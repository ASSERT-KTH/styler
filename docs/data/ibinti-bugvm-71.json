{
    "project_name": "ibinti-bugvm",
    "error_id": "71",
    "information": {
        "errors": [
            {
                "line": "95",
                "severity": "error",
                "message": "Line is longer than 80 characters (found 83).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": " * memory synchronization semantics as provided by the built-in monitor\n * lock, as described in\n * <a href=\"http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4\">\n * The Java Language Specification (17.4 Memory Model)</a>:\n * <ul>\n * <li>A successful {@code lock} operation has the same memory",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "95",
                    "severity": "error",
                    "message": "Line is longer than 80 characters (found 83).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "96",
                    "severity": "error",
                    "message": "Line is longer than 80 characters (found 83).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "200",
                    "severity": "error",
                    "message": "Line is longer than 80 characters (found 88).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "288",
                    "severity": "error",
                    "message": "Line is longer than 80 characters (found 84).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "324",
                    "severity": "error",
                    "message": "Line is longer than 80 characters (found 85).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/ibinti-bugvm/errored/1/71/Lock.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/ibinti-bugvm/intellij/71/Lock.java\nindex 6eeb236a7e7..258d443c63d 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/ibinti-bugvm/errored/1/71/Lock.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/ibinti-bugvm/intellij/71/Lock.java\n@@ -5,6 +5,7 @@\n  */\n \n package java.util.concurrent.locks;\n+\n import java.util.concurrent.TimeUnit;\n \n /**\n@@ -48,7 +49,7 @@ import java.util.concurrent.TimeUnit;\n  * methods and statements. In most cases, the following idiom\n  * should be used:\n  *\n- *  <pre> {@code\n+ * <pre> {@code\n  * Lock l = ...;\n  * l.lock();\n  * try {\n@@ -56,7 +57,7 @@ import java.util.concurrent.TimeUnit;\n  * } finally {\n  *   l.unlock();\n  * }}</pre>\n- *\n+ * <p>\n  * When locking and unlocking occur in different scopes, care must be\n  * taken to ensure that all code that is executed while the lock is\n  * held is protected by try-finally or try-catch to ensure that the\n@@ -100,7 +101,7 @@ import java.util.concurrent.TimeUnit;\n  * <li>A successful {@code unlock} operation has the same\n  * memory synchronization effects as a successful <em>Unlock</em> action.\n  * </ul>\n- *\n+ * <p>\n  * Unsuccessful locking and unlocking operations, and reentrant\n  * locking/unlocking operations, do not require any memory\n  * synchronization effects.\n@@ -128,201 +129,199 @@ import java.util.concurrent.TimeUnit;\n  * shown that the interrupt occurred after another action may have unblocked\n  * the thread. An implementation should document this behavior.\n  *\n+ * @author Doug Lea\n  * @see ReentrantLock\n  * @see Condition\n  * @see ReadWriteLock\n- *\n  * @since 1.5\n- * @author Doug Lea\n  */\n public interface Lock {\n \n-    /**\n-     * Acquires the lock.\n-     *\n-     * <p>If the lock is not available then the current thread becomes\n-     * disabled for thread scheduling purposes and lies dormant until the\n-     * lock has been acquired.\n-     *\n-     * <p><b>Implementation Considerations</b>\n-     *\n-     * <p>A {@code Lock} implementation may be able to detect erroneous use\n-     * of the lock, such as an invocation that would cause deadlock, and\n-     * may throw an (unchecked) exception in such circumstances.  The\n-     * circumstances and the exception type must be documented by that\n-     * {@code Lock} implementation.\n-     */\n-    void lock();\n+  /**\n+   * Acquires the lock.\n+   *\n+   * <p>If the lock is not available then the current thread becomes\n+   * disabled for thread scheduling purposes and lies dormant until the\n+   * lock has been acquired.\n+   *\n+   * <p><b>Implementation Considerations</b>\n+   *\n+   * <p>A {@code Lock} implementation may be able to detect erroneous use\n+   * of the lock, such as an invocation that would cause deadlock, and\n+   * may throw an (unchecked) exception in such circumstances.  The\n+   * circumstances and the exception type must be documented by that\n+   * {@code Lock} implementation.\n+   */\n+  void lock();\n \n-    /**\n-     * Acquires the lock unless the current thread is\n-     * {@linkplain Thread#interrupt interrupted}.\n-     *\n-     * <p>Acquires the lock if it is available and returns immediately.\n-     *\n-     * <p>If the lock is not available then the current thread becomes\n-     * disabled for thread scheduling purposes and lies dormant until\n-     * one of two things happens:\n-     *\n-     * <ul>\n-     * <li>The lock is acquired by the current thread; or\n-     * <li>Some other thread {@linkplain Thread#interrupt interrupts} the\n-     * current thread, and interruption of lock acquisition is supported.\n-     * </ul>\n-     *\n-     * <p>If the current thread:\n-     * <ul>\n-     * <li>has its interrupted status set on entry to this method; or\n-     * <li>is {@linkplain Thread#interrupt interrupted} while acquiring the\n-     * lock, and interruption of lock acquisition is supported,\n-     * </ul>\n-     * then {@link InterruptedException} is thrown and the current thread's\n-     * interrupted status is cleared.\n-     *\n-     * <p><b>Implementation Considerations</b>\n-     *\n-     * <p>The ability to interrupt a lock acquisition in some\n-     * implementations may not be possible, and if possible may be an\n-     * expensive operation.  The programmer should be aware that this\n-     * may be the case. An implementation should document when this is\n-     * the case.\n-     *\n-     * <p>An implementation can favor responding to an interrupt over\n-     * normal method return.\n-     *\n-     * <p>A {@code Lock} implementation may be able to detect\n-     * erroneous use of the lock, such as an invocation that would\n-     * cause deadlock, and may throw an (unchecked) exception in such\n-     * circumstances.  The circumstances and the exception type must\n-     * be documented by that {@code Lock} implementation.\n-     *\n-     * @throws InterruptedException if the current thread is\n-     *         interrupted while acquiring the lock (and interruption\n-     *         of lock acquisition is supported)\n-     */\n-    void lockInterruptibly() throws InterruptedException;\n+  /**\n+   * Acquires the lock unless the current thread is\n+   * {@linkplain Thread#interrupt interrupted}.\n+   *\n+   * <p>Acquires the lock if it is available and returns immediately.\n+   *\n+   * <p>If the lock is not available then the current thread becomes\n+   * disabled for thread scheduling purposes and lies dormant until\n+   * one of two things happens:\n+   *\n+   * <ul>\n+   * <li>The lock is acquired by the current thread; or\n+   * <li>Some other thread {@linkplain Thread#interrupt interrupts} the\n+   * current thread, and interruption of lock acquisition is supported.\n+   * </ul>\n+   *\n+   * <p>If the current thread:\n+   * <ul>\n+   * <li>has its interrupted status set on entry to this method; or\n+   * <li>is {@linkplain Thread#interrupt interrupted} while acquiring the\n+   * lock, and interruption of lock acquisition is supported,\n+   * </ul>\n+   * then {@link InterruptedException} is thrown and the current thread's\n+   * interrupted status is cleared.\n+   *\n+   * <p><b>Implementation Considerations</b>\n+   *\n+   * <p>The ability to interrupt a lock acquisition in some\n+   * implementations may not be possible, and if possible may be an\n+   * expensive operation.  The programmer should be aware that this\n+   * may be the case. An implementation should document when this is\n+   * the case.\n+   *\n+   * <p>An implementation can favor responding to an interrupt over\n+   * normal method return.\n+   *\n+   * <p>A {@code Lock} implementation may be able to detect\n+   * erroneous use of the lock, such as an invocation that would\n+   * cause deadlock, and may throw an (unchecked) exception in such\n+   * circumstances.  The circumstances and the exception type must\n+   * be documented by that {@code Lock} implementation.\n+   *\n+   * @throws InterruptedException if the current thread is\n+   *                              interrupted while acquiring the lock (and interruption\n+   *                              of lock acquisition is supported)\n+   */\n+  void lockInterruptibly() throws InterruptedException;\n \n-    /**\n-     * Acquires the lock only if it is free at the time of invocation.\n-     *\n-     * <p>Acquires the lock if it is available and returns immediately\n-     * with the value {@code true}.\n-     * If the lock is not available then this method will return\n-     * immediately with the value {@code false}.\n-     *\n-     * <p>A typical usage idiom for this method would be:\n-     *  <pre> {@code\n-     * Lock lock = ...;\n-     * if (lock.tryLock()) {\n-     *   try {\n-     *     // manipulate protected state\n-     *   } finally {\n-     *     lock.unlock();\n-     *   }\n-     * } else {\n-     *   // perform alternative actions\n-     * }}</pre>\n-     *\n-     * This usage ensures that the lock is unlocked if it was acquired, and\n-     * doesn't try to unlock if the lock was not acquired.\n-     *\n-     * @return {@code true} if the lock was acquired and\n-     *         {@code false} otherwise\n-     */\n-    boolean tryLock();\n+  /**\n+   * Acquires the lock only if it is free at the time of invocation.\n+   *\n+   * <p>Acquires the lock if it is available and returns immediately\n+   * with the value {@code true}.\n+   * If the lock is not available then this method will return\n+   * immediately with the value {@code false}.\n+   *\n+   * <p>A typical usage idiom for this method would be:\n+   * <pre> {@code\n+   * Lock lock = ...;\n+   * if (lock.tryLock()) {\n+   *   try {\n+   *     // manipulate protected state\n+   *   } finally {\n+   *     lock.unlock();\n+   *   }\n+   * } else {\n+   *   // perform alternative actions\n+   * }}</pre>\n+   * <p>\n+   * This usage ensures that the lock is unlocked if it was acquired, and\n+   * doesn't try to unlock if the lock was not acquired.\n+   *\n+   * @return {@code true} if the lock was acquired and\n+   * {@code false} otherwise\n+   */\n+  boolean tryLock();\n \n-    /**\n-     * Acquires the lock if it is free within the given waiting time and the\n-     * current thread has not been {@linkplain Thread#interrupt interrupted}.\n-     *\n-     * <p>If the lock is available this method returns immediately\n-     * with the value {@code true}.\n-     * If the lock is not available then\n-     * the current thread becomes disabled for thread scheduling\n-     * purposes and lies dormant until one of three things happens:\n-     * <ul>\n-     * <li>The lock is acquired by the current thread; or\n-     * <li>Some other thread {@linkplain Thread#interrupt interrupts} the\n-     * current thread, and interruption of lock acquisition is supported; or\n-     * <li>The specified waiting time elapses\n-     * </ul>\n-     *\n-     * <p>If the lock is acquired then the value {@code true} is returned.\n-     *\n-     * <p>If the current thread:\n-     * <ul>\n-     * <li>has its interrupted status set on entry to this method; or\n-     * <li>is {@linkplain Thread#interrupt interrupted} while acquiring\n-     * the lock, and interruption of lock acquisition is supported,\n-     * </ul>\n-     * then {@link InterruptedException} is thrown and the current thread's\n-     * interrupted status is cleared.\n-     *\n-     * <p>If the specified waiting time elapses then the value {@code false}\n-     * is returned.\n-     * If the time is\n-     * less than or equal to zero, the method will not wait at all.\n-     *\n-     * <p><b>Implementation Considerations</b>\n-     *\n-     * <p>The ability to interrupt a lock acquisition in some implementations\n-     * may not be possible, and if possible may\n-     * be an expensive operation.\n-     * The programmer should be aware that this may be the case. An\n-     * implementation should document when this is the case.\n-     *\n-     * <p>An implementation can favor responding to an interrupt over normal\n-     * method return, or reporting a timeout.\n-     *\n-     * <p>A {@code Lock} implementation may be able to detect\n-     * erroneous use of the lock, such as an invocation that would cause\n-     * deadlock, and may throw an (unchecked) exception in such circumstances.\n-     * The circumstances and the exception type must be documented by that\n-     * {@code Lock} implementation.\n-     *\n-     * @param time the maximum time to wait for the lock\n-     * @param unit the time unit of the {@code time} argument\n-     * @return {@code true} if the lock was acquired and {@code false}\n-     *         if the waiting time elapsed before the lock was acquired\n-     *\n-     * @throws InterruptedException if the current thread is interrupted\n-     *         while acquiring the lock (and interruption of lock\n-     *         acquisition is supported)\n-     */\n-    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;\n+  /**\n+   * Acquires the lock if it is free within the given waiting time and the\n+   * current thread has not been {@linkplain Thread#interrupt interrupted}.\n+   *\n+   * <p>If the lock is available this method returns immediately\n+   * with the value {@code true}.\n+   * If the lock is not available then\n+   * the current thread becomes disabled for thread scheduling\n+   * purposes and lies dormant until one of three things happens:\n+   * <ul>\n+   * <li>The lock is acquired by the current thread; or\n+   * <li>Some other thread {@linkplain Thread#interrupt interrupts} the\n+   * current thread, and interruption of lock acquisition is supported; or\n+   * <li>The specified waiting time elapses\n+   * </ul>\n+   *\n+   * <p>If the lock is acquired then the value {@code true} is returned.\n+   *\n+   * <p>If the current thread:\n+   * <ul>\n+   * <li>has its interrupted status set on entry to this method; or\n+   * <li>is {@linkplain Thread#interrupt interrupted} while acquiring\n+   * the lock, and interruption of lock acquisition is supported,\n+   * </ul>\n+   * then {@link InterruptedException} is thrown and the current thread's\n+   * interrupted status is cleared.\n+   *\n+   * <p>If the specified waiting time elapses then the value {@code false}\n+   * is returned.\n+   * If the time is\n+   * less than or equal to zero, the method will not wait at all.\n+   *\n+   * <p><b>Implementation Considerations</b>\n+   *\n+   * <p>The ability to interrupt a lock acquisition in some implementations\n+   * may not be possible, and if possible may\n+   * be an expensive operation.\n+   * The programmer should be aware that this may be the case. An\n+   * implementation should document when this is the case.\n+   *\n+   * <p>An implementation can favor responding to an interrupt over normal\n+   * method return, or reporting a timeout.\n+   *\n+   * <p>A {@code Lock} implementation may be able to detect\n+   * erroneous use of the lock, such as an invocation that would cause\n+   * deadlock, and may throw an (unchecked) exception in such circumstances.\n+   * The circumstances and the exception type must be documented by that\n+   * {@code Lock} implementation.\n+   *\n+   * @param time the maximum time to wait for the lock\n+   * @param unit the time unit of the {@code time} argument\n+   * @return {@code true} if the lock was acquired and {@code false}\n+   * if the waiting time elapsed before the lock was acquired\n+   * @throws InterruptedException if the current thread is interrupted\n+   *                              while acquiring the lock (and interruption of lock\n+   *                              acquisition is supported)\n+   */\n+  boolean tryLock(long time, TimeUnit unit) throws InterruptedException;\n \n-    /**\n-     * Releases the lock.\n-     *\n-     * <p><b>Implementation Considerations</b>\n-     *\n-     * <p>A {@code Lock} implementation will usually impose\n-     * restrictions on which thread can release a lock (typically only the\n-     * holder of the lock can release it) and may throw\n-     * an (unchecked) exception if the restriction is violated.\n-     * Any restrictions and the exception\n-     * type must be documented by that {@code Lock} implementation.\n-     */\n-    void unlock();\n+  /**\n+   * Releases the lock.\n+   *\n+   * <p><b>Implementation Considerations</b>\n+   *\n+   * <p>A {@code Lock} implementation will usually impose\n+   * restrictions on which thread can release a lock (typically only the\n+   * holder of the lock can release it) and may throw\n+   * an (unchecked) exception if the restriction is violated.\n+   * Any restrictions and the exception\n+   * type must be documented by that {@code Lock} implementation.\n+   */\n+  void unlock();\n \n-    /**\n-     * Returns a new {@link Condition} instance that is bound to this\n-     * {@code Lock} instance.\n-     *\n-     * <p>Before waiting on the condition the lock must be held by the\n-     * current thread.\n-     * A call to {@link Condition#await()} will atomically release the lock\n-     * before waiting and re-acquire the lock before the wait returns.\n-     *\n-     * <p><b>Implementation Considerations</b>\n-     *\n-     * <p>The exact operation of the {@link Condition} instance depends on\n-     * the {@code Lock} implementation and must be documented by that\n-     * implementation.\n-     *\n-     * @return A new {@link Condition} instance for this {@code Lock} instance\n-     * @throws UnsupportedOperationException if this {@code Lock}\n-     *         implementation does not support conditions\n-     */\n-    Condition newCondition();\n+  /**\n+   * Returns a new {@link Condition} instance that is bound to this\n+   * {@code Lock} instance.\n+   *\n+   * <p>Before waiting on the condition the lock must be held by the\n+   * current thread.\n+   * A call to {@link Condition#await()} will atomically release the lock\n+   * before waiting and re-acquire the lock before the wait returns.\n+   *\n+   * <p><b>Implementation Considerations</b>\n+   *\n+   * <p>The exact operation of the {@link Condition} instance depends on\n+   * the {@code Lock} implementation and must be documented by that\n+   * implementation.\n+   *\n+   * @return A new {@link Condition} instance for this {@code Lock} instance\n+   * @throws UnsupportedOperationException if this {@code Lock}\n+   *                                       implementation does not support conditions\n+   */\n+  Condition newCondition();\n }\n",
            "diff_size": 190
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "95",
                    "severity": "error",
                    "message": "Line is longer than 80 characters (found 83).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/ibinti-bugvm/errored/1/71/Lock.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/ibinti-bugvm/naturalize/71/Lock.java\nindex 6eeb236a7e7..1407626f46e 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/ibinti-bugvm/errored/1/71/Lock.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/ibinti-bugvm/naturalize/71/Lock.java\n@@ -325,4 +325,4 @@ public interface Lock {\n      *         implementation does not support conditions\n      */\n     Condition newCondition();\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 1
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "96",
                    "severity": "error",
                    "message": "Line is longer than 80 characters (found 83).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/ibinti-bugvm/errored/1/71/Lock.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/ibinti-bugvm/codebuff/71/Lock.java\nindex 6eeb236a7e7..9d0b43f81d6 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/ibinti-bugvm/errored/1/71/Lock.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/ibinti-bugvm/codebuff/71/Lock.java\n@@ -5,6 +5,7 @@\n  */\n \n package java.util.concurrent.locks;\n+\n import java.util.concurrent.TimeUnit;\n \n /**\n@@ -135,6 +136,8 @@ import java.util.concurrent.TimeUnit;\n  * @since 1.5\n  * @author Doug Lea\n  */\n+\n+\n public interface Lock {\n \n     /**\n@@ -152,6 +155,8 @@ public interface Lock {\n      * circumstances and the exception type must be documented by that\n      * {@code Lock} implementation.\n      */\n+\n+\n     void lock();\n \n     /**\n@@ -200,6 +205,8 @@ public interface Lock {\n      *         interrupted while acquiring the lock (and interruption\n      *         of lock acquisition is supported)\n      */\n+\n+\n     void lockInterruptibly() throws InterruptedException;\n \n     /**\n@@ -229,6 +236,8 @@ public interface Lock {\n      * @return {@code true} if the lock was acquired and\n      *         {@code false} otherwise\n      */\n+\n+\n     boolean tryLock();\n \n     /**\n@@ -289,6 +298,8 @@ public interface Lock {\n      *         while acquiring the lock (and interruption of lock\n      *         acquisition is supported)\n      */\n+\n+\n     boolean tryLock(long time, TimeUnit unit) throws InterruptedException;\n \n     /**\n@@ -303,6 +314,8 @@ public interface Lock {\n      * Any restrictions and the exception\n      * type must be documented by that {@code Lock} implementation.\n      */\n+\n+\n     void unlock();\n \n     /**\n@@ -324,5 +337,7 @@ public interface Lock {\n      * @throws UnsupportedOperationException if this {@code Lock}\n      *         implementation does not support conditions\n      */\n+\n+\n     Condition newCondition();\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 16
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "95",
                    "severity": "error",
                    "message": "Line is longer than 80 characters (found 83).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "94",
                    "severity": "error",
                    "message": "Line is longer than 80 characters (found 83).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/ibinti-bugvm/errored/1/71/Lock.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/ibinti-bugvm/styler_three_grams/71/Lock.java\nindex 6eeb236a7e7..5d1e3587e31 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/ibinti-bugvm/errored/1/71/Lock.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/ibinti-bugvm/styler_three_grams/71/Lock.java\n@@ -6,7 +6,6 @@\n \n package java.util.concurrent.locks;\n import java.util.concurrent.TimeUnit;\n-\n /**\n  * {@code Lock} implementations provide more extensive locking\n  * operations than can be obtained using {@code synchronized} methods\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [],
    "not_repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}