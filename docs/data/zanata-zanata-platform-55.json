{
    "project_name": "zanata-zanata-platform",
    "error_id": "55",
    "information": {
        "errors": [
            {
                "line": "227",
                "column": "51",
                "severity": "error",
                "message": "':' is not preceded with whitespace.",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
            }
        ]
    },
    "source_code": "\n        List<Long> versionIds = getProjectVersions().stream()\n                .map(it -> it != null ? it.getId(): null)\n                .collect(toList());\n        return activityServiceImpl.findLatestVersionActivitiesByUser(\n                currentUser.getPerson().getId(),",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/55/ProjectHomeAction.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/styler/55/ProjectHomeAction.java\nindex 9d89c478c5f..17db3b4579a 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/55/ProjectHomeAction.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/styler/55/ProjectHomeAction.java\n@@ -224,7 +224,7 @@ public class ProjectHomeAction extends AbstractSortAction\n         }\n \n         List<Long> versionIds = getProjectVersions().stream()\n-                .map(it -> it != null ? it.getId(): null)\n+                .map(it -> it != null ? it.getId() : null)\n                 .collect(toList());\n         return activityServiceImpl.findLatestVersionActivitiesByUser(\n                 currentUser.getPerson().getId(),\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/55/ProjectHomeAction.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/intellij/55/ProjectHomeAction.java\nindex 9d89c478c5f..c5ea6bed642 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/55/ProjectHomeAction.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/intellij/55/ProjectHomeAction.java\n@@ -18,6 +18,7 @@\n  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA, or see the FSF\n  * site: http://www.fsf.org.\n  */\n+\n package org.zanata.action;\n \n import java.io.Serializable;\n@@ -95,810 +96,810 @@ import static org.zanata.model.ProjectRole.TranslationMaintainer;\n @Model\n @Transactional\n public class ProjectHomeAction extends AbstractSortAction\n-        implements Serializable {\n-    public static final Ordering<LocaleRole> LOCALE_ROLE_ORDERING =\n-            Ordering.explicit(LocaleRole.Translator, LocaleRole.Reviewer,\n-                    LocaleRole.Coordinator, LocaleRole.Glossarist);\n-    private static final long serialVersionUID = -5163376385991003306L;\n-    @Inject\n-    private ActivityService activityServiceImpl;\n-    @Inject\n-    private LocaleService localeServiceImpl;\n-    @Inject\n-    private VersionStateCache versionStateCacheImpl;\n-    @Inject\n-    private LocaleMemberDAO localeMemberDAO;\n-    @Inject\n-    private CurrentUser currentUser;\n-    @Inject\n-    private ZanataIdentity identity;\n-    @Inject\n-    private CopyVersionManager copyVersionManager;\n-    @Inject\n-    private Messages msgs;\n-    private String slug;\n-    @Inject\n-    private ProjectDAO projectDAO;\n-    @Inject\n-    private ProjectIterationDAO projectIterationDAO;\n-    @Inject\n-    private FacesMessages facesMessages;\n-    @Inject\n-    private GlossaryDAO glossaryDAO;\n-    private SortingType VersionSortingList = new SortingType(Lists.newArrayList(\n-            SortingType.SortOption.ALPHABETICAL, SortingType.SortOption.HOURS,\n-            SortingType.SortOption.PERCENTAGE, SortingType.SortOption.WORDS,\n-            SortingType.SortOption.LAST_ACTIVITY));\n-    private boolean pageRendered = false;\n-    private AbstractListFilter<HProjectIteration> versionFilter =\n-            new InMemoryListFilter<HProjectIteration>() {\n-\n-                private static final long serialVersionUID =\n-                        7931445158995457207L;\n-\n-                @Override\n-                protected List<HProjectIteration> fetchAll() {\n-                    return getProjectVersions();\n-                }\n-\n-                @Override\n-                protected boolean include(HProjectIteration elem,\n-                        String filter) {\n-                    return containsIgnoreCase(elem.getSlug(),\n-                            filter);\n-                }\n-            };\n-    private final SortingType PeopleSortingList =\n-            new SortingType(\n-                    Lists.newArrayList(SortingType.SortOption.NAME,\n-                            SortingType.SortOption.ROLE),\n-                    SortingType.SortOption.NAME);\n-    private final PeopleFilterComparator peopleFilterComparator =\n-            new PeopleFilterComparator(getPeopleSortingList());\n-    private ListMultimap<HPerson, ProjectRole> personRoles;\n-    private Map<HPerson, ListMultimap<HLocale, LocaleRole>> personLocaleRoles;\n-    private List<HProjectIteration> projectVersions;\n-    private Map<String, WordStatistic> statisticMap = new HashMap<>();\n-    @SuppressFBWarnings(value = \"SE_BAD_FIELD\")\n-    private final VersionComparator versionComparator =\n-            new VersionComparator(getVersionSortingList());\n-    private final AtomicReference<Object> projectLastActivity =\n-            new AtomicReference<>();\n-    private HProject project;\n-    // for storing last activity date for the version\n-    private Map<Long, Date> versionLatestActivityDate = new HashMap<>();\n-\n-    public boolean isVersionCopying(String projectSlug, String versionSlug) {\n-        return copyVersionManager.isCopyVersionRunning(projectSlug,\n-                versionSlug);\n-    }\n-\n-    public String getCopiedDocumentCount(String projectSlug,\n-            String versionSlug) {\n-        CopyVersionTaskHandle handler = copyVersionManager\n-                .getCopyVersionProcessHandle(projectSlug, versionSlug);\n-        if (handler == null) {\n-            return \"0\";\n-        } else {\n-            return String.valueOf(handler.getDocumentCopied());\n-        }\n-    }\n-\n-    public void cancelCopyVersion(String projectSlug, String versionSlug) {\n-        copyVersionManager.cancelCopyVersion(projectSlug, versionSlug);\n-        facesMessages.addGlobal(msgs.format(\"jsf.copyVersion.Cancelled\",\n-                versionSlug));\n-    }\n-\n-    public String getCopyVersionCompletePercent(String projectSlug,\n-            String versionSlug) {\n-        CopyVersionTaskHandle handler = copyVersionManager\n-                .getCopyVersionProcessHandle(projectSlug, versionSlug);\n-        if (handler != null) {\n-            double completedPercent = (double) handler.getCurrentProgress()\n-                    / (double) handler.getMaxProgress() * 100;\n-            if (Double.compare(completedPercent, 100) == 0) {\n-                facesMessages.addGlobal(msgs.format(\"jsf.copyVersion.Completed\",\n-                        versionSlug));\n-            }\n-            return String.format(\"%1$,.2f\", completedPercent);\n-        } else {\n-            return \"0\";\n-        }\n-    }\n-\n-    public String getCopyVersionTotalDocuments(String projectSlug,\n-            String versionSlug) {\n-        CopyVersionTaskHandle handler = copyVersionManager\n-                .getCopyVersionProcessHandle(projectSlug, versionSlug);\n-        if (handler == null) {\n-            return \"0\";\n-        } else {\n-            return String.valueOf(handler.getTotalDoc());\n-        }\n-    }\n-\n-    private List<Activity> fetchProjectLastActivity() {\n-        if (StringUtils.isEmpty(slug) || !identity.isLoggedIn()) {\n-            return Collections.emptyList();\n-        }\n-\n-        List<Long> versionIds = getProjectVersions().stream()\n-                .map(it -> it != null ? it.getId(): null)\n-                .collect(toList());\n-        return activityServiceImpl.findLatestVersionActivitiesByUser(\n-                currentUser.getPerson().getId(),\n-                versionIds, 0, 1);\n-    }\n-\n-    public DisplayUnit getStatisticFigureForVersion(\n-            SortingType.SortOption sortOption, HProjectIteration version) {\n-        WordStatistic statistic = getStatisticForVersion(version.getSlug());\n-        return getDisplayUnit(sortOption, statistic, version.getLastChanged());\n+  implements Serializable {\n+  public static final Ordering<LocaleRole> LOCALE_ROLE_ORDERING =\n+    Ordering.explicit(LocaleRole.Translator, LocaleRole.Reviewer,\n+      LocaleRole.Coordinator, LocaleRole.Glossarist);\n+  private static final long serialVersionUID = -5163376385991003306L;\n+  @Inject\n+  private ActivityService activityServiceImpl;\n+  @Inject\n+  private LocaleService localeServiceImpl;\n+  @Inject\n+  private VersionStateCache versionStateCacheImpl;\n+  @Inject\n+  private LocaleMemberDAO localeMemberDAO;\n+  @Inject\n+  private CurrentUser currentUser;\n+  @Inject\n+  private ZanataIdentity identity;\n+  @Inject\n+  private CopyVersionManager copyVersionManager;\n+  @Inject\n+  private Messages msgs;\n+  private String slug;\n+  @Inject\n+  private ProjectDAO projectDAO;\n+  @Inject\n+  private ProjectIterationDAO projectIterationDAO;\n+  @Inject\n+  private FacesMessages facesMessages;\n+  @Inject\n+  private GlossaryDAO glossaryDAO;\n+  private SortingType VersionSortingList = new SortingType(Lists.newArrayList(\n+    SortingType.SortOption.ALPHABETICAL, SortingType.SortOption.HOURS,\n+    SortingType.SortOption.PERCENTAGE, SortingType.SortOption.WORDS,\n+    SortingType.SortOption.LAST_ACTIVITY));\n+  private boolean pageRendered = false;\n+  private AbstractListFilter<HProjectIteration> versionFilter =\n+    new InMemoryListFilter<HProjectIteration>() {\n+\n+      private static final long serialVersionUID =\n+        7931445158995457207L;\n+\n+      @Override\n+      protected List<HProjectIteration> fetchAll() {\n+        return getProjectVersions();\n+      }\n+\n+      @Override\n+      protected boolean include(HProjectIteration elem,\n+                                String filter) {\n+        return containsIgnoreCase(elem.getSlug(),\n+          filter);\n+      }\n+    };\n+  private final SortingType PeopleSortingList =\n+    new SortingType(\n+      Lists.newArrayList(SortingType.SortOption.NAME,\n+        SortingType.SortOption.ROLE),\n+      SortingType.SortOption.NAME);\n+  private final PeopleFilterComparator peopleFilterComparator =\n+    new PeopleFilterComparator(getPeopleSortingList());\n+  private ListMultimap<HPerson, ProjectRole> personRoles;\n+  private Map<HPerson, ListMultimap<HLocale, LocaleRole>> personLocaleRoles;\n+  private List<HProjectIteration> projectVersions;\n+  private Map<String, WordStatistic> statisticMap = new HashMap<>();\n+  @SuppressFBWarnings(value = \"SE_BAD_FIELD\")\n+  private final VersionComparator versionComparator =\n+    new VersionComparator(getVersionSortingList());\n+  private final AtomicReference<Object> projectLastActivity =\n+    new AtomicReference<>();\n+  private HProject project;\n+  // for storing last activity date for the version\n+  private Map<Long, Date> versionLatestActivityDate = new HashMap<>();\n+\n+  public boolean isVersionCopying(String projectSlug, String versionSlug) {\n+    return copyVersionManager.isCopyVersionRunning(projectSlug,\n+      versionSlug);\n+  }\n+\n+  public String getCopiedDocumentCount(String projectSlug,\n+                                       String versionSlug) {\n+    CopyVersionTaskHandle handler = copyVersionManager\n+      .getCopyVersionProcessHandle(projectSlug, versionSlug);\n+    if (handler == null) {\n+      return \"0\";\n+    } else {\n+      return String.valueOf(handler.getDocumentCopied());\n+    }\n+  }\n+\n+  public void cancelCopyVersion(String projectSlug, String versionSlug) {\n+    copyVersionManager.cancelCopyVersion(projectSlug, versionSlug);\n+    facesMessages.addGlobal(msgs.format(\"jsf.copyVersion.Cancelled\",\n+      versionSlug));\n+  }\n+\n+  public String getCopyVersionCompletePercent(String projectSlug,\n+                                              String versionSlug) {\n+    CopyVersionTaskHandle handler = copyVersionManager\n+      .getCopyVersionProcessHandle(projectSlug, versionSlug);\n+    if (handler != null) {\n+      double completedPercent = (double) handler.getCurrentProgress()\n+        / (double) handler.getMaxProgress() * 100;\n+      if (Double.compare(completedPercent, 100) == 0) {\n+        facesMessages.addGlobal(msgs.format(\"jsf.copyVersion.Completed\",\n+          versionSlug));\n+      }\n+      return String.format(\"%1$,.2f\", completedPercent);\n+    } else {\n+      return \"0\";\n+    }\n+  }\n+\n+  public String getCopyVersionTotalDocuments(String projectSlug,\n+                                             String versionSlug) {\n+    CopyVersionTaskHandle handler = copyVersionManager\n+      .getCopyVersionProcessHandle(projectSlug, versionSlug);\n+    if (handler == null) {\n+      return \"0\";\n+    } else {\n+      return String.valueOf(handler.getTotalDoc());\n+    }\n+  }\n+\n+  private List<Activity> fetchProjectLastActivity() {\n+    if (StringUtils.isEmpty(slug) || !identity.isLoggedIn()) {\n+      return Collections.emptyList();\n+    }\n+\n+    List<Long> versionIds = getProjectVersions().stream()\n+      .map(it -> it != null ? it.getId() : null)\n+      .collect(toList());\n+    return activityServiceImpl.findLatestVersionActivitiesByUser(\n+      currentUser.getPerson().getId(),\n+      versionIds, 0, 1);\n+  }\n+\n+  public DisplayUnit getStatisticFigureForVersion(\n+    SortingType.SortOption sortOption, HProjectIteration version) {\n+    WordStatistic statistic = getStatisticForVersion(version.getSlug());\n+    return getDisplayUnit(sortOption, statistic, version.getLastChanged());\n+  }\n+\n+  /**\n+   * Sort version list\n+   */\n+  public void sortVersionList() {\n+    Collections.sort(projectVersions, versionComparator);\n+    versionFilter.reset();\n+  }\n+\n+  private final class VersionComparator\n+    implements Comparator<HProjectIteration> {\n+    private SortingType sortingType;\n+\n+    public VersionComparator(SortingType sortingType) {\n+      this.sortingType = sortingType;\n     }\n \n-    /**\n-     * Sort version list\n-     */\n-    public void sortVersionList() {\n-        Collections.sort(projectVersions, versionComparator);\n-        versionFilter.reset();\n-    }\n-\n-    private final class VersionComparator\n-            implements Comparator<HProjectIteration> {\n-        private SortingType sortingType;\n-\n-        public VersionComparator(SortingType sortingType) {\n-            this.sortingType = sortingType;\n-        }\n-\n-        @Override\n-        public int compare(HProjectIteration o1, HProjectIteration o2) {\n-            SortingType.SortOption selectedSortOption =\n-                    sortingType.getSelectedSortOption();\n-            if (!selectedSortOption.isAscending()) {\n-                HProjectIteration temp = o1;\n-                o1 = o2;\n-                o2 = temp;\n-            }\n-            // Need to get statistic for comparison\n-            if (!selectedSortOption.equals(SortingType.SortOption.ALPHABETICAL)\n-                    && !selectedSortOption\n-                            .equals(SortingType.SortOption.LAST_ACTIVITY)) {\n-                WordStatistic wordStatistic1 =\n-                        getStatisticForVersion(o1.getSlug());\n-                WordStatistic wordStatistic2 =\n-                        getStatisticForVersion(o2.getSlug());\n-                if (selectedSortOption\n-                        .equals(SortingType.SortOption.PERCENTAGE)) {\n-                    return Double.compare(wordStatistic1.getPercentTranslated(),\n-                            wordStatistic2.getPercentTranslated());\n-                } else if (selectedSortOption\n-                        .equals(SortingType.SortOption.HOURS)) {\n-                    return Double.compare(wordStatistic1.getRemainingHours(),\n-                            wordStatistic2.getRemainingHours());\n-                } else if (selectedSortOption\n-                        .equals(SortingType.SortOption.WORDS)) {\n-                    if (wordStatistic1.getTotal() == wordStatistic2\n-                            .getTotal()) {\n-                        return 0;\n-                    }\n-                    return wordStatistic1.getTotal() > wordStatistic2.getTotal()\n-                            ? 1 : -1;\n-                }\n-            } else if (selectedSortOption\n-                    .equals(SortingType.SortOption.ALPHABETICAL)) {\n-                return o1.getSlug().compareToIgnoreCase(o2.getSlug());\n-            } else if (selectedSortOption\n-                    .equals(SortingType.SortOption.LAST_ACTIVITY)) {\n-                Date date1 = getVersionLastActivityDate(o1.getId());\n-                Date date2 = getVersionLastActivityDate(o2.getId());\n-                return DateUtil.compareDate(date1, date2);\n-            }\n+    @Override\n+    public int compare(HProjectIteration o1, HProjectIteration o2) {\n+      SortingType.SortOption selectedSortOption =\n+        sortingType.getSelectedSortOption();\n+      if (!selectedSortOption.isAscending()) {\n+        HProjectIteration temp = o1;\n+        o1 = o2;\n+        o2 = temp;\n+      }\n+      // Need to get statistic for comparison\n+      if (!selectedSortOption.equals(SortingType.SortOption.ALPHABETICAL)\n+        && !selectedSortOption\n+        .equals(SortingType.SortOption.LAST_ACTIVITY)) {\n+        WordStatistic wordStatistic1 =\n+          getStatisticForVersion(o1.getSlug());\n+        WordStatistic wordStatistic2 =\n+          getStatisticForVersion(o2.getSlug());\n+        if (selectedSortOption\n+          .equals(SortingType.SortOption.PERCENTAGE)) {\n+          return Double.compare(wordStatistic1.getPercentTranslated(),\n+            wordStatistic2.getPercentTranslated());\n+        } else if (selectedSortOption\n+          .equals(SortingType.SortOption.HOURS)) {\n+          return Double.compare(wordStatistic1.getRemainingHours(),\n+            wordStatistic2.getRemainingHours());\n+        } else if (selectedSortOption\n+          .equals(SortingType.SortOption.WORDS)) {\n+          if (wordStatistic1.getTotal() == wordStatistic2\n+            .getTotal()) {\n             return 0;\n-        }\n-    }\n-\n-    private Date getVersionLastActivityDate(Long versionId) {\n-        if (!versionLatestActivityDate.containsKey(versionId)) {\n-            List<Activity> activities = activityServiceImpl\n-                    .findLatestVersionActivities(versionId, 0, 1);\n-            if (!activities.isEmpty()) {\n-                versionLatestActivityDate.put(versionId,\n-                        activities.get(0).getLastChanged());\n-            } else {\n-                versionLatestActivityDate.put(versionId, null);\n-            }\n-        }\n-        return versionLatestActivityDate.get(versionId);\n-    }\n-\n-    public void clearVersionStats(String versionSlug) {\n-        statisticMap.remove(versionSlug);\n-    }\n-\n-    public WordStatistic getStatisticForVersion(String versionSlug) {\n-        WordStatistic statistic;\n-        if (statisticMap.containsKey(versionSlug)) {\n-            statistic = statisticMap.get(versionSlug);\n-        } else {\n-            HProjectIteration version =\n-                    projectIterationDAO.getBySlug(slug, versionSlug);\n-            statistic = getAllLocaleStatisticForVersion(version);\n-            statisticMap.put(versionSlug, statistic);\n-        }\n-        statistic\n-                .setRemainingHours(StatisticsUtil.getRemainingHours(statistic));\n-        return statistic;\n+          }\n+          return wordStatistic1.getTotal() > wordStatistic2.getTotal()\n+            ? 1 : -1;\n+        }\n+      } else if (selectedSortOption\n+        .equals(SortingType.SortOption.ALPHABETICAL)) {\n+        return o1.getSlug().compareToIgnoreCase(o2.getSlug());\n+      } else if (selectedSortOption\n+        .equals(SortingType.SortOption.LAST_ACTIVITY)) {\n+        Date date1 = getVersionLastActivityDate(o1.getId());\n+        Date date2 = getVersionLastActivityDate(o2.getId());\n+        return DateUtil.compareDate(date1, date2);\n+      }\n+      return 0;\n+    }\n+  }\n+\n+  private Date getVersionLastActivityDate(Long versionId) {\n+    if (!versionLatestActivityDate.containsKey(versionId)) {\n+      List<Activity> activities = activityServiceImpl\n+        .findLatestVersionActivities(versionId, 0, 1);\n+      if (!activities.isEmpty()) {\n+        versionLatestActivityDate.put(versionId,\n+          activities.get(0).getLastChanged());\n+      } else {\n+        versionLatestActivityDate.put(versionId, null);\n+      }\n+    }\n+    return versionLatestActivityDate.get(versionId);\n+  }\n+\n+  public void clearVersionStats(String versionSlug) {\n+    statisticMap.remove(versionSlug);\n+  }\n+\n+  public WordStatistic getStatisticForVersion(String versionSlug) {\n+    WordStatistic statistic;\n+    if (statisticMap.containsKey(versionSlug)) {\n+      statistic = statisticMap.get(versionSlug);\n+    } else {\n+      HProjectIteration version =\n+        projectIterationDAO.getBySlug(slug, versionSlug);\n+      statistic = getAllLocaleStatisticForVersion(version);\n+      statisticMap.put(versionSlug, statistic);\n+    }\n+    statistic\n+      .setRemainingHours(StatisticsUtil.getRemainingHours(statistic));\n+    return statistic;\n+  }\n+\n+  @Override\n+  protected void loadStatistics() {\n+    statisticMap.clear();\n+    for (HProjectIteration version : getProjectVersions()) {\n+      statisticMap.put(version.getSlug(),\n+        getAllLocaleStatisticForVersion(version));\n+    }\n+  }\n+\n+  private WordStatistic\n+  getAllLocaleStatisticForVersion(HProjectIteration version) {\n+    WordStatistic versionStats = new WordStatistic();\n+    List<HLocale> locales = getSupportedLocale(version);\n+    for (HLocale locale : locales) {\n+      versionStats.add(versionStateCacheImpl.getVersionStatistics(\n+        version.getId(), locale.getLocaleId()));\n+    }\n+    return versionStats;\n+  }\n+\n+  public List<HLocale> getSupportedLocale(HProjectIteration version) {\n+    if (version != null) {\n+      return localeServiceImpl.getSupportedLanguageByProjectIteration(\n+        slug, version.getSlug());\n+    }\n+    return Collections.emptyList();\n+  }\n+\n+  public List<HLocale> getUserJoinedLocales(HProjectIteration version) {\n+    if (!currentUser.isLoggedIn()) {\n+      return Collections.emptyList();\n+    }\n+    List<HLocale> userJoinedLocales = Lists.newArrayList();\n+    Long personId = currentUser.getPerson().getId();\n+    for (HLocale supportedLocale : getSupportedLocale(version)) {\n+      if (localeMemberDAO.isLocaleMember(personId,\n+        supportedLocale.getLocaleId())\n+        && isUserAllowedToTranslateOrReview(version,\n+        supportedLocale)) {\n+        userJoinedLocales.add(supportedLocale);\n+      }\n+    }\n+    return userJoinedLocales;\n+  }\n+  // return list of versions order by creation date\n+\n+  public List<HProjectIteration> getProjectVersions() {\n+    // Local DAO reference as this method is used from a dependent object\n+    // that may be out of bean scope.\n+    if (projectVersions == null) {\n+      projectVersions = projectDAO.getActiveIterations(slug);\n+      projectVersions.addAll(projectDAO.getReadOnlyIterations(slug));\n+      projectVersions\n+        .sort(ComparatorUtil.VERSION_CREATION_DATE_COMPARATOR);\n+    }\n+    return projectVersions;\n+  }\n+\n+  public HProject getProject() {\n+    if (project == null) {\n+      project = projectDAO.getBySlug(slug);\n+    }\n+    return project;\n+  }\n+\n+  public boolean isUserAllowedToTranslateOrReview(HProjectIteration version,\n+                                                  HLocale localeId) {\n+    return version != null && localeId != null && isIterationActive(version)\n+      && identity != null\n+      && (identity.hasPermissionWithAnyTargets(\"add-translation\",\n+      version.getProject(), localeId)\n+      || identity.hasPermissionWithAnyTargets(\n+      \"translation-review\", version.getProject(),\n+      localeId));\n+  }\n+\n+  private boolean isIterationActive(HProjectIteration version) {\n+    return version.isActive();\n+  }\n+\n+  public void setPageRendered(boolean pageRendered) {\n+    if (pageRendered) {\n+      loadStatistics();\n+    }\n+    this.pageRendered = pageRendered;\n+  }\n+\n+  @Override\n+  public void resetPageData() {\n+    projectVersions = null;\n+    versionFilter.reset();\n+    loadStatistics();\n+  }\n+\n+  @Override\n+  protected String getMessage(String key, Object... args) {\n+    return msgs.formatWithAnyArgs(key, args);\n+  }\n+\n+  public Map<HPerson, Collection<ProjectRole>> getMemberRoles() {\n+    return getPersonRoles().asMap();\n+  }\n+\n+  private ListMultimap<HPerson, ProjectRole> getPersonRoles() {\n+    if (personRoles == null) {\n+      populatePersonRoles();\n+    }\n+    return personRoles;\n+  }\n+\n+  private void populatePersonRoles() {\n+    personRoles = ArrayListMultimap.create();\n+    // This can be run from an ajax call that does not actually need to\n+    // render\n+    // personRoles. The null check prevents a NullPointerException in that\n+    // case, and the unused empty list is adequate\n+    if (getProject() != null) {\n+      for (HProjectMember membership : getProject().getMembers()) {\n+        personRoles.put(membership.getPerson(), membership.getRole());\n+      }\n+    }\n+  }\n+\n+  private Map<HPerson, ListMultimap<HLocale, LocaleRole>>\n+  getPersonLocaleRoles() {\n+    if (personLocaleRoles == null) {\n+      populatePersonLocaleRoles();\n+    }\n+    return personLocaleRoles;\n+  }\n+\n+  private void populatePersonLocaleRoles() {\n+    personLocaleRoles = new HashMap<>();\n+    // Project may be null if this is triggered from an ajax call that does\n+    // not actually need to render personLocaleRoles\n+    if (getProject() != null) {\n+      for (HProjectLocaleMember membership : getProject()\n+        .getLocaleMembers()) {\n+        final HPerson person = membership.getPerson();\n+        if (!personLocaleRoles.containsKey(person)) {\n+          final ListMultimap<HLocale, LocaleRole> localeRoles =\n+            ArrayListMultimap.create();\n+          personLocaleRoles.put(person, localeRoles);\n+        }\n+        personLocaleRoles.get(person).put(membership.getLocale(),\n+          membership.getRole());\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Clear data related to memberships so that it will be re-loaded from the\n+   * database next time it is needed for display.\n+   * <p>\n+   * This should be done whenever permissions are changed.\n+   */\n+  public void clearCachedMembershipData() {\n+    // Roles may have changed, so role lists are cleared so they will be\n+    // regenerated\n+    personRoles = null;\n+    personLocaleRoles = null;\n+    project = null;\n+    // Person may have no roles left and no longer belong in the list, so\n+    // ensure the list of people is refreshed.\n+    peopleFilterComparator.clearCachedData();\n+    peopleFilterComparator.sortPeopleList();\n+  }\n+\n+  public List<HPerson> getAllMembers() {\n+    final Set<HPerson> people = new HashSet<>(getMemberRoles().keySet());\n+    people.addAll(getPersonLocaleRoles().keySet());\n+    return Lists.newArrayList(people);\n+  }\n+\n+  public boolean isTranslator(HPerson person) {\n+    ListMultimap<HLocale, LocaleRole> map =\n+      getPersonLocaleRoles().get(person);\n+    return map != null && !map.isEmpty();\n+  }\n+\n+  public boolean isMaintainer(HPerson person) {\n+    List<ProjectRole> roles = getPersonRoles().get(person);\n+    return (roles == null || roles.isEmpty()) ? false\n+      : roles.contains(ProjectRole.Maintainer)\n+      || roles.contains(TranslationMaintainer);\n+  }\n+\n+  /**\n+   * Check whether a person has any project or locale membership in this\n+   * project.\n+   */\n+  public boolean isMember(HPerson person) {\n+    return getAllMembers().contains(person);\n+  }\n+\n+  /**\n+   * Get display names for all of a person's project and locale roles\n+   */\n+  public List<String> allRoleDisplayNames(HPerson person) {\n+    List<String> displayNames = Lists.newArrayList();\n+    displayNames.addAll(projectRoleDisplayNames(person));\n+    displayNames.addAll(languageRoleDisplayNames(person));\n+    return displayNames;\n+  }\n+\n+  /**\n+   * Get a list of the display name for every project-related role for a\n+   * person.\n+   */\n+  public Collection<String> projectRoleDisplayNames(HPerson person) {\n+    final Collection<ProjectRole> rolesForPerson =\n+      getMemberRoles().get(person);\n+    Collection<ProjectRole> roles;\n+    if (rolesForPerson == null) {\n+      roles = new ArrayList<>();\n+    } else {\n+      roles = new ArrayList<>(rolesForPerson);\n+    }\n+    // Maintainer role includes TranslationMaintainer privileges, so do not\n+    // show the lower-permission role.\n+    if (roles.contains(Maintainer)) {\n+      roles.remove(TranslationMaintainer);\n+    }\n+    return roles.stream().map(this::projectRoleDisplayName).collect(toList());\n+  }\n+\n+  /**\n+   * Get a list of the display name for every language-related role for a\n+   * person.\n+   */\n+  private List<String> languageRoleDisplayNames(HPerson person) {\n+    final ListMultimap<HLocale, LocaleRole> localeRolesMultimap =\n+      getPersonLocaleRoles().get(person);\n+    if (localeRolesMultimap == null) {\n+      return Collections.emptyList();\n+    }\n+\n+    return localeRolesMultimap.asMap().entrySet().stream()\n+      .map(TO_LOCALE_ROLES_DISPLAY_STRING)\n+      .sorted(Ordering.natural().onResultOf(\n+        s -> isNullOrEmpty(s) ? \"\" : s.toLowerCase()))\n+      .collect(toList());\n+  }\n+\n+  /**\n+   * Display string for just the roles for a person within a locale.\n+   */\n+  public Collection<String> rolesDisplayForLocale(HPerson person,\n+                                                  HLocale locale) {\n+    final ListMultimap<HLocale, LocaleRole> localesWithRoles =\n+      getPersonLocaleRoles().get(person);\n+    if (localesWithRoles == null) {\n+      return new ArrayList<>();\n+    }\n+    Collection<LocaleRole> roles = localesWithRoles.asMap().get(locale);\n+    if (roles == null) {\n+      return new ArrayList<>();\n+    }\n+    final List<LocaleRole> sortedRoles =\n+      LOCALE_ROLE_ORDERING.sortedCopy(roles);\n+\n+    final Stream<String> roleNames = sortedRoles.stream()\n+      .map(this::localeRoleDisplayName);\n+    return Lists.newArrayList(Joiner.on(\", \").join(roleNames.iterator()));\n+  }\n+\n+  @SuppressFBWarnings(\"SE_BAD_FIELD\")\n+  private final Function<Map.Entry<HLocale, Collection<LocaleRole>>, String>\n+    TO_LOCALE_ROLES_DISPLAY_STRING =\n+    new Function<Map.Entry<HLocale, Collection<LocaleRole>>, String>() {\n+\n+      @Nullable\n+      @Override\n+      public String apply(\n+        @Nullable Map.Entry<HLocale, Collection<LocaleRole>> entry) {\n+        if (entry != null) {\n+          final String localeName =\n+            entry.getKey().retrieveDisplayName();\n+          final List<LocaleRole> sortedRoles =\n+            LOCALE_ROLE_ORDERING\n+              .sortedCopy(entry.getValue());\n+\n+          Stream<String> roleNames = sortedRoles.stream()\n+            .map(it -> localeRoleDisplayName(it));\n+          return localeName + \" \" +\n+            Joiner.on(\", \").join(roleNames.iterator());\n+        }\n+        return null;\n+      }\n+    };\n+\n+  private String projectRoleDisplayName(ProjectRole role) {\n+    switch (role) {\n+    case Maintainer:\n+      return msgs.get(\"jsf.Maintainer\");\n+\n+    case TranslationMaintainer:\n+      return msgs.get(\"jsf.TranslationMaintainer\");\n+\n+    default:\n+      return \"\";\n+\n+    }\n+  }\n+\n+  public String localeRoleDisplayName(LocaleRole role) {\n+    switch (role) {\n+    case Translator:\n+      return msgs.get(\"jsf.Translator\");\n+\n+    case Reviewer:\n+      return msgs.get(\"jsf.Reviewer\");\n+\n+    case Coordinator:\n+      return msgs.get(\"jsf.Coordinator\");\n+\n+    case Glossarist:\n+      return msgs.get(\"jsf.Glossarist\");\n+\n+    default:\n+      return \"\";\n+\n+    }\n+  }\n+\n+  public int getGlossarySize() {\n+    String qualifiedName = GlossaryUtil.generateQualifiedName(\n+      GlossaryService.PROJECT_QUALIFIER_PREFIX, getSlug());\n+    return glossaryDAO.getEntriesCount(LocaleId.EN_US, null, qualifiedName);\n+  }\n+\n+  /**\n+   * Transform to extract the name of the locale from a HLocale (for sorting)\n+   * <p>\n+   * Use with {@link java.util.Collections#sort}\n+   */\n+  @SuppressFBWarnings(\"SE_BAD_FIELD\")\n+  public static final Function<HLocale, String> TO_LOCALE_NAME =\n+    new Function<HLocale, String>() {\n+\n+      @Nullable\n+      @Override\n+      public String apply(HLocale input) {\n+        // To lowercase to prevent non-caps values appearing after\n+        // all caps values (e.g. a appearing after Z)\n+        return input != null ?\n+          input.retrieveDisplayName().toLowerCase() : null;\n+      }\n+    };\n+  private static final Ordering<HLocale> LOCALE_NAME_ORDERING =\n+    Ordering.natural().onResultOf(TO_LOCALE_NAME::apply);\n+\n+  public final class PeopleFilterComparator\n+    extends InMemoryListFilter<HPerson> implements Comparator<HPerson> {\n+    private static final long serialVersionUID = 3905373873256076410L;\n+    private final ProjectRolePredicate projectRolePredicate =\n+      new ProjectRolePredicate();\n+    private final ProjectLocalePredicate projectLocalePredicate =\n+      new ProjectLocalePredicate();\n+    private SortingType sortingType;\n+    private boolean showMembersInGroup;\n+    private List<HPerson> allMembers;\n+    private Map<HLocale, List<HPerson>> localePersonMap;\n+\n+    public PeopleFilterComparator(SortingType sortingType) {\n+      this.sortingType = sortingType;\n     }\n \n     @Override\n-    protected void loadStatistics() {\n-        statisticMap.clear();\n-        for (HProjectIteration version : getProjectVersions()) {\n-            statisticMap.put(version.getSlug(),\n-                    getAllLocaleStatisticForVersion(version));\n-        }\n-    }\n-\n-    private WordStatistic\n-            getAllLocaleStatisticForVersion(HProjectIteration version) {\n-        WordStatistic versionStats = new WordStatistic();\n-        List<HLocale> locales = getSupportedLocale(version);\n-        for (HLocale locale : locales) {\n-            versionStats.add(versionStateCacheImpl.getVersionStatistics(\n-                    version.getId(), locale.getLocaleId()));\n-        }\n-        return versionStats;\n-    }\n-\n-    public List<HLocale> getSupportedLocale(HProjectIteration version) {\n-        if (version != null) {\n-            return localeServiceImpl.getSupportedLanguageByProjectIteration(\n-                    slug, version.getSlug());\n-        }\n-        return Collections.emptyList();\n+    public int compare(HPerson o1, HPerson o2) {\n+      SortingType.SortOption selectedSortOption =\n+        sortingType.getSelectedSortOption();\n+      if (!selectedSortOption.isAscending()) {\n+        HPerson temp = o1;\n+        o1 = o2;\n+        o2 = temp;\n+      }\n+      // this is set here as a workaround to prevent a separate API call\n+      // for the sort setting (according to aeng).\n+      setShowMembersInGroup(\n+        selectedSortOption.equals(SortingType.SortOption.ROLE));\n+      return o1.getAccount().getUsername().toLowerCase()\n+        .compareTo(o2.getAccount().getUsername().toLowerCase());\n     }\n \n-    public List<HLocale> getUserJoinedLocales(HProjectIteration version) {\n-        if (!currentUser.isLoggedIn()) {\n-            return Collections.emptyList();\n-        }\n-        List<HLocale> userJoinedLocales = Lists.newArrayList();\n-        Long personId = currentUser.getPerson().getId();\n-        for (HLocale supportedLocale : getSupportedLocale(version)) {\n-            if (localeMemberDAO.isLocaleMember(personId,\n-                    supportedLocale.getLocaleId())\n-                    && isUserAllowedToTranslateOrReview(version,\n-                            supportedLocale)) {\n-                userJoinedLocales.add(supportedLocale);\n-            }\n-        }\n-        return userJoinedLocales;\n-    }\n-    // return list of versions order by creation date\n-\n-    public List<HProjectIteration> getProjectVersions() {\n-        // Local DAO reference as this method is used from a dependent object\n-        // that may be out of bean scope.\n-        if (projectVersions == null) {\n-            projectVersions = projectDAO.getActiveIterations(slug);\n-            projectVersions.addAll(projectDAO.getReadOnlyIterations(slug));\n-            projectVersions\n-                    .sort(ComparatorUtil.VERSION_CREATION_DATE_COMPARATOR);\n-        }\n-        return projectVersions;\n-    }\n-\n-    public HProject getProject() {\n-        if (project == null) {\n-            project = projectDAO.getBySlug(slug);\n-        }\n-        return project;\n-    }\n-\n-    public boolean isUserAllowedToTranslateOrReview(HProjectIteration version,\n-            HLocale localeId) {\n-        return version != null && localeId != null && isIterationActive(version)\n-                && identity != null\n-                && (identity.hasPermissionWithAnyTargets(\"add-translation\",\n-                        version.getProject(), localeId)\n-                        || identity.hasPermissionWithAnyTargets(\n-                                \"translation-review\", version.getProject(),\n-                                localeId));\n-    }\n-\n-    private boolean isIterationActive(HProjectIteration version) {\n-        return version.isActive();\n+    @Override\n+    protected List<HPerson> fetchAll() {\n+      if (allMembers == null) {\n+        allMembers = getAllMembers();\n+        // allMembers must be sorted or the initial display will be in\n+        // an undefined ordering. This is a weakness of the parent\n+        // classes,\n+        // which do not ensure correct ordering for the initial display.\n+        allMembers.sort(peopleFilterComparator);\n+      }\n+      return allMembers;\n     }\n \n-    public void setPageRendered(boolean pageRendered) {\n-        if (pageRendered) {\n-            loadStatistics();\n-        }\n-        this.pageRendered = pageRendered;\n+    public void clearCachedData() {\n+      allMembers = null;\n+      localePersonMap = null;\n     }\n \n     @Override\n-    public void resetPageData() {\n-        projectVersions = null;\n-        versionFilter.reset();\n-        loadStatistics();\n+    protected boolean include(HPerson person, final String filter) {\n+      if (StringUtils.isBlank(filter)) {\n+        return true;\n+      }\n+      projectRolePredicate.setFilter(filter);\n+      projectLocalePredicate.setFilter(filter);\n+      return hasMatchingName(person, filter) || hasMatchingRole(person)\n+        || hasMatchingLanguage(person);\n     }\n \n-    @Override\n-    protected String getMessage(String key, Object... args) {\n-        return msgs.formatWithAnyArgs(key, args);\n+    public void sortPeopleList() {\n+      this.reset();\n+      fetchAll().sort(peopleFilterComparator);\n     }\n \n-    public Map<HPerson, Collection<ProjectRole>> getMemberRoles() {\n-        return getPersonRoles().asMap();\n+    public Collection<HPerson> getMaintainers() {\n+      return fetchAll().stream()\n+        .filter(p -> include(p, getFilter()) && isMaintainer(p))\n+        .collect(toList());\n     }\n \n-    private ListMultimap<HPerson, ProjectRole> getPersonRoles() {\n-        if (personRoles == null) {\n-            populatePersonRoles();\n-        }\n-        return personRoles;\n-    }\n-\n-    private void populatePersonRoles() {\n-        personRoles = ArrayListMultimap.create();\n-        // This can be run from an ajax call that does not actually need to\n-        // render\n-        // personRoles. The null check prevents a NullPointerException in that\n-        // case, and the unused empty list is adequate\n-        if (getProject() != null) {\n-            for (HProjectMember membership : getProject().getMembers()) {\n-                personRoles.put(membership.getPerson(), membership.getRole());\n-            }\n-        }\n+    public List<HLocale> getLocalesWithMembers() {\n+      final ArrayList<HLocale> locales =\n+        new ArrayList<>(getMembersByLocale().keySet());\n+      locales.sort(LOCALE_NAME_ORDERING);\n+      return locales;\n     }\n \n-    private Map<HPerson, ListMultimap<HLocale, LocaleRole>>\n-            getPersonLocaleRoles() {\n-        if (personLocaleRoles == null) {\n-            populatePersonLocaleRoles();\n-        }\n-        return personLocaleRoles;\n-    }\n-\n-    private void populatePersonLocaleRoles() {\n-        personLocaleRoles = new HashMap<>();\n-        // Project may be null if this is triggered from an ajax call that does\n-        // not actually need to render personLocaleRoles\n-        if (getProject() != null) {\n-            for (HProjectLocaleMember membership : getProject()\n-                    .getLocaleMembers()) {\n-                final HPerson person = membership.getPerson();\n-                if (!personLocaleRoles.containsKey(person)) {\n-                    final ListMultimap<HLocale, LocaleRole> localeRoles =\n-                            ArrayListMultimap.create();\n-                    personLocaleRoles.put(person, localeRoles);\n-                }\n-                personLocaleRoles.get(person).put(membership.getLocale(),\n-                        membership.getRole());\n-            }\n-        }\n+    public Map<HLocale, List<HPerson>> getMembersByLocale() {\n+      if (localePersonMap == null) {\n+        localePersonMap = generateMembersByLocale();\n+      }\n+      return localePersonMap;\n     }\n \n-    /**\n-     * Clear data related to memberships so that it will be re-loaded from the\n-     * database next time it is needed for display.\n-     *\n-     * This should be done whenever permissions are changed.\n-     */\n-    public void clearCachedMembershipData() {\n-        // Roles may have changed, so role lists are cleared so they will be\n-        // regenerated\n-        personRoles = null;\n-        personLocaleRoles = null;\n-        project = null;\n-        // Person may have no roles left and no longer belong in the list, so\n-        // ensure the list of people is refreshed.\n-        peopleFilterComparator.clearCachedData();\n-        peopleFilterComparator.sortPeopleList();\n-    }\n-\n-    public List<HPerson> getAllMembers() {\n-        final Set<HPerson> people = new HashSet<>(getMemberRoles().keySet());\n-        people.addAll(getPersonLocaleRoles().keySet());\n-        return Lists.newArrayList(people);\n-    }\n-\n-    public boolean isTranslator(HPerson person) {\n-        ListMultimap<HLocale, LocaleRole> map =\n-                getPersonLocaleRoles().get(person);\n-        return map != null && !map.isEmpty();\n-    }\n-\n-    public boolean isMaintainer(HPerson person) {\n-        List<ProjectRole> roles = getPersonRoles().get(person);\n-        return (roles == null || roles.isEmpty()) ? false\n-                : roles.contains(ProjectRole.Maintainer)\n-                        || roles.contains(TranslationMaintainer);\n-    }\n-\n-    /**\n-     * Check whether a person has any project or locale membership in this\n-     * project.\n-     */\n-    public boolean isMember(HPerson person) {\n-        return getAllMembers().contains(person);\n-    }\n-\n-    /**\n-     * Get display names for all of a person's project and locale roles\n-     */\n-    public List<String> allRoleDisplayNames(HPerson person) {\n-        List<String> displayNames = Lists.newArrayList();\n-        displayNames.addAll(projectRoleDisplayNames(person));\n-        displayNames.addAll(languageRoleDisplayNames(person));\n-        return displayNames;\n-    }\n-\n-    /**\n-     * Get a list of the display name for every project-related role for a\n-     * person.\n-     */\n-    public Collection<String> projectRoleDisplayNames(HPerson person) {\n-        final Collection<ProjectRole> rolesForPerson =\n-                getMemberRoles().get(person);\n-        Collection<ProjectRole> roles;\n-        if (rolesForPerson == null) {\n-            roles = new ArrayList<>();\n-        } else {\n-            roles = new ArrayList<>(rolesForPerson);\n-        }\n-        // Maintainer role includes TranslationMaintainer privileges, so do not\n-        // show the lower-permission role.\n-        if (roles.contains(Maintainer)) {\n-            roles.remove(TranslationMaintainer);\n-        }\n-        return roles.stream().map(this::projectRoleDisplayName).collect(toList());\n-    }\n-\n-    /**\n-     * Get a list of the display name for every language-related role for a\n-     * person.\n-     */\n-    private List<String> languageRoleDisplayNames(HPerson person) {\n-        final ListMultimap<HLocale, LocaleRole> localeRolesMultimap =\n-                getPersonLocaleRoles().get(person);\n-        if (localeRolesMultimap == null) {\n-            return Collections.emptyList();\n-        }\n-\n-        return localeRolesMultimap.asMap().entrySet().stream()\n-                .map(TO_LOCALE_ROLES_DISPLAY_STRING)\n-                .sorted(Ordering.natural().onResultOf(\n-                        s -> isNullOrEmpty(s) ? \"\" : s.toLowerCase()))\n-                .collect(toList());\n-    }\n-\n-    /**\n-     * Display string for just the roles for a person within a locale.\n-     */\n-    public Collection<String> rolesDisplayForLocale(HPerson person,\n-            HLocale locale) {\n-        final ListMultimap<HLocale, LocaleRole> localesWithRoles =\n-                getPersonLocaleRoles().get(person);\n-        if (localesWithRoles == null) {\n-            return new ArrayList<>();\n+    private Map<HLocale, List<HPerson>> generateMembersByLocale() {\n+      Map<HLocale, List<HPerson>> localePersonMap = new HashMap<>();\n+      for (HPerson person : fetchAll()) {\n+        if (!include(person, getFilter()) || !isTranslator(person)) {\n+          continue;\n         }\n-        Collection<LocaleRole> roles = localesWithRoles.asMap().get(locale);\n-        if (roles == null) {\n-            return new ArrayList<>();\n-        }\n-        final List<LocaleRole> sortedRoles =\n-                LOCALE_ROLE_ORDERING.sortedCopy(roles);\n-\n-        final Stream<String> roleNames = sortedRoles.stream()\n-                .map(this::localeRoleDisplayName);\n-        return Lists.newArrayList(Joiner.on(\", \").join(roleNames.iterator()));\n-    }\n-\n-    @SuppressFBWarnings(\"SE_BAD_FIELD\")\n-    private final Function<Map.Entry<HLocale, Collection<LocaleRole>>, String>\n-            TO_LOCALE_ROLES_DISPLAY_STRING =\n-            new Function<Map.Entry<HLocale, Collection<LocaleRole>>, String>() {\n-\n-                @Nullable\n-                @Override\n-                public String apply(\n-                        @Nullable Map.Entry<HLocale, Collection<LocaleRole>> entry) {\n-                    if (entry != null) {\n-                        final String localeName =\n-                                entry.getKey().retrieveDisplayName();\n-                        final List<LocaleRole> sortedRoles =\n-                                LOCALE_ROLE_ORDERING\n-                                        .sortedCopy(entry.getValue());\n-\n-                        Stream<String> roleNames = sortedRoles.stream()\n-                                .map(it -> localeRoleDisplayName(it));\n-                        return localeName + \" \" +\n-                                Joiner.on(\", \").join(roleNames.iterator());\n-                    }\n-                    return null;\n-                }\n-            };\n-\n-    private String projectRoleDisplayName(ProjectRole role) {\n-        switch (role) {\n-        case Maintainer:\n-            return msgs.get(\"jsf.Maintainer\");\n-\n-        case TranslationMaintainer:\n-            return msgs.get(\"jsf.TranslationMaintainer\");\n-\n-        default:\n-            return \"\";\n-\n+        ListMultimap<HLocale, LocaleRole> localeRolesForPerson =\n+          getPersonLocaleRoles().get(person);\n+        for (HLocale locale : localeRolesForPerson.keySet()) {\n+          List<HPerson> peopleForLocale = localePersonMap\n+            .computeIfAbsent(locale, k -> new ArrayList<>());\n+          if (!peopleForLocale.contains(person)) {\n+            peopleForLocale.add(person);\n+          }\n         }\n+      }\n+      // ensure each list of people is in order\n+      for (List<HPerson> people : localePersonMap.values()) {\n+        people.sort(this);\n+      }\n+      return localePersonMap;\n     }\n \n-    public String localeRoleDisplayName(LocaleRole role) {\n-        switch (role) {\n-        case Translator:\n-            return msgs.get(\"jsf.Translator\");\n-\n-        case Reviewer:\n-            return msgs.get(\"jsf.Reviewer\");\n-\n-        case Coordinator:\n-            return msgs.get(\"jsf.Coordinator\");\n-\n-        case Glossarist:\n-            return msgs.get(\"jsf.Glossarist\");\n-\n-        default:\n-            return \"\";\n-\n-        }\n+    private boolean hasMatchingName(HPerson person, String filter) {\n+      return containsIgnoreCase(person.getName(), filter)\n+        || containsIgnoreCase(\n+        person.getAccount().getUsername(), filter);\n     }\n \n-    public int getGlossarySize() {\n-        String qualifiedName = GlossaryUtil.generateQualifiedName(\n-                GlossaryService.PROJECT_QUALIFIER_PREFIX, getSlug());\n-        return glossaryDAO.getEntriesCount(LocaleId.EN_US, null, qualifiedName);\n-    }\n-\n-    /**\n-     * Transform to extract the name of the locale from a HLocale (for sorting)\n-     *\n-     * Use with {@link java.util.Collections#sort}\n-     */\n-    @SuppressFBWarnings(\"SE_BAD_FIELD\")\n-    public static final Function<HLocale, String> TO_LOCALE_NAME =\n-            new Function<HLocale, String>() {\n-\n-                @Nullable\n-                @Override\n-                public String apply(HLocale input) {\n-                    // To lowercase to prevent non-caps values appearing after\n-                    // all caps values (e.g. a appearing after Z)\n-                    return input != null ?\n-                            input.retrieveDisplayName().toLowerCase() : null;\n-                }\n-            };\n-    private static final Ordering<HLocale> LOCALE_NAME_ORDERING =\n-            Ordering.natural().onResultOf(TO_LOCALE_NAME::apply);\n-\n-    public final class PeopleFilterComparator\n-            extends InMemoryListFilter<HPerson> implements Comparator<HPerson> {\n-        private static final long serialVersionUID = 3905373873256076410L;\n-        private final ProjectRolePredicate projectRolePredicate =\n-                new ProjectRolePredicate();\n-        private final ProjectLocalePredicate projectLocalePredicate =\n-                new ProjectLocalePredicate();\n-        private SortingType sortingType;\n-        private boolean showMembersInGroup;\n-        private List<HPerson> allMembers;\n-        private Map<HLocale, List<HPerson>> localePersonMap;\n-\n-        public PeopleFilterComparator(SortingType sortingType) {\n-            this.sortingType = sortingType;\n-        }\n-\n-        @Override\n-        public int compare(HPerson o1, HPerson o2) {\n-            SortingType.SortOption selectedSortOption =\n-                    sortingType.getSelectedSortOption();\n-            if (!selectedSortOption.isAscending()) {\n-                HPerson temp = o1;\n-                o1 = o2;\n-                o2 = temp;\n-            }\n-            // this is set here as a workaround to prevent a separate API call\n-            // for the sort setting (according to aeng).\n-            setShowMembersInGroup(\n-                    selectedSortOption.equals(SortingType.SortOption.ROLE));\n-            return o1.getAccount().getUsername().toLowerCase()\n-                    .compareTo(o2.getAccount().getUsername().toLowerCase());\n-        }\n-\n-        @Override\n-        protected List<HPerson> fetchAll() {\n-            if (allMembers == null) {\n-                allMembers = getAllMembers();\n-                // allMembers must be sorted or the initial display will be in\n-                // an undefined ordering. This is a weakness of the parent\n-                // classes,\n-                // which do not ensure correct ordering for the initial display.\n-                allMembers.sort(peopleFilterComparator);\n-            }\n-            return allMembers;\n-        }\n-\n-        public void clearCachedData() {\n-            allMembers = null;\n-            localePersonMap = null;\n-        }\n-\n-        @Override\n-        protected boolean include(HPerson person, final String filter) {\n-            if (StringUtils.isBlank(filter)) {\n-                return true;\n-            }\n-            projectRolePredicate.setFilter(filter);\n-            projectLocalePredicate.setFilter(filter);\n-            return hasMatchingName(person, filter) || hasMatchingRole(person)\n-                    || hasMatchingLanguage(person);\n-        }\n-\n-        public void sortPeopleList() {\n-            this.reset();\n-            fetchAll().sort(peopleFilterComparator);\n-        }\n-\n-        public Collection<HPerson> getMaintainers() {\n-            return fetchAll().stream()\n-                    .filter(p -> include(p, getFilter()) && isMaintainer(p))\n-                    .collect(toList());\n-        }\n-\n-        public List<HLocale> getLocalesWithMembers() {\n-            final ArrayList<HLocale> locales =\n-                    new ArrayList<>(getMembersByLocale().keySet());\n-            locales.sort(LOCALE_NAME_ORDERING);\n-            return locales;\n-        }\n-\n-        public Map<HLocale, List<HPerson>> getMembersByLocale() {\n-            if (localePersonMap == null) {\n-                localePersonMap = generateMembersByLocale();\n-            }\n-            return localePersonMap;\n-        }\n-\n-        private Map<HLocale, List<HPerson>> generateMembersByLocale() {\n-            Map<HLocale, List<HPerson>> localePersonMap = new HashMap<>();\n-            for (HPerson person : fetchAll()) {\n-                if (!include(person, getFilter()) || !isTranslator(person)) {\n-                    continue;\n-                }\n-                ListMultimap<HLocale, LocaleRole> localeRolesForPerson =\n-                        getPersonLocaleRoles().get(person);\n-                for (HLocale locale : localeRolesForPerson.keySet()) {\n-                    List<HPerson> peopleForLocale = localePersonMap\n-                            .computeIfAbsent(locale, k -> new ArrayList<>());\n-                    if (!peopleForLocale.contains(person)) {\n-                        peopleForLocale.add(person);\n-                    }\n-                }\n-            }\n-            // ensure each list of people is in order\n-            for (List<HPerson> people : localePersonMap.values()) {\n-                people.sort(this);\n-            }\n-            return localePersonMap;\n-        }\n-\n-        private boolean hasMatchingName(HPerson person, String filter) {\n-            return containsIgnoreCase(person.getName(), filter)\n-                    || containsIgnoreCase(\n-                            person.getAccount().getUsername(), filter);\n-        }\n-\n-        private boolean hasMatchingRole(HPerson person) {\n-            return getPersonRoles().get(person).stream().anyMatch(projectRolePredicate);\n-        }\n-\n-        private boolean hasMatchingLanguage(HPerson person) {\n-            ListMultimap<HLocale, LocaleRole> languageRoles =\n-                    getPersonLocaleRoles().get(person);\n-            return languageRoles != null &&\n-                    languageRoles.keySet().stream().anyMatch(projectLocalePredicate);\n-        }\n-\n-        public boolean isShowMembersInGroup() {\n-            return this.showMembersInGroup;\n-        }\n-\n-        public void setShowMembersInGroup(final boolean showMembersInGroup) {\n-            this.showMembersInGroup = showMembersInGroup;\n-        }\n+    private boolean hasMatchingRole(HPerson person) {\n+      return getPersonRoles().get(person).stream().anyMatch(projectRolePredicate);\n     }\n \n-    private static final class ProjectRolePredicate implements Predicate<ProjectRole> {\n-\n-        private String filter;\n-\n-        @Override\n-        public boolean test(ProjectRole projectRole) {\n-            return projectRole != null &&\n-                    containsIgnoreCase(projectRole.name(), filter);\n-        }\n-\n-        public void setFilter(final String filter) {\n-            this.filter = filter;\n-        }\n+    private boolean hasMatchingLanguage(HPerson person) {\n+      ListMultimap<HLocale, LocaleRole> languageRoles =\n+        getPersonLocaleRoles().get(person);\n+      return languageRoles != null &&\n+        languageRoles.keySet().stream().anyMatch(projectLocalePredicate);\n     }\n \n-    private static final class ProjectLocalePredicate implements Predicate<HLocale> {\n-\n-        private String filter;\n-\n-        @Override\n-        public boolean test(HLocale locale) {\n-            return locale != null &&\n-                    (containsIgnoreCase(locale.getDisplayName(), filter) ||\n-                            containsIgnoreCase(locale.getLocaleId().toString(),\n-                                    filter));\n-        }\n-\n-        public void setFilter(final String filter) {\n-            this.filter = filter;\n-        }\n+    public boolean isShowMembersInGroup() {\n+      return this.showMembersInGroup;\n     }\n \n-    public void setSlug(final String slug) {\n-        this.slug = slug;\n+    public void setShowMembersInGroup(final boolean showMembersInGroup) {\n+      this.showMembersInGroup = showMembersInGroup;\n     }\n+  }\n \n-    public String getSlug() {\n-        return this.slug;\n-    }\n+  private static final class ProjectRolePredicate implements Predicate<ProjectRole> {\n \n-    public SortingType getVersionSortingList() {\n-        return this.VersionSortingList;\n-    }\n+    private String filter;\n \n-    public boolean isPageRendered() {\n-        return this.pageRendered;\n+    @Override\n+    public boolean test(ProjectRole projectRole) {\n+      return projectRole != null &&\n+        containsIgnoreCase(projectRole.name(), filter);\n     }\n \n-    public AbstractListFilter<HProjectIteration> getVersionFilter() {\n-        return this.versionFilter;\n+    public void setFilter(final String filter) {\n+      this.filter = filter;\n     }\n+  }\n \n-    public SortingType getPeopleSortingList() {\n-        return this.PeopleSortingList;\n-    }\n+  private static final class ProjectLocalePredicate implements Predicate<HLocale> {\n \n-    public PeopleFilterComparator getPeopleFilterComparator() {\n-        return this.peopleFilterComparator;\n-    }\n+    private String filter;\n \n-    // This ugly code was generated by @lombok.Getter(lazy = true)\n-    @SuppressWarnings(\"unchecked\")\n-    @SuppressFBWarnings(\"JLM_JSR166_UTILCONCURRENT_MONITORENTER\")\n-    public List<Activity> getProjectLastActivity() {\n-        Object value = this.projectLastActivity.get();\n+    @Override\n+    public boolean test(HLocale locale) {\n+      return locale != null &&\n+        (containsIgnoreCase(locale.getDisplayName(), filter) ||\n+          containsIgnoreCase(locale.getLocaleId().toString(),\n+            filter));\n+    }\n+\n+    public void setFilter(final String filter) {\n+      this.filter = filter;\n+    }\n+  }\n+\n+  public void setSlug(final String slug) {\n+    this.slug = slug;\n+  }\n+\n+  public String getSlug() {\n+    return this.slug;\n+  }\n+\n+  public SortingType getVersionSortingList() {\n+    return this.VersionSortingList;\n+  }\n+\n+  public boolean isPageRendered() {\n+    return this.pageRendered;\n+  }\n+\n+  public AbstractListFilter<HProjectIteration> getVersionFilter() {\n+    return this.versionFilter;\n+  }\n+\n+  public SortingType getPeopleSortingList() {\n+    return this.PeopleSortingList;\n+  }\n+\n+  public PeopleFilterComparator getPeopleFilterComparator() {\n+    return this.peopleFilterComparator;\n+  }\n+\n+  // This ugly code was generated by @lombok.Getter(lazy = true)\n+  @SuppressWarnings(\"unchecked\")\n+  @SuppressFBWarnings(\"JLM_JSR166_UTILCONCURRENT_MONITORENTER\")\n+  public List<Activity> getProjectLastActivity() {\n+    Object value = this.projectLastActivity.get();\n+    if (value == null) {\n+      synchronized (this.projectLastActivity) {\n+        value = this.projectLastActivity.get();\n         if (value == null) {\n-            synchronized (this.projectLastActivity) {\n-                value = this.projectLastActivity.get();\n-                if (value == null) {\n-                    final List<Activity> actualValue =\n-                            fetchProjectLastActivity();\n-                    value = actualValue == null ? this.projectLastActivity\n-                            : actualValue;\n-                    this.projectLastActivity.set(value);\n-                }\n-            }\n+          final List<Activity> actualValue =\n+            fetchProjectLastActivity();\n+          value = actualValue == null ? this.projectLastActivity\n+            : actualValue;\n+          this.projectLastActivity.set(value);\n         }\n-        return (List<Activity>) (value == this.projectLastActivity ? null\n-                : value);\n+      }\n     }\n+    return (List<Activity>) (value == this.projectLastActivity ? null\n+      : value);\n+  }\n }\n",
            "diff_size": 1220
        },
        {
            "tool": "naturalize",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/55/ProjectHomeAction.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/naturalize/55/ProjectHomeAction.java\nindex 9d89c478c5f..93f064f5038 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/55/ProjectHomeAction.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/naturalize/55/ProjectHomeAction.java\n@@ -224,7 +224,7 @@ public class ProjectHomeAction extends AbstractSortAction\n         }\n \n         List<Long> versionIds = getProjectVersions().stream()\n-                .map(it -> it != null ? it.getId(): null)\n+                .map(it -> it != null ? it.getId() : null)\n                 .collect(toList());\n         return activityServiceImpl.findLatestVersionActivitiesByUser(\n                 currentUser.getPerson().getId(),\n@@ -401,8 +401,7 @@ public class ProjectHomeAction extends AbstractSortAction\n     public boolean isUserAllowedToTranslateOrReview(HProjectIteration version,\n             HLocale localeId) {\n         return version != null && localeId != null && isIterationActive(version)\n-                && identity != null\n-                && (identity.hasPermissionWithAnyTargets(\"add-translation\",\n+                && identity != null && (identity.hasPermissionWithAnyTargets(\"add-translation\",\n                         version.getProject(), localeId)\n                         || identity.hasPermissionWithAnyTargets(\n                                 \"translation-review\", version.getProject(),\n@@ -515,8 +514,7 @@ public class ProjectHomeAction extends AbstractSortAction\n \n     public boolean isMaintainer(HPerson person) {\n         List<ProjectRole> roles = getPersonRoles().get(person);\n-        return (roles == null || roles.isEmpty()) ? false\n-                : roles.contains(ProjectRole.Maintainer)\n+        return (roles == null || roles.isEmpty()) ? false : roles.contains(ProjectRole.Maintainer)\n                         || roles.contains(TranslationMaintainer);\n     }\n \n@@ -601,8 +599,7 @@ public class ProjectHomeAction extends AbstractSortAction\n \n     @SuppressFBWarnings(\"SE_BAD_FIELD\")\n     private final Function<Map.Entry<HLocale, Collection<LocaleRole>>, String>\n-            TO_LOCALE_ROLES_DISPLAY_STRING =\n-            new Function<Map.Entry<HLocale, Collection<LocaleRole>>, String>() {\n+            TO_LOCALE_ROLES_DISPLAY_STRING = new Function<Map.Entry<HLocale, Collection<LocaleRole>>, String>() {\n \n                 @Nullable\n                 @Override\n@@ -846,7 +843,7 @@ public class ProjectHomeAction extends AbstractSortAction\n                     (containsIgnoreCase(locale.getDisplayName(), filter) ||\n                             containsIgnoreCase(locale.getLocaleId().toString(),\n                                     filter));\n-        }\n+    }\n \n         public void setFilter(final String filter) {\n             this.filter = filter;\n@@ -901,4 +898,4 @@ public class ProjectHomeAction extends AbstractSortAction\n         return (List<Activity>) (value == this.projectLastActivity ? null\n                 : value);\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 9
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/55/ProjectHomeAction.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/codebuff/55/ProjectHomeAction.java\nindex 9d89c478c5f..9751b6a1b75 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/55/ProjectHomeAction.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/codebuff/55/ProjectHomeAction.java\n@@ -90,15 +90,14 @@ import static org.zanata.model.ProjectRole.TranslationMaintainer;\n /**\n  * @author Alex Eng <a href=\"mailto:aeng@redhat.com\">aeng@redhat.com</a>\n  */\n+\n+\n @Named(\"projectHomeAction\")\n @ViewScoped\n @Model\n @Transactional\n-public class ProjectHomeAction extends AbstractSortAction\n-        implements Serializable {\n-    public static final Ordering<LocaleRole> LOCALE_ROLE_ORDERING =\n-            Ordering.explicit(LocaleRole.Translator, LocaleRole.Reviewer,\n-                    LocaleRole.Coordinator, LocaleRole.Glossarist);\n+public class ProjectHomeAction extends AbstractSortAction implements Serializable {\n+    public static final Ordering<LocaleRole> LOCALE_ROLE_ORDERING = Ordering.explicit(LocaleRole.Translator, LocaleRole.Reviewer, LocaleRole.Coordinator, LocaleRole.Glossarist);\n     private static final long serialVersionUID = -5163376385991003306L;\n     @Inject\n     private ActivityService activityServiceImpl;\n@@ -125,58 +124,38 @@ public class ProjectHomeAction extends AbstractSortAction\n     private FacesMessages facesMessages;\n     @Inject\n     private GlossaryDAO glossaryDAO;\n-    private SortingType VersionSortingList = new SortingType(Lists.newArrayList(\n-            SortingType.SortOption.ALPHABETICAL, SortingType.SortOption.HOURS,\n-            SortingType.SortOption.PERCENTAGE, SortingType.SortOption.WORDS,\n-            SortingType.SortOption.LAST_ACTIVITY));\n+    private SortingType VersionSortingList = new SortingType(Lists.newArrayList(SortingType.SortOption.ALPHABETICAL, SortingType.SortOption.HOURS, SortingType.SortOption.PERCENTAGE, SortingType.SortOption.WORDS, SortingType.SortOption.LAST_ACTIVITY));\n     private boolean pageRendered = false;\n-    private AbstractListFilter<HProjectIteration> versionFilter =\n-            new InMemoryListFilter<HProjectIteration>() {\n-\n-                private static final long serialVersionUID =\n-                        7931445158995457207L;\n-\n-                @Override\n-                protected List<HProjectIteration> fetchAll() {\n-                    return getProjectVersions();\n-                }\n-\n-                @Override\n-                protected boolean include(HProjectIteration elem,\n-                        String filter) {\n-                    return containsIgnoreCase(elem.getSlug(),\n-                            filter);\n-                }\n-            };\n-    private final SortingType PeopleSortingList =\n-            new SortingType(\n-                    Lists.newArrayList(SortingType.SortOption.NAME,\n-                            SortingType.SortOption.ROLE),\n-                    SortingType.SortOption.NAME);\n-    private final PeopleFilterComparator peopleFilterComparator =\n-            new PeopleFilterComparator(getPeopleSortingList());\n+    private AbstractListFilter<HProjectIteration> versionFilter = new InMemoryListFilter<HProjectIteration>() {\n+                                                                      private static final long serialVersionUID = 7931445158995457207L;\n+                                                                      @Override\n+                                                                      protected List<HProjectIteration> fetchAll() {\n+                                                                          return getProjectVersions();\n+                                                                      }\n+\n+                                                                      @Override\n+                                                                      protected boolean include(HProjectIteration elem, String filter) {\n+                                                                          return containsIgnoreCase(elem.getSlug(), filter);\n+                                                                      }\n+                                                                  };\n+    private final SortingType PeopleSortingList = new SortingType(Lists.newArrayList(SortingType.SortOption.NAME, SortingType.SortOption.ROLE), SortingType.SortOption.NAME);\n+    private final PeopleFilterComparator peopleFilterComparator = new PeopleFilterComparator(getPeopleSortingList());\n     private ListMultimap<HPerson, ProjectRole> personRoles;\n     private Map<HPerson, ListMultimap<HLocale, LocaleRole>> personLocaleRoles;\n     private List<HProjectIteration> projectVersions;\n     private Map<String, WordStatistic> statisticMap = new HashMap<>();\n     @SuppressFBWarnings(value = \"SE_BAD_FIELD\")\n-    private final VersionComparator versionComparator =\n-            new VersionComparator(getVersionSortingList());\n-    private final AtomicReference<Object> projectLastActivity =\n-            new AtomicReference<>();\n+    private final VersionComparator versionComparator = new VersionComparator(getVersionSortingList());\n+    private final AtomicReference<Object> projectLastActivity = new AtomicReference<>();\n     private HProject project;\n     // for storing last activity date for the version\n     private Map<Long, Date> versionLatestActivityDate = new HashMap<>();\n-\n     public boolean isVersionCopying(String projectSlug, String versionSlug) {\n-        return copyVersionManager.isCopyVersionRunning(projectSlug,\n-                versionSlug);\n+        return copyVersionManager.isCopyVersionRunning(projectSlug, versionSlug);\n     }\n \n-    public String getCopiedDocumentCount(String projectSlug,\n-            String versionSlug) {\n-        CopyVersionTaskHandle handler = copyVersionManager\n-                .getCopyVersionProcessHandle(projectSlug, versionSlug);\n+    public String getCopiedDocumentCount(String projectSlug, String versionSlug) {\n+        CopyVersionTaskHandle handler = copyVersionManager.getCopyVersionProcessHandle(projectSlug, versionSlug);\n         if (handler == null) {\n             return \"0\";\n         } else {\n@@ -186,20 +165,15 @@ public class ProjectHomeAction extends AbstractSortAction\n \n     public void cancelCopyVersion(String projectSlug, String versionSlug) {\n         copyVersionManager.cancelCopyVersion(projectSlug, versionSlug);\n-        facesMessages.addGlobal(msgs.format(\"jsf.copyVersion.Cancelled\",\n-                versionSlug));\n+        facesMessages.addGlobal(msgs.format(\"jsf.copyVersion.Cancelled\", versionSlug));\n     }\n \n-    public String getCopyVersionCompletePercent(String projectSlug,\n-            String versionSlug) {\n-        CopyVersionTaskHandle handler = copyVersionManager\n-                .getCopyVersionProcessHandle(projectSlug, versionSlug);\n+    public String getCopyVersionCompletePercent(String projectSlug, String versionSlug) {\n+        CopyVersionTaskHandle handler = copyVersionManager.getCopyVersionProcessHandle(projectSlug, versionSlug);\n         if (handler != null) {\n-            double completedPercent = (double) handler.getCurrentProgress()\n-                    / (double) handler.getMaxProgress() * 100;\n+            double completedPercent = (double) handler.getCurrentProgress() / (double) handler.getMaxProgress() * 100;\n             if (Double.compare(completedPercent, 100) == 0) {\n-                facesMessages.addGlobal(msgs.format(\"jsf.copyVersion.Completed\",\n-                        versionSlug));\n+                facesMessages.addGlobal(msgs.format(\"jsf.copyVersion.Completed\", versionSlug));\n             }\n             return String.format(\"%1$,.2f\", completedPercent);\n         } else {\n@@ -207,10 +181,8 @@ public class ProjectHomeAction extends AbstractSortAction\n         }\n     }\n \n-    public String getCopyVersionTotalDocuments(String projectSlug,\n-            String versionSlug) {\n-        CopyVersionTaskHandle handler = copyVersionManager\n-                .getCopyVersionProcessHandle(projectSlug, versionSlug);\n+    public String getCopyVersionTotalDocuments(String projectSlug, String versionSlug) {\n+        CopyVersionTaskHandle handler = copyVersionManager.getCopyVersionProcessHandle(projectSlug, versionSlug);\n         if (handler == null) {\n             return \"0\";\n         } else {\n@@ -222,17 +194,11 @@ public class ProjectHomeAction extends AbstractSortAction\n         if (StringUtils.isEmpty(slug) || !identity.isLoggedIn()) {\n             return Collections.emptyList();\n         }\n-\n-        List<Long> versionIds = getProjectVersions().stream()\n-                .map(it -> it != null ? it.getId(): null)\n-                .collect(toList());\n-        return activityServiceImpl.findLatestVersionActivitiesByUser(\n-                currentUser.getPerson().getId(),\n-                versionIds, 0, 1);\n+        List<Long> versionIds = getProjectVersions().stream().map(it -> it != null ? it.getId() : null).collect(toList());\n+        return activityServiceImpl.findLatestVersionActivitiesByUser(currentUser.getPerson().getId(), versionIds, 0, 1);\n     }\n \n-    public DisplayUnit getStatisticFigureForVersion(\n-            SortingType.SortOption sortOption, HProjectIteration version) {\n+    public DisplayUnit getStatisticFigureForVersion(SortingType.SortOption sortOption, HProjectIteration version) {\n         WordStatistic statistic = getStatisticForVersion(version.getSlug());\n         return getDisplayUnit(sortOption, statistic, version.getLastChanged());\n     }\n@@ -240,13 +206,13 @@ public class ProjectHomeAction extends AbstractSortAction\n     /**\n      * Sort version list\n      */\n+\n     public void sortVersionList() {\n         Collections.sort(projectVersions, versionComparator);\n         versionFilter.reset();\n     }\n \n-    private final class VersionComparator\n-            implements Comparator<HProjectIteration> {\n+    private final class VersionComparator implements Comparator<HProjectIteration> {\n         private SortingType sortingType;\n \n         public VersionComparator(SortingType sortingType) {\n@@ -255,58 +221,42 @@ public class ProjectHomeAction extends AbstractSortAction\n \n         @Override\n         public int compare(HProjectIteration o1, HProjectIteration o2) {\n-            SortingType.SortOption selectedSortOption =\n-                    sortingType.getSelectedSortOption();\n+            SortingType.SortOption selectedSortOption = sortingType.getSelectedSortOption();\n             if (!selectedSortOption.isAscending()) {\n                 HProjectIteration temp = o1;\n                 o1 = o2;\n                 o2 = temp;\n             }\n             // Need to get statistic for comparison\n-            if (!selectedSortOption.equals(SortingType.SortOption.ALPHABETICAL)\n-                    && !selectedSortOption\n-                            .equals(SortingType.SortOption.LAST_ACTIVITY)) {\n-                WordStatistic wordStatistic1 =\n-                        getStatisticForVersion(o1.getSlug());\n-                WordStatistic wordStatistic2 =\n-                        getStatisticForVersion(o2.getSlug());\n-                if (selectedSortOption\n-                        .equals(SortingType.SortOption.PERCENTAGE)) {\n-                    return Double.compare(wordStatistic1.getPercentTranslated(),\n-                            wordStatistic2.getPercentTranslated());\n-                } else if (selectedSortOption\n-                        .equals(SortingType.SortOption.HOURS)) {\n-                    return Double.compare(wordStatistic1.getRemainingHours(),\n-                            wordStatistic2.getRemainingHours());\n-                } else if (selectedSortOption\n-                        .equals(SortingType.SortOption.WORDS)) {\n-                    if (wordStatistic1.getTotal() == wordStatistic2\n-                            .getTotal()) {\n-                        return 0;\n-                    }\n-                    return wordStatistic1.getTotal() > wordStatistic2.getTotal()\n-                            ? 1 : -1;\n-                }\n-            } else if (selectedSortOption\n-                    .equals(SortingType.SortOption.ALPHABETICAL)) {\n+            if (!selectedSortOption.equals(SortingType.SortOption.ALPHABETICAL) && !selectedSortOption.equals(SortingType.SortOption.LAST_ACTIVITY)) {\n+                WordStatistic wordStatistic1 = getStatisticForVersion(o1.getSlug());\n+                WordStatistic wordStatistic2 = getStatisticForVersion(o2.getSlug());\n+                if (selectedSortOption.equals(SortingType.SortOption.PERCENTAGE)) {\n+                    return Double.compare(wordStatistic1.getPercentTranslated(), wordStatistic2.getPercentTranslated());\n+                } else if (selectedSortOption.equals(SortingType.SortOption.HOURS)) {\n+                    return Double.compare(wordStatistic1.getRemainingHours(), wordStatistic2.getRemainingHours());\n+                } else if (selectedSortOption.equals(SortingType.SortOption.WORDS)) {\n+                           if (wordStatistic1.getTotal() == wordStatistic2.getTotal()) {\n+                               return 0;\n+                           }\n+                           return wordStatistic1.getTotal() > wordStatistic2.getTotal() ? 1 : -1;\n+                       }\n+            } else if (selectedSortOption.equals(SortingType.SortOption.ALPHABETICAL)) {\n                 return o1.getSlug().compareToIgnoreCase(o2.getSlug());\n-            } else if (selectedSortOption\n-                    .equals(SortingType.SortOption.LAST_ACTIVITY)) {\n-                Date date1 = getVersionLastActivityDate(o1.getId());\n-                Date date2 = getVersionLastActivityDate(o2.getId());\n-                return DateUtil.compareDate(date1, date2);\n-            }\n+            } else if (selectedSortOption.equals(SortingType.SortOption.LAST_ACTIVITY)) {\n+                       Date date1 = getVersionLastActivityDate(o1.getId());\n+                       Date date2 = getVersionLastActivityDate(o2.getId());\n+                       return DateUtil.compareDate(date1, date2);\n+                   }\n             return 0;\n         }\n     }\n \n     private Date getVersionLastActivityDate(Long versionId) {\n         if (!versionLatestActivityDate.containsKey(versionId)) {\n-            List<Activity> activities = activityServiceImpl\n-                    .findLatestVersionActivities(versionId, 0, 1);\n+            List<Activity> activities = activityServiceImpl.findLatestVersionActivities(versionId, 0, 1);\n             if (!activities.isEmpty()) {\n-                versionLatestActivityDate.put(versionId,\n-                        activities.get(0).getLastChanged());\n+                versionLatestActivityDate.put(versionId, activities.get(0).getLastChanged());\n             } else {\n                 versionLatestActivityDate.put(versionId, null);\n             }\n@@ -323,13 +273,11 @@ public class ProjectHomeAction extends AbstractSortAction\n         if (statisticMap.containsKey(versionSlug)) {\n             statistic = statisticMap.get(versionSlug);\n         } else {\n-            HProjectIteration version =\n-                    projectIterationDAO.getBySlug(slug, versionSlug);\n+            HProjectIteration version = projectIterationDAO.getBySlug(slug, versionSlug);\n             statistic = getAllLocaleStatisticForVersion(version);\n             statisticMap.put(versionSlug, statistic);\n         }\n-        statistic\n-                .setRemainingHours(StatisticsUtil.getRemainingHours(statistic));\n+        statistic.setRemainingHours(StatisticsUtil.getRemainingHours(statistic));\n         return statistic;\n     }\n \n@@ -337,26 +285,22 @@ public class ProjectHomeAction extends AbstractSortAction\n     protected void loadStatistics() {\n         statisticMap.clear();\n         for (HProjectIteration version : getProjectVersions()) {\n-            statisticMap.put(version.getSlug(),\n-                    getAllLocaleStatisticForVersion(version));\n+            statisticMap.put(version.getSlug(), getAllLocaleStatisticForVersion(version));\n         }\n     }\n \n-    private WordStatistic\n-            getAllLocaleStatisticForVersion(HProjectIteration version) {\n+    private WordStatistic getAllLocaleStatisticForVersion(HProjectIteration version) {\n         WordStatistic versionStats = new WordStatistic();\n         List<HLocale> locales = getSupportedLocale(version);\n         for (HLocale locale : locales) {\n-            versionStats.add(versionStateCacheImpl.getVersionStatistics(\n-                    version.getId(), locale.getLocaleId()));\n+            versionStats.add(versionStateCacheImpl.getVersionStatistics(version.getId(), locale.getLocaleId()));\n         }\n         return versionStats;\n     }\n \n     public List<HLocale> getSupportedLocale(HProjectIteration version) {\n         if (version != null) {\n-            return localeServiceImpl.getSupportedLanguageByProjectIteration(\n-                    slug, version.getSlug());\n+            return localeServiceImpl.getSupportedLanguageByProjectIteration(slug, version.getSlug());\n         }\n         return Collections.emptyList();\n     }\n@@ -368,10 +312,7 @@ public class ProjectHomeAction extends AbstractSortAction\n         List<HLocale> userJoinedLocales = Lists.newArrayList();\n         Long personId = currentUser.getPerson().getId();\n         for (HLocale supportedLocale : getSupportedLocale(version)) {\n-            if (localeMemberDAO.isLocaleMember(personId,\n-                    supportedLocale.getLocaleId())\n-                    && isUserAllowedToTranslateOrReview(version,\n-                            supportedLocale)) {\n+            if (localeMemberDAO.isLocaleMember(personId, supportedLocale.getLocaleId()) && isUserAllowedToTranslateOrReview(version, supportedLocale)) {\n                 userJoinedLocales.add(supportedLocale);\n             }\n         }\n@@ -385,8 +326,7 @@ public class ProjectHomeAction extends AbstractSortAction\n         if (projectVersions == null) {\n             projectVersions = projectDAO.getActiveIterations(slug);\n             projectVersions.addAll(projectDAO.getReadOnlyIterations(slug));\n-            projectVersions\n-                    .sort(ComparatorUtil.VERSION_CREATION_DATE_COMPARATOR);\n+            projectVersions.sort(ComparatorUtil.VERSION_CREATION_DATE_COMPARATOR);\n         }\n         return projectVersions;\n     }\n@@ -398,15 +338,10 @@ public class ProjectHomeAction extends AbstractSortAction\n         return project;\n     }\n \n-    public boolean isUserAllowedToTranslateOrReview(HProjectIteration version,\n-            HLocale localeId) {\n+    public boolean isUserAllowedToTranslateOrReview(HProjectIteration version, HLocale localeId) {\n         return version != null && localeId != null && isIterationActive(version)\n-                && identity != null\n-                && (identity.hasPermissionWithAnyTargets(\"add-translation\",\n-                        version.getProject(), localeId)\n-                        || identity.hasPermissionWithAnyTargets(\n-                                \"translation-review\", version.getProject(),\n-                                localeId));\n+        && identity != null\n+        && (identity.hasPermissionWithAnyTargets(\"add-translation\", version.getProject(), localeId) || identity.hasPermissionWithAnyTargets(\"translation-review\", version.getProject(), localeId));\n     }\n \n     private boolean isIterationActive(HProjectIteration version) {\n@@ -456,8 +391,7 @@ public class ProjectHomeAction extends AbstractSortAction\n         }\n     }\n \n-    private Map<HPerson, ListMultimap<HLocale, LocaleRole>>\n-            getPersonLocaleRoles() {\n+    private Map<HPerson, ListMultimap<HLocale, LocaleRole>> getPersonLocaleRoles() {\n         if (personLocaleRoles == null) {\n             populatePersonLocaleRoles();\n         }\n@@ -469,16 +403,13 @@ public class ProjectHomeAction extends AbstractSortAction\n         // Project may be null if this is triggered from an ajax call that does\n         // not actually need to render personLocaleRoles\n         if (getProject() != null) {\n-            for (HProjectLocaleMember membership : getProject()\n-                    .getLocaleMembers()) {\n+            for (HProjectLocaleMember membership : getProject().getLocaleMembers()) {\n                 final HPerson person = membership.getPerson();\n                 if (!personLocaleRoles.containsKey(person)) {\n-                    final ListMultimap<HLocale, LocaleRole> localeRoles =\n-                            ArrayListMultimap.create();\n+                    final ListMultimap<HLocale, LocaleRole> localeRoles = ArrayListMultimap.create();\n                     personLocaleRoles.put(person, localeRoles);\n                 }\n-                personLocaleRoles.get(person).put(membership.getLocale(),\n-                        membership.getRole());\n+                personLocaleRoles.get(person).put(membership.getLocale(), membership.getRole());\n             }\n         }\n     }\n@@ -489,6 +420,7 @@ public class ProjectHomeAction extends AbstractSortAction\n      *\n      * This should be done whenever permissions are changed.\n      */\n+\n     public void clearCachedMembershipData() {\n         // Roles may have changed, so role lists are cleared so they will be\n         // regenerated\n@@ -508,22 +440,20 @@ public class ProjectHomeAction extends AbstractSortAction\n     }\n \n     public boolean isTranslator(HPerson person) {\n-        ListMultimap<HLocale, LocaleRole> map =\n-                getPersonLocaleRoles().get(person);\n+        ListMultimap<HLocale, LocaleRole> map = getPersonLocaleRoles().get(person);\n         return map != null && !map.isEmpty();\n     }\n \n     public boolean isMaintainer(HPerson person) {\n         List<ProjectRole> roles = getPersonRoles().get(person);\n-        return (roles == null || roles.isEmpty()) ? false\n-                : roles.contains(ProjectRole.Maintainer)\n-                        || roles.contains(TranslationMaintainer);\n+        return (roles == null || roles.isEmpty()) ? false : roles.contains(ProjectRole.Maintainer) || roles.contains(TranslationMaintainer);\n     }\n \n     /**\n      * Check whether a person has any project or locale membership in this\n      * project.\n      */\n+\n     public boolean isMember(HPerson person) {\n         return getAllMembers().contains(person);\n     }\n@@ -531,6 +461,7 @@ public class ProjectHomeAction extends AbstractSortAction\n     /**\n      * Get display names for all of a person's project and locale roles\n      */\n+\n     public List<String> allRoleDisplayNames(HPerson person) {\n         List<String> displayNames = Lists.newArrayList();\n         displayNames.addAll(projectRoleDisplayNames(person));\n@@ -542,9 +473,9 @@ public class ProjectHomeAction extends AbstractSortAction\n      * Get a list of the display name for every project-related role for a\n      * person.\n      */\n+\n     public Collection<String> projectRoleDisplayNames(HPerson person) {\n-        final Collection<ProjectRole> rolesForPerson =\n-                getMemberRoles().get(person);\n+        final Collection<ProjectRole> rolesForPerson = getMemberRoles().get(person);\n         Collection<ProjectRole> roles;\n         if (rolesForPerson == null) {\n             roles = new ArrayList<>();\n@@ -563,27 +494,21 @@ public class ProjectHomeAction extends AbstractSortAction\n      * Get a list of the display name for every language-related role for a\n      * person.\n      */\n+\n     private List<String> languageRoleDisplayNames(HPerson person) {\n-        final ListMultimap<HLocale, LocaleRole> localeRolesMultimap =\n-                getPersonLocaleRoles().get(person);\n+        final ListMultimap<HLocale, LocaleRole> localeRolesMultimap = getPersonLocaleRoles().get(person);\n         if (localeRolesMultimap == null) {\n             return Collections.emptyList();\n         }\n-\n-        return localeRolesMultimap.asMap().entrySet().stream()\n-                .map(TO_LOCALE_ROLES_DISPLAY_STRING)\n-                .sorted(Ordering.natural().onResultOf(\n-                        s -> isNullOrEmpty(s) ? \"\" : s.toLowerCase()))\n-                .collect(toList());\n+        return localeRolesMultimap.asMap().entrySet().stream().map(TO_LOCALE_ROLES_DISPLAY_STRING).sorted(Ordering.natural().onResultOf(s -> isNullOrEmpty(s) ? \"\" : s.toLowerCase())).collect(toList());\n     }\n \n     /**\n      * Display string for just the roles for a person within a locale.\n      */\n-    public Collection<String> rolesDisplayForLocale(HPerson person,\n-            HLocale locale) {\n-        final ListMultimap<HLocale, LocaleRole> localesWithRoles =\n-                getPersonLocaleRoles().get(person);\n+\n+    public Collection<String> rolesDisplayForLocale(HPerson person, HLocale locale) {\n+        final ListMultimap<HLocale, LocaleRole> localesWithRoles = getPersonLocaleRoles().get(person);\n         if (localesWithRoles == null) {\n             return new ArrayList<>();\n         }\n@@ -591,50 +516,36 @@ public class ProjectHomeAction extends AbstractSortAction\n         if (roles == null) {\n             return new ArrayList<>();\n         }\n-        final List<LocaleRole> sortedRoles =\n-                LOCALE_ROLE_ORDERING.sortedCopy(roles);\n-\n-        final Stream<String> roleNames = sortedRoles.stream()\n-                .map(this::localeRoleDisplayName);\n+        final List<LocaleRole> sortedRoles = LOCALE_ROLE_ORDERING.sortedCopy(roles);\n+        final Stream<String> roleNames = sortedRoles.stream().map(this::localeRoleDisplayName);\n         return Lists.newArrayList(Joiner.on(\", \").join(roleNames.iterator()));\n     }\n \n     @SuppressFBWarnings(\"SE_BAD_FIELD\")\n-    private final Function<Map.Entry<HLocale, Collection<LocaleRole>>, String>\n-            TO_LOCALE_ROLES_DISPLAY_STRING =\n-            new Function<Map.Entry<HLocale, Collection<LocaleRole>>, String>() {\n-\n-                @Nullable\n-                @Override\n-                public String apply(\n-                        @Nullable Map.Entry<HLocale, Collection<LocaleRole>> entry) {\n-                    if (entry != null) {\n-                        final String localeName =\n-                                entry.getKey().retrieveDisplayName();\n-                        final List<LocaleRole> sortedRoles =\n-                                LOCALE_ROLE_ORDERING\n-                                        .sortedCopy(entry.getValue());\n-\n-                        Stream<String> roleNames = sortedRoles.stream()\n-                                .map(it -> localeRoleDisplayName(it));\n-                        return localeName + \" \" +\n-                                Joiner.on(\", \").join(roleNames.iterator());\n-                    }\n-                    return null;\n-                }\n-            };\n-\n+    private final Function<Map.Entry<HLocale,\n+Collection<LocaleRole>>, String> TO_LOCALE_ROLES_DISPLAY_STRING = new Function<Map.Entry<HLocale,\n+Collection<LocaleRole>>, String>() {\n+                                                                      @Nullable\n+                                                                      @Override\n+                                                                      public String apply(@Nullable Map.Entry<HLocale,\n+Collection<LocaleRole>> entry) {\n+                                                                          if (entry != null) {\n+                                                                              final String localeName = entry.getKey().retrieveDisplayName();\n+                                                                              final List<LocaleRole> sortedRoles = LOCALE_ROLE_ORDERING.sortedCopy(entry.getValue());\n+                                                                              Stream<String> roleNames = sortedRoles.stream().map(it -> localeRoleDisplayName(it));\n+                                                                              return localeName + \" \" + Joiner.on(\", \").join(roleNames.iterator());\n+                                                                          }\n+                                                                          return null;\n+                                                                      }\n+                                                                  };\n     private String projectRoleDisplayName(ProjectRole role) {\n         switch (role) {\n         case Maintainer:\n             return msgs.get(\"jsf.Maintainer\");\n-\n         case TranslationMaintainer:\n             return msgs.get(\"jsf.TranslationMaintainer\");\n-\n         default:\n             return \"\";\n-\n         }\n     }\n \n@@ -642,25 +553,19 @@ public class ProjectHomeAction extends AbstractSortAction\n         switch (role) {\n         case Translator:\n             return msgs.get(\"jsf.Translator\");\n-\n         case Reviewer:\n             return msgs.get(\"jsf.Reviewer\");\n-\n         case Coordinator:\n             return msgs.get(\"jsf.Coordinator\");\n-\n         case Glossarist:\n             return msgs.get(\"jsf.Glossarist\");\n-\n         default:\n             return \"\";\n-\n         }\n     }\n \n     public int getGlossarySize() {\n-        String qualifiedName = GlossaryUtil.generateQualifiedName(\n-                GlossaryService.PROJECT_QUALIFIER_PREFIX, getSlug());\n+        String qualifiedName = GlossaryUtil.generateQualifiedName(GlossaryService.PROJECT_QUALIFIER_PREFIX, getSlug());\n         return glossaryDAO.getEntriesCount(LocaleId.EN_US, null, qualifiedName);\n     }\n \n@@ -669,29 +574,23 @@ public class ProjectHomeAction extends AbstractSortAction\n      *\n      * Use with {@link java.util.Collections#sort}\n      */\n-    @SuppressFBWarnings(\"SE_BAD_FIELD\")\n-    public static final Function<HLocale, String> TO_LOCALE_NAME =\n-            new Function<HLocale, String>() {\n \n-                @Nullable\n-                @Override\n-                public String apply(HLocale input) {\n+    @SuppressFBWarnings(\"SE_BAD_FIELD\")\n+    public static final Function<HLocale, String> TO_LOCALE_NAME = new Function<HLocale, String>() {\n+                                                                       @Nullable\n+                                                                       @Override\n+                                                                       public String apply(HLocale input) {\n                     // To lowercase to prevent non-caps values appearing after\n                     // all caps values (e.g. a appearing after Z)\n-                    return input != null ?\n-                            input.retrieveDisplayName().toLowerCase() : null;\n-                }\n-            };\n-    private static final Ordering<HLocale> LOCALE_NAME_ORDERING =\n-            Ordering.natural().onResultOf(TO_LOCALE_NAME::apply);\n-\n-    public final class PeopleFilterComparator\n-            extends InMemoryListFilter<HPerson> implements Comparator<HPerson> {\n+                                                                           return input != null ? input.retrieveDisplayName().toLowerCase() : null;\n+                                                                       }\n+                                                                   };\n+    private static final Ordering<HLocale> LOCALE_NAME_ORDERING = Ordering.natural().onResultOf(TO_LOCALE_NAME::apply);\n+    public final class PeopleFilterComparator extends InMemoryListFilter<HPerson>\n+        implements Comparator<HPerson> {\n         private static final long serialVersionUID = 3905373873256076410L;\n-        private final ProjectRolePredicate projectRolePredicate =\n-                new ProjectRolePredicate();\n-        private final ProjectLocalePredicate projectLocalePredicate =\n-                new ProjectLocalePredicate();\n+        private final ProjectRolePredicate projectRolePredicate = new ProjectRolePredicate();\n+        private final ProjectLocalePredicate projectLocalePredicate = new ProjectLocalePredicate();\n         private SortingType sortingType;\n         private boolean showMembersInGroup;\n         private List<HPerson> allMembers;\n@@ -703,8 +602,7 @@ public class ProjectHomeAction extends AbstractSortAction\n \n         @Override\n         public int compare(HPerson o1, HPerson o2) {\n-            SortingType.SortOption selectedSortOption =\n-                    sortingType.getSelectedSortOption();\n+            SortingType.SortOption selectedSortOption = sortingType.getSelectedSortOption();\n             if (!selectedSortOption.isAscending()) {\n                 HPerson temp = o1;\n                 o1 = o2;\n@@ -712,10 +610,8 @@ public class ProjectHomeAction extends AbstractSortAction\n             }\n             // this is set here as a workaround to prevent a separate API call\n             // for the sort setting (according to aeng).\n-            setShowMembersInGroup(\n-                    selectedSortOption.equals(SortingType.SortOption.ROLE));\n-            return o1.getAccount().getUsername().toLowerCase()\n-                    .compareTo(o2.getAccount().getUsername().toLowerCase());\n+            setShowMembersInGroup(selectedSortOption.equals(SortingType.SortOption.ROLE));\n+            return o1.getAccount().getUsername().toLowerCase().compareTo(o2.getAccount().getUsername().toLowerCase());\n         }\n \n         @Override\n@@ -737,14 +633,16 @@ public class ProjectHomeAction extends AbstractSortAction\n         }\n \n         @Override\n-        protected boolean include(HPerson person, final String filter) {\n+        protected boolean include(HPerson person,\n+            final String filter) {\n             if (StringUtils.isBlank(filter)) {\n                 return true;\n             }\n             projectRolePredicate.setFilter(filter);\n             projectLocalePredicate.setFilter(filter);\n-            return hasMatchingName(person, filter) || hasMatchingRole(person)\n-                    || hasMatchingLanguage(person);\n+            return hasMatchingName(person, filter)\n+            || hasMatchingRole(person)\n+            || hasMatchingLanguage(person);\n         }\n \n         public void sortPeopleList() {\n@@ -753,14 +651,11 @@ public class ProjectHomeAction extends AbstractSortAction\n         }\n \n         public Collection<HPerson> getMaintainers() {\n-            return fetchAll().stream()\n-                    .filter(p -> include(p, getFilter()) && isMaintainer(p))\n-                    .collect(toList());\n+            return fetchAll().stream().filter(p -> include(p, getFilter()) && isMaintainer(p)).collect(toList());\n         }\n \n         public List<HLocale> getLocalesWithMembers() {\n-            final ArrayList<HLocale> locales =\n-                    new ArrayList<>(getMembersByLocale().keySet());\n+            final ArrayList<HLocale> locales = new ArrayList<>(getMembersByLocale().keySet());\n             locales.sort(LOCALE_NAME_ORDERING);\n             return locales;\n         }\n@@ -778,11 +673,9 @@ public class ProjectHomeAction extends AbstractSortAction\n                 if (!include(person, getFilter()) || !isTranslator(person)) {\n                     continue;\n                 }\n-                ListMultimap<HLocale, LocaleRole> localeRolesForPerson =\n-                        getPersonLocaleRoles().get(person);\n+                ListMultimap<HLocale, LocaleRole> localeRolesForPerson = getPersonLocaleRoles().get(person);\n                 for (HLocale locale : localeRolesForPerson.keySet()) {\n-                    List<HPerson> peopleForLocale = localePersonMap\n-                            .computeIfAbsent(locale, k -> new ArrayList<>());\n+                    List<HPerson> peopleForLocale = localePersonMap.computeIfAbsent(locale, k -> new ArrayList<>());\n                     if (!peopleForLocale.contains(person)) {\n                         peopleForLocale.add(person);\n                     }\n@@ -796,9 +689,7 @@ public class ProjectHomeAction extends AbstractSortAction\n         }\n \n         private boolean hasMatchingName(HPerson person, String filter) {\n-            return containsIgnoreCase(person.getName(), filter)\n-                    || containsIgnoreCase(\n-                            person.getAccount().getUsername(), filter);\n+            return containsIgnoreCase(person.getName(), filter) || containsIgnoreCase(person.getAccount().getUsername(), filter);\n         }\n \n         private boolean hasMatchingRole(HPerson person) {\n@@ -806,10 +697,8 @@ public class ProjectHomeAction extends AbstractSortAction\n         }\n \n         private boolean hasMatchingLanguage(HPerson person) {\n-            ListMultimap<HLocale, LocaleRole> languageRoles =\n-                    getPersonLocaleRoles().get(person);\n-            return languageRoles != null &&\n-                    languageRoles.keySet().stream().anyMatch(projectLocalePredicate);\n+            ListMultimap<HLocale, LocaleRole> languageRoles = getPersonLocaleRoles().get(person);\n+            return languageRoles != null && languageRoles.keySet().stream().anyMatch(projectLocalePredicate);\n         }\n \n         public boolean isShowMembersInGroup() {\n@@ -822,13 +711,10 @@ public class ProjectHomeAction extends AbstractSortAction\n     }\n \n     private static final class ProjectRolePredicate implements Predicate<ProjectRole> {\n-\n         private String filter;\n-\n         @Override\n         public boolean test(ProjectRole projectRole) {\n-            return projectRole != null &&\n-                    containsIgnoreCase(projectRole.name(), filter);\n+            return projectRole != null && containsIgnoreCase(projectRole.name(), filter);\n         }\n \n         public void setFilter(final String filter) {\n@@ -837,15 +723,11 @@ public class ProjectHomeAction extends AbstractSortAction\n     }\n \n     private static final class ProjectLocalePredicate implements Predicate<HLocale> {\n-\n         private String filter;\n-\n         @Override\n         public boolean test(HLocale locale) {\n             return locale != null &&\n-                    (containsIgnoreCase(locale.getDisplayName(), filter) ||\n-                            containsIgnoreCase(locale.getLocaleId().toString(),\n-                                    filter));\n+                (containsIgnoreCase(locale.getDisplayName(), filter) || containsIgnoreCase(locale.getLocaleId().toString(), filter));\n         }\n \n         public void setFilter(final String filter) {\n@@ -882,23 +764,23 @@ public class ProjectHomeAction extends AbstractSortAction\n     }\n \n     // This ugly code was generated by @lombok.Getter(lazy = true)\n+\n     @SuppressWarnings(\"unchecked\")\n     @SuppressFBWarnings(\"JLM_JSR166_UTILCONCURRENT_MONITORENTER\")\n     public List<Activity> getProjectLastActivity() {\n         Object value = this.projectLastActivity.get();\n         if (value == null) {\n             synchronized (this.projectLastActivity) {\n-                value = this.projectLastActivity.get();\n+                value =\n+                    this.projectLastActivity.get();\n                 if (value == null) {\n-                    final List<Activity> actualValue =\n-                            fetchProjectLastActivity();\n-                    value = actualValue == null ? this.projectLastActivity\n-                            : actualValue;\n+                    final List<Activity> actualValue = fetchProjectLastActivity();\n+                    value = actualValue == null ? this.projectLastActivity : actualValue;\n                     this.projectLastActivity.set(value);\n                 }\n             }\n         }\n         return (List<Activity>) (value == this.projectLastActivity ? null\n-                : value);\n+            : value);\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 274
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/55/ProjectHomeAction.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/styler_random/55/ProjectHomeAction.java\nindex 9d89c478c5f..17db3b4579a 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/55/ProjectHomeAction.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/styler_random/55/ProjectHomeAction.java\n@@ -224,7 +224,7 @@ public class ProjectHomeAction extends AbstractSortAction\n         }\n \n         List<Long> versionIds = getProjectVersions().stream()\n-                .map(it -> it != null ? it.getId(): null)\n+                .map(it -> it != null ? it.getId() : null)\n                 .collect(toList());\n         return activityServiceImpl.findLatestVersionActivitiesByUser(\n                 currentUser.getPerson().getId(),\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/55/ProjectHomeAction.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/styler_three_grams/55/ProjectHomeAction.java\nindex 9d89c478c5f..17db3b4579a 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/55/ProjectHomeAction.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/styler_three_grams/55/ProjectHomeAction.java\n@@ -224,7 +224,7 @@ public class ProjectHomeAction extends AbstractSortAction\n         }\n \n         List<Long> versionIds = getProjectVersions().stream()\n-                .map(it -> it != null ? it.getId(): null)\n+                .map(it -> it != null ? it.getId() : null)\n                 .collect(toList());\n         return activityServiceImpl.findLatestVersionActivitiesByUser(\n                 currentUser.getPerson().getId(),\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": []
}