{
    "project_name": "vassalengine-vassal",
    "error_id": "1",
    "information": {
        "errors": [
            {
                "line": "145",
                "column": "5",
                "severity": "error",
                "message": "WhitespaceAround: 'switch' is not followed by whitespace. Empty blocks may only be represented as {} when not part of a multi-block statement (4.1.3)",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
            }
        ]
    },
    "source_code": "    }\n\n    switch(target.targetCompare) {\n    case MATCH:\n      return fastPattern.matcher(value).matches();\n    case NOT_MATCH:",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vassalengine-vassal/errored/1/1/GlobalCommand.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vassalengine-vassal/styler/1/GlobalCommand.java\nindex 3c1ad07f586..aedda930b06 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vassalengine-vassal/errored/1/1/GlobalCommand.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vassalengine-vassal/styler/1/GlobalCommand.java\n@@ -142,7 +142,7 @@ public class GlobalCommand {\n       return false;\n     }\n \n-    switch(target.targetCompare) {\n+    switch (target.targetCompare) {\n     case MATCH:\n       return fastPattern.matcher(value).matches();\n     case NOT_MATCH:\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vassalengine-vassal/errored/1/1/GlobalCommand.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vassalengine-vassal/intellij/1/GlobalCommand.java\nindex 3c1ad07f586..78eabf1b602 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vassalengine-vassal/errored/1/1/GlobalCommand.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vassalengine-vassal/intellij/1/GlobalCommand.java\n@@ -15,6 +15,7 @@\n  * License along with this library; if not, copies are available\n  * at http://www.opensource.org.\n  */\n+\n package VASSAL.counters;\n \n import javax.swing.KeyStroke;\n@@ -42,14 +43,14 @@ import java.util.regex.Pattern;\n /**\n  * The heart of all the different forms of Global Key Command, GlobalCommand handles sending a key command to\n  * multiple pieces, potentially on multiple maps, as long as they match its filtering condition.\n- *\n+ * <p>\n  * The various forms of Global Key Command that use GlobalCommand are:\n  * {@link VASSAL.build.module.GlobalKeyCommand} - Global Key Commands from a Module window\n  * {@link VASSAL.build.module.StartupGlobalKeyCommand} - Startup Global Key Commands from a Module\n  * {@link VASSAL.build.module.map.MassKeyCommand} - Global Key Commands from a specific Map window\n  * {@link VASSAL.build.module.map.DeckGlobalKeyCommand} - Global Key Commands from a Deck\n  * {@link CounterGlobalKeyCommand} - Global Key Command from a Game Piece\n- *\n+ * <p>\n  * Other important classes:\n  * {@link GlobalCommandTarget}           - \"Fast Match\" parameters\n  * {@link GlobalCommandTargetConfigurer} - configurer for \"Fast Match\" parameters\n@@ -57,7 +58,8 @@ import java.util.regex.Pattern;\n public class GlobalCommand {\n   protected KeyStroke keyStroke;        // Key Command we will issue\n   protected boolean reportSingle;       // If true, we temporarily disable Report traits in any receiving pieces\n-  protected int selectFromDeck = -1;    // selectFromDeck = -1 means process all cards in Deck; > 0 means select that many cards from the Deck\n+  protected int selectFromDeck = -1;\n+    // selectFromDeck = -1 means process all cards in Deck; > 0 means select that many cards from the Deck\n   protected FormattedString reportFormat = new FormattedString(); // Report to display before sending the command\n   protected Loopable owner;             // For preventing infinite loops\n   protected PropertySource source;      // Context for resolving properties (i.e. for our report message)\n@@ -69,10 +71,11 @@ public class GlobalCommand {\n   private double fastNumber = 0;        // Used during property Fast Match to hold evaluated numerical value\n   private Pattern fastPattern;          // Fast Match regex pattern\n \n-  private final Pattern fastCheckNumber = Pattern.compile(\"(\\\\+-)?\\\\d+(\\\\.\\\\d+)?\");  //match a number with optional +/- and decimal.\n+  private final Pattern fastCheckNumber = Pattern.compile(\"(\\\\+-)?\\\\d+(\\\\.\\\\d+)?\");\n+    //match a number with optional +/- and decimal.\n \n   public GlobalCommand(Loopable l) {\n-    this (l, null);\n+    this(l, null);\n   }\n \n   public GlobalCommand(Loopable l, PropertySource p) {\n@@ -122,11 +125,14 @@ public class GlobalCommand {\n \n   /**\n    * Check the Property Fast Match for a given gamePiece\n+   *\n    * @param gamePiece the game piece\n    * @return true if piece matches\n    */\n   private boolean passesPropertyFastMatch(GamePiece gamePiece) {\n-    if (!target.fastMatchProperty || fastProperty.isEmpty()) return true;\n+    if (!target.fastMatchProperty || fastProperty.isEmpty()) {\n+      return true;\n+    }\n     final String value = (String) gamePiece.getProperty(fastProperty);\n \n     // Intentionally favors the default \"Equals\" as first to process\n@@ -142,7 +148,7 @@ public class GlobalCommand {\n       return false;\n     }\n \n-    switch(target.targetCompare) {\n+    switch (target.targetCompare) {\n     case MATCH:\n       return fastPattern.matcher(value).matches();\n     case NOT_MATCH:\n@@ -182,6 +188,7 @@ public class GlobalCommand {\n \n   /**\n    * Need a super-fast (i.e. not dependent on exception-throwing) plan for detecting valid numbers\n+   *\n    * @param s string to check\n    * @return true if a value number\n    */\n@@ -192,8 +199,8 @@ public class GlobalCommand {\n   /**\n    * Apply the key command to all pieces that pass the given filter & our Fast Match {@link GlobalCommandTarget} parameters on all the given maps\n    *\n-   * @param maps Array of Maps\n-   * @param filter Filter to apply (created e.g. with {@link PropertyExpression#getFilter}\n+   * @param maps      Array of Maps\n+   * @param filter    Filter to apply (created e.g. with {@link PropertyExpression#getFilter}\n    * @param fastMatch Fast matching parameters, or null. {@link GlobalCommandTarget} and {@link VASSAL.configure.GlobalCommandTargetConfigurer}\n    * @return the corresponding {@link Command} that would reproduce all the things this GKC just did, on another client.\n    */\n@@ -261,19 +268,17 @@ public class GlobalCommand {\n       // Evaluate any property-based expressions we will be using - these are evaluated w/r/t the SOURCE of the command, not target pieces.\n       if (target.fastMatchProperty) {\n         fastProperty = target.targetProperty.tryEvaluate(source);\n-        fastValue    = target.targetValue.tryEvaluate(source);\n+        fastValue = target.targetValue.tryEvaluate(source);\n         if ((target.targetCompare == GlobalCommandTarget.CompareMode.EQUALS) ||\n-            (target.targetCompare == GlobalCommandTarget.CompareMode.NOT_EQUALS)) {\n+          (target.targetCompare == GlobalCommandTarget.CompareMode.NOT_EQUALS)) {\n           fastIsNumber = false;\n-          fastNumber   = 0;\n-        }\n-        else if ((target.targetCompare == GlobalCommandTarget.CompareMode.MATCH) ||\n-                 (target.targetCompare == GlobalCommandTarget.CompareMode.NOT_MATCH)) {\n-          fastPattern  = Pattern.compile(fastValue);\n+          fastNumber = 0;\n+        } else if ((target.targetCompare == GlobalCommandTarget.CompareMode.MATCH) ||\n+          (target.targetCompare == GlobalCommandTarget.CompareMode.NOT_MATCH)) {\n+          fastPattern = Pattern.compile(fastValue);\n           fastIsNumber = false;\n-          fastNumber   = 0;\n-        }\n-        else {\n+          fastNumber = 0;\n+        } else {\n           fastIsNumber = isNumeric(fastValue);\n           fastNumber = fastIsNumber ? Double.parseDouble(fastValue) : 0;\n         }\n@@ -288,7 +293,7 @@ public class GlobalCommand {\n         if (curPiece != null) {\n           final Stack stack = curPiece.getParent();\n           if (stack instanceof Deck) {\n-            command = command.append(((Deck)stack).maybeShuffle()); // If it's an always-shuffle deck, shuffle it.\n+            command = command.append(((Deck) stack).maybeShuffle()); // If it's an always-shuffle deck, shuffle it.\n           }\n           final List<GamePiece> pieces = stack.asList();\n           for (final GamePiece gamePiece : pieces) {\n@@ -318,8 +323,7 @@ public class GlobalCommand {\n             dispatcher.accept(gamePiece);\n           }\n         }\n-      }\n-      else {\n+      } else {\n         // For most Global Key Commands we need to run through the larger lists of maps & pieces. Ideally the Fast Matches\n         // here will filter some of that out to improve performance, but we also want to do the best job possible for old\n         // modules that don't take advantage of Fast Match yet.\n@@ -348,8 +352,7 @@ public class GlobalCommand {\n               for (final GamePiece pieceOrStack : everythingOnMap) {\n                 dispatcher.accept(pieceOrStack);\n               }\n-            }\n-            else {\n+            } else {\n               // This loop is WITH property Fast Match but WITHOUT location Fast Match\n               for (final GamePiece pieceOrStack : everythingOnMap) {\n                 final List<GamePiece> pieceList;\n@@ -357,8 +360,7 @@ public class GlobalCommand {\n                 // We may have an individual piece, or we may have a Stack (or Deck), in which case we need to traverse it.\n                 if (pieceOrStack instanceof Stack) {\n                   pieceList = ((Stack) pieceOrStack).asList();\n-                }\n-                else {\n+                } else {\n                   pieceList = Collections.singletonList(pieceOrStack); // Or if really just a single piece.\n                 }\n \n@@ -372,8 +374,7 @@ public class GlobalCommand {\n                 }\n               }\n             }\n-          }\n-          else {\n+          } else {\n             // WITH Location Fast Matching we have some extra steps\n             for (final GamePiece pieceOrStack : everythingOnMap) {\n               final List<GamePiece> pieceList;\n@@ -381,8 +382,7 @@ public class GlobalCommand {\n               // We may have an individual piece, or we may have a Stack (or Deck), in which case we need to traverse it.\n               if (pieceOrStack instanceof Stack) {\n                 pieceList = ((Stack) pieceOrStack).asList();\n-              }\n-              else {\n+              } else {\n                 pieceList = Collections.singletonList(pieceOrStack); // Or if really just a single piece.\n               }\n \n@@ -438,12 +438,10 @@ public class GlobalCommand {\n       // single piece affected by this command. This command can be sent to other clients involved in the same\n       // game to replicate all the stuff we just did.\n       command = visitor.getCommand();\n-    }\n-    catch (RecursionLimitException e) {\n+    } catch (RecursionLimitException e) {\n       // It is very easy to construct a set of GKC commands that fire each other off infinitely. This catches those.\n       RecursionLimiter.infiniteLoop(e);\n-    }\n-    finally {\n+    } finally {\n       RecursionLimiter.endExecution();\n       if (reportSingle) {\n         Map.setChangeReportingEnabled(true); // Restore normal reporting behavior (if we'd disabled all individual reports)\n@@ -455,17 +453,19 @@ public class GlobalCommand {\n \n   /**\n    * (Legacy - applies GKC without Fast Match)\n-   * @param map a single map\n+   *\n+   * @param map    a single map\n    * @param filter filter\n    * @return command\n    */\n   public Command apply(Map map, PieceFilter filter) {\n-    return apply(new Map[]{map}, filter);\n+    return apply(new Map[] {map}, filter);\n   }\n \n   /**\n    * (Legacy - applies GKC without Fast Match)\n-   * @param maps list of maps\n+   *\n+   * @param maps   list of maps\n    * @param filter filter\n    * @return command\n    */\n@@ -475,13 +475,14 @@ public class GlobalCommand {\n \n   /**\n    * Apply the key command on ONE SPECIFIC MAP to all pieces that pass the given filter and our Fast Match parameters.\n-   * @param map a single map\n-   * @param filter Filter to apply (created e.g. with {@link PropertyExpression#getFilter}\n+   *\n+   * @param map       a single map\n+   * @param filter    Filter to apply (created e.g. with {@link PropertyExpression#getFilter}\n    * @param fastMatch Fast matching parameters, or null. {@link GlobalCommandTarget} and {@link VASSAL.configure.GlobalCommandTargetConfigurer}\n    * @return the corresponding {@link Command} that would reproduce all the things this GKC just did, on another client.\n    */\n   public Command apply(Map map, PieceFilter filter, GlobalCommandTarget fastMatch) {\n-    return apply(new Map[]{map}, filter, fastMatch);\n+    return apply(new Map[] {map}, filter, fastMatch);\n   }\n \n   protected class Visitor implements DeckVisitor {\n@@ -501,16 +502,17 @@ public class GlobalCommand {\n     @Override\n     public Object visitDeck(Deck d) {\n       if (getSelectFromDeck() != 0) {\n-        \n+\n         // selectFromDeck = -1 means process all cards in Deck\n         // selectFromDeck > 0 means select that many cards from the Deck\n-        \n+\n         // Ask for all cards to be drawn.        \n         d.setDragCount(d.getPieceCount());\n-        \n+\n         // Keep drawing until required select count met or all cards in Deck have been processed\n         selectedCount = 0;\n-        for (final PieceIterator it = d.drawCards(); it.hasMoreElements() && (getSelectFromDeck() < 0 || getSelectFromDeck() > selectedCount);) {\n+        for (final PieceIterator it = d.drawCards();\n+             it.hasMoreElements() && (getSelectFromDeck() < 0 || getSelectFromDeck() > selectedCount); ) {\n           apply(it.nextPiece(), true);\n         }\n       }\n@@ -536,17 +538,18 @@ public class GlobalCommand {\n     private void apply(GamePiece p, boolean visitingDeck) {\n       if (filter == null || filter.accept(p)) {\n         if (visitingDeck) {\n-          p.setProperty(Properties.OBSCURED_BY, p.getProperty(Properties.OBSCURED_BY_PRE_DRAW));  // Bug 13433 restore correct OBSCURED_BY after checking filter\n+          p.setProperty(Properties.OBSCURED_BY,\n+            p.getProperty(Properties.OBSCURED_BY_PRE_DRAW));  // Bug 13433 restore correct OBSCURED_BY after checking filter\n         }\n         tracker.addPiece(p);\n         p.setProperty(Properties.SNAPSHOT, ((PropertyExporter) p).getProperties());\n         command.append(p.keyEvent(stroke));\n         tracker.addPiece(p);\n         selectedCount++;\n-      }\n-      else {\n+      } else {\n         if (visitingDeck) {\n-          p.setProperty(Properties.OBSCURED_BY, p.getProperty(Properties.OBSCURED_BY_PRE_DRAW));  // Bug 13433 restore correct OBSCURED_BY\n+          p.setProperty(Properties.OBSCURED_BY,\n+            p.getProperty(Properties.OBSCURED_BY_PRE_DRAW));  // Bug 13433 restore correct OBSCURED_BY\n         }\n       }\n     }\n@@ -566,6 +569,7 @@ public class GlobalCommand {\n \n   /**\n    * Set the number of pieces to select from a deck that the command will apply to.  A value <0 means to apply to all pieces in the deck\n+   *\n    * @param selectFromDeck Number of pieces to select\n    */\n   public void setSelectFromDeck(int selectFromDeck) {\n@@ -586,29 +590,36 @@ public class GlobalCommand {\n \n   @Override\n   public boolean equals(Object obj) {\n-    if (this == obj)\n+    if (this == obj) {\n       return true;\n-    if (obj == null)\n+    }\n+    if (obj == null) {\n       return false;\n-    if (getClass() != obj.getClass())\n+    }\n+    if (getClass() != obj.getClass()) {\n       return false;\n+    }\n     final GlobalCommand other = (GlobalCommand) obj;\n     if (keyStroke == null) {\n-      if (other.keyStroke != null)\n+      if (other.keyStroke != null) {\n         return false;\n-    }\n-    else if (!keyStroke.equals(other.keyStroke))\n+      }\n+    } else if (!keyStroke.equals(other.keyStroke)) {\n       return false;\n+    }\n     if (reportFormat == null) {\n-      if (other.reportFormat != null)\n+      if (other.reportFormat != null) {\n         return false;\n-    }\n-    else if (!reportFormat.equals(other.reportFormat))\n+      }\n+    } else if (!reportFormat.equals(other.reportFormat)) {\n       return false;\n-    if (reportSingle != other.reportSingle)\n+    }\n+    if (reportSingle != other.reportSingle) {\n       return false;\n-    if (selectFromDeck != other.selectFromDeck)\n+    }\n+    if (selectFromDeck != other.selectFromDeck) {\n       return false;\n+    }\n \n     // Match any specific targeting information, depending on the targeting type. targetType must always match.\n     if (target.fastMatchLocation != other.target.fastMatchLocation) {\n@@ -623,10 +634,12 @@ public class GlobalCommand {\n     if ((target.targetType == GlobalCommandTarget.Target.ZONE) && !target.targetZone.equals(other.target.targetZone)) {\n       return false;\n     }\n-    if ((target.targetType == GlobalCommandTarget.Target.LOCATION) && !target.targetLocation.equals(other.target.targetLocation)) {\n+    if ((target.targetType == GlobalCommandTarget.Target.LOCATION) &&\n+      !target.targetLocation.equals(other.target.targetLocation)) {\n       return false;\n     }\n-    if ((target.targetType == GlobalCommandTarget.Target.XY) && (!target.targetBoard.equals(other.target.targetBoard) || ((!target.targetX.equals(other.target.targetX)) || (!target.targetY.equals(other.target.targetY))))) {\n+    if ((target.targetType == GlobalCommandTarget.Target.XY) && (!target.targetBoard.equals(other.target.targetBoard) ||\n+      ((!target.targetX.equals(other.target.targetX)) || (!target.targetY.equals(other.target.targetY))))) {\n       return false;\n     }\n \n",
            "diff_size": 84
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vassalengine-vassal/errored/1/1/GlobalCommand.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vassalengine-vassal/styler_random/1/GlobalCommand.java\nindex 3c1ad07f586..aedda930b06 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vassalengine-vassal/errored/1/1/GlobalCommand.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vassalengine-vassal/styler_random/1/GlobalCommand.java\n@@ -142,7 +142,7 @@ public class GlobalCommand {\n       return false;\n     }\n \n-    switch(target.targetCompare) {\n+    switch (target.targetCompare) {\n     case MATCH:\n       return fastPattern.matcher(value).matches();\n     case NOT_MATCH:\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vassalengine-vassal/errored/1/1/GlobalCommand.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vassalengine-vassal/styler_three_grams/1/GlobalCommand.java\nindex 3c1ad07f586..3d147ed1a46 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vassalengine-vassal/errored/1/1/GlobalCommand.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vassalengine-vassal/styler_three_grams/1/GlobalCommand.java\n@@ -141,8 +141,7 @@ public class GlobalCommand {\n     if (value == null) {\n       return false;\n     }\n-\n-    switch(target.targetCompare) {\n+    switch (target.targetCompare) {\n     case MATCH:\n       return fastPattern.matcher(value).matches();\n     case NOT_MATCH:\n",
            "diff_size": 2
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "naturalize",
        "codebuff"
    ]
}