{
    "project_name": "IQSS-dataverse",
    "error_id": "14",
    "information": {
        "errors": [
            {
                "line": "356",
                "column": "1",
                "severity": "error",
                "message": "File contains tab characters (this is the first instance).",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
            }
        ]
    },
    "source_code": "        \n        // the following methods are now executed, in this order:\n\t    \n\t// decodeHeader -- this method doesn't read any [meta]data and \n\t//    doesn't initialize any values; its only purpose is to \n\t//    make sure that the file is indeed an SPSS/SAV file. ",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "356",
                    "column": "1",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/14/SAVFileReader.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/intellij/14/SAVFileReader.java\nindex 682b8f1166c..f774e3df0e6 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/14/SAVFileReader.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/intellij/14/SAVFileReader.java\n@@ -17,6 +17,7 @@\n    Developed at the Institute for Quantitative Social Science, Harvard University.\n    Version 3.0.\n */\n+\n package edu.harvard.iq.dataverse.ingest.tabulardata.impl.plugins.sav;\n \n import java.io.BufferedInputStream;\n@@ -70,2601 +71,2598 @@ import edu.harvard.iq.dataverse.ingest.tabulardata.InvalidData;\n \n /**\n  * ingest plugin for SPSS SAV file format.\n- *\n+ * <p>\n  * This reader plugin has been fully re-implemented for the DVN 4.0;\n- * It is still borrows heavily from, and builds on the basis of the \n- * old implementation by Akio Sone, that was in use in the versions \n+ * It is still borrows heavily from, and builds on the basis of the\n+ * old implementation by Akio Sone, that was in use in the versions\n  * 2-3 of the DVN.\n- * \n+ *\n  * @author Akio Sone at UNC-Odum\n  * @author Leonid Andreev\n  */\n \n-public class SAVFileReader  extends TabularDataFileReader{\n-    \n-    // static fields ---------------------------------------------------------//\n-    private static String[] FORMAT_NAMES = {\"sav\", \"SAV\"};\n-    private static String[] EXTENSIONS = {\"sav\"};\n-    private static String[] MIME_TYPE = {\"application/x-spss-sav\"};\n-\n-    private static final int LENGTH_SAV_INT_BLOCK = 4;\n-    // note: OBS block is either double or String, not Integer\n-    private static final int LENGTH_SAV_OBS_BLOCK = 8;\n-    \n-    private static final int SAV_MAGIC_NUMBER_LENGTH = LENGTH_SAV_INT_BLOCK;\n-    \n-    private static String SAV_FILE_SIGNATURE = \"$FL2\";\n-\n-    \n-    \n-    // Record Type 1 fields\n-    private static final int LENGTH_RECORDTYPE1 = 172;\n-    \n-    private static final int LENGTH_SPSS_PRODUCT_INFO = 60;\n-    \n-    private static final int FILE_LAYOUT_CONSTANT = 2;\n-    \n-    private static final int LENGTH_FILE_LAYOUT_CODE =  LENGTH_SAV_INT_BLOCK;\n-    \n-    private static final int LENGTH_NUMBER_OF_OBS_UNITS_PER_CASE = LENGTH_SAV_INT_BLOCK;\n-    \n-    private static final int LENGTH_COMPRESSION_SWITCH = LENGTH_SAV_INT_BLOCK;\n-    \n-    private static final int LENGTH_CASE_WEIGHT_VARIABLE_INDEX = LENGTH_SAV_INT_BLOCK;\n-    \n-    private static final int LENGTH_NUMBER_OF_CASES =   LENGTH_SAV_INT_BLOCK;\n-    \n-    private static final int LENGTH_COMPRESSION_BIAS =  LENGTH_SAV_OBS_BLOCK;\n-    \n-    private static final int LENGTH_FILE_CREATION_INFO = 84;\n-    \n-    private static final int length_file_creation_date = 9;\n-    private static final int length_file_creation_time = 8;\n-    private static final int length_file_creation_label= 64;\n-    private static final int length_file_creation_padding = 3;\n-    \n-    // Recorde Type 2\n-    \n-    private static final int LENGTH_RECORDTYPE2_FIXED = 32;\n-    private static final int LENGTH_RECORD_TYPE2_CODE = 4;\n-    private static final int LENGTH_TYPE_CODE = 4;\n-    private static final int LENGTH_LABEL_FOLLOWS = 4;\n-    private static final int LENGTH_MISS_VALUE_FORMAT_CODE= 4;\n-    private static final int LENGTH_PRINT_FORMAT_CODE = 4;;\n-    private static final int LENGTH_WRITE_FORMAT_CODE = 4;\n-    private static final int LENGTH_VARIABLE_NAME =  8;\n-    private static final int LENGTH_VARIABLE_LABEL= 4;\n-\n-    private static final int LENGTH_MISS_VAL_OBS_CODE = LENGTH_SAV_OBS_BLOCK;\n-    \n-    // Record Type 3/4\n-    private static final int LENGTH_RECORDTYPE3_HEADER_CODE = 4;\n-    private static final int LENGTH_RECORD_TYPE3_CODE = 4;\n-    private static final int LENGTH_RT3_HOW_MANY_LABELS = 4;\n-    private static final int LENGTH_RT3_VALUE  = LENGTH_SAV_OBS_BLOCK;\n-    private static final int LENGTH_RT3_LABEL_LENGTH =1;\n-    \n-    private static final int LENGTH_RECORD_TYPE4_CODE =      4;\n-    private static final int LENGTH_RT4_HOW_MANY_VARIABLES = 4;\n-    private static final int LENGTH_RT4_VARIABLE_INDEX =     4;\n-    \n-    // Record Type 6\n-    private static final int LENGTH_RECORD_TYPE6_CODE =  4;\n-    private static final int LENGTH_RT6_HOW_MANY_LINES = 4;\n-    private static final int LENGTH_RT6_DOCUMENT_LINE = 80;\n-    \n-    // Record Type 7\n-    private static final int LENGTH_RECORD_TYPE7_CODE =  4;\n-    private static final int LENGTH_RT7_SUB_TYPE_CODE =  4;\n-\n-    // Record Type 999\n-    private static final int LENGTH_RECORD_TYPE999_CODE =  4;\n-    private static final int LENGTH_RT999_FILLER        =  4;\n-\n-    \n-    private static final List<String> RecordType7SubType4Fields= new ArrayList<String>();\n-    private static final Set<Integer> validMissingValueCodeSet = new HashSet<Integer>();\n-    private static final Map<Integer, Integer> missingValueCodeUnits = new HashMap<Integer, Integer>();\n-\n-    private static double SYSMIS_LITTLE =0xFFFFFFFFFFFFEFFFL;\n-    private static double SYSMIS_BIG =0xFFEFFFFFFFFFFFFFL;\n-    \n-    private static Calendar GCO = new GregorianCalendar();\n-    \n-    private String[] dateFormatList;\n-\n-    static {\n-        \n-        // initialize validMissingValueCodeSet\n-        validMissingValueCodeSet.add(3);\n-        validMissingValueCodeSet.add(2);\n-        validMissingValueCodeSet.add(1);\n-        validMissingValueCodeSet.add(0);\n-        validMissingValueCodeSet.add(-2);\n-        validMissingValueCodeSet.add(-3);\n-        \n-        // initialize missingValueCodeUnits\n-        \n-        missingValueCodeUnits.put(1, 1);\n-        missingValueCodeUnits.put(2, 2);\n-        missingValueCodeUnits.put(3, 3);\n-        missingValueCodeUnits.put(-2,2);\n-        missingValueCodeUnits.put(-3, 3);\n-        missingValueCodeUnits.put(0, 0);\n-\n-        RecordType7SubType4Fields.add(\"SYSMIS\");\n-        RecordType7SubType4Fields.add(\"HIGHEST\");\n-        RecordType7SubType4Fields.add(\"LOWEST\");\n-        \n-        // set the origin of GCO to 1582-10-15\n-        GCO.set(1, 1582);// year\n-        GCO.set(2, 9); // month\n-        GCO.set(5, 15);// day of month\n-        GCO.set(9, 0);// AM(0) or PM(1)\n-        GCO.set(10, 0);// hh\n-        GCO.set(12, 0);// mm\n-        GCO.set(13, 0);// ss\n-        GCO.set(14, 0); // SS millisecond\n-        GCO.set(15, 0);// z\n-    }\n+public class SAVFileReader extends TabularDataFileReader {\n \n-    private static final long SPSS_DATE_BIAS = 60*60*24*1000;\n+  // static fields ---------------------------------------------------------//\n+  private static String[] FORMAT_NAMES = {\"sav\", \"SAV\"};\n+  private static String[] EXTENSIONS = {\"sav\"};\n+  private static String[] MIME_TYPE = {\"application/x-spss-sav\"};\n \n-    private static final long SPSS_DATE_OFFSET = SPSS_DATE_BIAS + Math.abs(GCO.getTimeInMillis());\n+  private static final int LENGTH_SAV_INT_BLOCK = 4;\n+  // note: OBS block is either double or String, not Integer\n+  private static final int LENGTH_SAV_OBS_BLOCK = 8;\n \n+  private static final int SAV_MAGIC_NUMBER_LENGTH = LENGTH_SAV_INT_BLOCK;\n \n-   // instance fields -------------------------------------------------------//\n-    private static String unfVersionNumber = \"6\";\n+  private static String SAV_FILE_SIGNATURE = \"$FL2\";\n \n-    // instance fields -------------------------------------------------------//\n \n-    private static Logger dbgLog = Logger.getLogger(SAVFileReader.class.getPackage().getName());\n+  // Record Type 1 fields\n+  private static final int LENGTH_RECORDTYPE1 = 172;\n \n-    \n-    TabularDataIngest ingesteddata = new TabularDataIngest();\n-    private DataTable dataTable = new DataTable();\n-    \n-    Map<String, String> shortToLongVariableNameTable = new LinkedHashMap<String, String>();\n-    Map<String, String> formatCategoryTable = new LinkedHashMap<String, String>(); \n+  private static final int LENGTH_SPSS_PRODUCT_INFO = 60;\n \n+  private static final int FILE_LAYOUT_CONSTANT = 2;\n \n+  private static final int LENGTH_FILE_LAYOUT_CODE = LENGTH_SAV_INT_BLOCK;\n \n-    private boolean isLittleEndian = false;     \n-    private boolean isDataSectionCompressed = true; \n+  private static final int LENGTH_NUMBER_OF_OBS_UNITS_PER_CASE = LENGTH_SAV_INT_BLOCK;\n \n-    private Map<Integer, String> OBSIndexToVariableName =\n-        new LinkedHashMap<Integer, String>(); \n-    \n-    private int OBSUnitsPerCase; \n-    \n-    private List<Integer> variableTypelList= new ArrayList<Integer>(); \n-    private List<Integer> OBSwiseTypelList= new ArrayList<Integer>(); \n+  private static final int LENGTH_COMPRESSION_SWITCH = LENGTH_SAV_INT_BLOCK;\n \n-    Map<String, String> printFormatTable = new LinkedHashMap<String, String>(); \n-    \n+  private static final int LENGTH_CASE_WEIGHT_VARIABLE_INDEX = LENGTH_SAV_INT_BLOCK;\n \n-    Set<Integer> obsNonVariableBlockSet = new LinkedHashSet<Integer>(); \n-    \n+  private static final int LENGTH_NUMBER_OF_CASES = LENGTH_SAV_INT_BLOCK;\n \n-    Map<String, String> valueVariableMappingTable = new LinkedHashMap<String, String>(); \n- \n-    Map<String, Integer> extendedVariablesSizeTable = new LinkedHashMap<String, Integer>();\n+  private static final int LENGTH_COMPRESSION_BIAS = LENGTH_SAV_OBS_BLOCK;\n \n+  private static final int LENGTH_FILE_CREATION_INFO = 84;\n \n-    List<String> variableNameList = new ArrayList<String>(); \n+  private static final int length_file_creation_date = 9;\n+  private static final int length_file_creation_time = 8;\n+  private static final int length_file_creation_label = 64;\n+  private static final int length_file_creation_padding = 3;\n \n+  // Recorde Type 2\n \n-    Map<String, InvalidData> invalidDataTable = new LinkedHashMap<String, InvalidData>(); // this variable used in 2 methods; only one uses it to set the smd value -- ??\n+  private static final int LENGTH_RECORDTYPE2_FIXED = 32;\n+  private static final int LENGTH_RECORD_TYPE2_CODE = 4;\n+  private static final int LENGTH_TYPE_CODE = 4;\n+  private static final int LENGTH_LABEL_FOLLOWS = 4;\n+  private static final int LENGTH_MISS_VALUE_FORMAT_CODE = 4;\n+  private static final int LENGTH_PRINT_FORMAT_CODE = 4;\n+  ;\n+  private static final int LENGTH_WRITE_FORMAT_CODE = 4;\n+  private static final int LENGTH_VARIABLE_NAME = 8;\n+  private static final int LENGTH_VARIABLE_LABEL = 4;\n \n-    NumberFormat doubleNumberFormatter = new DecimalFormat();\n+  private static final int LENGTH_MISS_VAL_OBS_CODE = LENGTH_SAV_OBS_BLOCK;\n \n-    Set<Integer> decimalVariableSet = new HashSet<Integer>(); \n-    \n-    String[] variableFormatTypeList= null; \n+  // Record Type 3/4\n+  private static final int LENGTH_RECORDTYPE3_HEADER_CODE = 4;\n+  private static final int LENGTH_RECORD_TYPE3_CODE = 4;\n+  private static final int LENGTH_RT3_HOW_MANY_LABELS = 4;\n+  private static final int LENGTH_RT3_VALUE = LENGTH_SAV_OBS_BLOCK;\n+  private static final int LENGTH_RT3_LABEL_LENGTH = 1;\n \n-    List<Integer> formatDecimalPointPositionList= new ArrayList<Integer>(); \n-  \n+  private static final int LENGTH_RECORD_TYPE4_CODE = 4;\n+  private static final int LENGTH_RT4_HOW_MANY_VARIABLES = 4;\n+  private static final int LENGTH_RT4_VARIABLE_INDEX = 4;\n \n-    int caseWeightVariableOBSIndex = 0; \n-    \n+  // Record Type 6\n+  private static final int LENGTH_RECORD_TYPE6_CODE = 4;\n+  private static final int LENGTH_RT6_HOW_MANY_LINES = 4;\n+  private static final int LENGTH_RT6_DOCUMENT_LINE = 80;\n \n-    // date/time data formats\n+  // Record Type 7\n+  private static final int LENGTH_RECORD_TYPE7_CODE = 4;\n+  private static final int LENGTH_RT7_SUB_TYPE_CODE = 4;\n \n-    private SimpleDateFormat sdf_ymd    = new SimpleDateFormat(\"yyyy-MM-dd\");\n-    private SimpleDateFormat sdf_ymdhms = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n-    private SimpleDateFormat sdf_dhms   = new SimpleDateFormat(\"DDD HH:mm:ss\");\n-    private SimpleDateFormat sdf_hms    = new SimpleDateFormat(\"HH:mm:ss\");\n+  // Record Type 999\n+  private static final int LENGTH_RECORD_TYPE999_CODE = 4;\n+  private static final int LENGTH_RT999_FILLER = 4;\n \n \n-    Map<String, String> OBSTypeHexValue = new LinkedHashMap<String, String>();    \n-    \n-    /*\n-     * TODO: add a comment explaining the whole thing about this default\n-     * character set. -- L.A. 4.0 beta\n-    */\n-    private String defaultCharSet = \"ISO-8859-1\";\n-    //private String defaultCharSet = \"US-ASCII\"; // -- temporary! -- 4.0 beta 6\n-    private int    spssVersionNumber = 0; \n+  private static final List<String> RecordType7SubType4Fields = new ArrayList<String>();\n+  private static final Set<Integer> validMissingValueCodeSet = new HashSet<Integer>();\n+  private static final Map<Integer, Integer> missingValueCodeUnits = new HashMap<Integer, Integer>();\n \n+  private static double SYSMIS_LITTLE = 0xFFFFFFFFFFFFEFFFL;\n+  private static double SYSMIS_BIG = 0xFFEFFFFFFFFFFFFFL;\n \n-    /**\n-     * The <code>String</code> that represents the numeric missing value \n-     * in the final tab-delimited data file.\n-     */\n-    private String MissingValueForTextDataFileNumeric = \"\";\n+  private static Calendar GCO = new GregorianCalendar();\n \n-    \n-    public String getMissingValueForTextDataFileNumeric() {\n-        return MissingValueForTextDataFileNumeric;\n-    }\n+  private String[] dateFormatList;\n \n-    \n-    public void setMissingValueForTextDataFileNumeric(String MissingValueToken) {\n-        this.MissingValueForTextDataFileNumeric = MissingValueToken;\n-    }\n+  static {\n \n+    // initialize validMissingValueCodeSet\n+    validMissingValueCodeSet.add(3);\n+    validMissingValueCodeSet.add(2);\n+    validMissingValueCodeSet.add(1);\n+    validMissingValueCodeSet.add(0);\n+    validMissingValueCodeSet.add(-2);\n+    validMissingValueCodeSet.add(-3);\n \n-    String MissingValueForTextDataFileString = \"\";\n+    // initialize missingValueCodeUnits\n \n-    \n-    public String getMissingValueForTextDataFileString() {\n-        return MissingValueForTextDataFileString;\n-    }\n+    missingValueCodeUnits.put(1, 1);\n+    missingValueCodeUnits.put(2, 2);\n+    missingValueCodeUnits.put(3, 3);\n+    missingValueCodeUnits.put(-2, 2);\n+    missingValueCodeUnits.put(-3, 3);\n+    missingValueCodeUnits.put(0, 0);\n \n-    \n-    public void setMissingValueForTextDataFileString(String MissingValueToken) {\n-        this.MissingValueForTextDataFileString = MissingValueToken;\n-    }\n+    RecordType7SubType4Fields.add(\"SYSMIS\");\n+    RecordType7SubType4Fields.add(\"HIGHEST\");\n+    RecordType7SubType4Fields.add(\"LOWEST\");\n \n-    \n-    public SAVFileReader(TabularDataFileReaderSpi originator){\n-        super(originator);\n-    }\n+    // set the origin of GCO to 1582-10-15\n+    GCO.set(1, 1582);// year\n+    GCO.set(2, 9); // month\n+    GCO.set(5, 15);// day of month\n+    GCO.set(9, 0);// AM(0) or PM(1)\n+    GCO.set(10, 0);// hh\n+    GCO.set(12, 0);// mm\n+    GCO.set(13, 0);// ss\n+    GCO.set(14, 0); // SS millisecond\n+    GCO.set(15, 0);// z\n+  }\n \n-    // Methods ---------------------------------------------------------------//\n-\n-    private void init() throws IOException {\n-        \n-        sdf_ymd.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n-        sdf_ymdhms.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n-        sdf_dhms.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n-        sdf_hms.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n-                \n-        doubleNumberFormatter.setGroupingUsed(false);\n-        doubleNumberFormatter.setMaximumFractionDigits(340);\n-        \n-        if (getDataLanguageEncoding() != null) {\n-            defaultCharSet = getDataLanguageEncoding(); \n-        }\n-    }\n+  private static final long SPSS_DATE_BIAS = 60 * 60 * 24 * 1000;\n \n-    public TabularDataIngest read(BufferedInputStream stream, File dataFile) throws IOException{\n-        dbgLog.info(\"SAVFileReader: read() start\");\n-        \n-        if (dataFile != null) {\n-            throw new IOException (\"this plugin does not support external raw data files\");\n-        }\n-        \n-        /* \n-         * this \"try\" block is for catching unknown/unexpected exceptions \n-         * thrown anywhere in the ingest code:\n-         */\n-        try {\n-         /* ingest happens here ... */ \n-        \n-        // the following methods are now executed, in this order:\n-\t    \n-\t// decodeHeader -- this method doesn't read any [meta]data and \n-\t//    doesn't initialize any values; its only purpose is to \n-\t//    make sure that the file is indeed an SPSS/SAV file. \n-\t// \n-\t// decodeRecordType1 -- there's always one RT1 record; it is \n-\t//    always 176 byte long. it contains the very basic metadata\n-\t//    about the data file. most notably, the number of observations\n-\t//    and the number of OBS (8 byte values) per observation.\n-\t//\n-\t// decodeRecordType2 -- there are multiple RT2 records. there's \n-\t//    one RT2 for every OBS (8 byte value); i.e. one per variable,\n-\t//    or more per every String variable split into multiple OBS\n-\t//    segments. this one is a 400 line method, that may benefit \n-\t//    from being split into smaller methods.\n-\t//\n-\t// decodeRecordType3and4 -- these sections come in pairs, each\n-\t//    pair dedicated to one set of variable labels. \n-\t// decodeRecordType6,\n-\t//\n-\t// decodeRecordType7 -- this RT contains some extended \n-\t//    metadata for the data file. (including the information \n-\t//    about the extended variables, i.e. variables longer than\n-\t//    255 bytes split into 255 byte fragments that are stored \n-\t//    in the data file as independent variables). \n-\t//\n-\t// decodeRecordType999 -- this RT does not contain any data; \n-\t//    its sole function is to indicate that the metadata portion \n-\t//    of the data file is over and the data section follows. \n-\t// \n-\t// decodeRecordTypeData -- this method decodes the data section \n-\t//    of the file. Inside this method, 2 distinct methods are \n-\t//    called to process compressed or uncompressed data, depending\n-\t//    on which method is used in this data file. \n-\n-\n-\tString methodCurrentlyExecuted = null; \n-\n-\ttry {\n-\t    methodCurrentlyExecuted = \"decodeHeader\";\n-\t    dbgLog.fine(\"***** SAVFileReader: executing method decodeHeader\");\n-\t    decodeHeader(stream); \n-\n-\t    methodCurrentlyExecuted = \"decodeRecordType1\";\n-\t    dbgLog.fine(\"***** SAVFileReader: executing method decodeRecordType1\");\n-\t    decodeRecordType1(stream); \n-\n-\t    methodCurrentlyExecuted = \"decodeRecordType2\";\n-\t    dbgLog.fine(\"***** SAVFileReader: executing method decodeRecordType1\");\n-\t    decodeRecordType2(stream); \n-\n-\t    methodCurrentlyExecuted = \"decodeRecordType3and4\"; \n-\t    dbgLog.fine(\"***** SAVFileReader: executing method decodeRecordType3and4\");\n-\t    decodeRecordType3and4(stream); \n-\n-\t    methodCurrentlyExecuted = \"decodeRecordType6\";\n-\t    dbgLog.fine(\"***** SAVFileReader: executing method decodeRecordType6\");\n-\t    decodeRecordType6(stream); \n-\n-\t    methodCurrentlyExecuted = \"decodeRecordType7\";\n-\t    dbgLog.fine(\"***** SAVFileReader: executing method decodeRecordType7\");\n-\t    decodeRecordType7(stream);\n-\n-\t    methodCurrentlyExecuted = \"decodeRecordType999\"; \n-\t    dbgLog.fine(\"***** SAVFileReader: executing method decodeRecordType999\");\n-\t    decodeRecordType999(stream);\n-\n-\t    methodCurrentlyExecuted = \"decodeRecordTypeData\";\n-\t    dbgLog.fine(\"***** SAVFileReader: executing method decodeRecordTypeData\");\n-\t    decodeRecordTypeData(stream); \n-\n-\t\t\n-\t} catch (IllegalArgumentException e) {\n-\t    //Throwable cause = e.getCause();\n-\t    dbgLog.fine(\"***** SAVFileReader: ATTENTION: IllegalArgumentException thrown while executing \"+methodCurrentlyExecuted);\n-\t    e.printStackTrace();\n-\t    throw new IOException ( \"IllegalArgumentException in method \"+methodCurrentlyExecuted+\": \"+e.getMessage() ); \n-\t} catch (IOException e) {\n-\t    dbgLog.fine(\"***** SAVFileReader: ATTENTION: IOException thrown while executing \"+methodCurrentlyExecuted);\n-\t    e.printStackTrace();\n-\t    throw new IOException ( \"IO Exception in method \"+methodCurrentlyExecuted+\": \"+e.getMessage() ); \n-\t} \n-\t\n-        /* \n-         * Final variable type assignments;\n-         * TODO: (maybe?) \n-         * Instead of doing it here, perhaps all the type assignments need to \n-         * be done on DataVariable objects directly;  without relying on \n-         * maps and lists here... -- L.A. 4.0 beta (?)\n-         */\n+  private static final long SPSS_DATE_OFFSET = SPSS_DATE_BIAS + Math.abs(GCO.getTimeInMillis());\n \n-        \n-        for (int indx = 0; indx < variableTypelList.size(); indx++) {\n-            String varName = dataTable.getDataVariables().get(indx).getName(); \n-            int simpleType = 0;\n-            if (variableTypelList.get(indx) != null) {\n-                simpleType = variableTypelList.get(indx).intValue();\n-            }\n \n-            if (simpleType <= 0) {\n-                // We need to make one last type adjustment:\n-                // Dates and Times will be stored as character values in the \n-                // dataverse tab files; even though they are not typed as \n-                // strings at this point:\n-                // TODO: \n-                // Make sure the date/time format is properly preserved!\n-                // (see the setFormatCategory below... but double-check!)\n-                // -- L.A. 4.0 alpha\n-                String variableFormatType = variableFormatTypeList[indx];\n-                if (variableFormatType != null) {\n-                    if (variableFormatType.equals(\"time\")\n-                        || variableFormatType.equals(\"date\")) {\n-                        simpleType = 1; \n-                    \n-                        String formatCategory = formatCategoryTable.get(varName);\n-\n-                        if (formatCategory != null) {\n-                            if (dateFormatList[indx] != null) {\n-                                dbgLog.fine(\"setting format category to \"+formatCategory);\n-                                dataTable.getDataVariables().get(indx).setFormatCategory(formatCategory);\n-                                dbgLog.fine(\"setting formatschemaname to \"+dateFormatList[indx]);\n-                                dataTable.getDataVariables().get(indx).setFormat(dateFormatList[indx]);\n-                            }\n-                        }\n-                    } else if (variableFormatType.equals(\"other\")) {\n-                        dbgLog.fine(\"Variable of format type \\\"other\\\"; type adjustment may be needed\");\n-                        dbgLog.fine(\"SPSS print format: \"+printFormatTable.get(dataTable.getDataVariables().get(indx).getName()));\n-                        \n-                        if (printFormatTable.get(dataTable.getDataVariables().get(indx).getName()).equals(\"WKDAY\")\n-                            || printFormatTable.get(dataTable.getDataVariables().get(indx).getName()).equals(\"MONTH\")) {\n-                            // week day or month; \n-                            // These are not treated as time/date values (meaning, we \n-                            // don't define time/date formats for them; there's likely \n-                            // no valid ISO time/date format for just a month or a day \n-                            // of week). However, the\n-                            // values will be stored in the TAB files as strings, \n-                            // and not as numerics - as they were stored in the \n-                            // SAV file. So we need to adjust the type here.\n-                            // -- L.A. \n-                            \n-                            simpleType = 1;\n-                        }\n-                    }\n-                }\n-            }\n-            \n-            // OK, we can now assign the types: \n-            \n-            if (simpleType > 0) {\n-                // String: \n-                dataTable.getDataVariables().get(indx).setTypeCharacter();\n-                dataTable.getDataVariables().get(indx).setIntervalDiscrete();\n-            } else {\n-                // Numeric: \n-                dataTable.getDataVariables().get(indx).setTypeNumeric();\n-                // discrete or continuous?\n-                // \"decimal variables\" become dataverse data variables of interval type \"continuous\":\n-        \n-                if (decimalVariableSet.contains(indx)) {\n-                    dataTable.getDataVariables().get(indx).setIntervalContinuous();\n-                } else {\n-                    dataTable.getDataVariables().get(indx).setIntervalDiscrete();\n-                }\n-                \n-            }\n-            \n-            // TODO: take care of the SPSS \"shortToLongVariableNameTable\"\n-            // mapping before returning the ingested data object. -- 4.0 alpha\n-            // (done, below - but verify!)\n-            \n-            if (shortToLongVariableNameTable.containsKey(varName)) {\n-                String longName = shortToLongVariableNameTable.get(varName); \n-                if (longName != null && !longName.equals(\"\")) {\n-                    dataTable.getDataVariables().get(indx).setName(longName);\n-                }\n-            }\n-            \n-        }        \n-        \n-        ingesteddata.setDataTable(dataTable);\n-        } catch (Exception ex) {\n-            dbgLog.fine(\"***** SAVFileReader: ATTENTION: unknown exception thrown.\");\n-\t    ex.printStackTrace();\n-            String failureMessage = \"Unknown exception in SPSS/SAV reader\";\n-            if (ex.getMessage() != null) {\n-                failureMessage = failureMessage.concat(\": \"+ex.getMessage());\n-            } else {\n-                failureMessage = failureMessage.concat(\"; no further information is available.\");\n-            }\n-\t    throw new IOException (failureMessage);    \n-        }\n-        dbgLog.info(\"SAVFileReader: read() end\");\n-        return ingesteddata;\n-    }\n-    \n-    void decodeHeader(BufferedInputStream stream) throws IOException {\n-        dbgLog.fine(\"decodeHeader(): start\");\n-        \n-        if (stream ==null){\n-            throw new IllegalArgumentException(\"stream == null!\");\n-        }\n-        // the length of the magic number is 4 (1-byte character * 4)\n-        // its value is expected to be $FL2\n-\n-        byte[] b = new byte[SAV_MAGIC_NUMBER_LENGTH];\n-        \n-        try {\n-            if (stream.markSupported()){\n-                stream.mark(100);\n-            }\n-            int nbytes = stream.read(b, 0, SAV_MAGIC_NUMBER_LENGTH);\n+  // instance fields -------------------------------------------------------//\n+  private static String unfVersionNumber = \"6\";\n \n-            if (nbytes == 0){\n-                throw new IOException();\n-            }\n+  // instance fields -------------------------------------------------------//\n \n-        } catch (IOException ex){\n-            //ex.printStackTrace();\n-\t    throw ex; \n-        }\n+  private static Logger dbgLog = Logger.getLogger(SAVFileReader.class.getPackage().getName());\n \n-        //printHexDump(b, \"hex dump of the byte-array\");\n \n-        String hdr4sav = new String(b);\n-        dbgLog.fine(\"from string=\" + hdr4sav);\n+  TabularDataIngest ingesteddata = new TabularDataIngest();\n+  private DataTable dataTable = new DataTable();\n \n-        if (hdr4sav.equals(SAV_FILE_SIGNATURE)) {\n-            dbgLog.fine(\"this file is spss-sav type\");\n-            // initialize version-specific parameter\n-            init();\n-            \n-            dataTable.setOriginalFileFormat(MIME_TYPE[0]);\n-            \n-            dataTable.setUnf(\"UNF:6:\");\n+  Map<String, String> shortToLongVariableNameTable = new LinkedHashMap<String, String>();\n+  Map<String, String> formatCategoryTable = new LinkedHashMap<String, String>();\n \n-            \n-        } else {\n-            dbgLog.fine(\"this file is NOT spss-sav type\");\n \n-            throw new IllegalArgumentException(\"given file is not spss-sav type\");\n-        }\n+  private boolean isLittleEndian = false;\n+  private boolean isDataSectionCompressed = true;\n \n-        dbgLog.fine(\"***** decodeHeader(): end *****\");\n+  private Map<Integer, String> OBSIndexToVariableName =\n+    new LinkedHashMap<Integer, String>();\n \n-    }\n+  private int OBSUnitsPerCase;\n \n+  private List<Integer> variableTypelList = new ArrayList<Integer>();\n+  private List<Integer> OBSwiseTypelList = new ArrayList<Integer>();\n \n-    void decodeRecordType1(BufferedInputStream stream) throws IOException {\n-        dbgLog.fine(\"***** decodeRecordType1(): start *****\");\n+  Map<String, String> printFormatTable = new LinkedHashMap<String, String>();\n \n-        if (stream ==null){\n-            throw new IllegalArgumentException(\"stream == null!\");\n-        }\n-        // how to read each recordType\n-        // 1. set-up the following objects before reading bytes\n-        // a. the working byte array\n-        // b. the storage object\n-        // the length of this field: 172bytes = 60 + 4 + 12 + 4 + 8 + 84\n-        // this field consists of 6 distinct blocks\n-        \n-        byte[] recordType1 = new byte[LENGTH_RECORDTYPE1];\n-\t// int caseWeightVariableOBSIndex = 0; \n-        \n-        try {\n-            int nbytes = stream.read(recordType1, 0, LENGTH_RECORDTYPE1);\n-            \n-            \n-            //printHexDump(recordType1, \"recordType1\");\n-            \n-            if (nbytes == 0){\n-                throw new IOException(\"reading recordType1: no byte was read\");\n-            }\n-            \n-            // 1.1 60 byte-String that tells the platform/version of SPSS that\n-            // wrote this file\n-            \n-            int offset_start = 0;\n-            int offset_end = LENGTH_SPSS_PRODUCT_INFO; // 60 bytes\n-            \n-            String productInfo = new String(Arrays.copyOfRange(recordType1, offset_start,\n-                offset_end),\"US-ASCII\");\n-                \n-            dbgLog.fine(\"productInfo:\\n\"+productInfo+\"\\n\");\n-            dataTable.setOriginalFormatVersion(productInfo);\n-\n-            \n-            // try to parse out the SPSS version that created this data\n-            // file: \n-            \n-            String spssVersionTag = null; \n-            \n-            String regexpVersionNumber = \".*Release ([0-9]*)\";\n-            Pattern versionTagPattern = Pattern.compile(regexpVersionNumber);\n-            Matcher matcher = versionTagPattern.matcher(productInfo);\n-            if ( matcher.find() ) {\n-                spssVersionTag = matcher.group(1); \n-                dbgLog.fine(\"SPSS Version Number: \"+spssVersionTag); \n-            }\n-            \n-            // TODO: \n-            // try a more elaborate regex (like the one for the \"new-style\" \n-            // productInfo line, below), to select the version number, the \n-            // minor version number and the platform (windows vs. mac) separately. \n-            // would be cleaner to save just that, rather than the entire \n-            // productInfo tag. \n-            // -- L.A. 4.0 beta\n-            \n-            if (spssVersionTag == null || spssVersionTag.equals(\"\")) {\n-                // Later versions of SPSS have different formatting of the\n-                // productInfo line:\n-                regexpVersionNumber = \".* IBM SPSS STATISTICS.* ([^ ]*) ([0-9][0-9]*)([^ ]*)\";\n-                versionTagPattern = Pattern.compile(regexpVersionNumber);\n-                matcher = versionTagPattern.matcher(productInfo);\n-                if (matcher.find()) {\n-                    String spssPlatformTag = matcher.group(1);\n-                    spssVersionTag = matcher.group(2);\n-                    String spssVersionTagMinor = matcher.group(3);\n-                    \n-                    dbgLog.fine(\"SPSS Version Number (new style): \" + spssVersionTag);\n-                    dbgLog.fine(\"SPSS Version/Platform Identification (new style:) \" +\n-                            spssPlatformTag + \" \" + spssVersionTag + spssVersionTagMinor);\n-                    dataTable.setOriginalFormatVersion(spssVersionTag + \n-                            spssVersionTagMinor + \" \" + \n-                            spssPlatformTag);\n-                    \n-                }\n-            }\n-            \n-            if (spssVersionTag != null && !spssVersionTag.equals(\"\")) {\n-                spssVersionNumber = Integer.valueOf(spssVersionTag).intValue();\n-                \n-\n-                /*\n-                 *  Starting with SPSS version 16, the default encoding is \n-                 *  UTF-8. \n-                 *  But we are only going to use it if the user did not explicitly\n-                 *  specify the encoding on the addfiles page. Then we'd want \n-                 *  to stick with whatever they entered. \n-                 *  (also, it appears that (starting with the same version 16?)\n-                 *  it is actually possible to define the locale/character set\n-                 *  in the file - section 7, sub-type 20; TODO: decide which \n-                 *  one takes precedence, if we have the encoding defined both\n-                 *  in the file and through the UI. -- L.A. 4.0 beta)\n-                 */\n-                if (spssVersionNumber > 15) {\n-                    if (getDataLanguageEncoding() == null) {\n-                        //defaultCharSet = \"windows-1252\"; // temporary! -- L.A. \"UTF-8\";\n-                        defaultCharSet = \"UTF-8\"; \n-                    }\n-                }\n-            }\n-             \n-            // TODO: \n-            // decide if we want to save the [determined/guessed] character set\n-            // somewhere in the dataset object. \n-            // this may be relevant in cases when accented/non-latin characters\n-            // get ingested incorrectly; \n-            // -- L.A. 4.0 beta\n-            \n-            // 1.2) 4-byte file-layout-code (byte-order)\n-            \n-            offset_start = offset_end;\n-            offset_end += LENGTH_FILE_LAYOUT_CODE; // 4 byte\n-            \n-            ByteBuffer bb_fileLayout_code  = ByteBuffer.wrap(\n-                    recordType1, offset_start, LENGTH_FILE_LAYOUT_CODE);\n-            \n-            ByteBuffer byteOderTest = bb_fileLayout_code.duplicate();\n-            // interprete the 4 byte as int\n-\n-            int int2test = byteOderTest.getInt();\n-            \n-            if (int2test == 2 || int2test == 3){\n-                dbgLog.fine(\"integer == \"+int2test+\": the byte-oder of the writer is the same \"+\n-                \"as the counterpart of Java: Big Endian\");\n-            } else {\n-                // Because Java's byte-order is always big endian, \n-                // this(!=2) means this sav file was  written on a little-endian machine\n-                // non-string, multi-bytes blocks must be byte-reversed\n \n-                bb_fileLayout_code.order(ByteOrder.LITTLE_ENDIAN);\n+  Set<Integer> obsNonVariableBlockSet = new LinkedHashSet<Integer>();\n \n-\t\tint2test = bb_fileLayout_code.getInt();\n \n-                if (int2test == 2 || int2test == 3){\n-                    dbgLog.fine(\"The sav file was saved on a little endian machine\");\n-                    dbgLog.fine(\"Reveral of the bytes is necessary to decode \"+\n-                            \"multi-byte, non-string blocks\");\n-                            \n-                    isLittleEndian = true;\n-                    \n-                } else {\n-                    throw new IOException(\"reading recordType1:unknown file layout code=\"+int2test);\n-                }\n-            }\n+  Map<String, String> valueVariableMappingTable = new LinkedHashMap<String, String>();\n \n-            dbgLog.fine(\"Endian of this platform:\"+ByteOrder.nativeOrder().toString());\n-\n-            // 1.3 4-byte Number_Of_OBS_Units_Per_Case \n-            // (= how many RT2 records => how many varilables)\n-            \n-            offset_start = offset_end;\n-            offset_end += LENGTH_NUMBER_OF_OBS_UNITS_PER_CASE; // 4 byte\n-            \n-            ByteBuffer bb_OBS_units_per_case  = ByteBuffer.wrap( \n-                    recordType1, offset_start,LENGTH_NUMBER_OF_OBS_UNITS_PER_CASE);\n-            \n-            if (isLittleEndian){\n-                bb_OBS_units_per_case.order(ByteOrder.LITTLE_ENDIAN);\n-            }\n-            \n-            \n-            OBSUnitsPerCase = bb_OBS_units_per_case.getInt();\n-            \n-            dbgLog.fine(\"RT1: OBSUnitsPerCase=\"+OBSUnitsPerCase);\n-\n-            // 1.4 4-byte Compression_Switch\n-            \n-            offset_start = offset_end;\n-            offset_end += LENGTH_COMPRESSION_SWITCH; // 4 byte\n-            \n-            ByteBuffer bb_compression_switch  = ByteBuffer.wrap(recordType1, \n-                    offset_start, LENGTH_COMPRESSION_SWITCH);\n-            \n-            if (isLittleEndian){\n-                bb_compression_switch.order(ByteOrder.LITTLE_ENDIAN);\n-            }\n-            \n-            int compression_switch = bb_compression_switch.getInt();\n-            if ( compression_switch == 0){\n-                // data section is not compressed\n-                isDataSectionCompressed = false;\n-                dbgLog.fine(\"data section is not compressed\");\n-            } else {\n-                dbgLog.fine(\"data section is compressed:\"+compression_switch);\n-            }\n-            \n-            // 1.5 4-byte Case-Weight Variable Index\n-            // warning: this variable index starts from 1, not 0\n-            \n-            offset_start = offset_end;\n-            offset_end += LENGTH_CASE_WEIGHT_VARIABLE_INDEX; // 4 byte\n-            \n-            ByteBuffer bb_Case_Weight_Variable_Index = ByteBuffer.wrap(recordType1, \n-                    offset_start, LENGTH_CASE_WEIGHT_VARIABLE_INDEX);\n-            \n-            if (isLittleEndian){\n-                bb_Case_Weight_Variable_Index.order(ByteOrder.LITTLE_ENDIAN);\n-            }\n-            \n-            caseWeightVariableOBSIndex = bb_Case_Weight_Variable_Index.getInt();\n-            \n-            /// caseWeightVariableOBSIndex will be used later on to locate \n-            /// the weight variable; so we'll be able to mark the corresponding\n-            /// variables properly. \n-            // TODO: make sure case weight variables are properly handled! \n-            // -- L.A. 4.0 beta\n-            ///smd.getFileInformation().put(\"caseWeightVariableOBSIndex\", caseWeightVariableOBSIndex);\n-\n-            // 1.6 4-byte Number of Cases\n-\n-            offset_start = offset_end;\n-            offset_end += LENGTH_NUMBER_OF_CASES; // 4 byte\n-            \n-            ByteBuffer bb_Number_Of_Cases = ByteBuffer.wrap(recordType1, \n-                    offset_start, LENGTH_NUMBER_OF_CASES);\n-            \n-            if (isLittleEndian){\n-                bb_Number_Of_Cases.order(ByteOrder.LITTLE_ENDIAN);\n-            }\n-            \n-            int numberOfCases = bb_Number_Of_Cases.getInt();\n-            \n-            if ( numberOfCases < 0){\n-                // -1 if numberOfCases is unknown\n-                throw new RuntimeException(\"number of cases is not recorded in the header\");\n-            } else {\n-                dbgLog.fine(\"RT1: number of cases is recorded= \"+numberOfCases);\n-                dataTable.setCaseQuantity(new Long(numberOfCases));\n-                ///caseQnty = numberOfCases;\n-                ///smd.getFileInformation().put(\"caseQnty\", numberOfCases);\n-            }\n+  Map<String, Integer> extendedVariablesSizeTable = new LinkedHashMap<String, Integer>();\n \n-            // 1.7 8-byte compression-bias [not long but double]\n-            \n-            offset_start = offset_end;\n-            offset_end += LENGTH_COMPRESSION_BIAS; // 8 byte\n-            \n-            ByteBuffer bb_compression_bias = ByteBuffer.wrap( \n-                    Arrays.copyOfRange(recordType1, offset_start,\n-                offset_end));\n-\n-            if (isLittleEndian){\n-               bb_compression_bias.order(ByteOrder.LITTLE_ENDIAN);\n-            }\n \n-            Double compressionBias = bb_compression_bias.getDouble();\n-            \n-            // TODO: \n-            // check if this \"compression bias\" is being used anywhere? \n-            // doesn't seem to be!\n-            // -- 4.0 alpha\n-            if ( compressionBias == 100d){\n-                // 100 is expected\n-                dbgLog.fine(\"compressionBias is 100 as expected\");\n-                ///smd.getFileInformation().put(\"compressionBias\", 100);\n-            } else {\n-                dbgLog.fine(\"compression bias is not 100: \"+ compressionBias);\n-                ///smd.getFileInformation().put(\"compressionBias\", compressionBias);\n-            }\n-            \n-            \n-            // 1.8 84-byte File Creation Information (date/time: dd MM yyhh:mm:ss +\n-            // 64-bytelabel)\n-            \n-            offset_start    = offset_end;\n-            offset_end += LENGTH_FILE_CREATION_INFO; // 84 bytes\n-            \n-            String fileCreationInfo = getNullStrippedString(new String(Arrays.copyOfRange(recordType1, offset_start,\n-                offset_end),\"US-ASCII\"));\n-                \n-            dbgLog.fine(\"fileCreationInfo:\\n\"+fileCreationInfo+\"\\n\");\n-            \n-            String fileCreationDate = fileCreationInfo.substring(0,length_file_creation_date);\n-            int dateEnd = length_file_creation_date+length_file_creation_time;\n-            String fileCreationTime = fileCreationInfo.substring(length_file_creation_date,\n-                    (dateEnd));\n-            String fileCreationNote = fileCreationInfo.substring(dateEnd,length_file_creation_label);\n-\n-\n-            dbgLog.fine(\"fileDate=\"+ fileCreationDate);\n-            dbgLog.fine(\"fileTime=\"+ fileCreationTime);\n-            dbgLog.fine(\"fileNote\"+ fileCreationNote);\n-            \n-            \n-        } catch (IOException ex) {\n-\t    throw ex; \n-        }\n-        \n-        dbgLog.fine(\"decodeRecordType1(): end\");\n-    }\n-    \n-    \n-    void decodeRecordType2(BufferedInputStream stream) throws IOException {\n-        dbgLog.fine(\"decodeRecordType2(): start\");\n-        if (stream ==null){\n-            throw new IllegalArgumentException(\"stream == null!\");\n-        }\n+  List<String> variableNameList = new ArrayList<String>();\n \n-        Map<String, String> printFormatNameTable = new LinkedHashMap<String, String>(); \n-        Map<String, String> variableLabelMap = new LinkedHashMap<String, String>();\n-        Map<String, List<String>> missingValueTable = new LinkedHashMap<String, List<String>>();\n-        List<Integer> printFormatList = new ArrayList<Integer>();\n \n-        String caseWeightVariableName = null;\n-        int caseWeightVariableIndex = 0;\n+  Map<String, InvalidData> invalidDataTable = new LinkedHashMap<String, InvalidData>();\n+    // this variable used in 2 methods; only one uses it to set the smd value -- ??\n \n+  NumberFormat doubleNumberFormatter = new DecimalFormat();\n \n-        boolean lastVariableIsExtendable = false;\n-        boolean extendedVariableMode = false;\n-        boolean obs255 = false;\n+  Set<Integer> decimalVariableSet = new HashSet<Integer>();\n \n-        String lastVariableName = null;\n-        String lastExtendedVariable = null;\n+  String[] variableFormatTypeList = null;\n \n+  List<Integer> formatDecimalPointPositionList = new ArrayList<Integer>();\n \n-        // this field repeats as many as the number of variables in\n-        // this sav file\n \n-        // (note that the above statement is not technically correct, this\n-        //  record repeats not just for every variable in the file, but for\n-        //  every OBS (8 byte unit); i.e., if a string is split into multiple\n-        //  OBS units, each one will have its own RT2 record -- L.A.).\n+  int caseWeightVariableOBSIndex = 0;\n \n-        // Each field constists of a fixed (32-byte) segment and\n-        // then a few variable segments:\n-        // if the variable has a label (3rd INT4 set to 1), then there's 4 more\n-        // bytes specifying the length of the label, and then that many bytes\n-        // holding the label itself (no more than 256).\n-        // Then if there are optional missing value units (4th INT4 set to 1)\n-        // there will be 3 more OBS units attached = 24 extra bytes.\n \n-        int variableCounter = 0;\n-        int obsSeqNumber = 0;\n+  // date/time data formats\n \n-        int j;\n+  private SimpleDateFormat sdf_ymd = new SimpleDateFormat(\"yyyy-MM-dd\");\n+  private SimpleDateFormat sdf_ymdhms = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n+  private SimpleDateFormat sdf_dhms = new SimpleDateFormat(\"DDD HH:mm:ss\");\n+  private SimpleDateFormat sdf_hms = new SimpleDateFormat(\"HH:mm:ss\");\n \n-        dbgLog.fine(\"RT2: Reading \"+OBSUnitsPerCase+\" OBS units.\");\n \n-        for (j=0; j<OBSUnitsPerCase; j++){\n+  Map<String, String> OBSTypeHexValue = new LinkedHashMap<String, String>();\n \n-            dbgLog.fine(\"RT2: \"+j+\"-th RT2 unit is being decoded.\");\n-            // 2.0: read the fixed[=non-optional] 32-byte segment\n-            byte[] recordType2Fixed = new byte[LENGTH_RECORDTYPE2_FIXED];\n+  /*\n+   * TODO: add a comment explaining the whole thing about this default\n+   * character set. -- L.A. 4.0 beta\n+   */\n+  private String defaultCharSet = \"ISO-8859-1\";\n+  //private String defaultCharSet = \"US-ASCII\"; // -- temporary! -- 4.0 beta 6\n+  private int spssVersionNumber = 0;\n \n-            try {\n-                int nbytes = stream.read(recordType2Fixed, 0, LENGTH_RECORDTYPE2_FIXED);\n \n+  /**\n+   * The <code>String</code> that represents the numeric missing value\n+   * in the final tab-delimited data file.\n+   */\n+  private String MissingValueForTextDataFileNumeric = \"\";\n \n-                //printHexDump(recordType2Fixed, \"recordType2 part 1\");\n \n-                if (nbytes == 0){\n-                    throw new IOException(\"reading recordType2: no bytes read!\");\n-                }\n+  public String getMissingValueForTextDataFileNumeric() {\n+    return MissingValueForTextDataFileNumeric;\n+  }\n \n-                int offset = 0;\n \n-                // 2.1: create int-view of the bytebuffer for the first 16-byte segment\n-                int rt2_1st_4_units = 4;\n-                ByteBuffer[] bb_record_type2_fixed_part1 = new ByteBuffer[rt2_1st_4_units];\n-                int[] recordType2FixedPart1 = new int[rt2_1st_4_units];\n-                for (int i= 0; i < rt2_1st_4_units;i++ ){\n+  public void setMissingValueForTextDataFileNumeric(String MissingValueToken) {\n+    this.MissingValueForTextDataFileNumeric = MissingValueToken;\n+  }\n \n-                    bb_record_type2_fixed_part1[i] =\n-                    ByteBuffer.wrap(recordType2Fixed, offset, LENGTH_SAV_INT_BLOCK);\n \n-                    offset +=LENGTH_SAV_INT_BLOCK;\n-                    if (isLittleEndian){\n-                        bb_record_type2_fixed_part1[i].order(ByteOrder.LITTLE_ENDIAN);\n-                    }\n-                    recordType2FixedPart1[i] = bb_record_type2_fixed_part1[i].getInt();\n-                }\n+  String MissingValueForTextDataFileString = \"\";\n \n \n-                ///dbgLog.fine(\"recordType2FixedPart=\"+\n-                ///        ReflectionToStringBuilder.toString(recordType2FixedPart1, ToStringStyle.MULTI_LINE_STYLE));\n+  public String getMissingValueForTextDataFileString() {\n+    return MissingValueForTextDataFileString;\n+  }\n \n \n-                // 1st ([0]) element must be 2 otherwise no longer Record Type 2\n-                if (recordType2FixedPart1[0] != 2){\n-                    dbgLog.warning(j+\"-th RT header value is no longet RT2! \"+recordType2FixedPart1[0]);\n-                    break;\n-                }\n-                dbgLog.fine(\"variable type[must be 2]=\"+recordType2FixedPart1[0]);\n+  public void setMissingValueForTextDataFileString(String MissingValueToken) {\n+    this.MissingValueForTextDataFileString = MissingValueToken;\n+  }\n \n \n-                // 2.3 variable name: 8 byte(space[x20]-padded)\n-                // This field is located at the very end of the 32 byte\n-                // fixed-size RT2 header (bytes 24-31).\n-                // We are processing it now, so that\n-                // we can make the decision on whether this variable is part\n-                // of a compound variable:\n+  public SAVFileReader(TabularDataFileReaderSpi originator) {\n+    super(originator);\n+  }\n \n-                String RawVariableName = getNullStrippedString(new String(Arrays.copyOfRange(recordType2Fixed, 24, (24+LENGTH_VARIABLE_NAME)),defaultCharSet));\n-                //offset +=LENGTH_VARIABLE_NAME;\n-                String variableName = null;\n-                if (RawVariableName.indexOf(' ') >= 0){\n-                    variableName = RawVariableName.substring(0, RawVariableName.indexOf(' '));\n-                } else {\n-                    variableName = RawVariableName;\n-                }\n+  // Methods ---------------------------------------------------------------//\n \n+  private void init() throws IOException {\n \n-                // 2nd ([1]) element: numeric variable = 0 :for string variable\n-                // this block indicates its datum-length, i.e, >0 ;\n-                // if -1, this RT2 unit is a non-1st RT2 unit for a string variable\n-                // whose value is longer than 8 character.\n+    sdf_ymd.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n+    sdf_ymdhms.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n+    sdf_dhms.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n+    sdf_hms.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n \n-                boolean isNumericVariable = false;\n+    doubleNumberFormatter.setGroupingUsed(false);\n+    doubleNumberFormatter.setMaximumFractionDigits(340);\n \n-                dbgLog.fine(\"variable type(0: numeric; > 0: String;-1 continue )=\"+recordType2FixedPart1[1]);\n+    if (getDataLanguageEncoding() != null) {\n+      defaultCharSet = getDataLanguageEncoding();\n+    }\n+  }\n \n-                //OBSwiseTypelList.add(recordType2FixedPart1[1]);\n+  public TabularDataIngest read(BufferedInputStream stream, File dataFile) throws IOException {\n+    dbgLog.info(\"SAVFileReader: read() start\");\n \n-                int HowManyRt2Units=1;\n+    if (dataFile != null) {\n+      throw new IOException(\"this plugin does not support external raw data files\");\n+    }\n \n+    /*\n+     * this \"try\" block is for catching unknown/unexpected exceptions\n+     * thrown anywhere in the ingest code:\n+     */\n+    try {\n+      /* ingest happens here ... */\n+\n+      // the following methods are now executed, in this order:\n+\n+      // decodeHeader -- this method doesn't read any [meta]data and\n+      //    doesn't initialize any values; its only purpose is to\n+      //    make sure that the file is indeed an SPSS/SAV file.\n+      //\n+      // decodeRecordType1 -- there's always one RT1 record; it is\n+      //    always 176 byte long. it contains the very basic metadata\n+      //    about the data file. most notably, the number of observations\n+      //    and the number of OBS (8 byte values) per observation.\n+      //\n+      // decodeRecordType2 -- there are multiple RT2 records. there's\n+      //    one RT2 for every OBS (8 byte value); i.e. one per variable,\n+      //    or more per every String variable split into multiple OBS\n+      //    segments. this one is a 400 line method, that may benefit\n+      //    from being split into smaller methods.\n+      //\n+      // decodeRecordType3and4 -- these sections come in pairs, each\n+      //    pair dedicated to one set of variable labels.\n+      // decodeRecordType6,\n+      //\n+      // decodeRecordType7 -- this RT contains some extended\n+      //    metadata for the data file. (including the information\n+      //    about the extended variables, i.e. variables longer than\n+      //    255 bytes split into 255 byte fragments that are stored\n+      //    in the data file as independent variables).\n+      //\n+      // decodeRecordType999 -- this RT does not contain any data;\n+      //    its sole function is to indicate that the metadata portion\n+      //    of the data file is over and the data section follows.\n+      //\n+      // decodeRecordTypeData -- this method decodes the data section\n+      //    of the file. Inside this method, 2 distinct methods are\n+      //    called to process compressed or uncompressed data, depending\n+      //    on which method is used in this data file.\n+\n+\n+      String methodCurrentlyExecuted = null;\n+\n+      try {\n+        methodCurrentlyExecuted = \"decodeHeader\";\n+        dbgLog.fine(\"***** SAVFileReader: executing method decodeHeader\");\n+        decodeHeader(stream);\n+\n+        methodCurrentlyExecuted = \"decodeRecordType1\";\n+        dbgLog.fine(\"***** SAVFileReader: executing method decodeRecordType1\");\n+        decodeRecordType1(stream);\n+\n+        methodCurrentlyExecuted = \"decodeRecordType2\";\n+        dbgLog.fine(\"***** SAVFileReader: executing method decodeRecordType1\");\n+        decodeRecordType2(stream);\n+\n+        methodCurrentlyExecuted = \"decodeRecordType3and4\";\n+        dbgLog.fine(\"***** SAVFileReader: executing method decodeRecordType3and4\");\n+        decodeRecordType3and4(stream);\n+\n+        methodCurrentlyExecuted = \"decodeRecordType6\";\n+        dbgLog.fine(\"***** SAVFileReader: executing method decodeRecordType6\");\n+        decodeRecordType6(stream);\n+\n+        methodCurrentlyExecuted = \"decodeRecordType7\";\n+        dbgLog.fine(\"***** SAVFileReader: executing method decodeRecordType7\");\n+        decodeRecordType7(stream);\n+\n+        methodCurrentlyExecuted = \"decodeRecordType999\";\n+        dbgLog.fine(\"***** SAVFileReader: executing method decodeRecordType999\");\n+        decodeRecordType999(stream);\n+\n+        methodCurrentlyExecuted = \"decodeRecordTypeData\";\n+        dbgLog.fine(\"***** SAVFileReader: executing method decodeRecordTypeData\");\n+        decodeRecordTypeData(stream);\n+\n+\n+      } catch (IllegalArgumentException e) {\n+        //Throwable cause = e.getCause();\n+        dbgLog.fine(\n+          \"***** SAVFileReader: ATTENTION: IllegalArgumentException thrown while executing \" + methodCurrentlyExecuted);\n+        e.printStackTrace();\n+        throw new IOException(\"IllegalArgumentException in method \" + methodCurrentlyExecuted + \": \" + e.getMessage());\n+      } catch (IOException e) {\n+        dbgLog.fine(\"***** SAVFileReader: ATTENTION: IOException thrown while executing \" + methodCurrentlyExecuted);\n+        e.printStackTrace();\n+        throw new IOException(\"IO Exception in method \" + methodCurrentlyExecuted + \": \" + e.getMessage());\n+      }\n+\n+      /*\n+       * Final variable type assignments;\n+       * TODO: (maybe?)\n+       * Instead of doing it here, perhaps all the type assignments need to\n+       * be done on DataVariable objects directly;  without relying on\n+       * maps and lists here... -- L.A. 4.0 beta (?)\n+       */\n+\n+\n+      for (int indx = 0; indx < variableTypelList.size(); indx++) {\n+        String varName = dataTable.getDataVariables().get(indx).getName();\n+        int simpleType = 0;\n+        if (variableTypelList.get(indx) != null) {\n+          simpleType = variableTypelList.get(indx).intValue();\n+        }\n \n-                if (recordType2FixedPart1[1] == -1) {\n-                    dbgLog.fine(\"this RT2 is an 8 bit continuation chunk of an earlier string variable\");\n-                    if ( obs255 ) {\n-                        if ( obsSeqNumber < 30 ) {\n-                            OBSwiseTypelList.add(recordType2FixedPart1[1]);\n-                            obsSeqNumber++;\n-                        } else {\n-                            OBSwiseTypelList.add(-2);\n-                            obs255 = false;\n-                            obsSeqNumber = 0;\n-                        }\n-                    } else {\n-                        OBSwiseTypelList.add(recordType2FixedPart1[1]);\n-                    }\n+        if (simpleType <= 0) {\n+          // We need to make one last type adjustment:\n+          // Dates and Times will be stored as character values in the\n+          // dataverse tab files; even though they are not typed as\n+          // strings at this point:\n+          // TODO:\n+          // Make sure the date/time format is properly preserved!\n+          // (see the setFormatCategory below... but double-check!)\n+          // -- L.A. 4.0 alpha\n+          String variableFormatType = variableFormatTypeList[indx];\n+          if (variableFormatType != null) {\n+            if (variableFormatType.equals(\"time\")\n+              || variableFormatType.equals(\"date\")) {\n+              simpleType = 1;\n+\n+              String formatCategory = formatCategoryTable.get(varName);\n+\n+              if (formatCategory != null) {\n+                if (dateFormatList[indx] != null) {\n+                  dbgLog.fine(\"setting format category to \" + formatCategory);\n+                  dataTable.getDataVariables().get(indx).setFormatCategory(formatCategory);\n+                  dbgLog.fine(\"setting formatschemaname to \" + dateFormatList[indx]);\n+                  dataTable.getDataVariables().get(indx).setFormat(dateFormatList[indx]);\n+                }\n+              }\n+            } else if (variableFormatType.equals(\"other\")) {\n+              dbgLog.fine(\"Variable of format type \\\"other\\\"; type adjustment may be needed\");\n+              dbgLog\n+                .fine(\"SPSS print format: \" + printFormatTable.get(dataTable.getDataVariables().get(indx).getName()));\n+\n+              if (printFormatTable.get(dataTable.getDataVariables().get(indx).getName()).equals(\"WKDAY\")\n+                || printFormatTable.get(dataTable.getDataVariables().get(indx).getName()).equals(\"MONTH\")) {\n+                // week day or month;\n+                // These are not treated as time/date values (meaning, we\n+                // don't define time/date formats for them; there's likely\n+                // no valid ISO time/date format for just a month or a day\n+                // of week). However, the\n+                // values will be stored in the TAB files as strings,\n+                // and not as numerics - as they were stored in the\n+                // SAV file. So we need to adjust the type here.\n+                // -- L.A.\n+\n+                simpleType = 1;\n+              }\n+            }\n+          }\n+        }\n \n-                    obsNonVariableBlockSet.add(j);\n-                    continue;\n-                } else if (recordType2FixedPart1[1] == 0){\n-                    // This is a numeric variable\n-                    extendedVariableMode = false;\n-                    // And as such, it cannot be an extension of a\n-                    // previous, long string variable.\n-                    OBSwiseTypelList.add(recordType2FixedPart1[1]);\n-                    variableCounter++;\n-                    isNumericVariable = true;\n-                    variableTypelList.add(recordType2FixedPart1[1]);\n-                } else if (recordType2FixedPart1[1] > 0){\n-\n-                    // This looks like a regular string variable. However,\n-                    // it may still be a part of a compound variable\n-                    // (a String > 255 bytes that was split into 255 byte\n-                    // chunks, stored as individual String variables).\n-\n-                    if (recordType2FixedPart1[1] == 255){\n-                        obs255 = true;\n-                    }\n+        // OK, we can now assign the types:\n \n-                    if ( lastVariableIsExtendable ) {\n-                        String varNameBase = null;\n-                        if ( lastVariableName.length() > 5 ) {\n-                            varNameBase = lastVariableName.substring (0, 5);\n-                        } else {\n-                            varNameBase = lastVariableName;\n-                        }\n-\n-                        if ( extendedVariableMode ) {\n-                            if ( variableNameIsAnIncrement ( varNameBase, lastExtendedVariable, variableName ) ) {\n-                                OBSwiseTypelList.add(-1);\n-                                lastExtendedVariable = variableName;\n-                                // OK, we stay in the \"extended variable\" mode;\n-                                // but we can't move on to the next OBS (hence the commented out\n-                                // \"continue\" below:\n-                                //continue;\n-                                // see the next comment below for the explanation.\n-                                //\n-                                // Should we also set \"extendable\" flag to false at this point\n-                                // if it's shorter than 255 bytes, i.e. the last extended chunk?\n-                            } else {\n-                                extendedVariableMode = false;\n-                            }\n-                        } else {\n-                            if ( variableNameIsAnIncrement ( varNameBase, variableName ) ) {\n-                                OBSwiseTypelList.add(-1);\n-                                extendedVariableMode = true;\n-                                dbgLog.fine(\"RT2: in extended variable mode; variable \"+variableName);\n-                                lastExtendedVariable = variableName;\n-                                // Before we move on to the next OBS unit, we need to check\n-                                // if this current extended variable has its own label specified;\n-                                // If so, we need to determine its length, then read and skip\n-                                // that many bytes.\n-                                // Hence the commented out \"continue\" below:\n-                                //continue;\n-                            }\n-                        }\n-                    }\n+        if (simpleType > 0) {\n+          // String:\n+          dataTable.getDataVariables().get(indx).setTypeCharacter();\n+          dataTable.getDataVariables().get(indx).setIntervalDiscrete();\n+        } else {\n+          // Numeric:\n+          dataTable.getDataVariables().get(indx).setTypeNumeric();\n+          // discrete or continuous?\n+          // \"decimal variables\" become dataverse data variables of interval type \"continuous\":\n \n-                    if ( !extendedVariableMode) {\n-                        // OK, this is a \"real\"\n-                        // string variable, and not a continuation chunk of a compound\n-                        // string.\n-\n-                        OBSwiseTypelList.add(recordType2FixedPart1[1]);\n-                        variableCounter++;\n-\n-                        if (recordType2FixedPart1[1] == 255){\n-                            // This variable is 255 bytes long, i.e. this is\n-                            // either the single \"atomic\" variable of the\n-                            // max allowed size, or it's a 255 byte segment\n-                            // of a compound variable. So we will check\n-                            // the next variable and see if it is the continuation\n-                            // of this one.\n-\n-                            lastVariableIsExtendable = true;\n-                        } else {\n-                            lastVariableIsExtendable = false;\n-                        }\n-\n-                        if (recordType2FixedPart1[1] % LENGTH_SAV_OBS_BLOCK == 0){\n-                            HowManyRt2Units = recordType2FixedPart1[1] / LENGTH_SAV_OBS_BLOCK;\n-                        } else {\n-                            HowManyRt2Units = recordType2FixedPart1[1] / LENGTH_SAV_OBS_BLOCK +1;\n-                        }\n-                        variableTypelList.add(recordType2FixedPart1[1]);\n-                    }\n-                }\n+          if (decimalVariableSet.contains(indx)) {\n+            dataTable.getDataVariables().get(indx).setIntervalContinuous();\n+          } else {\n+            dataTable.getDataVariables().get(indx).setIntervalDiscrete();\n+          }\n \n-                if ( !extendedVariableMode ) {\n-                    // Again, we only want to do the following steps for the \"real\"\n-                    // variables, not the chunks of split mega-variables:\n+        }\n \n-                    dbgLog.fine(\"RT2: HowManyRt2Units for this variable=\"+HowManyRt2Units);\n+        // TODO: take care of the SPSS \"shortToLongVariableNameTable\"\n+        // mapping before returning the ingested data object. -- 4.0 alpha\n+        // (done, below - but verify!)\n \n-                    lastVariableName = variableName;\n+        if (shortToLongVariableNameTable.containsKey(varName)) {\n+          String longName = shortToLongVariableNameTable.get(varName);\n+          if (longName != null && !longName.equals(\"\")) {\n+            dataTable.getDataVariables().get(indx).setName(longName);\n+          }\n+        }\n \n-                    // caseWeightVariableOBSIndex starts from 1: 0 is used for does-not-exist cases\n-                    if (j == (caseWeightVariableOBSIndex - 1)){\n-                        caseWeightVariableName = variableName;\n-                        // TODO: do we need this \"index\"? -- 4.0 alpha\n-                        caseWeightVariableIndex = variableCounter;\n+      }\n+\n+      ingesteddata.setDataTable(dataTable);\n+    } catch (Exception ex) {\n+      dbgLog.fine(\"***** SAVFileReader: ATTENTION: unknown exception thrown.\");\n+      ex.printStackTrace();\n+      String failureMessage = \"Unknown exception in SPSS/SAV reader\";\n+      if (ex.getMessage() != null) {\n+        failureMessage = failureMessage.concat(\": \" + ex.getMessage());\n+      } else {\n+        failureMessage = failureMessage.concat(\"; no further information is available.\");\n+      }\n+      throw new IOException(failureMessage);\n+    }\n+    dbgLog.info(\"SAVFileReader: read() end\");\n+    return ingesteddata;\n+  }\n \n-                        ///smd.setCaseWeightVariableName(caseWeightVariableName);\n-                        ///smd.getFileInformation().put(\"caseWeightVariableIndex\", caseWeightVariableIndex);\n-                    }\n+  void decodeHeader(BufferedInputStream stream) throws IOException {\n+    dbgLog.fine(\"decodeHeader(): start\");\n \n-                    OBSIndexToVariableName.put(j, variableName);\n+    if (stream == null) {\n+      throw new IllegalArgumentException(\"stream == null!\");\n+    }\n+    // the length of the magic number is 4 (1-byte character * 4)\n+    // its value is expected to be $FL2\n \n-                    //dbgLog.fine(\"\\nvariable name=\"+variableName+\"<-\");\n-                    dbgLog.fine(\"RT2: \"+j+\"-th variable name=\"+variableName+\"<-\");\n-                    dbgLog.fine(\"RT2: raw variable: \"+RawVariableName);\n+    byte[] b = new byte[SAV_MAGIC_NUMBER_LENGTH];\n \n-                    variableNameList.add(variableName);\n-                }\n+    try {\n+      if (stream.markSupported()) {\n+        stream.mark(100);\n+      }\n+      int nbytes = stream.read(b, 0, SAV_MAGIC_NUMBER_LENGTH);\n \n+      if (nbytes == 0) {\n+        throw new IOException();\n+      }\n \n+    } catch (IOException ex) {\n+      //ex.printStackTrace();\n+      throw ex;\n+    }\n \n-                // 3rd ([2]) element: = 1 variable-label block follows; 0 = no label\n-                //\n-                dbgLog.fine(\"RT: variable label follows?(1:yes; 0: no)=\"+recordType2FixedPart1[2]);\n-                boolean hasVariableLabel = recordType2FixedPart1[2] == 1 ? true : false;\n-                if ((recordType2FixedPart1[2] != 0) && (recordType2FixedPart1[2] != 1)) {\n-                    throw new IOException(\"RT2: reading error: value is neither 0 or 1\"+\n-                            recordType2FixedPart1[2]);\n-                }\n+    //printHexDump(b, \"hex dump of the byte-array\");\n \n-                // 2.4 [optional]The length of a variable label followed: 4-byte int\n-                // 3rd element of 2.1 indicates whether this field exists\n-                // *** warning: The label block is padded to a multiple of the 4-byte\n-                // NOT the raw integer value of this 4-byte block\n+    String hdr4sav = new String(b);\n+    dbgLog.fine(\"from string=\" + hdr4sav);\n \n+    if (hdr4sav.equals(SAV_FILE_SIGNATURE)) {\n+      dbgLog.fine(\"this file is spss-sav type\");\n+      // initialize version-specific parameter\n+      init();\n \n-                if (hasVariableLabel){\n-                    byte[] length_variable_label= new byte[4];\n-                    int nbytes_2_4 = stream.read(length_variable_label);\n-                    if (nbytes_2_4 == 0){\n-                        throw new IOException(\"RT 2: error reading recordType2.4: no bytes read!\");\n-                    } else {\n-                        dbgLog.fine(\"nbytes_2_4=\"+nbytes_2_4);\n-                    }\n-                    ByteBuffer bb_length_variable_label = ByteBuffer.wrap(\n-                            length_variable_label, 0, LENGTH_VARIABLE_LABEL);\n-                    if (isLittleEndian){\n-                        bb_length_variable_label.order(ByteOrder.LITTLE_ENDIAN);\n-                    }\n-                    int rawVariableLabelLength = bb_length_variable_label.getInt();\n+      dataTable.setOriginalFileFormat(MIME_TYPE[0]);\n \n-                    dbgLog.fine(\"rawVariableLabelLength=\"+rawVariableLabelLength);\n-                    int variableLabelLength = getSAVintAdjustedBlockLength(rawVariableLabelLength);\n-                    dbgLog.fine(\"RT2: variableLabelLength=\"+variableLabelLength);\n+      dataTable.setUnf(\"UNF:6:\");\n \n-                    // 2.5 [optional]variable label whose length is found at 2.4\n \n-                    String variableLabel = \"\";\n+    } else {\n+      dbgLog.fine(\"this file is NOT spss-sav type\");\n \n-                    if (rawVariableLabelLength > 0) {\n-                    byte[] variable_label = new byte[variableLabelLength];\n-                    int nbytes_2_5 = stream.read(variable_label);\n-                    if (nbytes_2_5 == 0){\n-                            throw new IOException(\"RT 2: error reading recordType2.5: \"\n-                                    +variableLabelLength+\" bytes requested, no bytes read!\");\n-                    } else {\n-                        dbgLog.fine(\"nbytes_2_5=\"+nbytes_2_5);\n-                    }\n-                        variableLabel = getNullStrippedString(new String(Arrays.copyOfRange(variable_label,\n-                                0, rawVariableLabelLength),defaultCharSet));\n-                        dbgLog.fine(\"RT2: variableLabel=\"+variableLabel+\"<-\");\n+      throw new IllegalArgumentException(\"given file is not spss-sav type\");\n+    }\n \n-                        dbgLog.fine(variableName + \" => \" + variableLabel);\n-                    } else {\n-                        dbgLog.fine(\"RT2: defaulting to empty variable label.\");\n-                    }\n-                    \n-                    if (!extendedVariableMode) {\n-                    // We only have any use for this label if it's a \"real\" variable.\n-                    // Thinking about it, it doesn't make much sense for the \"fake\"\n-                    // variables that are actually chunks of large strings to store\n-                    // their own labels. But in some files they do. Then failing to read\n-                    // the bytes would result in getting out of sync with the RT record\n-                    // borders. So we always read the bytes, but only use them for\n-                    // the real variable entries.\n-                        /*String variableLabel = new String(Arrays.copyOfRange(variable_label,\n-                                0, rawVariableLabelLength),\"US-ASCII\");*/\n+    dbgLog.fine(\"***** decodeHeader(): end *****\");\n \n-                        variableLabelMap.put(variableName, variableLabel);\n-                    }\n-                }\n+  }\n \n-                if (extendedVariableMode) {\n-                // there's nothing else left for us to do in this iteration of the loop.\n-                // Once again, this was not a real variable, but a dummy variable entry\n-                // created for a chunk of a string variable longer than 255 bytes --\n-                // that's how SPSS stores them.\n-                    continue;\n-                }\n \n-                // 4th ([3]) element: Missing value type code\n-                // 0[none], 1, 2, 3 [point-type],-2[range], -3 [range type+ point]\n+  void decodeRecordType1(BufferedInputStream stream) throws IOException {\n+    dbgLog.fine(\"***** decodeRecordType1(): start *****\");\n \n-                dbgLog.fine(\"RT: missing value unit follows?(if 0, none)=\"+recordType2FixedPart1[3]);\n-                boolean hasMissingValues =\n-                        (validMissingValueCodeSet.contains(\n-                                recordType2FixedPart1[3]) && (recordType2FixedPart1[3] !=0)) ?\n-                        true : false;\n+    if (stream == null) {\n+      throw new IllegalArgumentException(\"stream == null!\");\n+    }\n+    // how to read each recordType\n+    // 1. set-up the following objects before reading bytes\n+    // a. the working byte array\n+    // b. the storage object\n+    // the length of this field: 172bytes = 60 + 4 + 12 + 4 + 8 + 84\n+    // this field consists of 6 distinct blocks\n+\n+    byte[] recordType1 = new byte[LENGTH_RECORDTYPE1];\n+    // int caseWeightVariableOBSIndex = 0;\n+\n+    try {\n+      int nbytes = stream.read(recordType1, 0, LENGTH_RECORDTYPE1);\n+\n+\n+      //printHexDump(recordType1, \"recordType1\");\n+\n+      if (nbytes == 0) {\n+        throw new IOException(\"reading recordType1: no byte was read\");\n+      }\n+\n+      // 1.1 60 byte-String that tells the platform/version of SPSS that\n+      // wrote this file\n+\n+      int offset_start = 0;\n+      int offset_end = LENGTH_SPSS_PRODUCT_INFO; // 60 bytes\n+\n+      String productInfo = new String(Arrays.copyOfRange(recordType1, offset_start,\n+        offset_end), \"US-ASCII\");\n+\n+      dbgLog.fine(\"productInfo:\\n\" + productInfo + \"\\n\");\n+      dataTable.setOriginalFormatVersion(productInfo);\n+\n+\n+      // try to parse out the SPSS version that created this data\n+      // file:\n+\n+      String spssVersionTag = null;\n+\n+      String regexpVersionNumber = \".*Release ([0-9]*)\";\n+      Pattern versionTagPattern = Pattern.compile(regexpVersionNumber);\n+      Matcher matcher = versionTagPattern.matcher(productInfo);\n+      if (matcher.find()) {\n+        spssVersionTag = matcher.group(1);\n+        dbgLog.fine(\"SPSS Version Number: \" + spssVersionTag);\n+      }\n+\n+      // TODO:\n+      // try a more elaborate regex (like the one for the \"new-style\"\n+      // productInfo line, below), to select the version number, the\n+      // minor version number and the platform (windows vs. mac) separately.\n+      // would be cleaner to save just that, rather than the entire\n+      // productInfo tag.\n+      // -- L.A. 4.0 beta\n+\n+      if (spssVersionTag == null || spssVersionTag.equals(\"\")) {\n+        // Later versions of SPSS have different formatting of the\n+        // productInfo line:\n+        regexpVersionNumber = \".* IBM SPSS STATISTICS.* ([^ ]*) ([0-9][0-9]*)([^ ]*)\";\n+        versionTagPattern = Pattern.compile(regexpVersionNumber);\n+        matcher = versionTagPattern.matcher(productInfo);\n+        if (matcher.find()) {\n+          String spssPlatformTag = matcher.group(1);\n+          spssVersionTag = matcher.group(2);\n+          String spssVersionTagMinor = matcher.group(3);\n+\n+          dbgLog.fine(\"SPSS Version Number (new style): \" + spssVersionTag);\n+          dbgLog.fine(\"SPSS Version/Platform Identification (new style:) \" +\n+            spssPlatformTag + \" \" + spssVersionTag + spssVersionTagMinor);\n+          dataTable.setOriginalFormatVersion(spssVersionTag +\n+            spssVersionTagMinor + \" \" +\n+            spssPlatformTag);\n \n-                InvalidData invalidDataInfo = null;\n+        }\n+      }\n+\n+      if (spssVersionTag != null && !spssVersionTag.equals(\"\")) {\n+        spssVersionNumber = Integer.valueOf(spssVersionTag).intValue();\n+\n+\n+        /*\n+         *  Starting with SPSS version 16, the default encoding is\n+         *  UTF-8.\n+         *  But we are only going to use it if the user did not explicitly\n+         *  specify the encoding on the addfiles page. Then we'd want\n+         *  to stick with whatever they entered.\n+         *  (also, it appears that (starting with the same version 16?)\n+         *  it is actually possible to define the locale/character set\n+         *  in the file - section 7, sub-type 20; TODO: decide which\n+         *  one takes precedence, if we have the encoding defined both\n+         *  in the file and through the UI. -- L.A. 4.0 beta)\n+         */\n+        if (spssVersionNumber > 15) {\n+          if (getDataLanguageEncoding() == null) {\n+            //defaultCharSet = \"windows-1252\"; // temporary! -- L.A. \"UTF-8\";\n+            defaultCharSet = \"UTF-8\";\n+          }\n+        }\n+      }\n \n-                if (recordType2FixedPart1[3] !=0){\n-                    invalidDataInfo = new InvalidData(recordType2FixedPart1[3]);\n-                    dbgLog.fine(\"RT: missing value type=\"+invalidDataInfo.getType());\n-                }\n+      // TODO:\n+      // decide if we want to save the [determined/guessed] character set\n+      // somewhere in the dataset object.\n+      // this may be relevant in cases when accented/non-latin characters\n+      // get ingested incorrectly;\n+      // -- L.A. 4.0 beta\n \n-                // 2.2: print/write formats: 4-byte each = 8 bytes\n+      // 1.2) 4-byte file-layout-code (byte-order)\n \n-                byte[] printFormt = Arrays.copyOfRange(recordType2Fixed, offset, offset+\n-                        LENGTH_PRINT_FORMAT_CODE);\n-                dbgLog.fine(\"printFrmt=\"+new String (Hex.encodeHex(printFormt)));\n+      offset_start = offset_end;\n+      offset_end += LENGTH_FILE_LAYOUT_CODE; // 4 byte\n \n+      ByteBuffer bb_fileLayout_code = ByteBuffer.wrap(\n+        recordType1, offset_start, LENGTH_FILE_LAYOUT_CODE);\n \n-                offset +=LENGTH_PRINT_FORMAT_CODE;\n-                int formatCode = isLittleEndian ? printFormt[2] : printFormt[1];\n-                int formatWidth = isLittleEndian ? printFormt[1] : printFormt[2];\n-                \n-                // TODO: \n-                // What should we be doing with these \"format decimal positions\" \n-                // in 4.0? \n-                // -- L.A. 4.0 alpha\n-                \n-                int formatDecimalPointPosition = isLittleEndian ? printFormt[0] : printFormt[3];\n-                dbgLog.fine(\"RT2: format code{5=F, 1=A[String]}=\"+formatCode);\n+      ByteBuffer byteOderTest = bb_fileLayout_code.duplicate();\n+      // interprete the 4 byte as int\n \n-                formatDecimalPointPositionList.add(formatDecimalPointPosition);\n+      int int2test = byteOderTest.getInt();\n \n+      if (int2test == 2 || int2test == 3) {\n+        dbgLog.fine(\"integer == \" + int2test + \": the byte-oder of the writer is the same \" +\n+          \"as the counterpart of Java: Big Endian\");\n+      } else {\n+        // Because Java's byte-order is always big endian,\n+        // this(!=2) means this sav file was  written on a little-endian machine\n+        // non-string, multi-bytes blocks must be byte-reversed\n \n-                if (!SPSSConstants.FORMAT_CODE_TABLE_SAV.containsKey(formatCode)){\n-                    throw new IOException(\"Unknown format code was found = \"\n-                            + formatCode);\n-                } else{\n-                    printFormatList.add(formatCode);\n-                }\n+        bb_fileLayout_code.order(ByteOrder.LITTLE_ENDIAN);\n \n-                byte[] writeFormt = Arrays.copyOfRange(recordType2Fixed, offset, offset+\n-                        LENGTH_WRITE_FORMAT_CODE);\n+        int2test = bb_fileLayout_code.getInt();\n \n-                dbgLog.fine(\"RT2: writeFrmt=\"+new String (Hex.encodeHex(writeFormt)));\n-                if (writeFormt[3] != 0x00){\n-                    dbgLog.fine(\"byte-order(write format): reversal required\");\n-                }\n+        if (int2test == 2 || int2test == 3) {\n+          dbgLog.fine(\"The sav file was saved on a little endian machine\");\n+          dbgLog.fine(\"Reveral of the bytes is necessary to decode \" +\n+            \"multi-byte, non-string blocks\");\n \n-                offset +=LENGTH_WRITE_FORMAT_CODE;\n+          isLittleEndian = true;\n \n-                if (!SPSSConstants.ORDINARY_FORMAT_CODE_SET.contains(formatCode)) {\n-                    StringBuilder sb = new StringBuilder(\n-                    SPSSConstants.FORMAT_CODE_TABLE_SAV.get(formatCode)+\n-                            formatWidth);\n-                    if (formatDecimalPointPosition > 0){\n-                        sb.append(\".\"+ formatDecimalPointPosition);\n-                    }\n-                    dbgLog.fine(\"formattable[i] = \" + variableName + \" -> \" + sb.toString());\n-                    printFormatNameTable.put(variableName, sb.toString());\n+        } else {\n+          throw new IOException(\"reading recordType1:unknown file layout code=\" + int2test);\n+        }\n+      }\n \n-                }\n+      dbgLog.fine(\"Endian of this platform:\" + ByteOrder.nativeOrder().toString());\n \n-                printFormatTable.put(variableName, SPSSConstants.FORMAT_CODE_TABLE_SAV.get(formatCode));\n+      // 1.3 4-byte Number_Of_OBS_Units_Per_Case\n+      // (= how many RT2 records => how many varilables)\n \n+      offset_start = offset_end;\n+      offset_end += LENGTH_NUMBER_OF_OBS_UNITS_PER_CASE; // 4 byte\n \n-                // 2.6 [optional] missing values:4-byte each if exists\n-                // 4th element of 2.1 indicates the structure of this sub-field\n+      ByteBuffer bb_OBS_units_per_case = ByteBuffer.wrap(\n+        recordType1, offset_start, LENGTH_NUMBER_OF_OBS_UNITS_PER_CASE);\n \n-                // Should we perhaps check for this for the \"fake\" variables too?\n-                //\n+      if (isLittleEndian) {\n+        bb_OBS_units_per_case.order(ByteOrder.LITTLE_ENDIAN);\n+      }\n \n-                if (hasMissingValues) {\n-                    dbgLog.fine(\"RT2: decoding missing value: type=\"+recordType2FixedPart1[3]);\n-                    int howManyMissingValueUnits = missingValueCodeUnits.get(recordType2FixedPart1[3]);\n-                    //int howManyMissingValueUnits = recordType2FixedPart1[3] > 0 ? recordType2FixedPart1[3] :  0;\n \n-                    dbgLog.fine(\"RT2: howManyMissingValueUnits=\"+howManyMissingValueUnits);\n+      OBSUnitsPerCase = bb_OBS_units_per_case.getInt();\n \n-                    byte[] missing_value_code_units = new byte[LENGTH_SAV_OBS_BLOCK*howManyMissingValueUnits];\n-                    int nbytes_2_6 = stream.read(missing_value_code_units);\n+      dbgLog.fine(\"RT1: OBSUnitsPerCase=\" + OBSUnitsPerCase);\n \n-                    if (nbytes_2_6 == 0){\n-                        throw new IOException(\"RT 2: reading recordType2.6: no byte was read\");\n-                    } else {\n-                        dbgLog.fine(\"nbytes_2_6=\"+nbytes_2_6);\n-                    }\n+      // 1.4 4-byte Compression_Switch\n \n-                    //printHexDump(missing_value_code_units, \"missing value\");\n+      offset_start = offset_end;\n+      offset_end += LENGTH_COMPRESSION_SWITCH; // 4 byte\n \n-                    if (isNumericVariable){\n+      ByteBuffer bb_compression_switch = ByteBuffer.wrap(recordType1,\n+        offset_start, LENGTH_COMPRESSION_SWITCH);\n \n-                        double[] missingValues = new double[howManyMissingValueUnits];\n-                        //List<String> mvp = new ArrayList<String>();\n-                        List<String> mv = new ArrayList<String>();\n+      if (isLittleEndian) {\n+        bb_compression_switch.order(ByteOrder.LITTLE_ENDIAN);\n+      }\n \n-                        ByteBuffer[] bb_missig_value_code =\n-                            new ByteBuffer[howManyMissingValueUnits];\n+      int compression_switch = bb_compression_switch.getInt();\n+      if (compression_switch == 0) {\n+        // data section is not compressed\n+        isDataSectionCompressed = false;\n+        dbgLog.fine(\"data section is not compressed\");\n+      } else {\n+        dbgLog.fine(\"data section is compressed:\" + compression_switch);\n+      }\n \n-                        int offset_start = 0;\n+      // 1.5 4-byte Case-Weight Variable Index\n+      // warning: this variable index starts from 1, not 0\n \n-                        for (int i= 0; i < howManyMissingValueUnits;i++ ){\n+      offset_start = offset_end;\n+      offset_end += LENGTH_CASE_WEIGHT_VARIABLE_INDEX; // 4 byte\n \n-                            bb_missig_value_code[i]  =\n-                                    ByteBuffer.wrap(missing_value_code_units, offset_start,\n-                                    LENGTH_SAV_OBS_BLOCK);\n+      ByteBuffer bb_Case_Weight_Variable_Index = ByteBuffer.wrap(recordType1,\n+        offset_start, LENGTH_CASE_WEIGHT_VARIABLE_INDEX);\n \n-                            offset_start +=LENGTH_SAV_OBS_BLOCK;\n-                            if (isLittleEndian){\n-                                bb_missig_value_code[i].order(ByteOrder.LITTLE_ENDIAN);\n-                            }\n+      if (isLittleEndian) {\n+        bb_Case_Weight_Variable_Index.order(ByteOrder.LITTLE_ENDIAN);\n+      }\n \n-                            ByteBuffer temp = bb_missig_value_code[i].duplicate();\n+      caseWeightVariableOBSIndex = bb_Case_Weight_Variable_Index.getInt();\n \n+      /// caseWeightVariableOBSIndex will be used later on to locate\n+      /// the weight variable; so we'll be able to mark the corresponding\n+      /// variables properly.\n+      // TODO: make sure case weight variables are properly handled!\n+      // -- L.A. 4.0 beta\n+      ///smd.getFileInformation().put(\"caseWeightVariableOBSIndex\", caseWeightVariableOBSIndex);\n \n-                            missingValues[i] = bb_missig_value_code[i].getDouble();\n-                            if (Double.toHexString(missingValues[i]).equals(\"-0x1.ffffffffffffep1023\")){\n-                                dbgLog.fine(\"1st value is LOWEST\");\n-                                mv.add(Double.toHexString(missingValues[i]));\n-                            } else if (Double.valueOf(missingValues[i]).equals(Double.MAX_VALUE)){\n-                                dbgLog.fine(\"2nd value is HIGHEST\");\n-                                mv.add(Double.toHexString(missingValues[i]));\n-                            } else {\n-                                mv.add(doubleNumberFormatter.format(missingValues[i]));\n-                            }\n-                            dbgLog.fine(i+\"-th missing value=\"+Double.toHexString(missingValues[i]));\n-                        }\n-\n-                        dbgLog.fine(\"variableName=\"+variableName);\n-                        if (recordType2FixedPart1[3] > 0) {\n-                            // point cases only\n-                            dbgLog.fine(\"mv(>0)=\"+mv);\n-                            missingValueTable.put(variableName, mv);\n-                            invalidDataInfo.setInvalidValues(mv);\n-                        } else if (recordType2FixedPart1[3]== -2) {\n-                            dbgLog.fine(\"mv(-2)=\"+mv);\n-                            // range\n-                            invalidDataInfo.setInvalidRange(mv);\n-                        } else if (recordType2FixedPart1[3]== -3){\n-                            // mixed case\n-                            dbgLog.fine(\"mv(-3)=\"+mv);\n-                            invalidDataInfo.setInvalidRange(mv.subList(0, 2));\n-                            invalidDataInfo.setInvalidValues(mv.subList(2, 3));\n-                            missingValueTable.put(variableName, mv.subList(2, 3));\n-                        }\n-\n-                        dbgLog.fine(\"missing value=\"+\n-                                StringUtils.join(missingValueTable.get(variableName),\"|\"));\n-                        dbgLog.fine(\"invalidDataInfo(Numeric):\\n\"+invalidDataInfo);\n-                        invalidDataTable.put(variableName, invalidDataInfo);\n-                    } else {\n-                        // string variable case\n-                        String[] missingValues = new String[howManyMissingValueUnits];\n-                        List<String> mv = new ArrayList<String>();\n-                        int offset_start = 0;\n-                        int offset_end   = LENGTH_SAV_OBS_BLOCK;\n-                        for (int i= 0; i < howManyMissingValueUnits;i++ ){\n-\n-                            missingValues[i] =\n-                                    StringUtils.stripEnd(new\n-                            String(Arrays.copyOfRange(missing_value_code_units, offset_start, offset_end),defaultCharSet), \" \");\n-                            dbgLog.fine(\"missing value=\"+missingValues[i]+\"<-\");\n-\n-                            offset_start = offset_end;\n-                            offset_end +=LENGTH_SAV_OBS_BLOCK;\n-\n-                            mv.add(missingValues[i]);\n-                        }\n-                        invalidDataInfo.setInvalidValues(mv);\n-                        missingValueTable.put(variableName, mv);\n-                        invalidDataTable.put(variableName, invalidDataInfo);\n-                        dbgLog.fine(\"missing value(str)=\"+\n-                                StringUtils.join(missingValueTable.get(variableName),\"|\"));\n-                        dbgLog.fine(\"invalidDataInfo(String):\\n\"+invalidDataInfo);\n-\n-                    } // string case\n-                    dbgLog.fine(\"invalidDataTable:\\n\"+invalidDataTable);\n-                } // if msv\n-\n-            } catch (IOException ex){\n-                //ex.printStackTrace();\n-                throw ex;\n-            } catch (Exception ex){\n-                ex.printStackTrace();\n-                // should we be throwing some exception here?\n-            }\n-        } // j-loop\n+      // 1.6 4-byte Number of Cases\n \n-        if (j != OBSUnitsPerCase ) {\n-            dbgLog.fine(\"RT2: attention! didn't reach the end of the OBS list!\");\n-            throw new IOException(\"RT2: didn't reach the end of the OBS list!\");\n-        }\n-        \n-        dbgLog.fine(\"RT2 metadata-related exit-chores\");\n-        ///smd.getFileInformation().put(\"varQnty\", variableCounter);\n-        dataTable.setVarQuantity(new Long(variableCounter));\n-        dbgLog.fine(\"RT2: varQnty=\" + variableCounter);\n-\n-        // 4.0 Initialize variables: \n-        List<DataVariable> variableList = new ArrayList<DataVariable>();\n-\n-        for (int i = 0; i < variableCounter; i++) {\n-            DataVariable dv = new DataVariable(i, dataTable);\n-            String varName = variableNameList.get(i);\n-            dbgLog.fine(\"name: \"+varName);\n-            dv.setName(varName);\n-            String varLabel = variableLabelMap.get(varName);\n-            if (varLabel != null && varLabel.length() > 255) {\n-                // TODO: \n-                // variable labels will be changed into type 'TEXT' in the \n-                // database - this will eliminate the 255 char. limit. \n-                // -- L.A. 4.0 beta11\n-                dbgLog.fine(\"Have to truncate label: \"+varLabel);\n-                varLabel = varLabel.substring(0, 255);\n-            }\n-            dbgLog.fine(\"label: \"+varLabel);\n-            dv.setLabel(varLabel);\n-            variableList.add(dv);\n+      offset_start = offset_end;\n+      offset_end += LENGTH_NUMBER_OF_CASES; // 4 byte\n \n-        }\n+      ByteBuffer bb_Number_Of_Cases = ByteBuffer.wrap(recordType1,\n+        offset_start, LENGTH_NUMBER_OF_CASES);\n \n-        dataTable.setDataVariables(variableList);\n+      if (isLittleEndian) {\n+        bb_Number_Of_Cases.order(ByteOrder.LITTLE_ENDIAN);\n+      }\n \n-        ///smd.setVariableName(variableNameList.toArray(new String[variableNameList.size()]));\n-        ///smd.setVariableLabel(variableLabelMap);\n-        // TODO: \n-        // figure out what to do with the missing value table!\n-        // -- 4.0 alpha\n-        // well, they were used to generate merged summary statistics for \n-        // the variable. So need to verify what the DDI import was doing \n-        // with them and replicate the same in 4.0.\n-        // (add appropriate value labels?)\n-        ///TODO: 4.0 smd.setMissingValueTable(missingValueTable);\n-        ///smd.getFileInformation().put(\"caseWeightVariableName\", caseWeightVariableName);\n+      int numberOfCases = bb_Number_Of_Cases.getInt();\n \n-        dbgLog.fine(\"sumstat:long case=\" + Arrays.deepToString(variableTypelList.toArray()));\n+      if (numberOfCases < 0) {\n+        // -1 if numberOfCases is unknown\n+        throw new RuntimeException(\"number of cases is not recorded in the header\");\n+      } else {\n+        dbgLog.fine(\"RT1: number of cases is recorded= \" + numberOfCases);\n+        dataTable.setCaseQuantity(new Long(numberOfCases));\n+        ///caseQnty = numberOfCases;\n+        ///smd.getFileInformation().put(\"caseQnty\", numberOfCases);\n+      }\n \n-        dbgLog.fine(\"RT2: OBSwiseTypelList=\" + OBSwiseTypelList);\n+      // 1.7 8-byte compression-bias [not long but double]\n \n-        dbgLog.fine(\"decodeRecordType2(): end\");\n-    }\n-    \n-    void decodeRecordType3and4(BufferedInputStream stream) throws IOException {\n-        dbgLog.fine(\"decodeRecordType3and4(): start\");\n-        Map<String, Map<String, String>> valueLabelTable\n-                = new LinkedHashMap<String, Map<String, String>>();\n-\n-        int safteyCounter = 0;\n-        while (true) {\n-            try {\n-                if (stream == null) {\n-                    throw new IllegalArgumentException(\"stream == null!\");\n-                }\n-\t\t// this secton may not exit so first check the 4-byte header value\n-                //if (stream.markSupported()){\n-                stream.mark(1000);\n-\t\t//}\n-                // 3.0 check the first 4 bytes\n-                byte[] headerCode = new byte[LENGTH_RECORD_TYPE3_CODE];\n-\n-                int nbytes_rt3 = stream.read(headerCode, 0, LENGTH_RECORD_TYPE3_CODE);\n-\t\t// to-do check against nbytes\n-                //printHexDump(headerCode, \"RT3 header test\");\n-                ByteBuffer bb_header_code = ByteBuffer.wrap(headerCode,\n-                        0, LENGTH_RECORD_TYPE3_CODE);\n-                if (isLittleEndian) {\n-                    bb_header_code.order(ByteOrder.LITTLE_ENDIAN);\n-                }\n+      offset_start = offset_end;\n+      offset_end += LENGTH_COMPRESSION_BIAS; // 8 byte\n \n-                int intRT3test = bb_header_code.getInt();\n-                dbgLog.fine(\"header test value: RT3=\" + intRT3test);\n-                if (intRT3test != 3) {\n-                    //if (stream.markSupported()){\n-                    dbgLog.fine(\"iteration=\" + safteyCounter);\n-\n-                    // We have encountered a record that's not type 3. This means we've\n-                    // processed all the type 3/4 record pairs. So we want to rewind\n-                    // the stream and return -- so that the appropriate record type\n-                    // reader can be called on it.\n-                    // But before we return, we need to save all the value labels\n-                    // we have found:\n-                    //smd.setValueLabelTable(valueLabelTable);\n-                    assignValueLabels(valueLabelTable);\n-\n-                    stream.reset();\n-                    return;\n-                    //}\n-                }\n-                // 3.1 how many value-label pairs follow\n-                byte[] number_of_labels = new byte[LENGTH_RT3_HOW_MANY_LABELS];\n+      ByteBuffer bb_compression_bias = ByteBuffer.wrap(\n+        Arrays.copyOfRange(recordType1, offset_start,\n+          offset_end));\n \n-                int nbytes_3_1 = stream.read(number_of_labels);\n-                if (nbytes_3_1 == 0) {\n-                    throw new IOException(\"RT 3: reading recordType3.1: no byte was read\");\n-                }\n-                ByteBuffer bb_number_of_labels = ByteBuffer.wrap(number_of_labels,\n-                        0, LENGTH_RT3_HOW_MANY_LABELS);\n-                if (isLittleEndian) {\n-                    bb_number_of_labels.order(ByteOrder.LITTLE_ENDIAN);\n-                }\n+      if (isLittleEndian) {\n+        bb_compression_bias.order(ByteOrder.LITTLE_ENDIAN);\n+      }\n \n-                int numberOfValueLabels = bb_number_of_labels.getInt();\n-                dbgLog.fine(\"number of value-label pairs=\" + numberOfValueLabels);\n+      Double compressionBias = bb_compression_bias.getDouble();\n \n-                ByteBuffer[] tempBB = new ByteBuffer[numberOfValueLabels];\n+      // TODO:\n+      // check if this \"compression bias\" is being used anywhere?\n+      // doesn't seem to be!\n+      // -- 4.0 alpha\n+      if (compressionBias == 100d) {\n+        // 100 is expected\n+        dbgLog.fine(\"compressionBias is 100 as expected\");\n+        ///smd.getFileInformation().put(\"compressionBias\", 100);\n+      } else {\n+        dbgLog.fine(\"compression bias is not 100: \" + compressionBias);\n+        ///smd.getFileInformation().put(\"compressionBias\", compressionBias);\n+      }\n \n-                String valueLabel[] = new String[numberOfValueLabels];\n \n-                for (int i = 0; i < numberOfValueLabels; i++) {\n+      // 1.8 84-byte File Creation Information (date/time: dd MM yyhh:mm:ss +\n+      // 64-bytelabel)\n \n-                    // read 8-byte as value\t\t    \n-                    byte[] value = new byte[LENGTH_RT3_VALUE];\n-                    int nbytes_3_value = stream.read(value);\n+      offset_start = offset_end;\n+      offset_end += LENGTH_FILE_CREATION_INFO; // 84 bytes\n \n-                    if (nbytes_3_value == 0) {\n-                        throw new IOException(\"RT 3: reading recordType3 value: no byte was read\");\n-                    }\n-\t\t    // note these 8 bytes are interpreted later\n-                    // currently no information about which variable's (=> type unknown)\n-                    ByteBuffer bb_value = ByteBuffer.wrap(value,\n-                            0, LENGTH_RT3_VALUE);\n-                    if (isLittleEndian) {\n-                        bb_value.order(ByteOrder.LITTLE_ENDIAN);\n-                    }\n-                    tempBB[i] = bb_value;\n-                    dbgLog.fine(\"bb_value=\" + Hex.encodeHex(bb_value.array()));\n-                    /*\n-                     double valueD = bb_value.getDouble();                \n-                     dbgLog.fine(\"value=\"+valueD);\n-                     */\n-\t\t    // read 1st byte as unsigned integer = label_length\n+      String fileCreationInfo = getNullStrippedString(new String(Arrays.copyOfRange(recordType1, offset_start,\n+        offset_end), \"US-ASCII\"));\n \n-                    // read label_length byte as label\n-                    byte[] labelLengthByte = new byte[LENGTH_RT3_LABEL_LENGTH];\n+      dbgLog.fine(\"fileCreationInfo:\\n\" + fileCreationInfo + \"\\n\");\n \n-                    int nbytes_3_label_length = stream.read(labelLengthByte);\n+      String fileCreationDate = fileCreationInfo.substring(0, length_file_creation_date);\n+      int dateEnd = length_file_creation_date + length_file_creation_time;\n+      String fileCreationTime = fileCreationInfo.substring(length_file_creation_date,\n+        (dateEnd));\n+      String fileCreationNote = fileCreationInfo.substring(dateEnd, length_file_creation_label);\n \n-\t\t    // add check-routine here\n-                    dbgLog.fine(\"labelLengthByte\" + Hex.encodeHex(labelLengthByte));\n-                    dbgLog.fine(\"label length = \" + labelLengthByte[0]);\n-\t\t    // the net-length of a value label is saved as\n-                    // unsigned byte; however, the length is less than 127\n-                    // byte should be ok\n-                    int rawLabelLength = labelLengthByte[0] & 0xFF;\n-                    dbgLog.fine(\"rawLabelLength=\" + rawLabelLength);\n-                    // -1 =>1-byte already read\n-                    int labelLength = getSAVobsAdjustedBlockLength(rawLabelLength + 1) - 1;\n-                    byte[] valueLabelBytes = new byte[labelLength];\n-                    int nbytes_3_value_label = stream.read(valueLabelBytes);\n \n-\t\t    // ByteBuffer bb_label = ByteBuffer.wrap(valueLabel,0,labelLength);\n-                    valueLabel[i] = StringUtils.stripEnd(new String(Arrays.copyOfRange(valueLabelBytes, 0, rawLabelLength), defaultCharSet), \" \");\n-                    dbgLog.fine(i + \"-th valueLabel=\" + valueLabel[i] + \"<-\");\n+      dbgLog.fine(\"fileDate=\" + fileCreationDate);\n+      dbgLog.fine(\"fileTime=\" + fileCreationTime);\n+      dbgLog.fine(\"fileNote\" + fileCreationNote);\n \n-                } // iter rt3\n \n-                dbgLog.fine(\"end of RT3 block\");\n-                dbgLog.fine(\"start of RT4 block\");\n+    } catch (IOException ex) {\n+      throw ex;\n+    }\n \n-                // 4.0 check the first 4 bytes\n-                byte[] headerCode4 = new byte[LENGTH_RECORD_TYPE4_CODE];\n+    dbgLog.fine(\"decodeRecordType1(): end\");\n+  }\n \n-                int nbytes_rt4 = stream.read(headerCode4, 0, LENGTH_RECORD_TYPE4_CODE);\n \n-                if (nbytes_rt4 == 0) {\n-                    throw new IOException(\"RT4: reading recordType4 value: no byte was read\");\n-                }\n+  void decodeRecordType2(BufferedInputStream stream) throws IOException {\n+    dbgLog.fine(\"decodeRecordType2(): start\");\n+    if (stream == null) {\n+      throw new IllegalArgumentException(\"stream == null!\");\n+    }\n \n-\t\t//printHexDump(headerCode4, \"RT4 header test\");\n-                ByteBuffer bb_header_code_4 = ByteBuffer.wrap(headerCode4,\n-                        0, LENGTH_RECORD_TYPE4_CODE);\n-                if (isLittleEndian) {\n-                    bb_header_code_4.order(ByteOrder.LITTLE_ENDIAN);\n-                }\n+    Map<String, String> printFormatNameTable = new LinkedHashMap<String, String>();\n+    Map<String, String> variableLabelMap = new LinkedHashMap<String, String>();\n+    Map<String, List<String>> missingValueTable = new LinkedHashMap<String, List<String>>();\n+    List<Integer> printFormatList = new ArrayList<Integer>();\n \n-                int intRT4test = bb_header_code_4.getInt();\n-                dbgLog.fine(\"header test value: RT4=\" + intRT4test);\n+    String caseWeightVariableName = null;\n+    int caseWeightVariableIndex = 0;\n \n-                if (intRT4test != 4) {\n-                    throw new IOException(\"RT 4: reading recordType4 header: no byte was read\");\n-                }\n \n-                // 4.1 read the how-many-variables bytes\n-                byte[] howManyVariablesfollow = new byte[LENGTH_RT4_HOW_MANY_VARIABLES];\n+    boolean lastVariableIsExtendable = false;\n+    boolean extendedVariableMode = false;\n+    boolean obs255 = false;\n \n-                int nbytes_rt4_1 = stream.read(howManyVariablesfollow, 0, LENGTH_RT4_HOW_MANY_VARIABLES);\n+    String lastVariableName = null;\n+    String lastExtendedVariable = null;\n \n-                ByteBuffer bb_howManyVariablesfollow = ByteBuffer.wrap(howManyVariablesfollow,\n-                        0, LENGTH_RT4_HOW_MANY_VARIABLES);\n-                if (isLittleEndian) {\n-                    bb_howManyVariablesfollow.order(ByteOrder.LITTLE_ENDIAN);\n-                }\n \n-                int howManyVariablesRT4 = bb_howManyVariablesfollow.getInt();\n-                dbgLog.fine(\"how many variables follow: RT4=\" + howManyVariablesRT4);\n+    // this field repeats as many as the number of variables in\n+    // this sav file\n \n-                int length_indicies = LENGTH_RT4_VARIABLE_INDEX * howManyVariablesRT4;\n-                byte[] variableIdicesBytes = new byte[length_indicies];\n+    // (note that the above statement is not technically correct, this\n+    //  record repeats not just for every variable in the file, but for\n+    //  every OBS (8 byte unit); i.e., if a string is split into multiple\n+    //  OBS units, each one will have its own RT2 record -- L.A.).\n \n-                int nbytes_rt4_2 = stream.read(variableIdicesBytes, 0, length_indicies);\n+    // Each field constists of a fixed (32-byte) segment and\n+    // then a few variable segments:\n+    // if the variable has a label (3rd INT4 set to 1), then there's 4 more\n+    // bytes specifying the length of the label, and then that many bytes\n+    // holding the label itself (no more than 256).\n+    // Then if there are optional missing value units (4th INT4 set to 1)\n+    // there will be 3 more OBS units attached = 24 extra bytes.\n \n-                // !!!!! Caution: variableIndex in RT4 starts from 1 NOT ** 0 **\n-                int[] variableIndex = new int[howManyVariablesRT4];\n-                int offset = 0;\n-                for (int i = 0; i < howManyVariablesRT4; i++) {\n+    int variableCounter = 0;\n+    int obsSeqNumber = 0;\n \n-                    ByteBuffer bb_variable_index = ByteBuffer.wrap(variableIdicesBytes,\n-                            offset, LENGTH_RT4_VARIABLE_INDEX);\n-                    offset += LENGTH_RT4_VARIABLE_INDEX;\n+    int j;\n \n-                    if (isLittleEndian) {\n-                        bb_variable_index.order(ByteOrder.LITTLE_ENDIAN);\n-                    }\n+    dbgLog.fine(\"RT2: Reading \" + OBSUnitsPerCase + \" OBS units.\");\n \n-                    variableIndex[i] = bb_variable_index.getInt();\n-                    dbgLog.fine(i + \"-th variable index number=\" + variableIndex[i]);\n-                }\n+    for (j = 0; j < OBSUnitsPerCase; j++) {\n \n-                dbgLog.fine(\"variable index set=\" + ArrayUtils.toString(variableIndex));\n-                dbgLog.fine(\"subtract 1 from variableIndex for getting a variable info\");\n+      dbgLog.fine(\"RT2: \" + j + \"-th RT2 unit is being decoded.\");\n+      // 2.0: read the fixed[=non-optional] 32-byte segment\n+      byte[] recordType2Fixed = new byte[LENGTH_RECORDTYPE2_FIXED];\n \n-                boolean isNumeric = OBSwiseTypelList.get(variableIndex[0] - 1) == 0 ? true : false;\n+      try {\n+        int nbytes = stream.read(recordType2Fixed, 0, LENGTH_RECORDTYPE2_FIXED);\n \n-                Map<String, String> valueLabelPair = new LinkedHashMap<String, String>();\n-                if (isNumeric) {\n-                    // numeric variable\n-                    dbgLog.fine(\"processing of a numeric value-label table\");\n-                    for (int j = 0; j < numberOfValueLabels; j++) {\n-                        valueLabelPair.put(doubleNumberFormatter.format(tempBB[j].getDouble()), valueLabel[j]);\n-                    }\n-                } else {\n-                    // String variable\n-                    dbgLog.fine(\"processing of a string value-label table\");\n-                    for (int j = 0; j < numberOfValueLabels; j++) {\n-                        valueLabelPair.put(\n-                                StringUtils.stripEnd(new String((tempBB[j].array()), defaultCharSet), \" \"), valueLabel[j]);\n-                    }\n-                }\n \n-                dbgLog.fine(\"valueLabePair=\" + valueLabelPair);\n-                dbgLog.fine(\"key variable's (raw) index =\" + variableIndex[0]);\n+        //printHexDump(recordType2Fixed, \"recordType2 part 1\");\n \n-                valueLabelTable.put(OBSIndexToVariableName.get(variableIndex[0] - 1), valueLabelPair);\n+        if (nbytes == 0) {\n+          throw new IOException(\"reading recordType2: no bytes read!\");\n+        }\n \n-                dbgLog.fine(\"valueLabelTable=\" + valueLabelTable);\n+        int offset = 0;\n \n-                // create a mapping table that finds the key variable for this mapping table\n-                String keyVariableName = OBSIndexToVariableName.get(variableIndex[0] - 1);\n-                for (int vn : variableIndex) {\n-                    valueVariableMappingTable.put(OBSIndexToVariableName.get(vn - 1), keyVariableName);\n-                }\n+        // 2.1: create int-view of the bytebuffer for the first 16-byte segment\n+        int rt2_1st_4_units = 4;\n+        ByteBuffer[] bb_record_type2_fixed_part1 = new ByteBuffer[rt2_1st_4_units];\n+        int[] recordType2FixedPart1 = new int[rt2_1st_4_units];\n+        for (int i = 0; i < rt2_1st_4_units; i++) {\n \n-                dbgLog.fine(\"valueVariableMappingTable:\\n\" + valueVariableMappingTable);\n-            } catch (IOException ex) {\n-                //ex.printStackTrace();\n-                throw ex;\n-            }\n+          bb_record_type2_fixed_part1[i] =\n+            ByteBuffer.wrap(recordType2Fixed, offset, LENGTH_SAV_INT_BLOCK);\n \n-            safteyCounter++;\n-            if (safteyCounter >= 1000000) {\n-                break;\n-            }\n-        } //while\n+          offset += LENGTH_SAV_INT_BLOCK;\n+          if (isLittleEndian) {\n+            bb_record_type2_fixed_part1[i].order(ByteOrder.LITTLE_ENDIAN);\n+          }\n+          recordType2FixedPart1[i] = bb_record_type2_fixed_part1[i].getInt();\n+        }\n \n-        ///smd.setValueLabelTable(valueLabelTable);\n-        assignValueLabels(valueLabelTable);\n \n-        dbgLog.fine(\"***** decodeRecordType3and4(): end *****\");\n-    }\n-   \n-    void assignValueLabels(Map<String, Map<String, String>> valueLabelTable) {\n-        // Let's go through all the categorical value label mappings and \n-        // assign them to the correct variables: \n-        \n-        for (DataVariable dataVariable : dataTable.getDataVariables()) {\n-            String varName = dataVariable.getName();\n-            \n-            Map<String, String> valueLabelPairs = valueLabelTable.get(valueVariableMappingTable.get(varName));\n-            if (valueLabelPairs != null && !valueLabelPairs.isEmpty()) {\n-                for (String value : valueLabelPairs.keySet()) {\n-                    \n-                    VariableCategory cat = new VariableCategory();\n-                    cat.setValue(value);\n-                    cat.setLabel(valueLabelPairs.get(value));\n-\n-                    /* cross-link the variable and category to each other: */\n-                    cat.setDataVariable(dataVariable);\n-                    dataVariable.getCategories().add(cat);\n-                }\n-            }\n+        ///dbgLog.fine(\"recordType2FixedPart=\"+\n+        ///        ReflectionToStringBuilder.toString(recordType2FixedPart1, ToStringStyle.MULTI_LINE_STYLE));\n+\n+\n+        // 1st ([0]) element must be 2 otherwise no longer Record Type 2\n+        if (recordType2FixedPart1[0] != 2) {\n+          dbgLog.warning(j + \"-th RT header value is no longet RT2! \" + recordType2FixedPart1[0]);\n+          break;\n+        }\n+        dbgLog.fine(\"variable type[must be 2]=\" + recordType2FixedPart1[0]);\n+\n+\n+        // 2.3 variable name: 8 byte(space[x20]-padded)\n+        // This field is located at the very end of the 32 byte\n+        // fixed-size RT2 header (bytes 24-31).\n+        // We are processing it now, so that\n+        // we can make the decision on whether this variable is part\n+        // of a compound variable:\n+\n+        String RawVariableName = getNullStrippedString(\n+          new String(Arrays.copyOfRange(recordType2Fixed, 24, (24 + LENGTH_VARIABLE_NAME)), defaultCharSet));\n+        //offset +=LENGTH_VARIABLE_NAME;\n+        String variableName = null;\n+        if (RawVariableName.indexOf(' ') >= 0) {\n+          variableName = RawVariableName.substring(0, RawVariableName.indexOf(' '));\n+        } else {\n+          variableName = RawVariableName;\n         }\n-    }\n-    \n \n-    void decodeRecordType6(BufferedInputStream stream) throws IOException {\n-        dbgLog.fine(\"***** decodeRecordType6(): start *****\");\n-        try {\n-            if (stream ==null){\n-                throw new IllegalArgumentException(\"stream == null!\");\n-            }\n-            // this section is optional; so let's first check the 4-byte header \n-            // value and see what type it is. \n-            //if (stream.markSupported()){ // -- ? L.A. 4.0 alpha\n-            stream.mark(1000);\n-            //}\n-            // 6.0 check the first 4 bytes\n-            byte[] headerCodeRt6 = new byte[LENGTH_RECORD_TYPE6_CODE];\n-\n-            int nbytes_rt6 = stream.read(headerCodeRt6, 0, LENGTH_RECORD_TYPE6_CODE);\n-            // to-do check against nbytes\n-            //printHexDump(headerCodeRt6, \"RT6 header test\");\n-            ByteBuffer bb_header_code_rt6  = ByteBuffer.wrap(headerCodeRt6,\n-                       0, LENGTH_RECORD_TYPE6_CODE);\n-            if (isLittleEndian){\n-                bb_header_code_rt6.order(ByteOrder.LITTLE_ENDIAN);\n-            }\n \n-            int intRT6test = bb_header_code_rt6.getInt();\n-            dbgLog.fine(\"RT6: header test value=\"+intRT6test);\n-            if (intRT6test != 6){\n-            //if (stream.markSupported()){\n-                //out.print(\"iteration=\"+safteyCounter);\n-                //dbgLog.fine(\"iteration=\"+safteyCounter);\n-                dbgLog.fine(\"intRT6test failed=\"+intRT6test);\n-                \n-                stream.reset();\n-                return;\n-            //}\n+        // 2nd ([1]) element: numeric variable = 0 :for string variable\n+        // this block indicates its datum-length, i.e, >0 ;\n+        // if -1, this RT2 unit is a non-1st RT2 unit for a string variable\n+        // whose value is longer than 8 character.\n+\n+        boolean isNumericVariable = false;\n+\n+        dbgLog.fine(\"variable type(0: numeric; > 0: String;-1 continue )=\" + recordType2FixedPart1[1]);\n+\n+        //OBSwiseTypelList.add(recordType2FixedPart1[1]);\n+\n+        int HowManyRt2Units = 1;\n+\n+\n+        if (recordType2FixedPart1[1] == -1) {\n+          dbgLog.fine(\"this RT2 is an 8 bit continuation chunk of an earlier string variable\");\n+          if (obs255) {\n+            if (obsSeqNumber < 30) {\n+              OBSwiseTypelList.add(recordType2FixedPart1[1]);\n+              obsSeqNumber++;\n+            } else {\n+              OBSwiseTypelList.add(-2);\n+              obs255 = false;\n+              obsSeqNumber = 0;\n             }\n-            // 6.1 check 4-byte integer that tells how many lines follow\n-            \n-            byte[] length_how_many_line_bytes = new byte[LENGTH_RT6_HOW_MANY_LINES];\n-\n-            int nbytes_rt6_1 = stream.read(length_how_many_line_bytes, 0,\n-                LENGTH_RT6_HOW_MANY_LINES);\n-            // to-do check against nbytes\n-            \n-            //printHexDump(length_how_many_line_bytes, \"RT6 how_many_line_bytes\");\n-            ByteBuffer bb_how_many_lines = ByteBuffer.wrap(length_how_many_line_bytes,\n-                       0, LENGTH_RT6_HOW_MANY_LINES);\n-            if (isLittleEndian){\n-                bb_how_many_lines.order(ByteOrder.LITTLE_ENDIAN);\n+          } else {\n+            OBSwiseTypelList.add(recordType2FixedPart1[1]);\n+          }\n+\n+          obsNonVariableBlockSet.add(j);\n+          continue;\n+        } else if (recordType2FixedPart1[1] == 0) {\n+          // This is a numeric variable\n+          extendedVariableMode = false;\n+          // And as such, it cannot be an extension of a\n+          // previous, long string variable.\n+          OBSwiseTypelList.add(recordType2FixedPart1[1]);\n+          variableCounter++;\n+          isNumericVariable = true;\n+          variableTypelList.add(recordType2FixedPart1[1]);\n+        } else if (recordType2FixedPart1[1] > 0) {\n+\n+          // This looks like a regular string variable. However,\n+          // it may still be a part of a compound variable\n+          // (a String > 255 bytes that was split into 255 byte\n+          // chunks, stored as individual String variables).\n+\n+          if (recordType2FixedPart1[1] == 255) {\n+            obs255 = true;\n+          }\n+\n+          if (lastVariableIsExtendable) {\n+            String varNameBase = null;\n+            if (lastVariableName.length() > 5) {\n+              varNameBase = lastVariableName.substring(0, 5);\n+            } else {\n+              varNameBase = lastVariableName;\n             }\n \n-            int howManyLinesRt6 = bb_how_many_lines.getInt();\n-            dbgLog.fine(\"how Many lines follow=\"+howManyLinesRt6);\n-            \n-            // 6.2 read 80-char-long lines \n-            String[] documentRecord = new String[howManyLinesRt6];\n-            \n-            for (int i=0;i<howManyLinesRt6; i++){\n-                \n-                byte[] line = new byte[80];\n-                int nbytes_rt6_line = stream.read(line);\n-               \n-                documentRecord[i] = StringUtils.stripEnd(new\n-                    String(Arrays.copyOfRange(line,\n-                    0, LENGTH_RT6_DOCUMENT_LINE),defaultCharSet), \" \");\n-                    \n-                dbgLog.fine(i+\"-th line =\"+documentRecord[i]+\"<-\");\n+            if (extendedVariableMode) {\n+              if (variableNameIsAnIncrement(varNameBase, lastExtendedVariable, variableName)) {\n+                OBSwiseTypelList.add(-1);\n+                lastExtendedVariable = variableName;\n+                // OK, we stay in the \"extended variable\" mode;\n+                // but we can't move on to the next OBS (hence the commented out\n+                // \"continue\" below:\n+                //continue;\n+                // see the next comment below for the explanation.\n+                //\n+                // Should we also set \"extendable\" flag to false at this point\n+                // if it's shorter than 255 bytes, i.e. the last extended chunk?\n+              } else {\n+                extendedVariableMode = false;\n+              }\n+            } else {\n+              if (variableNameIsAnIncrement(varNameBase, variableName)) {\n+                OBSwiseTypelList.add(-1);\n+                extendedVariableMode = true;\n+                dbgLog.fine(\"RT2: in extended variable mode; variable \" + variableName);\n+                lastExtendedVariable = variableName;\n+                // Before we move on to the next OBS unit, we need to check\n+                // if this current extended variable has its own label specified;\n+                // If so, we need to determine its length, then read and skip\n+                // that many bytes.\n+                // Hence the commented out \"continue\" below:\n+                //continue;\n+              }\n             }\n-            dbgLog.fine(\"documentRecord:\\n\"+StringUtils.join(documentRecord, \"\\n\"));\n+          }\n+\n+          if (!extendedVariableMode) {\n+            // OK, this is a \"real\"\n+            // string variable, and not a continuation chunk of a compound\n+            // string.\n \n+            OBSwiseTypelList.add(recordType2FixedPart1[1]);\n+            variableCounter++;\n \n-        } catch (IOException ex){\n-            //ex.printStackTrace();\n-\t    throw ex; \n+            if (recordType2FixedPart1[1] == 255) {\n+              // This variable is 255 bytes long, i.e. this is\n+              // either the single \"atomic\" variable of the\n+              // max allowed size, or it's a 255 byte segment\n+              // of a compound variable. So we will check\n+              // the next variable and see if it is the continuation\n+              // of this one.\n+\n+              lastVariableIsExtendable = true;\n+            } else {\n+              lastVariableIsExtendable = false;\n+            }\n+\n+            if (recordType2FixedPart1[1] % LENGTH_SAV_OBS_BLOCK == 0) {\n+              HowManyRt2Units = recordType2FixedPart1[1] / LENGTH_SAV_OBS_BLOCK;\n+            } else {\n+              HowManyRt2Units = recordType2FixedPart1[1] / LENGTH_SAV_OBS_BLOCK + 1;\n+            }\n+            variableTypelList.add(recordType2FixedPart1[1]);\n+          }\n         }\n-        \n-        dbgLog.fine(\"decodeRecordType6(): end\");\n-    }\n-    \n-    \n-    /*\n-     * TODO: \n-     * Add an explanation note here documenting what \"record type 7\" is \n-     * and what information it stores. This is not obvious from the code\n-     * below. -- L.A. 4.0 alpha\n-    */\n-    void decodeRecordType7(BufferedInputStream stream) throws IOException {\n-        dbgLog.fine(\"decodeRecordType7(): start\");\n-        int counter=0;\n-        int[] headerSection = new int[2];\n-\n-\t// the variables below may no longer needed; \n-\t// but they may be useful for debugging/logging purposes.\n-\n-\t/// // RecordType 7 \n-\t/// // Subtype 3\n-\t/// List<Integer> releaseMachineSpecificInfo = new ArrayList<Integer>();\n-\t/// List<String> releaseMachineSpecificInfoHex = new ArrayList<String>();\n-    \n-\t/// // Subytpe 4\n-\t/// Map<String, Double> OBSTypeValue = new LinkedHashMap<String, Double>();\n-\t/// Map<String, String> OBSTypeHexValue = new LinkedHashMap<String, String>();    \n-\t//Subtype 11\n-\t/// List<Integer> measurementLevel = new ArrayList<Integer>();\n-\t/// List<Integer> columnWidth = new ArrayList<Integer>();\n-\t/// List<Integer> alignment = new ArrayList<Integer>();\n-\n-\n-\n-\n-\twhile(true){\n-\t    try {\n-\t\tif (stream ==null){\n-\t\t    throw new IllegalArgumentException(\"RT7: stream == null!\");\n-\t\t}\n-\t\t// first check the 4-byte header value\n-\t\t//if (stream.markSupported()){\n-\t\tstream.mark(1000);\n-\t\t//}\n-\t\t// 7.0 check the first 4 bytes\n-\t\tbyte[] headerCodeRt7 = new byte[LENGTH_RECORD_TYPE7_CODE];\n-\n-\t\tint nbytes_rt7 = stream.read(headerCodeRt7, 0, \n-\t\t\t\t\t     LENGTH_RECORD_TYPE7_CODE);\n-\t\t// to-do check against nbytes\n-\t\t//printHexDump(headerCodeRt7, \"RT7 header test\");\n-\t\tByteBuffer bb_header_code_rt7  = ByteBuffer.wrap(headerCodeRt7,\n-\t\t\t\t\t\t\t\t 0, LENGTH_RECORD_TYPE7_CODE);\n-\t\tif (isLittleEndian){\n-\t\t    bb_header_code_rt7.order(ByteOrder.LITTLE_ENDIAN);\n-\t\t}\n-\n-\t\tint intRT7test = bb_header_code_rt7.getInt();\n-\t\tdbgLog.fine(\"RT7: header test value=\"+intRT7test);\n-\t\tif (intRT7test != 7){\n-\t\t    //if (stream.markSupported()){\n-\t\t    //out.print(\"iteration=\"+safteyCounter);\n-\t\t    //dbgLog.fine(\"iteration=\"+safteyCounter);\n-\t\t    dbgLog.fine(\"intRT7test failed=\"+intRT7test);\n-\t\t    dbgLog.fine(\"counter=\"+counter);\n-\t\t    stream.reset();\n-\t\t    return;\n-\t\t    //}\n-\t\t}\n-            \n-\t\t// 7.1 check 4-byte integer Sub-Type Code\n-            \n-\t\tbyte[] length_sub_type_code = new byte[LENGTH_RT7_SUB_TYPE_CODE];\n-\n-\t\tint nbytes_rt7_1 = stream.read(length_sub_type_code, 0,\n-\t\t\t\t\t       LENGTH_RT7_SUB_TYPE_CODE);\n-\t\t// to-do check against nbytes\n-\t\t\n-\t\t//printHexDump(length_how_many_line_bytes, \"RT7 how_many_line_bytes\");\n-\t\tByteBuffer bb_sub_type_code = ByteBuffer.wrap(length_sub_type_code,\n-\t\t\t\t\t\t\t      0, LENGTH_RT7_SUB_TYPE_CODE);\n-\t\tif (isLittleEndian){\n-\t\t    bb_sub_type_code.order(ByteOrder.LITTLE_ENDIAN);\n-\t\t}\n-\t\t\n-\t\tint subTypeCode = bb_sub_type_code.getInt();\n-\t\tdbgLog.fine(\"RT7: subTypeCode=\"+subTypeCode);\n-\t\t\n-            \n-\t\tswitch (subTypeCode) {\n-                case 3:\n-                    // 3: Release andMachine-Specific Integer Information\n-                    \n-                    //parseRT7SubTypefield(stream);\n-                    \n-                    \n-                    headerSection = parseRT7SubTypefieldHeader(stream);\n-                    if (headerSection != null){\n-                        int unitLength = headerSection[0];\n-                        int numberOfUnits = headerSection[1];\n-                        \n-                        \n-                        for (int i=0; i<numberOfUnits; i++){\n-                            dbgLog.finer(i+\"-th fieldData\");\n-                            byte[] work = new byte[unitLength];\n-\n-                            int nb = stream.read(work);\n-                            dbgLog.finer(\"raw bytes in Hex:\"+ new String(Hex.encodeHex(work)));\n-                            ByteBuffer bb_field = ByteBuffer.wrap(work);\n-                            if (isLittleEndian){\n-                                bb_field.order(ByteOrder.LITTLE_ENDIAN);\n-                            }\n-                            String dataInHex = new String(Hex.encodeHex(bb_field.array()));\n-                            /// releaseMachineSpecificInfoHex.add(dataInHex);\n-                            \n-                            dbgLog.finer(\"raw bytes in Hex:\"+ dataInHex);\n-                            if (unitLength==4){\n-                                int fieldData = bb_field.getInt();\n-                                dbgLog.finer(\"fieldData(int)=\"+fieldData);\n-                                dbgLog.finer(\"fieldData in Hex=0x\"+Integer.toHexString(fieldData));\n-                                /// releaseMachineSpecificInfo.add(fieldData);\n-                            }\n-                            \n-                        }\n-                       \n-                        /// dbgLog.fine(\"releaseMachineSpecificInfo=\"+releaseMachineSpecificInfo);\n-                        /// dbgLog.fine(\"releaseMachineSpecificInfoHex=\"+releaseMachineSpecificInfoHex);\n-\t\t\t\n-                    } else {\n-                        // throw new IOException\n-                    }\n-                    \n-                    \n-                    dbgLog.fine(\"***** end of subType 3 ***** \\n\");\n-                    \n-                    break;\n-                case 4: \n-                    // Release andMachine-SpecificOBS-Type Information\n-                    headerSection = parseRT7SubTypefieldHeader(stream);\n-                    if (headerSection != null){\n-                        int unitLength = headerSection[0];\n-                        int numberOfUnits = headerSection[1];\n-\n-\n-                        for (int i=0; i<numberOfUnits; i++){\n-                            dbgLog.finer(i+\"-th fieldData:\"+RecordType7SubType4Fields.get(i));\n-                            byte[] work = new byte[unitLength];\n-\n-                            int nb = stream.read(work);\n-\n-                            dbgLog.finer(\"raw bytes in Hex:\"+ new String(Hex.encodeHex(work)));\n-                            ByteBuffer bb_field = ByteBuffer.wrap(work);\n-                            dbgLog.finer(\"byte order=\"+bb_field.order().toString());\n-                            if (isLittleEndian){\n-                                bb_field.order(ByteOrder.LITTLE_ENDIAN);\n-                            }\n-                            ByteBuffer bb_field_dup = bb_field.duplicate();\n-                            OBSTypeHexValue.put(RecordType7SubType4Fields.get(i),\n-                                new String(Hex.encodeHex(bb_field.array())) );\n-//                            dbgLog.finer(\"raw bytes in Hex:\"+\n-//                                OBSTypeHexValue.get(RecordType7SubType4Fields.get(i)));\n-                            if (unitLength==8){\n-                                double fieldData = bb_field.getDouble();\n-                                /// OBSTypeValue.put(RecordType7SubType4Fields.get(i), fieldData);\n-                                dbgLog.finer(\"fieldData(double)=\"+fieldData);\n-                                OBSTypeHexValue.put(RecordType7SubType4Fields.get(i),\n-\t\t\t\t\t\t    Double.toHexString(fieldData));\n-                                dbgLog.fine(\"fieldData in Hex=\"+Double.toHexString(fieldData));\n-                            }\n-                        }\n-                        /// dbgLog.fine(\"OBSTypeValue=\"+OBSTypeValue);\n-                        /// dbgLog.fine(\"OBSTypeHexValue=\"+OBSTypeHexValue);\n \n-                    } else {\n-                        // throw new IOException\n-                    }\n-                    \n-\n-                    dbgLog.fine(\"***** end of subType 4 ***** \\n\");\n-                    break;\n-                case 5:\n-                    // Variable Sets Information\n-                    parseRT7SubTypefield(stream);\n-                    break;\n-                case 6:\n-                    // Trends date information\n-                    parseRT7SubTypefield(stream);\n-                    break;\n-                case 7:\n-                    // Multiple response groups\n-                    parseRT7SubTypefield(stream);\n-                    break;\n-                case 8:\n-                    // Windows Data Entry data\n-                    parseRT7SubTypefield(stream);\n-                    break;\n-                case 9:\n-                    //\n-                    parseRT7SubTypefield(stream);\n-                    break;\n-                case 10:\n-                    // TextSmart data\n-                    parseRT7SubTypefield(stream);\n-                    break;\n-                case 11:\n-                    // Msmt level, col width, & alignment\n-                    //parseRT7SubTypefield(stream);\n-\n-                    headerSection = parseRT7SubTypefieldHeader(stream);\n-                    if (headerSection != null){\n-                        int unitLength = headerSection[0];\n-                        int numberOfUnits = headerSection[1];\n-\n-                        for (int i=0; i<numberOfUnits; i++){\n-                            dbgLog.finer(i+\"-th fieldData\");\n-                            byte[] work = new byte[unitLength];\n-\n-                            int nb = stream.read(work);\n-                            dbgLog.finer(\"raw bytes in Hex:\"+ new String(Hex.encodeHex(work)));\n-                            ByteBuffer bb_field = ByteBuffer.wrap(work);\n-                            if (isLittleEndian){\n-                                bb_field.order(ByteOrder.LITTLE_ENDIAN);\n-                            }\n-                            dbgLog.finer(\"raw bytes in Hex:\"+ new String(Hex.encodeHex(bb_field.array())));\n-                            \n-                            if (unitLength==4){\n-                                int fieldData = bb_field.getInt();\n-                                dbgLog.finer(\"fieldData(int)=\"+fieldData);\n-                                dbgLog.finer(\"fieldData in Hex=0x\"+Integer.toHexString(fieldData));\n-                                \n-                                int remainder = i%3;\n-                                dbgLog.finer(\"remainder=\"+remainder);\n-                                if (remainder == 0){\n-                                    /// measurementLevel.add(fieldData);\n-                                } else if (remainder == 1){\n-                                    /// columnWidth.add(fieldData);\n-                                } else if (remainder == 2){\n-                                    /// alignment.add(fieldData);\n-                                }\n-                            }\n+        if (!extendedVariableMode) {\n+          // Again, we only want to do the following steps for the \"real\"\n+          // variables, not the chunks of split mega-variables:\n \n-                        }\n+          dbgLog.fine(\"RT2: HowManyRt2Units for this variable=\" + HowManyRt2Units);\n \n-                    } else {\n-                        // throw new IOException\n-                    }\n-                    /// dbgLog.fine(\"measurementLevel=\"+measurementLevel);\n-                    /// dbgLog.fine(\"columnWidth=\"+columnWidth);\n-                    /// dbgLog.fine(\"alignment=\"+alignment);\n-                    dbgLog.fine(\"end of subType 11\\n\");\n-\n-                    break;\n-                case 12:\n-                    // Windows Data Entry GUID\n-                    parseRT7SubTypefield(stream);\n-                    break;\n-                case 13:\n-                    // Extended variable names\n-                    // parseRT7SubTypefield(stream);\n-                    headerSection = parseRT7SubTypefieldHeader(stream);\n-\n-                    if (headerSection != null){\n-                        int unitLength = headerSection[0];\n-                        dbgLog.fine(\"RT7: unitLength=\"+unitLength);\n-                        int numberOfUnits = headerSection[1];\n-                        dbgLog.fine(\"RT7: numberOfUnits=\"+numberOfUnits);\n-                        byte[] work = new byte[unitLength*numberOfUnits];\n-                        int nbtyes13 = stream.read(work);\n-\n-                        String[] variableShortLongNamePairs = new String(work,\"US-ASCII\").split(\"\\t\");\n-\n-                        for (int i=0; i<variableShortLongNamePairs.length; i++){\n-                            dbgLog.fine(\"RT7: \"+i+\"-th pair\"+variableShortLongNamePairs[i]);\n-                            String[] pair = variableShortLongNamePairs[i].split(\"=\");\n-                            shortToLongVariableNameTable.put(pair[0], pair[1]);\n-                        }\n-\n-                        dbgLog.fine(\"RT7: shortToLongVarialbeNameTable\"+\n-                                shortToLongVariableNameTable);\n-                        // We are saving the short-to-long name map; at the\n-                        // end of ingest, we'll go through the data variables and\n-                        // change the names accordingly. \n-                        \n-                        // smd.setShortToLongVarialbeNameTable(shortToLongVarialbeNameTable);\n-                    } else {\n-                        // throw new IOException\n-                    }\n+          lastVariableName = variableName;\n \n-                    break;\n-                case 14:\n-                    // Extended strings\n-                    //parseRT7SubTypefield(stream);\n-                    headerSection = parseRT7SubTypefieldHeader(stream);\n-\n-                    if (headerSection != null){\n-                        int unitLength = headerSection[0];\n-                        dbgLog.fine(\"RT7.14: unitLength=\"+unitLength);\n-                        int numberOfUnits = headerSection[1];\n-                        dbgLog.fine(\"RT7.14: numberOfUnits=\"+numberOfUnits);\n-                        byte[] work = new byte[unitLength*numberOfUnits];\n-                        int nbtyes13 = stream.read(work);\n-\n-                        String[] extendedVariablesSizePairs = new String(work,defaultCharSet).split(\"\\000\\t\");\n-\n-                        for (int i=0; i<extendedVariablesSizePairs.length; i++){\n-                            dbgLog.fine(\"RT7.14: \"+i+\"-th pair\"+extendedVariablesSizePairs[i]);\n-\t\t\t    if ( extendedVariablesSizePairs[i].indexOf(\"=\") > 0 ) {\n-\t\t\t\tString[] pair = extendedVariablesSizePairs[i].split(\"=\");\n-\t\t\t\textendedVariablesSizeTable.put(pair[0], Integer.valueOf(pair[1]));\n-\t\t\t    }\n-                        }\n-\n-                        dbgLog.fine(\"RT7.14: extendedVariablesSizeTable\"+\n-                                extendedVariablesSizeTable);\n-                    } else {\n-                        // throw new IOException\n-                    }\n+          // caseWeightVariableOBSIndex starts from 1: 0 is used for does-not-exist cases\n+          if (j == (caseWeightVariableOBSIndex - 1)) {\n+            caseWeightVariableName = variableName;\n+            // TODO: do we need this \"index\"? -- 4.0 alpha\n+            caseWeightVariableIndex = variableCounter;\n \n-                    break;\n-                case 15:\n-                    // Clementine Metadata\n-                    parseRT7SubTypefield(stream);\n-                    break;\n-                case 16:\n-                    // 64 bit N of cases\n-                    parseRT7SubTypefield(stream);\n-                    break;\n-                case 17:\n-                    // File level attributes\n-                    parseRT7SubTypefield(stream);\n-                    break;\n-                case 18:\n-                    // Variable attributes\n-                    parseRT7SubTypefield(stream);\n-                    break;\n-                case 19:\n-                    // Extended multiple response groups\n-                    parseRT7SubTypefield(stream);\n-                    break;\n-                case 20:\n-                    // Character encoding, aka code page.\n-                    // Must be a version 16+ feature (?).\n-                    // Starting v.16, the default character encoding for SAV\n-                    // files is UTF-8; but then it is possible to specify an \n-                    // alternative encoding here. \n-                    // A typical use case would be people setting it to \"ISO-Latin\" \n-                    // or \"windows-1252\", or a similar 8-bit encoding to store \n-                    // text with standard Western European accents.\n-                    // -- L.A.\n-                    \n-                    headerSection = parseRT7SubTypefieldHeader(stream);\n-\n-                    if (headerSection != null){\n-                        int unitLength = headerSection[0];\n-                        dbgLog.fine(\"RT7-20: unitLength=\"+unitLength);\n-                        int numberOfUnits = headerSection[1];\n-                        dbgLog.fine(\"RT7-20: numberOfUnits=\"+numberOfUnits);\n-                        byte[] rt7st20bytes = new byte[unitLength*numberOfUnits];\n-                        int nbytes20 = stream.read(rt7st20bytes);\n-\n-                        String dataCharSet = new String(rt7st20bytes,\"US-ASCII\");\n-\n-                        if (dataCharSet != null && !(dataCharSet.equals(\"\"))) {\n-                            dbgLog.fine(\"RT7-20: data charset: \"+ dataCharSet);\n-                            defaultCharSet = dataCharSet; \n-                        }\n-                    } /*else {\n-                        // TODO: \n-                        // decide if the exception should actually be thrown here!\n-                        // -- L.A. 4.0 beta\n-                        // throw new IOException\n-                    }*/\n-                     \n-\n-                    break;\n-                case 21:\n-                    // Value labels for long strings\n-                    parseRT7SubTypefield(stream);\n-                    break;\n-                case 22:\n-                    // Missing values for long strings\n-                    parseRT7SubTypefield(stream);\n-                    break;\n-                default:\n-                    parseRT7SubTypefield(stream);\n-            }\n+            ///smd.setCaseWeightVariableName(caseWeightVariableName);\n+            ///smd.getFileInformation().put(\"caseWeightVariableIndex\", caseWeightVariableIndex);\n+          }\n \n-        } catch (IOException ex){\n-            //ex.printStackTrace();\n-\t    throw ex; \n-        }\n+          OBSIndexToVariableName.put(j, variableName);\n \n-        counter++;\n+          //dbgLog.fine(\"\\nvariable name=\"+variableName+\"<-\");\n+          dbgLog.fine(\"RT2: \" + j + \"-th variable name=\" + variableName + \"<-\");\n+          dbgLog.fine(\"RT2: raw variable: \" + RawVariableName);\n \n-        if (counter > 20){\n-            break;\n+          variableNameList.add(variableName);\n         }\n-    }\n \n-    dbgLog.fine(\"RT7: counter=\"+counter);\n-        dbgLog.fine(\"RT7: decodeRecordType7(): end\");\n-    }\n-    \n-    \n-    void decodeRecordType999(BufferedInputStream stream) throws IOException {\n-        dbgLog.fine(\"decodeRecordType999(): start\");\n-        try {\n-            if (stream ==null){\n-                throw new IllegalArgumentException(\"RT999: stream == null!\");\n-            }\n-            // first check the 4-byte header value\n-            //if (stream.markSupported()){\n-            stream.mark(1000);\n-            //}\n-            // 999.0 check the first 4 bytes\n-            byte[] headerCodeRt999 = new byte[LENGTH_RECORD_TYPE999_CODE];\n-\n-            //dbgLog.fine(\"RT999: stream position=\"+stream.pos);\n-\n-            int nbytes_rt999 = stream.read(headerCodeRt999, 0, \n-                LENGTH_RECORD_TYPE999_CODE);\n-            // to-do check against nbytes\n-            //printHexDump(headerCodeRt999, \"RT999 header test\");\n-            ByteBuffer bb_header_code_rt999  = ByteBuffer.wrap(headerCodeRt999,\n-                       0, LENGTH_RECORD_TYPE999_CODE);\n-            if (isLittleEndian){\n-                bb_header_code_rt999.order(ByteOrder.LITTLE_ENDIAN);\n-            }\n \n-            int intRT999test = bb_header_code_rt999.getInt();\n-            dbgLog.fine(\"header test value: RT999=\"+intRT999test);\n-            if (intRT999test != 999){\n-            //if (stream.markSupported()){\n-                dbgLog.fine(\"intRT999test failed=\"+intRT999test);\n-                stream.reset();\n-               throw new IOException(\"RT999:Header value(999) was not correctly detected:\"+intRT999test);\n-            //}\n-            }\n-            \n-            \n-            \n-            // 999.1 check 4-byte integer Filler block\n-            \n-            byte[] length_filler = new byte[LENGTH_RT999_FILLER];\n-\n-            int nbytes_rt999_1 = stream.read(length_filler, 0,\n-                LENGTH_RT999_FILLER);\n-            // to-do check against nbytes\n-            \n-            //printHexDump(length_how_many_line_bytes, \"RT999 how_many_line_bytes\");\n-            ByteBuffer bb_filler = ByteBuffer.wrap(length_filler,\n-                       0, LENGTH_RT999_FILLER);\n-            if (isLittleEndian){\n-                bb_filler.order(ByteOrder.LITTLE_ENDIAN);\n-            }\n+        // 3rd ([2]) element: = 1 variable-label block follows; 0 = no label\n+        //\n+        dbgLog.fine(\"RT: variable label follows?(1:yes; 0: no)=\" + recordType2FixedPart1[2]);\n+        boolean hasVariableLabel = recordType2FixedPart1[2] == 1 ? true : false;\n+        if ((recordType2FixedPart1[2] != 0) && (recordType2FixedPart1[2] != 1)) {\n+          throw new IOException(\"RT2: reading error: value is neither 0 or 1\" +\n+            recordType2FixedPart1[2]);\n+        }\n \n-            int rt999filler = bb_filler.getInt();\n-            dbgLog.fine(\"rt999filler=\"+rt999filler);\n-            \n-            if (rt999filler == 0){\n-                dbgLog.fine(\"the end of the dictionary section\");\n+        // 2.4 [optional]The length of a variable label followed: 4-byte int\n+        // 3rd element of 2.1 indicates whether this field exists\n+        // *** warning: The label block is padded to a multiple of the 4-byte\n+        // NOT the raw integer value of this 4-byte block\n+\n+\n+        if (hasVariableLabel) {\n+          byte[] length_variable_label = new byte[4];\n+          int nbytes_2_4 = stream.read(length_variable_label);\n+          if (nbytes_2_4 == 0) {\n+            throw new IOException(\"RT 2: error reading recordType2.4: no bytes read!\");\n+          } else {\n+            dbgLog.fine(\"nbytes_2_4=\" + nbytes_2_4);\n+          }\n+          ByteBuffer bb_length_variable_label = ByteBuffer.wrap(\n+            length_variable_label, 0, LENGTH_VARIABLE_LABEL);\n+          if (isLittleEndian) {\n+            bb_length_variable_label.order(ByteOrder.LITTLE_ENDIAN);\n+          }\n+          int rawVariableLabelLength = bb_length_variable_label.getInt();\n+\n+          dbgLog.fine(\"rawVariableLabelLength=\" + rawVariableLabelLength);\n+          int variableLabelLength = getSAVintAdjustedBlockLength(rawVariableLabelLength);\n+          dbgLog.fine(\"RT2: variableLabelLength=\" + variableLabelLength);\n+\n+          // 2.5 [optional]variable label whose length is found at 2.4\n+\n+          String variableLabel = \"\";\n+\n+          if (rawVariableLabelLength > 0) {\n+            byte[] variable_label = new byte[variableLabelLength];\n+            int nbytes_2_5 = stream.read(variable_label);\n+            if (nbytes_2_5 == 0) {\n+              throw new IOException(\"RT 2: error reading recordType2.5: \"\n+                + variableLabelLength + \" bytes requested, no bytes read!\");\n             } else {\n-                throw new IOException(\"RT999: failed to detect the end mark(0): value=\"+rt999filler);\n+              dbgLog.fine(\"nbytes_2_5=\" + nbytes_2_5);\n             }\n+            variableLabel = getNullStrippedString(new String(Arrays.copyOfRange(variable_label,\n+              0, rawVariableLabelLength), defaultCharSet));\n+            dbgLog.fine(\"RT2: variableLabel=\" + variableLabel + \"<-\");\n+\n+            dbgLog.fine(variableName + \" => \" + variableLabel);\n+          } else {\n+            dbgLog.fine(\"RT2: defaulting to empty variable label.\");\n+          }\n+\n+          if (!extendedVariableMode) {\n+            // We only have any use for this label if it's a \"real\" variable.\n+            // Thinking about it, it doesn't make much sense for the \"fake\"\n+            // variables that are actually chunks of large strings to store\n+            // their own labels. But in some files they do. Then failing to read\n+            // the bytes would result in getting out of sync with the RT record\n+            // borders. So we always read the bytes, but only use them for\n+            // the real variable entries.\n+                        /*String variableLabel = new String(Arrays.copyOfRange(variable_label,\n+                                0, rawVariableLabelLength),\"US-ASCII\");*/\n \n-            // missing value processing concerning HIGHEST/LOWEST values\n-\n-            Set<Map.Entry<String,InvalidData>> msvlc = invalidDataTable.entrySet();\n-            for (Iterator<Map.Entry<String,InvalidData>> itc = msvlc.iterator(); itc.hasNext();){\n-                Map.Entry<String, InvalidData> et = itc.next();\n-                String variable = et.getKey();\n-                dbgLog.fine(\"variable=\"+variable);\n-                InvalidData invalidDataInfo = et.getValue();\n-\n-                if (invalidDataInfo.getInvalidRange() != null &&\n-                    !invalidDataInfo.getInvalidRange().isEmpty()){\n-                    if (invalidDataInfo.getInvalidRange().get(0).equals(OBSTypeHexValue.get(\"LOWEST\"))){\n-                        dbgLog.fine(\"1st value is LOWEST\");\n-                        invalidDataInfo.getInvalidRange().set(0, \"LOWEST\");\n-                    } else if (invalidDataInfo.getInvalidRange().get(1).equals(OBSTypeHexValue.get(\"HIGHEST\"))){\n-                        dbgLog.fine(\"2nd value is HIGHEST\");\n-                        invalidDataInfo.getInvalidRange().set(1,\"HIGHEST\");\n-                    }\n-                }\n-            }\n-            dbgLog.fine(\"invalidDataTable:\\n\"+invalidDataTable);\n-            // TODO: take care of the invalid data! - add the appropriate \n-            // value labels (?) \n-            // should it be done here, or at the end of ingest?\n-            // -- L.A. 4.0 alpha\n-            ///smd.setInvalidDataTable(invalidDataTable);\n-        } catch (IOException ex){\n-            //ex.printStackTrace();\n-            //exit(1);\n-\t    throw ex; \n+            variableLabelMap.put(variableName, variableLabel);\n+          }\n         }\n-        \n-        dbgLog.fine(\"decodeRecordType999(): end\");\n-    }\n-    \n-    \n \n-    void decodeRecordTypeData(BufferedInputStream stream) throws IOException {\n-        dbgLog.fine(\"decodeRecordTypeData(): start\");\n+        if (extendedVariableMode) {\n+          // there's nothing else left for us to do in this iteration of the loop.\n+          // Once again, this was not a real variable, but a dummy variable entry\n+          // created for a chunk of a string variable longer than 255 bytes --\n+          // that's how SPSS stores them.\n+          continue;\n+        }\n \n-\t///String fileUnfValue = null;\n-\t///String[] unfValues = null;\n+        // 4th ([3]) element: Missing value type code\n+        // 0[none], 1, 2, 3 [point-type],-2[range], -3 [range type+ point]\n \n+        dbgLog.fine(\"RT: missing value unit follows?(if 0, none)=\" + recordType2FixedPart1[3]);\n+        boolean hasMissingValues =\n+          (validMissingValueCodeSet.contains(\n+            recordType2FixedPart1[3]) && (recordType2FixedPart1[3] != 0)) ?\n+            true : false;\n \n+        InvalidData invalidDataInfo = null;\n \n-        if (stream ==null){\n-            throw new IllegalArgumentException(\"stream == null!\");\n+        if (recordType2FixedPart1[3] != 0) {\n+          invalidDataInfo = new InvalidData(recordType2FixedPart1[3]);\n+          dbgLog.fine(\"RT: missing value type=\" + invalidDataInfo.getType());\n         }\n-        if (isDataSectionCompressed){\n-            decodeRecordTypeDataCompressed(stream);\n-        } else {\n-            decodeRecordTypeDataUnCompressed(stream);\n-        }\n-            \n-        /* UNF calculation was here... */\n-        \n-        dbgLog.fine(\"***** decodeRecordTypeData(): end *****\");\n-    }\n \n-    PrintWriter createOutputWriter (BufferedInputStream stream) throws IOException {\n-        PrintWriter pwout = null;\n-\tFileOutputStream fileOutTab = null;\n-\t        \n-        try {\n+        // 2.2: print/write formats: 4-byte each = 8 bytes\n \n-            // create a File object to save the tab-delimited data file\n-            File tabDelimitedDataFile = File.createTempFile(\"tempTabfile.\", \".tab\");\n+        byte[] printFormt = Arrays.copyOfRange(recordType2Fixed, offset, offset +\n+          LENGTH_PRINT_FORMAT_CODE);\n+        dbgLog.fine(\"printFrmt=\" + new String(Hex.encodeHex(printFormt)));\n \n-            String tabDelimitedDataFileName   = tabDelimitedDataFile.getAbsolutePath();\n \n-            // save the temp file name in the metadata object\n-            ///smd.getFileInformation().put(\"tabDelimitedDataFileLocation\", tabDelimitedDataFileName);\n-            ingesteddata.setTabDelimitedFile(tabDelimitedDataFile);\n+        offset += LENGTH_PRINT_FORMAT_CODE;\n+        int formatCode = isLittleEndian ? printFormt[2] : printFormt[1];\n+        int formatWidth = isLittleEndian ? printFormt[1] : printFormt[2];\n \n-            fileOutTab = new FileOutputStream(tabDelimitedDataFile);\n-            \n-            pwout = new PrintWriter(new OutputStreamWriter(fileOutTab, \"utf8\"), true);\n+        // TODO:\n+        // What should we be doing with these \"format decimal positions\"\n+        // in 4.0?\n+        // -- L.A. 4.0 alpha\n \n-        } catch (FileNotFoundException ex) {\n-            ex.printStackTrace();\n-        } catch (UnsupportedEncodingException ex) {\n-            ex.printStackTrace();\n-        } catch (IOException ex){\n-            //ex.printStackTrace();\n-\t    throw ex; \n-        }\n+        int formatDecimalPointPosition = isLittleEndian ? printFormt[0] : printFormt[3];\n+        dbgLog.fine(\"RT2: format code{5=F, 1=A[String]}=\" + formatCode);\n \n-\treturn pwout;\n+        formatDecimalPointPositionList.add(formatDecimalPointPosition);\n \n-    }\n \n-    void decodeRecordTypeDataCompressed(BufferedInputStream stream) throws IOException {\n+        if (!SPSSConstants.FORMAT_CODE_TABLE_SAV.containsKey(formatCode)) {\n+          throw new IOException(\"Unknown format code was found = \"\n+            + formatCode);\n+        } else {\n+          printFormatList.add(formatCode);\n+        }\n \n-        dbgLog.fine(\"***** decodeRecordTypeDataCompressed(): start *****\");\n+        byte[] writeFormt = Arrays.copyOfRange(recordType2Fixed, offset, offset +\n+          LENGTH_WRITE_FORMAT_CODE);\n \n-        if (stream == null) {\n-            throw new IllegalArgumentException(\"decodeRecordTypeDataCompressed: stream == null!\");\n+        dbgLog.fine(\"RT2: writeFrmt=\" + new String(Hex.encodeHex(writeFormt)));\n+        if (writeFormt[3] != 0x00) {\n+          dbgLog.fine(\"byte-order(write format): reversal required\");\n         }\n \n-        PrintWriter pwout = createOutputWriter(stream);\n+        offset += LENGTH_WRITE_FORMAT_CODE;\n \n-        int varQnty = dataTable.getVarQuantity().intValue();\n-        int caseQnty = dataTable.getCaseQuantity().intValue();\n+        if (!SPSSConstants.ORDINARY_FORMAT_CODE_SET.contains(formatCode)) {\n+          StringBuilder sb = new StringBuilder(\n+            SPSSConstants.FORMAT_CODE_TABLE_SAV.get(formatCode) +\n+              formatWidth);\n+          if (formatDecimalPointPosition > 0) {\n+            sb.append(\".\" + formatDecimalPointPosition);\n+          }\n+          dbgLog.fine(\"formattable[i] = \" + variableName + \" -> \" + sb.toString());\n+          printFormatNameTable.put(variableName, sb.toString());\n \n-        dbgLog.fine(\"varQnty: \" + varQnty);\n+        }\n \n-        dateFormatList = new String[varQnty];\n+        printFormatTable.put(variableName, SPSSConstants.FORMAT_CODE_TABLE_SAV.get(formatCode));\n \n-        boolean hasStringVarContinuousBlock =\n-                obsNonVariableBlockSet.size() > 0 ? true : false;\n-        dbgLog.fine(\"hasStringVarContinuousBlock=\" + hasStringVarContinuousBlock);\n \n-        int ii = 0;\n+        // 2.6 [optional] missing values:4-byte each if exists\n+        // 4th element of 2.1 indicates the structure of this sub-field\n \n-        int OBS = LENGTH_SAV_OBS_BLOCK;\n-        int nOBS = OBSUnitsPerCase;\n+        // Should we perhaps check for this for the \"fake\" variables too?\n+        //\n \n-        dbgLog.fine(\"OBSUnitsPerCase=\" + OBSUnitsPerCase);\n+        if (hasMissingValues) {\n+          dbgLog.fine(\"RT2: decoding missing value: type=\" + recordType2FixedPart1[3]);\n+          int howManyMissingValueUnits = missingValueCodeUnits.get(recordType2FixedPart1[3]);\n+          //int howManyMissingValueUnits = recordType2FixedPart1[3] > 0 ? recordType2FixedPart1[3] :  0;\n \n-        int caseIndex = 0;\n+          dbgLog.fine(\"RT2: howManyMissingValueUnits=\" + howManyMissingValueUnits);\n \n-        dbgLog.fine(\"printFormatTable:\\n\" + printFormatTable);\n-        variableFormatTypeList = new String[varQnty];\n+          byte[] missing_value_code_units = new byte[LENGTH_SAV_OBS_BLOCK * howManyMissingValueUnits];\n+          int nbytes_2_6 = stream.read(missing_value_code_units);\n \n+          if (nbytes_2_6 == 0) {\n+            throw new IOException(\"RT 2: reading recordType2.6: no byte was read\");\n+          } else {\n+            dbgLog.fine(\"nbytes_2_6=\" + nbytes_2_6);\n+          }\n \n+          //printHexDump(missing_value_code_units, \"missing value\");\n \n-        for (int i = 0; i < varQnty; i++) {\n-            variableFormatTypeList[i] = SPSSConstants.FORMAT_CATEGORY_TABLE.get(\n-                    printFormatTable.get(variableNameList.get(i)));\n-            dbgLog.fine(\"i=\" + i + \"th variableFormatTypeList=\" + variableFormatTypeList[i]);\n-            formatCategoryTable.put(variableNameList.get(i), variableFormatTypeList[i]);\n-        }\n-        dbgLog.fine(\"variableFormatType:\\n\" + Arrays.deepToString(variableFormatTypeList));\n-        dbgLog.fine(\"formatCategoryTable:\\n\" + formatCategoryTable);\n+          if (isNumericVariable) {\n \n-        // TODO: \n-        // Make sure the date formats are actually preserved! \n-        // (this is something that was collected in the code below and passed\n-        // to the UNF calculator). \n-        // -- L.A. 4.0 alpha\n-        List<String> casewiseRecordForTabFile = new ArrayList<String>();\n+            double[] missingValues = new double[howManyMissingValueUnits];\n+            //List<String> mvp = new ArrayList<String>();\n+            List<String> mv = new ArrayList<String>();\n \n-        try {\n-            // this compression is applied only to non-float data, i.e. integer;\n-            // 8-byte float datum is kept in tact\n-            boolean hasReachedEOF = false;\n+            ByteBuffer[] bb_missig_value_code =\n+              new ByteBuffer[howManyMissingValueUnits];\n \n-            OBSERVATION:\n-            while (true) {\n+            int offset_start = 0;\n \n-                dbgLog.fine(\"SAV Reader: compressed: ii=\" + ii + \"-th iteration\");\n+            for (int i = 0; i < howManyMissingValueUnits; i++) {\n \n-                byte[] octate = new byte[LENGTH_SAV_OBS_BLOCK];\n+              bb_missig_value_code[i] =\n+                ByteBuffer.wrap(missing_value_code_units, offset_start,\n+                  LENGTH_SAV_OBS_BLOCK);\n \n-                int nbytes = stream.read(octate);\n+              offset_start += LENGTH_SAV_OBS_BLOCK;\n+              if (isLittleEndian) {\n+                bb_missig_value_code[i].order(ByteOrder.LITTLE_ENDIAN);\n+              }\n \n-                // processCompressedOBSblock ()\n+              ByteBuffer temp = bb_missig_value_code[i].duplicate();\n \n-                // (this means process a block of 8 compressed OBS\n-                // values -- should result in 64 bytes of data total)\n \n-                for (int i = 0; i < LENGTH_SAV_OBS_BLOCK; i++) {\n+              missingValues[i] = bb_missig_value_code[i].getDouble();\n+              if (Double.toHexString(missingValues[i]).equals(\"-0x1.ffffffffffffep1023\")) {\n+                dbgLog.fine(\"1st value is LOWEST\");\n+                mv.add(Double.toHexString(missingValues[i]));\n+              } else if (Double.valueOf(missingValues[i]).equals(Double.MAX_VALUE)) {\n+                dbgLog.fine(\"2nd value is HIGHEST\");\n+                mv.add(Double.toHexString(missingValues[i]));\n+              } else {\n+                mv.add(doubleNumberFormatter.format(missingValues[i]));\n+              }\n+              dbgLog.fine(i + \"-th missing value=\" + Double.toHexString(missingValues[i]));\n+            }\n \n+            dbgLog.fine(\"variableName=\" + variableName);\n+            if (recordType2FixedPart1[3] > 0) {\n+              // point cases only\n+              dbgLog.fine(\"mv(>0)=\" + mv);\n+              missingValueTable.put(variableName, mv);\n+              invalidDataInfo.setInvalidValues(mv);\n+            } else if (recordType2FixedPart1[3] == -2) {\n+              dbgLog.fine(\"mv(-2)=\" + mv);\n+              // range\n+              invalidDataInfo.setInvalidRange(mv);\n+            } else if (recordType2FixedPart1[3] == -3) {\n+              // mixed case\n+              dbgLog.fine(\"mv(-3)=\" + mv);\n+              invalidDataInfo.setInvalidRange(mv.subList(0, 2));\n+              invalidDataInfo.setInvalidValues(mv.subList(2, 3));\n+              missingValueTable.put(variableName, mv.subList(2, 3));\n+            }\n \n-                    dbgLog.finer(\"i=\" + i + \"-th iteration\");\n-                    int octate_i = octate[i];\n-                    //dbgLog.fine(\"octate=\"+octate_i);\n-                    if (octate_i < 0) {\n-                        octate_i += 256;\n-                    }\n-                    int byteCode = octate_i;//octate_i & 0xF;\n-                    //out.println(\"byeCode=\"+byteCode);\n+            dbgLog.fine(\"missing value=\" +\n+              StringUtils.join(missingValueTable.get(variableName), \"|\"));\n+            dbgLog.fine(\"invalidDataInfo(Numeric):\\n\" + invalidDataInfo);\n+            invalidDataTable.put(variableName, invalidDataInfo);\n+          } else {\n+            // string variable case\n+            String[] missingValues = new String[howManyMissingValueUnits];\n+            List<String> mv = new ArrayList<String>();\n+            int offset_start = 0;\n+            int offset_end = LENGTH_SAV_OBS_BLOCK;\n+            for (int i = 0; i < howManyMissingValueUnits; i++) {\n \n-                    // processCompressedOBS\n+              missingValues[i] =\n+                StringUtils.stripEnd(new\n+                  String(Arrays.copyOfRange(missing_value_code_units, offset_start, offset_end), defaultCharSet), \" \");\n+              dbgLog.fine(\"missing value=\" + missingValues[i] + \"<-\");\n \n-                    switch (byteCode) {\n-                        case 252:\n-                            // end of the file\n-                            dbgLog.fine(\"SAV Reader: compressed: end of file mark [FC] was found\");\n-                            hasReachedEOF = true;\n-                            break;\n-                        case 253:\n-                            // FD: uncompressed data follows after this octate\n-                            // long string datum or float datum\n-                            // read the following octate\n-                            byte[] uncompressedByte = new byte[LENGTH_SAV_OBS_BLOCK];\n-                            int ucbytes = stream.read(uncompressedByte);\n-                            int typeIndex = (ii * OBS + i) % nOBS;\n-\n-                            if ((OBSwiseTypelList.get(typeIndex) > 0) ||\n-                                    (OBSwiseTypelList.get(typeIndex) == -1)) {\n-                                // code= >0 |-1: string or its conitiguous block\n-                                // decode as a string object\n-                                String strdatum = new String(\n-                                        Arrays.copyOfRange(uncompressedByte,\n-                                        0, LENGTH_SAV_OBS_BLOCK), defaultCharSet);\n-                                //out.println(\"str_datum=\"+strdatum+\"<-\");\n-                                // add this non-missing-value string datum\n-                                casewiseRecordForTabFile.add(strdatum);\n-                            //out.println(\"casewiseRecordForTabFile(String)=\"+casewiseRecordForTabFile);\n-                            } else if (OBSwiseTypelList.get(typeIndex) == -2) {\n-                                String strdatum = new String(\n-                                        Arrays.copyOfRange(uncompressedByte,\n-                                        0, LENGTH_SAV_OBS_BLOCK - 1), defaultCharSet);\n-                                casewiseRecordForTabFile.add(strdatum);\n-                            //out.println(\"casewiseRecordForTabFile(String)=\"+casewiseRecordForTabFile);\n-                            } else if (OBSwiseTypelList.get(typeIndex) == 0) {\n-                                // code= 0: numeric\n-\n-                                ByteBuffer bb_double = ByteBuffer.wrap(\n-                                        uncompressedByte, 0, LENGTH_SAV_OBS_BLOCK);\n-                                if (isLittleEndian) {\n-                                    bb_double.order(ByteOrder.LITTLE_ENDIAN);\n-                                }\n-\n-                                Double ddatum = bb_double.getDouble();\n-                                // out.println(\"ddatum=\"+ddatum);\n-                                // add this non-missing-value numeric datum\n-                                casewiseRecordForTabFile.add(doubleNumberFormatter.format(ddatum));\n-                                dbgLog.fine(\"SAV Reader: compressed: added value to dataLine: \" + ddatum);\n-\n-                            } else {\n-                                dbgLog.fine(\"SAV Reader: out-of-range exception\");\n-                                throw new IOException(\"out-of-range value was found\");\n-                            }\n+              offset_start = offset_end;\n+              offset_end += LENGTH_SAV_OBS_BLOCK;\n \n-                            /*\n-                            // EOF-check after reading this octate\n-                            if (stream.available() == 0){\n-                            hasReachedEOF = true;\n-                            dbgLog.fine(\n-                            \"SAV Reader: *** After reading an uncompressed octate,\" +\n-                            \" reached the end of the file at \"+ii\n-                            +\"th iteration and i=\"+i+\"th octate position [0-start] *****\");\n-                            }\n-                             */\n+              mv.add(missingValues[i]);\n+            }\n+            invalidDataInfo.setInvalidValues(mv);\n+            missingValueTable.put(variableName, mv);\n+            invalidDataTable.put(variableName, invalidDataInfo);\n+            dbgLog.fine(\"missing value(str)=\" +\n+              StringUtils.join(missingValueTable.get(variableName), \"|\"));\n+            dbgLog.fine(\"invalidDataInfo(String):\\n\" + invalidDataInfo);\n+\n+          } // string case\n+          dbgLog.fine(\"invalidDataTable:\\n\" + invalidDataTable);\n+        } // if msv\n+\n+      } catch (IOException ex) {\n+        //ex.printStackTrace();\n+        throw ex;\n+      } catch (Exception ex) {\n+        ex.printStackTrace();\n+        // should we be throwing some exception here?\n+      }\n+    } // j-loop\n+\n+    if (j != OBSUnitsPerCase) {\n+      dbgLog.fine(\"RT2: attention! didn't reach the end of the OBS list!\");\n+      throw new IOException(\"RT2: didn't reach the end of the OBS list!\");\n+    }\n \n+    dbgLog.fine(\"RT2 metadata-related exit-chores\");\n+    ///smd.getFileInformation().put(\"varQnty\", variableCounter);\n+    dataTable.setVarQuantity(new Long(variableCounter));\n+    dbgLog.fine(\"RT2: varQnty=\" + variableCounter);\n+\n+    // 4.0 Initialize variables:\n+    List<DataVariable> variableList = new ArrayList<DataVariable>();\n+\n+    for (int i = 0; i < variableCounter; i++) {\n+      DataVariable dv = new DataVariable(i, dataTable);\n+      String varName = variableNameList.get(i);\n+      dbgLog.fine(\"name: \" + varName);\n+      dv.setName(varName);\n+      String varLabel = variableLabelMap.get(varName);\n+      if (varLabel != null && varLabel.length() > 255) {\n+        // TODO:\n+        // variable labels will be changed into type 'TEXT' in the\n+        // database - this will eliminate the 255 char. limit.\n+        // -- L.A. 4.0 beta11\n+        dbgLog.fine(\"Have to truncate label: \" + varLabel);\n+        varLabel = varLabel.substring(0, 255);\n+      }\n+      dbgLog.fine(\"label: \" + varLabel);\n+      dv.setLabel(varLabel);\n+      variableList.add(dv);\n+\n+    }\n+\n+    dataTable.setDataVariables(variableList);\n+\n+    ///smd.setVariableName(variableNameList.toArray(new String[variableNameList.size()]));\n+    ///smd.setVariableLabel(variableLabelMap);\n+    // TODO:\n+    // figure out what to do with the missing value table!\n+    // -- 4.0 alpha\n+    // well, they were used to generate merged summary statistics for\n+    // the variable. So need to verify what the DDI import was doing\n+    // with them and replicate the same in 4.0.\n+    // (add appropriate value labels?)\n+    ///TODO: 4.0 smd.setMissingValueTable(missingValueTable);\n+    ///smd.getFileInformation().put(\"caseWeightVariableName\", caseWeightVariableName);\n+\n+    dbgLog.fine(\"sumstat:long case=\" + Arrays.deepToString(variableTypelList.toArray()));\n+\n+    dbgLog.fine(\"RT2: OBSwiseTypelList=\" + OBSwiseTypelList);\n+\n+    dbgLog.fine(\"decodeRecordType2(): end\");\n+  }\n+\n+  void decodeRecordType3and4(BufferedInputStream stream) throws IOException {\n+    dbgLog.fine(\"decodeRecordType3and4(): start\");\n+    Map<String, Map<String, String>> valueLabelTable\n+      = new LinkedHashMap<String, Map<String, String>>();\n+\n+    int safteyCounter = 0;\n+    while (true) {\n+      try {\n+        if (stream == null) {\n+          throw new IllegalArgumentException(\"stream == null!\");\n+        }\n+        // this secton may not exit so first check the 4-byte header value\n+        //if (stream.markSupported()){\n+        stream.mark(1000);\n+        //}\n+        // 3.0 check the first 4 bytes\n+        byte[] headerCode = new byte[LENGTH_RECORD_TYPE3_CODE];\n+\n+        int nbytes_rt3 = stream.read(headerCode, 0, LENGTH_RECORD_TYPE3_CODE);\n+        // to-do check against nbytes\n+        //printHexDump(headerCode, \"RT3 header test\");\n+        ByteBuffer bb_header_code = ByteBuffer.wrap(headerCode,\n+          0, LENGTH_RECORD_TYPE3_CODE);\n+        if (isLittleEndian) {\n+          bb_header_code.order(ByteOrder.LITTLE_ENDIAN);\n+        }\n+\n+        int intRT3test = bb_header_code.getInt();\n+        dbgLog.fine(\"header test value: RT3=\" + intRT3test);\n+        if (intRT3test != 3) {\n+          //if (stream.markSupported()){\n+          dbgLog.fine(\"iteration=\" + safteyCounter);\n+\n+          // We have encountered a record that's not type 3. This means we've\n+          // processed all the type 3/4 record pairs. So we want to rewind\n+          // the stream and return -- so that the appropriate record type\n+          // reader can be called on it.\n+          // But before we return, we need to save all the value labels\n+          // we have found:\n+          //smd.setValueLabelTable(valueLabelTable);\n+          assignValueLabels(valueLabelTable);\n+\n+          stream.reset();\n+          return;\n+          //}\n+        }\n+        // 3.1 how many value-label pairs follow\n+        byte[] number_of_labels = new byte[LENGTH_RT3_HOW_MANY_LABELS];\n+\n+        int nbytes_3_1 = stream.read(number_of_labels);\n+        if (nbytes_3_1 == 0) {\n+          throw new IOException(\"RT 3: reading recordType3.1: no byte was read\");\n+        }\n+        ByteBuffer bb_number_of_labels = ByteBuffer.wrap(number_of_labels,\n+          0, LENGTH_RT3_HOW_MANY_LABELS);\n+        if (isLittleEndian) {\n+          bb_number_of_labels.order(ByteOrder.LITTLE_ENDIAN);\n+        }\n+\n+        int numberOfValueLabels = bb_number_of_labels.getInt();\n+        dbgLog.fine(\"number of value-label pairs=\" + numberOfValueLabels);\n+\n+        ByteBuffer[] tempBB = new ByteBuffer[numberOfValueLabels];\n+\n+        String valueLabel[] = new String[numberOfValueLabels];\n+\n+        for (int i = 0; i < numberOfValueLabels; i++) {\n+\n+          // read 8-byte as value\n+          byte[] value = new byte[LENGTH_RT3_VALUE];\n+          int nbytes_3_value = stream.read(value);\n+\n+          if (nbytes_3_value == 0) {\n+            throw new IOException(\"RT 3: reading recordType3 value: no byte was read\");\n+          }\n+          // note these 8 bytes are interpreted later\n+          // currently no information about which variable's (=> type unknown)\n+          ByteBuffer bb_value = ByteBuffer.wrap(value,\n+            0, LENGTH_RT3_VALUE);\n+          if (isLittleEndian) {\n+            bb_value.order(ByteOrder.LITTLE_ENDIAN);\n+          }\n+          tempBB[i] = bb_value;\n+          dbgLog.fine(\"bb_value=\" + Hex.encodeHex(bb_value.array()));\n+                    /*\n+                     double valueD = bb_value.getDouble();\n+                     dbgLog.fine(\"value=\"+valueD);\n+                     */\n+          // read 1st byte as unsigned integer = label_length\n+\n+          // read label_length byte as label\n+          byte[] labelLengthByte = new byte[LENGTH_RT3_LABEL_LENGTH];\n+\n+          int nbytes_3_label_length = stream.read(labelLengthByte);\n+\n+          // add check-routine here\n+          dbgLog.fine(\"labelLengthByte\" + Hex.encodeHex(labelLengthByte));\n+          dbgLog.fine(\"label length = \" + labelLengthByte[0]);\n+          // the net-length of a value label is saved as\n+          // unsigned byte; however, the length is less than 127\n+          // byte should be ok\n+          int rawLabelLength = labelLengthByte[0] & 0xFF;\n+          dbgLog.fine(\"rawLabelLength=\" + rawLabelLength);\n+          // -1 =>1-byte already read\n+          int labelLength = getSAVobsAdjustedBlockLength(rawLabelLength + 1) - 1;\n+          byte[] valueLabelBytes = new byte[labelLength];\n+          int nbytes_3_value_label = stream.read(valueLabelBytes);\n+\n+          // ByteBuffer bb_label = ByteBuffer.wrap(valueLabel,0,labelLength);\n+          valueLabel[i] = StringUtils\n+            .stripEnd(new String(Arrays.copyOfRange(valueLabelBytes, 0, rawLabelLength), defaultCharSet), \" \");\n+          dbgLog.fine(i + \"-th valueLabel=\" + valueLabel[i] + \"<-\");\n+\n+        } // iter rt3\n+\n+        dbgLog.fine(\"end of RT3 block\");\n+        dbgLog.fine(\"start of RT4 block\");\n+\n+        // 4.0 check the first 4 bytes\n+        byte[] headerCode4 = new byte[LENGTH_RECORD_TYPE4_CODE];\n+\n+        int nbytes_rt4 = stream.read(headerCode4, 0, LENGTH_RECORD_TYPE4_CODE);\n+\n+        if (nbytes_rt4 == 0) {\n+          throw new IOException(\"RT4: reading recordType4 value: no byte was read\");\n+        }\n+\n+        //printHexDump(headerCode4, \"RT4 header test\");\n+        ByteBuffer bb_header_code_4 = ByteBuffer.wrap(headerCode4,\n+          0, LENGTH_RECORD_TYPE4_CODE);\n+        if (isLittleEndian) {\n+          bb_header_code_4.order(ByteOrder.LITTLE_ENDIAN);\n+        }\n+\n+        int intRT4test = bb_header_code_4.getInt();\n+        dbgLog.fine(\"header test value: RT4=\" + intRT4test);\n+\n+        if (intRT4test != 4) {\n+          throw new IOException(\"RT 4: reading recordType4 header: no byte was read\");\n+        }\n+\n+        // 4.1 read the how-many-variables bytes\n+        byte[] howManyVariablesfollow = new byte[LENGTH_RT4_HOW_MANY_VARIABLES];\n+\n+        int nbytes_rt4_1 = stream.read(howManyVariablesfollow, 0, LENGTH_RT4_HOW_MANY_VARIABLES);\n+\n+        ByteBuffer bb_howManyVariablesfollow = ByteBuffer.wrap(howManyVariablesfollow,\n+          0, LENGTH_RT4_HOW_MANY_VARIABLES);\n+        if (isLittleEndian) {\n+          bb_howManyVariablesfollow.order(ByteOrder.LITTLE_ENDIAN);\n+        }\n+\n+        int howManyVariablesRT4 = bb_howManyVariablesfollow.getInt();\n+        dbgLog.fine(\"how many variables follow: RT4=\" + howManyVariablesRT4);\n+\n+        int length_indicies = LENGTH_RT4_VARIABLE_INDEX * howManyVariablesRT4;\n+        byte[] variableIdicesBytes = new byte[length_indicies];\n+\n+        int nbytes_rt4_2 = stream.read(variableIdicesBytes, 0, length_indicies);\n+\n+        // !!!!! Caution: variableIndex in RT4 starts from 1 NOT ** 0 **\n+        int[] variableIndex = new int[howManyVariablesRT4];\n+        int offset = 0;\n+        for (int i = 0; i < howManyVariablesRT4; i++) {\n+\n+          ByteBuffer bb_variable_index = ByteBuffer.wrap(variableIdicesBytes,\n+            offset, LENGTH_RT4_VARIABLE_INDEX);\n+          offset += LENGTH_RT4_VARIABLE_INDEX;\n+\n+          if (isLittleEndian) {\n+            bb_variable_index.order(ByteOrder.LITTLE_ENDIAN);\n+          }\n+\n+          variableIndex[i] = bb_variable_index.getInt();\n+          dbgLog.fine(i + \"-th variable index number=\" + variableIndex[i]);\n+        }\n+\n+        dbgLog.fine(\"variable index set=\" + ArrayUtils.toString(variableIndex));\n+        dbgLog.fine(\"subtract 1 from variableIndex for getting a variable info\");\n+\n+        boolean isNumeric = OBSwiseTypelList.get(variableIndex[0] - 1) == 0 ? true : false;\n+\n+        Map<String, String> valueLabelPair = new LinkedHashMap<String, String>();\n+        if (isNumeric) {\n+          // numeric variable\n+          dbgLog.fine(\"processing of a numeric value-label table\");\n+          for (int j = 0; j < numberOfValueLabels; j++) {\n+            valueLabelPair.put(doubleNumberFormatter.format(tempBB[j].getDouble()), valueLabel[j]);\n+          }\n+        } else {\n+          // String variable\n+          dbgLog.fine(\"processing of a string value-label table\");\n+          for (int j = 0; j < numberOfValueLabels; j++) {\n+            valueLabelPair.put(\n+              StringUtils.stripEnd(new String((tempBB[j].array()), defaultCharSet), \" \"), valueLabel[j]);\n+          }\n+        }\n+\n+        dbgLog.fine(\"valueLabePair=\" + valueLabelPair);\n+        dbgLog.fine(\"key variable's (raw) index =\" + variableIndex[0]);\n+\n+        valueLabelTable.put(OBSIndexToVariableName.get(variableIndex[0] - 1), valueLabelPair);\n+\n+        dbgLog.fine(\"valueLabelTable=\" + valueLabelTable);\n+\n+        // create a mapping table that finds the key variable for this mapping table\n+        String keyVariableName = OBSIndexToVariableName.get(variableIndex[0] - 1);\n+        for (int vn : variableIndex) {\n+          valueVariableMappingTable.put(OBSIndexToVariableName.get(vn - 1), keyVariableName);\n+        }\n+\n+        dbgLog.fine(\"valueVariableMappingTable:\\n\" + valueVariableMappingTable);\n+      } catch (IOException ex) {\n+        //ex.printStackTrace();\n+        throw ex;\n+      }\n+\n+      safteyCounter++;\n+      if (safteyCounter >= 1000000) {\n+        break;\n+      }\n+    } //while\n+\n+    ///smd.setValueLabelTable(valueLabelTable);\n+    assignValueLabels(valueLabelTable);\n+\n+    dbgLog.fine(\"***** decodeRecordType3and4(): end *****\");\n+  }\n+\n+  void assignValueLabels(Map<String, Map<String, String>> valueLabelTable) {\n+    // Let's go through all the categorical value label mappings and\n+    // assign them to the correct variables:\n+\n+    for (DataVariable dataVariable : dataTable.getDataVariables()) {\n+      String varName = dataVariable.getName();\n+\n+      Map<String, String> valueLabelPairs = valueLabelTable.get(valueVariableMappingTable.get(varName));\n+      if (valueLabelPairs != null && !valueLabelPairs.isEmpty()) {\n+        for (String value : valueLabelPairs.keySet()) {\n+\n+          VariableCategory cat = new VariableCategory();\n+          cat.setValue(value);\n+          cat.setLabel(valueLabelPairs.get(value));\n+\n+          /* cross-link the variable and category to each other: */\n+          cat.setDataVariable(dataVariable);\n+          dataVariable.getCategories().add(cat);\n+        }\n+      }\n+    }\n+  }\n+\n+\n+  void decodeRecordType6(BufferedInputStream stream) throws IOException {\n+    dbgLog.fine(\"***** decodeRecordType6(): start *****\");\n+    try {\n+      if (stream == null) {\n+        throw new IllegalArgumentException(\"stream == null!\");\n+      }\n+      // this section is optional; so let's first check the 4-byte header\n+      // value and see what type it is.\n+      //if (stream.markSupported()){ // -- ? L.A. 4.0 alpha\n+      stream.mark(1000);\n+      //}\n+      // 6.0 check the first 4 bytes\n+      byte[] headerCodeRt6 = new byte[LENGTH_RECORD_TYPE6_CODE];\n+\n+      int nbytes_rt6 = stream.read(headerCodeRt6, 0, LENGTH_RECORD_TYPE6_CODE);\n+      // to-do check against nbytes\n+      //printHexDump(headerCodeRt6, \"RT6 header test\");\n+      ByteBuffer bb_header_code_rt6 = ByteBuffer.wrap(headerCodeRt6,\n+        0, LENGTH_RECORD_TYPE6_CODE);\n+      if (isLittleEndian) {\n+        bb_header_code_rt6.order(ByteOrder.LITTLE_ENDIAN);\n+      }\n+\n+      int intRT6test = bb_header_code_rt6.getInt();\n+      dbgLog.fine(\"RT6: header test value=\" + intRT6test);\n+      if (intRT6test != 6) {\n+        //if (stream.markSupported()){\n+        //out.print(\"iteration=\"+safteyCounter);\n+        //dbgLog.fine(\"iteration=\"+safteyCounter);\n+        dbgLog.fine(\"intRT6test failed=\" + intRT6test);\n+\n+        stream.reset();\n+        return;\n+        //}\n+      }\n+      // 6.1 check 4-byte integer that tells how many lines follow\n+\n+      byte[] length_how_many_line_bytes = new byte[LENGTH_RT6_HOW_MANY_LINES];\n+\n+      int nbytes_rt6_1 = stream.read(length_how_many_line_bytes, 0,\n+        LENGTH_RT6_HOW_MANY_LINES);\n+      // to-do check against nbytes\n+\n+      //printHexDump(length_how_many_line_bytes, \"RT6 how_many_line_bytes\");\n+      ByteBuffer bb_how_many_lines = ByteBuffer.wrap(length_how_many_line_bytes,\n+        0, LENGTH_RT6_HOW_MANY_LINES);\n+      if (isLittleEndian) {\n+        bb_how_many_lines.order(ByteOrder.LITTLE_ENDIAN);\n+      }\n+\n+      int howManyLinesRt6 = bb_how_many_lines.getInt();\n+      dbgLog.fine(\"how Many lines follow=\" + howManyLinesRt6);\n+\n+      // 6.2 read 80-char-long lines\n+      String[] documentRecord = new String[howManyLinesRt6];\n+\n+      for (int i = 0; i < howManyLinesRt6; i++) {\n+\n+        byte[] line = new byte[80];\n+        int nbytes_rt6_line = stream.read(line);\n+\n+        documentRecord[i] = StringUtils.stripEnd(new\n+          String(Arrays.copyOfRange(line,\n+          0, LENGTH_RT6_DOCUMENT_LINE), defaultCharSet), \" \");\n+\n+        dbgLog.fine(i + \"-th line =\" + documentRecord[i] + \"<-\");\n+      }\n+      dbgLog.fine(\"documentRecord:\\n\" + StringUtils.join(documentRecord, \"\\n\"));\n+\n+\n+    } catch (IOException ex) {\n+      //ex.printStackTrace();\n+      throw ex;\n+    }\n+\n+    dbgLog.fine(\"decodeRecordType6(): end\");\n+  }\n+\n+\n+  /*\n+   * TODO:\n+   * Add an explanation note here documenting what \"record type 7\" is\n+   * and what information it stores. This is not obvious from the code\n+   * below. -- L.A. 4.0 alpha\n+   */\n+  void decodeRecordType7(BufferedInputStream stream) throws IOException {\n+    dbgLog.fine(\"decodeRecordType7(): start\");\n+    int counter = 0;\n+    int[] headerSection = new int[2];\n+\n+    // the variables below may no longer needed;\n+    // but they may be useful for debugging/logging purposes.\n+\n+    /// // RecordType 7\n+    /// // Subtype 3\n+    /// List<Integer> releaseMachineSpecificInfo = new ArrayList<Integer>();\n+    /// List<String> releaseMachineSpecificInfoHex = new ArrayList<String>();\n+\n+    /// // Subytpe 4\n+    /// Map<String, Double> OBSTypeValue = new LinkedHashMap<String, Double>();\n+    /// Map<String, String> OBSTypeHexValue = new LinkedHashMap<String, String>();\n+    //Subtype 11\n+    /// List<Integer> measurementLevel = new ArrayList<Integer>();\n+    /// List<Integer> columnWidth = new ArrayList<Integer>();\n+    /// List<Integer> alignment = new ArrayList<Integer>();\n+\n+\n+    while (true) {\n+      try {\n+        if (stream == null) {\n+          throw new IllegalArgumentException(\"RT7: stream == null!\");\n+        }\n+        // first check the 4-byte header value\n+        //if (stream.markSupported()){\n+        stream.mark(1000);\n+        //}\n+        // 7.0 check the first 4 bytes\n+        byte[] headerCodeRt7 = new byte[LENGTH_RECORD_TYPE7_CODE];\n+\n+        int nbytes_rt7 = stream.read(headerCodeRt7, 0,\n+          LENGTH_RECORD_TYPE7_CODE);\n+        // to-do check against nbytes\n+        //printHexDump(headerCodeRt7, \"RT7 header test\");\n+        ByteBuffer bb_header_code_rt7 = ByteBuffer.wrap(headerCodeRt7,\n+          0, LENGTH_RECORD_TYPE7_CODE);\n+        if (isLittleEndian) {\n+          bb_header_code_rt7.order(ByteOrder.LITTLE_ENDIAN);\n+        }\n+\n+        int intRT7test = bb_header_code_rt7.getInt();\n+        dbgLog.fine(\"RT7: header test value=\" + intRT7test);\n+        if (intRT7test != 7) {\n+          //if (stream.markSupported()){\n+          //out.print(\"iteration=\"+safteyCounter);\n+          //dbgLog.fine(\"iteration=\"+safteyCounter);\n+          dbgLog.fine(\"intRT7test failed=\" + intRT7test);\n+          dbgLog.fine(\"counter=\" + counter);\n+          stream.reset();\n+          return;\n+          //}\n+        }\n+\n+        // 7.1 check 4-byte integer Sub-Type Code\n+\n+        byte[] length_sub_type_code = new byte[LENGTH_RT7_SUB_TYPE_CODE];\n+\n+        int nbytes_rt7_1 = stream.read(length_sub_type_code, 0,\n+          LENGTH_RT7_SUB_TYPE_CODE);\n+        // to-do check against nbytes\n+\n+        //printHexDump(length_how_many_line_bytes, \"RT7 how_many_line_bytes\");\n+        ByteBuffer bb_sub_type_code = ByteBuffer.wrap(length_sub_type_code,\n+          0, LENGTH_RT7_SUB_TYPE_CODE);\n+        if (isLittleEndian) {\n+          bb_sub_type_code.order(ByteOrder.LITTLE_ENDIAN);\n+        }\n+\n+        int subTypeCode = bb_sub_type_code.getInt();\n+        dbgLog.fine(\"RT7: subTypeCode=\" + subTypeCode);\n+\n+\n+        switch (subTypeCode) {\n+          case 3:\n+            // 3: Release andMachine-Specific Integer Information\n+\n+            //parseRT7SubTypefield(stream);\n+\n+\n+            headerSection = parseRT7SubTypefieldHeader(stream);\n+            if (headerSection != null) {\n+              int unitLength = headerSection[0];\n+              int numberOfUnits = headerSection[1];\n \n-                            break;\n-                        case 254:\n-                            // FE: used as the missing value for string variables\n-                            // an empty case in a string variable also takes this value\n-                            // string variable does not accept space-only data\n-                            // cf: uncompressed case\n-                            // 20 20 20 20 20 20 20 20\n-                            // add the string missing value\n-                            // out.println(\"254: String missing data\");\n-\n-                            casewiseRecordForTabFile.add(\" \");  // add \".\" here?\n-\n-\n-                            // Note that technically this byte flag (254/xFE) means\n-                            // that *eight* white space characters should be\n-                            // written to the output stream. This caused me\n-                            // a great amount of confusion, because it appeared\n-                            // to me that there was a mismatch between the number\n-                            // of bytes advertised in the variable metadata and\n-                            // the number of bytes actually found in the data\n-                            // section of a compressed SAV file; this is because\n-                            // these 8 bytes \"come out of nowhere\"; they are not\n-                            // written in the data section, but this flag specifies\n-                            // that they should be added to the output.\n-                            // Also, as I pointed out above, we are only writing\n-                            // out one whitespace character, not 8 as instructed.\n-                            // This appears to be legit; these blocks of 8 spaces\n-                            // seem to be only used for padding, and all such\n-                            // multiple padding spaces are stripped anyway during\n-                            // the post-processing.\n-\n-\n-                            break;\n-                        case 255:\n-                            // FF: system missing value for numeric variables\n-                            // cf: uncompressed case (sysmis)\n-                            // FF FF FF FF FF FF eF FF(little endian)\n-                            // add the numeric missing value\n-                            dbgLog.fine(\"SAV Reader: compressed: Missing Value, numeric\");\n-                            casewiseRecordForTabFile.add(MissingValueForTextDataFileNumeric);\n-\n-                            break;\n-                        case 0:\n-                            // 00: do nothing\n-                            dbgLog.fine(\"SAV Reader: compressed: doing nothing (zero); \");\n-\n-                            break;\n-                        default:\n-                            //out.println(\"byte code(default)=\"+ byteCode);\n-                            if ((byteCode > 0) && (byteCode < 252)) {\n-                                // datum is compressed\n-                                //Integer unCompressed = Integer.valueOf(byteCode -100);\n-                                // add this uncompressed numeric datum\n-                                Double unCompressed = Double.valueOf(byteCode - 100);\n-                                dbgLog.fine(\"SAV Reader: compressed: default case: \" + unCompressed);\n-\n-                                casewiseRecordForTabFile.add(doubleNumberFormatter.format(unCompressed));\n-                            // out.println(\"uncompressed=\"+unCompressed);\n-                            // out.println(\"dataline=\"+casewiseRecordForTabFile);\n-                            }\n-                    }// end of switch\n \n-                    // out.println(\"end of switch\");\n+              for (int i = 0; i < numberOfUnits; i++) {\n+                dbgLog.finer(i + \"-th fieldData\");\n+                byte[] work = new byte[unitLength];\n+\n+                int nb = stream.read(work);\n+                dbgLog.finer(\"raw bytes in Hex:\" + new String(Hex.encodeHex(work)));\n+                ByteBuffer bb_field = ByteBuffer.wrap(work);\n+                if (isLittleEndian) {\n+                  bb_field.order(ByteOrder.LITTLE_ENDIAN);\n+                }\n+                String dataInHex = new String(Hex.encodeHex(bb_field.array()));\n+                /// releaseMachineSpecificInfoHex.add(dataInHex);\n+\n+                dbgLog.finer(\"raw bytes in Hex:\" + dataInHex);\n+                if (unitLength == 4) {\n+                  int fieldData = bb_field.getInt();\n+                  dbgLog.finer(\"fieldData(int)=\" + fieldData);\n+                  dbgLog.finer(\"fieldData in Hex=0x\" + Integer.toHexString(fieldData));\n+                  /// releaseMachineSpecificInfo.add(fieldData);\n+                }\n \n+              }\n \n-                    // The-end-of-a-case(row)-processing\n+              /// dbgLog.fine(\"releaseMachineSpecificInfo=\"+releaseMachineSpecificInfo);\n+              /// dbgLog.fine(\"releaseMachineSpecificInfoHex=\"+releaseMachineSpecificInfoHex);\n \n-                    // this line that follows, and the code around it\n-                    // is really confusing:\n-                    int varCounter = (ii * OBS + i + 1) % nOBS;\n-                    // while both OBS and LENGTH_SAV_OBS_BLOCK = 8\n-                    // (OBS was initialized as OBS=LENGTH_SAV_OBS_BLOCK),\n-                    // the 2 values mean different things:\n-                    // LENGTH_SAV_OBS_BLOCK is the number of bytes in one OBS;\n-                    // and OBS is the number of OBS blocks that we process\n-                    // at a time. I.e., we process 8 chunks of 8 bytes at a time.\n-                    // This is how data is organized inside an SAV file:\n-                    // 8 bytes of compression flags, followd by 8x8 or fewer\n-                    // (depending on the flags) bytes of compressed data.\n-                    // I should rename this OBS variable something more\n-                    // meaningful.\n-                    //\n-                    // Also, the \"varCounter\" variable name is entirely\n-                    // misleading -- it counts not variables, but OBS blocks.\n+            } else {\n+              // throw new IOException\n+            }\n \n-                    dbgLog.fine(\"SAV Reader: compressed: OBS counter=\" + varCounter + \"(ii=\" + ii + \")\");\n \n-                    if ((ii * OBS + i + 1) % nOBS == 0) {\n+            dbgLog.fine(\"***** end of subType 3 ***** \\n\");\n \n-                        //out.println(\"casewiseRecordForTabFile(before)=\"+casewiseRecordForTabFile);\n+            break;\n+          case 4:\n+            // Release andMachine-SpecificOBS-Type Information\n+            headerSection = parseRT7SubTypefieldHeader(stream);\n+            if (headerSection != null) {\n+              int unitLength = headerSection[0];\n+              int numberOfUnits = headerSection[1];\n \n-                        // out.println(\"all variables in a case are parsed == nOBS\");\n-                        // out.println(\"hasStringVarContinuousBlock=\"+hasStringVarContinuousBlock);\n \n-                        // check whether a string-variable's continuous block exits\n-                        // if so, they must be joined\n+              for (int i = 0; i < numberOfUnits; i++) {\n+                dbgLog.finer(i + \"-th fieldData:\" + RecordType7SubType4Fields.get(i));\n+                byte[] work = new byte[unitLength];\n \n-                        if (hasStringVarContinuousBlock) {\n+                int nb = stream.read(work);\n+\n+                dbgLog.finer(\"raw bytes in Hex:\" + new String(Hex.encodeHex(work)));\n+                ByteBuffer bb_field = ByteBuffer.wrap(work);\n+                dbgLog.finer(\"byte order=\" + bb_field.order().toString());\n+                if (isLittleEndian) {\n+                  bb_field.order(ByteOrder.LITTLE_ENDIAN);\n+                }\n+                ByteBuffer bb_field_dup = bb_field.duplicate();\n+                OBSTypeHexValue.put(RecordType7SubType4Fields.get(i),\n+                  new String(Hex.encodeHex(bb_field.array())));\n+//                            dbgLog.finer(\"raw bytes in Hex:\"+\n+//                                OBSTypeHexValue.get(RecordType7SubType4Fields.get(i)));\n+                if (unitLength == 8) {\n+                  double fieldData = bb_field.getDouble();\n+                  /// OBSTypeValue.put(RecordType7SubType4Fields.get(i), fieldData);\n+                  dbgLog.finer(\"fieldData(double)=\" + fieldData);\n+                  OBSTypeHexValue.put(RecordType7SubType4Fields.get(i),\n+                    Double.toHexString(fieldData));\n+                  dbgLog.fine(\"fieldData in Hex=\" + Double.toHexString(fieldData));\n+                }\n+              }\n+              /// dbgLog.fine(\"OBSTypeValue=\"+OBSTypeValue);\n+              /// dbgLog.fine(\"OBSTypeHexValue=\"+OBSTypeHexValue);\n \n-                            // string-variable's continuous-block-concatenating-processing\n+            } else {\n+              // throw new IOException\n+            }\n \n-                            //out.println(\"concatenating process starts\");\n-                            //out.println(\"casewiseRecordForTabFile(before)=\"+casewiseRecordForTabFile);\n-                            //out.println(\"casewiseRecordForTabFile(before:size)=\"+casewiseRecordForTabFile.size());\n \n-                            StringBuilder sb = new StringBuilder(\"\");\n-                            int firstPosition = 0;\n+            dbgLog.fine(\"***** end of subType 4 ***** \\n\");\n+            break;\n+          case 5:\n+            // Variable Sets Information\n+            parseRT7SubTypefield(stream);\n+            break;\n+          case 6:\n+            // Trends date information\n+            parseRT7SubTypefield(stream);\n+            break;\n+          case 7:\n+            // Multiple response groups\n+            parseRT7SubTypefield(stream);\n+            break;\n+          case 8:\n+            // Windows Data Entry data\n+            parseRT7SubTypefield(stream);\n+            break;\n+          case 9:\n+            //\n+            parseRT7SubTypefield(stream);\n+            break;\n+          case 10:\n+            // TextSmart data\n+            parseRT7SubTypefield(stream);\n+            break;\n+          case 11:\n+            // Msmt level, col width, & alignment\n+            //parseRT7SubTypefield(stream);\n \n-                            Set<Integer> removeJset = new HashSet<Integer>();\n-                            for (int j = 0; j < nOBS; j++) {\n-                                dbgLog.fine(\"RTD: j=\" + j + \"-th type =\" + OBSwiseTypelList.get(j));\n-                                if ((OBSwiseTypelList.get(j) == -1) ||\n-                                        (OBSwiseTypelList.get(j) == -2)) {\n-                                    // Continued String variable found at j-th\n-                                    // position. look back the j-1\n-                                    firstPosition = j - 1;\n-                                    int lastJ = j;\n-                                    String concatenated = null;\n+            headerSection = parseRT7SubTypefieldHeader(stream);\n+            if (headerSection != null) {\n+              int unitLength = headerSection[0];\n+              int numberOfUnits = headerSection[1];\n \n-                                    removeJset.add(j);\n-                                    sb.append(casewiseRecordForTabFile.get(j - 1));\n-                                    sb.append(casewiseRecordForTabFile.get(j));\n-                                    \n-\t\t\t\t    for (int jc = 1; ; jc++) {\n-                                        if ((j + jc == nOBS) \n-\t\t\t\t\t    || ((OBSwiseTypelList.get(j + jc) != -1) \n-\t\t\t\t\t\t&& (OBSwiseTypelList.get(j + jc) != -2))) {\n+              for (int i = 0; i < numberOfUnits; i++) {\n+                dbgLog.finer(i + \"-th fieldData\");\n+                byte[] work = new byte[unitLength];\n \n-                                            // j is the end unit of this string variable\n-                                            concatenated = sb.toString();\n-                                            sb.setLength(0);\n-                                            lastJ = j + jc;\n-                                            break;\n-                                        } else {\n-                                            sb.append(casewiseRecordForTabFile.get(j + jc));\n-                                            removeJset.add(j + jc);\n-                                        }\n-                                    }\n-                                    casewiseRecordForTabFile.set(j - 1, concatenated);\n+                int nb = stream.read(work);\n+                dbgLog.finer(\"raw bytes in Hex:\" + new String(Hex.encodeHex(work)));\n+                ByteBuffer bb_field = ByteBuffer.wrap(work);\n+                if (isLittleEndian) {\n+                  bb_field.order(ByteOrder.LITTLE_ENDIAN);\n+                }\n+                dbgLog.finer(\"raw bytes in Hex:\" + new String(Hex.encodeHex(bb_field.array())));\n+\n+                if (unitLength == 4) {\n+                  int fieldData = bb_field.getInt();\n+                  dbgLog.finer(\"fieldData(int)=\" + fieldData);\n+                  dbgLog.finer(\"fieldData in Hex=0x\" + Integer.toHexString(fieldData));\n+\n+                  int remainder = i % 3;\n+                  dbgLog.finer(\"remainder=\" + remainder);\n+                  if (remainder == 0) {\n+                    /// measurementLevel.add(fieldData);\n+                  } else if (remainder == 1) {\n+                    /// columnWidth.add(fieldData);\n+                  } else if (remainder == 2) {\n+                    /// alignment.add(fieldData);\n+                  }\n+                }\n \n-                                    //out.println(j-1+\"th concatenated=\"+concatenated);\n-                                    j = lastJ - 1;\n+              }\n \n-                                } // end-of-if: continuous-OBS only\n+            } else {\n+              // throw new IOException\n+            }\n+            /// dbgLog.fine(\"measurementLevel=\"+measurementLevel);\n+            /// dbgLog.fine(\"columnWidth=\"+columnWidth);\n+            /// dbgLog.fine(\"alignment=\"+alignment);\n+            dbgLog.fine(\"end of subType 11\\n\");\n \n-                            } // end of loop-j\n+            break;\n+          case 12:\n+            // Windows Data Entry GUID\n+            parseRT7SubTypefield(stream);\n+            break;\n+          case 13:\n+            // Extended variable names\n+            // parseRT7SubTypefield(stream);\n+            headerSection = parseRT7SubTypefieldHeader(stream);\n+\n+            if (headerSection != null) {\n+              int unitLength = headerSection[0];\n+              dbgLog.fine(\"RT7: unitLength=\" + unitLength);\n+              int numberOfUnits = headerSection[1];\n+              dbgLog.fine(\"RT7: numberOfUnits=\" + numberOfUnits);\n+              byte[] work = new byte[unitLength * numberOfUnits];\n+              int nbtyes13 = stream.read(work);\n+\n+              String[] variableShortLongNamePairs = new String(work, \"US-ASCII\").split(\"\\t\");\n+\n+              for (int i = 0; i < variableShortLongNamePairs.length; i++) {\n+                dbgLog.fine(\"RT7: \" + i + \"-th pair\" + variableShortLongNamePairs[i]);\n+                String[] pair = variableShortLongNamePairs[i].split(\"=\");\n+                shortToLongVariableNameTable.put(pair[0], pair[1]);\n+              }\n+\n+              dbgLog.fine(\"RT7: shortToLongVarialbeNameTable\" +\n+                shortToLongVariableNameTable);\n+              // We are saving the short-to-long name map; at the\n+              // end of ingest, we'll go through the data variables and\n+              // change the names accordingly.\n+\n+              // smd.setShortToLongVarialbeNameTable(shortToLongVarialbeNameTable);\n+            } else {\n+              // throw new IOException\n+            }\n \n-                            //out.println(\"removeJset=\"+removeJset);\n+            break;\n+          case 14:\n+            // Extended strings\n+            //parseRT7SubTypefield(stream);\n+            headerSection = parseRT7SubTypefieldHeader(stream);\n+\n+            if (headerSection != null) {\n+              int unitLength = headerSection[0];\n+              dbgLog.fine(\"RT7.14: unitLength=\" + unitLength);\n+              int numberOfUnits = headerSection[1];\n+              dbgLog.fine(\"RT7.14: numberOfUnits=\" + numberOfUnits);\n+              byte[] work = new byte[unitLength * numberOfUnits];\n+              int nbtyes13 = stream.read(work);\n+\n+              String[] extendedVariablesSizePairs = new String(work, defaultCharSet).split(\"\\000\\t\");\n+\n+              for (int i = 0; i < extendedVariablesSizePairs.length; i++) {\n+                dbgLog.fine(\"RT7.14: \" + i + \"-th pair\" + extendedVariablesSizePairs[i]);\n+                if (extendedVariablesSizePairs[i].indexOf(\"=\") > 0) {\n+                  String[] pair = extendedVariablesSizePairs[i].split(\"=\");\n+                  extendedVariablesSizeTable.put(pair[0], Integer.valueOf(pair[1]));\n+                }\n+              }\n \n-                            // a new list that stores a new case with concatanated string data\n-                            List<String> newDataLine = new ArrayList<String>();\n+              dbgLog.fine(\"RT7.14: extendedVariablesSizeTable\" +\n+                extendedVariablesSizeTable);\n+            } else {\n+              // throw new IOException\n+            }\n \n-                            for (int jl = 0; jl < casewiseRecordForTabFile.size(); jl++) {\n-                                //out.println(\"jl=\"+jl+\"-th datum =[\"+casewiseRecordForTabFile.get(jl)+\"]\");\n+            break;\n+          case 15:\n+            // Clementine Metadata\n+            parseRT7SubTypefield(stream);\n+            break;\n+          case 16:\n+            // 64 bit N of cases\n+            parseRT7SubTypefield(stream);\n+            break;\n+          case 17:\n+            // File level attributes\n+            parseRT7SubTypefield(stream);\n+            break;\n+          case 18:\n+            // Variable attributes\n+            parseRT7SubTypefield(stream);\n+            break;\n+          case 19:\n+            // Extended multiple response groups\n+            parseRT7SubTypefield(stream);\n+            break;\n+          case 20:\n+            // Character encoding, aka code page.\n+            // Must be a version 16+ feature (?).\n+            // Starting v.16, the default character encoding for SAV\n+            // files is UTF-8; but then it is possible to specify an\n+            // alternative encoding here.\n+            // A typical use case would be people setting it to \"ISO-Latin\"\n+            // or \"windows-1252\", or a similar 8-bit encoding to store\n+            // text with standard Western European accents.\n+            // -- L.A.\n+\n+            headerSection = parseRT7SubTypefieldHeader(stream);\n+\n+            if (headerSection != null) {\n+              int unitLength = headerSection[0];\n+              dbgLog.fine(\"RT7-20: unitLength=\" + unitLength);\n+              int numberOfUnits = headerSection[1];\n+              dbgLog.fine(\"RT7-20: numberOfUnits=\" + numberOfUnits);\n+              byte[] rt7st20bytes = new byte[unitLength * numberOfUnits];\n+              int nbytes20 = stream.read(rt7st20bytes);\n+\n+              String dataCharSet = new String(rt7st20bytes, \"US-ASCII\");\n+\n+              if (dataCharSet != null && !(dataCharSet.equals(\"\"))) {\n+                dbgLog.fine(\"RT7-20: data charset: \" + dataCharSet);\n+                defaultCharSet = dataCharSet;\n+              }\n+            } /*else {\n+                        // TODO:\n+                        // decide if the exception should actually be thrown here!\n+                        // -- L.A. 4.0 beta\n+                        // throw new IOException\n+                    }*/\n \n-                                if (!removeJset.contains(jl)) {\n+\n+            break;\n+          case 21:\n+            // Value labels for long strings\n+            parseRT7SubTypefield(stream);\n+            break;\n+          case 22:\n+            // Missing values for long strings\n+            parseRT7SubTypefield(stream);\n+            break;\n+          default:\n+            parseRT7SubTypefield(stream);\n+        }\n+\n+      } catch (IOException ex) {\n+        //ex.printStackTrace();\n+        throw ex;\n+      }\n+\n+      counter++;\n+\n+      if (counter > 20) {\n+        break;\n+      }\n+    }\n+\n+    dbgLog.fine(\"RT7: counter=\" + counter);\n+    dbgLog.fine(\"RT7: decodeRecordType7(): end\");\n+  }\n+\n+\n+  void decodeRecordType999(BufferedInputStream stream) throws IOException {\n+    dbgLog.fine(\"decodeRecordType999(): start\");\n+    try {\n+      if (stream == null) {\n+        throw new IllegalArgumentException(\"RT999: stream == null!\");\n+      }\n+      // first check the 4-byte header value\n+      //if (stream.markSupported()){\n+      stream.mark(1000);\n+      //}\n+      // 999.0 check the first 4 bytes\n+      byte[] headerCodeRt999 = new byte[LENGTH_RECORD_TYPE999_CODE];\n+\n+      //dbgLog.fine(\"RT999: stream position=\"+stream.pos);\n+\n+      int nbytes_rt999 = stream.read(headerCodeRt999, 0,\n+        LENGTH_RECORD_TYPE999_CODE);\n+      // to-do check against nbytes\n+      //printHexDump(headerCodeRt999, \"RT999 header test\");\n+      ByteBuffer bb_header_code_rt999 = ByteBuffer.wrap(headerCodeRt999,\n+        0, LENGTH_RECORD_TYPE999_CODE);\n+      if (isLittleEndian) {\n+        bb_header_code_rt999.order(ByteOrder.LITTLE_ENDIAN);\n+      }\n+\n+      int intRT999test = bb_header_code_rt999.getInt();\n+      dbgLog.fine(\"header test value: RT999=\" + intRT999test);\n+      if (intRT999test != 999) {\n+        //if (stream.markSupported()){\n+        dbgLog.fine(\"intRT999test failed=\" + intRT999test);\n+        stream.reset();\n+        throw new IOException(\"RT999:Header value(999) was not correctly detected:\" + intRT999test);\n+        //}\n+      }\n+\n+\n+      // 999.1 check 4-byte integer Filler block\n+\n+      byte[] length_filler = new byte[LENGTH_RT999_FILLER];\n+\n+      int nbytes_rt999_1 = stream.read(length_filler, 0,\n+        LENGTH_RT999_FILLER);\n+      // to-do check against nbytes\n+\n+      //printHexDump(length_how_many_line_bytes, \"RT999 how_many_line_bytes\");\n+      ByteBuffer bb_filler = ByteBuffer.wrap(length_filler,\n+        0, LENGTH_RT999_FILLER);\n+      if (isLittleEndian) {\n+        bb_filler.order(ByteOrder.LITTLE_ENDIAN);\n+      }\n+\n+      int rt999filler = bb_filler.getInt();\n+      dbgLog.fine(\"rt999filler=\" + rt999filler);\n+\n+      if (rt999filler == 0) {\n+        dbgLog.fine(\"the end of the dictionary section\");\n+      } else {\n+        throw new IOException(\"RT999: failed to detect the end mark(0): value=\" + rt999filler);\n+      }\n+\n+      // missing value processing concerning HIGHEST/LOWEST values\n+\n+      Set<Map.Entry<String, InvalidData>> msvlc = invalidDataTable.entrySet();\n+      for (Iterator<Map.Entry<String, InvalidData>> itc = msvlc.iterator(); itc.hasNext(); ) {\n+        Map.Entry<String, InvalidData> et = itc.next();\n+        String variable = et.getKey();\n+        dbgLog.fine(\"variable=\" + variable);\n+        InvalidData invalidDataInfo = et.getValue();\n+\n+        if (invalidDataInfo.getInvalidRange() != null &&\n+          !invalidDataInfo.getInvalidRange().isEmpty()) {\n+          if (invalidDataInfo.getInvalidRange().get(0).equals(OBSTypeHexValue.get(\"LOWEST\"))) {\n+            dbgLog.fine(\"1st value is LOWEST\");\n+            invalidDataInfo.getInvalidRange().set(0, \"LOWEST\");\n+          } else if (invalidDataInfo.getInvalidRange().get(1).equals(OBSTypeHexValue.get(\"HIGHEST\"))) {\n+            dbgLog.fine(\"2nd value is HIGHEST\");\n+            invalidDataInfo.getInvalidRange().set(1, \"HIGHEST\");\n+          }\n+        }\n+      }\n+      dbgLog.fine(\"invalidDataTable:\\n\" + invalidDataTable);\n+      // TODO: take care of the invalid data! - add the appropriate\n+      // value labels (?)\n+      // should it be done here, or at the end of ingest?\n+      // -- L.A. 4.0 alpha\n+      ///smd.setInvalidDataTable(invalidDataTable);\n+    } catch (IOException ex) {\n+      //ex.printStackTrace();\n+      //exit(1);\n+      throw ex;\n+    }\n+\n+    dbgLog.fine(\"decodeRecordType999(): end\");\n+  }\n+\n+\n+  void decodeRecordTypeData(BufferedInputStream stream) throws IOException {\n+    dbgLog.fine(\"decodeRecordTypeData(): start\");\n+\n+    ///String fileUnfValue = null;\n+    ///String[] unfValues = null;\n+\n+\n+    if (stream == null) {\n+      throw new IllegalArgumentException(\"stream == null!\");\n+    }\n+    if (isDataSectionCompressed) {\n+      decodeRecordTypeDataCompressed(stream);\n+    } else {\n+      decodeRecordTypeDataUnCompressed(stream);\n+    }\n+\n+    /* UNF calculation was here... */\n+\n+    dbgLog.fine(\"***** decodeRecordTypeData(): end *****\");\n+  }\n+\n+  PrintWriter createOutputWriter(BufferedInputStream stream) throws IOException {\n+    PrintWriter pwout = null;\n+    FileOutputStream fileOutTab = null;\n+\n+    try {\n+\n+      // create a File object to save the tab-delimited data file\n+      File tabDelimitedDataFile = File.createTempFile(\"tempTabfile.\", \".tab\");\n+\n+      String tabDelimitedDataFileName = tabDelimitedDataFile.getAbsolutePath();\n+\n+      // save the temp file name in the metadata object\n+      ///smd.getFileInformation().put(\"tabDelimitedDataFileLocation\", tabDelimitedDataFileName);\n+      ingesteddata.setTabDelimitedFile(tabDelimitedDataFile);\n+\n+      fileOutTab = new FileOutputStream(tabDelimitedDataFile);\n+\n+      pwout = new PrintWriter(new OutputStreamWriter(fileOutTab, \"utf8\"), true);\n+\n+    } catch (FileNotFoundException ex) {\n+      ex.printStackTrace();\n+    } catch (UnsupportedEncodingException ex) {\n+      ex.printStackTrace();\n+    } catch (IOException ex) {\n+      //ex.printStackTrace();\n+      throw ex;\n+    }\n+\n+    return pwout;\n+\n+  }\n+\n+  void decodeRecordTypeDataCompressed(BufferedInputStream stream) throws IOException {\n+\n+    dbgLog.fine(\"***** decodeRecordTypeDataCompressed(): start *****\");\n+\n+    if (stream == null) {\n+      throw new IllegalArgumentException(\"decodeRecordTypeDataCompressed: stream == null!\");\n+    }\n+\n+    PrintWriter pwout = createOutputWriter(stream);\n+\n+    int varQnty = dataTable.getVarQuantity().intValue();\n+    int caseQnty = dataTable.getCaseQuantity().intValue();\n+\n+    dbgLog.fine(\"varQnty: \" + varQnty);\n+\n+    dateFormatList = new String[varQnty];\n+\n+    boolean hasStringVarContinuousBlock =\n+      obsNonVariableBlockSet.size() > 0 ? true : false;\n+    dbgLog.fine(\"hasStringVarContinuousBlock=\" + hasStringVarContinuousBlock);\n+\n+    int ii = 0;\n+\n+    int OBS = LENGTH_SAV_OBS_BLOCK;\n+    int nOBS = OBSUnitsPerCase;\n+\n+    dbgLog.fine(\"OBSUnitsPerCase=\" + OBSUnitsPerCase);\n+\n+    int caseIndex = 0;\n+\n+    dbgLog.fine(\"printFormatTable:\\n\" + printFormatTable);\n+    variableFormatTypeList = new String[varQnty];\n+\n+\n+    for (int i = 0; i < varQnty; i++) {\n+      variableFormatTypeList[i] = SPSSConstants.FORMAT_CATEGORY_TABLE.get(\n+        printFormatTable.get(variableNameList.get(i)));\n+      dbgLog.fine(\"i=\" + i + \"th variableFormatTypeList=\" + variableFormatTypeList[i]);\n+      formatCategoryTable.put(variableNameList.get(i), variableFormatTypeList[i]);\n+    }\n+    dbgLog.fine(\"variableFormatType:\\n\" + Arrays.deepToString(variableFormatTypeList));\n+    dbgLog.fine(\"formatCategoryTable:\\n\" + formatCategoryTable);\n+\n+    // TODO:\n+    // Make sure the date formats are actually preserved!\n+    // (this is something that was collected in the code below and passed\n+    // to the UNF calculator).\n+    // -- L.A. 4.0 alpha\n+    List<String> casewiseRecordForTabFile = new ArrayList<String>();\n+\n+    try {\n+      // this compression is applied only to non-float data, i.e. integer;\n+      // 8-byte float datum is kept in tact\n+      boolean hasReachedEOF = false;\n+\n+      OBSERVATION:\n+      while (true) {\n+\n+        dbgLog.fine(\"SAV Reader: compressed: ii=\" + ii + \"-th iteration\");\n+\n+        byte[] octate = new byte[LENGTH_SAV_OBS_BLOCK];\n+\n+        int nbytes = stream.read(octate);\n+\n+        // processCompressedOBSblock ()\n+\n+        // (this means process a block of 8 compressed OBS\n+        // values -- should result in 64 bytes of data total)\n+\n+        for (int i = 0; i < LENGTH_SAV_OBS_BLOCK; i++) {\n+\n+\n+          dbgLog.finer(\"i=\" + i + \"-th iteration\");\n+          int octate_i = octate[i];\n+          //dbgLog.fine(\"octate=\"+octate_i);\n+          if (octate_i < 0) {\n+            octate_i += 256;\n+          }\n+          int byteCode = octate_i;//octate_i & 0xF;\n+          //out.println(\"byeCode=\"+byteCode);\n+\n+          // processCompressedOBS\n+\n+          switch (byteCode) {\n+            case 252:\n+              // end of the file\n+              dbgLog.fine(\"SAV Reader: compressed: end of file mark [FC] was found\");\n+              hasReachedEOF = true;\n+              break;\n+            case 253:\n+              // FD: uncompressed data follows after this octate\n+              // long string datum or float datum\n+              // read the following octate\n+              byte[] uncompressedByte = new byte[LENGTH_SAV_OBS_BLOCK];\n+              int ucbytes = stream.read(uncompressedByte);\n+              int typeIndex = (ii * OBS + i) % nOBS;\n+\n+              if ((OBSwiseTypelList.get(typeIndex) > 0) ||\n+                (OBSwiseTypelList.get(typeIndex) == -1)) {\n+                // code= >0 |-1: string or its conitiguous block\n+                // decode as a string object\n+                String strdatum = new String(\n+                  Arrays.copyOfRange(uncompressedByte,\n+                    0, LENGTH_SAV_OBS_BLOCK), defaultCharSet);\n+                //out.println(\"str_datum=\"+strdatum+\"<-\");\n+                // add this non-missing-value string datum\n+                casewiseRecordForTabFile.add(strdatum);\n+                //out.println(\"casewiseRecordForTabFile(String)=\"+casewiseRecordForTabFile);\n+              } else if (OBSwiseTypelList.get(typeIndex) == -2) {\n+                String strdatum = new String(\n+                  Arrays.copyOfRange(uncompressedByte,\n+                    0, LENGTH_SAV_OBS_BLOCK - 1), defaultCharSet);\n+                casewiseRecordForTabFile.add(strdatum);\n+                //out.println(\"casewiseRecordForTabFile(String)=\"+casewiseRecordForTabFile);\n+              } else if (OBSwiseTypelList.get(typeIndex) == 0) {\n+                // code= 0: numeric\n+\n+                ByteBuffer bb_double = ByteBuffer.wrap(\n+                  uncompressedByte, 0, LENGTH_SAV_OBS_BLOCK);\n+                if (isLittleEndian) {\n+                  bb_double.order(ByteOrder.LITTLE_ENDIAN);\n+                }\n+\n+                Double ddatum = bb_double.getDouble();\n+                // out.println(\"ddatum=\"+ddatum);\n+                // add this non-missing-value numeric datum\n+                casewiseRecordForTabFile.add(doubleNumberFormatter.format(ddatum));\n+                dbgLog.fine(\"SAV Reader: compressed: added value to dataLine: \" + ddatum);\n+\n+              } else {\n+                dbgLog.fine(\"SAV Reader: out-of-range exception\");\n+                throw new IOException(\"out-of-range value was found\");\n+              }\n+\n+                            /*\n+                            // EOF-check after reading this octate\n+                            if (stream.available() == 0){\n+                            hasReachedEOF = true;\n+                            dbgLog.fine(\n+                            \"SAV Reader: *** After reading an uncompressed octate,\" +\n+                            \" reached the end of the file at \"+ii\n+                            +\"th iteration and i=\"+i+\"th octate position [0-start] *****\");\n+                            }\n+                             */\n+\n+\n+              break;\n+            case 254:\n+              // FE: used as the missing value for string variables\n+              // an empty case in a string variable also takes this value\n+              // string variable does not accept space-only data\n+              // cf: uncompressed case\n+              // 20 20 20 20 20 20 20 20\n+              // add the string missing value\n+              // out.println(\"254: String missing data\");\n+\n+              casewiseRecordForTabFile.add(\" \");  // add \".\" here?\n+\n+\n+              // Note that technically this byte flag (254/xFE) means\n+              // that *eight* white space characters should be\n+              // written to the output stream. This caused me\n+              // a great amount of confusion, because it appeared\n+              // to me that there was a mismatch between the number\n+              // of bytes advertised in the variable metadata and\n+              // the number of bytes actually found in the data\n+              // section of a compressed SAV file; this is because\n+              // these 8 bytes \"come out of nowhere\"; they are not\n+              // written in the data section, but this flag specifies\n+              // that they should be added to the output.\n+              // Also, as I pointed out above, we are only writing\n+              // out one whitespace character, not 8 as instructed.\n+              // This appears to be legit; these blocks of 8 spaces\n+              // seem to be only used for padding, and all such\n+              // multiple padding spaces are stripped anyway during\n+              // the post-processing.\n+\n+\n+              break;\n+            case 255:\n+              // FF: system missing value for numeric variables\n+              // cf: uncompressed case (sysmis)\n+              // FF FF FF FF FF FF eF FF(little endian)\n+              // add the numeric missing value\n+              dbgLog.fine(\"SAV Reader: compressed: Missing Value, numeric\");\n+              casewiseRecordForTabFile.add(MissingValueForTextDataFileNumeric);\n+\n+              break;\n+            case 0:\n+              // 00: do nothing\n+              dbgLog.fine(\"SAV Reader: compressed: doing nothing (zero); \");\n+\n+              break;\n+            default:\n+              //out.println(\"byte code(default)=\"+ byteCode);\n+              if ((byteCode > 0) && (byteCode < 252)) {\n+                // datum is compressed\n+                //Integer unCompressed = Integer.valueOf(byteCode -100);\n+                // add this uncompressed numeric datum\n+                Double unCompressed = Double.valueOf(byteCode - 100);\n+                dbgLog.fine(\"SAV Reader: compressed: default case: \" + unCompressed);\n+\n+                casewiseRecordForTabFile.add(doubleNumberFormatter.format(unCompressed));\n+                // out.println(\"uncompressed=\"+unCompressed);\n+                // out.println(\"dataline=\"+casewiseRecordForTabFile);\n+              }\n+          }// end of switch\n+\n+          // out.println(\"end of switch\");\n+\n+\n+          // The-end-of-a-case(row)-processing\n+\n+          // this line that follows, and the code around it\n+          // is really confusing:\n+          int varCounter = (ii * OBS + i + 1) % nOBS;\n+          // while both OBS and LENGTH_SAV_OBS_BLOCK = 8\n+          // (OBS was initialized as OBS=LENGTH_SAV_OBS_BLOCK),\n+          // the 2 values mean different things:\n+          // LENGTH_SAV_OBS_BLOCK is the number of bytes in one OBS;\n+          // and OBS is the number of OBS blocks that we process\n+          // at a time. I.e., we process 8 chunks of 8 bytes at a time.\n+          // This is how data is organized inside an SAV file:\n+          // 8 bytes of compression flags, followd by 8x8 or fewer\n+          // (depending on the flags) bytes of compressed data.\n+          // I should rename this OBS variable something more\n+          // meaningful.\n+          //\n+          // Also, the \"varCounter\" variable name is entirely\n+          // misleading -- it counts not variables, but OBS blocks.\n+\n+          dbgLog.fine(\"SAV Reader: compressed: OBS counter=\" + varCounter + \"(ii=\" + ii + \")\");\n+\n+          if ((ii * OBS + i + 1) % nOBS == 0) {\n+\n+            //out.println(\"casewiseRecordForTabFile(before)=\"+casewiseRecordForTabFile);\n+\n+            // out.println(\"all variables in a case are parsed == nOBS\");\n+            // out.println(\"hasStringVarContinuousBlock=\"+hasStringVarContinuousBlock);\n+\n+            // check whether a string-variable's continuous block exits\n+            // if so, they must be joined\n+\n+            if (hasStringVarContinuousBlock) {\n+\n+              // string-variable's continuous-block-concatenating-processing\n+\n+              //out.println(\"concatenating process starts\");\n+              //out.println(\"casewiseRecordForTabFile(before)=\"+casewiseRecordForTabFile);\n+              //out.println(\"casewiseRecordForTabFile(before:size)=\"+casewiseRecordForTabFile.size());\n+\n+              StringBuilder sb = new StringBuilder(\"\");\n+              int firstPosition = 0;\n+\n+              Set<Integer> removeJset = new HashSet<Integer>();\n+              for (int j = 0; j < nOBS; j++) {\n+                dbgLog.fine(\"RTD: j=\" + j + \"-th type =\" + OBSwiseTypelList.get(j));\n+                if ((OBSwiseTypelList.get(j) == -1) ||\n+                  (OBSwiseTypelList.get(j) == -2)) {\n+                  // Continued String variable found at j-th\n+                  // position. look back the j-1\n+                  firstPosition = j - 1;\n+                  int lastJ = j;\n+                  String concatenated = null;\n+\n+                  removeJset.add(j);\n+                  sb.append(casewiseRecordForTabFile.get(j - 1));\n+                  sb.append(casewiseRecordForTabFile.get(j));\n+\n+                  for (int jc = 1; ; jc++) {\n+                    if ((j + jc == nOBS)\n+                      || ((OBSwiseTypelList.get(j + jc) != -1)\n+                      && (OBSwiseTypelList.get(j + jc) != -2))) {\n+\n+                      // j is the end unit of this string variable\n+                      concatenated = sb.toString();\n+                      sb.setLength(0);\n+                      lastJ = j + jc;\n+                      break;\n+                    } else {\n+                      sb.append(casewiseRecordForTabFile.get(j + jc));\n+                      removeJset.add(j + jc);\n+                    }\n+                  }\n+                  casewiseRecordForTabFile.set(j - 1, concatenated);\n+\n+                  //out.println(j-1+\"th concatenated=\"+concatenated);\n+                  j = lastJ - 1;\n+\n+                } // end-of-if: continuous-OBS only\n+\n+              } // end of loop-j\n+\n+              //out.println(\"removeJset=\"+removeJset);\n+\n+              // a new list that stores a new case with concatanated string data\n+              List<String> newDataLine = new ArrayList<String>();\n+\n+              for (int jl = 0; jl < casewiseRecordForTabFile.size(); jl++) {\n+                //out.println(\"jl=\"+jl+\"-th datum =[\"+casewiseRecordForTabFile.get(jl)+\"]\");\n+\n+                if (!removeJset.contains(jl)) {\n \n //                                if (casewiseRecordForTabFile.get(jl).equals(MissingValueForTextDataFileString)){\n //                                    out.println(\"NA-S jl= \"+jl+\"=[\"+casewiseRecordForTabFile.get(jl)+\"]\");\n@@ -2680,966 +2678,980 @@ public class SAVFileReader  extends TabularDataFileReader{\n //                                    out.println(\"space jl= \"+jl+\"=[\"+casewiseRecordForTabFile.get(jl)+\"]\");\n //                                }\n \n-                                    newDataLine.add(casewiseRecordForTabFile.get(jl));\n-                                } else {\n+                  newDataLine.add(casewiseRecordForTabFile.get(jl));\n+                } else {\n //                                out.println(\"Excluded: jl=\"+jl+\"-th datum=[\"+casewiseRecordForTabFile.get(jl)+\"]\");\n-                                }\n-                            }  // end of loop-jl\n-\n-                            //out.println(\"new casewiseRecordForTabFile=\"+newDataLine);\n-                            //out.println(\"new casewiseRecordForTabFile(size)=\"+newDataLine.size());\n-\n-                            casewiseRecordForTabFile = newDataLine;\n-\n-                        } // end-if: stringContinuousVar-exist case\n-\n-                        // caseIndex starts from 1 not 0\n-                        caseIndex = (ii * OBS + i + 1) / nOBS;\n-\n-                        for (int k = 0; k < casewiseRecordForTabFile.size(); k++) {\n-\n-                            dbgLog.fine(\"k=\" + k + \"-th variableTypelList=\" + variableTypelList.get(k));\n-\n-                            if (variableTypelList.get(k) > 0) {\n-\n-                                // Strip the String variables off the\n-                                // whitespace padding:\n-\n-                                // [ snipped ]\n-\n-                                // I've removed the block of code above where\n-                                // String values were substring()-ed to the\n-                                // length specified in the variable metadata;\n-                                // Doing that was not enough, since a string\n-                                // can still be space-padded inside its\n-                                // advertised capacity. (note that extended\n-                                // variables can have many kylobytes of such\n-                                // padding in them!) Plus it was completely\n-                                // redundant, since we are stripping all the\n-                                // trailing white spaces with\n-                                // StringUtils.stripEnd() below:\n-\n-\n-                                String paddRemoved = StringUtils.stripEnd(casewiseRecordForTabFile.get(k).toString(), null);\n-                                // TODO: clean this up.  For now, just make sure that strings contain at least one blank space.\n-                                if (paddRemoved.equals(\"\")) {\n-                                    paddRemoved = \" \";\n-                                }\n-                                //casewiseRecordForTabFile.set(k, \"\\\"\" + paddRemoved.replaceAll(\"\\\"\", Matcher.quoteReplacement(\"\\\\\\\"\")) + \"\\\"\");\n-                                casewiseRecordForTabFile.set(k, escapeCharacterString(paddRemoved));\n-\n-                            // end of String var case\n-\n-                            } // end of variable-type check\n-\n-                            if (casewiseRecordForTabFile.get(k) != null && !casewiseRecordForTabFile.get(k).equals(MissingValueForTextDataFileNumeric)) {\n-\t\t\t\t\n-                                String variableFormatType = variableFormatTypeList[k];\n-                                dbgLog.finer(\"k=\" + k + \"th printFormatTable format=\" + printFormatTable.get(variableNameList.get(k)));\n-\n-                                int formatDecimalPointPosition = formatDecimalPointPositionList.get(k);\n-\t\t\t\t\n-\n-                                if (variableFormatType.equals(\"date\")) {\n-                                    dbgLog.finer(\"date case\");\n-\n-                                    long dateDatum = Long.parseLong(casewiseRecordForTabFile.get(k).toString()) * 1000L - SPSS_DATE_OFFSET;\n-\n-                                    String newDatum = sdf_ymd.format(new Date(dateDatum));\n-                                    dbgLog.finer(\"k=\" + k + \":\" + newDatum);\n-                                    /* saving date format */\n-                                    dbgLog.finer(\"saving dateFormat[k] = \" + sdf_ymd.toPattern());\n-                                    casewiseRecordForTabFile.set(k, newDatum);\n-                                    dateFormatList[k] = sdf_ymd.toPattern();\n-                                //formatCategoryTable.put(variableNameList.get(k), \"date\");\n-                                } else if (variableFormatType.equals(\"time\")) {\n-                                    dbgLog.finer(\"time case:DTIME or DATETIME or TIME\");\n-                                    //formatCategoryTable.put(variableNameList.get(k), \"time\");\n-\n-                                    if (printFormatTable.get(variableNameList.get(k)).equals(\"DTIME\")) {\n-                                        // We're not even going to try to handle \"DTIME\"\n-                                        // values as time/dates in dataverse; this is a weird\n-                                        // format that nobody uses outside of SPSS.\n-                                        // (but we do need to remember to treat the resulting values \n-                                        // as character strings, not numerics!)\n-                                        \n-                                        if (casewiseRecordForTabFile.get(k).toString().indexOf(\".\") < 0) {\n-                                            long dateDatum = Long.parseLong(casewiseRecordForTabFile.get(k).toString()) * 1000L - SPSS_DATE_BIAS;\n-                                            String newDatum = sdf_dhms.format(new Date(dateDatum));\n-                                            dbgLog.finer(\"k=\" + k + \":\" + newDatum);\n-                                            casewiseRecordForTabFile.set(k, newDatum);\n-                                        } else {\n-                                            // decimal point included\n-                                            String[] timeData = casewiseRecordForTabFile.get(k).toString().split(\"\\\\.\");\n-\n-                                            dbgLog.finer(StringUtils.join(timeData, \"|\"));\n-                                            long dateDatum = Long.parseLong(timeData[0]) * 1000L - SPSS_DATE_BIAS;\n-                                            StringBuilder sb_time = new StringBuilder(\n-                                                    sdf_dhms.format(new Date(dateDatum)));\n-                                            dbgLog.finer(sb_time.toString());\n-\n-                                            if (formatDecimalPointPosition > 0) {\n-                                                sb_time.append(\".\" + timeData[1].substring(0, formatDecimalPointPosition));\n-                                            }\n-\n-                                            dbgLog.finer(\"k=\" + k + \":\" + sb_time.toString());\n-                                            casewiseRecordForTabFile.set(k, sb_time.toString());\n-                                        }\n-                                    } else if (printFormatTable.get(variableNameList.get(k)).equals(\"DATETIME\")) {\n-                                        // TODO: \n-                                        // (for both datetime and \"dateless\" time)\n-                                        // keep the longest of the matching formats - i.e., if there are *some*\n-                                        // values in the vector that have thousands of a second, that should be \n-                                        // part of the saved format!\n-                                        //  -- L.A. Aug. 12 2014 \n-                                        if (casewiseRecordForTabFile.get(k).toString().indexOf(\".\") < 0) {\n-                                            long dateDatum = Long.parseLong(casewiseRecordForTabFile.get(k).toString()) * 1000L - SPSS_DATE_OFFSET;\n-                                            String newDatum = sdf_ymdhms.format(new Date(dateDatum));\n-                                            dbgLog.finer(\"k=\" + k + \":\" + newDatum);\n-                                            casewiseRecordForTabFile.set(k, newDatum);\n-                                            dateFormatList[k] = sdf_ymdhms.toPattern();\n-                                        } else {\n-                                            // decimal point included\n-                                            String[] timeData = casewiseRecordForTabFile.get(k).toString().split(\"\\\\.\");\n-\n-                                            //dbgLog.finer(StringUtils.join(timeData, \"|\"));\n-                                            long dateDatum = Long.parseLong(timeData[0]) * 1000L - SPSS_DATE_OFFSET;\n-                                            StringBuilder sb_time = new StringBuilder(\n-                                                    sdf_ymdhms.format(new Date(dateDatum)));\n-                                            //dbgLog.finer(sb_time.toString());\n-\n-                                            if (formatDecimalPointPosition > 0) {\n-                                                sb_time.append(\".\" + timeData[1].substring(0, formatDecimalPointPosition));\n-                                            }\n-                                            dbgLog.finer(\"k=\" + k + \":\" + sb_time.toString());\n-                                            casewiseRecordForTabFile.set(k, sb_time.toString());\n-                                            dateFormatList[k] = sdf_ymdhms.toPattern() + (formatDecimalPointPosition > 0 ? \".S\" : \"\" );\n-                                        }\n-                                    } else if (printFormatTable.get(variableNameList.get(k)).equals(\"TIME\")) {\n-                                        // TODO: \n-                                        // double-check that we are handling \"dateless\" time correctly... -- L.A. Aug. 2014\n-                                        if (casewiseRecordForTabFile.get(k).toString().indexOf(\".\") < 0) {\n-                                            long dateDatum = Long.parseLong(casewiseRecordForTabFile.get(k).toString()) * 1000L;\n-                                            String newDatum = sdf_hms.format(new Date(dateDatum));\n-                                            dbgLog.finer(\"k=\" + k + \":\" + newDatum);\n-                                            casewiseRecordForTabFile.set(k, newDatum);\n-                                            if (dateFormatList[k] == null) {\n-                                                dateFormatList[k] = sdf_hms.toPattern();\n-                                            }\n-                                        } else {\n-                                            // decimal point included\n-                                            String[] timeData = casewiseRecordForTabFile.get(k).toString().split(\"\\\\.\");\n-\n-                                            //dbgLog.finer(StringUtils.join(timeData, \"|\"));\n-                                            long dateDatum = Long.parseLong(timeData[0]) * 1000L;\n-                                            StringBuilder sb_time = new StringBuilder(\n-                                                    sdf_hms.format(new Date(dateDatum)));\n-                                            //dbgLog.finer(sb_time.toString());\n-\n-                                            if (formatDecimalPointPosition > 0) {\n-                                                sb_time.append(\".\" + timeData[1].substring(0, formatDecimalPointPosition));\n-                                            }\n-                                            dbgLog.finer(\"k=\" + k + \":\" + sb_time.toString());\n-                                            casewiseRecordForTabFile.set(k, sb_time.toString());\n-                                            \n-                                            String format_hmsS = sdf_hms.toPattern() + (formatDecimalPointPosition > 0 ? \".S\" : \"\");\n-                                            if (dateFormatList[k] == null || (format_hmsS.length() > dateFormatList[k].length())) {\n-                                                dateFormatList[k] = format_hmsS;\n-                                            }\n-                                        }\n-                                    }\n-\t\t\t\t    \n-                                } else if (variableFormatType.equals(\"other\")) {\n-                                    dbgLog.finer(\"other non-date/time case:=\" + i);\n-\n-                                    if (printFormatTable.get(variableNameList.get(k)).equals(\"WKDAY\")) {\n-                                        // day of week\n-                                        dbgLog.finer(\"data k=\" + k + \":\" + casewiseRecordForTabFile.get(k));\n-                                        dbgLog.finer(\"data k=\" + k + \":\" + SPSSConstants.WEEKDAY_LIST.get(Integer.valueOf(casewiseRecordForTabFile.get(k).toString()) - 1));\n-                                        String newDatum = SPSSConstants.WEEKDAY_LIST.get(Integer.valueOf(casewiseRecordForTabFile.get(k).toString()) - 1);\n-                                        casewiseRecordForTabFile.set(k, newDatum);\n-                                        dbgLog.finer(\"wkday:k=\" + k + \":\" + casewiseRecordForTabFile.get(k));\n-                                    } else if (printFormatTable.get(variableNameList.get(k)).equals(\"MONTH\")) {\n-                                        // month\n-                                        dbgLog.finer(\"data k=\" + k + \":\" + casewiseRecordForTabFile.get(k));\n-                                        dbgLog.finer(\"data k=\" + k + \":\" + SPSSConstants.MONTH_LIST.get(Integer.valueOf(casewiseRecordForTabFile.get(k).toString()) - 1));\n-                                        String newDatum = SPSSConstants.MONTH_LIST.get(Integer.valueOf(casewiseRecordForTabFile.get(k).toString()) - 1);\n-                                        casewiseRecordForTabFile.set(k, newDatum);\n-                                        dbgLog.finer(\"month:k=\" + k + \":\" + casewiseRecordForTabFile.get(k));\n-                                    }\n-                                }\n-\t\t\t\t\n-\t\t\t\t\n-                            } // end: date-time-datum check\n-\n-\n-                        } // end: loop-k(2nd: variable-wise-check)\n-\n-\n-                        // write to tab file\n-                        if (casewiseRecordForTabFile.size() > 0) {\n-                            pwout.println(StringUtils.join(casewiseRecordForTabFile, \"\\t\"));\n-                        }\n-\n-                        // numeric contents-check\n-                        for (int l = 0; l < casewiseRecordForTabFile.size(); l++) {\n-                            if (variableFormatTypeList[l].equals(\"date\")\n-                                    || variableFormatTypeList[l].equals(\"time\")\n-                                    || printFormatTable.get(variableNameList.get(l)).equals(\"WKDAY\")\n-                                    || printFormatTable.get(variableNameList.get(l)).equals(\"MONTH\")) {\n-                                // TODO: \n-                                // figure out if any special handling is still needed here in 4.0. \n-                                // -- L.A. - Aug. 2014\n-\n-                            } else {\n-                                if (variableTypelList.get(l) <= 0) {\n-                                    if (casewiseRecordForTabFile.get(l).toString().indexOf(\".\") >= 0) {\n-                                        decimalVariableSet.add(l);\n-                                    }\n-                                }\n-                            }\n-                        }\n+                }\n+              }  // end of loop-jl\n+\n+              //out.println(\"new casewiseRecordForTabFile=\"+newDataLine);\n+              //out.println(\"new casewiseRecordForTabFile(size)=\"+newDataLine.size());\n+\n+              casewiseRecordForTabFile = newDataLine;\n+\n+            } // end-if: stringContinuousVar-exist case\n \n-                        // reset the case-wise working objects\n-\t\t\tcasewiseRecordForTabFile.clear();\n+            // caseIndex starts from 1 not 0\n+            caseIndex = (ii * OBS + i + 1) / nOBS;\n \n-\t\t\tif ( caseQnty > 0 ) {\n-\t\t\t    if ( caseIndex == caseQnty ) {\n-\t\t\t\thasReachedEOF = true; \n-\t\t\t    }\n-\t\t\t}\n+            for (int k = 0; k < casewiseRecordForTabFile.size(); k++) {\n \n- \t\t\tif (hasReachedEOF){\n-                            break;\n-                        }\n+              dbgLog.fine(\"k=\" + k + \"-th variableTypelList=\" + variableTypelList.get(k));\n \n-                    } // if(The-end-of-a-case(row)-processing)\n+              if (variableTypelList.get(k) > 0) {\n \n-                } // loop-i (OBS unit)\n+                // Strip the String variables off the\n+                // whitespace padding:\n \n-                if ((hasReachedEOF) || (stream.available() == 0)) {\n-                    // reached the end of this file\n-                    // do exit-processing\n+                // [ snipped ]\n \n-                    dbgLog.fine(\"***** reached the end of the file at \" + ii + \"th iteration *****\");\n+                // I've removed the block of code above where\n+                // String values were substring()-ed to the\n+                // length specified in the variable metadata;\n+                // Doing that was not enough, since a string\n+                // can still be space-padded inside its\n+                // advertised capacity. (note that extended\n+                // variables can have many kylobytes of such\n+                // padding in them!) Plus it was completely\n+                // redundant, since we are stripping all the\n+                // trailing white spaces with\n+                // StringUtils.stripEnd() below:\n \n-                    break OBSERVATION;\n+\n+                String paddRemoved = StringUtils.stripEnd(casewiseRecordForTabFile.get(k).toString(), null);\n+                // TODO: clean this up.  For now, just make sure that strings contain at least one blank space.\n+                if (paddRemoved.equals(\"\")) {\n+                  paddRemoved = \" \";\n                 }\n-\t\t\n-                ii++;\n+                //casewiseRecordForTabFile.set(k, \"\\\"\" + paddRemoved.replaceAll(\"\\\"\", Matcher.quoteReplacement(\"\\\\\\\"\")) + \"\\\"\");\n+                casewiseRecordForTabFile.set(k, escapeCharacterString(paddRemoved));\n \n-            } // while loop\n+                // end of String var case\n \n-            pwout.close();\n-        } catch (IOException ex) {\n-            throw ex;\n-        }\n-\t\n-\t\n-        dbgLog.fine(\"<<<<<<\");\n-        dbgLog.fine(\"formatCategoryTable = \" + formatCategoryTable);\n-        dbgLog.fine(\">>>>>>\");\n+              } // end of variable-type check\n \n+              if (casewiseRecordForTabFile.get(k) != null &&\n+                !casewiseRecordForTabFile.get(k).equals(MissingValueForTextDataFileNumeric)) {\n \n-        dbgLog.fine(\"decimalVariableSet=\" + decimalVariableSet);\n+                String variableFormatType = variableFormatTypeList[k];\n+                dbgLog.finer(\"k=\" + k + \"th printFormatTable format=\" + printFormatTable.get(variableNameList.get(k)));\n \n-        dbgLog.fine(\"decodeRecordTypeDataCompressed(): end\");\n-    }\n+                int formatDecimalPointPosition = formatDecimalPointPositionList.get(k);\n \n \n-    void decodeRecordTypeDataUnCompressed(BufferedInputStream stream) throws IOException {\n-        dbgLog.fine(\"***** decodeRecordTypeDataUnCompressed(): start *****\");\n+                if (variableFormatType.equals(\"date\")) {\n+                  dbgLog.finer(\"date case\");\n \n-        if (stream ==null){\n-            throw new IllegalArgumentException(\"decodeRecordTypeDataUnCompressed: stream == null!\");\n-        }\n+                  long dateDatum =\n+                    Long.parseLong(casewiseRecordForTabFile.get(k).toString()) * 1000L - SPSS_DATE_OFFSET;\n \n-        int varQnty = dataTable.getVarQuantity().intValue();\n-        \n-\n-        // \n-        // set-up tab file\n-        \n-        PrintWriter pwout = createOutputWriter ( stream ); \n-        \n-        boolean hasStringVarContinuousBlock = \n-            obsNonVariableBlockSet.size() > 0 ? true : false;\n-        dbgLog.fine(\"hasStringVarContinuousBlock=\"+hasStringVarContinuousBlock);\n-        \n-        int ii = 0;\n-        \n-        int OBS = LENGTH_SAV_OBS_BLOCK;\n-        int nOBS = OBSUnitsPerCase;\n-        \n-        dbgLog.fine(\"OBSUnitsPerCase=\"+OBSUnitsPerCase);\n-        \n-        int caseIndex = 0;\n-        \n-        dbgLog.fine(\"printFormatTable:\\n\"+printFormatTable);\n-\n-        variableFormatTypeList = new String[varQnty];\n-        dateFormatList = new String[varQnty];\n-\n-        for (int i = 0; i < varQnty; i++){\n-            variableFormatTypeList[i]=SPSSConstants.FORMAT_CATEGORY_TABLE.get(\n-\t\t\t\t\t\t\t\t\t      printFormatTable.get(variableNameList.get(i)));\n-            dbgLog.fine(\"i=\"+i+\"th variableFormatTypeList=\"+variableFormatTypeList[i]);\n-            formatCategoryTable.put(variableNameList.get(i), variableFormatTypeList[i]);\n-        }\n-        dbgLog.fine(\"variableFormatType:\\n\"+Arrays.deepToString(variableFormatTypeList));\n-        dbgLog.fine(\"formatCategoryTable:\\n\"+formatCategoryTable);\n-\n-        int numberOfDecimalVariables = 0;\n-        \n-        // TODO: \n-        // Make sure the date formats are actually preserved! \n-        // (this is something that was collected in the code below and passed\n-        // to the UNF calculator). \n-        // -- L.A. 4.0 alpha\n-        \n-        List<String> casewiseRecordForTabFile = new ArrayList<String>();\n-        \n-        \n-        // missing values are written to the tab-delimited file by\n-        // using the default or user-specified missing-value  strings;\n-        // however, to calculate UNF/summary statistics,\n-        // classes for these calculations require their specific \n-        // missing values that differ from the above missing-value\n-        // strings; therefore, after row data for the tab-delimited \n-        // file are written, missing values in a row are changed to\n-        // UNF/summary-statistics-OK ones.\n-\n-        // data-storage object for sumStat\n-        ///dataTable2 = new Object[varQnty][caseQnty];\n-\t// storage of date formats to pass to UNF\t\n-        ///dateFormats = new String[varQnty][caseQnty];\n-\n-        try {\n-            for (int i = 0; ; i++){  // case-wise loop\n-                \n-                byte[] buffer = new byte[OBS*nOBS];\n-                \n-                int nbytesuc =  stream.read(buffer);\n-                \n-                StringBuilder sb_stringStorage = new StringBuilder(\"\");\n-\n-                for (int k=0; k < nOBS; k++){\n-                    int offset= OBS*k;\n-\n-                    // uncompressed case\n-                    // numeric missing value == sysmis\n-                    // FF FF FF FF FF FF eF FF(little endian)\n-                    // string missing value\n-                    // 20 20 20 20 20 20 20 20\n-                    // cf: compressed case \n-                    // numeric type:sysmis == 0xFF\n-                    // string type: missing value == 0xFE\n-                    // \n-\n-                    boolean isNumeric = OBSwiseTypelList.get(k)==0 ? true : false;\n-                    \n-                    if (isNumeric){\n-                        dbgLog.finer(k+\"-th variable is numeric\");\n-                        // interprete as double\n-                        ByteBuffer bb_double = ByteBuffer.wrap(\n-                            buffer, offset , LENGTH_SAV_OBS_BLOCK);\n-                        if (isLittleEndian){\n-                            bb_double.order(ByteOrder.LITTLE_ENDIAN);\n-                        }\n-                        //char[] hexpattern =\n-                        String dphex = new String(Hex.encodeHex(\n-                                Arrays.copyOfRange(bb_double.array(),\n-                                offset, offset+LENGTH_SAV_OBS_BLOCK)));\n-                        dbgLog.finer(\"dphex=\"+ dphex);\n-                            \n-                        if ((dphex.equals(\"ffffffffffffefff\"))||\n-                            (dphex.equals(\"ffefffffffffffff\"))){\n-                            //casewiseRecordForTabFile.add(systemMissingValue);\n-                            // add the numeric missing value\n-\t\t\t    dbgLog.fine(\"SAV Reader: adding: Missing Value (numeric)\");\n-                            casewiseRecordForTabFile.add(MissingValueForTextDataFileNumeric);\n-                        } else {\n-                            Double ddatum  = bb_double.getDouble();\n-                            dbgLog.fine(\"SAV Reader: adding: ddatum=\"+ddatum);\n-\n-                            // add this non-missing-value numeric datum\n-                            casewiseRecordForTabFile.add(doubleNumberFormatter.format(ddatum)) ;\n-                        }\n-                    \n+                  String newDatum = sdf_ymd.format(new Date(dateDatum));\n+                  dbgLog.finer(\"k=\" + k + \":\" + newDatum);\n+                  /* saving date format */\n+                  dbgLog.finer(\"saving dateFormat[k] = \" + sdf_ymd.toPattern());\n+                  casewiseRecordForTabFile.set(k, newDatum);\n+                  dateFormatList[k] = sdf_ymd.toPattern();\n+                  //formatCategoryTable.put(variableNameList.get(k), \"date\");\n+                } else if (variableFormatType.equals(\"time\")) {\n+                  dbgLog.finer(\"time case:DTIME or DATETIME or TIME\");\n+                  //formatCategoryTable.put(variableNameList.get(k), \"time\");\n+\n+                  if (printFormatTable.get(variableNameList.get(k)).equals(\"DTIME\")) {\n+                    // We're not even going to try to handle \"DTIME\"\n+                    // values as time/dates in dataverse; this is a weird\n+                    // format that nobody uses outside of SPSS.\n+                    // (but we do need to remember to treat the resulting values\n+                    // as character strings, not numerics!)\n+\n+                    if (casewiseRecordForTabFile.get(k).toString().indexOf(\".\") < 0) {\n+                      long dateDatum =\n+                        Long.parseLong(casewiseRecordForTabFile.get(k).toString()) * 1000L - SPSS_DATE_BIAS;\n+                      String newDatum = sdf_dhms.format(new Date(dateDatum));\n+                      dbgLog.finer(\"k=\" + k + \":\" + newDatum);\n+                      casewiseRecordForTabFile.set(k, newDatum);\n                     } else {\n-                        dbgLog.finer(k+\"-th variable is string\");\n-                        // string case\n-                        // strip space-padding\n-                        // do not trim: string might have spaces within it\n-                        // the missing value (hex) for a string variable is:\n-                        // \"20 20 20 20 20 20 20 20\"\n-                        \n-                        \n-                        String strdatum = new String(\n-                            Arrays.copyOfRange(buffer,\n-                            offset, (offset+LENGTH_SAV_OBS_BLOCK)),defaultCharSet);\n-                        dbgLog.finer(\"str_datum=\"+strdatum);\n-                        // add this non-missing-value string datum \n-                        casewiseRecordForTabFile.add(strdatum);\n-\n-                    } // if isNumeric\n-                \n-                } // k-loop\n-\n-                // String-variable's continuous block exits:\n-                if (hasStringVarContinuousBlock){\n-\t\t    // continuous blocks: string case\n-\t\t    // concatenating process\n-                    //dbgLog.fine(\"concatenating process starts\");\n-\n-                    //dbgLog.fine(\"casewiseRecordForTabFile(before)=\"+casewiseRecordForTabFile);\n-                    //dbgLog.fine(\"casewiseRecordForTabFile(before:size)=\"+casewiseRecordForTabFile.size());\n-\n-                    StringBuilder sb = new StringBuilder(\"\");\n-                    int firstPosition = 0;\n-\n-                    Set<Integer> removeJset = new HashSet<Integer>();\n-                    for (int j=0; j< nOBS; j++){\n-                        dbgLog.finer(\"j=\"+j+\"-th type =\"+OBSwiseTypelList.get(j));\n-                        if (OBSwiseTypelList.get(j) == -1){\n-                            // String continued fount at j-th \n-                            // look back the j-1 \n-                            firstPosition = j-1;\n-                            int lastJ = j;\n-                            String concatanated = null;\n-\n-                            removeJset.add(j);\n-                            sb.append(casewiseRecordForTabFile.get(j-1));\n-                            sb.append(casewiseRecordForTabFile.get(j));\n-                            for (int jc =1; ; jc++ ){\n-                                if (OBSwiseTypelList.get(j+jc) != -1){\n-                                // j is the end unit of this string variable\n-                                    concatanated = sb.toString();\n-                                    sb.setLength(0);\n-                                   lastJ = j+jc;\n-                                   break;\n-                                } else {\n-                                    sb.append(casewiseRecordForTabFile.get(j+jc));\n-                                    removeJset.add(j+jc);\n-                                }\n-                            }\n-                            casewiseRecordForTabFile.set(j-1, concatanated); \n-\n-                            //out.println(j-1+\"th concatanated=\"+concatanated);\n-                            j = lastJ -1; \n-\n-                        } // end-of-if: continuous-OBS only\n-                    } // end of loop-j\n-\n-                    List<String> newDataLine = new ArrayList<String>();\n-                    \n-                    for (int jl=0; jl<casewiseRecordForTabFile.size();jl++){\n-                        //out.println(\"jl=\"+jl+\"-th datum =[\"+casewiseRecordForTabFile.get(jl)+\"]\");\n-                        \n-                        if (!removeJset.contains(jl) ){\n-                            newDataLine.add(casewiseRecordForTabFile.get(jl));\n-                        } \n-                    }\n+                      // decimal point included\n+                      String[] timeData = casewiseRecordForTabFile.get(k).toString().split(\"\\\\.\");\n \n-                    dbgLog.fine(\"new casewiseRecordForTabFile=\"+newDataLine);\n-                    dbgLog.fine(\"new casewiseRecordForTabFile(size)=\"+newDataLine.size());\n-                    \n-                    casewiseRecordForTabFile = newDataLine;\n-\n-                } // end-if: stringContinuousVar-exist case\n-\n-                caseIndex++;\n-                dbgLog.finer(\"caseIndex=\"+caseIndex);\n-                for (int k = 0; k < casewiseRecordForTabFile.size(); k++){\n-\n-                    if (variableTypelList.get(k) > 0) {\n-\n-\t\t\t// See my comments for this padding removal logic\n-\t\t\t// in the \"compressed\" method -- L.A.\n-\n-\t\t\tString paddRemoved = StringUtils.stripEnd(casewiseRecordForTabFile.get(k).toString(), null);\n-\t\t\t// TODO: clean this up.  For now, just make sure that strings contain at least one blank space.\n-\t\t\tif (paddRemoved.equals(\"\")) {\n-\t\t\t    paddRemoved = \" \";\n-\t\t\t}\n-\n-\t\t\t//casewiseRecordForTabFile.set(k, \"\\\"\" + paddRemoved.replaceAll(\"\\\"\", Matcher.quoteReplacement(\"\\\\\\\"\")) + \"\\\"\");\n-                        casewiseRecordForTabFile.set(k, escapeCharacterString(paddRemoved));\n-\t\t\t\n-\t\t\t// end of String var case\n-\n-                    } // end of variable-type check\n-                    \n-                    if (casewiseRecordForTabFile.get(k)!=null && !casewiseRecordForTabFile.get(k).equals(MissingValueForTextDataFileNumeric)){\n-                        \n-                        // to do date conversion\n-                        String variableFormatType =  variableFormatTypeList[k];\n-                        dbgLog.finer(\"k=\"+k+\"th variable format=\"+variableFormatType);\n-\n-                        int formatDecimalPointPosition = formatDecimalPointPositionList.get(k);\n-\n-                        if (variableFormatType.equals(\"date\")){\n-                            dbgLog.finer(\"date case\");\n-\n-                            long dateDatum = Long.parseLong(casewiseRecordForTabFile.get(k).toString())*1000L- SPSS_DATE_OFFSET;\n-\n-                            String newDatum = sdf_ymd.format(new Date(dateDatum));\n-                            dbgLog.finer(\"k=\"+k+\":\"+newDatum);\n-\n-                            casewiseRecordForTabFile.set(k, newDatum);\n-                            dateFormatList[k] = sdf_ymd.toPattern();\n-                        } else if (variableFormatType.equals(\"time\")) {\n-                            dbgLog.finer(\"time case:DTIME or DATETIME or TIME\");\n-                            //formatCategoryTable.put(variableNameList.get(k), \"time\");\n-                            // not treating DTIME as date/time; see comment elsewhere in \n-                            // the code; \n-                            // (but we do need to remember to treat the resulting values \n-                            // as character strings, not numerics!)\n-                            \n-                            if (printFormatTable.get(variableNameList.get(k)).equals(\"DTIME\")){\n-\n-                                if (casewiseRecordForTabFile.get(k).toString().indexOf(\".\") < 0){\n-                                    long dateDatum  = Long.parseLong(casewiseRecordForTabFile.get(k).toString())*1000L - SPSS_DATE_BIAS;\n-                                    String newDatum = sdf_dhms.format(new Date(dateDatum));\n-                                    // Note: DTIME is not a complete date, so we don't save a date format with it\n-                                    dbgLog.finer(\"k=\"+k+\":\"+newDatum);\n-                                    casewiseRecordForTabFile.set(k, newDatum);\n-                                } else {\n-                                    // decimal point included\n-                                    String[] timeData = casewiseRecordForTabFile.get(k).toString().split(\"\\\\.\");\n-\n-                                    dbgLog.finer(StringUtils.join(timeData, \"|\"));\n-                                    long dateDatum = Long.parseLong(timeData[0])*1000L - SPSS_DATE_BIAS;\n-                                    StringBuilder sb_time = new StringBuilder(\n-                                        sdf_dhms.format(new Date(dateDatum)));\n-                                    \n-                                    if (formatDecimalPointPosition > 0){\n-                                        sb_time.append(\".\"+timeData[1].substring(0,formatDecimalPointPosition));\n-                                    }\n-                                    \n-                                    \n-                                    dbgLog.finer(\"k=\"+k+\":\"+sb_time.toString());\n-                                    casewiseRecordForTabFile.set(k, sb_time.toString());\n-                                }\n-                            } else if (printFormatTable.get(variableNameList.get(k)).equals(\"DATETIME\")){\n-                                // TODO: \n-                                // (for both datetime and \"dateless\" time)\n-                                // keep the longest of the matching formats - i.e., if there are *some*\n-                                // values in the vector that have thousands of a second, that should be \n-                                // part of the saved format!\n-                                //  -- L.A. Aug. 12 2014 \n-\n-                                if (casewiseRecordForTabFile.get(k).toString().indexOf(\".\") < 0){\n-                                    long dateDatum  = Long.parseLong(casewiseRecordForTabFile.get(k).toString())*1000L - SPSS_DATE_OFFSET;\n-                                    String newDatum = sdf_ymdhms.format(new Date(dateDatum));\n-                                    dbgLog.finer(\"k=\"+k+\":\"+newDatum);\n-                                    casewiseRecordForTabFile.set(k, newDatum);\n-                                    dateFormatList[k] = sdf_ymdhms.toPattern();\n-                                } else {\n-                                    // decimal point included\n-                                    String[] timeData = casewiseRecordForTabFile.get(k).toString().split(\"\\\\.\");\n-\n-                                    //dbgLog.finer(StringUtils.join(timeData, \"|\"));\n-                                    long dateDatum = Long.parseLong(timeData[0])*1000L- SPSS_DATE_OFFSET;\n-                                    StringBuilder sb_time = new StringBuilder(\n-                                        sdf_ymdhms.format(new Date(dateDatum)));\n-                                    //dbgLog.finer(sb_time.toString());\n-                                    \n-                                    if (formatDecimalPointPosition > 0){\n-                                        sb_time.append(\".\"+timeData[1].substring(0,formatDecimalPointPosition));\n-                                    }\n-                                    dbgLog.finer(\"k=\"+k+\":\"+sb_time.toString());\n-                                    casewiseRecordForTabFile.set(k, sb_time.toString());\n-                                    // datetime with milliseconds:\n-                                    dateFormatList[k] = sdf_ymdhms.toPattern() + (formatDecimalPointPosition > 0 ? \".S\" : \"\" );\n-                                }\n-                            } else if (printFormatTable.get(variableNameList.get(k)).equals(\"TIME\")){\n-                                if (casewiseRecordForTabFile.get(k).toString().indexOf(\".\") < 0){\n-                                    long dateDatum = Long.parseLong(casewiseRecordForTabFile.get(k).toString())*1000L;\n-                                    String newDatum = sdf_hms.format(new Date(dateDatum));\n-                                    dbgLog.finer(\"k=\"+k+\":\"+newDatum);\n-                                    casewiseRecordForTabFile.set(k, newDatum);\n-                                    if (dateFormatList[k] == null) {\n-                                        dateFormatList[k] = sdf_hms.toPattern();\n-                                    }\n-                                } else {\n-                                    // decimal point included\n-                                    String[] timeData = casewiseRecordForTabFile.get(k).toString().split(\"\\\\.\");\n-\n-                                    //dbgLog.finer(StringUtils.join(timeData, \"|\"));\n-                                    long dateDatum = Long.parseLong(timeData[0])*1000L;\n-                                    StringBuilder sb_time = new StringBuilder(\n-                                        sdf_hms.format(new Date(dateDatum)));\n-                                    //dbgLog.finer(sb_time.toString());\n-                                    \n-                                    if (formatDecimalPointPosition > 0){\n-                                        sb_time.append(\".\"+timeData[1].substring(0,formatDecimalPointPosition));\n-                                    }\n-                                    dbgLog.finer(\"k=\"+k+\":\"+sb_time.toString());\n-                                    casewiseRecordForTabFile.set(k, sb_time.toString());\n-                                    // time, possibly with milliseconds:\n-                                    String format_hmsS = sdf_hms.toPattern() + (formatDecimalPointPosition > 0 ? \".S\" : \"\" );\n-                                    if (dateFormatList[k] == null || (format_hmsS.length() > dateFormatList[k].length())) {\n-                                        dateFormatList[k] = format_hmsS;\n-                                    }\n-                                }\n-                            }\n-                        } else if (variableFormatType.equals(\"other\")){\n-                            dbgLog.finer(\"other non-date/time case\");\n-\n-                            if (printFormatTable.get(variableNameList.get(k)).equals(\"WKDAY\")){\n-                                // day of week\n-                                dbgLog.finer(\"data k=\"+k+\":\"+casewiseRecordForTabFile.get(k));\n-                                dbgLog.finer(\"data k=\"+k+\":\"+SPSSConstants.WEEKDAY_LIST.get(Integer.valueOf(casewiseRecordForTabFile.get(k).toString())-1));\n-                                String newDatum = SPSSConstants.WEEKDAY_LIST.get(Integer.valueOf(casewiseRecordForTabFile.get(k).toString())-1);\n-                                casewiseRecordForTabFile.set(k, newDatum);\n-                                dbgLog.finer(\"wkday:k=\"+k+\":\"+casewiseRecordForTabFile.get(k));\n-                            } else if (printFormatTable.get(variableNameList.get(k)).equals(\"MONTH\")){\n-                                // month\n-                                dbgLog.finer(\"data k=\"+k+\":\"+casewiseRecordForTabFile.get(k));\n-                                dbgLog.finer(\"data k=\"+k+\":\"+SPSSConstants.MONTH_LIST.get(Integer.valueOf(casewiseRecordForTabFile.get(k).toString())-1));\n-                                String newDatum = SPSSConstants.MONTH_LIST.get(Integer.valueOf(casewiseRecordForTabFile.get(k).toString())-1);\n-                                casewiseRecordForTabFile.set(k, newDatum);\n-                                dbgLog.finer(\"month:k=\"+k+\":\"+casewiseRecordForTabFile.get(k));\n+                      dbgLog.finer(StringUtils.join(timeData, \"|\"));\n+                      long dateDatum = Long.parseLong(timeData[0]) * 1000L - SPSS_DATE_BIAS;\n+                      StringBuilder sb_time = new StringBuilder(\n+                        sdf_dhms.format(new Date(dateDatum)));\n+                      dbgLog.finer(sb_time.toString());\n \n-                            }\n-                        } \n-\t\t\t// end of date/time block\n-                    } // end: date-time-datum check\n-\n-                } // end: loop-k(2nd: variablte-wise-check)\n-\n-\t\t// write to tab file\n-\t\tif (casewiseRecordForTabFile.size() > 0) {\n-\t\t    pwout.println(StringUtils.join(casewiseRecordForTabFile, \"\\t\"));\n-\t\t}\n-\t\t\n-                // numeric contents-check\n-                for (int l = 0; l < casewiseRecordForTabFile.size(); l++){\n-                    if ( variableFormatTypeList[l].equals(\"date\") ||\n-                         variableFormatTypeList[l].equals(\"time\") ||\n-                         printFormatTable.get(variableNameList.get(l)).equals(\"WKDAY\") ||\n-                         printFormatTable.get(variableNameList.get(l)).equals(\"MONTH\") ) {\n-                        \n-                    } else { \n-                        if (variableTypelList.get(l) <= 0) {\n-                            if (casewiseRecordForTabFile.get(l).toString().indexOf(\".\") >= 0){\n-                                decimalVariableSet.add(l);\n-                            }\n-                        }\n+                      if (formatDecimalPointPosition > 0) {\n+                        sb_time.append(\".\" + timeData[1].substring(0, formatDecimalPointPosition));\n+                      }\n+\n+                      dbgLog.finer(\"k=\" + k + \":\" + sb_time.toString());\n+                      casewiseRecordForTabFile.set(k, sb_time.toString());\n+                    }\n+                  } else if (printFormatTable.get(variableNameList.get(k)).equals(\"DATETIME\")) {\n+                    // TODO:\n+                    // (for both datetime and \"dateless\" time)\n+                    // keep the longest of the matching formats - i.e., if there are *some*\n+                    // values in the vector that have thousands of a second, that should be\n+                    // part of the saved format!\n+                    //  -- L.A. Aug. 12 2014\n+                    if (casewiseRecordForTabFile.get(k).toString().indexOf(\".\") < 0) {\n+                      long dateDatum =\n+                        Long.parseLong(casewiseRecordForTabFile.get(k).toString()) * 1000L - SPSS_DATE_OFFSET;\n+                      String newDatum = sdf_ymdhms.format(new Date(dateDatum));\n+                      dbgLog.finer(\"k=\" + k + \":\" + newDatum);\n+                      casewiseRecordForTabFile.set(k, newDatum);\n+                      dateFormatList[k] = sdf_ymdhms.toPattern();\n+                    } else {\n+                      // decimal point included\n+                      String[] timeData = casewiseRecordForTabFile.get(k).toString().split(\"\\\\.\");\n+\n+                      //dbgLog.finer(StringUtils.join(timeData, \"|\"));\n+                      long dateDatum = Long.parseLong(timeData[0]) * 1000L - SPSS_DATE_OFFSET;\n+                      StringBuilder sb_time = new StringBuilder(\n+                        sdf_ymdhms.format(new Date(dateDatum)));\n+                      //dbgLog.finer(sb_time.toString());\n+\n+                      if (formatDecimalPointPosition > 0) {\n+                        sb_time.append(\".\" + timeData[1].substring(0, formatDecimalPointPosition));\n+                      }\n+                      dbgLog.finer(\"k=\" + k + \":\" + sb_time.toString());\n+                      casewiseRecordForTabFile.set(k, sb_time.toString());\n+                      dateFormatList[k] = sdf_ymdhms.toPattern() + (formatDecimalPointPosition > 0 ? \".S\" : \"\");\n+                    }\n+                  } else if (printFormatTable.get(variableNameList.get(k)).equals(\"TIME\")) {\n+                    // TODO:\n+                    // double-check that we are handling \"dateless\" time correctly... -- L.A. Aug. 2014\n+                    if (casewiseRecordForTabFile.get(k).toString().indexOf(\".\") < 0) {\n+                      long dateDatum = Long.parseLong(casewiseRecordForTabFile.get(k).toString()) * 1000L;\n+                      String newDatum = sdf_hms.format(new Date(dateDatum));\n+                      dbgLog.finer(\"k=\" + k + \":\" + newDatum);\n+                      casewiseRecordForTabFile.set(k, newDatum);\n+                      if (dateFormatList[k] == null) {\n+                        dateFormatList[k] = sdf_hms.toPattern();\n+                      }\n+                    } else {\n+                      // decimal point included\n+                      String[] timeData = casewiseRecordForTabFile.get(k).toString().split(\"\\\\.\");\n+\n+                      //dbgLog.finer(StringUtils.join(timeData, \"|\"));\n+                      long dateDatum = Long.parseLong(timeData[0]) * 1000L;\n+                      StringBuilder sb_time = new StringBuilder(\n+                        sdf_hms.format(new Date(dateDatum)));\n+                      //dbgLog.finer(sb_time.toString());\n+\n+                      if (formatDecimalPointPosition > 0) {\n+                        sb_time.append(\".\" + timeData[1].substring(0, formatDecimalPointPosition));\n+                      }\n+                      dbgLog.finer(\"k=\" + k + \":\" + sb_time.toString());\n+                      casewiseRecordForTabFile.set(k, sb_time.toString());\n+\n+                      String format_hmsS = sdf_hms.toPattern() + (formatDecimalPointPosition > 0 ? \".S\" : \"\");\n+                      if (dateFormatList[k] == null || (format_hmsS.length() > dateFormatList[k].length())) {\n+                        dateFormatList[k] = format_hmsS;\n+                      }\n                     }\n+                  }\n+\n+                } else if (variableFormatType.equals(\"other\")) {\n+                  dbgLog.finer(\"other non-date/time case:=\" + i);\n+\n+                  if (printFormatTable.get(variableNameList.get(k)).equals(\"WKDAY\")) {\n+                    // day of week\n+                    dbgLog.finer(\"data k=\" + k + \":\" + casewiseRecordForTabFile.get(k));\n+                    dbgLog.finer(\"data k=\" + k + \":\" +\n+                      SPSSConstants.WEEKDAY_LIST.get(Integer.valueOf(casewiseRecordForTabFile.get(k).toString()) - 1));\n+                    String newDatum =\n+                      SPSSConstants.WEEKDAY_LIST.get(Integer.valueOf(casewiseRecordForTabFile.get(k).toString()) - 1);\n+                    casewiseRecordForTabFile.set(k, newDatum);\n+                    dbgLog.finer(\"wkday:k=\" + k + \":\" + casewiseRecordForTabFile.get(k));\n+                  } else if (printFormatTable.get(variableNameList.get(k)).equals(\"MONTH\")) {\n+                    // month\n+                    dbgLog.finer(\"data k=\" + k + \":\" + casewiseRecordForTabFile.get(k));\n+                    dbgLog.finer(\"data k=\" + k + \":\" +\n+                      SPSSConstants.MONTH_LIST.get(Integer.valueOf(casewiseRecordForTabFile.get(k).toString()) - 1));\n+                    String newDatum =\n+                      SPSSConstants.MONTH_LIST.get(Integer.valueOf(casewiseRecordForTabFile.get(k).toString()) - 1);\n+                    casewiseRecordForTabFile.set(k, newDatum);\n+                    dbgLog.finer(\"month:k=\" + k + \":\" + casewiseRecordForTabFile.get(k));\n+                  }\n+                }\n+\n+\n+              } // end: date-time-datum check\n+\n+\n+            } // end: loop-k(2nd: variable-wise-check)\n+\n+\n+            // write to tab file\n+            if (casewiseRecordForTabFile.size() > 0) {\n+              pwout.println(StringUtils.join(casewiseRecordForTabFile, \"\\t\"));\n+            }\n+\n+            // numeric contents-check\n+            for (int l = 0; l < casewiseRecordForTabFile.size(); l++) {\n+              if (variableFormatTypeList[l].equals(\"date\")\n+                || variableFormatTypeList[l].equals(\"time\")\n+                || printFormatTable.get(variableNameList.get(l)).equals(\"WKDAY\")\n+                || printFormatTable.get(variableNameList.get(l)).equals(\"MONTH\")) {\n+                // TODO:\n+                // figure out if any special handling is still needed here in 4.0.\n+                // -- L.A. - Aug. 2014\n+\n+              } else {\n+                if (variableTypelList.get(l) <= 0) {\n+                  if (casewiseRecordForTabFile.get(l).toString().indexOf(\".\") >= 0) {\n+                    decimalVariableSet.add(l);\n+                  }\n                 }\n-                \n-                // reset the case-wise working objects\n-                casewiseRecordForTabFile.clear();\n-                \n-                if (stream.available() == 0){\n-                    // reached the end of this file\n-                    // do exit-processing\n-\n-                    dbgLog.fine(\"reached the end of the file at \"+ii\n-\t\t\t\t+\"th iteration\");\n-\n-                    break;\n-                } // if eof processing\n-            } //i-loop: case(row) iteration\n-\n-            // close the writer\n-            pwout.close();\n-            \n-\n-        } catch (IOException ex) {\n-\t    throw ex; \n+              }\n+            }\n+\n+            // reset the case-wise working objects\n+            casewiseRecordForTabFile.clear();\n+\n+            if (caseQnty > 0) {\n+              if (caseIndex == caseQnty) {\n+                hasReachedEOF = true;\n+              }\n+            }\n+\n+            if (hasReachedEOF) {\n+              break;\n+            }\n+\n+          } // if(The-end-of-a-case(row)-processing)\n+\n+        } // loop-i (OBS unit)\n+\n+        if ((hasReachedEOF) || (stream.available() == 0)) {\n+          // reached the end of this file\n+          // do exit-processing\n+\n+          dbgLog.fine(\"***** reached the end of the file at \" + ii + \"th iteration *****\");\n+\n+          break OBSERVATION;\n         }\n-        \n-        // contents check\n-        dbgLog.fine(\"numberOfDecimalVariables=\"+numberOfDecimalVariables);\n-        dbgLog.fine(\"decimalVariableSet=\"+decimalVariableSet);\n \n-        dbgLog.fine(\"***** decodeRecordTypeDataUnCompressed(): end *****\");\n+        ii++;\n+\n+      } // while loop\n+\n+      pwout.close();\n+    } catch (IOException ex) {\n+      throw ex;\n     }\n \n-    // Utility Methods  -----------------------------------------------------//\n \n-    private boolean variableNameIsAnIncrement (String varNameBase, String variableName){\n-\tif ( varNameBase == null ) {\n-\t    return false; \n-\t}\n+    dbgLog.fine(\"<<<<<<\");\n+    dbgLog.fine(\"formatCategoryTable = \" + formatCategoryTable);\n+    dbgLog.fine(\">>>>>>\");\n+\n+\n+    dbgLog.fine(\"decimalVariableSet=\" + decimalVariableSet);\n+\n+    dbgLog.fine(\"decodeRecordTypeDataCompressed(): end\");\n+  }\n+\n+\n+  void decodeRecordTypeDataUnCompressed(BufferedInputStream stream) throws IOException {\n+    dbgLog.fine(\"***** decodeRecordTypeDataUnCompressed(): start *****\");\n \n-\tif ( varNameBase.concat(\"0\").equals(variableName) ) {\n-\t    return true; \n-\t} \n-\t\n-\treturn false; \n+    if (stream == null) {\n+      throw new IllegalArgumentException(\"decodeRecordTypeDataUnCompressed: stream == null!\");\n     }\n \n-    private boolean variableNameIsAnIncrement (String varNameBase, String lastExtendedVariable, String currentVariable) {\n+    int varQnty = dataTable.getVarQuantity().intValue();\n \n-\tif ( varNameBase == null ||\n-\t     lastExtendedVariable == null || \n-\t     currentVariable == null ) {\n-\t    return false; \n-\t}\n \n-\tif ( varNameBase.length() >= lastExtendedVariable.length() ) {\n-\t    return false; \n-\t}\n+    //\n+    // set-up tab file\n \n-\tif ( varNameBase.length() >= currentVariable.length() ) {\n-\t    return false; \n-\t}\n+    PrintWriter pwout = createOutputWriter(stream);\n \n-\tif ( !(varNameBase.equals(currentVariable.substring(0,varNameBase.length()))) ) {\n-\t    return false; \n-\t}\n+    boolean hasStringVarContinuousBlock =\n+      obsNonVariableBlockSet.size() > 0 ? true : false;\n+    dbgLog.fine(\"hasStringVarContinuousBlock=\" + hasStringVarContinuousBlock);\n \n-\tString lastSuffix = lastExtendedVariable.substring(varNameBase.length()); \n-\tString currentSuffix = currentVariable.substring(varNameBase.length()); \n+    int ii = 0;\n \n-\tif ( currentSuffix.length() > 2 ) {\n-\t    return false; \n-\t}\n+    int OBS = LENGTH_SAV_OBS_BLOCK;\n+    int nOBS = OBSUnitsPerCase;\n \n-\t//if ( !currentSuffix.matches(\"^[0-9A-Z]*$\") ) {\n-\t//    return false; \n-\t//}\n+    dbgLog.fine(\"OBSUnitsPerCase=\" + OBSUnitsPerCase);\n \n-\treturn suffixIsAnIncrement (lastSuffix, currentSuffix); \n+    int caseIndex = 0;\n+\n+    dbgLog.fine(\"printFormatTable:\\n\" + printFormatTable);\n+\n+    variableFormatTypeList = new String[varQnty];\n+    dateFormatList = new String[varQnty];\n+\n+    for (int i = 0; i < varQnty; i++) {\n+      variableFormatTypeList[i] = SPSSConstants.FORMAT_CATEGORY_TABLE.get(\n+        printFormatTable.get(variableNameList.get(i)));\n+      dbgLog.fine(\"i=\" + i + \"th variableFormatTypeList=\" + variableFormatTypeList[i]);\n+      formatCategoryTable.put(variableNameList.get(i), variableFormatTypeList[i]);\n     }\n-\t\n+    dbgLog.fine(\"variableFormatType:\\n\" + Arrays.deepToString(variableFormatTypeList));\n+    dbgLog.fine(\"formatCategoryTable:\\n\" + formatCategoryTable);\n \n-    private boolean suffixIsAnIncrement ( String lastSuffix, String currentSuffix ) {\n-\t// Extended variable suffixes are base-36 number strings in the \n-\t// [0-9A-Z] alphabet. I.e. the incremental suffixes go from \n-\t// 0 to 9 to A to Z to 10 to 1Z ... etc. \n+    int numberOfDecimalVariables = 0;\n \n-\tint lastSuffixValue = intBase36 ( lastSuffix ); \n-\tint currentSuffixValue = intBase36 ( currentSuffix ); \n+    // TODO:\n+    // Make sure the date formats are actually preserved!\n+    // (this is something that was collected in the code below and passed\n+    // to the UNF calculator).\n+    // -- L.A. 4.0 alpha\n \n-\tif ( currentSuffixValue - lastSuffixValue > 0 ) {\n-\t    return true; \n-\t}\n+    List<String> casewiseRecordForTabFile = new ArrayList<String>();\n \n-\treturn false; \n-    }\n-\t\n-    private int intBase36 ( String stringBase36 ) {\n-\n-\t// integer value of a base-36 string in [0-9A-Z] alphabet;\n-\t// i.e. \"0\" = 0, \"9\" = 9, \"A\" = 10, \n-\t// \"Z\"  = 35, \"10\" = 36, \"1Z\" = 71 ...\n-\t\n-\tbyte[] stringBytes = stringBase36.getBytes(); \n-\n-\tint ret = 0; \n-\n-\tfor ( int i = 0; i < stringBytes.length; i++ ) {\n-\t    int value = 0; \n-\t    if (stringBytes[i] >= 48 && stringBytes[i] <= 57 ) {\n-\t\t// [0-9]\n-\t\tvalue = (int)stringBytes[i] - 48; \n-\t    } else if (stringBytes[i] >= 65 && stringBytes[i] <= 90 ) {\n-\t\t// [A-Z] \n-\t\tvalue = (int)stringBytes[i] - 55; \n-\t    }\n-\n-\t    ret = (ret * 36) + value;\n-\t}\n-\n-\treturn ret; \n-    }\n \n+    // missing values are written to the tab-delimited file by\n+    // using the default or user-specified missing-value  strings;\n+    // however, to calculate UNF/summary statistics,\n+    // classes for these calculations require their specific\n+    // missing values that differ from the above missing-value\n+    // strings; therefore, after row data for the tab-delimited\n+    // file are written, missing values in a row are changed to\n+    // UNF/summary-statistics-OK ones.\n \n-    private int getSAVintAdjustedBlockLength(int rawLength){\n-        int adjustedLength = rawLength;\n-        if ((rawLength%LENGTH_SAV_INT_BLOCK ) != 0){\n-            adjustedLength = \n-                LENGTH_SAV_INT_BLOCK*(rawLength/LENGTH_SAV_INT_BLOCK +1) ;\n-        }\n-        return adjustedLength;\n-    }\n-    \n-    private int getSAVobsAdjustedBlockLength(int rawLength){\n-        int adjustedLength = rawLength;\n-        if ((rawLength%LENGTH_SAV_OBS_BLOCK ) != 0){\n-            adjustedLength = \n-                LENGTH_SAV_OBS_BLOCK*(rawLength/LENGTH_SAV_OBS_BLOCK +1) ;\n-        }\n-        return adjustedLength;\n-    }\n-    \n-    \n-    private int[] parseRT7SubTypefieldHeader(BufferedInputStream stream) throws IOException {\n-        int length_unit_length = 4;\n-        int length_number_of_units = 4;\n-        int storage_size = length_unit_length + length_number_of_units;\n-        \n-        int[] headerSection = new int[2];\n-        \n-        byte[] byteStorage = new byte[storage_size];\n-\n-\ttry {\n-\t    int nbytes = stream.read(byteStorage);\n-\t    // to-do check against nbytes\n-\n-\t    //printHexDump(byteStorage, \"RT7:storage\");\n-\t    \n-\t    ByteBuffer bb_data_type = ByteBuffer.wrap(byteStorage,\n-\t\t\t\t\t\t      0, length_unit_length);\n-\t    if (isLittleEndian){\n-\t\tbb_data_type.order(ByteOrder.LITTLE_ENDIAN);\n-\t    }\n-\n-\t    int unitLength = bb_data_type.getInt();\n-\t    dbgLog.fine(\"parseRT7 SubTypefield: unitLength=\"+unitLength);\n-\t    \n-\t    ByteBuffer bb_number_of_units = ByteBuffer.wrap(byteStorage,\n-\t\t\t\t\t\t\t    length_unit_length, length_number_of_units);\n-\t    if (isLittleEndian){\n-\t\tbb_number_of_units.order(ByteOrder.LITTLE_ENDIAN);\n-\t    }\n-\n-\t    int numberOfUnits = bb_number_of_units.getInt();\n-\t    dbgLog.fine(\"parseRT7 SubTypefield: numberOfUnits=\"+numberOfUnits);\n-\t\n-\t    headerSection[0] = unitLength;\n-\t    headerSection[1] = numberOfUnits;\n-\t    return headerSection;\n-\t} catch (IOException ex) {\n-\t    throw ex;\n-\t}\n-    }\n-    \n-    // TODO: \n-    // rename this method \"skipRT7SubTypefield or parseAndSkip... \n-    // -- because that's what it really does. We only call it \n-    // on RT7 sub-fields that we don't know what to do with.\n-    // -- L.A. 4.0 beta\n-    private void parseRT7SubTypefield(BufferedInputStream stream) throws IOException {\n-        int length_unit_length = 4;\n-        int length_number_of_units = 4;\n-        int storage_size = length_unit_length + length_number_of_units;\n-        \n-        int[] headerSection = new int[2];\n-        \n-        byte[] byteStorage = new byte[storage_size];\n-\n-        try{\n-            int nbytes = stream.read(byteStorage);\n-            // to-do check against nbytes\n-\n-            //printHexDump(byteStorage, \"RT7:storage\");\n-\n-            ByteBuffer bb_data_type = ByteBuffer.wrap(byteStorage,\n-                       0, length_unit_length);\n-            if (isLittleEndian){\n-                bb_data_type.order(ByteOrder.LITTLE_ENDIAN);\n+    // data-storage object for sumStat\n+    ///dataTable2 = new Object[varQnty][caseQnty];\n+    // storage of date formats to pass to UNF\n+    ///dateFormats = new String[varQnty][caseQnty];\n+\n+    try {\n+      for (int i = 0; ; i++) {  // case-wise loop\n+\n+        byte[] buffer = new byte[OBS * nOBS];\n+\n+        int nbytesuc = stream.read(buffer);\n+\n+        StringBuilder sb_stringStorage = new StringBuilder(\"\");\n+\n+        for (int k = 0; k < nOBS; k++) {\n+          int offset = OBS * k;\n+\n+          // uncompressed case\n+          // numeric missing value == sysmis\n+          // FF FF FF FF FF FF eF FF(little endian)\n+          // string missing value\n+          // 20 20 20 20 20 20 20 20\n+          // cf: compressed case\n+          // numeric type:sysmis == 0xFF\n+          // string type: missing value == 0xFE\n+          //\n+\n+          boolean isNumeric = OBSwiseTypelList.get(k) == 0 ? true : false;\n+\n+          if (isNumeric) {\n+            dbgLog.finer(k + \"-th variable is numeric\");\n+            // interprete as double\n+            ByteBuffer bb_double = ByteBuffer.wrap(\n+              buffer, offset, LENGTH_SAV_OBS_BLOCK);\n+            if (isLittleEndian) {\n+              bb_double.order(ByteOrder.LITTLE_ENDIAN);\n+            }\n+            //char[] hexpattern =\n+            String dphex = new String(Hex.encodeHex(\n+              Arrays.copyOfRange(bb_double.array(),\n+                offset, offset + LENGTH_SAV_OBS_BLOCK)));\n+            dbgLog.finer(\"dphex=\" + dphex);\n+\n+            if ((dphex.equals(\"ffffffffffffefff\")) ||\n+              (dphex.equals(\"ffefffffffffffff\"))) {\n+              //casewiseRecordForTabFile.add(systemMissingValue);\n+              // add the numeric missing value\n+              dbgLog.fine(\"SAV Reader: adding: Missing Value (numeric)\");\n+              casewiseRecordForTabFile.add(MissingValueForTextDataFileNumeric);\n+            } else {\n+              Double ddatum = bb_double.getDouble();\n+              dbgLog.fine(\"SAV Reader: adding: ddatum=\" + ddatum);\n+\n+              // add this non-missing-value numeric datum\n+              casewiseRecordForTabFile.add(doubleNumberFormatter.format(ddatum));\n             }\n \n-            int unitLength = bb_data_type.getInt();\n-            dbgLog.fine(\"parseRT7 SubTypefield: unitLength=\"+unitLength);\n+          } else {\n+            dbgLog.finer(k + \"-th variable is string\");\n+            // string case\n+            // strip space-padding\n+            // do not trim: string might have spaces within it\n+            // the missing value (hex) for a string variable is:\n+            // \"20 20 20 20 20 20 20 20\"\n+\n+\n+            String strdatum = new String(\n+              Arrays.copyOfRange(buffer,\n+                offset, (offset + LENGTH_SAV_OBS_BLOCK)), defaultCharSet);\n+            dbgLog.finer(\"str_datum=\" + strdatum);\n+            // add this non-missing-value string datum\n+            casewiseRecordForTabFile.add(strdatum);\n+\n+          } // if isNumeric\n+\n+        } // k-loop\n+\n+        // String-variable's continuous block exits:\n+        if (hasStringVarContinuousBlock) {\n+          // continuous blocks: string case\n+          // concatenating process\n+          //dbgLog.fine(\"concatenating process starts\");\n+\n+          //dbgLog.fine(\"casewiseRecordForTabFile(before)=\"+casewiseRecordForTabFile);\n+          //dbgLog.fine(\"casewiseRecordForTabFile(before:size)=\"+casewiseRecordForTabFile.size());\n+\n+          StringBuilder sb = new StringBuilder(\"\");\n+          int firstPosition = 0;\n+\n+          Set<Integer> removeJset = new HashSet<Integer>();\n+          for (int j = 0; j < nOBS; j++) {\n+            dbgLog.finer(\"j=\" + j + \"-th type =\" + OBSwiseTypelList.get(j));\n+            if (OBSwiseTypelList.get(j) == -1) {\n+              // String continued fount at j-th\n+              // look back the j-1\n+              firstPosition = j - 1;\n+              int lastJ = j;\n+              String concatanated = null;\n+\n+              removeJset.add(j);\n+              sb.append(casewiseRecordForTabFile.get(j - 1));\n+              sb.append(casewiseRecordForTabFile.get(j));\n+              for (int jc = 1; ; jc++) {\n+                if (OBSwiseTypelList.get(j + jc) != -1) {\n+                  // j is the end unit of this string variable\n+                  concatanated = sb.toString();\n+                  sb.setLength(0);\n+                  lastJ = j + jc;\n+                  break;\n+                } else {\n+                  sb.append(casewiseRecordForTabFile.get(j + jc));\n+                  removeJset.add(j + jc);\n+                }\n+              }\n+              casewiseRecordForTabFile.set(j - 1, concatanated);\n+\n+              //out.println(j-1+\"th concatanated=\"+concatanated);\n+              j = lastJ - 1;\n+\n+            } // end-of-if: continuous-OBS only\n+          } // end of loop-j\n \n-            ByteBuffer bb_number_of_units = ByteBuffer.wrap(byteStorage,\n-                       length_unit_length, length_number_of_units);\n-            if (isLittleEndian){\n-                bb_number_of_units.order(ByteOrder.LITTLE_ENDIAN);\n+          List<String> newDataLine = new ArrayList<String>();\n+\n+          for (int jl = 0; jl < casewiseRecordForTabFile.size(); jl++) {\n+            //out.println(\"jl=\"+jl+\"-th datum =[\"+casewiseRecordForTabFile.get(jl)+\"]\");\n+\n+            if (!removeJset.contains(jl)) {\n+              newDataLine.add(casewiseRecordForTabFile.get(jl));\n             }\n+          }\n \n-            int numberOfUnits = bb_number_of_units.getInt();\n-            dbgLog.fine(\"parseRT7 SubTypefield: numberOfUnits=\"+numberOfUnits);\n+          dbgLog.fine(\"new casewiseRecordForTabFile=\" + newDataLine);\n+          dbgLog.fine(\"new casewiseRecordForTabFile(size)=\" + newDataLine.size());\n \n-            headerSection[0] = unitLength;\n-            headerSection[1] = numberOfUnits;\n-            \n-            for (int i=0; i<numberOfUnits; i++){\n-                byte[] work = new byte[unitLength];\n-                \n-                int nb = stream.read(work);\n-                dbgLog.finer(\"raw bytes in Hex:\"+ new String(Hex.encodeHex(work)));\n-                ByteBuffer bb_field = ByteBuffer.wrap(work);\n-                if (isLittleEndian){\n-                    bb_field.order(ByteOrder.LITTLE_ENDIAN);\n+          casewiseRecordForTabFile = newDataLine;\n+\n+        } // end-if: stringContinuousVar-exist case\n+\n+        caseIndex++;\n+        dbgLog.finer(\"caseIndex=\" + caseIndex);\n+        for (int k = 0; k < casewiseRecordForTabFile.size(); k++) {\n+\n+          if (variableTypelList.get(k) > 0) {\n+\n+            // See my comments for this padding removal logic\n+            // in the \"compressed\" method -- L.A.\n+\n+            String paddRemoved = StringUtils.stripEnd(casewiseRecordForTabFile.get(k).toString(), null);\n+            // TODO: clean this up.  For now, just make sure that strings contain at least one blank space.\n+            if (paddRemoved.equals(\"\")) {\n+              paddRemoved = \" \";\n+            }\n+\n+            //casewiseRecordForTabFile.set(k, \"\\\"\" + paddRemoved.replaceAll(\"\\\"\", Matcher.quoteReplacement(\"\\\\\\\"\")) + \"\\\"\");\n+            casewiseRecordForTabFile.set(k, escapeCharacterString(paddRemoved));\n+\n+            // end of String var case\n+\n+          } // end of variable-type check\n+\n+          if (casewiseRecordForTabFile.get(k) != null &&\n+            !casewiseRecordForTabFile.get(k).equals(MissingValueForTextDataFileNumeric)) {\n+\n+            // to do date conversion\n+            String variableFormatType = variableFormatTypeList[k];\n+            dbgLog.finer(\"k=\" + k + \"th variable format=\" + variableFormatType);\n+\n+            int formatDecimalPointPosition = formatDecimalPointPositionList.get(k);\n+\n+            if (variableFormatType.equals(\"date\")) {\n+              dbgLog.finer(\"date case\");\n+\n+              long dateDatum = Long.parseLong(casewiseRecordForTabFile.get(k).toString()) * 1000L - SPSS_DATE_OFFSET;\n+\n+              String newDatum = sdf_ymd.format(new Date(dateDatum));\n+              dbgLog.finer(\"k=\" + k + \":\" + newDatum);\n+\n+              casewiseRecordForTabFile.set(k, newDatum);\n+              dateFormatList[k] = sdf_ymd.toPattern();\n+            } else if (variableFormatType.equals(\"time\")) {\n+              dbgLog.finer(\"time case:DTIME or DATETIME or TIME\");\n+              //formatCategoryTable.put(variableNameList.get(k), \"time\");\n+              // not treating DTIME as date/time; see comment elsewhere in\n+              // the code;\n+              // (but we do need to remember to treat the resulting values\n+              // as character strings, not numerics!)\n+\n+              if (printFormatTable.get(variableNameList.get(k)).equals(\"DTIME\")) {\n+\n+                if (casewiseRecordForTabFile.get(k).toString().indexOf(\".\") < 0) {\n+                  long dateDatum = Long.parseLong(casewiseRecordForTabFile.get(k).toString()) * 1000L - SPSS_DATE_BIAS;\n+                  String newDatum = sdf_dhms.format(new Date(dateDatum));\n+                  // Note: DTIME is not a complete date, so we don't save a date format with it\n+                  dbgLog.finer(\"k=\" + k + \":\" + newDatum);\n+                  casewiseRecordForTabFile.set(k, newDatum);\n+                } else {\n+                  // decimal point included\n+                  String[] timeData = casewiseRecordForTabFile.get(k).toString().split(\"\\\\.\");\n+\n+                  dbgLog.finer(StringUtils.join(timeData, \"|\"));\n+                  long dateDatum = Long.parseLong(timeData[0]) * 1000L - SPSS_DATE_BIAS;\n+                  StringBuilder sb_time = new StringBuilder(\n+                    sdf_dhms.format(new Date(dateDatum)));\n+\n+                  if (formatDecimalPointPosition > 0) {\n+                    sb_time.append(\".\" + timeData[1].substring(0, formatDecimalPointPosition));\n+                  }\n+\n+\n+                  dbgLog.finer(\"k=\" + k + \":\" + sb_time.toString());\n+                  casewiseRecordForTabFile.set(k, sb_time.toString());\n+                }\n+              } else if (printFormatTable.get(variableNameList.get(k)).equals(\"DATETIME\")) {\n+                // TODO:\n+                // (for both datetime and \"dateless\" time)\n+                // keep the longest of the matching formats - i.e., if there are *some*\n+                // values in the vector that have thousands of a second, that should be\n+                // part of the saved format!\n+                //  -- L.A. Aug. 12 2014\n+\n+                if (casewiseRecordForTabFile.get(k).toString().indexOf(\".\") < 0) {\n+                  long dateDatum =\n+                    Long.parseLong(casewiseRecordForTabFile.get(k).toString()) * 1000L - SPSS_DATE_OFFSET;\n+                  String newDatum = sdf_ymdhms.format(new Date(dateDatum));\n+                  dbgLog.finer(\"k=\" + k + \":\" + newDatum);\n+                  casewiseRecordForTabFile.set(k, newDatum);\n+                  dateFormatList[k] = sdf_ymdhms.toPattern();\n+                } else {\n+                  // decimal point included\n+                  String[] timeData = casewiseRecordForTabFile.get(k).toString().split(\"\\\\.\");\n+\n+                  //dbgLog.finer(StringUtils.join(timeData, \"|\"));\n+                  long dateDatum = Long.parseLong(timeData[0]) * 1000L - SPSS_DATE_OFFSET;\n+                  StringBuilder sb_time = new StringBuilder(\n+                    sdf_ymdhms.format(new Date(dateDatum)));\n+                  //dbgLog.finer(sb_time.toString());\n+\n+                  if (formatDecimalPointPosition > 0) {\n+                    sb_time.append(\".\" + timeData[1].substring(0, formatDecimalPointPosition));\n+                  }\n+                  dbgLog.finer(\"k=\" + k + \":\" + sb_time.toString());\n+                  casewiseRecordForTabFile.set(k, sb_time.toString());\n+                  // datetime with milliseconds:\n+                  dateFormatList[k] = sdf_ymdhms.toPattern() + (formatDecimalPointPosition > 0 ? \".S\" : \"\");\n                 }\n-                dbgLog.fine(\"RT7ST: raw bytes in Hex:\"+ new String(Hex.encodeHex(bb_field.array())));\n-                if (unitLength==4){\n-                    int fieldData = bb_field.getInt();\n-                    dbgLog.fine(\"RT7ST: \"+i+\"-th fieldData=\"+fieldData);\n-                    dbgLog.fine(\"RT7ST: fieldData in Hex=\"+Integer.toHexString(fieldData));\n-                } else if (unitLength==8){\n-                    double fieldData = bb_field.getDouble();\n-                    dbgLog.finer(\"RT7ST: \"+i+\"-th fieldData=\"+fieldData);\n-                    dbgLog.finer(\"RT7ST: fieldData in Hex=\"+Double.toHexString(fieldData));\n-                \n+              } else if (printFormatTable.get(variableNameList.get(k)).equals(\"TIME\")) {\n+                if (casewiseRecordForTabFile.get(k).toString().indexOf(\".\") < 0) {\n+                  long dateDatum = Long.parseLong(casewiseRecordForTabFile.get(k).toString()) * 1000L;\n+                  String newDatum = sdf_hms.format(new Date(dateDatum));\n+                  dbgLog.finer(\"k=\" + k + \":\" + newDatum);\n+                  casewiseRecordForTabFile.set(k, newDatum);\n+                  if (dateFormatList[k] == null) {\n+                    dateFormatList[k] = sdf_hms.toPattern();\n+                  }\n+                } else {\n+                  // decimal point included\n+                  String[] timeData = casewiseRecordForTabFile.get(k).toString().split(\"\\\\.\");\n+\n+                  //dbgLog.finer(StringUtils.join(timeData, \"|\"));\n+                  long dateDatum = Long.parseLong(timeData[0]) * 1000L;\n+                  StringBuilder sb_time = new StringBuilder(\n+                    sdf_hms.format(new Date(dateDatum)));\n+                  //dbgLog.finer(sb_time.toString());\n+\n+                  if (formatDecimalPointPosition > 0) {\n+                    sb_time.append(\".\" + timeData[1].substring(0, formatDecimalPointPosition));\n+                  }\n+                  dbgLog.finer(\"k=\" + k + \":\" + sb_time.toString());\n+                  casewiseRecordForTabFile.set(k, sb_time.toString());\n+                  // time, possibly with milliseconds:\n+                  String format_hmsS = sdf_hms.toPattern() + (formatDecimalPointPosition > 0 ? \".S\" : \"\");\n+                  if (dateFormatList[k] == null || (format_hmsS.length() > dateFormatList[k].length())) {\n+                    dateFormatList[k] = format_hmsS;\n+                  }\n                 }\n-                dbgLog.finer(\"\");\n+              }\n+            } else if (variableFormatType.equals(\"other\")) {\n+              dbgLog.finer(\"other non-date/time case\");\n+\n+              if (printFormatTable.get(variableNameList.get(k)).equals(\"WKDAY\")) {\n+                // day of week\n+                dbgLog.finer(\"data k=\" + k + \":\" + casewiseRecordForTabFile.get(k));\n+                dbgLog.finer(\"data k=\" + k + \":\" +\n+                  SPSSConstants.WEEKDAY_LIST.get(Integer.valueOf(casewiseRecordForTabFile.get(k).toString()) - 1));\n+                String newDatum =\n+                  SPSSConstants.WEEKDAY_LIST.get(Integer.valueOf(casewiseRecordForTabFile.get(k).toString()) - 1);\n+                casewiseRecordForTabFile.set(k, newDatum);\n+                dbgLog.finer(\"wkday:k=\" + k + \":\" + casewiseRecordForTabFile.get(k));\n+              } else if (printFormatTable.get(variableNameList.get(k)).equals(\"MONTH\")) {\n+                // month\n+                dbgLog.finer(\"data k=\" + k + \":\" + casewiseRecordForTabFile.get(k));\n+                dbgLog.finer(\"data k=\" + k + \":\" +\n+                  SPSSConstants.MONTH_LIST.get(Integer.valueOf(casewiseRecordForTabFile.get(k).toString()) - 1));\n+                String newDatum =\n+                  SPSSConstants.MONTH_LIST.get(Integer.valueOf(casewiseRecordForTabFile.get(k).toString()) - 1);\n+                casewiseRecordForTabFile.set(k, newDatum);\n+                dbgLog.finer(\"month:k=\" + k + \":\" + casewiseRecordForTabFile.get(k));\n+\n+              }\n             }\n-           \n-        } catch (IOException ex) {\n-            //ex.printStackTrace();\n-\t    throw ex; \n+            // end of date/time block\n+          } // end: date-time-datum check\n+\n+        } // end: loop-k(2nd: variablte-wise-check)\n+\n+        // write to tab file\n+        if (casewiseRecordForTabFile.size() > 0) {\n+          pwout.println(StringUtils.join(casewiseRecordForTabFile, \"\\t\"));\n         }\n-        \n-    }\n-    \n-    private List<byte[]> getRT7SubTypefieldData(BufferedInputStream stream) throws IOException {\n-        int length_unit_length = 4;\n-        int length_number_of_units = 4;\n-        int storage_size = length_unit_length + length_number_of_units;\n-        List<byte[]> dataList = new ArrayList<byte[]>();\n-        int[] headerSection = new int[2];\n-        \n-        byte[] byteStorage = new byte[storage_size];\n-\n-        try{\n-            int nbytes = stream.read(byteStorage);\n-            // to-do check against nbytes\n-\n-            //printHexDump(byteStorage, \"RT7:storage\");\n-\n-            ByteBuffer bb_data_type = ByteBuffer.wrap(byteStorage,\n-                       0, length_unit_length);\n-            if (isLittleEndian){\n-                bb_data_type.order(ByteOrder.LITTLE_ENDIAN);\n+\n+        // numeric contents-check\n+        for (int l = 0; l < casewiseRecordForTabFile.size(); l++) {\n+          if (variableFormatTypeList[l].equals(\"date\") ||\n+            variableFormatTypeList[l].equals(\"time\") ||\n+            printFormatTable.get(variableNameList.get(l)).equals(\"WKDAY\") ||\n+            printFormatTable.get(variableNameList.get(l)).equals(\"MONTH\")) {\n+\n+          } else {\n+            if (variableTypelList.get(l) <= 0) {\n+              if (casewiseRecordForTabFile.get(l).toString().indexOf(\".\") >= 0) {\n+                decimalVariableSet.add(l);\n+              }\n             }\n+          }\n+        }\n \n-            int unitLength = bb_data_type.getInt();\n-            dbgLog.fine(\"parseRT7SubTypefield: unitLength=\"+unitLength);\n+        // reset the case-wise working objects\n+        casewiseRecordForTabFile.clear();\n \n-            ByteBuffer bb_number_of_units = ByteBuffer.wrap(byteStorage,\n-                       length_unit_length, length_number_of_units);\n-            if (isLittleEndian){\n-                bb_number_of_units.order(ByteOrder.LITTLE_ENDIAN);\n-            }\n+        if (stream.available() == 0) {\n+          // reached the end of this file\n+          // do exit-processing\n \n-            int numberOfUnits = bb_number_of_units.getInt();\n-            dbgLog.fine(\"parseRT7SubTypefield: numberOfUnits=\"+numberOfUnits);\n+          dbgLog.fine(\"reached the end of the file at \" + ii\n+            + \"th iteration\");\n \n-            headerSection[0] = unitLength;\n-            headerSection[1] = numberOfUnits;\n+          break;\n+        } // if eof processing\n+      } //i-loop: case(row) iteration\n \n-            for (int i=0; i<numberOfUnits; i++){\n+      // close the writer\n+      pwout.close();\n \n-                byte[] work = new byte[unitLength];\n-                int nb = stream.read(work);\n-                dbgLog.finer(new String(Hex.encodeHex(work)));\n-                dataList.add(work);\n-            }\n \n+    } catch (IOException ex) {\n+      throw ex;\n+    }\n+\n+    // contents check\n+    dbgLog.fine(\"numberOfDecimalVariables=\" + numberOfDecimalVariables);\n+    dbgLog.fine(\"decimalVariableSet=\" + decimalVariableSet);\n+\n+    dbgLog.fine(\"***** decodeRecordTypeDataUnCompressed(): end *****\");\n+  }\n+\n+  // Utility Methods  -----------------------------------------------------//\n+\n+  private boolean variableNameIsAnIncrement(String varNameBase, String variableName) {\n+    if (varNameBase == null) {\n+      return false;\n+    }\n+\n+    if (varNameBase.concat(\"0\").equals(variableName)) {\n+      return true;\n+    }\n+\n+    return false;\n+  }\n+\n+  private boolean variableNameIsAnIncrement(String varNameBase, String lastExtendedVariable, String currentVariable) {\n+\n+    if (varNameBase == null ||\n+      lastExtendedVariable == null ||\n+      currentVariable == null) {\n+      return false;\n+    }\n+\n+    if (varNameBase.length() >= lastExtendedVariable.length()) {\n+      return false;\n+    }\n+\n+    if (varNameBase.length() >= currentVariable.length()) {\n+      return false;\n+    }\n+\n+    if (!(varNameBase.equals(currentVariable.substring(0, varNameBase.length())))) {\n+      return false;\n+    }\n+\n+    String lastSuffix = lastExtendedVariable.substring(varNameBase.length());\n+    String currentSuffix = currentVariable.substring(varNameBase.length());\n+\n+    if (currentSuffix.length() > 2) {\n+      return false;\n+    }\n+\n+    //if ( !currentSuffix.matches(\"^[0-9A-Z]*$\") ) {\n+    //    return false;\n+    //}\n+\n+    return suffixIsAnIncrement(lastSuffix, currentSuffix);\n+  }\n+\n+\n+  private boolean suffixIsAnIncrement(String lastSuffix, String currentSuffix) {\n+    // Extended variable suffixes are base-36 number strings in the\n+    // [0-9A-Z] alphabet. I.e. the incremental suffixes go from\n+    // 0 to 9 to A to Z to 10 to 1Z ... etc.\n+\n+    int lastSuffixValue = intBase36(lastSuffix);\n+    int currentSuffixValue = intBase36(currentSuffix);\n+\n+    if (currentSuffixValue - lastSuffixValue > 0) {\n+      return true;\n+    }\n+\n+    return false;\n+  }\n+\n+  private int intBase36(String stringBase36) {\n+\n+    // integer value of a base-36 string in [0-9A-Z] alphabet;\n+    // i.e. \"0\" = 0, \"9\" = 9, \"A\" = 10,\n+    // \"Z\"  = 35, \"10\" = 36, \"1Z\" = 71 ...\n \n-        } catch (IOException ex) {\n-            //ex.printStackTrace();\n-\t    throw ex; \n+    byte[] stringBytes = stringBase36.getBytes();\n+\n+    int ret = 0;\n+\n+    for (int i = 0; i < stringBytes.length; i++) {\n+      int value = 0;\n+      if (stringBytes[i] >= 48 && stringBytes[i] <= 57) {\n+        // [0-9]\n+        value = (int) stringBytes[i] - 48;\n+      } else if (stringBytes[i] >= 65 && stringBytes[i] <= 90) {\n+        // [A-Z]\n+        value = (int) stringBytes[i] - 55;\n+      }\n+\n+      ret = (ret * 36) + value;\n+    }\n+\n+    return ret;\n+  }\n+\n+\n+  private int getSAVintAdjustedBlockLength(int rawLength) {\n+    int adjustedLength = rawLength;\n+    if ((rawLength % LENGTH_SAV_INT_BLOCK) != 0) {\n+      adjustedLength =\n+        LENGTH_SAV_INT_BLOCK * (rawLength / LENGTH_SAV_INT_BLOCK + 1);\n+    }\n+    return adjustedLength;\n+  }\n+\n+  private int getSAVobsAdjustedBlockLength(int rawLength) {\n+    int adjustedLength = rawLength;\n+    if ((rawLength % LENGTH_SAV_OBS_BLOCK) != 0) {\n+      adjustedLength =\n+        LENGTH_SAV_OBS_BLOCK * (rawLength / LENGTH_SAV_OBS_BLOCK + 1);\n+    }\n+    return adjustedLength;\n+  }\n+\n+\n+  private int[] parseRT7SubTypefieldHeader(BufferedInputStream stream) throws IOException {\n+    int length_unit_length = 4;\n+    int length_number_of_units = 4;\n+    int storage_size = length_unit_length + length_number_of_units;\n+\n+    int[] headerSection = new int[2];\n+\n+    byte[] byteStorage = new byte[storage_size];\n+\n+    try {\n+      int nbytes = stream.read(byteStorage);\n+      // to-do check against nbytes\n+\n+      //printHexDump(byteStorage, \"RT7:storage\");\n+\n+      ByteBuffer bb_data_type = ByteBuffer.wrap(byteStorage,\n+        0, length_unit_length);\n+      if (isLittleEndian) {\n+        bb_data_type.order(ByteOrder.LITTLE_ENDIAN);\n+      }\n+\n+      int unitLength = bb_data_type.getInt();\n+      dbgLog.fine(\"parseRT7 SubTypefield: unitLength=\" + unitLength);\n+\n+      ByteBuffer bb_number_of_units = ByteBuffer.wrap(byteStorage,\n+        length_unit_length, length_number_of_units);\n+      if (isLittleEndian) {\n+        bb_number_of_units.order(ByteOrder.LITTLE_ENDIAN);\n+      }\n+\n+      int numberOfUnits = bb_number_of_units.getInt();\n+      dbgLog.fine(\"parseRT7 SubTypefield: numberOfUnits=\" + numberOfUnits);\n+\n+      headerSection[0] = unitLength;\n+      headerSection[1] = numberOfUnits;\n+      return headerSection;\n+    } catch (IOException ex) {\n+      throw ex;\n+    }\n+  }\n+\n+  // TODO:\n+  // rename this method \"skipRT7SubTypefield or parseAndSkip...\n+  // -- because that's what it really does. We only call it\n+  // on RT7 sub-fields that we don't know what to do with.\n+  // -- L.A. 4.0 beta\n+  private void parseRT7SubTypefield(BufferedInputStream stream) throws IOException {\n+    int length_unit_length = 4;\n+    int length_number_of_units = 4;\n+    int storage_size = length_unit_length + length_number_of_units;\n+\n+    int[] headerSection = new int[2];\n+\n+    byte[] byteStorage = new byte[storage_size];\n+\n+    try {\n+      int nbytes = stream.read(byteStorage);\n+      // to-do check against nbytes\n+\n+      //printHexDump(byteStorage, \"RT7:storage\");\n+\n+      ByteBuffer bb_data_type = ByteBuffer.wrap(byteStorage,\n+        0, length_unit_length);\n+      if (isLittleEndian) {\n+        bb_data_type.order(ByteOrder.LITTLE_ENDIAN);\n+      }\n+\n+      int unitLength = bb_data_type.getInt();\n+      dbgLog.fine(\"parseRT7 SubTypefield: unitLength=\" + unitLength);\n+\n+      ByteBuffer bb_number_of_units = ByteBuffer.wrap(byteStorage,\n+        length_unit_length, length_number_of_units);\n+      if (isLittleEndian) {\n+        bb_number_of_units.order(ByteOrder.LITTLE_ENDIAN);\n+      }\n+\n+      int numberOfUnits = bb_number_of_units.getInt();\n+      dbgLog.fine(\"parseRT7 SubTypefield: numberOfUnits=\" + numberOfUnits);\n+\n+      headerSection[0] = unitLength;\n+      headerSection[1] = numberOfUnits;\n+\n+      for (int i = 0; i < numberOfUnits; i++) {\n+        byte[] work = new byte[unitLength];\n+\n+        int nb = stream.read(work);\n+        dbgLog.finer(\"raw bytes in Hex:\" + new String(Hex.encodeHex(work)));\n+        ByteBuffer bb_field = ByteBuffer.wrap(work);\n+        if (isLittleEndian) {\n+          bb_field.order(ByteOrder.LITTLE_ENDIAN);\n         }\n-        return dataList;\n-    }    \n-    \n-    void print2Darray(Object[][] datatable, String title){\n-        dbgLog.fine(title);\n-        for (int i=0; i< datatable.length; i++){\n-            dbgLog.fine(StringUtils.join(datatable[i], \"|\"));\n+        dbgLog.fine(\"RT7ST: raw bytes in Hex:\" + new String(Hex.encodeHex(bb_field.array())));\n+        if (unitLength == 4) {\n+          int fieldData = bb_field.getInt();\n+          dbgLog.fine(\"RT7ST: \" + i + \"-th fieldData=\" + fieldData);\n+          dbgLog.fine(\"RT7ST: fieldData in Hex=\" + Integer.toHexString(fieldData));\n+        } else if (unitLength == 8) {\n+          double fieldData = bb_field.getDouble();\n+          dbgLog.finer(\"RT7ST: \" + i + \"-th fieldData=\" + fieldData);\n+          dbgLog.finer(\"RT7ST: fieldData in Hex=\" + Double.toHexString(fieldData));\n+\n         }\n-    }    \n-        \n-    \n+        dbgLog.finer(\"\");\n+      }\n+\n+    } catch (IOException ex) {\n+      //ex.printStackTrace();\n+      throw ex;\n+    }\n+\n+  }\n+\n+  private List<byte[]> getRT7SubTypefieldData(BufferedInputStream stream) throws IOException {\n+    int length_unit_length = 4;\n+    int length_number_of_units = 4;\n+    int storage_size = length_unit_length + length_number_of_units;\n+    List<byte[]> dataList = new ArrayList<byte[]>();\n+    int[] headerSection = new int[2];\n+\n+    byte[] byteStorage = new byte[storage_size];\n+\n+    try {\n+      int nbytes = stream.read(byteStorage);\n+      // to-do check against nbytes\n+\n+      //printHexDump(byteStorage, \"RT7:storage\");\n+\n+      ByteBuffer bb_data_type = ByteBuffer.wrap(byteStorage,\n+        0, length_unit_length);\n+      if (isLittleEndian) {\n+        bb_data_type.order(ByteOrder.LITTLE_ENDIAN);\n+      }\n+\n+      int unitLength = bb_data_type.getInt();\n+      dbgLog.fine(\"parseRT7SubTypefield: unitLength=\" + unitLength);\n+\n+      ByteBuffer bb_number_of_units = ByteBuffer.wrap(byteStorage,\n+        length_unit_length, length_number_of_units);\n+      if (isLittleEndian) {\n+        bb_number_of_units.order(ByteOrder.LITTLE_ENDIAN);\n+      }\n+\n+      int numberOfUnits = bb_number_of_units.getInt();\n+      dbgLog.fine(\"parseRT7SubTypefield: numberOfUnits=\" + numberOfUnits);\n+\n+      headerSection[0] = unitLength;\n+      headerSection[1] = numberOfUnits;\n+\n+      for (int i = 0; i < numberOfUnits; i++) {\n+\n+        byte[] work = new byte[unitLength];\n+        int nb = stream.read(work);\n+        dbgLog.finer(new String(Hex.encodeHex(work)));\n+        dataList.add(work);\n+      }\n+\n+\n+    } catch (IOException ex) {\n+      //ex.printStackTrace();\n+      throw ex;\n+    }\n+    return dataList;\n+  }\n+\n+  void print2Darray(Object[][] datatable, String title) {\n+    dbgLog.fine(title);\n+    for (int i = 0; i < datatable.length; i++) {\n+      dbgLog.fine(StringUtils.join(datatable[i], \"|\"));\n+    }\n+  }\n+\n+\n }\n \n",
            "diff_size": 5641
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "356",
                    "column": "1",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "356",
                    "column": "1",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ],
    "repaired_by": [
        "intellij"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}