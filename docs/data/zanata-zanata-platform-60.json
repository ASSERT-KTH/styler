{
    "project_name": "zanata-zanata-platform",
    "error_id": "60",
    "information": {
        "errors": [
            {
                "line": "109",
                "column": "36",
                "severity": "error",
                "message": "Don't use trailing comments.",
                "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
            }
        ]
    },
    "source_code": "                            .findById(uploadForm.getUploadId());\n                    totalChunks = previousParts.getParts().size();\n                    totalChunks++; // add final part\n                    tempFile = Optional\n                            .of(util.combineToTempFileAndDeleteUploadRecord(\n                                    previousParts, uploadForm));",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/60/TranslationDocumentUpload.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/styler/60/TranslationDocumentUpload.java\nindex 92e7589ff75..f0774ef3ca9 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/60/TranslationDocumentUpload.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/styler/60/TranslationDocumentUpload.java\n@@ -106,8 +106,9 @@ public class TranslationDocumentUpload implements Serializable {\n                     HDocumentUpload previousParts = documentUploadDAO\n                             .findById(uploadForm.getUploadId());\n                     totalChunks = previousParts.getParts().size();\n-                    totalChunks++; // add final part\n-                    tempFile = Optional\n+                    totalChunks++;\n+                    // add final part\n+                     tempFile = Optional\n                             .of(util.combineToTempFileAndDeleteUploadRecord(\n                                     previousParts, uploadForm));\n                 }\n",
            "diff_size": 3
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "110",
                    "column": "26",
                    "severity": "error",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/60/TranslationDocumentUpload.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/intellij/60/TranslationDocumentUpload.java\nindex 92e7589ff75..5f9d667cf45 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/60/TranslationDocumentUpload.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/intellij/60/TranslationDocumentUpload.java\n@@ -18,6 +18,7 @@\n  * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n  * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n  */\n+\n package org.zanata.file;\n \n import static org.zanata.file.DocumentUploadUtil.getInputStream;\n@@ -61,214 +62,214 @@ import com.google.common.base.Optional;\n @Dependent\n @Named(\"translationDocumentUploader\")\n public class TranslationDocumentUpload implements Serializable {\n-    private static final org.slf4j.Logger log =\n-            org.slf4j.LoggerFactory.getLogger(TranslationDocumentUpload.class);\n-    private static final long serialVersionUID = -6742570568201128740L;\n+  private static final org.slf4j.Logger log =\n+    org.slf4j.LoggerFactory.getLogger(TranslationDocumentUpload.class);\n+  private static final long serialVersionUID = -6742570568201128740L;\n \n-    @Inject\n-    private DocumentUploadUtil util;\n-    @Inject\n-    private ZanataIdentity identity;\n-    @Inject\n-    private LocaleDAO localeDAO;\n-    @Inject\n-    private ProjectIterationDAO projectIterationDAO;\n-    @Inject\n-    private TranslationService translationServiceImpl;\n-    @Inject\n-    private TranslationFileService translationFileServiceImpl;\n-    @Inject\n-    private DocumentUploadDAO documentUploadDAO;\n+  @Inject\n+  private DocumentUploadUtil util;\n+  @Inject\n+  private ZanataIdentity identity;\n+  @Inject\n+  private LocaleDAO localeDAO;\n+  @Inject\n+  private ProjectIterationDAO projectIterationDAO;\n+  @Inject\n+  private TranslationService translationServiceImpl;\n+  @Inject\n+  private TranslationFileService translationFileServiceImpl;\n+  @Inject\n+  private DocumentUploadDAO documentUploadDAO;\n \n-    public Response tryUploadTranslationFile(GlobalDocumentId id,\n-            String localeId, String mergeType, boolean assignCreditToUploader,\n-            DocumentFileUploadForm uploadForm,\n-            TranslationSourceType translationSourceType) {\n-        try {\n-            failIfTranslationUploadNotValid(id, localeId, uploadForm);\n-            HLocale locale = findHLocale(localeId);\n-            Optional<File> tempFile;\n-            int totalChunks;\n-            if (isSinglePart(uploadForm)) {\n-                totalChunks = 1;\n-                tempFile = Optional.<File> absent();\n-            } else {\n-                if (!uploadForm.getLast()) {\n-                    HDocumentUpload upload =\n-                            util.saveUploadPart(id, locale, uploadForm);\n-                    totalChunks = upload.getParts().size();\n-                    return Response.status(Status.ACCEPTED)\n-                            .entity(new ChunkUploadResponse(upload.getId(),\n-                                    totalChunks, true,\n-                                    \"Chunk accepted, awaiting remaining chunks.\"))\n-                            .build();\n-                } else {\n-                    HDocumentUpload previousParts = documentUploadDAO\n-                            .findById(uploadForm.getUploadId());\n-                    totalChunks = previousParts.getParts().size();\n-                    totalChunks++; // add final part\n-                    tempFile = Optional\n-                            .of(util.combineToTempFileAndDeleteUploadRecord(\n-                                    previousParts, uploadForm));\n-                }\n-            }\n-            TranslationsResource transRes;\n-            if (uploadForm.getFileType().equals(\".po\")) {\n-                InputStream poStream = getInputStream(tempFile, uploadForm);\n-                transRes = translationFileServiceImpl.parsePoFile(poStream,\n-                        id.getProjectSlug(), id.getVersionSlug(),\n-                        id.getDocId());\n-            } else {\n-                if (!tempFile.isPresent()) {\n-                    tempFile = Optional\n-                            .of(util.persistTempFileFromUpload(uploadForm));\n-                }\n-                // FIXME this is misusing the 'filename' field. the method\n-                // should probably take a\n-                // type anyway\n-                Optional<String> docType =\n-                        Optional.fromNullable(uploadForm.getFileType());\n-                transRes =\n-                        translationFileServiceImpl.parseAdapterTranslationFile(\n-                                tempFile.get(), id.getProjectSlug(),\n-                                id.getVersionSlug(), id.getDocId(), localeId,\n-                                uploadForm.getFileType(), docType);\n-            }\n-            if (tempFile.isPresent()) {\n-                boolean deleted = tempFile.get().delete();\n-                if (deleted) {\n-                    log.debug(\"Temporary file deleted\");\n-                } else {\n-                    log.debug(\"Unable to delete temporary file\");\n-                }\n-            }\n-            Set<String> extensions =\n-                    newExtensions(uploadForm.getFileType().equals(\".po\"));\n-            // TODO useful error message for failed saving?\n-            List<String> warnings = translationServiceImpl.translateAllInDoc(\n-                    id.getProjectSlug(), id.getVersionSlug(), id.getDocId(),\n-                    locale.getLocaleId(), transRes, extensions,\n-                    mergeTypeFromString(mergeType), assignCreditToUploader,\n-                    translationSourceType);\n-            return transUploadResponse(totalChunks, warnings);\n-        } catch (FileNotFoundException e) {\n-            log.error(\"failed to create input stream from temp file\", e);\n-            return Response.status(Status.INTERNAL_SERVER_ERROR).entity(e)\n-                    .build();\n-        } catch (DocumentUploadException e) {\n-            return Response.status(e.getStatusCode())\n-                    .entity(new ChunkUploadResponse(e.getMessage())).build();\n+  public Response tryUploadTranslationFile(GlobalDocumentId id,\n+                                           String localeId, String mergeType, boolean assignCreditToUploader,\n+                                           DocumentFileUploadForm uploadForm,\n+                                           TranslationSourceType translationSourceType) {\n+    try {\n+      failIfTranslationUploadNotValid(id, localeId, uploadForm);\n+      HLocale locale = findHLocale(localeId);\n+      Optional<File> tempFile;\n+      int totalChunks;\n+      if (isSinglePart(uploadForm)) {\n+        totalChunks = 1;\n+        tempFile = Optional.<File>absent();\n+      } else {\n+        if (!uploadForm.getLast()) {\n+          HDocumentUpload upload =\n+            util.saveUploadPart(id, locale, uploadForm);\n+          totalChunks = upload.getParts().size();\n+          return Response.status(Status.ACCEPTED)\n+            .entity(new ChunkUploadResponse(upload.getId(),\n+              totalChunks, true,\n+              \"Chunk accepted, awaiting remaining chunks.\"))\n+            .build();\n+        } else {\n+          HDocumentUpload previousParts = documentUploadDAO\n+            .findById(uploadForm.getUploadId());\n+          totalChunks = previousParts.getParts().size();\n+          totalChunks++; // add final part\n+          tempFile = Optional\n+            .of(util.combineToTempFileAndDeleteUploadRecord(\n+              previousParts, uploadForm));\n+        }\n+      }\n+      TranslationsResource transRes;\n+      if (uploadForm.getFileType().equals(\".po\")) {\n+        InputStream poStream = getInputStream(tempFile, uploadForm);\n+        transRes = translationFileServiceImpl.parsePoFile(poStream,\n+          id.getProjectSlug(), id.getVersionSlug(),\n+          id.getDocId());\n+      } else {\n+        if (!tempFile.isPresent()) {\n+          tempFile = Optional\n+            .of(util.persistTempFileFromUpload(uploadForm));\n+        }\n+        // FIXME this is misusing the 'filename' field. the method\n+        // should probably take a\n+        // type anyway\n+        Optional<String> docType =\n+          Optional.fromNullable(uploadForm.getFileType());\n+        transRes =\n+          translationFileServiceImpl.parseAdapterTranslationFile(\n+            tempFile.get(), id.getProjectSlug(),\n+            id.getVersionSlug(), id.getDocId(), localeId,\n+            uploadForm.getFileType(), docType);\n+      }\n+      if (tempFile.isPresent()) {\n+        boolean deleted = tempFile.get().delete();\n+        if (deleted) {\n+          log.debug(\"Temporary file deleted\");\n+        } else {\n+          log.debug(\"Unable to delete temporary file\");\n         }\n+      }\n+      Set<String> extensions =\n+        newExtensions(uploadForm.getFileType().equals(\".po\"));\n+      // TODO useful error message for failed saving?\n+      List<String> warnings = translationServiceImpl.translateAllInDoc(\n+        id.getProjectSlug(), id.getVersionSlug(), id.getDocId(),\n+        locale.getLocaleId(), transRes, extensions,\n+        mergeTypeFromString(mergeType), assignCreditToUploader,\n+        translationSourceType);\n+      return transUploadResponse(totalChunks, warnings);\n+    } catch (FileNotFoundException e) {\n+      log.error(\"failed to create input stream from temp file\", e);\n+      return Response.status(Status.INTERNAL_SERVER_ERROR).entity(e)\n+        .build();\n+    } catch (DocumentUploadException e) {\n+      return Response.status(e.getStatusCode())\n+        .entity(new ChunkUploadResponse(e.getMessage())).build();\n     }\n+  }\n \n-    private void failIfTranslationUploadNotValid(GlobalDocumentId id,\n-            String localeId, DocumentFileUploadForm uploadForm)\n-            throws DocumentUploadException {\n-        util.failIfUploadNotValid(id, uploadForm);\n-        util.failIfHashNotPresent(uploadForm);\n-        failIfDocumentDoesNotExist(id);\n-        failIfFileTypeNotValid(uploadForm);\n-        failIfTranslationUploadNotAllowed(id, localeId);\n-    }\n+  private void failIfTranslationUploadNotValid(GlobalDocumentId id,\n+                                               String localeId, DocumentFileUploadForm uploadForm)\n+    throws DocumentUploadException {\n+    util.failIfUploadNotValid(id, uploadForm);\n+    util.failIfHashNotPresent(uploadForm);\n+    failIfDocumentDoesNotExist(id);\n+    failIfFileTypeNotValid(uploadForm);\n+    failIfTranslationUploadNotAllowed(id, localeId);\n+  }\n \n-    private void failIfDocumentDoesNotExist(GlobalDocumentId id)\n-            throws DocumentUploadException {\n-        if (util.isNewDocument(id)) {\n-            throw new DocumentUploadException(Status.NOT_FOUND,\n-                    \"No document with id \\\"\" + id.getDocId()\n-                            + \"\\\" exists in project-version \\\"\"\n-                            + id.getProjectSlug() + \":\" + id.getVersionSlug()\n-                            + \"\\\".\");\n-        }\n+  private void failIfDocumentDoesNotExist(GlobalDocumentId id)\n+    throws DocumentUploadException {\n+    if (util.isNewDocument(id)) {\n+      throw new DocumentUploadException(Status.NOT_FOUND,\n+        \"No document with id \\\"\" + id.getDocId()\n+          + \"\\\" exists in project-version \\\"\"\n+          + id.getProjectSlug() + \":\" + id.getVersionSlug()\n+          + \"\\\".\");\n     }\n+  }\n \n-    private void failIfFileTypeNotValid(DocumentFileUploadForm uploadForm)\n-            throws DocumentUploadException {\n-        String fileType = uploadForm.getFileType();\n-        if (!fileType.equals(\".po\") && !translationFileServiceImpl\n-                .hasAdapterFor(DocumentType.getByName(fileType))) {\n-            throw new DocumentUploadException(Status.BAD_REQUEST, \"The type \\\"\"\n-                    + fileType\n-                    + \"\\\" specified in form parameter \\'type\\' is not valid for a translation file on this server.\");\n-        }\n+  private void failIfFileTypeNotValid(DocumentFileUploadForm uploadForm)\n+    throws DocumentUploadException {\n+    String fileType = uploadForm.getFileType();\n+    if (!fileType.equals(\".po\") && !translationFileServiceImpl\n+      .hasAdapterFor(DocumentType.getByName(fileType))) {\n+      throw new DocumentUploadException(Status.BAD_REQUEST, \"The type \\\"\"\n+        + fileType\n+        + \"\\\" specified in form parameter \\'type\\' is not valid for a translation file on this server.\");\n     }\n+  }\n \n-    private void failIfTranslationUploadNotAllowed(GlobalDocumentId id,\n-            String localeId) throws DocumentUploadException {\n-        HLocale locale = findHLocale(localeId);\n-        if (!isTranslationUploadAllowed(id, locale)) {\n-            throw new DocumentUploadException(Status.FORBIDDEN,\n-                    \"You do not have permission to upload translations for locale \\\"\"\n-                            + localeId + \"\\\" to project-version \\\"\"\n-                            + id.getProjectSlug() + \":\" + id.getVersionSlug()\n-                            + \"\\\".\");\n-        }\n+  private void failIfTranslationUploadNotAllowed(GlobalDocumentId id,\n+                                                 String localeId) throws DocumentUploadException {\n+    HLocale locale = findHLocale(localeId);\n+    if (!isTranslationUploadAllowed(id, locale)) {\n+      throw new DocumentUploadException(Status.FORBIDDEN,\n+        \"You do not have permission to upload translations for locale \\\"\"\n+          + localeId + \"\\\" to project-version \\\"\"\n+          + id.getProjectSlug() + \":\" + id.getVersionSlug()\n+          + \"\\\".\");\n     }\n+  }\n \n-    private HLocale findHLocale(String localeString) {\n-        LocaleId localeId;\n-        try {\n-            localeId = new LocaleId(localeString);\n-        } catch (IllegalArgumentException e) {\n-            throw new DocumentUploadException(Status.BAD_REQUEST,\n-                    \"Invalid value for locale\", e);\n-        }\n-        HLocale locale = localeDAO.findByLocaleId(localeId);\n-        if (locale == null) {\n-            throw new DocumentUploadException(Status.NOT_FOUND,\n-                    \"The specified locale \\\"\" + localeString\n-                            + \"\\\" does not exist on this server.\");\n-        }\n-        return locale;\n+  private HLocale findHLocale(String localeString) {\n+    LocaleId localeId;\n+    try {\n+      localeId = new LocaleId(localeString);\n+    } catch (IllegalArgumentException e) {\n+      throw new DocumentUploadException(Status.BAD_REQUEST,\n+        \"Invalid value for locale\", e);\n     }\n-\n-    private boolean isTranslationUploadAllowed(GlobalDocumentId id,\n-            HLocale locale) {\n-        HProjectIteration projectIteration = projectIterationDAO\n-                .getBySlug(id.getProjectSlug(), id.getVersionSlug());\n-        // TODO should this check be \"add-translation\" or \"modify-translation\"?\n-        // They appear to be granted identically at the moment.\n-        return projectIteration.getStatus() == EntityStatus.ACTIVE\n-                && projectIteration.getProject()\n-                        .getStatus() == EntityStatus.ACTIVE\n-                && identity != null\n-                && identity.hasPermissionWithAnyTargets(\"add-translation\",\n-                        projectIteration.getProject(), locale);\n+    HLocale locale = localeDAO.findByLocaleId(localeId);\n+    if (locale == null) {\n+      throw new DocumentUploadException(Status.NOT_FOUND,\n+        \"The specified locale \\\"\" + localeString\n+          + \"\\\" does not exist on this server.\");\n     }\n+    return locale;\n+  }\n \n-    private static Set<String> newExtensions(boolean gettextExtensions) {\n-        Set<String> extensions;\n-        if (gettextExtensions) {\n-            extensions = new StringSet(ExtensionType.GetText.toString());\n-        } else {\n-            extensions = Collections.<String> emptySet();\n-        }\n-        return extensions;\n-    }\n+  private boolean isTranslationUploadAllowed(GlobalDocumentId id,\n+                                             HLocale locale) {\n+    HProjectIteration projectIteration = projectIterationDAO\n+      .getBySlug(id.getProjectSlug(), id.getVersionSlug());\n+    // TODO should this check be \"add-translation\" or \"modify-translation\"?\n+    // They appear to be granted identically at the moment.\n+    return projectIteration.getStatus() == EntityStatus.ACTIVE\n+      && projectIteration.getProject()\n+      .getStatus() == EntityStatus.ACTIVE\n+      && identity != null\n+      && identity.hasPermissionWithAnyTargets(\"add-translation\",\n+      projectIteration.getProject(), locale);\n+  }\n \n-    private static Response transUploadResponse(int totalChunks,\n-            List<String> warnings) {\n-        ChunkUploadResponse response = new ChunkUploadResponse();\n-        response.setExpectingMore(false);\n-        response.setAcceptedChunks(totalChunks);\n-        if (warnings != null && !warnings.isEmpty()) {\n-            response.setSuccessMessage(buildWarningString(warnings));\n-        } else {\n-            response.setSuccessMessage(\"Translations uploaded successfully\");\n-        }\n-        return Response.status(Status.OK).entity(response).build();\n+  private static Set<String> newExtensions(boolean gettextExtensions) {\n+    Set<String> extensions;\n+    if (gettextExtensions) {\n+      extensions = new StringSet(ExtensionType.GetText.toString());\n+    } else {\n+      extensions = Collections.<String>emptySet();\n     }\n+    return extensions;\n+  }\n \n-    private static String buildWarningString(List<String> warnings) {\n-        return \"Upload succeeded but had the following warnings:\\n    \" +\n-                Joiner.on(\"\\n    \").join(warnings);\n+  private static Response transUploadResponse(int totalChunks,\n+                                              List<String> warnings) {\n+    ChunkUploadResponse response = new ChunkUploadResponse();\n+    response.setExpectingMore(false);\n+    response.setAcceptedChunks(totalChunks);\n+    if (warnings != null && !warnings.isEmpty()) {\n+      response.setSuccessMessage(buildWarningString(warnings));\n+    } else {\n+      response.setSuccessMessage(\"Translations uploaded successfully\");\n     }\n+    return Response.status(Status.OK).entity(response).build();\n+  }\n \n-    private static MergeType mergeTypeFromString(String type) {\n-        if (\"import\".equals(type)) {\n-            return MergeType.IMPORT;\n-        } else {\n-            return MergeType.AUTO;\n-        }\n+  private static String buildWarningString(List<String> warnings) {\n+    return \"Upload succeeded but had the following warnings:\\n    \" +\n+      Joiner.on(\"\\n    \").join(warnings);\n+  }\n+\n+  private static MergeType mergeTypeFromString(String type) {\n+    if (\"import\".equals(type)) {\n+      return MergeType.IMPORT;\n+    } else {\n+      return MergeType.AUTO;\n     }\n+  }\n }\n",
            "diff_size": 232
        },
        {
            "tool": "naturalize",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/60/TranslationDocumentUpload.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/naturalize/60/TranslationDocumentUpload.java\nindex 92e7589ff75..39baec185ca 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/60/TranslationDocumentUpload.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/naturalize/60/TranslationDocumentUpload.java\n@@ -106,7 +106,9 @@ public class TranslationDocumentUpload implements Serializable {\n                     HDocumentUpload previousParts = documentUploadDAO\n                             .findById(uploadForm.getUploadId());\n                     totalChunks = previousParts.getParts().size();\n-                    totalChunks++; // add final part\n+                    totalChunks++;\n+\n+// add final part\n                     tempFile = Optional\n                             .of(util.combineToTempFileAndDeleteUploadRecord(\n                                     previousParts, uploadForm));\n@@ -230,9 +232,7 @@ public class TranslationDocumentUpload implements Serializable {\n         // They appear to be granted identically at the moment.\n         return projectIteration.getStatus() == EntityStatus.ACTIVE\n                 && projectIteration.getProject()\n-                        .getStatus() == EntityStatus.ACTIVE\n-                && identity != null\n-                && identity.hasPermissionWithAnyTargets(\"add-translation\",\n+                        .getStatus() == EntityStatus.ACTIVE && identity != null && identity.hasPermissionWithAnyTargets(\"add-translation\",\n                         projectIteration.getProject(), locale);\n     }\n \n@@ -271,4 +271,4 @@ public class TranslationDocumentUpload implements Serializable {\n             return MergeType.AUTO;\n         }\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 7
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "103",
                    "column": "36",
                    "severity": "error",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/60/TranslationDocumentUpload.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/codebuff/60/TranslationDocumentUpload.java\nindex 92e7589ff75..82d69d468bf 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/60/TranslationDocumentUpload.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/codebuff/60/TranslationDocumentUpload.java\n@@ -22,6 +22,7 @@ package org.zanata.file;\n \n import static org.zanata.file.DocumentUploadUtil.getInputStream;\n import static org.zanata.file.DocumentUploadUtil.isSinglePart;\n+\n import java.io.File;\n import java.io.FileNotFoundException;\n import java.io.InputStream;\n@@ -58,13 +59,12 @@ import com.google.common.base.Joiner;\n import com.google.common.base.Optional;\n //TODO damason: add thorough unit testing\n \n+\n @Dependent\n @Named(\"translationDocumentUploader\")\n public class TranslationDocumentUpload implements Serializable {\n-    private static final org.slf4j.Logger log =\n-            org.slf4j.LoggerFactory.getLogger(TranslationDocumentUpload.class);\n+    private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(TranslationDocumentUpload.class);\n     private static final long serialVersionUID = -6742570568201128740L;\n-\n     @Inject\n     private DocumentUploadUtil util;\n     @Inject\n@@ -79,11 +79,10 @@ public class TranslationDocumentUpload implements Serializable {\n     private TranslationFileService translationFileServiceImpl;\n     @Inject\n     private DocumentUploadDAO documentUploadDAO;\n-\n     public Response tryUploadTranslationFile(GlobalDocumentId id,\n-            String localeId, String mergeType, boolean assignCreditToUploader,\n-            DocumentFileUploadForm uploadForm,\n-            TranslationSourceType translationSourceType) {\n+           String localeId,\n+           String mergeType, boolean assignCreditToUploader,\n+           DocumentFileUploadForm uploadForm, TranslationSourceType translationSourceType) {\n         try {\n             failIfTranslationUploadNotValid(id, localeId, uploadForm);\n             HLocale locale = findHLocale(localeId);\n@@ -94,45 +93,30 @@ public class TranslationDocumentUpload implements Serializable {\n                 tempFile = Optional.<File> absent();\n             } else {\n                 if (!uploadForm.getLast()) {\n-                    HDocumentUpload upload =\n-                            util.saveUploadPart(id, locale, uploadForm);\n+                    HDocumentUpload upload = util.saveUploadPart(id, locale, uploadForm);\n                     totalChunks = upload.getParts().size();\n-                    return Response.status(Status.ACCEPTED)\n-                            .entity(new ChunkUploadResponse(upload.getId(),\n-                                    totalChunks, true,\n-                                    \"Chunk accepted, awaiting remaining chunks.\"))\n-                            .build();\n+                    return Response.status(Status.ACCEPTED).entity(new ChunkUploadResponse(upload.getId(), totalChunks, true,\n+                                                                                           \"Chunk accepted, awaiting remaining chunks.\")).build();\n                 } else {\n-                    HDocumentUpload previousParts = documentUploadDAO\n-                            .findById(uploadForm.getUploadId());\n+                    HDocumentUpload previousParts = documentUploadDAO.findById(uploadForm.getUploadId());\n                     totalChunks = previousParts.getParts().size();\n                     totalChunks++; // add final part\n-                    tempFile = Optional\n-                            .of(util.combineToTempFileAndDeleteUploadRecord(\n-                                    previousParts, uploadForm));\n+                    tempFile = Optional.of(util.combineToTempFileAndDeleteUploadRecord(previousParts, uploadForm));\n                 }\n             }\n             TranslationsResource transRes;\n             if (uploadForm.getFileType().equals(\".po\")) {\n                 InputStream poStream = getInputStream(tempFile, uploadForm);\n-                transRes = translationFileServiceImpl.parsePoFile(poStream,\n-                        id.getProjectSlug(), id.getVersionSlug(),\n-                        id.getDocId());\n+                transRes = translationFileServiceImpl.parsePoFile(poStream, id.getProjectSlug(), id.getVersionSlug(), id.getDocId());\n             } else {\n                 if (!tempFile.isPresent()) {\n-                    tempFile = Optional\n-                            .of(util.persistTempFileFromUpload(uploadForm));\n+                    tempFile = Optional.of(util.persistTempFileFromUpload(uploadForm));\n                 }\n                 // FIXME this is misusing the 'filename' field. the method\n                 // should probably take a\n                 // type anyway\n-                Optional<String> docType =\n-                        Optional.fromNullable(uploadForm.getFileType());\n-                transRes =\n-                        translationFileServiceImpl.parseAdapterTranslationFile(\n-                                tempFile.get(), id.getProjectSlug(),\n-                                id.getVersionSlug(), id.getDocId(), localeId,\n-                                uploadForm.getFileType(), docType);\n+                Optional<String> docType = Optional.fromNullable(uploadForm.getFileType());\n+                transRes = translationFileServiceImpl.parseAdapterTranslationFile(tempFile.get(), id.getProjectSlug(), id.getVersionSlug(), id.getDocId(), localeId, uploadForm.getFileType(), docType);\n             }\n             if (tempFile.isPresent()) {\n                 boolean deleted = tempFile.get().delete();\n@@ -142,28 +126,19 @@ public class TranslationDocumentUpload implements Serializable {\n                     log.debug(\"Unable to delete temporary file\");\n                 }\n             }\n-            Set<String> extensions =\n-                    newExtensions(uploadForm.getFileType().equals(\".po\"));\n+            Set<String> extensions = newExtensions(uploadForm.getFileType().equals(\".po\"));\n             // TODO useful error message for failed saving?\n-            List<String> warnings = translationServiceImpl.translateAllInDoc(\n-                    id.getProjectSlug(), id.getVersionSlug(), id.getDocId(),\n-                    locale.getLocaleId(), transRes, extensions,\n-                    mergeTypeFromString(mergeType), assignCreditToUploader,\n-                    translationSourceType);\n+            List<String> warnings = translationServiceImpl.translateAllInDoc(id.getProjectSlug(), id.getVersionSlug(), id.getDocId(), locale.getLocaleId(), transRes, extensions, mergeTypeFromString(mergeType), assignCreditToUploader, translationSourceType);\n             return transUploadResponse(totalChunks, warnings);\n         } catch (FileNotFoundException e) {\n             log.error(\"failed to create input stream from temp file\", e);\n-            return Response.status(Status.INTERNAL_SERVER_ERROR).entity(e)\n-                    .build();\n+            return Response.status(Status.INTERNAL_SERVER_ERROR).entity(e).build();\n         } catch (DocumentUploadException e) {\n-            return Response.status(e.getStatusCode())\n-                    .entity(new ChunkUploadResponse(e.getMessage())).build();\n+            return Response.status(e.getStatusCode()).entity(new ChunkUploadResponse(e.getMessage())).build();\n         }\n     }\n \n-    private void failIfTranslationUploadNotValid(GlobalDocumentId id,\n-            String localeId, DocumentFileUploadForm uploadForm)\n-            throws DocumentUploadException {\n+    private void failIfTranslationUploadNotValid(GlobalDocumentId id, String localeId, DocumentFileUploadForm uploadForm) throws DocumentUploadException {\n         util.failIfUploadNotValid(id, uploadForm);\n         util.failIfHashNotPresent(uploadForm);\n         failIfDocumentDoesNotExist(id);\n@@ -171,37 +146,23 @@ public class TranslationDocumentUpload implements Serializable {\n         failIfTranslationUploadNotAllowed(id, localeId);\n     }\n \n-    private void failIfDocumentDoesNotExist(GlobalDocumentId id)\n-            throws DocumentUploadException {\n+    private void failIfDocumentDoesNotExist(GlobalDocumentId id) throws DocumentUploadException {\n         if (util.isNewDocument(id)) {\n-            throw new DocumentUploadException(Status.NOT_FOUND,\n-                    \"No document with id \\\"\" + id.getDocId()\n-                            + \"\\\" exists in project-version \\\"\"\n-                            + id.getProjectSlug() + \":\" + id.getVersionSlug()\n-                            + \"\\\".\");\n+            throw new DocumentUploadException(Status.NOT_FOUND, \"No document with id \\\"\" + id.getDocId() + \"\\\" exists in project-version \\\"\" + id.getProjectSlug() + \":\" + id.getVersionSlug() + \"\\\".\");\n         }\n     }\n \n-    private void failIfFileTypeNotValid(DocumentFileUploadForm uploadForm)\n-            throws DocumentUploadException {\n+    private void failIfFileTypeNotValid(DocumentFileUploadForm uploadForm) throws DocumentUploadException {\n         String fileType = uploadForm.getFileType();\n-        if (!fileType.equals(\".po\") && !translationFileServiceImpl\n-                .hasAdapterFor(DocumentType.getByName(fileType))) {\n-            throw new DocumentUploadException(Status.BAD_REQUEST, \"The type \\\"\"\n-                    + fileType\n-                    + \"\\\" specified in form parameter \\'type\\' is not valid for a translation file on this server.\");\n+        if (!fileType.equals(\".po\") && !translationFileServiceImpl.hasAdapterFor(DocumentType.getByName(fileType))) {\n+            throw new DocumentUploadException(Status.BAD_REQUEST, \"The type \\\"\" + fileType + \"\\\" specified in form parameter \\'type\\' is not valid for a translation file on this server.\");\n         }\n     }\n \n-    private void failIfTranslationUploadNotAllowed(GlobalDocumentId id,\n-            String localeId) throws DocumentUploadException {\n+    private void failIfTranslationUploadNotAllowed(GlobalDocumentId id, String localeId) throws DocumentUploadException {\n         HLocale locale = findHLocale(localeId);\n         if (!isTranslationUploadAllowed(id, locale)) {\n-            throw new DocumentUploadException(Status.FORBIDDEN,\n-                    \"You do not have permission to upload translations for locale \\\"\"\n-                            + localeId + \"\\\" to project-version \\\"\"\n-                            + id.getProjectSlug() + \":\" + id.getVersionSlug()\n-                            + \"\\\".\");\n+            throw new DocumentUploadException(Status.FORBIDDEN, \"You do not have permission to upload translations for locale \\\"\" + localeId + \"\\\" to project-version \\\"\" + id.getProjectSlug() + \":\" + id.getVersionSlug() + \"\\\".\");\n         }\n     }\n \n@@ -210,30 +171,22 @@ public class TranslationDocumentUpload implements Serializable {\n         try {\n             localeId = new LocaleId(localeString);\n         } catch (IllegalArgumentException e) {\n-            throw new DocumentUploadException(Status.BAD_REQUEST,\n-                    \"Invalid value for locale\", e);\n+            throw new DocumentUploadException(Status.BAD_REQUEST, \"Invalid value for locale\", e);\n         }\n         HLocale locale = localeDAO.findByLocaleId(localeId);\n         if (locale == null) {\n             throw new DocumentUploadException(Status.NOT_FOUND,\n-                    \"The specified locale \\\"\" + localeString\n-                            + \"\\\" does not exist on this server.\");\n+                                              \"The specified locale \\\"\" + localeString + \"\\\" does not exist on this server.\");\n         }\n         return locale;\n     }\n \n-    private boolean isTranslationUploadAllowed(GlobalDocumentId id,\n-            HLocale locale) {\n-        HProjectIteration projectIteration = projectIterationDAO\n-                .getBySlug(id.getProjectSlug(), id.getVersionSlug());\n+    private boolean isTranslationUploadAllowed(GlobalDocumentId id, HLocale locale) {\n+        HProjectIteration projectIteration = projectIterationDAO.getBySlug(id.getProjectSlug(), id.getVersionSlug());\n         // TODO should this check be \"add-translation\" or \"modify-translation\"?\n         // They appear to be granted identically at the moment.\n-        return projectIteration.getStatus() == EntityStatus.ACTIVE\n-                && projectIteration.getProject()\n-                        .getStatus() == EntityStatus.ACTIVE\n-                && identity != null\n-                && identity.hasPermissionWithAnyTargets(\"add-translation\",\n-                        projectIteration.getProject(), locale);\n+        return projectIteration.getStatus() == EntityStatus.ACTIVE && projectIteration.getProject().getStatus() == EntityStatus.ACTIVE && identity != null\n+        && identity.hasPermissionWithAnyTargets(\"add-translation\", projectIteration.getProject(), locale);\n     }\n \n     private static Set<String> newExtensions(boolean gettextExtensions) {\n@@ -246,8 +199,7 @@ public class TranslationDocumentUpload implements Serializable {\n         return extensions;\n     }\n \n-    private static Response transUploadResponse(int totalChunks,\n-            List<String> warnings) {\n+    private static Response transUploadResponse(int totalChunks, List<String> warnings) {\n         ChunkUploadResponse response = new ChunkUploadResponse();\n         response.setExpectingMore(false);\n         response.setAcceptedChunks(totalChunks);\n@@ -260,8 +212,7 @@ public class TranslationDocumentUpload implements Serializable {\n     }\n \n     private static String buildWarningString(List<String> warnings) {\n-        return \"Upload succeeded but had the following warnings:\\n    \" +\n-                Joiner.on(\"\\n    \").join(warnings);\n+        return \"Upload succeeded but had the following warnings:\\n    \" + Joiner.on(\"\\n    \").join(warnings);\n     }\n \n     private static MergeType mergeTypeFromString(String type) {\n@@ -271,4 +222,4 @@ public class TranslationDocumentUpload implements Serializable {\n             return MergeType.AUTO;\n         }\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 87
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "109",
                    "column": "36",
                    "severity": "error",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/60/TranslationDocumentUpload.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/styler_three_grams/60/TranslationDocumentUpload.java\nindex 92e7589ff75..f0774ef3ca9 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/60/TranslationDocumentUpload.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/styler_three_grams/60/TranslationDocumentUpload.java\n@@ -106,8 +106,9 @@ public class TranslationDocumentUpload implements Serializable {\n                     HDocumentUpload previousParts = documentUploadDAO\n                             .findById(uploadForm.getUploadId());\n                     totalChunks = previousParts.getParts().size();\n-                    totalChunks++; // add final part\n-                    tempFile = Optional\n+                    totalChunks++;\n+                    // add final part\n+                     tempFile = Optional\n                             .of(util.combineToTempFileAndDeleteUploadRecord(\n                                     previousParts, uploadForm));\n                 }\n",
            "diff_size": 3
        }
    ],
    "repaired_by": [
        "styler",
        "naturalize",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "intellij",
        "codebuff",
        "styler_random"
    ]
}