{
    "project_name": "codefollower-H2-Research",
    "error_id": "139",
    "information": {
        "errors": [
            {
                "line": "166",
                "column": "22",
                "severity": "warning",
                "message": "'-' is followed by whitespace.",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.NoWhitespaceAfterCheck"
            }
        ]
    },
    "source_code": "        if (offset < 0) {\n            b.append('-');\n            offset = - offset;\n        } else {\n            b.append('+');\n        }",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/139/ValueTimestampTimeZone.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler/139/ValueTimestampTimeZone.java\nindex 4bc4022be9a..4b98192b6ae 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/139/ValueTimestampTimeZone.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler/139/ValueTimestampTimeZone.java\n@@ -163,7 +163,7 @@ public class ValueTimestampTimeZone extends Value {\n         b.append(\"GMT\");\n         if (offset < 0) {\n             b.append('-');\n-            offset = - offset;\n+            offset = -offset;\n         } else {\n             b.append('+');\n         }\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/139/ValueTimestampTimeZone.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/139/ValueTimestampTimeZone.java\nindex 4bc4022be9a..df81641f35d 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/139/ValueTimestampTimeZone.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/139/ValueTimestampTimeZone.java\n@@ -3,6 +3,7 @@\n  * EPL 1.0 (http://h2database.com/html/license.html). Initial Developer: H2\n  * Group\n  */\n+\n package org.h2.value;\n \n import java.math.BigDecimal;\n@@ -11,6 +12,7 @@ import java.sql.SQLException;\n import java.sql.Timestamp;\n import java.util.SimpleTimeZone;\n import java.util.TimeZone;\n+\n import org.h2.api.ErrorCode;\n import org.h2.api.TimestampWithTimeZone;\n import org.h2.message.DbException;\n@@ -21,283 +23,283 @@ import org.h2.util.StringUtils;\n  * Implementation of the TIMESTAMP WITH TIME ZONE data type.\n  *\n  * @see <a href=\"https://en.wikipedia.org/wiki/ISO_8601#Time_zone_designators\">\n- *      ISO 8601 Time zone designators</a>\n+ * ISO 8601 Time zone designators</a>\n  */\n public class ValueTimestampTimeZone extends Value {\n \n-    /**\n-     * The precision in digits.\n-     */\n-    public static final int PRECISION = 30;\n+  /**\n+   * The precision in digits.\n+   */\n+  public static final int PRECISION = 30;\n \n-    /**\n-     * The display size of the textual representation of a timestamp. Example:\n-     * 2001-01-01 23:59:59.000 +10:00\n-     */\n-    public static final int DISPLAY_SIZE = 30;\n+  /**\n+   * The display size of the textual representation of a timestamp. Example:\n+   * 2001-01-01 23:59:59.000 +10:00\n+   */\n+  public static final int DISPLAY_SIZE = 30;\n \n-    /**\n-     * The default scale for timestamps.\n-     */\n-    static final int DEFAULT_SCALE = 10;\n+  /**\n+   * The default scale for timestamps.\n+   */\n+  static final int DEFAULT_SCALE = 10;\n \n-    /**\n-     * A bit field with bits for the year, month, and day (see DateTimeUtils for\n-     * encoding)\n-     */\n-    private final long dateValue;\n-    /**\n-     * The nanoseconds since midnight.\n-     */\n-    private final long timeNanos;\n-    /**\n-     * Time zone offset from UTC in minutes, range of -18 hours to +18 hours. This\n-     * range is compatible with OffsetDateTime from JSR-310.\n-     */\n-    private final short timeZoneOffsetMins;\n-\n-    private ValueTimestampTimeZone(long dateValue, long timeNanos,\n-            short timeZoneOffsetMins) {\n-        if (timeNanos < 0 || timeNanos >= 24L * 60 * 60 * 1000 * 1000 * 1000) {\n-            throw new IllegalArgumentException(\n-                    \"timeNanos out of range \" + timeNanos);\n-        }\n-        /*\n-         * Some current and historic time zones have offsets larger than 12 hours.\n-         * JSR-310 determines 18 hours as maximum possible offset in both directions, so\n-         * we use this limit too for compatibility.\n-         */\n-        if (timeZoneOffsetMins < (-18 * 60)\n-                || timeZoneOffsetMins > (18 * 60)) {\n-            throw new IllegalArgumentException(\n-                    \"timeZoneOffsetMins out of range \" + timeZoneOffsetMins);\n-        }\n-        this.dateValue = dateValue;\n-        this.timeNanos = timeNanos;\n-        this.timeZoneOffsetMins = timeZoneOffsetMins;\n-    }\n+  /**\n+   * A bit field with bits for the year, month, and day (see DateTimeUtils for\n+   * encoding)\n+   */\n+  private final long dateValue;\n+  /**\n+   * The nanoseconds since midnight.\n+   */\n+  private final long timeNanos;\n+  /**\n+   * Time zone offset from UTC in minutes, range of -18 hours to +18 hours. This\n+   * range is compatible with OffsetDateTime from JSR-310.\n+   */\n+  private final short timeZoneOffsetMins;\n \n-    /**\n-     * Get or create a date value for the given date.\n-     *\n-     * @param dateValue the date value, a bit field with bits for the year,\n-     *            month, and day\n-     * @param timeNanos the nanoseconds since midnight\n-     * @param timeZoneOffsetMins the timezone offset in minutes\n-     * @return the value\n-     */\n-    public static ValueTimestampTimeZone fromDateValueAndNanos(long dateValue,\n-            long timeNanos, short timeZoneOffsetMins) {\n-        return (ValueTimestampTimeZone) Value.cache(new ValueTimestampTimeZone(\n-                dateValue, timeNanos, timeZoneOffsetMins));\n+  private ValueTimestampTimeZone(long dateValue, long timeNanos,\n+                                 short timeZoneOffsetMins) {\n+    if (timeNanos < 0 || timeNanos >= 24L * 60 * 60 * 1000 * 1000 * 1000) {\n+      throw new IllegalArgumentException(\n+          \"timeNanos out of range \" + timeNanos);\n     }\n-\n-    /**\n-     * Get or create a timestamp value for the given timestamp.\n-     *\n-     * @param timestamp the timestamp\n-     * @return the value\n+    /*\n+     * Some current and historic time zones have offsets larger than 12 hours.\n+     * JSR-310 determines 18 hours as maximum possible offset in both directions, so\n+     * we use this limit too for compatibility.\n      */\n-    public static ValueTimestampTimeZone get(TimestampWithTimeZone timestamp) {\n-        return fromDateValueAndNanos(timestamp.getYMD(),\n-                timestamp.getNanosSinceMidnight(),\n-                timestamp.getTimeZoneOffsetMins());\n+    if (timeZoneOffsetMins < (-18 * 60)\n+        || timeZoneOffsetMins > (18 * 60)) {\n+      throw new IllegalArgumentException(\n+          \"timeZoneOffsetMins out of range \" + timeZoneOffsetMins);\n     }\n+    this.dateValue = dateValue;\n+    this.timeNanos = timeNanos;\n+    this.timeZoneOffsetMins = timeZoneOffsetMins;\n+  }\n \n-    /**\n-     * Parse a string to a ValueTimestamp. This method supports the format\n-     * +/-year-month-day hour:minute:seconds.fractional and an optional timezone\n-     * part.\n-     *\n-     * @param s the string to parse\n-     * @return the date\n-     */\n-    public static ValueTimestampTimeZone parse(String s) {\n-        try {\n-            return (ValueTimestampTimeZone) DateTimeUtils.parseTimestamp(s, null, true);\n-        } catch (Exception e) {\n-            throw DbException.get(ErrorCode.INVALID_DATETIME_CONSTANT_2, e,\n-                    \"TIMESTAMP WITH TIME ZONE\", s);\n-        }\n-    }\n+  /**\n+   * Get or create a date value for the given date.\n+   *\n+   * @param dateValue          the date value, a bit field with bits for the year,\n+   *                           month, and day\n+   * @param timeNanos          the nanoseconds since midnight\n+   * @param timeZoneOffsetMins the timezone offset in minutes\n+   * @return the value\n+   */\n+  public static ValueTimestampTimeZone fromDateValueAndNanos(long dateValue,\n+                                                             long timeNanos, short timeZoneOffsetMins) {\n+    return (ValueTimestampTimeZone) Value.cache(new ValueTimestampTimeZone(\n+        dateValue, timeNanos, timeZoneOffsetMins));\n+  }\n \n-    /**\n-     * A bit field with bits for the year, month, and day (see DateTimeUtils for\n-     * encoding).\n-     *\n-     * @return the data value\n-     */\n-    public long getDateValue() {\n-        return dateValue;\n-    }\n+  /**\n+   * Get or create a timestamp value for the given timestamp.\n+   *\n+   * @param timestamp the timestamp\n+   * @return the value\n+   */\n+  public static ValueTimestampTimeZone get(TimestampWithTimeZone timestamp) {\n+    return fromDateValueAndNanos(timestamp.getYMD(),\n+        timestamp.getNanosSinceMidnight(),\n+        timestamp.getTimeZoneOffsetMins());\n+  }\n \n-    /**\n-     * The nanoseconds since midnight.\n-     *\n-     * @return the nanoseconds\n-     */\n-    public long getTimeNanos() {\n-        return timeNanos;\n+  /**\n+   * Parse a string to a ValueTimestamp. This method supports the format\n+   * +/-year-month-day hour:minute:seconds.fractional and an optional timezone\n+   * part.\n+   *\n+   * @param s the string to parse\n+   * @return the date\n+   */\n+  public static ValueTimestampTimeZone parse(String s) {\n+    try {\n+      return (ValueTimestampTimeZone) DateTimeUtils.parseTimestamp(s, null, true);\n+    } catch (Exception e) {\n+      throw DbException.get(ErrorCode.INVALID_DATETIME_CONSTANT_2, e,\n+          \"TIMESTAMP WITH TIME ZONE\", s);\n     }\n+  }\n \n-    /**\n-     * The timezone offset in minutes.\n-     *\n-     * @return the offset\n-     */\n-    public short getTimeZoneOffsetMins() {\n-        return timeZoneOffsetMins;\n-    }\n+  /**\n+   * A bit field with bits for the year, month, and day (see DateTimeUtils for\n+   * encoding).\n+   *\n+   * @return the data value\n+   */\n+  public long getDateValue() {\n+    return dateValue;\n+  }\n \n-    /**\n-     * Returns compatible offset-based time zone with no DST schedule.\n-     *\n-     * @return compatible offset-based time zone\n-     */\n-    public TimeZone getTimeZone() {\n-        int offset = timeZoneOffsetMins;\n-        if (offset == 0) {\n-            return DateTimeUtils.UTC;\n-        }\n-        StringBuilder b = new StringBuilder(9);\n-        b.append(\"GMT\");\n-        if (offset < 0) {\n-            b.append('-');\n-            offset = - offset;\n-        } else {\n-            b.append('+');\n-        }\n-        StringUtils.appendZeroPadded(b, 2, offset / 60);\n-        b.append(':');\n-        StringUtils.appendZeroPadded(b, 2, offset % 60);\n-        return new SimpleTimeZone(offset * 60000, b.toString());\n-    }\n+  /**\n+   * The nanoseconds since midnight.\n+   *\n+   * @return the nanoseconds\n+   */\n+  public long getTimeNanos() {\n+    return timeNanos;\n+  }\n \n-    @Override\n-    public Timestamp getTimestamp() {\n-        throw new UnsupportedOperationException(\"unimplemented\");\n-    }\n+  /**\n+   * The timezone offset in minutes.\n+   *\n+   * @return the offset\n+   */\n+  public short getTimeZoneOffsetMins() {\n+    return timeZoneOffsetMins;\n+  }\n \n-    @Override\n-    public int getType() {\n-        return Value.TIMESTAMP_TZ;\n+  /**\n+   * Returns compatible offset-based time zone with no DST schedule.\n+   *\n+   * @return compatible offset-based time zone\n+   */\n+  public TimeZone getTimeZone() {\n+    int offset = timeZoneOffsetMins;\n+    if (offset == 0) {\n+      return DateTimeUtils.UTC;\n     }\n-\n-    @Override\n-    public String getString() {\n-        return DateTimeUtils.timestampTimeZoneToString(dateValue, timeNanos, timeZoneOffsetMins);\n+    StringBuilder b = new StringBuilder(9);\n+    b.append(\"GMT\");\n+    if (offset < 0) {\n+      b.append('-');\n+      offset = -offset;\n+    } else {\n+      b.append('+');\n     }\n+    StringUtils.appendZeroPadded(b, 2, offset / 60);\n+    b.append(':');\n+    StringUtils.appendZeroPadded(b, 2, offset % 60);\n+    return new SimpleTimeZone(offset * 60000, b.toString());\n+  }\n \n-    @Override\n-    public String getSQL() {\n-        return \"TIMESTAMP WITH TIME ZONE '\" + getString() + \"'\";\n-    }\n+  @Override\n+  public Timestamp getTimestamp() {\n+    throw new UnsupportedOperationException(\"unimplemented\");\n+  }\n \n-    @Override\n-    public long getPrecision() {\n-        return PRECISION;\n-    }\n+  @Override\n+  public int getType() {\n+    return Value.TIMESTAMP_TZ;\n+  }\n \n-    @Override\n-    public int getScale() {\n-        return DEFAULT_SCALE;\n-    }\n+  @Override\n+  public String getString() {\n+    return DateTimeUtils.timestampTimeZoneToString(dateValue, timeNanos, timeZoneOffsetMins);\n+  }\n \n-    @Override\n-    public int getDisplaySize() {\n-        return DISPLAY_SIZE;\n-    }\n+  @Override\n+  public String getSQL() {\n+    return \"TIMESTAMP WITH TIME ZONE '\" + getString() + \"'\";\n+  }\n \n-    @Override\n-    public Value convertScale(boolean onlyToSmallerScale, int targetScale) {\n-        if (targetScale >= DEFAULT_SCALE) {\n-            return this;\n-        }\n-        if (targetScale < 0) {\n-            throw DbException.getInvalidValueException(\"scale\", targetScale);\n-        }\n-        long n = timeNanos;\n-        BigDecimal bd = BigDecimal.valueOf(n);\n-        bd = bd.movePointLeft(9);\n-        bd = ValueDecimal.setScale(bd, targetScale);\n-        bd = bd.movePointRight(9);\n-        long n2 = bd.longValue();\n-        if (n2 == n) {\n-            return this;\n-        }\n-        return fromDateValueAndNanos(dateValue, n2, timeZoneOffsetMins);\n-    }\n+  @Override\n+  public long getPrecision() {\n+    return PRECISION;\n+  }\n \n-    @Override\n-    protected int compareSecure(Value o, CompareMode mode) {\n-        ValueTimestampTimeZone t = (ValueTimestampTimeZone) o;\n-        // Maximum time zone offset is +/-18 hours so difference in days between local\n-        // and UTC cannot be more than one day\n-        long daysA = DateTimeUtils.absoluteDayFromDateValue(dateValue);\n-        long timeA = timeNanos - timeZoneOffsetMins * 60_000_000_000L;\n-        if (timeA < 0) {\n-            timeA += DateTimeUtils.NANOS_PER_DAY;\n-            daysA--;\n-        } else if (timeA >= DateTimeUtils.NANOS_PER_DAY) {\n-            timeA -= DateTimeUtils.NANOS_PER_DAY;\n-            daysA++;\n-        }\n-        long daysB = DateTimeUtils.absoluteDayFromDateValue(t.dateValue);\n-        long timeB = t.timeNanos - t.timeZoneOffsetMins * 60_000_000_000L;\n-        if (timeB < 0) {\n-            timeB += DateTimeUtils.NANOS_PER_DAY;\n-            daysB--;\n-        } else if (timeB >= DateTimeUtils.NANOS_PER_DAY) {\n-            timeB -= DateTimeUtils.NANOS_PER_DAY;\n-            daysB++;\n-        }\n-        int cmp = Long.compare(daysA, daysB);\n-        if (cmp != 0) {\n-            return cmp;\n-        }\n-        return Long.compare(timeA, timeB);\n-    }\n+  @Override\n+  public int getScale() {\n+    return DEFAULT_SCALE;\n+  }\n \n-    @Override\n-    public boolean equals(Object other) {\n-        if (this == other) {\n-            return true;\n-        } else if (!(other instanceof ValueTimestampTimeZone)) {\n-            return false;\n-        }\n-        ValueTimestampTimeZone x = (ValueTimestampTimeZone) other;\n-        return dateValue == x.dateValue && timeNanos == x.timeNanos\n-                && timeZoneOffsetMins == x.timeZoneOffsetMins;\n-    }\n+  @Override\n+  public int getDisplaySize() {\n+    return DISPLAY_SIZE;\n+  }\n \n-    @Override\n-    public int hashCode() {\n-        return (int) (dateValue ^ (dateValue >>> 32) ^ timeNanos\n-                ^ (timeNanos >>> 32) ^ timeZoneOffsetMins);\n+  @Override\n+  public Value convertScale(boolean onlyToSmallerScale, int targetScale) {\n+    if (targetScale >= DEFAULT_SCALE) {\n+      return this;\n     }\n-\n-    @Override\n-    public Object getObject() {\n-        return new TimestampWithTimeZone(dateValue, timeNanos,\n-                timeZoneOffsetMins);\n+    if (targetScale < 0) {\n+      throw DbException.getInvalidValueException(\"scale\", targetScale);\n     }\n-\n-    @Override\n-    public void set(PreparedStatement prep, int parameterIndex)\n-            throws SQLException {\n-        prep.setString(parameterIndex, getString());\n+    long n = timeNanos;\n+    BigDecimal bd = BigDecimal.valueOf(n);\n+    bd = bd.movePointLeft(9);\n+    bd = ValueDecimal.setScale(bd, targetScale);\n+    bd = bd.movePointRight(9);\n+    long n2 = bd.longValue();\n+    if (n2 == n) {\n+      return this;\n     }\n+    return fromDateValueAndNanos(dateValue, n2, timeZoneOffsetMins);\n+  }\n \n-    @Override\n-    public Value add(Value v) {\n-        throw DbException.getUnsupportedException(\n-                \"manipulating TIMESTAMP WITH TIME ZONE values is unsupported\");\n+  @Override\n+  protected int compareSecure(Value o, CompareMode mode) {\n+    ValueTimestampTimeZone t = (ValueTimestampTimeZone) o;\n+    // Maximum time zone offset is +/-18 hours so difference in days between local\n+    // and UTC cannot be more than one day\n+    long daysA = DateTimeUtils.absoluteDayFromDateValue(dateValue);\n+    long timeA = timeNanos - timeZoneOffsetMins * 60_000_000_000L;\n+    if (timeA < 0) {\n+      timeA += DateTimeUtils.NANOS_PER_DAY;\n+      daysA--;\n+    } else if (timeA >= DateTimeUtils.NANOS_PER_DAY) {\n+      timeA -= DateTimeUtils.NANOS_PER_DAY;\n+      daysA++;\n+    }\n+    long daysB = DateTimeUtils.absoluteDayFromDateValue(t.dateValue);\n+    long timeB = t.timeNanos - t.timeZoneOffsetMins * 60_000_000_000L;\n+    if (timeB < 0) {\n+      timeB += DateTimeUtils.NANOS_PER_DAY;\n+      daysB--;\n+    } else if (timeB >= DateTimeUtils.NANOS_PER_DAY) {\n+      timeB -= DateTimeUtils.NANOS_PER_DAY;\n+      daysB++;\n     }\n+    int cmp = Long.compare(daysA, daysB);\n+    if (cmp != 0) {\n+      return cmp;\n+    }\n+    return Long.compare(timeA, timeB);\n+  }\n \n-    @Override\n-    public Value subtract(Value v) {\n-        throw DbException.getUnsupportedException(\n-                \"manipulating TIMESTAMP WITH TIME ZONE values is unsupported\");\n+  @Override\n+  public boolean equals(Object other) {\n+    if (this == other) {\n+      return true;\n+    } else if (!(other instanceof ValueTimestampTimeZone)) {\n+      return false;\n     }\n+    ValueTimestampTimeZone x = (ValueTimestampTimeZone) other;\n+    return dateValue == x.dateValue && timeNanos == x.timeNanos\n+        && timeZoneOffsetMins == x.timeZoneOffsetMins;\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return (int) (dateValue ^ (dateValue >>> 32) ^ timeNanos\n+        ^ (timeNanos >>> 32) ^ timeZoneOffsetMins);\n+  }\n+\n+  @Override\n+  public Object getObject() {\n+    return new TimestampWithTimeZone(dateValue, timeNanos,\n+        timeZoneOffsetMins);\n+  }\n+\n+  @Override\n+  public void set(PreparedStatement prep, int parameterIndex)\n+      throws SQLException {\n+    prep.setString(parameterIndex, getString());\n+  }\n+\n+  @Override\n+  public Value add(Value v) {\n+    throw DbException.getUnsupportedException(\n+        \"manipulating TIMESTAMP WITH TIME ZONE values is unsupported\");\n+  }\n+\n+  @Override\n+  public Value subtract(Value v) {\n+    throw DbException.getUnsupportedException(\n+        \"manipulating TIMESTAMP WITH TIME ZONE values is unsupported\");\n+  }\n \n }\n",
            "diff_size": 343
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "165",
                    "column": "22",
                    "severity": "warning",
                    "message": "'-' is followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.NoWhitespaceAfterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/139/ValueTimestampTimeZone.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/naturalize/139/ValueTimestampTimeZone.java\nindex 4bc4022be9a..9955109df29 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/139/ValueTimestampTimeZone.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/naturalize/139/ValueTimestampTimeZone.java\n@@ -56,8 +56,7 @@ public class ValueTimestampTimeZone extends Value {\n      */\n     private final short timeZoneOffsetMins;\n \n-    private ValueTimestampTimeZone(long dateValue, long timeNanos,\n-            short timeZoneOffsetMins) {\n+    private ValueTimestampTimeZone(long dateValue, long timeNanos, short timeZoneOffsetMins) {\n         if (timeNanos < 0 || timeNanos >= 24L * 60 * 60 * 1000 * 1000 * 1000) {\n             throw new IllegalArgumentException(\n                     \"timeNanos out of range \" + timeNanos);\n@@ -88,7 +87,7 @@ public class ValueTimestampTimeZone extends Value {\n      */\n     public static ValueTimestampTimeZone fromDateValueAndNanos(long dateValue,\n             long timeNanos, short timeZoneOffsetMins) {\n-        return (ValueTimestampTimeZone) Value.cache(new ValueTimestampTimeZone(\n+    return (ValueTimestampTimeZone) Value.cache(new ValueTimestampTimeZone(\n                 dateValue, timeNanos, timeZoneOffsetMins));\n     }\n \n@@ -272,8 +271,7 @@ public class ValueTimestampTimeZone extends Value {\n \n     @Override\n     public int hashCode() {\n-        return (int) (dateValue ^ (dateValue >>> 32) ^ timeNanos\n-                ^ (timeNanos >>> 32) ^ timeZoneOffsetMins);\n+        return (int) (dateValue ^ (dateValue >>> 32) ^ timeNanos ^ (timeNanos >>> 32) ^ timeZoneOffsetMins);\n     }\n \n     @Override\n@@ -300,4 +298,4 @@ public class ValueTimestampTimeZone extends Value {\n                 \"manipulating TIMESTAMP WITH TIME ZONE values is unsupported\");\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 6
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/139/ValueTimestampTimeZone.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/codebuff/139/ValueTimestampTimeZone.java\nindex 4bc4022be9a..8ded251b00e 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/139/ValueTimestampTimeZone.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/codebuff/139/ValueTimestampTimeZone.java\n@@ -23,22 +23,30 @@ import org.h2.util.StringUtils;\n  * @see <a href=\"https://en.wikipedia.org/wiki/ISO_8601#Time_zone_designators\">\n  *      ISO 8601 Time zone designators</a>\n  */\n+\n+\n public class ValueTimestampTimeZone extends Value {\n \n     /**\n      * The precision in digits.\n      */\n+\n+\n     public static final int PRECISION = 30;\n \n     /**\n      * The display size of the textual representation of a timestamp. Example:\n      * 2001-01-01 23:59:59.000 +10:00\n      */\n+\n+\n     public static final int DISPLAY_SIZE = 30;\n \n     /**\n      * The default scale for timestamps.\n      */\n+\n+\n     static final int DEFAULT_SCALE = 10;\n \n     /**\n@@ -56,21 +64,17 @@ public class ValueTimestampTimeZone extends Value {\n      */\n     private final short timeZoneOffsetMins;\n \n-    private ValueTimestampTimeZone(long dateValue, long timeNanos,\n-            short timeZoneOffsetMins) {\n+    private ValueTimestampTimeZone(long dateValue, long timeNanos, short timeZoneOffsetMins) {\n         if (timeNanos < 0 || timeNanos >= 24L * 60 * 60 * 1000 * 1000 * 1000) {\n-            throw new IllegalArgumentException(\n-                    \"timeNanos out of range \" + timeNanos);\n+            throw new IllegalArgumentException(\"timeNanos out of range \" + timeNanos);\n         }\n         /*\n          * Some current and historic time zones have offsets larger than 12 hours.\n          * JSR-310 determines 18 hours as maximum possible offset in both directions, so\n          * we use this limit too for compatibility.\n          */\n-        if (timeZoneOffsetMins < (-18 * 60)\n-                || timeZoneOffsetMins > (18 * 60)) {\n-            throw new IllegalArgumentException(\n-                    \"timeZoneOffsetMins out of range \" + timeZoneOffsetMins);\n+        if (timeZoneOffsetMins < (-18 * 60) || timeZoneOffsetMins > (18 * 60)) {\n+            throw new IllegalArgumentException(\"timeZoneOffsetMins out of range \" + timeZoneOffsetMins);\n         }\n         this.dateValue = dateValue;\n         this.timeNanos = timeNanos;\n@@ -86,10 +90,10 @@ public class ValueTimestampTimeZone extends Value {\n      * @param timeZoneOffsetMins the timezone offset in minutes\n      * @return the value\n      */\n-    public static ValueTimestampTimeZone fromDateValueAndNanos(long dateValue,\n-            long timeNanos, short timeZoneOffsetMins) {\n-        return (ValueTimestampTimeZone) Value.cache(new ValueTimestampTimeZone(\n-                dateValue, timeNanos, timeZoneOffsetMins));\n+\n+\n+    public static ValueTimestampTimeZone fromDateValueAndNanos(long dateValue, long timeNanos, short timeZoneOffsetMins) {\n+        return (ValueTimestampTimeZone) Value.cache(new ValueTimestampTimeZone(dateValue, timeNanos, timeZoneOffsetMins));\n     }\n \n     /**\n@@ -98,10 +102,10 @@ public class ValueTimestampTimeZone extends Value {\n      * @param timestamp the timestamp\n      * @return the value\n      */\n+\n+\n     public static ValueTimestampTimeZone get(TimestampWithTimeZone timestamp) {\n-        return fromDateValueAndNanos(timestamp.getYMD(),\n-                timestamp.getNanosSinceMidnight(),\n-                timestamp.getTimeZoneOffsetMins());\n+        return fromDateValueAndNanos(timestamp.getYMD(), timestamp.getNanosSinceMidnight(), timestamp.getTimeZoneOffsetMins());\n     }\n \n     /**\n@@ -112,12 +116,14 @@ public class ValueTimestampTimeZone extends Value {\n      * @param s the string to parse\n      * @return the date\n      */\n+\n+\n     public static ValueTimestampTimeZone parse(String s) {\n         try {\n             return (ValueTimestampTimeZone) DateTimeUtils.parseTimestamp(s, null, true);\n         } catch (Exception e) {\n             throw DbException.get(ErrorCode.INVALID_DATETIME_CONSTANT_2, e,\n-                    \"TIMESTAMP WITH TIME ZONE\", s);\n+                                  \"TIMESTAMP WITH TIME ZONE\", s);\n         }\n     }\n \n@@ -127,6 +133,8 @@ public class ValueTimestampTimeZone extends Value {\n      *\n      * @return the data value\n      */\n+\n+\n     public long getDateValue() {\n         return dateValue;\n     }\n@@ -136,6 +144,8 @@ public class ValueTimestampTimeZone extends Value {\n      *\n      * @return the nanoseconds\n      */\n+\n+\n     public long getTimeNanos() {\n         return timeNanos;\n     }\n@@ -145,6 +155,8 @@ public class ValueTimestampTimeZone extends Value {\n      *\n      * @return the offset\n      */\n+\n+\n     public short getTimeZoneOffsetMins() {\n         return timeZoneOffsetMins;\n     }\n@@ -154,6 +166,8 @@ public class ValueTimestampTimeZone extends Value {\n      *\n      * @return compatible offset-based time zone\n      */\n+\n+\n     public TimeZone getTimeZone() {\n         int offset = timeZoneOffsetMins;\n         if (offset == 0) {\n@@ -163,7 +177,7 @@ public class ValueTimestampTimeZone extends Value {\n         b.append(\"GMT\");\n         if (offset < 0) {\n             b.append('-');\n-            offset = - offset;\n+            offset = -offset;\n         } else {\n             b.append('+');\n         }\n@@ -266,38 +280,34 @@ public class ValueTimestampTimeZone extends Value {\n             return false;\n         }\n         ValueTimestampTimeZone x = (ValueTimestampTimeZone) other;\n-        return dateValue == x.dateValue && timeNanos == x.timeNanos\n-                && timeZoneOffsetMins == x.timeZoneOffsetMins;\n+        return dateValue == x.dateValue && timeNanos == x.timeNanos && timeZoneOffsetMins == x.timeZoneOffsetMins;\n     }\n \n     @Override\n     public int hashCode() {\n-        return (int) (dateValue ^ (dateValue >>> 32) ^ timeNanos\n-                ^ (timeNanos >>> 32) ^ timeZoneOffsetMins);\n+        return (int) (dateValue ^ (dateValue >>> 32)\n+^ timeNanos\n+^ (timeNanos >>> 32) ^ timeZoneOffsetMins);\n     }\n \n     @Override\n     public Object getObject() {\n-        return new TimestampWithTimeZone(dateValue, timeNanos,\n-                timeZoneOffsetMins);\n+        return new TimestampWithTimeZone(dateValue, timeNanos, timeZoneOffsetMins);\n     }\n \n     @Override\n-    public void set(PreparedStatement prep, int parameterIndex)\n-            throws SQLException {\n+    public void set(PreparedStatement prep, int parameterIndex) throws SQLException {\n         prep.setString(parameterIndex, getString());\n     }\n \n     @Override\n     public Value add(Value v) {\n-        throw DbException.getUnsupportedException(\n-                \"manipulating TIMESTAMP WITH TIME ZONE values is unsupported\");\n+        throw DbException.getUnsupportedException(\"manipulating TIMESTAMP WITH TIME ZONE values is unsupported\");\n     }\n \n     @Override\n     public Value subtract(Value v) {\n-        throw DbException.getUnsupportedException(\n-                \"manipulating TIMESTAMP WITH TIME ZONE values is unsupported\");\n+        throw DbException.getUnsupportedException(\"manipulating TIMESTAMP WITH TIME ZONE values is unsupported\");\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 51
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/139/ValueTimestampTimeZone.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_random/139/ValueTimestampTimeZone.java\nindex 4bc4022be9a..4b98192b6ae 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/139/ValueTimestampTimeZone.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_random/139/ValueTimestampTimeZone.java\n@@ -163,7 +163,7 @@ public class ValueTimestampTimeZone extends Value {\n         b.append(\"GMT\");\n         if (offset < 0) {\n             b.append('-');\n-            offset = - offset;\n+            offset = -offset;\n         } else {\n             b.append('+');\n         }\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/139/ValueTimestampTimeZone.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/139/ValueTimestampTimeZone.java\nindex 4bc4022be9a..4b98192b6ae 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/139/ValueTimestampTimeZone.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/139/ValueTimestampTimeZone.java\n@@ -163,7 +163,7 @@ public class ValueTimestampTimeZone extends Value {\n         b.append(\"GMT\");\n         if (offset < 0) {\n             b.append('-');\n-            offset = - offset;\n+            offset = -offset;\n         } else {\n             b.append('+');\n         }\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "naturalize"
    ]
}