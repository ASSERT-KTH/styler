{
    "project_name": "DaGeRe-peass",
    "error_id": "36",
    "information": {
        "errors": [
            {
                "line": "89",
                "column": "53",
                "severity": "error",
                "message": "'{' is not preceded with whitespace.",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
            }
        ]
    },
    "source_code": "\t\t\tChangedTraceTests testsTemp;\n\t\t\tFile executionFile = new File(line.getOptionValue(OptionConstants.EXECUTIONFILE.getName()));\n\t\t\tif (!executionFile.exists()){\n\t\t\t\tthrow new RuntimeException(\"Executionfile needs to exist\");\n\t\t\t}\n\t\t\ttry {",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/errored/1/36/DependencyTestPairStarter.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/styler/36/DependencyTestPairStarter.java\nindex e3561767c42..bfdb0fd7248 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/errored/1/36/DependencyTestPairStarter.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/styler/36/DependencyTestPairStarter.java\n@@ -86,7 +86,7 @@ public class DependencyTestPairStarter extends PairProcessor {\n \t\t\tfinal ObjectMapper mapper = new ObjectMapper();\n \t\t\tChangedTraceTests testsTemp;\n \t\t\tFile executionFile = new File(line.getOptionValue(OptionConstants.EXECUTIONFILE.getName()));\n-\t\t\tif (!executionFile.exists()){\n+\t\t\tif (!executionFile.exists()) {\n \t\t\t\tthrow new RuntimeException(\"Executionfile needs to exist\");\n \t\t\t}\n \t\t\ttry {\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/errored/1/36/DependencyTestPairStarter.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/intellij/36/DependencyTestPairStarter.java\nindex e3561767c42..e608bbb9031 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/errored/1/36/DependencyTestPairStarter.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/intellij/36/DependencyTestPairStarter.java\n@@ -31,221 +31,220 @@ import de.peran.utils.OptionConstants;\n /**\n  * Runs the dependency test by running the test, where something could have changed, pairwise for every new version. This makes it faster to get potential change candidates, but it takes longer for a\n  * whole project.\n- * \n- * @author reichelt\n  *\n+ * @author reichelt\n  */\n public class DependencyTestPairStarter extends PairProcessor {\n \n-\tprivate static final Logger LOG = LogManager.getLogger(DependencyTestPairStarter.class);\n-\n-\tprotected final DependencyTester tester;\n-\tprivate final List<String> versions = new LinkedList<>();\n-\tprivate final int startindex, endindex;\n-\tprivate final ChangedTraceTests changedTests;\n-\tprivate final TestCase test;\n-\n-\tpublic DependencyTestPairStarter(final String[] args) throws ParseException, JAXBException, IOException {\n-\t\tsuper(args);\n-\t\tfinal int vms = Integer.parseInt(line.getOptionValue(OptionConstants.VMS.getName(), \"15\"));\n-\t\tfinal int repetitions = Integer.parseInt(line.getOptionValue(OptionConstants.REPETITIONS.getName(), \"1\"));\n-\t\tthis.changedTests = loadChangedTests(line);\n-\t\tboolean useKieker = Boolean.parseBoolean(line.getOptionValue(OptionConstants.USEKIEKER.getName(), \"false\"));\n-\n-\t\tif (line.hasOption(OptionConstants.DURATION.getName())) {\n-\t\t\tfinal int duration = Integer.parseInt(line.getOptionValue(OptionConstants.DURATION.getName()));\n-\t\t\tif (dependencies.getModule() != null) {\n-\t\t\t\tfinal File moduleFolder = new File(projectFolder, dependencies.getModule());\n-\t\t\t\ttester = new DependencyTester(projectFolder, moduleFolder, duration, vms, true, repetitions, useKieker);\n-\t\t\t} else {\n-\t\t\t\ttester = new DependencyTester(projectFolder, projectFolder, duration, vms, true, repetitions, useKieker);\n-\t\t\t}\n-\t\t} else {\n-\t\t\tfinal int warmup = Integer.parseInt(line.getOptionValue(OptionConstants.WARMUP.getName(), \"10\"));\n-\t\t\tfinal int iterationen = Integer.parseInt(line.getOptionValue(OptionConstants.ITERATIONS.getName(), \"10\"));\n-\t\t\ttester = new DependencyTester(projectFolder, warmup, iterationen, vms, true, repetitions, useKieker);\n-\t\t}\n-\n-\t\tif (line.hasOption(OptionConstants.TEST.getName())) {\n-\t\t\ttest = new TestCase(line.getOptionValue(OptionConstants.TEST.getName()));\n-\t\t} else {\n-\t\t\ttest = null;\n-\t\t}\n-\n-\t\tversions.add(dependencies.getInitialversion().getVersion());\n-\n-\t\tdependencies.getVersions().getVersion().forEach(version -> versions.add(version.getVersion()));\n-\n-\t\tstartindex = getStartVersionIndex();\n-\t\tendindex = getEndVersion();\n-\t}\n-\n-\tpublic static ChangedTraceTests loadChangedTests(final CommandLine line) throws IOException, JsonParseException, JsonMappingException {\n-\t\tfinal ChangedTraceTests changedTests;\n-\t\tif (line.hasOption(OptionConstants.EXECUTIONFILE.getName())) {\n-\t\t\tfinal ObjectMapper mapper = new ObjectMapper();\n-\t\t\tChangedTraceTests testsTemp;\n-\t\t\tFile executionFile = new File(line.getOptionValue(OptionConstants.EXECUTIONFILE.getName()));\n-\t\t\tif (!executionFile.exists()){\n-\t\t\t\tthrow new RuntimeException(\"Executionfile needs to exist\");\n-\t\t\t}\n-\t\t\ttry {\n-\t\t\t\ttestsTemp = mapper.readValue(executionFile, ChangedTraceTests.class);\n-\t\t\t} catch (final JsonMappingException e) {\n-\t\t\t\te.printStackTrace();\n-\t\t\t\tfinal ObjectMapper objectMapper = new ObjectMapper();\n-\t\t\t\tfinal SimpleModule module = new SimpleModule();\n-\t\t\t\tmodule.addDeserializer(ChangedTraceTests.class, new ChangedTraceTests.OldVersionDeserializer());\n-\t\t\t\tobjectMapper.registerModule(module);\n-\t\t\t\ttestsTemp = objectMapper.readValue(executionFile, ChangedTraceTests.class);\n-\t\t\t}\n-\t\t\tchangedTests = testsTemp;\n-\t\t} else {\n-\t\t\tchangedTests = null;\n-\t\t}\n-\t\treturn changedTests;\n-\t}\n-\n-\t/**\n-\t * Calculates the index of the start version\n-\t * \n-\t * @return index of the start version\n-\t */\n-\tprivate int getStartVersionIndex() {\n-\t\tint currentStartindex = startversion != null ? versions.indexOf(startversion) : 0;\n-\t\t// Only bugfix if dependencyfile and executefile do not fully match\n-\t\tif (changedTests != null) {\n-\t\t\tif (startversion != null && currentStartindex == -1) {\n-\t\t\t\tString potentialStart = \"\";\n-\t\t\t\tif (changedTests.getVersions().containsKey(startversion)) {\n-\t\t\t\t\tfor (final String sicVersion : changedTests.getVersions().keySet()) {\n-\t\t\t\t\t\tfor (final Version ticVersion : dependencies.getVersions().getVersion()) {\n-\t\t\t\t\t\t\tif (ticVersion.getVersion().equals(sicVersion)) {\n-\t\t\t\t\t\t\t\tpotentialStart = ticVersion.getVersion();\n-\t\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tif (sicVersion.equals(startversion)) {\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tLOG.debug(\"Version only in executefile, next version in dependencyfile: {}\", potentialStart);\n-\t\t\t\tcurrentStartindex = versions.indexOf(potentialStart);\n-\t\t\t}\n-\t\t}\n-\t\treturn currentStartindex;\n-\t}\n-\n-\t/**\n-\t * Calculates the index of the end version.\n-\t * \n-\t * @return index of the end version\n-\t */\n-\tprivate int getEndVersion() {\n-\t\tint currentEndindex = endversion != null ? versions.indexOf(endversion) : versions.size();\n-\t\t// Only bugfix if dependencyfile and executefile do not fully match\n-\t\tif (changedTests != null) {\n-\t\t\tif (endversion != null && currentEndindex == -1) {\n-\t\t\t\tString potentialStart = \"\";\n-\t\t\t\tif (changedTests.getVersions().containsKey(endversion)) {\n-\t\t\t\t\tfor (final String sicVersion : changedTests.getVersions().keySet()) {\n-\t\t\t\t\t\tboolean next = false;\n-\t\t\t\t\t\tfor (final Version ticVersion : dependencies.getVersions().getVersion()) {\n-\t\t\t\t\t\t\tif (next) {\n-\t\t\t\t\t\t\t\tpotentialStart = ticVersion.getVersion();\n-\t\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tif (ticVersion.getVersion().equals(sicVersion)) {\n-\t\t\t\t\t\t\t\tnext = true;\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tif (sicVersion.equals(endversion)) {\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tLOG.debug(\"Version only in executefile, next version in dependencyfile: {}\", potentialStart);\n-\t\t\t\tcurrentEndindex = versions.indexOf(potentialStart);\n-\t\t\t}\n-\t\t}\n-\t\treturn currentEndindex;\n-\t}\n-\n-\t@Override\n-\tprotected void processVersion(final Version versioninfo) {\n-\t\ttry {\n-\t\t\tfinal int currentIndex = versions.indexOf(versioninfo.getVersion());\n-\t\t\tfinal boolean executeThisVersion = currentIndex >= startindex && currentIndex <= endindex;\n-\n-\t\t\tfinal String version = versioninfo.getVersion();\n-\t\t\tLOG.info(\"Bearbeite {} Mit Tests: {}\", version, executeThisVersion);\n-\n-\t\t\tfinal Set<TestCase> testcases = findTestcases(versioninfo);\n-\n-\t\t\tfor (final TestCase testcase : testcases) {\n-\t\t\t\tboolean executeThisTest = true;\n-\t\t\t\tif (test != null) {\n-\t\t\t\t\tif (!test.equals(testcase)) {\n-\t\t\t\t\t\texecuteThisTest = false;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tif (executeThisTest && executeThisVersion && lastTestcaseCalls.containsKey(testcase)) {\n-\t\t\t\t\tif (changedTests != null) {\n-\t\t\t\t\t\tfinal TestSet calls = changedTests.getVersions().get(version);\n-\t\t\t\t\t\tboolean hasChanges = false;\n-\t\t\t\t\t\tif (calls != null) {\n-\t\t\t\t\t\t\tfor (final Map.Entry<String, List<String>> clazzCalls : calls.entrySet()) {\n-\t\t\t\t\t\t\t\tif (clazzCalls.getKey().equals(testcase.getClazz()) && clazzCalls.getValue().contains(testcase.getMethod())) {\n-\t\t\t\t\t\t\t\t\thasChanges = true;\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tif (hasChanges) {\n-\t\t\t\t\t\t\tfinal String versionOld = lastTestcaseCalls.get(testcase);\n-\t\t\t\t\t\t\texecuteCompareTests(version, versionOld, testcase);\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tLOG.debug(\"Skipping \" + testcase + \" because of execution-JSON in \" + versioninfo.getVersion());\n-\t\t\t\t\t\t}\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tfinal String versionOld = lastTestcaseCalls.get(testcase);\n-\t\t\t\t\t\texecuteCompareTests(version, versionOld, testcase);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tlastTestcaseCalls.put(testcase, version);\n-\t\t\t}\n-\t\t} catch (IOException | InterruptedException | JAXBException e) {\n-\t\t\te.printStackTrace();\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Compares the given testcase for the given versions.\n-\t * \n-\t * @param version Current version to test\n-\t * @param versionOld Old version to test\n-\t * @param testcase Testcase to test\n-\t */\n-\tprotected void executeCompareTests(final String version, final String versionOld, final TestCase testcase) throws IOException, InterruptedException, JAXBException {\n-\t\tLOG.info(\"Executing test \" + testcase.getClazz() + \" \" + testcase.getMethod() + \" in versions {} and {}\", versionOld, version);\n-\n-\t\tFile logFile = new File(PeASSFolderUtil.getLogFolder(), version);\n-\t\tif (logFile.exists()) {\n-\t\t\tlogFile = new File(PeASSFolderUtil.getLogFolder(), version + \"_new\");\n-\t\t}\n-\t\tlogFile.mkdir();\n-\n-\t\tfinal TestSet testset = new TestSet();\n-\t\ttestset.addTest(testcase.getClazz(), testcase.getMethod());\n-\t\tfor (int vmid = 0; vmid < tester.getVMCount(); vmid++) {\n-\t\t\ttester.evaluateOnce(testset, versionOld, vmid, logFile);\n-\t\t\ttester.evaluateOnce(testset, version, vmid, logFile);\n-\t\t}\n-\t}\n-\n-\tpublic static void main(final String[] args) throws ParseException, JAXBException, IOException {\n-\t\tfinal DependencyTestPairStarter starter = new DependencyTestPairStarter(args);\n-\t\tstarter.processCommandline();\n-\t}\n+  private static final Logger LOG = LogManager.getLogger(DependencyTestPairStarter.class);\n+\n+  protected final DependencyTester tester;\n+  private final List<String> versions = new LinkedList<>();\n+  private final int startindex, endindex;\n+  private final ChangedTraceTests changedTests;\n+  private final TestCase test;\n+\n+  public DependencyTestPairStarter(final String[] args) throws ParseException, JAXBException, IOException {\n+    super(args);\n+    final int vms = Integer.parseInt(line.getOptionValue(OptionConstants.VMS.getName(), \"15\"));\n+    final int repetitions = Integer.parseInt(line.getOptionValue(OptionConstants.REPETITIONS.getName(), \"1\"));\n+    this.changedTests = loadChangedTests(line);\n+    boolean useKieker = Boolean.parseBoolean(line.getOptionValue(OptionConstants.USEKIEKER.getName(), \"false\"));\n+\n+    if (line.hasOption(OptionConstants.DURATION.getName())) {\n+      final int duration = Integer.parseInt(line.getOptionValue(OptionConstants.DURATION.getName()));\n+      if (dependencies.getModule() != null) {\n+        final File moduleFolder = new File(projectFolder, dependencies.getModule());\n+        tester = new DependencyTester(projectFolder, moduleFolder, duration, vms, true, repetitions, useKieker);\n+      } else {\n+        tester = new DependencyTester(projectFolder, projectFolder, duration, vms, true, repetitions, useKieker);\n+      }\n+    } else {\n+      final int warmup = Integer.parseInt(line.getOptionValue(OptionConstants.WARMUP.getName(), \"10\"));\n+      final int iterationen = Integer.parseInt(line.getOptionValue(OptionConstants.ITERATIONS.getName(), \"10\"));\n+      tester = new DependencyTester(projectFolder, warmup, iterationen, vms, true, repetitions, useKieker);\n+    }\n+\n+    if (line.hasOption(OptionConstants.TEST.getName())) {\n+      test = new TestCase(line.getOptionValue(OptionConstants.TEST.getName()));\n+    } else {\n+      test = null;\n+    }\n+\n+    versions.add(dependencies.getInitialversion().getVersion());\n+\n+    dependencies.getVersions().getVersion().forEach(version -> versions.add(version.getVersion()));\n+\n+    startindex = getStartVersionIndex();\n+    endindex = getEndVersion();\n+  }\n+\n+  public static ChangedTraceTests loadChangedTests(final CommandLine line) throws IOException, JsonParseException, JsonMappingException {\n+    final ChangedTraceTests changedTests;\n+    if (line.hasOption(OptionConstants.EXECUTIONFILE.getName())) {\n+      final ObjectMapper mapper = new ObjectMapper();\n+      ChangedTraceTests testsTemp;\n+      File executionFile = new File(line.getOptionValue(OptionConstants.EXECUTIONFILE.getName()));\n+      if (!executionFile.exists()) {\n+        throw new RuntimeException(\"Executionfile needs to exist\");\n+      }\n+      try {\n+        testsTemp = mapper.readValue(executionFile, ChangedTraceTests.class);\n+      } catch (final JsonMappingException e) {\n+        e.printStackTrace();\n+        final ObjectMapper objectMapper = new ObjectMapper();\n+        final SimpleModule module = new SimpleModule();\n+        module.addDeserializer(ChangedTraceTests.class, new ChangedTraceTests.OldVersionDeserializer());\n+        objectMapper.registerModule(module);\n+        testsTemp = objectMapper.readValue(executionFile, ChangedTraceTests.class);\n+      }\n+      changedTests = testsTemp;\n+    } else {\n+      changedTests = null;\n+    }\n+    return changedTests;\n+  }\n+\n+  /**\n+   * Calculates the index of the start version\n+   *\n+   * @return index of the start version\n+   */\n+  private int getStartVersionIndex() {\n+    int currentStartindex = startversion != null ? versions.indexOf(startversion) : 0;\n+    // Only bugfix if dependencyfile and executefile do not fully match\n+    if (changedTests != null) {\n+      if (startversion != null && currentStartindex == -1) {\n+        String potentialStart = \"\";\n+        if (changedTests.getVersions().containsKey(startversion)) {\n+          for (final String sicVersion : changedTests.getVersions().keySet()) {\n+            for (final Version ticVersion : dependencies.getVersions().getVersion()) {\n+              if (ticVersion.getVersion().equals(sicVersion)) {\n+                potentialStart = ticVersion.getVersion();\n+                break;\n+              }\n+            }\n+            if (sicVersion.equals(startversion)) {\n+              break;\n+            }\n+          }\n+        }\n+        LOG.debug(\"Version only in executefile, next version in dependencyfile: {}\", potentialStart);\n+        currentStartindex = versions.indexOf(potentialStart);\n+      }\n+    }\n+    return currentStartindex;\n+  }\n+\n+  /**\n+   * Calculates the index of the end version.\n+   *\n+   * @return index of the end version\n+   */\n+  private int getEndVersion() {\n+    int currentEndindex = endversion != null ? versions.indexOf(endversion) : versions.size();\n+    // Only bugfix if dependencyfile and executefile do not fully match\n+    if (changedTests != null) {\n+      if (endversion != null && currentEndindex == -1) {\n+        String potentialStart = \"\";\n+        if (changedTests.getVersions().containsKey(endversion)) {\n+          for (final String sicVersion : changedTests.getVersions().keySet()) {\n+            boolean next = false;\n+            for (final Version ticVersion : dependencies.getVersions().getVersion()) {\n+              if (next) {\n+                potentialStart = ticVersion.getVersion();\n+                break;\n+              }\n+              if (ticVersion.getVersion().equals(sicVersion)) {\n+                next = true;\n+              }\n+            }\n+            if (sicVersion.equals(endversion)) {\n+              break;\n+            }\n+          }\n+        }\n+        LOG.debug(\"Version only in executefile, next version in dependencyfile: {}\", potentialStart);\n+        currentEndindex = versions.indexOf(potentialStart);\n+      }\n+    }\n+    return currentEndindex;\n+  }\n+\n+  @Override\n+  protected void processVersion(final Version versioninfo) {\n+    try {\n+      final int currentIndex = versions.indexOf(versioninfo.getVersion());\n+      final boolean executeThisVersion = currentIndex >= startindex && currentIndex <= endindex;\n+\n+      final String version = versioninfo.getVersion();\n+      LOG.info(\"Bearbeite {} Mit Tests: {}\", version, executeThisVersion);\n+\n+      final Set<TestCase> testcases = findTestcases(versioninfo);\n+\n+      for (final TestCase testcase : testcases) {\n+        boolean executeThisTest = true;\n+        if (test != null) {\n+          if (!test.equals(testcase)) {\n+            executeThisTest = false;\n+          }\n+        }\n+        if (executeThisTest && executeThisVersion && lastTestcaseCalls.containsKey(testcase)) {\n+          if (changedTests != null) {\n+            final TestSet calls = changedTests.getVersions().get(version);\n+            boolean hasChanges = false;\n+            if (calls != null) {\n+              for (final Map.Entry<String, List<String>> clazzCalls : calls.entrySet()) {\n+                if (clazzCalls.getKey().equals(testcase.getClazz()) && clazzCalls.getValue().contains(testcase.getMethod())) {\n+                  hasChanges = true;\n+                }\n+              }\n+            }\n+            if (hasChanges) {\n+              final String versionOld = lastTestcaseCalls.get(testcase);\n+              executeCompareTests(version, versionOld, testcase);\n+            } else {\n+              LOG.debug(\"Skipping \" + testcase + \" because of execution-JSON in \" + versioninfo.getVersion());\n+            }\n+          } else {\n+            final String versionOld = lastTestcaseCalls.get(testcase);\n+            executeCompareTests(version, versionOld, testcase);\n+          }\n+        }\n+        lastTestcaseCalls.put(testcase, version);\n+      }\n+    } catch (IOException | InterruptedException | JAXBException e) {\n+      e.printStackTrace();\n+    }\n+  }\n+\n+  /**\n+   * Compares the given testcase for the given versions.\n+   *\n+   * @param version    Current version to test\n+   * @param versionOld Old version to test\n+   * @param testcase   Testcase to test\n+   */\n+  protected void executeCompareTests(final String version, final String versionOld, final TestCase testcase) throws IOException, InterruptedException, JAXBException {\n+    LOG.info(\"Executing test \" + testcase.getClazz() + \" \" + testcase.getMethod() + \" in versions {} and {}\", versionOld, version);\n+\n+    File logFile = new File(PeASSFolderUtil.getLogFolder(), version);\n+    if (logFile.exists()) {\n+      logFile = new File(PeASSFolderUtil.getLogFolder(), version + \"_new\");\n+    }\n+    logFile.mkdir();\n+\n+    final TestSet testset = new TestSet();\n+    testset.addTest(testcase.getClazz(), testcase.getMethod());\n+    for (int vmid = 0; vmid < tester.getVMCount(); vmid++) {\n+      tester.evaluateOnce(testset, versionOld, vmid, logFile);\n+      tester.evaluateOnce(testset, version, vmid, logFile);\n+    }\n+  }\n+\n+  public static void main(final String[] args) throws ParseException, JAXBException, IOException {\n+    final DependencyTestPairStarter starter = new DependencyTestPairStarter(args);\n+    starter.processCommandline();\n+  }\n \n }\n",
            "diff_size": 213
        },
        {
            "tool": "naturalize",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/errored/1/36/DependencyTestPairStarter.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/naturalize/36/DependencyTestPairStarter.java\nindex e3561767c42..87c999bc47b 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/errored/1/36/DependencyTestPairStarter.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/naturalize/36/DependencyTestPairStarter.java\n@@ -86,7 +86,7 @@ public class DependencyTestPairStarter extends PairProcessor {\n \t\t\tfinal ObjectMapper mapper = new ObjectMapper();\n \t\t\tChangedTraceTests testsTemp;\n \t\t\tFile executionFile = new File(line.getOptionValue(OptionConstants.EXECUTIONFILE.getName()));\n-\t\t\tif (!executionFile.exists()){\n+\t\t\tif (!executionFile.exists()) {\n \t\t\t\tthrow new RuntimeException(\"Executionfile needs to exist\");\n \t\t\t}\n \t\t\ttry {\n@@ -248,4 +248,4 @@ public class DependencyTestPairStarter extends PairProcessor {\n \t\tstarter.processCommandline();\n \t}\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 2
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/errored/1/36/DependencyTestPairStarter.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/codebuff/36/DependencyTestPairStarter.java\nindex e3561767c42..09ec1ccb70b 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/errored/1/36/DependencyTestPairStarter.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/codebuff/36/DependencyTestPairStarter.java\n@@ -6,19 +6,15 @@ import java.util.LinkedList;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n-\n import javax.xml.bind.JAXBException;\n-\n import org.apache.commons.cli.CommandLine;\n import org.apache.commons.cli.ParseException;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n-\n import com.fasterxml.jackson.core.JsonParseException;\n import com.fasterxml.jackson.databind.JsonMappingException;\n import com.fasterxml.jackson.databind.ObjectMapper;\n import com.fasterxml.jackson.databind.module.SimpleModule;\n-\n import de.peran.dependency.PeASSFolderUtil;\n import de.peran.dependency.analysis.data.TestCase;\n import de.peran.dependency.analysis.data.TestSet;\n@@ -35,217 +31,214 @@ import de.peran.utils.OptionConstants;\n  * @author reichelt\n  *\n  */\n-public class DependencyTestPairStarter extends PairProcessor {\n \n-\tprivate static final Logger LOG = LogManager.getLogger(DependencyTestPairStarter.class);\n-\n-\tprotected final DependencyTester tester;\n-\tprivate final List<String> versions = new LinkedList<>();\n-\tprivate final int startindex, endindex;\n-\tprivate final ChangedTraceTests changedTests;\n-\tprivate final TestCase test;\n-\n-\tpublic DependencyTestPairStarter(final String[] args) throws ParseException, JAXBException, IOException {\n-\t\tsuper(args);\n-\t\tfinal int vms = Integer.parseInt(line.getOptionValue(OptionConstants.VMS.getName(), \"15\"));\n-\t\tfinal int repetitions = Integer.parseInt(line.getOptionValue(OptionConstants.REPETITIONS.getName(), \"1\"));\n-\t\tthis.changedTests = loadChangedTests(line);\n-\t\tboolean useKieker = Boolean.parseBoolean(line.getOptionValue(OptionConstants.USEKIEKER.getName(), \"false\"));\n-\n-\t\tif (line.hasOption(OptionConstants.DURATION.getName())) {\n-\t\t\tfinal int duration = Integer.parseInt(line.getOptionValue(OptionConstants.DURATION.getName()));\n-\t\t\tif (dependencies.getModule() != null) {\n-\t\t\t\tfinal File moduleFolder = new File(projectFolder, dependencies.getModule());\n-\t\t\t\ttester = new DependencyTester(projectFolder, moduleFolder, duration, vms, true, repetitions, useKieker);\n-\t\t\t} else {\n-\t\t\t\ttester = new DependencyTester(projectFolder, projectFolder, duration, vms, true, repetitions, useKieker);\n-\t\t\t}\n-\t\t} else {\n-\t\t\tfinal int warmup = Integer.parseInt(line.getOptionValue(OptionConstants.WARMUP.getName(), \"10\"));\n-\t\t\tfinal int iterationen = Integer.parseInt(line.getOptionValue(OptionConstants.ITERATIONS.getName(), \"10\"));\n-\t\t\ttester = new DependencyTester(projectFolder, warmup, iterationen, vms, true, repetitions, useKieker);\n-\t\t}\n-\n-\t\tif (line.hasOption(OptionConstants.TEST.getName())) {\n-\t\t\ttest = new TestCase(line.getOptionValue(OptionConstants.TEST.getName()));\n-\t\t} else {\n-\t\t\ttest = null;\n-\t\t}\n-\n-\t\tversions.add(dependencies.getInitialversion().getVersion());\n-\n-\t\tdependencies.getVersions().getVersion().forEach(version -> versions.add(version.getVersion()));\n-\n-\t\tstartindex = getStartVersionIndex();\n-\t\tendindex = getEndVersion();\n-\t}\n-\n-\tpublic static ChangedTraceTests loadChangedTests(final CommandLine line) throws IOException, JsonParseException, JsonMappingException {\n-\t\tfinal ChangedTraceTests changedTests;\n-\t\tif (line.hasOption(OptionConstants.EXECUTIONFILE.getName())) {\n-\t\t\tfinal ObjectMapper mapper = new ObjectMapper();\n-\t\t\tChangedTraceTests testsTemp;\n-\t\t\tFile executionFile = new File(line.getOptionValue(OptionConstants.EXECUTIONFILE.getName()));\n-\t\t\tif (!executionFile.exists()){\n-\t\t\t\tthrow new RuntimeException(\"Executionfile needs to exist\");\n-\t\t\t}\n-\t\t\ttry {\n-\t\t\t\ttestsTemp = mapper.readValue(executionFile, ChangedTraceTests.class);\n-\t\t\t} catch (final JsonMappingException e) {\n-\t\t\t\te.printStackTrace();\n-\t\t\t\tfinal ObjectMapper objectMapper = new ObjectMapper();\n-\t\t\t\tfinal SimpleModule module = new SimpleModule();\n-\t\t\t\tmodule.addDeserializer(ChangedTraceTests.class, new ChangedTraceTests.OldVersionDeserializer());\n-\t\t\t\tobjectMapper.registerModule(module);\n-\t\t\t\ttestsTemp = objectMapper.readValue(executionFile, ChangedTraceTests.class);\n-\t\t\t}\n-\t\t\tchangedTests = testsTemp;\n-\t\t} else {\n-\t\t\tchangedTests = null;\n-\t\t}\n-\t\treturn changedTests;\n-\t}\n-\n-\t/**\n-\t * Calculates the index of the start version\n-\t * \n-\t * @return index of the start version\n-\t */\n-\tprivate int getStartVersionIndex() {\n-\t\tint currentStartindex = startversion != null ? versions.indexOf(startversion) : 0;\n-\t\t// Only bugfix if dependencyfile and executefile do not fully match\n-\t\tif (changedTests != null) {\n-\t\t\tif (startversion != null && currentStartindex == -1) {\n-\t\t\t\tString potentialStart = \"\";\n-\t\t\t\tif (changedTests.getVersions().containsKey(startversion)) {\n-\t\t\t\t\tfor (final String sicVersion : changedTests.getVersions().keySet()) {\n-\t\t\t\t\t\tfor (final Version ticVersion : dependencies.getVersions().getVersion()) {\n-\t\t\t\t\t\t\tif (ticVersion.getVersion().equals(sicVersion)) {\n-\t\t\t\t\t\t\t\tpotentialStart = ticVersion.getVersion();\n-\t\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tif (sicVersion.equals(startversion)) {\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tLOG.debug(\"Version only in executefile, next version in dependencyfile: {}\", potentialStart);\n-\t\t\t\tcurrentStartindex = versions.indexOf(potentialStart);\n-\t\t\t}\n-\t\t}\n-\t\treturn currentStartindex;\n-\t}\n-\n-\t/**\n-\t * Calculates the index of the end version.\n-\t * \n-\t * @return index of the end version\n-\t */\n-\tprivate int getEndVersion() {\n-\t\tint currentEndindex = endversion != null ? versions.indexOf(endversion) : versions.size();\n-\t\t// Only bugfix if dependencyfile and executefile do not fully match\n-\t\tif (changedTests != null) {\n-\t\t\tif (endversion != null && currentEndindex == -1) {\n-\t\t\t\tString potentialStart = \"\";\n-\t\t\t\tif (changedTests.getVersions().containsKey(endversion)) {\n-\t\t\t\t\tfor (final String sicVersion : changedTests.getVersions().keySet()) {\n-\t\t\t\t\t\tboolean next = false;\n-\t\t\t\t\t\tfor (final Version ticVersion : dependencies.getVersions().getVersion()) {\n-\t\t\t\t\t\t\tif (next) {\n-\t\t\t\t\t\t\t\tpotentialStart = ticVersion.getVersion();\n-\t\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tif (ticVersion.getVersion().equals(sicVersion)) {\n-\t\t\t\t\t\t\t\tnext = true;\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tif (sicVersion.equals(endversion)) {\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tLOG.debug(\"Version only in executefile, next version in dependencyfile: {}\", potentialStart);\n-\t\t\t\tcurrentEndindex = versions.indexOf(potentialStart);\n-\t\t\t}\n-\t\t}\n-\t\treturn currentEndindex;\n-\t}\n-\n-\t@Override\n-\tprotected void processVersion(final Version versioninfo) {\n-\t\ttry {\n-\t\t\tfinal int currentIndex = versions.indexOf(versioninfo.getVersion());\n-\t\t\tfinal boolean executeThisVersion = currentIndex >= startindex && currentIndex <= endindex;\n-\n-\t\t\tfinal String version = versioninfo.getVersion();\n-\t\t\tLOG.info(\"Bearbeite {} Mit Tests: {}\", version, executeThisVersion);\n-\n-\t\t\tfinal Set<TestCase> testcases = findTestcases(versioninfo);\n-\n-\t\t\tfor (final TestCase testcase : testcases) {\n-\t\t\t\tboolean executeThisTest = true;\n-\t\t\t\tif (test != null) {\n-\t\t\t\t\tif (!test.equals(testcase)) {\n-\t\t\t\t\t\texecuteThisTest = false;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tif (executeThisTest && executeThisVersion && lastTestcaseCalls.containsKey(testcase)) {\n-\t\t\t\t\tif (changedTests != null) {\n-\t\t\t\t\t\tfinal TestSet calls = changedTests.getVersions().get(version);\n-\t\t\t\t\t\tboolean hasChanges = false;\n-\t\t\t\t\t\tif (calls != null) {\n-\t\t\t\t\t\t\tfor (final Map.Entry<String, List<String>> clazzCalls : calls.entrySet()) {\n-\t\t\t\t\t\t\t\tif (clazzCalls.getKey().equals(testcase.getClazz()) && clazzCalls.getValue().contains(testcase.getMethod())) {\n-\t\t\t\t\t\t\t\t\thasChanges = true;\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tif (hasChanges) {\n-\t\t\t\t\t\t\tfinal String versionOld = lastTestcaseCalls.get(testcase);\n-\t\t\t\t\t\t\texecuteCompareTests(version, versionOld, testcase);\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tLOG.debug(\"Skipping \" + testcase + \" because of execution-JSON in \" + versioninfo.getVersion());\n-\t\t\t\t\t\t}\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tfinal String versionOld = lastTestcaseCalls.get(testcase);\n-\t\t\t\t\t\texecuteCompareTests(version, versionOld, testcase);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tlastTestcaseCalls.put(testcase, version);\n-\t\t\t}\n-\t\t} catch (IOException | InterruptedException | JAXBException e) {\n-\t\t\te.printStackTrace();\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Compares the given testcase for the given versions.\n-\t * \n-\t * @param version Current version to test\n-\t * @param versionOld Old version to test\n-\t * @param testcase Testcase to test\n-\t */\n-\tprotected void executeCompareTests(final String version, final String versionOld, final TestCase testcase) throws IOException, InterruptedException, JAXBException {\n-\t\tLOG.info(\"Executing test \" + testcase.getClazz() + \" \" + testcase.getMethod() + \" in versions {} and {}\", versionOld, version);\n-\n-\t\tFile logFile = new File(PeASSFolderUtil.getLogFolder(), version);\n-\t\tif (logFile.exists()) {\n-\t\t\tlogFile = new File(PeASSFolderUtil.getLogFolder(), version + \"_new\");\n-\t\t}\n-\t\tlogFile.mkdir();\n-\n-\t\tfinal TestSet testset = new TestSet();\n-\t\ttestset.addTest(testcase.getClazz(), testcase.getMethod());\n-\t\tfor (int vmid = 0; vmid < tester.getVMCount(); vmid++) {\n-\t\t\ttester.evaluateOnce(testset, versionOld, vmid, logFile);\n-\t\t\ttester.evaluateOnce(testset, version, vmid, logFile);\n-\t\t}\n-\t}\n-\n-\tpublic static void main(final String[] args) throws ParseException, JAXBException, IOException {\n-\t\tfinal DependencyTestPairStarter starter = new DependencyTestPairStarter(args);\n-\t\tstarter.processCommandline();\n-\t}\n-\n-}\n+\n+public class DependencyTestPairStarter extends PairProcessor {\n+ private static final Logger LOG = LogManager.getLogger(DependencyTestPairStarter.class);\n+ protected final DependencyTester tester;\n+ private final List<String> versions = new LinkedList<>();\n+ private final int startindex, endindex;\n+ private final ChangedTraceTests changedTests;\n+ private final TestCase test;\n+\n+ public DependencyTestPairStarter(final String[] args) throws ParseException, JAXBException, IOException {\n+  super(args);\n+  final int vms = Integer.parseInt(line.getOptionValue(OptionConstants.VMS.getName(), \"15\"));\n+  final int repetitions = Integer.parseInt(line.getOptionValue(OptionConstants.REPETITIONS.getName(), \"1\"));\n+  this.changedTests = loadChangedTests(line);\n+  boolean useKieker = Boolean.parseBoolean(line.getOptionValue(OptionConstants.USEKIEKER.getName(), \"false\"));\n+  if (line.hasOption(OptionConstants.DURATION.getName())) {\n+   final int duration = Integer.parseInt(line.getOptionValue(OptionConstants.DURATION.getName()));\n+   if (dependencies.getModule() != null) {\n+    final File moduleFolder = new File(projectFolder, dependencies.getModule());\n+    tester = new DependencyTester(projectFolder, moduleFolder, duration, vms, true, repetitions, useKieker);\n+   } else {\n+    tester = new DependencyTester(projectFolder, projectFolder, duration, vms, true, repetitions, useKieker);\n+   }\n+  } else {\n+   final int warmup = Integer.parseInt(line.getOptionValue(OptionConstants.WARMUP.getName(), \"10\"));\n+   final int iterationen = Integer.parseInt(line.getOptionValue(OptionConstants.ITERATIONS.getName(), \"10\"));\n+   tester = new DependencyTester(projectFolder, warmup, iterationen, vms, true, repetitions, useKieker);\n+  }\n+  if (line.hasOption(OptionConstants.TEST.getName())) {\n+   test = new TestCase(line.getOptionValue(OptionConstants.TEST.getName()));\n+  } else {\n+   test = null;\n+  }\n+  versions.add(dependencies.getInitialversion().getVersion());\n+  dependencies.getVersions().getVersion().forEach(version -> versions.add(version.getVersion()));\n+  startindex = getStartVersionIndex();\n+  endindex = getEndVersion();\n+ }\n+\n+\n+ public static ChangedTraceTests loadChangedTests(final CommandLine line) throws IOException, JsonParseException, JsonMappingException {\n+  final ChangedTraceTests changedTests;\n+  if (line.hasOption(OptionConstants.EXECUTIONFILE.getName())) {\n+   final ObjectMapper mapper = new ObjectMapper();\n+   ChangedTraceTests testsTemp;\n+   File executionFile = new File(line.getOptionValue(OptionConstants.EXECUTIONFILE.getName()));\n+   if (!executionFile.exists()) {\n+    throw new RuntimeException(\"Executionfile needs to exist\");\n+   }\n+   try {\n+    testsTemp = mapper.readValue(executionFile, ChangedTraceTests.class);\n+   } catch (final JsonMappingException e) {\n+    e.printStackTrace();\n+\n+    final ObjectMapper objectMapper = new ObjectMapper();\n+    final SimpleModule module = new SimpleModule();\n+    module.addDeserializer(ChangedTraceTests.class, new ChangedTraceTests.OldVersionDeserializer());\n+    objectMapper.registerModule(module);\n+    testsTemp = objectMapper.readValue(executionFile, ChangedTraceTests.class);\n+   }\n+   changedTests = testsTemp;\n+  } else {\n+   changedTests = null;\n+  }\n+  return changedTests;\n+ }\n+\n+ /**\n+  * Calculates the index of the start version\n+  * \n+  * @return index of the start version\n+  */\n+\n+ private int getStartVersionIndex() {\n+  int currentStartindex = startversion != null ? versions.indexOf(startversion) : 0;\n+  // Only bugfix if dependencyfile and executefile do not fully match\n+  if (changedTests != null) {\n+   if (startversion != null && currentStartindex == -1) {\n+    String potentialStart = \"\";\n+    if (changedTests.getVersions().containsKey(startversion)) {\n+     for (final String sicVersion : changedTests.getVersions().keySet()) {\n+      for (final Version ticVersion : dependencies.getVersions().getVersion()) {\n+       if (ticVersion.getVersion().equals(sicVersion)) {\n+        potentialStart = ticVersion.getVersion();\n+        break;\n+       }\n+      }\n+      if (sicVersion.equals(startversion)) {\n+       break;\n+      }\n+     }\n+    }\n+    LOG.debug(\"Version only in executefile, next version in dependencyfile: {}\", potentialStart);\n+    currentStartindex = versions.indexOf(potentialStart);\n+   }\n+  }\n+  return currentStartindex;\n+ }\n+\n+ /**\n+  * Calculates the index of the end version.\n+  * \n+  * @return index of the end version\n+  */\n+\n+ private int getEndVersion() {\n+  int currentEndindex = endversion != null ? versions.indexOf(endversion) : versions.size();\n+  // Only bugfix if dependencyfile and executefile do not fully match\n+  if (changedTests != null) {\n+   if (endversion != null && currentEndindex == -1) {\n+    String potentialStart = \"\";\n+    if (changedTests.getVersions().containsKey(endversion)) {\n+     for (final String sicVersion : changedTests.getVersions().keySet()) {\n+      boolean next = false;\n+      for (final Version ticVersion : dependencies.getVersions().getVersion()) {\n+       if (next) {\n+        potentialStart = ticVersion.getVersion();\n+        break;\n+       }\n+       if (ticVersion.getVersion().equals(sicVersion)) {\n+        next = true;\n+       }\n+      }\n+      if (sicVersion.equals(endversion)) {\n+       break;\n+      }\n+     }\n+    }\n+    LOG.debug(\"Version only in executefile, next version in dependencyfile: {}\", potentialStart);\n+    currentEndindex = versions.indexOf(potentialStart);\n+   }\n+  }\n+  return currentEndindex;\n+ }\n+\n+ @Override\n+ protected void processVersion(final Version versioninfo) {\n+  try {\n+   final int currentIndex = versions.indexOf(versioninfo.getVersion());\n+   final boolean executeThisVersion = currentIndex >= startindex && currentIndex <= endindex;\n+   final String version = versioninfo.getVersion();\n+   LOG.info(\"Bearbeite {} Mit Tests: {}\", version, executeThisVersion);\n+\n+   final Set<TestCase> testcases = findTestcases(versioninfo);\n+   for (final TestCase testcase : testcases) {\n+    boolean executeThisTest = true;\n+    if (test != null) {\n+     if (!test.equals(testcase)) {\n+      executeThisTest = false;\n+     }\n+    }\n+    if (executeThisTest && executeThisVersion && lastTestcaseCalls.containsKey(testcase)) {\n+     if (changedTests != null) {\n+      final TestSet calls = changedTests.getVersions().get(version);\n+      boolean hasChanges = false;\n+      if (calls != null) {\n+       for (final Map.Entry<String, List<String>> clazzCalls : calls.entrySet()) {\n+        if (clazzCalls.getKey().equals(testcase.getClazz()) && clazzCalls.getValue().contains(testcase.getMethod())) {\n+         hasChanges = true;\n+        }\n+       }\n+      }\n+      if (hasChanges) {\n+       final String versionOld = lastTestcaseCalls.get(testcase);\n+       executeCompareTests(version, versionOld, testcase);\n+      } else {\n+       LOG.debug(\"Skipping \" + testcase + \" because of execution-JSON in \" + versioninfo.getVersion());\n+      }\n+     } else {\n+      final String versionOld = lastTestcaseCalls.get(testcase);\n+      executeCompareTests(version, versionOld, testcase);\n+     }\n+    }\n+    lastTestcaseCalls.put(testcase, version);\n+   }\n+  } catch (IOException | InterruptedException | JAXBException e) {\n+   e.printStackTrace();\n+  }\n+ }\n+\n+ /**\n+  * Compares the given testcase for the given versions.\n+  * \n+  * @param version Current version to test\n+  * @param versionOld Old version to test\n+  * @param testcase Testcase to test\n+  */\n+\n+ protected void executeCompareTests(final String version, final String versionOld, final TestCase testcase) throws IOException, InterruptedException, JAXBException {\n+  LOG.info(\"Executing test \" + testcase.getClazz() + \" \" + testcase.getMethod() + \" in versions {} and {}\", versionOld, version);\n+\n+  File logFile = new File(PeASSFolderUtil.getLogFolder(), version);\n+  if (logFile.exists()) {\n+   logFile = new File(PeASSFolderUtil.getLogFolder(), version + \"_new\");\n+  }\n+  logFile.mkdir();\n+\n+  final TestSet testset = new TestSet();\n+  testset.addTest(testcase.getClazz(), testcase.getMethod());\n+  for (int vmid = 0; vmid < tester.getVMCount(); vmid++) {\n+   tester.evaluateOnce(testset, versionOld, vmid, logFile);\n+   tester.evaluateOnce(testset, version, vmid, logFile);\n+  }\n+ }\n+\n+ public static void main(final String[] args) throws ParseException, JAXBException, IOException {\n+  final DependencyTestPairStarter starter = new DependencyTestPairStarter(args);\n+  starter.processCommandline();\n+ }\n+}\n\\ No newline at end of file\n",
            "diff_size": 217
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/errored/1/36/DependencyTestPairStarter.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/styler_random/36/DependencyTestPairStarter.java\nindex e3561767c42..bfdb0fd7248 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/errored/1/36/DependencyTestPairStarter.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/styler_random/36/DependencyTestPairStarter.java\n@@ -86,7 +86,7 @@ public class DependencyTestPairStarter extends PairProcessor {\n \t\t\tfinal ObjectMapper mapper = new ObjectMapper();\n \t\t\tChangedTraceTests testsTemp;\n \t\t\tFile executionFile = new File(line.getOptionValue(OptionConstants.EXECUTIONFILE.getName()));\n-\t\t\tif (!executionFile.exists()){\n+\t\t\tif (!executionFile.exists()) {\n \t\t\t\tthrow new RuntimeException(\"Executionfile needs to exist\");\n \t\t\t}\n \t\t\ttry {\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/errored/1/36/DependencyTestPairStarter.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/styler_three_grams/36/DependencyTestPairStarter.java\nindex e3561767c42..bfdb0fd7248 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/errored/1/36/DependencyTestPairStarter.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/styler_three_grams/36/DependencyTestPairStarter.java\n@@ -86,7 +86,7 @@ public class DependencyTestPairStarter extends PairProcessor {\n \t\t\tfinal ObjectMapper mapper = new ObjectMapper();\n \t\t\tChangedTraceTests testsTemp;\n \t\t\tFile executionFile = new File(line.getOptionValue(OptionConstants.EXECUTIONFILE.getName()));\n-\t\t\tif (!executionFile.exists()){\n+\t\t\tif (!executionFile.exists()) {\n \t\t\t\tthrow new RuntimeException(\"Executionfile needs to exist\");\n \t\t\t}\n \t\t\ttry {\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": []
}