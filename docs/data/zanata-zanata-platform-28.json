{
    "project_name": "zanata-zanata-platform",
    "error_id": "28",
    "information": {
        "errors": [
            {
                "line": "140",
                "column": "32",
                "severity": "error",
                "message": "Don't use trailing comments.",
                "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
            }
        ]
    },
    "source_code": "                        documentUploadDAO.findById(uploadForm.getUploadId());\n                totalChunks = previousParts.getParts().size();\n                totalChunks++; // add final part\n                tempFile =\n                        Optional.of(util.combineToTempFileAndDeleteUploadRecord(\n                                previousParts, uploadForm));",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/28/SourceDocumentUpload.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/styler/28/SourceDocumentUpload.java\nindex 16d88367517..b5f4f306de9 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/28/SourceDocumentUpload.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/styler/28/SourceDocumentUpload.java\n@@ -137,8 +137,9 @@ public class SourceDocumentUpload implements Serializable {\n                 HDocumentUpload previousParts =\n                         documentUploadDAO.findById(uploadForm.getUploadId());\n                 totalChunks = previousParts.getParts().size();\n-                totalChunks++; // add final part\n-                tempFile =\n+                totalChunks++;\n+                // add final part\n+                 tempFile =\n                         Optional.of(util.combineToTempFileAndDeleteUploadRecord(\n                                 previousParts, uploadForm));\n             }\n",
            "diff_size": 3
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "141",
                    "column": "24",
                    "severity": "error",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/28/SourceDocumentUpload.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/intellij/28/SourceDocumentUpload.java\nindex 16d88367517..4fe60190d34 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/28/SourceDocumentUpload.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/intellij/28/SourceDocumentUpload.java\n@@ -18,6 +18,7 @@\n  * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n  * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n  */\n+\n package org.zanata.file;\n \n import static com.google.common.base.Strings.nullToEmpty;\n@@ -68,275 +69,275 @@ import com.google.common.base.Optional;\n @Dependent\n @Named(\"sourceDocumentUploader\")\n public class SourceDocumentUpload implements Serializable {\n-    private static final org.slf4j.Logger log =\n-            org.slf4j.LoggerFactory.getLogger(SourceDocumentUpload.class);\n+  private static final org.slf4j.Logger log =\n+    org.slf4j.LoggerFactory.getLogger(SourceDocumentUpload.class);\n \n-    private static final HLocale NULL_LOCALE = null;\n-    private static final long serialVersionUID = 130062917705942914L;\n-    @Inject\n-    private DocumentUploadUtil util;\n-    @Inject\n-    private FilePersistService filePersistService;\n-    @Inject\n-    private ZanataIdentity identity;\n-    @Inject\n-    private ProjectIterationDAO projectIterationDAO;\n-    @Inject\n-    private TranslationFileService translationFileServiceImpl;\n-    @Inject\n-    private VirusScanner virusScanner;\n-    @Inject\n-    private DocumentDAO documentDAO;\n-    @Inject\n-    private DocumentUploadDAO documentUploadDAO;\n-    @Inject\n-    private DocumentService documentServiceImpl;\n+  private static final HLocale NULL_LOCALE = null;\n+  private static final long serialVersionUID = 130062917705942914L;\n+  @Inject\n+  private DocumentUploadUtil util;\n+  @Inject\n+  private FilePersistService filePersistService;\n+  @Inject\n+  private ZanataIdentity identity;\n+  @Inject\n+  private ProjectIterationDAO projectIterationDAO;\n+  @Inject\n+  private TranslationFileService translationFileServiceImpl;\n+  @Inject\n+  private VirusScanner virusScanner;\n+  @Inject\n+  private DocumentDAO documentDAO;\n+  @Inject\n+  private DocumentUploadDAO documentUploadDAO;\n+  @Inject\n+  private DocumentService documentServiceImpl;\n \n-    public Response tryUploadSourceFileWithoutHash(GlobalDocumentId id,\n-            DocumentFileUploadForm uploadForm) {\n-        try {\n-            failIfSourceUploadNotValid(id, uploadForm);\n-        } catch (DocumentUploadException e) {\n-            return Response.status(e.getStatusCode())\n-                    .entity(new ChunkUploadResponse(e.getMessage())).build();\n-        }\n-        return tryValidatedUploadSourceFile(id, uploadForm);\n+  public Response tryUploadSourceFileWithoutHash(GlobalDocumentId id,\n+                                                 DocumentFileUploadForm uploadForm) {\n+    try {\n+      failIfSourceUploadNotValid(id, uploadForm);\n+    } catch (DocumentUploadException e) {\n+      return Response.status(e.getStatusCode())\n+        .entity(new ChunkUploadResponse(e.getMessage())).build();\n     }\n+    return tryValidatedUploadSourceFile(id, uploadForm);\n+  }\n \n-    public Response tryUploadSourceFile(GlobalDocumentId id,\n-            DocumentFileUploadForm uploadForm) {\n-        try {\n-            failIfSourceUploadNotValid(id, uploadForm);\n-            util.failIfHashNotPresent(uploadForm);\n-        } catch (DocumentUploadException e) {\n-            return Response.status(e.getStatusCode())\n-                    .entity(new ChunkUploadResponse(e.getMessage())).build();\n-        }\n-        return tryValidatedUploadSourceFile(id, uploadForm);\n+  public Response tryUploadSourceFile(GlobalDocumentId id,\n+                                      DocumentFileUploadForm uploadForm) {\n+    try {\n+      failIfSourceUploadNotValid(id, uploadForm);\n+      util.failIfHashNotPresent(uploadForm);\n+    } catch (DocumentUploadException e) {\n+      return Response.status(e.getStatusCode())\n+        .entity(new ChunkUploadResponse(e.getMessage())).build();\n     }\n+    return tryValidatedUploadSourceFile(id, uploadForm);\n+  }\n \n-    public Response tryValidatedUploadSourceFile(GlobalDocumentId id,\n-            DocumentFileUploadForm uploadForm) {\n-        try {\n-            Optional<File> tempFile;\n-            int totalChunks;\n-            if (!uploadForm.getLast()) {\n-                HDocumentUpload upload =\n-                        util.saveUploadPart(id, NULL_LOCALE, uploadForm);\n-                totalChunks = upload.getParts().size();\n-                return Response.status(Status.ACCEPTED)\n-                        .entity(new ChunkUploadResponse(upload.getId(),\n-                                totalChunks, true,\n-                                \"Chunk accepted, awaiting remaining chunks.\"))\n-                        .build();\n-            }\n-            if (isSinglePart(uploadForm)) {\n-                totalChunks = 1;\n-                tempFile = Optional.<File> absent();\n-            } else {\n-                HDocumentUpload previousParts =\n-                        documentUploadDAO.findById(uploadForm.getUploadId());\n-                totalChunks = previousParts.getParts().size();\n-                totalChunks++; // add final part\n-                tempFile =\n-                        Optional.of(util.combineToTempFileAndDeleteUploadRecord(\n-                                previousParts, uploadForm));\n-            }\n-            HProjectIteration version = projectIterationDAO\n-                    .getBySlug(id.getProjectSlug(), id.getVersionSlug());\n-            if (version == null) {\n-                throw new ZanataServiceException(\"Project version not found: \"\n-                        + id.getProjectSlug() + \" \" + id.getVersionSlug());\n-            }\n-            if (version.getProjectType() == ProjectType.File) {\n-                if (!tempFile.isPresent()) {\n-                    tempFile = Optional\n-                            .of(util.persistTempFileFromUpload(uploadForm));\n-                }\n-                processAdapterFile(tempFile.get(), id, uploadForm);\n-            } else if (DocumentType.getByName(\n-                    uploadForm.getFileType()) == DocumentType.GETTEXT) {\n-                InputStream potStream = getInputStream(tempFile, uploadForm);\n-                parsePotFile(potStream, id);\n-            } else {\n-                throw new ZanataServiceException(\n-                        \"Unsupported source file: \" + id.getDocId());\n-            }\n-            if (tempFile.isPresent()) {\n-                boolean deleted = tempFile.get().delete();\n-                if (deleted) {\n-                    log.debug(\"Temporary file deleted\");\n-                } else {\n-                    log.debug(\"Unable to delete temporary file\");\n-                }\n-            }\n-            return sourceUploadSuccessResponse(util.isNewDocument(id),\n-                    totalChunks);\n-        } catch (DocumentUploadException e) {\n-            return Response.status(e.getStatusCode())\n-                    .entity(new ChunkUploadResponse(e.getMessage())).build();\n-        } catch (FileNotFoundException e) {\n-            log.error(\"failed to create input stream from temp file\", e);\n-            return Response.status(Status.INTERNAL_SERVER_ERROR).entity(e)\n-                    .build();\n+  public Response tryValidatedUploadSourceFile(GlobalDocumentId id,\n+                                               DocumentFileUploadForm uploadForm) {\n+    try {\n+      Optional<File> tempFile;\n+      int totalChunks;\n+      if (!uploadForm.getLast()) {\n+        HDocumentUpload upload =\n+          util.saveUploadPart(id, NULL_LOCALE, uploadForm);\n+        totalChunks = upload.getParts().size();\n+        return Response.status(Status.ACCEPTED)\n+          .entity(new ChunkUploadResponse(upload.getId(),\n+            totalChunks, true,\n+            \"Chunk accepted, awaiting remaining chunks.\"))\n+          .build();\n+      }\n+      if (isSinglePart(uploadForm)) {\n+        totalChunks = 1;\n+        tempFile = Optional.<File>absent();\n+      } else {\n+        HDocumentUpload previousParts =\n+          documentUploadDAO.findById(uploadForm.getUploadId());\n+        totalChunks = previousParts.getParts().size();\n+        totalChunks++; // add final part\n+        tempFile =\n+          Optional.of(util.combineToTempFileAndDeleteUploadRecord(\n+            previousParts, uploadForm));\n+      }\n+      HProjectIteration version = projectIterationDAO\n+        .getBySlug(id.getProjectSlug(), id.getVersionSlug());\n+      if (version == null) {\n+        throw new ZanataServiceException(\"Project version not found: \"\n+          + id.getProjectSlug() + \" \" + id.getVersionSlug());\n+      }\n+      if (version.getProjectType() == ProjectType.File) {\n+        if (!tempFile.isPresent()) {\n+          tempFile = Optional\n+            .of(util.persistTempFileFromUpload(uploadForm));\n         }\n+        processAdapterFile(tempFile.get(), id, uploadForm);\n+      } else if (DocumentType.getByName(\n+        uploadForm.getFileType()) == DocumentType.GETTEXT) {\n+        InputStream potStream = getInputStream(tempFile, uploadForm);\n+        parsePotFile(potStream, id);\n+      } else {\n+        throw new ZanataServiceException(\n+          \"Unsupported source file: \" + id.getDocId());\n+      }\n+      if (tempFile.isPresent()) {\n+        boolean deleted = tempFile.get().delete();\n+        if (deleted) {\n+          log.debug(\"Temporary file deleted\");\n+        } else {\n+          log.debug(\"Unable to delete temporary file\");\n+        }\n+      }\n+      return sourceUploadSuccessResponse(util.isNewDocument(id),\n+        totalChunks);\n+    } catch (DocumentUploadException e) {\n+      return Response.status(e.getStatusCode())\n+        .entity(new ChunkUploadResponse(e.getMessage())).build();\n+    } catch (FileNotFoundException e) {\n+      log.error(\"failed to create input stream from temp file\", e);\n+      return Response.status(Status.INTERNAL_SERVER_ERROR).entity(e)\n+        .build();\n     }\n+  }\n \n-    private void failIfSourceUploadNotValid(GlobalDocumentId id,\n-            DocumentFileUploadForm uploadForm) throws DocumentUploadException {\n-        util.failIfUploadNotValid(id, uploadForm);\n-        failIfSourceUploadNotAllowed(id);\n-        failIfFileTypeNotValid(uploadForm);\n-    }\n+  private void failIfSourceUploadNotValid(GlobalDocumentId id,\n+                                          DocumentFileUploadForm uploadForm) throws DocumentUploadException {\n+    util.failIfUploadNotValid(id, uploadForm);\n+    failIfSourceUploadNotAllowed(id);\n+    failIfFileTypeNotValid(uploadForm);\n+  }\n \n-    private void failIfSourceUploadNotAllowed(GlobalDocumentId id)\n-            throws DocumentUploadException {\n-        if (!isDocumentUploadAllowed(id)) {\n-            throw new DocumentUploadException(Status.FORBIDDEN,\n-                    \"You do not have permission to upload source documents to project-version \\\"\"\n-                            + id.getProjectSlug() + \":\" + id.getVersionSlug()\n-                            + \"\\\".\");\n-        }\n+  private void failIfSourceUploadNotAllowed(GlobalDocumentId id)\n+    throws DocumentUploadException {\n+    if (!isDocumentUploadAllowed(id)) {\n+      throw new DocumentUploadException(Status.FORBIDDEN,\n+        \"You do not have permission to upload source documents to project-version \\\"\"\n+          + id.getProjectSlug() + \":\" + id.getVersionSlug()\n+          + \"\\\".\");\n     }\n+  }\n \n-    private boolean isDocumentUploadAllowed(GlobalDocumentId id) {\n-        HProjectIteration projectIteration = projectIterationDAO\n-                .getBySlug(id.getProjectSlug(), id.getVersionSlug());\n-        return projectIteration.getStatus() == EntityStatus.ACTIVE\n-                && projectIteration.getProject()\n-                        .getStatus() == EntityStatus.ACTIVE\n-                && identity != null && identity.hasPermissionWithAnyTargets(\n-                        \"import-template\", projectIteration);\n-    }\n+  private boolean isDocumentUploadAllowed(GlobalDocumentId id) {\n+    HProjectIteration projectIteration = projectIterationDAO\n+      .getBySlug(id.getProjectSlug(), id.getVersionSlug());\n+    return projectIteration.getStatus() == EntityStatus.ACTIVE\n+      && projectIteration.getProject()\n+      .getStatus() == EntityStatus.ACTIVE\n+      && identity != null && identity.hasPermissionWithAnyTargets(\n+      \"import-template\", projectIteration);\n+  }\n \n-    private void failIfFileTypeNotValid(DocumentFileUploadForm uploadForm)\n-            throws DocumentUploadException {\n-        DocumentType type = DocumentType.getByName(uploadForm.getFileType());\n-        if (!isSourceDocumentType(type)) {\n-            throw new DocumentUploadException(Status.BAD_REQUEST, \"The type \\\"\"\n-                    + uploadForm.getFileType()\n-                    + \"\\\" specified in form parameter \\'type\\' is not valid for a source file on this server.\");\n-        }\n+  private void failIfFileTypeNotValid(DocumentFileUploadForm uploadForm)\n+    throws DocumentUploadException {\n+    DocumentType type = DocumentType.getByName(uploadForm.getFileType());\n+    if (!isSourceDocumentType(type)) {\n+      throw new DocumentUploadException(Status.BAD_REQUEST, \"The type \\\"\"\n+        + uploadForm.getFileType()\n+        + \"\\\" specified in form parameter \\'type\\' is not valid for a source file on this server.\");\n     }\n+  }\n \n-    private boolean isSourceDocumentType(DocumentType type) {\n-        return isPotType(type) || isAdapterType(type);\n-    }\n+  private boolean isSourceDocumentType(DocumentType type) {\n+    return isPotType(type) || isAdapterType(type);\n+  }\n \n-    private boolean isPotType(DocumentType type) {\n-        return type == DocumentType.GETTEXT;\n-    }\n+  private boolean isPotType(DocumentType type) {\n+    return type == DocumentType.GETTEXT;\n+  }\n \n-    private boolean isAdapterType(DocumentType type) {\n-        return translationFileServiceImpl.hasAdapterFor(type);\n-    }\n+  private boolean isAdapterType(DocumentType type) {\n+    return translationFileServiceImpl.hasAdapterFor(type);\n+  }\n \n-    private static Response sourceUploadSuccessResponse(boolean isNewDocument,\n-            int acceptedChunks) {\n-        Response response;\n-        ChunkUploadResponse uploadResponse = new ChunkUploadResponse();\n-        uploadResponse.setAcceptedChunks(acceptedChunks);\n-        uploadResponse.setExpectingMore(false);\n-        if (isNewDocument) {\n-            uploadResponse.setSuccessMessage(\n-                    \"Upload of new source document successful.\");\n-            response = Response.status(Status.CREATED).entity(uploadResponse)\n-                    .build();\n-        } else {\n-            uploadResponse.setSuccessMessage(\n-                    \"Upload of new version of source document successful.\");\n-            response =\n-                    Response.status(Status.OK).entity(uploadResponse).build();\n-        }\n-        return response;\n+  private static Response sourceUploadSuccessResponse(boolean isNewDocument,\n+                                                      int acceptedChunks) {\n+    Response response;\n+    ChunkUploadResponse uploadResponse = new ChunkUploadResponse();\n+    uploadResponse.setAcceptedChunks(acceptedChunks);\n+    uploadResponse.setExpectingMore(false);\n+    if (isNewDocument) {\n+      uploadResponse.setSuccessMessage(\n+        \"Upload of new source document successful.\");\n+      response = Response.status(Status.CREATED).entity(uploadResponse)\n+        .build();\n+    } else {\n+      uploadResponse.setSuccessMessage(\n+        \"Upload of new version of source document successful.\");\n+      response =\n+        Response.status(Status.OK).entity(uploadResponse).build();\n     }\n+    return response;\n+  }\n \n-    private void processAdapterFile(@Nonnull File tempFile, GlobalDocumentId id,\n-            DocumentFileUploadForm uploadForm) {\n-        String name = id.getProjectSlug() + \":\" + id.getVersionSlug() + \":\"\n-                + id.getDocId();\n-        try {\n-            virusScanner.scan(tempFile, name);\n-        } catch (VirusDetectedException e) {\n-            log.warn(\"File failed virus scan: {}\", e.getMessage());\n-            throw new DocumentUploadException(Status.BAD_REQUEST,\n-                    \"Uploaded file did not pass virus scan\");\n-        }\n-        HDocument document;\n-        String params = nullToEmpty(uploadForm.getAdapterParams());\n-        if (params.isEmpty()) {\n-            params = documentDAO.getAdapterParams(id.getProjectSlug(),\n-                    id.getVersionSlug(), id.getDocId());\n-        }\n-        try {\n-            Optional<String> docType =\n-                    Optional.fromNullable(uploadForm.getFileType());\n-            LocaleId locale = LocaleId.EN_US;\n-            Resource doc =\n-                    translationFileServiceImpl.parseUpdatedAdapterDocumentFile(\n-                            id.getDocId(),\n-                            uploadForm.getFileType(),\n-                            new FileFormatAdapter.ParserOptions(tempFile.toURI(),\n-                                    locale, params),\n-                            docType);\n-            doc.setLang(locale);\n-            // TODO Copy Trans values\n-            document = documentServiceImpl.saveDocument(id.getProjectSlug(),\n-                    id.getVersionSlug(), doc,\n-                    Sets.newHashSet(PotEntryHeader.ID, SimpleComment.ID),\n-                    false);\n-        } catch (SecurityException | ZanataServiceException e) {\n-            throw new DocumentUploadException(Status.INTERNAL_SERVER_ERROR,\n-                    e.getMessage(), e);\n-        }\n-        String contentHash = uploadForm.getHash();\n-        DocumentType documentType =\n-                DocumentType.getByName(uploadForm.getFileType());\n-        persistRawDocument(document, tempFile, contentHash, documentType,\n-                params);\n-        translationFileServiceImpl.removeTempFile(tempFile);\n+  private void processAdapterFile(@Nonnull File tempFile, GlobalDocumentId id,\n+                                  DocumentFileUploadForm uploadForm) {\n+    String name = id.getProjectSlug() + \":\" + id.getVersionSlug() + \":\"\n+      + id.getDocId();\n+    try {\n+      virusScanner.scan(tempFile, name);\n+    } catch (VirusDetectedException e) {\n+      log.warn(\"File failed virus scan: {}\", e.getMessage());\n+      throw new DocumentUploadException(Status.BAD_REQUEST,\n+        \"Uploaded file did not pass virus scan\");\n     }\n-\n-    private void persistRawDocument(HDocument document, File rawFile,\n-            String contentHash, DocumentType documentType,\n-            String params) {\n-        HRawDocument rawDocument = new HRawDocument();\n-        rawDocument.setDocument(document);\n-        rawDocument.setContentHash(contentHash);\n-        rawDocument.setType(documentType);\n-        rawDocument.setUploadedBy(identity.getCredentials().getUsername());\n-        filePersistService.persistRawDocumentContentFromFile(rawDocument,\n-                rawFile, FilenameUtils.getExtension(rawFile.getName()));\n-        if (!params.isEmpty()) {\n-            rawDocument.setAdapterParameters(params);\n-        }\n-        documentDAO.addRawDocument(document, rawDocument);\n-        documentDAO.flush();\n+    HDocument document;\n+    String params = nullToEmpty(uploadForm.getAdapterParams());\n+    if (params.isEmpty()) {\n+      params = documentDAO.getAdapterParams(id.getProjectSlug(),\n+        id.getVersionSlug(), id.getDocId());\n     }\n-\n-    /**\n-     * This method should only process gettext project type\n-     *\n-     * @param potStream\n-     * @param id\n-     */\n-    private void parsePotFile(InputStream potStream, GlobalDocumentId id) {\n-        // remove .pot extension from docId as per zanata-cli\n-        String docIdWithoutExtension =\n-                FilenameUtils.removeExtension(id.getDocId());\n-        Resource doc = translationFileServiceImpl.parseUpdatedPotFile(potStream,\n-                docIdWithoutExtension, \".pot\", useOfflinePo(id));\n-        doc.setLang(LocaleId.EN_US);\n-        // TODO Copy Trans values\n-        StringSet extensions = new StringSet(ExtensionType.GetText.toString());\n-        extensions.add(SimpleComment.ID);\n-        documentServiceImpl.saveDocument(id.getProjectSlug(),\n-                id.getVersionSlug(), doc, extensions, false);\n+    try {\n+      Optional<String> docType =\n+        Optional.fromNullable(uploadForm.getFileType());\n+      LocaleId locale = LocaleId.EN_US;\n+      Resource doc =\n+        translationFileServiceImpl.parseUpdatedAdapterDocumentFile(\n+          id.getDocId(),\n+          uploadForm.getFileType(),\n+          new FileFormatAdapter.ParserOptions(tempFile.toURI(),\n+            locale, params),\n+          docType);\n+      doc.setLang(locale);\n+      // TODO Copy Trans values\n+      document = documentServiceImpl.saveDocument(id.getProjectSlug(),\n+        id.getVersionSlug(), doc,\n+        Sets.newHashSet(PotEntryHeader.ID, SimpleComment.ID),\n+        false);\n+    } catch (SecurityException | ZanataServiceException e) {\n+      throw new DocumentUploadException(Status.INTERNAL_SERVER_ERROR,\n+        e.getMessage(), e);\n     }\n+    String contentHash = uploadForm.getHash();\n+    DocumentType documentType =\n+      DocumentType.getByName(uploadForm.getFileType());\n+    persistRawDocument(document, tempFile, contentHash, documentType,\n+      params);\n+    translationFileServiceImpl.removeTempFile(tempFile);\n+  }\n \n-    private boolean useOfflinePo(GlobalDocumentId id) {\n-        return !util.isNewDocument(id)\n-                && !translationFileServiceImpl.isPoDocument(id.getProjectSlug(),\n-                        id.getVersionSlug(), id.getDocId());\n+  private void persistRawDocument(HDocument document, File rawFile,\n+                                  String contentHash, DocumentType documentType,\n+                                  String params) {\n+    HRawDocument rawDocument = new HRawDocument();\n+    rawDocument.setDocument(document);\n+    rawDocument.setContentHash(contentHash);\n+    rawDocument.setType(documentType);\n+    rawDocument.setUploadedBy(identity.getCredentials().getUsername());\n+    filePersistService.persistRawDocumentContentFromFile(rawDocument,\n+      rawFile, FilenameUtils.getExtension(rawFile.getName()));\n+    if (!params.isEmpty()) {\n+      rawDocument.setAdapterParameters(params);\n     }\n+    documentDAO.addRawDocument(document, rawDocument);\n+    documentDAO.flush();\n+  }\n+\n+  /**\n+   * This method should only process gettext project type\n+   *\n+   * @param potStream\n+   * @param id\n+   */\n+  private void parsePotFile(InputStream potStream, GlobalDocumentId id) {\n+    // remove .pot extension from docId as per zanata-cli\n+    String docIdWithoutExtension =\n+      FilenameUtils.removeExtension(id.getDocId());\n+    Resource doc = translationFileServiceImpl.parseUpdatedPotFile(potStream,\n+      docIdWithoutExtension, \".pot\", useOfflinePo(id));\n+    doc.setLang(LocaleId.EN_US);\n+    // TODO Copy Trans values\n+    StringSet extensions = new StringSet(ExtensionType.GetText.toString());\n+    extensions.add(SimpleComment.ID);\n+    documentServiceImpl.saveDocument(id.getProjectSlug(),\n+      id.getVersionSlug(), doc, extensions, false);\n+  }\n+\n+  private boolean useOfflinePo(GlobalDocumentId id) {\n+    return !util.isNewDocument(id)\n+      && !translationFileServiceImpl.isPoDocument(id.getProjectSlug(),\n+      id.getVersionSlug(), id.getDocId());\n+  }\n }\n",
            "diff_size": 327
        },
        {
            "tool": "naturalize",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/28/SourceDocumentUpload.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/naturalize/28/SourceDocumentUpload.java\nindex 16d88367517..851963f29d7 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/28/SourceDocumentUpload.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/naturalize/28/SourceDocumentUpload.java\n@@ -137,7 +137,9 @@ public class SourceDocumentUpload implements Serializable {\n                 HDocumentUpload previousParts =\n                         documentUploadDAO.findById(uploadForm.getUploadId());\n                 totalChunks = previousParts.getParts().size();\n-                totalChunks++; // add final part\n+                totalChunks++;\n+\n+// add final part\n                 tempFile =\n                         Optional.of(util.combineToTempFileAndDeleteUploadRecord(\n                                 previousParts, uploadForm));\n@@ -204,8 +206,7 @@ public class SourceDocumentUpload implements Serializable {\n                 .getBySlug(id.getProjectSlug(), id.getVersionSlug());\n         return projectIteration.getStatus() == EntityStatus.ACTIVE\n                 && projectIteration.getProject()\n-                        .getStatus() == EntityStatus.ACTIVE\n-                && identity != null && identity.hasPermissionWithAnyTargets(\n+                        .getStatus() == EntityStatus.ACTIVE && identity != null && identity.hasPermissionWithAnyTargets(\n                         \"import-template\", projectIteration);\n     }\n \n@@ -339,4 +340,4 @@ public class SourceDocumentUpload implements Serializable {\n                 && !translationFileServiceImpl.isPoDocument(id.getProjectSlug(),\n                         id.getVersionSlug(), id.getDocId());\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 6
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "128",
                    "column": "32",
                    "severity": "error",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/28/SourceDocumentUpload.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/codebuff/28/SourceDocumentUpload.java\nindex 16d88367517..76165f6bdea 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/28/SourceDocumentUpload.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/codebuff/28/SourceDocumentUpload.java\n@@ -23,6 +23,7 @@ package org.zanata.file;\n import static com.google.common.base.Strings.nullToEmpty;\n import static org.zanata.file.DocumentUploadUtil.getInputStream;\n import static org.zanata.file.DocumentUploadUtil.isSinglePart;\n+\n import java.io.File;\n import java.io.FileNotFoundException;\n import java.io.InputStream;\n@@ -35,7 +36,6 @@ import com.google.common.collect.Sets;\n import org.apache.commons.io.FilenameUtils;\n import javax.inject.Inject;\n import javax.inject.Named;\n-\n import org.zanata.adapter.FileFormatAdapter;\n import org.zanata.common.DocumentType;\n import org.zanata.common.EntityStatus;\n@@ -65,12 +65,11 @@ import org.zanata.service.DocumentService;\n import org.zanata.service.TranslationFileService;\n import com.google.common.base.Optional;\n \n+\n @Dependent\n @Named(\"sourceDocumentUploader\")\n public class SourceDocumentUpload implements Serializable {\n-    private static final org.slf4j.Logger log =\n-            org.slf4j.LoggerFactory.getLogger(SourceDocumentUpload.class);\n-\n+    private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(SourceDocumentUpload.class);\n     private static final HLocale NULL_LOCALE = null;\n     private static final long serialVersionUID = 130062917705942914L;\n     @Inject\n@@ -91,76 +90,58 @@ public class SourceDocumentUpload implements Serializable {\n     private DocumentUploadDAO documentUploadDAO;\n     @Inject\n     private DocumentService documentServiceImpl;\n-\n-    public Response tryUploadSourceFileWithoutHash(GlobalDocumentId id,\n-            DocumentFileUploadForm uploadForm) {\n+    public Response tryUploadSourceFileWithoutHash(GlobalDocumentId id, DocumentFileUploadForm uploadForm) {\n         try {\n             failIfSourceUploadNotValid(id, uploadForm);\n         } catch (DocumentUploadException e) {\n-            return Response.status(e.getStatusCode())\n-                    .entity(new ChunkUploadResponse(e.getMessage())).build();\n+            return Response.status(e.getStatusCode()).entity(new ChunkUploadResponse(e.getMessage())).build();\n         }\n         return tryValidatedUploadSourceFile(id, uploadForm);\n     }\n \n-    public Response tryUploadSourceFile(GlobalDocumentId id,\n-            DocumentFileUploadForm uploadForm) {\n+    public Response tryUploadSourceFile(GlobalDocumentId id, DocumentFileUploadForm uploadForm) {\n         try {\n             failIfSourceUploadNotValid(id, uploadForm);\n             util.failIfHashNotPresent(uploadForm);\n         } catch (DocumentUploadException e) {\n-            return Response.status(e.getStatusCode())\n-                    .entity(new ChunkUploadResponse(e.getMessage())).build();\n+            return Response.status(e.getStatusCode()).entity(new ChunkUploadResponse(e.getMessage())).build();\n         }\n         return tryValidatedUploadSourceFile(id, uploadForm);\n     }\n \n-    public Response tryValidatedUploadSourceFile(GlobalDocumentId id,\n-            DocumentFileUploadForm uploadForm) {\n+    public Response tryValidatedUploadSourceFile(GlobalDocumentId id, DocumentFileUploadForm uploadForm) {\n         try {\n             Optional<File> tempFile;\n             int totalChunks;\n             if (!uploadForm.getLast()) {\n-                HDocumentUpload upload =\n-                        util.saveUploadPart(id, NULL_LOCALE, uploadForm);\n+                HDocumentUpload upload = util.saveUploadPart(id, NULL_LOCALE, uploadForm);\n                 totalChunks = upload.getParts().size();\n-                return Response.status(Status.ACCEPTED)\n-                        .entity(new ChunkUploadResponse(upload.getId(),\n-                                totalChunks, true,\n-                                \"Chunk accepted, awaiting remaining chunks.\"))\n-                        .build();\n+                return Response.status(Status.ACCEPTED).entity(new ChunkUploadResponse(upload.getId(), totalChunks, true,\n+                                                                                       \"Chunk accepted, awaiting remaining chunks.\")).build();\n             }\n             if (isSinglePart(uploadForm)) {\n                 totalChunks = 1;\n                 tempFile = Optional.<File> absent();\n             } else {\n-                HDocumentUpload previousParts =\n-                        documentUploadDAO.findById(uploadForm.getUploadId());\n+                HDocumentUpload previousParts = documentUploadDAO.findById(uploadForm.getUploadId());\n                 totalChunks = previousParts.getParts().size();\n                 totalChunks++; // add final part\n-                tempFile =\n-                        Optional.of(util.combineToTempFileAndDeleteUploadRecord(\n-                                previousParts, uploadForm));\n+                tempFile = Optional.of(util.combineToTempFileAndDeleteUploadRecord(previousParts, uploadForm));\n             }\n-            HProjectIteration version = projectIterationDAO\n-                    .getBySlug(id.getProjectSlug(), id.getVersionSlug());\n+            HProjectIteration version = projectIterationDAO.getBySlug(id.getProjectSlug(), id.getVersionSlug());\n             if (version == null) {\n-                throw new ZanataServiceException(\"Project version not found: \"\n-                        + id.getProjectSlug() + \" \" + id.getVersionSlug());\n+                throw new ZanataServiceException(\"Project version not found: \" + id.getProjectSlug() + \" \" + id.getVersionSlug());\n             }\n             if (version.getProjectType() == ProjectType.File) {\n                 if (!tempFile.isPresent()) {\n-                    tempFile = Optional\n-                            .of(util.persistTempFileFromUpload(uploadForm));\n+                    tempFile = Optional.of(util.persistTempFileFromUpload(uploadForm));\n                 }\n                 processAdapterFile(tempFile.get(), id, uploadForm);\n-            } else if (DocumentType.getByName(\n-                    uploadForm.getFileType()) == DocumentType.GETTEXT) {\n+            } else if (DocumentType.getByName(uploadForm.getFileType()) == DocumentType.GETTEXT) {\n                 InputStream potStream = getInputStream(tempFile, uploadForm);\n                 parsePotFile(potStream, id);\n             } else {\n-                throw new ZanataServiceException(\n-                        \"Unsupported source file: \" + id.getDocId());\n+                throw new ZanataServiceException(\"Unsupported source file: \" + id.getDocId());\n             }\n             if (tempFile.isPresent()) {\n                 boolean deleted = tempFile.get().delete();\n@@ -170,52 +151,37 @@ public class SourceDocumentUpload implements Serializable {\n                     log.debug(\"Unable to delete temporary file\");\n                 }\n             }\n-            return sourceUploadSuccessResponse(util.isNewDocument(id),\n-                    totalChunks);\n+            return sourceUploadSuccessResponse(util.isNewDocument(id), totalChunks);\n         } catch (DocumentUploadException e) {\n-            return Response.status(e.getStatusCode())\n-                    .entity(new ChunkUploadResponse(e.getMessage())).build();\n+            return Response.status(e.getStatusCode()).entity(new ChunkUploadResponse(e.getMessage())).build();\n         } catch (FileNotFoundException e) {\n             log.error(\"failed to create input stream from temp file\", e);\n-            return Response.status(Status.INTERNAL_SERVER_ERROR).entity(e)\n-                    .build();\n+            return Response.status(Status.INTERNAL_SERVER_ERROR).entity(e).build();\n         }\n     }\n \n-    private void failIfSourceUploadNotValid(GlobalDocumentId id,\n-            DocumentFileUploadForm uploadForm) throws DocumentUploadException {\n+    private void failIfSourceUploadNotValid(GlobalDocumentId id, DocumentFileUploadForm uploadForm) throws DocumentUploadException {\n         util.failIfUploadNotValid(id, uploadForm);\n         failIfSourceUploadNotAllowed(id);\n         failIfFileTypeNotValid(uploadForm);\n     }\n \n-    private void failIfSourceUploadNotAllowed(GlobalDocumentId id)\n-            throws DocumentUploadException {\n+    private void failIfSourceUploadNotAllowed(GlobalDocumentId id) throws DocumentUploadException {\n         if (!isDocumentUploadAllowed(id)) {\n-            throw new DocumentUploadException(Status.FORBIDDEN,\n-                    \"You do not have permission to upload source documents to project-version \\\"\"\n-                            + id.getProjectSlug() + \":\" + id.getVersionSlug()\n-                            + \"\\\".\");\n+            throw new DocumentUploadException(Status.FORBIDDEN, \"You do not have permission to upload source documents to project-version \\\"\" + id.getProjectSlug() + \":\" + id.getVersionSlug() + \"\\\".\");\n         }\n     }\n \n     private boolean isDocumentUploadAllowed(GlobalDocumentId id) {\n-        HProjectIteration projectIteration = projectIterationDAO\n-                .getBySlug(id.getProjectSlug(), id.getVersionSlug());\n-        return projectIteration.getStatus() == EntityStatus.ACTIVE\n-                && projectIteration.getProject()\n-                        .getStatus() == EntityStatus.ACTIVE\n-                && identity != null && identity.hasPermissionWithAnyTargets(\n-                        \"import-template\", projectIteration);\n+        HProjectIteration projectIteration = projectIterationDAO.getBySlug(id.getProjectSlug(), id.getVersionSlug());\n+        return projectIteration.getStatus() == EntityStatus.ACTIVE && projectIteration.getProject().getStatus() == EntityStatus.ACTIVE && identity != null\n+        && identity.hasPermissionWithAnyTargets(\"import-template\", projectIteration);\n     }\n \n-    private void failIfFileTypeNotValid(DocumentFileUploadForm uploadForm)\n-            throws DocumentUploadException {\n+    private void failIfFileTypeNotValid(DocumentFileUploadForm uploadForm) throws DocumentUploadException {\n         DocumentType type = DocumentType.getByName(uploadForm.getFileType());\n         if (!isSourceDocumentType(type)) {\n-            throw new DocumentUploadException(Status.BAD_REQUEST, \"The type \\\"\"\n-                    + uploadForm.getFileType()\n-                    + \"\\\" specified in form parameter \\'type\\' is not valid for a source file on this server.\");\n+            throw new DocumentUploadException(Status.BAD_REQUEST, \"The type \\\"\" + uploadForm.getFileType() + \"\\\" specified in form parameter \\'type\\' is not valid for a source file on this server.\");\n         }\n     }\n \n@@ -231,82 +197,62 @@ public class SourceDocumentUpload implements Serializable {\n         return translationFileServiceImpl.hasAdapterFor(type);\n     }\n \n-    private static Response sourceUploadSuccessResponse(boolean isNewDocument,\n-            int acceptedChunks) {\n+    private static Response sourceUploadSuccessResponse(boolean isNewDocument, int acceptedChunks) {\n         Response response;\n         ChunkUploadResponse uploadResponse = new ChunkUploadResponse();\n         uploadResponse.setAcceptedChunks(acceptedChunks);\n         uploadResponse.setExpectingMore(false);\n         if (isNewDocument) {\n-            uploadResponse.setSuccessMessage(\n-                    \"Upload of new source document successful.\");\n-            response = Response.status(Status.CREATED).entity(uploadResponse)\n-                    .build();\n+            uploadResponse.setSuccessMessage(\"Upload of new source document successful.\");\n+            response = Response.status(Status.CREATED).entity(uploadResponse).build();\n         } else {\n-            uploadResponse.setSuccessMessage(\n-                    \"Upload of new version of source document successful.\");\n-            response =\n-                    Response.status(Status.OK).entity(uploadResponse).build();\n+            uploadResponse.setSuccessMessage(\"Upload of new version of source document successful.\");\n+            response = Response.status(Status.OK).entity(uploadResponse).build();\n         }\n         return response;\n     }\n \n-    private void processAdapterFile(@Nonnull File tempFile, GlobalDocumentId id,\n-            DocumentFileUploadForm uploadForm) {\n-        String name = id.getProjectSlug() + \":\" + id.getVersionSlug() + \":\"\n-                + id.getDocId();\n+    private void processAdapterFile(\n+            @Nonnull File tempFile, GlobalDocumentId id, DocumentFileUploadForm uploadForm) {\n+        String name = id.getProjectSlug() + \":\" + id.getVersionSlug() + \":\" + id.getDocId();\n         try {\n             virusScanner.scan(tempFile, name);\n         } catch (VirusDetectedException e) {\n             log.warn(\"File failed virus scan: {}\", e.getMessage());\n             throw new DocumentUploadException(Status.BAD_REQUEST,\n-                    \"Uploaded file did not pass virus scan\");\n+                                              \"Uploaded file did not pass virus scan\");\n         }\n         HDocument document;\n         String params = nullToEmpty(uploadForm.getAdapterParams());\n         if (params.isEmpty()) {\n-            params = documentDAO.getAdapterParams(id.getProjectSlug(),\n-                    id.getVersionSlug(), id.getDocId());\n+            params = documentDAO.getAdapterParams(id.getProjectSlug(), id.getVersionSlug(), id.getDocId());\n         }\n         try {\n-            Optional<String> docType =\n-                    Optional.fromNullable(uploadForm.getFileType());\n+            Optional<String> docType = Optional.fromNullable(uploadForm.getFileType());\n             LocaleId locale = LocaleId.EN_US;\n-            Resource doc =\n-                    translationFileServiceImpl.parseUpdatedAdapterDocumentFile(\n-                            id.getDocId(),\n-                            uploadForm.getFileType(),\n-                            new FileFormatAdapter.ParserOptions(tempFile.toURI(),\n-                                    locale, params),\n-                            docType);\n+            Resource doc = translationFileServiceImpl.parseUpdatedAdapterDocumentFile(id.getDocId(), uploadForm.getFileType(), new FileFormatAdapter.ParserOptions(tempFile.toURI(), locale, params), docType);\n             doc.setLang(locale);\n             // TODO Copy Trans values\n-            document = documentServiceImpl.saveDocument(id.getProjectSlug(),\n-                    id.getVersionSlug(), doc,\n-                    Sets.newHashSet(PotEntryHeader.ID, SimpleComment.ID),\n-                    false);\n+            document = documentServiceImpl.saveDocument(id.getProjectSlug(), id.getVersionSlug(), doc, Sets.newHashSet(PotEntryHeader.ID, SimpleComment.ID), false);\n         } catch (SecurityException | ZanataServiceException e) {\n-            throw new DocumentUploadException(Status.INTERNAL_SERVER_ERROR,\n-                    e.getMessage(), e);\n+            throw new DocumentUploadException(Status.INTERNAL_SERVER_ERROR, e.getMessage(), e);\n         }\n         String contentHash = uploadForm.getHash();\n-        DocumentType documentType =\n-                DocumentType.getByName(uploadForm.getFileType());\n-        persistRawDocument(document, tempFile, contentHash, documentType,\n-                params);\n+        DocumentType documentType = DocumentType.getByName(uploadForm.getFileType());\n+        persistRawDocument(document, tempFile, contentHash, documentType, params);\n         translationFileServiceImpl.removeTempFile(tempFile);\n     }\n \n-    private void persistRawDocument(HDocument document, File rawFile,\n-            String contentHash, DocumentType documentType,\n-            String params) {\n+    private void persistRawDocument(HDocument document,\n+            File rawFile,\n+            String contentHash,\n+            DocumentType documentType, String params) {\n         HRawDocument rawDocument = new HRawDocument();\n         rawDocument.setDocument(document);\n         rawDocument.setContentHash(contentHash);\n         rawDocument.setType(documentType);\n         rawDocument.setUploadedBy(identity.getCredentials().getUsername());\n-        filePersistService.persistRawDocumentContentFromFile(rawDocument,\n-                rawFile, FilenameUtils.getExtension(rawFile.getName()));\n+        filePersistService.persistRawDocumentContentFromFile(rawDocument, rawFile, FilenameUtils.getExtension(rawFile.getName()));\n         if (!params.isEmpty()) {\n             rawDocument.setAdapterParameters(params);\n         }\n@@ -320,23 +266,20 @@ public class SourceDocumentUpload implements Serializable {\n      * @param potStream\n      * @param id\n      */\n+\n     private void parsePotFile(InputStream potStream, GlobalDocumentId id) {\n         // remove .pot extension from docId as per zanata-cli\n-        String docIdWithoutExtension =\n-                FilenameUtils.removeExtension(id.getDocId());\n-        Resource doc = translationFileServiceImpl.parseUpdatedPotFile(potStream,\n-                docIdWithoutExtension, \".pot\", useOfflinePo(id));\n+        String docIdWithoutExtension = FilenameUtils.removeExtension(id.getDocId());\n+        Resource doc = translationFileServiceImpl.parseUpdatedPotFile(potStream, docIdWithoutExtension,\n+                                                                      \".pot\", useOfflinePo(id));\n         doc.setLang(LocaleId.EN_US);\n         // TODO Copy Trans values\n         StringSet extensions = new StringSet(ExtensionType.GetText.toString());\n         extensions.add(SimpleComment.ID);\n-        documentServiceImpl.saveDocument(id.getProjectSlug(),\n-                id.getVersionSlug(), doc, extensions, false);\n+        documentServiceImpl.saveDocument(id.getProjectSlug(), id.getVersionSlug(), doc, extensions, false);\n     }\n \n     private boolean useOfflinePo(GlobalDocumentId id) {\n-        return !util.isNewDocument(id)\n-                && !translationFileServiceImpl.isPoDocument(id.getProjectSlug(),\n-                        id.getVersionSlug(), id.getDocId());\n+        return !util.isNewDocument(id) && !translationFileServiceImpl.isPoDocument(id.getProjectSlug(), id.getVersionSlug(), id.getDocId());\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 118
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "140",
                    "column": "32",
                    "severity": "error",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/28/SourceDocumentUpload.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/styler_three_grams/28/SourceDocumentUpload.java\nindex 16d88367517..b5f4f306de9 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/28/SourceDocumentUpload.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/styler_three_grams/28/SourceDocumentUpload.java\n@@ -137,8 +137,9 @@ public class SourceDocumentUpload implements Serializable {\n                 HDocumentUpload previousParts =\n                         documentUploadDAO.findById(uploadForm.getUploadId());\n                 totalChunks = previousParts.getParts().size();\n-                totalChunks++; // add final part\n-                tempFile =\n+                totalChunks++;\n+                // add final part\n+                 tempFile =\n                         Optional.of(util.combineToTempFileAndDeleteUploadRecord(\n                                 previousParts, uploadForm));\n             }\n",
            "diff_size": 3
        }
    ],
    "repaired_by": [
        "styler",
        "naturalize",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "intellij",
        "codebuff",
        "styler_random"
    ]
}