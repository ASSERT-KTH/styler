{
    "project_name": "graphfoundation-ongdb",
    "error_id": "1667",
    "information": {
        "errors": [
            {
                "line": "1",
                "severity": "error",
                "message": "Missing, wrong or duplicated license header",
                "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
            }
        ]
    },
    "source_code": "/*\n * Copyright (c) 2002-2018 \"Neo Technology,\"\n * Network Engine for Objects in Lund AB [http://neotechnology.com]\n *",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "1",
                    "severity": "error",
                    "message": "Missing, wrong or duplicated license header",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "1",
                    "severity": "error",
                    "message": "Missing, wrong or duplicated license header",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                },
                {
                    "line": "74",
                    "column": "25",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "75",
                    "column": "83",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "77",
                    "column": "49",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "77",
                    "column": "59",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "80",
                    "column": "51",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "80",
                    "column": "66",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "92",
                    "column": "62",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "92",
                    "column": "112",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "97",
                    "column": "49",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "97",
                    "column": "137",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "125",
                    "column": "62",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "125",
                    "column": "80",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "130",
                    "column": "66",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "130",
                    "column": "84",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "175",
                    "column": "5",
                    "severity": "error",
                    "message": "'}' at column 5 should be alone on a line.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.blocks.RightCurlyCheck"
                },
                {
                    "line": "175",
                    "column": "13",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "175",
                    "column": "25",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/errored/1/1667/HazelcastClient.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/intellij/1667/HazelcastClient.java\nindex af63f7ed88f..79187dc4ef7 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/errored/1/1667/HazelcastClient.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/intellij/1667/HazelcastClient.java\n@@ -17,6 +17,7 @@\n  * You should have received a copy of the GNU Affero General Public License\n  * along with this program. If not, see <http://www.gnu.org/licenses/>.\n  */\n+\n package org.neo4j.causalclustering.discovery;\n \n import java.util.HashMap;\n@@ -46,159 +47,158 @@ import static org.neo4j.causalclustering.discovery.HazelcastClusterTopology.refr\n \n public class HazelcastClient extends AbstractTopologyService\n {\n-    private final Log log;\n-    private final ClientConnectorAddresses connectorAddresses;\n-    private final RobustHazelcastWrapper hzInstance;\n-    private final RobustJobSchedulerWrapper scheduler;\n-    private final Config config;\n-    private final long timeToLive;\n-    private final long refreshPeriod;\n-    private final AdvertisedSocketAddress transactionSource;\n-    private final MemberId myself;\n-    private final List<String> groups;\n-    private final TopologyServiceRetryStrategy topologyServiceRetryStrategy;\n-\n-    //TODO: Work out error handling in case cluster hosts change their dbName unexpectedly\n-    private final String dbName;\n-\n-    private JobScheduler.JobHandle keepAliveJob;\n-    private JobScheduler.JobHandle refreshTopologyJob;\n-    private JobScheduler.JobHandle refreshRolesJob;\n-\n-    private volatile Map<MemberId,AdvertisedSocketAddress> catchupAddressMap = new HashMap<>();\n-    private volatile CoreTopology coreTopology = CoreTopology.EMPTY;\n-    private volatile ReadReplicaTopology rrTopology = ReadReplicaTopology.EMPTY;\n-    private volatile Map<MemberId,RoleInfo> coreRoles = emptyMap();\n-\n-    public HazelcastClient( HazelcastConnector connector, JobScheduler scheduler, LogProvider logProvider, Config config, MemberId myself,\n-            TopologyServiceRetryStrategy topologyServiceRetryStrategy )\n+  private final Log log;\n+  private final ClientConnectorAddresses connectorAddresses;\n+  private final RobustHazelcastWrapper hzInstance;\n+  private final RobustJobSchedulerWrapper scheduler;\n+  private final Config config;\n+  private final long timeToLive;\n+  private final long refreshPeriod;\n+  private final AdvertisedSocketAddress transactionSource;\n+  private final MemberId myself;\n+  private final List<String> groups;\n+  private final TopologyServiceRetryStrategy topologyServiceRetryStrategy;\n+\n+  //TODO: Work out error handling in case cluster hosts change their dbName unexpectedly\n+  private final String dbName;\n+\n+  private JobScheduler.JobHandle keepAliveJob;\n+  private JobScheduler.JobHandle refreshTopologyJob;\n+  private JobScheduler.JobHandle refreshRolesJob;\n+\n+  private volatile Map<MemberId, AdvertisedSocketAddress> catchupAddressMap = new HashMap<>();\n+  private volatile CoreTopology coreTopology = CoreTopology.EMPTY;\n+  private volatile ReadReplicaTopology rrTopology = ReadReplicaTopology.EMPTY;\n+  private volatile Map<MemberId, RoleInfo> coreRoles = emptyMap();\n+\n+  public HazelcastClient(HazelcastConnector connector, JobScheduler scheduler, LogProvider logProvider, Config config, MemberId myself,\n+                         TopologyServiceRetryStrategy topologyServiceRetryStrategy)\n+  {\n+    this.hzInstance = new RobustHazelcastWrapper(connector);\n+    this.config = config;\n+    this.log = logProvider.getLog(getClass());\n+    this.scheduler = new RobustJobSchedulerWrapper(scheduler, log);\n+    this.connectorAddresses = ClientConnectorAddresses.extractFromConfig(config);\n+    this.transactionSource = config.get(CausalClusteringSettings.transaction_advertised_address);\n+    this.timeToLive = config.get(CausalClusteringSettings.read_replica_time_to_live).toMillis();\n+    this.refreshPeriod = config.get(CausalClusteringSettings.cluster_topology_refresh).toMillis();\n+    this.myself = myself;\n+    this.groups = config.get(CausalClusteringSettings.server_groups);\n+    this.topologyServiceRetryStrategy = resolveStrategy(refreshPeriod, logProvider);\n+    this.dbName = config.get(CausalClusteringSettings.database);\n+    this.coreRoles = emptyMap();\n+  }\n+\n+  private static TopologyServiceRetryStrategy resolveStrategy(long refreshPeriodMillis, LogProvider logProvider)\n+  {\n+    int pollingFrequencyWithinRefreshWindow = 2;\n+    int numberOfRetries =\n+        pollingFrequencyWithinRefreshWindow + 1; // we want to have more retries at the given frequency than there is time in a refresh period\n+    return new TopologyServiceMultiRetryStrategy(refreshPeriodMillis / pollingFrequencyWithinRefreshWindow, numberOfRetries, logProvider);\n+  }\n+\n+  @Override\n+  public Map<MemberId, RoleInfo> allCoreRoles()\n+  {\n+    return coreRoles;\n+  }\n+\n+  @Override\n+  public String localDBName()\n+  {\n+    return dbName;\n+  }\n+\n+  @Override\n+  public CoreTopology allCoreServers()\n+  {\n+    return coreTopology;\n+  }\n+\n+  @Override\n+  public ReadReplicaTopology allReadReplicas()\n+  {\n+    return rrTopology;\n+  }\n+\n+  @Override\n+  public Optional<AdvertisedSocketAddress> findCatchupAddress(MemberId memberId)\n+  {\n+    return topologyServiceRetryStrategy.apply(memberId, this::retrieveSocketAddress, Optional::isPresent);\n+  }\n+\n+  private Optional<AdvertisedSocketAddress> retrieveSocketAddress(MemberId memberId)\n+  {\n+    return Optional.ofNullable(catchupAddressMap.get(memberId));\n+  }\n+\n+  /**\n+   * Caches the topology so that the lookups are fast.\n+   */\n+  private void refreshTopology() throws HazelcastInstanceNotActiveException\n+  {\n+    coreTopology = hzInstance.apply(hz -> getCoreTopology(hz, config, log));\n+    rrTopology = hzInstance.apply(hz -> getReadReplicaTopology(hz, log));\n+    catchupAddressMap = extractCatchupAddressesMap(localCoreServers(), localReadReplicas());\n+  }\n+\n+  private void refreshRoles() throws HazelcastInstanceNotActiveException\n+  {\n+    coreRoles = hzInstance.apply(hz -> HazelcastClusterTopology.getCoreRoles(hz, allCoreServers().members().keySet()));\n+  }\n+\n+  @Override\n+  public void start()\n+  {\n+    keepAliveJob = scheduler.scheduleRecurring(\"KeepAlive\", timeToLive / 3, this::keepReadReplicaAlive);\n+    refreshTopologyJob = scheduler.scheduleRecurring(\"TopologyRefresh\", refreshPeriod, () -> {\n+      this.refreshTopology();\n+      this.refreshRoles();\n+    });\n+  }\n+\n+  @Override\n+  public void stop()\n+  {\n+    keepAliveJob.cancel(true);\n+    refreshTopologyJob.cancel(true);\n+    disconnectFromCore();\n+  }\n+\n+  private void disconnectFromCore()\n+  {\n+    try\n     {\n-        this.hzInstance = new RobustHazelcastWrapper( connector );\n-        this.config = config;\n-        this.log = logProvider.getLog( getClass() );\n-        this.scheduler = new RobustJobSchedulerWrapper( scheduler, log );\n-        this.connectorAddresses = ClientConnectorAddresses.extractFromConfig( config );\n-        this.transactionSource = config.get( CausalClusteringSettings.transaction_advertised_address );\n-        this.timeToLive = config.get( CausalClusteringSettings.read_replica_time_to_live ).toMillis();\n-        this.refreshPeriod = config.get( CausalClusteringSettings.cluster_topology_refresh ).toMillis();\n-        this.myself = myself;\n-        this.groups = config.get( CausalClusteringSettings.server_groups );\n-        this.topologyServiceRetryStrategy = resolveStrategy( refreshPeriod, logProvider );\n-        this.dbName = config.get( CausalClusteringSettings.database );\n-        this.coreRoles = emptyMap();\n-    }\n-\n-    private static TopologyServiceRetryStrategy resolveStrategy( long refreshPeriodMillis, LogProvider logProvider )\n+      String uuid = hzInstance.apply(hzInstance -> hzInstance.getLocalEndpoint().getUuid());\n+      hzInstance.apply(hz -> hz.getMap(READ_REPLICA_BOLT_ADDRESS_MAP).remove(uuid));\n+      hzInstance.shutdown();\n+    } catch (Throwable e)\n     {\n-        int pollingFrequencyWithinRefreshWindow = 2;\n-        int numberOfRetries =\n-                pollingFrequencyWithinRefreshWindow + 1; // we want to have more retries at the given frequency than there is time in a refresh period\n-        return new TopologyServiceMultiRetryStrategy( refreshPeriodMillis / pollingFrequencyWithinRefreshWindow, numberOfRetries, logProvider );\n+      // Hazelcast is not able to stop correctly sometimes and throws a bunch of different exceptions\n+      // let's simply log the current problem but go on with our shutdown\n+      log.warn(\"Unable to shutdown hazelcast cleanly\", e);\n     }\n+  }\n \n-    @Override\n-    public Map<MemberId,RoleInfo> allCoreRoles()\n+  private void keepReadReplicaAlive() throws HazelcastInstanceNotActiveException\n+  {\n+    hzInstance.perform(hazelcastInstance ->\n     {\n-        return coreRoles;\n-    }\n+      String uuid = hazelcastInstance.getLocalEndpoint().getUuid();\n+      String addresses = connectorAddresses.toString();\n+      log.debug(\"Adding read replica into cluster (%s -> %s)\", uuid, addresses);\n \n-    @Override\n-    public String localDBName()\n-    {\n-        return dbName;\n-    }\n+      hazelcastInstance.getMap(READ_REPLICAS_DB_NAME_MAP).put(uuid, dbName, timeToLive, MILLISECONDS);\n \n-    @Override\n-    public CoreTopology allCoreServers()\n-    {\n-        return coreTopology;\n-    }\n+      hazelcastInstance.getMap(READ_REPLICA_TRANSACTION_SERVER_ADDRESS_MAP).put(uuid, transactionSource.toString(), timeToLive, MILLISECONDS);\n \n-    @Override\n-    public ReadReplicaTopology allReadReplicas()\n-    {\n-        return rrTopology;\n-    }\n+      hazelcastInstance.getMap(READ_REPLICA_MEMBER_ID_MAP).put(uuid, myself.getUuid().toString(), timeToLive, MILLISECONDS);\n \n-    @Override\n-    public Optional<AdvertisedSocketAddress> findCatchupAddress( MemberId memberId )\n-    {\n-        return topologyServiceRetryStrategy.apply( memberId, this::retrieveSocketAddress, Optional::isPresent );\n-    }\n-\n-    private Optional<AdvertisedSocketAddress> retrieveSocketAddress( MemberId memberId )\n-    {\n-        return Optional.ofNullable( catchupAddressMap.get( memberId ) );\n-    }\n+      refreshGroups(hazelcastInstance, uuid, groups);\n \n-    /**\n-     * Caches the topology so that the lookups are fast.\n-     */\n-    private void refreshTopology() throws HazelcastInstanceNotActiveException\n-    {\n-        coreTopology = hzInstance.apply( hz -> getCoreTopology( hz, config, log ) );\n-        rrTopology = hzInstance.apply( hz -> getReadReplicaTopology( hz, log ) );\n-        catchupAddressMap = extractCatchupAddressesMap( localCoreServers(), localReadReplicas() );\n-    }\n-\n-    private void refreshRoles() throws HazelcastInstanceNotActiveException\n-    {\n-        coreRoles = hzInstance.apply(hz -> HazelcastClusterTopology.getCoreRoles( hz, allCoreServers().members().keySet() ) );\n-    }\n-\n-    @Override\n-    public void start()\n-    {\n-        keepAliveJob = scheduler.scheduleRecurring( \"KeepAlive\", timeToLive / 3, this::keepReadReplicaAlive );\n-        refreshTopologyJob = scheduler.scheduleRecurring( \"TopologyRefresh\", refreshPeriod, () -> {\n-            this.refreshTopology();\n-            this.refreshRoles();\n-        } );\n-    }\n-\n-    @Override\n-    public void stop()\n-    {\n-        keepAliveJob.cancel( true );\n-        refreshTopologyJob.cancel( true );\n-        disconnectFromCore();\n-    }\n-\n-    private void disconnectFromCore()\n-    {\n-        try\n-        {\n-            String uuid = hzInstance.apply( hzInstance -> hzInstance.getLocalEndpoint().getUuid() );\n-            hzInstance.apply( hz -> hz.getMap( READ_REPLICA_BOLT_ADDRESS_MAP ).remove( uuid ) );\n-            hzInstance.shutdown();\n-        }\n-        catch ( Throwable e )\n-        {\n-            // Hazelcast is not able to stop correctly sometimes and throws a bunch of different exceptions\n-            // let's simply log the current problem but go on with our shutdown\n-            log.warn( \"Unable to shutdown hazelcast cleanly\", e );\n-        }\n-    }\n-\n-    private void keepReadReplicaAlive() throws HazelcastInstanceNotActiveException\n-    {\n-        hzInstance.perform( hazelcastInstance ->\n-        {\n-            String uuid = hazelcastInstance.getLocalEndpoint().getUuid();\n-            String addresses = connectorAddresses.toString();\n-            log.debug( \"Adding read replica into cluster (%s -> %s)\", uuid, addresses );\n-\n-            hazelcastInstance.getMap( READ_REPLICAS_DB_NAME_MAP ).put( uuid, dbName, timeToLive, MILLISECONDS);\n-\n-            hazelcastInstance.getMap( READ_REPLICA_TRANSACTION_SERVER_ADDRESS_MAP ).put( uuid, transactionSource.toString(), timeToLive, MILLISECONDS );\n-\n-            hazelcastInstance.getMap( READ_REPLICA_MEMBER_ID_MAP ).put( uuid, myself.getUuid().toString(), timeToLive, MILLISECONDS );\n-\n-            refreshGroups( hazelcastInstance, uuid, groups );\n-\n-            // this needs to be last as when we read from it in HazelcastClusterTopology.readReplicas\n-            // we assume that all the other maps have been populated if an entry exists in this one\n-            hazelcastInstance.getMap( READ_REPLICA_BOLT_ADDRESS_MAP ).put( uuid, addresses, timeToLive, MILLISECONDS );\n-        } );\n-    }\n+      // this needs to be last as when we read from it in HazelcastClusterTopology.readReplicas\n+      // we assume that all the other maps have been populated if an entry exists in this one\n+      hazelcastInstance.getMap(READ_REPLICA_BOLT_ADDRESS_MAP).put(uuid, addresses, timeToLive, MILLISECONDS);\n+    });\n+  }\n }\n",
            "diff_size": 244
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "1",
                    "severity": "error",
                    "message": "Missing, wrong or duplicated license header",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "1",
                    "severity": "error",
                    "message": "Missing, wrong or duplicated license header",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ],
    "repaired_by": [],
    "not_repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}