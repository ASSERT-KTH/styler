{
    "project_name": "graphfoundation-ongdb",
    "error_id": "3331",
    "information": {
        "errors": [
            {
                "line": "1",
                "severity": "error",
                "message": "Missing, wrong or duplicated license header",
                "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
            }
        ]
    },
    "source_code": "/*\n * Copyright (c) 2002-2020 \"Neo4j,\"\n * Neo4j Sweden AB [http://neo4j.com]\n *",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "1",
                    "severity": "error",
                    "message": "Missing, wrong or duplicated license header",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "1",
                    "severity": "error",
                    "message": "Missing, wrong or duplicated license header",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                },
                {
                    "line": "105",
                    "column": "42",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "105",
                    "column": "68",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "118",
                    "column": "42",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "118",
                    "column": "89",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "130",
                    "column": "26",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "130",
                    "column": "52",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "143",
                    "column": "26",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "143",
                    "column": "73",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "162",
                    "column": "42",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "162",
                    "column": "56",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "180",
                    "column": "26",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "180",
                    "column": "40",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "197",
                    "column": "42",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "197",
                    "column": "79",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "215",
                    "column": "26",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "215",
                    "column": "63",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "252",
                    "column": "37",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "252",
                    "column": "74",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "267",
                    "column": "36",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "267",
                    "column": "74",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "292",
                    "column": "16",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "292",
                    "column": "38",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "300",
                    "column": "16",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "300",
                    "column": "36",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "311",
                    "column": "16",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "311",
                    "column": "59",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "319",
                    "column": "16",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "319",
                    "column": "28",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "327",
                    "column": "19",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "327",
                    "column": "31",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "335",
                    "column": "19",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "335",
                    "column": "31",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/errored/1/3331/Node.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/intellij/3331/Node.java\nindex 788f7a4b998..327a8792744 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/errored/1/3331/Node.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/intellij/3331/Node.java\n@@ -17,6 +17,7 @@\n  * You should have received a copy of the GNU General Public License\n  * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n  */\n+\n package org.neo4j.graphdb;\n \n /**\n@@ -54,288 +55,290 @@ package org.neo4j.graphdb;\n  */\n public interface Node extends Entity\n {\n-    /**\n-     * Returns the unique id of this node. Ids are garbage collected over time\n-     * so they are only guaranteed to be unique during a specific time span: if\n-     * the node is deleted, it's likely that a new node at some point will get\n-     * the old id. <b>Note</b>: This makes node ids brittle as public APIs.\n-     *\n-     * @return the id of this node\n-     */\n-    @Override\n-    long getId();\n+  /**\n+   * Returns the unique id of this node. Ids are garbage collected over time\n+   * so they are only guaranteed to be unique during a specific time span: if\n+   * the node is deleted, it's likely that a new node at some point will get\n+   * the old id. <b>Note</b>: This makes node ids brittle as public APIs.\n+   *\n+   * @return the id of this node\n+   */\n+  @Override\n+  long getId();\n \n-    /**\n-     * Deletes this node if it has no relationships attached to it. If\n-     * <code>delete()</code> is invoked on a node with relationships, an\n-     * unchecked exception will be raised when the transaction is committing.\n-     * Invoking any methods on this node after <code>delete()</code> has\n-     * returned is invalid and will lead to {@link NotFoundException} being thrown.\n-     */\n-    void delete();\n+  /**\n+   * Deletes this node if it has no relationships attached to it. If\n+   * <code>delete()</code> is invoked on a node with relationships, an\n+   * unchecked exception will be raised when the transaction is committing.\n+   * Invoking any methods on this node after <code>delete()</code> has\n+   * returned is invalid and will lead to {@link NotFoundException} being thrown.\n+   */\n+  void delete();\n \n-    /**\n-     * Returns all the relationships attached to this node. If no relationships\n-     * are attached to this node, an empty iterable will be returned.\n-     *\n-     * @return all relationships attached to this node\n-     */\n-    Iterable<Relationship> getRelationships();\n+  /**\n+   * Returns all the relationships attached to this node. If no relationships\n+   * are attached to this node, an empty iterable will be returned.\n+   *\n+   * @return all relationships attached to this node\n+   */\n+  Iterable<Relationship> getRelationships();\n \n-    /**\n-     * Returns <code>true</code> if there are any relationships attached to this\n-     * node, <code>false</code> otherwise.\n-     *\n-     * @return <code>true</code> if there are any relationships attached to this\n-     *         node, <code>false</code> otherwise\n-     */\n-    boolean hasRelationship();\n+  /**\n+   * Returns <code>true</code> if there are any relationships attached to this\n+   * node, <code>false</code> otherwise.\n+   *\n+   * @return <code>true</code> if there are any relationships attached to this\n+   * node, <code>false</code> otherwise\n+   */\n+  boolean hasRelationship();\n \n-    /**\n-     * Returns all the relationships of any of the types in <code>types</code>\n-     * that are attached to this node, regardless of direction. If no\n-     * relationships of the given types are attached to this node, an empty\n-     * iterable will be returned.\n-     *\n-     * @param types the given relationship type(s)\n-     * @return all relationships of the given type(s) that are attached to this\n-     *         node\n-     */\n-    Iterable<Relationship> getRelationships( RelationshipType... types );\n+  /**\n+   * Returns all the relationships of any of the types in <code>types</code>\n+   * that are attached to this node, regardless of direction. If no\n+   * relationships of the given types are attached to this node, an empty\n+   * iterable will be returned.\n+   *\n+   * @param types the given relationship type(s)\n+   * @return all relationships of the given type(s) that are attached to this\n+   * node\n+   */\n+  Iterable<Relationship> getRelationships(RelationshipType... types);\n \n-    /**\n-     * Returns all the relationships of any of the types in <code>types</code>\n-     * that are attached to this node and have the given <code>direction</code>.\n-     * If no relationships of the given types are attached to this node, an empty\n-     * iterable will be returned.\n-     *\n-     * @param types the given relationship type(s)\n-     * @param direction the direction of the relationships to return.\n-     * @return all relationships of the given type(s) that are attached to this\n-     *         node\n-     */\n-    Iterable<Relationship> getRelationships( Direction direction, RelationshipType... types );\n+  /**\n+   * Returns all the relationships of any of the types in <code>types</code>\n+   * that are attached to this node and have the given <code>direction</code>.\n+   * If no relationships of the given types are attached to this node, an empty\n+   * iterable will be returned.\n+   *\n+   * @param types     the given relationship type(s)\n+   * @param direction the direction of the relationships to return.\n+   * @return all relationships of the given type(s) that are attached to this\n+   * node\n+   */\n+  Iterable<Relationship> getRelationships(Direction direction, RelationshipType... types);\n \n-    /**\n-     * Returns <code>true</code> if there are any relationships of any of the\n-     * types in <code>types</code> attached to this node (regardless of\n-     * direction), <code>false</code> otherwise.\n-     *\n-     * @param types the given relationship type(s)\n-     * @return <code>true</code> if there are any relationships of any of the\n-     *         types in <code>types</code> attached to this node,\n-     *         <code>false</code> otherwise\n-     */\n-    boolean hasRelationship( RelationshipType... types );\n+  /**\n+   * Returns <code>true</code> if there are any relationships of any of the\n+   * types in <code>types</code> attached to this node (regardless of\n+   * direction), <code>false</code> otherwise.\n+   *\n+   * @param types the given relationship type(s)\n+   * @return <code>true</code> if there are any relationships of any of the\n+   * types in <code>types</code> attached to this node,\n+   * <code>false</code> otherwise\n+   */\n+  boolean hasRelationship(RelationshipType... types);\n \n-    /**\n-     * Returns <code>true</code> if there are any relationships of any of the\n-     * types in <code>types</code> attached to this node (for the given\n-     * <code>direction</code>), <code>false</code> otherwise.\n-     *\n-     * @param types the given relationship type(s)\n-     * @param direction the direction to check relationships for\n-     * @return <code>true</code> if there are any relationships of any of the\n-     *         types in <code>types</code> attached to this node,\n-     *         <code>false</code> otherwise\n-     */\n-    boolean hasRelationship( Direction direction, RelationshipType... types );\n+  /**\n+   * Returns <code>true</code> if there are any relationships of any of the\n+   * types in <code>types</code> attached to this node (for the given\n+   * <code>direction</code>), <code>false</code> otherwise.\n+   *\n+   * @param types     the given relationship type(s)\n+   * @param direction the direction to check relationships for\n+   * @return <code>true</code> if there are any relationships of any of the\n+   * types in <code>types</code> attached to this node,\n+   * <code>false</code> otherwise\n+   */\n+  boolean hasRelationship(Direction direction, RelationshipType... types);\n \n-    /**\n-     * Returns all {@link Direction#OUTGOING OUTGOING} or\n-     * {@link Direction#INCOMING INCOMING} relationships from this node. If\n-     * there are no relationships with the given direction attached to this\n-     * node, an empty iterable will be returned. If {@link Direction#BOTH BOTH}\n-     * is passed in as a direction, relationships of both directions are\n-     * returned (effectively turning this into <code>getRelationships()</code>).\n-     *\n-     * @param dir the given direction, where <code>Direction.OUTGOING</code>\n-     *            means all relationships that have this node as\n-     *            {@link Relationship#getStartNode() start node} and <code>\n-     * Direction.INCOMING</code>\n-     *            means all relationships that have this node as\n-     *            {@link Relationship#getEndNode() end node}\n-     * @return all relationships with the given direction that are attached to\n-     *         this node\n-     */\n-    Iterable<Relationship> getRelationships( Direction dir );\n+  /**\n+   * Returns all {@link Direction#OUTGOING OUTGOING} or\n+   * {@link Direction#INCOMING INCOMING} relationships from this node. If\n+   * there are no relationships with the given direction attached to this\n+   * node, an empty iterable will be returned. If {@link Direction#BOTH BOTH}\n+   * is passed in as a direction, relationships of both directions are\n+   * returned (effectively turning this into <code>getRelationships()</code>).\n+   *\n+   * @param dir the given direction, where <code>Direction.OUTGOING</code>\n+   *            means all relationships that have this node as\n+   *            {@link Relationship#getStartNode() start node} and <code>\n+   *            Direction.INCOMING</code>\n+   *            means all relationships that have this node as\n+   *            {@link Relationship#getEndNode() end node}\n+   * @return all relationships with the given direction that are attached to\n+   * this node\n+   */\n+  Iterable<Relationship> getRelationships(Direction dir);\n \n-    /**\n-     * Returns <code>true</code> if there are any relationships in the given\n-     * direction attached to this node, <code>false</code> otherwise. If\n-     * {@link Direction#BOTH BOTH} is passed in as a direction, relationships of\n-     * both directions are matched (effectively turning this into\n-     * <code>hasRelationships()</code>).\n-     *\n-     * @param dir the given direction, where <code>Direction.OUTGOING</code>\n-     *            means all relationships that have this node as\n-     *            {@link Relationship#getStartNode() start node} and <code>\n-     * Direction.INCOMING</code>\n-     *            means all relationships that have this node as\n-     *            {@link Relationship#getEndNode() end node}\n-     * @return <code>true</code> if there are any relationships in the given\n-     *         direction attached to this node, <code>false</code> otherwise\n-     */\n-    boolean hasRelationship( Direction dir );\n+  /**\n+   * Returns <code>true</code> if there are any relationships in the given\n+   * direction attached to this node, <code>false</code> otherwise. If\n+   * {@link Direction#BOTH BOTH} is passed in as a direction, relationships of\n+   * both directions are matched (effectively turning this into\n+   * <code>hasRelationships()</code>).\n+   *\n+   * @param dir the given direction, where <code>Direction.OUTGOING</code>\n+   *            means all relationships that have this node as\n+   *            {@link Relationship#getStartNode() start node} and <code>\n+   *            Direction.INCOMING</code>\n+   *            means all relationships that have this node as\n+   *            {@link Relationship#getEndNode() end node}\n+   * @return <code>true</code> if there are any relationships in the given\n+   * direction attached to this node, <code>false</code> otherwise\n+   */\n+  boolean hasRelationship(Direction dir);\n \n-    /**\n-     * Returns all relationships with the given type and direction that are\n-     * attached to this node. If there are no matching relationships, an empty\n-     * iterable will be returned.\n-     *\n-     * @param type the given type\n-     * @param dir the given direction, where <code>Direction.OUTGOING</code>\n-     *            means all relationships that have this node as\n-     *            {@link Relationship#getStartNode() start node} and <code>\n-     * Direction.INCOMING</code>\n-     *            means all relationships that have this node as\n-     *            {@link Relationship#getEndNode() end node}\n-     * @return all relationships attached to this node that match the given type\n-     *         and direction\n-     */\n-    Iterable<Relationship> getRelationships( RelationshipType type, Direction dir );\n+  /**\n+   * Returns all relationships with the given type and direction that are\n+   * attached to this node. If there are no matching relationships, an empty\n+   * iterable will be returned.\n+   *\n+   * @param type the given type\n+   * @param dir  the given direction, where <code>Direction.OUTGOING</code>\n+   *             means all relationships that have this node as\n+   *             {@link Relationship#getStartNode() start node} and <code>\n+   *             Direction.INCOMING</code>\n+   *             means all relationships that have this node as\n+   *             {@link Relationship#getEndNode() end node}\n+   * @return all relationships attached to this node that match the given type\n+   * and direction\n+   */\n+  Iterable<Relationship> getRelationships(RelationshipType type, Direction dir);\n \n-    /**\n-     * Returns <code>true</code> if there are any relationships of the given\n-     * relationship type and direction attached to this node, <code>false</code>\n-     * otherwise.\n-     *\n-     * @param type the given type\n-     * @param dir the given direction, where <code>Direction.OUTGOING</code>\n-     *            means all relationships that have this node as\n-     *            {@link Relationship#getStartNode() start node} and <code>\n-     * Direction.INCOMING</code>\n-     *            means all relationships that have this node as\n-     *            {@link Relationship#getEndNode() end node}\n-     * @return <code>true</code> if there are any relationships of the given\n-     *         relationship type and direction attached to this node,\n-     *         <code>false</code> otherwise\n-     */\n-    boolean hasRelationship( RelationshipType type, Direction dir );\n+  /**\n+   * Returns <code>true</code> if there are any relationships of the given\n+   * relationship type and direction attached to this node, <code>false</code>\n+   * otherwise.\n+   *\n+   * @param type the given type\n+   * @param dir  the given direction, where <code>Direction.OUTGOING</code>\n+   *             means all relationships that have this node as\n+   *             {@link Relationship#getStartNode() start node} and <code>\n+   *             Direction.INCOMING</code>\n+   *             means all relationships that have this node as\n+   *             {@link Relationship#getEndNode() end node}\n+   * @return <code>true</code> if there are any relationships of the given\n+   * relationship type and direction attached to this node,\n+   * <code>false</code> otherwise\n+   */\n+  boolean hasRelationship(RelationshipType type, Direction dir);\n \n-    /**\n-     * Returns the only relationship of a given type and direction that is\n-     * attached to this node, or <code>null</code>. This is a convenience method\n-     * that is used in the commonly occuring situation where a node has exactly\n-     * zero or one relationships of a given type and direction to another node.\n-     * Typically this invariant is maintained by the rest of the code: if at any\n-     * time more than one such relationships exist, it is a fatal error that\n-     * should generate an unchecked exception. This method reflects that\n-     * semantics and returns either:\n-     * <ol>\n-     * <li><code>null</code> if there are zero relationships of the given type\n-     * and direction,</li>\n-     * <li>the relationship if there's exactly one, or\n-     * <li>throws an unchecked exception in all other cases.</li>\n-     * </ol>\n-     * <p>\n-     * This method should be used only in situations with an invariant as\n-     * described above. In those situations, a \"state-checking\" method (e.g.\n-     * <code>hasSingleRelationship(...)</code>) is not required, because this\n-     * method behaves correctly \"out of the box.\"\n-     *\n-     * @param type the type of the wanted relationship\n-     * @param dir the direction of the wanted relationship (where\n-     *            <code>Direction.OUTGOING</code> means a relationship that has\n-     *            this node as {@link Relationship#getStartNode() start node}\n-     *            and <code>\n-     * Direction.INCOMING</code> means a relationship that has\n-     *            this node as {@link Relationship#getEndNode() end node}) or\n-     *            {@link Direction#BOTH} if direction is irrelevant\n-     * @return the single relationship matching the given type and direction if\n-     *         exactly one such relationship exists, or <code>null</code> if\n-     *         exactly zero such relationships exists\n-     * @throws RuntimeException if more than one relationship matches the given\n-     *             type and direction\n-     */\n-    Relationship getSingleRelationship( RelationshipType type, Direction dir );\n+  /**\n+   * Returns the only relationship of a given type and direction that is\n+   * attached to this node, or <code>null</code>. This is a convenience method\n+   * that is used in the commonly occuring situation where a node has exactly\n+   * zero or one relationships of a given type and direction to another node.\n+   * Typically this invariant is maintained by the rest of the code: if at any\n+   * time more than one such relationships exist, it is a fatal error that\n+   * should generate an unchecked exception. This method reflects that\n+   * semantics and returns either:\n+   * <ol>\n+   * <li><code>null</code> if there are zero relationships of the given type\n+   * and direction,</li>\n+   * <li>the relationship if there's exactly one, or\n+   * <li>throws an unchecked exception in all other cases.</li>\n+   * </ol>\n+   * <p>\n+   * This method should be used only in situations with an invariant as\n+   * described above. In those situations, a \"state-checking\" method (e.g.\n+   * <code>hasSingleRelationship(...)</code>) is not required, because this\n+   * method behaves correctly \"out of the box.\"\n+   *\n+   * @param type the type of the wanted relationship\n+   * @param dir  the direction of the wanted relationship (where\n+   *             <code>Direction.OUTGOING</code> means a relationship that has\n+   *             this node as {@link Relationship#getStartNode() start node}\n+   *             and <code>\n+   *             Direction.INCOMING</code> means a relationship that has\n+   *             this node as {@link Relationship#getEndNode() end node}) or\n+   *             {@link Direction#BOTH} if direction is irrelevant\n+   * @return the single relationship matching the given type and direction if\n+   * exactly one such relationship exists, or <code>null</code> if\n+   * exactly zero such relationships exists\n+   * @throws RuntimeException if more than one relationship matches the given\n+   *                          type and direction\n+   */\n+  Relationship getSingleRelationship(RelationshipType type, Direction dir);\n \n-    /**\n-     * Creates a relationship between this node and another node. The\n-     * relationship is of type <code>type</code>. It starts at this node and\n-     * ends at <code>otherNode</code>.\n-     * <p>\n-     * A relationship is equally well traversed in both directions so there's no\n-     * need to create another relationship in the opposite direction (in regards\n-     * to traversal or performance).\n-     *\n-     * @param otherNode the end node of the new relationship\n-     * @param type the type of the new relationship\n-     * @return the newly created relationship\n-     */\n-    Relationship createRelationshipTo( Node otherNode, RelationshipType type );\n+  /**\n+   * Creates a relationship between this node and another node. The\n+   * relationship is of type <code>type</code>. It starts at this node and\n+   * ends at <code>otherNode</code>.\n+   * <p>\n+   * A relationship is equally well traversed in both directions so there's no\n+   * need to create another relationship in the opposite direction (in regards\n+   * to traversal or performance).\n+   *\n+   * @param otherNode the end node of the new relationship\n+   * @param type      the type of the new relationship\n+   * @return the newly created relationship\n+   */\n+  Relationship createRelationshipTo(Node otherNode, RelationshipType type);\n \n-    /**\n-     * Returns relationship types which this node has one more relationships\n-     * for. If this node doesn't have any relationships an empty {@link Iterable}\n-     * will be returned.\n-     * @return relationship types which this node has one more relationships for.\n-     */\n-    Iterable<RelationshipType> getRelationshipTypes();\n+  /**\n+   * Returns relationship types which this node has one more relationships\n+   * for. If this node doesn't have any relationships an empty {@link Iterable}\n+   * will be returned.\n+   *\n+   * @return relationship types which this node has one more relationships for.\n+   */\n+  Iterable<RelationshipType> getRelationshipTypes();\n \n-    /**\n-     * Returns the number of relationships connected to this node regardless of\n-     * direction or type. This operation is always O(1).\n-     * @return the number of relationships connected to this node.\n-     */\n-    int getDegree();\n+  /**\n+   * Returns the number of relationships connected to this node regardless of\n+   * direction or type. This operation is always O(1).\n+   *\n+   * @return the number of relationships connected to this node.\n+   */\n+  int getDegree();\n \n-    /**\n-     * Returns the number of relationships of a given {@code type} connected to this node.\n-     *\n-     * @param type the type of relationships to get the degree for\n-     * @return the number of relationships of a given {@code type} connected to this node.\n-     */\n-    int getDegree( RelationshipType type );\n+  /**\n+   * Returns the number of relationships of a given {@code type} connected to this node.\n+   *\n+   * @param type the type of relationships to get the degree for\n+   * @return the number of relationships of a given {@code type} connected to this node.\n+   */\n+  int getDegree(RelationshipType type);\n \n-    /**\n-     * Returns the number of relationships of a given {@code direction} connected to this node.\n-     *\n-     * @param direction the direction of the relationships\n-     * @return the number of relationships of a given {@code direction} for this node.\n-     */\n-    int getDegree( Direction direction );\n+  /**\n+   * Returns the number of relationships of a given {@code direction} connected to this node.\n+   *\n+   * @param direction the direction of the relationships\n+   * @return the number of relationships of a given {@code direction} for this node.\n+   */\n+  int getDegree(Direction direction);\n \n-    /**\n-     * Returns the number of relationships of a given {@code type} and {@code direction}\n-     * connected to this node.\n-     *\n-     * @param type the type of relationships to get the degree for\n-     * @param direction the direction of the relationships\n-     * @return the number of relationships of a given {@code type} and {@code direction}\n-     * for this node.\n-     */\n-    int getDegree( RelationshipType type, Direction direction );\n+  /**\n+   * Returns the number of relationships of a given {@code type} and {@code direction}\n+   * connected to this node.\n+   *\n+   * @param type      the type of relationships to get the degree for\n+   * @param direction the direction of the relationships\n+   * @return the number of relationships of a given {@code type} and {@code direction}\n+   * for this node.\n+   */\n+  int getDegree(RelationshipType type, Direction direction);\n \n-    /**\n-     * Adds a {@link Label} to this node. If this node doesn't already have\n-     * this label it will be added. If it already has the label, nothing will happen.\n-     *\n-     * @param label the label to add to this node.\n-     */\n-    void addLabel( Label label );\n+  /**\n+   * Adds a {@link Label} to this node. If this node doesn't already have\n+   * this label it will be added. If it already has the label, nothing will happen.\n+   *\n+   * @param label the label to add to this node.\n+   */\n+  void addLabel(Label label);\n \n-    /**\n-     * Removes a {@link Label} from this node. If this node doesn't have this label,\n-     * nothing will happen.\n-     *\n-     * @param label the label to remove from this node.\n-     */\n-    void removeLabel( Label label );\n+  /**\n+   * Removes a {@link Label} from this node. If this node doesn't have this label,\n+   * nothing will happen.\n+   *\n+   * @param label the label to remove from this node.\n+   */\n+  void removeLabel(Label label);\n \n-    /**\n-     * Checks whether or not this node has the given label.\n-     *\n-     * @param label the label to check for.\n-     * @return {@code true} if this node has the given label, otherwise {@code false}.\n-     */\n-    boolean hasLabel( Label label );\n+  /**\n+   * Checks whether or not this node has the given label.\n+   *\n+   * @param label the label to check for.\n+   * @return {@code true} if this node has the given label, otherwise {@code false}.\n+   */\n+  boolean hasLabel(Label label);\n \n-    /**\n-     * Lists all labels attached to this node. If this node has no\n-     * labels an empty {@link Iterable} will be returned.\n-     *\n-     * @return all labels attached to this node.\n-     */\n-    Iterable<Label> getLabels();\n+  /**\n+   * Lists all labels attached to this node. If this node has no\n+   * labels an empty {@link Iterable} will be returned.\n+   *\n+   * @return all labels attached to this node.\n+   */\n+  Iterable<Label> getLabels();\n }\n",
            "diff_size": 265
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "1",
                    "severity": "error",
                    "message": "Missing, wrong or duplicated license header",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/errored/1/3331/Node.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/naturalize/3331/Node.java\nindex 788f7a4b998..101bf6f18a5 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/errored/1/3331/Node.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/naturalize/3331/Node.java\n@@ -338,4 +338,4 @@ public interface Node extends Entity\n      * @return all labels attached to this node.\n      */\n     Iterable<Label> getLabels();\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 1
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "1",
                    "severity": "error",
                    "message": "Missing, wrong or duplicated license header",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "1",
                    "severity": "error",
                    "message": "Missing, wrong or duplicated license header",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ],
    "repaired_by": [],
    "not_repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}