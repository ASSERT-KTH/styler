{
    "project_name": "OpenEMS-openems",
    "error_id": "39",
    "information": {
        "errors": [
            {
                "line": "97",
                "column": "36",
                "severity": "warning",
                "message": "'(' is followed by whitespace.",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
            }
        ]
    },
    "source_code": "\t\t\tfor (Channel<?> channel : component.channels()) {\n\t\t\t\tDoc doc = channel.channelDoc();\n\t\t\t\tif ( // Ignore Low-Priority Channels\n\t\t\t\tdoc.getPersistencePriority().isLowerThan(this.parent.persistencePriority)\n\t\t\t\t\t\t// Ignore WRITE_ONLY Channels\n\t\t\t\t\t\t|| channel.channelDoc().getAccessMode() == AccessMode.WRITE_ONLY) {",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/OpenEMS-openems/errored/1/39/RecordWorker.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/OpenEMS-openems/styler/39/RecordWorker.java\nindex 265a177b420..c8f309e7607 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/OpenEMS-openems/errored/1/39/RecordWorker.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/OpenEMS-openems/styler/39/RecordWorker.java\n@@ -94,7 +94,7 @@ public class RecordWorker extends AbstractImmediateWorker {\n \t\tfor (OpenemsComponent component : this.parent.componentManager.getEnabledComponents()) {\n \t\t\tfor (Channel<?> channel : component.channels()) {\n \t\t\t\tDoc doc = channel.channelDoc();\n-\t\t\t\tif ( // Ignore Low-Priority Channels\n+\t\t\t\tif (// Ignore Low-Priority Channels\n \t\t\t\tdoc.getPersistencePriority().isLowerThan(this.parent.persistencePriority)\n \t\t\t\t\t\t// Ignore WRITE_ONLY Channels\n \t\t\t\t\t\t|| channel.channelDoc().getAccessMode() == AccessMode.WRITE_ONLY) {\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "83",
                    "column": "7",
                    "severity": "warning",
                    "message": "Comment has incorrect indentation level 6, expected is 8, indentation should be the same level as line 84.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "97",
                    "column": "12",
                    "severity": "warning",
                    "message": "'(' is followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/OpenEMS-openems/errored/1/39/RecordWorker.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/OpenEMS-openems/intellij/39/RecordWorker.java\nindex 265a177b420..32541bdb12b 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/OpenEMS-openems/errored/1/39/RecordWorker.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/OpenEMS-openems/intellij/39/RecordWorker.java\n@@ -27,236 +27,236 @@ import io.openems.edge.common.component.OpenemsComponent;\n \n public class RecordWorker extends AbstractImmediateWorker {\n \n-\tprotected static final int DEFAULT_NO_OF_CYCLES = 60;\n-\n-\tprivate final Logger log = LoggerFactory.getLogger(RecordWorker.class);\n-\tprivate final Rrd4jTimedataImpl parent;\n-\n-\t// Counts the number of Cycles till data is recorded\n-\tprivate int cycleCount = 0;\n-\n-\tprivate static class Record {\n-\t\tprivate final long timestamp;\n-\t\tprivate final ChannelAddress address;\n-\t\tprivate final Unit unit;\n-\t\tprivate final double value;\n-\n-\t\tpublic Record(long timestamp, ChannelAddress address, Unit unit, double value) {\n-\t\t\tthis.timestamp = timestamp;\n-\t\t\tthis.address = address;\n-\t\t\tthis.unit = unit;\n-\t\t\tthis.value = value;\n-\t\t}\n-\t}\n-\n-\t// Record queue\n-\tprivate LinkedBlockingQueue<Record> records = new LinkedBlockingQueue<>();\n-\n-\t// keeps the last recorded timestamp\n-\tprivate Instant lastTimestamp = Instant.MIN;\n-\tprivate LocalDateTime readChannelValuesSince = LocalDateTime.MIN;\n-\n-\tpublic RecordWorker(Rrd4jTimedataImpl parent) {\n-\t\tthis.parent = parent;\n-\t}\n-\n-\t/**\n-\t * Collects the data from Channels. This is called synchronously by the main\n-\t * OpenEMS cycle. On finish it triggers a next async task to write the data to\n-\t * RRD4J.\n-\t */\n-\tpublic void collectData() {\n-\t\tInstant timestamp = Instant.now().truncatedTo(ChronoUnit.SECONDS);\n-\t\tfinal LocalDateTime nextReadChannelValuesSince = LocalDateTime.now();\n-\n-\t\t// Increase CycleCount\n-\t\tthis.cycleCount += 1;\n-\n-\t\t// Same second as last run? -> RRD4j can only handle one sample per second per\n-\t\t// database. Timestamps are all stored \"truncated to seconds\".\n-\t\tif (timestamp.equals(this.lastTimestamp)) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tif (\n-\t\t// No need to persist data, as it is still stored by the Channel itself. The\n-\t\t// Channel keeps the last NO_OF_PAST_VALUES values\n-\t\tthis.cycleCount < Channel.NO_OF_PAST_VALUES\n-\t\t\t\t// RRD4j requires us to write one value per DEFAULT_HEARTBEAT_SECONDS\n-\t\t\t\t&& Duration.between(this.lastTimestamp, timestamp)\n-\t\t\t\t\t\t.getSeconds() < Rrd4jTimedataImpl.DEFAULT_HEARTBEAT_SECONDS - 1) {\n-\t\t\treturn;\n-\t\t}\n-\t\tthis.cycleCount = 0; // Reset Cycle-Count\n-\n-\t\tthis.lastTimestamp = timestamp;\n-\n-\t\tfor (OpenemsComponent component : this.parent.componentManager.getEnabledComponents()) {\n-\t\t\tfor (Channel<?> channel : component.channels()) {\n-\t\t\t\tDoc doc = channel.channelDoc();\n-\t\t\t\tif ( // Ignore Low-Priority Channels\n-\t\t\t\tdoc.getPersistencePriority().isLowerThan(this.parent.persistencePriority)\n-\t\t\t\t\t\t// Ignore WRITE_ONLY Channels\n-\t\t\t\t\t\t|| channel.channelDoc().getAccessMode() == AccessMode.WRITE_ONLY) {\n-\t\t\t\t\tcontinue;\n-\t\t\t\t}\n-\n-\t\t\t\tToDoubleFunction<? super Object> channelMapFunction = this\n-\t\t\t\t\t\t.getChannelMapFunction(channel.channelDoc().getType());\n-\t\t\t\tFunction<DoubleStream, OptionalDouble> channelAggregateFunction = this\n-\t\t\t\t\t\t.getChannelAggregateFunction(channel.channelDoc().getUnit());\n-\n-\t\t\t\tOptionalDouble value = channelAggregateFunction.apply(//\n-\t\t\t\t\t\tchannel.getPastValues() //\n-\t\t\t\t\t\t\t\t.tailMap(this.readChannelValuesSince, false) // new values since last recording\n-\t\t\t\t\t\t\t\t.values().stream() //\n-\t\t\t\t\t\t\t\t.map(v -> v.get()) //\n-\t\t\t\t\t\t\t\t.filter(v -> v != null) // only not-null values\n-\t\t\t\t\t\t\t\t.mapToDouble(channelMapFunction) // convert to double\n-\t\t\t\t);\n-\t\t\t\tif (!value.isPresent()) {\n-\t\t\t\t\t// only available channels\n-\t\t\t\t\tcontinue;\n-\t\t\t\t}\n-\n-\t\t\t\tif (this.records.offer(//\n-\t\t\t\t\t\tnew Record(timestamp.getEpochSecond(), channel.address(), channel.channelDoc().getUnit(),\n-\t\t\t\t\t\t\t\tvalue.getAsDouble()))) {\n-\t\t\t\t\tthis.parent._setQueueIsFull(false);\n-\n-\t\t\t\t} else {\n-\t\t\t\t\tthis.parent.logWarn(this.log, \"Unable to add record [\" + channel.address() + \"]. Queue is full!\");\n-\t\t\t\t\tthis.parent._setQueueIsFull(true);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\tthis.readChannelValuesSince = nextReadChannelValuesSince;\n-\t}\n-\n-\t@Override\n-\tprotected void forever() throws InterruptedException {\n-\t\tRecord record = this.records.take();\n-\t\tRrdDb database = null;\n-\n-\t\ttry {\n-\t\t\tdatabase = this.parent.getRrdDb(record.address, record.unit, record.timestamp - 1);\n-\n-\t\t\tif (database.getLastUpdateTime() < record.timestamp) {\n-\t\t\t\t// Avoid and silently ignore error \"IllegalArgumentException: Bad sample time:\n-\t\t\t\t// YYY. Last update time was ZZZ, at least one second step is required\".\n-\n-\t\t\t\t// Add Sample to RRD4J\n-\t\t\t\tSample sample = database.createSample(record.timestamp);\n-\t\t\t\tsample.setValue(0, record.value);\n-\t\t\t\tsample.update();\n-\t\t\t}\n-\n-\t\t\tthis.parent._setUnableToInsertSample(false);\n-\n-\t\t} catch (Throwable e) {\n-\t\t\tthis.parent._setUnableToInsertSample(true);\n-\t\t\tthis.parent.logWarn(this.log, \"Unable to insert Sample [\" + record.address + \"] \"\n-\t\t\t\t\t+ e.getClass().getSimpleName() + \": \" + e.getMessage());\n-\t\t} finally {\n-\t\t\tif (database != null) {\n-\t\t\t\ttry {\n-\t\t\t\t\tdatabase.close();\n-\t\t\t\t} catch (IOException e) {\n-\t\t\t\t\tthis.parent.logWarn(this.log,\n-\t\t\t\t\t\t\t\"Unable to close database [\" + record.address + \"]: \" + e.getMessage());\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate static final ToDoubleFunction<? super Object> MAP_BOOLEAN_TO_DOUBLE = (value) -> {\n-\t\treturn (Boolean) value ? 1d : 0d;\n-\t};\n-\n-\tprivate static final ToDoubleFunction<? super Object> MAP_SHORT_TO_DOUBLE = (value) -> {\n-\t\treturn ((Short) value).doubleValue();\n-\t};\n-\tprivate static final ToDoubleFunction<? super Object> MAP_INTEGER_TO_DOUBLE = (value) -> {\n-\t\treturn ((Integer) value).doubleValue();\n-\t};\n-\tprivate static final ToDoubleFunction<? super Object> MAP_LONG_TO_DOUBLE = (value) -> {\n-\t\treturn ((Long) value).doubleValue();\n-\t};\n-\tprivate static final ToDoubleFunction<? super Object> MAP_FLOAT_TO_DOUBLE = (value) -> {\n-\t\treturn ((Float) value).doubleValue();\n-\t};\n-\tprivate static final ToDoubleFunction<? super Object> MAP_DOUBLE_TO_DOUBLE = (value) -> {\n-\t\treturn (Double) value;\n-\t};\n-\tprivate static final ToDoubleFunction<? super Object> MAP_TO_DOUBLE_NOT_SUPPORTED = (value) -> {\n-\t\treturn 0d;\n-\t};\n-\n-\tprivate ToDoubleFunction<? super Object> getChannelMapFunction(OpenemsType openemsType) {\n-\t\tswitch (openemsType) {\n-\t\tcase BOOLEAN:\n-\t\t\treturn MAP_BOOLEAN_TO_DOUBLE;\n-\t\tcase SHORT:\n-\t\t\treturn MAP_SHORT_TO_DOUBLE;\n-\t\tcase INTEGER:\n-\t\t\treturn MAP_INTEGER_TO_DOUBLE;\n-\t\tcase LONG:\n-\t\t\treturn MAP_LONG_TO_DOUBLE;\n-\t\tcase FLOAT:\n-\t\t\treturn MAP_FLOAT_TO_DOUBLE;\n-\t\tcase DOUBLE:\n-\t\t\treturn MAP_DOUBLE_TO_DOUBLE;\n-\t\tcase STRING:\n-\t\t\t// Strings are not supported by RRD4J\n-\t\t\treturn MAP_TO_DOUBLE_NOT_SUPPORTED;\n-\t\t}\n-\t\tthrow new IllegalArgumentException(\"Type [\" + openemsType + \"] is not supported.\");\n-\t}\n-\n-\tprivate Function<DoubleStream, OptionalDouble> getChannelAggregateFunction(Unit channelUnit) {\n-\t\tswitch (channelUnit) {\n-\t\tcase AMPERE:\n-\t\tcase AMPERE_HOURS:\n-\t\tcase DEGREE_CELSIUS:\n-\t\tcase DEZIDEGREE_CELSIUS:\n-\t\tcase HERTZ:\n-\t\tcase HOUR:\n-\t\tcase KILOAMPERE_HOURS:\n-\t\tcase KILOOHM:\n-\t\tcase KILOVOLT_AMPERE:\n-\t\tcase KILOVOLT_AMPERE_REACTIVE:\n-\t\tcase KILOWATT:\n-\t\tcase MICROOHM:\n-\t\tcase MILLIAMPERE_HOURS:\n-\t\tcase MILLIAMPERE:\n-\t\tcase MILLIHERTZ:\n-\t\tcase MILLIOHM:\n-\t\tcase MILLISECONDS:\n-\t\tcase MILLIVOLT:\n-\t\tcase MILLIWATT:\n-\t\tcase MINUTE:\n-\t\tcase NONE:\n-\t\tcase WATT:\n-\t\tcase VOLT:\n-\t\tcase VOLT_AMPERE:\n-\t\tcase VOLT_AMPERE_REACTIVE:\n-\t\tcase WATT_HOURS_BY_WATT_PEAK:\n-\t\tcase OHM:\n-\t\tcase SECONDS:\n-\t\tcase THOUSANDTH:\n-\t\tcase PERCENT:\n-\t\tcase ON_OFF:\n-\t\t\treturn DoubleStream::average;\n-\t\tcase CUMULATED_SECONDS:\n-\t\tcase WATT_HOURS:\n-\t\tcase KILOWATT_HOURS:\n-\t\tcase VOLT_AMPERE_HOURS:\n-\t\tcase VOLT_AMPERE_REACTIVE_HOURS:\n-\t\tcase KILOVOLT_AMPERE_REACTIVE_HOURS:\n-\t\t\treturn DoubleStream::max;\n-\t\t}\n-\t\tthrow new IllegalArgumentException(\"Channel Unit [\" + channelUnit + \"] is not supported.\");\n-\t}\n+  protected static final int DEFAULT_NO_OF_CYCLES = 60;\n+\n+  private final Logger log = LoggerFactory.getLogger(RecordWorker.class);\n+  private final Rrd4jTimedataImpl parent;\n+\n+  // Counts the number of Cycles till data is recorded\n+  private int cycleCount = 0;\n+\n+  private static class Record {\n+    private final long timestamp;\n+    private final ChannelAddress address;\n+    private final Unit unit;\n+    private final double value;\n+\n+    public Record(long timestamp, ChannelAddress address, Unit unit, double value) {\n+      this.timestamp = timestamp;\n+      this.address = address;\n+      this.unit = unit;\n+      this.value = value;\n+    }\n+  }\n+\n+  // Record queue\n+  private LinkedBlockingQueue<Record> records = new LinkedBlockingQueue<>();\n+\n+  // keeps the last recorded timestamp\n+  private Instant lastTimestamp = Instant.MIN;\n+  private LocalDateTime readChannelValuesSince = LocalDateTime.MIN;\n+\n+  public RecordWorker(Rrd4jTimedataImpl parent) {\n+    this.parent = parent;\n+  }\n+\n+  /**\n+   * Collects the data from Channels. This is called synchronously by the main\n+   * OpenEMS cycle. On finish it triggers a next async task to write the data to\n+   * RRD4J.\n+   */\n+  public void collectData() {\n+    Instant timestamp = Instant.now().truncatedTo(ChronoUnit.SECONDS);\n+    final LocalDateTime nextReadChannelValuesSince = LocalDateTime.now();\n+\n+    // Increase CycleCount\n+    this.cycleCount += 1;\n+\n+    // Same second as last run? -> RRD4j can only handle one sample per second per\n+    // database. Timestamps are all stored \"truncated to seconds\".\n+    if (timestamp.equals(this.lastTimestamp)) {\n+      return;\n+    }\n+\n+    if (\n+      // No need to persist data, as it is still stored by the Channel itself. The\n+      // Channel keeps the last NO_OF_PAST_VALUES values\n+        this.cycleCount < Channel.NO_OF_PAST_VALUES\n+            // RRD4j requires us to write one value per DEFAULT_HEARTBEAT_SECONDS\n+            && Duration.between(this.lastTimestamp, timestamp)\n+            .getSeconds() < Rrd4jTimedataImpl.DEFAULT_HEARTBEAT_SECONDS - 1) {\n+      return;\n+    }\n+    this.cycleCount = 0; // Reset Cycle-Count\n+\n+    this.lastTimestamp = timestamp;\n+\n+    for (OpenemsComponent component : this.parent.componentManager.getEnabledComponents()) {\n+      for (Channel<?> channel : component.channels()) {\n+        Doc doc = channel.channelDoc();\n+        if ( // Ignore Low-Priority Channels\n+            doc.getPersistencePriority().isLowerThan(this.parent.persistencePriority)\n+                // Ignore WRITE_ONLY Channels\n+                || channel.channelDoc().getAccessMode() == AccessMode.WRITE_ONLY) {\n+          continue;\n+        }\n+\n+        ToDoubleFunction<? super Object> channelMapFunction = this\n+            .getChannelMapFunction(channel.channelDoc().getType());\n+        Function<DoubleStream, OptionalDouble> channelAggregateFunction = this\n+            .getChannelAggregateFunction(channel.channelDoc().getUnit());\n+\n+        OptionalDouble value = channelAggregateFunction.apply(//\n+            channel.getPastValues() //\n+                .tailMap(this.readChannelValuesSince, false) // new values since last recording\n+                .values().stream() //\n+                .map(v -> v.get()) //\n+                .filter(v -> v != null) // only not-null values\n+                .mapToDouble(channelMapFunction) // convert to double\n+        );\n+        if (!value.isPresent()) {\n+          // only available channels\n+          continue;\n+        }\n+\n+        if (this.records.offer(//\n+            new Record(timestamp.getEpochSecond(), channel.address(), channel.channelDoc().getUnit(),\n+                value.getAsDouble()))) {\n+          this.parent._setQueueIsFull(false);\n+\n+        } else {\n+          this.parent.logWarn(this.log, \"Unable to add record [\" + channel.address() + \"]. Queue is full!\");\n+          this.parent._setQueueIsFull(true);\n+        }\n+      }\n+    }\n+\n+    this.readChannelValuesSince = nextReadChannelValuesSince;\n+  }\n+\n+  @Override\n+  protected void forever() throws InterruptedException {\n+    Record record = this.records.take();\n+    RrdDb database = null;\n+\n+    try {\n+      database = this.parent.getRrdDb(record.address, record.unit, record.timestamp - 1);\n+\n+      if (database.getLastUpdateTime() < record.timestamp) {\n+        // Avoid and silently ignore error \"IllegalArgumentException: Bad sample time:\n+        // YYY. Last update time was ZZZ, at least one second step is required\".\n+\n+        // Add Sample to RRD4J\n+        Sample sample = database.createSample(record.timestamp);\n+        sample.setValue(0, record.value);\n+        sample.update();\n+      }\n+\n+      this.parent._setUnableToInsertSample(false);\n+\n+    } catch (Throwable e) {\n+      this.parent._setUnableToInsertSample(true);\n+      this.parent.logWarn(this.log, \"Unable to insert Sample [\" + record.address + \"] \"\n+          + e.getClass().getSimpleName() + \": \" + e.getMessage());\n+    } finally {\n+      if (database != null) {\n+        try {\n+          database.close();\n+        } catch (IOException e) {\n+          this.parent.logWarn(this.log,\n+              \"Unable to close database [\" + record.address + \"]: \" + e.getMessage());\n+        }\n+      }\n+    }\n+  }\n+\n+  private static final ToDoubleFunction<? super Object> MAP_BOOLEAN_TO_DOUBLE = (value) -> {\n+    return (Boolean) value ? 1d : 0d;\n+  };\n+\n+  private static final ToDoubleFunction<? super Object> MAP_SHORT_TO_DOUBLE = (value) -> {\n+    return ((Short) value).doubleValue();\n+  };\n+  private static final ToDoubleFunction<? super Object> MAP_INTEGER_TO_DOUBLE = (value) -> {\n+    return ((Integer) value).doubleValue();\n+  };\n+  private static final ToDoubleFunction<? super Object> MAP_LONG_TO_DOUBLE = (value) -> {\n+    return ((Long) value).doubleValue();\n+  };\n+  private static final ToDoubleFunction<? super Object> MAP_FLOAT_TO_DOUBLE = (value) -> {\n+    return ((Float) value).doubleValue();\n+  };\n+  private static final ToDoubleFunction<? super Object> MAP_DOUBLE_TO_DOUBLE = (value) -> {\n+    return (Double) value;\n+  };\n+  private static final ToDoubleFunction<? super Object> MAP_TO_DOUBLE_NOT_SUPPORTED = (value) -> {\n+    return 0d;\n+  };\n+\n+  private ToDoubleFunction<? super Object> getChannelMapFunction(OpenemsType openemsType) {\n+    switch (openemsType) {\n+      case BOOLEAN:\n+        return MAP_BOOLEAN_TO_DOUBLE;\n+      case SHORT:\n+        return MAP_SHORT_TO_DOUBLE;\n+      case INTEGER:\n+        return MAP_INTEGER_TO_DOUBLE;\n+      case LONG:\n+        return MAP_LONG_TO_DOUBLE;\n+      case FLOAT:\n+        return MAP_FLOAT_TO_DOUBLE;\n+      case DOUBLE:\n+        return MAP_DOUBLE_TO_DOUBLE;\n+      case STRING:\n+        // Strings are not supported by RRD4J\n+        return MAP_TO_DOUBLE_NOT_SUPPORTED;\n+    }\n+    throw new IllegalArgumentException(\"Type [\" + openemsType + \"] is not supported.\");\n+  }\n+\n+  private Function<DoubleStream, OptionalDouble> getChannelAggregateFunction(Unit channelUnit) {\n+    switch (channelUnit) {\n+      case AMPERE:\n+      case AMPERE_HOURS:\n+      case DEGREE_CELSIUS:\n+      case DEZIDEGREE_CELSIUS:\n+      case HERTZ:\n+      case HOUR:\n+      case KILOAMPERE_HOURS:\n+      case KILOOHM:\n+      case KILOVOLT_AMPERE:\n+      case KILOVOLT_AMPERE_REACTIVE:\n+      case KILOWATT:\n+      case MICROOHM:\n+      case MILLIAMPERE_HOURS:\n+      case MILLIAMPERE:\n+      case MILLIHERTZ:\n+      case MILLIOHM:\n+      case MILLISECONDS:\n+      case MILLIVOLT:\n+      case MILLIWATT:\n+      case MINUTE:\n+      case NONE:\n+      case WATT:\n+      case VOLT:\n+      case VOLT_AMPERE:\n+      case VOLT_AMPERE_REACTIVE:\n+      case WATT_HOURS_BY_WATT_PEAK:\n+      case OHM:\n+      case SECONDS:\n+      case THOUSANDTH:\n+      case PERCENT:\n+      case ON_OFF:\n+        return DoubleStream::average;\n+      case CUMULATED_SECONDS:\n+      case WATT_HOURS:\n+      case KILOWATT_HOURS:\n+      case VOLT_AMPERE_HOURS:\n+      case VOLT_AMPERE_REACTIVE_HOURS:\n+      case KILOVOLT_AMPERE_REACTIVE_HOURS:\n+        return DoubleStream::max;\n+    }\n+    throw new IllegalArgumentException(\"Channel Unit [\" + channelUnit + \"] is not supported.\");\n+  }\n \n }\n",
            "diff_size": 231
        },
        {
            "tool": "naturalize",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/OpenEMS-openems/errored/1/39/RecordWorker.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/OpenEMS-openems/naturalize/39/RecordWorker.java\nindex 265a177b420..4fe3041cbf0 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/OpenEMS-openems/errored/1/39/RecordWorker.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/OpenEMS-openems/naturalize/39/RecordWorker.java\n@@ -85,7 +85,7 @@ public class RecordWorker extends AbstractImmediateWorker {\n \t\t\t\t// RRD4j requires us to write one value per DEFAULT_HEARTBEAT_SECONDS\n \t\t\t\t&& Duration.between(this.lastTimestamp, timestamp)\n \t\t\t\t\t\t.getSeconds() < Rrd4jTimedataImpl.DEFAULT_HEARTBEAT_SECONDS - 1) {\n-\t\t\treturn;\n+\treturn;\n \t\t}\n \t\tthis.cycleCount = 0; // Reset Cycle-Count\n \n@@ -94,7 +94,7 @@ public class RecordWorker extends AbstractImmediateWorker {\n \t\tfor (OpenemsComponent component : this.parent.componentManager.getEnabledComponents()) {\n \t\t\tfor (Channel<?> channel : component.channels()) {\n \t\t\t\tDoc doc = channel.channelDoc();\n-\t\t\t\tif ( // Ignore Low-Priority Channels\n+\t\t\t\tif (// Ignore Low-Priority Channels\n \t\t\t\tdoc.getPersistencePriority().isLowerThan(this.parent.persistencePriority)\n \t\t\t\t\t\t// Ignore WRITE_ONLY Channels\n \t\t\t\t\t\t|| channel.channelDoc().getAccessMode() == AccessMode.WRITE_ONLY) {\n@@ -122,7 +122,7 @@ public class RecordWorker extends AbstractImmediateWorker {\n \t\t\t\tif (this.records.offer(//\n \t\t\t\t\t\tnew Record(timestamp.getEpochSecond(), channel.address(), channel.channelDoc().getUnit(),\n \t\t\t\t\t\t\t\tvalue.getAsDouble()))) {\n-\t\t\t\t\tthis.parent._setQueueIsFull(false);\n+\tthis.parent._setQueueIsFull(false);\n \n \t\t\t\t} else {\n \t\t\t\t\tthis.parent.logWarn(this.log, \"Unable to add record [\" + channel.address() + \"]. Queue is full!\");\n@@ -259,4 +259,4 @@ public class RecordWorker extends AbstractImmediateWorker {\n \t\tthrow new IllegalArgumentException(\"Channel Unit [\" + channelUnit + \"] is not supported.\");\n \t}\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 4
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/OpenEMS-openems/errored/1/39/RecordWorker.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/OpenEMS-openems/styler_random/39/RecordWorker.java\nindex 265a177b420..c8f309e7607 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/OpenEMS-openems/errored/1/39/RecordWorker.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/OpenEMS-openems/styler_random/39/RecordWorker.java\n@@ -94,7 +94,7 @@ public class RecordWorker extends AbstractImmediateWorker {\n \t\tfor (OpenemsComponent component : this.parent.componentManager.getEnabledComponents()) {\n \t\t\tfor (Channel<?> channel : component.channels()) {\n \t\t\t\tDoc doc = channel.channelDoc();\n-\t\t\t\tif ( // Ignore Low-Priority Channels\n+\t\t\t\tif (// Ignore Low-Priority Channels\n \t\t\t\tdoc.getPersistencePriority().isLowerThan(this.parent.persistencePriority)\n \t\t\t\t\t\t// Ignore WRITE_ONLY Channels\n \t\t\t\t\t\t|| channel.channelDoc().getAccessMode() == AccessMode.WRITE_ONLY) {\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/OpenEMS-openems/errored/1/39/RecordWorker.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/OpenEMS-openems/styler_three_grams/39/RecordWorker.java\nindex 265a177b420..c8f309e7607 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/OpenEMS-openems/errored/1/39/RecordWorker.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/OpenEMS-openems/styler_three_grams/39/RecordWorker.java\n@@ -94,7 +94,7 @@ public class RecordWorker extends AbstractImmediateWorker {\n \t\tfor (OpenemsComponent component : this.parent.componentManager.getEnabledComponents()) {\n \t\t\tfor (Channel<?> channel : component.channels()) {\n \t\t\t\tDoc doc = channel.channelDoc();\n-\t\t\t\tif ( // Ignore Low-Priority Channels\n+\t\t\t\tif (// Ignore Low-Priority Channels\n \t\t\t\tdoc.getPersistencePriority().isLowerThan(this.parent.persistencePriority)\n \t\t\t\t\t\t// Ignore WRITE_ONLY Channels\n \t\t\t\t\t\t|| channel.channelDoc().getAccessMode() == AccessMode.WRITE_ONLY) {\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "styler",
        "naturalize",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "intellij",
        "codebuff"
    ]
}