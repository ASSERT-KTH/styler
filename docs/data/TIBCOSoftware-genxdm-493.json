{
    "project_name": "TIBCOSoftware-genxdm",
    "error_id": "493",
    "information": {
        "errors": [
            {
                "line": "535",
                "column": "13",
                "severity": "warning",
                "message": "File contains tab characters (this is the first instance).",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
            }
        ]
    },
    "source_code": "            if (m_existingCache.hasAttribute(name))\n            {\n            \tif(!m_lastInWins)\n            \t{\n            \t\t// We are not allowing this schema parse to create new elements.  \n                    m_inCache.m_attributesUnresolved.remove(name);",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "536",
                    "column": "13",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/493/XMLSchemaConverter.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler/493/XMLSchemaConverter.java\nindex 790f70021c3..9b99606b2f1 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/493/XMLSchemaConverter.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler/493/XMLSchemaConverter.java\n@@ -532,7 +532,7 @@ public final class XMLSchemaConverter\n                 return m_outBag.getAttribute(name);\n             if (m_existingCache.hasAttribute(name))\n             {\n-            \tif(!m_lastInWins)\n+            if(!m_lastInWins)\n             \t{\n             \t\t// We are not allowing this schema parse to create new elements.  \n                     m_inCache.m_attributesUnresolved.remove(name);\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/493/XMLSchemaConverter.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/intellij/493/XMLSchemaConverter.java\nindex 790f70021c3..587534cc15e 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/493/XMLSchemaConverter.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/intellij/493/XMLSchemaConverter.java\n@@ -13,6 +13,7 @@ QName * Copyright (c) 2009-2010 TIBCO Software Inc.\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+\n package org.genxdm.processor.w3c.xs.impl;\n \n import java.math.BigInteger;\n@@ -158,13 +159,12 @@ import org.genxdm.xs.types.UnionSimpleType;\n  * distracting arguments to methods. The use of a static entry point and a private initializer protects against multiple\n  * invocations.\n  */\n-public final class XMLSchemaConverter\n-{\n-    private XMLSchemaConverter(final SchemaRegExCompiler regexc, final ComponentProvider outCache, \n-                               final XMLSchemaCache inCache, final ComponentBagImpl schema, \n-                               final XMLBidiComponentLocator locations, final SchemaExceptionHandler errors, \n-                               final boolean lastInWins)\n-    {\n+public final class XMLSchemaConverter {\n+    private XMLSchemaConverter(final SchemaRegExCompiler regexc, final ComponentProvider outCache,\n+                               final XMLSchemaCache inCache, final ComponentBagImpl schema,\n+                               final XMLBidiComponentLocator locations,\n+                               final SchemaExceptionHandler errors,\n+                               final boolean lastInWins) {\n         this.regexc = regexc;\n         this.m_existingCache = outCache;\n         this.m_atoms = new CanonicalAtomBridge(outCache);\n@@ -176,102 +176,98 @@ public final class XMLSchemaConverter\n         this.m_lastInWins = lastInWins;\n     }\n \n-    private SchemaWildcard attributeWildcard(final Type baseType)\n-    {\n-        if (baseType instanceof ComplexType)\n-        {\n-            final ComplexType complexBase = (ComplexType)baseType;\n+    private SchemaWildcard attributeWildcard(final Type baseType) {\n+        if (baseType instanceof ComplexType) {\n+            final ComplexType complexBase = (ComplexType) baseType;\n             final SchemaWildcard attributeWildcard = complexBase.getAttributeWildcard();\n-            if (attributeWildcard != null)\n+            if (attributeWildcard != null) {\n                 return attributeWildcard;\n-            else\n+            } else {\n                 return null;\n-        }\n-        else if (baseType instanceof SimpleType)\n+            }\n+        } else if (baseType instanceof SimpleType) {\n             return null;\n-        else\n+        } else {\n             throw new AssertionError(baseType);\n+        }\n     }\n \n-    private SchemaWildcard attributeWildcard(final XMLType complexType) \n-        throws AbortException, SchemaException\n-    {\n+    private SchemaWildcard attributeWildcard(final XMLType complexType)\n+        throws AbortException, SchemaException {\n         final XMLWildcard localWildcard = complexType.attributeWildcard;\n \n         final DerivationMethod derivation = complexType.getDerivationMethod();\n-        switch (derivation)\n-        {\n-            case Restriction:\n-            {\n+        switch (derivation) {\n+            case Restriction: {\n                 return completeWildcard(complexType.getAttributeGroups(), localWildcard);\n             }\n-            case Extension:\n-            {\n+            case Extension: {\n                 final SchemaWildcard baseWildcard = attributeWildcard(complexType.getBaseRef());\n-                if (baseWildcard != null)\n-                {\n-                    final SchemaWildcard completeWildcard = completeWildcard(complexType.getAttributeGroups(), localWildcard);\n-                    if (completeWildcard == null)\n+                if (baseWildcard != null) {\n+                    final SchemaWildcard completeWildcard =\n+                        completeWildcard(complexType.getAttributeGroups(), localWildcard);\n+                    if (completeWildcard == null) {\n                         return baseWildcard;\n+                    }\n                     // {process contents} and {annotation} from complete wildcard.\n                     // {namespace constraint} is union of the complete and base wildcard.\n-                    return new WildcardImpl(completeWildcard.getProcessContents(), completeWildcard.getNamespaceConstraint().union(baseWildcard.getNamespaceConstraint()));\n+                    return new WildcardImpl(completeWildcard.getProcessContents(),\n+                        completeWildcard.getNamespaceConstraint()\n+                            .union(baseWildcard.getNamespaceConstraint()));\n                 }\n                 return completeWildcard(complexType.getAttributeGroups(), localWildcard);\n             }\n-            default:\n-            {\n+            default: {\n                 throw new AssertionError(derivation);\n             }\n         }\n     }\n \n-    private SchemaWildcard attributeWildcard(final XMLTypeRef typeRef) \n-        throws AbortException, SchemaException\n-    {\n+    private SchemaWildcard attributeWildcard(final XMLTypeRef typeRef)\n+        throws AbortException, SchemaException {\n         final Type type = convertType(typeRef);\n         return attributeWildcard(type);\n     }\n \n-    private SchemaWildcard completeWildcard(final Iterable<XMLAttributeGroup> attributeGroups, final XMLWildcard localWildcard) \n-        throws AbortException, SchemaException\n-    {\n+    private SchemaWildcard completeWildcard(final Iterable<XMLAttributeGroup> attributeGroups,\n+                                            final XMLWildcard localWildcard)\n+        throws AbortException, SchemaException {\n         NamespaceConstraint constraint = null;\n \n         // Remember the first {process contents} within the <attributeGroup>[children].\n         ProcessContentsMode processContents = null;\n-        if (attributeGroups != null)\n-        {\n-            for (final XMLAttributeGroup xmlAttributeGroup : attributeGroups)\n-            {\n-                final AttributeGroupDefinition attributeGroup = convertAttributeGroup(xmlAttributeGroup);\n+        if (attributeGroups != null) {\n+            for (final XMLAttributeGroup xmlAttributeGroup : attributeGroups) {\n+                final AttributeGroupDefinition attributeGroup =\n+                    convertAttributeGroup(xmlAttributeGroup);\n                 final SchemaWildcard groupWildcard = attributeGroup.getWildcard();\n-                if (groupWildcard != null)\n-                {\n-                    if (constraint == null)\n-                    {\n+                if (groupWildcard != null) {\n+                    if (constraint == null) {\n                         constraint = groupWildcard.getNamespaceConstraint();\n                         processContents = groupWildcard.getProcessContents();\n+                    } else {\n+                        constraint =\n+                            constraint.intersection(groupWildcard.getNamespaceConstraint());\n                     }\n-                    else\n-                        constraint = constraint.intersection(groupWildcard.getNamespaceConstraint());\n                 }\n             }\n         }\n \n-        if (constraint == null)\n-        {\n+        if (constraint == null) {\n             // If nothing is found in the <attributeGroup>[children]...\n-            if (localWildcard != null)\n-                return new WildcardImpl(localWildcard.getProcessContents(), convert(localWildcard.getNamespaceConstraint()));\n+            if (localWildcard != null) {\n+                return new WildcardImpl(localWildcard.getProcessContents(),\n+                    convert(localWildcard.getNamespaceConstraint()));\n+            }\n             return null;\n-        }\n-        else\n-        {\n+        } else {\n             if (localWildcard != null)\n-                // {process contents} and {annotation} are those of the local wildcard.\n-                // {namespace constraint} defined by Attribute Wildcard Intersection.\n-                return new WildcardImpl(localWildcard.getProcessContents(), convert(localWildcard.getNamespaceConstraint()).intersection(constraint));\n+            // {process contents} and {annotation} are those of the local wildcard.\n+            // {namespace constraint} defined by Attribute Wildcard Intersection.\n+            {\n+                return new WildcardImpl(localWildcard.getProcessContents(),\n+                    convert(localWildcard.getNamespaceConstraint()).intersection(constraint));\n+            }\n             // {process contents} from first <attributeGroup>[children]\n             // {namespace constraint} from the <attributeGroup>[children] {annotation} is absent.\n             return new WildcardImpl(processContents, constraint);\n@@ -281,83 +277,73 @@ public final class XMLSchemaConverter\n     /**\n      * Expand temporary variables used to hold syntactic constructs for attribute uses and wildcards.\n      */\n-    private Map<QName, AttributeUse> computeAttributeUses(final XMLType complexType, final Map<QName, AttributeUse> attributeUses) \n-        throws AbortException, SchemaException\n-    {\n-        for (final XMLAttributeUse attributeUse : complexType.getAttributeUses())\n-        {\n+    private Map<QName, AttributeUse> computeAttributeUses(final XMLType complexType,\n+                                                          final Map<QName, AttributeUse> attributeUses)\n+        throws AbortException, SchemaException {\n+        for (final XMLAttributeUse attributeUse : complexType.getAttributeUses()) {\n             final QName attributeName = attributeUse.getDeclaration().getName();\n-            try\n-            {\n-                if (!attributeUses.containsKey(attributeName))\n+            try {\n+                if (!attributeUses.containsKey(attributeName)) {\n                     attributeUses.put(attributeName, convertAttributeUse(attributeUse));\n-                else\n+                } else {\n                     m_errors.error(new SccAttributeGroupMemberNamesException());\n-            }\n-            catch (final SchemaException e)\n-            {\n+                }\n+            } catch (final SchemaException e) {\n                 m_errors.error(e);\n             }\n         }\n \n-        for (final XMLAttributeGroup xmlAttributeGroup : complexType.getAttributeGroups())\n-        {\n-            final AttributeGroupDefinition attributeGroup = convertAttributeGroup(xmlAttributeGroup);\n-            if (attributeGroup.hasAttributeUses())\n-            {\n-                for (final AttributeUse attributeUse : attributeGroup.getAttributeUses())\n-                {\n+        for (final XMLAttributeGroup xmlAttributeGroup : complexType.getAttributeGroups()) {\n+            final AttributeGroupDefinition attributeGroup =\n+                convertAttributeGroup(xmlAttributeGroup);\n+            if (attributeGroup.hasAttributeUses()) {\n+                for (final AttributeUse attributeUse : attributeGroup.getAttributeUses()) {\n                     final AttributeDefinition attribute = attributeUse.getAttribute();\n                     final QName attributeName = attribute.getName();\n-                    if (!attributeUses.containsKey(attributeName))\n+                    if (!attributeUses.containsKey(attributeName)) {\n                         attributeUses.put(attributeName, attributeUse);\n-                    else\n+                    } else {\n                         m_errors.error(new SccAttributeGroupMemberNamesException());\n+                    }\n                 }\n             }\n         }\n \n-        switch (complexType.getDerivationMethod())\n-        {\n-            case Restriction:\n-            {\n+        switch (complexType.getDerivationMethod()) {\n+            case Restriction: {\n                 final Type typeB = convertType(complexType.getBaseRef());\n-                if (typeB instanceof ComplexType)\n-                {\n-                    final ComplexType complexTypeB = (ComplexType)typeB;\n-                    for (final AttributeUse attributeUse : complexTypeB.getAttributeUses().values())\n-                    {\n+                if (typeB instanceof ComplexType) {\n+                    final ComplexType complexTypeB = (ComplexType) typeB;\n+                    for (final AttributeUse attributeUse : complexTypeB.getAttributeUses()\n+                        .values()) {\n                         final QName attributeName = attributeUse.getAttribute().getName();\n-                        if (!complexType.prohibited.contains(attributeName))\n-                        {\n-                            if (!attributeUses.containsKey(attributeName))\n+                        if (!complexType.prohibited.contains(attributeName)) {\n+                            if (!attributeUses.containsKey(attributeName)) {\n                                 attributeUses.put(attributeName, attributeUse);\n+                            }\n                             // else:\n-                                // Obviously can't add it because that would\n-                                // cause a non-unique name.\n-                                // This collision will be analyzed during\n-                                // schema constraint checking.\n+                            // Obviously can't add it because that would\n+                            // cause a non-unique name.\n+                            // This collision will be analyzed during\n+                            // schema constraint checking.\n                         }\n                     }\n                 }\n                 break;\n             }\n-            case Extension:\n-            {\n+            case Extension: {\n                 final Type typeB = convertType(complexType.getBaseRef());\n-                if (typeB instanceof ComplexType)\n-                {\n-                    final ComplexType complexTypeB = (ComplexType)typeB;\n-                    for (final AttributeUse attributeUse : complexTypeB.getAttributeUses().values())\n-                    {\n+                if (typeB instanceof ComplexType) {\n+                    final ComplexType complexTypeB = (ComplexType) typeB;\n+                    for (final AttributeUse attributeUse : complexTypeB.getAttributeUses()\n+                        .values()) {\n                         final QName attributeName = attributeUse.getAttribute().getName();\n                         attributeUses.put(attributeName, attributeUse);\n                     }\n                 }\n                 break;\n             }\n-            default:\n-            {\n+            default: {\n                 throw new RuntimeException(complexType.getDerivationMethod().name());\n             }\n         }\n@@ -369,92 +355,68 @@ public final class XMLSchemaConverter\n      * Compile the enumeration facets for this type. <br/>\n      * Enumeration facets are not inherited during compilation, but must be subsets of base types.\n      */\n-    private void computeEnumerations(final SimpleType baseType, final XMLType type, final SimpleTypeImpl target) \n-        throws AbortException\n-    {\n-        if (type.getEnumerations().size() > 0)\n-        {\n-            for (final XMLEnumeration pattern : type.getEnumerations())\n-            {\n-                try\n-                {\n+    private void computeEnumerations(final SimpleType baseType, final XMLType type,\n+                                     final SimpleTypeImpl target)\n+        throws AbortException {\n+        if (type.getEnumerations().size() > 0) {\n+            for (final XMLEnumeration pattern : type.getEnumerations()) {\n+                try {\n                     target.addEnumeration(enumeration(target, baseType, pattern));\n-                }\n-                catch (final SmAttributeUseException e)\n-                {\n+                } catch (final SmAttributeUseException e) {\n                     m_errors.error(e);\n                 }\n             }\n         }\n     }\n \n-    private void computeFacets(final SimpleType baseType, final XMLType type, final SimpleTypeImpl target) \n-        throws AbortException, SchemaException\n-    {\n-        for (final XMLTotalDigitsFacet xmlFacet : type.getTotalDigitsFacets())\n-        {\n+    private void computeFacets(final SimpleType baseType, final XMLType type,\n+                               final SimpleTypeImpl target)\n+        throws AbortException, SchemaException {\n+        for (final XMLTotalDigitsFacet xmlFacet : type.getTotalDigitsFacets()) {\n             target.addFacet(totalDigits(xmlFacet));\n         }\n-        for (final XMLFractionDigitsFacet xmlFacet : type.getFractionDigitsFacets())\n-        {\n+        for (final XMLFractionDigitsFacet xmlFacet : type.getFractionDigitsFacets()) {\n             target.addFacet(fractionDigits(xmlFacet));\n         }\n         // Note that the length, minLength and maxLength facets are deprecated\n         // for types derived from QName or NOTATION.\n-        if (!subtype(target, m_existingCache.getAtomicType(NativeType.QNAME)) && \n-            !subtype(target, m_existingCache.getAtomicType(NativeType.NOTATION)))\n-        {\n-            for (final XMLLength xmlFacet : type.getLengthFacets())\n-            {\n+        if (!subtype(target, m_existingCache.getAtomicType(NativeType.QNAME)) &&\n+            !subtype(target, m_existingCache.getAtomicType(NativeType.NOTATION))) {\n+            for (final XMLLength xmlFacet : type.getLengthFacets()) {\n                 target.addFacet(length(xmlFacet));\n             }\n         }\n-        for (final XMLMinMaxFacet xmlFacet : type.getMinMaxFacets())\n-        {\n-            if (baseType.isAtomicType())\n-            {\n-                try\n-                {\n-                    target.addFacet(minmax(xmlFacet, (SimpleType)baseType));\n-                }\n-                catch (final SchemaException e)\n-                {\n+        for (final XMLMinMaxFacet xmlFacet : type.getMinMaxFacets()) {\n+            if (baseType.isAtomicType()) {\n+                try {\n+                    target.addFacet(minmax(xmlFacet, (SimpleType) baseType));\n+                } catch (final SchemaException e) {\n                     m_errors.error(e);\n                 }\n             }\n         }\n     }\n \n-    private ContentType computeLocallyEmptyContent(final XMLType complexType) \n-        throws SchemaException, AbortException\n-    {\n+    private ContentType computeLocallyEmptyContent(final XMLType complexType)\n+        throws SchemaException, AbortException {\n         final DerivationMethod derivation = complexType.getDerivationMethod();\n-        switch (derivation)\n-        {\n-            case Restriction:\n-            {\n+        switch (derivation) {\n+            case Restriction: {\n                 return EMPTY_CONTENT;\n             }\n-            case Extension:\n-            {\n+            case Extension: {\n                 final Type baseType = convertType(complexType.getBaseRef());\n-                if (baseType instanceof ComplexType)\n-                {\n-                    final ComplexType complexBase = (ComplexType)baseType;\n+                if (baseType instanceof ComplexType) {\n+                    final ComplexType complexBase = (ComplexType) baseType;\n                     return complexBase.getContentType();\n-                }\n-                else if (baseType instanceof SimpleType)\n-                {\n-                    final SimpleType simpleBase = (SimpleType)baseType;\n+                } else if (baseType instanceof SimpleType) {\n+                    final SimpleType simpleBase = (SimpleType) baseType;\n                     return new ContentTypeImpl(simpleBase);\n-                }\n-                else\n-                {\n+                } else {\n                     throw new AssertionError(derivation);\n                 }\n             }\n-            default:\n-            {\n+            default: {\n                 throw new AssertionError(derivation);\n             }\n         }\n@@ -464,124 +426,106 @@ public final class XMLSchemaConverter\n      * Compile the pattern facets for this type. <br/>\n      * Pattern facets are not inherited during compilation.\n      */\n-    private void computePatterns(final LinkedList<XMLPatternFacet> xmlFacets, final SimpleTypeImpl target) \n-        throws AbortException\n-    {\n-        if (xmlFacets.size() > 0)\n-        {\n-            for (final XMLPatternFacet pattern : xmlFacets)\n-            {\n-                try\n-                {\n+    private void computePatterns(final LinkedList<XMLPatternFacet> xmlFacets,\n+                                 final SimpleTypeImpl target)\n+        throws AbortException {\n+        if (xmlFacets.size() > 0) {\n+            for (final XMLPatternFacet pattern : xmlFacets) {\n+                try {\n                     target.addPattern(pattern(pattern));\n-                }\n-                catch (final SmAttributeUseException e)\n-                {\n+                } catch (final SmAttributeUseException e) {\n                     m_errors.error(e);\n                 }\n             }\n         }\n     }\n \n-    private Set<String> convert(final Iterable<String> strings)\n-    {\n+    private Set<String> convert(final Iterable<String> strings) {\n         final Set<String> result = new HashSet<String>();\n-        for (final String member : strings)\n-        {\n+        for (final String member : strings) {\n             result.add(member);\n         }\n         return result;\n     }\n \n-    private NamespaceConstraint convert(final NamespaceConstraint input)\n-    {\n-        switch (input.getMode())\n-        {\n-            case Any:\n-            {\n+    private NamespaceConstraint convert(final NamespaceConstraint input) {\n+        switch (input.getMode()) {\n+            case Any: {\n                 return NamespaceConstraint.Any();\n             }\n-            case Include:\n-            {\n+            case Include: {\n                 return NamespaceConstraint.include(convert(input.getNamespaces()));\n             }\n-            case Exclude:\n-            {\n+            case Exclude: {\n                 // This approach is a bit long-winded but it generalizes better\n                 // to multiple exclusions.\n                 final Iterator<String> namespaces = convert(input.getNamespaces()).iterator();\n-                if (namespaces.hasNext())\n+                if (namespaces.hasNext()) {\n                     return NamespaceConstraint.exclude(namespaces.next());\n+                }\n                 throw new AssertionError();\n             }\n-            default:\n-            {\n+            default: {\n                 throw new AssertionError(input.getMode());\n             }\n         }\n     }\n \n-    private AttributeDefinition convertAttribute(final XMLAttribute xmlAttribute) \n-        throws AbortException, SchemaException\n-    {\n+    private AttributeDefinition convertAttribute(final XMLAttribute xmlAttribute)\n+        throws AbortException, SchemaException {\n         final QName name = xmlAttribute.getName();\n         final ScopeExtent scope = convertScope(xmlAttribute.getScope());\n-        if (scope == ScopeExtent.Global)\n-        {\n-            if (m_outBag.hasAttribute(name))\n+        if (scope == ScopeExtent.Global) {\n+            if (m_outBag.hasAttribute(name)) {\n                 return m_outBag.getAttribute(name);\n-            if (m_existingCache.hasAttribute(name))\n-            {\n-            \tif(!m_lastInWins)\n-            \t{\n-            \t\t// We are not allowing this schema parse to create new elements.  \n+            }\n+            if (m_existingCache.hasAttribute(name)) {\n+                if (!m_lastInWins) {\n+                    // We are not allowing this schema parse to create new elements.\n                     m_inCache.m_attributesUnresolved.remove(name);\n                     return m_existingCache.getAttributeDeclaration(name);\n-            \t}\n-            \telse if(m_inCache.m_attributesUnresolved.containsKey(name) || m_attributesResolvedFromExistingCache.containsKey(name))\n-            \t{\n-            \t\t// This component is a reference which refers to an imported component; otherwise, its name would not be \n-            \t\t// in the m_inCache.m_XxxUnresolved.  When XMLSchemaCache.registerXxx is called, it removes name from m_XxxUnresolved,\n-            \t\t// and registerXxxt is called when XMLSchemaParser encounters a global component, the only components that can be referenced.\n-            \t\t// So, we're going to remove its name from the list, NOT convert it, and return the existing component.\n+                } else if (m_inCache.m_attributesUnresolved.containsKey(name) ||\n+                    m_attributesResolvedFromExistingCache.containsKey(name)) {\n+                    // This component is a reference which refers to an imported component; otherwise, its name would not be\n+                    // in the m_inCache.m_XxxUnresolved.  When XMLSchemaCache.registerXxx is called, it removes name from m_XxxUnresolved,\n+                    // and registerXxxt is called when XMLSchemaParser encounters a global component, the only components that can be referenced.\n+                    // So, we're going to remove its name from the list, NOT convert it, and return the existing component.\n                     m_inCache.m_attributesUnresolved.remove(name);\n-            \t\tAttributeDefinition existing = m_existingCache.getAttributeDeclaration(name);\n-            \t\tm_attributesResolvedFromExistingCache.put(name, existing);\n+                    AttributeDefinition existing = m_existingCache.getAttributeDeclaration(name);\n+                    m_attributesResolvedFromExistingCache.put(name, existing);\n                     return existing;\n-            \t}\n+                }\n             }\n-            if (m_cycles.attributes.contains(xmlAttribute))\n+            if (m_cycles.attributes.contains(xmlAttribute)) {\n                 throw new SccCyclicAttributeException(name);\n-            else\n+            } else {\n                 m_cycles.attributes.push(xmlAttribute);\n+            }\n         }\n         final AttributeDeclTypeImpl attribute;\n-        try\n-        {\n+        try {\n             attribute = new AttributeDeclTypeImpl(name, scope, m_existingCache.getSimpleUrType());\n-            if (scope == ScopeExtent.Global)\n+            if (scope == ScopeExtent.Global) {\n                 m_outBag.add(attribute);\n+            }\n //System.out.println(\"add attribute \"+name);\n             m_locations.m_attributeLocations.put(xmlAttribute.getLocation(), attribute);\n-        }\n-        finally\n-        {\n-            if (scope == ScopeExtent.Global)\n+        } finally {\n+            if (scope == ScopeExtent.Global) {\n                 m_cycles.attributes.pop();\n+            }\n         }\n         final Type attributeType = convertType(xmlAttribute.typeRef);\n-        if (attributeType instanceof SimpleType)\n-            attribute.setType((SimpleType)attributeType);\n-        else\n+        if (attributeType instanceof SimpleType) {\n+            attribute.setType((SimpleType) attributeType);\n+        } else {\n             m_errors.error(new SccAttributeDeclarationSimpleTypeException(name));\n-        if (xmlAttribute.m_valueConstraint != null)\n-        {\n-            try\n-            {\n-                attribute.setValueConstraint(convertValueConstraint(XMLRepresentation.LN_ATTRIBUTE, xmlAttribute.m_valueConstraint, (SimpleType)attribute.getType()));\n-            }\n-            catch (final SchemaException e)\n-            {\n+        }\n+        if (xmlAttribute.m_valueConstraint != null) {\n+            try {\n+                attribute.setValueConstraint(convertValueConstraint(XMLRepresentation.LN_ATTRIBUTE,\n+                    xmlAttribute.m_valueConstraint, (SimpleType) attribute.getType()));\n+            } catch (final SchemaException e) {\n                 m_errors.error(e);\n             }\n         }\n@@ -589,240 +533,216 @@ public final class XMLSchemaConverter\n         return attribute;\n     }\n \n-    private AttributeGroupDefinition convertAttributeGroup(final XMLAttributeGroup xmlAttributeGroup) \n-        throws AbortException, SchemaException\n-    {\n-        final QName agName = PreCondition.assertArgumentNotNull(xmlAttributeGroup.getName(), \"name\");\n+    private AttributeGroupDefinition convertAttributeGroup(\n+        final XMLAttributeGroup xmlAttributeGroup)\n+        throws AbortException, SchemaException {\n+        final QName agName =\n+            PreCondition.assertArgumentNotNull(xmlAttributeGroup.getName(), \"name\");\n         final ScopeExtent scope = convertScope(xmlAttributeGroup.getScope());\n-        if (scope == ScopeExtent.Global)\n-        {\n-            if (m_outBag.hasAttributeGroup(agName))\n+        if (scope == ScopeExtent.Global) {\n+            if (m_outBag.hasAttributeGroup(agName)) {\n                 return m_outBag.getAttributeGroup(agName);\n-            if (m_existingCache.hasAttributeGroup(agName))\n-            {\n-            \tif (!m_lastInWins)\n-            \t{\n-            \t\t// We are not allowing this schema parse to create new elements.  \n+            }\n+            if (m_existingCache.hasAttributeGroup(agName)) {\n+                if (!m_lastInWins) {\n+                    // We are not allowing this schema parse to create new elements.\n                     m_inCache.m_attributeGroupsUnresolved.remove(agName);\n                     return m_existingCache.getAttributeGroup(agName);\n-            \t}\n-            \telse if (m_inCache.m_attributeGroupsUnresolved.containsKey(agName) || \n-            \t         m_attributeGroupsResolvedFromExistingCache.containsKey(agName))\n-            \t{\n-            \t\t// This component is a reference which refers to an imported component; otherwise, its name would not be \n-            \t\t// in the m_inCache.m_XxxUnresolved.  When XMLSchemaCache.registerXxx is called, it removes name from m_XxxUnresolved,\n-            \t\t// and registerXxxt is called when XMLSchemaParser encounters a global component, the only components that can be referenced.\n-            \t\t// So, we're going to remove its name from the list, NOT convert it, and return the existing component.\n+                } else if (m_inCache.m_attributeGroupsUnresolved.containsKey(agName) ||\n+                    m_attributeGroupsResolvedFromExistingCache.containsKey(agName)) {\n+                    // This component is a reference which refers to an imported component; otherwise, its name would not be\n+                    // in the m_inCache.m_XxxUnresolved.  When XMLSchemaCache.registerXxx is called, it removes name from m_XxxUnresolved,\n+                    // and registerXxxt is called when XMLSchemaParser encounters a global component, the only components that can be referenced.\n+                    // So, we're going to remove its name from the list, NOT convert it, and return the existing component.\n                     m_inCache.m_attributeGroupsUnresolved.remove(agName);\n-            \t\tAttributeGroupDefinition existing = m_existingCache.getAttributeGroup(agName);\n-            \t\tm_attributeGroupsResolvedFromExistingCache.put(agName, existing);\n+                    AttributeGroupDefinition existing = m_existingCache.getAttributeGroup(agName);\n+                    m_attributeGroupsResolvedFromExistingCache.put(agName, existing);\n                     return existing;\n-            \t}\n+                }\n             }\n-            if (m_cycles.attributeGroups.contains(xmlAttributeGroup))\n+            if (m_cycles.attributeGroups.contains(xmlAttributeGroup)) {\n                 throw new SccCyclicAttributeGroupException(xmlAttributeGroup.getName());\n-            else\n+            } else {\n                 m_cycles.attributeGroups.push(xmlAttributeGroup);\n+            }\n         }\n-        try\n-        {\n+        try {\n             final HashMap<QName, AttributeUse> attributeUses = new HashMap<QName, AttributeUse>();\n-            for (final XMLAttributeGroup group : xmlAttributeGroup.getGroups())\n-            {\n+            for (final XMLAttributeGroup group : xmlAttributeGroup.getGroups()) {\n                 final AttributeGroupDefinition attributeGroup = convertAttributeGroup(group);\n-                if (attributeGroup.hasAttributeUses())\n-                {\n-                    for (final AttributeUse attributeUse : attributeGroup.getAttributeUses())\n-                    {\n+                if (attributeGroup.hasAttributeUses()) {\n+                    for (final AttributeUse attributeUse : attributeGroup.getAttributeUses()) {\n                         attributeUses.put(attributeUse.getAttribute().getName(), attributeUse);\n                     }\n                 }\n             }\n-            for (final XMLAttributeUse attributeUse : xmlAttributeGroup.getAttributeUses())\n-            {\n+            for (final XMLAttributeUse attributeUse : xmlAttributeGroup.getAttributeUses()) {\n                 final QName name = attributeUse.getDeclaration().getName();\n-                try\n-                {\n+                try {\n                     attributeUses.put(name, convertAttributeUse(attributeUse));\n-                }\n-                catch (final SchemaException e)\n-                {\n+                } catch (final SchemaException e) {\n                     m_errors.error(e);\n                 }\n             }\n-            final SchemaWildcard completeWildcard = completeWildcard(xmlAttributeGroup.getGroups(), xmlAttributeGroup.wildcard);\n+            final SchemaWildcard completeWildcard =\n+                completeWildcard(xmlAttributeGroup.getGroups(), xmlAttributeGroup.wildcard);\n             final AttributeGroupDefinition attributeGroup;\n-            attributeGroup = new AttributeGroupImpl(agName, scope, attributeUses.values(), completeWildcard);\n+            attributeGroup =\n+                new AttributeGroupImpl(agName, scope, attributeUses.values(), completeWildcard);\n \n-            if (attributeGroup.getScopeExtent() == ScopeExtent.Global)\n+            if (attributeGroup.getScopeExtent() == ScopeExtent.Global) {\n                 m_outBag.add(attributeGroup);\n+            }\n //System.out.println(\"add attribute group \"+agName);\n-            m_locations.m_attributeGroupLocations.put(xmlAttributeGroup.getLocation(), attributeGroup);\n-            copyForeignAttributes(xmlAttributeGroup.foreignAttributes, (AttributeGroupImpl)attributeGroup);\n+            m_locations.m_attributeGroupLocations\n+                .put(xmlAttributeGroup.getLocation(), attributeGroup);\n+            copyForeignAttributes(xmlAttributeGroup.foreignAttributes,\n+                (AttributeGroupImpl) attributeGroup);\n             return attributeGroup;\n-        }\n-        finally\n-        {\n-            if (scope == ScopeExtent.Global)\n+        } finally {\n+            if (scope == ScopeExtent.Global) {\n                 m_cycles.attributeGroups.pop();\n+            }\n         }\n     }\n \n-    private void convertAttributeGroups() \n-        throws AbortException\n-    {\n-        for (final XMLAttributeGroup source : m_inCache.m_attributeGroups.values())\n-        {\n-            try\n-            {\n+    private void convertAttributeGroups()\n+        throws AbortException {\n+        for (final XMLAttributeGroup source : m_inCache.m_attributeGroups.values()) {\n+            try {\n                 QName name = source.getName();\n-                if (!m_lastInWins && (m_existingCache.getAttributeGroup(name) != null))\n+                if (!m_lastInWins && (m_existingCache.getAttributeGroup(name) != null)) {\n                     m_inCache.m_attributeGroupsUnresolved.remove(name);\n+                }\n                 convertAttributeGroup(source);\n-            }\n-            catch (final SchemaException e)\n-            {\n+            } catch (final SchemaException e) {\n                 m_errors.error(e);\n             }\n         }\n     }\n \n-    private void convertAttributes() \n-        throws AbortException\n-    {\n-        for (final XMLAttribute source : m_inCache.m_attributes.values())\n-        {\n-            try\n-            {\n+    private void convertAttributes()\n+        throws AbortException {\n+        for (final XMLAttribute source : m_inCache.m_attributes.values()) {\n+            try {\n                 QName name = source.getName();\n-                \n-                if (!m_lastInWins && m_existingCache.hasAttribute(name))\n+\n+                if (!m_lastInWins && m_existingCache.hasAttribute(name)) {\n                     m_inCache.m_attributesUnresolved.remove(name);\n+                }\n                 convertAttribute(source);\n-            }\n-            catch (final SchemaException e)\n-            {\n+            } catch (final SchemaException e) {\n                 m_errors.error(e);\n             }\n         }\n     }\n \n-    private AttributeUse convertAttributeUse(final XMLAttributeUse xmlAttributeUse) \n-        throws AbortException, SchemaException\n-    {\n+    private AttributeUse convertAttributeUse(final XMLAttributeUse xmlAttributeUse)\n+        throws AbortException, SchemaException {\n         final AttributeDefinition attribute = convertAttribute(xmlAttributeUse.getDeclaration());\n-        final AttributeUseImpl attributeUse = new AttributeUseImpl(xmlAttributeUse.isRequired(), attribute);\n-        if (xmlAttributeUse.getValueConstraint() != null)\n-        {\n+        final AttributeUseImpl attributeUse =\n+            new AttributeUseImpl(xmlAttributeUse.isRequired(), attribute);\n+        if (xmlAttributeUse.getValueConstraint() != null) {\n             final Type attributeType = attribute.getType();\n-            if (attributeType instanceof SimpleType)\n-            {\n-                final SimpleType simpleType = (SimpleType)attributeType;\n-                try\n-                {\n-                    attributeUse.setValueConstraint(convertValueConstraint(XMLRepresentation.LN_ATTRIBUTE, xmlAttributeUse.getValueConstraint(), simpleType));\n-                }\n-                catch (final SchemaException e)\n-                {\n+            if (attributeType instanceof SimpleType) {\n+                final SimpleType simpleType = (SimpleType) attributeType;\n+                try {\n+                    attributeUse.setValueConstraint(\n+                        convertValueConstraint(XMLRepresentation.LN_ATTRIBUTE,\n+                            xmlAttributeUse.getValueConstraint(), simpleType));\n+                } catch (final SchemaException e) {\n                     m_errors.error(e);\n                 }\n-            }\n-            else if (attributeType instanceof SimpleUrType)\n-            {\n+            } else if (attributeType instanceof SimpleUrType) {\n                 // TODO: Do we set the value constraint with xs:untypedAtomic?\n-            }\n-            else\n+            } else {\n                 throw new AssertionError(attributeType);\n+            }\n         }\n         return attributeUse;\n     }\n \n-    private ComplexType convertComplexType(final QName outName, final boolean isAnonymous, final XMLType xmlComplexType) \n-        throws AbortException, SchemaException\n-    {\n+    private ComplexType convertComplexType(final QName outName, final boolean isAnonymous,\n+                                           final XMLType xmlComplexType)\n+        throws AbortException, SchemaException {\n         final ScopeExtent scope = convertScope(xmlComplexType.getScope());\n-        if (scope == ScopeExtent.Global)\n-        {\n-            if (m_outBag.hasComplexType(outName))\n+        if (scope == ScopeExtent.Global) {\n+            if (m_outBag.hasComplexType(outName)) {\n                 return m_outBag.getComplexType(outName);\n-            if (m_existingCache.hasComplexType(outName))\n-            {\n-            \tif (!m_lastInWins)\n-            \t{\n-            \t\t// We are not allowing this schema parse to create new elements.  \n+            }\n+            if (m_existingCache.hasComplexType(outName)) {\n+                if (!m_lastInWins) {\n+                    // We are not allowing this schema parse to create new elements.\n                     m_inCache.m_typesUnresolved.remove(outName);\n                     return m_existingCache.getComplexType(outName);\n-            \t}\n-            \telse if (m_inCache.m_typesUnresolved.containsKey(outName) || \n-            \t         m_typesResolvedFromExistingCache.containsKey(outName))\n-            \t{\n-            \t\t// This component is a reference which refers to an imported component; otherwise, its name would not be \n-            \t\t// in the m_inCache.m_XxxUnresolved.  When XMLSchemaCache.registerXxx is called, it removes name from m_XxxUnresolved,\n-            \t\t// and registerXxxt is called when XMLSchemaParser encounters a global component, the only components that can be referenced.\n-            \t\t// So, we're going to remove its name from the list, NOT convert it, and return the existing component.\n+                } else if (m_inCache.m_typesUnresolved.containsKey(outName) ||\n+                    m_typesResolvedFromExistingCache.containsKey(outName)) {\n+                    // This component is a reference which refers to an imported component; otherwise, its name would not be\n+                    // in the m_inCache.m_XxxUnresolved.  When XMLSchemaCache.registerXxx is called, it removes name from m_XxxUnresolved,\n+                    // and registerXxxt is called when XMLSchemaParser encounters a global component, the only components that can be referenced.\n+                    // So, we're going to remove its name from the list, NOT convert it, and return the existing component.\n                     m_inCache.m_typesUnresolved.remove(outName);\n-            \t\tComplexType existing = m_existingCache.getComplexType(outName);\n-            \t\tm_typesResolvedFromExistingCache.put(outName, existing);\n+                    ComplexType existing = m_existingCache.getComplexType(outName);\n+                    m_typesResolvedFromExistingCache.put(outName, existing);\n                     return existing;\n-            \t}\n+                }\n             }\n-            if (m_cycles.types.contains(xmlComplexType))\n+            if (m_cycles.types.contains(xmlComplexType)) {\n                 throw new SmCyclicTypeException(outName);\n+            }\n \n             // if we get here, we don't have an existing type, so set up a couple\n             // of collections before we create stuff.\n             m_cycles.types.push(xmlComplexType);\n             m_complexTypeNameCycles.push(xmlComplexType.getName());\n         }\n-        try\n-        {\n-            final Map<QName, AttributeUse> attributeUses = new HashMap<QName,AttributeUse>();\n-    \n+        try {\n+            final Map<QName, AttributeUse> attributeUses = new HashMap<QName, AttributeUse>();\n+\n             // Constructing and registering the complex type allows it to be\n             // referenced in the {content type} property.\n-            final ComplexTypeImpl complexType = new ComplexTypeImpl(outName, false, isAnonymous, scope, null, xmlComplexType.getDerivationMethod(), attributeUses, EMPTY_CONTENT, xmlComplexType.getBlock(), m_existingCache.getAtomicType(NativeType.UNTYPED_ATOMIC));\n-            \n+            final ComplexTypeImpl complexType =\n+                new ComplexTypeImpl(outName, false, isAnonymous, scope, null,\n+                    xmlComplexType.getDerivationMethod(), attributeUses, EMPTY_CONTENT,\n+                    xmlComplexType.getBlock(),\n+                    m_existingCache.getAtomicType(NativeType.UNTYPED_ATOMIC));\n+\n             m_outBag.add(complexType);\n //System.out.println(\"add complex type \"+outName);\n             m_locations.m_complexTypeLocations.put(xmlComplexType.getLocation(), complexType);\n-            \n+\n             final Type baseType = convertType(xmlComplexType.getBaseRef());\n             complexType.setBaseType(baseType);\n-            \n+\n             computeAttributeUses(xmlComplexType, attributeUses);\n             complexType.setContentType(convertContentType(xmlComplexType));\n-    \n+\n             complexType.setAbstract(xmlComplexType.isAbstract());\n             complexType.setAttributeWildcard(attributeWildcard(xmlComplexType));\n-    \n-            for (final DerivationMethod derivation : xmlComplexType.getBlock())\n-            {\n+\n+            for (final DerivationMethod derivation : xmlComplexType.getBlock()) {\n                 complexType.setBlock(derivation, true);\n             }\n-    \n-            for (final DerivationMethod derivation : xmlComplexType.getFinal())\n-            {\n-                if (derivation.isExtension() || derivation.isRestriction())\n+\n+            for (final DerivationMethod derivation : xmlComplexType.getFinal()) {\n+                if (derivation.isExtension() || derivation.isRestriction()) {\n                     complexType.setFinal(derivation, true);\n-                else\n+                } else {\n                     throw new AssertionError(derivation);\n+                }\n             }\n             copyForeignAttributes(xmlComplexType.foreignAttributes, complexType);\n             return complexType;\n-        }\n-        finally\n-        {\n-            if (scope == ScopeExtent.Global)\n-            {\n+        } finally {\n+            if (scope == ScopeExtent.Global) {\n                 // done constructing; now remove this guy from both cycles\n                 m_cycles.types.pop();\n                 final QName name = m_complexTypeNameCycles.pop();\n                 // If we have any late resolutions to do, make sure we're back at the point of the\n                 // stack where the late resolutions needs to begin; that ensures that the necessary base \n                 // type(s) have been resolved.  (See GXML-45 for relevant use cases.)\n-                if (!m_lateTypeResolutionNameList.isEmpty() &&  \n-                     name.equals(m_lateTypeResolutionNameList.get(0)))\n-                {\n+                if (!m_lateTypeResolutionNameList.isEmpty() &&\n+                    name.equals(m_lateTypeResolutionNameList.get(0))) {\n // TODO: dammit, is this right or not? figure it out!\n // i've removed the looping here, and instead pushed it into\n // a single step at the end of convertTypes. \n@@ -830,242 +750,236 @@ public final class XMLSchemaConverter\n // but is it **RIGHT??**\n //                    while (!m_lateTypeResolutionNameList.isEmpty())\n //                    {\n-                        lateResolveType(m_lateTypeResolutionNameList.get(0));\n+                    lateResolveType(m_lateTypeResolutionNameList.get(0));\n //                    }\n //                    if (!m_lateTypeResolutionMap.isEmpty())\n //                        throw new IllegalStateException(\"Late type resolution map should be empty, but it is not.\");\n                     // Element type resolution was delayed for all types whose resolution was delayed.\n                     // Those types have been resolved, so now we can resolve the elements.\n                     ArrayList<LateResolveElement> list = m_lateElementResolutionMap.get(name);\n-                    if ((list != null) && !list.isEmpty())\n-                    {\n-                        for (LateResolveElement lre : list) \n-                        {\n-                            convertElementTypeRef(lre.mi_xmlElement, lre.mi_elementDecl, lre.mi_subHead);\n+                    if ((list != null) && !list.isEmpty()) {\n+                        for (LateResolveElement lre : list) {\n+                            convertElementTypeRef(lre.mi_xmlElement, lre.mi_elementDecl,\n+                                lre.mi_subHead);\n                         }\n                     }\n                 }\n             }\n         }\n     }\n-    \n+\n     /**\n-     * Retrieves a list of the names of complex types needing late resolution; then, retrieves the \n+     * Retrieves a list of the names of complex types needing late resolution; then, retrieves the\n      * corresponding ComplexType object & builds it content model.\n-     * \n+     * <p>\n      * (See GXML-45 for use case.)\n-     *    \n+     *\n      * @param typeName name of the now-resolved type which has dependent types which were awaiting its\n-     * resolution\n-     * @throws SchemaException \n-     * @throws AbortException \n+     *                 resolution\n+     * @throws SchemaException\n+     * @throws AbortException\n      */\n-    private void lateResolveType(final QName typeName) \n-        throws AbortException, SchemaException\n-    {\n-    \t// Get the list of type names which were depending on the incoming type name's resolution.\n-    \tfinal List<XMLType> list = m_lateTypeResolutionMap.get(typeName);\n-    \tm_lateTypeResolutionMap.remove(typeName);\n-    \tm_lateTypeResolutionNameList.remove(typeName);\n-    \tif (list != null)\n-    \t{\n-    \t\t// for each dependent type, attempt to convert it, then\n+    private void lateResolveType(final QName typeName)\n+        throws AbortException, SchemaException {\n+        // Get the list of type names which were depending on the incoming type name's resolution.\n+        final List<XMLType> list = m_lateTypeResolutionMap.get(typeName);\n+        m_lateTypeResolutionMap.remove(typeName);\n+        m_lateTypeResolutionNameList.remove(typeName);\n+        if (list != null) {\n+            // for each dependent type, attempt to convert it, then\n             // recursively invoke this lateResolveType for it (why that order?)\n-    \t    // ah. the order is because invoking lateResolveType(name) removes the\n-    \t    // type from the list, if it does not have a list of dependents.\n-    \t\tfor (final XMLType xmlType : list)\n-    \t\t{\n-    \t\t\tfinal QName lateResolveTypeName = xmlType.getName();\n-    \t\t\tfinal ComplexTypeImpl complexType = (ComplexTypeImpl)m_outBag.getComplexType(lateResolveTypeName);\n-    \t\t\tcomplexType.setContentType(convertContentType(xmlType));\n-    \t\t\tlateResolveType(lateResolveTypeName);\n-    \t\t}\n-    \t}\n-    }\n-\n-    private ContentType convertContentType(final XMLType xmlComplexType) \n-        throws AbortException, SchemaException\n-    {\n+            // ah. the order is because invoking lateResolveType(name) removes the\n+            // type from the list, if it does not have a list of dependents.\n+            for (final XMLType xmlType : list) {\n+                final QName lateResolveTypeName = xmlType.getName();\n+                final ComplexTypeImpl complexType =\n+                    (ComplexTypeImpl) m_outBag.getComplexType(lateResolveTypeName);\n+                complexType.setContentType(convertContentType(xmlType));\n+                lateResolveType(lateResolveTypeName);\n+            }\n+        }\n+    }\n+\n+    private ContentType convertContentType(final XMLType xmlComplexType)\n+        throws AbortException, SchemaException {\n         final DerivationMethod derivation = xmlComplexType.getDerivationMethod();\n \n-        if (xmlComplexType.m_contentKind.isComplex())\n-        {\n+        if (xmlComplexType.m_contentKind.isComplex()) {\n             final boolean mixed = xmlComplexType.m_contentKind.isMixed();\n-            final ModelGroupUse effectiveContent = effectiveContent(mixed, xmlComplexType.m_contentModel);\n-            if (derivation.isRestriction())\n-            {\n-                if (effectiveContent == null)\n+            final ModelGroupUse effectiveContent =\n+                effectiveContent(mixed, xmlComplexType.m_contentModel);\n+            if (derivation.isRestriction()) {\n+                if (effectiveContent == null) {\n                     return EMPTY_CONTENT;\n-                else\n-                {\n-                    if (mixed)\n+                } else {\n+                    if (mixed) {\n                         return new ContentTypeImpl(mixed, effectiveContent);\n-                    else\n-                    {\n-                        if ((effectiveContent.getTerm() == null) || \n-                             effectiveContent.getTerm().getParticles().isEmpty())\n+                    } else {\n+                        if ((effectiveContent.getTerm() == null) ||\n+                            effectiveContent.getTerm().getParticles().isEmpty()) {\n                             return EMPTY_CONTENT;\n-                        else\n+                        } else {\n                             return new ContentTypeImpl(mixed, effectiveContent);\n+                        }\n                     }\n                 }\n-            }\n-            else if (derivation.isExtension())\n-            {\n-            \t// Is the typeRef (base ref) resolved, yet?  If not, postpone resolution of this type's content.\t\t\t\t\n-            \tfinal QName typeRefName =  xmlComplexType.getBaseRef().getName();\n-            \tif (m_complexTypeNameCycles.contains(typeRefName) || \n-            \t    m_lateTypeResolutionMap.containsKey(typeRefName))\n-            \t{\n-            \t\tArrayList<XMLType> list = m_lateTypeResolutionMap.get(typeRefName);\n-            \t\tif (list == null)\n-            \t\t{\n-            \t\t\tlist = new ArrayList<XMLType>();\n-            \t\t\tm_lateTypeResolutionMap.put(typeRefName, list);\n-            \t\t\tm_lateTypeResolutionNameList.add(typeRefName);\n-            \t\t}\n-            \t\tlist.add(xmlComplexType);\n-            \t\t// Also, add the type to be late resolved as key to late resolution map.  Any components\n-            \t\t// depending on its content model must also wait for resolution.\n-            \t\tif (!m_lateTypeResolutionMap.containsKey(xmlComplexType.getName()))\n-            \t\t{\n-            \t\t\tm_lateTypeResolutionMap.put(xmlComplexType.getName(), null);\n-            \t\t\tm_lateTypeResolutionNameList.add(xmlComplexType.getName());\n-            \t\t}\n-            \t\treturn EMPTY_CONTENT; // actual content to be determined later\n-            \t}\n-            \t// \"typeB\" == base type\n+            } else if (derivation.isExtension()) {\n+                // Is the typeRef (base ref) resolved, yet?  If not, postpone resolution of this type's content.\n+                final QName typeRefName = xmlComplexType.getBaseRef().getName();\n+                if (m_complexTypeNameCycles.contains(typeRefName) ||\n+                    m_lateTypeResolutionMap.containsKey(typeRefName)) {\n+                    ArrayList<XMLType> list = m_lateTypeResolutionMap.get(typeRefName);\n+                    if (list == null) {\n+                        list = new ArrayList<XMLType>();\n+                        m_lateTypeResolutionMap.put(typeRefName, list);\n+                        m_lateTypeResolutionNameList.add(typeRefName);\n+                    }\n+                    list.add(xmlComplexType);\n+                    // Also, add the type to be late resolved as key to late resolution map.  Any components\n+                    // depending on its content model must also wait for resolution.\n+                    if (!m_lateTypeResolutionMap.containsKey(xmlComplexType.getName())) {\n+                        m_lateTypeResolutionMap.put(xmlComplexType.getName(), null);\n+                        m_lateTypeResolutionNameList.add(xmlComplexType.getName());\n+                    }\n+                    return EMPTY_CONTENT; // actual content to be determined later\n+                }\n+                // \"typeB\" == base type\n                 final Type typeB = convertType(xmlComplexType.getBaseRef());\n-                if (typeB instanceof ComplexType)\n-                {\n-                    final ComplexType complexTypeB = (ComplexType)typeB;\n+                if (typeB instanceof ComplexType) {\n+                    final ComplexType complexTypeB = (ComplexType) typeB;\n                     final ContentType contentTypeB = complexTypeB.getContentType();\n-                    if (effectiveContent == null)\n+                    if (effectiveContent == null) {\n                         return contentTypeB;\n-                    else if (contentTypeB.isEmpty())\n+                    } else if (contentTypeB.isEmpty()) {\n                         return new ContentTypeImpl(mixed, effectiveContent);\n-                    else if (contentTypeB.isSimple())\n-                        throw new SrcBaseContentTypeCannotBeSimpleException(xmlComplexType.getName(), complexTypeB.getName(), xmlComplexType.getLocation());\n-                    else if (contentTypeB.isComplex())\n-                    {\n+                    } else if (contentTypeB.isSimple()) {\n+                        throw new SrcBaseContentTypeCannotBeSimpleException(\n+                            xmlComplexType.getName(), complexTypeB.getName(),\n+                            xmlComplexType.getLocation());\n+                    } else if (contentTypeB.isComplex()) {\n                         final LinkedList<ModelGroupUse> particles = new LinkedList<ModelGroupUse>();\n                         particles.add(contentTypeB.getContentModel());\n                         particles.add(effectiveContent);\n-                        final ModelGroup modelGroup = new ModelGroupImpl(ModelGroup.SmCompositor.Sequence, particles, null, true, ScopeExtent.Local);\n-                        final ModelGroupUse particle = new ParticleWithModelGroupTerm(1, 1, modelGroup);\n+                        final ModelGroup modelGroup =\n+                            new ModelGroupImpl(ModelGroup.SmCompositor.Sequence, particles, null,\n+                                true, ScopeExtent.Local);\n+                        final ModelGroupUse particle =\n+                            new ParticleWithModelGroupTerm(1, 1, modelGroup);\n                         return new ContentTypeImpl(mixed, particle);\n-                    }\n-                    else\n+                    } else {\n                         throw new AssertionError(contentTypeB.getKind());\n-                }\n-                else // typeB ! instanceof ComplexType\n+                    }\n+                } else // typeB ! instanceof ComplexType\n+                {\n                     throw new SrcBaseTypeMustBeComplexTypeException(xmlComplexType.getLocation());\n-            }\n-            else // derivation !isRestriction() && !isExtension()\n+                }\n+            } else // derivation !isRestriction() && !isExtension()\n+            {\n                 throw new AssertionError(derivation);\n-        }\n-        else if (xmlComplexType.m_contentKind.isSimple())\n-        {\n+            }\n+        } else if (xmlComplexType.m_contentKind.isSimple()) {\n             final Type typeB = convertType(xmlComplexType.getBaseRef());\n-            if (typeB instanceof ComplexType)\n-            {\n-                final ComplexType complexTypeB = (ComplexType)typeB;\n+            if (typeB instanceof ComplexType) {\n+                final ComplexType complexTypeB = (ComplexType) typeB;\n                 final ContentType contentTypeB = complexTypeB.getContentType();\n-                if (contentTypeB.isSimple())\n-                {\n-                    if (derivation.isRestriction())\n-                        return simpleContent(xmlComplexType.simpleType, contentTypeB.getSimpleType());\n-                    else if (derivation.isExtension())\n+                if (contentTypeB.isSimple()) {\n+                    if (derivation.isRestriction()) {\n+                        return simpleContent(xmlComplexType.simpleType,\n+                            contentTypeB.getSimpleType());\n+                    } else if (derivation.isExtension()) {\n                         return contentTypeB;\n-                    else\n+                    } else {\n                         throw new AssertionError(derivation);\n-                }\n-                else\n-                {\n-                    if (derivation.isRestriction())\n-                    {\n-                        if (contentTypeB.isMixed())\n-                        {\n+                    }\n+                } else {\n+                    if (derivation.isRestriction()) {\n+                        if (contentTypeB.isMixed()) {\n                             final ModelGroupUse contentModelB = contentTypeB.getContentModel();\n-                            if (contentModelB.isEmptiable())\n-                            {\n-                                final XMLTypeRef simpleType = xmlComplexType.simpleType.getBaseRef();\n-                                if (simpleType != null)\n-                                {\n+                            if (contentModelB.isEmptiable()) {\n+                                final XMLTypeRef simpleType =\n+                                    xmlComplexType.simpleType.getBaseRef();\n+                                if (simpleType != null) {\n                                     final SimpleType simpleBaseType = extractSimpleType(simpleType);\n                                     return simpleContent(xmlComplexType.simpleType, simpleBaseType);\n+                                } else // no base type\n+                                {\n+                                    throw new SrcSimpleTypeAmongChildrenOfRestrictionException(\n+                                        xmlComplexType.getLocation());\n                                 }\n-                                else // no base type\n-                                    throw new SrcSimpleTypeAmongChildrenOfRestrictionException(xmlComplexType.getLocation());\n+                            } else // not emptiable\n+                            {\n+                                throw new SrcBaseMustHaveSimpleOrMixedContentTypeComplexTypeException(\n+                                    xmlComplexType.getLocation());\n                             }\n-                            else // not emptiable\n-                                throw new SrcBaseMustHaveSimpleOrMixedContentTypeComplexTypeException(xmlComplexType.getLocation());\n+                        } else // not mixed\n+                        {\n+                            throw new SrcBaseMustHaveSimpleOrMixedContentTypeComplexTypeException(\n+                                xmlComplexType.getLocation());\n                         }\n-                        else // not mixed\n-                            throw new SrcBaseMustHaveSimpleOrMixedContentTypeComplexTypeException(xmlComplexType.getLocation());\n-                    }\n-                    else if (derivation.isExtension()) // can't extend a base complex type with simple content into a complex type with simple content (?)\n-                        throw new SrcBaseMustHaveSimpleOrMixedContentTypeComplexTypeException(xmlComplexType.getLocation());\n-                    else // not extension or restriction\n+                    } else if (derivation\n+                        .isExtension()) // can't extend a base complex type with simple content into a complex type with simple content (?)\n+                    {\n+                        throw new SrcBaseMustHaveSimpleOrMixedContentTypeComplexTypeException(\n+                            xmlComplexType.getLocation());\n+                    } else // not extension or restriction\n+                    {\n                         throw new AssertionError(derivation);\n+                    }\n                 }\n-            }\n-            else if (typeB instanceof SimpleType) // derived has simple content kind\n+            } else if (typeB instanceof SimpleType) // derived has simple content kind\n             {\n-                final SimpleType simpleTypeB = (SimpleType)typeB;\n-                if (derivation.isExtension())\n+                final SimpleType simpleTypeB = (SimpleType) typeB;\n+                if (derivation.isExtension()) {\n                     return new ContentTypeImpl(simpleTypeB);\n-                else if (derivation.isRestriction())\n+                } else if (derivation.isRestriction()) {\n                     return new ContentTypeImpl(simpleTypeB);\n-                else\n+                } else {\n                     throw new AssertionError(derivation);\n-            }\n-            else // typeB (base type) not instance of ComplexType or SimpleType\n+                }\n+            } else // typeB (base type) not instance of ComplexType or SimpleType\n+            {\n                 throw new AssertionError(typeB);\n-        }\n-        else // xmlComplexType.m_contentKind !complex, !simple, which means empty, apparently, though there isn't an item for empty in the enum\n+            }\n+        } else // xmlComplexType.m_contentKind !complex, !simple, which means empty, apparently, though there isn't an item for empty in the enum\n+        {\n             return computeLocallyEmptyContent(xmlComplexType);\n+        }\n     }\n \n-    private ElementDefinition convertElement(final XMLElement xmlElement) \n-        throws SchemaException, AbortException\n-    {\n+    private ElementDefinition convertElement(final XMLElement xmlElement)\n+        throws SchemaException, AbortException {\n         final QName name = PreCondition.assertArgumentNotNull(xmlElement.getName(), \"name\");\n         final ScopeExtent scope = convertScope(xmlElement.getScope());\n-        if (scope == ScopeExtent.Global)\n-        {\n-            if (m_outBag.hasElement(name))\n+        if (scope == ScopeExtent.Global) {\n+            if (m_outBag.hasElement(name)) {\n                 return m_outBag.getElement(name);\n-            if (m_existingCache.hasElement(name))\n-            {\n-            \tif (!m_lastInWins)\n-            \t{\n-            \t\t// We are not allowing this schema parse to create new elements.  \n+            }\n+            if (m_existingCache.hasElement(name)) {\n+                if (!m_lastInWins) {\n+                    // We are not allowing this schema parse to create new elements.\n                     m_inCache.m_elementsUnresolved.remove(name);\n                     return m_existingCache.getElementDeclaration(name);\n-            \t}\n-            \telse if (m_inCache.m_elementsUnresolved.containsKey(name) || \n-            \t         m_elementsResolvedFromExistingCache.containsKey(name))\n-            \t{\n-            \t\t// This element is a reference which refers to an imported element; otherwise, its name would not be \n-            \t\t// in the m_inCache.m_elementsUnresolved.  When XMLSchemaCache.registerELement is called, it removes name from m_elementsUnresolved,\n-            \t\t// and registerElement is called when XMLSchemaParser encounters a global element, the only elements that can be referenced.\n-            \t\t// So, we're going to remove its name from the list and NOT convert it -- it's just a reference\n+                } else if (m_inCache.m_elementsUnresolved.containsKey(name) ||\n+                    m_elementsResolvedFromExistingCache.containsKey(name)) {\n+                    // This element is a reference which refers to an imported element; otherwise, its name would not be\n+                    // in the m_inCache.m_elementsUnresolved.  When XMLSchemaCache.registerELement is called, it removes name from m_elementsUnresolved,\n+                    // and registerElement is called when XMLSchemaParser encounters a global element, the only elements that can be referenced.\n+                    // So, we're going to remove its name from the list and NOT convert it -- it's just a reference\n                     m_inCache.m_elementsUnresolved.remove(name);\n-            \t\tElementDefinition existing = m_existingCache.getElementDeclaration(name);\n-            \t\tm_elementsResolvedFromExistingCache.put(name, existing);\n+                    ElementDefinition existing = m_existingCache.getElementDeclaration(name);\n+                    m_elementsResolvedFromExistingCache.put(name, existing);\n                     return existing;\n-            \t}\n+                }\n             }\n-            if (m_cycles.elements.contains(xmlElement))\n+            if (m_cycles.elements.contains(xmlElement)) {\n                 throw new SccCyclicElementException(name);\n-            else\n+            } else {\n                 m_cycles.elements.push(xmlElement);\n+            }\n         }\n         final ElementDeclTypeImpl element;\n-        ElementDeclTypeImpl substitutionGroupHead = null;            \n-        try\n-        {\n+        ElementDeclTypeImpl substitutionGroupHead = null;\n+        try {\n             PreCondition.assertArgumentNotNull(xmlElement.typeRef, \"{type definition} of \" + name);\n \n             // The element {type definition} defaults to xs:anyType because\n@@ -1077,209 +991,185 @@ public final class XMLSchemaConverter\n             element = new ElementDeclTypeImpl(name, scope, anyType);\n \n             // {substitution group affiliation}\n-            if (xmlElement.substitutionGroup != null)\n-            {\n+            if (xmlElement.substitutionGroup != null) {\n                 // TODO: Would be nice to avoid this downcast. Maybe by using name for group head?\n-                substitutionGroupHead = (ElementDeclTypeImpl)convertElement(xmlElement.substitutionGroup);\n+                substitutionGroupHead =\n+                    (ElementDeclTypeImpl) convertElement(xmlElement.substitutionGroup);\n                 element.setSubstitutionGroup(substitutionGroupHead);\n                 substitutionGroupHead.addSubstitutionGroupMember(element);\n             }\n \n             // {identity-constraint definitions}\n-            for (final XMLIdentityConstraint constraint : xmlElement.getIdentityConstraints())\n-            {\n+            for (final XMLIdentityConstraint constraint : xmlElement.getIdentityConstraints()) {\n                 element.addIdentityConstraint(convertIdentityConstraint(constraint));\n             }\n-        }\n-        finally\n-        {\n-            if (scope == ScopeExtent.Global)\n+        } finally {\n+            if (scope == ScopeExtent.Global) {\n                 m_cycles.elements.pop();\n+            }\n         }\n \n-        if (element.getScopeExtent() == ScopeExtent.Global)\n+        if (element.getScopeExtent() == ScopeExtent.Global) {\n             m_outBag.add(element);\n+        }\n //System.out.println(\"add element \" + name);\n         m_locations.m_elementLocations.put(xmlElement.getLocation(), element);\n \n-\t\t// {type definition}\n-\t\tconvertElementTypeRef(xmlElement, element, substitutionGroupHead);\n-\t\t// {nillable}\n-\t\telement.setNillable(xmlElement.isNillable());\n-\t\t// {disallowed substitutions}\n-\t\tfor (final DerivationMethod derivation : xmlElement.getBlock())\n-\t\t{\n-\t\t\telement.setBlock(derivation, true);\n-\t\t}\n-\t\t// {substitution group exclusions}\n-\t\tfor (final DerivationMethod derivation : xmlElement.getFinal())\n-\t\t{\n-\t\t\telement.setFinal(derivation, true);\n-\t\t}\n-\t\t// {abstract}\n-\t\telement.setAbstract(xmlElement.isAbstract());\n-\t\t// {annotation} we don't care about.\n-\t\t// foreign attributes\n-\t\tcopyForeignAttributes(xmlElement.foreignAttributes, element);\n-\t\t// We're done!\n-\t\treturn element;\n-    }\n-\n-    private void convertElementTypeRef(final XMLElement xmlElement, final ElementDeclTypeImpl element, ElementDeclTypeImpl substitutionGroupHead) \n-        throws AbortException, SchemaException\n-    {\n-    \t// {type definition}\n-    \t// Is the typeRef resolved, yet?  If not, postpone resolution of this type's content.\t\t\t\t\n-    \tif (xmlElement.typeRef.isGlobal())\n-    \t{\n-    \t\tfinal QName typeRefName = xmlElement.typeRef.getName();\n-    \t\tif (m_complexTypeNameCycles.contains(typeRefName))\n-    \t\t{\n-    \t\t\tArrayList<LateResolveElement> list = m_lateElementResolutionMap.get(typeRefName);\n-    \t\t\tif(list == null) \n-    \t\t\t{\n-    \t\t\t\tlist = new ArrayList<LateResolveElement>();\n-    \t\t\t\tm_lateElementResolutionMap.put(typeRefName, list);\n-    \t\t\t}\n-    \t\t\tlist.add(new LateResolveElement(xmlElement, element, substitutionGroupHead));\n-    \t\t\t// NOTE THE RETURN; look at the conditions\n-    \t\t\treturn;\n-    \t\t}\n-    \t}\n-\n-    \tType typeFromTypeRef = convertType(xmlElement.typeRef);\n-    \t// If the typeFromTypeRef is complexUrType, then it was not set, probably because\n-    \t// the element did not have a type attribute.  So, use the type from the substitutionGroup\n-    \t// head, if possible.\n-    \tif ((substitutionGroupHead != null) && typeFromTypeRef.isComplexUrType()) \n-    \t\ttypeFromTypeRef = substitutionGroupHead.getType();\n-    \telement.setType(typeFromTypeRef);\n-\n-    \t// {value constraint}\n-    \tif (xmlElement.m_valueConstraint != null)\n-    \t{\n-            if (element.getType() instanceof SimpleType)\n-            {\n-                final SimpleType elementType = (SimpleType)element.getType();\n-                try\n-                {\n-                    element.setValueConstraint(convertValueConstraint(XMLRepresentation.LN_ELEMENT, xmlElement.m_valueConstraint, elementType));\n+        // {type definition}\n+        convertElementTypeRef(xmlElement, element, substitutionGroupHead);\n+        // {nillable}\n+        element.setNillable(xmlElement.isNillable());\n+        // {disallowed substitutions}\n+        for (final DerivationMethod derivation : xmlElement.getBlock()) {\n+            element.setBlock(derivation, true);\n+        }\n+        // {substitution group exclusions}\n+        for (final DerivationMethod derivation : xmlElement.getFinal()) {\n+            element.setFinal(derivation, true);\n+        }\n+        // {abstract}\n+        element.setAbstract(xmlElement.isAbstract());\n+        // {annotation} we don't care about.\n+        // foreign attributes\n+        copyForeignAttributes(xmlElement.foreignAttributes, element);\n+        // We're done!\n+        return element;\n+    }\n+\n+    private void convertElementTypeRef(final XMLElement xmlElement,\n+                                       final ElementDeclTypeImpl element,\n+                                       ElementDeclTypeImpl substitutionGroupHead)\n+        throws AbortException, SchemaException {\n+        // {type definition}\n+        // Is the typeRef resolved, yet?  If not, postpone resolution of this type's content.\n+        if (xmlElement.typeRef.isGlobal()) {\n+            final QName typeRefName = xmlElement.typeRef.getName();\n+            if (m_complexTypeNameCycles.contains(typeRefName)) {\n+                ArrayList<LateResolveElement> list = m_lateElementResolutionMap.get(typeRefName);\n+                if (list == null) {\n+                    list = new ArrayList<LateResolveElement>();\n+                    m_lateElementResolutionMap.put(typeRefName, list);\n                 }\n-                catch (final SchemaException e)\n-                {\n+                list.add(new LateResolveElement(xmlElement, element, substitutionGroupHead));\n+                // NOTE THE RETURN; look at the conditions\n+                return;\n+            }\n+        }\n+\n+        Type typeFromTypeRef = convertType(xmlElement.typeRef);\n+        // If the typeFromTypeRef is complexUrType, then it was not set, probably because\n+        // the element did not have a type attribute.  So, use the type from the substitutionGroup\n+        // head, if possible.\n+        if ((substitutionGroupHead != null) && typeFromTypeRef.isComplexUrType()) {\n+            typeFromTypeRef = substitutionGroupHead.getType();\n+        }\n+        element.setType(typeFromTypeRef);\n+\n+        // {value constraint}\n+        if (xmlElement.m_valueConstraint != null) {\n+            if (element.getType() instanceof SimpleType) {\n+                final SimpleType elementType = (SimpleType) element.getType();\n+                try {\n+                    element.setValueConstraint(convertValueConstraint(XMLRepresentation.LN_ELEMENT,\n+                        xmlElement.m_valueConstraint, elementType));\n+                } catch (final SchemaException e) {\n                     m_errors.error(e);\n                 }\n-            }\n-            else if (element.getType() instanceof ComplexType)\n-            {\n-                final ComplexType elementType = (ComplexType)element.getType();\n+            } else if (element.getType() instanceof ComplexType) {\n+                final ComplexType elementType = (ComplexType) element.getType();\n                 final ContentType contentType = elementType.getContentType();\n-                if (contentType.isSimple())\n-                {\n+                if (contentType.isSimple()) {\n                     final SimpleType simpleType = contentType.getSimpleType();\n-                    try\n-                    {\n-                        element.setValueConstraint(convertValueConstraint(XMLRepresentation.LN_ELEMENT, xmlElement.m_valueConstraint, simpleType));\n-                    }\n-                    catch (final SchemaException e)\n-                    {\n+                    try {\n+                        element.setValueConstraint(\n+                            convertValueConstraint(XMLRepresentation.LN_ELEMENT,\n+                                xmlElement.m_valueConstraint, simpleType));\n+                    } catch (final SchemaException e) {\n                         m_errors.error(e);\n                     }\n+                } else {\n+                    final String initialValue = xmlElement.m_valueConstraint.getValue();\n+                    final SimpleType simpleType =\n+                        m_existingCache.getSimpleType(NativeType.UNTYPED_ATOMIC);\n+                    element.setValueConstraint(\n+                        new ValueConstraint(xmlElement.m_valueConstraint.kind, simpleType,\n+                            initialValue));\n                 }\n-                else\n-                {\n-                  final String initialValue = xmlElement.m_valueConstraint.getValue();\n-                  final SimpleType simpleType = m_existingCache.getSimpleType(NativeType.UNTYPED_ATOMIC);\n-                  element.setValueConstraint(new ValueConstraint(xmlElement.m_valueConstraint.kind, simpleType, initialValue));\n-                }\n-            }\n-            else\n+            } else {\n                 throw new AssertionError(element.getType());\n-\t\t} // value constraint != null\n-\t}\n+            }\n+        } // value constraint != null\n+    }\n \n-    private void convertElements() \n-        throws AbortException\n-    {\n-        for (final XMLElement source : m_inCache.m_elements.values())\n-        {\n-            try\n-            {\n+    private void convertElements()\n+        throws AbortException {\n+        for (final XMLElement source : m_inCache.m_elements.values()) {\n+            try {\n                 QName name = source.getName();\n-                if (!m_lastInWins && (m_existingCache.getElementDeclaration(name) != null))\n+                if (!m_lastInWins && (m_existingCache.getElementDeclaration(name) != null)) {\n                     m_inCache.m_elementsUnresolved.remove(name);\n+                }\n                 convertElement(source);\n-            }\n-            catch (final SchemaException e)\n-            {\n+            } catch (final SchemaException e) {\n                 m_errors.error(e);\n             }\n         }\n         // Ensure that all elements have their type refs resolved.\n         // Element type resolution was delayed for all types whose resolution was delayed.\n         // Those types have been resolved, so now we can resolve the elements.\n-        for (QName typeName : m_lateElementResolutionMap.keySet()) \n-        {\n-        \tArrayList<LateResolveElement> list = m_lateElementResolutionMap.get(typeName);\n-        \tfor (LateResolveElement lre : list) \n-        \t{\n-                try \n-                {\n-                \tconvertElementTypeRef(lre.mi_xmlElement, lre.mi_elementDecl, lre.mi_subHead);\n-                } \n-                catch (SchemaException e) \n-                {\n-                \tm_errors.error(e);\n+        for (QName typeName : m_lateElementResolutionMap.keySet()) {\n+            ArrayList<LateResolveElement> list = m_lateElementResolutionMap.get(typeName);\n+            for (LateResolveElement lre : list) {\n+                try {\n+                    convertElementTypeRef(lre.mi_xmlElement, lre.mi_elementDecl, lre.mi_subHead);\n+                } catch (SchemaException e) {\n+                    m_errors.error(e);\n                 }\n-        \t}\n+            }\n         }\n         m_lateElementResolutionMap.clear();\n     }\n \n-    private SchemaParticle convertElementUse(final XMLParticleWithElementTerm particle) \n-        throws SchemaException, AbortException\n-    {\n+    private SchemaParticle convertElementUse(final XMLParticleWithElementTerm particle)\n+        throws SchemaException, AbortException {\n         final XMLElement xmlElement = particle.getTerm();\n         final ElementDefinition element = convertElement(xmlElement);\n \n         final ParticleWithElementTerm elementUse;\n-        if (isMaxOccursUnbounded(particle.getMaxOccurs()))\n-        {\n+        if (isMaxOccursUnbounded(particle.getMaxOccurs())) {\n             final int minOccurs = minOccurs(particle.getMinOccurs());\n             elementUse = new ParticleWithElementTerm(minOccurs, element);\n-        }\n-        else\n-        {\n+        } else {\n             final int minOccurs = minOccurs(particle.getMinOccurs());\n             final int maxOccurs = maxOccurs(particle.getMaxOccurs());\n             elementUse = new ParticleWithElementTerm(minOccurs, maxOccurs, element);\n         }\n //System.out.println(\"add particle with element term\");\n         m_locations.m_particleLocations.put(particle.getLocation(), elementUse);\n-        if (particle.valueConstraint != null)\n-        {\n-            final ValueConstraint valueConstraint = convertElementValueConstraint(particle.valueConstraint, element.getType());\n+        if (particle.valueConstraint != null) {\n+            final ValueConstraint valueConstraint =\n+                convertElementValueConstraint(particle.valueConstraint, element.getType());\n             elementUse.setValueConstraint(valueConstraint);\n         }\n         return elementUse;\n     }\n \n-    private ValueConstraint convertElementValueConstraint(final XMLValueConstraint xmlValueConstraint, final Type type) \n-        throws SchemaException\n-    {\n-        if (xmlValueConstraint != null)\n-        {\n-            if (type instanceof SimpleType)\n-                return convertValueConstraint(XMLRepresentation.LN_ELEMENT, xmlValueConstraint, (SimpleType)type);\n-            else if (type instanceof ComplexType)\n-            {\n-                final ContentType contentType = ((ComplexType)type).getContentType();\n-                if (contentType.isSimple())\n-                    return convertValueConstraint(XMLRepresentation.LN_ELEMENT, xmlValueConstraint, contentType.getSimpleType());\n-                else\n-                {\n+    private ValueConstraint convertElementValueConstraint(\n+        final XMLValueConstraint xmlValueConstraint, final Type type)\n+        throws SchemaException {\n+        if (xmlValueConstraint != null) {\n+            if (type instanceof SimpleType) {\n+                return convertValueConstraint(XMLRepresentation.LN_ELEMENT, xmlValueConstraint,\n+                    (SimpleType) type);\n+            } else if (type instanceof ComplexType) {\n+                final ContentType contentType = ((ComplexType) type).getContentType();\n+                if (contentType.isSimple()) {\n+                    return convertValueConstraint(XMLRepresentation.LN_ELEMENT, xmlValueConstraint,\n+                        contentType.getSimpleType());\n+                } else {\n                     final String initialValue = xmlValueConstraint.getValue();\n-                    return new ValueConstraint(xmlValueConstraint.kind, m_existingCache.getSimpleType(NativeType.UNTYPED_ATOMIC), initialValue);\n+                    return new ValueConstraint(xmlValueConstraint.kind,\n+                        m_existingCache.getSimpleType(NativeType.UNTYPED_ATOMIC), initialValue);\n                 }\n             }\n             throw new AssertionError(type); // neither simple nor complex; should not happen\n@@ -1287,148 +1177,134 @@ public final class XMLSchemaConverter\n         return null;\n     }\n \n-    private IdentityConstraint convertIdentityConstraint(final XMLIdentityConstraint xmlConstraint) \n-        throws SchemaException\n-    {\n+    private IdentityConstraint convertIdentityConstraint(final XMLIdentityConstraint xmlConstraint)\n+        throws SchemaException {\n         final QName name = xmlConstraint.getName();\n-        if (m_outBag.hasIdentityConstraint(name))\n+        if (m_outBag.hasIdentityConstraint(name)) {\n             return m_outBag.getIdentityConstraint(name);\n-        if (m_existingCache.hasIdentityConstraint(name))\n-        {\n-        \tif (!m_lastInWins)\n-        \t{\n-        \t\t// We are not allowing this schema parse to create new elements.  \n+        }\n+        if (m_existingCache.hasIdentityConstraint(name)) {\n+            if (!m_lastInWins) {\n+                // We are not allowing this schema parse to create new elements.\n                 m_inCache.m_constraintsUnresolved.remove(name);\n                 return m_existingCache.getIdentityConstraint(name);\n-        \t}\n-        \telse if (m_inCache.m_constraintsUnresolved.containsKey(name) ||\n-        \t         m_constraintsResolvedFromExistingCache.containsKey(name))\n-        \t{\n-        \t\t// This component is a reference which refers to an imported component; otherwise, its name would not be \n-        \t\t// in the m_inCache.m_XxxUnresolved.  When XMLSchemaCache.registerXxx is called, it removes name from m_XxxUnresolved,\n-        \t\t// and registerXxxt is called when XMLSchemaParser encounters a global component, the only components that can be referenced.\n-        \t\t// So, we're going to remove its name from the list, NOT convert it, and return the existing component.\n+            } else if (m_inCache.m_constraintsUnresolved.containsKey(name) ||\n+                m_constraintsResolvedFromExistingCache.containsKey(name)) {\n+                // This component is a reference which refers to an imported component; otherwise, its name would not be\n+                // in the m_inCache.m_XxxUnresolved.  When XMLSchemaCache.registerXxx is called, it removes name from m_XxxUnresolved,\n+                // and registerXxxt is called when XMLSchemaParser encounters a global component, the only components that can be referenced.\n+                // So, we're going to remove its name from the list, NOT convert it, and return the existing component.\n                 m_inCache.m_constraintsUnresolved.remove(name);\n-        \t\tIdentityConstraint existing = m_existingCache.getIdentityConstraint(name);\n-        \t\tm_constraintsResolvedFromExistingCache.put(name, existing);\n+                IdentityConstraint existing = m_existingCache.getIdentityConstraint(name);\n+                m_constraintsResolvedFromExistingCache.put(name, existing);\n                 return existing;\n-        \t}\n+            }\n         }\n-        if (m_cycles.constraints.contains(xmlConstraint))\n+        if (m_cycles.constraints.contains(xmlConstraint)) {\n             throw new SccCyclicIdentityConstraintException(name);\n+        }\n         m_cycles.constraints.push(xmlConstraint);\n-        try\n-        {\n-            if (xmlConstraint.keyConstraint == null)\n-            {\n-                final IdentityConstraint constraint = new IdentityConstraintImpl(name, xmlConstraint.category, xmlConstraint.selector, xmlConstraint.fields, null);\n+        try {\n+            if (xmlConstraint.keyConstraint == null) {\n+                final IdentityConstraint constraint =\n+                    new IdentityConstraintImpl(name, xmlConstraint.category, xmlConstraint.selector,\n+                        xmlConstraint.fields, null);\n                 m_outBag.add(constraint);\n //System.out.println(\"add constraint\");\n                 m_locations.m_constraintLocations.put(xmlConstraint.getLocation(), constraint);\n                 return constraint;\n-            }\n-            else\n-            {\n-                final IdentityConstraint keyConstraint = convertIdentityConstraint(xmlConstraint.keyConstraint);\n-                final IdentityConstraint constraint = new IdentityConstraintImpl(name, xmlConstraint.category, xmlConstraint.selector, xmlConstraint.fields, keyConstraint);\n+            } else {\n+                final IdentityConstraint keyConstraint =\n+                    convertIdentityConstraint(xmlConstraint.keyConstraint);\n+                final IdentityConstraint constraint =\n+                    new IdentityConstraintImpl(name, xmlConstraint.category, xmlConstraint.selector,\n+                        xmlConstraint.fields, keyConstraint);\n                 m_outBag.add(constraint);\n //System.out.println(\"add constraint\");\n                 m_locations.m_constraintLocations.put(xmlConstraint.getLocation(), constraint);\n                 return constraint;\n             }\n-        }\n-        finally\n-        {\n+        } finally {\n             m_cycles.constraints.pop();\n         }\n     }\n \n-    private void convertIdentityConstraints() \n-        throws AbortException\n-    {\n-        for (final XMLIdentityConstraint source : m_inCache.m_constraints.values())\n-        {\n-            try\n-            {\n+    private void convertIdentityConstraints()\n+        throws AbortException {\n+        for (final XMLIdentityConstraint source : m_inCache.m_constraints.values()) {\n+            try {\n                 QName name = source.getName();\n-                if (!m_lastInWins && (m_existingCache.getIdentityConstraint(name) != null))\n+                if (!m_lastInWins && (m_existingCache.getIdentityConstraint(name) != null)) {\n                     m_inCache.m_constraintsUnresolved.remove(name);\n+                }\n                 convertIdentityConstraint(source);\n-            }\n-            catch (final SchemaException e)\n-            {\n+            } catch (final SchemaException e) {\n                 m_errors.error(e);\n             }\n         }\n     }\n \n-    private SimpleType convertItemType(final QName simpleType, final XMLTypeRef typeRef) \n-        throws AbortException, SchemaException\n-    {\n+    private SimpleType convertItemType(final QName simpleType, final XMLTypeRef typeRef)\n+        throws AbortException, SchemaException {\n         final Type itemType = convertType(typeRef);\n-        if (itemType.isAtomicType())\n-            return (SimpleType)itemType;\n-        else if (itemType instanceof UnionSimpleType)\n-            return (UnionSimpleType)itemType;\n+        if (itemType.isAtomicType()) {\n+            return (SimpleType) itemType;\n+        } else if (itemType instanceof UnionSimpleType) {\n+            return (UnionSimpleType) itemType;\n+        }\n         throw new SccItemTypeMustBeAtomicOrUnionException(simpleType);\n     }\n \n-    private SimpleType convertMemberType(final QName simpleType, final XMLTypeRef typeRef) \n-        throws AbortException, SchemaException\n-    {\n+    private SimpleType convertMemberType(final QName simpleType, final XMLTypeRef typeRef)\n+        throws AbortException, SchemaException {\n         final Type memberType = convertType(typeRef);\n-        if (memberType.isAtomicType())\n-            return (SimpleType)memberType;\n-        else if (memberType instanceof ListSimpleType)\n-            return (ListSimpleType)memberType;\n-        else if (memberType instanceof UnionSimpleType)\n-        \treturn (UnionSimpleType)memberType;\n-        else if ( (memberType instanceof SimpleType) && memberType.isSimpleUrType())\n-            return (SimpleType)memberType;\n+        if (memberType.isAtomicType()) {\n+            return (SimpleType) memberType;\n+        } else if (memberType instanceof ListSimpleType) {\n+            return (ListSimpleType) memberType;\n+        } else if (memberType instanceof UnionSimpleType) {\n+            return (UnionSimpleType) memberType;\n+        } else if ((memberType instanceof SimpleType) && memberType.isSimpleUrType()) {\n+            return (SimpleType) memberType;\n+        }\n         throw new SccMemberTypeMustBeAtomicOrListException(simpleType);\n     }\n \n-    private ModelGroup convertModelGroup(final XMLModelGroup xmlModelGroup) \n-        throws AbortException, SchemaException\n-    {\n+    private ModelGroup convertModelGroup(final XMLModelGroup xmlModelGroup)\n+        throws AbortException, SchemaException {\n         final ScopeExtent scope = convertScope(xmlModelGroup.getScope());\n         final QName name;\n         final boolean isAnonymous;\n-        \n-        if (scope == ScopeExtent.Global)\n-        {\n+\n+        if (scope == ScopeExtent.Global) {\n             name = xmlModelGroup.getName();\n             isAnonymous = false;\n-            if (m_outBag.hasModelGroup(name))\n+            if (m_outBag.hasModelGroup(name)) {\n                 return m_outBag.getModelGroup(name);\n-            if (m_existingCache.hasModelGroup(name))\n-            {\n-            \tif (!m_lastInWins)\n-            \t{\n-            \t\t// We are not allowing this schema parse to create new elements.  \n+            }\n+            if (m_existingCache.hasModelGroup(name)) {\n+                if (!m_lastInWins) {\n+                    // We are not allowing this schema parse to create new elements.\n                     m_inCache.m_modelGroupsUnresolved.remove(name);\n                     return m_existingCache.getModelGroup(name);\n-            \t}\n-            \telse if(m_inCache.m_modelGroupsUnresolved.containsKey(name) || \n-            \t        m_modelGroupsResolvedFromExistingCache.containsKey(name))\n-            \t{\n-            \t\t// This component is a reference which refers to an imported component; otherwise, its name would not be \n-            \t\t// in the m_inCache.m_XxxUnresolved.  When XMLSchemaCache.registerXxx is called, it removes name from m_XxxUnresolved,\n-            \t\t// and registerXxxt is called when XMLSchemaParser encounters a global component, the only components that can be referenced.\n-            \t\t// So, we're going to remove its name from the list, NOT convert it, and return the existing component.\n+                } else if (m_inCache.m_modelGroupsUnresolved.containsKey(name) ||\n+                    m_modelGroupsResolvedFromExistingCache.containsKey(name)) {\n+                    // This component is a reference which refers to an imported component; otherwise, its name would not be\n+                    // in the m_inCache.m_XxxUnresolved.  When XMLSchemaCache.registerXxx is called, it removes name from m_XxxUnresolved,\n+                    // and registerXxxt is called when XMLSchemaParser encounters a global component, the only components that can be referenced.\n+                    // So, we're going to remove its name from the list, NOT convert it, and return the existing component.\n                     m_inCache.m_modelGroupsUnresolved.remove(name);\n-            \t\tModelGroup existing = m_existingCache.getModelGroup(name);\n-            \t\tm_modelGroupsResolvedFromExistingCache.put(name, existing);\n+                    ModelGroup existing = m_existingCache.getModelGroup(name);\n+                    m_modelGroupsResolvedFromExistingCache.put(name, existing);\n                     return existing;\n-            \t}\n+                }\n             }\n-            if (m_cycles.groups.contains(xmlModelGroup))\n+            if (m_cycles.groups.contains(xmlModelGroup)) {\n                 throw new SccCyclicModelGroupException(name, xmlModelGroup.getLocation());\n-            else\n+            } else {\n                 m_cycles.groups.push(xmlModelGroup);\n-        }\n-        else\n-        {\n+            }\n+        } else {\n             name = null;\n             isAnonymous = true;\n         }\n@@ -1437,98 +1313,84 @@ public final class XMLSchemaConverter\n         final ModelGroup.SmCompositor compositor = xmlModelGroup.getCompositor();\n         final LinkedList<SchemaParticle> particles = new LinkedList<SchemaParticle>();\n         ModelGroup modelGroup = new ModelGroupImpl(compositor, particles, name, isAnonymous, scope);\n-        copyForeignAttributes(xmlModelGroup.foreignAttributes, (ModelGroupImpl)modelGroup);\n-        if (modelGroup.getScopeExtent() == ScopeExtent.Global)\n+        copyForeignAttributes(xmlModelGroup.foreignAttributes, (ModelGroupImpl) modelGroup);\n+        if (modelGroup.getScopeExtent() == ScopeExtent.Global) {\n             m_outBag.add(modelGroup);\n+        }\n //System.out.println(\"add model group\");\n         m_locations.m_modelGroupLocations.put(xmlModelGroup.getLocation(), modelGroup);\n \n-        try\n-        {\n-            \n-            for (final XMLParticle xmlParticle : xmlModelGroup.getParticles())\n-            {\n-                try\n-                {\n-                    if (xmlParticle instanceof XMLParticleWithModelGroupTerm)\n-                        particles.add(convertModelGroupUse((XMLParticleWithModelGroupTerm)xmlParticle));\n-                    else if (xmlParticle instanceof XMLParticleWithElementTerm)\n-                    {\n-                    \t// We must prevent the contents of element particle from becoming part of our invalid cycles check.\n-                    \t// So, we're going to clear the cycles for groups, and then restore it after we finish processing the \n-                    \t// element.  \n+        try {\n+\n+            for (final XMLParticle xmlParticle : xmlModelGroup.getParticles()) {\n+                try {\n+                    if (xmlParticle instanceof XMLParticleWithModelGroupTerm) {\n+                        particles\n+                            .add(convertModelGroupUse((XMLParticleWithModelGroupTerm) xmlParticle));\n+                    } else if (xmlParticle instanceof XMLParticleWithElementTerm) {\n+                        // We must prevent the contents of element particle from becoming part of our invalid cycles check.\n+                        // So, we're going to clear the cycles for groups, and then restore it after we finish processing the\n+                        // element.\n                         Stack<XMLModelGroup> tempGroups = null;\n-                        if (!m_cycles.groups.isEmpty())\n-                        {\n-                        \ttempGroups = new Stack<XMLModelGroup>();\n-                        \tfor(XMLModelGroup group : m_cycles.groups)\n-                        \t{\n-                        \t\ttempGroups.add(group);\n-                        \t}\n+                        if (!m_cycles.groups.isEmpty()) {\n+                            tempGroups = new Stack<XMLModelGroup>();\n+                            for (XMLModelGroup group : m_cycles.groups) {\n+                                tempGroups.add(group);\n+                            }\n                             m_cycles.groups.clear();\n                         }\n-                        particles.add(convertElementUse((XMLParticleWithElementTerm)xmlParticle));\n-                        if (tempGroups != null)\n-                        {\n-                        \tm_cycles.groups.clear(); // should be clear, already; so, this line is probably unnecessary\n-                        \tfor(XMLModelGroup group : tempGroups)\n-                        \t{\n-                        \t\tm_cycles.groups.add(group);\n-                        \t}\n+                        particles.add(convertElementUse((XMLParticleWithElementTerm) xmlParticle));\n+                        if (tempGroups != null) {\n+                            m_cycles.groups\n+                                .clear(); // should be clear, already; so, this line is probably unnecessary\n+                            for (XMLModelGroup group : tempGroups) {\n+                                m_cycles.groups.add(group);\n+                            }\n                         }\n-                    }\n-                    else if (xmlParticle instanceof XMLParticleWithWildcardTerm)\n-                        particles.add(convertWildcardUse((XMLParticleWithWildcardTerm)xmlParticle));\n-                    else\n+                    } else if (xmlParticle instanceof XMLParticleWithWildcardTerm) {\n+                        particles\n+                            .add(convertWildcardUse((XMLParticleWithWildcardTerm) xmlParticle));\n+                    } else {\n                         throw new AssertionError(xmlParticle);\n+                    }\n \n                 } // try block\n-                catch (final SchemaException e)\n-                {\n+                catch (final SchemaException e) {\n                     m_errors.error(e);\n                 }\n             }\n             return modelGroup;\n-        }\n-        finally\n-        {\n-            if (scope == ScopeExtent.Global)\n+        } finally {\n+            if (scope == ScopeExtent.Global) {\n                 m_cycles.groups.pop();\n+            }\n         }\n     }\n \n-    private void convertModelGroups() \n-        throws AbortException\n-    {\n-        for (final XMLModelGroup source : m_inCache.m_modelGroups.values())\n-        {\n-            try\n-            {\n+    private void convertModelGroups()\n+        throws AbortException {\n+        for (final XMLModelGroup source : m_inCache.m_modelGroups.values()) {\n+            try {\n                 QName name = source.getName();\n-                if (!m_lastInWins && (m_existingCache.getModelGroup(name) != null))\n+                if (!m_lastInWins && (m_existingCache.getModelGroup(name) != null)) {\n                     m_inCache.m_modelGroupsUnresolved.remove(name);\n+                }\n                 convertModelGroup(source);\n-            }\n-            catch (final SchemaException e)\n-            {\n+            } catch (final SchemaException e) {\n                 m_errors.error(e);\n             }\n         }\n     }\n \n-    private ModelGroupUse convertModelGroupUse(final XMLParticleWithModelGroupTerm particle) \n-        throws AbortException, SchemaException\n-    {\n+    private ModelGroupUse convertModelGroupUse(final XMLParticleWithModelGroupTerm particle)\n+        throws AbortException, SchemaException {\n         final ModelGroup modelGroup = convertModelGroup(particle.getTerm());\n \n         final ModelGroupUse modelGroupUse;\n-        if (isMaxOccursUnbounded(particle.getMaxOccurs()))\n-        {\n+        if (isMaxOccursUnbounded(particle.getMaxOccurs())) {\n             final int minOccurs = minOccurs(particle.getMinOccurs());\n             modelGroupUse = new ParticleWithModelGroupTerm(minOccurs, modelGroup);\n-        }\n-        else\n-        {\n+        } else {\n             final int minOccurs = minOccurs(particle.getMinOccurs());\n             final int maxOccurs = maxOccurs(particle.getMaxOccurs());\n             modelGroupUse = new ParticleWithModelGroupTerm(minOccurs, maxOccurs, modelGroup);\n@@ -1538,29 +1400,28 @@ public final class XMLSchemaConverter\n         return modelGroupUse;\n     }\n \n-    private NotationDefinition convertNotation(final XMLNotation xmlNotation)\n-    {\n-        final NotationDefinition notation = new NotationImpl(xmlNotation.getName(), xmlNotation.getPublicId(), xmlNotation.getSystemId());\n-        copyForeignAttributes(xmlNotation.foreignAttributes, (NotationImpl)notation);\n+    private NotationDefinition convertNotation(final XMLNotation xmlNotation) {\n+        final NotationDefinition notation =\n+            new NotationImpl(xmlNotation.getName(), xmlNotation.getPublicId(),\n+                xmlNotation.getSystemId());\n+        copyForeignAttributes(xmlNotation.foreignAttributes, (NotationImpl) notation);\n         m_outBag.add(notation);\n //System.out.println(\"add notation\");\n         m_locations.m_notationLocations.put(xmlNotation.getLocation(), notation);\n         return notation;\n     }\n \n-    private void convertNotations()\n-    {\n-        for (final XMLNotation source : m_inCache.m_notations.values())\n-        {\n+    private void convertNotations() {\n+        for (final XMLNotation source : m_inCache.m_notations.values()) {\n             QName name = source.getName();\n-            if (!m_lastInWins && (m_existingCache.getNotationDeclaration(name) != null))\n+            if (!m_lastInWins && (m_existingCache.getNotationDeclaration(name) != null)) {\n                 m_inCache.m_notationsUnresolved.remove(name);\n+            }\n             convertNotation(source);\n         }\n     }\n \n-    private ScopeExtent convertScope(final XMLScope scope)\n-    {\n+    private ScopeExtent convertScope(final XMLScope scope) {\n         PreCondition.assertArgumentNotNull(scope, \"scope\");\n \n         return scope.isGlobal() ? ScopeExtent.Global : ScopeExtent.Local;\n@@ -1569,150 +1430,141 @@ public final class XMLSchemaConverter\n     /**\n      * Applies the Schema Component Constraints to this Simple Type.\n      */\n-    private SimpleType convertSimpleType(final QName name, final boolean isAnonymous, final XMLType xmlSimpleType) \n-        throws AbortException, SchemaException\n-    {\n+    private SimpleType convertSimpleType(final QName name, final boolean isAnonymous,\n+                                         final XMLType xmlSimpleType)\n+        throws AbortException, SchemaException {\n         PreCondition.assertTrue(xmlSimpleType.isSimple(), \"expecting a simple type for \" + name);\n \n         final ScopeExtent scope = convertScope(xmlSimpleType.getScope());\n-        if (scope == ScopeExtent.Global)\n-        {\n-            if (m_outBag.hasSimpleType(name))\n+        if (scope == ScopeExtent.Global) {\n+            if (m_outBag.hasSimpleType(name)) {\n                 return m_outBag.getSimpleType(name);\n-            if (m_existingCache.hasSimpleType(name))\n-            {\n-            \tif (!m_lastInWins)\n-            \t{\n-            \t\t// We are not allowing this schema parse to create new elements.  \n+            }\n+            if (m_existingCache.hasSimpleType(name)) {\n+                if (!m_lastInWins) {\n+                    // We are not allowing this schema parse to create new elements.\n                     m_inCache.m_typesUnresolved.remove(name);\n                     return m_existingCache.getSimpleType(name);\n-            \t}\n-            \telse if (m_inCache.m_typesUnresolved.containsKey(name) || \n-            \t         m_typesResolvedFromExistingCache.containsKey(name))\n-            \t{\n-            \t\t// This component is a reference which refers to an imported component; otherwise, its name would not be \n-            \t\t// in the m_inCache.m_XxxUnresolved.  When XMLSchemaCache.registerXxx is called, it removes name from m_XxxUnresolved,\n-            \t\t// and registerXxxt is called when XMLSchemaParser encounters a global component, the only components that can be referenced.\n-            \t\t// So, we're going to remove its name from the list, NOT convert it, and return the existing component.\n+                } else if (m_inCache.m_typesUnresolved.containsKey(name) ||\n+                    m_typesResolvedFromExistingCache.containsKey(name)) {\n+                    // This component is a reference which refers to an imported component; otherwise, its name would not be\n+                    // in the m_inCache.m_XxxUnresolved.  When XMLSchemaCache.registerXxx is called, it removes name from m_XxxUnresolved,\n+                    // and registerXxxt is called when XMLSchemaParser encounters a global component, the only components that can be referenced.\n+                    // So, we're going to remove its name from the list, NOT convert it, and return the existing component.\n                     m_inCache.m_typesUnresolved.remove(name);\n-            \t\tSimpleType existing = m_existingCache.getSimpleType(name);\n-            \t\tm_typesResolvedFromExistingCache.put(name, existing);\n+                    SimpleType existing = m_existingCache.getSimpleType(name);\n+                    m_typesResolvedFromExistingCache.put(name, existing);\n                     return existing;\n-            \t}\n+                }\n             }\n-            if (m_cycles.types.contains(xmlSimpleType))\n+            if (m_cycles.types.contains(xmlSimpleType)) {\n                 throw new SmCyclicTypeException(name);\n+            }\n \n             m_cycles.types.push(xmlSimpleType);\n         }\n-        try\n-        {\n+        try {\n             final SimpleType simpleBaseType;\n-            if (xmlSimpleType.getBaseRef() != null)\n+            if (xmlSimpleType.getBaseRef() != null) {\n                 simpleBaseType = convertSimpleTypeBase(name, xmlSimpleType.getBaseRef());\n-            else\n-                simpleBaseType = convertSimpleTypeBase(name, xmlSimpleType.getScope().getType().getBaseRef());\n+            } else {\n+                simpleBaseType =\n+                    convertSimpleTypeBase(name, xmlSimpleType.getScope().getType().getBaseRef());\n+            }\n \n             final SimpleTypeImpl simpleType;\n-            final DerivationMethod derivation = PreCondition.assertNotNull(xmlSimpleType.getDerivationMethod(), \"{type definition} with base \" + simpleBaseType.getName());\n+            final DerivationMethod derivation = PreCondition\n+                .assertNotNull(xmlSimpleType.getDerivationMethod(),\n+                    \"{type definition} with base \" + simpleBaseType.getName());\n             final WhiteSpacePolicy whiteSpace = xmlSimpleType.getWhiteSpacePolicy();\n-            if (derivation.isUnion())\n-            {\n+            if (derivation.isUnion()) {\n                 final LinkedList<SimpleType> memberTypes = new LinkedList<SimpleType>();\n-                for (final XMLTypeRef memberRef : xmlSimpleType.memberRefs)\n-                {\n+                for (final XMLTypeRef memberRef : xmlSimpleType.memberRefs) {\n                     final SimpleType memberType = convertMemberType(name, memberRef);\n                     memberTypes.add(memberType);\n                 }\n-                simpleType = new UnionTypeImpl(name, isAnonymous, scope, simpleBaseType, memberTypes, whiteSpace);\n+                simpleType =\n+                    new UnionTypeImpl(name, isAnonymous, scope, simpleBaseType, memberTypes,\n+                        whiteSpace);\n                 m_outBag.add(simpleType);\n //System.out.println(\"add simple type \"+name);\n                 m_locations.m_simpleTypeLocations.put(xmlSimpleType.getLocation(), simpleType);\n-            }\n-            else if (derivation.isList())\n-            {\n+            } else if (derivation.isList()) {\n                 final SimpleType itemType = convertItemType(name, xmlSimpleType.itemRef);\n-                simpleType = new ListTypeImpl(name, isAnonymous, scope, itemType, simpleBaseType, whiteSpace);\n+                simpleType = new ListTypeImpl(name, isAnonymous, scope, itemType, simpleBaseType,\n+                    whiteSpace);\n                 m_outBag.add(simpleType);\n //System.out.println(\"add simple type \"+name);\n                 m_locations.m_simpleTypeLocations.put(xmlSimpleType.getLocation(), simpleType);\n-            }\n-            else if (derivation.isRestriction())\n-                simpleType = deriveSimpleType(name, isAnonymous, scope, simpleBaseType, whiteSpace, xmlSimpleType.getLocation());\n-            else\n+            } else if (derivation.isRestriction()) {\n+                simpleType = deriveSimpleType(name, isAnonymous, scope, simpleBaseType, whiteSpace,\n+                    xmlSimpleType.getLocation());\n+            } else {\n                 throw new AssertionError(derivation.name());\n+            }\n             computePatterns(xmlSimpleType.getPatternFacets(), simpleType);\n             computeFacets(simpleBaseType, xmlSimpleType, simpleType);\n             computeEnumerations(simpleBaseType, xmlSimpleType, simpleType);\n             copyForeignAttributes(xmlSimpleType.foreignAttributes, simpleType);\n             return simpleType;\n-        }\n-        finally\n-        {\n-            if (scope == ScopeExtent.Global)\n+        } finally {\n+            if (scope == ScopeExtent.Global) {\n                 m_cycles.types.pop();\n+            }\n         }\n     }\n \n-    private SimpleType convertSimpleTypeBase(final QName simpleType, final XMLTypeRef baseRef) \n-        throws AbortException, SchemaException\n-    {\n+    private SimpleType convertSimpleTypeBase(final QName simpleType, final XMLTypeRef baseRef)\n+        throws AbortException, SchemaException {\n         final Type baseType = convertType(baseRef);\n-        if (baseType instanceof SimpleType)\n-            return (SimpleType)baseType;\n+        if (baseType instanceof SimpleType) {\n+            return (SimpleType) baseType;\n+        }\n         throw new SccBaseTypeMustBeSimpleTypeException(simpleType);\n     }\n \n-    private Type convertType(final QName name, final boolean isAnonymous) \n-        throws SchemaException, AbortException\n-    {\n+    private Type convertType(final QName name, final boolean isAnonymous)\n+        throws SchemaException, AbortException {\n         // note: as of 2014-2-18, only ever called from convertType(XMLTypeRef) (q.v.)\n         // first, check our incrementally collected results, in m_outBag.\n         // if we have something there, return it.\n         // should we insure that it's not in the unresolved list, in that case?\n-        if (m_outBag.hasSimpleType(name))\n+        if (m_outBag.hasSimpleType(name)) {\n             return m_outBag.getSimpleType(name);\n-        else if (m_outBag.hasComplexType(name))\n+        } else if (m_outBag.hasComplexType(name)) {\n             return m_outBag.getComplexType(name);\n-        else\n-        {\n+        } else {\n             // now, we look in the collection of xmlrep components. is it there?\n-            if (m_inCache.m_globalTypes.containsKey(name))\n-            {\n+            if (m_inCache.m_globalTypes.containsKey(name)) {\n                 // okay. if it's simple or complex, convert it and return\n                 final XMLType type = m_inCache.m_globalTypes.get(name);\n-                if (type.isSimple())\n+                if (type.isSimple()) {\n                     return convertSimpleType(name, isAnonymous, type);\n-                else if (type.isComplex())\n+                } else if (type.isComplex()) {\n                     return convertComplexType(name, isAnonymous, type);\n+                }\n                 // if not, then it's an unresolved reference. so ... don't ever\n                 // call this method if there's more parsing to be done, eh?\n-                if (m_lastInWins) \n-                {\n+                if (m_lastInWins) {\n                     // if operating w/lastInWins true, reference could still be in existing cache\n                     // and we wouldn't have resolved it, yet.  check now.)\n-                    if (m_existingCache.hasSimpleType(name))\n-                    {\n+                    if (m_existingCache.hasSimpleType(name)) {\n                         m_inCache.m_typesUnresolved.remove(name);\n                         return m_existingCache.getSimpleType(name);\n-                    }\n-                    else if (m_existingCache.hasComplexType(name))\n-                    {\n+                    } else if (m_existingCache.hasComplexType(name)) {\n                         m_inCache.m_typesUnresolved.remove(name);\n                         return m_existingCache.getComplexType(name);\n                     }\n                 }\n-                throw new SmUndeclaredReferenceException(name, m_inCache.m_typesUnresolved.get(name));\n+                throw new SmUndeclaredReferenceException(name,\n+                    m_inCache.m_typesUnresolved.get(name));\n             }\n             // it's not in the collection of unresolved components\n             // is it already in our component provider?\n-            else if (m_existingCache.hasSimpleType(name))\n-            {\n+            else if (m_existingCache.hasSimpleType(name)) {\n                 m_inCache.m_typesUnresolved.remove(name);\n                 return m_existingCache.getSimpleType(name);\n-            }\n-            else if (m_existingCache.hasComplexType(name))\n-            {\n+            } else if (m_existingCache.hasComplexType(name)) {\n                 m_inCache.m_typesUnresolved.remove(name);\n                 return m_existingCache.getComplexType(name);\n             }\n@@ -1721,39 +1573,34 @@ public final class XMLSchemaConverter\n         }\n     }\n \n-    private Type convertType(final QName name, final boolean isAnonymous, final XMLType type) \n-        throws AbortException, SchemaException\n-    {\n-        if (type.isSimple())\n+    private Type convertType(final QName name, final boolean isAnonymous, final XMLType type)\n+        throws AbortException, SchemaException {\n+        if (type.isSimple()) {\n             return convertSimpleType(name, isAnonymous, type);\n-        else if (type.isComplex())\n+        } else if (type.isComplex()) {\n             return convertComplexType(name, isAnonymous, type);\n+        }\n         // if it's neither simple nor complex, it's a type reference without a referent\n         throw new SmUndeclaredReferenceException(name, m_inCache.m_typesUnresolved.get(name));\n     }\n \n-    private Type convertType(final XMLTypeRef typeRef) \n-        throws AbortException, SchemaException\n-    {\n-        if (typeRef.isGlobal())\n-        {\n+    private Type convertType(final XMLTypeRef typeRef)\n+        throws AbortException, SchemaException {\n+        if (typeRef.isGlobal()) {\n             QName name = typeRef.getName();\n             // normal case: lastInWins is not true.\n             // check the cache.\n-            if (!m_lastInWins)\n-            {\n-                if (m_existingCache.hasComplexType(name))\n-                {\n+            if (!m_lastInWins) {\n+                if (m_existingCache.hasComplexType(name)) {\n                     m_inCache.m_typesUnresolved.remove(name);\n                     return m_existingCache.getComplexType(name);\n                 }\n-                if (m_existingCache.hasSimpleType(name))\n-                {\n+                if (m_existingCache.hasSimpleType(name)) {\n                     m_inCache.m_typesUnresolved.remove(name);\n                     return m_existingCache.getSimpleType(name);\n                 }\n             }\n-            \n+\n             // either it wasn't in the cache (an error), or\n             // we're doing lastInWins (it may be in the outbag)\n             // so call convertType, so that we check outbag\n@@ -1763,123 +1610,116 @@ public final class XMLSchemaConverter\n         return convertType(m_existingCache.generateUniqueName(), true, typeRef.getLocal());\n     }\n \n-    private void convertTypes() \n-        throws AbortException\n-    {\n+    private void convertTypes()\n+        throws AbortException {\n         // we're iterating over all of the global types that haven't been\n         // converted yet. local types can't ever be unresolved, of course,\n         // and should be handled in the context of whatever contains them.\n-        for (final XMLType sourceType : m_inCache.m_globalTypes.values())\n-        {\n+        for (final XMLType sourceType : m_inCache.m_globalTypes.values()) {\n             // {name} is known because the type is global.\n             final QName name = sourceType.getName();\n             // and therefore not anonymous\n             final boolean isAnonymous = false;\n-            try\n-            {\n+            try {\n                 // if this one exists already, do special processing in case lastInWins\n-            \tif (m_existingCache.getComplexType(name) != null || m_existingCache.getSimpleType(name) != null)\n-            \t{\n-            \t    if (!m_lastInWins)\n-            \t        m_inCache.m_typesUnresolved.remove(name);\n-            \t    else\n-            \t    {\n-            \t        // if it's a real type to replace the existing, replace.\n-            \t        if (sourceType.isComplex())\n-            \t            convertComplexType(name, isAnonymous, sourceType);\n-                        else if (sourceType.isSimple())\n+                if (m_existingCache.getComplexType(name) != null ||\n+                    m_existingCache.getSimpleType(name) != null) {\n+                    if (!m_lastInWins) {\n+                        m_inCache.m_typesUnresolved.remove(name);\n+                    } else {\n+                        // if it's a real type to replace the existing, replace.\n+                        if (sourceType.isComplex()) {\n+                            convertComplexType(name, isAnonymous, sourceType);\n+                        } else if (sourceType.isSimple()) {\n                             convertSimpleType(name, isAnonymous, sourceType);\n-            \t        // if neither complex nor simple, then it's a ref; remove from unresolved\n-                        else\n+                        }\n+                        // if neither complex nor simple, then it's a ref; remove from unresolved\n+                        else {\n                             m_inCache.m_typesUnresolved.remove(name);\n-            \t    }\n-            \t}\n-            \t// otherwise, it's not in the existing cache, so convert\n-                else if (sourceType.isComplex())\n+                        }\n+                    }\n+                }\n+                // otherwise, it's not in the existing cache, so convert\n+                else if (sourceType.isComplex()) {\n                     convertComplexType(name, isAnonymous, sourceType);\n-                else if (sourceType.isSimple())\n+                } else if (sourceType.isSimple()) {\n                     convertSimpleType(name, isAnonymous, sourceType);\n-                else // this isn't going to work--it's an incomplete type/type reference without a referent\n+                } else // this isn't going to work--it's an incomplete type/type reference without a referent\n+                {\n                     convertType(name, isAnonymous, sourceType); // let this method throw.\n-            }\n-            catch (final SchemaException e)\n-            {\n+                }\n+            } catch (final SchemaException e) {\n                 m_errors.error(e);\n             }\n         }\n         // do late resolution for all types and for all unresolved elements as well.\n-        try \n-        {\n-            while (!m_lateTypeResolutionNameList.isEmpty())\n-            {\n+        try {\n+            while (!m_lateTypeResolutionNameList.isEmpty()) {\n                 lateResolveType(m_lateTypeResolutionNameList.get(0));\n             }\n-            if (!m_lateTypeResolutionMap.isEmpty())\n-                throw new IllegalStateException(\"Late type resolution map should be empty, but it is not.\");\n+            if (!m_lateTypeResolutionMap.isEmpty()) {\n+                throw new IllegalStateException(\n+                    \"Late type resolution map should be empty, but it is not.\");\n+            }\n             // do we need to do element resolution? convertElement() is called after convertTypes() in convert()\n-            for (ArrayList<LateResolveElement> list : m_lateElementResolutionMap.values())\n-            {\n-                if (!list.isEmpty())\n-                {\n-                    for (LateResolveElement lre : list) \n-                    {\n-                        convertElementTypeRef(lre.mi_xmlElement, lre.mi_elementDecl, lre.mi_subHead);\n+            for (ArrayList<LateResolveElement> list : m_lateElementResolutionMap.values()) {\n+                if (!list.isEmpty()) {\n+                    for (LateResolveElement lre : list) {\n+                        convertElementTypeRef(lre.mi_xmlElement, lre.mi_elementDecl,\n+                            lre.mi_subHead);\n                     }\n                 }\n             }\n-        }\n-        catch (SchemaException se) \n-        { \n-            m_errors.error(se); \n+        } catch (SchemaException se) {\n+            m_errors.error(se);\n         }\n     }\n \n-    private ValueConstraint convertValueConstraint(final String elementName, final XMLValueConstraint xmlValueConstraint, final SimpleType simpleType) \n-        throws SchemaException\n-    {\n-        if (xmlValueConstraint != null)\n-        {\n+    private ValueConstraint convertValueConstraint(final String elementName,\n+                                                   final XMLValueConstraint xmlValueConstraint,\n+                                                   final SimpleType simpleType)\n+        throws SchemaException {\n+        if (xmlValueConstraint != null) {\n             final String initialValue = xmlValueConstraint.getValue();\n-            try\n-            {\n+            try {\n                 List<XmlAtom> val = simpleType.validate(initialValue, m_atoms);\n-                if (val.size() > 0)\n-                    return new ValueConstraint(xmlValueConstraint.kind, simpleType, m_atoms.getC14NForm(val.get(0)));\n+                if (val.size() > 0) {\n+                    return new ValueConstraint(xmlValueConstraint.kind, simpleType,\n+                        m_atoms.getC14NForm(val.get(0)));\n+                }\n                 // TODO: throw a better exception\n                 throw new AssertionError(); // no value in the value constraint\n-            }\n-            catch (DatatypeException dte)\n-            {\n+            } catch (DatatypeException dte) {\n                 // this is sort of a kludge: we can show the localname of the element, but not the\n                 // namespace, because we don't have the namespace here.\n-                final SimpleTypeException ste = new SimpleTypeException(initialValue, simpleType, dte, (elementName == null ? null : new QName(elementName)));\n-                throw new SmAttributeUseException(new QName(elementName), xmlValueConstraint.getAttributeName(), xmlValueConstraint.getLocation(), ste);\n+                final SimpleTypeException ste =\n+                    new SimpleTypeException(initialValue, simpleType, dte,\n+                        (elementName == null ? null : new QName(elementName)));\n+                throw new SmAttributeUseException(new QName(elementName),\n+                    xmlValueConstraint.getAttributeName(), xmlValueConstraint.getLocation(), ste);\n             }\n-            \n+\n         }\n         return null;\n     }\n \n-    private SchemaWildcard convertWildcard(final XMLWildcard wildcard)\n-    {\n-        if (wildcard != null)\n-            return new WildcardImpl(wildcard.getProcessContents(), convert(wildcard.getNamespaceConstraint()));\n+    private SchemaWildcard convertWildcard(final XMLWildcard wildcard) {\n+        if (wildcard != null) {\n+            return new WildcardImpl(wildcard.getProcessContents(),\n+                convert(wildcard.getNamespaceConstraint()));\n+        }\n         return null;\n     }\n \n-    private SchemaParticle convertWildcardUse(final XMLParticleWithWildcardTerm particle) \n-        throws SicOversizedIntegerException\n-    {\n+    private SchemaParticle convertWildcardUse(final XMLParticleWithWildcardTerm particle)\n+        throws SicOversizedIntegerException {\n         final SchemaWildcard wildcard = convertWildcard(particle.getTerm());\n \n         final WildcardUse wildcardUse;\n-        if (isMaxOccursUnbounded(particle.getMaxOccurs()))\n-        {\n+        if (isMaxOccursUnbounded(particle.getMaxOccurs())) {\n             final int minOccurs = minOccurs(particle.getMinOccurs());\n             wildcardUse = new ParticleWithWildcardTerm(minOccurs, wildcard);\n-        }\n-        else\n-        {\n+        } else {\n             final int minOccurs = minOccurs(particle.getMinOccurs());\n             final int maxOccurs = maxOccurs(particle.getMaxOccurs());\n             wildcardUse = new ParticleWithWildcardTerm(minOccurs, maxOccurs, wildcard);\n@@ -1889,50 +1729,50 @@ public final class XMLSchemaConverter\n         return wildcardUse;\n     }\n \n-    private SimpleTypeImpl deriveSimpleType(final QName name, final boolean isAnonymous, final ScopeExtent scope, final SimpleType simpleBaseType, final WhiteSpacePolicy whiteSpace, final SrcFrozenLocation location) \n-        throws SchemaException\n-    {\n+    private SimpleTypeImpl deriveSimpleType(final QName name, final boolean isAnonymous,\n+                                            final ScopeExtent scope,\n+                                            final SimpleType simpleBaseType,\n+                                            final WhiteSpacePolicy whiteSpace,\n+                                            final SrcFrozenLocation location)\n+        throws SchemaException {\n         final SimpleTypeImpl simpleType;\n-        if (simpleBaseType.isAtomicType())\n-        {\n-            final AtomicType atomicBaseType = (AtomicType)simpleBaseType;\n+        if (simpleBaseType.isAtomicType()) {\n+            final AtomicType atomicBaseType = (AtomicType) simpleBaseType;\n             simpleType = new AtomicTypeImpl(name, isAnonymous, scope, atomicBaseType, whiteSpace);\n             m_outBag.add(simpleType);\n //System.out.println(\"add simple type \"+name);\n             m_locations.m_simpleTypeLocations.put(location, simpleType);\n-        }\n-        else if (simpleBaseType instanceof ListSimpleType)\n-        {\n-            final ListSimpleType listBaseListType = (ListSimpleType)simpleBaseType;\n-            simpleType = new ListTypeImpl(name, isAnonymous, scope, listBaseListType.getItemType(), simpleBaseType, whiteSpace);\n+        } else if (simpleBaseType instanceof ListSimpleType) {\n+            final ListSimpleType listBaseListType = (ListSimpleType) simpleBaseType;\n+            simpleType = new ListTypeImpl(name, isAnonymous, scope, listBaseListType.getItemType(),\n+                simpleBaseType, whiteSpace);\n             m_outBag.add(simpleType);\n //System.out.println(\"add simple type \"+name);\n             m_locations.m_simpleTypeLocations.put(location, simpleType);\n-        }\n-        else if (simpleBaseType instanceof UnionSimpleType)\n-        {\n-            final UnionSimpleType unionBaseType = (UnionSimpleType)simpleBaseType;\n-            simpleType = new UnionTypeImpl(name, isAnonymous, scope, simpleBaseType, unionBaseType.getMemberTypes(), whiteSpace);\n+        } else if (simpleBaseType instanceof UnionSimpleType) {\n+            final UnionSimpleType unionBaseType = (UnionSimpleType) simpleBaseType;\n+            simpleType = new UnionTypeImpl(name, isAnonymous, scope, simpleBaseType,\n+                unionBaseType.getMemberTypes(), whiteSpace);\n             m_outBag.add(simpleType);\n //System.out.println(\"add simple type \"+name);\n             m_locations.m_simpleTypeLocations.put(location, simpleType);\n-        }\n-        else if (simpleBaseType.isSimpleUrType())\n+        } else if (simpleBaseType.isSimpleUrType()) {\n             throw new SccBaseTypeMustBeSimpleTypeException(name);\n-        else\n+        } else {\n             throw new AssertionError(simpleBaseType.getClass());\n+        }\n         return simpleType;\n     }\n \n-    private ModelGroupUse effectiveContent(final boolean mixed, final XMLParticleWithModelGroupTerm contentModel) \n-        throws AbortException, SchemaException\n-    {\n-        if (contentModel == null)\n-        {\n-            if (mixed)\n-            {\n+    private ModelGroupUse effectiveContent(final boolean mixed,\n+                                           final XMLParticleWithModelGroupTerm contentModel)\n+        throws AbortException, SchemaException {\n+        if (contentModel == null) {\n+            if (mixed) {\n                 final List<SchemaParticle> particles = Collections.emptyList();\n-                final ModelGroup modelGroup = new ModelGroupImpl(ModelGroup.SmCompositor.Sequence, particles, null, true, ScopeExtent.Local);\n+                final ModelGroup modelGroup =\n+                    new ModelGroupImpl(ModelGroup.SmCompositor.Sequence, particles, null, true,\n+                        ScopeExtent.Local);\n                 return new ParticleWithModelGroupTerm(1, 1, modelGroup);\n             }\n             return null;\n@@ -1940,22 +1780,18 @@ public final class XMLSchemaConverter\n         return convertModelGroupUse(contentModel);\n     }\n \n-    private EnumerationDefinition enumeration(final SimpleType type, final SimpleType baseType, final XMLEnumeration sourceEnum) \n-        throws SmAttributeUseException\n-    {\n-        try\n-        {\n+    private EnumerationDefinition enumeration(final SimpleType type, final SimpleType baseType,\n+                                              final XMLEnumeration sourceEnum)\n+        throws SmAttributeUseException {\n+        try {\n             final SimpleType notationType = m_existingCache.getAtomicType(NativeType.NOTATION);\n             final FacetEnumerationImpl impl;\n-            if (baseType.getName().equals(notationType.getName()) || \n-                baseType.derivedFromType(notationType, EnumSet.of(DerivationMethod.Restriction)))\n-            {\n+            if (baseType.getName().equals(notationType.getName()) ||\n+                baseType.derivedFromType(notationType, EnumSet.of(DerivationMethod.Restriction))) {\n                 final PrefixResolver resolver = sourceEnum.getPrefixResolver();\n                 baseType.validate(sourceEnum.getValue(), resolver, m_atoms);\n                 impl = new FacetEnumerationImpl(sourceEnum.getValue(), baseType, resolver);\n-            }\n-            else\n-            {\n+            } else {\n                 baseType.validate(sourceEnum.getValue(), m_atoms);\n                 impl = new FacetEnumerationImpl(sourceEnum.getValue(), baseType, null);\n             }\n@@ -1963,227 +1799,219 @@ public final class XMLSchemaConverter\n             // all the possible values, not just one of them. if that's wrong, restore this.\n //            copyForeignAttributes(sourceEnum.foreignAttributes, impl);\n             return impl;\n-        }\n-        catch (final DatatypeException dte)\n-        {\n+        } catch (final DatatypeException dte) {\n             // this is one of the places where we don't have an element name for the simple type exception\n-            final SimpleTypeException ste = new SimpleTypeException(sourceEnum.getValue(), baseType, dte);\n-            final QName elementName = new QName(XMLConstants.W3C_XML_SCHEMA_NS_URI, XMLRepresentation.LN_ENUMERATION);\n+            final SimpleTypeException ste =\n+                new SimpleTypeException(sourceEnum.getValue(), baseType, dte);\n+            final QName elementName =\n+                new QName(XMLConstants.W3C_XML_SCHEMA_NS_URI, XMLRepresentation.LN_ENUMERATION);\n             final QName attributeName = new QName(XMLRepresentation.LN_VALUE);\n-            throw new SmAttributeUseException(elementName, attributeName, sourceEnum.getLocation(), ste);\n+            throw new SmAttributeUseException(elementName, attributeName, sourceEnum.getLocation(),\n+                ste);\n         }\n     }\n \n-    private SimpleType extractSimpleType(final XMLTypeRef typeRef) \n-        throws AbortException, SchemaException\n-    {\n+    private SimpleType extractSimpleType(final XMLTypeRef typeRef)\n+        throws AbortException, SchemaException {\n         final Type type = convertType(typeRef);\n-        if (type instanceof SimpleType)\n-            return (SimpleType)type;\n-        else if (type instanceof ComplexType)\n-        {\n-            final ComplexType complexType = (ComplexType)type;\n+        if (type instanceof SimpleType) {\n+            return (SimpleType) type;\n+        } else if (type instanceof ComplexType) {\n+            final ComplexType complexType = (ComplexType) type;\n             final ContentType contentType = complexType.getContentType();\n-            if (contentType.isSimple())\n+            if (contentType.isSimple()) {\n                 return contentType.getSimpleType();\n-            else if (contentType.isMixed())\n+            } else if (contentType.isMixed()) {\n                 return contentType.getSimpleType();\n+            }\n             throw new AssertionError(contentType.getKind());\n         }\n         throw new AssertionError(type);\n     }\n \n-    private Facet fractionDigits(final XMLFractionDigitsFacet xmlFacet) \n-        throws SicOversizedIntegerException\n-    {\n-        final FacetFractionDigitsImpl impl = new FacetFractionDigitsImpl(getIntValue(xmlFacet.value), xmlFacet.fixed);\n+    private Facet fractionDigits(final XMLFractionDigitsFacet xmlFacet)\n+        throws SicOversizedIntegerException {\n+        final FacetFractionDigitsImpl impl =\n+            new FacetFractionDigitsImpl(getIntValue(xmlFacet.value), xmlFacet.fixed);\n         copyForeignAttributes(xmlFacet.foreignAttributes, impl);\n         return impl;\n     }\n-    \n+\n     /**\n      * Converts a BigInteger value to an int value\n-     * \n-     * @param value\n-     *            the BigInteger to convert\n+     *\n+     * @param value the BigInteger to convert\n      * @return the int value equivalent of the incoming BigInteger value\n-     * @throws SicOversizedIntegerException\n-     *             if value is larger than Integer.MAX_VALUE\n+     * @throws SicOversizedIntegerException if value is larger than Integer.MAX_VALUE\n      */\n-    private int getIntValue(final BigInteger value) \n-        throws SicOversizedIntegerException\n-    {\n+    private int getIntValue(final BigInteger value)\n+        throws SicOversizedIntegerException {\n         PreCondition.assertArgumentNotNull(value, \"value\");\n-        if (value.compareTo(MAX_INT_SIZE) <= 0)\n+        if (value.compareTo(MAX_INT_SIZE) <= 0) {\n             return value.intValue();\n+        }\n         throw new SicOversizedIntegerException(value);\n     }\n \n-    private Facet length(final XMLLength xmlFacet) \n-        throws SicOversizedIntegerException\n-    {\n+    private Facet length(final XMLLength xmlFacet)\n+        throws SicOversizedIntegerException {\n         final FacetImpl impl;\n-        if (xmlFacet.minLength != null)\n-        {\n-            if (xmlFacet.maxLength != null)\n-            {\n-                if (xmlFacet.minLength.equals(xmlFacet.maxLength))\n+        if (xmlFacet.minLength != null) {\n+            if (xmlFacet.maxLength != null) {\n+                if (xmlFacet.minLength.equals(xmlFacet.maxLength)) {\n                     impl = new FacetLengthImpl(getIntValue(xmlFacet.minLength), xmlFacet.fixed);\n-                else\n+                } else {\n                     throw new AssertionError();\n-            }\n-            else\n+                }\n+            } else {\n                 impl = new FacetMinLengthImpl(getIntValue(xmlFacet.minLength), xmlFacet.fixed);\n-        }\n-        else\n-        {\n-            if (xmlFacet.maxLength != null)\n+            }\n+        } else {\n+            if (xmlFacet.maxLength != null) {\n                 impl = new FacetMaxLengthImpl(getIntValue(xmlFacet.maxLength), xmlFacet.fixed);\n-            else\n+            } else {\n                 throw new AssertionError();\n+            }\n         }\n         copyForeignAttributes(xmlFacet.foreignAttributes, impl);\n         return impl;\n     }\n \n-    private Limit limit(final String value, final SimpleType simpleType, final FacetKind kind, final boolean isFixed)\n-    {\n+    private Limit limit(final String value, final SimpleType simpleType, final FacetKind kind,\n+                        final boolean isFixed) {\n         PreCondition.assertArgumentNotNull(value, \"value\");\n         PreCondition.assertArgumentNotNull(simpleType, \"simpleType\");\n         PreCondition.assertArgumentNotNull(kind, \"kind\");\n \n-        if (simpleType.isAtomicType())\n+        if (simpleType.isAtomicType()) {\n             return new FacetValueCompImpl(value, kind, simpleType, isFixed);\n-        else if (simpleType instanceof ListSimpleType)\n-        {\n-            final ListSimpleType listType = (ListSimpleType)simpleType;\n+        } else if (simpleType instanceof ListSimpleType) {\n+            final ListSimpleType listType = (ListSimpleType) simpleType;\n             final SimpleType itemType = listType.getItemType();\n-            if (itemType.isAtomicType())\n-            {\n-                final SimpleType atomicType = (SimpleType)itemType;\n+            if (itemType.isAtomicType()) {\n+                final SimpleType atomicType = (SimpleType) itemType;\n                 return new FacetValueCompImpl(value, kind, atomicType, isFixed);\n-            }\n-            else if (itemType instanceof UnionSimpleType)\n-                // is this a TODO? or does the specification forbid lists of unions?\n+            } else if (itemType instanceof UnionSimpleType)\n+            // is this a TODO? or does the specification forbid lists of unions?\n+            {\n                 throw new UnsupportedOperationException();\n-            else\n-                // The specification forbids lists of lists.\n+            } else\n+            // The specification forbids lists of lists.\n+            {\n                 throw new UnsupportedOperationException();\n-        }\n-        else if (simpleType instanceof UnionSimpleType)\n-            // TODO: is a limit on a union forbidden?\n+            }\n+        } else if (simpleType instanceof UnionSimpleType)\n+        // TODO: is a limit on a union forbidden?\n+        {\n             throw new UnsupportedOperationException();\n-        else\n-            // Simple Ur-Type? TODO: no limits?\n+        } else\n+        // Simple Ur-Type? TODO: no limits?\n+        {\n             throw new UnsupportedOperationException();\n+        }\n     }\n \n-    private Facet minmax(final XMLMinMaxFacet xmlFacet, final SimpleType baseType) \n-        throws SchemaException\n-    {\n+    private Facet minmax(final XMLMinMaxFacet xmlFacet, final SimpleType baseType)\n+        throws SchemaException {\n         final List<XmlAtom> value;\n         {\n             final String initialValue = xmlFacet.value;\n-            try\n-            {\n+            try {\n                 value = baseType.validate(initialValue, m_atoms);\n-            }\n-            catch (final DatatypeException dte)\n-            {\n+            } catch (final DatatypeException dte) {\n                 // don't have an element name\n-                final SimpleTypeException ste = new SimpleTypeException(initialValue, baseType, dte);\n-                final QName elementName = new QName(XMLConstants.W3C_XML_SCHEMA_NS_URI, xmlFacet.elementName);\n+                final SimpleTypeException ste =\n+                    new SimpleTypeException(initialValue, baseType, dte);\n+                final QName elementName =\n+                    new QName(XMLConstants.W3C_XML_SCHEMA_NS_URI, xmlFacet.elementName);\n                 final QName attributeName = new QName(XMLRepresentation.LN_VALUE);\n                 final SrcFrozenLocation location = xmlFacet.getLocation();\n                 throw new SmAttributeUseException(elementName, attributeName, location, ste);\n             }\n         }\n-        if (value.size() > 0)\n-            return limit(m_atoms.getC14NForm(value.get(0)), baseType, xmlFacet.getOperator(), xmlFacet.fixed);\n+        if (value.size() > 0) {\n+            return limit(m_atoms.getC14NForm(value.get(0)), baseType, xmlFacet.getOperator(),\n+                xmlFacet.fixed);\n+        }\n         return null;\n     }\n \n-    private Pattern pattern(final XMLPatternFacet pattern) \n-        throws SmAttributeUseException\n-    {\n-        try\n-        {\n+    private Pattern pattern(final XMLPatternFacet pattern)\n+        throws SmAttributeUseException {\n+        try {\n             final String regex = pattern.value;\n-            try\n-            {\n+            try {\n                 final RegExPattern regexp = regexc.compile(regex);\n                 final FacetPatternImpl impl = new FacetPatternImpl(regexp, regex);\n                 copyForeignAttributes(pattern.foreignAttributes, impl);\n                 return impl;\n-            }\n-            catch (final SchemaRegExCompileException e)\n-            {\n+            } catch (final SchemaRegExCompileException e) {\n                 final DatatypeException dte = new DatatypeException(regex, null);\n                 // don't have an element name\n                 throw new SimpleTypeException(regex, null, dte);\n             }\n-        }\n-        catch (final SimpleTypeException ste)\n-        {\n-            final QName elementName = new QName(XMLConstants.W3C_XML_SCHEMA_NS_URI, XMLRepresentation.LN_PATTERN);\n+        } catch (final SimpleTypeException ste) {\n+            final QName elementName =\n+                new QName(XMLConstants.W3C_XML_SCHEMA_NS_URI, XMLRepresentation.LN_PATTERN);\n             final QName attributeName = new QName(XMLRepresentation.LN_VALUE);\n-            throw new SmAttributeUseException(elementName, attributeName, pattern.getLocation(), ste);\n+            throw new SmAttributeUseException(elementName, attributeName, pattern.getLocation(),\n+                ste);\n         }\n     }\n \n-    private ContentType simpleContent(final XMLType simpleType, final SimpleType simpleBaseType) \n-        throws AbortException, SchemaException\n-    {\n+    private ContentType simpleContent(final XMLType simpleType, final SimpleType simpleBaseType)\n+        throws AbortException, SchemaException {\n         final QName name;\n         final boolean isAnonymous;\n         final ScopeExtent scope = convertScope(simpleType.getScope());\n-        if (scope == ScopeExtent.Global)\n-        {\n+        if (scope == ScopeExtent.Global) {\n             name = simpleType.getName();\n             isAnonymous = false;\n-        }\n-        else\n-        {\n+        } else {\n             name = m_existingCache.generateUniqueName();\n             isAnonymous = true;\n         }\n         final WhiteSpacePolicy whiteSpace = simpleType.getWhiteSpacePolicy();\n-        final SimpleTypeImpl simpleTypeD = deriveSimpleType(name, isAnonymous, scope, simpleBaseType, whiteSpace, simpleType.getLocation());\n+        final SimpleTypeImpl simpleTypeD =\n+            deriveSimpleType(name, isAnonymous, scope, simpleBaseType, whiteSpace,\n+                simpleType.getLocation());\n         computePatterns(simpleType.getPatternFacets(), simpleTypeD);\n         computeFacets(simpleBaseType, simpleType, simpleTypeD);\n         computeEnumerations(simpleBaseType, simpleType, simpleTypeD);\n         return new ContentTypeImpl(simpleTypeD);\n     }\n \n-    private Facet totalDigits(final XMLTotalDigitsFacet xmlFacet) \n-        throws SicOversizedIntegerException\n-    {\n-        final FacetTotalDigitsImpl impl = new FacetTotalDigitsImpl(getIntValue(xmlFacet.value), xmlFacet.fixed);\n+    private Facet totalDigits(final XMLTotalDigitsFacet xmlFacet)\n+        throws SicOversizedIntegerException {\n+        final FacetTotalDigitsImpl impl =\n+            new FacetTotalDigitsImpl(getIntValue(xmlFacet.value), xmlFacet.fixed);\n         copyForeignAttributes(xmlFacet.foreignAttributes, impl);\n         return impl;\n     }\n-    \n-    private void copyForeignAttributes(FAMap source, ForeignAttributesSink target)\n-    {\n-        for (QName name : source.keySet())\n-        {\n+\n+    private void copyForeignAttributes(FAMap source, ForeignAttributesSink target) {\n+        for (QName name : source.keySet()) {\n             target.putForeignAttribute(name, source.get(name));\n         }\n     }\n \n-    public static Pair<ComponentBagImpl, XMLBidiComponentLocator> convert(final SchemaRegExCompiler regexc, final ComponentProvider rtmCache, final XMLSchemaCache xmlCache, final SchemaExceptionHandler errors) \n-        throws AbortException\n-    {\n-    \treturn convert(regexc, rtmCache, xmlCache, errors, false);\n+    public static Pair<ComponentBagImpl, XMLBidiComponentLocator> convert(\n+        final SchemaRegExCompiler regexc, final ComponentProvider rtmCache,\n+        final XMLSchemaCache xmlCache, final SchemaExceptionHandler errors)\n+        throws AbortException {\n+        return convert(regexc, rtmCache, xmlCache, errors, false);\n     }\n-    \n-    public static  Pair<ComponentBagImpl, XMLBidiComponentLocator> convert(final SchemaRegExCompiler regexc, final ComponentProvider rtmCache, final XMLSchemaCache xmlCache, final SchemaExceptionHandler errors, boolean lastInWins) \n-        throws AbortException\n-    {\n+\n+    public static Pair<ComponentBagImpl, XMLBidiComponentLocator> convert(\n+        final SchemaRegExCompiler regexc, final ComponentProvider rtmCache,\n+        final XMLSchemaCache xmlCache, final SchemaExceptionHandler errors, boolean lastInWins)\n+        throws AbortException {\n         final ComponentBagImpl schema = new ComponentBagImpl();\n         final XMLBidiComponentLocator locations = new XMLBidiComponentLocator();\n \n-        final XMLSchemaConverter converter = new XMLSchemaConverter(regexc, rtmCache, xmlCache, schema, locations, errors, lastInWins);\n+        final XMLSchemaConverter converter =\n+            new XMLSchemaConverter(regexc, rtmCache, xmlCache, schema, locations, errors,\n+                lastInWins);\n \n         xmlCache.computeSubstitutionGroups();\n \n@@ -2198,66 +2026,63 @@ public final class XMLSchemaConverter\n         return new Pair<ComponentBagImpl, XMLBidiComponentLocator>(schema, locations);\n     }\n \n-    static boolean isMaxOccursUnbounded(final BigInteger maxOccurs) \n-        throws SicOversizedIntegerException\n-    {\n+    static boolean isMaxOccursUnbounded(final BigInteger maxOccurs)\n+        throws SicOversizedIntegerException {\n         PreCondition.assertArgumentNotNull(maxOccurs, \"maxOccurs\");\n \n-        if (XMLParticle.UNBOUNDED.equals(maxOccurs))\n+        if (XMLParticle.UNBOUNDED.equals(maxOccurs)) {\n             return true;\n-        else\n-        {\n-            if (MAX_INT_SIZE.compareTo(maxOccurs) < 0)\n+        } else {\n+            if (MAX_INT_SIZE.compareTo(maxOccurs) < 0) {\n                 throw new SicOversizedIntegerException(maxOccurs);\n+            }\n             return false;\n         }\n     }\n \n-    static int maxOccurs(final BigInteger maxOccurs) \n-        throws SicOversizedIntegerException\n-    {\n+    static int maxOccurs(final BigInteger maxOccurs)\n+        throws SicOversizedIntegerException {\n         PreCondition.assertArgumentNotNull(maxOccurs, \"maxOccurs\");\n \n-        if (XMLParticle.UNBOUNDED.equals(maxOccurs))\n+        if (XMLParticle.UNBOUNDED.equals(maxOccurs)) {\n             throw new IllegalStateException(\"maxOccurs is unbounded\");\n-        else\n-        {\n-            if (MAX_INT_SIZE.compareTo(maxOccurs) < 0)\n+        } else {\n+            if (MAX_INT_SIZE.compareTo(maxOccurs) < 0) {\n                 throw new SicOversizedIntegerException(maxOccurs);\n+            }\n             return maxOccurs.intValue();\n         }\n     }\n \n-    static int minOccurs(final BigInteger minOccurs) \n-        throws SicOversizedIntegerException\n-    {\n+    static int minOccurs(final BigInteger minOccurs)\n+        throws SicOversizedIntegerException {\n         PreCondition.assertArgumentNotNull(minOccurs, \"minOccurs\");\n-        if (MAX_INT_SIZE.compareTo(minOccurs) < 0)\n+        if (MAX_INT_SIZE.compareTo(minOccurs) < 0) {\n             throw new SicOversizedIntegerException(minOccurs);\n-        else\n-        {\n+        } else {\n             PreCondition.assertTrue(minOccurs.compareTo(BigInteger.ZERO) >= 0, \"minOccurs >= 0\");\n             return minOccurs.intValue();\n         }\n     }\n \n-    private static boolean subtype(final Type lhs, final Type rhs)\n-    {\n+    private static boolean subtype(final Type lhs, final Type rhs) {\n         PreCondition.assertArgumentNotNull(lhs, \"lhs\");\n         PreCondition.assertArgumentNotNull(rhs, \"rhs\");\n-        if (!rhs.isComplexUrType())\n-        {\n+        if (!rhs.isComplexUrType()) {\n             Type currentType = lhs;\n-            while (true)\n-            {\n-            \tif(currentType == rhs)\n-            \t\treturn true;\n-            \tif(currentType.getName().equals(rhs.getName()))\n-            \t\treturn true;\n-            \tif (!currentType.isComplexUrType()) // this + else recurse\n-            \t\tcurrentType = currentType.getBaseType();\n-            \telse\n-            \t\treturn false;\n+            while (true) {\n+                if (currentType == rhs) {\n+                    return true;\n+                }\n+                if (currentType.getName().equals(rhs.getName())) {\n+                    return true;\n+                }\n+                if (!currentType.isComplexUrType()) // this + else recurse\n+                {\n+                    currentType = currentType.getBaseType();\n+                } else {\n+                    return false;\n+                }\n             }\n         }\n         // All item types are derived from the Complex Ur-type.\n@@ -2271,21 +2096,26 @@ public final class XMLSchemaConverter\n     private static final BigInteger MAX_INT_SIZE = BigInteger.valueOf(Integer.MAX_VALUE);\n \n     private final ContentType EMPTY_CONTENT = new ContentTypeImpl();\n+\n     private final XMLCycles m_cycles;\n-    \n-\tprivate final Stack<QName> m_complexTypeNameCycles = new Stack<QName>();\n-\tprivate final HashMap<QName,ArrayList<XMLType>> m_lateTypeResolutionMap = new HashMap<QName,ArrayList<XMLType>>();\n-\tprivate final ArrayList<QName> m_lateTypeResolutionNameList = new ArrayList<QName>();\n-\t\n-\t// key = QName of type, value = list of elements to resolve\n-\tprivate final HashMap<QName, ArrayList<LateResolveElement>> m_lateElementResolutionMap = new HashMap<QName, ArrayList<LateResolveElement>>();\n-    \n+\n+    private final Stack<QName> m_complexTypeNameCycles = new Stack<QName>();\n+\n+    private final HashMap<QName, ArrayList<XMLType>> m_lateTypeResolutionMap =\n+        new HashMap<QName, ArrayList<XMLType>>();\n+\n+    private final ArrayList<QName> m_lateTypeResolutionNameList = new ArrayList<QName>();\n+\n+    // key = QName of type, value = list of elements to resolve\n+    private final HashMap<QName, ArrayList<LateResolveElement>> m_lateElementResolutionMap =\n+        new HashMap<QName, ArrayList<LateResolveElement>>();\n+\n \n     private final SchemaExceptionHandler m_errors;\n \n     // things that have already been pushed into the component provider in this parse group\n     private final ComponentProvider m_existingCache;\n-    \n+\n     private final CanonicalAtomBridge m_atoms;\n \n     // this is the collection of components from the xmlrep package.\n@@ -2298,27 +2128,43 @@ public final class XMLSchemaConverter\n     private final ComponentBagImpl m_outBag;\n \n     private final SchemaRegExCompiler regexc;\n-    \n+\n     private final boolean m_lastInWins;\n-    \n+\n     // Used only when m_lastInWins is true\n-    public final Map<QName, ElementDefinition> m_elementsResolvedFromExistingCache = new HashMap<QName, ElementDefinition>();\n-    public final Map<QName, AttributeDefinition> m_attributesResolvedFromExistingCache = new HashMap<QName, AttributeDefinition>();\n+    public final Map<QName, ElementDefinition> m_elementsResolvedFromExistingCache =\n+        new HashMap<QName, ElementDefinition>();\n+\n+    public final Map<QName, AttributeDefinition> m_attributesResolvedFromExistingCache =\n+        new HashMap<QName, AttributeDefinition>();\n+\n     public final Map<QName, Type> m_typesResolvedFromExistingCache = new HashMap<QName, Type>();\n-    public final Map<QName, ModelGroup> m_modelGroupsResolvedFromExistingCache = new HashMap<QName, ModelGroup>();\n-    public final Map<QName, AttributeGroupDefinition> m_attributeGroupsResolvedFromExistingCache = new HashMap<QName, AttributeGroupDefinition>();\n-    public final Map<QName, IdentityConstraint> m_constraintsResolvedFromExistingCache = new HashMap<QName, IdentityConstraint>();\n-    public final Map<QName, NotationDefinition> m_notationsResolvedFromExistingCache = new HashMap<QName, NotationDefinition>();\n-    \n+\n+    public final Map<QName, ModelGroup> m_modelGroupsResolvedFromExistingCache =\n+        new HashMap<QName, ModelGroup>();\n+\n+    public final Map<QName, AttributeGroupDefinition> m_attributeGroupsResolvedFromExistingCache =\n+        new HashMap<QName, AttributeGroupDefinition>();\n+\n+    public final Map<QName, IdentityConstraint> m_constraintsResolvedFromExistingCache =\n+        new HashMap<QName, IdentityConstraint>();\n+\n+    public final Map<QName, NotationDefinition> m_notationsResolvedFromExistingCache =\n+        new HashMap<QName, NotationDefinition>();\n+\n     final class LateResolveElement {\n-    \tpublic LateResolveElement(final XMLElement xmlElement, final ElementDeclTypeImpl elementDecl, final ElementDeclTypeImpl subHead)\n-    \t{\n-    \t\tmi_xmlElement = xmlElement;\n-    \t\tmi_elementDecl = elementDecl;\n-    \t\tmi_subHead = subHead;\n-    \t}\n-    \tfinal XMLElement mi_xmlElement;\n-    \tfinal ElementDeclTypeImpl mi_elementDecl;\n-    \tfinal ElementDeclTypeImpl mi_subHead;\n+        public LateResolveElement(final XMLElement xmlElement,\n+                                  final ElementDeclTypeImpl elementDecl,\n+                                  final ElementDeclTypeImpl subHead) {\n+            mi_xmlElement = xmlElement;\n+            mi_elementDecl = elementDecl;\n+            mi_subHead = subHead;\n+        }\n+\n+        final XMLElement mi_xmlElement;\n+\n+        final ElementDeclTypeImpl mi_elementDecl;\n+\n+        final ElementDeclTypeImpl mi_subHead;\n     }\n }\n",
            "diff_size": 1407
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/493/XMLSchemaConverter.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/codebuff/493/XMLSchemaConverter.java\nindex 790f70021c3..50f2320ede7 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/493/XMLSchemaConverter.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/codebuff/493/XMLSchemaConverter.java\n@@ -27,10 +27,8 @@ import java.util.List;\n import java.util.Map;\n import java.util.Set;\n import java.util.Stack;\n-\n import javax.xml.XMLConstants;\n import javax.xml.namespace.QName;\n-\n import org.genxdm.bridgekit.atoms.XmlAtom;\n import org.genxdm.bridgekit.misc.Pair;\n import org.genxdm.bridgekit.xs.ComponentBagImpl;\n@@ -158,12 +156,10 @@ import org.genxdm.xs.types.UnionSimpleType;\n  * distracting arguments to methods. The use of a static entry point and a private initializer protects against multiple\n  * invocations.\n  */\n+\n public final class XMLSchemaConverter\n {\n-    private XMLSchemaConverter(final SchemaRegExCompiler regexc, final ComponentProvider outCache, \n-                               final XMLSchemaCache inCache, final ComponentBagImpl schema, \n-                               final XMLBidiComponentLocator locations, final SchemaExceptionHandler errors, \n-                               final boolean lastInWins)\n+    private XMLSchemaConverter(final SchemaRegExCompiler regexc, final ComponentProvider outCache, final XMLSchemaCache inCache, final ComponentBagImpl schema, final XMLBidiComponentLocator locations, final SchemaExceptionHandler errors, final boolean lastInWins)\n     {\n         this.regexc = regexc;\n         this.m_existingCache = outCache;\n@@ -183,22 +179,22 @@ public final class XMLSchemaConverter\n             final ComplexType complexBase = (ComplexType)baseType;\n             final SchemaWildcard attributeWildcard = complexBase.getAttributeWildcard();\n             if (attributeWildcard != null)\n-                return attributeWildcard;\n+            return attributeWildcard;\n             else\n-                return null;\n+            return null;\n         }\n         else if (baseType instanceof SimpleType)\n-            return null;\n+        return null;\n         else\n-            throw new AssertionError(baseType);\n+        throw new AssertionError(baseType);\n     }\n \n-    private SchemaWildcard attributeWildcard(final XMLType complexType) \n+    private SchemaWildcard attributeWildcard(final XMLType complexType)\n         throws AbortException, SchemaException\n     {\n         final XMLWildcard localWildcard = complexType.attributeWildcard;\n-\n         final DerivationMethod derivation = complexType.getDerivationMethod();\n+\n         switch (derivation)\n         {\n             case Restriction:\n@@ -226,14 +222,14 @@ public final class XMLSchemaConverter\n         }\n     }\n \n-    private SchemaWildcard attributeWildcard(final XMLTypeRef typeRef) \n+    private SchemaWildcard attributeWildcard(final XMLTypeRef typeRef)\n         throws AbortException, SchemaException\n     {\n         final Type type = convertType(typeRef);\n         return attributeWildcard(type);\n     }\n \n-    private SchemaWildcard completeWildcard(final Iterable<XMLAttributeGroup> attributeGroups, final XMLWildcard localWildcard) \n+    private SchemaWildcard completeWildcard(final Iterable<XMLAttributeGroup> attributeGroups, final XMLWildcard localWildcard)\n         throws AbortException, SchemaException\n     {\n         NamespaceConstraint constraint = null;\n@@ -258,7 +254,6 @@ public final class XMLSchemaConverter\n                 }\n             }\n         }\n-\n         if (constraint == null)\n         {\n             // If nothing is found in the <attributeGroup>[children]...\n@@ -281,7 +276,8 @@ public final class XMLSchemaConverter\n     /**\n      * Expand temporary variables used to hold syntactic constructs for attribute uses and wildcards.\n      */\n-    private Map<QName, AttributeUse> computeAttributeUses(final XMLType complexType, final Map<QName, AttributeUse> attributeUses) \n+\n+    private Map<QName, AttributeUse> computeAttributeUses(final XMLType complexType, final Map<QName, AttributeUse> attributeUses)\n         throws AbortException, SchemaException\n     {\n         for (final XMLAttributeUse attributeUse : complexType.getAttributeUses())\n@@ -299,7 +295,6 @@ public final class XMLSchemaConverter\n                 m_errors.error(e);\n             }\n         }\n-\n         for (final XMLAttributeGroup xmlAttributeGroup : complexType.getAttributeGroups())\n         {\n             final AttributeGroupDefinition attributeGroup = convertAttributeGroup(xmlAttributeGroup);\n@@ -316,7 +311,6 @@ public final class XMLSchemaConverter\n                 }\n             }\n         }\n-\n         switch (complexType.getDerivationMethod())\n         {\n             case Restriction:\n@@ -361,7 +355,6 @@ public final class XMLSchemaConverter\n                 throw new RuntimeException(complexType.getDerivationMethod().name());\n             }\n         }\n-\n         return attributeUses;\n     }\n \n@@ -369,7 +362,8 @@ public final class XMLSchemaConverter\n      * Compile the enumeration facets for this type. <br/>\n      * Enumeration facets are not inherited during compilation, but must be subsets of base types.\n      */\n-    private void computeEnumerations(final SimpleType baseType, final XMLType type, final SimpleTypeImpl target) \n+\n+    private void computeEnumerations(final SimpleType baseType, final XMLType type, final SimpleTypeImpl target)\n         throws AbortException\n     {\n         if (type.getEnumerations().size() > 0)\n@@ -388,7 +382,7 @@ public final class XMLSchemaConverter\n         }\n     }\n \n-    private void computeFacets(final SimpleType baseType, final XMLType type, final SimpleTypeImpl target) \n+    private void computeFacets(final SimpleType baseType, final XMLType type, final SimpleTypeImpl target)\n         throws AbortException, SchemaException\n     {\n         for (final XMLTotalDigitsFacet xmlFacet : type.getTotalDigitsFacets())\n@@ -401,8 +395,7 @@ public final class XMLSchemaConverter\n         }\n         // Note that the length, minLength and maxLength facets are deprecated\n         // for types derived from QName or NOTATION.\n-        if (!subtype(target, m_existingCache.getAtomicType(NativeType.QNAME)) && \n-            !subtype(target, m_existingCache.getAtomicType(NativeType.NOTATION)))\n+        if (!subtype(target, m_existingCache.getAtomicType(NativeType.QNAME)) && !subtype(target, m_existingCache.getAtomicType(NativeType.NOTATION)))\n         {\n             for (final XMLLength xmlFacet : type.getLengthFacets())\n             {\n@@ -425,10 +418,11 @@ public final class XMLSchemaConverter\n         }\n     }\n \n-    private ContentType computeLocallyEmptyContent(final XMLType complexType) \n+    private ContentType computeLocallyEmptyContent(final XMLType complexType)\n         throws SchemaException, AbortException\n     {\n         final DerivationMethod derivation = complexType.getDerivationMethod();\n+\n         switch (derivation)\n         {\n             case Restriction:\n@@ -464,7 +458,8 @@ public final class XMLSchemaConverter\n      * Compile the pattern facets for this type. <br/>\n      * Pattern facets are not inherited during compilation.\n      */\n-    private void computePatterns(final LinkedList<XMLPatternFacet> xmlFacets, final SimpleTypeImpl target) \n+\n+    private void computePatterns(final LinkedList<XMLPatternFacet> xmlFacets, final SimpleTypeImpl target)\n         throws AbortException\n     {\n         if (xmlFacets.size() > 0)\n@@ -521,7 +516,7 @@ public final class XMLSchemaConverter\n         }\n     }\n \n-    private AttributeDefinition convertAttribute(final XMLAttribute xmlAttribute) \n+    private AttributeDefinition convertAttribute(final XMLAttribute xmlAttribute)\n         throws AbortException, SchemaException\n     {\n         final QName name = xmlAttribute.getName();\n@@ -532,29 +527,30 @@ public final class XMLSchemaConverter\n                 return m_outBag.getAttribute(name);\n             if (m_existingCache.hasAttribute(name))\n             {\n-            \tif(!m_lastInWins)\n-            \t{\n-            \t\t// We are not allowing this schema parse to create new elements.  \n+                if (!m_lastInWins)\n+                {\n+                    // We are not allowing this schema parse to create new elements.  \n                     m_inCache.m_attributesUnresolved.remove(name);\n                     return m_existingCache.getAttributeDeclaration(name);\n-            \t}\n-            \telse if(m_inCache.m_attributesUnresolved.containsKey(name) || m_attributesResolvedFromExistingCache.containsKey(name))\n-            \t{\n-            \t\t// This component is a reference which refers to an imported component; otherwise, its name would not be \n-            \t\t// in the m_inCache.m_XxxUnresolved.  When XMLSchemaCache.registerXxx is called, it removes name from m_XxxUnresolved,\n-            \t\t// and registerXxxt is called when XMLSchemaParser encounters a global component, the only components that can be referenced.\n-            \t\t// So, we're going to remove its name from the list, NOT convert it, and return the existing component.\n+                }\n+                else if (m_inCache.m_attributesUnresolved.containsKey(name) || m_attributesResolvedFromExistingCache.containsKey(name))\n+                {\n+                    // This component is a reference which refers to an imported component; otherwise, its name would not be \n+                    // in the m_inCache.m_XxxUnresolved.  When XMLSchemaCache.registerXxx is called, it removes name from m_XxxUnresolved,\n+                    // and registerXxxt is called when XMLSchemaParser encounters a global component, the only components that can be referenced.\n+                    // So, we're going to remove its name from the list, NOT convert it, and return the existing component.\n                     m_inCache.m_attributesUnresolved.remove(name);\n-            \t\tAttributeDefinition existing = m_existingCache.getAttributeDeclaration(name);\n-            \t\tm_attributesResolvedFromExistingCache.put(name, existing);\n+                    AttributeDefinition existing = m_existingCache.getAttributeDeclaration(name);\n+                    m_attributesResolvedFromExistingCache.put(name, existing);\n                     return existing;\n-            \t}\n+                }\n             }\n             if (m_cycles.attributes.contains(xmlAttribute))\n-                throw new SccCyclicAttributeException(name);\n+            throw new SccCyclicAttributeException(name);\n             else\n                 m_cycles.attributes.push(xmlAttribute);\n         }\n+\n         final AttributeDeclTypeImpl attribute;\n         try\n         {\n@@ -569,6 +565,7 @@ public final class XMLSchemaConverter\n             if (scope == ScopeExtent.Global)\n                 m_cycles.attributes.pop();\n         }\n+\n         final Type attributeType = convertType(xmlAttribute.typeRef);\n         if (attributeType instanceof SimpleType)\n             attribute.setType((SimpleType)attributeType);\n@@ -589,7 +586,7 @@ public final class XMLSchemaConverter\n         return attribute;\n     }\n \n-    private AttributeGroupDefinition convertAttributeGroup(final XMLAttributeGroup xmlAttributeGroup) \n+    private AttributeGroupDefinition convertAttributeGroup(final XMLAttributeGroup xmlAttributeGroup)\n         throws AbortException, SchemaException\n     {\n         final QName agName = PreCondition.assertArgumentNotNull(xmlAttributeGroup.getName(), \"name\");\n@@ -600,27 +597,26 @@ public final class XMLSchemaConverter\n                 return m_outBag.getAttributeGroup(agName);\n             if (m_existingCache.hasAttributeGroup(agName))\n             {\n-            \tif (!m_lastInWins)\n-            \t{\n-            \t\t// We are not allowing this schema parse to create new elements.  \n+                if (!m_lastInWins)\n+                {\n+                    // We are not allowing this schema parse to create new elements.  \n                     m_inCache.m_attributeGroupsUnresolved.remove(agName);\n                     return m_existingCache.getAttributeGroup(agName);\n-            \t}\n-            \telse if (m_inCache.m_attributeGroupsUnresolved.containsKey(agName) || \n-            \t         m_attributeGroupsResolvedFromExistingCache.containsKey(agName))\n-            \t{\n-            \t\t// This component is a reference which refers to an imported component; otherwise, its name would not be \n-            \t\t// in the m_inCache.m_XxxUnresolved.  When XMLSchemaCache.registerXxx is called, it removes name from m_XxxUnresolved,\n-            \t\t// and registerXxxt is called when XMLSchemaParser encounters a global component, the only components that can be referenced.\n-            \t\t// So, we're going to remove its name from the list, NOT convert it, and return the existing component.\n+                }\n+                else if (m_inCache.m_attributeGroupsUnresolved.containsKey(agName) || m_attributeGroupsResolvedFromExistingCache.containsKey(agName))\n+                {\n+                    // This component is a reference which refers to an imported component; otherwise, its name would not be \n+                    // in the m_inCache.m_XxxUnresolved.  When XMLSchemaCache.registerXxx is called, it removes name from m_XxxUnresolved,\n+                    // and registerXxxt is called when XMLSchemaParser encounters a global component, the only components that can be referenced.\n+                    // So, we're going to remove its name from the list, NOT convert it, and return the existing component.\n                     m_inCache.m_attributeGroupsUnresolved.remove(agName);\n-            \t\tAttributeGroupDefinition existing = m_existingCache.getAttributeGroup(agName);\n-            \t\tm_attributeGroupsResolvedFromExistingCache.put(agName, existing);\n+                    AttributeGroupDefinition existing = m_existingCache.getAttributeGroup(agName);\n+                    m_attributeGroupsResolvedFromExistingCache.put(agName, existing);\n                     return existing;\n-            \t}\n+                }\n             }\n             if (m_cycles.attributeGroups.contains(xmlAttributeGroup))\n-                throw new SccCyclicAttributeGroupException(xmlAttributeGroup.getName());\n+            throw new SccCyclicAttributeGroupException(xmlAttributeGroup.getName());\n             else\n                 m_cycles.attributeGroups.push(xmlAttributeGroup);\n         }\n@@ -650,10 +646,10 @@ public final class XMLSchemaConverter\n                     m_errors.error(e);\n                 }\n             }\n+\n             final SchemaWildcard completeWildcard = completeWildcard(xmlAttributeGroup.getGroups(), xmlAttributeGroup.wildcard);\n             final AttributeGroupDefinition attributeGroup;\n             attributeGroup = new AttributeGroupImpl(agName, scope, attributeUses.values(), completeWildcard);\n-\n             if (attributeGroup.getScopeExtent() == ScopeExtent.Global)\n                 m_outBag.add(attributeGroup);\n //System.out.println(\"add attribute group \"+agName);\n@@ -668,7 +664,7 @@ public final class XMLSchemaConverter\n         }\n     }\n \n-    private void convertAttributeGroups() \n+    private void convertAttributeGroups()\n         throws AbortException\n     {\n         for (final XMLAttributeGroup source : m_inCache.m_attributeGroups.values())\n@@ -687,7 +683,7 @@ public final class XMLSchemaConverter\n         }\n     }\n \n-    private void convertAttributes() \n+    private void convertAttributes()\n         throws AbortException\n     {\n         for (final XMLAttribute source : m_inCache.m_attributes.values())\n@@ -695,7 +691,6 @@ public final class XMLSchemaConverter\n             try\n             {\n                 QName name = source.getName();\n-                \n                 if (!m_lastInWins && m_existingCache.hasAttribute(name))\n                     m_inCache.m_attributesUnresolved.remove(name);\n                 convertAttribute(source);\n@@ -707,7 +702,7 @@ public final class XMLSchemaConverter\n         }\n     }\n \n-    private AttributeUse convertAttributeUse(final XMLAttributeUse xmlAttributeUse) \n+    private AttributeUse convertAttributeUse(final XMLAttributeUse xmlAttributeUse)\n         throws AbortException, SchemaException\n     {\n         final AttributeDefinition attribute = convertAttribute(xmlAttributeUse.getDeclaration());\n@@ -730,14 +725,15 @@ public final class XMLSchemaConverter\n             else if (attributeType instanceof SimpleUrType)\n             {\n                 // TODO: Do we set the value constraint with xs:untypedAtomic?\n+\n             }\n             else\n-                throw new AssertionError(attributeType);\n+            throw new AssertionError(attributeType);\n         }\n         return attributeUse;\n     }\n \n-    private ComplexType convertComplexType(final QName outName, final boolean isAnonymous, final XMLType xmlComplexType) \n+    private ComplexType convertComplexType(final QName outName, final boolean isAnonymous, final XMLType xmlComplexType)\n         throws AbortException, SchemaException\n     {\n         final ScopeExtent scope = convertScope(xmlComplexType.getScope());\n@@ -747,24 +743,23 @@ public final class XMLSchemaConverter\n                 return m_outBag.getComplexType(outName);\n             if (m_existingCache.hasComplexType(outName))\n             {\n-            \tif (!m_lastInWins)\n-            \t{\n-            \t\t// We are not allowing this schema parse to create new elements.  \n+                if (!m_lastInWins)\n+                {\n+                    // We are not allowing this schema parse to create new elements.  \n                     m_inCache.m_typesUnresolved.remove(outName);\n                     return m_existingCache.getComplexType(outName);\n-            \t}\n-            \telse if (m_inCache.m_typesUnresolved.containsKey(outName) || \n-            \t         m_typesResolvedFromExistingCache.containsKey(outName))\n-            \t{\n-            \t\t// This component is a reference which refers to an imported component; otherwise, its name would not be \n-            \t\t// in the m_inCache.m_XxxUnresolved.  When XMLSchemaCache.registerXxx is called, it removes name from m_XxxUnresolved,\n-            \t\t// and registerXxxt is called when XMLSchemaParser encounters a global component, the only components that can be referenced.\n-            \t\t// So, we're going to remove its name from the list, NOT convert it, and return the existing component.\n+                }\n+                else if (m_inCache.m_typesUnresolved.containsKey(outName) || m_typesResolvedFromExistingCache.containsKey(outName))\n+                {\n+                    // This component is a reference which refers to an imported component; otherwise, its name would not be \n+                    // in the m_inCache.m_XxxUnresolved.  When XMLSchemaCache.registerXxx is called, it removes name from m_XxxUnresolved,\n+                    // and registerXxxt is called when XMLSchemaParser encounters a global component, the only components that can be referenced.\n+                    // So, we're going to remove its name from the list, NOT convert it, and return the existing component.\n                     m_inCache.m_typesUnresolved.remove(outName);\n-            \t\tComplexType existing = m_existingCache.getComplexType(outName);\n-            \t\tm_typesResolvedFromExistingCache.put(outName, existing);\n+                    ComplexType existing = m_existingCache.getComplexType(outName);\n+                    m_typesResolvedFromExistingCache.put(outName, existing);\n                     return existing;\n-            \t}\n+                }\n             }\n             if (m_cycles.types.contains(xmlComplexType))\n                 throw new SmCyclicTypeException(outName);\n@@ -776,36 +771,31 @@ public final class XMLSchemaConverter\n         }\n         try\n         {\n-            final Map<QName, AttributeUse> attributeUses = new HashMap<QName,AttributeUse>();\n+            final Map<QName, AttributeUse> attributeUses = new HashMap<QName, AttributeUse>();\n     \n             // Constructing and registering the complex type allows it to be\n             // referenced in the {content type} property.\n             final ComplexTypeImpl complexType = new ComplexTypeImpl(outName, false, isAnonymous, scope, null, xmlComplexType.getDerivationMethod(), attributeUses, EMPTY_CONTENT, xmlComplexType.getBlock(), m_existingCache.getAtomicType(NativeType.UNTYPED_ATOMIC));\n-            \n             m_outBag.add(complexType);\n //System.out.println(\"add complex type \"+outName);\n             m_locations.m_complexTypeLocations.put(xmlComplexType.getLocation(), complexType);\n-            \n+\n             final Type baseType = convertType(xmlComplexType.getBaseRef());\n             complexType.setBaseType(baseType);\n-            \n             computeAttributeUses(xmlComplexType, attributeUses);\n             complexType.setContentType(convertContentType(xmlComplexType));\n-    \n             complexType.setAbstract(xmlComplexType.isAbstract());\n             complexType.setAttributeWildcard(attributeWildcard(xmlComplexType));\n-    \n             for (final DerivationMethod derivation : xmlComplexType.getBlock())\n             {\n                 complexType.setBlock(derivation, true);\n             }\n-    \n             for (final DerivationMethod derivation : xmlComplexType.getFinal())\n             {\n                 if (derivation.isExtension() || derivation.isRestriction())\n                     complexType.setFinal(derivation, true);\n                 else\n-                    throw new AssertionError(derivation);\n+                throw new AssertionError(derivation);\n             }\n             copyForeignAttributes(xmlComplexType.foreignAttributes, complexType);\n             return complexType;\n@@ -816,12 +806,12 @@ public final class XMLSchemaConverter\n             {\n                 // done constructing; now remove this guy from both cycles\n                 m_cycles.types.pop();\n+\n                 final QName name = m_complexTypeNameCycles.pop();\n                 // If we have any late resolutions to do, make sure we're back at the point of the\n                 // stack where the late resolutions needs to begin; that ensures that the necessary base \n                 // type(s) have been resolved.  (See GXML-45 for relevant use cases.)\n-                if (!m_lateTypeResolutionNameList.isEmpty() &&  \n-                     name.equals(m_lateTypeResolutionNameList.get(0)))\n+                if (!m_lateTypeResolutionNameList.isEmpty() && name.equals(m_lateTypeResolutionNameList.get(0)))\n                 {\n // TODO: dammit, is this right or not? figure it out!\n // i've removed the looping here, and instead pushed it into\n@@ -830,16 +820,16 @@ public final class XMLSchemaConverter\n // but is it **RIGHT??**\n //                    while (!m_lateTypeResolutionNameList.isEmpty())\n //                    {\n-                        lateResolveType(m_lateTypeResolutionNameList.get(0));\n+                    lateResolveType(m_lateTypeResolutionNameList.get(0));\n //                    }\n //                    if (!m_lateTypeResolutionMap.isEmpty())\n //                        throw new IllegalStateException(\"Late type resolution map should be empty, but it is not.\");\n                     // Element type resolution was delayed for all types whose resolution was delayed.\n                     // Those types have been resolved, so now we can resolve the elements.\n                     ArrayList<LateResolveElement> list = m_lateElementResolutionMap.get(name);\n-                    if ((list != null) && !list.isEmpty())\n+                    if ( (list != null) && !list.isEmpty())\n                     {\n-                        for (LateResolveElement lre : list) \n+                        for (LateResolveElement lre : list)\n                         {\n                             convertElementTypeRef(lre.mi_xmlElement, lre.mi_elementDecl, lre.mi_subHead);\n                         }\n@@ -860,34 +850,34 @@ public final class XMLSchemaConverter\n      * @throws SchemaException \n      * @throws AbortException \n      */\n-    private void lateResolveType(final QName typeName) \n+\n+    private void lateResolveType(final QName typeName)\n         throws AbortException, SchemaException\n     {\n-    \t// Get the list of type names which were depending on the incoming type name's resolution.\n-    \tfinal List<XMLType> list = m_lateTypeResolutionMap.get(typeName);\n-    \tm_lateTypeResolutionMap.remove(typeName);\n-    \tm_lateTypeResolutionNameList.remove(typeName);\n-    \tif (list != null)\n-    \t{\n-    \t\t// for each dependent type, attempt to convert it, then\n+        // Get the list of type names which were depending on the incoming type name's resolution.\n+        final List<XMLType> list = m_lateTypeResolutionMap.get(typeName);\n+        m_lateTypeResolutionMap.remove(typeName);\n+        m_lateTypeResolutionNameList.remove(typeName);\n+        if (list != null)\n+        {\n+            // for each dependent type, attempt to convert it, then\n             // recursively invoke this lateResolveType for it (why that order?)\n-    \t    // ah. the order is because invoking lateResolveType(name) removes the\n-    \t    // type from the list, if it does not have a list of dependents.\n-    \t\tfor (final XMLType xmlType : list)\n-    \t\t{\n-    \t\t\tfinal QName lateResolveTypeName = xmlType.getName();\n-    \t\t\tfinal ComplexTypeImpl complexType = (ComplexTypeImpl)m_outBag.getComplexType(lateResolveTypeName);\n-    \t\t\tcomplexType.setContentType(convertContentType(xmlType));\n-    \t\t\tlateResolveType(lateResolveTypeName);\n-    \t\t}\n-    \t}\n-    }\n-\n-    private ContentType convertContentType(final XMLType xmlComplexType) \n+            // ah. the order is because invoking lateResolveType(name) removes the\n+            // type from the list, if it does not have a list of dependents.\n+            for (final XMLType xmlType : list)\n+            {\n+                final QName lateResolveTypeName = xmlType.getName();\n+                final ComplexTypeImpl complexType = (ComplexTypeImpl)m_outBag.getComplexType(lateResolveTypeName);\n+                complexType.setContentType(convertContentType(xmlType));\n+                lateResolveType(lateResolveTypeName);\n+            }\n+        }\n+    }\n+\n+    private ContentType convertContentType(final XMLType xmlComplexType)\n         throws AbortException, SchemaException\n     {\n         final DerivationMethod derivation = xmlComplexType.getDerivationMethod();\n-\n         if (xmlComplexType.m_contentKind.isComplex())\n         {\n             final boolean mixed = xmlComplexType.m_contentKind.isMixed();\n@@ -902,67 +892,67 @@ public final class XMLSchemaConverter\n                         return new ContentTypeImpl(mixed, effectiveContent);\n                     else\n                     {\n-                        if ((effectiveContent.getTerm() == null) || \n-                             effectiveContent.getTerm().getParticles().isEmpty())\n+                        if ((effectiveContent.getTerm() == null) || effectiveContent.getTerm().getParticles().isEmpty())\n                             return EMPTY_CONTENT;\n                         else\n-                            return new ContentTypeImpl(mixed, effectiveContent);\n+                        return new ContentTypeImpl(mixed, effectiveContent);\n                     }\n                 }\n             }\n             else if (derivation.isExtension())\n             {\n-            \t// Is the typeRef (base ref) resolved, yet?  If not, postpone resolution of this type's content.\t\t\t\t\n-            \tfinal QName typeRefName =  xmlComplexType.getBaseRef().getName();\n-            \tif (m_complexTypeNameCycles.contains(typeRefName) || \n-            \t    m_lateTypeResolutionMap.containsKey(typeRefName))\n-            \t{\n-            \t\tArrayList<XMLType> list = m_lateTypeResolutionMap.get(typeRefName);\n-            \t\tif (list == null)\n-            \t\t{\n-            \t\t\tlist = new ArrayList<XMLType>();\n-            \t\t\tm_lateTypeResolutionMap.put(typeRefName, list);\n-            \t\t\tm_lateTypeResolutionNameList.add(typeRefName);\n-            \t\t}\n-            \t\tlist.add(xmlComplexType);\n-            \t\t// Also, add the type to be late resolved as key to late resolution map.  Any components\n-            \t\t// depending on its content model must also wait for resolution.\n-            \t\tif (!m_lateTypeResolutionMap.containsKey(xmlComplexType.getName()))\n-            \t\t{\n-            \t\t\tm_lateTypeResolutionMap.put(xmlComplexType.getName(), null);\n-            \t\t\tm_lateTypeResolutionNameList.add(xmlComplexType.getName());\n-            \t\t}\n-            \t\treturn EMPTY_CONTENT; // actual content to be determined later\n-            \t}\n-            \t// \"typeB\" == base type\n+                // Is the typeRef (base ref) resolved, yet?  If not, postpone resolution of this type's content.                \n+                final QName typeRefName = xmlComplexType.getBaseRef().getName();\n+                if (m_complexTypeNameCycles.contains(typeRefName) || m_lateTypeResolutionMap.containsKey(typeRefName))\n+                {\n+                    ArrayList<XMLType> list = m_lateTypeResolutionMap.get(typeRefName);\n+                    if (list == null)\n+                    {\n+                        list = new ArrayList<XMLType>();\n+                        m_lateTypeResolutionMap.put(typeRefName, list);\n+                        m_lateTypeResolutionNameList.add(typeRefName);\n+                    }\n+                    list.add(xmlComplexType);\n+                    // Also, add the type to be late resolved as key to late resolution map.  Any components\n+                    // depending on its content model must also wait for resolution.\n+                    if (!m_lateTypeResolutionMap.containsKey(xmlComplexType.getName()))\n+                    {\n+                        m_lateTypeResolutionMap.put(xmlComplexType.getName(), null);\n+                        m_lateTypeResolutionNameList.add(xmlComplexType.getName());\n+                    }\n+                    return EMPTY_CONTENT; // actual content to be determined later\n+                }\n+                // \"typeB\" == base type\n+\n                 final Type typeB = convertType(xmlComplexType.getBaseRef());\n                 if (typeB instanceof ComplexType)\n                 {\n                     final ComplexType complexTypeB = (ComplexType)typeB;\n                     final ContentType contentTypeB = complexTypeB.getContentType();\n                     if (effectiveContent == null)\n-                        return contentTypeB;\n+                    return contentTypeB;\n                     else if (contentTypeB.isEmpty())\n-                        return new ContentTypeImpl(mixed, effectiveContent);\n+                    return new ContentTypeImpl(mixed, effectiveContent);\n                     else if (contentTypeB.isSimple())\n-                        throw new SrcBaseContentTypeCannotBeSimpleException(xmlComplexType.getName(), complexTypeB.getName(), xmlComplexType.getLocation());\n+                    throw new SrcBaseContentTypeCannotBeSimpleException(xmlComplexType.getName(), complexTypeB.getName(), xmlComplexType.getLocation());\n                     else if (contentTypeB.isComplex())\n                     {\n                         final LinkedList<ModelGroupUse> particles = new LinkedList<ModelGroupUse>();\n                         particles.add(contentTypeB.getContentModel());\n                         particles.add(effectiveContent);\n+\n                         final ModelGroup modelGroup = new ModelGroupImpl(ModelGroup.SmCompositor.Sequence, particles, null, true, ScopeExtent.Local);\n                         final ModelGroupUse particle = new ParticleWithModelGroupTerm(1, 1, modelGroup);\n                         return new ContentTypeImpl(mixed, particle);\n                     }\n                     else\n-                        throw new AssertionError(contentTypeB.getKind());\n+                    throw new AssertionError(contentTypeB.getKind());\n                 }\n                 else // typeB ! instanceof ComplexType\n-                    throw new SrcBaseTypeMustBeComplexTypeException(xmlComplexType.getLocation());\n+                throw new SrcBaseTypeMustBeComplexTypeException(xmlComplexType.getLocation());\n             }\n             else // derivation !isRestriction() && !isExtension()\n-                throw new AssertionError(derivation);\n+            throw new AssertionError(derivation);\n         }\n         else if (xmlComplexType.m_contentKind.isSimple())\n         {\n@@ -976,9 +966,9 @@ public final class XMLSchemaConverter\n                     if (derivation.isRestriction())\n                         return simpleContent(xmlComplexType.simpleType, contentTypeB.getSimpleType());\n                     else if (derivation.isExtension())\n-                        return contentTypeB;\n+                    return contentTypeB;\n                     else\n-                        throw new AssertionError(derivation);\n+                    throw new AssertionError(derivation);\n                 }\n                 else\n                 {\n@@ -996,38 +986,38 @@ public final class XMLSchemaConverter\n                                     return simpleContent(xmlComplexType.simpleType, simpleBaseType);\n                                 }\n                                 else // no base type\n-                                    throw new SrcSimpleTypeAmongChildrenOfRestrictionException(xmlComplexType.getLocation());\n+                                throw new SrcSimpleTypeAmongChildrenOfRestrictionException(xmlComplexType.getLocation());\n                             }\n                             else // not emptiable\n-                                throw new SrcBaseMustHaveSimpleOrMixedContentTypeComplexTypeException(xmlComplexType.getLocation());\n+                            throw new SrcBaseMustHaveSimpleOrMixedContentTypeComplexTypeException(xmlComplexType.getLocation());\n                         }\n                         else // not mixed\n-                            throw new SrcBaseMustHaveSimpleOrMixedContentTypeComplexTypeException(xmlComplexType.getLocation());\n+                        throw new SrcBaseMustHaveSimpleOrMixedContentTypeComplexTypeException(xmlComplexType.getLocation());\n                     }\n                     else if (derivation.isExtension()) // can't extend a base complex type with simple content into a complex type with simple content (?)\n-                        throw new SrcBaseMustHaveSimpleOrMixedContentTypeComplexTypeException(xmlComplexType.getLocation());\n+                    throw new SrcBaseMustHaveSimpleOrMixedContentTypeComplexTypeException(xmlComplexType.getLocation());\n                     else // not extension or restriction\n-                        throw new AssertionError(derivation);\n+                    throw new AssertionError(derivation);\n                 }\n             }\n             else if (typeB instanceof SimpleType) // derived has simple content kind\n             {\n                 final SimpleType simpleTypeB = (SimpleType)typeB;\n                 if (derivation.isExtension())\n-                    return new ContentTypeImpl(simpleTypeB);\n+                return new ContentTypeImpl(simpleTypeB);\n                 else if (derivation.isRestriction())\n-                    return new ContentTypeImpl(simpleTypeB);\n+                return new ContentTypeImpl(simpleTypeB);\n                 else\n-                    throw new AssertionError(derivation);\n+                throw new AssertionError(derivation);\n             }\n             else // typeB (base type) not instance of ComplexType or SimpleType\n-                throw new AssertionError(typeB);\n+            throw new AssertionError(typeB);\n         }\n         else // xmlComplexType.m_contentKind !complex, !simple, which means empty, apparently, though there isn't an item for empty in the enum\n-            return computeLocallyEmptyContent(xmlComplexType);\n+        return computeLocallyEmptyContent(xmlComplexType);\n     }\n \n-    private ElementDefinition convertElement(final XMLElement xmlElement) \n+    private ElementDefinition convertElement(final XMLElement xmlElement)\n         throws SchemaException, AbortException\n     {\n         final QName name = PreCondition.assertArgumentNotNull(xmlElement.getName(), \"name\");\n@@ -1038,32 +1028,32 @@ public final class XMLSchemaConverter\n                 return m_outBag.getElement(name);\n             if (m_existingCache.hasElement(name))\n             {\n-            \tif (!m_lastInWins)\n-            \t{\n-            \t\t// We are not allowing this schema parse to create new elements.  \n+                if (!m_lastInWins)\n+                {\n+                    // We are not allowing this schema parse to create new elements.  \n                     m_inCache.m_elementsUnresolved.remove(name);\n                     return m_existingCache.getElementDeclaration(name);\n-            \t}\n-            \telse if (m_inCache.m_elementsUnresolved.containsKey(name) || \n-            \t         m_elementsResolvedFromExistingCache.containsKey(name))\n-            \t{\n-            \t\t// This element is a reference which refers to an imported element; otherwise, its name would not be \n-            \t\t// in the m_inCache.m_elementsUnresolved.  When XMLSchemaCache.registerELement is called, it removes name from m_elementsUnresolved,\n-            \t\t// and registerElement is called when XMLSchemaParser encounters a global element, the only elements that can be referenced.\n-            \t\t// So, we're going to remove its name from the list and NOT convert it -- it's just a reference\n+                }\n+                else if (m_inCache.m_elementsUnresolved.containsKey(name) || m_elementsResolvedFromExistingCache.containsKey(name))\n+                {\n+                    // This element is a reference which refers to an imported element; otherwise, its name would not be \n+                    // in the m_inCache.m_elementsUnresolved.  When XMLSchemaCache.registerELement is called, it removes name from m_elementsUnresolved,\n+                    // and registerElement is called when XMLSchemaParser encounters a global element, the only elements that can be referenced.\n+                    // So, we're going to remove its name from the list and NOT convert it -- it's just a reference\n                     m_inCache.m_elementsUnresolved.remove(name);\n-            \t\tElementDefinition existing = m_existingCache.getElementDeclaration(name);\n-            \t\tm_elementsResolvedFromExistingCache.put(name, existing);\n+                    ElementDefinition existing = m_existingCache.getElementDeclaration(name);\n+                    m_elementsResolvedFromExistingCache.put(name, existing);\n                     return existing;\n-            \t}\n+                }\n             }\n             if (m_cycles.elements.contains(xmlElement))\n-                throw new SccCyclicElementException(name);\n+            throw new SccCyclicElementException(name);\n             else\n                 m_cycles.elements.push(xmlElement);\n         }\n+\n         final ElementDeclTypeImpl element;\n-        ElementDeclTypeImpl substitutionGroupHead = null;            \n+        ElementDeclTypeImpl substitutionGroupHead = null;\n         try\n         {\n             PreCondition.assertArgumentNotNull(xmlElement.typeRef, \"{type definition} of \" + name);\n@@ -1073,6 +1063,7 @@ public final class XMLSchemaConverter\n             // {name}, {target namespace} and {scope} are set here. We set the\n             // {type definition} and other\n             // properties outside of the scope for checking cycles.\n+\n             final ComplexUrType anyType = m_existingCache.getComplexUrType();\n             element = new ElementDeclTypeImpl(name, scope, anyType);\n \n@@ -1096,68 +1087,66 @@ public final class XMLSchemaConverter\n             if (scope == ScopeExtent.Global)\n                 m_cycles.elements.pop();\n         }\n-\n         if (element.getScopeExtent() == ScopeExtent.Global)\n             m_outBag.add(element);\n //System.out.println(\"add element \" + name);\n         m_locations.m_elementLocations.put(xmlElement.getLocation(), element);\n \n-\t\t// {type definition}\n-\t\tconvertElementTypeRef(xmlElement, element, substitutionGroupHead);\n-\t\t// {nillable}\n-\t\telement.setNillable(xmlElement.isNillable());\n-\t\t// {disallowed substitutions}\n-\t\tfor (final DerivationMethod derivation : xmlElement.getBlock())\n-\t\t{\n-\t\t\telement.setBlock(derivation, true);\n-\t\t}\n-\t\t// {substitution group exclusions}\n-\t\tfor (final DerivationMethod derivation : xmlElement.getFinal())\n-\t\t{\n-\t\t\telement.setFinal(derivation, true);\n-\t\t}\n-\t\t// {abstract}\n-\t\telement.setAbstract(xmlElement.isAbstract());\n-\t\t// {annotation} we don't care about.\n-\t\t// foreign attributes\n-\t\tcopyForeignAttributes(xmlElement.foreignAttributes, element);\n-\t\t// We're done!\n-\t\treturn element;\n-    }\n-\n-    private void convertElementTypeRef(final XMLElement xmlElement, final ElementDeclTypeImpl element, ElementDeclTypeImpl substitutionGroupHead) \n+        // {type definition}\n+        convertElementTypeRef(xmlElement, element, substitutionGroupHead);\n+        // {nillable}\n+        element.setNillable(xmlElement.isNillable());\n+        // {disallowed substitutions}\n+        for (final DerivationMethod derivation : xmlElement.getBlock())\n+        {\n+            element.setBlock(derivation, true);\n+        }\n+        // {substitution group exclusions}\n+        for (final DerivationMethod derivation : xmlElement.getFinal())\n+        {\n+            element.setFinal(derivation, true);\n+        }\n+        // {abstract}\n+        element.setAbstract(xmlElement.isAbstract());\n+        // {annotation} we don't care about.\n+        // foreign attributes\n+        copyForeignAttributes(xmlElement.foreignAttributes, element);\n+        // We're done!\n+        return element;\n+    }\n+\n+    private void convertElementTypeRef(final XMLElement xmlElement, final ElementDeclTypeImpl element, ElementDeclTypeImpl substitutionGroupHead)\n         throws AbortException, SchemaException\n     {\n-    \t// {type definition}\n-    \t// Is the typeRef resolved, yet?  If not, postpone resolution of this type's content.\t\t\t\t\n-    \tif (xmlElement.typeRef.isGlobal())\n-    \t{\n-    \t\tfinal QName typeRefName = xmlElement.typeRef.getName();\n-    \t\tif (m_complexTypeNameCycles.contains(typeRefName))\n-    \t\t{\n-    \t\t\tArrayList<LateResolveElement> list = m_lateElementResolutionMap.get(typeRefName);\n-    \t\t\tif(list == null) \n-    \t\t\t{\n-    \t\t\t\tlist = new ArrayList<LateResolveElement>();\n-    \t\t\t\tm_lateElementResolutionMap.put(typeRefName, list);\n-    \t\t\t}\n-    \t\t\tlist.add(new LateResolveElement(xmlElement, element, substitutionGroupHead));\n-    \t\t\t// NOTE THE RETURN; look at the conditions\n-    \t\t\treturn;\n-    \t\t}\n-    \t}\n-\n-    \tType typeFromTypeRef = convertType(xmlElement.typeRef);\n-    \t// If the typeFromTypeRef is complexUrType, then it was not set, probably because\n-    \t// the element did not have a type attribute.  So, use the type from the substitutionGroup\n-    \t// head, if possible.\n-    \tif ((substitutionGroupHead != null) && typeFromTypeRef.isComplexUrType()) \n-    \t\ttypeFromTypeRef = substitutionGroupHead.getType();\n-    \telement.setType(typeFromTypeRef);\n-\n-    \t// {value constraint}\n-    \tif (xmlElement.m_valueConstraint != null)\n-    \t{\n+        // {type definition}\n+        // Is the typeRef resolved, yet?  If not, postpone resolution of this type's content.               \n+        if (xmlElement.typeRef.isGlobal())\n+        {\n+            final QName typeRefName = xmlElement.typeRef.getName();\n+            if (m_complexTypeNameCycles.contains(typeRefName))\n+            {\n+                ArrayList<LateResolveElement> list = m_lateElementResolutionMap.get(typeRefName);\n+                if (list == null)\n+                {\n+                    list = new ArrayList<LateResolveElement>();\n+                    m_lateElementResolutionMap.put(typeRefName, list);\n+                }\n+                list.add(new LateResolveElement(xmlElement, element, substitutionGroupHead));\n+                // NOTE THE RETURN; look at the conditions\n+                return;\n+            }\n+        }\n+        Type typeFromTypeRef = convertType(xmlElement.typeRef);\n+        // If the typeFromTypeRef is complexUrType, then it was not set, probably because\n+        // the element did not have a type attribute.  So, use the type from the substitutionGroup\n+        // head, if possible.\n+        if ( (substitutionGroupHead != null) && typeFromTypeRef.isComplexUrType())\n+            typeFromTypeRef = substitutionGroupHead.getType();\n+        element.setType(typeFromTypeRef);\n+\n+        // {value constraint}\n+        if (xmlElement.m_valueConstraint != null)\n+        {\n             if (element.getType() instanceof SimpleType)\n             {\n                 final SimpleType elementType = (SimpleType)element.getType();\n@@ -1188,17 +1177,17 @@ public final class XMLSchemaConverter\n                 }\n                 else\n                 {\n-                  final String initialValue = xmlElement.m_valueConstraint.getValue();\n-                  final SimpleType simpleType = m_existingCache.getSimpleType(NativeType.UNTYPED_ATOMIC);\n-                  element.setValueConstraint(new ValueConstraint(xmlElement.m_valueConstraint.kind, simpleType, initialValue));\n+                    final String initialValue = xmlElement.m_valueConstraint.getValue();\n+                    final SimpleType simpleType = m_existingCache.getSimpleType(NativeType.UNTYPED_ATOMIC);\n+                    element.setValueConstraint(new ValueConstraint(xmlElement.m_valueConstraint.kind, simpleType, initialValue));\n                 }\n             }\n             else\n-                throw new AssertionError(element.getType());\n-\t\t} // value constraint != null\n-\t}\n+            throw new AssertionError(element.getType());\n+        } // value constraint != null\n+    }\n \n-    private void convertElements() \n+    private void convertElements()\n         throws AbortException\n     {\n         for (final XMLElement source : m_inCache.m_elements.values())\n@@ -1218,30 +1207,29 @@ public final class XMLSchemaConverter\n         // Ensure that all elements have their type refs resolved.\n         // Element type resolution was delayed for all types whose resolution was delayed.\n         // Those types have been resolved, so now we can resolve the elements.\n-        for (QName typeName : m_lateElementResolutionMap.keySet()) \n+        for (QName typeName : m_lateElementResolutionMap.keySet())\n         {\n-        \tArrayList<LateResolveElement> list = m_lateElementResolutionMap.get(typeName);\n-        \tfor (LateResolveElement lre : list) \n-        \t{\n-                try \n+            ArrayList<LateResolveElement> list = m_lateElementResolutionMap.get(typeName);\n+            for (LateResolveElement lre : list)\n+            {\n+                try\n                 {\n-                \tconvertElementTypeRef(lre.mi_xmlElement, lre.mi_elementDecl, lre.mi_subHead);\n-                } \n-                catch (SchemaException e) \n+                    convertElementTypeRef(lre.mi_xmlElement, lre.mi_elementDecl, lre.mi_subHead);\n+                }\n+                catch (SchemaException e)\n                 {\n-                \tm_errors.error(e);\n+                    m_errors.error(e);\n                 }\n-        \t}\n+            }\n         }\n         m_lateElementResolutionMap.clear();\n     }\n \n-    private SchemaParticle convertElementUse(final XMLParticleWithElementTerm particle) \n+    private SchemaParticle convertElementUse(final XMLParticleWithElementTerm particle)\n         throws SchemaException, AbortException\n     {\n         final XMLElement xmlElement = particle.getTerm();\n         final ElementDefinition element = convertElement(xmlElement);\n-\n         final ParticleWithElementTerm elementUse;\n         if (isMaxOccursUnbounded(particle.getMaxOccurs()))\n         {\n@@ -1264,18 +1252,20 @@ public final class XMLSchemaConverter\n         return elementUse;\n     }\n \n-    private ValueConstraint convertElementValueConstraint(final XMLValueConstraint xmlValueConstraint, final Type type) \n+    private ValueConstraint convertElementValueConstraint(final XMLValueConstraint xmlValueConstraint, final Type type)\n         throws SchemaException\n     {\n         if (xmlValueConstraint != null)\n         {\n             if (type instanceof SimpleType)\n-                return convertValueConstraint(XMLRepresentation.LN_ELEMENT, xmlValueConstraint, (SimpleType)type);\n+                return convertValueConstraint(XMLRepresentation.LN_ELEMENT,\n+                    xmlValueConstraint,\n+        (SimpleType)type);\n             else if (type instanceof ComplexType)\n             {\n                 final ContentType contentType = ((ComplexType)type).getContentType();\n                 if (contentType.isSimple())\n-                    return convertValueConstraint(XMLRepresentation.LN_ELEMENT, xmlValueConstraint, contentType.getSimpleType());\n+                return convertValueConstraint(XMLRepresentation.LN_ELEMENT, xmlValueConstraint, contentType.getSimpleType());\n                 else\n                 {\n                     final String initialValue = xmlValueConstraint.getValue();\n@@ -1287,7 +1277,7 @@ public final class XMLSchemaConverter\n         return null;\n     }\n \n-    private IdentityConstraint convertIdentityConstraint(final XMLIdentityConstraint xmlConstraint) \n+    private IdentityConstraint convertIdentityConstraint(final XMLIdentityConstraint xmlConstraint)\n         throws SchemaException\n     {\n         final QName name = xmlConstraint.getName();\n@@ -1295,24 +1285,23 @@ public final class XMLSchemaConverter\n             return m_outBag.getIdentityConstraint(name);\n         if (m_existingCache.hasIdentityConstraint(name))\n         {\n-        \tif (!m_lastInWins)\n-        \t{\n-        \t\t// We are not allowing this schema parse to create new elements.  \n+            if (!m_lastInWins)\n+            {\n+                // We are not allowing this schema parse to create new elements.  \n                 m_inCache.m_constraintsUnresolved.remove(name);\n                 return m_existingCache.getIdentityConstraint(name);\n-        \t}\n-        \telse if (m_inCache.m_constraintsUnresolved.containsKey(name) ||\n-        \t         m_constraintsResolvedFromExistingCache.containsKey(name))\n-        \t{\n-        \t\t// This component is a reference which refers to an imported component; otherwise, its name would not be \n-        \t\t// in the m_inCache.m_XxxUnresolved.  When XMLSchemaCache.registerXxx is called, it removes name from m_XxxUnresolved,\n-        \t\t// and registerXxxt is called when XMLSchemaParser encounters a global component, the only components that can be referenced.\n-        \t\t// So, we're going to remove its name from the list, NOT convert it, and return the existing component.\n+            }\n+            else if (m_inCache.m_constraintsUnresolved.containsKey(name) || m_constraintsResolvedFromExistingCache.containsKey(name))\n+            {\n+                // This component is a reference which refers to an imported component; otherwise, its name would not be \n+                // in the m_inCache.m_XxxUnresolved.  When XMLSchemaCache.registerXxx is called, it removes name from m_XxxUnresolved,\n+                // and registerXxxt is called when XMLSchemaParser encounters a global component, the only components that can be referenced.\n+                // So, we're going to remove its name from the list, NOT convert it, and return the existing component.\n                 m_inCache.m_constraintsUnresolved.remove(name);\n-        \t\tIdentityConstraint existing = m_existingCache.getIdentityConstraint(name);\n-        \t\tm_constraintsResolvedFromExistingCache.put(name, existing);\n+                IdentityConstraint existing = m_existingCache.getIdentityConstraint(name);\n+                m_constraintsResolvedFromExistingCache.put(name, existing);\n                 return existing;\n-        \t}\n+            }\n         }\n         if (m_cycles.constraints.contains(xmlConstraint))\n             throw new SccCyclicIdentityConstraintException(name);\n@@ -1343,7 +1332,7 @@ public final class XMLSchemaConverter\n         }\n     }\n \n-    private void convertIdentityConstraints() \n+    private void convertIdentityConstraints()\n         throws AbortException\n     {\n         for (final XMLIdentityConstraint source : m_inCache.m_constraints.values())\n@@ -1362,39 +1351,38 @@ public final class XMLSchemaConverter\n         }\n     }\n \n-    private SimpleType convertItemType(final QName simpleType, final XMLTypeRef typeRef) \n+    private SimpleType convertItemType(final QName simpleType, final XMLTypeRef typeRef)\n         throws AbortException, SchemaException\n     {\n         final Type itemType = convertType(typeRef);\n         if (itemType.isAtomicType())\n-            return (SimpleType)itemType;\n+        return (SimpleType)itemType;\n         else if (itemType instanceof UnionSimpleType)\n-            return (UnionSimpleType)itemType;\n+        return (UnionSimpleType)itemType;\n         throw new SccItemTypeMustBeAtomicOrUnionException(simpleType);\n     }\n \n-    private SimpleType convertMemberType(final QName simpleType, final XMLTypeRef typeRef) \n+    private SimpleType convertMemberType(final QName simpleType, final XMLTypeRef typeRef)\n         throws AbortException, SchemaException\n     {\n         final Type memberType = convertType(typeRef);\n         if (memberType.isAtomicType())\n-            return (SimpleType)memberType;\n+        return (SimpleType)memberType;\n         else if (memberType instanceof ListSimpleType)\n-            return (ListSimpleType)memberType;\n+        return (ListSimpleType)memberType;\n         else if (memberType instanceof UnionSimpleType)\n-        \treturn (UnionSimpleType)memberType;\n+        return (UnionSimpleType)memberType;\n         else if ( (memberType instanceof SimpleType) && memberType.isSimpleUrType())\n-            return (SimpleType)memberType;\n+        return (SimpleType)memberType;\n         throw new SccMemberTypeMustBeAtomicOrListException(simpleType);\n     }\n \n-    private ModelGroup convertModelGroup(final XMLModelGroup xmlModelGroup) \n+    private ModelGroup convertModelGroup(final XMLModelGroup xmlModelGroup)\n         throws AbortException, SchemaException\n     {\n         final ScopeExtent scope = convertScope(xmlModelGroup.getScope());\n         final QName name;\n         final boolean isAnonymous;\n-        \n         if (scope == ScopeExtent.Global)\n         {\n             name = xmlModelGroup.getName();\n@@ -1403,27 +1391,26 @@ public final class XMLSchemaConverter\n                 return m_outBag.getModelGroup(name);\n             if (m_existingCache.hasModelGroup(name))\n             {\n-            \tif (!m_lastInWins)\n-            \t{\n-            \t\t// We are not allowing this schema parse to create new elements.  \n+                if (!m_lastInWins)\n+                {\n+                    // We are not allowing this schema parse to create new elements.  \n                     m_inCache.m_modelGroupsUnresolved.remove(name);\n                     return m_existingCache.getModelGroup(name);\n-            \t}\n-            \telse if(m_inCache.m_modelGroupsUnresolved.containsKey(name) || \n-            \t        m_modelGroupsResolvedFromExistingCache.containsKey(name))\n-            \t{\n-            \t\t// This component is a reference which refers to an imported component; otherwise, its name would not be \n-            \t\t// in the m_inCache.m_XxxUnresolved.  When XMLSchemaCache.registerXxx is called, it removes name from m_XxxUnresolved,\n-            \t\t// and registerXxxt is called when XMLSchemaParser encounters a global component, the only components that can be referenced.\n-            \t\t// So, we're going to remove its name from the list, NOT convert it, and return the existing component.\n+                }\n+                else if (m_inCache.m_modelGroupsUnresolved.containsKey(name) || m_modelGroupsResolvedFromExistingCache.containsKey(name))\n+                {\n+                    // This component is a reference which refers to an imported component; otherwise, its name would not be \n+                    // in the m_inCache.m_XxxUnresolved.  When XMLSchemaCache.registerXxx is called, it removes name from m_XxxUnresolved,\n+                    // and registerXxxt is called when XMLSchemaParser encounters a global component, the only components that can be referenced.\n+                    // So, we're going to remove its name from the list, NOT convert it, and return the existing component.\n                     m_inCache.m_modelGroupsUnresolved.remove(name);\n-            \t\tModelGroup existing = m_existingCache.getModelGroup(name);\n-            \t\tm_modelGroupsResolvedFromExistingCache.put(name, existing);\n+                    ModelGroup existing = m_existingCache.getModelGroup(name);\n+                    m_modelGroupsResolvedFromExistingCache.put(name, existing);\n                     return existing;\n-            \t}\n+                }\n             }\n             if (m_cycles.groups.contains(xmlModelGroup))\n-                throw new SccCyclicModelGroupException(name, xmlModelGroup.getLocation());\n+            throw new SccCyclicModelGroupException(name, xmlModelGroup.getLocation());\n             else\n                 m_cycles.groups.push(xmlModelGroup);\n         }\n@@ -1434,6 +1421,7 @@ public final class XMLSchemaConverter\n         }\n         // Create the model group and add it to m_outBag <em>prior</em> to processing the particles.  This way,\n         // we can exclude the contents of element particles from our modelGroup cycle check.\n+\n         final ModelGroup.SmCompositor compositor = xmlModelGroup.getCompositor();\n         final LinkedList<SchemaParticle> particles = new LinkedList<SchemaParticle>();\n         ModelGroup modelGroup = new ModelGroupImpl(compositor, particles, name, isAnonymous, scope);\n@@ -1442,10 +1430,8 @@ public final class XMLSchemaConverter\n             m_outBag.add(modelGroup);\n //System.out.println(\"add model group\");\n         m_locations.m_modelGroupLocations.put(xmlModelGroup.getLocation(), modelGroup);\n-\n         try\n         {\n-            \n             for (final XMLParticle xmlParticle : xmlModelGroup.getParticles())\n             {\n                 try\n@@ -1454,34 +1440,33 @@ public final class XMLSchemaConverter\n                         particles.add(convertModelGroupUse((XMLParticleWithModelGroupTerm)xmlParticle));\n                     else if (xmlParticle instanceof XMLParticleWithElementTerm)\n                     {\n-                    \t// We must prevent the contents of element particle from becoming part of our invalid cycles check.\n-                    \t// So, we're going to clear the cycles for groups, and then restore it after we finish processing the \n-                    \t// element.  \n+                        // We must prevent the contents of element particle from becoming part of our invalid cycles check.\n+                        // So, we're going to clear the cycles for groups, and then restore it after we finish processing the \n+                        // element.  \n                         Stack<XMLModelGroup> tempGroups = null;\n                         if (!m_cycles.groups.isEmpty())\n                         {\n-                        \ttempGroups = new Stack<XMLModelGroup>();\n-                        \tfor(XMLModelGroup group : m_cycles.groups)\n-                        \t{\n-                        \t\ttempGroups.add(group);\n-                        \t}\n+                            tempGroups = new Stack<XMLModelGroup>();\n+                            for (XMLModelGroup group : m_cycles.groups)\n+                            {\n+                                tempGroups.add(group);\n+                            }\n                             m_cycles.groups.clear();\n                         }\n                         particles.add(convertElementUse((XMLParticleWithElementTerm)xmlParticle));\n                         if (tempGroups != null)\n                         {\n-                        \tm_cycles.groups.clear(); // should be clear, already; so, this line is probably unnecessary\n-                        \tfor(XMLModelGroup group : tempGroups)\n-                        \t{\n-                        \t\tm_cycles.groups.add(group);\n-                        \t}\n+                            m_cycles.groups.clear(); // should be clear, already; so, this line is probably unnecessary\n+                            for (XMLModelGroup group : tempGroups)\n+                            {\n+                                m_cycles.groups.add(group);\n+                            }\n                         }\n                     }\n                     else if (xmlParticle instanceof XMLParticleWithWildcardTerm)\n-                        particles.add(convertWildcardUse((XMLParticleWithWildcardTerm)xmlParticle));\n+                    particles.add(convertWildcardUse((XMLParticleWithWildcardTerm)xmlParticle));\n                     else\n-                        throw new AssertionError(xmlParticle);\n-\n+                    throw new AssertionError(xmlParticle);\n                 } // try block\n                 catch (final SchemaException e)\n                 {\n@@ -1497,7 +1482,7 @@ public final class XMLSchemaConverter\n         }\n     }\n \n-    private void convertModelGroups() \n+    private void convertModelGroups()\n         throws AbortException\n     {\n         for (final XMLModelGroup source : m_inCache.m_modelGroups.values())\n@@ -1516,11 +1501,10 @@ public final class XMLSchemaConverter\n         }\n     }\n \n-    private ModelGroupUse convertModelGroupUse(final XMLParticleWithModelGroupTerm particle) \n+    private ModelGroupUse convertModelGroupUse(final XMLParticleWithModelGroupTerm particle)\n         throws AbortException, SchemaException\n     {\n         final ModelGroup modelGroup = convertModelGroup(particle.getTerm());\n-\n         final ModelGroupUse modelGroupUse;\n         if (isMaxOccursUnbounded(particle.getMaxOccurs()))\n         {\n@@ -1562,14 +1546,14 @@ public final class XMLSchemaConverter\n     private ScopeExtent convertScope(final XMLScope scope)\n     {\n         PreCondition.assertArgumentNotNull(scope, \"scope\");\n-\n         return scope.isGlobal() ? ScopeExtent.Global : ScopeExtent.Local;\n     }\n \n     /**\n      * Applies the Schema Component Constraints to this Simple Type.\n      */\n-    private SimpleType convertSimpleType(final QName name, final boolean isAnonymous, final XMLType xmlSimpleType) \n+\n+    private SimpleType convertSimpleType(final QName name, final boolean isAnonymous, final XMLType xmlSimpleType)\n         throws AbortException, SchemaException\n     {\n         PreCondition.assertTrue(xmlSimpleType.isSimple(), \"expecting a simple type for \" + name);\n@@ -1581,37 +1565,35 @@ public final class XMLSchemaConverter\n                 return m_outBag.getSimpleType(name);\n             if (m_existingCache.hasSimpleType(name))\n             {\n-            \tif (!m_lastInWins)\n-            \t{\n-            \t\t// We are not allowing this schema parse to create new elements.  \n+                if (!m_lastInWins)\n+                {\n+                    // We are not allowing this schema parse to create new elements.  \n                     m_inCache.m_typesUnresolved.remove(name);\n                     return m_existingCache.getSimpleType(name);\n-            \t}\n-            \telse if (m_inCache.m_typesUnresolved.containsKey(name) || \n-            \t         m_typesResolvedFromExistingCache.containsKey(name))\n-            \t{\n-            \t\t// This component is a reference which refers to an imported component; otherwise, its name would not be \n-            \t\t// in the m_inCache.m_XxxUnresolved.  When XMLSchemaCache.registerXxx is called, it removes name from m_XxxUnresolved,\n-            \t\t// and registerXxxt is called when XMLSchemaParser encounters a global component, the only components that can be referenced.\n-            \t\t// So, we're going to remove its name from the list, NOT convert it, and return the existing component.\n+                }\n+                else if (m_inCache.m_typesUnresolved.containsKey(name) || m_typesResolvedFromExistingCache.containsKey(name))\n+                {\n+                    // This component is a reference which refers to an imported component; otherwise, its name would not be \n+                    // in the m_inCache.m_XxxUnresolved.  When XMLSchemaCache.registerXxx is called, it removes name from m_XxxUnresolved,\n+                    // and registerXxxt is called when XMLSchemaParser encounters a global component, the only components that can be referenced.\n+                    // So, we're going to remove its name from the list, NOT convert it, and return the existing component.\n                     m_inCache.m_typesUnresolved.remove(name);\n-            \t\tSimpleType existing = m_existingCache.getSimpleType(name);\n-            \t\tm_typesResolvedFromExistingCache.put(name, existing);\n+                    SimpleType existing = m_existingCache.getSimpleType(name);\n+                    m_typesResolvedFromExistingCache.put(name, existing);\n                     return existing;\n-            \t}\n+                }\n             }\n             if (m_cycles.types.contains(xmlSimpleType))\n                 throw new SmCyclicTypeException(name);\n-\n             m_cycles.types.push(xmlSimpleType);\n         }\n         try\n         {\n             final SimpleType simpleBaseType;\n             if (xmlSimpleType.getBaseRef() != null)\n-                simpleBaseType = convertSimpleTypeBase(name, xmlSimpleType.getBaseRef());\n+            simpleBaseType = convertSimpleTypeBase(name, xmlSimpleType.getBaseRef());\n             else\n-                simpleBaseType = convertSimpleTypeBase(name, xmlSimpleType.getScope().getType().getBaseRef());\n+            simpleBaseType = convertSimpleTypeBase(name, xmlSimpleType.getScope().getType().getBaseRef());\n \n             final SimpleTypeImpl simpleType;\n             final DerivationMethod derivation = PreCondition.assertNotNull(xmlSimpleType.getDerivationMethod(), \"{type definition} with base \" + simpleBaseType.getName());\n@@ -1638,9 +1620,9 @@ public final class XMLSchemaConverter\n                 m_locations.m_simpleTypeLocations.put(xmlSimpleType.getLocation(), simpleType);\n             }\n             else if (derivation.isRestriction())\n-                simpleType = deriveSimpleType(name, isAnonymous, scope, simpleBaseType, whiteSpace, xmlSimpleType.getLocation());\n+            simpleType = deriveSimpleType(name, isAnonymous, scope, simpleBaseType, whiteSpace, xmlSimpleType.getLocation());\n             else\n-                throw new AssertionError(derivation.name());\n+            throw new AssertionError(derivation.name());\n             computePatterns(xmlSimpleType.getPatternFacets(), simpleType);\n             computeFacets(simpleBaseType, xmlSimpleType, simpleType);\n             computeEnumerations(simpleBaseType, xmlSimpleType, simpleType);\n@@ -1654,7 +1636,7 @@ public final class XMLSchemaConverter\n         }\n     }\n \n-    private SimpleType convertSimpleTypeBase(final QName simpleType, final XMLTypeRef baseRef) \n+    private SimpleType convertSimpleTypeBase(final QName simpleType, final XMLTypeRef baseRef)\n         throws AbortException, SchemaException\n     {\n         final Type baseType = convertType(baseRef);\n@@ -1663,7 +1645,7 @@ public final class XMLSchemaConverter\n         throw new SccBaseTypeMustBeSimpleTypeException(simpleType);\n     }\n \n-    private Type convertType(final QName name, final boolean isAnonymous) \n+    private Type convertType(final QName name, final boolean isAnonymous)\n         throws SchemaException, AbortException\n     {\n         // note: as of 2014-2-18, only ever called from convertType(XMLTypeRef) (q.v.)\n@@ -1673,7 +1655,7 @@ public final class XMLSchemaConverter\n         if (m_outBag.hasSimpleType(name))\n             return m_outBag.getSimpleType(name);\n         else if (m_outBag.hasComplexType(name))\n-            return m_outBag.getComplexType(name);\n+        return m_outBag.getComplexType(name);\n         else\n         {\n             // now, we look in the collection of xmlrep components. is it there?\n@@ -1682,12 +1664,12 @@ public final class XMLSchemaConverter\n                 // okay. if it's simple or complex, convert it and return\n                 final XMLType type = m_inCache.m_globalTypes.get(name);\n                 if (type.isSimple())\n-                    return convertSimpleType(name, isAnonymous, type);\n+                return convertSimpleType(name, isAnonymous, type);\n                 else if (type.isComplex())\n-                    return convertComplexType(name, isAnonymous, type);\n+                return convertComplexType(name, isAnonymous, type);\n                 // if not, then it's an unresolved reference. so ... don't ever\n                 // call this method if there's more parsing to be done, eh?\n-                if (m_lastInWins) \n+                if (m_lastInWins)\n                 {\n                     // if operating w/lastInWins true, reference could still be in existing cache\n                     // and we wouldn't have resolved it, yet.  check now.)\n@@ -1721,18 +1703,18 @@ public final class XMLSchemaConverter\n         }\n     }\n \n-    private Type convertType(final QName name, final boolean isAnonymous, final XMLType type) \n+    private Type convertType(final QName name, final boolean isAnonymous, final XMLType type)\n         throws AbortException, SchemaException\n     {\n         if (type.isSimple())\n             return convertSimpleType(name, isAnonymous, type);\n         else if (type.isComplex())\n-            return convertComplexType(name, isAnonymous, type);\n+        return convertComplexType(name, isAnonymous, type);\n         // if it's neither simple nor complex, it's a type reference without a referent\n         throw new SmUndeclaredReferenceException(name, m_inCache.m_typesUnresolved.get(name));\n     }\n \n-    private Type convertType(final XMLTypeRef typeRef) \n+    private Type convertType(final XMLTypeRef typeRef)\n         throws AbortException, SchemaException\n     {\n         if (typeRef.isGlobal())\n@@ -1763,7 +1745,7 @@ public final class XMLSchemaConverter\n         return convertType(m_existingCache.generateUniqueName(), true, typeRef.getLocal());\n     }\n \n-    private void convertTypes() \n+    private void convertTypes()\n         throws AbortException\n     {\n         // we're iterating over all of the global types that haven't been\n@@ -1778,29 +1760,29 @@ public final class XMLSchemaConverter\n             try\n             {\n                 // if this one exists already, do special processing in case lastInWins\n-            \tif (m_existingCache.getComplexType(name) != null || m_existingCache.getSimpleType(name) != null)\n-            \t{\n-            \t    if (!m_lastInWins)\n-            \t        m_inCache.m_typesUnresolved.remove(name);\n-            \t    else\n-            \t    {\n-            \t        // if it's a real type to replace the existing, replace.\n-            \t        if (sourceType.isComplex())\n-            \t            convertComplexType(name, isAnonymous, sourceType);\n+                if (m_existingCache.getComplexType(name) != null || m_existingCache.getSimpleType(name) != null)\n+                {\n+                    if (!m_lastInWins)\n+                        m_inCache.m_typesUnresolved.remove(name);\n+                    else\n+                    {\n+                        // if it's a real type to replace the existing, replace.\n+                        if (sourceType.isComplex())\n+                            convertComplexType(name, isAnonymous, sourceType);\n                         else if (sourceType.isSimple())\n-                            convertSimpleType(name, isAnonymous, sourceType);\n-            \t        // if neither complex nor simple, then it's a ref; remove from unresolved\n+                        convertSimpleType(name, isAnonymous, sourceType);\n+                        // if neither complex nor simple, then it's a ref; remove from unresolved\n                         else\n-                            m_inCache.m_typesUnresolved.remove(name);\n-            \t    }\n-            \t}\n-            \t// otherwise, it's not in the existing cache, so convert\n+                        m_inCache.m_typesUnresolved.remove(name);\n+                    }\n+                }\n+                // otherwise, it's not in the existing cache, so convert\n                 else if (sourceType.isComplex())\n-                    convertComplexType(name, isAnonymous, sourceType);\n+                convertComplexType(name, isAnonymous, sourceType);\n                 else if (sourceType.isSimple())\n-                    convertSimpleType(name, isAnonymous, sourceType);\n+                convertSimpleType(name, isAnonymous, sourceType);\n                 else // this isn't going to work--it's an incomplete type/type reference without a referent\n-                    convertType(name, isAnonymous, sourceType); // let this method throw.\n+                convertType(name, isAnonymous, sourceType); // let this method throw.\n             }\n             catch (final SchemaException e)\n             {\n@@ -1808,33 +1790,33 @@ public final class XMLSchemaConverter\n             }\n         }\n         // do late resolution for all types and for all unresolved elements as well.\n-        try \n+        try\n         {\n             while (!m_lateTypeResolutionNameList.isEmpty())\n             {\n                 lateResolveType(m_lateTypeResolutionNameList.get(0));\n             }\n             if (!m_lateTypeResolutionMap.isEmpty())\n-                throw new IllegalStateException(\"Late type resolution map should be empty, but it is not.\");\n+            throw new IllegalStateException(\"Late type resolution map should be empty, but it is not.\");\n             // do we need to do element resolution? convertElement() is called after convertTypes() in convert()\n             for (ArrayList<LateResolveElement> list : m_lateElementResolutionMap.values())\n             {\n                 if (!list.isEmpty())\n                 {\n-                    for (LateResolveElement lre : list) \n+                    for (LateResolveElement lre : list)\n                     {\n                         convertElementTypeRef(lre.mi_xmlElement, lre.mi_elementDecl, lre.mi_subHead);\n                     }\n                 }\n             }\n         }\n-        catch (SchemaException se) \n-        { \n-            m_errors.error(se); \n+        catch (SchemaException se)\n+        {\n+            m_errors.error(se);\n         }\n     }\n \n-    private ValueConstraint convertValueConstraint(final String elementName, final XMLValueConstraint xmlValueConstraint, final SimpleType simpleType) \n+    private ValueConstraint convertValueConstraint(final String elementName, final XMLValueConstraint xmlValueConstraint, final SimpleType simpleType)\n         throws SchemaException\n     {\n         if (xmlValueConstraint != null)\n@@ -1855,7 +1837,6 @@ public final class XMLSchemaConverter\n                 final SimpleTypeException ste = new SimpleTypeException(initialValue, simpleType, dte, (elementName == null ? null : new QName(elementName)));\n                 throw new SmAttributeUseException(new QName(elementName), xmlValueConstraint.getAttributeName(), xmlValueConstraint.getLocation(), ste);\n             }\n-            \n         }\n         return null;\n     }\n@@ -1867,11 +1848,10 @@ public final class XMLSchemaConverter\n         return null;\n     }\n \n-    private SchemaParticle convertWildcardUse(final XMLParticleWithWildcardTerm particle) \n+    private SchemaParticle convertWildcardUse(final XMLParticleWithWildcardTerm particle)\n         throws SicOversizedIntegerException\n     {\n         final SchemaWildcard wildcard = convertWildcard(particle.getTerm());\n-\n         final WildcardUse wildcardUse;\n         if (isMaxOccursUnbounded(particle.getMaxOccurs()))\n         {\n@@ -1889,7 +1869,7 @@ public final class XMLSchemaConverter\n         return wildcardUse;\n     }\n \n-    private SimpleTypeImpl deriveSimpleType(final QName name, final boolean isAnonymous, final ScopeExtent scope, final SimpleType simpleBaseType, final WhiteSpacePolicy whiteSpace, final SrcFrozenLocation location) \n+    private SimpleTypeImpl deriveSimpleType(final QName name, final boolean isAnonymous, final ScopeExtent scope, final SimpleType simpleBaseType, final WhiteSpacePolicy whiteSpace, final SrcFrozenLocation location)\n         throws SchemaException\n     {\n         final SimpleTypeImpl simpleType;\n@@ -1918,13 +1898,13 @@ public final class XMLSchemaConverter\n             m_locations.m_simpleTypeLocations.put(location, simpleType);\n         }\n         else if (simpleBaseType.isSimpleUrType())\n-            throw new SccBaseTypeMustBeSimpleTypeException(name);\n+        throw new SccBaseTypeMustBeSimpleTypeException(name);\n         else\n-            throw new AssertionError(simpleBaseType.getClass());\n+        throw new AssertionError(simpleBaseType.getClass());\n         return simpleType;\n     }\n \n-    private ModelGroupUse effectiveContent(final boolean mixed, final XMLParticleWithModelGroupTerm contentModel) \n+    private ModelGroupUse effectiveContent(final boolean mixed, final XMLParticleWithModelGroupTerm contentModel)\n         throws AbortException, SchemaException\n     {\n         if (contentModel == null)\n@@ -1940,15 +1920,14 @@ public final class XMLSchemaConverter\n         return convertModelGroupUse(contentModel);\n     }\n \n-    private EnumerationDefinition enumeration(final SimpleType type, final SimpleType baseType, final XMLEnumeration sourceEnum) \n+    private EnumerationDefinition enumeration(final SimpleType type, final SimpleType baseType, final XMLEnumeration sourceEnum)\n         throws SmAttributeUseException\n     {\n         try\n         {\n             final SimpleType notationType = m_existingCache.getAtomicType(NativeType.NOTATION);\n             final FacetEnumerationImpl impl;\n-            if (baseType.getName().equals(notationType.getName()) || \n-                baseType.derivedFromType(notationType, EnumSet.of(DerivationMethod.Restriction)))\n+            if (baseType.getName().equals(notationType.getName()) || baseType.derivedFromType(notationType, EnumSet.of(DerivationMethod.Restriction)))\n             {\n                 final PrefixResolver resolver = sourceEnum.getPrefixResolver();\n                 baseType.validate(sourceEnum.getValue(), resolver, m_atoms);\n@@ -1974,26 +1953,26 @@ public final class XMLSchemaConverter\n         }\n     }\n \n-    private SimpleType extractSimpleType(final XMLTypeRef typeRef) \n+    private SimpleType extractSimpleType(final XMLTypeRef typeRef)\n         throws AbortException, SchemaException\n     {\n         final Type type = convertType(typeRef);\n         if (type instanceof SimpleType)\n-            return (SimpleType)type;\n+        return (SimpleType)type;\n         else if (type instanceof ComplexType)\n         {\n             final ComplexType complexType = (ComplexType)type;\n             final ContentType contentType = complexType.getContentType();\n             if (contentType.isSimple())\n-                return contentType.getSimpleType();\n+            return contentType.getSimpleType();\n             else if (contentType.isMixed())\n-                return contentType.getSimpleType();\n+            return contentType.getSimpleType();\n             throw new AssertionError(contentType.getKind());\n         }\n         throw new AssertionError(type);\n     }\n \n-    private Facet fractionDigits(final XMLFractionDigitsFacet xmlFacet) \n+    private Facet fractionDigits(final XMLFractionDigitsFacet xmlFacet)\n         throws SicOversizedIntegerException\n     {\n         final FacetFractionDigitsImpl impl = new FacetFractionDigitsImpl(getIntValue(xmlFacet.value), xmlFacet.fixed);\n@@ -2010,7 +1989,8 @@ public final class XMLSchemaConverter\n      * @throws SicOversizedIntegerException\n      *             if value is larger than Integer.MAX_VALUE\n      */\n-    private int getIntValue(final BigInteger value) \n+\n+    private int getIntValue(final BigInteger value)\n         throws SicOversizedIntegerException\n     {\n         PreCondition.assertArgumentNotNull(value, \"value\");\n@@ -2019,7 +1999,7 @@ public final class XMLSchemaConverter\n         throw new SicOversizedIntegerException(value);\n     }\n \n-    private Facet length(final XMLLength xmlFacet) \n+    private Facet length(final XMLLength xmlFacet)\n         throws SicOversizedIntegerException\n     {\n         final FacetImpl impl;\n@@ -2030,7 +2010,7 @@ public final class XMLSchemaConverter\n                 if (xmlFacet.minLength.equals(xmlFacet.maxLength))\n                     impl = new FacetLengthImpl(getIntValue(xmlFacet.minLength), xmlFacet.fixed);\n                 else\n-                    throw new AssertionError();\n+                throw new AssertionError();\n             }\n             else\n                 impl = new FacetMinLengthImpl(getIntValue(xmlFacet.minLength), xmlFacet.fixed);\n@@ -2040,7 +2020,7 @@ public final class XMLSchemaConverter\n             if (xmlFacet.maxLength != null)\n                 impl = new FacetMaxLengthImpl(getIntValue(xmlFacet.maxLength), xmlFacet.fixed);\n             else\n-                throw new AssertionError();\n+            throw new AssertionError();\n         }\n         copyForeignAttributes(xmlFacet.foreignAttributes, impl);\n         return impl;\n@@ -2051,9 +2031,8 @@ public final class XMLSchemaConverter\n         PreCondition.assertArgumentNotNull(value, \"value\");\n         PreCondition.assertArgumentNotNull(simpleType, \"simpleType\");\n         PreCondition.assertArgumentNotNull(kind, \"kind\");\n-\n         if (simpleType.isAtomicType())\n-            return new FacetValueCompImpl(value, kind, simpleType, isFixed);\n+        return new FacetValueCompImpl(value, kind, simpleType, isFixed);\n         else if (simpleType instanceof ListSimpleType)\n         {\n             final ListSimpleType listType = (ListSimpleType)simpleType;\n@@ -2065,20 +2044,20 @@ public final class XMLSchemaConverter\n             }\n             else if (itemType instanceof UnionSimpleType)\n                 // is this a TODO? or does the specification forbid lists of unions?\n-                throw new UnsupportedOperationException();\n+            throw new UnsupportedOperationException();\n             else\n                 // The specification forbids lists of lists.\n-                throw new UnsupportedOperationException();\n+            throw new UnsupportedOperationException();\n         }\n         else if (simpleType instanceof UnionSimpleType)\n             // TODO: is a limit on a union forbidden?\n-            throw new UnsupportedOperationException();\n+        throw new UnsupportedOperationException();\n         else\n             // Simple Ur-Type? TODO: no limits?\n-            throw new UnsupportedOperationException();\n+        throw new UnsupportedOperationException();\n     }\n \n-    private Facet minmax(final XMLMinMaxFacet xmlFacet, final SimpleType baseType) \n+    private Facet minmax(final XMLMinMaxFacet xmlFacet, final SimpleType baseType)\n         throws SchemaException\n     {\n         final List<XmlAtom> value;\n@@ -2103,7 +2082,7 @@ public final class XMLSchemaConverter\n         return null;\n     }\n \n-    private Pattern pattern(final XMLPatternFacet pattern) \n+    private Pattern pattern(final XMLPatternFacet pattern)\n         throws SmAttributeUseException\n     {\n         try\n@@ -2125,13 +2104,14 @@ public final class XMLSchemaConverter\n         }\n         catch (final SimpleTypeException ste)\n         {\n-            final QName elementName = new QName(XMLConstants.W3C_XML_SCHEMA_NS_URI, XMLRepresentation.LN_PATTERN);\n+            final QName elementName = new QName(XMLConstants.W3C_XML_SCHEMA_NS_URI,\n+                XMLRepresentation.LN_PATTERN);\n             final QName attributeName = new QName(XMLRepresentation.LN_VALUE);\n             throw new SmAttributeUseException(elementName, attributeName, pattern.getLocation(), ste);\n         }\n     }\n \n-    private ContentType simpleContent(final XMLType simpleType, final SimpleType simpleBaseType) \n+    private ContentType simpleContent(final XMLType simpleType, final SimpleType simpleBaseType)\n         throws AbortException, SchemaException\n     {\n         final QName name;\n@@ -2147,6 +2127,7 @@ public final class XMLSchemaConverter\n             name = m_existingCache.generateUniqueName();\n             isAnonymous = true;\n         }\n+\n         final WhiteSpacePolicy whiteSpace = simpleType.getWhiteSpacePolicy();\n         final SimpleTypeImpl simpleTypeD = deriveSimpleType(name, isAnonymous, scope, simpleBaseType, whiteSpace, simpleType.getLocation());\n         computePatterns(simpleType.getPatternFacets(), simpleTypeD);\n@@ -2155,14 +2136,14 @@ public final class XMLSchemaConverter\n         return new ContentTypeImpl(simpleTypeD);\n     }\n \n-    private Facet totalDigits(final XMLTotalDigitsFacet xmlFacet) \n+    private Facet totalDigits(final XMLTotalDigitsFacet xmlFacet)\n         throws SicOversizedIntegerException\n     {\n         final FacetTotalDigitsImpl impl = new FacetTotalDigitsImpl(getIntValue(xmlFacet.value), xmlFacet.fixed);\n         copyForeignAttributes(xmlFacet.foreignAttributes, impl);\n         return impl;\n     }\n-    \n+\n     private void copyForeignAttributes(FAMap source, ForeignAttributesSink target)\n     {\n         for (QName name : source.keySet())\n@@ -2171,22 +2152,19 @@ public final class XMLSchemaConverter\n         }\n     }\n \n-    public static Pair<ComponentBagImpl, XMLBidiComponentLocator> convert(final SchemaRegExCompiler regexc, final ComponentProvider rtmCache, final XMLSchemaCache xmlCache, final SchemaExceptionHandler errors) \n+    public static Pair<ComponentBagImpl, XMLBidiComponentLocator> convert(final SchemaRegExCompiler regexc, final ComponentProvider rtmCache, final XMLSchemaCache xmlCache, final SchemaExceptionHandler errors)\n         throws AbortException\n     {\n-    \treturn convert(regexc, rtmCache, xmlCache, errors, false);\n+        return convert(regexc, rtmCache, xmlCache, errors, false);\n     }\n-    \n-    public static  Pair<ComponentBagImpl, XMLBidiComponentLocator> convert(final SchemaRegExCompiler regexc, final ComponentProvider rtmCache, final XMLSchemaCache xmlCache, final SchemaExceptionHandler errors, boolean lastInWins) \n+\n+    public static Pair<ComponentBagImpl, XMLBidiComponentLocator> convert(final SchemaRegExCompiler regexc, final ComponentProvider rtmCache, final XMLSchemaCache xmlCache, final SchemaExceptionHandler errors, boolean lastInWins)\n         throws AbortException\n     {\n         final ComponentBagImpl schema = new ComponentBagImpl();\n         final XMLBidiComponentLocator locations = new XMLBidiComponentLocator();\n-\n         final XMLSchemaConverter converter = new XMLSchemaConverter(regexc, rtmCache, xmlCache, schema, locations, errors, lastInWins);\n-\n         xmlCache.computeSubstitutionGroups();\n-\n         converter.convertTypes();\n         converter.convertAttributes();\n         converter.convertElements();\n@@ -2194,17 +2172,15 @@ public final class XMLSchemaConverter\n         converter.convertIdentityConstraints();\n         converter.convertModelGroups();\n         converter.convertNotations();\n-\n         return new Pair<ComponentBagImpl, XMLBidiComponentLocator>(schema, locations);\n     }\n \n-    static boolean isMaxOccursUnbounded(final BigInteger maxOccurs) \n+    static boolean isMaxOccursUnbounded(final BigInteger maxOccurs)\n         throws SicOversizedIntegerException\n     {\n         PreCondition.assertArgumentNotNull(maxOccurs, \"maxOccurs\");\n-\n         if (XMLParticle.UNBOUNDED.equals(maxOccurs))\n-            return true;\n+        return true;\n         else\n         {\n             if (MAX_INT_SIZE.compareTo(maxOccurs) < 0)\n@@ -2213,13 +2189,12 @@ public final class XMLSchemaConverter\n         }\n     }\n \n-    static int maxOccurs(final BigInteger maxOccurs) \n+    static int maxOccurs(final BigInteger maxOccurs)\n         throws SicOversizedIntegerException\n     {\n         PreCondition.assertArgumentNotNull(maxOccurs, \"maxOccurs\");\n-\n         if (XMLParticle.UNBOUNDED.equals(maxOccurs))\n-            throw new IllegalStateException(\"maxOccurs is unbounded\");\n+        throw new IllegalStateException(\"maxOccurs is unbounded\");\n         else\n         {\n             if (MAX_INT_SIZE.compareTo(maxOccurs) < 0)\n@@ -2228,12 +2203,12 @@ public final class XMLSchemaConverter\n         }\n     }\n \n-    static int minOccurs(final BigInteger minOccurs) \n+    static int minOccurs(final BigInteger minOccurs)\n         throws SicOversizedIntegerException\n     {\n         PreCondition.assertArgumentNotNull(minOccurs, \"minOccurs\");\n         if (MAX_INT_SIZE.compareTo(minOccurs) < 0)\n-            throw new SicOversizedIntegerException(minOccurs);\n+        throw new SicOversizedIntegerException(minOccurs);\n         else\n         {\n             PreCondition.assertTrue(minOccurs.compareTo(BigInteger.ZERO) >= 0, \"minOccurs >= 0\");\n@@ -2250,14 +2225,14 @@ public final class XMLSchemaConverter\n             Type currentType = lhs;\n             while (true)\n             {\n-            \tif(currentType == rhs)\n-            \t\treturn true;\n-            \tif(currentType.getName().equals(rhs.getName()))\n-            \t\treturn true;\n-            \tif (!currentType.isComplexUrType()) // this + else recurse\n-            \t\tcurrentType = currentType.getBaseType();\n-            \telse\n-            \t\treturn false;\n+                if (currentType == rhs)\n+                    return true;\n+                if (currentType.getName().equals(rhs.getName()))\n+                    return true;\n+                if (!currentType.isComplexUrType()) // this + else recurse\n+                    currentType = currentType.getBaseType();\n+                else\n+                return false;\n             }\n         }\n         // All item types are derived from the Complex Ur-type.\n@@ -2268,37 +2243,30 @@ public final class XMLSchemaConverter\n      * Integer.MAX_VALUE as a BigInteger; needed to ensure that we throw an exception rather than attempt to convert\n      * BigInteger values larger than Integer.MAX_VALUE.\n      */\n-    private static final BigInteger MAX_INT_SIZE = BigInteger.valueOf(Integer.MAX_VALUE);\n \n+    private static final BigInteger MAX_INT_SIZE = BigInteger.valueOf(Integer.MAX_VALUE);\n     private final ContentType EMPTY_CONTENT = new ContentTypeImpl();\n     private final XMLCycles m_cycles;\n+    private final Stack<QName> m_complexTypeNameCycles = new Stack<QName>();\n+    private final HashMap<QName, ArrayList<XMLType>> m_lateTypeResolutionMap = new HashMap<QName, ArrayList<XMLType>>();\n+    private final ArrayList<QName> m_lateTypeResolutionNameList = new ArrayList<QName>();\n     \n-\tprivate final Stack<QName> m_complexTypeNameCycles = new Stack<QName>();\n-\tprivate final HashMap<QName,ArrayList<XMLType>> m_lateTypeResolutionMap = new HashMap<QName,ArrayList<XMLType>>();\n-\tprivate final ArrayList<QName> m_lateTypeResolutionNameList = new ArrayList<QName>();\n-\t\n-\t// key = QName of type, value = list of elements to resolve\n-\tprivate final HashMap<QName, ArrayList<LateResolveElement>> m_lateElementResolutionMap = new HashMap<QName, ArrayList<LateResolveElement>>();\n-    \n-\n+    // key = QName of type, value = list of elements to resolve\n+    private final HashMap<QName, ArrayList<LateResolveElement>> m_lateElementResolutionMap = new HashMap<QName, ArrayList<LateResolveElement>>();\n     private final SchemaExceptionHandler m_errors;\n \n     // things that have already been pushed into the component provider in this parse group\n     private final ComponentProvider m_existingCache;\n-    \n     private final CanonicalAtomBridge m_atoms;\n \n     // this is the collection of components from the xmlrep package.\n     // it needs to be empty when we're done.\n     private final XMLSchemaCache m_inCache;\n-\n     private final XMLBidiComponentLocator m_locations;\n \n     // this is what we'll return\n     private final ComponentBagImpl m_outBag;\n-\n     private final SchemaRegExCompiler regexc;\n-    \n     private final boolean m_lastInWins;\n     \n     // Used only when m_lastInWins is true\n@@ -2309,16 +2277,20 @@ public final class XMLSchemaConverter\n     public final Map<QName, AttributeGroupDefinition> m_attributeGroupsResolvedFromExistingCache = new HashMap<QName, AttributeGroupDefinition>();\n     public final Map<QName, IdentityConstraint> m_constraintsResolvedFromExistingCache = new HashMap<QName, IdentityConstraint>();\n     public final Map<QName, NotationDefinition> m_notationsResolvedFromExistingCache = new HashMap<QName, NotationDefinition>();\n-    \n-    final class LateResolveElement {\n-    \tpublic LateResolveElement(final XMLElement xmlElement, final ElementDeclTypeImpl elementDecl, final ElementDeclTypeImpl subHead)\n-    \t{\n-    \t\tmi_xmlElement = xmlElement;\n-    \t\tmi_elementDecl = elementDecl;\n-    \t\tmi_subHead = subHead;\n-    \t}\n-    \tfinal XMLElement mi_xmlElement;\n-    \tfinal ElementDeclTypeImpl mi_elementDecl;\n-    \tfinal ElementDeclTypeImpl mi_subHead;\n-    }\n-}\n+\n+    final class LateResolveElement\n+    {\n+        public LateResolveElement(final XMLElement xmlElement, final ElementDeclTypeImpl elementDecl, final ElementDeclTypeImpl subHead)\n+        {\n+            mi_xmlElement = xmlElement;\n+            mi_elementDecl = elementDecl;\n+            mi_subHead = subHead;\n+        }\n+\n+        final XMLElement mi_xmlElement;\n+\n+        final ElementDeclTypeImpl mi_elementDecl;\n+\n+        final ElementDeclTypeImpl mi_subHead;\n+    }\n+}\n\\ No newline at end of file\n",
            "diff_size": 479
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "536",
                    "column": "13",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/493/XMLSchemaConverter.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_random/493/XMLSchemaConverter.java\nindex 790f70021c3..9b99606b2f1 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/493/XMLSchemaConverter.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_random/493/XMLSchemaConverter.java\n@@ -532,7 +532,7 @@ public final class XMLSchemaConverter\n                 return m_outBag.getAttribute(name);\n             if (m_existingCache.hasAttribute(name))\n             {\n-            \tif(!m_lastInWins)\n+            if(!m_lastInWins)\n             \t{\n             \t\t// We are not allowing this schema parse to create new elements.  \n                     m_inCache.m_attributesUnresolved.remove(name);\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "536",
                    "column": "13",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/493/XMLSchemaConverter.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_three_grams/493/XMLSchemaConverter.java\nindex 790f70021c3..192ad91a0da 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/493/XMLSchemaConverter.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_three_grams/493/XMLSchemaConverter.java\n@@ -532,7 +532,7 @@ public final class XMLSchemaConverter\n                 return m_outBag.getAttribute(name);\n             if (m_existingCache.hasAttribute(name))\n             {\n-            \tif(!m_lastInWins)\n+                if(!m_lastInWins)\n             \t{\n             \t\t// We are not allowing this schema parse to create new elements.  \n                     m_inCache.m_attributesUnresolved.remove(name);\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "intellij",
        "codebuff"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "styler_random",
        "styler_three_grams"
    ]
}