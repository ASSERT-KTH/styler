{
    "project_name": "apache-ignite-3",
    "error_id": "56",
    "information": {
        "errors": [
            {
                "line": "126",
                "column": "22",
                "severity": "error",
                "message": "'{' is not preceded with whitespace.",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
            }
        ]
    },
    "source_code": "\n    /** */\n    private Commons(){}\n\n    /**\n     * Combines two lists.",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/errored/1/56/Commons.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/styler/56/Commons.java\nindex 31e9a74950d..2426406bf96 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/errored/1/56/Commons.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/styler/56/Commons.java\n@@ -123,7 +123,7 @@ public final class Commons {\n         .build();\n \n     /** */\n-    private Commons(){}\n+    private Commons() {}\n \n     /**\n      * Combines two lists.\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/errored/1/56/Commons.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/intellij/56/Commons.java\nindex 31e9a74950d..fede7f9e505 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/errored/1/56/Commons.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/intellij/56/Commons.java\n@@ -78,181 +78,194 @@ import static org.apache.ignite.internal.util.CollectionUtils.nullOrEmpty;\n  * Utility methods.\n  */\n public final class Commons {\n-    /** */\n-    public static final int IN_BUFFER_SIZE = 512;\n-\n-    /** */\n-    public static final FrameworkConfig FRAMEWORK_CONFIG = Frameworks.newConfigBuilder()\n-        .executor(EXECUTOR)\n-        .sqlToRelConverterConfig(SqlToRelConverter.config()\n-            .withTrimUnusedFields(true)\n-            // currently SqlToRelConverter creates not optimal plan for both optimization and execution\n-            // so it's better to disable such rewriting right now\n-            // TODO: remove this after IGNITE-14277\n-            .withInSubQueryThreshold(Integer.MAX_VALUE)\n-            .withDecorrelationEnabled(true)\n-            .withHintStrategyTable(\n-                HintStrategyTable.builder()\n-                    .hintStrategy(\"DISABLE_RULE\", (hint, rel) -> true)\n-                    .hintStrategy(\"EXPAND_DISTINCT_AGG\", (hint, rel) -> rel instanceof Aggregate)\n-                    .build()\n-            )\n-        )\n-        .parserConfig(\n-            SqlParser.config()\n-                .withParserFactory(IgniteSqlParserImpl.FACTORY)\n-                .withLex(Lex.ORACLE)\n-                .withConformance(SqlConformanceEnum.DEFAULT))\n-        .sqlValidatorConfig(SqlValidator.Config.DEFAULT\n-            .withIdentifierExpansion(true)\n-            .withSqlConformance(SqlConformanceEnum.DEFAULT))\n-        // Dialects support.\n-        .operatorTable(SqlOperatorTables.chain(\n-            SqlLibraryOperatorTableFactory.INSTANCE\n-                .getOperatorTable(\n-                    SqlLibrary.STANDARD,\n-                    SqlLibrary.POSTGRESQL,\n-                    SqlLibrary.ORACLE,\n-                    SqlLibrary.MYSQL),\n-            IgniteSqlOperatorTable.instance()))\n-        // Context provides a way to store data within the planner session that can be accessed in planner rules.\n-        .context(Contexts.empty())\n-        // Custom cost factory to use during optimization\n-        .costFactory(new IgniteCostFactory())\n-        .typeSystem(IgniteTypeSystem.INSTANCE)\n-        .build();\n-\n-    /** */\n-    private Commons(){}\n-\n-    /**\n-     * Combines two lists.\n-     */\n-    public static <T> List<T> combine(List<T> left, List<T> right) {\n-        Set<T> set = new HashSet<>(left.size() + right.size());\n-\n-        set.addAll(left);\n-        set.addAll(right);\n-\n-        return new ArrayList<>(set);\n+  /**\n+   *\n+   */\n+  public static final int IN_BUFFER_SIZE = 512;\n+\n+  /**\n+   *\n+   */\n+  public static final FrameworkConfig FRAMEWORK_CONFIG = Frameworks.newConfigBuilder()\n+      .executor(EXECUTOR)\n+      .sqlToRelConverterConfig(SqlToRelConverter.config()\n+          .withTrimUnusedFields(true)\n+          // currently SqlToRelConverter creates not optimal plan for both optimization and execution\n+          // so it's better to disable such rewriting right now\n+          // TODO: remove this after IGNITE-14277\n+          .withInSubQueryThreshold(Integer.MAX_VALUE)\n+          .withDecorrelationEnabled(true)\n+          .withHintStrategyTable(\n+              HintStrategyTable.builder()\n+                  .hintStrategy(\"DISABLE_RULE\", (hint, rel) -> true)\n+                  .hintStrategy(\"EXPAND_DISTINCT_AGG\", (hint, rel) -> rel instanceof Aggregate)\n+                  .build()\n+          )\n+      )\n+      .parserConfig(\n+          SqlParser.config()\n+              .withParserFactory(IgniteSqlParserImpl.FACTORY)\n+              .withLex(Lex.ORACLE)\n+              .withConformance(SqlConformanceEnum.DEFAULT))\n+      .sqlValidatorConfig(SqlValidator.Config.DEFAULT\n+          .withIdentifierExpansion(true)\n+          .withSqlConformance(SqlConformanceEnum.DEFAULT))\n+      // Dialects support.\n+      .operatorTable(SqlOperatorTables.chain(\n+          SqlLibraryOperatorTableFactory.INSTANCE\n+              .getOperatorTable(\n+                  SqlLibrary.STANDARD,\n+                  SqlLibrary.POSTGRESQL,\n+                  SqlLibrary.ORACLE,\n+                  SqlLibrary.MYSQL),\n+          IgniteSqlOperatorTable.instance()))\n+      // Context provides a way to store data within the planner session that can be accessed in planner rules.\n+      .context(Contexts.empty())\n+      // Custom cost factory to use during optimization\n+      .costFactory(new IgniteCostFactory())\n+      .typeSystem(IgniteTypeSystem.INSTANCE)\n+      .build();\n+\n+  /**\n+   *\n+   */\n+  private Commons() {\n+  }\n+\n+  /**\n+   * Combines two lists.\n+   */\n+  public static <T> List<T> combine(List<T> left, List<T> right) {\n+    Set<T> set = new HashSet<>(left.size() + right.size());\n+\n+    set.addAll(left);\n+    set.addAll(right);\n+\n+    return new ArrayList<>(set);\n+  }\n+\n+  /**\n+   * Intersects two lists.\n+   */\n+  public static <T> List<T> intersect(List<T> left, List<T> right) {\n+    if (nullOrEmpty(left) || nullOrEmpty(right)) {\n+      return Collections.emptyList();\n     }\n \n-    /**\n-     * Intersects two lists.\n-     */\n-    public static <T> List<T> intersect(List<T> left, List<T> right) {\n-        if (nullOrEmpty(left) || nullOrEmpty(right))\n-            return Collections.emptyList();\n-\n-        return left.size() > right.size()\n-            ? intersect(new HashSet<>(right), left)\n-            : intersect(new HashSet<>(left), right);\n-    }\n-\n-    /**\n-     * Intersects a set and a list.\n-     *\n-     * @return A List of unique entries that presented in both the given set and the given list.\n-     */\n-    public static <T> List<T> intersect(Set<T> set, List<T> list) {\n-        if (nullOrEmpty(set) || nullOrEmpty(list))\n-            return Collections.emptyList();\n-\n-        return list.stream()\n-            .filter(set::contains)\n-            .collect(Collectors.toList());\n-    }\n-\n-    /**\n-     * Returns a given list as a typed list.\n-     */\n-    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n-    public static <T> List<T> cast(List<?> src) {\n-        return (List)src;\n-    }\n-\n-    /**\n-     * Transforms a given list using map function.\n-     */\n-    public static <T, R> List<R> transform(@NotNull List<T> src, @NotNull Function<T, R> mapFun) {\n-        if (nullOrEmpty(src))\n-            return Collections.emptyList();\n-\n-        List<R> list = new ArrayList<>(src.size());\n-\n-        for (T t : src)\n-            list.add(mapFun.apply(t));\n-\n-        return list;\n-    }\n-\n-    /**\n-     * Extracts type factory.\n-     */\n-    public static IgniteTypeFactory typeFactory(RelNode rel) {\n-        return typeFactory(rel.getCluster());\n-    }\n-\n-    /**\n-     * Extracts type factory.\n-     */\n-    public static IgniteTypeFactory typeFactory(RelOptCluster cluster) {\n-        return (IgniteTypeFactory)cluster.getTypeFactory();\n-    }\n-\n-    /**\n-     * Extracts planner context.\n-     */\n-    public static PlanningContext context(RelNode rel) {\n-        return context(rel.getCluster());\n+    return left.size() > right.size()\n+        ? intersect(new HashSet<>(right), left)\n+        : intersect(new HashSet<>(left), right);\n+  }\n+\n+  /**\n+   * Intersects a set and a list.\n+   *\n+   * @return A List of unique entries that presented in both the given set and the given list.\n+   */\n+  public static <T> List<T> intersect(Set<T> set, List<T> list) {\n+    if (nullOrEmpty(set) || nullOrEmpty(list)) {\n+      return Collections.emptyList();\n     }\n \n-    /**\n-     * Extracts planner context.\n-     */\n-    public static PlanningContext context(RelOptCluster cluster) {\n-        return context(cluster.getPlanner().getContext());\n+    return list.stream()\n+        .filter(set::contains)\n+        .collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Returns a given list as a typed list.\n+   */\n+  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n+  public static <T> List<T> cast(List<?> src) {\n+    return (List) src;\n+  }\n+\n+  /**\n+   * Transforms a given list using map function.\n+   */\n+  public static <T, R> List<R> transform(@NotNull List<T> src, @NotNull Function<T, R> mapFun) {\n+    if (nullOrEmpty(src)) {\n+      return Collections.emptyList();\n     }\n \n-    /**\n-     * Extracts planner context.\n-     */\n-    public static PlanningContext context(Context ctx) {\n-        return Objects.requireNonNull(ctx.unwrap(PlanningContext.class));\n-    }\n-\n-    /**\n-     * @param params Parameters.\n-     * @return Parameters map.\n-     */\n-    public static Map<String, Object> parametersMap(@Nullable Object[] params) {\n-        HashMap<String, Object> res = new HashMap<>();\n+    List<R> list = new ArrayList<>(src.size());\n \n-        return params != null ? populateParameters(res, params) : res;\n+    for (T t : src) {\n+      list.add(mapFun.apply(t));\n     }\n \n-    /**\n-     * Populates a provided map with given parameters.\n-     *\n-     * @param dst Map to populate.\n-     * @param params Parameters.\n-     * @return Parameters map.\n-     */\n-    public static Map<String, Object> populateParameters(@NotNull Map<String, Object> dst, @Nullable Object[] params) {\n-        if (!ArrayUtils.nullOrEmpty(params)) {\n-            for (int i = 0; i < params.length; i++)\n-                dst.put(\"?\" + i, params[i]);\n-        }\n-        return dst;\n+    return list;\n+  }\n+\n+  /**\n+   * Extracts type factory.\n+   */\n+  public static IgniteTypeFactory typeFactory(RelNode rel) {\n+    return typeFactory(rel.getCluster());\n+  }\n+\n+  /**\n+   * Extracts type factory.\n+   */\n+  public static IgniteTypeFactory typeFactory(RelOptCluster cluster) {\n+    return (IgniteTypeFactory) cluster.getTypeFactory();\n+  }\n+\n+  /**\n+   * Extracts planner context.\n+   */\n+  public static PlanningContext context(RelNode rel) {\n+    return context(rel.getCluster());\n+  }\n+\n+  /**\n+   * Extracts planner context.\n+   */\n+  public static PlanningContext context(RelOptCluster cluster) {\n+    return context(cluster.getPlanner().getContext());\n+  }\n+\n+  /**\n+   * Extracts planner context.\n+   */\n+  public static PlanningContext context(Context ctx) {\n+    return Objects.requireNonNull(ctx.unwrap(PlanningContext.class));\n+  }\n+\n+  /**\n+   * @param params Parameters.\n+   * @return Parameters map.\n+   */\n+  public static Map<String, Object> parametersMap(@Nullable Object[] params) {\n+    HashMap<String, Object> res = new HashMap<>();\n+\n+    return params != null ? populateParameters(res, params) : res;\n+  }\n+\n+  /**\n+   * Populates a provided map with given parameters.\n+   *\n+   * @param dst    Map to populate.\n+   * @param params Parameters.\n+   * @return Parameters map.\n+   */\n+  public static Map<String, Object> populateParameters(@NotNull Map<String, Object> dst, @Nullable Object[] params) {\n+    if (!ArrayUtils.nullOrEmpty(params)) {\n+      for (int i = 0; i < params.length; i++) {\n+        dst.put(\"?\" + i, params[i]);\n+      }\n     }\n-\n-    /**\n-     * @param o Object to close.\n-     */\n-    public static void close(Object o) throws Exception {\n-        if (o instanceof AutoCloseable)\n-            ((AutoCloseable) o).close();\n+    return dst;\n+  }\n+\n+  /**\n+   * @param o Object to close.\n+   */\n+  public static void close(Object o) throws Exception {\n+    if (o instanceof AutoCloseable) {\n+      ((AutoCloseable) o).close();\n     }\n+  }\n \n //    /**\n //     * @param o Object to close.\n@@ -270,180 +283,214 @@ public final class Commons {\n //            U.closeQuiet((AutoCloseable) o);\n //    }\n \n-    /** */\n-    public static <T> List<T> flat(List<List<? extends T>> src) {\n-        return src.stream().flatMap(List::stream).collect(Collectors.toList());\n+  /**\n+   *\n+   */\n+  public static <T> List<T> flat(List<List<? extends T>> src) {\n+    return src.stream().flatMap(List::stream).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   *\n+   */\n+  public static int max(ImmutableIntList list) {\n+    if (list.isEmpty()) {\n+      throw new UnsupportedOperationException();\n     }\n \n-    /** */\n-    public static int max(ImmutableIntList list) {\n-        if (list.isEmpty())\n-            throw new UnsupportedOperationException();\n-\n-        int res = list.getInt(0);\n+    int res = list.getInt(0);\n \n-        for (int i = 1; i < list.size(); i++)\n-            res = Math.max(res, list.getInt(i));\n-\n-        return res;\n+    for (int i = 1; i < list.size(); i++) {\n+      res = Math.max(res, list.getInt(i));\n     }\n \n-    /** */\n-    public static int min(ImmutableIntList list) {\n-        if (list.isEmpty())\n-            throw new UnsupportedOperationException();\n+    return res;\n+  }\n \n-        int res = list.getInt(0);\n+  /**\n+   *\n+   */\n+  public static int min(ImmutableIntList list) {\n+    if (list.isEmpty()) {\n+      throw new UnsupportedOperationException();\n+    }\n \n-        for (int i = 1; i < list.size(); i++)\n-            res = Math.min(res, list.getInt(i));\n+    int res = list.getInt(0);\n \n-        return res;\n+    for (int i = 1; i < list.size(); i++) {\n+      res = Math.min(res, list.getInt(i));\n     }\n \n-    /** */\n-    public static <T> T compile(Class<T> interfaceType, String body) {\n-        final boolean debug = CalciteSystemProperty.DEBUG.value();\n+    return res;\n+  }\n \n-        if (debug)\n-            Util.debugCode(System.out, body);\n+  /**\n+   *\n+   */\n+  public static <T> T compile(Class<T> interfaceType, String body) {\n+    final boolean debug = CalciteSystemProperty.DEBUG.value();\n \n-        try {\n-            final ICompilerFactory compilerFactory;\n+    if (debug) {\n+      Util.debugCode(System.out, body);\n+    }\n \n-            try {\n-                compilerFactory = CompilerFactoryFactory.getDefaultCompilerFactory();\n-            } catch (Exception e) {\n-                throw new IllegalStateException(\n-                    \"Unable to instantiate java compiler\", e);\n-            }\n+    try {\n+      final ICompilerFactory compilerFactory;\n \n-            IClassBodyEvaluator cbe = compilerFactory.newClassBodyEvaluator();\n+      try {\n+        compilerFactory = CompilerFactoryFactory.getDefaultCompilerFactory();\n+      } catch (Exception e) {\n+        throw new IllegalStateException(\n+            \"Unable to instantiate java compiler\", e);\n+      }\n \n-            cbe.setImplementedInterfaces(new Class[]{ interfaceType });\n-            cbe.setParentClassLoader(ExpressionFactoryImpl.class.getClassLoader());\n+      IClassBodyEvaluator cbe = compilerFactory.newClassBodyEvaluator();\n \n-            if (debug)\n-                // Add line numbers to the generated janino class\n-                cbe.setDebuggingInformation(true, true, true);\n+      cbe.setImplementedInterfaces(new Class[] {interfaceType});\n+      cbe.setParentClassLoader(ExpressionFactoryImpl.class.getClassLoader());\n \n-            return (T) cbe.createInstance(new StringReader(body));\n-        } catch (Exception e) {\n-            throw new IgniteException(e);\n-        }\n-    }\n+      if (debug)\n+      // Add line numbers to the generated janino class\n+      {\n+        cbe.setDebuggingInformation(true, true, true);\n+      }\n \n-    /** */\n-    public static void checkRange(@NotNull Object[] array, int idx) {\n-        if (idx < 0 || idx >= array.length)\n-            throw new ArrayIndexOutOfBoundsException(idx);\n+      return (T) cbe.createInstance(new StringReader(body));\n+    } catch (Exception e) {\n+      throw new IgniteException(e);\n     }\n-\n-    /** */\n-    public static <T> T[] ensureCapacity(T[] array, int required) {\n-        if (required < 0)\n-            throw new IllegalArgumentException(\"Capacity must not be negative\");\n-\n-        return array.length <= required ? Arrays.copyOf(array, nextPowerOf2(required)) : array;\n+  }\n+\n+  /**\n+   *\n+   */\n+  public static void checkRange(@NotNull Object[] array, int idx) {\n+    if (idx < 0 || idx >= array.length) {\n+      throw new ArrayIndexOutOfBoundsException(idx);\n     }\n-\n-    /**\n-     * Round up the argument to the next highest power of 2;\n-     *\n-     * @param v Value to round up.\n-     * @return Next closest power of 2.\n-     */\n-    public static int nextPowerOf2(int v) {\n-        if (v < 0)\n-            throw new IllegalArgumentException(\"v must not be negative\");\n-\n-        if (v == 0)\n-            return 1;\n-\n-        return 1 << (32 - Integer.numberOfLeadingZeros(v - 1));\n+  }\n+\n+  /**\n+   *\n+   */\n+  public static <T> T[] ensureCapacity(T[] array, int required) {\n+    if (required < 0) {\n+      throw new IllegalArgumentException(\"Capacity must not be negative\");\n     }\n \n-    /** */\n-    public static <T> Predicate<T> negate(Predicate<T> p) {\n-        return p.negate();\n+    return array.length <= required ? Arrays.copyOf(array, nextPowerOf2(required)) : array;\n+  }\n+\n+  /**\n+   * Round up the argument to the next highest power of 2;\n+   *\n+   * @param v Value to round up.\n+   * @return Next closest power of 2.\n+   */\n+  public static int nextPowerOf2(int v) {\n+    if (v < 0) {\n+      throw new IllegalArgumentException(\"v must not be negative\");\n     }\n \n-    /** */\n-    public static Mappings.TargetMapping mapping(ImmutableBitSet bitSet, int sourceSize) {\n-        Mapping mapping = Mappings.create(MappingType.PARTIAL_FUNCTION, sourceSize, bitSet.cardinality());\n-        for (Ord<Integer> ord : Ord.zip(bitSet))\n-            mapping.set(ord.e, ord.i);\n-        return mapping;\n+    if (v == 0) {\n+      return 1;\n     }\n \n-    /** */\n-    public static Mappings.TargetMapping inverseMapping(ImmutableBitSet bitSet, int sourceSize) {\n-        Mapping mapping = Mappings.create(MappingType.INVERSE_FUNCTION, sourceSize, bitSet.cardinality());\n-        for (Ord<Integer> ord : Ord.zip(bitSet))\n-            mapping.set(ord.e, ord.i);\n-        return mapping;\n+    return 1 << (32 - Integer.numberOfLeadingZeros(v - 1));\n+  }\n+\n+  /**\n+   *\n+   */\n+  public static <T> Predicate<T> negate(Predicate<T> p) {\n+    return p.negate();\n+  }\n+\n+  /**\n+   *\n+   */\n+  public static Mappings.TargetMapping mapping(ImmutableBitSet bitSet, int sourceSize) {\n+    Mapping mapping = Mappings.create(MappingType.PARTIAL_FUNCTION, sourceSize, bitSet.cardinality());\n+    for (Ord<Integer> ord : Ord.zip(bitSet)) {\n+      mapping.set(ord.e, ord.i);\n+    }\n+    return mapping;\n+  }\n+\n+  /**\n+   *\n+   */\n+  public static Mappings.TargetMapping inverseMapping(ImmutableBitSet bitSet, int sourceSize) {\n+    Mapping mapping = Mappings.create(MappingType.INVERSE_FUNCTION, sourceSize, bitSet.cardinality());\n+    for (Ord<Integer> ord : Ord.zip(bitSet)) {\n+      mapping.set(ord.e, ord.i);\n     }\n+    return mapping;\n+  }\n+\n+  /**\n+   * Checks if there is a such permutation of all {@code elems} that is prefix of\n+   * provided {@code seq}.\n+   *\n+   * @param seq   Sequence.\n+   * @param elems Elems.\n+   * @return {@code true} if there is a permutation of all {@code elems} that is prefix of {@code seq}.\n+   */\n+  public static <T> boolean isPrefix(List<T> seq, Collection<T> elems) {\n+    Set<T> elems0 = new HashSet<>(elems);\n+\n+    if (seq.size() < elems0.size()) {\n+      return false;\n+    }\n+\n+    for (T e : seq) {\n+      if (!elems0.remove(e)) {\n+        return false;\n+      }\n \n-    /**\n-     * Checks if there is a such permutation of all {@code elems} that is prefix of\n-     * provided {@code seq}.\n-     *\n-     * @param seq Sequence.\n-     * @param elems Elems.\n-     * @return {@code true} if there is a permutation of all {@code elems} that is prefix of {@code seq}.\n-     */\n-    public static <T> boolean isPrefix(List<T> seq, Collection<T> elems) {\n-        Set<T> elems0 = new HashSet<>(elems);\n-\n-        if (seq.size() < elems0.size())\n-            return false;\n-\n-        for (T e : seq) {\n-            if (!elems0.remove(e))\n-                return false;\n-\n-            if (elems0.isEmpty())\n-                break;\n-        }\n-\n-        return true;\n+      if (elems0.isEmpty()) {\n+        break;\n+      }\n     }\n \n-    /**\n-     * Returns the longest possible prefix of {@code seq} that could be form from provided {@code elems}.\n-     *\n-     * @param seq Sequence.\n-     * @param elems Elems.\n-     * @return The longest possible prefix of {@code seq}.\n-     */\n-    public static <T> List<T> maxPrefix(List<T> seq, Collection<T> elems) {\n-        List<T> res = new ArrayList<>();\n+    return true;\n+  }\n \n-        Set<T> elems0 = new HashSet<>(elems);\n+  /**\n+   * Returns the longest possible prefix of {@code seq} that could be form from provided {@code elems}.\n+   *\n+   * @param seq   Sequence.\n+   * @param elems Elems.\n+   * @return The longest possible prefix of {@code seq}.\n+   */\n+  public static <T> List<T> maxPrefix(List<T> seq, Collection<T> elems) {\n+    List<T> res = new ArrayList<>();\n \n-        for (T e : seq) {\n-            if (!elems0.remove(e))\n-                break;\n+    Set<T> elems0 = new HashSet<>(elems);\n \n-            res.add(e);\n-        }\n+    for (T e : seq) {\n+      if (!elems0.remove(e)) {\n+        break;\n+      }\n \n-        return res;\n+      res.add(e);\n     }\n \n-    /**\n-     * Quietly closes given object ignoring possible checked exception.\n-     *\n-     * @param obj Object to close. If it's {@code null} - it's no-op.\n-     */\n-    public static void closeQuiet(@Nullable Object obj) {\n-        if (obj instanceof AutoCloseable) {\n-            try {\n-                ((AutoCloseable)obj).close();\n-            }\n-            catch (Exception ignored) {\n-                // No-op.\n-            }\n-        }\n+    return res;\n+  }\n+\n+  /**\n+   * Quietly closes given object ignoring possible checked exception.\n+   *\n+   * @param obj Object to close. If it's {@code null} - it's no-op.\n+   */\n+  public static void closeQuiet(@Nullable Object obj) {\n+    if (obj instanceof AutoCloseable) {\n+      try {\n+        ((AutoCloseable) obj).close();\n+      } catch (Exception ignored) {\n+        // No-op.\n+      }\n     }\n+  }\n }\n",
            "diff_size": 475
        },
        {
            "tool": "naturalize",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/errored/1/56/Commons.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/naturalize/56/Commons.java\nindex 31e9a74950d..0a6dfa8ec9b 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/errored/1/56/Commons.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/naturalize/56/Commons.java\n@@ -95,35 +95,31 @@ public final class Commons {\n                 HintStrategyTable.builder()\n                     .hintStrategy(\"DISABLE_RULE\", (hint, rel) -> true)\n                     .hintStrategy(\"EXPAND_DISTINCT_AGG\", (hint, rel) -> rel instanceof Aggregate)\n-                    .build()\n-            )\n-        )\n+                    .build()))\n         .parserConfig(\n             SqlParser.config()\n                 .withParserFactory(IgniteSqlParserImpl.FACTORY)\n                 .withLex(Lex.ORACLE)\n                 .withConformance(SqlConformanceEnum.DEFAULT))\n-        .sqlValidatorConfig(SqlValidator.Config.DEFAULT\n-            .withIdentifierExpansion(true)\n+.sqlValidatorConfig(SqlValidator.Config.DEFAULT.withIdentifierExpansion(true)\n             .withSqlConformance(SqlConformanceEnum.DEFAULT))\n-        // Dialects support.\n+    // Dialects support.\n         .operatorTable(SqlOperatorTables.chain(\n-            SqlLibraryOperatorTableFactory.INSTANCE\n-                .getOperatorTable(\n+            SqlLibraryOperatorTableFactory.INSTANCE.getOperatorTable(\n                     SqlLibrary.STANDARD,\n                     SqlLibrary.POSTGRESQL,\n                     SqlLibrary.ORACLE,\n                     SqlLibrary.MYSQL),\n-            IgniteSqlOperatorTable.instance()))\n-        // Context provides a way to store data within the planner session that can be accessed in planner rules.\n+IgniteSqlOperatorTable.instance()))\n+    // Context provides a way to store data within the planner session that can be accessed in planner rules.\n         .context(Contexts.empty())\n         // Custom cost factory to use during optimization\n         .costFactory(new IgniteCostFactory())\n         .typeSystem(IgniteTypeSystem.INSTANCE)\n         .build();\n \n-    /** */\n-    private Commons(){}\n+/** */\n+    private Commons() {}\n \n     /**\n      * Combines two lists.\n@@ -144,8 +140,7 @@ public final class Commons {\n         if (nullOrEmpty(left) || nullOrEmpty(right))\n             return Collections.emptyList();\n \n-        return left.size() > right.size()\n-            ? intersect(new HashSet<>(right), left)\n+        return left.size() > right.size() ? intersect(new HashSet<>(right), left)\n             : intersect(new HashSet<>(left), right);\n     }\n \n@@ -320,7 +315,7 @@ public final class Commons {\n \n             IClassBodyEvaluator cbe = compilerFactory.newClassBodyEvaluator();\n \n-            cbe.setImplementedInterfaces(new Class[]{ interfaceType });\n+            cbe.setImplementedInterfaces(new Class[] { interfaceType });\n             cbe.setParentClassLoader(ExpressionFactoryImpl.class.getClassLoader());\n \n             if (debug)\n@@ -446,4 +441,4 @@ public final class Commons {\n             }\n         }\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 16
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "81",
                    "column": "1",
                    "severity": "error",
                    "message": "'CLASS_DEF' has more than 1 empty lines before.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.EmptyLineSeparatorCheck"
                },
                {
                    "line": "89",
                    "column": "5",
                    "severity": "error",
                    "message": "'VARIABLE_DEF' has more than 1 empty lines before.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.EmptyLineSeparatorCheck"
                },
                {
                    "line": "123",
                    "column": "5",
                    "severity": "error",
                    "message": "'METHOD_DEF' has more than 1 empty lines before.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.EmptyLineSeparatorCheck"
                },
                {
                    "line": "163",
                    "column": "5",
                    "severity": "error",
                    "message": "'METHOD_DEF' has more than 1 empty lines before.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.EmptyLineSeparatorCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/errored/1/56/Commons.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/codebuff/56/Commons.java\nindex 31e9a74950d..b787905e6ec 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/errored/1/56/Commons.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/codebuff/56/Commons.java\n@@ -31,7 +31,6 @@ import java.util.Set;\n import java.util.function.Function;\n import java.util.function.Predicate;\n import java.util.stream.Collectors;\n-\n import org.apache.calcite.config.CalciteSystemProperty;\n import org.apache.calcite.config.Lex;\n import org.apache.calcite.linq4j.Ord;\n@@ -77,61 +76,55 @@ import static org.apache.ignite.internal.util.CollectionUtils.nullOrEmpty;\n /**\n  * Utility methods.\n  */\n+\n+\n public final class Commons {\n     /** */\n+\n     public static final int IN_BUFFER_SIZE = 512;\n \n     /** */\n-    public static final FrameworkConfig FRAMEWORK_CONFIG = Frameworks.newConfigBuilder()\n-        .executor(EXECUTOR)\n-        .sqlToRelConverterConfig(SqlToRelConverter.config()\n-            .withTrimUnusedFields(true)\n+\n+\n+    public static final FrameworkConfig FRAMEWORK_CONFIG = Frameworks.newConfigBuilder().executor(EXECUTOR)\n+                                                                                        .sqlToRelConverterConfig(SqlToRelConverter.config().withTrimUnusedFields(true)\n             // currently SqlToRelConverter creates not optimal plan for both optimization and execution\n             // so it's better to disable such rewriting right now\n             // TODO: remove this after IGNITE-14277\n-            .withInSubQueryThreshold(Integer.MAX_VALUE)\n-            .withDecorrelationEnabled(true)\n-            .withHintStrategyTable(\n-                HintStrategyTable.builder()\n-                    .hintStrategy(\"DISABLE_RULE\", (hint, rel) -> true)\n-                    .hintStrategy(\"EXPAND_DISTINCT_AGG\", (hint, rel) -> rel instanceof Aggregate)\n-                    .build()\n-            )\n-        )\n-        .parserConfig(\n-            SqlParser.config()\n-                .withParserFactory(IgniteSqlParserImpl.FACTORY)\n-                .withLex(Lex.ORACLE)\n-                .withConformance(SqlConformanceEnum.DEFAULT))\n-        .sqlValidatorConfig(SqlValidator.Config.DEFAULT\n-            .withIdentifierExpansion(true)\n-            .withSqlConformance(SqlConformanceEnum.DEFAULT))\n+                                                                                                                                           .withInSubQueryThreshold(Integer.MAX_VALUE)\n+                                                                                                                                           .withDecorrelationEnabled(true)\n+                                                                                                                                           .withHintStrategyTable(HintStrategyTable.builder().hintStrategy(\"DISABLE_RULE\", (hint, rel) -> true)\n+                                                                                                                                                                                             .hintStrategy(\"EXPAND_DISTINCT_AGG\", (hint, rel) -> rel instanceof Aggregate)\n+                                                                                                                                                                                             .build()))\n+                                                                                        .parserConfig(SqlParser.config().withParserFactory(IgniteSqlParserImpl.FACTORY)\n+                                                                                                                        .withLex(Lex.ORACLE)\n+                                                                                                                        .withConformance(SqlConformanceEnum.DEFAULT))\n+                                                                                        .sqlValidatorConfig(SqlValidator.Config.DEFAULT.withIdentifierExpansion(true).withSqlConformance(SqlConformanceEnum.DEFAULT))\n         // Dialects support.\n-        .operatorTable(SqlOperatorTables.chain(\n-            SqlLibraryOperatorTableFactory.INSTANCE\n-                .getOperatorTable(\n-                    SqlLibrary.STANDARD,\n-                    SqlLibrary.POSTGRESQL,\n-                    SqlLibrary.ORACLE,\n-                    SqlLibrary.MYSQL),\n-            IgniteSqlOperatorTable.instance()))\n+                                                                                        .operatorTable(SqlOperatorTables.chain(SqlLibraryOperatorTableFactory.INSTANCE.getOperatorTable(SqlLibrary.STANDARD, SqlLibrary.POSTGRESQL, SqlLibrary.ORACLE, SqlLibrary.MYSQL), IgniteSqlOperatorTable.instance()))\n         // Context provides a way to store data within the planner session that can be accessed in planner rules.\n-        .context(Contexts.empty())\n+                                                                                        .context(Contexts.empty())\n         // Custom cost factory to use during optimization\n-        .costFactory(new IgniteCostFactory())\n-        .typeSystem(IgniteTypeSystem.INSTANCE)\n-        .build();\n+                                                                                        .costFactory(\n+                                            new IgniteCostFactory())\n+                                                                                        .typeSystem(IgniteTypeSystem.INSTANCE)\n+                                                                                        .build();\n \n     /** */\n-    private Commons(){}\n+\n+    private Commons() {\n+    }\n \n     /**\n      * Combines two lists.\n      */\n+\n+\n     public static <T> List<T> combine(List<T> left, List<T> right) {\n         Set<T> set = new HashSet<>(left.size() + right.size());\n \n         set.addAll(left);\n+\n         set.addAll(right);\n \n         return new ArrayList<>(set);\n@@ -140,13 +133,12 @@ public final class Commons {\n     /**\n      * Intersects two lists.\n      */\n+\n     public static <T> List<T> intersect(List<T> left, List<T> right) {\n         if (nullOrEmpty(left) || nullOrEmpty(right))\n             return Collections.emptyList();\n \n-        return left.size() > right.size()\n-            ? intersect(new HashSet<>(right), left)\n-            : intersect(new HashSet<>(left), right);\n+        return left.size() > right.size() ? intersect(new HashSet<>(right), left) : intersect(new HashSet<>(left), right);\n     }\n \n     /**\n@@ -154,19 +146,24 @@ public final class Commons {\n      *\n      * @return A List of unique entries that presented in both the given set and the given list.\n      */\n+\n     public static <T> List<T> intersect(Set<T> set, List<T> list) {\n         if (nullOrEmpty(set) || nullOrEmpty(list))\n             return Collections.emptyList();\n \n-        return list.stream()\n-            .filter(set::contains)\n-            .collect(Collectors.toList());\n+        return list.stream().filter(set::contains)\n+                            .collect(Collectors.toList());\n     }\n \n     /**\n      * Returns a given list as a typed list.\n      */\n-    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n+\n+\n+    @SuppressWarnings( {\n+        \"unchecked\",\n+        \"rawtypes\"\n+})\n     public static <T> List<T> cast(List<?> src) {\n         return (List)src;\n     }\n@@ -174,6 +171,7 @@ public final class Commons {\n     /**\n      * Transforms a given list using map function.\n      */\n+\n     public static <T, R> List<R> transform(@NotNull List<T> src, @NotNull Function<T, R> mapFun) {\n         if (nullOrEmpty(src))\n             return Collections.emptyList();\n@@ -189,6 +187,7 @@ public final class Commons {\n     /**\n      * Extracts type factory.\n      */\n+\n     public static IgniteTypeFactory typeFactory(RelNode rel) {\n         return typeFactory(rel.getCluster());\n     }\n@@ -196,6 +195,7 @@ public final class Commons {\n     /**\n      * Extracts type factory.\n      */\n+\n     public static IgniteTypeFactory typeFactory(RelOptCluster cluster) {\n         return (IgniteTypeFactory)cluster.getTypeFactory();\n     }\n@@ -203,6 +203,7 @@ public final class Commons {\n     /**\n      * Extracts planner context.\n      */\n+\n     public static PlanningContext context(RelNode rel) {\n         return context(rel.getCluster());\n     }\n@@ -210,6 +211,7 @@ public final class Commons {\n     /**\n      * Extracts planner context.\n      */\n+\n     public static PlanningContext context(RelOptCluster cluster) {\n         return context(cluster.getPlanner().getContext());\n     }\n@@ -217,6 +219,7 @@ public final class Commons {\n     /**\n      * Extracts planner context.\n      */\n+\n     public static PlanningContext context(Context ctx) {\n         return Objects.requireNonNull(ctx.unwrap(PlanningContext.class));\n     }\n@@ -225,6 +228,7 @@ public final class Commons {\n      * @param params Parameters.\n      * @return Parameters map.\n      */\n+\n     public static Map<String, Object> parametersMap(@Nullable Object[] params) {\n         HashMap<String, Object> res = new HashMap<>();\n \n@@ -238,20 +242,23 @@ public final class Commons {\n      * @param params Parameters.\n      * @return Parameters map.\n      */\n+\n     public static Map<String, Object> populateParameters(@NotNull Map<String, Object> dst, @Nullable Object[] params) {\n         if (!ArrayUtils.nullOrEmpty(params)) {\n             for (int i = 0; i < params.length; i++)\n                 dst.put(\"?\" + i, params[i]);\n         }\n+\n         return dst;\n     }\n \n     /**\n      * @param o Object to close.\n      */\n+\n     public static void close(Object o) throws Exception {\n         if (o instanceof AutoCloseable)\n-            ((AutoCloseable) o).close();\n+            ((AutoCloseable)o).close();\n     }\n \n //    /**\n@@ -271,11 +278,14 @@ public final class Commons {\n //    }\n \n     /** */\n+\n     public static <T> List<T> flat(List<List<? extends T>> src) {\n-        return src.stream().flatMap(List::stream).collect(Collectors.toList());\n+        return src.stream().flatMap(List::stream)\n+                           .collect(Collectors.toList());\n     }\n \n     /** */\n+\n     public static int max(ImmutableIntList list) {\n         if (list.isEmpty())\n             throw new UnsupportedOperationException();\n@@ -289,6 +299,7 @@ public final class Commons {\n     }\n \n     /** */\n+\n     public static int min(ImmutableIntList list) {\n         if (list.isEmpty())\n             throw new UnsupportedOperationException();\n@@ -302,6 +313,7 @@ public final class Commons {\n     }\n \n     /** */\n+\n     public static <T> T compile(Class<T> interfaceType, String body) {\n         final boolean debug = CalciteSystemProperty.DEBUG.value();\n \n@@ -313,33 +325,37 @@ public final class Commons {\n \n             try {\n                 compilerFactory = CompilerFactoryFactory.getDefaultCompilerFactory();\n-            } catch (Exception e) {\n-                throw new IllegalStateException(\n-                    \"Unable to instantiate java compiler\", e);\n+            }\n+            catch (Exception e) {\n+                throw new IllegalStateException(\"Unable to instantiate java compiler\", e);\n             }\n \n             IClassBodyEvaluator cbe = compilerFactory.newClassBodyEvaluator();\n \n-            cbe.setImplementedInterfaces(new Class[]{ interfaceType });\n+            cbe.setImplementedInterfaces(new Class[] {interfaceType});\n+\n             cbe.setParentClassLoader(ExpressionFactoryImpl.class.getClassLoader());\n \n             if (debug)\n                 // Add line numbers to the generated janino class\n                 cbe.setDebuggingInformation(true, true, true);\n \n-            return (T) cbe.createInstance(new StringReader(body));\n-        } catch (Exception e) {\n+            return (T)cbe.createInstance(new StringReader(body));\n+        }\n+        catch (Exception e) {\n             throw new IgniteException(e);\n         }\n     }\n \n     /** */\n+\n     public static void checkRange(@NotNull Object[] array, int idx) {\n         if (idx < 0 || idx >= array.length)\n             throw new ArrayIndexOutOfBoundsException(idx);\n     }\n \n     /** */\n+\n     public static <T> T[] ensureCapacity(T[] array, int required) {\n         if (required < 0)\n             throw new IllegalArgumentException(\"Capacity must not be negative\");\n@@ -353,6 +369,7 @@ public final class Commons {\n      * @param v Value to round up.\n      * @return Next closest power of 2.\n      */\n+\n     public static int nextPowerOf2(int v) {\n         if (v < 0)\n             throw new IllegalArgumentException(\"v must not be negative\");\n@@ -364,23 +381,30 @@ public final class Commons {\n     }\n \n     /** */\n+\n     public static <T> Predicate<T> negate(Predicate<T> p) {\n         return p.negate();\n     }\n \n     /** */\n+\n     public static Mappings.TargetMapping mapping(ImmutableBitSet bitSet, int sourceSize) {\n         Mapping mapping = Mappings.create(MappingType.PARTIAL_FUNCTION, sourceSize, bitSet.cardinality());\n+\n         for (Ord<Integer> ord : Ord.zip(bitSet))\n             mapping.set(ord.e, ord.i);\n+\n         return mapping;\n     }\n \n     /** */\n+\n     public static Mappings.TargetMapping inverseMapping(ImmutableBitSet bitSet, int sourceSize) {\n         Mapping mapping = Mappings.create(MappingType.INVERSE_FUNCTION, sourceSize, bitSet.cardinality());\n+\n         for (Ord<Integer> ord : Ord.zip(bitSet))\n             mapping.set(ord.e, ord.i);\n+\n         return mapping;\n     }\n \n@@ -392,6 +416,7 @@ public final class Commons {\n      * @param elems Elems.\n      * @return {@code true} if there is a permutation of all {@code elems} that is prefix of {@code seq}.\n      */\n+\n     public static <T> boolean isPrefix(List<T> seq, Collection<T> elems) {\n         Set<T> elems0 = new HashSet<>(elems);\n \n@@ -416,6 +441,7 @@ public final class Commons {\n      * @param elems Elems.\n      * @return The longest possible prefix of {@code seq}.\n      */\n+\n     public static <T> List<T> maxPrefix(List<T> seq, Collection<T> elems) {\n         List<T> res = new ArrayList<>();\n \n@@ -436,6 +462,7 @@ public final class Commons {\n      *\n      * @param obj Object to close. If it's {@code null} - it's no-op.\n      */\n+\n     public static void closeQuiet(@Nullable Object obj) {\n         if (obj instanceof AutoCloseable) {\n             try {\n@@ -443,7 +470,8 @@ public final class Commons {\n             }\n             catch (Exception ignored) {\n                 // No-op.\n+\n             }\n         }\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 98
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/errored/1/56/Commons.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/styler_random/56/Commons.java\nindex 31e9a74950d..2426406bf96 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/errored/1/56/Commons.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/styler_random/56/Commons.java\n@@ -123,7 +123,7 @@ public final class Commons {\n         .build();\n \n     /** */\n-    private Commons(){}\n+    private Commons() {}\n \n     /**\n      * Combines two lists.\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/errored/1/56/Commons.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/styler_three_grams/56/Commons.java\nindex 31e9a74950d..89749098927 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/errored/1/56/Commons.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/styler_three_grams/56/Commons.java\n@@ -123,7 +123,7 @@ public final class Commons {\n         .build();\n \n     /** */\n-    private Commons(){}\n+    private Commons() { }\n \n     /**\n      * Combines two lists.\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "codebuff"
    ]
}