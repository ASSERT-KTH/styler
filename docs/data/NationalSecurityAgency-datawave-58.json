{
    "project_name": "NationalSecurityAgency-datawave",
    "error_id": "58",
    "information": {
        "errors": [
            {
                "line": "14",
                "severity": "error",
                "message": "Accumulo non-public classes imported",
                "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
            }
        ]
    },
    "source_code": "import org.apache.accumulo.core.iterators.IteratorEnvironment;\nimport org.apache.accumulo.core.iterators.SortedKeyValueIterator;\nimport org.apache.accumulo.core.util.Pair;\nimport org.apache.hadoop.io.ArrayWritable;\nimport org.apache.hadoop.io.Writable;\nimport org.apache.hadoop.io.WritableUtils;",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/58/DiscoveryIterator.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/styler/58/DiscoveryIterator.java\nindex 52baa600822..95190c9f127 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/58/DiscoveryIterator.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/styler/58/DiscoveryIterator.java\n@@ -11,8 +11,9 @@ import org.apache.accumulo.core.data.Range;\n import org.apache.accumulo.core.data.Value;\n import org.apache.accumulo.core.iterators.IteratorEnvironment;\n import org.apache.accumulo.core.iterators.SortedKeyValueIterator;\n-import org.apache.accumulo.core.util.Pair;\n-import org.apache.hadoop.io.ArrayWritable;\n+import\n+org.apache.accumulo.core.util.Pair;\n+ import org.apache.hadoop.io.ArrayWritable;\n import org.apache.hadoop.io.Writable;\n import org.apache.hadoop.io.WritableUtils;\n import org.apache.log4j.Logger;\n",
            "diff_size": 3
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "14",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/58/DiscoveryIterator.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/intellij/58/DiscoveryIterator.java\nindex 52baa600822..2143a5e9a16 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/58/DiscoveryIterator.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/intellij/58/DiscoveryIterator.java\n@@ -27,129 +27,139 @@ import static com.google.common.collect.Collections2.filter;\n import static com.google.common.collect.Collections2.transform;\n import static com.google.common.collect.Lists.newArrayList;\n \n-public class DiscoveryIterator implements SortedKeyValueIterator<Key,Value> {\n-    private static final Logger log = Logger.getLogger(DiscoveryIterator.class);\n-    \n-    private Key tk;\n-    private Value tv;\n-    private SortedKeyValueIterator<Key,Value> itr;\n-    private boolean separateCountsByColVis = false;\n-    private boolean showReferenceCount = false;\n-    private boolean reverseIndex = false;\n-    \n-    @Override\n-    public DiscoveryIterator deepCopy(IteratorEnvironment env) {\n-        DiscoveryIterator i = new DiscoveryIterator();\n-        i.itr = itr.deepCopy(env);\n-        return i;\n-    }\n-    \n-    @Override\n-    public void next() throws IOException {\n-        tk = null;\n-        tv = null;\n-        \n-        while (itr.hasTop() && tk == null) {\n-            Multimap<String,TermInfo> terms = aggregateDate();\n-            if (terms.isEmpty()) {\n-                if (log.isTraceEnabled())\n-                    log.trace(\"Couldn't aggregate index info; moving onto next date/field/term if data is available.\");\n-                continue;\n-            } else {\n-                if (log.isTraceEnabled())\n-                    log.trace(\"Received term info multimap of size [\" + terms.size() + \"]\");\n-                ArrayList<DiscoveredThing> things = newArrayList(filter(\n-                                transform(terms.asMap().values(), new TermInfoAggregation(separateCountsByColVis, showReferenceCount, reverseIndex)),\n-                                Predicates.notNull()));\n-                if (log.isTraceEnabled())\n-                    log.trace(\"After conversion to discovery objects, there are [\" + things.size() + \"] term info objects.\");\n-                if (things.isEmpty()) {\n-                    continue;\n-                } else {\n-                    Pair<Key,Value> top = makeTop(things);\n-                    tk = top.getFirst();\n-                    tv = top.getSecond();\n-                    return;\n-                }\n-            }\n+public class DiscoveryIterator implements SortedKeyValueIterator<Key, Value> {\n+  private static final Logger log = Logger.getLogger(DiscoveryIterator.class);\n+\n+  private Key tk;\n+  private Value tv;\n+  private SortedKeyValueIterator<Key, Value> itr;\n+  private boolean separateCountsByColVis = false;\n+  private boolean showReferenceCount = false;\n+  private boolean reverseIndex = false;\n+\n+  @Override\n+  public DiscoveryIterator deepCopy(IteratorEnvironment env) {\n+    DiscoveryIterator i = new DiscoveryIterator();\n+    i.itr = itr.deepCopy(env);\n+    return i;\n+  }\n+\n+  @Override\n+  public void next() throws IOException {\n+    tk = null;\n+    tv = null;\n+\n+    while (itr.hasTop() && tk == null) {\n+      Multimap<String, TermInfo> terms = aggregateDate();\n+      if (terms.isEmpty()) {\n+        if (log.isTraceEnabled()) {\n+          log.trace(\"Couldn't aggregate index info; moving onto next date/field/term if data is available.\");\n         }\n-        if (log.isTraceEnabled())\n-            log.trace(\"No data found.\");\n-    }\n-    \n-    private Multimap<String,TermInfo> aggregateDate() throws IOException {\n-        Multimap<String,TermInfo> terms = ArrayListMultimap.create();\n-        Key start = new Key(itr.getTopKey()), key = null;\n-        while (itr.hasTop() && start.equals((key = itr.getTopKey()), PartialKey.ROW_COLFAM) && datesMatch(start, key)) {\n-            TermInfo ti = new TermInfo(key, itr.getTopValue());\n-            if (ti.valid)\n-                terms.put(ti.datatype, ti);\n-            else {\n-                if (log.isTraceEnabled())\n-                    log.trace(\"Received invalid term info from key: \" + key);\n-            }\n-            itr.next();\n+        continue;\n+      } else {\n+        if (log.isTraceEnabled()) {\n+          log.trace(\"Received term info multimap of size [\" + terms.size() + \"]\");\n         }\n-        return terms;\n-    }\n-    \n-    private static boolean datesMatch(Key reference, Key test) {\n-        ByteSequence a = reference.getColumnQualifierData(), b = test.getColumnQualifierData();\n-        for (int i = 0; i < 8; i++) {\n-            if (a.byteAt(i) != b.byteAt(i)) {\n-                return false;\n-            }\n+        ArrayList<DiscoveredThing> things = newArrayList(filter(\n+            transform(terms.asMap().values(),\n+                new TermInfoAggregation(separateCountsByColVis, showReferenceCount, reverseIndex)),\n+            Predicates.notNull()));\n+        if (log.isTraceEnabled()) {\n+          log.trace(\"After conversion to discovery objects, there are [\" + things.size() + \"] term info objects.\");\n         }\n-        return true;\n-    }\n-    \n-    private Pair<Key,Value> makeTop(List<DiscoveredThing> things) {\n-        Writable[] returnedThings = new Writable[things.size()];\n-        for (int i = 0; i < returnedThings.length; ++i)\n-            returnedThings[i] = things.get(i);\n-        ArrayWritable aw = new ArrayWritable(DiscoveredThing.class);\n-        aw.set(returnedThings);\n-        \n-        DiscoveredThing thing = things.get(0);\n-        // we want the key to be the last possible key for this date\n-        return new Pair<>(new Key(thing.getTerm(), thing.getField(), thing.getDate() + '\\uffff'), new Value(WritableUtils.toByteArray(aw)));\n+        if (things.isEmpty()) {\n+          continue;\n+        } else {\n+          Pair<Key, Value> top = makeTop(things);\n+          tk = top.getFirst();\n+          tv = top.getSecond();\n+          return;\n+        }\n+      }\n     }\n-    \n-    @Override\n-    public void seek(Range range, Collection<ByteSequence> columnFamilies, boolean inclusive) throws IOException {\n-        \n-        itr.seek(range, columnFamilies, inclusive);\n-        if (log.isTraceEnabled())\n-            log.trace(\"My source \" + (itr.hasTop() ? \"does\" : \"does not\") + \" have a top.\");\n-        next();\n+    if (log.isTraceEnabled()) {\n+      log.trace(\"No data found.\");\n     }\n-    \n-    @Override\n-    public void init(SortedKeyValueIterator<Key,Value> source, Map<String,String> options, IteratorEnvironment env) throws IOException {\n-        itr = source;\n-        separateCountsByColVis = Boolean.parseBoolean(options.get(DiscoveryLogic.SEPARATE_COUNTS_BY_COLVIS));\n-        showReferenceCount = Boolean.parseBoolean(options.get(DiscoveryLogic.SHOW_REFERENCE_COUNT));\n-        reverseIndex = Boolean.parseBoolean(options.get(DiscoveryLogic.REVERSE_INDEX));\n-        \n+  }\n+\n+  private Multimap<String, TermInfo> aggregateDate() throws IOException {\n+    Multimap<String, TermInfo> terms = ArrayListMultimap.create();\n+    Key start = new Key(itr.getTopKey()), key = null;\n+    while (itr.hasTop() && start.equals((key = itr.getTopKey()), PartialKey.ROW_COLFAM) && datesMatch(start, key)) {\n+      TermInfo ti = new TermInfo(key, itr.getTopValue());\n+      if (ti.valid) {\n+        terms.put(ti.datatype, ti);\n+      } else {\n         if (log.isTraceEnabled()) {\n-            log.trace(\"My source is a \" + source.getClass().getName());\n-            log.trace(\"Separate counts by column visibility = \" + separateCountsByColVis);\n-            log.trace(\"Show reference count only = \" + showReferenceCount);\n+          log.trace(\"Received invalid term info from key: \" + key);\n         }\n+      }\n+      itr.next();\n+    }\n+    return terms;\n+  }\n+\n+  private static boolean datesMatch(Key reference, Key test) {\n+    ByteSequence a = reference.getColumnQualifierData(), b = test.getColumnQualifierData();\n+    for (int i = 0; i < 8; i++) {\n+      if (a.byteAt(i) != b.byteAt(i)) {\n+        return false;\n+      }\n     }\n-    \n-    @Override\n-    public boolean hasTop() {\n-        return tk != null;\n+    return true;\n+  }\n+\n+  private Pair<Key, Value> makeTop(List<DiscoveredThing> things) {\n+    Writable[] returnedThings = new Writable[things.size()];\n+    for (int i = 0; i < returnedThings.length; ++i) {\n+      returnedThings[i] = things.get(i);\n     }\n-    \n-    @Override\n-    public Key getTopKey() {\n-        return tk;\n+    ArrayWritable aw = new ArrayWritable(DiscoveredThing.class);\n+    aw.set(returnedThings);\n+\n+    DiscoveredThing thing = things.get(0);\n+    // we want the key to be the last possible key for this date\n+    return new Pair<>(new Key(thing.getTerm(), thing.getField(), thing.getDate() + '\\uffff'),\n+        new Value(WritableUtils.toByteArray(aw)));\n+  }\n+\n+  @Override\n+  public void seek(Range range, Collection<ByteSequence> columnFamilies, boolean inclusive) throws IOException {\n+\n+    itr.seek(range, columnFamilies, inclusive);\n+    if (log.isTraceEnabled()) {\n+      log.trace(\"My source \" + (itr.hasTop() ? \"does\" : \"does not\") + \" have a top.\");\n     }\n-    \n-    @Override\n-    public Value getTopValue() {\n-        return tv;\n+    next();\n+  }\n+\n+  @Override\n+  public void init(SortedKeyValueIterator<Key, Value> source, Map<String, String> options, IteratorEnvironment env)\n+      throws IOException {\n+    itr = source;\n+    separateCountsByColVis = Boolean.parseBoolean(options.get(DiscoveryLogic.SEPARATE_COUNTS_BY_COLVIS));\n+    showReferenceCount = Boolean.parseBoolean(options.get(DiscoveryLogic.SHOW_REFERENCE_COUNT));\n+    reverseIndex = Boolean.parseBoolean(options.get(DiscoveryLogic.REVERSE_INDEX));\n+\n+    if (log.isTraceEnabled()) {\n+      log.trace(\"My source is a \" + source.getClass().getName());\n+      log.trace(\"Separate counts by column visibility = \" + separateCountsByColVis);\n+      log.trace(\"Show reference count only = \" + showReferenceCount);\n     }\n+  }\n+\n+  @Override\n+  public boolean hasTop() {\n+    return tk != null;\n+  }\n+\n+  @Override\n+  public Key getTopKey() {\n+    return tk;\n+  }\n+\n+  @Override\n+  public Value getTopValue() {\n+    return tv;\n+  }\n }\n",
            "diff_size": 169
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "14",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/58/DiscoveryIterator.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/naturalize/58/DiscoveryIterator.java\nindex 52baa600822..21b816fe0c3 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/58/DiscoveryIterator.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/naturalize/58/DiscoveryIterator.java\n@@ -58,8 +58,7 @@ public class DiscoveryIterator implements SortedKeyValueIterator<Key,Value> {\n             } else {\n                 if (log.isTraceEnabled())\n                     log.trace(\"Received term info multimap of size [\" + terms.size() + \"]\");\n-                ArrayList<DiscoveredThing> things = newArrayList(filter(\n-                                transform(terms.asMap().values(), new TermInfoAggregation(separateCountsByColVis, showReferenceCount, reverseIndex)),\n+                ArrayList<DiscoveredThing> things = newArrayList(filter(transform(terms.asMap().values(), new TermInfoAggregation(separateCountsByColVis, showReferenceCount, reverseIndex)),\n                                 Predicates.notNull()));\n                 if (log.isTraceEnabled())\n                     log.trace(\"After conversion to discovery objects, there are [\" + things.size() + \"] term info objects.\");\n@@ -152,4 +151,4 @@ public class DiscoveryIterator implements SortedKeyValueIterator<Key,Value> {\n     public Value getTopValue() {\n         return tv;\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 3
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "13",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/58/DiscoveryIterator.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/codebuff/58/DiscoveryIterator.java\nindex 52baa600822..6377af564e1 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/58/DiscoveryIterator.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/codebuff/58/DiscoveryIterator.java\n@@ -3,7 +3,6 @@ package datawave.query.discovery;\n import com.google.common.base.Predicates;\n import com.google.common.collect.ArrayListMultimap;\n import com.google.common.collect.Multimap;\n-\n import org.apache.accumulo.core.data.ByteSequence;\n import org.apache.accumulo.core.data.Key;\n import org.apache.accumulo.core.data.PartialKey;\n@@ -16,7 +15,6 @@ import org.apache.hadoop.io.ArrayWritable;\n import org.apache.hadoop.io.Writable;\n import org.apache.hadoop.io.WritableUtils;\n import org.apache.log4j.Logger;\n-\n import java.io.IOException;\n import java.util.ArrayList;\n import java.util.Collection;\n@@ -27,28 +25,27 @@ import static com.google.common.collect.Collections2.filter;\n import static com.google.common.collect.Collections2.transform;\n import static com.google.common.collect.Lists.newArrayList;\n \n+\n public class DiscoveryIterator implements SortedKeyValueIterator<Key,Value> {\n     private static final Logger log = Logger.getLogger(DiscoveryIterator.class);\n-    \n     private Key tk;\n     private Value tv;\n     private SortedKeyValueIterator<Key,Value> itr;\n     private boolean separateCountsByColVis = false;\n     private boolean showReferenceCount = false;\n     private boolean reverseIndex = false;\n-    \n+\n     @Override\n     public DiscoveryIterator deepCopy(IteratorEnvironment env) {\n         DiscoveryIterator i = new DiscoveryIterator();\n         i.itr = itr.deepCopy(env);\n         return i;\n     }\n-    \n+\n     @Override\n     public void next() throws IOException {\n         tk = null;\n         tv = null;\n-        \n         while (itr.hasTop() && tk == null) {\n             Multimap<String,TermInfo> terms = aggregateDate();\n             if (terms.isEmpty()) {\n@@ -58,9 +55,9 @@ public class DiscoveryIterator implements SortedKeyValueIterator<Key,Value> {\n             } else {\n                 if (log.isTraceEnabled())\n                     log.trace(\"Received term info multimap of size [\" + terms.size() + \"]\");\n-                ArrayList<DiscoveredThing> things = newArrayList(filter(\n-                                transform(terms.asMap().values(), new TermInfoAggregation(separateCountsByColVis, showReferenceCount, reverseIndex)),\n-                                Predicates.notNull()));\n+\n+                ArrayList<DiscoveredThing> things = newArrayList(filter(transform(terms.asMap().values(), new TermInfoAggregation(separateCountsByColVis, showReferenceCount, reverseIndex)),\n+Predicates.notNull()));\n                 if (log.isTraceEnabled())\n                     log.trace(\"After conversion to discovery objects, there are [\" + things.size() + \"] term info objects.\");\n                 if (things.isEmpty()) {\n@@ -73,10 +70,12 @@ public class DiscoveryIterator implements SortedKeyValueIterator<Key,Value> {\n                 }\n             }\n         }\n+\n+\n         if (log.isTraceEnabled())\n             log.trace(\"No data found.\");\n     }\n-    \n+\n     private Multimap<String,TermInfo> aggregateDate() throws IOException {\n         Multimap<String,TermInfo> terms = ArrayListMultimap.create();\n         Key start = new Key(itr.getTopKey()), key = null;\n@@ -92,7 +91,7 @@ public class DiscoveryIterator implements SortedKeyValueIterator<Key,Value> {\n         }\n         return terms;\n     }\n-    \n+\n     private static boolean datesMatch(Key reference, Key test) {\n         ByteSequence a = reference.getColumnQualifierData(), b = test.getColumnQualifierData();\n         for (int i = 0; i < 8; i++) {\n@@ -102,54 +101,53 @@ public class DiscoveryIterator implements SortedKeyValueIterator<Key,Value> {\n         }\n         return true;\n     }\n-    \n+\n     private Pair<Key,Value> makeTop(List<DiscoveredThing> things) {\n         Writable[] returnedThings = new Writable[things.size()];\n         for (int i = 0; i < returnedThings.length; ++i)\n             returnedThings[i] = things.get(i);\n+\n         ArrayWritable aw = new ArrayWritable(DiscoveredThing.class);\n         aw.set(returnedThings);\n-        \n+\n         DiscoveredThing thing = things.get(0);\n         // we want the key to be the last possible key for this date\n         return new Pair<>(new Key(thing.getTerm(), thing.getField(), thing.getDate() + '\\uffff'), new Value(WritableUtils.toByteArray(aw)));\n     }\n-    \n+\n     @Override\n     public void seek(Range range, Collection<ByteSequence> columnFamilies, boolean inclusive) throws IOException {\n-        \n         itr.seek(range, columnFamilies, inclusive);\n         if (log.isTraceEnabled())\n             log.trace(\"My source \" + (itr.hasTop() ? \"does\" : \"does not\") + \" have a top.\");\n         next();\n     }\n-    \n+\n     @Override\n     public void init(SortedKeyValueIterator<Key,Value> source, Map<String,String> options, IteratorEnvironment env) throws IOException {\n         itr = source;\n         separateCountsByColVis = Boolean.parseBoolean(options.get(DiscoveryLogic.SEPARATE_COUNTS_BY_COLVIS));\n         showReferenceCount = Boolean.parseBoolean(options.get(DiscoveryLogic.SHOW_REFERENCE_COUNT));\n         reverseIndex = Boolean.parseBoolean(options.get(DiscoveryLogic.REVERSE_INDEX));\n-        \n         if (log.isTraceEnabled()) {\n             log.trace(\"My source is a \" + source.getClass().getName());\n             log.trace(\"Separate counts by column visibility = \" + separateCountsByColVis);\n             log.trace(\"Show reference count only = \" + showReferenceCount);\n         }\n     }\n-    \n+\n     @Override\n     public boolean hasTop() {\n         return tk != null;\n     }\n-    \n+\n     @Override\n     public Key getTopKey() {\n         return tk;\n     }\n-    \n+\n     @Override\n     public Value getTopValue() {\n         return tv;\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 25
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "14",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/58/DiscoveryIterator.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/styler_three_grams/58/DiscoveryIterator.java\nindex 52baa600822..95190c9f127 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/58/DiscoveryIterator.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/styler_three_grams/58/DiscoveryIterator.java\n@@ -11,8 +11,9 @@ import org.apache.accumulo.core.data.Range;\n import org.apache.accumulo.core.data.Value;\n import org.apache.accumulo.core.iterators.IteratorEnvironment;\n import org.apache.accumulo.core.iterators.SortedKeyValueIterator;\n-import org.apache.accumulo.core.util.Pair;\n-import org.apache.hadoop.io.ArrayWritable;\n+import\n+org.apache.accumulo.core.util.Pair;\n+ import org.apache.hadoop.io.ArrayWritable;\n import org.apache.hadoop.io.Writable;\n import org.apache.hadoop.io.WritableUtils;\n import org.apache.log4j.Logger;\n",
            "diff_size": 3
        }
    ],
    "repaired_by": [
        "styler",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random"
    ]
}