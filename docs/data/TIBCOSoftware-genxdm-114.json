{
    "project_name": "TIBCOSoftware-genxdm",
    "error_id": "114",
    "information": {
        "errors": [
            {
                "line": "34",
                "column": "1",
                "severity": "warning",
                "message": "File contains tab characters (this is the first instance).",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
            }
        ]
    },
    "source_code": "final class NfaPattern<E, T> extends Graph<E, NfaMatchState<E>> implements RegExPattern<E, T>\n{\n\tprivate final RegExBridge<E, T> m_bridge;\n\n\tprivate NfaPattern(final NfaMatchState<E> initialState, final RegExBridge<E, T> bridge)\n\t{",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "36",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/114/NfaPattern.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler/114/NfaPattern.java\nindex 2c9a419905a..9c6109c7851 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/114/NfaPattern.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler/114/NfaPattern.java\n@@ -31,7 +31,7 @@ import org.genxdm.processor.w3c.xs.regex.api.RegExPatternInput;\n  */\n final class NfaPattern<E, T> extends Graph<E, NfaMatchState<E>> implements RegExPattern<E, T>\n {\n-\tprivate final RegExBridge<E, T> m_bridge;\n+private final RegExBridge<E, T> m_bridge;\n \n \tprivate NfaPattern(final NfaMatchState<E> initialState, final RegExBridge<E, T> bridge)\n \t{\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/114/NfaPattern.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/intellij/114/NfaPattern.java\nindex 2c9a419905a..9a29bc05ccc 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/114/NfaPattern.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/intellij/114/NfaPattern.java\n@@ -13,6 +13,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+\n package org.genxdm.processor.w3c.xs.regex.nfa;\n \n import java.util.ArrayList;\n@@ -29,246 +30,212 @@ import org.genxdm.processor.w3c.xs.regex.api.RegExPatternInput;\n  * A Pattern for representing and matching against regular expressions. Stores the pattern as a nondeterministic state\n  * machine. Can be used for XML content models or textual regular expressions.\n  */\n-final class NfaPattern<E, T> extends Graph<E, NfaMatchState<E>> implements RegExPattern<E, T>\n-{\n-\tprivate final RegExBridge<E, T> m_bridge;\n-\n-\tprivate NfaPattern(final NfaMatchState<E> initialState, final RegExBridge<E, T> bridge)\n-\t{\n-\t\tsuper(initialState);\n-\t\tm_bridge = PreCondition.assertArgumentNotNull(bridge, \"bridge\");\n-\t}\n-\n-\t/**\n-\t * Creates a pattern corresponding to the given term, which is a tree of terms.\n-\t * \n-\t * @param term\n-\t *            the head term of the term model. We allow null which represents the lambda set.\n-\t */\n-\tstatic <E, T> NfaPattern<E, T> newPattern(final E term, final RegExBridge<E, T> bridge)\n-\t{\n-\t\tfinal NfaMatchState<E> initialState = NfaCompiler.compileNFA(term, bridge);\n-\n-\t\treturn new NfaPattern<E, T>(initialState, bridge);\n-\n-\t\t// Can't use this yet till a*b bug is fixed.\n-\t\t// graph.optimize();\n-\t}\n-\n-\t/**\n-\t * Executes the state machine against the given input token stream.\n-\t * <p/>\n-\t * In case of failure, the input stream is left at the token that failed to match. The caller can use that to\n-\t * determine where the mismatch lies for error reporting.\n-\t * \n-\t * @param input\n-\t *            the input, which is a sequence of tokens\n-\t * @return true if the input matches the pattern\n-\t */\n-\tpublic boolean matches(final RegExPatternInput<E, T> input)\n-\t{\n-\t\treturn matches(input, null);\n-\t}\n-\n-\t/**\n-\t * Executes the state machine against the given input token stream. Returns true if the input matches the pattern.\n-\t * If the followers parameter is not null, it will be returned with possible leaf PatternTerms that could follow the\n-\t * last matched-token.\n-\t * <p>\n-\t * In case of failure, the input stream is left at the token that failed to match. The caller can use that to\n-\t * determine where the mismatch lies for error reporting.\n-\t * \n-\t * @param input\n-\t *            a PatternInput, advanced as needed.\n-\t * @param followers\n-\t *            an output List of PatternTerm.\n-\t * @return true if the input matches the pattern\n-\t */\n-\tpublic boolean matches(final RegExPatternInput<E, T> input, final List<E> followers)\n-\t{\n-\t\tfinal NfaStepper<E, T> stepper = new NfaStepper<E, T>(m_initialState, followers, m_bridge);\n-\t\tfinal List<E> matchTerms = new ArrayList<E>(23);\n-\t\twhile (input.hasNext())\n-\t\t{\n-\t\t\tmatchTerms.clear();\n-\t\t\tfinal T token = input.peek();\n-\t\t\tif (stepper.step(token, matchTerms))\n-\t\t\t{\n-\t\t\t\tinput.matchedPeek(matchTerms); // tell input who matched\n-\t\t\t\tinput.next(); // consume the term and continue\n-\t\t\t}\n-\t\t\telse\n-\t\t\t{\n-\t\t\t\treturn false;\n-\t\t\t}\n-\t\t}\n-\t\treturn stepper.step(null, null);\n-\t}\n-\n-\tpublic RegExMachine<E, T> createRegExMachine(final List<E> followers)\n-\t{\n-\t\treturn new NfaStepper<E, T>(m_initialState, followers, m_bridge);\n-\t}\n-\n-\t/**\n-\t * Returns terms that could follow the given token. if token if null, returns possible first terms.\n-\t * \n-\t * @param token\n-\t *            token or null\n-\t * @return List of PatternTerm\n-\t */\n-\tpublic List<E> getFollowers(T token)\n-\t{\n-\t\tfinal List<E> followers = new ArrayList<E>(23);\n-\t\tif (token == null)\n-\t\t{\n-\t\t\taddFollowers(m_initialState, followers, new ArrayList<NfaMatchState<E>>(23));\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tfinal List<NfaMatchState<E>> states = new ArrayList<NfaMatchState<E>>(23);\n-\t\t\taddStatesToVector(m_initialState, states);\n-\t\t\tfor (final NfaMatchState<E> s : states)\n-\t\t\t{\n-\t\t\t\tif (s.getTerm() != null && m_bridge.matches(s.getTerm(), token))\n-\t\t\t\t{\n-\t\t\t\t\tfinal List<NfaMatchState<E>> matchStates = s.nextStates();\n-\t\t\t\t\tfinal int count = matchStates.size();\n-\t\t\t\t\tfor (int index = 0; index < count; index++)\n-\t\t\t\t\t{\n-\t\t\t\t\t\taddFollowers(matchStates.get(index), followers, new ArrayList<NfaMatchState<E>>(23));\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn followers;\n-\t}\n-\n-\t/**\n-\t * add all leaf terms that could directly follow the given state.\n-\t * \n-\t * @param followers\n-\t *            a List of PatternTerm.\n-\t */\n-\tprotected void addFollowers(NfaMatchState<E> curState, List<E> followers, List<NfaMatchState<E>> visited)\n-\t{\n-\t\tif (curState.getTerm() == null)\n-\t\t{\n-\t\t\t// avoid infinite loop in case of (a?)*\n-\t\t\tif (visited.indexOf(curState) == -1)\n-\t\t\t{\n-\t\t\t\tvisited.add(curState);\n-\t\t\t\tfinal List<NfaMatchState<E>> matchStates = curState.nextStates();\n-\t\t\t\tfinal int count = matchStates.size();\n-\t\t\t\tfor (int index = 0; index < count; index++)\n-\t\t\t\t{\n-\t\t\t\t\taddFollowers(matchStates.get(index), followers, visited);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\telse if (followers.indexOf(curState.getTerm()) == -1 && curState.getTerm().toString() != null)\n-\t\t{\n-\t\t\tfollowers.add(curState.getTerm());\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * returns whether this pattern is deterministic or not, based on the XML/SGML definition. Non-determinism is\n-\t * allowed in the state machine, but only if alternate paths are based on the same PatternTerm. See Unique Particle\n-\t * Attribute Constraint in XML Schema Structures.\n-\t * \n-\t * @return true if deterministic\n-\t */\n-\t/*\n-\t * public boolean isDeterministic() { return (getPairOffendingDeterministic() == null); }\n-\t */\n-\n-\t/*\n-\t * public RegExPair<E, E> getPairOffendingDeterministic() { // TODO: This doesn't seem right. Shouldn't we consider\n-\t * states that have an exit condition too? // Create a list containing all the states in the NFA. final\n-\t * List<NfaMatchState<E>> states = new ArrayList<NfaMatchState<E>>(23); addStatesToVector(m_initialState, states);\n-\t * \n-\t * final List<NfaMatchState<E>> visited = new ArrayList<NfaMatchState<E>>(23); for (final NfaMatchState<E> s :\n-\t * states) { // If the state has no exit condition... if (s.getTerm() == null) { final List<E> followers = new\n-\t * ArrayList<E>(23); addFollowers(s, followers, visited); // check for duplicates for (int j = 0; j <\n-\t * followers.size() - 1; j++) { final E a = followers.get(j); for (int k = j + 1; k < followers.size(); k++) { final\n-\t * E b = followers.get(k); // don't count as duplicate if terms are the same. Happens for // patterns like\n-\t * ((a|b*)+), which get converted to ((a|b*),(a|b*)*) // since + is not handled by the state machine. if (a != b &&\n-\t * m_bridge.intersects(a, b)) { return new RegExPair<E, E>(a, b); // has duplicate followers, so it's not\n-\t * deterministic } } } } } return null; }\n-\t */\n-\n-\t/**\n-\t * Prints a text representation of the state machine for debugging purposes. For each state, the output is: state\n-\t * number, term accepted at that state, and a list of follower states. For example, below is a state machine for\n-\t * (a*,(b|c)):\n-\t * \n-\t * <PRE>\n-\t * 0  ==&gt;  1\n-\t * 1  ==&gt;  2 3\n-\t * 2 a ==&gt;  1\n-\t * 3  ==&gt;  4 6\n-\t * 4 b ==&gt;  5\n-\t * 5  ==&gt;\n-\t * 6 c ==&gt;  5\n-\t * </PRE>\n-\t * \n-\t * 0 is the start state, and 5 is the end state.\n-\t * <p/>\n-\t * A state can be entered if the current token matches the state's term.\n-\t * \n-\t * @return multi-line String\n-\t */\n-\tpublic String toString()\n-\t{\n-\t\tfinal StringBuilder sb = new StringBuilder();\n-\t\tfinal List<NfaMatchState<E>> states = new ArrayList<NfaMatchState<E>>(23);\n-\t\taddStatesToVector(m_initialState, states);\n-\t\tfor (int i = 0; i < states.size(); i++)\n-\t\t{\n-\t\t\tsb.append(\"#\").append(i).append(\" \");\n-\t\t\tfinal NfaMatchState<E> s = states.get(i);\n-\t\t\tif (s.getTerm() != null)\n-\t\t\t{\n-\t\t\t\tsb.append(s.getTerm().toString());\n-\t\t\t}\n-\t\t\tsb.append(\" ==> \");\n-\t\t\tList<NfaMatchState<E>> matchStates = s.nextStates();\n-\t\t\tint count = matchStates.size();\n-\t\t\tfor (int index = 0; index < count; index++)\n-\t\t\t{\n-\t\t\t\tNfaMatchState<E> next = matchStates.get(index);\n-\t\t\t\tsb.append(\" \").append(states.indexOf(next));\n-\t\t\t}\n-\t\t\tsb.append('\\n');\n-\t\t}\n-\t\treturn sb.toString();\n-\t}\n-\n-\t/**\n-\t * For debugging.\n-\t * \n-\t * @param name\n-\t *            label to write out\n-\t */\n-\tprotected void printStateMachine(final String name)\n-\t{\n-\t\tSystem.out.print(\"Name = \" + name + toString());\n-\t}\n-\n-\t/**\n-\t * add new states starting at 'from' to the given List\n-\t */\n-\tprivate void addStatesToVector(final NfaMatchState<E> from, final List<NfaMatchState<E>> states)\n-\t{\n-\t\tif (states.indexOf(from) >= 0)\n-\t\t{\n-\t\t\treturn; // already added\n-\t\t}\n-\t\tstates.add(from);\n-\t\tfor (final NfaMatchState<E> matchState : from.nextStates())\n-\t\t{\n-\t\t\taddStatesToVector(matchState, states);\n-\t\t}\n-\t}\n+final class NfaPattern<E, T> extends Graph<E, NfaMatchState<E>> implements RegExPattern<E, T> {\n+    private final RegExBridge<E, T> m_bridge;\n+\n+    private NfaPattern(final NfaMatchState<E> initialState, final RegExBridge<E, T> bridge) {\n+        super(initialState);\n+        m_bridge = PreCondition.assertArgumentNotNull(bridge, \"bridge\");\n+    }\n+\n+    /**\n+     * Creates a pattern corresponding to the given term, which is a tree of terms.\n+     *\n+     * @param term the head term of the term model. We allow null which represents the lambda set.\n+     */\n+    static <E, T> NfaPattern<E, T> newPattern(final E term, final RegExBridge<E, T> bridge) {\n+        final NfaMatchState<E> initialState = NfaCompiler.compileNFA(term, bridge);\n+\n+        return new NfaPattern<E, T>(initialState, bridge);\n+\n+        // Can't use this yet till a*b bug is fixed.\n+        // graph.optimize();\n+    }\n+\n+    /**\n+     * Executes the state machine against the given input token stream.\n+     * <p/>\n+     * In case of failure, the input stream is left at the token that failed to match. The caller can use that to\n+     * determine where the mismatch lies for error reporting.\n+     *\n+     * @param input the input, which is a sequence of tokens\n+     * @return true if the input matches the pattern\n+     */\n+    public boolean matches(final RegExPatternInput<E, T> input) {\n+        return matches(input, null);\n+    }\n+\n+    /**\n+     * Executes the state machine against the given input token stream. Returns true if the input matches the pattern.\n+     * If the followers parameter is not null, it will be returned with possible leaf PatternTerms that could follow the\n+     * last matched-token.\n+     * <p>\n+     * In case of failure, the input stream is left at the token that failed to match. The caller can use that to\n+     * determine where the mismatch lies for error reporting.\n+     *\n+     * @param input     a PatternInput, advanced as needed.\n+     * @param followers an output List of PatternTerm.\n+     * @return true if the input matches the pattern\n+     */\n+    public boolean matches(final RegExPatternInput<E, T> input, final List<E> followers) {\n+        final NfaStepper<E, T> stepper = new NfaStepper<E, T>(m_initialState, followers, m_bridge);\n+        final List<E> matchTerms = new ArrayList<E>(23);\n+        while (input.hasNext()) {\n+            matchTerms.clear();\n+            final T token = input.peek();\n+            if (stepper.step(token, matchTerms)) {\n+                input.matchedPeek(matchTerms); // tell input who matched\n+                input.next(); // consume the term and continue\n+            } else {\n+                return false;\n+            }\n+        }\n+        return stepper.step(null, null);\n+    }\n+\n+    public RegExMachine<E, T> createRegExMachine(final List<E> followers) {\n+        return new NfaStepper<E, T>(m_initialState, followers, m_bridge);\n+    }\n+\n+    /**\n+     * Returns terms that could follow the given token. if token if null, returns possible first terms.\n+     *\n+     * @param token token or null\n+     * @return List of PatternTerm\n+     */\n+    public List<E> getFollowers(T token) {\n+        final List<E> followers = new ArrayList<E>(23);\n+        if (token == null) {\n+            addFollowers(m_initialState, followers, new ArrayList<NfaMatchState<E>>(23));\n+        } else {\n+            final List<NfaMatchState<E>> states = new ArrayList<NfaMatchState<E>>(23);\n+            addStatesToVector(m_initialState, states);\n+            for (final NfaMatchState<E> s : states) {\n+                if (s.getTerm() != null && m_bridge.matches(s.getTerm(), token)) {\n+                    final List<NfaMatchState<E>> matchStates = s.nextStates();\n+                    final int count = matchStates.size();\n+                    for (int index = 0; index < count; index++) {\n+                        addFollowers(matchStates.get(index), followers,\n+                            new ArrayList<NfaMatchState<E>>(23));\n+                    }\n+                }\n+            }\n+        }\n+        return followers;\n+    }\n+\n+    /**\n+     * add all leaf terms that could directly follow the given state.\n+     *\n+     * @param followers a List of PatternTerm.\n+     */\n+    protected void addFollowers(NfaMatchState<E> curState, List<E> followers,\n+                                List<NfaMatchState<E>> visited) {\n+        if (curState.getTerm() == null) {\n+            // avoid infinite loop in case of (a?)*\n+            if (visited.indexOf(curState) == -1) {\n+                visited.add(curState);\n+                final List<NfaMatchState<E>> matchStates = curState.nextStates();\n+                final int count = matchStates.size();\n+                for (int index = 0; index < count; index++) {\n+                    addFollowers(matchStates.get(index), followers, visited);\n+                }\n+            }\n+        } else if (followers.indexOf(curState.getTerm()) == -1 &&\n+            curState.getTerm().toString() != null) {\n+            followers.add(curState.getTerm());\n+        }\n+    }\n+\n+    /**\n+     * returns whether this pattern is deterministic or not, based on the XML/SGML definition. Non-determinism is\n+     * allowed in the state machine, but only if alternate paths are based on the same PatternTerm. See Unique Particle\n+     * Attribute Constraint in XML Schema Structures.\n+     *\n+     * @return true if deterministic\n+     */\n+    /*\n+     * public boolean isDeterministic() { return (getPairOffendingDeterministic() == null); }\n+     */\n+\n+    /*\n+     * public RegExPair<E, E> getPairOffendingDeterministic() { // TODO: This doesn't seem right. Shouldn't we consider\n+     * states that have an exit condition too? // Create a list containing all the states in the NFA. final\n+     * List<NfaMatchState<E>> states = new ArrayList<NfaMatchState<E>>(23); addStatesToVector(m_initialState, states);\n+     *\n+     * final List<NfaMatchState<E>> visited = new ArrayList<NfaMatchState<E>>(23); for (final NfaMatchState<E> s :\n+     * states) { // If the state has no exit condition... if (s.getTerm() == null) { final List<E> followers = new\n+     * ArrayList<E>(23); addFollowers(s, followers, visited); // check for duplicates for (int j = 0; j <\n+     * followers.size() - 1; j++) { final E a = followers.get(j); for (int k = j + 1; k < followers.size(); k++) { final\n+     * E b = followers.get(k); // don't count as duplicate if terms are the same. Happens for // patterns like\n+     * ((a|b*)+), which get converted to ((a|b*),(a|b*)*) // since + is not handled by the state machine. if (a != b &&\n+     * m_bridge.intersects(a, b)) { return new RegExPair<E, E>(a, b); // has duplicate followers, so it's not\n+     * deterministic } } } } } return null; }\n+     */\n+\n+    /**\n+     * Prints a text representation of the state machine for debugging purposes. For each state, the output is: state\n+     * number, term accepted at that state, and a list of follower states. For example, below is a state machine for\n+     * (a*,(b|c)):\n+     *\n+     * <PRE>\n+     * 0  ==&gt;  1\n+     * 1  ==&gt;  2 3\n+     * 2 a ==&gt;  1\n+     * 3  ==&gt;  4 6\n+     * 4 b ==&gt;  5\n+     * 5  ==&gt;\n+     * 6 c ==&gt;  5\n+     * </PRE>\n+     * <p>\n+     * 0 is the start state, and 5 is the end state.\n+     * <p/>\n+     * A state can be entered if the current token matches the state's term.\n+     *\n+     * @return multi-line String\n+     */\n+    public String toString() {\n+        final StringBuilder sb = new StringBuilder();\n+        final List<NfaMatchState<E>> states = new ArrayList<NfaMatchState<E>>(23);\n+        addStatesToVector(m_initialState, states);\n+        for (int i = 0; i < states.size(); i++) {\n+            sb.append(\"#\").append(i).append(\" \");\n+            final NfaMatchState<E> s = states.get(i);\n+            if (s.getTerm() != null) {\n+                sb.append(s.getTerm().toString());\n+            }\n+            sb.append(\" ==> \");\n+            List<NfaMatchState<E>> matchStates = s.nextStates();\n+            int count = matchStates.size();\n+            for (int index = 0; index < count; index++) {\n+                NfaMatchState<E> next = matchStates.get(index);\n+                sb.append(\" \").append(states.indexOf(next));\n+            }\n+            sb.append('\\n');\n+        }\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * For debugging.\n+     *\n+     * @param name label to write out\n+     */\n+    protected void printStateMachine(final String name) {\n+        System.out.print(\"Name = \" + name + toString());\n+    }\n+\n+    /**\n+     * add new states starting at 'from' to the given List\n+     */\n+    private void addStatesToVector(final NfaMatchState<E> from,\n+                                   final List<NfaMatchState<E>> states) {\n+        if (states.indexOf(from) >= 0) {\n+            return; // already added\n+        }\n+        states.add(from);\n+        for (final NfaMatchState<E> matchState : from.nextStates()) {\n+            addStatesToVector(matchState, states);\n+        }\n+    }\n }\n",
            "diff_size": 243
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/114/NfaPattern.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/codebuff/114/NfaPattern.java\nindex 2c9a419905a..1c0c7d3bf19 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/114/NfaPattern.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/codebuff/114/NfaPattern.java\n@@ -17,7 +17,6 @@ package org.genxdm.processor.w3c.xs.regex.nfa;\n \n import java.util.ArrayList;\n import java.util.List;\n-\n import org.genxdm.exceptions.PreCondition;\n import org.genxdm.processor.w3c.xs.regex.api.RegExBridge;\n import org.genxdm.processor.w3c.xs.regex.api.RegExMachine;\n@@ -29,246 +28,259 @@ import org.genxdm.processor.w3c.xs.regex.api.RegExPatternInput;\n  * A Pattern for representing and matching against regular expressions. Stores the pattern as a nondeterministic state\n  * machine. Can be used for XML content models or textual regular expressions.\n  */\n-final class NfaPattern<E, T> extends Graph<E, NfaMatchState<E>> implements RegExPattern<E, T>\n+\n+final class NfaPattern<E, T>\n+    extends Graph<E, NfaMatchState<E>>\n+    implements RegExPattern<E, T>\n {\n-\tprivate final RegExBridge<E, T> m_bridge;\n+    private final RegExBridge<E, T> m_bridge;\n+\n+    private NfaPattern(final NfaMatchState<E> initialState, final RegExBridge<E, T> bridge)\n+    {\n+        super(initialState);\n+        m_bridge = PreCondition.assertArgumentNotNull(bridge, \"bridge\");\n+    }\n+\n+    /**\n+     * Creates a pattern corresponding to the given term, which is a tree of terms.\n+     * \n+     * @param term\n+     *            the head term of the term model. We allow null which represents the lambda set.\n+     */\n+\n+    static <E, T> NfaPattern<E, T> newPattern(final E term, final RegExBridge<E, T> bridge)\n+    {\n+        final NfaMatchState<E> initialState = NfaCompiler.compileNFA(term, bridge);\n+        return new NfaPattern<E, T>(initialState, bridge);\n+\n+        // Can't use this yet till a*b bug is fixed.\n+        // graph.optimize();\n+    }\n+\n+    /**\n+     * Executes the state machine against the given input token stream.\n+     * <p/>\n+     * In case of failure, the input stream is left at the token that failed to match. The caller can use that to\n+     * determine where the mismatch lies for error reporting.\n+     * \n+     * @param input\n+     *            the input, which is a sequence of tokens\n+     * @return true if the input matches the pattern\n+     */\n+\n+    public boolean matches(final RegExPatternInput<E, T> input)\n+    {\n+        return matches(input, null);\n+    }\n+\n+    /**\n+     * Executes the state machine against the given input token stream. Returns true if the input matches the pattern.\n+     * If the followers parameter is not null, it will be returned with possible leaf PatternTerms that could follow the\n+     * last matched-token.\n+     * <p>\n+     * In case of failure, the input stream is left at the token that failed to match. The caller can use that to\n+     * determine where the mismatch lies for error reporting.\n+     * \n+     * @param input\n+     *            a PatternInput, advanced as needed.\n+     * @param followers\n+     *            an output List of PatternTerm.\n+     * @return true if the input matches the pattern\n+     */\n+\n+    public boolean matches(final RegExPatternInput<E, T> input, final List<E> followers)\n+    {\n+        final NfaStepper<E, T> stepper = new NfaStepper<E, T>(m_initialState, followers, m_bridge);\n+        final List<E> matchTerms = new ArrayList<E>(23);\n+        while (input.hasNext())\n+        {\n+            matchTerms.clear();\n+\n+            final T token = input.peek();\n+            if (stepper.step(token, matchTerms))\n+            {\n+                input.matchedPeek(matchTerms); // tell input who matched\n+                input.next(); // consume the term and continue\n+            }\n+            else\n+            {\n+                return false;\n+            }\n+        }\n+        return stepper.step(null, null);\n+    }\n+\n+    public RegExMachine<E, T> createRegExMachine(final List<E> followers)\n+    {\n+        return new NfaStepper<E, T>(m_initialState, followers, m_bridge);\n+    }\n \n-\tprivate NfaPattern(final NfaMatchState<E> initialState, final RegExBridge<E, T> bridge)\n-\t{\n-\t\tsuper(initialState);\n-\t\tm_bridge = PreCondition.assertArgumentNotNull(bridge, \"bridge\");\n-\t}\n+    /**\n+     * Returns terms that could follow the given token. if token if null, returns possible first terms.\n+     * \n+     * @param token\n+     *            token or null\n+     * @return List of PatternTerm\n+     */\n \n-\t/**\n-\t * Creates a pattern corresponding to the given term, which is a tree of terms.\n-\t * \n-\t * @param term\n-\t *            the head term of the term model. We allow null which represents the lambda set.\n-\t */\n-\tstatic <E, T> NfaPattern<E, T> newPattern(final E term, final RegExBridge<E, T> bridge)\n-\t{\n-\t\tfinal NfaMatchState<E> initialState = NfaCompiler.compileNFA(term, bridge);\n+    public List<E> getFollowers(T token)\n+    {\n+        final List<E> followers = new ArrayList<E>(23);\n+        if (token == null)\n+        {\n+            addFollowers(m_initialState, followers, new ArrayList<NfaMatchState<E>>(23));\n+        }\n+        else\n+        {\n+            final List<NfaMatchState<E>> states = new ArrayList<NfaMatchState<E>>(23);\n+            addStatesToVector(m_initialState, states);\n+            for (final NfaMatchState<E> s : states)\n+            {\n+                if (s.getTerm() != null && m_bridge.matches(s.getTerm(), token))\n+                {\n+                    final List<NfaMatchState<E>> matchStates = s.nextStates();\n+                    final int count = matchStates.size();\n+                    for (int index = 0; index < count; index++)\n+                    {\n+                        addFollowers(matchStates.get(index), followers, new ArrayList<NfaMatchState<E>>(23));\n+                    }\n+                }\n+            }\n+        }\n+        return followers;\n+    }\n \n-\t\treturn new NfaPattern<E, T>(initialState, bridge);\n+    /**\n+     * add all leaf terms that could directly follow the given state.\n+     * \n+     * @param followers\n+     *            a List of PatternTerm.\n+     */\n \n-\t\t// Can't use this yet till a*b bug is fixed.\n-\t\t// graph.optimize();\n-\t}\n+    protected void addFollowers(NfaMatchState<E> curState, List<E> followers, List<NfaMatchState<E>> visited)\n+    {\n+        if (curState.getTerm() == null)\n+        {\n+            // avoid infinite loop in case of (a?)*\n+            if (visited.indexOf(curState) == -1)\n+            {\n+                visited.add(curState);\n \n-\t/**\n-\t * Executes the state machine against the given input token stream.\n-\t * <p/>\n-\t * In case of failure, the input stream is left at the token that failed to match. The caller can use that to\n-\t * determine where the mismatch lies for error reporting.\n-\t * \n-\t * @param input\n-\t *            the input, which is a sequence of tokens\n-\t * @return true if the input matches the pattern\n-\t */\n-\tpublic boolean matches(final RegExPatternInput<E, T> input)\n-\t{\n-\t\treturn matches(input, null);\n-\t}\n+                final List<NfaMatchState<E>> matchStates = curState.nextStates();\n+                final int count = matchStates.size();\n+                for (int index = 0; index < count; index++)\n+                {\n+                    addFollowers(matchStates.get(index), followers, visited);\n+                }\n+            }\n+        }\n+        else if (followers.indexOf(curState.getTerm()) == -1 && curState.getTerm().toString() != null)\n+        {\n+            followers.add(curState.getTerm());\n+        }\n+    }\n \n-\t/**\n-\t * Executes the state machine against the given input token stream. Returns true if the input matches the pattern.\n-\t * If the followers parameter is not null, it will be returned with possible leaf PatternTerms that could follow the\n-\t * last matched-token.\n-\t * <p>\n-\t * In case of failure, the input stream is left at the token that failed to match. The caller can use that to\n-\t * determine where the mismatch lies for error reporting.\n-\t * \n-\t * @param input\n-\t *            a PatternInput, advanced as needed.\n-\t * @param followers\n-\t *            an output List of PatternTerm.\n-\t * @return true if the input matches the pattern\n-\t */\n-\tpublic boolean matches(final RegExPatternInput<E, T> input, final List<E> followers)\n-\t{\n-\t\tfinal NfaStepper<E, T> stepper = new NfaStepper<E, T>(m_initialState, followers, m_bridge);\n-\t\tfinal List<E> matchTerms = new ArrayList<E>(23);\n-\t\twhile (input.hasNext())\n-\t\t{\n-\t\t\tmatchTerms.clear();\n-\t\t\tfinal T token = input.peek();\n-\t\t\tif (stepper.step(token, matchTerms))\n-\t\t\t{\n-\t\t\t\tinput.matchedPeek(matchTerms); // tell input who matched\n-\t\t\t\tinput.next(); // consume the term and continue\n-\t\t\t}\n-\t\t\telse\n-\t\t\t{\n-\t\t\t\treturn false;\n-\t\t\t}\n-\t\t}\n-\t\treturn stepper.step(null, null);\n-\t}\n+    /**\n+     * returns whether this pattern is deterministic or not, based on the XML/SGML definition. Non-determinism is\n+     * allowed in the state machine, but only if alternate paths are based on the same PatternTerm. See Unique Particle\n+     * Attribute Constraint in XML Schema Structures.\n+     * \n+     * @return true if deterministic\n+     */\n+    /*\n+     * public boolean isDeterministic() { return (getPairOffendingDeterministic() == null); }\n+     */\n \n-\tpublic RegExMachine<E, T> createRegExMachine(final List<E> followers)\n-\t{\n-\t\treturn new NfaStepper<E, T>(m_initialState, followers, m_bridge);\n-\t}\n+    /*\n+     * public RegExPair<E, E> getPairOffendingDeterministic() { // TODO: This doesn't seem right. Shouldn't we consider\n+     * states that have an exit condition too? // Create a list containing all the states in the NFA. final\n+     * List<NfaMatchState<E>> states = new ArrayList<NfaMatchState<E>>(23); addStatesToVector(m_initialState, states);\n+     * \n+     * final List<NfaMatchState<E>> visited = new ArrayList<NfaMatchState<E>>(23); for (final NfaMatchState<E> s :\n+     * states) { // If the state has no exit condition... if (s.getTerm() == null) { final List<E> followers = new\n+     * ArrayList<E>(23); addFollowers(s, followers, visited); // check for duplicates for (int j = 0; j <\n+     * followers.size() - 1; j++) { final E a = followers.get(j); for (int k = j + 1; k < followers.size(); k++) { final\n+     * E b = followers.get(k); // don't count as duplicate if terms are the same. Happens for // patterns like\n+     * ((a|b*)+), which get converted to ((a|b*),(a|b*)*) // since + is not handled by the state machine. if (a != b &&\n+     * m_bridge.intersects(a, b)) { return new RegExPair<E, E>(a, b); // has duplicate followers, so it's not\n+     * deterministic } } } } } return null; }\n+     */\n \n-\t/**\n-\t * Returns terms that could follow the given token. if token if null, returns possible first terms.\n-\t * \n-\t * @param token\n-\t *            token or null\n-\t * @return List of PatternTerm\n-\t */\n-\tpublic List<E> getFollowers(T token)\n-\t{\n-\t\tfinal List<E> followers = new ArrayList<E>(23);\n-\t\tif (token == null)\n-\t\t{\n-\t\t\taddFollowers(m_initialState, followers, new ArrayList<NfaMatchState<E>>(23));\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tfinal List<NfaMatchState<E>> states = new ArrayList<NfaMatchState<E>>(23);\n-\t\t\taddStatesToVector(m_initialState, states);\n-\t\t\tfor (final NfaMatchState<E> s : states)\n-\t\t\t{\n-\t\t\t\tif (s.getTerm() != null && m_bridge.matches(s.getTerm(), token))\n-\t\t\t\t{\n-\t\t\t\t\tfinal List<NfaMatchState<E>> matchStates = s.nextStates();\n-\t\t\t\t\tfinal int count = matchStates.size();\n-\t\t\t\t\tfor (int index = 0; index < count; index++)\n-\t\t\t\t\t{\n-\t\t\t\t\t\taddFollowers(matchStates.get(index), followers, new ArrayList<NfaMatchState<E>>(23));\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn followers;\n-\t}\n+    /**\n+     * Prints a text representation of the state machine for debugging purposes. For each state, the output is: state\n+     * number, term accepted at that state, and a list of follower states. For example, below is a state machine for\n+     * (a*,(b|c)):\n+     * \n+     * <PRE>\n+     * 0  ==&gt;  1\n+     * 1  ==&gt;  2 3\n+     * 2 a ==&gt;  1\n+     * 3  ==&gt;  4 6\n+     * 4 b ==&gt;  5\n+     * 5  ==&gt;\n+     * 6 c ==&gt;  5\n+     * </PRE>\n+     * \n+     * 0 is the start state, and 5 is the end state.\n+     * <p/>\n+     * A state can be entered if the current token matches the state's term.\n+     * \n+     * @return multi-line String\n+     */\n \n-\t/**\n-\t * add all leaf terms that could directly follow the given state.\n-\t * \n-\t * @param followers\n-\t *            a List of PatternTerm.\n-\t */\n-\tprotected void addFollowers(NfaMatchState<E> curState, List<E> followers, List<NfaMatchState<E>> visited)\n-\t{\n-\t\tif (curState.getTerm() == null)\n-\t\t{\n-\t\t\t// avoid infinite loop in case of (a?)*\n-\t\t\tif (visited.indexOf(curState) == -1)\n-\t\t\t{\n-\t\t\t\tvisited.add(curState);\n-\t\t\t\tfinal List<NfaMatchState<E>> matchStates = curState.nextStates();\n-\t\t\t\tfinal int count = matchStates.size();\n-\t\t\t\tfor (int index = 0; index < count; index++)\n-\t\t\t\t{\n-\t\t\t\t\taddFollowers(matchStates.get(index), followers, visited);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\telse if (followers.indexOf(curState.getTerm()) == -1 && curState.getTerm().toString() != null)\n-\t\t{\n-\t\t\tfollowers.add(curState.getTerm());\n-\t\t}\n-\t}\n+    public String toString()\n+    {\n+        final StringBuilder sb = new StringBuilder();\n+        final List<NfaMatchState<E>> states = new ArrayList<NfaMatchState<E>>(23);\n+        addStatesToVector(m_initialState, states);\n+        for (int i = 0; i < states.size() ; i++)\n+        {\n+            sb.append(\"#\").append(i).append(\" \");\n \n-\t/**\n-\t * returns whether this pattern is deterministic or not, based on the XML/SGML definition. Non-determinism is\n-\t * allowed in the state machine, but only if alternate paths are based on the same PatternTerm. See Unique Particle\n-\t * Attribute Constraint in XML Schema Structures.\n-\t * \n-\t * @return true if deterministic\n-\t */\n-\t/*\n-\t * public boolean isDeterministic() { return (getPairOffendingDeterministic() == null); }\n-\t */\n+            final NfaMatchState<E> s = states.get(i);\n+            if (s.getTerm() != null)\n+            {\n+                sb.append(s.getTerm().toString());\n+            }\n+            sb.append(\" ==> \");\n+            List<NfaMatchState<E>> matchStates = s.nextStates();\n+            int count = matchStates.size();\n+            for (int index = 0; index < count; index++)\n+            {\n+                NfaMatchState<E> next = matchStates.get(index);\n+                sb.append(\" \").append(states.indexOf(next));\n+            }\n+            sb.append('\\n');\n+        }\n+        return sb.toString();\n+    }\n \n-\t/*\n-\t * public RegExPair<E, E> getPairOffendingDeterministic() { // TODO: This doesn't seem right. Shouldn't we consider\n-\t * states that have an exit condition too? // Create a list containing all the states in the NFA. final\n-\t * List<NfaMatchState<E>> states = new ArrayList<NfaMatchState<E>>(23); addStatesToVector(m_initialState, states);\n-\t * \n-\t * final List<NfaMatchState<E>> visited = new ArrayList<NfaMatchState<E>>(23); for (final NfaMatchState<E> s :\n-\t * states) { // If the state has no exit condition... if (s.getTerm() == null) { final List<E> followers = new\n-\t * ArrayList<E>(23); addFollowers(s, followers, visited); // check for duplicates for (int j = 0; j <\n-\t * followers.size() - 1; j++) { final E a = followers.get(j); for (int k = j + 1; k < followers.size(); k++) { final\n-\t * E b = followers.get(k); // don't count as duplicate if terms are the same. Happens for // patterns like\n-\t * ((a|b*)+), which get converted to ((a|b*),(a|b*)*) // since + is not handled by the state machine. if (a != b &&\n-\t * m_bridge.intersects(a, b)) { return new RegExPair<E, E>(a, b); // has duplicate followers, so it's not\n-\t * deterministic } } } } } return null; }\n-\t */\n+    /**\n+     * For debugging.\n+     * \n+     * @param name\n+     *            label to write out\n+     */\n \n-\t/**\n-\t * Prints a text representation of the state machine for debugging purposes. For each state, the output is: state\n-\t * number, term accepted at that state, and a list of follower states. For example, below is a state machine for\n-\t * (a*,(b|c)):\n-\t * \n-\t * <PRE>\n-\t * 0  ==&gt;  1\n-\t * 1  ==&gt;  2 3\n-\t * 2 a ==&gt;  1\n-\t * 3  ==&gt;  4 6\n-\t * 4 b ==&gt;  5\n-\t * 5  ==&gt;\n-\t * 6 c ==&gt;  5\n-\t * </PRE>\n-\t * \n-\t * 0 is the start state, and 5 is the end state.\n-\t * <p/>\n-\t * A state can be entered if the current token matches the state's term.\n-\t * \n-\t * @return multi-line String\n-\t */\n-\tpublic String toString()\n-\t{\n-\t\tfinal StringBuilder sb = new StringBuilder();\n-\t\tfinal List<NfaMatchState<E>> states = new ArrayList<NfaMatchState<E>>(23);\n-\t\taddStatesToVector(m_initialState, states);\n-\t\tfor (int i = 0; i < states.size(); i++)\n-\t\t{\n-\t\t\tsb.append(\"#\").append(i).append(\" \");\n-\t\t\tfinal NfaMatchState<E> s = states.get(i);\n-\t\t\tif (s.getTerm() != null)\n-\t\t\t{\n-\t\t\t\tsb.append(s.getTerm().toString());\n-\t\t\t}\n-\t\t\tsb.append(\" ==> \");\n-\t\t\tList<NfaMatchState<E>> matchStates = s.nextStates();\n-\t\t\tint count = matchStates.size();\n-\t\t\tfor (int index = 0; index < count; index++)\n-\t\t\t{\n-\t\t\t\tNfaMatchState<E> next = matchStates.get(index);\n-\t\t\t\tsb.append(\" \").append(states.indexOf(next));\n-\t\t\t}\n-\t\t\tsb.append('\\n');\n-\t\t}\n-\t\treturn sb.toString();\n-\t}\n+    protected void printStateMachine(final String name)\n+    {\n+        System.out.print(\"Name = \" + name + toString());\n+    }\n \n-\t/**\n-\t * For debugging.\n-\t * \n-\t * @param name\n-\t *            label to write out\n-\t */\n-\tprotected void printStateMachine(final String name)\n-\t{\n-\t\tSystem.out.print(\"Name = \" + name + toString());\n-\t}\n+    /**\n+     * add new states starting at 'from' to the given List\n+     */\n \n-\t/**\n-\t * add new states starting at 'from' to the given List\n-\t */\n-\tprivate void addStatesToVector(final NfaMatchState<E> from, final List<NfaMatchState<E>> states)\n-\t{\n-\t\tif (states.indexOf(from) >= 0)\n-\t\t{\n-\t\t\treturn; // already added\n-\t\t}\n-\t\tstates.add(from);\n-\t\tfor (final NfaMatchState<E> matchState : from.nextStates())\n-\t\t{\n-\t\t\taddStatesToVector(matchState, states);\n-\t\t}\n-\t}\n-}\n+    private void addStatesToVector(final NfaMatchState<E> from, final List<NfaMatchState<E>> states)\n+    {\n+        if (states.indexOf(from) >= 0)\n+        {\n+            return; // already added\n+        }\n+        states.add(from);\n+        for (final NfaMatchState<E> matchState : from.nextStates())\n+        {\n+            addStatesToVector(matchState, states);\n+        }\n+    }\n+}\n\\ No newline at end of file\n",
            "diff_size": 358
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "36",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/114/NfaPattern.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_random/114/NfaPattern.java\nindex 2c9a419905a..9c6109c7851 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/114/NfaPattern.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_random/114/NfaPattern.java\n@@ -31,7 +31,7 @@ import org.genxdm.processor.w3c.xs.regex.api.RegExPatternInput;\n  */\n final class NfaPattern<E, T> extends Graph<E, NfaMatchState<E>> implements RegExPattern<E, T>\n {\n-\tprivate final RegExBridge<E, T> m_bridge;\n+private final RegExBridge<E, T> m_bridge;\n \n \tprivate NfaPattern(final NfaMatchState<E> initialState, final RegExBridge<E, T> bridge)\n \t{\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "36",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/114/NfaPattern.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_three_grams/114/NfaPattern.java\nindex 2c9a419905a..652961546f7 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/114/NfaPattern.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_three_grams/114/NfaPattern.java\n@@ -31,7 +31,7 @@ import org.genxdm.processor.w3c.xs.regex.api.RegExPatternInput;\n  */\n final class NfaPattern<E, T> extends Graph<E, NfaMatchState<E>> implements RegExPattern<E, T>\n {\n-\tprivate final RegExBridge<E, T> m_bridge;\n+    private final RegExBridge<E, T> m_bridge;\n \n \tprivate NfaPattern(final NfaMatchState<E> initialState, final RegExBridge<E, T> bridge)\n \t{\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "intellij",
        "codebuff"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "styler_random",
        "styler_three_grams"
    ]
}