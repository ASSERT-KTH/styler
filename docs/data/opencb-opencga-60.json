{
    "project_name": "opencb-opencga",
    "error_id": "60",
    "information": {
        "errors": [
            {
                "line": "173",
                "severity": "error",
                "message": "Line is longer than 140 characters (found 141).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": "        }\n//        if (catalogManager == null) {\n//            throw new IllegalStateException(\"OpenCGA was not properly initialized. Please, check if the configuration files are reachable \"\n//                    + \"or properly defined.\");\n//        }\n",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "173",
                    "severity": "error",
                    "message": "Line is longer than 140 characters (found 141).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "173",
                    "severity": "error",
                    "message": "Line is longer than 140 characters (found 141).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/60/OpenCGAWSServer.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/intellij/60/OpenCGAWSServer.java\nindex 78de6c0d447..2ebf9d61329 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/60/OpenCGAWSServer.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/intellij/60/OpenCGAWSServer.java\n@@ -74,621 +74,621 @@ import static org.opencb.opencga.core.common.JacksonUtils.getExternalOpencgaObje\n @Produces(MediaType.APPLICATION_JSON)\n public class OpenCGAWSServer {\n \n-    @DefaultValue(\"v1\")\n-    @PathParam(\"apiVersion\")\n-    @ApiParam(name = \"apiVersion\", value = \"OpenCGA major version\", allowableValues = \"v1\", defaultValue = \"v1\")\n-    protected String apiVersion;\n-    protected String exclude;\n-    protected String include;\n-    protected int limit;\n-    protected long skip;\n-    protected boolean count;\n-    protected boolean lazy;\n-    protected String sessionId;\n+  @DefaultValue(\"v1\")\n+  @PathParam(\"apiVersion\")\n+  @ApiParam(name = \"apiVersion\", value = \"OpenCGA major version\", allowableValues = \"v1\", defaultValue = \"v1\")\n+  protected String apiVersion;\n+  protected String exclude;\n+  protected String include;\n+  protected int limit;\n+  protected long skip;\n+  protected boolean count;\n+  protected boolean lazy;\n+  protected String sessionId;\n \n-    @DefaultValue(\"\")\n-    @QueryParam(\"sid\")\n-    @ApiParam(value = \"Session id\", hidden = true)\n-    protected String dummySessionId;\n+  @DefaultValue(\"\")\n+  @QueryParam(\"sid\")\n+  @ApiParam(value = \"Session id\", hidden = true)\n+  protected String dummySessionId;\n \n-    @HeaderParam(\"Authorization\")\n-    @DefaultValue(\"Bearer \")\n-    @ApiParam(\"JWT Authentication token\")\n-    protected String authentication;\n+  @HeaderParam(\"Authorization\")\n+  @DefaultValue(\"Bearer \")\n+  @ApiParam(\"JWT Authentication token\")\n+  protected String authentication;\n \n-    protected UriInfo uriInfo;\n-    protected HttpServletRequest httpServletRequest;\n-    protected MultivaluedMap<String, String> params;\n-    private String requestDescription;\n+  protected UriInfo uriInfo;\n+  protected HttpServletRequest httpServletRequest;\n+  protected MultivaluedMap<String, String> params;\n+  private String requestDescription;\n \n-    protected String sessionIp;\n+  protected String sessionIp;\n \n-    protected long startTime;\n+  protected long startTime;\n \n-    protected Query query;\n-    protected QueryOptions queryOptions;\n+  protected Query query;\n+  protected QueryOptions queryOptions;\n \n-    private static ObjectWriter jsonObjectWriter;\n-    private static ObjectMapper jsonObjectMapper;\n+  private static ObjectWriter jsonObjectWriter;\n+  private static ObjectMapper jsonObjectMapper;\n \n-    protected static Logger logger; // = LoggerFactory.getLogger(this.getClass());\n+  protected static Logger logger; // = LoggerFactory.getLogger(this.getClass());\n \n-    protected static AtomicBoolean initialized;\n+  protected static AtomicBoolean initialized;\n \n-    protected static java.nio.file.Path opencgaHome;\n+  protected static java.nio.file.Path opencgaHome;\n \n-    protected static Configuration configuration;\n-    protected static CatalogManager catalogManager;\n+  protected static Configuration configuration;\n+  protected static CatalogManager catalogManager;\n \n-    protected static StorageConfiguration storageConfiguration;\n-    protected static StorageEngineFactory storageEngineFactory;\n-    protected static VariantStorageManager variantManager;\n+  protected static StorageConfiguration storageConfiguration;\n+  protected static StorageEngineFactory storageEngineFactory;\n+  protected static VariantStorageManager variantManager;\n \n-    private static final int DEFAULT_LIMIT = 2000;\n-    private static final int MAX_LIMIT = 5000;\n-    private static final int MAX_ID_SIZE = 100;\n+  private static final int DEFAULT_LIMIT = 2000;\n+  private static final int MAX_LIMIT = 5000;\n+  private static final int MAX_ID_SIZE = 100;\n \n-    private static String errorMessage;\n+  private static String errorMessage;\n \n-    static {\n-        initialized = new AtomicBoolean(false);\n+  static {\n+    initialized = new AtomicBoolean(false);\n \n-        jsonObjectMapper = getExternalOpencgaObjectMapper();\n-        jsonObjectMapper.addMixIn(GenericRecord.class, GenericRecordAvroJsonMixin.class);\n-        jsonObjectMapper.addMixIn(VariantStats.class, VariantStatsJsonMixin.class);\n-        jsonObjectMapper.addMixIn(Genotype.class, GenotypeJsonMixin.class);\n-        jsonObjectMapper.addMixIn(Alignment.AlignmentDifference.class, AlignmentDifferenceJsonMixin.class);\n+    jsonObjectMapper = getExternalOpencgaObjectMapper();\n+    jsonObjectMapper.addMixIn(GenericRecord.class, GenericRecordAvroJsonMixin.class);\n+    jsonObjectMapper.addMixIn(VariantStats.class, VariantStatsJsonMixin.class);\n+    jsonObjectMapper.addMixIn(Genotype.class, GenotypeJsonMixin.class);\n+    jsonObjectMapper.addMixIn(Alignment.AlignmentDifference.class, AlignmentDifferenceJsonMixin.class);\n \n-        jsonObjectWriter = jsonObjectMapper.writer();\n+    jsonObjectWriter = jsonObjectMapper.writer();\n \n-        //Disable MongoDB useless logging\n-        org.apache.log4j.Logger.getLogger(\"org.mongodb.driver.cluster\").setLevel(Level.WARN);\n-        org.apache.log4j.Logger.getLogger(\"org.mongodb.driver.connection\").setLevel(Level.WARN);\n-    }\n+    //Disable MongoDB useless logging\n+    org.apache.log4j.Logger.getLogger(\"org.mongodb.driver.cluster\").setLevel(Level.WARN);\n+    org.apache.log4j.Logger.getLogger(\"org.mongodb.driver.connection\").setLevel(Level.WARN);\n+  }\n \n \n-    public OpenCGAWSServer(@Context UriInfo uriInfo, @Context HttpServletRequest httpServletRequest, @Context HttpHeaders httpHeaders)\n-            throws IOException, VersionException {\n-        this(uriInfo.getPathParameters().getFirst(\"apiVersion\"), uriInfo, httpServletRequest, httpHeaders);\n-    }\n+  public OpenCGAWSServer(@Context UriInfo uriInfo, @Context HttpServletRequest httpServletRequest, @Context HttpHeaders httpHeaders)\n+      throws IOException, VersionException {\n+    this(uriInfo.getPathParameters().getFirst(\"apiVersion\"), uriInfo, httpServletRequest, httpHeaders);\n+  }\n \n-    public OpenCGAWSServer(@PathParam(\"apiVersion\") String version, @Context UriInfo uriInfo,\n-                           @Context HttpServletRequest httpServletRequest, @Context HttpHeaders httpHeaders)\n-            throws VersionException {\n-        this.apiVersion = version;\n-        this.uriInfo = uriInfo;\n-        this.httpServletRequest = httpServletRequest;\n+  public OpenCGAWSServer(@PathParam(\"apiVersion\") String version, @Context UriInfo uriInfo,\n+                         @Context HttpServletRequest httpServletRequest, @Context HttpHeaders httpHeaders)\n+      throws VersionException {\n+    this.apiVersion = version;\n+    this.uriInfo = uriInfo;\n+    this.httpServletRequest = httpServletRequest;\n \n-        this.params = uriInfo.getQueryParameters();\n+    this.params = uriInfo.getQueryParameters();\n \n-        // This is only executed the first time to initialize configuration and some variables\n-        if (initialized.compareAndSet(false, true)) {\n-            init();\n-        }\n+    // This is only executed the first time to initialize configuration and some variables\n+    if (initialized.compareAndSet(false, true)) {\n+      init();\n+    }\n \n-        if (StringUtils.isNotEmpty(errorMessage)) {\n-            throw new IllegalStateException(errorMessage);\n-        }\n+    if (StringUtils.isNotEmpty(errorMessage)) {\n+      throw new IllegalStateException(errorMessage);\n+    }\n //        if (catalogManager == null) {\n //            throw new IllegalStateException(\"OpenCGA was not properly initialized. Please, check if the configuration files are reachable \"\n //                    + \"or properly defined.\");\n //        }\n \n-        try {\n-            verifyHeaders(httpHeaders);\n-        } catch (CatalogAuthenticationException e) {\n-            throw new IllegalStateException(e);\n-        }\n+    try {\n+      verifyHeaders(httpHeaders);\n+    } catch (CatalogAuthenticationException e) {\n+      throw new IllegalStateException(e);\n+    }\n \n-        query = new Query();\n-        queryOptions = new QueryOptions();\n-\n-        parseParams();\n-        // take the time for calculating the whole duration of the call\n-        startTime = System.currentTimeMillis();\n-    }\n-\n-    private void init() {\n-        logger = LoggerFactory.getLogger(\"org.opencb.opencga.server.rest.OpenCGAWSServer\");\n-        logger.info(\"========================================================================\");\n-        logger.info(\"| Starting OpenCGA REST server, initializing OpenCGAWSServer\");\n-        logger.info(\"| This message must appear only once.\");\n-\n-        // We must load the configuration files and init catalogManager, storageManagerFactory and Logger only the first time.\n-        // We first read 'config-dir' parameter passed\n-        ServletContext context = httpServletRequest.getServletContext();\n-        String configDirString = context.getInitParameter(\"config-dir\");\n-        if (StringUtils.isEmpty(configDirString)) {\n-            // If not environment variable then we check web.xml parameter\n-            if (StringUtils.isNotEmpty(context.getInitParameter(\"OPENCGA_HOME\"))) {\n-                configDirString = context.getInitParameter(\"OPENCGA_HOME\") + \"/conf\";\n-            } else if (StringUtils.isNotEmpty(System.getenv(\"OPENCGA_HOME\"))) {\n-                // If not exists then we try the environment variable OPENCGA_HOME\n-                configDirString = System.getenv(\"OPENCGA_HOME\") + \"/conf\";\n-            } else {\n-                logger.error(\"No valid configuration directory provided!\");\n-            }\n-        }\n+    query = new Query();\n+    queryOptions = new QueryOptions();\n+\n+    parseParams();\n+    // take the time for calculating the whole duration of the call\n+    startTime = System.currentTimeMillis();\n+  }\n+\n+  private void init() {\n+    logger = LoggerFactory.getLogger(\"org.opencb.opencga.server.rest.OpenCGAWSServer\");\n+    logger.info(\"========================================================================\");\n+    logger.info(\"| Starting OpenCGA REST server, initializing OpenCGAWSServer\");\n+    logger.info(\"| This message must appear only once.\");\n+\n+    // We must load the configuration files and init catalogManager, storageManagerFactory and Logger only the first time.\n+    // We first read 'config-dir' parameter passed\n+    ServletContext context = httpServletRequest.getServletContext();\n+    String configDirString = context.getInitParameter(\"config-dir\");\n+    if (StringUtils.isEmpty(configDirString)) {\n+      // If not environment variable then we check web.xml parameter\n+      if (StringUtils.isNotEmpty(context.getInitParameter(\"OPENCGA_HOME\"))) {\n+        configDirString = context.getInitParameter(\"OPENCGA_HOME\") + \"/conf\";\n+      } else if (StringUtils.isNotEmpty(System.getenv(\"OPENCGA_HOME\"))) {\n+        // If not exists then we try the environment variable OPENCGA_HOME\n+        configDirString = System.getenv(\"OPENCGA_HOME\") + \"/conf\";\n+      } else {\n+        logger.error(\"No valid configuration directory provided!\");\n+      }\n+    }\n \n-        // Check and execute the init methods\n-        java.nio.file.Path configDirPath = Paths.get(configDirString);\n-        opencgaHome = configDirPath.getParent();\n+    // Check and execute the init methods\n+    java.nio.file.Path configDirPath = Paths.get(configDirString);\n+    opencgaHome = configDirPath.getParent();\n \n-        if (Files.exists(configDirPath) && Files.isDirectory(configDirPath)) {\n-            logger.info(\"|  * Configuration folder: '{}'\", configDirPath.toString());\n-            initOpenCGAObjects(configDirPath);\n+    if (Files.exists(configDirPath) && Files.isDirectory(configDirPath)) {\n+      logger.info(\"|  * Configuration folder: '{}'\", configDirPath.toString());\n+      initOpenCGAObjects(configDirPath);\n \n-            // Required for reading the analysis.properties file.\n-            // TODO: Remove when analysis.properties is totally migrated to configuration.yml\n+      // Required for reading the analysis.properties file.\n+      // TODO: Remove when analysis.properties is totally migrated to configuration.yml\n //            Config.setOpenCGAHome(configDirPath.getParent().toString());\n \n-            // TODO use configuration.yml for getting the server.log, for now is hardcoded\n-            logger.info(\"|  * Server logfile: \" + opencgaHome.resolve(\"logs\").resolve(\"server.log\"));\n-            initLogger(opencgaHome.resolve(\"logs\"));\n-        } else {\n-            errorMessage = \"No valid configuration directory provided: '\" + configDirString + \"'\";\n-            logger.error(errorMessage);\n-        }\n-\n-        logger.info(\"========================================================================\\n\");\n-    }\n-\n-    /**\n-     * This method loads OpenCGA configuration files and initialize CatalogManager and StorageManagerFactory.\n-     * This must be only executed once.\n-     *\n-     * @param configDir directory containing the configuration files\n-     */\n-    private void initOpenCGAObjects(java.nio.file.Path configDir) {\n-        try {\n-            logger.info(\"|  * Catalog configuration file: '{}'\", configDir.toFile().getAbsolutePath() + \"/configuration.yml\");\n-            configuration = Configuration\n-                    .load(new FileInputStream(new File(configDir.toFile().getAbsolutePath() + \"/configuration.yml\")));\n-            catalogManager = new CatalogManager(configuration);\n-\n-            logger.info(\"|  * Storage configuration file: '{}'\", configDir.toFile().getAbsolutePath() + \"/storage-configuration.yml\");\n-            storageConfiguration = StorageConfiguration\n-                    .load(new FileInputStream(new File(configDir.toFile().getAbsolutePath() + \"/storage-configuration.yml\")));\n-            storageEngineFactory = StorageEngineFactory.get(storageConfiguration);\n-            variantManager = new VariantStorageManager(catalogManager, storageEngineFactory);\n-        } catch (IOException | CatalogException e) {\n-            errorMessage = e.getMessage();\n-            e.printStackTrace();\n-            logger.error(\"Error while creating CatalogManager\", e);\n-        }\n+      // TODO use configuration.yml for getting the server.log, for now is hardcoded\n+      logger.info(\"|  * Server logfile: \" + opencgaHome.resolve(\"logs\").resolve(\"server.log\"));\n+      initLogger(opencgaHome.resolve(\"logs\"));\n+    } else {\n+      errorMessage = \"No valid configuration directory provided: '\" + configDirString + \"'\";\n+      logger.error(errorMessage);\n     }\n \n-    private void initLogger(java.nio.file.Path logs) {\n-        try {\n-            org.apache.log4j.Logger rootLogger = LogManager.getRootLogger();\n-            PatternLayout layout = new PatternLayout(\"%d{yyyy-MM-dd HH:mm:ss} [%t] %-5p %c{1}:%L - %m%n\");\n-            String logFile = logs.resolve(\"server.log\").toString();\n-            RollingFileAppender rollingFileAppender = new RollingFileAppender(layout, logFile, true);\n-            rollingFileAppender.setThreshold(Level.DEBUG);\n-            rollingFileAppender.setMaxFileSize(\"20MB\");\n-            rollingFileAppender.setMaxBackupIndex(10);\n-            rootLogger.setLevel(Level.TRACE);\n-            rootLogger.addAppender(rollingFileAppender);\n-        } catch (IOException e) {\n-            e.printStackTrace();\n-        }\n+    logger.info(\"========================================================================\\n\");\n+  }\n+\n+  /**\n+   * This method loads OpenCGA configuration files and initialize CatalogManager and StorageManagerFactory.\n+   * This must be only executed once.\n+   *\n+   * @param configDir directory containing the configuration files\n+   */\n+  private void initOpenCGAObjects(java.nio.file.Path configDir) {\n+    try {\n+      logger.info(\"|  * Catalog configuration file: '{}'\", configDir.toFile().getAbsolutePath() + \"/configuration.yml\");\n+      configuration = Configuration\n+          .load(new FileInputStream(new File(configDir.toFile().getAbsolutePath() + \"/configuration.yml\")));\n+      catalogManager = new CatalogManager(configuration);\n+\n+      logger.info(\"|  * Storage configuration file: '{}'\", configDir.toFile().getAbsolutePath() + \"/storage-configuration.yml\");\n+      storageConfiguration = StorageConfiguration\n+          .load(new FileInputStream(new File(configDir.toFile().getAbsolutePath() + \"/storage-configuration.yml\")));\n+      storageEngineFactory = StorageEngineFactory.get(storageConfiguration);\n+      variantManager = new VariantStorageManager(catalogManager, storageEngineFactory);\n+    } catch (IOException | CatalogException e) {\n+      errorMessage = e.getMessage();\n+      e.printStackTrace();\n+      logger.error(\"Error while creating CatalogManager\", e);\n     }\n-\n-    private void parseParams() throws VersionException {\n-        // If by any reason 'apiVersion' is null we try to read it from the URI path, if not present an Exception is thrown\n-        if (apiVersion == null) {\n-            if (uriInfo.getPathParameters().containsKey(\"apiVersion\")) {\n-                logger.warn(\"Setting 'apiVersion' from UriInfo object\");\n-                this.apiVersion = uriInfo.getPathParameters().getFirst(\"apiVersion\");\n-            } else {\n-                throw new VersionException(\"Version not valid: '\" + apiVersion + \"'\");\n-            }\n-        }\n-\n-        // Check apiVersion parameter, must be: v1, v2, ... If 'latest' then is converted to appropriate apiVersion.\n-        if (apiVersion.equalsIgnoreCase(\"latest\")) {\n-            logger.info(\"Version 'latest' detected, setting 'apiVersion' parameter to 'v1'\");\n-            apiVersion = \"v1\";\n-        }\n-\n-        MultivaluedMap<String, String> multivaluedMap = uriInfo.getQueryParameters();\n-        queryOptions.put(\"metadata\", multivaluedMap.get(\"metadata\") == null || multivaluedMap.get(\"metadata\").get(0).equals(\"true\"));\n-\n-        // By default, we will avoid counting the number of documents unless explicitly specified.\n-        queryOptions.put(QueryOptions.SKIP_COUNT, true);\n-\n-        // Add all the others QueryParams from the URL\n-        for (Map.Entry<String, List<String>> entry : multivaluedMap.entrySet()) {\n-            String value = entry.getValue().get(0);\n-            switch (entry.getKey()) {\n-                case QueryOptions.INCLUDE:\n-                case QueryOptions.EXCLUDE:\n-                    queryOptions.put(entry.getKey(), new LinkedList<>(Splitter.on(\",\").splitToList(value)));\n-                    break;\n-                case QueryOptions.LIMIT:\n-                    limit = Integer.parseInt(value);\n-                    break;\n-                case QueryOptions.TIMEOUT:\n-                    queryOptions.put(entry.getKey(), Integer.parseInt(value));\n-                    break;\n-                case QueryOptions.SKIP:\n-                    int skip = Integer.parseInt(value);\n-                    queryOptions.put(entry.getKey(), (skip >= 0) ? skip : -1);\n-                    break;\n-                case QueryOptions.SORT:\n-                case QueryOptions.ORDER:\n-                    queryOptions.put(entry.getKey(), value);\n-                    break;\n-                case QueryOptions.SKIP_COUNT:\n-                    queryOptions.put(QueryOptions.SKIP_COUNT, Boolean.parseBoolean(value));\n-                    break;\n-                case Constants.INCREMENT_VERSION:\n-                    queryOptions.put(Constants.INCREMENT_VERSION, Boolean.parseBoolean(value));\n-                    break;\n-                case Constants.REFRESH:\n-                    queryOptions.put(Constants.REFRESH, Boolean.parseBoolean(value));\n-                    break;\n-                case QueryOptions.COUNT:\n-                    count = Boolean.parseBoolean(value);\n-                    queryOptions.put(entry.getKey(), count);\n-                    break;\n-                case Constants.SILENT:\n-                    queryOptions.put(entry.getKey(), Boolean.parseBoolean(value));\n-                    break;\n-                case Constants.FORCE:\n-                    queryOptions.put(entry.getKey(), Boolean.parseBoolean(value));\n-                    break;\n-                case Constants.FLATTENED_ANNOTATIONS:\n-                    queryOptions.put(Constants.FLATTENED_ANNOTATIONS, Boolean.parseBoolean(value));\n-                    break;\n-                case \"includeIndividual\": // SampleWS\n-                    lazy = !Boolean.parseBoolean(value);\n-                    queryOptions.put(\"lazy\", lazy);\n-                    break;\n-                case \"lazy\":\n-                    lazy = Boolean.parseBoolean(value);\n-                    queryOptions.put(entry.getKey(), lazy);\n-                    break;\n-                case QueryOptions.FACET:\n-                    queryOptions.put(entry.getKey(), value);\n-                    break;\n-                default:\n-                    // Query\n-                    query.put(entry.getKey(), value);\n-                    break;\n-            }\n-        }\n-\n-        queryOptions.put(QueryOptions.LIMIT, (limit > 0) ? Math.min(limit, MAX_LIMIT) : DEFAULT_LIMIT);\n-        query.remove(\"sid\");\n-\n-//      Exceptions\n-        if (query.containsKey(\"status\")) {\n-            query.put(\"status.name\", query.get(\"status\"));\n-            query.remove(\"status\");\n-        }\n-\n-        // Remove deprecated fields\n-        query.remove(\"variableSet\");\n-        query.remove(\"annotationsetName\");\n-\n-        try {\n-            requestDescription = httpServletRequest.getMethod() + \": \" + uriInfo.getAbsolutePath().toString()\n-                    + \", \" + jsonObjectWriter.writeValueAsString(query)\n-                    + \", \" + jsonObjectWriter.writeValueAsString(queryOptions);\n-            logger.info(requestDescription);\n-        } catch (JsonProcessingException e) {\n-            requestDescription = httpServletRequest.getMethod() + \": \" + uriInfo.getRequestUri();\n-            logger.info(requestDescription);\n-            logger.error(\"Error writing as Json\", e);\n-        }\n+  }\n+\n+  private void initLogger(java.nio.file.Path logs) {\n+    try {\n+      org.apache.log4j.Logger rootLogger = LogManager.getRootLogger();\n+      PatternLayout layout = new PatternLayout(\"%d{yyyy-MM-dd HH:mm:ss} [%t] %-5p %c{1}:%L - %m%n\");\n+      String logFile = logs.resolve(\"server.log\").toString();\n+      RollingFileAppender rollingFileAppender = new RollingFileAppender(layout, logFile, true);\n+      rollingFileAppender.setThreshold(Level.DEBUG);\n+      rollingFileAppender.setMaxFileSize(\"20MB\");\n+      rollingFileAppender.setMaxBackupIndex(10);\n+      rootLogger.setLevel(Level.TRACE);\n+      rootLogger.addAppender(rollingFileAppender);\n+    } catch (IOException e) {\n+      e.printStackTrace();\n     }\n-\n-    private void parseIncludeExclude(MultivaluedMap<String, String> multivaluedMap, String key, String value) {\n-        if (value != null && !value.isEmpty()) {\n-            queryOptions.put(key, new LinkedList<>(Splitter.on(\",\").splitToList(value)));\n-        } else {\n-            queryOptions.put(key, (multivaluedMap.get(key) != null)\n-                    ? Splitter.on(\",\").splitToList(multivaluedMap.get(key).get(0))\n-                    : null);\n-        }\n+  }\n+\n+  private void parseParams() throws VersionException {\n+    // If by any reason 'apiVersion' is null we try to read it from the URI path, if not present an Exception is thrown\n+    if (apiVersion == null) {\n+      if (uriInfo.getPathParameters().containsKey(\"apiVersion\")) {\n+        logger.warn(\"Setting 'apiVersion' from UriInfo object\");\n+        this.apiVersion = uriInfo.getPathParameters().getFirst(\"apiVersion\");\n+      } else {\n+        throw new VersionException(\"Version not valid: '\" + apiVersion + \"'\");\n+      }\n     }\n \n-\n-    protected void addParamIfNotNull(Map<String, String> params, String key, Object value) {\n-        if (key != null && value != null) {\n-            params.put(key, value.toString());\n-        }\n+    // Check apiVersion parameter, must be: v1, v2, ... If 'latest' then is converted to appropriate apiVersion.\n+    if (apiVersion.equalsIgnoreCase(\"latest\")) {\n+      logger.info(\"Version 'latest' detected, setting 'apiVersion' parameter to 'v1'\");\n+      apiVersion = \"v1\";\n     }\n \n-    protected void addParamIfTrue(Map<String, String> params, String key, boolean value) {\n-        if (key != null && value) {\n-            params.put(key, Boolean.toString(value));\n-        }\n+    MultivaluedMap<String, String> multivaluedMap = uriInfo.getQueryParameters();\n+    queryOptions.put(\"metadata\", multivaluedMap.get(\"metadata\") == null || multivaluedMap.get(\"metadata\").get(0).equals(\"true\"));\n+\n+    // By default, we will avoid counting the number of documents unless explicitly specified.\n+    queryOptions.put(QueryOptions.SKIP_COUNT, true);\n+\n+    // Add all the others QueryParams from the URL\n+    for (Map.Entry<String, List<String>> entry : multivaluedMap.entrySet()) {\n+      String value = entry.getValue().get(0);\n+      switch (entry.getKey()) {\n+        case QueryOptions.INCLUDE:\n+        case QueryOptions.EXCLUDE:\n+          queryOptions.put(entry.getKey(), new LinkedList<>(Splitter.on(\",\").splitToList(value)));\n+          break;\n+        case QueryOptions.LIMIT:\n+          limit = Integer.parseInt(value);\n+          break;\n+        case QueryOptions.TIMEOUT:\n+          queryOptions.put(entry.getKey(), Integer.parseInt(value));\n+          break;\n+        case QueryOptions.SKIP:\n+          int skip = Integer.parseInt(value);\n+          queryOptions.put(entry.getKey(), (skip >= 0) ? skip : -1);\n+          break;\n+        case QueryOptions.SORT:\n+        case QueryOptions.ORDER:\n+          queryOptions.put(entry.getKey(), value);\n+          break;\n+        case QueryOptions.SKIP_COUNT:\n+          queryOptions.put(QueryOptions.SKIP_COUNT, Boolean.parseBoolean(value));\n+          break;\n+        case Constants.INCREMENT_VERSION:\n+          queryOptions.put(Constants.INCREMENT_VERSION, Boolean.parseBoolean(value));\n+          break;\n+        case Constants.REFRESH:\n+          queryOptions.put(Constants.REFRESH, Boolean.parseBoolean(value));\n+          break;\n+        case QueryOptions.COUNT:\n+          count = Boolean.parseBoolean(value);\n+          queryOptions.put(entry.getKey(), count);\n+          break;\n+        case Constants.SILENT:\n+          queryOptions.put(entry.getKey(), Boolean.parseBoolean(value));\n+          break;\n+        case Constants.FORCE:\n+          queryOptions.put(entry.getKey(), Boolean.parseBoolean(value));\n+          break;\n+        case Constants.FLATTENED_ANNOTATIONS:\n+          queryOptions.put(Constants.FLATTENED_ANNOTATIONS, Boolean.parseBoolean(value));\n+          break;\n+        case \"includeIndividual\": // SampleWS\n+          lazy = !Boolean.parseBoolean(value);\n+          queryOptions.put(\"lazy\", lazy);\n+          break;\n+        case \"lazy\":\n+          lazy = Boolean.parseBoolean(value);\n+          queryOptions.put(entry.getKey(), lazy);\n+          break;\n+        case QueryOptions.FACET:\n+          queryOptions.put(entry.getKey(), value);\n+          break;\n+        default:\n+          // Query\n+          query.put(entry.getKey(), value);\n+          break;\n+      }\n     }\n \n-    // Temporal method used by deprecated methods. This will be removed at some point.\n-    protected AclParams getAclParams(\n-            @ApiParam(value = \"Comma separated list of permissions to add\") @QueryParam(\"add\") String addPermissions,\n-            @ApiParam(value = \"Comma separated list of permissions to remove\") @QueryParam(\"remove\") String removePermissions,\n-            @ApiParam(value = \"Comma separated list of permissions to set\") @QueryParam(\"set\") String setPermissions)\n-            throws CatalogException {\n-        int count = 0;\n-        count += StringUtils.isNotEmpty(setPermissions) ? 1 : 0;\n-        count += StringUtils.isNotEmpty(addPermissions) ? 1 : 0;\n-        count += StringUtils.isNotEmpty(removePermissions) ? 1 : 0;\n-        if (count > 1) {\n-            throw new CatalogException(\"Only one of add, remove or set parameters are allowed.\");\n-        } else if (count == 0) {\n-            throw new CatalogException(\"One of add, remove or set parameters is expected.\");\n-        }\n-\n-        String permissions = null;\n-        AclParams.Action action = null;\n-        if (StringUtils.isNotEmpty(addPermissions)) {\n-            permissions = addPermissions;\n-            action = AclParams.Action.ADD;\n-        }\n-        if (StringUtils.isNotEmpty(setPermissions)) {\n-            permissions = setPermissions;\n-            action = AclParams.Action.SET;\n-        }\n-        if (StringUtils.isNotEmpty(removePermissions)) {\n-            permissions = removePermissions;\n-            action = AclParams.Action.REMOVE;\n-        }\n-        return new AclParams(permissions, action);\n-    }\n-\n-    @Deprecated\n-    @GET\n-    @Path(\"/help\")\n-    @ApiOperation(value = \"Help\", hidden = true, position = 1)\n-    public Response help() {\n-        return createErrorResponse(\"help\", \"No help available\");\n-    }\n-\n-    protected Response createErrorResponse(Exception e) {\n-        // First we print the exception in Server logs\n-        logger.error(\"Catch error: \" + e.getMessage(), e);\n-\n-        // Now we prepare the response to client\n-        QueryResponse<ObjectMap> queryResponse = new QueryResponse<>();\n-        queryResponse.setTime(new Long(System.currentTimeMillis() - startTime).intValue());\n-        queryResponse.setApiVersion(apiVersion);\n-        queryResponse.setQueryOptions(queryOptions);\n-        if (StringUtils.isEmpty(e.getMessage())) {\n-            queryResponse.setError(e.toString());\n-        } else {\n-            queryResponse.setError(e.getMessage());\n-        }\n+    queryOptions.put(QueryOptions.LIMIT, (limit > 0) ? Math.min(limit, MAX_LIMIT) : DEFAULT_LIMIT);\n+    query.remove(\"sid\");\n \n-        QueryResult<ObjectMap> result = new QueryResult<>();\n-        result.setWarningMsg(\"Future errors will ONLY be shown in the QueryResponse body\");\n-        result.setErrorMsg(\"DEPRECATED: \" + e.toString());\n-        queryResponse.setResponse(Arrays.asList(result));\n-\n-        Response.Status errorStatus = Response.Status.INTERNAL_SERVER_ERROR;\n-        if (e instanceof CatalogAuthorizationException) {\n-            errorStatus = Response.Status.FORBIDDEN;\n-        } else if (e instanceof CatalogAuthenticationException) {\n-            errorStatus = Response.Status.UNAUTHORIZED;\n-        }\n-\n-        Response response = Response.fromResponse(createJsonResponse(queryResponse)).status(errorStatus).build();\n-        logResponse(response.getStatusInfo(), queryResponse);\n-        return response;\n+//      Exceptions\n+    if (query.containsKey(\"status\")) {\n+      query.put(\"status.name\", query.get(\"status\"));\n+      query.remove(\"status\");\n     }\n \n-    protected Response createErrorResponse(String errorMessage, QueryResult result) {\n-\n-        QueryResponse<ObjectMap> queryResponse = new QueryResponse<>();\n-        queryResponse.setApiVersion(apiVersion);\n-        queryResponse.setQueryOptions(queryOptions);\n-        queryResponse.setError(\"true\");\n-        result.setErrorMsg(\"DEPRECATED: \" + errorMessage);\n-        queryResponse.setResponse(Arrays.asList(result));\n-\n-        Response response = Response.fromResponse(createJsonResponse(queryResponse)).status(Response.Status.INTERNAL_SERVER_ERROR).build();\n-        logResponse(response.getStatusInfo(), queryResponse);\n-        return response;\n+    // Remove deprecated fields\n+    query.remove(\"variableSet\");\n+    query.remove(\"annotationsetName\");\n+\n+    try {\n+      requestDescription = httpServletRequest.getMethod() + \": \" + uriInfo.getAbsolutePath().toString()\n+          + \", \" + jsonObjectWriter.writeValueAsString(query)\n+          + \", \" + jsonObjectWriter.writeValueAsString(queryOptions);\n+      logger.info(requestDescription);\n+    } catch (JsonProcessingException e) {\n+      requestDescription = httpServletRequest.getMethod() + \": \" + uriInfo.getRequestUri();\n+      logger.info(requestDescription);\n+      logger.error(\"Error writing as Json\", e);\n     }\n+  }\n+\n+  private void parseIncludeExclude(MultivaluedMap<String, String> multivaluedMap, String key, String value) {\n+    if (value != null && !value.isEmpty()) {\n+      queryOptions.put(key, new LinkedList<>(Splitter.on(\",\").splitToList(value)));\n+    } else {\n+      queryOptions.put(key, (multivaluedMap.get(key) != null)\n+          ? Splitter.on(\",\").splitToList(multivaluedMap.get(key).get(0))\n+          : null);\n+    }\n+  }\n \n-    protected Response createErrorResponse(String method, String errorMessage) {\n-        try {\n-            Response response = buildResponse(Response.ok(jsonObjectWriter.writeValueAsString(new ObjectMap(\"error\", errorMessage)),\n-                    MediaType.APPLICATION_JSON_TYPE));\n-            logResponse(response.getStatusInfo());\n-            return response;\n-        } catch (JsonProcessingException e) {\n-            e.printStackTrace();\n-        }\n-\n-        return buildResponse(Response.ok(\"{\\\"error\\\":\\\"Error parsing json error\\\"}\", MediaType.APPLICATION_JSON_TYPE));\n-    }\n-\n-    // TODO: Change signature\n-    //    protected <T> Response createOkResponse(QueryResult<T> result)\n-    //    protected <T> Response createOkResponse(List<QueryResult<T>> results)\n-    protected Response createOkResponse(Object obj) {\n-        QueryResponse queryResponse = new QueryResponse();\n-        queryResponse.setTime(new Long(System.currentTimeMillis() - startTime).intValue());\n-        queryResponse.setApiVersion(apiVersion);\n-        queryResponse.setQueryOptions(queryOptions);\n-\n-        // Guarantee that the QueryResponse object contains a list of results\n-        List list;\n-        if (obj instanceof List) {\n-            list = (List) obj;\n-        } else {\n-            list = new ArrayList();\n-            if (!(obj instanceof QueryResult)) {\n-                list.add(new QueryResult<>(\"\", 0, 1, 1, \"\", \"\", Collections.singletonList(obj)));\n-            } else {\n-                list.add(obj);\n-            }\n-        }\n-        queryResponse.setResponse(list);\n \n-        Response response = createJsonResponse(queryResponse);\n-        logResponse(response.getStatusInfo(), queryResponse);\n-        return response;\n+  protected void addParamIfNotNull(Map<String, String> params, String key, Object value) {\n+    if (key != null && value != null) {\n+      params.put(key, value.toString());\n     }\n+  }\n \n-    protected Response createRawOkResponse(Object obj) {\n-        try {\n-            String res = jsonObjectWriter.writeValueAsString(obj);\n-//            System.out.println(\"\\n\\n\\n\" + res + \"\\n\\n\");\n-            Response response = buildResponse(Response.ok(res, MediaType.APPLICATION_JSON_TYPE));\n-            logResponse(response.getStatusInfo());\n-            return response;\n-        } catch (JsonProcessingException e) {\n-            e.printStackTrace();\n-            logger.error(\"Error parsing response object\");\n-            return createErrorResponse(\"\", \"Error parsing response object:\\n\" + Arrays.toString(e.getStackTrace()));\n-        }\n+  protected void addParamIfTrue(Map<String, String> params, String key, boolean value) {\n+    if (key != null && value) {\n+      params.put(key, Boolean.toString(value));\n     }\n-\n-    protected Response createAnalysisOkResponse(Object obj) {\n-        Map<String, Object> queryResponseMap = new LinkedHashMap<>();\n-        queryResponseMap.put(\"time\", new Long(System.currentTimeMillis() - startTime).intValue());\n-        queryResponseMap.put(\"apiVersion\", apiVersion);\n-        queryResponseMap.put(\"queryOptions\", queryOptions);\n-        queryResponseMap.put(\"response\", Collections.singletonList(obj));\n-\n-        Response response;\n-        try {\n-            response = buildResponse(Response.ok(jsonObjectWriter.writeValueAsString(queryResponseMap), MediaType.APPLICATION_JSON_TYPE));\n-            logResponse(response.getStatusInfo());\n-        } catch (JsonProcessingException e) {\n-            e.printStackTrace();\n-            logger.error(\"Error parsing queryResponse object\");\n-            return createErrorResponse(\"\", \"Error parsing QueryResponse object:\\n\" + Arrays.toString(e.getStackTrace()));\n-        }\n-\n-        return response;\n+  }\n+\n+  // Temporal method used by deprecated methods. This will be removed at some point.\n+  protected AclParams getAclParams(\n+      @ApiParam(value = \"Comma separated list of permissions to add\") @QueryParam(\"add\") String addPermissions,\n+      @ApiParam(value = \"Comma separated list of permissions to remove\") @QueryParam(\"remove\") String removePermissions,\n+      @ApiParam(value = \"Comma separated list of permissions to set\") @QueryParam(\"set\") String setPermissions)\n+      throws CatalogException {\n+    int count = 0;\n+    count += StringUtils.isNotEmpty(setPermissions) ? 1 : 0;\n+    count += StringUtils.isNotEmpty(addPermissions) ? 1 : 0;\n+    count += StringUtils.isNotEmpty(removePermissions) ? 1 : 0;\n+    if (count > 1) {\n+      throw new CatalogException(\"Only one of add, remove or set parameters are allowed.\");\n+    } else if (count == 0) {\n+      throw new CatalogException(\"One of add, remove or set parameters is expected.\");\n     }\n \n-    //Response methods\n-    protected Response createOkResponse(Object o1, MediaType o2) {\n-        return buildResponse(Response.ok(o1, o2));\n+    String permissions = null;\n+    AclParams.Action action = null;\n+    if (StringUtils.isNotEmpty(addPermissions)) {\n+      permissions = addPermissions;\n+      action = AclParams.Action.ADD;\n     }\n-\n-    protected Response createOkResponse(Object o1, MediaType o2, String fileName) {\n-        return buildResponse(Response.ok(o1, o2).header(\"content-disposition\", \"attachment; filename =\" + fileName));\n+    if (StringUtils.isNotEmpty(setPermissions)) {\n+      permissions = setPermissions;\n+      action = AclParams.Action.SET;\n     }\n-\n-    private void logResponse(Response.StatusType statusInfo) {\n-        logResponse(statusInfo, null);\n+    if (StringUtils.isNotEmpty(removePermissions)) {\n+      permissions = removePermissions;\n+      action = AclParams.Action.REMOVE;\n+    }\n+    return new AclParams(permissions, action);\n+  }\n+\n+  @Deprecated\n+  @GET\n+  @Path(\"/help\")\n+  @ApiOperation(value = \"Help\", hidden = true, position = 1)\n+  public Response help() {\n+    return createErrorResponse(\"help\", \"No help available\");\n+  }\n+\n+  protected Response createErrorResponse(Exception e) {\n+    // First we print the exception in Server logs\n+    logger.error(\"Catch error: \" + e.getMessage(), e);\n+\n+    // Now we prepare the response to client\n+    QueryResponse<ObjectMap> queryResponse = new QueryResponse<>();\n+    queryResponse.setTime(new Long(System.currentTimeMillis() - startTime).intValue());\n+    queryResponse.setApiVersion(apiVersion);\n+    queryResponse.setQueryOptions(queryOptions);\n+    if (StringUtils.isEmpty(e.getMessage())) {\n+      queryResponse.setError(e.toString());\n+    } else {\n+      queryResponse.setError(e.getMessage());\n     }\n \n-    private void logResponse(Response.StatusType statusInfo, QueryResponse<?> queryResponse) {\n-        StringBuilder sb = new StringBuilder();\n-        try {\n-            if (statusInfo.getFamily().equals(Response.Status.Family.SUCCESSFUL)) {\n-                sb.append(\"OK\");\n-            } else {\n-                sb.append(\"ERROR\");\n-            }\n-            sb.append(\" [\").append(statusInfo.getStatusCode()).append(']');\n-\n-            if (queryResponse == null) {\n-                sb.append(\", \").append(System.currentTimeMillis() - startTime).append(\"ms\");\n-            } else {\n-                sb.append(\", \").append(queryResponse.getTime()).append(\"ms\");\n-                if (queryResponse.getResponse().size() == 1) {\n-                    QueryResult<?> result = queryResponse.getResponse().get(0);\n-                    if (result != null) {\n-                        sb.append(\", num: \").append(result.getNumResults());\n-                        if (result.getNumTotalResults() >= 0) {\n-                            sb.append(\", total: \").append(result.getNumTotalResults());\n-                        }\n-                    }\n-                }\n-            }\n-            sb.append(\", \").append(requestDescription);\n-            logger.info(sb.toString());\n-        } catch (RuntimeException e) {\n-            logger.warn(\"Error logging response\", e);\n-            logger.info(sb.toString()); // Print incomplete response\n-        }\n+    QueryResult<ObjectMap> result = new QueryResult<>();\n+    result.setWarningMsg(\"Future errors will ONLY be shown in the QueryResponse body\");\n+    result.setErrorMsg(\"DEPRECATED: \" + e.toString());\n+    queryResponse.setResponse(Arrays.asList(result));\n+\n+    Response.Status errorStatus = Response.Status.INTERNAL_SERVER_ERROR;\n+    if (e instanceof CatalogAuthorizationException) {\n+      errorStatus = Response.Status.FORBIDDEN;\n+    } else if (e instanceof CatalogAuthenticationException) {\n+      errorStatus = Response.Status.UNAUTHORIZED;\n     }\n \n-    protected Response createJsonResponse(QueryResponse queryResponse) {\n-        try {\n-            return buildResponse(Response.ok(jsonObjectWriter.writeValueAsString(queryResponse), MediaType.APPLICATION_JSON_TYPE));\n-        } catch (JsonProcessingException e) {\n-            e.printStackTrace();\n-            logger.error(\"Error parsing queryResponse object\");\n-            return createErrorResponse(\"\", \"Error parsing QueryResponse object:\\n\" + Arrays.toString(e.getStackTrace()));\n-        }\n+    Response response = Response.fromResponse(createJsonResponse(queryResponse)).status(errorStatus).build();\n+    logResponse(response.getStatusInfo(), queryResponse);\n+    return response;\n+  }\n+\n+  protected Response createErrorResponse(String errorMessage, QueryResult result) {\n+\n+    QueryResponse<ObjectMap> queryResponse = new QueryResponse<>();\n+    queryResponse.setApiVersion(apiVersion);\n+    queryResponse.setQueryOptions(queryOptions);\n+    queryResponse.setError(\"true\");\n+    result.setErrorMsg(\"DEPRECATED: \" + errorMessage);\n+    queryResponse.setResponse(Arrays.asList(result));\n+\n+    Response response = Response.fromResponse(createJsonResponse(queryResponse)).status(Response.Status.INTERNAL_SERVER_ERROR).build();\n+    logResponse(response.getStatusInfo(), queryResponse);\n+    return response;\n+  }\n+\n+  protected Response createErrorResponse(String method, String errorMessage) {\n+    try {\n+      Response response = buildResponse(Response.ok(jsonObjectWriter.writeValueAsString(new ObjectMap(\"error\", errorMessage)),\n+          MediaType.APPLICATION_JSON_TYPE));\n+      logResponse(response.getStatusInfo());\n+      return response;\n+    } catch (JsonProcessingException e) {\n+      e.printStackTrace();\n     }\n \n-    protected Response buildResponse(Response.ResponseBuilder responseBuilder) {\n-        return responseBuilder\n-                .header(\"Access-Control-Allow-Origin\", \"*\")\n-                .header(\"Access-Control-Allow-Headers\", \"x-requested-with, content-type, authorization\")\n-                .header(\"Access-Control-Allow-Credentials\", \"true\")\n-                .header(\"Access-Control-Allow-Methods\", \"GET, POST, OPTIONS\")\n-                .build();\n+    return buildResponse(Response.ok(\"{\\\"error\\\":\\\"Error parsing json error\\\"}\", MediaType.APPLICATION_JSON_TYPE));\n+  }\n+\n+  // TODO: Change signature\n+  //    protected <T> Response createOkResponse(QueryResult<T> result)\n+  //    protected <T> Response createOkResponse(List<QueryResult<T>> results)\n+  protected Response createOkResponse(Object obj) {\n+    QueryResponse queryResponse = new QueryResponse();\n+    queryResponse.setTime(new Long(System.currentTimeMillis() - startTime).intValue());\n+    queryResponse.setApiVersion(apiVersion);\n+    queryResponse.setQueryOptions(queryOptions);\n+\n+    // Guarantee that the QueryResponse object contains a list of results\n+    List list;\n+    if (obj instanceof List) {\n+      list = (List) obj;\n+    } else {\n+      list = new ArrayList();\n+      if (!(obj instanceof QueryResult)) {\n+        list.add(new QueryResult<>(\"\", 0, 1, 1, \"\", \"\", Collections.singletonList(obj)));\n+      } else {\n+        list.add(obj);\n+      }\n     }\n+    queryResponse.setResponse(list);\n \n-    private void verifyHeaders(HttpHeaders httpHeaders) throws CatalogAuthenticationException {\n-        List<String> authorization = httpHeaders.getRequestHeader(\"Authorization\");\n-        if (authorization != null && authorization.get(0).length() > 7) {\n-            String token = authorization.get(0);\n-            if (!token.startsWith(\"Bearer \")) {\n-                throw new CatalogAuthenticationException(\"Authorization header must start with Bearer JWToken\");\n-            }\n-            this.sessionId = token.substring(\"Bearer\".length()).trim();\n-        }\n+    Response response = createJsonResponse(queryResponse);\n+    logResponse(response.getStatusInfo(), queryResponse);\n+    return response;\n+  }\n \n-        if (StringUtils.isEmpty(this.sessionId)) {\n-            this.sessionId = this.params.getFirst(\"sid\");\n-        }\n+  protected Response createRawOkResponse(Object obj) {\n+    try {\n+      String res = jsonObjectWriter.writeValueAsString(obj);\n+//            System.out.println(\"\\n\\n\\n\" + res + \"\\n\\n\");\n+      Response response = buildResponse(Response.ok(res, MediaType.APPLICATION_JSON_TYPE));\n+      logResponse(response.getStatusInfo());\n+      return response;\n+    } catch (JsonProcessingException e) {\n+      e.printStackTrace();\n+      logger.error(\"Error parsing response object\");\n+      return createErrorResponse(\"\", \"Error parsing response object:\\n\" + Arrays.toString(e.getStackTrace()));\n     }\n-\n-    protected List<String> getIdList(String id) throws WebServiceException {\n-        return getIdList(id, true);\n+  }\n+\n+  protected Response createAnalysisOkResponse(Object obj) {\n+    Map<String, Object> queryResponseMap = new LinkedHashMap<>();\n+    queryResponseMap.put(\"time\", new Long(System.currentTimeMillis() - startTime).intValue());\n+    queryResponseMap.put(\"apiVersion\", apiVersion);\n+    queryResponseMap.put(\"queryOptions\", queryOptions);\n+    queryResponseMap.put(\"response\", Collections.singletonList(obj));\n+\n+    Response response;\n+    try {\n+      response = buildResponse(Response.ok(jsonObjectWriter.writeValueAsString(queryResponseMap), MediaType.APPLICATION_JSON_TYPE));\n+      logResponse(response.getStatusInfo());\n+    } catch (JsonProcessingException e) {\n+      e.printStackTrace();\n+      logger.error(\"Error parsing queryResponse object\");\n+      return createErrorResponse(\"\", \"Error parsing QueryResponse object:\\n\" + Arrays.toString(e.getStackTrace()));\n     }\n \n-    protected List<String> getIdList(String id, boolean checkMaxNumberElements) throws WebServiceException {\n-        if (StringUtils.isNotEmpty(id)) {\n-            List<String> ids = checkUniqueList(id);\n-            if (checkMaxNumberElements && ids.size() > MAX_ID_SIZE) {\n-                throw new WebServiceException(\"More than \" + MAX_ID_SIZE + \" IDs are provided\");\n+    return response;\n+  }\n+\n+  //Response methods\n+  protected Response createOkResponse(Object o1, MediaType o2) {\n+    return buildResponse(Response.ok(o1, o2));\n+  }\n+\n+  protected Response createOkResponse(Object o1, MediaType o2, String fileName) {\n+    return buildResponse(Response.ok(o1, o2).header(\"content-disposition\", \"attachment; filename =\" + fileName));\n+  }\n+\n+  private void logResponse(Response.StatusType statusInfo) {\n+    logResponse(statusInfo, null);\n+  }\n+\n+  private void logResponse(Response.StatusType statusInfo, QueryResponse<?> queryResponse) {\n+    StringBuilder sb = new StringBuilder();\n+    try {\n+      if (statusInfo.getFamily().equals(Response.Status.Family.SUCCESSFUL)) {\n+        sb.append(\"OK\");\n+      } else {\n+        sb.append(\"ERROR\");\n+      }\n+      sb.append(\" [\").append(statusInfo.getStatusCode()).append(']');\n+\n+      if (queryResponse == null) {\n+        sb.append(\", \").append(System.currentTimeMillis() - startTime).append(\"ms\");\n+      } else {\n+        sb.append(\", \").append(queryResponse.getTime()).append(\"ms\");\n+        if (queryResponse.getResponse().size() == 1) {\n+          QueryResult<?> result = queryResponse.getResponse().get(0);\n+          if (result != null) {\n+            sb.append(\", num: \").append(result.getNumResults());\n+            if (result.getNumTotalResults() >= 0) {\n+              sb.append(\", total: \").append(result.getNumTotalResults());\n             }\n-            return ids;\n-        } else {\n-            throw new WebServiceException(\"ID is null or Empty\");\n-        }\n+          }\n+        }\n+      }\n+      sb.append(\", \").append(requestDescription);\n+      logger.info(sb.toString());\n+    } catch (RuntimeException e) {\n+      logger.warn(\"Error logging response\", e);\n+      logger.info(sb.toString()); // Print incomplete response\n     }\n-\n-    protected static List<String> checkUniqueList(String ids) throws WebServiceException {\n-        if (StringUtils.isNotEmpty(ids)) {\n-            List<String> idsList = Arrays.asList(ids.split(\",\"));\n-            return checkUniqueList(idsList, \"\");\n-        } else {\n-            throw new WebServiceException(\"ID is null or Empty\");\n-        }\n+  }\n+\n+  protected Response createJsonResponse(QueryResponse queryResponse) {\n+    try {\n+      return buildResponse(Response.ok(jsonObjectWriter.writeValueAsString(queryResponse), MediaType.APPLICATION_JSON_TYPE));\n+    } catch (JsonProcessingException e) {\n+      e.printStackTrace();\n+      logger.error(\"Error parsing queryResponse object\");\n+      return createErrorResponse(\"\", \"Error parsing QueryResponse object:\\n\" + Arrays.toString(e.getStackTrace()));\n+    }\n+  }\n+\n+  protected Response buildResponse(Response.ResponseBuilder responseBuilder) {\n+    return responseBuilder\n+        .header(\"Access-Control-Allow-Origin\", \"*\")\n+        .header(\"Access-Control-Allow-Headers\", \"x-requested-with, content-type, authorization\")\n+        .header(\"Access-Control-Allow-Credentials\", \"true\")\n+        .header(\"Access-Control-Allow-Methods\", \"GET, POST, OPTIONS\")\n+        .build();\n+  }\n+\n+  private void verifyHeaders(HttpHeaders httpHeaders) throws CatalogAuthenticationException {\n+    List<String> authorization = httpHeaders.getRequestHeader(\"Authorization\");\n+    if (authorization != null && authorization.get(0).length() > 7) {\n+      String token = authorization.get(0);\n+      if (!token.startsWith(\"Bearer \")) {\n+        throw new CatalogAuthenticationException(\"Authorization header must start with Bearer JWToken\");\n+      }\n+      this.sessionId = token.substring(\"Bearer\".length()).trim();\n     }\n \n-    protected static List<String> checkUniqueList(List<String> ids, String field) throws WebServiceException {\n-        if (ListUtils.isNotEmpty(ids)) {\n-            Set<String> hashSet = new HashSet<>(ids);\n-            if (hashSet.size() == ids.size()) {\n-                return ids;\n-            } else {\n-                throw new WebServiceException(\"Provided \" + field + \" IDs are not unique. Only unique IDs are accepted.\");\n-            }\n-        }\n-        return null;\n+    if (StringUtils.isEmpty(this.sessionId)) {\n+      this.sessionId = this.params.getFirst(\"sid\");\n     }\n+  }\n+\n+  protected List<String> getIdList(String id) throws WebServiceException {\n+    return getIdList(id, true);\n+  }\n+\n+  protected List<String> getIdList(String id, boolean checkMaxNumberElements) throws WebServiceException {\n+    if (StringUtils.isNotEmpty(id)) {\n+      List<String> ids = checkUniqueList(id);\n+      if (checkMaxNumberElements && ids.size() > MAX_ID_SIZE) {\n+        throw new WebServiceException(\"More than \" + MAX_ID_SIZE + \" IDs are provided\");\n+      }\n+      return ids;\n+    } else {\n+      throw new WebServiceException(\"ID is null or Empty\");\n+    }\n+  }\n+\n+  protected static List<String> checkUniqueList(String ids) throws WebServiceException {\n+    if (StringUtils.isNotEmpty(ids)) {\n+      List<String> idsList = Arrays.asList(ids.split(\",\"));\n+      return checkUniqueList(idsList, \"\");\n+    } else {\n+      throw new WebServiceException(\"ID is null or Empty\");\n+    }\n+  }\n+\n+  protected static List<String> checkUniqueList(List<String> ids, String field) throws WebServiceException {\n+    if (ListUtils.isNotEmpty(ids)) {\n+      Set<String> hashSet = new HashSet<>(ids);\n+      if (hashSet.size() == ids.size()) {\n+        return ids;\n+      } else {\n+        throw new WebServiceException(\"Provided \" + field + \" IDs are not unique. Only unique IDs are accepted.\");\n+      }\n+    }\n+    return null;\n+  }\n \n-    protected void areSingleIds(String... ids) throws CatalogParameterException {\n-        for (String id : ids) {\n-            ParamUtils.checkIsSingleID(id);\n-        }\n+  protected void areSingleIds(String... ids) throws CatalogParameterException {\n+    for (String id : ids) {\n+      ParamUtils.checkIsSingleID(id);\n     }\n+  }\n \n }\n",
            "diff_size": 807
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "173",
                    "severity": "error",
                    "message": "Line is longer than 140 characters (found 141).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "173",
                    "severity": "error",
                    "message": "Line is longer than 140 characters (found 141).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ],
    "repaired_by": [],
    "not_repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}