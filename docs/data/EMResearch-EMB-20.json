{
    "project_name": "EMResearch-EMB",
    "error_id": "20",
    "information": {
        "errors": [
            {
                "line": "184",
                "severity": "warning",
                "message": "Line is longer than 120 characters (found 122).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": "   * Converts case of the string token according to match element attributes.\n   * @param s Token to be converted.\n   * @param sample the sample string used to determine how the original string looks like (used only on case preservation)\n   * @return Converted string.\n   */\n  String convertCase(String s, String sample, Language lang) {",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "184",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 122).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "80",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 123).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "186",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 124).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/EMResearch-EMB/errored/1/20/MatchState.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/EMResearch-EMB/intellij/20/MatchState.java\nindex a97d90de94a..b3e93a46306 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/EMResearch-EMB/errored/1/20/MatchState.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/EMResearch-EMB/intellij/20/MatchState.java\n@@ -17,6 +17,7 @@\n  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301\n  * USA\n  */\n+\n package org.languagetool.rules.patterns;\n \n import java.io.IOException;\n@@ -46,344 +47,346 @@ import static org.languagetool.JLanguageTool.SENTENCE_START_TAGNAME;\n  */\n public class MatchState {\n \n-  private final Match match;\n-  private final Synthesizer synthesizer;\n+    private final Match match;\n+    private final Synthesizer synthesizer;\n \n-  private AnalyzedTokenReadings formattedToken;\n-  private AnalyzedTokenReadings matchedToken;\n-  private String skippedTokens;\n+    private AnalyzedTokenReadings formattedToken;\n+    private AnalyzedTokenReadings matchedToken;\n+    private String skippedTokens;\n \n-  public MatchState(Match match, Synthesizer synthesizer) {\n-    this.match = match;\n-    this.synthesizer = synthesizer;\n-    String lemma = match.getLemma();\n-    if (!StringUtils.isEmpty(lemma)) {\n-      formattedToken = new AnalyzedTokenReadings(new AnalyzedToken(lemma, match.getPosTag(), lemma), 0);\n+    public MatchState(Match match, Synthesizer synthesizer) {\n+        this.match = match;\n+        this.synthesizer = synthesizer;\n+        String lemma = match.getLemma();\n+        if (!StringUtils.isEmpty(lemma)) {\n+            formattedToken = new AnalyzedTokenReadings(new AnalyzedToken(lemma, match.getPosTag(), lemma), 0);\n+        }\n     }\n-  }\n \n-  public void setToken(AnalyzedTokenReadings token) {\n-    if (match.isStaticLemma()) {\n-      this.matchedToken = token;\n-    } else {\n-      this.formattedToken = token;\n+    public void setToken(AnalyzedTokenReadings token) {\n+        if (match.isStaticLemma()) {\n+            this.matchedToken = token;\n+        } else {\n+            this.formattedToken = token;\n+        }\n     }\n-  }\n \n-  /**\n-   * Sets the token to be formatted etc. and includes the support for\n-   * including the skipped tokens.\n-   *\n-   * @param tokens Array of tokens\n-   * @param index Index of the token to be formatted\n-   * @param next Position of the next token (the skipped tokens are the ones between the tokens[index] and tokens[next]\n-   */\n-  public final void setToken(AnalyzedTokenReadings[] tokens, int index, int next) {\n-    int idx = index;\n-    if (index >= tokens.length) {\n-      // TODO: hacky workaround, find a proper solution. See EnglishPatternRuleTest.testBug()\n-      idx = tokens.length - 1;\n-    }\n-    setToken(tokens[idx]);\n-    IncludeRange includeSkipped = match.getIncludeSkipped();\n-    if (next > 1 && includeSkipped != IncludeRange.NONE) {\n-      StringBuilder sb = new StringBuilder();\n-      if (includeSkipped == IncludeRange.FOLLOWING) {\n-        formattedToken = null;\n-      }\n-      for (int k = index + 1; k < index + next; k++) {\n-        if (tokens[k].isWhitespaceBefore()\n-            && !(k == index + 1 && includeSkipped == IncludeRange.FOLLOWING)) {\n-          sb.append(' ');\n+    /**\n+     * Sets the token to be formatted etc. and includes the support for\n+     * including the skipped tokens.\n+     *\n+     * @param tokens Array of tokens\n+     * @param index  Index of the token to be formatted\n+     * @param next   Position of the next token (the skipped tokens are the ones between the tokens[index] and tokens[next]\n+     */\n+    public final void setToken(AnalyzedTokenReadings[] tokens, int index, int next) {\n+        int idx = index;\n+        if (index >= tokens.length) {\n+            // TODO: hacky workaround, find a proper solution. See EnglishPatternRuleTest.testBug()\n+            idx = tokens.length - 1;\n+        }\n+        setToken(tokens[idx]);\n+        IncludeRange includeSkipped = match.getIncludeSkipped();\n+        if (next > 1 && includeSkipped != IncludeRange.NONE) {\n+            StringBuilder sb = new StringBuilder();\n+            if (includeSkipped == IncludeRange.FOLLOWING) {\n+                formattedToken = null;\n+            }\n+            for (int k = index + 1; k < index + next; k++) {\n+                if (tokens[k].isWhitespaceBefore()\n+                    && !(k == index + 1 && includeSkipped == IncludeRange.FOLLOWING)) {\n+                    sb.append(' ');\n+                }\n+                sb.append(tokens[k].getToken());\n+            }\n+            skippedTokens = sb.toString();\n+        } else {\n+            skippedTokens = \"\";\n         }\n-        sb.append(tokens[k].getToken());\n-      }\n-      skippedTokens = sb.toString();\n-    } else {\n-      skippedTokens = \"\";\n     }\n-  }\n \n-  public final AnalyzedTokenReadings filterReadings() {\n-    List<AnalyzedToken> l = new ArrayList<>();\n-    if (formattedToken != null) {\n-      if (match.isStaticLemma()) {\n-        // Note: we want the token without ignored characters so we can't use matchedToken.getToken()\n-        matchedToken.leaveReading(new AnalyzedToken(matchedToken.getReadings().get(0).getToken(),\n-                match.getPosTag(), formattedToken.getToken()));\n-        formattedToken = matchedToken;\n-      }\n-      // Note: we want the token without ignored characters so we can't use formattedToken.getToken()\n-      String token = formattedToken.getAnalyzedToken(0).getToken();\n-      Pattern regexMatch = match.getRegexMatch();\n-      String regexReplace = match.getRegexReplace();\n-      if (regexMatch != null && regexReplace != null) {\n-        /* only replace if it is something to replace */\n-        token = regexMatch.matcher(token).replaceAll(regexReplace);\n-      }\n-      token = convertCase(token, token, null);\n+    public final AnalyzedTokenReadings filterReadings() {\n+        List<AnalyzedToken> l = new ArrayList<>();\n+        if (formattedToken != null) {\n+            if (match.isStaticLemma()) {\n+                // Note: we want the token without ignored characters so we can't use matchedToken.getToken()\n+                matchedToken.leaveReading(new AnalyzedToken(matchedToken.getReadings().get(0).getToken(),\n+                    match.getPosTag(), formattedToken.getToken()));\n+                formattedToken = matchedToken;\n+            }\n+            // Note: we want the token without ignored characters so we can't use formattedToken.getToken()\n+            String token = formattedToken.getAnalyzedToken(0).getToken();\n+            Pattern regexMatch = match.getRegexMatch();\n+            String regexReplace = match.getRegexReplace();\n+            if (regexMatch != null && regexReplace != null) {\n+                /* only replace if it is something to replace */\n+                token = regexMatch.matcher(token).replaceAll(regexReplace);\n+            }\n+            token = convertCase(token, token, null);\n+\n+            String posTag = match.getPosTag();\n+            if (posTag != null) {\n+                int numRead = formattedToken.getReadingsLength();\n+                if (match.isPostagRegexp()) {\n+                    Pattern pPosRegexMatch = match.getPosRegexMatch();\n+                    String posTagReplace = match.getPosTagReplace();\n+                    String targetPosTag;\n+                    for (int i = 0; i < numRead; i++) {\n+                        String testTag = formattedToken.getAnalyzedToken(i).getPOSTag();\n+                        if (testTag != null && pPosRegexMatch.matcher(testTag).matches()) {\n+                            targetPosTag = testTag;\n+                            if (posTagReplace != null) {\n+                                targetPosTag = pPosRegexMatch.matcher(targetPosTag).replaceAll(posTagReplace);\n+                            }\n+                            l.add(new AnalyzedToken(token, targetPosTag,\n+                                formattedToken.getAnalyzedToken(i).getLemma()));\n+                            l.get(l.size() - 1).setWhitespaceBefore(formattedToken.isWhitespaceBefore());\n+                        }\n+                    }\n+                    if (l.isEmpty()) {\n+                        l.addAll(getNewToken(numRead, token));\n+                    }\n+                } else {\n+                    l.addAll(getNewToken(numRead, token));\n+                }\n+                String lemma = formattedToken.getAnalyzedToken(0).getLemma();\n+                if (formattedToken.isSentenceEnd()) {\n+                    l.add(new AnalyzedToken(formattedToken.getToken(), SENTENCE_END_TAGNAME, lemma));\n+                }\n+                if (formattedToken.isParagraphEnd()) {\n+                    l.add(new AnalyzedToken(formattedToken.getToken(), PARAGRAPH_END_TAGNAME, lemma));\n+                }\n \n-      String posTag = match.getPosTag();\n-      if (posTag != null) {\n-        int numRead = formattedToken.getReadingsLength();\n-        if (match.isPostagRegexp()) {\n-          Pattern pPosRegexMatch = match.getPosRegexMatch();\n-          String posTagReplace = match.getPosTagReplace();\n-          String targetPosTag;\n-          for (int i = 0; i < numRead; i++) {\n-            String testTag = formattedToken.getAnalyzedToken(i).getPOSTag();\n-            if (testTag != null && pPosRegexMatch.matcher(testTag).matches()) {\n-              targetPosTag = testTag;\n-              if (posTagReplace != null) {\n-                targetPosTag = pPosRegexMatch.matcher(targetPosTag).replaceAll(posTagReplace);\n-              }\n-              l.add(new AnalyzedToken(token, targetPosTag,\n-                  formattedToken.getAnalyzedToken(i).getLemma()));\n-              l.get(l.size() - 1).setWhitespaceBefore(formattedToken.isWhitespaceBefore());\n             }\n-          }\n-          if (l.isEmpty()) {\n-            l.addAll(getNewToken(numRead, token));\n-          }\n-        } else {\n-          l.addAll(getNewToken(numRead, token));\n-        }\n-        String lemma = formattedToken.getAnalyzedToken(0).getLemma();\n-        if (formattedToken.isSentenceEnd()) {\n-          l.add(new AnalyzedToken(formattedToken.getToken(), SENTENCE_END_TAGNAME, lemma));\n         }\n-        if (formattedToken.isParagraphEnd()) {\n-          l.add(new AnalyzedToken(formattedToken.getToken(), PARAGRAPH_END_TAGNAME, lemma));\n+        if (l.isEmpty()) {\n+            return formattedToken;\n         }\n-\n-      }\n-    }\n-    if (l.isEmpty()) {\n-      return formattedToken;\n-    }\n-    final AnalyzedTokenReadings anTkRead = new AnalyzedTokenReadings(\n-        l.toArray(new AnalyzedToken[0]),\n-        formattedToken.getStartPos());\n-    // TODO: in case original had ignored characters we want to restore readings.token\n-    // but there's no setToken() available :(\n+        final AnalyzedTokenReadings anTkRead = new AnalyzedTokenReadings(\n+            l.toArray(new AnalyzedToken[0]),\n+            formattedToken.getStartPos());\n+        // TODO: in case original had ignored characters we want to restore readings.token\n+        // but there's no setToken() available :(\n //    anTkRead.setToken(formattedToken.getToken());\n-    \n-    anTkRead.setWhitespaceBefore(formattedToken.getWhitespaceBefore());\n-    if (!formattedToken.getChunkTags().isEmpty()) {\n-      anTkRead.setChunkTags(formattedToken.getChunkTags());\n-    }\n-    if (formattedToken.isImmunized()) {\n-      anTkRead.immunize();\n+\n+        anTkRead.setWhitespaceBefore(formattedToken.getWhitespaceBefore());\n+        if (!formattedToken.getChunkTags().isEmpty()) {\n+            anTkRead.setChunkTags(formattedToken.getChunkTags());\n+        }\n+        if (formattedToken.isImmunized()) {\n+            anTkRead.immunize();\n+        }\n+        return anTkRead;\n     }\n-    return anTkRead;\n-  }\n \n-  /**\n-   * Converts case of the string token according to match element attributes.\n-   * @param s Token to be converted.\n-   * @param sample the sample string used to determine how the original string looks like (used only on case preservation)\n-   * @return Converted string.\n-   */\n-  String convertCase(String s, String sample, Language lang) {\n-    return CaseConversionHelper.convertCase(match.getCaseConversionType(), s, sample, lang);\n-  }\n+    /**\n+     * Converts case of the string token according to match element attributes.\n+     *\n+     * @param s      Token to be converted.\n+     * @param sample the sample string used to determine how the original string looks like (used only on case preservation)\n+     * @return Converted string.\n+     */\n+    String convertCase(String s, String sample, Language lang) {\n+        return CaseConversionHelper.convertCase(match.getCaseConversionType(), s, sample, lang);\n+    }\n \n-  private List<AnalyzedToken> getNewToken(int numRead, String token) {\n-    String posTag = match.getPosTag();\n-    List<AnalyzedToken> list = new ArrayList<>();\n-    String lemma = \"\";\n-    for (int j = 0; j < numRead; j++) {\n-      String tempPosTag = formattedToken.getAnalyzedToken(j).getPOSTag();\n-      if (tempPosTag != null) {\n-        if (tempPosTag.equals(posTag) && formattedToken.getAnalyzedToken(j).getLemma() != null) {\n-          lemma = formattedToken.getAnalyzedToken(j).getLemma();\n-        }\n-        if (StringTools.isEmpty(lemma)) {\n-          lemma = formattedToken.getAnalyzedToken(0).getLemma();\n+    private List<AnalyzedToken> getNewToken(int numRead, String token) {\n+        String posTag = match.getPosTag();\n+        List<AnalyzedToken> list = new ArrayList<>();\n+        String lemma = \"\";\n+        for (int j = 0; j < numRead; j++) {\n+            String tempPosTag = formattedToken.getAnalyzedToken(j).getPOSTag();\n+            if (tempPosTag != null) {\n+                if (tempPosTag.equals(posTag) && formattedToken.getAnalyzedToken(j).getLemma() != null) {\n+                    lemma = formattedToken.getAnalyzedToken(j).getLemma();\n+                }\n+                if (StringTools.isEmpty(lemma)) {\n+                    lemma = formattedToken.getAnalyzedToken(0).getLemma();\n+                }\n+                list.add(new AnalyzedToken(token, posTag, lemma));\n+                list.get(list.size() - 1).setWhitespaceBefore(\n+                    formattedToken.isWhitespaceBefore());\n+            }\n         }\n-        list.add(new AnalyzedToken(token, posTag, lemma));\n-        list.get(list.size() - 1).setWhitespaceBefore(\n-            formattedToken.isWhitespaceBefore());\n-      }\n+        return list;\n     }\n-    return list;\n-  }\n \n-  /**\n-   * Gets all strings formatted using the match element.\n-   */\n-  public final String[] toFinalString(Language lang) throws IOException {\n-    String[] formattedString = new String[1];\n-    if (formattedToken != null) {\n-      int readingCount = formattedToken.getReadingsLength();\n-      formattedString[0] = formattedToken.getToken();\n+    /**\n+     * Gets all strings formatted using the match element.\n+     */\n+    public final String[] toFinalString(Language lang) throws IOException {\n+        String[] formattedString = new String[1];\n+        if (formattedToken != null) {\n+            int readingCount = formattedToken.getReadingsLength();\n+            formattedString[0] = formattedToken.getToken();\n \n-      Pattern pRegexMatch = match.getRegexMatch();\n-      String regexReplace = match.getRegexReplace();\n-      if (pRegexMatch != null) {\n-        formattedString[0] = pRegexMatch.matcher(formattedString[0]).replaceAll(regexReplace);\n-      }\n+            Pattern pRegexMatch = match.getRegexMatch();\n+            String regexReplace = match.getRegexReplace();\n+            if (pRegexMatch != null) {\n+                formattedString[0] = pRegexMatch.matcher(formattedString[0]).replaceAll(regexReplace);\n+            }\n \n-      String posTag = match.getPosTag();\n-      if (posTag != null) {\n-        if (synthesizer == null) {\n-          formattedString[0] = formattedToken.getToken();\n-        } else if (match.isPostagRegexp()) {\n-          TreeSet<String> wordForms = new TreeSet<>();\n-          boolean oneForm = false;\n-          for (int k = 0; k < readingCount; k++) {\n-            if (formattedToken.getAnalyzedToken(k).getLemma() == null) {\n-              String posUnique = formattedToken.getAnalyzedToken(k).getPOSTag();\n-              if (posUnique == null) {\n-                wordForms.add(formattedToken.getToken());\n-                oneForm = true;\n-              } else {\n-                if (SENTENCE_START_TAGNAME.equals(posUnique)\n-                    || SENTENCE_END_TAGNAME.equals(posUnique)\n-                    || PARAGRAPH_END_TAGNAME.equals(posUnique)) {\n-                  if (!oneForm) {\n-                    wordForms.add(formattedToken.getToken());\n-                  }\n-                  oneForm = true;\n+            String posTag = match.getPosTag();\n+            if (posTag != null) {\n+                if (synthesizer == null) {\n+                    formattedString[0] = formattedToken.getToken();\n+                } else if (match.isPostagRegexp()) {\n+                    TreeSet<String> wordForms = new TreeSet<>();\n+                    boolean oneForm = false;\n+                    for (int k = 0; k < readingCount; k++) {\n+                        if (formattedToken.getAnalyzedToken(k).getLemma() == null) {\n+                            String posUnique = formattedToken.getAnalyzedToken(k).getPOSTag();\n+                            if (posUnique == null) {\n+                                wordForms.add(formattedToken.getToken());\n+                                oneForm = true;\n+                            } else {\n+                                if (SENTENCE_START_TAGNAME.equals(posUnique)\n+                                    || SENTENCE_END_TAGNAME.equals(posUnique)\n+                                    || PARAGRAPH_END_TAGNAME.equals(posUnique)) {\n+                                    if (!oneForm) {\n+                                        wordForms.add(formattedToken.getToken());\n+                                    }\n+                                    oneForm = true;\n+                                } else {\n+                                    oneForm = false;\n+                                }\n+                            }\n+                        }\n+                    }\n+                    String targetPosTag = getTargetPosTag();\n+                    if (!oneForm) {\n+                        for (int i = 0; i < readingCount; i++) {\n+                            String[] possibleWordForms = synthesizer.synthesize(\n+                                formattedToken.getAnalyzedToken(i), targetPosTag, true);\n+                            if (possibleWordForms != null && possibleWordForms.length > 0) {\n+                                wordForms.addAll(Arrays.asList(possibleWordForms));\n+                            }\n+                        }\n+                    }\n+                    if (wordForms.isEmpty()) {\n+                        formattedString[0] = \"(\" + formattedToken.getToken() + \")\";\n+                    } else {\n+                        formattedString = wordForms.toArray(new String[0]);\n+                    }\n                 } else {\n-                  oneForm = false;\n+                    TreeSet<String> wordForms = new TreeSet<>();\n+                    for (int i = 0; i < readingCount; i++) {\n+                        String[] possibleWordForms = synthesizer.synthesize(formattedToken.getAnalyzedToken(i), posTag);\n+                        if (possibleWordForms != null) {\n+                            wordForms.addAll(Arrays.asList(possibleWordForms));\n+                        }\n+                    }\n+                    formattedString = wordForms.toArray(new String[0]);\n                 }\n-              }\n             }\n-          }\n-          String targetPosTag = getTargetPosTag();\n-          if (!oneForm) {\n-            for (int i = 0; i < readingCount; i++) {\n-              String[] possibleWordForms = synthesizer.synthesize(\n-                  formattedToken.getAnalyzedToken(i), targetPosTag, true);\n-              if (possibleWordForms != null && possibleWordForms.length > 0) {\n-                wordForms.addAll(Arrays.asList(possibleWordForms));\n-              }\n-            }\n-          }\n-          if (wordForms.isEmpty()) {\n-            formattedString[0] = \"(\" + formattedToken.getToken() + \")\";\n-          } else {\n-            formattedString = wordForms.toArray(new String[0]);\n-          }\n+        }\n+        String original;\n+        if (match.isStaticLemma()) {\n+            original = matchedToken != null ? matchedToken.getToken() : \"\";\n         } else {\n-          TreeSet<String> wordForms = new TreeSet<>();\n-          for (int i = 0; i < readingCount; i++) {\n-            String[] possibleWordForms = synthesizer.synthesize(formattedToken.getAnalyzedToken(i), posTag);\n-            if (possibleWordForms != null) {\n-              wordForms.addAll(Arrays.asList(possibleWordForms));\n-            }\n-          }\n-          formattedString = wordForms.toArray(new String[0]);\n+            original = formattedToken != null ? formattedToken.getToken() : \"\";\n         }\n-      }\n-    }\n-    String original;\n-    if (match.isStaticLemma()) {\n-      original = matchedToken != null ? matchedToken.getToken() : \"\";\n-    } else {\n-      original = formattedToken != null ? formattedToken.getToken() : \"\";\n-    }\n-    for (int i = 0; i < formattedString.length; i++) {\n-      formattedString[i] = convertCase(formattedString[i], original, lang);\n-    }\n-    // TODO should case conversion happen before or after including skipped tokens?\n-    IncludeRange includeSkipped = match.getIncludeSkipped();\n-    if (includeSkipped != IncludeRange.NONE && skippedTokens != null\n-        && !skippedTokens.isEmpty()) {\n-      String[] helper = new String[formattedString.length];\n-      for (int i = 0; i < formattedString.length; i++) {\n-        if (formattedString[i] == null) {\n-          formattedString[i] = \"\";\n+        for (int i = 0; i < formattedString.length; i++) {\n+            formattedString[i] = convertCase(formattedString[i], original, lang);\n         }\n-        helper[i] = formattedString[i] + skippedTokens;\n-      }\n-      formattedString = helper;\n-    }\n-    if (match.checksSpelling() && lang != null) {\n-      List<String> formattedStringElements = Arrays.asList(formattedString);\n-      // tagger-based speller\n-      List<AnalyzedTokenReadings> analyzed = lang.getTagger().tag(\n-          formattedStringElements);\n-      for (int i = 0; i < formattedString.length; i++) {\n-        AnalyzedToken analyzedToken = analyzed.get(i).getAnalyzedToken(0);\n-        if (analyzedToken.getLemma() == null && analyzedToken.hasNoTag()) {\n-          formattedString[i] = PatternRuleMatcher.MISTAKE;\n+        // TODO should case conversion happen before or after including skipped tokens?\n+        IncludeRange includeSkipped = match.getIncludeSkipped();\n+        if (includeSkipped != IncludeRange.NONE && skippedTokens != null\n+            && !skippedTokens.isEmpty()) {\n+            String[] helper = new String[formattedString.length];\n+            for (int i = 0; i < formattedString.length; i++) {\n+                if (formattedString[i] == null) {\n+                    formattedString[i] = \"\";\n+                }\n+                helper[i] = formattedString[i] + skippedTokens;\n+            }\n+            formattedString = helper;\n         }\n-      }\n+        if (match.checksSpelling() && lang != null) {\n+            List<String> formattedStringElements = Arrays.asList(formattedString);\n+            // tagger-based speller\n+            List<AnalyzedTokenReadings> analyzed = lang.getTagger().tag(\n+                formattedStringElements);\n+            for (int i = 0; i < formattedString.length; i++) {\n+                AnalyzedToken analyzedToken = analyzed.get(i).getAnalyzedToken(0);\n+                if (analyzedToken.getLemma() == null && analyzedToken.hasNoTag()) {\n+                    formattedString[i] = PatternRuleMatcher.MISTAKE;\n+                }\n+            }\n+        }\n+        return formattedString;\n     }\n-    return formattedString;\n-  }\n \n-  /**\n-   * Format POS tag using parameters already defined in the class.\n-   *\n-   * @return Formatted POS tag as String.\n-   */\n-  // FIXME: gets only the first POS tag that matches, this can be wrong\n-  // on the other hand, many POS tags = too many suggestions?\n-  public final String getTargetPosTag() {\n-    String targetPosTag = match.getPosTag();\n-    List<String> posTags = new ArrayList<>();\n-    Pattern pPosRegexMatch = match.getPosRegexMatch();\n-    String posTagReplace = match.getPosTagReplace();\n+    /**\n+     * Format POS tag using parameters already defined in the class.\n+     *\n+     * @return Formatted POS tag as String.\n+     */\n+    // FIXME: gets only the first POS tag that matches, this can be wrong\n+    // on the other hand, many POS tags = too many suggestions?\n+    public final String getTargetPosTag() {\n+        String targetPosTag = match.getPosTag();\n+        List<String> posTags = new ArrayList<>();\n+        Pattern pPosRegexMatch = match.getPosRegexMatch();\n+        String posTagReplace = match.getPosTagReplace();\n \n-    if (match.isStaticLemma()) {\n-      for (AnalyzedToken analyzedToken : matchedToken) {\n-        String tst = analyzedToken.getPOSTag();\n-        if (tst != null && pPosRegexMatch.matcher(tst).matches()) {\n-          targetPosTag = analyzedToken.getPOSTag();\n-          posTags.add(targetPosTag);\n-        }\n-      }\n-      \n-      if (pPosRegexMatch != null && posTagReplace != null && !posTags.isEmpty()) {\n-        targetPosTag = pPosRegexMatch.matcher(targetPosTag).replaceAll(\n-            posTagReplace);\n-      }\n-    } else {\n-      for (AnalyzedToken analyzedToken : formattedToken) {\n-        String tst = analyzedToken.getPOSTag();\n-        if (tst != null && pPosRegexMatch.matcher(tst).matches()) {\n-          targetPosTag = analyzedToken.getPOSTag();\n-          posTags.add(targetPosTag);\n-        }\n-      }\n-      if (pPosRegexMatch != null && posTagReplace != null) {\n-        if (posTags.isEmpty()) {\n-          posTags.add(targetPosTag);\n-        }\n-        StringBuilder sb = new StringBuilder();\n-        int posTagLen = posTags.size();\n-        int l = 0;\n-        for (String lPosTag : posTags) {\n-          l++;\n-          lPosTag = pPosRegexMatch.matcher(lPosTag).replaceAll(posTagReplace);\n-          if (match.setsPos()) {\n-            lPosTag = synthesizer.getPosTagCorrection(lPosTag);\n-          }\n-          sb.append(lPosTag);\n-          if (l < posTagLen) {\n-            sb.append('|');\n-          }\n+        if (match.isStaticLemma()) {\n+            for (AnalyzedToken analyzedToken : matchedToken) {\n+                String tst = analyzedToken.getPOSTag();\n+                if (tst != null && pPosRegexMatch.matcher(tst).matches()) {\n+                    targetPosTag = analyzedToken.getPOSTag();\n+                    posTags.add(targetPosTag);\n+                }\n+            }\n+\n+            if (pPosRegexMatch != null && posTagReplace != null && !posTags.isEmpty()) {\n+                targetPosTag = pPosRegexMatch.matcher(targetPosTag).replaceAll(\n+                    posTagReplace);\n+            }\n+        } else {\n+            for (AnalyzedToken analyzedToken : formattedToken) {\n+                String tst = analyzedToken.getPOSTag();\n+                if (tst != null && pPosRegexMatch.matcher(tst).matches()) {\n+                    targetPosTag = analyzedToken.getPOSTag();\n+                    posTags.add(targetPosTag);\n+                }\n+            }\n+            if (pPosRegexMatch != null && posTagReplace != null) {\n+                if (posTags.isEmpty()) {\n+                    posTags.add(targetPosTag);\n+                }\n+                StringBuilder sb = new StringBuilder();\n+                int posTagLen = posTags.size();\n+                int l = 0;\n+                for (String lPosTag : posTags) {\n+                    l++;\n+                    lPosTag = pPosRegexMatch.matcher(lPosTag).replaceAll(posTagReplace);\n+                    if (match.setsPos()) {\n+                        lPosTag = synthesizer.getPosTagCorrection(lPosTag);\n+                    }\n+                    sb.append(lPosTag);\n+                    if (l < posTagLen) {\n+                        sb.append('|');\n+                    }\n+                }\n+                targetPosTag = sb.toString();\n+            }\n         }\n-        targetPosTag = sb.toString();\n-      }\n+        return targetPosTag;\n     }\n-    return targetPosTag;\n-  }\n \n-  /**\n-   * Method for getting the formatted match as a single string. In case of\n-   * multiple matches, it joins them using a regular expression operator \"|\".\n-   * @return Formatted string of the matched token.\n-   */\n-  final String toTokenString() throws IOException {\n-    String[] stringToFormat = toFinalString(null);\n-    return String.join(\"|\", Arrays.asList(stringToFormat));\n-  }\n+    /**\n+     * Method for getting the formatted match as a single string. In case of\n+     * multiple matches, it joins them using a regular expression operator \"|\".\n+     *\n+     * @return Formatted string of the matched token.\n+     */\n+    final String toTokenString() throws IOException {\n+        String[] stringToFormat = toFinalString(null);\n+        return String.join(\"|\", Arrays.asList(stringToFormat));\n+    }\n \n-  public Match getMatch() {\n-    return match;\n-  }\n+    public Match getMatch() {\n+        return match;\n+    }\n }\n",
            "diff_size": 398
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "142",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 130).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "144",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 141).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "145",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "166",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 136).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "183",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 122).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "240",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 158).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "254",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 140).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "304",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 122).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "305",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 123).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "354",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 137).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "356",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 124).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/EMResearch-EMB/errored/1/20/MatchState.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/EMResearch-EMB/codebuff/20/MatchState.java\nindex a97d90de94a..fa38742c805 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/EMResearch-EMB/errored/1/20/MatchState.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/EMResearch-EMB/codebuff/20/MatchState.java\n@@ -25,7 +25,6 @@ import java.util.Arrays;\n import java.util.List;\n import java.util.TreeSet;\n import java.util.regex.Pattern;\n-\n import org.apache.commons.lang3.StringUtils;\n import org.languagetool.AnalyzedToken;\n import org.languagetool.AnalyzedTokenReadings;\n@@ -44,31 +43,33 @@ import static org.languagetool.JLanguageTool.SENTENCE_START_TAGNAME;\n  * @author Stefan Lotties\n  * @since 2.3\n  */\n+\n+\n public class MatchState {\n \n-  private final Match match;\n-  private final Synthesizer synthesizer;\n+    private final Match match;\n+    private final Synthesizer synthesizer;\n+    private AnalyzedTokenReadings formattedToken;\n+    private AnalyzedTokenReadings matchedToken;\n+    private String skippedTokens;\n \n-  private AnalyzedTokenReadings formattedToken;\n-  private AnalyzedTokenReadings matchedToken;\n-  private String skippedTokens;\n+    public MatchState(Match match, Synthesizer synthesizer) {\n+        this.match = match;\n+        this.synthesizer = synthesizer;\n \n-  public MatchState(Match match, Synthesizer synthesizer) {\n-    this.match = match;\n-    this.synthesizer = synthesizer;\n-    String lemma = match.getLemma();\n-    if (!StringUtils.isEmpty(lemma)) {\n-      formattedToken = new AnalyzedTokenReadings(new AnalyzedToken(lemma, match.getPosTag(), lemma), 0);\n+        String lemma = match.getLemma();\n+        if (!StringUtils.isEmpty(lemma)) {\n+            formattedToken = new AnalyzedTokenReadings(new AnalyzedToken(lemma, match.getPosTag(), lemma), 0);\n+        }\n     }\n-  }\n \n-  public void setToken(AnalyzedTokenReadings token) {\n-    if (match.isStaticLemma()) {\n-      this.matchedToken = token;\n-    } else {\n-      this.formattedToken = token;\n+    public void setToken(AnalyzedTokenReadings token) {\n+        if (match.isStaticLemma()) {\n+            this.matchedToken = token;\n+        } else {\n+            this.formattedToken = token;\n+        }\n     }\n-  }\n \n   /**\n    * Sets the token to be formatted etc. and includes the support for\n@@ -78,105 +79,103 @@ public class MatchState {\n    * @param index Index of the token to be formatted\n    * @param next Position of the next token (the skipped tokens are the ones between the tokens[index] and tokens[next]\n    */\n-  public final void setToken(AnalyzedTokenReadings[] tokens, int index, int next) {\n-    int idx = index;\n-    if (index >= tokens.length) {\n+\n+    public final void setToken(AnalyzedTokenReadings[] tokens, int index, int next) {\n+        int idx = index;\n+        if (index >= tokens.length) {\n       // TODO: hacky workaround, find a proper solution. See EnglishPatternRuleTest.testBug()\n-      idx = tokens.length - 1;\n-    }\n-    setToken(tokens[idx]);\n-    IncludeRange includeSkipped = match.getIncludeSkipped();\n-    if (next > 1 && includeSkipped != IncludeRange.NONE) {\n-      StringBuilder sb = new StringBuilder();\n-      if (includeSkipped == IncludeRange.FOLLOWING) {\n-        formattedToken = null;\n-      }\n-      for (int k = index + 1; k < index + next; k++) {\n-        if (tokens[k].isWhitespaceBefore()\n-            && !(k == index + 1 && includeSkipped == IncludeRange.FOLLOWING)) {\n-          sb.append(' ');\n+            idx = tokens.length - 1;\n+        }\n+        setToken(tokens[idx]);\n+\n+        IncludeRange includeSkipped = match.getIncludeSkipped();\n+        if (next > 1 && includeSkipped != IncludeRange.NONE) {\n+            StringBuilder sb = new StringBuilder();\n+            if (includeSkipped == IncludeRange.FOLLOWING) {\n+                formattedToken = null;\n+            }\n+\n+            for (int k = index + 1; k < index + next; k++) {\n+                if (tokens[k].isWhitespaceBefore() && !(k == index + 1 && includeSkipped == IncludeRange.FOLLOWING)) {\n+                    sb.append(' ');\n+                }\n+                sb.append(tokens[k].getToken());\n+            }\n+            skippedTokens = sb.toString();\n+        } else {\n+            skippedTokens = \"\";\n         }\n-        sb.append(tokens[k].getToken());\n-      }\n-      skippedTokens = sb.toString();\n-    } else {\n-      skippedTokens = \"\";\n     }\n-  }\n \n-  public final AnalyzedTokenReadings filterReadings() {\n-    List<AnalyzedToken> l = new ArrayList<>();\n-    if (formattedToken != null) {\n-      if (match.isStaticLemma()) {\n+    public final AnalyzedTokenReadings filterReadings() {\n+        List<AnalyzedToken> l = new ArrayList<>();\n+        if (formattedToken != null) {\n+        if (match.isStaticLemma()) {\n         // Note: we want the token without ignored characters so we can't use matchedToken.getToken()\n-        matchedToken.leaveReading(new AnalyzedToken(matchedToken.getReadings().get(0).getToken(),\n-                match.getPosTag(), formattedToken.getToken()));\n-        formattedToken = matchedToken;\n-      }\n+            matchedToken.leaveReading(new AnalyzedToken(matchedToken.getReadings().get(0).getToken(),\n+                match.getPosTag(),\n+                    formattedToken.getToken()));\n+            formattedToken = matchedToken;\n+        }\n       // Note: we want the token without ignored characters so we can't use formattedToken.getToken()\n-      String token = formattedToken.getAnalyzedToken(0).getToken();\n-      Pattern regexMatch = match.getRegexMatch();\n-      String regexReplace = match.getRegexReplace();\n-      if (regexMatch != null && regexReplace != null) {\n+        String token = formattedToken.getAnalyzedToken(0).getToken();\n+        Pattern regexMatch = match.getRegexMatch();\n+        String regexReplace = match.getRegexReplace();\n+        if (regexMatch != null && regexReplace != null) {\n         /* only replace if it is something to replace */\n-        token = regexMatch.matcher(token).replaceAll(regexReplace);\n-      }\n-      token = convertCase(token, token, null);\n+            token = regexMatch.matcher(token).replaceAll(regexReplace);\n+        }\n+        token = convertCase(token, token, null);\n \n-      String posTag = match.getPosTag();\n-      if (posTag != null) {\n-        int numRead = formattedToken.getReadingsLength();\n-        if (match.isPostagRegexp()) {\n-          Pattern pPosRegexMatch = match.getPosRegexMatch();\n-          String posTagReplace = match.getPosTagReplace();\n-          String targetPosTag;\n-          for (int i = 0; i < numRead; i++) {\n-            String testTag = formattedToken.getAnalyzedToken(i).getPOSTag();\n-            if (testTag != null && pPosRegexMatch.matcher(testTag).matches()) {\n-              targetPosTag = testTag;\n-              if (posTagReplace != null) {\n-                targetPosTag = pPosRegexMatch.matcher(targetPosTag).replaceAll(posTagReplace);\n-              }\n-              l.add(new AnalyzedToken(token, targetPosTag,\n-                  formattedToken.getAnalyzedToken(i).getLemma()));\n-              l.get(l.size() - 1).setWhitespaceBefore(formattedToken.isWhitespaceBefore());\n+        String posTag = match.getPosTag();\n+        if (posTag != null) {\n+            int numRead = formattedToken.getReadingsLength();\n+            if (match.isPostagRegexp()) {\n+                Pattern pPosRegexMatch = match.getPosRegexMatch();\n+                String posTagReplace = match.getPosTagReplace();\n+                String targetPosTag;\n+                for (int i = 0; i < numRead; i++) {\n+                                            String testTag = formattedToken.getAnalyzedToken(i).getPOSTag();\n+                                            if (testTag != null && pPosRegexMatch.matcher(testTag).matches()) {\n+                                                targetPosTag = testTag;\n+                                                if (posTagReplace != null) {\n+                                                    targetPosTag = pPosRegexMatch.matcher(targetPosTag).replaceAll(posTagReplace);\n+                                                }\n+                                                l.add(new AnalyzedToken(token, targetPosTag, formattedToken.getAnalyzedToken(i).getLemma()));\n+                                                l.get(l.size() - 1).setWhitespaceBefore(formattedToken.isWhitespaceBefore());\n+                                            }\n+                }\n+                if (l.isEmpty()) {\n+                    l.addAll(getNewToken(numRead, token));\n+                }\n+            } else {\n+                l.addAll(getNewToken(numRead, token));\n+            }\n+            String lemma = formattedToken.getAnalyzedToken(0).getLemma();\n+            if (formattedToken.isSentenceEnd()) {\n+                l.add(new AnalyzedToken(formattedToken.getToken(), SENTENCE_END_TAGNAME, lemma));\n+            }\n+            if (formattedToken.isParagraphEnd()) {\n+                l.add(new AnalyzedToken(formattedToken.getToken(), PARAGRAPH_END_TAGNAME, lemma));\n             }\n-          }\n-          if (l.isEmpty()) {\n-            l.addAll(getNewToken(numRead, token));\n-          }\n-        } else {\n-          l.addAll(getNewToken(numRead, token));\n         }\n-        String lemma = formattedToken.getAnalyzedToken(0).getLemma();\n-        if (formattedToken.isSentenceEnd()) {\n-          l.add(new AnalyzedToken(formattedToken.getToken(), SENTENCE_END_TAGNAME, lemma));\n         }\n-        if (formattedToken.isParagraphEnd()) {\n-          l.add(new AnalyzedToken(formattedToken.getToken(), PARAGRAPH_END_TAGNAME, lemma));\n+        if (l.isEmpty()) {\n+            return formattedToken;\n         }\n-\n-      }\n-    }\n-    if (l.isEmpty()) {\n-      return formattedToken;\n-    }\n-    final AnalyzedTokenReadings anTkRead = new AnalyzedTokenReadings(\n-        l.toArray(new AnalyzedToken[0]),\n-        formattedToken.getStartPos());\n+        final AnalyzedTokenReadings anTkRead = new AnalyzedTokenReadings(l.toArray(new AnalyzedToken[0]), formattedToken.getStartPos());\n     // TODO: in case original had ignored characters we want to restore readings.token\n     // but there's no setToken() available :(\n //    anTkRead.setToken(formattedToken.getToken());\n-    \n-    anTkRead.setWhitespaceBefore(formattedToken.getWhitespaceBefore());\n-    if (!formattedToken.getChunkTags().isEmpty()) {\n-      anTkRead.setChunkTags(formattedToken.getChunkTags());\n-    }\n-    if (formattedToken.isImmunized()) {\n-      anTkRead.immunize();\n+        anTkRead.setWhitespaceBefore(formattedToken.getWhitespaceBefore());\n+        if (!formattedToken.getChunkTags().isEmpty()) {\n+            anTkRead.setChunkTags(formattedToken.getChunkTags());\n+        }\n+        if (formattedToken.isImmunized()) {\n+            anTkRead.immunize();\n+        }\n+        return anTkRead;\n     }\n-    return anTkRead;\n-  }\n \n   /**\n    * Converts case of the string token according to match element attributes.\n@@ -184,136 +183,132 @@ public class MatchState {\n    * @param sample the sample string used to determine how the original string looks like (used only on case preservation)\n    * @return Converted string.\n    */\n-  String convertCase(String s, String sample, Language lang) {\n+\n+    String convertCase(String s, String sample, Language lang) {\n     return CaseConversionHelper.convertCase(match.getCaseConversionType(), s, sample, lang);\n-  }\n+    }\n \n-  private List<AnalyzedToken> getNewToken(int numRead, String token) {\n-    String posTag = match.getPosTag();\n-    List<AnalyzedToken> list = new ArrayList<>();\n-    String lemma = \"\";\n-    for (int j = 0; j < numRead; j++) {\n-      String tempPosTag = formattedToken.getAnalyzedToken(j).getPOSTag();\n-      if (tempPosTag != null) {\n-        if (tempPosTag.equals(posTag) && formattedToken.getAnalyzedToken(j).getLemma() != null) {\n-          lemma = formattedToken.getAnalyzedToken(j).getLemma();\n+    private List<AnalyzedToken> getNewToken(int numRead, String token) {\n+        String posTag = match.getPosTag();\n+        List<AnalyzedToken> list = new ArrayList<>();\n+        String lemma = \"\";\n+        for (int j = 0; j < numRead; j++) {\n+        String tempPosTag = formattedToken.getAnalyzedToken(j).getPOSTag();\n+        if (tempPosTag != null) {\n+            if (tempPosTag.equals(posTag) && formattedToken.getAnalyzedToken(j).getLemma() != null) {\n+                lemma = formattedToken.getAnalyzedToken(j).getLemma();\n+            }\n+            if (StringTools.isEmpty(lemma)) {\n+                lemma = formattedToken.getAnalyzedToken(0).getLemma();\n+            }\n+            list.add(new AnalyzedToken(token, posTag, lemma));\n+            list.get(list.size() - 1).setWhitespaceBefore(formattedToken.isWhitespaceBefore());\n         }\n-        if (StringTools.isEmpty(lemma)) {\n-          lemma = formattedToken.getAnalyzedToken(0).getLemma();\n         }\n-        list.add(new AnalyzedToken(token, posTag, lemma));\n-        list.get(list.size() - 1).setWhitespaceBefore(\n-            formattedToken.isWhitespaceBefore());\n-      }\n+        return list;\n     }\n-    return list;\n-  }\n \n   /**\n    * Gets all strings formatted using the match element.\n    */\n-  public final String[] toFinalString(Language lang) throws IOException {\n-    String[] formattedString = new String[1];\n-    if (formattedToken != null) {\n-      int readingCount = formattedToken.getReadingsLength();\n-      formattedString[0] = formattedToken.getToken();\n \n-      Pattern pRegexMatch = match.getRegexMatch();\n-      String regexReplace = match.getRegexReplace();\n-      if (pRegexMatch != null) {\n-        formattedString[0] = pRegexMatch.matcher(formattedString[0]).replaceAll(regexReplace);\n-      }\n+    public final String[] toFinalString(Language lang) throws IOException {\n+        String[] formattedString = new String[1];\n+        if (formattedToken != null) {\n+        int readingCount = formattedToken.getReadingsLength();\n+        formattedString[0] = formattedToken.getToken();\n \n-      String posTag = match.getPosTag();\n-      if (posTag != null) {\n-        if (synthesizer == null) {\n-          formattedString[0] = formattedToken.getToken();\n-        } else if (match.isPostagRegexp()) {\n-          TreeSet<String> wordForms = new TreeSet<>();\n-          boolean oneForm = false;\n-          for (int k = 0; k < readingCount; k++) {\n-            if (formattedToken.getAnalyzedToken(k).getLemma() == null) {\n-              String posUnique = formattedToken.getAnalyzedToken(k).getPOSTag();\n-              if (posUnique == null) {\n-                wordForms.add(formattedToken.getToken());\n-                oneForm = true;\n-              } else {\n-                if (SENTENCE_START_TAGNAME.equals(posUnique)\n-                    || SENTENCE_END_TAGNAME.equals(posUnique)\n-                    || PARAGRAPH_END_TAGNAME.equals(posUnique)) {\n-                  if (!oneForm) {\n-                    wordForms.add(formattedToken.getToken());\n+        Pattern pRegexMatch = match.getRegexMatch();\n+        String regexReplace = match.getRegexReplace();\n+        if (pRegexMatch != null) {\n+            formattedString[0] = pRegexMatch.matcher(formattedString[0]).replaceAll(regexReplace);\n+        }\n+        String posTag = match.getPosTag();\n+        if (posTag != null) {\n+            if (synthesizer == null) {\n+                formattedString[0] = formattedToken.getToken();\n+            } else if (match.isPostagRegexp()) {\n+              TreeSet<String> wordForms = new TreeSet<>();\n+              boolean oneForm = false;\n+              for (int k = 0; k < readingCount; k++) {\n+                  if (formattedToken.getAnalyzedToken(k).getLemma() == null) {\n+                      String posUnique = formattedToken.getAnalyzedToken(k).getPOSTag();\n+                      if (posUnique == null) {\n+                          wordForms.add(formattedToken.getToken());\n+                          oneForm = true;\n+                      } else {\n+                          if (SENTENCE_START_TAGNAME.equals(posUnique) || SENTENCE_END_TAGNAME.equals(posUnique) || PARAGRAPH_END_TAGNAME.equals(posUnique)) {\n+                              if (!oneForm) {\n+                                  wordForms.add(formattedToken.getToken());\n+                              }\n+                              oneForm = true;\n+                          } else {\n+                              oneForm = false;\n+                          }\n+                      }\n                   }\n-                  oneForm = true;\n-                } else {\n-                  oneForm = false;\n-                }\n               }\n-            }\n-          }\n-          String targetPosTag = getTargetPosTag();\n-          if (!oneForm) {\n-            for (int i = 0; i < readingCount; i++) {\n-              String[] possibleWordForms = synthesizer.synthesize(\n-                  formattedToken.getAnalyzedToken(i), targetPosTag, true);\n-              if (possibleWordForms != null && possibleWordForms.length > 0) {\n-                wordForms.addAll(Arrays.asList(possibleWordForms));\n+              String targetPosTag = getTargetPosTag();\n+              if (!oneForm) {\n+                  for (int i = 0; i < readingCount; i++) {\n+                                String[] possibleWordForms = synthesizer.synthesize(formattedToken.getAnalyzedToken(i), targetPosTag, true);\n+                                if (possibleWordForms != null && possibleWordForms.length > 0) {\n+                                    wordForms.addAll(Arrays.asList(possibleWordForms));\n+                                }\n+                  }\n               }\n+              if (wordForms.isEmpty()) {\n+                  formattedString[0] = \"(\" + formattedToken.getToken() + \")\";\n+              } else {\n+                  formattedString = wordForms.toArray(new String[0]);\n+              }\n+            } else {\n+                TreeSet<String> wordForms = new TreeSet<>();\n+                for (int i = 0; i < readingCount; i++) {\n+                       String[] possibleWordForms = synthesizer.synthesize(formattedToken.getAnalyzedToken(i), posTag);\n+                       if (possibleWordForms != null) {\n+                           wordForms.addAll(Arrays.asList(possibleWordForms));\n+                       }\n+                }\n+                formattedString = wordForms.toArray(new String[0]);\n             }\n-          }\n-          if (wordForms.isEmpty()) {\n-            formattedString[0] = \"(\" + formattedToken.getToken() + \")\";\n-          } else {\n-            formattedString = wordForms.toArray(new String[0]);\n-          }\n+        }\n+        }\n+        String original;\n+        if (match.isStaticLemma()) {\n+            original = matchedToken != null ? matchedToken.getToken() : \"\";\n         } else {\n-          TreeSet<String> wordForms = new TreeSet<>();\n-          for (int i = 0; i < readingCount; i++) {\n-            String[] possibleWordForms = synthesizer.synthesize(formattedToken.getAnalyzedToken(i), posTag);\n-            if (possibleWordForms != null) {\n-              wordForms.addAll(Arrays.asList(possibleWordForms));\n-            }\n-          }\n-          formattedString = wordForms.toArray(new String[0]);\n+            original = formattedToken != null ? formattedToken.getToken() : \"\";\n+        }\n+\n+        for (int i = 0; i < formattedString.length; i++) {\n+        formattedString[i] = convertCase(formattedString[i], original, lang);\n         }\n-      }\n-    }\n-    String original;\n-    if (match.isStaticLemma()) {\n-      original = matchedToken != null ? matchedToken.getToken() : \"\";\n-    } else {\n-      original = formattedToken != null ? formattedToken.getToken() : \"\";\n-    }\n-    for (int i = 0; i < formattedString.length; i++) {\n-      formattedString[i] = convertCase(formattedString[i], original, lang);\n-    }\n     // TODO should case conversion happen before or after including skipped tokens?\n-    IncludeRange includeSkipped = match.getIncludeSkipped();\n-    if (includeSkipped != IncludeRange.NONE && skippedTokens != null\n-        && !skippedTokens.isEmpty()) {\n-      String[] helper = new String[formattedString.length];\n-      for (int i = 0; i < formattedString.length; i++) {\n-        if (formattedString[i] == null) {\n-          formattedString[i] = \"\";\n+        IncludeRange includeSkipped = match.getIncludeSkipped();\n+        if (includeSkipped != IncludeRange.NONE && skippedTokens != null && !skippedTokens.isEmpty()) {\n+            String[] helper = new String[formattedString.length];\n+            for (int i = 0; i < formattedString.length; i++) {\n+                if (formattedString[i] == null) {\n+                    formattedString[i] = \"\";\n+                }\n+                helper[i] = formattedString[i] + skippedTokens;\n+            }\n+            formattedString = helper;\n         }\n-        helper[i] = formattedString[i] + skippedTokens;\n-      }\n-      formattedString = helper;\n-    }\n-    if (match.checksSpelling() && lang != null) {\n-      List<String> formattedStringElements = Arrays.asList(formattedString);\n+        if (match.checksSpelling() && lang != null) {\n+            List<String> formattedStringElements = Arrays.asList(formattedString);\n       // tagger-based speller\n-      List<AnalyzedTokenReadings> analyzed = lang.getTagger().tag(\n-          formattedStringElements);\n-      for (int i = 0; i < formattedString.length; i++) {\n-        AnalyzedToken analyzedToken = analyzed.get(i).getAnalyzedToken(0);\n-        if (analyzedToken.getLemma() == null && analyzedToken.hasNoTag()) {\n-          formattedString[i] = PatternRuleMatcher.MISTAKE;\n+            List<AnalyzedTokenReadings> analyzed = lang.getTagger().tag(formattedStringElements);\n+            for (int i = 0; i < formattedString.length; i++) {\n+                                                        AnalyzedToken analyzedToken = analyzed.get(i).getAnalyzedToken(0);\n+                                                        if (analyzedToken.getLemma() == null && analyzedToken.hasNoTag()) {\n+                                                            formattedString[i] = PatternRuleMatcher.MISTAKE;\n+                                                        }\n+            }\n         }\n-      }\n+        return formattedString;\n     }\n-    return formattedString;\n-  }\n \n   /**\n    * Format POS tag using parameters already defined in the class.\n@@ -322,68 +317,67 @@ public class MatchState {\n    */\n   // FIXME: gets only the first POS tag that matches, this can be wrong\n   // on the other hand, many POS tags = too many suggestions?\n-  public final String getTargetPosTag() {\n-    String targetPosTag = match.getPosTag();\n-    List<String> posTags = new ArrayList<>();\n-    Pattern pPosRegexMatch = match.getPosRegexMatch();\n-    String posTagReplace = match.getPosTagReplace();\n \n-    if (match.isStaticLemma()) {\n-      for (AnalyzedToken analyzedToken : matchedToken) {\n-        String tst = analyzedToken.getPOSTag();\n-        if (tst != null && pPosRegexMatch.matcher(tst).matches()) {\n-          targetPosTag = analyzedToken.getPOSTag();\n-          posTags.add(targetPosTag);\n-        }\n-      }\n-      \n-      if (pPosRegexMatch != null && posTagReplace != null && !posTags.isEmpty()) {\n-        targetPosTag = pPosRegexMatch.matcher(targetPosTag).replaceAll(\n-            posTagReplace);\n-      }\n-    } else {\n-      for (AnalyzedToken analyzedToken : formattedToken) {\n-        String tst = analyzedToken.getPOSTag();\n-        if (tst != null && pPosRegexMatch.matcher(tst).matches()) {\n-          targetPosTag = analyzedToken.getPOSTag();\n-          posTags.add(targetPosTag);\n-        }\n-      }\n-      if (pPosRegexMatch != null && posTagReplace != null) {\n-        if (posTags.isEmpty()) {\n-          posTags.add(targetPosTag);\n-        }\n-        StringBuilder sb = new StringBuilder();\n-        int posTagLen = posTags.size();\n-        int l = 0;\n-        for (String lPosTag : posTags) {\n-          l++;\n-          lPosTag = pPosRegexMatch.matcher(lPosTag).replaceAll(posTagReplace);\n-          if (match.setsPos()) {\n-            lPosTag = synthesizer.getPosTagCorrection(lPosTag);\n-          }\n-          sb.append(lPosTag);\n-          if (l < posTagLen) {\n-            sb.append('|');\n-          }\n+    public final String getTargetPosTag() {\n+        String targetPosTag = match.getPosTag();\n+        List<String> posTags = new ArrayList<>();\n+        Pattern pPosRegexMatch = match.getPosRegexMatch();\n+        String posTagReplace = match.getPosTagReplace();\n+        if (match.isStaticLemma()) {\n+            for (AnalyzedToken analyzedToken : matchedToken) {\n+                                       String tst = analyzedToken.getPOSTag();\n+                                       if (tst != null && pPosRegexMatch.matcher(tst).matches()) {\n+                                           targetPosTag = analyzedToken.getPOSTag();\n+                                           posTags.add(targetPosTag);\n+                                       }\n+            }\n+            if (pPosRegexMatch != null && posTagReplace != null && !posTags.isEmpty()) {\n+                targetPosTag = pPosRegexMatch.matcher(targetPosTag).replaceAll(posTagReplace);\n+            }\n+        } else {\n+            for (AnalyzedToken analyzedToken : formattedToken) {\n+                   String tst = analyzedToken.getPOSTag();\n+                   if (tst != null && pPosRegexMatch.matcher(tst).matches()) {\n+                       targetPosTag = analyzedToken.getPOSTag();\n+                       posTags.add(targetPosTag);\n+                   }\n+            }\n+            if (pPosRegexMatch != null && posTagReplace != null) {\n+            if (posTags.isEmpty()) {\n+                posTags.add(targetPosTag);\n+            }\n+            StringBuilder sb = new StringBuilder();\n+            int posTagLen = posTags.size();\n+            int l = 0;\n+            for (String lPosTag : posTags) {\n+                                                                     l++;\n+                                                                     lPosTag = pPosRegexMatch.matcher(lPosTag).replaceAll(posTagReplace);\n+                                                                     if (match.setsPos()) {\n+                                                                         lPosTag = synthesizer.getPosTagCorrection(lPosTag);\n+                                                                     }\n+                                                                     sb.append(lPosTag);\n+                                                                     if (l < posTagLen) {\n+                                                                         sb.append('|');\n+                                                                     }\n+            }\n+            targetPosTag = sb.toString();\n+            }\n         }\n-        targetPosTag = sb.toString();\n-      }\n+        return targetPosTag;\n     }\n-    return targetPosTag;\n-  }\n \n   /**\n    * Method for getting the formatted match as a single string. In case of\n    * multiple matches, it joins them using a regular expression operator \"|\".\n    * @return Formatted string of the matched token.\n    */\n-  final String toTokenString() throws IOException {\n-    String[] stringToFormat = toFinalString(null);\n-    return String.join(\"|\", Arrays.asList(stringToFormat));\n-  }\n \n-  public Match getMatch() {\n-    return match;\n-  }\n-}\n+    final String toTokenString() throws IOException {\n+        String[] stringToFormat = toFinalString(null);\n+        return String.join(\"|\", Arrays.asList(stringToFormat));\n+    }\n+\n+    public Match getMatch() {\n+        return match;\n+    }\n+}\n\\ No newline at end of file\n",
            "diff_size": 339
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "184",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 122).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "184",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 122).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ],
    "repaired_by": [],
    "not_repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}