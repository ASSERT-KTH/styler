{
    "project_name": "NationalSecurityAgency-datawave",
    "error_id": "86",
    "information": {
        "errors": [
            {
                "line": "62",
                "severity": "error",
                "message": "Accumulo non-public classes imported",
                "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
            }
        ]
    },
    "source_code": "import org.apache.accumulo.core.security.Authorizations;\nimport org.apache.accumulo.core.security.ColumnVisibility;\nimport org.apache.accumulo.core.util.Pair;\nimport org.apache.commons.lang.StringUtils;\nimport org.apache.hadoop.io.Text;\nimport org.apache.log4j.Logger;",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "62",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "62",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/86/MutableMetadataHandler.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/intellij/86/MutableMetadataHandler.java\nindex 93a7e789ed0..c53aa0e6651 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/86/MutableMetadataHandler.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/intellij/86/MutableMetadataHandler.java\n@@ -68,10 +68,10 @@ import org.apache.log4j.Logger;\n  * Class that handles requests for modification requests (INSERT, UPDATE, DELETE) for metadata in the shard schema. <br>\n  * <br>\n  * INSERT Example using Column Visibility: <br>\n- * \n+ *\n  * <pre>\n  * {@code\n- * \n+ *\n  * <DefaultModificationRequest>\n  *   <Events>\n  *     <Event>\n@@ -87,13 +87,13 @@ import org.apache.log4j.Logger;\n  * </DefaultModificationRequest>\n  * }\n  * </pre>\n- * \n+ *\n  * <br>\n  * DELETE Example when removing a single value using Column Visibility: <br>\n- * \n+ *\n  * <pre>\n  * {@code\n- * \n+ *\n  * <DefaultModificationRequest>\n  *   <Events>\n  *     <Event>\n@@ -109,10 +109,10 @@ import org.apache.log4j.Logger;\n  * </DefaultModificationRequest>\n  * }\n  * </pre>\n- * \n+ *\n  * <br>\n  * DELETE Example when removing all entries for a field with a specific value (different column visibilities): <br>\n- * \n+ *\n  * <pre>\n  * {@code\n  * <DefaultModificationRequest>\n@@ -132,7 +132,7 @@ import org.apache.log4j.Logger;\n  *\n  * <br>\n  * UPDATE Example when removing a single value and replacing it with a new one using ColumnVisibilities:<br>\n- * \n+ *\n  * <pre>\n  * {@code\n  * <DefaultModificationRequest>\n@@ -152,13 +152,13 @@ import org.apache.log4j.Logger;\n  * </DefaultModificationRequest>\n  * }\n  * </pre>\n- * \n+ *\n  * <br>\n  * * UPDATE Example removing all entries for a field with a specific value (different column visibilities) and replacing it with a new one:<br>\n- * \n+ *\n  * <pre>\n  * {@code\n- * \n+ *\n  * <DefaultModificationRequest>\n  *   <Events>\n  *     <Event>\n@@ -175,910 +175,968 @@ import org.apache.log4j.Logger;\n  * </DefaultModificationRequest>\n  * }\n  * </pre>\n- * \n  */\n public class MutableMetadataHandler extends ModificationServiceConfiguration {\n-    \n-    private Logger log = Logger.getLogger(this.getClass());\n-    \n-    protected static final long MS_PER_DAY = TimeUnit.DAYS.toMillis(1);\n-    protected static final String DESCRIPTION = \"Modification service that processes insert, update, and delete requests of event fields for event(s) identified by the shard id, datatype, and event uid.\";\n-    public static final String FIELD_INDEX_PREFIX = \"fi\\0\";\n-    protected static final String NULL_BYTE = \"\\0\";\n-    protected static final String MAX_CHAR = new String(Character.toChars(Character.MAX_CODE_POINT));\n-    protected static final Value NULL_VALUE = new Value(new byte[0]);\n-    public static final String HISTORY_PREFIX = \"HISTORY_\";\n-    \n-    protected String eventTableName = null;\n-    protected String indexTableName = null;\n-    protected String reverseIndexTableName = null;\n-    protected String metadataTableName = null;\n-    protected MetadataHelperFactory metadataHelperFactory;\n-    protected MarkingFunctions markingFunctions = null;\n-    \n-    // a map of event fields to index only/derived fields to enable appropriate deleting of event fields and all derivatives\n-    protected Multimap<String,String> indexOnlyMap = null;\n-    \n-    // a set of token suffixes to include to enable appropriate deleting of event fields and all derivatives\n-    protected Set<String> indexOnlySuffixes = null;\n-    \n-    // a list of event fields that map to content\n-    protected Set<String> contentFields = null;\n-    \n-    public String getEventTableName() {\n-        return eventTableName;\n-    }\n-    \n-    public void setEventTableName(String eventTableName) {\n-        this.eventTableName = eventTableName;\n-    }\n-    \n-    public String getIndexTableName() {\n-        return indexTableName;\n-    }\n-    \n-    public void setIndexTableName(String indexTableName) {\n-        this.indexTableName = indexTableName;\n-    }\n-    \n-    public String getReverseIndexTableName() {\n-        return reverseIndexTableName;\n-    }\n-    \n-    public void setReverseIndexTableName(String reverseIndexTableName) {\n-        this.reverseIndexTableName = reverseIndexTableName;\n-    }\n-    \n-    public String getMetadataTableName() {\n-        return metadataTableName;\n-    }\n-    \n-    public void setMetadataTableName(String metadataTableName) {\n-        this.metadataTableName = metadataTableName;\n-    }\n-    \n-    public MarkingFunctions getMarkingFunctions() {\n-        return markingFunctions;\n-    }\n-    \n-    public void setMarkingFunctions(MarkingFunctions markingFunctions) {\n-        this.markingFunctions = markingFunctions;\n+\n+  private Logger log = Logger.getLogger(this.getClass());\n+\n+  protected static final long MS_PER_DAY = TimeUnit.DAYS.toMillis(1);\n+  protected static final String DESCRIPTION =\n+      \"Modification service that processes insert, update, and delete requests of event fields for event(s) identified by the shard id, datatype, and event uid.\";\n+  public static final String FIELD_INDEX_PREFIX = \"fi\\0\";\n+  protected static final String NULL_BYTE = \"\\0\";\n+  protected static final String MAX_CHAR = new String(Character.toChars(Character.MAX_CODE_POINT));\n+  protected static final Value NULL_VALUE = new Value(new byte[0]);\n+  public static final String HISTORY_PREFIX = \"HISTORY_\";\n+\n+  protected String eventTableName = null;\n+  protected String indexTableName = null;\n+  protected String reverseIndexTableName = null;\n+  protected String metadataTableName = null;\n+  protected MetadataHelperFactory metadataHelperFactory;\n+  protected MarkingFunctions markingFunctions = null;\n+\n+  // a map of event fields to index only/derived fields to enable appropriate deleting of event fields and all derivatives\n+  protected Multimap<String, String> indexOnlyMap = null;\n+\n+  // a set of token suffixes to include to enable appropriate deleting of event fields and all derivatives\n+  protected Set<String> indexOnlySuffixes = null;\n+\n+  // a list of event fields that map to content\n+  protected Set<String> contentFields = null;\n+\n+  public String getEventTableName() {\n+    return eventTableName;\n+  }\n+\n+  public void setEventTableName(String eventTableName) {\n+    this.eventTableName = eventTableName;\n+  }\n+\n+  public String getIndexTableName() {\n+    return indexTableName;\n+  }\n+\n+  public void setIndexTableName(String indexTableName) {\n+    this.indexTableName = indexTableName;\n+  }\n+\n+  public String getReverseIndexTableName() {\n+    return reverseIndexTableName;\n+  }\n+\n+  public void setReverseIndexTableName(String reverseIndexTableName) {\n+    this.reverseIndexTableName = reverseIndexTableName;\n+  }\n+\n+  public String getMetadataTableName() {\n+    return metadataTableName;\n+  }\n+\n+  public void setMetadataTableName(String metadataTableName) {\n+    this.metadataTableName = metadataTableName;\n+  }\n+\n+  public MarkingFunctions getMarkingFunctions() {\n+    return markingFunctions;\n+  }\n+\n+  public void setMarkingFunctions(MarkingFunctions markingFunctions) {\n+    this.markingFunctions = markingFunctions;\n+  }\n+\n+  public Multimap<String, String> getIndexOnlyMap() {\n+    return indexOnlyMap;\n+  }\n+\n+  // this is set from a spring configuration where the value is comma delimited\n+  public void setIndexOnlyMap(Map<String, String> map) {\n+    this.indexOnlyMap = HashMultimap.create();\n+    for (Map.Entry<String, String> entry : map.entrySet()) {\n+      for (String value : StringUtils.split(entry.getValue(), ',')) {\n+        this.indexOnlyMap.put(entry.getKey(), value.trim());\n+      }\n     }\n-    \n-    public Multimap<String,String> getIndexOnlyMap() {\n-        return indexOnlyMap;\n+  }\n+\n+  public Set<String> getContentFields() {\n+    return contentFields;\n+  }\n+\n+  public void setContentFields(Set<String> fields) {\n+    this.contentFields = fields;\n+  }\n+\n+  public Set<String> getIndexOnlySuffixes() {\n+    return indexOnlySuffixes;\n+  }\n+\n+  public void setIndexOnlySuffixes(Set<String> suffixes) {\n+    this.indexOnlySuffixes = suffixes;\n+  }\n+\n+  public MetadataHelperFactory getMetadataHelperFactory() {\n+    return metadataHelperFactory;\n+  }\n+\n+  public void setMetadataHelperFactory(MetadataHelperFactory metadataHelperFactory) {\n+    this.metadataHelperFactory = metadataHelperFactory;\n+  }\n+\n+  @Override\n+  public String getDescription() {\n+    return DESCRIPTION;\n+  }\n+\n+  @Override\n+  public Class<? extends ModificationRequestBase> getRequestClass() {\n+    return DefaultModificationRequest.class;\n+  }\n+\n+  // Default the insert history option to true so that the call remains backwards compatible.\n+  @Override\n+  public void process(AccumuloClient client, ModificationRequestBase request, Map<String, Set<String>> mutableFieldList,\n+                      Set<Authorizations> userAuths,\n+                      String user) throws Exception {\n+    this.process(client, request, mutableFieldList, userAuths, user, false, true);\n+  }\n+\n+  public void process(AccumuloClient client, ModificationRequestBase request, Map<String, Set<String>> mutableFieldList,\n+                      Set<Authorizations> userAuths,\n+                      String user, boolean purgeIndex, boolean insertHistory) throws Exception {\n+\n+    DefaultModificationRequest mr = DefaultModificationRequest.class.cast(request);\n+\n+    if (null == mr.getEvents() || mr.getEvents().isEmpty()) {\n+      throw new IllegalArgumentException(\"No events specified for modification\");\n     }\n-    \n-    // this is set from a spring configuration where the value is comma delimited\n-    public void setIndexOnlyMap(Map<String,String> map) {\n-        this.indexOnlyMap = HashMultimap.create();\n-        for (Map.Entry<String,String> entry : map.entrySet()) {\n-            for (String value : StringUtils.split(entry.getValue(), ',')) {\n-                this.indexOnlyMap.put(entry.getKey(), value.trim());\n+\n+    String fieldName = mr.getFieldName();\n+    MetadataHelper helper = getMetadataHelper(client);\n+    MODE mode = mr.getMode();\n+    MultiTableBatchWriter writer = client\n+        .createMultiTableBatchWriter(new BatchWriterConfig().setMaxLatency(1, TimeUnit.SECONDS).setMaxMemory(1048576L)\n+            .setMaxWriteThreads(4));\n+    try {\n+      for (EventIdentifier e : mr.getEvents()) {\n+        String shardId = e.getShardId();\n+        String datatype = e.getDatatype();\n+        Set<String> datatypeFilter = Collections.singleton(datatype);\n+        String eventUid = e.getEventUid();\n+\n+        String oldFieldValue = null;\n+        Map<String, String> oldFieldMarkings = null;\n+        String oldColumnVisibility = null;\n+        List<Pair<Key, Value>> currentEntryList = null;\n+        int valHistoryCount = 0;\n+\n+        /*\n+         * Makes all fields mutable for services requiring no history.\n+         */\n+        if (insertHistory && !isFieldMutable(mutableFieldList, datatype, fieldName)) {\n+          throw new IllegalArgumentException(\"Field \" + fieldName + \" is not mutable\");\n+        }\n+\n+        boolean isIndexed = helper.isIndexed(fieldName, datatypeFilter);\n+        boolean isReverseIndexed = helper.isReverseIndexed(fieldName, datatypeFilter);\n+        boolean isIndexOnly = helper.getIndexOnlyFields(datatypeFilter).contains(fieldName);\n+        boolean isContent = (contentFields != null && contentFields.contains(fieldName));\n+        Set<Type<?>> dataTypes = helper.getDatatypesForField(fieldName, Collections.singleton(datatype));\n+\n+        if ((isIndexed || isReverseIndexed || isIndexOnly) && (null == dataTypes || dataTypes.isEmpty())) {\n+          throw new IllegalStateException(\"Field \" + fieldName + \" is marked index only but has no dataTypes\");\n+        }\n+\n+        long origTimestamp = getOriginalEventTimestamp(client, userAuths, shardId, datatype, eventUid);\n+\n+        // Count the history entries if history is going to be inserted.\n+        if (insertHistory && (MODE.INSERT.equals(mode) || MODE.UPDATE.equals(mode))) {\n+          List<Pair<Key, Value>> fieldHistoryList =\n+              getField(client, userAuths, shardId, datatype, eventUid, \"HISTORY_\" + fieldName, null,\n+                  new HashMap<>(), null);\n+\n+          for (Pair<Key, Value> p : fieldHistoryList) {\n+            if (p.getFirst().getColumnQualifier().find(mr.getFieldValue()) > -1) {\n+              ++valHistoryCount;\n             }\n+          }\n         }\n+\n+        if (MODE.UPDATE.equals(mode) || MODE.DELETE.equals(mode)) {\n+          if (MODE.UPDATE.equals(mode)) {\n+            oldFieldValue = mr.getOldFieldValue();\n+            oldFieldMarkings = mr.getOldFieldMarkings();\n+            oldColumnVisibility = mr.getOldColumnVisibility();\n+            if (null == oldFieldValue) {\n+              throw new IllegalArgumentException(\"fieldValue parameter required for update\");\n+            }\n+          } else {\n+            oldFieldValue = mr.getFieldValue();\n+            oldFieldMarkings = mr.getFieldMarkings();\n+            oldColumnVisibility = mr.getColumnVisibility();\n+            if (null == oldFieldValue) {\n+              throw new IllegalArgumentException(\"fieldValue parameter required for delete\");\n+            }\n+          }\n+          ColumnVisibility oldViz = null;\n+          if (null != oldColumnVisibility) {\n+            oldViz = new ColumnVisibility(oldColumnVisibility);\n+          }\n+\n+          // find the current values\n+          currentEntryList =\n+              getField(client, userAuths, shardId, datatype, eventUid, fieldName, oldFieldValue, oldFieldMarkings,\n+                  oldViz);\n+          if (oldFieldValue != null && currentEntryList.isEmpty()) {\n+            throw new IllegalArgumentException(\n+                \"Modification request rejected. Current value of \" + fieldName + \" does not match submitted value.\");\n+          }\n+        } else {\n+          if (null == mr.getFieldValue()) {\n+            throw new IllegalArgumentException(\"fieldValue parameter required for insert\");\n+          }\n+        }\n+\n+        if (MODE.INSERT.equals(mode)) {\n+          String fieldValue = mr.getFieldValue();\n+          Map<String, String> fieldMarkings = mr.getFieldMarkings();\n+          String columnVisibility = mr.getColumnVisibility();\n+          ColumnVisibility colviz = null;\n+          if (null != columnVisibility) {\n+            colviz = new ColumnVisibility(columnVisibility);\n+          }\n+          insert(writer, shardId, datatype, eventUid, fieldMarkings, colviz, fieldName, fieldValue, isIndexOnly,\n+              isIndexed, isReverseIndexed,\n+              dataTypes, user, MODE.INSERT, origTimestamp + valHistoryCount, insertHistory);\n+        } else if (MODE.DELETE.equals(mode)) {\n+          delete(writer, client, userAuths, currentEntryList, isIndexOnly, isIndexed, isReverseIndexed, isContent,\n+              dataTypes, user, MODE.DELETE,\n+              origTimestamp + valHistoryCount, purgeIndex, insertHistory);\n+        } else {\n+          delete(writer, client, userAuths, currentEntryList, isIndexOnly, isIndexed, isReverseIndexed, isContent,\n+              dataTypes, user, MODE.UPDATE,\n+              origTimestamp + valHistoryCount, purgeIndex, insertHistory);\n+          String fieldValue = mr.getFieldValue();\n+          Map<String, String> fieldMarkings = mr.getFieldMarkings();\n+          String columnVisibility = mr.getColumnVisibility();\n+          ColumnVisibility colviz = null;\n+          if (null != columnVisibility) {\n+            colviz = new ColumnVisibility(columnVisibility);\n+          }\n+          insert(writer, shardId, datatype, eventUid, fieldMarkings, colviz, fieldName, fieldValue, isIndexOnly,\n+              isIndexed, isReverseIndexed,\n+              dataTypes, user, MODE.UPDATE, origTimestamp + valHistoryCount, insertHistory);\n+        }\n+      }\n+    } finally {\n+      writer.close();\n     }\n-    \n-    public Set<String> getContentFields() {\n-        return contentFields;\n-    }\n-    \n-    public void setContentFields(Set<String> fields) {\n-        this.contentFields = fields;\n-    }\n-    \n-    public Set<String> getIndexOnlySuffixes() {\n-        return indexOnlySuffixes;\n-    }\n-    \n-    public void setIndexOnlySuffixes(Set<String> suffixes) {\n-        this.indexOnlySuffixes = suffixes;\n-    }\n-    \n-    public MetadataHelperFactory getMetadataHelperFactory() {\n-        return metadataHelperFactory;\n+  }\n+\n+  /**\n+   * Insert new field value with provided timestamp\n+   *\n+   * @param writer\n+   * @param shardId\n+   * @param datatype\n+   * @param eventUid\n+   * @param viz\n+   * @param fieldName\n+   * @param fieldValue\n+   * @param timestamp\n+   * @param isIndexed\n+   * @param isReverseIndexed\n+   * @param dataTypes\n+   * @param historicalValue\n+   * @param insertHistory\n+   * @param user\n+   * @param mode\n+   * @throws Exception\n+   */\n+  protected void insert(MultiTableBatchWriter writer, String shardId, String datatype, String eventUid,\n+                        ColumnVisibility viz, String fieldName,\n+                        String fieldValue, long timestamp, boolean isIndexOnlyField, boolean isIndexed,\n+                        boolean isReverseIndexed, Set<Type<?>> dataTypes,\n+                        boolean historicalValue, boolean insertHistory, String user, MODE mode) throws Exception {\n+\n+    // increment the term frequency\n+    Mutation m = new Mutation(fieldName);\n+    if (!isIndexOnlyField) {\n+      m.put(ColumnFamilyConstants.COLF_E, new Text(datatype), NULL_VALUE);\n+      m.put(ColumnFamilyConstants.COLF_F, new Text(datatype + NULL_BYTE + DateHelper.format(timestamp)),\n+          new Value(SummingCombiner.VAR_LEN_ENCODER.encode(1L)));\n     }\n-    \n-    public void setMetadataHelperFactory(MetadataHelperFactory metadataHelperFactory) {\n-        this.metadataHelperFactory = metadataHelperFactory;\n+\n+    // Insert the new field.\n+    Mutation e = new Mutation(shardId);\n+    if (!isIndexOnlyField) {\n+      e.put(new Text(datatype + NULL_BYTE + eventUid), new Text(fieldName + NULL_BYTE + fieldValue), viz, timestamp,\n+          NULL_VALUE);\n     }\n-    \n-    @Override\n-    public String getDescription() {\n-        return DESCRIPTION;\n+\n+    if (isIndexed) {\n+\n+      long tsToDay = (timestamp / MS_PER_DAY) * MS_PER_DAY;\n+\n+      // Create a UID object for the Value\n+      Builder uidBuilder = Uid.List.newBuilder();\n+      uidBuilder.setIGNORE(false);\n+      uidBuilder.setCOUNT(1);\n+      uidBuilder.addUID(eventUid);\n+      Uid.List uidList = uidBuilder.build();\n+      Value val = new Value(uidList.toByteArray());\n+\n+      for (Type<?> n : dataTypes) {\n+        String indexTerm = fieldValue;\n+        if (historicalValue) {\n+          int lastColon = fieldValue.lastIndexOf(\":\");\n+          // The next two lines build up to the beginning of the indexTerm by finding the first two colons\n+          // We could use split if we could guarantee a colon never appears in the index term itself\n+          int indexTermLeadingColon = fieldValue.indexOf(\":\", 0);\n+          indexTermLeadingColon = fieldValue.indexOf(\":\", indexTermLeadingColon + 1);\n+          indexTerm = fieldValue.substring(indexTermLeadingColon + 1, lastColon);\n+        }\n+        String indexedValue = n.normalize(indexTerm);\n+\n+        // Insert the global index entry\n+        Mutation i = new Mutation(indexedValue);\n+        i.put(fieldName, shardId + NULL_BYTE + datatype, viz, tsToDay, val);\n+        writer.getBatchWriter(this.getIndexTableName()).addMutation(i);\n+        m.put(ColumnFamilyConstants.COLF_I, new Text(datatype + NULL_BYTE + n.getClass().getName()), NULL_VALUE);\n+\n+        if (isReverseIndexed) {\n+          String reverseIndexedValue = StringUtils.reverse(indexedValue);\n+          // Insert the global reverse index entry\n+          Mutation rm = new Mutation(reverseIndexedValue);\n+          rm.put(fieldName, shardId + NULL_BYTE + datatype, viz, tsToDay, val);\n+          writer.getBatchWriter(this.getReverseIndexTableName()).addMutation(rm);\n+          m.put(ColumnFamilyConstants.COLF_RI, new Text(datatype + NULL_BYTE + n.getClass().getName()), NULL_VALUE);\n+        }\n+        // Insert the field index entry\n+        e.put(new Text(FIELD_INDEX_PREFIX + fieldName),\n+            new Text(indexedValue + NULL_BYTE + datatype + NULL_BYTE + eventUid), viz, timestamp,\n+            NULL_VALUE);\n+      }\n     }\n-    \n-    @Override\n-    public Class<? extends ModificationRequestBase> getRequestClass() {\n-        return DefaultModificationRequest.class;\n+    writer.getBatchWriter(this.getEventTableName()).addMutation(e);\n+    writer.getBatchWriter(this.getMetadataTableName()).addMutation(m);\n+    writer.flush();\n+\n+    if (!isIndexOnlyField && insertHistory) {\n+      insertHistory(writer, shardId, datatype, eventUid, viz, fieldName, fieldValue, timestamp, isIndexOnlyField,\n+          isIndexed, isReverseIndexed, dataTypes,\n+          user, mode);\n     }\n-    \n-    // Default the insert history option to true so that the call remains backwards compatible.\n-    @Override\n-    public void process(AccumuloClient client, ModificationRequestBase request, Map<String,Set<String>> mutableFieldList, Set<Authorizations> userAuths,\n-                    String user) throws Exception {\n-        this.process(client, request, mutableFieldList, userAuths, user, false, true);\n+  }\n+\n+  /**\n+   * Prepares the value to be inserted as history, then calls insert\n+   *\n+   * @param writer\n+   * @param shardId\n+   * @param datatype\n+   * @param eventUid\n+   * @param viz\n+   * @param fieldName\n+   * @param fieldValue\n+   * @param timestamp\n+   * @param isIndexOnlyField\n+   * @param isIndexed\n+   * @param isReverseIndexed\n+   * @param dataTypes\n+   * @param user\n+   * @param mode\n+   * @throws Exception\n+   */\n+  protected void insertHistory(MultiTableBatchWriter writer, String shardId, String datatype, String eventUid,\n+                               ColumnVisibility viz, String fieldName,\n+                               String fieldValue, long timestamp, boolean isIndexOnlyField, boolean isIndexed,\n+                               boolean isReverseIndexed, Set<Type<?>> dataTypes,\n+                               String user, MODE mode) throws Exception {\n+    // Capture the fact of the insert in a history element\n+    // History element has the following structure\n+    // FIELD NAME: HISTORY_<ORIGINAL FIELD NAME>\n+    // for Deletes - FIELD VALUE: <timestamp of original field value> : <user that modified/deleted it> : < original field value> : <operation type>\n+    // for Inserts - FIELD VALUE: <timestamp of operation> : <user that modified it> : < original field value> : <operation type>\n+    // Timestamp of history element is now.\n+    String historyFieldName = HISTORY_PREFIX + fieldName;\n+    String historyFieldValue;\n+    if (mode.equals(MODE.INSERT)) {\n+      historyFieldValue = System.currentTimeMillis() + \":\" + user + \":\" + fieldValue;\n+      historyFieldValue += \":insert\";\n+    } else if (mode.equals(MODE.DELETE)) {\n+      historyFieldValue = System.currentTimeMillis() + \":\" + user + \":\" + fieldValue;\n+      historyFieldValue += \":delete\";\n+    } else { // update\n+      historyFieldValue = System.currentTimeMillis() + \":\" + user + \":\" + fieldValue;\n+      historyFieldValue += \":update\";\n     }\n-    \n-    public void process(AccumuloClient client, ModificationRequestBase request, Map<String,Set<String>> mutableFieldList, Set<Authorizations> userAuths,\n-                    String user, boolean purgeIndex, boolean insertHistory) throws Exception {\n-        \n-        DefaultModificationRequest mr = DefaultModificationRequest.class.cast(request);\n-        \n-        if (null == mr.getEvents() || mr.getEvents().isEmpty()) {\n-            throw new IllegalArgumentException(\"No events specified for modification\");\n-        }\n-        \n-        String fieldName = mr.getFieldName();\n-        MetadataHelper helper = getMetadataHelper(client);\n-        MODE mode = mr.getMode();\n-        MultiTableBatchWriter writer = client.createMultiTableBatchWriter(new BatchWriterConfig().setMaxLatency(1, TimeUnit.SECONDS).setMaxMemory(1048576L)\n-                        .setMaxWriteThreads(4));\n-        try {\n-            for (EventIdentifier e : mr.getEvents()) {\n-                String shardId = e.getShardId();\n-                String datatype = e.getDatatype();\n-                Set<String> datatypeFilter = Collections.singleton(datatype);\n-                String eventUid = e.getEventUid();\n-                \n-                String oldFieldValue = null;\n-                Map<String,String> oldFieldMarkings = null;\n-                String oldColumnVisibility = null;\n-                List<Pair<Key,Value>> currentEntryList = null;\n-                int valHistoryCount = 0;\n-                \n-                /*\n-                 * Makes all fields mutable for services requiring no history.\n-                 */\n-                if (insertHistory && !isFieldMutable(mutableFieldList, datatype, fieldName))\n-                    throw new IllegalArgumentException(\"Field \" + fieldName + \" is not mutable\");\n-                \n-                boolean isIndexed = helper.isIndexed(fieldName, datatypeFilter);\n-                boolean isReverseIndexed = helper.isReverseIndexed(fieldName, datatypeFilter);\n-                boolean isIndexOnly = helper.getIndexOnlyFields(datatypeFilter).contains(fieldName);\n-                boolean isContent = (contentFields != null && contentFields.contains(fieldName));\n-                Set<Type<?>> dataTypes = helper.getDatatypesForField(fieldName, Collections.singleton(datatype));\n-                \n-                if ((isIndexed || isReverseIndexed || isIndexOnly) && (null == dataTypes || dataTypes.isEmpty()))\n-                    throw new IllegalStateException(\"Field \" + fieldName + \" is marked index only but has no dataTypes\");\n-                \n-                long origTimestamp = getOriginalEventTimestamp(client, userAuths, shardId, datatype, eventUid);\n-                \n-                // Count the history entries if history is going to be inserted.\n-                if (insertHistory && (MODE.INSERT.equals(mode) || MODE.UPDATE.equals(mode))) {\n-                    List<Pair<Key,Value>> fieldHistoryList = getField(client, userAuths, shardId, datatype, eventUid, \"HISTORY_\" + fieldName, null,\n-                                    new HashMap<>(), null);\n-                    \n-                    for (Pair<Key,Value> p : fieldHistoryList) {\n-                        if (p.getFirst().getColumnQualifier().find(mr.getFieldValue()) > -1) {\n-                            ++valHistoryCount;\n-                        }\n-                    }\n-                }\n-                \n-                if (MODE.UPDATE.equals(mode) || MODE.DELETE.equals(mode)) {\n-                    if (MODE.UPDATE.equals(mode)) {\n-                        oldFieldValue = mr.getOldFieldValue();\n-                        oldFieldMarkings = mr.getOldFieldMarkings();\n-                        oldColumnVisibility = mr.getOldColumnVisibility();\n-                        if (null == oldFieldValue)\n-                            throw new IllegalArgumentException(\"fieldValue parameter required for update\");\n-                    } else {\n-                        oldFieldValue = mr.getFieldValue();\n-                        oldFieldMarkings = mr.getFieldMarkings();\n-                        oldColumnVisibility = mr.getColumnVisibility();\n-                        if (null == oldFieldValue)\n-                            throw new IllegalArgumentException(\"fieldValue parameter required for delete\");\n-                    }\n-                    ColumnVisibility oldViz = null;\n-                    if (null != oldColumnVisibility) {\n-                        oldViz = new ColumnVisibility(oldColumnVisibility);\n-                    }\n-                    \n-                    // find the current values\n-                    currentEntryList = getField(client, userAuths, shardId, datatype, eventUid, fieldName, oldFieldValue, oldFieldMarkings, oldViz);\n-                    if (oldFieldValue != null && currentEntryList.isEmpty()) {\n-                        throw new IllegalArgumentException(\"Modification request rejected. Current value of \" + fieldName + \" does not match submitted value.\");\n-                    }\n-                } else {\n-                    if (null == mr.getFieldValue())\n-                        throw new IllegalArgumentException(\"fieldValue parameter required for insert\");\n-                }\n-                \n-                if (MODE.INSERT.equals(mode)) {\n-                    String fieldValue = mr.getFieldValue();\n-                    Map<String,String> fieldMarkings = mr.getFieldMarkings();\n-                    String columnVisibility = mr.getColumnVisibility();\n-                    ColumnVisibility colviz = null;\n-                    if (null != columnVisibility) {\n-                        colviz = new ColumnVisibility(columnVisibility);\n-                    }\n-                    insert(writer, shardId, datatype, eventUid, fieldMarkings, colviz, fieldName, fieldValue, isIndexOnly, isIndexed, isReverseIndexed,\n-                                    dataTypes, user, MODE.INSERT, origTimestamp + valHistoryCount, insertHistory);\n-                } else if (MODE.DELETE.equals(mode)) {\n-                    delete(writer, client, userAuths, currentEntryList, isIndexOnly, isIndexed, isReverseIndexed, isContent, dataTypes, user, MODE.DELETE,\n-                                    origTimestamp + valHistoryCount, purgeIndex, insertHistory);\n-                } else {\n-                    delete(writer, client, userAuths, currentEntryList, isIndexOnly, isIndexed, isReverseIndexed, isContent, dataTypes, user, MODE.UPDATE,\n-                                    origTimestamp + valHistoryCount, purgeIndex, insertHistory);\n-                    String fieldValue = mr.getFieldValue();\n-                    Map<String,String> fieldMarkings = mr.getFieldMarkings();\n-                    String columnVisibility = mr.getColumnVisibility();\n-                    ColumnVisibility colviz = null;\n-                    if (null != columnVisibility) {\n-                        colviz = new ColumnVisibility(columnVisibility);\n-                    }\n-                    insert(writer, shardId, datatype, eventUid, fieldMarkings, colviz, fieldName, fieldValue, isIndexOnly, isIndexed, isReverseIndexed,\n-                                    dataTypes, user, MODE.UPDATE, origTimestamp + valHistoryCount, insertHistory);\n-                }\n-            }\n-        } finally {\n-            writer.close();\n-        }\n+\n+    insert(writer, shardId, datatype, eventUid, viz, historyFieldName, historyFieldValue, timestamp, isIndexOnlyField,\n+        isIndexed, isReverseIndexed,\n+        dataTypes, true, false, user, mode);\n+  }\n+\n+  /**\n+   * Insert new field value with original event timestamp\n+   *\n+   * @param writer\n+   * @param shardId\n+   * @param datatype\n+   * @param eventUid\n+   * @param fieldName\n+   * @param fieldValue\n+   * @param isIndexed\n+   * @param isReverseIndexed\n+   * @param dataTypes\n+   * @param user\n+   * @param mode\n+   * @throws Exception\n+   */\n+  protected void insert(MultiTableBatchWriter writer, String shardId, String datatype, String eventUid,\n+                        Map<String, String> markings, ColumnVisibility viz,\n+                        String fieldName, String fieldValue, boolean isIndexOnlyField, boolean isIndexed,\n+                        boolean isReverseIndexed, Set<Type<?>> dataTypes,\n+                        String user, MODE mode, long ts, boolean insertHistory) throws Exception {\n+\n+    if (null == viz) {\n+      if (null == markings || markings.isEmpty()) {\n+        throw new IllegalArgumentException(\"No security information specified. Security markings must be supplied\");\n+      }\n+\n+      viz = markingFunctions.translateToColumnVisibility(markings);\n     }\n-    \n-    /**\n-     * Insert new field value with provided timestamp\n-     * \n-     * @param writer\n-     * @param shardId\n-     * @param datatype\n-     * @param eventUid\n-     * @param viz\n-     * @param fieldName\n-     * @param fieldValue\n-     * @param timestamp\n-     * @param isIndexed\n-     * @param isReverseIndexed\n-     * @param dataTypes\n-     * @param historicalValue\n-     * @param insertHistory\n-     * @param user\n-     * @param mode\n-     * @throws Exception\n-     */\n-    protected void insert(MultiTableBatchWriter writer, String shardId, String datatype, String eventUid, ColumnVisibility viz, String fieldName,\n-                    String fieldValue, long timestamp, boolean isIndexOnlyField, boolean isIndexed, boolean isReverseIndexed, Set<Type<?>> dataTypes,\n-                    boolean historicalValue, boolean insertHistory, String user, MODE mode) throws Exception {\n-        \n-        // increment the term frequency\n-        Mutation m = new Mutation(fieldName);\n+\n+    insert(writer, shardId, datatype, eventUid, viz, fieldName, fieldValue, ts, isIndexOnlyField, isIndexed,\n+        isReverseIndexed, dataTypes, false,\n+        insertHistory, user, mode);\n+  }\n+\n+  /**\n+   * Delete the current K,V from the event, put in a history element\n+   *\n+   * @param writer\n+   * @param currentEntryList\n+   * @param isIndexed\n+   * @param isReverseIndexed\n+   * @param isContentField\n+   * @param dataTypes\n+   * @param user\n+   * @param mode\n+   * @param ts\n+   * @param purgeTokens      If set true, then this will delete all tokens for a field as well.\n+   * @param insertHistory\n+   * @throws Exception\n+   */\n+  protected void delete(MultiTableBatchWriter writer, AccumuloClient client, Set<Authorizations> userAuths,\n+                        List<Pair<Key, Value>> currentEntryList,\n+                        boolean isIndexOnlyField, boolean isIndexed, boolean isReverseIndexed, boolean isContentField,\n+                        Set<Type<?>> dataTypes, String user,\n+                        MODE mode, long ts, boolean purgeTokens, boolean insertHistory) throws Exception {\n+\n+    for (Pair<Key, Value> currentEntry : currentEntryList) {\n+\n+      ColumnVisibility viz = currentEntry.getFirst().getColumnVisibilityParsed();\n+\n+      DatawaveKey key = new DatawaveKey(currentEntry.getFirst());\n+\n+      String shardId = key.getRow().toString();\n+\n+      long currentEntryTimestamp = currentEntry.getFirst().getTimestamp();\n+\n+      if (key.getType().equals(KeyType.INDEX_EVENT)) {\n+        // Only the delete the fi key\n+        Mutation e = new Mutation(currentEntry.getFirst().getRow());\n+        e.putDelete(currentEntry.getFirst().getColumnFamily(), currentEntry.getFirst().getColumnQualifier(), viz,\n+            currentEntryTimestamp);\n+        writer.getBatchWriter(this.getEventTableName()).addMutation(e);\n+      } else if (key.getType().equals(KeyType.EVENT)) {\n+        Mutation m = new Mutation(key.getFieldName());\n+\n+        // Decrement the frequency (metadata table)\n+        m.put(ColumnFamilyConstants.COLF_F,\n+            new Text(key.getDataType() + NULL_BYTE + DateHelper.format(currentEntryTimestamp)), new Value(\n+                SummingCombiner.VAR_LEN_ENCODER.encode(-1L)));\n+\n+        // Remove the event field.\n+        Mutation e = new Mutation(currentEntry.getFirst().getRow());\n         if (!isIndexOnlyField) {\n-            m.put(ColumnFamilyConstants.COLF_E, new Text(datatype), NULL_VALUE);\n-            m.put(ColumnFamilyConstants.COLF_F, new Text(datatype + NULL_BYTE + DateHelper.format(timestamp)),\n-                            new Value(SummingCombiner.VAR_LEN_ENCODER.encode(1L)));\n+          e.putDelete(currentEntry.getFirst().getColumnFamily(), currentEntry.getFirst().getColumnQualifier(), viz,\n+              currentEntryTimestamp);\n         }\n-        \n-        // Insert the new field.\n-        Mutation e = new Mutation(shardId);\n-        if (!isIndexOnlyField) {\n-            e.put(new Text(datatype + NULL_BYTE + eventUid), new Text(fieldName + NULL_BYTE + fieldValue), viz, timestamp, NULL_VALUE);\n+\n+        // Remove the content column\n+        if (isContentField) {\n+          ContentIterable dKeys =\n+              getContentKeys(client, this.getEventTableName(), userAuths, shardId, key.getDataType(), key.getUid());\n+          try {\n+            for (Key dKey : dKeys) {\n+              e.putDelete(dKey.getColumnFamily(), dKey.getColumnQualifier(), dKey.getColumnVisibilityParsed(),\n+                  dKey.getTimestamp());\n+            }\n+          } finally {\n+            dKeys.close();\n+          }\n         }\n-        \n-        if (isIndexed) {\n-            \n-            long tsToDay = (timestamp / MS_PER_DAY) * MS_PER_DAY;\n-            \n-            // Create a UID object for the Value\n+\n+        long tsToDay = (ts / MS_PER_DAY) * MS_PER_DAY;\n+\n+        FieldIndexIterable fiKeys =\n+            getFieldIndexKeys(client, this.getEventTableName(), userAuths, shardId, key.getDataType(), key.getUid(),\n+                key.getFieldName(), key.getFieldValue(), dataTypes, purgeTokens);\n+        try {\n+          for (Key fiKey : fiKeys) {\n+            // Remove the field index entry\n+            e.putDelete(fiKey.getColumnFamily(), fiKey.getColumnQualifier(), fiKey.getColumnVisibilityParsed(),\n+                fiKey.getTimestamp());\n+\n+            DatawaveKey fiKeyParsed = new DatawaveKey(fiKey);\n+\n+            // Remove the term frequency entry\n+            e.putDelete(ColumnFamilyConstants.COLF_TF.toString(),\n+                fiKeyParsed.getDataType() + NULL_BYTE + fiKeyParsed.getUid() + NULL_BYTE\n+                    + fiKeyParsed.getFieldValue() + NULL_BYTE + fiKeyParsed.getFieldName(),\n+                fiKey.getColumnVisibilityParsed(),\n+                fiKey.getTimestamp());\n+\n+            // Create a UID object for the Value which will remove this UID\n             Builder uidBuilder = Uid.List.newBuilder();\n             uidBuilder.setIGNORE(false);\n-            uidBuilder.setCOUNT(1);\n-            uidBuilder.addUID(eventUid);\n+            uidBuilder.setCOUNT(-1);\n+            uidBuilder.addUID(fiKeyParsed.getUid());\n             Uid.List uidList = uidBuilder.build();\n             Value val = new Value(uidList.toByteArray());\n-            \n-            for (Type<?> n : dataTypes) {\n-                String indexTerm = fieldValue;\n-                if (historicalValue) {\n-                    int lastColon = fieldValue.lastIndexOf(\":\");\n-                    // The next two lines build up to the beginning of the indexTerm by finding the first two colons\n-                    // We could use split if we could guarantee a colon never appears in the index term itself\n-                    int indexTermLeadingColon = fieldValue.indexOf(\":\", 0);\n-                    indexTermLeadingColon = fieldValue.indexOf(\":\", indexTermLeadingColon + 1);\n-                    indexTerm = fieldValue.substring(indexTermLeadingColon + 1, lastColon);\n-                }\n-                String indexedValue = n.normalize(indexTerm);\n-                \n-                // Insert the global index entry\n-                Mutation i = new Mutation(indexedValue);\n-                i.put(fieldName, shardId + NULL_BYTE + datatype, viz, tsToDay, val);\n-                writer.getBatchWriter(this.getIndexTableName()).addMutation(i);\n-                m.put(ColumnFamilyConstants.COLF_I, new Text(datatype + NULL_BYTE + n.getClass().getName()), NULL_VALUE);\n-                \n-                if (isReverseIndexed) {\n-                    String reverseIndexedValue = StringUtils.reverse(indexedValue);\n-                    // Insert the global reverse index entry\n-                    Mutation rm = new Mutation(reverseIndexedValue);\n-                    rm.put(fieldName, shardId + NULL_BYTE + datatype, viz, tsToDay, val);\n-                    writer.getBatchWriter(this.getReverseIndexTableName()).addMutation(rm);\n-                    m.put(ColumnFamilyConstants.COLF_RI, new Text(datatype + NULL_BYTE + n.getClass().getName()), NULL_VALUE);\n-                }\n-                // Insert the field index entry\n-                e.put(new Text(FIELD_INDEX_PREFIX + fieldName), new Text(indexedValue + NULL_BYTE + datatype + NULL_BYTE + eventUid), viz, timestamp,\n-                                NULL_VALUE);\n+\n+            // buffer the global indexes cq\n+            String cq = shardId + NULL_BYTE + fiKeyParsed.getDataType();\n+\n+            // Remove the global index entry by adding the value\n+            Mutation i = new Mutation(fiKeyParsed.getFieldValue());\n+            i.put(fiKeyParsed.getFieldName(), cq, fiKey.getColumnVisibilityParsed(), tsToDay, val);\n+            writer.getBatchWriter(this.getIndexTableName()).addMutation(i);\n+\n+            // Remove the reverse global index entry\n+            if (isReverseIndexed) {\n+              String reverseIndexedValue = StringUtils.reverse(fiKeyParsed.getFieldValue());\n+              Mutation ri = new Mutation(reverseIndexedValue);\n+              ri.put(fiKeyParsed.getFieldName(), cq, viz, tsToDay, val);\n+              writer.getBatchWriter(this.getReverseIndexTableName()).addMutation(ri);\n             }\n+          }\n+        } finally {\n+          fiKeys.close();\n         }\n-        writer.getBatchWriter(this.getEventTableName()).addMutation(e);\n+\n+        if (e.size() > 0) {\n+          writer.getBatchWriter(this.getEventTableName()).addMutation(e);\n+        }\n+\n         writer.getBatchWriter(this.getMetadataTableName()).addMutation(m);\n-        writer.flush();\n-        \n+\n         if (!isIndexOnlyField && insertHistory) {\n-            insertHistory(writer, shardId, datatype, eventUid, viz, fieldName, fieldValue, timestamp, isIndexOnlyField, isIndexed, isReverseIndexed, dataTypes,\n-                            user, mode);\n+          insertHistory(writer, shardId, key.getDataType(), key.getUid(), viz, key.getFieldName(), key.getFieldValue(),\n+              ts, isIndexOnlyField,\n+              isIndexed, isReverseIndexed, dataTypes, user, mode);\n         }\n+      }\n     }\n-    \n-    /**\n-     * Prepares the value to be inserted as history, then calls insert\n-     * \n-     * @param writer\n-     * @param shardId\n-     * @param datatype\n-     * @param eventUid\n-     * @param viz\n-     * @param fieldName\n-     * @param fieldValue\n-     * @param timestamp\n-     * @param isIndexOnlyField\n-     * @param isIndexed\n-     * @param isReverseIndexed\n-     * @param dataTypes\n-     * @param user\n-     * @param mode\n-     * @throws Exception\n-     */\n-    protected void insertHistory(MultiTableBatchWriter writer, String shardId, String datatype, String eventUid, ColumnVisibility viz, String fieldName,\n-                    String fieldValue, long timestamp, boolean isIndexOnlyField, boolean isIndexed, boolean isReverseIndexed, Set<Type<?>> dataTypes,\n-                    String user, MODE mode) throws Exception {\n-        // Capture the fact of the insert in a history element\n-        // History element has the following structure\n-        // FIELD NAME: HISTORY_<ORIGINAL FIELD NAME>\n-        // for Deletes - FIELD VALUE: <timestamp of original field value> : <user that modified/deleted it> : < original field value> : <operation type>\n-        // for Inserts - FIELD VALUE: <timestamp of operation> : <user that modified it> : < original field value> : <operation type>\n-        // Timestamp of history element is now.\n-        String historyFieldName = HISTORY_PREFIX + fieldName;\n-        String historyFieldValue;\n-        if (mode.equals(MODE.INSERT)) {\n-            historyFieldValue = System.currentTimeMillis() + \":\" + user + \":\" + fieldValue;\n-            historyFieldValue += \":insert\";\n-        } else if (mode.equals(MODE.DELETE)) {\n-            historyFieldValue = System.currentTimeMillis() + \":\" + user + \":\" + fieldValue;\n-            historyFieldValue += \":delete\";\n-        } else { // update\n-            historyFieldValue = System.currentTimeMillis() + \":\" + user + \":\" + fieldValue;\n-            historyFieldValue += \":update\";\n-        }\n-        \n-        insert(writer, shardId, datatype, eventUid, viz, historyFieldName, historyFieldValue, timestamp, isIndexOnlyField, isIndexed, isReverseIndexed,\n-                        dataTypes, true, false, user, mode);\n+    writer.flush();\n+  }\n+\n+  /**\n+   * Get the Key,Value pair for the field to be updated/deleted from the event table\n+   *\n+   * @param client\n+   * @param userAuths\n+   * @param shardId\n+   * @param datatype\n+   * @param eventUid\n+   * @param fieldName\n+   * @param oldFieldValue\n+   * @param oldFieldMarkings\n+   * @param oldColumnVisibility\n+   * @return\n+   * @throws Exception\n+   */\n+  protected List<Pair<Key, Value>> getField(AccumuloClient client, Set<Authorizations> userAuths, String shardId,\n+                                            String datatype, String eventUid,\n+                                            String fieldName, String oldFieldValue,\n+                                            Map<String, String> oldFieldMarkings, ColumnVisibility oldColumnVisibility)\n+      throws Exception {\n+\n+    Text family = new Text(datatype);\n+    TextUtil.textAppend(family, eventUid);\n+\n+    Text qualifier = null;\n+\n+    if (oldFieldValue != null) {\n+      qualifier = new Text(fieldName);\n+      TextUtil.textAppend(qualifier, oldFieldValue);\n     }\n-    \n-    /**\n-     * Insert new field value with original event timestamp\n-     * \n-     * @param writer\n-     * @param shardId\n-     * @param datatype\n-     * @param eventUid\n-     * @param fieldName\n-     * @param fieldValue\n-     * @param isIndexed\n-     * @param isReverseIndexed\n-     * @param dataTypes\n-     * @param user\n-     * @param mode\n-     * @throws Exception\n-     */\n-    protected void insert(MultiTableBatchWriter writer, String shardId, String datatype, String eventUid, Map<String,String> markings, ColumnVisibility viz,\n-                    String fieldName, String fieldValue, boolean isIndexOnlyField, boolean isIndexed, boolean isReverseIndexed, Set<Type<?>> dataTypes,\n-                    String user, MODE mode, long ts, boolean insertHistory) throws Exception {\n-        \n-        if (null == viz) {\n-            if (null == markings || markings.isEmpty())\n-                throw new IllegalArgumentException(\"No security information specified. Security markings must be supplied\");\n-            \n-            viz = markingFunctions.translateToColumnVisibility(markings);\n+\n+    List<Pair<Key, Value>> results = new ArrayList<>();\n+\n+    Scanner s = ScannerHelper.createScanner(client, this.getEventTableName(), userAuths);\n+    try {\n+      s.setRange(new Range(shardId));\n+      if (qualifier == null) {\n+        s.fetchColumnFamily(family);\n+      } else {\n+        s.fetchColumn(family, qualifier);\n+      }\n+\n+      for (Entry<Key, Value> e : s) {\n+        ColumnVisibility thisViz = new ColumnVisibility(e.getKey().getColumnVisibility());\n+\n+        if (!e.getKey().getColumnQualifier().toString().startsWith(fieldName)) {\n+          continue;\n         }\n-        \n-        insert(writer, shardId, datatype, eventUid, viz, fieldName, fieldValue, ts, isIndexOnlyField, isIndexed, isReverseIndexed, dataTypes, false,\n-                        insertHistory, user, mode);\n-    }\n-    \n-    /**\n-     * Delete the current K,V from the event, put in a history element\n-     *\n-     * @param writer\n-     * @param currentEntryList\n-     * @param isIndexed\n-     * @param isReverseIndexed\n-     * @param isContentField\n-     * @param dataTypes\n-     * @param user\n-     * @param mode\n-     * @param ts\n-     * @param purgeTokens\n-     *            If set true, then this will delete all tokens for a field as well.\n-     * @param insertHistory\n-     * @throws Exception\n-     */\n-    protected void delete(MultiTableBatchWriter writer, AccumuloClient client, Set<Authorizations> userAuths, List<Pair<Key,Value>> currentEntryList,\n-                    boolean isIndexOnlyField, boolean isIndexed, boolean isReverseIndexed, boolean isContentField, Set<Type<?>> dataTypes, String user,\n-                    MODE mode, long ts, boolean purgeTokens, boolean insertHistory) throws Exception {\n-        \n-        for (Pair<Key,Value> currentEntry : currentEntryList) {\n-            \n-            ColumnVisibility viz = currentEntry.getFirst().getColumnVisibilityParsed();\n-            \n-            DatawaveKey key = new DatawaveKey(currentEntry.getFirst());\n-            \n-            String shardId = key.getRow().toString();\n-            \n-            long currentEntryTimestamp = currentEntry.getFirst().getTimestamp();\n-            \n-            if (key.getType().equals(KeyType.INDEX_EVENT)) {\n-                // Only the delete the fi key\n-                Mutation e = new Mutation(currentEntry.getFirst().getRow());\n-                e.putDelete(currentEntry.getFirst().getColumnFamily(), currentEntry.getFirst().getColumnQualifier(), viz, currentEntryTimestamp);\n-                writer.getBatchWriter(this.getEventTableName()).addMutation(e);\n-            } else if (key.getType().equals(KeyType.EVENT)) {\n-                Mutation m = new Mutation(key.getFieldName());\n-                \n-                // Decrement the frequency (metadata table)\n-                m.put(ColumnFamilyConstants.COLF_F, new Text(key.getDataType() + NULL_BYTE + DateHelper.format(currentEntryTimestamp)), new Value(\n-                                SummingCombiner.VAR_LEN_ENCODER.encode(-1L)));\n-                \n-                // Remove the event field.\n-                Mutation e = new Mutation(currentEntry.getFirst().getRow());\n-                if (!isIndexOnlyField) {\n-                    e.putDelete(currentEntry.getFirst().getColumnFamily(), currentEntry.getFirst().getColumnQualifier(), viz, currentEntryTimestamp);\n-                }\n-                \n-                // Remove the content column\n-                if (isContentField) {\n-                    ContentIterable dKeys = getContentKeys(client, this.getEventTableName(), userAuths, shardId, key.getDataType(), key.getUid());\n-                    try {\n-                        for (Key dKey : dKeys) {\n-                            e.putDelete(dKey.getColumnFamily(), dKey.getColumnQualifier(), dKey.getColumnVisibilityParsed(), dKey.getTimestamp());\n-                        }\n-                    } finally {\n-                        dKeys.close();\n-                    }\n-                }\n-                \n-                long tsToDay = (ts / MS_PER_DAY) * MS_PER_DAY;\n-                \n-                FieldIndexIterable fiKeys = getFieldIndexKeys(client, this.getEventTableName(), userAuths, shardId, key.getDataType(), key.getUid(),\n-                                key.getFieldName(), key.getFieldValue(), dataTypes, purgeTokens);\n-                try {\n-                    for (Key fiKey : fiKeys) {\n-                        // Remove the field index entry\n-                        e.putDelete(fiKey.getColumnFamily(), fiKey.getColumnQualifier(), fiKey.getColumnVisibilityParsed(), fiKey.getTimestamp());\n-                        \n-                        DatawaveKey fiKeyParsed = new DatawaveKey(fiKey);\n-                        \n-                        // Remove the term frequency entry\n-                        e.putDelete(ColumnFamilyConstants.COLF_TF.toString(), fiKeyParsed.getDataType() + NULL_BYTE + fiKeyParsed.getUid() + NULL_BYTE\n-                                        + fiKeyParsed.getFieldValue() + NULL_BYTE + fiKeyParsed.getFieldName(), fiKey.getColumnVisibilityParsed(),\n-                                        fiKey.getTimestamp());\n-                        \n-                        // Create a UID object for the Value which will remove this UID\n-                        Builder uidBuilder = Uid.List.newBuilder();\n-                        uidBuilder.setIGNORE(false);\n-                        uidBuilder.setCOUNT(-1);\n-                        uidBuilder.addUID(fiKeyParsed.getUid());\n-                        Uid.List uidList = uidBuilder.build();\n-                        Value val = new Value(uidList.toByteArray());\n-                        \n-                        // buffer the global indexes cq\n-                        String cq = shardId + NULL_BYTE + fiKeyParsed.getDataType();\n-                        \n-                        // Remove the global index entry by adding the value\n-                        Mutation i = new Mutation(fiKeyParsed.getFieldValue());\n-                        i.put(fiKeyParsed.getFieldName(), cq, fiKey.getColumnVisibilityParsed(), tsToDay, val);\n-                        writer.getBatchWriter(this.getIndexTableName()).addMutation(i);\n-                        \n-                        // Remove the reverse global index entry\n-                        if (isReverseIndexed) {\n-                            String reverseIndexedValue = StringUtils.reverse(fiKeyParsed.getFieldValue());\n-                            Mutation ri = new Mutation(reverseIndexedValue);\n-                            ri.put(fiKeyParsed.getFieldName(), cq, viz, tsToDay, val);\n-                            writer.getBatchWriter(this.getReverseIndexTableName()).addMutation(ri);\n-                        }\n-                    }\n-                } finally {\n-                    fiKeys.close();\n-                }\n-                \n-                if (e.size() > 0) {\n-                    writer.getBatchWriter(this.getEventTableName()).addMutation(e);\n-                }\n-                \n-                writer.getBatchWriter(this.getMetadataTableName()).addMutation(m);\n-                \n-                if (!isIndexOnlyField && insertHistory) {\n-                    insertHistory(writer, shardId, key.getDataType(), key.getUid(), viz, key.getFieldName(), key.getFieldValue(), ts, isIndexOnlyField,\n-                                    isIndexed, isReverseIndexed, dataTypes, user, mode);\n-                }\n-            }\n+\n+        if (null != oldColumnVisibility) {\n+          // need to compare the flattened values for equivalence. It's possible for the visibility to be in a different order\n+          String oldColViz = new String(oldColumnVisibility.flatten(), \"UTF-8\");\n+          String thisVis = new String(thisViz.flatten(), \"UTF-8\");\n+          if (!oldColViz.equals(thisVis)) {\n+            log.trace(\"Skipping key that does not match with column visibility: \" + e.getKey());\n+            continue;\n+          }\n+        } else {\n+          Map<String, String> markings =\n+              markingFunctions.translateFromColumnVisibilityForAuths(e.getKey().getColumnVisibilityParsed(), userAuths);\n+          if (null != oldFieldMarkings && !oldFieldMarkings.equals(markings)) {\n+            log.trace(\"Skipping key that does not match with markings: \" + e.getKey());\n+            continue;\n+          }\n         }\n-        writer.flush();\n+        results.add(new Pair<>(e.getKey(), e.getValue()));\n+      }\n+    } finally {\n+      s.close();\n     }\n-    \n-    /**\n-     * Get the Key,Value pair for the field to be updated/deleted from the event table\n-     * \n-     * @param client\n-     * @param userAuths\n-     * @param shardId\n-     * @param datatype\n-     * @param eventUid\n-     * @param fieldName\n-     * @param oldFieldValue\n-     * @param oldFieldMarkings\n-     * @param oldColumnVisibility\n-     * @return\n-     * @throws Exception\n-     */\n-    protected List<Pair<Key,Value>> getField(AccumuloClient client, Set<Authorizations> userAuths, String shardId, String datatype, String eventUid,\n-                    String fieldName, String oldFieldValue, Map<String,String> oldFieldMarkings, ColumnVisibility oldColumnVisibility) throws Exception {\n-        \n-        Text family = new Text(datatype);\n-        TextUtil.textAppend(family, eventUid);\n-        \n-        Text qualifier = null;\n-        \n-        if (oldFieldValue != null) {\n-            qualifier = new Text(fieldName);\n-            TextUtil.textAppend(qualifier, oldFieldValue);\n+    return results;\n+  }\n+\n+  /**\n+   * Pulls the entire event and returns the most common timestamp for the event. This *assumes* the most common timestamp is the original one. If this is not\n+   * the case, then it needs to change. Another option could be to return the earliest timestamp, which is also an assumption.\n+   *\n+   * @param client\n+   * @param userAuths\n+   * @param shardId\n+   * @param datatype\n+   * @param eventUid\n+   * @return long - highestOccurrenceTimestamp - most common timestamp in the event\n+   * @throws Exception\n+   */\n+  protected long getOriginalEventTimestamp(AccumuloClient client, Set<Authorizations> userAuths, String shardId,\n+                                           String datatype, String eventUid)\n+      throws Exception {\n+\n+    Text family = new Text(datatype);\n+    TextUtil.textAppend(family, eventUid);\n+\n+    HashMap<Long, Integer> timestampCounts = new HashMap<>();\n+\n+    long highestOccurrenceTimestamp = 0;\n+    int highestOccurrences = -1;\n+\n+    // Pull the entire event\n+    Scanner s = ScannerHelper.createScanner(client, this.getEventTableName(), userAuths);\n+    try {\n+      s.setRange(new Range(shardId));\n+      s.fetchColumnFamily(family);\n+\n+      // Populate map with how often each timestamp occurs\n+      for (Entry<Key, Value> e : s) {\n+        long ts = e.getKey().getTimestamp();\n+        if (!timestampCounts.containsKey(ts)) {\n+          timestampCounts.put(ts, 1);\n+        } else {\n+          timestampCounts.put(ts, timestampCounts.get(ts) + 1);\n         }\n-        \n-        List<Pair<Key,Value>> results = new ArrayList<>();\n-        \n-        Scanner s = ScannerHelper.createScanner(client, this.getEventTableName(), userAuths);\n-        try {\n-            s.setRange(new Range(shardId));\n-            if (qualifier == null) {\n-                s.fetchColumnFamily(family);\n-            } else {\n-                s.fetchColumn(family, qualifier);\n-            }\n-            \n-            for (Entry<Key,Value> e : s) {\n-                ColumnVisibility thisViz = new ColumnVisibility(e.getKey().getColumnVisibility());\n-                \n-                if (!e.getKey().getColumnQualifier().toString().startsWith(fieldName)) {\n-                    continue;\n-                }\n-                \n-                if (null != oldColumnVisibility) {\n-                    // need to compare the flattened values for equivalence. It's possible for the visibility to be in a different order\n-                    String oldColViz = new String(oldColumnVisibility.flatten(), \"UTF-8\");\n-                    String thisVis = new String(thisViz.flatten(), \"UTF-8\");\n-                    if (!oldColViz.equals(thisVis)) {\n-                        log.trace(\"Skipping key that does not match with column visibility: \" + e.getKey());\n-                        continue;\n-                    }\n-                } else {\n-                    Map<String,String> markings = markingFunctions.translateFromColumnVisibilityForAuths(e.getKey().getColumnVisibilityParsed(), userAuths);\n-                    if (null != oldFieldMarkings && !oldFieldMarkings.equals(markings)) {\n-                        log.trace(\"Skipping key that does not match with markings: \" + e.getKey());\n-                        continue;\n-                    }\n-                }\n-                results.add(new Pair<>(e.getKey(), e.getValue()));\n-            }\n-        } finally {\n-            s.close();\n+      }\n+\n+      // Determine the most common timestamp\n+      if (timestampCounts.isEmpty()) {\n+        // if no fields exist, then use the shard date at 00:00:00\n+        highestOccurrenceTimestamp = DateHelper.parse(shardId.substring(0, 8)).getTime();\n+      } else {\n+        for (Entry<Long, Integer> entry : timestampCounts.entrySet()) {\n+          Long ts = entry.getKey();\n+          int occurrences = entry.getValue();\n+          if (occurrences > highestOccurrences) {\n+            highestOccurrences = occurrences;\n+            highestOccurrenceTimestamp = ts;\n+          }\n         }\n-        return results;\n+      }\n+    } finally {\n+      s.close();\n     }\n-    \n-    /**\n-     * Pulls the entire event and returns the most common timestamp for the event. This *assumes* the most common timestamp is the original one. If this is not\n-     * the case, then it needs to change. Another option could be to return the earliest timestamp, which is also an assumption.\n-     * \n-     * @param client\n-     * @param userAuths\n-     * @param shardId\n-     * @param datatype\n-     * @param eventUid\n-     * @return long - highestOccurrenceTimestamp - most common timestamp in the event\n-     * @throws Exception\n-     */\n-    protected long getOriginalEventTimestamp(AccumuloClient client, Set<Authorizations> userAuths, String shardId, String datatype, String eventUid)\n-                    throws Exception {\n-        \n-        Text family = new Text(datatype);\n-        TextUtil.textAppend(family, eventUid);\n-        \n-        HashMap<Long,Integer> timestampCounts = new HashMap<>();\n-        \n-        long highestOccurrenceTimestamp = 0;\n-        int highestOccurrences = -1;\n-        \n-        // Pull the entire event\n-        Scanner s = ScannerHelper.createScanner(client, this.getEventTableName(), userAuths);\n-        try {\n-            s.setRange(new Range(shardId));\n-            s.fetchColumnFamily(family);\n-            \n-            // Populate map with how often each timestamp occurs\n-            for (Entry<Key,Value> e : s) {\n-                long ts = e.getKey().getTimestamp();\n-                if (!timestampCounts.containsKey(ts)) {\n-                    timestampCounts.put(ts, 1);\n-                } else {\n-                    timestampCounts.put(ts, timestampCounts.get(ts) + 1);\n-                }\n-            }\n-            \n-            // Determine the most common timestamp\n-            if (timestampCounts.isEmpty()) {\n-                // if no fields exist, then use the shard date at 00:00:00\n-                highestOccurrenceTimestamp = DateHelper.parse(shardId.substring(0, 8)).getTime();\n-            } else {\n-                for (Entry<Long,Integer> entry : timestampCounts.entrySet()) {\n-                    Long ts = entry.getKey();\n-                    int occurrences = entry.getValue();\n-                    if (occurrences > highestOccurrences) {\n-                        highestOccurrences = occurrences;\n-                        highestOccurrenceTimestamp = ts;\n-                    }\n-                }\n-            }\n-        } finally {\n-            s.close();\n-        }\n-        \n-        return highestOccurrenceTimestamp;\n+\n+    return highestOccurrenceTimestamp;\n+  }\n+\n+  /**\n+   * Get an instance of a MetadataHelper object\n+   *\n+   * @param client\n+   * @return\n+   * @throws AccumuloException\n+   * @throws AccumuloSecurityException\n+   * @throws ExecutionException\n+   * @throws TableNotFoundException\n+   */\n+  protected MetadataHelper getMetadataHelper(AccumuloClient client)\n+      throws AccumuloException, AccumuloSecurityException, TableNotFoundException,\n+      ExecutionException {\n+    Authorizations auths = client.securityOperations().getUserAuthorizations(client.whoami());\n+    return metadataHelperFactory\n+        .createMetadataHelper(client, this.getMetadataTableName(), Collections.singleton(auths));\n+  }\n+\n+  /**\n+   * Check to see if a field is mutable\n+   *\n+   * @param mutableFieldList\n+   * @param datatype\n+   * @param fieldName\n+   * @return\n+   */\n+  protected boolean isFieldMutable(Map<String, Set<String>> mutableFieldList, String datatype, String fieldName) {\n+    if (null == mutableFieldList) {\n+      return false;\n     }\n-    \n-    /**\n-     * Get an instance of a MetadataHelper object\n-     * \n-     * @param client\n-     * @return\n-     * @throws AccumuloException\n-     * @throws AccumuloSecurityException\n-     * @throws ExecutionException\n-     * @throws TableNotFoundException\n-     */\n-    protected MetadataHelper getMetadataHelper(AccumuloClient client) throws AccumuloException, AccumuloSecurityException, TableNotFoundException,\n-                    ExecutionException {\n-        Authorizations auths = client.securityOperations().getUserAuthorizations(client.whoami());\n-        return metadataHelperFactory.createMetadataHelper(client, this.getMetadataTableName(), Collections.singleton(auths));\n+    if (null == mutableFieldList.get(datatype)) {\n+      return false;\n     }\n-    \n-    /**\n-     * Check to see if a field is mutable\n-     * \n-     * @param mutableFieldList\n-     * @param datatype\n-     * @param fieldName\n-     * @return\n-     */\n-    protected boolean isFieldMutable(Map<String,Set<String>> mutableFieldList, String datatype, String fieldName) {\n-        if (null == mutableFieldList)\n-            return false;\n-        if (null == mutableFieldList.get(datatype))\n-            return false;\n-        return mutableFieldList.get(datatype).contains(fieldName);\n+    return mutableFieldList.get(datatype).contains(fieldName);\n+  }\n+\n+  /**\n+   * @return priority of the connection for this service\n+   */\n+  @Override\n+  public AccumuloConnectionFactory.Priority getPriority() {\n+    return AccumuloConnectionFactory.Priority.NORMAL;\n+  }\n+\n+  /**\n+   * Finds the event by creating a query by UUID from the keys and values in the runtime parameters.\n+   *\n+   * @param uuid\n+   * @param uuidType\n+   * @param userAuths\n+   * @return Event\n+   * @throws Exception\n+   */\n+  protected EventBase<?, ?> findMatchingEventUuid(String uuid, String uuidType, Set<Authorizations> userAuths,\n+                                                  ModificationOperation operation)\n+      throws Exception {\n+\n+    String field = operation.getFieldName();\n+    String columnVisibility = operation.getColumnVisibility();\n+\n+    // query in format uuidType:uuid\n+    StringBuilder query = new StringBuilder();\n+    query.append(uuidType.toUpperCase()).append(\":\\\"\").append(uuid).append(\"\\\"\");\n+    // make the query only return the field to be modified and the UUIDType (avoids NoResultsException on an insert where the field has no values)\n+    StringBuilder queryOptions = new StringBuilder();\n+    queryOptions.append(\"query.syntax:LUCENE-UUID;raw.data.only:true\");\n+    if (field != null) {\n+      queryOptions.append(\";return.fields:\").append(field.toUpperCase()).append(\",\").append(uuidType.toUpperCase());\n     }\n-    \n-    /**\n-     * @return priority of the connection for this service\n-     */\n-    @Override\n-    public AccumuloConnectionFactory.Priority getPriority() {\n-        return AccumuloConnectionFactory.Priority.NORMAL;\n+\n+    String logicName = \"LuceneUUIDEventQuery\";\n+\n+    DefaultEvent e = null;\n+    QueryExecutorBean queryService = this.getQueryService();\n+\n+    String id = null;\n+    HashSet<String> auths = new HashSet<>();\n+    for (Authorizations a : userAuths) {\n+      auths.addAll(Arrays.asList(a.toString().split(\",\")));\n     }\n-    \n-    /**\n-     * Finds the event by creating a query by UUID from the keys and values in the runtime parameters.\n-     * \n-     * @param uuid\n-     * @param uuidType\n-     * @param userAuths\n-     * @return Event\n-     * @throws Exception\n-     */\n-    protected EventBase<?,?> findMatchingEventUuid(String uuid, String uuidType, Set<Authorizations> userAuths, ModificationOperation operation)\n-                    throws Exception {\n-        \n-        String field = operation.getFieldName();\n-        String columnVisibility = operation.getColumnVisibility();\n-        \n-        // query in format uuidType:uuid\n-        StringBuilder query = new StringBuilder();\n-        query.append(uuidType.toUpperCase()).append(\":\\\"\").append(uuid).append(\"\\\"\");\n-        // make the query only return the field to be modified and the UUIDType (avoids NoResultsException on an insert where the field has no values)\n-        StringBuilder queryOptions = new StringBuilder();\n-        queryOptions.append(\"query.syntax:LUCENE-UUID;raw.data.only:true\");\n-        if (field != null) {\n-            queryOptions.append(\";return.fields:\").append(field.toUpperCase()).append(\",\").append(uuidType.toUpperCase());\n+\n+    Date expiration = new Date();\n+    expiration = new Date(expiration.getTime() + (1000 * 60 * 60 * 24));\n+\n+    try {\n+      GenericResponse<String> createResponse =\n+          queryService.createQuery(logicName, QueryParametersImpl.paramsToMap(logicName, query.toString(),\n+              \"Query to find matching records for metadata modification\", columnVisibility, new Date(0), new Date(),\n+              StringUtils.join(auths, ','), expiration, 2, -1, null, QueryPersistence.TRANSIENT,\n+              queryOptions.toString(), false));\n+\n+      id = createResponse.getResult();\n+      BaseQueryResponse response = queryService.next(id);\n+      if (response instanceof DefaultEventQueryResponse) {\n+        DefaultEventQueryResponse eResponse = (DefaultEventQueryResponse) response;\n+        if (eResponse.getEvents().size() > 1) {\n+          throw new IllegalStateException(\n+              \"More than one event matched \" + uuid + \" (\" + eResponse.getEvents().size() + \" matched)\");\n         }\n-        \n-        String logicName = \"LuceneUUIDEventQuery\";\n-        \n-        DefaultEvent e = null;\n-        QueryExecutorBean queryService = this.getQueryService();\n-        \n-        String id = null;\n-        HashSet<String> auths = new HashSet<>();\n-        for (Authorizations a : userAuths)\n-            auths.addAll(Arrays.asList(a.toString().split(\",\")));\n-        \n-        Date expiration = new Date();\n-        expiration = new Date(expiration.getTime() + (1000 * 60 * 60 * 24));\n-        \n-        try {\n-            GenericResponse<String> createResponse = queryService.createQuery(logicName, QueryParametersImpl.paramsToMap(logicName, query.toString(),\n-                            \"Query to find matching records for metadata modification\", columnVisibility, new Date(0), new Date(),\n-                            StringUtils.join(auths, ','), expiration, 2, -1, null, QueryPersistence.TRANSIENT, queryOptions.toString(), false));\n-            \n-            id = createResponse.getResult();\n-            BaseQueryResponse response = queryService.next(id);\n-            if (response instanceof DefaultEventQueryResponse) {\n-                DefaultEventQueryResponse eResponse = (DefaultEventQueryResponse) response;\n-                if (eResponse.getEvents().size() > 1) {\n-                    throw new IllegalStateException(\"More than one event matched \" + uuid + \" (\" + eResponse.getEvents().size() + \" matched)\");\n-                }\n-                if (eResponse.getEvents().isEmpty()) {\n-                    throw new IllegalStateException(\"No event matched \" + uuid);\n-                }\n-                \n-                e = (DefaultEvent) eResponse.getEvents().get(0);\n-            }\n-        } catch (Exception ex) {\n-            log.error(ex);\n-        } finally {\n-            if (id != null) {\n-                queryService.close(id);\n-            }\n+        if (eResponse.getEvents().isEmpty()) {\n+          throw new IllegalStateException(\"No event matched \" + uuid);\n         }\n-        \n-        return e;\n-        \n+\n+        e = (DefaultEvent) eResponse.getEvents().get(0);\n+      }\n+    } catch (Exception ex) {\n+      log.error(ex);\n+    } finally {\n+      if (id != null) {\n+        queryService.close(id);\n+      }\n     }\n-    \n-    /**\n-     * Find the field index keys associated with a specified field and a specified event. Note that this will return all keys for that field and configured\n-     * token fields if includeTokens is true.\n-     *\n-     * @param client\n-     * @param shardTable\n-     * @param userAuths\n-     * @param shardId\n-     * @param datatype\n-     * @param eventUid\n-     * @param fieldName\n-     * @param fieldValue\n-     * @param dataTypes\n-     * @param includeTokens\n-     *            If true then this will return all associated token fields as well\n-     * @return An iterable of Keys\n-     * @throws Exception\n-     */\n-    protected FieldIndexIterable getFieldIndexKeys(AccumuloClient client, String shardTable, Set<Authorizations> userAuths, String shardId, String datatype,\n-                    String eventUid, String fieldName, String fieldValue, Set<Type<?>> dataTypes, boolean includeTokens) throws Exception {\n-        \n-        List<Range> ranges = new ArrayList();\n-        fieldName = stripGrouping(fieldName);\n-        if (includeTokens) {\n-            // if we are including everything, then include the mapped tokenized fields as well.\n-            List<String> fields = new ArrayList();\n-            fields.add(fieldName);\n-            if (this.indexOnlyMap != null) {\n-                fields.addAll(this.indexOnlyMap.get(fieldName));\n-            }\n-            if (this.indexOnlySuffixes != null) {\n-                for (String suffix : indexOnlySuffixes) {\n-                    fields.add(fieldName + suffix);\n-                }\n-            }\n-            for (String field : fields) {\n-                Key startKey = new Key(shardId, \"fi\" + NULL_BYTE + field);\n-                Key endKey = startKey.followingKey(PartialKey.ROW_COLFAM);\n-                Range range = new Range(startKey, true, endKey, false);\n-                ranges.add(range);\n-            }\n-        } else {\n-            for (Type<?> n : dataTypes) {\n-                String indexedValue = n.normalize(fieldValue);\n-                Key startKey = new Key(shardId, \"fi\" + NULL_BYTE + fieldName, indexedValue + NULL_BYTE + datatype + NULL_BYTE);\n-                Key endKey = new Key(shardId, \"fi\" + NULL_BYTE + fieldName, indexedValue + NULL_BYTE + datatype + NULL_BYTE + MAX_CHAR);\n-                Range range = new Range(startKey, true, endKey, true);\n-                ranges.add(range);\n-            }\n+\n+    return e;\n+\n+  }\n+\n+  /**\n+   * Find the field index keys associated with a specified field and a specified event. Note that this will return all keys for that field and configured\n+   * token fields if includeTokens is true.\n+   *\n+   * @param client\n+   * @param shardTable\n+   * @param userAuths\n+   * @param shardId\n+   * @param datatype\n+   * @param eventUid\n+   * @param fieldName\n+   * @param fieldValue\n+   * @param dataTypes\n+   * @param includeTokens If true then this will return all associated token fields as well\n+   * @return An iterable of Keys\n+   * @throws Exception\n+   */\n+  protected FieldIndexIterable getFieldIndexKeys(AccumuloClient client, String shardTable,\n+                                                 Set<Authorizations> userAuths, String shardId, String datatype,\n+                                                 String eventUid, String fieldName, String fieldValue,\n+                                                 Set<Type<?>> dataTypes, boolean includeTokens) throws Exception {\n+\n+    List<Range> ranges = new ArrayList();\n+    fieldName = stripGrouping(fieldName);\n+    if (includeTokens) {\n+      // if we are including everything, then include the mapped tokenized fields as well.\n+      List<String> fields = new ArrayList();\n+      fields.add(fieldName);\n+      if (this.indexOnlyMap != null) {\n+        fields.addAll(this.indexOnlyMap.get(fieldName));\n+      }\n+      if (this.indexOnlySuffixes != null) {\n+        for (String suffix : indexOnlySuffixes) {\n+          fields.add(fieldName + suffix);\n         }\n-        return new FieldIndexIterable(client, shardTable, eventUid, datatype, userAuths, ranges);\n+      }\n+      for (String field : fields) {\n+        Key startKey = new Key(shardId, \"fi\" + NULL_BYTE + field);\n+        Key endKey = startKey.followingKey(PartialKey.ROW_COLFAM);\n+        Range range = new Range(startKey, true, endKey, false);\n+        ranges.add(range);\n+      }\n+    } else {\n+      for (Type<?> n : dataTypes) {\n+        String indexedValue = n.normalize(fieldValue);\n+        Key startKey = new Key(shardId, \"fi\" + NULL_BYTE + fieldName, indexedValue + NULL_BYTE + datatype + NULL_BYTE);\n+        Key endKey =\n+            new Key(shardId, \"fi\" + NULL_BYTE + fieldName, indexedValue + NULL_BYTE + datatype + NULL_BYTE + MAX_CHAR);\n+        Range range = new Range(startKey, true, endKey, true);\n+        ranges.add(range);\n+      }\n     }\n-    \n-    protected static class FieldIndexIterable implements Iterable<Key>, AutoCloseable {\n-        private BatchScanner scanner;\n-        \n-        public FieldIndexIterable(AccumuloClient client, String shardTable, String eventUid, String datatype, Set<Authorizations> userAuths, List<Range> ranges)\n-                        throws TableNotFoundException {\n-            scanner = ScannerHelper.createBatchScanner(client, shardTable, userAuths, ranges.size());\n-            scanner.setRanges(ranges);\n-            Map<String,String> options = new HashMap();\n-            options.put(FieldIndexDocumentFilter.DATA_TYPE_OPT, datatype);\n-            options.put(FieldIndexDocumentFilter.EVENT_UID_OPT, eventUid);\n-            IteratorSetting settings = new IteratorSetting(100, FieldIndexDocumentFilter.class, options);\n-            scanner.addScanIterator(settings);\n-        }\n-        \n-        @Override\n-        public Iterator<Key> iterator() {\n-            return Iterators.transform(scanner.iterator(), new Function<Entry<Key,Value>,Key>() {\n-                @Nullable\n-                @Override\n-                public Key apply(@Nullable Entry<Key,Value> keyValueEntry) {\n-                    return keyValueEntry.getKey();\n-                }\n-            });\n-        }\n-        \n+    return new FieldIndexIterable(client, shardTable, eventUid, datatype, userAuths, ranges);\n+  }\n+\n+  protected static class FieldIndexIterable implements Iterable<Key>, AutoCloseable {\n+    private BatchScanner scanner;\n+\n+    public FieldIndexIterable(AccumuloClient client, String shardTable, String eventUid, String datatype,\n+                              Set<Authorizations> userAuths, List<Range> ranges)\n+        throws TableNotFoundException {\n+      scanner = ScannerHelper.createBatchScanner(client, shardTable, userAuths, ranges.size());\n+      scanner.setRanges(ranges);\n+      Map<String, String> options = new HashMap();\n+      options.put(FieldIndexDocumentFilter.DATA_TYPE_OPT, datatype);\n+      options.put(FieldIndexDocumentFilter.EVENT_UID_OPT, eventUid);\n+      IteratorSetting settings = new IteratorSetting(100, FieldIndexDocumentFilter.class, options);\n+      scanner.addScanIterator(settings);\n+    }\n+\n+    @Override\n+    public Iterator<Key> iterator() {\n+      return Iterators.transform(scanner.iterator(), new Function<Entry<Key, Value>, Key>() {\n+        @Nullable\n         @Override\n-        public void close() throws Exception {\n-            scanner.close();\n+        public Key apply(@Nullable Entry<Key, Value> keyValueEntry) {\n+          return keyValueEntry.getKey();\n         }\n+      });\n     }\n-    \n-    private String stripGrouping(String fieldName) {\n-        int index = fieldName.indexOf('.');\n-        if (index >= 0) {\n-            return fieldName.substring(0, index);\n-        } else {\n-            return fieldName;\n-        }\n+\n+    @Override\n+    public void close() throws Exception {\n+      scanner.close();\n     }\n-    \n-    /**\n-     * Find the index only keys associated with a specified field and a specified event\n-     *\n-     * @param client\n-     * @param shardTable\n-     * @param userAuths\n-     * @param shardId\n-     * @param datatype\n-     * @param eventUid\n-     * @return An iterable of Keys\n-     * @throws Exception\n-     */\n-    protected ContentIterable getContentKeys(AccumuloClient client, String shardTable, Set<Authorizations> userAuths, String shardId, String datatype,\n-                    String eventUid) throws Exception {\n-        \n-        Key startKey = new Key(shardId, \"d\", datatype + NULL_BYTE + eventUid + NULL_BYTE);\n-        Key endKey = new Key(shardId, \"d\", datatype + NULL_BYTE + eventUid + NULL_BYTE + MAX_CHAR);\n-        Range range = new Range(startKey, true, endKey, false);\n-        return new ContentIterable(client, shardTable, eventUid, datatype, userAuths, range);\n+  }\n+\n+  private String stripGrouping(String fieldName) {\n+    int index = fieldName.indexOf('.');\n+    if (index >= 0) {\n+      return fieldName.substring(0, index);\n+    } else {\n+      return fieldName;\n     }\n-    \n-    protected static class ContentIterable implements Iterable<Key>, AutoCloseable {\n-        private Scanner scanner;\n-        \n-        public ContentIterable(AccumuloClient client, String shardTable, String eventUid, String datatype, Set<Authorizations> userAuths, Range range)\n-                        throws TableNotFoundException {\n-            scanner = ScannerHelper.createScanner(client, shardTable, userAuths);\n-            scanner.setRange(range);\n-        }\n-        \n-        @Override\n-        public Iterator<Key> iterator() {\n-            return Iterators.transform(scanner.iterator(), new Function<Entry<Key,Value>,Key>() {\n-                @Nullable\n-                @Override\n-                public Key apply(@Nullable Entry<Key,Value> keyValueEntry) {\n-                    return keyValueEntry.getKey();\n-                }\n-            });\n-        }\n-        \n+  }\n+\n+  /**\n+   * Find the index only keys associated with a specified field and a specified event\n+   *\n+   * @param client\n+   * @param shardTable\n+   * @param userAuths\n+   * @param shardId\n+   * @param datatype\n+   * @param eventUid\n+   * @return An iterable of Keys\n+   * @throws Exception\n+   */\n+  protected ContentIterable getContentKeys(AccumuloClient client, String shardTable, Set<Authorizations> userAuths,\n+                                           String shardId, String datatype,\n+                                           String eventUid) throws Exception {\n+\n+    Key startKey = new Key(shardId, \"d\", datatype + NULL_BYTE + eventUid + NULL_BYTE);\n+    Key endKey = new Key(shardId, \"d\", datatype + NULL_BYTE + eventUid + NULL_BYTE + MAX_CHAR);\n+    Range range = new Range(startKey, true, endKey, false);\n+    return new ContentIterable(client, shardTable, eventUid, datatype, userAuths, range);\n+  }\n+\n+  protected static class ContentIterable implements Iterable<Key>, AutoCloseable {\n+    private Scanner scanner;\n+\n+    public ContentIterable(AccumuloClient client, String shardTable, String eventUid, String datatype,\n+                           Set<Authorizations> userAuths, Range range)\n+        throws TableNotFoundException {\n+      scanner = ScannerHelper.createScanner(client, shardTable, userAuths);\n+      scanner.setRange(range);\n+    }\n+\n+    @Override\n+    public Iterator<Key> iterator() {\n+      return Iterators.transform(scanner.iterator(), new Function<Entry<Key, Value>, Key>() {\n+        @Nullable\n         @Override\n-        public void close() throws Exception {\n-            scanner.close();\n+        public Key apply(@Nullable Entry<Key, Value> keyValueEntry) {\n+          return keyValueEntry.getKey();\n         }\n+      });\n+    }\n+\n+    @Override\n+    public void close() throws Exception {\n+      scanner.close();\n     }\n-    \n+  }\n+\n }\n",
            "diff_size": 1287
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "62",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/86/MutableMetadataHandler.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/naturalize/86/MutableMetadataHandler.java\nindex 93a7e789ed0..bcfd1f5e300 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/86/MutableMetadataHandler.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/naturalize/86/MutableMetadataHandler.java\n@@ -325,12 +325,10 @@ public class MutableMetadataHandler extends ModificationServiceConfiguration {\n                 Map<String,String> oldFieldMarkings = null;\n                 String oldColumnVisibility = null;\n                 List<Pair<Key,Value>> currentEntryList = null;\n-                int valHistoryCount = 0;\n-                \n-                /*\n+                int valHistoryCount = 0; /*\n                  * Makes all fields mutable for services requiring no history.\n                  */\n-                if (insertHistory && !isFieldMutable(mutableFieldList, datatype, fieldName))\n+            if (insertHistory && !isFieldMutable(mutableFieldList, datatype, fieldName))\n                     throw new IllegalArgumentException(\"Field \" + fieldName + \" is not mutable\");\n                 \n                 boolean isIndexed = helper.isIndexed(fieldName, datatypeFilter);\n@@ -396,11 +394,9 @@ public class MutableMetadataHandler extends ModificationServiceConfiguration {\n                     insert(writer, shardId, datatype, eventUid, fieldMarkings, colviz, fieldName, fieldValue, isIndexOnly, isIndexed, isReverseIndexed,\n                                     dataTypes, user, MODE.INSERT, origTimestamp + valHistoryCount, insertHistory);\n                 } else if (MODE.DELETE.equals(mode)) {\n-                    delete(writer, client, userAuths, currentEntryList, isIndexOnly, isIndexed, isReverseIndexed, isContent, dataTypes, user, MODE.DELETE,\n-                                    origTimestamp + valHistoryCount, purgeIndex, insertHistory);\n+                    delete(writer, client, userAuths, currentEntryList, isIndexOnly, isIndexed, isReverseIndexed, isContent, dataTypes, user, MODE.DELETE, origTimestamp + valHistoryCount, purgeIndex, insertHistory);\n                 } else {\n-                    delete(writer, client, userAuths, currentEntryList, isIndexOnly, isIndexed, isReverseIndexed, isContent, dataTypes, user, MODE.UPDATE,\n-                                    origTimestamp + valHistoryCount, purgeIndex, insertHistory);\n+                    delete(writer, client, userAuths, currentEntryList, isIndexOnly, isIndexed, isReverseIndexed, isContent, dataTypes, user, MODE.UPDATE, origTimestamp + valHistoryCount, purgeIndex, insertHistory);\n                     String fieldValue = mr.getFieldValue();\n                     Map<String,String> fieldMarkings = mr.getFieldMarkings();\n                     String columnVisibility = mr.getColumnVisibility();\n@@ -438,8 +434,7 @@ public class MutableMetadataHandler extends ModificationServiceConfiguration {\n      * @throws Exception\n      */\n     protected void insert(MultiTableBatchWriter writer, String shardId, String datatype, String eventUid, ColumnVisibility viz, String fieldName,\n-                    String fieldValue, long timestamp, boolean isIndexOnlyField, boolean isIndexed, boolean isReverseIndexed, Set<Type<?>> dataTypes,\n-                    boolean historicalValue, boolean insertHistory, String user, MODE mode) throws Exception {\n+                    String fieldValue, long timestamp, boolean isIndexOnlyField, boolean isIndexed, boolean isReverseIndexed, Set<Type<?>> dataTypes, boolean historicalValue, boolean insertHistory, String user, MODE mode) throws Exception {\n         \n         // increment the term frequency\n         Mutation m = new Mutation(fieldName);\n@@ -528,8 +523,7 @@ public class MutableMetadataHandler extends ModificationServiceConfiguration {\n      * @throws Exception\n      */\n     protected void insertHistory(MultiTableBatchWriter writer, String shardId, String datatype, String eventUid, ColumnVisibility viz, String fieldName,\n-                    String fieldValue, long timestamp, boolean isIndexOnlyField, boolean isIndexed, boolean isReverseIndexed, Set<Type<?>> dataTypes,\n-                    String user, MODE mode) throws Exception {\n+                    String fieldValue, long timestamp, boolean isIndexOnlyField, boolean isIndexed, boolean isReverseIndexed, Set<Type<?>> dataTypes, String user, MODE mode) throws Exception {\n         // Capture the fact of the insert in a history element\n         // History element has the following structure\n         // FIELD NAME: HISTORY_<ORIGINAL FIELD NAME>\n@@ -549,8 +543,7 @@ public class MutableMetadataHandler extends ModificationServiceConfiguration {\n             historyFieldValue += \":update\";\n         }\n         \n-        insert(writer, shardId, datatype, eventUid, viz, historyFieldName, historyFieldValue, timestamp, isIndexOnlyField, isIndexed, isReverseIndexed,\n-                        dataTypes, true, false, user, mode);\n+        insert(writer, shardId, datatype, eventUid, viz, historyFieldName, historyFieldValue, timestamp, isIndexOnlyField, isIndexed, isReverseIndexed, dataTypes, true, false, user, mode);\n     }\n     \n     /**\n@@ -570,8 +563,7 @@ public class MutableMetadataHandler extends ModificationServiceConfiguration {\n      * @throws Exception\n      */\n     protected void insert(MultiTableBatchWriter writer, String shardId, String datatype, String eventUid, Map<String,String> markings, ColumnVisibility viz,\n-                    String fieldName, String fieldValue, boolean isIndexOnlyField, boolean isIndexed, boolean isReverseIndexed, Set<Type<?>> dataTypes,\n-                    String user, MODE mode, long ts, boolean insertHistory) throws Exception {\n+                    String fieldName, String fieldValue, boolean isIndexOnlyField, boolean isIndexed, boolean isReverseIndexed, Set<Type<?>> dataTypes, String user, MODE mode, long ts, boolean insertHistory) throws Exception {\n         \n         if (null == viz) {\n             if (null == markings || markings.isEmpty())\n@@ -580,8 +572,7 @@ public class MutableMetadataHandler extends ModificationServiceConfiguration {\n             viz = markingFunctions.translateToColumnVisibility(markings);\n         }\n         \n-        insert(writer, shardId, datatype, eventUid, viz, fieldName, fieldValue, ts, isIndexOnlyField, isIndexed, isReverseIndexed, dataTypes, false,\n-                        insertHistory, user, mode);\n+        insert(writer, shardId, datatype, eventUid, viz, fieldName, fieldValue, ts, isIndexOnlyField, isIndexed, isReverseIndexed, dataTypes, false, insertHistory, user, mode);\n     }\n     \n     /**\n@@ -602,10 +593,8 @@ public class MutableMetadataHandler extends ModificationServiceConfiguration {\n      * @throws Exception\n      */\n     protected void delete(MultiTableBatchWriter writer, AccumuloClient client, Set<Authorizations> userAuths, List<Pair<Key,Value>> currentEntryList,\n-                    boolean isIndexOnlyField, boolean isIndexed, boolean isReverseIndexed, boolean isContentField, Set<Type<?>> dataTypes, String user,\n-                    MODE mode, long ts, boolean purgeTokens, boolean insertHistory) throws Exception {\n-        \n-        for (Pair<Key,Value> currentEntry : currentEntryList) {\n+                    boolean isIndexOnlyField, boolean isIndexed, boolean isReverseIndexed, boolean isContentField, Set<Type<?>> dataTypes, String user, MODE mode, long ts, boolean purgeTokens, boolean insertHistory) throws Exception {\n+    for (Pair<Key,Value> currentEntry : currentEntryList) {\n             \n             ColumnVisibility viz = currentEntry.getFirst().getColumnVisibilityParsed();\n             \n@@ -644,8 +633,7 @@ public class MutableMetadataHandler extends ModificationServiceConfiguration {\n                         dKeys.close();\n                     }\n                 }\n-                \n-                long tsToDay = (ts / MS_PER_DAY) * MS_PER_DAY;\n+long tsToDay = (ts / MS_PER_DAY) * MS_PER_DAY;\n                 \n                 FieldIndexIterable fiKeys = getFieldIndexKeys(client, this.getEventTableName(), userAuths, shardId, key.getDataType(), key.getUid(),\n                                 key.getFieldName(), key.getFieldValue(), dataTypes, purgeTokens);\n@@ -915,8 +903,7 @@ public class MutableMetadataHandler extends ModificationServiceConfiguration {\n             GenericResponse<String> createResponse = queryService.createQuery(logicName, QueryParametersImpl.paramsToMap(logicName, query.toString(),\n                             \"Query to find matching records for metadata modification\", columnVisibility, new Date(0), new Date(),\n                             StringUtils.join(auths, ','), expiration, 2, -1, null, QueryPersistence.TRANSIENT, queryOptions.toString(), false));\n-            \n-            id = createResponse.getResult();\n+id = createResponse.getResult();\n             BaseQueryResponse response = queryService.next(id);\n             if (response instanceof DefaultEventQueryResponse) {\n                 DefaultEventQueryResponse eResponse = (DefaultEventQueryResponse) response;\n@@ -1081,4 +1068,4 @@ public class MutableMetadataHandler extends ModificationServiceConfiguration {\n         }\n     }\n     \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 27
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "62",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/86/MutableMetadataHandler.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/codebuff/86/MutableMetadataHandler.java\nindex 93a7e789ed0..97ed25e4ad4 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/86/MutableMetadataHandler.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/codebuff/86/MutableMetadataHandler.java\n@@ -177,18 +177,19 @@ import org.apache.log4j.Logger;\n  * </pre>\n  * \n  */\n+\n+\n public class MutableMetadataHandler extends ModificationServiceConfiguration {\n-    \n     private Logger log = Logger.getLogger(this.getClass());\n-    \n     protected static final long MS_PER_DAY = TimeUnit.DAYS.toMillis(1);\n     protected static final String DESCRIPTION = \"Modification service that processes insert, update, and delete requests of event fields for event(s) identified by the shard id, datatype, and event uid.\";\n+\n     public static final String FIELD_INDEX_PREFIX = \"fi\\0\";\n     protected static final String NULL_BYTE = \"\\0\";\n     protected static final String MAX_CHAR = new String(Character.toChars(Character.MAX_CODE_POINT));\n     protected static final Value NULL_VALUE = new Value(new byte[0]);\n+\n     public static final String HISTORY_PREFIX = \"HISTORY_\";\n-    \n     protected String eventTableName = null;\n     protected String indexTableName = null;\n     protected String reverseIndexTableName = null;\n@@ -204,123 +205,120 @@ public class MutableMetadataHandler extends ModificationServiceConfiguration {\n     \n     // a list of event fields that map to content\n     protected Set<String> contentFields = null;\n-    \n+\n     public String getEventTableName() {\n         return eventTableName;\n     }\n-    \n+\n     public void setEventTableName(String eventTableName) {\n         this.eventTableName = eventTableName;\n     }\n-    \n+\n     public String getIndexTableName() {\n         return indexTableName;\n     }\n-    \n+\n     public void setIndexTableName(String indexTableName) {\n         this.indexTableName = indexTableName;\n     }\n-    \n+\n     public String getReverseIndexTableName() {\n         return reverseIndexTableName;\n     }\n-    \n+\n     public void setReverseIndexTableName(String reverseIndexTableName) {\n         this.reverseIndexTableName = reverseIndexTableName;\n     }\n-    \n+\n     public String getMetadataTableName() {\n         return metadataTableName;\n     }\n-    \n+\n     public void setMetadataTableName(String metadataTableName) {\n         this.metadataTableName = metadataTableName;\n     }\n-    \n+\n     public MarkingFunctions getMarkingFunctions() {\n         return markingFunctions;\n     }\n-    \n+\n     public void setMarkingFunctions(MarkingFunctions markingFunctions) {\n         this.markingFunctions = markingFunctions;\n     }\n-    \n+\n     public Multimap<String,String> getIndexOnlyMap() {\n         return indexOnlyMap;\n     }\n     \n     // this is set from a spring configuration where the value is comma delimited\n+\n     public void setIndexOnlyMap(Map<String,String> map) {\n         this.indexOnlyMap = HashMultimap.create();\n+\n         for (Map.Entry<String,String> entry : map.entrySet()) {\n             for (String value : StringUtils.split(entry.getValue(), ',')) {\n                 this.indexOnlyMap.put(entry.getKey(), value.trim());\n             }\n         }\n     }\n-    \n+\n     public Set<String> getContentFields() {\n         return contentFields;\n     }\n-    \n+\n     public void setContentFields(Set<String> fields) {\n         this.contentFields = fields;\n     }\n-    \n+\n     public Set<String> getIndexOnlySuffixes() {\n         return indexOnlySuffixes;\n     }\n-    \n+\n     public void setIndexOnlySuffixes(Set<String> suffixes) {\n         this.indexOnlySuffixes = suffixes;\n     }\n-    \n+\n     public MetadataHelperFactory getMetadataHelperFactory() {\n         return metadataHelperFactory;\n     }\n-    \n+\n     public void setMetadataHelperFactory(MetadataHelperFactory metadataHelperFactory) {\n         this.metadataHelperFactory = metadataHelperFactory;\n     }\n-    \n+\n     @Override\n     public String getDescription() {\n         return DESCRIPTION;\n     }\n-    \n+\n     @Override\n     public Class<? extends ModificationRequestBase> getRequestClass() {\n         return DefaultModificationRequest.class;\n     }\n     \n     // Default the insert history option to true so that the call remains backwards compatible.\n+\n     @Override\n-    public void process(AccumuloClient client, ModificationRequestBase request, Map<String,Set<String>> mutableFieldList, Set<Authorizations> userAuths,\n-                    String user) throws Exception {\n+    public void process(AccumuloClient client, ModificationRequestBase request, Map<String,Set<String>> mutableFieldList, Set<Authorizations> userAuths, String user) throws Exception {\n         this.process(client, request, mutableFieldList, userAuths, user, false, true);\n     }\n-    \n-    public void process(AccumuloClient client, ModificationRequestBase request, Map<String,Set<String>> mutableFieldList, Set<Authorizations> userAuths,\n-                    String user, boolean purgeIndex, boolean insertHistory) throws Exception {\n-        \n+\n+    public void process(AccumuloClient client, ModificationRequestBase request, Map<String,Set<String>> mutableFieldList, Set<Authorizations> userAuths, String user, boolean purgeIndex, boolean insertHistory) throws Exception {\n         DefaultModificationRequest mr = DefaultModificationRequest.class.cast(request);\n-        \n         if (null == mr.getEvents() || mr.getEvents().isEmpty()) {\n             throw new IllegalArgumentException(\"No events specified for modification\");\n         }\n-        \n+\n         String fieldName = mr.getFieldName();\n         MetadataHelper helper = getMetadataHelper(client);\n         MODE mode = mr.getMode();\n-        MultiTableBatchWriter writer = client.createMultiTableBatchWriter(new BatchWriterConfig().setMaxLatency(1, TimeUnit.SECONDS).setMaxMemory(1048576L)\n-                        .setMaxWriteThreads(4));\n+        MultiTableBatchWriter writer = client.createMultiTableBatchWriter(new BatchWriterConfig().setMaxLatency(1, TimeUnit.SECONDS).setMaxMemory(1048576L).setMaxWriteThreads(4));\n         try {\n             for (EventIdentifier e : mr.getEvents()) {\n                 String shardId = e.getShardId();\n                 String datatype = e.getDatatype();\n                 Set<String> datatypeFilter = Collections.singleton(datatype);\n                 String eventUid = e.getEventUid();\n-                \n                 String oldFieldValue = null;\n                 Map<String,String> oldFieldMarkings = null;\n                 String oldColumnVisibility = null;\n@@ -332,30 +330,26 @@ public class MutableMetadataHandler extends ModificationServiceConfiguration {\n                  */\n                 if (insertHistory && !isFieldMutable(mutableFieldList, datatype, fieldName))\n                     throw new IllegalArgumentException(\"Field \" + fieldName + \" is not mutable\");\n-                \n                 boolean isIndexed = helper.isIndexed(fieldName, datatypeFilter);\n                 boolean isReverseIndexed = helper.isReverseIndexed(fieldName, datatypeFilter);\n                 boolean isIndexOnly = helper.getIndexOnlyFields(datatypeFilter).contains(fieldName);\n                 boolean isContent = (contentFields != null && contentFields.contains(fieldName));\n                 Set<Type<?>> dataTypes = helper.getDatatypesForField(fieldName, Collections.singleton(datatype));\n-                \n                 if ((isIndexed || isReverseIndexed || isIndexOnly) && (null == dataTypes || dataTypes.isEmpty()))\n                     throw new IllegalStateException(\"Field \" + fieldName + \" is marked index only but has no dataTypes\");\n-                \n                 long origTimestamp = getOriginalEventTimestamp(client, userAuths, shardId, datatype, eventUid);\n                 \n                 // Count the history entries if history is going to be inserted.\n                 if (insertHistory && (MODE.INSERT.equals(mode) || MODE.UPDATE.equals(mode))) {\n-                    List<Pair<Key,Value>> fieldHistoryList = getField(client, userAuths, shardId, datatype, eventUid, \"HISTORY_\" + fieldName, null,\n-                                    new HashMap<>(), null);\n-                    \n+                    List<Pair<Key,Value>> fieldHistoryList = getField(client, userAuths, shardId, datatype, eventUid, \"HISTORY_\" + fieldName, null, new HashMap<>(), null);\n                     for (Pair<Key,Value> p : fieldHistoryList) {\n                         if (p.getFirst().getColumnQualifier().find(mr.getFieldValue()) > -1) {\n                             ++valHistoryCount;\n                         }\n                     }\n                 }\n-                \n+\n+\n                 if (MODE.UPDATE.equals(mode) || MODE.DELETE.equals(mode)) {\n                     if (MODE.UPDATE.equals(mode)) {\n                         oldFieldValue = mr.getOldFieldValue();\n@@ -370,6 +364,7 @@ public class MutableMetadataHandler extends ModificationServiceConfiguration {\n                         if (null == oldFieldValue)\n                             throw new IllegalArgumentException(\"fieldValue parameter required for delete\");\n                     }\n+\n                     ColumnVisibility oldViz = null;\n                     if (null != oldColumnVisibility) {\n                         oldViz = new ColumnVisibility(oldColumnVisibility);\n@@ -384,7 +379,8 @@ public class MutableMetadataHandler extends ModificationServiceConfiguration {\n                     if (null == mr.getFieldValue())\n                         throw new IllegalArgumentException(\"fieldValue parameter required for insert\");\n                 }\n-                \n+\n+\n                 if (MODE.INSERT.equals(mode)) {\n                     String fieldValue = mr.getFieldValue();\n                     Map<String,String> fieldMarkings = mr.getFieldMarkings();\n@@ -393,14 +389,12 @@ public class MutableMetadataHandler extends ModificationServiceConfiguration {\n                     if (null != columnVisibility) {\n                         colviz = new ColumnVisibility(columnVisibility);\n                     }\n-                    insert(writer, shardId, datatype, eventUid, fieldMarkings, colviz, fieldName, fieldValue, isIndexOnly, isIndexed, isReverseIndexed,\n-                                    dataTypes, user, MODE.INSERT, origTimestamp + valHistoryCount, insertHistory);\n+                    insert(writer, shardId, datatype, eventUid, fieldMarkings, colviz, fieldName, fieldValue, isIndexOnly, isIndexed, isReverseIndexed, dataTypes, user, MODE.INSERT, origTimestamp + valHistoryCount, insertHistory);\n                 } else if (MODE.DELETE.equals(mode)) {\n-                    delete(writer, client, userAuths, currentEntryList, isIndexOnly, isIndexed, isReverseIndexed, isContent, dataTypes, user, MODE.DELETE,\n-                                    origTimestamp + valHistoryCount, purgeIndex, insertHistory);\n-                } else {\n-                    delete(writer, client, userAuths, currentEntryList, isIndexOnly, isIndexed, isReverseIndexed, isContent, dataTypes, user, MODE.UPDATE,\n-                                    origTimestamp + valHistoryCount, purgeIndex, insertHistory);\n+                    delete(writer, client, userAuths, currentEntryList, isIndexOnly, isIndexed, isReverseIndexed, isContent, dataTypes, user, MODE.DELETE, origTimestamp + valHistoryCount, purgeIndex, insertHistory);\n+                                                     } else {\n+                    delete(writer, client, userAuths, currentEntryList, isIndexOnly, isIndexed, isReverseIndexed, isContent, dataTypes, user, MODE.UPDATE, origTimestamp + valHistoryCount, purgeIndex, insertHistory);\n+\n                     String fieldValue = mr.getFieldValue();\n                     Map<String,String> fieldMarkings = mr.getFieldMarkings();\n                     String columnVisibility = mr.getColumnVisibility();\n@@ -408,8 +402,7 @@ public class MutableMetadataHandler extends ModificationServiceConfiguration {\n                     if (null != columnVisibility) {\n                         colviz = new ColumnVisibility(columnVisibility);\n                     }\n-                    insert(writer, shardId, datatype, eventUid, fieldMarkings, colviz, fieldName, fieldValue, isIndexOnly, isIndexed, isReverseIndexed,\n-                                    dataTypes, user, MODE.UPDATE, origTimestamp + valHistoryCount, insertHistory);\n+                    insert(writer, shardId, datatype, eventUid, fieldMarkings, colviz, fieldName, fieldValue, isIndexOnly, isIndexed, isReverseIndexed, dataTypes, user, MODE.UPDATE, origTimestamp + valHistoryCount, insertHistory);\n                 }\n             }\n         } finally {\n@@ -437,26 +430,25 @@ public class MutableMetadataHandler extends ModificationServiceConfiguration {\n      * @param mode\n      * @throws Exception\n      */\n-    protected void insert(MultiTableBatchWriter writer, String shardId, String datatype, String eventUid, ColumnVisibility viz, String fieldName,\n-                    String fieldValue, long timestamp, boolean isIndexOnlyField, boolean isIndexed, boolean isReverseIndexed, Set<Type<?>> dataTypes,\n-                    boolean historicalValue, boolean insertHistory, String user, MODE mode) throws Exception {\n+\n+    protected void insert(MultiTableBatchWriter writer, String shardId, String datatype, String eventUid, ColumnVisibility viz, String fieldName, String fieldValue, long timestamp, boolean isIndexOnlyField, boolean isIndexed, boolean isReverseIndexed, Set<Type<?>> dataTypes, boolean historicalValue, boolean insertHistory, String user, MODE mode) throws Exception {\n         \n         // increment the term frequency\n         Mutation m = new Mutation(fieldName);\n         if (!isIndexOnlyField) {\n             m.put(ColumnFamilyConstants.COLF_E, new Text(datatype), NULL_VALUE);\n-            m.put(ColumnFamilyConstants.COLF_F, new Text(datatype + NULL_BYTE + DateHelper.format(timestamp)),\n-                            new Value(SummingCombiner.VAR_LEN_ENCODER.encode(1L)));\n+            m.put(ColumnFamilyConstants.COLF_F, new Text(datatype + NULL_BYTE + DateHelper.format(timestamp)), new Value(SummingCombiner.VAR_LEN_ENCODER.encode(1L)));\n         }\n         \n         // Insert the new field.\n+\n         Mutation e = new Mutation(shardId);\n         if (!isIndexOnlyField) {\n             e.put(new Text(datatype + NULL_BYTE + eventUid), new Text(fieldName + NULL_BYTE + fieldValue), viz, timestamp, NULL_VALUE);\n         }\n-        \n+\n+\n         if (isIndexed) {\n-            \n             long tsToDay = (timestamp / MS_PER_DAY) * MS_PER_DAY;\n             \n             // Create a UID object for the Value\n@@ -464,9 +456,9 @@ public class MutableMetadataHandler extends ModificationServiceConfiguration {\n             uidBuilder.setIGNORE(false);\n             uidBuilder.setCOUNT(1);\n             uidBuilder.addUID(eventUid);\n+\n             Uid.List uidList = uidBuilder.build();\n             Value val = new Value(uidList.toByteArray());\n-            \n             for (Type<?> n : dataTypes) {\n                 String indexTerm = fieldValue;\n                 if (historicalValue) {\n@@ -477,6 +469,7 @@ public class MutableMetadataHandler extends ModificationServiceConfiguration {\n                     indexTermLeadingColon = fieldValue.indexOf(\":\", indexTermLeadingColon + 1);\n                     indexTerm = fieldValue.substring(indexTermLeadingColon + 1, lastColon);\n                 }\n+\n                 String indexedValue = n.normalize(indexTerm);\n                 \n                 // Insert the global index entry\n@@ -484,7 +477,6 @@ public class MutableMetadataHandler extends ModificationServiceConfiguration {\n                 i.put(fieldName, shardId + NULL_BYTE + datatype, viz, tsToDay, val);\n                 writer.getBatchWriter(this.getIndexTableName()).addMutation(i);\n                 m.put(ColumnFamilyConstants.COLF_I, new Text(datatype + NULL_BYTE + n.getClass().getName()), NULL_VALUE);\n-                \n                 if (isReverseIndexed) {\n                     String reverseIndexedValue = StringUtils.reverse(indexedValue);\n                     // Insert the global reverse index entry\n@@ -494,17 +486,31 @@ public class MutableMetadataHandler extends ModificationServiceConfiguration {\n                     m.put(ColumnFamilyConstants.COLF_RI, new Text(datatype + NULL_BYTE + n.getClass().getName()), NULL_VALUE);\n                 }\n                 // Insert the field index entry\n-                e.put(new Text(FIELD_INDEX_PREFIX + fieldName), new Text(indexedValue + NULL_BYTE + datatype + NULL_BYTE + eventUid), viz, timestamp,\n+                e.put(new Text(FIELD_INDEX_PREFIX + fieldName),\n+                    new Text(indexedValue + NULL_BYTE + datatype + NULL_BYTE + eventUid),\n+                        viz,\n+                            timestamp,\n                                 NULL_VALUE);\n             }\n         }\n         writer.getBatchWriter(this.getEventTableName()).addMutation(e);\n         writer.getBatchWriter(this.getMetadataTableName()).addMutation(m);\n         writer.flush();\n-        \n         if (!isIndexOnlyField && insertHistory) {\n-            insertHistory(writer, shardId, datatype, eventUid, viz, fieldName, fieldValue, timestamp, isIndexOnlyField, isIndexed, isReverseIndexed, dataTypes,\n-                            user, mode);\n+            insertHistory(writer,\n+shardId,\n+datatype,\n+eventUid,\n+viz,\n+fieldName,\n+fieldValue,\n+timestamp,\n+isIndexOnlyField,\n+isIndexed,\n+isReverseIndexed,\n+dataTypes,\n+user,\n+mode);\n         }\n     }\n     \n@@ -527,9 +533,8 @@ public class MutableMetadataHandler extends ModificationServiceConfiguration {\n      * @param mode\n      * @throws Exception\n      */\n-    protected void insertHistory(MultiTableBatchWriter writer, String shardId, String datatype, String eventUid, ColumnVisibility viz, String fieldName,\n-                    String fieldValue, long timestamp, boolean isIndexOnlyField, boolean isIndexed, boolean isReverseIndexed, Set<Type<?>> dataTypes,\n-                    String user, MODE mode) throws Exception {\n+\n+    protected void insertHistory(MultiTableBatchWriter writer, String shardId, String datatype, String eventUid, ColumnVisibility viz, String fieldName, String fieldValue, long timestamp, boolean isIndexOnlyField, boolean isIndexed, boolean isReverseIndexed, Set<Type<?>> dataTypes, String user, MODE mode) throws Exception {\n         // Capture the fact of the insert in a history element\n         // History element has the following structure\n         // FIELD NAME: HISTORY_<ORIGINAL FIELD NAME>\n@@ -544,13 +549,11 @@ public class MutableMetadataHandler extends ModificationServiceConfiguration {\n         } else if (mode.equals(MODE.DELETE)) {\n             historyFieldValue = System.currentTimeMillis() + \":\" + user + \":\" + fieldValue;\n             historyFieldValue += \":delete\";\n-        } else { // update\n+                                                                                                                                                                                                                                                                                                                                    } else { // update\n             historyFieldValue = System.currentTimeMillis() + \":\" + user + \":\" + fieldValue;\n             historyFieldValue += \":update\";\n         }\n-        \n-        insert(writer, shardId, datatype, eventUid, viz, historyFieldName, historyFieldValue, timestamp, isIndexOnlyField, isIndexed, isReverseIndexed,\n-                        dataTypes, true, false, user, mode);\n+        insert(writer, shardId, datatype, eventUid, viz, historyFieldName, historyFieldValue, timestamp, isIndexOnlyField, isIndexed, isReverseIndexed, dataTypes, true, false, user, mode);\n     }\n     \n     /**\n@@ -569,19 +572,29 @@ public class MutableMetadataHandler extends ModificationServiceConfiguration {\n      * @param mode\n      * @throws Exception\n      */\n-    protected void insert(MultiTableBatchWriter writer, String shardId, String datatype, String eventUid, Map<String,String> markings, ColumnVisibility viz,\n-                    String fieldName, String fieldValue, boolean isIndexOnlyField, boolean isIndexed, boolean isReverseIndexed, Set<Type<?>> dataTypes,\n-                    String user, MODE mode, long ts, boolean insertHistory) throws Exception {\n-        \n+\n+    protected void insert(MultiTableBatchWriter writer, String shardId, String datatype, String eventUid, Map<String,String> markings, ColumnVisibility viz, String fieldName, String fieldValue, boolean isIndexOnlyField, boolean isIndexed, boolean isReverseIndexed, Set<Type<?>> dataTypes, String user, MODE mode, long ts, boolean insertHistory) throws Exception {\n         if (null == viz) {\n             if (null == markings || markings.isEmpty())\n                 throw new IllegalArgumentException(\"No security information specified. Security markings must be supplied\");\n-            \n             viz = markingFunctions.translateToColumnVisibility(markings);\n         }\n-        \n-        insert(writer, shardId, datatype, eventUid, viz, fieldName, fieldValue, ts, isIndexOnlyField, isIndexed, isReverseIndexed, dataTypes, false,\n-                        insertHistory, user, mode);\n+        insert(writer,\n+shardId,\n+datatype,\n+eventUid,\n+viz,\n+fieldName,\n+fieldValue,\n+ts,\n+isIndexOnlyField,\n+isIndexed,\n+isReverseIndexed,\n+dataTypes,\n+false,\n+insertHistory,\n+user,\n+mode);\n     }\n     \n     /**\n@@ -601,20 +614,13 @@ public class MutableMetadataHandler extends ModificationServiceConfiguration {\n      * @param insertHistory\n      * @throws Exception\n      */\n-    protected void delete(MultiTableBatchWriter writer, AccumuloClient client, Set<Authorizations> userAuths, List<Pair<Key,Value>> currentEntryList,\n-                    boolean isIndexOnlyField, boolean isIndexed, boolean isReverseIndexed, boolean isContentField, Set<Type<?>> dataTypes, String user,\n-                    MODE mode, long ts, boolean purgeTokens, boolean insertHistory) throws Exception {\n-        \n+\n+    protected void delete(MultiTableBatchWriter writer, AccumuloClient client, Set<Authorizations> userAuths, List<Pair<Key,Value>> currentEntryList, boolean isIndexOnlyField, boolean isIndexed, boolean isReverseIndexed, boolean isContentField, Set<Type<?>> dataTypes, String user, MODE mode, long ts, boolean purgeTokens, boolean insertHistory) throws Exception {\n         for (Pair<Key,Value> currentEntry : currentEntryList) {\n-            \n             ColumnVisibility viz = currentEntry.getFirst().getColumnVisibilityParsed();\n-            \n             DatawaveKey key = new DatawaveKey(currentEntry.getFirst());\n-            \n             String shardId = key.getRow().toString();\n-            \n             long currentEntryTimestamp = currentEntry.getFirst().getTimestamp();\n-            \n             if (key.getType().equals(KeyType.INDEX_EVENT)) {\n                 // Only the delete the fi key\n                 Mutation e = new Mutation(currentEntry.getFirst().getRow());\n@@ -624,16 +630,18 @@ public class MutableMetadataHandler extends ModificationServiceConfiguration {\n                 Mutation m = new Mutation(key.getFieldName());\n                 \n                 // Decrement the frequency (metadata table)\n-                m.put(ColumnFamilyConstants.COLF_F, new Text(key.getDataType() + NULL_BYTE + DateHelper.format(currentEntryTimestamp)), new Value(\n-                                SummingCombiner.VAR_LEN_ENCODER.encode(-1L)));\n+                m.put(ColumnFamilyConstants.COLF_F, new Text(key.getDataType() + NULL_BYTE + DateHelper.format(currentEntryTimestamp)), new Value(SummingCombiner.VAR_LEN_ENCODER.encode(-1L)));\n                 \n                 // Remove the event field.\n+\n                 Mutation e = new Mutation(currentEntry.getFirst().getRow());\n                 if (!isIndexOnlyField) {\n                     e.putDelete(currentEntry.getFirst().getColumnFamily(), currentEntry.getFirst().getColumnQualifier(), viz, currentEntryTimestamp);\n                 }\n                 \n                 // Remove the content column\n+\n+\n                 if (isContentField) {\n                     ContentIterable dKeys = getContentKeys(client, this.getEventTableName(), userAuths, shardId, key.getDataType(), key.getUid());\n                     try {\n@@ -644,28 +652,34 @@ public class MutableMetadataHandler extends ModificationServiceConfiguration {\n                         dKeys.close();\n                     }\n                 }\n-                \n                 long tsToDay = (ts / MS_PER_DAY) * MS_PER_DAY;\n-                \n-                FieldIndexIterable fiKeys = getFieldIndexKeys(client, this.getEventTableName(), userAuths, shardId, key.getDataType(), key.getUid(),\n-                                key.getFieldName(), key.getFieldValue(), dataTypes, purgeTokens);\n+                FieldIndexIterable fiKeys = getFieldIndexKeys(client,\n+                    this.getEventTableName(),\n+                    userAuths,\n+                    shardId,\n+                    key.getDataType(),\n+                    key.getUid(),\n+                    key.getFieldName(),\n+                    key.getFieldValue(),\n+                    dataTypes,\n+                    purgeTokens);\n                 try {\n                     for (Key fiKey : fiKeys) {\n                         // Remove the field index entry\n                         e.putDelete(fiKey.getColumnFamily(), fiKey.getColumnQualifier(), fiKey.getColumnVisibilityParsed(), fiKey.getTimestamp());\n-                        \n+\n                         DatawaveKey fiKeyParsed = new DatawaveKey(fiKey);\n                         \n                         // Remove the term frequency entry\n-                        e.putDelete(ColumnFamilyConstants.COLF_TF.toString(), fiKeyParsed.getDataType() + NULL_BYTE + fiKeyParsed.getUid() + NULL_BYTE\n-                                        + fiKeyParsed.getFieldValue() + NULL_BYTE + fiKeyParsed.getFieldName(), fiKey.getColumnVisibilityParsed(),\n-                                        fiKey.getTimestamp());\n+                        e.putDelete(ColumnFamilyConstants.COLF_TF.toString(), fiKeyParsed.getDataType() + NULL_BYTE + fiKeyParsed.getUid() + NULL_BYTE + fiKeyParsed.getFieldValue() + NULL_BYTE + fiKeyParsed.getFieldName(), fiKey.getColumnVisibilityParsed(), fiKey.getTimestamp());\n                         \n                         // Create a UID object for the Value which will remove this UID\n+\n                         Builder uidBuilder = Uid.List.newBuilder();\n                         uidBuilder.setIGNORE(false);\n                         uidBuilder.setCOUNT(-1);\n                         uidBuilder.addUID(fiKeyParsed.getUid());\n+\n                         Uid.List uidList = uidBuilder.build();\n                         Value val = new Value(uidList.toByteArray());\n                         \n@@ -688,16 +702,14 @@ public class MutableMetadataHandler extends ModificationServiceConfiguration {\n                 } finally {\n                     fiKeys.close();\n                 }\n-                \n+\n+\n                 if (e.size() > 0) {\n                     writer.getBatchWriter(this.getEventTableName()).addMutation(e);\n                 }\n-                \n                 writer.getBatchWriter(this.getMetadataTableName()).addMutation(m);\n-                \n                 if (!isIndexOnlyField && insertHistory) {\n-                    insertHistory(writer, shardId, key.getDataType(), key.getUid(), viz, key.getFieldName(), key.getFieldValue(), ts, isIndexOnlyField,\n-                                    isIndexed, isReverseIndexed, dataTypes, user, mode);\n+                    insertHistory(writer, shardId, key.getDataType(), key.getUid(), viz, key.getFieldName(), key.getFieldValue(), ts, isIndexOnlyField, isIndexed, isReverseIndexed, dataTypes, user, mode);\n                 }\n             }\n         }\n@@ -719,21 +731,25 @@ public class MutableMetadataHandler extends ModificationServiceConfiguration {\n      * @return\n      * @throws Exception\n      */\n-    protected List<Pair<Key,Value>> getField(AccumuloClient client, Set<Authorizations> userAuths, String shardId, String datatype, String eventUid,\n-                    String fieldName, String oldFieldValue, Map<String,String> oldFieldMarkings, ColumnVisibility oldColumnVisibility) throws Exception {\n-        \n+\n+    protected List<Pair<Key,Value>> getField(AccumuloClient client,\n+        Set<Authorizations> userAuths,\n+            String shardId,\n+                String datatype,\n+                    String eventUid,\n+                        String fieldName,\n+                            String oldFieldValue,\n+                                Map<String,String> oldFieldMarkings, ColumnVisibility oldColumnVisibility) throws Exception {\n         Text family = new Text(datatype);\n         TextUtil.textAppend(family, eventUid);\n-        \n+\n         Text qualifier = null;\n-        \n         if (oldFieldValue != null) {\n             qualifier = new Text(fieldName);\n             TextUtil.textAppend(qualifier, oldFieldValue);\n         }\n-        \n+\n         List<Pair<Key,Value>> results = new ArrayList<>();\n-        \n         Scanner s = ScannerHelper.createScanner(client, this.getEventTableName(), userAuths);\n         try {\n             s.setRange(new Range(shardId));\n@@ -742,14 +758,13 @@ public class MutableMetadataHandler extends ModificationServiceConfiguration {\n             } else {\n                 s.fetchColumn(family, qualifier);\n             }\n-            \n             for (Entry<Key,Value> e : s) {\n                 ColumnVisibility thisViz = new ColumnVisibility(e.getKey().getColumnVisibility());\n-                \n                 if (!e.getKey().getColumnQualifier().toString().startsWith(fieldName)) {\n                     continue;\n                 }\n-                \n+\n+\n                 if (null != oldColumnVisibility) {\n                     // need to compare the flattened values for equivalence. It's possible for the visibility to be in a different order\n                     String oldColViz = new String(oldColumnVisibility.flatten(), \"UTF-8\");\n@@ -785,14 +800,12 @@ public class MutableMetadataHandler extends ModificationServiceConfiguration {\n      * @return long - highestOccurrenceTimestamp - most common timestamp in the event\n      * @throws Exception\n      */\n-    protected long getOriginalEventTimestamp(AccumuloClient client, Set<Authorizations> userAuths, String shardId, String datatype, String eventUid)\n-                    throws Exception {\n-        \n+\n+    protected long getOriginalEventTimestamp(AccumuloClient client, Set<Authorizations> userAuths, String shardId, String datatype, String eventUid) throws Exception {\n         Text family = new Text(datatype);\n         TextUtil.textAppend(family, eventUid);\n-        \n+\n         HashMap<Long,Integer> timestampCounts = new HashMap<>();\n-        \n         long highestOccurrenceTimestamp = 0;\n         int highestOccurrences = -1;\n         \n@@ -803,6 +816,7 @@ public class MutableMetadataHandler extends ModificationServiceConfiguration {\n             s.fetchColumnFamily(family);\n             \n             // Populate map with how often each timestamp occurs\n+\n             for (Entry<Key,Value> e : s) {\n                 long ts = e.getKey().getTimestamp();\n                 if (!timestampCounts.containsKey(ts)) {\n@@ -813,6 +827,8 @@ public class MutableMetadataHandler extends ModificationServiceConfiguration {\n             }\n             \n             // Determine the most common timestamp\n+\n+\n             if (timestampCounts.isEmpty()) {\n                 // if no fields exist, then use the shard date at 00:00:00\n                 highestOccurrenceTimestamp = DateHelper.parse(shardId.substring(0, 8)).getTime();\n@@ -829,7 +845,6 @@ public class MutableMetadataHandler extends ModificationServiceConfiguration {\n         } finally {\n             s.close();\n         }\n-        \n         return highestOccurrenceTimestamp;\n     }\n     \n@@ -843,8 +858,8 @@ public class MutableMetadataHandler extends ModificationServiceConfiguration {\n      * @throws ExecutionException\n      * @throws TableNotFoundException\n      */\n-    protected MetadataHelper getMetadataHelper(AccumuloClient client) throws AccumuloException, AccumuloSecurityException, TableNotFoundException,\n-                    ExecutionException {\n+\n+    protected MetadataHelper getMetadataHelper(AccumuloClient client) throws AccumuloException, AccumuloSecurityException, TableNotFoundException, ExecutionException {\n         Authorizations auths = client.securityOperations().getUserAuthorizations(client.whoami());\n         return metadataHelperFactory.createMetadataHelper(client, this.getMetadataTableName(), Collections.singleton(auths));\n     }\n@@ -857,6 +872,7 @@ public class MutableMetadataHandler extends ModificationServiceConfiguration {\n      * @param fieldName\n      * @return\n      */\n+\n     protected boolean isFieldMutable(Map<String,Set<String>> mutableFieldList, String datatype, String fieldName) {\n         if (null == mutableFieldList)\n             return false;\n@@ -868,6 +884,7 @@ public class MutableMetadataHandler extends ModificationServiceConfiguration {\n     /**\n      * @return priority of the connection for this service\n      */\n+\n     @Override\n     public AccumuloConnectionFactory.Priority getPriority() {\n         return AccumuloConnectionFactory.Priority.NORMAL;\n@@ -882,9 +899,8 @@ public class MutableMetadataHandler extends ModificationServiceConfiguration {\n      * @return Event\n      * @throws Exception\n      */\n-    protected EventBase<?,?> findMatchingEventUuid(String uuid, String uuidType, Set<Authorizations> userAuths, ModificationOperation operation)\n-                    throws Exception {\n-        \n+\n+    protected EventBase<?,?> findMatchingEventUuid(String uuid, String uuidType, Set<Authorizations> userAuths, ModificationOperation operation) throws Exception {\n         String field = operation.getFieldName();\n         String columnVisibility = operation.getColumnVisibility();\n         \n@@ -892,41 +908,38 @@ public class MutableMetadataHandler extends ModificationServiceConfiguration {\n         StringBuilder query = new StringBuilder();\n         query.append(uuidType.toUpperCase()).append(\":\\\"\").append(uuid).append(\"\\\"\");\n         // make the query only return the field to be modified and the UUIDType (avoids NoResultsException on an insert where the field has no values)\n+\n         StringBuilder queryOptions = new StringBuilder();\n         queryOptions.append(\"query.syntax:LUCENE-UUID;raw.data.only:true\");\n         if (field != null) {\n             queryOptions.append(\";return.fields:\").append(field.toUpperCase()).append(\",\").append(uuidType.toUpperCase());\n         }\n-        \n+\n         String logicName = \"LuceneUUIDEventQuery\";\n-        \n         DefaultEvent e = null;\n         QueryExecutorBean queryService = this.getQueryService();\n-        \n         String id = null;\n         HashSet<String> auths = new HashSet<>();\n         for (Authorizations a : userAuths)\n             auths.addAll(Arrays.asList(a.toString().split(\",\")));\n-        \n+\n         Date expiration = new Date();\n         expiration = new Date(expiration.getTime() + (1000 * 60 * 60 * 24));\n-        \n         try {\n-            GenericResponse<String> createResponse = queryService.createQuery(logicName, QueryParametersImpl.paramsToMap(logicName, query.toString(),\n-                            \"Query to find matching records for metadata modification\", columnVisibility, new Date(0), new Date(),\n-                            StringUtils.join(auths, ','), expiration, 2, -1, null, QueryPersistence.TRANSIENT, queryOptions.toString(), false));\n-            \n+            GenericResponse<String> createResponse = queryService.createQuery(logicName, QueryParametersImpl.paramsToMap(logicName, query.toString(), \"Query to find matching records for metadata modification\", columnVisibility, new Date(0), new Date(), StringUtils.join(auths, ','), expiration, 2, -1, null, QueryPersistence.TRANSIENT, queryOptions.toString(), false));\n             id = createResponse.getResult();\n+\n             BaseQueryResponse response = queryService.next(id);\n             if (response instanceof DefaultEventQueryResponse) {\n                 DefaultEventQueryResponse eResponse = (DefaultEventQueryResponse) response;\n                 if (eResponse.getEvents().size() > 1) {\n                     throw new IllegalStateException(\"More than one event matched \" + uuid + \" (\" + eResponse.getEvents().size() + \" matched)\");\n                 }\n+\n+\n                 if (eResponse.getEvents().isEmpty()) {\n                     throw new IllegalStateException(\"No event matched \" + uuid);\n                 }\n-                \n                 e = (DefaultEvent) eResponse.getEvents().get(0);\n             }\n         } catch (Exception ex) {\n@@ -936,9 +949,7 @@ public class MutableMetadataHandler extends ModificationServiceConfiguration {\n                 queryService.close(id);\n             }\n         }\n-        \n         return e;\n-        \n     }\n     \n     /**\n@@ -959,9 +970,16 @@ public class MutableMetadataHandler extends ModificationServiceConfiguration {\n      * @return An iterable of Keys\n      * @throws Exception\n      */\n-    protected FieldIndexIterable getFieldIndexKeys(AccumuloClient client, String shardTable, Set<Authorizations> userAuths, String shardId, String datatype,\n-                    String eventUid, String fieldName, String fieldValue, Set<Type<?>> dataTypes, boolean includeTokens) throws Exception {\n-        \n+\n+    protected FieldIndexIterable getFieldIndexKeys(AccumuloClient client,\n+        String shardTable,\n+            Set<Authorizations> userAuths,\n+                String shardId,\n+                    String datatype,\n+                        String eventUid,\n+                            String fieldName,\n+                                String fieldValue,\n+                                    Set<Type<?>> dataTypes, boolean includeTokens) throws Exception {\n         List<Range> ranges = new ArrayList();\n         fieldName = stripGrouping(fieldName);\n         if (includeTokens) {\n@@ -971,6 +989,8 @@ public class MutableMetadataHandler extends ModificationServiceConfiguration {\n             if (this.indexOnlyMap != null) {\n                 fields.addAll(this.indexOnlyMap.get(fieldName));\n             }\n+\n+\n             if (this.indexOnlySuffixes != null) {\n                 for (String suffix : indexOnlySuffixes) {\n                     fields.add(fieldName + suffix);\n@@ -993,38 +1013,39 @@ public class MutableMetadataHandler extends ModificationServiceConfiguration {\n         }\n         return new FieldIndexIterable(client, shardTable, eventUid, datatype, userAuths, ranges);\n     }\n-    \n+\n     protected static class FieldIndexIterable implements Iterable<Key>, AutoCloseable {\n         private BatchScanner scanner;\n-        \n-        public FieldIndexIterable(AccumuloClient client, String shardTable, String eventUid, String datatype, Set<Authorizations> userAuths, List<Range> ranges)\n-                        throws TableNotFoundException {\n+\n+        public FieldIndexIterable(AccumuloClient client, String shardTable, String eventUid, String datatype, Set<Authorizations> userAuths, List<Range> ranges) throws TableNotFoundException {\n             scanner = ScannerHelper.createBatchScanner(client, shardTable, userAuths, ranges.size());\n             scanner.setRanges(ranges);\n+\n             Map<String,String> options = new HashMap();\n             options.put(FieldIndexDocumentFilter.DATA_TYPE_OPT, datatype);\n             options.put(FieldIndexDocumentFilter.EVENT_UID_OPT, eventUid);\n+\n             IteratorSetting settings = new IteratorSetting(100, FieldIndexDocumentFilter.class, options);\n             scanner.addScanIterator(settings);\n         }\n-        \n+\n         @Override\n         public Iterator<Key> iterator() {\n             return Iterators.transform(scanner.iterator(), new Function<Entry<Key,Value>,Key>() {\n-                @Nullable\n-                @Override\n-                public Key apply(@Nullable Entry<Key,Value> keyValueEntry) {\n-                    return keyValueEntry.getKey();\n-                }\n-            });\n+                                           @Nullable\n+                                           @Override\n+                                           public Key apply(@Nullable Entry<Key,Value> keyValueEntry) {\n+                                               return keyValueEntry.getKey();\n+                                           }\n+                   });\n         }\n-        \n+\n         @Override\n         public void close() throws Exception {\n             scanner.close();\n         }\n     }\n-    \n+\n     private String stripGrouping(String fieldName) {\n         int index = fieldName.indexOf('.');\n         if (index >= 0) {\n@@ -1046,39 +1067,36 @@ public class MutableMetadataHandler extends ModificationServiceConfiguration {\n      * @return An iterable of Keys\n      * @throws Exception\n      */\n-    protected ContentIterable getContentKeys(AccumuloClient client, String shardTable, Set<Authorizations> userAuths, String shardId, String datatype,\n-                    String eventUid) throws Exception {\n-        \n+\n+    protected ContentIterable getContentKeys(AccumuloClient client, String shardTable, Set<Authorizations> userAuths, String shardId, String datatype, String eventUid) throws Exception {\n         Key startKey = new Key(shardId, \"d\", datatype + NULL_BYTE + eventUid + NULL_BYTE);\n         Key endKey = new Key(shardId, \"d\", datatype + NULL_BYTE + eventUid + NULL_BYTE + MAX_CHAR);\n         Range range = new Range(startKey, true, endKey, false);\n         return new ContentIterable(client, shardTable, eventUid, datatype, userAuths, range);\n     }\n-    \n+\n     protected static class ContentIterable implements Iterable<Key>, AutoCloseable {\n         private Scanner scanner;\n-        \n-        public ContentIterable(AccumuloClient client, String shardTable, String eventUid, String datatype, Set<Authorizations> userAuths, Range range)\n-                        throws TableNotFoundException {\n+\n+        public ContentIterable(AccumuloClient client, String shardTable, String eventUid, String datatype, Set<Authorizations> userAuths, Range range) throws TableNotFoundException {\n             scanner = ScannerHelper.createScanner(client, shardTable, userAuths);\n             scanner.setRange(range);\n         }\n-        \n+\n         @Override\n         public Iterator<Key> iterator() {\n             return Iterators.transform(scanner.iterator(), new Function<Entry<Key,Value>,Key>() {\n-                @Nullable\n-                @Override\n-                public Key apply(@Nullable Entry<Key,Value> keyValueEntry) {\n-                    return keyValueEntry.getKey();\n-                }\n-            });\n+                                           @Nullable\n+                                           @Override\n+                                           public Key apply(@Nullable Entry<Key,Value> keyValueEntry) {\n+                                               return keyValueEntry.getKey();\n+                                           }\n+                   });\n         }\n-        \n+\n         @Override\n         public void close() throws Exception {\n             scanner.close();\n         }\n     }\n-    \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 250
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "62",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "62",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ],
    "repaired_by": [],
    "not_repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}