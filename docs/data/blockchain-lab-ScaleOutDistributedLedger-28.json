{
    "project_name": "blockchain-lab-ScaleOutDistributedLedger",
    "error_id": "28",
    "information": {
        "errors": [
            {
                "line": "226",
                "column": "41",
                "severity": "warning",
                "message": "'{' is not preceded with whitespace.",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
            }
        ]
    },
    "source_code": "\n\t\tBlock other = (Block) obj;\n\t\tif (this.number != other.number){\n\t\t\tSystem.out.println(\"HEREEQUALS2\");\n\t\t\treturn false;\n\t\t}",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/blockchain-lab-ScaleOutDistributedLedger/errored/1/28/Block.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/blockchain-lab-ScaleOutDistributedLedger/styler/28/Block.java\nindex ec71cdd9eb8..879104be160 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/blockchain-lab-ScaleOutDistributedLedger/errored/1/28/Block.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/blockchain-lab-ScaleOutDistributedLedger/styler/28/Block.java\n@@ -223,7 +223,7 @@ public class Block {\n \t\t}\n \n \t\tBlock other = (Block) obj;\n-\t\tif (this.number != other.number){\n+\t\tif (this.number != other.number) {\n \t\t\tSystem.out.println(\"HEREEQUALS2\");\n \t\t\treturn false;\n \t\t}\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/blockchain-lab-ScaleOutDistributedLedger/errored/1/28/Block.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/blockchain-lab-ScaleOutDistributedLedger/intellij/28/Block.java\nindex ec71cdd9eb8..8774736b495 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/blockchain-lab-ScaleOutDistributedLedger/errored/1/28/Block.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/blockchain-lab-ScaleOutDistributedLedger/intellij/28/Block.java\n@@ -20,306 +20,327 @@ import java.util.logging.Level;\n  */\n public class Block {\n \n-\tpublic static final int GENESIS_BLOCK_NUMBER = 0;\n-\t\n-\t@Getter\n-\tprivate final int number;\n-\n-\t@Getter\n-\tprivate final Block previousBlock;\n-\n-\t@Getter @Setter\n-\tprivate Node owner;\n-\n-\t@Getter\n-\tprivate final List<Transaction> transactions;\n-\n-\t// Custom getter\n-\tprivate Sha256Hash hash;\n-\t\n-\tprivate transient boolean onMainChain;\n-\tprivate transient boolean hasNoAbstract;\n-\tprivate transient volatile boolean finalized;\n-\n-\t/**\n-\t * Constructor for a (genesis) block.\n-\t * @param number - the number of this block.\n-\t * @param owner - the owner of this block.\n-\t * @param transactions - a list of transactions of this block.\n-\t */\n-\tpublic Block(int number, Node owner, List<Transaction> transactions) {\n-\t\tthis.number = number;\n-\t\tthis.owner = owner;\n-\t\tthis.previousBlock = null;\n-\t\tthis.transactions = transactions;\n-\t\tfor (Transaction transaction : this.transactions) {\n-\t\t\ttransaction.setBlockNumber(number);\n-\t\t}\n-\t}\n-\t\n-\t/**\n-\t * Constructor for an empty block.\n-\t * @param previousBlock - reference to the previous block in the chain of this block.\n-\t * @param owner         - the owner\n-\t */\n-\tpublic Block(Block previousBlock, Node owner) {\n-\t\tthis.number = previousBlock.getNumber() + 1;\n-\t\tthis.previousBlock = previousBlock;\n-\t\tthis.owner = owner;\n-\t\tthis.transactions = new ArrayList<>();\n-\t\t\n-\t\t//Our own blocks are guaranteed to have no abstract until we create the abstract.\n-\t\tif (this.owner instanceof OwnNode) {\n-\t\t\tthis.hasNoAbstract = true;\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Constructor to decode a block message.\n-\t * @param blockMessage - block message from network.\n-\t * @param encodedChainUpdates - received chain of updates\n-\t * @param decodedChainUpdates - current decoded chain of updates\n-\t * @param localStore - local store.\n-\t * @throws IOException - error while getting node from tracker.\n-\t */\n-\tpublic Block(BlockMessage blockMessage, Map<Integer, List<BlockMessage>> encodedChainUpdates,\n-\t\t\tMap<Node, List<Block>> decodedChainUpdates, LocalStore localStore) throws IOException {\n-\t\tthis.number = blockMessage.getNumber();\n-\t\t// It's a genesis block\n-\t\tif (blockMessage.getOwnerId() == Transaction.GENESIS_SENDER) {\n-\t\t\tthis.owner = null;\n-\t\t} else {\n-\t\t\tthis.owner = localStore.getNode(blockMessage.getOwnerId());\n-\t\t}\n-\t\t\n-\t\tif (blockMessage.getPreviousBlockNumber() != -1) {\n-\t\t\t// Check if we have it in the local store\n-\t\t\tif (this.owner.getChain().getLastBlock().getNumber() < blockMessage.getPreviousBlockNumber()) {\n-\t\t\t\t// We don't have it (it should be in the received chain of updates)\n-\t\t\t\tint currentBlockIndex = encodedChainUpdates.get(this.owner.getId()).indexOf(blockMessage);\n-\t\t\t\tBlockMessage previousBlockMesssage = encodedChainUpdates.get(this.owner.getId()).get(currentBlockIndex - 1);\n-\t\t\t\t// Get decoded block list from the owner\n-\t\t\t\tBlock previousBlockLocal = new Block(previousBlockMesssage, encodedChainUpdates, decodedChainUpdates, localStore);\n-\t\t\t\tif (decodedChainUpdates.containsKey(this.owner)) {\n-\t\t\t\t\tdecodedChainUpdates.get(this.owner).add(previousBlockLocal);\n-\t\t\t\t} else {\n-\t\t\t\t\tList<Block> currentDecodedBlockList = new ArrayList<>();\n-\t\t\t\t\tcurrentDecodedBlockList.add(previousBlockLocal);\n-\t\t\t\t\tdecodedChainUpdates.put(this.owner, currentDecodedBlockList);\n-\t\t\t\t}\n-\t\t\t\tthis.previousBlock = previousBlockLocal;\n-\t\t\t} else {\n-\t\t\t\t// We have it (we infer it's the lastBlock from the chain)\n-\t\t\t\tthis.previousBlock = this.owner.getChain().getLastBlock();\n-\t\t\t}\n-\t\t} else {\n-\t\t\t// It's a genesis block\n-\t\t\tthis.previousBlock = null;\n-\t\t}\n-\t\t\n-\t\t// Convert TransactionMessage to Transaction\n-\t\tthis.transactions = new ArrayList<>();\n-\t\tfor (TransactionMessage transactionMessage : blockMessage.getTransactions()) {\n-\t\t\tthis.transactions.add(new Transaction(transactionMessage, encodedChainUpdates, decodedChainUpdates, localStore));\n-\t\t}\n-\t\t//TODO Do we want to send the hash along?\n-\t\tthis.hash = blockMessage.getHash();\n-\t}\n-\t\n-\t/**\n-\t * Adds the given transaction to this block and sets its block number.\n-\t * @param transaction - the transaction to add\n-\t * @throws IllegalStateException - If this block has already been committed.\n-\t */\n-\tpublic synchronized void addTransaction(Transaction transaction) {\n-\t\tif (finalized) {\n-\t\t\tthrow new IllegalStateException(\"You cannot add transactions to a block that is already committed.\");\n-\t\t}\n-\t\t\n-\t\ttransactions.add(transaction);\n-\t\ttransaction.setBlockNumber(this.getNumber());\n-\t}\n-\t\n-\t/**\n-\t * Get hash of the block.\n-\t * @return Hash SHA256\n-\t */\n-\tpublic synchronized Sha256Hash getHash() {\n-\t\tif (this.hash == null) {\n-\t\t\tthis.hash = this.calculateHash();\n-\t\t}\n-\t\treturn this.hash;\n-\t}\n-\n-\t/**\n-\t * Calculate the abstract of the block.\n-\t * @return abstract of the block\n-\t * @throws IllegalStateException - something went wrong while signing the block\n-\t */\n-\tpublic BlockAbstract calculateBlockAbstract() {\n-\t\tif (!(this.owner instanceof OwnNode)) {\n-\t\t\tthrow new UnsupportedOperationException(\"You cannot calculate the block abstract of a block you do not own!\");\n-\t\t}\n-\t\t\n-\t\t// Convert attributes of abstract into an array of bytes, for the signature\n-\t\t// Important to keep the order of writings\n-\t\tbyte[] attrInBytes;\n-\t\ttry (ByteArrayOutputStream outputStream = new ByteArrayOutputStream()) {\n-\t\t\toutputStream.write(Utils.intToByteArray(this.owner.getId()));\n-\t\t\toutputStream.write(Utils.intToByteArray(this.number));\n-\t\t\toutputStream.write(this.getHash().getBytes());\n-\t\t\tattrInBytes = outputStream.toByteArray();\n-\t\t} catch (IOException ex) {\n-\t\t\tthrow new IllegalStateException(\"Unable to write to outputstream\", ex);\n-\t\t}\n-\n-\t\t// Sign the attributes\n-\t\ttry {\n-\t\t\tbyte[] signature = ((OwnNode) this.owner).sign(attrInBytes);\n-\t\t\tBlockAbstract blockAbstract = new BlockAbstract(this.owner.getId(), this.number, this.getHash(), signature);\n-\t\t\tthis.hasNoAbstract = false;\n-\t\t\treturn blockAbstract;\n-\t\t} catch (Exception ex) {\n-\t\t\tthrow new IllegalStateException(\"Unable to sign block abstract\", ex);\n-\t\t}\n-\t}\n-\t\n-\t/**\n-\t * Commits this block to the main chain.\n-\t * @param localStore - the local store\n-\t */\n-\tpublic synchronized void commit(LocalStore localStore) {\n-\t\tif (finalized) {\n-\t\t\tthrow new IllegalStateException(\"This block has already been committed!\");\n-\t\t}\n-\t\t\n-\t\tChain chain = getOwner().getChain();\n-\t\tsynchronized (chain) {\n-\t\t\tBlockAbstract blockAbstract = calculateBlockAbstract();\n-\t\t\tlocalStore.getApplication().getMainChain().commitAbstract(blockAbstract);\n-\t\t\tgetOwner().getChain().setLastCommittedBlock(this);\n-\t\t}\n-\t\t\n-\t\tfinalized = true;\n-\t}\n-\n-\t@Override\n-\tpublic int hashCode() {\n-\t\tfinal int prime = 31;\n-\t\tint result = 1;\n-\t\tresult = prime * result + number;\n-\t\tresult = prime * result + (owner == null ? 0 : owner.hashCode());\n-\t\treturn result;\n-\t}\n-\n-\t@Override\n-\tpublic boolean equals(Object obj) {\n-\t\tif (this == obj) return true;\n-\t\tif (!(obj instanceof Block)) {\n-\t\t\tSystem.out.println(\"HEREEQUALS1\");\n-\t\t\tSystem.out.println(this);\n-\t\t\tSystem.out.println(obj);\n-\t\t\treturn false;\n-\t\t}\n-\n-\t\tBlock other = (Block) obj;\n-\t\tif (this.number != other.number){\n-\t\t\tSystem.out.println(\"HEREEQUALS2\");\n-\t\t\treturn false;\n-\t\t}\n-\t\tif (this.owner == null) {\n-\t\t\tif (other.owner != null) {\n-\t\t\t\tSystem.out.println(\"HEREEQUALS3\");\n-\t\t\t\treturn false;\n-\t\t\t}\n-\t\t} else if (other.owner == null || this.owner.getId() != other.owner.getId()) {\n-\t\t\tSystem.out.println(\"HEREEQUALS4\");\n-\t\t\treturn false;\n-\t\t}\n-\t\tif (this.previousBlock == null) {\n-\t\t\tif (other.previousBlock != null) {\n-\t\t\t\tSystem.out.println(\"HEREEQUALS5\");\n-\t\t\t\treturn false;\n-\t\t\t}\n-\t\t} else if (!this.previousBlock.equals(other.previousBlock)) {\n-\t\t\tSystem.out.println(\"HEREEQUALS6\");\n-\t\t\treturn false;\n-\t\t}\n-\n-\t\treturn this.transactions.equals(other.transactions);\n-\t}\n-\t\n-\t@Override\n-\tpublic String toString() {\n-\t\treturn \"Block<\" + number + \", \" + owner + \">\";\n-\t}\n-\n-\t/**\n-\t * Calculates the block hash.\n-\t * @return Hash SHA256\n-\t */\n-\tprivate Sha256Hash calculateHash() {\n-\t\t// Convert attributes of block into an array of bytes\n-\t\tByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n-\t\ttry {\n-\t\t\t// Important to keep the order of writings\n-\t\t\toutputStream.write(Utils.intToByteArray(this.number));\n-\t\t\tbyte[] prevBlockHash = (this.previousBlock != null) ? this.previousBlock.getHash().getBytes() : new byte[0];\n-\t\t\toutputStream.write(prevBlockHash);\n-\t\t\tif (this.owner != null) {\n-\t\t\t\toutputStream.write(Utils.intToByteArray(this.owner.getId()));\n-\t\t\t}\n-\t\t\tfor (Transaction tx : this.transactions) {\n-\t\t\t\toutputStream.write(tx.getHash().getBytes());\n-\t\t\t}\n-\t\t} catch (IOException ex) {\n-\t\t\tLog.log(Level.SEVERE, null, ex);\n-\t\t}\n-\t\tbyte[] blockInBytes = outputStream.toByteArray();\n-\n-\t\treturn new Sha256Hash(blockInBytes);\n-\t}\n-\n-\t/**\n-\t * Creates a copy of this genesis block.\n-\t * @return - a deep copy of this block and transactions\n-\t * @throws UnsupportedOperationException - If this block is not a genesis block.\n-\t */\n-\tpublic Block genesisCopy() {\n-\t\tif (this.number != GENESIS_BLOCK_NUMBER) throw new UnsupportedOperationException(\"You can only copy genesis blocks\");\n-\t\t\n-\t\tArrayList<Transaction> transactionsCopy = new ArrayList<>();\n-\t\tfor (Transaction transaction : transactions) {\n-\t\t\ttransactionsCopy.add(transaction.genesisCopy());\n-\t\t}\n-\t\tBlock block = new Block(this.number, this.owner, transactionsCopy);\n-\t\t\n-\t\tblock.onMainChain = true;\n-\t\treturn block;\n-\t}\n-\t\n-\t/**\n-\t * Returns if an abstract of this block is present on the main chain.\n-\t * @param localStore - the local store\n-\t * @return - boolean identifying if an abstract of this block is on the main chain.\n-\t */\n-\tpublic boolean isOnMainChain(LocalStore localStore) {\n-\t\t//TODO Remove hack?\n-\t\tif (this.number == GENESIS_BLOCK_NUMBER) return true;\n-\t\t\n-\t\t//Definitely has no abstract\n-\t\tif (this.hasNoAbstract) return false;\n-\t\t\n-\t\t//We already determined before what the result should be\n-\t\tif (this.onMainChain) return true;\n-\t\t\n-\t\t//It is present, so store it and return\n-\t\tif (localStore.getMainChain().isPresent(this.getHash())) {\n-\t\t\tthis.onMainChain = true;\n-\t\t\treturn true;\n-\t\t}\n-\t\t\n-\t\t//Not present (yet)\n-\t\treturn false;\n-\t}\n+    public static final int GENESIS_BLOCK_NUMBER = 0;\n+\n+    @Getter\n+    private final int number;\n+\n+    @Getter\n+    private final Block previousBlock;\n+\n+    @Getter\n+    @Setter\n+    private Node owner;\n+\n+    @Getter\n+    private final List<Transaction> transactions;\n+\n+    // Custom getter\n+    private Sha256Hash hash;\n+\n+    private transient boolean onMainChain;\n+    private transient boolean hasNoAbstract;\n+    private transient volatile boolean finalized;\n+\n+    /**\n+     * Constructor for a (genesis) block.\n+     *\n+     * @param number       - the number of this block.\n+     * @param owner        - the owner of this block.\n+     * @param transactions - a list of transactions of this block.\n+     */\n+    public Block(int number, Node owner, List<Transaction> transactions) {\n+        this.number = number;\n+        this.owner = owner;\n+        this.previousBlock = null;\n+        this.transactions = transactions;\n+        for (Transaction transaction : this.transactions) {\n+            transaction.setBlockNumber(number);\n+        }\n+    }\n+\n+    /**\n+     * Constructor for an empty block.\n+     *\n+     * @param previousBlock - reference to the previous block in the chain of this block.\n+     * @param owner         - the owner\n+     */\n+    public Block(Block previousBlock, Node owner) {\n+        this.number = previousBlock.getNumber() + 1;\n+        this.previousBlock = previousBlock;\n+        this.owner = owner;\n+        this.transactions = new ArrayList<>();\n+\n+        //Our own blocks are guaranteed to have no abstract until we create the abstract.\n+        if (this.owner instanceof OwnNode) {\n+            this.hasNoAbstract = true;\n+        }\n+    }\n+\n+    /**\n+     * Constructor to decode a block message.\n+     *\n+     * @param blockMessage        - block message from network.\n+     * @param encodedChainUpdates - received chain of updates\n+     * @param decodedChainUpdates - current decoded chain of updates\n+     * @param localStore          - local store.\n+     * @throws IOException - error while getting node from tracker.\n+     */\n+    public Block(BlockMessage blockMessage, Map<Integer, List<BlockMessage>> encodedChainUpdates,\n+                 Map<Node, List<Block>> decodedChainUpdates, LocalStore localStore) throws IOException {\n+        this.number = blockMessage.getNumber();\n+        // It's a genesis block\n+        if (blockMessage.getOwnerId() == Transaction.GENESIS_SENDER) {\n+            this.owner = null;\n+        } else {\n+            this.owner = localStore.getNode(blockMessage.getOwnerId());\n+        }\n+\n+        if (blockMessage.getPreviousBlockNumber() != -1) {\n+            // Check if we have it in the local store\n+            if (this.owner.getChain().getLastBlock().getNumber() < blockMessage.getPreviousBlockNumber()) {\n+                // We don't have it (it should be in the received chain of updates)\n+                int currentBlockIndex = encodedChainUpdates.get(this.owner.getId()).indexOf(blockMessage);\n+                BlockMessage previousBlockMesssage = encodedChainUpdates.get(this.owner.getId()).get(currentBlockIndex - 1);\n+                // Get decoded block list from the owner\n+                Block previousBlockLocal = new Block(previousBlockMesssage, encodedChainUpdates, decodedChainUpdates, localStore);\n+                if (decodedChainUpdates.containsKey(this.owner)) {\n+                    decodedChainUpdates.get(this.owner).add(previousBlockLocal);\n+                } else {\n+                    List<Block> currentDecodedBlockList = new ArrayList<>();\n+                    currentDecodedBlockList.add(previousBlockLocal);\n+                    decodedChainUpdates.put(this.owner, currentDecodedBlockList);\n+                }\n+                this.previousBlock = previousBlockLocal;\n+            } else {\n+                // We have it (we infer it's the lastBlock from the chain)\n+                this.previousBlock = this.owner.getChain().getLastBlock();\n+            }\n+        } else {\n+            // It's a genesis block\n+            this.previousBlock = null;\n+        }\n+\n+        // Convert TransactionMessage to Transaction\n+        this.transactions = new ArrayList<>();\n+        for (TransactionMessage transactionMessage : blockMessage.getTransactions()) {\n+            this.transactions.add(new Transaction(transactionMessage, encodedChainUpdates, decodedChainUpdates, localStore));\n+        }\n+        //TODO Do we want to send the hash along?\n+        this.hash = blockMessage.getHash();\n+    }\n+\n+    /**\n+     * Adds the given transaction to this block and sets its block number.\n+     *\n+     * @param transaction - the transaction to add\n+     * @throws IllegalStateException - If this block has already been committed.\n+     */\n+    public synchronized void addTransaction(Transaction transaction) {\n+        if (finalized) {\n+            throw new IllegalStateException(\"You cannot add transactions to a block that is already committed.\");\n+        }\n+\n+        transactions.add(transaction);\n+        transaction.setBlockNumber(this.getNumber());\n+    }\n+\n+    /**\n+     * Get hash of the block.\n+     *\n+     * @return Hash SHA256\n+     */\n+    public synchronized Sha256Hash getHash() {\n+        if (this.hash == null) {\n+            this.hash = this.calculateHash();\n+        }\n+        return this.hash;\n+    }\n+\n+    /**\n+     * Calculate the abstract of the block.\n+     *\n+     * @return abstract of the block\n+     * @throws IllegalStateException - something went wrong while signing the block\n+     */\n+    public BlockAbstract calculateBlockAbstract() {\n+        if (!(this.owner instanceof OwnNode)) {\n+            throw new UnsupportedOperationException(\"You cannot calculate the block abstract of a block you do not own!\");\n+        }\n+\n+        // Convert attributes of abstract into an array of bytes, for the signature\n+        // Important to keep the order of writings\n+        byte[] attrInBytes;\n+        try (ByteArrayOutputStream outputStream = new ByteArrayOutputStream()) {\n+            outputStream.write(Utils.intToByteArray(this.owner.getId()));\n+            outputStream.write(Utils.intToByteArray(this.number));\n+            outputStream.write(this.getHash().getBytes());\n+            attrInBytes = outputStream.toByteArray();\n+        } catch (IOException ex) {\n+            throw new IllegalStateException(\"Unable to write to outputstream\", ex);\n+        }\n+\n+        // Sign the attributes\n+        try {\n+            byte[] signature = ((OwnNode) this.owner).sign(attrInBytes);\n+            BlockAbstract blockAbstract = new BlockAbstract(this.owner.getId(), this.number, this.getHash(), signature);\n+            this.hasNoAbstract = false;\n+            return blockAbstract;\n+        } catch (Exception ex) {\n+            throw new IllegalStateException(\"Unable to sign block abstract\", ex);\n+        }\n+    }\n+\n+    /**\n+     * Commits this block to the main chain.\n+     *\n+     * @param localStore - the local store\n+     */\n+    public synchronized void commit(LocalStore localStore) {\n+        if (finalized) {\n+            throw new IllegalStateException(\"This block has already been committed!\");\n+        }\n+\n+        Chain chain = getOwner().getChain();\n+        synchronized (chain) {\n+            BlockAbstract blockAbstract = calculateBlockAbstract();\n+            localStore.getApplication().getMainChain().commitAbstract(blockAbstract);\n+            getOwner().getChain().setLastCommittedBlock(this);\n+        }\n+\n+        finalized = true;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        final int prime = 31;\n+        int result = 1;\n+        result = prime * result + number;\n+        result = prime * result + (owner == null ? 0 : owner.hashCode());\n+        return result;\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if (!(obj instanceof Block)) {\n+            System.out.println(\"HEREEQUALS1\");\n+            System.out.println(this);\n+            System.out.println(obj);\n+            return false;\n+        }\n+\n+        Block other = (Block) obj;\n+        if (this.number != other.number) {\n+            System.out.println(\"HEREEQUALS2\");\n+            return false;\n+        }\n+        if (this.owner == null) {\n+            if (other.owner != null) {\n+                System.out.println(\"HEREEQUALS3\");\n+                return false;\n+            }\n+        } else if (other.owner == null || this.owner.getId() != other.owner.getId()) {\n+            System.out.println(\"HEREEQUALS4\");\n+            return false;\n+        }\n+        if (this.previousBlock == null) {\n+            if (other.previousBlock != null) {\n+                System.out.println(\"HEREEQUALS5\");\n+                return false;\n+            }\n+        } else if (!this.previousBlock.equals(other.previousBlock)) {\n+            System.out.println(\"HEREEQUALS6\");\n+            return false;\n+        }\n+\n+        return this.transactions.equals(other.transactions);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"Block<\" + number + \", \" + owner + \">\";\n+    }\n+\n+    /**\n+     * Calculates the block hash.\n+     *\n+     * @return Hash SHA256\n+     */\n+    private Sha256Hash calculateHash() {\n+        // Convert attributes of block into an array of bytes\n+        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n+        try {\n+            // Important to keep the order of writings\n+            outputStream.write(Utils.intToByteArray(this.number));\n+            byte[] prevBlockHash = (this.previousBlock != null) ? this.previousBlock.getHash().getBytes() : new byte[0];\n+            outputStream.write(prevBlockHash);\n+            if (this.owner != null) {\n+                outputStream.write(Utils.intToByteArray(this.owner.getId()));\n+            }\n+            for (Transaction tx : this.transactions) {\n+                outputStream.write(tx.getHash().getBytes());\n+            }\n+        } catch (IOException ex) {\n+            Log.log(Level.SEVERE, null, ex);\n+        }\n+        byte[] blockInBytes = outputStream.toByteArray();\n+\n+        return new Sha256Hash(blockInBytes);\n+    }\n+\n+    /**\n+     * Creates a copy of this genesis block.\n+     *\n+     * @return - a deep copy of this block and transactions\n+     * @throws UnsupportedOperationException - If this block is not a genesis block.\n+     */\n+    public Block genesisCopy() {\n+        if (this.number != GENESIS_BLOCK_NUMBER) {\n+            throw new UnsupportedOperationException(\"You can only copy genesis blocks\");\n+        }\n+\n+        ArrayList<Transaction> transactionsCopy = new ArrayList<>();\n+        for (Transaction transaction : transactions) {\n+            transactionsCopy.add(transaction.genesisCopy());\n+        }\n+        Block block = new Block(this.number, this.owner, transactionsCopy);\n+\n+        block.onMainChain = true;\n+        return block;\n+    }\n+\n+    /**\n+     * Returns if an abstract of this block is present on the main chain.\n+     *\n+     * @param localStore - the local store\n+     * @return - boolean identifying if an abstract of this block is on the main chain.\n+     */\n+    public boolean isOnMainChain(LocalStore localStore) {\n+        //TODO Remove hack?\n+        if (this.number == GENESIS_BLOCK_NUMBER) {\n+            return true;\n+        }\n+\n+        //Definitely has no abstract\n+        if (this.hasNoAbstract) {\n+            return false;\n+        }\n+\n+        //We already determined before what the result should be\n+        if (this.onMainChain) {\n+            return true;\n+        }\n+\n+        //It is present, so store it and return\n+        if (localStore.getMainChain().isPresent(this.getHash())) {\n+            this.onMainChain = true;\n+            return true;\n+        }\n+\n+        //Not present (yet)\n+        return false;\n+    }\n }\n",
            "diff_size": 323
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/blockchain-lab-ScaleOutDistributedLedger/errored/1/28/Block.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/blockchain-lab-ScaleOutDistributedLedger/styler_random/28/Block.java\nindex ec71cdd9eb8..879104be160 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/blockchain-lab-ScaleOutDistributedLedger/errored/1/28/Block.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/blockchain-lab-ScaleOutDistributedLedger/styler_random/28/Block.java\n@@ -223,7 +223,7 @@ public class Block {\n \t\t}\n \n \t\tBlock other = (Block) obj;\n-\t\tif (this.number != other.number){\n+\t\tif (this.number != other.number) {\n \t\t\tSystem.out.println(\"HEREEQUALS2\");\n \t\t\treturn false;\n \t\t}\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/blockchain-lab-ScaleOutDistributedLedger/errored/1/28/Block.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/blockchain-lab-ScaleOutDistributedLedger/styler_three_grams/28/Block.java\nindex ec71cdd9eb8..879104be160 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/blockchain-lab-ScaleOutDistributedLedger/errored/1/28/Block.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/blockchain-lab-ScaleOutDistributedLedger/styler_three_grams/28/Block.java\n@@ -223,7 +223,7 @@ public class Block {\n \t\t}\n \n \t\tBlock other = (Block) obj;\n-\t\tif (this.number != other.number){\n+\t\tif (this.number != other.number) {\n \t\t\tSystem.out.println(\"HEREEQUALS2\");\n \t\t\treturn false;\n \t\t}\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "naturalize",
        "codebuff"
    ]
}