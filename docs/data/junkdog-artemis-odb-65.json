{
    "project_name": "junkdog-artemis-odb",
    "error_id": "65",
    "information": {
        "errors": [
            {
                "line": "24",
                "severity": "error",
                "message": "Line is longer than 105 characters (found 110).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": " * Within {@link #processExpired(int) processExpired(Entity e)}\n * you must call {@link #offerDelay(float) offerDelay(float delay)} if the\n * entity's delay time is renewed. That method is also called by {@link #inserted(int) inserted(int entityId)}\n * for each newly matched entity.\n * </p><p>\n *",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "24",
                    "severity": "error",
                    "message": "Line is longer than 105 characters (found 110).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "24",
                    "severity": "error",
                    "message": "Line is longer than 105 characters (found 110).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/junkdog-artemis-odb/errored/1/65/DelayedIteratingSystem.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/junkdog-artemis-odb/intellij/65/DelayedIteratingSystem.java\nindex 215cdb6e908..4abd2948d80 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/junkdog-artemis-odb/errored/1/65/DelayedIteratingSystem.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/junkdog-artemis-odb/intellij/65/DelayedIteratingSystem.java\n@@ -29,168 +29,168 @@ import com.artemis.utils.IntBag;\n  */\n public abstract class DelayedIteratingSystem extends BaseEntitySystem {\n \n-\t/** The time until an entity should be processed. */\n-\tprivate float delay;\n-\t/**\tIf the system is running and counting down delays. */\n-\tprivate boolean running;\n-\t/** The countdown, accumulates world deltas. */\n-\tprivate float acc;\n-\n-\t/**\n-\t * Creates a new DelayedEntityProcessingSystem.\n-\t *\n-\t * @param aspect\n-\t *\t\t\tthe aspect to match against entities\n-\t */\n-\tpublic DelayedIteratingSystem(Aspect.Builder aspect) {\n-\t\tsuper(aspect);\n-\t}\n-\n-\t@Override\n-\tprotected final void processSystem() {\n-\t\tIntBag entities = subscription.getEntities();\n-\t\tint processed = entities.size();\n-\t\tif (processed == 0) {\n-\t\t\tstop();\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tdelay = Float.MAX_VALUE;\n-\t\tint[] ids = entities.getData();\n-\t\tfor (int i = 0; processed > i; i++) {\n-\t\t\tint e = ids[i];\n-\t\t\tprocessDelta(e, acc);\n-\t\t\tfloat remaining = getRemainingDelay(e);\n-\t\t\tif(remaining <= 0) {\n-\t\t\t\tprocessExpired(e);\n-\t\t\t} else {\n-\t\t\t\tofferDelay(remaining);\n-\t\t\t}\n-\t\t}\n-\t\tacc = 0;\n-\t}\n-\n-\n-\t@Override\n-\tprotected void inserted(int entityId) {\n-\t\tfloat remainingDelay = getRemainingDelay(entityId);\n-\t\tprocessDelta(entityId, -acc);\n-\t\tif(remainingDelay > 0) {\n-\t\t\tofferDelay(remainingDelay);\n-\t\t}\n-\t}\n-\t\n-\t/**\n-\t * Return the delay until this entity should be processed.\n-\t * \n-\t * @param entityId\n-\t *\t\t\tentity\n-\t *\n-\t * @return delay\n-\t */\n-\tprotected abstract float getRemainingDelay(int entityId);\n-\n-\n-\t@Override\n-\tprotected final boolean checkProcessing() {\n-\t\tif (running) {\n-\t\t\tacc += getTimeDelta();\n-\t\t\treturn acc >= delay;\n-\t\t}\n-\t\treturn false;\n-\t}\n-\t\n-\t/**\n-\t * Overridable method to provide custom time delta.\n-\t */\n-\tprotected float getTimeDelta() {\n-\t\treturn world.getDelta();\n-\t}\n-\t\n-\t/**\n-\t * Process an entity this system is interested in.\n-\t * <p>\n-\t * Substract the accumulatedDelta from the entities defined delay.\n-\t * </p>\n-\t * \n-\t * @param entityId\n-\t *\t\t\tthe entity to process\n-\t * @param accumulatedDelta\n-\t *\t\t\tthe delta time since this system was last executed\n-\t */\n-\tprotected abstract void processDelta(int entityId, float accumulatedDelta);\n-\n-\n-\tprotected abstract void processExpired(int entityId);\n-\n-\t/**\n-\t * Restarts the system only if the delay offered is shorter than the time\n-\t * that the system is currently scheduled to execute at.\n-\t * <p>\n-\t * If the system is already stopped (not running) then the offered delay\n-\t * will be used to restart the system with no matter its value.\n-\t * </p><p>\n-\t * If the system is already counting down, and the offered delay is  larger\n-\t * than the time remaining, the system will ignore it. If the offered delay\n-\t * is shorter than the time remaining, the system will restart itself to\n-\t * run at the offered delay.\n-\t * </p>\n-\t *\n-\t * @param offeredDelay\n-\t *\t\t\tdelay to offer\n-\t */\n-\tpublic void offerDelay(float offeredDelay) {\n-\t\tif (!running) {\n-\t\t\trunning = true;\n-\t\t\tdelay = offeredDelay;\n-\t\t} else {\n-\t\t\tdelay = Math.min(delay, offeredDelay);\n-\t\t}\n-\t}\n-\t\n-\t/**\n-\t * Get the initial delay that the system was ordered to process entities\n-\t * after.\n-\t * \n-\t * @return the originally set delay\n-\t */\n-\tpublic float getInitialTimeDelay() {\n-\t\treturn delay;\n-\t}\n-\t\n-\t/**\n-\t * Get the time until the system is scheduled to run at.\n-\t * <p>\n-\t * Returns zero (0) if the system is not running.\n-\t * Use {@link #isRunning() isRunning()} before checking this value.\n-\t * </p>\n-\t *\n-\t * @return time when system will run at\n-\t */\n-\tpublic float getRemainingTimeUntilProcessing() {\n-\t\tif(running) {\n-\t\t\treturn delay-acc;\n-\t\t}\n-\t\treturn 0;\n-\t}\n-\t\n-\t/**\n-\t * Check if the system is counting down towards processing.\n-\t * \n-\t * @return {@code true} if it's counting down, false if it's not running\n-\t */\n-\tpublic boolean isRunning() {\n-\t\treturn running;\n-\t}\n-\t\n-\t/**\n-\t * Stops the system from running, aborts current countdown.\n-\t * <p>\n-\t * Call offerDelay or restart to run it again.\n-\t * </p>\n-\t */\n-\tpublic void stop() {\n-\t\tthis.running = false;\n-\t\tthis.acc = 0;\n-\t}\n+    /**\n+     * The time until an entity should be processed.\n+     */\n+    private float delay;\n+    /**\n+     * If the system is running and counting down delays.\n+     */\n+    private boolean running;\n+    /**\n+     * The countdown, accumulates world deltas.\n+     */\n+    private float acc;\n+\n+    /**\n+     * Creates a new DelayedEntityProcessingSystem.\n+     *\n+     * @param aspect the aspect to match against entities\n+     */\n+    public DelayedIteratingSystem(Aspect.Builder aspect) {\n+        super(aspect);\n+    }\n+\n+    @Override\n+    protected final void processSystem() {\n+        IntBag entities = subscription.getEntities();\n+        int processed = entities.size();\n+        if (processed == 0) {\n+            stop();\n+            return;\n+        }\n+\n+        delay = Float.MAX_VALUE;\n+        int[] ids = entities.getData();\n+        for (int i = 0; processed > i; i++) {\n+            int e = ids[i];\n+            processDelta(e, acc);\n+            float remaining = getRemainingDelay(e);\n+            if (remaining <= 0) {\n+                processExpired(e);\n+            } else {\n+                offerDelay(remaining);\n+            }\n+        }\n+        acc = 0;\n+    }\n+\n+\n+    @Override\n+    protected void inserted(int entityId) {\n+        float remainingDelay = getRemainingDelay(entityId);\n+        processDelta(entityId, -acc);\n+        if (remainingDelay > 0) {\n+            offerDelay(remainingDelay);\n+        }\n+    }\n+\n+    /**\n+     * Return the delay until this entity should be processed.\n+     *\n+     * @param entityId entity\n+     * @return delay\n+     */\n+    protected abstract float getRemainingDelay(int entityId);\n+\n+\n+    @Override\n+    protected final boolean checkProcessing() {\n+        if (running) {\n+            acc += getTimeDelta();\n+            return acc >= delay;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Overridable method to provide custom time delta.\n+     */\n+    protected float getTimeDelta() {\n+        return world.getDelta();\n+    }\n+\n+    /**\n+     * Process an entity this system is interested in.\n+     * <p>\n+     * Substract the accumulatedDelta from the entities defined delay.\n+     * </p>\n+     *\n+     * @param entityId         the entity to process\n+     * @param accumulatedDelta the delta time since this system was last executed\n+     */\n+    protected abstract void processDelta(int entityId, float accumulatedDelta);\n+\n+\n+    protected abstract void processExpired(int entityId);\n+\n+    /**\n+     * Restarts the system only if the delay offered is shorter than the time\n+     * that the system is currently scheduled to execute at.\n+     * <p>\n+     * If the system is already stopped (not running) then the offered delay\n+     * will be used to restart the system with no matter its value.\n+     * </p><p>\n+     * If the system is already counting down, and the offered delay is  larger\n+     * than the time remaining, the system will ignore it. If the offered delay\n+     * is shorter than the time remaining, the system will restart itself to\n+     * run at the offered delay.\n+     * </p>\n+     *\n+     * @param offeredDelay delay to offer\n+     */\n+    public void offerDelay(float offeredDelay) {\n+        if (!running) {\n+            running = true;\n+            delay = offeredDelay;\n+        } else {\n+            delay = Math.min(delay, offeredDelay);\n+        }\n+    }\n+\n+    /**\n+     * Get the initial delay that the system was ordered to process entities\n+     * after.\n+     *\n+     * @return the originally set delay\n+     */\n+    public float getInitialTimeDelay() {\n+        return delay;\n+    }\n+\n+    /**\n+     * Get the time until the system is scheduled to run at.\n+     * <p>\n+     * Returns zero (0) if the system is not running.\n+     * Use {@link #isRunning() isRunning()} before checking this value.\n+     * </p>\n+     *\n+     * @return time when system will run at\n+     */\n+    public float getRemainingTimeUntilProcessing() {\n+        if (running) {\n+            return delay - acc;\n+        }\n+        return 0;\n+    }\n+\n+    /**\n+     * Check if the system is counting down towards processing.\n+     *\n+     * @return {@code true} if it's counting down, false if it's not running\n+     */\n+    public boolean isRunning() {\n+        return running;\n+    }\n+\n+    /**\n+     * Stops the system from running, aborts current countdown.\n+     * <p>\n+     * Call offerDelay or restart to run it again.\n+     * </p>\n+     */\n+    public void stop() {\n+        this.running = false;\n+        this.acc = 0;\n+    }\n }\n",
            "diff_size": 164
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "24",
                    "severity": "error",
                    "message": "Line is longer than 105 characters (found 110).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/junkdog-artemis-odb/errored/1/65/DelayedIteratingSystem.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/junkdog-artemis-odb/naturalize/65/DelayedIteratingSystem.java\nindex 215cdb6e908..ddc71aec826 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/junkdog-artemis-odb/errored/1/65/DelayedIteratingSystem.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/junkdog-artemis-odb/naturalize/65/DelayedIteratingSystem.java\n@@ -88,7 +88,7 @@ public abstract class DelayedIteratingSystem extends BaseEntitySystem {\n \t *\n \t * @return delay\n \t */\n-\tprotected abstract float getRemainingDelay(int entityId);\n+\t\tprotected abstract float getRemainingDelay(int entityId);\n \n \n \t@Override\n@@ -103,7 +103,7 @@ public abstract class DelayedIteratingSystem extends BaseEntitySystem {\n \t/**\n \t * Overridable method to provide custom time delta.\n \t */\n-\tprotected float getTimeDelta() {\n+protected float getTimeDelta() {\n \t\treturn world.getDelta();\n \t}\n \t\n@@ -118,10 +118,9 @@ public abstract class DelayedIteratingSystem extends BaseEntitySystem {\n \t * @param accumulatedDelta\n \t *\t\t\tthe delta time since this system was last executed\n \t */\n-\tprotected abstract void processDelta(int entityId, float accumulatedDelta);\n+\t\tprotected abstract void processDelta(int entityId, float accumulatedDelta);\n \n-\n-\tprotected abstract void processExpired(int entityId);\n+protected abstract void processExpired(int entityId);\n \n \t/**\n \t * Restarts the system only if the delay offered is shorter than the time\n@@ -193,4 +192,4 @@ public abstract class DelayedIteratingSystem extends BaseEntitySystem {\n \t\tthis.running = false;\n \t\tthis.acc = 0;\n \t}\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 6
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "24",
                    "severity": "error",
                    "message": "Line is longer than 105 characters (found 110).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/junkdog-artemis-odb/errored/1/65/DelayedIteratingSystem.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/junkdog-artemis-odb/codebuff/65/DelayedIteratingSystem.java\nindex 215cdb6e908..d9af3e1ae29 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/junkdog-artemis-odb/errored/1/65/DelayedIteratingSystem.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/junkdog-artemis-odb/codebuff/65/DelayedIteratingSystem.java\n@@ -27,170 +27,187 @@ import com.artemis.utils.IntBag;\n  *\n  * @author Arni Arent\n  */\n+\n public abstract class DelayedIteratingSystem extends BaseEntitySystem {\n \n-\t/** The time until an entity should be processed. */\n-\tprivate float delay;\n-\t/**\tIf the system is running and counting down delays. */\n-\tprivate boolean running;\n-\t/** The countdown, accumulates world deltas. */\n-\tprivate float acc;\n-\n-\t/**\n-\t * Creates a new DelayedEntityProcessingSystem.\n-\t *\n-\t * @param aspect\n-\t *\t\t\tthe aspect to match against entities\n-\t */\n-\tpublic DelayedIteratingSystem(Aspect.Builder aspect) {\n-\t\tsuper(aspect);\n-\t}\n-\n-\t@Override\n-\tprotected final void processSystem() {\n-\t\tIntBag entities = subscription.getEntities();\n-\t\tint processed = entities.size();\n-\t\tif (processed == 0) {\n-\t\t\tstop();\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tdelay = Float.MAX_VALUE;\n-\t\tint[] ids = entities.getData();\n-\t\tfor (int i = 0; processed > i; i++) {\n-\t\t\tint e = ids[i];\n-\t\t\tprocessDelta(e, acc);\n-\t\t\tfloat remaining = getRemainingDelay(e);\n-\t\t\tif(remaining <= 0) {\n-\t\t\t\tprocessExpired(e);\n-\t\t\t} else {\n-\t\t\t\tofferDelay(remaining);\n-\t\t\t}\n-\t\t}\n-\t\tacc = 0;\n-\t}\n-\n-\n-\t@Override\n-\tprotected void inserted(int entityId) {\n-\t\tfloat remainingDelay = getRemainingDelay(entityId);\n-\t\tprocessDelta(entityId, -acc);\n-\t\tif(remainingDelay > 0) {\n-\t\t\tofferDelay(remainingDelay);\n-\t\t}\n-\t}\n-\t\n-\t/**\n-\t * Return the delay until this entity should be processed.\n-\t * \n-\t * @param entityId\n-\t *\t\t\tentity\n-\t *\n-\t * @return delay\n-\t */\n-\tprotected abstract float getRemainingDelay(int entityId);\n-\n-\n-\t@Override\n-\tprotected final boolean checkProcessing() {\n-\t\tif (running) {\n-\t\t\tacc += getTimeDelta();\n-\t\t\treturn acc >= delay;\n-\t\t}\n-\t\treturn false;\n-\t}\n-\t\n-\t/**\n-\t * Overridable method to provide custom time delta.\n-\t */\n-\tprotected float getTimeDelta() {\n-\t\treturn world.getDelta();\n-\t}\n-\t\n-\t/**\n-\t * Process an entity this system is interested in.\n-\t * <p>\n-\t * Substract the accumulatedDelta from the entities defined delay.\n-\t * </p>\n-\t * \n-\t * @param entityId\n-\t *\t\t\tthe entity to process\n-\t * @param accumulatedDelta\n-\t *\t\t\tthe delta time since this system was last executed\n-\t */\n-\tprotected abstract void processDelta(int entityId, float accumulatedDelta);\n-\n-\n-\tprotected abstract void processExpired(int entityId);\n-\n-\t/**\n-\t * Restarts the system only if the delay offered is shorter than the time\n-\t * that the system is currently scheduled to execute at.\n-\t * <p>\n-\t * If the system is already stopped (not running) then the offered delay\n-\t * will be used to restart the system with no matter its value.\n-\t * </p><p>\n-\t * If the system is already counting down, and the offered delay is  larger\n-\t * than the time remaining, the system will ignore it. If the offered delay\n-\t * is shorter than the time remaining, the system will restart itself to\n-\t * run at the offered delay.\n-\t * </p>\n-\t *\n-\t * @param offeredDelay\n-\t *\t\t\tdelay to offer\n-\t */\n-\tpublic void offerDelay(float offeredDelay) {\n-\t\tif (!running) {\n-\t\t\trunning = true;\n-\t\t\tdelay = offeredDelay;\n-\t\t} else {\n-\t\t\tdelay = Math.min(delay, offeredDelay);\n-\t\t}\n-\t}\n-\t\n-\t/**\n-\t * Get the initial delay that the system was ordered to process entities\n-\t * after.\n-\t * \n-\t * @return the originally set delay\n-\t */\n-\tpublic float getInitialTimeDelay() {\n-\t\treturn delay;\n-\t}\n-\t\n-\t/**\n-\t * Get the time until the system is scheduled to run at.\n-\t * <p>\n-\t * Returns zero (0) if the system is not running.\n-\t * Use {@link #isRunning() isRunning()} before checking this value.\n-\t * </p>\n-\t *\n-\t * @return time when system will run at\n-\t */\n-\tpublic float getRemainingTimeUntilProcessing() {\n-\t\tif(running) {\n-\t\t\treturn delay-acc;\n-\t\t}\n-\t\treturn 0;\n-\t}\n-\t\n-\t/**\n-\t * Check if the system is counting down towards processing.\n-\t * \n-\t * @return {@code true} if it's counting down, false if it's not running\n-\t */\n-\tpublic boolean isRunning() {\n-\t\treturn running;\n-\t}\n-\t\n-\t/**\n-\t * Stops the system from running, aborts current countdown.\n-\t * <p>\n-\t * Call offerDelay or restart to run it again.\n-\t * </p>\n-\t */\n-\tpublic void stop() {\n-\t\tthis.running = false;\n-\t\tthis.acc = 0;\n-\t}\n-}\n+ /** The time until an entity should be processed. */\n+ private float delay;\n+ /** If the system is running and counting down delays. */\n+\n+ private boolean running;\n+ /** The countdown, accumulates world deltas. */\n+\n+ private float acc;\n+\n+ /**\n+  * Creates a new DelayedEntityProcessingSystem.\n+  *\n+  * @param aspect\n+  *   the aspect to match against entities\n+  */\n+\n+ public DelayedIteratingSystem(Aspect.Builder aspect) {\n+  super(aspect);\n+ }\n+\n+ @Override\n+ protected final void processSystem() {\n+  IntBag entities = subscription.getEntities();\n+  int processed = entities.size();\n+  if (processed == 0) {\n+   stop();\n+   return;\n+  }\n+\n+  delay = Float.MAX_VALUE;\n+\n+  int[] ids = entities.getData();\n+  for (int i = 0; processed > i; i++) {\n+   int e = ids[i];\n+   processDelta(e, acc);\n+\n+   float remaining = getRemainingDelay(e);\n+   if (remaining <= 0) {\n+    processExpired(e);\n+   } else {\n+    offerDelay(remaining);\n+   }\n+  }\n+\n+  acc = 0;\n+ }\n+\n+ @Override\n+ protected void inserted(int entityId) {\n+  float remainingDelay = getRemainingDelay(entityId);\n+  processDelta(entityId, -acc);\n+  if (remainingDelay > 0) {\n+   offerDelay(remainingDelay);\n+  }\n+ }\n+ \n+ /**\n+  * Return the delay until this entity should be processed.\n+  * \n+  * @param entityId\n+  *   entity\n+  *\n+  * @return delay\n+  */\n+\n+ protected abstract float getRemainingDelay(int entityId);\n+\n+ @Override\n+ protected final boolean checkProcessing() {\n+  if (running) {\n+   acc += getTimeDelta();\n+   return acc >= delay;\n+  }\n+\n+  return false;\n+ }\n+ \n+ /**\n+  * Overridable method to provide custom time delta.\n+  */\n+\n+ protected float getTimeDelta() {\n+  return world.getDelta();\n+ }\n+ \n+ /**\n+  * Process an entity this system is interested in.\n+  * <p>\n+  * Substract the accumulatedDelta from the entities defined delay.\n+  * </p>\n+  * \n+  * @param entityId\n+  *   the entity to process\n+  * @param accumulatedDelta\n+  *   the delta time since this system was last executed\n+  */\n+\n+ protected abstract void processDelta(int entityId, float accumulatedDelta);\n+\n+ protected abstract void processExpired(int entityId);\n+\n+ /**\n+  * Restarts the system only if the delay offered is shorter than the time\n+  * that the system is currently scheduled to execute at.\n+  * <p>\n+  * If the system is already stopped (not running) then the offered delay\n+  * will be used to restart the system with no matter its value.\n+  * </p><p>\n+  * If the system is already counting down, and the offered delay is  larger\n+  * than the time remaining, the system will ignore it. If the offered delay\n+  * is shorter than the time remaining, the system will restart itself to\n+  * run at the offered delay.\n+  * </p>\n+  *\n+  * @param offeredDelay\n+  *   delay to offer\n+  */\n+ public void offerDelay(float offeredDelay) {\n+  if (!running) {\n+   running = true;\n+   delay = offeredDelay;\n+  } else {\n+   delay = Math.min(delay, offeredDelay);\n+  }\n+ }\n+ \n+ /**\n+  * Get the initial delay that the system was ordered to process entities\n+  * after.\n+  * \n+  * @return the originally set delay\n+  */\n+\n+\n+ public float getInitialTimeDelay() {\n+  return delay;\n+ }\n+ \n+ /**\n+  * Get the time until the system is scheduled to run at.\n+  * <p>\n+  * Returns zero (0) if the system is not running.\n+  * Use {@link #isRunning() isRunning()} before checking this value.\n+  * </p>\n+  *\n+  * @return time when system will run at\n+  */\n+\n+\n+ public float getRemainingTimeUntilProcessing() {\n+  if (running) {\n+   return delay - acc;\n+  }\n+\n+  return 0;\n+ }\n+ \n+ /**\n+  * Check if the system is counting down towards processing.\n+  * \n+  * @return {@code true} if it's counting down, false if it's not running\n+  */\n+\n+\n+ public boolean isRunning() {\n+  return running;\n+ }\n+ \n+ /**\n+  * Stops the system from running, aborts current countdown.\n+  * <p>\n+  * Call offerDelay or restart to run it again.\n+  * </p>\n+  */\n+\n+\n+ public void stop() {\n+  this.running = false;\n+  this.acc = 0;\n+ }\n+}\n\\ No newline at end of file\n",
            "diff_size": 182
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "24",
                    "severity": "error",
                    "message": "Line is longer than 105 characters (found 110).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": null,
            "diff": null
        }
    ],
    "repaired_by": [],
    "not_repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}