{
    "project_name": "vostok-hercules",
    "error_id": "45",
    "information": {
        "errors": [
            {
                "line": "238",
                "severity": "warning",
                "message": "Line is longer than 160 characters (found 171).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": "\n\n    public ElasticResponseHandler(Set<String> redefinedExceptions, boolean shouldCreateIndexIfAbsent, IndexCreator indexCreator, final MetricsCollector metricsCollector) {\n        this.redefinedExceptions = redefinedExceptions;\n        this.shouldCreateIndexIfAbsent = shouldCreateIndexIfAbsent;\n        this.indexCreator = indexCreator;",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "236",
                    "severity": "warning",
                    "message": "Line is longer than 160 characters (found 171).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/45/ElasticResponseHandler.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/styler/45/ElasticResponseHandler.java\nindex dc836b9a30f..afae8c3dcc7 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/45/ElasticResponseHandler.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/styler/45/ElasticResponseHandler.java\n@@ -233,8 +233,6 @@ public class ElasticResponseHandler {\n     private final Meter retryableErrorsMeter;\n     private final Meter nonRetryableErrorsMeter;\n     private final Meter unknownErrorsMeter;\n-\n-\n     public ElasticResponseHandler(Set<String> redefinedExceptions, boolean shouldCreateIndexIfAbsent, IndexCreator indexCreator, final MetricsCollector metricsCollector) {\n         this.redefinedExceptions = redefinedExceptions;\n         this.shouldCreateIndexIfAbsent = shouldCreateIndexIfAbsent;\n",
            "diff_size": 2
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/45/ElasticResponseHandler.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/intellij/45/ElasticResponseHandler.java\nindex dc836b9a30f..44b158d352b 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/45/ElasticResponseHandler.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/intellij/45/ElasticResponseHandler.java\n@@ -28,337 +28,338 @@ import static ru.kontur.vostok.hercules.util.throwable.ThrowableUtil.toUnchecked\n \n public class ElasticResponseHandler {\n \n-    public static class Result {\n-\n-        public static final Result OK = new Result(\n-                0,\n-                0,\n-                0,\n-                Collections.emptyMap()\n-        );\n-\n-        private final int retryableErrorCount;\n-        private final int nonRetryableErrorCount;\n-        private final int unknownErrorCount;\n-        private final Map<String, ErrorInfo> errorInfoMap;\n-\n-        public Result(\n-                int retryableErrorCount,\n-                int nonRetryableErrorCount,\n-                int unknownErrorCount,\n-                Map<String, ErrorInfo> errorInfoMap\n-        ) {\n-            this.retryableErrorCount = retryableErrorCount;\n-            this.nonRetryableErrorCount = nonRetryableErrorCount;\n-            this.unknownErrorCount = unknownErrorCount;\n-            this.errorInfoMap = errorInfoMap;\n-        }\n-\n-        public int getRetryableErrorCount() {\n-            return retryableErrorCount;\n-        }\n-\n-        public int getNonRetryableErrorCount() {\n-            return nonRetryableErrorCount;\n-        }\n-\n-        public int getUnknownErrorCount() {\n-            return unknownErrorCount;\n-        }\n+  public static class Result {\n+\n+    public static final Result OK = new Result(\n+      0,\n+      0,\n+      0,\n+      Collections.emptyMap()\n+    );\n+\n+    private final int retryableErrorCount;\n+    private final int nonRetryableErrorCount;\n+    private final int unknownErrorCount;\n+    private final Map<String, ErrorInfo> errorInfoMap;\n+\n+    public Result(\n+      int retryableErrorCount,\n+      int nonRetryableErrorCount,\n+      int unknownErrorCount,\n+      Map<String, ErrorInfo> errorInfoMap\n+    ) {\n+      this.retryableErrorCount = retryableErrorCount;\n+      this.nonRetryableErrorCount = nonRetryableErrorCount;\n+      this.unknownErrorCount = unknownErrorCount;\n+      this.errorInfoMap = errorInfoMap;\n+    }\n \n-        public int getTotalErrors() {\n-            return retryableErrorCount + nonRetryableErrorCount + unknownErrorCount;\n-        }\n+    public int getRetryableErrorCount() {\n+      return retryableErrorCount;\n+    }\n \n-        /**\n-         * @return Map of event-id -> error description\n-         */\n-        public Map<String, ErrorInfo> getErrors() {\n-            return errorInfoMap;\n-        }\n+    public int getNonRetryableErrorCount() {\n+      return nonRetryableErrorCount;\n     }\n \n-    static final Set<String> RETRYABLE_ERRORS_CODES = new HashSet<>(Arrays.asList(\n-            \"process_cluster_event_timeout_exception\",\n-            \"es_rejected_execution_exception\",\n-            \"cluster_block_exception\",\n-            \"unavailable_shards_exception\",\n-            \"timeout_exception\",\n-            \"master_not_discovered_exception\",\n-            \"connect_transport_exception\",\n-            \"primary_missing_action_exception\",\n-            \"concurrent_snapshot_execution_exception\",\n-            \"receive_timeout_transport_exception\",\n-            \"elasticsearch_timeout_exception\",\n-            \"no_shard_available_action_exception\",\n-            \"node_not_connected_exception\",\n-            \"node_disconnected_exception\",\n-            \"not_master_exception\",\n-            \"delay_recovery_exception\"\n-    ));\n-\n-    static final Set<String> NON_RETRYABLE_ERRORS_CODES = new HashSet<>(Arrays.asList(\n-            \"illegal_argument_exception\",\n-            \"mapper_parsing_exception\",\n-            \"illegal_state_exception\",\n-            \"invalid_index_name_exception\",\n-            \"index_closed_exception\",\n-            \"invalid_alias_name_exception\",\n-            \"elasticsearch_parse_exception\",\n-            \"invalid_type_name_exception\",\n-            \"parsing_exception\",\n-            \"index_template_missing_exception\",\n-            \"search_parse_exception\",\n-            \"timestamp_parsing_exception\",\n-            \"invalid_index_template_exception\",\n-            \"invalid_snapshot_name_exception\",\n-            \"document_source_missing_exception\",\n-            \"resource_already_exists_exception\",\n-            \"type_missing_exception\",\n-            \"index_shard_snapshot_failed_exception\",\n-            \"dfs_phase_execution_exception\",\n-            \"execution_cancelled_exception\",\n-            \"elasticsearch_security_exception\",\n-            \"index_shard_restore_exception\",\n-            \"bind_http_exception\",\n-            \"reduce_search_phase_exception\",\n-            \"node_closed_exception\",\n-            \"snapshot_failed_engine_exception\",\n-            \"shard_not_found_exception\",\n-            \"not_serializable_transport_exception\",\n-            \"response_handler_failure_transport_exception\",\n-            \"index_creation_exception\",\n-            \"index_not_found_exception\",\n-            \"illegal_shard_routing_state_exception\",\n-            \"broadcast_shard_operation_failed_exception\",\n-            \"resource_not_found_exception\",\n-            \"action_transport_exception\",\n-            \"elasticsearch_generation_exception\",\n-            \"index_shard_started_exception\",\n-            \"search_context_missing_exception\",\n-            \"general_script_exception\",\n-            \"snapshot_creation_exception\",\n-            \"document_missing_exception\",\n-            \"snapshot_exception\",\n-            \"index_primary_shard_not_allocated_exception\",\n-            \"transport_exception\",\n-            \"search_exception\",\n-            \"mapper_exception\",\n-            \"snapshot_restore_exception\",\n-            \"index_shard_closed_exception\",\n-            \"recover_files_recovery_exception\",\n-            \"truncated_translog_exception\",\n-            \"recovery_failed_exception\",\n-            \"index_shard_relocated_exception\",\n-            \"node_should_not_connect_exception\",\n-            \"translog_corrupted_exception\",\n-            \"fetch_phase_execution_exception\",\n-            \"version_conflict_engine_exception\",\n-            \"engine_exception\",\n-            \"no_such_node_exception\",\n-            \"settings_exception\",\n-            \"send_request_transport_exception\",\n-            \"not_serializable_exception_wrapper\",\n-            \"alias_filter_parsing_exception\",\n-            \"gateway_exception\",\n-            \"index_shard_not_recovering_exception\",\n-            \"http_exception\",\n-            \"elasticsearch_exception\",\n-            \"snapshot_missing_exception\",\n-            \"failed_node_exception\",\n-            \"blob_store_exception\",\n-            \"incompatible_cluster_state_version_exception\",\n-            \"recovery_engine_exception\",\n-            \"uncategorized_execution_exception\",\n-            \"routing_missing_exception\",\n-            \"index_shard_restore_failed_exception\",\n-            \"repository_exception\",\n-            \"aggregation_execution_exception\",\n-            \"refresh_failed_engine_exception\",\n-            \"aggregation_initialization_exception\",\n-            \"no_node_available_exception\",\n-            \"illegal_index_shard_state_exception\",\n-            \"index_shard_snapshot_exception\",\n-            \"index_shard_not_started_exception\",\n-            \"search_phase_execution_exception\",\n-            \"action_not_found_transport_exception\",\n-            \"transport_serialization_exception\",\n-            \"remote_transport_exception\",\n-            \"engine_creation_failure_exception\",\n-            \"routing_exception\",\n-            \"index_shard_recovery_exception\",\n-            \"repository_missing_exception\",\n-            \"no_class_settings_exception\",\n-            \"bind_transport_exception\",\n-            \"aliases_not_found_exception\",\n-            \"index_shard_recovering_exception\",\n-            \"translog_exception\",\n-            \"retry_on_primary_exception\",\n-            \"query_phase_execution_exception\",\n-            \"repository_verification_exception\",\n-            \"invalid_aggregation_path_exception\",\n-            \"http_on_transport_exception\",\n-            \"search_context_exception\",\n-            \"search_source_builder_exception\",\n-            \"flush_failed_engine_exception\",\n-            \"circuit_breaking_exception\",\n-            \"strict_dynamic_mapping_exception\",\n-            \"retry_on_replica_exception\",\n-            \"failed_to_commit_cluster_state_exception\",\n-            \"query_shard_exception\",\n-            \"no_longer_primary_shard_exception\",\n-            \"script_exception\",\n-            \"status_exception\",\n-            \"task_cancelled_exception\",\n-            \"shard_lock_obtain_failed_exception\",\n-            \"unknown_named_object_exception\",\n-            \"too_many_buckets_exception\"\n-    ));\n-\n-    private static final Logger LOGGER = LoggerFactory.getLogger(ElasticResponseHandler.class);\n-\n-    private static final String METRIC_PREFIX = \"bulkResponseHandler\";\n-\n-    private static final JsonFactory FACTORY = new JsonFactory();\n-    private static final ObjectMapper MAPPER = new ObjectMapper(FACTORY);\n-\n-    private final Set<String> redefinedExceptions;\n-    private final boolean shouldCreateIndexIfAbsent;\n-    private final IndexCreator indexCreator;\n-\n-    private final MetricsCollector metricsCollector;\n-\n-    private final ConcurrentHashMap<String, Meter> errorTypesMeter = new ConcurrentHashMap<>();\n-\n-    private final Meter retryableErrorsMeter;\n-    private final Meter nonRetryableErrorsMeter;\n-    private final Meter unknownErrorsMeter;\n-\n-\n-    public ElasticResponseHandler(Set<String> redefinedExceptions, boolean shouldCreateIndexIfAbsent, IndexCreator indexCreator, final MetricsCollector metricsCollector) {\n-        this.redefinedExceptions = redefinedExceptions;\n-        this.shouldCreateIndexIfAbsent = shouldCreateIndexIfAbsent;\n-        this.indexCreator = indexCreator;\n-        this.metricsCollector = metricsCollector;\n-\n-        this.retryableErrorsMeter = metricsCollector.meter(METRIC_PREFIX + \".retryableErrors\");\n-        this.nonRetryableErrorsMeter = metricsCollector.meter(METRIC_PREFIX + \".nonRetryableErrors\");\n-        this.unknownErrorsMeter = metricsCollector.meter(METRIC_PREFIX + \".unknownErrors\");\n+    public int getUnknownErrorCount() {\n+      return unknownErrorCount;\n     }\n \n-    // TODO: Replace with a good parser\n-    public Result process(HttpEntity httpEntity) {\n-        return toUnchecked(() -> {\n-            int retryableErrorCount = 0;\n-            int nonRetryableErrorCount = 0;\n-            int unknownErrorCount = 0;\n-            Map<String, ErrorInfo> errorInfos = new HashMap<>();\n-\n-            JsonParser parser = FACTORY.createParser(httpEntity.getContent());\n-\n-            String currentId = \"\";\n-            String currentIndex = \"\";\n-\n-            while (Objects.nonNull(parser.nextToken())) {\n-                /*\n-                 * No errors in response, so processing can be skipped\n-                 */\n-                if (\"errors\".equals(parser.getCurrentName())) {\n-                    if (Boolean.FALSE.equals(parser.nextBooleanValue())) {\n-                        return Result.OK;\n-                    }\n-                }\n-\n-                if (\"_id\".equals(parser.getCurrentName())) {\n-                    currentId = parser.getValueAsString(\"\");\n-                }\n-                if (\"_index\".equals(parser.getCurrentName())) {\n-                    currentIndex = parser.getValueAsString(\"\");\n-                }\n-                if (\"error\".equals(parser.getCurrentName())) {\n-                    parser.nextToken(); // Skip name\n-                    final ErrorInfo error = processError(MAPPER.readTree(parser), currentId, currentIndex);\n-                    errorInfos.put(currentId, error);\n-                    switch (error.getType()) {\n-                        case RETRYABLE:\n-                            retryableErrorCount++;\n-                            break;\n-                        case NON_RETRYABLE:\n-                            nonRetryableErrorCount++;\n-                            break;\n-                        case UNKNOWN:\n-                            unknownErrorCount++;\n-                            break;\n-                        default:\n-                            throw new RuntimeException(String.format(\"Unsupported error type '%s'\", error.getType()));\n-                    }\n-                }\n-            }\n-\n-            retryableErrorsMeter.mark(retryableErrorCount);\n-            nonRetryableErrorsMeter.mark(nonRetryableErrorCount);\n-            unknownErrorsMeter.mark(unknownErrorCount);\n-\n-            return new Result(retryableErrorCount, nonRetryableErrorCount, unknownErrorCount, errorInfos);\n-        });\n+    public int getTotalErrors() {\n+      return retryableErrorCount + nonRetryableErrorCount + unknownErrorCount;\n     }\n \n     /**\n-     * Process error JSON node\n-     *\n-     * @param errorNode           JSON node with error data\n-     * @param id                  event id\n-     * @param index               index\n-     * @return error type, which determines retryability of the error\n+     * @return Map of event-id -> error description\n      */\n-    private ErrorInfo processError(TreeNode errorNode, String id, String index) {\n-        if (errorNode instanceof ObjectNode) {\n-            ObjectNode error = (ObjectNode) errorNode;\n-            LOGGER.warn(\"Original error: {}\", error);\n-\n-            final String type = Optional.ofNullable(error.get(\"type\"))\n-                    .map(JsonNode::asText)\n-                    .orElse(\"\");\n-\n-            final String reason = Optional.ofNullable(error.get(\"reason\"))\n-                    .map(JsonNode::asText)\n-                    .orElse(\"\")\n-                    .replaceAll(\"[\\\\r\\\\n]+\", \" \");\n-\n-            //TODO: Build \"caused by\" trace\n-\n-            errorTypesMeter.computeIfAbsent(type, this::createMeter).mark();\n-            if (shouldCreateIndexIfAbsent && \"index_not_found_exception\".equals(type)) {\n-                LOGGER.info(\"Index \" + index + \" not found, will create\");\n-                if (indexCreator.create(index)) {\n-                    LOGGER.info(\"Index \" + index + \" has been created, will retry indexing\");\n-                } else {\n-                    LOGGER.warn(\"Cannot create index \" + index + \", will retry anyway\");\n-                }\n-                indexCreator.waitForIndexReadiness(index);\n-                return new ErrorInfo(ErrorType.RETRYABLE, error.toString());\n-            }\n-            if (redefinedExceptions.contains(type)) {\n-                LOGGER.warn(\"Retryable error which will be regarded as non-retryable: index={}, id={}, type={}, reason={}\", index, id, type, reason);\n-                return new ErrorInfo(ErrorType.NON_RETRYABLE, error.toString());\n-            } else if (RETRYABLE_ERRORS_CODES.contains(type)) {\n-                LOGGER.warn(\"Retryable error: index={}, id={}, type={}, reason={}\", index, id, type, reason);\n-                return new ErrorInfo(ErrorType.RETRYABLE, error.toString());\n-            } else if (NON_RETRYABLE_ERRORS_CODES.contains(type)) {\n-                LOGGER.warn(\"Non retryable error: index={}, id={}, type={}, reason={}\", index, id, type, reason);\n-                return new ErrorInfo(ErrorType.NON_RETRYABLE, error.toString());\n-            } else {\n-                LOGGER.warn(\"Unknown error: index={}, id={}, type={}, reason={}\", index, id, type, reason);\n-                return new ErrorInfo(ErrorType.UNKNOWN, error.toString());\n-            }\n+    public Map<String, ErrorInfo> getErrors() {\n+      return errorInfoMap;\n+    }\n+  }\n+\n+  static final Set<String> RETRYABLE_ERRORS_CODES = new HashSet<>(Arrays.asList(\n+    \"process_cluster_event_timeout_exception\",\n+    \"es_rejected_execution_exception\",\n+    \"cluster_block_exception\",\n+    \"unavailable_shards_exception\",\n+    \"timeout_exception\",\n+    \"master_not_discovered_exception\",\n+    \"connect_transport_exception\",\n+    \"primary_missing_action_exception\",\n+    \"concurrent_snapshot_execution_exception\",\n+    \"receive_timeout_transport_exception\",\n+    \"elasticsearch_timeout_exception\",\n+    \"no_shard_available_action_exception\",\n+    \"node_not_connected_exception\",\n+    \"node_disconnected_exception\",\n+    \"not_master_exception\",\n+    \"delay_recovery_exception\"\n+  ));\n+\n+  static final Set<String> NON_RETRYABLE_ERRORS_CODES = new HashSet<>(Arrays.asList(\n+    \"illegal_argument_exception\",\n+    \"mapper_parsing_exception\",\n+    \"illegal_state_exception\",\n+    \"invalid_index_name_exception\",\n+    \"index_closed_exception\",\n+    \"invalid_alias_name_exception\",\n+    \"elasticsearch_parse_exception\",\n+    \"invalid_type_name_exception\",\n+    \"parsing_exception\",\n+    \"index_template_missing_exception\",\n+    \"search_parse_exception\",\n+    \"timestamp_parsing_exception\",\n+    \"invalid_index_template_exception\",\n+    \"invalid_snapshot_name_exception\",\n+    \"document_source_missing_exception\",\n+    \"resource_already_exists_exception\",\n+    \"type_missing_exception\",\n+    \"index_shard_snapshot_failed_exception\",\n+    \"dfs_phase_execution_exception\",\n+    \"execution_cancelled_exception\",\n+    \"elasticsearch_security_exception\",\n+    \"index_shard_restore_exception\",\n+    \"bind_http_exception\",\n+    \"reduce_search_phase_exception\",\n+    \"node_closed_exception\",\n+    \"snapshot_failed_engine_exception\",\n+    \"shard_not_found_exception\",\n+    \"not_serializable_transport_exception\",\n+    \"response_handler_failure_transport_exception\",\n+    \"index_creation_exception\",\n+    \"index_not_found_exception\",\n+    \"illegal_shard_routing_state_exception\",\n+    \"broadcast_shard_operation_failed_exception\",\n+    \"resource_not_found_exception\",\n+    \"action_transport_exception\",\n+    \"elasticsearch_generation_exception\",\n+    \"index_shard_started_exception\",\n+    \"search_context_missing_exception\",\n+    \"general_script_exception\",\n+    \"snapshot_creation_exception\",\n+    \"document_missing_exception\",\n+    \"snapshot_exception\",\n+    \"index_primary_shard_not_allocated_exception\",\n+    \"transport_exception\",\n+    \"search_exception\",\n+    \"mapper_exception\",\n+    \"snapshot_restore_exception\",\n+    \"index_shard_closed_exception\",\n+    \"recover_files_recovery_exception\",\n+    \"truncated_translog_exception\",\n+    \"recovery_failed_exception\",\n+    \"index_shard_relocated_exception\",\n+    \"node_should_not_connect_exception\",\n+    \"translog_corrupted_exception\",\n+    \"fetch_phase_execution_exception\",\n+    \"version_conflict_engine_exception\",\n+    \"engine_exception\",\n+    \"no_such_node_exception\",\n+    \"settings_exception\",\n+    \"send_request_transport_exception\",\n+    \"not_serializable_exception_wrapper\",\n+    \"alias_filter_parsing_exception\",\n+    \"gateway_exception\",\n+    \"index_shard_not_recovering_exception\",\n+    \"http_exception\",\n+    \"elasticsearch_exception\",\n+    \"snapshot_missing_exception\",\n+    \"failed_node_exception\",\n+    \"blob_store_exception\",\n+    \"incompatible_cluster_state_version_exception\",\n+    \"recovery_engine_exception\",\n+    \"uncategorized_execution_exception\",\n+    \"routing_missing_exception\",\n+    \"index_shard_restore_failed_exception\",\n+    \"repository_exception\",\n+    \"aggregation_execution_exception\",\n+    \"refresh_failed_engine_exception\",\n+    \"aggregation_initialization_exception\",\n+    \"no_node_available_exception\",\n+    \"illegal_index_shard_state_exception\",\n+    \"index_shard_snapshot_exception\",\n+    \"index_shard_not_started_exception\",\n+    \"search_phase_execution_exception\",\n+    \"action_not_found_transport_exception\",\n+    \"transport_serialization_exception\",\n+    \"remote_transport_exception\",\n+    \"engine_creation_failure_exception\",\n+    \"routing_exception\",\n+    \"index_shard_recovery_exception\",\n+    \"repository_missing_exception\",\n+    \"no_class_settings_exception\",\n+    \"bind_transport_exception\",\n+    \"aliases_not_found_exception\",\n+    \"index_shard_recovering_exception\",\n+    \"translog_exception\",\n+    \"retry_on_primary_exception\",\n+    \"query_phase_execution_exception\",\n+    \"repository_verification_exception\",\n+    \"invalid_aggregation_path_exception\",\n+    \"http_on_transport_exception\",\n+    \"search_context_exception\",\n+    \"search_source_builder_exception\",\n+    \"flush_failed_engine_exception\",\n+    \"circuit_breaking_exception\",\n+    \"strict_dynamic_mapping_exception\",\n+    \"retry_on_replica_exception\",\n+    \"failed_to_commit_cluster_state_exception\",\n+    \"query_shard_exception\",\n+    \"no_longer_primary_shard_exception\",\n+    \"script_exception\",\n+    \"status_exception\",\n+    \"task_cancelled_exception\",\n+    \"shard_lock_obtain_failed_exception\",\n+    \"unknown_named_object_exception\",\n+    \"too_many_buckets_exception\"\n+  ));\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(ElasticResponseHandler.class);\n+\n+  private static final String METRIC_PREFIX = \"bulkResponseHandler\";\n+\n+  private static final JsonFactory FACTORY = new JsonFactory();\n+  private static final ObjectMapper MAPPER = new ObjectMapper(FACTORY);\n+\n+  private final Set<String> redefinedExceptions;\n+  private final boolean shouldCreateIndexIfAbsent;\n+  private final IndexCreator indexCreator;\n+\n+  private final MetricsCollector metricsCollector;\n+\n+  private final ConcurrentHashMap<String, Meter> errorTypesMeter = new ConcurrentHashMap<>();\n+\n+  private final Meter retryableErrorsMeter;\n+  private final Meter nonRetryableErrorsMeter;\n+  private final Meter unknownErrorsMeter;\n+\n+\n+  public ElasticResponseHandler(Set<String> redefinedExceptions, boolean shouldCreateIndexIfAbsent, IndexCreator indexCreator,\n+                                final MetricsCollector metricsCollector) {\n+    this.redefinedExceptions = redefinedExceptions;\n+    this.shouldCreateIndexIfAbsent = shouldCreateIndexIfAbsent;\n+    this.indexCreator = indexCreator;\n+    this.metricsCollector = metricsCollector;\n+\n+    this.retryableErrorsMeter = metricsCollector.meter(METRIC_PREFIX + \".retryableErrors\");\n+    this.nonRetryableErrorsMeter = metricsCollector.meter(METRIC_PREFIX + \".nonRetryableErrors\");\n+    this.unknownErrorsMeter = metricsCollector.meter(METRIC_PREFIX + \".unknownErrors\");\n+  }\n+\n+  // TODO: Replace with a good parser\n+  public Result process(HttpEntity httpEntity) {\n+    return toUnchecked(() -> {\n+      int retryableErrorCount = 0;\n+      int nonRetryableErrorCount = 0;\n+      int unknownErrorCount = 0;\n+      Map<String, ErrorInfo> errorInfos = new HashMap<>();\n+\n+      JsonParser parser = FACTORY.createParser(httpEntity.getContent());\n+\n+      String currentId = \"\";\n+      String currentIndex = \"\";\n+\n+      while (Objects.nonNull(parser.nextToken())) {\n+        /*\n+         * No errors in response, so processing can be skipped\n+         */\n+        if (\"errors\".equals(parser.getCurrentName())) {\n+          if (Boolean.FALSE.equals(parser.nextBooleanValue())) {\n+            return Result.OK;\n+          }\n+        }\n+\n+        if (\"_id\".equals(parser.getCurrentName())) {\n+          currentId = parser.getValueAsString(\"\");\n+        }\n+        if (\"_index\".equals(parser.getCurrentName())) {\n+          currentIndex = parser.getValueAsString(\"\");\n+        }\n+        if (\"error\".equals(parser.getCurrentName())) {\n+          parser.nextToken(); // Skip name\n+          final ErrorInfo error = processError(MAPPER.readTree(parser), currentId, currentIndex);\n+          errorInfos.put(currentId, error);\n+          switch (error.getType()) {\n+          case RETRYABLE:\n+            retryableErrorCount++;\n+            break;\n+          case NON_RETRYABLE:\n+            nonRetryableErrorCount++;\n+            break;\n+          case UNKNOWN:\n+            unknownErrorCount++;\n+            break;\n+          default:\n+            throw new RuntimeException(String.format(\"Unsupported error type '%s'\", error.getType()));\n+          }\n+        }\n+      }\n+\n+      retryableErrorsMeter.mark(retryableErrorCount);\n+      nonRetryableErrorsMeter.mark(nonRetryableErrorCount);\n+      unknownErrorsMeter.mark(unknownErrorCount);\n+\n+      return new Result(retryableErrorCount, nonRetryableErrorCount, unknownErrorCount, errorInfos);\n+    });\n+  }\n+\n+  /**\n+   * Process error JSON node\n+   *\n+   * @param errorNode JSON node with error data\n+   * @param id        event id\n+   * @param index     index\n+   * @return error type, which determines retryability of the error\n+   */\n+  private ErrorInfo processError(TreeNode errorNode, String id, String index) {\n+    if (errorNode instanceof ObjectNode) {\n+      ObjectNode error = (ObjectNode) errorNode;\n+      LOGGER.warn(\"Original error: {}\", error);\n+\n+      final String type = Optional.ofNullable(error.get(\"type\"))\n+        .map(JsonNode::asText)\n+        .orElse(\"\");\n+\n+      final String reason = Optional.ofNullable(error.get(\"reason\"))\n+        .map(JsonNode::asText)\n+        .orElse(\"\")\n+        .replaceAll(\"[\\\\r\\\\n]+\", \" \");\n+\n+      //TODO: Build \"caused by\" trace\n+\n+      errorTypesMeter.computeIfAbsent(type, this::createMeter).mark();\n+      if (shouldCreateIndexIfAbsent && \"index_not_found_exception\".equals(type)) {\n+        LOGGER.info(\"Index \" + index + \" not found, will create\");\n+        if (indexCreator.create(index)) {\n+          LOGGER.info(\"Index \" + index + \" has been created, will retry indexing\");\n         } else {\n-            String errorMessage = \"Error node is not object node, cannot parse\";\n-            LOGGER.warn(errorMessage);\n-            return new ErrorInfo(ErrorType.NON_RETRYABLE, errorMessage);\n+          LOGGER.warn(\"Cannot create index \" + index + \", will retry anyway\");\n         }\n+        indexCreator.waitForIndexReadiness(index);\n+        return new ErrorInfo(ErrorType.RETRYABLE, error.toString());\n+      }\n+      if (redefinedExceptions.contains(type)) {\n+        LOGGER.warn(\"Retryable error which will be regarded as non-retryable: index={}, id={}, type={}, reason={}\", index, id, type, reason);\n+        return new ErrorInfo(ErrorType.NON_RETRYABLE, error.toString());\n+      } else if (RETRYABLE_ERRORS_CODES.contains(type)) {\n+        LOGGER.warn(\"Retryable error: index={}, id={}, type={}, reason={}\", index, id, type, reason);\n+        return new ErrorInfo(ErrorType.RETRYABLE, error.toString());\n+      } else if (NON_RETRYABLE_ERRORS_CODES.contains(type)) {\n+        LOGGER.warn(\"Non retryable error: index={}, id={}, type={}, reason={}\", index, id, type, reason);\n+        return new ErrorInfo(ErrorType.NON_RETRYABLE, error.toString());\n+      } else {\n+        LOGGER.warn(\"Unknown error: index={}, id={}, type={}, reason={}\", index, id, type, reason);\n+        return new ErrorInfo(ErrorType.UNKNOWN, error.toString());\n+      }\n+    } else {\n+      String errorMessage = \"Error node is not object node, cannot parse\";\n+      LOGGER.warn(errorMessage);\n+      return new ErrorInfo(ErrorType.NON_RETRYABLE, errorMessage);\n     }\n+  }\n \n-    private Meter createMeter(final String errorType) {\n-        return metricsCollector.meter(METRIC_PREFIX + \".errorTypes.\" + MetricsUtil.sanitizeMetricName(errorType));\n-    }\n+  private Meter createMeter(final String errorType) {\n+    return metricsCollector.meter(METRIC_PREFIX + \".errorTypes.\" + MetricsUtil.sanitizeMetricName(errorType));\n+  }\n }\n",
            "diff_size": 560
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "74",
                    "severity": "warning",
                    "message": "Line is longer than 160 characters (found 614).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "76",
                    "severity": "warning",
                    "message": "Line is longer than 160 characters (found 3,763).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/45/ElasticResponseHandler.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/codebuff/45/ElasticResponseHandler.java\nindex dc836b9a30f..10cbb491b5b 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/45/ElasticResponseHandler.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/codebuff/45/ElasticResponseHandler.java\n@@ -13,7 +13,6 @@ import ru.kontur.vostok.hercules.elastic.sink.index.IndexCreator;\n import ru.kontur.vostok.hercules.health.Meter;\n import ru.kontur.vostok.hercules.health.MetricsCollector;\n import ru.kontur.vostok.hercules.health.MetricsUtil;\n-\n import java.util.Arrays;\n import java.util.Collections;\n import java.util.HashMap;\n@@ -30,23 +29,16 @@ public class ElasticResponseHandler {\n \n     public static class Result {\n \n-        public static final Result OK = new Result(\n-                0,\n-                0,\n-                0,\n-                Collections.emptyMap()\n-        );\n-\n+        public static final Result OK = new Result(0, 0, 0, Collections.emptyMap());\n         private final int retryableErrorCount;\n         private final int nonRetryableErrorCount;\n         private final int unknownErrorCount;\n         private final Map<String, ErrorInfo> errorInfoMap;\n \n         public Result(\n-                int retryableErrorCount,\n-                int nonRetryableErrorCount,\n-                int unknownErrorCount,\n-                Map<String, ErrorInfo> errorInfoMap\n+            int retryableErrorCount,\n+            int nonRetryableErrorCount,\n+            int unknownErrorCount, Map<String, ErrorInfo> errorInfoMap\n         ) {\n             this.retryableErrorCount = retryableErrorCount;\n             this.nonRetryableErrorCount = nonRetryableErrorCount;\n@@ -73,234 +65,95 @@ public class ElasticResponseHandler {\n         /**\n          * @return Map of event-id -> error description\n          */\n+\n         public Map<String, ErrorInfo> getErrors() {\n             return errorInfoMap;\n         }\n     }\n \n-    static final Set<String> RETRYABLE_ERRORS_CODES = new HashSet<>(Arrays.asList(\n-            \"process_cluster_event_timeout_exception\",\n-            \"es_rejected_execution_exception\",\n-            \"cluster_block_exception\",\n-            \"unavailable_shards_exception\",\n-            \"timeout_exception\",\n-            \"master_not_discovered_exception\",\n-            \"connect_transport_exception\",\n-            \"primary_missing_action_exception\",\n-            \"concurrent_snapshot_execution_exception\",\n-            \"receive_timeout_transport_exception\",\n-            \"elasticsearch_timeout_exception\",\n-            \"no_shard_available_action_exception\",\n-            \"node_not_connected_exception\",\n-            \"node_disconnected_exception\",\n-            \"not_master_exception\",\n-            \"delay_recovery_exception\"\n-    ));\n-\n-    static final Set<String> NON_RETRYABLE_ERRORS_CODES = new HashSet<>(Arrays.asList(\n-            \"illegal_argument_exception\",\n-            \"mapper_parsing_exception\",\n-            \"illegal_state_exception\",\n-            \"invalid_index_name_exception\",\n-            \"index_closed_exception\",\n-            \"invalid_alias_name_exception\",\n-            \"elasticsearch_parse_exception\",\n-            \"invalid_type_name_exception\",\n-            \"parsing_exception\",\n-            \"index_template_missing_exception\",\n-            \"search_parse_exception\",\n-            \"timestamp_parsing_exception\",\n-            \"invalid_index_template_exception\",\n-            \"invalid_snapshot_name_exception\",\n-            \"document_source_missing_exception\",\n-            \"resource_already_exists_exception\",\n-            \"type_missing_exception\",\n-            \"index_shard_snapshot_failed_exception\",\n-            \"dfs_phase_execution_exception\",\n-            \"execution_cancelled_exception\",\n-            \"elasticsearch_security_exception\",\n-            \"index_shard_restore_exception\",\n-            \"bind_http_exception\",\n-            \"reduce_search_phase_exception\",\n-            \"node_closed_exception\",\n-            \"snapshot_failed_engine_exception\",\n-            \"shard_not_found_exception\",\n-            \"not_serializable_transport_exception\",\n-            \"response_handler_failure_transport_exception\",\n-            \"index_creation_exception\",\n-            \"index_not_found_exception\",\n-            \"illegal_shard_routing_state_exception\",\n-            \"broadcast_shard_operation_failed_exception\",\n-            \"resource_not_found_exception\",\n-            \"action_transport_exception\",\n-            \"elasticsearch_generation_exception\",\n-            \"index_shard_started_exception\",\n-            \"search_context_missing_exception\",\n-            \"general_script_exception\",\n-            \"snapshot_creation_exception\",\n-            \"document_missing_exception\",\n-            \"snapshot_exception\",\n-            \"index_primary_shard_not_allocated_exception\",\n-            \"transport_exception\",\n-            \"search_exception\",\n-            \"mapper_exception\",\n-            \"snapshot_restore_exception\",\n-            \"index_shard_closed_exception\",\n-            \"recover_files_recovery_exception\",\n-            \"truncated_translog_exception\",\n-            \"recovery_failed_exception\",\n-            \"index_shard_relocated_exception\",\n-            \"node_should_not_connect_exception\",\n-            \"translog_corrupted_exception\",\n-            \"fetch_phase_execution_exception\",\n-            \"version_conflict_engine_exception\",\n-            \"engine_exception\",\n-            \"no_such_node_exception\",\n-            \"settings_exception\",\n-            \"send_request_transport_exception\",\n-            \"not_serializable_exception_wrapper\",\n-            \"alias_filter_parsing_exception\",\n-            \"gateway_exception\",\n-            \"index_shard_not_recovering_exception\",\n-            \"http_exception\",\n-            \"elasticsearch_exception\",\n-            \"snapshot_missing_exception\",\n-            \"failed_node_exception\",\n-            \"blob_store_exception\",\n-            \"incompatible_cluster_state_version_exception\",\n-            \"recovery_engine_exception\",\n-            \"uncategorized_execution_exception\",\n-            \"routing_missing_exception\",\n-            \"index_shard_restore_failed_exception\",\n-            \"repository_exception\",\n-            \"aggregation_execution_exception\",\n-            \"refresh_failed_engine_exception\",\n-            \"aggregation_initialization_exception\",\n-            \"no_node_available_exception\",\n-            \"illegal_index_shard_state_exception\",\n-            \"index_shard_snapshot_exception\",\n-            \"index_shard_not_started_exception\",\n-            \"search_phase_execution_exception\",\n-            \"action_not_found_transport_exception\",\n-            \"transport_serialization_exception\",\n-            \"remote_transport_exception\",\n-            \"engine_creation_failure_exception\",\n-            \"routing_exception\",\n-            \"index_shard_recovery_exception\",\n-            \"repository_missing_exception\",\n-            \"no_class_settings_exception\",\n-            \"bind_transport_exception\",\n-            \"aliases_not_found_exception\",\n-            \"index_shard_recovering_exception\",\n-            \"translog_exception\",\n-            \"retry_on_primary_exception\",\n-            \"query_phase_execution_exception\",\n-            \"repository_verification_exception\",\n-            \"invalid_aggregation_path_exception\",\n-            \"http_on_transport_exception\",\n-            \"search_context_exception\",\n-            \"search_source_builder_exception\",\n-            \"flush_failed_engine_exception\",\n-            \"circuit_breaking_exception\",\n-            \"strict_dynamic_mapping_exception\",\n-            \"retry_on_replica_exception\",\n-            \"failed_to_commit_cluster_state_exception\",\n-            \"query_shard_exception\",\n-            \"no_longer_primary_shard_exception\",\n-            \"script_exception\",\n-            \"status_exception\",\n-            \"task_cancelled_exception\",\n-            \"shard_lock_obtain_failed_exception\",\n-            \"unknown_named_object_exception\",\n-            \"too_many_buckets_exception\"\n-    ));\n+    static final Set<String> RETRYABLE_ERRORS_CODES = new HashSet<>(Arrays.asList(\"process_cluster_event_timeout_exception\", \"es_rejected_execution_exception\", \"cluster_block_exception\", \"unavailable_shards_exception\", \"timeout_exception\", \"master_not_discovered_exception\", \"connect_transport_exception\", \"primary_missing_action_exception\", \"concurrent_snapshot_execution_exception\", \"receive_timeout_transport_exception\", \"elasticsearch_timeout_exception\", \"no_shard_available_action_exception\", \"node_not_connected_exception\", \"node_disconnected_exception\", \"not_master_exception\", \"delay_recovery_exception\"));\n \n+    static final Set<String> NON_RETRYABLE_ERRORS_CODES = new HashSet<>(Arrays.asList(\"illegal_argument_exception\", \"mapper_parsing_exception\", \"illegal_state_exception\", \"invalid_index_name_exception\", \"index_closed_exception\", \"invalid_alias_name_exception\", \"elasticsearch_parse_exception\", \"invalid_type_name_exception\", \"parsing_exception\", \"index_template_missing_exception\", \"search_parse_exception\", \"timestamp_parsing_exception\", \"invalid_index_template_exception\", \"invalid_snapshot_name_exception\", \"document_source_missing_exception\", \"resource_already_exists_exception\", \"type_missing_exception\", \"index_shard_snapshot_failed_exception\", \"dfs_phase_execution_exception\", \"execution_cancelled_exception\", \"elasticsearch_security_exception\", \"index_shard_restore_exception\", \"bind_http_exception\", \"reduce_search_phase_exception\", \"node_closed_exception\", \"snapshot_failed_engine_exception\", \"shard_not_found_exception\", \"not_serializable_transport_exception\", \"response_handler_failure_transport_exception\", \"index_creation_exception\", \"index_not_found_exception\", \"illegal_shard_routing_state_exception\", \"broadcast_shard_operation_failed_exception\", \"resource_not_found_exception\", \"action_transport_exception\", \"elasticsearch_generation_exception\", \"index_shard_started_exception\", \"search_context_missing_exception\", \"general_script_exception\", \"snapshot_creation_exception\", \"document_missing_exception\", \"snapshot_exception\", \"index_primary_shard_not_allocated_exception\", \"transport_exception\", \"search_exception\", \"mapper_exception\", \"snapshot_restore_exception\", \"index_shard_closed_exception\", \"recover_files_recovery_exception\", \"truncated_translog_exception\", \"recovery_failed_exception\", \"index_shard_relocated_exception\", \"node_should_not_connect_exception\", \"translog_corrupted_exception\", \"fetch_phase_execution_exception\", \"version_conflict_engine_exception\", \"engine_exception\", \"no_such_node_exception\", \"settings_exception\", \"send_request_transport_exception\", \"not_serializable_exception_wrapper\", \"alias_filter_parsing_exception\", \"gateway_exception\", \"index_shard_not_recovering_exception\", \"http_exception\", \"elasticsearch_exception\", \"snapshot_missing_exception\", \"failed_node_exception\", \"blob_store_exception\", \"incompatible_cluster_state_version_exception\", \"recovery_engine_exception\", \"uncategorized_execution_exception\", \"routing_missing_exception\", \"index_shard_restore_failed_exception\", \"repository_exception\", \"aggregation_execution_exception\", \"refresh_failed_engine_exception\", \"aggregation_initialization_exception\", \"no_node_available_exception\", \"illegal_index_shard_state_exception\", \"index_shard_snapshot_exception\", \"index_shard_not_started_exception\", \"search_phase_execution_exception\", \"action_not_found_transport_exception\", \"transport_serialization_exception\", \"remote_transport_exception\", \"engine_creation_failure_exception\", \"routing_exception\", \"index_shard_recovery_exception\", \"repository_missing_exception\", \"no_class_settings_exception\", \"bind_transport_exception\", \"aliases_not_found_exception\", \"index_shard_recovering_exception\", \"translog_exception\", \"retry_on_primary_exception\", \"query_phase_execution_exception\", \"repository_verification_exception\", \"invalid_aggregation_path_exception\", \"http_on_transport_exception\", \"search_context_exception\", \"search_source_builder_exception\", \"flush_failed_engine_exception\", \"circuit_breaking_exception\", \"strict_dynamic_mapping_exception\", \"retry_on_replica_exception\", \"failed_to_commit_cluster_state_exception\", \"query_shard_exception\", \"no_longer_primary_shard_exception\", \"script_exception\", \"status_exception\", \"task_cancelled_exception\", \"shard_lock_obtain_failed_exception\", \"unknown_named_object_exception\", \"too_many_buckets_exception\"));\n     private static final Logger LOGGER = LoggerFactory.getLogger(ElasticResponseHandler.class);\n-\n     private static final String METRIC_PREFIX = \"bulkResponseHandler\";\n-\n     private static final JsonFactory FACTORY = new JsonFactory();\n     private static final ObjectMapper MAPPER = new ObjectMapper(FACTORY);\n-\n     private final Set<String> redefinedExceptions;\n     private final boolean shouldCreateIndexIfAbsent;\n     private final IndexCreator indexCreator;\n-\n     private final MetricsCollector metricsCollector;\n-\n     private final ConcurrentHashMap<String, Meter> errorTypesMeter = new ConcurrentHashMap<>();\n-\n     private final Meter retryableErrorsMeter;\n     private final Meter nonRetryableErrorsMeter;\n     private final Meter unknownErrorsMeter;\n \n-\n-    public ElasticResponseHandler(Set<String> redefinedExceptions, boolean shouldCreateIndexIfAbsent, IndexCreator indexCreator, final MetricsCollector metricsCollector) {\n+    public ElasticResponseHandler(\n+        Set<String> redefinedExceptions,\n+        boolean shouldCreateIndexIfAbsent,\n+        IndexCreator indexCreator, final MetricsCollector metricsCollector\n+    ) {\n         this.redefinedExceptions = redefinedExceptions;\n         this.shouldCreateIndexIfAbsent = shouldCreateIndexIfAbsent;\n         this.indexCreator = indexCreator;\n         this.metricsCollector = metricsCollector;\n-\n         this.retryableErrorsMeter = metricsCollector.meter(METRIC_PREFIX + \".retryableErrors\");\n         this.nonRetryableErrorsMeter = metricsCollector.meter(METRIC_PREFIX + \".nonRetryableErrors\");\n         this.unknownErrorsMeter = metricsCollector.meter(METRIC_PREFIX + \".unknownErrors\");\n     }\n \n     // TODO: Replace with a good parser\n+\n     public Result process(HttpEntity httpEntity) {\n         return toUnchecked(() -> {\n-            int retryableErrorCount = 0;\n-            int nonRetryableErrorCount = 0;\n-            int unknownErrorCount = 0;\n-            Map<String, ErrorInfo> errorInfos = new HashMap<>();\n-\n-            JsonParser parser = FACTORY.createParser(httpEntity.getContent());\n-\n-            String currentId = \"\";\n-            String currentIndex = \"\";\n-\n-            while (Objects.nonNull(parser.nextToken())) {\n+                   int retryableErrorCount = 0;\n+                   int nonRetryableErrorCount = 0;\n+                   int unknownErrorCount = 0;\n+                   Map<String, ErrorInfo> errorInfos = new HashMap<>();\n+                   JsonParser parser = FACTORY.createParser(httpEntity.getContent());\n+                   String currentId = \"\";\n+                   String currentIndex = \"\";\n+                   while (Objects.nonNull(parser.nextToken())) {\n                 /*\n                  * No errors in response, so processing can be skipped\n                  */\n-                if (\"errors\".equals(parser.getCurrentName())) {\n-                    if (Boolean.FALSE.equals(parser.nextBooleanValue())) {\n-                        return Result.OK;\n-                    }\n-                }\n-\n-                if (\"_id\".equals(parser.getCurrentName())) {\n-                    currentId = parser.getValueAsString(\"\");\n-                }\n-                if (\"_index\".equals(parser.getCurrentName())) {\n-                    currentIndex = parser.getValueAsString(\"\");\n-                }\n-                if (\"error\".equals(parser.getCurrentName())) {\n-                    parser.nextToken(); // Skip name\n-                    final ErrorInfo error = processError(MAPPER.readTree(parser), currentId, currentIndex);\n-                    errorInfos.put(currentId, error);\n-                    switch (error.getType()) {\n-                        case RETRYABLE:\n-                            retryableErrorCount++;\n-                            break;\n-                        case NON_RETRYABLE:\n-                            nonRetryableErrorCount++;\n-                            break;\n-                        case UNKNOWN:\n-                            unknownErrorCount++;\n-                            break;\n-                        default:\n-                            throw new RuntimeException(String.format(\"Unsupported error type '%s'\", error.getType()));\n-                    }\n-                }\n-            }\n-\n-            retryableErrorsMeter.mark(retryableErrorCount);\n-            nonRetryableErrorsMeter.mark(nonRetryableErrorCount);\n-            unknownErrorsMeter.mark(unknownErrorCount);\n-\n-            return new Result(retryableErrorCount, nonRetryableErrorCount, unknownErrorCount, errorInfos);\n-        });\n+                       if (\"errors\".equals(parser.getCurrentName())) {\n+                           if (Boolean.FALSE.equals(parser.nextBooleanValue())) {\n+                               return Result.OK;\n+                           }\n+                       }\n+                       if (\"_id\".equals(parser.getCurrentName())) {\n+                           currentId = parser.getValueAsString(\"\");\n+                       }\n+                       if (\"_index\".equals(parser.getCurrentName())) {\n+                           currentIndex = parser.getValueAsString(\"\");\n+                       }\n+                       if (\"error\".equals(parser.getCurrentName())) {\n+                           parser.nextToken(); // Skip name\n+\n+\n+                           final ErrorInfo error = processError(MAPPER.readTree(parser), currentId, currentIndex);\n+                           errorInfos.put(currentId, error);\n+                           switch (error.getType()) {\n+                               case RETRYABLE:\n+                                   retryableErrorCount++;\n+                                   break;\n+                               case NON_RETRYABLE:\n+                                   nonRetryableErrorCount++;\n+                                   break;\n+                               case UNKNOWN:\n+                                   unknownErrorCount++;\n+                                   break;\n+                               default:\n+                                   throw new RuntimeException(String.format(\"Unsupported error type '%s'\", error.getType()));\n+                           }\n+                       }\n+                   }\n+\n+                   retryableErrorsMeter.mark(retryableErrorCount);\n+                   nonRetryableErrorsMeter.mark(nonRetryableErrorCount);\n+                   unknownErrorsMeter.mark(unknownErrorCount);\n+                   return new Result(retryableErrorCount, nonRetryableErrorCount, unknownErrorCount, errorInfos);\n+               });\n     }\n \n     /**\n@@ -311,22 +164,22 @@ public class ElasticResponseHandler {\n      * @param index               index\n      * @return error type, which determines retryability of the error\n      */\n+\n     private ErrorInfo processError(TreeNode errorNode, String id, String index) {\n         if (errorNode instanceof ObjectNode) {\n             ObjectNode error = (ObjectNode) errorNode;\n             LOGGER.warn(\"Original error: {}\", error);\n \n-            final String type = Optional.ofNullable(error.get(\"type\"))\n-                    .map(JsonNode::asText)\n-                    .orElse(\"\");\n \n+            final String type = Optional.ofNullable(error.get(\"type\"))\n+            .map(JsonNode::asText)\n+            .orElse(\"\");\n             final String reason = Optional.ofNullable(error.get(\"reason\"))\n-                    .map(JsonNode::asText)\n-                    .orElse(\"\")\n-                    .replaceAll(\"[\\\\r\\\\n]+\", \" \");\n+            .map(JsonNode::asText)\n+            .orElse(\"\")\n+            .replaceAll(\"[\\\\r\\\\n]+\", \" \");\n \n             //TODO: Build \"caused by\" trace\n-\n             errorTypesMeter.computeIfAbsent(type, this::createMeter).mark();\n             if (shouldCreateIndexIfAbsent && \"index_not_found_exception\".equals(type)) {\n                 LOGGER.info(\"Index \" + index + \" not found, will create\");\n@@ -335,6 +188,7 @@ public class ElasticResponseHandler {\n                 } else {\n                     LOGGER.warn(\"Cannot create index \" + index + \", will retry anyway\");\n                 }\n+\n                 indexCreator.waitForIndexReadiness(index);\n                 return new ErrorInfo(ErrorType.RETRYABLE, error.toString());\n             }\n@@ -342,15 +196,21 @@ public class ElasticResponseHandler {\n                 LOGGER.warn(\"Retryable error which will be regarded as non-retryable: index={}, id={}, type={}, reason={}\", index, id, type, reason);\n                 return new ErrorInfo(ErrorType.NON_RETRYABLE, error.toString());\n             } else if (RETRYABLE_ERRORS_CODES.contains(type)) {\n-                LOGGER.warn(\"Retryable error: index={}, id={}, type={}, reason={}\", index, id, type, reason);\n-                return new ErrorInfo(ErrorType.RETRYABLE, error.toString());\n+                       LOGGER.warn(\"Retryable error: index={}, id={}, type={}, reason={}\", index, id, type, reason);\n+                       return new ErrorInfo(ErrorType.RETRYABLE, error.toString());\n             } else if (NON_RETRYABLE_ERRORS_CODES.contains(type)) {\n-                LOGGER.warn(\"Non retryable error: index={}, id={}, type={}, reason={}\", index, id, type, reason);\n-                return new ErrorInfo(ErrorType.NON_RETRYABLE, error.toString());\n-            } else {\n-                LOGGER.warn(\"Unknown error: index={}, id={}, type={}, reason={}\", index, id, type, reason);\n-                return new ErrorInfo(ErrorType.UNKNOWN, error.toString());\n-            }\n+                       LOGGER.warn(\n+                           \"Non retryable error: index={}, id={}, type={}, reason={}\",\n+                           index,\n+                           id,\n+                           type,\n+                           reason\n+                       );\n+                       return new ErrorInfo(ErrorType.NON_RETRYABLE, error.toString());\n+                   } else {\n+                       LOGGER.warn(\"Unknown error: index={}, id={}, type={}, reason={}\", index, id, type, reason);\n+                       return new ErrorInfo(ErrorType.UNKNOWN, error.toString());\n+                   }\n         } else {\n             String errorMessage = \"Error node is not object node, cannot parse\";\n             LOGGER.warn(errorMessage);\n@@ -361,4 +221,4 @@ public class ElasticResponseHandler {\n     private Meter createMeter(final String errorType) {\n         return metricsCollector.meter(METRIC_PREFIX + \".errorTypes.\" + MetricsUtil.sanitizeMetricName(errorType));\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 239
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "237",
                    "severity": "warning",
                    "message": "Line is longer than 160 characters (found 172).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "239",
                    "column": "9",
                    "severity": "warning",
                    "message": "'{' at column 9 should be on the previous line.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.blocks.LeftCurlyCheck"
                },
                {
                    "line": "239",
                    "column": "9",
                    "severity": "warning",
                    "message": "'{' at column 9 should have line break after.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.blocks.LeftCurlyCheck"
                },
                {
                    "line": "239",
                    "column": "9",
                    "severity": "warning",
                    "message": "'{' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/45/ElasticResponseHandler.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/styler_random/45/ElasticResponseHandler.java\nindex dc836b9a30f..07fa83e1cd7 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/45/ElasticResponseHandler.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/styler_random/45/ElasticResponseHandler.java\n@@ -234,9 +234,9 @@ public class ElasticResponseHandler {\n     private final Meter nonRetryableErrorsMeter;\n     private final Meter unknownErrorsMeter;\n \n-\n-    public ElasticResponseHandler(Set<String> redefinedExceptions, boolean shouldCreateIndexIfAbsent, IndexCreator indexCreator, final MetricsCollector metricsCollector) {\n-        this.redefinedExceptions = redefinedExceptions;\n+        public ElasticResponseHandler(Set<String>redefinedExceptions , boolean shouldCreateIndexIfAbsent,IndexCreator indexCreator , final MetricsCollector metricsCollector\n+        )\n+        {this.redefinedExceptions = redefinedExceptions;\n         this.shouldCreateIndexIfAbsent = shouldCreateIndexIfAbsent;\n         this.indexCreator = indexCreator;\n         this.metricsCollector = metricsCollector;\n",
            "diff_size": 3
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "236",
                    "severity": "warning",
                    "message": "Line is longer than 160 characters (found 171).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/45/ElasticResponseHandler.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/styler_three_grams/45/ElasticResponseHandler.java\nindex dc836b9a30f..afae8c3dcc7 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/45/ElasticResponseHandler.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/styler_three_grams/45/ElasticResponseHandler.java\n@@ -233,8 +233,6 @@ public class ElasticResponseHandler {\n     private final Meter retryableErrorsMeter;\n     private final Meter nonRetryableErrorsMeter;\n     private final Meter unknownErrorsMeter;\n-\n-\n     public ElasticResponseHandler(Set<String> redefinedExceptions, boolean shouldCreateIndexIfAbsent, IndexCreator indexCreator, final MetricsCollector metricsCollector) {\n         this.redefinedExceptions = redefinedExceptions;\n         this.shouldCreateIndexIfAbsent = shouldCreateIndexIfAbsent;\n",
            "diff_size": 2
        }
    ],
    "repaired_by": [
        "intellij"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}