{
    "project_name": "IQSS-dataverse",
    "error_id": "17",
    "information": {
        "errors": [
            {
                "line": "1597",
                "column": "9",
                "severity": "error",
                "message": "File contains tab characters (this is the first instance).",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
            }
        ]
    },
    "source_code": "        S3AccessIO<?> s3io = FileUtil.getS3AccessForDirectUpload(dataset);\n        if(s3io == null) {\n        \tFacesContext.getCurrentInstance().addMessage(uploadComponentId, new FacesMessage(FacesMessage.SEVERITY_ERROR, BundleUtil.getStringFromBundle(\"dataset.file.uploadWarning\"), \"Direct upload not supported for this dataset\"));\n        }\n        String url = null;\n        String storageIdentifier = null;",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "1602",
                    "column": "9",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/17/EditDatafilesPage.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler/17/EditDatafilesPage.java\nindex 7d190618330..33b2c567a2c 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/17/EditDatafilesPage.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler/17/EditDatafilesPage.java\n@@ -1594,7 +1594,7 @@ public class EditDatafilesPage implements java.io.Serializable {\n         \n         S3AccessIO<?> s3io = FileUtil.getS3AccessForDirectUpload(dataset);\n         if(s3io == null) {\n-        \tFacesContext.getCurrentInstance().addMessage(uploadComponentId, new FacesMessage(FacesMessage.SEVERITY_ERROR, BundleUtil.getStringFromBundle(\"dataset.file.uploadWarning\"), \"Direct upload not supported for this dataset\"));\n+    FacesContext.getCurrentInstance().addMessage(uploadComponentId, new FacesMessage(FacesMessage.SEVERITY_ERROR, BundleUtil.getStringFromBundle(\"dataset.file.uploadWarning\"), \"Direct upload not supported for this dataset\"));\n         }\n         String url = null;\n         String storageIdentifier = null;\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "2076",
                    "column": "1",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/17/EditDatafilesPage.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/intellij/17/EditDatafilesPage.java\nindex 7d190618330..ee81cdb00f8 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/17/EditDatafilesPage.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/intellij/17/EditDatafilesPage.java\n@@ -81,184 +81,190 @@ import org.apache.commons.lang3.mutable.MutableBoolean;\n import org.primefaces.PrimeFaces;\n \n /**\n- *\n  * @author Leonid Andreev\n  */\n @ViewScoped\n @Named(\"EditDatafilesPage\")\n public class EditDatafilesPage implements java.io.Serializable {\n \n-    private static final Logger logger = Logger.getLogger(EditDatafilesPage.class.getCanonicalName());\n+  private static final Logger logger = Logger.getLogger(EditDatafilesPage.class.getCanonicalName());\n+\n+  public enum FileEditMode {\n+\n+    EDIT, UPLOAD, CREATE, REPLACE\n+  }\n+\n+  ;\n+\n+  public enum Referrer {\n+    DATASET, FILE\n+  }\n+\n+  ;\n+\n+  @EJB\n+  DatasetServiceBean datasetService;\n+  @EJB\n+  DataverseServiceBean dataverseService;\n+  @EJB\n+  DatasetVersionServiceBean datasetVersionService;\n+  @EJB\n+  DataFileServiceBean datafileService;\n+  @EJB\n+  PermissionServiceBean permissionService;\n+  @EJB\n+  IngestServiceBean ingestService;\n+  @EJB\n+  EjbDataverseEngine commandEngine;\n+  @Inject\n+  DataverseSession session;\n+  @EJB\n+  UserNotificationServiceBean userNotificationService;\n+  @EJB\n+  SettingsServiceBean settingsService;\n+  @EJB\n+  AuthenticationServiceBean authService;\n+  @EJB\n+  SystemConfig systemConfig;\n+  @EJB\n+  DataverseLinkingServiceBean dvLinkingService;\n+  @EJB\n+  IndexServiceBean indexService;\n+  @Inject\n+  DataverseRequestServiceBean dvRequestService;\n+  @Inject\n+  PermissionsWrapper permissionsWrapper;\n+  @Inject\n+  FileDownloadHelper fileDownloadHelper;\n+  @Inject\n+  ProvPopupFragmentBean provPopupFragmentBean;\n+  @Inject\n+  SettingsWrapper settingsWrapper;\n+\n+  private Dataset dataset = new Dataset();\n+\n+  private FileReplacePageHelper fileReplacePageHelper;\n+\n+\n+  private String selectedFileIdsString = null;\n+  private FileEditMode mode;\n+  private Referrer referrer = Referrer.DATASET;\n+  private List<Long> selectedFileIdsList = new ArrayList<>();\n+  private List<FileMetadata> fileMetadatas = new ArrayList<>();\n+  ;\n+\n+\n+  private Long ownerId;\n+  private Long versionId;\n+  private List<DataFile> newFiles = new ArrayList<>();\n+  private List<DataFile> uploadedFiles = new ArrayList<>();\n+  private List<DataFile> uploadedInThisProcess = new ArrayList<>();\n+\n+  private DatasetVersion workingVersion;\n+  private DatasetVersion clone;\n+  private String dropBoxSelection = \"\";\n+  private String displayCitation;\n+  private boolean tabularDataTagsUpdated = false;\n+\n+  private String persistentId;\n+\n+  private String versionString = \"\";\n+\n+\n+  private boolean saveEnabled = false;\n+\n+  // Used to store results of permissions checks\n+  private final Map<String, Boolean> datasetPermissionMap = new HashMap<>(); // { Permission human_name : Boolean }\n+\n+  private Long maxFileUploadSizeInBytes = null;\n+  private Integer multipleUploadFilesLimit = null;\n+\n+  //MutableBoolean so it can be passed from DatasetPage, supporting DatasetPage.cancelCreate()\n+  private MutableBoolean uploadInProgress = null;\n+\n+  private final int NUMBER_OF_SCROLL_ROWS = 25;\n+\n+  private DataFile singleFile = null;\n+\n+  public DataFile getSingleFile() {\n+    return singleFile;\n+  }\n+\n+  public void setSingleFile(DataFile singleFile) {\n+    this.singleFile = singleFile;\n+  }\n+\n+  public String getSelectedFileIds() {\n+    return selectedFileIdsString;\n+  }\n+\n+  public DataFile getFileToReplace() {\n+    if (!this.isFileReplaceOperation()) {\n+      return null;\n+    }\n+    if (this.fileReplacePageHelper == null) {\n+      return null;\n+    }\n+    return this.fileReplacePageHelper.getFileToReplace();\n+  }\n+\n+  public void setSelectedFileIds(String selectedFileIds) {\n+    selectedFileIdsString = selectedFileIds;\n+  }\n+\n+  public FileEditMode getMode() {\n+    return mode;\n+  }\n+\n+  public void setMode(FileEditMode mode) {\n+    this.mode = mode;\n+  }\n \n-    public enum FileEditMode {\n+  public Referrer getReferrer() {\n+    return referrer;\n+  }\n \n-        EDIT, UPLOAD, CREATE, REPLACE\n-    };\n-    \n-    public enum Referrer {\n-        DATASET, FILE\n-    };\n-    \n-    @EJB\n-    DatasetServiceBean datasetService;\n-    @EJB\n-    DataverseServiceBean dataverseService;\n-    @EJB\n-    DatasetVersionServiceBean datasetVersionService;\n-    @EJB\n-    DataFileServiceBean datafileService;\n-    @EJB\n-    PermissionServiceBean permissionService;\n-    @EJB\n-    IngestServiceBean ingestService;\n-    @EJB\n-    EjbDataverseEngine commandEngine;\n-    @Inject\n-    DataverseSession session;\n-    @EJB\n-    UserNotificationServiceBean userNotificationService;\n-    @EJB\n-    SettingsServiceBean settingsService;\n-    @EJB\n-    AuthenticationServiceBean authService;\n-    @EJB\n-    SystemConfig systemConfig;\n-    @EJB\n-    DataverseLinkingServiceBean dvLinkingService;\n-    @EJB\n-    IndexServiceBean indexService;\n-    @Inject\n-    DataverseRequestServiceBean dvRequestService;\n-    @Inject PermissionsWrapper permissionsWrapper;\n-    @Inject FileDownloadHelper fileDownloadHelper;\n-    @Inject ProvPopupFragmentBean provPopupFragmentBean;\n-    @Inject\n-    SettingsWrapper settingsWrapper;\n-\n-    private Dataset dataset = new Dataset();\n-    \n-    private FileReplacePageHelper fileReplacePageHelper;\n-\n-\n-    private String selectedFileIdsString = null; \n-    private FileEditMode mode; \n-    private Referrer referrer = Referrer.DATASET;\n-    private List<Long> selectedFileIdsList = new ArrayList<>(); \n-    private List<FileMetadata> fileMetadatas = new ArrayList<>();;\n-\n-    \n-    private Long ownerId;\n-    private Long versionId;\n-    private List<DataFile> newFiles = new ArrayList<>();\n-    private List<DataFile> uploadedFiles = new ArrayList<>();\n-    private List<DataFile> uploadedInThisProcess = new ArrayList<>();\n-    \n-    private DatasetVersion workingVersion;\n-    private DatasetVersion clone;\n-    private String dropBoxSelection = \"\";\n-    private String displayCitation;\n-    private boolean tabularDataTagsUpdated = false; \n-    \n-    private String persistentId;\n-    \n-    private String versionString = \"\";\n-            \n-    \n-    private boolean saveEnabled = false; \n+  public void setReferrer(Referrer referrer) {\n+    this.referrer = referrer;\n+  }\n \n-    // Used to store results of permissions checks\n-    private final Map<String, Boolean> datasetPermissionMap = new HashMap<>(); // { Permission human_name : Boolean }\n \n-    private Long maxFileUploadSizeInBytes = null;\n-    private Integer multipleUploadFilesLimit = null; \n-    \n-    //MutableBoolean so it can be passed from DatasetPage, supporting DatasetPage.cancelCreate()\n-    private MutableBoolean uploadInProgress = null;\n-    \n-    private final int NUMBER_OF_SCROLL_ROWS = 25;\n-    \n-    private DataFile singleFile = null;\n+  public List<FileMetadata> getFileMetadatas() {\n \n-    public DataFile getSingleFile() {\n-        return singleFile;\n+    // -------------------------------------\n+    // Handle a Replace operation\n+    //  - The List<FileMetadata> comes from a different source\n+    // -------------------------------------\n+    if (isFileReplaceOperation()) {\n+      if (fileReplacePageHelper.wasPhase1Successful()) {\n+        logger.fine(\"Replace: File metadatas 'list' of 1 from the fileReplacePageHelper.\");\n+        return fileReplacePageHelper.getNewFileMetadatasBeforeSave();\n+      } else {\n+        logger.fine(\"Replace: replacement file not yet uploaded.\");\n+        return null;\n+      }\n     }\n \n-    public void setSingleFile(DataFile singleFile) {\n-        this.singleFile = singleFile;\n-    }\n-    \n-    public String getSelectedFileIds() {\n-        return selectedFileIdsString;\n-    }\n-    \n-    public DataFile getFileToReplace(){\n-        if (!this.isFileReplaceOperation()){\n-            return null;\n-        }\n-        if (this.fileReplacePageHelper == null){\n-            return null;\n-        }\n-        return this.fileReplacePageHelper.getFileToReplace();\n-    }\n-    \n-    public void setSelectedFileIds(String selectedFileIds) {\n-        selectedFileIdsString = selectedFileIds;\n-    }\n-    \n-    public FileEditMode getMode() {\n-        return mode;\n-    }\n-    \n-    public void setMode(FileEditMode mode) {\n-        this.mode = mode;\n+    if (fileMetadatas != null) {\n+      logger.fine(\"Returning a list of \" + fileMetadatas.size() + \" file metadatas.\");\n+    } else {\n+      logger.fine(\"File metadatas list hasn't been initialized yet.\");\n     }\n+    // [experimental]\n+    // this would be a way to hide any already-uploaded files from the page\n+    // while a new upload is happening:\n+    // (the uploadStarted button on the page needs the update=\"filesTable\"\n+    // attribute added for this to work)\n+    //if (uploadInProgress) {\n+    //    return null;\n+    //}\n \n-    public Referrer getReferrer() {\n-        return referrer;\n-    }\n+    return fileMetadatas;\n+  }\n \n-    public void setReferrer(Referrer referrer) {\n-        this.referrer = referrer;\n-    }\n-    \n-    \n-    \n-    public List<FileMetadata> getFileMetadatas() {\n-        \n-        // -------------------------------------\n-        // Handle a Replace operation\n-        //  - The List<FileMetadata> comes from a different source\n-        // -------------------------------------\n-        if (isFileReplaceOperation()){\n-            if (fileReplacePageHelper.wasPhase1Successful()){\n-                logger.fine(\"Replace: File metadatas 'list' of 1 from the fileReplacePageHelper.\");\n-                return fileReplacePageHelper.getNewFileMetadatasBeforeSave();\n-            } else {\n-                logger.fine(\"Replace: replacement file not yet uploaded.\");\n-                return null;\n-            }            \n-        }\n-        \n-        if (fileMetadatas != null) {\n-            logger.fine(\"Returning a list of \"+fileMetadatas.size()+\" file metadatas.\");\n-        } else {\n-            logger.fine(\"File metadatas list hasn't been initialized yet.\");\n-        }\n-        // [experimental] \n-        // this would be a way to hide any already-uploaded files from the page\n-        // while a new upload is happening:\n-        // (the uploadStarted button on the page needs the update=\"filesTable\"\n-        // attribute added for this to work)\n-        //if (uploadInProgress) {\n-        //    return null; \n-        //}\n-        \n-        return fileMetadatas;\n-    }\n-  \n-    public void setFileMetadatas(List<FileMetadata> fileMetadatas) {\n-        this.fileMetadatas = fileMetadatas;\n-    }\n+  public void setFileMetadatas(List<FileMetadata> fileMetadatas) {\n+    this.fileMetadatas = fileMetadatas;\n+  }\n     \n     /* \n         The 2 methods below are for setting up the PrimeFaces:dataTabe component\n@@ -281,28 +287,28 @@ public class EditDatafilesPage implements java.io.Serializable {\n           of the p:dataTable component only applies when \"liveScroll=true\" is being\n           used). \n     */\n-    \n-    public boolean isScrollable() {\n-        return !(fileMetadatas == null || fileMetadatas.size() <= NUMBER_OF_SCROLL_ROWS + 1);\n+\n+  public boolean isScrollable() {\n+    return !(fileMetadatas == null || fileMetadatas.size() <= NUMBER_OF_SCROLL_ROWS + 1);\n+  }\n+\n+  public String getScrollHeightPercentage() {\n+    int perc;\n+    if (fileMetadatas == null || fileMetadatas.size() < NUMBER_OF_SCROLL_ROWS) {\n+      perc = 100;\n+    } else {\n+      perc = NUMBER_OF_SCROLL_ROWS * 100 / fileMetadatas.size();\n     }\n-    \n-    public String getScrollHeightPercentage() {\n-        int perc; \n-        if (fileMetadatas == null || fileMetadatas.size() < NUMBER_OF_SCROLL_ROWS) {\n-            perc = 100;\n-        } else {\n-            perc = NUMBER_OF_SCROLL_ROWS * 100 / fileMetadatas.size();\n-        }\n-        \n-        if (perc == 0) {\n-            perc = 1;\n-        } else if (perc > 100) {\n-            perc = 100;\n-        }\n-        \n-        logger.fine(\"scroll height percentage: \"+perc);\n-        return perc + \"%\";\n+\n+    if (perc == 0) {\n+      perc = 1;\n+    } else if (perc > 100) {\n+      perc = 100;\n     }\n+\n+    logger.fine(\"scroll height percentage: \" + perc);\n+    return perc + \"%\";\n+  }\n     \n     /*\n         Any settings, such as the upload size limits, should be saved locally - \n@@ -311,472 +317,477 @@ public class EditDatafilesPage implements java.io.Serializable {\n     \n         This may be \"null\", signifying unlimited download size.\n     */\n-    \n-    public Long getMaxFileUploadSizeInBytes() {\n-        return this.maxFileUploadSizeInBytes;\n-    }\n-    \n-    public String getHumanMaxFileUploadSizeInBytes() {\n-        return FileSizeChecker.bytesToHumanReadable(this.maxFileUploadSizeInBytes);\n-    }\n-    \n-    public boolean isUnlimitedUploadFileSize() {\n-        \n-        return this.maxFileUploadSizeInBytes == null;\n-    }\n-    \n-    /*\n-        The number of files the GUI user is allowed to upload in one batch, \n-        via drag-and-drop, or through the file select dialog. Now configurable \n-        in the Settings table. \n-    */\n-    public Integer getMaxNumberOfFiles() {\n-        return this.multipleUploadFilesLimit;\n-    }\n-    /**\n-     * Check Dataset related permissions\n-     * \n-     * @param permissionToCheck\n-     * @return \n-     */\n-    public boolean doesSessionUserHaveDataSetPermission(Permission permissionToCheck){\n-        if (permissionToCheck == null){\n-            return false;\n-        }\n-               \n-        String permName = permissionToCheck.getHumanName();\n-       \n-        // Has this check already been done? \n-        // \n-        if (this.datasetPermissionMap.containsKey(permName)){\n-            // Yes, return previous answer\n-            return this.datasetPermissionMap.get(permName);\n-        }\n-        \n-        // Check the permission\n-        //\n-        boolean hasPermission = this.permissionService.userOn(this.session.getUser(), this.dataset).has(permissionToCheck);\n \n-        // Save the permission\n-        this.datasetPermissionMap.put(permName, hasPermission);\n-        \n-        // return true/false\n-        return hasPermission;\n-    }\n-    \n-    public void reset() {\n-        // ?\n-    }\n+  public Long getMaxFileUploadSizeInBytes() {\n+    return this.maxFileUploadSizeInBytes;\n+  }\n \n-    public String getGlobalId() {\n-        return persistentId;\n-    }\n-        \n-    public String getPersistentId() {\n-        return persistentId;\n-    }\n+  public String getHumanMaxFileUploadSizeInBytes() {\n+    return FileSizeChecker.bytesToHumanReadable(this.maxFileUploadSizeInBytes);\n+  }\n \n-    public void setPersistentId(String persistentId) {\n-        this.persistentId = persistentId;\n-    }\n+  public boolean isUnlimitedUploadFileSize() {\n \n-    public String getDisplayCitation() {\n-        //displayCitation = dataset.getCitation(false, workingVersion);\n-        return displayCitation;\n-    }\n+    return this.maxFileUploadSizeInBytes == null;\n+  }\n \n-    public void setDisplayCitation(String displayCitation) {\n-        this.displayCitation = displayCitation;\n-    }\n+  /*\n+      The number of files the GUI user is allowed to upload in one batch,\n+      via drag-and-drop, or through the file select dialog. Now configurable\n+      in the Settings table.\n+  */\n+  public Integer getMaxNumberOfFiles() {\n+    return this.multipleUploadFilesLimit;\n+  }\n \n-    public String getDropBoxSelection() {\n-        return dropBoxSelection;\n-    }\n+  /**\n+   * Check Dataset related permissions\n+   *\n+   * @param permissionToCheck\n+   * @return\n+   */\n+  public boolean doesSessionUserHaveDataSetPermission(Permission permissionToCheck) {\n+    if (permissionToCheck == null) {\n+      return false;\n+    }\n \n-    public String getDropBoxKey() {\n-        // Site-specific DropBox application registration key is configured \n-        // via a JVM option under glassfish.\n-        //if (true)return \"some-test-key\";  // for debugging\n+    String permName = permissionToCheck.getHumanName();\n \n-        String configuredDropBoxKey = System.getProperty(\"dataverse.dropbox.key\");\n-        if (configuredDropBoxKey != null) {\n-            return configuredDropBoxKey;\n-        }\n-        return \"\";\n+    // Has this check already been done?\n+    //\n+    if (this.datasetPermissionMap.containsKey(permName)) {\n+      // Yes, return previous answer\n+      return this.datasetPermissionMap.get(permName);\n     }\n \n-    public void setDropBoxSelection(String dropBoxSelection) {\n-        this.dropBoxSelection = dropBoxSelection;\n-    }\n+    // Check the permission\n+    //\n+    boolean hasPermission = this.permissionService.userOn(this.session.getUser(), this.dataset).has(permissionToCheck);\n+\n+    // Save the permission\n+    this.datasetPermissionMap.put(permName, hasPermission);\n+\n+    // return true/false\n+    return hasPermission;\n+  }\n+\n+  public void reset() {\n+    // ?\n+  }\n+\n+  public String getGlobalId() {\n+    return persistentId;\n+  }\n \n-    public Dataset getDataset() {\n-        return dataset;\n+  public String getPersistentId() {\n+    return persistentId;\n+  }\n+\n+  public void setPersistentId(String persistentId) {\n+    this.persistentId = persistentId;\n+  }\n+\n+  public String getDisplayCitation() {\n+    //displayCitation = dataset.getCitation(false, workingVersion);\n+    return displayCitation;\n+  }\n+\n+  public void setDisplayCitation(String displayCitation) {\n+    this.displayCitation = displayCitation;\n+  }\n+\n+  public String getDropBoxSelection() {\n+    return dropBoxSelection;\n+  }\n+\n+  public String getDropBoxKey() {\n+    // Site-specific DropBox application registration key is configured\n+    // via a JVM option under glassfish.\n+    //if (true)return \"some-test-key\";  // for debugging\n+\n+    String configuredDropBoxKey = System.getProperty(\"dataverse.dropbox.key\");\n+    if (configuredDropBoxKey != null) {\n+      return configuredDropBoxKey;\n     }\n+    return \"\";\n+  }\n+\n+  public void setDropBoxSelection(String dropBoxSelection) {\n+    this.dropBoxSelection = dropBoxSelection;\n+  }\n+\n+  public Dataset getDataset() {\n+    return dataset;\n+  }\n \n-    public void setDataset(Dataset dataset) {\n-        this.dataset = dataset;\n+  public void setDataset(Dataset dataset) {\n+    this.dataset = dataset;\n+  }\n+\n+  public DatasetVersion getWorkingVersion() {\n+    return workingVersion;\n+  }\n+\n+  public Long getOwnerId() {\n+    return ownerId;\n+  }\n+\n+  public void setOwnerId(Long ownerId) {\n+    this.ownerId = ownerId;\n+  }\n+\n+  public Long getVersionId() {\n+    return versionId;\n+  }\n+\n+  public void setVersionId(Long versionId) {\n+    this.versionId = versionId;\n+  }\n+\n+  public String initCreateMode(String modeToken, DatasetVersion version, MutableBoolean inProgress,\n+                               List<DataFile> newFilesList, List<DataFile> uploadedFilesList,\n+                               List<FileMetadata> selectedFileMetadatasList) {\n+    if (modeToken == null) {\n+      logger.fine(\"Request to initialize Edit Files page with null token (aborting).\");\n+      return null;\n     }\n \n-    public DatasetVersion getWorkingVersion() {\n-        return workingVersion;\n+    if (!modeToken.equals(\"CREATE\")) {\n+      logger.fine(\"Request to initialize Edit Files page with token \" + modeToken + \" (aborting).\");\n+      return null;\n     }\n \n-    public Long getOwnerId() {\n-        return ownerId;\n+    logger.fine(\"Initializing Edit Files page in CREATE mode;\");\n+\n+    if (version == null) {\n+      return permissionsWrapper.notFound();\n     }\n \n-    public void setOwnerId(Long ownerId) {\n-        this.ownerId = ownerId;\n+    workingVersion = version;\n+    dataset = version.getDataset();\n+    mode = FileEditMode.CREATE;\n+    uploadInProgress = inProgress;\n+    newFiles = newFilesList;\n+    uploadedFiles = uploadedFilesList;\n+    selectedFiles = selectedFileMetadatasList;\n+\n+    this.maxFileUploadSizeInBytes = systemConfig.getMaxFileUploadSizeForStore(dataset.getEffectiveStorageDriverId());\n+    this.multipleUploadFilesLimit = systemConfig.getMultipleUploadFilesLimit();\n+\n+    logger.fine(\"done\");\n+\n+    saveEnabled = true;\n+    return null;\n+  }\n+\n+\n+  public String init() {\n+    // default mode should be EDIT\n+    if (mode == null) {\n+      mode = FileEditMode.EDIT;\n     }\n \n-    public Long getVersionId() {\n-        return versionId;\n+    newFiles = new ArrayList<>();\n+    uploadedFiles = new ArrayList<>();\n+    uploadInProgress = new MutableBoolean(false);\n+\n+    if (dataset.getId() != null) {\n+      // Set Working Version and Dataset by Datasaet Id and Version\n+      //retrieveDatasetVersionResponse = datasetVersionService.retrieveDatasetVersionById(dataset.getId(), null);\n+      dataset = datasetService.find(dataset.getId());\n+      // Is the Dataset harvested? (because we don't allow editing of harvested\n+      // files!)\n+      if (dataset == null || dataset.isHarvested()) {\n+        return permissionsWrapper.notFound();\n+      }\n+    } else {\n+      // It could be better to show an error page of some sort, explaining\n+      // that the dataset id is mandatory... But 404 will do for now.\n+      return permissionsWrapper.notFound();\n     }\n \n-    public void setVersionId(Long versionId) {\n-        this.versionId = versionId;\n+    workingVersion = dataset.getEditVersion();\n+\n+    //TODO: review if we we need this check;\n+    // as getEditVersion should either return the exisiting draft or create a new one\n+    if (workingVersion == null || !workingVersion.isDraft()) {\n+      // Sorry, we couldn't find/obtain a draft version for this dataset!\n+      return permissionsWrapper.notFound();\n     }\n \n-    public String initCreateMode(String modeToken, DatasetVersion version, MutableBoolean inProgress, List<DataFile> newFilesList, List<DataFile> uploadedFilesList, List<FileMetadata> selectedFileMetadatasList) {\n-        if (modeToken == null) {\n-            logger.fine(\"Request to initialize Edit Files page with null token (aborting).\");\n-            return null;\n-        }\n-        \n-        if (!modeToken.equals(\"CREATE\")) {\n-            logger.fine(\"Request to initialize Edit Files page with token \" + modeToken + \" (aborting).\");\n-            return null; \n-        }\n-        \n-        logger.fine(\"Initializing Edit Files page in CREATE mode;\");\n-        \n-        if (version == null) {\n-            return permissionsWrapper.notFound();\n-        }   \n-        \n-        workingVersion = version; \n-        dataset = version.getDataset();\n-        mode = FileEditMode.CREATE;\n-        uploadInProgress= inProgress;\n-        newFiles = newFilesList;\n-        uploadedFiles = uploadedFilesList;\n-        selectedFiles = selectedFileMetadatasList;\n-        \n-        this.maxFileUploadSizeInBytes = systemConfig.getMaxFileUploadSizeForStore(dataset.getEffectiveStorageDriverId());\n-        this.multipleUploadFilesLimit = systemConfig.getMultipleUploadFilesLimit();\n-        \n-        logger.fine(\"done\");\n-        \n-        saveEnabled = true;\n-        return null; \n+    // Check if they have permission to modify this dataset:\n+    if (!permissionService.on(dataset).has(Permission.EditDataset)) {\n+      return permissionsWrapper.notAuthorized();\n     }\n-    \n \n-    public String init() {\n-        // default mode should be EDIT\n-        if (mode == null) {\n-            mode = FileEditMode.EDIT;\n-        }\n-        \n-        newFiles = new ArrayList<>();\n-        uploadedFiles = new ArrayList<>();\n-        uploadInProgress= new MutableBoolean(false);\n-        \n-        if (dataset.getId() != null){\n-            // Set Working Version and Dataset by Datasaet Id and Version\n-            //retrieveDatasetVersionResponse = datasetVersionService.retrieveDatasetVersionById(dataset.getId(), null);\n-            dataset = datasetService.find(dataset.getId());\n-            // Is the Dataset harvested? (because we don't allow editing of harvested \n-            // files!)\n-            if (dataset == null || dataset.isHarvested()) {\n-                return permissionsWrapper.notFound();\n-            }\n-        } else {\n-            // It could be better to show an error page of some sort, explaining\n-            // that the dataset id is mandatory... But 404 will do for now.\n-            return permissionsWrapper.notFound();\n-        }\n-                               \n-        workingVersion = dataset.getEditVersion();\n-        \n-        //TODO: review if we we need this check; \n-        // as getEditVersion should either return the exisiting draft or create a new one      \n-        if (workingVersion == null || !workingVersion.isDraft()) {\n-            // Sorry, we couldn't find/obtain a draft version for this dataset!\n-            return permissionsWrapper.notFound();\n-        }\n-        \n-        // Check if they have permission to modify this dataset: \n-        if (!permissionService.on(dataset).has(Permission.EditDataset)) {\n-            return permissionsWrapper.notAuthorized();\n-        }\n-        \n-        clone = workingVersion.cloneDatasetVersion();   \n-        this.maxFileUploadSizeInBytes = systemConfig.getMaxFileUploadSizeForStore(dataset.getEffectiveStorageDriverId());\n-        this.multipleUploadFilesLimit = systemConfig.getMultipleUploadFilesLimit();        \n-\n-        // -------------------------------------------\n-        //  Is this a file replacement operation?\n-        // -------------------------------------------\n-        if (mode == FileEditMode.REPLACE){\n+    clone = workingVersion.cloneDatasetVersion();\n+    this.maxFileUploadSizeInBytes = systemConfig.getMaxFileUploadSizeForStore(dataset.getEffectiveStorageDriverId());\n+    this.multipleUploadFilesLimit = systemConfig.getMultipleUploadFilesLimit();\n+\n+    // -------------------------------------------\n+    //  Is this a file replacement operation?\n+    // -------------------------------------------\n+    if (mode == FileEditMode.REPLACE) {\n             /*\n             http://localhost:8080/editdatafiles.xhtml?mode=REPLACE&datasetId=26&fid=726\n-            */        \n-            DataFile fileToReplace = loadFileToReplace();\n-            if (fileToReplace == null){\n-                return permissionsWrapper.notFound();\n-            }\n-            \n-            //DataverseRequest dvRequest2 = createDataverseRequest(authUser);\n-            AddReplaceFileHelper addReplaceFileHelper = new AddReplaceFileHelper(dvRequestService.getDataverseRequest(),\n-                                                ingestService,\n-                                                datasetService,\n-                                                datafileService,\n-                                                permissionService,\n-                                                commandEngine,\n-                                                systemConfig);\n-                        \n-            fileReplacePageHelper = new FileReplacePageHelper(addReplaceFileHelper,\n-                                                dataset, \n-                                                fileToReplace);\n-\n-            populateFileMetadatas();\n-            singleFile = getFileToReplace();\n-        }else if (mode == FileEditMode.EDIT) {\n-\n-            if (selectedFileIdsString != null) {\n-                String[] ids = selectedFileIdsString.split(\",\");\n-\n-                for (String id : ids) {\n-                    Long test = null;\n-                    try {\n-                        test = new Long(id);\n-                    } catch (NumberFormatException nfe) {\n-                        // do nothing...\n-                        test = null;\n-                    }\n-                    if (test != null) {\n-                        if (FileEditMode.EDIT == mode && Referrer.FILE == referrer) {\n-                            singleFile = datafileService.find(test);\n-                        }\n-                        selectedFileIdsList.add(test);\n-                    }\n-                }\n-            }\n+            */\n+      DataFile fileToReplace = loadFileToReplace();\n+      if (fileToReplace == null) {\n+        return permissionsWrapper.notFound();\n+      }\n+\n+      //DataverseRequest dvRequest2 = createDataverseRequest(authUser);\n+      AddReplaceFileHelper addReplaceFileHelper = new AddReplaceFileHelper(dvRequestService.getDataverseRequest(),\n+        ingestService,\n+        datasetService,\n+        datafileService,\n+        permissionService,\n+        commandEngine,\n+        systemConfig);\n+\n+      fileReplacePageHelper = new FileReplacePageHelper(addReplaceFileHelper,\n+        dataset,\n+        fileToReplace);\n+\n+      populateFileMetadatas();\n+      singleFile = getFileToReplace();\n+    } else if (mode == FileEditMode.EDIT) {\n \n-            if (selectedFileIdsList.size() < 1) {\n-                logger.fine(\"No numeric file ids supplied to the page, in the edit mode. Redirecting to the 404 page.\");\n-                // If no valid file IDs specified, send them to the 404 page...\n-                return permissionsWrapper.notFound();\n-            }\n+      if (selectedFileIdsString != null) {\n+        String[] ids = selectedFileIdsString.split(\",\");\n \n-            logger.fine(\"The page is called with \" + selectedFileIdsList.size() + \" file ids.\");\n-\n-            populateFileMetadatas();\n-            setUpRsync();\n-            // and if no filemetadatas can be found for the specified file ids \n-            // and version id - same deal, send them to the \"not found\" page. \n-            // (at least for now; ideally, we probably want to show them a page \n-            // with a more informative error message; something alonog the lines \n-            // of - could not find the files for the ids specified; or, these \n-            // datafiles are not present in the version specified, etc.\n-            if (fileMetadatas.size() < 1) {\n-                return permissionsWrapper.notFound();\n+        for (String id : ids) {\n+          Long test = null;\n+          try {\n+            test = new Long(id);\n+          } catch (NumberFormatException nfe) {\n+            // do nothing...\n+            test = null;\n+          }\n+          if (test != null) {\n+            if (FileEditMode.EDIT == mode && Referrer.FILE == referrer) {\n+              singleFile = datafileService.find(test);\n             }\n-            \n-            if (FileEditMode.EDIT == mode && Referrer.FILE == referrer){\n-                if (fileMetadatas.get(0).getDatasetVersion().getId() != null){\n-                    versionString = \"DRAFT\";\n-                }\n-            }    \n-                       \n-        }\n-        \n-        saveEnabled = true; \n-        if (mode == FileEditMode.UPLOAD && workingVersion.getFileMetadatas().isEmpty() && rsyncUploadSupported())  {\n-            setUpRsync();\n+            selectedFileIdsList.add(test);\n+          }\n         }\n+      }\n \n-        if (mode == FileEditMode.UPLOAD) {\n-            if (settingsWrapper.getUploadMethodsCount() == 1){\n-                JH.addMessage(FacesMessage.SEVERITY_INFO, BundleUtil.getStringFromBundle(\"dataset.message.uploadFiles.label\"), BundleUtil.getStringFromBundle(\"dataset.message.uploadFilesSingle.message\", Arrays.asList(systemConfig.getGuidesBaseUrl(), systemConfig.getGuidesVersion())));\n-            } else if (settingsWrapper.getUploadMethodsCount() > 1) {\n-                JH.addMessage(FacesMessage.SEVERITY_INFO, BundleUtil.getStringFromBundle(\"dataset.message.uploadFiles.label\"), BundleUtil.getStringFromBundle(\"dataset.message.uploadFilesMultiple.message\", Arrays.asList(systemConfig.getGuidesBaseUrl(), systemConfig.getGuidesVersion())));\n-            }\n-            \n-        }\n-        \n-        if (settingsService.isTrueForKey(SettingsServiceBean.Key.PublicInstall, false)){\n-            JH.addMessage(FacesMessage.SEVERITY_WARN, getBundleString(\"dataset.message.publicInstall\"));\n-        }   \n-        \n-        return null;\n-    }\n-    \n-    \n-    private void msg(String s){\n-        System.out.println(s);\n-    }\n-    \n-    /**\n-     * For single file replacement, load the file to replace\n-     * \n-     * @return \n-     */\n-    private DataFile loadFileToReplace(){\n-        \n-        Map<String, String> params =FacesContext.getCurrentInstance().\n-                                getExternalContext().getRequestParameterMap();\n-        \n-        if (params.containsKey(\"fid\")){\n-            String fid = params.get(\"fid\");\n-            if ((!fid.isEmpty()) && (StringUtils.isNumeric(fid))){\n-                selectedFileIdsList.add(Long.parseLong(fid));\n-                return datafileService.find(Long.parseLong(fid));\n-            }\n+      if (selectedFileIdsList.size() < 1) {\n+        logger.fine(\"No numeric file ids supplied to the page, in the edit mode. Redirecting to the 404 page.\");\n+        // If no valid file IDs specified, send them to the 404 page...\n+        return permissionsWrapper.notFound();\n+      }\n+\n+      logger.fine(\"The page is called with \" + selectedFileIdsList.size() + \" file ids.\");\n+\n+      populateFileMetadatas();\n+      setUpRsync();\n+      // and if no filemetadatas can be found for the specified file ids\n+      // and version id - same deal, send them to the \"not found\" page.\n+      // (at least for now; ideally, we probably want to show them a page\n+      // with a more informative error message; something alonog the lines\n+      // of - could not find the files for the ids specified; or, these\n+      // datafiles are not present in the version specified, etc.\n+      if (fileMetadatas.size() < 1) {\n+        return permissionsWrapper.notFound();\n+      }\n+\n+      if (FileEditMode.EDIT == mode && Referrer.FILE == referrer) {\n+        if (fileMetadatas.get(0).getDatasetVersion().getId() != null) {\n+          versionString = \"DRAFT\";\n         }\n-        return null;\n-        \n-    } // loadFileToReplace\n-    \n-    private List<FileMetadata> selectedFiles; // = new ArrayList<>();\n+      }\n \n-    public List<FileMetadata> getSelectedFiles() {\n-        return selectedFiles;\n     }\n \n-    public void setSelectedFiles(List<FileMetadata> selectedFiles) {\n-        this.selectedFiles = selectedFiles;\n+    saveEnabled = true;\n+    if (mode == FileEditMode.UPLOAD && workingVersion.getFileMetadatas().isEmpty() && rsyncUploadSupported()) {\n+      setUpRsync();\n     }\n-    \n-    private boolean selectAllFiles;\n \n-    public boolean isSelectAllFiles() {\n-        return selectAllFiles;\n+    if (mode == FileEditMode.UPLOAD) {\n+      if (settingsWrapper.getUploadMethodsCount() == 1) {\n+        JH.addMessage(FacesMessage.SEVERITY_INFO, BundleUtil.getStringFromBundle(\"dataset.message.uploadFiles.label\"),\n+          BundleUtil.getStringFromBundle(\"dataset.message.uploadFilesSingle.message\",\n+            Arrays.asList(systemConfig.getGuidesBaseUrl(), systemConfig.getGuidesVersion())));\n+      } else if (settingsWrapper.getUploadMethodsCount() > 1) {\n+        JH.addMessage(FacesMessage.SEVERITY_INFO, BundleUtil.getStringFromBundle(\"dataset.message.uploadFiles.label\"),\n+          BundleUtil.getStringFromBundle(\"dataset.message.uploadFilesMultiple.message\",\n+            Arrays.asList(systemConfig.getGuidesBaseUrl(), systemConfig.getGuidesVersion())));\n+      }\n+\n     }\n \n-    public void setSelectAllFiles(boolean selectAllFiles) {\n-        this.selectAllFiles = selectAllFiles;\n+    if (settingsService.isTrueForKey(SettingsServiceBean.Key.PublicInstall, false)) {\n+      JH.addMessage(FacesMessage.SEVERITY_WARN, getBundleString(\"dataset.message.publicInstall\"));\n     }\n-    \n-    public String getVersionString() {\n-        return versionString;\n+\n+    return null;\n+  }\n+\n+\n+  private void msg(String s) {\n+    System.out.println(s);\n+  }\n+\n+  /**\n+   * For single file replacement, load the file to replace\n+   *\n+   * @return\n+   */\n+  private DataFile loadFileToReplace() {\n+\n+    Map<String, String> params = FacesContext.getCurrentInstance().\n+      getExternalContext().getRequestParameterMap();\n+\n+    if (params.containsKey(\"fid\")) {\n+      String fid = params.get(\"fid\");\n+      if ((!fid.isEmpty()) && (StringUtils.isNumeric(fid))) {\n+        selectedFileIdsList.add(Long.parseLong(fid));\n+        return datafileService.find(Long.parseLong(fid));\n+      }\n     }\n+    return null;\n \n-    public void setVersionString(String versionString) {\n-        this.versionString = versionString;\n+  } // loadFileToReplace\n+\n+  private List<FileMetadata> selectedFiles; // = new ArrayList<>();\n+\n+  public List<FileMetadata> getSelectedFiles() {\n+    return selectedFiles;\n+  }\n+\n+  public void setSelectedFiles(List<FileMetadata> selectedFiles) {\n+    this.selectedFiles = selectedFiles;\n+  }\n+\n+  private boolean selectAllFiles;\n+\n+  public boolean isSelectAllFiles() {\n+    return selectAllFiles;\n+  }\n+\n+  public void setSelectAllFiles(boolean selectAllFiles) {\n+    this.selectAllFiles = selectAllFiles;\n+  }\n+\n+  public String getVersionString() {\n+    return versionString;\n+  }\n+\n+  public void setVersionString(String versionString) {\n+    this.versionString = versionString;\n+  }\n+\n+  public void restrictFiles(boolean restricted) throws UnsupportedOperationException {\n+\n+    if (restricted) { // get values from access popup\n+      workingVersion.getTermsOfUseAndAccess().setTermsOfAccess(termsOfAccess);\n+      workingVersion.getTermsOfUseAndAccess().setFileAccessRequest(fileAccessRequest);\n     }\n-    \n-    public void restrictFiles(boolean restricted) throws UnsupportedOperationException{\n-        \n-        if (restricted) { // get values from access popup\n-            workingVersion.getTermsOfUseAndAccess().setTermsOfAccess(termsOfAccess);\n-            workingVersion.getTermsOfUseAndAccess().setFileAccessRequest(fileAccessRequest);\n-        }\n-        \n-        String fileNames = null;\n-        \n-        for (FileMetadata fmd : this.getSelectedFiles()) {\n-            if (restricted && !fmd.isRestricted()) {\n-                // collect the names of the newly-restrticted files, \n-                // to show in the success message:\n-                if (fileNames == null) {\n-                    fileNames = fmd.getLabel();\n-                } else {\n-                    fileNames = fileNames.concat(\", \" + fmd.getLabel());\n-                }\n-            }\n-            fmd.setRestricted(restricted);\n-                                  \n-            if (workingVersion.isDraft() && !fmd.getDataFile().isReleased()) {\n-                // We do not really need to check that the working version is \n-                // a draft here - it must be a draft, if we've gotten this\n-                // far. But just in case. -- L.A. 4.2.1\n-                  fmd.getDataFile().setRestricted(restricted);              \n-            }\n-        }\n-        if (fileNames != null) {\n-            String successMessage = getBundleString(\"file.restricted.success\");\n-            logger.fine(successMessage);\n-            successMessage = successMessage.replace(\"{0}\", fileNames);\n-            JsfHelper.addFlashMessage(successMessage);    \n-        }\n-    } \n-    \n-    public int getRestrictedFileCount() {\n-        int restrictedFileCount = 0;\n-        for (FileMetadata fmd : workingVersion.getFileMetadatas()) {\n-            if (fmd.isRestricted()) {\n-                restrictedFileCount++;\n-            }\n+\n+    String fileNames = null;\n+\n+    for (FileMetadata fmd : this.getSelectedFiles()) {\n+      if (restricted && !fmd.isRestricted()) {\n+        // collect the names of the newly-restrticted files,\n+        // to show in the success message:\n+        if (fileNames == null) {\n+          fileNames = fmd.getLabel();\n+        } else {\n+          fileNames = fileNames.concat(\", \" + fmd.getLabel());\n         }\n+      }\n+      fmd.setRestricted(restricted);\n \n-        return restrictedFileCount;\n+      if (workingVersion.isDraft() && !fmd.getDataFile().isReleased()) {\n+        // We do not really need to check that the working version is\n+        // a draft here - it must be a draft, if we've gotten this\n+        // far. But just in case. -- L.A. 4.2.1\n+        fmd.getDataFile().setRestricted(restricted);\n+      }\n     }\n+    if (fileNames != null) {\n+      String successMessage = getBundleString(\"file.restricted.success\");\n+      logger.fine(successMessage);\n+      successMessage = successMessage.replace(\"{0}\", fileNames);\n+      JsfHelper.addFlashMessage(successMessage);\n+    }\n+  }\n \n-    private List<FileMetadata> filesToBeDeleted = new ArrayList<>();\n+  public int getRestrictedFileCount() {\n+    int restrictedFileCount = 0;\n+    for (FileMetadata fmd : workingVersion.getFileMetadatas()) {\n+      if (fmd.isRestricted()) {\n+        restrictedFileCount++;\n+      }\n+    }\n \n-    \n-    public void deleteReplacementFile() throws FileReplaceException{\n-        if (!isFileReplaceOperation()){\n-            throw new FileReplaceException(\"Only use this for File Replace Operations\");            \n-        }\n+    return restrictedFileCount;\n+  }\n \n-        if (!fileReplacePageHelper.wasPhase1Successful()){\n-            throw new FileReplaceException(\"Should only be called if Phase 1 was successful\");                        \n-        }\n-        \n-        fileReplacePageHelper.resetReplaceFileHelper();\n+  private List<FileMetadata> filesToBeDeleted = new ArrayList<>();\n \n \n-        \n-        String successMessage = getBundleString(\"file.deleted.replacement.success\");\n-        logger.fine(successMessage);\n-        JsfHelper.addFlashMessage(successMessage);\n-        \n-    }\n-    \n-    \n-    /**\n-     * \n-     * @param msgName - from the bundle e.g. \"file.deleted.success\"\n-     * @return \n-     */\n-    private String getBundleString(String msgName){\n-        \n-       return BundleUtil.getStringFromBundle(msgName);\n+  public void deleteReplacementFile() throws FileReplaceException {\n+    if (!isFileReplaceOperation()) {\n+      throw new FileReplaceException(\"Only use this for File Replace Operations\");\n     }\n-    \n-    // This deleteFilesCompleted method is used in editFilesFragment.xhtml\n-    public void deleteFilesCompleted(){\n-        \n+\n+    if (!fileReplacePageHelper.wasPhase1Successful()) {\n+      throw new FileReplaceException(\"Should only be called if Phase 1 was successful\");\n     }\n-    \n-    public void deleteFiles(){        \n-        deleteFiles(this.selectedFiles);\n+\n+    fileReplacePageHelper.resetReplaceFileHelper();\n+\n+\n+    String successMessage = getBundleString(\"file.deleted.replacement.success\");\n+    logger.fine(successMessage);\n+    JsfHelper.addFlashMessage(successMessage);\n+\n+  }\n+\n+\n+  /**\n+   * @param msgName - from the bundle e.g. \"file.deleted.success\"\n+   * @return\n+   */\n+  private String getBundleString(String msgName) {\n+\n+    return BundleUtil.getStringFromBundle(msgName);\n+  }\n+\n+  // This deleteFilesCompleted method is used in editFilesFragment.xhtml\n+  public void deleteFilesCompleted() {\n+\n+  }\n+\n+  public void deleteFiles() {\n+    deleteFiles(this.selectedFiles);\n+  }\n+\n+  public void deleteDuplicateFiles() {\n+    List<FileMetadata> filesForDelete = new ArrayList();\n+    for (DataFile df : newFiles) {\n+      if (df.isMarkedAsDuplicate()) {\n+        filesForDelete.add(df.getFileMetadata());\n+      }\n     }\n-    \n-    public void deleteDuplicateFiles(){\n-        List<FileMetadata> filesForDelete = new ArrayList();\n-        for(DataFile df : newFiles ){\n-                if (df.isMarkedAsDuplicate()){\n-                    filesForDelete.add(df.getFileMetadata());\n-                }\n-            }\n-        deleteFiles(filesForDelete);\n+    deleteFiles(filesForDelete);\n+  }\n+\n+\n+  private void deleteFiles(List<FileMetadata> filesForDelete) {\n+    logger.fine(\"entering bulk file delete (EditDataFilesPage)\");\n+    if (isFileReplaceOperation()) {\n+      try {\n+        deleteReplacementFile();\n+      } catch (FileReplaceException ex) {\n+        Logger.getLogger(EditDatafilesPage.class.getName()).log(Level.SEVERE, null, ex);\n+      }\n+      return;\n     }\n-    \n-      \n-    private void deleteFiles(List<FileMetadata> filesForDelete) {\n-        logger.fine(\"entering bulk file delete (EditDataFilesPage)\");\n-        if (isFileReplaceOperation()) {\n-            try {\n-                deleteReplacementFile();\n-            } catch (FileReplaceException ex) {\n-                Logger.getLogger(EditDatafilesPage.class.getName()).log(Level.SEVERE, null, ex);\n-            }\n-            return;\n-        }\n \n         /*\n         If selected files are empty it means that we are dealing \n@@ -785,341 +796,352 @@ public class EditDatafilesPage implements java.io.Serializable {\n         and moving on accordingly.\n         */\n \n-        String fileNames = null;\n-        for (FileMetadata fmd : filesForDelete) {\n-            // collect the names of the files, \n-            // to show in the success message:\n-            if (fileNames == null) {\n-                fileNames = fmd.getLabel();\n-            } else {\n-                fileNames = fileNames.concat(\", \" + fmd.getLabel());\n-            }\n+    String fileNames = null;\n+    for (FileMetadata fmd : filesForDelete) {\n+      // collect the names of the files,\n+      // to show in the success message:\n+      if (fileNames == null) {\n+        fileNames = fmd.getLabel();\n+      } else {\n+        fileNames = fileNames.concat(\", \" + fmd.getLabel());\n+      }\n+    }\n+\n+    for (FileMetadata markedForDelete : filesForDelete) {\n+      logger.fine(\"delete requested on file \" + markedForDelete.getLabel());\n+      logger.fine(\"file metadata id: \" + markedForDelete.getId());\n+      logger.fine(\"datafile id: \" + markedForDelete.getDataFile().getId());\n+      logger.fine(\"page is in edit mode \" + mode.name());\n+\n+      // has this filemetadata been saved already? (or is it a brand new\n+      // filemetadata, created as part of a brand new version, created when\n+      // the user clicked 'delete', that hasn't been saved in the db yet?)\n+      if (markedForDelete.getId() != null) {\n+        logger.fine(\"this is a filemetadata from an existing draft version\");\n+        // so all we remove is the file from the fileMetadatas (from the\n+        // file metadatas attached to the editVersion, and from the\n+        // display list of file metadatas that are being edited)\n+        // and let the delete be handled in the command (by adding it to the\n+        // filesToBeDeleted list):\n+\n+        // ToDo - FileMetadataUtil.removeFileMetadataFromList should handle these two\n+        // removes so they could be put after this if clause and the else clause could\n+        // be removed.\n+        dataset.getEditVersion().getFileMetadatas().remove(markedForDelete);\n+        fileMetadatas.remove(markedForDelete);\n+\n+        filesToBeDeleted.add(markedForDelete);\n+      } else {\n+        logger.fine(\"this is a brand-new (unsaved) filemetadata\");\n+        // ok, this is a brand-new DRAFT version.\n+\n+        // if (mode != FileEditMode.CREATE) {\n+        // If the bean is in the 'CREATE' mode, the page is using\n+        // dataset.getEditVersion().getFileMetadatas() directly,\n+        // so there's no need to delete this meta from the local\n+        // fileMetadatas list. (but doing both just adds a no-op and won't cause an\n+        // error)\n+        // 1. delete the filemetadata from the local display list:\n+        FileMetadataUtil.removeFileMetadataFromList(fileMetadatas, markedForDelete);\n+        // 2. delete the filemetadata from the version:\n+        FileMetadataUtil.removeFileMetadataFromList(dataset.getEditVersion().getFileMetadatas(), markedForDelete);\n+      }\n+\n+      if (markedForDelete.getDataFile().getId() == null) {\n+        logger.fine(\"this is a brand new file.\");\n+        // the file was just added during this step, so in addition to\n+        // removing it from the fileMetadatas lists (above), we also remove it from\n+        // the newFiles list and the dataset's files, so it never gets saved.\n+\n+        FileMetadataUtil.removeDataFileFromList(dataset.getFiles(), markedForDelete.getDataFile());\n+        FileMetadataUtil.removeDataFileFromList(newFiles, markedForDelete.getDataFile());\n+        FileUtil.deleteTempFile(markedForDelete.getDataFile(), dataset, ingestService);\n+        // Also remove checksum from the list of newly uploaded checksums (perhaps odd\n+        // to delete and then try uploading the same file again, but it seems like it\n+        // should be allowed/the checksum list is part of the state to clean-up\n+        if (checksumMapNew != null && markedForDelete.getDataFile().getChecksumValue() != null) {\n+          checksumMapNew.remove(markedForDelete.getDataFile().getChecksumValue());\n+        }\n+\n+      }\n+    }\n+\n+    if (fileNames != null) {\n+      String successMessage;\n+      if (mode == FileEditMode.UPLOAD) {\n+        if (fileNames.contains(\", \")) {\n+          successMessage = getBundleString(\"file.deleted.upload.success.multiple\");\n+        } else {\n+          successMessage = getBundleString(\"file.deleted.upload.success.single\");\n         }\n+      } else {\n+        successMessage = getBundleString(\"file.deleted.success\");\n+        successMessage = successMessage.replace(\"{0}\", fileNames);\n+      }\n+      logger.fine(successMessage);\n+      JsfHelper.addFlashMessage(successMessage);\n+    }\n+  }\n \n-        for (FileMetadata markedForDelete : filesForDelete) {\n-            logger.fine(\"delete requested on file \" + markedForDelete.getLabel());\n-            logger.fine(\"file metadata id: \" + markedForDelete.getId());\n-            logger.fine(\"datafile id: \" + markedForDelete.getDataFile().getId());\n-            logger.fine(\"page is in edit mode \" + mode.name());\n-\n-            // has this filemetadata been saved already? (or is it a brand new\n-            // filemetadata, created as part of a brand new version, created when \n-            // the user clicked 'delete', that hasn't been saved in the db yet?)\n-            if (markedForDelete.getId() != null) {\n-                logger.fine(\"this is a filemetadata from an existing draft version\");\n-                // so all we remove is the file from the fileMetadatas (from the\n-                // file metadatas attached to the editVersion, and from the\n-                // display list of file metadatas that are being edited)\n-                // and let the delete be handled in the command (by adding it to the\n-                // filesToBeDeleted list):\n-\n-                // ToDo - FileMetadataUtil.removeFileMetadataFromList should handle these two\n-                // removes so they could be put after this if clause and the else clause could\n-                // be removed.\n-                dataset.getEditVersion().getFileMetadatas().remove(markedForDelete);\n-                fileMetadatas.remove(markedForDelete);\n-\n-                filesToBeDeleted.add(markedForDelete);\n-            } else {\n-                logger.fine(\"this is a brand-new (unsaved) filemetadata\");\n-                // ok, this is a brand-new DRAFT version. \n-\n-                // if (mode != FileEditMode.CREATE) {\n-                // If the bean is in the 'CREATE' mode, the page is using\n-                // dataset.getEditVersion().getFileMetadatas() directly,\n-                // so there's no need to delete this meta from the local\n-                // fileMetadatas list. (but doing both just adds a no-op and won't cause an\n-                // error)\n-                // 1. delete the filemetadata from the local display list: \n-                FileMetadataUtil.removeFileMetadataFromList(fileMetadatas, markedForDelete);\n-                // 2. delete the filemetadata from the version: \n-                FileMetadataUtil.removeFileMetadataFromList(dataset.getEditVersion().getFileMetadatas(), markedForDelete);\n-            }\n \n-            if (markedForDelete.getDataFile().getId() == null) {\n-                logger.fine(\"this is a brand new file.\");\n-                // the file was just added during this step, so in addition to \n-                // removing it from the fileMetadatas lists (above), we also remove it from\n-                // the newFiles list and the dataset's files, so it never gets saved.\n-\n-                FileMetadataUtil.removeDataFileFromList(dataset.getFiles(), markedForDelete.getDataFile());\n-                FileMetadataUtil.removeDataFileFromList(newFiles, markedForDelete.getDataFile());\n-                FileUtil.deleteTempFile(markedForDelete.getDataFile(), dataset, ingestService);\n-                // Also remove checksum from the list of newly uploaded checksums (perhaps odd\n-                // to delete and then try uploading the same file again, but it seems like it\n-                // should be allowed/the checksum list is part of the state to clean-up\n-                if(checksumMapNew != null && markedForDelete.getDataFile().getChecksumValue() != null)\n-                    checksumMapNew.remove(markedForDelete.getDataFile().getChecksumValue());\n+  /**\n+   * Save for File Replace operations\n+   *\n+   * @return\n+   * @throws FileReplaceException\n+   */\n+  public String saveReplacementFile() throws FileReplaceException {\n \n-            }\n-        }\n+    // Ahh, make sure it's a file replace operation\n+    //\n+    if (!isFileReplaceOperation()) {\n+      throw new FileReplaceException(\"Only use this for File Replace Operations\");\n+    }\n \n-        if (fileNames != null) {\n-            String successMessage;\n-            if (mode == FileEditMode.UPLOAD) {\n-                if (fileNames.contains(\", \")) {\n-                    successMessage = getBundleString(\"file.deleted.upload.success.multiple\");\n-                } else {\n-                    successMessage = getBundleString(\"file.deleted.upload.success.single\");\n-                }\n-            } else {\n-                successMessage = getBundleString(\"file.deleted.success\");\n-                successMessage = successMessage.replace(\"{0}\", fileNames);\n-            }\n-            logger.fine(successMessage);\n-            JsfHelper.addFlashMessage(successMessage);\n-        }\n+    // Can we do a save?\n+    //  (redundant but ok, also called in main \"save\" event before forking here)\n+    //\n+    if (!saveEnabled) {\n+      return \"\";\n+    }\n+    // Sanity check 1\n+    //\n+    if (fileReplacePageHelper == null) {\n+      throw new NullPointerException(\"fileReplacePageHelper cannot be null\");\n     }\n \n+    // Make sure phase 1 ran -- button shouldn't be visible if it did not\n+    //\n+    if (!fileReplacePageHelper.wasPhase1Successful()) {\n+      throw new FileReplaceException(\n+        \"Save should only be called when a replacement file has been chosen.  (Phase 1 has to have completed)\");\n \n-    \n-    \n-    /**\n-     * Save for File Replace operations\n-     * @return\n-     * @throws FileReplaceException \n-     */\n-    public String saveReplacementFile() throws FileReplaceException{\n-        \n-        // Ahh, make sure it's a file replace operation\n-        //\n-        if (!isFileReplaceOperation()){\n-            throw new FileReplaceException(\"Only use this for File Replace Operations\");\n-        }\n-\n-        // Can we do a save?  \n-        //  (redundant but ok, also called in main \"save\" event before forking here)      \n-        //\n-        if (!saveEnabled) {\n-            return \"\";\n-        }\n-        // Sanity check 1\n-        //\n-        if (fileReplacePageHelper == null){\n-            throw new NullPointerException(\"fileReplacePageHelper cannot be null\");\n-        }\n-        \n-        // Make sure phase 1 ran -- button shouldn't be visible if it did not\n-        //\n-        if (!fileReplacePageHelper.wasPhase1Successful()){\n-            throw new FileReplaceException(\"Save should only be called when a replacement file has been chosen.  (Phase 1 has to have completed)\");\n-            \n-        }\n-\n-        // Run save!!\n-        //\n-        if (fileReplacePageHelper.runSaveReplacementFile_Phase2()){\n-            JsfHelper.addSuccessMessage(getBundleString(\"file.message.replaceSuccess\"));\n-            // It worked!!!  Go to page of new file!!\n-            if (Referrer.FILE == referrer) {\n-                return returnToFileLandingPageAfterReplace(fileReplacePageHelper.getFirstNewlyAddedFile());\n-            } else {\n-                return returnToDraftVersion();\n-            }\n-        }else{\n-            // Uh oh.\n-            String errMsg = fileReplacePageHelper.getErrorMessages();\n-            \n-            FacesContext.getCurrentInstance().addMessage(null, new FacesMessage(FacesMessage.SEVERITY_ERROR, getBundleString(\"dataset.save.fail\"), errMsg));\n-            logger.severe(\"Dataset save failed for replace operation: \" + errMsg);\n-            return null;\n-        }\n-        \n-    }    \n-        \n-    public String save() {\n-        \n-        Collection<String> duplicates = IngestUtil.findDuplicateFilenames(workingVersion, newFiles);\n-        if (!duplicates.isEmpty()) {\n-            JH.addMessage(FacesMessage.SEVERITY_ERROR, BundleUtil.getStringFromBundle(\"dataset.message.filesFailure\"), BundleUtil.getStringFromBundle(\"dataset.message.editMetadata.duplicateFilenames\", new ArrayList<>(duplicates)));\n-            return null;\n-        }\n-        if (!saveEnabled) {\n-            return \"\";\n-        }\n-        //Mirroring the checks for DcmUpload, make sure that the db version of the dataset is not locked. \n-        //Also checking local version to save time - if data.isLocked() is true, the UpdateDatasetVersionCommand below would fail\n-        if (dataset.getId() != null) {\n-            Dataset lockTest = datasetService.find(dataset.getId());\n-            if (dataset.isLockedFor(DatasetLock.Reason.EditInProgress) || lockTest.isLockedFor(DatasetLock.Reason.EditInProgress)) {\n-                logger.log(Level.INFO, \"Couldn''t save dataset: {0}\", \"It is locked.\"\n-                        + \"\");\n-                JH.addMessage(FacesMessage.SEVERITY_FATAL, getBundleString(\"dataset.locked.editInProgress.message\"),BundleUtil.getStringFromBundle(\"dataset.locked.editInProgress.message.details\", Arrays.asList(BrandingUtil.getSupportTeamName(null))));\n-                return null;\n-            }\n-        }\n-\n-        if (isFileReplaceOperation()){\n-            try {\n-                return saveReplacementFile();\n-            } catch (FileReplaceException ex) {\n-                String errMsg = ex.getMessage();\n-                FacesContext.getCurrentInstance().addMessage(null, new FacesMessage(FacesMessage.SEVERITY_ERROR, getBundleString(\"dataset.save.fail\"), errMsg));\n-                logger.log(Level.SEVERE, \"Dataset save failed for replace operation: {0}\", errMsg);\n-                return null;\n-            }            \n-        }\n-\n-                \n-        int nOldFiles = workingVersion.getFileMetadatas().size();\n-        int nNewFiles = newFiles.size();\n-        int nExpectedFilesTotal = nOldFiles + nNewFiles; \n-        \n-        if (nNewFiles > 0) {\n-            //SEK 10/15/2018 only apply the following tests if dataset has already been saved.\n-            if (dataset.getId() != null) {\n-                Dataset lockTest = datasetService.find(dataset.getId());\n-                //SEK 09/19/18 Get Dataset again to test for lock just in case the user downloads the rsync script via the api while the \n-                // edit files page is open and has already loaded a file in http upload for Dual Mode\n-                if (dataset.isLockedFor(DatasetLock.Reason.DcmUpload) || lockTest.isLockedFor(DatasetLock.Reason.DcmUpload)) {\n-                    logger.log(Level.INFO, \"Couldn''t save dataset: {0}\", \"DCM script has been downloaded for this dataset. Additonal files are not permitted.\"\n-                            + \"\");\n-                    populateDatasetUpdateFailureMessage();\n-                    return null;\n-                }\n-                for (DatasetVersion dv : lockTest.getVersions()) {\n-                    if (dv.isHasPackageFile()) {\n-                        logger.log(Level.INFO, BundleUtil.getStringFromBundle(\"file.api.alreadyHasPackageFile\")\n-                                + \"\");\n-                        populateDatasetUpdateFailureMessage();\n-                        return null;\n-                    }\n-                }\n-            }\n-                                \n-            // Try to save the NEW files permanently: \n-            List<DataFile> filesAdded = ingestService.saveAndAddFilesToDataset(workingVersion, newFiles, null);\n-            \n-            // reset the working list of fileMetadatas, as to only include the ones\n-            // that have been added to the version successfully: \n-            fileMetadatas.clear();\n-            for (DataFile addedFile : filesAdded) {\n-                fileMetadatas.add(addedFile.getFileMetadata());\n-            }\n-            filesAdded = null; \n-        }\n-        //boolean newDraftVersion = false;    \n-\n-        Boolean provJsonChanges = false;\n-        \n-        if(systemConfig.isProvCollectionEnabled()) {\n-            Boolean provFreeChanges = provPopupFragmentBean.updatePageMetadatasWithProvFreeform(fileMetadatas);\n-\n-            try {\n-                // Note that the user may have uploaded provenance metadata file(s)\n-                // for some of the new files that have since failed to be permanently saved \n-                // in storage (in the ingestService.saveAndAddFilesToDataset() step, above); \n-                // these files have been dropped from the fileMetadatas list, and we \n-                // are not adding them to the dataset; but the \n-                // provenance update set still has entries for these failed files,\n-                // so we are passing the fileMetadatas list to the saveStagedProvJson()\n-                // method below - so that it doesn't attempt to save the entries \n-                // that are no longer valid. \n-                provJsonChanges = provPopupFragmentBean.saveStagedProvJson(false, fileMetadatas);\n-            } catch (AbstractApiBean.WrappedResponse ex) {\n-                JsfHelper.addErrorMessage(getBundleString(\"file.metadataTab.provenance.error\"));\n-                Logger.getLogger(EditDatafilesPage.class.getName()).log(Level.SEVERE, null, ex);\n-            }\n-        }\n-        logger.fine(\"issuing the dataset update command\");\n-        // We are creating a new draft version or updating an existing draft;\n-        // We'll use an Update command for this:\n-        if (workingVersion.getId() != null) {\n-            for (int i = 0; i < workingVersion.getFileMetadatas().size(); i++) {\n-                for (FileMetadata fileMetadata : fileMetadatas) {\n-                    if (fileMetadata.getDataFile().getStorageIdentifier() != null) {\n-                        if (fileMetadata.getDataFile().getStorageIdentifier().equals(workingVersion.getFileMetadatas().get(i).getDataFile().getStorageIdentifier())) {\n-                            workingVersion.getFileMetadatas().set(i, fileMetadata);\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-        // Moves DataFile updates from popupFragment to page for saving\n-        // This does not seem to collide with the tags updating below\n-        if (systemConfig.isProvCollectionEnabled() && provJsonChanges) {\n-            HashMap<String, ProvPopupFragmentBean.UpdatesEntry> provenanceUpdates = provPopupFragmentBean.getProvenanceUpdates();\n-            for (int i = 0; i < dataset.getFiles().size(); i++) {\n-                for (ProvPopupFragmentBean.UpdatesEntry ue : provenanceUpdates.values()) {\n-                    if (ue.dataFile.getStorageIdentifier() != null) {\n-                        if (ue.dataFile.getStorageIdentifier().equals(dataset.getFiles().get(i).getStorageIdentifier())) {\n-                            dataset.getFiles().set(i, ue.dataFile);\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-\n-        // Tabular data tags are assigned to datafiles, not to\n-        // version-specfic filemetadatas!\n-        // So if tabular tags have been modified, we also need to\n-        // refresh the list of datafiles, as found in dataset.getFiles(),\n-        // similarly to what we've just done, above, for the filemetadatas.\n-        // Otherwise, when we call UpdateDatasetCommand, it's not going\n-        // to update the tags in the database (issue #2798).\n-        // TODO: Is the above still true/is this still necessary?\n-        // (and why?...)\n-\n-        if (tabularDataTagsUpdated) {\n-            for (int i = 0; i < dataset.getFiles().size(); i++) {\n-                for (FileMetadata fileMetadata : fileMetadatas) {\n-                    if (fileMetadata.getDataFile().getStorageIdentifier() != null) {\n-                        if (fileMetadata.getDataFile().getStorageIdentifier().equals(dataset.getFiles().get(i).getStorageIdentifier())) {\n-                            dataset.getFiles().set(i, fileMetadata.getDataFile());\n-                        }\n-                    }\n-                }\n-            }\n-            tabularDataTagsUpdated = false;\n-        }\n-\n-        Map<Long, String> deleteStorageLocations = null;\n+    }\n \n-        if (!filesToBeDeleted.isEmpty()) {\n-            deleteStorageLocations = datafileService.getPhysicalFilesToDelete(filesToBeDeleted);\n-        }\n+    // Run save!!\n+    //\n+    if (fileReplacePageHelper.runSaveReplacementFile_Phase2()) {\n+      JsfHelper.addSuccessMessage(getBundleString(\"file.message.replaceSuccess\"));\n+      // It worked!!!  Go to page of new file!!\n+      if (Referrer.FILE == referrer) {\n+        return returnToFileLandingPageAfterReplace(fileReplacePageHelper.getFirstNewlyAddedFile());\n+      } else {\n+        return returnToDraftVersion();\n+      }\n+    } else {\n+      // Uh oh.\n+      String errMsg = fileReplacePageHelper.getErrorMessages();\n+\n+      FacesContext.getCurrentInstance()\n+        .addMessage(null, new FacesMessage(FacesMessage.SEVERITY_ERROR, getBundleString(\"dataset.save.fail\"), errMsg));\n+      logger.severe(\"Dataset save failed for replace operation: \" + errMsg);\n+      return null;\n+    }\n+\n+  }\n+\n+  public String save() {\n+\n+    Collection<String> duplicates = IngestUtil.findDuplicateFilenames(workingVersion, newFiles);\n+    if (!duplicates.isEmpty()) {\n+      JH.addMessage(FacesMessage.SEVERITY_ERROR, BundleUtil.getStringFromBundle(\"dataset.message.filesFailure\"),\n+        BundleUtil.getStringFromBundle(\"dataset.message.editMetadata.duplicateFilenames\", new ArrayList<>(duplicates)));\n+      return null;\n+    }\n+    if (!saveEnabled) {\n+      return \"\";\n+    }\n+    //Mirroring the checks for DcmUpload, make sure that the db version of the dataset is not locked.\n+    //Also checking local version to save time - if data.isLocked() is true, the UpdateDatasetVersionCommand below would fail\n+    if (dataset.getId() != null) {\n+      Dataset lockTest = datasetService.find(dataset.getId());\n+      if (dataset.isLockedFor(DatasetLock.Reason.EditInProgress) ||\n+        lockTest.isLockedFor(DatasetLock.Reason.EditInProgress)) {\n+        logger.log(Level.INFO, \"Couldn''t save dataset: {0}\", \"It is locked.\"\n+          + \"\");\n+        JH.addMessage(FacesMessage.SEVERITY_FATAL, getBundleString(\"dataset.locked.editInProgress.message\"), BundleUtil\n+          .getStringFromBundle(\"dataset.locked.editInProgress.message.details\",\n+            Arrays.asList(BrandingUtil.getSupportTeamName(null))));\n+        return null;\n+      }\n+    }\n \n-        Command<Dataset> cmd;\n-        try {\n-            cmd = new UpdateDatasetVersionCommand(dataset, dvRequestService.getDataverseRequest(), filesToBeDeleted, clone);\n-            ((UpdateDatasetVersionCommand) cmd).setValidateLenient(true);\n-            dataset = commandEngine.submit(cmd);\n-\n-        } catch (EJBException ex) {\n-            StringBuilder error = new StringBuilder();\n-            error.append(ex).append(\" \");\n-            error.append(ex.getMessage()).append(\" \");\n-            Throwable cause = ex;\n-            while (cause.getCause() != null) {\n-                cause = cause.getCause();\n-                error.append(cause).append(\" \");\n-                error.append(cause.getMessage()).append(\" \");\n-            }\n-            logger.log(Level.INFO, \"Couldn''t save dataset: {0}\", error.toString());\n-            populateDatasetUpdateFailureMessage();\n-            return null;\n-        } catch (CommandException ex) {\n-            // FacesContext.getCurrentInstance().addMessage(null, new\n-            // FacesMessage(FacesMessage.SEVERITY_ERROR, \"Dataset Save Failed\", \" - \" +\n-            // ex.toString()));\n-            logger.log(Level.INFO, \"Couldn''t save dataset: {0}\", ex.getMessage());\n+    if (isFileReplaceOperation()) {\n+      try {\n+        return saveReplacementFile();\n+      } catch (FileReplaceException ex) {\n+        String errMsg = ex.getMessage();\n+        FacesContext.getCurrentInstance().addMessage(null,\n+          new FacesMessage(FacesMessage.SEVERITY_ERROR, getBundleString(\"dataset.save.fail\"), errMsg));\n+        logger.log(Level.SEVERE, \"Dataset save failed for replace operation: {0}\", errMsg);\n+        return null;\n+      }\n+    }\n+\n+\n+    int nOldFiles = workingVersion.getFileMetadatas().size();\n+    int nNewFiles = newFiles.size();\n+    int nExpectedFilesTotal = nOldFiles + nNewFiles;\n+\n+    if (nNewFiles > 0) {\n+      //SEK 10/15/2018 only apply the following tests if dataset has already been saved.\n+      if (dataset.getId() != null) {\n+        Dataset lockTest = datasetService.find(dataset.getId());\n+        //SEK 09/19/18 Get Dataset again to test for lock just in case the user downloads the rsync script via the api while the\n+        // edit files page is open and has already loaded a file in http upload for Dual Mode\n+        if (dataset.isLockedFor(DatasetLock.Reason.DcmUpload) || lockTest.isLockedFor(DatasetLock.Reason.DcmUpload)) {\n+          logger.log(Level.INFO, \"Couldn''t save dataset: {0}\",\n+            \"DCM script has been downloaded for this dataset. Additonal files are not permitted.\"\n+              + \"\");\n+          populateDatasetUpdateFailureMessage();\n+          return null;\n+        }\n+        for (DatasetVersion dv : lockTest.getVersions()) {\n+          if (dv.isHasPackageFile()) {\n+            logger.log(Level.INFO, BundleUtil.getStringFromBundle(\"file.api.alreadyHasPackageFile\")\n+              + \"\");\n             populateDatasetUpdateFailureMessage();\n             return null;\n-        }\n-\n-        // Have we just deleted some draft datafiles (successfully)?\n-        // finalize the physical file deletes:\n-        // (DataFileService will double-check that the datafiles no\n-        // longer exist in the database, before attempting to delete\n-        // the physical files)\n-        if (deleteStorageLocations != null) {\n-            datafileService.finalizeFileDeletes(deleteStorageLocations);\n-        }\n-        saveEnabled = false;\n-\n-        if (newFiles.size() > 0) {\n-            logger.fine(\"clearing newfiles list.\");\n-            newFiles.clear();\n+          }\n+        }\n+      }\n+\n+      // Try to save the NEW files permanently:\n+      List<DataFile> filesAdded = ingestService.saveAndAddFilesToDataset(workingVersion, newFiles, null);\n+\n+      // reset the working list of fileMetadatas, as to only include the ones\n+      // that have been added to the version successfully:\n+      fileMetadatas.clear();\n+      for (DataFile addedFile : filesAdded) {\n+        fileMetadatas.add(addedFile.getFileMetadata());\n+      }\n+      filesAdded = null;\n+    }\n+    //boolean newDraftVersion = false;\n+\n+    Boolean provJsonChanges = false;\n+\n+    if (systemConfig.isProvCollectionEnabled()) {\n+      Boolean provFreeChanges = provPopupFragmentBean.updatePageMetadatasWithProvFreeform(fileMetadatas);\n+\n+      try {\n+        // Note that the user may have uploaded provenance metadata file(s)\n+        // for some of the new files that have since failed to be permanently saved\n+        // in storage (in the ingestService.saveAndAddFilesToDataset() step, above);\n+        // these files have been dropped from the fileMetadatas list, and we\n+        // are not adding them to the dataset; but the\n+        // provenance update set still has entries for these failed files,\n+        // so we are passing the fileMetadatas list to the saveStagedProvJson()\n+        // method below - so that it doesn't attempt to save the entries\n+        // that are no longer valid.\n+        provJsonChanges = provPopupFragmentBean.saveStagedProvJson(false, fileMetadatas);\n+      } catch (AbstractApiBean.WrappedResponse ex) {\n+        JsfHelper.addErrorMessage(getBundleString(\"file.metadataTab.provenance.error\"));\n+        Logger.getLogger(EditDatafilesPage.class.getName()).log(Level.SEVERE, null, ex);\n+      }\n+    }\n+    logger.fine(\"issuing the dataset update command\");\n+    // We are creating a new draft version or updating an existing draft;\n+    // We'll use an Update command for this:\n+    if (workingVersion.getId() != null) {\n+      for (int i = 0; i < workingVersion.getFileMetadatas().size(); i++) {\n+        for (FileMetadata fileMetadata : fileMetadatas) {\n+          if (fileMetadata.getDataFile().getStorageIdentifier() != null) {\n+            if (fileMetadata.getDataFile().getStorageIdentifier()\n+              .equals(workingVersion.getFileMetadatas().get(i).getDataFile().getStorageIdentifier())) {\n+              workingVersion.getFileMetadatas().set(i, fileMetadata);\n+            }\n+          }\n+        }\n+      }\n+    }\n+    // Moves DataFile updates from popupFragment to page for saving\n+    // This does not seem to collide with the tags updating below\n+    if (systemConfig.isProvCollectionEnabled() && provJsonChanges) {\n+      HashMap<String, ProvPopupFragmentBean.UpdatesEntry> provenanceUpdates =\n+        provPopupFragmentBean.getProvenanceUpdates();\n+      for (int i = 0; i < dataset.getFiles().size(); i++) {\n+        for (ProvPopupFragmentBean.UpdatesEntry ue : provenanceUpdates.values()) {\n+          if (ue.dataFile.getStorageIdentifier() != null) {\n+            if (ue.dataFile.getStorageIdentifier().equals(dataset.getFiles().get(i).getStorageIdentifier())) {\n+              dataset.getFiles().set(i, ue.dataFile);\n+            }\n+          }\n+        }\n+      }\n+    }\n+\n+    // Tabular data tags are assigned to datafiles, not to\n+    // version-specfic filemetadatas!\n+    // So if tabular tags have been modified, we also need to\n+    // refresh the list of datafiles, as found in dataset.getFiles(),\n+    // similarly to what we've just done, above, for the filemetadatas.\n+    // Otherwise, when we call UpdateDatasetCommand, it's not going\n+    // to update the tags in the database (issue #2798).\n+    // TODO: Is the above still true/is this still necessary?\n+    // (and why?...)\n+\n+    if (tabularDataTagsUpdated) {\n+      for (int i = 0; i < dataset.getFiles().size(); i++) {\n+        for (FileMetadata fileMetadata : fileMetadatas) {\n+          if (fileMetadata.getDataFile().getStorageIdentifier() != null) {\n+            if (fileMetadata.getDataFile().getStorageIdentifier()\n+              .equals(dataset.getFiles().get(i).getStorageIdentifier())) {\n+              dataset.getFiles().set(i, fileMetadata.getDataFile());\n+            }\n+          }\n+        }\n+      }\n+      tabularDataTagsUpdated = false;\n+    }\n+\n+    Map<Long, String> deleteStorageLocations = null;\n+\n+    if (!filesToBeDeleted.isEmpty()) {\n+      deleteStorageLocations = datafileService.getPhysicalFilesToDelete(filesToBeDeleted);\n+    }\n+\n+    Command<Dataset> cmd;\n+    try {\n+      cmd = new UpdateDatasetVersionCommand(dataset, dvRequestService.getDataverseRequest(), filesToBeDeleted, clone);\n+      ((UpdateDatasetVersionCommand) cmd).setValidateLenient(true);\n+      dataset = commandEngine.submit(cmd);\n+\n+    } catch (EJBException ex) {\n+      StringBuilder error = new StringBuilder();\n+      error.append(ex).append(\" \");\n+      error.append(ex.getMessage()).append(\" \");\n+      Throwable cause = ex;\n+      while (cause.getCause() != null) {\n+        cause = cause.getCause();\n+        error.append(cause).append(\" \");\n+        error.append(cause.getMessage()).append(\" \");\n+      }\n+      logger.log(Level.INFO, \"Couldn''t save dataset: {0}\", error.toString());\n+      populateDatasetUpdateFailureMessage();\n+      return null;\n+    } catch (CommandException ex) {\n+      // FacesContext.getCurrentInstance().addMessage(null, new\n+      // FacesMessage(FacesMessage.SEVERITY_ERROR, \"Dataset Save Failed\", \" - \" +\n+      // ex.toString()));\n+      logger.log(Level.INFO, \"Couldn''t save dataset: {0}\", ex.getMessage());\n+      populateDatasetUpdateFailureMessage();\n+      return null;\n+    }\n+\n+    // Have we just deleted some draft datafiles (successfully)?\n+    // finalize the physical file deletes:\n+    // (DataFileService will double-check that the datafiles no\n+    // longer exist in the database, before attempting to delete\n+    // the physical files)\n+    if (deleteStorageLocations != null) {\n+      datafileService.finalizeFileDeletes(deleteStorageLocations);\n+    }\n+    saveEnabled = false;\n+\n+    if (newFiles.size() > 0) {\n+      logger.fine(\"clearing newfiles list.\");\n+      newFiles.clear();\n             /*\n              - We decided not to bother obtaining persistent ids for new files \n              as they are uploaded and created. The identifiers will be assigned \n@@ -1128,107 +1150,107 @@ public class EditDatafilesPage implements java.io.Serializable {\n             logger.info(\"starting async job for obtaining persistent ids for files.\");\n             datasetService.obtainPersistentIdentifiersForDatafiles(dataset);\n             */\n-        }\n-                \n-        workingVersion = dataset.getEditVersion();\n-        logger.fine(\"working version id: \"+workingVersion.getId());\n-       \n-        if (FileEditMode.EDIT == mode && Referrer.FILE == referrer){\n-            JsfHelper.addSuccessMessage(getBundleString(\"file.message.editSuccess\"));\n-            \n-        } else {\n-            int nFilesTotal = workingVersion.getFileMetadatas().size();\n-            if (nNewFiles == 0 || nFilesTotal == nExpectedFilesTotal) {\n-                JsfHelper.addSuccessMessage(getBundleString(\"dataset.message.filesSuccess\").concat(\" \").concat(datasetService.getReminderString(dataset, canPublishDataset())));\n-            } else if (nFilesTotal == nOldFiles) {\n-                JsfHelper.addErrorMessage(getBundleString(\"dataset.message.addFiles.Failure\"));\n-            } else {\n-                String warningMessage = getBundleString(\"dataset.message.addFiles.partialSuccess\");\n-                warningMessage = warningMessage.replace(\"{0}\", \"\" + (nFilesTotal - nOldFiles));\n-                warningMessage = warningMessage.replace(\"{1}\", \"\" + nNewFiles);\n-                JsfHelper.addWarningMessage(warningMessage);\n-            }\n-        }\n+    }\n \n-        // Call Ingest Service one more time, to \n-        // queue the data ingest jobs for asynchronous execution:\n-        if (mode == FileEditMode.UPLOAD) {\n-            ingestService.startIngestJobsForDataset(dataset, (AuthenticatedUser) session.getUser());\n-        }\n+    workingVersion = dataset.getEditVersion();\n+    logger.fine(\"working version id: \" + workingVersion.getId());\n \n-        if (FileEditMode.EDIT == mode && Referrer.FILE == referrer && fileMetadatas.size() > 0) {\n-            // If this was a \"single file edit\", i.e. an edit request sent from \n-            // the individual File Landing page, we want to redirect back to \n-            // the landing page. BUT ONLY if the file still exists - i.e., if \n-            // the user hasn't just deleted it!\n-            versionString = \"DRAFT\";\n-            return returnToFileLandingPage();\n-        }\n-        \n-        logger.fine(\"Redirecting to the dataset page, from the edit/upload page.\");\n-        return returnToDraftVersion();\n-    }\n-    \n-    public boolean canPublishDataset(){\n-        return permissionsWrapper.canIssuePublishDatasetCommand(dataset);\n-    }\n-    \n-    private void populateDatasetUpdateFailureMessage(){\n-            \n-        JH.addMessage(FacesMessage.SEVERITY_FATAL, getBundleString(\"dataset.message.filesFailure\"));\n+    if (FileEditMode.EDIT == mode && Referrer.FILE == referrer) {\n+      JsfHelper.addSuccessMessage(getBundleString(\"file.message.editSuccess\"));\n+\n+    } else {\n+      int nFilesTotal = workingVersion.getFileMetadatas().size();\n+      if (nNewFiles == 0 || nFilesTotal == nExpectedFilesTotal) {\n+        JsfHelper.addSuccessMessage(getBundleString(\"dataset.message.filesSuccess\").concat(\" \")\n+          .concat(datasetService.getReminderString(dataset, canPublishDataset())));\n+      } else if (nFilesTotal == nOldFiles) {\n+        JsfHelper.addErrorMessage(getBundleString(\"dataset.message.addFiles.Failure\"));\n+      } else {\n+        String warningMessage = getBundleString(\"dataset.message.addFiles.partialSuccess\");\n+        warningMessage = warningMessage.replace(\"{0}\", \"\" + (nFilesTotal - nOldFiles));\n+        warningMessage = warningMessage.replace(\"{1}\", \"\" + nNewFiles);\n+        JsfHelper.addWarningMessage(warningMessage);\n+      }\n     }\n-    \n-    \n-    \n-    private String returnToDraftVersion(){      \n-         return \"/dataset.xhtml?persistentId=\" + dataset.getGlobalId().asString() + \"&version=DRAFT&faces-redirect=true\";    \n+\n+    // Call Ingest Service one more time, to\n+    // queue the data ingest jobs for asynchronous execution:\n+    if (mode == FileEditMode.UPLOAD) {\n+      ingestService.startIngestJobsForDataset(dataset, (AuthenticatedUser) session.getUser());\n     }\n-    \n-    private String returnToDatasetOnly(){\n-         dataset = datasetService.find(dataset.getId());\n-         return \"/dataset.xhtml?persistentId=\" + dataset.getGlobalId().asString()  +  \"&faces-redirect=true\";       \n+\n+    if (FileEditMode.EDIT == mode && Referrer.FILE == referrer && fileMetadatas.size() > 0) {\n+      // If this was a \"single file edit\", i.e. an edit request sent from\n+      // the individual File Landing page, we want to redirect back to\n+      // the landing page. BUT ONLY if the file still exists - i.e., if\n+      // the user hasn't just deleted it!\n+      versionString = \"DRAFT\";\n+      return returnToFileLandingPage();\n     }\n-    \n-    private String returnToFileLandingPage() {\n-        Long fileId = fileMetadatas.get(0).getDataFile().getId();   \n-        if (versionString != null && versionString.equals(\"DRAFT\")){\n-            return  \"/file.xhtml?fileId=\" + fileId  +  \"&version=DRAFT&faces-redirect=true\";\n-        }\n-        return  \"/file.xhtml?fileId=\" + fileId  +  \"&faces-redirect=true\";\n \n+    logger.fine(\"Redirecting to the dataset page, from the edit/upload page.\");\n+    return returnToDraftVersion();\n+  }\n+\n+  public boolean canPublishDataset() {\n+    return permissionsWrapper.canIssuePublishDatasetCommand(dataset);\n+  }\n+\n+  private void populateDatasetUpdateFailureMessage() {\n+\n+    JH.addMessage(FacesMessage.SEVERITY_FATAL, getBundleString(\"dataset.message.filesFailure\"));\n+  }\n+\n+\n+  private String returnToDraftVersion() {\n+    return \"/dataset.xhtml?persistentId=\" + dataset.getGlobalId().asString() + \"&version=DRAFT&faces-redirect=true\";\n+  }\n+\n+  private String returnToDatasetOnly() {\n+    dataset = datasetService.find(dataset.getId());\n+    return \"/dataset.xhtml?persistentId=\" + dataset.getGlobalId().asString() + \"&faces-redirect=true\";\n+  }\n+\n+  private String returnToFileLandingPage() {\n+    Long fileId = fileMetadatas.get(0).getDataFile().getId();\n+    if (versionString != null && versionString.equals(\"DRAFT\")) {\n+      return \"/file.xhtml?fileId=\" + fileId + \"&version=DRAFT&faces-redirect=true\";\n     }\n+    return \"/file.xhtml?fileId=\" + fileId + \"&faces-redirect=true\";\n \n-    private String returnToFileLandingPageAfterReplace(DataFile newFile) {\n-        \n-        if (newFile == null){\n-            throw new NullPointerException(\"newFile cannot be null!\");\n-        }\n-        //Long datasetVersionId = newFile.getOwner().getLatestVersion().getId();\n-        return \"/file.xhtml?fileId=\" + newFile.getId()  + \"&version=DRAFT&faces-redirect=true\";\n+  }\n+\n+  private String returnToFileLandingPageAfterReplace(DataFile newFile) {\n+\n+    if (newFile == null) {\n+      throw new NullPointerException(\"newFile cannot be null!\");\n     }\n+    //Long datasetVersionId = newFile.getOwner().getLatestVersion().getId();\n+    return \"/file.xhtml?fileId=\" + newFile.getId() + \"&version=DRAFT&faces-redirect=true\";\n+  }\n \n-    \n-    public String cancel() {\n-        uploadInProgress.setValue(false);\n-        //Files that have been finished and are now in the lower list on the page\n-        for (DataFile newFile : newFiles) {\n-            FileUtil.deleteTempFile(newFile, dataset, ingestService);\n-        }\n \n-        //Files in the upload process but not yet finished\n-        for (DataFile newFile : uploadedFiles) {\n-            FileUtil.deleteTempFile(newFile, dataset, ingestService);\n-        }\n+  public String cancel() {\n+    uploadInProgress.setValue(false);\n+    //Files that have been finished and are now in the lower list on the page\n+    for (DataFile newFile : newFiles) {\n+      FileUtil.deleteTempFile(newFile, dataset, ingestService);\n+    }\n \n-        if (Referrer.FILE == referrer) {\n-            return returnToFileLandingPage();\n-        }\n-        if (workingVersion.getId() != null) {\n-            return returnToDraftVersion();\n-        }\n-        return returnToDatasetOnly();\n+    //Files in the upload process but not yet finished\n+    for (DataFile newFile : uploadedFiles) {\n+      FileUtil.deleteTempFile(newFile, dataset, ingestService);\n     }\n \n+    if (Referrer.FILE == referrer) {\n+      return returnToFileLandingPage();\n+    }\n+    if (workingVersion.getId() != null) {\n+      return returnToDraftVersion();\n+    }\n+    return returnToDatasetOnly();\n+  }\n+\n     \n     /* deprecated; super inefficient, when called repeatedly on a long list \n        of files! \n@@ -1264,117 +1286,117 @@ public class EditDatafilesPage implements java.io.Serializable {\n \n         return MD5Map.get(thisMd5) != null && MD5Map.get(thisMd5).intValue() > 1;\n     }*/\n-   \n-    private HttpClient getClient() {\n-        // TODO: \n-        // cache the http client? -- L.A. 4.0 alpha\n-        return new HttpClient();\n-    }\n \n-    /**\n-     * Is this page in File Replace mode\n-     * \n-     * @return \n-     */\n-    public boolean isFileReplaceOperation(){\n-        return (mode == FileEditMode.REPLACE)&&(fileReplacePageHelper!= null);\n+  private HttpClient getClient() {\n+    // TODO:\n+    // cache the http client? -- L.A. 4.0 alpha\n+    return new HttpClient();\n+  }\n+\n+  /**\n+   * Is this page in File Replace mode\n+   *\n+   * @return\n+   */\n+  public boolean isFileReplaceOperation() {\n+    return (mode == FileEditMode.REPLACE) && (fileReplacePageHelper != null);\n+  }\n+\n+  public boolean allowMultipleFileUpload() {\n+\n+    return !isFileReplaceOperation();\n+  }\n+\n+  public boolean showFileUploadFragment() {\n+    return mode == FileEditMode.UPLOAD || mode == FileEditMode.CREATE || mode == FileEditMode.REPLACE;\n+  }\n+\n+\n+  public boolean showFileUploadComponent() {\n+    if (mode == FileEditMode.UPLOAD || mode == FileEditMode.CREATE) {\n+      return true;\n     }\n-    \n-    public boolean allowMultipleFileUpload(){\n-        \n-        return !isFileReplaceOperation();\n+\n+    if (isFileReplaceOperation()) {\n+      //msg(\"fileReplacePageHelper.showFileUploadComponent(): \"+ fileReplacePageHelper.showFileUploadComponent());\n+      return fileReplacePageHelper.showFileUploadComponent();\n     }\n-    \n-    public boolean showFileUploadFragment(){\n-        return mode == FileEditMode.UPLOAD || mode == FileEditMode.CREATE || mode == FileEditMode.REPLACE;\n+\n+    return false;\n+    //return false;\n+  }\n+\n+\n+  /**\n+   * Download a file from drop box\n+   *\n+   * @param fileLink\n+   * @return\n+   */\n+  private InputStream getDropBoxInputStream(String fileLink, GetMethod dropBoxMethod) {\n+\n+    if (fileLink == null) {\n+      return null;\n     }\n-    \n-    \n-    public boolean showFileUploadComponent(){\n-        if (mode == FileEditMode.UPLOAD || mode == FileEditMode.CREATE) {\n-           return true;\n-        }\n-        \n-        if (isFileReplaceOperation()){\n-            //msg(\"fileReplacePageHelper.showFileUploadComponent(): \"+ fileReplacePageHelper.showFileUploadComponent());\n-            return fileReplacePageHelper.showFileUploadComponent();\n-            }\n \n-        return false;\n-        //return false;\n+    // -----------------------------------------------------------\n+    // Make http call, download the file:\n+    // -----------------------------------------------------------\n+    int status = 0;\n+    //InputStream dropBoxStream = null;\n+\n+    try {\n+      status = getClient().executeMethod(dropBoxMethod);\n+      if (status == 200) {\n+        return dropBoxMethod.getResponseBodyAsStream();\n+      }\n+    } catch (IOException ex) {\n+      logger.log(Level.WARNING, \"Failed to access DropBox url: {0}!\", fileLink);\n+      return null;\n     }\n-    \n \n-    /**\n-     * Download a file from drop box\n-     * \n-     * @param fileLink\n-     * @return \n-     */\n-    private InputStream getDropBoxInputStream(String fileLink, GetMethod dropBoxMethod){\n-        \n-        if (fileLink == null){\n-            return null;\n-        }\n-        \n-        // -----------------------------------------------------------\n-        // Make http call, download the file: \n-        // -----------------------------------------------------------\n-        int status = 0;\n-        //InputStream dropBoxStream = null;\n+    logger.log(Level.WARNING, \"Failed to get DropBox InputStream for file: {0}\", fileLink);\n+    return null;\n+  } // end: getDropBoxInputStream\n \n-        try {\n-            status = getClient().executeMethod(dropBoxMethod);\n-            if (status == 200) {\n-                return dropBoxMethod.getResponseBodyAsStream();\n-            }\n-        } catch (IOException ex) {\n-            logger.log(Level.WARNING, \"Failed to access DropBox url: {0}!\", fileLink);\n-            return null;\n-        } \n \n-        logger.log(Level.WARNING, \"Failed to get DropBox InputStream for file: {0}\", fileLink);\n-        return null;\n-    } // end: getDropBoxInputStream\n-                  \n-    \n-    /**\n-     * Using information from the DropBox choose, ingest the chosen files\n-     *  https://www.dropbox.com/developers/dropins/chooser/js\n-     * \n-     * @param event\n-     */\n-    public void handleDropBoxUpload(ActionEvent event) {\n-        if (uploadInProgress.isFalse()) {\n-            uploadInProgress.setValue(true);\n-        }\n-        logger.fine(\"handleDropBoxUpload\");\n-        uploadComponentId = event.getComponent().getClientId();\n-        \n-        // -----------------------------------------------------------\n-        // Read JSON object from the output of the DropBox Chooser: \n-        // -----------------------------------------------------------\n-        JsonReader dbJsonReader = Json.createReader(new StringReader(dropBoxSelection));\n-        JsonArray dbArray = dbJsonReader.readArray();\n-        dbJsonReader.close();\n+  /**\n+   * Using information from the DropBox choose, ingest the chosen files\n+   * https://www.dropbox.com/developers/dropins/chooser/js\n+   *\n+   * @param event\n+   */\n+  public void handleDropBoxUpload(ActionEvent event) {\n+    if (uploadInProgress.isFalse()) {\n+      uploadInProgress.setValue(true);\n+    }\n+    logger.fine(\"handleDropBoxUpload\");\n+    uploadComponentId = event.getComponent().getClientId();\n \n-        // -----------------------------------------------------------\n-        // Iterate through the Dropbox file information (JSON)\n-        // -----------------------------------------------------------\n-        DataFile dFile = null;\n-        GetMethod dropBoxMethod = null;\n-        String localWarningMessage = null; \n-        for (int i = 0; i < dbArray.size(); i++) {\n-            JsonObject dbObject = dbArray.getJsonObject(i);\n+    // -----------------------------------------------------------\n+    // Read JSON object from the output of the DropBox Chooser:\n+    // -----------------------------------------------------------\n+    JsonReader dbJsonReader = Json.createReader(new StringReader(dropBoxSelection));\n+    JsonArray dbArray = dbJsonReader.readArray();\n+    dbJsonReader.close();\n \n-            // -----------------------------------------------------------\n-            // Parse information for a single file\n-            // -----------------------------------------------------------\n-            String fileLink = dbObject.getString(\"link\");\n-            String fileName = dbObject.getString(\"name\");\n-            int fileSize = dbObject.getInt(\"bytes\");\n+    // -----------------------------------------------------------\n+    // Iterate through the Dropbox file information (JSON)\n+    // -----------------------------------------------------------\n+    DataFile dFile = null;\n+    GetMethod dropBoxMethod = null;\n+    String localWarningMessage = null;\n+    for (int i = 0; i < dbArray.size(); i++) {\n+      JsonObject dbObject = dbArray.getJsonObject(i);\n \n-            logger.fine(\"DropBox url: \" + fileLink + \", filename: \" + fileName + \", size: \" + fileSize);\n+      // -----------------------------------------------------------\n+      // Parse information for a single file\n+      // -----------------------------------------------------------\n+      String fileLink = dbObject.getString(\"link\");\n+      String fileName = dbObject.getString(\"name\");\n+      int fileSize = dbObject.getInt(\"bytes\");\n+\n+      logger.fine(\"DropBox url: \" + fileLink + \", filename: \" + fileName + \", size: \" + fileSize);\n \n \n             /* ----------------------------\n@@ -1382,89 +1404,95 @@ public class EditDatafilesPage implements java.io.Serializable {\n                 - Max size NOT specified in db: default is unlimited\n                 - Max size specified in db: check too make sure file is within limits\n             // ---------------------------- */\n-            if ((!this.isUnlimitedUploadFileSize()) && (fileSize > this.getMaxFileUploadSizeInBytes())) {\n-                String warningMessage = \"Dropbox file \\\"\" + fileName + \"\\\" exceeded the limit of \" + fileSize + \" bytes and was not uploaded.\";\n-                //msg(warningMessage);\n-                //FacesContext.getCurrentInstance().addMessage(event.getComponent().getClientId(), new FacesMessage(FacesMessage.SEVERITY_ERROR, \"upload failure\", warningMessage));\n-                if (localWarningMessage == null) {\n-                    localWarningMessage = warningMessage;\n-                } else {\n-                    localWarningMessage = localWarningMessage.concat(\"; \" + warningMessage);\n-                }\n-                continue; // skip to next file, and add error mesage\n-            }\n-\n-            \n-            dFile = null;\n-            dropBoxMethod = new GetMethod(fileLink);\n-\n-            // -----------------------------------------------------------\n-            // Download the file\n-            // -----------------------------------------------------------\n-            InputStream dropBoxStream = this.getDropBoxInputStream(fileLink, dropBoxMethod);\n-            if (dropBoxStream==null){\n-                logger.severe(\"Could not retrieve dropgox input stream for: \" + fileLink);\n-                continue;  // Error skip this file\n-            }\n-            \n-            // -----------------------------------------------------------\n-            // Is this a FileReplaceOperation?  If so, then diverge!\n-            // -----------------------------------------------------------\n-            if (this.isFileReplaceOperation()){\n-              this.handleReplaceFileUpload(event, dropBoxStream, fileName, FileUtil.MIME_TYPE_UNDETERMINED_DEFAULT, null, event);\n-              this.setFileMetadataSelectedForTagsPopup(fileReplacePageHelper.getNewFileMetadatasBeforeSave().get(0));\n-              return;\n-             }\n-            // -----------------------------------------------------------\n-\n-            \n-            List<DataFile> datafiles = new ArrayList<>(); \n-            \n-            // -----------------------------------------------------------\n-            // Send it through the ingest service\n-            // -----------------------------------------------------------\n-            try {\n-\n-                // Note: A single uploaded file may produce multiple datafiles - \n-                // for example, multiple files can be extracted from an uncompressed\n-                // zip file.\n-                //datafiles = ingestService.createDataFiles(workingVersion, dropBoxStream, fileName, \"application/octet-stream\");\n-                datafiles = FileUtil.createDataFiles(workingVersion, dropBoxStream, fileName, \"application/octet-stream\", null,null, systemConfig);\n-                \n-            } catch (IOException ex) {\n-                this.logger.log(Level.SEVERE, \"Error during ingest of DropBox file {0} from link {1}\", new Object[]{fileName, fileLink});\n-                continue;\n-            }/*catch (FileExceedsMaxSizeException ex){\n+      if ((!this.isUnlimitedUploadFileSize()) && (fileSize > this.getMaxFileUploadSizeInBytes())) {\n+        String warningMessage =\n+          \"Dropbox file \\\"\" + fileName + \"\\\" exceeded the limit of \" + fileSize + \" bytes and was not uploaded.\";\n+        //msg(warningMessage);\n+        //FacesContext.getCurrentInstance().addMessage(event.getComponent().getClientId(), new FacesMessage(FacesMessage.SEVERITY_ERROR, \"upload failure\", warningMessage));\n+        if (localWarningMessage == null) {\n+          localWarningMessage = warningMessage;\n+        } else {\n+          localWarningMessage = localWarningMessage.concat(\"; \" + warningMessage);\n+        }\n+        continue; // skip to next file, and add error mesage\n+      }\n+\n+\n+      dFile = null;\n+      dropBoxMethod = new GetMethod(fileLink);\n+\n+      // -----------------------------------------------------------\n+      // Download the file\n+      // -----------------------------------------------------------\n+      InputStream dropBoxStream = this.getDropBoxInputStream(fileLink, dropBoxMethod);\n+      if (dropBoxStream == null) {\n+        logger.severe(\"Could not retrieve dropgox input stream for: \" + fileLink);\n+        continue;  // Error skip this file\n+      }\n+\n+      // -----------------------------------------------------------\n+      // Is this a FileReplaceOperation?  If so, then diverge!\n+      // -----------------------------------------------------------\n+      if (this.isFileReplaceOperation()) {\n+        this.handleReplaceFileUpload(event, dropBoxStream, fileName, FileUtil.MIME_TYPE_UNDETERMINED_DEFAULT, null,\n+          event);\n+        this.setFileMetadataSelectedForTagsPopup(fileReplacePageHelper.getNewFileMetadatasBeforeSave().get(0));\n+        return;\n+      }\n+      // -----------------------------------------------------------\n+\n+\n+      List<DataFile> datafiles = new ArrayList<>();\n+\n+      // -----------------------------------------------------------\n+      // Send it through the ingest service\n+      // -----------------------------------------------------------\n+      try {\n+\n+        // Note: A single uploaded file may produce multiple datafiles -\n+        // for example, multiple files can be extracted from an uncompressed\n+        // zip file.\n+        //datafiles = ingestService.createDataFiles(workingVersion, dropBoxStream, fileName, \"application/octet-stream\");\n+        datafiles = FileUtil\n+          .createDataFiles(workingVersion, dropBoxStream, fileName, \"application/octet-stream\", null, null,\n+            systemConfig);\n+\n+      } catch (IOException ex) {\n+        this.logger.log(Level.SEVERE, \"Error during ingest of DropBox file {0} from link {1}\",\n+          new Object[] {fileName, fileLink});\n+        continue;\n+      }/*catch (FileExceedsMaxSizeException ex){\n                 this.logger.log(Level.SEVERE, \"Error during ingest of DropBox file {0} from link {1}: {2}\", new Object[]{fileName, fileLink, ex.getMessage()});\n                 continue;\n             }*/ finally {\n-                // -----------------------------------------------------------\n-                // release connection for dropBoxMethod\n-                // -----------------------------------------------------------\n-                \n-                if (dropBoxMethod != null) {\n-                    dropBoxMethod.releaseConnection();\n-                }\n-                \n-                // -----------------------------------------------------------\n-                // close the  dropBoxStream\n-                // -----------------------------------------------------------\n-                try {\n-                    dropBoxStream.close();\n-                } catch (IOException ex) {\n-                    logger.log(Level.WARNING, \"Failed to close the dropBoxStream for file: {0}\", fileLink);\n-                }\n-            }\n-            \n-            if (datafiles == null){\n-                this.logger.log(Level.SEVERE, \"Failed to create DataFile for DropBox file {0} from link {1}\", new Object[]{fileName, fileLink});\n-                continue;\n-            }else{    \n-                // -----------------------------------------------------------\n-                // Check if there are duplicate files or ingest warnings\n-                // -----------------------------------------------------------\n-                uploadWarningMessage = processUploadedFileList(datafiles);\n-                logger.fine(\"Warning message during upload: \" + uploadWarningMessage);\n+        // -----------------------------------------------------------\n+        // release connection for dropBoxMethod\n+        // -----------------------------------------------------------\n+\n+        if (dropBoxMethod != null) {\n+          dropBoxMethod.releaseConnection();\n+        }\n+\n+        // -----------------------------------------------------------\n+        // close the  dropBoxStream\n+        // -----------------------------------------------------------\n+        try {\n+          dropBoxStream.close();\n+        } catch (IOException ex) {\n+          logger.log(Level.WARNING, \"Failed to close the dropBoxStream for file: {0}\", fileLink);\n+        }\n+      }\n+\n+      if (datafiles == null) {\n+        this.logger.log(Level.SEVERE, \"Failed to create DataFile for DropBox file {0} from link {1}\",\n+          new Object[] {fileName, fileLink});\n+        continue;\n+      } else {\n+        // -----------------------------------------------------------\n+        // Check if there are duplicate files or ingest warnings\n+        // -----------------------------------------------------------\n+        uploadWarningMessage = processUploadedFileList(datafiles);\n+        logger.fine(\"Warning message during upload: \" + uploadWarningMessage);\n                 /*if (warningMessage != null){\n                      logger.fine(\"trying to send faces message to \" + event.getComponent().getClientId());\n                      FacesContext.getCurrentInstance().addMessage(event.getComponent().getClientId(), new FacesMessage(FacesMessage.SEVERITY_ERROR, \"upload failure\", warningMessage));\n@@ -1474,339 +1502,355 @@ public class EditDatafilesPage implements java.io.Serializable {\n                          uploadWarningMessage = uploadWarningMessage.concat(\"; \"+warningMessage);\n                      }\n                 }*/\n-            }\n-            if(uploadInProgress.isFalse()) {\n-                logger.warning(\"Upload in progress cancelled\");\n-                for (DataFile newFile : datafiles) {\n-                    FileUtil.deleteTempFile(newFile, dataset, ingestService);\n-                }\n-            }\n-        }\n-        \n-        if (localWarningMessage != null) {\n-            if (uploadWarningMessage == null) {\n-                uploadWarningMessage = localWarningMessage;\n-            } else {\n-                uploadWarningMessage = localWarningMessage.concat(\"; \" + uploadWarningMessage);\n-            }\n-        }\n-    }\n-    \n-    public void uploadStarted() {\n-        // uploadStarted() is triggered by PrimeFaces <p:upload onStart=... when an upload is \n-        // started. It will be called *once*, even if it is a multiple file upload \n-        // (either through drag-and-drop or select menu). \n-        logger.fine(\"upload started\");\n-        \n-        uploadInProgress.setValue(true);        \n-    }\n-    \n-    \n-    private Boolean hasRsyncScript = false;\n-    public Boolean isHasRsyncScript() {\n-        return hasRsyncScript;\n-    }\n-\n-    public void setHasRsyncScript(Boolean hasRsyncScript) {\n-        this.hasRsyncScript = hasRsyncScript;\n-    }\n-\n-    private  void setUpRsync() {\n-        logger.fine(\"setUpRsync called...\");\n-        if (DataCaptureModuleUtil.rsyncSupportEnabled(settingsWrapper.getValueForKey(SettingsServiceBean.Key.UploadMethods))\n-                && dataset.getFiles().isEmpty()) { //only check for rsync if no files exist\n-            try {\n-                ScriptRequestResponse scriptRequestResponse = commandEngine.submit(new RequestRsyncScriptCommand(dvRequestService.getDataverseRequest(), dataset));\n-                logger.fine(\"script: \" + scriptRequestResponse.getScript());\n-                if (scriptRequestResponse.getScript() != null && !scriptRequestResponse.getScript().isEmpty()) {\n-                    setRsyncScript(scriptRequestResponse.getScript());\n-                    rsyncScriptFilename = DataCaptureModuleUtil.getScriptName(workingVersion);\n-                    setHasRsyncScript(true);\n-                } else {\n-                    setHasRsyncScript(false);\n-                }\n-            } catch (EJBException ex) {\n-                logger.warning(\"Problem getting rsync script (EJBException): \" + EjbUtil.ejbExceptionToString(ex));\n-            } catch (RuntimeException ex) {\n-                logger.warning(\"Problem getting rsync script (RuntimeException): \" + ex.getLocalizedMessage());\n-            } catch (CommandException cex) {\n-                logger.warning(\"Problem getting rsync script (Command Exception): \" + cex.getLocalizedMessage());\n-            }\n-        }\n-    }\n-    \n-    public void downloadRsyncScript() {\n-\n-        FacesContext ctx = FacesContext.getCurrentInstance();\n-        HttpServletResponse response = (HttpServletResponse) ctx.getExternalContext().getResponse();\n-        response.setContentType(\"application/download\");\n-\n-        String contentDispositionString;\n-\n-        contentDispositionString = \"attachment;filename=\" + rsyncScriptFilename;\n-        response.setHeader(\"Content-Disposition\", contentDispositionString);\n-\n-        try {\n-            ServletOutputStream out = response.getOutputStream();\n-            out.write(getRsyncScript().getBytes());\n-            out.flush();\n-            ctx.responseComplete();\n-        } catch (IOException e) {\n-            String error = \"Problem getting bytes from rsync script: \" + e;\n-            logger.warning(error);\n-            return; \n-        }\n-        \n-        // If the script has been successfully downloaded, lock the dataset:\n-        String lockInfoMessage = \"script downloaded\";\n-        DatasetLock lock = datasetService.addDatasetLock(dataset.getId(), DatasetLock.Reason.DcmUpload, session.getUser() != null ? ((AuthenticatedUser)session.getUser()).getId() : null, lockInfoMessage);\n-        if (lock != null) {\n-            dataset.addLock(lock);\n+      }\n+      if (uploadInProgress.isFalse()) {\n+        logger.warning(\"Upload in progress cancelled\");\n+        for (DataFile newFile : datafiles) {\n+          FileUtil.deleteTempFile(newFile, dataset, ingestService);\n+        }\n+      }\n+    }\n+\n+    if (localWarningMessage != null) {\n+      if (uploadWarningMessage == null) {\n+        uploadWarningMessage = localWarningMessage;\n+      } else {\n+        uploadWarningMessage = localWarningMessage.concat(\"; \" + uploadWarningMessage);\n+      }\n+    }\n+  }\n+\n+  public void uploadStarted() {\n+    // uploadStarted() is triggered by PrimeFaces <p:upload onStart=... when an upload is\n+    // started. It will be called *once*, even if it is a multiple file upload\n+    // (either through drag-and-drop or select menu).\n+    logger.fine(\"upload started\");\n+\n+    uploadInProgress.setValue(true);\n+  }\n+\n+\n+  private Boolean hasRsyncScript = false;\n+\n+  public Boolean isHasRsyncScript() {\n+    return hasRsyncScript;\n+  }\n+\n+  public void setHasRsyncScript(Boolean hasRsyncScript) {\n+    this.hasRsyncScript = hasRsyncScript;\n+  }\n+\n+  private void setUpRsync() {\n+    logger.fine(\"setUpRsync called...\");\n+    if (DataCaptureModuleUtil.rsyncSupportEnabled(settingsWrapper.getValueForKey(SettingsServiceBean.Key.UploadMethods))\n+      && dataset.getFiles().isEmpty()) { //only check for rsync if no files exist\n+      try {\n+        ScriptRequestResponse scriptRequestResponse =\n+          commandEngine.submit(new RequestRsyncScriptCommand(dvRequestService.getDataverseRequest(), dataset));\n+        logger.fine(\"script: \" + scriptRequestResponse.getScript());\n+        if (scriptRequestResponse.getScript() != null && !scriptRequestResponse.getScript().isEmpty()) {\n+          setRsyncScript(scriptRequestResponse.getScript());\n+          rsyncScriptFilename = DataCaptureModuleUtil.getScriptName(workingVersion);\n+          setHasRsyncScript(true);\n         } else {\n-            logger.log(Level.WARNING, \"Failed to lock the dataset (dataset id={0})\", dataset.getId());\n+          setHasRsyncScript(false);\n         }\n-        \n-    }\n-    \n-        /**\n-     * The contents of the script.\n-     */\n-    private String rsyncScript = \"\";\n-\n-    public String getRsyncScript() {\n-        return rsyncScript;\n+      } catch (EJBException ex) {\n+        logger.warning(\"Problem getting rsync script (EJBException): \" + EjbUtil.ejbExceptionToString(ex));\n+      } catch (RuntimeException ex) {\n+        logger.warning(\"Problem getting rsync script (RuntimeException): \" + ex.getLocalizedMessage());\n+      } catch (CommandException cex) {\n+        logger.warning(\"Problem getting rsync script (Command Exception): \" + cex.getLocalizedMessage());\n+      }\n     }\n+  }\n \n-    public void setRsyncScript(String rsyncScript) {\n-        this.rsyncScript = rsyncScript;\n-    }\n+  public void downloadRsyncScript() {\n \n-    private String rsyncScriptFilename;\n+    FacesContext ctx = FacesContext.getCurrentInstance();\n+    HttpServletResponse response = (HttpServletResponse) ctx.getExternalContext().getResponse();\n+    response.setContentType(\"application/download\");\n \n-    public String getRsyncScriptFilename() {\n-        return rsyncScriptFilename;\n-    }\n+    String contentDispositionString;\n \n-    @Deprecated\n-    public void requestDirectUploadUrl() {\n-        \n+    contentDispositionString = \"attachment;filename=\" + rsyncScriptFilename;\n+    response.setHeader(\"Content-Disposition\", contentDispositionString);\n \n-        \n-        S3AccessIO<?> s3io = FileUtil.getS3AccessForDirectUpload(dataset);\n-        if(s3io == null) {\n-        \tFacesContext.getCurrentInstance().addMessage(uploadComponentId, new FacesMessage(FacesMessage.SEVERITY_ERROR, BundleUtil.getStringFromBundle(\"dataset.file.uploadWarning\"), \"Direct upload not supported for this dataset\"));\n-        }\n-        String url = null;\n-        String storageIdentifier = null;\n-        try {\n-        \turl = s3io.generateTemporaryS3UploadUrl();\n-        \tstorageIdentifier = FileUtil.getStorageIdentifierFromLocation(s3io.getStorageLocation());\n-        } catch (IOException io) {\n-        \tlogger.warning(io.getMessage());\n-       \tFacesContext.getCurrentInstance().addMessage(uploadComponentId, new FacesMessage(FacesMessage.SEVERITY_ERROR, BundleUtil.getStringFromBundle(\"dataset.file.uploadWarning\"), \"Issue in connecting to S3 store for direct upload\"));\n-       }\n-\n-    \tPrimeFaces.current().executeScript(\"uploadFileDirectly('\" + url + \"','\" + storageIdentifier + \"')\");\n-    }\n-    \n-\tpublic void requestDirectUploadUrls() {\n-\n-\t\tMap<String, String> paramMap = FacesContext.getCurrentInstance().getExternalContext().getRequestParameterMap();\n-\n-\t\tString sizeString = paramMap.get(\"fileSize\");\n-\t\tlong fileSize = Long.parseLong(sizeString);\n-\n-\t\tS3AccessIO<?> s3io = FileUtil.getS3AccessForDirectUpload(dataset);\n-\t\tif (s3io == null) {\n-\t\t\tFacesContext.getCurrentInstance().addMessage(uploadComponentId,\n-\t\t\t\t\tnew FacesMessage(FacesMessage.SEVERITY_ERROR,\n-\t\t\t\t\t\t\tBundleUtil.getStringFromBundle(\"dataset.file.uploadWarning\"),\n-\t\t\t\t\t\t\t\"Direct upload not supported for this dataset\"));\n-\t\t}\n-\t\tJsonObjectBuilder urls = null;\n-\t\tString storageIdentifier = null;\n-\t\ttry {\n-\t\t\tstorageIdentifier = FileUtil.getStorageIdentifierFromLocation(s3io.getStorageLocation());\n-\t\t\turls = s3io.generateTemporaryS3UploadUrls(dataset.getGlobalId().asString(), storageIdentifier, fileSize);\n-\n-\t\t} catch (IOException io) {\n-\t\t\tlogger.warning(io.getMessage());\n-\t\t\tFacesContext.getCurrentInstance().addMessage(uploadComponentId,\n-\t\t\t\t\tnew FacesMessage(FacesMessage.SEVERITY_ERROR,\n-\t\t\t\t\t\t\tBundleUtil.getStringFromBundle(\"dataset.file.uploadWarning\"),\n-\t\t\t\t\t\t\t\"Issue in connecting to S3 store for direct upload\"));\n-\t\t}\n-\n-\t\tPrimeFaces.current().executeScript(\n-\t\t\t\t\"uploadFileDirectly('\" + urls.build().toString() + \"','\" + storageIdentifier + \"','\" + fileSize + \"')\");\n-\t}\n-\n-    public void uploadFinished() {\n-        // This method is triggered from the page, by the <p:upload ... onComplete=...\n-        // attribute. \n-        // Note that its behavior is different from that of of <p:upload ... onStart=...\n-        // that's triggered only once, even for a multiple file upload. In contrast, \n-        // onComplete=... gets executed for each of the completed multiple upload events. \n-        // So when you drag-and-drop a bunch of files, you CANNOT rely on onComplete=...\n-        // to notify the page when the batch finishes uploading! There IS a way \n-        // to detect ALL the current uploads completing: the p:upload widget has \n-        // the property \"files\", that contains the list of all the files currently \n-        // uploading; so checking on the size of the list tells you if any uploads\n-        // are still in progress. Once it's zero, you know it's all done. \n-        // This is super important - because if the user is uploading 1000 files \n-        // via drag-and-drop, you don't want to re-render the entire page each \n-        // time every single of the 1000 uploads finishes!\n-        // (check editFilesFragment.xhtml for the exact code handling this; and \n-        // http://stackoverflow.com/questions/20747201/when-multiple-upload-is-finished-in-pfileupload\n-        // for more info). -- 4.6\n-        logger.fine(\"upload finished\");\n-\n-        // Add the file(s) added during this last upload event, single or multiple, \n-        // to the full list of new files, and the list of filemetadatas \n-        // used to render the page:\n-        \n-        for (DataFile dataFile : uploadedFiles) {\n-            fileMetadatas.add(dataFile.getFileMetadata());\n-            newFiles.add(dataFile);\n-        }\n-        \n-        \n-       \n-        if(uploadInProgress.isTrue()) {\n-            uploadedFiles.clear();\n-            uploadInProgress.setValue(false);\n-        }\n-        // refresh the warning message below the upload component, if exists:\n-        if (uploadComponentId != null) {\n-            if (uploadWarningMessage != null) {\n-                if (existingFilesWithDupeContent != null || newlyUploadedFilesWithDupeContent != null) {\n-                    setWarningMessageForAlreadyExistsPopUp(uploadWarningMessage);\n-                    setHeaderForAlreadyExistsPopUp();\n-                    setLabelForDeleteFilesPopup();\n-                    PrimeFaces.current().ajax().update(\"datasetForm:fileAlreadyExistsPopup\");\n-                    PrimeFaces.current().executeScript(\"PF('fileAlreadyExistsPopup').show();\");\n-                } else {\n-                    //adding back warnings in non-replace situations\n-                    FacesContext.getCurrentInstance().addMessage(uploadComponentId, new FacesMessage(FacesMessage.SEVERITY_WARN, BundleUtil.getStringFromBundle(\"dataset.file.uploadWarning\"), uploadWarningMessage));                   \n-                }\n-                \n-\n-\n-            } else if (uploadSuccessMessage != null) {\n-                FacesContext.getCurrentInstance().addMessage(uploadComponentId, new FacesMessage(FacesMessage.SEVERITY_INFO, BundleUtil.getStringFromBundle(\"dataset.file.uploadWorked\"), uploadSuccessMessage));\n-            }\n-        }\n-\n-        if(isFileReplaceOperation() && fileReplacePageHelper.wasPhase1Successful() && fileReplacePageHelper.hasContentTypeWarning()){\n-                    //RequestContext context = RequestContext.getCurrentInstance();\n-                    //RequestContext.getCurrentInstance().update(\"datasetForm:fileTypeDifferentPopup\");\n-                    PrimeFaces.current().ajax().update(\"datasetForm:fileTypeDifferentPopup\");\n-                    //context.execute(\"PF('fileTypeDifferentPopup').show();\");\n-                    PrimeFaces.current().executeScript(\"PF('fileTypeDifferentPopup').show();\");\n-        }\n-        \n-        if(isFileReplaceOperation() && fileReplacePageHelper.getAddReplaceFileHelper().isDuplicateFileErrorFound() ) {\n-                FacesContext.getCurrentInstance().addMessage(uploadComponentId, new FacesMessage(FacesMessage.SEVERITY_ERROR, fileReplacePageHelper.getAddReplaceFileHelper().getDuplicateFileErrorString(), fileReplacePageHelper.getAddReplaceFileHelper().getDuplicateFileErrorString()));\n-        }\n-        \n-        if (isFileReplaceOperation() && !fileReplacePageHelper.getAddReplaceFileHelper().isDuplicateFileErrorFound() && fileReplacePageHelper.getAddReplaceFileHelper().isDuplicateFileWarningFound()) {\n-            setWarningMessageForAlreadyExistsPopUp(fileReplacePageHelper.getAddReplaceFileHelper().getDuplicateFileWarningString());\n-            setHeaderForAlreadyExistsPopUp();\n-            setLabelForDeleteFilesPopup();\n-            PrimeFaces.current().ajax().update(\"datasetForm:fileAlreadyExistsPopup\");\n-            PrimeFaces.current().executeScript(\"PF('fileAlreadyExistsPopup').show();\");\n+    try {\n+      ServletOutputStream out = response.getOutputStream();\n+      out.write(getRsyncScript().getBytes());\n+      out.flush();\n+      ctx.responseComplete();\n+    } catch (IOException e) {\n+      String error = \"Problem getting bytes from rsync script: \" + e;\n+      logger.warning(error);\n+      return;\n+    }\n+\n+    // If the script has been successfully downloaded, lock the dataset:\n+    String lockInfoMessage = \"script downloaded\";\n+    DatasetLock lock = datasetService.addDatasetLock(dataset.getId(), DatasetLock.Reason.DcmUpload,\n+      session.getUser() != null ? ((AuthenticatedUser) session.getUser()).getId() : null, lockInfoMessage);\n+    if (lock != null) {\n+      dataset.addLock(lock);\n+    } else {\n+      logger.log(Level.WARNING, \"Failed to lock the dataset (dataset id={0})\", dataset.getId());\n+    }\n+\n+  }\n+\n+  /**\n+   * The contents of the script.\n+   */\n+  private String rsyncScript = \"\";\n+\n+  public String getRsyncScript() {\n+    return rsyncScript;\n+  }\n+\n+  public void setRsyncScript(String rsyncScript) {\n+    this.rsyncScript = rsyncScript;\n+  }\n+\n+  private String rsyncScriptFilename;\n+\n+  public String getRsyncScriptFilename() {\n+    return rsyncScriptFilename;\n+  }\n+\n+  @Deprecated\n+  public void requestDirectUploadUrl() {\n+\n+\n+    S3AccessIO<?> s3io = FileUtil.getS3AccessForDirectUpload(dataset);\n+    if (s3io == null) {\n+      FacesContext.getCurrentInstance().addMessage(uploadComponentId,\n+        new FacesMessage(FacesMessage.SEVERITY_ERROR, BundleUtil.getStringFromBundle(\"dataset.file.uploadWarning\"),\n+          \"Direct upload not supported for this dataset\"));\n+    }\n+    String url = null;\n+    String storageIdentifier = null;\n+    try {\n+      url = s3io.generateTemporaryS3UploadUrl();\n+      storageIdentifier = FileUtil.getStorageIdentifierFromLocation(s3io.getStorageLocation());\n+    } catch (IOException io) {\n+      logger.warning(io.getMessage());\n+      FacesContext.getCurrentInstance().addMessage(uploadComponentId,\n+        new FacesMessage(FacesMessage.SEVERITY_ERROR, BundleUtil.getStringFromBundle(\"dataset.file.uploadWarning\"),\n+          \"Issue in connecting to S3 store for direct upload\"));\n+    }\n+\n+    PrimeFaces.current().executeScript(\"uploadFileDirectly('\" + url + \"','\" + storageIdentifier + \"')\");\n+  }\n+\n+  public void requestDirectUploadUrls() {\n+\n+    Map<String, String> paramMap = FacesContext.getCurrentInstance().getExternalContext().getRequestParameterMap();\n+\n+    String sizeString = paramMap.get(\"fileSize\");\n+    long fileSize = Long.parseLong(sizeString);\n+\n+    S3AccessIO<?> s3io = FileUtil.getS3AccessForDirectUpload(dataset);\n+    if (s3io == null) {\n+      FacesContext.getCurrentInstance().addMessage(uploadComponentId,\n+        new FacesMessage(FacesMessage.SEVERITY_ERROR,\n+          BundleUtil.getStringFromBundle(\"dataset.file.uploadWarning\"),\n+          \"Direct upload not supported for this dataset\"));\n+    }\n+    JsonObjectBuilder urls = null;\n+    String storageIdentifier = null;\n+    try {\n+      storageIdentifier = FileUtil.getStorageIdentifierFromLocation(s3io.getStorageLocation());\n+      urls = s3io.generateTemporaryS3UploadUrls(dataset.getGlobalId().asString(), storageIdentifier, fileSize);\n+\n+    } catch (IOException io) {\n+      logger.warning(io.getMessage());\n+      FacesContext.getCurrentInstance().addMessage(uploadComponentId,\n+        new FacesMessage(FacesMessage.SEVERITY_ERROR,\n+          BundleUtil.getStringFromBundle(\"dataset.file.uploadWarning\"),\n+          \"Issue in connecting to S3 store for direct upload\"));\n+    }\n+\n+    PrimeFaces.current().executeScript(\n+      \"uploadFileDirectly('\" + urls.build().toString() + \"','\" + storageIdentifier + \"','\" + fileSize + \"')\");\n+  }\n+\n+  public void uploadFinished() {\n+    // This method is triggered from the page, by the <p:upload ... onComplete=...\n+    // attribute.\n+    // Note that its behavior is different from that of of <p:upload ... onStart=...\n+    // that's triggered only once, even for a multiple file upload. In contrast,\n+    // onComplete=... gets executed for each of the completed multiple upload events.\n+    // So when you drag-and-drop a bunch of files, you CANNOT rely on onComplete=...\n+    // to notify the page when the batch finishes uploading! There IS a way\n+    // to detect ALL the current uploads completing: the p:upload widget has\n+    // the property \"files\", that contains the list of all the files currently\n+    // uploading; so checking on the size of the list tells you if any uploads\n+    // are still in progress. Once it's zero, you know it's all done.\n+    // This is super important - because if the user is uploading 1000 files\n+    // via drag-and-drop, you don't want to re-render the entire page each\n+    // time every single of the 1000 uploads finishes!\n+    // (check editFilesFragment.xhtml for the exact code handling this; and\n+    // http://stackoverflow.com/questions/20747201/when-multiple-upload-is-finished-in-pfileupload\n+    // for more info). -- 4.6\n+    logger.fine(\"upload finished\");\n+\n+    // Add the file(s) added during this last upload event, single or multiple,\n+    // to the full list of new files, and the list of filemetadatas\n+    // used to render the page:\n+\n+    for (DataFile dataFile : uploadedFiles) {\n+      fileMetadatas.add(dataFile.getFileMetadata());\n+      newFiles.add(dataFile);\n+    }\n+\n+\n+    if (uploadInProgress.isTrue()) {\n+      uploadedFiles.clear();\n+      uploadInProgress.setValue(false);\n+    }\n+    // refresh the warning message below the upload component, if exists:\n+    if (uploadComponentId != null) {\n+      if (uploadWarningMessage != null) {\n+        if (existingFilesWithDupeContent != null || newlyUploadedFilesWithDupeContent != null) {\n+          setWarningMessageForAlreadyExistsPopUp(uploadWarningMessage);\n+          setHeaderForAlreadyExistsPopUp();\n+          setLabelForDeleteFilesPopup();\n+          PrimeFaces.current().ajax().update(\"datasetForm:fileAlreadyExistsPopup\");\n+          PrimeFaces.current().executeScript(\"PF('fileAlreadyExistsPopup').show();\");\n+        } else {\n+          //adding back warnings in non-replace situations\n+          FacesContext.getCurrentInstance().addMessage(uploadComponentId,\n+            new FacesMessage(FacesMessage.SEVERITY_WARN, BundleUtil.getStringFromBundle(\"dataset.file.uploadWarning\"),\n+              uploadWarningMessage));\n         }\n-        // We clear the following duplicate warning labels, because we want to \n-        // only inform the user of the duplicates dropped in the current upload \n-        // attempt - for ex., one batch of drag-and-dropped files, or a single \n-        // file uploaded through the file chooser. \n-        newlyUploadedFilesWithDupeContent = null; \n-        existingFilesWithDupeContent = null;\n-        multipleDupesExisting = false;\n-        multipleDupesNew = false; \n-        uploadWarningMessage = null;\n-        uploadSuccessMessage = null; \n-    }\n-    \n-    private String warningMessageForFileTypeDifferentPopUp;\n \n-    public String getWarningMessageForFileTypeDifferentPopUp() {\n-        return warningMessageForFileTypeDifferentPopUp;\n-    }\n \n-    public void setWarningMessageForFileTypeDifferentPopUp(String warningMessageForPopUp) {\n-        this.warningMessageForFileTypeDifferentPopUp = warningMessageForPopUp;\n+      } else if (uploadSuccessMessage != null) {\n+        FacesContext.getCurrentInstance().addMessage(uploadComponentId,\n+          new FacesMessage(FacesMessage.SEVERITY_INFO, BundleUtil.getStringFromBundle(\"dataset.file.uploadWorked\"),\n+            uploadSuccessMessage));\n+      }\n     }\n-    \n-    private String warningMessageForAlreadyExistsPopUp;\n \n-    public String getWarningMessageForAlreadyExistsPopUp() {\n-        return warningMessageForAlreadyExistsPopUp;\n+    if (isFileReplaceOperation() && fileReplacePageHelper.wasPhase1Successful() &&\n+      fileReplacePageHelper.hasContentTypeWarning()) {\n+      //RequestContext context = RequestContext.getCurrentInstance();\n+      //RequestContext.getCurrentInstance().update(\"datasetForm:fileTypeDifferentPopup\");\n+      PrimeFaces.current().ajax().update(\"datasetForm:fileTypeDifferentPopup\");\n+      //context.execute(\"PF('fileTypeDifferentPopup').show();\");\n+      PrimeFaces.current().executeScript(\"PF('fileTypeDifferentPopup').show();\");\n     }\n \n-    public void setWarningMessageForAlreadyExistsPopUp(String warningMessageForAlreadyExistsPopUp) {\n-        this.warningMessageForAlreadyExistsPopUp = warningMessageForAlreadyExistsPopUp;\n+    if (isFileReplaceOperation() && fileReplacePageHelper.getAddReplaceFileHelper().isDuplicateFileErrorFound()) {\n+      FacesContext.getCurrentInstance().addMessage(uploadComponentId, new FacesMessage(FacesMessage.SEVERITY_ERROR,\n+        fileReplacePageHelper.getAddReplaceFileHelper().getDuplicateFileErrorString(),\n+        fileReplacePageHelper.getAddReplaceFileHelper().getDuplicateFileErrorString()));\n     }\n-    \n-    private String headerForAlreadyExistsPopUp;\n \n-    public String getHeaderForAlreadyExistsPopUp() {\n-        return headerForAlreadyExistsPopUp;\n-    }\n-\n-    public void setHeaderForAlreadyExistsPopUp(String headerForAlreadyExistsPopUp) {\n-        this.headerForAlreadyExistsPopUp = headerForAlreadyExistsPopUp;\n-    }\n-    \n-    private String labelForDeleteFilesPopup;\n-\n-    public String getLabelForDeleteFilesPopup() {\n-        return labelForDeleteFilesPopup;\n-    }\n+    if (isFileReplaceOperation() && !fileReplacePageHelper.getAddReplaceFileHelper().isDuplicateFileErrorFound() &&\n+      fileReplacePageHelper.getAddReplaceFileHelper().isDuplicateFileWarningFound()) {\n+      setWarningMessageForAlreadyExistsPopUp(\n+        fileReplacePageHelper.getAddReplaceFileHelper().getDuplicateFileWarningString());\n+      setHeaderForAlreadyExistsPopUp();\n+      setLabelForDeleteFilesPopup();\n+      PrimeFaces.current().ajax().update(\"datasetForm:fileAlreadyExistsPopup\");\n+      PrimeFaces.current().executeScript(\"PF('fileAlreadyExistsPopup').show();\");\n+    }\n+    // We clear the following duplicate warning labels, because we want to\n+    // only inform the user of the duplicates dropped in the current upload\n+    // attempt - for ex., one batch of drag-and-dropped files, or a single\n+    // file uploaded through the file chooser.\n+    newlyUploadedFilesWithDupeContent = null;\n+    existingFilesWithDupeContent = null;\n+    multipleDupesExisting = false;\n+    multipleDupesNew = false;\n+    uploadWarningMessage = null;\n+    uploadSuccessMessage = null;\n+  }\n+\n+  private String warningMessageForFileTypeDifferentPopUp;\n+\n+  public String getWarningMessageForFileTypeDifferentPopUp() {\n+    return warningMessageForFileTypeDifferentPopUp;\n+  }\n+\n+  public void setWarningMessageForFileTypeDifferentPopUp(String warningMessageForPopUp) {\n+    this.warningMessageForFileTypeDifferentPopUp = warningMessageForPopUp;\n+  }\n+\n+  private String warningMessageForAlreadyExistsPopUp;\n+\n+  public String getWarningMessageForAlreadyExistsPopUp() {\n+    return warningMessageForAlreadyExistsPopUp;\n+  }\n+\n+  public void setWarningMessageForAlreadyExistsPopUp(String warningMessageForAlreadyExistsPopUp) {\n+    this.warningMessageForAlreadyExistsPopUp = warningMessageForAlreadyExistsPopUp;\n+  }\n+\n+  private String headerForAlreadyExistsPopUp;\n+\n+  public String getHeaderForAlreadyExistsPopUp() {\n+    return headerForAlreadyExistsPopUp;\n+  }\n+\n+  public void setHeaderForAlreadyExistsPopUp(String headerForAlreadyExistsPopUp) {\n+    this.headerForAlreadyExistsPopUp = headerForAlreadyExistsPopUp;\n+  }\n+\n+  private String labelForDeleteFilesPopup;\n+\n+  public String getLabelForDeleteFilesPopup() {\n+    return labelForDeleteFilesPopup;\n+  }\n+\n+  public void setLabelForDeleteFilesPopup(String labelForDeleteFilesPopup) {\n+    this.labelForDeleteFilesPopup = labelForDeleteFilesPopup;\n+  }\n+\n+  public void setLabelForDeleteFilesPopup() {\n+    this.labelForDeleteFilesPopup =\n+      ((multipleDupesExisting || multipleDupesNew) ? BundleUtil.getStringFromBundle(\"file.delete.duplicate.multiple\") :\n+        BundleUtil.getStringFromBundle(\"file.delete.duplicate.single\"));\n+  }\n+\n+  //((multipleDupesExisting|| multipleDupesNew) ? BundleUtil.getStringFromBundle(\"file.addreplace.already_exists.header.multiple\"):  BundleUtil.getStringFromBundle(\"file.addreplace.already_exists.header\"));\n+\n+  public void setHeaderForAlreadyExistsPopUp() {\n+\n+    this.headerForAlreadyExistsPopUp = ((multipleDupesExisting || multipleDupesNew) ?\n+      BundleUtil.getStringFromBundle(\"file.addreplace.already_exists.header.multiple\") :\n+      BundleUtil.getStringFromBundle(\"file.addreplace.already_exists.header\"));\n+  }\n \n-    public void setLabelForDeleteFilesPopup(String labelForDeleteFilesPopup) {\n-        this.labelForDeleteFilesPopup = labelForDeleteFilesPopup;\n-    }\n-    \n-    public void setLabelForDeleteFilesPopup() {\n-        this.labelForDeleteFilesPopup = ((multipleDupesExisting|| multipleDupesNew) ? BundleUtil.getStringFromBundle(\"file.delete.duplicate.multiple\") :  \n-                BundleUtil.getStringFromBundle(\"file.delete.duplicate.single\"));\n-    }\n-    \n-    //((multipleDupesExisting|| multipleDupesNew) ? BundleUtil.getStringFromBundle(\"file.addreplace.already_exists.header.multiple\"):  BundleUtil.getStringFromBundle(\"file.addreplace.already_exists.header\"));\n-    \n-    public void setHeaderForAlreadyExistsPopUp() {\n-        \n-        this.headerForAlreadyExistsPopUp = ((multipleDupesExisting|| multipleDupesNew) ? BundleUtil.getStringFromBundle(\"file.addreplace.already_exists.header.multiple\"):  BundleUtil.getStringFromBundle(\"file.addreplace.already_exists.header\"));\n-    }\n-\n-    private void handleReplaceFileUpload(FacesEvent event, InputStream inputStream, \n-                        String fileName, \n-                        String contentType,\n-                        FileUploadEvent nativeUploadEvent,\n-                        ActionEvent dropboxUploadEvent\n-    ){\n-\n-        fileReplacePageHelper.resetReplaceFileHelper();\n-\n-        saveEnabled = false;\n-        \n-        uploadComponentId = event.getComponent().getClientId();\n-        \n-        if (fileReplacePageHelper.handleNativeFileUpload(inputStream,null,\n-                                    fileName,\n-                                    contentType, \n-                                    null, \n-                                    null\n-                                )){\n-            saveEnabled = true;\n-\n-            /**\n-             * If the file content type changed, let the user know\n-             */\n-            if (fileReplacePageHelper.hasContentTypeWarning()){\n-                //Add warning to popup instead of page for Content Type Difference\n-                setWarningMessageForFileTypeDifferentPopUp(fileReplacePageHelper.getContentTypeWarning());\n+  private void handleReplaceFileUpload(FacesEvent event, InputStream inputStream,\n+                                       String fileName,\n+                                       String contentType,\n+                                       FileUploadEvent nativeUploadEvent,\n+                                       ActionEvent dropboxUploadEvent\n+  ) {\n+\n+    fileReplacePageHelper.resetReplaceFileHelper();\n+\n+    saveEnabled = false;\n+\n+    uploadComponentId = event.getComponent().getClientId();\n+\n+    if (fileReplacePageHelper.handleNativeFileUpload(inputStream, null,\n+      fileName,\n+      contentType,\n+      null,\n+      null\n+    )) {\n+      saveEnabled = true;\n+\n+      /**\n+       * If the file content type changed, let the user know\n+       */\n+      if (fileReplacePageHelper.hasContentTypeWarning()) {\n+        //Add warning to popup instead of page for Content Type Difference\n+        setWarningMessageForFileTypeDifferentPopUp(fileReplacePageHelper.getContentTypeWarning());\n                 /* \n                     Note on the info messages - upload errors, warnings and success messages:\n                     Instead of trying to display the message here (commented out code below),\n@@ -1821,113 +1865,115 @@ public class EditDatafilesPage implements java.io.Serializable {\n                     consistency. -- L.A. 4.6.1\n                    \n                 */\n-                //FacesContext.getCurrentInstance().addMessage(\n-                //        uploadComponentId,                         \n-                //        new FacesMessage(FacesMessage.SEVERITY_ERROR, \"upload warning\", uploadWarningMessage));\n-            }\n-            // See the comment above, on how upload messages are displayed.\n-            \n-            // Commented out the success message below - since we probably don't\n-            // need it - the state of the page will indicate the success fairly \n-            // unambiguously: the primefaces upload and the dropbox upload components\n-            // will become disabled, and the uploaded file will appear on the page. \n-            // But feel free to un-comment it, if you feel it could be useful. \n-            // -- L.A. 4.6.1\n-            //uploadSuccessMessage = \"Hey! It worked!\";\n-                \n-        } else {\n-            // See the comment above, on how upload messages are displayed.\n-            uploadWarningMessage = fileReplacePageHelper.getErrorMessages();\n+        //FacesContext.getCurrentInstance().addMessage(\n+        //        uploadComponentId,\n+        //        new FacesMessage(FacesMessage.SEVERITY_ERROR, \"upload warning\", uploadWarningMessage));\n+      }\n+      // See the comment above, on how upload messages are displayed.\n+\n+      // Commented out the success message below - since we probably don't\n+      // need it - the state of the page will indicate the success fairly\n+      // unambiguously: the primefaces upload and the dropbox upload components\n+      // will become disabled, and the uploaded file will appear on the page.\n+      // But feel free to un-comment it, if you feel it could be useful.\n+      // -- L.A. 4.6.1\n+      //uploadSuccessMessage = \"Hey! It worked!\";\n+\n+    } else {\n+      // See the comment above, on how upload messages are displayed.\n+      uploadWarningMessage = fileReplacePageHelper.getErrorMessages();\n //            uploadWarningMessage += \" ******* \";\n-            \n-            \n-            if (nativeUploadEvent != null){\n+\n+\n+      if (nativeUploadEvent != null) {\n //                uploadWarningMessage += \" nativeUploadEvent \";\n-                \n-            }\n-            if (dropboxUploadEvent != null){\n+\n+      }\n+      if (dropboxUploadEvent != null) {\n //                uploadWarningMessage += \" dropboxUploadEvent \";\n-            }\n-            //FacesContext.getCurrentInstance().addMessage(\n-            //    uploadComponentId,                         \n-            //    new FacesMessage(FacesMessage.SEVERITY_ERROR, \"upload failure\", uploadWarningMessage));\n-        }\n+      }\n+      //FacesContext.getCurrentInstance().addMessage(\n+      //    uploadComponentId,\n+      //    new FacesMessage(FacesMessage.SEVERITY_ERROR, \"upload failure\", uploadWarningMessage));\n     }\n-    \n-    private void handleReplaceFileUpload(String fullStorageLocation, \n-    \t\tString fileName, \n-    \t\tString contentType, \n-    \t\tString checkSumValue,\n-    \t\tChecksumType checkSumType){\n-\n-    \tfileReplacePageHelper.resetReplaceFileHelper();\n-    \tsaveEnabled = false;\n-    \tString storageIdentifier = DataAccess.getStorarageIdFromLocation(fullStorageLocation);\n-    \tif (fileReplacePageHelper.handleNativeFileUpload(null, storageIdentifier, fileName, contentType, checkSumValue, checkSumType)){\n-    \t\tsaveEnabled = true;\n-\n-    \t\t/**\n-    \t\t * If the file content type changed, let the user know\n-    \t\t */\n-    \t\tif (fileReplacePageHelper.hasContentTypeWarning()){\n-    \t\t\t//Add warning to popup instead of page for Content Type Difference\n-    \t\t\tsetWarningMessageForFileTypeDifferentPopUp(fileReplacePageHelper.getContentTypeWarning());\n-    \t\t}\n-    \t} else {\n-    \t\tuploadWarningMessage = fileReplacePageHelper.getErrorMessages();\n-    \t}\n-    }\n-\n-    private String uploadWarningMessage = null; \n-    private String uploadSuccessMessage = null; \n-    private String uploadComponentId = null; \n-    \n-    /**\n-     * Handle native file replace\n-     * @param event \n-     * @throws java.io.IOException \n-     */\n-    public void handleFileUpload(FileUploadEvent event) throws IOException {\n-        \n-        if (uploadInProgress.isFalse()) {\n-            uploadInProgress.setValue(true);\n-        }\n-                \n-        //resetting marked as dup in case there are multiple uploads \n-        //we only want to delete as dupes those that we uploaded in this \n-        //session\n-        \n-        newFiles.forEach((df) -> {\n-            df.setMarkedAsDuplicate(false);\n-        });\n-        \n-        if (event == null){\n-            throw new NullPointerException(\"event cannot be null\");\n-        }\n-        \n-        UploadedFile uFile = event.getFile();\n-        if (uFile == null){\n-            throw new NullPointerException(\"uFile cannot be null\");\n-        }\n+  }\n \n+  private void handleReplaceFileUpload(String fullStorageLocation,\n+                                       String fileName,\n+                                       String contentType,\n+                                       String checkSumValue,\n+                                       ChecksumType checkSumType) {\n \n-        /**\n-         * For File Replace, take a different code path\n-         */\n-        if (isFileReplaceOperation()){\n+    fileReplacePageHelper.resetReplaceFileHelper();\n+    saveEnabled = false;\n+    String storageIdentifier = DataAccess.getStorarageIdFromLocation(fullStorageLocation);\n+    if (fileReplacePageHelper\n+      .handleNativeFileUpload(null, storageIdentifier, fileName, contentType, checkSumValue, checkSumType)) {\n+      saveEnabled = true;\n \n-            handleReplaceFileUpload(event, uFile.getInputStream(),\n-                                    uFile.getFileName(),\n-                                    uFile.getContentType(),\n-                                    event,\n-                                    null);\n-            if( fileReplacePageHelper.wasPhase1Successful() && fileReplacePageHelper.hasContentTypeWarning()){\n-                    //RequestContext context = RequestContext.getCurrentInstance();\n-                    //RequestContext.getCurrentInstance().update(\"datasetForm:fileTypeDifferentPopup\");\n-                    //context.execute(\"PF('fileTypeDifferentPopup').show();\");\n-                    PrimeFaces.current().ajax().update(\"datasetForm:fileTypeDifferentPopup\");\n-                    PrimeFaces.current().executeScript(\"PF('fileTypeDifferentPopup').show();\");\n-            }\n+      /**\n+       * If the file content type changed, let the user know\n+       */\n+      if (fileReplacePageHelper.hasContentTypeWarning()) {\n+        //Add warning to popup instead of page for Content Type Difference\n+        setWarningMessageForFileTypeDifferentPopUp(fileReplacePageHelper.getContentTypeWarning());\n+      }\n+    } else {\n+      uploadWarningMessage = fileReplacePageHelper.getErrorMessages();\n+    }\n+  }\n+\n+  private String uploadWarningMessage = null;\n+  private String uploadSuccessMessage = null;\n+  private String uploadComponentId = null;\n+\n+  /**\n+   * Handle native file replace\n+   *\n+   * @param event\n+   * @throws java.io.IOException\n+   */\n+  public void handleFileUpload(FileUploadEvent event) throws IOException {\n+\n+    if (uploadInProgress.isFalse()) {\n+      uploadInProgress.setValue(true);\n+    }\n+\n+    //resetting marked as dup in case there are multiple uploads\n+    //we only want to delete as dupes those that we uploaded in this\n+    //session\n+\n+    newFiles.forEach((df) -> {\n+      df.setMarkedAsDuplicate(false);\n+    });\n+\n+    if (event == null) {\n+      throw new NullPointerException(\"event cannot be null\");\n+    }\n+\n+    UploadedFile uFile = event.getFile();\n+    if (uFile == null) {\n+      throw new NullPointerException(\"uFile cannot be null\");\n+    }\n+\n+\n+    /**\n+     * For File Replace, take a different code path\n+     */\n+    if (isFileReplaceOperation()) {\n+\n+      handleReplaceFileUpload(event, uFile.getInputStream(),\n+        uFile.getFileName(),\n+        uFile.getContentType(),\n+        event,\n+        null);\n+      if (fileReplacePageHelper.wasPhase1Successful() && fileReplacePageHelper.hasContentTypeWarning()) {\n+        //RequestContext context = RequestContext.getCurrentInstance();\n+        //RequestContext.getCurrentInstance().update(\"datasetForm:fileTypeDifferentPopup\");\n+        //context.execute(\"PF('fileTypeDifferentPopup').show();\");\n+        PrimeFaces.current().ajax().update(\"datasetForm:fileTypeDifferentPopup\");\n+        PrimeFaces.current().executeScript(\"PF('fileTypeDifferentPopup').show();\");\n+      }\n             /*\n             \n \n@@ -1939,299 +1985,311 @@ public class EditDatafilesPage implements java.io.Serializable {\n                     PrimeFaces.current().executeScript(\"PF('fileTypeDifferentPopup').show();\");\n             }\n                         */\n-            return;\n-               \n-        }\n+      return;\n \n-   \n-        List<DataFile> dFileList = null;\n-        \n-        try {\n-            // Note: A single uploaded file may produce multiple datafiles - \n-            // for example, multiple files can be extracted from an uncompressed\n-            // zip file. \n-            dFileList = FileUtil.createDataFiles(workingVersion, uFile.getInputStream(), uFile.getFileName(), uFile.getContentType(), null, null, systemConfig);\n-            \n-        } catch (IOException ioex) {\n-            logger.warning(\"Failed to process and/or save the file \" + uFile.getFileName() + \"; \" + ioex.getMessage());\n-            return;\n-        } /*catch (FileExceedsMaxSizeException ex) {\n+    }\n+\n+\n+    List<DataFile> dFileList = null;\n+\n+    try {\n+      // Note: A single uploaded file may produce multiple datafiles -\n+      // for example, multiple files can be extracted from an uncompressed\n+      // zip file.\n+      dFileList = FileUtil\n+        .createDataFiles(workingVersion, uFile.getInputStream(), uFile.getFileName(), uFile.getContentType(), null,\n+          null, systemConfig);\n+\n+    } catch (IOException ioex) {\n+      logger.warning(\"Failed to process and/or save the file \" + uFile.getFileName() + \"; \" + ioex.getMessage());\n+      return;\n+    } /*catch (FileExceedsMaxSizeException ex) {\n             logger.warning(\"Failed to process and/or save the file \" + uFile.getFileName() + \"; \" + ex.getMessage());\n             return;\n         }*/\n \n-        // -----------------------------------------------------------\n-        // These raw datafiles are then post-processed, in order to drop any files \n-        // already in the dataset/already uploaded, and to correct duplicate file names, etc. \n-        // -----------------------------------------------------------\n-        String warningMessage = processUploadedFileList(dFileList);\n-        \n-        if (warningMessage != null){\n-            uploadWarningMessage = warningMessage;\n-            FacesContext.getCurrentInstance().addMessage(event.getComponent().getClientId(), new FacesMessage(FacesMessage.SEVERITY_ERROR, BundleUtil.getStringFromBundle(\"dataset.file.uploadWarning\"), warningMessage));\n-            // save the component id of the p:upload widget, so that we could \n-            // send an info message there, from elsewhere in the code:\n-            uploadComponentId = event.getComponent().getClientId();\n-        }\n-        \n-        if(uploadInProgress.isFalse()) {\n-            logger.warning(\"Upload in progress cancelled\");\n-            for (DataFile newFile : dFileList) {\n-                FileUtil.deleteTempFile(newFile, dataset, ingestService);\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Using information from the DropBox choose, ingest the chosen files\n-     *  https://www.dropbox.com/developers/dropins/chooser/js\n-     * \n-     * @param event\n-     */\n-    public void handleExternalUpload() {\n-    \tMap<String,String> paramMap = FacesContext.getCurrentInstance().getExternalContext().getRequestParameterMap();\n-    \t\n-    \tthis.uploadComponentId = paramMap.get(\"uploadComponentId\");\n-        String fullStorageIdentifier = paramMap.get(\"fullStorageIdentifier\");\n-        String fileName = paramMap.get(\"fileName\");\n-        String contentType = paramMap.get(\"contentType\");\n-        String checksumTypeString = paramMap.get(\"checksumType\");\n-        String checksumValue = paramMap.get(\"checksumValue\");\n-        ChecksumType checksumType = null;\n-        if (!checksumTypeString.isBlank()) {\n-            checksumType = ChecksumType.fromString(checksumTypeString);\n-        }\n-        int lastColon = fullStorageIdentifier.lastIndexOf(':');\n-        String storageLocation= fullStorageIdentifier.substring(0,lastColon) + \"/\" + dataset.getAuthorityForFileStorage() + \"/\" + dataset.getIdentifierForFileStorage() + \"/\" + fullStorageIdentifier.substring(lastColon+1);\n-    \tif (uploadInProgress.isFalse()) {\n-    \t\tuploadInProgress.setValue(true);\n-    \t}\n-    \tlogger.fine(\"handleExternalUpload\");\n-    \t\n-    \tStorageIO<DvObject> sio;\n-    \tString localWarningMessage = null;\n-    \ttry {\n-    \t\tsio = DataAccess.getDirectStorageIO(storageLocation);\n-\n-    \t\t//Populate metadata\n-    \t\tsio.open(DataAccessOption.READ_ACCESS);\n-    \t\t//get file size\n-    \t\tlong fileSize = sio.getSize();\n-\n-\t\t\tif(StringUtils.isEmpty(contentType)) {\n-\t\t\t\tcontentType = FileUtil.MIME_TYPE_UNDETERMINED_DEFAULT;\n-\t\t\t}\n+    // -----------------------------------------------------------\n+    // These raw datafiles are then post-processed, in order to drop any files\n+    // already in the dataset/already uploaded, and to correct duplicate file names, etc.\n+    // -----------------------------------------------------------\n+    String warningMessage = processUploadedFileList(dFileList);\n+\n+    if (warningMessage != null) {\n+      uploadWarningMessage = warningMessage;\n+      FacesContext.getCurrentInstance().addMessage(event.getComponent().getClientId(),\n+        new FacesMessage(FacesMessage.SEVERITY_ERROR, BundleUtil.getStringFromBundle(\"dataset.file.uploadWarning\"),\n+          warningMessage));\n+      // save the component id of the p:upload widget, so that we could\n+      // send an info message there, from elsewhere in the code:\n+      uploadComponentId = event.getComponent().getClientId();\n+    }\n+\n+    if (uploadInProgress.isFalse()) {\n+      logger.warning(\"Upload in progress cancelled\");\n+      for (DataFile newFile : dFileList) {\n+        FileUtil.deleteTempFile(newFile, dataset, ingestService);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Using information from the DropBox choose, ingest the chosen files\n+   * https://www.dropbox.com/developers/dropins/chooser/js\n+   *\n+   * @param event\n+   */\n+  public void handleExternalUpload() {\n+    Map<String, String> paramMap = FacesContext.getCurrentInstance().getExternalContext().getRequestParameterMap();\n+\n+    this.uploadComponentId = paramMap.get(\"uploadComponentId\");\n+    String fullStorageIdentifier = paramMap.get(\"fullStorageIdentifier\");\n+    String fileName = paramMap.get(\"fileName\");\n+    String contentType = paramMap.get(\"contentType\");\n+    String checksumTypeString = paramMap.get(\"checksumType\");\n+    String checksumValue = paramMap.get(\"checksumValue\");\n+    ChecksumType checksumType = null;\n+    if (!checksumTypeString.isBlank()) {\n+      checksumType = ChecksumType.fromString(checksumTypeString);\n+    }\n+    int lastColon = fullStorageIdentifier.lastIndexOf(':');\n+    String storageLocation =\n+      fullStorageIdentifier.substring(0, lastColon) + \"/\" + dataset.getAuthorityForFileStorage() + \"/\" +\n+        dataset.getIdentifierForFileStorage() + \"/\" + fullStorageIdentifier.substring(lastColon + 1);\n+    if (uploadInProgress.isFalse()) {\n+      uploadInProgress.setValue(true);\n+    }\n+    logger.fine(\"handleExternalUpload\");\n+\n+    StorageIO<DvObject> sio;\n+    String localWarningMessage = null;\n+    try {\n+      sio = DataAccess.getDirectStorageIO(storageLocation);\n+\n+      //Populate metadata\n+      sio.open(DataAccessOption.READ_ACCESS);\n+      //get file size\n+      long fileSize = sio.getSize();\n+\n+      if (StringUtils.isEmpty(contentType)) {\n+        contentType = FileUtil.MIME_TYPE_UNDETERMINED_DEFAULT;\n+      }\n \t\t\t\n     \t\t/* ----------------------------\n                 Check file size\n                 - Max size NOT specified in db: default is unlimited\n                 - Max size specified in db: check too make sure file is within limits\n             // ---------------------------- */\n-    \t\tif ((!this.isUnlimitedUploadFileSize()) && (fileSize > this.getMaxFileUploadSizeInBytes())) {\n-    \t\t\tString warningMessage = \"Uploaded file \\\"\" + fileName + \"\\\" exceeded the limit of \" + fileSize + \" bytes and was not uploaded.\";\n-    \t\t\tsio.delete();\n-    \t\t\tlocalWarningMessage = warningMessage;\n-    \t\t} else {\n-    \t\t\t// -----------------------------------------------------------\n-    \t\t\t// Is this a FileReplaceOperation?  If so, then diverge!\n-    \t\t\t// -----------------------------------------------------------\n-    \t\t\tif (this.isFileReplaceOperation()){\n-    \t\t\t\tthis.handleReplaceFileUpload(storageLocation, fileName, contentType, checksumValue, checksumType);\n-    \t\t\t\tthis.setFileMetadataSelectedForTagsPopup(fileReplacePageHelper.getNewFileMetadatasBeforeSave().get(0));\n-    \t\t\t\treturn;\n-    \t\t\t}\n-    \t\t\t// -----------------------------------------------------------\n-    \t\t\tList<DataFile> datafiles = new ArrayList<>(); \n-\n-    \t\t\t// -----------------------------------------------------------\n-    \t\t\t// Send it through the ingest service\n-    \t\t\t// -----------------------------------------------------------\n-    \t\t\ttry {\n-\n-    \t\t\t\t// Note: A single uploaded file may produce multiple datafiles - \n-    \t\t\t\t// for example, multiple files can be extracted from an uncompressed\n-    \t\t\t\t// zip file.\n-    \t\t\t\t//datafiles = ingestService.createDataFiles(workingVersion, dropBoxStream, fileName, \"application/octet-stream\");\n-\n-\n-    \t\t\t\tdatafiles = FileUtil.createDataFiles(workingVersion, null, fileName, contentType, fullStorageIdentifier, checksumValue, checksumType, systemConfig);\n-    \t\t\t} catch (IOException ex) {\n-    \t\t\t\tlogger.log(Level.SEVERE, \"Error during ingest of file {0}\", new Object[]{fileName});\n-    \t\t\t}\n-\n-    \t\t\tif (datafiles == null){\n-    \t\t\t\tlogger.log(Level.SEVERE, \"Failed to create DataFile for file {0}\", new Object[]{fileName});\n-    \t\t\t}else{    \n-    \t\t\t\t// -----------------------------------------------------------\n-    \t\t\t\t// Check if there are duplicate files or ingest warnings\n-    \t\t\t\t// -----------------------------------------------------------\n-    \t\t\t\tuploadWarningMessage = processUploadedFileList(datafiles);\n-    \t\t\t}\n-    \t\t\tif(uploadInProgress.isFalse()) {\n-    \t\t\t\tlogger.warning(\"Upload in progress cancelled\");\n-    \t\t\t\tfor (DataFile newFile : datafiles) {\n-    \t\t\t\t\tFileUtil.deleteTempFile(newFile, dataset, ingestService);\n-    \t\t\t\t}\n-    \t\t\t}\n-    \t\t}\n-    \t} catch (IOException e) {\n-    \t\tlogger.log(Level.SEVERE, \"Failed to create DataFile for file {0}: {1}\", new Object[]{fileName, e.getMessage()});\n-    \t}\n-    \tif (localWarningMessage != null) {\n-    \t\tif (uploadWarningMessage == null) {\n-    \t\t\tuploadWarningMessage = localWarningMessage;\n-    \t\t} else {\n-    \t\t\tuploadWarningMessage = localWarningMessage.concat(\"; \" + uploadWarningMessage);\n-    \t\t}\n-    \t}\n-    }\n-    \n-    /**\n-     *  After uploading via the site or Dropbox, \n-     *  check the list of DataFile objects\n-     * @param dFileList \n-     */\n-    \n-    private String existingFilesWithDupeContent = null; \n-    private String uploadedFilesWithDupeContentToExisting = null;\n-    private String uploadedFilesWithDupeContentToNewlyUploaded = null;\n-    private String newlyUploadedFilesWithDupeContent = null;\n-    \n-    private boolean multipleDupesExisting = false;\n-    private boolean multipleDupesNew = false;\n-    \n-    public String getExistingFilesWithDupeContent() {\n-        return existingFilesWithDupeContent;\n-    }\n-\n-    public void setExistingFilesWithDupeContent(String existingFilesWithDupeContent) {\n-        this.existingFilesWithDupeContent = existingFilesWithDupeContent;\n-    }\n-\n-    public String getUploadedFilesWithDupeContentToExisting() {\n-        return uploadedFilesWithDupeContentToExisting;\n-    }\n-\n-    public void setUploadedFilesWithDupeContentToExisting(String uploadedFilesWithDupeContentToExisting) {\n-        this.uploadedFilesWithDupeContentToExisting = uploadedFilesWithDupeContentToExisting;\n-    }\n-\n-    public String getUploadedFilesWithDupeContentToNewlyUploaded() {\n-        return uploadedFilesWithDupeContentToNewlyUploaded;\n-    }\n-\n-    public void setUploadedFilesWithDupeContentToNewlyUploaded(String uploadedFilesWithDupeContentToNewlyUploaded) {\n-        this.uploadedFilesWithDupeContentToNewlyUploaded = uploadedFilesWithDupeContentToNewlyUploaded;\n-    }\n-\n-    public String getNewlyUploadedFilesWithDupeContent() {\n-        return newlyUploadedFilesWithDupeContent;\n-    }\n-\n-    public void setNewlyUploadedFilesWithDupeContent(String newlyUploadedFilesWithDupeContent) {\n-        this.newlyUploadedFilesWithDupeContent = newlyUploadedFilesWithDupeContent;\n-    }\n-\n-\n-    public boolean isMultipleDupesExisting() {\n-        return multipleDupesExisting;\n-    }\n-\n-    public void setMultipleDupesExisting(boolean multipleDupesExisting) {\n-        this.multipleDupesExisting = multipleDupesExisting;\n-    }\n-\n-    public boolean isMultipleDupesNew() {\n-        return multipleDupesNew;\n-    }\n-\n-    public void setMultipleDupesNew(boolean multipleDupesNew) {\n-        this.multipleDupesNew = multipleDupesNew;\n-    }\n-\n-    private String processUploadedFileList(List<DataFile> dFileList) {\n-        if (dFileList == null) {\n-            return null;\n+      if ((!this.isUnlimitedUploadFileSize()) && (fileSize > this.getMaxFileUploadSizeInBytes())) {\n+        String warningMessage =\n+          \"Uploaded file \\\"\" + fileName + \"\\\" exceeded the limit of \" + fileSize + \" bytes and was not uploaded.\";\n+        sio.delete();\n+        localWarningMessage = warningMessage;\n+      } else {\n+        // -----------------------------------------------------------\n+        // Is this a FileReplaceOperation?  If so, then diverge!\n+        // -----------------------------------------------------------\n+        if (this.isFileReplaceOperation()) {\n+          this.handleReplaceFileUpload(storageLocation, fileName, contentType, checksumValue, checksumType);\n+          this.setFileMetadataSelectedForTagsPopup(fileReplacePageHelper.getNewFileMetadatasBeforeSave().get(0));\n+          return;\n         }\n-        \n-        uploadedInThisProcess = new ArrayList();\n-\n-        DataFile dataFile;\n-        String warningMessage = null;\n+        // -----------------------------------------------------------\n+        List<DataFile> datafiles = new ArrayList<>();\n \n-        // NOTE: for native file uploads, the dFileList will only \n-        // contain 1 file--method is called for every file even if the UI shows \"simultaneous uploads\"\n-        \n         // -----------------------------------------------------------\n-        // Iterate through list of DataFile objects\n+        // Send it through the ingest service\n         // -----------------------------------------------------------\n-        for (DataFile dFileList1 : dFileList) {\n-            dataFile = dFileList1;\n-            // -----------------------------------------------------------\n-            // Check for ingest warnings\n-            // -----------------------------------------------------------\n-            if (dataFile.isIngestProblem()) {\n-                if (dataFile.getIngestReportMessage() != null) {\n-                    if (warningMessage == null) {\n-                        warningMessage = dataFile.getIngestReportMessage();\n-                    } else {\n-                        warningMessage = warningMessage.concat(\"; \" + dataFile.getIngestReportMessage());\n-                    }\n-                }\n-                dataFile.setIngestDone();\n-            }\n+        try {\n \n-            // -----------------------------------------------------------\n-            // Check for duplicates -- e.g. file is already in the dataset, \n-            // or if another file with the same checksum has already been \n-            // uploaded.\n-            // -----------------------------------------------------------\n-\n-            if (isFileAlreadyInDataset(dataFile)) {\n-                DataFile existingFile = fileAlreadyExists.get(dataFile);\n-                \n-                // String alreadyExists = dataFile.getFileMetadata().getLabel() + \" at \" + existingFile.getDirectoryLabel() != null ? existingFile.getDirectoryLabel() + \"/\" + existingFile.getDisplayName() : existingFile.getDisplayName();\n-                String uploadedDuplicateFileName = dataFile.getFileMetadata().getLabel();\n-                String existingFileName = existingFile.getDisplayName();\n-                List<String> args = Arrays.asList(existingFileName);\n-                String inLineMessage = BundleUtil.getStringFromBundle(\"dataset.file.inline.message\", args);\n-\n-                if (existingFilesWithDupeContent == null) {\n-                    existingFilesWithDupeContent = existingFileName;\n-                    uploadedFilesWithDupeContentToExisting = uploadedDuplicateFileName;\n-                } else {\n-                    existingFilesWithDupeContent = existingFilesWithDupeContent.concat(\", \" + existingFileName);\n-                    uploadedFilesWithDupeContentToExisting = uploadedFilesWithDupeContentToExisting.concat(\", \" + uploadedDuplicateFileName);\n-                    multipleDupesExisting = true;\n-                }\n-                //now we are marking as duplicate and\n-                //allowing the user to decide whether to delete\n-                //   deleteTempFile(dataFile);\n-                dataFile.setMarkedAsDuplicate(true);\n-                dataFile.setDuplicateFilename(inLineMessage);\n-\n-            } else if (isFileAlreadyUploaded(dataFile)) {\n-                DataFile existingFile = checksumMapNew.get(dataFile.getChecksumValue());\n-                String alreadyUploadedWithSame =  existingFile.getDisplayName();\n-                String newlyUploadedDupe = dataFile.getFileMetadata().getLabel();\n-                if (newlyUploadedFilesWithDupeContent == null) {\n-                    newlyUploadedFilesWithDupeContent = newlyUploadedDupe;\n-                    uploadedFilesWithDupeContentToNewlyUploaded = alreadyUploadedWithSame;\n-                } else {\n-                    newlyUploadedFilesWithDupeContent = newlyUploadedFilesWithDupeContent.concat(\", \" + newlyUploadedDupe);\n-                    uploadedFilesWithDupeContentToNewlyUploaded = uploadedFilesWithDupeContentToNewlyUploaded.concat(\", \" + alreadyUploadedWithSame);\n-                    multipleDupesNew = true;\n-                }\n-                //now we are marking as duplicate and\n-                //allowing the user to decide whether to delete\n-                dataFile.setMarkedAsDuplicate(true);\n-                List<String> args = Arrays.asList(existingFile.getDisplayName());\n-                String inLineMessage = BundleUtil.getStringFromBundle(\"dataset.file.inline.message\", args);\n-                dataFile.setDuplicateFilename(inLineMessage);\n-            } else {\n-                // OK, this one is not a duplicate, we want it. \n-                // But let's check if its filename is a duplicate of another \n-                // file already uploaded, or already in the dataset:\n+          // Note: A single uploaded file may produce multiple datafiles -\n+          // for example, multiple files can be extracted from an uncompressed\n+          // zip file.\n+          //datafiles = ingestService.createDataFiles(workingVersion, dropBoxStream, fileName, \"application/octet-stream\");\n+\n+\n+          datafiles = FileUtil\n+            .createDataFiles(workingVersion, null, fileName, contentType, fullStorageIdentifier, checksumValue,\n+              checksumType, systemConfig);\n+        } catch (IOException ex) {\n+          logger.log(Level.SEVERE, \"Error during ingest of file {0}\", new Object[] {fileName});\n+        }\n+\n+        if (datafiles == null) {\n+          logger.log(Level.SEVERE, \"Failed to create DataFile for file {0}\", new Object[] {fileName});\n+        } else {\n+          // -----------------------------------------------------------\n+          // Check if there are duplicate files or ingest warnings\n+          // -----------------------------------------------------------\n+          uploadWarningMessage = processUploadedFileList(datafiles);\n+        }\n+        if (uploadInProgress.isFalse()) {\n+          logger.warning(\"Upload in progress cancelled\");\n+          for (DataFile newFile : datafiles) {\n+            FileUtil.deleteTempFile(newFile, dataset, ingestService);\n+          }\n+        }\n+      }\n+    } catch (IOException e) {\n+      logger.log(Level.SEVERE, \"Failed to create DataFile for file {0}: {1}\", new Object[] {fileName, e.getMessage()});\n+    }\n+    if (localWarningMessage != null) {\n+      if (uploadWarningMessage == null) {\n+        uploadWarningMessage = localWarningMessage;\n+      } else {\n+        uploadWarningMessage = localWarningMessage.concat(\"; \" + uploadWarningMessage);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * After uploading via the site or Dropbox,\n+   * check the list of DataFile objects\n+   *\n+   * @param dFileList\n+   */\n+\n+  private String existingFilesWithDupeContent = null;\n+  private String uploadedFilesWithDupeContentToExisting = null;\n+  private String uploadedFilesWithDupeContentToNewlyUploaded = null;\n+  private String newlyUploadedFilesWithDupeContent = null;\n+\n+  private boolean multipleDupesExisting = false;\n+  private boolean multipleDupesNew = false;\n+\n+  public String getExistingFilesWithDupeContent() {\n+    return existingFilesWithDupeContent;\n+  }\n+\n+  public void setExistingFilesWithDupeContent(String existingFilesWithDupeContent) {\n+    this.existingFilesWithDupeContent = existingFilesWithDupeContent;\n+  }\n+\n+  public String getUploadedFilesWithDupeContentToExisting() {\n+    return uploadedFilesWithDupeContentToExisting;\n+  }\n+\n+  public void setUploadedFilesWithDupeContentToExisting(String uploadedFilesWithDupeContentToExisting) {\n+    this.uploadedFilesWithDupeContentToExisting = uploadedFilesWithDupeContentToExisting;\n+  }\n+\n+  public String getUploadedFilesWithDupeContentToNewlyUploaded() {\n+    return uploadedFilesWithDupeContentToNewlyUploaded;\n+  }\n+\n+  public void setUploadedFilesWithDupeContentToNewlyUploaded(String uploadedFilesWithDupeContentToNewlyUploaded) {\n+    this.uploadedFilesWithDupeContentToNewlyUploaded = uploadedFilesWithDupeContentToNewlyUploaded;\n+  }\n+\n+  public String getNewlyUploadedFilesWithDupeContent() {\n+    return newlyUploadedFilesWithDupeContent;\n+  }\n+\n+  public void setNewlyUploadedFilesWithDupeContent(String newlyUploadedFilesWithDupeContent) {\n+    this.newlyUploadedFilesWithDupeContent = newlyUploadedFilesWithDupeContent;\n+  }\n+\n+\n+  public boolean isMultipleDupesExisting() {\n+    return multipleDupesExisting;\n+  }\n+\n+  public void setMultipleDupesExisting(boolean multipleDupesExisting) {\n+    this.multipleDupesExisting = multipleDupesExisting;\n+  }\n+\n+  public boolean isMultipleDupesNew() {\n+    return multipleDupesNew;\n+  }\n+\n+  public void setMultipleDupesNew(boolean multipleDupesNew) {\n+    this.multipleDupesNew = multipleDupesNew;\n+  }\n+\n+  private String processUploadedFileList(List<DataFile> dFileList) {\n+    if (dFileList == null) {\n+      return null;\n+    }\n+\n+    uploadedInThisProcess = new ArrayList();\n+\n+    DataFile dataFile;\n+    String warningMessage = null;\n+\n+    // NOTE: for native file uploads, the dFileList will only\n+    // contain 1 file--method is called for every file even if the UI shows \"simultaneous uploads\"\n+\n+    // -----------------------------------------------------------\n+    // Iterate through list of DataFile objects\n+    // -----------------------------------------------------------\n+    for (DataFile dFileList1 : dFileList) {\n+      dataFile = dFileList1;\n+      // -----------------------------------------------------------\n+      // Check for ingest warnings\n+      // -----------------------------------------------------------\n+      if (dataFile.isIngestProblem()) {\n+        if (dataFile.getIngestReportMessage() != null) {\n+          if (warningMessage == null) {\n+            warningMessage = dataFile.getIngestReportMessage();\n+          } else {\n+            warningMessage = warningMessage.concat(\"; \" + dataFile.getIngestReportMessage());\n+          }\n+        }\n+        dataFile.setIngestDone();\n+      }\n+\n+      // -----------------------------------------------------------\n+      // Check for duplicates -- e.g. file is already in the dataset,\n+      // or if another file with the same checksum has already been\n+      // uploaded.\n+      // -----------------------------------------------------------\n+\n+      if (isFileAlreadyInDataset(dataFile)) {\n+        DataFile existingFile = fileAlreadyExists.get(dataFile);\n+\n+        // String alreadyExists = dataFile.getFileMetadata().getLabel() + \" at \" + existingFile.getDirectoryLabel() != null ? existingFile.getDirectoryLabel() + \"/\" + existingFile.getDisplayName() : existingFile.getDisplayName();\n+        String uploadedDuplicateFileName = dataFile.getFileMetadata().getLabel();\n+        String existingFileName = existingFile.getDisplayName();\n+        List<String> args = Arrays.asList(existingFileName);\n+        String inLineMessage = BundleUtil.getStringFromBundle(\"dataset.file.inline.message\", args);\n+\n+        if (existingFilesWithDupeContent == null) {\n+          existingFilesWithDupeContent = existingFileName;\n+          uploadedFilesWithDupeContentToExisting = uploadedDuplicateFileName;\n+        } else {\n+          existingFilesWithDupeContent = existingFilesWithDupeContent.concat(\", \" + existingFileName);\n+          uploadedFilesWithDupeContentToExisting =\n+            uploadedFilesWithDupeContentToExisting.concat(\", \" + uploadedDuplicateFileName);\n+          multipleDupesExisting = true;\n+        }\n+        //now we are marking as duplicate and\n+        //allowing the user to decide whether to delete\n+        //   deleteTempFile(dataFile);\n+        dataFile.setMarkedAsDuplicate(true);\n+        dataFile.setDuplicateFilename(inLineMessage);\n+\n+      } else if (isFileAlreadyUploaded(dataFile)) {\n+        DataFile existingFile = checksumMapNew.get(dataFile.getChecksumValue());\n+        String alreadyUploadedWithSame = existingFile.getDisplayName();\n+        String newlyUploadedDupe = dataFile.getFileMetadata().getLabel();\n+        if (newlyUploadedFilesWithDupeContent == null) {\n+          newlyUploadedFilesWithDupeContent = newlyUploadedDupe;\n+          uploadedFilesWithDupeContentToNewlyUploaded = alreadyUploadedWithSame;\n+        } else {\n+          newlyUploadedFilesWithDupeContent = newlyUploadedFilesWithDupeContent.concat(\", \" + newlyUploadedDupe);\n+          uploadedFilesWithDupeContentToNewlyUploaded =\n+            uploadedFilesWithDupeContentToNewlyUploaded.concat(\", \" + alreadyUploadedWithSame);\n+          multipleDupesNew = true;\n+        }\n+        //now we are marking as duplicate and\n+        //allowing the user to decide whether to delete\n+        dataFile.setMarkedAsDuplicate(true);\n+        List<String> args = Arrays.asList(existingFile.getDisplayName());\n+        String inLineMessage = BundleUtil.getStringFromBundle(\"dataset.file.inline.message\", args);\n+        dataFile.setDuplicateFilename(inLineMessage);\n+      } else {\n+        // OK, this one is not a duplicate, we want it.\n+        // But let's check if its filename is a duplicate of another\n+        // file already uploaded, or already in the dataset:\n                 /*\n                 dataFile.getFileMetadata().setLabel(duplicateFilenameCheck(dataFile.getFileMetadata()));\n                 if (isTemporaryPreviewAvailable(dataFile.getStorageIdentifier(), dataFile.getContentType())) {\n@@ -2239,18 +2297,18 @@ public class EditDatafilesPage implements java.io.Serializable {\n                 }\n                 uploadedFiles.add(dataFile);\n                 */\n-                // We are NOT adding the fileMetadata to the list that is being used\n-                // to render the page; we'll do that once we know that all the individual uploads\n-                // in this batch (as in, a bunch of drag-and-dropped files) have finished. \n-                //fileMetadatas.add(dataFile.getFileMetadata());\n-            }\n-            \n-            dataFile.getFileMetadata().setLabel(duplicateFilenameCheck(dataFile.getFileMetadata()));\n-            if (isTemporaryPreviewAvailable(dataFile.getStorageIdentifier(), dataFile.getContentType())) {\n-                dataFile.setPreviewImageAvailable(true);\n-            }\n-            uploadedFiles.add(dataFile);\n-            uploadedInThisProcess.add(dataFile);\n+        // We are NOT adding the fileMetadata to the list that is being used\n+        // to render the page; we'll do that once we know that all the individual uploads\n+        // in this batch (as in, a bunch of drag-and-dropped files) have finished.\n+        //fileMetadatas.add(dataFile.getFileMetadata());\n+      }\n+\n+      dataFile.getFileMetadata().setLabel(duplicateFilenameCheck(dataFile.getFileMetadata()));\n+      if (isTemporaryPreviewAvailable(dataFile.getStorageIdentifier(), dataFile.getContentType())) {\n+        dataFile.setPreviewImageAvailable(true);\n+      }\n+      uploadedFiles.add(dataFile);\n+      uploadedInThisProcess.add(dataFile);\n             /*\n              preserved old, pre 4.6 code - mainly as an illustration of how we used to do this. \n             \n@@ -2286,723 +2344,739 @@ public class EditDatafilesPage implements java.io.Serializable {\n                     }\n                 }\n             } */\n-        }\n-        \n-        // -----------------------------------------------------------\n-        // Format error message for duplicate files\n-        // (note the separate messages for the files already in the dataset, \n-        // and the newly uploaded ones)\n-        // -----------------------------------------------------------\n-        if (existingFilesWithDupeContent != null) {\n-            String duplicateFilesErrorMessage = null;\n-            List<String> args = Arrays.asList(uploadedFilesWithDupeContentToExisting, existingFilesWithDupeContent);\n+    }\n \n-            if (multipleDupesExisting) {                              \n-                duplicateFilesErrorMessage = BundleUtil.getStringFromBundle(\"dataset.files.exist\", args);\n-            } else {\n-            \tduplicateFilesErrorMessage =  BundleUtil.getStringFromBundle(\"dataset.file.exist\", args);\n-            }\n-            if (warningMessage == null) {\n-                warningMessage = duplicateFilesErrorMessage;\n-            } else {\n-                warningMessage = warningMessage.concat(\" \" + duplicateFilesErrorMessage);\n-            }\n-        }\n+    // -----------------------------------------------------------\n+    // Format error message for duplicate files\n+    // (note the separate messages for the files already in the dataset,\n+    // and the newly uploaded ones)\n+    // -----------------------------------------------------------\n+    if (existingFilesWithDupeContent != null) {\n+      String duplicateFilesErrorMessage = null;\n+      List<String> args = Arrays.asList(uploadedFilesWithDupeContentToExisting, existingFilesWithDupeContent);\n \n-        if (newlyUploadedFilesWithDupeContent != null) {\n-            String duplicateFilesErrorMessage = null;\n-            List<String> args = Arrays.asList(newlyUploadedFilesWithDupeContent, uploadedFilesWithDupeContentToNewlyUploaded);\n+      if (multipleDupesExisting) {\n+        duplicateFilesErrorMessage = BundleUtil.getStringFromBundle(\"dataset.files.exist\", args);\n+      } else {\n+        duplicateFilesErrorMessage = BundleUtil.getStringFromBundle(\"dataset.file.exist\", args);\n+      }\n+      if (warningMessage == null) {\n+        warningMessage = duplicateFilesErrorMessage;\n+      } else {\n+        warningMessage = warningMessage.concat(\" \" + duplicateFilesErrorMessage);\n+      }\n+    }\n \n-            if (multipleDupesNew) {                              \n-                duplicateFilesErrorMessage = BundleUtil.getStringFromBundle(\"dataset.files.duplicate\", args);\n-            } else {\n-            \tduplicateFilesErrorMessage =  BundleUtil.getStringFromBundle(\"dataset.file.duplicate\", args);\n-            }\n-            if (warningMessage == null) {\n-                warningMessage = duplicateFilesErrorMessage;\n-            } else {\n-                warningMessage = warningMessage.concat(\" \" + duplicateFilesErrorMessage);\n-            }\n-        }\n+    if (newlyUploadedFilesWithDupeContent != null) {\n+      String duplicateFilesErrorMessage = null;\n+      List<String> args = Arrays.asList(newlyUploadedFilesWithDupeContent, uploadedFilesWithDupeContentToNewlyUploaded);\n \n-        if (warningMessage != null) {\n-            logger.severe(warningMessage);\n-            return warningMessage;\n-        }\n+      if (multipleDupesNew) {\n+        duplicateFilesErrorMessage = BundleUtil.getStringFromBundle(\"dataset.files.duplicate\", args);\n+      } else {\n+        duplicateFilesErrorMessage = BundleUtil.getStringFromBundle(\"dataset.file.duplicate\", args);\n+      }\n+      if (warningMessage == null) {\n+        warningMessage = duplicateFilesErrorMessage;\n+      } else {\n+        warningMessage = warningMessage.concat(\" \" + duplicateFilesErrorMessage);\n+      }\n+    }\n \n-        return null;\n+    if (warningMessage != null) {\n+      logger.severe(warningMessage);\n+      return warningMessage;\n     }\n-    \n-    private Map<String, String> temporaryThumbnailsMap = new HashMap<>();\n-    \n-    public boolean isTemporaryPreviewAvailable(String fileSystemId, String mimeType) {\n-        if (temporaryThumbnailsMap.get(fileSystemId) != null && !temporaryThumbnailsMap.get(fileSystemId).isEmpty()) {\n-            return true;\n-        }\n-        \n-        if (\"\".equals(temporaryThumbnailsMap.get(fileSystemId))) {\n-            // we've already looked once - and there's no thumbnail.\n-            return false;\n-        }\n-        \n-        String filesRootDirectory = System.getProperty(\"dataverse.files.directory\");\n-        if (filesRootDirectory == null || filesRootDirectory.isEmpty()) {\n-            filesRootDirectory = \"/tmp/files\";\n-        }\n \n-        String fileSystemName = filesRootDirectory + \"/temp/\" + fileSystemId;\n-        \n-        String imageThumbFileName = null;\n-        \n-        // ATTENTION! TODO: the current version of the method below may not be checking if files are already cached!\n-        if (\"application/pdf\".equals(mimeType)) {\n-            imageThumbFileName = ImageThumbConverter.generatePDFThumbnailFromFile(fileSystemName, ImageThumbConverter.DEFAULT_THUMBNAIL_SIZE);\n-        } else if (mimeType != null && mimeType.startsWith(\"image/\")) {\n-            imageThumbFileName = ImageThumbConverter.generateImageThumbnailFromFile(fileSystemName, ImageThumbConverter.DEFAULT_THUMBNAIL_SIZE);\n-        }\n-        \n-        if (imageThumbFileName != null) {\n-            File imageThumbFile = new File(imageThumbFileName);\n-            if (imageThumbFile.exists()) {\n-                String previewAsBase64 = ImageThumbConverter.getImageAsBase64FromFile(imageThumbFile); \n-                if (previewAsBase64 != null) {\n-                    temporaryThumbnailsMap.put(fileSystemId, previewAsBase64);\n-                    return true;\n-                } else {\n-                    temporaryThumbnailsMap.put(fileSystemId, \"\");\n-                }\n-            }\n-        }\n-            \n-        return false;\n+    return null;\n+  }\n+\n+  private Map<String, String> temporaryThumbnailsMap = new HashMap<>();\n+\n+  public boolean isTemporaryPreviewAvailable(String fileSystemId, String mimeType) {\n+    if (temporaryThumbnailsMap.get(fileSystemId) != null && !temporaryThumbnailsMap.get(fileSystemId).isEmpty()) {\n+      return true;\n     }\n-    \n-    public String getTemporaryPreviewAsBase64(String fileSystemId) {\n-        return temporaryThumbnailsMap.get(fileSystemId);\n+\n+    if (\"\".equals(temporaryThumbnailsMap.get(fileSystemId))) {\n+      // we've already looked once - and there's no thumbnail.\n+      return false;\n     }\n \n-    private Set<String> fileLabelsExisting = null; \n-    \n-    private String duplicateFilenameCheck(FileMetadata fileMetadata) {\n-        if (fileLabelsExisting == null) {\n-            fileLabelsExisting = IngestUtil.existingPathNamesAsSet(workingVersion);\n-        }\n-        \n-        return IngestUtil.duplicateFilenameCheck(fileMetadata, fileLabelsExisting);\n+    String filesRootDirectory = System.getProperty(\"dataverse.files.directory\");\n+    if (filesRootDirectory == null || filesRootDirectory.isEmpty()) {\n+      filesRootDirectory = \"/tmp/files\";\n     }\n \n-    private  Map<String, DataFile> checksumMapOld = null; // checksums of the files already in the dataset\n-    private  Map<String, DataFile> checksumMapNew = null; // checksums of the new files already uploaded\n-    private Map<DataFile, DataFile> fileAlreadyExists = null;\n-    \n-    private void initChecksumMap() {\n-        checksumMapOld = new HashMap<>();\n+    String fileSystemName = filesRootDirectory + \"/temp/\" + fileSystemId;\n \n-        Iterator<FileMetadata> fmIt = workingVersion.getFileMetadatas().iterator();\n+    String imageThumbFileName = null;\n \n-        while (fmIt.hasNext()) {\n-            FileMetadata fm = fmIt.next();\n-            if (fm.getDataFile() != null && fm.getDataFile().getId() != null) {\n-                String chksum = fm.getDataFile().getChecksumValue();\n-                if (chksum != null) {\n-                    checksumMapOld.put(chksum, fm.getDataFile());\n+    // ATTENTION! TODO: the current version of the method below may not be checking if files are already cached!\n+    if (\"application/pdf\".equals(mimeType)) {\n+      imageThumbFileName =\n+        ImageThumbConverter.generatePDFThumbnailFromFile(fileSystemName, ImageThumbConverter.DEFAULT_THUMBNAIL_SIZE);\n+    } else if (mimeType != null && mimeType.startsWith(\"image/\")) {\n+      imageThumbFileName =\n+        ImageThumbConverter.generateImageThumbnailFromFile(fileSystemName, ImageThumbConverter.DEFAULT_THUMBNAIL_SIZE);\n+    }\n \n-                }\n-            }\n+    if (imageThumbFileName != null) {\n+      File imageThumbFile = new File(imageThumbFileName);\n+      if (imageThumbFile.exists()) {\n+        String previewAsBase64 = ImageThumbConverter.getImageAsBase64FromFile(imageThumbFile);\n+        if (previewAsBase64 != null) {\n+          temporaryThumbnailsMap.put(fileSystemId, previewAsBase64);\n+          return true;\n+        } else {\n+          temporaryThumbnailsMap.put(fileSystemId, \"\");\n         }\n-\n+      }\n     }\n-    \n-    private boolean isFileAlreadyInDataset(DataFile dataFile) {\n-        if (checksumMapOld == null) {\n-            initChecksumMap();\n-        }\n-        \n-        if (fileAlreadyExists == null) {\n-            fileAlreadyExists = new HashMap<>();\n-        }\n-        \n \n-        String chksum = dataFile.getChecksumValue();\n-        \n-        if(checksumMapOld.get(chksum) != null){\n-           fileAlreadyExists.put(dataFile, checksumMapOld.get(chksum));\n-       }\n-        \n-        return chksum == null ? false : checksumMapOld.get(chksum) != null;\n-    }\n-    \n-    private boolean isFileAlreadyUploaded(DataFile dataFile) {\n+    return false;\n+  }\n \n-        if (checksumMapNew == null) {\n-            checksumMapNew = new HashMap<>();\n-        }\n+  public String getTemporaryPreviewAsBase64(String fileSystemId) {\n+    return temporaryThumbnailsMap.get(fileSystemId);\n+  }\n \n-        return FileUtil.isFileAlreadyUploaded(dataFile, checksumMapNew, fileAlreadyExists);\n-        \n-    }\n-    \n- \n-    public boolean isLocked() {\n-        if (dataset != null) {\n-            logger.log(Level.FINE, \"checking lock status of dataset {0}\", dataset.getId());\n-            if (dataset.isLocked()) {\n-                // refresh the dataset and version, if the current working\n-                // version of the dataset is locked:\n-            }\n-            Dataset lookedupDataset = datasetService.find(dataset.getId());\n-            \n-            if ( (lookedupDataset!=null) && lookedupDataset.isLocked() ) {\n-                logger.fine(\"locked!\");\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-    \n-    private Boolean lockedFromEditsVar;\n-    \n-    public boolean isLockedFromEdits() {\n-        if(null == lockedFromEditsVar ) {\n-            try {\n-                permissionService.checkEditDatasetLock(dataset, dvRequestService.getDataverseRequest(), new UpdateDatasetVersionCommand(dataset, dvRequestService.getDataverseRequest()));\n-                lockedFromEditsVar = false;\n-            } catch (IllegalCommandException ex) {\n-                lockedFromEditsVar = true;\n-            }\n-        }\n-        return lockedFromEditsVar;\n-    }\n-    \n-    // Methods for edit functions that are performed on one file at a time, \n-    // in popups that block the rest of the page:\n-    \n-    private FileMetadata fileMetadataSelected = null;\n+  private Set<String> fileLabelsExisting = null;\n \n-    public void  setFileMetadataSelected(FileMetadata fm){\n-       setFileMetadataSelected(fm, null); \n+  private String duplicateFilenameCheck(FileMetadata fileMetadata) {\n+    if (fileLabelsExisting == null) {\n+      fileLabelsExisting = IngestUtil.existingPathNamesAsSet(workingVersion);\n     }\n-    \n-    public void setFileMetadataSelected(FileMetadata fm, String guestbook) {\n \n-        fileMetadataSelected = fm;\n-        logger.log(Level.FINE, \"set the file for the advanced options popup ({0})\", fileMetadataSelected.getLabel());\n-    }\n+    return IngestUtil.duplicateFilenameCheck(fileMetadata, fileLabelsExisting);\n+  }\n \n-    public FileMetadata getFileMetadataSelected() {\n-        if (fileMetadataSelected != null) {\n-            logger.log(Level.FINE, \"returning file metadata for the advanced options popup ({0})\", fileMetadataSelected.getLabel());\n-        } else {\n-            logger.fine(\"file metadata for the advanced options popup is null.\");\n-        }\n-        return fileMetadataSelected;\n-    }\n+  private Map<String, DataFile> checksumMapOld = null; // checksums of the files already in the dataset\n+  private Map<String, DataFile> checksumMapNew = null; // checksums of the new files already uploaded\n+  private Map<DataFile, DataFile> fileAlreadyExists = null;\n+\n+  private void initChecksumMap() {\n+    checksumMapOld = new HashMap<>();\n+\n+    Iterator<FileMetadata> fmIt = workingVersion.getFileMetadatas().iterator();\n+\n+    while (fmIt.hasNext()) {\n+      FileMetadata fm = fmIt.next();\n+      if (fm.getDataFile() != null && fm.getDataFile().getId() != null) {\n+        String chksum = fm.getDataFile().getChecksumValue();\n+        if (chksum != null) {\n+          checksumMapOld.put(chksum, fm.getDataFile());\n \n-    public void clearFileMetadataSelected() {\n-        fileMetadataSelected = null;\n-    }\n-    \n-    public boolean isDesignatedDatasetThumbnail (FileMetadata fileMetadata) {\n-        if (fileMetadata != null) {\n-            if (fileMetadata.getDataFile() != null) {\n-                if (fileMetadata.getDataFile().getId() != null) {\n-                    //if (fileMetadata.getDataFile().getOwner() != null) {\n-                        if (fileMetadata.getDataFile().equals(dataset.getThumbnailFile())) {\n-                            return true;\n-                        }\n-                    //}\n-                }\n-            }\n         }\n-        return false;\n+      }\n     }\n-    \n-    /* \n-     * Items for the \"Designated this image as the Dataset thumbnail: \n-     */\n-    \n-    private FileMetadata fileMetadataSelectedForThumbnailPopup = null; \n \n-    /**\n-     * @param fm\n-     * @todo For consistency, we should disallow users from setting the\n-     * thumbnail to a restricted file. We enforce this rule in the newer\n-     * workflow in dataset-widgets.xhtml. The logic to show the \"Set Thumbnail\"\n-     * button is in editFilesFragment.xhtml and it would be nice to move it to\n-     * Java since it's getting long and a bit complicated.\n-     */\n-    public void  setFileMetadataSelectedForThumbnailPopup(FileMetadata fm){\n-       fileMetadataSelectedForThumbnailPopup = fm; \n-       alreadyDesignatedAsDatasetThumbnail = getUseAsDatasetThumbnail();\n+  }\n \n+  private boolean isFileAlreadyInDataset(DataFile dataFile) {\n+    if (checksumMapOld == null) {\n+      initChecksumMap();\n     }\n-    \n-    public FileMetadata getFileMetadataSelectedForThumbnailPopup() {\n-        return fileMetadataSelectedForThumbnailPopup;\n-    }\n-    \n-    public void clearFileMetadataSelectedForThumbnailPopup() {\n-        fileMetadataSelectedForThumbnailPopup = null;\n-    }\n-    \n-    private boolean alreadyDesignatedAsDatasetThumbnail = false; \n-    \n-    public boolean getUseAsDatasetThumbnail() {\n \n-        return isDesignatedDatasetThumbnail(fileMetadataSelectedForThumbnailPopup);\n+    if (fileAlreadyExists == null) {\n+      fileAlreadyExists = new HashMap<>();\n     }\n \n-    public void setUseAsDatasetThumbnail(boolean useAsThumbnail) {\n-        if (fileMetadataSelectedForThumbnailPopup != null) {\n-            if (fileMetadataSelectedForThumbnailPopup.getDataFile() != null) {\n-                if (useAsThumbnail) {\n-                    dataset.setThumbnailFile(fileMetadataSelectedForThumbnailPopup.getDataFile());\n-                } else if (getUseAsDatasetThumbnail()) {\n-                    dataset.setThumbnailFile(null);\n-                }\n-            }\n-        }\n-    }\n \n-    public void saveAsDesignatedThumbnail() {\n-        logger.fine(\"saving as the designated thumbnail\");\n-        // We don't need to do anything specific to save this setting, because\n-        // the setUseAsDatasetThumbnail() method, above, has already updated the\n-        // file object appropriately. \n-        // However, once the \"save\" button is pressed, we want to show a success message, if this is \n-        // a new image has been designated as such:\n-        if (getUseAsDatasetThumbnail() && !alreadyDesignatedAsDatasetThumbnail) {\n-            String successMessage = getBundleString(\"file.assignedDataverseImage.success\");\n-            logger.fine(successMessage);\n-            successMessage = successMessage.replace(\"{0}\", fileMetadataSelectedForThumbnailPopup.getLabel());\n-            JsfHelper.addFlashMessage(successMessage);\n-        }\n+    String chksum = dataFile.getChecksumValue();\n \n-        // And reset the selected fileMetadata:\n-        fileMetadataSelectedForThumbnailPopup = null;\n+    if (checksumMapOld.get(chksum) != null) {\n+      fileAlreadyExists.put(dataFile, checksumMapOld.get(chksum));\n     }\n \n-    public void deleteDatasetLogoAndUseThisDataFileAsThumbnailInstead() {\n-        logger.log(Level.FINE, \"For dataset id {0} the current thumbnail is from a dataset logo rather than a dataset file, blowing away the logo and using this FileMetadata id instead: {1}\", new Object[]{dataset.getId(), fileMetadataSelectedForThumbnailPopup});\n-        /**\n-         * @todo Rather than deleting and merging right away, try to respect how\n-         * this page seems to stage actions and giving the user a chance to\n-         * review before clicking \"Save Changes\".\n-         */\n-        try {\n-            DatasetThumbnail datasetThumbnail = commandEngine.submit(new UpdateDatasetThumbnailCommand(dvRequestService.getDataverseRequest(), dataset, UpdateDatasetThumbnailCommand.UserIntent.setDatasetFileAsThumbnail, fileMetadataSelectedForThumbnailPopup.getDataFile().getId(), null));\n-            // look up the dataset again because the UpdateDatasetThumbnailCommand mutates (merges) the dataset\n-            dataset = datasetService.find(dataset.getId());\n-        } catch (CommandException ex) {\n-            String error = \"Problem setting thumbnail for dataset id \" + dataset.getId() + \".: \" + ex;\n-            // show this error to the user?\n-            logger.info(error);\n-        }\n-    }\n+    return chksum == null ? false : checksumMapOld.get(chksum) != null;\n+  }\n+\n+  private boolean isFileAlreadyUploaded(DataFile dataFile) {\n \n-    public boolean isThumbnailIsFromDatasetLogoRatherThanDatafile() {\n-        DatasetThumbnail datasetThumbnail = dataset.getDatasetThumbnail(ImageThumbConverter.DEFAULT_CARDIMAGE_SIZE);\n-        return datasetThumbnail != null && !datasetThumbnail.isFromDataFile();\n+    if (checksumMapNew == null) {\n+      checksumMapNew = new HashMap<>();\n     }\n \n-    /* \n-     * Items for the \"Tags (Categories)\" popup.\n-     *\n-     */\n-    private FileMetadata fileMetadataSelectedForTagsPopup = null; \n+    return FileUtil.isFileAlreadyUploaded(dataFile, checksumMapNew, fileAlreadyExists);\n \n-    public void  setFileMetadataSelectedForTagsPopup(FileMetadata fm){\n-        fileMetadataSelectedForTagsPopup = fm;\n+  }\n+\n+\n+  public boolean isLocked() {\n+    if (dataset != null) {\n+      logger.log(Level.FINE, \"checking lock status of dataset {0}\", dataset.getId());\n+      if (dataset.isLocked()) {\n+        // refresh the dataset and version, if the current working\n+        // version of the dataset is locked:\n+      }\n+      Dataset lookedupDataset = datasetService.find(dataset.getId());\n+\n+      if ((lookedupDataset != null) && lookedupDataset.isLocked()) {\n+        logger.fine(\"locked!\");\n+        return true;\n+      }\n     }\n-    \n-    public FileMetadata getFileMetadataSelectedForTagsPopup() {\n-        return fileMetadataSelectedForTagsPopup;\n+    return false;\n+  }\n+\n+  private Boolean lockedFromEditsVar;\n+\n+  public boolean isLockedFromEdits() {\n+    if (null == lockedFromEditsVar) {\n+      try {\n+        permissionService.checkEditDatasetLock(dataset, dvRequestService.getDataverseRequest(),\n+          new UpdateDatasetVersionCommand(dataset, dvRequestService.getDataverseRequest()));\n+        lockedFromEditsVar = false;\n+      } catch (IllegalCommandException ex) {\n+        lockedFromEditsVar = true;\n+      }\n     }\n-    \n-    public void clearFileMetadataSelectedForTagsPopup() {\n-        fileMetadataSelectedForTagsPopup = null;\n+    return lockedFromEditsVar;\n+  }\n+\n+  // Methods for edit functions that are performed on one file at a time,\n+  // in popups that block the rest of the page:\n+\n+  private FileMetadata fileMetadataSelected = null;\n+\n+  public void setFileMetadataSelected(FileMetadata fm) {\n+    setFileMetadataSelected(fm, null);\n+  }\n+\n+  public void setFileMetadataSelected(FileMetadata fm, String guestbook) {\n+\n+    fileMetadataSelected = fm;\n+    logger.log(Level.FINE, \"set the file for the advanced options popup ({0})\", fileMetadataSelected.getLabel());\n+  }\n+\n+  public FileMetadata getFileMetadataSelected() {\n+    if (fileMetadataSelected != null) {\n+      logger.log(Level.FINE, \"returning file metadata for the advanced options popup ({0})\",\n+        fileMetadataSelected.getLabel());\n+    } else {\n+      logger.fine(\"file metadata for the advanced options popup is null.\");\n     }\n-    \n-    /*\n-     * 1. Tabular File Tags: \n+    return fileMetadataSelected;\n+  }\n+\n+  public void clearFileMetadataSelected() {\n+    fileMetadataSelected = null;\n+  }\n+\n+  public boolean isDesignatedDatasetThumbnail(FileMetadata fileMetadata) {\n+    if (fileMetadata != null) {\n+      if (fileMetadata.getDataFile() != null) {\n+        if (fileMetadata.getDataFile().getId() != null) {\n+          //if (fileMetadata.getDataFile().getOwner() != null) {\n+          if (fileMetadata.getDataFile().equals(dataset.getThumbnailFile())) {\n+            return true;\n+          }\n+          //}\n+        }\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /*\n+   * Items for the \"Designated this image as the Dataset thumbnail:\n+   */\n+\n+  private FileMetadata fileMetadataSelectedForThumbnailPopup = null;\n+\n+  /**\n+   * @param fm\n+   * @todo For consistency, we should disallow users from setting the\n+   * thumbnail to a restricted file. We enforce this rule in the newer\n+   * workflow in dataset-widgets.xhtml. The logic to show the \"Set Thumbnail\"\n+   * button is in editFilesFragment.xhtml and it would be nice to move it to\n+   * Java since it's getting long and a bit complicated.\n+   */\n+  public void setFileMetadataSelectedForThumbnailPopup(FileMetadata fm) {\n+    fileMetadataSelectedForThumbnailPopup = fm;\n+    alreadyDesignatedAsDatasetThumbnail = getUseAsDatasetThumbnail();\n+\n+  }\n+\n+  public FileMetadata getFileMetadataSelectedForThumbnailPopup() {\n+    return fileMetadataSelectedForThumbnailPopup;\n+  }\n+\n+  public void clearFileMetadataSelectedForThumbnailPopup() {\n+    fileMetadataSelectedForThumbnailPopup = null;\n+  }\n+\n+  private boolean alreadyDesignatedAsDatasetThumbnail = false;\n+\n+  public boolean getUseAsDatasetThumbnail() {\n+\n+    return isDesignatedDatasetThumbnail(fileMetadataSelectedForThumbnailPopup);\n+  }\n+\n+  public void setUseAsDatasetThumbnail(boolean useAsThumbnail) {\n+    if (fileMetadataSelectedForThumbnailPopup != null) {\n+      if (fileMetadataSelectedForThumbnailPopup.getDataFile() != null) {\n+        if (useAsThumbnail) {\n+          dataset.setThumbnailFile(fileMetadataSelectedForThumbnailPopup.getDataFile());\n+        } else if (getUseAsDatasetThumbnail()) {\n+          dataset.setThumbnailFile(null);\n+        }\n+      }\n+    }\n+  }\n+\n+  public void saveAsDesignatedThumbnail() {\n+    logger.fine(\"saving as the designated thumbnail\");\n+    // We don't need to do anything specific to save this setting, because\n+    // the setUseAsDatasetThumbnail() method, above, has already updated the\n+    // file object appropriately.\n+    // However, once the \"save\" button is pressed, we want to show a success message, if this is\n+    // a new image has been designated as such:\n+    if (getUseAsDatasetThumbnail() && !alreadyDesignatedAsDatasetThumbnail) {\n+      String successMessage = getBundleString(\"file.assignedDataverseImage.success\");\n+      logger.fine(successMessage);\n+      successMessage = successMessage.replace(\"{0}\", fileMetadataSelectedForThumbnailPopup.getLabel());\n+      JsfHelper.addFlashMessage(successMessage);\n+    }\n+\n+    // And reset the selected fileMetadata:\n+    fileMetadataSelectedForThumbnailPopup = null;\n+  }\n+\n+  public void deleteDatasetLogoAndUseThisDataFileAsThumbnailInstead() {\n+    logger.log(Level.FINE,\n+      \"For dataset id {0} the current thumbnail is from a dataset logo rather than a dataset file, blowing away the logo and using this FileMetadata id instead: {1}\",\n+      new Object[] {dataset.getId(), fileMetadataSelectedForThumbnailPopup});\n+    /**\n+     * @todo Rather than deleting and merging right away, try to respect how\n+     * this page seems to stage actions and giving the user a chance to\n+     * review before clicking \"Save Changes\".\n      */\n-    \n-    private List<String> tabFileTags = null;\n+    try {\n+      DatasetThumbnail datasetThumbnail = commandEngine.submit(\n+        new UpdateDatasetThumbnailCommand(dvRequestService.getDataverseRequest(), dataset,\n+          UpdateDatasetThumbnailCommand.UserIntent.setDatasetFileAsThumbnail,\n+          fileMetadataSelectedForThumbnailPopup.getDataFile().getId(), null));\n+      // look up the dataset again because the UpdateDatasetThumbnailCommand mutates (merges) the dataset\n+      dataset = datasetService.find(dataset.getId());\n+    } catch (CommandException ex) {\n+      String error = \"Problem setting thumbnail for dataset id \" + dataset.getId() + \".: \" + ex;\n+      // show this error to the user?\n+      logger.info(error);\n+    }\n+  }\n+\n+  public boolean isThumbnailIsFromDatasetLogoRatherThanDatafile() {\n+    DatasetThumbnail datasetThumbnail = dataset.getDatasetThumbnail(ImageThumbConverter.DEFAULT_CARDIMAGE_SIZE);\n+    return datasetThumbnail != null && !datasetThumbnail.isFromDataFile();\n+  }\n \n-    public List<String> getTabFileTags() {\n-        if (tabFileTags == null) {\n-            tabFileTags = DataFileTag.listTags();\n-        }\n-        return tabFileTags;\n-    }\n+  /*\n+   * Items for the \"Tags (Categories)\" popup.\n+   *\n+   */\n+  private FileMetadata fileMetadataSelectedForTagsPopup = null;\n+\n+  public void setFileMetadataSelectedForTagsPopup(FileMetadata fm) {\n+    fileMetadataSelectedForTagsPopup = fm;\n+  }\n+\n+  public FileMetadata getFileMetadataSelectedForTagsPopup() {\n+    return fileMetadataSelectedForTagsPopup;\n+  }\n+\n+  public void clearFileMetadataSelectedForTagsPopup() {\n+    fileMetadataSelectedForTagsPopup = null;\n+  }\n \n-    public void setTabFileTags(List<String> tabFileTags) {\n-        this.tabFileTags = tabFileTags;\n-    }\n-    \n-    private String[] selectedTabFileTags = {};\n+  /*\n+   * 1. Tabular File Tags:\n+   */\n+\n+  private List<String> tabFileTags = null;\n \n-    public String[] getSelectedTabFileTags() {\n-        return selectedTabFileTags;\n+  public List<String> getTabFileTags() {\n+    if (tabFileTags == null) {\n+      tabFileTags = DataFileTag.listTags();\n     }\n+    return tabFileTags;\n+  }\n \n-    public void setSelectedTabFileTags(String[] selectedTabFileTags) {\n-        this.selectedTabFileTags = selectedTabFileTags;\n-    }\n+  public void setTabFileTags(List<String> tabFileTags) {\n+    this.tabFileTags = tabFileTags;\n+  }\n \n-    private String[] selectedTags = {};\n-    \n-    public void refreshTagsPopUp(FileMetadata fm){\n-        setFileMetadataSelectedForTagsPopup(fm);\n-        refreshCategoriesByName();\n-        refreshTabFileTagsByName();\n-    }\n-    \n-    private List<String> tabFileTagsByName;\n+  private String[] selectedTabFileTags = {};\n \n-    public List<String> getTabFileTagsByName() {\n-        return tabFileTagsByName;\n-    }\n+  public String[] getSelectedTabFileTags() {\n+    return selectedTabFileTags;\n+  }\n \n-    public void setTabFileTagsByName(List<String> tabFileTagsByName) {\n-        this.tabFileTagsByName = tabFileTagsByName;\n-    }\n-    \n-    private void refreshTabFileTagsByName() {\n-        tabFileTagsByName = new ArrayList<>();\n-        if (fileMetadataSelectedForTagsPopup.getDataFile().getTags() != null) {\n-            for (int i = 0; i < fileMetadataSelectedForTagsPopup.getDataFile().getTags().size(); i++) {\n-                tabFileTagsByName.add(fileMetadataSelectedForTagsPopup.getDataFile().getTags().get(i).getTypeLabel());\n-            }\n-        }\n-        refreshSelectedTabFileTags();\n-    }\n+  public void setSelectedTabFileTags(String[] selectedTabFileTags) {\n+    this.selectedTabFileTags = selectedTabFileTags;\n+  }\n \n-    private void refreshSelectedTabFileTags() {\n-        selectedTabFileTags = null;\n-        selectedTabFileTags = new String[0];\n-        if (tabFileTagsByName.size() > 0) {\n-            selectedTabFileTags = new String[tabFileTagsByName.size()];\n-            for (int i = 0; i < tabFileTagsByName.size(); i++) {\n-                selectedTabFileTags[i] = tabFileTagsByName.get(i);\n-            }\n-        }\n-        Arrays.sort(selectedTabFileTags);\n-    }\n-    \n-    private void refreshCategoriesByName(){\n-        categoriesByName= new ArrayList<>();\n-        for (String category: dataset.getCategoriesByName() ){\n-            categoriesByName.add(category);\n-        }\n-        refreshSelectedTags();\n+  private String[] selectedTags = {};\n+\n+  public void refreshTagsPopUp(FileMetadata fm) {\n+    setFileMetadataSelectedForTagsPopup(fm);\n+    refreshCategoriesByName();\n+    refreshTabFileTagsByName();\n+  }\n+\n+  private List<String> tabFileTagsByName;\n+\n+  public List<String> getTabFileTagsByName() {\n+    return tabFileTagsByName;\n+  }\n+\n+  public void setTabFileTagsByName(List<String> tabFileTagsByName) {\n+    this.tabFileTagsByName = tabFileTagsByName;\n+  }\n+\n+  private void refreshTabFileTagsByName() {\n+    tabFileTagsByName = new ArrayList<>();\n+    if (fileMetadataSelectedForTagsPopup.getDataFile().getTags() != null) {\n+      for (int i = 0; i < fileMetadataSelectedForTagsPopup.getDataFile().getTags().size(); i++) {\n+        tabFileTagsByName.add(fileMetadataSelectedForTagsPopup.getDataFile().getTags().get(i).getTypeLabel());\n+      }\n     }\n-    \n-    \n-    private List<String> categoriesByName;\n+    refreshSelectedTabFileTags();\n+  }\n \n-    public List<String> getCategoriesByName() {\n-        return categoriesByName;\n+  private void refreshSelectedTabFileTags() {\n+    selectedTabFileTags = null;\n+    selectedTabFileTags = new String[0];\n+    if (tabFileTagsByName.size() > 0) {\n+      selectedTabFileTags = new String[tabFileTagsByName.size()];\n+      for (int i = 0; i < tabFileTagsByName.size(); i++) {\n+        selectedTabFileTags[i] = tabFileTagsByName.get(i);\n+      }\n     }\n+    Arrays.sort(selectedTabFileTags);\n+  }\n \n-    public void setCategoriesByName(List<String> categoriesByName) {\n-        this.categoriesByName = categoriesByName;\n+  private void refreshCategoriesByName() {\n+    categoriesByName = new ArrayList<>();\n+    for (String category : dataset.getCategoriesByName()) {\n+      categoriesByName.add(category);\n     }\n-    \n-    private void refreshSelectedTags() {\n-        selectedTags = null;\n-        selectedTags = new String[0];\n-        List<String> selectedCategoriesByName = new ArrayList<>();\n-\n-        if (fileMetadataSelectedForTagsPopup.getCategories() != null) {\n-            for (int i = 0; i < fileMetadataSelectedForTagsPopup.getCategories().size(); i++) {\n-                if (!selectedCategoriesByName.contains(fileMetadataSelectedForTagsPopup.getCategories().get(i).getName())) {\n-                    selectedCategoriesByName.add(fileMetadataSelectedForTagsPopup.getCategories().get(i).getName());\n-                }\n-            }\n-        }\n+    refreshSelectedTags();\n+  }\n \n-        if (selectedCategoriesByName.size() > 0) {\n-            selectedTags = new String[selectedCategoriesByName.size()];\n-            for (int i = 0; i < selectedCategoriesByName.size(); i++) {\n-                selectedTags[i] = selectedCategoriesByName.get(i);\n-            }\n+\n+  private List<String> categoriesByName;\n+\n+  public List<String> getCategoriesByName() {\n+    return categoriesByName;\n+  }\n+\n+  public void setCategoriesByName(List<String> categoriesByName) {\n+    this.categoriesByName = categoriesByName;\n+  }\n+\n+  private void refreshSelectedTags() {\n+    selectedTags = null;\n+    selectedTags = new String[0];\n+    List<String> selectedCategoriesByName = new ArrayList<>();\n+\n+    if (fileMetadataSelectedForTagsPopup.getCategories() != null) {\n+      for (int i = 0; i < fileMetadataSelectedForTagsPopup.getCategories().size(); i++) {\n+        if (!selectedCategoriesByName.contains(fileMetadataSelectedForTagsPopup.getCategories().get(i).getName())) {\n+          selectedCategoriesByName.add(fileMetadataSelectedForTagsPopup.getCategories().get(i).getName());\n         }\n-        Arrays.sort(selectedTags);\n+      }\n     }\n \n-    public String[] getSelectedTags() {\n-        return selectedTags;\n+    if (selectedCategoriesByName.size() > 0) {\n+      selectedTags = new String[selectedCategoriesByName.size()];\n+      for (int i = 0; i < selectedCategoriesByName.size(); i++) {\n+        selectedTags[i] = selectedCategoriesByName.get(i);\n+      }\n     }\n+    Arrays.sort(selectedTags);\n+  }\n \n-    public void setSelectedTags(String[] selectedTags) {\n-        this.selectedTags = selectedTags;\n-    }\n-    \n+  public String[] getSelectedTags() {\n+    return selectedTags;\n+  }\n \n+  public void setSelectedTags(String[] selectedTags) {\n+    this.selectedTags = selectedTags;\n+  }\n \n-    /*\n-     * \"File Tags\" (aka \"File Categories\"): \n-    */\n-    \n-    private String newCategoryName = null;\n \n-    public String getNewCategoryName() {\n-        return newCategoryName;\n+\n+  /*\n+   * \"File Tags\" (aka \"File Categories\"):\n+   */\n+\n+  private String newCategoryName = null;\n+\n+  public String getNewCategoryName() {\n+    return newCategoryName;\n+  }\n+\n+  public void setNewCategoryName(String newCategoryName) {\n+    this.newCategoryName = newCategoryName;\n+  }\n+\n+  public String saveNewCategory() {\n+\n+    if (newCategoryName != null && !newCategoryName.isEmpty()) {\n+      categoriesByName.add(newCategoryName);\n     }\n+    //Now increase size of selectedTags and add new category\n+    String[] temp = new String[selectedTags.length + 1];\n+    System.arraycopy(selectedTags, 0, temp, 0, selectedTags.length);\n+    selectedTags = temp;\n+    selectedTags[selectedTags.length - 1] = newCategoryName;\n+    //Blank out added category\n+    newCategoryName = \"\";\n+    return \"\";\n+  }\n \n-    public void setNewCategoryName(String newCategoryName) {\n-        this.newCategoryName = newCategoryName;\n+  /* This method handles saving both \"tabular file tags\" and\n+   * \"file categories\" (which are also considered \"tags\" in 4.0)\n+   */\n+  public void saveFileTagsAndCategories() {\n+    if (fileMetadataSelectedForTagsPopup == null) {\n+      logger.fine(\"No FileMetadata selected for the categories popup\");\n+      return;\n     }\n-       \n-    public String saveNewCategory() {\n-       \n-        if (newCategoryName != null && !newCategoryName.isEmpty()) {\n-            categoriesByName.add(newCategoryName);\n-        }\n-        //Now increase size of selectedTags and add new category\n-        String[] temp = new String[selectedTags.length + 1];\n-        System.arraycopy(selectedTags, 0, temp, 0, selectedTags.length);\n-        selectedTags = temp;\n-        selectedTags[selectedTags.length - 1] = newCategoryName;\n-        //Blank out added category\n-        newCategoryName = \"\";\n-        return \"\";\n-    }\n-\n-    /* This method handles saving both \"tabular file tags\" and \n-     * \"file categories\" (which are also considered \"tags\" in 4.0)\n-    */\n-    public void saveFileTagsAndCategories() {\n-        if (fileMetadataSelectedForTagsPopup == null) {\n-            logger.fine(\"No FileMetadata selected for the categories popup\");\n-            return; \n-        }\n-        // 1. File categories:\n+    // 1. File categories:\n         /*\n         In order to get the cancel button to work we had to separate the selected tags \n         from the file metadata and re-add them on save\n         \n         */\n-        \n-        fileMetadataSelectedForTagsPopup.setCategories(new ArrayList<>());\n-        \n-        // New, custom file category (if specified):\n-        if (newCategoryName != null) {\n-            logger.fine(\"Adding new category, \" + newCategoryName + \" for file \" + fileMetadataSelectedForTagsPopup.getLabel());\n-            fileMetadataSelectedForTagsPopup.addCategoryByName(newCategoryName);\n-        } else {\n-            logger.fine(\"no category specified\");\n-        }\n-        newCategoryName = null;\n-        \n-        // File Categories selected from the list of existing categories: \n-        if (selectedTags != null) {\n-            for (String selectedTag : selectedTags) {\n-                \n-                fileMetadataSelectedForTagsPopup.addCategoryByName(selectedTag);\n-            }\n-        }        \n-                \n-        // 2. Tabular DataFile Tags: \n-        \n-        if (fileMetadataSelectedForTagsPopup.getDataFile() != null && tabularDataTagsUpdated && selectedTabFileTags != null) {\n-            fileMetadataSelectedForTagsPopup.getDataFile().setTags(null);\n-            for (String selectedTabFileTag : selectedTabFileTags) {\n-                DataFileTag tag = new DataFileTag();\n-                try {\n-                    tag.setTypeByLabel(selectedTabFileTag);\n-                    tag.setDataFile(fileMetadataSelectedForTagsPopup.getDataFile());\n-                    fileMetadataSelectedForTagsPopup.getDataFile().addTag(tag);\n-\n-                } catch (IllegalArgumentException iax) {\n-                    // ignore \n-                }\n-            }\n-        }\n-        \n-        fileMetadataSelectedForTagsPopup = null;\n \n-    }\n-    \n-    public void handleFileCategoriesSelection(final AjaxBehaviorEvent event) {\n-        if (selectedTags != null) {\n-            selectedTags = selectedTags.clone();\n-        }\n-    }\n-    \n-    public void handleTabularTagsSelection(final AjaxBehaviorEvent event) {\n-        tabularDataTagsUpdated = true;\n-    }\n-        \n-    /* \n-     * Items for the \"Advanced (Ingest) Options\" popup. \n-     * \n-     */\n-    private FileMetadata fileMetadataSelectedForIngestOptionsPopup = null; \n+    fileMetadataSelectedForTagsPopup.setCategories(new ArrayList<>());\n \n-    public void  setFileMetadataSelectedForIngestOptionsPopup(FileMetadata fm){\n-       fileMetadataSelectedForIngestOptionsPopup = fm; \n-    }\n-    \n-    public FileMetadata getFileMetadataSelectedForIngestOptionsPopup() {\n-        return fileMetadataSelectedForIngestOptionsPopup;\n+    // New, custom file category (if specified):\n+    if (newCategoryName != null) {\n+      logger\n+        .fine(\"Adding new category, \" + newCategoryName + \" for file \" + fileMetadataSelectedForTagsPopup.getLabel());\n+      fileMetadataSelectedForTagsPopup.addCategoryByName(newCategoryName);\n+    } else {\n+      logger.fine(\"no category specified\");\n     }\n-    \n-    public void clearFileMetadataSelectedForIngestOptionsPopup() {\n-        fileMetadataSelectedForIngestOptionsPopup = null;\n+    newCategoryName = null;\n+\n+    // File Categories selected from the list of existing categories:\n+    if (selectedTags != null) {\n+      for (String selectedTag : selectedTags) {\n+\n+        fileMetadataSelectedForTagsPopup.addCategoryByName(selectedTag);\n+      }\n     }\n-    \n-    private String ingestLanguageEncoding = null;\n \n-    public String getIngestLanguageEncoding() {\n-        if (ingestLanguageEncoding == null) {\n-            return BundleUtil.getStringFromBundle(\"editdatafilepage.defaultLanguageEncoding\");\n+    // 2. Tabular DataFile Tags:\n+\n+    if (fileMetadataSelectedForTagsPopup.getDataFile() != null && tabularDataTagsUpdated &&\n+      selectedTabFileTags != null) {\n+      fileMetadataSelectedForTagsPopup.getDataFile().setTags(null);\n+      for (String selectedTabFileTag : selectedTabFileTags) {\n+        DataFileTag tag = new DataFileTag();\n+        try {\n+          tag.setTypeByLabel(selectedTabFileTag);\n+          tag.setDataFile(fileMetadataSelectedForTagsPopup.getDataFile());\n+          fileMetadataSelectedForTagsPopup.getDataFile().addTag(tag);\n+\n+        } catch (IllegalArgumentException iax) {\n+          // ignore\n         }\n-        return ingestLanguageEncoding;\n+      }\n     }\n \n-    public void setIngestLanguageEncoding(String ingestLanguageEncoding) {\n-        this.ingestLanguageEncoding = ingestLanguageEncoding;\n-    }\n+    fileMetadataSelectedForTagsPopup = null;\n \n-    public void setIngestEncoding(String ingestEncoding) {\n-        ingestLanguageEncoding = ingestEncoding;\n+  }\n+\n+  public void handleFileCategoriesSelection(final AjaxBehaviorEvent event) {\n+    if (selectedTags != null) {\n+      selectedTags = selectedTags.clone();\n     }\n+  }\n \n-    private String savedLabelsTempFile = null;\n+  public void handleTabularTagsSelection(final AjaxBehaviorEvent event) {\n+    tabularDataTagsUpdated = true;\n+  }\n \n-    public void handleLabelsFileUpload(FileUploadEvent event) {\n-        logger.fine(\"entering handleUpload method.\");\n-        UploadedFile file = event.getFile();\n+  /*\n+   * Items for the \"Advanced (Ingest) Options\" popup.\n+   *\n+   */\n+  private FileMetadata fileMetadataSelectedForIngestOptionsPopup = null;\n \n-        if (file != null) {\n+  public void setFileMetadataSelectedForIngestOptionsPopup(FileMetadata fm) {\n+    fileMetadataSelectedForIngestOptionsPopup = fm;\n+  }\n \n-            InputStream uploadStream = null;\n-            try {\n-                uploadStream = file.getInputStream();\n-            } catch (IOException ioex) {\n-                logger.info(\"the file \" + file.getFileName() + \" failed to upload!\");\n-                List<String> args = Arrays.asList(file.getFileName());\n-                String msg = BundleUtil.getStringFromBundle(\"dataset.file.uploadFailure.detailmsg\", args);\n-                FacesMessage message = new FacesMessage(FacesMessage.SEVERITY_WARN, BundleUtil.getStringFromBundle(\"dataset.file.uploadFailure\"), msg);\n-                FacesContext.getCurrentInstance().addMessage(null, message);\n-                return;\n-            }\n+  public FileMetadata getFileMetadataSelectedForIngestOptionsPopup() {\n+    return fileMetadataSelectedForIngestOptionsPopup;\n+  }\n \n-            savedLabelsTempFile = saveTempFile(uploadStream);\n+  public void clearFileMetadataSelectedForIngestOptionsPopup() {\n+    fileMetadataSelectedForIngestOptionsPopup = null;\n+  }\n \n-            logger.fine(file.getFileName() + \" is successfully uploaded.\");\n-            List<String> args = Arrays.asList(file.getFileName());\n-            FacesMessage message = new FacesMessage(BundleUtil.getStringFromBundle(\"dataset.file.upload\", args));\n-            FacesContext.getCurrentInstance().addMessage(null, message);\n-        }\n+  private String ingestLanguageEncoding = null;\n+\n+  public String getIngestLanguageEncoding() {\n+    if (ingestLanguageEncoding == null) {\n+      return BundleUtil.getStringFromBundle(\"editdatafilepage.defaultLanguageEncoding\");\n+    }\n+    return ingestLanguageEncoding;\n+  }\n+\n+  public void setIngestLanguageEncoding(String ingestLanguageEncoding) {\n+    this.ingestLanguageEncoding = ingestLanguageEncoding;\n+  }\n \n-        // process file (i.e., just save it in a temp location; for now):\n-    }\n+  public void setIngestEncoding(String ingestEncoding) {\n+    ingestLanguageEncoding = ingestEncoding;\n+  }\n \n-    private String saveTempFile(InputStream input) {\n-        if (input == null) {\n-            return null;\n-        }\n-        byte[] buffer = new byte[8192];\n-        int bytesRead = 0;\n-        File labelsFile = null;\n-        FileOutputStream output = null;\n-        try {\n-            labelsFile = File.createTempFile(\"tempIngestLabels.\", \".txt\");\n-            output = new FileOutputStream(labelsFile);\n-            while ((bytesRead = input.read(buffer)) > -1) {\n-                output.write(buffer, 0, bytesRead);\n-            }\n-        } catch (IOException ioex) {\n-            return null;\n-        } finally {\n-            IOUtils.closeQuietly(input);\n-            IOUtils.closeQuietly(output);\n-        }\n-        if (labelsFile != null) {\n-            return labelsFile.getAbsolutePath();\n-        }\n-        return null;\n-    }\n+  private String savedLabelsTempFile = null;\n+\n+  public void handleLabelsFileUpload(FileUploadEvent event) {\n+    logger.fine(\"entering handleUpload method.\");\n+    UploadedFile file = event.getFile();\n \n-    public void saveAdvancedOptions() {\n+    if (file != null) {\n \n-        // Language encoding for SPSS SAV (and, possibly, other tabular ingests:) \n-        if (ingestLanguageEncoding != null) {\n-            if (fileMetadataSelectedForIngestOptionsPopup != null && fileMetadataSelectedForIngestOptionsPopup.getDataFile() != null) {\n-                if (fileMetadataSelectedForIngestOptionsPopup.getDataFile().getIngestRequest() == null) {\n-                    IngestRequest ingestRequest = new IngestRequest();\n-                    ingestRequest.setDataFile(fileMetadataSelectedForIngestOptionsPopup.getDataFile());\n-                    fileMetadataSelectedForIngestOptionsPopup.getDataFile().setIngestRequest(ingestRequest);\n+      InputStream uploadStream = null;\n+      try {\n+        uploadStream = file.getInputStream();\n+      } catch (IOException ioex) {\n+        logger.info(\"the file \" + file.getFileName() + \" failed to upload!\");\n+        List<String> args = Arrays.asList(file.getFileName());\n+        String msg = BundleUtil.getStringFromBundle(\"dataset.file.uploadFailure.detailmsg\", args);\n+        FacesMessage message =\n+          new FacesMessage(FacesMessage.SEVERITY_WARN, BundleUtil.getStringFromBundle(\"dataset.file.uploadFailure\"),\n+            msg);\n+        FacesContext.getCurrentInstance().addMessage(null, message);\n+        return;\n+      }\n \n-                }\n-                fileMetadataSelectedForIngestOptionsPopup.getDataFile().getIngestRequest().setTextEncoding(ingestLanguageEncoding);\n-            }\n-        }\n-        ingestLanguageEncoding = null;\n-\n-        // Extra labels for SPSS POR (and, possibly, other tabular ingests:)\n-        // (we are adding this parameter to the IngestRequest now, instead of back\n-        // when it was uploaded. This is because we want the user to be able to \n-        // hit cancel and bail out, until they actually click 'save' in the \n-        // \"advanced options\" popup) -- L.A. 4.0 beta 11\n-        if (savedLabelsTempFile != null) {\n-            if (fileMetadataSelectedForIngestOptionsPopup != null && fileMetadataSelectedForIngestOptionsPopup.getDataFile() != null) {\n-                if (fileMetadataSelectedForIngestOptionsPopup.getDataFile().getIngestRequest() == null) {\n-                    IngestRequest ingestRequest = new IngestRequest();\n-                    ingestRequest.setDataFile(fileMetadataSelectedForIngestOptionsPopup.getDataFile());\n-                    fileMetadataSelectedForIngestOptionsPopup.getDataFile().setIngestRequest(ingestRequest);\n-                }\n-                fileMetadataSelectedForIngestOptionsPopup.getDataFile().getIngestRequest().setLabelsFile(savedLabelsTempFile);\n-            }\n-        }\n-        savedLabelsTempFile = null;\n+      savedLabelsTempFile = saveTempFile(uploadStream);\n \n-        fileMetadataSelectedForIngestOptionsPopup = null;\n+      logger.fine(file.getFileName() + \" is successfully uploaded.\");\n+      List<String> args = Arrays.asList(file.getFileName());\n+      FacesMessage message = new FacesMessage(BundleUtil.getStringFromBundle(\"dataset.file.upload\", args));\n+      FacesContext.getCurrentInstance().addMessage(null, message);\n     }\n \n-    public boolean rsyncUploadSupported() {\n-    \t// ToDo - rsync was written before multiple store support and currently is hardcoded to use the \"s3\" store. \n-    \t// When those restrictions are lifted/rsync can be configured per store, the test in the \n-        // Dataset Util method should be updated\n+    // process file (i.e., just save it in a temp location; for now):\n+  }\n \n-    \treturn settingsWrapper.isRsyncUpload() && DatasetUtil.isAppropriateStorageDriver(dataset);\n+  private String saveTempFile(InputStream input) {\n+    if (input == null) {\n+      return null;\n     }\n-    \n-    \n-    private void populateFileMetadatas() {\n-        fileMetadatas = new ArrayList<>();\n-        if (selectedFileIdsList == null || selectedFileIdsList.isEmpty()) {\n-            return;\n-        }\n+    byte[] buffer = new byte[8192];\n+    int bytesRead = 0;\n+    File labelsFile = null;\n+    FileOutputStream output = null;\n+    try {\n+      labelsFile = File.createTempFile(\"tempIngestLabels.\", \".txt\");\n+      output = new FileOutputStream(labelsFile);\n+      while ((bytesRead = input.read(buffer)) > -1) {\n+        output.write(buffer, 0, bytesRead);\n+      }\n+    } catch (IOException ioex) {\n+      return null;\n+    } finally {\n+      IOUtils.closeQuietly(input);\n+      IOUtils.closeQuietly(output);\n+    }\n+    if (labelsFile != null) {\n+      return labelsFile.getAbsolutePath();\n+    }\n+    return null;\n+  }\n \n-        for (FileMetadata fmd : workingVersion.getFileMetadatas()) {\n-            for (Long id : selectedFileIdsList) {\n-                if (id.intValue() == fmd.getDataFile().getId().intValue()) {\n-                    fileMetadatas.add(fmd);\n-                }\n-            }\n-        }       \n-    }    \n-    \n-    private String termsOfAccess;\n-    private boolean fileAccessRequest;\n+  public void saveAdvancedOptions() {\n+\n+    // Language encoding for SPSS SAV (and, possibly, other tabular ingests:)\n+    if (ingestLanguageEncoding != null) {\n+      if (fileMetadataSelectedForIngestOptionsPopup != null &&\n+        fileMetadataSelectedForIngestOptionsPopup.getDataFile() != null) {\n+        if (fileMetadataSelectedForIngestOptionsPopup.getDataFile().getIngestRequest() == null) {\n+          IngestRequest ingestRequest = new IngestRequest();\n+          ingestRequest.setDataFile(fileMetadataSelectedForIngestOptionsPopup.getDataFile());\n+          fileMetadataSelectedForIngestOptionsPopup.getDataFile().setIngestRequest(ingestRequest);\n \n-    public String getTermsOfAccess() {\n-        return termsOfAccess;\n+        }\n+        fileMetadataSelectedForIngestOptionsPopup.getDataFile().getIngestRequest()\n+          .setTextEncoding(ingestLanguageEncoding);\n+      }\n     }\n-\n-    public void setTermsOfAccess(String termsOfAccess) {\n-        this.termsOfAccess = termsOfAccess;\n+    ingestLanguageEncoding = null;\n+\n+    // Extra labels for SPSS POR (and, possibly, other tabular ingests:)\n+    // (we are adding this parameter to the IngestRequest now, instead of back\n+    // when it was uploaded. This is because we want the user to be able to\n+    // hit cancel and bail out, until they actually click 'save' in the\n+    // \"advanced options\" popup) -- L.A. 4.0 beta 11\n+    if (savedLabelsTempFile != null) {\n+      if (fileMetadataSelectedForIngestOptionsPopup != null &&\n+        fileMetadataSelectedForIngestOptionsPopup.getDataFile() != null) {\n+        if (fileMetadataSelectedForIngestOptionsPopup.getDataFile().getIngestRequest() == null) {\n+          IngestRequest ingestRequest = new IngestRequest();\n+          ingestRequest.setDataFile(fileMetadataSelectedForIngestOptionsPopup.getDataFile());\n+          fileMetadataSelectedForIngestOptionsPopup.getDataFile().setIngestRequest(ingestRequest);\n+        }\n+        fileMetadataSelectedForIngestOptionsPopup.getDataFile().getIngestRequest().setLabelsFile(savedLabelsTempFile);\n+      }\n+    }\n+    savedLabelsTempFile = null;\n+\n+    fileMetadataSelectedForIngestOptionsPopup = null;\n+  }\n+\n+  public boolean rsyncUploadSupported() {\n+    // ToDo - rsync was written before multiple store support and currently is hardcoded to use the \"s3\" store.\n+    // When those restrictions are lifted/rsync can be configured per store, the test in the\n+    // Dataset Util method should be updated\n+\n+    return settingsWrapper.isRsyncUpload() && DatasetUtil.isAppropriateStorageDriver(dataset);\n+  }\n+\n+\n+  private void populateFileMetadatas() {\n+    fileMetadatas = new ArrayList<>();\n+    if (selectedFileIdsList == null || selectedFileIdsList.isEmpty()) {\n+      return;\n+    }\n+\n+    for (FileMetadata fmd : workingVersion.getFileMetadatas()) {\n+      for (Long id : selectedFileIdsList) {\n+        if (id.intValue() == fmd.getDataFile().getId().intValue()) {\n+          fileMetadatas.add(fmd);\n+        }\n+      }\n     }\n+  }\n \n-    public boolean isFileAccessRequest() {\n-        return fileAccessRequest;\n-    }\n+  private String termsOfAccess;\n+  private boolean fileAccessRequest;\n+\n+  public String getTermsOfAccess() {\n+    return termsOfAccess;\n+  }\n \n-    public void setFileAccessRequest(boolean fileAccessRequest) {\n-        this.fileAccessRequest = fileAccessRequest;\n-    }\n+  public void setTermsOfAccess(String termsOfAccess) {\n+    this.termsOfAccess = termsOfAccess;\n+  }\n+\n+  public boolean isFileAccessRequest() {\n+    return fileAccessRequest;\n+  }\n+\n+  public void setFileAccessRequest(boolean fileAccessRequest) {\n+    this.fileAccessRequest = fileAccessRequest;\n+  }\n }\n",
            "diff_size": 3981
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "1602",
                    "column": "9",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/17/EditDatafilesPage.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_random/17/EditDatafilesPage.java\nindex 7d190618330..33b2c567a2c 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/17/EditDatafilesPage.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_random/17/EditDatafilesPage.java\n@@ -1594,7 +1594,7 @@ public class EditDatafilesPage implements java.io.Serializable {\n         \n         S3AccessIO<?> s3io = FileUtil.getS3AccessForDirectUpload(dataset);\n         if(s3io == null) {\n-        \tFacesContext.getCurrentInstance().addMessage(uploadComponentId, new FacesMessage(FacesMessage.SEVERITY_ERROR, BundleUtil.getStringFromBundle(\"dataset.file.uploadWarning\"), \"Direct upload not supported for this dataset\"));\n+    FacesContext.getCurrentInstance().addMessage(uploadComponentId, new FacesMessage(FacesMessage.SEVERITY_ERROR, BundleUtil.getStringFromBundle(\"dataset.file.uploadWarning\"), \"Direct upload not supported for this dataset\"));\n         }\n         String url = null;\n         String storageIdentifier = null;\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "1602",
                    "column": "9",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/17/EditDatafilesPage.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_three_grams/17/EditDatafilesPage.java\nindex 7d190618330..ddc0bb728b6 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/17/EditDatafilesPage.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_three_grams/17/EditDatafilesPage.java\n@@ -1594,7 +1594,7 @@ public class EditDatafilesPage implements java.io.Serializable {\n         \n         S3AccessIO<?> s3io = FileUtil.getS3AccessForDirectUpload(dataset);\n         if(s3io == null) {\n-        \tFacesContext.getCurrentInstance().addMessage(uploadComponentId, new FacesMessage(FacesMessage.SEVERITY_ERROR, BundleUtil.getStringFromBundle(\"dataset.file.uploadWarning\"), \"Direct upload not supported for this dataset\"));\n+        FacesContext.getCurrentInstance().addMessage(uploadComponentId, new FacesMessage(FacesMessage.SEVERITY_ERROR, BundleUtil.getStringFromBundle(\"dataset.file.uploadWarning\"), \"Direct upload not supported for this dataset\"));\n         }\n         String url = null;\n         String storageIdentifier = null;\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [],
    "not_repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}