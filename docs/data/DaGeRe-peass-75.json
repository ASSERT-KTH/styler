{
    "project_name": "DaGeRe-peass",
    "error_id": "75",
    "information": {
        "errors": [
            {
                "line": "35",
                "severity": "error",
                "message": "Line is longer than 200 characters (found 201).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": "   private final ModuleClassMapping mapping;\n\n   public TreeFilter(final String prefix, final IProjectContext projectContext, final TestCase test, final boolean ignoreEOIs, final MeasurementConfiguration config, final ModuleClassMapping mapping) {\n      super(new Configuration(), projectContext);\n      this.test = test;\n      this.measurementConfig = config;",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "35",
                    "severity": "error",
                    "message": "Line is longer than 200 characters (found 222).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/errored/1/75/TreeFilter.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/styler/75/TreeFilter.java\nindex ee01ae03b10..c16ed883f5e 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/errored/1/75/TreeFilter.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/styler/75/TreeFilter.java\n@@ -32,7 +32,7 @@ public class TreeFilter extends AbstractFilterPlugin {\n    private final boolean ignoreEOIs;\n    private final ModuleClassMapping mapping;\n \n-   public TreeFilter(final String prefix, final IProjectContext projectContext, final TestCase test, final boolean ignoreEOIs, final MeasurementConfiguration config, final ModuleClassMapping mapping) {\n+\t\t\tpublic TreeFilter(final String prefix, final IProjectContext projectContext, final TestCase test, final boolean ignoreEOIs, final MeasurementConfiguration config, final ModuleClassMapping mapping) {\n       super(new Configuration(), projectContext);\n       this.test = test;\n       this.measurementConfig = config;\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/errored/1/75/TreeFilter.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/intellij/75/TreeFilter.java\nindex ee01ae03b10..0ea9a263372 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/errored/1/75/TreeFilter.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/intellij/75/TreeFilter.java\n@@ -19,122 +19,122 @@ import kieker.tools.trace.analysis.systemModel.ExecutionTrace;\n @Plugin(description = \"A filter to transform generate PeASS-Call-trees\")\n public class TreeFilter extends AbstractFilterPlugin {\n \n-   private static final Logger LOG = LogManager.getLogger(TreeFilter.class);\n-\n-   public static final String INPUT_EXECUTION_TRACE = \"INPUT_EXECUTION_TRACE\";\n-\n-   private CallTreeNode root;\n-   \n-   private MeasurementConfiguration measurementConfig;\n-\n-   private final TestCase test;\n-\n-   private final boolean ignoreEOIs;\n-   private final ModuleClassMapping mapping;\n-\n-   public TreeFilter(final String prefix, final IProjectContext projectContext, final TestCase test, final boolean ignoreEOIs, final MeasurementConfiguration config, final ModuleClassMapping mapping) {\n-      super(new Configuration(), projectContext);\n-      this.test = test;\n-      this.measurementConfig = config;\n-      this.ignoreEOIs = ignoreEOIs;\n-      this.mapping = mapping;\n-   }\n-\n-   @Override\n-   public Configuration getCurrentConfiguration() {\n-      return super.configuration;\n-   }\n-\n-   public CallTreeNode getRoot() {\n-      return root;\n-   }\n-\n-   CallTreeNode lastParent = null, lastAdded = null;\n-   int lastStackSize = 1;\n-   long testTraceId = -1;\n-\n-   @InputPort(name = INPUT_EXECUTION_TRACE, eventTypes = { ExecutionTrace.class })\n-   public void handleInputs(final ExecutionTrace trace) {\n-      LOG.info(\"Trace: \" + trace.getTraceId());\n-\n-      for (final Execution execution : trace.getTraceAsSortedExecutionSet()) {\n-         final String fullClassname = execution.getOperation().getComponentType().getFullQualifiedName().intern();\n-         final String methodname = execution.getOperation().getSignature().getName().intern();\n-         final String call = fullClassname + \"#\" + methodname;\n-         final String kiekerPattern = KiekerPatternConverter.getKiekerPattern(execution.getOperation());\n-         LOG.trace(\"{} {}\", kiekerPattern, execution.getEss());\n-\n-         // ignore synthetic java methods\n-         if (!methodname.equals(\"class$\") && !methodname.startsWith(\"access$\")) {\n-            addExecutionToTree(execution, fullClassname, methodname, call, kiekerPattern);\n-         }\n+  private static final Logger LOG = LogManager.getLogger(TreeFilter.class);\n+\n+  public static final String INPUT_EXECUTION_TRACE = \"INPUT_EXECUTION_TRACE\";\n+\n+  private CallTreeNode root;\n+\n+  private MeasurementConfiguration measurementConfig;\n+\n+  private final TestCase test;\n+\n+  private final boolean ignoreEOIs;\n+  private final ModuleClassMapping mapping;\n+\n+  public TreeFilter(final String prefix, final IProjectContext projectContext, final TestCase test, final boolean ignoreEOIs, final MeasurementConfiguration config, final ModuleClassMapping mapping) {\n+    super(new Configuration(), projectContext);\n+    this.test = test;\n+    this.measurementConfig = config;\n+    this.ignoreEOIs = ignoreEOIs;\n+    this.mapping = mapping;\n+  }\n+\n+  @Override\n+  public Configuration getCurrentConfiguration() {\n+    return super.configuration;\n+  }\n+\n+  public CallTreeNode getRoot() {\n+    return root;\n+  }\n+\n+  CallTreeNode lastParent = null, lastAdded = null;\n+  int lastStackSize = 1;\n+  long testTraceId = -1;\n+\n+  @InputPort(name = INPUT_EXECUTION_TRACE, eventTypes = {ExecutionTrace.class})\n+  public void handleInputs(final ExecutionTrace trace) {\n+    LOG.info(\"Trace: \" + trace.getTraceId());\n+\n+    for (final Execution execution : trace.getTraceAsSortedExecutionSet()) {\n+      final String fullClassname = execution.getOperation().getComponentType().getFullQualifiedName().intern();\n+      final String methodname = execution.getOperation().getSignature().getName().intern();\n+      final String call = fullClassname + \"#\" + methodname;\n+      final String kiekerPattern = KiekerPatternConverter.getKiekerPattern(execution.getOperation());\n+      LOG.trace(\"{} {}\", kiekerPattern, execution.getEss());\n+\n+      // ignore synthetic java methods\n+      if (!methodname.equals(\"class$\") && !methodname.startsWith(\"access$\")) {\n+        addExecutionToTree(execution, fullClassname, methodname, call, kiekerPattern);\n       }\n-   }\n-\n-   private void addExecutionToTree(final Execution execution, final String fullClassname, final String methodname, final String call, final String kiekerPattern) {\n-      if (test.getClazz().equals(fullClassname) && test.getMethod().equals(methodname)) {\n-         readRoot(execution, call, kiekerPattern);\n-         setModule(fullClassname, root);\n-      } else if (root != null && execution.getTraceId() == testTraceId) {\n-         LOG.trace(fullClassname + \" \" + execution.getOperation().getSignature() + \" \" + execution.getEoi() + \" \" + execution.getEss());\n-         LOG.trace(\"Last Stack: \" + lastStackSize);\n-\n-         callLevelDown(execution);\n-         callLevelUp(execution);\n-         LOG.trace(\"Parent: {} {}\", lastParent.getCall(), lastParent.getEss());\n-\n-         if (execution.getEss() == lastParent.getEss()) {\n-            final String message = \"Trying to add \" + call + \"(\" + execution.getEss() + \")\" + \" to \" + lastParent.getCall() + \"(\" + lastParent.getEss()\n-                  + \"), but parent ess always needs to be child ess -1\";\n-            LOG.error(message);\n-            throw new RuntimeException(message);\n-         }\n-\n-         boolean hasEqualNode = false;\n-         for (CallTreeNode candidate : lastParent.getChildren()) {\n-            if (candidate.getKiekerPattern().equals(kiekerPattern)) {\n-               hasEqualNode = true;\n-               lastAdded = candidate;\n-            }\n-         }\n-         if (!ignoreEOIs || !hasEqualNode) {\n-            lastAdded = lastParent.appendChild(call, kiekerPattern, null);\n-            setModule(fullClassname, lastAdded);\n-         }\n+    }\n+  }\n+\n+  private void addExecutionToTree(final Execution execution, final String fullClassname, final String methodname, final String call, final String kiekerPattern) {\n+    if (test.getClazz().equals(fullClassname) && test.getMethod().equals(methodname)) {\n+      readRoot(execution, call, kiekerPattern);\n+      setModule(fullClassname, root);\n+    } else if (root != null && execution.getTraceId() == testTraceId) {\n+      LOG.trace(fullClassname + \" \" + execution.getOperation().getSignature() + \" \" + execution.getEoi() + \" \" + execution.getEss());\n+      LOG.trace(\"Last Stack: \" + lastStackSize);\n+\n+      callLevelDown(execution);\n+      callLevelUp(execution);\n+      LOG.trace(\"Parent: {} {}\", lastParent.getCall(), lastParent.getEss());\n+\n+      if (execution.getEss() == lastParent.getEss()) {\n+        final String message = \"Trying to add \" + call + \"(\" + execution.getEss() + \")\" + \" to \" + lastParent.getCall() + \"(\" + lastParent.getEss()\n+            + \"), but parent ess always needs to be child ess -1\";\n+        LOG.error(message);\n+        throw new RuntimeException(message);\n       }\n-   }\n-\n-   private void setModule(final String fullClassname, final CallTreeNode node) {\n-      final String outerClazzName = ClazzFileFinder.getOuterClass(fullClassname);\n-      final String moduleOfClass = mapping.getModuleOfClass(outerClazzName);\n-      node.setModule(moduleOfClass);\n-   }\n-\n-   private void callLevelUp(final Execution execution) {\n-      while (execution.getEss() < lastStackSize) {\n-         LOG.trace(\"Level up: \" + execution.getEss() + \" \" + lastStackSize);\n-         lastParent = lastParent.getParent();\n-         lastStackSize--;\n+\n+      boolean hasEqualNode = false;\n+      for (CallTreeNode candidate : lastParent.getChildren()) {\n+        if (candidate.getKiekerPattern().equals(kiekerPattern)) {\n+          hasEqualNode = true;\n+          lastAdded = candidate;\n+        }\n       }\n-   }\n-\n-   private void callLevelDown(final Execution execution) {\n-      if (execution.getEss() > lastStackSize) {\n-         LOG.trace(\"Level down: \" + execution.getEss() + \" \" + lastStackSize);\n-         lastParent = lastAdded;\n-         // lastStackSize++;\n-         if (lastStackSize + 1 != lastParent.getEss() + 1) {\n-            LOG.error(\"Down caused wrong lastStackSize: {} {}\", lastStackSize, lastParent.getEss());\n-         }\n-         lastStackSize = lastParent.getEss() + 1;\n-         LOG.trace(\"Stack size after going down: {} Measured: {}\", lastParent.getEss(), lastStackSize);\n+      if (!ignoreEOIs || !hasEqualNode) {\n+        lastAdded = lastParent.appendChild(call, kiekerPattern, null);\n+        setModule(fullClassname, lastAdded);\n       }\n-   }\n-\n-   private void readRoot(final Execution execution, final String call, final String kiekerPattern) {\n-      root = new CallTreeNode(call, kiekerPattern, null, measurementConfig);\n-      lastParent = root;\n-      testTraceId = execution.getTraceId();\n-   }\n+    }\n+  }\n+\n+  private void setModule(final String fullClassname, final CallTreeNode node) {\n+    final String outerClazzName = ClazzFileFinder.getOuterClass(fullClassname);\n+    final String moduleOfClass = mapping.getModuleOfClass(outerClazzName);\n+    node.setModule(moduleOfClass);\n+  }\n+\n+  private void callLevelUp(final Execution execution) {\n+    while (execution.getEss() < lastStackSize) {\n+      LOG.trace(\"Level up: \" + execution.getEss() + \" \" + lastStackSize);\n+      lastParent = lastParent.getParent();\n+      lastStackSize--;\n+    }\n+  }\n+\n+  private void callLevelDown(final Execution execution) {\n+    if (execution.getEss() > lastStackSize) {\n+      LOG.trace(\"Level down: \" + execution.getEss() + \" \" + lastStackSize);\n+      lastParent = lastAdded;\n+      // lastStackSize++;\n+      if (lastStackSize + 1 != lastParent.getEss() + 1) {\n+        LOG.error(\"Down caused wrong lastStackSize: {} {}\", lastStackSize, lastParent.getEss());\n+      }\n+      lastStackSize = lastParent.getEss() + 1;\n+      LOG.trace(\"Stack size after going down: {} Measured: {}\", lastParent.getEss(), lastStackSize);\n+    }\n+  }\n+\n+  private void readRoot(final Execution execution, final String call, final String kiekerPattern) {\n+    root = new CallTreeNode(call, kiekerPattern, null, measurementConfig);\n+    lastParent = root;\n+    testTraceId = execution.getTraceId();\n+  }\n \n }\n",
            "diff_size": 141
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "33",
                    "severity": "error",
                    "message": "Line is longer than 200 characters (found 201).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "86",
                    "severity": "error",
                    "message": "Line is longer than 200 characters (found 202).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/errored/1/75/TreeFilter.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/naturalize/75/TreeFilter.java\nindex ee01ae03b10..01d329184fd 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/errored/1/75/TreeFilter.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/naturalize/75/TreeFilter.java\n@@ -19,46 +19,45 @@ import kieker.tools.trace.analysis.systemModel.ExecutionTrace;\n @Plugin(description = \"A filter to transform generate PeASS-Call-trees\")\n public class TreeFilter extends AbstractFilterPlugin {\n \n-   private static final Logger LOG = LogManager.getLogger(TreeFilter.class);\n+\tprivate static final Logger LOG = LogManager.getLogger(TreeFilter.class);\n \n    public static final String INPUT_EXECUTION_TRACE = \"INPUT_EXECUTION_TRACE\";\n \n    private CallTreeNode root;\n-   \n-   private MeasurementConfiguration measurementConfig;\n-\n-   private final TestCase test;\n+private MeasurementConfiguration measurementConfig;\n+private final TestCase test;\n \n    private final boolean ignoreEOIs;\n    private final ModuleClassMapping mapping;\n \n    public TreeFilter(final String prefix, final IProjectContext projectContext, final TestCase test, final boolean ignoreEOIs, final MeasurementConfiguration config, final ModuleClassMapping mapping) {\n-      super(new Configuration(), projectContext);\n+\tsuper(new Configuration(), projectContext);\n       this.test = test;\n       this.measurementConfig = config;\n       this.ignoreEOIs = ignoreEOIs;\n       this.mapping = mapping;\n-   }\n+\t}\n \n    @Override\n    public Configuration getCurrentConfiguration() {\n-      return super.configuration;\n-   }\n+\treturn super.configuration;\n+\t}\n \n    public CallTreeNode getRoot() {\n-      return root;\n-   }\n+\treturn root;\n+\t}\n \n    CallTreeNode lastParent = null, lastAdded = null;\n    int lastStackSize = 1;\n    long testTraceId = -1;\n \n-   @InputPort(name = INPUT_EXECUTION_TRACE, eventTypes = { ExecutionTrace.class })\n+   @InputPort(name = INPUT_EXECUTION_TRACE, eventTypes = {\n+\tExecutionTrace.class })\n    public void handleInputs(final ExecutionTrace trace) {\n-      LOG.info(\"Trace: \" + trace.getTraceId());\n+\tLOG.info(\"Trace: \" + trace.getTraceId());\n \n       for (final Execution execution : trace.getTraceAsSortedExecutionSet()) {\n-         final String fullClassname = execution.getOperation().getComponentType().getFullQualifiedName().intern();\n+\tfinal String fullClassname = execution.getOperation().getComponentType().getFullQualifiedName().intern();\n          final String methodname = execution.getOperation().getSignature().getName().intern();\n          final String call = fullClassname + \"#\" + methodname;\n          final String kiekerPattern = KiekerPatternConverter.getKiekerPattern(execution.getOperation());\n@@ -66,17 +65,17 @@ public class TreeFilter extends AbstractFilterPlugin {\n \n          // ignore synthetic java methods\n          if (!methodname.equals(\"class$\") && !methodname.startsWith(\"access$\")) {\n-            addExecutionToTree(execution, fullClassname, methodname, call, kiekerPattern);\n-         }\n-      }\n-   }\n+\taddExecutionToTree(execution, fullClassname, methodname, call, kiekerPattern);\n+\t}\n+\t}\n+\t}\n \n    private void addExecutionToTree(final Execution execution, final String fullClassname, final String methodname, final String call, final String kiekerPattern) {\n-      if (test.getClazz().equals(fullClassname) && test.getMethod().equals(methodname)) {\n-         readRoot(execution, call, kiekerPattern);\n+\tif (test.getClazz().equals(fullClassname) && test.getMethod().equals(methodname)) {\n+\treadRoot(execution, call, kiekerPattern);\n          setModule(fullClassname, root);\n-      } else if (root != null && execution.getTraceId() == testTraceId) {\n-         LOG.trace(fullClassname + \" \" + execution.getOperation().getSignature() + \" \" + execution.getEoi() + \" \" + execution.getEss());\n+\t} else if (root != null && execution.getTraceId() == testTraceId) {\n+\tLOG.trace(fullClassname + \" \" + execution.getOperation().getSignature() + \" \" + execution.getEoi() + \" \" + execution.getEss());\n          LOG.trace(\"Last Stack: \" + lastStackSize);\n \n          callLevelDown(execution);\n@@ -84,57 +83,54 @@ public class TreeFilter extends AbstractFilterPlugin {\n          LOG.trace(\"Parent: {} {}\", lastParent.getCall(), lastParent.getEss());\n \n          if (execution.getEss() == lastParent.getEss()) {\n-            final String message = \"Trying to add \" + call + \"(\" + execution.getEss() + \")\" + \" to \" + lastParent.getCall() + \"(\" + lastParent.getEss()\n-                  + \"), but parent ess always needs to be child ess -1\";\n-            LOG.error(message);\n+\tfinal String message = \"Trying to add \" + call + \"(\" + execution.getEss() + \")\" + \" to \" + lastParent.getCall() + \"(\" + lastParent.getEss() + \"), but parent ess always needs to be child ess -1\";\n+LOG.error(message);\n             throw new RuntimeException(message);\n-         }\n-\n-         boolean hasEqualNode = false;\n+\t}\n+boolean hasEqualNode = false;\n          for (CallTreeNode candidate : lastParent.getChildren()) {\n-            if (candidate.getKiekerPattern().equals(kiekerPattern)) {\n-               hasEqualNode = true;\n+\tif (candidate.getKiekerPattern().equals(kiekerPattern)) {\n+\thasEqualNode = true;\n                lastAdded = candidate;\n-            }\n-         }\n+\t}\n+\t}\n          if (!ignoreEOIs || !hasEqualNode) {\n-            lastAdded = lastParent.appendChild(call, kiekerPattern, null);\n+\tlastAdded = lastParent.appendChild(call, kiekerPattern, null);\n             setModule(fullClassname, lastAdded);\n-         }\n-      }\n-   }\n+\t}\n+\t}\n+\t}\n \n    private void setModule(final String fullClassname, final CallTreeNode node) {\n-      final String outerClazzName = ClazzFileFinder.getOuterClass(fullClassname);\n+\tfinal String outerClazzName = ClazzFileFinder.getOuterClass(fullClassname);\n       final String moduleOfClass = mapping.getModuleOfClass(outerClazzName);\n       node.setModule(moduleOfClass);\n-   }\n+\t}\n \n    private void callLevelUp(final Execution execution) {\n-      while (execution.getEss() < lastStackSize) {\n-         LOG.trace(\"Level up: \" + execution.getEss() + \" \" + lastStackSize);\n+while (execution.getEss() < lastStackSize) {\n+\tLOG.trace(\"Level up: \" + execution.getEss() + \" \" + lastStackSize);\n          lastParent = lastParent.getParent();\n          lastStackSize--;\n-      }\n-   }\n+\t}\n+\t}\n \n    private void callLevelDown(final Execution execution) {\n-      if (execution.getEss() > lastStackSize) {\n-         LOG.trace(\"Level down: \" + execution.getEss() + \" \" + lastStackSize);\n+\tif (execution.getEss() > lastStackSize) {\n+\tLOG.trace(\"Level down: \" + execution.getEss() + \" \" + lastStackSize);\n          lastParent = lastAdded;\n          // lastStackSize++;\n          if (lastStackSize + 1 != lastParent.getEss() + 1) {\n-            LOG.error(\"Down caused wrong lastStackSize: {} {}\", lastStackSize, lastParent.getEss());\n-         }\n+\tLOG.error(\"Down caused wrong lastStackSize: {} {}\", lastStackSize, lastParent.getEss());\n+\t}\n          lastStackSize = lastParent.getEss() + 1;\n          LOG.trace(\"Stack size after going down: {} Measured: {}\", lastParent.getEss(), lastStackSize);\n-      }\n-   }\n+\t}\n+\t}\n \n    private void readRoot(final Execution execution, final String call, final String kiekerPattern) {\n-      root = new CallTreeNode(call, kiekerPattern, null, measurementConfig);\n+\troot = new CallTreeNode(call, kiekerPattern, null, measurementConfig);\n       lastParent = root;\n       testTraceId = execution.getTraceId();\n-   }\n-\n-}\n+\t}\n+\t}\n\\ No newline at end of file\n",
            "diff_size": 53
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "19",
                    "column": "73",
                    "severity": "error",
                    "message": "')' is preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "79",
                    "severity": "error",
                    "message": "Line is longer than 200 characters (found 205).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/errored/1/75/TreeFilter.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/codebuff/75/TreeFilter.java\nindex ee01ae03b10..403a20458f7 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/errored/1/75/TreeFilter.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/codebuff/75/TreeFilter.java\n@@ -2,7 +2,6 @@ package de.peass.measurement.rca.kieker;\n \n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n-\n import de.peass.config.MeasurementConfiguration;\n import de.peass.dependency.ClazzFileFinder;\n import de.peass.dependency.analysis.ModuleClassMapping;\n@@ -16,125 +15,116 @@ import kieker.common.configuration.Configuration;\n import kieker.tools.trace.analysis.systemModel.Execution;\n import kieker.tools.trace.analysis.systemModel.ExecutionTrace;\n \n-@Plugin(description = \"A filter to transform generate PeASS-Call-trees\")\n-public class TreeFilter extends AbstractFilterPlugin {\n-\n-   private static final Logger LOG = LogManager.getLogger(TreeFilter.class);\n-\n-   public static final String INPUT_EXECUTION_TRACE = \"INPUT_EXECUTION_TRACE\";\n-\n-   private CallTreeNode root;\n-   \n-   private MeasurementConfiguration measurementConfig;\n-\n-   private final TestCase test;\n-\n-   private final boolean ignoreEOIs;\n-   private final ModuleClassMapping mapping;\n-\n-   public TreeFilter(final String prefix, final IProjectContext projectContext, final TestCase test, final boolean ignoreEOIs, final MeasurementConfiguration config, final ModuleClassMapping mapping) {\n-      super(new Configuration(), projectContext);\n-      this.test = test;\n-      this.measurementConfig = config;\n-      this.ignoreEOIs = ignoreEOIs;\n-      this.mapping = mapping;\n-   }\n-\n-   @Override\n-   public Configuration getCurrentConfiguration() {\n-      return super.configuration;\n-   }\n-\n-   public CallTreeNode getRoot() {\n-      return root;\n-   }\n-\n-   CallTreeNode lastParent = null, lastAdded = null;\n-   int lastStackSize = 1;\n-   long testTraceId = -1;\n-\n-   @InputPort(name = INPUT_EXECUTION_TRACE, eventTypes = { ExecutionTrace.class })\n-   public void handleInputs(final ExecutionTrace trace) {\n-      LOG.info(\"Trace: \" + trace.getTraceId());\n \n-      for (final Execution execution : trace.getTraceAsSortedExecutionSet()) {\n-         final String fullClassname = execution.getOperation().getComponentType().getFullQualifiedName().intern();\n-         final String methodname = execution.getOperation().getSignature().getName().intern();\n-         final String call = fullClassname + \"#\" + methodname;\n-         final String kiekerPattern = KiekerPatternConverter.getKiekerPattern(execution.getOperation());\n-         LOG.trace(\"{} {}\", kiekerPattern, execution.getEss());\n+@Plugin(description = \"A filter to transform generate PeASS-Call-trees\" ) public class TreeFilter extends AbstractFilterPlugin {\n+ private static final Logger LOG = LogManager.getLogger(TreeFilter.class);\n+\n+ public static final String INPUT_EXECUTION_TRACE = \"INPUT_EXECUTION_TRACE\";\n+ private CallTreeNode root;\n+ private MeasurementConfiguration measurementConfig;\n+ private final TestCase test;\n+ private final boolean ignoreEOIs;\n+ private final ModuleClassMapping mapping;\n+\n+ public TreeFilter(final String prefix, final IProjectContext projectContext, final TestCase test, final boolean ignoreEOIs, final MeasurementConfiguration config, final ModuleClassMapping mapping) {\n+  super(new Configuration(), projectContext);\n+  this.test = test;\n+  this.measurementConfig = config;\n+  this.ignoreEOIs = ignoreEOIs;\n+  this.mapping = mapping;\n+ }\n+\n+ @Override\n+ public Configuration getCurrentConfiguration() {\n+  return super.configuration;\n+ }\n+\n+ public CallTreeNode getRoot() {\n+  return root;\n+ }\n+\n+ CallTreeNode lastParent = null, lastAdded = null;\n+ int lastStackSize = 1;\n+ long testTraceId = -1;\n+\n+ @InputPort(name = INPUT_EXECUTION_TRACE, eventTypes = {\n+             ExecutionTrace.class })\n+ public void handleInputs(final ExecutionTrace trace) {\n+  LOG.info(\"Trace: \" + trace.getTraceId());\n+  for (final Execution execution : trace.getTraceAsSortedExecutionSet()) {\n+   final String fullClassname = execution.getOperation().getComponentType().getFullQualifiedName().intern();\n+   final String methodname = execution.getOperation().getSignature().getName().intern();\n+   final String call = fullClassname + \"#\" + methodname;\n+   final String kiekerPattern = KiekerPatternConverter.getKiekerPattern(execution.getOperation());\n+   LOG.trace(\"{} {}\", kiekerPattern, execution.getEss());\n \n          // ignore synthetic java methods\n-         if (!methodname.equals(\"class$\") && !methodname.startsWith(\"access$\")) {\n-            addExecutionToTree(execution, fullClassname, methodname, call, kiekerPattern);\n-         }\n-      }\n-   }\n-\n-   private void addExecutionToTree(final Execution execution, final String fullClassname, final String methodname, final String call, final String kiekerPattern) {\n-      if (test.getClazz().equals(fullClassname) && test.getMethod().equals(methodname)) {\n-         readRoot(execution, call, kiekerPattern);\n-         setModule(fullClassname, root);\n-      } else if (root != null && execution.getTraceId() == testTraceId) {\n-         LOG.trace(fullClassname + \" \" + execution.getOperation().getSignature() + \" \" + execution.getEoi() + \" \" + execution.getEss());\n-         LOG.trace(\"Last Stack: \" + lastStackSize);\n-\n-         callLevelDown(execution);\n-         callLevelUp(execution);\n-         LOG.trace(\"Parent: {} {}\", lastParent.getCall(), lastParent.getEss());\n-\n-         if (execution.getEss() == lastParent.getEss()) {\n-            final String message = \"Trying to add \" + call + \"(\" + execution.getEss() + \")\" + \" to \" + lastParent.getCall() + \"(\" + lastParent.getEss()\n-                  + \"), but parent ess always needs to be child ess -1\";\n-            LOG.error(message);\n-            throw new RuntimeException(message);\n-         }\n-\n-         boolean hasEqualNode = false;\n-         for (CallTreeNode candidate : lastParent.getChildren()) {\n-            if (candidate.getKiekerPattern().equals(kiekerPattern)) {\n-               hasEqualNode = true;\n-               lastAdded = candidate;\n-            }\n-         }\n-         if (!ignoreEOIs || !hasEqualNode) {\n-            lastAdded = lastParent.appendChild(call, kiekerPattern, null);\n-            setModule(fullClassname, lastAdded);\n-         }\n-      }\n-   }\n-\n-   private void setModule(final String fullClassname, final CallTreeNode node) {\n-      final String outerClazzName = ClazzFileFinder.getOuterClass(fullClassname);\n-      final String moduleOfClass = mapping.getModuleOfClass(outerClazzName);\n-      node.setModule(moduleOfClass);\n+   if (!methodname.equals(\"class$\") && !methodname.startsWith(\"access$\")) {\n+    addExecutionToTree(execution, fullClassname, methodname, call, kiekerPattern);\n    }\n-\n-   private void callLevelUp(final Execution execution) {\n-      while (execution.getEss() < lastStackSize) {\n-         LOG.trace(\"Level up: \" + execution.getEss() + \" \" + lastStackSize);\n-         lastParent = lastParent.getParent();\n-         lastStackSize--;\n-      }\n-   }\n-\n-   private void callLevelDown(final Execution execution) {\n-      if (execution.getEss() > lastStackSize) {\n-         LOG.trace(\"Level down: \" + execution.getEss() + \" \" + lastStackSize);\n-         lastParent = lastAdded;\n+  }\n+ }\n+\n+ private void addExecutionToTree(final Execution execution, final String fullClassname, final String methodname, final String call, final String kiekerPattern) {\n+  if (test.getClazz().equals(fullClassname) && test.getMethod().equals(methodname)) {\n+   readRoot(execution, call, kiekerPattern);\n+   setModule(fullClassname, root);\n+  } else if (root != null && execution.getTraceId() == testTraceId) {\n+          LOG.trace(fullClassname + \" \" + execution.getOperation().getSignature() + \" \" + execution.getEoi() + \" \" + execution.getEss());\n+          LOG.trace(\"Last Stack: \" + lastStackSize);\n+          callLevelDown(execution);\n+          callLevelUp(execution);\n+          LOG.trace(\"Parent: {} {}\", lastParent.getCall(), lastParent.getEss());\n+          if (execution.getEss() == lastParent.getEss()) {\n+           final String message = \"Trying to add \" + call + \"(\" + execution.getEss() + \")\" + \" to \" + lastParent.getCall() + \"(\" + lastParent.getEss() + \"), but parent ess always needs to be child ess -1\";\n+           LOG.error(message);\n+           throw new RuntimeException(message);\n+          }\n+\n+          boolean hasEqualNode = false;\n+          for (CallTreeNode candidate : lastParent.getChildren()) {\n+           if (candidate.getKiekerPattern().equals(kiekerPattern)) {\n+            hasEqualNode = true;\n+            lastAdded = candidate;\n+           }\n+          }\n+          if (!ignoreEOIs || !hasEqualNode) {\n+           lastAdded = lastParent.appendChild(call, kiekerPattern, null);\n+           setModule(fullClassname, lastAdded);\n+          }\n+  }\n+ }\n+\n+ private void setModule(final String fullClassname, final CallTreeNode node) {\n+  final String outerClazzName = ClazzFileFinder.getOuterClass(fullClassname);\n+  final String moduleOfClass = mapping.getModuleOfClass(outerClazzName);\n+  node.setModule(moduleOfClass);\n+ }\n+\n+ private void callLevelUp(final Execution execution) {\n+  while (execution.getEss() < lastStackSize) {\n+   LOG.trace(\"Level up: \" + execution.getEss() + \" \" + lastStackSize);\n+   lastParent = lastParent.getParent();\n+   lastStackSize--;\n+  }\n+ }\n+\n+ private void callLevelDown(final Execution execution) {\n+  if (execution.getEss() > lastStackSize) {\n+   LOG.trace(\"Level down: \" + execution.getEss() + \" \" + lastStackSize);\n+   lastParent = lastAdded;\n          // lastStackSize++;\n-         if (lastStackSize + 1 != lastParent.getEss() + 1) {\n-            LOG.error(\"Down caused wrong lastStackSize: {} {}\", lastStackSize, lastParent.getEss());\n-         }\n-         lastStackSize = lastParent.getEss() + 1;\n-         LOG.trace(\"Stack size after going down: {} Measured: {}\", lastParent.getEss(), lastStackSize);\n-      }\n+   if (lastStackSize + 1 != lastParent.getEss() + 1) {\n+    LOG.error(\"Down caused wrong lastStackSize: {} {}\", lastStackSize, lastParent.getEss());\n    }\n-\n-   private void readRoot(final Execution execution, final String call, final String kiekerPattern) {\n-      root = new CallTreeNode(call, kiekerPattern, null, measurementConfig);\n-      lastParent = root;\n-      testTraceId = execution.getTraceId();\n-   }\n-\n-}\n+   lastStackSize = lastParent.getEss() + 1;\n+   LOG.trace(\"Stack size after going down: {} Measured: {}\", lastParent.getEss(), lastStackSize);\n+  }\n+ }\n+\n+ private void readRoot(final Execution execution, final String call, final String kiekerPattern) {\n+  root = new CallTreeNode(call, kiekerPattern, null, measurementConfig);\n+  lastParent = root;\n+  testTraceId = execution.getTraceId();\n+ }\n+}\n\\ No newline at end of file\n",
            "diff_size": 193
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "35",
                    "severity": "error",
                    "message": "Line is longer than 200 characters (found 222).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/errored/1/75/TreeFilter.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/styler_random/75/TreeFilter.java\nindex ee01ae03b10..c16ed883f5e 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/errored/1/75/TreeFilter.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/styler_random/75/TreeFilter.java\n@@ -32,7 +32,7 @@ public class TreeFilter extends AbstractFilterPlugin {\n    private final boolean ignoreEOIs;\n    private final ModuleClassMapping mapping;\n \n-   public TreeFilter(final String prefix, final IProjectContext projectContext, final TestCase test, final boolean ignoreEOIs, final MeasurementConfiguration config, final ModuleClassMapping mapping) {\n+\t\t\tpublic TreeFilter(final String prefix, final IProjectContext projectContext, final TestCase test, final boolean ignoreEOIs, final MeasurementConfiguration config, final ModuleClassMapping mapping) {\n       super(new Configuration(), projectContext);\n       this.test = test;\n       this.measurementConfig = config;\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": null,
            "diff": null
        }
    ],
    "repaired_by": [
        "intellij"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}