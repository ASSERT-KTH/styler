{
    "project_name": "codefollower-H2-Research",
    "error_id": "579",
    "information": {
        "errors": [
            {
                "line": "313",
                "column": "39",
                "severity": "warning",
                "message": "Don't use trailing comments.",
                "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
            }
        ]
    },
    "source_code": "    public OutputStream newOutputStream(boolean append) throws IOException {\n        Path file = Paths.get(name);\n        OpenOption[] options = append //\n                ? new OpenOption[] { StandardOpenOption.CREATE, StandardOpenOption.APPEND }\n                : new OpenOption[0];\n        try {",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/579/FilePathDisk.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler/579/FilePathDisk.java\nindex db9b6b113ce..003e8d6ef7e 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/579/FilePathDisk.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler/579/FilePathDisk.java\n@@ -310,8 +310,9 @@ public class FilePathDisk extends FilePath {\n     @Override\n     public OutputStream newOutputStream(boolean append) throws IOException {\n         Path file = Paths.get(name);\n-        OpenOption[] options = append //\n-                ? new OpenOption[] { StandardOpenOption.CREATE, StandardOpenOption.APPEND }\n+        OpenOption[] options = append\n+        //\n+                 ? new OpenOption[] { StandardOpenOption.CREATE, StandardOpenOption.APPEND }\n                 : new OpenOption[0];\n         try {\n             Path parent = file.getParent();\n",
            "diff_size": 3
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "314",
                    "column": "35",
                    "severity": "warning",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/579/FilePathDisk.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/579/FilePathDisk.java\nindex db9b6b113ce..b5d592b1f4e 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/579/FilePathDisk.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/579/FilePathDisk.java\n@@ -3,6 +3,7 @@\n  * and the EPL 1.0 (https://h2database.com/html/license.html).\n  * Initial Developer: H2 Group\n  */\n+\n package org.h2.store.fs;\n \n import java.io.File;\n@@ -36,372 +37,372 @@ import org.h2.util.IOUtils;\n  */\n public class FilePathDisk extends FilePath {\n \n-    private static final String CLASSPATH_PREFIX = \"classpath:\";\n+  private static final String CLASSPATH_PREFIX = \"classpath:\";\n \n-    @Override\n-    public FilePathDisk getPath(String path) {\n-        FilePathDisk p = new FilePathDisk();\n-        p.name = translateFileName(path);\n-        return p;\n-    }\n+  @Override\n+  public FilePathDisk getPath(String path) {\n+    FilePathDisk p = new FilePathDisk();\n+    p.name = translateFileName(path);\n+    return p;\n+  }\n \n-    @Override\n-    public long size() {\n-        if (name.startsWith(CLASSPATH_PREFIX)) {\n-            try {\n-                String fileName = name.substring(CLASSPATH_PREFIX.length());\n-                // Force absolute resolution in Class.getResource\n-                if (!fileName.startsWith(\"/\")) {\n-                    fileName = \"/\" + fileName;\n-                }\n-                URL resource = this.getClass().getResource(fileName);\n-                if (resource != null) {\n-                    return Files.size(Paths.get(resource.toURI()));\n-                } else {\n-                    return 0;\n-                }\n-            } catch (Exception e) {\n-                return 0;\n-            }\n+  @Override\n+  public long size() {\n+    if (name.startsWith(CLASSPATH_PREFIX)) {\n+      try {\n+        String fileName = name.substring(CLASSPATH_PREFIX.length());\n+        // Force absolute resolution in Class.getResource\n+        if (!fileName.startsWith(\"/\")) {\n+          fileName = \"/\" + fileName;\n+        }\n+        URL resource = this.getClass().getResource(fileName);\n+        if (resource != null) {\n+          return Files.size(Paths.get(resource.toURI()));\n+        } else {\n+          return 0;\n         }\n-        return new File(name).length();\n+      } catch (Exception e) {\n+        return 0;\n+      }\n     }\n+    return new File(name).length();\n+  }\n \n-    /**\n-     * Translate the file name to the native format. This will replace '\\' with\n-     * '/' and expand the home directory ('~').\n-     *\n-     * @param fileName the file name\n-     * @return the native file name\n-     */\n-    protected static String translateFileName(String fileName) {\n-        fileName = fileName.replace('\\\\', '/');\n-        if (fileName.startsWith(\"file:\")) {\n-            fileName = fileName.substring(5);\n-        } else if (fileName.startsWith(\"nio:\")) {\n-            fileName = fileName.substring(4);\n-        }\n-        return expandUserHomeDirectory(fileName);\n+  /**\n+   * Translate the file name to the native format. This will replace '\\' with\n+   * '/' and expand the home directory ('~').\n+   *\n+   * @param fileName the file name\n+   * @return the native file name\n+   */\n+  protected static String translateFileName(String fileName) {\n+    fileName = fileName.replace('\\\\', '/');\n+    if (fileName.startsWith(\"file:\")) {\n+      fileName = fileName.substring(5);\n+    } else if (fileName.startsWith(\"nio:\")) {\n+      fileName = fileName.substring(4);\n     }\n+    return expandUserHomeDirectory(fileName);\n+  }\n \n-    /**\n-     * Expand '~' to the user home directory. It is only be expanded if the '~'\n-     * stands alone, or is followed by '/' or '\\'.\n-     *\n-     * @param fileName the file name\n-     * @return the native file name\n-     */\n-    public static String expandUserHomeDirectory(String fileName) {\n-        if (fileName.startsWith(\"~\") && (fileName.length() == 1 ||\n-                fileName.startsWith(\"~/\"))) {\n-            String userDir = SysProperties.USER_HOME;\n-            fileName = userDir + fileName.substring(1);\n-        }\n-        return fileName;\n+  /**\n+   * Expand '~' to the user home directory. It is only be expanded if the '~'\n+   * stands alone, or is followed by '/' or '\\'.\n+   *\n+   * @param fileName the file name\n+   * @return the native file name\n+   */\n+  public static String expandUserHomeDirectory(String fileName) {\n+    if (fileName.startsWith(\"~\") && (fileName.length() == 1 ||\n+        fileName.startsWith(\"~/\"))) {\n+      String userDir = SysProperties.USER_HOME;\n+      fileName = userDir + fileName.substring(1);\n     }\n+    return fileName;\n+  }\n \n-    @Override\n-    public void moveTo(FilePath newName, boolean atomicReplace) {\n-        Path oldFile = Paths.get(name);\n-        Path newFile = Paths.get(newName.name);\n-        if (!Files.exists(oldFile)) {\n-            throw DbException.get(ErrorCode.FILE_RENAME_FAILED_2, name + \" (not found)\", newName.name);\n-        }\n-        if (atomicReplace) {\n-            try {\n-                Files.move(oldFile, newFile, StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.ATOMIC_MOVE);\n-                return;\n-            } catch (AtomicMoveNotSupportedException ex) {\n-                // Ignore\n-            } catch (IOException ex) {\n-                throw DbException.get(ErrorCode.FILE_RENAME_FAILED_2, ex, name, newName.name);\n-            }\n-        }\n-        CopyOption[] copyOptions = atomicReplace ? new CopyOption[] { StandardCopyOption.REPLACE_EXISTING }\n-                : new CopyOption[0];\n-        IOException cause;\n+  @Override\n+  public void moveTo(FilePath newName, boolean atomicReplace) {\n+    Path oldFile = Paths.get(name);\n+    Path newFile = Paths.get(newName.name);\n+    if (!Files.exists(oldFile)) {\n+      throw DbException.get(ErrorCode.FILE_RENAME_FAILED_2, name + \" (not found)\", newName.name);\n+    }\n+    if (atomicReplace) {\n+      try {\n+        Files.move(oldFile, newFile, StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.ATOMIC_MOVE);\n+        return;\n+      } catch (AtomicMoveNotSupportedException ex) {\n+        // Ignore\n+      } catch (IOException ex) {\n+        throw DbException.get(ErrorCode.FILE_RENAME_FAILED_2, ex, name, newName.name);\n+      }\n+    }\n+    CopyOption[] copyOptions = atomicReplace ? new CopyOption[] {StandardCopyOption.REPLACE_EXISTING}\n+        : new CopyOption[0];\n+    IOException cause;\n+    try {\n+      Files.move(oldFile, newFile, copyOptions);\n+    } catch (FileAlreadyExistsException ex) {\n+      throw DbException.get(ErrorCode.FILE_RENAME_FAILED_2, name, newName + \" (exists)\");\n+    } catch (IOException ex) {\n+      cause = ex;\n+      for (int i = 0; i < SysProperties.MAX_FILE_RETRY; i++) {\n+        IOUtils.trace(\"rename\", name + \" >\" + newName, null);\n         try {\n-            Files.move(oldFile, newFile, copyOptions);\n-        } catch (FileAlreadyExistsException ex) {\n-            throw DbException.get(ErrorCode.FILE_RENAME_FAILED_2, name, newName + \" (exists)\");\n-        } catch (IOException ex) {\n-            cause = ex;\n-            for (int i = 0; i < SysProperties.MAX_FILE_RETRY; i++) {\n-                IOUtils.trace(\"rename\", name + \" >\" + newName, null);\n-                try {\n-                    Files.move(oldFile, newFile, copyOptions);\n-                    return;\n-                } catch (FileAlreadyExistsException ex2) {\n-                    throw DbException.get(ErrorCode.FILE_RENAME_FAILED_2, name, newName + \" (exists)\");\n-                } catch (IOException ex2) {\n-                    cause = ex;\n-                }\n-                wait(i);\n-            }\n-            throw DbException.get(ErrorCode.FILE_RENAME_FAILED_2, cause, name, newName.name);\n+          Files.move(oldFile, newFile, copyOptions);\n+          return;\n+        } catch (FileAlreadyExistsException ex2) {\n+          throw DbException.get(ErrorCode.FILE_RENAME_FAILED_2, name, newName + \" (exists)\");\n+        } catch (IOException ex2) {\n+          cause = ex;\n         }\n+        wait(i);\n+      }\n+      throw DbException.get(ErrorCode.FILE_RENAME_FAILED_2, cause, name, newName.name);\n     }\n+  }\n \n-    private static void wait(int i) {\n-        if (i == 8) {\n-            System.gc();\n-        }\n-        try {\n-            // sleep at most 256 ms\n-            long sleep = Math.min(256, i * i);\n-            Thread.sleep(sleep);\n-        } catch (InterruptedException e) {\n-            // ignore\n-        }\n+  private static void wait(int i) {\n+    if (i == 8) {\n+      System.gc();\n     }\n+    try {\n+      // sleep at most 256 ms\n+      long sleep = Math.min(256, i * i);\n+      Thread.sleep(sleep);\n+    } catch (InterruptedException e) {\n+      // ignore\n+    }\n+  }\n \n-    @Override\n-    public boolean createFile() {\n-        Path file = Paths.get(name);\n-        for (int i = 0; i < SysProperties.MAX_FILE_RETRY; i++) {\n-            try {\n-                Files.createFile(file);\n-                return true;\n-            } catch (FileAlreadyExistsException e) {\n-                return false;\n-            } catch (IOException e) {\n-                // 'access denied' is really a concurrent access problem\n-                wait(i);\n-            }\n-        }\n+  @Override\n+  public boolean createFile() {\n+    Path file = Paths.get(name);\n+    for (int i = 0; i < SysProperties.MAX_FILE_RETRY; i++) {\n+      try {\n+        Files.createFile(file);\n+        return true;\n+      } catch (FileAlreadyExistsException e) {\n         return false;\n+      } catch (IOException e) {\n+        // 'access denied' is really a concurrent access problem\n+        wait(i);\n+      }\n     }\n+    return false;\n+  }\n \n-    @Override\n-    public boolean exists() {\n-        return new File(name).exists();\n-    }\n+  @Override\n+  public boolean exists() {\n+    return new File(name).exists();\n+  }\n \n-    @Override\n-    public void delete() {\n-        Path file = Paths.get(name);\n-        IOException cause = null;\n-        for (int i = 0; i < SysProperties.MAX_FILE_RETRY; i++) {\n-            IOUtils.trace(\"delete\", name, null);\n-            try {\n-                Files.deleteIfExists(file);\n-                return;\n-            } catch (DirectoryNotEmptyException e) {\n-                throw DbException.get(ErrorCode.FILE_DELETE_FAILED_1, e, name);\n-            } catch (IOException e) {\n-                cause = e;\n-            }\n-            wait(i);\n-        }\n-        throw DbException.get(ErrorCode.FILE_DELETE_FAILED_1, cause, name);\n+  @Override\n+  public void delete() {\n+    Path file = Paths.get(name);\n+    IOException cause = null;\n+    for (int i = 0; i < SysProperties.MAX_FILE_RETRY; i++) {\n+      IOUtils.trace(\"delete\", name, null);\n+      try {\n+        Files.deleteIfExists(file);\n+        return;\n+      } catch (DirectoryNotEmptyException e) {\n+        throw DbException.get(ErrorCode.FILE_DELETE_FAILED_1, e, name);\n+      } catch (IOException e) {\n+        cause = e;\n+      }\n+      wait(i);\n     }\n+    throw DbException.get(ErrorCode.FILE_DELETE_FAILED_1, cause, name);\n+  }\n \n-    @Override\n-    public List<FilePath> newDirectoryStream() {\n-        ArrayList<FilePath> list = new ArrayList<>();\n-        File f = new File(name);\n-        try {\n-            String[] files = f.list();\n-            if (files != null) {\n-                String base = f.getCanonicalPath();\n-                if (!base.endsWith(SysProperties.FILE_SEPARATOR)) {\n-                    base += SysProperties.FILE_SEPARATOR;\n-                }\n-                list.ensureCapacity(files.length);\n-                for (String file : files) {\n-                    list.add(getPath(base + file));\n-                }\n-            }\n-            return list;\n-        } catch (IOException e) {\n-            throw DbException.convertIOException(e, name);\n+  @Override\n+  public List<FilePath> newDirectoryStream() {\n+    ArrayList<FilePath> list = new ArrayList<>();\n+    File f = new File(name);\n+    try {\n+      String[] files = f.list();\n+      if (files != null) {\n+        String base = f.getCanonicalPath();\n+        if (!base.endsWith(SysProperties.FILE_SEPARATOR)) {\n+          base += SysProperties.FILE_SEPARATOR;\n+        }\n+        list.ensureCapacity(files.length);\n+        for (String file : files) {\n+          list.add(getPath(base + file));\n         }\n+      }\n+      return list;\n+    } catch (IOException e) {\n+      throw DbException.convertIOException(e, name);\n     }\n+  }\n \n-    @Override\n-    public boolean canWrite() {\n-        return canWriteInternal(new File(name));\n-    }\n+  @Override\n+  public boolean canWrite() {\n+    return canWriteInternal(new File(name));\n+  }\n \n-    @Override\n-    public boolean setReadOnly() {\n-        File f = new File(name);\n-        return f.setReadOnly();\n-    }\n+  @Override\n+  public boolean setReadOnly() {\n+    File f = new File(name);\n+    return f.setReadOnly();\n+  }\n \n-    @Override\n-    public FilePathDisk toRealPath() {\n-        try {\n-            String fileName = new File(name).getCanonicalPath();\n-            return getPath(fileName);\n-        } catch (IOException e) {\n-            throw DbException.convertIOException(e, name);\n-        }\n+  @Override\n+  public FilePathDisk toRealPath() {\n+    try {\n+      String fileName = new File(name).getCanonicalPath();\n+      return getPath(fileName);\n+    } catch (IOException e) {\n+      throw DbException.convertIOException(e, name);\n     }\n+  }\n \n-    @Override\n-    public FilePath getParent() {\n-        String p = new File(name).getParent();\n-        return p == null ? null : getPath(p);\n-    }\n+  @Override\n+  public FilePath getParent() {\n+    String p = new File(name).getParent();\n+    return p == null ? null : getPath(p);\n+  }\n \n-    @Override\n-    public boolean isDirectory() {\n-        return Files.isDirectory(Paths.get(name));\n-    }\n+  @Override\n+  public boolean isDirectory() {\n+    return Files.isDirectory(Paths.get(name));\n+  }\n \n-    @Override\n-    public boolean isAbsolute() {\n-        return new File(name).isAbsolute();\n-    }\n+  @Override\n+  public boolean isAbsolute() {\n+    return new File(name).isAbsolute();\n+  }\n \n-    @Override\n-    public long lastModified() {\n-        return new File(name).lastModified();\n-    }\n+  @Override\n+  public long lastModified() {\n+    return new File(name).lastModified();\n+  }\n \n-    private static boolean canWriteInternal(File file) {\n-        try {\n-            if (!file.canWrite()) {\n-                return false;\n-            }\n-        } catch (Exception e) {\n-            // workaround for GAE which throws a\n-            // java.security.AccessControlException\n-            return false;\n-        }\n-        // File.canWrite() does not respect windows user permissions,\n-        // so we must try to open it using the mode \"rw\".\n-        // See also https://bugs.java.com/bugdatabase/view_bug.do?bug_id=4420020\n-        try (FileChannel f = FileChannel.open(file.toPath(), FileUtils.RW, FileUtils.NO_ATTRIBUTES)) {\n-            return true;\n-        } catch (IOException e) {\n-            return false;\n-        }\n+  private static boolean canWriteInternal(File file) {\n+    try {\n+      if (!file.canWrite()) {\n+        return false;\n+      }\n+    } catch (Exception e) {\n+      // workaround for GAE which throws a\n+      // java.security.AccessControlException\n+      return false;\n+    }\n+    // File.canWrite() does not respect windows user permissions,\n+    // so we must try to open it using the mode \"rw\".\n+    // See also https://bugs.java.com/bugdatabase/view_bug.do?bug_id=4420020\n+    try (FileChannel f = FileChannel.open(file.toPath(), FileUtils.RW, FileUtils.NO_ATTRIBUTES)) {\n+      return true;\n+    } catch (IOException e) {\n+      return false;\n     }\n+  }\n \n-    @Override\n-    public void createDirectory() {\n-        Path dir = Paths.get(name);\n+  @Override\n+  public void createDirectory() {\n+    Path dir = Paths.get(name);\n+    try {\n+      Files.createDirectory(dir);\n+    } catch (FileAlreadyExistsException e) {\n+      throw DbException.get(ErrorCode.FILE_CREATION_FAILED_1, name + \" (a file with this name already exists)\");\n+    } catch (IOException e) {\n+      IOException cause = e;\n+      for (int i = 0; i < SysProperties.MAX_FILE_RETRY; i++) {\n+        if (Files.isDirectory(dir)) {\n+          return;\n+        }\n         try {\n-            Files.createDirectory(dir);\n-        } catch (FileAlreadyExistsException e) {\n-            throw DbException.get(ErrorCode.FILE_CREATION_FAILED_1, name + \" (a file with this name already exists)\");\n-        } catch (IOException e) {\n-            IOException cause = e;\n-            for (int i = 0; i < SysProperties.MAX_FILE_RETRY; i++) {\n-                if (Files.isDirectory(dir)) {\n-                    return;\n-                }\n-                try {\n-                    Files.createDirectory(dir);\n-                } catch (FileAlreadyExistsException ex) {\n-                    throw DbException.get(ErrorCode.FILE_CREATION_FAILED_1,\n-                            name + \" (a file with this name already exists)\");\n-                } catch (IOException ex) {\n-                    cause = ex;\n-                }\n-                wait(i);\n-            }\n-            throw DbException.get(ErrorCode.FILE_CREATION_FAILED_1, cause, name);\n+          Files.createDirectory(dir);\n+        } catch (FileAlreadyExistsException ex) {\n+          throw DbException.get(ErrorCode.FILE_CREATION_FAILED_1,\n+              name + \" (a file with this name already exists)\");\n+        } catch (IOException ex) {\n+          cause = ex;\n         }\n+        wait(i);\n+      }\n+      throw DbException.get(ErrorCode.FILE_CREATION_FAILED_1, cause, name);\n     }\n+  }\n \n-    @Override\n-    public OutputStream newOutputStream(boolean append) throws IOException {\n-        Path file = Paths.get(name);\n-        OpenOption[] options = append //\n-                ? new OpenOption[] { StandardOpenOption.CREATE, StandardOpenOption.APPEND }\n-                : new OpenOption[0];\n-        try {\n-            Path parent = file.getParent();\n-            if (parent != null) {\n-                Files.createDirectories(parent);\n-            }\n-            OutputStream out = Files.newOutputStream(file, options);\n-            IOUtils.trace(\"openFileOutputStream\", name, out);\n-            return out;\n-        } catch (IOException e) {\n-            freeMemoryAndFinalize();\n-            return Files.newOutputStream(file, options);\n-        }\n+  @Override\n+  public OutputStream newOutputStream(boolean append) throws IOException {\n+    Path file = Paths.get(name);\n+    OpenOption[] options = append //\n+        ? new OpenOption[] {StandardOpenOption.CREATE, StandardOpenOption.APPEND}\n+        : new OpenOption[0];\n+    try {\n+      Path parent = file.getParent();\n+      if (parent != null) {\n+        Files.createDirectories(parent);\n+      }\n+      OutputStream out = Files.newOutputStream(file, options);\n+      IOUtils.trace(\"openFileOutputStream\", name, out);\n+      return out;\n+    } catch (IOException e) {\n+      freeMemoryAndFinalize();\n+      return Files.newOutputStream(file, options);\n     }\n+  }\n \n-    @Override\n-    public InputStream newInputStream() throws IOException {\n-        if (name.matches(\"[a-zA-Z]{2,19}:.*\")) {\n-            // if the ':' is in position 1, a windows file access is assumed:\n-            // C:.. or D:, and if the ':' is not at the beginning, assume its a\n-            // file name with a colon\n-            if (name.startsWith(CLASSPATH_PREFIX)) {\n-                String fileName = name.substring(CLASSPATH_PREFIX.length());\n-                // Force absolute resolution in Class.getResourceAsStream\n-                if (!fileName.startsWith(\"/\")) {\n-                    fileName = \"/\" + fileName;\n-                }\n-                InputStream in = getClass().getResourceAsStream(fileName);\n-                if (in == null) {\n-                    // ClassLoader.getResourceAsStream doesn't need leading \"/\"\n-                    in = Thread.currentThread().getContextClassLoader().\n-                            getResourceAsStream(fileName.substring(1));\n-                }\n-                if (in == null) {\n-                    throw new FileNotFoundException(\"resource \" + fileName);\n-                }\n-                return in;\n-            }\n-            // otherwise a URL is assumed\n-            URL url = new URL(name);\n-            return url.openStream();\n+  @Override\n+  public InputStream newInputStream() throws IOException {\n+    if (name.matches(\"[a-zA-Z]{2,19}:.*\")) {\n+      // if the ':' is in position 1, a windows file access is assumed:\n+      // C:.. or D:, and if the ':' is not at the beginning, assume its a\n+      // file name with a colon\n+      if (name.startsWith(CLASSPATH_PREFIX)) {\n+        String fileName = name.substring(CLASSPATH_PREFIX.length());\n+        // Force absolute resolution in Class.getResourceAsStream\n+        if (!fileName.startsWith(\"/\")) {\n+          fileName = \"/\" + fileName;\n+        }\n+        InputStream in = getClass().getResourceAsStream(fileName);\n+        if (in == null) {\n+          // ClassLoader.getResourceAsStream doesn't need leading \"/\"\n+          in = Thread.currentThread().getContextClassLoader().\n+              getResourceAsStream(fileName.substring(1));\n+        }\n+        if (in == null) {\n+          throw new FileNotFoundException(\"resource \" + fileName);\n         }\n-        InputStream in = Files.newInputStream(Paths.get(name));\n-        IOUtils.trace(\"openFileInputStream\", name, in);\n         return in;\n+      }\n+      // otherwise a URL is assumed\n+      URL url = new URL(name);\n+      return url.openStream();\n     }\n+    InputStream in = Files.newInputStream(Paths.get(name));\n+    IOUtils.trace(\"openFileInputStream\", name, in);\n+    return in;\n+  }\n \n-    /**\n-     * Call the garbage collection and run finalization. This close all files\n-     * that were not closed, and are no longer referenced.\n-     */\n-    static void freeMemoryAndFinalize() {\n-        IOUtils.trace(\"freeMemoryAndFinalize\", null, null);\n-        Runtime rt = Runtime.getRuntime();\n-        long mem = rt.freeMemory();\n-        for (int i = 0; i < 16; i++) {\n-            rt.gc();\n-            long now = rt.freeMemory();\n-            rt.runFinalization();\n-            if (now == mem) {\n-                break;\n-            }\n-            mem = now;\n-        }\n+  /**\n+   * Call the garbage collection and run finalization. This close all files\n+   * that were not closed, and are no longer referenced.\n+   */\n+  static void freeMemoryAndFinalize() {\n+    IOUtils.trace(\"freeMemoryAndFinalize\", null, null);\n+    Runtime rt = Runtime.getRuntime();\n+    long mem = rt.freeMemory();\n+    for (int i = 0; i < 16; i++) {\n+      rt.gc();\n+      long now = rt.freeMemory();\n+      rt.runFinalization();\n+      if (now == mem) {\n+        break;\n+      }\n+      mem = now;\n     }\n+  }\n \n-    @Override\n-    public FileChannel open(String mode) throws IOException {\n-        FileChannel f = FileChannel.open(Paths.get(name), FileUtils.modeToOptions(mode), FileUtils.NO_ATTRIBUTES);\n-        IOUtils.trace(\"open\", name, f);\n-        return f;\n-    }\n+  @Override\n+  public FileChannel open(String mode) throws IOException {\n+    FileChannel f = FileChannel.open(Paths.get(name), FileUtils.modeToOptions(mode), FileUtils.NO_ATTRIBUTES);\n+    IOUtils.trace(\"open\", name, f);\n+    return f;\n+  }\n \n-    @Override\n-    public String getScheme() {\n-        return \"file\";\n-    }\n+  @Override\n+  public String getScheme() {\n+    return \"file\";\n+  }\n \n-    @Override\n-    public FilePath createTempFile(String suffix, boolean inTempDir) throws IOException {\n-        Path file = Paths.get(name + '.').toAbsolutePath();\n-        String prefix = file.getFileName().toString();\n-        if (inTempDir) {\n-            file = Files.createTempFile(prefix, suffix);\n-        } else {\n-            Path dir = file.getParent();\n-            Files.createDirectories(dir);\n-            file = Files.createTempFile(dir, prefix, suffix);\n-        }\n-        return get(file.toString());\n+  @Override\n+  public FilePath createTempFile(String suffix, boolean inTempDir) throws IOException {\n+    Path file = Paths.get(name + '.').toAbsolutePath();\n+    String prefix = file.getFileName().toString();\n+    if (inTempDir) {\n+      file = Files.createTempFile(prefix, suffix);\n+    } else {\n+      Path dir = file.getParent();\n+      Files.createDirectories(dir);\n+      file = Files.createTempFile(dir, prefix, suffix);\n     }\n+    return get(file.toString());\n+  }\n \n }\n",
            "diff_size": 388
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "313",
                    "column": "38",
                    "severity": "warning",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/579/FilePathDisk.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_random/579/FilePathDisk.java\nindex db9b6b113ce..83fd690681d 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/579/FilePathDisk.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_random/579/FilePathDisk.java\n@@ -310,7 +310,7 @@ public class FilePathDisk extends FilePath {\n     @Override\n     public OutputStream newOutputStream(boolean append) throws IOException {\n         Path file = Paths.get(name);\n-        OpenOption[] options = append //\n+        OpenOption[] options = append//\n                 ? new OpenOption[] { StandardOpenOption.CREATE, StandardOpenOption.APPEND }\n                 : new OpenOption[0];\n         try {\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/579/FilePathDisk.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/579/FilePathDisk.java\nindex db9b6b113ce..003e8d6ef7e 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/579/FilePathDisk.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/579/FilePathDisk.java\n@@ -310,8 +310,9 @@ public class FilePathDisk extends FilePath {\n     @Override\n     public OutputStream newOutputStream(boolean append) throws IOException {\n         Path file = Paths.get(name);\n-        OpenOption[] options = append //\n-                ? new OpenOption[] { StandardOpenOption.CREATE, StandardOpenOption.APPEND }\n+        OpenOption[] options = append\n+        //\n+                 ? new OpenOption[] { StandardOpenOption.CREATE, StandardOpenOption.APPEND }\n                 : new OpenOption[0];\n         try {\n             Path parent = file.getParent();\n",
            "diff_size": 3
        }
    ],
    "repaired_by": [
        "styler",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random"
    ]
}