{
    "project_name": "CESNET-perun",
    "error_id": "258",
    "information": {
        "errors": [
            {
                "line": "80",
                "severity": "error",
                "message": "Line matches the illegal pattern 'Wrong number of tabs before space on next line. Indent must use tab characters.'.",
                "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpCheck"
            }
        ]
    },
    "source_code": "\tpublic final static List<String> reservedNamesForUnixGroups = Arrays.asList(\"root\", \"daemon\", \"tty\", \"bin\", \"sys\", \"sudo\", \"nogroup\",\n\t          \"hadoop\", \"hdfs\", \"mapred\", \"yarn\", \"hsqldb\", \"derby\", \"jetty\", \"hbase\", \"zookeeper\", \"users\", \"oozie\", \"hive\");\n\tpublic final static List<String> unpermittedNamesForUserLogins = Arrays.asList(\"arraysvcs\", \"at\", \"backup\", \"bin\", \"daemon\", \"Debian-exim\", \"flexlm\", \"ftp\", \"games\",\n\t\t        \"gdm\", \"glite\", \"gnats\", \"haldaemon\", \"identd\", \"irc\", \"libuuid\", \"list\", \"lp\", \"mail\", \"man\",\n\t\t        \"messagebus\", \"news\", \"nobody\", \"ntp\", \"openslp\", \"pcp\", \"polkituser\", \"postfix\", \"proxy\",\n\t\t        \"pulse\", \"puppet\", \"root\", \"saned\", \"smmsp\", \"smmta\", \"sshd\", \"statd\", \"suse-ncc\", \"sync\",",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/258/ModulesUtilsBlImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/styler/258/ModulesUtilsBlImpl.java\nindex eaf48b2aa7f..d63383cd769 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/258/ModulesUtilsBlImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/styler/258/ModulesUtilsBlImpl.java\n@@ -77,8 +77,8 @@ public class ModulesUtilsBlImpl implements ModulesUtilsBl {\n \n \tpublic final static List<String> reservedNamesForUnixGroups = Arrays.asList(\"root\", \"daemon\", \"tty\", \"bin\", \"sys\", \"sudo\", \"nogroup\",\n \t          \"hadoop\", \"hdfs\", \"mapred\", \"yarn\", \"hsqldb\", \"derby\", \"jetty\", \"hbase\", \"zookeeper\", \"users\", \"oozie\", \"hive\");\n-\tpublic final static List<String> unpermittedNamesForUserLogins = Arrays.asList(\"arraysvcs\", \"at\", \"backup\", \"bin\", \"daemon\", \"Debian-exim\", \"flexlm\", \"ftp\", \"games\",\n-\t\t        \"gdm\", \"glite\", \"gnats\", \"haldaemon\", \"identd\", \"irc\", \"libuuid\", \"list\", \"lp\", \"mail\", \"man\",\n+\n+public final static List<String> unpermittedNamesForUserLogins = Arrays.asList(\"arraysvcs\", \"at\", \"backup\", \"bin\", \"daemon\", \"Debian-exim\", \"flexlm\", \"ftp\", \"games\", \"gdm\", \"glite\", \"gnats\", \"haldaemon\", \"identd\", \"irc\", \"libuuid\", \"list\", \"lp\", \"mail\", \"man\",\n \t\t        \"messagebus\", \"news\", \"nobody\", \"ntp\", \"openslp\", \"pcp\", \"polkituser\", \"postfix\", \"proxy\",\n \t\t        \"pulse\", \"puppet\", \"root\", \"saned\", \"smmsp\", \"smmta\", \"sshd\", \"statd\", \"suse-ncc\", \"sync\",\n \t\t        \"sys\", \"uucp\", \"uuidd\", \"www-data\", \"wwwrun\", \"zenssh\", \"tomcat6\", \"tomcat7\", \"tomcat8\",\n",
            "diff_size": 2
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/258/ModulesUtilsBlImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/intellij/258/ModulesUtilsBlImpl.java\nindex eaf48b2aa7f..077a3b347cf 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/258/ModulesUtilsBlImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/intellij/258/ModulesUtilsBlImpl.java\n@@ -51,1124 +51,1254 @@ import java.util.stream.Collectors;\n  */\n public class ModulesUtilsBlImpl implements ModulesUtilsBl {\n \n-\tfinal static Logger log = LoggerFactory.getLogger(ServicesManagerBlImpl.class);\n-\tprivate PerunBl perunBl;\n-\tMap<String,String> perunNamespaces = null;\n-\n-\tpublic static final String A_E_namespace_GIDRanges = AttributesManager.NS_ENTITYLESS_ATTR_DEF + \":namespace-GIDRanges\";\n-\tpublic static final String A_G_unixGID_namespace = AttributesManager.NS_GROUP_ATTR_DEF + \":unixGID-namespace\";\n-\tpublic static final String A_G_unixGroupName_namespace = AttributesManager.NS_GROUP_ATTR_DEF + \":unixGroupName-namespace\";\n-\tpublic static final String A_R_unixGID_namespace = AttributesManager.NS_RESOURCE_ATTR_DEF + \":unixGID-namespace\";\n-\tpublic static final String A_R_unixGroupName_namespace = AttributesManager.NS_RESOURCE_ATTR_DEF + \":unixGroupName-namespace\";\n-\tpublic static final String A_F_unixGID_namespace = AttributesManager.NS_FACILITY_ATTR_DEF + \":unixGID-namespace\";\n-\tpublic static final String A_F_unixGroupName_namespace = AttributesManager.NS_FACILITY_ATTR_DEF + \":unixGroupName-namespace\";\n-\tpublic static final String A_F_googleGroupsDomain = AttributesManager.NS_FACILITY_ATTR_DEF + \":googleGroupsDomain\";\n-\tprivate static final String A_E_usedGids = AttributesManager.NS_ENTITYLESS_ATTR_DEF + \":usedGids\";\n-\n-\t//Often used patterns\n-\tpublic static final Pattern quotaWithMetricsPattern = Pattern.compile(\"^([0-9]+([.][0-9]+)?[KMGTPE]?):([0-9]+([.][0-9]+)?[KMGTPE]?)$\");\n-\tpublic static final Pattern quotaWithoutMetricsPattern = Pattern.compile(\"^([0-9]+)(:)([0-9]+)$\");\n-\tpublic static final Pattern numberPattern = Pattern.compile(\"[0-9]+([.][0-9]+)?\");\n-\tpublic static final Pattern letterPattern = Pattern.compile(\"[A-Z]\");\n-\tpublic static final Pattern fqdnPattern = Pattern.compile(\"^((?!-)[a-zA-Z0-9-]{1,63}(?<!-)\\\\.)+[a-zA-Z]{2,63}\\\\.?$\");\n-\n-\t//previous regex ^/[-a-zA-Z0-9_/]*$\"\n-\tpublic static final Pattern shellPattern = Pattern.compile(\"^(/[-_a-zA-Z0-9]+)+$\");\n-\n-\tpublic final static List<String> reservedNamesForUnixGroups = Arrays.asList(\"root\", \"daemon\", \"tty\", \"bin\", \"sys\", \"sudo\", \"nogroup\",\n-\t          \"hadoop\", \"hdfs\", \"mapred\", \"yarn\", \"hsqldb\", \"derby\", \"jetty\", \"hbase\", \"zookeeper\", \"users\", \"oozie\", \"hive\");\n-\tpublic final static List<String> unpermittedNamesForUserLogins = Arrays.asList(\"arraysvcs\", \"at\", \"backup\", \"bin\", \"daemon\", \"Debian-exim\", \"flexlm\", \"ftp\", \"games\",\n-\t\t        \"gdm\", \"glite\", \"gnats\", \"haldaemon\", \"identd\", \"irc\", \"libuuid\", \"list\", \"lp\", \"mail\", \"man\",\n-\t\t        \"messagebus\", \"news\", \"nobody\", \"ntp\", \"openslp\", \"pcp\", \"polkituser\", \"postfix\", \"proxy\",\n-\t\t        \"pulse\", \"puppet\", \"root\", \"saned\", \"smmsp\", \"smmta\", \"sshd\", \"statd\", \"suse-ncc\", \"sync\",\n-\t\t        \"sys\", \"uucp\", \"uuidd\", \"www-data\", \"wwwrun\", \"zenssh\", \"tomcat6\", \"tomcat7\", \"tomcat8\",\n-\t\t        \"nn\", \"dn\", \"rm\", \"nm\", \"sn\", \"jn\", \"jhs\", \"http\", \"yarn\", \"hdfs\", \"mapred\", \"hadoop\", \"hsqldb\", \"derby\",\n-\t\t        \"jetty\", \"hbase\", \"zookeeper\", \"hive\", \"hue\", \"oozie\", \"httpfs\");\n-\n-\t//Definition of K = KB, M = MB etc.\n-\tpublic static final long M = 1024;\n-\tpublic static final long G = M * 1024;\n-\tpublic static final long T = G * 1024;\n-\tpublic static final long P = T * 1024;\n-\tpublic static final long E = P * 1024;\n-\n-\tpublic ModulesUtilsBlImpl() {\n-\t}\n-\n-\t@Override\n-\tpublic boolean isNamespaceEqualsToFacilityUnixGroupNameNamespace(PerunSessionImpl sess, Facility facility, String namespace) throws InternalErrorException, AttributeNotExistsException, WrongAttributeAssignmentException{\n-\t\tUtils.notNull(facility, \"facility\");\n-\t\tUtils.notNull(namespace, \"namespace\");\n-\t\tUtils.notNull(sess, \"perunSessionImpl\");\n-\t\tAttribute facilityNamespaceAttr = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, facility, A_F_unixGroupName_namespace + \":\" + namespace);\n-\t\tif(facilityNamespaceAttr.getValue() == null) return false;\n-\t\tif(!namespace.equals(facilityNamespaceAttr.getValue())) {\n-\t\t\treturn false;\n-\t\t}\n-\t\treturn true;\n-\t}\n-\n-\tpublic List<Resource> findCollisionResourcesWithSameGroupName(PerunSessionImpl sess, Resource resource, String namespace) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException {\n-\t\tUtils.notNull(sess, \"perunSessionImpl\");\n-\t\tUtils.notNull(resource, \"resource\");\n-\t\tAttribute resourceUnixGroupName = getPerunBl().getAttributesManagerBl().getAttribute(sess, resource, A_R_unixGroupName_namespace + \":\" + namespace);\n-\t\tList<Resource> resourcesWithSameUnixGroupName = getPerunBl().getResourcesManagerBl().getResourcesByAttribute(sess, resourceUnixGroupName);\n-\t\tresourcesWithSameUnixGroupName.remove(resource);\n-\t\treturn resourcesWithSameUnixGroupName;\n-\t}\n-\n-\tpublic List<Resource> findCollisionResourcesWithSameGroupName(PerunSessionImpl sess, Group group, String namespace) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException {\n-\t\tUtils.notNull(sess, \"perunSessionImpl\");\n-\t\tUtils.notNull(group, \"group\");\n-\t\tUtils.notNull(namespace, \"namespace\");\n-\t\tAttribute groupUnixGroupName = getPerunBl().getAttributesManagerBl().getAttribute(sess, group, A_G_unixGroupName_namespace + \":\" + namespace);\n-\t\tAttribute copyResourceUnixGroupName = new Attribute(getPerunBl().getAttributesManagerBl().getAttributeDefinition(sess, A_R_unixGroupName_namespace + \":\" + namespace));\n-\t\tcopyResourceUnixGroupName.setValue(groupUnixGroupName.getValue());\n-\t\treturn getPerunBl().getResourcesManagerBl().getResourcesByAttribute(sess, copyResourceUnixGroupName);\n-\t}\n-\n-\tpublic List<Group> findCollisionGroupsWithSamgeGroupName(PerunSessionImpl sess, Resource resource, String namespace) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException {\n-\t\tUtils.notNull(sess, \"perunSessionImpl\");\n-\t\tUtils.notNull(resource, \"resource\");\n-\t\tUtils.notNull(namespace, \"namespace\");\n-\t\tAttribute resourceUnixGroupName = getPerunBl().getAttributesManagerBl().getAttribute(sess, resource, A_R_unixGroupName_namespace + \":\" + namespace);\n-\t\tAttribute copyGroupUnixGroupName = new Attribute(getPerunBl().getAttributesManagerBl().getAttributeDefinition(sess, A_G_unixGroupName_namespace + \":\" + namespace));\n-\t\tcopyGroupUnixGroupName.setValue(resourceUnixGroupName.getValue());\n-\t\treturn getPerunBl().getGroupsManagerBl().getGroupsByAttribute(sess, copyGroupUnixGroupName);\n-\n-\t}\n-\n-\tpublic List<Group> findCollisionGroupsWithSamgeGroupName(PerunSessionImpl sess, Group group, String namespace) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException {\n-\t\tUtils.notNull(sess, \"perunSessionImpl\");\n-\t\tUtils.notNull(group, \"group\");\n-\t\tUtils.notNull(namespace, \"namespace\");\n-\t\tAttribute groupUnixGroupName = getPerunBl().getAttributesManagerBl().getAttribute(sess, group, A_G_unixGroupName_namespace + \":\" + namespace);\n-\t\tList<Group> groupsWithsameGroupName = getPerunBl().getGroupsManagerBl().getGroupsByAttribute(sess, groupUnixGroupName);\n-\t\tgroupsWithsameGroupName.remove(group);\n-\t\treturn groupsWithsameGroupName;\n-\t}\n-\n-\tpublic List<Resource> findCollisionResourcesWithSameGid(PerunSessionImpl sess, Resource resource, String namespace) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException {\n-\t\tUtils.notNull(sess, \"perunSessionImpl\");\n-\t\tUtils.notNull(resource, \"resource\");\n-\t\tUtils.notNull(namespace, \"namespace\");\n-\t\tAttribute resourceUnixGid = getPerunBl().getAttributesManagerBl().getAttribute(sess, resource, A_R_unixGID_namespace + \":\" + namespace);\n-\t\tList<Resource> resourcesWithSameGid = getPerunBl().getResourcesManagerBl().getResourcesByAttribute(sess, resourceUnixGid);\n-\t\tresourcesWithSameGid.remove(resource);\n-\t\treturn resourcesWithSameGid;\n-\t}\n-\n-\tpublic List<Resource> findCollisionResourcesWithSameGid(PerunSessionImpl sess, Group group, String namespace) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException {\n-\t\tUtils.notNull(sess, \"perunSessionImpl\");\n-\t\tUtils.notNull(group, \"group\");\n-\t\tUtils.notNull(namespace, \"namespace\");\n-\t\tAttribute groupUnixGid = getPerunBl().getAttributesManagerBl().getAttribute(sess, group, A_G_unixGID_namespace + \":\" + namespace);\n-\t\tAttribute copyResourceUnixGid = new Attribute(getPerunBl().getAttributesManagerBl().getAttributeDefinition(sess, A_R_unixGID_namespace + \":\" + namespace));\n-\t\tcopyResourceUnixGid.setValue(groupUnixGid.getValue());\n-\t\treturn getPerunBl().getResourcesManagerBl().getResourcesByAttribute(sess, copyResourceUnixGid);\n-\t}\n-\n-\tpublic List<Group> findCollisionGroupsWithSamgeGroupGid(PerunSessionImpl sess, Resource resource, String namespace) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException {\n-\t\tUtils.notNull(sess, \"perunSessionImpl\");\n-\t\tUtils.notNull(resource, \"resource\");\n-\t\tUtils.notNull(namespace, \"namespace\");\n-\t\tAttribute resourceUnixGid = getPerunBl().getAttributesManagerBl().getAttribute(sess, resource, A_R_unixGID_namespace + \":\" + namespace);\n-\t\tAttribute copyGroupUnixGid = new Attribute(getPerunBl().getAttributesManagerBl().getAttributeDefinition(sess, A_G_unixGID_namespace + \":\" + namespace));\n-\t\tcopyGroupUnixGid.setValue(resourceUnixGid.getValue());\n-\t\treturn getPerunBl().getGroupsManagerBl().getGroupsByAttribute(sess, copyGroupUnixGid);\n-\t}\n-\n-\tpublic List<Group> findCollisionGroupsWithSamgeGroupGid(PerunSessionImpl sess, Group group, String namespace) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException {\n-\t\tUtils.notNull(sess, \"perunSessionImpl\");\n-\t\tUtils.notNull(group, \"group\");\n-\t\tUtils.notNull(namespace, \"namespace\");\n-\t\tAttribute groupUnixGid = getPerunBl().getAttributesManagerBl().getAttribute(sess, group, A_G_unixGID_namespace + \":\" + namespace);\n-\t\tList<Group> groupsWithSameUnixGid = getPerunBl().getGroupsManagerBl().getGroupsByAttribute(sess, groupUnixGid);\n-\t\tgroupsWithSameUnixGid.remove(group);\n-\t\treturn groupsWithSameUnixGid;\n-\t}\n-\n-\tpublic boolean hasAccessToWriteToAttributeForAnyResource(PerunSessionImpl sess, AttributeDefinition attrDef, List<Resource> resources) throws InternalErrorException {\n-\t\tUtils.notNull(sess, \"perunSessionImpl\");\n-\t\tUtils.notNull(attrDef, \"attributeDefinition\");\n-\t\tif(resources == null || resources.isEmpty()) return false;\n-\t\tfor(Resource r: resources) {\n-\t\t\tif(AuthzResolver.isAuthorizedForAttribute(sess, ActionType.WRITE, attrDef , r)) return true;\n-\t\t}\n-\t\treturn false;\n-\t}\n-\n-\tpublic boolean hasAccessToWriteToAttributeForAnyGroup(PerunSessionImpl sess, AttributeDefinition attrDef, List<Group> groups) throws InternalErrorException {\n-\t\tUtils.notNull(sess, \"perunSessionImpl\");\n-\t\tUtils.notNull(attrDef, \"attributeDefinition\");\n-\t\tif(groups == null || groups.isEmpty()) return false;\n-\t\tfor(Group g: groups) {\n-\t\t\tif(AuthzResolver.isAuthorizedForAttribute(sess, ActionType.WRITE, attrDef, g)) return true;\n-\t\t}\n-\t\treturn false;\n-\t}\n-\n-\t/**\n-\t * Return true if gid is valid in ranges defined by Map of ranges, false otherwise.\n-\t * Keys in gidRanges map are minimums of one range and values are maximums.\n-\t * If minimum is same as maximum, such range has only one element.\n-\t *\n-\t * @param gidRanges map of gid ranges (keys = minimums, values = maximums)\n-\t * @param gid gid which need to be checked if it is in ranges\n-\t * @return\n-\t */\n-\tprivate boolean isGIDWithinRanges(Map<Integer,Integer> gidRanges, Integer gid) {\n-\t\tif(gid == null) return false;\n-\t\tif(gidRanges == null || gidRanges.isEmpty()) return false;\n-\n-\t\t//Test all valid ranges\n-\t\tfor(Integer minimum: gidRanges.keySet()) {\n-\t\t\tInteger maximum = gidRanges.get(minimum);\n-\t\t\t//Gid is in range, it is ok\n-\t\t\tif(gid >= minimum && gid <= maximum) return true;\n-\t\t}\n-\n-\t\treturn false;\n-\t}\n-\n-\t@Override\n-\tpublic void checkIfGIDIsWithinRange(PerunSessionImpl sess, Attribute attribute) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException, WrongAttributeValueException, WrongReferenceAttributeValueException {\n-\t\tUtils.notNull(attribute, \"attribute\");\n-\t\tInteger gid = null;\n-\t\tif(attribute.getValue() != null) gid = (Integer) attribute.getValue();\n-\n-\t\tif(gid == null) throw new WrongAttributeValueException(attribute, \"Gid with null value is not allowed.\");\n-\n-\t\tString gidNamespace = attribute.getFriendlyNameParameter();\n-\n-\t\tAttribute gidRangesAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, gidNamespace, A_E_namespace_GIDRanges);\n-\t\tMap<Integer, Integer> gidRanges = checkAndConvertGIDRanges(gidRangesAttribute);\n-\n-\t\t//Gid is not in range, throw exception\n-\t\tif(!isGIDWithinRanges(gidRanges, gid)) {\n-\t\t\tthrow new WrongReferenceAttributeValueException(attribute, gidRangesAttribute, null, null, gidNamespace, null, \"GID number is not in allowed ranges \" + gidRanges + \" for namespace \" + gidNamespace);\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void checkIfListOfGIDIsWithinRange(PerunSessionImpl sess, User user, Attribute attribute) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException, WrongAttributeValueException {\n-\t\tUtils.notNull(attribute, \"attribute\");\n-\t\tList<String> gidsToCheck = attribute.valueAsList();\n-\t\tif (gidsToCheck != null){\n-\t\t\tString gidNamespace = attribute.getFriendlyNameParameter();\n-\t\t\tAttribute gidRangesAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, gidNamespace, A_E_namespace_GIDRanges);\n-\t\t\tMap<Integer, Integer> gidRanges = checkAndConvertGIDRanges(gidRangesAttribute);\n-\n-\t\t\tfor(String gidToCheck : gidsToCheck){\n-\t\t\t\ttry{\n-\t\t\t\t\tInteger gid = new Integer(gidToCheck);\n-\n-\t\t\t\t\tif ( ! isGIDWithinRanges(gidRanges, gid) ) {\n-\t\t\t\t\t\tthrow new WrongAttributeValueException(attribute, \"GID number is not in allowed ranges \" + gidRanges + \" for namespace \" + gidNamespace);\n-\t\t\t\t\t}\n-\t\t\t\t}catch(NumberFormatException ex){\n-\t\t\t\t\tthrow new WrongAttributeValueException(attribute ,user,\"attribute is not a number\", ex);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic Integer getFreeGID(PerunSessionImpl sess, Attribute attribute) throws InternalErrorException, AttributeNotExistsException, WrongAttributeAssignmentException {\n-\t\tUtils.notNull(attribute, \"attribute\");\n-\t\tString gidNamespace = attribute.getFriendlyNameParameter();\n-\n-\t\tAttribute gidRangesAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, gidNamespace, A_E_namespace_GIDRanges);\n-\t\tif(gidRangesAttribute.getValue() == null) return 0;\n-\t\tMap<Integer, Integer> gidRanges;\n-\t\ttry {\n-\t\t\tgidRanges = checkAndConvertGIDRanges(gidRangesAttribute);\n-\t\t} catch (WrongAttributeValueException ex) {\n-\t\t\tthrow new InternalErrorException(\"Value in GID ranges attribute where we are looking for free gid is not in correct format \" + gidRangesAttribute, ex);\n-\t\t}\n-\t\tif(gidRanges.isEmpty()) return 0;\n-\t\tList<Integer> allMinimums = gidRanges.keySet().stream().sorted().collect(Collectors.toList());\n-\n-\t\tList<Integer> allGids = new ArrayList<>();\n-\t\tAttribute usedGids = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, gidNamespace, A_E_usedGids);\n-\n-\t\t//return the minimum from all ranges\n-\t\tif(usedGids.getValue() == null) return allMinimums.get(0);\n-\t\telse {\n-\t\t\tMap<String,String> usedGidsValue = usedGids.valueAsMap();\n-\t\t\tSet<String> keys = usedGidsValue.keySet();\n-\n-\t\t\tfor(String key: keys) {\n-\t\t\t\tallGids.add(Integer.parseInt(usedGidsValue.get(key)));\n-\t\t\t}\n-\t\t}\n-\n-\t\tfor(Integer minimum: allMinimums) {\n-\t\t\tInteger maximum = gidRanges.get(minimum);\n-\t\t\tfor (int i = minimum; i <= maximum; i++) {\n-\t\t\t\tif (!allGids.contains(i)) {\n-\t\t\t\t\treturn i;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn null;\n-\t}\n-\n-\t@Override\n-\tpublic Integer getCommonGIDOfGroupsWithSameNameInSameNamespace(PerunSessionImpl sess, List<Group> groupsWithSameGroupNameInSameNamespace, String gidNamespace, Integer commonGID) throws InternalErrorException, WrongAttributeAssignmentException {\n-\t\t//If there are no groups, return commonGID from param (it can be null)\n-\t\tif(groupsWithSameGroupNameInSameNamespace == null || groupsWithSameGroupNameInSameNamespace.isEmpty()) return commonGID;\n-\t\tUtils.notNull(gidNamespace, \"gidNamespace\");\n-\n-\t\tGroup commonGIDGroup = null;  //only for more verbose exception messages\n-\t\tfor(Group g: groupsWithSameGroupNameInSameNamespace) {\n-\t\t\ttry {\n-\t\t\t\tAttribute attr = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, g, A_G_unixGID_namespace + \":\" + gidNamespace);\n-\t\t\t\tif(attr.getValue() != null) {\n-\t\t\t\t\tif(commonGID == null) {\n-\t\t\t\t\t\tcommonGIDGroup = g;\n-\t\t\t\t\t\tcommonGID = (Integer) attr.getValue();\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tif(!commonGID.equals(attr.getValue())) throw new ConsistencyErrorException(\"There are at least 1 groups/resources with same GroupName in same namespace but with different GID in same namespaces. Conflict found: \"  + g + \"(gid=\" + attr.getValue()+ \") and \" + commonGIDGroup + \"(gid=\" + commonGID + \")\");\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t} catch (AttributeNotExistsException ex) {\n-\t\t\t\tthrow new ConsistencyErrorException(ex);\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn commonGID;\n-\t}\n-\n-\t@Override\n-\tpublic Integer getCommonGIDOfResourcesWithSameNameInSameNamespace(PerunSessionImpl sess, List<Resource> resourcesWithSameGroupNameInSameNamespace, String gidNamespace, Integer commonGID) throws InternalErrorException, WrongAttributeAssignmentException {\n-\t\t//If there are no resources, return commonGID from param (it can be null)\n-\t\tif(resourcesWithSameGroupNameInSameNamespace == null || resourcesWithSameGroupNameInSameNamespace.isEmpty()) return commonGID;\n-\t\tUtils.notNull(gidNamespace,\"gidNamespace\");\n-\n-\t\tResource commonGIDResource = null;   //only for more verbose exception messages\n-\t\tfor(Resource r: resourcesWithSameGroupNameInSameNamespace) {\n-\t\t\ttry {\n-\t\t\t\tAttribute attr = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, r, A_R_unixGID_namespace + \":\" + gidNamespace);\n-\t\t\t\tif(attr.getValue() != null) {\n-\t\t\t\t\tif(commonGID == null) {\n-\t\t\t\t\t\tcommonGIDResource = r;\n-\t\t\t\t\t\tcommonGID = (Integer) attr.getValue();\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tif(!commonGID.equals(attr.getValue())) throw new ConsistencyErrorException(\"There are at least 1 groups/resources with same GroupName in same namespace but with different GID in same namespaces. Conflict found: \" + r + \"(gid=\" + attr.getValue()+ \") and \" + commonGIDResource + \"(gid=\" + commonGID + \")\");\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t} catch (AttributeNotExistsException ex) {\n-\t\t\t\tthrow new ConsistencyErrorException(ex);\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn commonGID;\n-\t}\n-\n-\t@Override\n-\tpublic int haveTheSameAttributeWithTheSameNamespace(PerunSessionImpl sess, Group group, Attribute attr) throws InternalErrorException, WrongAttributeAssignmentException {\n-\t\tUtils.notNull(group, \"group\");\n-\t\tUtils.notNull(attr, \"attr\");\n-\n-\t\tString attributeNamespace = attr.getFriendlyNameParameter();\n-\t\tif(attributeNamespace == null || attributeNamespace.isEmpty()) throw new InternalErrorException(\"Attribute has no namespace, this method can't be use.\");\n-\n-\t\ttry {\n-\t\t\tAttribute testingAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, group, attr.getName());\n-\t\t\tif(testingAttribute.getValue() == null) return -1;\n-\t\t\telse {\n-\t\t\t\tif(!testingAttribute.getValue().equals(attr.getValue())) return 1;\n-\t\t\t}\n-\t\t} catch (AttributeNotExistsException ex) {\n-\t\t\tthrow new ConsistencyErrorException(ex);\n-\t\t}\n-\t\treturn 0;\n-\t}\n-\n-\t@Override\n-\tpublic int haveTheSameAttributeWithTheSameNamespace(PerunSessionImpl sess, Resource resource, Attribute attr) throws InternalErrorException, WrongAttributeAssignmentException{\n-\t\tUtils.notNull(resource, \"resource\");\n-\t\tUtils.notNull(attr, \"attr\");\n-\n-\t\tString attributeNamespace = attr.getFriendlyNameParameter();\n-\t\tif(attributeNamespace == null || attributeNamespace.isEmpty()) throw new InternalErrorException(\"Attribute has no namespace, this method can't be use.\");\n-\n-\t\ttry {\n-\t\t\tAttribute testingAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, resource, attr.getName());\n-\t\t\tif(testingAttribute.getValue() == null) return -1;\n-\t\t\telse {\n-\t\t\t\tif(!testingAttribute.getValue().equals(attr.getValue())) return 1;\n-\t\t\t}\n-\t\t} catch (AttributeNotExistsException ex) {\n-\t\t\tthrow new ConsistencyErrorException(ex);\n-\t\t}\n-\t\treturn 0;\n-\t}\n-\n-\t@Override\n-\tpublic boolean haveRightToWriteAttributeInAnyGroupOrResource(PerunSessionImpl sess, List<Group> groups, List<Resource> resources, AttributeDefinition groupAttribute, AttributeDefinition resourceAttribute) throws InternalErrorException {\n-\t\tif(groups != null && !groups.isEmpty() && groupAttribute != null) {\n-\t\t\tfor(Group g: groups) {\n-\t\t\t\tif(AuthzResolver.isAuthorizedForAttribute(sess, ActionType.WRITE, groupAttribute, g)) return true;\n-\t\t\t}\n-\t\t}\n-\n-\t\tif(resources != null && !resources.isEmpty() && resourceAttribute != null) {\n-\t\t\tfor(Resource r: resources) {\n-\t\t\t\tif(AuthzResolver.isAuthorizedForAttribute(sess, ActionType.WRITE, resourceAttribute, r)) return true;\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn false;\n-\t}\n-\n-\t@Override\n-\tpublic List<Attribute> getListOfResourceGIDsFromListOfGroupGIDs(PerunSessionImpl sess, List<Attribute> groupGIDs) throws InternalErrorException, AttributeNotExistsException {\n-\t\tList<Attribute> resourceGIDs = new ArrayList<>();\n-\t\tif(groupGIDs == null || groupGIDs.isEmpty()) {\n-\t\t\treturn resourceGIDs;\n-\t\t}\n-\n-\t\tfor(Attribute a: groupGIDs) {\n-\t\t\tAttribute resourceGID = new Attribute(sess.getPerunBl().getAttributesManagerBl().getAttributeDefinition(sess, A_R_unixGID_namespace + \":\" + a.getFriendlyNameParameter()));\n-\t\t\tresourceGID.setValue(a.getValue());\n-\t\t\tresourceGIDs.add(resourceGID);\n-\t\t}\n-\n-\t\treturn resourceGIDs;\n-\t}\n-\n-\t@Override\n-\tpublic List<Attribute> getListOfGroupGIDsFromListOfResourceGIDs(PerunSessionImpl sess, List<Attribute> resourceGIDs) throws InternalErrorException, AttributeNotExistsException {\n-\t\tList<Attribute> groupGIDs = new ArrayList<>();\n-\t\tif(resourceGIDs == null || resourceGIDs.isEmpty()) {\n-\t\t\treturn groupGIDs;\n-\t\t}\n-\n-\t\tfor(Attribute a: resourceGIDs) {\n-\t\t\tAttribute groupGID = new Attribute(sess.getPerunBl().getAttributesManagerBl().getAttributeDefinition(sess, A_G_unixGID_namespace + \":\" + a.getFriendlyNameParameter()));\n-\t\t\tgroupGID.setValue(a.getValue());\n-\t\t\tgroupGIDs.add(groupGID);\n-\t\t}\n-\n-\t\treturn groupGIDs;\n-\t}\n-\n-\t@Override\n-\tpublic Set<String> getSetOfGIDNamespacesWhereFacilitiesHasTheSameGroupNameNamespace(PerunSessionImpl sess, List<Facility> facilities, Attribute unixGroupNameNamespace) throws InternalErrorException, WrongAttributeAssignmentException {\n-\t\tSet<String> gidNamespaces = new HashSet<>();\n-\t\tif(facilities == null || facilities.isEmpty()) return gidNamespaces;\n-\t\tUtils.notNull(facilities, \"facilities\");\n-\n-\t\tfor(Facility f: facilities) {\n-\t\t\tAttribute facilityGroupNameNamespace;\n-\t\t\ttry {\n-\t\t\t\tfacilityGroupNameNamespace = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, f, A_F_unixGroupName_namespace);\n-\t\t\t\tif(facilityGroupNameNamespace.getValue() != null) {\n-\t\t\t\t\t//if they are same, save GID-namespace from this facility to hashSet\n-\t\t\t\t\tif(unixGroupNameNamespace.getFriendlyNameParameter().equals(facilityGroupNameNamespace.getValue())) {\n-\t\t\t\t\t\tAttribute facilityGIDNamespace = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, f, A_F_unixGID_namespace);\n-\t\t\t\t\t\t//If facilityGIDNamespace exists and is not null, save to the hashSet of gidNamespaces\n-\t\t\t\t\t\tif(facilityGIDNamespace.getValue() != null) {\n-\t\t\t\t\t\t\tgidNamespaces.add((String) facilityGIDNamespace.getValue());\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t} catch (AttributeNotExistsException ex) {\n-\t\t\t\tthrow new ConsistencyErrorException(ex);\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn gidNamespaces;\n-\t}\n-\n-\t@Override\n-\tpublic Set<String> getSetOfGroupNameNamespacesWhereFacilitiesHasTheSameGIDNamespace(PerunSessionImpl sess, List<Facility> facilities, Attribute unixGIDNamespace) throws InternalErrorException, WrongAttributeAssignmentException, WrongReferenceAttributeValueException {\n-\t\tSet<String> groupNameNamespaces = new HashSet<>();\n-\t\tif(facilities == null || facilities.isEmpty()) return groupNameNamespaces;\n-\t\tUtils.notNull(unixGIDNamespace, \"unixGIDNamespace\");\n-\n-\t\tfor(Facility f: facilities) {\n-\t\t\tAttribute facilityGIDNamespace;\n-\t\t\ttry {\n-\t\t\t\tfacilityGIDNamespace = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, f, A_F_unixGID_namespace);\n-\t\t\t\tif(facilityGIDNamespace.getValue() != null) {\n-\t\t\t\t\t//if they are same, save GroupName-namespace from this facility to hashSet\n-\t\t\t\t\tif(unixGIDNamespace.getFriendlyNameParameter().equals(facilityGIDNamespace.getValue())) {\n-\t\t\t\t\t\tAttribute facilityGroupNameNamespace = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, f, A_F_unixGroupName_namespace);\n-\t\t\t\t\t\t//If facilityGroupNameNamespace exists and is not null, save to the hashSet of gidNamespaces\n-\t\t\t\t\t\tif(facilityGroupNameNamespace.getValue() != null) {\n-\t\t\t\t\t\t\tgroupNameNamespaces.add((String) facilityGroupNameNamespace.getValue());\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tthrow new WrongReferenceAttributeValueException(unixGIDNamespace, facilityGroupNameNamespace, \"Facility has gidNamespace set, but groupNameNamespace not set.\");\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t} catch (AttributeNotExistsException ex) {\n-\t\t\t\tthrow new ConsistencyErrorException(ex);\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn groupNameNamespaces;\n-\t}\n-\n-\t@Override\n-\tpublic void checkReservedUnixGroupNames(Attribute groupNameAttribute) throws WrongAttributeValueException {\n-\t\tif(groupNameAttribute == null) return;\n-\t\tcheckPerunNamespacesMap();\n-\n-\t\tString reservedNames = perunNamespaces.get(groupNameAttribute.getFriendlyName() + \":reservedNames\");\n-\t\tif (reservedNames != null) {\n-\t\t\tList<String> reservedNamesList = Arrays.asList(reservedNames.split(\"\\\\s*,\\\\s*\"));\n-\t\t\tif (reservedNamesList.contains(groupNameAttribute.valueAsString()))\n-\t\t\t\tthrow new WrongAttributeValueException(groupNameAttribute, \"This groupName is reserved.\");\n-\t\t} else {\n-\t\t\t//Property not found in our attribute map, so we will use the default hardcoded values instead\n-\t\t\tif (reservedNamesForUnixGroups.contains(groupNameAttribute.valueAsString()))\n-\t\t\t\tthrow new WrongAttributeValueException(groupNameAttribute, \"This groupName is reserved.\");\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void checkUnpermittedUserLogins(Attribute loginAttribute) throws WrongAttributeValueException {\n-\t\tif(loginAttribute == null) return;\n-\t\tcheckPerunNamespacesMap();\n-\n-\t\tString unpermittedNames = perunNamespaces.get(loginAttribute.getFriendlyName() + \":reservedNames\");\n-\t\tif (unpermittedNames != null) {\n-\t\t\tList<String> unpermittedNamesList = Arrays.asList(unpermittedNames.split(\"\\\\s*,\\\\s*\"));\n-\t\t\tif (unpermittedNamesList.contains(loginAttribute.valueAsString()))\n-\t\t\t\tthrow new WrongAttributeValueException(loginAttribute, \"This login is not permitted.\");\n-\t\t} else {\n-\t\t\t//Property not found in our attribute map, so we will use the default hardcoded values instead\n-\t\t\tif (unpermittedNamesForUserLogins.contains(loginAttribute.valueAsString()))\n-\t\t\t\tthrow new WrongAttributeValueException(loginAttribute, \"This login is not permitted.\");\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic Attribute getGoogleGroupNameNamespaceAttributeWithNotNullValue(PerunSessionImpl sess, Resource resource) throws InternalErrorException, WrongReferenceAttributeValueException {\n-\t\tFacility facility = sess.getPerunBl().getResourcesManagerBl().getFacility(sess, resource);\n-\t\ttry {\n-\t\t\tAttribute googleGroupNameNamespaceAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, facility, A_F_googleGroupsDomain);\n-\t\t\tif(googleGroupNameNamespaceAttribute.getValue() == null) throw new WrongReferenceAttributeValueException(googleGroupNameNamespaceAttribute);\n-\t\t\treturn googleGroupNameNamespaceAttribute;\n-\t\t} catch(AttributeNotExistsException ex) {\n-\t\t\tthrow new ConsistencyErrorException(ex);\n-\t\t} catch(WrongAttributeAssignmentException ex) {\n-\t\t\tthrow new InternalErrorException(ex);\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic Attribute getUnixGroupNameNamespaceAttributeWithNotNullValue(PerunSessionImpl sess, Resource resource) throws InternalErrorException, WrongReferenceAttributeValueException {\n-\t\tFacility facility = sess.getPerunBl().getResourcesManagerBl().getFacility(sess, resource);\n-\t\ttry {\n-\t\t\tAttribute unixGroupNameNamespaceAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, facility, A_F_unixGroupName_namespace);\n-\t\t\tif(unixGroupNameNamespaceAttribute.getValue() == null) throw new WrongReferenceAttributeValueException(unixGroupNameNamespaceAttribute);\n-\t\t\treturn unixGroupNameNamespaceAttribute;\n-\t\t} catch(AttributeNotExistsException ex) {\n-\t\t\tthrow new ConsistencyErrorException(ex);\n-\t\t} catch(WrongAttributeAssignmentException ex) {\n-\t\t\tthrow new InternalErrorException(ex);\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic Attribute getUnixGIDNamespaceAttributeWithNotNullValue(PerunSessionImpl sess, Resource resource) throws InternalErrorException, WrongReferenceAttributeValueException {\n-\t\tFacility facility = sess.getPerunBl().getResourcesManagerBl().getFacility(sess, resource);\n-\t\ttry {\n-\t\t\tAttribute unixGIDNamespaceAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, facility, A_F_unixGID_namespace);\n-\t\t\tif(unixGIDNamespaceAttribute.getValue() == null) throw new WrongReferenceAttributeValueException(unixGIDNamespaceAttribute);\n-\t\t\treturn unixGIDNamespaceAttribute;\n-\t\t} catch(AttributeNotExistsException ex) {\n-\t\t\tthrow new ConsistencyErrorException(ex);\n-\t\t} catch(WrongAttributeAssignmentException ex) {\n-\t\t\tthrow new InternalErrorException(ex);\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic boolean isGroupUnixGIDNamespaceFillable(PerunSessionImpl sess, Group group, Attribute groupUnixGIDNamespace) throws InternalErrorException, WrongReferenceAttributeValueException, WrongAttributeAssignmentException {\n-\t\tUtils.notNull(group, \"group\");\n-\t\tUtils.notNull(groupUnixGIDNamespace, \"groupUnixGIDNamespace\");\n-\n-\t\t//Get All Facilities from group\n-\t\tSet<Facility> facilitiesOfGroup = new HashSet<>();\n-\t\tList<Resource> resourcesOfGroup = sess.getPerunBl().getResourcesManagerBl().getAssignedResources(sess, group);\n-\t\tfor(Resource r: resourcesOfGroup) {\n-\t\t\tfacilitiesOfGroup.add(sess.getPerunBl().getResourcesManagerBl().getFacility(sess, r));\n-\t\t}\n-\n-\t\t//Prepare list of gid namespaces of all facilities which have the same groupName namespace like this unixGroupName namespace\n-\t\tSet<String> groupNameNamespaces = this.getSetOfGroupNameNamespacesWhereFacilitiesHasTheSameGIDNamespace(sess, new ArrayList<>(facilitiesOfGroup), groupUnixGIDNamespace);\n-\n-\t\tif(!groupNameNamespaces.isEmpty()) {\n-\t\t\tfor(String s: groupNameNamespaces) {\n-\t\t\t\ttry {\n-\t\t\t\t\tAttribute groupNameNamespace = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, group, A_G_unixGroupName_namespace + \":\" + s);\n-\t\t\t\t\tif(groupNameNamespace.getValue() != null) {\n-\t\t\t\t\t\treturn true;\n-\t\t\t\t\t}\n-\t\t\t\t} catch (AttributeNotExistsException ex) {\n-\t\t\t\t\tthrow new ConsistencyErrorException(ex);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn false;\n-\t}\n-\n-\t@Override\n-\tpublic boolean isNameOfEmailValid(PerunSessionImpl sess, String email) {\n-\t\tif (email == null) return false;\n-\n-\t\tMatcher emailMatcher = Utils.emailPattern.matcher(email);\n-\t\treturn emailMatcher.find();\n-\t}\n-\n-\t@Override\n-\tpublic void checkFormatOfShell(String shell, Attribute attribute) throws WrongAttributeValueException {\n-\t\tMatcher match = shellPattern.matcher(shell);\n-\t\tif (!match.matches()) {\n-\t\t\tthrow new WrongAttributeValueException(attribute, \"Bad shell attribute format \" + shell);\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void checkAttributeRegex(Attribute attribute, Pattern defaultRegex) throws InternalErrorException, WrongAttributeValueException {\n-\t\tif (attribute == null || attribute.getValue() == null) throw new InternalErrorException(\"Attribute or it's value is null.\");\n-\t\tString attributeValue = (String) attribute.getValue();\n-\t\tcheckPerunNamespacesMap();\n-\n-\t\tString regex = perunNamespaces.get(attribute.getFriendlyName() + \":regex\");\n-\t\tif (regex != null) {\n-\t\t\t//Check if regex is valid\n-\t\t\ttry {\n-\t\t\t\tPattern.compile(regex);\n-\t\t\t} catch (PatternSyntaxException e) {\n-\t\t\t\tlog.error(\"Regex pattern \\\"\" + regex + \"\\\" from \\\"\" + attribute.getFriendlyName() + \":regex\\\"\" + \" property of perun-namespaces.properties file is invalid.\");\n-\t\t\t\tthrow new InternalErrorException(\"Regex pattern \\\"\" + regex + \"\\\" from \\\"\" + attribute.getFriendlyName() + \":regex\\\"\" + \" property of perun-namespaces.properties file is invalid.\");\n-\t\t\t}\n-\t\t\tif(!attributeValue.matches(regex)) {\n-\t\t\t\tthrow new WrongAttributeValueException(attribute, \"Wrong format. Regex: \\\"\" + regex +\"\\\" expected for this attribute:\");\n-\t\t\t}\n-\t\t} else {\n-\t\t\t//Regex property not found in our attribute map, so use the default hardcoded regex\n-\t\t\tif (!defaultRegex.matcher(attributeValue).matches()) {\n-\t\t\t\tthrow new WrongAttributeValueException(attribute, \"Wrong format. Regex: \\\"\" + defaultRegex +\"\\\" expected for this attribute:\");\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Internal protected method.\n-\t * Checks this.perunNamespaces map, which is always initialized as null.\n-\t * If null, it tries to load the configuration into this map from a perun-namespaces.properties file.\n-\t * If the file does not exist, it creates an empty HashMap, so it's not null anymore.\n-\t */\n-\tprotected void checkPerunNamespacesMap() {\n-\t\tif (perunNamespaces == null) {\n-\t\t\ttry {\n-\t\t\t\tperunNamespaces = BeansUtils.getAllPropertiesFromCustomConfiguration(\"perun-namespaces.properties\");\n-\t\t\t} catch (InternalErrorException e) {\n-\t\t\t\tperunNamespaces = new HashMap<>();\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void checkIfQuotasIsInLimit(Map<String, Pair<BigDecimal, BigDecimal>> quotaToCheck, Map<String, Pair<BigDecimal, BigDecimal>> limitQuota) throws InternalErrorException {\n-\t\tif(quotaToCheck == null) throw new InternalErrorException(\"Quota to check can't be null.\");\n-\t\tif(limitQuota == null) throw new InternalErrorException(\"Limit quota can't be null.\");\n-\n-\t\t//If there is no value to check, then everything is in limit (we don't need to limit anything)\n-\t\tif(quotaToCheck.isEmpty()) return;\n-\n-\t\t//test every record of quotaToCheck against record in limitQuota\n-\t\tfor(String volumeToCheck: quotaToCheck.keySet()) {\n-\t\t\tif(!limitQuota.containsKey(volumeToCheck)) {\n-\t\t\t\tthrow new QuotaNotInAllowedLimitException(quotaToCheck, limitQuota, \"Volume \" + volumeToCheck + \" is missing in limitQuota.\");\n-\t\t\t}\n-\n-\t\t\tPair<BigDecimal, BigDecimal> volumeToCheckQuotas = quotaToCheck.get(volumeToCheck);\n-\t\t\tPair<BigDecimal, BigDecimal> volumeToCheckLimitQuotas = limitQuota.get(volumeToCheck);\n-\n-\t\t\t//Check limit of softQuota, zero limit means unlimited so no need for testing\n-\t\t\tif(volumeToCheckLimitQuotas.getLeft().compareTo(BigDecimal.ZERO) != 0) {\n-\t\t\t\tif (volumeToCheckQuotas.getLeft().compareTo(BigDecimal.ZERO) == 0 || volumeToCheckQuotas.getLeft().compareTo(volumeToCheckLimitQuotas.getLeft()) > 0) {\n-\t\t\t\t\tthrow new QuotaNotInAllowedLimitException(quotaToCheck, limitQuota, \"SoftQuota of volume \" + volumeToCheck + \" is bigger than limit.\");\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t//Check limit of hardQuota, zero limit means unlimited so no need for testing\n-\t\t\tif(volumeToCheckLimitQuotas.getRight().compareTo(BigDecimal.ZERO) != 0) {\n-\t\t\t\tif (volumeToCheckQuotas.getRight().compareTo(BigDecimal.ZERO) == 0 || volumeToCheckQuotas.getRight().compareTo(volumeToCheckLimitQuotas.getRight()) > 0) {\n-\t\t\t\t\tthrow new QuotaNotInAllowedLimitException(quotaToCheck, limitQuota, \"HardQuota of volume \" + volumeToCheck + \" is bigger than limit.\");\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic Map<String, Pair<BigDecimal, BigDecimal>> checkAndTransferQuotas(Attribute quotasAttribute, PerunBean firstPlaceholder, PerunBean secondPlaceholder, boolean withMetrics) throws InternalErrorException, WrongAttributeValueException {\n-\t\t//firstPlaceholder can't be null\n-\t\tif(firstPlaceholder == null) throw new InternalErrorException(\"Missing first mandatory placeHolder (PerunBean).\");\n-\t\t//If quotas attribute is null or it's value is empty, return empty hash map\n-\t\tif(quotasAttribute == null || quotasAttribute.getValue() == null) return new LinkedHashMap<>();\n-\n-\t\t//Prepare result container and value of attribute\n-\t\tMap<String, Pair<BigDecimal, BigDecimal>> transferedQuotas = new LinkedHashMap<>();\n-\t\tMap<String, String> defaultQuotasMap = quotasAttribute.valueAsMap();\n-\n-\t\t//List to test if all paths are unique (/var/log and /var/log/ are the same so these two paths are not unique)\n-\t\tList<String> uniquePaths = new ArrayList<>();\n-\t\tfor(String path: defaultQuotasMap.keySet()) {\n-\t\t\t//null is not correct path for volume on File System\n-\t\t\tif(path == null || path.isEmpty()) throw new WrongAttributeValueException(quotasAttribute, firstPlaceholder, secondPlaceholder, \"The path of some volume where quota should be set is null.\");\n-\n-\t\t\t//testing if path is unique\n-\t\t\tString canonicalPath;\n-\t\t\ttry {\n-\t\t\t\tcanonicalPath = new URI(path).normalize().getPath();\n-\t\t\t\t//path should not end on '/' (problem with some systems as GPFS)\n-\t\t\t\tif(!canonicalPath.equals(\"/\") && canonicalPath.endsWith(\"/\")) canonicalPath = canonicalPath.substring(0, canonicalPath.length() - 1);\n-\t\t\t} catch (URISyntaxException ex) {\n-\t\t\t\tthrow new WrongAttributeValueException(quotasAttribute, firstPlaceholder, secondPlaceholder, \"Path '\" + path + \"' is not correct form.\");\n-\t\t\t}\n-\n-\t\t\tif(uniquePaths.contains(canonicalPath)) throw new WrongAttributeValueException(quotasAttribute, firstPlaceholder, secondPlaceholder, \"Paths are not unique, there are two same paths: \" + path);\n-\t\t\telse uniquePaths.add(canonicalPath);\n-\n-\t\t\tString quota = defaultQuotasMap.get(path);\n-\t\t\t//quota can't be null, if exists in attribute, must be set in some way\n-\t\t\tif(quota == null) throw new WrongAttributeValueException(quotasAttribute, firstPlaceholder, secondPlaceholder, \"The quota of some volume where quota should be set is null.\");\n-\n-\t\t\t//check format of quota parameter (for data with metrics, for count of files without metrics)\n-\t\t\tMatcher quotaMatcher;\n-\t\t\tif(withMetrics) {\n-\t\t\t\tquotaMatcher = ModulesUtilsBlImpl.quotaWithMetricsPattern.matcher(quota);\n-\t\t\t\tif(!quotaMatcher.matches()) throw new WrongAttributeValueException(quotasAttribute, firstPlaceholder, secondPlaceholder, \"Format of quota in quotas attribute is not correct.\");\n-\t\t\t} else {\n-\t\t\t\tquotaMatcher = ModulesUtilsBlImpl.quotaWithoutMetricsPattern.matcher(quota);\n-\t\t\t\tif(!quotaMatcher.matches()) throw new WrongAttributeValueException(quotasAttribute, firstPlaceholder, secondPlaceholder, \"Format of quota in quotas attribute is not correct.\");\n-\t\t\t}\n-\n-\t\t\t//Parse quotas to variables\n-\t\t\tString softQuota = quotaMatcher.group(1);\n-\t\t\tString hardQuota = quotaMatcher.group(3);\n-\n-\t\t\t//Parse number pattern and letter pattern from whole quotas\n-\n-\t\t\t//SoftQuotaNumber\n-\t\t\tBigDecimal softQuotaAfterTransfer;\n-\t\t\tBigDecimal hardQuotaAfterTransfer;\n-\t\t\t//special behavior with metrics\n-\t\t\tif(withMetrics) {\n-\t\t\t\tMatcher numberMatcher = numberPattern.matcher(softQuota);\n-\t\t\t\tif(!numberMatcher.find()) throw new ConsistencyErrorException(\"Matcher can't find number in softQuota '\" + softQuota + \"' in attribute \" + quotasAttribute);\n-\t\t\t\tString softQuotaNumber = numberMatcher.group();\n-\n-\t\t\t\t//SoftQuotaLetter\n-\t\t\t\tString softQuotaLetter;\n-\t\t\t\tMatcher letterMatcher = letterPattern.matcher(softQuota);\n-\t\t\t\t//in this case no letter means default and default is G\n-\t\t\t\tif(!letterMatcher.find()) softQuotaLetter = \"G\";\n-\t\t\t\telse softQuotaLetter = letterMatcher.group();\n-\n-\t\t\t\t//HardQuotaNumber\n-\t\t\t\tnumberMatcher = numberPattern.matcher(hardQuota);\n-\t\t\t\tif(!numberMatcher.find()) throw new ConsistencyErrorException(\"Matcher can't find number in hardQuota '\" + hardQuota + \"' in attribute \" + quotasAttribute);\n-\t\t\t\tString hardQuotaNumber = numberMatcher.group();\n-\n-\t\t\t\t//HardQuotaLetter\n-\t\t\t\tString hardQuotaLetter;\n-\t\t\t\tletterMatcher = letterPattern.matcher(hardQuota);\n-\t\t\t\t//in this case no letter means default and default is G\n-\t\t\t\tif(!letterMatcher.find()) hardQuotaLetter = \"G\";\n-\t\t\t\telse hardQuotaLetter = letterMatcher.group();\n-\n-\t\t\t\t//Prepare whole big decimal numbers\n-\t\t\t\tsoftQuotaAfterTransfer = new BigDecimal(softQuotaNumber);\n-\t\t\t\thardQuotaAfterTransfer = new BigDecimal(hardQuotaNumber);\n-\n-\t\t\t\t//multiplying for softQuota\n-\t\t\t\tswitch (softQuotaLetter) {\n-\t\t\t\t\tcase \"K\":\n-\t\t\t\t\t\tbreak; //K is basic metric, no need to multiply it\n-\t\t\t\t\tcase \"G\":\n-\t\t\t\t\t\tsoftQuotaAfterTransfer = softQuotaAfterTransfer.multiply(BigDecimal.valueOf(G));\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\tcase \"M\":\n-\t\t\t\t\t\tsoftQuotaAfterTransfer = softQuotaAfterTransfer.multiply(BigDecimal.valueOf(M));\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\tcase \"T\":\n-\t\t\t\t\t\tsoftQuotaAfterTransfer = softQuotaAfterTransfer.multiply(BigDecimal.valueOf(T));\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\tcase \"P\":\n-\t\t\t\t\t\tsoftQuotaAfterTransfer = softQuotaAfterTransfer.multiply(BigDecimal.valueOf(P));\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\tcase \"E\":\n-\t\t\t\t\t\tsoftQuotaAfterTransfer = softQuotaAfterTransfer.multiply(BigDecimal.valueOf(E));\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\tdefault:\n-\t\t\t\t\t\tthrow new ConsistencyErrorException(\"There is not allowed character in soft quota letter '\" + softQuotaLetter + \"'.\");\n-\t\t\t\t}\n-\n-\t\t\t\t//multiplying for softQuota\n-\t\t\t\tswitch (hardQuotaLetter) {\n-\t\t\t\t\tcase \"K\":\n-\t\t\t\t\t\tbreak; //K is basic metric, no need to multiply it\n-\t\t\t\t\tcase \"G\":\n-\t\t\t\t\t\thardQuotaAfterTransfer = hardQuotaAfterTransfer.multiply(BigDecimal.valueOf(G));\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\tcase \"M\":\n-\t\t\t\t\t\thardQuotaAfterTransfer = hardQuotaAfterTransfer.multiply(BigDecimal.valueOf(M));\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\tcase \"T\":\n-\t\t\t\t\t\thardQuotaAfterTransfer = hardQuotaAfterTransfer.multiply(BigDecimal.valueOf(T));\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\tcase \"P\":\n-\t\t\t\t\t\thardQuotaAfterTransfer = hardQuotaAfterTransfer.multiply(BigDecimal.valueOf(P));\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\tcase \"E\":\n-\t\t\t\t\t\thardQuotaAfterTransfer = hardQuotaAfterTransfer.multiply(BigDecimal.valueOf(E));\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\tdefault:\n-\t\t\t\t\t\tthrow new ConsistencyErrorException(\"There is not allowed character in hard quota letter '\" + hardQuotaLetter + \"'.\");\n-\t\t\t\t}\n-\t\t\t//easy way without metrics\n-\t\t\t} else {\n-\t\t\t\tsoftQuotaAfterTransfer = new BigDecimal(softQuota);\n-\t\t\t\thardQuotaAfterTransfer = new BigDecimal(hardQuota);\n-\t\t\t}\n-\n-\t\t\t//test comparing softQuota and hardQuota (softQuota must be less or equals than hardQuota, 0 means unlimited)\n-\t\t\t//1] if softQuota is unlimited, but hardQuota not = exception\n-\t\t\tif(softQuotaAfterTransfer.compareTo(BigDecimal.valueOf(0)) == 0 && hardQuotaAfterTransfer.compareTo(BigDecimal.valueOf(0)) != 0) {\n-\t\t\t\tthrow new WrongAttributeValueException(quotasAttribute, firstPlaceholder, secondPlaceholder, \"SoftQuota is set to unlimited (0) but hardQuota is limited to '\" + hardQuota + \"'.\");\n-\t\t\t//2] if hardQuota is not unlimited but still it is less then softQuota = exception\n-\t\t\t} else if(hardQuotaAfterTransfer.compareTo(BigDecimal.valueOf(0)) != 0 && hardQuotaAfterTransfer.compareTo(softQuotaAfterTransfer) < 0) {\n-\t\t\t\tthrow new WrongAttributeValueException(quotasAttribute, firstPlaceholder, secondPlaceholder, \"One of quotas is not correct. HardQuota '\" + hardQuota + \"' is less then softQuota '\" + softQuota + \"'.\");\n-\t\t\t}\n-\t\t\t//other cases are ok\n-\n-\t\t\ttransferedQuotas.put(canonicalPath, new Pair<>(softQuotaAfterTransfer, hardQuotaAfterTransfer));\n-\t\t}\n-\n-\t\treturn transferedQuotas;\n-\t}\n-\n-\t@Override\n-\tpublic Map<String, String> transferQuotasBackToAttributeValue(Map<String, Pair<BigDecimal, BigDecimal>> transferedQuotasMap, boolean withMetrics) throws InternalErrorException {\n-\t\tMap<String, String> attributeQuotasValue = new LinkedHashMap<>();\n-\t\t//if null or empty, return empty attribute value map for quotas\n-\t\tif(transferedQuotasMap == null || transferedQuotasMap.isEmpty()) return attributeQuotasValue;\n-\n-\t\t//every path with quotas transfer step by step\n-\t\tfor(String path: transferedQuotasMap.keySet()) {\n-\t\t\tPair<BigDecimal, BigDecimal> quotas =  transferedQuotasMap.get(path);\n-\t\t\tBigDecimal softQuotaBD = quotas.getLeft();\n-\t\t\tBigDecimal hardQuotaBD = quotas.getRight();\n-\n-\t\t\t//Divide decimal till it is still natural number\n-\t\t\t//Soft Quota\n-\t\t\tString softQuota = \"0\";\n-\t\t\t//Zero means unlimited, stay the same\n-\t\t\tif(softQuotaBD.compareTo(BigDecimal.ZERO) != 0) {\n-\t\t\t\tif(withMetrics) softQuota = Utils.bigDecimalBytesToReadableStringWithMetric(softQuotaBD);\n-\t\t\t\telse softQuota = softQuotaBD.toPlainString();\n-\t\t\t}\n-\t\t\t//Hard Quota\n-\t\t\tString hardQuota = \"0\";\n-\t\t\t//Zero means unlimited, stay the same\n-\t\t\tif(hardQuotaBD.compareTo(BigDecimal.ZERO) != 0) {\n-\t\t\t\tif(withMetrics) hardQuota = Utils.bigDecimalBytesToReadableStringWithMetric(hardQuotaBD);\n-\t\t\t\telse hardQuota = hardQuotaBD.toPlainString();\n-\t\t\t}\n-\n-\t\t\t//add softQuota and hardQuota to result (50T:60T)\n-\t\t\tattributeQuotasValue.put(path, softQuota + \":\" + hardQuota);\n-\t\t}\n-\t\treturn attributeQuotasValue;\n-\t}\n-\n-\t@Override\n-\tpublic Map<String,Pair<BigDecimal, BigDecimal>> mergeMemberAndResourceTransferredQuotas(Map<String, Pair<BigDecimal, BigDecimal>> resourceQuotas, Map<String, Pair<BigDecimal, BigDecimal>> memberResourceQuotas, Map<String, Pair<BigDecimal, BigDecimal>> quotasOverride) {\n-\t\tMap<String,Pair<BigDecimal, BigDecimal>> mergedTransferedQuotas = new LinkedHashMap<>();\n-\n-\t\t//first go through member-resource quotas values\n-\t\tfor(String path: memberResourceQuotas.keySet()) {\n-\t\t\t//override has the highest priority\n-\t\t\tif (quotasOverride.containsKey(path)) {\n-\t\t\t\tmergedTransferedQuotas.put(path, quotasOverride.get(path));\n-\t\t\t} else {\n-\t\t\t\t//if override not exists, take the original value\n-\t\t\t\tmergedTransferedQuotas.put(path, memberResourceQuotas.get(path));\n-\t\t\t}\n-\t\t}\n-\n-\t\t//save unique values from resource quotas (not exists in member-resource quotas)\n-\t\tfor(String path: resourceQuotas.keySet()) {\n-\t\t\t//skip already saved values, they are not unique\n-\t\t\tif(mergedTransferedQuotas.containsKey(path)) continue;\n-\n-\t\t\t//take override if exists\n-\t\t\tif(quotasOverride.containsKey(path)) {\n-\t\t\t\tmergedTransferedQuotas.put(path, quotasOverride.get(path));\n-\t\t\t} else {\n-\t\t\t\tmergedTransferedQuotas.put(path, resourceQuotas.get(path));\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn mergedTransferedQuotas;\n-\t}\n-\n-\t@Override\n-\tpublic Map<String, Pair<BigDecimal, BigDecimal>> countUserFacilityQuotas(List<Map<String, Pair<BigDecimal, BigDecimal>>> allUserQuotas) {\n-\t\tMap<String, Pair<BigDecimal, BigDecimal>> resultTransferredQuotas = new LinkedHashMap<>();\n-\t\t//for every transfered map of merged quotas count one result transfered map\n-\t\tfor(Map<String, Pair<BigDecimal, BigDecimal>> mapValue : allUserQuotas) {\n-\t\t\t//for every path in one transfered map\n-\t\t\tfor(String pathKey: mapValue.keySet()) {\n-\t\t\t\t//if path not exists in result map, add it with it's values\n-\t\t\t\tif(!resultTransferredQuotas.containsKey(pathKey)) {\n-\t\t\t\t\tresultTransferredQuotas.put(pathKey, mapValue.get(pathKey));\n-\t\t\t\t//if path already exists in result map, sum their quotas together\n-\t\t\t\t} else {\n-\t\t\t\t\tPair<BigDecimal, BigDecimal> quotasValue1 = resultTransferredQuotas.get(pathKey);\n-\t\t\t\t\tPair<BigDecimal, BigDecimal> quotasValue2 = mapValue.get(pathKey);\n-\t\t\t\t\t//for soft quota (left part of pair)\n-\t\t\t\t\tBigDecimal softQuota = BigDecimal.ZERO;\n-\t\t\t\t\tif(quotasValue1.getLeft().compareTo(BigDecimal.ZERO) != 0 && quotasValue2.getLeft().compareTo(BigDecimal.ZERO) != 0) {\n-\t\t\t\t\t\tsoftQuota = quotasValue1.getLeft().add(quotasValue2.getLeft());\n-\t\t\t\t\t}\n-\t\t\t\t\t//for hard quota (right part of pair)\n-\t\t\t\t\tBigDecimal hardQuota = BigDecimal.ZERO;\n-\t\t\t\t\tif(quotasValue1.getRight().compareTo(BigDecimal.ZERO) != 0 && quotasValue2.getRight().compareTo(BigDecimal.ZERO) != 0) {\n-\t\t\t\t\t\thardQuota = quotasValue1.getRight().add(quotasValue2.getRight());\n-\t\t\t\t\t}\n-\t\t\t\t\t//create new pair of summed numbers\n-\t\t\t\t\tPair<BigDecimal, BigDecimal> finalQuotasValue = new Pair<>(softQuota, hardQuota);\n-\t\t\t\t\t//add new summed pair to the result map\n-\t\t\t\t\tresultTransferredQuotas.put(pathKey, finalQuotasValue);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\t//return result map\n-\t\treturn resultTransferredQuotas;\n-\t}\n-\n-\t@Override\n-\tpublic boolean isFQDNValid(PerunSessionImpl sess, String fqdn) {\n-\t\tif (fqdn == null) return false;\n-\t\tMatcher fqdnMatcher = fqdnPattern.matcher(fqdn);\n-\t\treturn fqdnMatcher.find();\n-\t}\n-\n-\t/**\n-\t * Normalize string for purpose of generating safe login value.\n-\t *\n-\t * @return normalized string\n-\t */\n-\tpublic static String normalizeStringForLogin(String toBeNormalized) {\n-\n-\t\tif (toBeNormalized == null || toBeNormalized.trim().isEmpty()) return null;\n-\n-\t\ttoBeNormalized = toBeNormalized.toLowerCase();\n-\t\ttoBeNormalized = java.text.Normalizer.normalize(toBeNormalized, java.text.Normalizer.Form.NFD).replaceAll(\"\\\\p{InCombiningDiacriticalMarks}+\",\"\");\n-\t\ttoBeNormalized = toBeNormalized.replaceAll(\"[^a-zA-Z]+\", \"\");\n-\n-\t\t// unable to fill login for users without name or with partial name\n-\t\tif (toBeNormalized.isEmpty()) {\n-\t\t\treturn null;\n-\t\t}\n-\n-\t\treturn toBeNormalized;\n-\n-\t}\n-\n-\t/**\n-\t * Shared logic for purpose of login generation\n-\t */\n-\tpublic static class LoginGenerator {\n-\n-\t\t/**\n-\t\t * Define joining function for anonymous classes\n-\t\t */\n-\t\tpublic interface LoginGeneratorFunction {\n-\n-\t\t\t/**\n-\t\t\t * Generate login for user using his name.\n-\t\t\t * Implementation must handle empty/null input on both fields.\n-\t\t\t *\n-\t\t\t * @param firstName\n-\t\t\t * @param lastName\n-\t\t\t * @return generated login\n-\t\t\t */\n-\t\t\tString generateLogin(String firstName, String lastName);\n-\n-\t\t}\n-\n-\t\t/**\n-\t\t * Generate login for user using his name and joining function\n-\t\t *\n-\t\t * @param user User to get data from\n-\t\t * @param function Function to join fist/lastName to login\n-\t\t * @return generated login\n-\t\t */\n-\t\tpublic String generateLogin(User user, LoginGeneratorFunction function) {\n-\n-\t\t\tString firstName = user.getFirstName();\n-\t\t\tString lastName = user.getLastName();\n-\n-\t\t\t// get only first part of first name and remove spec. chars\n-\t\t\tif (firstName != null && !firstName.isEmpty()) {\n-\t\t\t\tfirstName = ModulesUtilsBlImpl.normalizeStringForLogin(firstName.split(\" \")[0]);\n-\t\t\t}\n-\n-\t\t\t// get only last part of last name and remove spec. chars\n-\t\t\tif (lastName != null && !lastName.isEmpty()) {\n-\t\t\t\tList<String> names = Arrays.asList(lastName.split(\" \"));\n-\t\t\t\tlastName = names.get(names.size() - 1);\n-\t\t\t\tlastName = ModulesUtilsBlImpl.normalizeStringForLogin(lastName.split(\" \")[0]);\n-\t\t\t}\n-\n-\t\t\treturn function.generateLogin(firstName, lastName);\n-\n-\t\t}\n-\n-\t}\n-\n-\t@Override\n-\tpublic User getUserFromMessage(PerunSessionImpl sess, String message) throws InternalErrorException {\n-\t\tList<PerunBean> perunBeans = AuditParser.parseLog(message);\n-\n-\t\tUser user = null;\n-\t\tUserExtSource userExtSource = null;\n-\t\tMember member = null;\n-\n-\t\tfor(PerunBean perunBean: perunBeans) {\n-\t\t\tif(perunBean instanceof User) {\n-\t\t\t\tuser = (User) perunBean;\n-\t\t\t\tbreak;\n-\t\t\t} else if (perunBean instanceof UserExtSource && userExtSource == null) {\n-\t\t\t\tuserExtSource = (UserExtSource) perunBean;\n-\t\t\t} else if (perunBean instanceof Member && member == null) {\n-\t\t\t\tmember = (Member) perunBean;\n-\t\t\t}\n-\t\t}\n-\n-\t\t//if we don't have object user, try to parse user id from userExtSource (-1 means no userId was defined)\n-\t\tif(user == null && userExtSource != null && userExtSource.getUserId() != -1) {\n-\t\t\ttry {\n-\t\t\t\tuser = getPerunBl().getUsersManagerBl().getUserById(sess, userExtSource.getUserId());\n-\t\t\t} catch (UserNotExistsException ex) {\n-\t\t\t\tlog.warn(\"User from UserExtSource {} doesn't exist in Perun. This occurred while parsing message: {}.\", userExtSource, message);\n-\t\t\t\treturn null;\n-\t\t\t}\n-\t\t} else if (user == null && member != null) {\n-\t\t\ttry {\n-\t\t\t\tuser = getPerunBl().getUsersManagerBl().getUserById(sess, member.getUserId());\n-\t\t\t} catch (UserNotExistsException ex) {\n-\t\t\t\tlog.warn(\"User from Member {} doesn't exist in Perun. This occurred while parsing message: {}.\", member, message);\n-\t\t\t\treturn null;\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn user;\n-\t}\n-\n-\t@Override\n-\tpublic Map<Integer, Integer> checkAndConvertGIDRanges(Attribute gidRangesAttribute) throws InternalErrorException, WrongAttributeValueException {\n-\t\t//Prepare structure for better working with GID Ranges\n-\t\tMap<Integer, Integer> convertedRanges = new HashMap<>();\n-\n-\t\t//For null attribute throw an exception\n-\t\tif(gidRangesAttribute == null) throw new InternalErrorException(\"Can't get value from null attribute!\");\n-\n-\t\tMap<String, String> gidRanges = gidRangesAttribute.valueAsMap();\n-\n-\t\t//Return empty map if there is empty input of gidRanges in method parameters\n-\t\tif(gidRanges == null || gidRanges.isEmpty()) return convertedRanges;\n-\n-\t\t//Check every range if it is in correct format and it is valid range\n-\t\tfor(String minimumOfRange: gidRanges.keySet()) {\n-\t\t\t//Check not null\n-\t\t\tif(minimumOfRange == null || minimumOfRange.isEmpty()) throw new WrongAttributeValueException(gidRangesAttribute, \"Minimum in one of gid ranges is empty!\");\n-\t\t\tString maximumOfRange = gidRanges.get(minimumOfRange);\n-\t\t\tif(maximumOfRange == null || maximumOfRange.isEmpty()) throw new WrongAttributeValueException(gidRangesAttribute, \"Maximum in one of gid ranges is empty!\");\n-\n-\t\t\t//Transfer string to numbers\n-\t\t\tInteger minimum;\n-\t\t\tInteger maximum;\n-\n-\t\t\ttry {\n-\t\t\t\tminimum = Integer.valueOf(minimumOfRange);\n-\t\t\t\tmaximum = Integer.valueOf(maximumOfRange);\n-\t\t\t} catch (NumberFormatException ex) {\n-\t\t\t\tthrow new WrongAttributeValueException(gidRangesAttribute, \"Min or max value of some range is not correct number format.\");\n-\t\t\t}\n-\n-\t\t\t//Check if min value from range is bigger than 0\n-\t\t\tif(minimum < 1) throw new WrongAttributeValueException(gidRangesAttribute, \"Minimum of one of gid ranges is less than 0.\");\n-\n-\t\t\t//Check if it is correct range\n-\t\t\tif(minimum>maximum) throw new WrongAttributeValueException(gidRangesAttribute, \"One of gid ranges is not correct range. Minimum of this range is bigger then it's maximum.\");\n-\n-\t\t\t//Put this valid range to the map of correct gid ranges\n-\t\t\tconvertedRanges.put(minimum, maximum);\n-\t\t}\n-\n-\t\t//Check gid ranges overlaps (there should be no overlaps)\n-\t\tInteger lastMaxValue = 0;\n-\t\tfor(Integer minValue: convertedRanges.keySet().stream().sorted().collect(Collectors.toList())) {\n-\t\t\tif(minValue <= lastMaxValue) throw new WrongAttributeValueException(gidRangesAttribute, \"There is an overlap between two gid ranges.\");\n-\t\t\tlastMaxValue = convertedRanges.get(minValue);\n-\t\t}\n-\n-\t\treturn convertedRanges;\n-\t}\n-\n-\t/**\n-\t * Returns pair of number (BigDecimal) and unit (String) from given string. Returns default value Pair<0, \"G\"> if parsing fails.\n-\t * E.g.: \"5T\" -> Pair<5, \"T\">\n-\t *\n-\t * @param attributeValue string to parse\n-\t * @return pair of number and unit\n-\t */\n-\tpublic static Pair<BigDecimal, String> getNumberAndUnitFromString(String attributeValue) {\n-\t\tString numberString = \"0\";\n-\t\tString unit = \"G\";\n-\n-\t\tif (attributeValue != null) {\n-\t\t\tMatcher numberMatcher = numberPattern.matcher(attributeValue);\n-\t\t\tMatcher letterMatcher = letterPattern.matcher(attributeValue);\n-\t\t\tnumberMatcher.find();\n-\t\t\tletterMatcher.find();\n-\t\t\ttry {\n-\t\t\t\tnumberString = attributeValue.substring(numberMatcher.start(), numberMatcher.end());\n-\t\t\t} catch (IllegalStateException ex) {\n-\t\t\t\tlog.debug(\"No number could be parsed from given string.\", ex);\n-\t\t\t}\n-\t\t\ttry {\n-\t\t\t\tunit = attributeValue.substring(letterMatcher.start(), letterMatcher.end());\n-\t\t\t} catch (IllegalStateException ex) {\n-\t\t\t\tlog.debug(\"No unit could be parsed from given string.\", ex);\n-\t\t\t}\n-\t\t}\n-\n-\t\tBigDecimal number = new BigDecimal(numberString.replace(',', '.'));\n-\n-\t\treturn new Pair<>(number, unit);\n-\t}\n-\n-\tpublic PerunBl getPerunBl() {\n-\t\treturn this.perunBl;\n-\t}\n-\n-\tpublic void setPerunBl(PerunBl perunBl) {\n-\t\tthis.perunBl = perunBl;\n-\t}\n+    final static Logger log = LoggerFactory.getLogger(ServicesManagerBlImpl.class);\n+    private PerunBl perunBl;\n+    Map<String, String> perunNamespaces = null;\n+\n+    public static final String A_E_namespace_GIDRanges = AttributesManager.NS_ENTITYLESS_ATTR_DEF + \":namespace-GIDRanges\";\n+    public static final String A_G_unixGID_namespace = AttributesManager.NS_GROUP_ATTR_DEF + \":unixGID-namespace\";\n+    public static final String A_G_unixGroupName_namespace = AttributesManager.NS_GROUP_ATTR_DEF + \":unixGroupName-namespace\";\n+    public static final String A_R_unixGID_namespace = AttributesManager.NS_RESOURCE_ATTR_DEF + \":unixGID-namespace\";\n+    public static final String A_R_unixGroupName_namespace = AttributesManager.NS_RESOURCE_ATTR_DEF + \":unixGroupName-namespace\";\n+    public static final String A_F_unixGID_namespace = AttributesManager.NS_FACILITY_ATTR_DEF + \":unixGID-namespace\";\n+    public static final String A_F_unixGroupName_namespace = AttributesManager.NS_FACILITY_ATTR_DEF + \":unixGroupName-namespace\";\n+    public static final String A_F_googleGroupsDomain = AttributesManager.NS_FACILITY_ATTR_DEF + \":googleGroupsDomain\";\n+    private static final String A_E_usedGids = AttributesManager.NS_ENTITYLESS_ATTR_DEF + \":usedGids\";\n+\n+    //Often used patterns\n+    public static final Pattern quotaWithMetricsPattern = Pattern.compile(\"^([0-9]+([.][0-9]+)?[KMGTPE]?):([0-9]+([.][0-9]+)?[KMGTPE]?)$\");\n+    public static final Pattern quotaWithoutMetricsPattern = Pattern.compile(\"^([0-9]+)(:)([0-9]+)$\");\n+    public static final Pattern numberPattern = Pattern.compile(\"[0-9]+([.][0-9]+)?\");\n+    public static final Pattern letterPattern = Pattern.compile(\"[A-Z]\");\n+    public static final Pattern fqdnPattern = Pattern.compile(\"^((?!-)[a-zA-Z0-9-]{1,63}(?<!-)\\\\.)+[a-zA-Z]{2,63}\\\\.?$\");\n+\n+    //previous regex ^/[-a-zA-Z0-9_/]*$\"\n+    public static final Pattern shellPattern = Pattern.compile(\"^(/[-_a-zA-Z0-9]+)+$\");\n+\n+    public final static List<String> reservedNamesForUnixGroups = Arrays.asList(\"root\", \"daemon\", \"tty\", \"bin\", \"sys\", \"sudo\", \"nogroup\",\n+            \"hadoop\", \"hdfs\", \"mapred\", \"yarn\", \"hsqldb\", \"derby\", \"jetty\", \"hbase\", \"zookeeper\", \"users\", \"oozie\", \"hive\");\n+    public final static List<String> unpermittedNamesForUserLogins = Arrays.asList(\"arraysvcs\", \"at\", \"backup\", \"bin\", \"daemon\", \"Debian-exim\", \"flexlm\", \"ftp\", \"games\",\n+            \"gdm\", \"glite\", \"gnats\", \"haldaemon\", \"identd\", \"irc\", \"libuuid\", \"list\", \"lp\", \"mail\", \"man\",\n+            \"messagebus\", \"news\", \"nobody\", \"ntp\", \"openslp\", \"pcp\", \"polkituser\", \"postfix\", \"proxy\",\n+            \"pulse\", \"puppet\", \"root\", \"saned\", \"smmsp\", \"smmta\", \"sshd\", \"statd\", \"suse-ncc\", \"sync\",\n+            \"sys\", \"uucp\", \"uuidd\", \"www-data\", \"wwwrun\", \"zenssh\", \"tomcat6\", \"tomcat7\", \"tomcat8\",\n+            \"nn\", \"dn\", \"rm\", \"nm\", \"sn\", \"jn\", \"jhs\", \"http\", \"yarn\", \"hdfs\", \"mapred\", \"hadoop\", \"hsqldb\", \"derby\",\n+            \"jetty\", \"hbase\", \"zookeeper\", \"hive\", \"hue\", \"oozie\", \"httpfs\");\n+\n+    //Definition of K = KB, M = MB etc.\n+    public static final long M = 1024;\n+    public static final long G = M * 1024;\n+    public static final long T = G * 1024;\n+    public static final long P = T * 1024;\n+    public static final long E = P * 1024;\n+\n+    public ModulesUtilsBlImpl() {\n+    }\n+\n+    @Override\n+    public boolean isNamespaceEqualsToFacilityUnixGroupNameNamespace(PerunSessionImpl sess, Facility facility, String namespace) throws InternalErrorException, AttributeNotExistsException, WrongAttributeAssignmentException {\n+        Utils.notNull(facility, \"facility\");\n+        Utils.notNull(namespace, \"namespace\");\n+        Utils.notNull(sess, \"perunSessionImpl\");\n+        Attribute facilityNamespaceAttr = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, facility, A_F_unixGroupName_namespace + \":\" + namespace);\n+        if (facilityNamespaceAttr.getValue() == null) {\n+            return false;\n+        }\n+        if (!namespace.equals(facilityNamespaceAttr.getValue())) {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    public List<Resource> findCollisionResourcesWithSameGroupName(PerunSessionImpl sess, Resource resource, String namespace) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException {\n+        Utils.notNull(sess, \"perunSessionImpl\");\n+        Utils.notNull(resource, \"resource\");\n+        Attribute resourceUnixGroupName = getPerunBl().getAttributesManagerBl().getAttribute(sess, resource, A_R_unixGroupName_namespace + \":\" + namespace);\n+        List<Resource> resourcesWithSameUnixGroupName = getPerunBl().getResourcesManagerBl().getResourcesByAttribute(sess, resourceUnixGroupName);\n+        resourcesWithSameUnixGroupName.remove(resource);\n+        return resourcesWithSameUnixGroupName;\n+    }\n+\n+    public List<Resource> findCollisionResourcesWithSameGroupName(PerunSessionImpl sess, Group group, String namespace) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException {\n+        Utils.notNull(sess, \"perunSessionImpl\");\n+        Utils.notNull(group, \"group\");\n+        Utils.notNull(namespace, \"namespace\");\n+        Attribute groupUnixGroupName = getPerunBl().getAttributesManagerBl().getAttribute(sess, group, A_G_unixGroupName_namespace + \":\" + namespace);\n+        Attribute copyResourceUnixGroupName = new Attribute(getPerunBl().getAttributesManagerBl().getAttributeDefinition(sess, A_R_unixGroupName_namespace + \":\" + namespace));\n+        copyResourceUnixGroupName.setValue(groupUnixGroupName.getValue());\n+        return getPerunBl().getResourcesManagerBl().getResourcesByAttribute(sess, copyResourceUnixGroupName);\n+    }\n+\n+    public List<Group> findCollisionGroupsWithSamgeGroupName(PerunSessionImpl sess, Resource resource, String namespace) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException {\n+        Utils.notNull(sess, \"perunSessionImpl\");\n+        Utils.notNull(resource, \"resource\");\n+        Utils.notNull(namespace, \"namespace\");\n+        Attribute resourceUnixGroupName = getPerunBl().getAttributesManagerBl().getAttribute(sess, resource, A_R_unixGroupName_namespace + \":\" + namespace);\n+        Attribute copyGroupUnixGroupName = new Attribute(getPerunBl().getAttributesManagerBl().getAttributeDefinition(sess, A_G_unixGroupName_namespace + \":\" + namespace));\n+        copyGroupUnixGroupName.setValue(resourceUnixGroupName.getValue());\n+        return getPerunBl().getGroupsManagerBl().getGroupsByAttribute(sess, copyGroupUnixGroupName);\n+\n+    }\n+\n+    public List<Group> findCollisionGroupsWithSamgeGroupName(PerunSessionImpl sess, Group group, String namespace) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException {\n+        Utils.notNull(sess, \"perunSessionImpl\");\n+        Utils.notNull(group, \"group\");\n+        Utils.notNull(namespace, \"namespace\");\n+        Attribute groupUnixGroupName = getPerunBl().getAttributesManagerBl().getAttribute(sess, group, A_G_unixGroupName_namespace + \":\" + namespace);\n+        List<Group> groupsWithsameGroupName = getPerunBl().getGroupsManagerBl().getGroupsByAttribute(sess, groupUnixGroupName);\n+        groupsWithsameGroupName.remove(group);\n+        return groupsWithsameGroupName;\n+    }\n+\n+    public List<Resource> findCollisionResourcesWithSameGid(PerunSessionImpl sess, Resource resource, String namespace) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException {\n+        Utils.notNull(sess, \"perunSessionImpl\");\n+        Utils.notNull(resource, \"resource\");\n+        Utils.notNull(namespace, \"namespace\");\n+        Attribute resourceUnixGid = getPerunBl().getAttributesManagerBl().getAttribute(sess, resource, A_R_unixGID_namespace + \":\" + namespace);\n+        List<Resource> resourcesWithSameGid = getPerunBl().getResourcesManagerBl().getResourcesByAttribute(sess, resourceUnixGid);\n+        resourcesWithSameGid.remove(resource);\n+        return resourcesWithSameGid;\n+    }\n+\n+    public List<Resource> findCollisionResourcesWithSameGid(PerunSessionImpl sess, Group group, String namespace) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException {\n+        Utils.notNull(sess, \"perunSessionImpl\");\n+        Utils.notNull(group, \"group\");\n+        Utils.notNull(namespace, \"namespace\");\n+        Attribute groupUnixGid = getPerunBl().getAttributesManagerBl().getAttribute(sess, group, A_G_unixGID_namespace + \":\" + namespace);\n+        Attribute copyResourceUnixGid = new Attribute(getPerunBl().getAttributesManagerBl().getAttributeDefinition(sess, A_R_unixGID_namespace + \":\" + namespace));\n+        copyResourceUnixGid.setValue(groupUnixGid.getValue());\n+        return getPerunBl().getResourcesManagerBl().getResourcesByAttribute(sess, copyResourceUnixGid);\n+    }\n+\n+    public List<Group> findCollisionGroupsWithSamgeGroupGid(PerunSessionImpl sess, Resource resource, String namespace) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException {\n+        Utils.notNull(sess, \"perunSessionImpl\");\n+        Utils.notNull(resource, \"resource\");\n+        Utils.notNull(namespace, \"namespace\");\n+        Attribute resourceUnixGid = getPerunBl().getAttributesManagerBl().getAttribute(sess, resource, A_R_unixGID_namespace + \":\" + namespace);\n+        Attribute copyGroupUnixGid = new Attribute(getPerunBl().getAttributesManagerBl().getAttributeDefinition(sess, A_G_unixGID_namespace + \":\" + namespace));\n+        copyGroupUnixGid.setValue(resourceUnixGid.getValue());\n+        return getPerunBl().getGroupsManagerBl().getGroupsByAttribute(sess, copyGroupUnixGid);\n+    }\n+\n+    public List<Group> findCollisionGroupsWithSamgeGroupGid(PerunSessionImpl sess, Group group, String namespace) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException {\n+        Utils.notNull(sess, \"perunSessionImpl\");\n+        Utils.notNull(group, \"group\");\n+        Utils.notNull(namespace, \"namespace\");\n+        Attribute groupUnixGid = getPerunBl().getAttributesManagerBl().getAttribute(sess, group, A_G_unixGID_namespace + \":\" + namespace);\n+        List<Group> groupsWithSameUnixGid = getPerunBl().getGroupsManagerBl().getGroupsByAttribute(sess, groupUnixGid);\n+        groupsWithSameUnixGid.remove(group);\n+        return groupsWithSameUnixGid;\n+    }\n+\n+    public boolean hasAccessToWriteToAttributeForAnyResource(PerunSessionImpl sess, AttributeDefinition attrDef, List<Resource> resources) throws InternalErrorException {\n+        Utils.notNull(sess, \"perunSessionImpl\");\n+        Utils.notNull(attrDef, \"attributeDefinition\");\n+        if (resources == null || resources.isEmpty()) {\n+            return false;\n+        }\n+        for (Resource r : resources) {\n+            if (AuthzResolver.isAuthorizedForAttribute(sess, ActionType.WRITE, attrDef, r)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public boolean hasAccessToWriteToAttributeForAnyGroup(PerunSessionImpl sess, AttributeDefinition attrDef, List<Group> groups) throws InternalErrorException {\n+        Utils.notNull(sess, \"perunSessionImpl\");\n+        Utils.notNull(attrDef, \"attributeDefinition\");\n+        if (groups == null || groups.isEmpty()) {\n+            return false;\n+        }\n+        for (Group g : groups) {\n+            if (AuthzResolver.isAuthorizedForAttribute(sess, ActionType.WRITE, attrDef, g)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Return true if gid is valid in ranges defined by Map of ranges, false otherwise.\n+     * Keys in gidRanges map are minimums of one range and values are maximums.\n+     * If minimum is same as maximum, such range has only one element.\n+     *\n+     * @param gidRanges map of gid ranges (keys = minimums, values = maximums)\n+     * @param gid       gid which need to be checked if it is in ranges\n+     * @return\n+     */\n+    private boolean isGIDWithinRanges(Map<Integer, Integer> gidRanges, Integer gid) {\n+        if (gid == null) {\n+            return false;\n+        }\n+        if (gidRanges == null || gidRanges.isEmpty()) {\n+            return false;\n+        }\n+\n+        //Test all valid ranges\n+        for (Integer minimum : gidRanges.keySet()) {\n+            Integer maximum = gidRanges.get(minimum);\n+            //Gid is in range, it is ok\n+            if (gid >= minimum && gid <= maximum) {\n+                return true;\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    @Override\n+    public void checkIfGIDIsWithinRange(PerunSessionImpl sess, Attribute attribute) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException, WrongAttributeValueException, WrongReferenceAttributeValueException {\n+        Utils.notNull(attribute, \"attribute\");\n+        Integer gid = null;\n+        if (attribute.getValue() != null) {\n+            gid = (Integer) attribute.getValue();\n+        }\n+\n+        if (gid == null) {\n+            throw new WrongAttributeValueException(attribute, \"Gid with null value is not allowed.\");\n+        }\n+\n+        String gidNamespace = attribute.getFriendlyNameParameter();\n+\n+        Attribute gidRangesAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, gidNamespace, A_E_namespace_GIDRanges);\n+        Map<Integer, Integer> gidRanges = checkAndConvertGIDRanges(gidRangesAttribute);\n+\n+        //Gid is not in range, throw exception\n+        if (!isGIDWithinRanges(gidRanges, gid)) {\n+            throw new WrongReferenceAttributeValueException(attribute, gidRangesAttribute, null, null, gidNamespace, null, \"GID number is not in allowed ranges \" + gidRanges + \" for namespace \" + gidNamespace);\n+        }\n+    }\n+\n+    @Override\n+    public void checkIfListOfGIDIsWithinRange(PerunSessionImpl sess, User user, Attribute attribute) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException, WrongAttributeValueException {\n+        Utils.notNull(attribute, \"attribute\");\n+        List<String> gidsToCheck = attribute.valueAsList();\n+        if (gidsToCheck != null) {\n+            String gidNamespace = attribute.getFriendlyNameParameter();\n+            Attribute gidRangesAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, gidNamespace, A_E_namespace_GIDRanges);\n+            Map<Integer, Integer> gidRanges = checkAndConvertGIDRanges(gidRangesAttribute);\n+\n+            for (String gidToCheck : gidsToCheck) {\n+                try {\n+                    Integer gid = new Integer(gidToCheck);\n+\n+                    if (!isGIDWithinRanges(gidRanges, gid)) {\n+                        throw new WrongAttributeValueException(attribute, \"GID number is not in allowed ranges \" + gidRanges + \" for namespace \" + gidNamespace);\n+                    }\n+                } catch (NumberFormatException ex) {\n+                    throw new WrongAttributeValueException(attribute, user, \"attribute is not a number\", ex);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public Integer getFreeGID(PerunSessionImpl sess, Attribute attribute) throws InternalErrorException, AttributeNotExistsException, WrongAttributeAssignmentException {\n+        Utils.notNull(attribute, \"attribute\");\n+        String gidNamespace = attribute.getFriendlyNameParameter();\n+\n+        Attribute gidRangesAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, gidNamespace, A_E_namespace_GIDRanges);\n+        if (gidRangesAttribute.getValue() == null) {\n+            return 0;\n+        }\n+        Map<Integer, Integer> gidRanges;\n+        try {\n+            gidRanges = checkAndConvertGIDRanges(gidRangesAttribute);\n+        } catch (WrongAttributeValueException ex) {\n+            throw new InternalErrorException(\"Value in GID ranges attribute where we are looking for free gid is not in correct format \" + gidRangesAttribute, ex);\n+        }\n+        if (gidRanges.isEmpty()) {\n+            return 0;\n+        }\n+        List<Integer> allMinimums = gidRanges.keySet().stream().sorted().collect(Collectors.toList());\n+\n+        List<Integer> allGids = new ArrayList<>();\n+        Attribute usedGids = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, gidNamespace, A_E_usedGids);\n+\n+        //return the minimum from all ranges\n+        if (usedGids.getValue() == null) {\n+            return allMinimums.get(0);\n+        } else {\n+            Map<String, String> usedGidsValue = usedGids.valueAsMap();\n+            Set<String> keys = usedGidsValue.keySet();\n+\n+            for (String key : keys) {\n+                allGids.add(Integer.parseInt(usedGidsValue.get(key)));\n+            }\n+        }\n+\n+        for (Integer minimum : allMinimums) {\n+            Integer maximum = gidRanges.get(minimum);\n+            for (int i = minimum; i <= maximum; i++) {\n+                if (!allGids.contains(i)) {\n+                    return i;\n+                }\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Integer getCommonGIDOfGroupsWithSameNameInSameNamespace(PerunSessionImpl sess, List<Group> groupsWithSameGroupNameInSameNamespace, String gidNamespace, Integer commonGID) throws InternalErrorException, WrongAttributeAssignmentException {\n+        //If there are no groups, return commonGID from param (it can be null)\n+        if (groupsWithSameGroupNameInSameNamespace == null || groupsWithSameGroupNameInSameNamespace.isEmpty()) {\n+            return commonGID;\n+        }\n+        Utils.notNull(gidNamespace, \"gidNamespace\");\n+\n+        Group commonGIDGroup = null;  //only for more verbose exception messages\n+        for (Group g : groupsWithSameGroupNameInSameNamespace) {\n+            try {\n+                Attribute attr = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, g, A_G_unixGID_namespace + \":\" + gidNamespace);\n+                if (attr.getValue() != null) {\n+                    if (commonGID == null) {\n+                        commonGIDGroup = g;\n+                        commonGID = (Integer) attr.getValue();\n+                    } else {\n+                        if (!commonGID.equals(attr.getValue())) {\n+                            throw new ConsistencyErrorException(\"There are at least 1 groups/resources with same GroupName in same namespace but with different GID in same namespaces. Conflict found: \" + g + \"(gid=\" + attr.getValue() + \") and \" + commonGIDGroup + \"(gid=\" + commonGID + \")\");\n+                        }\n+                    }\n+                }\n+            } catch (AttributeNotExistsException ex) {\n+                throw new ConsistencyErrorException(ex);\n+            }\n+        }\n+\n+        return commonGID;\n+    }\n+\n+    @Override\n+    public Integer getCommonGIDOfResourcesWithSameNameInSameNamespace(PerunSessionImpl sess, List<Resource> resourcesWithSameGroupNameInSameNamespace, String gidNamespace, Integer commonGID) throws InternalErrorException, WrongAttributeAssignmentException {\n+        //If there are no resources, return commonGID from param (it can be null)\n+        if (resourcesWithSameGroupNameInSameNamespace == null || resourcesWithSameGroupNameInSameNamespace.isEmpty()) {\n+            return commonGID;\n+        }\n+        Utils.notNull(gidNamespace, \"gidNamespace\");\n+\n+        Resource commonGIDResource = null;   //only for more verbose exception messages\n+        for (Resource r : resourcesWithSameGroupNameInSameNamespace) {\n+            try {\n+                Attribute attr = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, r, A_R_unixGID_namespace + \":\" + gidNamespace);\n+                if (attr.getValue() != null) {\n+                    if (commonGID == null) {\n+                        commonGIDResource = r;\n+                        commonGID = (Integer) attr.getValue();\n+                    } else {\n+                        if (!commonGID.equals(attr.getValue())) {\n+                            throw new ConsistencyErrorException(\"There are at least 1 groups/resources with same GroupName in same namespace but with different GID in same namespaces. Conflict found: \" + r + \"(gid=\" + attr.getValue() + \") and \" + commonGIDResource + \"(gid=\" + commonGID + \")\");\n+                        }\n+                    }\n+                }\n+            } catch (AttributeNotExistsException ex) {\n+                throw new ConsistencyErrorException(ex);\n+            }\n+        }\n+\n+        return commonGID;\n+    }\n+\n+    @Override\n+    public int haveTheSameAttributeWithTheSameNamespace(PerunSessionImpl sess, Group group, Attribute attr) throws InternalErrorException, WrongAttributeAssignmentException {\n+        Utils.notNull(group, \"group\");\n+        Utils.notNull(attr, \"attr\");\n+\n+        String attributeNamespace = attr.getFriendlyNameParameter();\n+        if (attributeNamespace == null || attributeNamespace.isEmpty()) {\n+            throw new InternalErrorException(\"Attribute has no namespace, this method can't be use.\");\n+        }\n+\n+        try {\n+            Attribute testingAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, group, attr.getName());\n+            if (testingAttribute.getValue() == null) {\n+                return -1;\n+            } else {\n+                if (!testingAttribute.getValue().equals(attr.getValue())) {\n+                    return 1;\n+                }\n+            }\n+        } catch (AttributeNotExistsException ex) {\n+            throw new ConsistencyErrorException(ex);\n+        }\n+        return 0;\n+    }\n+\n+    @Override\n+    public int haveTheSameAttributeWithTheSameNamespace(PerunSessionImpl sess, Resource resource, Attribute attr) throws InternalErrorException, WrongAttributeAssignmentException {\n+        Utils.notNull(resource, \"resource\");\n+        Utils.notNull(attr, \"attr\");\n+\n+        String attributeNamespace = attr.getFriendlyNameParameter();\n+        if (attributeNamespace == null || attributeNamespace.isEmpty()) {\n+            throw new InternalErrorException(\"Attribute has no namespace, this method can't be use.\");\n+        }\n+\n+        try {\n+            Attribute testingAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, resource, attr.getName());\n+            if (testingAttribute.getValue() == null) {\n+                return -1;\n+            } else {\n+                if (!testingAttribute.getValue().equals(attr.getValue())) {\n+                    return 1;\n+                }\n+            }\n+        } catch (AttributeNotExistsException ex) {\n+            throw new ConsistencyErrorException(ex);\n+        }\n+        return 0;\n+    }\n+\n+    @Override\n+    public boolean haveRightToWriteAttributeInAnyGroupOrResource(PerunSessionImpl sess, List<Group> groups, List<Resource> resources, AttributeDefinition groupAttribute, AttributeDefinition resourceAttribute) throws InternalErrorException {\n+        if (groups != null && !groups.isEmpty() && groupAttribute != null) {\n+            for (Group g : groups) {\n+                if (AuthzResolver.isAuthorizedForAttribute(sess, ActionType.WRITE, groupAttribute, g)) {\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        if (resources != null && !resources.isEmpty() && resourceAttribute != null) {\n+            for (Resource r : resources) {\n+                if (AuthzResolver.isAuthorizedForAttribute(sess, ActionType.WRITE, resourceAttribute, r)) {\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    @Override\n+    public List<Attribute> getListOfResourceGIDsFromListOfGroupGIDs(PerunSessionImpl sess, List<Attribute> groupGIDs) throws InternalErrorException, AttributeNotExistsException {\n+        List<Attribute> resourceGIDs = new ArrayList<>();\n+        if (groupGIDs == null || groupGIDs.isEmpty()) {\n+            return resourceGIDs;\n+        }\n+\n+        for (Attribute a : groupGIDs) {\n+            Attribute resourceGID = new Attribute(sess.getPerunBl().getAttributesManagerBl().getAttributeDefinition(sess, A_R_unixGID_namespace + \":\" + a.getFriendlyNameParameter()));\n+            resourceGID.setValue(a.getValue());\n+            resourceGIDs.add(resourceGID);\n+        }\n+\n+        return resourceGIDs;\n+    }\n+\n+    @Override\n+    public List<Attribute> getListOfGroupGIDsFromListOfResourceGIDs(PerunSessionImpl sess, List<Attribute> resourceGIDs) throws InternalErrorException, AttributeNotExistsException {\n+        List<Attribute> groupGIDs = new ArrayList<>();\n+        if (resourceGIDs == null || resourceGIDs.isEmpty()) {\n+            return groupGIDs;\n+        }\n+\n+        for (Attribute a : resourceGIDs) {\n+            Attribute groupGID = new Attribute(sess.getPerunBl().getAttributesManagerBl().getAttributeDefinition(sess, A_G_unixGID_namespace + \":\" + a.getFriendlyNameParameter()));\n+            groupGID.setValue(a.getValue());\n+            groupGIDs.add(groupGID);\n+        }\n+\n+        return groupGIDs;\n+    }\n+\n+    @Override\n+    public Set<String> getSetOfGIDNamespacesWhereFacilitiesHasTheSameGroupNameNamespace(PerunSessionImpl sess, List<Facility> facilities, Attribute unixGroupNameNamespace) throws InternalErrorException, WrongAttributeAssignmentException {\n+        Set<String> gidNamespaces = new HashSet<>();\n+        if (facilities == null || facilities.isEmpty()) {\n+            return gidNamespaces;\n+        }\n+        Utils.notNull(facilities, \"facilities\");\n+\n+        for (Facility f : facilities) {\n+            Attribute facilityGroupNameNamespace;\n+            try {\n+                facilityGroupNameNamespace = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, f, A_F_unixGroupName_namespace);\n+                if (facilityGroupNameNamespace.getValue() != null) {\n+                    //if they are same, save GID-namespace from this facility to hashSet\n+                    if (unixGroupNameNamespace.getFriendlyNameParameter().equals(facilityGroupNameNamespace.getValue())) {\n+                        Attribute facilityGIDNamespace = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, f, A_F_unixGID_namespace);\n+                        //If facilityGIDNamespace exists and is not null, save to the hashSet of gidNamespaces\n+                        if (facilityGIDNamespace.getValue() != null) {\n+                            gidNamespaces.add((String) facilityGIDNamespace.getValue());\n+                        }\n+                    }\n+                }\n+            } catch (AttributeNotExistsException ex) {\n+                throw new ConsistencyErrorException(ex);\n+            }\n+        }\n+\n+        return gidNamespaces;\n+    }\n+\n+    @Override\n+    public Set<String> getSetOfGroupNameNamespacesWhereFacilitiesHasTheSameGIDNamespace(PerunSessionImpl sess, List<Facility> facilities, Attribute unixGIDNamespace) throws InternalErrorException, WrongAttributeAssignmentException, WrongReferenceAttributeValueException {\n+        Set<String> groupNameNamespaces = new HashSet<>();\n+        if (facilities == null || facilities.isEmpty()) {\n+            return groupNameNamespaces;\n+        }\n+        Utils.notNull(unixGIDNamespace, \"unixGIDNamespace\");\n+\n+        for (Facility f : facilities) {\n+            Attribute facilityGIDNamespace;\n+            try {\n+                facilityGIDNamespace = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, f, A_F_unixGID_namespace);\n+                if (facilityGIDNamespace.getValue() != null) {\n+                    //if they are same, save GroupName-namespace from this facility to hashSet\n+                    if (unixGIDNamespace.getFriendlyNameParameter().equals(facilityGIDNamespace.getValue())) {\n+                        Attribute facilityGroupNameNamespace = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, f, A_F_unixGroupName_namespace);\n+                        //If facilityGroupNameNamespace exists and is not null, save to the hashSet of gidNamespaces\n+                        if (facilityGroupNameNamespace.getValue() != null) {\n+                            groupNameNamespaces.add((String) facilityGroupNameNamespace.getValue());\n+                        } else {\n+                            throw new WrongReferenceAttributeValueException(unixGIDNamespace, facilityGroupNameNamespace, \"Facility has gidNamespace set, but groupNameNamespace not set.\");\n+                        }\n+                    }\n+                }\n+            } catch (AttributeNotExistsException ex) {\n+                throw new ConsistencyErrorException(ex);\n+            }\n+        }\n+\n+        return groupNameNamespaces;\n+    }\n+\n+    @Override\n+    public void checkReservedUnixGroupNames(Attribute groupNameAttribute) throws WrongAttributeValueException {\n+        if (groupNameAttribute == null) {\n+            return;\n+        }\n+        checkPerunNamespacesMap();\n+\n+        String reservedNames = perunNamespaces.get(groupNameAttribute.getFriendlyName() + \":reservedNames\");\n+        if (reservedNames != null) {\n+            List<String> reservedNamesList = Arrays.asList(reservedNames.split(\"\\\\s*,\\\\s*\"));\n+            if (reservedNamesList.contains(groupNameAttribute.valueAsString())) {\n+                throw new WrongAttributeValueException(groupNameAttribute, \"This groupName is reserved.\");\n+            }\n+        } else {\n+            //Property not found in our attribute map, so we will use the default hardcoded values instead\n+            if (reservedNamesForUnixGroups.contains(groupNameAttribute.valueAsString())) {\n+                throw new WrongAttributeValueException(groupNameAttribute, \"This groupName is reserved.\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void checkUnpermittedUserLogins(Attribute loginAttribute) throws WrongAttributeValueException {\n+        if (loginAttribute == null) {\n+            return;\n+        }\n+        checkPerunNamespacesMap();\n+\n+        String unpermittedNames = perunNamespaces.get(loginAttribute.getFriendlyName() + \":reservedNames\");\n+        if (unpermittedNames != null) {\n+            List<String> unpermittedNamesList = Arrays.asList(unpermittedNames.split(\"\\\\s*,\\\\s*\"));\n+            if (unpermittedNamesList.contains(loginAttribute.valueAsString())) {\n+                throw new WrongAttributeValueException(loginAttribute, \"This login is not permitted.\");\n+            }\n+        } else {\n+            //Property not found in our attribute map, so we will use the default hardcoded values instead\n+            if (unpermittedNamesForUserLogins.contains(loginAttribute.valueAsString())) {\n+                throw new WrongAttributeValueException(loginAttribute, \"This login is not permitted.\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public Attribute getGoogleGroupNameNamespaceAttributeWithNotNullValue(PerunSessionImpl sess, Resource resource) throws InternalErrorException, WrongReferenceAttributeValueException {\n+        Facility facility = sess.getPerunBl().getResourcesManagerBl().getFacility(sess, resource);\n+        try {\n+            Attribute googleGroupNameNamespaceAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, facility, A_F_googleGroupsDomain);\n+            if (googleGroupNameNamespaceAttribute.getValue() == null) {\n+                throw new WrongReferenceAttributeValueException(googleGroupNameNamespaceAttribute);\n+            }\n+            return googleGroupNameNamespaceAttribute;\n+        } catch (AttributeNotExistsException ex) {\n+            throw new ConsistencyErrorException(ex);\n+        } catch (WrongAttributeAssignmentException ex) {\n+            throw new InternalErrorException(ex);\n+        }\n+    }\n+\n+    @Override\n+    public Attribute getUnixGroupNameNamespaceAttributeWithNotNullValue(PerunSessionImpl sess, Resource resource) throws InternalErrorException, WrongReferenceAttributeValueException {\n+        Facility facility = sess.getPerunBl().getResourcesManagerBl().getFacility(sess, resource);\n+        try {\n+            Attribute unixGroupNameNamespaceAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, facility, A_F_unixGroupName_namespace);\n+            if (unixGroupNameNamespaceAttribute.getValue() == null) {\n+                throw new WrongReferenceAttributeValueException(unixGroupNameNamespaceAttribute);\n+            }\n+            return unixGroupNameNamespaceAttribute;\n+        } catch (AttributeNotExistsException ex) {\n+            throw new ConsistencyErrorException(ex);\n+        } catch (WrongAttributeAssignmentException ex) {\n+            throw new InternalErrorException(ex);\n+        }\n+    }\n+\n+    @Override\n+    public Attribute getUnixGIDNamespaceAttributeWithNotNullValue(PerunSessionImpl sess, Resource resource) throws InternalErrorException, WrongReferenceAttributeValueException {\n+        Facility facility = sess.getPerunBl().getResourcesManagerBl().getFacility(sess, resource);\n+        try {\n+            Attribute unixGIDNamespaceAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, facility, A_F_unixGID_namespace);\n+            if (unixGIDNamespaceAttribute.getValue() == null) {\n+                throw new WrongReferenceAttributeValueException(unixGIDNamespaceAttribute);\n+            }\n+            return unixGIDNamespaceAttribute;\n+        } catch (AttributeNotExistsException ex) {\n+            throw new ConsistencyErrorException(ex);\n+        } catch (WrongAttributeAssignmentException ex) {\n+            throw new InternalErrorException(ex);\n+        }\n+    }\n+\n+    @Override\n+    public boolean isGroupUnixGIDNamespaceFillable(PerunSessionImpl sess, Group group, Attribute groupUnixGIDNamespace) throws InternalErrorException, WrongReferenceAttributeValueException, WrongAttributeAssignmentException {\n+        Utils.notNull(group, \"group\");\n+        Utils.notNull(groupUnixGIDNamespace, \"groupUnixGIDNamespace\");\n+\n+        //Get All Facilities from group\n+        Set<Facility> facilitiesOfGroup = new HashSet<>();\n+        List<Resource> resourcesOfGroup = sess.getPerunBl().getResourcesManagerBl().getAssignedResources(sess, group);\n+        for (Resource r : resourcesOfGroup) {\n+            facilitiesOfGroup.add(sess.getPerunBl().getResourcesManagerBl().getFacility(sess, r));\n+        }\n+\n+        //Prepare list of gid namespaces of all facilities which have the same groupName namespace like this unixGroupName namespace\n+        Set<String> groupNameNamespaces = this.getSetOfGroupNameNamespacesWhereFacilitiesHasTheSameGIDNamespace(sess, new ArrayList<>(facilitiesOfGroup), groupUnixGIDNamespace);\n+\n+        if (!groupNameNamespaces.isEmpty()) {\n+            for (String s : groupNameNamespaces) {\n+                try {\n+                    Attribute groupNameNamespace = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, group, A_G_unixGroupName_namespace + \":\" + s);\n+                    if (groupNameNamespace.getValue() != null) {\n+                        return true;\n+                    }\n+                } catch (AttributeNotExistsException ex) {\n+                    throw new ConsistencyErrorException(ex);\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isNameOfEmailValid(PerunSessionImpl sess, String email) {\n+        if (email == null) {\n+            return false;\n+        }\n+\n+        Matcher emailMatcher = Utils.emailPattern.matcher(email);\n+        return emailMatcher.find();\n+    }\n+\n+    @Override\n+    public void checkFormatOfShell(String shell, Attribute attribute) throws WrongAttributeValueException {\n+        Matcher match = shellPattern.matcher(shell);\n+        if (!match.matches()) {\n+            throw new WrongAttributeValueException(attribute, \"Bad shell attribute format \" + shell);\n+        }\n+    }\n+\n+    @Override\n+    public void checkAttributeRegex(Attribute attribute, Pattern defaultRegex) throws InternalErrorException, WrongAttributeValueException {\n+        if (attribute == null || attribute.getValue() == null) {\n+            throw new InternalErrorException(\"Attribute or it's value is null.\");\n+        }\n+        String attributeValue = (String) attribute.getValue();\n+        checkPerunNamespacesMap();\n+\n+        String regex = perunNamespaces.get(attribute.getFriendlyName() + \":regex\");\n+        if (regex != null) {\n+            //Check if regex is valid\n+            try {\n+                Pattern.compile(regex);\n+            } catch (PatternSyntaxException e) {\n+                log.error(\"Regex pattern \\\"\" + regex + \"\\\" from \\\"\" + attribute.getFriendlyName() + \":regex\\\"\" + \" property of perun-namespaces.properties file is invalid.\");\n+                throw new InternalErrorException(\"Regex pattern \\\"\" + regex + \"\\\" from \\\"\" + attribute.getFriendlyName() + \":regex\\\"\" + \" property of perun-namespaces.properties file is invalid.\");\n+            }\n+            if (!attributeValue.matches(regex)) {\n+                throw new WrongAttributeValueException(attribute, \"Wrong format. Regex: \\\"\" + regex + \"\\\" expected for this attribute:\");\n+            }\n+        } else {\n+            //Regex property not found in our attribute map, so use the default hardcoded regex\n+            if (!defaultRegex.matcher(attributeValue).matches()) {\n+                throw new WrongAttributeValueException(attribute, \"Wrong format. Regex: \\\"\" + defaultRegex + \"\\\" expected for this attribute:\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Internal protected method.\n+     * Checks this.perunNamespaces map, which is always initialized as null.\n+     * If null, it tries to load the configuration into this map from a perun-namespaces.properties file.\n+     * If the file does not exist, it creates an empty HashMap, so it's not null anymore.\n+     */\n+    protected void checkPerunNamespacesMap() {\n+        if (perunNamespaces == null) {\n+            try {\n+                perunNamespaces = BeansUtils.getAllPropertiesFromCustomConfiguration(\"perun-namespaces.properties\");\n+            } catch (InternalErrorException e) {\n+                perunNamespaces = new HashMap<>();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void checkIfQuotasIsInLimit(Map<String, Pair<BigDecimal, BigDecimal>> quotaToCheck, Map<String, Pair<BigDecimal, BigDecimal>> limitQuota) throws InternalErrorException {\n+        if (quotaToCheck == null) {\n+            throw new InternalErrorException(\"Quota to check can't be null.\");\n+        }\n+        if (limitQuota == null) {\n+            throw new InternalErrorException(\"Limit quota can't be null.\");\n+        }\n+\n+        //If there is no value to check, then everything is in limit (we don't need to limit anything)\n+        if (quotaToCheck.isEmpty()) {\n+            return;\n+        }\n+\n+        //test every record of quotaToCheck against record in limitQuota\n+        for (String volumeToCheck : quotaToCheck.keySet()) {\n+            if (!limitQuota.containsKey(volumeToCheck)) {\n+                throw new QuotaNotInAllowedLimitException(quotaToCheck, limitQuota, \"Volume \" + volumeToCheck + \" is missing in limitQuota.\");\n+            }\n+\n+            Pair<BigDecimal, BigDecimal> volumeToCheckQuotas = quotaToCheck.get(volumeToCheck);\n+            Pair<BigDecimal, BigDecimal> volumeToCheckLimitQuotas = limitQuota.get(volumeToCheck);\n+\n+            //Check limit of softQuota, zero limit means unlimited so no need for testing\n+            if (volumeToCheckLimitQuotas.getLeft().compareTo(BigDecimal.ZERO) != 0) {\n+                if (volumeToCheckQuotas.getLeft().compareTo(BigDecimal.ZERO) == 0 || volumeToCheckQuotas.getLeft().compareTo(volumeToCheckLimitQuotas.getLeft()) > 0) {\n+                    throw new QuotaNotInAllowedLimitException(quotaToCheck, limitQuota, \"SoftQuota of volume \" + volumeToCheck + \" is bigger than limit.\");\n+                }\n+            }\n+\n+            //Check limit of hardQuota, zero limit means unlimited so no need for testing\n+            if (volumeToCheckLimitQuotas.getRight().compareTo(BigDecimal.ZERO) != 0) {\n+                if (volumeToCheckQuotas.getRight().compareTo(BigDecimal.ZERO) == 0 || volumeToCheckQuotas.getRight().compareTo(volumeToCheckLimitQuotas.getRight()) > 0) {\n+                    throw new QuotaNotInAllowedLimitException(quotaToCheck, limitQuota, \"HardQuota of volume \" + volumeToCheck + \" is bigger than limit.\");\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public Map<String, Pair<BigDecimal, BigDecimal>> checkAndTransferQuotas(Attribute quotasAttribute, PerunBean firstPlaceholder, PerunBean secondPlaceholder, boolean withMetrics) throws InternalErrorException, WrongAttributeValueException {\n+        //firstPlaceholder can't be null\n+        if (firstPlaceholder == null) {\n+            throw new InternalErrorException(\"Missing first mandatory placeHolder (PerunBean).\");\n+        }\n+        //If quotas attribute is null or it's value is empty, return empty hash map\n+        if (quotasAttribute == null || quotasAttribute.getValue() == null) {\n+            return new LinkedHashMap<>();\n+        }\n+\n+        //Prepare result container and value of attribute\n+        Map<String, Pair<BigDecimal, BigDecimal>> transferedQuotas = new LinkedHashMap<>();\n+        Map<String, String> defaultQuotasMap = quotasAttribute.valueAsMap();\n+\n+        //List to test if all paths are unique (/var/log and /var/log/ are the same so these two paths are not unique)\n+        List<String> uniquePaths = new ArrayList<>();\n+        for (String path : defaultQuotasMap.keySet()) {\n+            //null is not correct path for volume on File System\n+            if (path == null || path.isEmpty()) {\n+                throw new WrongAttributeValueException(quotasAttribute, firstPlaceholder, secondPlaceholder, \"The path of some volume where quota should be set is null.\");\n+            }\n+\n+            //testing if path is unique\n+            String canonicalPath;\n+            try {\n+                canonicalPath = new URI(path).normalize().getPath();\n+                //path should not end on '/' (problem with some systems as GPFS)\n+                if (!canonicalPath.equals(\"/\") && canonicalPath.endsWith(\"/\")) {\n+                    canonicalPath = canonicalPath.substring(0, canonicalPath.length() - 1);\n+                }\n+            } catch (URISyntaxException ex) {\n+                throw new WrongAttributeValueException(quotasAttribute, firstPlaceholder, secondPlaceholder, \"Path '\" + path + \"' is not correct form.\");\n+            }\n+\n+            if (uniquePaths.contains(canonicalPath)) {\n+                throw new WrongAttributeValueException(quotasAttribute, firstPlaceholder, secondPlaceholder, \"Paths are not unique, there are two same paths: \" + path);\n+            } else {\n+                uniquePaths.add(canonicalPath);\n+            }\n+\n+            String quota = defaultQuotasMap.get(path);\n+            //quota can't be null, if exists in attribute, must be set in some way\n+            if (quota == null) {\n+                throw new WrongAttributeValueException(quotasAttribute, firstPlaceholder, secondPlaceholder, \"The quota of some volume where quota should be set is null.\");\n+            }\n+\n+            //check format of quota parameter (for data with metrics, for count of files without metrics)\n+            Matcher quotaMatcher;\n+            if (withMetrics) {\n+                quotaMatcher = ModulesUtilsBlImpl.quotaWithMetricsPattern.matcher(quota);\n+                if (!quotaMatcher.matches()) {\n+                    throw new WrongAttributeValueException(quotasAttribute, firstPlaceholder, secondPlaceholder, \"Format of quota in quotas attribute is not correct.\");\n+                }\n+            } else {\n+                quotaMatcher = ModulesUtilsBlImpl.quotaWithoutMetricsPattern.matcher(quota);\n+                if (!quotaMatcher.matches()) {\n+                    throw new WrongAttributeValueException(quotasAttribute, firstPlaceholder, secondPlaceholder, \"Format of quota in quotas attribute is not correct.\");\n+                }\n+            }\n+\n+            //Parse quotas to variables\n+            String softQuota = quotaMatcher.group(1);\n+            String hardQuota = quotaMatcher.group(3);\n+\n+            //Parse number pattern and letter pattern from whole quotas\n+\n+            //SoftQuotaNumber\n+            BigDecimal softQuotaAfterTransfer;\n+            BigDecimal hardQuotaAfterTransfer;\n+            //special behavior with metrics\n+            if (withMetrics) {\n+                Matcher numberMatcher = numberPattern.matcher(softQuota);\n+                if (!numberMatcher.find()) {\n+                    throw new ConsistencyErrorException(\"Matcher can't find number in softQuota '\" + softQuota + \"' in attribute \" + quotasAttribute);\n+                }\n+                String softQuotaNumber = numberMatcher.group();\n+\n+                //SoftQuotaLetter\n+                String softQuotaLetter;\n+                Matcher letterMatcher = letterPattern.matcher(softQuota);\n+                //in this case no letter means default and default is G\n+                if (!letterMatcher.find()) {\n+                    softQuotaLetter = \"G\";\n+                } else {\n+                    softQuotaLetter = letterMatcher.group();\n+                }\n+\n+                //HardQuotaNumber\n+                numberMatcher = numberPattern.matcher(hardQuota);\n+                if (!numberMatcher.find()) {\n+                    throw new ConsistencyErrorException(\"Matcher can't find number in hardQuota '\" + hardQuota + \"' in attribute \" + quotasAttribute);\n+                }\n+                String hardQuotaNumber = numberMatcher.group();\n+\n+                //HardQuotaLetter\n+                String hardQuotaLetter;\n+                letterMatcher = letterPattern.matcher(hardQuota);\n+                //in this case no letter means default and default is G\n+                if (!letterMatcher.find()) {\n+                    hardQuotaLetter = \"G\";\n+                } else {\n+                    hardQuotaLetter = letterMatcher.group();\n+                }\n+\n+                //Prepare whole big decimal numbers\n+                softQuotaAfterTransfer = new BigDecimal(softQuotaNumber);\n+                hardQuotaAfterTransfer = new BigDecimal(hardQuotaNumber);\n+\n+                //multiplying for softQuota\n+                switch (softQuotaLetter) {\n+                    case \"K\":\n+                        break; //K is basic metric, no need to multiply it\n+                    case \"G\":\n+                        softQuotaAfterTransfer = softQuotaAfterTransfer.multiply(BigDecimal.valueOf(G));\n+                        break;\n+                    case \"M\":\n+                        softQuotaAfterTransfer = softQuotaAfterTransfer.multiply(BigDecimal.valueOf(M));\n+                        break;\n+                    case \"T\":\n+                        softQuotaAfterTransfer = softQuotaAfterTransfer.multiply(BigDecimal.valueOf(T));\n+                        break;\n+                    case \"P\":\n+                        softQuotaAfterTransfer = softQuotaAfterTransfer.multiply(BigDecimal.valueOf(P));\n+                        break;\n+                    case \"E\":\n+                        softQuotaAfterTransfer = softQuotaAfterTransfer.multiply(BigDecimal.valueOf(E));\n+                        break;\n+                    default:\n+                        throw new ConsistencyErrorException(\"There is not allowed character in soft quota letter '\" + softQuotaLetter + \"'.\");\n+                }\n+\n+                //multiplying for softQuota\n+                switch (hardQuotaLetter) {\n+                    case \"K\":\n+                        break; //K is basic metric, no need to multiply it\n+                    case \"G\":\n+                        hardQuotaAfterTransfer = hardQuotaAfterTransfer.multiply(BigDecimal.valueOf(G));\n+                        break;\n+                    case \"M\":\n+                        hardQuotaAfterTransfer = hardQuotaAfterTransfer.multiply(BigDecimal.valueOf(M));\n+                        break;\n+                    case \"T\":\n+                        hardQuotaAfterTransfer = hardQuotaAfterTransfer.multiply(BigDecimal.valueOf(T));\n+                        break;\n+                    case \"P\":\n+                        hardQuotaAfterTransfer = hardQuotaAfterTransfer.multiply(BigDecimal.valueOf(P));\n+                        break;\n+                    case \"E\":\n+                        hardQuotaAfterTransfer = hardQuotaAfterTransfer.multiply(BigDecimal.valueOf(E));\n+                        break;\n+                    default:\n+                        throw new ConsistencyErrorException(\"There is not allowed character in hard quota letter '\" + hardQuotaLetter + \"'.\");\n+                }\n+                //easy way without metrics\n+            } else {\n+                softQuotaAfterTransfer = new BigDecimal(softQuota);\n+                hardQuotaAfterTransfer = new BigDecimal(hardQuota);\n+            }\n+\n+            //test comparing softQuota and hardQuota (softQuota must be less or equals than hardQuota, 0 means unlimited)\n+            //1] if softQuota is unlimited, but hardQuota not = exception\n+            if (softQuotaAfterTransfer.compareTo(BigDecimal.valueOf(0)) == 0 && hardQuotaAfterTransfer.compareTo(BigDecimal.valueOf(0)) != 0) {\n+                throw new WrongAttributeValueException(quotasAttribute, firstPlaceholder, secondPlaceholder, \"SoftQuota is set to unlimited (0) but hardQuota is limited to '\" + hardQuota + \"'.\");\n+                //2] if hardQuota is not unlimited but still it is less then softQuota = exception\n+            } else if (hardQuotaAfterTransfer.compareTo(BigDecimal.valueOf(0)) != 0 && hardQuotaAfterTransfer.compareTo(softQuotaAfterTransfer) < 0) {\n+                throw new WrongAttributeValueException(quotasAttribute, firstPlaceholder, secondPlaceholder, \"One of quotas is not correct. HardQuota '\" + hardQuota + \"' is less then softQuota '\" + softQuota + \"'.\");\n+            }\n+            //other cases are ok\n+\n+            transferedQuotas.put(canonicalPath, new Pair<>(softQuotaAfterTransfer, hardQuotaAfterTransfer));\n+        }\n+\n+        return transferedQuotas;\n+    }\n+\n+    @Override\n+    public Map<String, String> transferQuotasBackToAttributeValue(Map<String, Pair<BigDecimal, BigDecimal>> transferedQuotasMap, boolean withMetrics) throws InternalErrorException {\n+        Map<String, String> attributeQuotasValue = new LinkedHashMap<>();\n+        //if null or empty, return empty attribute value map for quotas\n+        if (transferedQuotasMap == null || transferedQuotasMap.isEmpty()) {\n+            return attributeQuotasValue;\n+        }\n+\n+        //every path with quotas transfer step by step\n+        for (String path : transferedQuotasMap.keySet()) {\n+            Pair<BigDecimal, BigDecimal> quotas = transferedQuotasMap.get(path);\n+            BigDecimal softQuotaBD = quotas.getLeft();\n+            BigDecimal hardQuotaBD = quotas.getRight();\n+\n+            //Divide decimal till it is still natural number\n+            //Soft Quota\n+            String softQuota = \"0\";\n+            //Zero means unlimited, stay the same\n+            if (softQuotaBD.compareTo(BigDecimal.ZERO) != 0) {\n+                if (withMetrics) {\n+                    softQuota = Utils.bigDecimalBytesToReadableStringWithMetric(softQuotaBD);\n+                } else {\n+                    softQuota = softQuotaBD.toPlainString();\n+                }\n+            }\n+            //Hard Quota\n+            String hardQuota = \"0\";\n+            //Zero means unlimited, stay the same\n+            if (hardQuotaBD.compareTo(BigDecimal.ZERO) != 0) {\n+                if (withMetrics) {\n+                    hardQuota = Utils.bigDecimalBytesToReadableStringWithMetric(hardQuotaBD);\n+                } else {\n+                    hardQuota = hardQuotaBD.toPlainString();\n+                }\n+            }\n+\n+            //add softQuota and hardQuota to result (50T:60T)\n+            attributeQuotasValue.put(path, softQuota + \":\" + hardQuota);\n+        }\n+        return attributeQuotasValue;\n+    }\n+\n+    @Override\n+    public Map<String, Pair<BigDecimal, BigDecimal>> mergeMemberAndResourceTransferredQuotas(Map<String, Pair<BigDecimal, BigDecimal>> resourceQuotas, Map<String, Pair<BigDecimal, BigDecimal>> memberResourceQuotas, Map<String, Pair<BigDecimal, BigDecimal>> quotasOverride) {\n+        Map<String, Pair<BigDecimal, BigDecimal>> mergedTransferedQuotas = new LinkedHashMap<>();\n+\n+        //first go through member-resource quotas values\n+        for (String path : memberResourceQuotas.keySet()) {\n+            //override has the highest priority\n+            if (quotasOverride.containsKey(path)) {\n+                mergedTransferedQuotas.put(path, quotasOverride.get(path));\n+            } else {\n+                //if override not exists, take the original value\n+                mergedTransferedQuotas.put(path, memberResourceQuotas.get(path));\n+            }\n+        }\n+\n+        //save unique values from resource quotas (not exists in member-resource quotas)\n+        for (String path : resourceQuotas.keySet()) {\n+            //skip already saved values, they are not unique\n+            if (mergedTransferedQuotas.containsKey(path)) {\n+                continue;\n+            }\n+\n+            //take override if exists\n+            if (quotasOverride.containsKey(path)) {\n+                mergedTransferedQuotas.put(path, quotasOverride.get(path));\n+            } else {\n+                mergedTransferedQuotas.put(path, resourceQuotas.get(path));\n+            }\n+        }\n+\n+        return mergedTransferedQuotas;\n+    }\n+\n+    @Override\n+    public Map<String, Pair<BigDecimal, BigDecimal>> countUserFacilityQuotas(List<Map<String, Pair<BigDecimal, BigDecimal>>> allUserQuotas) {\n+        Map<String, Pair<BigDecimal, BigDecimal>> resultTransferredQuotas = new LinkedHashMap<>();\n+        //for every transfered map of merged quotas count one result transfered map\n+        for (Map<String, Pair<BigDecimal, BigDecimal>> mapValue : allUserQuotas) {\n+            //for every path in one transfered map\n+            for (String pathKey : mapValue.keySet()) {\n+                //if path not exists in result map, add it with it's values\n+                if (!resultTransferredQuotas.containsKey(pathKey)) {\n+                    resultTransferredQuotas.put(pathKey, mapValue.get(pathKey));\n+                    //if path already exists in result map, sum their quotas together\n+                } else {\n+                    Pair<BigDecimal, BigDecimal> quotasValue1 = resultTransferredQuotas.get(pathKey);\n+                    Pair<BigDecimal, BigDecimal> quotasValue2 = mapValue.get(pathKey);\n+                    //for soft quota (left part of pair)\n+                    BigDecimal softQuota = BigDecimal.ZERO;\n+                    if (quotasValue1.getLeft().compareTo(BigDecimal.ZERO) != 0 && quotasValue2.getLeft().compareTo(BigDecimal.ZERO) != 0) {\n+                        softQuota = quotasValue1.getLeft().add(quotasValue2.getLeft());\n+                    }\n+                    //for hard quota (right part of pair)\n+                    BigDecimal hardQuota = BigDecimal.ZERO;\n+                    if (quotasValue1.getRight().compareTo(BigDecimal.ZERO) != 0 && quotasValue2.getRight().compareTo(BigDecimal.ZERO) != 0) {\n+                        hardQuota = quotasValue1.getRight().add(quotasValue2.getRight());\n+                    }\n+                    //create new pair of summed numbers\n+                    Pair<BigDecimal, BigDecimal> finalQuotasValue = new Pair<>(softQuota, hardQuota);\n+                    //add new summed pair to the result map\n+                    resultTransferredQuotas.put(pathKey, finalQuotasValue);\n+                }\n+            }\n+        }\n+        //return result map\n+        return resultTransferredQuotas;\n+    }\n+\n+    @Override\n+    public boolean isFQDNValid(PerunSessionImpl sess, String fqdn) {\n+        if (fqdn == null) {\n+            return false;\n+        }\n+        Matcher fqdnMatcher = fqdnPattern.matcher(fqdn);\n+        return fqdnMatcher.find();\n+    }\n+\n+    /**\n+     * Normalize string for purpose of generating safe login value.\n+     *\n+     * @return normalized string\n+     */\n+    public static String normalizeStringForLogin(String toBeNormalized) {\n+\n+        if (toBeNormalized == null || toBeNormalized.trim().isEmpty()) {\n+            return null;\n+        }\n+\n+        toBeNormalized = toBeNormalized.toLowerCase();\n+        toBeNormalized = java.text.Normalizer.normalize(toBeNormalized, java.text.Normalizer.Form.NFD).replaceAll(\"\\\\p{InCombiningDiacriticalMarks}+\", \"\");\n+        toBeNormalized = toBeNormalized.replaceAll(\"[^a-zA-Z]+\", \"\");\n+\n+        // unable to fill login for users without name or with partial name\n+        if (toBeNormalized.isEmpty()) {\n+            return null;\n+        }\n+\n+        return toBeNormalized;\n+\n+    }\n+\n+    /**\n+     * Shared logic for purpose of login generation\n+     */\n+    public static class LoginGenerator {\n+\n+        /**\n+         * Define joining function for anonymous classes\n+         */\n+        public interface LoginGeneratorFunction {\n+\n+            /**\n+             * Generate login for user using his name.\n+             * Implementation must handle empty/null input on both fields.\n+             *\n+             * @param firstName\n+             * @param lastName\n+             * @return generated login\n+             */\n+            String generateLogin(String firstName, String lastName);\n+\n+        }\n+\n+        /**\n+         * Generate login for user using his name and joining function\n+         *\n+         * @param user     User to get data from\n+         * @param function Function to join fist/lastName to login\n+         * @return generated login\n+         */\n+        public String generateLogin(User user, LoginGeneratorFunction function) {\n+\n+            String firstName = user.getFirstName();\n+            String lastName = user.getLastName();\n+\n+            // get only first part of first name and remove spec. chars\n+            if (firstName != null && !firstName.isEmpty()) {\n+                firstName = ModulesUtilsBlImpl.normalizeStringForLogin(firstName.split(\" \")[0]);\n+            }\n+\n+            // get only last part of last name and remove spec. chars\n+            if (lastName != null && !lastName.isEmpty()) {\n+                List<String> names = Arrays.asList(lastName.split(\" \"));\n+                lastName = names.get(names.size() - 1);\n+                lastName = ModulesUtilsBlImpl.normalizeStringForLogin(lastName.split(\" \")[0]);\n+            }\n+\n+            return function.generateLogin(firstName, lastName);\n+\n+        }\n+\n+    }\n+\n+    @Override\n+    public User getUserFromMessage(PerunSessionImpl sess, String message) throws InternalErrorException {\n+        List<PerunBean> perunBeans = AuditParser.parseLog(message);\n+\n+        User user = null;\n+        UserExtSource userExtSource = null;\n+        Member member = null;\n+\n+        for (PerunBean perunBean : perunBeans) {\n+            if (perunBean instanceof User) {\n+                user = (User) perunBean;\n+                break;\n+            } else if (perunBean instanceof UserExtSource && userExtSource == null) {\n+                userExtSource = (UserExtSource) perunBean;\n+            } else if (perunBean instanceof Member && member == null) {\n+                member = (Member) perunBean;\n+            }\n+        }\n+\n+        //if we don't have object user, try to parse user id from userExtSource (-1 means no userId was defined)\n+        if (user == null && userExtSource != null && userExtSource.getUserId() != -1) {\n+            try {\n+                user = getPerunBl().getUsersManagerBl().getUserById(sess, userExtSource.getUserId());\n+            } catch (UserNotExistsException ex) {\n+                log.warn(\"User from UserExtSource {} doesn't exist in Perun. This occurred while parsing message: {}.\", userExtSource, message);\n+                return null;\n+            }\n+        } else if (user == null && member != null) {\n+            try {\n+                user = getPerunBl().getUsersManagerBl().getUserById(sess, member.getUserId());\n+            } catch (UserNotExistsException ex) {\n+                log.warn(\"User from Member {} doesn't exist in Perun. This occurred while parsing message: {}.\", member, message);\n+                return null;\n+            }\n+        }\n+\n+        return user;\n+    }\n+\n+    @Override\n+    public Map<Integer, Integer> checkAndConvertGIDRanges(Attribute gidRangesAttribute) throws InternalErrorException, WrongAttributeValueException {\n+        //Prepare structure for better working with GID Ranges\n+        Map<Integer, Integer> convertedRanges = new HashMap<>();\n+\n+        //For null attribute throw an exception\n+        if (gidRangesAttribute == null) {\n+            throw new InternalErrorException(\"Can't get value from null attribute!\");\n+        }\n+\n+        Map<String, String> gidRanges = gidRangesAttribute.valueAsMap();\n+\n+        //Return empty map if there is empty input of gidRanges in method parameters\n+        if (gidRanges == null || gidRanges.isEmpty()) {\n+            return convertedRanges;\n+        }\n+\n+        //Check every range if it is in correct format and it is valid range\n+        for (String minimumOfRange : gidRanges.keySet()) {\n+            //Check not null\n+            if (minimumOfRange == null || minimumOfRange.isEmpty()) {\n+                throw new WrongAttributeValueException(gidRangesAttribute, \"Minimum in one of gid ranges is empty!\");\n+            }\n+            String maximumOfRange = gidRanges.get(minimumOfRange);\n+            if (maximumOfRange == null || maximumOfRange.isEmpty()) {\n+                throw new WrongAttributeValueException(gidRangesAttribute, \"Maximum in one of gid ranges is empty!\");\n+            }\n+\n+            //Transfer string to numbers\n+            Integer minimum;\n+            Integer maximum;\n+\n+            try {\n+                minimum = Integer.valueOf(minimumOfRange);\n+                maximum = Integer.valueOf(maximumOfRange);\n+            } catch (NumberFormatException ex) {\n+                throw new WrongAttributeValueException(gidRangesAttribute, \"Min or max value of some range is not correct number format.\");\n+            }\n+\n+            //Check if min value from range is bigger than 0\n+            if (minimum < 1) {\n+                throw new WrongAttributeValueException(gidRangesAttribute, \"Minimum of one of gid ranges is less than 0.\");\n+            }\n+\n+            //Check if it is correct range\n+            if (minimum > maximum) {\n+                throw new WrongAttributeValueException(gidRangesAttribute, \"One of gid ranges is not correct range. Minimum of this range is bigger then it's maximum.\");\n+            }\n+\n+            //Put this valid range to the map of correct gid ranges\n+            convertedRanges.put(minimum, maximum);\n+        }\n+\n+        //Check gid ranges overlaps (there should be no overlaps)\n+        Integer lastMaxValue = 0;\n+        for (Integer minValue : convertedRanges.keySet().stream().sorted().collect(Collectors.toList())) {\n+            if (minValue <= lastMaxValue) {\n+                throw new WrongAttributeValueException(gidRangesAttribute, \"There is an overlap between two gid ranges.\");\n+            }\n+            lastMaxValue = convertedRanges.get(minValue);\n+        }\n+\n+        return convertedRanges;\n+    }\n+\n+    /**\n+     * Returns pair of number (BigDecimal) and unit (String) from given string. Returns default value Pair<0, \"G\"> if parsing fails.\n+     * E.g.: \"5T\" -> Pair<5, \"T\">\n+     *\n+     * @param attributeValue string to parse\n+     * @return pair of number and unit\n+     */\n+    public static Pair<BigDecimal, String> getNumberAndUnitFromString(String attributeValue) {\n+        String numberString = \"0\";\n+        String unit = \"G\";\n+\n+        if (attributeValue != null) {\n+            Matcher numberMatcher = numberPattern.matcher(attributeValue);\n+            Matcher letterMatcher = letterPattern.matcher(attributeValue);\n+            numberMatcher.find();\n+            letterMatcher.find();\n+            try {\n+                numberString = attributeValue.substring(numberMatcher.start(), numberMatcher.end());\n+            } catch (IllegalStateException ex) {\n+                log.debug(\"No number could be parsed from given string.\", ex);\n+            }\n+            try {\n+                unit = attributeValue.substring(letterMatcher.start(), letterMatcher.end());\n+            } catch (IllegalStateException ex) {\n+                log.debug(\"No unit could be parsed from given string.\", ex);\n+            }\n+        }\n+\n+        BigDecimal number = new BigDecimal(numberString.replace(',', '.'));\n+\n+        return new Pair<>(number, unit);\n+    }\n+\n+    public PerunBl getPerunBl() {\n+        return this.perunBl;\n+    }\n+\n+    public void setPerunBl(PerunBl perunBl) {\n+        this.perunBl = perunBl;\n+    }\n }\n",
            "diff_size": 1250
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/258/ModulesUtilsBlImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/codebuff/258/ModulesUtilsBlImpl.java\nindex eaf48b2aa7f..868f50f510c 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/258/ModulesUtilsBlImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/codebuff/258/ModulesUtilsBlImpl.java\n@@ -29,7 +29,6 @@ import cz.metacentrum.perun.core.impl.PerunSessionImpl;\n import cz.metacentrum.perun.core.impl.Utils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-\n import java.math.BigDecimal;\n import java.net.URI;\n import java.net.URISyntaxException;\n@@ -49,1126 +48,1173 @@ import java.util.stream.Collectors;\n /**\n  * @author Michal Stava <stavamichal@gmail.com>\n  */\n+\n+\n public class ModulesUtilsBlImpl implements ModulesUtilsBl {\n \n-\tfinal static Logger log = LoggerFactory.getLogger(ServicesManagerBlImpl.class);\n-\tprivate PerunBl perunBl;\n-\tMap<String,String> perunNamespaces = null;\n-\n-\tpublic static final String A_E_namespace_GIDRanges = AttributesManager.NS_ENTITYLESS_ATTR_DEF + \":namespace-GIDRanges\";\n-\tpublic static final String A_G_unixGID_namespace = AttributesManager.NS_GROUP_ATTR_DEF + \":unixGID-namespace\";\n-\tpublic static final String A_G_unixGroupName_namespace = AttributesManager.NS_GROUP_ATTR_DEF + \":unixGroupName-namespace\";\n-\tpublic static final String A_R_unixGID_namespace = AttributesManager.NS_RESOURCE_ATTR_DEF + \":unixGID-namespace\";\n-\tpublic static final String A_R_unixGroupName_namespace = AttributesManager.NS_RESOURCE_ATTR_DEF + \":unixGroupName-namespace\";\n-\tpublic static final String A_F_unixGID_namespace = AttributesManager.NS_FACILITY_ATTR_DEF + \":unixGID-namespace\";\n-\tpublic static final String A_F_unixGroupName_namespace = AttributesManager.NS_FACILITY_ATTR_DEF + \":unixGroupName-namespace\";\n-\tpublic static final String A_F_googleGroupsDomain = AttributesManager.NS_FACILITY_ATTR_DEF + \":googleGroupsDomain\";\n-\tprivate static final String A_E_usedGids = AttributesManager.NS_ENTITYLESS_ATTR_DEF + \":usedGids\";\n-\n-\t//Often used patterns\n-\tpublic static final Pattern quotaWithMetricsPattern = Pattern.compile(\"^([0-9]+([.][0-9]+)?[KMGTPE]?):([0-9]+([.][0-9]+)?[KMGTPE]?)$\");\n-\tpublic static final Pattern quotaWithoutMetricsPattern = Pattern.compile(\"^([0-9]+)(:)([0-9]+)$\");\n-\tpublic static final Pattern numberPattern = Pattern.compile(\"[0-9]+([.][0-9]+)?\");\n-\tpublic static final Pattern letterPattern = Pattern.compile(\"[A-Z]\");\n-\tpublic static final Pattern fqdnPattern = Pattern.compile(\"^((?!-)[a-zA-Z0-9-]{1,63}(?<!-)\\\\.)+[a-zA-Z]{2,63}\\\\.?$\");\n-\n-\t//previous regex ^/[-a-zA-Z0-9_/]*$\"\n-\tpublic static final Pattern shellPattern = Pattern.compile(\"^(/[-_a-zA-Z0-9]+)+$\");\n-\n-\tpublic final static List<String> reservedNamesForUnixGroups = Arrays.asList(\"root\", \"daemon\", \"tty\", \"bin\", \"sys\", \"sudo\", \"nogroup\",\n-\t          \"hadoop\", \"hdfs\", \"mapred\", \"yarn\", \"hsqldb\", \"derby\", \"jetty\", \"hbase\", \"zookeeper\", \"users\", \"oozie\", \"hive\");\n-\tpublic final static List<String> unpermittedNamesForUserLogins = Arrays.asList(\"arraysvcs\", \"at\", \"backup\", \"bin\", \"daemon\", \"Debian-exim\", \"flexlm\", \"ftp\", \"games\",\n-\t\t        \"gdm\", \"glite\", \"gnats\", \"haldaemon\", \"identd\", \"irc\", \"libuuid\", \"list\", \"lp\", \"mail\", \"man\",\n-\t\t        \"messagebus\", \"news\", \"nobody\", \"ntp\", \"openslp\", \"pcp\", \"polkituser\", \"postfix\", \"proxy\",\n-\t\t        \"pulse\", \"puppet\", \"root\", \"saned\", \"smmsp\", \"smmta\", \"sshd\", \"statd\", \"suse-ncc\", \"sync\",\n-\t\t        \"sys\", \"uucp\", \"uuidd\", \"www-data\", \"wwwrun\", \"zenssh\", \"tomcat6\", \"tomcat7\", \"tomcat8\",\n-\t\t        \"nn\", \"dn\", \"rm\", \"nm\", \"sn\", \"jn\", \"jhs\", \"http\", \"yarn\", \"hdfs\", \"mapred\", \"hadoop\", \"hsqldb\", \"derby\",\n-\t\t        \"jetty\", \"hbase\", \"zookeeper\", \"hive\", \"hue\", \"oozie\", \"httpfs\");\n-\n-\t//Definition of K = KB, M = MB etc.\n-\tpublic static final long M = 1024;\n-\tpublic static final long G = M * 1024;\n-\tpublic static final long T = G * 1024;\n-\tpublic static final long P = T * 1024;\n-\tpublic static final long E = P * 1024;\n-\n-\tpublic ModulesUtilsBlImpl() {\n-\t}\n-\n-\t@Override\n-\tpublic boolean isNamespaceEqualsToFacilityUnixGroupNameNamespace(PerunSessionImpl sess, Facility facility, String namespace) throws InternalErrorException, AttributeNotExistsException, WrongAttributeAssignmentException{\n-\t\tUtils.notNull(facility, \"facility\");\n-\t\tUtils.notNull(namespace, \"namespace\");\n-\t\tUtils.notNull(sess, \"perunSessionImpl\");\n-\t\tAttribute facilityNamespaceAttr = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, facility, A_F_unixGroupName_namespace + \":\" + namespace);\n-\t\tif(facilityNamespaceAttr.getValue() == null) return false;\n-\t\tif(!namespace.equals(facilityNamespaceAttr.getValue())) {\n-\t\t\treturn false;\n-\t\t}\n-\t\treturn true;\n-\t}\n-\n-\tpublic List<Resource> findCollisionResourcesWithSameGroupName(PerunSessionImpl sess, Resource resource, String namespace) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException {\n-\t\tUtils.notNull(sess, \"perunSessionImpl\");\n-\t\tUtils.notNull(resource, \"resource\");\n-\t\tAttribute resourceUnixGroupName = getPerunBl().getAttributesManagerBl().getAttribute(sess, resource, A_R_unixGroupName_namespace + \":\" + namespace);\n-\t\tList<Resource> resourcesWithSameUnixGroupName = getPerunBl().getResourcesManagerBl().getResourcesByAttribute(sess, resourceUnixGroupName);\n-\t\tresourcesWithSameUnixGroupName.remove(resource);\n-\t\treturn resourcesWithSameUnixGroupName;\n-\t}\n-\n-\tpublic List<Resource> findCollisionResourcesWithSameGroupName(PerunSessionImpl sess, Group group, String namespace) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException {\n-\t\tUtils.notNull(sess, \"perunSessionImpl\");\n-\t\tUtils.notNull(group, \"group\");\n-\t\tUtils.notNull(namespace, \"namespace\");\n-\t\tAttribute groupUnixGroupName = getPerunBl().getAttributesManagerBl().getAttribute(sess, group, A_G_unixGroupName_namespace + \":\" + namespace);\n-\t\tAttribute copyResourceUnixGroupName = new Attribute(getPerunBl().getAttributesManagerBl().getAttributeDefinition(sess, A_R_unixGroupName_namespace + \":\" + namespace));\n-\t\tcopyResourceUnixGroupName.setValue(groupUnixGroupName.getValue());\n-\t\treturn getPerunBl().getResourcesManagerBl().getResourcesByAttribute(sess, copyResourceUnixGroupName);\n-\t}\n-\n-\tpublic List<Group> findCollisionGroupsWithSamgeGroupName(PerunSessionImpl sess, Resource resource, String namespace) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException {\n-\t\tUtils.notNull(sess, \"perunSessionImpl\");\n-\t\tUtils.notNull(resource, \"resource\");\n-\t\tUtils.notNull(namespace, \"namespace\");\n-\t\tAttribute resourceUnixGroupName = getPerunBl().getAttributesManagerBl().getAttribute(sess, resource, A_R_unixGroupName_namespace + \":\" + namespace);\n-\t\tAttribute copyGroupUnixGroupName = new Attribute(getPerunBl().getAttributesManagerBl().getAttributeDefinition(sess, A_G_unixGroupName_namespace + \":\" + namespace));\n-\t\tcopyGroupUnixGroupName.setValue(resourceUnixGroupName.getValue());\n-\t\treturn getPerunBl().getGroupsManagerBl().getGroupsByAttribute(sess, copyGroupUnixGroupName);\n-\n-\t}\n-\n-\tpublic List<Group> findCollisionGroupsWithSamgeGroupName(PerunSessionImpl sess, Group group, String namespace) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException {\n-\t\tUtils.notNull(sess, \"perunSessionImpl\");\n-\t\tUtils.notNull(group, \"group\");\n-\t\tUtils.notNull(namespace, \"namespace\");\n-\t\tAttribute groupUnixGroupName = getPerunBl().getAttributesManagerBl().getAttribute(sess, group, A_G_unixGroupName_namespace + \":\" + namespace);\n-\t\tList<Group> groupsWithsameGroupName = getPerunBl().getGroupsManagerBl().getGroupsByAttribute(sess, groupUnixGroupName);\n-\t\tgroupsWithsameGroupName.remove(group);\n-\t\treturn groupsWithsameGroupName;\n-\t}\n-\n-\tpublic List<Resource> findCollisionResourcesWithSameGid(PerunSessionImpl sess, Resource resource, String namespace) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException {\n-\t\tUtils.notNull(sess, \"perunSessionImpl\");\n-\t\tUtils.notNull(resource, \"resource\");\n-\t\tUtils.notNull(namespace, \"namespace\");\n-\t\tAttribute resourceUnixGid = getPerunBl().getAttributesManagerBl().getAttribute(sess, resource, A_R_unixGID_namespace + \":\" + namespace);\n-\t\tList<Resource> resourcesWithSameGid = getPerunBl().getResourcesManagerBl().getResourcesByAttribute(sess, resourceUnixGid);\n-\t\tresourcesWithSameGid.remove(resource);\n-\t\treturn resourcesWithSameGid;\n-\t}\n-\n-\tpublic List<Resource> findCollisionResourcesWithSameGid(PerunSessionImpl sess, Group group, String namespace) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException {\n-\t\tUtils.notNull(sess, \"perunSessionImpl\");\n-\t\tUtils.notNull(group, \"group\");\n-\t\tUtils.notNull(namespace, \"namespace\");\n-\t\tAttribute groupUnixGid = getPerunBl().getAttributesManagerBl().getAttribute(sess, group, A_G_unixGID_namespace + \":\" + namespace);\n-\t\tAttribute copyResourceUnixGid = new Attribute(getPerunBl().getAttributesManagerBl().getAttributeDefinition(sess, A_R_unixGID_namespace + \":\" + namespace));\n-\t\tcopyResourceUnixGid.setValue(groupUnixGid.getValue());\n-\t\treturn getPerunBl().getResourcesManagerBl().getResourcesByAttribute(sess, copyResourceUnixGid);\n-\t}\n-\n-\tpublic List<Group> findCollisionGroupsWithSamgeGroupGid(PerunSessionImpl sess, Resource resource, String namespace) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException {\n-\t\tUtils.notNull(sess, \"perunSessionImpl\");\n-\t\tUtils.notNull(resource, \"resource\");\n-\t\tUtils.notNull(namespace, \"namespace\");\n-\t\tAttribute resourceUnixGid = getPerunBl().getAttributesManagerBl().getAttribute(sess, resource, A_R_unixGID_namespace + \":\" + namespace);\n-\t\tAttribute copyGroupUnixGid = new Attribute(getPerunBl().getAttributesManagerBl().getAttributeDefinition(sess, A_G_unixGID_namespace + \":\" + namespace));\n-\t\tcopyGroupUnixGid.setValue(resourceUnixGid.getValue());\n-\t\treturn getPerunBl().getGroupsManagerBl().getGroupsByAttribute(sess, copyGroupUnixGid);\n-\t}\n-\n-\tpublic List<Group> findCollisionGroupsWithSamgeGroupGid(PerunSessionImpl sess, Group group, String namespace) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException {\n-\t\tUtils.notNull(sess, \"perunSessionImpl\");\n-\t\tUtils.notNull(group, \"group\");\n-\t\tUtils.notNull(namespace, \"namespace\");\n-\t\tAttribute groupUnixGid = getPerunBl().getAttributesManagerBl().getAttribute(sess, group, A_G_unixGID_namespace + \":\" + namespace);\n-\t\tList<Group> groupsWithSameUnixGid = getPerunBl().getGroupsManagerBl().getGroupsByAttribute(sess, groupUnixGid);\n-\t\tgroupsWithSameUnixGid.remove(group);\n-\t\treturn groupsWithSameUnixGid;\n-\t}\n-\n-\tpublic boolean hasAccessToWriteToAttributeForAnyResource(PerunSessionImpl sess, AttributeDefinition attrDef, List<Resource> resources) throws InternalErrorException {\n-\t\tUtils.notNull(sess, \"perunSessionImpl\");\n-\t\tUtils.notNull(attrDef, \"attributeDefinition\");\n-\t\tif(resources == null || resources.isEmpty()) return false;\n-\t\tfor(Resource r: resources) {\n-\t\t\tif(AuthzResolver.isAuthorizedForAttribute(sess, ActionType.WRITE, attrDef , r)) return true;\n-\t\t}\n-\t\treturn false;\n-\t}\n-\n-\tpublic boolean hasAccessToWriteToAttributeForAnyGroup(PerunSessionImpl sess, AttributeDefinition attrDef, List<Group> groups) throws InternalErrorException {\n-\t\tUtils.notNull(sess, \"perunSessionImpl\");\n-\t\tUtils.notNull(attrDef, \"attributeDefinition\");\n-\t\tif(groups == null || groups.isEmpty()) return false;\n-\t\tfor(Group g: groups) {\n-\t\t\tif(AuthzResolver.isAuthorizedForAttribute(sess, ActionType.WRITE, attrDef, g)) return true;\n-\t\t}\n-\t\treturn false;\n-\t}\n-\n-\t/**\n-\t * Return true if gid is valid in ranges defined by Map of ranges, false otherwise.\n-\t * Keys in gidRanges map are minimums of one range and values are maximums.\n-\t * If minimum is same as maximum, such range has only one element.\n-\t *\n-\t * @param gidRanges map of gid ranges (keys = minimums, values = maximums)\n-\t * @param gid gid which need to be checked if it is in ranges\n-\t * @return\n-\t */\n-\tprivate boolean isGIDWithinRanges(Map<Integer,Integer> gidRanges, Integer gid) {\n-\t\tif(gid == null) return false;\n-\t\tif(gidRanges == null || gidRanges.isEmpty()) return false;\n-\n-\t\t//Test all valid ranges\n-\t\tfor(Integer minimum: gidRanges.keySet()) {\n-\t\t\tInteger maximum = gidRanges.get(minimum);\n-\t\t\t//Gid is in range, it is ok\n-\t\t\tif(gid >= minimum && gid <= maximum) return true;\n-\t\t}\n-\n-\t\treturn false;\n-\t}\n-\n-\t@Override\n-\tpublic void checkIfGIDIsWithinRange(PerunSessionImpl sess, Attribute attribute) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException, WrongAttributeValueException, WrongReferenceAttributeValueException {\n-\t\tUtils.notNull(attribute, \"attribute\");\n-\t\tInteger gid = null;\n-\t\tif(attribute.getValue() != null) gid = (Integer) attribute.getValue();\n-\n-\t\tif(gid == null) throw new WrongAttributeValueException(attribute, \"Gid with null value is not allowed.\");\n-\n-\t\tString gidNamespace = attribute.getFriendlyNameParameter();\n-\n-\t\tAttribute gidRangesAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, gidNamespace, A_E_namespace_GIDRanges);\n-\t\tMap<Integer, Integer> gidRanges = checkAndConvertGIDRanges(gidRangesAttribute);\n-\n-\t\t//Gid is not in range, throw exception\n-\t\tif(!isGIDWithinRanges(gidRanges, gid)) {\n-\t\t\tthrow new WrongReferenceAttributeValueException(attribute, gidRangesAttribute, null, null, gidNamespace, null, \"GID number is not in allowed ranges \" + gidRanges + \" for namespace \" + gidNamespace);\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void checkIfListOfGIDIsWithinRange(PerunSessionImpl sess, User user, Attribute attribute) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException, WrongAttributeValueException {\n-\t\tUtils.notNull(attribute, \"attribute\");\n-\t\tList<String> gidsToCheck = attribute.valueAsList();\n-\t\tif (gidsToCheck != null){\n-\t\t\tString gidNamespace = attribute.getFriendlyNameParameter();\n-\t\t\tAttribute gidRangesAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, gidNamespace, A_E_namespace_GIDRanges);\n-\t\t\tMap<Integer, Integer> gidRanges = checkAndConvertGIDRanges(gidRangesAttribute);\n-\n-\t\t\tfor(String gidToCheck : gidsToCheck){\n-\t\t\t\ttry{\n-\t\t\t\t\tInteger gid = new Integer(gidToCheck);\n-\n-\t\t\t\t\tif ( ! isGIDWithinRanges(gidRanges, gid) ) {\n-\t\t\t\t\t\tthrow new WrongAttributeValueException(attribute, \"GID number is not in allowed ranges \" + gidRanges + \" for namespace \" + gidNamespace);\n-\t\t\t\t\t}\n-\t\t\t\t}catch(NumberFormatException ex){\n-\t\t\t\t\tthrow new WrongAttributeValueException(attribute ,user,\"attribute is not a number\", ex);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic Integer getFreeGID(PerunSessionImpl sess, Attribute attribute) throws InternalErrorException, AttributeNotExistsException, WrongAttributeAssignmentException {\n-\t\tUtils.notNull(attribute, \"attribute\");\n-\t\tString gidNamespace = attribute.getFriendlyNameParameter();\n-\n-\t\tAttribute gidRangesAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, gidNamespace, A_E_namespace_GIDRanges);\n-\t\tif(gidRangesAttribute.getValue() == null) return 0;\n-\t\tMap<Integer, Integer> gidRanges;\n-\t\ttry {\n-\t\t\tgidRanges = checkAndConvertGIDRanges(gidRangesAttribute);\n-\t\t} catch (WrongAttributeValueException ex) {\n-\t\t\tthrow new InternalErrorException(\"Value in GID ranges attribute where we are looking for free gid is not in correct format \" + gidRangesAttribute, ex);\n-\t\t}\n-\t\tif(gidRanges.isEmpty()) return 0;\n-\t\tList<Integer> allMinimums = gidRanges.keySet().stream().sorted().collect(Collectors.toList());\n-\n-\t\tList<Integer> allGids = new ArrayList<>();\n-\t\tAttribute usedGids = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, gidNamespace, A_E_usedGids);\n-\n-\t\t//return the minimum from all ranges\n-\t\tif(usedGids.getValue() == null) return allMinimums.get(0);\n-\t\telse {\n-\t\t\tMap<String,String> usedGidsValue = usedGids.valueAsMap();\n-\t\t\tSet<String> keys = usedGidsValue.keySet();\n-\n-\t\t\tfor(String key: keys) {\n-\t\t\t\tallGids.add(Integer.parseInt(usedGidsValue.get(key)));\n-\t\t\t}\n-\t\t}\n-\n-\t\tfor(Integer minimum: allMinimums) {\n-\t\t\tInteger maximum = gidRanges.get(minimum);\n-\t\t\tfor (int i = minimum; i <= maximum; i++) {\n-\t\t\t\tif (!allGids.contains(i)) {\n-\t\t\t\t\treturn i;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn null;\n-\t}\n-\n-\t@Override\n-\tpublic Integer getCommonGIDOfGroupsWithSameNameInSameNamespace(PerunSessionImpl sess, List<Group> groupsWithSameGroupNameInSameNamespace, String gidNamespace, Integer commonGID) throws InternalErrorException, WrongAttributeAssignmentException {\n-\t\t//If there are no groups, return commonGID from param (it can be null)\n-\t\tif(groupsWithSameGroupNameInSameNamespace == null || groupsWithSameGroupNameInSameNamespace.isEmpty()) return commonGID;\n-\t\tUtils.notNull(gidNamespace, \"gidNamespace\");\n-\n-\t\tGroup commonGIDGroup = null;  //only for more verbose exception messages\n-\t\tfor(Group g: groupsWithSameGroupNameInSameNamespace) {\n-\t\t\ttry {\n-\t\t\t\tAttribute attr = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, g, A_G_unixGID_namespace + \":\" + gidNamespace);\n-\t\t\t\tif(attr.getValue() != null) {\n-\t\t\t\t\tif(commonGID == null) {\n-\t\t\t\t\t\tcommonGIDGroup = g;\n-\t\t\t\t\t\tcommonGID = (Integer) attr.getValue();\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tif(!commonGID.equals(attr.getValue())) throw new ConsistencyErrorException(\"There are at least 1 groups/resources with same GroupName in same namespace but with different GID in same namespaces. Conflict found: \"  + g + \"(gid=\" + attr.getValue()+ \") and \" + commonGIDGroup + \"(gid=\" + commonGID + \")\");\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t} catch (AttributeNotExistsException ex) {\n-\t\t\t\tthrow new ConsistencyErrorException(ex);\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn commonGID;\n-\t}\n-\n-\t@Override\n-\tpublic Integer getCommonGIDOfResourcesWithSameNameInSameNamespace(PerunSessionImpl sess, List<Resource> resourcesWithSameGroupNameInSameNamespace, String gidNamespace, Integer commonGID) throws InternalErrorException, WrongAttributeAssignmentException {\n-\t\t//If there are no resources, return commonGID from param (it can be null)\n-\t\tif(resourcesWithSameGroupNameInSameNamespace == null || resourcesWithSameGroupNameInSameNamespace.isEmpty()) return commonGID;\n-\t\tUtils.notNull(gidNamespace,\"gidNamespace\");\n-\n-\t\tResource commonGIDResource = null;   //only for more verbose exception messages\n-\t\tfor(Resource r: resourcesWithSameGroupNameInSameNamespace) {\n-\t\t\ttry {\n-\t\t\t\tAttribute attr = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, r, A_R_unixGID_namespace + \":\" + gidNamespace);\n-\t\t\t\tif(attr.getValue() != null) {\n-\t\t\t\t\tif(commonGID == null) {\n-\t\t\t\t\t\tcommonGIDResource = r;\n-\t\t\t\t\t\tcommonGID = (Integer) attr.getValue();\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tif(!commonGID.equals(attr.getValue())) throw new ConsistencyErrorException(\"There are at least 1 groups/resources with same GroupName in same namespace but with different GID in same namespaces. Conflict found: \" + r + \"(gid=\" + attr.getValue()+ \") and \" + commonGIDResource + \"(gid=\" + commonGID + \")\");\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t} catch (AttributeNotExistsException ex) {\n-\t\t\t\tthrow new ConsistencyErrorException(ex);\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn commonGID;\n-\t}\n-\n-\t@Override\n-\tpublic int haveTheSameAttributeWithTheSameNamespace(PerunSessionImpl sess, Group group, Attribute attr) throws InternalErrorException, WrongAttributeAssignmentException {\n-\t\tUtils.notNull(group, \"group\");\n-\t\tUtils.notNull(attr, \"attr\");\n-\n-\t\tString attributeNamespace = attr.getFriendlyNameParameter();\n-\t\tif(attributeNamespace == null || attributeNamespace.isEmpty()) throw new InternalErrorException(\"Attribute has no namespace, this method can't be use.\");\n-\n-\t\ttry {\n-\t\t\tAttribute testingAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, group, attr.getName());\n-\t\t\tif(testingAttribute.getValue() == null) return -1;\n-\t\t\telse {\n-\t\t\t\tif(!testingAttribute.getValue().equals(attr.getValue())) return 1;\n-\t\t\t}\n-\t\t} catch (AttributeNotExistsException ex) {\n-\t\t\tthrow new ConsistencyErrorException(ex);\n-\t\t}\n-\t\treturn 0;\n-\t}\n-\n-\t@Override\n-\tpublic int haveTheSameAttributeWithTheSameNamespace(PerunSessionImpl sess, Resource resource, Attribute attr) throws InternalErrorException, WrongAttributeAssignmentException{\n-\t\tUtils.notNull(resource, \"resource\");\n-\t\tUtils.notNull(attr, \"attr\");\n-\n-\t\tString attributeNamespace = attr.getFriendlyNameParameter();\n-\t\tif(attributeNamespace == null || attributeNamespace.isEmpty()) throw new InternalErrorException(\"Attribute has no namespace, this method can't be use.\");\n-\n-\t\ttry {\n-\t\t\tAttribute testingAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, resource, attr.getName());\n-\t\t\tif(testingAttribute.getValue() == null) return -1;\n-\t\t\telse {\n-\t\t\t\tif(!testingAttribute.getValue().equals(attr.getValue())) return 1;\n-\t\t\t}\n-\t\t} catch (AttributeNotExistsException ex) {\n-\t\t\tthrow new ConsistencyErrorException(ex);\n-\t\t}\n-\t\treturn 0;\n-\t}\n-\n-\t@Override\n-\tpublic boolean haveRightToWriteAttributeInAnyGroupOrResource(PerunSessionImpl sess, List<Group> groups, List<Resource> resources, AttributeDefinition groupAttribute, AttributeDefinition resourceAttribute) throws InternalErrorException {\n-\t\tif(groups != null && !groups.isEmpty() && groupAttribute != null) {\n-\t\t\tfor(Group g: groups) {\n-\t\t\t\tif(AuthzResolver.isAuthorizedForAttribute(sess, ActionType.WRITE, groupAttribute, g)) return true;\n-\t\t\t}\n-\t\t}\n-\n-\t\tif(resources != null && !resources.isEmpty() && resourceAttribute != null) {\n-\t\t\tfor(Resource r: resources) {\n-\t\t\t\tif(AuthzResolver.isAuthorizedForAttribute(sess, ActionType.WRITE, resourceAttribute, r)) return true;\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn false;\n-\t}\n-\n-\t@Override\n-\tpublic List<Attribute> getListOfResourceGIDsFromListOfGroupGIDs(PerunSessionImpl sess, List<Attribute> groupGIDs) throws InternalErrorException, AttributeNotExistsException {\n-\t\tList<Attribute> resourceGIDs = new ArrayList<>();\n-\t\tif(groupGIDs == null || groupGIDs.isEmpty()) {\n-\t\t\treturn resourceGIDs;\n-\t\t}\n-\n-\t\tfor(Attribute a: groupGIDs) {\n-\t\t\tAttribute resourceGID = new Attribute(sess.getPerunBl().getAttributesManagerBl().getAttributeDefinition(sess, A_R_unixGID_namespace + \":\" + a.getFriendlyNameParameter()));\n-\t\t\tresourceGID.setValue(a.getValue());\n-\t\t\tresourceGIDs.add(resourceGID);\n-\t\t}\n-\n-\t\treturn resourceGIDs;\n-\t}\n-\n-\t@Override\n-\tpublic List<Attribute> getListOfGroupGIDsFromListOfResourceGIDs(PerunSessionImpl sess, List<Attribute> resourceGIDs) throws InternalErrorException, AttributeNotExistsException {\n-\t\tList<Attribute> groupGIDs = new ArrayList<>();\n-\t\tif(resourceGIDs == null || resourceGIDs.isEmpty()) {\n-\t\t\treturn groupGIDs;\n-\t\t}\n-\n-\t\tfor(Attribute a: resourceGIDs) {\n-\t\t\tAttribute groupGID = new Attribute(sess.getPerunBl().getAttributesManagerBl().getAttributeDefinition(sess, A_G_unixGID_namespace + \":\" + a.getFriendlyNameParameter()));\n-\t\t\tgroupGID.setValue(a.getValue());\n-\t\t\tgroupGIDs.add(groupGID);\n-\t\t}\n-\n-\t\treturn groupGIDs;\n-\t}\n-\n-\t@Override\n-\tpublic Set<String> getSetOfGIDNamespacesWhereFacilitiesHasTheSameGroupNameNamespace(PerunSessionImpl sess, List<Facility> facilities, Attribute unixGroupNameNamespace) throws InternalErrorException, WrongAttributeAssignmentException {\n-\t\tSet<String> gidNamespaces = new HashSet<>();\n-\t\tif(facilities == null || facilities.isEmpty()) return gidNamespaces;\n-\t\tUtils.notNull(facilities, \"facilities\");\n-\n-\t\tfor(Facility f: facilities) {\n-\t\t\tAttribute facilityGroupNameNamespace;\n-\t\t\ttry {\n-\t\t\t\tfacilityGroupNameNamespace = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, f, A_F_unixGroupName_namespace);\n-\t\t\t\tif(facilityGroupNameNamespace.getValue() != null) {\n-\t\t\t\t\t//if they are same, save GID-namespace from this facility to hashSet\n-\t\t\t\t\tif(unixGroupNameNamespace.getFriendlyNameParameter().equals(facilityGroupNameNamespace.getValue())) {\n-\t\t\t\t\t\tAttribute facilityGIDNamespace = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, f, A_F_unixGID_namespace);\n-\t\t\t\t\t\t//If facilityGIDNamespace exists and is not null, save to the hashSet of gidNamespaces\n-\t\t\t\t\t\tif(facilityGIDNamespace.getValue() != null) {\n-\t\t\t\t\t\t\tgidNamespaces.add((String) facilityGIDNamespace.getValue());\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t} catch (AttributeNotExistsException ex) {\n-\t\t\t\tthrow new ConsistencyErrorException(ex);\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn gidNamespaces;\n-\t}\n-\n-\t@Override\n-\tpublic Set<String> getSetOfGroupNameNamespacesWhereFacilitiesHasTheSameGIDNamespace(PerunSessionImpl sess, List<Facility> facilities, Attribute unixGIDNamespace) throws InternalErrorException, WrongAttributeAssignmentException, WrongReferenceAttributeValueException {\n-\t\tSet<String> groupNameNamespaces = new HashSet<>();\n-\t\tif(facilities == null || facilities.isEmpty()) return groupNameNamespaces;\n-\t\tUtils.notNull(unixGIDNamespace, \"unixGIDNamespace\");\n-\n-\t\tfor(Facility f: facilities) {\n-\t\t\tAttribute facilityGIDNamespace;\n-\t\t\ttry {\n-\t\t\t\tfacilityGIDNamespace = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, f, A_F_unixGID_namespace);\n-\t\t\t\tif(facilityGIDNamespace.getValue() != null) {\n-\t\t\t\t\t//if they are same, save GroupName-namespace from this facility to hashSet\n-\t\t\t\t\tif(unixGIDNamespace.getFriendlyNameParameter().equals(facilityGIDNamespace.getValue())) {\n-\t\t\t\t\t\tAttribute facilityGroupNameNamespace = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, f, A_F_unixGroupName_namespace);\n-\t\t\t\t\t\t//If facilityGroupNameNamespace exists and is not null, save to the hashSet of gidNamespaces\n-\t\t\t\t\t\tif(facilityGroupNameNamespace.getValue() != null) {\n-\t\t\t\t\t\t\tgroupNameNamespaces.add((String) facilityGroupNameNamespace.getValue());\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tthrow new WrongReferenceAttributeValueException(unixGIDNamespace, facilityGroupNameNamespace, \"Facility has gidNamespace set, but groupNameNamespace not set.\");\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t} catch (AttributeNotExistsException ex) {\n-\t\t\t\tthrow new ConsistencyErrorException(ex);\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn groupNameNamespaces;\n-\t}\n-\n-\t@Override\n-\tpublic void checkReservedUnixGroupNames(Attribute groupNameAttribute) throws WrongAttributeValueException {\n-\t\tif(groupNameAttribute == null) return;\n-\t\tcheckPerunNamespacesMap();\n-\n-\t\tString reservedNames = perunNamespaces.get(groupNameAttribute.getFriendlyName() + \":reservedNames\");\n-\t\tif (reservedNames != null) {\n-\t\t\tList<String> reservedNamesList = Arrays.asList(reservedNames.split(\"\\\\s*,\\\\s*\"));\n-\t\t\tif (reservedNamesList.contains(groupNameAttribute.valueAsString()))\n-\t\t\t\tthrow new WrongAttributeValueException(groupNameAttribute, \"This groupName is reserved.\");\n-\t\t} else {\n-\t\t\t//Property not found in our attribute map, so we will use the default hardcoded values instead\n-\t\t\tif (reservedNamesForUnixGroups.contains(groupNameAttribute.valueAsString()))\n-\t\t\t\tthrow new WrongAttributeValueException(groupNameAttribute, \"This groupName is reserved.\");\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void checkUnpermittedUserLogins(Attribute loginAttribute) throws WrongAttributeValueException {\n-\t\tif(loginAttribute == null) return;\n-\t\tcheckPerunNamespacesMap();\n-\n-\t\tString unpermittedNames = perunNamespaces.get(loginAttribute.getFriendlyName() + \":reservedNames\");\n-\t\tif (unpermittedNames != null) {\n-\t\t\tList<String> unpermittedNamesList = Arrays.asList(unpermittedNames.split(\"\\\\s*,\\\\s*\"));\n-\t\t\tif (unpermittedNamesList.contains(loginAttribute.valueAsString()))\n-\t\t\t\tthrow new WrongAttributeValueException(loginAttribute, \"This login is not permitted.\");\n-\t\t} else {\n-\t\t\t//Property not found in our attribute map, so we will use the default hardcoded values instead\n-\t\t\tif (unpermittedNamesForUserLogins.contains(loginAttribute.valueAsString()))\n-\t\t\t\tthrow new WrongAttributeValueException(loginAttribute, \"This login is not permitted.\");\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic Attribute getGoogleGroupNameNamespaceAttributeWithNotNullValue(PerunSessionImpl sess, Resource resource) throws InternalErrorException, WrongReferenceAttributeValueException {\n-\t\tFacility facility = sess.getPerunBl().getResourcesManagerBl().getFacility(sess, resource);\n-\t\ttry {\n-\t\t\tAttribute googleGroupNameNamespaceAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, facility, A_F_googleGroupsDomain);\n-\t\t\tif(googleGroupNameNamespaceAttribute.getValue() == null) throw new WrongReferenceAttributeValueException(googleGroupNameNamespaceAttribute);\n-\t\t\treturn googleGroupNameNamespaceAttribute;\n-\t\t} catch(AttributeNotExistsException ex) {\n-\t\t\tthrow new ConsistencyErrorException(ex);\n-\t\t} catch(WrongAttributeAssignmentException ex) {\n-\t\t\tthrow new InternalErrorException(ex);\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic Attribute getUnixGroupNameNamespaceAttributeWithNotNullValue(PerunSessionImpl sess, Resource resource) throws InternalErrorException, WrongReferenceAttributeValueException {\n-\t\tFacility facility = sess.getPerunBl().getResourcesManagerBl().getFacility(sess, resource);\n-\t\ttry {\n-\t\t\tAttribute unixGroupNameNamespaceAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, facility, A_F_unixGroupName_namespace);\n-\t\t\tif(unixGroupNameNamespaceAttribute.getValue() == null) throw new WrongReferenceAttributeValueException(unixGroupNameNamespaceAttribute);\n-\t\t\treturn unixGroupNameNamespaceAttribute;\n-\t\t} catch(AttributeNotExistsException ex) {\n-\t\t\tthrow new ConsistencyErrorException(ex);\n-\t\t} catch(WrongAttributeAssignmentException ex) {\n-\t\t\tthrow new InternalErrorException(ex);\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic Attribute getUnixGIDNamespaceAttributeWithNotNullValue(PerunSessionImpl sess, Resource resource) throws InternalErrorException, WrongReferenceAttributeValueException {\n-\t\tFacility facility = sess.getPerunBl().getResourcesManagerBl().getFacility(sess, resource);\n-\t\ttry {\n-\t\t\tAttribute unixGIDNamespaceAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, facility, A_F_unixGID_namespace);\n-\t\t\tif(unixGIDNamespaceAttribute.getValue() == null) throw new WrongReferenceAttributeValueException(unixGIDNamespaceAttribute);\n-\t\t\treturn unixGIDNamespaceAttribute;\n-\t\t} catch(AttributeNotExistsException ex) {\n-\t\t\tthrow new ConsistencyErrorException(ex);\n-\t\t} catch(WrongAttributeAssignmentException ex) {\n-\t\t\tthrow new InternalErrorException(ex);\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic boolean isGroupUnixGIDNamespaceFillable(PerunSessionImpl sess, Group group, Attribute groupUnixGIDNamespace) throws InternalErrorException, WrongReferenceAttributeValueException, WrongAttributeAssignmentException {\n-\t\tUtils.notNull(group, \"group\");\n-\t\tUtils.notNull(groupUnixGIDNamespace, \"groupUnixGIDNamespace\");\n-\n-\t\t//Get All Facilities from group\n-\t\tSet<Facility> facilitiesOfGroup = new HashSet<>();\n-\t\tList<Resource> resourcesOfGroup = sess.getPerunBl().getResourcesManagerBl().getAssignedResources(sess, group);\n-\t\tfor(Resource r: resourcesOfGroup) {\n-\t\t\tfacilitiesOfGroup.add(sess.getPerunBl().getResourcesManagerBl().getFacility(sess, r));\n-\t\t}\n-\n-\t\t//Prepare list of gid namespaces of all facilities which have the same groupName namespace like this unixGroupName namespace\n-\t\tSet<String> groupNameNamespaces = this.getSetOfGroupNameNamespacesWhereFacilitiesHasTheSameGIDNamespace(sess, new ArrayList<>(facilitiesOfGroup), groupUnixGIDNamespace);\n-\n-\t\tif(!groupNameNamespaces.isEmpty()) {\n-\t\t\tfor(String s: groupNameNamespaces) {\n-\t\t\t\ttry {\n-\t\t\t\t\tAttribute groupNameNamespace = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, group, A_G_unixGroupName_namespace + \":\" + s);\n-\t\t\t\t\tif(groupNameNamespace.getValue() != null) {\n-\t\t\t\t\t\treturn true;\n-\t\t\t\t\t}\n-\t\t\t\t} catch (AttributeNotExistsException ex) {\n-\t\t\t\t\tthrow new ConsistencyErrorException(ex);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn false;\n-\t}\n-\n-\t@Override\n-\tpublic boolean isNameOfEmailValid(PerunSessionImpl sess, String email) {\n-\t\tif (email == null) return false;\n-\n-\t\tMatcher emailMatcher = Utils.emailPattern.matcher(email);\n-\t\treturn emailMatcher.find();\n-\t}\n-\n-\t@Override\n-\tpublic void checkFormatOfShell(String shell, Attribute attribute) throws WrongAttributeValueException {\n-\t\tMatcher match = shellPattern.matcher(shell);\n-\t\tif (!match.matches()) {\n-\t\t\tthrow new WrongAttributeValueException(attribute, \"Bad shell attribute format \" + shell);\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void checkAttributeRegex(Attribute attribute, Pattern defaultRegex) throws InternalErrorException, WrongAttributeValueException {\n-\t\tif (attribute == null || attribute.getValue() == null) throw new InternalErrorException(\"Attribute or it's value is null.\");\n-\t\tString attributeValue = (String) attribute.getValue();\n-\t\tcheckPerunNamespacesMap();\n-\n-\t\tString regex = perunNamespaces.get(attribute.getFriendlyName() + \":regex\");\n-\t\tif (regex != null) {\n-\t\t\t//Check if regex is valid\n-\t\t\ttry {\n-\t\t\t\tPattern.compile(regex);\n-\t\t\t} catch (PatternSyntaxException e) {\n-\t\t\t\tlog.error(\"Regex pattern \\\"\" + regex + \"\\\" from \\\"\" + attribute.getFriendlyName() + \":regex\\\"\" + \" property of perun-namespaces.properties file is invalid.\");\n-\t\t\t\tthrow new InternalErrorException(\"Regex pattern \\\"\" + regex + \"\\\" from \\\"\" + attribute.getFriendlyName() + \":regex\\\"\" + \" property of perun-namespaces.properties file is invalid.\");\n-\t\t\t}\n-\t\t\tif(!attributeValue.matches(regex)) {\n-\t\t\t\tthrow new WrongAttributeValueException(attribute, \"Wrong format. Regex: \\\"\" + regex +\"\\\" expected for this attribute:\");\n-\t\t\t}\n-\t\t} else {\n-\t\t\t//Regex property not found in our attribute map, so use the default hardcoded regex\n-\t\t\tif (!defaultRegex.matcher(attributeValue).matches()) {\n-\t\t\t\tthrow new WrongAttributeValueException(attribute, \"Wrong format. Regex: \\\"\" + defaultRegex +\"\\\" expected for this attribute:\");\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Internal protected method.\n-\t * Checks this.perunNamespaces map, which is always initialized as null.\n-\t * If null, it tries to load the configuration into this map from a perun-namespaces.properties file.\n-\t * If the file does not exist, it creates an empty HashMap, so it's not null anymore.\n-\t */\n-\tprotected void checkPerunNamespacesMap() {\n-\t\tif (perunNamespaces == null) {\n-\t\t\ttry {\n-\t\t\t\tperunNamespaces = BeansUtils.getAllPropertiesFromCustomConfiguration(\"perun-namespaces.properties\");\n-\t\t\t} catch (InternalErrorException e) {\n-\t\t\t\tperunNamespaces = new HashMap<>();\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void checkIfQuotasIsInLimit(Map<String, Pair<BigDecimal, BigDecimal>> quotaToCheck, Map<String, Pair<BigDecimal, BigDecimal>> limitQuota) throws InternalErrorException {\n-\t\tif(quotaToCheck == null) throw new InternalErrorException(\"Quota to check can't be null.\");\n-\t\tif(limitQuota == null) throw new InternalErrorException(\"Limit quota can't be null.\");\n-\n-\t\t//If there is no value to check, then everything is in limit (we don't need to limit anything)\n-\t\tif(quotaToCheck.isEmpty()) return;\n-\n-\t\t//test every record of quotaToCheck against record in limitQuota\n-\t\tfor(String volumeToCheck: quotaToCheck.keySet()) {\n-\t\t\tif(!limitQuota.containsKey(volumeToCheck)) {\n-\t\t\t\tthrow new QuotaNotInAllowedLimitException(quotaToCheck, limitQuota, \"Volume \" + volumeToCheck + \" is missing in limitQuota.\");\n-\t\t\t}\n-\n-\t\t\tPair<BigDecimal, BigDecimal> volumeToCheckQuotas = quotaToCheck.get(volumeToCheck);\n-\t\t\tPair<BigDecimal, BigDecimal> volumeToCheckLimitQuotas = limitQuota.get(volumeToCheck);\n-\n-\t\t\t//Check limit of softQuota, zero limit means unlimited so no need for testing\n-\t\t\tif(volumeToCheckLimitQuotas.getLeft().compareTo(BigDecimal.ZERO) != 0) {\n-\t\t\t\tif (volumeToCheckQuotas.getLeft().compareTo(BigDecimal.ZERO) == 0 || volumeToCheckQuotas.getLeft().compareTo(volumeToCheckLimitQuotas.getLeft()) > 0) {\n-\t\t\t\t\tthrow new QuotaNotInAllowedLimitException(quotaToCheck, limitQuota, \"SoftQuota of volume \" + volumeToCheck + \" is bigger than limit.\");\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t//Check limit of hardQuota, zero limit means unlimited so no need for testing\n-\t\t\tif(volumeToCheckLimitQuotas.getRight().compareTo(BigDecimal.ZERO) != 0) {\n-\t\t\t\tif (volumeToCheckQuotas.getRight().compareTo(BigDecimal.ZERO) == 0 || volumeToCheckQuotas.getRight().compareTo(volumeToCheckLimitQuotas.getRight()) > 0) {\n-\t\t\t\t\tthrow new QuotaNotInAllowedLimitException(quotaToCheck, limitQuota, \"HardQuota of volume \" + volumeToCheck + \" is bigger than limit.\");\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic Map<String, Pair<BigDecimal, BigDecimal>> checkAndTransferQuotas(Attribute quotasAttribute, PerunBean firstPlaceholder, PerunBean secondPlaceholder, boolean withMetrics) throws InternalErrorException, WrongAttributeValueException {\n-\t\t//firstPlaceholder can't be null\n-\t\tif(firstPlaceholder == null) throw new InternalErrorException(\"Missing first mandatory placeHolder (PerunBean).\");\n-\t\t//If quotas attribute is null or it's value is empty, return empty hash map\n-\t\tif(quotasAttribute == null || quotasAttribute.getValue() == null) return new LinkedHashMap<>();\n-\n-\t\t//Prepare result container and value of attribute\n-\t\tMap<String, Pair<BigDecimal, BigDecimal>> transferedQuotas = new LinkedHashMap<>();\n-\t\tMap<String, String> defaultQuotasMap = quotasAttribute.valueAsMap();\n-\n-\t\t//List to test if all paths are unique (/var/log and /var/log/ are the same so these two paths are not unique)\n-\t\tList<String> uniquePaths = new ArrayList<>();\n-\t\tfor(String path: defaultQuotasMap.keySet()) {\n-\t\t\t//null is not correct path for volume on File System\n-\t\t\tif(path == null || path.isEmpty()) throw new WrongAttributeValueException(quotasAttribute, firstPlaceholder, secondPlaceholder, \"The path of some volume where quota should be set is null.\");\n-\n-\t\t\t//testing if path is unique\n-\t\t\tString canonicalPath;\n-\t\t\ttry {\n-\t\t\t\tcanonicalPath = new URI(path).normalize().getPath();\n-\t\t\t\t//path should not end on '/' (problem with some systems as GPFS)\n-\t\t\t\tif(!canonicalPath.equals(\"/\") && canonicalPath.endsWith(\"/\")) canonicalPath = canonicalPath.substring(0, canonicalPath.length() - 1);\n-\t\t\t} catch (URISyntaxException ex) {\n-\t\t\t\tthrow new WrongAttributeValueException(quotasAttribute, firstPlaceholder, secondPlaceholder, \"Path '\" + path + \"' is not correct form.\");\n-\t\t\t}\n-\n-\t\t\tif(uniquePaths.contains(canonicalPath)) throw new WrongAttributeValueException(quotasAttribute, firstPlaceholder, secondPlaceholder, \"Paths are not unique, there are two same paths: \" + path);\n-\t\t\telse uniquePaths.add(canonicalPath);\n-\n-\t\t\tString quota = defaultQuotasMap.get(path);\n-\t\t\t//quota can't be null, if exists in attribute, must be set in some way\n-\t\t\tif(quota == null) throw new WrongAttributeValueException(quotasAttribute, firstPlaceholder, secondPlaceholder, \"The quota of some volume where quota should be set is null.\");\n-\n-\t\t\t//check format of quota parameter (for data with metrics, for count of files without metrics)\n-\t\t\tMatcher quotaMatcher;\n-\t\t\tif(withMetrics) {\n-\t\t\t\tquotaMatcher = ModulesUtilsBlImpl.quotaWithMetricsPattern.matcher(quota);\n-\t\t\t\tif(!quotaMatcher.matches()) throw new WrongAttributeValueException(quotasAttribute, firstPlaceholder, secondPlaceholder, \"Format of quota in quotas attribute is not correct.\");\n-\t\t\t} else {\n-\t\t\t\tquotaMatcher = ModulesUtilsBlImpl.quotaWithoutMetricsPattern.matcher(quota);\n-\t\t\t\tif(!quotaMatcher.matches()) throw new WrongAttributeValueException(quotasAttribute, firstPlaceholder, secondPlaceholder, \"Format of quota in quotas attribute is not correct.\");\n-\t\t\t}\n-\n-\t\t\t//Parse quotas to variables\n-\t\t\tString softQuota = quotaMatcher.group(1);\n-\t\t\tString hardQuota = quotaMatcher.group(3);\n-\n-\t\t\t//Parse number pattern and letter pattern from whole quotas\n-\n-\t\t\t//SoftQuotaNumber\n-\t\t\tBigDecimal softQuotaAfterTransfer;\n-\t\t\tBigDecimal hardQuotaAfterTransfer;\n-\t\t\t//special behavior with metrics\n-\t\t\tif(withMetrics) {\n-\t\t\t\tMatcher numberMatcher = numberPattern.matcher(softQuota);\n-\t\t\t\tif(!numberMatcher.find()) throw new ConsistencyErrorException(\"Matcher can't find number in softQuota '\" + softQuota + \"' in attribute \" + quotasAttribute);\n-\t\t\t\tString softQuotaNumber = numberMatcher.group();\n-\n-\t\t\t\t//SoftQuotaLetter\n-\t\t\t\tString softQuotaLetter;\n-\t\t\t\tMatcher letterMatcher = letterPattern.matcher(softQuota);\n-\t\t\t\t//in this case no letter means default and default is G\n-\t\t\t\tif(!letterMatcher.find()) softQuotaLetter = \"G\";\n-\t\t\t\telse softQuotaLetter = letterMatcher.group();\n-\n-\t\t\t\t//HardQuotaNumber\n-\t\t\t\tnumberMatcher = numberPattern.matcher(hardQuota);\n-\t\t\t\tif(!numberMatcher.find()) throw new ConsistencyErrorException(\"Matcher can't find number in hardQuota '\" + hardQuota + \"' in attribute \" + quotasAttribute);\n-\t\t\t\tString hardQuotaNumber = numberMatcher.group();\n-\n-\t\t\t\t//HardQuotaLetter\n-\t\t\t\tString hardQuotaLetter;\n-\t\t\t\tletterMatcher = letterPattern.matcher(hardQuota);\n-\t\t\t\t//in this case no letter means default and default is G\n-\t\t\t\tif(!letterMatcher.find()) hardQuotaLetter = \"G\";\n-\t\t\t\telse hardQuotaLetter = letterMatcher.group();\n-\n-\t\t\t\t//Prepare whole big decimal numbers\n-\t\t\t\tsoftQuotaAfterTransfer = new BigDecimal(softQuotaNumber);\n-\t\t\t\thardQuotaAfterTransfer = new BigDecimal(hardQuotaNumber);\n-\n-\t\t\t\t//multiplying for softQuota\n-\t\t\t\tswitch (softQuotaLetter) {\n-\t\t\t\t\tcase \"K\":\n-\t\t\t\t\t\tbreak; //K is basic metric, no need to multiply it\n-\t\t\t\t\tcase \"G\":\n-\t\t\t\t\t\tsoftQuotaAfterTransfer = softQuotaAfterTransfer.multiply(BigDecimal.valueOf(G));\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\tcase \"M\":\n-\t\t\t\t\t\tsoftQuotaAfterTransfer = softQuotaAfterTransfer.multiply(BigDecimal.valueOf(M));\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\tcase \"T\":\n-\t\t\t\t\t\tsoftQuotaAfterTransfer = softQuotaAfterTransfer.multiply(BigDecimal.valueOf(T));\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\tcase \"P\":\n-\t\t\t\t\t\tsoftQuotaAfterTransfer = softQuotaAfterTransfer.multiply(BigDecimal.valueOf(P));\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\tcase \"E\":\n-\t\t\t\t\t\tsoftQuotaAfterTransfer = softQuotaAfterTransfer.multiply(BigDecimal.valueOf(E));\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\tdefault:\n-\t\t\t\t\t\tthrow new ConsistencyErrorException(\"There is not allowed character in soft quota letter '\" + softQuotaLetter + \"'.\");\n-\t\t\t\t}\n-\n-\t\t\t\t//multiplying for softQuota\n-\t\t\t\tswitch (hardQuotaLetter) {\n-\t\t\t\t\tcase \"K\":\n-\t\t\t\t\t\tbreak; //K is basic metric, no need to multiply it\n-\t\t\t\t\tcase \"G\":\n-\t\t\t\t\t\thardQuotaAfterTransfer = hardQuotaAfterTransfer.multiply(BigDecimal.valueOf(G));\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\tcase \"M\":\n-\t\t\t\t\t\thardQuotaAfterTransfer = hardQuotaAfterTransfer.multiply(BigDecimal.valueOf(M));\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\tcase \"T\":\n-\t\t\t\t\t\thardQuotaAfterTransfer = hardQuotaAfterTransfer.multiply(BigDecimal.valueOf(T));\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\tcase \"P\":\n-\t\t\t\t\t\thardQuotaAfterTransfer = hardQuotaAfterTransfer.multiply(BigDecimal.valueOf(P));\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\tcase \"E\":\n-\t\t\t\t\t\thardQuotaAfterTransfer = hardQuotaAfterTransfer.multiply(BigDecimal.valueOf(E));\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\tdefault:\n-\t\t\t\t\t\tthrow new ConsistencyErrorException(\"There is not allowed character in hard quota letter '\" + hardQuotaLetter + \"'.\");\n-\t\t\t\t}\n-\t\t\t//easy way without metrics\n-\t\t\t} else {\n-\t\t\t\tsoftQuotaAfterTransfer = new BigDecimal(softQuota);\n-\t\t\t\thardQuotaAfterTransfer = new BigDecimal(hardQuota);\n-\t\t\t}\n-\n-\t\t\t//test comparing softQuota and hardQuota (softQuota must be less or equals than hardQuota, 0 means unlimited)\n-\t\t\t//1] if softQuota is unlimited, but hardQuota not = exception\n-\t\t\tif(softQuotaAfterTransfer.compareTo(BigDecimal.valueOf(0)) == 0 && hardQuotaAfterTransfer.compareTo(BigDecimal.valueOf(0)) != 0) {\n-\t\t\t\tthrow new WrongAttributeValueException(quotasAttribute, firstPlaceholder, secondPlaceholder, \"SoftQuota is set to unlimited (0) but hardQuota is limited to '\" + hardQuota + \"'.\");\n-\t\t\t//2] if hardQuota is not unlimited but still it is less then softQuota = exception\n-\t\t\t} else if(hardQuotaAfterTransfer.compareTo(BigDecimal.valueOf(0)) != 0 && hardQuotaAfterTransfer.compareTo(softQuotaAfterTransfer) < 0) {\n-\t\t\t\tthrow new WrongAttributeValueException(quotasAttribute, firstPlaceholder, secondPlaceholder, \"One of quotas is not correct. HardQuota '\" + hardQuota + \"' is less then softQuota '\" + softQuota + \"'.\");\n-\t\t\t}\n-\t\t\t//other cases are ok\n-\n-\t\t\ttransferedQuotas.put(canonicalPath, new Pair<>(softQuotaAfterTransfer, hardQuotaAfterTransfer));\n-\t\t}\n-\n-\t\treturn transferedQuotas;\n-\t}\n-\n-\t@Override\n-\tpublic Map<String, String> transferQuotasBackToAttributeValue(Map<String, Pair<BigDecimal, BigDecimal>> transferedQuotasMap, boolean withMetrics) throws InternalErrorException {\n-\t\tMap<String, String> attributeQuotasValue = new LinkedHashMap<>();\n-\t\t//if null or empty, return empty attribute value map for quotas\n-\t\tif(transferedQuotasMap == null || transferedQuotasMap.isEmpty()) return attributeQuotasValue;\n-\n-\t\t//every path with quotas transfer step by step\n-\t\tfor(String path: transferedQuotasMap.keySet()) {\n-\t\t\tPair<BigDecimal, BigDecimal> quotas =  transferedQuotasMap.get(path);\n-\t\t\tBigDecimal softQuotaBD = quotas.getLeft();\n-\t\t\tBigDecimal hardQuotaBD = quotas.getRight();\n-\n-\t\t\t//Divide decimal till it is still natural number\n-\t\t\t//Soft Quota\n-\t\t\tString softQuota = \"0\";\n-\t\t\t//Zero means unlimited, stay the same\n-\t\t\tif(softQuotaBD.compareTo(BigDecimal.ZERO) != 0) {\n-\t\t\t\tif(withMetrics) softQuota = Utils.bigDecimalBytesToReadableStringWithMetric(softQuotaBD);\n-\t\t\t\telse softQuota = softQuotaBD.toPlainString();\n-\t\t\t}\n-\t\t\t//Hard Quota\n-\t\t\tString hardQuota = \"0\";\n-\t\t\t//Zero means unlimited, stay the same\n-\t\t\tif(hardQuotaBD.compareTo(BigDecimal.ZERO) != 0) {\n-\t\t\t\tif(withMetrics) hardQuota = Utils.bigDecimalBytesToReadableStringWithMetric(hardQuotaBD);\n-\t\t\t\telse hardQuota = hardQuotaBD.toPlainString();\n-\t\t\t}\n-\n-\t\t\t//add softQuota and hardQuota to result (50T:60T)\n-\t\t\tattributeQuotasValue.put(path, softQuota + \":\" + hardQuota);\n-\t\t}\n-\t\treturn attributeQuotasValue;\n-\t}\n-\n-\t@Override\n-\tpublic Map<String,Pair<BigDecimal, BigDecimal>> mergeMemberAndResourceTransferredQuotas(Map<String, Pair<BigDecimal, BigDecimal>> resourceQuotas, Map<String, Pair<BigDecimal, BigDecimal>> memberResourceQuotas, Map<String, Pair<BigDecimal, BigDecimal>> quotasOverride) {\n-\t\tMap<String,Pair<BigDecimal, BigDecimal>> mergedTransferedQuotas = new LinkedHashMap<>();\n-\n-\t\t//first go through member-resource quotas values\n-\t\tfor(String path: memberResourceQuotas.keySet()) {\n-\t\t\t//override has the highest priority\n-\t\t\tif (quotasOverride.containsKey(path)) {\n-\t\t\t\tmergedTransferedQuotas.put(path, quotasOverride.get(path));\n-\t\t\t} else {\n-\t\t\t\t//if override not exists, take the original value\n-\t\t\t\tmergedTransferedQuotas.put(path, memberResourceQuotas.get(path));\n-\t\t\t}\n-\t\t}\n-\n-\t\t//save unique values from resource quotas (not exists in member-resource quotas)\n-\t\tfor(String path: resourceQuotas.keySet()) {\n-\t\t\t//skip already saved values, they are not unique\n-\t\t\tif(mergedTransferedQuotas.containsKey(path)) continue;\n-\n-\t\t\t//take override if exists\n-\t\t\tif(quotasOverride.containsKey(path)) {\n-\t\t\t\tmergedTransferedQuotas.put(path, quotasOverride.get(path));\n-\t\t\t} else {\n-\t\t\t\tmergedTransferedQuotas.put(path, resourceQuotas.get(path));\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn mergedTransferedQuotas;\n-\t}\n-\n-\t@Override\n-\tpublic Map<String, Pair<BigDecimal, BigDecimal>> countUserFacilityQuotas(List<Map<String, Pair<BigDecimal, BigDecimal>>> allUserQuotas) {\n-\t\tMap<String, Pair<BigDecimal, BigDecimal>> resultTransferredQuotas = new LinkedHashMap<>();\n-\t\t//for every transfered map of merged quotas count one result transfered map\n-\t\tfor(Map<String, Pair<BigDecimal, BigDecimal>> mapValue : allUserQuotas) {\n-\t\t\t//for every path in one transfered map\n-\t\t\tfor(String pathKey: mapValue.keySet()) {\n-\t\t\t\t//if path not exists in result map, add it with it's values\n-\t\t\t\tif(!resultTransferredQuotas.containsKey(pathKey)) {\n-\t\t\t\t\tresultTransferredQuotas.put(pathKey, mapValue.get(pathKey));\n-\t\t\t\t//if path already exists in result map, sum their quotas together\n-\t\t\t\t} else {\n-\t\t\t\t\tPair<BigDecimal, BigDecimal> quotasValue1 = resultTransferredQuotas.get(pathKey);\n-\t\t\t\t\tPair<BigDecimal, BigDecimal> quotasValue2 = mapValue.get(pathKey);\n-\t\t\t\t\t//for soft quota (left part of pair)\n-\t\t\t\t\tBigDecimal softQuota = BigDecimal.ZERO;\n-\t\t\t\t\tif(quotasValue1.getLeft().compareTo(BigDecimal.ZERO) != 0 && quotasValue2.getLeft().compareTo(BigDecimal.ZERO) != 0) {\n-\t\t\t\t\t\tsoftQuota = quotasValue1.getLeft().add(quotasValue2.getLeft());\n-\t\t\t\t\t}\n-\t\t\t\t\t//for hard quota (right part of pair)\n-\t\t\t\t\tBigDecimal hardQuota = BigDecimal.ZERO;\n-\t\t\t\t\tif(quotasValue1.getRight().compareTo(BigDecimal.ZERO) != 0 && quotasValue2.getRight().compareTo(BigDecimal.ZERO) != 0) {\n-\t\t\t\t\t\thardQuota = quotasValue1.getRight().add(quotasValue2.getRight());\n-\t\t\t\t\t}\n-\t\t\t\t\t//create new pair of summed numbers\n-\t\t\t\t\tPair<BigDecimal, BigDecimal> finalQuotasValue = new Pair<>(softQuota, hardQuota);\n-\t\t\t\t\t//add new summed pair to the result map\n-\t\t\t\t\tresultTransferredQuotas.put(pathKey, finalQuotasValue);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\t//return result map\n-\t\treturn resultTransferredQuotas;\n-\t}\n-\n-\t@Override\n-\tpublic boolean isFQDNValid(PerunSessionImpl sess, String fqdn) {\n-\t\tif (fqdn == null) return false;\n-\t\tMatcher fqdnMatcher = fqdnPattern.matcher(fqdn);\n-\t\treturn fqdnMatcher.find();\n-\t}\n-\n-\t/**\n-\t * Normalize string for purpose of generating safe login value.\n-\t *\n-\t * @return normalized string\n-\t */\n-\tpublic static String normalizeStringForLogin(String toBeNormalized) {\n-\n-\t\tif (toBeNormalized == null || toBeNormalized.trim().isEmpty()) return null;\n-\n-\t\ttoBeNormalized = toBeNormalized.toLowerCase();\n-\t\ttoBeNormalized = java.text.Normalizer.normalize(toBeNormalized, java.text.Normalizer.Form.NFD).replaceAll(\"\\\\p{InCombiningDiacriticalMarks}+\",\"\");\n-\t\ttoBeNormalized = toBeNormalized.replaceAll(\"[^a-zA-Z]+\", \"\");\n-\n-\t\t// unable to fill login for users without name or with partial name\n-\t\tif (toBeNormalized.isEmpty()) {\n-\t\t\treturn null;\n-\t\t}\n-\n-\t\treturn toBeNormalized;\n-\n-\t}\n-\n-\t/**\n-\t * Shared logic for purpose of login generation\n-\t */\n-\tpublic static class LoginGenerator {\n-\n-\t\t/**\n-\t\t * Define joining function for anonymous classes\n-\t\t */\n-\t\tpublic interface LoginGeneratorFunction {\n-\n-\t\t\t/**\n-\t\t\t * Generate login for user using his name.\n-\t\t\t * Implementation must handle empty/null input on both fields.\n-\t\t\t *\n-\t\t\t * @param firstName\n-\t\t\t * @param lastName\n-\t\t\t * @return generated login\n-\t\t\t */\n-\t\t\tString generateLogin(String firstName, String lastName);\n-\n-\t\t}\n-\n-\t\t/**\n-\t\t * Generate login for user using his name and joining function\n-\t\t *\n-\t\t * @param user User to get data from\n-\t\t * @param function Function to join fist/lastName to login\n-\t\t * @return generated login\n-\t\t */\n-\t\tpublic String generateLogin(User user, LoginGeneratorFunction function) {\n-\n-\t\t\tString firstName = user.getFirstName();\n-\t\t\tString lastName = user.getLastName();\n-\n-\t\t\t// get only first part of first name and remove spec. chars\n-\t\t\tif (firstName != null && !firstName.isEmpty()) {\n-\t\t\t\tfirstName = ModulesUtilsBlImpl.normalizeStringForLogin(firstName.split(\" \")[0]);\n-\t\t\t}\n-\n-\t\t\t// get only last part of last name and remove spec. chars\n-\t\t\tif (lastName != null && !lastName.isEmpty()) {\n-\t\t\t\tList<String> names = Arrays.asList(lastName.split(\" \"));\n-\t\t\t\tlastName = names.get(names.size() - 1);\n-\t\t\t\tlastName = ModulesUtilsBlImpl.normalizeStringForLogin(lastName.split(\" \")[0]);\n-\t\t\t}\n-\n-\t\t\treturn function.generateLogin(firstName, lastName);\n-\n-\t\t}\n-\n-\t}\n-\n-\t@Override\n-\tpublic User getUserFromMessage(PerunSessionImpl sess, String message) throws InternalErrorException {\n-\t\tList<PerunBean> perunBeans = AuditParser.parseLog(message);\n-\n-\t\tUser user = null;\n-\t\tUserExtSource userExtSource = null;\n-\t\tMember member = null;\n-\n-\t\tfor(PerunBean perunBean: perunBeans) {\n-\t\t\tif(perunBean instanceof User) {\n-\t\t\t\tuser = (User) perunBean;\n-\t\t\t\tbreak;\n-\t\t\t} else if (perunBean instanceof UserExtSource && userExtSource == null) {\n-\t\t\t\tuserExtSource = (UserExtSource) perunBean;\n-\t\t\t} else if (perunBean instanceof Member && member == null) {\n-\t\t\t\tmember = (Member) perunBean;\n-\t\t\t}\n-\t\t}\n-\n-\t\t//if we don't have object user, try to parse user id from userExtSource (-1 means no userId was defined)\n-\t\tif(user == null && userExtSource != null && userExtSource.getUserId() != -1) {\n-\t\t\ttry {\n-\t\t\t\tuser = getPerunBl().getUsersManagerBl().getUserById(sess, userExtSource.getUserId());\n-\t\t\t} catch (UserNotExistsException ex) {\n-\t\t\t\tlog.warn(\"User from UserExtSource {} doesn't exist in Perun. This occurred while parsing message: {}.\", userExtSource, message);\n-\t\t\t\treturn null;\n-\t\t\t}\n-\t\t} else if (user == null && member != null) {\n-\t\t\ttry {\n-\t\t\t\tuser = getPerunBl().getUsersManagerBl().getUserById(sess, member.getUserId());\n-\t\t\t} catch (UserNotExistsException ex) {\n-\t\t\t\tlog.warn(\"User from Member {} doesn't exist in Perun. This occurred while parsing message: {}.\", member, message);\n-\t\t\t\treturn null;\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn user;\n-\t}\n-\n-\t@Override\n-\tpublic Map<Integer, Integer> checkAndConvertGIDRanges(Attribute gidRangesAttribute) throws InternalErrorException, WrongAttributeValueException {\n-\t\t//Prepare structure for better working with GID Ranges\n-\t\tMap<Integer, Integer> convertedRanges = new HashMap<>();\n-\n-\t\t//For null attribute throw an exception\n-\t\tif(gidRangesAttribute == null) throw new InternalErrorException(\"Can't get value from null attribute!\");\n-\n-\t\tMap<String, String> gidRanges = gidRangesAttribute.valueAsMap();\n-\n-\t\t//Return empty map if there is empty input of gidRanges in method parameters\n-\t\tif(gidRanges == null || gidRanges.isEmpty()) return convertedRanges;\n-\n-\t\t//Check every range if it is in correct format and it is valid range\n-\t\tfor(String minimumOfRange: gidRanges.keySet()) {\n-\t\t\t//Check not null\n-\t\t\tif(minimumOfRange == null || minimumOfRange.isEmpty()) throw new WrongAttributeValueException(gidRangesAttribute, \"Minimum in one of gid ranges is empty!\");\n-\t\t\tString maximumOfRange = gidRanges.get(minimumOfRange);\n-\t\t\tif(maximumOfRange == null || maximumOfRange.isEmpty()) throw new WrongAttributeValueException(gidRangesAttribute, \"Maximum in one of gid ranges is empty!\");\n-\n-\t\t\t//Transfer string to numbers\n-\t\t\tInteger minimum;\n-\t\t\tInteger maximum;\n-\n-\t\t\ttry {\n-\t\t\t\tminimum = Integer.valueOf(minimumOfRange);\n-\t\t\t\tmaximum = Integer.valueOf(maximumOfRange);\n-\t\t\t} catch (NumberFormatException ex) {\n-\t\t\t\tthrow new WrongAttributeValueException(gidRangesAttribute, \"Min or max value of some range is not correct number format.\");\n-\t\t\t}\n-\n-\t\t\t//Check if min value from range is bigger than 0\n-\t\t\tif(minimum < 1) throw new WrongAttributeValueException(gidRangesAttribute, \"Minimum of one of gid ranges is less than 0.\");\n-\n-\t\t\t//Check if it is correct range\n-\t\t\tif(minimum>maximum) throw new WrongAttributeValueException(gidRangesAttribute, \"One of gid ranges is not correct range. Minimum of this range is bigger then it's maximum.\");\n-\n-\t\t\t//Put this valid range to the map of correct gid ranges\n-\t\t\tconvertedRanges.put(minimum, maximum);\n-\t\t}\n-\n-\t\t//Check gid ranges overlaps (there should be no overlaps)\n-\t\tInteger lastMaxValue = 0;\n-\t\tfor(Integer minValue: convertedRanges.keySet().stream().sorted().collect(Collectors.toList())) {\n-\t\t\tif(minValue <= lastMaxValue) throw new WrongAttributeValueException(gidRangesAttribute, \"There is an overlap between two gid ranges.\");\n-\t\t\tlastMaxValue = convertedRanges.get(minValue);\n-\t\t}\n-\n-\t\treturn convertedRanges;\n-\t}\n-\n-\t/**\n-\t * Returns pair of number (BigDecimal) and unit (String) from given string. Returns default value Pair<0, \"G\"> if parsing fails.\n-\t * E.g.: \"5T\" -> Pair<5, \"T\">\n-\t *\n-\t * @param attributeValue string to parse\n-\t * @return pair of number and unit\n-\t */\n-\tpublic static Pair<BigDecimal, String> getNumberAndUnitFromString(String attributeValue) {\n-\t\tString numberString = \"0\";\n-\t\tString unit = \"G\";\n-\n-\t\tif (attributeValue != null) {\n-\t\t\tMatcher numberMatcher = numberPattern.matcher(attributeValue);\n-\t\t\tMatcher letterMatcher = letterPattern.matcher(attributeValue);\n-\t\t\tnumberMatcher.find();\n-\t\t\tletterMatcher.find();\n-\t\t\ttry {\n-\t\t\t\tnumberString = attributeValue.substring(numberMatcher.start(), numberMatcher.end());\n-\t\t\t} catch (IllegalStateException ex) {\n-\t\t\t\tlog.debug(\"No number could be parsed from given string.\", ex);\n-\t\t\t}\n-\t\t\ttry {\n-\t\t\t\tunit = attributeValue.substring(letterMatcher.start(), letterMatcher.end());\n-\t\t\t} catch (IllegalStateException ex) {\n-\t\t\t\tlog.debug(\"No unit could be parsed from given string.\", ex);\n-\t\t\t}\n-\t\t}\n-\n-\t\tBigDecimal number = new BigDecimal(numberString.replace(',', '.'));\n-\n-\t\treturn new Pair<>(number, unit);\n-\t}\n-\n-\tpublic PerunBl getPerunBl() {\n-\t\treturn this.perunBl;\n-\t}\n-\n-\tpublic void setPerunBl(PerunBl perunBl) {\n-\t\tthis.perunBl = perunBl;\n-\t}\n-}\n+ final static Logger log = LoggerFactory.getLogger(ServicesManagerBlImpl.class);\n+ private PerunBl perunBl;\n+ Map<String, String> perunNamespaces = null;\n+\n+ public static final String A_E_namespace_GIDRanges = AttributesManager.NS_ENTITYLESS_ATTR_DEF + \":namespace-GIDRanges\";\n+\n+ public static final String A_G_unixGID_namespace = AttributesManager.NS_GROUP_ATTR_DEF + \":unixGID-namespace\";\n+\n+ public static final String A_G_unixGroupName_namespace = AttributesManager.NS_GROUP_ATTR_DEF + \":unixGroupName-namespace\";\n+\n+ public static final String A_R_unixGID_namespace = AttributesManager.NS_RESOURCE_ATTR_DEF + \":unixGID-namespace\";\n+\n+ public static final String A_R_unixGroupName_namespace = AttributesManager.NS_RESOURCE_ATTR_DEF + \":unixGroupName-namespace\";\n+\n+ public static final String A_F_unixGID_namespace = AttributesManager.NS_FACILITY_ATTR_DEF + \":unixGID-namespace\";\n+\n+ public static final String A_F_unixGroupName_namespace = AttributesManager.NS_FACILITY_ATTR_DEF + \":unixGroupName-namespace\";\n+\n+ public static final String A_F_googleGroupsDomain = AttributesManager.NS_FACILITY_ATTR_DEF + \":googleGroupsDomain\";\n+ private static final String A_E_usedGids = AttributesManager.NS_ENTITYLESS_ATTR_DEF + \":usedGids\";\n+\n+ //Often used patterns\n+\n+ public static final Pattern quotaWithMetricsPattern = Pattern.compile(\"^([0-9]+([.][0-9]+)?[KMGTPE]?):([0-9]+([.][0-9]+)?[KMGTPE]?)$\");\n+\n+ public static final Pattern quotaWithoutMetricsPattern = Pattern.compile(\"^([0-9]+)(:)([0-9]+)$\");\n+\n+ public static final Pattern numberPattern = Pattern.compile(\"[0-9]+([.][0-9]+)?\");\n+\n+ public static final Pattern letterPattern = Pattern.compile(\"[A-Z]\");\n+\n+ public static final Pattern fqdnPattern = Pattern.compile(\"^((?!-)[a-zA-Z0-9-]{1,63}(?<!-)\\\\.)+[a-zA-Z]{2,63}\\\\.?$\");\n+\n+ //previous regex ^/[-a-zA-Z0-9_/]*$\"\n+\n+ public static final Pattern shellPattern = Pattern.compile(\"^(/[-_a-zA-Z0-9]+)+$\");\n+\n+ public final static List<String> reservedNamesForUnixGroups = Arrays.asList(\"root\", \"daemon\", \"tty\", \"bin\", \"sys\", \"sudo\", \"nogroup\", \"hadoop\", \"hdfs\", \"mapred\", \"yarn\", \"hsqldb\", \"derby\", \"jetty\", \"hbase\", \"zookeeper\", \"users\", \"oozie\", \"hive\");\n+\n+ public final static List<String> unpermittedNamesForUserLogins = Arrays.asList(\"arraysvcs\", \"at\", \"backup\", \"bin\", \"daemon\", \"Debian-exim\", \"flexlm\", \"ftp\", \"games\", \"gdm\", \"glite\", \"gnats\", \"haldaemon\", \"identd\", \"irc\", \"libuuid\", \"list\", \"lp\", \"mail\", \"man\", \"messagebus\", \"news\", \"nobody\", \"ntp\", \"openslp\", \"pcp\", \"polkituser\", \"postfix\", \"proxy\", \"pulse\", \"puppet\", \"root\", \"saned\", \"smmsp\", \"smmta\", \"sshd\", \"statd\", \"suse-ncc\", \"sync\", \"sys\", \"uucp\", \"uuidd\", \"www-data\", \"wwwrun\", \"zenssh\", \"tomcat6\", \"tomcat7\", \"tomcat8\", \"nn\", \"dn\", \"rm\", \"nm\", \"sn\", \"jn\", \"jhs\", \"http\", \"yarn\", \"hdfs\", \"mapred\", \"hadoop\", \"hsqldb\", \"derby\", \"jetty\", \"hbase\", \"zookeeper\", \"hive\", \"hue\", \"oozie\", \"httpfs\");\n+\n+ //Definition of K = KB, M = MB etc.\n+\n+ public static final long M = 1024;\n+\n+ public static final long G = M * 1024;\n+\n+ public static final long T = G * 1024;\n+\n+ public static final long P = T * 1024;\n+\n+ public static final long E = P * 1024;\n+\n+\n+ public ModulesUtilsBlImpl() {}\n+\n+\n+ @Override\n+ public boolean isNamespaceEqualsToFacilityUnixGroupNameNamespace(PerunSessionImpl sess, Facility facility, String namespace) throws InternalErrorException, AttributeNotExistsException, WrongAttributeAssignmentException {\n+  Utils.notNull(facility, \"facility\");\n+  Utils.notNull(namespace, \"namespace\");\n+  Utils.notNull(sess, \"perunSessionImpl\");\n+  Attribute facilityNamespaceAttr = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, facility, A_F_unixGroupName_namespace + \":\" + namespace);\n+  if (facilityNamespaceAttr.getValue() == null)\n+   return false;\n+  if (!namespace.equals(facilityNamespaceAttr.getValue())) {\n+   return false;\n+  }\n+\n+  return true;\n+ }\n+\n+ public List<Resource> findCollisionResourcesWithSameGroupName(PerunSessionImpl sess, Resource resource, String namespace) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException {\n+  Utils.notNull(sess, \"perunSessionImpl\");\n+  Utils.notNull(resource, \"resource\");\n+  Attribute resourceUnixGroupName = getPerunBl().getAttributesManagerBl().getAttribute(sess, resource, A_R_unixGroupName_namespace + \":\" + namespace);\n+  List<Resource> resourcesWithSameUnixGroupName = getPerunBl().getResourcesManagerBl().getResourcesByAttribute(sess, resourceUnixGroupName);\n+  resourcesWithSameUnixGroupName.remove(resource);\n+  return resourcesWithSameUnixGroupName;\n+ }\n+\n+ public List<Resource> findCollisionResourcesWithSameGroupName(PerunSessionImpl sess, Group group, String namespace) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException {\n+  Utils.notNull(sess, \"perunSessionImpl\");\n+  Utils.notNull(group, \"group\");\n+  Utils.notNull(namespace, \"namespace\");\n+  Attribute groupUnixGroupName = getPerunBl().getAttributesManagerBl().getAttribute(sess, group, A_G_unixGroupName_namespace + \":\" + namespace);\n+  Attribute copyResourceUnixGroupName = new Attribute(getPerunBl().getAttributesManagerBl().getAttributeDefinition(sess, A_R_unixGroupName_namespace + \":\" + namespace));\n+  copyResourceUnixGroupName.setValue(groupUnixGroupName.getValue());\n+  return getPerunBl().getResourcesManagerBl().getResourcesByAttribute(sess, copyResourceUnixGroupName);\n+ }\n+\n+ public List<Group> findCollisionGroupsWithSamgeGroupName(PerunSessionImpl sess, Resource resource, String namespace) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException {\n+  Utils.notNull(sess, \"perunSessionImpl\");\n+  Utils.notNull(resource, \"resource\");\n+  Utils.notNull(namespace, \"namespace\");\n+  Attribute resourceUnixGroupName = getPerunBl().getAttributesManagerBl().getAttribute(sess, resource, A_R_unixGroupName_namespace + \":\" + namespace);\n+  Attribute copyGroupUnixGroupName = new Attribute(getPerunBl().getAttributesManagerBl().getAttributeDefinition(sess, A_G_unixGroupName_namespace + \":\" + namespace));\n+  copyGroupUnixGroupName.setValue(resourceUnixGroupName.getValue());\n+  return getPerunBl().getGroupsManagerBl().getGroupsByAttribute(sess, copyGroupUnixGroupName);\n+ }\n+\n+ public List<Group> findCollisionGroupsWithSamgeGroupName(PerunSessionImpl sess, Group group, String namespace) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException {\n+  Utils.notNull(sess, \"perunSessionImpl\");\n+  Utils.notNull(group, \"group\");\n+  Utils.notNull(namespace, \"namespace\");\n+  Attribute groupUnixGroupName = getPerunBl().getAttributesManagerBl().getAttribute(sess, group, A_G_unixGroupName_namespace + \":\" + namespace);\n+  List<Group> groupsWithsameGroupName = getPerunBl().getGroupsManagerBl().getGroupsByAttribute(sess, groupUnixGroupName);\n+  groupsWithsameGroupName.remove(group);\n+  return groupsWithsameGroupName;\n+ }\n+\n+ public List<Resource> findCollisionResourcesWithSameGid(PerunSessionImpl sess, Resource resource, String namespace) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException {\n+  Utils.notNull(sess, \"perunSessionImpl\");\n+  Utils.notNull(resource, \"resource\");\n+  Utils.notNull(namespace, \"namespace\");\n+  Attribute resourceUnixGid = getPerunBl().getAttributesManagerBl().getAttribute(sess, resource, A_R_unixGID_namespace + \":\" + namespace);\n+  List<Resource> resourcesWithSameGid = getPerunBl().getResourcesManagerBl().getResourcesByAttribute(sess, resourceUnixGid);\n+  resourcesWithSameGid.remove(resource);\n+  return resourcesWithSameGid;\n+ }\n+\n+ public List<Resource> findCollisionResourcesWithSameGid(PerunSessionImpl sess, Group group, String namespace) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException {\n+  Utils.notNull(sess, \"perunSessionImpl\");\n+  Utils.notNull(group, \"group\");\n+  Utils.notNull(namespace, \"namespace\");\n+  Attribute groupUnixGid = getPerunBl().getAttributesManagerBl().getAttribute(sess, group, A_G_unixGID_namespace + \":\" + namespace);\n+  Attribute copyResourceUnixGid = new Attribute(getPerunBl().getAttributesManagerBl().getAttributeDefinition(sess, A_R_unixGID_namespace + \":\" + namespace));\n+  copyResourceUnixGid.setValue(groupUnixGid.getValue());\n+  return getPerunBl().getResourcesManagerBl().getResourcesByAttribute(sess, copyResourceUnixGid);\n+ }\n+\n+ public List<Group> findCollisionGroupsWithSamgeGroupGid(PerunSessionImpl sess, Resource resource, String namespace) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException {\n+  Utils.notNull(sess, \"perunSessionImpl\");\n+  Utils.notNull(resource, \"resource\");\n+  Utils.notNull(namespace, \"namespace\");\n+  Attribute resourceUnixGid = getPerunBl().getAttributesManagerBl().getAttribute(sess, resource, A_R_unixGID_namespace + \":\" + namespace);\n+  Attribute copyGroupUnixGid = new Attribute(getPerunBl().getAttributesManagerBl().getAttributeDefinition(sess, A_G_unixGID_namespace + \":\" + namespace));\n+  copyGroupUnixGid.setValue(resourceUnixGid.getValue());\n+  return getPerunBl().getGroupsManagerBl().getGroupsByAttribute(sess, copyGroupUnixGid);\n+ }\n+\n+ public List<Group> findCollisionGroupsWithSamgeGroupGid(PerunSessionImpl sess, Group group, String namespace) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException {\n+  Utils.notNull(sess, \"perunSessionImpl\");\n+  Utils.notNull(group, \"group\");\n+  Utils.notNull(namespace, \"namespace\");\n+  Attribute groupUnixGid = getPerunBl().getAttributesManagerBl().getAttribute(sess, group, A_G_unixGID_namespace + \":\" + namespace);\n+  List<Group> groupsWithSameUnixGid = getPerunBl().getGroupsManagerBl().getGroupsByAttribute(sess, groupUnixGid);\n+  groupsWithSameUnixGid.remove(group);\n+  return groupsWithSameUnixGid;\n+ }\n+\n+ public boolean hasAccessToWriteToAttributeForAnyResource(PerunSessionImpl sess, AttributeDefinition attrDef, List<Resource> resources) throws InternalErrorException {\n+  Utils.notNull(sess, \"perunSessionImpl\");\n+  Utils.notNull(attrDef, \"attributeDefinition\");\n+  if (resources == null || resources.isEmpty())\n+   return false;\n+  for (Resource r : resources) {\n+   if (AuthzResolver.isAuthorizedForAttribute(sess, ActionType.WRITE, attrDef, r))\n+    return true;\n+  }\n+\n+  return false;\n+ }\n+\n+ public boolean hasAccessToWriteToAttributeForAnyGroup(PerunSessionImpl sess, AttributeDefinition attrDef, List<Group> groups) throws InternalErrorException {\n+  Utils.notNull(sess, \"perunSessionImpl\");\n+  Utils.notNull(attrDef, \"attributeDefinition\");\n+  if (groups == null || groups.isEmpty())\n+   return false;\n+  for (Group g : groups) {\n+   if (AuthzResolver.isAuthorizedForAttribute(sess, ActionType.WRITE, attrDef, g))\n+    return true;\n+  }\n+\n+  return false;\n+ }\n+\n+ /**\n+  * Return true if gid is valid in ranges defined by Map of ranges, false otherwise.\n+  * Keys in gidRanges map are minimums of one range and values are maximums.\n+  * If minimum is same as maximum, such range has only one element.\n+  *\n+  * @param gidRanges map of gid ranges (keys = minimums, values = maximums)\n+  * @param gid gid which need to be checked if it is in ranges\n+  * @return\n+  */\n+\n+\n+ private boolean isGIDWithinRanges(Map<Integer, Integer> gidRanges, Integer gid) {\n+  if (gid == null)\n+   return false;\n+  if (gidRanges == null || gidRanges.isEmpty())\n+   return false;\n+\n+  //Test all valid ranges\n+  for (Integer minimum : gidRanges.keySet()) {\n+   Integer maximum = gidRanges.get(minimum);\n+   //Gid is in range, it is ok\n+   if (gid >= minimum && gid <= maximum)\n+    return true;\n+  }\n+\n+  return false;\n+ }\n+\n+ @Override\n+ public void checkIfGIDIsWithinRange(PerunSessionImpl sess, Attribute attribute) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException, WrongAttributeValueException, WrongReferenceAttributeValueException {\n+  Utils.notNull(attribute, \"attribute\");\n+  Integer gid = null;\n+  if (attribute.getValue() != null) gid = (Integer) attribute.getValue();\n+  if (gid == null) throw new WrongAttributeValueException(attribute, \"Gid with null value is not allowed.\");\n+  String gidNamespace = attribute.getFriendlyNameParameter();\n+  Attribute gidRangesAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, gidNamespace, A_E_namespace_GIDRanges);\n+  Map<Integer, Integer> gidRanges = checkAndConvertGIDRanges(gidRangesAttribute);\n+\n+  //Gid is not in range, throw exception\n+  if (!isGIDWithinRanges(gidRanges, gid)) {\n+   throw new WrongReferenceAttributeValueException(attribute, gidRangesAttribute, null, null, gidNamespace, null, \"GID number is not in allowed ranges \" + gidRanges + \" for namespace \" + gidNamespace);\n+  }\n+ }\n+\n+ @Override\n+ public void checkIfListOfGIDIsWithinRange(PerunSessionImpl sess, User user, Attribute attribute) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException, WrongAttributeValueException {\n+  Utils.notNull(attribute, \"attribute\");\n+  List<String> gidsToCheck = attribute.valueAsList();\n+  if (gidsToCheck != null) {\n+   String gidNamespace = attribute.getFriendlyNameParameter();\n+   Attribute gidRangesAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, gidNamespace, A_E_namespace_GIDRanges);\n+   Map<Integer, Integer> gidRanges = checkAndConvertGIDRanges(gidRangesAttribute);\n+   for (String gidToCheck : gidsToCheck) {\n+    try {\n+     Integer gid = new Integer(gidToCheck);\n+     if (!isGIDWithinRanges(gidRanges, gid)) {\n+      throw new WrongAttributeValueException(attribute, \"GID number is not in allowed ranges \" + gidRanges + \" for namespace \" + gidNamespace);\n+     }\n+    } catch (NumberFormatException ex) {\n+     throw new WrongAttributeValueException(attribute, user, \"attribute is not a number\", ex);\n+    }\n+   }\n+  }\n+ }\n+\n+ @Override\n+ public Integer getFreeGID(PerunSessionImpl sess, Attribute attribute) throws InternalErrorException, AttributeNotExistsException, WrongAttributeAssignmentException {\n+  Utils.notNull(attribute, \"attribute\");\n+  String gidNamespace = attribute.getFriendlyNameParameter();\n+  Attribute gidRangesAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, gidNamespace, A_E_namespace_GIDRanges);\n+  if (gidRangesAttribute.getValue() == null)\n+   return 0;\n+  Map<Integer, Integer> gidRanges;\n+  try {\n+   gidRanges = checkAndConvertGIDRanges(gidRangesAttribute);\n+  } catch (WrongAttributeValueException ex) {\n+   throw new InternalErrorException(\"Value in GID ranges attribute where we are looking for free gid is not in correct format \" + gidRangesAttribute,\n+ex);\n+  }\n+  if (gidRanges.isEmpty())\n+   return 0;\n+  List<Integer> allMinimums = gidRanges.keySet().stream().sorted().collect(Collectors.toList());\n+  List<Integer> allGids = new ArrayList<>();\n+  Attribute usedGids = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, gidNamespace, A_E_usedGids);\n+\n+  //return the minimum from all ranges\n+  if (usedGids.getValue() == null) return allMinimums.get(0);\n+  else {\n+   Map<String, String> usedGidsValue = usedGids.valueAsMap();\n+   Set<String> keys = usedGidsValue.keySet();\n+   for (String key : keys) {\n+    allGids.add(Integer.parseInt(usedGidsValue.get(key)));\n+   }\n+  }\n+\n+  for (Integer minimum : allMinimums) {\n+   Integer maximum = gidRanges.get(minimum);\n+   for (int i = minimum; i <= maximum; i++) {\n+    if (!allGids.contains(i)) {\n+     return i;\n+    }\n+   }\n+  }\n+\n+  return null;\n+ }\n+\n+ @Override\n+ public Integer getCommonGIDOfGroupsWithSameNameInSameNamespace(PerunSessionImpl sess, List<Group> groupsWithSameGroupNameInSameNamespace, String gidNamespace, Integer commonGID) throws InternalErrorException, WrongAttributeAssignmentException {\n+  //If there are no groups, return commonGID from param (it can be null)\n+  if (groupsWithSameGroupNameInSameNamespace == null || groupsWithSameGroupNameInSameNamespace.isEmpty())\n+   return commonGID;\n+  Utils.notNull(gidNamespace, \"gidNamespace\");\n+  Group commonGIDGroup = null;  //only for more verbose exception messages\n+  for (Group g : groupsWithSameGroupNameInSameNamespace) {\n+   try {\n+    Attribute attr = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, g, A_G_unixGID_namespace + \":\" + gidNamespace);\n+    if (attr.getValue() != null) {\n+     if (commonGID == null) {\n+      commonGIDGroup = g;\n+      commonGID = (Integer) attr.getValue();\n+     } else {\n+      if (!commonGID.equals(attr.getValue())) throw new ConsistencyErrorException(\"There are at least 1 groups/resources with same GroupName in same namespace but with different GID in same namespaces. Conflict found: \" + g + \"(gid=\" + attr.getValue() + \") and \" + commonGIDGroup + \"(gid=\" + commonGID + \")\");\n+     }\n+    }\n+   } catch (AttributeNotExistsException ex) {\n+    throw new ConsistencyErrorException(ex);\n+   }\n+  }\n+\n+  return commonGID;\n+ }\n+\n+ @Override\n+ public Integer getCommonGIDOfResourcesWithSameNameInSameNamespace(PerunSessionImpl sess, List<Resource> resourcesWithSameGroupNameInSameNamespace, String gidNamespace, Integer commonGID) throws InternalErrorException, WrongAttributeAssignmentException {\n+  //If there are no resources, return commonGID from param (it can be null)\n+  if (resourcesWithSameGroupNameInSameNamespace == null || resourcesWithSameGroupNameInSameNamespace.isEmpty())\n+   return commonGID;\n+  Utils.notNull(gidNamespace, \"gidNamespace\");\n+  Resource commonGIDResource = null;   //only for more verbose exception messages\n+  for (Resource r : resourcesWithSameGroupNameInSameNamespace) {\n+   try {\n+    Attribute attr = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, r, A_R_unixGID_namespace + \":\" + gidNamespace);\n+    if (attr.getValue() != null) {\n+     if (commonGID == null) {\n+      commonGIDResource = r;\n+      commonGID = (Integer) attr.getValue();\n+     } else {\n+      if (!commonGID.equals(attr.getValue())) throw new ConsistencyErrorException(\"There are at least 1 groups/resources with same GroupName in same namespace but with different GID in same namespaces. Conflict found: \" + r + \"(gid=\" + attr.getValue() + \") and \" + commonGIDResource + \"(gid=\" + commonGID + \")\");\n+     }\n+    }\n+   } catch (AttributeNotExistsException ex) {\n+    throw new ConsistencyErrorException(ex);\n+   }\n+  }\n+\n+  return commonGID;\n+ }\n+\n+ @Override\n+ public int haveTheSameAttributeWithTheSameNamespace(PerunSessionImpl sess, Group group, Attribute attr) throws InternalErrorException, WrongAttributeAssignmentException {\n+  Utils.notNull(group, \"group\");\n+  Utils.notNull(attr, \"attr\");\n+  String attributeNamespace = attr.getFriendlyNameParameter();\n+  if (attributeNamespace == null || attributeNamespace.isEmpty()) throw new InternalErrorException(\"Attribute has no namespace, this method can't be use.\");\n+\n+  try {\n+   Attribute testingAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, group, attr.getName());\n+   if (testingAttribute.getValue() == null) return -1;\n+   else {\n+    if (!testingAttribute.getValue().equals(attr.getValue()))\n+     return 1;\n+   }\n+  } catch (AttributeNotExistsException ex) {\n+   throw new ConsistencyErrorException(ex);\n+  }\n+\n+  return 0;\n+ }\n+\n+ @Override\n+ public int haveTheSameAttributeWithTheSameNamespace(PerunSessionImpl sess, Resource resource, Attribute attr) throws InternalErrorException, WrongAttributeAssignmentException {\n+  Utils.notNull(resource, \"resource\");\n+  Utils.notNull(attr, \"attr\");\n+  String attributeNamespace = attr.getFriendlyNameParameter();\n+  if (attributeNamespace == null || attributeNamespace.isEmpty()) throw new InternalErrorException(\"Attribute has no namespace, this method can't be use.\");\n+\n+  try {\n+   Attribute testingAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, resource, attr.getName());\n+   if (testingAttribute.getValue() == null) return -1;\n+   else {\n+    if (!testingAttribute.getValue().equals(attr.getValue()))\n+     return 1;\n+   }\n+  } catch (AttributeNotExistsException ex) {\n+   throw new ConsistencyErrorException(ex);\n+  }\n+\n+  return 0;\n+ }\n+\n+ @Override\n+ public boolean haveRightToWriteAttributeInAnyGroupOrResource(PerunSessionImpl sess, List<Group> groups, List<Resource> resources, AttributeDefinition groupAttribute, AttributeDefinition resourceAttribute) throws InternalErrorException {\n+  if (groups != null && !groups.isEmpty() && groupAttribute != null) {\n+\n+   for (Group g : groups) {\n+    if (AuthzResolver.isAuthorizedForAttribute(sess, ActionType.WRITE, groupAttribute, g))\n+     return true;\n+   }\n+  }\n+  if (resources != null && !resources.isEmpty() && resourceAttribute != null) {\n+\n+   for (Resource r : resources) {\n+    if (AuthzResolver.isAuthorizedForAttribute(sess, ActionType.WRITE, resourceAttribute, r))\n+     return true;\n+   }\n+  }\n+\n+  return false;\n+ }\n+\n+ @Override\n+ public List<Attribute> getListOfResourceGIDsFromListOfGroupGIDs(PerunSessionImpl sess, List<Attribute> groupGIDs) throws InternalErrorException, AttributeNotExistsException {\n+  List<Attribute> resourceGIDs = new ArrayList<>();\n+  if (groupGIDs == null || groupGIDs.isEmpty()) {\n+   return resourceGIDs;\n+  }\n+\n+  for (Attribute a : groupGIDs) {\n+   Attribute resourceGID = new Attribute(sess.getPerunBl().getAttributesManagerBl().getAttributeDefinition(sess, A_R_unixGID_namespace + \":\" + a.getFriendlyNameParameter()));\n+   resourceGID.setValue(a.getValue());\n+   resourceGIDs.add(resourceGID);\n+  }\n+\n+  return resourceGIDs;\n+ }\n+\n+ @Override\n+ public List<Attribute> getListOfGroupGIDsFromListOfResourceGIDs(PerunSessionImpl sess, List<Attribute> resourceGIDs) throws InternalErrorException, AttributeNotExistsException {\n+  List<Attribute> groupGIDs = new ArrayList<>();\n+  if (resourceGIDs == null || resourceGIDs.isEmpty()) {\n+   return groupGIDs;\n+  }\n+\n+  for (Attribute a : resourceGIDs) {\n+   Attribute groupGID = new Attribute(sess.getPerunBl().getAttributesManagerBl().getAttributeDefinition(sess, A_G_unixGID_namespace + \":\" + a.getFriendlyNameParameter()));\n+   groupGID.setValue(a.getValue());\n+   groupGIDs.add(groupGID);\n+  }\n+\n+  return groupGIDs;\n+ }\n+\n+ @Override\n+ public Set<String> getSetOfGIDNamespacesWhereFacilitiesHasTheSameGroupNameNamespace(PerunSessionImpl sess, List<Facility> facilities, Attribute unixGroupNameNamespace) throws InternalErrorException, WrongAttributeAssignmentException {\n+  Set<String> gidNamespaces = new HashSet<>();\n+  if (facilities == null || facilities.isEmpty())\n+   return gidNamespaces;\n+  Utils.notNull(facilities, \"facilities\");\n+  for (Facility f : facilities) {\n+   Attribute facilityGroupNameNamespace;\n+   try {\n+    facilityGroupNameNamespace = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, f, A_F_unixGroupName_namespace);\n+    if (facilityGroupNameNamespace.getValue() != null) {\n+     //if they are same, save GID-namespace from this facility to hashSet\n+     if (unixGroupNameNamespace.getFriendlyNameParameter().equals(facilityGroupNameNamespace.getValue())) {\n+      Attribute facilityGIDNamespace = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, f, A_F_unixGID_namespace);\n+      //If facilityGIDNamespace exists and is not null, save to the hashSet of gidNamespaces\n+      if (facilityGIDNamespace.getValue() != null) {\n+       gidNamespaces.add((String) facilityGIDNamespace.getValue());\n+      }\n+     }\n+    }\n+   } catch (AttributeNotExistsException ex) {\n+    throw new ConsistencyErrorException(ex);\n+   }\n+  }\n+\n+  return gidNamespaces;\n+ }\n+\n+ @Override\n+ public Set<String> getSetOfGroupNameNamespacesWhereFacilitiesHasTheSameGIDNamespace(PerunSessionImpl sess, List<Facility> facilities, Attribute unixGIDNamespace) throws InternalErrorException, WrongAttributeAssignmentException, WrongReferenceAttributeValueException {\n+  Set<String> groupNameNamespaces = new HashSet<>();\n+  if (facilities == null || facilities.isEmpty())\n+   return groupNameNamespaces;\n+  Utils.notNull(unixGIDNamespace, \"unixGIDNamespace\");\n+  for (Facility f : facilities) {\n+   Attribute facilityGIDNamespace;\n+   try {\n+    facilityGIDNamespace = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, f, A_F_unixGID_namespace);\n+    if (facilityGIDNamespace.getValue() != null) {\n+     //if they are same, save GroupName-namespace from this facility to hashSet\n+     if (unixGIDNamespace.getFriendlyNameParameter().equals(facilityGIDNamespace.getValue())) {\n+      Attribute facilityGroupNameNamespace = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, f, A_F_unixGroupName_namespace);\n+      //If facilityGroupNameNamespace exists and is not null, save to the hashSet of gidNamespaces\n+      if (facilityGroupNameNamespace.getValue() != null) {\n+       groupNameNamespaces.add((String) facilityGroupNameNamespace.getValue());\n+      } else {\n+       throw new WrongReferenceAttributeValueException(unixGIDNamespace,\n+facilityGroupNameNamespace,\n+\"Facility has gidNamespace set, but groupNameNamespace not set.\");\n+      }\n+     }\n+    }\n+   } catch (AttributeNotExistsException ex) {\n+    throw new ConsistencyErrorException(ex);\n+   }\n+  }\n+\n+  return groupNameNamespaces;\n+ }\n+\n+ @Override\n+ public void checkReservedUnixGroupNames(Attribute groupNameAttribute) throws WrongAttributeValueException {\n+  if (groupNameAttribute == null)\n+   return;\n+  checkPerunNamespacesMap();\n+  String reservedNames = perunNamespaces.get(groupNameAttribute.getFriendlyName() + \":reservedNames\");\n+  if (reservedNames != null) {\n+   List<String> reservedNamesList = Arrays.asList(reservedNames.split(\"\\\\s*,\\\\s*\"));\n+   if (reservedNamesList.contains(groupNameAttribute.valueAsString())) throw new WrongAttributeValueException(groupNameAttribute, \"This groupName is reserved.\");\n+  } else {\n+   //Property not found in our attribute map, so we will use the default hardcoded values instead\n+   if (reservedNamesForUnixGroups.contains(groupNameAttribute.valueAsString())) throw new WrongAttributeValueException(groupNameAttribute, \"This groupName is reserved.\");\n+  }\n+ }\n+\n+ @Override\n+ public void checkUnpermittedUserLogins(Attribute loginAttribute) throws WrongAttributeValueException {\n+  if (loginAttribute == null)\n+   return;\n+  checkPerunNamespacesMap();\n+  String unpermittedNames = perunNamespaces.get(loginAttribute.getFriendlyName() + \":reservedNames\");\n+  if (unpermittedNames != null) {\n+   List<String> unpermittedNamesList = Arrays.asList(unpermittedNames.split(\"\\\\s*,\\\\s*\"));\n+   if (unpermittedNamesList.contains(loginAttribute.valueAsString())) throw new WrongAttributeValueException(loginAttribute, \"This login is not permitted.\");\n+  } else {\n+   //Property not found in our attribute map, so we will use the default hardcoded values instead\n+   if (unpermittedNamesForUserLogins.contains(loginAttribute.valueAsString())) throw new WrongAttributeValueException(loginAttribute, \"This login is not permitted.\");\n+  }\n+ }\n+\n+ @Override\n+ public Attribute getGoogleGroupNameNamespaceAttributeWithNotNullValue(PerunSessionImpl sess, Resource resource) throws InternalErrorException, WrongReferenceAttributeValueException {\n+  Facility facility = sess.getPerunBl().getResourcesManagerBl().getFacility(sess, resource);\n+  try {\n+   Attribute googleGroupNameNamespaceAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, facility, A_F_googleGroupsDomain);\n+   if (googleGroupNameNamespaceAttribute.getValue() == null) throw new WrongReferenceAttributeValueException(googleGroupNameNamespaceAttribute);\n+   return googleGroupNameNamespaceAttribute;\n+  } catch (AttributeNotExistsException ex) {\n+   throw new ConsistencyErrorException(ex);\n+  } catch (WrongAttributeAssignmentException ex) {\n+   throw new InternalErrorException(ex);\n+  }\n+ }\n+\n+ @Override\n+ public Attribute getUnixGroupNameNamespaceAttributeWithNotNullValue(PerunSessionImpl sess, Resource resource) throws InternalErrorException, WrongReferenceAttributeValueException {\n+  Facility facility = sess.getPerunBl().getResourcesManagerBl().getFacility(sess, resource);\n+  try {\n+   Attribute unixGroupNameNamespaceAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, facility, A_F_unixGroupName_namespace);\n+   if (unixGroupNameNamespaceAttribute.getValue() == null) throw new WrongReferenceAttributeValueException(unixGroupNameNamespaceAttribute);\n+   return unixGroupNameNamespaceAttribute;\n+  } catch (AttributeNotExistsException ex) {\n+   throw new ConsistencyErrorException(ex);\n+  } catch (WrongAttributeAssignmentException ex) {\n+   throw new InternalErrorException(ex);\n+  }\n+ }\n+\n+ @Override\n+ public Attribute getUnixGIDNamespaceAttributeWithNotNullValue(PerunSessionImpl sess, Resource resource) throws InternalErrorException, WrongReferenceAttributeValueException {\n+  Facility facility = sess.getPerunBl().getResourcesManagerBl().getFacility(sess, resource);\n+  try {\n+   Attribute unixGIDNamespaceAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, facility, A_F_unixGID_namespace);\n+   if (unixGIDNamespaceAttribute.getValue() == null) throw new WrongReferenceAttributeValueException(unixGIDNamespaceAttribute);\n+   return unixGIDNamespaceAttribute;\n+  } catch (AttributeNotExistsException ex) {\n+   throw new ConsistencyErrorException(ex);\n+  } catch (WrongAttributeAssignmentException ex) {\n+   throw new InternalErrorException(ex);\n+  }\n+ }\n+\n+ @Override\n+ public boolean isGroupUnixGIDNamespaceFillable(PerunSessionImpl sess, Group group, Attribute groupUnixGIDNamespace) throws InternalErrorException, WrongReferenceAttributeValueException, WrongAttributeAssignmentException {\n+  Utils.notNull(group, \"group\");\n+  Utils.notNull(groupUnixGIDNamespace, \"groupUnixGIDNamespace\");\n+\n+  //Get All Facilities from group\n+  Set<Facility> facilitiesOfGroup = new HashSet<>();\n+  List<Resource> resourcesOfGroup = sess.getPerunBl().getResourcesManagerBl().getAssignedResources(sess, group);\n+  for (Resource r : resourcesOfGroup) {\n+   facilitiesOfGroup.add(sess.getPerunBl().getResourcesManagerBl().getFacility(sess, r));\n+  }\n+\n+  //Prepare list of gid namespaces of all facilities which have the same groupName namespace like this unixGroupName namespace\n+  Set<String> groupNameNamespaces = this.getSetOfGroupNameNamespacesWhereFacilitiesHasTheSameGIDNamespace(sess, new ArrayList<>(facilitiesOfGroup), groupUnixGIDNamespace);\n+  if (!groupNameNamespaces.isEmpty()) {\n+\n+   for (String s : groupNameNamespaces) {\n+    try {\n+     Attribute groupNameNamespace = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, group, A_G_unixGroupName_namespace + \":\" + s);\n+     if (groupNameNamespace.getValue() != null) {\n+      return true;\n+     }\n+    } catch (AttributeNotExistsException ex) {\n+     throw new ConsistencyErrorException(ex);\n+    }\n+   }\n+  }\n+\n+  return false;\n+ }\n+\n+ @Override\n+ public boolean isNameOfEmailValid(PerunSessionImpl sess, String email) {\n+  if (email == null)\n+   return false;\n+  Matcher emailMatcher = Utils.emailPattern.matcher(email);\n+  return emailMatcher.find();\n+ }\n+\n+ @Override\n+ public void checkFormatOfShell(String shell, Attribute attribute) throws WrongAttributeValueException {\n+  Matcher match = shellPattern.matcher(shell);\n+  if (!match.matches()) {\n+   throw new WrongAttributeValueException(attribute, \"Bad shell attribute format \" + shell);\n+  }\n+ }\n+\n+ @Override\n+ public void checkAttributeRegex(Attribute attribute, Pattern defaultRegex) throws InternalErrorException, WrongAttributeValueException {\n+  if (attribute == null || attribute.getValue() == null) throw new InternalErrorException(\"Attribute or it's value is null.\");\n+  String attributeValue = (String) attribute.getValue();\n+  checkPerunNamespacesMap();\n+  String regex = perunNamespaces.get(attribute.getFriendlyName() + \":regex\");\n+  if (regex != null) {\n+   //Check if regex is valid\n+   try {\n+    Pattern.compile(regex);\n+   } catch (PatternSyntaxException e) {\n+    log.error(\"Regex pattern \\\"\" + regex + \"\\\" from \\\"\" + attribute.getFriendlyName() + \":regex\\\"\" + \" property of perun-namespaces.properties file is invalid.\");\n+    throw new InternalErrorException(\"Regex pattern \\\"\" + regex + \"\\\" from \\\"\" + attribute.getFriendlyName() + \":regex\\\"\" + \" property of perun-namespaces.properties file is invalid.\");\n+   }\n+   if (!attributeValue.matches(regex)) {\n+    throw new WrongAttributeValueException(attribute, \"Wrong format. Regex: \\\"\" + regex + \"\\\" expected for this attribute:\");\n+   }\n+  } else {\n+   //Regex property not found in our attribute map, so use the default hardcoded regex\n+   if (!defaultRegex.matcher(attributeValue).matches()) {\n+    throw new WrongAttributeValueException(attribute, \"Wrong format. Regex: \\\"\" + defaultRegex + \"\\\" expected for this attribute:\");\n+   }\n+  }\n+ }\n+\n+ /**\n+  * Internal protected method.\n+  * Checks this.perunNamespaces map, which is always initialized as null.\n+  * If null, it tries to load the configuration into this map from a perun-namespaces.properties file.\n+  * If the file does not exist, it creates an empty HashMap, so it's not null anymore.\n+  */\n+\n+ protected void checkPerunNamespacesMap() {\n+  if (perunNamespaces == null) {\n+   try {\n+    perunNamespaces = BeansUtils.getAllPropertiesFromCustomConfiguration(\"perun-namespaces.properties\");\n+   } catch (InternalErrorException e) {\n+    perunNamespaces = new HashMap<>();\n+   }\n+  }\n+ }\n+\n+ @Override\n+ public void checkIfQuotasIsInLimit(Map<String, Pair<BigDecimal, BigDecimal>> quotaToCheck, Map<String, Pair<BigDecimal, BigDecimal>> limitQuota) throws InternalErrorException {\n+  if (quotaToCheck == null) throw new InternalErrorException(\"Quota to check can't be null.\");\n+  if (limitQuota == null) throw new InternalErrorException(\"Limit quota can't be null.\");\n+\n+  //If there is no value to check, then everything is in limit (we don't need to limit anything)\n+  if (quotaToCheck.isEmpty())\n+   return;\n+\n+  //test every record of quotaToCheck against record in limitQuota\n+  for (String volumeToCheck : quotaToCheck.keySet()) {\n+   if (!limitQuota.containsKey(volumeToCheck)) {\n+    throw new QuotaNotInAllowedLimitException(quotaToCheck, limitQuota, \"Volume \" + volumeToCheck + \" is missing in limitQuota.\");\n+   }\n+   Pair<BigDecimal, BigDecimal> volumeToCheckQuotas = quotaToCheck.get(volumeToCheck);\n+   Pair<BigDecimal, BigDecimal> volumeToCheckLimitQuotas = limitQuota.get(volumeToCheck);\n+\n+   //Check limit of softQuota, zero limit means unlimited so no need for testing\n+   if (volumeToCheckLimitQuotas.getLeft().compareTo(BigDecimal.ZERO) != 0) {\n+    if (volumeToCheckQuotas.getLeft().compareTo(BigDecimal.ZERO) == 0 || volumeToCheckQuotas.getLeft().compareTo(volumeToCheckLimitQuotas.getLeft()) > 0) {\n+     throw new QuotaNotInAllowedLimitException(quotaToCheck, limitQuota, \"SoftQuota of volume \" + volumeToCheck + \" is bigger than limit.\");\n+    }\n+   }\n+\n+   //Check limit of hardQuota, zero limit means unlimited so no need for testing\n+   if (volumeToCheckLimitQuotas.getRight().compareTo(BigDecimal.ZERO) != 0) {\n+    if (volumeToCheckQuotas.getRight().compareTo(BigDecimal.ZERO) == 0 || volumeToCheckQuotas.getRight().compareTo(volumeToCheckLimitQuotas.getRight()) > 0) {\n+     throw new QuotaNotInAllowedLimitException(quotaToCheck, limitQuota, \"HardQuota of volume \" + volumeToCheck + \" is bigger than limit.\");\n+    }\n+   }\n+  }\n+ }\n+\n+ @Override\n+ public Map<String, Pair<BigDecimal, BigDecimal>> checkAndTransferQuotas(Attribute quotasAttribute, PerunBean firstPlaceholder, PerunBean secondPlaceholder, boolean withMetrics) throws InternalErrorException, WrongAttributeValueException {\n+  //firstPlaceholder can't be null\n+  if (firstPlaceholder == null) throw new InternalErrorException(\"Missing first mandatory placeHolder (PerunBean).\");\n+  //If quotas attribute is null or it's value is empty, return empty hash map\n+  if (quotasAttribute == null || quotasAttribute.getValue() == null)\n+   return new LinkedHashMap<>();\n+\n+  //Prepare result container and value of attribute\n+  Map<String, Pair<BigDecimal, BigDecimal>> transferedQuotas = new LinkedHashMap<>();\n+  Map<String, String> defaultQuotasMap = quotasAttribute.valueAsMap();\n+\n+  //List to test if all paths are unique (/var/log and /var/log/ are the same so these two paths are not unique)\n+  List<String> uniquePaths = new ArrayList<>();\n+  for (String path : defaultQuotasMap.keySet()) {\n+   //null is not correct path for volume on File System\n+   if (path == null || path.isEmpty()) throw new WrongAttributeValueException(quotasAttribute,\n+firstPlaceholder,\n+secondPlaceholder,\n+\"The path of some volume where quota should be set is null.\");\n+\n+   //testing if path is unique\n+   String canonicalPath;\n+   try {\n+    canonicalPath = new URI(path).normalize().getPath();\n+    //path should not end on '/' (problem with some systems as GPFS)\n+    if (!canonicalPath.equals(\"/\") && canonicalPath.endsWith(\"/\")) canonicalPath = canonicalPath.substring(0, canonicalPath.length()-1);\n+   } catch (URISyntaxException ex) {\n+    throw new WrongAttributeValueException(quotasAttribute, firstPlaceholder, secondPlaceholder, \"Path '\" + path + \"' is not correct form.\");\n+   }\n+   if (uniquePaths.contains(canonicalPath)) throw new WrongAttributeValueException(quotasAttribute,\n+firstPlaceholder,\n+secondPlaceholder,\n+\"Paths are not unique, there are two same paths: \" + path);\n+   else uniquePaths.add(canonicalPath);\n+   String quota = defaultQuotasMap.get(path);\n+   //quota can't be null, if exists in attribute, must be set in some way\n+   if (quota == null) throw new WrongAttributeValueException(quotasAttribute,\n+firstPlaceholder,\n+secondPlaceholder,\n+\"The quota of some volume where quota should be set is null.\");\n+\n+   //check format of quota parameter (for data with metrics, for count of files without metrics)\n+   Matcher quotaMatcher;\n+   if (withMetrics) {\n+    quotaMatcher = ModulesUtilsBlImpl.quotaWithMetricsPattern.matcher(quota);\n+    if (!quotaMatcher.matches()) throw new WrongAttributeValueException(quotasAttribute,\n+firstPlaceholder,\n+secondPlaceholder,\n+\"Format of quota in quotas attribute is not correct.\");\n+   } else {\n+    quotaMatcher = ModulesUtilsBlImpl.quotaWithoutMetricsPattern.matcher(quota);\n+    if (!quotaMatcher.matches()) throw new WrongAttributeValueException(quotasAttribute,\n+firstPlaceholder,\n+secondPlaceholder,\n+\"Format of quota in quotas attribute is not correct.\");\n+   }\n+\n+   //Parse quotas to variables\n+   String softQuota = quotaMatcher.group(1);\n+   String hardQuota = quotaMatcher.group(3);\n+\n+   //Parse number pattern and letter pattern from whole quotas\n+\n+   //SoftQuotaNumber\n+   BigDecimal softQuotaAfterTransfer;\n+   BigDecimal hardQuotaAfterTransfer;\n+   //special behavior with metrics\n+   if (withMetrics) {\n+    Matcher numberMatcher = numberPattern.matcher(softQuota);\n+    if (!numberMatcher.find()) throw new ConsistencyErrorException(\"Matcher can't find number in softQuota '\" + softQuota + \"' in attribute \" + quotasAttribute);\n+    String softQuotaNumber = numberMatcher.group();\n+\n+    //SoftQuotaLetter\n+    String softQuotaLetter;\n+    Matcher letterMatcher = letterPattern.matcher(softQuota);\n+    //in this case no letter means default and default is G\n+    if (!letterMatcher.find()) softQuotaLetter = \"G\";\n+    else softQuotaLetter = letterMatcher.group();\n+\n+    //HardQuotaNumber\n+    numberMatcher = numberPattern.matcher(hardQuota);\n+    if (!numberMatcher.find()) throw new ConsistencyErrorException(\"Matcher can't find number in hardQuota '\" + hardQuota + \"' in attribute \" + quotasAttribute);\n+    String hardQuotaNumber = numberMatcher.group();\n+\n+    //HardQuotaLetter\n+    String hardQuotaLetter;\n+    letterMatcher = letterPattern.matcher(hardQuota);\n+    //in this case no letter means default and default is G\n+    if (!letterMatcher.find()) hardQuotaLetter = \"G\";\n+    else hardQuotaLetter = letterMatcher.group();\n+\n+    //Prepare whole big decimal numbers\n+    softQuotaAfterTransfer = new BigDecimal(softQuotaNumber);\n+    hardQuotaAfterTransfer = new BigDecimal(hardQuotaNumber);\n+\n+    //multiplying for softQuota\n+    switch (softQuotaLetter) {\n+     case \"K\":\n+      break; //K is basic metric, no need to multiply it\n+     case \"G\":\n+      softQuotaAfterTransfer = softQuotaAfterTransfer.multiply(BigDecimal.valueOf(G));\n+      break;\n+     case \"M\":\n+      softQuotaAfterTransfer = softQuotaAfterTransfer.multiply(BigDecimal.valueOf(M));\n+      break;\n+     case \"T\":\n+      softQuotaAfterTransfer = softQuotaAfterTransfer.multiply(BigDecimal.valueOf(T));\n+      break;\n+     case \"P\":\n+      softQuotaAfterTransfer = softQuotaAfterTransfer.multiply(BigDecimal.valueOf(P));\n+      break;\n+     case \"E\":\n+      softQuotaAfterTransfer = softQuotaAfterTransfer.multiply(BigDecimal.valueOf(E));\n+      break;\n+     default:\n+      throw new ConsistencyErrorException(\"There is not allowed character in soft quota letter '\" + softQuotaLetter + \"'.\");\n+    }\n+\n+    //multiplying for softQuota\n+    switch (hardQuotaLetter) {\n+     case \"K\":\n+      break; //K is basic metric, no need to multiply it\n+     case \"G\":\n+      hardQuotaAfterTransfer = hardQuotaAfterTransfer.multiply(BigDecimal.valueOf(G));\n+      break;\n+     case \"M\":\n+      hardQuotaAfterTransfer = hardQuotaAfterTransfer.multiply(BigDecimal.valueOf(M));\n+      break;\n+     case \"T\":\n+      hardQuotaAfterTransfer = hardQuotaAfterTransfer.multiply(BigDecimal.valueOf(T));\n+      break;\n+     case \"P\":\n+      hardQuotaAfterTransfer = hardQuotaAfterTransfer.multiply(BigDecimal.valueOf(P));\n+      break;\n+     case \"E\":\n+      hardQuotaAfterTransfer = hardQuotaAfterTransfer.multiply(BigDecimal.valueOf(E));\n+      break;\n+     default:\n+      throw new ConsistencyErrorException(\"There is not allowed character in hard quota letter '\" + hardQuotaLetter + \"'.\");\n+    }\n+   //easy way without metrics\n+   } else {\n+    softQuotaAfterTransfer = new BigDecimal(softQuota);\n+    hardQuotaAfterTransfer = new BigDecimal(hardQuota);\n+   }\n+\n+   //test comparing softQuota and hardQuota (softQuota must be less or equals than hardQuota, 0 means unlimited)\n+   //1] if softQuota is unlimited, but hardQuota not = exception\n+   if (softQuotaAfterTransfer.compareTo(BigDecimal.valueOf(0)) == 0 && hardQuotaAfterTransfer.compareTo(BigDecimal.valueOf(0)) != 0) {\n+    throw new WrongAttributeValueException(quotasAttribute, firstPlaceholder, secondPlaceholder, \"SoftQuota is set to unlimited (0) but hardQuota is limited to '\" + hardQuota + \"'.\");\n+   //2] if hardQuota is not unlimited but still it is less then softQuota = exception\n+   } else if (hardQuotaAfterTransfer.compareTo(BigDecimal.valueOf(0)) != 0 && hardQuotaAfterTransfer.compareTo(softQuotaAfterTransfer) < 0) {\n+    throw new WrongAttributeValueException(quotasAttribute, firstPlaceholder, secondPlaceholder, \"One of quotas is not correct. HardQuota '\" + hardQuota + \"' is less then softQuota '\" + softQuota + \"'.\");\n+   }\n+   //other cases are ok\n+   transferedQuotas.put(canonicalPath, new Pair<>(softQuotaAfterTransfer, hardQuotaAfterTransfer));\n+  }\n+\n+  return transferedQuotas;\n+ }\n+\n+ @Override\n+ public Map<String, String> transferQuotasBackToAttributeValue(Map<String, Pair<BigDecimal, BigDecimal>> transferedQuotasMap, boolean withMetrics) throws InternalErrorException {\n+  Map<String, String> attributeQuotasValue = new LinkedHashMap<>();\n+  //if null or empty, return empty attribute value map for quotas\n+  if (transferedQuotasMap == null || transferedQuotasMap.isEmpty())\n+   return attributeQuotasValue;\n+\n+  //every path with quotas transfer step by step\n+  for (String path : transferedQuotasMap.keySet()) {\n+   Pair<BigDecimal, BigDecimal> quotas = transferedQuotasMap.get(path);\n+   BigDecimal softQuotaBD = quotas.getLeft();\n+   BigDecimal hardQuotaBD = quotas.getRight();\n+\n+   //Divide decimal till it is still natural number\n+   //Soft Quota\n+   String softQuota = \"0\";\n+   //Zero means unlimited, stay the same\n+   if (softQuotaBD.compareTo(BigDecimal.ZERO) != 0) {\n+    if (withMetrics) softQuota = Utils.bigDecimalBytesToReadableStringWithMetric(softQuotaBD);\n+    else softQuota = softQuotaBD.toPlainString();\n+   }\n+   //Hard Quota\n+   String hardQuota = \"0\";\n+   //Zero means unlimited, stay the same\n+   if (hardQuotaBD.compareTo(BigDecimal.ZERO) != 0) {\n+    if (withMetrics) hardQuota = Utils.bigDecimalBytesToReadableStringWithMetric(hardQuotaBD);\n+    else hardQuota = hardQuotaBD.toPlainString();\n+   }\n+\n+   //add softQuota and hardQuota to result (50T:60T)\n+   attributeQuotasValue.put(path, softQuota + \":\" + hardQuota);\n+  }\n+\n+  return attributeQuotasValue;\n+ }\n+\n+ @Override\n+ public Map<String, Pair<BigDecimal, BigDecimal>> mergeMemberAndResourceTransferredQuotas(Map<String, Pair<BigDecimal, BigDecimal>> resourceQuotas, Map<String, Pair<BigDecimal, BigDecimal>> memberResourceQuotas, Map<String, Pair<BigDecimal, BigDecimal>> quotasOverride) {\n+  Map<String, Pair<BigDecimal, BigDecimal>> mergedTransferedQuotas = new LinkedHashMap<>();\n+\n+  //first go through member-resource quotas values\n+  for (String path : memberResourceQuotas.keySet()) {\n+   //override has the highest priority\n+   if (quotasOverride.containsKey(path)) {\n+    mergedTransferedQuotas.put(path, quotasOverride.get(path));\n+   } else {\n+    //if override not exists, take the original value\n+    mergedTransferedQuotas.put(path, memberResourceQuotas.get(path));\n+   }\n+  }\n+\n+  //save unique values from resource quotas (not exists in member-resource quotas)\n+\n+  for (String path : resourceQuotas.keySet()) {\n+   //skip already saved values, they are not unique\n+   if (mergedTransferedQuotas.containsKey(path)) continue;\n+\n+   //take override if exists\n+   if (quotasOverride.containsKey(path)) {\n+    mergedTransferedQuotas.put(path, quotasOverride.get(path));\n+   } else {\n+    mergedTransferedQuotas.put(path, resourceQuotas.get(path));\n+   }\n+  }\n+\n+  return mergedTransferedQuotas;\n+ }\n+\n+ @Override\n+ public Map<String, Pair<BigDecimal, BigDecimal>> countUserFacilityQuotas(List<Map<String, Pair<BigDecimal, BigDecimal>>> allUserQuotas) {\n+  Map<String, Pair<BigDecimal, BigDecimal>> resultTransferredQuotas = new LinkedHashMap<>();\n+  //for every transfered map of merged quotas count one result transfered map\n+  for (Map<String, Pair<BigDecimal, BigDecimal>> mapValue : allUserQuotas) {\n+   //for every path in one transfered map\n+\n+   for (String pathKey : mapValue.keySet()) {\n+    //if path not exists in result map, add it with it's values\n+    if (!resultTransferredQuotas.containsKey(pathKey)) {\n+     resultTransferredQuotas.put(pathKey, mapValue.get(pathKey));\n+    //if path already exists in result map, sum their quotas together\n+    } else {\n+     Pair<BigDecimal, BigDecimal> quotasValue1 = resultTransferredQuotas.get(pathKey);\n+     Pair<BigDecimal, BigDecimal> quotasValue2 = mapValue.get(pathKey);\n+     //for soft quota (left part of pair)\n+     BigDecimal softQuota = BigDecimal.ZERO;\n+     if (quotasValue1.getLeft().compareTo(BigDecimal.ZERO) != 0 && quotasValue2.getLeft().compareTo(BigDecimal.ZERO) != 0) {\n+      softQuota = quotasValue1.getLeft().add(quotasValue2.getLeft());\n+     }\n+     //for hard quota (right part of pair)\n+     BigDecimal hardQuota = BigDecimal.ZERO;\n+     if (quotasValue1.getRight().compareTo(BigDecimal.ZERO) != 0 && quotasValue2.getRight().compareTo(BigDecimal.ZERO) != 0) {\n+      hardQuota = quotasValue1.getRight().add(quotasValue2.getRight());\n+     }\n+     //create new pair of summed numbers\n+     Pair<BigDecimal, BigDecimal> finalQuotasValue = new Pair<>(softQuota, hardQuota);\n+     //add new summed pair to the result map\n+     resultTransferredQuotas.put(pathKey, finalQuotasValue);\n+    }\n+   }\n+  }\n+  //return result map\n+\n+  return resultTransferredQuotas;\n+ }\n+\n+ @Override\n+ public boolean isFQDNValid(PerunSessionImpl sess, String fqdn) {\n+  if (fqdn == null)\n+   return false;\n+  Matcher fqdnMatcher = fqdnPattern.matcher(fqdn);\n+  return fqdnMatcher.find();\n+ }\n+\n+ /**\n+  * Normalize string for purpose of generating safe login value.\n+  *\n+  * @return normalized string\n+  */\n+\n+ public static String normalizeStringForLogin(String toBeNormalized) {\n+  if (toBeNormalized == null || toBeNormalized.trim().isEmpty())\n+   return null;\n+  toBeNormalized = toBeNormalized.toLowerCase();\n+  toBeNormalized = java.text.Normalizer.normalize(toBeNormalized, java.text.Normalizer.Form.NFD).replaceAll(\"\\\\p{InCombiningDiacriticalMarks}+\", \"\");\n+  toBeNormalized = toBeNormalized.replaceAll(\"[^a-zA-Z]+\", \"\");\n+\n+  // unable to fill login for users without name or with partial name\n+  if (toBeNormalized.isEmpty()) {\n+   return null;\n+  }\n+\n+  return toBeNormalized;\n+ }\n+\n+ /**\n+  * Shared logic for purpose of login generation\n+  */\n+\n+ public static class LoginGenerator {\n+\n+  /**\n+   * Define joining function for anonymous classes\n+   */\n+  public interface LoginGeneratorFunction {\n+\n+   /**\n+    * Generate login for user using his name.\n+    * Implementation must handle empty/null input on both fields.\n+    *\n+    * @param firstName\n+    * @param lastName\n+    * @return generated login\n+    */\n+\n+\n+   String generateLogin(String firstName, String lastName);\n+  }\n+\n+  /**\n+   * Generate login for user using his name and joining function\n+   *\n+   * @param user User to get data from\n+   * @param function Function to join fist/lastName to login\n+   * @return generated login\n+   */\n+\n+  public String generateLogin(User user, LoginGeneratorFunction function) {\n+   String firstName = user.getFirstName();\n+   String lastName = user.getLastName();\n+\n+   // get only first part of first name and remove spec. chars\n+   if (firstName != null && !firstName.isEmpty()) {\n+    firstName = ModulesUtilsBlImpl.normalizeStringForLogin(firstName.split(\" \")[0]);\n+   }\n+\n+   // get only last part of last name and remove spec. chars\n+   if (lastName != null && !lastName.isEmpty()) {\n+    List<String> names = Arrays.asList(lastName.split(\" \"));\n+    lastName = names.get(names.size()-1);\n+    lastName = ModulesUtilsBlImpl.normalizeStringForLogin(lastName.split(\" \")[0]);\n+   }\n+\n+   return function.generateLogin(firstName, lastName);\n+  }\n+ }\n+\n+ @Override\n+ public User getUserFromMessage(PerunSessionImpl sess, String message) throws InternalErrorException {\n+  List<PerunBean> perunBeans = AuditParser.parseLog(message);\n+  User user = null;\n+  UserExtSource userExtSource = null;\n+  Member member = null;\n+  for (PerunBean perunBean : perunBeans) {\n+   if (perunBean instanceof User) {\n+    user = (User) perunBean;\n+    break;\n+   } else if (perunBean instanceof UserExtSource && userExtSource == null) {\n+    userExtSource = (UserExtSource) perunBean;\n+   } else if (perunBean instanceof Member && member == null) {\n+           member = (Member) perunBean;\n+          }\n+  }\n+\n+  //if we don't have object user, try to parse user id from userExtSource (-1 means no userId was defined)\n+  if (user == null && userExtSource != null && userExtSource.getUserId() != -1) {\n+   try {\n+    user = getPerunBl().getUsersManagerBl().getUserById(sess, userExtSource.getUserId());\n+   } catch (UserNotExistsException ex) {\n+    log.warn(\"User from UserExtSource {} doesn't exist in Perun. This occurred while parsing message: {}.\",\n+    userExtSource,\n+    message);\n+    return null;\n+   }\n+  } else if (user == null && member != null) {\n+   try {\n+    user = getPerunBl().getUsersManagerBl().getUserById(sess, member.getUserId());\n+   } catch (UserNotExistsException ex) {\n+    log.warn(\"User from Member {} doesn't exist in Perun. This occurred while parsing message: {}.\",\n+    member,\n+    message);\n+    return null;\n+   }\n+  }\n+\n+  return user;\n+ }\n+\n+ @Override\n+ public Map<Integer, Integer> checkAndConvertGIDRanges(Attribute gidRangesAttribute) throws InternalErrorException, WrongAttributeValueException {\n+  //Prepare structure for better working with GID Ranges\n+  Map<Integer, Integer> convertedRanges = new HashMap<>();\n+\n+  //For null attribute throw an exception\n+  if (gidRangesAttribute == null) throw new InternalErrorException(\"Can't get value from null attribute!\");\n+  Map<String, String> gidRanges = gidRangesAttribute.valueAsMap();\n+\n+  //Return empty map if there is empty input of gidRanges in method parameters\n+  if (gidRanges == null || gidRanges.isEmpty())\n+   return convertedRanges;\n+\n+  //Check every range if it is in correct format and it is valid range\n+  for (String minimumOfRange : gidRanges.keySet()) {\n+   //Check not null\n+   if (minimumOfRange == null || minimumOfRange.isEmpty()) throw new WrongAttributeValueException(gidRangesAttribute, \"Minimum in one of gid ranges is empty!\");\n+   String maximumOfRange = gidRanges.get(minimumOfRange);\n+   if (maximumOfRange == null || maximumOfRange.isEmpty()) throw new WrongAttributeValueException(gidRangesAttribute, \"Maximum in one of gid ranges is empty!\");\n+\n+   //Transfer string to numbers\n+   Integer minimum;\n+   Integer maximum;\n+   try {\n+    minimum = Integer.valueOf(minimumOfRange);\n+    maximum = Integer.valueOf(maximumOfRange);\n+   } catch (NumberFormatException ex) {\n+    throw new WrongAttributeValueException(gidRangesAttribute, \"Min or max value of some range is not correct number format.\");\n+   }\n+\n+   //Check if min value from range is bigger than 0\n+   if (minimum< 1) throw new WrongAttributeValueException(gidRangesAttribute, \"Minimum of one of gid ranges is less than 0.\");\n+\n+   //Check if it is correct range\n+   if (minimum > maximum) throw new WrongAttributeValueException(gidRangesAttribute,\n+\"One of gid ranges is not correct range. Minimum of this range is bigger then it's maximum.\");\n+\n+   //Put this valid range to the map of correct gid ranges\n+   convertedRanges.put(minimum, maximum);\n+  }\n+\n+  //Check gid ranges overlaps (there should be no overlaps)\n+  Integer lastMaxValue = 0;\n+  for (Integer minValue : convertedRanges.keySet().stream().sorted().collect(Collectors.toList())) {\n+   if (minValue <= lastMaxValue) throw new WrongAttributeValueException(gidRangesAttribute, \"There is an overlap between two gid ranges.\");\n+   lastMaxValue = convertedRanges.get(minValue);\n+  }\n+\n+  return convertedRanges;\n+ }\n+\n+ /**\n+  * Returns pair of number (BigDecimal) and unit (String) from given string. Returns default value Pair<0, \"G\"> if parsing fails.\n+  * E.g.: \"5T\" -> Pair<5, \"T\">\n+  *\n+  * @param attributeValue string to parse\n+  * @return pair of number and unit\n+  */\n+\n+ public static Pair<BigDecimal, String> getNumberAndUnitFromString(String attributeValue) {\n+  String numberString = \"0\";\n+  String unit = \"G\";\n+  if (attributeValue != null) {\n+   Matcher numberMatcher = numberPattern.matcher(attributeValue);\n+   Matcher letterMatcher = letterPattern.matcher(attributeValue);\n+   numberMatcher.find();\n+   letterMatcher.find();\n+\n+   try {\n+    numberString = attributeValue.substring(numberMatcher.start(), numberMatcher.end());\n+   } catch (IllegalStateException ex) {\n+    log.debug(\"No number could be parsed from given string.\", ex);\n+   }\n+\n+   try {\n+    unit = attributeValue.substring(letterMatcher.start(), letterMatcher.end());\n+   } catch (IllegalStateException ex) {\n+    log.debug(\"No unit could be parsed from given string.\", ex);\n+   }\n+  }\n+  BigDecimal number = new BigDecimal(numberString.replace(',', '.'));\n+  return new Pair<>(number, unit);\n+ }\n+\n+ public PerunBl getPerunBl() {\n+  return this.perunBl;\n+ }\n+\n+ public void setPerunBl(PerunBl perunBl) {\n+  this.perunBl = perunBl;\n+ }\n+\n+}\n\\ No newline at end of file\n",
            "diff_size": 1169
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/258/ModulesUtilsBlImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/styler_random/258/ModulesUtilsBlImpl.java\nindex eaf48b2aa7f..d63383cd769 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/258/ModulesUtilsBlImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/styler_random/258/ModulesUtilsBlImpl.java\n@@ -77,8 +77,8 @@ public class ModulesUtilsBlImpl implements ModulesUtilsBl {\n \n \tpublic final static List<String> reservedNamesForUnixGroups = Arrays.asList(\"root\", \"daemon\", \"tty\", \"bin\", \"sys\", \"sudo\", \"nogroup\",\n \t          \"hadoop\", \"hdfs\", \"mapred\", \"yarn\", \"hsqldb\", \"derby\", \"jetty\", \"hbase\", \"zookeeper\", \"users\", \"oozie\", \"hive\");\n-\tpublic final static List<String> unpermittedNamesForUserLogins = Arrays.asList(\"arraysvcs\", \"at\", \"backup\", \"bin\", \"daemon\", \"Debian-exim\", \"flexlm\", \"ftp\", \"games\",\n-\t\t        \"gdm\", \"glite\", \"gnats\", \"haldaemon\", \"identd\", \"irc\", \"libuuid\", \"list\", \"lp\", \"mail\", \"man\",\n+\n+public final static List<String> unpermittedNamesForUserLogins = Arrays.asList(\"arraysvcs\", \"at\", \"backup\", \"bin\", \"daemon\", \"Debian-exim\", \"flexlm\", \"ftp\", \"games\", \"gdm\", \"glite\", \"gnats\", \"haldaemon\", \"identd\", \"irc\", \"libuuid\", \"list\", \"lp\", \"mail\", \"man\",\n \t\t        \"messagebus\", \"news\", \"nobody\", \"ntp\", \"openslp\", \"pcp\", \"polkituser\", \"postfix\", \"proxy\",\n \t\t        \"pulse\", \"puppet\", \"root\", \"saned\", \"smmsp\", \"smmta\", \"sshd\", \"statd\", \"suse-ncc\", \"sync\",\n \t\t        \"sys\", \"uucp\", \"uuidd\", \"www-data\", \"wwwrun\", \"zenssh\", \"tomcat6\", \"tomcat7\", \"tomcat8\",\n",
            "diff_size": 2
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/258/ModulesUtilsBlImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/styler_three_grams/258/ModulesUtilsBlImpl.java\nindex eaf48b2aa7f..0356a2584c9 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/258/ModulesUtilsBlImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/styler_three_grams/258/ModulesUtilsBlImpl.java\n@@ -77,8 +77,10 @@ public class ModulesUtilsBlImpl implements ModulesUtilsBl {\n \n \tpublic final static List<String> reservedNamesForUnixGroups = Arrays.asList(\"root\", \"daemon\", \"tty\", \"bin\", \"sys\", \"sudo\", \"nogroup\",\n \t          \"hadoop\", \"hdfs\", \"mapred\", \"yarn\", \"hsqldb\", \"derby\", \"jetty\", \"hbase\", \"zookeeper\", \"users\", \"oozie\", \"hive\");\n-\tpublic final static List<String> unpermittedNamesForUserLogins = Arrays.asList(\"arraysvcs\", \"at\", \"backup\", \"bin\", \"daemon\", \"Debian-exim\", \"flexlm\", \"ftp\", \"games\",\n-\t\t        \"gdm\", \"glite\", \"gnats\", \"haldaemon\", \"identd\", \"irc\", \"libuuid\", \"list\", \"lp\", \"mail\", \"man\",\n+\n+           public final static List<String> unpermittedNamesForUserLogins = Arrays.asList(\"arraysvcs\", \"at\", \"backup\", \"bin\", \"daemon\", \"Debian-exim\", \"flexlm\",\n+          \"ftp\", \"games\",\n+           \"gdm\", \"glite\", \"gnats\", \"haldaemon\", \"identd\", \"irc\", \"libuuid\", \"list\", \"lp\", \"mail\", \"man\",\n \t\t        \"messagebus\", \"news\", \"nobody\", \"ntp\", \"openslp\", \"pcp\", \"polkituser\", \"postfix\", \"proxy\",\n \t\t        \"pulse\", \"puppet\", \"root\", \"saned\", \"smmsp\", \"smmta\", \"sshd\", \"statd\", \"suse-ncc\", \"sync\",\n \t\t        \"sys\", \"uucp\", \"uuidd\", \"www-data\", \"wwwrun\", \"zenssh\", \"tomcat6\", \"tomcat7\", \"tomcat8\",\n",
            "diff_size": 4
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "naturalize"
    ]
}