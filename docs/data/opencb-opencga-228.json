{
    "project_name": "opencb-opencga",
    "error_id": "228",
    "information": {
        "errors": [
            {
                "line": "187",
                "severity": "error",
                "message": "Line is longer than 140 characters (found 141).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": "        }\n//        if (catalogManager == null) {\n//            throw new IllegalStateException(\"OpenCGA was not properly initialized. Please, check if the configuration files are reachable \"\n//                    + \"or properly defined.\");\n//        }\n",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "187",
                    "severity": "error",
                    "message": "Line is longer than 140 characters (found 141).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "187",
                    "severity": "error",
                    "message": "Line is longer than 140 characters (found 141).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/228/OpenCGAWSServer.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/intellij/228/OpenCGAWSServer.java\nindex 50d66bad386..36958004321 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/228/OpenCGAWSServer.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/intellij/228/OpenCGAWSServer.java\n@@ -80,158 +80,158 @@ import static org.opencb.opencga.core.common.JacksonUtils.getExternalOpencgaObje\n @Produces(MediaType.APPLICATION_JSON)\n public class OpenCGAWSServer {\n \n-    @DefaultValue(\"v2\")\n-    @PathParam(\"apiVersion\")\n-    @ApiParam(name = \"apiVersion\", value = \"OpenCGA major version\", allowableValues = \"v2\", defaultValue = \"v2\")\n-    protected String apiVersion;\n-    protected String exclude;\n-    protected String include;\n-    protected int limit;\n-    protected long skip;\n-    protected boolean count;\n-    protected boolean lazy;\n-    protected String token;\n+  @DefaultValue(\"v2\")\n+  @PathParam(\"apiVersion\")\n+  @ApiParam(name = \"apiVersion\", value = \"OpenCGA major version\", allowableValues = \"v2\", defaultValue = \"v2\")\n+  protected String apiVersion;\n+  protected String exclude;\n+  protected String include;\n+  protected int limit;\n+  protected long skip;\n+  protected boolean count;\n+  protected boolean lazy;\n+  protected String token;\n \n-    @DefaultValue(\"\")\n-    @QueryParam(\"sid\")\n-    @ApiParam(value = \"Session id\", hidden = true)\n-    protected String dummySessionId;\n+  @DefaultValue(\"\")\n+  @QueryParam(\"sid\")\n+  @ApiParam(value = \"Session id\", hidden = true)\n+  protected String dummySessionId;\n \n-    @HeaderParam(\"Authorization\")\n-    @DefaultValue(\"Bearer \")\n-    @ApiParam(\"JWT Authentication token\")\n-    protected String authentication;\n+  @HeaderParam(\"Authorization\")\n+  @DefaultValue(\"Bearer \")\n+  @ApiParam(\"JWT Authentication token\")\n+  protected String authentication;\n \n-    protected UriInfo uriInfo;\n-    protected HttpServletRequest httpServletRequest;\n-    protected ObjectMap params;\n-    private String requestDescription;\n+  protected UriInfo uriInfo;\n+  protected HttpServletRequest httpServletRequest;\n+  protected ObjectMap params;\n+  private String requestDescription;\n \n-    protected String sessionIp;\n+  protected String sessionIp;\n \n-    protected long startTime;\n+  protected long startTime;\n \n-    protected Query query;\n-    protected QueryOptions queryOptions;\n+  protected Query query;\n+  protected QueryOptions queryOptions;\n \n-    private static ObjectWriter jsonObjectWriter;\n-    private static ObjectMapper jsonObjectMapper;\n+  private static ObjectWriter jsonObjectWriter;\n+  private static ObjectMapper jsonObjectMapper;\n \n-    protected static Logger logger; // = LoggerFactory.getLogger(this.getClass());\n+  protected static Logger logger; // = LoggerFactory.getLogger(this.getClass());\n \n-    protected static AtomicBoolean initialized;\n+  protected static AtomicBoolean initialized;\n \n-    protected static java.nio.file.Path opencgaHome;\n+  protected static java.nio.file.Path opencgaHome;\n \n-    protected static Configuration configuration;\n-    protected static CatalogManager catalogManager;\n+  protected static Configuration configuration;\n+  protected static CatalogManager catalogManager;\n \n-    protected static StorageConfiguration storageConfiguration;\n-    protected static StorageEngineFactory storageEngineFactory;\n-    protected static VariantStorageManager variantManager;\n+  protected static StorageConfiguration storageConfiguration;\n+  protected static StorageEngineFactory storageEngineFactory;\n+  protected static VariantStorageManager variantManager;\n \n-    private static final int DEFAULT_LIMIT = AbstractManager.DEFAULT_LIMIT;\n-    private static final int MAX_LIMIT = AbstractManager.MAX_LIMIT;\n-    private static final int MAX_ID_SIZE = 100;\n+  private static final int DEFAULT_LIMIT = AbstractManager.DEFAULT_LIMIT;\n+  private static final int MAX_LIMIT = AbstractManager.MAX_LIMIT;\n+  private static final int MAX_ID_SIZE = 100;\n \n-    private static String errorMessage;\n+  private static String errorMessage;\n \n-    static {\n-        initialized = new AtomicBoolean(false);\n+  static {\n+    initialized = new AtomicBoolean(false);\n \n-        jsonObjectMapper = getExternalOpencgaObjectMapper();\n-        jsonObjectMapper.addMixIn(GenericRecord.class, GenericRecordAvroJsonMixin.class);\n-        jsonObjectMapper.addMixIn(VariantStats.class, VariantStatsJsonMixin.class);\n-        jsonObjectMapper.addMixIn(Genotype.class, GenotypeJsonMixin.class);\n+    jsonObjectMapper = getExternalOpencgaObjectMapper();\n+    jsonObjectMapper.addMixIn(GenericRecord.class, GenericRecordAvroJsonMixin.class);\n+    jsonObjectMapper.addMixIn(VariantStats.class, VariantStatsJsonMixin.class);\n+    jsonObjectMapper.addMixIn(Genotype.class, GenotypeJsonMixin.class);\n \n-        jsonObjectWriter = jsonObjectMapper.writer();\n+    jsonObjectWriter = jsonObjectMapper.writer();\n \n-        //Disable MongoDB useless logging\n-        org.apache.log4j.Logger.getLogger(\"org.mongodb.driver.cluster\").setLevel(Level.WARN);\n-        org.apache.log4j.Logger.getLogger(\"org.mongodb.driver.connection\").setLevel(Level.WARN);\n-    }\n+    //Disable MongoDB useless logging\n+    org.apache.log4j.Logger.getLogger(\"org.mongodb.driver.cluster\").setLevel(Level.WARN);\n+    org.apache.log4j.Logger.getLogger(\"org.mongodb.driver.connection\").setLevel(Level.WARN);\n+  }\n \n \n-    public OpenCGAWSServer(@Context UriInfo uriInfo, @Context HttpServletRequest httpServletRequest, @Context HttpHeaders httpHeaders)\n-            throws IOException, VersionException {\n-        this(uriInfo.getPathParameters().getFirst(\"apiVersion\"), uriInfo, httpServletRequest, httpHeaders);\n-    }\n+  public OpenCGAWSServer(@Context UriInfo uriInfo, @Context HttpServletRequest httpServletRequest, @Context HttpHeaders httpHeaders)\n+      throws IOException, VersionException {\n+    this(uriInfo.getPathParameters().getFirst(\"apiVersion\"), uriInfo, httpServletRequest, httpHeaders);\n+  }\n \n-    public OpenCGAWSServer(@PathParam(\"apiVersion\") String version, @Context UriInfo uriInfo,\n-                           @Context HttpServletRequest httpServletRequest, @Context HttpHeaders httpHeaders)\n-            throws VersionException {\n-        this.apiVersion = version;\n-        this.uriInfo = uriInfo;\n-        this.httpServletRequest = httpServletRequest;\n-        httpServletRequest.setAttribute(OpenCGAWSServer.class.getName(), this);\n+  public OpenCGAWSServer(@PathParam(\"apiVersion\") String version, @Context UriInfo uriInfo,\n+                         @Context HttpServletRequest httpServletRequest, @Context HttpHeaders httpHeaders)\n+      throws VersionException {\n+    this.apiVersion = version;\n+    this.uriInfo = uriInfo;\n+    this.httpServletRequest = httpServletRequest;\n+    httpServletRequest.setAttribute(OpenCGAWSServer.class.getName(), this);\n \n-        this.params = new ObjectMap();\n-        for (String key : uriInfo.getQueryParameters().keySet()) {\n-            this.params.put(key, uriInfo.getQueryParameters().getFirst(key));\n-        }\n-        for (String key : uriInfo.getPathParameters().keySet()) {\n-            if (!\"apiVersion\".equals(key)) {\n-                this.params.put(key, uriInfo.getPathParameters().getFirst(key));\n-            }\n-        }\n+    this.params = new ObjectMap();\n+    for (String key : uriInfo.getQueryParameters().keySet()) {\n+      this.params.put(key, uriInfo.getQueryParameters().getFirst(key));\n+    }\n+    for (String key : uriInfo.getPathParameters().keySet()) {\n+      if (!\"apiVersion\".equals(key)) {\n+        this.params.put(key, uriInfo.getPathParameters().getFirst(key));\n+      }\n+    }\n \n-        // This is only executed the first time to initialize configuration and some variables\n-        if (initialized.compareAndSet(false, true)) {\n-            init();\n-        }\n+    // This is only executed the first time to initialize configuration and some variables\n+    if (initialized.compareAndSet(false, true)) {\n+      init();\n+    }\n \n-        if (StringUtils.isNotEmpty(errorMessage)) {\n-            throw new IllegalStateException(errorMessage);\n-        }\n+    if (StringUtils.isNotEmpty(errorMessage)) {\n+      throw new IllegalStateException(errorMessage);\n+    }\n //        if (catalogManager == null) {\n //            throw new IllegalStateException(\"OpenCGA was not properly initialized. Please, check if the configuration files are reachable \"\n //                    + \"or properly defined.\");\n //        }\n \n-        try {\n-            verifyHeaders(httpHeaders);\n-        } catch (CatalogAuthenticationException e) {\n-            throw new IllegalStateException(e);\n-        }\n+    try {\n+      verifyHeaders(httpHeaders);\n+    } catch (CatalogAuthenticationException e) {\n+      throw new IllegalStateException(e);\n+    }\n \n-        query = new Query();\n-        queryOptions = new QueryOptions();\n+    query = new Query();\n+    queryOptions = new QueryOptions();\n \n-        parseParams();\n-        // take the time for calculating the whole duration of the call\n-        startTime = System.currentTimeMillis();\n-    }\n+    parseParams();\n+    // take the time for calculating the whole duration of the call\n+    startTime = System.currentTimeMillis();\n+  }\n \n-    private void init() {\n-        ServletContext context = httpServletRequest.getServletContext();\n-        init(context.getInitParameter(\"OPENCGA_HOME\"));\n-    }\n+  private void init() {\n+    ServletContext context = httpServletRequest.getServletContext();\n+    init(context.getInitParameter(\"OPENCGA_HOME\"));\n+  }\n \n-    static void init(String opencgaHomeStr) {\n-        initialized.set(true);\n+  static void init(String opencgaHomeStr) {\n+    initialized.set(true);\n \n-        logger = LoggerFactory.getLogger(\"org.opencb.opencga.server.rest.OpenCGAWSServer\");\n-        logger.info(\"========================================================================\");\n-        logger.info(\"| Starting OpenCGA REST server, initializing OpenCGAWSServer\");\n-        logger.info(\"| This message must appear only once.\");\n+    logger = LoggerFactory.getLogger(\"org.opencb.opencga.server.rest.OpenCGAWSServer\");\n+    logger.info(\"========================================================================\");\n+    logger.info(\"| Starting OpenCGA REST server, initializing OpenCGAWSServer\");\n+    logger.info(\"| This message must appear only once.\");\n \n-        // We must load the configuration files and init catalogManager, storageManagerFactory and Logger only the first time.\n-        // We first read 'config-dir' parameter passed\n+    // We must load the configuration files and init catalogManager, storageManagerFactory and Logger only the first time.\n+    // We first read 'config-dir' parameter passed\n \n //        String configDirString = context.getInitParameter(\"config-dir\");\n //        if (StringUtils.isEmpty(configDirString)) {\n-        // If not environment variable then we check web.xml parameter\n+    // If not environment variable then we check web.xml parameter\n \n-        // Preference for the env var OPENCGA_HOME\n-        String opencgaHomeEnv = System.getenv(\"OPENCGA_HOME\");\n-        if (StringUtils.isNotEmpty(opencgaHomeEnv)) {\n-            opencgaHomeStr = opencgaHomeEnv;\n-        }\n-        if (StringUtils.isEmpty(opencgaHomeEnv) && StringUtils.isEmpty(opencgaHomeStr)) {\n-            logger.error(\"No valid OpenCGA home directory provided!\");\n-            throw new IllegalStateException(\"No valid OpenCGA home directory provided!\");\n-        }\n-        OpenCGAWSServer.opencgaHome = Paths.get(opencgaHomeStr);\n+    // Preference for the env var OPENCGA_HOME\n+    String opencgaHomeEnv = System.getenv(\"OPENCGA_HOME\");\n+    if (StringUtils.isNotEmpty(opencgaHomeEnv)) {\n+      opencgaHomeStr = opencgaHomeEnv;\n+    }\n+    if (StringUtils.isEmpty(opencgaHomeEnv) && StringUtils.isEmpty(opencgaHomeStr)) {\n+      logger.error(\"No valid OpenCGA home directory provided!\");\n+      throw new IllegalStateException(\"No valid OpenCGA home directory provided!\");\n+    }\n+    OpenCGAWSServer.opencgaHome = Paths.get(opencgaHomeStr);\n \n //        if (StringUtils.isNotEmpty(context.getInitParameter(\"OPENCGA_HOME\"))) {\n //            configDirString = context.getInitParameter(\"OPENCGA_HOME\") + \"/conf\";\n@@ -244,546 +244,546 @@ public class OpenCGAWSServer {\n //        }\n \n \n-        // Check and execute the init methods\n-        java.nio.file.Path configDirPath = OpenCGAWSServer.opencgaHome.resolve(\"conf\");\n-        if (Files.exists(configDirPath) && Files.isDirectory(configDirPath)) {\n-            logger.info(\"|  * Configuration folder: '{}'\", configDirPath.toString());\n-            initOpenCGAObjects(configDirPath);\n-\n-            // TODO use configuration.yml for getting the server.log, for now is hardcoded\n-            logger.info(\"|  * Server logfile: \" + OpenCGAWSServer.opencgaHome.resolve(\"logs\").resolve(\"server.log\"));\n-            initLogger(OpenCGAWSServer.opencgaHome.resolve(\"logs\"));\n-        } else {\n-            errorMessage = \"No valid configuration directory provided: '\" + configDirPath.toString() + \"'\";\n-            logger.error(errorMessage);\n-            throw new IllegalStateException(errorMessage);\n-        }\n-\n-        logger.info(\"========================================================================\\n\");\n-    }\n-\n-    /**\n-     * This method loads OpenCGA configuration files and initialize CatalogManager and StorageManagerFactory.\n-     * This must be only executed once.\n-     *\n-     * @param configDir directory containing the configuration files\n-     */\n-    private static void initOpenCGAObjects(java.nio.file.Path configDir) {\n-        try {\n-            logger.info(\"|  * Catalog configuration file: '{}'\", configDir.toFile().getAbsolutePath() + \"/configuration.yml\");\n-            configuration = Configuration\n-                    .load(new FileInputStream(new File(configDir.toFile().getAbsolutePath() + \"/configuration.yml\")));\n-            catalogManager = new CatalogManager(configuration);\n-\n-            logger.info(\"|  * Storage configuration file: '{}'\", configDir.toFile().getAbsolutePath() + \"/storage-configuration.yml\");\n-            storageConfiguration = StorageConfiguration\n-                    .load(new FileInputStream(new File(configDir.toFile().getAbsolutePath() + \"/storage-configuration.yml\")));\n-            storageEngineFactory = StorageEngineFactory.get(storageConfiguration);\n-            variantManager = new VariantStorageManager(catalogManager, storageEngineFactory);\n-        } catch (IOException | CatalogException e) {\n-            errorMessage = e.getMessage();\n-            e.printStackTrace();\n-            logger.error(\"Error while creating CatalogManager\", e);\n-        }\n-    }\n-\n-    private static void initLogger(java.nio.file.Path logs) {\n-        try {\n-            org.apache.log4j.Logger rootLogger = LogManager.getRootLogger();\n-            PatternLayout layout = new PatternLayout(\"%d{yyyy-MM-dd HH:mm:ss} [%t] %-5p %c{1}:%L - %m%n\");\n-            String logFile = logs.resolve(\"server.log\").toString();\n-            RollingFileAppender rollingFileAppender = new RollingFileAppender(layout, logFile, true);\n-            rollingFileAppender.setThreshold(Level.DEBUG);\n-            rollingFileAppender.setMaxFileSize(\"20MB\");\n-            rollingFileAppender.setMaxBackupIndex(10);\n-            rootLogger.setLevel(Level.TRACE);\n-            rootLogger.addAppender(rollingFileAppender);\n-        } catch (IOException e) {\n-            e.printStackTrace();\n-        }\n-    }\n-\n-    static void shutdown() {\n-        logger.info(\"========================================================================\");\n-        logger.info(\"| Stopping OpenCGA REST server\");\n-        try {\n-            if (OpenCGAWSServer.variantManager != null) {\n-                logger.info(\"| * Closing VariantStorageManager\");\n-                OpenCGAWSServer.variantManager.close();\n-            }\n-        } catch (Exception e) {\n-            logger.error(\"Error closing VariantManager\", e);\n-        }\n-        try {\n-            if (OpenCGAWSServer.catalogManager != null) {\n-                logger.info(\"| * Closing CatalogManager\");\n-                OpenCGAWSServer.catalogManager.close();\n-            }\n-        } catch (Exception e) {\n-            logger.error(\"Error closing CatalogManager\", e);\n-        }\n-        logger.info(\"| OpenCGA destroyed\");\n-        logger.info(\"========================================================================\\n\");\n-    }\n-\n-    private void parseParams() throws VersionException {\n-        // If by any reason 'apiVersion' is null we try to read it from the URI path, if not present an Exception is thrown\n-        if (apiVersion == null) {\n-            if (uriInfo.getPathParameters().containsKey(\"apiVersion\")) {\n-                logger.warn(\"Setting 'apiVersion' from UriInfo object\");\n-                this.apiVersion = uriInfo.getPathParameters().getFirst(\"apiVersion\");\n-            } else {\n-                throw new VersionException(\"Version not valid: '\" + apiVersion + \"'\");\n-            }\n-        }\n-\n-        // Check apiVersion parameter, must be: v1, v2, ... If 'latest' then is converted to appropriate apiVersion.\n-        if (apiVersion.equalsIgnoreCase(\"latest\")) {\n-            logger.info(\"Version 'latest' detected, setting 'apiVersion' parameter to 'v1'\");\n-            apiVersion = \"v1\";\n-        }\n-\n-        MultivaluedMap<String, String> multivaluedMap = uriInfo.getQueryParameters();\n-        queryOptions.put(\"metadata\", multivaluedMap.get(\"metadata\") == null || multivaluedMap.get(\"metadata\").get(0).equals(\"true\"));\n-\n-        // By default, we will avoid counting the number of documents unless explicitly specified.\n-        queryOptions.put(QueryOptions.SKIP_COUNT, true);\n-\n-        // Add all the others QueryParams from the URL\n-        for (Map.Entry<String, List<String>> entry : multivaluedMap.entrySet()) {\n-            String value = entry.getValue().get(0);\n-            switch (entry.getKey()) {\n-                case QueryOptions.INCLUDE:\n-                case QueryOptions.EXCLUDE:\n-                    queryOptions.put(entry.getKey(), new LinkedList<>(Splitter.on(\",\").splitToList(value)));\n-                    break;\n-                case QueryOptions.LIMIT:\n-                    limit = Integer.parseInt(value);\n-                    break;\n-                case QueryOptions.TIMEOUT:\n-                    queryOptions.put(entry.getKey(), Integer.parseInt(value));\n-                    break;\n-                case QueryOptions.SKIP:\n-                    int skip = Integer.parseInt(value);\n-                    queryOptions.put(entry.getKey(), (skip >= 0) ? skip : -1);\n-                    break;\n-                case QueryOptions.SORT:\n-                case QueryOptions.ORDER:\n-                    queryOptions.put(entry.getKey(), value);\n-                    break;\n-                case QueryOptions.SKIP_COUNT:\n-                    queryOptions.put(QueryOptions.SKIP_COUNT, Boolean.parseBoolean(value));\n-                    break;\n-                case Constants.INCREMENT_VERSION:\n-                    queryOptions.put(Constants.INCREMENT_VERSION, Boolean.parseBoolean(value));\n-                    break;\n-                case Constants.REFRESH:\n-                    queryOptions.put(Constants.REFRESH, Boolean.parseBoolean(value));\n-                    break;\n-                case QueryOptions.COUNT:\n-                    count = Boolean.parseBoolean(value);\n-                    queryOptions.put(entry.getKey(), count);\n-                    break;\n-                case Constants.SILENT:\n-                    queryOptions.put(entry.getKey(), Boolean.parseBoolean(value));\n-                    break;\n-                case Constants.FORCE:\n-                    queryOptions.put(entry.getKey(), Boolean.parseBoolean(value));\n-                    break;\n-                case ParamConstants.FLATTEN_ANNOTATIONS:\n-                    queryOptions.put(ParamConstants.FLATTEN_ANNOTATIONS, Boolean.parseBoolean(value));\n-                    break;\n-                case ParamConstants.OTHER_STUDIES_FLAG:\n-                    queryOptions.put(ParamConstants.OTHER_STUDIES_FLAG, Boolean.parseBoolean(value));\n-                    break;\n-                case ParamConstants.SAMPLE_INCLUDE_INDIVIDUAL_PARAM: // SampleWS\n-                    queryOptions.put(ParamConstants.SAMPLE_INCLUDE_INDIVIDUAL_PARAM, Boolean.parseBoolean(value));\n-                    break;\n-                case \"lazy\":\n-                    lazy = Boolean.parseBoolean(value);\n-                    queryOptions.put(entry.getKey(), lazy);\n-                    break;\n-                case QueryOptions.FACET:\n-                    queryOptions.put(entry.getKey(), value);\n-                    break;\n-                default:\n-                    // Query\n-                    query.put(entry.getKey(), value);\n-                    break;\n-            }\n-        }\n-\n-        queryOptions.put(QueryOptions.LIMIT, (limit > 0) ? Math.min(limit, MAX_LIMIT) : (count ? 0 : DEFAULT_LIMIT));\n-        query.remove(\"sid\");\n+    // Check and execute the init methods\n+    java.nio.file.Path configDirPath = OpenCGAWSServer.opencgaHome.resolve(\"conf\");\n+    if (Files.exists(configDirPath) && Files.isDirectory(configDirPath)) {\n+      logger.info(\"|  * Configuration folder: '{}'\", configDirPath.toString());\n+      initOpenCGAObjects(configDirPath);\n+\n+      // TODO use configuration.yml for getting the server.log, for now is hardcoded\n+      logger.info(\"|  * Server logfile: \" + OpenCGAWSServer.opencgaHome.resolve(\"logs\").resolve(\"server.log\"));\n+      initLogger(OpenCGAWSServer.opencgaHome.resolve(\"logs\"));\n+    } else {\n+      errorMessage = \"No valid configuration directory provided: '\" + configDirPath.toString() + \"'\";\n+      logger.error(errorMessage);\n+      throw new IllegalStateException(errorMessage);\n+    }\n+\n+    logger.info(\"========================================================================\\n\");\n+  }\n+\n+  /**\n+   * This method loads OpenCGA configuration files and initialize CatalogManager and StorageManagerFactory.\n+   * This must be only executed once.\n+   *\n+   * @param configDir directory containing the configuration files\n+   */\n+  private static void initOpenCGAObjects(java.nio.file.Path configDir) {\n+    try {\n+      logger.info(\"|  * Catalog configuration file: '{}'\", configDir.toFile().getAbsolutePath() + \"/configuration.yml\");\n+      configuration = Configuration\n+          .load(new FileInputStream(new File(configDir.toFile().getAbsolutePath() + \"/configuration.yml\")));\n+      catalogManager = new CatalogManager(configuration);\n+\n+      logger.info(\"|  * Storage configuration file: '{}'\", configDir.toFile().getAbsolutePath() + \"/storage-configuration.yml\");\n+      storageConfiguration = StorageConfiguration\n+          .load(new FileInputStream(new File(configDir.toFile().getAbsolutePath() + \"/storage-configuration.yml\")));\n+      storageEngineFactory = StorageEngineFactory.get(storageConfiguration);\n+      variantManager = new VariantStorageManager(catalogManager, storageEngineFactory);\n+    } catch (IOException | CatalogException e) {\n+      errorMessage = e.getMessage();\n+      e.printStackTrace();\n+      logger.error(\"Error while creating CatalogManager\", e);\n+    }\n+  }\n+\n+  private static void initLogger(java.nio.file.Path logs) {\n+    try {\n+      org.apache.log4j.Logger rootLogger = LogManager.getRootLogger();\n+      PatternLayout layout = new PatternLayout(\"%d{yyyy-MM-dd HH:mm:ss} [%t] %-5p %c{1}:%L - %m%n\");\n+      String logFile = logs.resolve(\"server.log\").toString();\n+      RollingFileAppender rollingFileAppender = new RollingFileAppender(layout, logFile, true);\n+      rollingFileAppender.setThreshold(Level.DEBUG);\n+      rollingFileAppender.setMaxFileSize(\"20MB\");\n+      rollingFileAppender.setMaxBackupIndex(10);\n+      rootLogger.setLevel(Level.TRACE);\n+      rootLogger.addAppender(rollingFileAppender);\n+    } catch (IOException e) {\n+      e.printStackTrace();\n+    }\n+  }\n+\n+  static void shutdown() {\n+    logger.info(\"========================================================================\");\n+    logger.info(\"| Stopping OpenCGA REST server\");\n+    try {\n+      if (OpenCGAWSServer.variantManager != null) {\n+        logger.info(\"| * Closing VariantStorageManager\");\n+        OpenCGAWSServer.variantManager.close();\n+      }\n+    } catch (Exception e) {\n+      logger.error(\"Error closing VariantManager\", e);\n+    }\n+    try {\n+      if (OpenCGAWSServer.catalogManager != null) {\n+        logger.info(\"| * Closing CatalogManager\");\n+        OpenCGAWSServer.catalogManager.close();\n+      }\n+    } catch (Exception e) {\n+      logger.error(\"Error closing CatalogManager\", e);\n+    }\n+    logger.info(\"| OpenCGA destroyed\");\n+    logger.info(\"========================================================================\\n\");\n+  }\n+\n+  private void parseParams() throws VersionException {\n+    // If by any reason 'apiVersion' is null we try to read it from the URI path, if not present an Exception is thrown\n+    if (apiVersion == null) {\n+      if (uriInfo.getPathParameters().containsKey(\"apiVersion\")) {\n+        logger.warn(\"Setting 'apiVersion' from UriInfo object\");\n+        this.apiVersion = uriInfo.getPathParameters().getFirst(\"apiVersion\");\n+      } else {\n+        throw new VersionException(\"Version not valid: '\" + apiVersion + \"'\");\n+      }\n+    }\n+\n+    // Check apiVersion parameter, must be: v1, v2, ... If 'latest' then is converted to appropriate apiVersion.\n+    if (apiVersion.equalsIgnoreCase(\"latest\")) {\n+      logger.info(\"Version 'latest' detected, setting 'apiVersion' parameter to 'v1'\");\n+      apiVersion = \"v1\";\n+    }\n+\n+    MultivaluedMap<String, String> multivaluedMap = uriInfo.getQueryParameters();\n+    queryOptions.put(\"metadata\", multivaluedMap.get(\"metadata\") == null || multivaluedMap.get(\"metadata\").get(0).equals(\"true\"));\n+\n+    // By default, we will avoid counting the number of documents unless explicitly specified.\n+    queryOptions.put(QueryOptions.SKIP_COUNT, true);\n+\n+    // Add all the others QueryParams from the URL\n+    for (Map.Entry<String, List<String>> entry : multivaluedMap.entrySet()) {\n+      String value = entry.getValue().get(0);\n+      switch (entry.getKey()) {\n+        case QueryOptions.INCLUDE:\n+        case QueryOptions.EXCLUDE:\n+          queryOptions.put(entry.getKey(), new LinkedList<>(Splitter.on(\",\").splitToList(value)));\n+          break;\n+        case QueryOptions.LIMIT:\n+          limit = Integer.parseInt(value);\n+          break;\n+        case QueryOptions.TIMEOUT:\n+          queryOptions.put(entry.getKey(), Integer.parseInt(value));\n+          break;\n+        case QueryOptions.SKIP:\n+          int skip = Integer.parseInt(value);\n+          queryOptions.put(entry.getKey(), (skip >= 0) ? skip : -1);\n+          break;\n+        case QueryOptions.SORT:\n+        case QueryOptions.ORDER:\n+          queryOptions.put(entry.getKey(), value);\n+          break;\n+        case QueryOptions.SKIP_COUNT:\n+          queryOptions.put(QueryOptions.SKIP_COUNT, Boolean.parseBoolean(value));\n+          break;\n+        case Constants.INCREMENT_VERSION:\n+          queryOptions.put(Constants.INCREMENT_VERSION, Boolean.parseBoolean(value));\n+          break;\n+        case Constants.REFRESH:\n+          queryOptions.put(Constants.REFRESH, Boolean.parseBoolean(value));\n+          break;\n+        case QueryOptions.COUNT:\n+          count = Boolean.parseBoolean(value);\n+          queryOptions.put(entry.getKey(), count);\n+          break;\n+        case Constants.SILENT:\n+          queryOptions.put(entry.getKey(), Boolean.parseBoolean(value));\n+          break;\n+        case Constants.FORCE:\n+          queryOptions.put(entry.getKey(), Boolean.parseBoolean(value));\n+          break;\n+        case ParamConstants.FLATTEN_ANNOTATIONS:\n+          queryOptions.put(ParamConstants.FLATTEN_ANNOTATIONS, Boolean.parseBoolean(value));\n+          break;\n+        case ParamConstants.OTHER_STUDIES_FLAG:\n+          queryOptions.put(ParamConstants.OTHER_STUDIES_FLAG, Boolean.parseBoolean(value));\n+          break;\n+        case ParamConstants.SAMPLE_INCLUDE_INDIVIDUAL_PARAM: // SampleWS\n+          queryOptions.put(ParamConstants.SAMPLE_INCLUDE_INDIVIDUAL_PARAM, Boolean.parseBoolean(value));\n+          break;\n+        case \"lazy\":\n+          lazy = Boolean.parseBoolean(value);\n+          queryOptions.put(entry.getKey(), lazy);\n+          break;\n+        case QueryOptions.FACET:\n+          queryOptions.put(entry.getKey(), value);\n+          break;\n+        default:\n+          // Query\n+          query.put(entry.getKey(), value);\n+          break;\n+      }\n+    }\n+\n+    queryOptions.put(QueryOptions.LIMIT, (limit > 0) ? Math.min(limit, MAX_LIMIT) : (count ? 0 : DEFAULT_LIMIT));\n+    query.remove(\"sid\");\n \n //      Exceptions\n-        if (query.containsKey(\"status\")) {\n-            query.put(\"status.name\", query.get(\"status\"));\n-            query.remove(\"status\");\n-        }\n-\n-        // Remove deprecated fields\n-        query.remove(\"variableSet\");\n-        query.remove(\"annotationsetName\");\n-\n-        try {\n-            requestDescription = httpServletRequest.getMethod() + \": \" + uriInfo.getAbsolutePath().toString()\n-                    + \", \" + jsonObjectWriter.writeValueAsString(query)\n-                    + \", \" + jsonObjectWriter.writeValueAsString(queryOptions);\n-            logger.info(requestDescription);\n-        } catch (JsonProcessingException e) {\n-            requestDescription = httpServletRequest.getMethod() + \": \" + uriInfo.getRequestUri();\n-            logger.info(requestDescription);\n-            logger.error(\"Error writing as Json\", e);\n-        }\n-    }\n-\n-    private void parseIncludeExclude(MultivaluedMap<String, String> multivaluedMap, String key, String value) {\n-        if (value != null && !value.isEmpty()) {\n-            queryOptions.put(key, new LinkedList<>(Splitter.on(\",\").splitToList(value)));\n+    if (query.containsKey(\"status\")) {\n+      query.put(\"status.name\", query.get(\"status\"));\n+      query.remove(\"status\");\n+    }\n+\n+    // Remove deprecated fields\n+    query.remove(\"variableSet\");\n+    query.remove(\"annotationsetName\");\n+\n+    try {\n+      requestDescription = httpServletRequest.getMethod() + \": \" + uriInfo.getAbsolutePath().toString()\n+          + \", \" + jsonObjectWriter.writeValueAsString(query)\n+          + \", \" + jsonObjectWriter.writeValueAsString(queryOptions);\n+      logger.info(requestDescription);\n+    } catch (JsonProcessingException e) {\n+      requestDescription = httpServletRequest.getMethod() + \": \" + uriInfo.getRequestUri();\n+      logger.info(requestDescription);\n+      logger.error(\"Error writing as Json\", e);\n+    }\n+  }\n+\n+  private void parseIncludeExclude(MultivaluedMap<String, String> multivaluedMap, String key, String value) {\n+    if (value != null && !value.isEmpty()) {\n+      queryOptions.put(key, new LinkedList<>(Splitter.on(\",\").splitToList(value)));\n+    } else {\n+      queryOptions.put(key, (multivaluedMap.get(key) != null)\n+          ? Splitter.on(\",\").splitToList(multivaluedMap.get(key).get(0))\n+          : null);\n+    }\n+  }\n+\n+\n+  protected void addParamIfNotNull(Map<String, Object> params, String key, Object value) {\n+    if (key != null && value != null) {\n+      params.put(key, value.toString());\n+    }\n+  }\n+\n+  protected void addParamIfTrue(Map<String, Object> params, String key, boolean value) {\n+    if (key != null && value) {\n+      params.put(key, Boolean.toString(value));\n+    }\n+  }\n+\n+  protected Response createErrorResponse(Throwable e) {\n+    // First we print the exception in Server logs\n+    logger.error(\"Catch error: \" + e.getMessage(), e);\n+\n+    // Now we prepare the response to client\n+    RestResponse<ObjectMap> queryResponse = new RestResponse<>();\n+    queryResponse.setTime(new Long(System.currentTimeMillis() - startTime).intValue());\n+    queryResponse.setApiVersion(apiVersion);\n+    queryResponse.setParams(params);\n+    addErrorEvent(queryResponse, e);\n+\n+    OpenCGAResult<ObjectMap> result = OpenCGAResult.empty();\n+    queryResponse.setResponses(Arrays.asList(result));\n+\n+    Response.Status errorStatus = Response.Status.INTERNAL_SERVER_ERROR;\n+    if (e instanceof CatalogAuthorizationException) {\n+      errorStatus = Response.Status.FORBIDDEN;\n+    } else if (e instanceof CatalogAuthenticationException) {\n+      errorStatus = Response.Status.UNAUTHORIZED;\n+    }\n+\n+    Response response = Response.fromResponse(createJsonResponse(queryResponse)).status(errorStatus).build();\n+    logResponse(response.getStatusInfo(), queryResponse);\n+    return response;\n+  }\n+\n+  protected Response createErrorResponse(String errorMessage, OpenCGAResult result) {\n+    RestResponse<ObjectMap> dataResponse = new RestResponse<>();\n+    dataResponse.setApiVersion(apiVersion);\n+    dataResponse.setParams(params);\n+    addErrorEvent(dataResponse, errorMessage);\n+    dataResponse.setResponses(Arrays.asList(result));\n+\n+    Response response = Response.fromResponse(createJsonResponse(dataResponse)).status(Response.Status.INTERNAL_SERVER_ERROR).build();\n+    logResponse(response.getStatusInfo(), dataResponse);\n+    return response;\n+  }\n+\n+  protected Response createErrorResponse(String method, String errorMessage) {\n+    try {\n+      Response response = buildResponse(Response.ok(jsonObjectWriter.writeValueAsString(new ObjectMap(\"error\", errorMessage)),\n+          MediaType.APPLICATION_JSON_TYPE));\n+      logResponse(response.getStatusInfo());\n+      return response;\n+    } catch (JsonProcessingException e) {\n+      e.printStackTrace();\n+    }\n+\n+    return buildResponse(Response.ok(\"{\\\"error\\\":\\\"Error parsing json error\\\"}\", MediaType.APPLICATION_JSON_TYPE));\n+  }\n+\n+  private <T> void addErrorEvent(RestResponse<T> response, String message) {\n+    if (response.getEvents() == null) {\n+      response.setEvents(new ArrayList<>());\n+    }\n+    response.getEvents().add(new Event(Event.Type.ERROR, message));\n+  }\n+\n+  private <T> void addErrorEvent(RestResponse<T> response, Throwable e) {\n+    if (response.getEvents() == null) {\n+      response.setEvents(new ArrayList<>());\n+    }\n+    response.getEvents().add(\n+        new Event(Event.Type.ERROR, 0, e.getClass().getName(), e.getClass().getSimpleName(), e.getMessage()));\n+  }\n+\n+  // TODO: Change signature\n+  //    protected <T> Response createOkResponse(OpenCGAResult<T> result)\n+  //    protected <T> Response createOkResponse(List<OpenCGAResult<T>> results)\n+  protected Response createOkResponse(Object obj) {\n+    RestResponse queryResponse = new RestResponse();\n+    queryResponse.setTime(new Long(System.currentTimeMillis() - startTime).intValue());\n+    queryResponse.setApiVersion(apiVersion);\n+    queryResponse.setParams(params);\n+\n+    // Guarantee that the RestResponse object contains a list of results\n+    List<OpenCGAResult<?>> list = new ArrayList<>();\n+    if (obj instanceof List) {\n+      if (!((List) obj).isEmpty()) {\n+        Object firstObject = ((List) obj).get(0);\n+        if (firstObject instanceof OpenCGAResult) {\n+          list = (List) obj;\n+        } else if (firstObject instanceof DataResult) {\n+          List<DataResult> results = (List) obj;\n+          // We will cast each of the DataResults to OpenCGAResult\n+          for (DataResult result : results) {\n+            list.add(new OpenCGAResult<>(result));\n+          }\n         } else {\n-            queryOptions.put(key, (multivaluedMap.get(key) != null)\n-                    ? Splitter.on(\",\").splitToList(multivaluedMap.get(key).get(0))\n-                    : null);\n-        }\n-    }\n-\n-\n-    protected void addParamIfNotNull(Map<String, Object> params, String key, Object value) {\n-        if (key != null && value != null) {\n-            params.put(key, value.toString());\n-        }\n-    }\n-\n-    protected void addParamIfTrue(Map<String, Object> params, String key, boolean value) {\n-        if (key != null && value) {\n-            params.put(key, Boolean.toString(value));\n-        }\n-    }\n-\n-    protected Response createErrorResponse(Throwable e) {\n-        // First we print the exception in Server logs\n-        logger.error(\"Catch error: \" + e.getMessage(), e);\n-\n-        // Now we prepare the response to client\n-        RestResponse<ObjectMap> queryResponse = new RestResponse<>();\n-        queryResponse.setTime(new Long(System.currentTimeMillis() - startTime).intValue());\n-        queryResponse.setApiVersion(apiVersion);\n-        queryResponse.setParams(params);\n-        addErrorEvent(queryResponse, e);\n-\n-        OpenCGAResult<ObjectMap> result = OpenCGAResult.empty();\n-        queryResponse.setResponses(Arrays.asList(result));\n-\n-        Response.Status errorStatus = Response.Status.INTERNAL_SERVER_ERROR;\n-        if (e instanceof CatalogAuthorizationException) {\n-            errorStatus = Response.Status.FORBIDDEN;\n-        } else if (e instanceof CatalogAuthenticationException) {\n-            errorStatus = Response.Status.UNAUTHORIZED;\n-        }\n-\n-        Response response = Response.fromResponse(createJsonResponse(queryResponse)).status(errorStatus).build();\n-        logResponse(response.getStatusInfo(), queryResponse);\n-        return response;\n-    }\n-\n-    protected Response createErrorResponse(String errorMessage, OpenCGAResult result) {\n-        RestResponse<ObjectMap> dataResponse = new RestResponse<>();\n-        dataResponse.setApiVersion(apiVersion);\n-        dataResponse.setParams(params);\n-        addErrorEvent(dataResponse, errorMessage);\n-        dataResponse.setResponses(Arrays.asList(result));\n-\n-        Response response = Response.fromResponse(createJsonResponse(dataResponse)).status(Response.Status.INTERNAL_SERVER_ERROR).build();\n-        logResponse(response.getStatusInfo(), dataResponse);\n-        return response;\n-    }\n-\n-    protected Response createErrorResponse(String method, String errorMessage) {\n-        try {\n-            Response response = buildResponse(Response.ok(jsonObjectWriter.writeValueAsString(new ObjectMap(\"error\", errorMessage)),\n-                    MediaType.APPLICATION_JSON_TYPE));\n-            logResponse(response.getStatusInfo());\n-            return response;\n-        } catch (JsonProcessingException e) {\n-            e.printStackTrace();\n-        }\n-\n-        return buildResponse(Response.ok(\"{\\\"error\\\":\\\"Error parsing json error\\\"}\", MediaType.APPLICATION_JSON_TYPE));\n-    }\n-\n-    private <T> void addErrorEvent(RestResponse<T> response, String message) {\n-        if (response.getEvents() == null) {\n-            response.setEvents(new ArrayList<>());\n-        }\n-        response.getEvents().add(new Event(Event.Type.ERROR, message));\n-    }\n-\n-    private <T> void addErrorEvent(RestResponse<T> response, Throwable e) {\n-        if (response.getEvents() == null) {\n-            response.setEvents(new ArrayList<>());\n-        }\n-        response.getEvents().add(\n-                new Event(Event.Type.ERROR, 0, e.getClass().getName(), e.getClass().getSimpleName(), e.getMessage()));\n-    }\n-\n-    // TODO: Change signature\n-    //    protected <T> Response createOkResponse(OpenCGAResult<T> result)\n-    //    protected <T> Response createOkResponse(List<OpenCGAResult<T>> results)\n-    protected Response createOkResponse(Object obj) {\n-        RestResponse queryResponse = new RestResponse();\n-        queryResponse.setTime(new Long(System.currentTimeMillis() - startTime).intValue());\n-        queryResponse.setApiVersion(apiVersion);\n-        queryResponse.setParams(params);\n-\n-        // Guarantee that the RestResponse object contains a list of results\n-        List<OpenCGAResult<?>> list = new ArrayList<>();\n-        if (obj instanceof List) {\n-            if (!((List) obj).isEmpty()) {\n-                Object firstObject = ((List) obj).get(0);\n-                if (firstObject instanceof OpenCGAResult) {\n-                    list = (List) obj;\n-                } else if (firstObject instanceof DataResult) {\n-                    List<DataResult> results = (List) obj;\n-                    // We will cast each of the DataResults to OpenCGAResult\n-                    for (DataResult result : results) {\n-                        list.add(new OpenCGAResult<>(result));\n-                    }\n-                } else {\n-                    list = Collections.singletonList(new OpenCGAResult<>(0, Collections.emptyList(), 1, (List) obj, 1));\n-                }\n-            }\n-        } else {\n-            if (obj instanceof OpenCGAResult) {\n-                list.add(((OpenCGAResult) obj));\n-            } else if (obj instanceof DataResult) {\n-                list.add(new OpenCGAResult<>((DataResult) obj));\n-            } else {\n-                list.add(new OpenCGAResult<>(0, Collections.emptyList(), 1, Collections.singletonList(obj), 1));\n-            }\n-        }\n-        queryResponse.setResponses(list);\n-\n-        Response response = createJsonResponse(queryResponse);\n-        logResponse(response.getStatusInfo(), queryResponse);\n-        return response;\n-    }\n-\n-    protected Response createRawOkResponse(Object obj) {\n-        try {\n-            String res = jsonObjectWriter.writeValueAsString(obj);\n+          list = Collections.singletonList(new OpenCGAResult<>(0, Collections.emptyList(), 1, (List) obj, 1));\n+        }\n+      }\n+    } else {\n+      if (obj instanceof OpenCGAResult) {\n+        list.add(((OpenCGAResult) obj));\n+      } else if (obj instanceof DataResult) {\n+        list.add(new OpenCGAResult<>((DataResult) obj));\n+      } else {\n+        list.add(new OpenCGAResult<>(0, Collections.emptyList(), 1, Collections.singletonList(obj), 1));\n+      }\n+    }\n+    queryResponse.setResponses(list);\n+\n+    Response response = createJsonResponse(queryResponse);\n+    logResponse(response.getStatusInfo(), queryResponse);\n+    return response;\n+  }\n+\n+  protected Response createRawOkResponse(Object obj) {\n+    try {\n+      String res = jsonObjectWriter.writeValueAsString(obj);\n //            System.out.println(\"\\n\\n\\n\" + res + \"\\n\\n\");\n-            Response response = buildResponse(Response.ok(res, MediaType.APPLICATION_JSON_TYPE));\n-            logResponse(response.getStatusInfo());\n-            return response;\n-        } catch (JsonProcessingException e) {\n-            e.printStackTrace();\n-            logger.error(\"Error parsing response object\");\n-            return createErrorResponse(\"\", \"Error parsing response object:\\n\" + Arrays.toString(e.getStackTrace()));\n-        }\n-    }\n-\n-    //Response methods\n-    protected Response createOkResponse(Object o1, MediaType o2) {\n-        return buildResponse(Response.ok(o1, o2));\n-    }\n-\n-    protected Response createOkResponse(Object o1, MediaType o2, String fileName) {\n-        return buildResponse(Response.ok(o1, o2).header(\"content-disposition\", \"attachment; filename =\" + fileName));\n-    }\n-\n-    private void logResponse(Response.StatusType statusInfo) {\n-        logResponse(statusInfo, null);\n-    }\n-\n-    private void logResponse(Response.StatusType statusInfo, RestResponse<?> queryResponse) {\n-        StringBuilder sb = new StringBuilder();\n-        try {\n-            if (statusInfo.getFamily().equals(Response.Status.Family.SUCCESSFUL)) {\n-                sb.append(\"OK\");\n-            } else {\n-                sb.append(\"ERROR\");\n-            }\n-            sb.append(\" [\").append(statusInfo.getStatusCode()).append(']');\n-\n-            if (queryResponse == null) {\n-                sb.append(\", \").append(System.currentTimeMillis() - startTime).append(\"ms\");\n-            } else {\n-                sb.append(\", \").append(queryResponse.getTime()).append(\"ms\");\n-                if (queryResponse.getResponses().size() == 1) {\n-                    OpenCGAResult<?> result = queryResponse.getResponses().get(0);\n-                    if (result != null) {\n-                        sb.append(\", num: \").append(result.getNumResults());\n-                        if (result.getNumTotalResults() >= 0) {\n-                            sb.append(\", total: \").append(result.getNumTotalResults());\n-                        }\n-                    }\n-                }\n+      Response response = buildResponse(Response.ok(res, MediaType.APPLICATION_JSON_TYPE));\n+      logResponse(response.getStatusInfo());\n+      return response;\n+    } catch (JsonProcessingException e) {\n+      e.printStackTrace();\n+      logger.error(\"Error parsing response object\");\n+      return createErrorResponse(\"\", \"Error parsing response object:\\n\" + Arrays.toString(e.getStackTrace()));\n+    }\n+  }\n+\n+  //Response methods\n+  protected Response createOkResponse(Object o1, MediaType o2) {\n+    return buildResponse(Response.ok(o1, o2));\n+  }\n+\n+  protected Response createOkResponse(Object o1, MediaType o2, String fileName) {\n+    return buildResponse(Response.ok(o1, o2).header(\"content-disposition\", \"attachment; filename =\" + fileName));\n+  }\n+\n+  private void logResponse(Response.StatusType statusInfo) {\n+    logResponse(statusInfo, null);\n+  }\n+\n+  private void logResponse(Response.StatusType statusInfo, RestResponse<?> queryResponse) {\n+    StringBuilder sb = new StringBuilder();\n+    try {\n+      if (statusInfo.getFamily().equals(Response.Status.Family.SUCCESSFUL)) {\n+        sb.append(\"OK\");\n+      } else {\n+        sb.append(\"ERROR\");\n+      }\n+      sb.append(\" [\").append(statusInfo.getStatusCode()).append(']');\n+\n+      if (queryResponse == null) {\n+        sb.append(\", \").append(System.currentTimeMillis() - startTime).append(\"ms\");\n+      } else {\n+        sb.append(\", \").append(queryResponse.getTime()).append(\"ms\");\n+        if (queryResponse.getResponses().size() == 1) {\n+          OpenCGAResult<?> result = queryResponse.getResponses().get(0);\n+          if (result != null) {\n+            sb.append(\", num: \").append(result.getNumResults());\n+            if (result.getNumTotalResults() >= 0) {\n+              sb.append(\", total: \").append(result.getNumTotalResults());\n             }\n-            sb.append(\", \").append(requestDescription);\n-            logger.info(sb.toString());\n-        } catch (RuntimeException e) {\n-            logger.warn(\"Error logging response\", e);\n-            logger.info(sb.toString()); // Print incomplete response\n-        }\n-    }\n-\n-    protected Response createJsonResponse(RestResponse queryResponse) {\n-        try {\n-            return buildResponse(Response.ok(jsonObjectWriter.writeValueAsString(queryResponse), MediaType.APPLICATION_JSON_TYPE));\n-        } catch (JsonProcessingException e) {\n-            e.printStackTrace();\n-            logger.error(\"Error parsing queryResponse object\");\n-            return createErrorResponse(\"\", \"Error parsing RestResponse object:\\n\" + Arrays.toString(e.getStackTrace()));\n-        }\n-    }\n-\n-    protected Response buildResponse(Response.ResponseBuilder responseBuilder) {\n-        return responseBuilder\n-                .header(\"Access-Control-Allow-Origin\", \"*\")\n-                .header(\"Access-Control-Allow-Headers\", \"x-requested-with, content-type, authorization\")\n-                .header(\"Access-Control-Allow-Credentials\", \"true\")\n-                .header(\"Access-Control-Allow-Methods\", \"GET, POST, OPTIONS\")\n-                .build();\n-    }\n-\n-    private void verifyHeaders(HttpHeaders httpHeaders) throws CatalogAuthenticationException {\n-        List<String> authorization = httpHeaders.getRequestHeader(\"Authorization\");\n-        if (authorization != null && authorization.get(0).length() > 7) {\n-            String token = authorization.get(0);\n-            if (!token.startsWith(\"Bearer \")) {\n-                throw new CatalogAuthenticationException(\"Authorization header must start with Bearer JWToken\");\n-            }\n-            this.token = token.substring(\"Bearer\".length()).trim();\n-        }\n-\n-        if (StringUtils.isEmpty(this.token)) {\n-            this.token = this.params.getString(\"sid\");\n-        }\n-    }\n-\n-    protected List<String> getIdListOrEmpty(String id) throws WebServiceException {\n-        return id == null ? Collections.emptyList() : getIdList(id, true);\n-    }\n-\n-    protected List<String> getIdList(String id) throws WebServiceException {\n-        return getIdList(id, true);\n-    }\n-\n-    protected List<String> getIdList(String id, boolean checkMaxNumberElements) throws WebServiceException {\n-        if (StringUtils.isNotEmpty(id)) {\n-            List<String> ids = checkUniqueList(id);\n-            if (checkMaxNumberElements && ids.size() > MAX_ID_SIZE) {\n-                throw new WebServiceException(\"More than \" + MAX_ID_SIZE + \" IDs are provided\");\n-            }\n-            return ids;\n-        } else {\n-            throw new WebServiceException(\"ID is null or Empty\");\n-        }\n-    }\n-\n-    protected static List<String> checkUniqueList(String ids) throws WebServiceException {\n-        if (StringUtils.isNotEmpty(ids)) {\n-            List<String> idsList = Arrays.asList(ids.split(\",\"));\n-            return checkUniqueList(idsList, \"\");\n-        } else {\n-            throw new WebServiceException(\"ID is null or Empty\");\n-        }\n-    }\n-\n-    protected static List<String> checkUniqueList(List<String> ids, String field) throws WebServiceException {\n-        if (ListUtils.isNotEmpty(ids)) {\n-            Set<String> hashSet = new HashSet<>(ids);\n-            if (hashSet.size() == ids.size()) {\n-                return ids;\n-            } else {\n-                throw new WebServiceException(\"Provided \" + field + \" IDs are not unique. Only unique IDs are accepted.\");\n-            }\n-        }\n-        return null;\n-    }\n-\n-    protected void areSingleIds(String... ids) throws CatalogParameterException {\n-        for (String id : ids) {\n-            ParamUtils.checkIsSingleID(id);\n-        }\n-    }\n-\n-    public Response run(Callable<DataResult<?>> c) {\n-        try {\n-            return createOkResponse(c.call());\n-        } catch (Exception e) {\n-            return createErrorResponse(e);\n-        }\n-    }\n-\n-    public Response submitJob(String toolId, String project, String study, Map<String, Object> paramsMap,\n-                               String jobName, String jobDescription, String jobDependsOne, String jobTags) {\n-        return run(() -> submitJobRaw(toolId, project, study, paramsMap, jobName, jobDescription, jobDependsOne, jobTags));\n-    }\n-\n-    public Response submitJob(String toolId, String study, ToolParams bodyParams, String jobId, String jobDescription,\n-                              String jobDependsOnStr, String jobTagsStr) {\n-        return submitJob(toolId, null, study, bodyParams, jobId, jobDescription, jobDependsOnStr, jobTagsStr);\n-    }\n-\n-    public Response submitJob(String toolId, String project, String study, ToolParams bodyParams, String jobId, String jobDescription,\n-                              String jobDependsOnStr, String jobTagsStr) {\n-        return run(() -> {\n-            Map<String, Object> paramsMap = bodyParams.toParams();\n-            if (StringUtils.isNotEmpty(study)) {\n-                paramsMap.putIfAbsent(ParamConstants.STUDY_PARAM, study);\n-            }\n-            return submitJobRaw(toolId, project, study, paramsMap, jobId, jobDescription, jobDependsOnStr, jobTagsStr);\n-        });\n-    }\n-\n-    protected DataResult<?> submitJobRaw(String toolId, String project, String study, Map<String, Object> paramsMap,\n-                                         String jobId, String jobDescription, String jobDependsOnStr, String jobTagsStr)\n-            throws CatalogException {\n-\n-        if (StringUtils.isNotEmpty(project) && StringUtils.isEmpty(study)) {\n-            // Project job\n-            QueryOptions options = new QueryOptions(QueryOptions.INCLUDE, StudyDBAdaptor.QueryParams.FQN.key());\n-            // Peek any study. The ExecutionDaemon will take care of filling up the rest of studies.\n-            List<String> studies = catalogManager.getStudyManager()\n-                    .get(project, new Query(), options, token)\n-                    .getResults()\n-                    .stream()\n-                    .map(Study::getFqn)\n-                    .collect(Collectors.toList());\n-            if (studies.isEmpty()) {\n-                throw new CatalogException(\"Project '\" + project + \"' not found!\");\n-            }\n-            study = studies.get(0);\n-        }\n-\n-        List<String> jobTags;\n-        if (StringUtils.isNotEmpty(jobTagsStr)) {\n-            jobTags = Arrays.asList(jobTagsStr.split(\",\"));\n-        } else {\n-            jobTags = Collections.emptyList();\n-        }\n-        List<String> jobDependsOn;\n-        if (StringUtils.isNotEmpty(jobDependsOnStr)) {\n-            jobDependsOn = Arrays.asList(jobDependsOnStr.split(\",\"));\n-        } else {\n-            jobDependsOn = Collections.emptyList();\n-        }\n-        return catalogManager.getJobManager()\n-                .submit(study, toolId, Enums.Priority.MEDIUM, paramsMap, jobId, jobDescription, jobDependsOn, jobTags, token);\n-    }\n-\n-    public Response createPendingResponse() {\n-        return createErrorResponse(new NotImplementedException(\"Pending \" + uriInfo.getPath()));\n-    }\n-\n-    public Response createDeprecatedRemovedResponse() {\n-        return createErrorResponse(new NotImplementedException(\"Deprecated \" + uriInfo.getPath()));\n-    }\n-\n-    public Response createDeprecatedMovedResponse(String newEndpoint) {\n-        return createErrorResponse(new NotImplementedException(\"Deprecated \" + uriInfo.getPath() + \" . Use instead \" + newEndpoint));\n-    }\n+          }\n+        }\n+      }\n+      sb.append(\", \").append(requestDescription);\n+      logger.info(sb.toString());\n+    } catch (RuntimeException e) {\n+      logger.warn(\"Error logging response\", e);\n+      logger.info(sb.toString()); // Print incomplete response\n+    }\n+  }\n+\n+  protected Response createJsonResponse(RestResponse queryResponse) {\n+    try {\n+      return buildResponse(Response.ok(jsonObjectWriter.writeValueAsString(queryResponse), MediaType.APPLICATION_JSON_TYPE));\n+    } catch (JsonProcessingException e) {\n+      e.printStackTrace();\n+      logger.error(\"Error parsing queryResponse object\");\n+      return createErrorResponse(\"\", \"Error parsing RestResponse object:\\n\" + Arrays.toString(e.getStackTrace()));\n+    }\n+  }\n+\n+  protected Response buildResponse(Response.ResponseBuilder responseBuilder) {\n+    return responseBuilder\n+        .header(\"Access-Control-Allow-Origin\", \"*\")\n+        .header(\"Access-Control-Allow-Headers\", \"x-requested-with, content-type, authorization\")\n+        .header(\"Access-Control-Allow-Credentials\", \"true\")\n+        .header(\"Access-Control-Allow-Methods\", \"GET, POST, OPTIONS\")\n+        .build();\n+  }\n+\n+  private void verifyHeaders(HttpHeaders httpHeaders) throws CatalogAuthenticationException {\n+    List<String> authorization = httpHeaders.getRequestHeader(\"Authorization\");\n+    if (authorization != null && authorization.get(0).length() > 7) {\n+      String token = authorization.get(0);\n+      if (!token.startsWith(\"Bearer \")) {\n+        throw new CatalogAuthenticationException(\"Authorization header must start with Bearer JWToken\");\n+      }\n+      this.token = token.substring(\"Bearer\".length()).trim();\n+    }\n+\n+    if (StringUtils.isEmpty(this.token)) {\n+      this.token = this.params.getString(\"sid\");\n+    }\n+  }\n+\n+  protected List<String> getIdListOrEmpty(String id) throws WebServiceException {\n+    return id == null ? Collections.emptyList() : getIdList(id, true);\n+  }\n+\n+  protected List<String> getIdList(String id) throws WebServiceException {\n+    return getIdList(id, true);\n+  }\n+\n+  protected List<String> getIdList(String id, boolean checkMaxNumberElements) throws WebServiceException {\n+    if (StringUtils.isNotEmpty(id)) {\n+      List<String> ids = checkUniqueList(id);\n+      if (checkMaxNumberElements && ids.size() > MAX_ID_SIZE) {\n+        throw new WebServiceException(\"More than \" + MAX_ID_SIZE + \" IDs are provided\");\n+      }\n+      return ids;\n+    } else {\n+      throw new WebServiceException(\"ID is null or Empty\");\n+    }\n+  }\n+\n+  protected static List<String> checkUniqueList(String ids) throws WebServiceException {\n+    if (StringUtils.isNotEmpty(ids)) {\n+      List<String> idsList = Arrays.asList(ids.split(\",\"));\n+      return checkUniqueList(idsList, \"\");\n+    } else {\n+      throw new WebServiceException(\"ID is null or Empty\");\n+    }\n+  }\n+\n+  protected static List<String> checkUniqueList(List<String> ids, String field) throws WebServiceException {\n+    if (ListUtils.isNotEmpty(ids)) {\n+      Set<String> hashSet = new HashSet<>(ids);\n+      if (hashSet.size() == ids.size()) {\n+        return ids;\n+      } else {\n+        throw new WebServiceException(\"Provided \" + field + \" IDs are not unique. Only unique IDs are accepted.\");\n+      }\n+    }\n+    return null;\n+  }\n+\n+  protected void areSingleIds(String... ids) throws CatalogParameterException {\n+    for (String id : ids) {\n+      ParamUtils.checkIsSingleID(id);\n+    }\n+  }\n+\n+  public Response run(Callable<DataResult<?>> c) {\n+    try {\n+      return createOkResponse(c.call());\n+    } catch (Exception e) {\n+      return createErrorResponse(e);\n+    }\n+  }\n+\n+  public Response submitJob(String toolId, String project, String study, Map<String, Object> paramsMap,\n+                            String jobName, String jobDescription, String jobDependsOne, String jobTags) {\n+    return run(() -> submitJobRaw(toolId, project, study, paramsMap, jobName, jobDescription, jobDependsOne, jobTags));\n+  }\n+\n+  public Response submitJob(String toolId, String study, ToolParams bodyParams, String jobId, String jobDescription,\n+                            String jobDependsOnStr, String jobTagsStr) {\n+    return submitJob(toolId, null, study, bodyParams, jobId, jobDescription, jobDependsOnStr, jobTagsStr);\n+  }\n+\n+  public Response submitJob(String toolId, String project, String study, ToolParams bodyParams, String jobId, String jobDescription,\n+                            String jobDependsOnStr, String jobTagsStr) {\n+    return run(() -> {\n+      Map<String, Object> paramsMap = bodyParams.toParams();\n+      if (StringUtils.isNotEmpty(study)) {\n+        paramsMap.putIfAbsent(ParamConstants.STUDY_PARAM, study);\n+      }\n+      return submitJobRaw(toolId, project, study, paramsMap, jobId, jobDescription, jobDependsOnStr, jobTagsStr);\n+    });\n+  }\n+\n+  protected DataResult<?> submitJobRaw(String toolId, String project, String study, Map<String, Object> paramsMap,\n+                                       String jobId, String jobDescription, String jobDependsOnStr, String jobTagsStr)\n+      throws CatalogException {\n+\n+    if (StringUtils.isNotEmpty(project) && StringUtils.isEmpty(study)) {\n+      // Project job\n+      QueryOptions options = new QueryOptions(QueryOptions.INCLUDE, StudyDBAdaptor.QueryParams.FQN.key());\n+      // Peek any study. The ExecutionDaemon will take care of filling up the rest of studies.\n+      List<String> studies = catalogManager.getStudyManager()\n+          .get(project, new Query(), options, token)\n+          .getResults()\n+          .stream()\n+          .map(Study::getFqn)\n+          .collect(Collectors.toList());\n+      if (studies.isEmpty()) {\n+        throw new CatalogException(\"Project '\" + project + \"' not found!\");\n+      }\n+      study = studies.get(0);\n+    }\n+\n+    List<String> jobTags;\n+    if (StringUtils.isNotEmpty(jobTagsStr)) {\n+      jobTags = Arrays.asList(jobTagsStr.split(\",\"));\n+    } else {\n+      jobTags = Collections.emptyList();\n+    }\n+    List<String> jobDependsOn;\n+    if (StringUtils.isNotEmpty(jobDependsOnStr)) {\n+      jobDependsOn = Arrays.asList(jobDependsOnStr.split(\",\"));\n+    } else {\n+      jobDependsOn = Collections.emptyList();\n+    }\n+    return catalogManager.getJobManager()\n+        .submit(study, toolId, Enums.Priority.MEDIUM, paramsMap, jobId, jobDescription, jobDependsOn, jobTags, token);\n+  }\n+\n+  public Response createPendingResponse() {\n+    return createErrorResponse(new NotImplementedException(\"Pending \" + uriInfo.getPath()));\n+  }\n+\n+  public Response createDeprecatedRemovedResponse() {\n+    return createErrorResponse(new NotImplementedException(\"Deprecated \" + uriInfo.getPath()));\n+  }\n+\n+  public Response createDeprecatedMovedResponse(String newEndpoint) {\n+    return createErrorResponse(new NotImplementedException(\"Deprecated \" + uriInfo.getPath() + \" . Use instead \" + newEndpoint));\n+  }\n \n }\n",
            "diff_size": 760
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "187",
                    "severity": "error",
                    "message": "Line is longer than 140 characters (found 141).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "187",
                    "severity": "error",
                    "message": "Line is longer than 140 characters (found 141).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ],
    "repaired_by": [],
    "not_repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}