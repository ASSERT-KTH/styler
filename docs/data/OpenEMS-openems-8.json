{
    "project_name": "OpenEMS-openems",
    "error_id": "8",
    "information": {
        "errors": [
            {
                "line": "143",
                "column": "86",
                "severity": "warning",
                "message": "'+' should be on a new line.",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.OperatorWrapCheck"
            }
        ]
    },
    "source_code": "\t\t\t\t}\n\t\t\t\tcase ComponentConfigurationDTO.UNSATISFIED_REFERENCE: {\n\t\t\t\t\tdefectDetails = \"Unsatisfied reference for \" + //\n\t\t\t\t\t\t\tStream.of(configuration.unsatisfiedReferences) //\n\t\t\t\t\t\t\t\t\t.map(ref -> {\n\t\t\t\t\t\t\t\t\t\tString result = ref.name;",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "143",
                    "column": "86",
                    "severity": "warning",
                    "message": "'+' should be on a new line.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.OperatorWrapCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "143",
                    "column": "58",
                    "severity": "warning",
                    "message": "'+' should be on a new line.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.OperatorWrapCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/OpenEMS-openems/errored/1/8/OsgiValidateWorker.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/OpenEMS-openems/intellij/8/OsgiValidateWorker.java\nindex 458ba15e2fa..fa0348b13af 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/OpenEMS-openems/errored/1/8/OsgiValidateWorker.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/OpenEMS-openems/intellij/8/OsgiValidateWorker.java\n@@ -25,310 +25,310 @@ import io.openems.edge.common.component.OpenemsComponent;\n \n /**\n  * This Worker constantly validates:.\n- * \n+ *\n  * <ul>\n  * <li>that all configured OpenEMS-Components are actually activated. Otherwise\n  * it sets the {@link ComponentManager.ChannelId#CONFIG_NOT_ACTIVATED} channel.\n  * <li>that there is no duplicated Component-ID in the system. Otherwise it sets\n  * the {@link ComponentManager.ChannelId#DUPLICATED_COMPONENT_ID} channel.\n  * </ul>\n- * \n+ *\n  * <p>\n  * Next to the Warning/Fault channels details are also printed to console on\n  * debugLog.\n  */\n public class OsgiValidateWorker extends ComponentManagerWorker {\n \n-\t/*\n-\t * For INITIAL_CYCLES cycles the distance between two checks is\n-\t * INITIAL_CYCLE_TIME, afterwards the check runs every REGULAR_CYCLE_TIME\n-\t * milliseconds.\n-\t * \n-\t * Why? In the beginning it takes a while till all components are up and\n-\t * running. So it is likely, that in the beginning not all are immediately\n-\t * running.\n-\t */\n-\tprivate static final int INITIAL_CYCLES = 60;\n-\tprivate static final int INITIAL_CYCLE_TIME = 5_000; // in ms\n-\tprivate static final int REGULAR_CYCLE_TIME = 60_000; // in ms\n+  /*\n+   * For INITIAL_CYCLES cycles the distance between two checks is\n+   * INITIAL_CYCLE_TIME, afterwards the check runs every REGULAR_CYCLE_TIME\n+   * milliseconds.\n+   *\n+   * Why? In the beginning it takes a while till all components are up and\n+   * running. So it is likely, that in the beginning not all are immediately\n+   * running.\n+   */\n+  private static final int INITIAL_CYCLES = 60;\n+  private static final int INITIAL_CYCLE_TIME = 5_000; // in ms\n+  private static final int REGULAR_CYCLE_TIME = 60_000; // in ms\n \n-\tprivate final Logger log = LoggerFactory.getLogger(OsgiValidateWorker.class);\n+  private final Logger log = LoggerFactory.getLogger(OsgiValidateWorker.class);\n \n-\t/**\n-\t * Map from Component-ID to defect details.\n-\t */\n-\tprivate final Map<String, String> defectiveComponents = new HashMap<>();\n+  /**\n+   * Map from Component-ID to defect details.\n+   */\n+  private final Map<String, String> defectiveComponents = new HashMap<>();\n \n-\t/**\n-\t * Delays announcement of defective Components by one execution Cycle.\n-\t */\n-\tprivate final Set<String> lastDefectiveComponents = new HashSet<>();\n+  /**\n+   * Delays announcement of defective Components by one execution Cycle.\n+   */\n+  private final Set<String> lastDefectiveComponents = new HashSet<>();\n \n-\t/**\n-\t * Components with duplicated Component-IDs.\n-\t */\n-\tprivate final Set<String> duplicatedComponentIds = new HashSet<String>();\n+  /**\n+   * Components with duplicated Component-IDs.\n+   */\n+  private final Set<String> duplicatedComponentIds = new HashSet<String>();\n \n-\tpublic OsgiValidateWorker(ComponentManagerImpl parent) {\n-\t\tsuper(parent);\n-\t}\n+  public OsgiValidateWorker(ComponentManagerImpl parent) {\n+    super(parent);\n+  }\n \n-\t@Override\n-\tprotected void forever() {\n-\t\tthis.findDuplicatedComponentIds();\n-\t\tthis.findDefectiveComponents();\n-\t}\n+  @Override\n+  protected void forever() {\n+    this.findDuplicatedComponentIds();\n+    this.findDefectiveComponents();\n+  }\n \n-\tprivate void findDuplicatedComponentIds() {\n-\t\tfinal Configuration[] configs = this.readAllConfigurations();\n-\t\tfinal Set<String> duplicatedComponentIds = new HashSet<String>();\n-\t\tupdateDuplicatedComponentIds(duplicatedComponentIds, configs);\n-\t\tthis.parent._setDuplicatedComponentId(!this.duplicatedComponentIds.isEmpty());\n-\t\tsynchronized (this.duplicatedComponentIds) {\n-\t\t\tthis.duplicatedComponentIds.clear();\n-\t\t\tthis.duplicatedComponentIds.addAll(duplicatedComponentIds);\n-\t\t}\n-\t}\n+  private void findDuplicatedComponentIds() {\n+    final Configuration[] configs = this.readAllConfigurations();\n+    final Set<String> duplicatedComponentIds = new HashSet<String>();\n+    updateDuplicatedComponentIds(duplicatedComponentIds, configs);\n+    this.parent._setDuplicatedComponentId(!this.duplicatedComponentIds.isEmpty());\n+    synchronized (this.duplicatedComponentIds) {\n+      this.duplicatedComponentIds.clear();\n+      this.duplicatedComponentIds.addAll(duplicatedComponentIds);\n+    }\n+  }\n \n-\tprivate void findDefectiveComponents() {\n-\t\tfinal Configuration[] configs = this.readEnabledConfigurations();\n-\t\tfinal Map<String, String> defectiveComponents = new HashMap<>();\n-\t\tupdateInactiveComponentsUsingScr(defectiveComponents, this.parent.serviceComponentRuntime);\n-\t\tupdateInactiveComponentsUsingConfigurationAdmin(defectiveComponents, this.parent.getEnabledComponents(),\n-\t\t\t\tconfigs);\n-\t\tthis.parent._setConfigNotActivated(!defectiveComponents.isEmpty());\n-\t\tsynchronized (this.defectiveComponents) {\n-\t\t\tthis.defectiveComponents.clear();\n-\t\t\tfor (Entry<String, String> c : defectiveComponents.entrySet()) {\n-\t\t\t\tif (this.lastDefectiveComponents.contains(c.getKey())) {\n-\t\t\t\t\t// Delay announcement of defective Components by one execution Cycle.\n-\t\t\t\t\tthis.defectiveComponents.put(c.getKey(), c.getValue());\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tthis.lastDefectiveComponents.addAll(defectiveComponents.keySet());\n-\t\t}\n-\t}\n+  private void findDefectiveComponents() {\n+    final Configuration[] configs = this.readEnabledConfigurations();\n+    final Map<String, String> defectiveComponents = new HashMap<>();\n+    updateInactiveComponentsUsingScr(defectiveComponents, this.parent.serviceComponentRuntime);\n+    updateInactiveComponentsUsingConfigurationAdmin(defectiveComponents, this.parent.getEnabledComponents(),\n+        configs);\n+    this.parent._setConfigNotActivated(!defectiveComponents.isEmpty());\n+    synchronized (this.defectiveComponents) {\n+      this.defectiveComponents.clear();\n+      for (Entry<String, String> c : defectiveComponents.entrySet()) {\n+        if (this.lastDefectiveComponents.contains(c.getKey())) {\n+          // Delay announcement of defective Components by one execution Cycle.\n+          this.defectiveComponents.put(c.getKey(), c.getValue());\n+        }\n+      }\n+      this.lastDefectiveComponents.addAll(defectiveComponents.keySet());\n+    }\n+  }\n \n-\t/**\n-\t * Updates the inactive Components.\n-\t * \n-\t * <p>\n-\t * This method uses {@link ServiceComponentRuntime} to get details about why the\n-\t * Component is inactive.\n-\t * \n-\t * @param defectiveComponents the map to be updated\n-\t * @param scr                 the {@link ServiceComponentRuntime}\n-\t */\n-\tprivate static void updateInactiveComponentsUsingScr(Map<String, String> defectiveComponents,\n-\t\t\tServiceComponentRuntime scr) {\n-\t\tCollection<ComponentDescriptionDTO> descriptions = scr.getComponentDescriptionDTOs();\n-\t\tfor (ComponentDescriptionDTO description : descriptions) {\n-\t\t\tCollection<ComponentConfigurationDTO> configurations = scr.getComponentConfigurationDTOs(description);\n-\t\t\tfor (ComponentConfigurationDTO configuration : configurations) {\n-\t\t\t\tif (!MapUtils.getAsOptionalBoolean(configuration.properties, \"enabled\").orElse(true)) {\n-\t\t\t\t\t// Component is not enabled -> ignore\n-\t\t\t\t\tcontinue;\n-\t\t\t\t}\n+  /**\n+   * Updates the inactive Components.\n+   *\n+   * <p>\n+   * This method uses {@link ServiceComponentRuntime} to get details about why the\n+   * Component is inactive.\n+   *\n+   * @param defectiveComponents the map to be updated\n+   * @param scr                 the {@link ServiceComponentRuntime}\n+   */\n+  private static void updateInactiveComponentsUsingScr(Map<String, String> defectiveComponents,\n+                                                       ServiceComponentRuntime scr) {\n+    Collection<ComponentDescriptionDTO> descriptions = scr.getComponentDescriptionDTOs();\n+    for (ComponentDescriptionDTO description : descriptions) {\n+      Collection<ComponentConfigurationDTO> configurations = scr.getComponentConfigurationDTOs(description);\n+      for (ComponentConfigurationDTO configuration : configurations) {\n+        if (!MapUtils.getAsOptionalBoolean(configuration.properties, \"enabled\").orElse(true)) {\n+          // Component is not enabled -> ignore\n+          continue;\n+        }\n \n-\t\t\t\tfinal String defectDetails;\n-\t\t\t\tswitch (configuration.state) {\n-\t\t\t\tcase ComponentConfigurationDTO.ACTIVE:\n-\t\t\t\tcase ComponentConfigurationDTO.SATISFIED:\n-\t\t\t\t\tcontinue;\n-\t\t\t\tcase ComponentConfigurationDTO.UNSATISFIED_CONFIGURATION: {\n-\t\t\t\t\tdefectDetails = \"Missing required configuration\";\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t\tcase ComponentConfigurationDTO.UNSATISFIED_REFERENCE: {\n-\t\t\t\t\tdefectDetails = \"Unsatisfied reference for \" + //\n-\t\t\t\t\t\t\tStream.of(configuration.unsatisfiedReferences) //\n-\t\t\t\t\t\t\t\t\t.map(ref -> {\n-\t\t\t\t\t\t\t\t\t\tString result = ref.name;\n-\t\t\t\t\t\t\t\t\t\tif (ref.target != null && !ref.target.isEmpty()) {\n-\t\t\t\t\t\t\t\t\t\t\tresult += \" (\" + ref.target + \")\";\n-\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t\treturn result;\n-\t\t\t\t\t\t\t\t\t}) //\n-\t\t\t\t\t\t\t\t\t.collect(Collectors.joining(\",\")); //\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t\tcase ComponentConfigurationDTO.FAILED_ACTIVATION: {\n-\t\t\t\t\tdefectDetails = \"Failed activation \" + configuration.failure.split(System.lineSeparator(), 2)[0];\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t\tdefault:\n-\t\t\t\t\tdefectDetails = \"Undefined failure [\" + configuration.state + \"];\";\n-\t\t\t\t}\n-\t\t\t\tString componentId = (String) configuration.properties.get(\"id\");\n-\t\t\t\tdefectiveComponents.put(componentId, defectDetails);\n-\t\t\t}\n-\t\t}\n-\t}\n+        final String defectDetails;\n+        switch (configuration.state) {\n+          case ComponentConfigurationDTO.ACTIVE:\n+          case ComponentConfigurationDTO.SATISFIED:\n+            continue;\n+          case ComponentConfigurationDTO.UNSATISFIED_CONFIGURATION: {\n+            defectDetails = \"Missing required configuration\";\n+            break;\n+          }\n+          case ComponentConfigurationDTO.UNSATISFIED_REFERENCE: {\n+            defectDetails = \"Unsatisfied reference for \" + //\n+                Stream.of(configuration.unsatisfiedReferences) //\n+                    .map(ref -> {\n+                      String result = ref.name;\n+                      if (ref.target != null && !ref.target.isEmpty()) {\n+                        result += \" (\" + ref.target + \")\";\n+                      }\n+                      return result;\n+                    }) //\n+                    .collect(Collectors.joining(\",\")); //\n+            break;\n+          }\n+          case ComponentConfigurationDTO.FAILED_ACTIVATION: {\n+            defectDetails = \"Failed activation \" + configuration.failure.split(System.lineSeparator(), 2)[0];\n+            break;\n+          }\n+          default:\n+            defectDetails = \"Undefined failure [\" + configuration.state + \"];\";\n+        }\n+        String componentId = (String) configuration.properties.get(\"id\");\n+        defectiveComponents.put(componentId, defectDetails);\n+      }\n+    }\n+  }\n \n-\t/*\n-\t * Compare all Configuration Admin Configurations with actually existing and\n-\t * active OpenEMS Components.\n-\t * \n-\t * @param configs enabled {@link Configuration}s from {@link ConfigurationAdmin}\n-\t */\n-\tprivate static void updateInactiveComponentsUsingConfigurationAdmin(Map<String, String> defectiveComponents,\n-\t\t\tList<OpenemsComponent> enabledComponents, Configuration[] configs) {\n-\t\tfor (Configuration config : configs) {\n-\t\t\tDictionary<String, Object> properties;\n-\t\t\ttry {\n-\t\t\t\tproperties = config.getProperties();\n-\t\t\t\tif (properties == null) {\n-\t\t\t\t\t// configuration was just created and update has not been called\n-\t\t\t\t\tcontinue;\n-\t\t\t\t}\n-\t\t\t} catch (IllegalStateException e) {\n-\t\t\t\t// Configuration has been deleted\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\t\t\tString componentId = (String) properties.get(\"id\");\n-\t\t\tif (componentId != null) {\n-\t\t\t\tif (defectiveComponents.containsKey(componentId)) {\n-\t\t\t\t\t// already in the list\n-\t\t\t\t\tcontinue;\n-\t\t\t\t}\n-\t\t\t\tif (!isComponentActivated(enabledComponents, componentId)) {\n-\t\t\t\t\tdefectiveComponents.putIfAbsent(componentId, \"Missing Bundle\");\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n+  /*\n+   * Compare all Configuration Admin Configurations with actually existing and\n+   * active OpenEMS Components.\n+   *\n+   * @param configs enabled {@link Configuration}s from {@link ConfigurationAdmin}\n+   */\n+  private static void updateInactiveComponentsUsingConfigurationAdmin(Map<String, String> defectiveComponents,\n+                                                                      List<OpenemsComponent> enabledComponents, Configuration[] configs) {\n+    for (Configuration config : configs) {\n+      Dictionary<String, Object> properties;\n+      try {\n+        properties = config.getProperties();\n+        if (properties == null) {\n+          // configuration was just created and update has not been called\n+          continue;\n+        }\n+      } catch (IllegalStateException e) {\n+        // Configuration has been deleted\n+        continue;\n+      }\n+      String componentId = (String) properties.get(\"id\");\n+      if (componentId != null) {\n+        if (defectiveComponents.containsKey(componentId)) {\n+          // already in the list\n+          continue;\n+        }\n+        if (!isComponentActivated(enabledComponents, componentId)) {\n+          defectiveComponents.putIfAbsent(componentId, \"Missing Bundle\");\n+        }\n+      }\n+    }\n+  }\n \n-\t/**\n-\t * Read all configurations from ConfigurationAdmin - no matter if enabled or\n-\t * not.\n-\t * \n-\t * @return {@link Configuration}s from {@link ConfigurationAdmin}; empty array\n-\t *         on error\n-\t */\n-\tprivate Configuration[] readAllConfigurations() {\n-\t\ttry {\n-\t\t\tConfigurationAdmin cm = this.parent.cm;\n-\t\t\tConfiguration[] configs = cm.listConfigurations(null);\n-\t\t\tif (configs != null) {\n-\t\t\t\treturn configs;\n-\t\t\t} else {\n-\t\t\t\treturn new Configuration[0];\n-\t\t\t}\n-\t\t} catch (Exception e) {\n-\t\t\tthis.parent.logError(this.log, e.getMessage());\n-\t\t\te.printStackTrace();\n-\t\t\treturn new Configuration[0];\n-\t\t}\n-\t}\n+  /**\n+   * Read all configurations from ConfigurationAdmin - no matter if enabled or\n+   * not.\n+   *\n+   * @return {@link Configuration}s from {@link ConfigurationAdmin}; empty array\n+   * on error\n+   */\n+  private Configuration[] readAllConfigurations() {\n+    try {\n+      ConfigurationAdmin cm = this.parent.cm;\n+      Configuration[] configs = cm.listConfigurations(null);\n+      if (configs != null) {\n+        return configs;\n+      } else {\n+        return new Configuration[0];\n+      }\n+    } catch (Exception e) {\n+      this.parent.logError(this.log, e.getMessage());\n+      e.printStackTrace();\n+      return new Configuration[0];\n+    }\n+  }\n \n-\t/**\n-\t * Read all enabled configurations from ConfigurationAdmin.\n-\t * \n-\t * @return enabled {@link Configuration}s from {@link ConfigurationAdmin}; empty\n-\t *         array on error\n-\t */\n-\tprivate Configuration[] readEnabledConfigurations() {\n-\t\ttry {\n-\t\t\tConfigurationAdmin cm = this.parent.cm;\n-\t\t\tConfiguration[] configs = cm.listConfigurations(\"(enabled=true)\");\n-\t\t\tif (configs != null) {\n-\t\t\t\treturn configs;\n-\t\t\t} else {\n-\t\t\t\treturn new Configuration[0];\n-\t\t\t}\n-\t\t} catch (Exception e) {\n-\t\t\tthis.parent.logError(this.log, e.getMessage());\n-\t\t\te.printStackTrace();\n-\t\t\treturn new Configuration[0];\n-\t\t}\n-\t}\n+  /**\n+   * Read all enabled configurations from ConfigurationAdmin.\n+   *\n+   * @return enabled {@link Configuration}s from {@link ConfigurationAdmin}; empty\n+   * array on error\n+   */\n+  private Configuration[] readEnabledConfigurations() {\n+    try {\n+      ConfigurationAdmin cm = this.parent.cm;\n+      Configuration[] configs = cm.listConfigurations(\"(enabled=true)\");\n+      if (configs != null) {\n+        return configs;\n+      } else {\n+        return new Configuration[0];\n+      }\n+    } catch (Exception e) {\n+      this.parent.logError(this.log, e.getMessage());\n+      e.printStackTrace();\n+      return new Configuration[0];\n+    }\n+  }\n \n-\tprivate static boolean isComponentActivated(List<OpenemsComponent> enabledComponents, String componentId) {\n-\t\tfor (OpenemsComponent component : enabledComponents) {\n-\t\t\tif (componentId.equals(component.id())) {\n-\t\t\t\t// Everything Ok\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t}\n-\t\treturn false;\n-\t}\n+  private static boolean isComponentActivated(List<OpenemsComponent> enabledComponents, String componentId) {\n+    for (OpenemsComponent component : enabledComponents) {\n+      if (componentId.equals(component.id())) {\n+        // Everything Ok\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n \n-\t/**\n-\t * Checks for duplicated Component-IDs.\n-\t * \n-\t * @param duplicatedComponentIds the Set of Component-IDs to be updated\n-\t * @param configs                enabled {@link Configuration}s from\n-\t *                               {@link ConfigurationAdmin}\n-\t */\n-\tprivate static void updateDuplicatedComponentIds(Set<String> duplicatedComponentIds, Configuration[] configs) {\n-\t\tSet<String> componentIds = new HashSet<>();\n-\t\tfor (Configuration config : configs) {\n-\t\t\tDictionary<String, Object> properties = config.getProperties();\n-\t\t\tif (properties == null) {\n-\t\t\t\tSystem.err.println(config.getPid() + \": Properties is 'null'\");\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\t\t\tString componentId = (String) properties.get(\"id\");\n-\t\t\tif (componentId != null) {\n-\t\t\t\tif (componentIds.contains(componentId)) {\n-\t\t\t\t\tduplicatedComponentIds.add(componentId);\n-\t\t\t\t} else {\n-\t\t\t\t\tcomponentIds.add(componentId);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n+  /**\n+   * Checks for duplicated Component-IDs.\n+   *\n+   * @param duplicatedComponentIds the Set of Component-IDs to be updated\n+   * @param configs                enabled {@link Configuration}s from\n+   *                               {@link ConfigurationAdmin}\n+   */\n+  private static void updateDuplicatedComponentIds(Set<String> duplicatedComponentIds, Configuration[] configs) {\n+    Set<String> componentIds = new HashSet<>();\n+    for (Configuration config : configs) {\n+      Dictionary<String, Object> properties = config.getProperties();\n+      if (properties == null) {\n+        System.err.println(config.getPid() + \": Properties is 'null'\");\n+        continue;\n+      }\n+      String componentId = (String) properties.get(\"id\");\n+      if (componentId != null) {\n+        if (componentIds.contains(componentId)) {\n+          duplicatedComponentIds.add(componentId);\n+        } else {\n+          componentIds.add(componentId);\n+        }\n+      }\n+    }\n+  }\n \n-\tprivate int cycleCountDown = OsgiValidateWorker.INITIAL_CYCLES;\n+  private int cycleCountDown = OsgiValidateWorker.INITIAL_CYCLES;\n \n-\t@Override\n-\tprotected int getCycleTime() {\n-\t\tif (this.cycleCountDown > 0) {\n-\t\t\tthis.cycleCountDown--;\n-\t\t\treturn OsgiValidateWorker.INITIAL_CYCLE_TIME;\n-\t\t} else {\n-\t\t\treturn OsgiValidateWorker.REGULAR_CYCLE_TIME;\n-\t\t}\n-\t}\n+  @Override\n+  protected int getCycleTime() {\n+    if (this.cycleCountDown > 0) {\n+      this.cycleCountDown--;\n+      return OsgiValidateWorker.INITIAL_CYCLE_TIME;\n+    } else {\n+      return OsgiValidateWorker.REGULAR_CYCLE_TIME;\n+    }\n+  }\n \n-\t@Override\n-\tpublic void configurationEvent(ConfigurationEvent event) {\n-\t\t// trigger immediate validation on configuration event\n-\t\tthis.triggerNextRun();\n-\t}\n+  @Override\n+  public void configurationEvent(ConfigurationEvent event) {\n+    // trigger immediate validation on configuration event\n+    this.triggerNextRun();\n+  }\n \n-\t@Override\n-\tpublic void triggerNextRun() {\n-\t\t// Reset Cycle-Counter on explicit run\n-\t\tthis.cycleCountDown = OsgiValidateWorker.INITIAL_CYCLES;\n-\t\tsuper.triggerNextRun();\n-\t}\n+  @Override\n+  public void triggerNextRun() {\n+    // Reset Cycle-Counter on explicit run\n+    this.cycleCountDown = OsgiValidateWorker.INITIAL_CYCLES;\n+    super.triggerNextRun();\n+  }\n \n-\t@Override\n-\tpublic String debugLog() {\n-\t\tString defectiveComponents = \"\";\n-\t\tsynchronized (this.defectiveComponents) {\n-\t\t\tdefectiveComponents = this.defectiveComponents.entrySet().stream() //\n-\t\t\t\t\t.map(e -> e.getKey() + \"[\" + e.getValue() + \"]\") //\n-\t\t\t\t\t.collect(Collectors.joining(\" \"));\n-\t\t}\n-\t\tString duplicatedComponents = \"\";\n-\t\tsynchronized (this.duplicatedComponentIds) {\n-\t\t\tduplicatedComponents = String.join(\",\", this.duplicatedComponentIds);\n-\t\t}\n+  @Override\n+  public String debugLog() {\n+    String defectiveComponents = \"\";\n+    synchronized (this.defectiveComponents) {\n+      defectiveComponents = this.defectiveComponents.entrySet().stream() //\n+          .map(e -> e.getKey() + \"[\" + e.getValue() + \"]\") //\n+          .collect(Collectors.joining(\" \"));\n+    }\n+    String duplicatedComponents = \"\";\n+    synchronized (this.duplicatedComponentIds) {\n+      duplicatedComponents = String.join(\",\", this.duplicatedComponentIds);\n+    }\n \n-\t\tif (defectiveComponents.isEmpty() && duplicatedComponents.isEmpty()) {\n-\t\t\treturn null;\n+    if (defectiveComponents.isEmpty() && duplicatedComponents.isEmpty()) {\n+      return null;\n \n-\t\t} else if (defectiveComponents.isEmpty()) {\n-\t\t\treturn \"Duplicated:\" + duplicatedComponents;\n+    } else if (defectiveComponents.isEmpty()) {\n+      return \"Duplicated:\" + duplicatedComponents;\n \n-\t\t} else if (duplicatedComponents.isEmpty()) {\n-\t\t\treturn \"Defective:\" + defectiveComponents;\n+    } else if (duplicatedComponents.isEmpty()) {\n+      return \"Defective:\" + defectiveComponents;\n \n-\t\t} else {\n-\t\t\treturn \"Duplicated:\" + duplicatedComponents + \"|\" + \"Defective:\" + defectiveComponents;\n-\t\t}\n-\t}\n+    } else {\n+      return \"Duplicated:\" + duplicatedComponents + \"|\" + \"Defective:\" + defectiveComponents;\n+    }\n+  }\n \n }\n",
            "diff_size": 269
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "143",
                    "column": "86",
                    "severity": "warning",
                    "message": "'+' should be on a new line.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.OperatorWrapCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "143",
                    "column": "86",
                    "severity": "warning",
                    "message": "'+' should be on a new line.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.OperatorWrapCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ],
    "repaired_by": [],
    "not_repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}