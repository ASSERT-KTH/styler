{
    "project_name": "intuit-Tank",
    "error_id": "164",
    "information": {
        "errors": [
            {
                "line": "30",
                "column": "1",
                "severity": "warning",
                "message": "File contains tab characters (this is the first instance).",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
            }
        ]
    },
    "source_code": "\n\n\t/**\n\t * Adds a null token to the end of the current linked list of tokens.\n\t * This should be put at the end of the linked list whenever the last\n\t * token on the current line is NOT a multi-line token.",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "30",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/intuit-Tank/errored/1/164/TokenMaker.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/intuit-Tank/styler/164/TokenMaker.java\nindex 580db9f5a51..b6d6ac5273f 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/intuit-Tank/errored/1/164/TokenMaker.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/intuit-Tank/styler/164/TokenMaker.java\n@@ -26,13 +26,12 @@ import javax.swing.text.Segment;\n  */\n public interface TokenMaker {\n \n-\n-\t/**\n+    /**\n \t * Adds a null token to the end of the current linked list of tokens.\n \t * This should be put at the end of the linked list whenever the last\n \t * token on the current line is NOT a multi-line token.\n \t */\n-\tvoid addNullToken();\n+        void addNullToken();\n \n \n \t/**\n",
            "diff_size": 3
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/intuit-Tank/errored/1/164/TokenMaker.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/intuit-Tank/intellij/164/TokenMaker.java\nindex 580db9f5a51..a6a924ba191 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/intuit-Tank/errored/1/164/TokenMaker.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/intuit-Tank/intellij/164/TokenMaker.java\n@@ -7,6 +7,7 @@\n  * This library is distributed under a modified BSD license.  See the included\n  * LICENSE file for details.\n  */\n+\n package org.fife.ui.rsyntaxtextarea;\n \n import javax.swing.Action;\n@@ -18,173 +19,172 @@ import javax.swing.text.Segment;\n  * a linked list of <code>Token</code>s for syntax highlighting\n  * in a particular language.\n  *\n- * @see Token\n- * @see AbstractTokenMaker\n- *\n  * @author Robert Futrell\n  * @version 0.2\n+ * @see Token\n+ * @see AbstractTokenMaker\n  */\n public interface TokenMaker {\n \n \n-\t/**\n-\t * Adds a null token to the end of the current linked list of tokens.\n-\t * This should be put at the end of the linked list whenever the last\n-\t * token on the current line is NOT a multi-line token.\n-\t */\n-\tvoid addNullToken();\n-\n-\n-\t/**\n-\t * Adds the token specified to the current linked list of tokens.\n-\t *\n-\t * @param array The character array from which to get the text.\n-\t * @param start Start offset in <code>segment</code> of token.\n-\t * @param end End offset in <code>segment</code> of token.\n-\t * @param tokenType The token's type.\n-\t * @param startOffset The offset in the document at which this token\n-\t *        occurs.\n-\t */\n-\tvoid addToken(char[] array, int start, int end, int tokenType,\n-\t\t\t\t  int startOffset);\n-\n-\n-\t/**\n-\t * Returns the closest {@link TokenTypes \"standard\" token type} for a given\n-\t * \"internal\" token type (e.g. one whose value is <code>&lt; 0</code>).\n-\t *\n-\t * @param type The token type.\n-\t * @return The closest \"standard\" token type.  If a mapping is not defined\n-\t *         for this language, then <code>type</code> is returned.\n-\t */\n-\tint getClosestStandardTokenTypeForInternalType(int type);\n-\n-\n-\t/**\n-\t * Returns whether this programming language uses curly braces\n-\t * ('<code>{</code>' and '<code>}</code>') to denote code blocks.\n-\t *\n-\t * @param languageIndex The language index at the offset in question.\n-\t *        Since some <code>TokenMaker</code>s effectively have nested\n-\t *        languages (such as JavaScript in HTML), this parameter tells the\n-\t *        <code>TokenMaker</code> what sub-language to look at.\n-\t * @return Whether curly braces denote code blocks.\n-\t */\n-\tboolean getCurlyBracesDenoteCodeBlocks(int languageIndex);\n-\n-\n-\t/**\n-\t * Returns the last token on this line's type if the token is \"unfinished\",\n-\t * or {@link Token#NULL} if it was finished.  For example, if C-style\n-\t * syntax highlighting is being implemented, and <code>text</code>\n-\t * contained a line of code that contained the beginning of a comment but\n-\t * no end-comment marker (\"*\\/\"), then this method would return\n-\t * {@link Token#COMMENT_MULTILINE} for that line.  This is useful\n-\t * for doing syntax highlighting.\n-\t *\n-\t * @param text The line of tokens to examine.\n-\t * @param initialTokenType The token type to start with (i.e., the value\n-\t *        of <code>getLastTokenTypeOnLine</code> for the line before\n-\t *        <code>text</code>).\n-\t * @return The last token on this line's type, or {@link Token#NULL}\n-\t *         if the line was completed.\n-\t */\n-\tint getLastTokenTypeOnLine(Segment text, int initialTokenType);\n-\n-\n-\t/**\n-\t * Returns the text to place at the beginning and end of a\n-\t * line to \"comment\" it in this programming language.\n-\t *\n-\t * @param languageIndex The language index at the offset in question.\n-\t *        Since some <code>TokenMaker</code>s effectively have nested\n-\t *        languages (such as JavaScript in HTML), this parameter tells the\n-\t *        <code>TokenMaker</code> what sub-language to look at.\n-\t * @return The start and end strings to add to a line to \"comment\"\n-\t *         it out.  A <code>null</code> value for either means there\n-\t *         is no string to add for that part.  A value of\n-\t *         <code>null</code> for the array means this language\n-\t *         does not support commenting/uncommenting lines.\n-\t */\n-\tString[] getLineCommentStartAndEnd(int languageIndex);\n-\n-\n-\t/**\n-\t * Returns an action to handle \"insert break\" key presses (i.e. Enter).\n-\t *\n-\t * @return The action, or <code>null</code> if the default action should\n-\t *         be used.\n-\t */\n-\tAction getInsertBreakAction();\n-\n-\n-\t/**\n-\t * Returns whether tokens of the specified type should have \"mark\n-\t * occurrences\" enabled for the current programming language.\n-\t *\n-\t * @param type The token type.\n-\t * @return Whether tokens of this type should have \"mark occurrences\"\n-\t *         enabled.\n-\t */\n-\tboolean getMarkOccurrencesOfTokenType(int type);\n-\n-\n-\t/**\n-\t * Returns the object in charge of marking all occurrences of the token\n-\t * at the current caret position, if it is a relevant token.  If\n-\t * <code>null</code> is returned, a default <code>OccurrenceMarker</code>\n-\t * is used.\n-\t *\n-\t * @return The occurrence marker for this language, or <code>null</code>\n-\t *         for none.\n-\t */\n-\tOccurrenceMarker getOccurrenceMarker();\n-\n-\n-\t/**\n-\t * If a line ends in the specified token, this method returns whether\n-\t * a new line inserted after that line should be indented.\n-\t *\n-\t * @param token The token the previous line ends with.\n-\t * @return Whether the next line should be indented.\n-\t */\n-\tboolean getShouldIndentNextLineAfter(Token token);\n-\n-\n-\t/**\n-\t * Returns the first token in the linked list of tokens generated\n-\t * from <code>text</code>.  This method must be implemented by\n-\t * subclasses so they can correctly implement syntax highlighting.\n-\t *\n-\t * @param text The text from which to get tokens.\n-\t * @param initialTokenType The token type we should start with.\n-\t * @param startOffset The offset into the document at which\n-\t *        <code>text</code> starts.\n-\t * @return The first <code>Token</code> in a linked list representing\n-\t *         the syntax highlighted text.\n-\t */\n-\tToken getTokenList(Segment text, int initialTokenType,\n-\t\t\t\t\t   int startOffset);\n-\n-\n-\t/**\n-\t * Returns whether a character could be part of an \"identifier\" token\n-\t * in a specific language.  This is used to identify such things as the\n-\t * bounds of the \"word\" to select on double-clicking.\n-\t *\n-\t * @param languageIndex The language index the character was found in.\n-\t * @param ch The character.\n-\t * @return Whether the character could be part of an \"identifier\" token.\n-\t */\n-\tboolean isIdentifierChar(int languageIndex, char ch);\n-\n-\n-\t/**\n-\t * Returns whether this language is a markup language.\n-\t *\n-\t * @return Whether this language is markup.\n-\t */\n-\tboolean isMarkupLanguage();\n+  /**\n+   * Adds a null token to the end of the current linked list of tokens.\n+   * This should be put at the end of the linked list whenever the last\n+   * token on the current line is NOT a multi-line token.\n+   */\n+  void addNullToken();\n+\n+\n+  /**\n+   * Adds the token specified to the current linked list of tokens.\n+   *\n+   * @param array       The character array from which to get the text.\n+   * @param start       Start offset in <code>segment</code> of token.\n+   * @param end         End offset in <code>segment</code> of token.\n+   * @param tokenType   The token's type.\n+   * @param startOffset The offset in the document at which this token\n+   *                    occurs.\n+   */\n+  void addToken(char[] array, int start, int end, int tokenType,\n+                int startOffset);\n+\n+\n+  /**\n+   * Returns the closest {@link TokenTypes \"standard\" token type} for a given\n+   * \"internal\" token type (e.g. one whose value is <code>&lt; 0</code>).\n+   *\n+   * @param type The token type.\n+   * @return The closest \"standard\" token type.  If a mapping is not defined\n+   * for this language, then <code>type</code> is returned.\n+   */\n+  int getClosestStandardTokenTypeForInternalType(int type);\n+\n+\n+  /**\n+   * Returns whether this programming language uses curly braces\n+   * ('<code>{</code>' and '<code>}</code>') to denote code blocks.\n+   *\n+   * @param languageIndex The language index at the offset in question.\n+   *                      Since some <code>TokenMaker</code>s effectively have nested\n+   *                      languages (such as JavaScript in HTML), this parameter tells the\n+   *                      <code>TokenMaker</code> what sub-language to look at.\n+   * @return Whether curly braces denote code blocks.\n+   */\n+  boolean getCurlyBracesDenoteCodeBlocks(int languageIndex);\n+\n+\n+  /**\n+   * Returns the last token on this line's type if the token is \"unfinished\",\n+   * or {@link Token#NULL} if it was finished.  For example, if C-style\n+   * syntax highlighting is being implemented, and <code>text</code>\n+   * contained a line of code that contained the beginning of a comment but\n+   * no end-comment marker (\"*\\/\"), then this method would return\n+   * {@link Token#COMMENT_MULTILINE} for that line.  This is useful\n+   * for doing syntax highlighting.\n+   *\n+   * @param text             The line of tokens to examine.\n+   * @param initialTokenType The token type to start with (i.e., the value\n+   *                         of <code>getLastTokenTypeOnLine</code> for the line before\n+   *                         <code>text</code>).\n+   * @return The last token on this line's type, or {@link Token#NULL}\n+   * if the line was completed.\n+   */\n+  int getLastTokenTypeOnLine(Segment text, int initialTokenType);\n+\n+\n+  /**\n+   * Returns the text to place at the beginning and end of a\n+   * line to \"comment\" it in this programming language.\n+   *\n+   * @param languageIndex The language index at the offset in question.\n+   *                      Since some <code>TokenMaker</code>s effectively have nested\n+   *                      languages (such as JavaScript in HTML), this parameter tells the\n+   *                      <code>TokenMaker</code> what sub-language to look at.\n+   * @return The start and end strings to add to a line to \"comment\"\n+   * it out.  A <code>null</code> value for either means there\n+   * is no string to add for that part.  A value of\n+   * <code>null</code> for the array means this language\n+   * does not support commenting/uncommenting lines.\n+   */\n+  String[] getLineCommentStartAndEnd(int languageIndex);\n+\n+\n+  /**\n+   * Returns an action to handle \"insert break\" key presses (i.e. Enter).\n+   *\n+   * @return The action, or <code>null</code> if the default action should\n+   * be used.\n+   */\n+  Action getInsertBreakAction();\n+\n+\n+  /**\n+   * Returns whether tokens of the specified type should have \"mark\n+   * occurrences\" enabled for the current programming language.\n+   *\n+   * @param type The token type.\n+   * @return Whether tokens of this type should have \"mark occurrences\"\n+   * enabled.\n+   */\n+  boolean getMarkOccurrencesOfTokenType(int type);\n+\n+\n+  /**\n+   * Returns the object in charge of marking all occurrences of the token\n+   * at the current caret position, if it is a relevant token.  If\n+   * <code>null</code> is returned, a default <code>OccurrenceMarker</code>\n+   * is used.\n+   *\n+   * @return The occurrence marker for this language, or <code>null</code>\n+   * for none.\n+   */\n+  OccurrenceMarker getOccurrenceMarker();\n+\n+\n+  /**\n+   * If a line ends in the specified token, this method returns whether\n+   * a new line inserted after that line should be indented.\n+   *\n+   * @param token The token the previous line ends with.\n+   * @return Whether the next line should be indented.\n+   */\n+  boolean getShouldIndentNextLineAfter(Token token);\n+\n+\n+  /**\n+   * Returns the first token in the linked list of tokens generated\n+   * from <code>text</code>.  This method must be implemented by\n+   * subclasses so they can correctly implement syntax highlighting.\n+   *\n+   * @param text             The text from which to get tokens.\n+   * @param initialTokenType The token type we should start with.\n+   * @param startOffset      The offset into the document at which\n+   *                         <code>text</code> starts.\n+   * @return The first <code>Token</code> in a linked list representing\n+   * the syntax highlighted text.\n+   */\n+  Token getTokenList(Segment text, int initialTokenType,\n+                     int startOffset);\n+\n+\n+  /**\n+   * Returns whether a character could be part of an \"identifier\" token\n+   * in a specific language.  This is used to identify such things as the\n+   * bounds of the \"word\" to select on double-clicking.\n+   *\n+   * @param languageIndex The language index the character was found in.\n+   * @param ch            The character.\n+   * @return Whether the character could be part of an \"identifier\" token.\n+   */\n+  boolean isIdentifierChar(int languageIndex, char ch);\n+\n+\n+  /**\n+   * Returns whether this language is a markup language.\n+   *\n+   * @return Whether this language is markup.\n+   */\n+  boolean isMarkupLanguage();\n \n \n }\n",
            "diff_size": 164
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "29",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/intuit-Tank/errored/1/164/TokenMaker.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/intuit-Tank/naturalize/164/TokenMaker.java\nindex 580db9f5a51..2de85d882da 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/intuit-Tank/errored/1/164/TokenMaker.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/intuit-Tank/naturalize/164/TokenMaker.java\n@@ -12,7 +12,6 @@ package org.fife.ui.rsyntaxtextarea;\n import javax.swing.Action;\n import javax.swing.text.Segment;\n \n-\n /**\n  * An implementation of <code>TokenMaker</code> is a class that turns text into\n  * a linked list of <code>Token</code>s for syntax highlighting\n@@ -26,16 +25,14 @@ import javax.swing.text.Segment;\n  */\n public interface TokenMaker {\n \n-\n-\t/**\n+    /**\n \t * Adds a null token to the end of the current linked list of tokens.\n \t * This should be put at the end of the linked list whenever the last\n \t * token on the current line is NOT a multi-line token.\n \t */\n \tvoid addNullToken();\n \n-\n-\t/**\n+/**\n \t * Adds the token specified to the current linked list of tokens.\n \t *\n \t * @param array The character array from which to get the text.\n@@ -45,11 +42,9 @@ public interface TokenMaker {\n \t * @param startOffset The offset in the document at which this token\n \t *        occurs.\n \t */\n-\tvoid addToken(char[] array, int start, int end, int tokenType,\n-\t\t\t\t  int startOffset);\n+\tvoid addToken(char[] array, int start, int end, int tokenType, int startOffset);\n \n-\n-\t/**\n+/**\n \t * Returns the closest {@link TokenTypes \"standard\" token type} for a given\n \t * \"internal\" token type (e.g. one whose value is <code>&lt; 0</code>).\n \t *\n@@ -59,8 +54,7 @@ public interface TokenMaker {\n \t */\n \tint getClosestStandardTokenTypeForInternalType(int type);\n \n-\n-\t/**\n+/**\n \t * Returns whether this programming language uses curly braces\n \t * ('<code>{</code>' and '<code>}</code>') to denote code blocks.\n \t *\n@@ -72,8 +66,7 @@ public interface TokenMaker {\n \t */\n \tboolean getCurlyBracesDenoteCodeBlocks(int languageIndex);\n \n-\n-\t/**\n+/**\n \t * Returns the last token on this line's type if the token is \"unfinished\",\n \t * or {@link Token#NULL} if it was finished.  For example, if C-style\n \t * syntax highlighting is being implemented, and <code>text</code>\n@@ -91,8 +84,7 @@ public interface TokenMaker {\n \t */\n \tint getLastTokenTypeOnLine(Segment text, int initialTokenType);\n \n-\n-\t/**\n+/**\n \t * Returns the text to place at the beginning and end of a\n \t * line to \"comment\" it in this programming language.\n \t *\n@@ -108,8 +100,7 @@ public interface TokenMaker {\n \t */\n \tString[] getLineCommentStartAndEnd(int languageIndex);\n \n-\n-\t/**\n+/**\n \t * Returns an action to handle \"insert break\" key presses (i.e. Enter).\n \t *\n \t * @return The action, or <code>null</code> if the default action should\n@@ -117,8 +108,7 @@ public interface TokenMaker {\n \t */\n \tAction getInsertBreakAction();\n \n-\n-\t/**\n+/**\n \t * Returns whether tokens of the specified type should have \"mark\n \t * occurrences\" enabled for the current programming language.\n \t *\n@@ -128,8 +118,7 @@ public interface TokenMaker {\n \t */\n \tboolean getMarkOccurrencesOfTokenType(int type);\n \n-\n-\t/**\n+/**\n \t * Returns the object in charge of marking all occurrences of the token\n \t * at the current caret position, if it is a relevant token.  If\n \t * <code>null</code> is returned, a default <code>OccurrenceMarker</code>\n@@ -140,8 +129,7 @@ public interface TokenMaker {\n \t */\n \tOccurrenceMarker getOccurrenceMarker();\n \n-\n-\t/**\n+/**\n \t * If a line ends in the specified token, this method returns whether\n \t * a new line inserted after that line should be indented.\n \t *\n@@ -150,8 +138,7 @@ public interface TokenMaker {\n \t */\n \tboolean getShouldIndentNextLineAfter(Token token);\n \n-\n-\t/**\n+/**\n \t * Returns the first token in the linked list of tokens generated\n \t * from <code>text</code>.  This method must be implemented by\n \t * subclasses so they can correctly implement syntax highlighting.\n@@ -163,11 +150,9 @@ public interface TokenMaker {\n \t * @return The first <code>Token</code> in a linked list representing\n \t *         the syntax highlighted text.\n \t */\n-\tToken getTokenList(Segment text, int initialTokenType,\n-\t\t\t\t\t   int startOffset);\n-\n+\tToken getTokenList(Segment text, int initialTokenType, int startOffset);\n \n-\t/**\n+/**\n \t * Returns whether a character could be part of an \"identifier\" token\n \t * in a specific language.  This is used to identify such things as the\n \t * bounds of the \"word\" to select on double-clicking.\n@@ -178,13 +163,11 @@ public interface TokenMaker {\n \t */\n \tboolean isIdentifierChar(int languageIndex, char ch);\n \n-\n-\t/**\n+/**\n \t * Returns whether this language is a markup language.\n \t *\n \t * @return Whether this language is markup.\n \t */\n \tboolean isMarkupLanguage();\n \n-\n-}\n+    }\n\\ No newline at end of file\n",
            "diff_size": 33
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/intuit-Tank/errored/1/164/TokenMaker.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/intuit-Tank/codebuff/164/TokenMaker.java\nindex 580db9f5a51..dfac5c9f4f9 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/intuit-Tank/errored/1/164/TokenMaker.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/intuit-Tank/codebuff/164/TokenMaker.java\n@@ -9,6 +9,8 @@\n  */\n package org.fife.ui.rsyntaxtextarea;\n \n+\n+\n import javax.swing.Action;\n import javax.swing.text.Segment;\n \n@@ -24,167 +26,179 @@ import javax.swing.text.Segment;\n  * @author Robert Futrell\n  * @version 0.2\n  */\n+\n+\n public interface TokenMaker {\n \n \n-\t/**\n-\t * Adds a null token to the end of the current linked list of tokens.\n-\t * This should be put at the end of the linked list whenever the last\n-\t * token on the current line is NOT a multi-line token.\n-\t */\n-\tvoid addNullToken();\n-\n-\n-\t/**\n-\t * Adds the token specified to the current linked list of tokens.\n-\t *\n-\t * @param array The character array from which to get the text.\n-\t * @param start Start offset in <code>segment</code> of token.\n-\t * @param end End offset in <code>segment</code> of token.\n-\t * @param tokenType The token's type.\n-\t * @param startOffset The offset in the document at which this token\n-\t *        occurs.\n-\t */\n-\tvoid addToken(char[] array, int start, int end, int tokenType,\n-\t\t\t\t  int startOffset);\n-\n-\n-\t/**\n-\t * Returns the closest {@link TokenTypes \"standard\" token type} for a given\n-\t * \"internal\" token type (e.g. one whose value is <code>&lt; 0</code>).\n-\t *\n-\t * @param type The token type.\n-\t * @return The closest \"standard\" token type.  If a mapping is not defined\n-\t *         for this language, then <code>type</code> is returned.\n-\t */\n-\tint getClosestStandardTokenTypeForInternalType(int type);\n-\n-\n-\t/**\n-\t * Returns whether this programming language uses curly braces\n-\t * ('<code>{</code>' and '<code>}</code>') to denote code blocks.\n-\t *\n-\t * @param languageIndex The language index at the offset in question.\n-\t *        Since some <code>TokenMaker</code>s effectively have nested\n-\t *        languages (such as JavaScript in HTML), this parameter tells the\n-\t *        <code>TokenMaker</code> what sub-language to look at.\n-\t * @return Whether curly braces denote code blocks.\n-\t */\n-\tboolean getCurlyBracesDenoteCodeBlocks(int languageIndex);\n-\n-\n-\t/**\n-\t * Returns the last token on this line's type if the token is \"unfinished\",\n-\t * or {@link Token#NULL} if it was finished.  For example, if C-style\n-\t * syntax highlighting is being implemented, and <code>text</code>\n-\t * contained a line of code that contained the beginning of a comment but\n-\t * no end-comment marker (\"*\\/\"), then this method would return\n-\t * {@link Token#COMMENT_MULTILINE} for that line.  This is useful\n-\t * for doing syntax highlighting.\n-\t *\n-\t * @param text The line of tokens to examine.\n-\t * @param initialTokenType The token type to start with (i.e., the value\n-\t *        of <code>getLastTokenTypeOnLine</code> for the line before\n-\t *        <code>text</code>).\n-\t * @return The last token on this line's type, or {@link Token#NULL}\n-\t *         if the line was completed.\n-\t */\n-\tint getLastTokenTypeOnLine(Segment text, int initialTokenType);\n-\n-\n-\t/**\n-\t * Returns the text to place at the beginning and end of a\n-\t * line to \"comment\" it in this programming language.\n-\t *\n-\t * @param languageIndex The language index at the offset in question.\n-\t *        Since some <code>TokenMaker</code>s effectively have nested\n-\t *        languages (such as JavaScript in HTML), this parameter tells the\n-\t *        <code>TokenMaker</code> what sub-language to look at.\n-\t * @return The start and end strings to add to a line to \"comment\"\n-\t *         it out.  A <code>null</code> value for either means there\n-\t *         is no string to add for that part.  A value of\n-\t *         <code>null</code> for the array means this language\n-\t *         does not support commenting/uncommenting lines.\n-\t */\n-\tString[] getLineCommentStartAndEnd(int languageIndex);\n-\n-\n-\t/**\n-\t * Returns an action to handle \"insert break\" key presses (i.e. Enter).\n-\t *\n-\t * @return The action, or <code>null</code> if the default action should\n-\t *         be used.\n-\t */\n-\tAction getInsertBreakAction();\n-\n-\n-\t/**\n-\t * Returns whether tokens of the specified type should have \"mark\n-\t * occurrences\" enabled for the current programming language.\n-\t *\n-\t * @param type The token type.\n-\t * @return Whether tokens of this type should have \"mark occurrences\"\n-\t *         enabled.\n-\t */\n-\tboolean getMarkOccurrencesOfTokenType(int type);\n-\n-\n-\t/**\n-\t * Returns the object in charge of marking all occurrences of the token\n-\t * at the current caret position, if it is a relevant token.  If\n-\t * <code>null</code> is returned, a default <code>OccurrenceMarker</code>\n-\t * is used.\n-\t *\n-\t * @return The occurrence marker for this language, or <code>null</code>\n-\t *         for none.\n-\t */\n-\tOccurrenceMarker getOccurrenceMarker();\n-\n-\n-\t/**\n-\t * If a line ends in the specified token, this method returns whether\n-\t * a new line inserted after that line should be indented.\n-\t *\n-\t * @param token The token the previous line ends with.\n-\t * @return Whether the next line should be indented.\n-\t */\n-\tboolean getShouldIndentNextLineAfter(Token token);\n-\n-\n-\t/**\n-\t * Returns the first token in the linked list of tokens generated\n-\t * from <code>text</code>.  This method must be implemented by\n-\t * subclasses so they can correctly implement syntax highlighting.\n-\t *\n-\t * @param text The text from which to get tokens.\n-\t * @param initialTokenType The token type we should start with.\n-\t * @param startOffset The offset into the document at which\n-\t *        <code>text</code> starts.\n-\t * @return The first <code>Token</code> in a linked list representing\n-\t *         the syntax highlighted text.\n-\t */\n-\tToken getTokenList(Segment text, int initialTokenType,\n-\t\t\t\t\t   int startOffset);\n-\n-\n-\t/**\n-\t * Returns whether a character could be part of an \"identifier\" token\n-\t * in a specific language.  This is used to identify such things as the\n-\t * bounds of the \"word\" to select on double-clicking.\n-\t *\n-\t * @param languageIndex The language index the character was found in.\n-\t * @param ch The character.\n-\t * @return Whether the character could be part of an \"identifier\" token.\n-\t */\n-\tboolean isIdentifierChar(int languageIndex, char ch);\n-\n-\n-\t/**\n-\t * Returns whether this language is a markup language.\n-\t *\n-\t * @return Whether this language is markup.\n-\t */\n-\tboolean isMarkupLanguage();\n-\n-\n-}\n+    /**\n+     * Adds a null token to the end of the current linked list of tokens.\n+     * This should be put at the end of the linked list whenever the last\n+     * token on the current line is NOT a multi-line token.\n+     */\n+\n+    void addNullToken();\n+\n+\n+    /**\n+     * Adds the token specified to the current linked list of tokens.\n+     *\n+     * @param array The character array from which to get the text.\n+     * @param start Start offset in <code>segment</code> of token.\n+     * @param end End offset in <code>segment</code> of token.\n+     * @param tokenType The token's type.\n+     * @param startOffset The offset in the document at which this token\n+     *        occurs.\n+     */\n+\n+    void addToken(char[] array, int start, int end, int tokenType, int startOffset);\n+\n+\n+    /**\n+     * Returns the closest {@link TokenTypes \"standard\" token type} for a given\n+     * \"internal\" token type (e.g. one whose value is <code>&lt; 0</code>).\n+     *\n+     * @param type The token type.\n+     * @return The closest \"standard\" token type.  If a mapping is not defined\n+     *         for this language, then <code>type</code> is returned.\n+     */\n+\n+    int getClosestStandardTokenTypeForInternalType(int type);\n+\n+\n+    /**\n+     * Returns whether this programming language uses curly braces\n+     * ('<code>{</code>' and '<code>}</code>') to denote code blocks.\n+     *\n+     * @param languageIndex The language index at the offset in question.\n+     *        Since some <code>TokenMaker</code>s effectively have nested\n+     *        languages (such as JavaScript in HTML), this parameter tells the\n+     *        <code>TokenMaker</code> what sub-language to look at.\n+     * @return Whether curly braces denote code blocks.\n+     */\n+\n+    boolean getCurlyBracesDenoteCodeBlocks(int languageIndex);\n+\n+\n+    /**\n+     * Returns the last token on this line's type if the token is \"unfinished\",\n+     * or {@link Token#NULL} if it was finished.  For example, if C-style\n+     * syntax highlighting is being implemented, and <code>text</code>\n+     * contained a line of code that contained the beginning of a comment but\n+     * no end-comment marker (\"*\\/\"), then this method would return\n+     * {@link Token#COMMENT_MULTILINE} for that line.  This is useful\n+     * for doing syntax highlighting.\n+     *\n+     * @param text The line of tokens to examine.\n+     * @param initialTokenType The token type to start with (i.e., the value\n+     *        of <code>getLastTokenTypeOnLine</code> for the line before\n+     *        <code>text</code>).\n+     * @return The last token on this line's type, or {@link Token#NULL}\n+     *         if the line was completed.\n+     */\n+\n+    int getLastTokenTypeOnLine(Segment text, int initialTokenType);\n+\n+\n+    /**\n+     * Returns the text to place at the beginning and end of a\n+     * line to \"comment\" it in this programming language.\n+     *\n+     * @param languageIndex The language index at the offset in question.\n+     *        Since some <code>TokenMaker</code>s effectively have nested\n+     *        languages (such as JavaScript in HTML), this parameter tells the\n+     *        <code>TokenMaker</code> what sub-language to look at.\n+     * @return The start and end strings to add to a line to \"comment\"\n+     *         it out.  A <code>null</code> value for either means there\n+     *         is no string to add for that part.  A value of\n+     *         <code>null</code> for the array means this language\n+     *         does not support commenting/uncommenting lines.\n+     */\n+\n+    String[] getLineCommentStartAndEnd(int languageIndex);\n+\n+\n+    /**\n+     * Returns an action to handle \"insert break\" key presses (i.e. Enter).\n+     *\n+     * @return The action, or <code>null</code> if the default action should\n+     *         be used.\n+     */\n+\n+    Action getInsertBreakAction();\n+\n+\n+    /**\n+     * Returns whether tokens of the specified type should have \"mark\n+     * occurrences\" enabled for the current programming language.\n+     *\n+     * @param type The token type.\n+     * @return Whether tokens of this type should have \"mark occurrences\"\n+     *         enabled.\n+     */\n+\n+    boolean getMarkOccurrencesOfTokenType(int type);\n+\n+\n+    /**\n+     * Returns the object in charge of marking all occurrences of the token\n+     * at the current caret position, if it is a relevant token.  If\n+     * <code>null</code> is returned, a default <code>OccurrenceMarker</code>\n+     * is used.\n+     *\n+     * @return The occurrence marker for this language, or <code>null</code>\n+     *         for none.\n+     */\n+\n+    OccurrenceMarker getOccurrenceMarker();\n+\n+\n+    /**\n+     * If a line ends in the specified token, this method returns whether\n+     * a new line inserted after that line should be indented.\n+     *\n+     * @param token The token the previous line ends with.\n+     * @return Whether the next line should be indented.\n+     */\n+\n+    boolean getShouldIndentNextLineAfter(Token token);\n+\n+\n+    /**\n+     * Returns the first token in the linked list of tokens generated\n+     * from <code>text</code>.  This method must be implemented by\n+     * subclasses so they can correctly implement syntax highlighting.\n+     *\n+     * @param text The text from which to get tokens.\n+     * @param initialTokenType The token type we should start with.\n+     * @param startOffset The offset into the document at which\n+     *        <code>text</code> starts.\n+     * @return The first <code>Token</code> in a linked list representing\n+     *         the syntax highlighted text.\n+     */\n+\n+    Token getTokenList(Segment text, int initialTokenType, int startOffset);\n+\n+\n+    /**\n+     * Returns whether a character could be part of an \"identifier\" token\n+     * in a specific language.  This is used to identify such things as the\n+     * bounds of the \"word\" to select on double-clicking.\n+     *\n+     * @param languageIndex The language index the character was found in.\n+     * @param ch The character.\n+     * @return Whether the character could be part of an \"identifier\" token.\n+     */\n+\n+    boolean isIdentifierChar(int languageIndex, char ch);\n+\n+\n+    /**\n+     * Returns whether this language is a markup language.\n+     *\n+     * @return Whether this language is markup.\n+     */\n+\n+    boolean isMarkupLanguage();\n+\n+}\n\\ No newline at end of file\n",
            "diff_size": 175
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "30",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/intuit-Tank/errored/1/164/TokenMaker.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/intuit-Tank/styler_random/164/TokenMaker.java\nindex 580db9f5a51..b6d6ac5273f 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/intuit-Tank/errored/1/164/TokenMaker.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/intuit-Tank/styler_random/164/TokenMaker.java\n@@ -26,13 +26,12 @@ import javax.swing.text.Segment;\n  */\n public interface TokenMaker {\n \n-\n-\t/**\n+    /**\n \t * Adds a null token to the end of the current linked list of tokens.\n \t * This should be put at the end of the linked list whenever the last\n \t * token on the current line is NOT a multi-line token.\n \t */\n-\tvoid addNullToken();\n+        void addNullToken();\n \n \n \t/**\n",
            "diff_size": 3
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "30",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/intuit-Tank/errored/1/164/TokenMaker.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/intuit-Tank/styler_three_grams/164/TokenMaker.java\nindex 580db9f5a51..5e4f1e3e0c8 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/intuit-Tank/errored/1/164/TokenMaker.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/intuit-Tank/styler_three_grams/164/TokenMaker.java\n@@ -26,13 +26,12 @@ import javax.swing.text.Segment;\n  */\n public interface TokenMaker {\n \n-\n-\t/**\n+    /**\n \t * Adds a null token to the end of the current linked list of tokens.\n \t * This should be put at the end of the linked list whenever the last\n \t * token on the current line is NOT a multi-line token.\n \t */\n-\tvoid addNullToken();\n+ void addNullToken();\n \n \n \t/**\n",
            "diff_size": 3
        }
    ],
    "repaired_by": [
        "intellij",
        "codebuff"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "styler_random",
        "styler_three_grams"
    ]
}