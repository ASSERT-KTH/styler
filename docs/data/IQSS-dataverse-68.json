{
    "project_name": "IQSS-dataverse",
    "error_id": "68",
    "information": {
        "errors": [
            {
                "line": "390",
                "column": "5",
                "severity": "error",
                "message": "File contains tab characters (this is the first instance).",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
            }
        ]
    },
    "source_code": "    \n    public String getDirectFileCitation(boolean html){\n    \treturn new DataCitation(this, true).toString(html);\n    }\n    \n        ",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/68/FileMetadata.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler/68/FileMetadata.java\nindex 7b0fb0fd76c..573a02ffcc1 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/68/FileMetadata.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler/68/FileMetadata.java\n@@ -387,7 +387,7 @@ public class FileMetadata implements Serializable {\n      }\n     \n     public String getDirectFileCitation(boolean html){\n-    \treturn new DataCitation(this, true).toString(html);\n+    return new DataCitation(this, true).toString(html);\n     }\n     \n         \n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/68/FileMetadata.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/intellij/68/FileMetadata.java\nindex 7b0fb0fd76c..eaae0761d1c 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/68/FileMetadata.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/intellij/68/FileMetadata.java\n@@ -55,235 +55,235 @@ import javax.validation.constraints.Pattern;\n \n \n /**\n- *\n  * @author skraffmiller\n  */\n-@Table(indexes = {@Index(columnList=\"datafile_id\"), @Index(columnList=\"datasetversion_id\")} )\n+@Table(indexes = {@Index(columnList = \"datafile_id\"), @Index(columnList = \"datasetversion_id\")})\n @Entity\n public class FileMetadata implements Serializable {\n-    private static final long serialVersionUID = 1L;\n-    private static final Logger logger = Logger.getLogger(FileMetadata.class.getCanonicalName());\n+  private static final long serialVersionUID = 1L;\n+  private static final Logger logger = Logger.getLogger(FileMetadata.class.getCanonicalName());\n+\n+\n+  @Expose\n+  @Pattern(regexp = \"^[^:<>;#/\\\"\\\\*\\\\|\\\\?\\\\\\\\]*$\",\n+    message = \"{filename.illegalCharacters}\")\n+  @NotBlank(message = \"{filename.blank}\")\n+  @Column(nullable = false)\n+  private String label = \"\";\n+\n+\n+  @ValidateDataFileDirectoryName(message = \"{directoryname.illegalCharacters}\")\n+  @Expose\n+  @Column(nullable = true)\n+\n+  private String directoryLabel;\n+  @Expose\n+  @Column(columnDefinition = \"TEXT\")\n+  private String description = \"\";\n+\n+  /**\n+   * At the FileMetadata level, \"restricted\" is a historical indication of the\n+   * data owner's intent for the file by version. Permissions are actually\n+   * enforced based on the \"restricted\" boolean at the *DataFile* level. On\n+   * publish, the latest intent is copied from the FileMetadata level to the\n+   * DataFile level.\n+   */\n+  @Expose\n+  private boolean restricted;\n+\n+  @ManyToOne\n+  @JoinColumn(nullable = false)\n+  private DatasetVersion datasetVersion;\n+\n+  @ManyToOne\n+  @JoinColumn(nullable = false)\n+  private DataFile dataFile;\n+\n+  /**\n+   * There are two types of provenance types and this \"free-form\" type is\n+   * represented in the GUI as text box the user can type into. The other type\n+   * is based on PROV-JSON from the W3C.\n+   */\n+  @Expose\n+  @Column(columnDefinition = \"TEXT\", nullable = true, name = \"prov_freeform\")\n+  private String provFreeForm;\n+\n+  @OneToMany(mappedBy = \"fileMetadata\", cascade = {CascadeType.REMOVE, CascadeType.MERGE, CascadeType.PERSIST})\n+  private Collection<VariableMetadata> variableMetadatas;\n+\n+  /**\n+   * Creates a copy of {@code this}, with identical business logic fields.\n+   * E.g., {@link #label} would be duplicated; {@link #version} will not.\n+   *\n+   * @return A copy of {@code this}, except for the DB-related data.\n+   */\n+  public FileMetadata createCopy() {\n+    FileMetadata fmd = new FileMetadata();\n+    fmd.setCategories(new LinkedList<>(getCategories()));\n+    fmd.setDataFile(getDataFile());\n+    fmd.setDatasetVersion(getDatasetVersion());\n+    fmd.setDescription(getDescription());\n+    fmd.setLabel(getLabel());\n+    fmd.setRestricted(isRestricted());\n+\n+    return fmd;\n+  }\n+\n+  public String getLabel() {\n+    return label;\n+  }\n+\n+  public void setLabel(String label) {\n+    this.label = label;\n+  }\n+\n+  public FileMetadata() {\n+    variableMetadatas = new ArrayList<VariableMetadata>();\n+    varGroups = new ArrayList<VarGroup>();\n+  }\n+\n+  public String getDirectoryLabel() {\n+    return directoryLabel;\n+  }\n+\n+  public void setDirectoryLabel(String directoryLabel) {\n+    //Strip off beginning and ending \\ // - .\n+    // and replace any sequences/combinations of / and \\ with a single /\n+    if (directoryLabel != null) {\n+      directoryLabel = StringUtil.sanitizeFileDirectory(directoryLabel);\n+    }\n \n+    this.directoryLabel = directoryLabel;\n+  }\n \n-    @Expose\n-    @Pattern(regexp=\"^[^:<>;#/\\\"\\\\*\\\\|\\\\?\\\\\\\\]*$\", \n-            message = \"{filename.illegalCharacters}\")\n-    @NotBlank(message = \"{filename.blank}\")\n-    @Column( nullable=false )\n-    private String label = \"\";\n-    \n-    \n-    @ValidateDataFileDirectoryName(message = \"{directoryname.illegalCharacters}\")\n-    @Expose\n-    @Column ( nullable=true )\n-\n-    private String directoryLabel;\n-    @Expose\n-    @Column(columnDefinition = \"TEXT\")\n-    private String description = \"\";\n-    \n-    /**\n-     * At the FileMetadata level, \"restricted\" is a historical indication of the\n-     * data owner's intent for the file by version. Permissions are actually\n-     * enforced based on the \"restricted\" boolean at the *DataFile* level. On\n-     * publish, the latest intent is copied from the FileMetadata level to the\n-     * DataFile level.\n-     */\n-    @Expose\n-    private boolean restricted;\n-\n-    @ManyToOne\n-    @JoinColumn(nullable=false)\n-    private DatasetVersion datasetVersion;\n-    \n-    @ManyToOne\n-    @JoinColumn(nullable=false)\n-    private DataFile dataFile;\n-\n-    /**\n-     * There are two types of provenance types and this \"free-form\" type is\n-     * represented in the GUI as text box the user can type into. The other type\n-     * is based on PROV-JSON from the W3C.\n-     */\n-    @Expose\n-    @Column(columnDefinition = \"TEXT\", nullable = true, name=\"prov_freeform\")\n-    private String provFreeForm;\n-\n-    @OneToMany (mappedBy=\"fileMetadata\", cascade={ CascadeType.REMOVE, CascadeType.MERGE,CascadeType.PERSIST})\n-    private Collection<VariableMetadata> variableMetadatas;\n-        \n-    /**\n-     * Creates a copy of {@code this}, with identical business logic fields.\n-     * E.g., {@link #label} would be duplicated; {@link #version} will not.\n-     * \n-     * @return A copy of {@code this}, except for the DB-related data.\n-     */\n-    public FileMetadata createCopy() {\n-        FileMetadata fmd = new FileMetadata();\n-        fmd.setCategories(new LinkedList<>(getCategories()) );\n-        fmd.setDataFile( getDataFile() );\n-        fmd.setDatasetVersion( getDatasetVersion() );\n-        fmd.setDescription( getDescription() );\n-        fmd.setLabel( getLabel() );\n-        fmd.setRestricted( isRestricted() );\n-        \n-        return fmd;\n-    }\n-    \n-    public String getLabel() {\n-        return label;\n-    }\n-    \n-    public void setLabel(String label) {\n-        this.label = label;\n-    }\n+  public String getDescription() {\n+    return description;\n+  }\n \n-    public FileMetadata() {\n-        variableMetadatas = new ArrayList<VariableMetadata>();\n-        varGroups = new ArrayList<VarGroup>();\n-    }\n+  public void setDescription(String description) {\n+    this.description = description;\n+  }\n \n-    public String getDirectoryLabel() {\n-        return directoryLabel;\n-    }\n+  public boolean isRestricted() {\n+    return restricted;\n+  }\n \n-    public void setDirectoryLabel(String directoryLabel) {\n-        //Strip off beginning and ending \\ // - .\n-        // and replace any sequences/combinations of / and \\ with a single /\n-        if (directoryLabel != null) {\n-            directoryLabel = StringUtil.sanitizeFileDirectory(directoryLabel);\n-        }\n+  public void setRestricted(boolean restricted) {\n+    this.restricted = restricted;\n+  }\n \n-        this.directoryLabel = directoryLabel;\n-    }\n+  @OneToMany(mappedBy = \"fileMetadata\", cascade = {CascadeType.REMOVE, CascadeType.MERGE, CascadeType.PERSIST})\n+  private List<VarGroup> varGroups;\n \n-    public String getDescription() {\n-        return description;\n-    }\n+  public Collection<VariableMetadata> getVariableMetadatas() {\n+    return variableMetadatas;\n+  }\n \n-    public void setDescription(String description) {\n-        this.description = description;\n-    }\n+  public List<VarGroup> getVarGroups() {\n+    return varGroups;\n+  }\n \n-    public boolean isRestricted() {\n-        return restricted;\n-    }\n+  public void setVariableMetadatas(Collection<VariableMetadata> variableMetadatas) {\n+    this.variableMetadatas = variableMetadatas;\n+  }\n \n-    public void setRestricted(boolean restricted) {\n-        this.restricted = restricted;\n-    }\n+  public void setVarGroups(List<VarGroup> varGroups) {\n+    this.varGroups = varGroups;\n+  }\n \n-    @OneToMany(mappedBy=\"fileMetadata\", cascade={ CascadeType.REMOVE, CascadeType.MERGE,CascadeType.PERSIST})\n-    private List<VarGroup> varGroups;\n+  /*\n+   * File Categories to which this version of the DataFile belongs:\n+   */\n+  @SerializedName(\"categories\") //Used for OptionalFileParams serialization\n+  @ManyToMany\n+  @JoinTable(indexes = {@Index(columnList = \"filecategories_id\"), @Index(columnList = \"filemetadatas_id\")})\n+  @OrderBy(\"name\")\n+  private List<DataFileCategory> fileCategories;\n \n-    public Collection<VariableMetadata> getVariableMetadatas() {\n-        return variableMetadatas;\n-    }\n+  public List<DataFileCategory> getCategories() {\n+    return fileCategories;\n+  }\n \n-    public List<VarGroup> getVarGroups() {\n-        return varGroups;\n-    }\n+  public void setCategories(List<DataFileCategory> fileCategories) {\n+    this.fileCategories = fileCategories;\n+  }\n \n-    public void setVariableMetadatas(Collection<VariableMetadata> variableMetadatas) {\n-        this.variableMetadatas = variableMetadatas;\n+  public void addCategory(DataFileCategory category) {\n+    if (fileCategories == null) {\n+      fileCategories = new ArrayList<>();\n     }\n+    fileCategories.add(category);\n+  }\n \n-    public void setVarGroups(List<VarGroup> varGroups) {\n-        this.varGroups = varGroups;\n-    }\n+  /**\n+   * Retrieve categories\n+   *\n+   * @return\n+   */\n+  public List<String> getCategoriesByName() {\n+    ArrayList<String> ret = new ArrayList<>();\n \n-    /*\n-     * File Categories to which this version of the DataFile belongs: \n-     */\n-    @SerializedName(\"categories\") //Used for OptionalFileParams serialization\n-    @ManyToMany\n-    @JoinTable(indexes = {@Index(columnList=\"filecategories_id\"),@Index(columnList=\"filemetadatas_id\")})\n-    @OrderBy(\"name\")\n-    private List<DataFileCategory> fileCategories;\n-    \n-    public List<DataFileCategory> getCategories() {\n-        return fileCategories;\n+    if (fileCategories == null) {\n+      return ret;\n     }\n-    \n-    public void setCategories(List<DataFileCategory> fileCategories) {\n-        this.fileCategories = fileCategories; \n+\n+    for (DataFileCategory fileCategory : fileCategories) {\n+      ret.add(fileCategory.getName());\n     }\n-    \n-    public void addCategory(DataFileCategory category) {\n-        if (fileCategories == null) {\n-            fileCategories = new ArrayList<>();\n-        }\n-        fileCategories.add(category);\n+    // fileCategories.stream()\n+    //              .map(x -> ret.add(x.getName()));\n+\n+    return ret;\n+  }\n+\n+\n+  public JsonArrayBuilder getCategoryNamesAsJsonArrayBuilder() {\n+\n+    JsonArrayBuilder builder = Json.createArrayBuilder();\n+\n+    if (fileCategories == null) {\n+      return builder;\n     }\n \n-    /**\n-     * Retrieve categories \n-     * @return \n-     */\n-    public List<String> getCategoriesByName() {\n-        ArrayList<String> ret = new ArrayList<>();\n-             \n-        if (fileCategories == null) {\n-            return ret;\n-        }\n-        \n-        for (DataFileCategory fileCategory : fileCategories) {\n-            ret.add(fileCategory.getName());\n-        }\n-        // fileCategories.stream()\n-        //              .map(x -> ret.add(x.getName()));\n-       \n-        return ret;\n+    for (DataFileCategory fileCategory : fileCategories) {\n+      builder.add(fileCategory.getName());\n     }\n-    \n-    \n-    public JsonArrayBuilder getCategoryNamesAsJsonArrayBuilder() {\n \n-        JsonArrayBuilder builder = Json.createArrayBuilder();\n+    //fileCategories.stream()\n+    //              .map(x -> builder.add(x.getName()));\n \n-        if (fileCategories == null) {\n-            return builder;\n-        }\n-        \n-        for (DataFileCategory fileCategory : fileCategories) {\n-            builder.add(fileCategory.getName());\n-        }\n+    return builder;\n \n-        //fileCategories.stream()\n-        //              .map(x -> builder.add(x.getName()));\n-        \n-        return builder;\n-        \n-    }\n-    \n-    \n-    // alternative, experimental method: \n+  }\n \n-    public void setCategoriesByName(List<String> newCategoryNames) {\n-        setCategories(null); // ?? TODO: investigate! \n \n-        if (newCategoryNames != null) {\n+  // alternative, experimental method:\n \n-            for (String newCategoryName : newCategoryNames) {\n-                // Dataset.getCategoryByName() will check if such a category \n-                // already exists for the parent dataset; it will be created \n-                // if not. The method will return null if the supplied \n-                // category name is null or empty. -- L.A. 4.0 beta 10\n-                DataFileCategory fileCategory;\n-                try {\n-                    // Using \"try {}\" to catch any null pointer exceptions, \n-                    // just in case: \n-                    fileCategory = this.getDatasetVersion().getDataset().getCategoryByName(newCategoryName);\n-                } catch (Exception ex) {\n-                    fileCategory = null;\n-                }\n-                if (fileCategory != null) {\n-                    this.addCategory(fileCategory);\n-                    fileCategory.addFileMetadata(this);\n-                }\n-            }\n+  public void setCategoriesByName(List<String> newCategoryNames) {\n+    setCategories(null); // ?? TODO: investigate!\n+\n+    if (newCategoryNames != null) {\n+\n+      for (String newCategoryName : newCategoryNames) {\n+        // Dataset.getCategoryByName() will check if such a category\n+        // already exists for the parent dataset; it will be created\n+        // if not. The method will return null if the supplied\n+        // category name is null or empty. -- L.A. 4.0 beta 10\n+        DataFileCategory fileCategory;\n+        try {\n+          // Using \"try {}\" to catch any null pointer exceptions,\n+          // just in case:\n+          fileCategory = this.getDatasetVersion().getDataset().getCategoryByName(newCategoryName);\n+        } catch (Exception ex) {\n+          fileCategory = null;\n+        }\n+        if (fileCategory != null) {\n+          this.addCategory(fileCategory);\n+          fileCategory.addFileMetadata(this);\n         }\n+      }\n     }\n+  }\n     \n     /* \n         note that this version only *adds* new categories, but does not \n@@ -316,433 +316,433 @@ public class FileMetadata implements Serializable {\n         }\n     }\n     */\n-    \n-    public void addCategoryByName(String newCategoryName) {\n-        if (newCategoryName != null && !newCategoryName.isEmpty()) {\n-            Collection<String> oldCategoryNames = getCategoriesByName();\n-            if (!oldCategoryNames.contains(newCategoryName)) {\n-                DataFileCategory fileCategory;\n-                // Dataset.getCategoryByName() will check if such a category \n-                // already exists for the parent dataset; it will be created \n-                // if not. The method will return null if the supplied \n-                // category name is null or empty. -- L.A. 4.0 beta 10\n-                try {\n-                    // Using \"try {}\" to catch any null pointer exceptions, \n-                    // just in case: \n-                    fileCategory = this.getDatasetVersion().getDataset().getCategoryByName(newCategoryName);\n-                } catch (Exception ex) {\n-                    // If we failed to obtain an existing category, we'll create a new one:\n-                    fileCategory = new DataFileCategory();\n-                    fileCategory.setName(newCategoryName);\n-                }\n-\n-                \n-                if (fileCategory != null) {\n-                    logger.log(Level.FINE, \"Found file category for {0}\", newCategoryName);\n-\n-                    this.addCategory(fileCategory);\n-                    fileCategory.addFileMetadata(this);\n-                } else {\n-                    logger.log(Level.INFO, \"Could not find file category for {0}\", newCategoryName);\n-                }\n-            } else {\n-                // don't do anything - this file metadata already belongs to\n-                // this category.\n-            }\n+\n+  public void addCategoryByName(String newCategoryName) {\n+    if (newCategoryName != null && !newCategoryName.isEmpty()) {\n+      Collection<String> oldCategoryNames = getCategoriesByName();\n+      if (!oldCategoryNames.contains(newCategoryName)) {\n+        DataFileCategory fileCategory;\n+        // Dataset.getCategoryByName() will check if such a category\n+        // already exists for the parent dataset; it will be created\n+        // if not. The method will return null if the supplied\n+        // category name is null or empty. -- L.A. 4.0 beta 10\n+        try {\n+          // Using \"try {}\" to catch any null pointer exceptions,\n+          // just in case:\n+          fileCategory = this.getDatasetVersion().getDataset().getCategoryByName(newCategoryName);\n+        } catch (Exception ex) {\n+          // If we failed to obtain an existing category, we'll create a new one:\n+          fileCategory = new DataFileCategory();\n+          fileCategory.setName(newCategoryName);\n         }\n-    }\n-    \n-     public String getFileDateToDisplay() {\n-        Date fileDate = null;\n-        DataFile datafile = this.getDataFile();\n-        if (datafile != null) {\n-            boolean fileHasBeenReleased = datafile.isReleased();\n-            if (fileHasBeenReleased) {\n-                Timestamp filePublicationTimestamp = datafile.getPublicationDate();\n-                if (filePublicationTimestamp != null) {\n-                    fileDate = filePublicationTimestamp;\n-                }\n-            } else {\n-                Timestamp fileCreateTimestamp = datafile.getCreateDate();\n-                if (fileCreateTimestamp != null) {\n-                    fileDate = fileCreateTimestamp;\n-                }\n-            }\n+\n+\n+        if (fileCategory != null) {\n+          logger.log(Level.FINE, \"Found file category for {0}\", newCategoryName);\n+\n+          this.addCategory(fileCategory);\n+          fileCategory.addFileMetadata(this);\n+        } else {\n+          logger.log(Level.INFO, \"Could not find file category for {0}\", newCategoryName);\n         }\n-        if (fileDate != null) {\n-            return DateUtil.formatDate(fileDate);\n+      } else {\n+        // don't do anything - this file metadata already belongs to\n+        // this category.\n+      }\n+    }\n+  }\n+\n+  public String getFileDateToDisplay() {\n+    Date fileDate = null;\n+    DataFile datafile = this.getDataFile();\n+    if (datafile != null) {\n+      boolean fileHasBeenReleased = datafile.isReleased();\n+      if (fileHasBeenReleased) {\n+        Timestamp filePublicationTimestamp = datafile.getPublicationDate();\n+        if (filePublicationTimestamp != null) {\n+          fileDate = filePublicationTimestamp;\n         }\n-        return \"\";\n-    }\n-     \n-    public String getFileCitation(){\n-         return getFileCitation(false);\n-     }\n-     \n-\n-    \n-     \n-    public String getFileCitation(boolean html){\n-         return new DataCitation(this).toString(html);\n-     }\n-    \n-    public String getDirectFileCitation(boolean html){\n-    \treturn new DataCitation(this, true).toString(html);\n+      } else {\n+        Timestamp fileCreateTimestamp = datafile.getCreateDate();\n+        if (fileCreateTimestamp != null) {\n+          fileDate = fileCreateTimestamp;\n+        }\n+      }\n     }\n-    \n-        \n-    public DatasetVersion getDatasetVersion() {\n-        return datasetVersion;\n+    if (fileDate != null) {\n+      return DateUtil.formatDate(fileDate);\n     }\n+    return \"\";\n+  }\n \n-    public void setDatasetVersion(DatasetVersion datasetVersion) {\n-        this.datasetVersion = datasetVersion;\n-    }\n+  public String getFileCitation() {\n+    return getFileCitation(false);\n+  }\n \n \n+  public String getFileCitation(boolean html) {\n+    return new DataCitation(this).toString(html);\n+  }\n \n-    public DataFile getDataFile() {\n-        return dataFile;\n-    }\n+  public String getDirectFileCitation(boolean html) {\n+    return new DataCitation(this, true).toString(html);\n+  }\n \n-    public void setDataFile(DataFile dataFile) {\n-        this.dataFile = dataFile;\n-    }\n \n+  public DatasetVersion getDatasetVersion() {\n+    return datasetVersion;\n+  }\n \n-    @Id\n-    @GeneratedValue(strategy = GenerationType.IDENTITY)\n-    private Long id;\n+  public void setDatasetVersion(DatasetVersion datasetVersion) {\n+    this.datasetVersion = datasetVersion;\n+  }\n \n-    /**\n-     * Getter for property id.\n-     * @return Value of property id.\n-     */\n-    public Long getId() {\n-        return this.id;\n-    }\n \n-    /**\n-     * Setter for property id.\n-     * @param id New value of property id.\n-     */\n-    public void setId(Long id) {\n-        this.id = id;\n-    }\n+  public DataFile getDataFile() {\n+    return dataFile;\n+  }\n \n+  public void setDataFile(DataFile dataFile) {\n+    this.dataFile = dataFile;\n+  }\n \n-    @Version\n-    private Long version;\n \n-    /**\n-     * Getter for property version.\n-     * @return Value of property version.\n-     */\n-    public Long getVersion() {\n-        return this.version;\n-    }\n+  @Id\n+  @GeneratedValue(strategy = GenerationType.IDENTITY)\n+  private Long id;\n \n-    /**\n-     * Setter for property version.\n-     * @param version New value of property version.\n-     */\n-    public void setVersion(Long version) {\n-        this.version = version;\n-    }\n-    \n-    @Transient\n-    private boolean inPriorVersion;\n+  /**\n+   * Getter for property id.\n+   *\n+   * @return Value of property id.\n+   */\n+  public Long getId() {\n+    return this.id;\n+  }\n \n-    public boolean isInPriorVersion() {\n-        return inPriorVersion;\n-    }\n+  /**\n+   * Setter for property id.\n+   *\n+   * @param id New value of property id.\n+   */\n+  public void setId(Long id) {\n+    this.id = id;\n+  }\n \n-    public void setInPriorVersion(boolean inPriorVersion) {\n-        this.inPriorVersion = inPriorVersion;\n-    }\n \n-    @Transient\n-    private boolean selected;\n+  @Version\n+  private Long version;\n \n-    public boolean isSelected() {\n-        return selected;\n-    }\n+  /**\n+   * Getter for property version.\n+   *\n+   * @return Value of property version.\n+   */\n+  public Long getVersion() {\n+    return this.version;\n+  }\n \n-    public void setSelected(boolean selected) {\n-        this.selected = selected;\n-    }\n-    \n-    \n-    @Transient\n-    private boolean restrictedUI;\n+  /**\n+   * Setter for property version.\n+   *\n+   * @param version New value of property version.\n+   */\n+  public void setVersion(Long version) {\n+    this.version = version;\n+  }\n \n-    public boolean isRestrictedUI() {\n-        return restrictedUI;\n-    }\n+  @Transient\n+  private boolean inPriorVersion;\n \n-    public void setRestrictedUI(boolean restrictedUI) {\n-        this.restrictedUI = restrictedUI;\n-    }\n-    \n-    @Transient\n-    private FileVersionDifference fileVersionDifference ;\n+  public boolean isInPriorVersion() {\n+    return inPriorVersion;\n+  }\n \n-    public FileVersionDifference getFileVersionDifference() {\n-        return fileVersionDifference;\n-    }\n+  public void setInPriorVersion(boolean inPriorVersion) {\n+    this.inPriorVersion = inPriorVersion;\n+  }\n \n-    public void setFileVersionDifference(FileVersionDifference fileVersionDifference) {\n-        this.fileVersionDifference = fileVersionDifference;\n-    }\n-    \n-    @Transient\n-    private String contributorNames;\n+  @Transient\n+  private boolean selected;\n \n-    public String getContributorNames() {\n-        return contributorNames;\n-    }\n+  public boolean isSelected() {\n+    return selected;\n+  }\n \n-    public void setContributorNames(String contributorNames) {\n-        this.contributorNames = contributorNames;\n-    }\n-        \n+  public void setSelected(boolean selected) {\n+    this.selected = selected;\n+  }\n \n-    @Override\n-    public int hashCode() {\n-        int hash = 0;\n-        hash += (id != null ? id.hashCode() : 0);\n-        return hash;\n-    }\n \n-    @Override\n-    public boolean equals(Object object) {\n-        if (!(object instanceof FileMetadata)) {\n-            return false;\n-        }\n-        FileMetadata other = (FileMetadata) object;\n-        \n-        return !((this.id == null && other.id != null) || (this.id != null && !this.id.equals(other.id)));\n+  @Transient\n+  private boolean restrictedUI;\n+\n+  public boolean isRestrictedUI() {\n+    return restrictedUI;\n+  }\n+\n+  public void setRestrictedUI(boolean restrictedUI) {\n+    this.restrictedUI = restrictedUI;\n+  }\n+\n+  @Transient\n+  private FileVersionDifference fileVersionDifference;\n+\n+  public FileVersionDifference getFileVersionDifference() {\n+    return fileVersionDifference;\n+  }\n+\n+  public void setFileVersionDifference(FileVersionDifference fileVersionDifference) {\n+    this.fileVersionDifference = fileVersionDifference;\n+  }\n+\n+  @Transient\n+  private String contributorNames;\n+\n+  public String getContributorNames() {\n+    return contributorNames;\n+  }\n+\n+  public void setContributorNames(String contributorNames) {\n+    this.contributorNames = contributorNames;\n+  }\n+\n+\n+  @Override\n+  public int hashCode() {\n+    int hash = 0;\n+    hash += (id != null ? id.hashCode() : 0);\n+    return hash;\n+  }\n+\n+  @Override\n+  public boolean equals(Object object) {\n+    if (!(object instanceof FileMetadata)) {\n+      return false;\n     }\n-    \n-    public boolean contentEquals(FileMetadata other) {\n+    FileMetadata other = (FileMetadata) object;\n+\n+    return !((this.id == null && other.id != null) || (this.id != null && !this.id.equals(other.id)));\n+  }\n+\n+  public boolean contentEquals(FileMetadata other) {\n     /* \n        This method now invokes the logic contained in the FileVersionDifference compareMetadata method\n        so that the logic is in a single place\n     */\n-        return compareContent(other);\n-    }\n+    return compareContent(other);\n+  }\n \n-    \n-    public boolean compareContent(FileMetadata other){\n-         FileVersionDifference diffObj = new FileVersionDifference(this, other, false);\n-         return diffObj.compareMetadata(this, other);\n-    }\n-    \n+\n+  public boolean compareContent(FileMetadata other) {\n+    FileVersionDifference diffObj = new FileVersionDifference(this, other, false);\n+    return diffObj.compareMetadata(this, other);\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return \"edu.harvard.iq.dvn.core.study.FileMetadata[id=\" + id + \"]\";\n+  }\n+\n+  public static final Comparator<FileMetadata> compareByLabel = new Comparator<FileMetadata>() {\n     @Override\n-    public String toString() {\n-        return \"edu.harvard.iq.dvn.core.study.FileMetadata[id=\" + id + \"]\";\n+    public int compare(FileMetadata o1, FileMetadata o2) {\n+      return o1.getLabel().toUpperCase().compareTo(o2.getLabel().toUpperCase());\n     }\n-    \n-    public static final Comparator<FileMetadata> compareByLabel = new Comparator<FileMetadata>() {\n-        @Override\n-        public int compare(FileMetadata o1, FileMetadata o2) {\n-            return o1.getLabel().toUpperCase().compareTo(o2.getLabel().toUpperCase());\n-        }\n-    };\n-    \n-    public static final Comparator<FileMetadata> compareByLabelAndFolder = new Comparator<FileMetadata>() {\n-        @Override\n-        public int compare(FileMetadata o1, FileMetadata o2) {\n-            String folder1 = o1.getDirectoryLabel() == null ? \"\" : o1.getDirectoryLabel().toUpperCase();\n-            String folder2 = o2.getDirectoryLabel() == null ? \"\" : o2.getDirectoryLabel().toUpperCase();\n-            \n-            \n-            // We want to the files w/ no folders appear *after* all the folders\n-            // on the sorted list:\n-            if (\"\".equals(folder1) && !\"\".equals(folder2)) {\n-                return 1;\n-            }\n-            \n-            if (\"\".equals(folder2) && !\"\".equals(folder1)) {\n-                return -1;\n-            }\n-            \n-            int comp = folder1.compareTo(folder2); \n-            if (comp != 0) {\n-                return comp;\n-            }\n-            return o1.getLabel().toUpperCase().compareTo(o2.getLabel().toUpperCase());\n-        }\n-    };\n-    \n-    public static final Comparator<FileMetadata> compareByFullPath = new Comparator<FileMetadata>() {\n-        @Override\n-        public int compare(FileMetadata o1, FileMetadata o2) {\n-            String folder1 = StringUtil.isEmpty(o1.getDirectoryLabel()) ? \"\" : o1.getDirectoryLabel().toUpperCase() + \"/\";\n-            String folder2 = StringUtil.isEmpty(o2.getDirectoryLabel()) ? \"\" : o2.getDirectoryLabel().toUpperCase() + \"/\";\n-            \n-            return folder1.concat(o1.getLabel().toUpperCase()).compareTo(folder2.concat(o2.getLabel().toUpperCase()));\n-        }\n-    };\n-    \n-    \n-    public String toPrettyJSON(){\n-        \n-        return serializeAsJSON(true);\n+  };\n+\n+  public static final Comparator<FileMetadata> compareByLabelAndFolder = new Comparator<FileMetadata>() {\n+    @Override\n+    public int compare(FileMetadata o1, FileMetadata o2) {\n+      String folder1 = o1.getDirectoryLabel() == null ? \"\" : o1.getDirectoryLabel().toUpperCase();\n+      String folder2 = o2.getDirectoryLabel() == null ? \"\" : o2.getDirectoryLabel().toUpperCase();\n+\n+\n+      // We want to the files w/ no folders appear *after* all the folders\n+      // on the sorted list:\n+      if (\"\".equals(folder1) && !\"\".equals(folder2)) {\n+        return 1;\n+      }\n+\n+      if (\"\".equals(folder2) && !\"\".equals(folder1)) {\n+        return -1;\n+      }\n+\n+      int comp = folder1.compareTo(folder2);\n+      if (comp != 0) {\n+        return comp;\n+      }\n+      return o1.getLabel().toUpperCase().compareTo(o2.getLabel().toUpperCase());\n     }\n+  };\n+\n+  public static final Comparator<FileMetadata> compareByFullPath = new Comparator<FileMetadata>() {\n+    @Override\n+    public int compare(FileMetadata o1, FileMetadata o2) {\n+      String folder1 = StringUtil.isEmpty(o1.getDirectoryLabel()) ? \"\" : o1.getDirectoryLabel().toUpperCase() + \"/\";\n+      String folder2 = StringUtil.isEmpty(o2.getDirectoryLabel()) ? \"\" : o2.getDirectoryLabel().toUpperCase() + \"/\";\n \n-    public String toJSON(){\n-        \n-        return serializeAsJSON(false);\n+      return folder1.concat(o1.getLabel().toUpperCase()).compareTo(folder2.concat(o2.getLabel().toUpperCase()));\n     }\n-    \n-     /**\n-     * \n-     * @param prettyPrint\n-     * @return \n-     */\n-    private String serializeAsJSON(boolean prettyPrint){\n-        \n-        JsonObject jsonObj = asGsonObject(prettyPrint);\n-                \n-        return jsonObj.toString();\n-       \n+  };\n+\n+\n+  public String toPrettyJSON() {\n+\n+    return serializeAsJSON(true);\n+  }\n+\n+  public String toJSON() {\n+\n+    return serializeAsJSON(false);\n+  }\n+\n+  /**\n+   * @param prettyPrint\n+   * @return\n+   */\n+  private String serializeAsJSON(boolean prettyPrint) {\n+\n+    JsonObject jsonObj = asGsonObject(prettyPrint);\n+\n+    return jsonObj.toString();\n+\n+  }\n+\n+\n+  public JsonObject asGsonObject(boolean prettyPrint) {\n+\n+    GsonBuilder builder;\n+    if (prettyPrint) {  // Add pretty printing\n+      builder = new GsonBuilder().excludeFieldsWithoutExposeAnnotation().setPrettyPrinting();\n+    } else {\n+      builder = new GsonBuilder().excludeFieldsWithoutExposeAnnotation();\n     }\n \n-    \n-    public JsonObject asGsonObject(boolean prettyPrint){\n-        \n-        GsonBuilder builder;\n-        if (prettyPrint){  // Add pretty printing\n-            builder = new GsonBuilder().excludeFieldsWithoutExposeAnnotation().setPrettyPrinting();\n-        } else {\n-            builder = new GsonBuilder().excludeFieldsWithoutExposeAnnotation();                        \n-        }\n-        \n-        Gson gson = builder.create();\n-        \n-        JsonElement jsonObj = gson.toJsonTree(this);\n-        \n-        //Add categories without the \"name\"\n-        List<String> cats = this.getCategoriesByName();\n-        JsonArray jsonCats = new JsonArray();\n-        for(String t : cats) {\n-            jsonCats.add(new JsonPrimitive(t));\n-        }\n-        if(jsonCats.size() > 0) {\n-            jsonObj.getAsJsonObject().add(OptionalFileParams.CATEGORIES_ATTR_NAME, jsonCats);\n-        }\n-        \n-        //Add tags without the \"name\"\n-        List<String> tags = this.getDataFile().getTagLabels();\n-        JsonArray jsonTags = new JsonArray();\n-        for(String t : tags) {\n-            jsonTags.add(new JsonPrimitive(t));\n-        }\n-        if(jsonTags.size() > 0) {\n-            jsonObj.getAsJsonObject().add(OptionalFileParams.FILE_DATA_TAGS_ATTR_NAME, jsonTags);\n-        }\n+    Gson gson = builder.create();\n+\n+    JsonElement jsonObj = gson.toJsonTree(this);\n \n-        jsonObj.getAsJsonObject().addProperty(\"id\", this.getId());\n-        \n-        return jsonObj.getAsJsonObject();\n+    //Add categories without the \"name\"\n+    List<String> cats = this.getCategoriesByName();\n+    JsonArray jsonCats = new JsonArray();\n+    for (String t : cats) {\n+      jsonCats.add(new JsonPrimitive(t));\n     }\n-    \n-    public String getProvFreeForm() {\n-        return provFreeForm;\n+    if (jsonCats.size() > 0) {\n+      jsonObj.getAsJsonObject().add(OptionalFileParams.CATEGORIES_ATTR_NAME, jsonCats);\n     }\n \n-    public void setProvFreeForm(String provFreeForm) {\n-        this.provFreeForm = provFreeForm;\n+    //Add tags without the \"name\"\n+    List<String> tags = this.getDataFile().getTagLabels();\n+    JsonArray jsonTags = new JsonArray();\n+    for (String t : tags) {\n+      jsonTags.add(new JsonPrimitive(t));\n+    }\n+    if (jsonTags.size() > 0) {\n+      jsonObj.getAsJsonObject().add(OptionalFileParams.FILE_DATA_TAGS_ATTR_NAME, jsonTags);\n     }\n \n-    public void copyVariableMetadata(Collection<VariableMetadata> vml) {\n+    jsonObj.getAsJsonObject().addProperty(\"id\", this.getId());\n \n-        if (variableMetadatas == null) {\n-            variableMetadatas = new ArrayList<VariableMetadata>();\n-        }\n+    return jsonObj.getAsJsonObject();\n+  }\n \n-        for (VariableMetadata vm : vml) {\n-            VariableMetadata vmNew = null;\n-            boolean flagNew = true;\n-            for (VariableMetadata vmThis: variableMetadatas) {\n-                if (vmThis.getDataVariable().getId().equals(vm.getDataVariable().getId())) {\n-                    vmNew = vmThis;\n-                    flagNew = false;\n-                    break;\n-                }\n-            }\n-            if (flagNew) {\n-                vmNew = new VariableMetadata(vm.getDataVariable(), this);\n-            }\n-            vmNew.setIsweightvar(vm.isIsweightvar());\n-            vmNew.setWeighted(vm.isWeighted());\n-            vmNew.setWeightvariable(vm.getWeightvariable());\n-            vmNew.setInterviewinstruction(vm.getInterviewinstruction());\n-            vmNew.setLabel(vm.getLabel());\n-            vmNew.setLiteralquestion(vm.getLiteralquestion());\n-            vmNew.setNotes(vm.getNotes());\n-            vmNew.setUniverse(vm.getUniverse());\n-            vmNew.setPostquestion(vm.getPostquestion());\n-\n-            Collection<CategoryMetadata> cms = vm.getCategoriesMetadata();\n-            if (flagNew) {\n-                for (CategoryMetadata cm : cms) {\n-                    CategoryMetadata cmNew = new CategoryMetadata(vmNew, cm.getCategory());\n-                    cmNew.setWfreq(cm.getWfreq());\n-                    vmNew.getCategoriesMetadata().add(cmNew);\n-                }\n-                variableMetadatas.add(vmNew);\n-            } else {\n-                Collection<CategoryMetadata> cmlThis = vm.getCategoriesMetadata();\n-                for (CategoryMetadata cm : cms) {\n-                    for (CategoryMetadata cmThis : cmlThis) {\n-                        if (cm.getCategory().getId().equals(cmThis.getCategory().getId())) {\n-                            cmThis.setWfreq(cm.getWfreq());\n-                        }\n-                    }\n-                }\n-            }\n+  public String getProvFreeForm() {\n+    return provFreeForm;\n+  }\n \n-        }\n+  public void setProvFreeForm(String provFreeForm) {\n+    this.provFreeForm = provFreeForm;\n+  }\n+\n+  public void copyVariableMetadata(Collection<VariableMetadata> vml) {\n+\n+    if (variableMetadatas == null) {\n+      variableMetadatas = new ArrayList<VariableMetadata>();\n     }\n \n-    public void copyVarGroups(Collection<VarGroup> vgl) {\n-        if (varGroups != null) {\n-            varGroups.clear();\n+    for (VariableMetadata vm : vml) {\n+      VariableMetadata vmNew = null;\n+      boolean flagNew = true;\n+      for (VariableMetadata vmThis : variableMetadatas) {\n+        if (vmThis.getDataVariable().getId().equals(vm.getDataVariable().getId())) {\n+          vmNew = vmThis;\n+          flagNew = false;\n+          break;\n         }\n-\n-        for (VarGroup vg : vgl) {\n-            VarGroup vgNew = new VarGroup(this);\n-            for (DataVariable dv : vg.getVarsInGroup()) {\n-                vgNew.getVarsInGroup().add(dv);\n-            }\n-            vgNew.setLabel(vg.getLabel());\n-            if (varGroups == null) {\n-                varGroups = new ArrayList<VarGroup>();\n+      }\n+      if (flagNew) {\n+        vmNew = new VariableMetadata(vm.getDataVariable(), this);\n+      }\n+      vmNew.setIsweightvar(vm.isIsweightvar());\n+      vmNew.setWeighted(vm.isWeighted());\n+      vmNew.setWeightvariable(vm.getWeightvariable());\n+      vmNew.setInterviewinstruction(vm.getInterviewinstruction());\n+      vmNew.setLabel(vm.getLabel());\n+      vmNew.setLiteralquestion(vm.getLiteralquestion());\n+      vmNew.setNotes(vm.getNotes());\n+      vmNew.setUniverse(vm.getUniverse());\n+      vmNew.setPostquestion(vm.getPostquestion());\n+\n+      Collection<CategoryMetadata> cms = vm.getCategoriesMetadata();\n+      if (flagNew) {\n+        for (CategoryMetadata cm : cms) {\n+          CategoryMetadata cmNew = new CategoryMetadata(vmNew, cm.getCategory());\n+          cmNew.setWfreq(cm.getWfreq());\n+          vmNew.getCategoriesMetadata().add(cmNew);\n+        }\n+        variableMetadatas.add(vmNew);\n+      } else {\n+        Collection<CategoryMetadata> cmlThis = vm.getCategoriesMetadata();\n+        for (CategoryMetadata cm : cms) {\n+          for (CategoryMetadata cmThis : cmlThis) {\n+            if (cm.getCategory().getId().equals(cmThis.getCategory().getId())) {\n+              cmThis.setWfreq(cm.getWfreq());\n             }\n-            varGroups.add(vgNew);\n+          }\n         }\n+      }\n \n     }\n-    \n-    public Set<ConstraintViolation> validate() {\n-        Set<ConstraintViolation> returnSet = new HashSet<>();\n-\n-        ValidatorFactory factory = Validation.buildDefaultValidatorFactory();\n-        Validator validator = factory.getValidator();\n-        Set<ConstraintViolation<FileMetadata>> constraintViolations = validator.validate(this);\n-        if (constraintViolations.size() > 0) {\n-            // currently only support one message\n-            ConstraintViolation<FileMetadata> violation = constraintViolations.iterator().next();\n-            String message = \"Constraint violation found in FileMetadata. \"\n-                    + violation.getMessage() + \" \"\n-                    + \"The invalid value is \\\"\" + violation.getInvalidValue().toString() + \"\\\".\";\n-            logger.info(message);\n-            returnSet.add(violation);\n-        }\n+  }\n \n-        return returnSet;\n+  public void copyVarGroups(Collection<VarGroup> vgl) {\n+    if (varGroups != null) {\n+      varGroups.clear();\n     }\n-    \n+\n+    for (VarGroup vg : vgl) {\n+      VarGroup vgNew = new VarGroup(this);\n+      for (DataVariable dv : vg.getVarsInGroup()) {\n+        vgNew.getVarsInGroup().add(dv);\n+      }\n+      vgNew.setLabel(vg.getLabel());\n+      if (varGroups == null) {\n+        varGroups = new ArrayList<VarGroup>();\n+      }\n+      varGroups.add(vgNew);\n+    }\n+\n+  }\n+\n+  public Set<ConstraintViolation> validate() {\n+    Set<ConstraintViolation> returnSet = new HashSet<>();\n+\n+    ValidatorFactory factory = Validation.buildDefaultValidatorFactory();\n+    Validator validator = factory.getValidator();\n+    Set<ConstraintViolation<FileMetadata>> constraintViolations = validator.validate(this);\n+    if (constraintViolations.size() > 0) {\n+      // currently only support one message\n+      ConstraintViolation<FileMetadata> violation = constraintViolations.iterator().next();\n+      String message = \"Constraint violation found in FileMetadata. \"\n+        + violation.getMessage() + \" \"\n+        + \"The invalid value is \\\"\" + violation.getInvalidValue().toString() + \"\\\".\";\n+      logger.info(message);\n+      returnSet.add(violation);\n+    }\n+\n+    return returnSet;\n+  }\n+\n }\n",
            "diff_size": 866
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/68/FileMetadata.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_random/68/FileMetadata.java\nindex 7b0fb0fd76c..573a02ffcc1 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/68/FileMetadata.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_random/68/FileMetadata.java\n@@ -387,7 +387,7 @@ public class FileMetadata implements Serializable {\n      }\n     \n     public String getDirectFileCitation(boolean html){\n-    \treturn new DataCitation(this, true).toString(html);\n+    return new DataCitation(this, true).toString(html);\n     }\n     \n         \n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/68/FileMetadata.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_three_grams/68/FileMetadata.java\nindex 7b0fb0fd76c..98c382cf8f1 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/68/FileMetadata.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_three_grams/68/FileMetadata.java\n@@ -387,7 +387,7 @@ public class FileMetadata implements Serializable {\n      }\n     \n     public String getDirectFileCitation(boolean html){\n-    \treturn new DataCitation(this, true).toString(html);\n+        return new DataCitation(this, true).toString(html);\n     }\n     \n         \n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "naturalize",
        "codebuff"
    ]
}