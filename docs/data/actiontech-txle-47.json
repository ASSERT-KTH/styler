{
    "project_name": "actiontech-txle",
    "error_id": "47",
    "information": {
        "errors": [
            {
                "line": "42",
                "column": "1",
                "severity": "error",
                "message": "File contains tab characters (this is the first instance).",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
            }
        ]
    },
    "source_code": "\npublic class TxConsistentService {\n\tprivate static final Logger LOG = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n\n\tprivate final TxEventRepository eventRepository;\n\tprivate final CommandRepository commandRepository;",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "44",
                    "column": "1",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/errored/1/47/TxConsistentService.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/styler/47/TxConsistentService.java\nindex 0feec116172..1549c81e4dd 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/errored/1/47/TxConsistentService.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/styler/47/TxConsistentService.java\n@@ -39,7 +39,7 @@ import static org.apache.servicecomb.saga.alpha.core.TaskStatus.NEW;\n import static org.apache.servicecomb.saga.common.EventType.*;\n \n public class TxConsistentService {\n-\tprivate static final Logger LOG = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+private static final Logger LOG = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n \n \tprivate final TxEventRepository eventRepository;\n \tprivate final CommandRepository commandRepository;\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/errored/1/47/TxConsistentService.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/intellij/47/TxConsistentService.java\nindex 0feec116172..24b51d0225f 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/errored/1/47/TxConsistentService.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/intellij/47/TxConsistentService.java\n@@ -39,237 +39,237 @@ import static org.apache.servicecomb.saga.alpha.core.TaskStatus.NEW;\n import static org.apache.servicecomb.saga.common.EventType.*;\n \n public class TxConsistentService {\n-\tprivate static final Logger LOG = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n-\n-\tprivate final TxEventRepository eventRepository;\n-\tprivate final CommandRepository commandRepository;\n-\tprivate final TxTimeoutRepository timeoutRepository;\n-\n-\t@Autowired\n-\tprivate IKafkaMessageRepository kafkaMessageRepository;\n-\n-\t@Autowired\n-\tprivate TxleMetrics txleMetrics;\n-\n-\t@Autowired\n-\tprivate ITxleCache txleCache;\n-\n-\tprivate final List<String> types = Arrays.asList(TxEndedEvent.name(), TxAbortedEvent.name(), SagaEndedEvent.name());\n-\n-\tpublic TxConsistentService(TxEventRepository eventRepository, CommandRepository commandRepository, TxTimeoutRepository timeoutRepository) {\n-\t\tthis.eventRepository = eventRepository;\n-\t\tthis.commandRepository = commandRepository;\n-\t\tthis.timeoutRepository = timeoutRepository;\n-\t}\n-\n-\tpublic boolean handle(TxEvent event) {\n-\t\t// start duration.\n-\t\ttxleMetrics.startMarkTxDuration(event);\n-\t\tif (types.contains(event.type()) && isGlobalTxAborted(event)) {\n-\t\t\tLOG.info(\"Transaction event {} rejected, because its parent with globalTxId {} was already aborted\",\n-\t\t\t\t\tevent.type(), event.globalTxId());\n-\t\t\t// end duration.\n-\t\t\ttxleMetrics.endMarkTxDuration(event);\n-\t\t\treturn false;\n-\t\t}\n-\n-\t\teventRepository.save(event);\n-\t\t// end duration.\n-\t\ttxleMetrics.endMarkTxDuration(event);\n-\n-\t\treturn true;\n-\t}\n-\n-\t/**\n-\t * handle the event. support transaction pause/continue/auto-continue.\n-\t *\n-\t * @param event event for global/sub transaction\n-\t * @return result\n-\t * @author Gannalyo\n-\t */\n-\tpublic int handleSupportTxPause(TxEvent event) {\n-\t\t// start duration.\n-\t\ttxleMetrics.startMarkTxDuration(event);\n-\t\t// child transaction count\n-\t\ttxleMetrics.countChildTxNumber(event);\n-\n-\t\tString globalTxId = event.globalTxId(), localTxId = event.localTxId(), type = event.type();\n-\t\tif (!types.contains(type) && isGlobalTxAborted(event)) {\n-\t\t\tLOG.info(\"Transaction event {} rejected, because its parent with globalTxId {} was already aborted\", type, globalTxId);\n-\t\t\ttxleMetrics.countTxNumber(event, false, event.retries() > 0);\n-\t\t\t// end duration.\n-\t\t\ttxleMetrics.endMarkTxDuration(event);\n-\t\t\treturn -1;\n-\t\t}\n-\n-\t\t/**\n-\t\t * To save event only when the status of the global transaction is not paused.\n-\t\t * If not, return to client immediately, and client will do something, like sending again.\n-\t\t */\n-\t\tboolean isPaused = isGlobalTxPaused(globalTxId, type);\n-\t\tif (!isPaused) {\n-\t\t\ttry {\n-\t\t\t\tCurrentThreadContext.put(globalTxId, event);\n-\n-\t\t\t\teventRepository.save(event);\n-\n-\t\t\t\tif (TxEndedEvent.name().equals(type)) {\n-\t\t\t\t\t// There are two places for checking timeout. Here and the scheduler of the 'EventScanner' file.\n-\t\t\t\t\t// Due to they're not synchronized, hence, is's possible that global transaction is aborted here after timeout is detected by the scheduler.\n-\t\t\t\t\tif (isGlobalTxAborted(event)) {\n-\t\t\t\t\t\t// In the timeout abort case, other passed sub-transactions were compensated when the scheduler checked timeout out.\n-\t\t\t\t\t\t// Current sub-transaction need to be compensated due to it is also passed.\n-\t\t\t\t\t\t// subA ok, timeout, compensate subA, subB ok without exception(need to save ended even though aborted), compensate subB.\n-\t\t\t\t\t\tcommandRepository.saveWillCompensateCmdForCurSubTx(globalTxId, localTxId);\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\t// If not aborted, here have to check timeout again to avoid the latency of the timeout scheduler.\n-\t\t\t\t\t\tTxEvent unhandleTimeoutEvent = eventRepository.findTimeoutEventsBeforeEnding(globalTxId);\n-\t\t\t\t\t\tif (unhandleTimeoutEvent != null) {\n-\t\t\t\t\t\t\tTxTimeout txTimeout = txTimeoutOf(unhandleTimeoutEvent);\n-\t\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\t\tLOG.debug(\"TxConsistentService Detected the Timeout {}.\", txTimeout);\n-\t\t\t\t\t\t\t\ttimeoutRepository.save(txTimeout);\n-\t\t\t\t\t\t\t\tTxEvent abortedEvent = toTxAbortedEvent(txTimeout);\n-\t\t\t\t\t\t\t\tif (!eventRepository.checkIsExistsEventType(globalTxId, localTxId, abortedEvent.type())) {\n-\t\t\t\t\t\t\t\t\teventRepository.save(abortedEvent);\n-\t\t\t\t\t\t\t\t\ttxleCache.putDistributedTxAbortStatusCache(globalTxId, true, 2);\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t} catch (Exception e) {\n-\t\t\t\t\t\t\t\tLOG.error(\"Failed to save timeout {} in method 'TxConsistentService.handleSupportTxPause()'.\", txTimeout, e);\n-\t\t\t\t\t\t\t} finally {\n-\t\t\t\t\t\t\t\tcommandRepository.saveWillCompensateCommandsForTimeout(globalTxId);\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\tif (TxAbortedEvent.name().equals(type)) {\n-\t\t\t\t\t// To verify eventually abort (exclude some abort events which retried successfully).\n-\t\t\t\t\tif (globalTxId.equals(localTxId) || eventRepository.checkTxIsAborted(globalTxId, localTxId)) {\n-\t\t\t\t\t\ttxleCache.putDistributedTxAbortStatusCache(globalTxId, true, 2);\n-\t\t\t\t\t\tif (!globalTxId.equals(localTxId)) {\n-\t\t\t\t\t\t\tcommandRepository.saveWillCompensateCommandsForException(globalTxId, localTxId);\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tcommandRepository.saveWillCompensateCommandsWhenGlobalTxAborted(globalTxId);\n-\t\t\t\t\t\t\tTxEvent sagaEndedEvent = new TxEvent(event.serviceName(), event.instanceId(), globalTxId, globalTxId, null, SagaEndedEvent.name(), \"\", event.category(), new byte[0]);\n-\t\t\t\t\t\t\teventRepository.save(sagaEndedEvent);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t} catch (Exception e) {\n-\t\t\t\tLOG.error(\"Failed to save event globalTxId {} localTxId {} type {}\", globalTxId, localTxId, type, e);\n-\t\t\t} finally {\n-\t\t\t\ttxleMetrics.countTxNumber(event, false, event.retries() > 0);\n-\t\t\t\t// end duration.\n-\t\t\t\ttxleMetrics.endMarkTxDuration(event);\n-\t\t\t}\n-\n-\t\t\treturn 1;\n-\t\t}\n-\n-\t\ttxleMetrics.endMarkTxDuration(event);\n-\n-\t\treturn 0;\n-\t}\n-\n-\tprivate boolean isGlobalTxAborted(TxEvent event) {\n-\t\tif (SagaStartedEvent.name().equals(event.type())) {\n-\t\t\treturn false;\n-\t\t}\n-\t\treturn txleCache.getTxAbortStatus(event.globalTxId());\n-\t}\n-\n-\tpublic boolean isGlobalTxPaused(String globalTxId, String type) {\n-\t\tif (SagaEndedEvent.name().equals(type)) {\n-\t\t\treturn false;\n-\t\t}\n-\t\tboolean isPaused = false;\n-\t\ttry {\n-\t\t\tfinal String pauseAllGlobalTxKey = TxleConstants.constructConfigCacheKey(null, null, ConfigCenterType.PauseGlobalTx.toInteger());\n-\t\t\tif (txleCache.getConfigCache().getOrDefault(pauseAllGlobalTxKey, false)) {\n-\t\t\t\t// paused all global transactions.\n-\t\t\t\treturn true;\n-\t\t\t}\n-\n-\t\t\tif (!txleCache.getTxSuspendStatus(globalTxId)) {\n-\t\t\t\t// return false directly if it's not suspended.\n-\t\t\t\treturn false;\n-\t\t\t} else {\n-\t\t\t\t// It's unusual to pause global transaction. So, just search the list of transaction type first for saving performance.\n-\t\t\t\tList<String> typeList = eventRepository.selectAllTypeByGlobalTxId(globalTxId);\n-\t\t\t\tif (typeList == null || typeList.isEmpty()) {\n-\t\t\t\t\treturn false;\n-\t\t\t\t}\n-\n-\t\t\t\tAtomicBoolean isContainPauseEvent = new AtomicBoolean(false);\n-\t\t\t\ttypeList.forEach(t -> {\n-\t\t\t\t\tif (AdditionalEventType.SagaPausedEvent.name().equals(t) || AdditionalEventType.SagaAutoContinuedEvent.name().equals(t)) {\n-\t\t\t\t\t\tisContainPauseEvent.set(true);\n-\t\t\t\t\t}\n-\t\t\t\t});\n-\t\t\t\tif (!isContainPauseEvent.get()) {\n-\t\t\t\t\treturn false;\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t// If paused, continue to verify the expire for auto-recovery\n-\t\t\tList<TxEvent> pauseContinueEventList = eventRepository.selectPausedAndContinueEvent(globalTxId);\n-\t\t\tif (pauseContinueEventList != null && !pauseContinueEventList.isEmpty()) {\n-\t\t\t\tTxEvent event = pauseContinueEventList.get(0);\n-\t\t\t\tif (event != null && AdditionalEventType.SagaAutoContinuedEvent.name().equals(event.type())) {\n-\t\t\t\t\tisPaused = true;\n-\t\t\t\t\tif (event.expiryTime().compareTo(new Date()) < 1) {\n-\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\t// was due, create the event 'SagaAutoContinueEvent' to make event to continue running.\n-\t\t\t\t\t\t\teventRepository.save(new TxEvent(event.serviceName(), event.instanceId(), event.globalTxId(), event.localTxId(), event.parentTxId(),\n-\t\t\t\t\t\t\t\t\tAdditionalEventType.SagaAutoContinuedEvent.name(), \"\", 0, \"\", 0, event.category(), event.payloads()));\n-\t\t\t\t\t\t\tisPaused = false;\n-\t\t\t\t\t\t} catch (Exception e) {\n-\t\t\t\t\t\t\tisPaused = true;\n-\t\t\t\t\t\t\tLOG.error(\"Fail to save the event 'SagaAutoContinuedEvent'.\", e);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t} catch (Exception e) {\n-\t\t\tLOG.error(\"Fail to execute the method 'isGlobalTxPaused'.\", e);\n-\t\t}\n-\t\treturn isPaused;\n-\t}\n-\n-\tpublic Set<String> fetchLocalTxIdOfEndedGlobalTx(Set<String> localTxIdSet) {\n-\t\treturn eventRepository.selectEndedGlobalTx(localTxIdSet);\n-\t}\n-\n-\tpublic boolean saveKafkaMessage(KafkaMessage message) {\n-\t\treturn kafkaMessageRepository.save(message);\n-\t}\n-\n-\tprivate TxTimeout txTimeoutOf(TxEvent event) {\n-\t\treturn new TxTimeout(\n-\t\t\t\tevent.id(),\n-\t\t\t\tevent.serviceName(),\n-\t\t\t\tevent.instanceId(),\n-\t\t\t\tevent.globalTxId(),\n-\t\t\t\tevent.localTxId(),\n-\t\t\t\tevent.parentTxId(),\n-\t\t\t\tevent.type(),\n-\t\t\t\tevent.expiryTime(),\n-\t\t\t\tNEW.name(),\n-\t\t\t\tevent.category()\n-\t\t);\n-\t}\n-\n-\tprivate TxEvent toTxAbortedEvent(TxTimeout timeout) {\n-\t\treturn new TxEvent(\n-\t\t\t\ttimeout.serviceName(),\n-\t\t\t\ttimeout.instanceId(),\n-\t\t\t\ttimeout.globalTxId(),\n-\t\t\t\ttimeout.localTxId(),\n-\t\t\t\ttimeout.parentTxId(),\n-\t\t\t\tTxAbortedEvent.name(),\n-\t\t\t\t\"\",\n-\t\t\t\ttimeout.category(),\n-\t\t\t\t(\"Transaction timeout\").getBytes());\n-\t}\n+    private static final Logger LOG = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private final TxEventRepository eventRepository;\n+    private final CommandRepository commandRepository;\n+    private final TxTimeoutRepository timeoutRepository;\n+\n+    @Autowired\n+    private IKafkaMessageRepository kafkaMessageRepository;\n+\n+    @Autowired\n+    private TxleMetrics txleMetrics;\n+\n+    @Autowired\n+    private ITxleCache txleCache;\n+\n+    private final List<String> types = Arrays.asList(TxEndedEvent.name(), TxAbortedEvent.name(), SagaEndedEvent.name());\n+\n+    public TxConsistentService(TxEventRepository eventRepository, CommandRepository commandRepository, TxTimeoutRepository timeoutRepository) {\n+        this.eventRepository = eventRepository;\n+        this.commandRepository = commandRepository;\n+        this.timeoutRepository = timeoutRepository;\n+    }\n+\n+    public boolean handle(TxEvent event) {\n+        // start duration.\n+        txleMetrics.startMarkTxDuration(event);\n+        if (types.contains(event.type()) && isGlobalTxAborted(event)) {\n+            LOG.info(\"Transaction event {} rejected, because its parent with globalTxId {} was already aborted\",\n+                    event.type(), event.globalTxId());\n+            // end duration.\n+            txleMetrics.endMarkTxDuration(event);\n+            return false;\n+        }\n+\n+        eventRepository.save(event);\n+        // end duration.\n+        txleMetrics.endMarkTxDuration(event);\n+\n+        return true;\n+    }\n+\n+    /**\n+     * handle the event. support transaction pause/continue/auto-continue.\n+     *\n+     * @param event event for global/sub transaction\n+     * @return result\n+     * @author Gannalyo\n+     */\n+    public int handleSupportTxPause(TxEvent event) {\n+        // start duration.\n+        txleMetrics.startMarkTxDuration(event);\n+        // child transaction count\n+        txleMetrics.countChildTxNumber(event);\n+\n+        String globalTxId = event.globalTxId(), localTxId = event.localTxId(), type = event.type();\n+        if (!types.contains(type) && isGlobalTxAborted(event)) {\n+            LOG.info(\"Transaction event {} rejected, because its parent with globalTxId {} was already aborted\", type, globalTxId);\n+            txleMetrics.countTxNumber(event, false, event.retries() > 0);\n+            // end duration.\n+            txleMetrics.endMarkTxDuration(event);\n+            return -1;\n+        }\n+\n+        /**\n+         * To save event only when the status of the global transaction is not paused.\n+         * If not, return to client immediately, and client will do something, like sending again.\n+         */\n+        boolean isPaused = isGlobalTxPaused(globalTxId, type);\n+        if (!isPaused) {\n+            try {\n+                CurrentThreadContext.put(globalTxId, event);\n+\n+                eventRepository.save(event);\n+\n+                if (TxEndedEvent.name().equals(type)) {\n+                    // There are two places for checking timeout. Here and the scheduler of the 'EventScanner' file.\n+                    // Due to they're not synchronized, hence, is's possible that global transaction is aborted here after timeout is detected by the scheduler.\n+                    if (isGlobalTxAborted(event)) {\n+                        // In the timeout abort case, other passed sub-transactions were compensated when the scheduler checked timeout out.\n+                        // Current sub-transaction need to be compensated due to it is also passed.\n+                        // subA ok, timeout, compensate subA, subB ok without exception(need to save ended even though aborted), compensate subB.\n+                        commandRepository.saveWillCompensateCmdForCurSubTx(globalTxId, localTxId);\n+                    } else {\n+                        // If not aborted, here have to check timeout again to avoid the latency of the timeout scheduler.\n+                        TxEvent unhandleTimeoutEvent = eventRepository.findTimeoutEventsBeforeEnding(globalTxId);\n+                        if (unhandleTimeoutEvent != null) {\n+                            TxTimeout txTimeout = txTimeoutOf(unhandleTimeoutEvent);\n+                            try {\n+                                LOG.debug(\"TxConsistentService Detected the Timeout {}.\", txTimeout);\n+                                timeoutRepository.save(txTimeout);\n+                                TxEvent abortedEvent = toTxAbortedEvent(txTimeout);\n+                                if (!eventRepository.checkIsExistsEventType(globalTxId, localTxId, abortedEvent.type())) {\n+                                    eventRepository.save(abortedEvent);\n+                                    txleCache.putDistributedTxAbortStatusCache(globalTxId, true, 2);\n+                                }\n+                            } catch (Exception e) {\n+                                LOG.error(\"Failed to save timeout {} in method 'TxConsistentService.handleSupportTxPause()'.\", txTimeout, e);\n+                            } finally {\n+                                commandRepository.saveWillCompensateCommandsForTimeout(globalTxId);\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                if (TxAbortedEvent.name().equals(type)) {\n+                    // To verify eventually abort (exclude some abort events which retried successfully).\n+                    if (globalTxId.equals(localTxId) || eventRepository.checkTxIsAborted(globalTxId, localTxId)) {\n+                        txleCache.putDistributedTxAbortStatusCache(globalTxId, true, 2);\n+                        if (!globalTxId.equals(localTxId)) {\n+                            commandRepository.saveWillCompensateCommandsForException(globalTxId, localTxId);\n+                        } else {\n+                            commandRepository.saveWillCompensateCommandsWhenGlobalTxAborted(globalTxId);\n+                            TxEvent sagaEndedEvent = new TxEvent(event.serviceName(), event.instanceId(), globalTxId, globalTxId, null, SagaEndedEvent.name(), \"\", event.category(), new byte[0]);\n+                            eventRepository.save(sagaEndedEvent);\n+                        }\n+                    }\n+                }\n+            } catch (Exception e) {\n+                LOG.error(\"Failed to save event globalTxId {} localTxId {} type {}\", globalTxId, localTxId, type, e);\n+            } finally {\n+                txleMetrics.countTxNumber(event, false, event.retries() > 0);\n+                // end duration.\n+                txleMetrics.endMarkTxDuration(event);\n+            }\n+\n+            return 1;\n+        }\n+\n+        txleMetrics.endMarkTxDuration(event);\n+\n+        return 0;\n+    }\n+\n+    private boolean isGlobalTxAborted(TxEvent event) {\n+        if (SagaStartedEvent.name().equals(event.type())) {\n+            return false;\n+        }\n+        return txleCache.getTxAbortStatus(event.globalTxId());\n+    }\n+\n+    public boolean isGlobalTxPaused(String globalTxId, String type) {\n+        if (SagaEndedEvent.name().equals(type)) {\n+            return false;\n+        }\n+        boolean isPaused = false;\n+        try {\n+            final String pauseAllGlobalTxKey = TxleConstants.constructConfigCacheKey(null, null, ConfigCenterType.PauseGlobalTx.toInteger());\n+            if (txleCache.getConfigCache().getOrDefault(pauseAllGlobalTxKey, false)) {\n+                // paused all global transactions.\n+                return true;\n+            }\n+\n+            if (!txleCache.getTxSuspendStatus(globalTxId)) {\n+                // return false directly if it's not suspended.\n+                return false;\n+            } else {\n+                // It's unusual to pause global transaction. So, just search the list of transaction type first for saving performance.\n+                List<String> typeList = eventRepository.selectAllTypeByGlobalTxId(globalTxId);\n+                if (typeList == null || typeList.isEmpty()) {\n+                    return false;\n+                }\n+\n+                AtomicBoolean isContainPauseEvent = new AtomicBoolean(false);\n+                typeList.forEach(t -> {\n+                    if (AdditionalEventType.SagaPausedEvent.name().equals(t) || AdditionalEventType.SagaAutoContinuedEvent.name().equals(t)) {\n+                        isContainPauseEvent.set(true);\n+                    }\n+                });\n+                if (!isContainPauseEvent.get()) {\n+                    return false;\n+                }\n+            }\n+\n+            // If paused, continue to verify the expire for auto-recovery\n+            List<TxEvent> pauseContinueEventList = eventRepository.selectPausedAndContinueEvent(globalTxId);\n+            if (pauseContinueEventList != null && !pauseContinueEventList.isEmpty()) {\n+                TxEvent event = pauseContinueEventList.get(0);\n+                if (event != null && AdditionalEventType.SagaAutoContinuedEvent.name().equals(event.type())) {\n+                    isPaused = true;\n+                    if (event.expiryTime().compareTo(new Date()) < 1) {\n+                        try {\n+                            // was due, create the event 'SagaAutoContinueEvent' to make event to continue running.\n+                            eventRepository.save(new TxEvent(event.serviceName(), event.instanceId(), event.globalTxId(), event.localTxId(), event.parentTxId(),\n+                                    AdditionalEventType.SagaAutoContinuedEvent.name(), \"\", 0, \"\", 0, event.category(), event.payloads()));\n+                            isPaused = false;\n+                        } catch (Exception e) {\n+                            isPaused = true;\n+                            LOG.error(\"Fail to save the event 'SagaAutoContinuedEvent'.\", e);\n+                        }\n+                    }\n+                }\n+            }\n+        } catch (Exception e) {\n+            LOG.error(\"Fail to execute the method 'isGlobalTxPaused'.\", e);\n+        }\n+        return isPaused;\n+    }\n+\n+    public Set<String> fetchLocalTxIdOfEndedGlobalTx(Set<String> localTxIdSet) {\n+        return eventRepository.selectEndedGlobalTx(localTxIdSet);\n+    }\n+\n+    public boolean saveKafkaMessage(KafkaMessage message) {\n+        return kafkaMessageRepository.save(message);\n+    }\n+\n+    private TxTimeout txTimeoutOf(TxEvent event) {\n+        return new TxTimeout(\n+                event.id(),\n+                event.serviceName(),\n+                event.instanceId(),\n+                event.globalTxId(),\n+                event.localTxId(),\n+                event.parentTxId(),\n+                event.type(),\n+                event.expiryTime(),\n+                NEW.name(),\n+                event.category()\n+        );\n+    }\n+\n+    private TxEvent toTxAbortedEvent(TxTimeout timeout) {\n+        return new TxEvent(\n+                timeout.serviceName(),\n+                timeout.instanceId(),\n+                timeout.globalTxId(),\n+                timeout.localTxId(),\n+                timeout.parentTxId(),\n+                TxAbortedEvent.name(),\n+                \"\",\n+                timeout.category(),\n+                (\"Transaction timeout\").getBytes());\n+    }\n }\n",
            "diff_size": 233
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "44",
                    "column": "1",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/errored/1/47/TxConsistentService.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/naturalize/47/TxConsistentService.java\nindex 0feec116172..5bfde286311 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/errored/1/47/TxConsistentService.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/naturalize/47/TxConsistentService.java\n@@ -39,7 +39,7 @@ import static org.apache.servicecomb.saga.alpha.core.TaskStatus.NEW;\n import static org.apache.servicecomb.saga.common.EventType.*;\n \n public class TxConsistentService {\n-\tprivate static final Logger LOG = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+    private static final Logger LOG = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n \n \tprivate final TxEventRepository eventRepository;\n \tprivate final CommandRepository commandRepository;\n@@ -57,28 +57,28 @@ public class TxConsistentService {\n \tprivate final List<String> types = Arrays.asList(TxEndedEvent.name(), TxAbortedEvent.name(), SagaEndedEvent.name());\n \n \tpublic TxConsistentService(TxEventRepository eventRepository, CommandRepository commandRepository, TxTimeoutRepository timeoutRepository) {\n-\t\tthis.eventRepository = eventRepository;\n+    this.eventRepository = eventRepository;\n \t\tthis.commandRepository = commandRepository;\n \t\tthis.timeoutRepository = timeoutRepository;\n-\t}\n+    }\n \n \tpublic boolean handle(TxEvent event) {\n-\t\t// start duration.\n+    // start duration.\n \t\ttxleMetrics.startMarkTxDuration(event);\n \t\tif (types.contains(event.type()) && isGlobalTxAborted(event)) {\n-\t\t\tLOG.info(\"Transaction event {} rejected, because its parent with globalTxId {} was already aborted\",\n-\t\t\t\t\tevent.type(), event.globalTxId());\n-\t\t\t// end duration.\n+    LOG.info(\"Transaction event {} rejected, because its parent with globalTxId {} was already aborted\", event.type(), event.globalTxId());\n+\n+// end duration.\n \t\t\ttxleMetrics.endMarkTxDuration(event);\n \t\t\treturn false;\n-\t\t}\n+    }\n \n \t\teventRepository.save(event);\n \t\t// end duration.\n \t\ttxleMetrics.endMarkTxDuration(event);\n \n \t\treturn true;\n-\t}\n+    }\n \n \t/**\n \t * handle the event. support transaction pause/continue/auto-continue.\n@@ -88,19 +88,19 @@ public class TxConsistentService {\n \t * @author Gannalyo\n \t */\n \tpublic int handleSupportTxPause(TxEvent event) {\n-\t\t// start duration.\n+    // start duration.\n \t\ttxleMetrics.startMarkTxDuration(event);\n \t\t// child transaction count\n \t\ttxleMetrics.countChildTxNumber(event);\n \n \t\tString globalTxId = event.globalTxId(), localTxId = event.localTxId(), type = event.type();\n \t\tif (!types.contains(type) && isGlobalTxAborted(event)) {\n-\t\t\tLOG.info(\"Transaction event {} rejected, because its parent with globalTxId {} was already aborted\", type, globalTxId);\n+    LOG.info(\"Transaction event {} rejected, because its parent with globalTxId {} was already aborted\", type, globalTxId);\n \t\t\ttxleMetrics.countTxNumber(event, false, event.retries() > 0);\n \t\t\t// end duration.\n \t\t\ttxleMetrics.endMarkTxDuration(event);\n \t\t\treturn -1;\n-\t\t}\n+    }\n \n \t\t/**\n \t\t * To save event only when the status of the global transaction is not paused.\n@@ -108,146 +108,144 @@ public class TxConsistentService {\n \t\t */\n \t\tboolean isPaused = isGlobalTxPaused(globalTxId, type);\n \t\tif (!isPaused) {\n-\t\t\ttry {\n-\t\t\t\tCurrentThreadContext.put(globalTxId, event);\n+    try {\n+    CurrentThreadContext.put(globalTxId, event);\n \n \t\t\t\teventRepository.save(event);\n \n \t\t\t\tif (TxEndedEvent.name().equals(type)) {\n-\t\t\t\t\t// There are two places for checking timeout. Here and the scheduler of the 'EventScanner' file.\n+    // There are two places for checking timeout. Here and the scheduler of the 'EventScanner' file.\n \t\t\t\t\t// Due to they're not synchronized, hence, is's possible that global transaction is aborted here after timeout is detected by the scheduler.\n \t\t\t\t\tif (isGlobalTxAborted(event)) {\n-\t\t\t\t\t\t// In the timeout abort case, other passed sub-transactions were compensated when the scheduler checked timeout out.\n+    // In the timeout abort case, other passed sub-transactions were compensated when the scheduler checked timeout out.\n \t\t\t\t\t\t// Current sub-transaction need to be compensated due to it is also passed.\n \t\t\t\t\t\t// subA ok, timeout, compensate subA, subB ok without exception(need to save ended even though aborted), compensate subB.\n \t\t\t\t\t\tcommandRepository.saveWillCompensateCmdForCurSubTx(globalTxId, localTxId);\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\t// If not aborted, here have to check timeout again to avoid the latency of the timeout scheduler.\n+    } else {\n+    // If not aborted, here have to check timeout again to avoid the latency of the timeout scheduler.\n \t\t\t\t\t\tTxEvent unhandleTimeoutEvent = eventRepository.findTimeoutEventsBeforeEnding(globalTxId);\n \t\t\t\t\t\tif (unhandleTimeoutEvent != null) {\n-\t\t\t\t\t\t\tTxTimeout txTimeout = txTimeoutOf(unhandleTimeoutEvent);\n+    TxTimeout txTimeout = txTimeoutOf(unhandleTimeoutEvent);\n \t\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\t\tLOG.debug(\"TxConsistentService Detected the Timeout {}.\", txTimeout);\n+    LOG.debug(\"TxConsistentService Detected the Timeout {}.\", txTimeout);\n \t\t\t\t\t\t\t\ttimeoutRepository.save(txTimeout);\n \t\t\t\t\t\t\t\tTxEvent abortedEvent = toTxAbortedEvent(txTimeout);\n \t\t\t\t\t\t\t\tif (!eventRepository.checkIsExistsEventType(globalTxId, localTxId, abortedEvent.type())) {\n-\t\t\t\t\t\t\t\t\teventRepository.save(abortedEvent);\n+    eventRepository.save(abortedEvent);\n \t\t\t\t\t\t\t\t\ttxleCache.putDistributedTxAbortStatusCache(globalTxId, true, 2);\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t} catch (Exception e) {\n-\t\t\t\t\t\t\t\tLOG.error(\"Failed to save timeout {} in method 'TxConsistentService.handleSupportTxPause()'.\", txTimeout, e);\n-\t\t\t\t\t\t\t} finally {\n-\t\t\t\t\t\t\t\tcommandRepository.saveWillCompensateCommandsForTimeout(globalTxId);\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n+    }\n+    } catch (Exception e) {\n+    LOG.error(\"Failed to save timeout {} in method 'TxConsistentService.handleSupportTxPause()'.\", txTimeout, e);\n+    } finally {\n+    commandRepository.saveWillCompensateCommandsForTimeout(globalTxId);\n+    }\n+    }\n+    }\n+    }\n \n \t\t\t\tif (TxAbortedEvent.name().equals(type)) {\n-\t\t\t\t\t// To verify eventually abort (exclude some abort events which retried successfully).\n+    // To verify eventually abort (exclude some abort events which retried successfully).\n \t\t\t\t\tif (globalTxId.equals(localTxId) || eventRepository.checkTxIsAborted(globalTxId, localTxId)) {\n-\t\t\t\t\t\ttxleCache.putDistributedTxAbortStatusCache(globalTxId, true, 2);\n+    txleCache.putDistributedTxAbortStatusCache(globalTxId, true, 2);\n \t\t\t\t\t\tif (!globalTxId.equals(localTxId)) {\n-\t\t\t\t\t\t\tcommandRepository.saveWillCompensateCommandsForException(globalTxId, localTxId);\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tcommandRepository.saveWillCompensateCommandsWhenGlobalTxAborted(globalTxId);\n+    commandRepository.saveWillCompensateCommandsForException(globalTxId, localTxId);\n+    } else {\n+    commandRepository.saveWillCompensateCommandsWhenGlobalTxAborted(globalTxId);\n \t\t\t\t\t\t\tTxEvent sagaEndedEvent = new TxEvent(event.serviceName(), event.instanceId(), globalTxId, globalTxId, null, SagaEndedEvent.name(), \"\", event.category(), new byte[0]);\n \t\t\t\t\t\t\teventRepository.save(sagaEndedEvent);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t} catch (Exception e) {\n-\t\t\t\tLOG.error(\"Failed to save event globalTxId {} localTxId {} type {}\", globalTxId, localTxId, type, e);\n-\t\t\t} finally {\n-\t\t\t\ttxleMetrics.countTxNumber(event, false, event.retries() > 0);\n+    }\n+    }\n+    }\n+    } catch (Exception e) {\n+    LOG.error(\"Failed to save event globalTxId {} localTxId {} type {}\", globalTxId, localTxId, type, e);\n+    } finally {\n+    txleMetrics.countTxNumber(event, false, event.retries() > 0);\n \t\t\t\t// end duration.\n \t\t\t\ttxleMetrics.endMarkTxDuration(event);\n-\t\t\t}\n+    }\n \n \t\t\treturn 1;\n-\t\t}\n+    }\n \n \t\ttxleMetrics.endMarkTxDuration(event);\n \n \t\treturn 0;\n-\t}\n+          }\n \n \tprivate boolean isGlobalTxAborted(TxEvent event) {\n-\t\tif (SagaStartedEvent.name().equals(event.type())) {\n-\t\t\treturn false;\n-\t\t}\n+    if (SagaStartedEvent.name().equals(event.type())) {\n+    return false;\n+    }\n \t\treturn txleCache.getTxAbortStatus(event.globalTxId());\n-\t}\n+    }\n \n \tpublic boolean isGlobalTxPaused(String globalTxId, String type) {\n-\t\tif (SagaEndedEvent.name().equals(type)) {\n-\t\t\treturn false;\n-\t\t}\n+    if (SagaEndedEvent.name().equals(type)) {\n+    return false;\n+    }\n \t\tboolean isPaused = false;\n \t\ttry {\n-\t\t\tfinal String pauseAllGlobalTxKey = TxleConstants.constructConfigCacheKey(null, null, ConfigCenterType.PauseGlobalTx.toInteger());\n+    final String pauseAllGlobalTxKey = TxleConstants.constructConfigCacheKey(null, null, ConfigCenterType.PauseGlobalTx.toInteger());\n \t\t\tif (txleCache.getConfigCache().getOrDefault(pauseAllGlobalTxKey, false)) {\n-\t\t\t\t// paused all global transactions.\n+    // paused all global transactions.\n \t\t\t\treturn true;\n-\t\t\t}\n+    }\n \n \t\t\tif (!txleCache.getTxSuspendStatus(globalTxId)) {\n-\t\t\t\t// return false directly if it's not suspended.\n+    // return false directly if it's not suspended.\n \t\t\t\treturn false;\n-\t\t\t} else {\n-\t\t\t\t// It's unusual to pause global transaction. So, just search the list of transaction type first for saving performance.\n+    } else {\n+    // It's unusual to pause global transaction. So, just search the list of transaction type first for saving performance.\n \t\t\t\tList<String> typeList = eventRepository.selectAllTypeByGlobalTxId(globalTxId);\n \t\t\t\tif (typeList == null || typeList.isEmpty()) {\n-\t\t\t\t\treturn false;\n-\t\t\t\t}\n+    return false;\n+    }\n \n \t\t\t\tAtomicBoolean isContainPauseEvent = new AtomicBoolean(false);\n \t\t\t\ttypeList.forEach(t -> {\n-\t\t\t\t\tif (AdditionalEventType.SagaPausedEvent.name().equals(t) || AdditionalEventType.SagaAutoContinuedEvent.name().equals(t)) {\n-\t\t\t\t\t\tisContainPauseEvent.set(true);\n-\t\t\t\t\t}\n-\t\t\t\t});\n+    if (AdditionalEventType.SagaPausedEvent.name().equals(t) || AdditionalEventType.SagaAutoContinuedEvent.name().equals(t)) {\n+    isContainPauseEvent.set(true);\n+    }\n+    });\n \t\t\t\tif (!isContainPauseEvent.get()) {\n-\t\t\t\t\treturn false;\n-\t\t\t\t}\n-\t\t\t}\n+    return false;\n+    }\n+    }\n \n \t\t\t// If paused, continue to verify the expire for auto-recovery\n \t\t\tList<TxEvent> pauseContinueEventList = eventRepository.selectPausedAndContinueEvent(globalTxId);\n \t\t\tif (pauseContinueEventList != null && !pauseContinueEventList.isEmpty()) {\n-\t\t\t\tTxEvent event = pauseContinueEventList.get(0);\n+    TxEvent event = pauseContinueEventList.get(0);\n \t\t\t\tif (event != null && AdditionalEventType.SagaAutoContinuedEvent.name().equals(event.type())) {\n-\t\t\t\t\tisPaused = true;\n+    isPaused = true;\n \t\t\t\t\tif (event.expiryTime().compareTo(new Date()) < 1) {\n-\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\t// was due, create the event 'SagaAutoContinueEvent' to make event to continue running.\n-\t\t\t\t\t\t\teventRepository.save(new TxEvent(event.serviceName(), event.instanceId(), event.globalTxId(), event.localTxId(), event.parentTxId(),\n-\t\t\t\t\t\t\t\t\tAdditionalEventType.SagaAutoContinuedEvent.name(), \"\", 0, \"\", 0, event.category(), event.payloads()));\n-\t\t\t\t\t\t\tisPaused = false;\n-\t\t\t\t\t\t} catch (Exception e) {\n-\t\t\t\t\t\t\tisPaused = true;\n+    try {\n+    // was due, create the event 'SagaAutoContinueEvent' to make event to continue running.\n+\t\t\t\t\t\t\teventRepository.save(new TxEvent(event.serviceName(), event.instanceId(), event.globalTxId(), event.localTxId(), event.parentTxId(), AdditionalEventType.SagaAutoContinuedEvent.name(), \"\", 0, \"\", 0, event.category(), event.payloads()));\n+isPaused = false;\n+    } catch (Exception e) {\n+    isPaused = true;\n \t\t\t\t\t\t\tLOG.error(\"Fail to save the event 'SagaAutoContinuedEvent'.\", e);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t} catch (Exception e) {\n-\t\t\tLOG.error(\"Fail to execute the method 'isGlobalTxPaused'.\", e);\n-\t\t}\n+    }\n+    }\n+    }\n+    }\n+    } catch (Exception e) {\n+    LOG.error(\"Fail to execute the method 'isGlobalTxPaused'.\", e);\n+    }\n \t\treturn isPaused;\n-\t}\n+    }\n \n \tpublic Set<String> fetchLocalTxIdOfEndedGlobalTx(Set<String> localTxIdSet) {\n-\t\treturn eventRepository.selectEndedGlobalTx(localTxIdSet);\n-\t}\n+    return eventRepository.selectEndedGlobalTx(localTxIdSet);\n+    }\n \n \tpublic boolean saveKafkaMessage(KafkaMessage message) {\n-\t\treturn kafkaMessageRepository.save(message);\n-\t}\n+    return kafkaMessageRepository.save(message);\n+    }\n \n \tprivate TxTimeout txTimeoutOf(TxEvent event) {\n-\t\treturn new TxTimeout(\n-\t\t\t\tevent.id(),\n+  return new TxTimeout(event.id(),\n \t\t\t\tevent.serviceName(),\n \t\t\t\tevent.instanceId(),\n \t\t\t\tevent.globalTxId(),\n@@ -256,13 +254,11 @@ public class TxConsistentService {\n \t\t\t\tevent.type(),\n \t\t\t\tevent.expiryTime(),\n \t\t\t\tNEW.name(),\n-\t\t\t\tevent.category()\n-\t\t);\n-\t}\n+\t\t\t\tevent.category());\n+    }\n \n \tprivate TxEvent toTxAbortedEvent(TxTimeout timeout) {\n-\t\treturn new TxEvent(\n-\t\t\t\ttimeout.serviceName(),\n+  return new TxEvent(timeout.serviceName(),\n \t\t\t\ttimeout.instanceId(),\n \t\t\t\ttimeout.globalTxId(),\n \t\t\t\ttimeout.localTxId(),\n@@ -271,5 +267,5 @@ public class TxConsistentService {\n \t\t\t\t\"\",\n \t\t\t\ttimeout.category(),\n \t\t\t\t(\"Transaction timeout\").getBytes());\n-\t}\n-}\n+    }\n+    }\n\\ No newline at end of file\n",
            "diff_size": 97
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/errored/1/47/TxConsistentService.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/codebuff/47/TxConsistentService.java\nindex 0feec116172..bc5a3dd542c 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/errored/1/47/TxConsistentService.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/codebuff/47/TxConsistentService.java\n@@ -27,7 +27,6 @@ import org.apache.servicecomb.saga.common.TxleConstants;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.springframework.beans.factory.annotation.Autowired;\n-\n import java.lang.invoke.MethodHandles;\n import java.util.Arrays;\n import java.util.Date;\n@@ -38,238 +37,217 @@ import java.util.concurrent.atomic.AtomicBoolean;\n import static org.apache.servicecomb.saga.alpha.core.TaskStatus.NEW;\n import static org.apache.servicecomb.saga.common.EventType.*;\n \n-public class TxConsistentService {\n-\tprivate static final Logger LOG = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n-\n-\tprivate final TxEventRepository eventRepository;\n-\tprivate final CommandRepository commandRepository;\n-\tprivate final TxTimeoutRepository timeoutRepository;\n-\n-\t@Autowired\n-\tprivate IKafkaMessageRepository kafkaMessageRepository;\n-\n-\t@Autowired\n-\tprivate TxleMetrics txleMetrics;\n-\n-\t@Autowired\n-\tprivate ITxleCache txleCache;\n-\n-\tprivate final List<String> types = Arrays.asList(TxEndedEvent.name(), TxAbortedEvent.name(), SagaEndedEvent.name());\n-\n-\tpublic TxConsistentService(TxEventRepository eventRepository, CommandRepository commandRepository, TxTimeoutRepository timeoutRepository) {\n-\t\tthis.eventRepository = eventRepository;\n-\t\tthis.commandRepository = commandRepository;\n-\t\tthis.timeoutRepository = timeoutRepository;\n-\t}\n-\n-\tpublic boolean handle(TxEvent event) {\n-\t\t// start duration.\n-\t\ttxleMetrics.startMarkTxDuration(event);\n-\t\tif (types.contains(event.type()) && isGlobalTxAborted(event)) {\n-\t\t\tLOG.info(\"Transaction event {} rejected, because its parent with globalTxId {} was already aborted\",\n-\t\t\t\t\tevent.type(), event.globalTxId());\n-\t\t\t// end duration.\n-\t\t\ttxleMetrics.endMarkTxDuration(event);\n-\t\t\treturn false;\n-\t\t}\n-\n-\t\teventRepository.save(event);\n-\t\t// end duration.\n-\t\ttxleMetrics.endMarkTxDuration(event);\n-\n-\t\treturn true;\n-\t}\n-\n-\t/**\n-\t * handle the event. support transaction pause/continue/auto-continue.\n-\t *\n-\t * @param event event for global/sub transaction\n-\t * @return result\n-\t * @author Gannalyo\n-\t */\n-\tpublic int handleSupportTxPause(TxEvent event) {\n-\t\t// start duration.\n-\t\ttxleMetrics.startMarkTxDuration(event);\n-\t\t// child transaction count\n-\t\ttxleMetrics.countChildTxNumber(event);\n-\n-\t\tString globalTxId = event.globalTxId(), localTxId = event.localTxId(), type = event.type();\n-\t\tif (!types.contains(type) && isGlobalTxAborted(event)) {\n-\t\t\tLOG.info(\"Transaction event {} rejected, because its parent with globalTxId {} was already aborted\", type, globalTxId);\n-\t\t\ttxleMetrics.countTxNumber(event, false, event.retries() > 0);\n-\t\t\t// end duration.\n-\t\t\ttxleMetrics.endMarkTxDuration(event);\n-\t\t\treturn -1;\n-\t\t}\n-\n-\t\t/**\n-\t\t * To save event only when the status of the global transaction is not paused.\n-\t\t * If not, return to client immediately, and client will do something, like sending again.\n-\t\t */\n-\t\tboolean isPaused = isGlobalTxPaused(globalTxId, type);\n-\t\tif (!isPaused) {\n-\t\t\ttry {\n-\t\t\t\tCurrentThreadContext.put(globalTxId, event);\n-\n-\t\t\t\teventRepository.save(event);\n \n-\t\t\t\tif (TxEndedEvent.name().equals(type)) {\n-\t\t\t\t\t// There are two places for checking timeout. Here and the scheduler of the 'EventScanner' file.\n-\t\t\t\t\t// Due to they're not synchronized, hence, is's possible that global transaction is aborted here after timeout is detected by the scheduler.\n-\t\t\t\t\tif (isGlobalTxAborted(event)) {\n-\t\t\t\t\t\t// In the timeout abort case, other passed sub-transactions were compensated when the scheduler checked timeout out.\n-\t\t\t\t\t\t// Current sub-transaction need to be compensated due to it is also passed.\n-\t\t\t\t\t\t// subA ok, timeout, compensate subA, subB ok without exception(need to save ended even though aborted), compensate subB.\n-\t\t\t\t\t\tcommandRepository.saveWillCompensateCmdForCurSubTx(globalTxId, localTxId);\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\t// If not aborted, here have to check timeout again to avoid the latency of the timeout scheduler.\n-\t\t\t\t\t\tTxEvent unhandleTimeoutEvent = eventRepository.findTimeoutEventsBeforeEnding(globalTxId);\n-\t\t\t\t\t\tif (unhandleTimeoutEvent != null) {\n-\t\t\t\t\t\t\tTxTimeout txTimeout = txTimeoutOf(unhandleTimeoutEvent);\n-\t\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\t\tLOG.debug(\"TxConsistentService Detected the Timeout {}.\", txTimeout);\n-\t\t\t\t\t\t\t\ttimeoutRepository.save(txTimeout);\n-\t\t\t\t\t\t\t\tTxEvent abortedEvent = toTxAbortedEvent(txTimeout);\n-\t\t\t\t\t\t\t\tif (!eventRepository.checkIsExistsEventType(globalTxId, localTxId, abortedEvent.type())) {\n-\t\t\t\t\t\t\t\t\teventRepository.save(abortedEvent);\n-\t\t\t\t\t\t\t\t\ttxleCache.putDistributedTxAbortStatusCache(globalTxId, true, 2);\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t} catch (Exception e) {\n-\t\t\t\t\t\t\t\tLOG.error(\"Failed to save timeout {} in method 'TxConsistentService.handleSupportTxPause()'.\", txTimeout, e);\n-\t\t\t\t\t\t\t} finally {\n-\t\t\t\t\t\t\t\tcommandRepository.saveWillCompensateCommandsForTimeout(globalTxId);\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\tif (TxAbortedEvent.name().equals(type)) {\n-\t\t\t\t\t// To verify eventually abort (exclude some abort events which retried successfully).\n-\t\t\t\t\tif (globalTxId.equals(localTxId) || eventRepository.checkTxIsAborted(globalTxId, localTxId)) {\n-\t\t\t\t\t\ttxleCache.putDistributedTxAbortStatusCache(globalTxId, true, 2);\n-\t\t\t\t\t\tif (!globalTxId.equals(localTxId)) {\n-\t\t\t\t\t\t\tcommandRepository.saveWillCompensateCommandsForException(globalTxId, localTxId);\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tcommandRepository.saveWillCompensateCommandsWhenGlobalTxAborted(globalTxId);\n-\t\t\t\t\t\t\tTxEvent sagaEndedEvent = new TxEvent(event.serviceName(), event.instanceId(), globalTxId, globalTxId, null, SagaEndedEvent.name(), \"\", event.category(), new byte[0]);\n-\t\t\t\t\t\t\teventRepository.save(sagaEndedEvent);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t} catch (Exception e) {\n-\t\t\t\tLOG.error(\"Failed to save event globalTxId {} localTxId {} type {}\", globalTxId, localTxId, type, e);\n-\t\t\t} finally {\n-\t\t\t\ttxleMetrics.countTxNumber(event, false, event.retries() > 0);\n-\t\t\t\t// end duration.\n-\t\t\t\ttxleMetrics.endMarkTxDuration(event);\n-\t\t\t}\n-\n-\t\t\treturn 1;\n-\t\t}\n-\n-\t\ttxleMetrics.endMarkTxDuration(event);\n-\n-\t\treturn 0;\n-\t}\n-\n-\tprivate boolean isGlobalTxAborted(TxEvent event) {\n-\t\tif (SagaStartedEvent.name().equals(event.type())) {\n-\t\t\treturn false;\n-\t\t}\n-\t\treturn txleCache.getTxAbortStatus(event.globalTxId());\n-\t}\n-\n-\tpublic boolean isGlobalTxPaused(String globalTxId, String type) {\n-\t\tif (SagaEndedEvent.name().equals(type)) {\n-\t\t\treturn false;\n-\t\t}\n-\t\tboolean isPaused = false;\n-\t\ttry {\n-\t\t\tfinal String pauseAllGlobalTxKey = TxleConstants.constructConfigCacheKey(null, null, ConfigCenterType.PauseGlobalTx.toInteger());\n-\t\t\tif (txleCache.getConfigCache().getOrDefault(pauseAllGlobalTxKey, false)) {\n-\t\t\t\t// paused all global transactions.\n-\t\t\t\treturn true;\n-\t\t\t}\n-\n-\t\t\tif (!txleCache.getTxSuspendStatus(globalTxId)) {\n-\t\t\t\t// return false directly if it's not suspended.\n-\t\t\t\treturn false;\n-\t\t\t} else {\n-\t\t\t\t// It's unusual to pause global transaction. So, just search the list of transaction type first for saving performance.\n-\t\t\t\tList<String> typeList = eventRepository.selectAllTypeByGlobalTxId(globalTxId);\n-\t\t\t\tif (typeList == null || typeList.isEmpty()) {\n-\t\t\t\t\treturn false;\n-\t\t\t\t}\n-\n-\t\t\t\tAtomicBoolean isContainPauseEvent = new AtomicBoolean(false);\n-\t\t\t\ttypeList.forEach(t -> {\n-\t\t\t\t\tif (AdditionalEventType.SagaPausedEvent.name().equals(t) || AdditionalEventType.SagaAutoContinuedEvent.name().equals(t)) {\n-\t\t\t\t\t\tisContainPauseEvent.set(true);\n-\t\t\t\t\t}\n-\t\t\t\t});\n-\t\t\t\tif (!isContainPauseEvent.get()) {\n-\t\t\t\t\treturn false;\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t// If paused, continue to verify the expire for auto-recovery\n-\t\t\tList<TxEvent> pauseContinueEventList = eventRepository.selectPausedAndContinueEvent(globalTxId);\n-\t\t\tif (pauseContinueEventList != null && !pauseContinueEventList.isEmpty()) {\n-\t\t\t\tTxEvent event = pauseContinueEventList.get(0);\n-\t\t\t\tif (event != null && AdditionalEventType.SagaAutoContinuedEvent.name().equals(event.type())) {\n-\t\t\t\t\tisPaused = true;\n-\t\t\t\t\tif (event.expiryTime().compareTo(new Date()) < 1) {\n-\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\t// was due, create the event 'SagaAutoContinueEvent' to make event to continue running.\n-\t\t\t\t\t\t\teventRepository.save(new TxEvent(event.serviceName(), event.instanceId(), event.globalTxId(), event.localTxId(), event.parentTxId(),\n-\t\t\t\t\t\t\t\t\tAdditionalEventType.SagaAutoContinuedEvent.name(), \"\", 0, \"\", 0, event.category(), event.payloads()));\n-\t\t\t\t\t\t\tisPaused = false;\n-\t\t\t\t\t\t} catch (Exception e) {\n-\t\t\t\t\t\t\tisPaused = true;\n-\t\t\t\t\t\t\tLOG.error(\"Fail to save the event 'SagaAutoContinuedEvent'.\", e);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t} catch (Exception e) {\n-\t\t\tLOG.error(\"Fail to execute the method 'isGlobalTxPaused'.\", e);\n-\t\t}\n-\t\treturn isPaused;\n-\t}\n-\n-\tpublic Set<String> fetchLocalTxIdOfEndedGlobalTx(Set<String> localTxIdSet) {\n-\t\treturn eventRepository.selectEndedGlobalTx(localTxIdSet);\n-\t}\n-\n-\tpublic boolean saveKafkaMessage(KafkaMessage message) {\n-\t\treturn kafkaMessageRepository.save(message);\n-\t}\n-\n-\tprivate TxTimeout txTimeoutOf(TxEvent event) {\n-\t\treturn new TxTimeout(\n-\t\t\t\tevent.id(),\n-\t\t\t\tevent.serviceName(),\n-\t\t\t\tevent.instanceId(),\n-\t\t\t\tevent.globalTxId(),\n-\t\t\t\tevent.localTxId(),\n-\t\t\t\tevent.parentTxId(),\n-\t\t\t\tevent.type(),\n-\t\t\t\tevent.expiryTime(),\n-\t\t\t\tNEW.name(),\n-\t\t\t\tevent.category()\n-\t\t);\n-\t}\n-\n-\tprivate TxEvent toTxAbortedEvent(TxTimeout timeout) {\n-\t\treturn new TxEvent(\n-\t\t\t\ttimeout.serviceName(),\n-\t\t\t\ttimeout.instanceId(),\n-\t\t\t\ttimeout.globalTxId(),\n-\t\t\t\ttimeout.localTxId(),\n-\t\t\t\ttimeout.parentTxId(),\n-\t\t\t\tTxAbortedEvent.name(),\n-\t\t\t\t\"\",\n-\t\t\t\ttimeout.category(),\n-\t\t\t\t(\"Transaction timeout\").getBytes());\n-\t}\n-}\n+public class TxConsistentService {\n+    private static final Logger LOG = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+    private final TxEventRepository eventRepository;\n+    private final CommandRepository commandRepository;\n+    private final TxTimeoutRepository timeoutRepository;\n+\n+    @Autowired\n+    private IKafkaMessageRepository kafkaMessageRepository;\n+\n+    @Autowired\n+    private TxleMetrics txleMetrics;\n+\n+    @Autowired\n+    private ITxleCache txleCache;\n+    private final List<String> types = Arrays.asList(TxEndedEvent.name(), TxAbortedEvent.name(), SagaEndedEvent.name());\n+\n+    public TxConsistentService(TxEventRepository eventRepository, CommandRepository commandRepository, TxTimeoutRepository timeoutRepository) {\n+        this.eventRepository = eventRepository;\n+        this.commandRepository = commandRepository;\n+        this.timeoutRepository = timeoutRepository;\n+    }\n+\n+    public boolean handle(TxEvent event) {\n+        // start duration.\n+        txleMetrics.startMarkTxDuration(event);\n+        if (types.contains(event.type()) && isGlobalTxAborted(event)) {\n+            LOG.info(\"Transaction event {} rejected, because its parent with globalTxId {} was already aborted\", event.type(), event.globalTxId());\n+            // end duration.\n+            txleMetrics.endMarkTxDuration(event);\n+            return false;\n+        }\n+        eventRepository.save(event);\n+        // end duration.\n+        txleMetrics.endMarkTxDuration(event);\n+        return true;\n+    }\n+\n+    /**\n+     * handle the event. support transaction pause/continue/auto-continue.\n+     *\n+     * @param event event for global/sub transaction\n+     * @return result\n+     * @author Gannalyo\n+     */\n+\n+    public int handleSupportTxPause(TxEvent event) {\n+        // start duration.\n+        txleMetrics.startMarkTxDuration(event);\n+        // child transaction count\n+        txleMetrics.countChildTxNumber(event);\n+        String globalTxId = event.globalTxId(), localTxId = event.localTxId(), type = event.type();\n+        if (!types.contains(type) && isGlobalTxAborted(event)) {\n+            LOG.info(\"Transaction event {} rejected, because its parent with globalTxId {} was already aborted\", type, globalTxId);\n+            txleMetrics.countTxNumber(event, false, event.retries() > 0);\n+            // end duration.\n+            txleMetrics.endMarkTxDuration(event);\n+            return -1;\n+        }\n+\n+        /**\n+         * To save event only when the status of the global transaction is not paused.\n+         * If not, return to client immediately, and client will do something, like sending again.\n+         */\n+        boolean isPaused = isGlobalTxPaused(globalTxId, type);\n+        if (!isPaused) {\n+            try {\n+                CurrentThreadContext.put(globalTxId, event);\n+                eventRepository.save(event);\n+                if (TxEndedEvent.name().equals(type)) {\n+                    // There are two places for checking timeout. Here and the scheduler of the 'EventScanner' file.\n+                    // Due to they're not synchronized, hence, is's possible that global transaction is aborted here after timeout is detected by the scheduler.\n+                    if (isGlobalTxAborted(event)) {\n+                        // In the timeout abort case, other passed sub-transactions were compensated when the scheduler checked timeout out.\n+                        // Current sub-transaction need to be compensated due to it is also passed.\n+                        // subA ok, timeout, compensate subA, subB ok without exception(need to save ended even though aborted), compensate subB.\n+                        commandRepository.saveWillCompensateCmdForCurSubTx(globalTxId, localTxId);\n+                    } else {\n+                        // If not aborted, here have to check timeout again to avoid the latency of the timeout scheduler.\n+                        TxEvent unhandleTimeoutEvent = eventRepository.findTimeoutEventsBeforeEnding(globalTxId);\n+                        if (unhandleTimeoutEvent != null) {\n+                            TxTimeout txTimeout = txTimeoutOf(unhandleTimeoutEvent);\n+                            try {\n+                                LOG.debug(\"TxConsistentService Detected the Timeout {}.\", txTimeout);\n+                                timeoutRepository.save(txTimeout);\n+                                TxEvent abortedEvent = toTxAbortedEvent(txTimeout);\n+                                if (!eventRepository.checkIsExistsEventType(globalTxId, localTxId, abortedEvent.type())) {\n+                                    eventRepository.save(abortedEvent);\n+                                    txleCache.putDistributedTxAbortStatusCache(globalTxId, true, 2);\n+                                }\n+                            } catch (Exception e) {\n+                                LOG.error(\"Failed to save timeout {} in method 'TxConsistentService.handleSupportTxPause()'.\", txTimeout, e);\n+                            } finally {\n+                                commandRepository.saveWillCompensateCommandsForTimeout(globalTxId);\n+                            }\n+                        }\n+                    }\n+                }\n+                if (TxAbortedEvent.name().equals(type)) {\n+                    // To verify eventually abort (exclude some abort events which retried successfully).\n+                    if (globalTxId.equals(localTxId) || eventRepository.checkTxIsAborted(globalTxId, localTxId)) {\n+                        txleCache.putDistributedTxAbortStatusCache(globalTxId, true, 2);\n+                        if (!globalTxId.equals(localTxId)) {\n+                            commandRepository.saveWillCompensateCommandsForException(globalTxId, localTxId);\n+                        } else {\n+                            commandRepository.saveWillCompensateCommandsWhenGlobalTxAborted(globalTxId);\n+                            TxEvent sagaEndedEvent = new TxEvent(event.serviceName(), event.instanceId(), globalTxId, globalTxId, null, SagaEndedEvent.name(), \"\", event.category(), new byte[0]);\n+                            eventRepository.save(sagaEndedEvent);\n+                        }\n+                    }\n+                }\n+            } catch (Exception e) {\n+                LOG.error(\"Failed to save event globalTxId {} localTxId {} type {}\", globalTxId, localTxId, type, e);\n+            } finally {\n+                txleMetrics.countTxNumber(event, false, event.retries() > 0);\n+                // end duration.\n+                txleMetrics.endMarkTxDuration(event);\n+            }\n+            return 1;\n+        }\n+        txleMetrics.endMarkTxDuration(event);\n+        return 0;\n+    }\n+\n+    private boolean isGlobalTxAborted(TxEvent event) {\n+        if (SagaStartedEvent.name().equals(event.type())) {\n+            return false;\n+        }\n+        return txleCache.getTxAbortStatus(event.globalTxId());\n+    }\n+\n+    public boolean isGlobalTxPaused(String globalTxId, String type) {\n+        if (SagaEndedEvent.name().equals(type)) {\n+            return false;\n+        }\n+        boolean isPaused = false;\n+        try {\n+            final String pauseAllGlobalTxKey = TxleConstants.constructConfigCacheKey(null, null, ConfigCenterType.PauseGlobalTx.toInteger());\n+            if (txleCache.getConfigCache().getOrDefault(pauseAllGlobalTxKey, false)) {\n+                // paused all global transactions.\n+                return true;\n+            }\n+            if (!txleCache.getTxSuspendStatus(globalTxId)) {\n+                // return false directly if it's not suspended.\n+                return false;\n+            } else {\n+                // It's unusual to pause global transaction. So, just search the list of transaction type first for saving performance.\n+                List<String> typeList = eventRepository.selectAllTypeByGlobalTxId(globalTxId);\n+                if (typeList == null || typeList.isEmpty()) {\n+                    return false;\n+                }\n+                AtomicBoolean isContainPauseEvent = new AtomicBoolean(false);\n+                typeList.forEach(t -> {\n+                    if (AdditionalEventType.SagaPausedEvent.name().equals(t) || AdditionalEventType.SagaAutoContinuedEvent.name().equals(t)) {\n+                        isContainPauseEvent.set(true);\n+                    }\n+                });\n+                if (!isContainPauseEvent.get()) {\n+                    return false;\n+                }\n+            }\n+\n+            // If paused, continue to verify the expire for auto-recovery\n+            List<TxEvent> pauseContinueEventList = eventRepository.selectPausedAndContinueEvent(globalTxId);\n+            if (pauseContinueEventList != null && !pauseContinueEventList.isEmpty()) {\n+                TxEvent event = pauseContinueEventList.get(0);\n+                if (event != null && AdditionalEventType.SagaAutoContinuedEvent.name().equals(event.type())) {\n+                    isPaused = true;\n+                    if (event.expiryTime().compareTo(new Date()) < 1) {\n+                        try {\n+                            // was due, create the event 'SagaAutoContinueEvent' to make event to continue running.\n+                            eventRepository.save(new TxEvent(event.serviceName(), event.instanceId(), event.globalTxId(), event.localTxId(), event.parentTxId(), AdditionalEventType.SagaAutoContinuedEvent.name(), \"\", 0, \"\", 0, event.category(), event.payloads()));\n+                            isPaused = false;\n+                        } catch (Exception e) {\n+                            isPaused = true;\n+                            LOG.error(\"Fail to save the event 'SagaAutoContinuedEvent'.\", e);\n+                        }\n+                    }\n+                }\n+            }\n+        } catch (Exception e) {\n+            LOG.error(\"Fail to execute the method 'isGlobalTxPaused'.\", e);\n+        }\n+        return isPaused;\n+    }\n+\n+    public Set<String> fetchLocalTxIdOfEndedGlobalTx(Set<String> localTxIdSet) {\n+        return eventRepository.selectEndedGlobalTx(localTxIdSet);\n+    }\n+\n+    public boolean saveKafkaMessage(KafkaMessage message) {\n+        return kafkaMessageRepository.save(message);\n+    }\n+\n+    private TxTimeout txTimeoutOf(TxEvent event) {\n+        return new TxTimeout(\n+            event.id(),\n+            event.serviceName(),\n+            event.instanceId(),\n+            event.globalTxId(),\n+            event.localTxId(),\n+            event.parentTxId(),\n+            event.type(),\n+            event.expiryTime(),\n+            NEW.name(),\n+            event.category()\n+        );\n+    }\n+\n+    private TxEvent toTxAbortedEvent(TxTimeout timeout) {\n+        return new TxEvent(timeout.serviceName(), timeout.instanceId(), timeout.globalTxId(), timeout.localTxId(), timeout.parentTxId(), TxAbortedEvent.name(), \"\", timeout.category(), (\"Transaction timeout\").getBytes());\n+    }\n+\n+}\n\\ No newline at end of file\n",
            "diff_size": 288
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "44",
                    "column": "1",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/errored/1/47/TxConsistentService.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/styler_random/47/TxConsistentService.java\nindex 0feec116172..1549c81e4dd 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/errored/1/47/TxConsistentService.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/styler_random/47/TxConsistentService.java\n@@ -39,7 +39,7 @@ import static org.apache.servicecomb.saga.alpha.core.TaskStatus.NEW;\n import static org.apache.servicecomb.saga.common.EventType.*;\n \n public class TxConsistentService {\n-\tprivate static final Logger LOG = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+private static final Logger LOG = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n \n \tprivate final TxEventRepository eventRepository;\n \tprivate final CommandRepository commandRepository;\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "44",
                    "column": "1",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/errored/1/47/TxConsistentService.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/styler_three_grams/47/TxConsistentService.java\nindex 0feec116172..03644e7cac8 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/errored/1/47/TxConsistentService.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/styler_three_grams/47/TxConsistentService.java\n@@ -39,7 +39,7 @@ import static org.apache.servicecomb.saga.alpha.core.TaskStatus.NEW;\n import static org.apache.servicecomb.saga.common.EventType.*;\n \n public class TxConsistentService {\n-\tprivate static final Logger LOG = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+  private static final Logger LOG = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n \n \tprivate final TxEventRepository eventRepository;\n \tprivate final CommandRepository commandRepository;\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "intellij",
        "codebuff"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "styler_random",
        "styler_three_grams"
    ]
}