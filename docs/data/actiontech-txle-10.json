{
    "project_name": "actiontech-txle",
    "error_id": "10",
    "information": {
        "errors": [
            {
                "line": "27",
                "column": "1",
                "severity": "error",
                "message": "File contains tab characters (this is the first instance).",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
            }
        ]
    },
    "source_code": " */\npublic class AutoCompensableForwardRecovery extends AutoCompensableRecovery {\n\tprivate static final Logger LOG = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n\n\t// 2018/03/10 we do not support retry with timeout yet\n\t@Override",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "29",
                    "column": "1",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/errored/1/10/AutoCompensableForwardRecovery.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/styler/10/AutoCompensableForwardRecovery.java\nindex 6e0f5908471..6d7f56e8073 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/errored/1/10/AutoCompensableForwardRecovery.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/styler/10/AutoCompensableForwardRecovery.java\n@@ -24,7 +24,7 @@ import org.slf4j.LoggerFactory;\n  * If the value of the variable 'retries' is less than 0, it will use the forward recovery and retry forever until interrupted.\n  */\n public class AutoCompensableForwardRecovery extends AutoCompensableRecovery {\n-\tprivate static final Logger LOG = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+private static final Logger LOG = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n \n \t// 2018/03/10 we do not support retry with timeout yet\n \t@Override\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/errored/1/10/AutoCompensableForwardRecovery.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/intellij/10/AutoCompensableForwardRecovery.java\nindex 6e0f5908471..fc7d7fb68f6 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/errored/1/10/AutoCompensableForwardRecovery.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/intellij/10/AutoCompensableForwardRecovery.java\n@@ -24,46 +24,46 @@ import org.slf4j.LoggerFactory;\n  * If the value of the variable 'retries' is less than 0, it will use the forward recovery and retry forever until interrupted.\n  */\n public class AutoCompensableForwardRecovery extends AutoCompensableRecovery {\n-\tprivate static final Logger LOG = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+    private static final Logger LOG = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n \n-\t// 2018/03/10 we do not support retry with timeout yet\n-\t@Override\n-\tpublic Object apply(ProceedingJoinPoint joinPoint, AutoCompensable compensable,\n-\t\t\tAutoCompensableInterceptor interceptor, OmegaContext context, String parentTxId, int retries,\n-\t\t\tIAutoCompensateService autoCompensateService) throws Throwable {\n-\t\tMethod method = ((MethodSignature) joinPoint.getSignature()).getMethod();\n-\t\tint remains = retries;\n-\t\ttry {\n-\t\t\twhile (true) {\n-\t\t\t\ttry {\n-\t\t\t\t\treturn super.apply(joinPoint, compensable, interceptor, context, parentTxId, remains,\n-\t\t\t\t\t\t\tautoCompensateService);\n-\t\t\t\t} catch (Throwable throwable) {\n-\t\t\t\t\tif (throwable instanceof InvalidTransactionException) {\n-\t\t\t\t\t\tthrow throwable;\n-\t\t\t\t\t}\n+    // 2018/03/10 we do not support retry with timeout yet\n+    @Override\n+    public Object apply(ProceedingJoinPoint joinPoint, AutoCompensable compensable,\n+                        AutoCompensableInterceptor interceptor, OmegaContext context, String parentTxId, int retries,\n+                        IAutoCompensateService autoCompensateService) throws Throwable {\n+        Method method = ((MethodSignature) joinPoint.getSignature()).getMethod();\n+        int remains = retries;\n+        try {\n+            while (true) {\n+                try {\n+                    return super.apply(joinPoint, compensable, interceptor, context, parentTxId, remains,\n+                            autoCompensateService);\n+                } catch (Throwable throwable) {\n+                    if (throwable instanceof InvalidTransactionException) {\n+                        throw throwable;\n+                    }\n \n-\t\t\t\t\tif (remains > 0) {\n-\t\t\t\t\t\tremains--;\n-\t\t\t\t\t} else if (remains == 0) {\n-\t\t\t\t\t\tLOG.error(\"Retried sub tx failed maximum times, global tx id: {}, local tx id: {}, method: {}, retried times: {}\",\n-\t\t\t\t\t\t\t\tcontext.globalTxId(), context.localTxId(), method.toString(), retries);\n-\t\t\t\t\t\tthrow throwable;\n-\t\t\t\t\t}\n+                    if (remains > 0) {\n+                        remains--;\n+                    } else if (remains == 0) {\n+                        LOG.error(\"Retried sub tx failed maximum times, global tx id: {}, local tx id: {}, method: {}, retried times: {}\",\n+                                context.globalTxId(), context.localTxId(), method.toString(), retries);\n+                        throw throwable;\n+                    }\n \n-\t\t\t\t\tLOG.warn(\"Retrying sub tx failed, global tx id: {}, local tx id: {}, method: {}, remains: {}\",\n-\t\t\t\t\t\t\tcontext.globalTxId(), context.localTxId(), method.toString(), remains);\n-\t\t\t\t\tThread.sleep(compensable.retryDelayInMilliseconds());\n-\t\t\t\t}\n-\t\t\t}\n-\t\t} catch (InterruptedException e) {\n-\t\t\tString errorMessage = \"Failed to handle tx because it is interrupted, global tx id: \" + context.globalTxId()\n-\t\t\t\t\t+ \", local tx id: \" + context.localTxId() + \", method: \" + method.toString();\n-\t\t\tLOG.error(errorMessage);\n-\t\t\t// interceptor.onError(parentTxId, compensationMethodSignature(joinPoint,\n-\t\t\t// compensable, method), e);\n-\t\t\tinterceptor.onError(parentTxId, \"\", e);\n-\t\t\tthrow new OmegaException(errorMessage);\n-\t\t}\n-\t}\n+                    LOG.warn(\"Retrying sub tx failed, global tx id: {}, local tx id: {}, method: {}, remains: {}\",\n+                            context.globalTxId(), context.localTxId(), method.toString(), remains);\n+                    Thread.sleep(compensable.retryDelayInMilliseconds());\n+                }\n+            }\n+        } catch (InterruptedException e) {\n+            String errorMessage = \"Failed to handle tx because it is interrupted, global tx id: \" + context.globalTxId()\n+                    + \", local tx id: \" + context.localTxId() + \", method: \" + method.toString();\n+            LOG.error(errorMessage);\n+            // interceptor.onError(parentTxId, compensationMethodSignature(joinPoint,\n+            // compensable, method), e);\n+            interceptor.onError(parentTxId, \"\", e);\n+            throw new OmegaException(errorMessage);\n+        }\n+    }\n }\n",
            "diff_size": 39
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "29",
                    "column": "1",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/errored/1/10/AutoCompensableForwardRecovery.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/naturalize/10/AutoCompensableForwardRecovery.java\nindex 6e0f5908471..8c510ab9a7f 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/errored/1/10/AutoCompensableForwardRecovery.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/naturalize/10/AutoCompensableForwardRecovery.java\n@@ -24,46 +24,41 @@ import org.slf4j.LoggerFactory;\n  * If the value of the variable 'retries' is less than 0, it will use the forward recovery and retry forever until interrupted.\n  */\n public class AutoCompensableForwardRecovery extends AutoCompensableRecovery {\n-\tprivate static final Logger LOG = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+    private static final Logger LOG = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n \n \t// 2018/03/10 we do not support retry with timeout yet\n \t@Override\n-\tpublic Object apply(ProceedingJoinPoint joinPoint, AutoCompensable compensable,\n-\t\t\tAutoCompensableInterceptor interceptor, OmegaContext context, String parentTxId, int retries,\n+\tpublic Object apply(ProceedingJoinPoint joinPoint, AutoCompensable compensable, AutoCompensableInterceptor interceptor, OmegaContext context, String parentTxId, int retries,\n \t\t\tIAutoCompensateService autoCompensateService) throws Throwable {\n-\t\tMethod method = ((MethodSignature) joinPoint.getSignature()).getMethod();\n+    Method method = ((MethodSignature) joinPoint.getSignature()).getMethod();\n \t\tint remains = retries;\n \t\ttry {\n-\t\t\twhile (true) {\n-\t\t\t\ttry {\n-\t\t\t\t\treturn super.apply(joinPoint, compensable, interceptor, context, parentTxId, remains,\n-\t\t\t\t\t\t\tautoCompensateService);\n-\t\t\t\t} catch (Throwable throwable) {\n-\t\t\t\t\tif (throwable instanceof InvalidTransactionException) {\n-\t\t\t\t\t\tthrow throwable;\n-\t\t\t\t\t}\n+  while (true) {\n+    try {\n+  return super.apply(joinPoint, compensable, interceptor, context, parentTxId, remains, autoCompensateService);\n+    } catch (Throwable throwable) {\n+    if (throwable instanceof InvalidTransactionException) {\n+  throw throwable;\n+    }\n \n \t\t\t\t\tif (remains > 0) {\n-\t\t\t\t\t\tremains--;\n-\t\t\t\t\t} else if (remains == 0) {\n-\t\t\t\t\t\tLOG.error(\"Retried sub tx failed maximum times, global tx id: {}, local tx id: {}, method: {}, retried times: {}\",\n-\t\t\t\t\t\t\t\tcontext.globalTxId(), context.localTxId(), method.toString(), retries);\n-\t\t\t\t\t\tthrow throwable;\n-\t\t\t\t\t}\n+  remains--;\n+  } else if (remains == 0) {\n+    LOG.error(\"Retried sub tx failed maximum times, global tx id: {}, local tx id: {}, method: {}, retried times: {}\", context.globalTxId(), context.localTxId(), method.toString(), retries);\n+throw throwable;\n+    }\n \n-\t\t\t\t\tLOG.warn(\"Retrying sub tx failed, global tx id: {}, local tx id: {}, method: {}, remains: {}\",\n-\t\t\t\t\t\t\tcontext.globalTxId(), context.localTxId(), method.toString(), remains);\n-\t\t\t\t\tThread.sleep(compensable.retryDelayInMilliseconds());\n-\t\t\t\t}\n-\t\t\t}\n-\t\t} catch (InterruptedException e) {\n-\t\t\tString errorMessage = \"Failed to handle tx because it is interrupted, global tx id: \" + context.globalTxId()\n-\t\t\t\t\t+ \", local tx id: \" + context.localTxId() + \", method: \" + method.toString();\n-\t\t\tLOG.error(errorMessage);\n+\t\t\t\t\tLOG.warn(\"Retrying sub tx failed, global tx id: {}, local tx id: {}, method: {}, remains: {}\", context.globalTxId(), context.localTxId(), method.toString(), remains);\n+Thread.sleep(compensable.retryDelayInMilliseconds());\n+    }\n+    }\n+    } catch (InterruptedException e) {\n+    String errorMessage = \"Failed to handle tx because it is interrupted, global tx id: \" + context.globalTxId() + \", local tx id: \" + context.localTxId() + \", method: \" + method.toString();\n+LOG.error(errorMessage);\n \t\t\t// interceptor.onError(parentTxId, compensationMethodSignature(joinPoint,\n \t\t\t// compensable, method), e);\n \t\t\tinterceptor.onError(parentTxId, \"\", e);\n \t\t\tthrow new OmegaException(errorMessage);\n-\t\t}\n-\t}\n-}\n+    }\n+    }\n+    }\n\\ No newline at end of file\n",
            "diff_size": 30
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/errored/1/10/AutoCompensableForwardRecovery.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/codebuff/10/AutoCompensableForwardRecovery.java\nindex 6e0f5908471..aa30cb521bf 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/errored/1/10/AutoCompensableForwardRecovery.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/codebuff/10/AutoCompensableForwardRecovery.java\n@@ -7,9 +7,7 @@ package org.apache.servicecomb.saga.omega.transaction;\n \n import java.lang.invoke.MethodHandles;\n import java.lang.reflect.Method;\n-\n import javax.transaction.InvalidTransactionException;\n-\n import org.apache.servicecomb.saga.omega.context.OmegaContext;\n import org.apache.servicecomb.saga.omega.transaction.annotations.AutoCompensable;\n import org.aspectj.lang.ProceedingJoinPoint;\n@@ -23,47 +21,56 @@ import org.slf4j.LoggerFactory;\n  * If the value of the variable 'retries' is more than 0, it will use the forward recovery and retry the given times at most.\n  * If the value of the variable 'retries' is less than 0, it will use the forward recovery and retry forever until interrupted.\n  */\n+\n public class AutoCompensableForwardRecovery extends AutoCompensableRecovery {\n-\tprivate static final Logger LOG = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+    private static final Logger LOG = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n \n-\t// 2018/03/10 we do not support retry with timeout yet\n-\t@Override\n-\tpublic Object apply(ProceedingJoinPoint joinPoint, AutoCompensable compensable,\n-\t\t\tAutoCompensableInterceptor interceptor, OmegaContext context, String parentTxId, int retries,\n-\t\t\tIAutoCompensateService autoCompensateService) throws Throwable {\n-\t\tMethod method = ((MethodSignature) joinPoint.getSignature()).getMethod();\n-\t\tint remains = retries;\n-\t\ttry {\n-\t\t\twhile (true) {\n-\t\t\t\ttry {\n-\t\t\t\t\treturn super.apply(joinPoint, compensable, interceptor, context, parentTxId, remains,\n-\t\t\t\t\t\t\tautoCompensateService);\n-\t\t\t\t} catch (Throwable throwable) {\n-\t\t\t\t\tif (throwable instanceof InvalidTransactionException) {\n-\t\t\t\t\t\tthrow throwable;\n-\t\t\t\t\t}\n+    // 2018/03/10 we do not support retry with timeout yet\n \n-\t\t\t\t\tif (remains > 0) {\n-\t\t\t\t\t\tremains--;\n-\t\t\t\t\t} else if (remains == 0) {\n-\t\t\t\t\t\tLOG.error(\"Retried sub tx failed maximum times, global tx id: {}, local tx id: {}, method: {}, retried times: {}\",\n-\t\t\t\t\t\t\t\tcontext.globalTxId(), context.localTxId(), method.toString(), retries);\n-\t\t\t\t\t\tthrow throwable;\n-\t\t\t\t\t}\n+    @Override\n+    public Object apply(\n+ProceedingJoinPoint joinPoint,\n+AutoCompensable compensable,\n+AutoCompensableInterceptor interceptor,\n+OmegaContext context,\n+String parentTxId,\n+int retries, IAutoCompensateService autoCompensateService) throws Throwable {\n+        Method method = ((MethodSignature) joinPoint.getSignature()).getMethod();\n+        int remains = retries;\n+        try {\n+            while (true) {\n+                try {\n+                             return super.apply(joinPoint, compensable, interceptor, context, parentTxId, remains, autoCompensateService);\n+                } catch (Throwable throwable) {\n+                    if (throwable instanceof InvalidTransactionException) {\n+                        throw throwable;\n+                    }\n+                    if (remains > 0) {\n+                        remains--;\n+                    } else if (remains == 0) {\n+                        LOG.error(\"Retried sub tx failed maximum times, global tx id: {}, local tx id: {}, method: {}, retried times: {}\",\n+                                  context.globalTxId(),\n+                                  context.localTxId(),\n+                                  method.toString(),\n+                                  retries);\n+                        throw throwable;\n+                    }\n+                    LOG.warn(\"Retrying sub tx failed, global tx id: {}, local tx id: {}, method: {}, remains: {}\",\n+                             context.globalTxId(),\n+                             context.localTxId(),\n+                             method.toString(),\n+                             remains);\n+                    Thread.sleep(compensable.retryDelayInMilliseconds());\n+                }\n+            }\n+        } catch (InterruptedException e) {\n+            String errorMessage = \"Failed to handle tx because it is interrupted, global tx id: \" + context.globalTxId() + \", local tx id: \" + context.localTxId() + \", method: \" + method.toString();\n+            LOG.error(errorMessage);\n+            // interceptor.onError(parentTxId, compensationMethodSignature(joinPoint,\n+            // compensable, method), e);\n+            interceptor.onError(parentTxId, \"\", e);\n+            throw new OmegaException(errorMessage);\n+        }\n+    }\n \n-\t\t\t\t\tLOG.warn(\"Retrying sub tx failed, global tx id: {}, local tx id: {}, method: {}, remains: {}\",\n-\t\t\t\t\t\t\tcontext.globalTxId(), context.localTxId(), method.toString(), remains);\n-\t\t\t\t\tThread.sleep(compensable.retryDelayInMilliseconds());\n-\t\t\t\t}\n-\t\t\t}\n-\t\t} catch (InterruptedException e) {\n-\t\t\tString errorMessage = \"Failed to handle tx because it is interrupted, global tx id: \" + context.globalTxId()\n-\t\t\t\t\t+ \", local tx id: \" + context.localTxId() + \", method: \" + method.toString();\n-\t\t\tLOG.error(errorMessage);\n-\t\t\t// interceptor.onError(parentTxId, compensationMethodSignature(joinPoint,\n-\t\t\t// compensable, method), e);\n-\t\t\tinterceptor.onError(parentTxId, \"\", e);\n-\t\t\tthrow new OmegaException(errorMessage);\n-\t\t}\n-\t}\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 81
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "29",
                    "column": "1",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/errored/1/10/AutoCompensableForwardRecovery.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/styler_random/10/AutoCompensableForwardRecovery.java\nindex 6e0f5908471..6d7f56e8073 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/errored/1/10/AutoCompensableForwardRecovery.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/styler_random/10/AutoCompensableForwardRecovery.java\n@@ -24,7 +24,7 @@ import org.slf4j.LoggerFactory;\n  * If the value of the variable 'retries' is less than 0, it will use the forward recovery and retry forever until interrupted.\n  */\n public class AutoCompensableForwardRecovery extends AutoCompensableRecovery {\n-\tprivate static final Logger LOG = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+private static final Logger LOG = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n \n \t// 2018/03/10 we do not support retry with timeout yet\n \t@Override\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "29",
                    "column": "1",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/errored/1/10/AutoCompensableForwardRecovery.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/styler_three_grams/10/AutoCompensableForwardRecovery.java\nindex 6e0f5908471..6d7f56e8073 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/errored/1/10/AutoCompensableForwardRecovery.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/styler_three_grams/10/AutoCompensableForwardRecovery.java\n@@ -24,7 +24,7 @@ import org.slf4j.LoggerFactory;\n  * If the value of the variable 'retries' is less than 0, it will use the forward recovery and retry forever until interrupted.\n  */\n public class AutoCompensableForwardRecovery extends AutoCompensableRecovery {\n-\tprivate static final Logger LOG = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+private static final Logger LOG = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n \n \t// 2018/03/10 we do not support retry with timeout yet\n \t@Override\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "intellij",
        "codebuff"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "styler_random",
        "styler_three_grams"
    ]
}