{
    "project_name": "blockchain-lab-ScaleOutDistributedLedger",
    "error_id": "20",
    "information": {
        "errors": [
            {
                "line": "176",
                "severity": "warning",
                "message": "Line is longer than 160 characters (found 194).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": "\t\t}\n\t\t\n\t\tfrom.getChain().getBlocks().stream().map(Block::getTransactions).flatMap(List::stream).filter(Transaction::isUnspent).sorted((a, b) -> -Long.compare(a.getRemainder(), b.getRemainder()));\n\t\treturn null;\n\t}\n",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "176",
                    "severity": "warning",
                    "message": "Line is longer than 160 characters (found 184).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/blockchain-lab-ScaleOutDistributedLedger/errored/1/20/TransactionCreator.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/blockchain-lab-ScaleOutDistributedLedger/styler/20/TransactionCreator.java\nindex f6de4b54b83..07b24b87702 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/blockchain-lab-ScaleOutDistributedLedger/errored/1/20/TransactionCreator.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/blockchain-lab-ScaleOutDistributedLedger/styler/20/TransactionCreator.java\n@@ -172,8 +172,8 @@ public class TransactionCreator {\n \t\t\t\tif (amountRequired >= currentBestPair) it.remove();\n \t\t\t}\n \t\t}\n-\t\t\n-\t\tfrom.getChain().getBlocks().stream().map(Block::getTransactions).flatMap(List::stream).filter(Transaction::isUnspent).sorted((a, b) -> -Long.compare(a.getRemainder(), b.getRemainder()));\n+  from\n+  .getChain().getBlocks().stream().map(Block::getTransactions).flatMap(List::stream).filter(Transaction::isUnspent).sorted((a, b) -> -Long.compare(a.getRemainder(), b.getRemainder()));\n \t\treturn null;\n \t}\n \n",
            "diff_size": 2
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/blockchain-lab-ScaleOutDistributedLedger/errored/1/20/TransactionCreator.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/blockchain-lab-ScaleOutDistributedLedger/intellij/20/TransactionCreator.java\nindex f6de4b54b83..2f42465fd45 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/blockchain-lab-ScaleOutDistributedLedger/errored/1/20/TransactionCreator.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/blockchain-lab-ScaleOutDistributedLedger/intellij/20/TransactionCreator.java\n@@ -17,175 +17,186 @@ import nl.tudelft.blockchain.scaleoutdistributedledger.model.Transaction;\n \n /**\n  * Class for creating transactions.\n- * \n+ * <p>\n  * This class implements a modified version of algorithm 3 of the paper to select the best set of\n  * sources for a transaction.\n  */\n public class TransactionCreator {\n-\tprivate final int nodes;\n-\tprivate final Node from;\n-\tprivate final Node to;\n-\tprivate final long amount;\n-\tprivate final BitSet known;\n-\t\n-\tprivate Map<Transaction, BitSet> chainSets = new HashMap<>();\n-\tprivate Map<Set<Transaction>, BitSet> chainSets2 = new HashMap<>();\n-\t\n-\tprivate int currentBest = Integer.MAX_VALUE;\n-\tprivate Set<Transaction> currentBestSources;\n-\t\n-\t/**\n-\t * @param application - the application\n-\t * @param from        - the sender of the transaction\n-\t * @param to          - the receiver of the transaction\n-\t * @param amount      - the amount to send\n-\t */\n-\tpublic TransactionCreator(Application application, Node from, Node to, long amount) {\n-\t\tthis.nodes = application.getNodes().size();\n-\t\tthis.from = from;\n-\t\tthis.to = to;\n-\t\tthis.amount = amount;\n-\t\tthis.known = calculateKnowledge();\n-\t}\n-\t\n-\t/**\n-\t * Calculates what the receiver already knows about.\n-\t * \n-\t * @return a bitset with the chains the receiver already knows about\n-\t */\n-\tprivate BitSet calculateKnowledge() {\n-\t\tBitSet collected = to.getMetaKnowledge()\n-\t\t\t\t.keySet()\n-\t\t\t\t.stream()\n-\t\t\t\t.map(Node::getId)\n-\t\t\t\t.collect(() -> new BitSet(nodes), (bs, i) -> bs.set(i), (bs1, bs2) -> {\n-\t\t\t\t\tbs1.or(bs2);\n-\t\t\t\t});\n-\t\t\n-\t\treturn collected;\n-\t}\n-\t\n-\t/**\n-\t * @param number - the number to assign to the transaction\n-\t * @return         a new transaction\n-\t */\n-\tpublic Transaction createTransaction(int number) {\n-\t\tSet<Transaction> sources = bestSources();\n-\t\tlong remainder = -amount;\n-\t\tfor (Transaction source : sources) {\n-\t\t\tremainder += source.getRemainder();\n-\t\t}\n-\t\t\n-\t\treturn new Transaction(number, from, to, amount, remainder, sources);\n-\t}\n-\t\n-\t/**\n-\t * @return the best set of sources\n-\t */\n-\tSet<Transaction> bestSources() {\n-\t\t//TODO Cache unspent transactions\n-\t\t//Chain -> Blocks -> Transactions -> Unspent Transactions\n-\t\tList<Transaction> unspentTransactions = from.getChain()\n-\t\t\t\t.getBlocks()\n-\t\t\t\t.stream()\n-\t\t\t\t.map(Block::getTransactions)\n-\t\t\t\t.flatMap(List::stream)\n-\t\t\t\t.filter(Transaction::isUnspent)\n-\t\t\t\t.collect(Collectors.toCollection(ArrayList::new));\n-\t\t\n-\t\tint currentBestSingle = Integer.MAX_VALUE;\n-\t\tSet<Transaction> currentBestSources = null;\n-\t\t\n-\t\tList<Transaction> combine = new ArrayList<>();\n-\t\tfor (Transaction transaction : unspentTransactions) {\n-\t\t\tBitSet chainsRequired = chainsRequired(transaction);\n-\t\t\tint amountRequired = chainsRequired.cardinality();\n-\t\t\t\n-\t\t\t//If this transaction is worse than our current best, then we don't even have to consider it.\n-\t\t\tif (amountRequired >= currentBestSingle) continue;\n-\t\t\t\n-\t\t\t//Remember the required chains for this transaction\n-\t\t\tchainSets.put(transaction, chainsRequired);\n-\t\t\t\n-\t\t\tif (transaction.getRemainder() >= amount) {\n-\t\t\t\t//This transaction is enough on its own\n-\t\t\t\tcurrentBestSingle = amountRequired;\n-\t\t\t\tcurrentBestSources = Collections.singleton(transaction);\n-\t\t\t} else {\n-\t\t\t\tcombine.add(transaction);\n-\t\t\t}\n-\t\t}\n-\t\t\n-\t\t//If we have a current best, we delete all transactions which are not worth considering\n-\t\tif (currentBestSingle != Integer.MAX_VALUE) {\n-\t\t\tIterator<Transaction> it = combine.iterator();\n-\t\t\twhile (it.hasNext()) {\n-\t\t\t\tTransaction t = it.next();\n-\t\t\t\tint amountRequired = chainSets.get(t).cardinality();\n-\t\t\t\tif (amountRequired >= currentBestSingle) it.remove();\n-\t\t\t}\n-\t\t}\n-\t\t\n-\t\t//Check if we have found anything\n-\t\tif (combine.isEmpty()) return currentBestSources;\n-\t\t\n-\t\tList<Set<Transaction>> combine2 = new ArrayList<>();\n-\t\tint currentBestPair = currentBestSingle;\n-\t\tfor (Transaction t1 : combine) {\n-\t\t\tBitSet r1 = chainSets.get(t1);\n-\t\t\t\n-\t\t\tfor (Transaction t2 : combine) {\n-\t\t\t\tBitSet r2 = chainSets.get(t2);\n-\t\t\t\tBitSet r3 = (BitSet) r1.clone();\n-\t\t\t\tr3.or(r2);\n-\t\t\t\t\n-\t\t\t\tint amountRequired = r3.cardinality();\n-\t\t\t\t\n-\t\t\t\t//If this combination is worse than the current best, we don't consider it.\n-\t\t\t\tif (amountRequired >= currentBestPair) continue;\n-\t\t\t\t\n-\t\t\t\tif (t1.getRemainder() + t2.getRemainder() >= amount) {\n-\t\t\t\t\tSet<Transaction> t3 = new HashSet<>(2);\n-\t\t\t\t\tt3.add(t1);\n-\t\t\t\t\tt3.add(t2);\n-\t\t\t\t\tchainSets2.put(t3, r3);\n-\t\t\t\t\t\n-\t\t\t\t\tcurrentBestPair = amountRequired;\n-\t\t\t\t\tcurrentBestSources = t3;\n-\t\t\t\t} else {\n-\t\t\t\t\t//Consider this pair for the next round\n-\t\t\t\t\tSet<Transaction> t3 = new HashSet<>(2);\n-\t\t\t\t\tt3.add(t1);\n-\t\t\t\t\tt3.add(t2);\n-\t\t\t\t\tchainSets2.put(t3, r3);\n-\t\t\t\t\t\n-\t\t\t\t\tcombine2.add(t3);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\t\n-\t\tif (currentBestPair != currentBestSingle) {\n-\t\t\tIterator<Set<Transaction>> it = combine2.iterator();\n-\t\t\twhile (it.hasNext()) {\n-\t\t\t\tSet<Transaction> ts = it.next();\n-\t\t\t\tint amountRequired = chainSets2.get(ts).cardinality();\n-\t\t\t\tif (amountRequired >= currentBestPair) it.remove();\n-\t\t\t}\n-\t\t}\n-\t\t\n-\t\tfrom.getChain().getBlocks().stream().map(Block::getTransactions).flatMap(List::stream).filter(Transaction::isUnspent).sorted((a, b) -> -Long.compare(a.getRemainder(), b.getRemainder()));\n-\t\treturn null;\n-\t}\n-\n-\tprivate BitSet chainsRequired(Transaction transaction) {\n-\t\tBitSet bitset = new BitSet(nodes);\n-\t\t\n-\t\t\n-\t\t//TODO determine chains required for transaction\n-\t\t\n-\t\t//Remove all chains that are already known\n-\t\tbitset.andNot(known);\n-\t\t\n-\t\treturn bitset;\n-\t}\n+    private final int nodes;\n+    private final Node from;\n+    private final Node to;\n+    private final long amount;\n+    private final BitSet known;\n+\n+    private Map<Transaction, BitSet> chainSets = new HashMap<>();\n+    private Map<Set<Transaction>, BitSet> chainSets2 = new HashMap<>();\n+\n+    private int currentBest = Integer.MAX_VALUE;\n+    private Set<Transaction> currentBestSources;\n+\n+    /**\n+     * @param application - the application\n+     * @param from        - the sender of the transaction\n+     * @param to          - the receiver of the transaction\n+     * @param amount      - the amount to send\n+     */\n+    public TransactionCreator(Application application, Node from, Node to, long amount) {\n+        this.nodes = application.getNodes().size();\n+        this.from = from;\n+        this.to = to;\n+        this.amount = amount;\n+        this.known = calculateKnowledge();\n+    }\n+\n+    /**\n+     * Calculates what the receiver already knows about.\n+     *\n+     * @return a bitset with the chains the receiver already knows about\n+     */\n+    private BitSet calculateKnowledge() {\n+        BitSet collected = to.getMetaKnowledge()\n+            .keySet()\n+            .stream()\n+            .map(Node::getId)\n+            .collect(() -> new BitSet(nodes), (bs, i) -> bs.set(i), (bs1, bs2) -> {\n+                bs1.or(bs2);\n+            });\n+\n+        return collected;\n+    }\n+\n+    /**\n+     * @param number - the number to assign to the transaction\n+     * @return a new transaction\n+     */\n+    public Transaction createTransaction(int number) {\n+        Set<Transaction> sources = bestSources();\n+        long remainder = -amount;\n+        for (Transaction source : sources) {\n+            remainder += source.getRemainder();\n+        }\n+\n+        return new Transaction(number, from, to, amount, remainder, sources);\n+    }\n+\n+    /**\n+     * @return the best set of sources\n+     */\n+    Set<Transaction> bestSources() {\n+        //TODO Cache unspent transactions\n+        //Chain -> Blocks -> Transactions -> Unspent Transactions\n+        List<Transaction> unspentTransactions = from.getChain()\n+            .getBlocks()\n+            .stream()\n+            .map(Block::getTransactions)\n+            .flatMap(List::stream)\n+            .filter(Transaction::isUnspent)\n+            .collect(Collectors.toCollection(ArrayList::new));\n+\n+        int currentBestSingle = Integer.MAX_VALUE;\n+        Set<Transaction> currentBestSources = null;\n+\n+        List<Transaction> combine = new ArrayList<>();\n+        for (Transaction transaction : unspentTransactions) {\n+            BitSet chainsRequired = chainsRequired(transaction);\n+            int amountRequired = chainsRequired.cardinality();\n+\n+            //If this transaction is worse than our current best, then we don't even have to consider it.\n+            if (amountRequired >= currentBestSingle) {\n+                continue;\n+            }\n+\n+            //Remember the required chains for this transaction\n+            chainSets.put(transaction, chainsRequired);\n+\n+            if (transaction.getRemainder() >= amount) {\n+                //This transaction is enough on its own\n+                currentBestSingle = amountRequired;\n+                currentBestSources = Collections.singleton(transaction);\n+            } else {\n+                combine.add(transaction);\n+            }\n+        }\n+\n+        //If we have a current best, we delete all transactions which are not worth considering\n+        if (currentBestSingle != Integer.MAX_VALUE) {\n+            Iterator<Transaction> it = combine.iterator();\n+            while (it.hasNext()) {\n+                Transaction t = it.next();\n+                int amountRequired = chainSets.get(t).cardinality();\n+                if (amountRequired >= currentBestSingle) {\n+                    it.remove();\n+                }\n+            }\n+        }\n+\n+        //Check if we have found anything\n+        if (combine.isEmpty()) {\n+            return currentBestSources;\n+        }\n+\n+        List<Set<Transaction>> combine2 = new ArrayList<>();\n+        int currentBestPair = currentBestSingle;\n+        for (Transaction t1 : combine) {\n+            BitSet r1 = chainSets.get(t1);\n+\n+            for (Transaction t2 : combine) {\n+                BitSet r2 = chainSets.get(t2);\n+                BitSet r3 = (BitSet) r1.clone();\n+                r3.or(r2);\n+\n+                int amountRequired = r3.cardinality();\n+\n+                //If this combination is worse than the current best, we don't consider it.\n+                if (amountRequired >= currentBestPair) {\n+                    continue;\n+                }\n+\n+                if (t1.getRemainder() + t2.getRemainder() >= amount) {\n+                    Set<Transaction> t3 = new HashSet<>(2);\n+                    t3.add(t1);\n+                    t3.add(t2);\n+                    chainSets2.put(t3, r3);\n+\n+                    currentBestPair = amountRequired;\n+                    currentBestSources = t3;\n+                } else {\n+                    //Consider this pair for the next round\n+                    Set<Transaction> t3 = new HashSet<>(2);\n+                    t3.add(t1);\n+                    t3.add(t2);\n+                    chainSets2.put(t3, r3);\n+\n+                    combine2.add(t3);\n+                }\n+            }\n+        }\n+\n+        if (currentBestPair != currentBestSingle) {\n+            Iterator<Set<Transaction>> it = combine2.iterator();\n+            while (it.hasNext()) {\n+                Set<Transaction> ts = it.next();\n+                int amountRequired = chainSets2.get(ts).cardinality();\n+                if (amountRequired >= currentBestPair) {\n+                    it.remove();\n+                }\n+            }\n+        }\n+\n+        from.getChain().getBlocks().stream().map(Block::getTransactions).flatMap(List::stream).filter(Transaction::isUnspent)\n+            .sorted((a, b) -> -Long.compare(a.getRemainder(), b.getRemainder()));\n+        return null;\n+    }\n+\n+    private BitSet chainsRequired(Transaction transaction) {\n+        BitSet bitset = new BitSet(nodes);\n+\n+\n+        //TODO determine chains required for transaction\n+\n+        //Remove all chains that are already known\n+        bitset.andNot(known);\n+\n+        return bitset;\n+    }\n }\n",
            "diff_size": 178
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "176",
                    "severity": "warning",
                    "message": "Line is longer than 160 characters (found 184).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/blockchain-lab-ScaleOutDistributedLedger/errored/1/20/TransactionCreator.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/blockchain-lab-ScaleOutDistributedLedger/styler_random/20/TransactionCreator.java\nindex f6de4b54b83..07b24b87702 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/blockchain-lab-ScaleOutDistributedLedger/errored/1/20/TransactionCreator.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/blockchain-lab-ScaleOutDistributedLedger/styler_random/20/TransactionCreator.java\n@@ -172,8 +172,8 @@ public class TransactionCreator {\n \t\t\t\tif (amountRequired >= currentBestPair) it.remove();\n \t\t\t}\n \t\t}\n-\t\t\n-\t\tfrom.getChain().getBlocks().stream().map(Block::getTransactions).flatMap(List::stream).filter(Transaction::isUnspent).sorted((a, b) -> -Long.compare(a.getRemainder(), b.getRemainder()));\n+  from\n+  .getChain().getBlocks().stream().map(Block::getTransactions).flatMap(List::stream).filter(Transaction::isUnspent).sorted((a, b) -> -Long.compare(a.getRemainder(), b.getRemainder()));\n \t\treturn null;\n \t}\n \n",
            "diff_size": 2
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "175",
                    "severity": "warning",
                    "message": "Line is longer than 160 characters (found 188).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/blockchain-lab-ScaleOutDistributedLedger/errored/1/20/TransactionCreator.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/blockchain-lab-ScaleOutDistributedLedger/styler_three_grams/20/TransactionCreator.java\nindex f6de4b54b83..3a0e7c8a3bb 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/blockchain-lab-ScaleOutDistributedLedger/errored/1/20/TransactionCreator.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/blockchain-lab-ScaleOutDistributedLedger/styler_three_grams/20/TransactionCreator.java\n@@ -171,9 +171,8 @@ public class TransactionCreator {\n \t\t\t\tint amountRequired = chainSets2.get(ts).cardinality();\n \t\t\t\tif (amountRequired >= currentBestPair) it.remove();\n \t\t\t}\n-\t\t}\n-\t\t\n-\t\tfrom.getChain().getBlocks().stream().map(Block::getTransactions).flatMap(List::stream).filter(Transaction::isUnspent).sorted((a, b) -> -Long.compare(a.getRemainder(), b.getRemainder()));\n+\t\t} from\n+      .getChain().getBlocks().stream().map(Block::getTransactions).flatMap(List::stream).filter(Transaction::isUnspent).sorted((a, b) -> -Long.compare(a.getRemainder(), b.getRemainder()));\n \t\treturn null;\n \t}\n \n",
            "diff_size": 3
        }
    ],
    "repaired_by": [
        "intellij"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}