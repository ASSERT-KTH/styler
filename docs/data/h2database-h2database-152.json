{
    "project_name": "h2database-h2database",
    "error_id": "152",
    "information": {
        "errors": [
            {
                "line": "1157",
                "column": "53",
                "severity": "warning",
                "message": "'typecast' is not followed by whitespace.",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAfterCheck"
            }
        ]
    },
    "source_code": "            return null;\n        }\n        return StringUtils.convertHexToBytes((String)v);\n    }\n\n    /**",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/errored/1/152/DataUtils.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/styler/152/DataUtils.java\nindex 45b80c522ba..0856a153484 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/errored/1/152/DataUtils.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/styler/152/DataUtils.java\n@@ -1154,7 +1154,7 @@ public final class DataUtils {\n         if (v == null) {\n             return null;\n         }\n-        return StringUtils.convertHexToBytes((String)v);\n+        return StringUtils.convertHexToBytes((String) v);\n     }\n \n     /**\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "816",
                    "column": "54",
                    "severity": "warning",
                    "message": "';' is followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.EmptyForIteratorPadCheck"
                },
                {
                    "line": "850",
                    "column": "54",
                    "severity": "warning",
                    "message": "';' is followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.EmptyForIteratorPadCheck"
                },
                {
                    "line": "897",
                    "column": "54",
                    "severity": "warning",
                    "message": "';' is followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.EmptyForIteratorPadCheck"
                },
                {
                    "line": "947",
                    "column": "61",
                    "severity": "warning",
                    "message": "';' is followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.EmptyForIteratorPadCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/errored/1/152/DataUtils.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/intellij/152/DataUtils.java\nindex 45b80c522ba..0bbe39ee65b 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/errored/1/152/DataUtils.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/intellij/152/DataUtils.java\n@@ -3,6 +3,7 @@\n  * and the EPL 1.0 (https://h2database.com/html/license.html).\n  * Initial Developer: H2 Group\n  */\n+\n package org.h2.mvstore;\n \n import java.io.EOFException;\n@@ -288,7 +289,7 @@ public final class DataUtils {\n      * Write a variable size int.\n      *\n      * @param out the output stream\n-     * @param x the value\n+     * @param x   the value\n      * @throws IOException if some data could not be written\n      */\n     public static void writeVarInt(OutputStream out, int x) throws IOException {\n@@ -303,7 +304,7 @@ public final class DataUtils {\n      * Write a variable size int.\n      *\n      * @param buff the source buffer\n-     * @param x the value\n+     * @param x    the value\n      */\n     public static void writeVarInt(ByteBuffer buff, int x) {\n         while ((x & ~0x7f) != 0) {\n@@ -317,11 +318,11 @@ public final class DataUtils {\n      * Write characters from a string (without the length).\n      *\n      * @param buff the target buffer (must be large enough)\n-     * @param s the string\n-     * @param len the number of characters\n+     * @param s    the string\n+     * @param len  the number of characters\n      */\n     public static void writeStringData(ByteBuffer buff,\n-            String s, int len) {\n+                                       String s, int len) {\n         for (int i = 0; i < len; i++) {\n             int c = s.charAt(i);\n             if (c < 0x80) {\n@@ -351,7 +352,7 @@ public final class DataUtils {\n      * Read a string.\n      *\n      * @param buff the source buffer\n-     * @param len the number of characters\n+     * @param len  the number of characters\n      * @return the value\n      */\n     public static String readString(ByteBuffer buff, int len) {\n@@ -374,7 +375,7 @@ public final class DataUtils {\n      * Write a variable size long.\n      *\n      * @param buff the target buffer\n-     * @param x the value\n+     * @param x    the value\n      */\n     public static void writeVarLong(ByteBuffer buff, long x) {\n         while ((x & ~0x7f) != 0) {\n@@ -388,7 +389,7 @@ public final class DataUtils {\n      * Write a variable size long.\n      *\n      * @param out the output stream\n-     * @param x the value\n+     * @param x   the value\n      * @throws IOException if some data could not be written\n      */\n     public static void writeVarLong(OutputStream out, long x)\n@@ -403,13 +404,13 @@ public final class DataUtils {\n     /**\n      * Copy the elements of an array, with a gap.\n      *\n-     * @param src the source array\n-     * @param dst the target array\n-     * @param oldSize the size of the old array\n+     * @param src      the source array\n+     * @param dst      the target array\n+     * @param oldSize  the size of the old array\n      * @param gapIndex the index of the gap\n      */\n     public static void copyWithGap(Object src, Object dst, int oldSize,\n-            int gapIndex) {\n+                                   int gapIndex) {\n         if (gapIndex > 0) {\n             System.arraycopy(src, 0, dst, 0, gapIndex);\n         }\n@@ -422,13 +423,13 @@ public final class DataUtils {\n     /**\n      * Copy the elements of an array, and remove one element.\n      *\n-     * @param src the source array\n-     * @param dst the target array\n-     * @param oldSize the size of the old array\n+     * @param src         the source array\n+     * @param dst         the target array\n+     * @param oldSize     the size of the old array\n      * @param removeIndex the index of the entry to remove\n      */\n     public static void copyExcept(Object src, Object dst, int oldSize,\n-            int removeIndex) {\n+                                  int removeIndex) {\n         if (removeIndex > 0 && oldSize > 0) {\n             System.arraycopy(src, 0, dst, 0, removeIndex);\n         }\n@@ -443,8 +444,8 @@ public final class DataUtils {\n      * The buffer is rewind after reading.\n      *\n      * @param file the file channel\n-     * @param pos the absolute position within the file\n-     * @param dst the byte buffer\n+     * @param pos  the absolute position within the file\n+     * @param dst  the byte buffer\n      * @throws IllegalStateException if some data could not be read\n      */\n     public static void readFully(FileChannel file, long pos, ByteBuffer dst) {\n@@ -467,7 +468,7 @@ public final class DataUtils {\n             throw newIllegalStateException(\n                     ERROR_READING_FAILED,\n                     \"Reading from file {0} failed at {1} (length {2}), \" +\n-                    \"read {3}, remaining {4}\",\n+                            \"read {3}, remaining {4}\",\n                     file, pos, size, dst.position(), dst.remaining(), e);\n         }\n     }\n@@ -476,8 +477,8 @@ public final class DataUtils {\n      * Write to a file channel.\n      *\n      * @param file the file channel\n-     * @param pos the absolute position within the file\n-     * @param src the source buffer\n+     * @param pos  the absolute position within the file\n+     * @param src  the source buffer\n      */\n     public static void writeFully(FileChannel file, long pos, ByteBuffer src) {\n         try {\n@@ -594,6 +595,7 @@ public final class DataUtils {\n \n     /**\n      * Determines whether specified file position corresponds to a leaf page\n+     *\n      * @param pos the position\n      * @return true if it is a leaf, false otherwise\n      */\n@@ -616,7 +618,7 @@ public final class DataUtils {\n      *\n      * @param pos the position\n      * @return true if page has been removed (no longer accessible from the\n-     *         current root of the tree)\n+     * current root of the tree)\n      */\n     static boolean isPageRemoved(long pos) {\n         return pos == 1L;\n@@ -628,12 +630,13 @@ public final class DataUtils {\n      * (node or leaf).\n      *\n      * @param chunkId the chunk id\n-     * @param offset the offset\n-     * @param length the length\n-     * @param type the page type (1 for node, 0 for leaf)\n+     * @param offset  the offset\n+     * @param length  the length\n+     * @param type    the page type (1 for node, 0 for leaf)\n      * @return the position\n      */\n-    public static long getPagePos(int chunkId, int offset, int length, int type) {\n+    public static long getPagePos(int chunkId, int offset, int length,\n+                                  int type) {\n         long pos = (long) chunkId << 38;\n         pos |= (long) offset << 6;\n         pos |= encodeLength(length) << 1;\n@@ -643,6 +646,7 @@ public final class DataUtils {\n \n     /**\n      * Convert tocElement into pagePos by replacing mapId with chunkId\n+     *\n      * @param chunkId\n      * @param tocElement\n      * @return\n@@ -656,13 +660,14 @@ public final class DataUtils {\n      * the map id, the page offset, the maximum length, and the type\n      * (node or leaf).\n      *\n-     * @param mapId the chunk id\n+     * @param mapId  the chunk id\n      * @param offset the offset\n      * @param length the length\n-     * @param type the page type (1 for node, 0 for leaf)\n+     * @param type   the page type (1 for node, 0 for leaf)\n      * @return the position\n      */\n-    public static long getTocElement(int mapId, int offset, int length, int type) {\n+    public static long getTocElement(int mapId, int offset, int length,\n+                                     int type) {\n         long pos = (long) mapId << 38;\n         pos |= (long) offset << 6;\n         pos |= encodeLength(length) << 1;\n@@ -686,10 +691,11 @@ public final class DataUtils {\n      * Append a map to the string builder, sorted by key.\n      *\n      * @param buff the target buffer\n-     * @param map the map\n+     * @param map  the map\n      * @return the string builder\n      */\n-    public static StringBuilder appendMap(StringBuilder buff, HashMap<String, ?> map) {\n+    public static StringBuilder appendMap(StringBuilder buff,\n+                                          HashMap<String, ?> map) {\n         Object[] keys = map.keySet().toArray();\n         Arrays.sort(keys);\n         for (Object k : keys) {\n@@ -718,8 +724,8 @@ public final class DataUtils {\n      * colon. Values that contain a comma or a double quote are enclosed in\n      * double quotes, with special characters escaped using a backslash.\n      *\n-     * @param buff the target buffer\n-     * @param key the key\n+     * @param buff  the target buffer\n+     * @param key   the key\n      * @param value the value\n      */\n     public static void appendMap(StringBuilder buff, String key, String value) {\n@@ -743,8 +749,8 @@ public final class DataUtils {\n      * Append a key-value pair to the string builder. Keys may not contain a\n      * colon.\n      *\n-     * @param buff the target buffer\n-     * @param key the key\n+     * @param buff  the target buffer\n+     * @param key   the key\n      * @param value the value\n      */\n     public static void appendMap(StringBuilder buff, String key, long value) {\n@@ -755,8 +761,8 @@ public final class DataUtils {\n      * Append a key-value pair to the string builder. Keys may not contain a\n      * colon.\n      *\n-     * @param buff the target buffer\n-     * @param key the key\n+     * @param buff  the target buffer\n+     * @param key   the key\n      * @param value the value\n      */\n     public static void appendMap(StringBuilder buff, String key, int value) {\n@@ -765,12 +771,13 @@ public final class DataUtils {\n \n     /**\n      * @param buff output buffer, should be empty\n-     * @param s parsed string\n-     * @param i offset to parse from\n+     * @param s    parsed string\n+     * @param i    offset to parse from\n      * @param size stop offset (exclusive)\n      * @return new offset\n      */\n-    private static int parseMapValue(StringBuilder buff, String s, int i, int size) {\n+    private static int parseMapValue(StringBuilder buff, String s, int i,\n+                                     int size) {\n         while (i < size) {\n             char c = s.charAt(i++);\n             if (c == ',') {\n@@ -780,7 +787,8 @@ public final class DataUtils {\n                     c = s.charAt(i++);\n                     if (c == '\\\\') {\n                         if (i == size) {\n-                            throw newIllegalStateException(ERROR_FILE_CORRUPT, \"Not a map: {0}\", s);\n+                            throw newIllegalStateException(ERROR_FILE_CORRUPT,\n+                                    \"Not a map: {0}\", s);\n                         }\n                         c = s.charAt(i++);\n                     } else if (c == '\\\"') {\n@@ -805,11 +813,12 @@ public final class DataUtils {\n     public static HashMap<String, String> parseMap(String s) {\n         HashMap<String, String> map = new HashMap<>();\n         StringBuilder buff = new StringBuilder();\n-        for (int i = 0, size = s.length(); i < size;) {\n+        for (int i = 0, size = s.length(); i < size; ) {\n             int startKey = i;\n             i = s.indexOf(':', i);\n             if (i < 0) {\n-                throw newIllegalStateException(ERROR_FILE_CORRUPT, \"Not a map: {0}\", s);\n+                throw newIllegalStateException(ERROR_FILE_CORRUPT,\n+                        \"Not a map: {0}\", s);\n             }\n             String key = s.substring(startKey, i++);\n             i = parseMapValue(buff, s, i, size);\n@@ -824,7 +833,7 @@ public final class DataUtils {\n      *\n      * @param bytes encoded map\n      * @return the map without mapping for {@code \"fletcher\"}, or {@code null} if checksum is wrong\n-     *              or parameter do not represent a properly formatted map serialization\n+     * or parameter do not represent a properly formatted map serialization\n      */\n     static HashMap<String, String> parseChecksummedMap(byte[] bytes) {\n         int start = 0, end = bytes.length;\n@@ -834,17 +843,19 @@ public final class DataUtils {\n         while (start < end && bytes[end - 1] <= ' ') {\n             end--;\n         }\n-        String s = new String(bytes, start, end - start, StandardCharsets.ISO_8859_1);\n+        String s = new String(bytes, start, end - start,\n+                StandardCharsets.ISO_8859_1);\n         HashMap<String, String> map = new HashMap<>();\n         StringBuilder buff = new StringBuilder();\n-        for (int i = 0, size = s.length(); i < size;) {\n+        for (int i = 0, size = s.length(); i < size; ) {\n             int startKey = i;\n             i = s.indexOf(':', i);\n             if (i < 0) {\n                 // Corrupted map\n                 return null;\n             }\n-            if (i - startKey == 8 && s.regionMatches(startKey, \"fletcher\", 0, 8)) {\n+            if (i - startKey == 8 &&\n+                    s.regionMatches(startKey, \"fletcher\", 0, 8)) {\n                 parseMapValue(buff, s, i + 1, size);\n                 int check = (int) Long.parseLong(buff.toString(), 16);\n                 if (check == getFletcher32(bytes, start, startKey - 1)) {\n@@ -876,20 +887,22 @@ public final class DataUtils {\n     /**\n      * Parse a specified pair from key-value pair list.\n      *\n-     * @param s the list\n+     * @param s   the list\n      * @param key the name of the key\n      * @return value of the specified item, or {@code null}\n      * @throws IllegalStateException if parsing failed\n      */\n     public static String getFromMap(String s, String key) {\n         int keyLength = key.length();\n-        for (int i = 0, size = s.length(); i < size;) {\n+        for (int i = 0, size = s.length(); i < size; ) {\n             int startKey = i;\n             i = s.indexOf(':', i);\n             if (i < 0) {\n-                throw newIllegalStateException(ERROR_FILE_CORRUPT, \"Not a map: {0}\", s);\n+                throw newIllegalStateException(ERROR_FILE_CORRUPT,\n+                        \"Not a map: {0}\", s);\n             }\n-            if (i++ - startKey == keyLength && s.regionMatches(startKey, key, 0, keyLength)) {\n+            if (i++ - startKey == keyLength &&\n+                    s.regionMatches(startKey, key, 0, keyLength)) {\n                 StringBuilder buff = new StringBuilder();\n                 parseMapValue(buff, s, i, size);\n                 return buff.toString();\n@@ -903,7 +916,9 @@ public final class DataUtils {\n                             c = s.charAt(i++);\n                             if (c == '\\\\') {\n                                 if (i++ == size) {\n-                                    throw newIllegalStateException(ERROR_FILE_CORRUPT, \"Not a map: {0}\", s);\n+                                    throw newIllegalStateException(\n+                                            ERROR_FILE_CORRUPT,\n+                                            \"Not a map: {0}\", s);\n                                 }\n                             } else if (c == '\\\"') {\n                                 break;\n@@ -919,7 +934,7 @@ public final class DataUtils {\n     /**\n      * Calculate the Fletcher32 checksum.\n      *\n-     * @param bytes the bytes\n+     * @param bytes  the bytes\n      * @param offset initial offset\n      * @param length the message length (if odd, 0 is appended)\n      * @return the checksum\n@@ -929,7 +944,7 @@ public final class DataUtils {\n         int i = offset, len = offset + (length & ~1);\n         while (i < len) {\n             // reduce after 360 words (each word is two bytes)\n-            for (int end = Math.min(i + 720, len); i < end;) {\n+            for (int end = Math.min(i + 720, len); i < end; ) {\n                 int x = ((bytes[i++] & 0xff) << 8) | (bytes[i++] & 0xff);\n                 s2 += s1 += x;\n             }\n@@ -949,13 +964,13 @@ public final class DataUtils {\n     /**\n      * Throw an IllegalArgumentException if the argument is invalid.\n      *\n-     * @param test true if the argument is valid\n-     * @param message the message\n+     * @param test      true if the argument is valid\n+     * @param message   the message\n      * @param arguments the arguments\n      * @throws IllegalArgumentException if the argument is invalid\n      */\n     public static void checkArgument(boolean test, String message,\n-            Object... arguments) {\n+                                     Object... arguments) {\n         if (!test) {\n             throw newIllegalArgumentException(message, arguments);\n         }\n@@ -964,14 +979,14 @@ public final class DataUtils {\n     /**\n      * Create a new IllegalArgumentException.\n      *\n-     * @param message the message\n+     * @param message   the message\n      * @param arguments the arguments\n      * @return the exception\n      */\n     public static IllegalArgumentException newIllegalArgumentException(\n             String message, Object... arguments) {\n         return initCause(new IllegalArgumentException(\n-                formatMessage(0, message, arguments)),\n+                        formatMessage(0, message, arguments)),\n                 arguments);\n     }\n \n@@ -982,7 +997,7 @@ public final class DataUtils {\n      * @return the exception\n      */\n     public static UnsupportedOperationException\n-            newUnsupportedOperationException(String message) {\n+    newUnsupportedOperationException(String message) {\n         return new UnsupportedOperationException(formatMessage(0, message));\n     }\n \n@@ -990,14 +1005,14 @@ public final class DataUtils {\n      * Create a new IllegalStateException.\n      *\n      * @param errorCode the error code\n-     * @param message the message\n+     * @param message   the message\n      * @param arguments the arguments\n      * @return the exception\n      */\n     public static IllegalStateException newIllegalStateException(\n             int errorCode, String message, Object... arguments) {\n         return initCause(new IllegalStateException(\n-                formatMessage(errorCode, message, arguments)),\n+                        formatMessage(errorCode, message, arguments)),\n                 arguments);\n     }\n \n@@ -1016,12 +1031,12 @@ public final class DataUtils {\n      * Format an error message.\n      *\n      * @param errorCode the error code\n-     * @param message the message\n+     * @param message   the message\n      * @param arguments the arguments\n      * @return the formatted message\n      */\n     public static String formatMessage(int errorCode, String message,\n-            Object... arguments) {\n+                                       Object... arguments) {\n         // convert arguments to strings, to avoid locale specific formatting\n         arguments = arguments.clone();\n         for (int i = 0; i < arguments.length; i++) {\n@@ -1063,13 +1078,14 @@ public final class DataUtils {\n     /**\n      * Read a hex long value from a map.\n      *\n-     * @param map the map\n-     * @param key the key\n+     * @param map          the map\n+     * @param key          the key\n      * @param defaultValue if the value is null\n      * @return the parsed value\n      * @throws IllegalStateException if parsing fails\n      */\n-    public static long readHexLong(Map<String, ?> map, String key, long defaultValue) {\n+    public static long readHexLong(Map<String, ?> map, String key,\n+                                   long defaultValue) {\n         Object v = map.get(key);\n         if (v == null) {\n             return defaultValue;\n@@ -1127,13 +1143,14 @@ public final class DataUtils {\n     /**\n      * Read a hex int value from a map.\n      *\n-     * @param map the map\n-     * @param key the key\n+     * @param map          the map\n+     * @param key          the key\n      * @param defaultValue if the value is null\n      * @return the parsed value\n      * @throws IllegalStateException if parsing fails\n      */\n-    public static int readHexInt(Map<String, ?> map, String key, int defaultValue) {\n+    public static int readHexInt(Map<String, ?> map, String key,\n+                                 int defaultValue) {\n         Object v = map.get(key);\n         if (v == null) {\n             return defaultValue;\n@@ -1154,18 +1171,19 @@ public final class DataUtils {\n         if (v == null) {\n             return null;\n         }\n-        return StringUtils.convertHexToBytes((String)v);\n+        return StringUtils.convertHexToBytes((String) v);\n     }\n \n     /**\n      * Get the configuration parameter value, or default.\n      *\n-     * @param config the configuration\n-     * @param key the key\n+     * @param config       the configuration\n+     * @param key          the key\n      * @param defaultValue the default\n      * @return the configured value or default\n      */\n-    public static int getConfigParam(Map<String, ?> config, String key, int defaultValue) {\n+    public static int getConfigParam(Map<String, ?> config, String key,\n+                                     int defaultValue) {\n         Object o = config.get(key);\n         if (o instanceof Number) {\n             return ((Number) o).intValue();\n",
            "diff_size": 92
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "1157",
                    "column": "53",
                    "severity": "warning",
                    "message": "'typecast' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAfterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/errored/1/152/DataUtils.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/naturalize/152/DataUtils.java\nindex 45b80c522ba..203a84623b7 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/errored/1/152/DataUtils.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/naturalize/152/DataUtils.java\n@@ -1179,4 +1179,4 @@ public final class DataUtils {\n         return defaultValue;\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 1
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/errored/1/152/DataUtils.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/codebuff/152/DataUtils.java\nindex 45b80c522ba..64452f53711 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/errored/1/152/DataUtils.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/codebuff/152/DataUtils.java\n@@ -15,154 +15,209 @@ import java.text.MessageFormat;\n import java.util.Arrays;\n import java.util.HashMap;\n import java.util.Map;\n-\n import org.h2.engine.Constants;\n import org.h2.util.StringUtils;\n \n /**\n  * Utility methods\n  */\n+\n+\n public final class DataUtils {\n \n     /**\n      * An error occurred while reading from the file.\n      */\n+\n+\n     public static final int ERROR_READING_FAILED = 1;\n \n     /**\n      * An error occurred when trying to write to the file.\n      */\n+\n+\n     public static final int ERROR_WRITING_FAILED = 2;\n \n     /**\n      * An internal error occurred. This could be a bug, or a memory corruption\n      * (for example caused by out of memory).\n      */\n+\n+\n     public static final int ERROR_INTERNAL = 3;\n \n     /**\n      * The object is already closed.\n      */\n+\n+\n     public static final int ERROR_CLOSED = 4;\n \n     /**\n      * The file format is not supported.\n      */\n+\n+\n     public static final int ERROR_UNSUPPORTED_FORMAT = 5;\n \n     /**\n      * The file is corrupt or (for encrypted files) the encryption key is wrong.\n      */\n+\n+\n     public static final int ERROR_FILE_CORRUPT = 6;\n \n     /**\n      * The file is locked.\n      */\n+\n+\n     public static final int ERROR_FILE_LOCKED = 7;\n \n     /**\n      * An error occurred when serializing or de-serializing.\n      */\n+\n+\n     public static final int ERROR_SERIALIZATION = 8;\n \n     /**\n      * The application was trying to read data from a chunk that is no longer\n      * available.\n      */\n+\n+\n     public static final int ERROR_CHUNK_NOT_FOUND = 9;\n \n     /**\n      * The block in the stream store was not found.\n      */\n+\n+\n     public static final int ERROR_BLOCK_NOT_FOUND = 50;\n \n     /**\n      * The transaction store is corrupt.\n      */\n+\n+\n     public static final int ERROR_TRANSACTION_CORRUPT = 100;\n \n     /**\n      * An entry is still locked by another transaction.\n      */\n+\n+\n     public static final int ERROR_TRANSACTION_LOCKED = 101;\n \n     /**\n      * There are too many open transactions.\n      */\n+\n+\n     public static final int ERROR_TOO_MANY_OPEN_TRANSACTIONS = 102;\n \n     /**\n      * The transaction store is in an illegal state (for example, not yet\n      * initialized).\n      */\n+\n+\n     public static final int ERROR_TRANSACTION_ILLEGAL_STATE = 103;\n \n     /**\n      * The transaction contains too many changes.\n      */\n+\n+\n     public static final int ERROR_TRANSACTION_TOO_BIG = 104;\n \n     /**\n      * Deadlock discovered and one of transactions involved chosen as victim and rolled back.\n      */\n+\n+\n     public static final int ERROR_TRANSACTIONS_DEADLOCK = 105;\n \n     /**\n      * The transaction store can not be initialized because data type\n      * is not found in type registry.\n      */\n+\n+\n     public static final int ERROR_UNKNOWN_DATA_TYPE = 106;\n \n     /**\n      * The type for leaf page.\n      */\n+\n+\n     public static final int PAGE_TYPE_LEAF = 0;\n \n     /**\n      * The type for node page.\n      */\n+\n+\n     public static final int PAGE_TYPE_NODE = 1;\n \n     /**\n      * The bit mask for compressed pages (compression level fast).\n      */\n+\n+\n     public static final int PAGE_COMPRESSED = 2;\n \n     /**\n      * The bit mask for compressed pages (compression level high).\n      */\n+\n+\n     public static final int PAGE_COMPRESSED_HIGH = 2 + 4;\n \n     /**\n      * The bit mask for pages with page sequential number.\n      */\n+\n+\n     public static final int PAGE_HAS_PAGE_NO = 8;\n \n     /**\n      * The maximum length of a variable size int.\n      */\n+\n+\n     public static final int MAX_VAR_INT_LEN = 5;\n \n     /**\n      * The maximum length of a variable size long.\n      */\n+\n+\n     public static final int MAX_VAR_LONG_LEN = 10;\n \n     /**\n      * The maximum integer that needs less space when using variable size\n      * encoding (only 3 bytes instead of 4).\n      */\n+\n+\n     public static final int COMPRESSED_VAR_INT_MAX = 0x1fffff;\n \n     /**\n      * The maximum long that needs less space when using variable size\n      * encoding (only 7 bytes instead of 8).\n      */\n+\n+\n     public static final long COMPRESSED_VAR_LONG_MAX = 0x1ffffffffffffL;\n \n     /**\n      * The marker size of a very large page.\n      */\n+\n+\n     public static final int PAGE_LARGE = 2 * 1024 * 1024;\n \n     // The following are key prefixes used in meta map\n@@ -171,24 +226,32 @@ public final class DataUtils {\n      * The prefix for chunks (\"chunk.\"). This, plus the chunk id (hex encoded)\n      * is the key, and the serialized chunk metadata is the value.\n      */\n+\n+\n     public static final String META_CHUNK = \"chunk.\";\n \n     /**\n      * The prefix for names (\"name.\"). This, plus the name of the map, is the\n      * key, and the map id (hey encoded) is the value.\n      */\n+\n+\n     public static final String META_NAME = \"name.\";\n \n     /**\n      * The prefix for maps (\"map.\"). This, plus the map id (hex encoded) is the\n      * key, and the serialized in the map metadata is the value.\n      */\n+\n+\n     public static final String META_MAP = \"map.\";\n \n     /**\n      * The prefix for root positions of maps (\"root.\"). This, plus the map id\n      * (hex encoded) is the key, and the position (hex encoded) is the value.\n      */\n+\n+\n     public static final String META_ROOT = \"root.\";\n \n     /**\n@@ -197,16 +260,18 @@ public final class DataUtils {\n      * @param x the value\n      * @return the length in bytes\n      */\n+\n+\n     public static int getVarIntLen(int x) {\n         if ((x & (-1 << 7)) == 0) {\n             return 1;\n         } else if ((x & (-1 << 14)) == 0) {\n             return 2;\n-        } else if ((x & (-1 << 21)) == 0) {\n+                                          } else if ((x & (-1 << 21)) == 0) {\n             return 3;\n         } else if ((x & (-1 << 28)) == 0) {\n-            return 4;\n-        }\n+                                                     return 4;\n+                                                 }\n         return 5;\n     }\n \n@@ -216,6 +281,8 @@ public final class DataUtils {\n      * @param x the value\n      * @return the length in bytes\n      */\n+\n+\n     public static int getVarLongLen(long x) {\n         int i = 1;\n         while (true) {\n@@ -233,6 +300,8 @@ public final class DataUtils {\n      * @param buff the source buffer\n      * @return the value\n      */\n+\n+\n     public static int readVarInt(ByteBuffer buff) {\n         int b = buff.get();\n         if (b >= 0) {\n@@ -268,6 +337,8 @@ public final class DataUtils {\n      * @param buff the source buffer\n      * @return the value\n      */\n+\n+\n     public static long readVarLong(ByteBuffer buff) {\n         long x = buff.get();\n         if (x >= 0) {\n@@ -291,6 +362,8 @@ public final class DataUtils {\n      * @param x the value\n      * @throws IOException if some data could not be written\n      */\n+\n+\n     public static void writeVarInt(OutputStream out, int x) throws IOException {\n         while ((x & ~0x7f) != 0) {\n             out.write((byte) (x | 0x80));\n@@ -305,6 +378,8 @@ public final class DataUtils {\n      * @param buff the source buffer\n      * @param x the value\n      */\n+\n+\n     public static void writeVarInt(ByteBuffer buff, int x) {\n         while ((x & ~0x7f) != 0) {\n             buff.put((byte) (x | 0x80));\n@@ -320,8 +395,9 @@ public final class DataUtils {\n      * @param s the string\n      * @param len the number of characters\n      */\n-    public static void writeStringData(ByteBuffer buff,\n-            String s, int len) {\n+\n+\n+    public static void writeStringData(ByteBuffer buff, String s, int len) {\n         for (int i = 0; i < len; i++) {\n             int c = s.charAt(i);\n             if (c < 0x80) {\n@@ -330,7 +406,7 @@ public final class DataUtils {\n                 buff.put((byte) (0xe0 | (c >> 12)));\n                 buff.put((byte) (((c >> 6) & 0x3f)));\n                 buff.put((byte) (c & 0x3f));\n-            } else {\n+                                      } else {\n                 buff.put((byte) (0xc0 | (c >> 6)));\n                 buff.put((byte) (c & 0x3f));\n             }\n@@ -343,6 +419,8 @@ public final class DataUtils {\n      * @param buff the source buffer\n      * @return the value\n      */\n+\n+\n     public static String readString(ByteBuffer buff) {\n         return readString(buff, readVarInt(buff));\n     }\n@@ -354,6 +432,8 @@ public final class DataUtils {\n      * @param len the number of characters\n      * @return the value\n      */\n+\n+\n     public static String readString(ByteBuffer buff, int len) {\n         char[] chars = new char[len];\n         for (int i = 0; i < len; i++) {\n@@ -361,9 +441,8 @@ public final class DataUtils {\n             if (x < 0x80) {\n                 chars[i] = (char) x;\n             } else if (x >= 0xe0) {\n-                chars[i] = (char) (((x & 0xf) << 12)\n-                        + ((buff.get() & 0x3f) << 6) + (buff.get() & 0x3f));\n-            } else {\n+                chars[i] = (char) (((x & 0xf) << 12) + ((buff.get() & 0x3f) << 6) + (buff.get() & 0x3f));\n+                                      } else {\n                 chars[i] = (char) (((x & 0x1f) << 6) + (buff.get() & 0x3f));\n             }\n         }\n@@ -376,6 +455,8 @@ public final class DataUtils {\n      * @param buff the target buffer\n      * @param x the value\n      */\n+\n+\n     public static void writeVarLong(ByteBuffer buff, long x) {\n         while ((x & ~0x7f) != 0) {\n             buff.put((byte) (x | 0x80));\n@@ -391,8 +472,9 @@ public final class DataUtils {\n      * @param x the value\n      * @throws IOException if some data could not be written\n      */\n-    public static void writeVarLong(OutputStream out, long x)\n-            throws IOException {\n+\n+\n+    public static void writeVarLong(OutputStream out, long x) throws IOException {\n         while ((x & ~0x7f) != 0) {\n             out.write((byte) (x | 0x80));\n             x >>>= 7;\n@@ -408,14 +490,14 @@ public final class DataUtils {\n      * @param oldSize the size of the old array\n      * @param gapIndex the index of the gap\n      */\n-    public static void copyWithGap(Object src, Object dst, int oldSize,\n-            int gapIndex) {\n+\n+\n+    public static void copyWithGap(Object src, Object dst, int oldSize, int gapIndex) {\n         if (gapIndex > 0) {\n             System.arraycopy(src, 0, dst, 0, gapIndex);\n         }\n         if (gapIndex < oldSize) {\n-            System.arraycopy(src, gapIndex, dst, gapIndex + 1, oldSize\n-                    - gapIndex);\n+            System.arraycopy(src, gapIndex, dst, gapIndex + 1, oldSize - gapIndex);\n         }\n     }\n \n@@ -427,14 +509,14 @@ public final class DataUtils {\n      * @param oldSize the size of the old array\n      * @param removeIndex the index of the entry to remove\n      */\n-    public static void copyExcept(Object src, Object dst, int oldSize,\n-            int removeIndex) {\n+\n+\n+    public static void copyExcept(Object src, Object dst, int oldSize, int removeIndex) {\n         if (removeIndex > 0 && oldSize > 0) {\n             System.arraycopy(src, 0, dst, 0, removeIndex);\n         }\n         if (removeIndex < oldSize) {\n-            System.arraycopy(src, removeIndex + 1, dst, removeIndex, oldSize\n-                    - removeIndex - 1);\n+            System.arraycopy(src, removeIndex + 1, dst, removeIndex, oldSize - removeIndex - 1);\n         }\n     }\n \n@@ -447,6 +529,8 @@ public final class DataUtils {\n      * @param dst the byte buffer\n      * @throws IllegalStateException if some data could not be read\n      */\n+\n+\n     public static void readFully(FileChannel file, long pos, ByteBuffer dst) {\n         try {\n             do {\n@@ -464,11 +548,7 @@ public final class DataUtils {\n             } catch (IOException e2) {\n                 size = -1;\n             }\n-            throw newIllegalStateException(\n-                    ERROR_READING_FAILED,\n-                    \"Reading from file {0} failed at {1} (length {2}), \" +\n-                    \"read {3}, remaining {4}\",\n-                    file, pos, size, dst.position(), dst.remaining(), e);\n+            throw newIllegalStateException(ERROR_READING_FAILED, \"Reading from file {0} failed at {1} (length {2}), \" + \"read {3}, remaining {4}\", file, pos, size, dst.position(), dst.remaining(), e);\n         }\n     }\n \n@@ -479,6 +559,8 @@ public final class DataUtils {\n      * @param pos the absolute position within the file\n      * @param src the source buffer\n      */\n+\n+\n     public static void writeFully(FileChannel file, long pos, ByteBuffer src) {\n         try {\n             int off = 0;\n@@ -487,10 +569,7 @@ public final class DataUtils {\n                 off += len;\n             } while (src.remaining() > 0);\n         } catch (IOException e) {\n-            throw newIllegalStateException(\n-                    ERROR_WRITING_FAILED,\n-                    \"Writing to {0} failed; length {1} at {2}\",\n-                    file, src.remaining(), pos, e);\n+            throw newIllegalStateException(ERROR_WRITING_FAILED, \"Writing to {0} failed; length {1} at {2}\", file, src.remaining(), pos, e);\n         }\n     }\n \n@@ -500,6 +579,8 @@ public final class DataUtils {\n      * @param len the length\n      * @return the length code\n      */\n+\n+\n     public static int encodeLength(int len) {\n         if (len <= 32) {\n             return 0;\n@@ -533,6 +614,8 @@ public final class DataUtils {\n      * @param pos the position\n      * @return the chunk id\n      */\n+\n+\n     public static int getPageChunkId(long pos) {\n         return (int) (pos >>> 38);\n     }\n@@ -543,6 +626,8 @@ public final class DataUtils {\n      * @param tocElement packed table of content element\n      * @return the map id\n      */\n+\n+\n     public static int getPageMapId(long tocElement) {\n         return (int) (tocElement >>> 38);\n     }\n@@ -553,6 +638,8 @@ public final class DataUtils {\n      * @param pos the position\n      * @return the maximum length\n      */\n+\n+\n     public static int getPageMaxLength(long pos) {\n         int code = (int) ((pos >> 1) & 31);\n         return decodePageLength(code);\n@@ -565,6 +652,8 @@ public final class DataUtils {\n      * @param code encoded page length\n      * @return the maximum length\n      */\n+\n+\n     public static int decodePageLength(int code) {\n         if (code == 31) {\n             return PAGE_LARGE;\n@@ -578,6 +667,8 @@ public final class DataUtils {\n      * @param tocElement packed table of content element\n      * @return the offset\n      */\n+\n+\n     public static int getPageOffset(long tocElement) {\n         return (int) (tocElement >> 6);\n     }\n@@ -588,6 +679,8 @@ public final class DataUtils {\n      * @param pos the position\n      * @return the page type (PAGE_TYPE_NODE or PAGE_TYPE_LEAF)\n      */\n+\n+\n     public static int getPageType(long pos) {\n         return ((int) pos) & 1;\n     }\n@@ -597,6 +690,8 @@ public final class DataUtils {\n      * @param pos the position\n      * @return true if it is a leaf, false otherwise\n      */\n+\n+\n     public static boolean isLeafPosition(long pos) {\n         return getPageType(pos) == PAGE_TYPE_LEAF;\n     }\n@@ -607,6 +702,8 @@ public final class DataUtils {\n      * @param pos the position\n      * @return true if page has been saved\n      */\n+\n+\n     public static boolean isPageSaved(long pos) {\n         return (pos & ~1L) != 0;\n     }\n@@ -618,6 +715,8 @@ public final class DataUtils {\n      * @return true if page has been removed (no longer accessible from the\n      *         current root of the tree)\n      */\n+\n+\n     static boolean isPageRemoved(long pos) {\n         return pos == 1L;\n     }\n@@ -633,6 +732,8 @@ public final class DataUtils {\n      * @param type the page type (1 for node, 0 for leaf)\n      * @return the position\n      */\n+\n+\n     public static long getPagePos(int chunkId, int offset, int length, int type) {\n         long pos = (long) chunkId << 38;\n         pos |= (long) offset << 6;\n@@ -647,6 +748,8 @@ public final class DataUtils {\n      * @param tocElement\n      * @return\n      */\n+\n+\n     public static long getPagePos(int chunkId, long tocElement) {\n         return (tocElement & 0x3FFFFFFFFFL) | ((long) chunkId << 38);\n     }\n@@ -662,6 +765,8 @@ public final class DataUtils {\n      * @param type the page type (1 for node, 0 for leaf)\n      * @return the position\n      */\n+\n+\n     public static long getTocElement(int mapId, int offset, int length, int type) {\n         long pos = (long) mapId << 38;\n         pos |= (long) offset << 6;\n@@ -678,6 +783,8 @@ public final class DataUtils {\n      * @param x the value\n      * @return the check value\n      */\n+\n+\n     public static short getCheckValue(int x) {\n         return (short) ((x >> 16) ^ x);\n     }\n@@ -689,6 +796,8 @@ public final class DataUtils {\n      * @param map the map\n      * @return the string builder\n      */\n+\n+\n     public static StringBuilder appendMap(StringBuilder buff, HashMap<String, ?> map) {\n         Object[] keys = map.keySet().toArray();\n         Arrays.sort(keys);\n@@ -699,7 +808,7 @@ public final class DataUtils {\n                 appendMap(buff, key, (long) value);\n             } else if (value instanceof Integer) {\n                 appendMap(buff, key, (int) value);\n-            } else {\n+                              } else {\n                 appendMap(buff, key, value.toString());\n             }\n         }\n@@ -722,6 +831,8 @@ public final class DataUtils {\n      * @param key the key\n      * @param value the value\n      */\n+\n+\n     public static void appendMap(StringBuilder buff, String key, String value) {\n         appendMapKey(buff, key);\n         if (value.indexOf(',') < 0 && value.indexOf('\\\"') < 0) {\n@@ -747,6 +858,8 @@ public final class DataUtils {\n      * @param key the key\n      * @param value the value\n      */\n+\n+\n     public static void appendMap(StringBuilder buff, String key, long value) {\n         appendMapKey(buff, key).append(Long.toHexString(value));\n     }\n@@ -759,6 +872,8 @@ public final class DataUtils {\n      * @param key the key\n      * @param value the value\n      */\n+\n+\n     public static void appendMap(StringBuilder buff, String key, int value) {\n         appendMapKey(buff, key).append(Integer.toHexString(value));\n     }\n@@ -770,6 +885,7 @@ public final class DataUtils {\n      * @param size stop offset (exclusive)\n      * @return new offset\n      */\n+\n     private static int parseMapValue(StringBuilder buff, String s, int i, int size) {\n         while (i < size) {\n             char c = s.charAt(i++);\n@@ -788,7 +904,7 @@ public final class DataUtils {\n                     }\n                     buff.append(c);\n                 }\n-            } else {\n+                         } else {\n                 buff.append(c);\n             }\n         }\n@@ -802,8 +918,10 @@ public final class DataUtils {\n      * @return the map\n      * @throws IllegalStateException if parsing failed\n      */\n+\n+\n     public static HashMap<String, String> parseMap(String s) {\n-        HashMap<String, String> map = new HashMap<>();\n+        HashMap<String, String> map = new HashMap< >();\n         StringBuilder buff = new StringBuilder();\n         for (int i = 0, size = s.length(); i < size;) {\n             int startKey = i;\n@@ -826,6 +944,8 @@ public final class DataUtils {\n      * @return the map without mapping for {@code \"fletcher\"}, or {@code null} if checksum is wrong\n      *              or parameter do not represent a properly formatted map serialization\n      */\n+\n+\n     static HashMap<String, String> parseChecksummedMap(byte[] bytes) {\n         int start = 0, end = bytes.length;\n         while (start < end && bytes[start] <= ' ') {\n@@ -835,7 +955,7 @@ public final class DataUtils {\n             end--;\n         }\n         String s = new String(bytes, start, end - start, StandardCharsets.ISO_8859_1);\n-        HashMap<String, String> map = new HashMap<>();\n+        HashMap<String, String> map = new HashMap< >();\n         StringBuilder buff = new StringBuilder();\n         for (int i = 0, size = s.length(); i < size;) {\n             int startKey = i;\n@@ -869,6 +989,8 @@ public final class DataUtils {\n      * @return value of name item, or {@code null}\n      * @throws IllegalStateException if parsing failed\n      */\n+\n+\n     public static String getMapName(String s) {\n         return getFromMap(s, \"name\");\n     }\n@@ -881,6 +1003,8 @@ public final class DataUtils {\n      * @return value of the specified item, or {@code null}\n      * @throws IllegalStateException if parsing failed\n      */\n+\n+\n     public static String getFromMap(String s, String key) {\n         int keyLength = key.length();\n         for (int i = 0, size = s.length(); i < size;) {\n@@ -924,6 +1048,8 @@ public final class DataUtils {\n      * @param length the message length (if odd, 0 is appended)\n      * @return the checksum\n      */\n+\n+\n     public static int getFletcher32(byte[] bytes, int offset, int length) {\n         int s1 = 0xffff, s2 = 0xffff;\n         int i = offset, len = offset + (length & ~1);\n@@ -954,8 +1080,9 @@ public final class DataUtils {\n      * @param arguments the arguments\n      * @throws IllegalArgumentException if the argument is invalid\n      */\n-    public static void checkArgument(boolean test, String message,\n-            Object... arguments) {\n+\n+\n+    public static void checkArgument(boolean test, String message, Object... arguments) {\n         if (!test) {\n             throw newIllegalArgumentException(message, arguments);\n         }\n@@ -968,11 +1095,10 @@ public final class DataUtils {\n      * @param arguments the arguments\n      * @return the exception\n      */\n-    public static IllegalArgumentException newIllegalArgumentException(\n-            String message, Object... arguments) {\n-        return initCause(new IllegalArgumentException(\n-                formatMessage(0, message, arguments)),\n-                arguments);\n+\n+\n+    public static IllegalArgumentException newIllegalArgumentException(String message, Object... arguments) {\n+        return initCause(new IllegalArgumentException(formatMessage(0, message, arguments)), arguments);\n     }\n \n     /**\n@@ -981,8 +1107,9 @@ public final class DataUtils {\n      * @param message the message\n      * @return the exception\n      */\n-    public static UnsupportedOperationException\n-            newUnsupportedOperationException(String message) {\n+\n+\n+    public static UnsupportedOperationException newUnsupportedOperationException(String message) {\n         return new UnsupportedOperationException(formatMessage(0, message));\n     }\n \n@@ -994,11 +1121,10 @@ public final class DataUtils {\n      * @param arguments the arguments\n      * @return the exception\n      */\n-    public static IllegalStateException newIllegalStateException(\n-            int errorCode, String message, Object... arguments) {\n-        return initCause(new IllegalStateException(\n-                formatMessage(errorCode, message, arguments)),\n-                arguments);\n+\n+\n+    public static IllegalStateException newIllegalStateException(int errorCode, String message, Object... arguments) {\n+        return initCause(new IllegalStateException(formatMessage(errorCode, message, arguments)), arguments);\n     }\n \n     private static <T extends Exception> T initCause(T e, Object... arguments) {\n@@ -1020,8 +1146,9 @@ public final class DataUtils {\n      * @param arguments the arguments\n      * @return the formatted message\n      */\n-    public static String formatMessage(int errorCode, String message,\n-            Object... arguments) {\n+\n+\n+    public static String formatMessage(int errorCode, String message, Object... arguments) {\n         // convert arguments to strings, to avoid locale specific formatting\n         arguments = arguments.clone();\n         for (int i = 0; i < arguments.length; i++) {\n@@ -1034,10 +1161,11 @@ public final class DataUtils {\n                 arguments[i] = s;\n             }\n         }\n-        return MessageFormat.format(message, arguments) +\n-                \" [\" + Constants.VERSION_MAJOR + \".\" +\n-                Constants.VERSION_MINOR + \".\" + Constants.BUILD_ID +\n-                \"/\" + errorCode + \"]\";\n+        return MessageFormat.format(message, arguments) + \" [\"\n+        + Constants.VERSION_MAJOR + \".\"\n+        + Constants.VERSION_MINOR + \".\"\n+        + Constants.BUILD_ID + \"/\"\n+        + errorCode + \"]\";\n     }\n \n     /**\n@@ -1046,6 +1174,8 @@ public final class DataUtils {\n      * @param m the message\n      * @return the error code, or 0 if none\n      */\n+\n+\n     public static int getErrorCode(String m) {\n         if (m != null && m.endsWith(\"]\")) {\n             int dash = m.lastIndexOf('/');\n@@ -1054,6 +1184,7 @@ public final class DataUtils {\n                     return StringUtils.parseUInt31(m, dash + 1, m.length() - 1);\n                 } catch (NumberFormatException e) {\n                     // no error code\n+\n                 }\n             }\n         }\n@@ -1069,6 +1200,8 @@ public final class DataUtils {\n      * @return the parsed value\n      * @throws IllegalStateException if parsing fails\n      */\n+\n+\n     public static long readHexLong(Map<String, ?> map, String key, long defaultValue) {\n         Object v = map.get(key);\n         if (v == null) {\n@@ -1079,8 +1212,7 @@ public final class DataUtils {\n         try {\n             return parseHexLong((String) v);\n         } catch (NumberFormatException e) {\n-            throw newIllegalStateException(ERROR_FILE_CORRUPT,\n-                    \"Error parsing the value {0}\", v, e);\n+            throw newIllegalStateException(ERROR_FILE_CORRUPT, \"Error parsing the value {0}\", v, e);\n         }\n     }\n \n@@ -1091,18 +1223,18 @@ public final class DataUtils {\n      * @return the parsed value\n      * @throws IllegalStateException if parsing fails\n      */\n+\n+\n     public static long parseHexLong(String x) {\n         try {\n             if (x.length() == 16) {\n                 // avoid problems with overflow\n                 // in Java 8, this special case is not needed\n-                return (Long.parseLong(x.substring(0, 8), 16) << 32) |\n-                        Long.parseLong(x.substring(8, 16), 16);\n+                return (Long.parseLong(x.substring(0, 8), 16) << 32) | Long.parseLong(x.substring(8, 16), 16);\n             }\n             return Long.parseLong(x, 16);\n         } catch (NumberFormatException e) {\n-            throw newIllegalStateException(ERROR_FILE_CORRUPT,\n-                    \"Error parsing the value {0}\", x, e);\n+            throw newIllegalStateException(ERROR_FILE_CORRUPT, \"Error parsing the value {0}\", x, e);\n         }\n     }\n \n@@ -1113,14 +1245,15 @@ public final class DataUtils {\n      * @return the parsed value\n      * @throws IllegalStateException if parsing fails\n      */\n+\n+\n     public static int parseHexInt(String x) {\n         try {\n             // avoid problems with overflow\n             // in Java 8, we can use Integer.parseLong(x, 16);\n             return (int) Long.parseLong(x, 16);\n         } catch (NumberFormatException e) {\n-            throw newIllegalStateException(ERROR_FILE_CORRUPT,\n-                    \"Error parsing the value {0}\", x, e);\n+            throw newIllegalStateException(ERROR_FILE_CORRUPT, \"Error parsing the value {0}\", x, e);\n         }\n     }\n \n@@ -1133,6 +1266,8 @@ public final class DataUtils {\n      * @return the parsed value\n      * @throws IllegalStateException if parsing fails\n      */\n+\n+\n     public static int readHexInt(Map<String, ?> map, String key, int defaultValue) {\n         Object v = map.get(key);\n         if (v == null) {\n@@ -1144,17 +1279,17 @@ public final class DataUtils {\n             // support unsigned hex value\n             return (int) Long.parseLong((String) v, 16);\n         } catch (NumberFormatException e) {\n-            throw newIllegalStateException(ERROR_FILE_CORRUPT,\n-                    \"Error parsing the value {0}\", v, e);\n+            throw newIllegalStateException(ERROR_FILE_CORRUPT, \"Error parsing the value {0}\", v, e);\n         }\n     }\n \n+\n     public static byte[] parseHexBytes(Map<String, ?> map, String key) {\n         Object v = map.get(key);\n         if (v == null) {\n             return null;\n         }\n-        return StringUtils.convertHexToBytes((String)v);\n+        return StringUtils.convertHexToBytes((String) v);\n     }\n \n     /**\n@@ -1165,6 +1300,8 @@ public final class DataUtils {\n      * @param defaultValue the default\n      * @return the configured value or default\n      */\n+\n+\n     public static int getConfigParam(Map<String, ?> config, String key, int defaultValue) {\n         Object o = config.get(key);\n         if (o instanceof Number) {\n@@ -1174,9 +1311,10 @@ public final class DataUtils {\n                 return Integer.decode(o.toString());\n             } catch (NumberFormatException e) {\n                 // ignore\n+\n             }\n         }\n         return defaultValue;\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 221
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/errored/1/152/DataUtils.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/styler_random/152/DataUtils.java\nindex 45b80c522ba..0856a153484 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/errored/1/152/DataUtils.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/styler_random/152/DataUtils.java\n@@ -1154,7 +1154,7 @@ public final class DataUtils {\n         if (v == null) {\n             return null;\n         }\n-        return StringUtils.convertHexToBytes((String)v);\n+        return StringUtils.convertHexToBytes((String) v);\n     }\n \n     /**\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/errored/1/152/DataUtils.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/styler_three_grams/152/DataUtils.java\nindex 45b80c522ba..0856a153484 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/errored/1/152/DataUtils.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/styler_three_grams/152/DataUtils.java\n@@ -1154,7 +1154,7 @@ public final class DataUtils {\n         if (v == null) {\n             return null;\n         }\n-        return StringUtils.convertHexToBytes((String)v);\n+        return StringUtils.convertHexToBytes((String) v);\n     }\n \n     /**\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "styler",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "intellij",
        "naturalize"
    ]
}