{
    "project_name": "graphfoundation-ongdb",
    "error_id": "2959",
    "information": {
        "errors": [
            {
                "line": "1",
                "severity": "error",
                "message": "Missing, wrong or duplicated license header",
                "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
            }
        ]
    },
    "source_code": "/*\n * Copyright (c) 2002-2020 \"Neo4j,\"\n * Neo4j Sweden AB [http://neo4j.com]\n *",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "1",
                    "severity": "error",
                    "message": "Missing, wrong or duplicated license header",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "1",
                    "severity": "error",
                    "message": "Missing, wrong or duplicated license header",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                },
                {
                    "line": "78",
                    "column": "23",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "82",
                    "column": "57",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "107",
                    "column": "20",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "107",
                    "column": "32",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "111",
                    "column": "8",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "111",
                    "column": "24",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "122",
                    "column": "9",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "122",
                    "column": "31",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "124",
                    "column": "11",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "124",
                    "column": "33",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "131",
                    "column": "9",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "131",
                    "column": "29",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "138",
                    "column": "9",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "138",
                    "column": "53",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "142",
                    "column": "10",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "142",
                    "column": "35",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "148",
                    "column": "10",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "149",
                    "column": "58",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "154",
                    "column": "10",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "155",
                    "column": "58",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "163",
                    "column": "9",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "163",
                    "column": "31",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "165",
                    "column": "11",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "165",
                    "column": "33",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "167",
                    "column": "13",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "167",
                    "column": "35",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "171",
                    "column": "14",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "171",
                    "column": "72",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "189",
                    "column": "26",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "189",
                    "column": "49",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "202",
                    "column": "28",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "202",
                    "column": "60",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "209",
                    "column": "11",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "209",
                    "column": "32",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/errored/1/2959/FloydWarshall.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/intellij/2959/FloydWarshall.java\nindex 747e81bd28b..20c83a48517 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/errored/1/2959/FloydWarshall.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/intellij/2959/FloydWarshall.java\n@@ -17,6 +17,7 @@\n  * You should have received a copy of the GNU General Public License\n  * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n  */\n+\n package org.neo4j.graphalgo.impl.shortestpath;\n \n import java.util.Comparator;\n@@ -35,190 +36,183 @@ import org.neo4j.graphdb.Relationship;\n /**\n  * This provides an implementation of the Floyd Warshall algorithm solving the\n  * all pair shortest path problem.\n- * @complexity The {@link CostEvaluator} is called once for every relationship.\n- *             The {@link CostAccumulator} and cost comparator are both called\n- *             n^3 times. Assuming they run in constant time, the time\n- *             complexity for this algorithm is O(n^3).\n+ *\n+ * @param <CostType> The datatype the edge weights are represented by.\n  * @author Patrik Larsson\n- * @param <CostType>\n- *            The datatype the edge weights are represented by.\n+ * @complexity The {@link CostEvaluator} is called once for every relationship.\n+ * The {@link CostAccumulator} and cost comparator are both called\n+ * n^3 times. Assuming they run in constant time, the time\n+ * complexity for this algorithm is O(n^3).\n  */\n public class FloydWarshall<CostType>\n {\n-    protected CostType startCost; // starting cost for all nodes\n-    protected CostType infinitelyBad; // starting value for calculation\n-    protected Direction relationDirection;\n-    protected CostEvaluator<CostType> costEvaluator;\n-    protected CostAccumulator<CostType> costAccumulator;\n-    protected Comparator<CostType> costComparator;\n-    protected Set<Node> nodeSet;\n-    protected Set<Relationship> relationshipSet;\n-    CostType[][] costMatrix;\n-    Integer[][] predecessors;\n-    Map<Node,Integer> nodeIndexes; // node ->index\n-    Node[] IndexedNodes; // index -> node\n-    protected boolean doneCalculation;\n+  protected CostType startCost; // starting cost for all nodes\n+  protected CostType infinitelyBad; // starting value for calculation\n+  protected Direction relationDirection;\n+  protected CostEvaluator<CostType> costEvaluator;\n+  protected CostAccumulator<CostType> costAccumulator;\n+  protected Comparator<CostType> costComparator;\n+  protected Set<Node> nodeSet;\n+  protected Set<Relationship> relationshipSet;\n+  CostType[][] costMatrix;\n+  Integer[][] predecessors;\n+  Map<Node, Integer> nodeIndexes; // node ->index\n+  Node[] IndexedNodes; // index -> node\n+  protected boolean doneCalculation;\n+\n+  /**\n+   * @param startCost         The cost for just starting (or ending) a path in a node.\n+   * @param infinitelyBad     A cost worse than all others. This is used to initialize the\n+   *                          distance matrix.\n+   * @param relationDirection The direction in which the paths should follow the\n+   *                          relationships.\n+   * @param costEvaluator\n+   * @param costAccumulator\n+   * @param costComparator\n+   * @param nodeSet           The set of nodes the calculation should be run on.\n+   * @param relationshipSet   The set of relationships that should be processed.\n+   * @see {@link CostEvaluator}\n+   * @see {@link CostAccumulator}\n+   * @see {@link CostAccumulator} or {@link CostEvaluator}\n+   */\n+  public FloydWarshall(CostType startCost, CostType infinitelyBad,\n+                       Direction relationDirection, CostEvaluator<CostType> costEvaluator,\n+                       CostAccumulator<CostType> costAccumulator,\n+                       Comparator<CostType> costComparator, Set<Node> nodeSet,\n+                       Set<Relationship> relationshipSet)\n+  {\n+    super();\n+    this.startCost = startCost;\n+    this.infinitelyBad = infinitelyBad;\n+    this.relationDirection = relationDirection;\n+    this.costEvaluator = costEvaluator;\n+    this.costAccumulator = costAccumulator;\n+    this.costComparator = costComparator;\n+    this.nodeSet = nodeSet;\n+    this.relationshipSet = relationshipSet;\n+  }\n+\n+  /**\n+   * This resets the calculation if we for some reason would like to redo it.\n+   */\n+  public void reset()\n+  {\n+    doneCalculation = false;\n+  }\n \n-    /**\n-     * @param startCost\n-     *            The cost for just starting (or ending) a path in a node.\n-     * @param infinitelyBad\n-     *            A cost worse than all others. This is used to initialize the\n-     *            distance matrix.\n-     * @param relationDirection\n-     *            The direction in which the paths should follow the\n-     *            relationships.\n-     * @param costEvaluator\n-     * @see {@link CostEvaluator}\n-     * @param costAccumulator\n-     * @see {@link CostAccumulator}\n-     * @param costComparator\n-     * @see {@link CostAccumulator} or {@link CostEvaluator}\n-     * @param nodeSet\n-     *            The set of nodes the calculation should be run on.\n-     * @param relationshipSet\n-     *            The set of relationships that should be processed.\n-     */\n-    public FloydWarshall( CostType startCost, CostType infinitelyBad,\n-        Direction relationDirection, CostEvaluator<CostType> costEvaluator,\n-        CostAccumulator<CostType> costAccumulator,\n-        Comparator<CostType> costComparator, Set<Node> nodeSet,\n-        Set<Relationship> relationshipSet )\n+  /**\n+   * Internal calculate method that will do the calculation. This can however\n+   * be called externally to manually trigger the calculation.\n+   */\n+  @SuppressWarnings(\"unchecked\")\n+  public void calculate()\n+  {\n+    // Don't do it more than once\n+    if (doneCalculation)\n     {\n-        super();\n-        this.startCost = startCost;\n-        this.infinitelyBad = infinitelyBad;\n-        this.relationDirection = relationDirection;\n-        this.costEvaluator = costEvaluator;\n-        this.costAccumulator = costAccumulator;\n-        this.costComparator = costComparator;\n-        this.nodeSet = nodeSet;\n-        this.relationshipSet = relationshipSet;\n+      return;\n     }\n-\n-    /**\n-     * This resets the calculation if we for some reason would like to redo it.\n-     */\n-    public void reset()\n+    doneCalculation = true;\n+    // Build initial matrix\n+    int n = nodeSet.size();\n+    costMatrix = (CostType[][]) new Object[n][n];\n+    predecessors = new Integer[n][n];\n+    IndexedNodes = new Node[n];\n+    nodeIndexes = new HashMap<>();\n+    for (int i = 0; i < n; ++i)\n     {\n-        doneCalculation = false;\n+      for (int j = 0; j < n; ++j)\n+      {\n+        costMatrix[i][j] = infinitelyBad;\n+      }\n+      costMatrix[i][i] = startCost;\n     }\n-\n-    /**\n-     * Internal calculate method that will do the calculation. This can however\n-     * be called externally to manually trigger the calculation.\n-     */\n-    @SuppressWarnings( \"unchecked\" )\n-    public void calculate()\n+    int nodeIndex = 0;\n+    for (Node node : nodeSet)\n     {\n-        // Don't do it more than once\n-        if ( doneCalculation )\n-        {\n-            return;\n-        }\n-        doneCalculation = true;\n-        // Build initial matrix\n-        int n = nodeSet.size();\n-        costMatrix = (CostType[][]) new Object[n][n];\n-        predecessors = new Integer[n][n];\n-        IndexedNodes = new Node[n];\n-        nodeIndexes = new HashMap<>();\n-        for ( int i = 0; i < n; ++i )\n-        {\n-            for ( int j = 0; j < n; ++j )\n-            {\n-                costMatrix[i][j] = infinitelyBad;\n-            }\n-            costMatrix[i][i] = startCost;\n-        }\n-        int nodeIndex = 0;\n-        for ( Node node : nodeSet )\n-        {\n-            nodeIndexes.put( node, nodeIndex );\n-            IndexedNodes[nodeIndex] = node;\n-            ++nodeIndex;\n-        }\n-        // Put the relationships in there\n-        for ( Relationship relationship : relationshipSet )\n-        {\n-            Integer i1 = nodeIndexes.get( relationship.getStartNode() );\n-            Integer i2 = nodeIndexes.get( relationship.getEndNode() );\n-            if ( i1 == null || i2 == null )\n-            {\n-                // TODO: what to do here? pretend nothing happened? cast\n-                // exception?\n-                continue;\n-            }\n-            if ( relationDirection.equals( Direction.BOTH )\n-                || relationDirection.equals( Direction.OUTGOING ) )\n-            {\n-                costMatrix[i1][i2] = costEvaluator.getCost( relationship, Direction.OUTGOING );\n-                predecessors[i1][i2] = i1;\n-            }\n-            if ( relationDirection.equals( Direction.BOTH )\n-                || relationDirection.equals( Direction.INCOMING ) )\n-            {\n-                costMatrix[i2][i1] = costEvaluator.getCost( relationship,\n-                        Direction.INCOMING );\n-                predecessors[i2][i1] = i2;\n-            }\n-        }\n-        // Do it!\n-        for ( int v = 0; v < n; ++v )\n-        {\n-            for ( int i = 0; i < n; ++i )\n-            {\n-                for ( int j = 0; j < n; ++j )\n-                {\n-                    CostType alternative = costAccumulator.addCosts(\n-                        costMatrix[i][v], costMatrix[v][j] );\n-                    if ( costComparator.compare( costMatrix[i][j], alternative ) > 0 )\n-                    {\n-                        costMatrix[i][j] = alternative;\n-                        predecessors[i][j] = predecessors[v][j];\n-                    }\n-                }\n-            }\n-        }\n-        // TODO: detect negative cycles?\n+      nodeIndexes.put(node, nodeIndex);\n+      IndexedNodes[nodeIndex] = node;\n+      ++nodeIndex;\n     }\n-\n-    /**\n-     * This returns the cost for the shortest path between two nodes.\n-     * @param node1\n-     *            The start node.\n-     * @param node2\n-     *            The end node.\n-     * @return The cost for the shortest path.\n-     */\n-    public CostType getCost( Node node1, Node node2 )\n+    // Put the relationships in there\n+    for (Relationship relationship : relationshipSet)\n     {\n-        calculate();\n-        return costMatrix[nodeIndexes.get( node1 )][nodeIndexes.get( node2 )];\n+      Integer i1 = nodeIndexes.get(relationship.getStartNode());\n+      Integer i2 = nodeIndexes.get(relationship.getEndNode());\n+      if (i1 == null || i2 == null)\n+      {\n+        // TODO: what to do here? pretend nothing happened? cast\n+        // exception?\n+        continue;\n+      }\n+      if (relationDirection.equals(Direction.BOTH)\n+          || relationDirection.equals(Direction.OUTGOING))\n+      {\n+        costMatrix[i1][i2] = costEvaluator.getCost(relationship, Direction.OUTGOING);\n+        predecessors[i1][i2] = i1;\n+      }\n+      if (relationDirection.equals(Direction.BOTH)\n+          || relationDirection.equals(Direction.INCOMING))\n+      {\n+        costMatrix[i2][i1] = costEvaluator.getCost(relationship,\n+            Direction.INCOMING);\n+        predecessors[i2][i1] = i2;\n+      }\n     }\n-\n-    /**\n-     * This returns the shortest path between two nodes as list of nodes.\n-     * @param startNode\n-     *            The start node.\n-     * @param targetNode\n-     *            The end node.\n-     * @return The shortest path as a list of nodes.\n-     */\n-    public List<Node> getPath( Node startNode, Node targetNode )\n+    // Do it!\n+    for (int v = 0; v < n; ++v)\n     {\n-        calculate();\n-        LinkedList<Node> path = new LinkedList<>();\n-        int index = nodeIndexes.get( targetNode );\n-        int startIndex = nodeIndexes.get( startNode );\n-        Node n = targetNode;\n-        while ( !n.equals( startNode ) )\n+      for (int i = 0; i < n; ++i)\n+      {\n+        for (int j = 0; j < n; ++j)\n         {\n-            path.addFirst( n );\n-            index = predecessors[startIndex][index];\n-            n = IndexedNodes[index];\n+          CostType alternative = costAccumulator.addCosts(\n+              costMatrix[i][v], costMatrix[v][j]);\n+          if (costComparator.compare(costMatrix[i][j], alternative) > 0)\n+          {\n+            costMatrix[i][j] = alternative;\n+            predecessors[i][j] = predecessors[v][j];\n+          }\n         }\n-        path.addFirst( n );\n-        return path;\n+      }\n+    }\n+    // TODO: detect negative cycles?\n+  }\n+\n+  /**\n+   * This returns the cost for the shortest path between two nodes.\n+   *\n+   * @param node1 The start node.\n+   * @param node2 The end node.\n+   * @return The cost for the shortest path.\n+   */\n+  public CostType getCost(Node node1, Node node2)\n+  {\n+    calculate();\n+    return costMatrix[nodeIndexes.get(node1)][nodeIndexes.get(node2)];\n+  }\n+\n+  /**\n+   * This returns the shortest path between two nodes as list of nodes.\n+   *\n+   * @param startNode  The start node.\n+   * @param targetNode The end node.\n+   * @return The shortest path as a list of nodes.\n+   */\n+  public List<Node> getPath(Node startNode, Node targetNode)\n+  {\n+    calculate();\n+    LinkedList<Node> path = new LinkedList<>();\n+    int index = nodeIndexes.get(targetNode);\n+    int startIndex = nodeIndexes.get(startNode);\n+    Node n = targetNode;\n+    while (!n.equals(startNode))\n+    {\n+      path.addFirst(n);\n+      index = predecessors[startIndex][index];\n+      n = IndexedNodes[index];\n     }\n+    path.addFirst(n);\n+    return path;\n+  }\n }\n",
            "diff_size": 280
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "1",
                    "severity": "error",
                    "message": "Missing, wrong or duplicated license header",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                },
                {
                    "line": "82",
                    "severity": "error",
                    "message": "Line is longer than 160 characters (found 272).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "151",
                    "column": "48",
                    "severity": "error",
                    "message": "'||' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                },
                {
                    "line": "157",
                    "column": "48",
                    "severity": "error",
                    "message": "'||' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/errored/1/2959/FloydWarshall.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/naturalize/2959/FloydWarshall.java\nindex 747e81bd28b..ac397044737 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/errored/1/2959/FloydWarshall.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/naturalize/2959/FloydWarshall.java\n@@ -79,12 +79,8 @@ public class FloydWarshall<CostType>\n      * @param relationshipSet\n      *            The set of relationships that should be processed.\n      */\n-    public FloydWarshall( CostType startCost, CostType infinitelyBad,\n-        Direction relationDirection, CostEvaluator<CostType> costEvaluator,\n-        CostAccumulator<CostType> costAccumulator,\n-        Comparator<CostType> costComparator, Set<Node> nodeSet,\n-        Set<Relationship> relationshipSet )\n-    {\n+    public FloydWarshall( CostType startCost, CostType infinitelyBad, Direction relationDirection, CostEvaluator<CostType> costEvaluator, CostAccumulator<CostType> costAccumulator, Comparator<CostType> costComparator, Set<Node> nodeSet, Set<Relationship> relationshipSet )\n+{\n         super();\n         this.startCost = startCost;\n         this.infinitelyBad = infinitelyBad;\n@@ -116,7 +112,8 @@ public class FloydWarshall<CostType>\n         {\n             return;\n         }\n-        doneCalculation = true;\n+\n+doneCalculation = true;\n         // Build initial matrix\n         int n = nodeSet.size();\n         costMatrix = (CostType[][]) new Object[n][n];\n@@ -129,7 +126,8 @@ public class FloydWarshall<CostType>\n             {\n                 costMatrix[i][j] = infinitelyBad;\n             }\n-            costMatrix[i][i] = startCost;\n+\n+costMatrix[i][i] = startCost;\n         }\n         int nodeIndex = 0;\n         for ( Node node : nodeSet )\n@@ -149,18 +147,18 @@ public class FloydWarshall<CostType>\n                 // exception?\n                 continue;\n             }\n-            if ( relationDirection.equals( Direction.BOTH )\n-                || relationDirection.equals( Direction.OUTGOING ) )\n-            {\n+\n+if ( relationDirection.equals( Direction.BOTH )|| relationDirection.equals( Direction.OUTGOING ) )\n+{\n                 costMatrix[i1][i2] = costEvaluator.getCost( relationship, Direction.OUTGOING );\n                 predecessors[i1][i2] = i1;\n             }\n-            if ( relationDirection.equals( Direction.BOTH )\n-                || relationDirection.equals( Direction.INCOMING ) )\n-            {\n+\n+if ( relationDirection.equals( Direction.BOTH )|| relationDirection.equals( Direction.INCOMING ) )\n+{\n                 costMatrix[i2][i1] = costEvaluator.getCost( relationship,\n                         Direction.INCOMING );\n-                predecessors[i2][i1] = i2;\n+predecessors[i2][i1] = i2;\n             }\n         }\n         // Do it!\n@@ -170,9 +168,8 @@ public class FloydWarshall<CostType>\n             {\n                 for ( int j = 0; j < n; ++j )\n                 {\n-                    CostType alternative = costAccumulator.addCosts(\n-                        costMatrix[i][v], costMatrix[v][j] );\n-                    if ( costComparator.compare( costMatrix[i][j], alternative ) > 0 )\n+                    CostType alternative = costAccumulator.addCosts( costMatrix[i][v], costMatrix[v][j] );\n+if ( costComparator.compare( costMatrix[i][j], alternative ) > 0 )\n                     {\n                         costMatrix[i][j] = alternative;\n                         predecessors[i][j] = predecessors[v][j];\n@@ -221,4 +218,4 @@ public class FloydWarshall<CostType>\n         path.addFirst( n );\n         return path;\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 21
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "1",
                    "severity": "error",
                    "message": "Missing, wrong or duplicated license header",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "1",
                    "severity": "error",
                    "message": "Missing, wrong or duplicated license header",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ],
    "repaired_by": [],
    "not_repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}