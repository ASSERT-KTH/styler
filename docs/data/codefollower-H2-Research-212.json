{
    "project_name": "codefollower-H2-Research",
    "error_id": "212",
    "information": {
        "errors": [
            {
                "line": "938",
                "column": "20",
                "severity": "warning",
                "message": "Don't use trailing comments.",
                "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
            }
        ]
    },
    "source_code": "        case Types.TIMESTAMP:\n            return Value.TIMESTAMP;\n        case 2014: // Types.TIMESTAMP_WITH_TIMEZONE\n            return Value.TIMESTAMP_TZ;\n        case Types.BLOB:\n            return Value.BLOB;",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/212/DataType.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler/212/DataType.java\nindex 25d132e0f11..da906597475 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/212/DataType.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler/212/DataType.java\n@@ -935,8 +935,9 @@ public class DataType {\n             return Value.TIME;\n         case Types.TIMESTAMP:\n             return Value.TIMESTAMP;\n-        case 2014: // Types.TIMESTAMP_WITH_TIMEZONE\n-            return Value.TIMESTAMP_TZ;\n+        case 2014:\n+        // Types.TIMESTAMP_WITH_TIMEZONE return Value.TIMESTAMP_TZ;\n+     return Value.TIMESTAMP_TZ;\n         case Types.BLOB:\n             return Value.BLOB;\n         case Types.CLOB:\n",
            "diff_size": 3
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "939",
                    "column": "18",
                    "severity": "warning",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/212/DataType.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/212/DataType.java\nindex 25d132e0f11..94cbdb64cf4 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/212/DataType.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/212/DataType.java\n@@ -3,6 +3,7 @@\n  * and the EPL 1.0 (http://h2database.com/html/license.html).\n  * Initial Developer: H2 Group\n  */\n+\n package org.h2.value;\n \n import java.io.BufferedReader;\n@@ -47,1400 +48,1400 @@ import org.h2.util.Utils;\n  */\n public class DataType {\n \n-    /**\n-     * This constant is used to represent the type of a ResultSet. There is no\n-     * equivalent java.sql.Types value, but Oracle uses it to represent a\n-     * ResultSet (OracleTypes.CURSOR = -10).\n-     */\n-    public static final int TYPE_RESULT_SET = -10;\n+  /**\n+   * This constant is used to represent the type of a ResultSet. There is no\n+   * equivalent java.sql.Types value, but Oracle uses it to represent a\n+   * ResultSet (OracleTypes.CURSOR = -10).\n+   */\n+  public static final int TYPE_RESULT_SET = -10;\n \n-    /**\n-     * The Geometry class. This object is null if the jts jar file is not in the\n-     * classpath.\n-     */\n-    public static final Class<?> GEOMETRY_CLASS;\n+  /**\n+   * The Geometry class. This object is null if the jts jar file is not in the\n+   * classpath.\n+   */\n+  public static final Class<?> GEOMETRY_CLASS;\n \n-    private static final String GEOMETRY_CLASS_NAME =\n-            \"org.locationtech.jts.geom.Geometry\";\n+  private static final String GEOMETRY_CLASS_NAME =\n+      \"org.locationtech.jts.geom.Geometry\";\n \n-    /**\n-     * The list of types. An ArrayList so that Tomcat doesn't set it to null\n-     * when clearing references.\n-     */\n-    private static final ArrayList<DataType> TYPES = new ArrayList<>(96);\n-    private static final HashMap<String, DataType> TYPES_BY_NAME = new HashMap<>(128);\n-    private static final HashMap<Integer, DataType> TYPES_BY_VALUE_TYPE = new HashMap<>(64);\n+  /**\n+   * The list of types. An ArrayList so that Tomcat doesn't set it to null\n+   * when clearing references.\n+   */\n+  private static final ArrayList<DataType> TYPES = new ArrayList<>(96);\n+  private static final HashMap<String, DataType> TYPES_BY_NAME = new HashMap<>(128);\n+  private static final HashMap<Integer, DataType> TYPES_BY_VALUE_TYPE = new HashMap<>(64);\n \n-    /**\n-     * The value type of this data type.\n-     */\n-    public int type;\n+  /**\n+   * The value type of this data type.\n+   */\n+  public int type;\n \n-    /**\n-     * The data type name.\n-     */\n-    public String name;\n+  /**\n+   * The data type name.\n+   */\n+  public String name;\n \n-    /**\n-     * The SQL type.\n-     */\n-    public int sqlType;\n+  /**\n+   * The SQL type.\n+   */\n+  public int sqlType;\n \n-    /**\n-     * How closely the data type maps to the corresponding JDBC SQL type (low is\n-     * best).\n-     */\n-    public int sqlTypePos;\n+  /**\n+   * How closely the data type maps to the corresponding JDBC SQL type (low is\n+   * best).\n+   */\n+  public int sqlTypePos;\n \n-    /**\n-     * The maximum supported precision.\n-     */\n-    public long maxPrecision;\n+  /**\n+   * The maximum supported precision.\n+   */\n+  public long maxPrecision;\n \n-    /**\n-     * The lowest possible scale.\n-     */\n-    public int minScale;\n+  /**\n+   * The lowest possible scale.\n+   */\n+  public int minScale;\n \n-    /**\n-     * The highest possible scale.\n-     */\n-    public int maxScale;\n+  /**\n+   * The highest possible scale.\n+   */\n+  public int maxScale;\n \n-    /**\n-     * If this is a numeric type.\n-     */\n-    public boolean decimal;\n+  /**\n+   * If this is a numeric type.\n+   */\n+  public boolean decimal;\n \n-    /**\n-     * The prefix required for the SQL literal representation.\n-     */\n-    public String prefix;\n+  /**\n+   * The prefix required for the SQL literal representation.\n+   */\n+  public String prefix;\n \n-    /**\n-     * The suffix required for the SQL literal representation.\n-     */\n-    public String suffix;\n+  /**\n+   * The suffix required for the SQL literal representation.\n+   */\n+  public String suffix;\n \n-    /**\n-     * The list of parameters used in the column definition.\n-     */\n-    public String params;\n+  /**\n+   * The list of parameters used in the column definition.\n+   */\n+  public String params;\n \n-    /**\n-     * If this is an autoincrement type.\n-     */\n-    public boolean autoIncrement;\n+  /**\n+   * If this is an autoincrement type.\n+   */\n+  public boolean autoIncrement;\n \n-    /**\n-     * If this data type is an autoincrement type.\n-     */\n-    public boolean caseSensitive;\n+  /**\n+   * If this data type is an autoincrement type.\n+   */\n+  public boolean caseSensitive;\n \n-    /**\n-     * If the precision parameter is supported.\n-     */\n-    public boolean supportsPrecision;\n+  /**\n+   * If the precision parameter is supported.\n+   */\n+  public boolean supportsPrecision;\n \n-    /**\n-     * If the scale parameter is supported.\n-     */\n-    public boolean supportsScale;\n+  /**\n+   * If the scale parameter is supported.\n+   */\n+  public boolean supportsScale;\n \n-    /**\n-     * The default precision.\n-     */\n-    public long defaultPrecision;\n+  /**\n+   * The default precision.\n+   */\n+  public long defaultPrecision;\n \n-    /**\n-     * The default scale.\n-     */\n-    public int defaultScale;\n+  /**\n+   * The default scale.\n+   */\n+  public int defaultScale;\n \n-    /**\n-     * The default display size.\n-     */\n-    public int defaultDisplaySize;\n+  /**\n+   * The default display size.\n+   */\n+  public int defaultDisplaySize;\n \n-    /**\n-     * If this data type should not be listed in the database meta data.\n-     */\n-    public boolean hidden;\n+  /**\n+   * If this data type should not be listed in the database meta data.\n+   */\n+  public boolean hidden;\n \n-    /**\n-     * The number of bytes required for an object.\n-     */\n-    public int memory;\n+  /**\n+   * The number of bytes required for an object.\n+   */\n+  public int memory;\n \n-    static {\n-        Class<?> g;\n-        try {\n-            g = JdbcUtils.loadUserClass(GEOMETRY_CLASS_NAME);\n-        } catch (Exception e) {\n-            // class is not in the classpath - ignore\n-            g = null;\n-        }\n-        GEOMETRY_CLASS = g;\n+  static {\n+    Class<?> g;\n+    try {\n+      g = JdbcUtils.loadUserClass(GEOMETRY_CLASS_NAME);\n+    } catch (Exception e) {\n+      // class is not in the classpath - ignore\n+      g = null;\n     }\n+    GEOMETRY_CLASS = g;\n+  }\n \n-    static {\n-        add(Value.NULL, Types.NULL,\n-                new DataType(),\n-                new String[]{\"NULL\"},\n-                // the value is always in the cache\n-                0\n-        );\n-        add(Value.STRING, Types.VARCHAR,\n-                createString(true),\n-                new String[]{\"VARCHAR\", \"VARCHAR2\", \"NVARCHAR\", \"NVARCHAR2\",\n-                    \"VARCHAR_CASESENSITIVE\", \"CHARACTER VARYING\", \"TID\"},\n-                // 24 for ValueString, 24 for String\n-                48\n-        );\n-        add(Value.STRING, Types.LONGVARCHAR,\n-                createString(true),\n-                new String[]{\"LONGVARCHAR\", \"LONGNVARCHAR\"},\n-                48\n-        );\n-        add(Value.STRING_FIXED, Types.CHAR,\n-                createString(true),\n-                new String[]{\"CHAR\", \"CHARACTER\", \"NCHAR\"},\n-                48\n-        );\n-        add(Value.STRING_IGNORECASE, Types.VARCHAR,\n-                createString(false),\n-                new String[]{\"VARCHAR_IGNORECASE\"},\n-                48\n-        );\n-        add(Value.BOOLEAN, Types.BOOLEAN,\n-                createDecimal(ValueBoolean.PRECISION, ValueBoolean.PRECISION,\n-                        0, ValueBoolean.DISPLAY_SIZE, false, false),\n-                new String[]{\"BOOLEAN\", \"BIT\", \"BOOL\"},\n-                // the value is always in the cache\n-                0\n-        );\n-        add(Value.BYTE, Types.TINYINT,\n-                createDecimal(ValueByte.PRECISION, ValueByte.PRECISION, 0,\n-                        ValueByte.DISPLAY_SIZE, false, false),\n-                new String[]{\"TINYINT\"},\n-                // the value is almost always in the cache\n-                1\n-        );\n-        add(Value.SHORT, Types.SMALLINT,\n-                createDecimal(ValueShort.PRECISION, ValueShort.PRECISION, 0,\n-                        ValueShort.DISPLAY_SIZE, false, false),\n-                new String[]{\"SMALLINT\", \"YEAR\", \"INT2\"},\n-                // in many cases the value is in the cache\n-                20\n-        );\n-        add(Value.INT, Types.INTEGER,\n-                createDecimal(ValueInt.PRECISION, ValueInt.PRECISION, 0,\n-                        ValueInt.DISPLAY_SIZE, false, false),\n-                new String[]{\"INTEGER\", \"INT\", \"MEDIUMINT\", \"INT4\", \"SIGNED\"},\n-                // in many cases the value is in the cache\n-                20\n-        );\n-        add(Value.INT, Types.INTEGER,\n-                createDecimal(ValueInt.PRECISION, ValueInt.PRECISION, 0,\n-                        ValueInt.DISPLAY_SIZE, false, true),\n-                new String[]{\"SERIAL\"},\n-                20\n-        );\n-        add(Value.LONG, Types.BIGINT,\n-                createDecimal(ValueLong.PRECISION, ValueLong.PRECISION, 0,\n-                        ValueLong.DISPLAY_SIZE, false, false),\n-                new String[]{\"BIGINT\", \"INT8\", \"LONG\"},\n-                24\n-        );\n-        add(Value.LONG, Types.BIGINT,\n-                createDecimal(ValueLong.PRECISION, ValueLong.PRECISION, 0,\n-                        ValueLong.DISPLAY_SIZE, false, true),\n-                new String[]{\"IDENTITY\", \"BIGSERIAL\"},\n-                24\n-        );\n-        if (SysProperties.BIG_DECIMAL_IS_DECIMAL) {\n-            addDecimal();\n-            addNumeric();\n-        } else {\n-            addNumeric();\n-            addDecimal();\n-        }\n-        add(Value.FLOAT, Types.REAL,\n-                createDecimal(ValueFloat.PRECISION, ValueFloat.PRECISION,\n-                        0, ValueFloat.DISPLAY_SIZE, false, false),\n-                new String[] {\"REAL\", \"FLOAT4\"},\n-                24\n-        );\n-        add(Value.DOUBLE, Types.DOUBLE,\n-                createDecimal(ValueDouble.PRECISION, ValueDouble.PRECISION,\n-                        0, ValueDouble.DISPLAY_SIZE, false, false),\n-                new String[] { \"DOUBLE\", \"DOUBLE PRECISION\" },\n-                24\n-        );\n-        add(Value.DOUBLE, Types.FLOAT,\n-                createDecimal(ValueDouble.PRECISION, ValueDouble.PRECISION,\n-                        0, ValueDouble.DISPLAY_SIZE, false, false),\n-                new String[] {\"FLOAT\", \"FLOAT8\" },\n-                24\n-        );\n-        add(Value.TIME, Types.TIME,\n-                createDate(ValueTime.MAXIMUM_PRECISION, ValueTime.DEFAULT_PRECISION,\n-                        \"TIME\", true, ValueTime.DEFAULT_SCALE, ValueTime.MAXIMUM_SCALE),\n-                new String[]{\"TIME\", \"TIME WITHOUT TIME ZONE\"},\n-                // 24 for ValueTime, 32 for java.sql.Time\n-                56\n-        );\n-        add(Value.DATE, Types.DATE,\n-                createDate(ValueDate.PRECISION, ValueDate.PRECISION,\n-                        \"DATE\", false, 0, 0),\n-                new String[]{\"DATE\"},\n-                // 24 for ValueDate, 32 for java.sql.Data\n-                56\n-        );\n-        add(Value.TIMESTAMP, Types.TIMESTAMP,\n-                createDate(ValueTimestamp.MAXIMUM_PRECISION, ValueTimestamp.DEFAULT_PRECISION,\n-                        \"TIMESTAMP\", true, ValueTimestamp.DEFAULT_SCALE, ValueTimestamp.MAXIMUM_SCALE),\n-                new String[]{\"TIMESTAMP\", \"TIMESTAMP WITHOUT TIME ZONE\",\n-                        \"DATETIME\", \"DATETIME2\", \"SMALLDATETIME\"},\n-                // 24 for ValueTimestamp, 32 for java.sql.Timestamp\n-                56\n-        );\n-        // 2014 is the value of Types.TIMESTAMP_WITH_TIMEZONE\n-        // use the value instead of the reference because the code has to\n-        // compile (on Java 1.7). Can be replaced with\n-        // Types.TIMESTAMP_WITH_TIMEZONE once Java 1.8 is required.\n-        add(Value.TIMESTAMP_TZ, 2014,\n-                createDate(ValueTimestampTimeZone.MAXIMUM_PRECISION, ValueTimestampTimeZone.DEFAULT_PRECISION,\n-                        \"TIMESTAMP_TZ\", true, ValueTimestampTimeZone.DEFAULT_SCALE,\n-                        ValueTimestampTimeZone.MAXIMUM_SCALE),\n-                new String[]{\"TIMESTAMP WITH TIME ZONE\"},\n-                // 26 for ValueTimestampUtc, 32 for java.sql.Timestamp\n-                58\n-        );\n-        add(Value.BYTES, Types.VARBINARY,\n-                createString(false),\n-                new String[]{\"VARBINARY\"},\n-                32\n-        );\n-        add(Value.BYTES, Types.BINARY,\n-                createString(false),\n-                new String[]{\"BINARY\", \"RAW\", \"BYTEA\", \"LONG RAW\"},\n-                32\n-        );\n-        add(Value.BYTES, Types.LONGVARBINARY,\n-                createString(false),\n-                new String[]{\"LONGVARBINARY\"},\n-                32\n-        );\n-        add(Value.UUID, Types.BINARY,\n-                createString(false),\n-                // UNIQUEIDENTIFIER is the MSSQL mode equivalent\n-                new String[]{\"UUID\", \"UNIQUEIDENTIFIER\"},\n-                32\n-        );\n-        add(Value.JAVA_OBJECT, Types.OTHER,\n-                createString(false),\n-                new String[]{\"OTHER\", \"OBJECT\", \"JAVA_OBJECT\"},\n-                24\n-        );\n-        add(Value.BLOB, Types.BLOB,\n-                createLob(),\n-                new String[]{\"BLOB\", \"TINYBLOB\", \"MEDIUMBLOB\",\n-                    \"LONGBLOB\", \"IMAGE\", \"OID\"},\n-                // 80 for ValueLob, 24 for String\n-                104\n-        );\n-        add(Value.CLOB, Types.CLOB,\n-                createLob(),\n-                new String[]{\"CLOB\", \"TINYTEXT\", \"TEXT\", \"MEDIUMTEXT\",\n-                    \"LONGTEXT\", \"NTEXT\", \"NCLOB\"},\n-                // 80 for ValueLob, 24 for String\n-                104\n-        );\n-        add(Value.GEOMETRY, Types.OTHER,\n-                createString(false),\n-                new String[]{\"GEOMETRY\"},\n-                32\n-        );\n-        DataType dataType = new DataType();\n-        dataType.prefix = \"(\";\n-        dataType.suffix = \"')\";\n-        add(Value.ARRAY, Types.ARRAY,\n-                dataType,\n-                new String[]{\"ARRAY\"},\n-                32\n-        );\n-        dataType = new DataType();\n-        add(Value.RESULT_SET, DataType.TYPE_RESULT_SET,\n-                dataType,\n-                new String[]{\"RESULT_SET\"},\n-                400\n-        );\n-        dataType = createString(false);\n-        dataType.supportsPrecision = false;\n-        dataType.supportsScale = false;\n-        add(Value.ENUM, Types.OTHER,\n-                dataType,\n-                new String[]{\"ENUM\"},\n-                48\n-        );\n-        for (Integer i : TYPES_BY_VALUE_TYPE.keySet()) {\n-            Value.getOrder(i);\n-        }\n+  static {\n+    add(Value.NULL, Types.NULL,\n+        new DataType(),\n+        new String[] {\"NULL\"},\n+        // the value is always in the cache\n+        0\n+    );\n+    add(Value.STRING, Types.VARCHAR,\n+        createString(true),\n+        new String[] {\"VARCHAR\", \"VARCHAR2\", \"NVARCHAR\", \"NVARCHAR2\",\n+            \"VARCHAR_CASESENSITIVE\", \"CHARACTER VARYING\", \"TID\"},\n+        // 24 for ValueString, 24 for String\n+        48\n+    );\n+    add(Value.STRING, Types.LONGVARCHAR,\n+        createString(true),\n+        new String[] {\"LONGVARCHAR\", \"LONGNVARCHAR\"},\n+        48\n+    );\n+    add(Value.STRING_FIXED, Types.CHAR,\n+        createString(true),\n+        new String[] {\"CHAR\", \"CHARACTER\", \"NCHAR\"},\n+        48\n+    );\n+    add(Value.STRING_IGNORECASE, Types.VARCHAR,\n+        createString(false),\n+        new String[] {\"VARCHAR_IGNORECASE\"},\n+        48\n+    );\n+    add(Value.BOOLEAN, Types.BOOLEAN,\n+        createDecimal(ValueBoolean.PRECISION, ValueBoolean.PRECISION,\n+            0, ValueBoolean.DISPLAY_SIZE, false, false),\n+        new String[] {\"BOOLEAN\", \"BIT\", \"BOOL\"},\n+        // the value is always in the cache\n+        0\n+    );\n+    add(Value.BYTE, Types.TINYINT,\n+        createDecimal(ValueByte.PRECISION, ValueByte.PRECISION, 0,\n+            ValueByte.DISPLAY_SIZE, false, false),\n+        new String[] {\"TINYINT\"},\n+        // the value is almost always in the cache\n+        1\n+    );\n+    add(Value.SHORT, Types.SMALLINT,\n+        createDecimal(ValueShort.PRECISION, ValueShort.PRECISION, 0,\n+            ValueShort.DISPLAY_SIZE, false, false),\n+        new String[] {\"SMALLINT\", \"YEAR\", \"INT2\"},\n+        // in many cases the value is in the cache\n+        20\n+    );\n+    add(Value.INT, Types.INTEGER,\n+        createDecimal(ValueInt.PRECISION, ValueInt.PRECISION, 0,\n+            ValueInt.DISPLAY_SIZE, false, false),\n+        new String[] {\"INTEGER\", \"INT\", \"MEDIUMINT\", \"INT4\", \"SIGNED\"},\n+        // in many cases the value is in the cache\n+        20\n+    );\n+    add(Value.INT, Types.INTEGER,\n+        createDecimal(ValueInt.PRECISION, ValueInt.PRECISION, 0,\n+            ValueInt.DISPLAY_SIZE, false, true),\n+        new String[] {\"SERIAL\"},\n+        20\n+    );\n+    add(Value.LONG, Types.BIGINT,\n+        createDecimal(ValueLong.PRECISION, ValueLong.PRECISION, 0,\n+            ValueLong.DISPLAY_SIZE, false, false),\n+        new String[] {\"BIGINT\", \"INT8\", \"LONG\"},\n+        24\n+    );\n+    add(Value.LONG, Types.BIGINT,\n+        createDecimal(ValueLong.PRECISION, ValueLong.PRECISION, 0,\n+            ValueLong.DISPLAY_SIZE, false, true),\n+        new String[] {\"IDENTITY\", \"BIGSERIAL\"},\n+        24\n+    );\n+    if (SysProperties.BIG_DECIMAL_IS_DECIMAL) {\n+      addDecimal();\n+      addNumeric();\n+    } else {\n+      addNumeric();\n+      addDecimal();\n     }\n-\n-    private static void addDecimal() {\n-        add(Value.DECIMAL, Types.DECIMAL,\n-                createDecimal(Integer.MAX_VALUE,\n-                        ValueDecimal.DEFAULT_PRECISION,\n-                        ValueDecimal.DEFAULT_SCALE,\n-                        ValueDecimal.DEFAULT_DISPLAY_SIZE, true, false),\n-                new String[]{\"DECIMAL\", \"DEC\"},\n-                // 40 for ValueDecimal,\n-                64\n-        );\n+    add(Value.FLOAT, Types.REAL,\n+        createDecimal(ValueFloat.PRECISION, ValueFloat.PRECISION,\n+            0, ValueFloat.DISPLAY_SIZE, false, false),\n+        new String[] {\"REAL\", \"FLOAT4\"},\n+        24\n+    );\n+    add(Value.DOUBLE, Types.DOUBLE,\n+        createDecimal(ValueDouble.PRECISION, ValueDouble.PRECISION,\n+            0, ValueDouble.DISPLAY_SIZE, false, false),\n+        new String[] {\"DOUBLE\", \"DOUBLE PRECISION\"},\n+        24\n+    );\n+    add(Value.DOUBLE, Types.FLOAT,\n+        createDecimal(ValueDouble.PRECISION, ValueDouble.PRECISION,\n+            0, ValueDouble.DISPLAY_SIZE, false, false),\n+        new String[] {\"FLOAT\", \"FLOAT8\"},\n+        24\n+    );\n+    add(Value.TIME, Types.TIME,\n+        createDate(ValueTime.MAXIMUM_PRECISION, ValueTime.DEFAULT_PRECISION,\n+            \"TIME\", true, ValueTime.DEFAULT_SCALE, ValueTime.MAXIMUM_SCALE),\n+        new String[] {\"TIME\", \"TIME WITHOUT TIME ZONE\"},\n+        // 24 for ValueTime, 32 for java.sql.Time\n+        56\n+    );\n+    add(Value.DATE, Types.DATE,\n+        createDate(ValueDate.PRECISION, ValueDate.PRECISION,\n+            \"DATE\", false, 0, 0),\n+        new String[] {\"DATE\"},\n+        // 24 for ValueDate, 32 for java.sql.Data\n+        56\n+    );\n+    add(Value.TIMESTAMP, Types.TIMESTAMP,\n+        createDate(ValueTimestamp.MAXIMUM_PRECISION, ValueTimestamp.DEFAULT_PRECISION,\n+            \"TIMESTAMP\", true, ValueTimestamp.DEFAULT_SCALE, ValueTimestamp.MAXIMUM_SCALE),\n+        new String[] {\"TIMESTAMP\", \"TIMESTAMP WITHOUT TIME ZONE\",\n+            \"DATETIME\", \"DATETIME2\", \"SMALLDATETIME\"},\n+        // 24 for ValueTimestamp, 32 for java.sql.Timestamp\n+        56\n+    );\n+    // 2014 is the value of Types.TIMESTAMP_WITH_TIMEZONE\n+    // use the value instead of the reference because the code has to\n+    // compile (on Java 1.7). Can be replaced with\n+    // Types.TIMESTAMP_WITH_TIMEZONE once Java 1.8 is required.\n+    add(Value.TIMESTAMP_TZ, 2014,\n+        createDate(ValueTimestampTimeZone.MAXIMUM_PRECISION, ValueTimestampTimeZone.DEFAULT_PRECISION,\n+            \"TIMESTAMP_TZ\", true, ValueTimestampTimeZone.DEFAULT_SCALE,\n+            ValueTimestampTimeZone.MAXIMUM_SCALE),\n+        new String[] {\"TIMESTAMP WITH TIME ZONE\"},\n+        // 26 for ValueTimestampUtc, 32 for java.sql.Timestamp\n+        58\n+    );\n+    add(Value.BYTES, Types.VARBINARY,\n+        createString(false),\n+        new String[] {\"VARBINARY\"},\n+        32\n+    );\n+    add(Value.BYTES, Types.BINARY,\n+        createString(false),\n+        new String[] {\"BINARY\", \"RAW\", \"BYTEA\", \"LONG RAW\"},\n+        32\n+    );\n+    add(Value.BYTES, Types.LONGVARBINARY,\n+        createString(false),\n+        new String[] {\"LONGVARBINARY\"},\n+        32\n+    );\n+    add(Value.UUID, Types.BINARY,\n+        createString(false),\n+        // UNIQUEIDENTIFIER is the MSSQL mode equivalent\n+        new String[] {\"UUID\", \"UNIQUEIDENTIFIER\"},\n+        32\n+    );\n+    add(Value.JAVA_OBJECT, Types.OTHER,\n+        createString(false),\n+        new String[] {\"OTHER\", \"OBJECT\", \"JAVA_OBJECT\"},\n+        24\n+    );\n+    add(Value.BLOB, Types.BLOB,\n+        createLob(),\n+        new String[] {\"BLOB\", \"TINYBLOB\", \"MEDIUMBLOB\",\n+            \"LONGBLOB\", \"IMAGE\", \"OID\"},\n+        // 80 for ValueLob, 24 for String\n+        104\n+    );\n+    add(Value.CLOB, Types.CLOB,\n+        createLob(),\n+        new String[] {\"CLOB\", \"TINYTEXT\", \"TEXT\", \"MEDIUMTEXT\",\n+            \"LONGTEXT\", \"NTEXT\", \"NCLOB\"},\n+        // 80 for ValueLob, 24 for String\n+        104\n+    );\n+    add(Value.GEOMETRY, Types.OTHER,\n+        createString(false),\n+        new String[] {\"GEOMETRY\"},\n+        32\n+    );\n+    DataType dataType = new DataType();\n+    dataType.prefix = \"(\";\n+    dataType.suffix = \"')\";\n+    add(Value.ARRAY, Types.ARRAY,\n+        dataType,\n+        new String[] {\"ARRAY\"},\n+        32\n+    );\n+    dataType = new DataType();\n+    add(Value.RESULT_SET, DataType.TYPE_RESULT_SET,\n+        dataType,\n+        new String[] {\"RESULT_SET\"},\n+        400\n+    );\n+    dataType = createString(false);\n+    dataType.supportsPrecision = false;\n+    dataType.supportsScale = false;\n+    add(Value.ENUM, Types.OTHER,\n+        dataType,\n+        new String[] {\"ENUM\"},\n+        48\n+    );\n+    for (Integer i : TYPES_BY_VALUE_TYPE.keySet()) {\n+      Value.getOrder(i);\n     }\n+  }\n \n-    private static void addNumeric() {\n-        add(Value.DECIMAL, Types.NUMERIC,\n-                createDecimal(Integer.MAX_VALUE,\n-                        ValueDecimal.DEFAULT_PRECISION,\n-                        ValueDecimal.DEFAULT_SCALE,\n-                        ValueDecimal.DEFAULT_DISPLAY_SIZE, true, false),\n-                new String[]{\"NUMERIC\", \"NUMBER\"},\n-                64\n-        );\n-    }\n+  private static void addDecimal() {\n+    add(Value.DECIMAL, Types.DECIMAL,\n+        createDecimal(Integer.MAX_VALUE,\n+            ValueDecimal.DEFAULT_PRECISION,\n+            ValueDecimal.DEFAULT_SCALE,\n+            ValueDecimal.DEFAULT_DISPLAY_SIZE, true, false),\n+        new String[] {\"DECIMAL\", \"DEC\"},\n+        // 40 for ValueDecimal,\n+        64\n+    );\n+  }\n \n-    private static void add(int type, int sqlType,\n-            DataType dataType, String[] names, int memory) {\n-        for (int i = 0; i < names.length; i++) {\n-            DataType dt = new DataType();\n-            dt.type = type;\n-            dt.sqlType = sqlType;\n-            dt.name = names[i];\n-            dt.autoIncrement = dataType.autoIncrement;\n-            dt.decimal = dataType.decimal;\n-            dt.maxPrecision = dataType.maxPrecision;\n-            dt.maxScale = dataType.maxScale;\n-            dt.minScale = dataType.minScale;\n-            dt.params = dataType.params;\n-            dt.prefix = dataType.prefix;\n-            dt.suffix = dataType.suffix;\n-            dt.supportsPrecision = dataType.supportsPrecision;\n-            dt.supportsScale = dataType.supportsScale;\n-            dt.defaultPrecision = dataType.defaultPrecision;\n-            dt.defaultScale = dataType.defaultScale;\n-            dt.defaultDisplaySize = dataType.defaultDisplaySize;\n-            dt.caseSensitive = dataType.caseSensitive;\n-            dt.hidden = i > 0;\n-            dt.memory = memory;\n-            for (DataType t2 : TYPES) {\n-                if (t2.sqlType == dt.sqlType) {\n-                    dt.sqlTypePos++;\n-                }\n-            }\n-            TYPES_BY_NAME.put(dt.name, dt);\n-            if (TYPES_BY_VALUE_TYPE.get(type) == null) {\n-                TYPES_BY_VALUE_TYPE.put(type, dt);\n-            }\n-            TYPES.add(dt);\n-        }\n-    }\n+  private static void addNumeric() {\n+    add(Value.DECIMAL, Types.NUMERIC,\n+        createDecimal(Integer.MAX_VALUE,\n+            ValueDecimal.DEFAULT_PRECISION,\n+            ValueDecimal.DEFAULT_SCALE,\n+            ValueDecimal.DEFAULT_DISPLAY_SIZE, true, false),\n+        new String[] {\"NUMERIC\", \"NUMBER\"},\n+        64\n+    );\n+  }\n \n-    private static DataType createDecimal(int maxPrecision,\n-            int defaultPrecision, int defaultScale, int defaultDisplaySize,\n-            boolean needsPrecisionAndScale, boolean autoInc) {\n-        DataType dataType = new DataType();\n-        dataType.maxPrecision = maxPrecision;\n-        dataType.defaultPrecision = defaultPrecision;\n-        dataType.defaultScale = defaultScale;\n-        dataType.defaultDisplaySize = defaultDisplaySize;\n-        if (needsPrecisionAndScale) {\n-            dataType.params = \"PRECISION,SCALE\";\n-            dataType.supportsPrecision = true;\n-            dataType.supportsScale = true;\n+  private static void add(int type, int sqlType,\n+                          DataType dataType, String[] names, int memory) {\n+    for (int i = 0; i < names.length; i++) {\n+      DataType dt = new DataType();\n+      dt.type = type;\n+      dt.sqlType = sqlType;\n+      dt.name = names[i];\n+      dt.autoIncrement = dataType.autoIncrement;\n+      dt.decimal = dataType.decimal;\n+      dt.maxPrecision = dataType.maxPrecision;\n+      dt.maxScale = dataType.maxScale;\n+      dt.minScale = dataType.minScale;\n+      dt.params = dataType.params;\n+      dt.prefix = dataType.prefix;\n+      dt.suffix = dataType.suffix;\n+      dt.supportsPrecision = dataType.supportsPrecision;\n+      dt.supportsScale = dataType.supportsScale;\n+      dt.defaultPrecision = dataType.defaultPrecision;\n+      dt.defaultScale = dataType.defaultScale;\n+      dt.defaultDisplaySize = dataType.defaultDisplaySize;\n+      dt.caseSensitive = dataType.caseSensitive;\n+      dt.hidden = i > 0;\n+      dt.memory = memory;\n+      for (DataType t2 : TYPES) {\n+        if (t2.sqlType == dt.sqlType) {\n+          dt.sqlTypePos++;\n         }\n-        dataType.decimal = true;\n-        dataType.autoIncrement = autoInc;\n-        return dataType;\n+      }\n+      TYPES_BY_NAME.put(dt.name, dt);\n+      if (TYPES_BY_VALUE_TYPE.get(type) == null) {\n+        TYPES_BY_VALUE_TYPE.put(type, dt);\n+      }\n+      TYPES.add(dt);\n     }\n+  }\n \n-    private static DataType createDate(int maxPrecision, int precision, String prefix,\n-            boolean supportsScale, int scale, int maxScale) {\n-        DataType dataType = new DataType();\n-        dataType.prefix = prefix + \" '\";\n-        dataType.suffix = \"'\";\n-        dataType.maxPrecision = maxPrecision;\n-        dataType.supportsScale = supportsScale;\n-        dataType.maxScale = maxScale;\n-        dataType.defaultPrecision = precision;\n-        dataType.defaultScale = scale;\n-        dataType.defaultDisplaySize = precision;\n-        return dataType;\n+  private static DataType createDecimal(int maxPrecision,\n+                                        int defaultPrecision, int defaultScale, int defaultDisplaySize,\n+                                        boolean needsPrecisionAndScale, boolean autoInc) {\n+    DataType dataType = new DataType();\n+    dataType.maxPrecision = maxPrecision;\n+    dataType.defaultPrecision = defaultPrecision;\n+    dataType.defaultScale = defaultScale;\n+    dataType.defaultDisplaySize = defaultDisplaySize;\n+    if (needsPrecisionAndScale) {\n+      dataType.params = \"PRECISION,SCALE\";\n+      dataType.supportsPrecision = true;\n+      dataType.supportsScale = true;\n     }\n+    dataType.decimal = true;\n+    dataType.autoIncrement = autoInc;\n+    return dataType;\n+  }\n \n-    private static DataType createString(boolean caseSensitive) {\n-        DataType dataType = new DataType();\n-        dataType.prefix = \"'\";\n-        dataType.suffix = \"'\";\n-        dataType.params = \"LENGTH\";\n-        dataType.caseSensitive = caseSensitive;\n-        dataType.supportsPrecision = true;\n-        dataType.maxPrecision = Integer.MAX_VALUE;\n-        dataType.defaultPrecision = Integer.MAX_VALUE;\n-        dataType.defaultDisplaySize = Integer.MAX_VALUE;\n-        return dataType;\n-    }\n+  private static DataType createDate(int maxPrecision, int precision, String prefix,\n+                                     boolean supportsScale, int scale, int maxScale) {\n+    DataType dataType = new DataType();\n+    dataType.prefix = prefix + \" '\";\n+    dataType.suffix = \"'\";\n+    dataType.maxPrecision = maxPrecision;\n+    dataType.supportsScale = supportsScale;\n+    dataType.maxScale = maxScale;\n+    dataType.defaultPrecision = precision;\n+    dataType.defaultScale = scale;\n+    dataType.defaultDisplaySize = precision;\n+    return dataType;\n+  }\n \n-    private static DataType createLob() {\n-        DataType t = createString(true);\n-        t.maxPrecision = Long.MAX_VALUE;\n-        t.defaultPrecision = Long.MAX_VALUE;\n-        return t;\n-    }\n+  private static DataType createString(boolean caseSensitive) {\n+    DataType dataType = new DataType();\n+    dataType.prefix = \"'\";\n+    dataType.suffix = \"'\";\n+    dataType.params = \"LENGTH\";\n+    dataType.caseSensitive = caseSensitive;\n+    dataType.supportsPrecision = true;\n+    dataType.maxPrecision = Integer.MAX_VALUE;\n+    dataType.defaultPrecision = Integer.MAX_VALUE;\n+    dataType.defaultDisplaySize = Integer.MAX_VALUE;\n+    return dataType;\n+  }\n \n-    /**\n-     * Get the list of data types.\n-     *\n-     * @return the list\n-     */\n-    public static ArrayList<DataType> getTypes() {\n-        return TYPES;\n-    }\n+  private static DataType createLob() {\n+    DataType t = createString(true);\n+    t.maxPrecision = Long.MAX_VALUE;\n+    t.defaultPrecision = Long.MAX_VALUE;\n+    return t;\n+  }\n \n-    /**\n-     * Read a value from the given result set.\n-     *\n-     * @param session the session\n-     * @param rs the result set\n-     * @param columnIndex the column index (1 based)\n-     * @param type the data type\n-     * @return the value\n-     */\n-    public static Value readValue(SessionInterface session, ResultSet rs,\n-            int columnIndex, int type) {\n-        try {\n-            Value v;\n-            switch (type) {\n-            case Value.NULL: {\n-                return ValueNull.INSTANCE;\n-            }\n-            case Value.BYTES: {\n-                /*\n-                 * Both BINARY and UUID may be mapped to Value.BYTES. getObject() returns byte[]\n-                 * for SQL BINARY, UUID for SQL UUID and null for SQL NULL.\n-                 */\n-                Object o = rs.getObject(columnIndex);\n-                if (o instanceof byte[]) {\n-                    v = ValueBytes.getNoCopy((byte[]) o);\n-                } else if (o != null) {\n-                    v = ValueUuid.get((UUID) o);\n-                } else {\n-                    v = ValueNull.INSTANCE;\n-                }\n-                break;\n-            }\n-            case Value.UUID: {\n-                Object o = rs.getObject(columnIndex);\n-                if (o instanceof UUID) {\n-                    v = ValueUuid.get((UUID) o);\n-                } else if (o != null) {\n-                    v = ValueUuid.get((byte[]) o);\n-                } else {\n-                    v = ValueNull.INSTANCE;\n-                }\n-                break;\n-            }\n-            case Value.BOOLEAN: {\n-                boolean value = rs.getBoolean(columnIndex);\n-                v = rs.wasNull() ? (Value) ValueNull.INSTANCE :\n-                    ValueBoolean.get(value);\n-                break;\n-            }\n-            case Value.BYTE: {\n-                byte value = rs.getByte(columnIndex);\n-                v = rs.wasNull() ? (Value) ValueNull.INSTANCE :\n-                    ValueByte.get(value);\n-                break;\n-            }\n-            case Value.DATE: {\n-                Date value = rs.getDate(columnIndex);\n-                v = value == null ? (Value) ValueNull.INSTANCE :\n-                    ValueDate.get(value);\n-                break;\n-            }\n-            case Value.TIME: {\n-                Time value = rs.getTime(columnIndex);\n-                v = value == null ? (Value) ValueNull.INSTANCE :\n-                    ValueTime.get(value);\n-                break;\n-            }\n-            case Value.TIMESTAMP: {\n-                Timestamp value = rs.getTimestamp(columnIndex);\n-                v = value == null ? (Value) ValueNull.INSTANCE :\n-                    ValueTimestamp.get(value);\n-                break;\n-            }\n-            case Value.TIMESTAMP_TZ: {\n-                TimestampWithTimeZone value = (TimestampWithTimeZone) rs.getObject(columnIndex);\n-                v = value == null ? (Value) ValueNull.INSTANCE :\n-                    ValueTimestampTimeZone.get(value);\n-                break;\n-            }\n-            case Value.DECIMAL: {\n-                BigDecimal value = rs.getBigDecimal(columnIndex);\n-                v = value == null ? (Value) ValueNull.INSTANCE :\n-                    ValueDecimal.get(value);\n-                break;\n-            }\n-            case Value.DOUBLE: {\n-                double value = rs.getDouble(columnIndex);\n-                v = rs.wasNull() ? (Value) ValueNull.INSTANCE :\n-                    ValueDouble.get(value);\n-                break;\n-            }\n-            case Value.FLOAT: {\n-                float value = rs.getFloat(columnIndex);\n-                v = rs.wasNull() ? (Value) ValueNull.INSTANCE :\n-                    ValueFloat.get(value);\n-                break;\n-            }\n-            case Value.INT: {\n-                int value = rs.getInt(columnIndex);\n-                v = rs.wasNull() ? (Value) ValueNull.INSTANCE :\n-                    ValueInt.get(value);\n-                break;\n-            }\n-            case Value.LONG: {\n-                long value = rs.getLong(columnIndex);\n-                v = rs.wasNull() ? (Value) ValueNull.INSTANCE :\n-                    ValueLong.get(value);\n-                break;\n-            }\n-            case Value.SHORT: {\n-                short value = rs.getShort(columnIndex);\n-                v = rs.wasNull() ? (Value) ValueNull.INSTANCE :\n-                    ValueShort.get(value);\n-                break;\n-            }\n-            case Value.STRING_IGNORECASE: {\n-                String s = rs.getString(columnIndex);\n-                v = (s == null) ? (Value) ValueNull.INSTANCE :\n-                    ValueStringIgnoreCase.get(s);\n-                break;\n-            }\n-            case Value.STRING_FIXED: {\n-                String s = rs.getString(columnIndex);\n-                v = (s == null) ? (Value) ValueNull.INSTANCE :\n-                    ValueStringFixed.get(s);\n-                break;\n-            }\n-            case Value.STRING: {\n-                String s = rs.getString(columnIndex);\n-                v = (s == null) ? (Value) ValueNull.INSTANCE :\n-                    ValueString.get(s);\n-                break;\n-            }\n-            case Value.CLOB: {\n-                if (session == null) {\n-                    String s = rs.getString(columnIndex);\n-                    v = s == null ? ValueNull.INSTANCE :\n-                        ValueLobDb.createSmallLob(Value.CLOB, s.getBytes(StandardCharsets.UTF_8));\n-                } else {\n-                    Reader in = rs.getCharacterStream(columnIndex);\n-                    if (in == null) {\n-                        v = ValueNull.INSTANCE;\n-                    } else {\n-                        v = session.getDataHandler().getLobStorage().\n-                                createClob(new BufferedReader(in), -1);\n-                    }\n-                }\n-                if (session != null) {\n-                    session.addTemporaryLob(v);\n-                }\n-                break;\n-            }\n-            case Value.BLOB: {\n-                if (session == null) {\n-                    byte[] buff = rs.getBytes(columnIndex);\n-                    return buff == null ? ValueNull.INSTANCE :\n-                        ValueLobDb.createSmallLob(Value.BLOB, buff);\n-                }\n-                InputStream in = rs.getBinaryStream(columnIndex);\n-                v = (in == null) ? (Value) ValueNull.INSTANCE :\n-                    session.getDataHandler().getLobStorage().createBlob(in, -1);\n-                session.addTemporaryLob(v);\n-                break;\n-            }\n-            case Value.JAVA_OBJECT: {\n-                if (SysProperties.serializeJavaObject) {\n-                    byte[] buff = rs.getBytes(columnIndex);\n-                    v = buff == null ? ValueNull.INSTANCE :\n-                        ValueJavaObject.getNoCopy(null, buff, session.getDataHandler());\n-                } else {\n-                    Object o = rs.getObject(columnIndex);\n-                    v = o == null ? ValueNull.INSTANCE :\n-                        ValueJavaObject.getNoCopy(o, null, session.getDataHandler());\n-                }\n-                break;\n-            }\n-            case Value.ARRAY: {\n-                Array array = rs.getArray(columnIndex);\n-                if (array == null) {\n-                    return ValueNull.INSTANCE;\n-                }\n-                Object[] list = (Object[]) array.getArray();\n-                if (list == null) {\n-                    return ValueNull.INSTANCE;\n-                }\n-                int len = list.length;\n-                Value[] values = new Value[len];\n-                for (int i = 0; i < len; i++) {\n-                    values[i] = DataType.convertToValue(session, list[i], Value.NULL);\n-                }\n-                v = ValueArray.get(values);\n-                break;\n-            }\n-            case Value.ENUM: {\n-                int value = rs.getInt(columnIndex);\n-                v = rs.wasNull() ? (Value) ValueNull.INSTANCE :\n-                    ValueInt.get(value);\n-                break;\n-            }\n-            case Value.RESULT_SET: {\n-                ResultSet x = (ResultSet) rs.getObject(columnIndex);\n-                if (x == null) {\n-                    return ValueNull.INSTANCE;\n-                }\n-                return ValueResultSet.get(x);\n-            }\n-            case Value.GEOMETRY: {\n-                Object x = rs.getObject(columnIndex);\n-                if (x == null) {\n-                    return ValueNull.INSTANCE;\n-                }\n-                return ValueGeometry.getFromGeometry(x);\n-            }\n-            default:\n-                if (JdbcUtils.customDataTypesHandler != null) {\n-                    return JdbcUtils.customDataTypesHandler.getValue(type,\n-                        rs.getObject(columnIndex),\n-                        session.getDataHandler());\n-                }\n-                throw DbException.throwInternalError(\"type=\"+type);\n-            }\n-            return v;\n-        } catch (SQLException e) {\n-            throw DbException.convert(e);\n-        }\n-    }\n+  /**\n+   * Get the list of data types.\n+   *\n+   * @return the list\n+   */\n+  public static ArrayList<DataType> getTypes() {\n+    return TYPES;\n+  }\n \n-    /**\n-     * Get the name of the Java class for the given value type.\n-     *\n-     * @param type the value type\n-     * @return the class name\n-     */\n-    public static String getTypeClassName(int type) {\n-        switch (type) {\n-        case Value.BOOLEAN:\n-            // \"java.lang.Boolean\";\n-            return Boolean.class.getName();\n-        case Value.BYTE:\n-            // \"java.lang.Byte\";\n-            return Byte.class.getName();\n-        case Value.SHORT:\n-            // \"java.lang.Short\";\n-            return Short.class.getName();\n-        case Value.INT:\n-            // \"java.lang.Integer\";\n-            return Integer.class.getName();\n-        case Value.LONG:\n-            // \"java.lang.Long\";\n-            return Long.class.getName();\n-        case Value.DECIMAL:\n-            // \"java.math.BigDecimal\";\n-            return BigDecimal.class.getName();\n-        case Value.TIME:\n-            // \"java.sql.Time\";\n-            return Time.class.getName();\n-        case Value.DATE:\n-            // \"java.sql.Date\";\n-            return Date.class.getName();\n-        case Value.TIMESTAMP:\n-            // \"java.sql.Timestamp\";\n-            return Timestamp.class.getName();\n-        case Value.TIMESTAMP_TZ:\n-            // \"org.h2.api.TimestampWithTimeZone\";\n-            return TimestampWithTimeZone.class.getName();\n-        case Value.BYTES:\n-        case Value.UUID:\n-            // \"[B\", not \"byte[]\";\n-            return byte[].class.getName();\n-        case Value.STRING:\n-        case Value.STRING_IGNORECASE:\n-        case Value.STRING_FIXED:\n-        case Value.ENUM:\n-            // \"java.lang.String\";\n-            return String.class.getName();\n-        case Value.BLOB:\n-            // \"java.sql.Blob\";\n-            return java.sql.Blob.class.getName();\n-        case Value.CLOB:\n-            // \"java.sql.Clob\";\n-            return java.sql.Clob.class.getName();\n-        case Value.DOUBLE:\n-            // \"java.lang.Double\";\n-            return Double.class.getName();\n-        case Value.FLOAT:\n-            // \"java.lang.Float\";\n-            return Float.class.getName();\n-        case Value.NULL:\n-            return null;\n-        case Value.JAVA_OBJECT:\n-            // \"java.lang.Object\";\n-            return Object.class.getName();\n-        case Value.UNKNOWN:\n-            // anything\n-            return Object.class.getName();\n-        case Value.ARRAY:\n-            return Array.class.getName();\n-        case Value.RESULT_SET:\n-            return ResultSet.class.getName();\n-        case Value.GEOMETRY:\n-            return GEOMETRY_CLASS_NAME;\n-        default:\n-            if (JdbcUtils.customDataTypesHandler != null) {\n-                return JdbcUtils.customDataTypesHandler.getDataTypeClassName(type);\n+  /**\n+   * Read a value from the given result set.\n+   *\n+   * @param session     the session\n+   * @param rs          the result set\n+   * @param columnIndex the column index (1 based)\n+   * @param type        the data type\n+   * @return the value\n+   */\n+  public static Value readValue(SessionInterface session, ResultSet rs,\n+                                int columnIndex, int type) {\n+    try {\n+      Value v;\n+      switch (type) {\n+        case Value.NULL: {\n+          return ValueNull.INSTANCE;\n+        }\n+        case Value.BYTES: {\n+          /*\n+           * Both BINARY and UUID may be mapped to Value.BYTES. getObject() returns byte[]\n+           * for SQL BINARY, UUID for SQL UUID and null for SQL NULL.\n+           */\n+          Object o = rs.getObject(columnIndex);\n+          if (o instanceof byte[]) {\n+            v = ValueBytes.getNoCopy((byte[]) o);\n+          } else if (o != null) {\n+            v = ValueUuid.get((UUID) o);\n+          } else {\n+            v = ValueNull.INSTANCE;\n+          }\n+          break;\n+        }\n+        case Value.UUID: {\n+          Object o = rs.getObject(columnIndex);\n+          if (o instanceof UUID) {\n+            v = ValueUuid.get((UUID) o);\n+          } else if (o != null) {\n+            v = ValueUuid.get((byte[]) o);\n+          } else {\n+            v = ValueNull.INSTANCE;\n+          }\n+          break;\n+        }\n+        case Value.BOOLEAN: {\n+          boolean value = rs.getBoolean(columnIndex);\n+          v = rs.wasNull() ? (Value) ValueNull.INSTANCE :\n+              ValueBoolean.get(value);\n+          break;\n+        }\n+        case Value.BYTE: {\n+          byte value = rs.getByte(columnIndex);\n+          v = rs.wasNull() ? (Value) ValueNull.INSTANCE :\n+              ValueByte.get(value);\n+          break;\n+        }\n+        case Value.DATE: {\n+          Date value = rs.getDate(columnIndex);\n+          v = value == null ? (Value) ValueNull.INSTANCE :\n+              ValueDate.get(value);\n+          break;\n+        }\n+        case Value.TIME: {\n+          Time value = rs.getTime(columnIndex);\n+          v = value == null ? (Value) ValueNull.INSTANCE :\n+              ValueTime.get(value);\n+          break;\n+        }\n+        case Value.TIMESTAMP: {\n+          Timestamp value = rs.getTimestamp(columnIndex);\n+          v = value == null ? (Value) ValueNull.INSTANCE :\n+              ValueTimestamp.get(value);\n+          break;\n+        }\n+        case Value.TIMESTAMP_TZ: {\n+          TimestampWithTimeZone value = (TimestampWithTimeZone) rs.getObject(columnIndex);\n+          v = value == null ? (Value) ValueNull.INSTANCE :\n+              ValueTimestampTimeZone.get(value);\n+          break;\n+        }\n+        case Value.DECIMAL: {\n+          BigDecimal value = rs.getBigDecimal(columnIndex);\n+          v = value == null ? (Value) ValueNull.INSTANCE :\n+              ValueDecimal.get(value);\n+          break;\n+        }\n+        case Value.DOUBLE: {\n+          double value = rs.getDouble(columnIndex);\n+          v = rs.wasNull() ? (Value) ValueNull.INSTANCE :\n+              ValueDouble.get(value);\n+          break;\n+        }\n+        case Value.FLOAT: {\n+          float value = rs.getFloat(columnIndex);\n+          v = rs.wasNull() ? (Value) ValueNull.INSTANCE :\n+              ValueFloat.get(value);\n+          break;\n+        }\n+        case Value.INT: {\n+          int value = rs.getInt(columnIndex);\n+          v = rs.wasNull() ? (Value) ValueNull.INSTANCE :\n+              ValueInt.get(value);\n+          break;\n+        }\n+        case Value.LONG: {\n+          long value = rs.getLong(columnIndex);\n+          v = rs.wasNull() ? (Value) ValueNull.INSTANCE :\n+              ValueLong.get(value);\n+          break;\n+        }\n+        case Value.SHORT: {\n+          short value = rs.getShort(columnIndex);\n+          v = rs.wasNull() ? (Value) ValueNull.INSTANCE :\n+              ValueShort.get(value);\n+          break;\n+        }\n+        case Value.STRING_IGNORECASE: {\n+          String s = rs.getString(columnIndex);\n+          v = (s == null) ? (Value) ValueNull.INSTANCE :\n+              ValueStringIgnoreCase.get(s);\n+          break;\n+        }\n+        case Value.STRING_FIXED: {\n+          String s = rs.getString(columnIndex);\n+          v = (s == null) ? (Value) ValueNull.INSTANCE :\n+              ValueStringFixed.get(s);\n+          break;\n+        }\n+        case Value.STRING: {\n+          String s = rs.getString(columnIndex);\n+          v = (s == null) ? (Value) ValueNull.INSTANCE :\n+              ValueString.get(s);\n+          break;\n+        }\n+        case Value.CLOB: {\n+          if (session == null) {\n+            String s = rs.getString(columnIndex);\n+            v = s == null ? ValueNull.INSTANCE :\n+                ValueLobDb.createSmallLob(Value.CLOB, s.getBytes(StandardCharsets.UTF_8));\n+          } else {\n+            Reader in = rs.getCharacterStream(columnIndex);\n+            if (in == null) {\n+              v = ValueNull.INSTANCE;\n+            } else {\n+              v = session.getDataHandler().getLobStorage().\n+                  createClob(new BufferedReader(in), -1);\n             }\n-            throw DbException.throwInternalError(\"type=\"+type);\n+          }\n+          if (session != null) {\n+            session.addTemporaryLob(v);\n+          }\n+          break;\n         }\n-    }\n-\n-    /**\n-     * Get the data type object for the given value type.\n-     *\n-     * @param type the value type\n-     * @return the data type object\n-     */\n-    public static DataType getDataType(int type) {\n-        if (type == Value.UNKNOWN) {\n-            throw DbException.get(ErrorCode.UNKNOWN_DATA_TYPE_1, \"?\");\n+        case Value.BLOB: {\n+          if (session == null) {\n+            byte[] buff = rs.getBytes(columnIndex);\n+            return buff == null ? ValueNull.INSTANCE :\n+                ValueLobDb.createSmallLob(Value.BLOB, buff);\n+          }\n+          InputStream in = rs.getBinaryStream(columnIndex);\n+          v = (in == null) ? (Value) ValueNull.INSTANCE :\n+              session.getDataHandler().getLobStorage().createBlob(in, -1);\n+          session.addTemporaryLob(v);\n+          break;\n+        }\n+        case Value.JAVA_OBJECT: {\n+          if (SysProperties.serializeJavaObject) {\n+            byte[] buff = rs.getBytes(columnIndex);\n+            v = buff == null ? ValueNull.INSTANCE :\n+                ValueJavaObject.getNoCopy(null, buff, session.getDataHandler());\n+          } else {\n+            Object o = rs.getObject(columnIndex);\n+            v = o == null ? ValueNull.INSTANCE :\n+                ValueJavaObject.getNoCopy(o, null, session.getDataHandler());\n+          }\n+          break;\n         }\n-        DataType dt = TYPES_BY_VALUE_TYPE.get(type);\n-        if (dt == null && JdbcUtils.customDataTypesHandler != null) {\n-            dt = JdbcUtils.customDataTypesHandler.getDataTypeById(type);\n+        case Value.ARRAY: {\n+          Array array = rs.getArray(columnIndex);\n+          if (array == null) {\n+            return ValueNull.INSTANCE;\n+          }\n+          Object[] list = (Object[]) array.getArray();\n+          if (list == null) {\n+            return ValueNull.INSTANCE;\n+          }\n+          int len = list.length;\n+          Value[] values = new Value[len];\n+          for (int i = 0; i < len; i++) {\n+            values[i] = DataType.convertToValue(session, list[i], Value.NULL);\n+          }\n+          v = ValueArray.get(values);\n+          break;\n         }\n-        if (dt == null) {\n-            dt = TYPES_BY_VALUE_TYPE.get(Value.NULL);\n+        case Value.ENUM: {\n+          int value = rs.getInt(columnIndex);\n+          v = rs.wasNull() ? (Value) ValueNull.INSTANCE :\n+              ValueInt.get(value);\n+          break;\n         }\n-        return dt;\n-    }\n-\n-    /**\n-     * Convert a value type to a SQL type.\n-     *\n-     * @param type the value type\n-     * @return the SQL type\n-     */\n-    public static int convertTypeToSQLType(int type) {\n-        return getDataType(type).sqlType;\n+        case Value.RESULT_SET: {\n+          ResultSet x = (ResultSet) rs.getObject(columnIndex);\n+          if (x == null) {\n+            return ValueNull.INSTANCE;\n+          }\n+          return ValueResultSet.get(x);\n+        }\n+        case Value.GEOMETRY: {\n+          Object x = rs.getObject(columnIndex);\n+          if (x == null) {\n+            return ValueNull.INSTANCE;\n+          }\n+          return ValueGeometry.getFromGeometry(x);\n+        }\n+        default:\n+          if (JdbcUtils.customDataTypesHandler != null) {\n+            return JdbcUtils.customDataTypesHandler.getValue(type,\n+                rs.getObject(columnIndex),\n+                session.getDataHandler());\n+          }\n+          throw DbException.throwInternalError(\"type=\" + type);\n+      }\n+      return v;\n+    } catch (SQLException e) {\n+      throw DbException.convert(e);\n     }\n+  }\n \n-    /**\n-     * Convert a SQL type to a value type using SQL type name, in order to\n-     * manage SQL type extension mechanism.\n-     *\n-     * @param sqlType the SQL type\n-     * @param sqlTypeName the SQL type name\n-     * @return the value type\n-     */\n-    public static int convertSQLTypeToValueType(int sqlType, String sqlTypeName) {\n-        switch (sqlType) {\n-            case Types.BINARY:\n-                if (sqlTypeName.equalsIgnoreCase(\"UUID\")) {\n-                    return Value.UUID;\n-                }\n-                break;\n-            case Types.OTHER:\n-            case Types.JAVA_OBJECT:\n-                if (sqlTypeName.equalsIgnoreCase(\"geometry\")) {\n-                    return Value.GEOMETRY;\n-                }\n+  /**\n+   * Get the name of the Java class for the given value type.\n+   *\n+   * @param type the value type\n+   * @return the class name\n+   */\n+  public static String getTypeClassName(int type) {\n+    switch (type) {\n+      case Value.BOOLEAN:\n+        // \"java.lang.Boolean\";\n+        return Boolean.class.getName();\n+      case Value.BYTE:\n+        // \"java.lang.Byte\";\n+        return Byte.class.getName();\n+      case Value.SHORT:\n+        // \"java.lang.Short\";\n+        return Short.class.getName();\n+      case Value.INT:\n+        // \"java.lang.Integer\";\n+        return Integer.class.getName();\n+      case Value.LONG:\n+        // \"java.lang.Long\";\n+        return Long.class.getName();\n+      case Value.DECIMAL:\n+        // \"java.math.BigDecimal\";\n+        return BigDecimal.class.getName();\n+      case Value.TIME:\n+        // \"java.sql.Time\";\n+        return Time.class.getName();\n+      case Value.DATE:\n+        // \"java.sql.Date\";\n+        return Date.class.getName();\n+      case Value.TIMESTAMP:\n+        // \"java.sql.Timestamp\";\n+        return Timestamp.class.getName();\n+      case Value.TIMESTAMP_TZ:\n+        // \"org.h2.api.TimestampWithTimeZone\";\n+        return TimestampWithTimeZone.class.getName();\n+      case Value.BYTES:\n+      case Value.UUID:\n+        // \"[B\", not \"byte[]\";\n+        return byte[].class.getName();\n+      case Value.STRING:\n+      case Value.STRING_IGNORECASE:\n+      case Value.STRING_FIXED:\n+      case Value.ENUM:\n+        // \"java.lang.String\";\n+        return String.class.getName();\n+      case Value.BLOB:\n+        // \"java.sql.Blob\";\n+        return java.sql.Blob.class.getName();\n+      case Value.CLOB:\n+        // \"java.sql.Clob\";\n+        return java.sql.Clob.class.getName();\n+      case Value.DOUBLE:\n+        // \"java.lang.Double\";\n+        return Double.class.getName();\n+      case Value.FLOAT:\n+        // \"java.lang.Float\";\n+        return Float.class.getName();\n+      case Value.NULL:\n+        return null;\n+      case Value.JAVA_OBJECT:\n+        // \"java.lang.Object\";\n+        return Object.class.getName();\n+      case Value.UNKNOWN:\n+        // anything\n+        return Object.class.getName();\n+      case Value.ARRAY:\n+        return Array.class.getName();\n+      case Value.RESULT_SET:\n+        return ResultSet.class.getName();\n+      case Value.GEOMETRY:\n+        return GEOMETRY_CLASS_NAME;\n+      default:\n+        if (JdbcUtils.customDataTypesHandler != null) {\n+          return JdbcUtils.customDataTypesHandler.getDataTypeClassName(type);\n         }\n-        return convertSQLTypeToValueType(sqlType);\n+        throw DbException.throwInternalError(\"type=\" + type);\n     }\n+  }\n \n-    /**\n-     * Get the SQL type from the result set meta data for the given column. This\n-     * method uses the SQL type and type name.\n-     *\n-     * @param meta the meta data\n-     * @param columnIndex the column index (1, 2,...)\n-     * @return the value type\n-     */\n-    public static int getValueTypeFromResultSet(ResultSetMetaData meta,\n-            int columnIndex) throws SQLException {\n-        return convertSQLTypeToValueType(\n-                meta.getColumnType(columnIndex),\n-                meta.getColumnTypeName(columnIndex));\n+  /**\n+   * Get the data type object for the given value type.\n+   *\n+   * @param type the value type\n+   * @return the data type object\n+   */\n+  public static DataType getDataType(int type) {\n+    if (type == Value.UNKNOWN) {\n+      throw DbException.get(ErrorCode.UNKNOWN_DATA_TYPE_1, \"?\");\n     }\n-\n-    /**\n-     * Convert a SQL type to a value type.\n-     *\n-     * @param sqlType the SQL type\n-     * @return the value type\n-     */\n-    public static int convertSQLTypeToValueType(int sqlType) {\n-        switch (sqlType) {\n-        case Types.CHAR:\n-        case Types.NCHAR:\n-            return Value.STRING_FIXED;\n-        case Types.VARCHAR:\n-        case Types.LONGVARCHAR:\n-        case Types.NVARCHAR:\n-        case Types.LONGNVARCHAR:\n-            return Value.STRING;\n-        case Types.NUMERIC:\n-        case Types.DECIMAL:\n-            return Value.DECIMAL;\n-        case Types.BIT:\n-        case Types.BOOLEAN:\n-            return Value.BOOLEAN;\n-        case Types.INTEGER:\n-            return Value.INT;\n-        case Types.SMALLINT:\n-            return Value.SHORT;\n-        case Types.TINYINT:\n-            return Value.BYTE;\n-        case Types.BIGINT:\n-            return Value.LONG;\n-        case Types.REAL:\n-            return Value.FLOAT;\n-        case Types.DOUBLE:\n-        case Types.FLOAT:\n-            return Value.DOUBLE;\n-        case Types.BINARY:\n-        case Types.VARBINARY:\n-        case Types.LONGVARBINARY:\n-            return Value.BYTES;\n-        case Types.OTHER:\n-        case Types.JAVA_OBJECT:\n-            return Value.JAVA_OBJECT;\n-        case Types.DATE:\n-            return Value.DATE;\n-        case Types.TIME:\n-            return Value.TIME;\n-        case Types.TIMESTAMP:\n-            return Value.TIMESTAMP;\n-        case 2014: // Types.TIMESTAMP_WITH_TIMEZONE\n-            return Value.TIMESTAMP_TZ;\n-        case Types.BLOB:\n-            return Value.BLOB;\n-        case Types.CLOB:\n-        case Types.NCLOB:\n-            return Value.CLOB;\n-        case Types.NULL:\n-            return Value.NULL;\n-        case Types.ARRAY:\n-            return Value.ARRAY;\n-        case DataType.TYPE_RESULT_SET:\n-            return Value.RESULT_SET;\n-        default:\n-            throw DbException.get(\n-                    ErrorCode.UNKNOWN_DATA_TYPE_1, Integer.toString(sqlType));\n-        }\n+    DataType dt = TYPES_BY_VALUE_TYPE.get(type);\n+    if (dt == null && JdbcUtils.customDataTypesHandler != null) {\n+      dt = JdbcUtils.customDataTypesHandler.getDataTypeById(type);\n+    }\n+    if (dt == null) {\n+      dt = TYPES_BY_VALUE_TYPE.get(Value.NULL);\n     }\n+    return dt;\n+  }\n \n-    /**\n-     * Get the value type for the given Java class.\n-     *\n-     * @param x the Java class\n-     * @return the value type\n-     */\n-    public static int getTypeFromClass(Class <?> x) {\n-        // TODO refactor: too many if/else in functions, can reduce!\n-        if (x == null || Void.TYPE == x) {\n-            return Value.NULL;\n+  /**\n+   * Convert a value type to a SQL type.\n+   *\n+   * @param type the value type\n+   * @return the SQL type\n+   */\n+  public static int convertTypeToSQLType(int type) {\n+    return getDataType(type).sqlType;\n+  }\n+\n+  /**\n+   * Convert a SQL type to a value type using SQL type name, in order to\n+   * manage SQL type extension mechanism.\n+   *\n+   * @param sqlType     the SQL type\n+   * @param sqlTypeName the SQL type name\n+   * @return the value type\n+   */\n+  public static int convertSQLTypeToValueType(int sqlType, String sqlTypeName) {\n+    switch (sqlType) {\n+      case Types.BINARY:\n+        if (sqlTypeName.equalsIgnoreCase(\"UUID\")) {\n+          return Value.UUID;\n         }\n-        if (x.isPrimitive()) {\n-            x = Utils.getNonPrimitiveClass(x);\n+        break;\n+      case Types.OTHER:\n+      case Types.JAVA_OBJECT:\n+        if (sqlTypeName.equalsIgnoreCase(\"geometry\")) {\n+          return Value.GEOMETRY;\n         }\n-        if (String.class == x) {\n-            return Value.STRING;\n-        } else if (Integer.class == x) {\n-            return Value.INT;\n-        } else if (Long.class == x) {\n-            return Value.LONG;\n-        } else if (Boolean.class == x) {\n-            return Value.BOOLEAN;\n-        } else if (Double.class == x) {\n-            return Value.DOUBLE;\n-        } else if (Byte.class == x) {\n-            return Value.BYTE;\n-        } else if (Short.class == x) {\n-            return Value.SHORT;\n-        } else if (Character.class == x) {\n-            throw DbException.get(\n-                    ErrorCode.DATA_CONVERSION_ERROR_1, \"char (not supported)\");\n-        } else if (Float.class == x) {\n-            return Value.FLOAT;\n-        } else if (byte[].class == x) {\n-            return Value.BYTES;\n-        } else if (UUID.class == x) {\n-            return Value.UUID;\n-        } else if (Void.class == x) {\n-            return Value.NULL;\n-        } else if (BigDecimal.class.isAssignableFrom(x)) {\n-            return Value.DECIMAL;\n-        } else if (ResultSet.class.isAssignableFrom(x)) {\n-            return Value.RESULT_SET;\n-        } else if (ValueLobDb.class.isAssignableFrom(x)) {\n-            return Value.BLOB;\n+    }\n+    return convertSQLTypeToValueType(sqlType);\n+  }\n+\n+  /**\n+   * Get the SQL type from the result set meta data for the given column. This\n+   * method uses the SQL type and type name.\n+   *\n+   * @param meta        the meta data\n+   * @param columnIndex the column index (1, 2,...)\n+   * @return the value type\n+   */\n+  public static int getValueTypeFromResultSet(ResultSetMetaData meta,\n+                                              int columnIndex) throws SQLException {\n+    return convertSQLTypeToValueType(\n+        meta.getColumnType(columnIndex),\n+        meta.getColumnTypeName(columnIndex));\n+  }\n+\n+  /**\n+   * Convert a SQL type to a value type.\n+   *\n+   * @param sqlType the SQL type\n+   * @return the value type\n+   */\n+  public static int convertSQLTypeToValueType(int sqlType) {\n+    switch (sqlType) {\n+      case Types.CHAR:\n+      case Types.NCHAR:\n+        return Value.STRING_FIXED;\n+      case Types.VARCHAR:\n+      case Types.LONGVARCHAR:\n+      case Types.NVARCHAR:\n+      case Types.LONGNVARCHAR:\n+        return Value.STRING;\n+      case Types.NUMERIC:\n+      case Types.DECIMAL:\n+        return Value.DECIMAL;\n+      case Types.BIT:\n+      case Types.BOOLEAN:\n+        return Value.BOOLEAN;\n+      case Types.INTEGER:\n+        return Value.INT;\n+      case Types.SMALLINT:\n+        return Value.SHORT;\n+      case Types.TINYINT:\n+        return Value.BYTE;\n+      case Types.BIGINT:\n+        return Value.LONG;\n+      case Types.REAL:\n+        return Value.FLOAT;\n+      case Types.DOUBLE:\n+      case Types.FLOAT:\n+        return Value.DOUBLE;\n+      case Types.BINARY:\n+      case Types.VARBINARY:\n+      case Types.LONGVARBINARY:\n+        return Value.BYTES;\n+      case Types.OTHER:\n+      case Types.JAVA_OBJECT:\n+        return Value.JAVA_OBJECT;\n+      case Types.DATE:\n+        return Value.DATE;\n+      case Types.TIME:\n+        return Value.TIME;\n+      case Types.TIMESTAMP:\n+        return Value.TIMESTAMP;\n+      case 2014: // Types.TIMESTAMP_WITH_TIMEZONE\n+        return Value.TIMESTAMP_TZ;\n+      case Types.BLOB:\n+        return Value.BLOB;\n+      case Types.CLOB:\n+      case Types.NCLOB:\n+        return Value.CLOB;\n+      case Types.NULL:\n+        return Value.NULL;\n+      case Types.ARRAY:\n+        return Value.ARRAY;\n+      case DataType.TYPE_RESULT_SET:\n+        return Value.RESULT_SET;\n+      default:\n+        throw DbException.get(\n+            ErrorCode.UNKNOWN_DATA_TYPE_1, Integer.toString(sqlType));\n+    }\n+  }\n+\n+  /**\n+   * Get the value type for the given Java class.\n+   *\n+   * @param x the Java class\n+   * @return the value type\n+   */\n+  public static int getTypeFromClass(Class<?> x) {\n+    // TODO refactor: too many if/else in functions, can reduce!\n+    if (x == null || Void.TYPE == x) {\n+      return Value.NULL;\n+    }\n+    if (x.isPrimitive()) {\n+      x = Utils.getNonPrimitiveClass(x);\n+    }\n+    if (String.class == x) {\n+      return Value.STRING;\n+    } else if (Integer.class == x) {\n+      return Value.INT;\n+    } else if (Long.class == x) {\n+      return Value.LONG;\n+    } else if (Boolean.class == x) {\n+      return Value.BOOLEAN;\n+    } else if (Double.class == x) {\n+      return Value.DOUBLE;\n+    } else if (Byte.class == x) {\n+      return Value.BYTE;\n+    } else if (Short.class == x) {\n+      return Value.SHORT;\n+    } else if (Character.class == x) {\n+      throw DbException.get(\n+          ErrorCode.DATA_CONVERSION_ERROR_1, \"char (not supported)\");\n+    } else if (Float.class == x) {\n+      return Value.FLOAT;\n+    } else if (byte[].class == x) {\n+      return Value.BYTES;\n+    } else if (UUID.class == x) {\n+      return Value.UUID;\n+    } else if (Void.class == x) {\n+      return Value.NULL;\n+    } else if (BigDecimal.class.isAssignableFrom(x)) {\n+      return Value.DECIMAL;\n+    } else if (ResultSet.class.isAssignableFrom(x)) {\n+      return Value.RESULT_SET;\n+    } else if (ValueLobDb.class.isAssignableFrom(x)) {\n+      return Value.BLOB;\n // FIXME no way to distinguish between these 2 types\n //        } else if (ValueLobDb.class.isAssignableFrom(x)) {\n //            return Value.CLOB;\n-        } else if (Date.class.isAssignableFrom(x)) {\n-            return Value.DATE;\n-        } else if (Time.class.isAssignableFrom(x)) {\n-            return Value.TIME;\n-        } else if (Timestamp.class.isAssignableFrom(x)) {\n-            return Value.TIMESTAMP;\n-        } else if (java.util.Date.class.isAssignableFrom(x)) {\n-            return Value.TIMESTAMP;\n-        } else if (java.io.Reader.class.isAssignableFrom(x)) {\n-            return Value.CLOB;\n-        } else if (java.sql.Clob.class.isAssignableFrom(x)) {\n-            return Value.CLOB;\n-        } else if (java.io.InputStream.class.isAssignableFrom(x)) {\n-            return Value.BLOB;\n-        } else if (java.sql.Blob.class.isAssignableFrom(x)) {\n-            return Value.BLOB;\n-        } else if (Object[].class.isAssignableFrom(x)) {\n-            // this includes String[] and so on\n-            return Value.ARRAY;\n-        } else if (isGeometryClass(x)) {\n-            return Value.GEOMETRY;\n-        } else if (LocalDateTimeUtils.LOCAL_DATE == x) {\n-            return Value.DATE;\n-        } else if (LocalDateTimeUtils.LOCAL_TIME == x) {\n-            return Value.TIME;\n-        } else if (LocalDateTimeUtils.LOCAL_DATE_TIME == x) {\n-            return Value.TIMESTAMP;\n-        } else if (LocalDateTimeUtils.OFFSET_DATE_TIME == x || LocalDateTimeUtils.INSTANT == x) {\n-            return Value.TIMESTAMP_TZ;\n-        } else {\n-            if (JdbcUtils.customDataTypesHandler != null) {\n-                return JdbcUtils.customDataTypesHandler.getTypeIdFromClass(x);\n-            }\n-            return Value.JAVA_OBJECT;\n-        }\n+    } else if (Date.class.isAssignableFrom(x)) {\n+      return Value.DATE;\n+    } else if (Time.class.isAssignableFrom(x)) {\n+      return Value.TIME;\n+    } else if (Timestamp.class.isAssignableFrom(x)) {\n+      return Value.TIMESTAMP;\n+    } else if (java.util.Date.class.isAssignableFrom(x)) {\n+      return Value.TIMESTAMP;\n+    } else if (java.io.Reader.class.isAssignableFrom(x)) {\n+      return Value.CLOB;\n+    } else if (java.sql.Clob.class.isAssignableFrom(x)) {\n+      return Value.CLOB;\n+    } else if (java.io.InputStream.class.isAssignableFrom(x)) {\n+      return Value.BLOB;\n+    } else if (java.sql.Blob.class.isAssignableFrom(x)) {\n+      return Value.BLOB;\n+    } else if (Object[].class.isAssignableFrom(x)) {\n+      // this includes String[] and so on\n+      return Value.ARRAY;\n+    } else if (isGeometryClass(x)) {\n+      return Value.GEOMETRY;\n+    } else if (LocalDateTimeUtils.LOCAL_DATE == x) {\n+      return Value.DATE;\n+    } else if (LocalDateTimeUtils.LOCAL_TIME == x) {\n+      return Value.TIME;\n+    } else if (LocalDateTimeUtils.LOCAL_DATE_TIME == x) {\n+      return Value.TIMESTAMP;\n+    } else if (LocalDateTimeUtils.OFFSET_DATE_TIME == x || LocalDateTimeUtils.INSTANT == x) {\n+      return Value.TIMESTAMP_TZ;\n+    } else {\n+      if (JdbcUtils.customDataTypesHandler != null) {\n+        return JdbcUtils.customDataTypesHandler.getTypeIdFromClass(x);\n+      }\n+      return Value.JAVA_OBJECT;\n     }\n+  }\n \n-    /**\n-     * Convert a Java object to a value.\n-     *\n-     * @param session the session\n-     * @param x the value\n-     * @param type the value type\n-     * @return the value\n-     */\n-    public static Value convertToValue(SessionInterface session, Object x,\n-            int type) {\n-        Value v = convertToValue1(session, x, type);\n-        if (session != null) {\n-            session.addTemporaryLob(v);\n-        }\n-        return v;\n+  /**\n+   * Convert a Java object to a value.\n+   *\n+   * @param session the session\n+   * @param x       the value\n+   * @param type    the value type\n+   * @return the value\n+   */\n+  public static Value convertToValue(SessionInterface session, Object x,\n+                                     int type) {\n+    Value v = convertToValue1(session, x, type);\n+    if (session != null) {\n+      session.addTemporaryLob(v);\n     }\n+    return v;\n+  }\n \n-    private static Value convertToValue1(SessionInterface session, Object x,\n-            int type) {\n-        if (x == null) {\n-            return ValueNull.INSTANCE;\n-        }\n-        if (type == Value.JAVA_OBJECT) {\n-            return ValueJavaObject.getNoCopy(x, null, session.getDataHandler());\n-        }\n-        if (x instanceof String) {\n-            return ValueString.get((String) x);\n-        } else if (x instanceof Value) {\n-            return (Value) x;\n-        } else if (x instanceof Long) {\n-            return ValueLong.get(((Long) x).longValue());\n-        } else if (x instanceof Integer) {\n-            return ValueInt.get(((Integer) x).intValue());\n-        } else if (x instanceof BigInteger) {\n-            return ValueDecimal.get(new BigDecimal((BigInteger) x));\n-        } else if (x instanceof BigDecimal) {\n-            return ValueDecimal.get((BigDecimal) x);\n-        } else if (x instanceof Boolean) {\n-            return ValueBoolean.get(((Boolean) x).booleanValue());\n-        } else if (x instanceof Byte) {\n-            return ValueByte.get(((Byte) x).byteValue());\n-        } else if (x instanceof Short) {\n-            return ValueShort.get(((Short) x).shortValue());\n-        } else if (x instanceof Float) {\n-            return ValueFloat.get(((Float) x).floatValue());\n-        } else if (x instanceof Double) {\n-            return ValueDouble.get(((Double) x).doubleValue());\n-        } else if (x instanceof byte[]) {\n-            return ValueBytes.get((byte[]) x);\n-        } else if (x instanceof Date) {\n-            return ValueDate.get((Date) x);\n-        } else if (x instanceof Time) {\n-            return ValueTime.get((Time) x);\n-        } else if (x instanceof Timestamp) {\n-            return ValueTimestamp.get((Timestamp) x);\n-        } else if (x instanceof java.util.Date) {\n-            return ValueTimestamp.fromMillis(((java.util.Date) x).getTime());\n-        } else if (x instanceof java.io.Reader) {\n-            Reader r = new BufferedReader((java.io.Reader) x);\n-            return session.getDataHandler().getLobStorage().\n-                    createClob(r, -1);\n-        } else if (x instanceof java.sql.Clob) {\n-            try {\n-                java.sql.Clob clob = (java.sql.Clob) x;\n-                Reader r = new BufferedReader(clob.getCharacterStream());\n-                return session.getDataHandler().getLobStorage().\n-                        createClob(r, clob.length());\n-            } catch (SQLException e) {\n-                throw DbException.convert(e);\n-            }\n-        } else if (x instanceof java.io.InputStream) {\n-            return session.getDataHandler().getLobStorage().\n-                    createBlob((java.io.InputStream) x, -1);\n-        } else if (x instanceof java.sql.Blob) {\n-            try {\n-                java.sql.Blob blob = (java.sql.Blob) x;\n-                return session.getDataHandler().getLobStorage().\n-                        createBlob(blob.getBinaryStream(), blob.length());\n-            } catch (SQLException e) {\n-                throw DbException.convert(e);\n-            }\n-        } else if (x instanceof java.sql.SQLXML) {\n-            try {\n-                java.sql.SQLXML clob = (java.sql.SQLXML) x;\n-                Reader r = new BufferedReader(clob.getCharacterStream());\n-                return session.getDataHandler().getLobStorage().\n-                        createClob(r, -1);\n-            } catch (SQLException e) {\n-                throw DbException.convert(e);\n-            }\n-        } else if (x instanceof java.sql.Array) {\n-            java.sql.Array array = (java.sql.Array) x;\n-            try {\n-                return convertToValue(session, array.getArray(), Value.ARRAY);\n-            } catch (SQLException e) {\n-                throw DbException.convert(e);\n-            }\n-        } else if (x instanceof ResultSet) {\n-            if (x instanceof SimpleResultSet) {\n-                return ValueResultSet.get((ResultSet) x);\n-            }\n-            return ValueResultSet.getCopy((ResultSet) x, Integer.MAX_VALUE);\n-        } else if (x instanceof UUID) {\n-            return ValueUuid.get((UUID) x);\n-        }\n-        Class<?> clazz = x.getClass();\n-        if (x instanceof Object[]) {\n-            // (a.getClass().isArray());\n-            // (a.getClass().getComponentType().isPrimitive());\n-            Object[] o = (Object[]) x;\n-            int len = o.length;\n-            Value[] v = new Value[len];\n-            for (int i = 0; i < len; i++) {\n-                v[i] = convertToValue(session, o[i], type);\n-            }\n-            return ValueArray.get(clazz.getComponentType(), v);\n-        } else if (x instanceof Character) {\n-            return ValueStringFixed.get(((Character) x).toString());\n-        } else if (isGeometry(x)) {\n-            return ValueGeometry.getFromGeometry(x);\n-        } else if (clazz == LocalDateTimeUtils.LOCAL_DATE) {\n-            return LocalDateTimeUtils.localDateToDateValue(x);\n-        } else if (clazz == LocalDateTimeUtils.LOCAL_TIME) {\n-            return LocalDateTimeUtils.localTimeToTimeValue(x);\n-        } else if (clazz == LocalDateTimeUtils.LOCAL_DATE_TIME) {\n-            return LocalDateTimeUtils.localDateTimeToValue(x);\n-        } else if (clazz == LocalDateTimeUtils.INSTANT) {\n-            return LocalDateTimeUtils.instantToValue(x);\n-        } else if (clazz == LocalDateTimeUtils.OFFSET_DATE_TIME) {\n-            return LocalDateTimeUtils.offsetDateTimeToValue(x);\n-        } else if (x instanceof TimestampWithTimeZone) {\n-            return ValueTimestampTimeZone.get((TimestampWithTimeZone) x);\n-        } else {\n-            if (JdbcUtils.customDataTypesHandler != null) {\n-                return JdbcUtils.customDataTypesHandler.getValue(type, x,\n-                        session.getDataHandler());\n-            }\n-            return ValueJavaObject.getNoCopy(x, null, session.getDataHandler());\n-        }\n+  private static Value convertToValue1(SessionInterface session, Object x,\n+                                       int type) {\n+    if (x == null) {\n+      return ValueNull.INSTANCE;\n+    }\n+    if (type == Value.JAVA_OBJECT) {\n+      return ValueJavaObject.getNoCopy(x, null, session.getDataHandler());\n+    }\n+    if (x instanceof String) {\n+      return ValueString.get((String) x);\n+    } else if (x instanceof Value) {\n+      return (Value) x;\n+    } else if (x instanceof Long) {\n+      return ValueLong.get(((Long) x).longValue());\n+    } else if (x instanceof Integer) {\n+      return ValueInt.get(((Integer) x).intValue());\n+    } else if (x instanceof BigInteger) {\n+      return ValueDecimal.get(new BigDecimal((BigInteger) x));\n+    } else if (x instanceof BigDecimal) {\n+      return ValueDecimal.get((BigDecimal) x);\n+    } else if (x instanceof Boolean) {\n+      return ValueBoolean.get(((Boolean) x).booleanValue());\n+    } else if (x instanceof Byte) {\n+      return ValueByte.get(((Byte) x).byteValue());\n+    } else if (x instanceof Short) {\n+      return ValueShort.get(((Short) x).shortValue());\n+    } else if (x instanceof Float) {\n+      return ValueFloat.get(((Float) x).floatValue());\n+    } else if (x instanceof Double) {\n+      return ValueDouble.get(((Double) x).doubleValue());\n+    } else if (x instanceof byte[]) {\n+      return ValueBytes.get((byte[]) x);\n+    } else if (x instanceof Date) {\n+      return ValueDate.get((Date) x);\n+    } else if (x instanceof Time) {\n+      return ValueTime.get((Time) x);\n+    } else if (x instanceof Timestamp) {\n+      return ValueTimestamp.get((Timestamp) x);\n+    } else if (x instanceof java.util.Date) {\n+      return ValueTimestamp.fromMillis(((java.util.Date) x).getTime());\n+    } else if (x instanceof java.io.Reader) {\n+      Reader r = new BufferedReader((java.io.Reader) x);\n+      return session.getDataHandler().getLobStorage().\n+          createClob(r, -1);\n+    } else if (x instanceof java.sql.Clob) {\n+      try {\n+        java.sql.Clob clob = (java.sql.Clob) x;\n+        Reader r = new BufferedReader(clob.getCharacterStream());\n+        return session.getDataHandler().getLobStorage().\n+            createClob(r, clob.length());\n+      } catch (SQLException e) {\n+        throw DbException.convert(e);\n+      }\n+    } else if (x instanceof java.io.InputStream) {\n+      return session.getDataHandler().getLobStorage().\n+          createBlob((java.io.InputStream) x, -1);\n+    } else if (x instanceof java.sql.Blob) {\n+      try {\n+        java.sql.Blob blob = (java.sql.Blob) x;\n+        return session.getDataHandler().getLobStorage().\n+            createBlob(blob.getBinaryStream(), blob.length());\n+      } catch (SQLException e) {\n+        throw DbException.convert(e);\n+      }\n+    } else if (x instanceof java.sql.SQLXML) {\n+      try {\n+        java.sql.SQLXML clob = (java.sql.SQLXML) x;\n+        Reader r = new BufferedReader(clob.getCharacterStream());\n+        return session.getDataHandler().getLobStorage().\n+            createClob(r, -1);\n+      } catch (SQLException e) {\n+        throw DbException.convert(e);\n+      }\n+    } else if (x instanceof java.sql.Array) {\n+      java.sql.Array array = (java.sql.Array) x;\n+      try {\n+        return convertToValue(session, array.getArray(), Value.ARRAY);\n+      } catch (SQLException e) {\n+        throw DbException.convert(e);\n+      }\n+    } else if (x instanceof ResultSet) {\n+      if (x instanceof SimpleResultSet) {\n+        return ValueResultSet.get((ResultSet) x);\n+      }\n+      return ValueResultSet.getCopy((ResultSet) x, Integer.MAX_VALUE);\n+    } else if (x instanceof UUID) {\n+      return ValueUuid.get((UUID) x);\n+    }\n+    Class<?> clazz = x.getClass();\n+    if (x instanceof Object[]) {\n+      // (a.getClass().isArray());\n+      // (a.getClass().getComponentType().isPrimitive());\n+      Object[] o = (Object[]) x;\n+      int len = o.length;\n+      Value[] v = new Value[len];\n+      for (int i = 0; i < len; i++) {\n+        v[i] = convertToValue(session, o[i], type);\n+      }\n+      return ValueArray.get(clazz.getComponentType(), v);\n+    } else if (x instanceof Character) {\n+      return ValueStringFixed.get(((Character) x).toString());\n+    } else if (isGeometry(x)) {\n+      return ValueGeometry.getFromGeometry(x);\n+    } else if (clazz == LocalDateTimeUtils.LOCAL_DATE) {\n+      return LocalDateTimeUtils.localDateToDateValue(x);\n+    } else if (clazz == LocalDateTimeUtils.LOCAL_TIME) {\n+      return LocalDateTimeUtils.localTimeToTimeValue(x);\n+    } else if (clazz == LocalDateTimeUtils.LOCAL_DATE_TIME) {\n+      return LocalDateTimeUtils.localDateTimeToValue(x);\n+    } else if (clazz == LocalDateTimeUtils.INSTANT) {\n+      return LocalDateTimeUtils.instantToValue(x);\n+    } else if (clazz == LocalDateTimeUtils.OFFSET_DATE_TIME) {\n+      return LocalDateTimeUtils.offsetDateTimeToValue(x);\n+    } else if (x instanceof TimestampWithTimeZone) {\n+      return ValueTimestampTimeZone.get((TimestampWithTimeZone) x);\n+    } else {\n+      if (JdbcUtils.customDataTypesHandler != null) {\n+        return JdbcUtils.customDataTypesHandler.getValue(type, x,\n+            session.getDataHandler());\n+      }\n+      return ValueJavaObject.getNoCopy(x, null, session.getDataHandler());\n     }\n+  }\n \n \n-    /**\n-     * Check whether a given class matches the Geometry class.\n-     *\n-     * @param x the class\n-     * @return true if it is a Geometry class\n-     */\n-    public static boolean isGeometryClass(Class<?> x) {\n-        if (x == null || GEOMETRY_CLASS == null) {\n-            return false;\n-        }\n-        return GEOMETRY_CLASS.isAssignableFrom(x);\n+  /**\n+   * Check whether a given class matches the Geometry class.\n+   *\n+   * @param x the class\n+   * @return true if it is a Geometry class\n+   */\n+  public static boolean isGeometryClass(Class<?> x) {\n+    if (x == null || GEOMETRY_CLASS == null) {\n+      return false;\n     }\n+    return GEOMETRY_CLASS.isAssignableFrom(x);\n+  }\n \n-    /**\n-     * Check whether a given object is a Geometry object.\n-     *\n-     * @param x the the object\n-     * @return true if it is a Geometry object\n-     */\n-    public static boolean isGeometry(Object x) {\n-        if (x == null) {\n-            return false;\n-        }\n-        return isGeometryClass(x.getClass());\n+  /**\n+   * Check whether a given object is a Geometry object.\n+   *\n+   * @param x the the object\n+   * @return true if it is a Geometry object\n+   */\n+  public static boolean isGeometry(Object x) {\n+    if (x == null) {\n+      return false;\n     }\n+    return isGeometryClass(x.getClass());\n+  }\n \n-    /**\n-     * Get a data type object from a type name.\n-     *\n-     * @param s the type name\n-     * @param mode database mode\n-     * @return the data type object\n-     */\n-    public static DataType getTypeByName(String s, Mode mode) {\n-        DataType result = mode.typeByNameMap.get(s);\n-        if (result == null) {\n-            result = TYPES_BY_NAME.get(s);\n-            if (result == null && JdbcUtils.customDataTypesHandler != null) {\n-                result = JdbcUtils.customDataTypesHandler.getDataTypeByName(s);\n-            }\n-        }\n-        return result;\n+  /**\n+   * Get a data type object from a type name.\n+   *\n+   * @param s    the type name\n+   * @param mode database mode\n+   * @return the data type object\n+   */\n+  public static DataType getTypeByName(String s, Mode mode) {\n+    DataType result = mode.typeByNameMap.get(s);\n+    if (result == null) {\n+      result = TYPES_BY_NAME.get(s);\n+      if (result == null && JdbcUtils.customDataTypesHandler != null) {\n+        result = JdbcUtils.customDataTypesHandler.getDataTypeByName(s);\n+      }\n     }\n+    return result;\n+  }\n \n-    /**\n-     * Check if the given value type is a date-time type (TIME, DATE, TIMESTAMP,\n-     * TIMESTAMP_TZ).\n-     *\n-     * @param type the value type\n-     * @return true if the value type is a date-time type\n-     */\n-    public static boolean isDateTimeType(int type) {\n-        switch (type) {\n-        case Value.TIME:\n-        case Value.DATE:\n-        case Value.TIMESTAMP:\n-        case Value.TIMESTAMP_TZ:\n-            return true;\n-        default:\n-            return false;\n-        }\n+  /**\n+   * Check if the given value type is a date-time type (TIME, DATE, TIMESTAMP,\n+   * TIMESTAMP_TZ).\n+   *\n+   * @param type the value type\n+   * @return true if the value type is a date-time type\n+   */\n+  public static boolean isDateTimeType(int type) {\n+    switch (type) {\n+      case Value.TIME:\n+      case Value.DATE:\n+      case Value.TIMESTAMP:\n+      case Value.TIMESTAMP_TZ:\n+        return true;\n+      default:\n+        return false;\n     }\n+  }\n \n-    /**\n-     * Check if the given value type is a large object (BLOB or CLOB).\n-     *\n-     * @param type the value type\n-     * @return true if the value type is a lob type\n-     */\n-    public static boolean isLargeObject(int type) {\n-        return type == Value.BLOB || type == Value.CLOB;\n-    }\n+  /**\n+   * Check if the given value type is a large object (BLOB or CLOB).\n+   *\n+   * @param type the value type\n+   * @return true if the value type is a lob type\n+   */\n+  public static boolean isLargeObject(int type) {\n+    return type == Value.BLOB || type == Value.CLOB;\n+  }\n \n-    /**\n-     * Check if the given value type is a String (VARCHAR,...).\n-     *\n-     * @param type the value type\n-     * @return true if the value type is a String type\n-     */\n-    public static boolean isStringType(int type) {\n-        return type == Value.STRING || type == Value.STRING_FIXED || type == Value.STRING_IGNORECASE;\n-    }\n+  /**\n+   * Check if the given value type is a String (VARCHAR,...).\n+   *\n+   * @param type the value type\n+   * @return true if the value type is a String type\n+   */\n+  public static boolean isStringType(int type) {\n+    return type == Value.STRING || type == Value.STRING_FIXED || type == Value.STRING_IGNORECASE;\n+  }\n \n-    /**\n-     * Check if the given value type supports the add operation.\n-     *\n-     * @param type the value type\n-     * @return true if add is supported\n-     */\n-    public static boolean supportsAdd(int type) {\n-        switch (type) {\n-        case Value.BYTE:\n-        case Value.DECIMAL:\n-        case Value.DOUBLE:\n-        case Value.FLOAT:\n-        case Value.INT:\n-        case Value.LONG:\n-        case Value.SHORT:\n-            return true;\n-        case Value.BOOLEAN:\n-        case Value.TIME:\n-        case Value.DATE:\n-        case Value.TIMESTAMP:\n-        case Value.TIMESTAMP_TZ:\n-        case Value.BYTES:\n-        case Value.UUID:\n-        case Value.STRING:\n-        case Value.STRING_IGNORECASE:\n-        case Value.STRING_FIXED:\n-        case Value.BLOB:\n-        case Value.CLOB:\n-        case Value.NULL:\n-        case Value.JAVA_OBJECT:\n-        case Value.UNKNOWN:\n-        case Value.ARRAY:\n-        case Value.RESULT_SET:\n-        case Value.GEOMETRY:\n-            return false;\n-        default:\n-            if (JdbcUtils.customDataTypesHandler != null) {\n-                return JdbcUtils.customDataTypesHandler.supportsAdd(type);\n-            }\n-            return false;\n+  /**\n+   * Check if the given value type supports the add operation.\n+   *\n+   * @param type the value type\n+   * @return true if add is supported\n+   */\n+  public static boolean supportsAdd(int type) {\n+    switch (type) {\n+      case Value.BYTE:\n+      case Value.DECIMAL:\n+      case Value.DOUBLE:\n+      case Value.FLOAT:\n+      case Value.INT:\n+      case Value.LONG:\n+      case Value.SHORT:\n+        return true;\n+      case Value.BOOLEAN:\n+      case Value.TIME:\n+      case Value.DATE:\n+      case Value.TIMESTAMP:\n+      case Value.TIMESTAMP_TZ:\n+      case Value.BYTES:\n+      case Value.UUID:\n+      case Value.STRING:\n+      case Value.STRING_IGNORECASE:\n+      case Value.STRING_FIXED:\n+      case Value.BLOB:\n+      case Value.CLOB:\n+      case Value.NULL:\n+      case Value.JAVA_OBJECT:\n+      case Value.UNKNOWN:\n+      case Value.ARRAY:\n+      case Value.RESULT_SET:\n+      case Value.GEOMETRY:\n+        return false;\n+      default:\n+        if (JdbcUtils.customDataTypesHandler != null) {\n+          return JdbcUtils.customDataTypesHandler.supportsAdd(type);\n         }\n+        return false;\n     }\n+  }\n \n-    /**\n-     * Get the data type that will not overflow when calling 'add' 2 billion\n-     * times.\n-     *\n-     * @param type the value type\n-     * @return the data type that supports adding\n-     */\n-    public static int getAddProofType(int type) {\n-        switch (type) {\n-        case Value.BYTE:\n-            return Value.LONG;\n-        case Value.FLOAT:\n-            return Value.DOUBLE;\n-        case Value.INT:\n-            return Value.LONG;\n-        case Value.LONG:\n-            return Value.DECIMAL;\n-        case Value.SHORT:\n-            return Value.LONG;\n-        case Value.BOOLEAN:\n-        case Value.DECIMAL:\n-        case Value.TIME:\n-        case Value.DATE:\n-        case Value.TIMESTAMP:\n-        case Value.TIMESTAMP_TZ:\n-        case Value.BYTES:\n-        case Value.UUID:\n-        case Value.STRING:\n-        case Value.STRING_IGNORECASE:\n-        case Value.STRING_FIXED:\n-        case Value.BLOB:\n-        case Value.CLOB:\n-        case Value.DOUBLE:\n-        case Value.NULL:\n-        case Value.JAVA_OBJECT:\n-        case Value.UNKNOWN:\n-        case Value.ARRAY:\n-        case Value.RESULT_SET:\n-        case Value.GEOMETRY:\n-            return type;\n-        default:\n-            if (JdbcUtils.customDataTypesHandler != null) {\n-                return JdbcUtils.customDataTypesHandler.getAddProofType(type);\n-            }\n-            return type;\n+  /**\n+   * Get the data type that will not overflow when calling 'add' 2 billion\n+   * times.\n+   *\n+   * @param type the value type\n+   * @return the data type that supports adding\n+   */\n+  public static int getAddProofType(int type) {\n+    switch (type) {\n+      case Value.BYTE:\n+        return Value.LONG;\n+      case Value.FLOAT:\n+        return Value.DOUBLE;\n+      case Value.INT:\n+        return Value.LONG;\n+      case Value.LONG:\n+        return Value.DECIMAL;\n+      case Value.SHORT:\n+        return Value.LONG;\n+      case Value.BOOLEAN:\n+      case Value.DECIMAL:\n+      case Value.TIME:\n+      case Value.DATE:\n+      case Value.TIMESTAMP:\n+      case Value.TIMESTAMP_TZ:\n+      case Value.BYTES:\n+      case Value.UUID:\n+      case Value.STRING:\n+      case Value.STRING_IGNORECASE:\n+      case Value.STRING_FIXED:\n+      case Value.BLOB:\n+      case Value.CLOB:\n+      case Value.DOUBLE:\n+      case Value.NULL:\n+      case Value.JAVA_OBJECT:\n+      case Value.UNKNOWN:\n+      case Value.ARRAY:\n+      case Value.RESULT_SET:\n+      case Value.GEOMETRY:\n+        return type;\n+      default:\n+        if (JdbcUtils.customDataTypesHandler != null) {\n+          return JdbcUtils.customDataTypesHandler.getAddProofType(type);\n         }\n+        return type;\n     }\n+  }\n \n-    /**\n-     * Get the default value in the form of a Java object for the given Java\n-     * class.\n-     *\n-     * @param clazz the Java class\n-     * @return the default object\n-     */\n-    public static Object getDefaultForPrimitiveType(Class<?> clazz) {\n-        if (clazz == Boolean.TYPE) {\n-            return Boolean.FALSE;\n-        } else if (clazz == Byte.TYPE) {\n-            return (byte) 0;\n-        } else if (clazz == Character.TYPE) {\n-            return (char) 0;\n-        } else if (clazz == Short.TYPE) {\n-            return (short) 0;\n-        } else if (clazz == Integer.TYPE) {\n-            return 0;\n-        } else if (clazz == Long.TYPE) {\n-            return 0L;\n-        } else if (clazz == Float.TYPE) {\n-            return (float) 0;\n-        } else if (clazz == Double.TYPE) {\n-            return (double) 0;\n-        }\n-        throw DbException.throwInternalError(\n-                \"primitive=\" + clazz.toString());\n+  /**\n+   * Get the default value in the form of a Java object for the given Java\n+   * class.\n+   *\n+   * @param clazz the Java class\n+   * @return the default object\n+   */\n+  public static Object getDefaultForPrimitiveType(Class<?> clazz) {\n+    if (clazz == Boolean.TYPE) {\n+      return Boolean.FALSE;\n+    } else if (clazz == Byte.TYPE) {\n+      return (byte) 0;\n+    } else if (clazz == Character.TYPE) {\n+      return (char) 0;\n+    } else if (clazz == Short.TYPE) {\n+      return (short) 0;\n+    } else if (clazz == Integer.TYPE) {\n+      return 0;\n+    } else if (clazz == Long.TYPE) {\n+      return 0L;\n+    } else if (clazz == Float.TYPE) {\n+      return (float) 0;\n+    } else if (clazz == Double.TYPE) {\n+      return (double) 0;\n     }\n+    throw DbException.throwInternalError(\n+        \"primitive=\" + clazz.toString());\n+  }\n \n-    /**\n-     * Convert a value to the specified class.\n-     *\n-     * @param conn the database connection\n-     * @param v the value\n-     * @param paramClass the target class\n-     * @return the converted object\n-     */\n-    public static Object convertTo(JdbcConnection conn, Value v,\n-            Class<?> paramClass) {\n-        if (paramClass == Blob.class) {\n-            return new JdbcBlob(conn, v, JdbcLob.State.WITH_VALUE, 0);\n-        } else if (paramClass == Clob.class) {\n-            return new JdbcClob(conn, v, JdbcLob.State.WITH_VALUE, 0);\n-        } else if (paramClass == Array.class) {\n-            return new JdbcArray(conn, v, 0);\n-        }\n-        switch (v.getType()) {\n-        case Value.JAVA_OBJECT: {\n-            Object o = SysProperties.serializeJavaObject ? JdbcUtils.deserialize(v.getBytes(),\n-                    conn.getSession().getDataHandler()) : v.getObject();\n-            if (paramClass.isAssignableFrom(o.getClass())) {\n-                return o;\n-            }\n-            break;\n+  /**\n+   * Convert a value to the specified class.\n+   *\n+   * @param conn       the database connection\n+   * @param v          the value\n+   * @param paramClass the target class\n+   * @return the converted object\n+   */\n+  public static Object convertTo(JdbcConnection conn, Value v,\n+                                 Class<?> paramClass) {\n+    if (paramClass == Blob.class) {\n+      return new JdbcBlob(conn, v, JdbcLob.State.WITH_VALUE, 0);\n+    } else if (paramClass == Clob.class) {\n+      return new JdbcClob(conn, v, JdbcLob.State.WITH_VALUE, 0);\n+    } else if (paramClass == Array.class) {\n+      return new JdbcArray(conn, v, 0);\n+    }\n+    switch (v.getType()) {\n+      case Value.JAVA_OBJECT: {\n+        Object o = SysProperties.serializeJavaObject ? JdbcUtils.deserialize(v.getBytes(),\n+            conn.getSession().getDataHandler()) : v.getObject();\n+        if (paramClass.isAssignableFrom(o.getClass())) {\n+          return o;\n         }\n-        case Value.BOOLEAN:\n-        case Value.BYTE:\n-        case Value.SHORT:\n-        case Value.INT:\n-        case Value.LONG:\n-        case Value.DECIMAL:\n-        case Value.TIME:\n-        case Value.DATE:\n-        case Value.TIMESTAMP:\n-        case Value.TIMESTAMP_TZ:\n-        case Value.BYTES:\n-        case Value.UUID:\n-        case Value.STRING:\n-        case Value.STRING_IGNORECASE:\n-        case Value.STRING_FIXED:\n-        case Value.BLOB:\n-        case Value.CLOB:\n-        case Value.DOUBLE:\n-        case Value.FLOAT:\n-        case Value.NULL:\n-        case Value.UNKNOWN:\n-        case Value.ARRAY:\n-        case Value.RESULT_SET:\n-        case Value.GEOMETRY:\n-            break;\n-        default:\n-            if (JdbcUtils.customDataTypesHandler != null) {\n-                return JdbcUtils.customDataTypesHandler.getObject(v, paramClass);\n-            }\n+        break;\n+      }\n+      case Value.BOOLEAN:\n+      case Value.BYTE:\n+      case Value.SHORT:\n+      case Value.INT:\n+      case Value.LONG:\n+      case Value.DECIMAL:\n+      case Value.TIME:\n+      case Value.DATE:\n+      case Value.TIMESTAMP:\n+      case Value.TIMESTAMP_TZ:\n+      case Value.BYTES:\n+      case Value.UUID:\n+      case Value.STRING:\n+      case Value.STRING_IGNORECASE:\n+      case Value.STRING_FIXED:\n+      case Value.BLOB:\n+      case Value.CLOB:\n+      case Value.DOUBLE:\n+      case Value.FLOAT:\n+      case Value.NULL:\n+      case Value.UNKNOWN:\n+      case Value.ARRAY:\n+      case Value.RESULT_SET:\n+      case Value.GEOMETRY:\n+        break;\n+      default:\n+        if (JdbcUtils.customDataTypesHandler != null) {\n+          return JdbcUtils.customDataTypesHandler.getObject(v, paramClass);\n         }\n-        throw DbException.getUnsupportedException(\"converting to class \" + paramClass.getName());\n     }\n+    throw DbException.getUnsupportedException(\"converting to class \" + paramClass.getName());\n+  }\n \n }\n",
            "diff_size": 1765
        },
        {
            "tool": "naturalize",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/212/DataType.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/naturalize/212/DataType.java\nindex 25d132e0f11..d0c5c48e435 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/212/DataType.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/naturalize/212/DataType.java\n@@ -302,7 +302,7 @@ public class DataType {\n                         \"TIMESTAMP\", true, ValueTimestamp.DEFAULT_SCALE, ValueTimestamp.MAXIMUM_SCALE),\n                 new String[]{\"TIMESTAMP\", \"TIMESTAMP WITHOUT TIME ZONE\",\n                         \"DATETIME\", \"DATETIME2\", \"SMALLDATETIME\"},\n-                // 24 for ValueTimestamp, 32 for java.sql.Timestamp\n+    // 24 for ValueTimestamp, 32 for java.sql.Timestamp\n                 56\n         );\n         // 2014 is the value of Types.TIMESTAMP_WITH_TIMEZONE\n@@ -724,10 +724,9 @@ public class DataType {\n             }\n             default:\n                 if (JdbcUtils.customDataTypesHandler != null) {\n-                    return JdbcUtils.customDataTypesHandler.getValue(type,\n-                        rs.getObject(columnIndex),\n+                    return JdbcUtils.customDataTypesHandler.getValue(type, rs.getObject(columnIndex),\n                         session.getDataHandler());\n-                }\n+    }\n                 throw DbException.throwInternalError(\"type=\"+type);\n             }\n             return v;\n@@ -935,7 +934,8 @@ public class DataType {\n             return Value.TIME;\n         case Types.TIMESTAMP:\n             return Value.TIMESTAMP;\n-        case 2014: // Types.TIMESTAMP_WITH_TIMEZONE\n+        case 2014:\n+    // Types.TIMESTAMP_WITH_TIMEZONE\n             return Value.TIMESTAMP_TZ;\n         case Types.BLOB:\n             return Value.BLOB;\n@@ -999,10 +999,8 @@ public class DataType {\n             return Value.RESULT_SET;\n         } else if (ValueLobDb.class.isAssignableFrom(x)) {\n             return Value.BLOB;\n-// FIXME no way to distinguish between these 2 types\n-//        } else if (ValueLobDb.class.isAssignableFrom(x)) {\n-//            return Value.CLOB;\n-        } else if (Date.class.isAssignableFrom(x)) {\n+// FI\n+    } else if (Date.class.isAssignableFrom(x)) {\n             return Value.DATE;\n         } else if (Time.class.isAssignableFrom(x)) {\n             return Value.TIME;\n@@ -1443,4 +1441,4 @@ public class DataType {\n         throw DbException.getUnsupportedException(\"converting to class \" + paramClass.getName());\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 11
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "938",
                    "column": "20",
                    "severity": "warning",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/212/DataType.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/212/DataType.java\nindex 25d132e0f11..da906597475 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/212/DataType.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/212/DataType.java\n@@ -935,8 +935,9 @@ public class DataType {\n             return Value.TIME;\n         case Types.TIMESTAMP:\n             return Value.TIMESTAMP;\n-        case 2014: // Types.TIMESTAMP_WITH_TIMEZONE\n-            return Value.TIMESTAMP_TZ;\n+        case 2014:\n+        // Types.TIMESTAMP_WITH_TIMEZONE return Value.TIMESTAMP_TZ;\n+     return Value.TIMESTAMP_TZ;\n         case Types.BLOB:\n             return Value.BLOB;\n         case Types.CLOB:\n",
            "diff_size": 3
        }
    ],
    "repaired_by": [
        "styler",
        "naturalize",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "intellij",
        "codebuff",
        "styler_random"
    ]
}