{
    "project_name": "codefollower-H2-Research",
    "error_id": "457",
    "information": {
        "errors": [
            {
                "line": "923",
                "column": "33",
                "severity": "warning",
                "message": "Don't use trailing comments.",
                "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
            }
        ]
    },
    "source_code": "                    WeakReference<V> reference = e.reference;\n                    if (reference != null && reference.get() != null) {\n                        break;  // stop trimming if entry holds a value\n                    }\n                }\n                int hash = getHash(e.key);",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/457/CacheLongKeyLIRS.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler/457/CacheLongKeyLIRS.java\nindex 38c405ce2f4..91f7bafe3d4 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/457/CacheLongKeyLIRS.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler/457/CacheLongKeyLIRS.java\n@@ -920,8 +920,9 @@ public class CacheLongKeyLIRS<V> {\n                 if (queue2Size <= maxQueue2SizeHigh) {\n                     WeakReference<V> reference = e.reference;\n                     if (reference != null && reference.get() != null) {\n-                        break;  // stop trimming if entry holds a value\n-                    }\n+                        break;\n+                        // stop trimming if entry holds a value\n+                      }\n                 }\n                 int hash = getHash(e.key);\n                 remove(e.key, hash);\n",
            "diff_size": 3
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "927",
                    "column": "21",
                    "severity": "warning",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/457/CacheLongKeyLIRS.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/457/CacheLongKeyLIRS.java\nindex 38c405ce2f4..2d9d133bc60 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/457/CacheLongKeyLIRS.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/457/CacheLongKeyLIRS.java\n@@ -3,6 +3,7 @@\n  * and the EPL 1.0 (https://h2database.com/html/license.html).\n  * Initial Developer: H2 Group\n  */\n+\n package org.h2.mvstore.cache;\n \n import java.lang.ref.WeakReference;\n@@ -12,6 +13,7 @@ import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n+\n import org.h2.mvstore.DataUtils;\n \n /**\n@@ -40,1177 +42,1179 @@ import org.h2.mvstore.DataUtils;\n  * Write access and moving entries to the top of the stack is synchronized per\n  * segment.\n  *\n- * @author Thomas Mueller\n  * @param <V> the value type\n+ * @author Thomas Mueller\n  */\n public class CacheLongKeyLIRS<V> {\n \n+  /**\n+   * The maximum memory this cache should use.\n+   */\n+  private long maxMemory;\n+\n+  private final Segment<V>[] segments;\n+\n+  private final int segmentCount;\n+  private final int segmentShift;\n+  private final int segmentMask;\n+  private final int stackMoveDistance;\n+  private final int nonResidentQueueSize;\n+  private final int nonResidentQueueSizeHigh;\n+\n+  /**\n+   * Create a new cache with the given memory size.\n+   *\n+   * @param config the configuration\n+   */\n+  @SuppressWarnings(\"unchecked\")\n+  public CacheLongKeyLIRS(Config config) {\n+    setMaxMemory(config.maxMemory);\n+    this.nonResidentQueueSize = config.nonResidentQueueSize;\n+    this.nonResidentQueueSizeHigh = config.nonResidentQueueSizeHigh;\n+    DataUtils.checkArgument(\n+        Integer.bitCount(config.segmentCount) == 1,\n+        \"The segment count must be a power of 2, is {0}\", config.segmentCount);\n+    this.segmentCount = config.segmentCount;\n+    this.segmentMask = segmentCount - 1;\n+    this.stackMoveDistance = config.stackMoveDistance;\n+    segments = new Segment[segmentCount];\n+    clear();\n+    // use the high bits for the segment\n+    this.segmentShift = 32 - Integer.bitCount(segmentMask);\n+  }\n+\n+  /**\n+   * Remove all entries.\n+   */\n+  public void clear() {\n+    long max = getMaxItemSize();\n+    for (int i = 0; i < segmentCount; i++) {\n+      segments[i] = new Segment<>(max, stackMoveDistance, 8, nonResidentQueueSize,\n+          nonResidentQueueSizeHigh);\n+    }\n+  }\n+\n+  /**\n+   * Determines max size of the data item size to fit into cache\n+   *\n+   * @return data items size limit\n+   */\n+  public long getMaxItemSize() {\n+    return Math.max(1, maxMemory / segmentCount);\n+  }\n+\n+  private Entry<V> find(long key) {\n+    int hash = getHash(key);\n+    return getSegment(hash).find(key, hash);\n+  }\n+\n+  /**\n+   * Check whether there is a resident entry for the given key. This\n+   * method does not adjust the internal state of the cache.\n+   *\n+   * @param key the key (may not be null)\n+   * @return true if there is a resident entry\n+   */\n+  public boolean containsKey(long key) {\n+    Entry<V> e = find(key);\n+    return e != null && e.value != null;\n+  }\n+\n+  /**\n+   * Get the value for the given key if the entry is cached. This method does\n+   * not modify the internal state.\n+   *\n+   * @param key the key (may not be null)\n+   * @return the value, or null if there is no resident entry\n+   */\n+  public V peek(long key) {\n+    Entry<V> e = find(key);\n+    return e == null ? null : e.getValue();\n+  }\n+\n+  /**\n+   * Add an entry to the cache using the average memory size.\n+   *\n+   * @param key   the key (may not be null)\n+   * @param value the value (may not be null)\n+   * @return the old value, or null if there was no resident entry\n+   */\n+  public V put(long key, V value) {\n+    return put(key, value, sizeOf(value));\n+  }\n+\n+  /**\n+   * Add an entry to the cache. The entry may or may not exist in the\n+   * cache yet. This method will usually mark unknown entries as cold and\n+   * known entries as hot.\n+   *\n+   * @param key    the key (may not be null)\n+   * @param value  the value (may not be null)\n+   * @param memory the memory used for the given entry\n+   * @return the old value, or null if there was no resident entry\n+   */\n+  public V put(long key, V value, int memory) {\n+    if (value == null) {\n+      throw DataUtils.newIllegalArgumentException(\n+          \"The value may not be null\");\n+    }\n+    int hash = getHash(key);\n+    int segmentIndex = getSegmentIndex(hash);\n+    Segment<V> s = segments[segmentIndex];\n+    // check whether resize is required: synchronize on s, to avoid\n+    // concurrent resizes (concurrent reads read\n+    // from the old segment)\n+    synchronized (s) {\n+      s = resizeIfNeeded(s, segmentIndex);\n+      return s.put(key, hash, value, memory);\n+    }\n+  }\n+\n+  private Segment<V> resizeIfNeeded(Segment<V> s, int segmentIndex) {\n+    int newLen = s.getNewMapLen();\n+    if (newLen == 0) {\n+      return s;\n+    }\n+    // another thread might have resized\n+    // (as we retrieved the segment before synchronizing on it)\n+    Segment<V> s2 = segments[segmentIndex];\n+    if (s == s2) {\n+      // no other thread resized, so we do\n+      s = new Segment<>(s, newLen);\n+      segments[segmentIndex] = s;\n+    }\n+    return s;\n+  }\n+\n+  /**\n+   * Get the size of the given value. The default implementation returns 1.\n+   *\n+   * @param value the value\n+   * @return the size\n+   */\n+  protected int sizeOf(V value) {\n+    return 1;\n+  }\n+\n+  /**\n+   * Remove an entry. Both resident and non-resident entries can be\n+   * removed.\n+   *\n+   * @param key the key (may not be null)\n+   * @return the old value, or null if there was no resident entry\n+   */\n+  public V remove(long key) {\n+    int hash = getHash(key);\n+    int segmentIndex = getSegmentIndex(hash);\n+    Segment<V> s = segments[segmentIndex];\n+    // check whether resize is required: synchronize on s, to avoid\n+    // concurrent resizes (concurrent reads read\n+    // from the old segment)\n+    synchronized (s) {\n+      s = resizeIfNeeded(s, segmentIndex);\n+      return s.remove(key, hash);\n+    }\n+  }\n+\n+  /**\n+   * Get the memory used for the given key.\n+   *\n+   * @param key the key (may not be null)\n+   * @return the memory, or 0 if there is no resident entry\n+   */\n+  public int getMemory(long key) {\n+    Entry<V> e = find(key);\n+    return e == null ? 0 : e.getMemory();\n+  }\n+\n+  /**\n+   * Get the value for the given key if the entry is cached. This method\n+   * adjusts the internal state of the cache sometimes, to ensure commonly\n+   * used entries stay in the cache.\n+   *\n+   * @param key the key (may not be null)\n+   * @return the value, or null if there is no resident entry\n+   */\n+  public V get(long key) {\n+    int hash = getHash(key);\n+    Segment<V> s = getSegment(hash);\n+    Entry<V> e = s.find(key, hash);\n+    return s.get(e);\n+  }\n+\n+  private Segment<V> getSegment(int hash) {\n+    return segments[getSegmentIndex(hash)];\n+  }\n+\n+  private int getSegmentIndex(int hash) {\n+    return (hash >>> segmentShift) & segmentMask;\n+  }\n+\n+  /**\n+   * Get the hash code for the given key. The hash code is\n+   * further enhanced to spread the values more evenly.\n+   *\n+   * @param key the key\n+   * @return the hash code\n+   */\n+  static int getHash(long key) {\n+    int hash = (int) ((key >>> 32) ^ key);\n+    // a supplemental secondary hash function\n+    // to protect against hash codes that don't differ much\n+    hash = ((hash >>> 16) ^ hash) * 0x45d9f3b;\n+    hash = ((hash >>> 16) ^ hash) * 0x45d9f3b;\n+    hash = (hash >>> 16) ^ hash;\n+    return hash;\n+  }\n+\n+  /**\n+   * Get the currently used memory.\n+   *\n+   * @return the used memory\n+   */\n+  public long getUsedMemory() {\n+    long x = 0;\n+    for (Segment<V> s : segments) {\n+      x += s.usedMemory;\n+    }\n+    return x;\n+  }\n+\n+  /**\n+   * Set the maximum memory this cache should use. This will not\n+   * immediately cause entries to get removed however; it will only change\n+   * the limit. To resize the internal array, call the clear method.\n+   *\n+   * @param maxMemory the maximum size (1 or larger) in bytes\n+   */\n+  public void setMaxMemory(long maxMemory) {\n+    DataUtils.checkArgument(\n+        maxMemory > 0,\n+        \"Max memory must be larger than 0, is {0}\", maxMemory);\n+    this.maxMemory = maxMemory;\n+    if (segments != null) {\n+      long max = 1 + maxMemory / segments.length;\n+      for (Segment<V> s : segments) {\n+        s.setMaxMemory(max);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Get the maximum memory to use.\n+   *\n+   * @return the maximum memory\n+   */\n+  public long getMaxMemory() {\n+    return maxMemory;\n+  }\n+\n+  /**\n+   * Get the entry set for all resident entries.\n+   *\n+   * @return the entry set\n+   */\n+  public synchronized Set<Map.Entry<Long, V>> entrySet() {\n+    HashMap<Long, V> map = new HashMap<>();\n+    for (long k : keySet()) {\n+      V value = peek(k);\n+      if (value != null) {\n+        map.put(k, value);\n+      }\n+    }\n+    return map.entrySet();\n+  }\n+\n+  /**\n+   * Get the set of keys for resident entries.\n+   *\n+   * @return the set of keys\n+   */\n+  public Set<Long> keySet() {\n+    HashSet<Long> set = new HashSet<>();\n+    for (Segment<V> s : segments) {\n+      set.addAll(s.keySet());\n+    }\n+    return set;\n+  }\n+\n+  /**\n+   * Get the number of non-resident entries in the cache.\n+   *\n+   * @return the number of non-resident entries\n+   */\n+  public int sizeNonResident() {\n+    int x = 0;\n+    for (Segment<V> s : segments) {\n+      x += s.queue2Size;\n+    }\n+    return x;\n+  }\n+\n+  /**\n+   * Get the length of the internal map array.\n+   *\n+   * @return the size of the array\n+   */\n+  public int sizeMapArray() {\n+    int x = 0;\n+    for (Segment<V> s : segments) {\n+      x += s.entries.length;\n+    }\n+    return x;\n+  }\n+\n+  /**\n+   * Get the number of hot entries in the cache.\n+   *\n+   * @return the number of hot entries\n+   */\n+  public int sizeHot() {\n+    int x = 0;\n+    for (Segment<V> s : segments) {\n+      x += s.mapSize - s.queueSize - s.queue2Size;\n+    }\n+    return x;\n+  }\n+\n+  /**\n+   * Get the number of cache hits.\n+   *\n+   * @return the cache hits\n+   */\n+  public long getHits() {\n+    long x = 0;\n+    for (Segment<V> s : segments) {\n+      x += s.hits;\n+    }\n+    return x;\n+  }\n+\n+  /**\n+   * Get the number of cache misses.\n+   *\n+   * @return the cache misses\n+   */\n+  public long getMisses() {\n+    int x = 0;\n+    for (Segment<V> s : segments) {\n+      x += s.misses;\n+    }\n+    return x;\n+  }\n+\n+  /**\n+   * Get the number of resident entries.\n+   *\n+   * @return the number of entries\n+   */\n+  public int size() {\n+    int x = 0;\n+    for (Segment<V> s : segments) {\n+      x += s.mapSize - s.queue2Size;\n+    }\n+    return x;\n+  }\n+\n+  /**\n+   * Get the list of keys. This method allows to read the internal state of\n+   * the cache.\n+   *\n+   * @param cold        if true, only keys for the cold entries are returned\n+   * @param nonResident true for non-resident entries\n+   * @return the key list\n+   */\n+  public List<Long> keys(boolean cold, boolean nonResident) {\n+    ArrayList<Long> keys = new ArrayList<>();\n+    for (Segment<V> s : segments) {\n+      keys.addAll(s.keys(cold, nonResident));\n+    }\n+    return keys;\n+  }\n+\n+  /**\n+   * Get the values for all resident entries.\n+   *\n+   * @return the entry set\n+   */\n+  public List<V> values() {\n+    ArrayList<V> list = new ArrayList<>();\n+    for (long k : keySet()) {\n+      V value = peek(k);\n+      if (value != null) {\n+        list.add(value);\n+      }\n+    }\n+    return list;\n+  }\n+\n+  /**\n+   * Check whether the cache is empty.\n+   *\n+   * @return true if it is empty\n+   */\n+  public boolean isEmpty() {\n+    return size() == 0;\n+  }\n+\n+  /**\n+   * Check whether the given value is stored.\n+   *\n+   * @param value the value\n+   * @return true if it is stored\n+   */\n+  public boolean containsValue(V value) {\n+    return getMap().containsValue(value);\n+  }\n+\n+  /**\n+   * Convert this cache to a map.\n+   *\n+   * @return the map\n+   */\n+  public Map<Long, V> getMap() {\n+    HashMap<Long, V> map = new HashMap<>();\n+    for (long k : keySet()) {\n+      V x = peek(k);\n+      if (x != null) {\n+        map.put(k, x);\n+      }\n+    }\n+    return map;\n+  }\n+\n+  /**\n+   * Add all elements of the map to this cache.\n+   *\n+   * @param m the map\n+   */\n+  public void putAll(Map<Long, ? extends V> m) {\n+    for (Map.Entry<Long, ? extends V> e : m.entrySet()) {\n+      // copy only non-null entries\n+      put(e.getKey(), e.getValue());\n+    }\n+  }\n+\n+  /**\n+   * Loop through segments, trimming the non resident queue.\n+   */\n+  public void trimNonResidentQueue() {\n+    for (Segment<V> s : segments) {\n+      synchronized (s) {\n+        s.trimNonResidentQueue();\n+      }\n+    }\n+  }\n+\n+  /**\n+   * A cache segment\n+   *\n+   * @param <V> the value type\n+   */\n+  private static class Segment<V> {\n+\n     /**\n-     * The maximum memory this cache should use.\n+     * The number of (hot, cold, and non-resident) entries in the map.\n      */\n-    private long maxMemory;\n-\n-    private final Segment<V>[] segments;\n+    int mapSize;\n \n-    private final int segmentCount;\n-    private final int segmentShift;\n-    private final int segmentMask;\n-    private final int stackMoveDistance;\n-    private final int nonResidentQueueSize;\n-    private final int nonResidentQueueSizeHigh;\n+    /**\n+     * The size of the LIRS queue for resident cold entries.\n+     */\n+    int queueSize;\n \n     /**\n-     * Create a new cache with the given memory size.\n-     *\n-     * @param config the configuration\n+     * The size of the LIRS queue for non-resident cold entries.\n      */\n-    @SuppressWarnings(\"unchecked\")\n-    public CacheLongKeyLIRS(Config config) {\n-        setMaxMemory(config.maxMemory);\n-        this.nonResidentQueueSize = config.nonResidentQueueSize;\n-        this.nonResidentQueueSizeHigh = config.nonResidentQueueSizeHigh;\n-        DataUtils.checkArgument(\n-                Integer.bitCount(config.segmentCount) == 1,\n-                \"The segment count must be a power of 2, is {0}\", config.segmentCount);\n-        this.segmentCount = config.segmentCount;\n-        this.segmentMask = segmentCount - 1;\n-        this.stackMoveDistance = config.stackMoveDistance;\n-        segments = new Segment[segmentCount];\n-        clear();\n-        // use the high bits for the segment\n-        this.segmentShift = 32 - Integer.bitCount(segmentMask);\n-    }\n+    int queue2Size;\n \n     /**\n-     * Remove all entries.\n+     * The number of cache hits.\n      */\n-    public void clear() {\n-        long max = getMaxItemSize();\n-        for (int i = 0; i < segmentCount; i++) {\n-            segments[i] = new Segment<>(max, stackMoveDistance, 8, nonResidentQueueSize,\n-                                        nonResidentQueueSizeHigh);\n-        }\n-    }\n+    long hits;\n \n     /**\n-     * Determines max size of the data item size to fit into cache\n-     * @return data items size limit\n+     * The number of cache misses.\n      */\n-    public long getMaxItemSize() {\n-        return Math.max(1, maxMemory / segmentCount);\n-    }\n+    long misses;\n \n-    private Entry<V> find(long key) {\n-        int hash = getHash(key);\n-        return getSegment(hash).find(key, hash);\n-    }\n+    /**\n+     * The map array. The size is always a power of 2.\n+     */\n+    final Entry<V>[] entries;\n \n     /**\n-     * Check whether there is a resident entry for the given key. This\n-     * method does not adjust the internal state of the cache.\n-     *\n-     * @param key the key (may not be null)\n-     * @return true if there is a resident entry\n+     * The currently used memory.\n      */\n-    public boolean containsKey(long key) {\n-        Entry<V> e = find(key);\n-        return e != null && e.value != null;\n-    }\n+    long usedMemory;\n \n     /**\n-     * Get the value for the given key if the entry is cached. This method does\n-     * not modify the internal state.\n-     *\n-     * @param key the key (may not be null)\n-     * @return the value, or null if there is no resident entry\n+     * How many other item are to be moved to the top of the stack before\n+     * the current item is moved.\n      */\n-    public V peek(long key) {\n-        Entry<V> e = find(key);\n-        return e == null ? null : e.getValue();\n-    }\n+    private final int stackMoveDistance;\n \n     /**\n-     * Add an entry to the cache using the average memory size.\n-     *\n-     * @param key the key (may not be null)\n-     * @param value the value (may not be null)\n-     * @return the old value, or null if there was no resident entry\n+     * The maximum memory this cache should use in bytes.\n      */\n-    public V put(long key, V value) {\n-        return put(key, value, sizeOf(value));\n-    }\n+    private long maxMemory;\n \n     /**\n-     * Add an entry to the cache. The entry may or may not exist in the\n-     * cache yet. This method will usually mark unknown entries as cold and\n-     * known entries as hot.\n-     *\n-     * @param key the key (may not be null)\n-     * @param value the value (may not be null)\n-     * @param memory the memory used for the given entry\n-     * @return the old value, or null if there was no resident entry\n+     * The bit mask that is applied to the key hash code to get the index in\n+     * the map array. The mask is the length of the array minus one.\n      */\n-    public V put(long key, V value, int memory) {\n-        if (value == null) {\n-            throw DataUtils.newIllegalArgumentException(\n-                    \"The value may not be null\");\n-        }\n-        int hash = getHash(key);\n-        int segmentIndex = getSegmentIndex(hash);\n-        Segment<V> s = segments[segmentIndex];\n-        // check whether resize is required: synchronize on s, to avoid\n-        // concurrent resizes (concurrent reads read\n-        // from the old segment)\n-        synchronized (s) {\n-            s = resizeIfNeeded(s, segmentIndex);\n-            return s.put(key, hash, value, memory);\n-        }\n-    }\n+    private final int mask;\n \n-    private Segment<V> resizeIfNeeded(Segment<V> s, int segmentIndex) {\n-        int newLen = s.getNewMapLen();\n-        if (newLen == 0) {\n-            return s;\n-        }\n-        // another thread might have resized\n-        // (as we retrieved the segment before synchronizing on it)\n-        Segment<V> s2 = segments[segmentIndex];\n-        if (s == s2) {\n-            // no other thread resized, so we do\n-            s = new Segment<>(s, newLen);\n-            segments[segmentIndex] = s;\n-        }\n-        return s;\n-    }\n+    /**\n+     * Low watermark for the number of entries in the non-resident queue,\n+     * as a factor of the number of entries in the map.\n+     */\n+    private final int nonResidentQueueSize;\n \n     /**\n-     * Get the size of the given value. The default implementation returns 1.\n-     *\n-     * @param value the value\n-     * @return the size\n+     * High watermark for the number of entries in the non-resident queue,\n+     * as a factor of the number of entries in the map.\n      */\n-    protected int sizeOf(V value) {\n-        return 1;\n-    }\n+    private final int nonResidentQueueSizeHigh;\n \n     /**\n-     * Remove an entry. Both resident and non-resident entries can be\n-     * removed.\n-     *\n-     * @param key the key (may not be null)\n-     * @return the old value, or null if there was no resident entry\n+     * The stack of recently referenced elements. This includes all hot\n+     * entries, and the recently referenced cold entries. Resident cold\n+     * entries that were not recently referenced, as well as non-resident\n+     * cold entries, are not in the stack.\n+     * <p>\n+     * There is always at least one entry: the head entry.\n      */\n-    public V remove(long key) {\n-        int hash = getHash(key);\n-        int segmentIndex = getSegmentIndex(hash);\n-        Segment<V> s = segments[segmentIndex];\n-        // check whether resize is required: synchronize on s, to avoid\n-        // concurrent resizes (concurrent reads read\n-        // from the old segment)\n-        synchronized (s) {\n-            s = resizeIfNeeded(s, segmentIndex);\n-            return s.remove(key, hash);\n-        }\n-    }\n+    private final Entry<V> stack;\n \n     /**\n-     * Get the memory used for the given key.\n-     *\n-     * @param key the key (may not be null)\n-     * @return the memory, or 0 if there is no resident entry\n+     * The number of entries in the stack.\n      */\n-    public int getMemory(long key) {\n-        Entry<V> e = find(key);\n-        return e == null ? 0 : e.getMemory();\n-    }\n+    private int stackSize;\n \n     /**\n-     * Get the value for the given key if the entry is cached. This method\n-     * adjusts the internal state of the cache sometimes, to ensure commonly\n-     * used entries stay in the cache.\n-     *\n-     * @param key the key (may not be null)\n-     * @return the value, or null if there is no resident entry\n+     * The queue of resident cold entries.\n+     * <p>\n+     * There is always at least one entry: the head entry.\n      */\n-    public V get(long key) {\n-        int hash = getHash(key);\n-        Segment<V> s = getSegment(hash);\n-        Entry<V> e = s.find(key, hash);\n-        return s.get(e);\n-    }\n+    private final Entry<V> queue;\n \n-    private Segment<V> getSegment(int hash) {\n-        return segments[getSegmentIndex(hash)];\n-    }\n+    /**\n+     * The queue of non-resident cold entries.\n+     * <p>\n+     * There is always at least one entry: the head entry.\n+     */\n+    private final Entry<V> queue2;\n \n-    private int getSegmentIndex(int hash) {\n-        return (hash >>> segmentShift) & segmentMask;\n-    }\n+    /**\n+     * The number of times any item was moved to the top of the stack.\n+     */\n+    private int stackMoveCounter;\n \n     /**\n-     * Get the hash code for the given key. The hash code is\n-     * further enhanced to spread the values more evenly.\n+     * Create a new cache segment.\n      *\n-     * @param key the key\n-     * @return the hash code\n+     * @param maxMemory                the maximum memory to use\n+     * @param stackMoveDistance        the number of other entries to be moved to\n+     *                                 the top of the stack before moving an entry to the top\n+     * @param len                      the number of hash table buckets (must be a power of 2)\n+     * @param nonResidentQueueSize     the non-resident queue size low watermark factor\n+     * @param nonResidentQueueSizeHigh the non-resident queue size high watermark factor\n      */\n-    static int getHash(long key) {\n-        int hash = (int) ((key >>> 32) ^ key);\n-        // a supplemental secondary hash function\n-        // to protect against hash codes that don't differ much\n-        hash = ((hash >>> 16) ^ hash) * 0x45d9f3b;\n-        hash = ((hash >>> 16) ^ hash) * 0x45d9f3b;\n-        hash = (hash >>> 16) ^ hash;\n-        return hash;\n+    Segment(long maxMemory, int stackMoveDistance, int len,\n+            int nonResidentQueueSize, int nonResidentQueueSizeHigh) {\n+      setMaxMemory(maxMemory);\n+      this.stackMoveDistance = stackMoveDistance;\n+      this.nonResidentQueueSize = nonResidentQueueSize;\n+      this.nonResidentQueueSizeHigh = nonResidentQueueSizeHigh;\n+\n+      // the bit mask has all bits set\n+      mask = len - 1;\n+\n+      // initialize the stack and queue heads\n+      stack = new Entry<>();\n+      stack.stackPrev = stack.stackNext = stack;\n+      queue = new Entry<>();\n+      queue.queuePrev = queue.queueNext = queue;\n+      queue2 = new Entry<>();\n+      queue2.queuePrev = queue2.queueNext = queue2;\n+\n+      @SuppressWarnings(\"unchecked\")\n+      Entry<V>[] e = new Entry[len];\n+      entries = e;\n     }\n \n     /**\n-     * Get the currently used memory.\n+     * Create a new cache segment from an existing one.\n+     * The caller must synchronize on the old segment, to avoid\n+     * concurrent modifications.\n      *\n-     * @return the used memory\n+     * @param old the old segment\n+     * @param len the number of hash table buckets (must be a power of 2)\n      */\n-    public long getUsedMemory() {\n-        long x = 0;\n-        for (Segment<V> s : segments) {\n-            x += s.usedMemory;\n+    Segment(Segment<V> old, int len) {\n+      this(old.maxMemory, old.stackMoveDistance, len,\n+          old.nonResidentQueueSize, old.nonResidentQueueSizeHigh);\n+      hits = old.hits;\n+      misses = old.misses;\n+      Entry<V> s = old.stack.stackPrev;\n+      while (s != old.stack) {\n+        Entry<V> e = new Entry<>(s);\n+        addToMap(e);\n+        addToStack(e);\n+        s = s.stackPrev;\n+      }\n+      s = old.queue.queuePrev;\n+      while (s != old.queue) {\n+        Entry<V> e = find(s.key, getHash(s.key));\n+        if (e == null) {\n+          e = new Entry<>(s);\n+          addToMap(e);\n         }\n-        return x;\n+        addToQueue(queue, e);\n+        s = s.queuePrev;\n+      }\n+      s = old.queue2.queuePrev;\n+      while (s != old.queue2) {\n+        Entry<V> e = find(s.key, getHash(s.key));\n+        if (e == null) {\n+          e = new Entry<>(s);\n+          addToMap(e);\n+        }\n+        addToQueue(queue2, e);\n+        s = s.queuePrev;\n+      }\n     }\n \n     /**\n-     * Set the maximum memory this cache should use. This will not\n-     * immediately cause entries to get removed however; it will only change\n-     * the limit. To resize the internal array, call the clear method.\n+     * Calculate the new number of hash table buckets if the internal map\n+     * should be re-sized.\n      *\n-     * @param maxMemory the maximum size (1 or larger) in bytes\n+     * @return 0 if no resizing is needed, or the new length\n      */\n-    public void setMaxMemory(long maxMemory) {\n-        DataUtils.checkArgument(\n-                maxMemory > 0,\n-                \"Max memory must be larger than 0, is {0}\", maxMemory);\n-        this.maxMemory = maxMemory;\n-        if (segments != null) {\n-            long max = 1 + maxMemory / segments.length;\n-            for (Segment<V> s : segments) {\n-                s.setMaxMemory(max);\n-            }\n-        }\n+    int getNewMapLen() {\n+      int len = mask + 1;\n+      if (len * 3 < mapSize * 4 && len < (1 << 28)) {\n+        // more than 75% usage\n+        return len * 2;\n+      } else if (len > 32 && len / 8 > mapSize) {\n+        // less than 12% usage\n+        return len / 2;\n+      }\n+      return 0;\n+    }\n+\n+    private void addToMap(Entry<V> e) {\n+      int index = getHash(e.key) & mask;\n+      e.mapNext = entries[index];\n+      entries[index] = e;\n+      usedMemory += e.getMemory();\n+      mapSize++;\n     }\n \n     /**\n-     * Get the maximum memory to use.\n+     * Get the value from the given entry.\n+     * This method adjusts the internal state of the cache sometimes,\n+     * to ensure commonly used entries stay in the cache.\n      *\n-     * @return the maximum memory\n+     * @param e the entry\n+     * @return the value, or null if there is no resident entry\n      */\n-    public long getMaxMemory() {\n-        return maxMemory;\n+    synchronized V get(Entry<V> e) {\n+      V value = e == null ? null : e.getValue();\n+      if (value == null) {\n+        // the entry was not found\n+        // or it was a non-resident entry\n+        misses++;\n+      } else {\n+        access(e);\n+        hits++;\n+      }\n+      return value;\n     }\n \n     /**\n-     * Get the entry set for all resident entries.\n+     * Access an item, moving the entry to the top of the stack or front of\n+     * the queue if found.\n      *\n-     * @return the entry set\n+     * @param e entry to record access for\n      */\n-    public synchronized Set<Map.Entry<Long, V>> entrySet() {\n-        HashMap<Long, V> map = new HashMap<>();\n-        for (long k : keySet()) {\n-            V value = peek(k);\n-            if (value != null) {\n-                map.put(k, value);\n+    private void access(Entry<V> e) {\n+      if (e.isHot()) {\n+        if (e != stack.stackNext && e.stackNext != null) {\n+          if (stackMoveCounter - e.topMove > stackMoveDistance) {\n+            // move a hot entry to the top of the stack\n+            // unless it is already there\n+            boolean wasEnd = e == stack.stackPrev;\n+            removeFromStack(e);\n+            if (wasEnd) {\n+              // if moving the last entry, the last entry\n+              // could now be cold, which is not allowed\n+              pruneStack();\n             }\n+            addToStack(e);\n+          }\n         }\n-        return map.entrySet();\n+      } else {\n+        V v = e.getValue();\n+        if (v != null) {\n+          removeFromQueue(e);\n+          if (e.reference != null) {\n+            e.value = v;\n+            e.reference = null;\n+            usedMemory += e.memory;\n+          }\n+          if (e.stackNext != null) {\n+            // resident, or even non-resident (weak value reference),\n+            // cold entries become hot if they are on the stack\n+            removeFromStack(e);\n+            // which means a hot entry needs to become cold\n+            // (this entry is cold, that means there is at least one\n+            // more entry in the stack, which must be hot)\n+            convertOldestHotToCold();\n+          } else {\n+            // cold entries that are not on the stack\n+            // move to the front of the queue\n+            addToQueue(queue, e);\n+          }\n+          // in any case, the cold entry is moved to the top of the stack\n+          addToStack(e);\n+          // but if newly promoted cold/non-resident is the only entry on a stack now\n+          // that means last one is cold, need to prune\n+          pruneStack();\n+        }\n+      }\n     }\n \n     /**\n-     * Get the set of keys for resident entries.\n+     * Add an entry to the cache. The entry may or may not exist in the\n+     * cache yet. This method will usually mark unknown entries as cold and\n+     * known entries as hot.\n      *\n-     * @return the set of keys\n+     * @param key    the key (may not be null)\n+     * @param hash   the hash\n+     * @param value  the value (may not be null)\n+     * @param memory the memory used for the given entry\n+     * @return the old value, or null if there was no resident entry\n      */\n-    public Set<Long> keySet() {\n-        HashSet<Long> set = new HashSet<>();\n-        for (Segment<V> s : segments) {\n-            set.addAll(s.keySet());\n+    synchronized V put(long key, int hash, V value, int memory) {\n+      Entry<V> e = find(key, hash);\n+      boolean existed = e != null;\n+      V old = null;\n+      if (existed) {\n+        old = e.getValue();\n+        remove(key, hash);\n+      }\n+      if (memory > maxMemory) {\n+        // the new entry is too big to fit\n+        return old;\n+      }\n+      e = new Entry<>(key, value, memory);\n+      int index = hash & mask;\n+      e.mapNext = entries[index];\n+      entries[index] = e;\n+      usedMemory += memory;\n+      if (usedMemory > maxMemory) {\n+        // old entries needs to be removed\n+        evict();\n+        // if the cache is full, the new entry is\n+        // cold if possible\n+        if (stackSize > 0) {\n+          // the new cold entry is at the top of the queue\n+          addToQueue(queue, e);\n         }\n-        return set;\n+      }\n+      mapSize++;\n+      // added entries are always added to the stack\n+      addToStack(e);\n+      if (existed) {\n+        // if it was there before (even non-resident), it becomes hot\n+        access(e);\n+      }\n+      return old;\n     }\n \n     /**\n-     * Get the number of non-resident entries in the cache.\n+     * Remove an entry. Both resident and non-resident entries can be\n+     * removed.\n      *\n-     * @return the number of non-resident entries\n+     * @param key  the key (may not be null)\n+     * @param hash the hash\n+     * @return the old value, or null if there was no resident entry\n      */\n-    public int sizeNonResident() {\n-        int x = 0;\n-        for (Segment<V> s : segments) {\n-            x += s.queue2Size;\n+    synchronized V remove(long key, int hash) {\n+      int index = hash & mask;\n+      Entry<V> e = entries[index];\n+      if (e == null) {\n+        return null;\n+      }\n+      if (e.key == key) {\n+        entries[index] = e.mapNext;\n+      } else {\n+        Entry<V> last;\n+        do {\n+          last = e;\n+          e = e.mapNext;\n+          if (e == null) {\n+            return null;\n+          }\n+        } while (e.key != key);\n+        last.mapNext = e.mapNext;\n+      }\n+      V old = e.getValue();\n+      mapSize--;\n+      usedMemory -= e.getMemory();\n+      if (e.stackNext != null) {\n+        removeFromStack(e);\n+      }\n+      if (e.isHot()) {\n+        // when removing a hot entry, the newest cold entry gets hot,\n+        // so the number of hot entries does not change\n+        e = queue.queueNext;\n+        if (e != queue) {\n+          removeFromQueue(e);\n+          if (e.stackNext == null) {\n+            addToStackBottom(e);\n+          }\n         }\n-        return x;\n+        pruneStack();\n+      } else {\n+        removeFromQueue(e);\n+      }\n+      return old;\n     }\n \n     /**\n-     * Get the length of the internal map array.\n-     *\n-     * @return the size of the array\n+     * Evict cold entries (resident and non-resident) until the memory limit\n+     * is reached. The new entry is added as a cold entry, except if it is\n+     * the only entry.\n      */\n-    public int sizeMapArray() {\n-        int x = 0;\n-        for (Segment<V> s : segments) {\n-            x += s.entries.length;\n-        }\n-        return x;\n+    private void evict() {\n+      do {\n+        evictBlock();\n+      } while (usedMemory > maxMemory);\n     }\n \n-    /**\n-     * Get the number of hot entries in the cache.\n-     *\n-     * @return the number of hot entries\n-     */\n-    public int sizeHot() {\n-        int x = 0;\n-        for (Segment<V> s : segments) {\n-            x += s.mapSize - s.queueSize - s.queue2Size;\n+    private void evictBlock() {\n+      // ensure there are not too many hot entries: right shift of 5 is\n+      // division by 32, that means if there are only 1/32 (3.125%) or\n+      // less cold entries, a hot entry needs to become cold\n+      while (queueSize <= ((mapSize - queue2Size) >>> 5) && stackSize > 0) {\n+        convertOldestHotToCold();\n+      }\n+      // the oldest resident cold entries become non-resident\n+      while (usedMemory > maxMemory && queueSize > 0) {\n+        Entry<V> e = queue.queuePrev;\n+        usedMemory -= e.memory;\n+        removeFromQueue(e);\n+        e.reference = new WeakReference<>(e.value);\n+        e.value = null;\n+        addToQueue(queue2, e);\n+        // the size of the non-resident-cold entries needs to be limited\n+        trimNonResidentQueue();\n+      }\n+    }\n+\n+    void trimNonResidentQueue() {\n+      int residentCount = mapSize - queue2Size;\n+      int maxQueue2SizeHigh = nonResidentQueueSizeHigh * residentCount;\n+      int maxQueue2Size = nonResidentQueueSize * residentCount;\n+      while (queue2Size > maxQueue2Size) {\n+        Entry<V> e = queue2.queuePrev;\n+        if (queue2Size <= maxQueue2SizeHigh) {\n+          WeakReference<V> reference = e.reference;\n+          if (reference != null && reference.get() != null) {\n+            break;  // stop trimming if entry holds a value\n+          }\n         }\n-        return x;\n+        int hash = getHash(e.key);\n+        remove(e.key, hash);\n+      }\n+    }\n+\n+    private void convertOldestHotToCold() {\n+      // the last entry of the stack is known to be hot\n+      Entry<V> last = stack.stackPrev;\n+      if (last == stack) {\n+        // never remove the stack head itself (this would mean the\n+        // internal structure of the cache is corrupt)\n+        throw new IllegalStateException();\n+      }\n+      // remove from stack - which is done anyway in the stack pruning,\n+      // but we can do it here as well\n+      removeFromStack(last);\n+      // adding an entry to the queue will make it cold\n+      addToQueue(queue, last);\n+      pruneStack();\n     }\n \n     /**\n-     * Get the number of cache hits.\n-     *\n-     * @return the cache hits\n+     * Ensure the last entry of the stack is cold.\n      */\n-    public long getHits() {\n-        long x = 0;\n-        for (Segment<V> s : segments) {\n-            x += s.hits;\n+    private void pruneStack() {\n+      while (true) {\n+        Entry<V> last = stack.stackPrev;\n+        // must stop at a hot entry or the stack head,\n+        // but the stack head itself is also hot, so we\n+        // don't have to test it\n+        if (last.isHot()) {\n+          break;\n         }\n-        return x;\n+        // the cold entry is still in the queue\n+        removeFromStack(last);\n+      }\n     }\n \n     /**\n-     * Get the number of cache misses.\n+     * Try to find an entry in the map.\n      *\n-     * @return the cache misses\n+     * @param key  the key\n+     * @param hash the hash\n+     * @return the entry (might be a non-resident)\n      */\n-    public long getMisses() {\n-        int x = 0;\n-        for (Segment<V> s : segments) {\n-            x += s.misses;\n-        }\n-        return x;\n+    Entry<V> find(long key, int hash) {\n+      int index = hash & mask;\n+      Entry<V> e = entries[index];\n+      while (e != null && e.key != key) {\n+        e = e.mapNext;\n+      }\n+      return e;\n+    }\n+\n+    private void addToStack(Entry<V> e) {\n+      e.stackPrev = stack;\n+      e.stackNext = stack.stackNext;\n+      e.stackNext.stackPrev = e;\n+      stack.stackNext = e;\n+      stackSize++;\n+      e.topMove = stackMoveCounter++;\n+    }\n+\n+    private void addToStackBottom(Entry<V> e) {\n+      e.stackNext = stack;\n+      e.stackPrev = stack.stackPrev;\n+      e.stackPrev.stackNext = e;\n+      stack.stackPrev = e;\n+      stackSize++;\n     }\n \n     /**\n-     * Get the number of resident entries.\n+     * Remove the entry from the stack. The head itself must not be removed.\n      *\n-     * @return the number of entries\n+     * @param e the entry\n      */\n-    public int size() {\n-        int x = 0;\n-        for (Segment<V> s : segments) {\n-            x += s.mapSize - s.queue2Size;\n-        }\n-        return x;\n+    private void removeFromStack(Entry<V> e) {\n+      e.stackPrev.stackNext = e.stackNext;\n+      e.stackNext.stackPrev = e.stackPrev;\n+      e.stackPrev = e.stackNext = null;\n+      stackSize--;\n+    }\n+\n+    private void addToQueue(Entry<V> q, Entry<V> e) {\n+      e.queuePrev = q;\n+      e.queueNext = q.queueNext;\n+      e.queueNext.queuePrev = e;\n+      q.queueNext = e;\n+      if (e.value != null) {\n+        queueSize++;\n+      } else {\n+        queue2Size++;\n+      }\n+    }\n+\n+    private void removeFromQueue(Entry<V> e) {\n+      e.queuePrev.queueNext = e.queueNext;\n+      e.queueNext.queuePrev = e.queuePrev;\n+      e.queuePrev = e.queueNext = null;\n+      if (e.value != null) {\n+        queueSize--;\n+      } else {\n+        queue2Size--;\n+      }\n     }\n \n     /**\n-     * Get the list of keys. This method allows to read the internal state of\n-     * the cache.\n+     * Get the list of keys. This method allows to read the internal state\n+     * of the cache.\n      *\n-     * @param cold if true, only keys for the cold entries are returned\n+     * @param cold        if true, only keys for the cold entries are returned\n      * @param nonResident true for non-resident entries\n      * @return the key list\n      */\n-    public List<Long> keys(boolean cold, boolean nonResident) {\n-        ArrayList<Long> keys = new ArrayList<>();\n-        for (Segment<V> s : segments) {\n-            keys.addAll(s.keys(cold, nonResident));\n+    synchronized List<Long> keys(boolean cold, boolean nonResident) {\n+      ArrayList<Long> keys = new ArrayList<>();\n+      if (cold) {\n+        Entry<V> start = nonResident ? queue2 : queue;\n+        for (Entry<V> e = start.queueNext; e != start;\n+             e = e.queueNext) {\n+          keys.add(e.key);\n         }\n-        return keys;\n+      } else {\n+        for (Entry<V> e = stack.stackNext; e != stack;\n+             e = e.stackNext) {\n+          keys.add(e.key);\n+        }\n+      }\n+      return keys;\n     }\n \n     /**\n-     * Get the values for all resident entries.\n+     * Get the set of keys for resident entries.\n      *\n-     * @return the entry set\n+     * @return the set of keys\n      */\n-    public List<V> values() {\n-        ArrayList<V> list = new ArrayList<>();\n-        for (long k : keySet()) {\n-            V value = peek(k);\n-            if (value != null) {\n-                list.add(value);\n-            }\n-        }\n-        return list;\n+    synchronized Set<Long> keySet() {\n+      HashSet<Long> set = new HashSet<>();\n+      for (Entry<V> e = stack.stackNext; e != stack; e = e.stackNext) {\n+        set.add(e.key);\n+      }\n+      for (Entry<V> e = queue.queueNext; e != queue; e = e.queueNext) {\n+        set.add(e.key);\n+      }\n+      return set;\n     }\n \n     /**\n-     * Check whether the cache is empty.\n+     * Set the maximum memory this cache should use. This will not\n+     * immediately cause entries to get removed however; it will only change\n+     * the limit. To resize the internal array, call the clear method.\n      *\n-     * @return true if it is empty\n+     * @param maxMemory the maximum size (1 or larger) in bytes\n      */\n-    public boolean isEmpty() {\n-        return size() == 0;\n+    void setMaxMemory(long maxMemory) {\n+      this.maxMemory = maxMemory;\n     }\n \n+  }\n+\n+  /**\n+   * A cache entry. Each entry is either hot (low inter-reference recency;\n+   * LIR), cold (high inter-reference recency; HIR), or non-resident-cold. Hot\n+   * entries are in the stack only. Cold entries are in the queue, and may be\n+   * in the stack. Non-resident-cold entries have their value set to null and\n+   * are in the stack and in the non-resident queue.\n+   *\n+   * @param <V> the value type\n+   */\n+  static class Entry<V> {\n+\n     /**\n-     * Check whether the given value is stored.\n-     *\n-     * @param value the value\n-     * @return true if it is stored\n+     * The key.\n      */\n-    public boolean containsValue(V value) {\n-        return getMap().containsValue(value);\n-    }\n+    final long key;\n \n     /**\n-     * Convert this cache to a map.\n-     *\n-     * @return the map\n+     * The value. Set to null for non-resident-cold entries.\n      */\n-    public Map<Long, V> getMap() {\n-        HashMap<Long, V> map = new HashMap<>();\n-        for (long k : keySet()) {\n-            V x = peek(k);\n-            if (x != null) {\n-                map.put(k, x);\n-            }\n-        }\n-        return map;\n-    }\n+    V value;\n \n     /**\n-     * Add all elements of the map to this cache.\n-     *\n-     * @param m the map\n+     * Weak reference to the value. Set to null for resident entries.\n      */\n-    public void putAll(Map<Long, ? extends V> m) {\n-        for (Map.Entry<Long, ? extends V> e : m.entrySet()) {\n-            // copy only non-null entries\n-            put(e.getKey(), e.getValue());\n-        }\n-    }\n+    WeakReference<V> reference;\n \n     /**\n-     * Loop through segments, trimming the non resident queue.\n+     * The estimated memory used.\n      */\n-    public void trimNonResidentQueue() {\n-        for (Segment<V> s : segments) {\n-            synchronized (s) {\n-                s.trimNonResidentQueue();\n-            }\n-        }\n-    }\n+    final int memory;\n \n     /**\n-     * A cache segment\n-     *\n-     * @param <V> the value type\n+     * When the item was last moved to the top of the stack.\n      */\n-    private static class Segment<V> {\n-\n-        /**\n-         * The number of (hot, cold, and non-resident) entries in the map.\n-         */\n-        int mapSize;\n-\n-        /**\n-         * The size of the LIRS queue for resident cold entries.\n-         */\n-        int queueSize;\n-\n-        /**\n-         * The size of the LIRS queue for non-resident cold entries.\n-         */\n-        int queue2Size;\n-\n-        /**\n-         * The number of cache hits.\n-         */\n-        long hits;\n-\n-        /**\n-         * The number of cache misses.\n-         */\n-        long misses;\n-\n-        /**\n-         * The map array. The size is always a power of 2.\n-         */\n-        final Entry<V>[] entries;\n-\n-        /**\n-         * The currently used memory.\n-         */\n-        long usedMemory;\n-\n-        /**\n-         * How many other item are to be moved to the top of the stack before\n-         * the current item is moved.\n-         */\n-        private final int stackMoveDistance;\n-\n-        /**\n-         * The maximum memory this cache should use in bytes.\n-         */\n-        private long maxMemory;\n-\n-        /**\n-         * The bit mask that is applied to the key hash code to get the index in\n-         * the map array. The mask is the length of the array minus one.\n-         */\n-        private final int mask;\n-\n-        /**\n-         * Low watermark for the number of entries in the non-resident queue,\n-         * as a factor of the number of entries in the map.\n-         */\n-        private final int nonResidentQueueSize;\n-\n-        /**\n-         * High watermark for the number of entries in the non-resident queue,\n-         * as a factor of the number of entries in the map.\n-         */\n-        private final int nonResidentQueueSizeHigh;\n-\n-        /**\n-         * The stack of recently referenced elements. This includes all hot\n-         * entries, and the recently referenced cold entries. Resident cold\n-         * entries that were not recently referenced, as well as non-resident\n-         * cold entries, are not in the stack.\n-         * <p>\n-         * There is always at least one entry: the head entry.\n-         */\n-        private final Entry<V> stack;\n-\n-        /**\n-         * The number of entries in the stack.\n-         */\n-        private int stackSize;\n-\n-        /**\n-         * The queue of resident cold entries.\n-         * <p>\n-         * There is always at least one entry: the head entry.\n-         */\n-        private final Entry<V> queue;\n-\n-        /**\n-         * The queue of non-resident cold entries.\n-         * <p>\n-         * There is always at least one entry: the head entry.\n-         */\n-        private final Entry<V> queue2;\n-\n-        /**\n-         * The number of times any item was moved to the top of the stack.\n-         */\n-        private int stackMoveCounter;\n-\n-        /**\n-         * Create a new cache segment.\n-         *  @param maxMemory the maximum memory to use\n-         * @param stackMoveDistance the number of other entries to be moved to\n-         *        the top of the stack before moving an entry to the top\n-         * @param len the number of hash table buckets (must be a power of 2)\n-         * @param nonResidentQueueSize the non-resident queue size low watermark factor\n-         * @param nonResidentQueueSizeHigh  the non-resident queue size high watermark factor\n-         */\n-        Segment(long maxMemory, int stackMoveDistance, int len,\n-                int nonResidentQueueSize, int nonResidentQueueSizeHigh) {\n-            setMaxMemory(maxMemory);\n-            this.stackMoveDistance = stackMoveDistance;\n-            this.nonResidentQueueSize = nonResidentQueueSize;\n-            this.nonResidentQueueSizeHigh = nonResidentQueueSizeHigh;\n-\n-            // the bit mask has all bits set\n-            mask = len - 1;\n-\n-            // initialize the stack and queue heads\n-            stack = new Entry<>();\n-            stack.stackPrev = stack.stackNext = stack;\n-            queue = new Entry<>();\n-            queue.queuePrev = queue.queueNext = queue;\n-            queue2 = new Entry<>();\n-            queue2.queuePrev = queue2.queueNext = queue2;\n-\n-            @SuppressWarnings(\"unchecked\")\n-            Entry<V>[] e = new Entry[len];\n-            entries = e;\n-        }\n-\n-        /**\n-         * Create a new cache segment from an existing one.\n-         * The caller must synchronize on the old segment, to avoid\n-         * concurrent modifications.\n-         *\n-         * @param old the old segment\n-         * @param len the number of hash table buckets (must be a power of 2)\n-         */\n-        Segment(Segment<V> old, int len) {\n-            this(old.maxMemory, old.stackMoveDistance, len,\n-                    old.nonResidentQueueSize, old.nonResidentQueueSizeHigh);\n-            hits = old.hits;\n-            misses = old.misses;\n-            Entry<V> s = old.stack.stackPrev;\n-            while (s != old.stack) {\n-                Entry<V> e = new Entry<>(s);\n-                addToMap(e);\n-                addToStack(e);\n-                s = s.stackPrev;\n-            }\n-            s = old.queue.queuePrev;\n-            while (s != old.queue) {\n-                Entry<V> e = find(s.key, getHash(s.key));\n-                if (e == null) {\n-                    e = new Entry<>(s);\n-                    addToMap(e);\n-                }\n-                addToQueue(queue, e);\n-                s = s.queuePrev;\n-            }\n-            s = old.queue2.queuePrev;\n-            while (s != old.queue2) {\n-                Entry<V> e = find(s.key, getHash(s.key));\n-                if (e == null) {\n-                    e = new Entry<>(s);\n-                    addToMap(e);\n-                }\n-                addToQueue(queue2, e);\n-                s = s.queuePrev;\n-            }\n-        }\n-\n-        /**\n-         * Calculate the new number of hash table buckets if the internal map\n-         * should be re-sized.\n-         *\n-         * @return 0 if no resizing is needed, or the new length\n-         */\n-        int getNewMapLen() {\n-            int len = mask + 1;\n-            if (len * 3 < mapSize * 4 && len < (1 << 28)) {\n-                // more than 75% usage\n-                return len * 2;\n-            } else if (len > 32 && len / 8 > mapSize) {\n-                // less than 12% usage\n-                return len / 2;\n-            }\n-            return 0;\n-        }\n-\n-        private void addToMap(Entry<V> e) {\n-            int index = getHash(e.key) & mask;\n-            e.mapNext = entries[index];\n-            entries[index] = e;\n-            usedMemory += e.getMemory();\n-            mapSize++;\n-        }\n-\n-        /**\n-         * Get the value from the given entry.\n-         * This method adjusts the internal state of the cache sometimes,\n-         * to ensure commonly used entries stay in the cache.\n-         *\n-         * @param e the entry\n-         * @return the value, or null if there is no resident entry\n-         */\n-        synchronized V get(Entry<V> e) {\n-            V value = e == null ? null : e.getValue();\n-            if (value == null) {\n-                // the entry was not found\n-                // or it was a non-resident entry\n-                misses++;\n-            } else {\n-                access(e);\n-                hits++;\n-            }\n-            return value;\n-        }\n-\n-        /**\n-         * Access an item, moving the entry to the top of the stack or front of\n-         * the queue if found.\n-         *\n-         * @param e entry to record access for\n-         */\n-        private void access(Entry<V> e) {\n-            if (e.isHot()) {\n-                if (e != stack.stackNext && e.stackNext != null) {\n-                    if (stackMoveCounter - e.topMove > stackMoveDistance) {\n-                        // move a hot entry to the top of the stack\n-                        // unless it is already there\n-                        boolean wasEnd = e == stack.stackPrev;\n-                        removeFromStack(e);\n-                        if (wasEnd) {\n-                            // if moving the last entry, the last entry\n-                            // could now be cold, which is not allowed\n-                            pruneStack();\n-                        }\n-                        addToStack(e);\n-                    }\n-                }\n-            } else {\n-                V v = e.getValue();\n-                if (v != null) {\n-                    removeFromQueue(e);\n-                    if (e.reference != null) {\n-                        e.value = v;\n-                        e.reference = null;\n-                        usedMemory += e.memory;\n-                    }\n-                    if (e.stackNext != null) {\n-                        // resident, or even non-resident (weak value reference),\n-                        // cold entries become hot if they are on the stack\n-                        removeFromStack(e);\n-                        // which means a hot entry needs to become cold\n-                        // (this entry is cold, that means there is at least one\n-                        // more entry in the stack, which must be hot)\n-                        convertOldestHotToCold();\n-                    } else {\n-                        // cold entries that are not on the stack\n-                        // move to the front of the queue\n-                        addToQueue(queue, e);\n-                    }\n-                    // in any case, the cold entry is moved to the top of the stack\n-                    addToStack(e);\n-                    // but if newly promoted cold/non-resident is the only entry on a stack now\n-                    // that means last one is cold, need to prune\n-                    pruneStack();\n-                }\n-            }\n-        }\n-\n-        /**\n-         * Add an entry to the cache. The entry may or may not exist in the\n-         * cache yet. This method will usually mark unknown entries as cold and\n-         * known entries as hot.\n-         *\n-         * @param key the key (may not be null)\n-         * @param hash the hash\n-         * @param value the value (may not be null)\n-         * @param memory the memory used for the given entry\n-         * @return the old value, or null if there was no resident entry\n-         */\n-        synchronized V put(long key, int hash, V value, int memory) {\n-            Entry<V> e = find(key, hash);\n-            boolean existed = e != null;\n-            V old = null;\n-            if (existed) {\n-                old = e.getValue();\n-                remove(key, hash);\n-            }\n-            if (memory > maxMemory) {\n-                // the new entry is too big to fit\n-                return old;\n-            }\n-            e = new Entry<>(key, value, memory);\n-            int index = hash & mask;\n-            e.mapNext = entries[index];\n-            entries[index] = e;\n-            usedMemory += memory;\n-            if (usedMemory > maxMemory) {\n-                // old entries needs to be removed\n-                evict();\n-                // if the cache is full, the new entry is\n-                // cold if possible\n-                if (stackSize > 0) {\n-                    // the new cold entry is at the top of the queue\n-                    addToQueue(queue, e);\n-                }\n-            }\n-            mapSize++;\n-            // added entries are always added to the stack\n-            addToStack(e);\n-            if (existed) {\n-                // if it was there before (even non-resident), it becomes hot\n-                access(e);\n-            }\n-            return old;\n-        }\n-\n-        /**\n-         * Remove an entry. Both resident and non-resident entries can be\n-         * removed.\n-         *\n-         * @param key the key (may not be null)\n-         * @param hash the hash\n-         * @return the old value, or null if there was no resident entry\n-         */\n-        synchronized V remove(long key, int hash) {\n-            int index = hash & mask;\n-            Entry<V> e = entries[index];\n-            if (e == null) {\n-                return null;\n-            }\n-            if (e.key == key) {\n-                entries[index] = e.mapNext;\n-            } else {\n-                Entry<V> last;\n-                do {\n-                    last = e;\n-                    e = e.mapNext;\n-                    if (e == null) {\n-                        return null;\n-                    }\n-                } while (e.key != key);\n-                last.mapNext = e.mapNext;\n-            }\n-            V old = e.getValue();\n-            mapSize--;\n-            usedMemory -= e.getMemory();\n-            if (e.stackNext != null) {\n-                removeFromStack(e);\n-            }\n-            if (e.isHot()) {\n-                // when removing a hot entry, the newest cold entry gets hot,\n-                // so the number of hot entries does not change\n-                e = queue.queueNext;\n-                if (e != queue) {\n-                    removeFromQueue(e);\n-                    if (e.stackNext == null) {\n-                        addToStackBottom(e);\n-                    }\n-                }\n-                pruneStack();\n-            } else {\n-                removeFromQueue(e);\n-            }\n-            return old;\n-        }\n-\n-        /**\n-         * Evict cold entries (resident and non-resident) until the memory limit\n-         * is reached. The new entry is added as a cold entry, except if it is\n-         * the only entry.\n-         */\n-        private void evict() {\n-            do {\n-                evictBlock();\n-            } while (usedMemory > maxMemory);\n-        }\n+    int topMove;\n \n-        private void evictBlock() {\n-            // ensure there are not too many hot entries: right shift of 5 is\n-            // division by 32, that means if there are only 1/32 (3.125%) or\n-            // less cold entries, a hot entry needs to become cold\n-            while (queueSize <= ((mapSize - queue2Size) >>> 5) && stackSize > 0) {\n-                convertOldestHotToCold();\n-            }\n-            // the oldest resident cold entries become non-resident\n-            while (usedMemory > maxMemory && queueSize > 0) {\n-                Entry<V> e = queue.queuePrev;\n-                usedMemory -= e.memory;\n-                removeFromQueue(e);\n-                e.reference = new WeakReference<>(e.value);\n-                e.value = null;\n-                addToQueue(queue2, e);\n-                // the size of the non-resident-cold entries needs to be limited\n-                trimNonResidentQueue();\n-            }\n-        }\n-\n-        void trimNonResidentQueue() {\n-            int residentCount = mapSize - queue2Size;\n-            int maxQueue2SizeHigh = nonResidentQueueSizeHigh * residentCount;\n-            int maxQueue2Size = nonResidentQueueSize * residentCount;\n-            while (queue2Size > maxQueue2Size) {\n-                Entry<V> e = queue2.queuePrev;\n-                if (queue2Size <= maxQueue2SizeHigh) {\n-                    WeakReference<V> reference = e.reference;\n-                    if (reference != null && reference.get() != null) {\n-                        break;  // stop trimming if entry holds a value\n-                    }\n-                }\n-                int hash = getHash(e.key);\n-                remove(e.key, hash);\n-            }\n-        }\n-\n-        private void convertOldestHotToCold() {\n-            // the last entry of the stack is known to be hot\n-            Entry<V> last = stack.stackPrev;\n-            if (last == stack) {\n-                // never remove the stack head itself (this would mean the\n-                // internal structure of the cache is corrupt)\n-                throw new IllegalStateException();\n-            }\n-            // remove from stack - which is done anyway in the stack pruning,\n-            // but we can do it here as well\n-            removeFromStack(last);\n-            // adding an entry to the queue will make it cold\n-            addToQueue(queue, last);\n-            pruneStack();\n-        }\n-\n-        /**\n-         * Ensure the last entry of the stack is cold.\n-         */\n-        private void pruneStack() {\n-            while (true) {\n-                Entry<V> last = stack.stackPrev;\n-                // must stop at a hot entry or the stack head,\n-                // but the stack head itself is also hot, so we\n-                // don't have to test it\n-                if (last.isHot()) {\n-                    break;\n-                }\n-                // the cold entry is still in the queue\n-                removeFromStack(last);\n-            }\n-        }\n-\n-        /**\n-         * Try to find an entry in the map.\n-         *\n-         * @param key the key\n-         * @param hash the hash\n-         * @return the entry (might be a non-resident)\n-         */\n-        Entry<V> find(long key, int hash) {\n-            int index = hash & mask;\n-            Entry<V> e = entries[index];\n-            while (e != null && e.key != key) {\n-                e = e.mapNext;\n-            }\n-            return e;\n-        }\n-\n-        private void addToStack(Entry<V> e) {\n-            e.stackPrev = stack;\n-            e.stackNext = stack.stackNext;\n-            e.stackNext.stackPrev = e;\n-            stack.stackNext = e;\n-            stackSize++;\n-            e.topMove = stackMoveCounter++;\n-        }\n+    /**\n+     * The next entry in the stack.\n+     */\n+    Entry<V> stackNext;\n \n-        private void addToStackBottom(Entry<V> e) {\n-            e.stackNext = stack;\n-            e.stackPrev = stack.stackPrev;\n-            e.stackPrev.stackNext = e;\n-            stack.stackPrev = e;\n-            stackSize++;\n-        }\n+    /**\n+     * The previous entry in the stack.\n+     */\n+    Entry<V> stackPrev;\n \n-        /**\n-         * Remove the entry from the stack. The head itself must not be removed.\n-         *\n-         * @param e the entry\n-         */\n-        private void removeFromStack(Entry<V> e) {\n-            e.stackPrev.stackNext = e.stackNext;\n-            e.stackNext.stackPrev = e.stackPrev;\n-            e.stackPrev = e.stackNext = null;\n-            stackSize--;\n-        }\n+    /**\n+     * The next entry in the queue (either the resident queue or the\n+     * non-resident queue).\n+     */\n+    Entry<V> queueNext;\n \n-        private void addToQueue(Entry<V> q, Entry<V> e) {\n-            e.queuePrev = q;\n-            e.queueNext = q.queueNext;\n-            e.queueNext.queuePrev = e;\n-            q.queueNext = e;\n-            if (e.value != null) {\n-                queueSize++;\n-            } else {\n-                queue2Size++;\n-            }\n-        }\n+    /**\n+     * The previous entry in the queue.\n+     */\n+    Entry<V> queuePrev;\n \n-        private void removeFromQueue(Entry<V> e) {\n-            e.queuePrev.queueNext = e.queueNext;\n-            e.queueNext.queuePrev = e.queuePrev;\n-            e.queuePrev = e.queueNext = null;\n-            if (e.value != null) {\n-                queueSize--;\n-            } else {\n-                queue2Size--;\n-            }\n-        }\n+    /**\n+     * The next entry in the map (the chained entry).\n+     */\n+    Entry<V> mapNext;\n \n-        /**\n-         * Get the list of keys. This method allows to read the internal state\n-         * of the cache.\n-         *\n-         * @param cold if true, only keys for the cold entries are returned\n-         * @param nonResident true for non-resident entries\n-         * @return the key list\n-         */\n-        synchronized List<Long> keys(boolean cold, boolean nonResident) {\n-            ArrayList<Long> keys = new ArrayList<>();\n-            if (cold) {\n-                Entry<V> start = nonResident ? queue2 : queue;\n-                for (Entry<V> e = start.queueNext; e != start;\n-                        e = e.queueNext) {\n-                    keys.add(e.key);\n-                }\n-            } else {\n-                for (Entry<V> e = stack.stackNext; e != stack;\n-                        e = e.stackNext) {\n-                    keys.add(e.key);\n-                }\n-            }\n-            return keys;\n-        }\n \n-        /**\n-         * Get the set of keys for resident entries.\n-         *\n-         * @return the set of keys\n-         */\n-        synchronized Set<Long> keySet() {\n-            HashSet<Long> set = new HashSet<>();\n-            for (Entry<V> e = stack.stackNext; e != stack; e = e.stackNext) {\n-                set.add(e.key);\n-            }\n-            for (Entry<V> e = queue.queueNext; e != queue; e = e.queueNext) {\n-                set.add(e.key);\n-            }\n-            return set;\n-        }\n+    Entry() {\n+      this(0L, null, 0);\n+    }\n \n-        /**\n-         * Set the maximum memory this cache should use. This will not\n-         * immediately cause entries to get removed however; it will only change\n-         * the limit. To resize the internal array, call the clear method.\n-         *\n-         * @param maxMemory the maximum size (1 or larger) in bytes\n-         */\n-        void setMaxMemory(long maxMemory) {\n-            this.maxMemory = maxMemory;\n-        }\n+    Entry(long key, V value, int memory) {\n+      this.key = key;\n+      this.memory = memory;\n+      this.value = value;\n+    }\n \n+    Entry(Entry<V> old) {\n+      this(old.key, old.value, old.memory);\n+      this.reference = old.reference;\n+      this.topMove = old.topMove;\n     }\n \n     /**\n-     * A cache entry. Each entry is either hot (low inter-reference recency;\n-     * LIR), cold (high inter-reference recency; HIR), or non-resident-cold. Hot\n-     * entries are in the stack only. Cold entries are in the queue, and may be\n-     * in the stack. Non-resident-cold entries have their value set to null and\n-     * are in the stack and in the non-resident queue.\n+     * Whether this entry is hot. Cold entries are in one of the two queues.\n      *\n-     * @param <V> the value type\n+     * @return whether the entry is hot\n      */\n-    static class Entry<V> {\n-\n-        /**\n-         * The key.\n-         */\n-        final long key;\n-\n-        /**\n-         * The value. Set to null for non-resident-cold entries.\n-         */\n-        V value;\n-\n-        /**\n-         * Weak reference to the value. Set to null for resident entries.\n-         */\n-        WeakReference<V> reference;\n-\n-        /**\n-         * The estimated memory used.\n-         */\n-        final int memory;\n-\n-        /**\n-         * When the item was last moved to the top of the stack.\n-         */\n-        int topMove;\n-\n-        /**\n-         * The next entry in the stack.\n-         */\n-        Entry<V> stackNext;\n-\n-        /**\n-         * The previous entry in the stack.\n-         */\n-        Entry<V> stackPrev;\n-\n-        /**\n-         * The next entry in the queue (either the resident queue or the\n-         * non-resident queue).\n-         */\n-        Entry<V> queueNext;\n-\n-        /**\n-         * The previous entry in the queue.\n-         */\n-        Entry<V> queuePrev;\n-\n-        /**\n-         * The next entry in the map (the chained entry).\n-         */\n-        Entry<V> mapNext;\n-\n-\n-        Entry() {\n-            this(0L, null, 0);\n-        }\n+    boolean isHot() {\n+      return queueNext == null;\n+    }\n \n-        Entry(long key, V value, int memory) {\n-            this.key = key;\n-            this.memory = memory;\n-            this.value = value;\n-        }\n+    V getValue() {\n+      return value == null ? reference.get() : value;\n+    }\n \n-        Entry(Entry<V> old) {\n-            this(old.key, old.value, old.memory);\n-            this.reference = old.reference;\n-            this.topMove = old.topMove;\n-        }\n+    int getMemory() {\n+      return value == null ? 0 : memory;\n+    }\n+  }\n \n-        /**\n-         * Whether this entry is hot. Cold entries are in one of the two queues.\n-         *\n-         * @return whether the entry is hot\n-         */\n-        boolean isHot() {\n-            return queueNext == null;\n-        }\n+  /**\n+   * The cache configuration.\n+   */\n+  public static class Config {\n \n-        V getValue() {\n-            return value == null ? reference.get() : value;\n-        }\n+    /**\n+     * The maximum memory to use (1 or larger).\n+     */\n+    public long maxMemory = 1;\n \n-        int getMemory() {\n-            return value == null ? 0 : memory;\n-        }\n-    }\n+    /**\n+     * The number of cache segments (must be a power of 2).\n+     */\n+    public int segmentCount = 16;\n \n     /**\n-     * The cache configuration.\n+     * How many other item are to be moved to the top of the stack before\n+     * the current item is moved.\n      */\n-    public static class Config {\n-\n-        /**\n-         *  The maximum memory to use (1 or larger).\n-         */\n-        public long maxMemory = 1;\n-\n-        /**\n-         * The number of cache segments (must be a power of 2).\n-         */\n-        public int segmentCount = 16;\n-\n-        /**\n-         * How many other item are to be moved to the top of the stack before\n-         * the current item is moved.\n-         */\n-        public int stackMoveDistance = 32;\n-\n-        /**\n-         * Low water mark for the number of entries in the non-resident queue,\n-         * as a factor of the number of all other entries in the map.\n-         */\n-        public final int nonResidentQueueSize = 3;\n-\n-        /**\n-         * High watermark for the number of entries in the non-resident queue,\n-         * as a factor of the number of all other entries in the map\n-         */\n-        public final int nonResidentQueueSizeHigh = 12;\n-    }\n+    public int stackMoveDistance = 32;\n+\n+    /**\n+     * Low water mark for the number of entries in the non-resident queue,\n+     * as a factor of the number of all other entries in the map.\n+     */\n+    public final int nonResidentQueueSize = 3;\n+\n+    /**\n+     * High watermark for the number of entries in the non-resident queue,\n+     * as a factor of the number of all other entries in the map\n+     */\n+    public final int nonResidentQueueSizeHigh = 12;\n+  }\n }\n",
            "diff_size": 1778
        },
        {
            "tool": "naturalize",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/457/CacheLongKeyLIRS.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/naturalize/457/CacheLongKeyLIRS.java\nindex 38c405ce2f4..fb7d7b02e1a 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/457/CacheLongKeyLIRS.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/naturalize/457/CacheLongKeyLIRS.java\n@@ -87,9 +87,8 @@ public class CacheLongKeyLIRS<V> {\n     public void clear() {\n         long max = getMaxItemSize();\n         for (int i = 0; i < segmentCount; i++) {\n-            segments[i] = new Segment<>(max, stackMoveDistance, 8, nonResidentQueueSize,\n-                                        nonResidentQueueSizeHigh);\n-        }\n+            segments[i] = new Segment<>(max, stackMoveDistance, 8, nonResidentQueueSize, nonResidentQueueSizeHigh);\n+    }\n     }\n \n     /**\n@@ -920,7 +919,8 @@ public class CacheLongKeyLIRS<V> {\n                 if (queue2Size <= maxQueue2SizeHigh) {\n                     WeakReference<V> reference = e.reference;\n                     if (reference != null && reference.get() != null) {\n-                        break;  // stop trimming if entry holds a value\n+                        break;\n+// stop trimming if entry holds a value\n                     }\n                 }\n                 int hash = getHash(e.key);\n@@ -1144,9 +1144,7 @@ public class CacheLongKeyLIRS<V> {\n          * The next entry in the map (the chained entry).\n          */\n         Entry<V> mapNext;\n-\n-\n-        Entry() {\n+Entry() {\n             this(0L, null, 0);\n         }\n \n@@ -1213,4 +1211,4 @@ public class CacheLongKeyLIRS<V> {\n          */\n         public final int nonResidentQueueSizeHigh = 12;\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 9
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "1003",
                    "column": "33",
                    "severity": "warning",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/457/CacheLongKeyLIRS.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/codebuff/457/CacheLongKeyLIRS.java\nindex 38c405ce2f4..e3a08d4dae0 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/457/CacheLongKeyLIRS.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/codebuff/457/CacheLongKeyLIRS.java\n@@ -43,15 +43,16 @@ import org.h2.mvstore.DataUtils;\n  * @author Thomas Mueller\n  * @param <V> the value type\n  */\n+\n+\n public class CacheLongKeyLIRS<V> {\n \n     /**\n      * The maximum memory this cache should use.\n      */\n-    private long maxMemory;\n \n+    private long maxMemory;\n     private final Segment<V>[] segments;\n-\n     private final int segmentCount;\n     private final int segmentShift;\n     private final int segmentMask;\n@@ -64,14 +65,13 @@ public class CacheLongKeyLIRS<V> {\n      *\n      * @param config the configuration\n      */\n+\n     @SuppressWarnings(\"unchecked\")\n     public CacheLongKeyLIRS(Config config) {\n         setMaxMemory(config.maxMemory);\n         this.nonResidentQueueSize = config.nonResidentQueueSize;\n         this.nonResidentQueueSizeHigh = config.nonResidentQueueSizeHigh;\n-        DataUtils.checkArgument(\n-                Integer.bitCount(config.segmentCount) == 1,\n-                \"The segment count must be a power of 2, is {0}\", config.segmentCount);\n+        DataUtils.checkArgument(Integer.bitCount(config.segmentCount) == 1, \"The segment count must be a power of 2, is {0}\", config.segmentCount);\n         this.segmentCount = config.segmentCount;\n         this.segmentMask = segmentCount - 1;\n         this.stackMoveDistance = config.stackMoveDistance;\n@@ -84,11 +84,12 @@ public class CacheLongKeyLIRS<V> {\n     /**\n      * Remove all entries.\n      */\n+\n+\n     public void clear() {\n         long max = getMaxItemSize();\n         for (int i = 0; i < segmentCount; i++) {\n-            segments[i] = new Segment<>(max, stackMoveDistance, 8, nonResidentQueueSize,\n-                                        nonResidentQueueSizeHigh);\n+            segments[i] = new Segment< >(max, stackMoveDistance, 8, nonResidentQueueSize, nonResidentQueueSizeHigh);\n         }\n     }\n \n@@ -96,6 +97,8 @@ public class CacheLongKeyLIRS<V> {\n      * Determines max size of the data item size to fit into cache\n      * @return data items size limit\n      */\n+\n+\n     public long getMaxItemSize() {\n         return Math.max(1, maxMemory / segmentCount);\n     }\n@@ -112,6 +115,8 @@ public class CacheLongKeyLIRS<V> {\n      * @param key the key (may not be null)\n      * @return true if there is a resident entry\n      */\n+\n+\n     public boolean containsKey(long key) {\n         Entry<V> e = find(key);\n         return e != null && e.value != null;\n@@ -124,6 +129,8 @@ public class CacheLongKeyLIRS<V> {\n      * @param key the key (may not be null)\n      * @return the value, or null if there is no resident entry\n      */\n+\n+\n     public V peek(long key) {\n         Entry<V> e = find(key);\n         return e == null ? null : e.getValue();\n@@ -136,6 +143,8 @@ public class CacheLongKeyLIRS<V> {\n      * @param value the value (may not be null)\n      * @return the old value, or null if there was no resident entry\n      */\n+\n+\n     public V put(long key, V value) {\n         return put(key, value, sizeOf(value));\n     }\n@@ -150,10 +159,11 @@ public class CacheLongKeyLIRS<V> {\n      * @param memory the memory used for the given entry\n      * @return the old value, or null if there was no resident entry\n      */\n+\n+\n     public V put(long key, V value, int memory) {\n         if (value == null) {\n-            throw DataUtils.newIllegalArgumentException(\n-                    \"The value may not be null\");\n+            throw DataUtils.newIllegalArgumentException(\"The value may not be null\");\n         }\n         int hash = getHash(key);\n         int segmentIndex = getSegmentIndex(hash);\n@@ -177,7 +187,7 @@ public class CacheLongKeyLIRS<V> {\n         Segment<V> s2 = segments[segmentIndex];\n         if (s == s2) {\n             // no other thread resized, so we do\n-            s = new Segment<>(s, newLen);\n+            s = new Segment< >(s, newLen);\n             segments[segmentIndex] = s;\n         }\n         return s;\n@@ -189,6 +199,8 @@ public class CacheLongKeyLIRS<V> {\n      * @param value the value\n      * @return the size\n      */\n+\n+\n     protected int sizeOf(V value) {\n         return 1;\n     }\n@@ -200,6 +212,8 @@ public class CacheLongKeyLIRS<V> {\n      * @param key the key (may not be null)\n      * @return the old value, or null if there was no resident entry\n      */\n+\n+\n     public V remove(long key) {\n         int hash = getHash(key);\n         int segmentIndex = getSegmentIndex(hash);\n@@ -219,6 +233,8 @@ public class CacheLongKeyLIRS<V> {\n      * @param key the key (may not be null)\n      * @return the memory, or 0 if there is no resident entry\n      */\n+\n+\n     public int getMemory(long key) {\n         Entry<V> e = find(key);\n         return e == null ? 0 : e.getMemory();\n@@ -232,6 +248,8 @@ public class CacheLongKeyLIRS<V> {\n      * @param key the key (may not be null)\n      * @return the value, or null if there is no resident entry\n      */\n+\n+\n     public V get(long key) {\n         int hash = getHash(key);\n         Segment<V> s = getSegment(hash);\n@@ -254,6 +272,8 @@ public class CacheLongKeyLIRS<V> {\n      * @param key the key\n      * @return the hash code\n      */\n+\n+\n     static int getHash(long key) {\n         int hash = (int) ((key >>> 32) ^ key);\n         // a supplemental secondary hash function\n@@ -269,6 +289,8 @@ public class CacheLongKeyLIRS<V> {\n      *\n      * @return the used memory\n      */\n+\n+\n     public long getUsedMemory() {\n         long x = 0;\n         for (Segment<V> s : segments) {\n@@ -284,10 +306,11 @@ public class CacheLongKeyLIRS<V> {\n      *\n      * @param maxMemory the maximum size (1 or larger) in bytes\n      */\n+\n+\n     public void setMaxMemory(long maxMemory) {\n-        DataUtils.checkArgument(\n-                maxMemory > 0,\n-                \"Max memory must be larger than 0, is {0}\", maxMemory);\n+        DataUtils.checkArgument(maxMemory > 0,\n+                                \"Max memory must be larger than 0, is {0}\", maxMemory);\n         this.maxMemory = maxMemory;\n         if (segments != null) {\n             long max = 1 + maxMemory / segments.length;\n@@ -302,6 +325,8 @@ public class CacheLongKeyLIRS<V> {\n      *\n      * @return the maximum memory\n      */\n+\n+\n     public long getMaxMemory() {\n         return maxMemory;\n     }\n@@ -311,8 +336,10 @@ public class CacheLongKeyLIRS<V> {\n      *\n      * @return the entry set\n      */\n+\n+\n     public synchronized Set<Map.Entry<Long, V>> entrySet() {\n-        HashMap<Long, V> map = new HashMap<>();\n+        HashMap<Long, V> map = new HashMap< >();\n         for (long k : keySet()) {\n             V value = peek(k);\n             if (value != null) {\n@@ -327,8 +354,10 @@ public class CacheLongKeyLIRS<V> {\n      *\n      * @return the set of keys\n      */\n+\n+\n     public Set<Long> keySet() {\n-        HashSet<Long> set = new HashSet<>();\n+        HashSet<Long> set = new HashSet< >();\n         for (Segment<V> s : segments) {\n             set.addAll(s.keySet());\n         }\n@@ -340,6 +369,8 @@ public class CacheLongKeyLIRS<V> {\n      *\n      * @return the number of non-resident entries\n      */\n+\n+\n     public int sizeNonResident() {\n         int x = 0;\n         for (Segment<V> s : segments) {\n@@ -353,6 +384,8 @@ public class CacheLongKeyLIRS<V> {\n      *\n      * @return the size of the array\n      */\n+\n+\n     public int sizeMapArray() {\n         int x = 0;\n         for (Segment<V> s : segments) {\n@@ -366,6 +399,8 @@ public class CacheLongKeyLIRS<V> {\n      *\n      * @return the number of hot entries\n      */\n+\n+\n     public int sizeHot() {\n         int x = 0;\n         for (Segment<V> s : segments) {\n@@ -379,6 +414,8 @@ public class CacheLongKeyLIRS<V> {\n      *\n      * @return the cache hits\n      */\n+\n+\n     public long getHits() {\n         long x = 0;\n         for (Segment<V> s : segments) {\n@@ -392,6 +429,8 @@ public class CacheLongKeyLIRS<V> {\n      *\n      * @return the cache misses\n      */\n+\n+\n     public long getMisses() {\n         int x = 0;\n         for (Segment<V> s : segments) {\n@@ -405,6 +444,8 @@ public class CacheLongKeyLIRS<V> {\n      *\n      * @return the number of entries\n      */\n+\n+\n     public int size() {\n         int x = 0;\n         for (Segment<V> s : segments) {\n@@ -421,8 +462,10 @@ public class CacheLongKeyLIRS<V> {\n      * @param nonResident true for non-resident entries\n      * @return the key list\n      */\n+\n+\n     public List<Long> keys(boolean cold, boolean nonResident) {\n-        ArrayList<Long> keys = new ArrayList<>();\n+        ArrayList<Long> keys = new ArrayList< >();\n         for (Segment<V> s : segments) {\n             keys.addAll(s.keys(cold, nonResident));\n         }\n@@ -434,8 +477,10 @@ public class CacheLongKeyLIRS<V> {\n      *\n      * @return the entry set\n      */\n+\n+\n     public List<V> values() {\n-        ArrayList<V> list = new ArrayList<>();\n+        ArrayList<V> list = new ArrayList< >();\n         for (long k : keySet()) {\n             V value = peek(k);\n             if (value != null) {\n@@ -450,6 +495,8 @@ public class CacheLongKeyLIRS<V> {\n      *\n      * @return true if it is empty\n      */\n+\n+\n     public boolean isEmpty() {\n         return size() == 0;\n     }\n@@ -460,6 +507,8 @@ public class CacheLongKeyLIRS<V> {\n      * @param value the value\n      * @return true if it is stored\n      */\n+\n+\n     public boolean containsValue(V value) {\n         return getMap().containsValue(value);\n     }\n@@ -469,8 +518,10 @@ public class CacheLongKeyLIRS<V> {\n      *\n      * @return the map\n      */\n+\n+\n     public Map<Long, V> getMap() {\n-        HashMap<Long, V> map = new HashMap<>();\n+        HashMap<Long, V> map = new HashMap< >();\n         for (long k : keySet()) {\n             V x = peek(k);\n             if (x != null) {\n@@ -485,6 +536,8 @@ public class CacheLongKeyLIRS<V> {\n      *\n      * @param m the map\n      */\n+\n+\n     public void putAll(Map<Long, ? extends V> m) {\n         for (Map.Entry<Long, ? extends V> e : m.entrySet()) {\n             // copy only non-null entries\n@@ -495,6 +548,8 @@ public class CacheLongKeyLIRS<V> {\n     /**\n      * Loop through segments, trimming the non resident queue.\n      */\n+\n+\n     public void trimNonResidentQueue() {\n         for (Segment<V> s : segments) {\n             synchronized (s) {\n@@ -508,41 +563,56 @@ public class CacheLongKeyLIRS<V> {\n      *\n      * @param <V> the value type\n      */\n+\n     private static class Segment<V> {\n \n         /**\n          * The number of (hot, cold, and non-resident) entries in the map.\n          */\n+\n+\n         int mapSize;\n \n         /**\n          * The size of the LIRS queue for resident cold entries.\n          */\n+\n+\n         int queueSize;\n \n         /**\n          * The size of the LIRS queue for non-resident cold entries.\n          */\n+\n+\n         int queue2Size;\n \n         /**\n          * The number of cache hits.\n          */\n+\n+\n         long hits;\n \n         /**\n          * The number of cache misses.\n          */\n+\n+\n         long misses;\n \n         /**\n          * The map array. The size is always a power of 2.\n          */\n+\n+\n         final Entry<V>[] entries;\n \n         /**\n          * The currently used memory.\n          */\n+\n+\n         long usedMemory;\n \n         /**\n@@ -617,8 +687,8 @@ public class CacheLongKeyLIRS<V> {\n          * @param nonResidentQueueSize the non-resident queue size low watermark factor\n          * @param nonResidentQueueSizeHigh  the non-resident queue size high watermark factor\n          */\n-        Segment(long maxMemory, int stackMoveDistance, int len,\n-                int nonResidentQueueSize, int nonResidentQueueSizeHigh) {\n+\n+        Segment(long maxMemory, int stackMoveDistance, int len, int nonResidentQueueSize, int nonResidentQueueSizeHigh) {\n             setMaxMemory(maxMemory);\n             this.stackMoveDistance = stackMoveDistance;\n             this.nonResidentQueueSize = nonResidentQueueSize;\n@@ -628,13 +698,12 @@ public class CacheLongKeyLIRS<V> {\n             mask = len - 1;\n \n             // initialize the stack and queue heads\n-            stack = new Entry<>();\n+            stack = new Entry< >();\n             stack.stackPrev = stack.stackNext = stack;\n-            queue = new Entry<>();\n+            queue = new Entry< >();\n             queue.queuePrev = queue.queueNext = queue;\n-            queue2 = new Entry<>();\n+            queue2 = new Entry< >();\n             queue2.queuePrev = queue2.queueNext = queue2;\n-\n             @SuppressWarnings(\"unchecked\")\n             Entry<V>[] e = new Entry[len];\n             entries = e;\n@@ -648,14 +717,14 @@ public class CacheLongKeyLIRS<V> {\n          * @param old the old segment\n          * @param len the number of hash table buckets (must be a power of 2)\n          */\n+\n         Segment(Segment<V> old, int len) {\n-            this(old.maxMemory, old.stackMoveDistance, len,\n-                    old.nonResidentQueueSize, old.nonResidentQueueSizeHigh);\n+            this(old.maxMemory, old.stackMoveDistance, len, old.nonResidentQueueSize, old.nonResidentQueueSizeHigh);\n             hits = old.hits;\n             misses = old.misses;\n             Entry<V> s = old.stack.stackPrev;\n             while (s != old.stack) {\n-                Entry<V> e = new Entry<>(s);\n+                Entry<V> e = new Entry< >(s);\n                 addToMap(e);\n                 addToStack(e);\n                 s = s.stackPrev;\n@@ -664,7 +733,7 @@ public class CacheLongKeyLIRS<V> {\n             while (s != old.queue) {\n                 Entry<V> e = find(s.key, getHash(s.key));\n                 if (e == null) {\n-                    e = new Entry<>(s);\n+                    e = new Entry< >(s);\n                     addToMap(e);\n                 }\n                 addToQueue(queue, e);\n@@ -674,7 +743,7 @@ public class CacheLongKeyLIRS<V> {\n             while (s != old.queue2) {\n                 Entry<V> e = find(s.key, getHash(s.key));\n                 if (e == null) {\n-                    e = new Entry<>(s);\n+                    e = new Entry< >(s);\n                     addToMap(e);\n                 }\n                 addToQueue(queue2, e);\n@@ -688,6 +757,8 @@ public class CacheLongKeyLIRS<V> {\n          *\n          * @return 0 if no resizing is needed, or the new length\n          */\n+\n+\n         int getNewMapLen() {\n             int len = mask + 1;\n             if (len * 3 < mapSize * 4 && len < (1 << 28)) {\n@@ -716,6 +787,8 @@ public class CacheLongKeyLIRS<V> {\n          * @param e the entry\n          * @return the value, or null if there is no resident entry\n          */\n+\n+\n         synchronized V get(Entry<V> e) {\n             V value = e == null ? null : e.getValue();\n             if (value == null) {\n@@ -735,6 +808,7 @@ public class CacheLongKeyLIRS<V> {\n          *\n          * @param e entry to record access for\n          */\n+\n         private void access(Entry<V> e) {\n             if (e.isHot()) {\n                 if (e != stack.stackNext && e.stackNext != null) {\n@@ -793,6 +867,8 @@ public class CacheLongKeyLIRS<V> {\n          * @param memory the memory used for the given entry\n          * @return the old value, or null if there was no resident entry\n          */\n+\n+\n         synchronized V put(long key, int hash, V value, int memory) {\n             Entry<V> e = find(key, hash);\n             boolean existed = e != null;\n@@ -805,7 +881,7 @@ public class CacheLongKeyLIRS<V> {\n                 // the new entry is too big to fit\n                 return old;\n             }\n-            e = new Entry<>(key, value, memory);\n+            e = new Entry< >(key, value, memory);\n             int index = hash & mask;\n             e.mapNext = entries[index];\n             entries[index] = e;\n@@ -838,6 +914,8 @@ public class CacheLongKeyLIRS<V> {\n          * @param hash the hash\n          * @return the old value, or null if there was no resident entry\n          */\n+\n+\n         synchronized V remove(long key, int hash) {\n             int index = hash & mask;\n             Entry<V> e = entries[index];\n@@ -885,6 +963,7 @@ public class CacheLongKeyLIRS<V> {\n          * is reached. The new entry is added as a cold entry, except if it is\n          * the only entry.\n          */\n+\n         private void evict() {\n             do {\n                 evictBlock();\n@@ -903,7 +982,7 @@ public class CacheLongKeyLIRS<V> {\n                 Entry<V> e = queue.queuePrev;\n                 usedMemory -= e.memory;\n                 removeFromQueue(e);\n-                e.reference = new WeakReference<>(e.value);\n+                e.reference = new WeakReference< >(e.value);\n                 e.value = null;\n                 addToQueue(queue2, e);\n                 // the size of the non-resident-cold entries needs to be limited\n@@ -911,6 +990,7 @@ public class CacheLongKeyLIRS<V> {\n             }\n         }\n \n+\n         void trimNonResidentQueue() {\n             int residentCount = mapSize - queue2Size;\n             int maxQueue2SizeHigh = nonResidentQueueSizeHigh * residentCount;\n@@ -947,6 +1027,7 @@ public class CacheLongKeyLIRS<V> {\n         /**\n          * Ensure the last entry of the stack is cold.\n          */\n+\n         private void pruneStack() {\n             while (true) {\n                 Entry<V> last = stack.stackPrev;\n@@ -968,6 +1049,8 @@ public class CacheLongKeyLIRS<V> {\n          * @param hash the hash\n          * @return the entry (might be a non-resident)\n          */\n+\n+\n         Entry<V> find(long key, int hash) {\n             int index = hash & mask;\n             Entry<V> e = entries[index];\n@@ -999,6 +1082,7 @@ public class CacheLongKeyLIRS<V> {\n          *\n          * @param e the entry\n          */\n+\n         private void removeFromStack(Entry<V> e) {\n             e.stackPrev.stackNext = e.stackNext;\n             e.stackNext.stackPrev = e.stackPrev;\n@@ -1037,17 +1121,17 @@ public class CacheLongKeyLIRS<V> {\n          * @param nonResident true for non-resident entries\n          * @return the key list\n          */\n+\n+\n         synchronized List<Long> keys(boolean cold, boolean nonResident) {\n-            ArrayList<Long> keys = new ArrayList<>();\n+            ArrayList<Long> keys = new ArrayList< >();\n             if (cold) {\n                 Entry<V> start = nonResident ? queue2 : queue;\n-                for (Entry<V> e = start.queueNext; e != start;\n-                        e = e.queueNext) {\n+                for (Entry<V> e = start.queueNext; e != start; e = e.queueNext) {\n                     keys.add(e.key);\n                 }\n             } else {\n-                for (Entry<V> e = stack.stackNext; e != stack;\n-                        e = e.stackNext) {\n+                for (Entry<V> e = stack.stackNext; e != stack; e = e.stackNext) {\n                     keys.add(e.key);\n                 }\n             }\n@@ -1059,8 +1143,10 @@ public class CacheLongKeyLIRS<V> {\n          *\n          * @return the set of keys\n          */\n+\n+\n         synchronized Set<Long> keySet() {\n-            HashSet<Long> set = new HashSet<>();\n+            HashSet<Long> set = new HashSet< >();\n             for (Entry<V> e = stack.stackNext; e != stack; e = e.stackNext) {\n                 set.add(e.key);\n             }\n@@ -1077,6 +1163,8 @@ public class CacheLongKeyLIRS<V> {\n          *\n          * @param maxMemory the maximum size (1 or larger) in bytes\n          */\n+\n+\n         void setMaxMemory(long maxMemory) {\n             this.maxMemory = maxMemory;\n         }\n@@ -1092,60 +1180,81 @@ public class CacheLongKeyLIRS<V> {\n      *\n      * @param <V> the value type\n      */\n+\n+\n     static class Entry<V> {\n \n         /**\n          * The key.\n          */\n+\n+\n         final long key;\n \n         /**\n          * The value. Set to null for non-resident-cold entries.\n          */\n+\n+\n         V value;\n \n         /**\n          * Weak reference to the value. Set to null for resident entries.\n          */\n+\n+\n         WeakReference<V> reference;\n \n         /**\n          * The estimated memory used.\n          */\n+\n+\n         final int memory;\n \n         /**\n          * When the item was last moved to the top of the stack.\n          */\n+\n+\n         int topMove;\n \n         /**\n          * The next entry in the stack.\n          */\n+\n+\n         Entry<V> stackNext;\n \n         /**\n          * The previous entry in the stack.\n          */\n+\n+\n         Entry<V> stackPrev;\n \n         /**\n          * The next entry in the queue (either the resident queue or the\n          * non-resident queue).\n          */\n+\n+\n         Entry<V> queueNext;\n \n         /**\n          * The previous entry in the queue.\n          */\n+\n+\n         Entry<V> queuePrev;\n \n         /**\n          * The next entry in the map (the chained entry).\n          */\n-        Entry<V> mapNext;\n \n \n+        Entry<V> mapNext;\n+\n         Entry() {\n             this(0L, null, 0);\n         }\n@@ -1167,50 +1276,68 @@ public class CacheLongKeyLIRS<V> {\n          *\n          * @return whether the entry is hot\n          */\n+\n+\n         boolean isHot() {\n             return queueNext == null;\n         }\n \n+\n         V getValue() {\n             return value == null ? reference.get() : value;\n         }\n \n+\n         int getMemory() {\n             return value == null ? 0 : memory;\n         }\n+\n     }\n \n     /**\n      * The cache configuration.\n      */\n+\n+\n     public static class Config {\n \n         /**\n          *  The maximum memory to use (1 or larger).\n          */\n+\n+\n         public long maxMemory = 1;\n \n         /**\n          * The number of cache segments (must be a power of 2).\n          */\n+\n+\n         public int segmentCount = 16;\n \n         /**\n          * How many other item are to be moved to the top of the stack before\n          * the current item is moved.\n          */\n+\n+\n         public int stackMoveDistance = 32;\n \n         /**\n          * Low water mark for the number of entries in the non-resident queue,\n          * as a factor of the number of all other entries in the map.\n          */\n+\n+\n         public final int nonResidentQueueSize = 3;\n \n         /**\n          * High watermark for the number of entries in the non-resident queue,\n          * as a factor of the number of all other entries in the map\n          */\n+\n+\n         public final int nonResidentQueueSizeHigh = 12;\n     }\n-}\n+\n+}\n\\ No newline at end of file\n",
            "diff_size": 178
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/457/CacheLongKeyLIRS.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_random/457/CacheLongKeyLIRS.java\nindex 38c405ce2f4..91f7bafe3d4 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/457/CacheLongKeyLIRS.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_random/457/CacheLongKeyLIRS.java\n@@ -920,8 +920,9 @@ public class CacheLongKeyLIRS<V> {\n                 if (queue2Size <= maxQueue2SizeHigh) {\n                     WeakReference<V> reference = e.reference;\n                     if (reference != null && reference.get() != null) {\n-                        break;  // stop trimming if entry holds a value\n-                    }\n+                        break;\n+                        // stop trimming if entry holds a value\n+                      }\n                 }\n                 int hash = getHash(e.key);\n                 remove(e.key, hash);\n",
            "diff_size": 3
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/457/CacheLongKeyLIRS.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/457/CacheLongKeyLIRS.java\nindex 38c405ce2f4..4bbf252513e 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/457/CacheLongKeyLIRS.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/457/CacheLongKeyLIRS.java\n@@ -920,8 +920,9 @@ public class CacheLongKeyLIRS<V> {\n                 if (queue2Size <= maxQueue2SizeHigh) {\n                     WeakReference<V> reference = e.reference;\n                     if (reference != null && reference.get() != null) {\n-                        break;  // stop trimming if entry holds a value\n-                    }\n+                        break;\n+                    // stop trimming if entry holds a value\n+                      }\n                 }\n                 int hash = getHash(e.key);\n                 remove(e.key, hash);\n",
            "diff_size": 3
        }
    ],
    "repaired_by": [
        "styler",
        "naturalize",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "intellij",
        "codebuff"
    ]
}