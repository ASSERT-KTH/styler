{
    "project_name": "zanata-zanata-platform",
    "error_id": "31",
    "information": {
        "errors": [
            {
                "line": "365",
                "column": "45",
                "severity": "error",
                "message": "Don't use trailing comments.",
                "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
            }
        ]
    },
    "source_code": "        try {\n            tempFile = File.createTempFile(\"zupload\", \".tmp\");\n            byte[] buffer = new byte[4096]; // To hold file contents\n            int bytesRead;\n            FileOutputStream output = new FileOutputStream(tempFile);\n            while ((bytesRead = fileContents.read(buffer)) != -1) {",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/31/TranslationFileServiceImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/styler/31/TranslationFileServiceImpl.java\nindex b8474b2323e..e71d86377fd 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/31/TranslationFileServiceImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/styler/31/TranslationFileServiceImpl.java\n@@ -362,8 +362,9 @@ public class TranslationFileServiceImpl implements TranslationFileService {\n         File tempFile = null;\n         try {\n             tempFile = File.createTempFile(\"zupload\", \".tmp\");\n-            byte[] buffer = new byte[4096]; // To hold file contents\n-            int bytesRead;\n+            byte[] buffer = new byte[4096];\n+            // To hold file contents\n+             int bytesRead;\n             FileOutputStream output = new FileOutputStream(tempFile);\n             while ((bytesRead = fileContents.read(buffer)) != -1) {\n                 output.write(buffer, 0, bytesRead);\n",
            "diff_size": 3
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "369",
                    "column": "39",
                    "severity": "error",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/31/TranslationFileServiceImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/intellij/31/TranslationFileServiceImpl.java\nindex b8474b2323e..93239733b68 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/31/TranslationFileServiceImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/intellij/31/TranslationFileServiceImpl.java\n@@ -18,6 +18,7 @@\n  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA, or see the FSF\n  * site: http://www.fsf.org.\n  */\n+\n package org.zanata.service.impl;\n \n import com.google.common.base.Optional;\n@@ -88,348 +89,351 @@ import static org.zanata.common.DocumentType.XML_DOCUMENT_TYPE_DEFINITION;\n  * Default implementation of the TranslationFileService interface.\n  *\n  * @author Carlos Munoz\n- *         <a href=\"mailto:camunoz@redhat.com\">camunoz@redhat.com</a>\n+ * <a href=\"mailto:camunoz@redhat.com\">camunoz@redhat.com</a>\n  */\n @Named(\"translationFileServiceImpl\")\n @RequestScoped\n @Transactional\n public class TranslationFileServiceImpl implements TranslationFileService {\n-    private static final org.slf4j.Logger log =\n-            org.slf4j.LoggerFactory.getLogger(TranslationFileServiceImpl.class);\n-    private static final long serialVersionUID = 133921403101284549L;\n+  private static final org.slf4j.Logger log =\n+    org.slf4j.LoggerFactory.getLogger(TranslationFileServiceImpl.class);\n+  private static final long serialVersionUID = 133921403101284549L;\n \n-    private static Map<DocumentType, Class<? extends FileFormatAdapter>> DOCTYPEMAP =\n-            new MapMaker().makeMap();\n-    private static DocumentType[] ODF_TYPES =\n-            { OPEN_DOCUMENT_TEXT, OPEN_DOCUMENT_PRESENTATION,\n-                    OPEN_DOCUMENT_SPREADSHEET, OPEN_DOCUMENT_GRAPHICS };\n-    static {\n-        for (DocumentType type : ODF_TYPES) {\n-            DOCTYPEMAP.put(type, OpenOfficeAdapter.class);\n-        }\n-        DOCTYPEMAP.put(PLAIN_TEXT, PlainTextAdapter.class);\n-        DOCTYPEMAP.put(XML_DOCUMENT_TYPE_DEFINITION, DTDAdapter.class);\n-        DOCTYPEMAP.put(IDML, IDMLAdapter.class);\n-        DOCTYPEMAP.put(HTML, HTMLAdapter.class);\n-        DOCTYPEMAP.put(JSON, JsonAdapter.class);\n-        DOCTYPEMAP.put(SUBTITLE, SubtitleAdapter.class);\n-        DOCTYPEMAP.put(PROPERTIES, PropertiesLatinOneAdapter.class);\n-        DOCTYPEMAP.put(PROPERTIES_UTF8, PropertiesUTF8Adapter.class);\n-        DOCTYPEMAP.put(XLIFF, XliffAdapter.class);\n-        DOCTYPEMAP.put(GETTEXT, GettextAdapter.class);\n-        DOCTYPEMAP.put(TS, TSAdapter.class);\n-    }\n-    private static Set<String> SUPPORTED_EXTENSIONS =\n-            buildSupportedExtensionSet();\n+  private static Map<DocumentType, Class<? extends FileFormatAdapter>> DOCTYPEMAP =\n+    new MapMaker().makeMap();\n+  private static DocumentType[] ODF_TYPES =\n+    {OPEN_DOCUMENT_TEXT, OPEN_DOCUMENT_PRESENTATION,\n+      OPEN_DOCUMENT_SPREADSHEET, OPEN_DOCUMENT_GRAPHICS};\n \n-    private static Set<String> buildSupportedExtensionSet() {\n-        Set<String> supported = new HashSet<String>();\n-        for (DocumentType type : DOCTYPEMAP.keySet()) {\n-            supported.addAll(type.getSourceExtensions());\n-        }\n-        return supported;\n+  static {\n+    for (DocumentType type : ODF_TYPES) {\n+      DOCTYPEMAP.put(type, OpenOfficeAdapter.class);\n     }\n+    DOCTYPEMAP.put(PLAIN_TEXT, PlainTextAdapter.class);\n+    DOCTYPEMAP.put(XML_DOCUMENT_TYPE_DEFINITION, DTDAdapter.class);\n+    DOCTYPEMAP.put(IDML, IDMLAdapter.class);\n+    DOCTYPEMAP.put(HTML, HTMLAdapter.class);\n+    DOCTYPEMAP.put(JSON, JsonAdapter.class);\n+    DOCTYPEMAP.put(SUBTITLE, SubtitleAdapter.class);\n+    DOCTYPEMAP.put(PROPERTIES, PropertiesLatinOneAdapter.class);\n+    DOCTYPEMAP.put(PROPERTIES_UTF8, PropertiesUTF8Adapter.class);\n+    DOCTYPEMAP.put(XLIFF, XliffAdapter.class);\n+    DOCTYPEMAP.put(GETTEXT, GettextAdapter.class);\n+    DOCTYPEMAP.put(TS, TSAdapter.class);\n+  }\n \n-    @Inject\n-    private DocumentDAO documentDAO;\n-    @Inject\n-    private ProjectIterationDAO projectIterationDAO;\n+  private static Set<String> SUPPORTED_EXTENSIONS =\n+    buildSupportedExtensionSet();\n \n-    @Override\n-    public TranslationsResource parseTranslationFile(InputStream fileContents,\n-            String fileName, String localeId, String projectSlug,\n-            String iterationSlug, String docId, Optional<String> documentType)\n-            throws ZanataServiceException {\n-        HProjectIteration version =\n-                projectIterationDAO.getBySlug(projectSlug, iterationSlug);\n-        if (version == null) {\n-            throw new ZanataServiceException(\"Project version not found: \"\n-                    + projectSlug + \" \" + iterationSlug);\n-        }\n-        if (fileName.endsWith(\".po\")) {\n-            // Always process a standard translation file\n-            return parsePoFile(fileContents, projectSlug, iterationSlug, docId);\n-        } else if (version.getProjectType() == ProjectType.File) {\n-            // Attempt to equivalent file-type-translate\n-            File tempFile = persistToTempFile(fileContents);\n-            TranslationsResource transRes = parseAdapterTranslationFile(\n-                    tempFile, projectSlug, iterationSlug, docId, localeId,\n-                    fileName, documentType);\n-            removeTempFile(tempFile);\n-            return transRes;\n-        } else {\n-            throw new ZanataServiceException(\n-                    \"Unsupported Translation file: \" + fileName);\n-        }\n+  private static Set<String> buildSupportedExtensionSet() {\n+    Set<String> supported = new HashSet<String>();\n+    for (DocumentType type : DOCTYPEMAP.keySet()) {\n+      supported.addAll(type.getSourceExtensions());\n     }\n+    return supported;\n+  }\n \n-    @Override\n-    public TranslationsResource parsePoFile(InputStream fileContents,\n-            String projectSlug, String iterationSlug, String docId) {\n-        boolean originalIsPo = isPoDocument(projectSlug, iterationSlug, docId);\n-        try {\n-            return parsePoFile(fileContents, !originalIsPo);\n-        } catch (Exception e) {\n-            throw new ZanataServiceException(\n-                    \"Invalid PO file contents on file: \" + docId, e);\n-        }\n-    }\n+  @Inject\n+  private DocumentDAO documentDAO;\n+  @Inject\n+  private ProjectIterationDAO projectIterationDAO;\n \n-    @Override\n-    public TranslationsResource parseAdapterTranslationFile(File tempFile,\n-            String projectSlug, String iterationSlug, String docId,\n-            String localeId, String fileName, Optional<String> documentType) {\n-        HDocument doc = documentDAO.getByProjectIterationAndDocId(projectSlug,\n-                iterationSlug, docId);\n-        TranslationsResource transRes;\n-        FileFormatAdapter adapter = getAdapterFor(documentType, fileName);\n-        try {\n-            transRes = adapter.parseTranslationFile(\n-                    new ParserOptions(tempFile.toURI(), new LocaleId(localeId), getAdapterParams(doc)));\n-        } catch (FileFormatAdapterException e) {\n-            throw new ZanataServiceException(\n-                    \"Error parsing translation file: \" + fileName, e);\n-        } catch (RuntimeException e) {\n-            throw new ZanataServiceException(e);\n-        }\n-        return transRes;\n+  @Override\n+  public TranslationsResource parseTranslationFile(InputStream fileContents,\n+                                                   String fileName, String localeId, String projectSlug,\n+                                                   String iterationSlug, String docId, Optional<String> documentType)\n+    throws ZanataServiceException {\n+    HProjectIteration version =\n+      projectIterationDAO.getBySlug(projectSlug, iterationSlug);\n+    if (version == null) {\n+      throw new ZanataServiceException(\"Project version not found: \"\n+        + projectSlug + \" \" + iterationSlug);\n     }\n-\n-    public String getAdapterParams(HDocument doc) {\n-        if (doc != null) {\n-            HRawDocument rawDoc = doc.getRawDocument();\n-            if (rawDoc != null) {\n-                return nullToEmpty(rawDoc.getAdapterParameters());\n-            }\n-        }\n-        return \"\";\n+    if (fileName.endsWith(\".po\")) {\n+      // Always process a standard translation file\n+      return parsePoFile(fileContents, projectSlug, iterationSlug, docId);\n+    } else if (version.getProjectType() == ProjectType.File) {\n+      // Attempt to equivalent file-type-translate\n+      File tempFile = persistToTempFile(fileContents);\n+      TranslationsResource transRes = parseAdapterTranslationFile(\n+        tempFile, projectSlug, iterationSlug, docId, localeId,\n+        fileName, documentType);\n+      removeTempFile(tempFile);\n+      return transRes;\n+    } else {\n+      throw new ZanataServiceException(\n+        \"Unsupported Translation file: \" + fileName);\n     }\n+  }\n \n-    @Override\n-    public Resource parseUpdatedPotFile(InputStream fileContents, String docId,\n-            String fileName, boolean offlinePo) {\n-        if (fileName.endsWith(\".pot\")) {\n-            try {\n-                return parsePotFile(fileContents, docId, offlinePo);\n-            } catch (Exception e) {\n-                throw new ZanataServiceException(\n-                        \"Invalid POT file contents on file: \" + docId, e);\n-            }\n-        } else {\n-            throw new ZanataServiceException(\n-                    \"Unsupported Document file: \" + docId);\n-        }\n+  @Override\n+  public TranslationsResource parsePoFile(InputStream fileContents,\n+                                          String projectSlug, String iterationSlug, String docId) {\n+    boolean originalIsPo = isPoDocument(projectSlug, iterationSlug, docId);\n+    try {\n+      return parsePoFile(fileContents, !originalIsPo);\n+    } catch (Exception e) {\n+      throw new ZanataServiceException(\n+        \"Invalid PO file contents on file: \" + docId, e);\n     }\n+  }\n \n-    @Override\n-    public boolean hasMultipleDocumentTypes(String fileNameOrExtension) {\n-        String extension = FilenameUtils.getExtension(fileNameOrExtension);\n-        return DocumentType.fromSourceExtension(extension).size() > 1;\n+  @Override\n+  public TranslationsResource parseAdapterTranslationFile(File tempFile,\n+                                                          String projectSlug, String iterationSlug, String docId,\n+                                                          String localeId, String fileName,\n+                                                          Optional<String> documentType) {\n+    HDocument doc = documentDAO.getByProjectIterationAndDocId(projectSlug,\n+      iterationSlug, docId);\n+    TranslationsResource transRes;\n+    FileFormatAdapter adapter = getAdapterFor(documentType, fileName);\n+    try {\n+      transRes = adapter.parseTranslationFile(\n+        new ParserOptions(tempFile.toURI(), new LocaleId(localeId), getAdapterParams(doc)));\n+    } catch (FileFormatAdapterException e) {\n+      throw new ZanataServiceException(\n+        \"Error parsing translation file: \" + fileName, e);\n+    } catch (RuntimeException e) {\n+      throw new ZanataServiceException(e);\n     }\n+    return transRes;\n+  }\n \n-    @Override\n-    public Set<DocumentType> getDocumentTypes(String fileNameOrExtension) {\n-        String extension = FilenameUtils.getExtension(fileNameOrExtension);\n-        Set<DocumentType> documentTypes =\n-                DocumentType.fromSourceExtension(extension);\n-        documentTypes.addAll(DocumentType.fromTranslationExtension(extension));\n-        return documentTypes;\n+  public String getAdapterParams(HDocument doc) {\n+    if (doc != null) {\n+      HRawDocument rawDoc = doc.getRawDocument();\n+      if (rawDoc != null) {\n+        return nullToEmpty(rawDoc.getAdapterParameters());\n+      }\n     }\n+    return \"\";\n+  }\n \n-    @Override\n-    public Resource parseAdapterDocumentFile(\n-            String documentPath, String fileName, ParserOptions options,\n-            Optional<String> documentType) throws ZanataServiceException {\n-        return parseUpdatedAdapterDocumentFile(\n-                FileUtil.convertToValidPath(documentPath) + fileName, fileName,\n-                options, documentType);\n+  @Override\n+  public Resource parseUpdatedPotFile(InputStream fileContents, String docId,\n+                                      String fileName, boolean offlinePo) {\n+    if (fileName.endsWith(\".pot\")) {\n+      try {\n+        return parsePotFile(fileContents, docId, offlinePo);\n+      } catch (Exception e) {\n+        throw new ZanataServiceException(\n+          \"Invalid POT file contents on file: \" + docId, e);\n+      }\n+    } else {\n+      throw new ZanataServiceException(\n+        \"Unsupported Document file: \" + docId);\n     }\n+  }\n \n-    @Override\n-    public Resource parseUpdatedAdapterDocumentFile(\n-            String docId, String fileName, ParserOptions options,\n-            Optional<String> documentType) throws ZanataServiceException {\n-        FileFormatAdapter adapter = getAdapterFor(documentType, fileName);\n-        Resource doc;\n-        try {\n-            doc = adapter.parseDocumentFile(options);\n-        } catch (FileFormatAdapterException e) {\n-            throw new ZanataServiceException(\n-                    \"Error parsing document file: \" + fileName, e);\n-        }\n-        doc.setName(docId);\n-        return doc;\n-    }\n+  @Override\n+  public boolean hasMultipleDocumentTypes(String fileNameOrExtension) {\n+    String extension = FilenameUtils.getExtension(fileNameOrExtension);\n+    return DocumentType.fromSourceExtension(extension).size() > 1;\n+  }\n \n-    private TranslationsResource parsePoFile(InputStream fileContents,\n-            boolean offlinePo) {\n-        PoReader2 poReader = new PoReader2(offlinePo);\n-        return poReader.extractTarget(new InputSource(fileContents));\n-    }\n+  @Override\n+  public Set<DocumentType> getDocumentTypes(String fileNameOrExtension) {\n+    String extension = FilenameUtils.getExtension(fileNameOrExtension);\n+    Set<DocumentType> documentTypes =\n+      DocumentType.fromSourceExtension(extension);\n+    documentTypes.addAll(DocumentType.fromTranslationExtension(extension));\n+    return documentTypes;\n+  }\n \n-    private Resource parsePotFile(InputStream fileContents, String docId,\n-            boolean offlinePo) {\n-        PoReader2 poReader = new PoReader2(offlinePo);\n-        // assume english as source locale\n-        Resource res = poReader.extractTemplate(new InputSource(fileContents),\n-                new LocaleId(\"en\"), docId);\n-        return res;\n-    }\n-    // TODO replace these with values from DocumentType\n+  @Override\n+  public Resource parseAdapterDocumentFile(\n+    String documentPath, String fileName, ParserOptions options,\n+    Optional<String> documentType) throws ZanataServiceException {\n+    return parseUpdatedAdapterDocumentFile(\n+      FileUtil.convertToValidPath(documentPath) + fileName, fileName,\n+      options, documentType);\n+  }\n \n-    @Override\n-    public Set<String> getSupportedExtensions() {\n-        return SUPPORTED_EXTENSIONS;\n+  @Override\n+  public Resource parseUpdatedAdapterDocumentFile(\n+    String docId, String fileName, ParserOptions options,\n+    Optional<String> documentType) throws ZanataServiceException {\n+    FileFormatAdapter adapter = getAdapterFor(documentType, fileName);\n+    Resource doc;\n+    try {\n+      doc = adapter.parseDocumentFile(options);\n+    } catch (FileFormatAdapterException e) {\n+      throw new ZanataServiceException(\n+        \"Error parsing document file: \" + fileName, e);\n     }\n+    doc.setName(docId);\n+    return doc;\n+  }\n \n-    @Override\n-    public boolean hasAdapterFor(DocumentType type) {\n-        if (type == null) {\n-            return false;\n-        }\n-        return DOCTYPEMAP.containsKey(type);\n-    }\n+  private TranslationsResource parsePoFile(InputStream fileContents,\n+                                           boolean offlinePo) {\n+    PoReader2 poReader = new PoReader2(offlinePo);\n+    return poReader.extractTarget(new InputSource(fileContents));\n+  }\n \n-    @Override\n-    public Set<DocumentType> getSupportedDocumentTypes() {\n-        return DOCTYPEMAP.keySet();\n-    }\n+  private Resource parsePotFile(InputStream fileContents, String docId,\n+                                boolean offlinePo) {\n+    PoReader2 poReader = new PoReader2(offlinePo);\n+    // assume english as source locale\n+    Resource res = poReader.extractTemplate(new InputSource(fileContents),\n+      new LocaleId(\"en\"), docId);\n+    return res;\n+  }\n+  // TODO replace these with values from DocumentType\n \n-    private FileFormatAdapter getAdapterFor(String fileNameOrExtension) {\n-        String extension = FilenameUtils.getExtension(fileNameOrExtension);\n-        if (extension == null) {\n-            throw new RuntimeException(\n-                    \"Cannot find adapter for null filename or extension.\");\n-        }\n-        DocumentType documentType = DocumentType.getByName(extension);\n-        if (documentType == null) {\n-            throw new RuntimeException(\n-                    \"Cannot choose an adapter because the provided string \\'\"\n-                            + fileNameOrExtension\n-                            + \"\\' does not match any known document type.\");\n-        }\n-        FileFormatAdapter adapter = getAdapterFor(documentType);\n-        if (hasMultipleDocumentTypes(fileNameOrExtension)) {\n-            log.warn(\n-                    \"More than 1 adapter found for this file extension: \\'{}\\'. Adapter \\'{}\\' will be used.\",\n-                    extension, adapter.getClass().getName());\n-        }\n-        return adapter;\n-    }\n+  @Override\n+  public Set<String> getSupportedExtensions() {\n+    return SUPPORTED_EXTENSIONS;\n+  }\n \n-    /**\n-     * TODO: throw runtime error. Need to wait for all upload file dialog\n-     * implement multiple adapter check for file extension.\n-     *\n-     * https://bugzilla.redhat.com/show_bug.cgi?id=1217671\n-     */\n-    @Override\n-    public FileFormatAdapter getAdapterFor(DocumentType type) {\n-        Class<? extends FileFormatAdapter> clazz = DOCTYPEMAP.get(type);\n-        if (clazz == null) {\n-            throw new RuntimeException(\"No adapter for document type: \" + type);\n-        }\n-        try {\n-            return clazz.newInstance();\n-        } catch (Exception e) {\n-            throw new RuntimeException(\n-                    \"Unable to construct adapter for document type: \" + type,\n-                    e);\n-        }\n+  @Override\n+  public boolean hasAdapterFor(DocumentType type) {\n+    if (type == null) {\n+      return false;\n     }\n+    return DOCTYPEMAP.containsKey(type);\n+  }\n+\n+  @Override\n+  public Set<DocumentType> getSupportedDocumentTypes() {\n+    return DOCTYPEMAP.keySet();\n+  }\n \n-    /**\n-     * Get an appropriate adapter for a document type or file name.\n-     *\n-     * @param documentType\n-     * @param fileName\n-     * @return adapter for given documentType if present, otherwise return\n-     *         adapter with given fileName.\n-     */\n-    private FileFormatAdapter getAdapterFor(Optional<String> documentType,\n-            @Nonnull String fileName) {\n-        if (documentType.isPresent()\n-                && StringUtils.isNotEmpty(documentType.get())) {\n-            DocumentType docType = DocumentType.valueOf(documentType.get());\n-            return docType != null ? getAdapterFor(docType)\n-                    : getAdapterFor(fileName);\n-        }\n-        return getAdapterFor(fileName);\n+  private FileFormatAdapter getAdapterFor(String fileNameOrExtension) {\n+    String extension = FilenameUtils.getExtension(fileNameOrExtension);\n+    if (extension == null) {\n+      throw new RuntimeException(\n+        \"Cannot find adapter for null filename or extension.\");\n+    }\n+    DocumentType documentType = DocumentType.getByName(extension);\n+    if (documentType == null) {\n+      throw new RuntimeException(\n+        \"Cannot choose an adapter because the provided string \\'\"\n+          + fileNameOrExtension\n+          + \"\\' does not match any known document type.\");\n     }\n+    FileFormatAdapter adapter = getAdapterFor(documentType);\n+    if (hasMultipleDocumentTypes(fileNameOrExtension)) {\n+      log.warn(\n+        \"More than 1 adapter found for this file extension: \\'{}\\'. Adapter \\'{}\\' will be used.\",\n+        extension, adapter.getClass().getName());\n+    }\n+    return adapter;\n+  }\n \n-    @Override\n-    public File persistToTempFile(InputStream fileContents) {\n-        File tempFile = null;\n-        try {\n-            tempFile = File.createTempFile(\"zupload\", \".tmp\");\n-            byte[] buffer = new byte[4096]; // To hold file contents\n-            int bytesRead;\n-            FileOutputStream output = new FileOutputStream(tempFile);\n-            while ((bytesRead = fileContents.read(buffer)) != -1) {\n-                output.write(buffer, 0, bytesRead);\n-            }\n-            output.close();\n-        } catch (IOException e) {\n-            throw new ZanataServiceException(\n-                    \"Error while writing uploaded file to temporary location\",\n-                    e);\n-        }\n-        return tempFile;\n+  /**\n+   * TODO: throw runtime error. Need to wait for all upload file dialog\n+   * implement multiple adapter check for file extension.\n+   * <p>\n+   * https://bugzilla.redhat.com/show_bug.cgi?id=1217671\n+   */\n+  @Override\n+  public FileFormatAdapter getAdapterFor(DocumentType type) {\n+    Class<? extends FileFormatAdapter> clazz = DOCTYPEMAP.get(type);\n+    if (clazz == null) {\n+      throw new RuntimeException(\"No adapter for document type: \" + type);\n+    }\n+    try {\n+      return clazz.newInstance();\n+    } catch (Exception e) {\n+      throw new RuntimeException(\n+        \"Unable to construct adapter for document type: \" + type,\n+        e);\n     }\n+  }\n \n-    @Override\n-    public void removeTempFile(File tempFile) {\n-        if (tempFile != null) {\n-            if (!tempFile.delete()) {\n-                log.warn(\n-                        \"unable to remove temporary file {}, marking for delete on exit\",\n-                        tempFile.getAbsolutePath());\n-                tempFile.deleteOnExit();\n-            }\n-        }\n+  /**\n+   * Get an appropriate adapter for a document type or file name.\n+   *\n+   * @param documentType\n+   * @param fileName\n+   * @return adapter for given documentType if present, otherwise return\n+   * adapter with given fileName.\n+   */\n+  private FileFormatAdapter getAdapterFor(Optional<String> documentType,\n+                                          @Nonnull String fileName) {\n+    if (documentType.isPresent()\n+      && StringUtils.isNotEmpty(documentType.get())) {\n+      DocumentType docType = DocumentType.valueOf(documentType.get());\n+      return docType != null ? getAdapterFor(docType)\n+        : getAdapterFor(fileName);\n     }\n+    return getAdapterFor(fileName);\n+  }\n \n-    @Override\n-    public String getSourceFileExtension(String projectSlug,\n-            String iterationSlug, String docPath, String docName) {\n-        return FilenameUtils.getExtension(docName);\n+  @Override\n+  public File persistToTempFile(InputStream fileContents) {\n+    File tempFile = null;\n+    try {\n+      tempFile = File.createTempFile(\"zupload\", \".tmp\");\n+      byte[] buffer = new byte[4096]; // To hold file contents\n+      int bytesRead;\n+      FileOutputStream output = new FileOutputStream(tempFile);\n+      while ((bytesRead = fileContents.read(buffer)) != -1) {\n+        output.write(buffer, 0, bytesRead);\n+      }\n+      output.close();\n+    } catch (IOException e) {\n+      throw new ZanataServiceException(\n+        \"Error while writing uploaded file to temporary location\",\n+        e);\n     }\n+    return tempFile;\n+  }\n \n-    @Override\n-    public String getTranslationFileExtension(String projectSlug,\n-            String iterationSlug, String docPath, String docName) {\n-        String srcExt = getSourceFileExtension(projectSlug, iterationSlug,\n-                docPath, docName);\n-        HDocument doc = documentDAO.getByProjectIterationAndDocId(projectSlug,\n-                iterationSlug, docPath + docName);\n-        return doc.getRawDocument().getType().getExtensions().get(srcExt);\n+  @Override\n+  public void removeTempFile(File tempFile) {\n+    if (tempFile != null) {\n+      if (!tempFile.delete()) {\n+        log.warn(\n+          \"unable to remove temporary file {}, marking for delete on exit\",\n+          tempFile.getAbsolutePath());\n+        tempFile.deleteOnExit();\n+      }\n     }\n+  }\n \n-    @Override\n-    public boolean isPoDocument(String projectSlug, String iterationSlug,\n-            String docId) {\n-        HProjectIteration projectIteration =\n-                projectIterationDAO.getBySlug(projectSlug, iterationSlug);\n-        ProjectType projectType = projectIteration.getProjectType();\n-        if (projectType == null) {\n-            projectType = projectIteration.getProject().getDefaultProjectType();\n-        }\n-        if (projectType == ProjectType.Gettext\n-                || projectType == ProjectType.Podir) {\n-            return true;\n-        }\n-        if (projectType == ProjectType.File) {\n-            HDocument doc =\n-                    documentDAO.getByDocIdAndIteration(projectIteration, docId);\n-            if (doc.getRawDocument() == null) {\n-                // po is the only format in File projects for which no raw\n-                // document is stored\n-                return true;\n-            }\n-            // additional check in case we do start storing raw documents for po\n-            DocumentType docType = doc.getRawDocument().getType();\n-            return docType == GETTEXT;\n-        }\n-        return false;\n+  @Override\n+  public String getSourceFileExtension(String projectSlug,\n+                                       String iterationSlug, String docPath, String docName) {\n+    return FilenameUtils.getExtension(docName);\n+  }\n+\n+  @Override\n+  public String getTranslationFileExtension(String projectSlug,\n+                                            String iterationSlug, String docPath, String docName) {\n+    String srcExt = getSourceFileExtension(projectSlug, iterationSlug,\n+      docPath, docName);\n+    HDocument doc = documentDAO.getByProjectIterationAndDocId(projectSlug,\n+      iterationSlug, docPath + docName);\n+    return doc.getRawDocument().getType().getExtensions().get(srcExt);\n+  }\n+\n+  @Override\n+  public boolean isPoDocument(String projectSlug, String iterationSlug,\n+                              String docId) {\n+    HProjectIteration projectIteration =\n+      projectIterationDAO.getBySlug(projectSlug, iterationSlug);\n+    ProjectType projectType = projectIteration.getProjectType();\n+    if (projectType == null) {\n+      projectType = projectIteration.getProject().getDefaultProjectType();\n+    }\n+    if (projectType == ProjectType.Gettext\n+      || projectType == ProjectType.Podir) {\n+      return true;\n+    }\n+    if (projectType == ProjectType.File) {\n+      HDocument doc =\n+        documentDAO.getByDocIdAndIteration(projectIteration, docId);\n+      if (doc.getRawDocument() == null) {\n+        // po is the only format in File projects for which no raw\n+        // document is stored\n+        return true;\n+      }\n+      // additional check in case we do start storing raw documents for po\n+      DocumentType docType = doc.getRawDocument().getType();\n+      return docType == GETTEXT;\n     }\n+    return false;\n+  }\n }\n",
            "diff_size": 419
        },
        {
            "tool": "naturalize",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/31/TranslationFileServiceImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/naturalize/31/TranslationFileServiceImpl.java\nindex b8474b2323e..7e346e28cbc 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/31/TranslationFileServiceImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/naturalize/31/TranslationFileServiceImpl.java\n@@ -103,7 +103,7 @@ public class TranslationFileServiceImpl implements TranslationFileService {\n     private static DocumentType[] ODF_TYPES =\n             { OPEN_DOCUMENT_TEXT, OPEN_DOCUMENT_PRESENTATION,\n                     OPEN_DOCUMENT_SPREADSHEET, OPEN_DOCUMENT_GRAPHICS };\n-    static {\n+        static {\n         for (DocumentType type : ODF_TYPES) {\n             DOCTYPEMAP.put(type, OpenOfficeAdapter.class);\n         }\n@@ -362,7 +362,9 @@ public class TranslationFileServiceImpl implements TranslationFileService {\n         File tempFile = null;\n         try {\n             tempFile = File.createTempFile(\"zupload\", \".tmp\");\n-            byte[] buffer = new byte[4096]; // To hold file contents\n+            byte[] buffer = new byte[4096];\n+\n+// To hold file contents\n             int bytesRead;\n             FileOutputStream output = new FileOutputStream(tempFile);\n             while ((bytesRead = fileContents.read(buffer)) != -1) {\n@@ -432,4 +434,4 @@ public class TranslationFileServiceImpl implements TranslationFileService {\n         }\n         return false;\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 5
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "342",
                    "column": "45",
                    "severity": "error",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/31/TranslationFileServiceImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/codebuff/31/TranslationFileServiceImpl.java\nindex b8474b2323e..ff30eccaa01 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/31/TranslationFileServiceImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/codebuff/31/TranslationFileServiceImpl.java\n@@ -90,19 +90,22 @@ import static org.zanata.common.DocumentType.XML_DOCUMENT_TYPE_DEFINITION;\n  * @author Carlos Munoz\n  *         <a href=\"mailto:camunoz@redhat.com\">camunoz@redhat.com</a>\n  */\n+\n+\n @Named(\"translationFileServiceImpl\")\n @RequestScoped\n @Transactional\n public class TranslationFileServiceImpl implements TranslationFileService {\n-    private static final org.slf4j.Logger log =\n-            org.slf4j.LoggerFactory.getLogger(TranslationFileServiceImpl.class);\n+    private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(TranslationFileServiceImpl.class);\n     private static final long serialVersionUID = 133921403101284549L;\n+    private static Map<DocumentType, Class<? extends FileFormatAdapter>> DOCTYPEMAP = new MapMaker().makeMap();\n+    private static DocumentType[] ODF_TYPES = {\n+            OPEN_DOCUMENT_TEXT,\n+            OPEN_DOCUMENT_PRESENTATION,\n+            OPEN_DOCUMENT_SPREADSHEET,\n+            OPEN_DOCUMENT_GRAPHICS\n+    };\n \n-    private static Map<DocumentType, Class<? extends FileFormatAdapter>> DOCTYPEMAP =\n-            new MapMaker().makeMap();\n-    private static DocumentType[] ODF_TYPES =\n-            { OPEN_DOCUMENT_TEXT, OPEN_DOCUMENT_PRESENTATION,\n-                    OPEN_DOCUMENT_SPREADSHEET, OPEN_DOCUMENT_GRAPHICS };\n     static {\n         for (DocumentType type : ODF_TYPES) {\n             DOCTYPEMAP.put(type, OpenOfficeAdapter.class);\n@@ -119,9 +122,8 @@ public class TranslationFileServiceImpl implements TranslationFileService {\n         DOCTYPEMAP.put(GETTEXT, GettextAdapter.class);\n         DOCTYPEMAP.put(TS, TSAdapter.class);\n     }\n-    private static Set<String> SUPPORTED_EXTENSIONS =\n-            buildSupportedExtensionSet();\n \n+    private static Set<String> SUPPORTED_EXTENSIONS = buildSupportedExtensionSet();\n     private static Set<String> buildSupportedExtensionSet() {\n         Set<String> supported = new HashSet<String>();\n         for (DocumentType type : DOCTYPEMAP.keySet()) {\n@@ -134,17 +136,16 @@ public class TranslationFileServiceImpl implements TranslationFileService {\n     private DocumentDAO documentDAO;\n     @Inject\n     private ProjectIterationDAO projectIterationDAO;\n-\n     @Override\n     public TranslationsResource parseTranslationFile(InputStream fileContents,\n-            String fileName, String localeId, String projectSlug,\n-            String iterationSlug, String docId, Optional<String> documentType)\n-            throws ZanataServiceException {\n-        HProjectIteration version =\n-                projectIterationDAO.getBySlug(projectSlug, iterationSlug);\n+        String fileName,\n+            String localeId,\n+                String projectSlug,\n+                    String iterationSlug,\n+                        String docId, Optional<String> documentType) throws ZanataServiceException {\n+        HProjectIteration version = projectIterationDAO.getBySlug(projectSlug, iterationSlug);\n         if (version == null) {\n-            throw new ZanataServiceException(\"Project version not found: \"\n-                    + projectSlug + \" \" + iterationSlug);\n+            throw new ZanataServiceException(\"Project version not found: \" + projectSlug + \" \" + iterationSlug);\n         }\n         if (fileName.endsWith(\".po\")) {\n             // Always process a standard translation file\n@@ -152,43 +153,41 @@ public class TranslationFileServiceImpl implements TranslationFileService {\n         } else if (version.getProjectType() == ProjectType.File) {\n             // Attempt to equivalent file-type-translate\n             File tempFile = persistToTempFile(fileContents);\n-            TranslationsResource transRes = parseAdapterTranslationFile(\n-                    tempFile, projectSlug, iterationSlug, docId, localeId,\n-                    fileName, documentType);\n+            TranslationsResource transRes = parseAdapterTranslationFile(tempFile, projectSlug, iterationSlug, docId, localeId, fileName, documentType);\n             removeTempFile(tempFile);\n             return transRes;\n         } else {\n-            throw new ZanataServiceException(\n-                    \"Unsupported Translation file: \" + fileName);\n+            throw new ZanataServiceException(\"Unsupported Translation file: \" + fileName);\n         }\n     }\n \n     @Override\n     public TranslationsResource parsePoFile(InputStream fileContents,\n-            String projectSlug, String iterationSlug, String docId) {\n+        String projectSlug,\n+            String iterationSlug, String docId) {\n         boolean originalIsPo = isPoDocument(projectSlug, iterationSlug, docId);\n         try {\n             return parsePoFile(fileContents, !originalIsPo);\n         } catch (Exception e) {\n-            throw new ZanataServiceException(\n-                    \"Invalid PO file contents on file: \" + docId, e);\n+            throw new ZanataServiceException(\"Invalid PO file contents on file: \" + docId, e);\n         }\n     }\n \n     @Override\n     public TranslationsResource parseAdapterTranslationFile(File tempFile,\n-            String projectSlug, String iterationSlug, String docId,\n-            String localeId, String fileName, Optional<String> documentType) {\n-        HDocument doc = documentDAO.getByProjectIterationAndDocId(projectSlug,\n-                iterationSlug, docId);\n+        String projectSlug,\n+            String iterationSlug,\n+                String docId,\n+                    String localeId,\n+                        String fileName, Optional<String> documentType) {\n+        HDocument doc = documentDAO.getByProjectIterationAndDocId(projectSlug, iterationSlug, docId);\n         TranslationsResource transRes;\n         FileFormatAdapter adapter = getAdapterFor(documentType, fileName);\n         try {\n-            transRes = adapter.parseTranslationFile(\n-                    new ParserOptions(tempFile.toURI(), new LocaleId(localeId), getAdapterParams(doc)));\n+            transRes = adapter.parseTranslationFile(new ParserOptions(tempFile.toURI(),\n+                                                                      new LocaleId(localeId), getAdapterParams(doc)));\n         } catch (FileFormatAdapterException e) {\n-            throw new ZanataServiceException(\n-                    \"Error parsing translation file: \" + fileName, e);\n+            throw new ZanataServiceException(\"Error parsing translation file: \" + fileName, e);\n         } catch (RuntimeException e) {\n             throw new ZanataServiceException(e);\n         }\n@@ -206,18 +205,15 @@ public class TranslationFileServiceImpl implements TranslationFileService {\n     }\n \n     @Override\n-    public Resource parseUpdatedPotFile(InputStream fileContents, String docId,\n-            String fileName, boolean offlinePo) {\n+    public Resource parseUpdatedPotFile(InputStream fileContents, String docId, String fileName, boolean offlinePo) {\n         if (fileName.endsWith(\".pot\")) {\n             try {\n                 return parsePotFile(fileContents, docId, offlinePo);\n             } catch (Exception e) {\n-                throw new ZanataServiceException(\n-                        \"Invalid POT file contents on file: \" + docId, e);\n+                throw new ZanataServiceException(\"Invalid POT file contents on file: \" + docId, e);\n             }\n         } else {\n-            throw new ZanataServiceException(\n-                    \"Unsupported Document file: \" + docId);\n+            throw new ZanataServiceException(\"Unsupported Document file: \" + docId);\n         }\n     }\n \n@@ -230,49 +226,38 @@ public class TranslationFileServiceImpl implements TranslationFileService {\n     @Override\n     public Set<DocumentType> getDocumentTypes(String fileNameOrExtension) {\n         String extension = FilenameUtils.getExtension(fileNameOrExtension);\n-        Set<DocumentType> documentTypes =\n-                DocumentType.fromSourceExtension(extension);\n+        Set<DocumentType> documentTypes = DocumentType.fromSourceExtension(extension);\n         documentTypes.addAll(DocumentType.fromTranslationExtension(extension));\n         return documentTypes;\n     }\n \n     @Override\n-    public Resource parseAdapterDocumentFile(\n-            String documentPath, String fileName, ParserOptions options,\n-            Optional<String> documentType) throws ZanataServiceException {\n-        return parseUpdatedAdapterDocumentFile(\n-                FileUtil.convertToValidPath(documentPath) + fileName, fileName,\n-                options, documentType);\n+    public Resource parseAdapterDocumentFile(String documentPath, String fileName, ParserOptions options, Optional<String> documentType) throws ZanataServiceException {\n+        return parseUpdatedAdapterDocumentFile(FileUtil.convertToValidPath(documentPath) + fileName, fileName, options, documentType);\n     }\n \n     @Override\n-    public Resource parseUpdatedAdapterDocumentFile(\n-            String docId, String fileName, ParserOptions options,\n-            Optional<String> documentType) throws ZanataServiceException {\n+    public Resource parseUpdatedAdapterDocumentFile(String docId, String fileName, ParserOptions options, Optional<String> documentType) throws ZanataServiceException {\n         FileFormatAdapter adapter = getAdapterFor(documentType, fileName);\n         Resource doc;\n         try {\n             doc = adapter.parseDocumentFile(options);\n         } catch (FileFormatAdapterException e) {\n-            throw new ZanataServiceException(\n-                    \"Error parsing document file: \" + fileName, e);\n+            throw new ZanataServiceException(\"Error parsing document file: \" + fileName, e);\n         }\n         doc.setName(docId);\n         return doc;\n     }\n \n-    private TranslationsResource parsePoFile(InputStream fileContents,\n-            boolean offlinePo) {\n+    private TranslationsResource parsePoFile(InputStream fileContents, boolean offlinePo) {\n         PoReader2 poReader = new PoReader2(offlinePo);\n         return poReader.extractTarget(new InputSource(fileContents));\n     }\n \n-    private Resource parsePotFile(InputStream fileContents, String docId,\n-            boolean offlinePo) {\n+    private Resource parsePotFile(InputStream fileContents, String docId, boolean offlinePo) {\n         PoReader2 poReader = new PoReader2(offlinePo);\n         // assume english as source locale\n-        Resource res = poReader.extractTemplate(new InputSource(fileContents),\n-                new LocaleId(\"en\"), docId);\n+        Resource res = poReader.extractTemplate(new InputSource(fileContents), new LocaleId(\"en\"), docId);\n         return res;\n     }\n     // TODO replace these with values from DocumentType\n@@ -298,21 +283,15 @@ public class TranslationFileServiceImpl implements TranslationFileService {\n     private FileFormatAdapter getAdapterFor(String fileNameOrExtension) {\n         String extension = FilenameUtils.getExtension(fileNameOrExtension);\n         if (extension == null) {\n-            throw new RuntimeException(\n-                    \"Cannot find adapter for null filename or extension.\");\n+            throw new RuntimeException(\"Cannot find adapter for null filename or extension.\");\n         }\n         DocumentType documentType = DocumentType.getByName(extension);\n         if (documentType == null) {\n-            throw new RuntimeException(\n-                    \"Cannot choose an adapter because the provided string \\'\"\n-                            + fileNameOrExtension\n-                            + \"\\' does not match any known document type.\");\n+            throw new RuntimeException(\"Cannot choose an adapter because the provided string \\'\" + fileNameOrExtension + \"\\' does not match any known document type.\");\n         }\n         FileFormatAdapter adapter = getAdapterFor(documentType);\n         if (hasMultipleDocumentTypes(fileNameOrExtension)) {\n-            log.warn(\n-                    \"More than 1 adapter found for this file extension: \\'{}\\'. Adapter \\'{}\\' will be used.\",\n-                    extension, adapter.getClass().getName());\n+            log.warn(\"More than 1 adapter found for this file extension: \\'{}\\'. Adapter \\'{}\\' will be used.\", extension, adapter.getClass().getName());\n         }\n         return adapter;\n     }\n@@ -323,6 +302,7 @@ public class TranslationFileServiceImpl implements TranslationFileService {\n      *\n      * https://bugzilla.redhat.com/show_bug.cgi?id=1217671\n      */\n+\n     @Override\n     public FileFormatAdapter getAdapterFor(DocumentType type) {\n         Class<? extends FileFormatAdapter> clazz = DOCTYPEMAP.get(type);\n@@ -332,9 +312,7 @@ public class TranslationFileServiceImpl implements TranslationFileService {\n         try {\n             return clazz.newInstance();\n         } catch (Exception e) {\n-            throw new RuntimeException(\n-                    \"Unable to construct adapter for document type: \" + type,\n-                    e);\n+            throw new RuntimeException(\"Unable to construct adapter for document type: \" + type, e);\n         }\n     }\n \n@@ -346,13 +324,12 @@ public class TranslationFileServiceImpl implements TranslationFileService {\n      * @return adapter for given documentType if present, otherwise return\n      *         adapter with given fileName.\n      */\n+\n     private FileFormatAdapter getAdapterFor(Optional<String> documentType,\n-            @Nonnull String fileName) {\n-        if (documentType.isPresent()\n-                && StringUtils.isNotEmpty(documentType.get())) {\n+    @Nonnull String fileName) {\n+        if (documentType.isPresent() && StringUtils.isNotEmpty(documentType.get())) {\n             DocumentType docType = DocumentType.valueOf(documentType.get());\n-            return docType != null ? getAdapterFor(docType)\n-                    : getAdapterFor(fileName);\n+            return docType != null ? getAdapterFor(docType) : getAdapterFor(fileName);\n         }\n         return getAdapterFor(fileName);\n     }\n@@ -370,9 +347,7 @@ public class TranslationFileServiceImpl implements TranslationFileService {\n             }\n             output.close();\n         } catch (IOException e) {\n-            throw new ZanataServiceException(\n-                    \"Error while writing uploaded file to temporary location\",\n-                    e);\n+            throw new ZanataServiceException(\"Error while writing uploaded file to temporary location\", e);\n         }\n         return tempFile;\n     }\n@@ -381,35 +356,27 @@ public class TranslationFileServiceImpl implements TranslationFileService {\n     public void removeTempFile(File tempFile) {\n         if (tempFile != null) {\n             if (!tempFile.delete()) {\n-                log.warn(\n-                        \"unable to remove temporary file {}, marking for delete on exit\",\n-                        tempFile.getAbsolutePath());\n+                log.warn(\"unable to remove temporary file {}, marking for delete on exit\", tempFile.getAbsolutePath());\n                 tempFile.deleteOnExit();\n             }\n         }\n     }\n \n     @Override\n-    public String getSourceFileExtension(String projectSlug,\n-            String iterationSlug, String docPath, String docName) {\n+    public String getSourceFileExtension(String projectSlug, String iterationSlug, String docPath, String docName) {\n         return FilenameUtils.getExtension(docName);\n     }\n \n     @Override\n-    public String getTranslationFileExtension(String projectSlug,\n-            String iterationSlug, String docPath, String docName) {\n-        String srcExt = getSourceFileExtension(projectSlug, iterationSlug,\n-                docPath, docName);\n-        HDocument doc = documentDAO.getByProjectIterationAndDocId(projectSlug,\n-                iterationSlug, docPath + docName);\n+    public String getTranslationFileExtension(String projectSlug, String iterationSlug, String docPath, String docName) {\n+        String srcExt = getSourceFileExtension(projectSlug, iterationSlug, docPath, docName);\n+        HDocument doc = documentDAO.getByProjectIterationAndDocId(projectSlug, iterationSlug, docPath + docName);\n         return doc.getRawDocument().getType().getExtensions().get(srcExt);\n     }\n \n     @Override\n-    public boolean isPoDocument(String projectSlug, String iterationSlug,\n-            String docId) {\n-        HProjectIteration projectIteration =\n-                projectIterationDAO.getBySlug(projectSlug, iterationSlug);\n+    public boolean isPoDocument(String projectSlug, String iterationSlug, String docId) {\n+        HProjectIteration projectIteration = projectIterationDAO.getBySlug(projectSlug, iterationSlug);\n         ProjectType projectType = projectIteration.getProjectType();\n         if (projectType == null) {\n             projectType = projectIteration.getProject().getDefaultProjectType();\n@@ -419,8 +386,7 @@ public class TranslationFileServiceImpl implements TranslationFileService {\n             return true;\n         }\n         if (projectType == ProjectType.File) {\n-            HDocument doc =\n-                    documentDAO.getByDocIdAndIteration(projectIteration, docId);\n+            HDocument doc = documentDAO.getByDocIdAndIteration(projectIteration, docId);\n             if (doc.getRawDocument() == null) {\n                 // po is the only format in File projects for which no raw\n                 // document is stored\n@@ -432,4 +398,4 @@ public class TranslationFileServiceImpl implements TranslationFileService {\n         }\n         return false;\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 112
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "365",
                    "column": "45",
                    "severity": "error",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/31/TranslationFileServiceImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/styler_three_grams/31/TranslationFileServiceImpl.java\nindex b8474b2323e..e71d86377fd 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/31/TranslationFileServiceImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/styler_three_grams/31/TranslationFileServiceImpl.java\n@@ -362,8 +362,9 @@ public class TranslationFileServiceImpl implements TranslationFileService {\n         File tempFile = null;\n         try {\n             tempFile = File.createTempFile(\"zupload\", \".tmp\");\n-            byte[] buffer = new byte[4096]; // To hold file contents\n-            int bytesRead;\n+            byte[] buffer = new byte[4096];\n+            // To hold file contents\n+             int bytesRead;\n             FileOutputStream output = new FileOutputStream(tempFile);\n             while ((bytesRead = fileContents.read(buffer)) != -1) {\n                 output.write(buffer, 0, bytesRead);\n",
            "diff_size": 3
        }
    ],
    "repaired_by": [
        "styler",
        "naturalize",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "intellij",
        "codebuff",
        "styler_random"
    ]
}