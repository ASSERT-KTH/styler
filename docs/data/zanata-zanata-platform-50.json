{
    "project_name": "zanata-zanata-platform",
    "error_id": "50",
    "information": {
        "errors": [
            {
                "line": "204",
                "column": "50",
                "severity": "error",
                "message": "'=' is not preceded with whitespace.",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
            }
        ]
    },
    "source_code": "            DocumentId documentId = new DocumentId(doc.getId(),\n                    doc.getDocId());\n            List<HTextFlow> untranslatedTextFlows=\n                    textFlowDAO\n                            .getAllTextFlowByDocumentIdWithConstraints(\n                                    documentId, targetLocale,",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/50/MachineTranslationServiceImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/styler/50/MachineTranslationServiceImpl.java\nindex 9b86e011a54..4b47ae87185 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/50/MachineTranslationServiceImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/styler/50/MachineTranslationServiceImpl.java\n@@ -201,7 +201,7 @@ public class MachineTranslationServiceImpl implements\n         for (HDocument doc : documents.values()) {\n             DocumentId documentId = new DocumentId(doc.getId(),\n                     doc.getDocId());\n-            List<HTextFlow> untranslatedTextFlows=\n+            List<HTextFlow> untranslatedTextFlows =\n                     textFlowDAO\n                             .getAllTextFlowByDocumentIdWithConstraints(\n                                     documentId, targetLocale,\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/50/MachineTranslationServiceImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/intellij/50/MachineTranslationServiceImpl.java\nindex 9b86e011a54..d9a319839fa 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/50/MachineTranslationServiceImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/intellij/50/MachineTranslationServiceImpl.java\n@@ -18,6 +18,7 @@\n  * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n  * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n  */\n+\n package org.zanata.service.impl;\n \n import java.net.URI;\n@@ -79,218 +80,218 @@ import com.google.common.collect.Maps;\n  */\n @RequestScoped\n public class MachineTranslationServiceImpl implements\n-        MachineTranslationService {\n-    private static final Logger log =\n-            LoggerFactory.getLogger(MachineTranslationServiceImpl.class);\n-\n-    private URI mtServiceURL;\n-    private String mtUser;\n-    private String mtToken;\n-    private TextFlowsToMTDoc textFlowsToMTDoc;\n-    private TextFlowDAO textFlowDAO;\n-    private LocaleService localeService;\n-    private EntityManager entityManager;\n-    private TransactionUtil transactionUtil;\n-    private TranslationService translationService;\n-    private VersionStateCache versionStateCache;\n-\n-    public MachineTranslationServiceImpl() {\n+  MachineTranslationService {\n+  private static final Logger log =\n+    LoggerFactory.getLogger(MachineTranslationServiceImpl.class);\n+\n+  private URI mtServiceURL;\n+  private String mtUser;\n+  private String mtToken;\n+  private TextFlowsToMTDoc textFlowsToMTDoc;\n+  private TextFlowDAO textFlowDAO;\n+  private LocaleService localeService;\n+  private EntityManager entityManager;\n+  private TransactionUtil transactionUtil;\n+  private TranslationService translationService;\n+  private VersionStateCache versionStateCache;\n+\n+  public MachineTranslationServiceImpl() {\n+  }\n+\n+  @Inject\n+  public MachineTranslationServiceImpl(@MTServiceURL URI mtServiceURL,\n+                                       @MTServiceUser String mtUser,\n+                                       @MTServiceToken String mtToken,\n+                                       TextFlowsToMTDoc textFlowsToMTDoc,\n+                                       TextFlowDAO textFlowDAO,\n+                                       LocaleService localeService,\n+                                       EntityManager entityManager,\n+                                       TransactionUtil transactionUtil,\n+                                       TranslationService translationService,\n+                                       VersionStateCache versionStateCache) {\n+    this.mtServiceURL = mtServiceURL;\n+    this.mtUser = mtUser;\n+    this.mtToken = mtToken;\n+    this.textFlowsToMTDoc = textFlowsToMTDoc;\n+    this.textFlowDAO = textFlowDAO;\n+    this.localeService = localeService;\n+    this.entityManager = entityManager;\n+    this.transactionUtil = transactionUtil;\n+    this.translationService = translationService;\n+    this.versionStateCache = versionStateCache;\n+  }\n+\n+  @Override\n+  public List<String> getSuggestion(@Nonnull HTextFlow textFlow,\n+                                    @Nonnull LocaleId fromLocale,\n+                                    @Nonnull LocaleId toLocale) {\n+\n+    HDocument document = textFlow.getDocument();\n+    String docId = document.getDocId();\n+    String versionSlug = document.getProjectIteration().getSlug();\n+    String projectSlug = document.getProjectIteration().getProject().getSlug();\n+\n+    MTDocument doc = textFlowsToMTDoc.fromSingleTextFlow(projectSlug,\n+      versionSlug, docId, fromLocale, textFlow);\n+\n+    try {\n+      MTDocument result = getTranslationFromMT(doc, toLocale);\n+      return result.getContents().stream().map(TypeString::getValue)\n+        .collect(Collectors.toList());\n+    } catch (ZanataServiceException e) {\n+      log.error(\"failed to get translations from machine translation\");\n+      return Collections.emptyList();\n     }\n \n-    @Inject\n-    public MachineTranslationServiceImpl(@MTServiceURL URI mtServiceURL,\n-            @MTServiceUser String mtUser,\n-            @MTServiceToken String mtToken,\n-            TextFlowsToMTDoc textFlowsToMTDoc,\n-            TextFlowDAO textFlowDAO,\n-            LocaleService localeService,\n-            EntityManager entityManager,\n-            TransactionUtil transactionUtil,\n-            TranslationService translationService,\n-            VersionStateCache versionStateCache) {\n-        this.mtServiceURL = mtServiceURL;\n-        this.mtUser = mtUser;\n-        this.mtToken = mtToken;\n-        this.textFlowsToMTDoc = textFlowsToMTDoc;\n-        this.textFlowDAO = textFlowDAO;\n-        this.localeService = localeService;\n-        this.entityManager = entityManager;\n-        this.transactionUtil = transactionUtil;\n-        this.translationService = translationService;\n-        this.versionStateCache = versionStateCache;\n+  }\n+\n+  private MTDocument getTranslationFromMT(MTDocument request,\n+                                          LocaleId toLocale) throws ZanataServiceException {\n+    ResteasyClient client = new ResteasyClientBuilder().build();\n+\n+    ResteasyWebTarget webTarget = client.target(mtServiceURL).path(\"api\")\n+      .path(\"document\").path(\"translate\")\n+      .queryParam(\"toLocaleCode\", toLocale.getId());\n+    Response response = webTarget.request(MediaType.APPLICATION_JSON_TYPE)\n+      .header(\"X-Auth-User\", mtUser)\n+      .header(\"X-Auth-Token\", mtToken)\n+      .header(\"Content-Type\", MediaType.APPLICATION_JSON)\n+      .header(\"Accept\", MediaType.APPLICATION_JSON)\n+      .post(Entity.json(request));\n+\n+    if (response.getStatus() == 200) {\n+      MTDocument result = response.readEntity(MTDocument.class);\n+      if (!result.getWarnings().isEmpty()) {\n+        log.warn(\"Machine translation returns warning: {}\", result.getWarnings());\n+      }\n+      return result;\n+    } else {\n+      log.warn(\"Machine translation return status: {}, header: {}, body: {}\",\n+        response.getStatus(), response.getHeaders(),\n+        response.readEntity(String.class));\n+      throw new ZanataServiceException(\"failed to get translations from machine translation\");\n+    }\n+  }\n+\n+  @Async\n+  @Override\n+  public Future<Void> prefillWithMachineTranslation(\n+    Long versionId, LocaleId targetLocaleId,\n+    @Nonnull MachineTranslationPrefillTaskHandle taskHandle) {\n+    // need to reload all entities\n+    HProjectIteration version = entityManager.find(HProjectIteration.class, versionId);\n+    HLocale targetLocale = localeService.getByLocaleId(targetLocaleId);\n+    Map<String, HDocument> documents = version.getDocuments();\n+    if (documents.isEmpty()) {\n+      log.warn(\"no document in this version {}\", version.userFriendlyToString());\n+      return AsyncTaskResult.completed();\n     }\n \n-    @Override\n-    public List<String> getSuggestion(@Nonnull HTextFlow textFlow,\n-            @Nonnull LocaleId fromLocale,\n-            @Nonnull LocaleId toLocale) {\n+    // TODO this assumes all documents using same source locale\n+    // TODO some document don't have source locale (null)\n+    LocaleId fromLocale =\n+      documents.values().iterator().next().getSourceLocaleId();\n+\n+    Stopwatch overallStopwatch = Stopwatch.createStarted();\n+    Long targetVersionId = version.getId();\n+    String projectSlug = version.getProject().getSlug();\n+    String versionSlug = version.getSlug();\n+\n+    Map<String, List<HTextFlow>> docUrlToTextFlows = Maps.newHashMap();\n+    List<MTDocument> mtDocuments = Lists.newArrayList();\n+    for (HDocument doc : documents.values()) {\n+      DocumentId documentId = new DocumentId(doc.getId(),\n+        doc.getDocId());\n+      List<HTextFlow> untranslatedTextFlows =\n+        textFlowDAO\n+          .getAllTextFlowByDocumentIdWithConstraints(\n+            documentId, targetLocale,\n+            FilterConstraints.builder()\n+              .keepNone().includeNew()\n+              .build());\n+      MTDocument mtDocument = textFlowsToMTDoc\n+        .fromTextFlows(projectSlug, versionSlug,\n+          doc.getDocId(), fromLocale,\n+          untranslatedTextFlows);\n+      docUrlToTextFlows.put(mtDocument.getUrl(), untranslatedTextFlows);\n+      mtDocuments.add(mtDocument);\n+    }\n \n-        HDocument document = textFlow.getDocument();\n-        String docId = document.getDocId();\n-        String versionSlug = document.getProjectIteration().getSlug();\n-        String projectSlug = document.getProjectIteration().getProject().getSlug();\n \n-        MTDocument doc = textFlowsToMTDoc.fromSingleTextFlow(projectSlug,\n-                versionSlug, docId, fromLocale, textFlow);\n+    log.info(\"prepare to send {} of documents to MT\", mtDocuments.size());\n \n-        try {\n-            MTDocument result = getTranslationFromMT(doc, toLocale);\n-            return result.getContents().stream().map(TypeString::getValue)\n-                    .collect(Collectors.toList());\n-        } catch (ZanataServiceException e) {\n-            log.error(\"failed to get translations from machine translation\");\n-            return Collections.emptyList();\n-        }\n+    List<MTDocument> result = mtDocuments.stream()\n+      .map(mtDoc -> getTranslationFromMT(mtDoc,\n+        targetLocale.getLocaleId()))\n+      .collect(Collectors.toList());\n \n-    }\n+    log.info(\"get back result: {}\", result.size());\n \n-    private MTDocument getTranslationFromMT(MTDocument request,\n-            LocaleId toLocale) throws ZanataServiceException {\n-        ResteasyClient client = new ResteasyClientBuilder().build();\n-\n-        ResteasyWebTarget webTarget = client.target(mtServiceURL).path(\"api\")\n-                .path(\"document\").path(\"translate\")\n-                .queryParam(\"toLocaleCode\", toLocale.getId());\n-        Response response = webTarget.request(MediaType.APPLICATION_JSON_TYPE)\n-                .header(\"X-Auth-User\", mtUser)\n-                .header(\"X-Auth-Token\", mtToken)\n-                .header(\"Content-Type\", MediaType.APPLICATION_JSON)\n-                .header(\"Accept\", MediaType.APPLICATION_JSON)\n-                .post(Entity.json(request));\n-\n-        if (response.getStatus() == 200) {\n-            MTDocument result = response.readEntity(MTDocument.class);\n-            if (!result.getWarnings().isEmpty()) {\n-                log.warn(\"Machine translation returns warning: {}\", result.getWarnings());\n-            }\n-            return result;\n-        } else {\n-            log.warn(\"Machine translation return status: {}, header: {}, body: {}\",\n-                    response.getStatus(), response.getHeaders(),\n-                    response.readEntity(String.class));\n-            throw new ZanataServiceException(\"failed to get translations from machine translation\");\n-        }\n-    }\n+    taskHandle.setMaxProgress(mtDocuments.size());\n \n-    @Async\n-    @Override\n-    public Future<Void> prefillWithMachineTranslation(\n-            Long versionId, LocaleId targetLocaleId,\n-            @Nonnull MachineTranslationPrefillTaskHandle taskHandle) {\n-        // need to reload all entities\n-        HProjectIteration version = entityManager.find(HProjectIteration.class, versionId);\n-        HLocale targetLocale = localeService.getByLocaleId(targetLocaleId);\n-        Map<String, HDocument> documents = version.getDocuments();\n-        if (documents.isEmpty()) {\n-            log.warn(\"no document in this version {}\", version.userFriendlyToString());\n-            return AsyncTaskResult.completed();\n-        }\n-\n-        // TODO this assumes all documents using same source locale\n-        // TODO some document don't have source locale (null)\n-        LocaleId fromLocale =\n-                documents.values().iterator().next().getSourceLocaleId();\n-\n-        Stopwatch overallStopwatch = Stopwatch.createStarted();\n-        Long targetVersionId = version.getId();\n-        String projectSlug = version.getProject().getSlug();\n-        String versionSlug = version.getSlug();\n-\n-        Map<String, List<HTextFlow>> docUrlToTextFlows = Maps.newHashMap();\n-        List<MTDocument> mtDocuments = Lists.newArrayList();\n-        for (HDocument doc : documents.values()) {\n-            DocumentId documentId = new DocumentId(doc.getId(),\n-                    doc.getDocId());\n-            List<HTextFlow> untranslatedTextFlows=\n-                    textFlowDAO\n-                            .getAllTextFlowByDocumentIdWithConstraints(\n-                                    documentId, targetLocale,\n-                                    FilterConstraints.builder()\n-                                            .keepNone().includeNew()\n-                                            .build());\n-            MTDocument mtDocument = textFlowsToMTDoc\n-                    .fromTextFlows(projectSlug, versionSlug,\n-                            doc.getDocId(), fromLocale,\n-                            untranslatedTextFlows);\n-            docUrlToTextFlows.put(mtDocument.getUrl(), untranslatedTextFlows);\n-            mtDocuments.add(mtDocument);\n-        }\n-\n-\n-        log.info(\"prepare to send {} of documents to MT\", mtDocuments.size());\n-\n-        List<MTDocument> result = mtDocuments.stream()\n-                .map(mtDoc -> getTranslationFromMT(mtDoc,\n-                        targetLocale.getLocaleId()))\n-                .collect(Collectors.toList());\n-\n-        log.info(\"get back result: {}\", result.size());\n-\n-        taskHandle.setMaxProgress(mtDocuments.size());\n-\n-\n-        boolean cancelled = false;\n-        for (int i = 0; i < mtDocuments.size() && !(cancelled = taskHandle.isCancelled()); i++) {\n-            MTDocument sourceDoc = mtDocuments.get(i);\n-            MTDocument transDoc = result.get(i);\n-\n-            translateInBatch(docUrlToTextFlows.get(sourceDoc.getUrl()), transDoc,\n-                    targetLocale);\n-\n-            taskHandle.increaseProgress(1);\n-        }\n-        versionStateCache.clearVersionStatsCache(targetVersionId);\n-\n-        log.info(\"{} prefill translation with machine translations for version {}, {}\",\n-                cancelled ? \"CANCELLED\" : \"COMPLETED\",\n-                version.userFriendlyToString(), overallStopwatch);\n-        return AsyncTaskResult.completed();\n-    }\n \n-    private void translateInBatch(List<HTextFlow> textFlows,\n-            MTDocument transDoc,\n-            HLocale targetLocale) {\n-        int index = 0;\n-        while (index < textFlows.size()) {\n-            int bound = Math.min(index + BATCH_SIZE, textFlows.size());\n-            List<HTextFlow> batch = textFlows.subList(index, bound);\n-            List<TypeString> transContentBatch =\n-                    transDoc.getContents().subList(index, bound);\n-\n-            List<TransUnitUpdateRequest> updateRequests = Lists.newArrayList();\n-            index += bound;\n-            for (int i = 0; i < batch.size(); i++) {\n-                HTextFlow textFlow = batch.get(i);\n-                HTextFlowTarget maybeTarget =\n-                        textFlow.getTargets().get(targetLocale.getId());\n-                int baseRevision = maybeTarget == null ? 0 : maybeTarget.getVersionNum();\n-                List<String> translation = Lists.newArrayList(\n-                        transContentBatch.get(i).getValue());\n-                // TODO saved state should be configurable from UI\n-                // TODO TranslationSourceType only says MT but without provider name\n-                TransUnitUpdateRequest updateRequest =\n-                        new TransUnitUpdateRequest(\n-                                new TransUnitId(textFlow.getId()),\n-                                translation, ContentState.NeedReview,\n-                                baseRevision,\n-                                TranslationSourceType.MACHINE_TRANS\n-                                        .getAbbr());\n-                updateRequest.addRevisionComment(\"Translated by Google\");\n-                updateRequests.add(updateRequest);\n-            }\n-            try {\n-                transactionUtil.run(() -> {\n-                    translationService.translate(targetLocale.getLocaleId(), updateRequests);\n-                });\n-            } catch (Exception e) {\n-                log.error(\"error prefilling translation with machine translation\", e);\n-            }\n-        }\n-    }\n+    boolean cancelled = false;\n+    for (int i = 0; i < mtDocuments.size() && !(cancelled = taskHandle.isCancelled()); i++) {\n+      MTDocument sourceDoc = mtDocuments.get(i);\n+      MTDocument transDoc = result.get(i);\n+\n+      translateInBatch(docUrlToTextFlows.get(sourceDoc.getUrl()), transDoc,\n+        targetLocale);\n \n-    private boolean shouldTranslate(ContentState contentState) {\n-        // right now we only target untranslated. We might target more in the future\n-        return contentState.isUntranslated();\n+      taskHandle.increaseProgress(1);\n     }\n+    versionStateCache.clearVersionStatsCache(targetVersionId);\n+\n+    log.info(\"{} prefill translation with machine translations for version {}, {}\",\n+      cancelled ? \"CANCELLED\" : \"COMPLETED\",\n+      version.userFriendlyToString(), overallStopwatch);\n+    return AsyncTaskResult.completed();\n+  }\n+\n+  private void translateInBatch(List<HTextFlow> textFlows,\n+                                MTDocument transDoc,\n+                                HLocale targetLocale) {\n+    int index = 0;\n+    while (index < textFlows.size()) {\n+      int bound = Math.min(index + BATCH_SIZE, textFlows.size());\n+      List<HTextFlow> batch = textFlows.subList(index, bound);\n+      List<TypeString> transContentBatch =\n+        transDoc.getContents().subList(index, bound);\n+\n+      List<TransUnitUpdateRequest> updateRequests = Lists.newArrayList();\n+      index += bound;\n+      for (int i = 0; i < batch.size(); i++) {\n+        HTextFlow textFlow = batch.get(i);\n+        HTextFlowTarget maybeTarget =\n+          textFlow.getTargets().get(targetLocale.getId());\n+        int baseRevision = maybeTarget == null ? 0 : maybeTarget.getVersionNum();\n+        List<String> translation = Lists.newArrayList(\n+          transContentBatch.get(i).getValue());\n+        // TODO saved state should be configurable from UI\n+        // TODO TranslationSourceType only says MT but without provider name\n+        TransUnitUpdateRequest updateRequest =\n+          new TransUnitUpdateRequest(\n+            new TransUnitId(textFlow.getId()),\n+            translation, ContentState.NeedReview,\n+            baseRevision,\n+            TranslationSourceType.MACHINE_TRANS\n+              .getAbbr());\n+        updateRequest.addRevisionComment(\"Translated by Google\");\n+        updateRequests.add(updateRequest);\n+      }\n+      try {\n+        transactionUtil.run(() -> {\n+          translationService.translate(targetLocale.getLocaleId(), updateRequests);\n+        });\n+      } catch (Exception e) {\n+        log.error(\"error prefilling translation with machine translation\", e);\n+      }\n+    }\n+  }\n+\n+  private boolean shouldTranslate(ContentState contentState) {\n+    // right now we only target untranslated. We might target more in the future\n+    return contentState.isUntranslated();\n+  }\n \n }\n",
            "diff_size": 345
        },
        {
            "tool": "naturalize",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/50/MachineTranslationServiceImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/naturalize/50/MachineTranslationServiceImpl.java\nindex 9b86e011a54..758ff09c497 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/50/MachineTranslationServiceImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/naturalize/50/MachineTranslationServiceImpl.java\n@@ -201,23 +201,21 @@ public class MachineTranslationServiceImpl implements\n         for (HDocument doc : documents.values()) {\n             DocumentId documentId = new DocumentId(doc.getId(),\n                     doc.getDocId());\n-            List<HTextFlow> untranslatedTextFlows=\n+            List<HTextFlow> untranslatedTextFlows =\n                     textFlowDAO\n                             .getAllTextFlowByDocumentIdWithConstraints(\n                                     documentId, targetLocale,\n                                     FilterConstraints.builder()\n                                             .keepNone().includeNew()\n                                             .build());\n-            MTDocument mtDocument = textFlowsToMTDoc\n+MTDocument mtDocument = textFlowsToMTDoc\n                     .fromTextFlows(projectSlug, versionSlug,\n                             doc.getDocId(), fromLocale,\n                             untranslatedTextFlows);\n             docUrlToTextFlows.put(mtDocument.getUrl(), untranslatedTextFlows);\n             mtDocuments.add(mtDocument);\n         }\n-\n-\n-        log.info(\"prepare to send {} of documents to MT\", mtDocuments.size());\n+log.info(\"prepare to send {} of documents to MT\", mtDocuments.size());\n \n         List<MTDocument> result = mtDocuments.stream()\n                 .map(mtDoc -> getTranslationFromMT(mtDoc,\n@@ -227,9 +225,7 @@ public class MachineTranslationServiceImpl implements\n         log.info(\"get back result: {}\", result.size());\n \n         taskHandle.setMaxProgress(mtDocuments.size());\n-\n-\n-        boolean cancelled = false;\n+boolean cancelled = false;\n         for (int i = 0; i < mtDocuments.size() && !(cancelled = taskHandle.isCancelled()); i++) {\n             MTDocument sourceDoc = mtDocuments.get(i);\n             MTDocument transDoc = result.get(i);\n@@ -293,4 +289,4 @@ public class MachineTranslationServiceImpl implements\n         return contentState.isUntranslated();\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 9
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/50/MachineTranslationServiceImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/codebuff/50/MachineTranslationServiceImpl.java\nindex 9b86e011a54..497ff3287fd 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/50/MachineTranslationServiceImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/codebuff/50/MachineTranslationServiceImpl.java\n@@ -26,7 +26,6 @@ import java.util.List;\n import java.util.Map;\n import java.util.concurrent.Future;\n import java.util.stream.Collectors;\n-\n import javax.annotation.Nonnull;\n import javax.enterprise.context.RequestScoped;\n import javax.inject.Inject;\n@@ -34,7 +33,6 @@ import javax.persistence.EntityManager;\n import javax.ws.rs.client.Entity;\n import javax.ws.rs.core.MediaType;\n import javax.ws.rs.core.Response;\n-\n import org.jboss.resteasy.client.jaxrs.ResteasyClient;\n import org.jboss.resteasy.client.jaxrs.ResteasyClientBuilder;\n import org.jboss.resteasy.client.jaxrs.ResteasyWebTarget;\n@@ -68,7 +66,6 @@ import org.zanata.webtrans.shared.model.DocumentId;\n import org.zanata.webtrans.shared.model.TransUnitId;\n import org.zanata.webtrans.shared.model.TransUnitUpdateRequest;\n import org.zanata.webtrans.shared.search.FilterConstraints;\n-\n import com.google.common.base.Stopwatch;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n@@ -77,12 +74,11 @@ import com.google.common.collect.Maps;\n  * @author Patrick Huang\n  * <a href=\"mailto:pahuang@redhat.com\">pahuang@redhat.com</a>\n  */\n-@RequestScoped\n-public class MachineTranslationServiceImpl implements\n-        MachineTranslationService {\n-    private static final Logger log =\n-            LoggerFactory.getLogger(MachineTranslationServiceImpl.class);\n \n+\n+@RequestScoped\n+public class MachineTranslationServiceImpl implements MachineTranslationService {\n+    private static final Logger log = LoggerFactory.getLogger(MachineTranslationServiceImpl.class);\n     private URI mtServiceURL;\n     private String mtUser;\n     private String mtToken;\n@@ -99,15 +95,14 @@ public class MachineTranslationServiceImpl implements\n \n     @Inject\n     public MachineTranslationServiceImpl(@MTServiceURL URI mtServiceURL,\n-            @MTServiceUser String mtUser,\n+        @MTServiceUser String mtUser,\n             @MTServiceToken String mtToken,\n-            TextFlowsToMTDoc textFlowsToMTDoc,\n-            TextFlowDAO textFlowDAO,\n-            LocaleService localeService,\n-            EntityManager entityManager,\n-            TransactionUtil transactionUtil,\n-            TranslationService translationService,\n-            VersionStateCache versionStateCache) {\n+        TextFlowsToMTDoc textFlowsToMTDoc,\n+        TextFlowDAO textFlowDAO,\n+        LocaleService localeService,\n+        EntityManager entityManager,\n+        TransactionUtil transactionUtil,\n+        TranslationService translationService, VersionStateCache versionStateCache) {\n         this.mtServiceURL = mtServiceURL;\n         this.mtUser = mtUser;\n         this.mtToken = mtToken;\n@@ -121,43 +116,27 @@ public class MachineTranslationServiceImpl implements\n     }\n \n     @Override\n-    public List<String> getSuggestion(@Nonnull HTextFlow textFlow,\n-            @Nonnull LocaleId fromLocale,\n-            @Nonnull LocaleId toLocale) {\n-\n+    public List<String> getSuggestion(\n+        @Nonnull HTextFlow textFlow, @Nonnull LocaleId fromLocale,\n+        @Nonnull LocaleId toLocale) {\n         HDocument document = textFlow.getDocument();\n         String docId = document.getDocId();\n         String versionSlug = document.getProjectIteration().getSlug();\n         String projectSlug = document.getProjectIteration().getProject().getSlug();\n-\n-        MTDocument doc = textFlowsToMTDoc.fromSingleTextFlow(projectSlug,\n-                versionSlug, docId, fromLocale, textFlow);\n-\n+        MTDocument doc = textFlowsToMTDoc.fromSingleTextFlow(projectSlug, versionSlug, docId, fromLocale, textFlow);\n         try {\n             MTDocument result = getTranslationFromMT(doc, toLocale);\n-            return result.getContents().stream().map(TypeString::getValue)\n-                    .collect(Collectors.toList());\n+            return result.getContents().stream().map(TypeString::getValue).collect(Collectors.toList());\n         } catch (ZanataServiceException e) {\n             log.error(\"failed to get translations from machine translation\");\n             return Collections.emptyList();\n         }\n-\n     }\n \n-    private MTDocument getTranslationFromMT(MTDocument request,\n-            LocaleId toLocale) throws ZanataServiceException {\n+    private MTDocument getTranslationFromMT(MTDocument request, LocaleId toLocale) throws ZanataServiceException {\n         ResteasyClient client = new ResteasyClientBuilder().build();\n-\n-        ResteasyWebTarget webTarget = client.target(mtServiceURL).path(\"api\")\n-                .path(\"document\").path(\"translate\")\n-                .queryParam(\"toLocaleCode\", toLocale.getId());\n-        Response response = webTarget.request(MediaType.APPLICATION_JSON_TYPE)\n-                .header(\"X-Auth-User\", mtUser)\n-                .header(\"X-Auth-Token\", mtToken)\n-                .header(\"Content-Type\", MediaType.APPLICATION_JSON)\n-                .header(\"Accept\", MediaType.APPLICATION_JSON)\n-                .post(Entity.json(request));\n-\n+        ResteasyWebTarget webTarget = client.target(mtServiceURL).path(\"api\").path(\"document\").path(\"translate\").queryParam(\"toLocaleCode\", toLocale.getId());\n+        Response response = webTarget.request(MediaType.APPLICATION_JSON_TYPE).header(\"X-Auth-User\", mtUser).header(\"X-Auth-Token\", mtToken).header(\"Content-Type\", MediaType.APPLICATION_JSON).header(\"Accept\", MediaType.APPLICATION_JSON).post(Entity.json(request));\n         if (response.getStatus() == 200) {\n             MTDocument result = response.readEntity(MTDocument.class);\n             if (!result.getWarnings().isEmpty()) {\n@@ -165,18 +144,15 @@ public class MachineTranslationServiceImpl implements\n             }\n             return result;\n         } else {\n-            log.warn(\"Machine translation return status: {}, header: {}, body: {}\",\n-                    response.getStatus(), response.getHeaders(),\n-                    response.readEntity(String.class));\n+            log.warn(\"Machine translation return status: {}, header: {}, body: {}\", response.getStatus(), response.getHeaders(), response.readEntity(String.class));\n             throw new ZanataServiceException(\"failed to get translations from machine translation\");\n         }\n     }\n \n     @Async\n     @Override\n-    public Future<Void> prefillWithMachineTranslation(\n-            Long versionId, LocaleId targetLocaleId,\n-            @Nonnull MachineTranslationPrefillTaskHandle taskHandle) {\n+    public Future<Void> prefillWithMachineTranslation(Long versionId, LocaleId targetLocaleId,\n+                                                      @Nonnull MachineTranslationPrefillTaskHandle taskHandle) {\n         // need to reload all entities\n         HProjectIteration version = entityManager.find(HProjectIteration.class, versionId);\n         HLocale targetLocale = localeService.getByLocaleId(targetLocaleId);\n@@ -188,93 +164,52 @@ public class MachineTranslationServiceImpl implements\n \n         // TODO this assumes all documents using same source locale\n         // TODO some document don't have source locale (null)\n-        LocaleId fromLocale =\n-                documents.values().iterator().next().getSourceLocaleId();\n-\n+        LocaleId fromLocale = documents.values().iterator().next().getSourceLocaleId();\n         Stopwatch overallStopwatch = Stopwatch.createStarted();\n         Long targetVersionId = version.getId();\n         String projectSlug = version.getProject().getSlug();\n         String versionSlug = version.getSlug();\n-\n         Map<String, List<HTextFlow>> docUrlToTextFlows = Maps.newHashMap();\n         List<MTDocument> mtDocuments = Lists.newArrayList();\n         for (HDocument doc : documents.values()) {\n-            DocumentId documentId = new DocumentId(doc.getId(),\n-                    doc.getDocId());\n-            List<HTextFlow> untranslatedTextFlows=\n-                    textFlowDAO\n-                            .getAllTextFlowByDocumentIdWithConstraints(\n-                                    documentId, targetLocale,\n-                                    FilterConstraints.builder()\n-                                            .keepNone().includeNew()\n-                                            .build());\n-            MTDocument mtDocument = textFlowsToMTDoc\n-                    .fromTextFlows(projectSlug, versionSlug,\n-                            doc.getDocId(), fromLocale,\n-                            untranslatedTextFlows);\n+            DocumentId documentId = new DocumentId(doc.getId(), doc.getDocId());\n+            List<HTextFlow> untranslatedTextFlows = textFlowDAO.getAllTextFlowByDocumentIdWithConstraints(documentId, targetLocale, FilterConstraints.builder().keepNone().includeNew().build());\n+            MTDocument mtDocument = textFlowsToMTDoc.fromTextFlows(projectSlug, versionSlug, doc.getDocId(), fromLocale, untranslatedTextFlows);\n             docUrlToTextFlows.put(mtDocument.getUrl(), untranslatedTextFlows);\n             mtDocuments.add(mtDocument);\n         }\n-\n-\n         log.info(\"prepare to send {} of documents to MT\", mtDocuments.size());\n-\n-        List<MTDocument> result = mtDocuments.stream()\n-                .map(mtDoc -> getTranslationFromMT(mtDoc,\n-                        targetLocale.getLocaleId()))\n-                .collect(Collectors.toList());\n-\n+        List<MTDocument> result = mtDocuments.stream().map(mtDoc -> getTranslationFromMT(mtDoc, targetLocale.getLocaleId())).collect(Collectors.toList());\n         log.info(\"get back result: {}\", result.size());\n-\n         taskHandle.setMaxProgress(mtDocuments.size());\n-\n-\n         boolean cancelled = false;\n         for (int i = 0; i < mtDocuments.size() && !(cancelled = taskHandle.isCancelled()); i++) {\n             MTDocument sourceDoc = mtDocuments.get(i);\n             MTDocument transDoc = result.get(i);\n-\n-            translateInBatch(docUrlToTextFlows.get(sourceDoc.getUrl()), transDoc,\n-                    targetLocale);\n-\n+            translateInBatch(docUrlToTextFlows.get(sourceDoc.getUrl()), transDoc, targetLocale);\n             taskHandle.increaseProgress(1);\n         }\n         versionStateCache.clearVersionStatsCache(targetVersionId);\n-\n-        log.info(\"{} prefill translation with machine translations for version {}, {}\",\n-                cancelled ? \"CANCELLED\" : \"COMPLETED\",\n-                version.userFriendlyToString(), overallStopwatch);\n+        log.info(\"{} prefill translation with machine translations for version {}, {}\", cancelled ? \"CANCELLED\" : \"COMPLETED\", version.userFriendlyToString(), overallStopwatch);\n         return AsyncTaskResult.completed();\n     }\n \n-    private void translateInBatch(List<HTextFlow> textFlows,\n-            MTDocument transDoc,\n-            HLocale targetLocale) {\n+    private void translateInBatch(List<HTextFlow> textFlows, MTDocument transDoc, HLocale targetLocale) {\n         int index = 0;\n         while (index < textFlows.size()) {\n             int bound = Math.min(index + BATCH_SIZE, textFlows.size());\n             List<HTextFlow> batch = textFlows.subList(index, bound);\n-            List<TypeString> transContentBatch =\n-                    transDoc.getContents().subList(index, bound);\n-\n+            List<TypeString> transContentBatch = transDoc.getContents().subList(index, bound);\n             List<TransUnitUpdateRequest> updateRequests = Lists.newArrayList();\n             index += bound;\n             for (int i = 0; i < batch.size(); i++) {\n                 HTextFlow textFlow = batch.get(i);\n-                HTextFlowTarget maybeTarget =\n-                        textFlow.getTargets().get(targetLocale.getId());\n+                HTextFlowTarget maybeTarget = textFlow.getTargets().get(targetLocale.getId());\n                 int baseRevision = maybeTarget == null ? 0 : maybeTarget.getVersionNum();\n-                List<String> translation = Lists.newArrayList(\n-                        transContentBatch.get(i).getValue());\n+                List<String> translation = Lists.newArrayList(transContentBatch.get(i).getValue());\n                 // TODO saved state should be configurable from UI\n                 // TODO TranslationSourceType only says MT but without provider name\n-                TransUnitUpdateRequest updateRequest =\n-                        new TransUnitUpdateRequest(\n-                                new TransUnitId(textFlow.getId()),\n-                                translation, ContentState.NeedReview,\n-                                baseRevision,\n-                                TranslationSourceType.MACHINE_TRANS\n-                                        .getAbbr());\n+                TransUnitUpdateRequest updateRequest = new TransUnitUpdateRequest(new TransUnitId(textFlow.getId()), translation, ContentState.NeedReview, baseRevision, TranslationSourceType.MACHINE_TRANS.getAbbr());\n                 updateRequest.addRevisionComment(\"Translated by Google\");\n                 updateRequests.add(updateRequest);\n             }\n@@ -292,5 +227,4 @@ public class MachineTranslationServiceImpl implements\n         // right now we only target untranslated. We might target more in the future\n         return contentState.isUntranslated();\n     }\n-\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 105
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/50/MachineTranslationServiceImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/styler_random/50/MachineTranslationServiceImpl.java\nindex 9b86e011a54..4b47ae87185 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/50/MachineTranslationServiceImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/styler_random/50/MachineTranslationServiceImpl.java\n@@ -201,7 +201,7 @@ public class MachineTranslationServiceImpl implements\n         for (HDocument doc : documents.values()) {\n             DocumentId documentId = new DocumentId(doc.getId(),\n                     doc.getDocId());\n-            List<HTextFlow> untranslatedTextFlows=\n+            List<HTextFlow> untranslatedTextFlows =\n                     textFlowDAO\n                             .getAllTextFlowByDocumentIdWithConstraints(\n                                     documentId, targetLocale,\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/50/MachineTranslationServiceImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/styler_three_grams/50/MachineTranslationServiceImpl.java\nindex 9b86e011a54..4b47ae87185 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/50/MachineTranslationServiceImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/styler_three_grams/50/MachineTranslationServiceImpl.java\n@@ -201,7 +201,7 @@ public class MachineTranslationServiceImpl implements\n         for (HDocument doc : documents.values()) {\n             DocumentId documentId = new DocumentId(doc.getId(),\n                     doc.getDocId());\n-            List<HTextFlow> untranslatedTextFlows=\n+            List<HTextFlow> untranslatedTextFlows =\n                     textFlowDAO\n                             .getAllTextFlowByDocumentIdWithConstraints(\n                                     documentId, targetLocale,\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": []
}