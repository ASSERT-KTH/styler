{
    "project_name": "codefollower-H2-Research",
    "error_id": "215",
    "information": {
        "errors": [
            {
                "line": "373",
                "column": "36",
                "severity": "warning",
                "message": "Don't use trailing comments.",
                "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
            }
        ]
    },
    "source_code": "                int mapId = (Integer) op[0];\n                MVMap<Object, VersionedValue> map = openMap(mapId);\n                if (map != null) { // might be null if map was removed later\n                    Object key = op[1];\n                    VersionedValue value = map.get(key);\n                    if (value != null) {",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/215/TransactionStore.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler/215/TransactionStore.java\nindex 5e45c92e007..cfa16ca3277 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/215/TransactionStore.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler/215/TransactionStore.java\n@@ -370,8 +370,9 @@ public class TransactionStore {\n                 }\n                 int mapId = (Integer) op[0];\n                 MVMap<Object, VersionedValue> map = openMap(mapId);\n-                if (map != null) { // might be null if map was removed later\n-                    Object key = op[1];\n+                if (map != null) {\n+                    // might be null if map was removed later\n+                Object key = op[1];\n                     VersionedValue value = map.get(key);\n                     if (value != null) {\n                         // only commit (remove/update) value if we've reached\n",
            "diff_size": 3
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "375",
                    "column": "28",
                    "severity": "warning",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/215/TransactionStore.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/215/TransactionStore.java\nindex 5e45c92e007..bba68c8e828 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/215/TransactionStore.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/215/TransactionStore.java\n@@ -3,6 +3,7 @@\n  * and the EPL 1.0 (http://h2database.com/html/license.html).\n  * Initial Developer: H2 Group\n  */\n+\n package org.h2.mvstore.tx;\n \n import java.nio.ByteBuffer;\n@@ -12,6 +13,7 @@ import java.util.HashMap;\n import java.util.Iterator;\n import java.util.List;\n import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n import org.h2.mvstore.DataUtils;\n import org.h2.mvstore.MVMap;\n import org.h2.mvstore.MVStore;\n@@ -25,714 +27,714 @@ import org.h2.util.New;\n  */\n public class TransactionStore {\n \n-    /**\n-     * The store.\n-     */\n-    final MVStore store;\n-\n-    /**\n-     * The persisted map of prepared transactions.\n-     * Key: transactionId, value: [ status, name ].\n-     */\n-    final MVMap<Integer, Object[]> preparedTransactions;\n-\n-    /**\n-     * The undo log.\n-     * <p>\n-     * If the first entry for a transaction doesn't have a logId\n-     * of 0, then the transaction is partially committed (which means rollback\n-     * is not possible). Log entries are written before the data is changed\n-     * (write-ahead).\n-     * <p>\n-     * Key: opId, value: [ mapId, key, oldValue ].\n-     */\n-    final MVMap<Long, Object[]> undoLog;\n-\n-    /**\n-     * the reader/writer lock for the undo-log. Allows us to process multiple\n-     * selects in parallel.\n-     */\n-    final ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();\n-\n-    /**\n-     * The map of maps.\n-     */\n-    private final HashMap<Integer, MVMap<Object, VersionedValue>> maps =\n-            new HashMap<>();\n-\n-    private final DataType dataType;\n-\n-    private final BitSet openTransactions = new BitSet();\n-\n-    private boolean init;\n-\n-    private int maxTransactionId = 0xffff;\n-\n-    /**\n-     * The next id of a temporary map.\n-     */\n-    private int nextTempMapId;\n-\n-    /**\n-     * Create a new transaction store.\n-     *\n-     * @param store the store\n-     */\n-    public TransactionStore(MVStore store) {\n-        this(store, new ObjectDataType());\n+  /**\n+   * The store.\n+   */\n+  final MVStore store;\n+\n+  /**\n+   * The persisted map of prepared transactions.\n+   * Key: transactionId, value: [ status, name ].\n+   */\n+  final MVMap<Integer, Object[]> preparedTransactions;\n+\n+  /**\n+   * The undo log.\n+   * <p>\n+   * If the first entry for a transaction doesn't have a logId\n+   * of 0, then the transaction is partially committed (which means rollback\n+   * is not possible). Log entries are written before the data is changed\n+   * (write-ahead).\n+   * <p>\n+   * Key: opId, value: [ mapId, key, oldValue ].\n+   */\n+  final MVMap<Long, Object[]> undoLog;\n+\n+  /**\n+   * the reader/writer lock for the undo-log. Allows us to process multiple\n+   * selects in parallel.\n+   */\n+  final ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();\n+\n+  /**\n+   * The map of maps.\n+   */\n+  private final HashMap<Integer, MVMap<Object, VersionedValue>> maps =\n+      new HashMap<>();\n+\n+  private final DataType dataType;\n+\n+  private final BitSet openTransactions = new BitSet();\n+\n+  private boolean init;\n+\n+  private int maxTransactionId = 0xffff;\n+\n+  /**\n+   * The next id of a temporary map.\n+   */\n+  private int nextTempMapId;\n+\n+  /**\n+   * Create a new transaction store.\n+   *\n+   * @param store the store\n+   */\n+  public TransactionStore(MVStore store) {\n+    this(store, new ObjectDataType());\n+  }\n+\n+  /**\n+   * Create a new transaction store.\n+   *\n+   * @param store    the store\n+   * @param dataType the data type for map keys and values\n+   */\n+  public TransactionStore(MVStore store, DataType dataType) {\n+    this.store = store;\n+    this.dataType = dataType;\n+    preparedTransactions = store.openMap(\"openTransactions\",\n+        new MVMap.Builder<Integer, Object[]>());\n+    DataType oldValueType = new VersionedValue.Type(dataType);\n+    ArrayType undoLogValueType = new ArrayType(new DataType[] {\n+        new ObjectDataType(), dataType, oldValueType\n+    });\n+    MVMap.Builder<Long, Object[]> builder =\n+        new MVMap.Builder<Long, Object[]>().\n+            valueType(undoLogValueType);\n+    undoLog = store.openMap(\"undoLog\", builder);\n+    if (undoLog.getValueType() != undoLogValueType) {\n+      throw DataUtils.newIllegalStateException(\n+          DataUtils.ERROR_TRANSACTION_CORRUPT,\n+          \"Undo map open with a different value type\");\n     }\n-\n-    /**\n-     * Create a new transaction store.\n-     *\n-     * @param store the store\n-     * @param dataType the data type for map keys and values\n-     */\n-    public TransactionStore(MVStore store, DataType dataType) {\n-        this.store = store;\n-        this.dataType = dataType;\n-        preparedTransactions = store.openMap(\"openTransactions\",\n-                new MVMap.Builder<Integer, Object[]>());\n-        DataType oldValueType = new VersionedValue.Type(dataType);\n-        ArrayType undoLogValueType = new ArrayType(new DataType[]{\n-                new ObjectDataType(), dataType, oldValueType\n-        });\n-        MVMap.Builder<Long, Object[]> builder =\n-                new MVMap.Builder<Long, Object[]>().\n-                valueType(undoLogValueType);\n-        undoLog = store.openMap(\"undoLog\", builder);\n-        if (undoLog.getValueType() != undoLogValueType) {\n-            throw DataUtils.newIllegalStateException(\n-                    DataUtils.ERROR_TRANSACTION_CORRUPT,\n-                    \"Undo map open with a different value type\");\n-        }\n+  }\n+\n+  /**\n+   * Initialize the store. This is needed before a transaction can be opened.\n+   * If the transaction store is corrupt, this method can throw an exception,\n+   * in which case the store can only be used for reading.\n+   */\n+  public synchronized void init() {\n+    init = true;\n+    // remove all temporary maps\n+    for (String mapName : store.getMapNames()) {\n+      if (mapName.startsWith(\"temp.\")) {\n+        MVMap<Object, Integer> temp = openTempMap(mapName);\n+        store.removeMap(temp);\n+      }\n     }\n-\n-    /**\n-     * Initialize the store. This is needed before a transaction can be opened.\n-     * If the transaction store is corrupt, this method can throw an exception,\n-     * in which case the store can only be used for reading.\n-     */\n-    public synchronized void init() {\n-        init = true;\n-        // remove all temporary maps\n-        for (String mapName : store.getMapNames()) {\n-            if (mapName.startsWith(\"temp.\")) {\n-                MVMap<Object, Integer> temp = openTempMap(mapName);\n-                store.removeMap(temp);\n-            }\n-        }\n-        rwLock.writeLock().lock();\n-        try {\n-            if (undoLog.size() > 0) {\n-                for (Long key : undoLog.keySet()) {\n-                    int transactionId = getTransactionId(key);\n-                    openTransactions.set(transactionId);\n-                }\n-            }\n-        } finally {\n-            rwLock.writeLock().unlock();\n+    rwLock.writeLock().lock();\n+    try {\n+      if (undoLog.size() > 0) {\n+        for (Long key : undoLog.keySet()) {\n+          int transactionId = getTransactionId(key);\n+          openTransactions.set(transactionId);\n         }\n+      }\n+    } finally {\n+      rwLock.writeLock().unlock();\n     }\n-\n-    /**\n-     * Set the maximum transaction id, after which ids are re-used. If the old\n-     * transaction is still in use when re-using an old id, the new transaction\n-     * fails.\n-     *\n-     * @param max the maximum id\n-     */\n-    public void setMaxTransactionId(int max) {\n-        this.maxTransactionId = max;\n-    }\n-\n-    /**\n-     * Check whether a given map exists.\n-     *\n-     * @param name the map name\n-     * @return true if it exists\n-     */\n-    public boolean hasMap(String name) {\n-        return store.hasMap(name);\n+  }\n+\n+  /**\n+   * Set the maximum transaction id, after which ids are re-used. If the old\n+   * transaction is still in use when re-using an old id, the new transaction\n+   * fails.\n+   *\n+   * @param max the maximum id\n+   */\n+  public void setMaxTransactionId(int max) {\n+    this.maxTransactionId = max;\n+  }\n+\n+  /**\n+   * Check whether a given map exists.\n+   *\n+   * @param name the map name\n+   * @return true if it exists\n+   */\n+  public boolean hasMap(String name) {\n+    return store.hasMap(name);\n+  }\n+\n+  /**\n+   * Combine the transaction id and the log id to an operation id.\n+   *\n+   * @param transactionId the transaction id\n+   * @param logId         the log id\n+   * @return the operation id\n+   */\n+  static long getOperationId(int transactionId, long logId) {\n+    DataUtils.checkArgument(transactionId >= 0 && transactionId < (1 << 24),\n+        \"Transaction id out of range: {0}\", transactionId);\n+    DataUtils.checkArgument(logId >= 0 && logId < (1L << 40),\n+        \"Transaction log id out of range: {0}\", logId);\n+    return ((long) transactionId << 40) | logId;\n+  }\n+\n+  /**\n+   * Get the transaction id for the given operation id.\n+   *\n+   * @param operationId the operation id\n+   * @return the transaction id\n+   */\n+  static int getTransactionId(long operationId) {\n+    return (int) (operationId >>> 40);\n+  }\n+\n+  /**\n+   * Get the log id for the given operation id.\n+   *\n+   * @param operationId the operation id\n+   * @return the log id\n+   */\n+  static long getLogId(long operationId) {\n+    return operationId & ((1L << 40) - 1);\n+  }\n+\n+  /**\n+   * Get the list of unclosed transactions that have pending writes.\n+   *\n+   * @return the list of transactions (sorted by id)\n+   */\n+  public List<Transaction> getOpenTransactions() {\n+    rwLock.readLock().lock();\n+    try {\n+      ArrayList<Transaction> list = New.arrayList();\n+      Long key = undoLog.firstKey();\n+      while (key != null) {\n+        int transactionId = getTransactionId(key);\n+        key = undoLog.lowerKey(getOperationId(transactionId + 1, 0));\n+        long logId = getLogId(key) + 1;\n+        Object[] data = preparedTransactions.get(transactionId);\n+        int status;\n+        String name;\n+        if (data == null) {\n+          if (undoLog.containsKey(getOperationId(transactionId, 0))) {\n+            status = Transaction.STATUS_OPEN;\n+          } else {\n+            status = Transaction.STATUS_COMMITTING;\n+          }\n+          name = null;\n+        } else {\n+          status = (Integer) data[0];\n+          name = (String) data[1];\n+        }\n+        Transaction t = new Transaction(this, transactionId, status,\n+            name, logId);\n+        list.add(t);\n+        key = undoLog.ceilingKey(getOperationId(transactionId + 1, 0));\n+      }\n+      return list;\n+    } finally {\n+      rwLock.readLock().unlock();\n     }\n-\n-    /**\n-     * Combine the transaction id and the log id to an operation id.\n-     *\n-     * @param transactionId the transaction id\n-     * @param logId the log id\n-     * @return the operation id\n-     */\n-    static long getOperationId(int transactionId, long logId) {\n-        DataUtils.checkArgument(transactionId >= 0 && transactionId < (1 << 24),\n-                \"Transaction id out of range: {0}\", transactionId);\n-        DataUtils.checkArgument(logId >= 0 && logId < (1L << 40),\n-                \"Transaction log id out of range: {0}\", logId);\n-        return ((long) transactionId << 40) | logId;\n+  }\n+\n+  /**\n+   * Close the transaction store.\n+   */\n+  public synchronized void close() {\n+    store.commit();\n+  }\n+\n+  /**\n+   * Begin a new transaction.\n+   *\n+   * @return the transaction\n+   */\n+  public synchronized Transaction begin() {\n+\n+    int transactionId;\n+    int status;\n+    if (!init) {\n+      throw DataUtils.newIllegalStateException(\n+          DataUtils.ERROR_TRANSACTION_ILLEGAL_STATE,\n+          \"Not initialized\");\n     }\n-\n-    /**\n-     * Get the transaction id for the given operation id.\n-     *\n-     * @param operationId the operation id\n-     * @return the transaction id\n-     */\n-    static int getTransactionId(long operationId) {\n-        return (int) (operationId >>> 40);\n+    transactionId = openTransactions.nextClearBit(1);\n+    if (transactionId > maxTransactionId) {\n+      throw DataUtils.newIllegalStateException(\n+          DataUtils.ERROR_TOO_MANY_OPEN_TRANSACTIONS,\n+          \"There are {0} open transactions\",\n+          transactionId - 1);\n     }\n-\n-    /**\n-     * Get the log id for the given operation id.\n-     *\n-     * @param operationId the operation id\n-     * @return the log id\n-     */\n-    static long getLogId(long operationId) {\n-        return operationId & ((1L << 40) - 1);\n+    openTransactions.set(transactionId);\n+    status = Transaction.STATUS_OPEN;\n+    return new Transaction(this, transactionId, status, null, 0);\n+  }\n+\n+  /**\n+   * Store a transaction.\n+   *\n+   * @param t the transaction\n+   */\n+  synchronized void storeTransaction(Transaction t) {\n+    if (t.getStatus() == Transaction.STATUS_PREPARED ||\n+        t.getName() != null) {\n+      Object[] v = {t.getStatus(), t.getName()};\n+      preparedTransactions.put(t.getId(), v);\n     }\n-\n-    /**\n-     * Get the list of unclosed transactions that have pending writes.\n-     *\n-     * @return the list of transactions (sorted by id)\n-     */\n-    public List<Transaction> getOpenTransactions() {\n-        rwLock.readLock().lock();\n-        try {\n-            ArrayList<Transaction> list = New.arrayList();\n-            Long key = undoLog.firstKey();\n-            while (key != null) {\n-                int transactionId = getTransactionId(key);\n-                key = undoLog.lowerKey(getOperationId(transactionId + 1, 0));\n-                long logId = getLogId(key) + 1;\n-                Object[] data = preparedTransactions.get(transactionId);\n-                int status;\n-                String name;\n-                if (data == null) {\n-                    if (undoLog.containsKey(getOperationId(transactionId, 0))) {\n-                        status = Transaction.STATUS_OPEN;\n-                    } else {\n-                        status = Transaction.STATUS_COMMITTING;\n-                    }\n-                    name = null;\n-                } else {\n-                    status = (Integer) data[0];\n-                    name = (String) data[1];\n-                }\n-                Transaction t = new Transaction(this, transactionId, status,\n-                        name, logId);\n-                list.add(t);\n-                key = undoLog.ceilingKey(getOperationId(transactionId + 1, 0));\n-            }\n-            return list;\n-        } finally {\n-            rwLock.readLock().unlock();\n+  }\n+\n+  /**\n+   * Log an entry.\n+   *\n+   * @param t        the transaction\n+   * @param logId    the log id\n+   * @param mapId    the map id\n+   * @param key      the key\n+   * @param oldValue the old value\n+   */\n+  void log(Transaction t, long logId, int mapId,\n+           Object key, Object oldValue) {\n+    Long undoKey = getOperationId(t.getId(), logId);\n+    Object[] log = {mapId, key, oldValue};\n+    rwLock.writeLock().lock();\n+    try {\n+      if (logId == 0) {\n+        if (undoLog.containsKey(undoKey)) {\n+          throw DataUtils.newIllegalStateException(\n+              DataUtils.ERROR_TOO_MANY_OPEN_TRANSACTIONS,\n+              \"An old transaction with the same id \" +\n+                  \"is still open: {0}\",\n+              t.getId());\n         }\n+      }\n+      undoLog.put(undoKey, log);\n+    } finally {\n+      rwLock.writeLock().unlock();\n     }\n-\n-    /**\n-     * Close the transaction store.\n-     */\n-    public synchronized void close() {\n-        store.commit();\n+  }\n+\n+  /**\n+   * Remove a log entry.\n+   *\n+   * @param t     the transaction\n+   * @param logId the log id\n+   */\n+  public void logUndo(Transaction t, long logId) {\n+    Long undoKey = getOperationId(t.getId(), logId);\n+    rwLock.writeLock().lock();\n+    try {\n+      Object[] old = undoLog.remove(undoKey);\n+      if (old == null) {\n+        throw DataUtils.newIllegalStateException(\n+            DataUtils.ERROR_TRANSACTION_ILLEGAL_STATE,\n+            \"Transaction {0} was concurrently rolled back\",\n+            t.getId());\n+      }\n+    } finally {\n+      rwLock.writeLock().unlock();\n     }\n-\n-    /**\n-     * Begin a new transaction.\n-     *\n-     * @return the transaction\n-     */\n-    public synchronized Transaction begin() {\n-\n-        int transactionId;\n-        int status;\n-        if (!init) {\n-            throw DataUtils.newIllegalStateException(\n-                    DataUtils.ERROR_TRANSACTION_ILLEGAL_STATE,\n-                    \"Not initialized\");\n-        }\n-        transactionId = openTransactions.nextClearBit(1);\n-        if (transactionId > maxTransactionId) {\n-            throw DataUtils.newIllegalStateException(\n-                    DataUtils.ERROR_TOO_MANY_OPEN_TRANSACTIONS,\n-                    \"There are {0} open transactions\",\n-                    transactionId - 1);\n-        }\n-        openTransactions.set(transactionId);\n-        status = Transaction.STATUS_OPEN;\n-        return new Transaction(this, transactionId, status, null, 0);\n+  }\n+\n+  /**\n+   * Remove the given map.\n+   *\n+   * @param <K> the key type\n+   * @param <V> the value type\n+   * @param map the map\n+   */\n+  synchronized <K, V> void removeMap(TransactionMap<K, V> map) {\n+    maps.remove(map.mapId);\n+    store.removeMap(map.map);\n+  }\n+\n+  /**\n+   * Commit a transaction.\n+   *\n+   * @param t        the transaction\n+   * @param maxLogId the last log id\n+   */\n+  void commit(Transaction t, long maxLogId) {\n+    if (store.isClosed()) {\n+      return;\n     }\n-\n-    /**\n-     * Store a transaction.\n-     *\n-     * @param t the transaction\n-     */\n-    synchronized void storeTransaction(Transaction t) {\n-        if (t.getStatus() == Transaction.STATUS_PREPARED ||\n-                t.getName() != null) {\n-            Object[] v = { t.getStatus(), t.getName() };\n-            preparedTransactions.put(t.getId(), v);\n-        }\n-    }\n-\n-    /**\n-     * Log an entry.\n-     *\n-     * @param t the transaction\n-     * @param logId the log id\n-     * @param mapId the map id\n-     * @param key the key\n-     * @param oldValue the old value\n-     */\n-    void log(Transaction t, long logId, int mapId,\n-            Object key, Object oldValue) {\n+    // TODO could synchronize on blocks (100 at a time or so)\n+    rwLock.writeLock().lock();\n+    int oldStatus = t.getStatus();\n+    try {\n+      t.setStatus(Transaction.STATUS_COMMITTING);\n+      for (long logId = 0; logId < maxLogId; logId++) {\n         Long undoKey = getOperationId(t.getId(), logId);\n-        Object[] log = { mapId, key, oldValue };\n-        rwLock.writeLock().lock();\n-        try {\n-            if (logId == 0) {\n-                if (undoLog.containsKey(undoKey)) {\n-                    throw DataUtils.newIllegalStateException(\n-                            DataUtils.ERROR_TOO_MANY_OPEN_TRANSACTIONS,\n-                            \"An old transaction with the same id \" +\n-                            \"is still open: {0}\",\n-                            t.getId());\n-                }\n-            }\n-            undoLog.put(undoKey, log);\n-        } finally {\n-            rwLock.writeLock().unlock();\n+        Object[] op = undoLog.get(undoKey);\n+        if (op == null) {\n+          // partially committed: load next\n+          undoKey = undoLog.ceilingKey(undoKey);\n+          if (undoKey == null ||\n+              getTransactionId(undoKey) != t.getId()) {\n+            break;\n+          }\n+          logId = getLogId(undoKey) - 1;\n+          continue;\n         }\n-    }\n-\n-    /**\n-     * Remove a log entry.\n-     *\n-     * @param t the transaction\n-     * @param logId the log id\n-     */\n-    public void logUndo(Transaction t, long logId) {\n-        Long undoKey = getOperationId(t.getId(), logId);\n-        rwLock.writeLock().lock();\n-        try {\n-            Object[] old = undoLog.remove(undoKey);\n-            if (old == null) {\n-                throw DataUtils.newIllegalStateException(\n-                        DataUtils.ERROR_TRANSACTION_ILLEGAL_STATE,\n-                        \"Transaction {0} was concurrently rolled back\",\n-                        t.getId());\n+        int mapId = (Integer) op[0];\n+        MVMap<Object, VersionedValue> map = openMap(mapId);\n+        if (map != null) { // might be null if map was removed later\n+          Object key = op[1];\n+          VersionedValue value = map.get(key);\n+          if (value != null) {\n+            // only commit (remove/update) value if we've reached\n+            // last undoLog entry for a given key\n+            if (value.operationId == undoKey) {\n+              if (value.value == null) {\n+                map.remove(key);\n+              } else {\n+                map.put(key, new VersionedValue(0L, value.value));\n+              }\n             }\n-        } finally {\n-            rwLock.writeLock().unlock();\n+          }\n         }\n+        undoLog.remove(undoKey);\n+      }\n+    } finally {\n+      rwLock.writeLock().unlock();\n     }\n-\n-    /**\n-     * Remove the given map.\n-     *\n-     * @param <K> the key type\n-     * @param <V> the value type\n-     * @param map the map\n-     */\n-    synchronized <K, V> void removeMap(TransactionMap<K, V> map) {\n-        maps.remove(map.mapId);\n-        store.removeMap(map.map);\n+    endTransaction(t, oldStatus);\n+  }\n+\n+  /**\n+   * Open the map with the given name.\n+   *\n+   * @param <K>       the key type\n+   * @param name      the map name\n+   * @param keyType   the key type\n+   * @param valueType the value type\n+   * @return the map\n+   */\n+  synchronized <K> MVMap<K, VersionedValue> openMap(String name,\n+                                                    DataType keyType, DataType valueType) {\n+    if (keyType == null) {\n+      keyType = new ObjectDataType();\n     }\n-\n-    /**\n-     * Commit a transaction.\n-     *\n-     * @param t the transaction\n-     * @param maxLogId the last log id\n-     */\n-    void commit(Transaction t, long maxLogId) {\n-        if (store.isClosed()) {\n-            return;\n-        }\n-        // TODO could synchronize on blocks (100 at a time or so)\n-        rwLock.writeLock().lock();\n-        int oldStatus = t.getStatus();\n-        try {\n-            t.setStatus(Transaction.STATUS_COMMITTING);\n-            for (long logId = 0; logId < maxLogId; logId++) {\n-                Long undoKey = getOperationId(t.getId(), logId);\n-                Object[] op = undoLog.get(undoKey);\n-                if (op == null) {\n-                    // partially committed: load next\n-                    undoKey = undoLog.ceilingKey(undoKey);\n-                    if (undoKey == null ||\n-                            getTransactionId(undoKey) != t.getId()) {\n-                        break;\n-                    }\n-                    logId = getLogId(undoKey) - 1;\n-                    continue;\n-                }\n-                int mapId = (Integer) op[0];\n-                MVMap<Object, VersionedValue> map = openMap(mapId);\n-                if (map != null) { // might be null if map was removed later\n-                    Object key = op[1];\n-                    VersionedValue value = map.get(key);\n-                    if (value != null) {\n-                        // only commit (remove/update) value if we've reached\n-                        // last undoLog entry for a given key\n-                        if (value.operationId == undoKey) {\n-                            if (value.value == null) {\n-                                map.remove(key);\n-                            } else {\n-                                map.put(key, new VersionedValue(0L, value.value));\n-                            }\n-                        }\n-                    }\n-                }\n-                undoLog.remove(undoKey);\n-            }\n-        } finally {\n-            rwLock.writeLock().unlock();\n-        }\n-        endTransaction(t, oldStatus);\n+    if (valueType == null) {\n+      valueType = new ObjectDataType();\n     }\n-\n-    /**\n-     * Open the map with the given name.\n-     *\n-     * @param <K> the key type\n-     * @param name the map name\n-     * @param keyType the key type\n-     * @param valueType the value type\n-     * @return the map\n-     */\n-    synchronized <K> MVMap<K, VersionedValue> openMap(String name,\n-            DataType keyType, DataType valueType) {\n-        if (keyType == null) {\n-            keyType = new ObjectDataType();\n-        }\n-        if (valueType == null) {\n-            valueType = new ObjectDataType();\n-        }\n-        VersionedValue.Type vt = new VersionedValue.Type(valueType);\n-        MVMap<K, VersionedValue> map;\n-        MVMap.Builder<K, VersionedValue> builder =\n-                new MVMap.Builder<K, VersionedValue>().\n-                keyType(keyType).valueType(vt);\n-        map = store.openMap(name, builder);\n-        @SuppressWarnings(\"unchecked\")\n-        MVMap<Object, VersionedValue> m = (MVMap<Object, VersionedValue>) map;\n-        maps.put(map.getId(), m);\n-        return map;\n+    VersionedValue.Type vt = new VersionedValue.Type(valueType);\n+    MVMap<K, VersionedValue> map;\n+    MVMap.Builder<K, VersionedValue> builder =\n+        new MVMap.Builder<K, VersionedValue>().\n+            keyType(keyType).valueType(vt);\n+    map = store.openMap(name, builder);\n+    @SuppressWarnings(\"unchecked\")\n+    MVMap<Object, VersionedValue> m = (MVMap<Object, VersionedValue>) map;\n+    maps.put(map.getId(), m);\n+    return map;\n+  }\n+\n+  /**\n+   * Open the map with the given id.\n+   *\n+   * @param mapId the id\n+   * @return the map\n+   */\n+  synchronized MVMap<Object, VersionedValue> openMap(int mapId) {\n+    MVMap<Object, VersionedValue> map = maps.get(mapId);\n+    if (map != null) {\n+      return map;\n     }\n-\n-    /**\n-     * Open the map with the given id.\n-     *\n-     * @param mapId the id\n-     * @return the map\n-     */\n-    synchronized MVMap<Object, VersionedValue> openMap(int mapId) {\n-        MVMap<Object, VersionedValue> map = maps.get(mapId);\n-        if (map != null) {\n-            return map;\n-        }\n-        String mapName = store.getMapName(mapId);\n-        if (mapName == null) {\n-            // the map was removed later on\n-            return null;\n-        }\n-        DataType vt = new VersionedValue.Type(dataType);\n-        MVMap.Builder<Object, VersionedValue> mapBuilder =\n-                new MVMap.Builder<Object, VersionedValue>().\n-                keyType(dataType).valueType(vt);\n-        map = store.openMap(mapName, mapBuilder);\n-        maps.put(mapId, map);\n-        return map;\n+    String mapName = store.getMapName(mapId);\n+    if (mapName == null) {\n+      // the map was removed later on\n+      return null;\n     }\n-\n-    /**\n-     * Create a temporary map. Such maps are removed when opening the store.\n-     *\n-     * @return the map\n-     */\n-    synchronized MVMap<Object, Integer> createTempMap() {\n-        String mapName = \"temp.\" + nextTempMapId++;\n-        return openTempMap(mapName);\n+    DataType vt = new VersionedValue.Type(dataType);\n+    MVMap.Builder<Object, VersionedValue> mapBuilder =\n+        new MVMap.Builder<Object, VersionedValue>().\n+            keyType(dataType).valueType(vt);\n+    map = store.openMap(mapName, mapBuilder);\n+    maps.put(mapId, map);\n+    return map;\n+  }\n+\n+  /**\n+   * Create a temporary map. Such maps are removed when opening the store.\n+   *\n+   * @return the map\n+   */\n+  synchronized MVMap<Object, Integer> createTempMap() {\n+    String mapName = \"temp.\" + nextTempMapId++;\n+    return openTempMap(mapName);\n+  }\n+\n+  /**\n+   * Open a temporary map.\n+   *\n+   * @param mapName the map name\n+   * @return the map\n+   */\n+  MVMap<Object, Integer> openTempMap(String mapName) {\n+    MVMap.Builder<Object, Integer> mapBuilder =\n+        new MVMap.Builder<Object, Integer>().\n+            keyType(dataType);\n+    return store.openMap(mapName, mapBuilder);\n+  }\n+\n+  /**\n+   * End this transaction\n+   *\n+   * @param t         the transaction\n+   * @param oldStatus status of this transaction\n+   */\n+  synchronized void endTransaction(Transaction t, int oldStatus) {\n+    if (oldStatus == Transaction.STATUS_PREPARED) {\n+      preparedTransactions.remove(t.getId());\n     }\n-\n-    /**\n-     * Open a temporary map.\n-     *\n-     * @param mapName the map name\n-     * @return the map\n-     */\n-    MVMap<Object, Integer> openTempMap(String mapName) {\n-        MVMap.Builder<Object, Integer> mapBuilder =\n-                new MVMap.Builder<Object, Integer>().\n-                keyType(dataType);\n-        return store.openMap(mapName, mapBuilder);\n+    t.setStatus(Transaction.STATUS_CLOSED);\n+    openTransactions.clear(t.transactionId);\n+    if (oldStatus == Transaction.STATUS_PREPARED || store.getAutoCommitDelay() == 0) {\n+      store.tryCommit();\n+      return;\n     }\n-\n-    /**\n-     * End this transaction\n-     *\n-     * @param t the transaction\n-     * @param oldStatus status of this transaction\n-     */\n-    synchronized void endTransaction(Transaction t, int oldStatus) {\n-        if (oldStatus == Transaction.STATUS_PREPARED) {\n-            preparedTransactions.remove(t.getId());\n-        }\n-        t.setStatus(Transaction.STATUS_CLOSED);\n-        openTransactions.clear(t.transactionId);\n-        if (oldStatus == Transaction.STATUS_PREPARED || store.getAutoCommitDelay() == 0) {\n-            store.tryCommit();\n-            return;\n+    // to avoid having to store the transaction log,\n+    // if there is no open transaction,\n+    // and if there have been many changes, store them now\n+    if (undoLog.isEmpty()) {\n+      int unsaved = store.getUnsavedMemory();\n+      int max = store.getAutoCommitMemory();\n+      // save at 3/4 capacity\n+      if (unsaved * 4 > max * 3) {\n+        store.tryCommit();\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Rollback to an old savepoint.\n+   *\n+   * @param t        the transaction\n+   * @param maxLogId the last log id\n+   * @param toLogId  the log id to roll back to\n+   */\n+  void rollbackTo(Transaction t, long maxLogId, long toLogId) {\n+    // TODO could synchronize on blocks (100 at a time or so)\n+    rwLock.writeLock().lock();\n+    try {\n+      for (long logId = maxLogId - 1; logId >= toLogId; logId--) {\n+        Long undoKey = getOperationId(t.getId(), logId);\n+        Object[] op = undoLog.get(undoKey);\n+        if (op == null) {\n+          // partially rolled back: load previous\n+          undoKey = undoLog.floorKey(undoKey);\n+          if (undoKey == null ||\n+              getTransactionId(undoKey) != t.getId()) {\n+            break;\n+          }\n+          logId = getLogId(undoKey) + 1;\n+          continue;\n         }\n-        // to avoid having to store the transaction log,\n-        // if there is no open transaction,\n-        // and if there have been many changes, store them now\n-        if (undoLog.isEmpty()) {\n-            int unsaved = store.getUnsavedMemory();\n-            int max = store.getAutoCommitMemory();\n-            // save at 3/4 capacity\n-            if (unsaved * 4 > max * 3) {\n-                store.tryCommit();\n-            }\n+        int mapId = ((Integer) op[0]).intValue();\n+        MVMap<Object, VersionedValue> map = openMap(mapId);\n+        if (map != null) {\n+          Object key = op[1];\n+          VersionedValue oldValue = (VersionedValue) op[2];\n+          if (oldValue == null) {\n+            // this transaction added the value\n+            map.remove(key);\n+          } else {\n+            // this transaction updated the value\n+            map.put(key, oldValue);\n+          }\n         }\n+        undoLog.remove(undoKey);\n+      }\n+    } finally {\n+      rwLock.writeLock().unlock();\n     }\n-\n-    /**\n-     * Rollback to an old savepoint.\n-     *\n-     * @param t the transaction\n-     * @param maxLogId the last log id\n-     * @param toLogId the log id to roll back to\n-     */\n-    void rollbackTo(Transaction t, long maxLogId, long toLogId) {\n-        // TODO could synchronize on blocks (100 at a time or so)\n+  }\n+\n+  /**\n+   * Get the changes of the given transaction, starting from the latest log id\n+   * back to the given log id.\n+   *\n+   * @param t        the transaction\n+   * @param maxLogId the maximum log id\n+   * @param toLogId  the minimum log id\n+   * @return the changes\n+   */\n+  Iterator<Change> getChanges(final Transaction t, final long maxLogId,\n+                              final long toLogId) {\n+    return new Iterator<Change>() {\n+\n+      private long logId = maxLogId - 1;\n+      private Change current;\n+\n+      {\n+        fetchNext();\n+      }\n+\n+      private void fetchNext() {\n         rwLock.writeLock().lock();\n         try {\n-            for (long logId = maxLogId - 1; logId >= toLogId; logId--) {\n-                Long undoKey = getOperationId(t.getId(), logId);\n-                Object[] op = undoLog.get(undoKey);\n-                if (op == null) {\n-                    // partially rolled back: load previous\n-                    undoKey = undoLog.floorKey(undoKey);\n-                    if (undoKey == null ||\n-                            getTransactionId(undoKey) != t.getId()) {\n-                        break;\n-                    }\n-                    logId = getLogId(undoKey) + 1;\n-                    continue;\n-                }\n-                int mapId = ((Integer) op[0]).intValue();\n-                MVMap<Object, VersionedValue> map = openMap(mapId);\n-                if (map != null) {\n-                    Object key = op[1];\n-                    VersionedValue oldValue = (VersionedValue) op[2];\n-                    if (oldValue == null) {\n-                        // this transaction added the value\n-                        map.remove(key);\n-                    } else {\n-                        // this transaction updated the value\n-                        map.put(key, oldValue);\n-                    }\n-                }\n-                undoLog.remove(undoKey);\n+          while (logId >= toLogId) {\n+            Long undoKey = getOperationId(t.getId(), logId);\n+            Object[] op = undoLog.get(undoKey);\n+            logId--;\n+            if (op == null) {\n+              // partially rolled back: load previous\n+              undoKey = undoLog.floorKey(undoKey);\n+              if (undoKey == null ||\n+                  getTransactionId(undoKey) != t.getId()) {\n+                break;\n+              }\n+              logId = getLogId(undoKey);\n+              continue;\n+            }\n+            int mapId = ((Integer) op[0]).intValue();\n+            MVMap<Object, VersionedValue> m = openMap(mapId);\n+            if (m == null) {\n+              // map was removed later on\n+            } else {\n+              current = new Change();\n+              current.mapName = m.getName();\n+              current.key = op[1];\n+              VersionedValue oldValue = (VersionedValue) op[2];\n+              current.value = oldValue == null ?\n+                  null : oldValue.value;\n+              return;\n             }\n+          }\n         } finally {\n-            rwLock.writeLock().unlock();\n+          rwLock.writeLock().unlock();\n         }\n-    }\n-\n-    /**\n-     * Get the changes of the given transaction, starting from the latest log id\n-     * back to the given log id.\n-     *\n-     * @param t the transaction\n-     * @param maxLogId the maximum log id\n-     * @param toLogId the minimum log id\n-     * @return the changes\n-     */\n-    Iterator<Change> getChanges(final Transaction t, final long maxLogId,\n-            final long toLogId) {\n-        return new Iterator<Change>() {\n-\n-            private long logId = maxLogId - 1;\n-            private Change current;\n-\n-            {\n-                fetchNext();\n-            }\n+        current = null;\n+      }\n+\n+      @Override\n+      public boolean hasNext() {\n+        return current != null;\n+      }\n+\n+      @Override\n+      public Change next() {\n+        if (current == null) {\n+          throw DataUtils.newUnsupportedOperationException(\"no data\");\n+        }\n+        Change result = current;\n+        fetchNext();\n+        return result;\n+      }\n \n-            private void fetchNext() {\n-                rwLock.writeLock().lock();\n-                try {\n-                    while (logId >= toLogId) {\n-                        Long undoKey = getOperationId(t.getId(), logId);\n-                        Object[] op = undoLog.get(undoKey);\n-                        logId--;\n-                        if (op == null) {\n-                            // partially rolled back: load previous\n-                            undoKey = undoLog.floorKey(undoKey);\n-                            if (undoKey == null ||\n-                                    getTransactionId(undoKey) != t.getId()) {\n-                                break;\n-                            }\n-                            logId = getLogId(undoKey);\n-                            continue;\n-                        }\n-                        int mapId = ((Integer) op[0]).intValue();\n-                        MVMap<Object, VersionedValue> m = openMap(mapId);\n-                        if (m == null) {\n-                            // map was removed later on\n-                        } else {\n-                            current = new Change();\n-                            current.mapName = m.getName();\n-                            current.key = op[1];\n-                            VersionedValue oldValue = (VersionedValue) op[2];\n-                            current.value = oldValue == null ?\n-                                    null : oldValue.value;\n-                            return;\n-                        }\n-                    }\n-                } finally {\n-                    rwLock.writeLock().unlock();\n-                }\n-                current = null;\n-            }\n+      @Override\n+      public void remove() {\n+        throw DataUtils.newUnsupportedOperationException(\"remove\");\n+      }\n \n-            @Override\n-            public boolean hasNext() {\n-                return current != null;\n-            }\n+    };\n+  }\n \n-            @Override\n-            public Change next() {\n-                if (current == null) {\n-                    throw DataUtils.newUnsupportedOperationException(\"no data\");\n-                }\n-                Change result = current;\n-                fetchNext();\n-                return result;\n-            }\n-\n-            @Override\n-            public void remove() {\n-                throw DataUtils.newUnsupportedOperationException(\"remove\");\n-            }\n-\n-        };\n-    }\n+  /**\n+   * A change in a map.\n+   */\n+  public static class Change {\n \n     /**\n-     * A change in a map.\n+     * The name of the map where the change occurred.\n      */\n-    public static class Change {\n-\n-        /**\n-         * The name of the map where the change occurred.\n-         */\n-        public String mapName;\n-\n-        /**\n-         * The key.\n-         */\n-        public Object key;\n-\n-        /**\n-         * The value.\n-         */\n-        public Object value;\n-    }\n+    public String mapName;\n \n+    /**\n+     * The key.\n+     */\n+    public Object key;\n \n     /**\n-     * A data type that contains an array of objects with the specified data\n-     * types.\n+     * The value.\n      */\n-    public static class ArrayType implements DataType {\n+    public Object value;\n+  }\n \n-        private final int arrayLength;\n-        private final DataType[] elementTypes;\n \n-        ArrayType(DataType[] elementTypes) {\n-            this.arrayLength = elementTypes.length;\n-            this.elementTypes = elementTypes;\n-        }\n+  /**\n+   * A data type that contains an array of objects with the specified data\n+   * types.\n+   */\n+  public static class ArrayType implements DataType {\n \n-        @Override\n-        public int getMemory(Object obj) {\n-            Object[] array = (Object[]) obj;\n-            int size = 0;\n-            for (int i = 0; i < arrayLength; i++) {\n-                DataType t = elementTypes[i];\n-                Object o = array[i];\n-                if (o != null) {\n-                    size += t.getMemory(o);\n-                }\n-            }\n-            return size;\n-        }\n+    private final int arrayLength;\n+    private final DataType[] elementTypes;\n \n-        @Override\n-        public int compare(Object aObj, Object bObj) {\n-            if (aObj == bObj) {\n-                return 0;\n-            }\n-            Object[] a = (Object[]) aObj;\n-            Object[] b = (Object[]) bObj;\n-            for (int i = 0; i < arrayLength; i++) {\n-                DataType t = elementTypes[i];\n-                int comp = t.compare(a[i], b[i]);\n-                if (comp != 0) {\n-                    return comp;\n-                }\n-            }\n-            return 0;\n-        }\n+    ArrayType(DataType[] elementTypes) {\n+      this.arrayLength = elementTypes.length;\n+      this.elementTypes = elementTypes;\n+    }\n \n-        @Override\n-        public void read(ByteBuffer buff, Object[] obj,\n-                int len, boolean key) {\n-            for (int i = 0; i < len; i++) {\n-                obj[i] = read(buff);\n-            }\n+    @Override\n+    public int getMemory(Object obj) {\n+      Object[] array = (Object[]) obj;\n+      int size = 0;\n+      for (int i = 0; i < arrayLength; i++) {\n+        DataType t = elementTypes[i];\n+        Object o = array[i];\n+        if (o != null) {\n+          size += t.getMemory(o);\n         }\n+      }\n+      return size;\n+    }\n \n-        @Override\n-        public void write(WriteBuffer buff, Object[] obj,\n-                int len, boolean key) {\n-            for (int i = 0; i < len; i++) {\n-                write(buff, obj[i]);\n-            }\n+    @Override\n+    public int compare(Object aObj, Object bObj) {\n+      if (aObj == bObj) {\n+        return 0;\n+      }\n+      Object[] a = (Object[]) aObj;\n+      Object[] b = (Object[]) bObj;\n+      for (int i = 0; i < arrayLength; i++) {\n+        DataType t = elementTypes[i];\n+        int comp = t.compare(a[i], b[i]);\n+        if (comp != 0) {\n+          return comp;\n         }\n+      }\n+      return 0;\n+    }\n \n-        @Override\n-        public void write(WriteBuffer buff, Object obj) {\n-            Object[] array = (Object[]) obj;\n-            for (int i = 0; i < arrayLength; i++) {\n-                DataType t = elementTypes[i];\n-                Object o = array[i];\n-                if (o == null) {\n-                    buff.put((byte) 0);\n-                } else {\n-                    buff.put((byte) 1);\n-                    t.write(buff, o);\n-                }\n-            }\n-        }\n+    @Override\n+    public void read(ByteBuffer buff, Object[] obj,\n+                     int len, boolean key) {\n+      for (int i = 0; i < len; i++) {\n+        obj[i] = read(buff);\n+      }\n+    }\n \n-        @Override\n-        public Object read(ByteBuffer buff) {\n-            Object[] array = new Object[arrayLength];\n-            for (int i = 0; i < arrayLength; i++) {\n-                DataType t = elementTypes[i];\n-                if (buff.get() == 1) {\n-                    array[i] = t.read(buff);\n-                }\n-            }\n-            return array;\n+    @Override\n+    public void write(WriteBuffer buff, Object[] obj,\n+                      int len, boolean key) {\n+      for (int i = 0; i < len; i++) {\n+        write(buff, obj[i]);\n+      }\n+    }\n+\n+    @Override\n+    public void write(WriteBuffer buff, Object obj) {\n+      Object[] array = (Object[]) obj;\n+      for (int i = 0; i < arrayLength; i++) {\n+        DataType t = elementTypes[i];\n+        Object o = array[i];\n+        if (o == null) {\n+          buff.put((byte) 0);\n+        } else {\n+          buff.put((byte) 1);\n+          t.write(buff, o);\n         }\n+      }\n+    }\n \n+    @Override\n+    public Object read(ByteBuffer buff) {\n+      Object[] array = new Object[arrayLength];\n+      for (int i = 0; i < arrayLength; i++) {\n+        DataType t = elementTypes[i];\n+        if (buff.get() == 1) {\n+          array[i] = t.read(buff);\n+        }\n+      }\n+      return array;\n     }\n \n+  }\n+\n }\n",
            "diff_size": 917
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "387",
                    "column": "36",
                    "severity": "warning",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/215/TransactionStore.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/codebuff/215/TransactionStore.java\nindex 5e45c92e007..183acab5cfa 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/215/TransactionStore.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/codebuff/215/TransactionStore.java\n@@ -23,17 +23,23 @@ import org.h2.util.New;\n /**\n  * A store that supports concurrent MVCC read-committed transactions.\n  */\n+\n+\n public class TransactionStore {\n \n     /**\n      * The store.\n      */\n+\n+\n     final MVStore store;\n \n     /**\n      * The persisted map of prepared transactions.\n      * Key: transactionId, value: [ status, name ].\n      */\n+\n+\n     final MVMap<Integer, Object[]> preparedTransactions;\n \n     /**\n@@ -46,26 +52,25 @@ public class TransactionStore {\n      * <p>\n      * Key: opId, value: [ mapId, key, oldValue ].\n      */\n+\n+\n     final MVMap<Long, Object[]> undoLog;\n \n     /**\n      * the reader/writer lock for the undo-log. Allows us to process multiple\n      * selects in parallel.\n      */\n+\n+\n     final ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();\n \n     /**\n      * The map of maps.\n      */\n-    private final HashMap<Integer, MVMap<Object, VersionedValue>> maps =\n-            new HashMap<>();\n-\n+    private final HashMap<Integer, MVMap<Object, VersionedValue>> maps = new HashMap< >();\n     private final DataType dataType;\n-\n     private final BitSet openTransactions = new BitSet();\n-\n     private boolean init;\n-\n     private int maxTransactionId = 0xffff;\n \n     /**\n@@ -78,6 +83,7 @@ public class TransactionStore {\n      *\n      * @param store the store\n      */\n+\n     public TransactionStore(MVStore store) {\n         this(store, new ObjectDataType());\n     }\n@@ -88,23 +94,18 @@ public class TransactionStore {\n      * @param store the store\n      * @param dataType the data type for map keys and values\n      */\n+\n     public TransactionStore(MVStore store, DataType dataType) {\n         this.store = store;\n         this.dataType = dataType;\n         preparedTransactions = store.openMap(\"openTransactions\",\n-                new MVMap.Builder<Integer, Object[]>());\n+            new MVMap.Builder<Integer, Object[]>());\n         DataType oldValueType = new VersionedValue.Type(dataType);\n-        ArrayType undoLogValueType = new ArrayType(new DataType[]{\n-                new ObjectDataType(), dataType, oldValueType\n-        });\n-        MVMap.Builder<Long, Object[]> builder =\n-                new MVMap.Builder<Long, Object[]>().\n-                valueType(undoLogValueType);\n+        ArrayType undoLogValueType = new ArrayType(new DataType[] { new ObjectDataType(), dataType, oldValueType });\n+        MVMap.Builder<Long, Object[]> builder = new MVMap.Builder<Long, Object[]>().valueType(undoLogValueType);\n         undoLog = store.openMap(\"undoLog\", builder);\n         if (undoLog.getValueType() != undoLogValueType) {\n-            throw DataUtils.newIllegalStateException(\n-                    DataUtils.ERROR_TRANSACTION_CORRUPT,\n-                    \"Undo map open with a different value type\");\n+            throw DataUtils.newIllegalStateException(DataUtils.ERROR_TRANSACTION_CORRUPT, \"Undo map open with a different value type\");\n         }\n     }\n \n@@ -113,6 +114,8 @@ public class TransactionStore {\n      * If the transaction store is corrupt, this method can throw an exception,\n      * in which case the store can only be used for reading.\n      */\n+\n+\n     public synchronized void init() {\n         init = true;\n         // remove all temporary maps\n@@ -142,6 +145,8 @@ public class TransactionStore {\n      *\n      * @param max the maximum id\n      */\n+\n+\n     public void setMaxTransactionId(int max) {\n         this.maxTransactionId = max;\n     }\n@@ -152,6 +157,8 @@ public class TransactionStore {\n      * @param name the map name\n      * @return true if it exists\n      */\n+\n+\n     public boolean hasMap(String name) {\n         return store.hasMap(name);\n     }\n@@ -163,11 +170,12 @@ public class TransactionStore {\n      * @param logId the log id\n      * @return the operation id\n      */\n+\n+\n     static long getOperationId(int transactionId, long logId) {\n-        DataUtils.checkArgument(transactionId >= 0 && transactionId < (1 << 24),\n-                \"Transaction id out of range: {0}\", transactionId);\n+        DataUtils.checkArgument(transactionId >= 0 && transactionId < (1 << 24), \"Transaction id out of range: {0}\", transactionId);\n         DataUtils.checkArgument(logId >= 0 && logId < (1L << 40),\n-                \"Transaction log id out of range: {0}\", logId);\n+                                \"Transaction log id out of range: {0}\", logId);\n         return ((long) transactionId << 40) | logId;\n     }\n \n@@ -177,6 +185,8 @@ public class TransactionStore {\n      * @param operationId the operation id\n      * @return the transaction id\n      */\n+\n+\n     static int getTransactionId(long operationId) {\n         return (int) (operationId >>> 40);\n     }\n@@ -187,6 +197,8 @@ public class TransactionStore {\n      * @param operationId the operation id\n      * @return the log id\n      */\n+\n+\n     static long getLogId(long operationId) {\n         return operationId & ((1L << 40) - 1);\n     }\n@@ -196,6 +208,8 @@ public class TransactionStore {\n      *\n      * @return the list of transactions (sorted by id)\n      */\n+\n+\n     public List<Transaction> getOpenTransactions() {\n         rwLock.readLock().lock();\n         try {\n@@ -219,8 +233,7 @@ public class TransactionStore {\n                     status = (Integer) data[0];\n                     name = (String) data[1];\n                 }\n-                Transaction t = new Transaction(this, transactionId, status,\n-                        name, logId);\n+                Transaction t = new Transaction(this, transactionId, status, name, logId);\n                 list.add(t);\n                 key = undoLog.ceilingKey(getOperationId(transactionId + 1, 0));\n             }\n@@ -233,6 +246,8 @@ public class TransactionStore {\n     /**\n      * Close the transaction store.\n      */\n+\n+\n     public synchronized void close() {\n         store.commit();\n     }\n@@ -242,21 +257,18 @@ public class TransactionStore {\n      *\n      * @return the transaction\n      */\n-    public synchronized Transaction begin() {\n \n+\n+    public synchronized Transaction begin() {\n         int transactionId;\n         int status;\n         if (!init) {\n-            throw DataUtils.newIllegalStateException(\n-                    DataUtils.ERROR_TRANSACTION_ILLEGAL_STATE,\n-                    \"Not initialized\");\n+            throw DataUtils.newIllegalStateException(DataUtils.ERROR_TRANSACTION_ILLEGAL_STATE,\n+                                                     \"Not initialized\");\n         }\n         transactionId = openTransactions.nextClearBit(1);\n         if (transactionId > maxTransactionId) {\n-            throw DataUtils.newIllegalStateException(\n-                    DataUtils.ERROR_TOO_MANY_OPEN_TRANSACTIONS,\n-                    \"There are {0} open transactions\",\n-                    transactionId - 1);\n+            throw DataUtils.newIllegalStateException(DataUtils.ERROR_TOO_MANY_OPEN_TRANSACTIONS, \"There are {0} open transactions\", transactionId - 1);\n         }\n         openTransactions.set(transactionId);\n         status = Transaction.STATUS_OPEN;\n@@ -268,9 +280,10 @@ public class TransactionStore {\n      *\n      * @param t the transaction\n      */\n+\n+\n     synchronized void storeTransaction(Transaction t) {\n-        if (t.getStatus() == Transaction.STATUS_PREPARED ||\n-                t.getName() != null) {\n+        if (t.getStatus() == Transaction.STATUS_PREPARED || t.getName() != null) {\n             Object[] v = { t.getStatus(), t.getName() };\n             preparedTransactions.put(t.getId(), v);\n         }\n@@ -285,7 +298,10 @@ public class TransactionStore {\n      * @param key the key\n      * @param oldValue the old value\n      */\n-    void log(Transaction t, long logId, int mapId,\n+\n+\n+    void log(Transaction t,\n+        long logId, int mapId,\n             Object key, Object oldValue) {\n         Long undoKey = getOperationId(t.getId(), logId);\n         Object[] log = { mapId, key, oldValue };\n@@ -293,11 +309,7 @@ public class TransactionStore {\n         try {\n             if (logId == 0) {\n                 if (undoLog.containsKey(undoKey)) {\n-                    throw DataUtils.newIllegalStateException(\n-                            DataUtils.ERROR_TOO_MANY_OPEN_TRANSACTIONS,\n-                            \"An old transaction with the same id \" +\n-                            \"is still open: {0}\",\n-                            t.getId());\n+                    throw DataUtils.newIllegalStateException(DataUtils.ERROR_TOO_MANY_OPEN_TRANSACTIONS, \"An old transaction with the same id \" + \"is still open: {0}\", t.getId());\n                 }\n             }\n             undoLog.put(undoKey, log);\n@@ -312,16 +324,15 @@ public class TransactionStore {\n      * @param t the transaction\n      * @param logId the log id\n      */\n+\n+\n     public void logUndo(Transaction t, long logId) {\n         Long undoKey = getOperationId(t.getId(), logId);\n         rwLock.writeLock().lock();\n         try {\n             Object[] old = undoLog.remove(undoKey);\n             if (old == null) {\n-                throw DataUtils.newIllegalStateException(\n-                        DataUtils.ERROR_TRANSACTION_ILLEGAL_STATE,\n-                        \"Transaction {0} was concurrently rolled back\",\n-                        t.getId());\n+                throw DataUtils.newIllegalStateException(DataUtils.ERROR_TRANSACTION_ILLEGAL_STATE, \"Transaction {0} was concurrently rolled back\", t.getId());\n             }\n         } finally {\n             rwLock.writeLock().unlock();\n@@ -335,6 +346,8 @@ public class TransactionStore {\n      * @param <V> the value type\n      * @param map the map\n      */\n+\n+\n     synchronized <K, V> void removeMap(TransactionMap<K, V> map) {\n         maps.remove(map.mapId);\n         store.removeMap(map.map);\n@@ -346,6 +359,8 @@ public class TransactionStore {\n      * @param t the transaction\n      * @param maxLogId the last log id\n      */\n+\n+\n     void commit(Transaction t, long maxLogId) {\n         if (store.isClosed()) {\n             return;\n@@ -361,8 +376,7 @@ public class TransactionStore {\n                 if (op == null) {\n                     // partially committed: load next\n                     undoKey = undoLog.ceilingKey(undoKey);\n-                    if (undoKey == null ||\n-                            getTransactionId(undoKey) != t.getId()) {\n+                    if (undoKey == null || getTransactionId(undoKey) != t.getId()) {\n                         break;\n                     }\n                     logId = getLogId(undoKey) - 1;\n@@ -402,8 +416,9 @@ public class TransactionStore {\n      * @param valueType the value type\n      * @return the map\n      */\n-    synchronized <K> MVMap<K, VersionedValue> openMap(String name,\n-            DataType keyType, DataType valueType) {\n+\n+\n+    synchronized <K> MVMap<K, VersionedValue> openMap(String name, DataType keyType, DataType valueType) {\n         if (keyType == null) {\n             keyType = new ObjectDataType();\n         }\n@@ -412,9 +427,7 @@ public class TransactionStore {\n         }\n         VersionedValue.Type vt = new VersionedValue.Type(valueType);\n         MVMap<K, VersionedValue> map;\n-        MVMap.Builder<K, VersionedValue> builder =\n-                new MVMap.Builder<K, VersionedValue>().\n-                keyType(keyType).valueType(vt);\n+        MVMap.Builder<K, VersionedValue> builder = new MVMap.Builder<K, VersionedValue>().keyType(keyType).valueType(vt);\n         map = store.openMap(name, builder);\n         @SuppressWarnings(\"unchecked\")\n         MVMap<Object, VersionedValue> m = (MVMap<Object, VersionedValue>) map;\n@@ -428,6 +441,8 @@ public class TransactionStore {\n      * @param mapId the id\n      * @return the map\n      */\n+\n+\n     synchronized MVMap<Object, VersionedValue> openMap(int mapId) {\n         MVMap<Object, VersionedValue> map = maps.get(mapId);\n         if (map != null) {\n@@ -439,9 +454,7 @@ public class TransactionStore {\n             return null;\n         }\n         DataType vt = new VersionedValue.Type(dataType);\n-        MVMap.Builder<Object, VersionedValue> mapBuilder =\n-                new MVMap.Builder<Object, VersionedValue>().\n-                keyType(dataType).valueType(vt);\n+        MVMap.Builder<Object, VersionedValue> mapBuilder = new MVMap.Builder<Object, VersionedValue>().keyType(dataType).valueType(vt);\n         map = store.openMap(mapName, mapBuilder);\n         maps.put(mapId, map);\n         return map;\n@@ -452,6 +465,8 @@ public class TransactionStore {\n      *\n      * @return the map\n      */\n+\n+\n     synchronized MVMap<Object, Integer> createTempMap() {\n         String mapName = \"temp.\" + nextTempMapId++;\n         return openTempMap(mapName);\n@@ -463,10 +478,10 @@ public class TransactionStore {\n      * @param mapName the map name\n      * @return the map\n      */\n+\n+\n     MVMap<Object, Integer> openTempMap(String mapName) {\n-        MVMap.Builder<Object, Integer> mapBuilder =\n-                new MVMap.Builder<Object, Integer>().\n-                keyType(dataType);\n+        MVMap.Builder<Object, Integer> mapBuilder = new MVMap.Builder<Object, Integer>().keyType(dataType);\n         return store.openMap(mapName, mapBuilder);\n     }\n \n@@ -476,6 +491,8 @@ public class TransactionStore {\n      * @param t the transaction\n      * @param oldStatus status of this transaction\n      */\n+\n+\n     synchronized void endTransaction(Transaction t, int oldStatus) {\n         if (oldStatus == Transaction.STATUS_PREPARED) {\n             preparedTransactions.remove(t.getId());\n@@ -506,6 +523,8 @@ public class TransactionStore {\n      * @param maxLogId the last log id\n      * @param toLogId the log id to roll back to\n      */\n+\n+\n     void rollbackTo(Transaction t, long maxLogId, long toLogId) {\n         // TODO could synchronize on blocks (100 at a time or so)\n         rwLock.writeLock().lock();\n@@ -516,8 +535,7 @@ public class TransactionStore {\n                 if (op == null) {\n                     // partially rolled back: load previous\n                     undoKey = undoLog.floorKey(undoKey);\n-                    if (undoKey == null ||\n-                            getTransactionId(undoKey) != t.getId()) {\n+                    if (undoKey == null || getTransactionId(undoKey) != t.getId()) {\n                         break;\n                     }\n                     logId = getLogId(undoKey) + 1;\n@@ -552,8 +570,9 @@ public class TransactionStore {\n      * @param toLogId the minimum log id\n      * @return the changes\n      */\n-    Iterator<Change> getChanges(final Transaction t, final long maxLogId,\n-            final long toLogId) {\n+\n+\n+    Iterator<Change> getChanges(final Transaction t, final long maxLogId, final long toLogId) {\n         return new Iterator<Change>() {\n \n             private long logId = maxLogId - 1;\n@@ -573,8 +592,7 @@ public class TransactionStore {\n                         if (op == null) {\n                             // partially rolled back: load previous\n                             undoKey = undoLog.floorKey(undoKey);\n-                            if (undoKey == null ||\n-                                    getTransactionId(undoKey) != t.getId()) {\n+                            if (undoKey == null || getTransactionId(undoKey) != t.getId()) {\n                                 break;\n                             }\n                             logId = getLogId(undoKey);\n@@ -584,13 +602,13 @@ public class TransactionStore {\n                         MVMap<Object, VersionedValue> m = openMap(mapId);\n                         if (m == null) {\n                             // map was removed later on\n+\n                         } else {\n                             current = new Change();\n                             current.mapName = m.getName();\n                             current.key = op[1];\n                             VersionedValue oldValue = (VersionedValue) op[2];\n-                            current.value = oldValue == null ?\n-                                    null : oldValue.value;\n+                            current.value = oldValue == null ? null : oldValue.value;\n                             return;\n                         }\n                     }\n@@ -619,28 +637,35 @@ public class TransactionStore {\n             public void remove() {\n                 throw DataUtils.newUnsupportedOperationException(\"remove\");\n             }\n-\n         };\n     }\n \n     /**\n      * A change in a map.\n      */\n+\n+\n     public static class Change {\n \n         /**\n          * The name of the map where the change occurred.\n          */\n+\n+\n         public String mapName;\n \n         /**\n          * The key.\n          */\n+\n+\n         public Object key;\n \n         /**\n          * The value.\n          */\n+\n+\n         public Object value;\n     }\n \n@@ -649,6 +674,8 @@ public class TransactionStore {\n      * A data type that contains an array of objects with the specified data\n      * types.\n      */\n+\n+\n     public static class ArrayType implements DataType {\n \n         private final int arrayLength;\n@@ -691,16 +718,14 @@ public class TransactionStore {\n         }\n \n         @Override\n-        public void read(ByteBuffer buff, Object[] obj,\n-                int len, boolean key) {\n+        public void read(ByteBuffer buff, Object[] obj, int len, boolean key) {\n             for (int i = 0; i < len; i++) {\n                 obj[i] = read(buff);\n             }\n         }\n \n         @Override\n-        public void write(WriteBuffer buff, Object[] obj,\n-                int len, boolean key) {\n+        public void write(WriteBuffer buff, Object[] obj, int len, boolean key) {\n             for (int i = 0; i < len; i++) {\n                 write(buff, obj[i]);\n             }\n@@ -735,4 +760,4 @@ public class TransactionStore {\n \n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 132
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/215/TransactionStore.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_random/215/TransactionStore.java\nindex 5e45c92e007..cfa16ca3277 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/215/TransactionStore.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_random/215/TransactionStore.java\n@@ -370,8 +370,9 @@ public class TransactionStore {\n                 }\n                 int mapId = (Integer) op[0];\n                 MVMap<Object, VersionedValue> map = openMap(mapId);\n-                if (map != null) { // might be null if map was removed later\n-                    Object key = op[1];\n+                if (map != null) {\n+                    // might be null if map was removed later\n+                Object key = op[1];\n                     VersionedValue value = map.get(key);\n                     if (value != null) {\n                         // only commit (remove/update) value if we've reached\n",
            "diff_size": 3
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/215/TransactionStore.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/215/TransactionStore.java\nindex 5e45c92e007..5fd934b5da8 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/215/TransactionStore.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/215/TransactionStore.java\n@@ -370,8 +370,9 @@ public class TransactionStore {\n                 }\n                 int mapId = (Integer) op[0];\n                 MVMap<Object, VersionedValue> map = openMap(mapId);\n-                if (map != null) { // might be null if map was removed later\n-                    Object key = op[1];\n+                if (map != null) {\n+            // might be null if map was removed later\n+                Object key = op[1];\n                     VersionedValue value = map.get(key);\n                     if (value != null) {\n                         // only commit (remove/update) value if we've reached\n",
            "diff_size": 3
        }
    ],
    "repaired_by": [
        "styler",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "intellij",
        "naturalize",
        "codebuff"
    ]
}