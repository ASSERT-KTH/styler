{
    "project_name": "IQSS-dataverse",
    "error_id": "15",
    "information": {
        "errors": [
            {
                "line": "371",
                "column": "1",
                "severity": "error",
                "message": "File contains tab characters (this is the first instance).",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
            }
        ]
    },
    "source_code": "\n        // size test\n\tint bufferCapacity = buff.capacity();\n\tdbgLog.fine(\"Subsettable Checker: buffer capacity: \"+bufferCapacity);\n\n        if (bufferCapacity < 491) {",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "372",
                    "column": "1",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/15/IngestableDataChecker.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler/15/IngestableDataChecker.java\nindex 5f771d2756b..765882e8971 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/15/IngestableDataChecker.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler/15/IngestableDataChecker.java\n@@ -368,7 +368,7 @@ public class IngestableDataChecker implements java.io.Serializable {\n         }\n \n         // size test\n-\tint bufferCapacity = buff.capacity();\n+       int bufferCapacity = buff.capacity();\n \tdbgLog.fine(\"Subsettable Checker: buffer capacity: \"+bufferCapacity);\n \n         if (bufferCapacity < 491) {\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/15/IngestableDataChecker.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/intellij/15/IngestableDataChecker.java\nindex 5f771d2756b..0b15aa6619f 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/15/IngestableDataChecker.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/intellij/15/IngestableDataChecker.java\n@@ -17,6 +17,7 @@\n    Developed at the Institute for Quantitative Social Science, Harvard University.\n    Version 3.0.\n */\n+\n package edu.harvard.iq.dataverse.ingest;\n \n \n@@ -33,745 +34,739 @@ import org.apache.commons.lang3.builder.*;\n import org.apache.commons.io.IOUtils;\n \n /**\n- * This is a virtually unchanged DVN v2-3 implementation by \n- * @author Akio Sone\n+ * This is a virtually unchanged DVN v2-3 implementation by\n  *\n- * incorporated into 4.0 by \n+ * @author Akio Sone\n+ * <p>\n+ * incorporated into 4.0 by\n  * @author Leonid Andreev\n- * \n  */\n public class IngestableDataChecker implements java.io.Serializable {\n \n-    /**\n-     * \n-     */\n-\n-    // static fields\n-    private static Logger dbgLog = Logger.getLogger(IngestableDataChecker.class.getPackage().getName());\n-\n-    // default format set\n-    private static String[] defaultFormatSet = {\"POR\", \"SAV\", \"DTA\", \"RDA\", \"XPT\"};\n-    private String[] testFormatSet;\n-    // Map that returns a Stata Release number\n-    private static Map<Byte, String> stataReleaseNumber = new HashMap<Byte, String>();\n-    public static String STATA_13_HEADER = \"<stata_dta><header><release>117</release>\";\n-    public static String STATA_14_HEADER = \"<stata_dta><header><release>118</release>\";\n-    public static String STATA_15_HEADER = \"<stata_dta><header><release>119</release>\";\n-    // Map that returns a reader-implemented mime-type\n-    private static Set<String> readableFileTypes = new HashSet<String>();\n-    private static Map<String, Method> testMethods = new HashMap<String, Method>();\n-    public static String SAS_XPT_HEADER_80 = \"HEADER RECORD*******LIBRARY HEADER RECORD!!!!!!!000000000000000000000000000000  \";\n-    public static String SAS_XPT_HEADER_11 = \"SAS     SAS\";\n-    public static int POR_MARK_POSITION_DEFAULT = 461;\n-    public static String POR_MARK = \"SPSSPORT\";\n-    private static int DEFAULT_BUFFER_SIZE = 500;\n-    private static String regex = \"^test(\\\\w+)format$\";\n-\n-    // static initialization block\n-    private static String rdargx = \"^(52)(44)(41|42|58)(31|32|33)(0A)$\";\n-    private static int RDA_HEADER_SIZE = 5;\n-    private static Pattern ptn;\n-\n-\n-    static {\n-\n-        stataReleaseNumber.put((byte) 104, \"rel_3\");\n-        stataReleaseNumber.put((byte) 105, \"rel_4or5\");\n-        stataReleaseNumber.put((byte) 108, \"rel_6\");\n-        stataReleaseNumber.put((byte) 110, \"rel_7first\");\n-        stataReleaseNumber.put((byte) 111, \"rel_7scnd\");\n-        stataReleaseNumber.put((byte) 113, \"rel_8_or_9\");\n-        stataReleaseNumber.put((byte) 114, \"rel_10\");\n-        stataReleaseNumber.put((byte) 115, \"rel_12\"); \n-        // 116 was an in-house experimental version that was never \n-        // released.\n-        // STATA v.13 introduced a new format, 117. It's a completely\n-        // new development, unrelated to the old format. \n-        stataReleaseNumber.put((byte) 117, \"rel_13\");\n-\n-        readableFileTypes.add(\"application/x-stata\");\n-        readableFileTypes.add(\"application/x-spss-sav\");\n-        readableFileTypes.add(\"application/x-spss-por\");\n-        readableFileTypes.add(\"application/x-rlang-transport\");\n-        readableFileTypes.add(\"application/x-stata-13\");\n-        readableFileTypes.add(\"application/x-stata-14\");\n-        readableFileTypes.add(\"application/x-stata-15\");\n-\n-        Pattern p = Pattern.compile(regex);\n-        ptn = Pattern.compile(rdargx);\n-\n-        for (Method m : IngestableDataChecker.class.getDeclaredMethods()) {\n-            //String mname = m.getName();\n-            // if (mname.startsWith(\"test\")) && (mname.endsWith(\"format\")){\n-\n-            Matcher mtr = p.matcher(m.getName());\n-            if (mtr.matches()) {\n-                testMethods.put(mtr.group(1), m);\n-            }\n-        }\n+  /**\n+   *\n+   */\n+\n+  // static fields\n+  private static Logger dbgLog = Logger.getLogger(IngestableDataChecker.class.getPackage().getName());\n+\n+  // default format set\n+  private static String[] defaultFormatSet = {\"POR\", \"SAV\", \"DTA\", \"RDA\", \"XPT\"};\n+  private String[] testFormatSet;\n+  // Map that returns a Stata Release number\n+  private static Map<Byte, String> stataReleaseNumber = new HashMap<Byte, String>();\n+  public static String STATA_13_HEADER = \"<stata_dta><header><release>117</release>\";\n+  public static String STATA_14_HEADER = \"<stata_dta><header><release>118</release>\";\n+  public static String STATA_15_HEADER = \"<stata_dta><header><release>119</release>\";\n+  // Map that returns a reader-implemented mime-type\n+  private static Set<String> readableFileTypes = new HashSet<String>();\n+  private static Map<String, Method> testMethods = new HashMap<String, Method>();\n+  public static String SAS_XPT_HEADER_80 =\n+    \"HEADER RECORD*******LIBRARY HEADER RECORD!!!!!!!000000000000000000000000000000  \";\n+  public static String SAS_XPT_HEADER_11 = \"SAS     SAS\";\n+  public static int POR_MARK_POSITION_DEFAULT = 461;\n+  public static String POR_MARK = \"SPSSPORT\";\n+  private static int DEFAULT_BUFFER_SIZE = 500;\n+  private static String regex = \"^test(\\\\w+)format$\";\n+\n+  // static initialization block\n+  private static String rdargx = \"^(52)(44)(41|42|58)(31|32|33)(0A)$\";\n+  private static int RDA_HEADER_SIZE = 5;\n+  private static Pattern ptn;\n+\n+\n+  static {\n+\n+    stataReleaseNumber.put((byte) 104, \"rel_3\");\n+    stataReleaseNumber.put((byte) 105, \"rel_4or5\");\n+    stataReleaseNumber.put((byte) 108, \"rel_6\");\n+    stataReleaseNumber.put((byte) 110, \"rel_7first\");\n+    stataReleaseNumber.put((byte) 111, \"rel_7scnd\");\n+    stataReleaseNumber.put((byte) 113, \"rel_8_or_9\");\n+    stataReleaseNumber.put((byte) 114, \"rel_10\");\n+    stataReleaseNumber.put((byte) 115, \"rel_12\");\n+    // 116 was an in-house experimental version that was never\n+    // released.\n+    // STATA v.13 introduced a new format, 117. It's a completely\n+    // new development, unrelated to the old format.\n+    stataReleaseNumber.put((byte) 117, \"rel_13\");\n+\n+    readableFileTypes.add(\"application/x-stata\");\n+    readableFileTypes.add(\"application/x-spss-sav\");\n+    readableFileTypes.add(\"application/x-spss-por\");\n+    readableFileTypes.add(\"application/x-rlang-transport\");\n+    readableFileTypes.add(\"application/x-stata-13\");\n+    readableFileTypes.add(\"application/x-stata-14\");\n+    readableFileTypes.add(\"application/x-stata-15\");\n+\n+    Pattern p = Pattern.compile(regex);\n+    ptn = Pattern.compile(rdargx);\n+\n+    for (Method m : IngestableDataChecker.class.getDeclaredMethods()) {\n+      //String mname = m.getName();\n+      // if (mname.startsWith(\"test\")) && (mname.endsWith(\"format\")){\n+\n+      Matcher mtr = p.matcher(m.getName());\n+      if (mtr.matches()) {\n+        testMethods.put(mtr.group(1), m);\n+      }\n     }\n-    private boolean windowsNewLine = true;\n-\n-    // constructors\n-    // using the default format set\n-    public IngestableDataChecker() {\n-        this.testFormatSet = defaultFormatSet;\n+  }\n+\n+  private boolean windowsNewLine = true;\n+\n+  // constructors\n+  // using the default format set\n+  public IngestableDataChecker() {\n+    this.testFormatSet = defaultFormatSet;\n+  }\n+  // using a user-defined customized format set\n+\n+  public IngestableDataChecker(String[] requestedFormatSet) {\n+    this.testFormatSet = requestedFormatSet;\n+    dbgLog.fine(\"SubsettableFileChecker instance=\" + this.toString());\n+  }\n+\n+  // public class methods\n+  public static String[] getDefaultTestFormatSet() {\n+    return defaultFormatSet;\n+  }\n+\n+  /**\n+   * print the usage\n+   */\n+  public static void printUsage() {\n+    out.println(\"Usage : java subsettableFileChecker <datafileName>\");\n+  }\n+\n+  // instance methods\n+  public String[] getTestFormatSet() {\n+    return this.testFormatSet;\n+  }\n+\n+  // test methods start here ------------------------------------------------\n+\n+  /**\n+   * test this byte buffer against SPSS-SAV spec\n+   */\n+  public String testSAVformat(MappedByteBuffer buff) {\n+    String result = null;\n+    buff.rewind();\n+    boolean DEBUG = false;\n+\n+\n+    // -----------------------------------------\n+    // Avoid java.nio.BufferUnderflowException\n+    // -----------------------------------------\n+    if (buff.capacity() < 4) {\n+      return null;\n     }\n-    // using a user-defined customized format set\n \n-    public IngestableDataChecker(String[] requestedFormatSet) {\n-        this.testFormatSet = requestedFormatSet;\n-        dbgLog.fine(\"SubsettableFileChecker instance=\" + this.toString());\n+    if (DEBUG) {\n+      out.println(\"applying the sav test\\n\");\n     }\n \n-    // public class methods\n-    public static String[] getDefaultTestFormatSet() {\n-        return defaultFormatSet;\n-    }\n+    byte[] hdr4 = new byte[4];\n+    buff.get(hdr4, 0, 4);\n+    String hdr4sav = new String(hdr4);\n \n-    /**\n-     *  print the usage\n-     *\n-     */\n-    public static void printUsage() {\n-        out.println(\"Usage : java subsettableFileChecker <datafileName>\");\n+    if (DEBUG) {\n+      out.println(\"from string=\" + hdr4sav);\n     }\n-\n-    // instance methods\n-    public String[] getTestFormatSet() {\n-        return this.testFormatSet;\n+    if (hdr4sav.equals(\"$FL2\")) {\n+      if (DEBUG) {\n+        out.println(\"this file is spss-sav type\");\n+      }\n+      result = \"application/x-spss-sav\";\n+    } else {\n+      if (DEBUG) {\n+        out.println(\"this file is NOT spss-sav type\");\n+      }\n     }\n \n-    // test methods start here ------------------------------------------------\n-    /**\n-     * test this byte buffer against SPSS-SAV spec\n-     *\n-     *\n-     */\n-    public String testSAVformat(MappedByteBuffer buff) {\n-        String result = null;\n-        buff.rewind();\n-        boolean DEBUG = false;\n-\n-        \n-        // -----------------------------------------\n-        // Avoid java.nio.BufferUnderflowException\n-        // -----------------------------------------\n-        if (buff.capacity() < 4){\n-            return null;\n-        }\n-        \n-        if (DEBUG) {\n-            out.println(\"applying the sav test\\n\");\n-        }\n+    return result;\n+  }\n \n-        byte[] hdr4 = new byte[4];\n-        buff.get(hdr4, 0, 4);\n-        String hdr4sav = new String(hdr4);\n \n-        if (DEBUG) {\n-            out.println(\"from string=\" + hdr4sav);\n-        }\n-        if (hdr4sav.equals(\"$FL2\")) {\n-            if (DEBUG) {\n-                out.println(\"this file is spss-sav type\");\n-            }\n-            result = \"application/x-spss-sav\";\n-        } else {\n-            if (DEBUG) {\n-                out.println(\"this file is NOT spss-sav type\");\n-            }\n-        }\n-        \n-        return result;\n-    }\n+  /**\n+   * test this byte buffer against STATA DTA spec\n+   */\n+  public String testDTAformat(MappedByteBuffer buff) {\n+    String result = null;\n+    buff.rewind();\n+    boolean DEBUG = false;\n \n-    \n-    /**\n-     * test this byte buffer against STATA DTA spec\n-     *\n-     */\n-    public String testDTAformat(MappedByteBuffer buff) {\n-        String result = null;\n-        buff.rewind();\n-        boolean DEBUG = false;\n+    if (DEBUG) {\n+      dbgLog.info(\"applying the dta test\\n\");\n+    }\n \n-        if (DEBUG) {\n-            dbgLog.info(\"applying the dta test\\n\");\n-        }\n+    // -----------------------------------------\n+    // Avoid java.nio.BufferUnderflowException\n+    // -----------------------------------------\n+    if (buff.capacity() < 4) {\n+      return result;\n+    }\n \n-        // -----------------------------------------\n-        // Avoid java.nio.BufferUnderflowException\n-        // -----------------------------------------\n-        if (buff.capacity() < 4) {            \n-            return result;\n-        }\n-        \n-        // We first check if it's a \"classic\", old DTA format \n-        // (up to version 115): \n-        \n-        byte[] hdr4 = new byte[4];\n-        buff.get(hdr4, 0, 4);\n-        \n-        if (DEBUG) {\n-            for (int i = 0; i < hdr4.length; ++i) {\n-                dbgLog.info(String.format(\"%d\\t%02X\\n\", i, hdr4[i]));\n-            }\n-        }\n+    // We first check if it's a \"classic\", old DTA format\n+    // (up to version 115):\n \n-        if (hdr4[2] != 1) {\n-            if (DEBUG) {\n-                dbgLog.info(\"3rd byte is not 1: given file is not stata-dta type\");\n-            }\n-            //return result;\n-        } else if ((hdr4[1] != 1) && (hdr4[1] != 2)) {\n-            if (DEBUG) {\n-                dbgLog.info(\"2nd byte is neither 0 nor 1: this file is not stata-dta type\");\n-            }\n-            //return result;\n-        } else if (!IngestableDataChecker.stataReleaseNumber.containsKey(hdr4[0])) {\n-            if (DEBUG) {\n-                dbgLog.info(\"1st byte (\" + hdr4[0] +\n-                    \") is not within the ingestable range [rel. 3-10]: this file is NOT stata-dta type\");\n-            }\n-            //return result;\n-        } else {\n-            if (DEBUG) {\n-                dbgLog.info(\"this file is stata-dta type: \" +\n-                    IngestableDataChecker.stataReleaseNumber.get(hdr4[0]) +\n-                    \"(No in HEX=\" + hdr4[0] + \")\");\n-            }\n-            result = \"application/x-stata\";\n-        }\n-        \n-        if ((result == null)&&(buff.capacity() >= STATA_13_HEADER.length())) {\n-            // Let's see if it's a \"new\" STATA (v.13+) format: \n-            buff.rewind();\n-            byte[] headerBuffer = null; \n-            String headerString = null; \n-            try {\n-                headerBuffer = new byte[STATA_13_HEADER.length()];\n-                buff.get(headerBuffer, 0, STATA_13_HEADER.length());\n-                headerString = new String(headerBuffer, \"US-ASCII\");\n-            } catch (Exception ex) {\n-                // probably a buffer underflow exception; \n-                // we don't have to do anything... null will \n-                // be returned, below. \n-            }\n-            \n-            if (STATA_13_HEADER.equals(headerString)) {\n-                result = \"application/x-stata-13\";\n-            }\n-            \n-        }\n+    byte[] hdr4 = new byte[4];\n+    buff.get(hdr4, 0, 4);\n \n-        if ((result == null) && (buff.capacity() >= STATA_14_HEADER.length())) {\n-            // Let's see if it's a \"new\" STATA (v.14+) format:\n-            buff.rewind();\n-            byte[] headerBuffer = null;\n-            String headerString = null;\n-            try {\n-                headerBuffer = new byte[STATA_14_HEADER.length()];\n-                buff.get(headerBuffer, 0, STATA_14_HEADER.length());\n-                headerString = new String(headerBuffer, \"US-ASCII\");\n-            } catch (Exception ex) {\n-                // probably a buffer underflow exception;\n-                // we don't have to do anything... null will\n-                // be returned, below.\n-            }\n-            if (STATA_14_HEADER.equals(headerString)) {\n-                result = \"application/x-stata-14\";\n-            }\n-        }\n-\n-        if ((result == null) && (buff.capacity() >= STATA_15_HEADER.length())) {\n-            // Let's see if it's a \"new\" STATA (v.14+) format:\n-            buff.rewind();\n-            byte[] headerBuffer = null;\n-            String headerString = null;\n-            try {\n-                headerBuffer = new byte[STATA_15_HEADER.length()];\n-                buff.get(headerBuffer, 0, STATA_15_HEADER.length());\n-                headerString = new String(headerBuffer, \"US-ASCII\");\n-            } catch (Exception ex) {\n-                // probably a buffer underflow exception;\n-                // we don't have to do anything... null will\n-                // be returned, below.\n-            }\n-            if (STATA_15_HEADER.equals(headerString)) {\n-                result = \"application/x-stata-15\";\n-            }\n-        }\n+    if (DEBUG) {\n+      for (int i = 0; i < hdr4.length; ++i) {\n+        dbgLog.info(String.format(\"%d\\t%02X\\n\", i, hdr4[i]));\n+      }\n+    }\n \n-        return result;\n+    if (hdr4[2] != 1) {\n+      if (DEBUG) {\n+        dbgLog.info(\"3rd byte is not 1: given file is not stata-dta type\");\n+      }\n+      //return result;\n+    } else if ((hdr4[1] != 1) && (hdr4[1] != 2)) {\n+      if (DEBUG) {\n+        dbgLog.info(\"2nd byte is neither 0 nor 1: this file is not stata-dta type\");\n+      }\n+      //return result;\n+    } else if (!IngestableDataChecker.stataReleaseNumber.containsKey(hdr4[0])) {\n+      if (DEBUG) {\n+        dbgLog.info(\"1st byte (\" + hdr4[0] +\n+          \") is not within the ingestable range [rel. 3-10]: this file is NOT stata-dta type\");\n+      }\n+      //return result;\n+    } else {\n+      if (DEBUG) {\n+        dbgLog.info(\"this file is stata-dta type: \" +\n+          IngestableDataChecker.stataReleaseNumber.get(hdr4[0]) +\n+          \"(No in HEX=\" + hdr4[0] + \")\");\n+      }\n+      result = \"application/x-stata\";\n     }\n \n-    /**\n-     * test this byte buffer against SAS Transport(XPT) spec\n-     *\n-     */\n-    public String testXPTformat(MappedByteBuffer buff) {\n-        String result = null;\n-        buff.rewind();\n-        boolean DEBUG = false;\n+    if ((result == null) && (buff.capacity() >= STATA_13_HEADER.length())) {\n+      // Let's see if it's a \"new\" STATA (v.13+) format:\n+      buff.rewind();\n+      byte[] headerBuffer = null;\n+      String headerString = null;\n+      try {\n+        headerBuffer = new byte[STATA_13_HEADER.length()];\n+        buff.get(headerBuffer, 0, STATA_13_HEADER.length());\n+        headerString = new String(headerBuffer, \"US-ASCII\");\n+      } catch (Exception ex) {\n+        // probably a buffer underflow exception;\n+        // we don't have to do anything... null will\n+        // be returned, below.\n+      }\n+\n+      if (STATA_13_HEADER.equals(headerString)) {\n+        result = \"application/x-stata-13\";\n+      }\n \n-        if (DEBUG) {\n-            out.println(\"applying the sas-transport test\\n\");\n-        }\n-        // size test\n-        if (buff.capacity() < 91) {\n-            if (DEBUG) {\n-                out.println(\"this file is NOT sas-exort type\\n\");\n-            }\n+    }\n \n-            return result;\n-        }\n+    if ((result == null) && (buff.capacity() >= STATA_14_HEADER.length())) {\n+      // Let's see if it's a \"new\" STATA (v.14+) format:\n+      buff.rewind();\n+      byte[] headerBuffer = null;\n+      String headerString = null;\n+      try {\n+        headerBuffer = new byte[STATA_14_HEADER.length()];\n+        buff.get(headerBuffer, 0, STATA_14_HEADER.length());\n+        headerString = new String(headerBuffer, \"US-ASCII\");\n+      } catch (Exception ex) {\n+        // probably a buffer underflow exception;\n+        // we don't have to do anything... null will\n+        // be returned, below.\n+      }\n+      if (STATA_14_HEADER.equals(headerString)) {\n+        result = \"application/x-stata-14\";\n+      }\n+    }\n \n-        byte[] hdr1 = new byte[80];\n-        byte[] hdr2 = new byte[11];\n-        buff.get(hdr1, 0, 80);\n-        buff.get(hdr2, 0, 11);\n+    if ((result == null) && (buff.capacity() >= STATA_15_HEADER.length())) {\n+      // Let's see if it's a \"new\" STATA (v.14+) format:\n+      buff.rewind();\n+      byte[] headerBuffer = null;\n+      String headerString = null;\n+      try {\n+        headerBuffer = new byte[STATA_15_HEADER.length()];\n+        buff.get(headerBuffer, 0, STATA_15_HEADER.length());\n+        headerString = new String(headerBuffer, \"US-ASCII\");\n+      } catch (Exception ex) {\n+        // probably a buffer underflow exception;\n+        // we don't have to do anything... null will\n+        // be returned, below.\n+      }\n+      if (STATA_15_HEADER.equals(headerString)) {\n+        result = \"application/x-stata-15\";\n+      }\n+    }\n \n-        String hdr1st80 = new String(hdr1);\n-        String hdrnxt11 = new String(hdr2);\n+    return result;\n+  }\n \n-        if (DEBUG) {\n-            out.println(\"1st-80  bytes=\" + hdr1st80);\n-            out.println(\"next-11 bytes=\" + hdrnxt11);\n-        }\n+  /**\n+   * test this byte buffer against SAS Transport(XPT) spec\n+   */\n+  public String testXPTformat(MappedByteBuffer buff) {\n+    String result = null;\n+    buff.rewind();\n+    boolean DEBUG = false;\n \n-        if ((hdr1st80.equals(IngestableDataChecker.SAS_XPT_HEADER_80)) &&\n-            (hdrnxt11.equals(IngestableDataChecker.SAS_XPT_HEADER_11))) {\n-            if (DEBUG) {\n-                out.println(\"this file is sas-export type\\n\");\n-            }\n-            result = \"application/x-sas-xport\";\n-        } else {\n-            if (DEBUG) {\n-                out.println(\"this file is NOT sas-exort type\\n\");\n-            }\n-        }\n-        return result;\n+    if (DEBUG) {\n+      out.println(\"applying the sas-transport test\\n\");\n     }\n+    // size test\n+    if (buff.capacity() < 91) {\n+      if (DEBUG) {\n+        out.println(\"this file is NOT sas-exort type\\n\");\n+      }\n \n-    /**\n-     * test this byte buffer against SPSS Portable (POR) spec\n-     *\n-     */\n-    public String testPORformat(MappedByteBuffer buff) {\n-        String result = null;\n-        buff.rewind();\n-        boolean DEBUG = false;\n+      return result;\n+    }\n \n-        if (DEBUG) {\n-            out.println(\"applying the spss-por test\\n\");\n-        }\n+    byte[] hdr1 = new byte[80];\n+    byte[] hdr2 = new byte[11];\n+    buff.get(hdr1, 0, 80);\n+    buff.get(hdr2, 0, 11);\n \n-        // size test\n-\tint bufferCapacity = buff.capacity();\n-\tdbgLog.fine(\"Subsettable Checker: buffer capacity: \"+bufferCapacity);\n+    String hdr1st80 = new String(hdr1);\n+    String hdrnxt11 = new String(hdr2);\n \n-        if (bufferCapacity < 491) {\n-            if (DEBUG) {\n-                out.println(\"this file is NOT spss-por type\\n\");\n-            }\n+    if (DEBUG) {\n+      out.println(\"1st-80  bytes=\" + hdr1st80);\n+      out.println(\"next-11 bytes=\" + hdrnxt11);\n+    }\n \n-            return result;\n-        }\n+    if ((hdr1st80.equals(IngestableDataChecker.SAS_XPT_HEADER_80)) &&\n+      (hdrnxt11.equals(IngestableDataChecker.SAS_XPT_HEADER_11))) {\n+      if (DEBUG) {\n+        out.println(\"this file is sas-export type\\n\");\n+      }\n+      result = \"application/x-sas-xport\";\n+    } else {\n+      if (DEBUG) {\n+        out.println(\"this file is NOT sas-exort type\\n\");\n+      }\n+    }\n+    return result;\n+  }\n+\n+  /**\n+   * test this byte buffer against SPSS Portable (POR) spec\n+   */\n+  public String testPORformat(MappedByteBuffer buff) {\n+    String result = null;\n+    buff.rewind();\n+    boolean DEBUG = false;\n+\n+    if (DEBUG) {\n+      out.println(\"applying the spss-por test\\n\");\n+    }\n \n-        //windows [0D0A]=>   [1310] = [CR/LF]\n-        //unix    [0A]  =>   [10]\n-        //mac     [0D]  =>   [13]\n-        // 3char  [0D0D0A]=> [131310] spss for windows rel 15\n-        // expected results\n-        // unix    case: [0A]   : [80], [161], [242], [323], [404], [485]\n-        // windows case: [0D0A] : [81], [163], [245], [327], [409], [491]\n-        //  : [0D0D0A] : [82], [165], [248], [331], [414], [495]\n+    // size test\n+    int bufferCapacity = buff.capacity();\n+    dbgLog.fine(\"Subsettable Checker: buffer capacity: \" + bufferCapacity);\n \n-        buff.rewind();\n-        byte[] nlch = new byte[36];\n-        int pos1;\n-        int pos2;\n-        int pos3;\n-        int ucase = 0;\n-        int wcase = 0;\n-        int mcase = 0;\n-        int three = 0;\n-        int nolines = 6;\n-        int nocols = 80;\n-        for (int i = 0; i < nolines; ++i) {\n-            int baseBias = nocols * (i + 1);\n-            // 1-char case\n-            pos1 = baseBias + i;\n-\n-\t    if ( pos1 > bufferCapacity - 1 ) {\n-\t\tdbgLog.fine(\"Subsettable Checker: request to go beyond buffer capacity (\"+pos1+\")\");\n-\t\treturn result; \n-\t    }\n-\n-            buff.position(pos1);\n-            if (DEBUG) {\n-                out.println(\"\\tposition(1)=\" + buff.position());\n-            }\n-            int j = 6 * i;\n-            nlch[j] = buff.get();\n+    if (bufferCapacity < 491) {\n+      if (DEBUG) {\n+        out.println(\"this file is NOT spss-por type\\n\");\n+      }\n \n-            if (nlch[j] == 10) {\n-                ucase++;\n-            } else if (nlch[j] == 13) {\n-                mcase++;\n-            }\n+      return result;\n+    }\n \n-            // 2-char case\n-            pos2 = baseBias + 2 * i;\n+    //windows [0D0A]=>   [1310] = [CR/LF]\n+    //unix    [0A]  =>   [10]\n+    //mac     [0D]  =>   [13]\n+    // 3char  [0D0D0A]=> [131310] spss for windows rel 15\n+    // expected results\n+    // unix    case: [0A]   : [80], [161], [242], [323], [404], [485]\n+    // windows case: [0D0A] : [81], [163], [245], [327], [409], [491]\n+    //  : [0D0D0A] : [82], [165], [248], [331], [414], [495]\n+\n+    buff.rewind();\n+    byte[] nlch = new byte[36];\n+    int pos1;\n+    int pos2;\n+    int pos3;\n+    int ucase = 0;\n+    int wcase = 0;\n+    int mcase = 0;\n+    int three = 0;\n+    int nolines = 6;\n+    int nocols = 80;\n+    for (int i = 0; i < nolines; ++i) {\n+      int baseBias = nocols * (i + 1);\n+      // 1-char case\n+      pos1 = baseBias + i;\n+\n+      if (pos1 > bufferCapacity - 1) {\n+        dbgLog.fine(\"Subsettable Checker: request to go beyond buffer capacity (\" + pos1 + \")\");\n+        return result;\n+      }\n+\n+      buff.position(pos1);\n+      if (DEBUG) {\n+        out.println(\"\\tposition(1)=\" + buff.position());\n+      }\n+      int j = 6 * i;\n+      nlch[j] = buff.get();\n+\n+      if (nlch[j] == 10) {\n+        ucase++;\n+      } else if (nlch[j] == 13) {\n+        mcase++;\n+      }\n+\n+      // 2-char case\n+      pos2 = baseBias + 2 * i;\n+\n+      if (pos2 > bufferCapacity - 2) {\n+        dbgLog.fine(\"Subsettable Checker: request to read 2 bytes beyond buffer capacity (\" + pos2 + \")\");\n+        return result;\n+      }\n \n-\t    if ( pos2 > bufferCapacity - 2 ) {\n-\t\tdbgLog.fine(\"Subsettable Checker: request to read 2 bytes beyond buffer capacity (\"+pos2+\")\");\n-\t\treturn result; \n-\t    }\n \n+      buff.position(pos2);\n+      if (DEBUG) {\n+        out.println(\"\\tposition(2)=\" + buff.position());\n+      }\n+      nlch[j + 1] = buff.get();\n+      nlch[j + 2] = buff.get();\n \n-            buff.position(pos2);\n-            if (DEBUG) {\n-                out.println(\"\\tposition(2)=\" + buff.position());\n-            }\n-            nlch[j + 1] = buff.get();\n-            nlch[j + 2] = buff.get();\n+      // 3-char case\n+      pos3 = baseBias + 3 * i;\n \n-            // 3-char case\n-            pos3 = baseBias + 3 * i;\n+      if (pos3 > bufferCapacity - 3) {\n+        dbgLog.fine(\"Subsettable Checker: request to read 3 bytes beyond buffer capacity (\" + pos3 + \")\");\n+        return result;\n+      }\n+\n+\n+      buff.position(pos3);\n+      if (DEBUG) {\n+        out.println(\"\\tposition(3)=\" + buff.position());\n+      }\n+      nlch[j + 3] = buff.get();\n+      nlch[j + 4] = buff.get();\n+      nlch[j + 5] = buff.get();\n+\n+      if (DEBUG) {\n+        out.println(i + \"-th iteration position =\" + nlch[j] + \"\\t\" + nlch[j + 1] + \"\\t\" + nlch[j + 2]);\n+        out.println(i + \"-th iteration position =\" + nlch[j + 3] + \"\\t\" + nlch[j + 4] + \"\\t\" + nlch[j + 5]);\n+      }\n+      if ((nlch[j + 3] == 13) && (nlch[j + 4] == 13) && (nlch[j + 5] == 10)) {\n+        three++;\n+      } else if ((nlch[j + 1] == 13) && (nlch[j + 2] == 10)) {\n+        wcase++;\n+      }\n+\n+      buff.rewind();\n+    }\n+    if (three == nolines) {\n+      if (DEBUG) {\n+        out.println(\"0D0D0A case\");\n+      }\n+      windowsNewLine = false;\n+    } else if ((ucase == nolines) && (wcase < nolines)) {\n+      if (DEBUG) {\n+        out.println(\"0A case\");\n+      }\n+      windowsNewLine = false;\n+    } else if ((ucase < nolines) && (wcase == nolines)) {\n+      if (DEBUG) {\n+        out.println(\"0D0A case\");\n+      }\n+    } else if ((mcase == nolines) && (wcase < nolines)) {\n+      if (DEBUG) {\n+        out.println(\"0D case\");\n+      }\n+      windowsNewLine = false;\n+    }\n \n-\t    if ( pos3 > bufferCapacity - 3 ) {\n-\t\tdbgLog.fine(\"Subsettable Checker: request to read 3 bytes beyond buffer capacity (\"+pos3+\")\");\n-\t\treturn result; \n-\t    }\n \n+    buff.rewind();\n+    int PORmarkPosition = POR_MARK_POSITION_DEFAULT;\n+    if (windowsNewLine) {\n+      PORmarkPosition = PORmarkPosition + 5;\n+    } else if (three == nolines) {\n+      PORmarkPosition = PORmarkPosition + 10;\n+    }\n \n-            buff.position(pos3);\n-            if (DEBUG) {\n-                out.println(\"\\tposition(3)=\" + buff.position());\n-            }\n-            nlch[j + 3] = buff.get();\n-            nlch[j + 4] = buff.get();\n-            nlch[j + 5] = buff.get();\n+    byte[] pormark = new byte[8];\n+    buff.position(PORmarkPosition);\n+    buff.get(pormark, 0, 8);\n+    String pormarks = new String(pormark);\n \n-            if (DEBUG) {\n-                out.println(i + \"-th iteration position =\" + nlch[j] + \"\\t\" + nlch[j + 1] + \"\\t\" + nlch[j + 2]);\n-                out.println(i + \"-th iteration position =\" + nlch[j + 3] + \"\\t\" + nlch[j + 4] + \"\\t\" + nlch[j + 5]);\n-            }\n-            if ((nlch[j + 3] == 13) && (nlch[j + 4] == 13) && (nlch[j + 5] == 10)) {\n-                three++;\n-            } else if ((nlch[j + 1] == 13) && (nlch[j + 2] == 10)) {\n-                wcase++;\n-            }\n+    if (DEBUG) {\n+      out.println(\"pormark =>\" + pormarks + \"<-\");\n+    }\n \n-            buff.rewind();\n-        }\n-        if (three == nolines) {\n-            if (DEBUG) {\n-                out.println(\"0D0D0A case\");\n-            }\n-            windowsNewLine = false;\n-        } else if ((ucase == nolines) && (wcase < nolines)) {\n-            if (DEBUG) {\n-                out.println(\"0A case\");\n-            }\n-            windowsNewLine = false;\n-        } else if ((ucase < nolines) && (wcase == nolines)) {\n-            if (DEBUG) {\n-                out.println(\"0D0A case\");\n-            }\n-        } else if ((mcase == nolines) && (wcase < nolines)) {\n-            if (DEBUG) {\n-                out.println(\"0D case\");\n-            }\n-            windowsNewLine = false;\n-        }\n+    if (pormarks.equals(POR_MARK)) {\n+      if (DEBUG) {\n+        out.println(\"this file is spss-por type\");\n+      }\n+      result = \"application/x-spss-por\";\n+    } else {\n+      if (DEBUG) {\n+        out.println(\"this file is NOT spss-por type\");\n+      }\n+    }\n \n+    return result;\n+  }\n \n-        buff.rewind();\n-        int PORmarkPosition = POR_MARK_POSITION_DEFAULT;\n-        if (windowsNewLine) {\n-            PORmarkPosition = PORmarkPosition + 5;\n-        } else if (three == nolines) {\n-            PORmarkPosition = PORmarkPosition + 10;\n-        }\n+  /**\n+   * test this byte buffer against R data file\n+   */\n+  public String testRDAformat(MappedByteBuffer buff) {\n+    String result = null;\n+    buff.rewind();\n \n-        byte[] pormark = new byte[8];\n-        buff.position(PORmarkPosition);\n-        buff.get(pormark, 0, 8);\n-        String pormarks = new String(pormark);\n+    if (buff.capacity() < 4) {\n+      return null;\n+    }\n \n+    boolean DEBUG = false;\n+    if (DEBUG) {\n+      out.println(\"applying the RData test\\n\");\n+      out.println(\"buffer capacity=\" + buff.capacity());\n+    }\n+    if (DEBUG) {\n+      byte[] rawhdr = new byte[4];\n+      buff.get(rawhdr, 0, 4);\n+      for (int j = 0; j < 4; j++) {\n+        out.printf(\"%02X \", rawhdr[j]);\n+      }\n+      out.println();\n+      buff.rewind();\n+    }\n+    // get the first 4 bytes as an int and check its value;\n+    // if it is 0x1F8B0800, then gunzip and its first 4 bytes\n+    int magicNumber = buff.getInt();\n+\n+    if (DEBUG) {\n+      out.println(\"magicNumber in decimal =\" + magicNumber);\n+      out.println(\"in binary=\" + Integer.toBinaryString(magicNumber));\n+      out.println(\"in oct=\" + Integer.toOctalString(magicNumber));\n+      out.println(\"in hex=\" + Integer.toHexString(magicNumber));\n+    }\n+    try {\n+      if (magicNumber == 0x1F8B0800) {\n         if (DEBUG) {\n-            out.println(\"pormark =>\" + pormarks + \"<-\");\n+          out.println(\"magicNumber is GZIP\");\n         }\n+        // gunzip the first 5 bytes and check their bye-pattern\n \n-        if (pormarks.equals(POR_MARK)) {\n-            if (DEBUG) {\n-                out.println(\"this file is spss-por type\");\n-            }\n-            result = \"application/x-spss-por\";\n-        } else {\n-            if (DEBUG) {\n-                out.println(\"this file is NOT spss-por type\");\n-            }\n-        }\n+        // get gzip buffer size\n \n-        return result;\n-    }\n+        int gzip_buffer_size = this.getGzipBufferSize(buff);\n \n-    /**\n-     * test this byte buffer against R data file\n-     *\n-     */\n-    public String testRDAformat(MappedByteBuffer buff) {\n-        String result = null;\n-        buff.rewind();\n-        \n-        if (buff.capacity() < 4){\n-            return null;\n+        byte[] hdr = new byte[gzip_buffer_size];\n+        buff.get(hdr, 0, gzip_buffer_size);\n+\n+        try (GZIPInputStream gzin = new GZIPInputStream(new ByteArrayInputStream(hdr))) {\n+          StringBuilder sb = new StringBuilder();\n+          for (int i = 0; i < RDA_HEADER_SIZE; i++) {\n+            sb.append(String.format(\"%02X\", gzin.read()));\n+          }\n+          String fisrt5bytes = sb.toString();\n+          result = this.checkUncompressedFirst5bytes(fisrt5bytes);\n         }\n-        \n-        boolean DEBUG = false;\n+        // end of compressed case\n+      } else {\n+        // uncompressed case?\n         if (DEBUG) {\n-            out.println(\"applying the RData test\\n\");\n-            out.println(\"buffer capacity=\" + buff.capacity());\n+          out.println(\"magicNumber is not GZIP:\" + magicNumber);\n+          out.println(\"test as an uncompressed RData file\");\n         }\n-        if (DEBUG) {\n-            byte[] rawhdr = new byte[4];\n-            buff.get(rawhdr, 0, 4);\n-            for (int j = 0; j < 4; j++) {\n-                out.printf(\"%02X \", rawhdr[j]);\n-            }\n-            out.println();\n-            buff.rewind();\n-        }\n-        // get the first 4 bytes as an int and check its value; \n-        // if it is 0x1F8B0800, then gunzip and its first 4 bytes\n-        int magicNumber = buff.getInt();\n \n-        if (DEBUG) {\n-            out.println(\"magicNumber in decimal =\" + magicNumber);\n-            out.println(\"in binary=\" + Integer.toBinaryString(magicNumber));\n-            out.println(\"in oct=\" + Integer.toOctalString(magicNumber));\n-            out.println(\"in hex=\" + Integer.toHexString(magicNumber));\n-        }\n-        try {\n-            if (magicNumber == 0x1F8B0800) {\n-                if (DEBUG) {\n-                    out.println(\"magicNumber is GZIP\");\n-                }\n-                // gunzip the first 5 bytes and check their bye-pattern\n-\n-                // get gzip buffer size\n-\n-                int gzip_buffer_size = this.getGzipBufferSize(buff);\n-\n-                byte[] hdr = new byte[gzip_buffer_size];\n-                buff.get(hdr, 0, gzip_buffer_size);\n-\n-                try (GZIPInputStream gzin = new GZIPInputStream(new ByteArrayInputStream(hdr))) {\n-                    StringBuilder sb = new StringBuilder();\n-                    for (int i = 0; i < RDA_HEADER_SIZE; i++) {\n-                        sb.append(String.format(\"%02X\", gzin.read()));\n-                    }\n-                    String fisrt5bytes = sb.toString();\n-                    result = this.checkUncompressedFirst5bytes(fisrt5bytes);\n-                }\n-            // end of compressed case\n-            } else {\n-                // uncompressed case?\n-                if (DEBUG) {\n-                    out.println(\"magicNumber is not GZIP:\" + magicNumber);\n-                    out.println(\"test as an uncompressed RData file\");\n-                }\n-\n-                buff.rewind();\n-                byte[] uchdr = new byte[5];\n-                buff.get(uchdr, 0, 5);\n-                StringBuilder sb = new StringBuilder();\n-                for (int i = 0; i < uchdr.length; i++) {\n-                    sb.append(String.format(\"%02X\", uchdr[i]));\n-                }\n-                String fisrt5bytes = sb.toString();\n-\n-                result = this.checkUncompressedFirst5bytes(fisrt5bytes);\n-            // end of uncompressed case\n-            }\n-        } catch (IOException ex) {\n-            ex.printStackTrace();\n-        }\n-        return result;\n+        buff.rewind();\n+        byte[] uchdr = new byte[5];\n+        buff.get(uchdr, 0, 5);\n+        StringBuilder sb = new StringBuilder();\n+        for (int i = 0; i < uchdr.length; i++) {\n+          sb.append(String.format(\"%02X\", uchdr[i]));\n+        }\n+        String fisrt5bytes = sb.toString();\n+\n+        result = this.checkUncompressedFirst5bytes(fisrt5bytes);\n+        // end of uncompressed case\n+      }\n+    } catch (IOException ex) {\n+      ex.printStackTrace();\n     }\n+    return result;\n+  }\n \n-    // public instance methods ------------------------------------------------\n-    public String detectTabularDataFormat(File fh) {\n-        boolean DEBUG = false;\n-        String readableFormatType = null;\n-        FileChannel srcChannel = null;\n-        FileInputStream inp = null;\n-        try {\n-            int buffer_size = this.getBufferSize(fh);\n-            dbgLog.fine(\"buffer_size: \" + buffer_size);\n-        \n-            // set-up a FileChannel instance for a given file object\n-            inp = new FileInputStream(fh);\n-            srcChannel = inp.getChannel();\n-\n-            // create a read-only MappedByteBuffer\n-            MappedByteBuffer buff = srcChannel.map(FileChannel.MapMode.READ_ONLY, 0, buffer_size);\n-\n-            //this.printHexDump(buff, \"hex dump of the byte-buffer\");\n-\n-            //for (String fmt : defaultFormatSet){\n-            buff.rewind();\n-            dbgLog.fine(\"before the for loop\");\n-            for (String fmt : this.getTestFormatSet()) {\n-                \n-                // get a test method\n-                Method mthd = testMethods.get(fmt);\n-                //dbgLog.info(\"mthd: \" + mthd.getName());\n-\n-                try {\n-                    // invoke this method\n-                    Object retobj = mthd.invoke(this, buff);\n-                    String result = (String) retobj;\n-\n-                    if (result != null) {\n-                        dbgLog.fine(\"result for (\" + fmt + \")=\" + result);\n-                        if (DEBUG) {\n-                            out.println(\"result for (\" + fmt + \")=\" + result);\n-                        }\n-                        if (readableFileTypes.contains(result)) {\n-                            readableFormatType = result;\n-                        }\n-                        dbgLog.fine(\"readableFormatType=\" + readableFormatType);\n-                        return readableFormatType;\n-                    } else {\n-                        dbgLog.fine(\"null was returned for \" + fmt + \" test\");\n-                        if (DEBUG) {\n-                            out.println(\"null was returned for \" + fmt + \" test\");\n-                        }\n-                    }\n-                } catch (InvocationTargetException e) {\n-                    Throwable cause = e.getCause();\n-                    // added null check because of \"homemade.zip\" from https://redmine.hmdc.harvard.edu/issues/3273\n-                    if (cause.getMessage() != null) {\n-                        err.format(cause.getMessage());\n-                        e.printStackTrace();\n-                    } else {\n-                        dbgLog.info(\"cause.getMessage() was null for \" + e);\n-                        e.printStackTrace();\n-                    }\n-                } catch (IllegalAccessException e) {\n-                    e.printStackTrace();\n-                } catch (BufferUnderflowException e){\n-                    dbgLog.info(\"BufferUnderflowException \" + e);\n-                    e.printStackTrace();\n-                }\n-            }\n+  // public instance methods ------------------------------------------------\n+  public String detectTabularDataFormat(File fh) {\n+    boolean DEBUG = false;\n+    String readableFormatType = null;\n+    FileChannel srcChannel = null;\n+    FileInputStream inp = null;\n+    try {\n+      int buffer_size = this.getBufferSize(fh);\n+      dbgLog.fine(\"buffer_size: \" + buffer_size);\n \n-            return readableFormatType;\n+      // set-up a FileChannel instance for a given file object\n+      inp = new FileInputStream(fh);\n+      srcChannel = inp.getChannel();\n \n-        } catch (FileNotFoundException fe) {\n-            dbgLog.fine(\"exception detected: file was not foud\");\n-            fe.printStackTrace();\n-        } catch (IOException ie) {\n-            dbgLog.fine(\"other io exception detected\");\n-            ie.printStackTrace();\n-        } finally {\n-            IOUtils.closeQuietly(srcChannel);\n-            IOUtils.closeQuietly(inp);\n-        }\n-        return readableFormatType;\n-    }\n+      // create a read-only MappedByteBuffer\n+      MappedByteBuffer buff = srcChannel.map(FileChannel.MapMode.READ_ONLY, 0, buffer_size);\n \n-    /**\n-     * identify the first 5 bytes\n-     *\n-     */\n-    private String checkUncompressedFirst5bytes(String fisrt5bytes) {\n-        boolean DEBUG = false;\n-        String result = null;\n-        if (DEBUG) {\n-            out.println(\"first5bytes=\" + fisrt5bytes);\n-        }\n-        Matcher mtr = ptn.matcher(fisrt5bytes);\n+      //this.printHexDump(buff, \"hex dump of the byte-buffer\");\n+\n+      //for (String fmt : defaultFormatSet){\n+      buff.rewind();\n+      dbgLog.fine(\"before the for loop\");\n+      for (String fmt : this.getTestFormatSet()) {\n \n-        if (mtr.matches()) {\n+        // get a test method\n+        Method mthd = testMethods.get(fmt);\n+        //dbgLog.info(\"mthd: \" + mthd.getName());\n+\n+        try {\n+          // invoke this method\n+          Object retobj = mthd.invoke(this, buff);\n+          String result = (String) retobj;\n+\n+          if (result != null) {\n+            dbgLog.fine(\"result for (\" + fmt + \")=\" + result);\n             if (DEBUG) {\n-                out.println(\"RDATA type\");\n+              out.println(\"result for (\" + fmt + \")=\" + result);\n             }\n-            result = \"application/x-rlang-transport\";\n-        } else {\n-            if (DEBUG) {\n-                out.println(\"not binary RDATA type\");\n+            if (readableFileTypes.contains(result)) {\n+              readableFormatType = result;\n             }\n-        }\n-\n-        return result;\n+            dbgLog.fine(\"readableFormatType=\" + readableFormatType);\n+            return readableFormatType;\n+          } else {\n+            dbgLog.fine(\"null was returned for \" + fmt + \" test\");\n+            if (DEBUG) {\n+              out.println(\"null was returned for \" + fmt + \" test\");\n+            }\n+          }\n+        } catch (InvocationTargetException e) {\n+          Throwable cause = e.getCause();\n+          // added null check because of \"homemade.zip\" from https://redmine.hmdc.harvard.edu/issues/3273\n+          if (cause.getMessage() != null) {\n+            err.format(cause.getMessage());\n+            e.printStackTrace();\n+          } else {\n+            dbgLog.info(\"cause.getMessage() was null for \" + e);\n+            e.printStackTrace();\n+          }\n+        } catch (IllegalAccessException e) {\n+          e.printStackTrace();\n+        } catch (BufferUnderflowException e) {\n+          dbgLog.info(\"BufferUnderflowException \" + e);\n+          e.printStackTrace();\n+        }\n+      }\n+\n+      return readableFormatType;\n+\n+    } catch (FileNotFoundException fe) {\n+      dbgLog.fine(\"exception detected: file was not foud\");\n+      fe.printStackTrace();\n+    } catch (IOException ie) {\n+      dbgLog.fine(\"other io exception detected\");\n+      ie.printStackTrace();\n+    } finally {\n+      IOUtils.closeQuietly(srcChannel);\n+      IOUtils.closeQuietly(inp);\n+    }\n+    return readableFormatType;\n+  }\n+\n+  /**\n+   * identify the first 5 bytes\n+   */\n+  private String checkUncompressedFirst5bytes(String fisrt5bytes) {\n+    boolean DEBUG = false;\n+    String result = null;\n+    if (DEBUG) {\n+      out.println(\"first5bytes=\" + fisrt5bytes);\n+    }\n+    Matcher mtr = ptn.matcher(fisrt5bytes);\n+\n+    if (mtr.matches()) {\n+      if (DEBUG) {\n+        out.println(\"RDATA type\");\n+      }\n+      result = \"application/x-rlang-transport\";\n+    } else {\n+      if (DEBUG) {\n+        out.println(\"not binary RDATA type\");\n+      }\n     }\n \n-    /**\n-     * adjust the size of the buffer according to the size of \n-     * the file if necessary; otherwise, use the default size\n-     */\n-    private int getBufferSize(File fh) {\n-        boolean DEBUG = false;\n-        int BUFFER_SIZE = DEFAULT_BUFFER_SIZE;\n-        if (fh.length() < DEFAULT_BUFFER_SIZE) {\n-            BUFFER_SIZE = (int) fh.length();\n-            if (DEBUG) {\n-                out.println(\"non-default buffer_size: new size=\" + BUFFER_SIZE);\n-            }\n-        }\n-        return BUFFER_SIZE;\n+    return result;\n+  }\n+\n+  /**\n+   * adjust the size of the buffer according to the size of\n+   * the file if necessary; otherwise, use the default size\n+   */\n+  private int getBufferSize(File fh) {\n+    boolean DEBUG = false;\n+    int BUFFER_SIZE = DEFAULT_BUFFER_SIZE;\n+    if (fh.length() < DEFAULT_BUFFER_SIZE) {\n+      BUFFER_SIZE = (int) fh.length();\n+      if (DEBUG) {\n+        out.println(\"non-default buffer_size: new size=\" + BUFFER_SIZE);\n+      }\n     }\n+    return BUFFER_SIZE;\n+  }\n \n-    private int getGzipBufferSize(MappedByteBuffer buff) {\n-        int GZIP_BUFFER_SIZE = 120;\n+  private int getGzipBufferSize(MappedByteBuffer buff) {\n+    int GZIP_BUFFER_SIZE = 120;\n         /*\n         note:\n         gzip buffer size <= 118  causes \"java.io.EOFException:\n         Unexpected end of ZLIB input stream\"\n         with a byte buffer of 500 bytes\n          */\n-        // adjust gzip buffer size if necessary\n-        // file.size might be less than the default gzip buffer size\n-        if (buff.capacity() < GZIP_BUFFER_SIZE) {\n-            GZIP_BUFFER_SIZE = buff.capacity();\n-        }\n-        buff.rewind();\n-        return GZIP_BUFFER_SIZE;\n+    // adjust gzip buffer size if necessary\n+    // file.size might be less than the default gzip buffer size\n+    if (buff.capacity() < GZIP_BUFFER_SIZE) {\n+      GZIP_BUFFER_SIZE = buff.capacity();\n     }\n-\n-    /**\n-     * dump the data buffer in HEX\n-     *\n-     */\n-    public void printHexDump(MappedByteBuffer buff, String hdr) {\n-        int counter = 0;\n-        if (hdr != null) {\n-            out.println(hdr);\n-        }\n-        for (int i = 0; i < buff.capacity(); i++) {\n-            counter = i + 1;\n-            out.print(String.format(\"%02X \", buff.get()));\n-            if (counter % 16 == 0) {\n-                out.println();\n-            } else {\n-                if (counter % 8 == 0) {\n-                    out.print(\" \");\n-                }\n-            }\n-        }\n-        out.println();\n-        buff.rewind();\n+    buff.rewind();\n+    return GZIP_BUFFER_SIZE;\n+  }\n+\n+  /**\n+   * dump the data buffer in HEX\n+   */\n+  public void printHexDump(MappedByteBuffer buff, String hdr) {\n+    int counter = 0;\n+    if (hdr != null) {\n+      out.println(hdr);\n     }\n-\n-    @Override\n-    public String toString() {\n-        return ToStringBuilder.reflectionToString(this,\n-            ToStringStyle.MULTI_LINE_STYLE);\n+    for (int i = 0; i < buff.capacity(); i++) {\n+      counter = i + 1;\n+      out.print(String.format(\"%02X \", buff.get()));\n+      if (counter % 16 == 0) {\n+        out.println();\n+      } else {\n+        if (counter % 8 == 0) {\n+          out.print(\" \");\n+        }\n+      }\n     }\n+    out.println();\n+    buff.rewind();\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return ToStringBuilder.reflectionToString(this,\n+      ToStringStyle.MULTI_LINE_STYLE);\n+  }\n }\n",
            "diff_size": 1029
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "372",
                    "column": "1",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/15/IngestableDataChecker.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_random/15/IngestableDataChecker.java\nindex 5f771d2756b..765882e8971 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/15/IngestableDataChecker.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_random/15/IngestableDataChecker.java\n@@ -368,7 +368,7 @@ public class IngestableDataChecker implements java.io.Serializable {\n         }\n \n         // size test\n-\tint bufferCapacity = buff.capacity();\n+       int bufferCapacity = buff.capacity();\n \tdbgLog.fine(\"Subsettable Checker: buffer capacity: \"+bufferCapacity);\n \n         if (bufferCapacity < 491) {\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "372",
                    "column": "1",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/15/IngestableDataChecker.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_three_grams/15/IngestableDataChecker.java\nindex 5f771d2756b..8964ebd2250 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/15/IngestableDataChecker.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_three_grams/15/IngestableDataChecker.java\n@@ -368,7 +368,7 @@ public class IngestableDataChecker implements java.io.Serializable {\n         }\n \n         // size test\n-\tint bufferCapacity = buff.capacity();\n+        int bufferCapacity = buff.capacity();\n \tdbgLog.fine(\"Subsettable Checker: buffer capacity: \"+bufferCapacity);\n \n         if (bufferCapacity < 491) {\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "intellij"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}