{
    "project_name": "zanata-zanata-platform",
    "error_id": "56",
    "information": {
        "errors": [
            {
                "line": "314",
                "column": "24",
                "severity": "error",
                "message": "Don't use trailing comments.",
                "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
            }
        ]
    },
    "source_code": "\n    public void validateSuppliedId() {\n        getInstance(); // this will raise an EntityNotFound exception\n        // when id is invalid and conversation will not\n        // start\n    }",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/56/VersionHome.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/styler/56/VersionHome.java\nindex f56a7f4056e..ce4f11c0706 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/56/VersionHome.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/styler/56/VersionHome.java\n@@ -311,8 +311,9 @@ public class VersionHome extends SlugHome<HProjectIteration>\n     }\n \n     public void validateSuppliedId() {\n-        getInstance(); // this will raise an EntityNotFound exception\n-        // when id is invalid and conversation will not\n+        getInstance();\n+        // this will raise an EntityNotFound exception\n+         // when id is invalid and conversation will not\n         // start\n     }\n \n",
            "diff_size": 3
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "315",
                    "column": "20",
                    "severity": "error",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/56/VersionHome.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/intellij/56/VersionHome.java\nindex f56a7f4056e..dfa604e8636 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/56/VersionHome.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/intellij/56/VersionHome.java\n@@ -19,6 +19,7 @@\n  *  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA, or see the FSF\n  *  * site: http://www.fsf.org.\n  */\n+\n package org.zanata.action;\n \n import static com.google.common.base.Strings.isNullOrEmpty;\n@@ -85,1009 +86,1006 @@ import java.util.stream.Collectors;\n @Model\n @Transactional\n public class VersionHome extends SlugHome<HProjectIteration>\n-        implements HasLanguageSettings, Serializable {\n-    private static final org.slf4j.Logger log =\n-            org.slf4j.LoggerFactory.getLogger(VersionHome.class);\n-    private static final long serialVersionUID = 1L;\n-\n-    /**\n-     * This field is set from form input which can differ from original slug\n-     */\n-    @Nullable\n-    private String inputSlugValue;\n-    private Long versionId;\n-    @Inject\n-    @Any\n-    private ProjectAndVersionSlug projectAndVersionSlug;\n-    @Inject\n-    private FacesMessages facesMessages;\n-    @Inject\n-    private ProjectIterationDAO projectIterationDAO;\n-    @Inject\n-    private LocaleDAO localeDAO;\n-    @Inject\n-    private LocaleService localeServiceImpl;\n-    @Inject\n-    private ValidationService validationServiceImpl;\n-    @Inject\n-    private SlugEntityService slugEntityServiceImpl;\n-    @Inject\n-    private ProjectDAO projectDAO;\n-    @Inject\n-    private Messages msgs;\n-    @Inject\n-    private CopyVersionManager copyVersionManager;\n-    @Inject\n-    private UrlUtil urlUtil;\n-    @Inject\n-    private ZanataIdentity identity;\n-    @Inject\n-    private WebhookServiceImpl webhookServiceImpl;\n-    @SuppressFBWarnings(\"SE_BAD_FIELD\")\n-    private Map<ValidationId, ValidationAction> availableValidations =\n-            Maps.newHashMap();\n-    private boolean isNewInstance = false;\n-    private String selectedProjectType;\n-    private boolean copyFromVersion = true;\n-    private String copyFromVersionSlug;\n-\n-    private void setDefaultCopyFromVersion() {\n-        List<VersionItem> otherVersions = getOtherVersions();\n-        if (!otherVersions.isEmpty()\n-                && isEmpty(copyFromVersionSlug)) {\n-            this.copyFromVersionSlug =\n-                    otherVersions.get(0).getVersion().getSlug();\n-            copyFromVersion = true;\n-        } else {\n-            copyFromVersion = false;\n-        }\n-    }\n-\n-    public VersionHome() {\n-        setEntityClass(HProjectIteration.class);\n-    }\n-\n-    public void init(boolean isNewInstance) {\n-        this.isNewInstance = isNewInstance;\n-        if (isNewInstance) {\n-            String projectSlug = getProjectSlug();\n-            clearSlugs();\n-            setProjectSlug(projectSlug);\n-            if (!identity.hasPermission(getProject(), \"read\")) {\n-                throw new EntityNotFoundException();\n-            }\n-            identity.checkPermission(getProject(), \"insert\");\n-            ProjectType projectType = getProject().getDefaultProjectType();\n-            if (projectType != null) {\n-                selectedProjectType = projectType.name();\n-            }\n-            if (isEmpty(copyFromVersionSlug)) {\n-                setDefaultCopyFromVersion();\n-            }\n-        } else {\n-            if (!identity.hasPermission(getInstance(), \"read\")) {\n-                throw new EntityNotFoundException();\n-            }\n-            copyFromVersion = false;\n-            ProjectType versionProjectType = getInstance().getProjectType();\n-            if (versionProjectType != null) {\n-                selectedProjectType = versionProjectType.name();\n-            }\n-            copyFromVersionSlug = \"\";\n-            enteredLocaleAliases.putAll(getLocaleAliases());\n-        }\n-    }\n-\n-    public HProject getProject() {\n-        return projectDAO.getBySlug(getProjectSlug());\n-    }\n-\n-    public String getProjectSlug() {\n-        return projectAndVersionSlug.getProjectSlug();\n-    }\n-\n-    public void setProjectSlug(String slug) {\n-        projectAndVersionSlug.setProjectSlug(slug);\n-    }\n-\n-    public String getSlug() {\n-        return projectAndVersionSlug.getVersionSlug();\n-    }\n-\n-    public List<VersionItem> getOtherVersions() {\n-        HProject project = getProject();\n-        if (project != null) {\n-            List<HProjectIteration> versionList =\n-                    projectIterationDAO.getByProjectSlug(getProjectSlug(),\n-                            EntityStatus.ACTIVE, EntityStatus.READONLY);\n-            versionList.sort(ComparatorUtil.VERSION_CREATION_DATE_COMPARATOR);\n-            List<VersionItem> versionItems =\n-                    versionList.stream().map(this::makeVersionItem)\n-                            .collect(Collectors.toList());\n-            if (isEmpty(copyFromVersionSlug) && !versionItems.isEmpty()) {\n-                versionItems.get(0).setSelected(true);\n-            }\n-            return versionItems;\n-        }\n-        return Collections.emptyList();\n-    }\n-\n-    private VersionItem makeVersionItem(HProjectIteration iter) {\n-        boolean selected = StringUtils.isNotEmpty(copyFromVersionSlug) &&\n-                copyFromVersionSlug.equals(iter.getSlug());\n-        return new VersionItem(selected, iter);\n-    }\n-\n-    public static class VersionItem {\n-        private boolean selected;\n-        private HProjectIteration version;\n-\n-        public boolean isSelected() {\n-            return this.selected;\n+  implements HasLanguageSettings, Serializable {\n+  private static final org.slf4j.Logger log =\n+    org.slf4j.LoggerFactory.getLogger(VersionHome.class);\n+  private static final long serialVersionUID = 1L;\n+\n+  /**\n+   * This field is set from form input which can differ from original slug\n+   */\n+  @Nullable\n+  private String inputSlugValue;\n+  private Long versionId;\n+  @Inject\n+  @Any\n+  private ProjectAndVersionSlug projectAndVersionSlug;\n+  @Inject\n+  private FacesMessages facesMessages;\n+  @Inject\n+  private ProjectIterationDAO projectIterationDAO;\n+  @Inject\n+  private LocaleDAO localeDAO;\n+  @Inject\n+  private LocaleService localeServiceImpl;\n+  @Inject\n+  private ValidationService validationServiceImpl;\n+  @Inject\n+  private SlugEntityService slugEntityServiceImpl;\n+  @Inject\n+  private ProjectDAO projectDAO;\n+  @Inject\n+  private Messages msgs;\n+  @Inject\n+  private CopyVersionManager copyVersionManager;\n+  @Inject\n+  private UrlUtil urlUtil;\n+  @Inject\n+  private ZanataIdentity identity;\n+  @Inject\n+  private WebhookServiceImpl webhookServiceImpl;\n+  @SuppressFBWarnings(\"SE_BAD_FIELD\")\n+  private Map<ValidationId, ValidationAction> availableValidations =\n+    Maps.newHashMap();\n+  private boolean isNewInstance = false;\n+  private String selectedProjectType;\n+  private boolean copyFromVersion = true;\n+  private String copyFromVersionSlug;\n+\n+  private void setDefaultCopyFromVersion() {\n+    List<VersionItem> otherVersions = getOtherVersions();\n+    if (!otherVersions.isEmpty()\n+      && isEmpty(copyFromVersionSlug)) {\n+      this.copyFromVersionSlug =\n+        otherVersions.get(0).getVersion().getSlug();\n+      copyFromVersion = true;\n+    } else {\n+      copyFromVersion = false;\n+    }\n+  }\n+\n+  public VersionHome() {\n+    setEntityClass(HProjectIteration.class);\n+  }\n+\n+  public void init(boolean isNewInstance) {\n+    this.isNewInstance = isNewInstance;\n+    if (isNewInstance) {\n+      String projectSlug = getProjectSlug();\n+      clearSlugs();\n+      setProjectSlug(projectSlug);\n+      if (!identity.hasPermission(getProject(), \"read\")) {\n+        throw new EntityNotFoundException();\n+      }\n+      identity.checkPermission(getProject(), \"insert\");\n+      ProjectType projectType = getProject().getDefaultProjectType();\n+      if (projectType != null) {\n+        selectedProjectType = projectType.name();\n+      }\n+      if (isEmpty(copyFromVersionSlug)) {\n+        setDefaultCopyFromVersion();\n+      }\n+    } else {\n+      if (!identity.hasPermission(getInstance(), \"read\")) {\n+        throw new EntityNotFoundException();\n+      }\n+      copyFromVersion = false;\n+      ProjectType versionProjectType = getInstance().getProjectType();\n+      if (versionProjectType != null) {\n+        selectedProjectType = versionProjectType.name();\n+      }\n+      copyFromVersionSlug = \"\";\n+      enteredLocaleAliases.putAll(getLocaleAliases());\n+    }\n+  }\n+\n+  public HProject getProject() {\n+    return projectDAO.getBySlug(getProjectSlug());\n+  }\n+\n+  public String getProjectSlug() {\n+    return projectAndVersionSlug.getProjectSlug();\n+  }\n+\n+  public void setProjectSlug(String slug) {\n+    projectAndVersionSlug.setProjectSlug(slug);\n+  }\n+\n+  public String getSlug() {\n+    return projectAndVersionSlug.getVersionSlug();\n+  }\n+\n+  public List<VersionItem> getOtherVersions() {\n+    HProject project = getProject();\n+    if (project != null) {\n+      List<HProjectIteration> versionList =\n+        projectIterationDAO.getByProjectSlug(getProjectSlug(),\n+          EntityStatus.ACTIVE, EntityStatus.READONLY);\n+      versionList.sort(ComparatorUtil.VERSION_CREATION_DATE_COMPARATOR);\n+      List<VersionItem> versionItems =\n+        versionList.stream().map(this::makeVersionItem)\n+          .collect(Collectors.toList());\n+      if (isEmpty(copyFromVersionSlug) && !versionItems.isEmpty()) {\n+        versionItems.get(0).setSelected(true);\n+      }\n+      return versionItems;\n+    }\n+    return Collections.emptyList();\n+  }\n+\n+  private VersionItem makeVersionItem(HProjectIteration iter) {\n+    boolean selected = StringUtils.isNotEmpty(copyFromVersionSlug) &&\n+      copyFromVersionSlug.equals(iter.getSlug());\n+    return new VersionItem(selected, iter);\n+  }\n+\n+  public static class VersionItem {\n+    private boolean selected;\n+    private HProjectIteration version;\n+\n+    public boolean isSelected() {\n+      return this.selected;\n+    }\n+\n+    public HProjectIteration getVersion() {\n+      return this.version;\n+    }\n+\n+    public void setSelected(final boolean selected) {\n+      this.selected = selected;\n+    }\n+\n+    public void setVersion(final HProjectIteration version) {\n+      this.version = version;\n+    }\n+\n+    @java.beans.ConstructorProperties({\"selected\", \"version\"})\n+    public VersionItem(final boolean selected,\n+                       final HProjectIteration version) {\n+      this.selected = selected;\n+      this.version = version;\n+    }\n+  }\n+\n+  @Override\n+  protected HProjectIteration loadInstance() {\n+    Session session = (Session) getEntityManager().getDelegate();\n+    HProject project = (HProject) session.byNaturalId(HProject.class)\n+      .using(\"slug\", getProjectSlug()).load();\n+    validateProjectState(project);\n+    if (versionId == null) {\n+      HProject targetProject = projectDAO.getBySlug(getProjectSlug());\n+      validateProjectState(targetProject);\n+      HProjectIteration iteration = (HProjectIteration) session\n+        .byNaturalId(HProjectIteration.class)\n+        .using(\"slug\", getSlug())\n+        .using(\"project\", targetProject)\n+        .load();\n+      validateIterationState(iteration);\n+      versionId = iteration.getId();\n+      return iteration;\n+    } else {\n+      HProjectIteration iteration = (HProjectIteration) session\n+        .load(HProjectIteration.class, versionId);\n+      validateIterationState(iteration);\n+      return iteration;\n+    }\n+  }\n+\n+  private void validateIterationState(HProjectIteration iteration) {\n+    if (iteration == null\n+      || iteration.getStatus() == EntityStatus.OBSOLETE) {\n+      log.warn(\n+        \"Project version [id={}, slug={}], does not exist or is soft deleted: {}\",\n+        versionId, getSlug(), iteration);\n+      throw new VersionNotFoundException(getProjectSlug(), getSlug());\n+    }\n+  }\n+\n+  private void validateProjectState(HProject project) {\n+    if (project == null || project.getStatus() == EntityStatus.OBSOLETE) {\n+      log.warn(\"Project [slug={}], does not exist or is soft deleted: {}\",\n+        getProjectSlug(), project);\n+      throw new ProjectNotFoundException(getProjectSlug());\n+    }\n+  }\n+\n+  public List<ValidationAction> getValidationList() {\n+    List<ValidationAction> sortedList =\n+      Lists.newArrayList(getValidations().values());\n+    Collections.sort(sortedList,\n+      ValidationFactory.ValidationActionComparator);\n+    return sortedList;\n+  }\n+\n+  private Map<ValidationId, ValidationAction> getValidations() {\n+    if (availableValidations.isEmpty()) {\n+      Collection<ValidationAction> validationList =\n+        validationServiceImpl.getValidationActions(getProjectSlug(),\n+          getInstance().getSlug());\n+      for (ValidationAction validationAction : validationList) {\n+        availableValidations.put(validationAction.getId(),\n+          validationAction);\n+      }\n+    }\n+    return availableValidations;\n+  }\n+\n+  public void validateSuppliedId() {\n+    getInstance(); // this will raise an EntityNotFound exception\n+    // when id is invalid and conversation will not\n+    // start\n+  }\n+\n+  public ProjectType getProjectType() {\n+    if (getInstance().getProjectType() == null) {\n+      getInstance().setProjectType(\n+        getInstance().getProject().getDefaultProjectType());\n+    }\n+    return getInstance().getProjectType();\n+  }\n+\n+  @Transactional\n+  public void setProjectType(ProjectType projectType) {\n+    getInstance().setProjectType(projectType);\n+  }\n+\n+  public void validateProjectSlug() {\n+    if (projectDAO.getBySlug(getProjectSlug()) == null) {\n+      throw new EntityNotFoundException(\n+        \"no entity with slug \" + getProjectSlug());\n+    }\n+  }\n+\n+  public void verifySlugAvailable(ValueChangeEvent e) {\n+    String slug = (String) e.getNewValue();\n+    validateSlug(slug, e.getComponent().getId());\n+  }\n+\n+  public boolean validateSlug(String slug, String componentId) {\n+    if (!isSlugAvailable(slug)) {\n+      facesMessages.addToControl(componentId,\n+        \"This Version ID has been used in this project\");\n+      return false;\n+    }\n+    boolean valid = new SlugValidator().isValid(slug, null);\n+    if (!valid) {\n+      String validationMessages =\n+        ResourceBundle.getBundle(\"ValidationMessages\").getString(\n+          \"javax.validation.constraints.Slug.message\");\n+      facesMessages.addToControl(componentId, validationMessages);\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  public boolean isSlugAvailable(String slug) {\n+    return slugEntityServiceImpl.isProjectIterationSlugAvailable(slug,\n+      getProjectSlug());\n+  }\n+\n+  @Transactional\n+  public String createVersion() {\n+    if (!validateSlug(inputSlugValue, \"slug\")) {\n+      return \"invalid-slug\";\n+    }\n+    if (copyFromVersion) {\n+      copyVersion();\n+      return \"copy-version\";\n+    } else {\n+      return persist();\n+    }\n+  }\n+\n+  @Transactional\n+  public void copyVersion() {\n+    copyVersionManager.startCopyVersion(getProjectSlug(),\n+      copyFromVersionSlug, inputSlugValue);\n+    facesMessages.addGlobal(msgs.format(\"jsf.copyVersion.started\", inputSlugValue,\n+      copyFromVersionSlug));\n+  }\n+\n+  public void setSlug(String slug) {\n+    projectAndVersionSlug.setVersionSlug(slug);\n+    this.inputSlugValue = slug;\n+  }\n+\n+  @Override\n+  @Transactional\n+  public String persist() {\n+    String slug = getInputSlugValue();\n+    if (!validateSlug(slug, \"slug\")) {\n+      return null;\n+    }\n+    getInstance().setSlug(slug);\n+    updateProjectType();\n+    HProject project = getProject();\n+    project.addIteration(getInstance());\n+    // FIXME this looks only to be used when copying a version.\n+    // so it should copy the setting for isOverrideLocales,\n+    // and all enabled locales and locale alias data if it is\n+    // overriding.\n+    List<HLocale> projectLocales = localeServiceImpl\n+      .getSupportedLanguageByProject(getProjectSlug());\n+    getInstance().getCustomizedLocales().addAll(projectLocales);\n+    getInstance().getCustomizedValidations()\n+      .putAll(project.getCustomizedValidations());\n+    String result = super.persist();\n+    webhookServiceImpl.processWebhookVersionChanged(getProjectSlug(), slug,\n+      getProject().getWebHooks(),\n+      VersionChangedEvent.ChangeType.CREATE);\n+    return result;\n+  }\n+\n+  @Override\n+  public Object getId() {\n+    return getProjectSlug() + \"/\" + getSlug();\n+  }\n+\n+  @Override\n+  public NaturalIdentifier getNaturalId() {\n+    return Restrictions.naturalId().set(\"slug\", getSlug()).set(\"project\",\n+      projectDAO.getBySlug(getProjectSlug()));\n+  }\n+\n+  @Override\n+  public boolean isIdDefined() {\n+    return getSlug() != null && getProjectSlug() != null;\n+  }\n+\n+  public boolean isValidationsSameAsProject() {\n+    Collection<ValidationAction> versionValidations = validationServiceImpl\n+      .getValidationActions(getProjectSlug(), getSlug());\n+    Collection<ValidationAction> projectValidations =\n+      validationServiceImpl.getValidationActions(getProjectSlug());\n+    return versionValidations.equals(projectValidations);\n+  }\n+\n+  @Transactional\n+  public void copyValidationFromProject() {\n+    getInstance().getCustomizedValidations().clear();\n+    getInstance().getCustomizedValidations()\n+      .putAll(getInstance().getProject().getCustomizedValidations());\n+    availableValidations.clear();\n+    update();\n+    facesMessages.addGlobal(msgs.get(\"jsf.iteration.CopyProjectValidations.message\"));\n+  }\n+\n+  /**\n+   * Flush changes to the database, and raise an event to communicate that the\n+   * version has been changed.\n+   *\n+   * @return the String \"updated\"\n+   */\n+  @Override\n+  @Transactional\n+  public String update() {\n+    identity.checkPermission(getInstance(), \"update\");\n+    if (!getSlug().equals(getInputSlugValue())\n+      && !validateSlug(getInputSlugValue(), \"slug\")) {\n+      return null;\n+    }\n+    if (getInputSlugValue() != null\n+      && !getSlug().equals(getInputSlugValue())) {\n+      getInstance().setSlug(getInputSlugValue());\n+    }\n+    boolean softDeleted = false;\n+    if (getInstance().getStatus() == EntityStatus.OBSOLETE) {\n+      // if we offer delete in REST, we need to move this to hibernate\n+      // listener\n+      String newSlug = getInstance().changeToDeletedSlug();\n+      getInstance().setSlug(newSlug);\n+      softDeleted = true;\n+    }\n+    String state = super.update();\n+    if (softDeleted) {\n+      String url = urlUtil.projectUrl(getProjectSlug());\n+      urlUtil.redirectToInternal(url);\n+      return state;\n+    }\n+    facesMessages.addGlobal(SEVERITY_INFO,\n+      msgs.get(\"jsf.version.settings.updated\"));\n+    if (!getSlug().equals(getInstance().getSlug())) {\n+      projectAndVersionSlug.setVersionSlug(getInstance().getSlug());\n+      return \"version-slug-updated\";\n+    }\n+    return state;\n+  }\n+\n+  @Override\n+  protected void updatedMessage() {\n+    // Disable the default message from Seam\n+  }\n+\n+  @Transactional\n+  public void updateStatus(char initial) {\n+    identity.checkPermission(getInstance(), \"update\");\n+    if (getProject().getStatus() == EntityStatus.READONLY) {\n+      facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n+        \"Parent project is read-only!\");\n+      return;\n+    }\n+    String message = msgs.format(\"jsf.iteration.status.updated\",\n+      EntityStatus.valueOf(initial));\n+    getInstance().setStatus(EntityStatus.valueOf(initial));\n+    if (getInstance().getStatus() == EntityStatus.OBSOLETE) {\n+      message = msgs.get(\"jsf.iteration.deleted\");\n+    }\n+    update();\n+    facesMessages.addGlobal(FacesMessage.SEVERITY_INFO, message);\n+  }\n+\n+  @Transactional\n+  public void deleteSelf() {\n+    String slug = getInstance().getSlug();\n+    updateStatus('O');\n+    webhookServiceImpl.processWebhookVersionChanged(getProjectSlug(), slug,\n+      getProject().getWebHooks(),\n+      VersionChangedEvent.ChangeType.DELETE);\n+  }\n+\n+  @Transactional\n+  public void updateSelectedProjectType(ValueChangeEvent e) {\n+    selectedProjectType = (String) e.getNewValue();\n+    updateProjectType();\n+  }\n+\n+  @Transactional\n+  public void copyProjectTypeFromProject() {\n+    getInstance().setProjectType(\n+      getInstance().getProject().getDefaultProjectType());\n+    update();\n+    facesMessages.addGlobal(msgs.get(\"jsf.iteration.CopyProjectType.message\"));\n+  }\n+\n+  /**\n+   * @return comma-separated list of accepted file extensions. May be an empty\n+   * string\n+   */\n+  @SuppressWarnings(\"deprecation\")\n+  public String getAcceptedSourceFileExtensions() {\n+    List<String> supportedTypes =\n+      ProjectType.getSupportedSourceFileTypes(getProjectType())\n+        .stream().map(docType -> Joiner.on(\",\")\n+        .join(docType.getSourceExtensions()))\n+        .collect(Collectors.toList());\n+    return Joiner.on(\", \").join(supportedTypes);\n+  }\n+\n+  @SuppressWarnings(\"deprecation\")\n+  public String getAcceptedSourceFile() {\n+    List<String> supportedTypes =\n+      ProjectType.getSupportedSourceFileTypes(getProjectType())\n+        .stream()\n+        .map(docType -> docType.name() + \"[\" + Joiner.on(\",\")\n+          .join(docType.getSourceExtensions()) + \"]\")\n+        .collect(Collectors.toList());\n+    return Joiner.on(\", \").join(supportedTypes);\n+  }\n+\n+  private void updateProjectType() {\n+    if (!isEmpty(selectedProjectType)\n+      && !selectedProjectType.equals(\"null\")) {\n+      ProjectType projectType = ProjectType.valueOf(selectedProjectType);\n+      getInstance().setProjectType(projectType);\n+    } else {\n+      getInstance().setProjectType(null);\n+    }\n+  }\n+\n+  public List<ValidationAction.State> getValidationStates() {\n+    return Arrays.asList(ValidationAction.State.values());\n+  }\n+\n+  @Transactional\n+  public void updateValidationOption(String name, String state) {\n+    identity.checkPermission(getInstance(), \"update\");\n+    ValidationId validationId = ValidationId.valueOf(name);\n+    for (Map.Entry<ValidationId, ValidationAction> entry : getValidations()\n+      .entrySet()) {\n+      if (entry.getKey().name().equals(name)) {\n+        getValidations().get(validationId)\n+          .setState(ValidationAction.State.valueOf(state));\n+        getInstance().getCustomizedValidations().put(\n+          entry.getKey().name(),\n+          entry.getValue().getState().name());\n+        ensureMutualExclusivity(getValidations().get(validationId));\n+        break;\n+      }\n+    }\n+    update();\n+    facesMessages.addGlobal(msgs.format(\"jsf.validation.updated\",\n+      validationId.getDisplayName(), state));\n+  }\n+\n+  /**\n+   * If this action is enabled(Warning or Error), then it's exclusive\n+   * validation will be turn off\n+   */\n+  private void\n+  ensureMutualExclusivity(ValidationAction selectedValidationAction) {\n+    if (selectedValidationAction.getState() != ValidationAction.State.Off) {\n+      for (ValidationAction exclusiveValAction : selectedValidationAction\n+        .getExclusiveValidations()) {\n+        getInstance().getCustomizedValidations().put(\n+          exclusiveValAction.getId().name(),\n+          ValidationAction.State.Off.name());\n+        getValidations().get(exclusiveValAction.getId())\n+          .setState(ValidationAction.State.Off);\n+      }\n+    }\n+  }\n+\n+  public List<ProjectType> getProjectTypeList() {\n+    List<ProjectType> projectTypes = Arrays.asList(ProjectType.values());\n+    Collections.sort(projectTypes, ComparatorUtil.PROJECT_TYPE_COMPARATOR);\n+    return projectTypes;\n+  }\n+\n+  public boolean isOverrideLocales() {\n+    return getInstance().isOverrideLocales();\n+  }\n+\n+  @Transactional\n+  public void setOverrideLocales(boolean overrideLocales) {\n+    identity.checkPermission(getInstance(), \"update\");\n+    getInstance().setOverrideLocales(overrideLocales);\n+  }\n+\n+  public Map<LocaleId, String> getLocaleAliases() {\n+    return LocaleServiceImpl.getLocaleAliasesByIteration(getInstance());\n+  }\n+\n+  @Transactional\n+  public void removeAllLocaleAliases() {\n+    identity.checkPermission(getInstance(), \"update\");\n+    List<LocaleId> removed = new ArrayList<>();\n+    List<LocaleId> aliasedLocales =\n+      new ArrayList<>(getLocaleAliases().keySet());\n+    if (!aliasedLocales.isEmpty()) {\n+      ensureOverridingLocales();\n+      for (LocaleId aliasedLocale : aliasedLocales) {\n+        boolean hadAlias = removeAliasSilently(aliasedLocale);\n+        if (hadAlias) {\n+          removed.add(aliasedLocale);\n         }\n-\n-        public HProjectIteration getVersion() {\n-            return this.version;\n-        }\n-\n-        public void setSelected(final boolean selected) {\n-            this.selected = selected;\n-        }\n-\n-        public void setVersion(final HProjectIteration version) {\n-            this.version = version;\n-        }\n-\n-        @java.beans.ConstructorProperties({ \"selected\", \"version\" })\n-        public VersionItem(final boolean selected,\n-                final HProjectIteration version) {\n-            this.selected = selected;\n-            this.version = version;\n-        }\n-    }\n-\n-    @Override\n-    protected HProjectIteration loadInstance() {\n-        Session session = (Session) getEntityManager().getDelegate();\n-        HProject project = (HProject) session.byNaturalId(HProject.class)\n-                .using(\"slug\", getProjectSlug()).load();\n-        validateProjectState(project);\n-        if (versionId == null) {\n-            HProject targetProject = projectDAO.getBySlug(getProjectSlug());\n-            validateProjectState(targetProject);\n-            HProjectIteration iteration = (HProjectIteration) session\n-                    .byNaturalId(HProjectIteration.class)\n-                    .using(\"slug\", getSlug())\n-                    .using(\"project\", targetProject)\n-                    .load();\n-            validateIterationState(iteration);\n-            versionId = iteration.getId();\n-            return iteration;\n-        } else {\n-            HProjectIteration iteration = (HProjectIteration) session\n-                    .load(HProjectIteration.class, versionId);\n-            validateIterationState(iteration);\n-            return iteration;\n-        }\n-    }\n-\n-    private void validateIterationState(HProjectIteration iteration) {\n-        if (iteration == null\n-                || iteration.getStatus() == EntityStatus.OBSOLETE) {\n-            log.warn(\n-                    \"Project version [id={}, slug={}], does not exist or is soft deleted: {}\",\n-                    versionId, getSlug(), iteration);\n-            throw new VersionNotFoundException(getProjectSlug(), getSlug());\n-        }\n-    }\n-\n-    private void validateProjectState(HProject project) {\n-        if (project == null || project.getStatus() == EntityStatus.OBSOLETE) {\n-            log.warn(\"Project [slug={}], does not exist or is soft deleted: {}\",\n-                    getProjectSlug(), project);\n-            throw new ProjectNotFoundException(getProjectSlug());\n-        }\n-    }\n-\n-    public List<ValidationAction> getValidationList() {\n-        List<ValidationAction> sortedList =\n-                Lists.newArrayList(getValidations().values());\n-        Collections.sort(sortedList,\n-                ValidationFactory.ValidationActionComparator);\n-        return sortedList;\n-    }\n-\n-    private Map<ValidationId, ValidationAction> getValidations() {\n-        if (availableValidations.isEmpty()) {\n-            Collection<ValidationAction> validationList =\n-                    validationServiceImpl.getValidationActions(getProjectSlug(),\n-                            getInstance().getSlug());\n-            for (ValidationAction validationAction : validationList) {\n-                availableValidations.put(validationAction.getId(),\n-                        validationAction);\n-            }\n-        }\n-        return availableValidations;\n-    }\n-\n-    public void validateSuppliedId() {\n-        getInstance(); // this will raise an EntityNotFound exception\n-        // when id is invalid and conversation will not\n-        // start\n-    }\n-\n-    public ProjectType getProjectType() {\n-        if (getInstance().getProjectType() == null) {\n-            getInstance().setProjectType(\n-                    getInstance().getProject().getDefaultProjectType());\n-        }\n-        return getInstance().getProjectType();\n-    }\n-\n-    @Transactional\n-    public void setProjectType(ProjectType projectType) {\n-        getInstance().setProjectType(projectType);\n-    }\n-\n-    public void validateProjectSlug() {\n-        if (projectDAO.getBySlug(getProjectSlug()) == null) {\n-            throw new EntityNotFoundException(\n-                    \"no entity with slug \" + getProjectSlug());\n-        }\n-    }\n-\n-    public void verifySlugAvailable(ValueChangeEvent e) {\n-        String slug = (String) e.getNewValue();\n-        validateSlug(slug, e.getComponent().getId());\n-    }\n-\n-    public boolean validateSlug(String slug, String componentId) {\n-        if (!isSlugAvailable(slug)) {\n-            facesMessages.addToControl(componentId,\n-                    \"This Version ID has been used in this project\");\n-            return false;\n+      }\n+    }\n+    // else no locales to remove, nothing to do.\n+    showRemovedAliasesMessage(removed);\n+  }\n+\n+  /**\n+   * Ensure that isOverrideLocales is true, and copy data if necessary.\n+   */\n+  private void ensureOverridingLocales() {\n+    if (!isOverrideLocales()) {\n+      startOverridingLocales();\n+    }\n+  }\n+\n+  /**\n+   * Copy locale data from project and set overrideLocales, in preparation for\n+   * making customizations to the locales.\n+   */\n+  private void startOverridingLocales() {\n+    // Copied before setOverrideLocales(true) so that the currently returned\n+    // values will be used as the basis for any customization.\n+    List<HLocale> enabledLocales = getEnabledLocales();\n+    Map<LocaleId, String> localeAliases = getLocaleAliases();\n+    setOverrideLocales(true);\n+    // Replace contents rather than entire collections to avoid confusion\n+    // with reference to the collections that are bound before this runs.\n+    getInstance().getCustomizedLocales().clear();\n+    getInstance().getCustomizedLocales().addAll(enabledLocales);\n+    getInstance().getLocaleAliases().clear();\n+    getInstance().getLocaleAliases().putAll(localeAliases);\n+    enteredLocaleAliases.clear();\n+    enteredLocaleAliases.putAll(localeAliases);\n+    refreshDisabledLocales();\n+  }\n+\n+  /**\n+   * Update disabled locales to be consistent with enabled locales.\n+   */\n+  private void refreshDisabledLocales() {\n+    // will be re-generated with correct values next time it is fetched.\n+    disabledLocales = null;\n+  }\n+\n+  @Transactional\n+  public void removeSelectedLocaleAliases() {\n+    identity.checkPermission(getInstance(), \"update\");\n+    List<LocaleId> removed = new ArrayList<>();\n+    for (Map.Entry<LocaleId, Boolean> entry : getSelectedEnabledLocales()\n+      .entrySet()) {\n+      if (entry.getValue()) {\n+        boolean hadAlias = removeAliasSilently(entry.getKey());\n+        if (hadAlias) {\n+          removed.add(entry.getKey());\n         }\n-        boolean valid = new SlugValidator().isValid(slug, null);\n-        if (!valid) {\n-            String validationMessages =\n-                    ResourceBundle.getBundle(\"ValidationMessages\").getString(\n-                            \"javax.validation.constraints.Slug.message\");\n-            facesMessages.addToControl(componentId, validationMessages);\n-            return false;\n-        }\n-        return true;\n-    }\n-\n-    public boolean isSlugAvailable(String slug) {\n-        return slugEntityServiceImpl.isProjectIterationSlugAvailable(slug,\n-                getProjectSlug());\n-    }\n-\n-    @Transactional\n-    public String createVersion() {\n-        if (!validateSlug(inputSlugValue, \"slug\"))\n-            return \"invalid-slug\";\n-        if (copyFromVersion) {\n-            copyVersion();\n-            return \"copy-version\";\n-        } else {\n-            return persist();\n-        }\n-    }\n-\n-    @Transactional\n-    public void copyVersion() {\n-        copyVersionManager.startCopyVersion(getProjectSlug(),\n-                copyFromVersionSlug, inputSlugValue);\n-        facesMessages.addGlobal(msgs.format(\"jsf.copyVersion.started\", inputSlugValue,\n-                copyFromVersionSlug));\n-    }\n-\n-    public void setSlug(String slug) {\n-        projectAndVersionSlug.setVersionSlug(slug);\n-        this.inputSlugValue = slug;\n-    }\n-\n-    @Override\n-    @Transactional\n-    public String persist() {\n-        String slug = getInputSlugValue();\n-        if (!validateSlug(slug, \"slug\")) {\n-            return null;\n-        }\n-        getInstance().setSlug(slug);\n-        updateProjectType();\n-        HProject project = getProject();\n-        project.addIteration(getInstance());\n-        // FIXME this looks only to be used when copying a version.\n-        // so it should copy the setting for isOverrideLocales,\n-        // and all enabled locales and locale alias data if it is\n-        // overriding.\n-        List<HLocale> projectLocales = localeServiceImpl\n-                .getSupportedLanguageByProject(getProjectSlug());\n-        getInstance().getCustomizedLocales().addAll(projectLocales);\n-        getInstance().getCustomizedValidations()\n-                .putAll(project.getCustomizedValidations());\n-        String result = super.persist();\n-        webhookServiceImpl.processWebhookVersionChanged(getProjectSlug(), slug,\n-                getProject().getWebHooks(),\n-                VersionChangedEvent.ChangeType.CREATE);\n-        return result;\n-    }\n-\n-    @Override\n-    public Object getId() {\n-        return getProjectSlug() + \"/\" + getSlug();\n-    }\n-\n-    @Override\n-    public NaturalIdentifier getNaturalId() {\n-        return Restrictions.naturalId().set(\"slug\", getSlug()).set(\"project\",\n-                projectDAO.getBySlug(getProjectSlug()));\n-    }\n-\n-    @Override\n-    public boolean isIdDefined() {\n-        return getSlug() != null && getProjectSlug() != null;\n-    }\n-\n-    public boolean isValidationsSameAsProject() {\n-        Collection<ValidationAction> versionValidations = validationServiceImpl\n-                .getValidationActions(getProjectSlug(), getSlug());\n-        Collection<ValidationAction> projectValidations =\n-                validationServiceImpl.getValidationActions(getProjectSlug());\n-        return versionValidations.equals(projectValidations);\n-    }\n-\n-    @Transactional\n-    public void copyValidationFromProject() {\n-        getInstance().getCustomizedValidations().clear();\n-        getInstance().getCustomizedValidations()\n-                .putAll(getInstance().getProject().getCustomizedValidations());\n-        availableValidations.clear();\n-        update();\n-        facesMessages.addGlobal(msgs.get(\"jsf.iteration.CopyProjectValidations.message\"));\n-    }\n-\n-    /**\n-     * Flush changes to the database, and raise an event to communicate that the\n-     * version has been changed.\n-     *\n-     * @return the String \"updated\"\n-     */\n-    @Override\n-    @Transactional\n-    public String update() {\n-        identity.checkPermission(getInstance(), \"update\");\n-        if (!getSlug().equals(getInputSlugValue())\n-                && !validateSlug(getInputSlugValue(), \"slug\")) {\n-            return null;\n-        }\n-        if (getInputSlugValue() != null\n-                && !getSlug().equals(getInputSlugValue())) {\n-            getInstance().setSlug(getInputSlugValue());\n-        }\n-        boolean softDeleted = false;\n-        if (getInstance().getStatus() == EntityStatus.OBSOLETE) {\n-            // if we offer delete in REST, we need to move this to hibernate\n-            // listener\n-            String newSlug = getInstance().changeToDeletedSlug();\n-            getInstance().setSlug(newSlug);\n-            softDeleted = true;\n-        }\n-        String state = super.update();\n-        if (softDeleted) {\n-            String url = urlUtil.projectUrl(getProjectSlug());\n-            urlUtil.redirectToInternal(url);\n-            return state;\n-        }\n-        facesMessages.addGlobal(SEVERITY_INFO,\n-                msgs.get(\"jsf.version.settings.updated\"));\n-        if (!getSlug().equals(getInstance().getSlug())) {\n-            projectAndVersionSlug.setVersionSlug(getInstance().getSlug());\n-            return \"version-slug-updated\";\n-        }\n-        return state;\n-    }\n-\n-    @Override\n-    protected void updatedMessage() {\n-        // Disable the default message from Seam\n-    }\n-\n-    @Transactional\n-    public void updateStatus(char initial) {\n-        identity.checkPermission(getInstance(), \"update\");\n-        if (getProject().getStatus() == EntityStatus.READONLY) {\n-            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n-                    \"Parent project is read-only!\");\n-            return;\n-        }\n-        String message = msgs.format(\"jsf.iteration.status.updated\",\n-                EntityStatus.valueOf(initial));\n-        getInstance().setStatus(EntityStatus.valueOf(initial));\n-        if (getInstance().getStatus() == EntityStatus.OBSOLETE) {\n-            message = msgs.get(\"jsf.iteration.deleted\");\n-        }\n-        update();\n-        facesMessages.addGlobal(FacesMessage.SEVERITY_INFO, message);\n-    }\n-\n-    @Transactional\n-    public void deleteSelf() {\n-        String slug = getInstance().getSlug();\n-        updateStatus('O');\n-        webhookServiceImpl.processWebhookVersionChanged(getProjectSlug(), slug,\n-                getProject().getWebHooks(),\n-                VersionChangedEvent.ChangeType.DELETE);\n-    }\n-\n-    @Transactional\n-    public void updateSelectedProjectType(ValueChangeEvent e) {\n-        selectedProjectType = (String) e.getNewValue();\n-        updateProjectType();\n-    }\n-\n-    @Transactional\n-    public void copyProjectTypeFromProject() {\n-        getInstance().setProjectType(\n-                getInstance().getProject().getDefaultProjectType());\n-        update();\n-        facesMessages.addGlobal(msgs.get(\"jsf.iteration.CopyProjectType.message\"));\n-    }\n-\n-    /**\n-     * @return comma-separated list of accepted file extensions. May be an empty\n-     *         string\n-     */\n-    @SuppressWarnings(\"deprecation\")\n-    public String getAcceptedSourceFileExtensions() {\n-        List<String> supportedTypes =\n-                ProjectType.getSupportedSourceFileTypes(getProjectType())\n-                        .stream().map(docType -> Joiner.on(\",\")\n-                        .join(docType.getSourceExtensions()))\n-                        .collect(Collectors.toList());\n-        return Joiner.on(\", \").join(supportedTypes);\n-    }\n-\n-    @SuppressWarnings(\"deprecation\")\n-    public String getAcceptedSourceFile() {\n-        List<String> supportedTypes =\n-                ProjectType.getSupportedSourceFileTypes(getProjectType())\n-                        .stream()\n-                        .map(docType -> docType.name() + \"[\" + Joiner.on(\",\")\n-                                .join(docType.getSourceExtensions()) + \"]\")\n-                        .collect(Collectors.toList());\n-        return Joiner.on(\", \").join(supportedTypes);\n-    }\n-\n-    private void updateProjectType() {\n-        if (!isEmpty(selectedProjectType)\n-                && !selectedProjectType.equals(\"null\")) {\n-            ProjectType projectType = ProjectType.valueOf(selectedProjectType);\n-            getInstance().setProjectType(projectType);\n-        } else {\n-            getInstance().setProjectType(null);\n-        }\n-    }\n-\n-    public List<ValidationAction.State> getValidationStates() {\n-        return Arrays.asList(ValidationAction.State.values());\n-    }\n-\n-    @Transactional\n-    public void updateValidationOption(String name, String state) {\n-        identity.checkPermission(getInstance(), \"update\");\n-        ValidationId validationId = ValidationId.valueOf(name);\n-        for (Map.Entry<ValidationId, ValidationAction> entry : getValidations()\n-                .entrySet()) {\n-            if (entry.getKey().name().equals(name)) {\n-                getValidations().get(validationId)\n-                        .setState(ValidationAction.State.valueOf(state));\n-                getInstance().getCustomizedValidations().put(\n-                        entry.getKey().name(),\n-                        entry.getValue().getState().name());\n-                ensureMutualExclusivity(getValidations().get(validationId));\n-                break;\n-            }\n-        }\n-        update();\n-        facesMessages.addGlobal(msgs.format(\"jsf.validation.updated\",\n-                validationId.getDisplayName(), state));\n-    }\n-\n-    /**\n-     * If this action is enabled(Warning or Error), then it's exclusive\n-     * validation will be turn off\n-     */\n-    private void\n-            ensureMutualExclusivity(ValidationAction selectedValidationAction) {\n-        if (selectedValidationAction.getState() != ValidationAction.State.Off) {\n-            for (ValidationAction exclusiveValAction : selectedValidationAction\n-                    .getExclusiveValidations()) {\n-                getInstance().getCustomizedValidations().put(\n-                        exclusiveValAction.getId().name(),\n-                        ValidationAction.State.Off.name());\n-                getValidations().get(exclusiveValAction.getId())\n-                        .setState(ValidationAction.State.Off);\n-            }\n-        }\n-    }\n-\n-    public List<ProjectType> getProjectTypeList() {\n-        List<ProjectType> projectTypes = Arrays.asList(ProjectType.values());\n-        Collections.sort(projectTypes, ComparatorUtil.PROJECT_TYPE_COMPARATOR);\n-        return projectTypes;\n-    }\n-\n-    public boolean isOverrideLocales() {\n-        return getInstance().isOverrideLocales();\n-    }\n-\n-    @Transactional\n-    public void setOverrideLocales(boolean overrideLocales) {\n-        identity.checkPermission(getInstance(), \"update\");\n-        getInstance().setOverrideLocales(overrideLocales);\n-    }\n-\n-    public Map<LocaleId, String> getLocaleAliases() {\n-        return LocaleServiceImpl.getLocaleAliasesByIteration(getInstance());\n-    }\n-\n-    @Transactional\n-    public void removeAllLocaleAliases() {\n-        identity.checkPermission(getInstance(), \"update\");\n-        List<LocaleId> removed = new ArrayList<>();\n-        List<LocaleId> aliasedLocales =\n-                new ArrayList<>(getLocaleAliases().keySet());\n-        if (!aliasedLocales.isEmpty()) {\n-            ensureOverridingLocales();\n-            for (LocaleId aliasedLocale : aliasedLocales) {\n-                boolean hadAlias = removeAliasSilently(aliasedLocale);\n-                if (hadAlias) {\n-                    removed.add(aliasedLocale);\n-                }\n-            }\n-        }\n-        // else no locales to remove, nothing to do.\n-        showRemovedAliasesMessage(removed);\n-    }\n-\n-    /**\n-     * Ensure that isOverrideLocales is true, and copy data if necessary.\n-     */\n-    private void ensureOverridingLocales() {\n-        if (!isOverrideLocales()) {\n-            startOverridingLocales();\n-        }\n-    }\n-\n-    /**\n-     * Copy locale data from project and set overrideLocales, in preparation for\n-     * making customizations to the locales.\n-     */\n-    private void startOverridingLocales() {\n-        // Copied before setOverrideLocales(true) so that the currently returned\n-        // values will be used as the basis for any customization.\n-        List<HLocale> enabledLocales = getEnabledLocales();\n-        Map<LocaleId, String> localeAliases = getLocaleAliases();\n-        setOverrideLocales(true);\n-        // Replace contents rather than entire collections to avoid confusion\n-        // with reference to the collections that are bound before this runs.\n-        getInstance().getCustomizedLocales().clear();\n-        getInstance().getCustomizedLocales().addAll(enabledLocales);\n-        getInstance().getLocaleAliases().clear();\n-        getInstance().getLocaleAliases().putAll(localeAliases);\n-        enteredLocaleAliases.clear();\n-        enteredLocaleAliases.putAll(localeAliases);\n-        refreshDisabledLocales();\n-    }\n-\n-    /**\n-     * Update disabled locales to be consistent with enabled locales.\n-     */\n-    private void refreshDisabledLocales() {\n-        // will be re-generated with correct values next time it is fetched.\n-        disabledLocales = null;\n-    }\n-\n-    @Transactional\n-    public void removeSelectedLocaleAliases() {\n-        identity.checkPermission(getInstance(), \"update\");\n-        List<LocaleId> removed = new ArrayList<>();\n-        for (Map.Entry<LocaleId, Boolean> entry : getSelectedEnabledLocales()\n-                .entrySet()) {\n-            if (entry.getValue()) {\n-                boolean hadAlias = removeAliasSilently(entry.getKey());\n-                if (hadAlias) {\n-                    removed.add(entry.getKey());\n-                }\n-            }\n-        }\n-        showRemovedAliasesMessage(removed);\n-    }\n-\n-    /**\n-     * Show an appropriate message for the removal of aliases from locales with\n-     * the given IDs.\n-     *\n-     * @param removed\n-     *            ids of locales that had aliases removed\n-     */\n-    private void showRemovedAliasesMessage(List<LocaleId> removed) {\n-        if (removed.isEmpty()) {\n-            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n-                    msgs.get(\"jsf.LocaleAlias.NoAliasesToRemove\"));\n-        } else if (removed.size() == 1) {\n-            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO, msgs\n-                    .format(\"jsf.LocaleAlias.AliasRemoved\", removed.get(0)));\n-        } else {\n-            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n-                    msgs.format(\"jsf.LocaleAlias.AliasesRemoved\",\n-                            StringUtils.join(removed, \", \")));\n-        }\n-    }\n-\n-    private boolean removeAliasSilently(LocaleId localeId) {\n-        return setLocaleAliasSilently(localeId, \"\");\n-    }\n-\n-    public String getLocaleAlias(HLocale locale) {\n-        return getLocaleAliases().get(locale.getLocaleId());\n-    }\n-\n-    public boolean hasLocaleAlias(HLocale locale) {\n-        return getLocaleAliases().containsKey(locale.getLocaleId());\n-    }\n-\n-    /**\n-     * A separate map is used, rather than binding the alias map from the\n-     * project directly. This is done so that empty values are not added to the\n-     * map in every form submission, and so that a value entered in the field\n-     * for a row is not automatically updated when a different row is submitted.\n-     */\n-    private Map<LocaleId, String> enteredLocaleAliases = Maps.newHashMap();\n-\n-    @Transactional\n-    public void updateToEnteredLocaleAlias(LocaleId localeId) {\n-        identity.checkPermission(getInstance(), \"update\");\n-        String enteredAlias = enteredLocaleAliases.get(localeId);\n-        setLocaleAlias(localeId, enteredAlias);\n-    }\n-\n-    private void setLocaleAlias(LocaleId localeId, String alias) {\n-        boolean hadAlias = setLocaleAliasSilently(localeId, alias);\n-        if (isNullOrEmpty(alias)) {\n-            if (hadAlias) {\n-                facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n-                        msgs.format(\"jsf.LocaleAlias.AliasRemoved\", localeId));\n-            } else {\n-                facesMessages.addGlobal(FacesMessage.SEVERITY_INFO, msgs\n-                        .format(\"jsf.LocaleAlias.NoAliasToRemove\", localeId));\n-            }\n-        } else {\n-            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n-                    msgs.format(\"jsf.LocaleAlias.AliasSet\", localeId, alias));\n-        }\n-    }\n-\n-    /**\n-     * Set or remove a locale alias without showing any message.\n-     *\n-     * @param localeId\n-     *            for which to set alias\n-     * @param alias\n-     *            new alias to use. Use empty string to remove alias.\n-     * @return true if there was already an alias, otherwise false.\n-     */\n-    private boolean setLocaleAliasSilently(LocaleId localeId, String alias) {\n-        HProjectIteration instance = getInstance();\n-        Map<LocaleId, String> aliases = instance.getLocaleAliases();\n-        boolean hadAlias = aliases.containsKey(localeId);\n-        if (isNullOrEmpty(alias)) {\n-            if (hadAlias) {\n-                ensureOverridingLocales();\n-                aliases.remove(localeId);\n-            }\n-        } else {\n-            final boolean sameAlias =\n-                    hadAlias && alias.equals(aliases.get(localeId));\n-            if (!sameAlias) {\n-                ensureOverridingLocales();\n-                aliases.put(localeId, alias);\n-            }\n-        }\n-        update();\n-        return hadAlias;\n-    }\n-\n-    @Transactional\n-    public void useDefaultLocales() {\n-        identity.checkPermission(getInstance(), \"update\");\n-        setOverrideLocales(false);\n-        refreshDisabledLocales();\n-    }\n-\n-    private String enabledLocalesFilter = \"\";\n-    private String disabledLocalesFilter;\n-\n-    public List<HLocale> getEnabledLocales() {\n-        if (StringUtils.isNotEmpty(getProjectSlug())\n-                && StringUtils.isNotEmpty(getSlug())) {\n-            List<HLocale> locales =\n-                    localeServiceImpl.getSupportedLanguageByProjectIteration(\n-                            getProjectSlug(), getSlug());\n-            locales.sort(ComparatorUtil.LOCALE_COMPARATOR);\n-            return locales;\n-        }\n-        return Lists.newArrayList();\n-    }\n-\n-    private Map<LocaleId, Boolean> selectedEnabledLocales = Maps.newHashMap();\n-    // Not sure if this is necessary, seems to work ok on selected disabled\n-    // locales without this.\n-\n-    public Map<LocaleId, Boolean> getSelectedEnabledLocales() {\n-        if (selectedEnabledLocales == null) {\n-            selectedEnabledLocales = Maps.newHashMap();\n-            for (HLocale locale : getEnabledLocales()) {\n-                selectedEnabledLocales.put(locale.getLocaleId(), Boolean.FALSE);\n-            }\n-        }\n-        return selectedEnabledLocales;\n-    }\n-\n-    @Transactional\n-    public void disableSelectedLocales() {\n-        identity.checkPermission(getInstance(), \"update\");\n-        List<LocaleId> toRemove = Lists.newArrayList();\n-        for (Map.Entry<LocaleId, Boolean> entry : getSelectedEnabledLocales()\n-                .entrySet()) {\n-            if (entry.getValue()) {\n-                toRemove.add(entry.getKey());\n-            }\n-        }\n-        List<LocaleId> removed = Lists.newArrayList();\n-        for (LocaleId localeId : toRemove) {\n-            boolean wasEnabled = disableLocaleSilently(localeId);\n-            if (wasEnabled) {\n-                removed.add(localeId);\n-            }\n-        }\n-        update();\n-        if (removed.isEmpty()) {\n-            // This should not be possible in the UI, but maybe if multiple\n-            // users are editing it.\n-        } else if (removed.size() == 1) {\n-            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO, msgs.format(\n-                    \"jsf.languageSettings.LanguageDisabled\", removed.get(0)));\n-        } else {\n-            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n-                    msgs.format(\"jsf.languageSettings.LanguagesDisabled\",\n-                            StringUtils.join(removed, \", \")));\n-        }\n-    }\n-\n-    private boolean disableLocaleSilently(LocaleId localeId) {\n-        HLocale locale = localeServiceImpl.getByLocaleId(localeId);\n-        return disableLocaleSilently(locale);\n-    }\n-\n-    @Transactional\n-    public void disableLocale(HLocale locale) {\n-        identity.checkPermission(getInstance(), \"update\");\n-        boolean wasEnabled = disableLocaleSilently(locale);\n-        update();\n-        if (wasEnabled) {\n-            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n-                    msgs.format(\"jsf.languageSettings.LanguageDisabled\",\n-                            locale.getLocaleId()));\n-        }\n-        // TODO consider showing a message like \"Locale {0} was already\n-        // disabled.\"\n-    }\n-\n-    /**\n-     * Disable a locale without printing any message.\n-     *\n-     * @param locale\n-     *            to disable\n-     * @return true if the locale was enabled before this call, false otherwise.\n-     */\n-    private boolean disableLocaleSilently(HLocale locale) {\n-        boolean wasEnabled;\n-        if (getEnabledLocales().contains(locale)) {\n-            ensureOverridingLocales();\n-            wasEnabled = getInstance().getCustomizedLocales().remove(locale);\n-            refreshDisabledLocales();\n-            // TODO consider using alias from project as default rather than\n-            // none.\n-            getLocaleAliases().remove(locale.getLocaleId());\n-            getSelectedEnabledLocales().remove(locale.getLocaleId());\n-        } else {\n-            wasEnabled = false;\n-        }\n-        return wasEnabled;\n-    }\n-\n-    private List<HLocale> disabledLocales;\n-\n-    public List<HLocale> getDisabledLocales() {\n-        if (disabledLocales == null) {\n-            disabledLocales = findActiveNotEnabledLocales();\n-        }\n-        return disabledLocales;\n-    }\n-\n-    /**\n-     * Populate the list of available locales after filtering out the locales\n-     * already in the project.\n-     */\n-    private List<HLocale> findActiveNotEnabledLocales() {\n-        List<HLocale> activeLocales = localeDAO.findAllActive();\n-        // only include those not already in the project version\n-        List<HLocale> filteredList = activeLocales.stream()\n-                .filter(hLocale -> !getEnabledLocales().contains(hLocale))\n-                .sorted(ComparatorUtil.LOCALE_COMPARATOR)\n-                .collect(Collectors.toList());\n-        return filteredList;\n-    }\n-\n-    private Map<LocaleId, Boolean> selectedDisabledLocales = Maps.newHashMap();\n-\n-    @Transactional\n-    public void enableSelectedLocales() {\n-        identity.checkPermission(getInstance(), \"update\");\n-        List<LocaleId> enabled = new ArrayList<>();\n-        for (Map.Entry<LocaleId, Boolean> entry : selectedDisabledLocales\n-                .entrySet()) {\n-            if (entry.getValue()) {\n-                boolean wasDisabled = enableLocaleSilently(entry.getKey());\n-                if (wasDisabled) {\n-                    enabled.add(entry.getKey());\n-                }\n-            }\n-        }\n-        selectedDisabledLocales.clear();\n-        update();\n-        if (enabled.isEmpty()) {\n-            // This should not be possible in the UI, but maybe if multiple\n-            // users are editing it.\n-        } else if (enabled.size() == 1) {\n-            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO, msgs.format(\n-                    \"jsf.languageSettings.LanguageEnabled\", enabled.get(0)));\n-        } else {\n-            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n-                    msgs.format(\"jsf.languageSettings.LanguagesEnabled\",\n-                            StringUtils.join(enabled, \", \")));\n-        }\n-    }\n-\n-    @Transactional\n-    public void enableLocale(HLocale locale) {\n-        identity.checkPermission(getInstance(), \"update\");\n-        boolean wasDisabled = enableLocaleSilently(locale);\n+      }\n+    }\n+    showRemovedAliasesMessage(removed);\n+  }\n+\n+  /**\n+   * Show an appropriate message for the removal of aliases from locales with\n+   * the given IDs.\n+   *\n+   * @param removed ids of locales that had aliases removed\n+   */\n+  private void showRemovedAliasesMessage(List<LocaleId> removed) {\n+    if (removed.isEmpty()) {\n+      facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n+        msgs.get(\"jsf.LocaleAlias.NoAliasesToRemove\"));\n+    } else if (removed.size() == 1) {\n+      facesMessages.addGlobal(FacesMessage.SEVERITY_INFO, msgs\n+        .format(\"jsf.LocaleAlias.AliasRemoved\", removed.get(0)));\n+    } else {\n+      facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n+        msgs.format(\"jsf.LocaleAlias.AliasesRemoved\",\n+          StringUtils.join(removed, \", \")));\n+    }\n+  }\n+\n+  private boolean removeAliasSilently(LocaleId localeId) {\n+    return setLocaleAliasSilently(localeId, \"\");\n+  }\n+\n+  public String getLocaleAlias(HLocale locale) {\n+    return getLocaleAliases().get(locale.getLocaleId());\n+  }\n+\n+  public boolean hasLocaleAlias(HLocale locale) {\n+    return getLocaleAliases().containsKey(locale.getLocaleId());\n+  }\n+\n+  /**\n+   * A separate map is used, rather than binding the alias map from the\n+   * project directly. This is done so that empty values are not added to the\n+   * map in every form submission, and so that a value entered in the field\n+   * for a row is not automatically updated when a different row is submitted.\n+   */\n+  private Map<LocaleId, String> enteredLocaleAliases = Maps.newHashMap();\n+\n+  @Transactional\n+  public void updateToEnteredLocaleAlias(LocaleId localeId) {\n+    identity.checkPermission(getInstance(), \"update\");\n+    String enteredAlias = enteredLocaleAliases.get(localeId);\n+    setLocaleAlias(localeId, enteredAlias);\n+  }\n+\n+  private void setLocaleAlias(LocaleId localeId, String alias) {\n+    boolean hadAlias = setLocaleAliasSilently(localeId, alias);\n+    if (isNullOrEmpty(alias)) {\n+      if (hadAlias) {\n+        facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n+          msgs.format(\"jsf.LocaleAlias.AliasRemoved\", localeId));\n+      } else {\n+        facesMessages.addGlobal(FacesMessage.SEVERITY_INFO, msgs\n+          .format(\"jsf.LocaleAlias.NoAliasToRemove\", localeId));\n+      }\n+    } else {\n+      facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n+        msgs.format(\"jsf.LocaleAlias.AliasSet\", localeId, alias));\n+    }\n+  }\n+\n+  /**\n+   * Set or remove a locale alias without showing any message.\n+   *\n+   * @param localeId for which to set alias\n+   * @param alias    new alias to use. Use empty string to remove alias.\n+   * @return true if there was already an alias, otherwise false.\n+   */\n+  private boolean setLocaleAliasSilently(LocaleId localeId, String alias) {\n+    HProjectIteration instance = getInstance();\n+    Map<LocaleId, String> aliases = instance.getLocaleAliases();\n+    boolean hadAlias = aliases.containsKey(localeId);\n+    if (isNullOrEmpty(alias)) {\n+      if (hadAlias) {\n+        ensureOverridingLocales();\n+        aliases.remove(localeId);\n+      }\n+    } else {\n+      final boolean sameAlias =\n+        hadAlias && alias.equals(aliases.get(localeId));\n+      if (!sameAlias) {\n+        ensureOverridingLocales();\n+        aliases.put(localeId, alias);\n+      }\n+    }\n+    update();\n+    return hadAlias;\n+  }\n+\n+  @Transactional\n+  public void useDefaultLocales() {\n+    identity.checkPermission(getInstance(), \"update\");\n+    setOverrideLocales(false);\n+    refreshDisabledLocales();\n+  }\n+\n+  private String enabledLocalesFilter = \"\";\n+  private String disabledLocalesFilter;\n+\n+  public List<HLocale> getEnabledLocales() {\n+    if (StringUtils.isNotEmpty(getProjectSlug())\n+      && StringUtils.isNotEmpty(getSlug())) {\n+      List<HLocale> locales =\n+        localeServiceImpl.getSupportedLanguageByProjectIteration(\n+          getProjectSlug(), getSlug());\n+      locales.sort(ComparatorUtil.LOCALE_COMPARATOR);\n+      return locales;\n+    }\n+    return Lists.newArrayList();\n+  }\n+\n+  private Map<LocaleId, Boolean> selectedEnabledLocales = Maps.newHashMap();\n+  // Not sure if this is necessary, seems to work ok on selected disabled\n+  // locales without this.\n+\n+  public Map<LocaleId, Boolean> getSelectedEnabledLocales() {\n+    if (selectedEnabledLocales == null) {\n+      selectedEnabledLocales = Maps.newHashMap();\n+      for (HLocale locale : getEnabledLocales()) {\n+        selectedEnabledLocales.put(locale.getLocaleId(), Boolean.FALSE);\n+      }\n+    }\n+    return selectedEnabledLocales;\n+  }\n+\n+  @Transactional\n+  public void disableSelectedLocales() {\n+    identity.checkPermission(getInstance(), \"update\");\n+    List<LocaleId> toRemove = Lists.newArrayList();\n+    for (Map.Entry<LocaleId, Boolean> entry : getSelectedEnabledLocales()\n+      .entrySet()) {\n+      if (entry.getValue()) {\n+        toRemove.add(entry.getKey());\n+      }\n+    }\n+    List<LocaleId> removed = Lists.newArrayList();\n+    for (LocaleId localeId : toRemove) {\n+      boolean wasEnabled = disableLocaleSilently(localeId);\n+      if (wasEnabled) {\n+        removed.add(localeId);\n+      }\n+    }\n+    update();\n+    if (removed.isEmpty()) {\n+      // This should not be possible in the UI, but maybe if multiple\n+      // users are editing it.\n+    } else if (removed.size() == 1) {\n+      facesMessages.addGlobal(FacesMessage.SEVERITY_INFO, msgs.format(\n+        \"jsf.languageSettings.LanguageDisabled\", removed.get(0)));\n+    } else {\n+      facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n+        msgs.format(\"jsf.languageSettings.LanguagesDisabled\",\n+          StringUtils.join(removed, \", \")));\n+    }\n+  }\n+\n+  private boolean disableLocaleSilently(LocaleId localeId) {\n+    HLocale locale = localeServiceImpl.getByLocaleId(localeId);\n+    return disableLocaleSilently(locale);\n+  }\n+\n+  @Transactional\n+  public void disableLocale(HLocale locale) {\n+    identity.checkPermission(getInstance(), \"update\");\n+    boolean wasEnabled = disableLocaleSilently(locale);\n+    update();\n+    if (wasEnabled) {\n+      facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n+        msgs.format(\"jsf.languageSettings.LanguageDisabled\",\n+          locale.getLocaleId()));\n+    }\n+    // TODO consider showing a message like \"Locale {0} was already\n+    // disabled.\"\n+  }\n+\n+  /**\n+   * Disable a locale without printing any message.\n+   *\n+   * @param locale to disable\n+   * @return true if the locale was enabled before this call, false otherwise.\n+   */\n+  private boolean disableLocaleSilently(HLocale locale) {\n+    boolean wasEnabled;\n+    if (getEnabledLocales().contains(locale)) {\n+      ensureOverridingLocales();\n+      wasEnabled = getInstance().getCustomizedLocales().remove(locale);\n+      refreshDisabledLocales();\n+      // TODO consider using alias from project as default rather than\n+      // none.\n+      getLocaleAliases().remove(locale.getLocaleId());\n+      getSelectedEnabledLocales().remove(locale.getLocaleId());\n+    } else {\n+      wasEnabled = false;\n+    }\n+    return wasEnabled;\n+  }\n+\n+  private List<HLocale> disabledLocales;\n+\n+  public List<HLocale> getDisabledLocales() {\n+    if (disabledLocales == null) {\n+      disabledLocales = findActiveNotEnabledLocales();\n+    }\n+    return disabledLocales;\n+  }\n+\n+  /**\n+   * Populate the list of available locales after filtering out the locales\n+   * already in the project.\n+   */\n+  private List<HLocale> findActiveNotEnabledLocales() {\n+    List<HLocale> activeLocales = localeDAO.findAllActive();\n+    // only include those not already in the project version\n+    List<HLocale> filteredList = activeLocales.stream()\n+      .filter(hLocale -> !getEnabledLocales().contains(hLocale))\n+      .sorted(ComparatorUtil.LOCALE_COMPARATOR)\n+      .collect(Collectors.toList());\n+    return filteredList;\n+  }\n+\n+  private Map<LocaleId, Boolean> selectedDisabledLocales = Maps.newHashMap();\n+\n+  @Transactional\n+  public void enableSelectedLocales() {\n+    identity.checkPermission(getInstance(), \"update\");\n+    List<LocaleId> enabled = new ArrayList<>();\n+    for (Map.Entry<LocaleId, Boolean> entry : selectedDisabledLocales\n+      .entrySet()) {\n+      if (entry.getValue()) {\n+        boolean wasDisabled = enableLocaleSilently(entry.getKey());\n         if (wasDisabled) {\n-            LocaleId localeId = locale.getLocaleId();\n-            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO, msgs\n-                    .format(\"jsf.languageSettings.LanguageEnabled\", localeId));\n+          enabled.add(entry.getKey());\n         }\n-        // TODO consider printing message like \"Locale {0} was already enabled\"\n-    }\n-\n-    private boolean enableLocaleSilently(LocaleId localeId) {\n-        HLocale locale = localeServiceImpl.getByLocaleId(localeId);\n-        return enableLocaleSilently(locale);\n-    }\n-\n-    private boolean enableLocaleSilently(HLocale locale) {\n-        final boolean wasDisabled = getDisabledLocales().contains(locale);\n-        if (wasDisabled) {\n-            ensureOverridingLocales();\n-            getInstance().getCustomizedLocales().add(locale);\n-            getSelectedEnabledLocales().put(locale.getLocaleId(),\n-                    Boolean.FALSE);\n-            refreshDisabledLocales();\n-        }\n-        // else locale already enabled, nothing to do.\n-        return wasDisabled;\n-    }\n-\n-    /**\n-     * This field is set from form input which can differ from original slug\n-     */\n-    public void setInputSlugValue(@Nullable final String inputSlugValue) {\n-        this.inputSlugValue = inputSlugValue;\n-    }\n-\n-    /**\n-     * This field is set from form input which can differ from original slug\n-     */\n-    @Nullable\n-    public String getInputSlugValue() {\n-        return this.inputSlugValue;\n-    }\n-\n-    public boolean isNewInstance() {\n-        return this.isNewInstance;\n-    }\n-\n-    public void setNewInstance(final boolean isNewInstance) {\n-        this.isNewInstance = isNewInstance;\n-    }\n-\n-    public void setSelectedProjectType(final String selectedProjectType) {\n-        this.selectedProjectType = selectedProjectType;\n-    }\n-\n-    public String getSelectedProjectType() {\n-        return this.selectedProjectType;\n-    }\n-\n-    public boolean isCopyFromVersion() {\n-        return this.copyFromVersion;\n-    }\n-\n-    public void setCopyFromVersion(final boolean copyFromVersion) {\n-        this.copyFromVersion = copyFromVersion;\n-    }\n-\n-    public String getCopyFromVersionSlug() {\n-        return this.copyFromVersionSlug;\n-    }\n-\n-    public void setCopyFromVersionSlug(final String copyFromVersionSlug) {\n-        this.copyFromVersionSlug = copyFromVersionSlug;\n-    }\n-\n-    /**\n-     * A separate map is used, rather than binding the alias map from the\n-     * project directly. This is done so that empty values are not added to the\n-     * map in every form submission, and so that a value entered in the field\n-     * for a row is not automatically updated when a different row is submitted.\n-     */\n-    public Map<LocaleId, String> getEnteredLocaleAliases() {\n-        return this.enteredLocaleAliases;\n-    }\n-\n-    /**\n-     * A separate map is used, rather than binding the alias map from the\n-     * project directly. This is done so that empty values are not added to the\n-     * map in every form submission, and so that a value entered in the field\n-     * for a row is not automatically updated when a different row is submitted.\n-     */\n-    public void setEnteredLocaleAliases(\n-            final Map<LocaleId, String> enteredLocaleAliases) {\n-        this.enteredLocaleAliases = enteredLocaleAliases;\n-    }\n-\n-    public String getEnabledLocalesFilter() {\n-        return this.enabledLocalesFilter;\n-    }\n-\n-    public void setEnabledLocalesFilter(final String enabledLocalesFilter) {\n-        this.enabledLocalesFilter = enabledLocalesFilter;\n-    }\n-\n-    public String getDisabledLocalesFilter() {\n-        return this.disabledLocalesFilter;\n-    }\n-\n-    public void setDisabledLocalesFilter(final String disabledLocalesFilter) {\n-        this.disabledLocalesFilter = disabledLocalesFilter;\n-    }\n-\n-    public void setSelectedEnabledLocales(\n-            final Map<LocaleId, Boolean> selectedEnabledLocales) {\n-        this.selectedEnabledLocales = selectedEnabledLocales;\n-    }\n-\n-    public Map<LocaleId, Boolean> getSelectedDisabledLocales() {\n-        return this.selectedDisabledLocales;\n-    }\n-\n-    public void setSelectedDisabledLocales(\n-            final Map<LocaleId, Boolean> selectedDisabledLocales) {\n-        this.selectedDisabledLocales = selectedDisabledLocales;\n-    }\n+      }\n+    }\n+    selectedDisabledLocales.clear();\n+    update();\n+    if (enabled.isEmpty()) {\n+      // This should not be possible in the UI, but maybe if multiple\n+      // users are editing it.\n+    } else if (enabled.size() == 1) {\n+      facesMessages.addGlobal(FacesMessage.SEVERITY_INFO, msgs.format(\n+        \"jsf.languageSettings.LanguageEnabled\", enabled.get(0)));\n+    } else {\n+      facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n+        msgs.format(\"jsf.languageSettings.LanguagesEnabled\",\n+          StringUtils.join(enabled, \", \")));\n+    }\n+  }\n+\n+  @Transactional\n+  public void enableLocale(HLocale locale) {\n+    identity.checkPermission(getInstance(), \"update\");\n+    boolean wasDisabled = enableLocaleSilently(locale);\n+    if (wasDisabled) {\n+      LocaleId localeId = locale.getLocaleId();\n+      facesMessages.addGlobal(FacesMessage.SEVERITY_INFO, msgs\n+        .format(\"jsf.languageSettings.LanguageEnabled\", localeId));\n+    }\n+    // TODO consider printing message like \"Locale {0} was already enabled\"\n+  }\n+\n+  private boolean enableLocaleSilently(LocaleId localeId) {\n+    HLocale locale = localeServiceImpl.getByLocaleId(localeId);\n+    return enableLocaleSilently(locale);\n+  }\n+\n+  private boolean enableLocaleSilently(HLocale locale) {\n+    final boolean wasDisabled = getDisabledLocales().contains(locale);\n+    if (wasDisabled) {\n+      ensureOverridingLocales();\n+      getInstance().getCustomizedLocales().add(locale);\n+      getSelectedEnabledLocales().put(locale.getLocaleId(),\n+        Boolean.FALSE);\n+      refreshDisabledLocales();\n+    }\n+    // else locale already enabled, nothing to do.\n+    return wasDisabled;\n+  }\n+\n+  /**\n+   * This field is set from form input which can differ from original slug\n+   */\n+  public void setInputSlugValue(@Nullable final String inputSlugValue) {\n+    this.inputSlugValue = inputSlugValue;\n+  }\n+\n+  /**\n+   * This field is set from form input which can differ from original slug\n+   */\n+  @Nullable\n+  public String getInputSlugValue() {\n+    return this.inputSlugValue;\n+  }\n+\n+  public boolean isNewInstance() {\n+    return this.isNewInstance;\n+  }\n+\n+  public void setNewInstance(final boolean isNewInstance) {\n+    this.isNewInstance = isNewInstance;\n+  }\n+\n+  public void setSelectedProjectType(final String selectedProjectType) {\n+    this.selectedProjectType = selectedProjectType;\n+  }\n+\n+  public String getSelectedProjectType() {\n+    return this.selectedProjectType;\n+  }\n+\n+  public boolean isCopyFromVersion() {\n+    return this.copyFromVersion;\n+  }\n+\n+  public void setCopyFromVersion(final boolean copyFromVersion) {\n+    this.copyFromVersion = copyFromVersion;\n+  }\n+\n+  public String getCopyFromVersionSlug() {\n+    return this.copyFromVersionSlug;\n+  }\n+\n+  public void setCopyFromVersionSlug(final String copyFromVersionSlug) {\n+    this.copyFromVersionSlug = copyFromVersionSlug;\n+  }\n+\n+  /**\n+   * A separate map is used, rather than binding the alias map from the\n+   * project directly. This is done so that empty values are not added to the\n+   * map in every form submission, and so that a value entered in the field\n+   * for a row is not automatically updated when a different row is submitted.\n+   */\n+  public Map<LocaleId, String> getEnteredLocaleAliases() {\n+    return this.enteredLocaleAliases;\n+  }\n+\n+  /**\n+   * A separate map is used, rather than binding the alias map from the\n+   * project directly. This is done so that empty values are not added to the\n+   * map in every form submission, and so that a value entered in the field\n+   * for a row is not automatically updated when a different row is submitted.\n+   */\n+  public void setEnteredLocaleAliases(\n+    final Map<LocaleId, String> enteredLocaleAliases) {\n+    this.enteredLocaleAliases = enteredLocaleAliases;\n+  }\n+\n+  public String getEnabledLocalesFilter() {\n+    return this.enabledLocalesFilter;\n+  }\n+\n+  public void setEnabledLocalesFilter(final String enabledLocalesFilter) {\n+    this.enabledLocalesFilter = enabledLocalesFilter;\n+  }\n+\n+  public String getDisabledLocalesFilter() {\n+    return this.disabledLocalesFilter;\n+  }\n+\n+  public void setDisabledLocalesFilter(final String disabledLocalesFilter) {\n+    this.disabledLocalesFilter = disabledLocalesFilter;\n+  }\n+\n+  public void setSelectedEnabledLocales(\n+    final Map<LocaleId, Boolean> selectedEnabledLocales) {\n+    this.selectedEnabledLocales = selectedEnabledLocales;\n+  }\n+\n+  public Map<LocaleId, Boolean> getSelectedDisabledLocales() {\n+    return this.selectedDisabledLocales;\n+  }\n+\n+  public void setSelectedDisabledLocales(\n+    final Map<LocaleId, Boolean> selectedDisabledLocales) {\n+    this.selectedDisabledLocales = selectedDisabledLocales;\n+  }\n }\n",
            "diff_size": 1451
        },
        {
            "tool": "naturalize",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/56/VersionHome.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/naturalize/56/VersionHome.java\nindex f56a7f4056e..7dc747831e9 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/56/VersionHome.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/naturalize/56/VersionHome.java\n@@ -311,7 +311,8 @@ public class VersionHome extends SlugHome<HProjectIteration>\n     }\n \n     public void validateSuppliedId() {\n-        getInstance(); // this will raise an EntityNotFound exception\n+        getInstance();\n+// this will raise an EntityNotFound exception\n         // when id is invalid and conversation will not\n         // start\n     }\n@@ -1090,4 +1091,4 @@ public class VersionHome extends SlugHome<HProjectIteration>\n             final Map<LocaleId, Boolean> selectedDisabledLocales) {\n         this.selectedDisabledLocales = selectedDisabledLocales;\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 3
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "289",
                    "column": "24",
                    "severity": "error",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/56/VersionHome.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/codebuff/56/VersionHome.java\nindex f56a7f4056e..5a093315278 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/56/VersionHome.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/codebuff/56/VersionHome.java\n@@ -80,14 +80,14 @@ import java.util.ResourceBundle;\n import java.util.function.Function;\n import java.util.stream.Collectors;\n \n+\n @Named(\"versionHome\")\n @ViewScoped\n @Model\n @Transactional\n public class VersionHome extends SlugHome<HProjectIteration>\n-        implements HasLanguageSettings, Serializable {\n-    private static final org.slf4j.Logger log =\n-            org.slf4j.LoggerFactory.getLogger(VersionHome.class);\n+    implements HasLanguageSettings, Serializable {\n+    private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(VersionHome.class);\n     private static final long serialVersionUID = 1L;\n \n     /**\n@@ -124,19 +124,15 @@ public class VersionHome extends SlugHome<HProjectIteration>\n     @Inject\n     private WebhookServiceImpl webhookServiceImpl;\n     @SuppressFBWarnings(\"SE_BAD_FIELD\")\n-    private Map<ValidationId, ValidationAction> availableValidations =\n-            Maps.newHashMap();\n+    private Map<ValidationId, ValidationAction> availableValidations = Maps.newHashMap();\n     private boolean isNewInstance = false;\n     private String selectedProjectType;\n     private boolean copyFromVersion = true;\n     private String copyFromVersionSlug;\n-\n     private void setDefaultCopyFromVersion() {\n         List<VersionItem> otherVersions = getOtherVersions();\n-        if (!otherVersions.isEmpty()\n-                && isEmpty(copyFromVersionSlug)) {\n-            this.copyFromVersionSlug =\n-                    otherVersions.get(0).getVersion().getSlug();\n+        if (!otherVersions.isEmpty() && isEmpty(copyFromVersionSlug)) {\n+            this.copyFromVersionSlug = otherVersions.get(0).getVersion().getSlug();\n             copyFromVersion = true;\n         } else {\n             copyFromVersion = false;\n@@ -197,13 +193,9 @@ public class VersionHome extends SlugHome<HProjectIteration>\n     public List<VersionItem> getOtherVersions() {\n         HProject project = getProject();\n         if (project != null) {\n-            List<HProjectIteration> versionList =\n-                    projectIterationDAO.getByProjectSlug(getProjectSlug(),\n-                            EntityStatus.ACTIVE, EntityStatus.READONLY);\n+            List<HProjectIteration> versionList = projectIterationDAO.getByProjectSlug(getProjectSlug(), EntityStatus.ACTIVE, EntityStatus.READONLY);\n             versionList.sort(ComparatorUtil.VERSION_CREATION_DATE_COMPARATOR);\n-            List<VersionItem> versionItems =\n-                    versionList.stream().map(this::makeVersionItem)\n-                            .collect(Collectors.toList());\n+            List<VersionItem> versionItems = versionList.stream().map(this::makeVersionItem).collect(Collectors.toList());\n             if (isEmpty(copyFromVersionSlug) && !versionItems.isEmpty()) {\n                 versionItems.get(0).setSelected(true);\n             }\n@@ -213,15 +205,13 @@ public class VersionHome extends SlugHome<HProjectIteration>\n     }\n \n     private VersionItem makeVersionItem(HProjectIteration iter) {\n-        boolean selected = StringUtils.isNotEmpty(copyFromVersionSlug) &&\n-                copyFromVersionSlug.equals(iter.getSlug());\n+        boolean selected = StringUtils.isNotEmpty(copyFromVersionSlug) && copyFromVersionSlug.equals(iter.getSlug());\n         return new VersionItem(selected, iter);\n     }\n \n     public static class VersionItem {\n         private boolean selected;\n         private HProjectIteration version;\n-\n         public boolean isSelected() {\n             return this.selected;\n         }\n@@ -240,7 +230,7 @@ public class VersionHome extends SlugHome<HProjectIteration>\n \n         @java.beans.ConstructorProperties({ \"selected\", \"version\" })\n         public VersionItem(final boolean selected,\n-                final HProjectIteration version) {\n+        final HProjectIteration version) {\n             this.selected = selected;\n             this.version = version;\n         }\n@@ -249,62 +239,47 @@ public class VersionHome extends SlugHome<HProjectIteration>\n     @Override\n     protected HProjectIteration loadInstance() {\n         Session session = (Session) getEntityManager().getDelegate();\n-        HProject project = (HProject) session.byNaturalId(HProject.class)\n-                .using(\"slug\", getProjectSlug()).load();\n+        HProject project = (HProject) session.byNaturalId(HProject.class).using(\"slug\", getProjectSlug()).load();\n         validateProjectState(project);\n         if (versionId == null) {\n             HProject targetProject = projectDAO.getBySlug(getProjectSlug());\n             validateProjectState(targetProject);\n-            HProjectIteration iteration = (HProjectIteration) session\n-                    .byNaturalId(HProjectIteration.class)\n-                    .using(\"slug\", getSlug())\n-                    .using(\"project\", targetProject)\n-                    .load();\n+            HProjectIteration iteration = (HProjectIteration) session.byNaturalId(HProjectIteration.class).using(\"slug\", getSlug()).using(\"project\", targetProject).load();\n             validateIterationState(iteration);\n             versionId = iteration.getId();\n             return iteration;\n         } else {\n-            HProjectIteration iteration = (HProjectIteration) session\n-                    .load(HProjectIteration.class, versionId);\n+            HProjectIteration iteration = (HProjectIteration) session.load(HProjectIteration.class, versionId);\n             validateIterationState(iteration);\n             return iteration;\n         }\n     }\n \n     private void validateIterationState(HProjectIteration iteration) {\n-        if (iteration == null\n-                || iteration.getStatus() == EntityStatus.OBSOLETE) {\n-            log.warn(\n-                    \"Project version [id={}, slug={}], does not exist or is soft deleted: {}\",\n-                    versionId, getSlug(), iteration);\n+        if (iteration == null || iteration.getStatus() == EntityStatus.OBSOLETE) {\n+            log.warn(\"Project version [id={}, slug={}], does not exist or is soft deleted: {}\", versionId, getSlug(), iteration);\n             throw new VersionNotFoundException(getProjectSlug(), getSlug());\n         }\n     }\n \n     private void validateProjectState(HProject project) {\n         if (project == null || project.getStatus() == EntityStatus.OBSOLETE) {\n-            log.warn(\"Project [slug={}], does not exist or is soft deleted: {}\",\n-                    getProjectSlug(), project);\n+            log.warn(\"Project [slug={}], does not exist or is soft deleted: {}\", getProjectSlug(), project);\n             throw new ProjectNotFoundException(getProjectSlug());\n         }\n     }\n \n     public List<ValidationAction> getValidationList() {\n-        List<ValidationAction> sortedList =\n-                Lists.newArrayList(getValidations().values());\n-        Collections.sort(sortedList,\n-                ValidationFactory.ValidationActionComparator);\n+        List<ValidationAction> sortedList = Lists.newArrayList(getValidations().values());\n+        Collections.sort(sortedList, ValidationFactory.ValidationActionComparator);\n         return sortedList;\n     }\n \n     private Map<ValidationId, ValidationAction> getValidations() {\n         if (availableValidations.isEmpty()) {\n-            Collection<ValidationAction> validationList =\n-                    validationServiceImpl.getValidationActions(getProjectSlug(),\n-                            getInstance().getSlug());\n+            Collection<ValidationAction> validationList = validationServiceImpl.getValidationActions(getProjectSlug(), getInstance().getSlug());\n             for (ValidationAction validationAction : validationList) {\n-                availableValidations.put(validationAction.getId(),\n-                        validationAction);\n+                availableValidations.put(validationAction.getId(), validationAction);\n             }\n         }\n         return availableValidations;\n@@ -318,8 +293,7 @@ public class VersionHome extends SlugHome<HProjectIteration>\n \n     public ProjectType getProjectType() {\n         if (getInstance().getProjectType() == null) {\n-            getInstance().setProjectType(\n-                    getInstance().getProject().getDefaultProjectType());\n+            getInstance().setProjectType(getInstance().getProject().getDefaultProjectType());\n         }\n         return getInstance().getProjectType();\n     }\n@@ -331,8 +305,7 @@ public class VersionHome extends SlugHome<HProjectIteration>\n \n     public void validateProjectSlug() {\n         if (projectDAO.getBySlug(getProjectSlug()) == null) {\n-            throw new EntityNotFoundException(\n-                    \"no entity with slug \" + getProjectSlug());\n+            throw new EntityNotFoundException(\"no entity with slug \" + getProjectSlug());\n         }\n     }\n \n@@ -344,14 +317,13 @@ public class VersionHome extends SlugHome<HProjectIteration>\n     public boolean validateSlug(String slug, String componentId) {\n         if (!isSlugAvailable(slug)) {\n             facesMessages.addToControl(componentId,\n-                    \"This Version ID has been used in this project\");\n+                \"This Version ID has been used in this project\");\n             return false;\n         }\n+\n         boolean valid = new SlugValidator().isValid(slug, null);\n         if (!valid) {\n-            String validationMessages =\n-                    ResourceBundle.getBundle(\"ValidationMessages\").getString(\n-                            \"javax.validation.constraints.Slug.message\");\n+            String validationMessages = ResourceBundle.getBundle(\"ValidationMessages\").getString(\"javax.validation.constraints.Slug.message\");\n             facesMessages.addToControl(componentId, validationMessages);\n             return false;\n         }\n@@ -359,8 +331,7 @@ public class VersionHome extends SlugHome<HProjectIteration>\n     }\n \n     public boolean isSlugAvailable(String slug) {\n-        return slugEntityServiceImpl.isProjectIterationSlugAvailable(slug,\n-                getProjectSlug());\n+        return slugEntityServiceImpl.isProjectIterationSlugAvailable(slug, getProjectSlug());\n     }\n \n     @Transactional\n@@ -377,10 +348,8 @@ public class VersionHome extends SlugHome<HProjectIteration>\n \n     @Transactional\n     public void copyVersion() {\n-        copyVersionManager.startCopyVersion(getProjectSlug(),\n-                copyFromVersionSlug, inputSlugValue);\n-        facesMessages.addGlobal(msgs.format(\"jsf.copyVersion.started\", inputSlugValue,\n-                copyFromVersionSlug));\n+        copyVersionManager.startCopyVersion(getProjectSlug(), copyFromVersionSlug, inputSlugValue);\n+        facesMessages.addGlobal(msgs.format(\"jsf.copyVersion.started\", inputSlugValue, copyFromVersionSlug));\n     }\n \n     public void setSlug(String slug) {\n@@ -403,15 +372,11 @@ public class VersionHome extends SlugHome<HProjectIteration>\n         // so it should copy the setting for isOverrideLocales,\n         // and all enabled locales and locale alias data if it is\n         // overriding.\n-        List<HLocale> projectLocales = localeServiceImpl\n-                .getSupportedLanguageByProject(getProjectSlug());\n+        List<HLocale> projectLocales = localeServiceImpl.getSupportedLanguageByProject(getProjectSlug());\n         getInstance().getCustomizedLocales().addAll(projectLocales);\n-        getInstance().getCustomizedValidations()\n-                .putAll(project.getCustomizedValidations());\n+        getInstance().getCustomizedValidations().putAll(project.getCustomizedValidations());\n         String result = super.persist();\n-        webhookServiceImpl.processWebhookVersionChanged(getProjectSlug(), slug,\n-                getProject().getWebHooks(),\n-                VersionChangedEvent.ChangeType.CREATE);\n+        webhookServiceImpl.processWebhookVersionChanged(getProjectSlug(), slug, getProject().getWebHooks(), VersionChangedEvent.ChangeType.CREATE);\n         return result;\n     }\n \n@@ -422,8 +387,7 @@ public class VersionHome extends SlugHome<HProjectIteration>\n \n     @Override\n     public NaturalIdentifier getNaturalId() {\n-        return Restrictions.naturalId().set(\"slug\", getSlug()).set(\"project\",\n-                projectDAO.getBySlug(getProjectSlug()));\n+        return Restrictions.naturalId().set(\"slug\", getSlug()).set(\"project\", projectDAO.getBySlug(getProjectSlug()));\n     }\n \n     @Override\n@@ -432,18 +396,15 @@ public class VersionHome extends SlugHome<HProjectIteration>\n     }\n \n     public boolean isValidationsSameAsProject() {\n-        Collection<ValidationAction> versionValidations = validationServiceImpl\n-                .getValidationActions(getProjectSlug(), getSlug());\n-        Collection<ValidationAction> projectValidations =\n-                validationServiceImpl.getValidationActions(getProjectSlug());\n+        Collection<ValidationAction> versionValidations = validationServiceImpl.getValidationActions(getProjectSlug(), getSlug());\n+        Collection<ValidationAction> projectValidations = validationServiceImpl.getValidationActions(getProjectSlug());\n         return versionValidations.equals(projectValidations);\n     }\n \n     @Transactional\n     public void copyValidationFromProject() {\n         getInstance().getCustomizedValidations().clear();\n-        getInstance().getCustomizedValidations()\n-                .putAll(getInstance().getProject().getCustomizedValidations());\n+        getInstance().getCustomizedValidations().putAll(getInstance().getProject().getCustomizedValidations());\n         availableValidations.clear();\n         update();\n         facesMessages.addGlobal(msgs.get(\"jsf.iteration.CopyProjectValidations.message\"));\n@@ -455,18 +416,18 @@ public class VersionHome extends SlugHome<HProjectIteration>\n      *\n      * @return the String \"updated\"\n      */\n+\n     @Override\n     @Transactional\n     public String update() {\n         identity.checkPermission(getInstance(), \"update\");\n-        if (!getSlug().equals(getInputSlugValue())\n-                && !validateSlug(getInputSlugValue(), \"slug\")) {\n+        if (!getSlug().equals(getInputSlugValue()) && !validateSlug(getInputSlugValue(), \"slug\")) {\n             return null;\n         }\n-        if (getInputSlugValue() != null\n-                && !getSlug().equals(getInputSlugValue())) {\n+        if (getInputSlugValue() != null && !getSlug().equals(getInputSlugValue())) {\n             getInstance().setSlug(getInputSlugValue());\n         }\n+\n         boolean softDeleted = false;\n         if (getInstance().getStatus() == EntityStatus.OBSOLETE) {\n             // if we offer delete in REST, we need to move this to hibernate\n@@ -481,8 +442,7 @@ public class VersionHome extends SlugHome<HProjectIteration>\n             urlUtil.redirectToInternal(url);\n             return state;\n         }\n-        facesMessages.addGlobal(SEVERITY_INFO,\n-                msgs.get(\"jsf.version.settings.updated\"));\n+        facesMessages.addGlobal(SEVERITY_INFO, msgs.get(\"jsf.version.settings.updated\"));\n         if (!getSlug().equals(getInstance().getSlug())) {\n             projectAndVersionSlug.setVersionSlug(getInstance().getSlug());\n             return \"version-slug-updated\";\n@@ -500,11 +460,10 @@ public class VersionHome extends SlugHome<HProjectIteration>\n         identity.checkPermission(getInstance(), \"update\");\n         if (getProject().getStatus() == EntityStatus.READONLY) {\n             facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n-                    \"Parent project is read-only!\");\n+                \"Parent project is read-only!\");\n             return;\n         }\n-        String message = msgs.format(\"jsf.iteration.status.updated\",\n-                EntityStatus.valueOf(initial));\n+        String message = msgs.format(\"jsf.iteration.status.updated\", EntityStatus.valueOf(initial));\n         getInstance().setStatus(EntityStatus.valueOf(initial));\n         if (getInstance().getStatus() == EntityStatus.OBSOLETE) {\n             message = msgs.get(\"jsf.iteration.deleted\");\n@@ -517,21 +476,19 @@ public class VersionHome extends SlugHome<HProjectIteration>\n     public void deleteSelf() {\n         String slug = getInstance().getSlug();\n         updateStatus('O');\n-        webhookServiceImpl.processWebhookVersionChanged(getProjectSlug(), slug,\n-                getProject().getWebHooks(),\n-                VersionChangedEvent.ChangeType.DELETE);\n+        webhookServiceImpl.processWebhookVersionChanged(getProjectSlug(), slug, getProject().getWebHooks(), VersionChangedEvent.ChangeType.DELETE);\n     }\n \n     @Transactional\n     public void updateSelectedProjectType(ValueChangeEvent e) {\n-        selectedProjectType = (String) e.getNewValue();\n+        selectedProjectType =\n+            (String) e.getNewValue();\n         updateProjectType();\n     }\n \n     @Transactional\n     public void copyProjectTypeFromProject() {\n-        getInstance().setProjectType(\n-                getInstance().getProject().getDefaultProjectType());\n+        getInstance().setProjectType(getInstance().getProject().getDefaultProjectType());\n         update();\n         facesMessages.addGlobal(msgs.get(\"jsf.iteration.CopyProjectType.message\"));\n     }\n@@ -540,30 +497,21 @@ public class VersionHome extends SlugHome<HProjectIteration>\n      * @return comma-separated list of accepted file extensions. May be an empty\n      *         string\n      */\n+\n     @SuppressWarnings(\"deprecation\")\n     public String getAcceptedSourceFileExtensions() {\n-        List<String> supportedTypes =\n-                ProjectType.getSupportedSourceFileTypes(getProjectType())\n-                        .stream().map(docType -> Joiner.on(\",\")\n-                        .join(docType.getSourceExtensions()))\n-                        .collect(Collectors.toList());\n+        List<String> supportedTypes = ProjectType.getSupportedSourceFileTypes(getProjectType()).stream().map(docType -> Joiner.on(\",\").join(docType.getSourceExtensions())).collect(Collectors.toList());\n         return Joiner.on(\", \").join(supportedTypes);\n     }\n \n     @SuppressWarnings(\"deprecation\")\n     public String getAcceptedSourceFile() {\n-        List<String> supportedTypes =\n-                ProjectType.getSupportedSourceFileTypes(getProjectType())\n-                        .stream()\n-                        .map(docType -> docType.name() + \"[\" + Joiner.on(\",\")\n-                                .join(docType.getSourceExtensions()) + \"]\")\n-                        .collect(Collectors.toList());\n+        List<String> supportedTypes = ProjectType.getSupportedSourceFileTypes(getProjectType()).stream().map(docType -> docType.name() + \"[\" + Joiner.on(\",\").join(docType.getSourceExtensions()) + \"]\").collect(Collectors.toList());\n         return Joiner.on(\", \").join(supportedTypes);\n     }\n \n     private void updateProjectType() {\n-        if (!isEmpty(selectedProjectType)\n-                && !selectedProjectType.equals(\"null\")) {\n+        if (!isEmpty(selectedProjectType) && !selectedProjectType.equals(\"null\")) {\n             ProjectType projectType = ProjectType.valueOf(selectedProjectType);\n             getInstance().setProjectType(projectType);\n         } else {\n@@ -579,37 +527,28 @@ public class VersionHome extends SlugHome<HProjectIteration>\n     public void updateValidationOption(String name, String state) {\n         identity.checkPermission(getInstance(), \"update\");\n         ValidationId validationId = ValidationId.valueOf(name);\n-        for (Map.Entry<ValidationId, ValidationAction> entry : getValidations()\n-                .entrySet()) {\n+        for (Map.Entry<ValidationId, ValidationAction> entry : getValidations().entrySet()) {\n             if (entry.getKey().name().equals(name)) {\n-                getValidations().get(validationId)\n-                        .setState(ValidationAction.State.valueOf(state));\n-                getInstance().getCustomizedValidations().put(\n-                        entry.getKey().name(),\n-                        entry.getValue().getState().name());\n+                getValidations().get(validationId).setState(ValidationAction.State.valueOf(state));\n+                getInstance().getCustomizedValidations().put(entry.getKey().name(), entry.getValue().getState().name());\n                 ensureMutualExclusivity(getValidations().get(validationId));\n                 break;\n             }\n         }\n         update();\n-        facesMessages.addGlobal(msgs.format(\"jsf.validation.updated\",\n-                validationId.getDisplayName(), state));\n+        facesMessages.addGlobal(msgs.format(\"jsf.validation.updated\", validationId.getDisplayName(), state));\n     }\n \n     /**\n      * If this action is enabled(Warning or Error), then it's exclusive\n      * validation will be turn off\n      */\n-    private void\n-            ensureMutualExclusivity(ValidationAction selectedValidationAction) {\n+\n+    private void ensureMutualExclusivity(ValidationAction selectedValidationAction) {\n         if (selectedValidationAction.getState() != ValidationAction.State.Off) {\n-            for (ValidationAction exclusiveValAction : selectedValidationAction\n-                    .getExclusiveValidations()) {\n-                getInstance().getCustomizedValidations().put(\n-                        exclusiveValAction.getId().name(),\n-                        ValidationAction.State.Off.name());\n-                getValidations().get(exclusiveValAction.getId())\n-                        .setState(ValidationAction.State.Off);\n+            for (ValidationAction exclusiveValAction : selectedValidationAction.getExclusiveValidations()) {\n+                getInstance().getCustomizedValidations().put(exclusiveValAction.getId().name(), ValidationAction.State.Off.name());\n+                getValidations().get(exclusiveValAction.getId()).setState(ValidationAction.State.Off);\n             }\n         }\n     }\n@@ -638,8 +577,7 @@ public class VersionHome extends SlugHome<HProjectIteration>\n     public void removeAllLocaleAliases() {\n         identity.checkPermission(getInstance(), \"update\");\n         List<LocaleId> removed = new ArrayList<>();\n-        List<LocaleId> aliasedLocales =\n-                new ArrayList<>(getLocaleAliases().keySet());\n+        List<LocaleId> aliasedLocales = new ArrayList<>(getLocaleAliases().keySet());\n         if (!aliasedLocales.isEmpty()) {\n             ensureOverridingLocales();\n             for (LocaleId aliasedLocale : aliasedLocales) {\n@@ -656,6 +594,7 @@ public class VersionHome extends SlugHome<HProjectIteration>\n     /**\n      * Ensure that isOverrideLocales is true, and copy data if necessary.\n      */\n+\n     private void ensureOverridingLocales() {\n         if (!isOverrideLocales()) {\n             startOverridingLocales();\n@@ -666,6 +605,7 @@ public class VersionHome extends SlugHome<HProjectIteration>\n      * Copy locale data from project and set overrideLocales, in preparation for\n      * making customizations to the locales.\n      */\n+\n     private void startOverridingLocales() {\n         // Copied before setOverrideLocales(true) so that the currently returned\n         // values will be used as the basis for any customization.\n@@ -686,6 +626,7 @@ public class VersionHome extends SlugHome<HProjectIteration>\n     /**\n      * Update disabled locales to be consistent with enabled locales.\n      */\n+\n     private void refreshDisabledLocales() {\n         // will be re-generated with correct values next time it is fetched.\n         disabledLocales = null;\n@@ -695,8 +636,7 @@ public class VersionHome extends SlugHome<HProjectIteration>\n     public void removeSelectedLocaleAliases() {\n         identity.checkPermission(getInstance(), \"update\");\n         List<LocaleId> removed = new ArrayList<>();\n-        for (Map.Entry<LocaleId, Boolean> entry : getSelectedEnabledLocales()\n-                .entrySet()) {\n+        for (Map.Entry<LocaleId, Boolean> entry : getSelectedEnabledLocales().entrySet()) {\n             if (entry.getValue()) {\n                 boolean hadAlias = removeAliasSilently(entry.getKey());\n                 if (hadAlias) {\n@@ -714,17 +654,14 @@ public class VersionHome extends SlugHome<HProjectIteration>\n      * @param removed\n      *            ids of locales that had aliases removed\n      */\n+\n     private void showRemovedAliasesMessage(List<LocaleId> removed) {\n         if (removed.isEmpty()) {\n-            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n-                    msgs.get(\"jsf.LocaleAlias.NoAliasesToRemove\"));\n+            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO, msgs.get(\"jsf.LocaleAlias.NoAliasesToRemove\"));\n         } else if (removed.size() == 1) {\n-            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO, msgs\n-                    .format(\"jsf.LocaleAlias.AliasRemoved\", removed.get(0)));\n+            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO, msgs.format(\"jsf.LocaleAlias.AliasRemoved\", removed.get(0)));\n         } else {\n-            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n-                    msgs.format(\"jsf.LocaleAlias.AliasesRemoved\",\n-                            StringUtils.join(removed, \", \")));\n+            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO, msgs.format(\"jsf.LocaleAlias.AliasesRemoved\", StringUtils.join(removed, \", \")));\n         }\n     }\n \n@@ -746,8 +683,8 @@ public class VersionHome extends SlugHome<HProjectIteration>\n      * map in every form submission, and so that a value entered in the field\n      * for a row is not automatically updated when a different row is submitted.\n      */\n-    private Map<LocaleId, String> enteredLocaleAliases = Maps.newHashMap();\n \n+    private Map<LocaleId, String> enteredLocaleAliases = Maps.newHashMap();\n     @Transactional\n     public void updateToEnteredLocaleAlias(LocaleId localeId) {\n         identity.checkPermission(getInstance(), \"update\");\n@@ -759,15 +696,12 @@ public class VersionHome extends SlugHome<HProjectIteration>\n         boolean hadAlias = setLocaleAliasSilently(localeId, alias);\n         if (isNullOrEmpty(alias)) {\n             if (hadAlias) {\n-                facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n-                        msgs.format(\"jsf.LocaleAlias.AliasRemoved\", localeId));\n+                facesMessages.addGlobal(FacesMessage.SEVERITY_INFO, msgs.format(\"jsf.LocaleAlias.AliasRemoved\", localeId));\n             } else {\n-                facesMessages.addGlobal(FacesMessage.SEVERITY_INFO, msgs\n-                        .format(\"jsf.LocaleAlias.NoAliasToRemove\", localeId));\n+                facesMessages.addGlobal(FacesMessage.SEVERITY_INFO, msgs.format(\"jsf.LocaleAlias.NoAliasToRemove\", localeId));\n             }\n         } else {\n-            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n-                    msgs.format(\"jsf.LocaleAlias.AliasSet\", localeId, alias));\n+            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO, msgs.format(\"jsf.LocaleAlias.AliasSet\", localeId, alias));\n         }\n     }\n \n@@ -780,6 +714,7 @@ public class VersionHome extends SlugHome<HProjectIteration>\n      *            new alias to use. Use empty string to remove alias.\n      * @return true if there was already an alias, otherwise false.\n      */\n+\n     private boolean setLocaleAliasSilently(LocaleId localeId, String alias) {\n         HProjectIteration instance = getInstance();\n         Map<LocaleId, String> aliases = instance.getLocaleAliases();\n@@ -790,8 +725,7 @@ public class VersionHome extends SlugHome<HProjectIteration>\n                 aliases.remove(localeId);\n             }\n         } else {\n-            final boolean sameAlias =\n-                    hadAlias && alias.equals(aliases.get(localeId));\n+            final boolean sameAlias = hadAlias && alias.equals(aliases.get(localeId));\n             if (!sameAlias) {\n                 ensureOverridingLocales();\n                 aliases.put(localeId, alias);\n@@ -810,13 +744,9 @@ public class VersionHome extends SlugHome<HProjectIteration>\n \n     private String enabledLocalesFilter = \"\";\n     private String disabledLocalesFilter;\n-\n     public List<HLocale> getEnabledLocales() {\n-        if (StringUtils.isNotEmpty(getProjectSlug())\n-                && StringUtils.isNotEmpty(getSlug())) {\n-            List<HLocale> locales =\n-                    localeServiceImpl.getSupportedLanguageByProjectIteration(\n-                            getProjectSlug(), getSlug());\n+        if (StringUtils.isNotEmpty(getProjectSlug()) && StringUtils.isNotEmpty(getSlug())) {\n+            List<HLocale> locales = localeServiceImpl.getSupportedLanguageByProjectIteration(getProjectSlug(), getSlug());\n             locales.sort(ComparatorUtil.LOCALE_COMPARATOR);\n             return locales;\n         }\n@@ -826,7 +756,6 @@ public class VersionHome extends SlugHome<HProjectIteration>\n     private Map<LocaleId, Boolean> selectedEnabledLocales = Maps.newHashMap();\n     // Not sure if this is necessary, seems to work ok on selected disabled\n     // locales without this.\n-\n     public Map<LocaleId, Boolean> getSelectedEnabledLocales() {\n         if (selectedEnabledLocales == null) {\n             selectedEnabledLocales = Maps.newHashMap();\n@@ -841,8 +770,7 @@ public class VersionHome extends SlugHome<HProjectIteration>\n     public void disableSelectedLocales() {\n         identity.checkPermission(getInstance(), \"update\");\n         List<LocaleId> toRemove = Lists.newArrayList();\n-        for (Map.Entry<LocaleId, Boolean> entry : getSelectedEnabledLocales()\n-                .entrySet()) {\n+        for (Map.Entry<LocaleId, Boolean> entry : getSelectedEnabledLocales().entrySet()) {\n             if (entry.getValue()) {\n                 toRemove.add(entry.getKey());\n             }\n@@ -858,13 +786,11 @@ public class VersionHome extends SlugHome<HProjectIteration>\n         if (removed.isEmpty()) {\n             // This should not be possible in the UI, but maybe if multiple\n             // users are editing it.\n+\n         } else if (removed.size() == 1) {\n-            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO, msgs.format(\n-                    \"jsf.languageSettings.LanguageDisabled\", removed.get(0)));\n+            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO, msgs.format(\"jsf.languageSettings.LanguageDisabled\", removed.get(0)));\n         } else {\n-            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n-                    msgs.format(\"jsf.languageSettings.LanguagesDisabled\",\n-                            StringUtils.join(removed, \", \")));\n+            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO, msgs.format(\"jsf.languageSettings.LanguagesDisabled\", StringUtils.join(removed, \", \")));\n         }\n     }\n \n@@ -879,9 +805,7 @@ public class VersionHome extends SlugHome<HProjectIteration>\n         boolean wasEnabled = disableLocaleSilently(locale);\n         update();\n         if (wasEnabled) {\n-            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n-                    msgs.format(\"jsf.languageSettings.LanguageDisabled\",\n-                            locale.getLocaleId()));\n+            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO, msgs.format(\"jsf.languageSettings.LanguageDisabled\", locale.getLocaleId()));\n         }\n         // TODO consider showing a message like \"Locale {0} was already\n         // disabled.\"\n@@ -894,6 +818,7 @@ public class VersionHome extends SlugHome<HProjectIteration>\n      *            to disable\n      * @return true if the locale was enabled before this call, false otherwise.\n      */\n+\n     private boolean disableLocaleSilently(HLocale locale) {\n         boolean wasEnabled;\n         if (getEnabledLocales().contains(locale)) {\n@@ -911,7 +836,6 @@ public class VersionHome extends SlugHome<HProjectIteration>\n     }\n \n     private List<HLocale> disabledLocales;\n-\n     public List<HLocale> getDisabledLocales() {\n         if (disabledLocales == null) {\n             disabledLocales = findActiveNotEnabledLocales();\n@@ -923,24 +847,20 @@ public class VersionHome extends SlugHome<HProjectIteration>\n      * Populate the list of available locales after filtering out the locales\n      * already in the project.\n      */\n+\n     private List<HLocale> findActiveNotEnabledLocales() {\n         List<HLocale> activeLocales = localeDAO.findAllActive();\n         // only include those not already in the project version\n-        List<HLocale> filteredList = activeLocales.stream()\n-                .filter(hLocale -> !getEnabledLocales().contains(hLocale))\n-                .sorted(ComparatorUtil.LOCALE_COMPARATOR)\n-                .collect(Collectors.toList());\n+        List<HLocale> filteredList = activeLocales.stream().filter(hLocale -> !getEnabledLocales().contains(hLocale)).sorted(ComparatorUtil.LOCALE_COMPARATOR).collect(Collectors.toList());\n         return filteredList;\n     }\n \n     private Map<LocaleId, Boolean> selectedDisabledLocales = Maps.newHashMap();\n-\n     @Transactional\n     public void enableSelectedLocales() {\n         identity.checkPermission(getInstance(), \"update\");\n         List<LocaleId> enabled = new ArrayList<>();\n-        for (Map.Entry<LocaleId, Boolean> entry : selectedDisabledLocales\n-                .entrySet()) {\n+        for (Map.Entry<LocaleId, Boolean> entry : selectedDisabledLocales.entrySet()) {\n             if (entry.getValue()) {\n                 boolean wasDisabled = enableLocaleSilently(entry.getKey());\n                 if (wasDisabled) {\n@@ -953,13 +873,11 @@ public class VersionHome extends SlugHome<HProjectIteration>\n         if (enabled.isEmpty()) {\n             // This should not be possible in the UI, but maybe if multiple\n             // users are editing it.\n+\n         } else if (enabled.size() == 1) {\n-            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO, msgs.format(\n-                    \"jsf.languageSettings.LanguageEnabled\", enabled.get(0)));\n+            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO, msgs.format(\"jsf.languageSettings.LanguageEnabled\", enabled.get(0)));\n         } else {\n-            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n-                    msgs.format(\"jsf.languageSettings.LanguagesEnabled\",\n-                            StringUtils.join(enabled, \", \")));\n+            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO, msgs.format(\"jsf.languageSettings.LanguagesEnabled\", StringUtils.join(enabled, \", \")));\n         }\n     }\n \n@@ -969,8 +887,7 @@ public class VersionHome extends SlugHome<HProjectIteration>\n         boolean wasDisabled = enableLocaleSilently(locale);\n         if (wasDisabled) {\n             LocaleId localeId = locale.getLocaleId();\n-            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO, msgs\n-                    .format(\"jsf.languageSettings.LanguageEnabled\", localeId));\n+            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO, msgs.format(\"jsf.languageSettings.LanguageEnabled\", localeId));\n         }\n         // TODO consider printing message like \"Locale {0} was already enabled\"\n     }\n@@ -985,8 +902,7 @@ public class VersionHome extends SlugHome<HProjectIteration>\n         if (wasDisabled) {\n             ensureOverridingLocales();\n             getInstance().getCustomizedLocales().add(locale);\n-            getSelectedEnabledLocales().put(locale.getLocaleId(),\n-                    Boolean.FALSE);\n+            getSelectedEnabledLocales().put(locale.getLocaleId(), Boolean.FALSE);\n             refreshDisabledLocales();\n         }\n         // else locale already enabled, nothing to do.\n@@ -996,6 +912,7 @@ public class VersionHome extends SlugHome<HProjectIteration>\n     /**\n      * This field is set from form input which can differ from original slug\n      */\n+\n     public void setInputSlugValue(@Nullable final String inputSlugValue) {\n         this.inputSlugValue = inputSlugValue;\n     }\n@@ -1003,6 +920,7 @@ public class VersionHome extends SlugHome<HProjectIteration>\n     /**\n      * This field is set from form input which can differ from original slug\n      */\n+\n     @Nullable\n     public String getInputSlugValue() {\n         return this.inputSlugValue;\n@@ -1046,6 +964,7 @@ public class VersionHome extends SlugHome<HProjectIteration>\n      * map in every form submission, and so that a value entered in the field\n      * for a row is not automatically updated when a different row is submitted.\n      */\n+\n     public Map<LocaleId, String> getEnteredLocaleAliases() {\n         return this.enteredLocaleAliases;\n     }\n@@ -1056,8 +975,8 @@ public class VersionHome extends SlugHome<HProjectIteration>\n      * map in every form submission, and so that a value entered in the field\n      * for a row is not automatically updated when a different row is submitted.\n      */\n-    public void setEnteredLocaleAliases(\n-            final Map<LocaleId, String> enteredLocaleAliases) {\n+\n+    public void setEnteredLocaleAliases(final Map<LocaleId, String> enteredLocaleAliases) {\n         this.enteredLocaleAliases = enteredLocaleAliases;\n     }\n \n@@ -1077,8 +996,7 @@ public class VersionHome extends SlugHome<HProjectIteration>\n         this.disabledLocalesFilter = disabledLocalesFilter;\n     }\n \n-    public void setSelectedEnabledLocales(\n-            final Map<LocaleId, Boolean> selectedEnabledLocales) {\n+    public void setSelectedEnabledLocales(final Map<LocaleId, Boolean> selectedEnabledLocales) {\n         this.selectedEnabledLocales = selectedEnabledLocales;\n     }\n \n@@ -1086,8 +1004,7 @@ public class VersionHome extends SlugHome<HProjectIteration>\n         return this.selectedDisabledLocales;\n     }\n \n-    public void setSelectedDisabledLocales(\n-            final Map<LocaleId, Boolean> selectedDisabledLocales) {\n+    public void setSelectedDisabledLocales(final Map<LocaleId, Boolean> selectedDisabledLocales) {\n         this.selectedDisabledLocales = selectedDisabledLocales;\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 200
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "314",
                    "column": "24",
                    "severity": "error",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/56/VersionHome.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/styler_three_grams/56/VersionHome.java\nindex f56a7f4056e..ce4f11c0706 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/56/VersionHome.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/styler_three_grams/56/VersionHome.java\n@@ -311,8 +311,9 @@ public class VersionHome extends SlugHome<HProjectIteration>\n     }\n \n     public void validateSuppliedId() {\n-        getInstance(); // this will raise an EntityNotFound exception\n-        // when id is invalid and conversation will not\n+        getInstance();\n+        // this will raise an EntityNotFound exception\n+         // when id is invalid and conversation will not\n         // start\n     }\n \n",
            "diff_size": 3
        }
    ],
    "repaired_by": [
        "styler",
        "naturalize",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "intellij",
        "codebuff",
        "styler_random"
    ]
}