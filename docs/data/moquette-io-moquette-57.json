{
    "project_name": "moquette-io-moquette",
    "error_id": "57",
    "information": {
        "errors": [
            {
                "line": "1",
                "severity": "warning",
                "message": "missing copyright header",
                "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
            }
        ]
    },
    "source_code": "package io.moquette.broker.subscriptions;\n\nimport java.util.Collections;\nimport java.util.HashSet;",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "1",
                    "severity": "warning",
                    "message": "missing copyright header",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "1",
                    "severity": "warning",
                    "message": "missing copyright header",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/errored/1/57/CTrie.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/intellij/57/CTrie.java\nindex 70e279f0b42..63a9be9e450 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/errored/1/57/CTrie.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/intellij/57/CTrie.java\n@@ -7,227 +7,225 @@ import java.util.Set;\n \n public class CTrie {\n \n-    interface IVisitor<T> {\n-\n-        void visit(CNode node, int deep);\n-\n-        T getResult();\n-    }\n-\n-    private static final Token ROOT = new Token(\"root\");\n-    private static final INode NO_PARENT = null;\n-\n-    private enum Action {\n-        OK, REPEAT\n-    }\n-\n-    INode root;\n-\n-    CTrie() {\n-        final CNode mainNode = new CNode();\n-        mainNode.token = ROOT;\n-        this.root = new INode(mainNode);\n-    }\n-\n-    Optional<CNode> lookup(Topic topic) {\n-        INode inode = this.root;\n-        Token token = topic.headToken();\n-        while (!topic.isEmpty() && (inode.mainNode().anyChildrenMatch(token))) {\n-            topic = topic.exceptHeadToken();\n-            inode = inode.mainNode().childOf(token);\n-            token = topic.headToken();\n-        }\n-        if (inode == null || !topic.isEmpty()) {\n-            return Optional.empty();\n-        }\n-        return Optional.of(inode.mainNode());\n-    }\n-\n-    enum NavigationAction {\n-        MATCH, GODEEP, STOP\n-    }\n-\n-    private NavigationAction evaluate(Topic topic, CNode cnode) {\n-        if (Token.MULTI.equals(cnode.token)) {\n-            return NavigationAction.MATCH;\n-        }\n-        if (topic.isEmpty()) {\n-            return NavigationAction.STOP;\n-        }\n-        final Token token = topic.headToken();\n-        if (!(Token.SINGLE.equals(cnode.token) || cnode.token.equals(token) || ROOT.equals(cnode.token))) {\n-            return NavigationAction.STOP;\n-        }\n-        return NavigationAction.GODEEP;\n-    }\n-\n-    public Set<Subscription> recursiveMatch(Topic topic) {\n-        return recursiveMatch(topic, this.root);\n-    }\n-\n-    private Set<Subscription> recursiveMatch(Topic topic, INode inode) {\n-        CNode cnode = inode.mainNode();\n-        NavigationAction action = evaluate(topic, cnode);\n-        if (action == NavigationAction.MATCH) {\n-            return cnode.subscriptions;\n-        }\n-        if (action == NavigationAction.STOP) {\n-            return Collections.emptySet();\n-        }\n-        if (cnode instanceof TNode) {\n-            return Collections.emptySet();\n-        }\n-        Topic remainingTopic = (ROOT.equals(cnode.token)) ? topic : topic.exceptHeadToken();\n-        Set<Subscription> subscriptions = new HashSet<>();\n-        if (remainingTopic.isEmpty()) {\n-            subscriptions.addAll(cnode.subscriptions);\n-        }\n-        for (INode subInode : cnode.allChildren()) {\n-            subscriptions.addAll(recursiveMatch(remainingTopic, subInode));\n-        }\n-        return subscriptions;\n-    }\n-\n-    public void addToTree(Subscription newSubscription) {\n-        Action res;\n-        do {\n-            res = insert(newSubscription.topicFilter, this.root, newSubscription);\n-        } while (res == Action.REPEAT);\n-    }\n-\n-    private Action insert(Topic topic, final INode inode, Subscription newSubscription) {\n-        Token token = topic.headToken();\n-        if (!topic.isEmpty() && inode.mainNode().anyChildrenMatch(token)) {\n-            Topic remainingTopic = topic.exceptHeadToken();\n-            INode nextInode = inode.mainNode().childOf(token);\n-            return insert(remainingTopic, nextInode, newSubscription);\n-        } else {\n-            if (topic.isEmpty()) {\n-                return insertSubscription(inode, newSubscription);\n-            } else {\n-                return createNodeAndInsertSubscription(topic, inode, newSubscription);\n-            }\n-        }\n-    }\n-\n-    private Action insertSubscription(INode inode, Subscription newSubscription) {\n-        CNode cnode = inode.mainNode();\n-        CNode updatedCnode = cnode.copy().addSubscription(newSubscription);\n-        if (inode.compareAndSet(cnode, updatedCnode)) {\n-            return Action.OK;\n-        } else {\n-            return Action.REPEAT;\n-        }\n-    }\n-\n-    private Action createNodeAndInsertSubscription(Topic topic, INode inode, Subscription newSubscription) {\n-        INode newInode = createPathRec(topic, newSubscription);\n-        CNode cnode = inode.mainNode();\n+  interface IVisitor<T> {\n+\n+    void visit(CNode node, int deep);\n+\n+    T getResult();\n+  }\n+\n+  private static final Token ROOT = new Token(\"root\");\n+  private static final INode NO_PARENT = null;\n+\n+  private enum Action {\n+    OK, REPEAT\n+  }\n+\n+  INode root;\n+\n+  CTrie() {\n+    final CNode mainNode = new CNode();\n+    mainNode.token = ROOT;\n+    this.root = new INode(mainNode);\n+  }\n+\n+  Optional<CNode> lookup(Topic topic) {\n+    INode inode = this.root;\n+    Token token = topic.headToken();\n+    while (!topic.isEmpty() && (inode.mainNode().anyChildrenMatch(token))) {\n+      topic = topic.exceptHeadToken();\n+      inode = inode.mainNode().childOf(token);\n+      token = topic.headToken();\n+    }\n+    if (inode == null || !topic.isEmpty()) {\n+      return Optional.empty();\n+    }\n+    return Optional.of(inode.mainNode());\n+  }\n+\n+  enum NavigationAction {\n+    MATCH, GODEEP, STOP\n+  }\n+\n+  private NavigationAction evaluate(Topic topic, CNode cnode) {\n+    if (Token.MULTI.equals(cnode.token)) {\n+      return NavigationAction.MATCH;\n+    }\n+    if (topic.isEmpty()) {\n+      return NavigationAction.STOP;\n+    }\n+    final Token token = topic.headToken();\n+    if (!(Token.SINGLE.equals(cnode.token) || cnode.token.equals(token) || ROOT.equals(cnode.token))) {\n+      return NavigationAction.STOP;\n+    }\n+    return NavigationAction.GODEEP;\n+  }\n+\n+  public Set<Subscription> recursiveMatch(Topic topic) {\n+    return recursiveMatch(topic, this.root);\n+  }\n+\n+  private Set<Subscription> recursiveMatch(Topic topic, INode inode) {\n+    CNode cnode = inode.mainNode();\n+    NavigationAction action = evaluate(topic, cnode);\n+    if (action == NavigationAction.MATCH) {\n+      return cnode.subscriptions;\n+    }\n+    if (action == NavigationAction.STOP) {\n+      return Collections.emptySet();\n+    }\n+    if (cnode instanceof TNode) {\n+      return Collections.emptySet();\n+    }\n+    Topic remainingTopic = (ROOT.equals(cnode.token)) ? topic : topic.exceptHeadToken();\n+    Set<Subscription> subscriptions = new HashSet<>();\n+    if (remainingTopic.isEmpty()) {\n+      subscriptions.addAll(cnode.subscriptions);\n+    }\n+    for (INode subInode : cnode.allChildren()) {\n+      subscriptions.addAll(recursiveMatch(remainingTopic, subInode));\n+    }\n+    return subscriptions;\n+  }\n+\n+  public void addToTree(Subscription newSubscription) {\n+    Action res;\n+    do {\n+      res = insert(newSubscription.topicFilter, this.root, newSubscription);\n+    } while (res == Action.REPEAT);\n+  }\n+\n+  private Action insert(Topic topic, final INode inode, Subscription newSubscription) {\n+    Token token = topic.headToken();\n+    if (!topic.isEmpty() && inode.mainNode().anyChildrenMatch(token)) {\n+      Topic remainingTopic = topic.exceptHeadToken();\n+      INode nextInode = inode.mainNode().childOf(token);\n+      return insert(remainingTopic, nextInode, newSubscription);\n+    } else {\n+      if (topic.isEmpty()) {\n+        return insertSubscription(inode, newSubscription);\n+      } else {\n+        return createNodeAndInsertSubscription(topic, inode, newSubscription);\n+      }\n+    }\n+  }\n+\n+  private Action insertSubscription(INode inode, Subscription newSubscription) {\n+    CNode cnode = inode.mainNode();\n+    CNode updatedCnode = cnode.copy().addSubscription(newSubscription);\n+    if (inode.compareAndSet(cnode, updatedCnode)) {\n+      return Action.OK;\n+    } else {\n+      return Action.REPEAT;\n+    }\n+  }\n+\n+  private Action createNodeAndInsertSubscription(Topic topic, INode inode, Subscription newSubscription) {\n+    INode newInode = createPathRec(topic, newSubscription);\n+    CNode cnode = inode.mainNode();\n+    CNode updatedCnode = cnode.copy();\n+    updatedCnode.add(newInode);\n+\n+    return inode.compareAndSet(cnode, updatedCnode) ? Action.OK : Action.REPEAT;\n+  }\n+\n+  private INode createPathRec(Topic topic, Subscription newSubscription) {\n+    Topic remainingTopic = topic.exceptHeadToken();\n+    if (!remainingTopic.isEmpty()) {\n+      INode inode = createPathRec(remainingTopic, newSubscription);\n+      CNode cnode = new CNode();\n+      cnode.token = topic.headToken();\n+      cnode.add(inode);\n+      return new INode(cnode);\n+    } else {\n+      return createLeafNodes(topic.headToken(), newSubscription);\n+    }\n+  }\n+\n+  private INode createLeafNodes(Token token, Subscription newSubscription) {\n+    CNode newLeafCnode = new CNode();\n+    newLeafCnode.token = token;\n+    newLeafCnode.addSubscription(newSubscription);\n+\n+    return new INode(newLeafCnode);\n+  }\n+\n+  public void removeFromTree(Topic topic, String clientID) {\n+    Action res;\n+    do {\n+      res = remove(clientID, topic, this.root, NO_PARENT);\n+    } while (res == Action.REPEAT);\n+  }\n+\n+  private Action remove(String clientId, Topic topic, INode inode, INode iParent) {\n+    Token token = topic.headToken();\n+    if (!topic.isEmpty() && (inode.mainNode().anyChildrenMatch(token))) {\n+      Topic remainingTopic = topic.exceptHeadToken();\n+      INode nextInode = inode.mainNode().childOf(token);\n+      return remove(clientId, remainingTopic, nextInode, inode);\n+    } else {\n+      final CNode cnode = inode.mainNode();\n+      if (cnode instanceof TNode) {\n+        // this inode is a tomb, has no clients and should be cleaned up\n+        // Because we implemented cleanTomb below, this should be rare, but possible\n+        // Consider calling cleanTomb here too\n+        return Action.OK;\n+      }\n+      if (cnode.containsOnly(clientId) && topic.isEmpty() && cnode.allChildren().isEmpty()) {\n+        // last client to leave this node, AND there are no downstream children, remove via TNode tomb\n+        if (inode == this.root) {\n+          return inode.compareAndSet(cnode, inode.mainNode().copy()) ? Action.OK : Action.REPEAT;\n+        }\n+        TNode tnode = new TNode();\n+        return inode.compareAndSet(cnode, tnode) ? cleanTomb(inode, iParent) : Action.REPEAT;\n+      } else if (cnode.contains(clientId) && topic.isEmpty()) {\n         CNode updatedCnode = cnode.copy();\n-        updatedCnode.add(newInode);\n-\n+        updatedCnode.removeSubscriptionsFor(clientId);\n         return inode.compareAndSet(cnode, updatedCnode) ? Action.OK : Action.REPEAT;\n-    }\n-\n-    private INode createPathRec(Topic topic, Subscription newSubscription) {\n-        Topic remainingTopic = topic.exceptHeadToken();\n-        if (!remainingTopic.isEmpty()) {\n-            INode inode = createPathRec(remainingTopic, newSubscription);\n-            CNode cnode = new CNode();\n-            cnode.token = topic.headToken();\n-            cnode.add(inode);\n-            return new INode(cnode);\n-        } else {\n-            return createLeafNodes(topic.headToken(), newSubscription);\n-        }\n-    }\n-\n-    private INode createLeafNodes(Token token, Subscription newSubscription) {\n-        CNode newLeafCnode = new CNode();\n-        newLeafCnode.token = token;\n-        newLeafCnode.addSubscription(newSubscription);\n-\n-        return new INode(newLeafCnode);\n-    }\n-\n-    public void removeFromTree(Topic topic, String clientID) {\n-        Action res;\n-        do {\n-            res = remove(clientID, topic, this.root, NO_PARENT);\n-        } while (res == Action.REPEAT);\n-    }\n-\n-    private Action remove(String clientId, Topic topic, INode inode, INode iParent) {\n-        Token token = topic.headToken();\n-        if (!topic.isEmpty() && (inode.mainNode().anyChildrenMatch(token))) {\n-            Topic remainingTopic = topic.exceptHeadToken();\n-            INode nextInode = inode.mainNode().childOf(token);\n-            return remove(clientId, remainingTopic, nextInode, inode);\n-        } else {\n-            final CNode cnode = inode.mainNode();\n-            if (cnode instanceof TNode) {\n-                // this inode is a tomb, has no clients and should be cleaned up\n-                // Because we implemented cleanTomb below, this should be rare, but possible\n-                // Consider calling cleanTomb here too\n-                return Action.OK;\n-            }\n-            if (cnode.containsOnly(clientId) && topic.isEmpty() && cnode.allChildren().isEmpty()) {\n-                // last client to leave this node, AND there are no downstream children, remove via TNode tomb\n-                if (inode == this.root) {\n-                    return inode.compareAndSet(cnode, inode.mainNode().copy()) ? Action.OK : Action.REPEAT;\n-                }\n-                TNode tnode = new TNode();\n-                return inode.compareAndSet(cnode, tnode) ? cleanTomb(inode, iParent) : Action.REPEAT;\n-            } else if (cnode.contains(clientId) && topic.isEmpty()) {\n-                CNode updatedCnode = cnode.copy();\n-                updatedCnode.removeSubscriptionsFor(clientId);\n-                return inode.compareAndSet(cnode, updatedCnode) ? Action.OK : Action.REPEAT;\n-            } else {\n-                //someone else already removed\n-                return Action.OK;\n-            }\n-        }\n-    }\n-\n-    /**\n-     *\n-     * Cleans Disposes of TNode in separate Atomic CAS operation per\n-     * http://bravenewgeek.com/breaking-and-entering-lose-the-lock-while-embracing-concurrency/\n-     *\n-     * We roughly follow this theory above, but we allow CNode with no Subscriptions to linger (for now).\n-     *\n-     *\n-     * @param inode inode that handle to the tomb node.\n-     * @param iParent inode parent.\n-     * @return REPEAT if the this methods wasn't successful or OK.\n-     */\n-    private Action cleanTomb(INode inode, INode iParent) {\n-        CNode updatedCnode = iParent.mainNode().copy();\n-        updatedCnode.remove(inode);\n-        return iParent.compareAndSet(iParent.mainNode(), updatedCnode) ? Action.OK : Action.REPEAT;\n-    }\n-\n-    public int size() {\n-        SubscriptionCounterVisitor visitor = new SubscriptionCounterVisitor();\n-        dfsVisit(this.root, visitor, 0);\n-        return visitor.getResult();\n-    }\n-\n-    public String dumpTree() {\n-        DumpTreeVisitor visitor = new DumpTreeVisitor();\n-        dfsVisit(this.root, visitor, 0);\n-        return visitor.getResult();\n-    }\n-\n-    private void dfsVisit(INode node, IVisitor<?> visitor, int deep) {\n-        if (node == null) {\n-            return;\n-        }\n-\n-        visitor.visit(node.mainNode(), deep);\n-        ++deep;\n-        for (INode child : node.mainNode().allChildren()) {\n-            dfsVisit(child, visitor, deep);\n-        }\n-    }\n+      } else {\n+        //someone else already removed\n+        return Action.OK;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Cleans Disposes of TNode in separate Atomic CAS operation per\n+   * http://bravenewgeek.com/breaking-and-entering-lose-the-lock-while-embracing-concurrency/\n+   * <p>\n+   * We roughly follow this theory above, but we allow CNode with no Subscriptions to linger (for now).\n+   *\n+   * @param inode   inode that handle to the tomb node.\n+   * @param iParent inode parent.\n+   * @return REPEAT if the this methods wasn't successful or OK.\n+   */\n+  private Action cleanTomb(INode inode, INode iParent) {\n+    CNode updatedCnode = iParent.mainNode().copy();\n+    updatedCnode.remove(inode);\n+    return iParent.compareAndSet(iParent.mainNode(), updatedCnode) ? Action.OK : Action.REPEAT;\n+  }\n+\n+  public int size() {\n+    SubscriptionCounterVisitor visitor = new SubscriptionCounterVisitor();\n+    dfsVisit(this.root, visitor, 0);\n+    return visitor.getResult();\n+  }\n+\n+  public String dumpTree() {\n+    DumpTreeVisitor visitor = new DumpTreeVisitor();\n+    dfsVisit(this.root, visitor, 0);\n+    return visitor.getResult();\n+  }\n+\n+  private void dfsVisit(INode node, IVisitor<?> visitor, int deep) {\n+    if (node == null) {\n+      return;\n+    }\n+\n+    visitor.visit(node.mainNode(), deep);\n+    ++deep;\n+    for (INode child : node.mainNode().allChildren()) {\n+      dfsVisit(child, visitor, deep);\n+    }\n+  }\n }\n",
            "diff_size": 277
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "1",
                    "severity": "warning",
                    "message": "missing copyright header",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/errored/1/57/CTrie.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/naturalize/57/CTrie.java\nindex 70e279f0b42..1a9dac1d50f 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/errored/1/57/CTrie.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/naturalize/57/CTrie.java\n@@ -230,4 +230,4 @@ public class CTrie {\n             dfsVisit(child, visitor, deep);\n         }\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 1
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "1",
                    "severity": "warning",
                    "message": "missing copyright header",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                },
                {
                    "line": "12",
                    "severity": "warning",
                    "message": "two or more consecutive empty lines",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpMultilineCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/errored/1/57/CTrie.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/codebuff/57/CTrie.java\nindex 70e279f0b42..6130679f6fb 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/errored/1/57/CTrie.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/codebuff/57/CTrie.java\n@@ -5,18 +5,19 @@ import java.util.HashSet;\n import java.util.Optional;\n import java.util.Set;\n \n+\n public class CTrie {\n \n     interface IVisitor<T> {\n \n         void visit(CNode node, int deep);\n \n+\n         T getResult();\n     }\n \n     private static final Token ROOT = new Token(\"root\");\n     private static final INode NO_PARENT = null;\n-\n     private enum Action {\n         OK, REPEAT\n     }\n@@ -37,6 +38,7 @@ public class CTrie {\n             inode = inode.mainNode().childOf(token);\n             token = topic.headToken();\n         }\n+\n         if (inode == null || !topic.isEmpty()) {\n             return Optional.empty();\n         }\n@@ -51,6 +53,7 @@ public class CTrie {\n         if (Token.MULTI.equals(cnode.token)) {\n             return NavigationAction.MATCH;\n         }\n+\n         if (topic.isEmpty()) {\n             return NavigationAction.STOP;\n         }\n@@ -71,12 +74,15 @@ public class CTrie {\n         if (action == NavigationAction.MATCH) {\n             return cnode.subscriptions;\n         }\n+\n         if (action == NavigationAction.STOP) {\n             return Collections.emptySet();\n         }\n+\n         if (cnode instanceof TNode) {\n             return Collections.emptySet();\n         }\n+\n         Topic remainingTopic = (ROOT.equals(cnode.token)) ? topic : topic.exceptHeadToken();\n         Set<Subscription> subscriptions = new HashSet<>();\n         if (remainingTopic.isEmpty()) {\n@@ -125,7 +131,6 @@ public class CTrie {\n         CNode cnode = inode.mainNode();\n         CNode updatedCnode = cnode.copy();\n         updatedCnode.add(newInode);\n-\n         return inode.compareAndSet(cnode, updatedCnode) ? Action.OK : Action.REPEAT;\n     }\n \n@@ -146,7 +151,6 @@ public class CTrie {\n         CNode newLeafCnode = new CNode();\n         newLeafCnode.token = token;\n         newLeafCnode.addSubscription(newSubscription);\n-\n         return new INode(newLeafCnode);\n     }\n \n@@ -171,20 +175,22 @@ public class CTrie {\n                 // Consider calling cleanTomb here too\n                 return Action.OK;\n             }\n+\n             if (cnode.containsOnly(clientId) && topic.isEmpty() && cnode.allChildren().isEmpty()) {\n                 // last client to leave this node, AND there are no downstream children, remove via TNode tomb\n                 if (inode == this.root) {\n                     return inode.compareAndSet(cnode, inode.mainNode().copy()) ? Action.OK : Action.REPEAT;\n                 }\n+\n                 TNode tnode = new TNode();\n                 return inode.compareAndSet(cnode, tnode) ? cleanTomb(inode, iParent) : Action.REPEAT;\n             } else if (cnode.contains(clientId) && topic.isEmpty()) {\n-                CNode updatedCnode = cnode.copy();\n-                updatedCnode.removeSubscriptionsFor(clientId);\n-                return inode.compareAndSet(cnode, updatedCnode) ? Action.OK : Action.REPEAT;\n+                       CNode updatedCnode = cnode.copy();\n+                       updatedCnode.removeSubscriptionsFor(clientId);\n+                       return inode.compareAndSet(cnode, updatedCnode) ? Action.OK : Action.REPEAT;\n             } else {\n                 //someone else already removed\n-                return Action.OK;\n+                       return Action.OK;\n             }\n         }\n     }\n@@ -201,6 +207,7 @@ public class CTrie {\n      * @param iParent inode parent.\n      * @return REPEAT if the this methods wasn't successful or OK.\n      */\n+\n     private Action cleanTomb(INode inode, INode iParent) {\n         CNode updatedCnode = iParent.mainNode().copy();\n         updatedCnode.remove(inode);\n@@ -223,11 +230,10 @@ public class CTrie {\n         if (node == null) {\n             return;\n         }\n-\n         visitor.visit(node.mainNode(), deep);\n         ++deep;\n         for (INode child : node.mainNode().allChildren()) {\n             dfsVisit(child, visitor, deep);\n         }\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 19
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "1",
                    "severity": "warning",
                    "message": "missing copyright header",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/errored/1/57/CTrie.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/styler_random/57/CTrie.java\nindex 70e279f0b42..49261a669e4 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/errored/1/57/CTrie.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/styler_random/57/CTrie.java\n@@ -1,6 +1,6 @@\n-package io.moquette.broker.subscriptions;\n+package io.moquette.broker.subscriptions\n \n-import java.util.Collections;\n+; import java.util.Collections;\n import java.util.HashSet;\n import java.util.Optional;\n import java.util.Set;\n",
            "diff_size": 2
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "1",
                    "severity": "warning",
                    "message": "missing copyright header",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ],
    "repaired_by": [],
    "not_repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}