{
    "project_name": "DaGeRe-peass",
    "error_id": "31",
    "information": {
        "errors": [
            {
                "line": "177",
                "column": "99",
                "severity": "error",
                "message": "':' is not followed by whitespace.",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
            }
        ]
    },
    "source_code": "   \n   public CompareData getComparableStatistics(final String versionOld, final String version) {\n      List<OneVMResult> before = data.get(versionOld) != null ? data.get(versionOld).getResults() :null;\n      List<OneVMResult> after = data.get(version) != null ? data.get(version).getResults() : null;\n      \n      CompareData cd = CompareData.createCompareDataFromOneVMResults(before, after);",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/errored/1/31/CallTreeNode.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/styler/31/CallTreeNode.java\nindex e72e82b02e8..7559d1504bf 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/errored/1/31/CallTreeNode.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/styler/31/CallTreeNode.java\n@@ -174,7 +174,7 @@ public class CallTreeNode extends BasicNode {\n    }\n    \n    public CompareData getComparableStatistics(final String versionOld, final String version) {\n-      List<OneVMResult> before = data.get(versionOld) != null ? data.get(versionOld).getResults() :null;\n+      List<OneVMResult> before = data.get(versionOld) != null ? data.get(versionOld).getResults() : null;\n       List<OneVMResult> after = data.get(version) != null ? data.get(version).getResults() : null;\n       \n       CompareData cd = CompareData.createCompareDataFromOneVMResults(before, after);\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "105",
                    "column": "82",
                    "severity": "error",
                    "message": "';' is followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.EmptyForIteratorPadCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/errored/1/31/CallTreeNode.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/intellij/31/CallTreeNode.java\nindex e72e82b02e8..11bffbffe84 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/errored/1/31/CallTreeNode.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/intellij/31/CallTreeNode.java\n@@ -25,358 +25,357 @@ import de.precision.analysis.repetitions.bimodal.CompareData;\n \n /**\n  * Saves the call tree structure and measurement data of the call tree\n- * \n+ * <p>\n  * If the measurements are added call by call, the API is: 1) call setVersions with the versions to compare 2) call newVM with the current version 3) call addMeasurement with all\n  * values 4) repeat 2) and 3) until all measurements are read 5) call createStatistics with both versions\n- * \n- * @author reichelt\n  *\n+ * @author reichelt\n  */\n @JsonDeserialize(using = CallTreeNodeDeserializer.class)\n public class CallTreeNode extends BasicNode {\n \n-   private static final Logger LOG = LogManager.getLogger(CallTreeNode.class);\n-\n-   @JsonIgnore\n-   private final CallTreeNode parent;\n-   protected final List<CallTreeNode> children = new ArrayList<>();\n-   protected final Map<String, CallTreeStatistics> data = new HashMap<>();\n-\n-   @JsonIgnore\n-   protected MeasurementConfiguration config;\n-\n-   private CallTreeNode otherVersionNode;\n-\n-   /**\n-    * Creates a root node\n-    */\n-   public CallTreeNode(final String call, final String kiekerPattern, final String otherKiekerPattern, final MeasurementConfiguration config) {\n-      super(call, kiekerPattern, otherKiekerPattern);\n-      this.parent = null;\n-      this.config = config;\n-   }\n-\n-   protected CallTreeNode(final String call, final String kiekerPattern, final String otherKiekerPattern, final CallTreeNode parent) {\n-      super(call, kiekerPattern, otherKiekerPattern);\n-      this.parent = parent;\n-      this.config = parent.config;\n-   }\n-\n-   public void setConfig(final MeasurementConfiguration config) {\n-      this.config = config;\n-   }\n-   \n-   @Override\n-   public List<CallTreeNode> getChildren() {\n-      return children;\n-   }\n-\n-   public CallTreeNode appendChild(final String call, final String kiekerPattern, final String otherKiekerPattern) {\n-      final CallTreeNode added = new CallTreeNode(call, kiekerPattern, otherKiekerPattern, this);\n-      children.add(added);\n-      return added;\n-   }\n-\n-   public CallTreeNode getParent() {\n-      return parent;\n-   }\n-\n-   public void addMeasurement(final String version, final Long duration) {\n-      checkDataAddPossible(version);\n-      LOG.debug(\"Adding measurement: {}\", version);\n-      data.get(version).addMeasurement(duration);\n-   }\n-\n-   /**\n-    * Adds the measurement of *one full VM* to the measurements of the version\n-    * \n-    * @param version\n-    * @param statistic\n-    */\n-   public void addAggregatedMeasurement(final String version, final List<StatisticalSummary> statistic) {\n-      checkDataAddPossible(version);\n-      removeWarmup(statistic);\n-      data.get(version).addAggregatedMeasurement(statistic);\n-   }\n-\n-   private void removeWarmup(final List<StatisticalSummary> statistic) {\n-      if (config.getNodeWarmup() > 0) {\n-         int remainingWarmup = config.getNodeWarmup();\n-         StatisticalSummary borderSummary = null;\n-         for (Iterator<StatisticalSummary> it = statistic.iterator(); it.hasNext();) {\n-            StatisticalSummary chunk = it.next();\n-            if (remainingWarmup - chunk.getN() > 0) {\n-               remainingWarmup -= chunk.getN();\n-               LOG.debug(\"Reducing warmup by {}, remaining warmup {}\", chunk.getN(), remainingWarmup);\n-               it.remove();\n-            } else {\n-               if (remainingWarmup > 0) {\n-                  final long reducedN = chunk.getN() - remainingWarmup;\n-                  borderSummary = new StatisticalSummaryValues(chunk.getMean(), chunk.getVariance(), reducedN,\n-                        chunk.getMax(), chunk.getMin(), chunk.getMean() * reducedN);\n-               } else {\n-                  // Since there is no warmup remaining, the first summary is just removed and added later on\n-                  borderSummary = chunk;\n-               }\n-               it.remove();\n-               break;\n-            }\n-         }\n-         if (borderSummary != null) {\n-            statistic.add(0, borderSummary);\n-         } else {\n-            LOG.warn(\"Warning! Reading aggregated data which contain less executions than the warmup \" + config.getNodeWarmup());\n-         }\n-         for (StatisticalSummary summary : statistic) {\n-            LOG.trace(\"After removing: {} {} Sum: {}\", summary.getMean(), summary.getN(), summary.getSum());\n-         }\n-         LOG.trace(\"Overall mean: {}\", StatisticUtil.getMean(statistic));\n-      }\n-   }\n-\n-   private void checkDataAddPossible(final String version) {\n-      if (PeassGlobalInfos.isTwoVersionRun) {\n-         if (otherVersionNode == null) {\n-            throw new RuntimeException(\"Other version node needs to be defined before measurement! Node: \" + call);\n-         }\n-         if (otherVersionNode.getCall().equals(CauseSearchData.ADDED) && version.equals(config.getVersion())) {\n-            throw new RuntimeException(\"Added methods may not contain data\");\n-         }\n-      }\n-      if (call.equals(CauseSearchData.ADDED) && version.equals(config.getVersionOld())) {\n-         throw new RuntimeException(\"Added methods may not contain data, trying to add data for \" + version);\n-      }\n-\n-   }\n-\n-   public boolean hasMeasurement(final String version) {\n-      return data.get(version).getResults().size() > 0;\n-   }\n-\n-   public List<OneVMResult> getResults(final String version) {\n-      final CallTreeStatistics statistics = data.get(version);\n-      return statistics != null ? statistics.getResults() : null;\n-   }\n-\n-   public void newVM(final String version) {\n-      final CallTreeStatistics statistics = data.get(version);\n-      LOG.debug(\"Adding VM: {} {} VMs: {}\", call, version, statistics.getResults().size());\n-      statistics.newResult();\n-   }\n-\n-   private void newVersion(final String version) {\n-      LOG.trace(\"Adding version: {}\", version);\n-      CallTreeStatistics statistics = data.get(version);\n-      if (statistics == null) {\n-         statistics = new CallTreeStatistics(config.getNodeWarmup());\n-         data.put(version, statistics);\n+  private static final Logger LOG = LogManager.getLogger(CallTreeNode.class);\n+\n+  @JsonIgnore\n+  private final CallTreeNode parent;\n+  protected final List<CallTreeNode> children = new ArrayList<>();\n+  protected final Map<String, CallTreeStatistics> data = new HashMap<>();\n+\n+  @JsonIgnore\n+  protected MeasurementConfiguration config;\n+\n+  private CallTreeNode otherVersionNode;\n+\n+  /**\n+   * Creates a root node\n+   */\n+  public CallTreeNode(final String call, final String kiekerPattern, final String otherKiekerPattern, final MeasurementConfiguration config) {\n+    super(call, kiekerPattern, otherKiekerPattern);\n+    this.parent = null;\n+    this.config = config;\n+  }\n+\n+  protected CallTreeNode(final String call, final String kiekerPattern, final String otherKiekerPattern, final CallTreeNode parent) {\n+    super(call, kiekerPattern, otherKiekerPattern);\n+    this.parent = parent;\n+    this.config = parent.config;\n+  }\n+\n+  public void setConfig(final MeasurementConfiguration config) {\n+    this.config = config;\n+  }\n+\n+  @Override\n+  public List<CallTreeNode> getChildren() {\n+    return children;\n+  }\n+\n+  public CallTreeNode appendChild(final String call, final String kiekerPattern, final String otherKiekerPattern) {\n+    final CallTreeNode added = new CallTreeNode(call, kiekerPattern, otherKiekerPattern, this);\n+    children.add(added);\n+    return added;\n+  }\n+\n+  public CallTreeNode getParent() {\n+    return parent;\n+  }\n+\n+  public void addMeasurement(final String version, final Long duration) {\n+    checkDataAddPossible(version);\n+    LOG.debug(\"Adding measurement: {}\", version);\n+    data.get(version).addMeasurement(duration);\n+  }\n+\n+  /**\n+   * Adds the measurement of *one full VM* to the measurements of the version\n+   *\n+   * @param version\n+   * @param statistic\n+   */\n+  public void addAggregatedMeasurement(final String version, final List<StatisticalSummary> statistic) {\n+    checkDataAddPossible(version);\n+    removeWarmup(statistic);\n+    data.get(version).addAggregatedMeasurement(statistic);\n+  }\n+\n+  private void removeWarmup(final List<StatisticalSummary> statistic) {\n+    if (config.getNodeWarmup() > 0) {\n+      int remainingWarmup = config.getNodeWarmup();\n+      StatisticalSummary borderSummary = null;\n+      for (Iterator<StatisticalSummary> it = statistic.iterator(); it.hasNext(); ) {\n+        StatisticalSummary chunk = it.next();\n+        if (remainingWarmup - chunk.getN() > 0) {\n+          remainingWarmup -= chunk.getN();\n+          LOG.debug(\"Reducing warmup by {}, remaining warmup {}\", chunk.getN(), remainingWarmup);\n+          it.remove();\n+        } else {\n+          if (remainingWarmup > 0) {\n+            final long reducedN = chunk.getN() - remainingWarmup;\n+            borderSummary = new StatisticalSummaryValues(chunk.getMean(), chunk.getVariance(), reducedN,\n+                chunk.getMax(), chunk.getMin(), chunk.getMean() * reducedN);\n+          } else {\n+            // Since there is no warmup remaining, the first summary is just removed and added later on\n+            borderSummary = chunk;\n+          }\n+          it.remove();\n+          break;\n+        }\n       }\n-   }\n-   \n-   public CompareData getComparableStatistics(final String versionOld, final String version) {\n-      List<OneVMResult> before = data.get(versionOld) != null ? data.get(versionOld).getResults() :null;\n-      List<OneVMResult> after = data.get(version) != null ? data.get(version).getResults() : null;\n-      \n-      CompareData cd = CompareData.createCompareDataFromOneVMResults(before, after);\n-      return cd;\n-   }\n-\n-   public SummaryStatistics getStatistics(final String version) {\n-      LOG.trace(\"Getting data: {}\", version);\n-      final CallTreeStatistics statistics = data.get(version);\n-      return statistics != null ? statistics.getStatistics() : null;\n-   }\n-\n-   public void createStatistics(final String version) {\n-      LOG.debug(\"Creating statistics: {} Call: {}\", version, call);\n-      final CallTreeStatistics callTreeStatistics = data.get(version);\n-      callTreeStatistics.createStatistics();\n-   }\n-\n-   @Override\n-   public String toString() {\n-      return kiekerPattern.toString();\n-   }\n-\n-   public ChangedEntity toEntity() {\n-      if (call.equals(CauseSearchData.ADDED)) {\n-         return otherVersionNode.toEntity();\n+      if (borderSummary != null) {\n+        statistic.add(0, borderSummary);\n       } else {\n-         final int index = call.lastIndexOf(ChangedEntity.METHOD_SEPARATOR);\n-         final ChangedEntity entity = new ChangedEntity(call.substring(0, index), \"\", call.substring(index + 1));\n-         return entity;\n+        LOG.warn(\"Warning! Reading aggregated data which contain less executions than the warmup \" + config.getNodeWarmup());\n       }\n-   }\n-\n-   @JsonIgnore\n-   public TestcaseStatistic getTestcaseStatistic() {\n-      final CallTreeStatistics currentVersionStatistics = data.get(config.getVersion());\n-      final SummaryStatistics current = currentVersionStatistics.getStatistics();\n-      final CallTreeStatistics previousVersionStatistics = data.get(config.getVersionOld());\n-      final SummaryStatistics previous = previousVersionStatistics.getStatistics();\n-      try {\n-         final TestcaseStatistic testcaseStatistic = new TestcaseStatistic(previous, current,\n-               previousVersionStatistics.getCalls(), currentVersionStatistics.getCalls());\n-         return testcaseStatistic;\n-      } catch (NumberIsTooSmallException t) {\n-         LOG.debug(\"Data: \" + current.getN() + \" \" + previous.getN());\n-         final String otherCall = otherVersionNode != null ? otherVersionNode.getCall() : \"Not Existing\";\n-         throw new RuntimeException(\"Could not read \" + call + \" Other Version: \" + otherCall, t);\n+      for (StatisticalSummary summary : statistic) {\n+        LOG.trace(\"After removing: {} {} Sum: {}\", summary.getMean(), summary.getN(), summary.getSum());\n       }\n-   }\n-\n-   @JsonIgnore\n-   public TestcaseStatistic getPartialTestcaseStatistic() {\n-      final CallTreeStatistics currentVersionStatistics = data.get(config.getVersion());\n-      final SummaryStatistics current = currentVersionStatistics.getStatistics();\n-      final CallTreeStatistics previousVersionStatistics = data.get(config.getVersionOld());\n-      final SummaryStatistics previous = previousVersionStatistics.getStatistics();\n-\n-      if (firstHasValues(current, previous)) {\n-         final TestcaseStatistic testcaseStatistic = new TestcaseStatistic(previous, current, 0, currentVersionStatistics.getCalls());\n-         testcaseStatistic.setChange(true);\n-         return testcaseStatistic;\n-      } else if (firstHasValues(previous, current)) {\n-         final TestcaseStatistic testcaseStatistic = new TestcaseStatistic(previous, current, previousVersionStatistics.getCalls(), 0);\n-         testcaseStatistic.setChange(true);\n-         return testcaseStatistic;\n-      } else if ((current == null || current.getN() == 0) && (previous == null || previous.getN() == 0)) {\n-         LOG.error(\"Could not measure {}\", this);\n-         final TestcaseStatistic testcaseStatistic = new TestcaseStatistic(previous, current, 0, 0);\n-         testcaseStatistic.setChange(true);\n-         return testcaseStatistic;\n-      } else {\n-         throw new RuntimeException(\"Partial statistics should exactly be created if one node is unmeasurable\");\n+      LOG.trace(\"Overall mean: {}\", StatisticUtil.getMean(statistic));\n+    }\n+  }\n+\n+  private void checkDataAddPossible(final String version) {\n+    if (PeassGlobalInfos.isTwoVersionRun) {\n+      if (otherVersionNode == null) {\n+        throw new RuntimeException(\"Other version node needs to be defined before measurement! Node: \" + call);\n       }\n-   }\n-\n-   private boolean firstHasValues(final SummaryStatistics first, final SummaryStatistics second) {\n-      return (second == null || second.getN() == 0) && (first != null && first.getN() > 0);\n-   }\n-\n-   /**\n-    * @deprecated use initVersions instead, and asure that the MeasurementConfig already has the correct versions\n-    */\n-   @Deprecated\n-   @JsonIgnore\n-   public void setVersions(final String version, final String predecessor) {\n-      config.setVersion(version);\n-      config.setVersionOld(predecessor);\n-      resetStatistics();\n-      newVersion(version);\n-      newVersion(predecessor);\n-   }\n-   \n-   public void initVersions() {\n-      resetStatistics();\n-      newVersion(config.getVersionOld());\n-      newVersion(config.getVersion());\n-   }\n-\n-   @JsonIgnore\n-   public int getTreeSize() {\n-      int size = 1;\n-      for (final CallTreeNode child : children) {\n-         size += child.getTreeSize();\n+      if (otherVersionNode.getCall().equals(CauseSearchData.ADDED) && version.equals(config.getVersion())) {\n+        throw new RuntimeException(\"Added methods may not contain data\");\n       }\n-      return size;\n-   }\n-\n-   protected void resetStatistics() {\n-      data.values().forEach(statistics -> statistics.resetResults());\n-   }\n-\n-   @JsonIgnore\n-   public CallTreeNode getOtherVersionNode() {\n-      return otherVersionNode;\n-   }\n-\n-   public void setOtherVersionNode(final CallTreeNode otherVersionNode) {\n-      this.otherVersionNode = otherVersionNode;\n-   }\n-\n-   @JsonIgnore\n-   public String getMethod() {\n-      final String method = call.substring(call.lastIndexOf('#'));\n-      return method;\n-   }\n-\n-   @JsonIgnore\n-   public String getParameters() {\n-      final String parameters = kiekerPattern.substring(kiekerPattern.indexOf('('));\n-      return parameters;\n-   }\n-\n-   @JsonIgnore\n-   public int getEss() {\n-      return parent != null ? parent.getEss() + 1 : 0;\n-   }\n-\n-   @JsonIgnore\n-   public int getEoi() {\n-      int eoi;\n-      if (parent != null) {\n-         int predecessorIndex = parent.getChildren().indexOf(this) - 1;\n-         if (predecessorIndex >= 0) {\n-            CallTreeNode predecessor = parent.getChildren().get(predecessorIndex);\n-            eoi = predecessor.getEoi() + predecessor.getAllChildCount() + 1;\n-         } else {\n-            eoi = parent.getEoi() + 1;\n-         }\n+    }\n+    if (call.equals(CauseSearchData.ADDED) && version.equals(config.getVersionOld())) {\n+      throw new RuntimeException(\"Added methods may not contain data, trying to add data for \" + version);\n+    }\n+\n+  }\n+\n+  public boolean hasMeasurement(final String version) {\n+    return data.get(version).getResults().size() > 0;\n+  }\n+\n+  public List<OneVMResult> getResults(final String version) {\n+    final CallTreeStatistics statistics = data.get(version);\n+    return statistics != null ? statistics.getResults() : null;\n+  }\n+\n+  public void newVM(final String version) {\n+    final CallTreeStatistics statistics = data.get(version);\n+    LOG.debug(\"Adding VM: {} {} VMs: {}\", call, version, statistics.getResults().size());\n+    statistics.newResult();\n+  }\n+\n+  private void newVersion(final String version) {\n+    LOG.trace(\"Adding version: {}\", version);\n+    CallTreeStatistics statistics = data.get(version);\n+    if (statistics == null) {\n+      statistics = new CallTreeStatistics(config.getNodeWarmup());\n+      data.put(version, statistics);\n+    }\n+  }\n+\n+  public CompareData getComparableStatistics(final String versionOld, final String version) {\n+    List<OneVMResult> before = data.get(versionOld) != null ? data.get(versionOld).getResults() : null;\n+    List<OneVMResult> after = data.get(version) != null ? data.get(version).getResults() : null;\n+\n+    CompareData cd = CompareData.createCompareDataFromOneVMResults(before, after);\n+    return cd;\n+  }\n+\n+  public SummaryStatistics getStatistics(final String version) {\n+    LOG.trace(\"Getting data: {}\", version);\n+    final CallTreeStatistics statistics = data.get(version);\n+    return statistics != null ? statistics.getStatistics() : null;\n+  }\n+\n+  public void createStatistics(final String version) {\n+    LOG.debug(\"Creating statistics: {} Call: {}\", version, call);\n+    final CallTreeStatistics callTreeStatistics = data.get(version);\n+    callTreeStatistics.createStatistics();\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return kiekerPattern.toString();\n+  }\n+\n+  public ChangedEntity toEntity() {\n+    if (call.equals(CauseSearchData.ADDED)) {\n+      return otherVersionNode.toEntity();\n+    } else {\n+      final int index = call.lastIndexOf(ChangedEntity.METHOD_SEPARATOR);\n+      final ChangedEntity entity = new ChangedEntity(call.substring(0, index), \"\", call.substring(index + 1));\n+      return entity;\n+    }\n+  }\n+\n+  @JsonIgnore\n+  public TestcaseStatistic getTestcaseStatistic() {\n+    final CallTreeStatistics currentVersionStatistics = data.get(config.getVersion());\n+    final SummaryStatistics current = currentVersionStatistics.getStatistics();\n+    final CallTreeStatistics previousVersionStatistics = data.get(config.getVersionOld());\n+    final SummaryStatistics previous = previousVersionStatistics.getStatistics();\n+    try {\n+      final TestcaseStatistic testcaseStatistic = new TestcaseStatistic(previous, current,\n+          previousVersionStatistics.getCalls(), currentVersionStatistics.getCalls());\n+      return testcaseStatistic;\n+    } catch (NumberIsTooSmallException t) {\n+      LOG.debug(\"Data: \" + current.getN() + \" \" + previous.getN());\n+      final String otherCall = otherVersionNode != null ? otherVersionNode.getCall() : \"Not Existing\";\n+      throw new RuntimeException(\"Could not read \" + call + \" Other Version: \" + otherCall, t);\n+    }\n+  }\n+\n+  @JsonIgnore\n+  public TestcaseStatistic getPartialTestcaseStatistic() {\n+    final CallTreeStatistics currentVersionStatistics = data.get(config.getVersion());\n+    final SummaryStatistics current = currentVersionStatistics.getStatistics();\n+    final CallTreeStatistics previousVersionStatistics = data.get(config.getVersionOld());\n+    final SummaryStatistics previous = previousVersionStatistics.getStatistics();\n+\n+    if (firstHasValues(current, previous)) {\n+      final TestcaseStatistic testcaseStatistic = new TestcaseStatistic(previous, current, 0, currentVersionStatistics.getCalls());\n+      testcaseStatistic.setChange(true);\n+      return testcaseStatistic;\n+    } else if (firstHasValues(previous, current)) {\n+      final TestcaseStatistic testcaseStatistic = new TestcaseStatistic(previous, current, previousVersionStatistics.getCalls(), 0);\n+      testcaseStatistic.setChange(true);\n+      return testcaseStatistic;\n+    } else if ((current == null || current.getN() == 0) && (previous == null || previous.getN() == 0)) {\n+      LOG.error(\"Could not measure {}\", this);\n+      final TestcaseStatistic testcaseStatistic = new TestcaseStatistic(previous, current, 0, 0);\n+      testcaseStatistic.setChange(true);\n+      return testcaseStatistic;\n+    } else {\n+      throw new RuntimeException(\"Partial statistics should exactly be created if one node is unmeasurable\");\n+    }\n+  }\n+\n+  private boolean firstHasValues(final SummaryStatistics first, final SummaryStatistics second) {\n+    return (second == null || second.getN() == 0) && (first != null && first.getN() > 0);\n+  }\n+\n+  /**\n+   * @deprecated use initVersions instead, and asure that the MeasurementConfig already has the correct versions\n+   */\n+  @Deprecated\n+  @JsonIgnore\n+  public void setVersions(final String version, final String predecessor) {\n+    config.setVersion(version);\n+    config.setVersionOld(predecessor);\n+    resetStatistics();\n+    newVersion(version);\n+    newVersion(predecessor);\n+  }\n+\n+  public void initVersions() {\n+    resetStatistics();\n+    newVersion(config.getVersionOld());\n+    newVersion(config.getVersion());\n+  }\n+\n+  @JsonIgnore\n+  public int getTreeSize() {\n+    int size = 1;\n+    for (final CallTreeNode child : children) {\n+      size += child.getTreeSize();\n+    }\n+    return size;\n+  }\n+\n+  protected void resetStatistics() {\n+    data.values().forEach(statistics -> statistics.resetResults());\n+  }\n+\n+  @JsonIgnore\n+  public CallTreeNode getOtherVersionNode() {\n+    return otherVersionNode;\n+  }\n+\n+  public void setOtherVersionNode(final CallTreeNode otherVersionNode) {\n+    this.otherVersionNode = otherVersionNode;\n+  }\n+\n+  @JsonIgnore\n+  public String getMethod() {\n+    final String method = call.substring(call.lastIndexOf('#'));\n+    return method;\n+  }\n+\n+  @JsonIgnore\n+  public String getParameters() {\n+    final String parameters = kiekerPattern.substring(kiekerPattern.indexOf('('));\n+    return parameters;\n+  }\n+\n+  @JsonIgnore\n+  public int getEss() {\n+    return parent != null ? parent.getEss() + 1 : 0;\n+  }\n+\n+  @JsonIgnore\n+  public int getEoi() {\n+    int eoi;\n+    if (parent != null) {\n+      int predecessorIndex = parent.getChildren().indexOf(this) - 1;\n+      if (predecessorIndex >= 0) {\n+        CallTreeNode predecessor = parent.getChildren().get(predecessorIndex);\n+        eoi = predecessor.getEoi() + predecessor.getAllChildCount() + 1;\n       } else {\n-         eoi = 0;\n+        eoi = parent.getEoi() + 1;\n       }\n-      return eoi;\n-   }\n-\n-   private int getAllChildCount() {\n-      int childs = 0;\n-      for (CallTreeNode child : children) {\n-         childs += child.getAllChildCount() + 1;\n+    } else {\n+      eoi = 0;\n+    }\n+    return eoi;\n+  }\n+\n+  private int getAllChildCount() {\n+    int childs = 0;\n+    for (CallTreeNode child : children) {\n+      childs += child.getAllChildCount() + 1;\n+    }\n+    return childs;\n+  }\n+\n+  @JsonIgnore\n+  public int getPosition() {\n+    if (parent != null) {\n+      for (int childIndex = 0; childIndex < parent.getChildren().size(); childIndex++) {\n+        if (parent.getChildren().get(childIndex) == this) {\n+          return childIndex;\n+        }\n       }\n-      return childs;\n-   }\n-\n-   @JsonIgnore\n-   public int getPosition() {\n-      if (parent != null) {\n-         for (int childIndex = 0; childIndex < parent.getChildren().size(); childIndex++) {\n-            if (parent.getChildren().get(childIndex) == this) {\n-               return childIndex;\n-            }\n-         }\n-         return -1;\n-      } else {\n-         return 0;\n-      }\n-   }\n-\n-   public long getCallCount(final String version) {\n-      return data.get(version).getResults().stream().mapToLong(result -> result.getCalls()).sum();\n-   }\n-\n-   @Override\n-   public int hashCode() {\n-      return kiekerPattern.hashCode();\n-   }\n-\n-   @Override\n-   public boolean equals(final Object obj) {\n-      if (obj instanceof CallTreeNode) {\n-         final CallTreeNode other = (CallTreeNode) obj;\n-         boolean equal = other.getKiekerPattern().equals(kiekerPattern);\n-         if (equal) {\n-            if ((this.parent == null) != (other.parent == null)) {\n-               equal = false;\n-            } else if (parent != null) {\n-               equal &= this.parent.equals(other.parent);\n-               equal &= (this.getPosition() == other.getPosition());\n-            }\n-         }\n-         return equal;\n-      } else {\n-         return false;\n+      return -1;\n+    } else {\n+      return 0;\n+    }\n+  }\n+\n+  public long getCallCount(final String version) {\n+    return data.get(version).getResults().stream().mapToLong(result -> result.getCalls()).sum();\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return kiekerPattern.hashCode();\n+  }\n+\n+  @Override\n+  public boolean equals(final Object obj) {\n+    if (obj instanceof CallTreeNode) {\n+      final CallTreeNode other = (CallTreeNode) obj;\n+      boolean equal = other.getKiekerPattern().equals(kiekerPattern);\n+      if (equal) {\n+        if ((this.parent == null) != (other.parent == null)) {\n+          equal = false;\n+        } else if (parent != null) {\n+          equal &= this.parent.equals(other.parent);\n+          equal &= (this.getPosition() == other.getPosition());\n+        }\n       }\n-   }\n+      return equal;\n+    } else {\n+      return false;\n+    }\n+  }\n \n }\n\\ No newline at end of file\n",
            "diff_size": 489
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "34",
                    "column": "57",
                    "severity": "error",
                    "message": "')' is preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/errored/1/31/CallTreeNode.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/codebuff/31/CallTreeNode.java\nindex e72e82b02e8..8415545a11d 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/errored/1/31/CallTreeNode.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/codebuff/31/CallTreeNode.java\n@@ -5,17 +5,14 @@ import java.util.HashMap;\n import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n-\n import org.apache.commons.math3.exception.NumberIsTooSmallException;\n import org.apache.commons.math3.stat.descriptive.StatisticalSummary;\n import org.apache.commons.math3.stat.descriptive.StatisticalSummaryValues;\n import org.apache.commons.math3.stat.descriptive.SummaryStatistics;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n-\n import com.fasterxml.jackson.annotation.JsonIgnore;\n import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n-\n import de.peass.PeassGlobalInfos;\n import de.peass.config.MeasurementConfiguration;\n import de.peass.dependency.analysis.data.ChangedEntity;\n@@ -32,60 +29,59 @@ import de.precision.analysis.repetitions.bimodal.CompareData;\n  * @author reichelt\n  *\n  */\n-@JsonDeserialize(using = CallTreeNodeDeserializer.class)\n-public class CallTreeNode extends BasicNode {\n \n-   private static final Logger LOG = LogManager.getLogger(CallTreeNode.class);\n \n-   @JsonIgnore\n-   private final CallTreeNode parent;\n-   protected final List<CallTreeNode> children = new ArrayList<>();\n-   protected final Map<String, CallTreeStatistics> data = new HashMap<>();\n+@JsonDeserialize(using = CallTreeNodeDeserializer.class ) public class CallTreeNode extends BasicNode {\n+ private static final Logger LOG = LogManager.getLogger(CallTreeNode.class);\n \n-   @JsonIgnore\n-   protected MeasurementConfiguration config;\n+ @JsonIgnore private final CallTreeNode parent;\n+ protected final List<CallTreeNode> children = new ArrayList<>();\n+ protected final Map<String, CallTreeStatistics> data = new HashMap<>();\n \n-   private CallTreeNode otherVersionNode;\n+ @JsonIgnore protected MeasurementConfiguration config;\n+ private CallTreeNode otherVersionNode;\n \n    /**\n     * Creates a root node\n     */\n-   public CallTreeNode(final String call, final String kiekerPattern, final String otherKiekerPattern, final MeasurementConfiguration config) {\n-      super(call, kiekerPattern, otherKiekerPattern);\n-      this.parent = null;\n-      this.config = config;\n-   }\n \n-   protected CallTreeNode(final String call, final String kiekerPattern, final String otherKiekerPattern, final CallTreeNode parent) {\n-      super(call, kiekerPattern, otherKiekerPattern);\n-      this.parent = parent;\n-      this.config = parent.config;\n-   }\n+ public CallTreeNode(final String call, final String kiekerPattern, final String otherKiekerPattern, final MeasurementConfiguration config) {\n+  super(call, kiekerPattern, otherKiekerPattern);\n+  this.parent = null;\n+  this.config = config;\n+ }\n \n-   public void setConfig(final MeasurementConfiguration config) {\n-      this.config = config;\n-   }\n-   \n-   @Override\n-   public List<CallTreeNode> getChildren() {\n-      return children;\n-   }\n+ protected CallTreeNode(final String call, final String kiekerPattern, final String otherKiekerPattern, final CallTreeNode parent) {\n+  super(call, kiekerPattern, otherKiekerPattern);\n+  this.parent = parent;\n+  this.config = parent.config;\n+ }\n \n-   public CallTreeNode appendChild(final String call, final String kiekerPattern, final String otherKiekerPattern) {\n-      final CallTreeNode added = new CallTreeNode(call, kiekerPattern, otherKiekerPattern, this);\n-      children.add(added);\n-      return added;\n-   }\n \n-   public CallTreeNode getParent() {\n-      return parent;\n-   }\n+ public void setConfig(final MeasurementConfiguration config) {\n+  this.config = config;\n+ }\n \n-   public void addMeasurement(final String version, final Long duration) {\n-      checkDataAddPossible(version);\n-      LOG.debug(\"Adding measurement: {}\", version);\n-      data.get(version).addMeasurement(duration);\n-   }\n+ @Override\n+ public List<CallTreeNode> getChildren() {\n+  return children;\n+ }\n+\n+ public CallTreeNode appendChild(final String call, final String kiekerPattern, final String otherKiekerPattern) {\n+  final CallTreeNode added = new CallTreeNode(call, kiekerPattern, otherKiekerPattern, this);\n+  children.add(added);\n+  return added;\n+ }\n+\n+ public CallTreeNode getParent() {\n+  return parent;\n+ }\n+\n+ public void addMeasurement(final String version, final Long duration) {\n+  checkDataAddPossible(version);\n+  LOG.debug(\"Adding measurement: {}\", version);\n+  data.get(version).addMeasurement(duration);\n+ }\n \n    /**\n     * Adds the measurement of *one full VM* to the measurements of the version\n@@ -93,290 +89,292 @@ public class CallTreeNode extends BasicNode {\n     * @param version\n     * @param statistic\n     */\n-   public void addAggregatedMeasurement(final String version, final List<StatisticalSummary> statistic) {\n-      checkDataAddPossible(version);\n-      removeWarmup(statistic);\n-      data.get(version).addAggregatedMeasurement(statistic);\n-   }\n \n-   private void removeWarmup(final List<StatisticalSummary> statistic) {\n-      if (config.getNodeWarmup() > 0) {\n-         int remainingWarmup = config.getNodeWarmup();\n-         StatisticalSummary borderSummary = null;\n-         for (Iterator<StatisticalSummary> it = statistic.iterator(); it.hasNext();) {\n-            StatisticalSummary chunk = it.next();\n-            if (remainingWarmup - chunk.getN() > 0) {\n-               remainingWarmup -= chunk.getN();\n-               LOG.debug(\"Reducing warmup by {}, remaining warmup {}\", chunk.getN(), remainingWarmup);\n-               it.remove();\n-            } else {\n-               if (remainingWarmup > 0) {\n-                  final long reducedN = chunk.getN() - remainingWarmup;\n-                  borderSummary = new StatisticalSummaryValues(chunk.getMean(), chunk.getVariance(), reducedN,\n-                        chunk.getMax(), chunk.getMin(), chunk.getMean() * reducedN);\n-               } else {\n+ public void addAggregatedMeasurement(final String version, final List<StatisticalSummary> statistic) {\n+  checkDataAddPossible(version);\n+  removeWarmup(statistic);\n+  data.get(version).addAggregatedMeasurement(statistic);\n+ }\n+\n+ private void removeWarmup(final List<StatisticalSummary> statistic) {\n+  if (config.getNodeWarmup() > 0) {\n+   int remainingWarmup = config.getNodeWarmup();\n+   StatisticalSummary borderSummary = null;\n+   for (Iterator<StatisticalSummary> it = statistic.iterator(); it.hasNext();) {\n+    StatisticalSummary chunk = it.next();\n+    if (remainingWarmup - chunk.getN() > 0) {\n+     remainingWarmup -= chunk.getN();\n+     LOG.debug(\"Reducing warmup by {}, remaining warmup {}\", chunk.getN(), remainingWarmup);\n+     it.remove();\n+    } else {\n+     if (remainingWarmup > 0) {\n+      final long reducedN = chunk.getN() - remainingWarmup;\n+      borderSummary = new StatisticalSummaryValues(chunk.getMean(), chunk.getVariance(), reducedN, chunk.getMax(), chunk.getMin(), chunk.getMean() * reducedN);\n+     } else {\n                   // Since there is no warmup remaining, the first summary is just removed and added later on\n-                  borderSummary = chunk;\n-               }\n-               it.remove();\n-               break;\n-            }\n-         }\n-         if (borderSummary != null) {\n-            statistic.add(0, borderSummary);\n+      borderSummary = chunk;\n+     }\n+     it.remove();\n+     break;\n+    }\n+   }\n+   if (borderSummary != null) {\n+    statistic.add(0, borderSummary);\n+   } else {\n+    LOG.warn(\"Warning! Reading aggregated data which contain less executions than the warmup \" + config.getNodeWarmup());\n+   }\n+\n+   for (StatisticalSummary summary : statistic) {\n+    LOG.trace(\"After removing: {} {} Sum: {}\", summary.getMean(), summary.getN(), summary.getSum());\n+   }\n+   LOG.trace(\"Overall mean: {}\", StatisticUtil.getMean(statistic));\n+  }\n+ }\n+\n+ private void checkDataAddPossible(final String version) {\n+  if (PeassGlobalInfos.isTwoVersionRun) {\n+   if (otherVersionNode == null) {\n+    throw new RuntimeException(\"Other version node needs to be defined before measurement! Node: \" + call);\n+   }\n+   if (otherVersionNode.getCall().equals(CauseSearchData.ADDED) && version.equals(config.getVersion())) {\n+    throw new RuntimeException(\"Added methods may not contain data\");\n+   }\n+  }\n+  if (call.equals(CauseSearchData.ADDED) && version.equals(config.getVersionOld())) {\n+   throw new RuntimeException(\"Added methods may not contain data, trying to add data for \" + version);\n+  }\n+ }\n+\n+ public boolean hasMeasurement(final String version) {\n+  return data.get(version).getResults().size() > 0;\n+ }\n+\n+ public List<OneVMResult> getResults(final String version) {\n+  final CallTreeStatistics statistics = data.get(version);\n+  return statistics != null ? statistics.getResults() : null;\n+ }\n+\n+ public void newVM(final String version) {\n+  final CallTreeStatistics statistics = data.get(version);\n+  LOG.debug(\"Adding VM: {} {} VMs: {}\", call, version, statistics.getResults().size());\n+  statistics.newResult();\n+ }\n+\n+ private void newVersion(final String version) {\n+  LOG.trace(\"Adding version: {}\", version);\n+\n+  CallTreeStatistics statistics = data.get(version);\n+  if (statistics == null) {\n+   statistics = new CallTreeStatistics(config.getNodeWarmup());\n+   data.put(version, statistics);\n+  }\n+ }\n+\n+ public CompareData getComparableStatistics(final String versionOld, final String version) {\n+  List<OneVMResult> before = data.get(versionOld) != null ? data.get(versionOld).getResults() : null;\n+  List<OneVMResult> after = data.get(version) != null ? data.get(version).getResults() : null;\n+  CompareData cd = CompareData.createCompareDataFromOneVMResults(before, after);\n+  return cd;\n+ }\n+\n+ public SummaryStatistics getStatistics(final String version) {\n+  LOG.trace(\"Getting data: {}\", version);\n+\n+  final CallTreeStatistics statistics = data.get(version);\n+  return statistics != null ? statistics.getStatistics() : null;\n+ }\n+\n+ public void createStatistics(final String version) {\n+  LOG.debug(\"Creating statistics: {} Call: {}\", version, call);\n+\n+  final CallTreeStatistics callTreeStatistics = data.get(version);\n+  callTreeStatistics.createStatistics();\n+ }\n+\n+ @Override\n+ public String toString() {\n+  return kiekerPattern.toString();\n+ }\n+\n+ public ChangedEntity toEntity() {\n+  if (call.equals(CauseSearchData.ADDED)) {\n+   return otherVersionNode.toEntity();\n+  } else {\n+   final int index = call.lastIndexOf(ChangedEntity.METHOD_SEPARATOR);\n+   final ChangedEntity entity = new ChangedEntity(call.substring(0, index), \"\", call.substring(index + 1));\n+   return entity;\n+  }\n+ }\n+\n+ @JsonIgnore\n+ public TestcaseStatistic getTestcaseStatistic() {\n+  final CallTreeStatistics currentVersionStatistics = data.get(config.getVersion());\n+  final SummaryStatistics current = currentVersionStatistics.getStatistics();\n+  final CallTreeStatistics previousVersionStatistics = data.get(config.getVersionOld());\n+  final SummaryStatistics previous = previousVersionStatistics.getStatistics();\n+  try {\n+   final TestcaseStatistic testcaseStatistic = new TestcaseStatistic(previous, current, previousVersionStatistics.getCalls(), currentVersionStatistics.getCalls());\n+   return testcaseStatistic;\n+  } catch (NumberIsTooSmallException t) {\n+   LOG.debug(\"Data: \" + current.getN() + \" \" + previous.getN());\n+\n+   final String otherCall = otherVersionNode != null ? otherVersionNode.getCall() : \"Not Existing\";\n+   throw new RuntimeException(\"Could not read \" + call + \" Other Version: \" + otherCall, t);\n+  }\n+ }\n+\n+ @JsonIgnore\n+ public TestcaseStatistic getPartialTestcaseStatistic() {\n+  final CallTreeStatistics currentVersionStatistics = data.get(config.getVersion());\n+  final SummaryStatistics current = currentVersionStatistics.getStatistics();\n+  final CallTreeStatistics previousVersionStatistics = data.get(config.getVersionOld());\n+  final SummaryStatistics previous = previousVersionStatistics.getStatistics();\n+  if (firstHasValues(current, previous)) {\n+   final TestcaseStatistic testcaseStatistic = new TestcaseStatistic(previous, current, 0, currentVersionStatistics.getCalls());\n+   testcaseStatistic.setChange(true);\n+   return testcaseStatistic;\n+  } else if (firstHasValues(previous, current)) {\n+          final TestcaseStatistic testcaseStatistic = new TestcaseStatistic(previous, current, previousVersionStatistics.getCalls(), 0);\n+          testcaseStatistic.setChange(true);\n+          return testcaseStatistic;\n+  } else if ((current == null || current.getN() == 0) && (previous == null || previous.getN() == 0)) {\n+          LOG.error(\"Could not measure {}\", this);\n+\n+          final TestcaseStatistic testcaseStatistic = new TestcaseStatistic(previous, current, 0, 0);\n+          testcaseStatistic.setChange(true);\n+          return testcaseStatistic;\n          } else {\n-            LOG.warn(\"Warning! Reading aggregated data which contain less executions than the warmup \" + config.getNodeWarmup());\n-         }\n-         for (StatisticalSummary summary : statistic) {\n-            LOG.trace(\"After removing: {} {} Sum: {}\", summary.getMean(), summary.getN(), summary.getSum());\n-         }\n-         LOG.trace(\"Overall mean: {}\", StatisticUtil.getMean(statistic));\n-      }\n-   }\n-\n-   private void checkDataAddPossible(final String version) {\n-      if (PeassGlobalInfos.isTwoVersionRun) {\n-         if (otherVersionNode == null) {\n-            throw new RuntimeException(\"Other version node needs to be defined before measurement! Node: \" + call);\n+          throw new RuntimeException(\"Partial statistics should exactly be created if one node is unmeasurable\");\n          }\n-         if (otherVersionNode.getCall().equals(CauseSearchData.ADDED) && version.equals(config.getVersion())) {\n-            throw new RuntimeException(\"Added methods may not contain data\");\n-         }\n-      }\n-      if (call.equals(CauseSearchData.ADDED) && version.equals(config.getVersionOld())) {\n-         throw new RuntimeException(\"Added methods may not contain data, trying to add data for \" + version);\n-      }\n-\n-   }\n-\n-   public boolean hasMeasurement(final String version) {\n-      return data.get(version).getResults().size() > 0;\n-   }\n-\n-   public List<OneVMResult> getResults(final String version) {\n-      final CallTreeStatistics statistics = data.get(version);\n-      return statistics != null ? statistics.getResults() : null;\n-   }\n-\n-   public void newVM(final String version) {\n-      final CallTreeStatistics statistics = data.get(version);\n-      LOG.debug(\"Adding VM: {} {} VMs: {}\", call, version, statistics.getResults().size());\n-      statistics.newResult();\n-   }\n-\n-   private void newVersion(final String version) {\n-      LOG.trace(\"Adding version: {}\", version);\n-      CallTreeStatistics statistics = data.get(version);\n-      if (statistics == null) {\n-         statistics = new CallTreeStatistics(config.getNodeWarmup());\n-         data.put(version, statistics);\n-      }\n-   }\n-   \n-   public CompareData getComparableStatistics(final String versionOld, final String version) {\n-      List<OneVMResult> before = data.get(versionOld) != null ? data.get(versionOld).getResults() :null;\n-      List<OneVMResult> after = data.get(version) != null ? data.get(version).getResults() : null;\n-      \n-      CompareData cd = CompareData.createCompareDataFromOneVMResults(before, after);\n-      return cd;\n-   }\n-\n-   public SummaryStatistics getStatistics(final String version) {\n-      LOG.trace(\"Getting data: {}\", version);\n-      final CallTreeStatistics statistics = data.get(version);\n-      return statistics != null ? statistics.getStatistics() : null;\n-   }\n-\n-   public void createStatistics(final String version) {\n-      LOG.debug(\"Creating statistics: {} Call: {}\", version, call);\n-      final CallTreeStatistics callTreeStatistics = data.get(version);\n-      callTreeStatistics.createStatistics();\n-   }\n-\n-   @Override\n-   public String toString() {\n-      return kiekerPattern.toString();\n-   }\n-\n-   public ChangedEntity toEntity() {\n-      if (call.equals(CauseSearchData.ADDED)) {\n-         return otherVersionNode.toEntity();\n-      } else {\n-         final int index = call.lastIndexOf(ChangedEntity.METHOD_SEPARATOR);\n-         final ChangedEntity entity = new ChangedEntity(call.substring(0, index), \"\", call.substring(index + 1));\n-         return entity;\n-      }\n-   }\n-\n-   @JsonIgnore\n-   public TestcaseStatistic getTestcaseStatistic() {\n-      final CallTreeStatistics currentVersionStatistics = data.get(config.getVersion());\n-      final SummaryStatistics current = currentVersionStatistics.getStatistics();\n-      final CallTreeStatistics previousVersionStatistics = data.get(config.getVersionOld());\n-      final SummaryStatistics previous = previousVersionStatistics.getStatistics();\n-      try {\n-         final TestcaseStatistic testcaseStatistic = new TestcaseStatistic(previous, current,\n-               previousVersionStatistics.getCalls(), currentVersionStatistics.getCalls());\n-         return testcaseStatistic;\n-      } catch (NumberIsTooSmallException t) {\n-         LOG.debug(\"Data: \" + current.getN() + \" \" + previous.getN());\n-         final String otherCall = otherVersionNode != null ? otherVersionNode.getCall() : \"Not Existing\";\n-         throw new RuntimeException(\"Could not read \" + call + \" Other Version: \" + otherCall, t);\n-      }\n-   }\n-\n-   @JsonIgnore\n-   public TestcaseStatistic getPartialTestcaseStatistic() {\n-      final CallTreeStatistics currentVersionStatistics = data.get(config.getVersion());\n-      final SummaryStatistics current = currentVersionStatistics.getStatistics();\n-      final CallTreeStatistics previousVersionStatistics = data.get(config.getVersionOld());\n-      final SummaryStatistics previous = previousVersionStatistics.getStatistics();\n-\n-      if (firstHasValues(current, previous)) {\n-         final TestcaseStatistic testcaseStatistic = new TestcaseStatistic(previous, current, 0, currentVersionStatistics.getCalls());\n-         testcaseStatistic.setChange(true);\n-         return testcaseStatistic;\n-      } else if (firstHasValues(previous, current)) {\n-         final TestcaseStatistic testcaseStatistic = new TestcaseStatistic(previous, current, previousVersionStatistics.getCalls(), 0);\n-         testcaseStatistic.setChange(true);\n-         return testcaseStatistic;\n-      } else if ((current == null || current.getN() == 0) && (previous == null || previous.getN() == 0)) {\n-         LOG.error(\"Could not measure {}\", this);\n-         final TestcaseStatistic testcaseStatistic = new TestcaseStatistic(previous, current, 0, 0);\n-         testcaseStatistic.setChange(true);\n-         return testcaseStatistic;\n-      } else {\n-         throw new RuntimeException(\"Partial statistics should exactly be created if one node is unmeasurable\");\n-      }\n-   }\n+ }\n \n-   private boolean firstHasValues(final SummaryStatistics first, final SummaryStatistics second) {\n-      return (second == null || second.getN() == 0) && (first != null && first.getN() > 0);\n-   }\n+ private boolean firstHasValues(final SummaryStatistics first, final SummaryStatistics second) {\n+  return (second == null || second.getN() == 0) && (first != null && first.getN() > 0);\n+ }\n \n    /**\n     * @deprecated use initVersions instead, and asure that the MeasurementConfig already has the correct versions\n     */\n-   @Deprecated\n-   @JsonIgnore\n-   public void setVersions(final String version, final String predecessor) {\n-      config.setVersion(version);\n-      config.setVersionOld(predecessor);\n-      resetStatistics();\n-      newVersion(version);\n-      newVersion(predecessor);\n-   }\n-   \n-   public void initVersions() {\n-      resetStatistics();\n-      newVersion(config.getVersionOld());\n-      newVersion(config.getVersion());\n-   }\n-\n-   @JsonIgnore\n-   public int getTreeSize() {\n-      int size = 1;\n-      for (final CallTreeNode child : children) {\n-         size += child.getTreeSize();\n-      }\n-      return size;\n-   }\n-\n-   protected void resetStatistics() {\n-      data.values().forEach(statistics -> statistics.resetResults());\n-   }\n-\n-   @JsonIgnore\n-   public CallTreeNode getOtherVersionNode() {\n-      return otherVersionNode;\n-   }\n-\n-   public void setOtherVersionNode(final CallTreeNode otherVersionNode) {\n-      this.otherVersionNode = otherVersionNode;\n-   }\n-\n-   @JsonIgnore\n-   public String getMethod() {\n-      final String method = call.substring(call.lastIndexOf('#'));\n-      return method;\n-   }\n-\n-   @JsonIgnore\n-   public String getParameters() {\n-      final String parameters = kiekerPattern.substring(kiekerPattern.indexOf('('));\n-      return parameters;\n-   }\n-\n-   @JsonIgnore\n-   public int getEss() {\n-      return parent != null ? parent.getEss() + 1 : 0;\n-   }\n-\n-   @JsonIgnore\n-   public int getEoi() {\n-      int eoi;\n-      if (parent != null) {\n-         int predecessorIndex = parent.getChildren().indexOf(this) - 1;\n-         if (predecessorIndex >= 0) {\n-            CallTreeNode predecessor = parent.getChildren().get(predecessorIndex);\n-            eoi = predecessor.getEoi() + predecessor.getAllChildCount() + 1;\n-         } else {\n-            eoi = parent.getEoi() + 1;\n-         }\n-      } else {\n-         eoi = 0;\n-      }\n-      return eoi;\n-   }\n-\n-   private int getAllChildCount() {\n-      int childs = 0;\n-      for (CallTreeNode child : children) {\n-         childs += child.getAllChildCount() + 1;\n-      }\n-      return childs;\n-   }\n-\n-   @JsonIgnore\n-   public int getPosition() {\n-      if (parent != null) {\n-         for (int childIndex = 0; childIndex < parent.getChildren().size(); childIndex++) {\n-            if (parent.getChildren().get(childIndex) == this) {\n-               return childIndex;\n-            }\n-         }\n-         return -1;\n-      } else {\n-         return 0;\n-      }\n-   }\n-\n-   public long getCallCount(final String version) {\n-      return data.get(version).getResults().stream().mapToLong(result -> result.getCalls()).sum();\n-   }\n-\n-   @Override\n-   public int hashCode() {\n-      return kiekerPattern.hashCode();\n-   }\n-\n-   @Override\n-   public boolean equals(final Object obj) {\n-      if (obj instanceof CallTreeNode) {\n-         final CallTreeNode other = (CallTreeNode) obj;\n-         boolean equal = other.getKiekerPattern().equals(kiekerPattern);\n-         if (equal) {\n-            if ((this.parent == null) != (other.parent == null)) {\n-               equal = false;\n-            } else if (parent != null) {\n-               equal &= this.parent.equals(other.parent);\n-               equal &= (this.getPosition() == other.getPosition());\n-            }\n-         }\n-         return equal;\n-      } else {\n-         return false;\n-      }\n-   }\n \n+ @Deprecated\n+ @JsonIgnore\n+ public void setVersions(final String version, final String predecessor) {\n+  config.setVersion(version);\n+  config.setVersionOld(predecessor);\n+  resetStatistics();\n+  newVersion(version);\n+  newVersion(predecessor);\n+ }\n+\n+ public void initVersions() {\n+  resetStatistics();\n+  newVersion(config.getVersionOld());\n+  newVersion(config.getVersion());\n+ }\n+\n+ @JsonIgnore\n+ public int getTreeSize() {\n+  int size = 1;\n+  for (final CallTreeNode child : children) {\n+   size += child.getTreeSize();\n+  }\n+  return size;\n+ }\n+\n+ protected void resetStatistics() {\n+  data.values().forEach(statistics -> statistics.resetResults());\n+ }\n+\n+ @JsonIgnore\n+ public CallTreeNode getOtherVersionNode() {\n+  return otherVersionNode;\n+ }\n+\n+ public void setOtherVersionNode(final CallTreeNode otherVersionNode) {\n+  this.otherVersionNode = otherVersionNode;\n+ }\n+\n+ @JsonIgnore\n+ public String getMethod() {\n+  final String method = call.substring(call.lastIndexOf('#'));\n+  return method;\n+ }\n+\n+ @JsonIgnore\n+ public String getParameters() {\n+  final String parameters = kiekerPattern.substring(kiekerPattern.indexOf('('));\n+  return parameters;\n+ }\n+\n+ @JsonIgnore\n+ public int getEss() {\n+  return parent != null ? parent.getEss() + 1 : 0;\n+ }\n+\n+ @JsonIgnore\n+ public int getEoi() {\n+  int eoi;\n+  if (parent != null) {\n+   int predecessorIndex = parent.getChildren().indexOf(this) - 1;\n+   if (predecessorIndex >= 0) {\n+    CallTreeNode predecessor = parent.getChildren().get(predecessorIndex);\n+    eoi = predecessor.getEoi() + predecessor.getAllChildCount() + 1;\n+   } else {\n+    eoi = parent.getEoi() + 1;\n+   }\n+  } else {\n+   eoi = 0;\n+  }\n+  return eoi;\n+ }\n+\n+ private int getAllChildCount() {\n+  int childs = 0;\n+  for (CallTreeNode child : children) {\n+   childs += child.getAllChildCount() + 1;\n+  }\n+  return childs;\n+ }\n+\n+ @JsonIgnore\n+ public int getPosition() {\n+  if (parent != null) {\n+   for (int childIndex = 0; childIndex < parent.getChildren().size(); childIndex++) {\n+    if (parent.getChildren().get(childIndex) == this) {\n+     return childIndex;\n+    }\n+   }\n+   return -1;\n+  } else {\n+   return 0;\n+  }\n+ }\n+\n+ public long getCallCount(final String version) {\n+  return data.get(version).getResults().stream().mapToLong(result -> result.getCalls()).sum();\n+ }\n+\n+ @Override\n+ public int hashCode() {\n+  return kiekerPattern.hashCode();\n+ }\n+\n+ @Override\n+ public boolean equals(final Object obj) {\n+  if (obj instanceof CallTreeNode) {\n+   final CallTreeNode other = (CallTreeNode) obj;\n+   boolean equal = other.getKiekerPattern().equals(kiekerPattern);\n+   if (equal) {\n+    if ((this.parent == null) != (other.parent == null)) {\n+     equal = false;\n+    } else if (parent != null) {\n+            equal &= this.parent.equals(other.parent);\n+            equal &= (this.getPosition() == other.getPosition());\n+    }\n+   }\n+   return equal;\n+  } else {\n+   return false;\n+  }\n+ }\n }\n\\ No newline at end of file\n",
            "diff_size": 586
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/errored/1/31/CallTreeNode.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/styler_random/31/CallTreeNode.java\nindex e72e82b02e8..7559d1504bf 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/errored/1/31/CallTreeNode.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/styler_random/31/CallTreeNode.java\n@@ -174,7 +174,7 @@ public class CallTreeNode extends BasicNode {\n    }\n    \n    public CompareData getComparableStatistics(final String versionOld, final String version) {\n-      List<OneVMResult> before = data.get(versionOld) != null ? data.get(versionOld).getResults() :null;\n+      List<OneVMResult> before = data.get(versionOld) != null ? data.get(versionOld).getResults() : null;\n       List<OneVMResult> after = data.get(version) != null ? data.get(version).getResults() : null;\n       \n       CompareData cd = CompareData.createCompareDataFromOneVMResults(before, after);\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "177",
                    "column": "99",
                    "severity": "error",
                    "message": "':' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ],
    "repaired_by": [
        "styler",
        "styler_random"
    ],
    "not_repaired_by": [
        "intellij",
        "naturalize",
        "codebuff",
        "styler_three_grams"
    ]
}