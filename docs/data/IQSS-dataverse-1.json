{
    "project_name": "IQSS-dataverse",
    "error_id": "1",
    "information": {
        "errors": [
            {
                "line": "122",
                "column": "1",
                "severity": "error",
                "message": "File contains tab characters (this is the first instance).",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
            }
        ]
    },
    "source_code": "public class Admin extends AbstractApiBean {\n\n\tprivate static final Logger logger = Logger.getLogger(Admin.class.getName());\n\n        @EJB\n        AuthenticationProvidersRegistrationServiceBean authProvidersRegistrationSvc;",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "126",
                    "column": "1",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/1/Admin.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler/1/Admin.java\nindex 1df51137969..1118ba7d843 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/1/Admin.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler/1/Admin.java\n@@ -119,7 +119,7 @@ import javax.ws.rs.core.StreamingOutput;\n @Path(\"admin\")\n public class Admin extends AbstractApiBean {\n \n-\tprivate static final Logger logger = Logger.getLogger(Admin.class.getName());\n+private static final Logger logger = Logger.getLogger(Admin.class.getName());\n \n         @EJB\n         AuthenticationProvidersRegistrationServiceBean authProvidersRegistrationSvc;\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/1/Admin.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/intellij/1/Admin.java\nindex 1df51137969..6698c3db462 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/1/Admin.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/intellij/1/Admin.java\n@@ -112,1861 +112,1873 @@ import javax.ws.rs.core.StreamingOutput;\n \n /**\n  * Where the secure, setup API calls live.\n- * \n+ *\n  * @author michael\n  */\n @Stateless\n @Path(\"admin\")\n public class Admin extends AbstractApiBean {\n \n-\tprivate static final Logger logger = Logger.getLogger(Admin.class.getName());\n-\n-        @EJB\n-        AuthenticationProvidersRegistrationServiceBean authProvidersRegistrationSvc;\n-\t@EJB\n-\tBuiltinUserServiceBean builtinUserService;\n-\t@EJB\n-\tShibServiceBean shibService;\n-\t@EJB\n-\tAuthTestDataServiceBean authTestDataService;\n-\t@EJB\n-\tUserServiceBean userService;\n-\t@EJB\n-\tIngestServiceBean ingestService;\n-\t@EJB\n-\tDataFileServiceBean fileService;\n-\t@EJB\n-\tDatasetServiceBean datasetService;\n-\t@EJB\n-\tDatasetVersionServiceBean datasetversionService;\n-        @Inject\n-        DataverseRequestServiceBean dvRequestService;\n-        @EJB\n-        EjbDataverseEngine commandEngine;\n-        @EJB\n-        GroupServiceBean groupService;\n-        @EJB\n-        SettingsServiceBean settingsService;\n-        @EJB\n-        DatasetVersionServiceBean datasetVersionService;\n-        @EJB\n-        ExplicitGroupServiceBean explicitGroupService;\n-        @EJB\n-        BannerMessageServiceBean bannerMessageService;\n-        \n-\n-\t// Make the session available\n-\t@Inject\n-\tDataverseSession session;\n-\n-\tpublic static final String listUsersPartialAPIPath = \"list-users\";\n-\tpublic static final String listUsersFullAPIPath = \"/api/admin/\" + listUsersPartialAPIPath;\n-\n-\t@Path(\"settings\")\n-\t@GET\n-\tpublic Response listAllSettings() {\n-\t\tJsonObjectBuilder bld = jsonObjectBuilder();\n-\t\tsettingsSvc.listAll().forEach(s -> bld.add(s.getName(), s.getContent()));\n-\t\treturn ok(bld);\n-\t}\n-\n-\t@Path(\"settings/{name}\")\n-\t@PUT\n-\tpublic Response putSetting(@PathParam(\"name\") String name, String content) {\n-\t\tSetting s = settingsSvc.set(name, content);\n-\t\treturn ok(jsonObjectBuilder().add(s.getName(), s.getContent()));\n-\t}\n-\n-\t@Path(\"settings/{name}/lang/{lang}\")\n-\t@PUT\n-\tpublic Response putSetting(@PathParam(\"name\") String name, @PathParam(\"lang\") String lang, String content) {\n-\t\tSetting s = settingsSvc.set(name, lang, content);\n-\t\treturn ok(\"Setting \" + name + \" - \" + lang + \" - added.\");\n-\t}\n-\n-\t@Path(\"settings/{name}\")\n-\t@GET\n-\tpublic Response getSetting(@PathParam(\"name\") String name) {\n-\t\tString s = settingsSvc.get(name);\n-\n-\t\treturn (s != null) ? ok(s) : notFound(\"Setting \" + name + \" not found\");\n-\t}\n-\n-\t@Path(\"settings/{name}\")\n-\t@DELETE\n-\tpublic Response deleteSetting(@PathParam(\"name\") String name) {\n-\t\tsettingsSvc.delete(name);\n-\n-\t\treturn ok(\"Setting \" + name + \" deleted.\");\n-\t}\n-\n-\t@Path(\"settings/{name}/lang/{lang}\")\n-\t@DELETE\n-\tpublic Response deleteSetting(@PathParam(\"name\") String name, @PathParam(\"lang\") String lang) {\n-\t\tsettingsSvc.delete(name, lang);\n-\t\treturn ok(\"Setting \" + name + \" - \" + lang + \" deleted.\");\n-\t}\n-\n-\t@Path(\"authenticationProviderFactories\")\n-\t@GET\n-\tpublic Response listAuthProviderFactories() {\n-\t\treturn ok(authSvc.listProviderFactories().stream()\n-\t\t\t\t.map(f -> jsonObjectBuilder().add(\"alias\", f.getAlias()).add(\"info\", f.getInfo()))\n-\t\t\t\t.collect(toJsonArray()));\n-\t}\n-\n-\t@Path(\"authenticationProviders\")\n-\t@GET\n-\tpublic Response listAuthProviders() {\n-\t\treturn ok(em.createNamedQuery(\"AuthenticationProviderRow.findAll\", AuthenticationProviderRow.class)\n-\t\t\t\t.getResultList().stream().map(r -> json(r)).collect(toJsonArray()));\n-\t}\n-\n-\t@Path(\"authenticationProviders\")\n-\t@POST\n-\tpublic Response addProvider(AuthenticationProviderRow row) {\n-\t\ttry {\n-\t\t\tAuthenticationProviderRow managed = em.find(AuthenticationProviderRow.class, row.getId());\n-\t\t\tif (managed != null) {\n-\t\t\t\tmanaged = em.merge(row);\n-\t\t\t} else {\n-\t\t\t\tem.persist(row);\n-\t\t\t\tmanaged = row;\n-\t\t\t}\n-\t\t\tif (managed.isEnabled()) {\n-\t\t\t\tAuthenticationProvider provider = authProvidersRegistrationSvc.loadProvider(managed);\n-\t\t\t\tauthProvidersRegistrationSvc.deregisterProvider(provider.getId());\n-\t\t\t\tauthProvidersRegistrationSvc.registerProvider(provider);\n-\t\t\t}\n-\t\t\treturn created(\"/api/admin/authenticationProviders/\" + managed.getId(), json(managed));\n-\t\t} catch (AuthorizationSetupException e) {\n-\t\t\treturn error(Response.Status.INTERNAL_SERVER_ERROR, e.getMessage());\n-\t\t}\n-\t}\n-\n-\t@Path(\"authenticationProviders/{id}\")\n-\t@GET\n-\tpublic Response showProvider(@PathParam(\"id\") String id) {\n-\t\tAuthenticationProviderRow row = em.find(AuthenticationProviderRow.class, id);\n-\t\treturn (row != null) ? ok(json(row))\n-\t\t\t\t: error(Status.NOT_FOUND, \"Can't find authetication provider with id '\" + id + \"'\");\n-\t}\n-\n-\t@POST\n-\t@Path(\"authenticationProviders/{id}/:enabled\")\n-\tpublic Response enableAuthenticationProvider_deprecated(@PathParam(\"id\") String id, String body) {\n-\t\treturn enableAuthenticationProvider(id, body);\n-\t}\n-\n-\t@PUT\n-\t@Path(\"authenticationProviders/{id}/enabled\")\n-\t@Produces(\"application/json\")\n-\tpublic Response enableAuthenticationProvider(@PathParam(\"id\") String id, String body) {\n-\t\tbody = body.trim();\n-\t\tif (!Util.isBoolean(body)) {\n-\t\t\treturn error(Response.Status.BAD_REQUEST, \"Illegal value '\" + body + \"'. Use 'true' or 'false'\");\n-\t\t}\n-\t\tboolean enable = Util.isTrue(body);\n-\n-\t\tAuthenticationProviderRow row = em.find(AuthenticationProviderRow.class, id);\n-\t\tif (row == null) {\n-\t\t\treturn notFound(\"Can't find authentication provider with id '\" + id + \"'\");\n-\t\t}\n-\n-\t\trow.setEnabled(enable);\n-\t\tem.merge(row);\n-\n-\t\tif (enable) {\n-\t\t\t// enable a provider\n-\t\t\tif (authSvc.getAuthenticationProvider(id) != null) {\n-\t\t\t\treturn ok(String.format(\"Authentication provider '%s' already enabled\", id));\n-\t\t\t}\n-\t\t\ttry {\n-\t\t\t\tauthProvidersRegistrationSvc.registerProvider(authProvidersRegistrationSvc.loadProvider(row));\n-\t\t\t\treturn ok(String.format(\"Authentication Provider %s enabled\", row.getId()));\n-\n-\t\t\t} catch (AuthenticationProviderFactoryNotFoundException ex) {\n-\t\t\t\treturn notFound(String.format(\"Can't instantiate provider, as there's no factory with alias %s\",\n-\t\t\t\t\t\trow.getFactoryAlias()));\n-\t\t\t} catch (AuthorizationSetupException ex) {\n-\t\t\t\tlogger.log(Level.WARNING, \"Error instantiating authentication provider: \" + ex.getMessage(), ex);\n-\t\t\t\treturn error(Status.INTERNAL_SERVER_ERROR,\n-\t\t\t\t\t\tString.format(\"Can't instantiate provider: %s\", ex.getMessage()));\n-\t\t\t}\n-\n-\t\t} else {\n-\t\t\t// disable a provider\n-\t\t\tauthProvidersRegistrationSvc.deregisterProvider(id);\n-\t\t\treturn ok(\"Authentication Provider '\" + id + \"' disabled. \"\n-\t\t\t\t\t+ (authSvc.getAuthenticationProviderIds().isEmpty()\n-\t\t\t\t\t\t\t? \"WARNING: no enabled authentication providers left.\"\n-\t\t\t\t\t\t\t: \"\"));\n-\t\t}\n-\t}\n-\n-\t@GET\n-\t@Path(\"authenticationProviders/{id}/enabled\")\n-\tpublic Response checkAuthenticationProviderEnabled(@PathParam(\"id\") String id) {\n-\t\tList<AuthenticationProviderRow> prvs = em\n-\t\t\t\t.createNamedQuery(\"AuthenticationProviderRow.findById\", AuthenticationProviderRow.class)\n-\t\t\t\t.setParameter(\"id\", id).getResultList();\n-\t\tif (prvs.isEmpty()) {\n-\t\t\treturn notFound(\"Can't find a provider with id '\" + id + \"'.\");\n-\t\t} else {\n-\t\t\treturn ok(Boolean.toString(prvs.get(0).isEnabled()));\n-\t\t}\n-\t}\n-\n-\t@DELETE\n-\t@Path(\"authenticationProviders/{id}/\")\n-\tpublic Response deleteAuthenticationProvider(@PathParam(\"id\") String id) {\n-\t\tauthProvidersRegistrationSvc.deregisterProvider(id);\n-\t\tAuthenticationProviderRow row = em.find(AuthenticationProviderRow.class, id);\n-\t\tif (row != null) {\n-\t\t\tem.remove(row);\n-\t\t}\n-\n-\t\treturn ok(\"AuthenticationProvider \" + id + \" deleted. \"\n-\t\t\t\t+ (authSvc.getAuthenticationProviderIds().isEmpty()\n-\t\t\t\t\t\t? \"WARNING: no enabled authentication providers left.\"\n-\t\t\t\t\t\t: \"\"));\n-\t}\n-\n-    @GET\n-    @Path(\"authenticatedUsers/{identifier}/\")\n-    public Response getAuthenticatedUserByIdentifier(@PathParam(\"identifier\") String identifier) {\n-        AuthenticatedUser authenticatedUser = authSvc.getAuthenticatedUser(identifier);\n-        if (authenticatedUser != null) {\n-            return ok(json(authenticatedUser));\n-        }\n-        return error(Response.Status.BAD_REQUEST, \"User \" + identifier + \" not found.\");\n+  private static final Logger logger = Logger.getLogger(Admin.class.getName());\n+\n+  @EJB\n+  AuthenticationProvidersRegistrationServiceBean authProvidersRegistrationSvc;\n+  @EJB\n+  BuiltinUserServiceBean builtinUserService;\n+  @EJB\n+  ShibServiceBean shibService;\n+  @EJB\n+  AuthTestDataServiceBean authTestDataService;\n+  @EJB\n+  UserServiceBean userService;\n+  @EJB\n+  IngestServiceBean ingestService;\n+  @EJB\n+  DataFileServiceBean fileService;\n+  @EJB\n+  DatasetServiceBean datasetService;\n+  @EJB\n+  DatasetVersionServiceBean datasetversionService;\n+  @Inject\n+  DataverseRequestServiceBean dvRequestService;\n+  @EJB\n+  EjbDataverseEngine commandEngine;\n+  @EJB\n+  GroupServiceBean groupService;\n+  @EJB\n+  SettingsServiceBean settingsService;\n+  @EJB\n+  DatasetVersionServiceBean datasetVersionService;\n+  @EJB\n+  ExplicitGroupServiceBean explicitGroupService;\n+  @EJB\n+  BannerMessageServiceBean bannerMessageService;\n+\n+\n+  // Make the session available\n+  @Inject\n+  DataverseSession session;\n+\n+  public static final String listUsersPartialAPIPath = \"list-users\";\n+  public static final String listUsersFullAPIPath = \"/api/admin/\" + listUsersPartialAPIPath;\n+\n+  @Path(\"settings\")\n+  @GET\n+  public Response listAllSettings() {\n+    JsonObjectBuilder bld = jsonObjectBuilder();\n+    settingsSvc.listAll().forEach(s -> bld.add(s.getName(), s.getContent()));\n+    return ok(bld);\n+  }\n+\n+  @Path(\"settings/{name}\")\n+  @PUT\n+  public Response putSetting(@PathParam(\"name\") String name, String content) {\n+    Setting s = settingsSvc.set(name, content);\n+    return ok(jsonObjectBuilder().add(s.getName(), s.getContent()));\n+  }\n+\n+  @Path(\"settings/{name}/lang/{lang}\")\n+  @PUT\n+  public Response putSetting(@PathParam(\"name\") String name, @PathParam(\"lang\") String lang, String content) {\n+    Setting s = settingsSvc.set(name, lang, content);\n+    return ok(\"Setting \" + name + \" - \" + lang + \" - added.\");\n+  }\n+\n+  @Path(\"settings/{name}\")\n+  @GET\n+  public Response getSetting(@PathParam(\"name\") String name) {\n+    String s = settingsSvc.get(name);\n+\n+    return (s != null) ? ok(s) : notFound(\"Setting \" + name + \" not found\");\n+  }\n+\n+  @Path(\"settings/{name}\")\n+  @DELETE\n+  public Response deleteSetting(@PathParam(\"name\") String name) {\n+    settingsSvc.delete(name);\n+\n+    return ok(\"Setting \" + name + \" deleted.\");\n+  }\n+\n+  @Path(\"settings/{name}/lang/{lang}\")\n+  @DELETE\n+  public Response deleteSetting(@PathParam(\"name\") String name, @PathParam(\"lang\") String lang) {\n+    settingsSvc.delete(name, lang);\n+    return ok(\"Setting \" + name + \" - \" + lang + \" deleted.\");\n+  }\n+\n+  @Path(\"authenticationProviderFactories\")\n+  @GET\n+  public Response listAuthProviderFactories() {\n+    return ok(authSvc.listProviderFactories().stream()\n+      .map(f -> jsonObjectBuilder().add(\"alias\", f.getAlias()).add(\"info\", f.getInfo()))\n+      .collect(toJsonArray()));\n+  }\n+\n+  @Path(\"authenticationProviders\")\n+  @GET\n+  public Response listAuthProviders() {\n+    return ok(em.createNamedQuery(\"AuthenticationProviderRow.findAll\", AuthenticationProviderRow.class)\n+      .getResultList().stream().map(r -> json(r)).collect(toJsonArray()));\n+  }\n+\n+  @Path(\"authenticationProviders\")\n+  @POST\n+  public Response addProvider(AuthenticationProviderRow row) {\n+    try {\n+      AuthenticationProviderRow managed = em.find(AuthenticationProviderRow.class, row.getId());\n+      if (managed != null) {\n+        managed = em.merge(row);\n+      } else {\n+        em.persist(row);\n+        managed = row;\n+      }\n+      if (managed.isEnabled()) {\n+        AuthenticationProvider provider = authProvidersRegistrationSvc.loadProvider(managed);\n+        authProvidersRegistrationSvc.deregisterProvider(provider.getId());\n+        authProvidersRegistrationSvc.registerProvider(provider);\n+      }\n+      return created(\"/api/admin/authenticationProviders/\" + managed.getId(), json(managed));\n+    } catch (AuthorizationSetupException e) {\n+      return error(Response.Status.INTERNAL_SERVER_ERROR, e.getMessage());\n     }\n+  }\n+\n+  @Path(\"authenticationProviders/{id}\")\n+  @GET\n+  public Response showProvider(@PathParam(\"id\") String id) {\n+    AuthenticationProviderRow row = em.find(AuthenticationProviderRow.class, id);\n+    return (row != null) ? ok(json(row))\n+      : error(Status.NOT_FOUND, \"Can't find authetication provider with id '\" + id + \"'\");\n+  }\n+\n+  @POST\n+  @Path(\"authenticationProviders/{id}/:enabled\")\n+  public Response enableAuthenticationProvider_deprecated(@PathParam(\"id\") String id, String body) {\n+    return enableAuthenticationProvider(id, body);\n+  }\n+\n+  @PUT\n+  @Path(\"authenticationProviders/{id}/enabled\")\n+  @Produces(\"application/json\")\n+  public Response enableAuthenticationProvider(@PathParam(\"id\") String id, String body) {\n+    body = body.trim();\n+    if (!Util.isBoolean(body)) {\n+      return error(Response.Status.BAD_REQUEST, \"Illegal value '\" + body + \"'. Use 'true' or 'false'\");\n+    }\n+    boolean enable = Util.isTrue(body);\n \n-    @DELETE\n-    @Path(\"authenticatedUsers/{identifier}/\")\n-    public Response deleteAuthenticatedUser(@PathParam(\"identifier\") String identifier) {\n-        AuthenticatedUser user = authSvc.getAuthenticatedUser(identifier);\n-        if (user != null) {\n-            return deleteAuthenticatedUser(user);\n-        }\n-        return error(Response.Status.BAD_REQUEST, \"User \" + identifier + \" not found.\");\n-    }\n-    \n-    @DELETE\n-    @Path(\"authenticatedUsers/id/{id}/\")\n-    public Response deleteAuthenticatedUserById(@PathParam(\"id\") Long id) {\n-        AuthenticatedUser user = authSvc.findByID(id);\n-        if (user != null) {\n-            return deleteAuthenticatedUser(user);\n-        }\n-        return error(Response.Status.BAD_REQUEST, \"User \" + id + \" not found.\");\n-    }\n-\n-    private Response deleteAuthenticatedUser(AuthenticatedUser au) {\n-        \n-        //getDeleteUserErrorMessages does all of the tests to see\n-        //if the user is 'deletable' if it returns an empty string the user \n-        //can be safely deleted.\n-        \n-        String errorMessages = authSvc.getDeleteUserErrorMessages(au);\n-        \n-        if (!errorMessages.isEmpty()) {\n-            return badRequest(errorMessages);\n-        }\n-        \n-        //if the user is deletable we will delete access requests and group membership\n-        // many-to-many relationships that couldn't be cascade deleted\n-        authSvc.removeAuthentictedUserItems(au);\n-        \n-        authSvc.deleteAuthenticatedUser(au.getId());\n-        return ok(\"AuthenticatedUser \" + au.getIdentifier() + \" deleted.\");\n-    }\n-\n-    @POST\n-    @Path(\"authenticatedUsers/{identifier}/deactivate\")\n-    public Response deactivateAuthenticatedUser(@PathParam(\"identifier\") String identifier) {\n-        AuthenticatedUser user = authSvc.getAuthenticatedUser(identifier);\n-        if (user != null) {\n-            return deactivateAuthenticatedUser(user);\n-        }\n-        return error(Response.Status.BAD_REQUEST, \"User \" + identifier + \" not found.\");\n+    AuthenticationProviderRow row = em.find(AuthenticationProviderRow.class, id);\n+    if (row == null) {\n+      return notFound(\"Can't find authentication provider with id '\" + id + \"'\");\n     }\n \n-    @POST\n-    @Path(\"authenticatedUsers/id/{id}/deactivate\")\n-    public Response deactivateAuthenticatedUserById(@PathParam(\"id\") Long id) {\n-        AuthenticatedUser user = authSvc.findByID(id);\n-        if (user != null) {\n-            return deactivateAuthenticatedUser(user);\n-        }\n-        return error(Response.Status.BAD_REQUEST, \"User \" + id + \" not found.\");\n+    row.setEnabled(enable);\n+    em.merge(row);\n+\n+    if (enable) {\n+      // enable a provider\n+      if (authSvc.getAuthenticationProvider(id) != null) {\n+        return ok(String.format(\"Authentication provider '%s' already enabled\", id));\n+      }\n+      try {\n+        authProvidersRegistrationSvc.registerProvider(authProvidersRegistrationSvc.loadProvider(row));\n+        return ok(String.format(\"Authentication Provider %s enabled\", row.getId()));\n+\n+      } catch (AuthenticationProviderFactoryNotFoundException ex) {\n+        return notFound(String.format(\"Can't instantiate provider, as there's no factory with alias %s\",\n+          row.getFactoryAlias()));\n+      } catch (AuthorizationSetupException ex) {\n+        logger.log(Level.WARNING, \"Error instantiating authentication provider: \" + ex.getMessage(), ex);\n+        return error(Status.INTERNAL_SERVER_ERROR,\n+          String.format(\"Can't instantiate provider: %s\", ex.getMessage()));\n+      }\n+\n+    } else {\n+      // disable a provider\n+      authProvidersRegistrationSvc.deregisterProvider(id);\n+      return ok(\"Authentication Provider '\" + id + \"' disabled. \"\n+        + (authSvc.getAuthenticationProviderIds().isEmpty()\n+        ? \"WARNING: no enabled authentication providers left.\"\n+        : \"\"));\n+    }\n+  }\n+\n+  @GET\n+  @Path(\"authenticationProviders/{id}/enabled\")\n+  public Response checkAuthenticationProviderEnabled(@PathParam(\"id\") String id) {\n+    List<AuthenticationProviderRow> prvs = em\n+      .createNamedQuery(\"AuthenticationProviderRow.findById\", AuthenticationProviderRow.class)\n+      .setParameter(\"id\", id).getResultList();\n+    if (prvs.isEmpty()) {\n+      return notFound(\"Can't find a provider with id '\" + id + \"'.\");\n+    } else {\n+      return ok(Boolean.toString(prvs.get(0).isEnabled()));\n+    }\n+  }\n+\n+  @DELETE\n+  @Path(\"authenticationProviders/{id}/\")\n+  public Response deleteAuthenticationProvider(@PathParam(\"id\") String id) {\n+    authProvidersRegistrationSvc.deregisterProvider(id);\n+    AuthenticationProviderRow row = em.find(AuthenticationProviderRow.class, id);\n+    if (row != null) {\n+      em.remove(row);\n+    }\n+\n+    return ok(\"AuthenticationProvider \" + id + \" deleted. \"\n+      + (authSvc.getAuthenticationProviderIds().isEmpty()\n+      ? \"WARNING: no enabled authentication providers left.\"\n+      : \"\"));\n+  }\n+\n+  @GET\n+  @Path(\"authenticatedUsers/{identifier}/\")\n+  public Response getAuthenticatedUserByIdentifier(@PathParam(\"identifier\") String identifier) {\n+    AuthenticatedUser authenticatedUser = authSvc.getAuthenticatedUser(identifier);\n+    if (authenticatedUser != null) {\n+      return ok(json(authenticatedUser));\n+    }\n+    return error(Response.Status.BAD_REQUEST, \"User \" + identifier + \" not found.\");\n+  }\n+\n+  @DELETE\n+  @Path(\"authenticatedUsers/{identifier}/\")\n+  public Response deleteAuthenticatedUser(@PathParam(\"identifier\") String identifier) {\n+    AuthenticatedUser user = authSvc.getAuthenticatedUser(identifier);\n+    if (user != null) {\n+      return deleteAuthenticatedUser(user);\n+    }\n+    return error(Response.Status.BAD_REQUEST, \"User \" + identifier + \" not found.\");\n+  }\n+\n+  @DELETE\n+  @Path(\"authenticatedUsers/id/{id}/\")\n+  public Response deleteAuthenticatedUserById(@PathParam(\"id\") Long id) {\n+    AuthenticatedUser user = authSvc.findByID(id);\n+    if (user != null) {\n+      return deleteAuthenticatedUser(user);\n+    }\n+    return error(Response.Status.BAD_REQUEST, \"User \" + id + \" not found.\");\n+  }\n+\n+  private Response deleteAuthenticatedUser(AuthenticatedUser au) {\n+\n+    //getDeleteUserErrorMessages does all of the tests to see\n+    //if the user is 'deletable' if it returns an empty string the user\n+    //can be safely deleted.\n+\n+    String errorMessages = authSvc.getDeleteUserErrorMessages(au);\n+\n+    if (!errorMessages.isEmpty()) {\n+      return badRequest(errorMessages);\n+    }\n+\n+    //if the user is deletable we will delete access requests and group membership\n+    // many-to-many relationships that couldn't be cascade deleted\n+    authSvc.removeAuthentictedUserItems(au);\n+\n+    authSvc.deleteAuthenticatedUser(au.getId());\n+    return ok(\"AuthenticatedUser \" + au.getIdentifier() + \" deleted.\");\n+  }\n+\n+  @POST\n+  @Path(\"authenticatedUsers/{identifier}/deactivate\")\n+  public Response deactivateAuthenticatedUser(@PathParam(\"identifier\") String identifier) {\n+    AuthenticatedUser user = authSvc.getAuthenticatedUser(identifier);\n+    if (user != null) {\n+      return deactivateAuthenticatedUser(user);\n+    }\n+    return error(Response.Status.BAD_REQUEST, \"User \" + identifier + \" not found.\");\n+  }\n+\n+  @POST\n+  @Path(\"authenticatedUsers/id/{id}/deactivate\")\n+  public Response deactivateAuthenticatedUserById(@PathParam(\"id\") Long id) {\n+    AuthenticatedUser user = authSvc.findByID(id);\n+    if (user != null) {\n+      return deactivateAuthenticatedUser(user);\n+    }\n+    return error(Response.Status.BAD_REQUEST, \"User \" + id + \" not found.\");\n+  }\n+\n+  private Response deactivateAuthenticatedUser(AuthenticatedUser userToDisable) {\n+    AuthenticatedUser superuser = authSvc.getAdminUser();\n+    if (superuser == null) {\n+      return error(Response.Status.INTERNAL_SERVER_ERROR, \"Cannot find superuser to execute DeactivateUserCommand.\");\n+    }\n+    try {\n+      execCommand(new DeactivateUserCommand(createDataverseRequest(superuser), userToDisable));\n+      return ok(\"User \" + userToDisable.getIdentifier() + \" deactivated.\");\n+    } catch (WrappedResponse ex) {\n+      return ex.getResponse();\n+    }\n+  }\n+\n+  @POST\n+  @Path(\"publishDataverseAsCreator/{id}\")\n+  public Response publishDataverseAsCreator(@PathParam(\"id\") long id) {\n+    try {\n+      Dataverse dataverse = dataverseSvc.find(id);\n+      if (dataverse != null) {\n+        AuthenticatedUser authenticatedUser = dataverse.getCreator();\n+        return ok(json(execCommand(\n+          new PublishDataverseCommand(createDataverseRequest(authenticatedUser), dataverse))));\n+      } else {\n+        return error(Status.BAD_REQUEST, \"Could not find dataverse with id \" + id);\n+      }\n+    } catch (WrappedResponse wr) {\n+      return wr.getResponse();\n+    }\n+  }\n+\n+  @Deprecated\n+  @GET\n+  @Path(\"authenticatedUsers\")\n+  public Response listAuthenticatedUsers() {\n+    try {\n+      AuthenticatedUser user = findAuthenticatedUserOrDie();\n+      if (!user.isSuperuser()) {\n+        return error(Response.Status.FORBIDDEN, \"Superusers only.\");\n+      }\n+    } catch (WrappedResponse ex) {\n+      return error(Response.Status.FORBIDDEN, \"Superusers only.\");\n+    }\n+    JsonArrayBuilder userArray = Json.createArrayBuilder();\n+    authSvc.findAllAuthenticatedUsers().stream().forEach((user) -> {\n+      userArray.add(json(user));\n+    });\n+    return ok(userArray);\n+  }\n+\n+  @GET\n+  @Path(listUsersPartialAPIPath)\n+  @Produces({\"application/json\"})\n+  public Response filterAuthenticatedUsers(\n+    @QueryParam(\"searchTerm\") String searchTerm,\n+    @QueryParam(\"selectedPage\") Integer selectedPage,\n+    @QueryParam(\"itemsPerPage\") Integer itemsPerPage,\n+    @QueryParam(\"sortKey\") String sortKey\n+  ) {\n+\n+    User authUser;\n+    try {\n+      authUser = this.findUserOrDie();\n+    } catch (AbstractApiBean.WrappedResponse ex) {\n+      return error(Response.Status.FORBIDDEN,\n+        BundleUtil.getStringFromBundle(\"dashboard.list_users.api.auth.invalid_apikey\"));\n+    }\n+\n+    if (!authUser.isSuperuser()) {\n+      return error(Response.Status.FORBIDDEN,\n+        BundleUtil.getStringFromBundle(\"dashboard.list_users.api.auth.not_superuser\"));\n     }\n \n-    private Response deactivateAuthenticatedUser(AuthenticatedUser userToDisable) {\n-        AuthenticatedUser superuser = authSvc.getAdminUser();\n-        if (superuser == null) {\n-            return error(Response.Status.INTERNAL_SERVER_ERROR, \"Cannot find superuser to execute DeactivateUserCommand.\");\n+    UserListMaker userListMaker = new UserListMaker(userService);\n+\n+    // String sortKey = null;\n+    UserListResult userListResult = userListMaker.runUserSearch(searchTerm, itemsPerPage, selectedPage, sortKey);\n+\n+    return ok(userListResult.toJSON());\n+  }\n+\n+  /**\n+   * @todo Make this support creation of BuiltInUsers.\n+   * @todo Add way more error checking. Only the happy path is tested by AdminIT.\n+   */\n+  @POST\n+  @Path(\"authenticatedUsers\")\n+  public Response createAuthenicatedUser(JsonObject jsonObject) {\n+    logger.fine(\"JSON in: \" + jsonObject);\n+    String persistentUserId = jsonObject.getString(\"persistentUserId\");\n+    String identifier = jsonObject.getString(\"identifier\");\n+    String proposedAuthenticatedUserIdentifier = identifier.replaceFirst(\"@\", \"\");\n+    String firstName = jsonObject.getString(\"firstName\");\n+    String lastName = jsonObject.getString(\"lastName\");\n+    String emailAddress = jsonObject.getString(\"email\");\n+    String position = null;\n+    String affiliation = null;\n+    UserRecordIdentifier userRecordId = new UserRecordIdentifier(jsonObject.getString(\"authenticationProviderId\"),\n+      persistentUserId);\n+    AuthenticatedUserDisplayInfo userDisplayInfo = new AuthenticatedUserDisplayInfo(firstName, lastName,\n+      emailAddress, affiliation, position);\n+    boolean generateUniqueIdentifier = true;\n+    AuthenticatedUser authenticatedUser = authSvc.createAuthenticatedUser(userRecordId,\n+      proposedAuthenticatedUserIdentifier, userDisplayInfo, true);\n+    return ok(json(authenticatedUser));\n+  }\n+\n+  //TODO: Delete this endpoint after 4.9.3. Was updated with change in docs. --MAD\n+\n+  /**\n+   * curl -X PUT -d \"shib@mailinator.com\"\n+   * http://localhost:8080/api/admin/authenticatedUsers/id/11/convertShibToBuiltIn\n+   *\n+   * @deprecated We have documented this API endpoint so we'll keep in around for\n+   * a while but we should encourage everyone to switch to the\n+   * \"convertRemoteToBuiltIn\" endpoint and then remove this\n+   * Shib-specfic one.\n+   */\n+  @PUT\n+  @Path(\"authenticatedUsers/id/{id}/convertShibToBuiltIn\")\n+  @Deprecated\n+  public Response convertShibUserToBuiltin(@PathParam(\"id\") Long id, String newEmailAddress) {\n+    try {\n+      AuthenticatedUser user = findAuthenticatedUserOrDie();\n+      if (!user.isSuperuser()) {\n+        return error(Response.Status.FORBIDDEN, \"Superusers only.\");\n+      }\n+    } catch (WrappedResponse ex) {\n+      return error(Response.Status.FORBIDDEN, \"Superusers only.\");\n+    }\n+    try {\n+      BuiltinUser builtinUser = authSvc.convertRemoteToBuiltIn(id, newEmailAddress);\n+      if (builtinUser == null) {\n+        return error(Response.Status.BAD_REQUEST, \"User id \" + id\n+          + \" could not be converted from Shibboleth to BuiltIn. An Exception was not thrown.\");\n+      }\n+      AuthenticatedUser authUser = authSvc.getAuthenticatedUser(builtinUser.getUserName());\n+      JsonObjectBuilder output = Json.createObjectBuilder();\n+      output.add(\"email\", authUser.getEmail());\n+      output.add(\"username\", builtinUser.getUserName());\n+      return ok(output);\n+    } catch (Throwable ex) {\n+      StringBuilder sb = new StringBuilder();\n+      sb.append(ex + \" \");\n+      while (ex.getCause() != null) {\n+        ex = ex.getCause();\n+        sb.append(ex + \" \");\n+      }\n+      String msg = \"User id \" + id\n+        + \" could not be converted from Shibboleth to BuiltIn. Details from Exception: \" + sb;\n+      logger.info(msg);\n+      return error(Response.Status.BAD_REQUEST, msg);\n+    }\n+  }\n+\n+  @PUT\n+  @Path(\"authenticatedUsers/id/{id}/convertRemoteToBuiltIn\")\n+  public Response convertOAuthUserToBuiltin(@PathParam(\"id\") Long id, String newEmailAddress) {\n+    try {\n+      AuthenticatedUser user = findAuthenticatedUserOrDie();\n+      if (!user.isSuperuser()) {\n+        return error(Response.Status.FORBIDDEN, \"Superusers only.\");\n+      }\n+    } catch (WrappedResponse ex) {\n+      return error(Response.Status.FORBIDDEN, \"Superusers only.\");\n+    }\n+    try {\n+      BuiltinUser builtinUser = authSvc.convertRemoteToBuiltIn(id, newEmailAddress);\n+      //AuthenticatedUser authUser = authService.getAuthenticatedUser(aUser.getUserName());\n+      if (builtinUser == null) {\n+        return error(Response.Status.BAD_REQUEST, \"User id \" + id\n+          + \" could not be converted from remote to BuiltIn. An Exception was not thrown.\");\n+      }\n+      AuthenticatedUser authUser = authSvc.getAuthenticatedUser(builtinUser.getUserName());\n+      JsonObjectBuilder output = Json.createObjectBuilder();\n+      output.add(\"email\", authUser.getEmail());\n+      output.add(\"username\", builtinUser.getUserName());\n+      return ok(output);\n+    } catch (Throwable ex) {\n+      StringBuilder sb = new StringBuilder();\n+      sb.append(ex + \" \");\n+      while (ex.getCause() != null) {\n+        ex = ex.getCause();\n+        sb.append(ex + \" \");\n+      }\n+      String msg = \"User id \" + id + \" could not be converted from remote to BuiltIn. Details from Exception: \"\n+        + sb;\n+      logger.info(msg);\n+      return error(Response.Status.BAD_REQUEST, msg);\n+    }\n+  }\n+\n+  /**\n+   * This is used in testing via AdminIT.java but we don't expect sysadmins to use\n+   * this.\n+   */\n+  @Path(\"authenticatedUsers/convert/builtin2shib\")\n+  @PUT\n+  public Response builtin2shib(String content) {\n+    logger.info(\"entering builtin2shib...\");\n+    try {\n+      AuthenticatedUser userToRunThisMethod = findAuthenticatedUserOrDie();\n+      if (!userToRunThisMethod.isSuperuser()) {\n+        return error(Response.Status.FORBIDDEN, \"Superusers only.\");\n+      }\n+    } catch (WrappedResponse ex) {\n+      return error(Response.Status.FORBIDDEN, \"Superusers only.\");\n+    }\n+    boolean disabled = false;\n+    if (disabled) {\n+      return error(Response.Status.BAD_REQUEST, \"API endpoint disabled.\");\n+    }\n+    AuthenticatedUser builtInUserToConvert = null;\n+    String emailToFind;\n+    String password;\n+    String authuserId = \"0\"; // could let people specify id on authuser table. probably better to let them\n+    // tell us their\n+    String newEmailAddressToUse;\n+    try {\n+      String[] args = content.split(\":\");\n+      emailToFind = args[0];\n+      password = args[1];\n+      newEmailAddressToUse = args[2];\n+      // authuserId = args[666];\n+    } catch (ArrayIndexOutOfBoundsException ex) {\n+      return error(Response.Status.BAD_REQUEST, \"Problem with content <<<\" + content + \">>>: \" + ex.toString());\n+    }\n+    AuthenticatedUser existingAuthUserFoundByEmail = shibService.findAuthUserByEmail(emailToFind);\n+    String existing = \"NOT FOUND\";\n+    if (existingAuthUserFoundByEmail != null) {\n+      builtInUserToConvert = existingAuthUserFoundByEmail;\n+      existing = existingAuthUserFoundByEmail.getIdentifier();\n+    } else {\n+      long longToLookup = Long.parseLong(authuserId);\n+      AuthenticatedUser specifiedUserToConvert = authSvc.findByID(longToLookup);\n+      if (specifiedUserToConvert != null) {\n+        builtInUserToConvert = specifiedUserToConvert;\n+      } else {\n+        return error(Response.Status.BAD_REQUEST,\n+          \"No user to convert. We couldn't find a *single* existing user account based on \" + emailToFind\n+            + \" and no user was found using specified id \" + longToLookup);\n+      }\n+    }\n+    String shibProviderId = ShibAuthenticationProvider.PROVIDER_ID;\n+    Map<String, String> randomUser = authTestDataService.getRandomUser();\n+    // String eppn = UUID.randomUUID().toString().substring(0, 8);\n+    String eppn = randomUser.get(\"eppn\");\n+    String idPEntityId = randomUser.get(\"idp\");\n+    String notUsed = null;\n+    String separator = \"|\";\n+    UserIdentifier newUserIdentifierInLookupTable = new UserIdentifier(idPEntityId + separator + eppn, notUsed);\n+    String overwriteFirstName = randomUser.get(\"firstName\");\n+    String overwriteLastName = randomUser.get(\"lastName\");\n+    String overwriteEmail = randomUser.get(\"email\");\n+    overwriteEmail = newEmailAddressToUse;\n+    logger.info(\"overwriteEmail: \" + overwriteEmail);\n+    boolean validEmail = EMailValidator.isEmailValid(overwriteEmail, null);\n+    if (!validEmail) {\n+      // See https://github.com/IQSS/dataverse/issues/2998\n+      return error(Response.Status.BAD_REQUEST, \"invalid email: \" + overwriteEmail);\n+    }\n+    /**\n+     * @todo If affiliation is not null, put it in RoleAssigneeDisplayInfo\n+     *       constructor.\n+     */\n+    /**\n+     * Here we are exercising (via an API test) shibService.getAffiliation with the\n+     * TestShib IdP and a non-production DevShibAccountType.\n+     */\n+    idPEntityId = ShibUtil.testShibIdpEntityId;\n+    String overwriteAffiliation = shibService.getAffiliation(idPEntityId,\n+      ShibServiceBean.DevShibAccountType.RANDOM);\n+    logger.info(\"overwriteAffiliation: \" + overwriteAffiliation);\n+    /**\n+     * @todo Find a place to put \"position\" in the authenticateduser table:\n+     *       https://github.com/IQSS/dataverse/issues/1444#issuecomment-74134694\n+     */\n+    String overwritePosition = \"staff;student\";\n+    AuthenticatedUserDisplayInfo displayInfo = new AuthenticatedUserDisplayInfo(overwriteFirstName,\n+      overwriteLastName, overwriteEmail, overwriteAffiliation, overwritePosition);\n+    JsonObjectBuilder response = Json.createObjectBuilder();\n+    JsonArrayBuilder problems = Json.createArrayBuilder();\n+    if (password != null) {\n+      response.add(\"password supplied\", password);\n+      boolean knowsExistingPassword = false;\n+      BuiltinUser oldBuiltInUser = builtinUserService.findByUserName(builtInUserToConvert.getUserIdentifier());\n+      if (oldBuiltInUser != null) {\n+        if (builtInUserToConvert.isDeactivated()) {\n+          problems.add(\"builtin account has been deactivated\");\n+          return error(Status.BAD_REQUEST, problems.build().toString());\n         }\n-        try {\n-            execCommand(new DeactivateUserCommand(createDataverseRequest(superuser), userToDisable));\n-            return ok(\"User \" + userToDisable.getIdentifier() + \" deactivated.\");\n-        } catch (WrappedResponse ex) {\n-            return ex.getResponse();\n+        String usernameOfBuiltinAccountToConvert = oldBuiltInUser.getUserName();\n+        response.add(\"old username\", usernameOfBuiltinAccountToConvert);\n+        AuthenticatedUser authenticatedUser = authSvc.canLogInAsBuiltinUser(usernameOfBuiltinAccountToConvert,\n+          password);\n+        if (authenticatedUser != null) {\n+          knowsExistingPassword = true;\n+          AuthenticatedUser convertedUser = authSvc.convertBuiltInToShib(builtInUserToConvert, shibProviderId,\n+            newUserIdentifierInLookupTable);\n+          if (convertedUser != null) {\n+            /**\n+             * @todo Display name is not being overwritten. Logic must be in Shib backing\n+             *       bean\n+             */\n+            AuthenticatedUser updatedInfoUser = authSvc.updateAuthenticatedUser(convertedUser, displayInfo);\n+            if (updatedInfoUser != null) {\n+              response.add(\"display name overwritten with\", updatedInfoUser.getName());\n+            } else {\n+              problems.add(\"couldn't update display info\");\n+            }\n+          } else {\n+            problems.add(\"unable to convert user\");\n+          }\n         }\n+      } else {\n+        problems.add(\"couldn't find old username\");\n+      }\n+      if (!knowsExistingPassword) {\n+        String message = \"User doesn't know password.\";\n+        problems.add(message);\n+        /**\n+         * @todo Someday we should make a errorResponse method that takes JSON arrays\n+         *       and objects.\n+         */\n+        return error(Status.BAD_REQUEST, problems.build().toString());\n+      }\n+      // response.add(\"knows existing password\", knowsExistingPassword);\n     }\n \n-\t@POST\n-\t@Path(\"publishDataverseAsCreator/{id}\")\n-\tpublic Response publishDataverseAsCreator(@PathParam(\"id\") long id) {\n-\t\ttry {\n-\t\t\tDataverse dataverse = dataverseSvc.find(id);\n-\t\t\tif (dataverse != null) {\n-\t\t\t\tAuthenticatedUser authenticatedUser = dataverse.getCreator();\n-\t\t\t\treturn ok(json(execCommand(\n-\t\t\t\t\t\tnew PublishDataverseCommand(createDataverseRequest(authenticatedUser), dataverse))));\n-\t\t\t} else {\n-\t\t\t\treturn error(Status.BAD_REQUEST, \"Could not find dataverse with id \" + id);\n-\t\t\t}\n-\t\t} catch (WrappedResponse wr) {\n-\t\t\treturn wr.getResponse();\n-\t\t}\n-\t}\n-\n-\t@Deprecated\n-\t@GET\n-\t@Path(\"authenticatedUsers\")\n-\tpublic Response listAuthenticatedUsers() {\n-\t\ttry {\n-\t\t\tAuthenticatedUser user = findAuthenticatedUserOrDie();\n-\t\t\tif (!user.isSuperuser()) {\n-\t\t\t\treturn error(Response.Status.FORBIDDEN, \"Superusers only.\");\n-\t\t\t}\n-\t\t} catch (WrappedResponse ex) {\n-\t\t\treturn error(Response.Status.FORBIDDEN, \"Superusers only.\");\n-\t\t}\n-\t\tJsonArrayBuilder userArray = Json.createArrayBuilder();\n-\t\tauthSvc.findAllAuthenticatedUsers().stream().forEach((user) -> {\n-\t\t\tuserArray.add(json(user));\n-\t\t});\n-\t\treturn ok(userArray);\n-\t}\n-\n-\t@GET\n-\t@Path(listUsersPartialAPIPath)\n-\t@Produces({ \"application/json\" })\n-\tpublic Response filterAuthenticatedUsers(\n-\t\t\t@QueryParam(\"searchTerm\") String searchTerm,\n-\t\t\t@QueryParam(\"selectedPage\") Integer selectedPage,\n-\t\t\t@QueryParam(\"itemsPerPage\") Integer itemsPerPage,\n-\t\t\t@QueryParam(\"sortKey\") String sortKey\n-\t) {\n-\n-\t\tUser authUser;\n-\t\ttry {\n-\t\t\tauthUser = this.findUserOrDie();\n-\t\t} catch (AbstractApiBean.WrappedResponse ex) {\n-\t\t\treturn error(Response.Status.FORBIDDEN,\n-\t\t\t\t\tBundleUtil.getStringFromBundle(\"dashboard.list_users.api.auth.invalid_apikey\"));\n-\t\t}\n-\n-\t\tif (!authUser.isSuperuser()) {\n-\t\t\treturn error(Response.Status.FORBIDDEN,\n-\t\t\t\t\tBundleUtil.getStringFromBundle(\"dashboard.list_users.api.auth.not_superuser\"));\n-\t\t}\n-\n-\t\tUserListMaker userListMaker = new UserListMaker(userService);\n-\n-\t\t// String sortKey = null;\n-\t\tUserListResult userListResult = userListMaker.runUserSearch(searchTerm, itemsPerPage, selectedPage, sortKey);\n-\n-\t\treturn ok(userListResult.toJSON());\n-\t}\n-\n-\t/**\n-\t * @todo Make this support creation of BuiltInUsers.\n-\t *\n-\t * @todo Add way more error checking. Only the happy path is tested by AdminIT.\n-\t */\n-\t@POST\n-\t@Path(\"authenticatedUsers\")\n-\tpublic Response createAuthenicatedUser(JsonObject jsonObject) {\n-\t\tlogger.fine(\"JSON in: \" + jsonObject);\n-\t\tString persistentUserId = jsonObject.getString(\"persistentUserId\");\n-\t\tString identifier = jsonObject.getString(\"identifier\");\n-\t\tString proposedAuthenticatedUserIdentifier = identifier.replaceFirst(\"@\", \"\");\n-\t\tString firstName = jsonObject.getString(\"firstName\");\n-\t\tString lastName = jsonObject.getString(\"lastName\");\n-\t\tString emailAddress = jsonObject.getString(\"email\");\n-\t\tString position = null;\n-\t\tString affiliation = null;\n-\t\tUserRecordIdentifier userRecordId = new UserRecordIdentifier(jsonObject.getString(\"authenticationProviderId\"),\n-\t\t\t\tpersistentUserId);\n-\t\tAuthenticatedUserDisplayInfo userDisplayInfo = new AuthenticatedUserDisplayInfo(firstName, lastName,\n-\t\t\t\temailAddress, affiliation, position);\n-\t\tboolean generateUniqueIdentifier = true;\n-\t\tAuthenticatedUser authenticatedUser = authSvc.createAuthenticatedUser(userRecordId,\n-\t\t\t\tproposedAuthenticatedUserIdentifier, userDisplayInfo, true);\n-\t\treturn ok(json(authenticatedUser));\n-\t}\n-\n-        //TODO: Delete this endpoint after 4.9.3. Was updated with change in docs. --MAD\n-\t/**\n-\t * curl -X PUT -d \"shib@mailinator.com\"\n-\t * http://localhost:8080/api/admin/authenticatedUsers/id/11/convertShibToBuiltIn\n-\t *\n-\t * @deprecated We have documented this API endpoint so we'll keep in around for\n-\t *             a while but we should encourage everyone to switch to the\n-\t *             \"convertRemoteToBuiltIn\" endpoint and then remove this\n-\t *             Shib-specfic one.\n-\t */\n-\t@PUT\n-\t@Path(\"authenticatedUsers/id/{id}/convertShibToBuiltIn\")\n-\t@Deprecated\n-\tpublic Response convertShibUserToBuiltin(@PathParam(\"id\") Long id, String newEmailAddress) {\n-                try {\n-                        AuthenticatedUser user = findAuthenticatedUserOrDie();\n-\t\t\tif (!user.isSuperuser()) {\n-\t\t\t\treturn error(Response.Status.FORBIDDEN, \"Superusers only.\");\n-\t\t\t}\n-\t\t} catch (WrappedResponse ex) {\n-\t\t\treturn error(Response.Status.FORBIDDEN, \"Superusers only.\");\n-\t\t}\n-\t\ttry {\n-\t\t\tBuiltinUser builtinUser = authSvc.convertRemoteToBuiltIn(id, newEmailAddress);\n-\t\t\tif (builtinUser == null) {\n-\t\t\t\treturn error(Response.Status.BAD_REQUEST, \"User id \" + id\n-\t\t\t\t\t\t+ \" could not be converted from Shibboleth to BuiltIn. An Exception was not thrown.\");\n-\t\t\t}\n-                        AuthenticatedUser authUser = authSvc.getAuthenticatedUser(builtinUser.getUserName());\n-\t\t\tJsonObjectBuilder output = Json.createObjectBuilder();\n-\t\t\toutput.add(\"email\", authUser.getEmail());\n-\t\t\toutput.add(\"username\", builtinUser.getUserName());\n-\t\t\treturn ok(output);\n-\t\t} catch (Throwable ex) {\n-\t\t\tStringBuilder sb = new StringBuilder();\n-\t\t\tsb.append(ex + \" \");\n-\t\t\twhile (ex.getCause() != null) {\n-\t\t\t\tex = ex.getCause();\n-\t\t\t\tsb.append(ex + \" \");\n-\t\t\t}\n-\t\t\tString msg = \"User id \" + id\n-\t\t\t\t\t+ \" could not be converted from Shibboleth to BuiltIn. Details from Exception: \" + sb;\n-\t\t\tlogger.info(msg);\n-\t\t\treturn error(Response.Status.BAD_REQUEST, msg);\n-\t\t}\n-\t}\n-\n-\t@PUT\n-\t@Path(\"authenticatedUsers/id/{id}/convertRemoteToBuiltIn\")\n-\tpublic Response convertOAuthUserToBuiltin(@PathParam(\"id\") Long id, String newEmailAddress) {\n-                try {\n-\t\t\tAuthenticatedUser user = findAuthenticatedUserOrDie();\n-\t\t\tif (!user.isSuperuser()) {\n-\t\t\t\treturn error(Response.Status.FORBIDDEN, \"Superusers only.\");\n-\t\t\t}\n-\t\t} catch (WrappedResponse ex) {\n-\t\t\treturn error(Response.Status.FORBIDDEN, \"Superusers only.\");\n-\t\t}\n-\t\ttry {\n-\t\t\tBuiltinUser builtinUser = authSvc.convertRemoteToBuiltIn(id, newEmailAddress);\n-                        //AuthenticatedUser authUser = authService.getAuthenticatedUser(aUser.getUserName());\n-\t\t\tif (builtinUser == null) {\n-\t\t\t\treturn error(Response.Status.BAD_REQUEST, \"User id \" + id\n-\t\t\t\t\t\t+ \" could not be converted from remote to BuiltIn. An Exception was not thrown.\");\n-\t\t\t}\n-                        AuthenticatedUser authUser = authSvc.getAuthenticatedUser(builtinUser.getUserName());\n-\t\t\tJsonObjectBuilder output = Json.createObjectBuilder();\n-\t\t\toutput.add(\"email\", authUser.getEmail());\n-\t\t\toutput.add(\"username\", builtinUser.getUserName());\n-\t\t\treturn ok(output);\n-\t\t} catch (Throwable ex) {\n-\t\t\tStringBuilder sb = new StringBuilder();\n-\t\t\tsb.append(ex + \" \");\n-\t\t\twhile (ex.getCause() != null) {\n-\t\t\t\tex = ex.getCause();\n-\t\t\t\tsb.append(ex + \" \");\n-\t\t\t}\n-\t\t\tString msg = \"User id \" + id + \" could not be converted from remote to BuiltIn. Details from Exception: \"\n-\t\t\t\t\t+ sb;\n-\t\t\tlogger.info(msg);\n-\t\t\treturn error(Response.Status.BAD_REQUEST, msg);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * This is used in testing via AdminIT.java but we don't expect sysadmins to use\n-\t * this.\n-\t */\n-\t@Path(\"authenticatedUsers/convert/builtin2shib\")\n-\t@PUT\n-\tpublic Response builtin2shib(String content) {\n-\t\tlogger.info(\"entering builtin2shib...\");\n-\t\ttry {\n-\t\t\tAuthenticatedUser userToRunThisMethod = findAuthenticatedUserOrDie();\n-\t\t\tif (!userToRunThisMethod.isSuperuser()) {\n-\t\t\t\treturn error(Response.Status.FORBIDDEN, \"Superusers only.\");\n-\t\t\t}\n-\t\t} catch (WrappedResponse ex) {\n-\t\t\treturn error(Response.Status.FORBIDDEN, \"Superusers only.\");\n-\t\t}\n-\t\tboolean disabled = false;\n-\t\tif (disabled) {\n-\t\t\treturn error(Response.Status.BAD_REQUEST, \"API endpoint disabled.\");\n-\t\t}\n-\t\tAuthenticatedUser builtInUserToConvert = null;\n-\t\tString emailToFind;\n-\t\tString password;\n-\t\tString authuserId = \"0\"; // could let people specify id on authuser table. probably better to let them\n-\t\t\t\t\t\t\t\t\t// tell us their\n-\t\tString newEmailAddressToUse;\n-\t\ttry {\n-\t\t\tString[] args = content.split(\":\");\n-\t\t\temailToFind = args[0];\n-\t\t\tpassword = args[1];\n-\t\t\tnewEmailAddressToUse = args[2];\n-\t\t\t// authuserId = args[666];\n-\t\t} catch (ArrayIndexOutOfBoundsException ex) {\n-\t\t\treturn error(Response.Status.BAD_REQUEST, \"Problem with content <<<\" + content + \">>>: \" + ex.toString());\n-\t\t}\n-\t\tAuthenticatedUser existingAuthUserFoundByEmail = shibService.findAuthUserByEmail(emailToFind);\n-\t\tString existing = \"NOT FOUND\";\n-\t\tif (existingAuthUserFoundByEmail != null) {\n-\t\t\tbuiltInUserToConvert = existingAuthUserFoundByEmail;\n-\t\t\texisting = existingAuthUserFoundByEmail.getIdentifier();\n-\t\t} else {\n-\t\t\tlong longToLookup = Long.parseLong(authuserId);\n-\t\t\tAuthenticatedUser specifiedUserToConvert = authSvc.findByID(longToLookup);\n-\t\t\tif (specifiedUserToConvert != null) {\n-\t\t\t\tbuiltInUserToConvert = specifiedUserToConvert;\n-\t\t\t} else {\n-\t\t\t\treturn error(Response.Status.BAD_REQUEST,\n-\t\t\t\t\t\t\"No user to convert. We couldn't find a *single* existing user account based on \" + emailToFind\n-\t\t\t\t\t\t\t\t+ \" and no user was found using specified id \" + longToLookup);\n-\t\t\t}\n-\t\t}\n-\t\tString shibProviderId = ShibAuthenticationProvider.PROVIDER_ID;\n-\t\tMap<String, String> randomUser = authTestDataService.getRandomUser();\n-\t\t// String eppn = UUID.randomUUID().toString().substring(0, 8);\n-\t\tString eppn = randomUser.get(\"eppn\");\n-\t\tString idPEntityId = randomUser.get(\"idp\");\n-\t\tString notUsed = null;\n-\t\tString separator = \"|\";\n-\t\tUserIdentifier newUserIdentifierInLookupTable = new UserIdentifier(idPEntityId + separator + eppn, notUsed);\n-\t\tString overwriteFirstName = randomUser.get(\"firstName\");\n-\t\tString overwriteLastName = randomUser.get(\"lastName\");\n-\t\tString overwriteEmail = randomUser.get(\"email\");\n-\t\toverwriteEmail = newEmailAddressToUse;\n-\t\tlogger.info(\"overwriteEmail: \" + overwriteEmail);\n-\t\tboolean validEmail = EMailValidator.isEmailValid(overwriteEmail, null);\n-\t\tif (!validEmail) {\n-\t\t\t// See https://github.com/IQSS/dataverse/issues/2998\n-\t\t\treturn error(Response.Status.BAD_REQUEST, \"invalid email: \" + overwriteEmail);\n-\t\t}\n-\t\t/**\n-\t\t * @todo If affiliation is not null, put it in RoleAssigneeDisplayInfo\n-\t\t *       constructor.\n-\t\t */\n-\t\t/**\n-\t\t * Here we are exercising (via an API test) shibService.getAffiliation with the\n-\t\t * TestShib IdP and a non-production DevShibAccountType.\n-\t\t */\n-\t\tidPEntityId = ShibUtil.testShibIdpEntityId;\n-\t\tString overwriteAffiliation = shibService.getAffiliation(idPEntityId,\n-\t\t\t\tShibServiceBean.DevShibAccountType.RANDOM);\n-\t\tlogger.info(\"overwriteAffiliation: \" + overwriteAffiliation);\n-\t\t/**\n-\t\t * @todo Find a place to put \"position\" in the authenticateduser table:\n-\t\t *       https://github.com/IQSS/dataverse/issues/1444#issuecomment-74134694\n-\t\t */\n-\t\tString overwritePosition = \"staff;student\";\n-\t\tAuthenticatedUserDisplayInfo displayInfo = new AuthenticatedUserDisplayInfo(overwriteFirstName,\n-\t\t\t\toverwriteLastName, overwriteEmail, overwriteAffiliation, overwritePosition);\n-\t\tJsonObjectBuilder response = Json.createObjectBuilder();\n-\t\tJsonArrayBuilder problems = Json.createArrayBuilder();\n-\t\tif (password != null) {\n-\t\t\tresponse.add(\"password supplied\", password);\n-\t\t\tboolean knowsExistingPassword = false;\n-\t\t\tBuiltinUser oldBuiltInUser = builtinUserService.findByUserName(builtInUserToConvert.getUserIdentifier());\n-\t\t\tif (oldBuiltInUser != null) {\n-                                if (builtInUserToConvert.isDeactivated()) {\n-                                        problems.add(\"builtin account has been deactivated\");\n-                                        return error(Status.BAD_REQUEST, problems.build().toString());\n-                                }\n-\t\t\t\tString usernameOfBuiltinAccountToConvert = oldBuiltInUser.getUserName();\n-\t\t\t\tresponse.add(\"old username\", usernameOfBuiltinAccountToConvert);\n-\t\t\t\tAuthenticatedUser authenticatedUser = authSvc.canLogInAsBuiltinUser(usernameOfBuiltinAccountToConvert,\n-\t\t\t\t\t\tpassword);\n-\t\t\t\tif (authenticatedUser != null) {\n-\t\t\t\t\tknowsExistingPassword = true;\n-\t\t\t\t\tAuthenticatedUser convertedUser = authSvc.convertBuiltInToShib(builtInUserToConvert, shibProviderId,\n-\t\t\t\t\t\t\tnewUserIdentifierInLookupTable);\n-\t\t\t\t\tif (convertedUser != null) {\n-\t\t\t\t\t\t/**\n-\t\t\t\t\t\t * @todo Display name is not being overwritten. Logic must be in Shib backing\n-\t\t\t\t\t\t *       bean\n-\t\t\t\t\t\t */\n-\t\t\t\t\t\tAuthenticatedUser updatedInfoUser = authSvc.updateAuthenticatedUser(convertedUser, displayInfo);\n-\t\t\t\t\t\tif (updatedInfoUser != null) {\n-\t\t\t\t\t\t\tresponse.add(\"display name overwritten with\", updatedInfoUser.getName());\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tproblems.add(\"couldn't update display info\");\n-\t\t\t\t\t\t}\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tproblems.add(\"unable to convert user\");\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\tproblems.add(\"couldn't find old username\");\n-\t\t\t}\n-\t\t\tif (!knowsExistingPassword) {\n-\t\t\t\tString message = \"User doesn't know password.\";\n-\t\t\t\tproblems.add(message);\n-\t\t\t\t/**\n-\t\t\t\t * @todo Someday we should make a errorResponse method that takes JSON arrays\n-\t\t\t\t *       and objects.\n-\t\t\t\t */\n-\t\t\t\treturn error(Status.BAD_REQUEST, problems.build().toString());\n-\t\t\t}\n-\t\t\t// response.add(\"knows existing password\", knowsExistingPassword);\n-\t\t}\n-\n-\t\tresponse.add(\"user to convert\", builtInUserToConvert.getIdentifier());\n-\t\tresponse.add(\"existing user found by email (prompt to convert)\", existing);\n-\t\tresponse.add(\"changing to this provider\", shibProviderId);\n-\t\tresponse.add(\"value to overwrite old first name\", overwriteFirstName);\n-\t\tresponse.add(\"value to overwrite old last name\", overwriteLastName);\n-\t\tresponse.add(\"value to overwrite old email address\", overwriteEmail);\n-\t\tif (overwriteAffiliation != null) {\n-\t\t\tresponse.add(\"affiliation\", overwriteAffiliation);\n-\t\t}\n-\t\tresponse.add(\"problems\", problems);\n-\t\treturn ok(response);\n-\t}\n-\n-\t/**\n-\t * This is used in testing via AdminIT.java but we don't expect sysadmins to use\n-\t * this.\n-\t */\n-\t@Path(\"authenticatedUsers/convert/builtin2oauth\")\n-\t@PUT\n-\tpublic Response builtin2oauth(String content) {\n-\t\tlogger.info(\"entering builtin2oauth...\");\n-\t\ttry {\n-\t\t\tAuthenticatedUser userToRunThisMethod = findAuthenticatedUserOrDie();\n-\t\t\tif (!userToRunThisMethod.isSuperuser()) {\n-\t\t\t\treturn error(Response.Status.FORBIDDEN, \"Superusers only.\");\n-\t\t\t}\n-\t\t} catch (WrappedResponse ex) {\n-\t\t\treturn error(Response.Status.FORBIDDEN, \"Superusers only.\");\n-\t\t}\n-\t\tboolean disabled = false;\n-\t\tif (disabled) {\n-\t\t\treturn error(Response.Status.BAD_REQUEST, \"API endpoint disabled.\");\n-\t\t}\n-\t\tAuthenticatedUser builtInUserToConvert = null;\n-\t\tString emailToFind;\n-\t\tString password;\n-\t\tString authuserId = \"0\"; // could let people specify id on authuser table. probably better to let them\n-\t\t\t\t\t\t\t\t\t// tell us their\n-\t\tString newEmailAddressToUse;\n-\t\tString newProviderId;\n-\t\tString newPersistentUserIdInLookupTable;\n-\t\tlogger.info(\"content: \" + content);\n-\t\ttry {\n-\t\t\tString[] args = content.split(\":\");\n-\t\t\temailToFind = args[0];\n-\t\t\tpassword = args[1];\n-\t\t\tnewEmailAddressToUse = args[2];\n-\t\t\tnewProviderId = args[3];\n-\t\t\tnewPersistentUserIdInLookupTable = args[4];\n-\t\t\t// authuserId = args[666];\n-\t\t} catch (ArrayIndexOutOfBoundsException ex) {\n-\t\t\treturn error(Response.Status.BAD_REQUEST, \"Problem with content <<<\" + content + \">>>: \" + ex.toString());\n-\t\t}\n-\t\tAuthenticatedUser existingAuthUserFoundByEmail = shibService.findAuthUserByEmail(emailToFind);\n-\t\tString existing = \"NOT FOUND\";\n-\t\tif (existingAuthUserFoundByEmail != null) {\n-\t\t\tbuiltInUserToConvert = existingAuthUserFoundByEmail;\n-\t\t\texisting = existingAuthUserFoundByEmail.getIdentifier();\n-\t\t} else {\n-\t\t\tlong longToLookup = Long.parseLong(authuserId);\n-\t\t\tAuthenticatedUser specifiedUserToConvert = authSvc.findByID(longToLookup);\n-\t\t\tif (specifiedUserToConvert != null) {\n-\t\t\t\tbuiltInUserToConvert = specifiedUserToConvert;\n-\t\t\t} else {\n-\t\t\t\treturn error(Response.Status.BAD_REQUEST,\n-\t\t\t\t\t\t\"No user to convert. We couldn't find a *single* existing user account based on \" + emailToFind\n-\t\t\t\t\t\t\t\t+ \" and no user was found using specified id \" + longToLookup);\n-\t\t\t}\n-\t\t}\n-\t\t// String shibProviderId = ShibAuthenticationProvider.PROVIDER_ID;\n-\t\tMap<String, String> randomUser = authTestDataService.getRandomUser();\n-\t\t// String eppn = UUID.randomUUID().toString().substring(0, 8);\n-\t\tString eppn = randomUser.get(\"eppn\");\n-\t\tString idPEntityId = randomUser.get(\"idp\");\n-\t\tString notUsed = null;\n-\t\tString separator = \"|\";\n-\t\t// UserIdentifier newUserIdentifierInLookupTable = new\n-\t\t// UserIdentifier(idPEntityId + separator + eppn, notUsed);\n-\t\tUserIdentifier newUserIdentifierInLookupTable = new UserIdentifier(newPersistentUserIdInLookupTable, notUsed);\n-\t\tString overwriteFirstName = randomUser.get(\"firstName\");\n-\t\tString overwriteLastName = randomUser.get(\"lastName\");\n-\t\tString overwriteEmail = randomUser.get(\"email\");\n-\t\toverwriteEmail = newEmailAddressToUse;\n-\t\tlogger.info(\"overwriteEmail: \" + overwriteEmail);\n-\t\tboolean validEmail = EMailValidator.isEmailValid(overwriteEmail, null);\n-\t\tif (!validEmail) {\n-\t\t\t// See https://github.com/IQSS/dataverse/issues/2998\n-\t\t\treturn error(Response.Status.BAD_REQUEST, \"invalid email: \" + overwriteEmail);\n-\t\t}\n-\t\t/**\n-\t\t * @todo If affiliation is not null, put it in RoleAssigneeDisplayInfo\n-\t\t *       constructor.\n-\t\t */\n-\t\t/**\n-\t\t * Here we are exercising (via an API test) shibService.getAffiliation with the\n-\t\t * TestShib IdP and a non-production DevShibAccountType.\n-\t\t */\n-\t\t// idPEntityId = ShibUtil.testShibIdpEntityId;\n-\t\t// String overwriteAffiliation = shibService.getAffiliation(idPEntityId,\n-\t\t// ShibServiceBean.DevShibAccountType.RANDOM);\n-\t\tString overwriteAffiliation = null;\n-\t\tlogger.info(\"overwriteAffiliation: \" + overwriteAffiliation);\n-\t\t/**\n-\t\t * @todo Find a place to put \"position\" in the authenticateduser table:\n-\t\t *       https://github.com/IQSS/dataverse/issues/1444#issuecomment-74134694\n-\t\t */\n-\t\tString overwritePosition = \"staff;student\";\n-\t\tAuthenticatedUserDisplayInfo displayInfo = new AuthenticatedUserDisplayInfo(overwriteFirstName,\n-\t\t\t\toverwriteLastName, overwriteEmail, overwriteAffiliation, overwritePosition);\n-\t\tJsonObjectBuilder response = Json.createObjectBuilder();\n-\t\tJsonArrayBuilder problems = Json.createArrayBuilder();\n-\t\tif (password != null) {\n-\t\t\tresponse.add(\"password supplied\", password);\n-\t\t\tboolean knowsExistingPassword = false;\n-\t\t\tBuiltinUser oldBuiltInUser = builtinUserService.findByUserName(builtInUserToConvert.getUserIdentifier());\n-\t\t\tif (oldBuiltInUser != null) {\n-\t\t\t\tString usernameOfBuiltinAccountToConvert = oldBuiltInUser.getUserName();\n-\t\t\t\tresponse.add(\"old username\", usernameOfBuiltinAccountToConvert);\n-\t\t\t\tAuthenticatedUser authenticatedUser = authSvc.canLogInAsBuiltinUser(usernameOfBuiltinAccountToConvert,\n-\t\t\t\t\t\tpassword);\n-\t\t\t\tif (authenticatedUser != null) {\n-\t\t\t\t\tknowsExistingPassword = true;\n-\t\t\t\t\tAuthenticatedUser convertedUser = authSvc.convertBuiltInUserToRemoteUser(builtInUserToConvert,\n-\t\t\t\t\t\t\tnewProviderId, newUserIdentifierInLookupTable);\n-\t\t\t\t\tif (convertedUser != null) {\n-\t\t\t\t\t\t/**\n-\t\t\t\t\t\t * @todo Display name is not being overwritten. Logic must be in Shib backing\n-\t\t\t\t\t\t *       bean\n-\t\t\t\t\t\t */\n-\t\t\t\t\t\tAuthenticatedUser updatedInfoUser = authSvc.updateAuthenticatedUser(convertedUser, displayInfo);\n-\t\t\t\t\t\tif (updatedInfoUser != null) {\n-\t\t\t\t\t\t\tresponse.add(\"display name overwritten with\", updatedInfoUser.getName());\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tproblems.add(\"couldn't update display info\");\n-\t\t\t\t\t\t}\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tproblems.add(\"unable to convert user\");\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\tproblems.add(\"couldn't find old username\");\n-\t\t\t}\n-\t\t\tif (!knowsExistingPassword) {\n-\t\t\t\tString message = \"User doesn't know password.\";\n-\t\t\t\tproblems.add(message);\n-\t\t\t\t/**\n-\t\t\t\t * @todo Someday we should make a errorResponse method that takes JSON arrays\n-\t\t\t\t *       and objects.\n-\t\t\t\t */\n-\t\t\t\treturn error(Status.BAD_REQUEST, problems.build().toString());\n-\t\t\t}\n-\t\t\t// response.add(\"knows existing password\", knowsExistingPassword);\n-\t\t}\n-\n-\t\tresponse.add(\"user to convert\", builtInUserToConvert.getIdentifier());\n-\t\tresponse.add(\"existing user found by email (prompt to convert)\", existing);\n-\t\tresponse.add(\"changing to this provider\", newProviderId);\n-\t\tresponse.add(\"value to overwrite old first name\", overwriteFirstName);\n-\t\tresponse.add(\"value to overwrite old last name\", overwriteLastName);\n-\t\tresponse.add(\"value to overwrite old email address\", overwriteEmail);\n-\t\tif (overwriteAffiliation != null) {\n-\t\t\tresponse.add(\"affiliation\", overwriteAffiliation);\n-\t\t}\n-\t\tresponse.add(\"problems\", problems);\n-\t\treturn ok(response);\n-\t}\n-\n-\n-\n-\n-\t@Path(\"roles\")\n-\t@POST\n-\tpublic Response createNewBuiltinRole(RoleDTO roleDto) {\n-\t\tActionLogRecord alr = new ActionLogRecord(ActionLogRecord.ActionType.Admin, \"createBuiltInRole\")\n-\t\t\t\t.setInfo(roleDto.getAlias() + \":\" + roleDto.getDescription());\n-\t\ttry {\n-\t\t\treturn ok(json(rolesSvc.save(roleDto.asRole())));\n-\t\t} catch (Exception e) {\n-\t\t\talr.setActionResult(ActionLogRecord.Result.InternalError);\n-\t\t\talr.setInfo(alr.getInfo() + \"// \" + e.getMessage());\n-\t\t\treturn error(Response.Status.INTERNAL_SERVER_ERROR, e.getMessage());\n-\t\t} finally {\n-\t\t\tactionLogSvc.log(alr);\n-\t\t}\n-\t}\n-\n-\t@Path(\"roles\")\n-\t@GET\n-\tpublic Response listBuiltinRoles() {\n-\t\ttry {\n-\t\t\treturn ok(rolesToJson(rolesSvc.findBuiltinRoles()));\n-\t\t} catch (Exception e) {\n-\t\t\treturn error(Response.Status.INTERNAL_SERVER_ERROR, e.getMessage());\n-\t\t}\n-\t}\n-        \n-    @DELETE\n-    @Path(\"roles/{id}\")\n-    public Response deleteRole(@PathParam(\"id\") String id) {\n-\n-        return response(req -> {\n-            DataverseRole doomed = findRoleOrDie(id);\n-            execCommand(new DeleteRoleCommand(req, doomed));\n-            return ok(\"role \" + doomed.getName() + \" deleted.\");\n-        });\n-    }\n-\n-\t@Path(\"superuser/{identifier}\")\n-\t@POST\n-\tpublic Response toggleSuperuser(@PathParam(\"identifier\") String identifier) {\n-\t\tActionLogRecord alr = new ActionLogRecord(ActionLogRecord.ActionType.Admin, \"toggleSuperuser\")\n-\t\t\t\t.setInfo(identifier);\n-\t\ttry {\n-\t\t\tAuthenticatedUser user = authSvc.getAuthenticatedUser(identifier);\n-                        if (user.isDeactivated()) {\n-                            return error(Status.BAD_REQUEST, \"You cannot make a deactivated user a superuser.\");\n-                        }\n-\n-\t\t\tuser.setSuperuser(!user.isSuperuser());\n-\n-\t\t\treturn ok(\"User \" + user.getIdentifier() + \" \" + (user.isSuperuser() ? \"set\" : \"removed\")\n-\t\t\t\t\t+ \" as a superuser.\");\n-\t\t} catch (Exception e) {\n-\t\t\talr.setActionResult(ActionLogRecord.Result.InternalError);\n-\t\t\talr.setInfo(alr.getInfo() + \"// \" + e.getMessage());\n-\t\t\treturn error(Response.Status.INTERNAL_SERVER_ERROR, e.getMessage());\n-\t\t} finally {\n-\t\t\tactionLogSvc.log(alr);\n-\t\t}\n-\t}\n-\n-    @GET\n-    @Path(\"validate/datasets\")\n-    @Produces({\"application/json\"})\n-    public Response validateAllDatasets(@QueryParam(\"variables\") boolean includeVariables) {\n-        \n-        // Streaming output: the API will start producing \n-        // the output right away, as it goes through the list \n-        // of the datasets; there's potentially a lot of content \n-        // to validate, so we don't want to wait for the process \n-        // to finish. Or to wait to encounter the first invalid \n-        // object - so we'll be reporting both the success and failure\n-        // outcomes for all the validated datasets, to give the user\n-        // an indication of the progress. \n-        // This is the first streaming API that produces json that \n-        // we have; there may be better ways to stream json - but \n-        // what I have put together below works. -- L.A. \n-        StreamingOutput stream = new StreamingOutput() {\n-\n-            @Override\n-            public void write(OutputStream os) throws IOException,\n-                    WebApplicationException {\n-                os.write(\"{\\\"datasets\\\": [\\n\".getBytes());\n-                \n-                boolean wroteObject = false;\n-                for (Long datasetId : datasetService.findAllLocalDatasetIds()) {\n-                    // Potentially, there's a godzillion datasets in this Dataverse. \n-                    // This is why we go through the list of ids here, and instantiate \n-                    // only one dataset at a time. \n-                    boolean success = false;\n-                    boolean constraintViolationDetected = false;\n-                     \n-                    JsonObjectBuilder output = Json.createObjectBuilder();\n-                    output.add(\"datasetId\", datasetId);\n-\n-                    \n-                    try {\n-                        datasetService.instantiateDatasetInNewTransaction(datasetId, includeVariables);\n-                        success = true;\n-                    } catch (Exception ex) {\n-                        Throwable cause = ex;\n-                        while (cause != null) {\n-                            if (cause instanceof ConstraintViolationException) {\n-                                ConstraintViolationException constraintViolationException = (ConstraintViolationException) cause;\n-                                for (ConstraintViolation<?> constraintViolation : constraintViolationException\n-                                        .getConstraintViolations()) {\n-                                    String databaseRow = constraintViolation.getLeafBean().toString();\n-                                    String field = constraintViolation.getPropertyPath().toString();\n-                                    String invalidValue = null;\n-                                    if (constraintViolation.getInvalidValue() != null) {\n-                                        invalidValue = constraintViolation.getInvalidValue().toString();\n-                                    }\n-                                    output.add(\"status\", \"invalid\");\n-                                    output.add(\"entityClassDatabaseTableRowId\", databaseRow);\n-                                    output.add(\"field\", field);\n-                                    output.add(\"invalidValue\", invalidValue == null ? \"NULL\" : invalidValue);\n-                                    \n-                                    constraintViolationDetected = true; \n-                                    \n-                                    break; \n-                                    \n-                                }\n-                            }\n-                            cause = cause.getCause();\n-                        }\n-                    }\n-                    \n-                    \n-                    if (success) {\n-                        output.add(\"status\", \"valid\");\n-                    } else if (!constraintViolationDetected) {\n-                        output.add(\"status\", \"unknown\");\n-                    }\n-                    \n-                    // write it out:\n-                    \n-                    if (wroteObject) {\n-                        os.write(\",\\n\".getBytes());\n-                    }\n-\n-                    os.write(output.build().toString().getBytes(\"UTF8\"));\n-                    \n-                    if (!wroteObject) {\n-                        wroteObject = true;\n-                    }\n-                }\n-                \n-                \n-                os.write(\"\\n]\\n}\\n\".getBytes());\n+    response.add(\"user to convert\", builtInUserToConvert.getIdentifier());\n+    response.add(\"existing user found by email (prompt to convert)\", existing);\n+    response.add(\"changing to this provider\", shibProviderId);\n+    response.add(\"value to overwrite old first name\", overwriteFirstName);\n+    response.add(\"value to overwrite old last name\", overwriteLastName);\n+    response.add(\"value to overwrite old email address\", overwriteEmail);\n+    if (overwriteAffiliation != null) {\n+      response.add(\"affiliation\", overwriteAffiliation);\n+    }\n+    response.add(\"problems\", problems);\n+    return ok(response);\n+  }\n+\n+  /**\n+   * This is used in testing via AdminIT.java but we don't expect sysadmins to use\n+   * this.\n+   */\n+  @Path(\"authenticatedUsers/convert/builtin2oauth\")\n+  @PUT\n+  public Response builtin2oauth(String content) {\n+    logger.info(\"entering builtin2oauth...\");\n+    try {\n+      AuthenticatedUser userToRunThisMethod = findAuthenticatedUserOrDie();\n+      if (!userToRunThisMethod.isSuperuser()) {\n+        return error(Response.Status.FORBIDDEN, \"Superusers only.\");\n+      }\n+    } catch (WrappedResponse ex) {\n+      return error(Response.Status.FORBIDDEN, \"Superusers only.\");\n+    }\n+    boolean disabled = false;\n+    if (disabled) {\n+      return error(Response.Status.BAD_REQUEST, \"API endpoint disabled.\");\n+    }\n+    AuthenticatedUser builtInUserToConvert = null;\n+    String emailToFind;\n+    String password;\n+    String authuserId = \"0\"; // could let people specify id on authuser table. probably better to let them\n+    // tell us their\n+    String newEmailAddressToUse;\n+    String newProviderId;\n+    String newPersistentUserIdInLookupTable;\n+    logger.info(\"content: \" + content);\n+    try {\n+      String[] args = content.split(\":\");\n+      emailToFind = args[0];\n+      password = args[1];\n+      newEmailAddressToUse = args[2];\n+      newProviderId = args[3];\n+      newPersistentUserIdInLookupTable = args[4];\n+      // authuserId = args[666];\n+    } catch (ArrayIndexOutOfBoundsException ex) {\n+      return error(Response.Status.BAD_REQUEST, \"Problem with content <<<\" + content + \">>>: \" + ex.toString());\n+    }\n+    AuthenticatedUser existingAuthUserFoundByEmail = shibService.findAuthUserByEmail(emailToFind);\n+    String existing = \"NOT FOUND\";\n+    if (existingAuthUserFoundByEmail != null) {\n+      builtInUserToConvert = existingAuthUserFoundByEmail;\n+      existing = existingAuthUserFoundByEmail.getIdentifier();\n+    } else {\n+      long longToLookup = Long.parseLong(authuserId);\n+      AuthenticatedUser specifiedUserToConvert = authSvc.findByID(longToLookup);\n+      if (specifiedUserToConvert != null) {\n+        builtInUserToConvert = specifiedUserToConvert;\n+      } else {\n+        return error(Response.Status.BAD_REQUEST,\n+          \"No user to convert. We couldn't find a *single* existing user account based on \" + emailToFind\n+            + \" and no user was found using specified id \" + longToLookup);\n+      }\n+    }\n+    // String shibProviderId = ShibAuthenticationProvider.PROVIDER_ID;\n+    Map<String, String> randomUser = authTestDataService.getRandomUser();\n+    // String eppn = UUID.randomUUID().toString().substring(0, 8);\n+    String eppn = randomUser.get(\"eppn\");\n+    String idPEntityId = randomUser.get(\"idp\");\n+    String notUsed = null;\n+    String separator = \"|\";\n+    // UserIdentifier newUserIdentifierInLookupTable = new\n+    // UserIdentifier(idPEntityId + separator + eppn, notUsed);\n+    UserIdentifier newUserIdentifierInLookupTable = new UserIdentifier(newPersistentUserIdInLookupTable, notUsed);\n+    String overwriteFirstName = randomUser.get(\"firstName\");\n+    String overwriteLastName = randomUser.get(\"lastName\");\n+    String overwriteEmail = randomUser.get(\"email\");\n+    overwriteEmail = newEmailAddressToUse;\n+    logger.info(\"overwriteEmail: \" + overwriteEmail);\n+    boolean validEmail = EMailValidator.isEmailValid(overwriteEmail, null);\n+    if (!validEmail) {\n+      // See https://github.com/IQSS/dataverse/issues/2998\n+      return error(Response.Status.BAD_REQUEST, \"invalid email: \" + overwriteEmail);\n+    }\n+    /**\n+     * @todo If affiliation is not null, put it in RoleAssigneeDisplayInfo\n+     *       constructor.\n+     */\n+    /**\n+     * Here we are exercising (via an API test) shibService.getAffiliation with the\n+     * TestShib IdP and a non-production DevShibAccountType.\n+     */\n+    // idPEntityId = ShibUtil.testShibIdpEntityId;\n+    // String overwriteAffiliation = shibService.getAffiliation(idPEntityId,\n+    // ShibServiceBean.DevShibAccountType.RANDOM);\n+    String overwriteAffiliation = null;\n+    logger.info(\"overwriteAffiliation: \" + overwriteAffiliation);\n+    /**\n+     * @todo Find a place to put \"position\" in the authenticateduser table:\n+     *       https://github.com/IQSS/dataverse/issues/1444#issuecomment-74134694\n+     */\n+    String overwritePosition = \"staff;student\";\n+    AuthenticatedUserDisplayInfo displayInfo = new AuthenticatedUserDisplayInfo(overwriteFirstName,\n+      overwriteLastName, overwriteEmail, overwriteAffiliation, overwritePosition);\n+    JsonObjectBuilder response = Json.createObjectBuilder();\n+    JsonArrayBuilder problems = Json.createArrayBuilder();\n+    if (password != null) {\n+      response.add(\"password supplied\", password);\n+      boolean knowsExistingPassword = false;\n+      BuiltinUser oldBuiltInUser = builtinUserService.findByUserName(builtInUserToConvert.getUserIdentifier());\n+      if (oldBuiltInUser != null) {\n+        String usernameOfBuiltinAccountToConvert = oldBuiltInUser.getUserName();\n+        response.add(\"old username\", usernameOfBuiltinAccountToConvert);\n+        AuthenticatedUser authenticatedUser = authSvc.canLogInAsBuiltinUser(usernameOfBuiltinAccountToConvert,\n+          password);\n+        if (authenticatedUser != null) {\n+          knowsExistingPassword = true;\n+          AuthenticatedUser convertedUser = authSvc.convertBuiltInUserToRemoteUser(builtInUserToConvert,\n+            newProviderId, newUserIdentifierInLookupTable);\n+          if (convertedUser != null) {\n+            /**\n+             * @todo Display name is not being overwritten. Logic must be in Shib backing\n+             *       bean\n+             */\n+            AuthenticatedUser updatedInfoUser = authSvc.updateAuthenticatedUser(convertedUser, displayInfo);\n+            if (updatedInfoUser != null) {\n+              response.add(\"display name overwritten with\", updatedInfoUser.getName());\n+            } else {\n+              problems.add(\"couldn't update display info\");\n             }\n-            \n-        };\n-        return Response.ok(stream).build();\n-    }\n-        \n-    @Path(\"validate/dataset/{id}\")\n-    @GET\n-    public Response validateDataset(@PathParam(\"id\") String id, @QueryParam(\"variables\") boolean includeVariables) {\n-        Dataset dataset;\n-        try {\n-            dataset = findDatasetOrDie(id);\n-        } catch (Exception ex) {\n-            return error(Response.Status.NOT_FOUND, \"No Such Dataset\");\n+          } else {\n+            problems.add(\"unable to convert user\");\n+          }\n         }\n+      } else {\n+        problems.add(\"couldn't find old username\");\n+      }\n+      if (!knowsExistingPassword) {\n+        String message = \"User doesn't know password.\";\n+        problems.add(message);\n+        /**\n+         * @todo Someday we should make a errorResponse method that takes JSON arrays\n+         *       and objects.\n+         */\n+        return error(Status.BAD_REQUEST, problems.build().toString());\n+      }\n+      // response.add(\"knows existing password\", knowsExistingPassword);\n+    }\n \n-        Long dbId = dataset.getId();\n-\n-        String msg = \"unknown\";\n-        try {\n-            datasetService.instantiateDatasetInNewTransaction(dbId, includeVariables);\n-            msg = \"valid\";\n-        } catch (Exception ex) {\n+    response.add(\"user to convert\", builtInUserToConvert.getIdentifier());\n+    response.add(\"existing user found by email (prompt to convert)\", existing);\n+    response.add(\"changing to this provider\", newProviderId);\n+    response.add(\"value to overwrite old first name\", overwriteFirstName);\n+    response.add(\"value to overwrite old last name\", overwriteLastName);\n+    response.add(\"value to overwrite old email address\", overwriteEmail);\n+    if (overwriteAffiliation != null) {\n+      response.add(\"affiliation\", overwriteAffiliation);\n+    }\n+    response.add(\"problems\", problems);\n+    return ok(response);\n+  }\n+\n+\n+  @Path(\"roles\")\n+  @POST\n+  public Response createNewBuiltinRole(RoleDTO roleDto) {\n+    ActionLogRecord alr = new ActionLogRecord(ActionLogRecord.ActionType.Admin, \"createBuiltInRole\")\n+      .setInfo(roleDto.getAlias() + \":\" + roleDto.getDescription());\n+    try {\n+      return ok(json(rolesSvc.save(roleDto.asRole())));\n+    } catch (Exception e) {\n+      alr.setActionResult(ActionLogRecord.Result.InternalError);\n+      alr.setInfo(alr.getInfo() + \"// \" + e.getMessage());\n+      return error(Response.Status.INTERNAL_SERVER_ERROR, e.getMessage());\n+    } finally {\n+      actionLogSvc.log(alr);\n+    }\n+  }\n+\n+  @Path(\"roles\")\n+  @GET\n+  public Response listBuiltinRoles() {\n+    try {\n+      return ok(rolesToJson(rolesSvc.findBuiltinRoles()));\n+    } catch (Exception e) {\n+      return error(Response.Status.INTERNAL_SERVER_ERROR, e.getMessage());\n+    }\n+  }\n+\n+  @DELETE\n+  @Path(\"roles/{id}\")\n+  public Response deleteRole(@PathParam(\"id\") String id) {\n+\n+    return response(req -> {\n+      DataverseRole doomed = findRoleOrDie(id);\n+      execCommand(new DeleteRoleCommand(req, doomed));\n+      return ok(\"role \" + doomed.getName() + \" deleted.\");\n+    });\n+  }\n+\n+  @Path(\"superuser/{identifier}\")\n+  @POST\n+  public Response toggleSuperuser(@PathParam(\"identifier\") String identifier) {\n+    ActionLogRecord alr = new ActionLogRecord(ActionLogRecord.ActionType.Admin, \"toggleSuperuser\")\n+      .setInfo(identifier);\n+    try {\n+      AuthenticatedUser user = authSvc.getAuthenticatedUser(identifier);\n+      if (user.isDeactivated()) {\n+        return error(Status.BAD_REQUEST, \"You cannot make a deactivated user a superuser.\");\n+      }\n+\n+      user.setSuperuser(!user.isSuperuser());\n+\n+      return ok(\"User \" + user.getIdentifier() + \" \" + (user.isSuperuser() ? \"set\" : \"removed\")\n+        + \" as a superuser.\");\n+    } catch (Exception e) {\n+      alr.setActionResult(ActionLogRecord.Result.InternalError);\n+      alr.setInfo(alr.getInfo() + \"// \" + e.getMessage());\n+      return error(Response.Status.INTERNAL_SERVER_ERROR, e.getMessage());\n+    } finally {\n+      actionLogSvc.log(alr);\n+    }\n+  }\n+\n+  @GET\n+  @Path(\"validate/datasets\")\n+  @Produces({\"application/json\"})\n+  public Response validateAllDatasets(@QueryParam(\"variables\") boolean includeVariables) {\n+\n+    // Streaming output: the API will start producing\n+    // the output right away, as it goes through the list\n+    // of the datasets; there's potentially a lot of content\n+    // to validate, so we don't want to wait for the process\n+    // to finish. Or to wait to encounter the first invalid\n+    // object - so we'll be reporting both the success and failure\n+    // outcomes for all the validated datasets, to give the user\n+    // an indication of the progress.\n+    // This is the first streaming API that produces json that\n+    // we have; there may be better ways to stream json - but\n+    // what I have put together below works. -- L.A.\n+    StreamingOutput stream = new StreamingOutput() {\n+\n+      @Override\n+      public void write(OutputStream os) throws IOException,\n+        WebApplicationException {\n+        os.write(\"{\\\"datasets\\\": [\\n\".getBytes());\n+\n+        boolean wroteObject = false;\n+        for (Long datasetId : datasetService.findAllLocalDatasetIds()) {\n+          // Potentially, there's a godzillion datasets in this Dataverse.\n+          // This is why we go through the list of ids here, and instantiate\n+          // only one dataset at a time.\n+          boolean success = false;\n+          boolean constraintViolationDetected = false;\n+\n+          JsonObjectBuilder output = Json.createObjectBuilder();\n+          output.add(\"datasetId\", datasetId);\n+\n+\n+          try {\n+            datasetService.instantiateDatasetInNewTransaction(datasetId, includeVariables);\n+            success = true;\n+          } catch (Exception ex) {\n             Throwable cause = ex;\n             while (cause != null) {\n-                if (cause instanceof ConstraintViolationException) {\n-                    ConstraintViolationException constraintViolationException = (ConstraintViolationException) cause;\n-                    for (ConstraintViolation<?> constraintViolation : constraintViolationException\n-                            .getConstraintViolations()) {\n-                        String databaseRow = constraintViolation.getLeafBean().toString();\n-                        String field = constraintViolation.getPropertyPath().toString();\n-                        String invalidValue = null; \n-                        if (constraintViolation.getInvalidValue() != null) {\n-                            invalidValue = constraintViolation.getInvalidValue().toString();\n-                        }\n-                        JsonObjectBuilder violation = Json.createObjectBuilder();\n-                        violation.add(\"entityClassDatabaseTableRowId\", databaseRow);\n-                        violation.add(\"field\", field);\n-                        violation.add(\"invalidValue\", invalidValue == null ? \"NULL\" : invalidValue);\n-                        return ok(violation);\n-                    }\n-                }\n-                cause = cause.getCause();\n-            }\n-        }\n-        return ok(msg);\n-    }\n-    \n-    // This API does the same thing as /validateDataFileHashValue/{fileId}, \n-    // but for all the files in the dataset, with streaming output.\n-    @GET\n-    @Path(\"validate/dataset/files/{id}\")\n-    @Produces({\"application/json\"})\n-    public Response validateDatasetDatafiles(@PathParam(\"id\") String id) {\n-        \n-        // Streaming output: the API will start producing \n-        // the output right away, as it goes through the list \n-        // of the datafiles in the dataset.\n-        // The streaming mechanism is modeled after validate/datasets API.\n-        StreamingOutput stream = new StreamingOutput() {\n-\n-            @Override\n-            public void write(OutputStream os) throws IOException,\n-                    WebApplicationException {\n-                Dataset dataset;\n-        \n-                try {\n-                    dataset = findDatasetOrDie(id);\n-                } catch (Exception ex) {\n-                    throw new IOException(ex.getMessage());\n-                }\n-                \n-                os.write(\"{\\\"dataFiles\\\": [\\n\".getBytes());\n-                \n-                boolean wroteObject = false;\n-                for (DataFile dataFile : dataset.getFiles()) {\n-                    // Potentially, there's a godzillion datasets in this Dataverse. \n-                    // This is why we go through the list of ids here, and instantiate \n-                    // only one dataset at a time. \n-                    boolean success = false;\n-                    boolean constraintViolationDetected = false;\n-                     \n-                    JsonObjectBuilder output = Json.createObjectBuilder();\n-                    output.add(\"datafileId\", dataFile.getId());\n-                    output.add(\"storageIdentifier\", dataFile.getStorageIdentifier());\n-\n-                    \n-                    try {\n-                        FileUtil.validateDataFileChecksum(dataFile);\n-                        success = true;\n-                    } catch (IOException ex) {\n-                        output.add(\"status\", \"invalid\");\n-                        output.add(\"errorMessage\", ex.getMessage());\n-                    }\n-                    \n-                    if (success) {\n-                        output.add(\"status\", \"valid\");\n-                    } \n-                    \n-                    // write it out:\n-                    \n-                    if (wroteObject) {\n-                        os.write(\",\\n\".getBytes());\n-                    }\n-\n-                    os.write(output.build().toString().getBytes(\"UTF8\"));\n-                    \n-                    if (!wroteObject) {\n-                        wroteObject = true;\n-                    }\n+              if (cause instanceof ConstraintViolationException) {\n+                ConstraintViolationException constraintViolationException = (ConstraintViolationException) cause;\n+                for (ConstraintViolation<?> constraintViolation : constraintViolationException\n+                  .getConstraintViolations()) {\n+                  String databaseRow = constraintViolation.getLeafBean().toString();\n+                  String field = constraintViolation.getPropertyPath().toString();\n+                  String invalidValue = null;\n+                  if (constraintViolation.getInvalidValue() != null) {\n+                    invalidValue = constraintViolation.getInvalidValue().toString();\n+                  }\n+                  output.add(\"status\", \"invalid\");\n+                  output.add(\"entityClassDatabaseTableRowId\", databaseRow);\n+                  output.add(\"field\", field);\n+                  output.add(\"invalidValue\", invalidValue == null ? \"NULL\" : invalidValue);\n+\n+                  constraintViolationDetected = true;\n+\n+                  break;\n+\n                 }\n-                \n-                os.write(\"\\n]\\n}\\n\".getBytes());\n-            }\n-            \n-        };\n-        return Response.ok(stream).build();\n-    }\n-\n-\t@Path(\"assignments/assignees/{raIdtf: .*}\")\n-\t@GET\n-\tpublic Response getAssignmentsFor(@PathParam(\"raIdtf\") String raIdtf) {\n-\n-\t\tJsonArrayBuilder arr = Json.createArrayBuilder();\n-\t\troleAssigneeSvc.getAssignmentsFor(raIdtf).forEach(a -> arr.add(json(a)));\n-\n-\t\treturn ok(arr);\n-\t}\n-\n-\t/**\n-\t * This method is used in integration tests.\n-\t *\n-\t * @param userId\n-\t *            The database id of an AuthenticatedUser.\n-\t * @return The confirm email token.\n-\t */\n-\t@Path(\"confirmEmail/{userId}\")\n-\t@GET\n-\tpublic Response getConfirmEmailToken(@PathParam(\"userId\") long userId) {\n-\t\tAuthenticatedUser user = authSvc.findByID(userId);\n-\t\tif (user != null) {\n-\t\t\tConfirmEmailData confirmEmailData = confirmEmailSvc.findSingleConfirmEmailDataByUser(user);\n-\t\t\tif (confirmEmailData != null) {\n-\t\t\t\treturn ok(Json.createObjectBuilder().add(\"token\", confirmEmailData.getToken()));\n-\t\t\t}\n-\t\t}\n-\t\treturn error(Status.BAD_REQUEST, \"Could not find confirm email token for user \" + userId);\n-\t}\n-\n-\t/**\n-\t * This method is used in integration tests.\n-\t *\n-\t * @param userId\n-\t *            The database id of an AuthenticatedUser.\n-\t */\n-\t@Path(\"confirmEmail/{userId}\")\n-\t@POST\n-\tpublic Response startConfirmEmailProcess(@PathParam(\"userId\") long userId) {\n-\t\tAuthenticatedUser user = authSvc.findByID(userId);\n-\t\tif (user != null) {\n-\t\t\ttry {\n-\t\t\t\tConfirmEmailInitResponse confirmEmailInitResponse = confirmEmailSvc.beginConfirm(user);\n-\t\t\t\tConfirmEmailData confirmEmailData = confirmEmailInitResponse.getConfirmEmailData();\n-\t\t\t\treturn ok(Json.createObjectBuilder().add(\"tokenCreated\", confirmEmailData.getCreated().toString())\n-\t\t\t\t\t\t.add(\"identifier\", user.getUserIdentifier()));\n-\t\t\t} catch (ConfirmEmailException ex) {\n-\t\t\t\treturn error(Status.BAD_REQUEST,\n-\t\t\t\t\t\t\"Could not start confirm email process for user \" + userId + \": \" + ex.getLocalizedMessage());\n-\t\t\t}\n-\t\t}\n-\t\treturn error(Status.BAD_REQUEST, \"Could not find user based on \" + userId);\n-\t}\n-\n-\t/**\n-\t * This method is used by an integration test in UsersIT.java to exercise bug\n-\t * https://github.com/IQSS/dataverse/issues/3287 . Not for use by users!\n-\t */\n-\t@Path(\"convertUserFromBcryptToSha1\")\n-\t@POST\n-\tpublic Response convertUserFromBcryptToSha1(String json) {\n-\t\tJsonReader jsonReader = Json.createReader(new StringReader(json));\n-\t\tJsonObject object = jsonReader.readObject();\n-\t\tjsonReader.close();\n-\t\tBuiltinUser builtinUser = builtinUserService.find(new Long(object.getInt(\"builtinUserId\")));\n-\t\tbuiltinUser.updateEncryptedPassword(\"4G7xxL9z11/JKN4jHPn4g9iIQck=\", 0); // password is \"sha-1Pass\", 0 means\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// SHA-1\n-\t\tBuiltinUser savedUser = builtinUserService.save(builtinUser);\n-\t\treturn ok(\"foo: \" + savedUser);\n-\n-\t}\n-\n-\t@Path(\"permissions/{dvo}\")\n-\t@GET\n-\tpublic Response findPermissonsOn(@PathParam(\"dvo\") String dvo) {\n-\t\ttry {\n-\t\t\tDvObject dvObj = findDvo(dvo);\n-\t\t\tif (dvObj == null) {\n-\t\t\t\treturn notFound(\"DvObject \" + dvo + \" not found\");\n-\t\t\t}\n-\t\t\ttry {\n-\t\t\t\tUser aUser = findUserOrDie();\n-\t\t\t\tJsonObjectBuilder bld = Json.createObjectBuilder();\n-\t\t\t\tbld.add(\"user\", aUser.getIdentifier());\n-\t\t\t\tbld.add(\"permissions\", json(permissionSvc.permissionsFor(createDataverseRequest(aUser), dvObj)));\n-\t\t\t\treturn ok(bld);\n-\n-\t\t\t} catch (WrappedResponse wr) {\n-\t\t\t\treturn wr.getResponse();\n-\t\t\t}\n-\t\t} catch (Exception e) {\n-\t\t\tlogger.log(Level.SEVERE, \"Error while testing permissions\", e);\n-\t\t\treturn error(Response.Status.INTERNAL_SERVER_ERROR, e.getMessage());\n-\t\t}\n-\t}\n-\n-\t@Path(\"assignee/{idtf}\")\n-\t@GET\n-\tpublic Response findRoleAssignee(@PathParam(\"idtf\") String idtf) {\n-\t\tRoleAssignee ra = roleAssigneeSvc.getRoleAssignee(idtf);\n-\t\treturn (ra == null) ? notFound(\"Role Assignee '\" + idtf + \"' not found.\") : ok(json(ra.getDisplayInfo()));\n-\t}\n-\n-\t@Path(\"datasets/integrity/{datasetVersionId}/fixmissingunf\")\n-\t@POST\n-\tpublic Response fixUnf(@PathParam(\"datasetVersionId\") String datasetVersionId,\n-\t\t\t@QueryParam(\"forceRecalculate\") boolean forceRecalculate) {\n-\t\tJsonObjectBuilder info = datasetVersionSvc.fixMissingUnf(datasetVersionId, forceRecalculate);\n-\t\treturn ok(info);\n-\t}\n-\n-\t@Path(\"datafiles/integrity/fixmissingoriginaltypes\")\n-\t@GET\n-\tpublic Response fixMissingOriginalTypes() {\n-\t\tJsonObjectBuilder info = Json.createObjectBuilder();\n-\n-\t\tList<Long> affectedFileIds = fileService.selectFilesWithMissingOriginalTypes();\n-\n-\t\tif (affectedFileIds.isEmpty()) {\n-\t\t\tinfo.add(\"message\",\n-\t\t\t\t\t\"All the tabular files in the database already have the original types set correctly; exiting.\");\n-\t\t} else {\n-\t\t\tfor (Long fileid : affectedFileIds) {\n-\t\t\t\tlogger.info(\"found file id: \" + fileid);\n-\t\t\t}\n-\t\t\tinfo.add(\"message\", \"Found \" + affectedFileIds.size()\n-\t\t\t\t\t+ \" tabular files with missing original types. Kicking off an async job that will repair the files in the background.\");\n-\t\t}\n-\n-\t\tingestService.fixMissingOriginalTypes(affectedFileIds);\n-\n-\t\treturn ok(info);\n-\t}\n-        \n-    @Path(\"datafiles/integrity/fixmissingoriginalsizes\")\n-    @GET\n-    public Response fixMissingOriginalSizes(@QueryParam(\"limit\") Integer limit) {\n-        JsonObjectBuilder info = Json.createObjectBuilder();\n-\n-        List<Long> affectedFileIds = fileService.selectFilesWithMissingOriginalSizes();\n-\n-        if (affectedFileIds.isEmpty()) {\n-            info.add(\"message\",\n-                    \"All the tabular files in the database already have the original sizes set correctly; exiting.\");\n-        } else {\n-            \n-            int howmany = affectedFileIds.size();\n-            String message = \"Found \" + howmany + \" tabular files with missing original sizes. \"; \n-            \n-            if (limit == null || howmany <= limit) {\n-                message = message.concat(\" Kicking off an async job that will repair the files in the background.\");\n-            } else {\n-                affectedFileIds.subList(limit, howmany-1).clear();\n-                message = message.concat(\" Kicking off an async job that will repair the \" + limit + \" files in the background.\");                        \n+              }\n+              cause = cause.getCause();\n             }\n-            info.add(\"message\", message);\n-        }\n+          }\n \n-        ingestService.fixMissingOriginalSizes(affectedFileIds);\n-        return ok(info);\n-    }\n-\n-\t/**\n-\t * This method is used in API tests, called from UtilIt.java.\n-\t */\n-\t@GET\n-\t@Path(\"datasets/thumbnailMetadata/{id}\")\n-\tpublic Response getDatasetThumbnailMetadata(@PathParam(\"id\") Long idSupplied) {\n-\t\tDataset dataset = datasetSvc.find(idSupplied);\n-\t\tif (dataset == null) {\n-\t\t\treturn error(Response.Status.NOT_FOUND, \"Could not find dataset based on id supplied: \" + idSupplied + \".\");\n-\t\t}\n-\t\tJsonObjectBuilder data = Json.createObjectBuilder();\n-\t\tDatasetThumbnail datasetThumbnail = dataset.getDatasetThumbnail(ImageThumbConverter.DEFAULT_CARDIMAGE_SIZE);\n-\t\tdata.add(\"isUseGenericThumbnail\", dataset.isUseGenericThumbnail());\n-\t\tdata.add(\"datasetLogoPresent\", DatasetUtil.isDatasetLogoPresent(dataset, ImageThumbConverter.DEFAULT_CARDIMAGE_SIZE));\n-\t\tif (datasetThumbnail != null) {\n-\t\t\tdata.add(\"datasetThumbnailBase64image\", datasetThumbnail.getBase64image());\n-\t\t\tDataFile dataFile = datasetThumbnail.getDataFile();\n-\t\t\tif (dataFile != null) {\n-\t\t\t\t/**\n-\t\t\t\t * @todo Change this from a String to a long.\n-\t\t\t\t */\n-\t\t\t\tdata.add(\"dataFileId\", dataFile.getId().toString());\n-\t\t\t}\n-\t\t}\n-\t\treturn ok(data);\n-\t}\n-\n-\t/**\n-\t * validatePassword\n-\t * <p>\n-\t * Validate a password with an API call\n-\t *\n-\t * @param password\n-\t *            The password\n-\t * @return A response with the validation result.\n-\t */\n-\t@Path(\"validatePassword\")\n-\t@POST\n-\tpublic Response validatePassword(String password) {\n-\n-\t\tfinal List<String> errors = passwordValidatorService.validate(password, new Date(), false);\n-\t\tfinal JsonArrayBuilder errorArray = Json.createArrayBuilder();\n-\t\terrors.forEach(errorArray::add);\n-\t\treturn ok(Json.createObjectBuilder().add(\"password\", password).add(\"errors\", errorArray));\n-\t}\n-\n-\t@GET\n-\t@Path(\"/isOrcid\")\n-\tpublic Response isOrcidEnabled() {\n-\t\treturn authSvc.isOrcidEnabled() ? ok(\"Orcid is enabled\") : ok(\"no orcid for you.\");\n-\t}\n-\n-    @POST\n-    @Path(\"{id}/reregisterHDLToPID\")\n-    public Response reregisterHdlToPID(@PathParam(\"id\") String id) {\n-        logger.info(\"Starting to reregister  \" + id + \" Dataset Id. (from hdl to doi)\" + new Date());\n-        try {\n-            if (settingsSvc.get(SettingsServiceBean.Key.Protocol.toString()).equals(GlobalId.HDL_PROTOCOL)) {\n-                logger.info(\"Bad Request protocol set to handle  \" );\n-                return error(Status.BAD_REQUEST, BundleUtil.getStringFromBundle(\"admin.api.migrateHDL.failure.must.be.set.for.doi\"));\n-            }\n-            \n-            User u = findUserOrDie();\n-            if (!u.isSuperuser()) {\n-                logger.info(\"Bad Request Unauthor \" );\n-                return error(Status.UNAUTHORIZED, BundleUtil.getStringFromBundle(\"admin.api.auth.mustBeSuperUser\"));\n-            }\n \n-            DataverseRequest r = createDataverseRequest(u);\n-            Dataset ds = findDatasetOrDie(id);\n-            if (ds.getIdentifier() != null && !ds.getIdentifier().isEmpty() && ds.getProtocol().equals(GlobalId.HDL_PROTOCOL)) {\n-                execCommand(new RegisterDvObjectCommand(r, ds, true));\n-            } else {\n-                return error(Status.BAD_REQUEST, BundleUtil.getStringFromBundle(\"admin.api.migrateHDL.failure.must.be.hdl.dataset\"));\n-            }\n+          if (success) {\n+            output.add(\"status\", \"valid\");\n+          } else if (!constraintViolationDetected) {\n+            output.add(\"status\", \"unknown\");\n+          }\n \n-        } catch (WrappedResponse r) {\n-            logger.info(\"Failed to migrate Dataset Handle id: \" + id);\n-            return badRequest(BundleUtil.getStringFromBundle(\"admin.api.migrateHDL.failure\", Arrays.asList(id)));\n-        } catch (Exception e) {\n-            logger.info(\"Failed to migrate Dataset Handle id: \" + id + \" Unexpected Exception \" + e.getMessage());\n-            List<String> args = Arrays.asList(id,e.getMessage());\n-            return badRequest(BundleUtil.getStringFromBundle(\"admin.api.migrateHDL.failureWithException\", args));\n+          // write it out:\n+\n+          if (wroteObject) {\n+            os.write(\",\\n\".getBytes());\n+          }\n+\n+          os.write(output.build().toString().getBytes(\"UTF8\"));\n+\n+          if (!wroteObject) {\n+            wroteObject = true;\n+          }\n         }\n-        \n-        return ok(BundleUtil.getStringFromBundle(\"admin.api.migrateHDL.success\"));\n-    }\n-\n-\t@GET\n-\t@Path(\"{id}/registerDataFile\")\n-\tpublic Response registerDataFile(@PathParam(\"id\") String id) {\n-\t\tlogger.info(\"Starting to register  \" + id + \" file id. \" + new Date());\n-\n-\t\ttry {\n-\t\t\tUser u = findUserOrDie();\n-\t\t\tDataverseRequest r = createDataverseRequest(u);\n-\t\t\tDataFile df = findDataFileOrDie(id);\n-\t\t\tif (df.getIdentifier() == null || df.getIdentifier().isEmpty()) {\n-\t\t\t\texecCommand(new RegisterDvObjectCommand(r, df));\n-\t\t\t} else {\n-\t\t\t\treturn ok(\"File was already registered. \");\n-\t\t\t}\n-\n-\t\t} catch (WrappedResponse r) {\n-\t\t\tlogger.info(\"Failed to register file id: \" + id);\n-\t\t} catch (Exception e) {\n-\t\t\tlogger.info(\"Failed to register file id: \" + id + \" Unexpecgted Exception \" + e.getMessage());\n-\t\t}\n-\t\treturn ok(\"Datafile registration complete. File registered successfully.\");\n-\t}\n-\n-\t@GET\n-\t@Path(\"/registerDataFileAll\")\n-\tpublic Response registerDataFileAll() {\n-\t\tInteger count = fileService.findAll().size();\n-\t\tInteger successes = 0;\n-\t\tInteger alreadyRegistered = 0;\n-\t\tInteger released = 0;\n-\t\tInteger draft = 0;\n-\t\tlogger.info(\"Starting to register: analyzing \" + count + \" files. \" + new Date());\n-\t\tlogger.info(\"Only unregistered, published files will be registered.\");\n-\t\tfor (DataFile df : fileService.findAll()) {\n-\t\t\ttry {\n-\t\t\t\tif ((df.getIdentifier() == null || df.getIdentifier().isEmpty())) {\n-\t\t\t\t\tif (df.isReleased()) {\n-\t\t\t\t\t\treleased++;\n-\t\t\t\t\t\tUser u = findAuthenticatedUserOrDie();\n-\t\t\t\t\t\tDataverseRequest r = createDataverseRequest(u);\n-\t\t\t\t\t\texecCommand(new RegisterDvObjectCommand(r, df));\n-\t\t\t\t\t\tsuccesses++;\n-\t\t\t\t\t\tif (successes % 100 == 0) {\n-\t\t\t\t\t\t\tlogger.info(successes + \" of  \" + count + \" files registered successfully. \" + new Date());\n-\t\t\t\t\t\t}\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tdraft++;\n-\t\t\t\t\t\tlogger.info(draft + \" of  \" + count + \" files not yet published\");\n-\t\t\t\t\t}\n-\t\t\t\t} else {\n-\t\t\t\t\talreadyRegistered++;\n-\t\t\t\t\tlogger.info(alreadyRegistered + \" of  \" + count + \" files are already registered. \" + new Date());\n-\t\t\t\t}\n-\t\t\t} catch (WrappedResponse ex) {\n-\t\t\t\treleased++;\n-\t\t\t\tlogger.info(\"Failed to register file id: \" + df.getId());\n-\t\t\t\tLogger.getLogger(Datasets.class.getName()).log(Level.SEVERE, null, ex);\n-\t\t\t} catch (Exception e) {\n-\t\t\t\tlogger.info(\"Unexpected Exception: \" + e.getMessage());\n-\t\t\t}\n-\t\t}\n-\t\tlogger.info(\"Final Results:\");\n-\t\tlogger.info(alreadyRegistered + \" of  \" + count + \" files were already registered. \" + new Date());\n-\t\tlogger.info(draft + \" of  \" + count + \" files are not yet published. \" + new Date());\n-\t\tlogger.info(released + \" of  \" + count + \" unregistered, published files to register. \" + new Date());\n-\t\tlogger.info(successes + \" of  \" + released + \" unregistered, published files registered successfully. \"\n-\t\t\t\t+ new Date());\n-\n-\t\treturn ok(\"Datafile registration complete.\" + successes + \" of  \" + released\n-\t\t\t\t+ \" unregistered, published files registered successfully.\");\n-\t}\n-\n-\t@GET\n-\t@Path(\"/updateHashValues/{alg}\")\n-\tpublic Response updateHashValues(@PathParam(\"alg\") String alg, @QueryParam(\"num\") int num) {\n-\t\tInteger count = fileService.findAll().size();\n-\t\tInteger successes = 0;\n-\t\tInteger alreadyUpdated = 0;\n-\t\tInteger rehashed = 0;\n-\t\tInteger harvested=0;\n-\t\t\n-\t\tif (num <= 0)\n-\t\t\tnum = Integer.MAX_VALUE;\n-\t\tDataFile.ChecksumType cType = null;\n-\t\ttry {\n-\t\t\tcType = DataFile.ChecksumType.fromString(alg);\n-\t\t} catch (IllegalArgumentException iae) {\n-\t\t\treturn error(Status.BAD_REQUEST, \"Unknown algorithm\");\n-\t\t}\n-\t\tlogger.info(\"Starting to rehash: analyzing \" + count + \" files. \" + new Date());\n-\t\tlogger.info(\"Hashes not created with \" + alg + \" will be verified, and, if valid, replaced with a hash using \"\n-\t\t\t\t+ alg);\n-\t\ttry {\n-\t\t\tUser u = findAuthenticatedUserOrDie();\n-\t\t\tif (!u.isSuperuser())\n-\t\t\t\treturn error(Status.UNAUTHORIZED, \"must be superuser\");\n-\t\t} catch (WrappedResponse e1) {\n-\t\t\treturn error(Status.UNAUTHORIZED, \"api key required\");\n-\t\t}\n-\n-\t\tfor (DataFile df : fileService.findAll()) {\n-\t\t\tif (rehashed.intValue() >= num)\n-\t\t\t\tbreak;\n-\t\t\tInputStream in = null;\n-\t\t\tInputStream in2 = null; \n-\t\t\ttry {\n-\t\t\t\tif (df.isHarvested()) {\n-\t\t\t\t\tharvested++;\n-\t\t\t\t} else {\n-\t\t\t\t\tif (!df.getChecksumType().equals(cType)) {\n-\n-\t\t\t\t\t\trehashed++;\n-\t\t\t\t\t\tlogger.fine(rehashed + \": Datafile: \" + df.getFileMetadata().getLabel() + \", \"\n-\t\t\t\t\t\t\t\t+ df.getIdentifier());\n-\t\t\t\t\t\t// verify hash and calc new one to replace it\n-\t\t\t\t\t\tStorageIO<DataFile> storage = df.getStorageIO();\n-\t\t\t\t\t\tstorage.open(DataAccessOption.READ_ACCESS);\n-\t\t\t\t\t\tif (!df.isTabularData()) {\n-\t\t\t\t\t\t\tin = storage.getInputStream();\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t// if this is a tabular file, read the preserved original \"auxiliary file\"\n-\t\t\t\t\t\t\t// instead:\n-\t\t\t\t\t\t\tin = storage.getAuxFileAsInputStream(FileUtil.SAVED_ORIGINAL_FILENAME_EXTENSION);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tif (in == null)\n-\t\t\t\t\t\t\tlogger.warning(\"Cannot retrieve file.\");\n-\t\t\t\t\t\tString currentChecksum = FileUtil.calculateChecksum(in, df.getChecksumType());\n-\t\t\t\t\t\tif (currentChecksum.equals(df.getChecksumValue())) {\n-\t\t\t\t\t\t\tlogger.fine(\"Current checksum for datafile: \" + df.getFileMetadata().getLabel() + \", \"\n-\t\t\t\t\t\t\t\t\t+ df.getIdentifier() + \" is valid\");\n-\t\t\t\t\t\t\tstorage.open(DataAccessOption.READ_ACCESS);\n-\t\t\t\t\t\t\tif (!df.isTabularData()) {\n-\t\t\t\t\t\t\t\tin2 = storage.getInputStream();\n-\t\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t\t// if this is a tabular file, read the preserved original \"auxiliary file\"\n-\t\t\t\t\t\t\t\t// instead:\n-\t\t\t\t\t\t\t\tin2 = storage.getAuxFileAsInputStream(FileUtil.SAVED_ORIGINAL_FILENAME_EXTENSION);\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tif (in2 == null)\n-\t\t\t\t\t\t\t\tlogger.warning(\"Cannot retrieve file to calculate new checksum.\");\n-\t\t\t\t\t\t\tString newChecksum = FileUtil.calculateChecksum(in2, cType);\n-\n-\t\t\t\t\t\t\tdf.setChecksumType(cType);\n-\t\t\t\t\t\t\tdf.setChecksumValue(newChecksum);\n-\t\t\t\t\t\t\tsuccesses++;\n-\t\t\t\t\t\t\tif (successes % 100 == 0) {\n-\t\t\t\t\t\t\t\tlogger.info(\n-\t\t\t\t\t\t\t\t\t\tsuccesses + \" of  \" + count + \" files rehashed successfully. \" + new Date());\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tlogger.warning(\"Problem: Current checksum for datafile: \" + df.getFileMetadata().getLabel()\n-\t\t\t\t\t\t\t\t\t+ \", \" + df.getIdentifier() + \" is INVALID\");\n-\t\t\t\t\t\t}\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\talreadyUpdated++;\n-\t\t\t\t\t\tif (alreadyUpdated % 100 == 0) {\n-\t\t\t\t\t\t\tlogger.info(alreadyUpdated + \" of  \" + count\n-\t\t\t\t\t\t\t\t\t+ \" files are already have hashes with the new algorithm. \" + new Date());\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t} catch (Exception e) {\n-\t\t\t\tlogger.warning(\"Unexpected Exception: \" + e.getMessage());\n-\n-\t\t\t} finally {\n-\t\t\t\tIOUtils.closeQuietly(in);\n-\t\t\t\tIOUtils.closeQuietly(in2);\n-\t\t\t}\n-\t\t}\n-\t\tlogger.info(\"Final Results:\");\n-\t\tlogger.info(harvested + \" harvested files skipped.\");\n-\t\tlogger.info(\n-\t\t\t\talreadyUpdated + \" of  \" + count + \" files already had hashes with the new algorithm. \" + new Date());\n-\t\tlogger.info(rehashed + \" of  \" + count + \" files to rehash. \" + new Date());\n-\t\tlogger.info(\n-\t\t\t\tsuccesses + \" of  \" + rehashed + \" files successfully rehashed with the new algorithm. \" + new Date());\n-\n-\t\treturn ok(\"Datafile rehashing complete.\" + successes + \" of  \" + rehashed + \" files successfully rehashed.\");\n-\t}\n-        \n-    @POST\n-    @Path(\"/computeDataFileHashValue/{fileId}/algorithm/{alg}\")\n-    public Response computeDataFileHashValue(@PathParam(\"fileId\") String fileId, @PathParam(\"alg\") String alg) {\n \n-        try {\n-            User u = findAuthenticatedUserOrDie();\n-            if (!u.isSuperuser()) {\n-                return error(Status.UNAUTHORIZED, \"must be superuser\");\n+\n+        os.write(\"\\n]\\n}\\n\".getBytes());\n+      }\n+\n+    };\n+    return Response.ok(stream).build();\n+  }\n+\n+  @Path(\"validate/dataset/{id}\")\n+  @GET\n+  public Response validateDataset(@PathParam(\"id\") String id, @QueryParam(\"variables\") boolean includeVariables) {\n+    Dataset dataset;\n+    try {\n+      dataset = findDatasetOrDie(id);\n+    } catch (Exception ex) {\n+      return error(Response.Status.NOT_FOUND, \"No Such Dataset\");\n+    }\n+\n+    Long dbId = dataset.getId();\n+\n+    String msg = \"unknown\";\n+    try {\n+      datasetService.instantiateDatasetInNewTransaction(dbId, includeVariables);\n+      msg = \"valid\";\n+    } catch (Exception ex) {\n+      Throwable cause = ex;\n+      while (cause != null) {\n+        if (cause instanceof ConstraintViolationException) {\n+          ConstraintViolationException constraintViolationException = (ConstraintViolationException) cause;\n+          for (ConstraintViolation<?> constraintViolation : constraintViolationException\n+            .getConstraintViolations()) {\n+            String databaseRow = constraintViolation.getLeafBean().toString();\n+            String field = constraintViolation.getPropertyPath().toString();\n+            String invalidValue = null;\n+            if (constraintViolation.getInvalidValue() != null) {\n+              invalidValue = constraintViolation.getInvalidValue().toString();\n             }\n-        } catch (WrappedResponse e1) {\n-            return error(Status.UNAUTHORIZED, \"api key required\");\n+            JsonObjectBuilder violation = Json.createObjectBuilder();\n+            violation.add(\"entityClassDatabaseTableRowId\", databaseRow);\n+            violation.add(\"field\", field);\n+            violation.add(\"invalidValue\", invalidValue == null ? \"NULL\" : invalidValue);\n+            return ok(violation);\n+          }\n         }\n+        cause = cause.getCause();\n+      }\n+    }\n+    return ok(msg);\n+  }\n+\n+  // This API does the same thing as /validateDataFileHashValue/{fileId},\n+  // but for all the files in the dataset, with streaming output.\n+  @GET\n+  @Path(\"validate/dataset/files/{id}\")\n+  @Produces({\"application/json\"})\n+  public Response validateDatasetDatafiles(@PathParam(\"id\") String id) {\n+\n+    // Streaming output: the API will start producing\n+    // the output right away, as it goes through the list\n+    // of the datafiles in the dataset.\n+    // The streaming mechanism is modeled after validate/datasets API.\n+    StreamingOutput stream = new StreamingOutput() {\n+\n+      @Override\n+      public void write(OutputStream os) throws IOException,\n+        WebApplicationException {\n+        Dataset dataset;\n \n-        DataFile fileToUpdate = null;\n         try {\n-            fileToUpdate = findDataFileOrDie(fileId);\n-        } catch (WrappedResponse r) {\n-            logger.info(\"Could not find file with the id: \" + fileId);\n-            return error(Status.BAD_REQUEST, \"Could not find file with the id: \" + fileId);\n+          dataset = findDatasetOrDie(id);\n+        } catch (Exception ex) {\n+          throw new IOException(ex.getMessage());\n         }\n \n-        if (fileToUpdate.isHarvested()) {\n-            return error(Status.BAD_REQUEST, \"File with the id: \" + fileId + \" is harvested.\");\n-        }\n+        os.write(\"{\\\"dataFiles\\\": [\\n\".getBytes());\n \n-        DataFile.ChecksumType cType = null;\n-        try {\n-            cType = DataFile.ChecksumType.fromString(alg);\n-        } catch (IllegalArgumentException iae) {\n-            return error(Status.BAD_REQUEST, \"Unknown algorithm: \" + alg);\n-        }\n+        boolean wroteObject = false;\n+        for (DataFile dataFile : dataset.getFiles()) {\n+          // Potentially, there's a godzillion datasets in this Dataverse.\n+          // This is why we go through the list of ids here, and instantiate\n+          // only one dataset at a time.\n+          boolean success = false;\n+          boolean constraintViolationDetected = false;\n \n-        String newChecksum = \"\";\n+          JsonObjectBuilder output = Json.createObjectBuilder();\n+          output.add(\"datafileId\", dataFile.getId());\n+          output.add(\"storageIdentifier\", dataFile.getStorageIdentifier());\n \n-        InputStream in = null;\n-        try {\n \n-            StorageIO<DataFile> storage = fileToUpdate.getStorageIO();\n-            storage.open(DataAccessOption.READ_ACCESS);\n-            if (!fileToUpdate.isTabularData()) {\n-                in = storage.getInputStream();\n-            } else {\n-                in = storage.getAuxFileAsInputStream(FileUtil.SAVED_ORIGINAL_FILENAME_EXTENSION);\n-            }\n-            if (in == null) {\n-                return error(Status.NOT_FOUND, \"Could not retrieve file with the id: \" + fileId);\n-            }\n-            newChecksum = FileUtil.calculateChecksum(in, cType);\n-            fileToUpdate.setChecksumType(cType);\n-            fileToUpdate.setChecksumValue(newChecksum);\n+          try {\n+            FileUtil.validateDataFileChecksum(dataFile);\n+            success = true;\n+          } catch (IOException ex) {\n+            output.add(\"status\", \"invalid\");\n+            output.add(\"errorMessage\", ex.getMessage());\n+          }\n+\n+          if (success) {\n+            output.add(\"status\", \"valid\");\n+          }\n+\n+          // write it out:\n+\n+          if (wroteObject) {\n+            os.write(\",\\n\".getBytes());\n+          }\n \n-        } catch (Exception e) {\n-            logger.warning(\"Unexpected Exception: \" + e.getMessage());\n+          os.write(output.build().toString().getBytes(\"UTF8\"));\n \n-        } finally {\n-            IOUtils.closeQuietly(in);\n+          if (!wroteObject) {\n+            wroteObject = true;\n+          }\n         }\n \n-        return ok(\"Datafile rehashing complete. \" + fileId + \"  successfully rehashed. New hash value is: \" + newChecksum);\n+        os.write(\"\\n]\\n}\\n\".getBytes());\n+      }\n+\n+    };\n+    return Response.ok(stream).build();\n+  }\n+\n+  @Path(\"assignments/assignees/{raIdtf: .*}\")\n+  @GET\n+  public Response getAssignmentsFor(@PathParam(\"raIdtf\") String raIdtf) {\n+\n+    JsonArrayBuilder arr = Json.createArrayBuilder();\n+    roleAssigneeSvc.getAssignmentsFor(raIdtf).forEach(a -> arr.add(json(a)));\n+\n+    return ok(arr);\n+  }\n+\n+  /**\n+   * This method is used in integration tests.\n+   *\n+   * @param userId The database id of an AuthenticatedUser.\n+   * @return The confirm email token.\n+   */\n+  @Path(\"confirmEmail/{userId}\")\n+  @GET\n+  public Response getConfirmEmailToken(@PathParam(\"userId\") long userId) {\n+    AuthenticatedUser user = authSvc.findByID(userId);\n+    if (user != null) {\n+      ConfirmEmailData confirmEmailData = confirmEmailSvc.findSingleConfirmEmailDataByUser(user);\n+      if (confirmEmailData != null) {\n+        return ok(Json.createObjectBuilder().add(\"token\", confirmEmailData.getToken()));\n+      }\n+    }\n+    return error(Status.BAD_REQUEST, \"Could not find confirm email token for user \" + userId);\n+  }\n+\n+  /**\n+   * This method is used in integration tests.\n+   *\n+   * @param userId The database id of an AuthenticatedUser.\n+   */\n+  @Path(\"confirmEmail/{userId}\")\n+  @POST\n+  public Response startConfirmEmailProcess(@PathParam(\"userId\") long userId) {\n+    AuthenticatedUser user = authSvc.findByID(userId);\n+    if (user != null) {\n+      try {\n+        ConfirmEmailInitResponse confirmEmailInitResponse = confirmEmailSvc.beginConfirm(user);\n+        ConfirmEmailData confirmEmailData = confirmEmailInitResponse.getConfirmEmailData();\n+        return ok(Json.createObjectBuilder().add(\"tokenCreated\", confirmEmailData.getCreated().toString())\n+          .add(\"identifier\", user.getUserIdentifier()));\n+      } catch (ConfirmEmailException ex) {\n+        return error(Status.BAD_REQUEST,\n+          \"Could not start confirm email process for user \" + userId + \": \" + ex.getLocalizedMessage());\n+      }\n+    }\n+    return error(Status.BAD_REQUEST, \"Could not find user based on \" + userId);\n+  }\n+\n+  /**\n+   * This method is used by an integration test in UsersIT.java to exercise bug\n+   * https://github.com/IQSS/dataverse/issues/3287 . Not for use by users!\n+   */\n+  @Path(\"convertUserFromBcryptToSha1\")\n+  @POST\n+  public Response convertUserFromBcryptToSha1(String json) {\n+    JsonReader jsonReader = Json.createReader(new StringReader(json));\n+    JsonObject object = jsonReader.readObject();\n+    jsonReader.close();\n+    BuiltinUser builtinUser = builtinUserService.find(new Long(object.getInt(\"builtinUserId\")));\n+    builtinUser.updateEncryptedPassword(\"4G7xxL9z11/JKN4jHPn4g9iIQck=\", 0); // password is \"sha-1Pass\", 0 means\n+    // SHA-1\n+    BuiltinUser savedUser = builtinUserService.save(builtinUser);\n+    return ok(\"foo: \" + savedUser);\n+\n+  }\n+\n+  @Path(\"permissions/{dvo}\")\n+  @GET\n+  public Response findPermissonsOn(@PathParam(\"dvo\") String dvo) {\n+    try {\n+      DvObject dvObj = findDvo(dvo);\n+      if (dvObj == null) {\n+        return notFound(\"DvObject \" + dvo + \" not found\");\n+      }\n+      try {\n+        User aUser = findUserOrDie();\n+        JsonObjectBuilder bld = Json.createObjectBuilder();\n+        bld.add(\"user\", aUser.getIdentifier());\n+        bld.add(\"permissions\", json(permissionSvc.permissionsFor(createDataverseRequest(aUser), dvObj)));\n+        return ok(bld);\n+\n+      } catch (WrappedResponse wr) {\n+        return wr.getResponse();\n+      }\n+    } catch (Exception e) {\n+      logger.log(Level.SEVERE, \"Error while testing permissions\", e);\n+      return error(Response.Status.INTERNAL_SERVER_ERROR, e.getMessage());\n+    }\n+  }\n+\n+  @Path(\"assignee/{idtf}\")\n+  @GET\n+  public Response findRoleAssignee(@PathParam(\"idtf\") String idtf) {\n+    RoleAssignee ra = roleAssigneeSvc.getRoleAssignee(idtf);\n+    return (ra == null) ? notFound(\"Role Assignee '\" + idtf + \"' not found.\") : ok(json(ra.getDisplayInfo()));\n+  }\n+\n+  @Path(\"datasets/integrity/{datasetVersionId}/fixmissingunf\")\n+  @POST\n+  public Response fixUnf(@PathParam(\"datasetVersionId\") String datasetVersionId,\n+                         @QueryParam(\"forceRecalculate\") boolean forceRecalculate) {\n+    JsonObjectBuilder info = datasetVersionSvc.fixMissingUnf(datasetVersionId, forceRecalculate);\n+    return ok(info);\n+  }\n+\n+  @Path(\"datafiles/integrity/fixmissingoriginaltypes\")\n+  @GET\n+  public Response fixMissingOriginalTypes() {\n+    JsonObjectBuilder info = Json.createObjectBuilder();\n+\n+    List<Long> affectedFileIds = fileService.selectFilesWithMissingOriginalTypes();\n+\n+    if (affectedFileIds.isEmpty()) {\n+      info.add(\"message\",\n+        \"All the tabular files in the database already have the original types set correctly; exiting.\");\n+    } else {\n+      for (Long fileid : affectedFileIds) {\n+        logger.info(\"found file id: \" + fileid);\n+      }\n+      info.add(\"message\", \"Found \" + affectedFileIds.size()\n+        +\n+        \" tabular files with missing original types. Kicking off an async job that will repair the files in the background.\");\n     }\n-    \n-    @POST\n-    @Path(\"/validateDataFileHashValue/{fileId}\")\n-    public Response validateDataFileHashValue(@PathParam(\"fileId\") String fileId) {\n \n-        try {\n-            User u = findAuthenticatedUserOrDie();\n-            if (!u.isSuperuser()) {\n-                return error(Status.UNAUTHORIZED, \"must be superuser\");\n-            }\n-        } catch (WrappedResponse e1) {\n-            return error(Status.UNAUTHORIZED, \"api key required\");\n-        }\n+    ingestService.fixMissingOriginalTypes(affectedFileIds);\n \n-        DataFile fileToValidate = null;\n-        try {\n-            fileToValidate = findDataFileOrDie(fileId);\n-        } catch (WrappedResponse r) {\n-            logger.info(\"Could not find file with the id: \" + fileId);\n-            return error(Status.BAD_REQUEST, \"Could not find file with the id: \" + fileId);\n-        }\n+    return ok(info);\n+  }\n \n-        if (fileToValidate.isHarvested()) {\n-            return error(Status.BAD_REQUEST, \"File with the id: \" + fileId + \" is harvested.\");\n-        }\n+  @Path(\"datafiles/integrity/fixmissingoriginalsizes\")\n+  @GET\n+  public Response fixMissingOriginalSizes(@QueryParam(\"limit\") Integer limit) {\n+    JsonObjectBuilder info = Json.createObjectBuilder();\n \n-        DataFile.ChecksumType cType = null;\n-        try {\n-            String checkSumTypeFromDataFile = fileToValidate.getChecksumType().toString();\n-            cType = DataFile.ChecksumType.fromString(checkSumTypeFromDataFile);\n-        } catch (IllegalArgumentException iae) {\n-            return error(Status.BAD_REQUEST, \"Unknown algorithm\");\n+    List<Long> affectedFileIds = fileService.selectFilesWithMissingOriginalSizes();\n+\n+    if (affectedFileIds.isEmpty()) {\n+      info.add(\"message\",\n+        \"All the tabular files in the database already have the original sizes set correctly; exiting.\");\n+    } else {\n+\n+      int howmany = affectedFileIds.size();\n+      String message = \"Found \" + howmany + \" tabular files with missing original sizes. \";\n+\n+      if (limit == null || howmany <= limit) {\n+        message = message.concat(\" Kicking off an async job that will repair the files in the background.\");\n+      } else {\n+        affectedFileIds.subList(limit, howmany - 1).clear();\n+        message =\n+          message.concat(\" Kicking off an async job that will repair the \" + limit + \" files in the background.\");\n+      }\n+      info.add(\"message\", message);\n+    }\n+\n+    ingestService.fixMissingOriginalSizes(affectedFileIds);\n+    return ok(info);\n+  }\n+\n+  /**\n+   * This method is used in API tests, called from UtilIt.java.\n+   */\n+  @GET\n+  @Path(\"datasets/thumbnailMetadata/{id}\")\n+  public Response getDatasetThumbnailMetadata(@PathParam(\"id\") Long idSupplied) {\n+    Dataset dataset = datasetSvc.find(idSupplied);\n+    if (dataset == null) {\n+      return error(Response.Status.NOT_FOUND, \"Could not find dataset based on id supplied: \" + idSupplied + \".\");\n+    }\n+    JsonObjectBuilder data = Json.createObjectBuilder();\n+    DatasetThumbnail datasetThumbnail = dataset.getDatasetThumbnail(ImageThumbConverter.DEFAULT_CARDIMAGE_SIZE);\n+    data.add(\"isUseGenericThumbnail\", dataset.isUseGenericThumbnail());\n+    data\n+      .add(\"datasetLogoPresent\", DatasetUtil.isDatasetLogoPresent(dataset, ImageThumbConverter.DEFAULT_CARDIMAGE_SIZE));\n+    if (datasetThumbnail != null) {\n+      data.add(\"datasetThumbnailBase64image\", datasetThumbnail.getBase64image());\n+      DataFile dataFile = datasetThumbnail.getDataFile();\n+      if (dataFile != null) {\n+        /**\n+         * @todo Change this from a String to a long.\n+         */\n+        data.add(\"dataFileId\", dataFile.getId().toString());\n+      }\n+    }\n+    return ok(data);\n+  }\n+\n+  /**\n+   * validatePassword\n+   * <p>\n+   * Validate a password with an API call\n+   *\n+   * @param password The password\n+   * @return A response with the validation result.\n+   */\n+  @Path(\"validatePassword\")\n+  @POST\n+  public Response validatePassword(String password) {\n+\n+    final List<String> errors = passwordValidatorService.validate(password, new Date(), false);\n+    final JsonArrayBuilder errorArray = Json.createArrayBuilder();\n+    errors.forEach(errorArray::add);\n+    return ok(Json.createObjectBuilder().add(\"password\", password).add(\"errors\", errorArray));\n+  }\n+\n+  @GET\n+  @Path(\"/isOrcid\")\n+  public Response isOrcidEnabled() {\n+    return authSvc.isOrcidEnabled() ? ok(\"Orcid is enabled\") : ok(\"no orcid for you.\");\n+  }\n+\n+  @POST\n+  @Path(\"{id}/reregisterHDLToPID\")\n+  public Response reregisterHdlToPID(@PathParam(\"id\") String id) {\n+    logger.info(\"Starting to reregister  \" + id + \" Dataset Id. (from hdl to doi)\" + new Date());\n+    try {\n+      if (settingsSvc.get(SettingsServiceBean.Key.Protocol.toString()).equals(GlobalId.HDL_PROTOCOL)) {\n+        logger.info(\"Bad Request protocol set to handle  \");\n+        return error(Status.BAD_REQUEST,\n+          BundleUtil.getStringFromBundle(\"admin.api.migrateHDL.failure.must.be.set.for.doi\"));\n+      }\n+\n+      User u = findUserOrDie();\n+      if (!u.isSuperuser()) {\n+        logger.info(\"Bad Request Unauthor \");\n+        return error(Status.UNAUTHORIZED, BundleUtil.getStringFromBundle(\"admin.api.auth.mustBeSuperUser\"));\n+      }\n+\n+      DataverseRequest r = createDataverseRequest(u);\n+      Dataset ds = findDatasetOrDie(id);\n+      if (ds.getIdentifier() != null && !ds.getIdentifier().isEmpty() &&\n+        ds.getProtocol().equals(GlobalId.HDL_PROTOCOL)) {\n+        execCommand(new RegisterDvObjectCommand(r, ds, true));\n+      } else {\n+        return error(Status.BAD_REQUEST,\n+          BundleUtil.getStringFromBundle(\"admin.api.migrateHDL.failure.must.be.hdl.dataset\"));\n+      }\n+\n+    } catch (WrappedResponse r) {\n+      logger.info(\"Failed to migrate Dataset Handle id: \" + id);\n+      return badRequest(BundleUtil.getStringFromBundle(\"admin.api.migrateHDL.failure\", Arrays.asList(id)));\n+    } catch (Exception e) {\n+      logger.info(\"Failed to migrate Dataset Handle id: \" + id + \" Unexpected Exception \" + e.getMessage());\n+      List<String> args = Arrays.asList(id, e.getMessage());\n+      return badRequest(BundleUtil.getStringFromBundle(\"admin.api.migrateHDL.failureWithException\", args));\n+    }\n+\n+    return ok(BundleUtil.getStringFromBundle(\"admin.api.migrateHDL.success\"));\n+  }\n+\n+  @GET\n+  @Path(\"{id}/registerDataFile\")\n+  public Response registerDataFile(@PathParam(\"id\") String id) {\n+    logger.info(\"Starting to register  \" + id + \" file id. \" + new Date());\n+\n+    try {\n+      User u = findUserOrDie();\n+      DataverseRequest r = createDataverseRequest(u);\n+      DataFile df = findDataFileOrDie(id);\n+      if (df.getIdentifier() == null || df.getIdentifier().isEmpty()) {\n+        execCommand(new RegisterDvObjectCommand(r, df));\n+      } else {\n+        return ok(\"File was already registered. \");\n+      }\n+\n+    } catch (WrappedResponse r) {\n+      logger.info(\"Failed to register file id: \" + id);\n+    } catch (Exception e) {\n+      logger.info(\"Failed to register file id: \" + id + \" Unexpecgted Exception \" + e.getMessage());\n+    }\n+    return ok(\"Datafile registration complete. File registered successfully.\");\n+  }\n+\n+  @GET\n+  @Path(\"/registerDataFileAll\")\n+  public Response registerDataFileAll() {\n+    Integer count = fileService.findAll().size();\n+    Integer successes = 0;\n+    Integer alreadyRegistered = 0;\n+    Integer released = 0;\n+    Integer draft = 0;\n+    logger.info(\"Starting to register: analyzing \" + count + \" files. \" + new Date());\n+    logger.info(\"Only unregistered, published files will be registered.\");\n+    for (DataFile df : fileService.findAll()) {\n+      try {\n+        if ((df.getIdentifier() == null || df.getIdentifier().isEmpty())) {\n+          if (df.isReleased()) {\n+            released++;\n+            User u = findAuthenticatedUserOrDie();\n+            DataverseRequest r = createDataverseRequest(u);\n+            execCommand(new RegisterDvObjectCommand(r, df));\n+            successes++;\n+            if (successes % 100 == 0) {\n+              logger.info(successes + \" of  \" + count + \" files registered successfully. \" + new Date());\n+            }\n+          } else {\n+            draft++;\n+            logger.info(draft + \" of  \" + count + \" files not yet published\");\n+          }\n+        } else {\n+          alreadyRegistered++;\n+          logger.info(alreadyRegistered + \" of  \" + count + \" files are already registered. \" + new Date());\n         }\n+      } catch (WrappedResponse ex) {\n+        released++;\n+        logger.info(\"Failed to register file id: \" + df.getId());\n+        Logger.getLogger(Datasets.class.getName()).log(Level.SEVERE, null, ex);\n+      } catch (Exception e) {\n+        logger.info(\"Unexpected Exception: \" + e.getMessage());\n+      }\n+    }\n+    logger.info(\"Final Results:\");\n+    logger.info(alreadyRegistered + \" of  \" + count + \" files were already registered. \" + new Date());\n+    logger.info(draft + \" of  \" + count + \" files are not yet published. \" + new Date());\n+    logger.info(released + \" of  \" + count + \" unregistered, published files to register. \" + new Date());\n+    logger.info(successes + \" of  \" + released + \" unregistered, published files registered successfully. \"\n+      + new Date());\n+\n+    return ok(\"Datafile registration complete.\" + successes + \" of  \" + released\n+      + \" unregistered, published files registered successfully.\");\n+  }\n+\n+  @GET\n+  @Path(\"/updateHashValues/{alg}\")\n+  public Response updateHashValues(@PathParam(\"alg\") String alg, @QueryParam(\"num\") int num) {\n+    Integer count = fileService.findAll().size();\n+    Integer successes = 0;\n+    Integer alreadyUpdated = 0;\n+    Integer rehashed = 0;\n+    Integer harvested = 0;\n+\n+    if (num <= 0) {\n+      num = Integer.MAX_VALUE;\n+    }\n+    DataFile.ChecksumType cType = null;\n+    try {\n+      cType = DataFile.ChecksumType.fromString(alg);\n+    } catch (IllegalArgumentException iae) {\n+      return error(Status.BAD_REQUEST, \"Unknown algorithm\");\n+    }\n+    logger.info(\"Starting to rehash: analyzing \" + count + \" files. \" + new Date());\n+    logger.info(\"Hashes not created with \" + alg + \" will be verified, and, if valid, replaced with a hash using \"\n+      + alg);\n+    try {\n+      User u = findAuthenticatedUserOrDie();\n+      if (!u.isSuperuser()) {\n+        return error(Status.UNAUTHORIZED, \"must be superuser\");\n+      }\n+    } catch (WrappedResponse e1) {\n+      return error(Status.UNAUTHORIZED, \"api key required\");\n+    }\n \n-        String currentChecksum = fileToValidate.getChecksumValue();\n-        String calculatedChecksum = \"\";\n-        InputStream in = null;\n-        try {\n+    for (DataFile df : fileService.findAll()) {\n+      if (rehashed.intValue() >= num) {\n+        break;\n+      }\n+      InputStream in = null;\n+      InputStream in2 = null;\n+      try {\n+        if (df.isHarvested()) {\n+          harvested++;\n+        } else {\n+          if (!df.getChecksumType().equals(cType)) {\n \n-            StorageIO<DataFile> storage = fileToValidate.getStorageIO();\n+            rehashed++;\n+            logger.fine(rehashed + \": Datafile: \" + df.getFileMetadata().getLabel() + \", \"\n+              + df.getIdentifier());\n+            // verify hash and calc new one to replace it\n+            StorageIO<DataFile> storage = df.getStorageIO();\n             storage.open(DataAccessOption.READ_ACCESS);\n-            if (!fileToValidate.isTabularData()) {\n-                in = storage.getInputStream();\n+            if (!df.isTabularData()) {\n+              in = storage.getInputStream();\n             } else {\n-                in = storage.getAuxFileAsInputStream(FileUtil.SAVED_ORIGINAL_FILENAME_EXTENSION);\n+              // if this is a tabular file, read the preserved original \"auxiliary file\"\n+              // instead:\n+              in = storage.getAuxFileAsInputStream(FileUtil.SAVED_ORIGINAL_FILENAME_EXTENSION);\n             }\n             if (in == null) {\n-                return error(Status.NOT_FOUND, \"Could not retrieve file with the id: \" + fileId);\n+              logger.warning(\"Cannot retrieve file.\");\n             }\n-            calculatedChecksum = FileUtil.calculateChecksum(in, cType);\n+            String currentChecksum = FileUtil.calculateChecksum(in, df.getChecksumType());\n+            if (currentChecksum.equals(df.getChecksumValue())) {\n+              logger.fine(\"Current checksum for datafile: \" + df.getFileMetadata().getLabel() + \", \"\n+                + df.getIdentifier() + \" is valid\");\n+              storage.open(DataAccessOption.READ_ACCESS);\n+              if (!df.isTabularData()) {\n+                in2 = storage.getInputStream();\n+              } else {\n+                // if this is a tabular file, read the preserved original \"auxiliary file\"\n+                // instead:\n+                in2 = storage.getAuxFileAsInputStream(FileUtil.SAVED_ORIGINAL_FILENAME_EXTENSION);\n+              }\n+              if (in2 == null) {\n+                logger.warning(\"Cannot retrieve file to calculate new checksum.\");\n+              }\n+              String newChecksum = FileUtil.calculateChecksum(in2, cType);\n+\n+              df.setChecksumType(cType);\n+              df.setChecksumValue(newChecksum);\n+              successes++;\n+              if (successes % 100 == 0) {\n+                logger.info(\n+                  successes + \" of  \" + count + \" files rehashed successfully. \" + new Date());\n+              }\n+            } else {\n+              logger.warning(\"Problem: Current checksum for datafile: \" + df.getFileMetadata().getLabel()\n+                + \", \" + df.getIdentifier() + \" is INVALID\");\n+            }\n+          } else {\n+            alreadyUpdated++;\n+            if (alreadyUpdated % 100 == 0) {\n+              logger.info(alreadyUpdated + \" of  \" + count\n+                + \" files are already have hashes with the new algorithm. \" + new Date());\n+            }\n+          }\n+        }\n+      } catch (Exception e) {\n+        logger.warning(\"Unexpected Exception: \" + e.getMessage());\n+\n+      } finally {\n+        IOUtils.closeQuietly(in);\n+        IOUtils.closeQuietly(in2);\n+      }\n+    }\n+    logger.info(\"Final Results:\");\n+    logger.info(harvested + \" harvested files skipped.\");\n+    logger.info(\n+      alreadyUpdated + \" of  \" + count + \" files already had hashes with the new algorithm. \" + new Date());\n+    logger.info(rehashed + \" of  \" + count + \" files to rehash. \" + new Date());\n+    logger.info(\n+      successes + \" of  \" + rehashed + \" files successfully rehashed with the new algorithm. \" + new Date());\n+\n+    return ok(\"Datafile rehashing complete.\" + successes + \" of  \" + rehashed + \" files successfully rehashed.\");\n+  }\n+\n+  @POST\n+  @Path(\"/computeDataFileHashValue/{fileId}/algorithm/{alg}\")\n+  public Response computeDataFileHashValue(@PathParam(\"fileId\") String fileId, @PathParam(\"alg\") String alg) {\n+\n+    try {\n+      User u = findAuthenticatedUserOrDie();\n+      if (!u.isSuperuser()) {\n+        return error(Status.UNAUTHORIZED, \"must be superuser\");\n+      }\n+    } catch (WrappedResponse e1) {\n+      return error(Status.UNAUTHORIZED, \"api key required\");\n+    }\n \n-        } catch (Exception e) {\n-            logger.warning(\"Unexpected Exception: \" + e.getMessage());\n-            return error(Status.BAD_REQUEST, \"Checksum Validation Unexpected Exception: \" + e.getMessage());\n-        } finally {\n-            IOUtils.closeQuietly(in);\n+    DataFile fileToUpdate = null;\n+    try {\n+      fileToUpdate = findDataFileOrDie(fileId);\n+    } catch (WrappedResponse r) {\n+      logger.info(\"Could not find file with the id: \" + fileId);\n+      return error(Status.BAD_REQUEST, \"Could not find file with the id: \" + fileId);\n+    }\n \n-        }\n+    if (fileToUpdate.isHarvested()) {\n+      return error(Status.BAD_REQUEST, \"File with the id: \" + fileId + \" is harvested.\");\n+    }\n \n-        if (currentChecksum.equals(calculatedChecksum)) {\n-            return ok(\"Datafile validation complete for \" + fileId + \". The hash value is: \" + calculatedChecksum);\n-        } else {\n-            return error(Status.EXPECTATION_FAILED, \"Datafile validation failed for \" + fileId + \". The saved hash value is: \" + currentChecksum + \" while the recalculated hash value for the stored file is: \" + calculatedChecksum);\n-        }\n+    DataFile.ChecksumType cType = null;\n+    try {\n+      cType = DataFile.ChecksumType.fromString(alg);\n+    } catch (IllegalArgumentException iae) {\n+      return error(Status.BAD_REQUEST, \"Unknown algorithm: \" + alg);\n+    }\n \n+    String newChecksum = \"\";\n+\n+    InputStream in = null;\n+    try {\n+\n+      StorageIO<DataFile> storage = fileToUpdate.getStorageIO();\n+      storage.open(DataAccessOption.READ_ACCESS);\n+      if (!fileToUpdate.isTabularData()) {\n+        in = storage.getInputStream();\n+      } else {\n+        in = storage.getAuxFileAsInputStream(FileUtil.SAVED_ORIGINAL_FILENAME_EXTENSION);\n+      }\n+      if (in == null) {\n+        return error(Status.NOT_FOUND, \"Could not retrieve file with the id: \" + fileId);\n+      }\n+      newChecksum = FileUtil.calculateChecksum(in, cType);\n+      fileToUpdate.setChecksumType(cType);\n+      fileToUpdate.setChecksumValue(newChecksum);\n+\n+    } catch (Exception e) {\n+      logger.warning(\"Unexpected Exception: \" + e.getMessage());\n+\n+    } finally {\n+      IOUtils.closeQuietly(in);\n     }\n \n-    @GET\n-    @Path(\"/submitDataVersionToArchive/{id}/{version}\")\n-    public Response submitDatasetVersionToArchive(@PathParam(\"id\") String dsid, @PathParam(\"version\") String versionNumber) {\n+    return ok(\"Datafile rehashing complete. \" + fileId + \"  successfully rehashed. New hash value is: \" + newChecksum);\n+  }\n \n-        try {\n-            AuthenticatedUser au = findAuthenticatedUserOrDie();\n-\t\t\t// Note - the user is being set in the session so it becomes part of the\n-\t\t\t// DataverseRequest and is sent to the back-end command where it is used to get\n-\t\t\t// the API Token which is then used to retrieve files (e.g. via S3 direct\n-\t\t\t// downloads) to create the Bag\n-            session.setUser(au); // TODO: Stop using session. Use createDataverseRequest instead.\n-            Dataset ds = findDatasetOrDie(dsid);\n-\n-            DatasetVersion dv = datasetversionService.findByFriendlyVersionNumber(ds.getId(), versionNumber);\n-            if (dv.getArchivalCopyLocation() == null) {\n-                String className = settingsService.getValueForKey(SettingsServiceBean.Key.ArchiverClassName);\n-                AbstractSubmitToArchiveCommand cmd = ArchiverUtil.createSubmitToArchiveCommand(className, dvRequestService.getDataverseRequest(), dv);\n-                if (cmd != null) {\n-                    new Thread(new Runnable() {\n-                        public void run() {\n-                            try {\n-                                DatasetVersion dv = commandEngine.submit(cmd);\n-                                if (dv.getArchivalCopyLocation() != null) {\n-                                    logger.info(\"DatasetVersion id=\" + ds.getGlobalId().toString() + \" v\" + versionNumber + \" submitted to Archive at: \"\n-                                            + dv.getArchivalCopyLocation());\n-                                } else {\n-                                    logger.severe(\"Error submitting version due to conflict/error at Archive\");\n-                                }\n-                            } catch (CommandException ex) {\n-                                logger.log(Level.SEVERE, \"Unexpected Exception calling  submit archive command\", ex);\n-                            }\n-                        }\n-                    }).start();\n-                    return ok(\"Archive submission using \" + cmd.getClass().getCanonicalName() + \" started. Processing can take significant time for large datasets. View log and/or check archive for results.\");\n+  @POST\n+  @Path(\"/validateDataFileHashValue/{fileId}\")\n+  public Response validateDataFileHashValue(@PathParam(\"fileId\") String fileId) {\n+\n+    try {\n+      User u = findAuthenticatedUserOrDie();\n+      if (!u.isSuperuser()) {\n+        return error(Status.UNAUTHORIZED, \"must be superuser\");\n+      }\n+    } catch (WrappedResponse e1) {\n+      return error(Status.UNAUTHORIZED, \"api key required\");\n+    }\n+\n+    DataFile fileToValidate = null;\n+    try {\n+      fileToValidate = findDataFileOrDie(fileId);\n+    } catch (WrappedResponse r) {\n+      logger.info(\"Could not find file with the id: \" + fileId);\n+      return error(Status.BAD_REQUEST, \"Could not find file with the id: \" + fileId);\n+    }\n+\n+    if (fileToValidate.isHarvested()) {\n+      return error(Status.BAD_REQUEST, \"File with the id: \" + fileId + \" is harvested.\");\n+    }\n+\n+    DataFile.ChecksumType cType = null;\n+    try {\n+      String checkSumTypeFromDataFile = fileToValidate.getChecksumType().toString();\n+      cType = DataFile.ChecksumType.fromString(checkSumTypeFromDataFile);\n+    } catch (IllegalArgumentException iae) {\n+      return error(Status.BAD_REQUEST, \"Unknown algorithm\");\n+    }\n+\n+    String currentChecksum = fileToValidate.getChecksumValue();\n+    String calculatedChecksum = \"\";\n+    InputStream in = null;\n+    try {\n+\n+      StorageIO<DataFile> storage = fileToValidate.getStorageIO();\n+      storage.open(DataAccessOption.READ_ACCESS);\n+      if (!fileToValidate.isTabularData()) {\n+        in = storage.getInputStream();\n+      } else {\n+        in = storage.getAuxFileAsInputStream(FileUtil.SAVED_ORIGINAL_FILENAME_EXTENSION);\n+      }\n+      if (in == null) {\n+        return error(Status.NOT_FOUND, \"Could not retrieve file with the id: \" + fileId);\n+      }\n+      calculatedChecksum = FileUtil.calculateChecksum(in, cType);\n+\n+    } catch (Exception e) {\n+      logger.warning(\"Unexpected Exception: \" + e.getMessage());\n+      return error(Status.BAD_REQUEST, \"Checksum Validation Unexpected Exception: \" + e.getMessage());\n+    } finally {\n+      IOUtils.closeQuietly(in);\n+\n+    }\n+\n+    if (currentChecksum.equals(calculatedChecksum)) {\n+      return ok(\"Datafile validation complete for \" + fileId + \". The hash value is: \" + calculatedChecksum);\n+    } else {\n+      return error(Status.EXPECTATION_FAILED,\n+        \"Datafile validation failed for \" + fileId + \". The saved hash value is: \" + currentChecksum +\n+          \" while the recalculated hash value for the stored file is: \" + calculatedChecksum);\n+    }\n+\n+  }\n+\n+  @GET\n+  @Path(\"/submitDataVersionToArchive/{id}/{version}\")\n+  public Response submitDatasetVersionToArchive(@PathParam(\"id\") String dsid,\n+                                                @PathParam(\"version\") String versionNumber) {\n+\n+    try {\n+      AuthenticatedUser au = findAuthenticatedUserOrDie();\n+      // Note - the user is being set in the session so it becomes part of the\n+      // DataverseRequest and is sent to the back-end command where it is used to get\n+      // the API Token which is then used to retrieve files (e.g. via S3 direct\n+      // downloads) to create the Bag\n+      session.setUser(au); // TODO: Stop using session. Use createDataverseRequest instead.\n+      Dataset ds = findDatasetOrDie(dsid);\n+\n+      DatasetVersion dv = datasetversionService.findByFriendlyVersionNumber(ds.getId(), versionNumber);\n+      if (dv.getArchivalCopyLocation() == null) {\n+        String className = settingsService.getValueForKey(SettingsServiceBean.Key.ArchiverClassName);\n+        AbstractSubmitToArchiveCommand cmd =\n+          ArchiverUtil.createSubmitToArchiveCommand(className, dvRequestService.getDataverseRequest(), dv);\n+        if (cmd != null) {\n+          new Thread(new Runnable() {\n+            public void run() {\n+              try {\n+                DatasetVersion dv = commandEngine.submit(cmd);\n+                if (dv.getArchivalCopyLocation() != null) {\n+                  logger.info(\"DatasetVersion id=\" + ds.getGlobalId().toString() + \" v\" + versionNumber +\n+                    \" submitted to Archive at: \"\n+                    + dv.getArchivalCopyLocation());\n                 } else {\n-                    logger.log(Level.SEVERE, \"Could not find Archiver class: \" + className);\n-                    return error(Status.INTERNAL_SERVER_ERROR, \"Could not find Archiver class: \" + className);\n+                  logger.severe(\"Error submitting version due to conflict/error at Archive\");\n                 }\n-            } else {\n-                return error(Status.BAD_REQUEST, \"Version already archived at: \" + dv.getArchivalCopyLocation());\n+              } catch (CommandException ex) {\n+                logger.log(Level.SEVERE, \"Unexpected Exception calling  submit archive command\", ex);\n+              }\n             }\n-        } catch (WrappedResponse e1) {\n-            return error(Status.UNAUTHORIZED, \"api key required\");\n+          }).start();\n+          return ok(\"Archive submission using \" + cmd.getClass().getCanonicalName() +\n+            \" started. Processing can take significant time for large datasets. View log and/or check archive for results.\");\n+        } else {\n+          logger.log(Level.SEVERE, \"Could not find Archiver class: \" + className);\n+          return error(Status.INTERNAL_SERVER_ERROR, \"Could not find Archiver class: \" + className);\n         }\n+      } else {\n+        return error(Status.BAD_REQUEST, \"Version already archived at: \" + dv.getArchivalCopyLocation());\n+      }\n+    } catch (WrappedResponse e1) {\n+      return error(Status.UNAUTHORIZED, \"api key required\");\n     }\n-    \n-\t@DELETE\n-\t@Path(\"/clearMetricsCache\")\n-\tpublic Response clearMetricsCache() {\n-\t\tem.createNativeQuery(\"DELETE FROM metric\").executeUpdate();\n-\t\treturn ok(\"all metric caches cleared.\");\n-\t}\n-\n-\t@DELETE\n-\t@Path(\"/clearMetricsCache/{name}\")\n-\tpublic Response clearMetricsCacheByName(@PathParam(\"name\") String name) {\n-\t\tQuery deleteQuery = em.createNativeQuery(\"DELETE FROM metric where metricname = ?\");\n-\t\tdeleteQuery.setParameter(1, name);\n-\t\tdeleteQuery.executeUpdate();\n-\t\treturn ok(\"metric cache \" + name + \" cleared.\");\n-\t}\n-\n-    @GET\n-    @Path(\"/dataverse/{alias}/addRoleAssignmentsToChildren\")\n-    public Response addRoleAssignementsToChildren(@PathParam(\"alias\") String alias) throws WrappedResponse {\n-        Dataverse owner = dataverseSvc.findByAlias(alias);\n-        if (owner == null) {\n-            return error(Response.Status.NOT_FOUND, \"Could not find dataverse based on alias supplied: \" + alias + \".\");\n-        }\n-        try {\n-            AuthenticatedUser user = findAuthenticatedUserOrDie();\n-            if (!user.isSuperuser()) {\n-                return error(Response.Status.FORBIDDEN, \"Superusers only.\");\n-            }\n-        } catch (WrappedResponse wr) {\n-            return wr.getResponse();\n-        }\n-        boolean inheritAllRoles = false;\n-        String rolesString = settingsSvc.getValueForKey(SettingsServiceBean.Key.InheritParentRoleAssignments, \"\");\n-        if (rolesString.length() > 0) {\n-            ArrayList<String> rolesToInherit = new ArrayList<String>(Arrays.asList(rolesString.split(\"\\\\s*,\\\\s*\")));\n-            if (!rolesToInherit.isEmpty()) {\n-                if (rolesToInherit.contains(\"*\")) {\n-                    inheritAllRoles = true;\n-                }\n-                return ok(dataverseSvc.addRoleAssignmentsToChildren(owner, rolesToInherit, inheritAllRoles));\n-            }\n+  }\n+\n+  @DELETE\n+  @Path(\"/clearMetricsCache\")\n+  public Response clearMetricsCache() {\n+    em.createNativeQuery(\"DELETE FROM metric\").executeUpdate();\n+    return ok(\"all metric caches cleared.\");\n+  }\n+\n+  @DELETE\n+  @Path(\"/clearMetricsCache/{name}\")\n+  public Response clearMetricsCacheByName(@PathParam(\"name\") String name) {\n+    Query deleteQuery = em.createNativeQuery(\"DELETE FROM metric where metricname = ?\");\n+    deleteQuery.setParameter(1, name);\n+    deleteQuery.executeUpdate();\n+    return ok(\"metric cache \" + name + \" cleared.\");\n+  }\n+\n+  @GET\n+  @Path(\"/dataverse/{alias}/addRoleAssignmentsToChildren\")\n+  public Response addRoleAssignementsToChildren(@PathParam(\"alias\") String alias) throws WrappedResponse {\n+    Dataverse owner = dataverseSvc.findByAlias(alias);\n+    if (owner == null) {\n+      return error(Response.Status.NOT_FOUND, \"Could not find dataverse based on alias supplied: \" + alias + \".\");\n+    }\n+    try {\n+      AuthenticatedUser user = findAuthenticatedUserOrDie();\n+      if (!user.isSuperuser()) {\n+        return error(Response.Status.FORBIDDEN, \"Superusers only.\");\n+      }\n+    } catch (WrappedResponse wr) {\n+      return wr.getResponse();\n+    }\n+    boolean inheritAllRoles = false;\n+    String rolesString = settingsSvc.getValueForKey(SettingsServiceBean.Key.InheritParentRoleAssignments, \"\");\n+    if (rolesString.length() > 0) {\n+      ArrayList<String> rolesToInherit = new ArrayList<String>(Arrays.asList(rolesString.split(\"\\\\s*,\\\\s*\")));\n+      if (!rolesToInherit.isEmpty()) {\n+        if (rolesToInherit.contains(\"*\")) {\n+          inheritAllRoles = true;\n         }\n-        return error(Response.Status.BAD_REQUEST,\n-                \"InheritParentRoleAssignments does not list any roles on this instance\");\n-    }\n-    \n-    @GET\n-    @Path(\"/dataverse/{alias}/storageDriver\")\n-    public Response getStorageDriver(@PathParam(\"alias\") String alias) throws WrappedResponse {\n-    \tDataverse dataverse = dataverseSvc.findByAlias(alias);\n-    \tif (dataverse == null) {\n-    \t\treturn error(Response.Status.NOT_FOUND, \"Could not find dataverse based on alias supplied: \" + alias + \".\");\n-    \t}\n-    \ttry {\n-    \t\tAuthenticatedUser user = findAuthenticatedUserOrDie();\n-    \t\tif (!user.isSuperuser()) {\n-    \t\t\treturn error(Response.Status.FORBIDDEN, \"Superusers only.\");\n-    \t\t}\n-    \t} catch (WrappedResponse wr) {\n-    \t\treturn wr.getResponse();\n-    \t}\n-    \t//Note that this returns what's set directly on this dataverse. If null/DataAccess.UNDEFINED_STORAGE_DRIVER_IDENTIFIER, the user would have to recurse the chain of parents to find the effective storageDriver\n-    \treturn ok(dataverse.getStorageDriverId());\n-    }\n-    \n-    @PUT\n-    @Path(\"/dataverse/{alias}/storageDriver\")\n-    public Response setStorageDriver(@PathParam(\"alias\") String alias, String label) throws WrappedResponse {\n-    \tDataverse dataverse = dataverseSvc.findByAlias(alias);\n-    \tif (dataverse == null) {\n-    \t\treturn error(Response.Status.NOT_FOUND, \"Could not find dataverse based on alias supplied: \" + alias + \".\");\n-    \t}\n-    \ttry {\n-    \t\tAuthenticatedUser user = findAuthenticatedUserOrDie();\n-    \t\tif (!user.isSuperuser()) {\n-    \t\t\treturn error(Response.Status.FORBIDDEN, \"Superusers only.\");\n-    \t\t}\n-    \t} catch (WrappedResponse wr) {\n-    \t\treturn wr.getResponse();\n-    \t}\n-    \tfor (Entry<String, String> store: DataAccess.getStorageDriverLabels().entrySet()) {\n-    \t\tif(store.getKey().equals(label)) {\n-    \t\t\tdataverse.setStorageDriverId(store.getValue());\n-    \t\t\treturn ok(\"Storage set to: \" + store.getKey() + \"/\" + store.getValue());\n-    \t\t}\n-    \t}\n-    \treturn error(Response.Status.BAD_REQUEST,\n-    \t\t\t\"No Storage Driver found for : \" + label);\n-    }\n-\n-    @DELETE\n-    @Path(\"/dataverse/{alias}/storageDriver\")\n-    public Response resetStorageDriver(@PathParam(\"alias\") String alias) throws WrappedResponse {\n-    \tDataverse dataverse = dataverseSvc.findByAlias(alias);\n-    \tif (dataverse == null) {\n-    \t\treturn error(Response.Status.NOT_FOUND, \"Could not find dataverse based on alias supplied: \" + alias + \".\");\n-    \t}\n-    \ttry {\n-    \t\tAuthenticatedUser user = findAuthenticatedUserOrDie();\n-    \t\tif (!user.isSuperuser()) {\n-    \t\t\treturn error(Response.Status.FORBIDDEN, \"Superusers only.\");\n-    \t\t}\n-    \t} catch (WrappedResponse wr) {\n-    \t\treturn wr.getResponse();\n-    \t}\n-    \tdataverse.setStorageDriverId(\"\");\n-    \treturn ok(\"Storage reset to default: \" + DataAccess.DEFAULT_STORAGE_DRIVER_IDENTIFIER);\n-    }\n-    \n-    @GET\n-    @Path(\"/dataverse/storageDrivers\")\n-    public Response listStorageDrivers() throws WrappedResponse {\n-    \ttry {\n-    \t\tAuthenticatedUser user = findAuthenticatedUserOrDie();\n-    \t\tif (!user.isSuperuser()) {\n-    \t\t\treturn error(Response.Status.FORBIDDEN, \"Superusers only.\");\n-    \t\t}\n-    \t} catch (WrappedResponse wr) {\n-    \t\treturn wr.getResponse();\n-    \t}\n-    \tJsonObjectBuilder bld = jsonObjectBuilder();\n-    \tDataAccess.getStorageDriverLabels().entrySet().forEach(s -> bld.add(s.getKey(), s.getValue()));\n-\t\treturn ok(bld);\n-    }\n-    \n-    @POST\n-    @Path(\"/bannerMessage\")\n-    public Response addBannerMessage(JsonObject jsonObject) throws WrappedResponse {\n-\n-        BannerMessage toAdd = new BannerMessage();\n-        try {\n-            String dismissible = jsonObject.getString(\"dismissibleByUser\");\n+        return ok(dataverseSvc.addRoleAssignmentsToChildren(owner, rolesToInherit, inheritAllRoles));\n+      }\n+    }\n+    return error(Response.Status.BAD_REQUEST,\n+      \"InheritParentRoleAssignments does not list any roles on this instance\");\n+  }\n+\n+  @GET\n+  @Path(\"/dataverse/{alias}/storageDriver\")\n+  public Response getStorageDriver(@PathParam(\"alias\") String alias) throws WrappedResponse {\n+    Dataverse dataverse = dataverseSvc.findByAlias(alias);\n+    if (dataverse == null) {\n+      return error(Response.Status.NOT_FOUND, \"Could not find dataverse based on alias supplied: \" + alias + \".\");\n+    }\n+    try {\n+      AuthenticatedUser user = findAuthenticatedUserOrDie();\n+      if (!user.isSuperuser()) {\n+        return error(Response.Status.FORBIDDEN, \"Superusers only.\");\n+      }\n+    } catch (WrappedResponse wr) {\n+      return wr.getResponse();\n+    }\n+    //Note that this returns what's set directly on this dataverse. If null/DataAccess.UNDEFINED_STORAGE_DRIVER_IDENTIFIER, the user would have to recurse the chain of parents to find the effective storageDriver\n+    return ok(dataverse.getStorageDriverId());\n+  }\n+\n+  @PUT\n+  @Path(\"/dataverse/{alias}/storageDriver\")\n+  public Response setStorageDriver(@PathParam(\"alias\") String alias, String label) throws WrappedResponse {\n+    Dataverse dataverse = dataverseSvc.findByAlias(alias);\n+    if (dataverse == null) {\n+      return error(Response.Status.NOT_FOUND, \"Could not find dataverse based on alias supplied: \" + alias + \".\");\n+    }\n+    try {\n+      AuthenticatedUser user = findAuthenticatedUserOrDie();\n+      if (!user.isSuperuser()) {\n+        return error(Response.Status.FORBIDDEN, \"Superusers only.\");\n+      }\n+    } catch (WrappedResponse wr) {\n+      return wr.getResponse();\n+    }\n+    for (Entry<String, String> store : DataAccess.getStorageDriverLabels().entrySet()) {\n+      if (store.getKey().equals(label)) {\n+        dataverse.setStorageDriverId(store.getValue());\n+        return ok(\"Storage set to: \" + store.getKey() + \"/\" + store.getValue());\n+      }\n+    }\n+    return error(Response.Status.BAD_REQUEST,\n+      \"No Storage Driver found for : \" + label);\n+  }\n+\n+  @DELETE\n+  @Path(\"/dataverse/{alias}/storageDriver\")\n+  public Response resetStorageDriver(@PathParam(\"alias\") String alias) throws WrappedResponse {\n+    Dataverse dataverse = dataverseSvc.findByAlias(alias);\n+    if (dataverse == null) {\n+      return error(Response.Status.NOT_FOUND, \"Could not find dataverse based on alias supplied: \" + alias + \".\");\n+    }\n+    try {\n+      AuthenticatedUser user = findAuthenticatedUserOrDie();\n+      if (!user.isSuperuser()) {\n+        return error(Response.Status.FORBIDDEN, \"Superusers only.\");\n+      }\n+    } catch (WrappedResponse wr) {\n+      return wr.getResponse();\n+    }\n+    dataverse.setStorageDriverId(\"\");\n+    return ok(\"Storage reset to default: \" + DataAccess.DEFAULT_STORAGE_DRIVER_IDENTIFIER);\n+  }\n+\n+  @GET\n+  @Path(\"/dataverse/storageDrivers\")\n+  public Response listStorageDrivers() throws WrappedResponse {\n+    try {\n+      AuthenticatedUser user = findAuthenticatedUserOrDie();\n+      if (!user.isSuperuser()) {\n+        return error(Response.Status.FORBIDDEN, \"Superusers only.\");\n+      }\n+    } catch (WrappedResponse wr) {\n+      return wr.getResponse();\n+    }\n+    JsonObjectBuilder bld = jsonObjectBuilder();\n+    DataAccess.getStorageDriverLabels().entrySet().forEach(s -> bld.add(s.getKey(), s.getValue()));\n+    return ok(bld);\n+  }\n+\n+  @POST\n+  @Path(\"/bannerMessage\")\n+  public Response addBannerMessage(JsonObject jsonObject) throws WrappedResponse {\n+\n+    BannerMessage toAdd = new BannerMessage();\n+    try {\n+      String dismissible = jsonObject.getString(\"dismissibleByUser\");\n+\n+      boolean dismissibleByUser = false;\n+      if (dismissible.equals(\"true\")) {\n+        dismissibleByUser = true;\n+      }\n+      toAdd.setDismissibleByUser(dismissibleByUser);\n+      toAdd.setBannerMessageTexts(new ArrayList());\n+      toAdd.setActive(true);\n+      JsonArray jsonArray = jsonObject.getJsonArray(\"messageTexts\");\n+      for (int i = 0; i < jsonArray.size(); i++) {\n+        JsonObject obj = (JsonObject) jsonArray.get(i);\n+        String message = obj.getString(\"message\");\n+        String lang = obj.getString(\"lang\");\n+        BannerMessageText messageText = new BannerMessageText();\n+        messageText.setMessage(message);\n+        messageText.setLang(lang);\n+        messageText.setBannerMessage(toAdd);\n+        toAdd.getBannerMessageTexts().add(messageText);\n+      }\n+      bannerMessageService.save(toAdd);\n+      return ok(\"Banner Message added successfully.\");\n+\n+    } catch (Exception e) {\n+      logger.warning(\"Unexpected Exception: \" + e.getMessage());\n+      return error(Status.BAD_REQUEST, \"Add Banner Message unexpected exception: \" + e.getMessage());\n+    }\n \n-            boolean dismissibleByUser = false;\n-            if (dismissible.equals(\"true\")) {\n-                dismissibleByUser = true;\n-            }\n-            toAdd.setDismissibleByUser(dismissibleByUser);\n-            toAdd.setBannerMessageTexts(new ArrayList());\n-            toAdd.setActive(true);\n-            JsonArray jsonArray = jsonObject.getJsonArray(\"messageTexts\");\n-            for (int i = 0; i < jsonArray.size(); i++) {\n-                JsonObject obj = (JsonObject) jsonArray.get(i);\n-                String message = obj.getString(\"message\");\n-                String lang = obj.getString(\"lang\");\n-                BannerMessageText messageText = new BannerMessageText();\n-                messageText.setMessage(message);\n-                messageText.setLang(lang);\n-                messageText.setBannerMessage(toAdd);\n-                toAdd.getBannerMessageTexts().add(messageText);\n-            }\n-                bannerMessageService.save(toAdd);\n-                return ok(\"Banner Message added successfully.\");\n+  }\n \n-        } catch (Exception e) {\n-            logger.warning(\"Unexpected Exception: \" + e.getMessage());\n-            return error(Status.BAD_REQUEST, \"Add Banner Message unexpected exception: \" + e.getMessage());\n-        }\n+  @DELETE\n+  @Path(\"/bannerMessage/{id}\")\n+  public Response deleteBannerMessage(@PathParam(\"id\") Long id) throws WrappedResponse {\n \n+    BannerMessage message = em.find(BannerMessage.class, id);\n+    if (message == null) {\n+      return error(Response.Status.NOT_FOUND, \"Message id = \" + id + \" not found.\");\n     }\n-    \n-    @DELETE\n-    @Path(\"/bannerMessage/{id}\")\n-    public Response deleteBannerMessage(@PathParam(\"id\") Long id) throws WrappedResponse {\n- \n-        BannerMessage message = em.find(BannerMessage.class, id);\n-        if (message == null){\n-            return error(Response.Status.NOT_FOUND, \"Message id = \"  + id + \" not found.\");\n-        }\n-        bannerMessageService.deleteBannerMessage(id);\n-        \n-        return ok(\"Message id =  \" + id + \" deleted.\");\n-\n-    }\n-    \n-    @PUT\n-    @Path(\"/bannerMessage/{id}/deactivate\")\n-    public Response deactivateBannerMessage(@PathParam(\"id\") Long id) throws WrappedResponse {\n-        BannerMessage message = em.find(BannerMessage.class, id);\n-        if (message == null){\n-            return error(Response.Status.NOT_FOUND, \"Message id = \"  + id + \" not found.\");\n-        }\n-        bannerMessageService.deactivateBannerMessage(id);\n-        \n-        return ok(\"Message id =  \" + id + \" deactivated.\");\n+    bannerMessageService.deleteBannerMessage(id);\n \n-    }\n-    \n-    @GET\n-    @Path(\"/bannerMessage\")\n-    public Response getBannerMessages(@PathParam(\"id\") Long id) throws WrappedResponse {\n+    return ok(\"Message id =  \" + id + \" deleted.\");\n \n-        return ok(bannerMessageService.findAllBannerMessages().stream()\n-                .map(m -> jsonObjectBuilder().add(\"id\", m.getId()).add(\"displayValue\", m.getDisplayValue()))\n-                .collect(toJsonArray()));\n+  }\n \n+  @PUT\n+  @Path(\"/bannerMessage/{id}/deactivate\")\n+  public Response deactivateBannerMessage(@PathParam(\"id\") Long id) throws WrappedResponse {\n+    BannerMessage message = em.find(BannerMessage.class, id);\n+    if (message == null) {\n+      return error(Response.Status.NOT_FOUND, \"Message id = \" + id + \" not found.\");\n     }\n-    \n+    bannerMessageService.deactivateBannerMessage(id);\n+\n+    return ok(\"Message id =  \" + id + \" deactivated.\");\n+\n+  }\n+\n+  @GET\n+  @Path(\"/bannerMessage\")\n+  public Response getBannerMessages(@PathParam(\"id\") Long id) throws WrappedResponse {\n+\n+    return ok(bannerMessageService.findAllBannerMessages().stream()\n+      .map(m -> jsonObjectBuilder().add(\"id\", m.getId()).add(\"displayValue\", m.getDisplayValue()))\n+      .collect(toJsonArray()));\n+\n+  }\n+\n }\n",
            "diff_size": 3011
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/1/Admin.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/codebuff/1/Admin.java\nindex 1df51137969..1e68ac385a4 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/1/Admin.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/codebuff/1/Admin.java\n@@ -69,10 +69,8 @@ import javax.validation.ConstraintViolation;\n import javax.validation.ConstraintViolationException;\n import javax.ws.rs.Produces;\n import javax.ws.rs.core.Response.Status;\n-\n import org.apache.commons.io.IOUtils;\n import org.apache.commons.lang3.StringUtils;\n-\n import java.util.List;\n import edu.harvard.iq.dataverse.authorization.AuthTestDataServiceBean;\n import edu.harvard.iq.dataverse.authorization.AuthenticationProvidersRegistrationServiceBean;\n@@ -98,7 +96,6 @@ import edu.harvard.iq.dataverse.util.BundleUtil;\n import edu.harvard.iq.dataverse.util.FileUtil;\n import java.io.IOException;\n import java.io.OutputStream;\n-\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Date;\n@@ -115,222 +112,221 @@ import javax.ws.rs.core.StreamingOutput;\n  * \n  * @author michael\n  */\n+\n+\n @Stateless\n @Path(\"admin\")\n public class Admin extends AbstractApiBean {\n \n-\tprivate static final Logger logger = Logger.getLogger(Admin.class.getName());\n-\n-        @EJB\n-        AuthenticationProvidersRegistrationServiceBean authProvidersRegistrationSvc;\n-\t@EJB\n-\tBuiltinUserServiceBean builtinUserService;\n-\t@EJB\n-\tShibServiceBean shibService;\n-\t@EJB\n-\tAuthTestDataServiceBean authTestDataService;\n-\t@EJB\n-\tUserServiceBean userService;\n-\t@EJB\n-\tIngestServiceBean ingestService;\n-\t@EJB\n-\tDataFileServiceBean fileService;\n-\t@EJB\n-\tDatasetServiceBean datasetService;\n-\t@EJB\n-\tDatasetVersionServiceBean datasetversionService;\n-        @Inject\n-        DataverseRequestServiceBean dvRequestService;\n-        @EJB\n-        EjbDataverseEngine commandEngine;\n-        @EJB\n-        GroupServiceBean groupService;\n-        @EJB\n-        SettingsServiceBean settingsService;\n-        @EJB\n-        DatasetVersionServiceBean datasetVersionService;\n-        @EJB\n-        ExplicitGroupServiceBean explicitGroupService;\n-        @EJB\n-        BannerMessageServiceBean bannerMessageService;\n+    private static final Logger logger = Logger.getLogger(Admin.class.getName());\n+\n+    @EJB\n+    AuthenticationProvidersRegistrationServiceBean authProvidersRegistrationSvc;\n+\n+    @EJB\n+    BuiltinUserServiceBean builtinUserService;\n+\n+    @EJB\n+    ShibServiceBean shibService;\n+\n+    @EJB\n+    AuthTestDataServiceBean authTestDataService;\n+\n+    @EJB\n+    UserServiceBean userService;\n+\n+    @EJB\n+    IngestServiceBean ingestService;\n+\n+    @EJB\n+    DataFileServiceBean fileService;\n+\n+    @EJB\n+    DatasetServiceBean datasetService;\n+\n+    @EJB\n+    DatasetVersionServiceBean datasetversionService;\n+\n+    @Inject\n+    DataverseRequestServiceBean dvRequestService;\n+\n+    @EJB\n+    EjbDataverseEngine commandEngine;\n+\n+    @EJB\n+    GroupServiceBean groupService;\n+\n+    @EJB\n+    SettingsServiceBean settingsService;\n+\n+    @EJB\n+    DatasetVersionServiceBean datasetVersionService;\n+\n+    @EJB\n+    ExplicitGroupServiceBean explicitGroupService;\n+\n+    @EJB\n+    BannerMessageServiceBean bannerMessageService;\n         \n \n-\t// Make the session available\n-\t@Inject\n-\tDataverseSession session;\n-\n-\tpublic static final String listUsersPartialAPIPath = \"list-users\";\n-\tpublic static final String listUsersFullAPIPath = \"/api/admin/\" + listUsersPartialAPIPath;\n-\n-\t@Path(\"settings\")\n-\t@GET\n-\tpublic Response listAllSettings() {\n-\t\tJsonObjectBuilder bld = jsonObjectBuilder();\n-\t\tsettingsSvc.listAll().forEach(s -> bld.add(s.getName(), s.getContent()));\n-\t\treturn ok(bld);\n-\t}\n-\n-\t@Path(\"settings/{name}\")\n-\t@PUT\n-\tpublic Response putSetting(@PathParam(\"name\") String name, String content) {\n-\t\tSetting s = settingsSvc.set(name, content);\n-\t\treturn ok(jsonObjectBuilder().add(s.getName(), s.getContent()));\n-\t}\n-\n-\t@Path(\"settings/{name}/lang/{lang}\")\n-\t@PUT\n-\tpublic Response putSetting(@PathParam(\"name\") String name, @PathParam(\"lang\") String lang, String content) {\n-\t\tSetting s = settingsSvc.set(name, lang, content);\n-\t\treturn ok(\"Setting \" + name + \" - \" + lang + \" - added.\");\n-\t}\n-\n-\t@Path(\"settings/{name}\")\n-\t@GET\n-\tpublic Response getSetting(@PathParam(\"name\") String name) {\n-\t\tString s = settingsSvc.get(name);\n-\n-\t\treturn (s != null) ? ok(s) : notFound(\"Setting \" + name + \" not found\");\n-\t}\n-\n-\t@Path(\"settings/{name}\")\n-\t@DELETE\n-\tpublic Response deleteSetting(@PathParam(\"name\") String name) {\n-\t\tsettingsSvc.delete(name);\n-\n-\t\treturn ok(\"Setting \" + name + \" deleted.\");\n-\t}\n-\n-\t@Path(\"settings/{name}/lang/{lang}\")\n-\t@DELETE\n-\tpublic Response deleteSetting(@PathParam(\"name\") String name, @PathParam(\"lang\") String lang) {\n-\t\tsettingsSvc.delete(name, lang);\n-\t\treturn ok(\"Setting \" + name + \" - \" + lang + \" deleted.\");\n-\t}\n-\n-\t@Path(\"authenticationProviderFactories\")\n-\t@GET\n-\tpublic Response listAuthProviderFactories() {\n-\t\treturn ok(authSvc.listProviderFactories().stream()\n-\t\t\t\t.map(f -> jsonObjectBuilder().add(\"alias\", f.getAlias()).add(\"info\", f.getInfo()))\n-\t\t\t\t.collect(toJsonArray()));\n-\t}\n-\n-\t@Path(\"authenticationProviders\")\n-\t@GET\n-\tpublic Response listAuthProviders() {\n-\t\treturn ok(em.createNamedQuery(\"AuthenticationProviderRow.findAll\", AuthenticationProviderRow.class)\n-\t\t\t\t.getResultList().stream().map(r -> json(r)).collect(toJsonArray()));\n-\t}\n-\n-\t@Path(\"authenticationProviders\")\n-\t@POST\n-\tpublic Response addProvider(AuthenticationProviderRow row) {\n-\t\ttry {\n-\t\t\tAuthenticationProviderRow managed = em.find(AuthenticationProviderRow.class, row.getId());\n-\t\t\tif (managed != null) {\n-\t\t\t\tmanaged = em.merge(row);\n-\t\t\t} else {\n-\t\t\t\tem.persist(row);\n-\t\t\t\tmanaged = row;\n-\t\t\t}\n-\t\t\tif (managed.isEnabled()) {\n-\t\t\t\tAuthenticationProvider provider = authProvidersRegistrationSvc.loadProvider(managed);\n-\t\t\t\tauthProvidersRegistrationSvc.deregisterProvider(provider.getId());\n-\t\t\t\tauthProvidersRegistrationSvc.registerProvider(provider);\n-\t\t\t}\n-\t\t\treturn created(\"/api/admin/authenticationProviders/\" + managed.getId(), json(managed));\n-\t\t} catch (AuthorizationSetupException e) {\n-\t\t\treturn error(Response.Status.INTERNAL_SERVER_ERROR, e.getMessage());\n-\t\t}\n-\t}\n-\n-\t@Path(\"authenticationProviders/{id}\")\n-\t@GET\n-\tpublic Response showProvider(@PathParam(\"id\") String id) {\n-\t\tAuthenticationProviderRow row = em.find(AuthenticationProviderRow.class, id);\n-\t\treturn (row != null) ? ok(json(row))\n-\t\t\t\t: error(Status.NOT_FOUND, \"Can't find authetication provider with id '\" + id + \"'\");\n-\t}\n-\n-\t@POST\n-\t@Path(\"authenticationProviders/{id}/:enabled\")\n-\tpublic Response enableAuthenticationProvider_deprecated(@PathParam(\"id\") String id, String body) {\n-\t\treturn enableAuthenticationProvider(id, body);\n-\t}\n-\n-\t@PUT\n-\t@Path(\"authenticationProviders/{id}/enabled\")\n-\t@Produces(\"application/json\")\n-\tpublic Response enableAuthenticationProvider(@PathParam(\"id\") String id, String body) {\n-\t\tbody = body.trim();\n-\t\tif (!Util.isBoolean(body)) {\n-\t\t\treturn error(Response.Status.BAD_REQUEST, \"Illegal value '\" + body + \"'. Use 'true' or 'false'\");\n-\t\t}\n-\t\tboolean enable = Util.isTrue(body);\n-\n-\t\tAuthenticationProviderRow row = em.find(AuthenticationProviderRow.class, id);\n-\t\tif (row == null) {\n-\t\t\treturn notFound(\"Can't find authentication provider with id '\" + id + \"'\");\n-\t\t}\n-\n-\t\trow.setEnabled(enable);\n-\t\tem.merge(row);\n-\n-\t\tif (enable) {\n-\t\t\t// enable a provider\n-\t\t\tif (authSvc.getAuthenticationProvider(id) != null) {\n-\t\t\t\treturn ok(String.format(\"Authentication provider '%s' already enabled\", id));\n-\t\t\t}\n-\t\t\ttry {\n-\t\t\t\tauthProvidersRegistrationSvc.registerProvider(authProvidersRegistrationSvc.loadProvider(row));\n-\t\t\t\treturn ok(String.format(\"Authentication Provider %s enabled\", row.getId()));\n-\n-\t\t\t} catch (AuthenticationProviderFactoryNotFoundException ex) {\n-\t\t\t\treturn notFound(String.format(\"Can't instantiate provider, as there's no factory with alias %s\",\n-\t\t\t\t\t\trow.getFactoryAlias()));\n-\t\t\t} catch (AuthorizationSetupException ex) {\n-\t\t\t\tlogger.log(Level.WARNING, \"Error instantiating authentication provider: \" + ex.getMessage(), ex);\n-\t\t\t\treturn error(Status.INTERNAL_SERVER_ERROR,\n-\t\t\t\t\t\tString.format(\"Can't instantiate provider: %s\", ex.getMessage()));\n-\t\t\t}\n-\n-\t\t} else {\n-\t\t\t// disable a provider\n-\t\t\tauthProvidersRegistrationSvc.deregisterProvider(id);\n-\t\t\treturn ok(\"Authentication Provider '\" + id + \"' disabled. \"\n-\t\t\t\t\t+ (authSvc.getAuthenticationProviderIds().isEmpty()\n-\t\t\t\t\t\t\t? \"WARNING: no enabled authentication providers left.\"\n-\t\t\t\t\t\t\t: \"\"));\n-\t\t}\n-\t}\n-\n-\t@GET\n-\t@Path(\"authenticationProviders/{id}/enabled\")\n-\tpublic Response checkAuthenticationProviderEnabled(@PathParam(\"id\") String id) {\n-\t\tList<AuthenticationProviderRow> prvs = em\n-\t\t\t\t.createNamedQuery(\"AuthenticationProviderRow.findById\", AuthenticationProviderRow.class)\n-\t\t\t\t.setParameter(\"id\", id).getResultList();\n-\t\tif (prvs.isEmpty()) {\n-\t\t\treturn notFound(\"Can't find a provider with id '\" + id + \"'.\");\n-\t\t} else {\n-\t\t\treturn ok(Boolean.toString(prvs.get(0).isEnabled()));\n-\t\t}\n-\t}\n-\n-\t@DELETE\n-\t@Path(\"authenticationProviders/{id}/\")\n-\tpublic Response deleteAuthenticationProvider(@PathParam(\"id\") String id) {\n-\t\tauthProvidersRegistrationSvc.deregisterProvider(id);\n-\t\tAuthenticationProviderRow row = em.find(AuthenticationProviderRow.class, id);\n-\t\tif (row != null) {\n-\t\t\tem.remove(row);\n-\t\t}\n-\n-\t\treturn ok(\"AuthenticationProvider \" + id + \" deleted. \"\n-\t\t\t\t+ (authSvc.getAuthenticationProviderIds().isEmpty()\n-\t\t\t\t\t\t? \"WARNING: no enabled authentication providers left.\"\n-\t\t\t\t\t\t: \"\"));\n-\t}\n+    // Make the session available\n+\n+    @Inject\n+    DataverseSession session;\n+\n+    public static final String listUsersPartialAPIPath = \"list-users\";\n+\n+    public static final String listUsersFullAPIPath = \"/api/admin/\" + listUsersPartialAPIPath;\n+\n+    @Path(\"settings\")\n+    @GET\n+    public Response listAllSettings() {\n+        JsonObjectBuilder bld = jsonObjectBuilder();\n+        settingsSvc.listAll().forEach(s -> bld.add(s.getName(), s.getContent()));\n+        return ok(bld);\n+    }\n+\n+    @Path(\"settings/{name}\")\n+    @PUT\n+    public Response putSetting(@PathParam(\"name\") String name, String content) {\n+        Setting s = settingsSvc.set(name, content);\n+        return ok(jsonObjectBuilder().add(s.getName(), s.getContent()));\n+    }\n+\n+    @Path(\"settings/{name}/lang/{lang}\")\n+    @PUT\n+    public Response putSetting(@PathParam(\"name\") String name, @PathParam(\"lang\") String lang, String content) {\n+        Setting s = settingsSvc.set(name, lang, content);\n+        return ok(\"Setting \" + name + \" - \" + lang + \" - added.\");\n+    }\n+\n+    @Path(\"settings/{name}\")\n+    @GET\n+    public Response getSetting(@PathParam(\"name\") String name) {\n+        String s = settingsSvc.get(name);\n+        return (s != null) ? ok(s) : notFound(\"Setting \" + name + \" not found\");\n+    }\n+\n+    @Path(\"settings/{name}\")\n+    @DELETE\n+    public Response deleteSetting(@PathParam(\"name\") String name) {\n+        settingsSvc.delete(name);\n+        return ok(\"Setting \" + name + \" deleted.\");\n+    }\n+\n+    @Path(\"settings/{name}/lang/{lang}\")\n+    @DELETE\n+    public Response deleteSetting(@PathParam(\"name\") String name, @PathParam(\"lang\") String lang) {\n+        settingsSvc.delete(name, lang);\n+        return ok(\"Setting \" + name + \" - \" + lang + \" deleted.\");\n+    }\n+\n+    @Path(\"authenticationProviderFactories\")\n+    @GET\n+    public Response listAuthProviderFactories() {\n+        return ok(authSvc.listProviderFactories().stream().map(f -> jsonObjectBuilder().add(\"alias\", f.getAlias()).add(\"info\", f.getInfo())).collect(toJsonArray()));\n+    }\n+\n+    @Path(\"authenticationProviders\")\n+    @GET\n+    public Response listAuthProviders() {\n+        return ok(em.createNamedQuery(\"AuthenticationProviderRow.findAll\", AuthenticationProviderRow.class).getResultList().stream().map(r -> json(r)).collect(toJsonArray()));\n+    }\n+\n+    @Path(\"authenticationProviders\")\n+    @POST\n+    public Response addProvider(AuthenticationProviderRow row) {\n+        try {\n+            AuthenticationProviderRow managed = em.find(AuthenticationProviderRow.class, row.getId());\n+            if (managed != null) {\n+                managed = em.merge(row);\n+            } else {\n+                em.persist(row);\n+                managed = row;\n+            }\n+\n+            if (managed.isEnabled()) {\n+                AuthenticationProvider provider = authProvidersRegistrationSvc.loadProvider(managed);\n+                authProvidersRegistrationSvc.deregisterProvider(provider.getId());\n+                authProvidersRegistrationSvc.registerProvider(provider);\n+            }\n+            return created(\"/api/admin/authenticationProviders/\" + managed.getId(), json(managed));\n+        } catch (AuthorizationSetupException e) {\n+            return error(Response.Status.INTERNAL_SERVER_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    @Path(\"authenticationProviders/{id}\")\n+    @GET\n+    public Response showProvider(@PathParam(\"id\") String id) {\n+        AuthenticationProviderRow row = em.find(AuthenticationProviderRow.class, id);\n+        return (row != null) ? ok(json(row)) : error(Status.NOT_FOUND, \"Can't find authetication provider with id '\" + id + \"'\");\n+    }\n+\n+    @POST\n+    @Path(\"authenticationProviders/{id}/:enabled\")\n+    public Response enableAuthenticationProvider_deprecated(@PathParam(\"id\") String id, String body) {\n+        return enableAuthenticationProvider(id, body);\n+    }\n+\n+    @PUT\n+    @Path(\"authenticationProviders/{id}/enabled\")\n+    @Produces(\"application/json\")\n+    public Response enableAuthenticationProvider(@PathParam(\"id\") String id, String body) {\n+        body = body.trim();\n+        if (!Util.isBoolean(body)) {\n+            return error(Response.Status.BAD_REQUEST, \"Illegal value '\" + body + \"'. Use 'true' or 'false'\");\n+        }\n+\n+        boolean enable = Util.isTrue(body);\n+        AuthenticationProviderRow row = em.find(AuthenticationProviderRow.class, id);\n+        if (row == null) {\n+            return notFound(\"Can't find authentication provider with id '\" + id + \"'\");\n+        }\n+        row.setEnabled(enable);\n+        em.merge(row);\n+        if (enable) {\n+            // enable a provider\n+            if (authSvc.getAuthenticationProvider(id) != null) {\n+                return ok(String.format(\"Authentication provider '%s' already enabled\", id));\n+            }\n+            try {\n+                authProvidersRegistrationSvc.registerProvider(authProvidersRegistrationSvc.loadProvider(row));\n+                return ok(String.format(\"Authentication Provider %s enabled\", row.getId()));\n+            } catch (AuthenticationProviderFactoryNotFoundException ex) {\n+                return notFound(String.format(\"Can't instantiate provider, as there's no factory with alias %s\", row.getFactoryAlias()));\n+            } catch (AuthorizationSetupException ex) {\n+                logger.log(Level.WARNING, \"Error instantiating authentication provider: \" + ex.getMessage(), ex);\n+                return error(Status.INTERNAL_SERVER_ERROR, String.format(\"Can't instantiate provider: %s\", ex.getMessage()));\n+            }\n+        } else {\n+            // disable a provider\n+            authProvidersRegistrationSvc.deregisterProvider(id);\n+            return ok(\"Authentication Provider '\" + id + \"' disabled. \" + (authSvc.getAuthenticationProviderIds().isEmpty() ? \"WARNING: no enabled authentication providers left.\" : \"\"));\n+        }\n+    }\n+\n+    @GET\n+    @Path(\"authenticationProviders/{id}/enabled\")\n+    public Response checkAuthenticationProviderEnabled(@PathParam(\"id\") String id) {\n+        List<AuthenticationProviderRow> prvs = em.createNamedQuery(\"AuthenticationProviderRow.findById\", AuthenticationProviderRow.class).setParameter(\"id\", id).getResultList();\n+        if (prvs.isEmpty()) {\n+            return notFound(\"Can't find a provider with id '\" + id + \"'.\");\n+        } else {\n+            return ok(Boolean.toString(prvs.get(0).isEnabled()));\n+        }\n+    }\n+\n+    @DELETE\n+    @Path(\"authenticationProviders/{id}/\")\n+    public Response deleteAuthenticationProvider(@PathParam(\"id\") String id) {\n+        authProvidersRegistrationSvc.deregisterProvider(id);\n+        AuthenticationProviderRow row = em.find(AuthenticationProviderRow.class, id);\n+        if (row != null) {\n+            em.remove(row);\n+        }\n+        return ok(\"AuthenticationProvider \" + id + \" deleted. \" + (authSvc.getAuthenticationProviderIds().isEmpty() ? \"WARNING: no enabled authentication providers left.\" : \"\"));\n+    }\n \n     @GET\n     @Path(\"authenticatedUsers/{identifier}/\")\n@@ -351,7 +347,7 @@ public class Admin extends AbstractApiBean {\n         }\n         return error(Response.Status.BAD_REQUEST, \"User \" + identifier + \" not found.\");\n     }\n-    \n+\n     @DELETE\n     @Path(\"authenticatedUsers/id/{id}/\")\n     public Response deleteAuthenticatedUserById(@PathParam(\"id\") Long id) {\n@@ -367,9 +363,7 @@ public class Admin extends AbstractApiBean {\n         //getDeleteUserErrorMessages does all of the tests to see\n         //if the user is 'deletable' if it returns an empty string the user \n         //can be safely deleted.\n-        \n         String errorMessages = authSvc.getDeleteUserErrorMessages(au);\n-        \n         if (!errorMessages.isEmpty()) {\n             return badRequest(errorMessages);\n         }\n@@ -377,7 +371,6 @@ public class Admin extends AbstractApiBean {\n         //if the user is deletable we will delete access requests and group membership\n         // many-to-many relationships that couldn't be cascade deleted\n         authSvc.removeAuthentictedUserItems(au);\n-        \n         authSvc.deleteAuthenticatedUser(au.getId());\n         return ok(\"AuthenticatedUser \" + au.getIdentifier() + \" deleted.\");\n     }\n@@ -405,7 +398,8 @@ public class Admin extends AbstractApiBean {\n     private Response deactivateAuthenticatedUser(AuthenticatedUser userToDisable) {\n         AuthenticatedUser superuser = authSvc.getAdminUser();\n         if (superuser == null) {\n-            return error(Response.Status.INTERNAL_SERVER_ERROR, \"Cannot find superuser to execute DeactivateUserCommand.\");\n+            return error(Response.Status.INTERNAL_SERVER_ERROR,\n+                \"Cannot find superuser to execute DeactivateUserCommand.\");\n         }\n         try {\n             execCommand(new DeactivateUserCommand(createDataverseRequest(superuser), userToDisable));\n@@ -415,521 +409,513 @@ public class Admin extends AbstractApiBean {\n         }\n     }\n \n-\t@POST\n-\t@Path(\"publishDataverseAsCreator/{id}\")\n-\tpublic Response publishDataverseAsCreator(@PathParam(\"id\") long id) {\n-\t\ttry {\n-\t\t\tDataverse dataverse = dataverseSvc.find(id);\n-\t\t\tif (dataverse != null) {\n-\t\t\t\tAuthenticatedUser authenticatedUser = dataverse.getCreator();\n-\t\t\t\treturn ok(json(execCommand(\n-\t\t\t\t\t\tnew PublishDataverseCommand(createDataverseRequest(authenticatedUser), dataverse))));\n-\t\t\t} else {\n-\t\t\t\treturn error(Status.BAD_REQUEST, \"Could not find dataverse with id \" + id);\n-\t\t\t}\n-\t\t} catch (WrappedResponse wr) {\n-\t\t\treturn wr.getResponse();\n-\t\t}\n-\t}\n-\n-\t@Deprecated\n-\t@GET\n-\t@Path(\"authenticatedUsers\")\n-\tpublic Response listAuthenticatedUsers() {\n-\t\ttry {\n-\t\t\tAuthenticatedUser user = findAuthenticatedUserOrDie();\n-\t\t\tif (!user.isSuperuser()) {\n-\t\t\t\treturn error(Response.Status.FORBIDDEN, \"Superusers only.\");\n-\t\t\t}\n-\t\t} catch (WrappedResponse ex) {\n-\t\t\treturn error(Response.Status.FORBIDDEN, \"Superusers only.\");\n-\t\t}\n-\t\tJsonArrayBuilder userArray = Json.createArrayBuilder();\n-\t\tauthSvc.findAllAuthenticatedUsers().stream().forEach((user) -> {\n-\t\t\tuserArray.add(json(user));\n-\t\t});\n-\t\treturn ok(userArray);\n-\t}\n-\n-\t@GET\n-\t@Path(listUsersPartialAPIPath)\n-\t@Produces({ \"application/json\" })\n-\tpublic Response filterAuthenticatedUsers(\n-\t\t\t@QueryParam(\"searchTerm\") String searchTerm,\n-\t\t\t@QueryParam(\"selectedPage\") Integer selectedPage,\n-\t\t\t@QueryParam(\"itemsPerPage\") Integer itemsPerPage,\n-\t\t\t@QueryParam(\"sortKey\") String sortKey\n-\t) {\n-\n-\t\tUser authUser;\n-\t\ttry {\n-\t\t\tauthUser = this.findUserOrDie();\n-\t\t} catch (AbstractApiBean.WrappedResponse ex) {\n-\t\t\treturn error(Response.Status.FORBIDDEN,\n-\t\t\t\t\tBundleUtil.getStringFromBundle(\"dashboard.list_users.api.auth.invalid_apikey\"));\n-\t\t}\n-\n-\t\tif (!authUser.isSuperuser()) {\n-\t\t\treturn error(Response.Status.FORBIDDEN,\n-\t\t\t\t\tBundleUtil.getStringFromBundle(\"dashboard.list_users.api.auth.not_superuser\"));\n-\t\t}\n-\n-\t\tUserListMaker userListMaker = new UserListMaker(userService);\n-\n-\t\t// String sortKey = null;\n-\t\tUserListResult userListResult = userListMaker.runUserSearch(searchTerm, itemsPerPage, selectedPage, sortKey);\n-\n-\t\treturn ok(userListResult.toJSON());\n-\t}\n-\n-\t/**\n-\t * @todo Make this support creation of BuiltInUsers.\n-\t *\n-\t * @todo Add way more error checking. Only the happy path is tested by AdminIT.\n-\t */\n-\t@POST\n-\t@Path(\"authenticatedUsers\")\n-\tpublic Response createAuthenicatedUser(JsonObject jsonObject) {\n-\t\tlogger.fine(\"JSON in: \" + jsonObject);\n-\t\tString persistentUserId = jsonObject.getString(\"persistentUserId\");\n-\t\tString identifier = jsonObject.getString(\"identifier\");\n-\t\tString proposedAuthenticatedUserIdentifier = identifier.replaceFirst(\"@\", \"\");\n-\t\tString firstName = jsonObject.getString(\"firstName\");\n-\t\tString lastName = jsonObject.getString(\"lastName\");\n-\t\tString emailAddress = jsonObject.getString(\"email\");\n-\t\tString position = null;\n-\t\tString affiliation = null;\n-\t\tUserRecordIdentifier userRecordId = new UserRecordIdentifier(jsonObject.getString(\"authenticationProviderId\"),\n-\t\t\t\tpersistentUserId);\n-\t\tAuthenticatedUserDisplayInfo userDisplayInfo = new AuthenticatedUserDisplayInfo(firstName, lastName,\n-\t\t\t\temailAddress, affiliation, position);\n-\t\tboolean generateUniqueIdentifier = true;\n-\t\tAuthenticatedUser authenticatedUser = authSvc.createAuthenticatedUser(userRecordId,\n-\t\t\t\tproposedAuthenticatedUserIdentifier, userDisplayInfo, true);\n-\t\treturn ok(json(authenticatedUser));\n-\t}\n+    @POST\n+    @Path(\"publishDataverseAsCreator/{id}\")\n+    public Response publishDataverseAsCreator(@PathParam(\"id\") long id) {\n+        try {\n+            Dataverse dataverse = dataverseSvc.find(id);\n+            if (dataverse != null) {\n+                AuthenticatedUser authenticatedUser = dataverse.getCreator();\n+                return ok(json(execCommand(new PublishDataverseCommand(createDataverseRequest(authenticatedUser), dataverse))));\n+            } else {\n+                return error(Status.BAD_REQUEST, \"Could not find dataverse with id \" + id);\n+            }\n+        } catch (WrappedResponse wr) {\n+            return wr.getResponse();\n+        }\n+    }\n+\n+    @Deprecated\n+    @GET\n+    @Path(\"authenticatedUsers\")\n+    public Response listAuthenticatedUsers() {\n+        try {\n+            AuthenticatedUser user = findAuthenticatedUserOrDie();\n+            if (!user.isSuperuser()) {\n+                return error(Response.Status.FORBIDDEN, \"Superusers only.\");\n+            }\n+        } catch (WrappedResponse ex) {\n+            return error(Response.Status.FORBIDDEN, \"Superusers only.\");\n+        }\n+\n+        JsonArrayBuilder userArray = Json.createArrayBuilder();\n+        authSvc.findAllAuthenticatedUsers().stream().forEach((user) -> {\n+            userArray.add(json(user));\n+        });\n+        return ok(userArray);\n+    }\n+\n+    @GET\n+    @Path(listUsersPartialAPIPath)\n+    @Produces({\"application/json\" })\n+    public Response filterAuthenticatedUsers(@QueryParam(\"searchTerm\") String searchTerm, @QueryParam(\"selectedPage\") Integer selectedPage, @QueryParam(\"itemsPerPage\") Integer itemsPerPage, @QueryParam(\"sortKey\") String sortKey) {\n+        User authUser;\n+        try {\n+            authUser = this.findUserOrDie();\n+        } catch (AbstractApiBean.WrappedResponse ex) {\n+            return error(Response.Status.FORBIDDEN,\n+                BundleUtil.getStringFromBundle(\"dashboard.list_users.api.auth.invalid_apikey\")\n+            );\n+        }\n+\n+        if (!authUser.isSuperuser()) {\n+            return error(Response.Status.FORBIDDEN,\n+                BundleUtil.getStringFromBundle(\"dashboard.list_users.api.auth.not_superuser\")\n+            );\n+        }\n+\n+        UserListMaker userListMaker = new UserListMaker(userService);\n+\n+        // String sortKey = null;\n+        UserListResult userListResult = userListMaker.runUserSearch(searchTerm, itemsPerPage, selectedPage, sortKey);\n+        return ok(userListResult.toJSON());\n+    }\n+\n+    /**\n+     * @todo Make this support creation of BuiltInUsers.\n+     *\n+     * @todo Add way more error checking. Only the happy path is tested by AdminIT.\n+     */\n+\n+    @POST\n+    @Path(\"authenticatedUsers\")\n+    public Response createAuthenicatedUser(JsonObject jsonObject) {\n+        logger.fine(\"JSON in: \" + jsonObject);\n+        String persistentUserId = jsonObject.getString(\"persistentUserId\");\n+        String identifier = jsonObject.getString(\"identifier\");\n+        String proposedAuthenticatedUserIdentifier = identifier.replaceFirst(\"@\", \"\");\n+        String firstName = jsonObject.getString(\"firstName\");\n+        String lastName = jsonObject.getString(\"lastName\");\n+        String emailAddress = jsonObject.getString(\"email\");\n+        String position = null;\n+        String affiliation = null;\n+        UserRecordIdentifier userRecordId = new UserRecordIdentifier(jsonObject.getString(\"authenticationProviderId\"), persistentUserId);\n+        AuthenticatedUserDisplayInfo userDisplayInfo = new AuthenticatedUserDisplayInfo(firstName, lastName, emailAddress, affiliation, position);\n+        boolean generateUniqueIdentifier = true;\n+        AuthenticatedUser authenticatedUser = authSvc.createAuthenticatedUser(userRecordId, proposedAuthenticatedUserIdentifier, userDisplayInfo, true);\n+        return ok(json(authenticatedUser));\n+    }\n \n         //TODO: Delete this endpoint after 4.9.3. Was updated with change in docs. --MAD\n-\t/**\n-\t * curl -X PUT -d \"shib@mailinator.com\"\n-\t * http://localhost:8080/api/admin/authenticatedUsers/id/11/convertShibToBuiltIn\n-\t *\n-\t * @deprecated We have documented this API endpoint so we'll keep in around for\n-\t *             a while but we should encourage everyone to switch to the\n-\t *             \"convertRemoteToBuiltIn\" endpoint and then remove this\n-\t *             Shib-specfic one.\n-\t */\n-\t@PUT\n-\t@Path(\"authenticatedUsers/id/{id}/convertShibToBuiltIn\")\n-\t@Deprecated\n-\tpublic Response convertShibUserToBuiltin(@PathParam(\"id\") Long id, String newEmailAddress) {\n-                try {\n-                        AuthenticatedUser user = findAuthenticatedUserOrDie();\n-\t\t\tif (!user.isSuperuser()) {\n-\t\t\t\treturn error(Response.Status.FORBIDDEN, \"Superusers only.\");\n-\t\t\t}\n-\t\t} catch (WrappedResponse ex) {\n-\t\t\treturn error(Response.Status.FORBIDDEN, \"Superusers only.\");\n-\t\t}\n-\t\ttry {\n-\t\t\tBuiltinUser builtinUser = authSvc.convertRemoteToBuiltIn(id, newEmailAddress);\n-\t\t\tif (builtinUser == null) {\n-\t\t\t\treturn error(Response.Status.BAD_REQUEST, \"User id \" + id\n-\t\t\t\t\t\t+ \" could not be converted from Shibboleth to BuiltIn. An Exception was not thrown.\");\n-\t\t\t}\n-                        AuthenticatedUser authUser = authSvc.getAuthenticatedUser(builtinUser.getUserName());\n-\t\t\tJsonObjectBuilder output = Json.createObjectBuilder();\n-\t\t\toutput.add(\"email\", authUser.getEmail());\n-\t\t\toutput.add(\"username\", builtinUser.getUserName());\n-\t\t\treturn ok(output);\n-\t\t} catch (Throwable ex) {\n-\t\t\tStringBuilder sb = new StringBuilder();\n-\t\t\tsb.append(ex + \" \");\n-\t\t\twhile (ex.getCause() != null) {\n-\t\t\t\tex = ex.getCause();\n-\t\t\t\tsb.append(ex + \" \");\n-\t\t\t}\n-\t\t\tString msg = \"User id \" + id\n-\t\t\t\t\t+ \" could not be converted from Shibboleth to BuiltIn. Details from Exception: \" + sb;\n-\t\t\tlogger.info(msg);\n-\t\t\treturn error(Response.Status.BAD_REQUEST, msg);\n-\t\t}\n-\t}\n-\n-\t@PUT\n-\t@Path(\"authenticatedUsers/id/{id}/convertRemoteToBuiltIn\")\n-\tpublic Response convertOAuthUserToBuiltin(@PathParam(\"id\") Long id, String newEmailAddress) {\n-                try {\n-\t\t\tAuthenticatedUser user = findAuthenticatedUserOrDie();\n-\t\t\tif (!user.isSuperuser()) {\n-\t\t\t\treturn error(Response.Status.FORBIDDEN, \"Superusers only.\");\n-\t\t\t}\n-\t\t} catch (WrappedResponse ex) {\n-\t\t\treturn error(Response.Status.FORBIDDEN, \"Superusers only.\");\n-\t\t}\n-\t\ttry {\n-\t\t\tBuiltinUser builtinUser = authSvc.convertRemoteToBuiltIn(id, newEmailAddress);\n+    /**\n+     * curl -X PUT -d \"shib@mailinator.com\"\n+     * http://localhost:8080/api/admin/authenticatedUsers/id/11/convertShibToBuiltIn\n+     *\n+     * @deprecated We have documented this API endpoint so we'll keep in around for\n+     *             a while but we should encourage everyone to switch to the\n+     *             \"convertRemoteToBuiltIn\" endpoint and then remove this\n+     *             Shib-specfic one.\n+     */\n+\n+    @PUT\n+    @Path(\"authenticatedUsers/id/{id}/convertShibToBuiltIn\")\n+    @Deprecated\n+    public Response convertShibUserToBuiltin(@PathParam(\"id\") Long id, String newEmailAddress) {\n+        try {\n+            AuthenticatedUser user = findAuthenticatedUserOrDie();\n+            if (!user.isSuperuser()) {\n+                return error(Response.Status.FORBIDDEN, \"Superusers only.\");\n+            }\n+        } catch (WrappedResponse ex) {\n+            return error(Response.Status.FORBIDDEN, \"Superusers only.\");\n+        }\n+        try {\n+            BuiltinUser builtinUser = authSvc.convertRemoteToBuiltIn(id, newEmailAddress);\n+            if (builtinUser == null) {\n+                return error(Response.Status.BAD_REQUEST, \"User id \" + id + \" could not be converted from Shibboleth to BuiltIn. An Exception was not thrown.\");\n+            }\n+\n+            AuthenticatedUser authUser = authSvc.getAuthenticatedUser(builtinUser.getUserName());\n+            JsonObjectBuilder output = Json.createObjectBuilder();\n+            output.add(\"email\", authUser.getEmail());\n+            output.add(\"username\", builtinUser.getUserName());\n+            return ok(output);\n+        } catch (Throwable ex) {\n+            StringBuilder sb = new StringBuilder();\n+            sb.append(ex + \" \");\n+            while (ex.getCause() != null) {\n+                ex = ex.getCause();\n+                sb.append(ex + \" \");\n+            }\n+\n+            String msg = \"User id \" + id + \" could not be converted from Shibboleth to BuiltIn. Details from Exception: \" + sb;\n+            logger.info(msg);\n+            return error(Response.Status.BAD_REQUEST, msg);\n+        }\n+    }\n+\n+    @PUT\n+    @Path(\"authenticatedUsers/id/{id}/convertRemoteToBuiltIn\")\n+    public Response convertOAuthUserToBuiltin(@PathParam(\"id\") Long id, String newEmailAddress) {\n+        try {\n+            AuthenticatedUser user = findAuthenticatedUserOrDie();\n+            if (!user.isSuperuser()) {\n+                return error(Response.Status.FORBIDDEN, \"Superusers only.\");\n+            }\n+        } catch (WrappedResponse ex) {\n+            return error(Response.Status.FORBIDDEN, \"Superusers only.\");\n+        }\n+        try {\n+            BuiltinUser builtinUser = authSvc.convertRemoteToBuiltIn(id, newEmailAddress);\n                         //AuthenticatedUser authUser = authService.getAuthenticatedUser(aUser.getUserName());\n-\t\t\tif (builtinUser == null) {\n-\t\t\t\treturn error(Response.Status.BAD_REQUEST, \"User id \" + id\n-\t\t\t\t\t\t+ \" could not be converted from remote to BuiltIn. An Exception was not thrown.\");\n-\t\t\t}\n-                        AuthenticatedUser authUser = authSvc.getAuthenticatedUser(builtinUser.getUserName());\n-\t\t\tJsonObjectBuilder output = Json.createObjectBuilder();\n-\t\t\toutput.add(\"email\", authUser.getEmail());\n-\t\t\toutput.add(\"username\", builtinUser.getUserName());\n-\t\t\treturn ok(output);\n-\t\t} catch (Throwable ex) {\n-\t\t\tStringBuilder sb = new StringBuilder();\n-\t\t\tsb.append(ex + \" \");\n-\t\t\twhile (ex.getCause() != null) {\n-\t\t\t\tex = ex.getCause();\n-\t\t\t\tsb.append(ex + \" \");\n-\t\t\t}\n-\t\t\tString msg = \"User id \" + id + \" could not be converted from remote to BuiltIn. Details from Exception: \"\n-\t\t\t\t\t+ sb;\n-\t\t\tlogger.info(msg);\n-\t\t\treturn error(Response.Status.BAD_REQUEST, msg);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * This is used in testing via AdminIT.java but we don't expect sysadmins to use\n-\t * this.\n-\t */\n-\t@Path(\"authenticatedUsers/convert/builtin2shib\")\n-\t@PUT\n-\tpublic Response builtin2shib(String content) {\n-\t\tlogger.info(\"entering builtin2shib...\");\n-\t\ttry {\n-\t\t\tAuthenticatedUser userToRunThisMethod = findAuthenticatedUserOrDie();\n-\t\t\tif (!userToRunThisMethod.isSuperuser()) {\n-\t\t\t\treturn error(Response.Status.FORBIDDEN, \"Superusers only.\");\n-\t\t\t}\n-\t\t} catch (WrappedResponse ex) {\n-\t\t\treturn error(Response.Status.FORBIDDEN, \"Superusers only.\");\n-\t\t}\n-\t\tboolean disabled = false;\n-\t\tif (disabled) {\n-\t\t\treturn error(Response.Status.BAD_REQUEST, \"API endpoint disabled.\");\n-\t\t}\n-\t\tAuthenticatedUser builtInUserToConvert = null;\n-\t\tString emailToFind;\n-\t\tString password;\n-\t\tString authuserId = \"0\"; // could let people specify id on authuser table. probably better to let them\n-\t\t\t\t\t\t\t\t\t// tell us their\n-\t\tString newEmailAddressToUse;\n-\t\ttry {\n-\t\t\tString[] args = content.split(\":\");\n-\t\t\temailToFind = args[0];\n-\t\t\tpassword = args[1];\n-\t\t\tnewEmailAddressToUse = args[2];\n-\t\t\t// authuserId = args[666];\n-\t\t} catch (ArrayIndexOutOfBoundsException ex) {\n-\t\t\treturn error(Response.Status.BAD_REQUEST, \"Problem with content <<<\" + content + \">>>: \" + ex.toString());\n-\t\t}\n-\t\tAuthenticatedUser existingAuthUserFoundByEmail = shibService.findAuthUserByEmail(emailToFind);\n-\t\tString existing = \"NOT FOUND\";\n-\t\tif (existingAuthUserFoundByEmail != null) {\n-\t\t\tbuiltInUserToConvert = existingAuthUserFoundByEmail;\n-\t\t\texisting = existingAuthUserFoundByEmail.getIdentifier();\n-\t\t} else {\n-\t\t\tlong longToLookup = Long.parseLong(authuserId);\n-\t\t\tAuthenticatedUser specifiedUserToConvert = authSvc.findByID(longToLookup);\n-\t\t\tif (specifiedUserToConvert != null) {\n-\t\t\t\tbuiltInUserToConvert = specifiedUserToConvert;\n-\t\t\t} else {\n-\t\t\t\treturn error(Response.Status.BAD_REQUEST,\n-\t\t\t\t\t\t\"No user to convert. We couldn't find a *single* existing user account based on \" + emailToFind\n-\t\t\t\t\t\t\t\t+ \" and no user was found using specified id \" + longToLookup);\n-\t\t\t}\n-\t\t}\n-\t\tString shibProviderId = ShibAuthenticationProvider.PROVIDER_ID;\n-\t\tMap<String, String> randomUser = authTestDataService.getRandomUser();\n-\t\t// String eppn = UUID.randomUUID().toString().substring(0, 8);\n-\t\tString eppn = randomUser.get(\"eppn\");\n-\t\tString idPEntityId = randomUser.get(\"idp\");\n-\t\tString notUsed = null;\n-\t\tString separator = \"|\";\n-\t\tUserIdentifier newUserIdentifierInLookupTable = new UserIdentifier(idPEntityId + separator + eppn, notUsed);\n-\t\tString overwriteFirstName = randomUser.get(\"firstName\");\n-\t\tString overwriteLastName = randomUser.get(\"lastName\");\n-\t\tString overwriteEmail = randomUser.get(\"email\");\n-\t\toverwriteEmail = newEmailAddressToUse;\n-\t\tlogger.info(\"overwriteEmail: \" + overwriteEmail);\n-\t\tboolean validEmail = EMailValidator.isEmailValid(overwriteEmail, null);\n-\t\tif (!validEmail) {\n-\t\t\t// See https://github.com/IQSS/dataverse/issues/2998\n-\t\t\treturn error(Response.Status.BAD_REQUEST, \"invalid email: \" + overwriteEmail);\n-\t\t}\n-\t\t/**\n-\t\t * @todo If affiliation is not null, put it in RoleAssigneeDisplayInfo\n-\t\t *       constructor.\n-\t\t */\n-\t\t/**\n-\t\t * Here we are exercising (via an API test) shibService.getAffiliation with the\n-\t\t * TestShib IdP and a non-production DevShibAccountType.\n-\t\t */\n-\t\tidPEntityId = ShibUtil.testShibIdpEntityId;\n-\t\tString overwriteAffiliation = shibService.getAffiliation(idPEntityId,\n-\t\t\t\tShibServiceBean.DevShibAccountType.RANDOM);\n-\t\tlogger.info(\"overwriteAffiliation: \" + overwriteAffiliation);\n-\t\t/**\n-\t\t * @todo Find a place to put \"position\" in the authenticateduser table:\n-\t\t *       https://github.com/IQSS/dataverse/issues/1444#issuecomment-74134694\n-\t\t */\n-\t\tString overwritePosition = \"staff;student\";\n-\t\tAuthenticatedUserDisplayInfo displayInfo = new AuthenticatedUserDisplayInfo(overwriteFirstName,\n-\t\t\t\toverwriteLastName, overwriteEmail, overwriteAffiliation, overwritePosition);\n-\t\tJsonObjectBuilder response = Json.createObjectBuilder();\n-\t\tJsonArrayBuilder problems = Json.createArrayBuilder();\n-\t\tif (password != null) {\n-\t\t\tresponse.add(\"password supplied\", password);\n-\t\t\tboolean knowsExistingPassword = false;\n-\t\t\tBuiltinUser oldBuiltInUser = builtinUserService.findByUserName(builtInUserToConvert.getUserIdentifier());\n-\t\t\tif (oldBuiltInUser != null) {\n-                                if (builtInUserToConvert.isDeactivated()) {\n-                                        problems.add(\"builtin account has been deactivated\");\n-                                        return error(Status.BAD_REQUEST, problems.build().toString());\n-                                }\n-\t\t\t\tString usernameOfBuiltinAccountToConvert = oldBuiltInUser.getUserName();\n-\t\t\t\tresponse.add(\"old username\", usernameOfBuiltinAccountToConvert);\n-\t\t\t\tAuthenticatedUser authenticatedUser = authSvc.canLogInAsBuiltinUser(usernameOfBuiltinAccountToConvert,\n-\t\t\t\t\t\tpassword);\n-\t\t\t\tif (authenticatedUser != null) {\n-\t\t\t\t\tknowsExistingPassword = true;\n-\t\t\t\t\tAuthenticatedUser convertedUser = authSvc.convertBuiltInToShib(builtInUserToConvert, shibProviderId,\n-\t\t\t\t\t\t\tnewUserIdentifierInLookupTable);\n-\t\t\t\t\tif (convertedUser != null) {\n-\t\t\t\t\t\t/**\n-\t\t\t\t\t\t * @todo Display name is not being overwritten. Logic must be in Shib backing\n-\t\t\t\t\t\t *       bean\n-\t\t\t\t\t\t */\n-\t\t\t\t\t\tAuthenticatedUser updatedInfoUser = authSvc.updateAuthenticatedUser(convertedUser, displayInfo);\n-\t\t\t\t\t\tif (updatedInfoUser != null) {\n-\t\t\t\t\t\t\tresponse.add(\"display name overwritten with\", updatedInfoUser.getName());\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tproblems.add(\"couldn't update display info\");\n-\t\t\t\t\t\t}\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tproblems.add(\"unable to convert user\");\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\tproblems.add(\"couldn't find old username\");\n-\t\t\t}\n-\t\t\tif (!knowsExistingPassword) {\n-\t\t\t\tString message = \"User doesn't know password.\";\n-\t\t\t\tproblems.add(message);\n-\t\t\t\t/**\n-\t\t\t\t * @todo Someday we should make a errorResponse method that takes JSON arrays\n-\t\t\t\t *       and objects.\n-\t\t\t\t */\n-\t\t\t\treturn error(Status.BAD_REQUEST, problems.build().toString());\n-\t\t\t}\n-\t\t\t// response.add(\"knows existing password\", knowsExistingPassword);\n-\t\t}\n-\n-\t\tresponse.add(\"user to convert\", builtInUserToConvert.getIdentifier());\n-\t\tresponse.add(\"existing user found by email (prompt to convert)\", existing);\n-\t\tresponse.add(\"changing to this provider\", shibProviderId);\n-\t\tresponse.add(\"value to overwrite old first name\", overwriteFirstName);\n-\t\tresponse.add(\"value to overwrite old last name\", overwriteLastName);\n-\t\tresponse.add(\"value to overwrite old email address\", overwriteEmail);\n-\t\tif (overwriteAffiliation != null) {\n-\t\t\tresponse.add(\"affiliation\", overwriteAffiliation);\n-\t\t}\n-\t\tresponse.add(\"problems\", problems);\n-\t\treturn ok(response);\n-\t}\n-\n-\t/**\n-\t * This is used in testing via AdminIT.java but we don't expect sysadmins to use\n-\t * this.\n-\t */\n-\t@Path(\"authenticatedUsers/convert/builtin2oauth\")\n-\t@PUT\n-\tpublic Response builtin2oauth(String content) {\n-\t\tlogger.info(\"entering builtin2oauth...\");\n-\t\ttry {\n-\t\t\tAuthenticatedUser userToRunThisMethod = findAuthenticatedUserOrDie();\n-\t\t\tif (!userToRunThisMethod.isSuperuser()) {\n-\t\t\t\treturn error(Response.Status.FORBIDDEN, \"Superusers only.\");\n-\t\t\t}\n-\t\t} catch (WrappedResponse ex) {\n-\t\t\treturn error(Response.Status.FORBIDDEN, \"Superusers only.\");\n-\t\t}\n-\t\tboolean disabled = false;\n-\t\tif (disabled) {\n-\t\t\treturn error(Response.Status.BAD_REQUEST, \"API endpoint disabled.\");\n-\t\t}\n-\t\tAuthenticatedUser builtInUserToConvert = null;\n-\t\tString emailToFind;\n-\t\tString password;\n-\t\tString authuserId = \"0\"; // could let people specify id on authuser table. probably better to let them\n-\t\t\t\t\t\t\t\t\t// tell us their\n-\t\tString newEmailAddressToUse;\n-\t\tString newProviderId;\n-\t\tString newPersistentUserIdInLookupTable;\n-\t\tlogger.info(\"content: \" + content);\n-\t\ttry {\n-\t\t\tString[] args = content.split(\":\");\n-\t\t\temailToFind = args[0];\n-\t\t\tpassword = args[1];\n-\t\t\tnewEmailAddressToUse = args[2];\n-\t\t\tnewProviderId = args[3];\n-\t\t\tnewPersistentUserIdInLookupTable = args[4];\n-\t\t\t// authuserId = args[666];\n-\t\t} catch (ArrayIndexOutOfBoundsException ex) {\n-\t\t\treturn error(Response.Status.BAD_REQUEST, \"Problem with content <<<\" + content + \">>>: \" + ex.toString());\n-\t\t}\n-\t\tAuthenticatedUser existingAuthUserFoundByEmail = shibService.findAuthUserByEmail(emailToFind);\n-\t\tString existing = \"NOT FOUND\";\n-\t\tif (existingAuthUserFoundByEmail != null) {\n-\t\t\tbuiltInUserToConvert = existingAuthUserFoundByEmail;\n-\t\t\texisting = existingAuthUserFoundByEmail.getIdentifier();\n-\t\t} else {\n-\t\t\tlong longToLookup = Long.parseLong(authuserId);\n-\t\t\tAuthenticatedUser specifiedUserToConvert = authSvc.findByID(longToLookup);\n-\t\t\tif (specifiedUserToConvert != null) {\n-\t\t\t\tbuiltInUserToConvert = specifiedUserToConvert;\n-\t\t\t} else {\n-\t\t\t\treturn error(Response.Status.BAD_REQUEST,\n-\t\t\t\t\t\t\"No user to convert. We couldn't find a *single* existing user account based on \" + emailToFind\n-\t\t\t\t\t\t\t\t+ \" and no user was found using specified id \" + longToLookup);\n-\t\t\t}\n-\t\t}\n-\t\t// String shibProviderId = ShibAuthenticationProvider.PROVIDER_ID;\n-\t\tMap<String, String> randomUser = authTestDataService.getRandomUser();\n-\t\t// String eppn = UUID.randomUUID().toString().substring(0, 8);\n-\t\tString eppn = randomUser.get(\"eppn\");\n-\t\tString idPEntityId = randomUser.get(\"idp\");\n-\t\tString notUsed = null;\n-\t\tString separator = \"|\";\n-\t\t// UserIdentifier newUserIdentifierInLookupTable = new\n-\t\t// UserIdentifier(idPEntityId + separator + eppn, notUsed);\n-\t\tUserIdentifier newUserIdentifierInLookupTable = new UserIdentifier(newPersistentUserIdInLookupTable, notUsed);\n-\t\tString overwriteFirstName = randomUser.get(\"firstName\");\n-\t\tString overwriteLastName = randomUser.get(\"lastName\");\n-\t\tString overwriteEmail = randomUser.get(\"email\");\n-\t\toverwriteEmail = newEmailAddressToUse;\n-\t\tlogger.info(\"overwriteEmail: \" + overwriteEmail);\n-\t\tboolean validEmail = EMailValidator.isEmailValid(overwriteEmail, null);\n-\t\tif (!validEmail) {\n-\t\t\t// See https://github.com/IQSS/dataverse/issues/2998\n-\t\t\treturn error(Response.Status.BAD_REQUEST, \"invalid email: \" + overwriteEmail);\n-\t\t}\n-\t\t/**\n-\t\t * @todo If affiliation is not null, put it in RoleAssigneeDisplayInfo\n-\t\t *       constructor.\n-\t\t */\n-\t\t/**\n-\t\t * Here we are exercising (via an API test) shibService.getAffiliation with the\n-\t\t * TestShib IdP and a non-production DevShibAccountType.\n-\t\t */\n-\t\t// idPEntityId = ShibUtil.testShibIdpEntityId;\n-\t\t// String overwriteAffiliation = shibService.getAffiliation(idPEntityId,\n-\t\t// ShibServiceBean.DevShibAccountType.RANDOM);\n-\t\tString overwriteAffiliation = null;\n-\t\tlogger.info(\"overwriteAffiliation: \" + overwriteAffiliation);\n-\t\t/**\n-\t\t * @todo Find a place to put \"position\" in the authenticateduser table:\n-\t\t *       https://github.com/IQSS/dataverse/issues/1444#issuecomment-74134694\n-\t\t */\n-\t\tString overwritePosition = \"staff;student\";\n-\t\tAuthenticatedUserDisplayInfo displayInfo = new AuthenticatedUserDisplayInfo(overwriteFirstName,\n-\t\t\t\toverwriteLastName, overwriteEmail, overwriteAffiliation, overwritePosition);\n-\t\tJsonObjectBuilder response = Json.createObjectBuilder();\n-\t\tJsonArrayBuilder problems = Json.createArrayBuilder();\n-\t\tif (password != null) {\n-\t\t\tresponse.add(\"password supplied\", password);\n-\t\t\tboolean knowsExistingPassword = false;\n-\t\t\tBuiltinUser oldBuiltInUser = builtinUserService.findByUserName(builtInUserToConvert.getUserIdentifier());\n-\t\t\tif (oldBuiltInUser != null) {\n-\t\t\t\tString usernameOfBuiltinAccountToConvert = oldBuiltInUser.getUserName();\n-\t\t\t\tresponse.add(\"old username\", usernameOfBuiltinAccountToConvert);\n-\t\t\t\tAuthenticatedUser authenticatedUser = authSvc.canLogInAsBuiltinUser(usernameOfBuiltinAccountToConvert,\n-\t\t\t\t\t\tpassword);\n-\t\t\t\tif (authenticatedUser != null) {\n-\t\t\t\t\tknowsExistingPassword = true;\n-\t\t\t\t\tAuthenticatedUser convertedUser = authSvc.convertBuiltInUserToRemoteUser(builtInUserToConvert,\n-\t\t\t\t\t\t\tnewProviderId, newUserIdentifierInLookupTable);\n-\t\t\t\t\tif (convertedUser != null) {\n-\t\t\t\t\t\t/**\n-\t\t\t\t\t\t * @todo Display name is not being overwritten. Logic must be in Shib backing\n-\t\t\t\t\t\t *       bean\n-\t\t\t\t\t\t */\n-\t\t\t\t\t\tAuthenticatedUser updatedInfoUser = authSvc.updateAuthenticatedUser(convertedUser, displayInfo);\n-\t\t\t\t\t\tif (updatedInfoUser != null) {\n-\t\t\t\t\t\t\tresponse.add(\"display name overwritten with\", updatedInfoUser.getName());\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tproblems.add(\"couldn't update display info\");\n-\t\t\t\t\t\t}\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tproblems.add(\"unable to convert user\");\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\tproblems.add(\"couldn't find old username\");\n-\t\t\t}\n-\t\t\tif (!knowsExistingPassword) {\n-\t\t\t\tString message = \"User doesn't know password.\";\n-\t\t\t\tproblems.add(message);\n-\t\t\t\t/**\n-\t\t\t\t * @todo Someday we should make a errorResponse method that takes JSON arrays\n-\t\t\t\t *       and objects.\n-\t\t\t\t */\n-\t\t\t\treturn error(Status.BAD_REQUEST, problems.build().toString());\n-\t\t\t}\n-\t\t\t// response.add(\"knows existing password\", knowsExistingPassword);\n-\t\t}\n-\n-\t\tresponse.add(\"user to convert\", builtInUserToConvert.getIdentifier());\n-\t\tresponse.add(\"existing user found by email (prompt to convert)\", existing);\n-\t\tresponse.add(\"changing to this provider\", newProviderId);\n-\t\tresponse.add(\"value to overwrite old first name\", overwriteFirstName);\n-\t\tresponse.add(\"value to overwrite old last name\", overwriteLastName);\n-\t\tresponse.add(\"value to overwrite old email address\", overwriteEmail);\n-\t\tif (overwriteAffiliation != null) {\n-\t\t\tresponse.add(\"affiliation\", overwriteAffiliation);\n-\t\t}\n-\t\tresponse.add(\"problems\", problems);\n-\t\treturn ok(response);\n-\t}\n-\n-\n-\n-\n-\t@Path(\"roles\")\n-\t@POST\n-\tpublic Response createNewBuiltinRole(RoleDTO roleDto) {\n-\t\tActionLogRecord alr = new ActionLogRecord(ActionLogRecord.ActionType.Admin, \"createBuiltInRole\")\n-\t\t\t\t.setInfo(roleDto.getAlias() + \":\" + roleDto.getDescription());\n-\t\ttry {\n-\t\t\treturn ok(json(rolesSvc.save(roleDto.asRole())));\n-\t\t} catch (Exception e) {\n-\t\t\talr.setActionResult(ActionLogRecord.Result.InternalError);\n-\t\t\talr.setInfo(alr.getInfo() + \"// \" + e.getMessage());\n-\t\t\treturn error(Response.Status.INTERNAL_SERVER_ERROR, e.getMessage());\n-\t\t} finally {\n-\t\t\tactionLogSvc.log(alr);\n-\t\t}\n-\t}\n-\n-\t@Path(\"roles\")\n-\t@GET\n-\tpublic Response listBuiltinRoles() {\n-\t\ttry {\n-\t\t\treturn ok(rolesToJson(rolesSvc.findBuiltinRoles()));\n-\t\t} catch (Exception e) {\n-\t\t\treturn error(Response.Status.INTERNAL_SERVER_ERROR, e.getMessage());\n-\t\t}\n-\t}\n-        \n+            if (builtinUser == null) {\n+                return error(Response.Status.BAD_REQUEST,\n+                    \"User id \"\n+                        + id + \" could not be converted from remote to BuiltIn. An Exception was not thrown.\");\n+            }\n+\n+            AuthenticatedUser authUser = authSvc.getAuthenticatedUser(builtinUser.getUserName());\n+            JsonObjectBuilder output = Json.createObjectBuilder();\n+            output.add(\"email\", authUser.getEmail());\n+            output.add(\"username\", builtinUser.getUserName());\n+            return ok(output);\n+        } catch (Throwable ex) {\n+            StringBuilder sb = new StringBuilder();\n+            sb.append(ex + \" \");\n+            while (ex.getCause() != null) {\n+                ex = ex.getCause();\n+                sb.append(ex + \" \");\n+            }\n+\n+            String msg = \"User id \" + id + \" could not be converted from remote to BuiltIn. Details from Exception: \" + sb;\n+            logger.info(msg);\n+            return error(Response.Status.BAD_REQUEST, msg);\n+        }\n+    }\n+\n+    /**\n+     * This is used in testing via AdminIT.java but we don't expect sysadmins to use\n+     * this.\n+     */\n+\n+    @Path(\"authenticatedUsers/convert/builtin2shib\")\n+    @PUT\n+    public Response builtin2shib(String content) {\n+        logger.info(\"entering builtin2shib...\");\n+        try {\n+            AuthenticatedUser userToRunThisMethod = findAuthenticatedUserOrDie();\n+            if (!userToRunThisMethod.isSuperuser()) {\n+                return error(Response.Status.FORBIDDEN, \"Superusers only.\");\n+            }\n+        } catch (WrappedResponse ex) {\n+            return error(Response.Status.FORBIDDEN, \"Superusers only.\");\n+        }\n+\n+        boolean disabled = false;\n+        if (disabled) {\n+            return error(Response.Status.BAD_REQUEST, \"API endpoint disabled.\");\n+        }\n+\n+        AuthenticatedUser builtInUserToConvert = null;\n+        String emailToFind;\n+        String password;\n+        String authuserId = \"0\"; // could let people specify id on authuser table. probably better to let them\n+                                    // tell us their\n+        String newEmailAddressToUse;\n+        try {\n+            String[] args = content.split(\":\");\n+            emailToFind = args[0];\n+            password = args[1];\n+            newEmailAddressToUse = args[2];\n+            // authuserId = args[666];\n+        } catch (ArrayIndexOutOfBoundsException ex) {\n+            return error(Response.Status.BAD_REQUEST, \"Problem with content <<<\" + content + \">>>: \" + ex.toString());\n+        }\n+\n+        AuthenticatedUser existingAuthUserFoundByEmail = shibService.findAuthUserByEmail(emailToFind);\n+        String existing = \"NOT FOUND\";\n+        if (existingAuthUserFoundByEmail != null) {\n+            builtInUserToConvert = existingAuthUserFoundByEmail;\n+            existing = existingAuthUserFoundByEmail.getIdentifier();\n+        } else {\n+            long longToLookup = Long.parseLong(authuserId);\n+            AuthenticatedUser specifiedUserToConvert = authSvc.findByID(longToLookup);\n+            if (specifiedUserToConvert != null) {\n+                builtInUserToConvert = specifiedUserToConvert;\n+            } else {\n+                return error(Response.Status.BAD_REQUEST, \"No user to convert. We couldn't find a *single* existing user account based on \" + emailToFind + \" and no user was found using specified id \" + longToLookup);\n+            }\n+        }\n+\n+        String shibProviderId = ShibAuthenticationProvider.PROVIDER_ID;\n+        Map<String, String> randomUser = authTestDataService.getRandomUser();\n+        // String eppn = UUID.randomUUID().toString().substring(0, 8);\n+        String eppn = randomUser.get(\"eppn\");\n+        String idPEntityId = randomUser.get(\"idp\");\n+        String notUsed = null;\n+        String separator = \"|\";\n+        UserIdentifier newUserIdentifierInLookupTable = new UserIdentifier(idPEntityId + separator + eppn, notUsed);\n+        String overwriteFirstName = randomUser.get(\"firstName\");\n+        String overwriteLastName = randomUser.get(\"lastName\");\n+        String overwriteEmail = randomUser.get(\"email\");\n+        overwriteEmail = newEmailAddressToUse;\n+        logger.info(\"overwriteEmail: \" + overwriteEmail);\n+        boolean validEmail = EMailValidator.isEmailValid(overwriteEmail, null);\n+        if (!validEmail) {\n+            // See https://github.com/IQSS/dataverse/issues/2998\n+            return error(Response.Status.BAD_REQUEST, \"invalid email: \" + overwriteEmail);\n+        }\n+        /**\n+         * @todo If affiliation is not null, put it in RoleAssigneeDisplayInfo\n+         *       constructor.\n+         */\n+        /**\n+         * Here we are exercising (via an API test) shibService.getAffiliation with the\n+         * TestShib IdP and a non-production DevShibAccountType.\n+         */\n+        idPEntityId = ShibUtil.testShibIdpEntityId;\n+        String overwriteAffiliation = shibService.getAffiliation(idPEntityId, ShibServiceBean.DevShibAccountType.RANDOM);\n+        logger.info(\"overwriteAffiliation: \" + overwriteAffiliation);\n+        /**\n+         * @todo Find a place to put \"position\" in the authenticateduser table:\n+         *       https://github.com/IQSS/dataverse/issues/1444#issuecomment-74134694\n+         */\n+        String overwritePosition = \"staff;student\";\n+        AuthenticatedUserDisplayInfo displayInfo = new AuthenticatedUserDisplayInfo(overwriteFirstName, overwriteLastName, overwriteEmail, overwriteAffiliation, overwritePosition);\n+        JsonObjectBuilder response = Json.createObjectBuilder();\n+        JsonArrayBuilder problems = Json.createArrayBuilder();\n+        if (password != null) {\n+            response.add(\"password supplied\", password);\n+            boolean knowsExistingPassword = false;\n+            BuiltinUser oldBuiltInUser = builtinUserService.findByUserName(builtInUserToConvert.getUserIdentifier());\n+            if (oldBuiltInUser != null) {\n+                if (builtInUserToConvert.isDeactivated()) {\n+                    problems.add(\"builtin account has been deactivated\");\n+                    return error(Status.BAD_REQUEST, problems.build().toString());\n+                }\n+\n+                String usernameOfBuiltinAccountToConvert = oldBuiltInUser.getUserName();\n+                response.add(\"old username\", usernameOfBuiltinAccountToConvert);\n+                AuthenticatedUser authenticatedUser = authSvc.canLogInAsBuiltinUser(usernameOfBuiltinAccountToConvert, password);\n+                if (authenticatedUser != null) {\n+                    knowsExistingPassword = true;\n+                    AuthenticatedUser convertedUser = authSvc.convertBuiltInToShib(builtInUserToConvert, shibProviderId, newUserIdentifierInLookupTable);\n+                    if (convertedUser != null) {\n+                        /**\n+                         * @todo Display name is not being overwritten. Logic must be in Shib backing\n+                         *       bean\n+                         */\n+                        AuthenticatedUser updatedInfoUser = authSvc.updateAuthenticatedUser(convertedUser, displayInfo);\n+                        if (updatedInfoUser != null) {\n+                            response.add(\"display name overwritten with\", updatedInfoUser.getName());\n+                        } else {\n+                            problems.add(\"couldn't update display info\");\n+                        }\n+                    } else {\n+                        problems.add(\"unable to convert user\");\n+                    }\n+                }\n+            } else {\n+                problems.add(\"couldn't find old username\");\n+            }\n+\n+            if (!knowsExistingPassword) {\n+                String message = \"User doesn't know password.\";\n+                problems.add(message);\n+                /**\n+                 * @todo Someday we should make a errorResponse method that takes JSON arrays\n+                 *       and objects.\n+                 */\n+                return error(Status.BAD_REQUEST, problems.build().toString());\n+            }\n+            // response.add(\"knows existing password\", knowsExistingPassword);\n+        }\n+        response.add(\"user to convert\", builtInUserToConvert.getIdentifier());\n+        response.add(\"existing user found by email (prompt to convert)\", existing);\n+        response.add(\"changing to this provider\", shibProviderId);\n+        response.add(\"value to overwrite old first name\", overwriteFirstName);\n+        response.add(\"value to overwrite old last name\", overwriteLastName);\n+        response.add(\"value to overwrite old email address\", overwriteEmail);\n+        if (overwriteAffiliation != null) {\n+            response.add(\"affiliation\", overwriteAffiliation);\n+        }\n+        response.add(\"problems\", problems);\n+        return ok(response);\n+    }\n+\n+    /**\n+     * This is used in testing via AdminIT.java but we don't expect sysadmins to use\n+     * this.\n+     */\n+\n+    @Path(\"authenticatedUsers/convert/builtin2oauth\")\n+    @PUT\n+    public Response builtin2oauth(String content) {\n+        logger.info(\"entering builtin2oauth...\");\n+        try {\n+            AuthenticatedUser userToRunThisMethod = findAuthenticatedUserOrDie();\n+            if (!userToRunThisMethod.isSuperuser()) {\n+                return error(Response.Status.FORBIDDEN, \"Superusers only.\");\n+            }\n+        } catch (WrappedResponse ex) {\n+            return error(Response.Status.FORBIDDEN, \"Superusers only.\");\n+        }\n+\n+        boolean disabled = false;\n+        if (disabled) {\n+            return error(Response.Status.BAD_REQUEST, \"API endpoint disabled.\");\n+        }\n+\n+        AuthenticatedUser builtInUserToConvert = null;\n+        String emailToFind;\n+        String password;\n+        String authuserId = \"0\"; // could let people specify id on authuser table. probably better to let them\n+                                    // tell us their\n+        String newEmailAddressToUse;\n+        String newProviderId;\n+        String newPersistentUserIdInLookupTable;\n+        logger.info(\"content: \" + content);\n+        try {\n+            String[] args = content.split(\":\");\n+            emailToFind = args[0];\n+            password = args[1];\n+            newEmailAddressToUse = args[2];\n+            newProviderId = args[3];\n+            newPersistentUserIdInLookupTable = args[4];\n+            // authuserId = args[666];\n+        } catch (ArrayIndexOutOfBoundsException ex) {\n+            return error(Response.Status.BAD_REQUEST, \"Problem with content <<<\" + content + \">>>: \" + ex.toString());\n+        }\n+\n+        AuthenticatedUser existingAuthUserFoundByEmail = shibService.findAuthUserByEmail(emailToFind);\n+        String existing = \"NOT FOUND\";\n+        if (existingAuthUserFoundByEmail != null) {\n+            builtInUserToConvert = existingAuthUserFoundByEmail;\n+            existing = existingAuthUserFoundByEmail.getIdentifier();\n+        } else {\n+            long longToLookup = Long.parseLong(authuserId);\n+            AuthenticatedUser specifiedUserToConvert = authSvc.findByID(longToLookup);\n+            if (specifiedUserToConvert != null) {\n+                builtInUserToConvert = specifiedUserToConvert;\n+            } else {\n+                return error(Response.Status.BAD_REQUEST, \"No user to convert. We couldn't find a *single* existing user account based on \" + emailToFind + \" and no user was found using specified id \" + longToLookup);\n+            }\n+        }\n+        // String shibProviderId = ShibAuthenticationProvider.PROVIDER_ID;\n+\n+        Map<String, String> randomUser = authTestDataService.getRandomUser();\n+        // String eppn = UUID.randomUUID().toString().substring(0, 8);\n+        String eppn = randomUser.get(\"eppn\");\n+        String idPEntityId = randomUser.get(\"idp\");\n+        String notUsed = null;\n+        String separator = \"|\";\n+        // UserIdentifier newUserIdentifierInLookupTable = new\n+        // UserIdentifier(idPEntityId + separator + eppn, notUsed);\n+        UserIdentifier newUserIdentifierInLookupTable = new UserIdentifier(newPersistentUserIdInLookupTable, notUsed);\n+        String overwriteFirstName = randomUser.get(\"firstName\");\n+        String overwriteLastName = randomUser.get(\"lastName\");\n+        String overwriteEmail = randomUser.get(\"email\");\n+        overwriteEmail = newEmailAddressToUse;\n+        logger.info(\"overwriteEmail: \" + overwriteEmail);\n+        boolean validEmail = EMailValidator.isEmailValid(overwriteEmail, null);\n+        if (!validEmail) {\n+            // See https://github.com/IQSS/dataverse/issues/2998\n+            return error(Response.Status.BAD_REQUEST, \"invalid email: \" + overwriteEmail);\n+        }\n+        /**\n+         * @todo If affiliation is not null, put it in RoleAssigneeDisplayInfo\n+         *       constructor.\n+         */\n+        /**\n+         * Here we are exercising (via an API test) shibService.getAffiliation with the\n+         * TestShib IdP and a non-production DevShibAccountType.\n+         */\n+        // idPEntityId = ShibUtil.testShibIdpEntityId;\n+        // String overwriteAffiliation = shibService.getAffiliation(idPEntityId,\n+        // ShibServiceBean.DevShibAccountType.RANDOM);\n+\n+        String overwriteAffiliation = null;\n+        logger.info(\"overwriteAffiliation: \" + overwriteAffiliation);\n+        /**\n+         * @todo Find a place to put \"position\" in the authenticateduser table:\n+         *       https://github.com/IQSS/dataverse/issues/1444#issuecomment-74134694\n+         */\n+        String overwritePosition = \"staff;student\";\n+        AuthenticatedUserDisplayInfo displayInfo = new AuthenticatedUserDisplayInfo(overwriteFirstName, overwriteLastName, overwriteEmail, overwriteAffiliation, overwritePosition);\n+        JsonObjectBuilder response = Json.createObjectBuilder();\n+        JsonArrayBuilder problems = Json.createArrayBuilder();\n+        if (password != null) {\n+            response.add(\"password supplied\", password);\n+            boolean knowsExistingPassword = false;\n+            BuiltinUser oldBuiltInUser = builtinUserService.findByUserName(builtInUserToConvert.getUserIdentifier());\n+            if (oldBuiltInUser != null) {\n+                String usernameOfBuiltinAccountToConvert = oldBuiltInUser.getUserName();\n+                response.add(\"old username\", usernameOfBuiltinAccountToConvert);\n+                AuthenticatedUser authenticatedUser = authSvc.canLogInAsBuiltinUser(usernameOfBuiltinAccountToConvert, password);\n+                if (authenticatedUser != null) {\n+                    knowsExistingPassword = true;\n+                    AuthenticatedUser convertedUser = authSvc.convertBuiltInUserToRemoteUser(builtInUserToConvert, newProviderId, newUserIdentifierInLookupTable);\n+                    if (convertedUser != null) {\n+                        /**\n+                         * @todo Display name is not being overwritten. Logic must be in Shib backing\n+                         *       bean\n+                         */\n+                        AuthenticatedUser updatedInfoUser = authSvc.updateAuthenticatedUser(convertedUser, displayInfo);\n+                        if (updatedInfoUser != null) {\n+                            response.add(\"display name overwritten with\", updatedInfoUser.getName());\n+                        } else {\n+                            problems.add(\"couldn't update display info\");\n+                        }\n+                    } else {\n+                        problems.add(\"unable to convert user\");\n+                    }\n+                }\n+            } else {\n+                problems.add(\"couldn't find old username\");\n+            }\n+\n+            if (!knowsExistingPassword) {\n+                String message = \"User doesn't know password.\";\n+                problems.add(message);\n+                /**\n+                 * @todo Someday we should make a errorResponse method that takes JSON arrays\n+                 *       and objects.\n+                 */\n+                return error(Status.BAD_REQUEST, problems.build().toString());\n+            }\n+            // response.add(\"knows existing password\", knowsExistingPassword);\n+        }\n+        response.add(\"user to convert\", builtInUserToConvert.getIdentifier());\n+        response.add(\"existing user found by email (prompt to convert)\", existing);\n+        response.add(\"changing to this provider\", newProviderId);\n+        response.add(\"value to overwrite old first name\", overwriteFirstName);\n+        response.add(\"value to overwrite old last name\", overwriteLastName);\n+        response.add(\"value to overwrite old email address\", overwriteEmail);\n+        if (overwriteAffiliation != null) {\n+            response.add(\"affiliation\", overwriteAffiliation);\n+        }\n+        response.add(\"problems\", problems);\n+        return ok(response);\n+    }\n+\n+    @Path(\"roles\")\n+    @POST\n+    public Response createNewBuiltinRole(RoleDTO roleDto) {\n+        ActionLogRecord alr = new ActionLogRecord(ActionLogRecord.ActionType.Admin, \"createBuiltInRole\").setInfo(roleDto.getAlias() + \":\" + roleDto.getDescription());\n+        try {\n+            return ok(json(rolesSvc.save(roleDto.asRole())));\n+        } catch (Exception e) {\n+            alr.setActionResult(ActionLogRecord.Result.InternalError);\n+            alr.setInfo(alr.getInfo() + \"// \" + e.getMessage());\n+            return error(Response.Status.INTERNAL_SERVER_ERROR, e.getMessage());\n+        } finally {\n+            actionLogSvc.log(alr);\n+        }\n+    }\n+\n+    @Path(\"roles\")\n+    @GET\n+    public Response listBuiltinRoles() {\n+        try {\n+            return ok(rolesToJson(rolesSvc.findBuiltinRoles()));\n+        } catch (Exception e) {\n+            return error(Response.Status.INTERNAL_SERVER_ERROR, e.getMessage());\n+        }\n+    }\n+\n     @DELETE\n     @Path(\"roles/{id}\")\n     public Response deleteRole(@PathParam(\"id\") String id) {\n-\n         return response(req -> {\n             DataverseRole doomed = findRoleOrDie(id);\n             execCommand(new DeleteRoleCommand(req, doomed));\n@@ -937,33 +923,29 @@ public class Admin extends AbstractApiBean {\n         });\n     }\n \n-\t@Path(\"superuser/{identifier}\")\n-\t@POST\n-\tpublic Response toggleSuperuser(@PathParam(\"identifier\") String identifier) {\n-\t\tActionLogRecord alr = new ActionLogRecord(ActionLogRecord.ActionType.Admin, \"toggleSuperuser\")\n-\t\t\t\t.setInfo(identifier);\n-\t\ttry {\n-\t\t\tAuthenticatedUser user = authSvc.getAuthenticatedUser(identifier);\n-                        if (user.isDeactivated()) {\n-                            return error(Status.BAD_REQUEST, \"You cannot make a deactivated user a superuser.\");\n-                        }\n-\n-\t\t\tuser.setSuperuser(!user.isSuperuser());\n-\n-\t\t\treturn ok(\"User \" + user.getIdentifier() + \" \" + (user.isSuperuser() ? \"set\" : \"removed\")\n-\t\t\t\t\t+ \" as a superuser.\");\n-\t\t} catch (Exception e) {\n-\t\t\talr.setActionResult(ActionLogRecord.Result.InternalError);\n-\t\t\talr.setInfo(alr.getInfo() + \"// \" + e.getMessage());\n-\t\t\treturn error(Response.Status.INTERNAL_SERVER_ERROR, e.getMessage());\n-\t\t} finally {\n-\t\t\tactionLogSvc.log(alr);\n-\t\t}\n-\t}\n+    @Path(\"superuser/{identifier}\")\n+    @POST\n+    public Response toggleSuperuser(@PathParam(\"identifier\") String identifier) {\n+        ActionLogRecord alr = new ActionLogRecord(ActionLogRecord.ActionType.Admin, \"toggleSuperuser\").setInfo(identifier);\n+        try {\n+            AuthenticatedUser user = authSvc.getAuthenticatedUser(identifier);\n+            if (user.isDeactivated()) {\n+                return error(Status.BAD_REQUEST, \"You cannot make a deactivated user a superuser.\");\n+            }\n+            user.setSuperuser(!user.isSuperuser());\n+            return ok(\"User \" + user.getIdentifier() + \" \" + (user.isSuperuser() ? \"set\" : \"removed\") + \" as a superuser.\");\n+        } catch (Exception e) {\n+            alr.setActionResult(ActionLogRecord.Result.InternalError);\n+            alr.setInfo(alr.getInfo() + \"// \" + e.getMessage());\n+            return error(Response.Status.INTERNAL_SERVER_ERROR, e.getMessage());\n+        } finally {\n+            actionLogSvc.log(alr);\n+        }\n+    }\n \n     @GET\n     @Path(\"validate/datasets\")\n-    @Produces({\"application/json\"})\n+    @Produces({\"application/json\" })\n     public Response validateAllDatasets(@QueryParam(\"variables\") boolean includeVariables) {\n         \n         // Streaming output: the API will start producing \n@@ -980,10 +962,8 @@ public class Admin extends AbstractApiBean {\n         StreamingOutput stream = new StreamingOutput() {\n \n             @Override\n-            public void write(OutputStream os) throws IOException,\n-                    WebApplicationException {\n+            public void write(OutputStream os) throws IOException, WebApplicationException {\n                 os.write(\"{\\\"datasets\\\": [\\n\".getBytes());\n-                \n                 boolean wroteObject = false;\n                 for (Long datasetId : datasetService.findAllLocalDatasetIds()) {\n                     // Potentially, there's a godzillion datasets in this Dataverse. \n@@ -991,11 +971,8 @@ public class Admin extends AbstractApiBean {\n                     // only one dataset at a time. \n                     boolean success = false;\n                     boolean constraintViolationDetected = false;\n-                     \n                     JsonObjectBuilder output = Json.createObjectBuilder();\n                     output.add(\"datasetId\", datasetId);\n-\n-                    \n                     try {\n                         datasetService.instantiateDatasetInNewTransaction(datasetId, includeVariables);\n                         success = true;\n@@ -1004,8 +981,7 @@ public class Admin extends AbstractApiBean {\n                         while (cause != null) {\n                             if (cause instanceof ConstraintViolationException) {\n                                 ConstraintViolationException constraintViolationException = (ConstraintViolationException) cause;\n-                                for (ConstraintViolation<?> constraintViolation : constraintViolationException\n-                                        .getConstraintViolations()) {\n+                                for (ConstraintViolation<?> constraintViolation : constraintViolationException.getConstraintViolations()) {\n                                     String databaseRow = constraintViolation.getLeafBean().toString();\n                                     String field = constraintViolation.getPropertyPath().toString();\n                                     String invalidValue = null;\n@@ -1016,18 +992,14 @@ public class Admin extends AbstractApiBean {\n                                     output.add(\"entityClassDatabaseTableRowId\", databaseRow);\n                                     output.add(\"field\", field);\n                                     output.add(\"invalidValue\", invalidValue == null ? \"NULL\" : invalidValue);\n-                                    \n-                                    constraintViolationDetected = true; \n-                                    \n-                                    break; \n-                                    \n+                                    constraintViolationDetected = true;\n+                                    break;\n                                 }\n                             }\n                             cause = cause.getCause();\n                         }\n                     }\n-                    \n-                    \n+\n                     if (success) {\n                         output.add(\"status\", \"valid\");\n                     } else if (!constraintViolationDetected) {\n@@ -1035,26 +1007,21 @@ public class Admin extends AbstractApiBean {\n                     }\n                     \n                     // write it out:\n-                    \n+\n                     if (wroteObject) {\n                         os.write(\",\\n\".getBytes());\n                     }\n-\n                     os.write(output.build().toString().getBytes(\"UTF8\"));\n-                    \n                     if (!wroteObject) {\n                         wroteObject = true;\n                     }\n                 }\n-                \n-                \n                 os.write(\"\\n]\\n}\\n\".getBytes());\n             }\n-            \n         };\n         return Response.ok(stream).build();\n     }\n-        \n+\n     @Path(\"validate/dataset/{id}\")\n     @GET\n     public Response validateDataset(@PathParam(\"id\") String id, @QueryParam(\"variables\") boolean includeVariables) {\n@@ -1066,7 +1033,6 @@ public class Admin extends AbstractApiBean {\n         }\n \n         Long dbId = dataset.getId();\n-\n         String msg = \"unknown\";\n         try {\n             datasetService.instantiateDatasetInNewTransaction(dbId, includeVariables);\n@@ -1076,14 +1042,14 @@ public class Admin extends AbstractApiBean {\n             while (cause != null) {\n                 if (cause instanceof ConstraintViolationException) {\n                     ConstraintViolationException constraintViolationException = (ConstraintViolationException) cause;\n-                    for (ConstraintViolation<?> constraintViolation : constraintViolationException\n-                            .getConstraintViolations()) {\n+                    for (ConstraintViolation<?> constraintViolation : constraintViolationException.getConstraintViolations()) {\n                         String databaseRow = constraintViolation.getLeafBean().toString();\n                         String field = constraintViolation.getPropertyPath().toString();\n-                        String invalidValue = null; \n+                        String invalidValue = null;\n                         if (constraintViolation.getInvalidValue() != null) {\n                             invalidValue = constraintViolation.getInvalidValue().toString();\n                         }\n+\n                         JsonObjectBuilder violation = Json.createObjectBuilder();\n                         violation.add(\"entityClassDatabaseTableRowId\", databaseRow);\n                         violation.add(\"field\", field);\n@@ -1099,9 +1065,10 @@ public class Admin extends AbstractApiBean {\n     \n     // This API does the same thing as /validateDataFileHashValue/{fileId}, \n     // but for all the files in the dataset, with streaming output.\n+\n     @GET\n     @Path(\"validate/dataset/files/{id}\")\n-    @Produces({\"application/json\"})\n+    @Produces({\"application/json\" })\n     public Response validateDatasetDatafiles(@PathParam(\"id\") String id) {\n         \n         // Streaming output: the API will start producing \n@@ -1111,18 +1078,14 @@ public class Admin extends AbstractApiBean {\n         StreamingOutput stream = new StreamingOutput() {\n \n             @Override\n-            public void write(OutputStream os) throws IOException,\n-                    WebApplicationException {\n+            public void write(OutputStream os) throws IOException, WebApplicationException {\n                 Dataset dataset;\n-        \n                 try {\n                     dataset = findDatasetOrDie(id);\n                 } catch (Exception ex) {\n                     throw new IOException(ex.getMessage());\n                 }\n-                \n                 os.write(\"{\\\"dataFiles\\\": [\\n\".getBytes());\n-                \n                 boolean wroteObject = false;\n                 for (DataFile dataFile : dataset.getFiles()) {\n                     // Potentially, there's a godzillion datasets in this Dataverse. \n@@ -1130,12 +1093,9 @@ public class Admin extends AbstractApiBean {\n                     // only one dataset at a time. \n                     boolean success = false;\n                     boolean constraintViolationDetected = false;\n-                     \n                     JsonObjectBuilder output = Json.createObjectBuilder();\n                     output.add(\"datafileId\", dataFile.getId());\n                     output.add(\"storageIdentifier\", dataFile.getStorageIdentifier());\n-\n-                    \n                     try {\n                         FileUtil.validateDataFileChecksum(dataFile);\n                         success = true;\n@@ -1143,244 +1103,232 @@ public class Admin extends AbstractApiBean {\n                         output.add(\"status\", \"invalid\");\n                         output.add(\"errorMessage\", ex.getMessage());\n                     }\n-                    \n+\n                     if (success) {\n                         output.add(\"status\", \"valid\");\n                     } \n                     \n                     // write it out:\n-                    \n+\n                     if (wroteObject) {\n                         os.write(\",\\n\".getBytes());\n                     }\n-\n                     os.write(output.build().toString().getBytes(\"UTF8\"));\n-                    \n                     if (!wroteObject) {\n                         wroteObject = true;\n                     }\n                 }\n-                \n                 os.write(\"\\n]\\n}\\n\".getBytes());\n             }\n-            \n         };\n         return Response.ok(stream).build();\n     }\n \n-\t@Path(\"assignments/assignees/{raIdtf: .*}\")\n-\t@GET\n-\tpublic Response getAssignmentsFor(@PathParam(\"raIdtf\") String raIdtf) {\n-\n-\t\tJsonArrayBuilder arr = Json.createArrayBuilder();\n-\t\troleAssigneeSvc.getAssignmentsFor(raIdtf).forEach(a -> arr.add(json(a)));\n-\n-\t\treturn ok(arr);\n-\t}\n-\n-\t/**\n-\t * This method is used in integration tests.\n-\t *\n-\t * @param userId\n-\t *            The database id of an AuthenticatedUser.\n-\t * @return The confirm email token.\n-\t */\n-\t@Path(\"confirmEmail/{userId}\")\n-\t@GET\n-\tpublic Response getConfirmEmailToken(@PathParam(\"userId\") long userId) {\n-\t\tAuthenticatedUser user = authSvc.findByID(userId);\n-\t\tif (user != null) {\n-\t\t\tConfirmEmailData confirmEmailData = confirmEmailSvc.findSingleConfirmEmailDataByUser(user);\n-\t\t\tif (confirmEmailData != null) {\n-\t\t\t\treturn ok(Json.createObjectBuilder().add(\"token\", confirmEmailData.getToken()));\n-\t\t\t}\n-\t\t}\n-\t\treturn error(Status.BAD_REQUEST, \"Could not find confirm email token for user \" + userId);\n-\t}\n-\n-\t/**\n-\t * This method is used in integration tests.\n-\t *\n-\t * @param userId\n-\t *            The database id of an AuthenticatedUser.\n-\t */\n-\t@Path(\"confirmEmail/{userId}\")\n-\t@POST\n-\tpublic Response startConfirmEmailProcess(@PathParam(\"userId\") long userId) {\n-\t\tAuthenticatedUser user = authSvc.findByID(userId);\n-\t\tif (user != null) {\n-\t\t\ttry {\n-\t\t\t\tConfirmEmailInitResponse confirmEmailInitResponse = confirmEmailSvc.beginConfirm(user);\n-\t\t\t\tConfirmEmailData confirmEmailData = confirmEmailInitResponse.getConfirmEmailData();\n-\t\t\t\treturn ok(Json.createObjectBuilder().add(\"tokenCreated\", confirmEmailData.getCreated().toString())\n-\t\t\t\t\t\t.add(\"identifier\", user.getUserIdentifier()));\n-\t\t\t} catch (ConfirmEmailException ex) {\n-\t\t\t\treturn error(Status.BAD_REQUEST,\n-\t\t\t\t\t\t\"Could not start confirm email process for user \" + userId + \": \" + ex.getLocalizedMessage());\n-\t\t\t}\n-\t\t}\n-\t\treturn error(Status.BAD_REQUEST, \"Could not find user based on \" + userId);\n-\t}\n-\n-\t/**\n-\t * This method is used by an integration test in UsersIT.java to exercise bug\n-\t * https://github.com/IQSS/dataverse/issues/3287 . Not for use by users!\n-\t */\n-\t@Path(\"convertUserFromBcryptToSha1\")\n-\t@POST\n-\tpublic Response convertUserFromBcryptToSha1(String json) {\n-\t\tJsonReader jsonReader = Json.createReader(new StringReader(json));\n-\t\tJsonObject object = jsonReader.readObject();\n-\t\tjsonReader.close();\n-\t\tBuiltinUser builtinUser = builtinUserService.find(new Long(object.getInt(\"builtinUserId\")));\n-\t\tbuiltinUser.updateEncryptedPassword(\"4G7xxL9z11/JKN4jHPn4g9iIQck=\", 0); // password is \"sha-1Pass\", 0 means\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// SHA-1\n-\t\tBuiltinUser savedUser = builtinUserService.save(builtinUser);\n-\t\treturn ok(\"foo: \" + savedUser);\n-\n-\t}\n-\n-\t@Path(\"permissions/{dvo}\")\n-\t@GET\n-\tpublic Response findPermissonsOn(@PathParam(\"dvo\") String dvo) {\n-\t\ttry {\n-\t\t\tDvObject dvObj = findDvo(dvo);\n-\t\t\tif (dvObj == null) {\n-\t\t\t\treturn notFound(\"DvObject \" + dvo + \" not found\");\n-\t\t\t}\n-\t\t\ttry {\n-\t\t\t\tUser aUser = findUserOrDie();\n-\t\t\t\tJsonObjectBuilder bld = Json.createObjectBuilder();\n-\t\t\t\tbld.add(\"user\", aUser.getIdentifier());\n-\t\t\t\tbld.add(\"permissions\", json(permissionSvc.permissionsFor(createDataverseRequest(aUser), dvObj)));\n-\t\t\t\treturn ok(bld);\n-\n-\t\t\t} catch (WrappedResponse wr) {\n-\t\t\t\treturn wr.getResponse();\n-\t\t\t}\n-\t\t} catch (Exception e) {\n-\t\t\tlogger.log(Level.SEVERE, \"Error while testing permissions\", e);\n-\t\t\treturn error(Response.Status.INTERNAL_SERVER_ERROR, e.getMessage());\n-\t\t}\n-\t}\n-\n-\t@Path(\"assignee/{idtf}\")\n-\t@GET\n-\tpublic Response findRoleAssignee(@PathParam(\"idtf\") String idtf) {\n-\t\tRoleAssignee ra = roleAssigneeSvc.getRoleAssignee(idtf);\n-\t\treturn (ra == null) ? notFound(\"Role Assignee '\" + idtf + \"' not found.\") : ok(json(ra.getDisplayInfo()));\n-\t}\n-\n-\t@Path(\"datasets/integrity/{datasetVersionId}/fixmissingunf\")\n-\t@POST\n-\tpublic Response fixUnf(@PathParam(\"datasetVersionId\") String datasetVersionId,\n-\t\t\t@QueryParam(\"forceRecalculate\") boolean forceRecalculate) {\n-\t\tJsonObjectBuilder info = datasetVersionSvc.fixMissingUnf(datasetVersionId, forceRecalculate);\n-\t\treturn ok(info);\n-\t}\n-\n-\t@Path(\"datafiles/integrity/fixmissingoriginaltypes\")\n-\t@GET\n-\tpublic Response fixMissingOriginalTypes() {\n-\t\tJsonObjectBuilder info = Json.createObjectBuilder();\n-\n-\t\tList<Long> affectedFileIds = fileService.selectFilesWithMissingOriginalTypes();\n-\n-\t\tif (affectedFileIds.isEmpty()) {\n-\t\t\tinfo.add(\"message\",\n-\t\t\t\t\t\"All the tabular files in the database already have the original types set correctly; exiting.\");\n-\t\t} else {\n-\t\t\tfor (Long fileid : affectedFileIds) {\n-\t\t\t\tlogger.info(\"found file id: \" + fileid);\n-\t\t\t}\n-\t\t\tinfo.add(\"message\", \"Found \" + affectedFileIds.size()\n-\t\t\t\t\t+ \" tabular files with missing original types. Kicking off an async job that will repair the files in the background.\");\n-\t\t}\n-\n-\t\tingestService.fixMissingOriginalTypes(affectedFileIds);\n-\n-\t\treturn ok(info);\n-\t}\n-        \n+    @Path(\"assignments/assignees/{raIdtf: .*}\")\n+    @GET\n+    public Response getAssignmentsFor(@PathParam(\"raIdtf\") String raIdtf) {\n+        JsonArrayBuilder arr = Json.createArrayBuilder();\n+        roleAssigneeSvc.getAssignmentsFor(raIdtf).forEach(a -> arr.add(json(a)));\n+        return ok(arr);\n+    }\n+\n+    /**\n+     * This method is used in integration tests.\n+     *\n+     * @param userId\n+     *            The database id of an AuthenticatedUser.\n+     * @return The confirm email token.\n+     */\n+\n+    @Path(\"confirmEmail/{userId}\")\n+    @GET\n+    public Response getConfirmEmailToken(@PathParam(\"userId\") long userId) {\n+        AuthenticatedUser user = authSvc.findByID(userId);\n+        if (user != null) {\n+            ConfirmEmailData confirmEmailData = confirmEmailSvc.findSingleConfirmEmailDataByUser(user);\n+            if (confirmEmailData != null) {\n+                return ok(Json.createObjectBuilder().add(\"token\", confirmEmailData.getToken()));\n+            }\n+        }\n+        return error(Status.BAD_REQUEST, \"Could not find confirm email token for user \" + userId);\n+    }\n+\n+    /**\n+     * This method is used in integration tests.\n+     *\n+     * @param userId\n+     *            The database id of an AuthenticatedUser.\n+     */\n+\n+    @Path(\"confirmEmail/{userId}\")\n+    @POST\n+    public Response startConfirmEmailProcess(@PathParam(\"userId\") long userId) {\n+        AuthenticatedUser user = authSvc.findByID(userId);\n+        if (user != null) {\n+            try {\n+                ConfirmEmailInitResponse confirmEmailInitResponse = confirmEmailSvc.beginConfirm(user);\n+                ConfirmEmailData confirmEmailData = confirmEmailInitResponse.getConfirmEmailData();\n+                return ok(Json.createObjectBuilder().add(\"tokenCreated\", confirmEmailData.getCreated().toString()).add(\"identifier\", user.getUserIdentifier()));\n+            } catch (ConfirmEmailException ex) {\n+                return error(Status.BAD_REQUEST,\n+                    \"Could not start confirm email process for user \"\n++ userId + \": \" + ex.getLocalizedMessage()\n+                );\n+            }\n+        }\n+        return error(Status.BAD_REQUEST, \"Could not find user based on \" + userId);\n+    }\n+\n+    /**\n+     * This method is used by an integration test in UsersIT.java to exercise bug\n+     * https://github.com/IQSS/dataverse/issues/3287 . Not for use by users!\n+     */\n+\n+    @Path(\"convertUserFromBcryptToSha1\")\n+    @POST\n+    public Response convertUserFromBcryptToSha1(String json) {\n+        JsonReader jsonReader = Json.createReader(new StringReader(json));\n+        JsonObject object = jsonReader.readObject();\n+        jsonReader.close();\n+        BuiltinUser builtinUser = builtinUserService.find(new Long(object.getInt(\"builtinUserId\")));\n+        builtinUser.updateEncryptedPassword(\"4G7xxL9z11/JKN4jHPn4g9iIQck=\", 0); // password is \"sha-1Pass\", 0 means\n+                                                                                // SHA-1\n+        BuiltinUser savedUser = builtinUserService.save(builtinUser);\n+        return ok(\"foo: \" + savedUser);\n+    }\n+\n+    @Path(\"permissions/{dvo}\")\n+    @GET\n+    public Response findPermissonsOn(@PathParam(\"dvo\") String dvo) {\n+        try {\n+            DvObject dvObj = findDvo(dvo);\n+            if (dvObj == null) {\n+                return notFound(\"DvObject \" + dvo + \" not found\");\n+            }\n+            try {\n+                User aUser = findUserOrDie();\n+                JsonObjectBuilder bld = Json.createObjectBuilder();\n+                bld.add(\"user\", aUser.getIdentifier());\n+                bld.add(\"permissions\", json(permissionSvc.permissionsFor(createDataverseRequest(aUser), dvObj)));\n+                return ok(bld);\n+            } catch (WrappedResponse wr) {\n+                return wr.getResponse();\n+            }\n+        } catch (Exception e) {\n+            logger.log(Level.SEVERE, \"Error while testing permissions\", e);\n+            return error(Response.Status.INTERNAL_SERVER_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    @Path(\"assignee/{idtf}\")\n+    @GET\n+    public Response findRoleAssignee(@PathParam(\"idtf\") String idtf) {\n+        RoleAssignee ra = roleAssigneeSvc.getRoleAssignee(idtf);\n+        return (ra == null) ? notFound(\"Role Assignee '\" + idtf + \"' not found.\") : ok(json(ra.getDisplayInfo()));\n+    }\n+\n+    @Path(\"datasets/integrity/{datasetVersionId}/fixmissingunf\")\n+    @POST\n+    public Response fixUnf(@PathParam(\"datasetVersionId\") String datasetVersionId, @QueryParam(\"forceRecalculate\") boolean forceRecalculate) {\n+        JsonObjectBuilder info = datasetVersionSvc.fixMissingUnf(datasetVersionId, forceRecalculate);\n+        return ok(info);\n+    }\n+\n+    @Path(\"datafiles/integrity/fixmissingoriginaltypes\")\n+    @GET\n+    public Response fixMissingOriginalTypes() {\n+        JsonObjectBuilder info = Json.createObjectBuilder();\n+        List<Long> affectedFileIds = fileService.selectFilesWithMissingOriginalTypes();\n+        if (affectedFileIds.isEmpty()) {\n+            info.add(\"message\",\n+                     \"All the tabular files in the database already have the original types set correctly; exiting.\");\n+        } else {\n+            for (Long fileid : affectedFileIds) {\n+                logger.info(\"found file id: \" + fileid);\n+            }\n+            info.add(\"message\", \"Found \" + affectedFileIds.size() + \" tabular files with missing original types. Kicking off an async job that will repair the files in the background.\");\n+        }\n+        ingestService.fixMissingOriginalTypes(affectedFileIds);\n+        return ok(info);\n+    }\n+\n     @Path(\"datafiles/integrity/fixmissingoriginalsizes\")\n     @GET\n     public Response fixMissingOriginalSizes(@QueryParam(\"limit\") Integer limit) {\n         JsonObjectBuilder info = Json.createObjectBuilder();\n-\n         List<Long> affectedFileIds = fileService.selectFilesWithMissingOriginalSizes();\n-\n         if (affectedFileIds.isEmpty()) {\n             info.add(\"message\",\n-                    \"All the tabular files in the database already have the original sizes set correctly; exiting.\");\n+                     \"All the tabular files in the database already have the original sizes set correctly; exiting.\");\n         } else {\n-            \n             int howmany = affectedFileIds.size();\n-            String message = \"Found \" + howmany + \" tabular files with missing original sizes. \"; \n-            \n+            String message = \"Found \" + howmany + \" tabular files with missing original sizes. \";\n             if (limit == null || howmany <= limit) {\n                 message = message.concat(\" Kicking off an async job that will repair the files in the background.\");\n             } else {\n-                affectedFileIds.subList(limit, howmany-1).clear();\n-                message = message.concat(\" Kicking off an async job that will repair the \" + limit + \" files in the background.\");                        \n+                affectedFileIds.subList(limit, howmany - 1).clear();\n+                message = message.concat(\" Kicking off an async job that will repair the \" + limit + \" files in the background.\");\n             }\n             info.add(\"message\", message);\n         }\n-\n         ingestService.fixMissingOriginalSizes(affectedFileIds);\n         return ok(info);\n     }\n \n-\t/**\n-\t * This method is used in API tests, called from UtilIt.java.\n-\t */\n-\t@GET\n-\t@Path(\"datasets/thumbnailMetadata/{id}\")\n-\tpublic Response getDatasetThumbnailMetadata(@PathParam(\"id\") Long idSupplied) {\n-\t\tDataset dataset = datasetSvc.find(idSupplied);\n-\t\tif (dataset == null) {\n-\t\t\treturn error(Response.Status.NOT_FOUND, \"Could not find dataset based on id supplied: \" + idSupplied + \".\");\n-\t\t}\n-\t\tJsonObjectBuilder data = Json.createObjectBuilder();\n-\t\tDatasetThumbnail datasetThumbnail = dataset.getDatasetThumbnail(ImageThumbConverter.DEFAULT_CARDIMAGE_SIZE);\n-\t\tdata.add(\"isUseGenericThumbnail\", dataset.isUseGenericThumbnail());\n-\t\tdata.add(\"datasetLogoPresent\", DatasetUtil.isDatasetLogoPresent(dataset, ImageThumbConverter.DEFAULT_CARDIMAGE_SIZE));\n-\t\tif (datasetThumbnail != null) {\n-\t\t\tdata.add(\"datasetThumbnailBase64image\", datasetThumbnail.getBase64image());\n-\t\t\tDataFile dataFile = datasetThumbnail.getDataFile();\n-\t\t\tif (dataFile != null) {\n-\t\t\t\t/**\n-\t\t\t\t * @todo Change this from a String to a long.\n-\t\t\t\t */\n-\t\t\t\tdata.add(\"dataFileId\", dataFile.getId().toString());\n-\t\t\t}\n-\t\t}\n-\t\treturn ok(data);\n-\t}\n-\n-\t/**\n-\t * validatePassword\n-\t * <p>\n-\t * Validate a password with an API call\n-\t *\n-\t * @param password\n-\t *            The password\n-\t * @return A response with the validation result.\n-\t */\n-\t@Path(\"validatePassword\")\n-\t@POST\n-\tpublic Response validatePassword(String password) {\n-\n-\t\tfinal List<String> errors = passwordValidatorService.validate(password, new Date(), false);\n-\t\tfinal JsonArrayBuilder errorArray = Json.createArrayBuilder();\n-\t\terrors.forEach(errorArray::add);\n-\t\treturn ok(Json.createObjectBuilder().add(\"password\", password).add(\"errors\", errorArray));\n-\t}\n-\n-\t@GET\n-\t@Path(\"/isOrcid\")\n-\tpublic Response isOrcidEnabled() {\n-\t\treturn authSvc.isOrcidEnabled() ? ok(\"Orcid is enabled\") : ok(\"no orcid for you.\");\n-\t}\n+    /**\n+     * This method is used in API tests, called from UtilIt.java.\n+     */\n+\n+    @GET\n+    @Path(\"datasets/thumbnailMetadata/{id}\")\n+    public Response getDatasetThumbnailMetadata(@PathParam(\"id\") Long idSupplied) {\n+        Dataset dataset = datasetSvc.find(idSupplied);\n+        if (dataset == null) {\n+            return error(Response.Status.NOT_FOUND, \"Could not find dataset based on id supplied: \" + idSupplied + \".\");\n+        }\n+\n+        JsonObjectBuilder data = Json.createObjectBuilder();\n+        DatasetThumbnail datasetThumbnail = dataset.getDatasetThumbnail(ImageThumbConverter.DEFAULT_CARDIMAGE_SIZE);\n+        data.add(\"isUseGenericThumbnail\", dataset.isUseGenericThumbnail());\n+        data.add(\"datasetLogoPresent\",\n+DatasetUtil.isDatasetLogoPresent(dataset, ImageThumbConverter.DEFAULT_CARDIMAGE_SIZE));\n+        if (datasetThumbnail != null) {\n+            data.add(\"datasetThumbnailBase64image\", datasetThumbnail.getBase64image());\n+            DataFile dataFile = datasetThumbnail.getDataFile();\n+            if (dataFile != null) {\n+                /**\n+                 * @todo Change this from a String to a long.\n+                 */\n+                data.add(\"dataFileId\", dataFile.getId().toString());\n+            }\n+        }\n+        return ok(data);\n+    }\n+\n+    /**\n+     * validatePassword\n+     * <p>\n+     * Validate a password with an API call\n+     *\n+     * @param password\n+     *            The password\n+     * @return A response with the validation result.\n+     */\n+\n+    @Path(\"validatePassword\")\n+    @POST\n+    public Response validatePassword(String password) {\n+        final List<String> errors = passwordValidatorService.validate(password, new Date(), false);\n+        final JsonArrayBuilder errorArray = Json.createArrayBuilder();\n+        errors.forEach(errorArray::add);\n+        return ok(Json.createObjectBuilder().add(\"password\", password).add(\"errors\", errorArray));\n+    }\n+\n+    @GET\n+    @Path(\"/isOrcid\")\n+    public Response isOrcidEnabled() {\n+        return authSvc.isOrcidEnabled() ? ok(\"Orcid is enabled\") : ok(\"no orcid for you.\");\n+    }\n \n     @POST\n     @Path(\"{id}/reregisterHDLToPID\")\n@@ -1388,13 +1336,15 @@ public class Admin extends AbstractApiBean {\n         logger.info(\"Starting to reregister  \" + id + \" Dataset Id. (from hdl to doi)\" + new Date());\n         try {\n             if (settingsSvc.get(SettingsServiceBean.Key.Protocol.toString()).equals(GlobalId.HDL_PROTOCOL)) {\n-                logger.info(\"Bad Request protocol set to handle  \" );\n-                return error(Status.BAD_REQUEST, BundleUtil.getStringFromBundle(\"admin.api.migrateHDL.failure.must.be.set.for.doi\"));\n+                logger.info(\"Bad Request protocol set to handle  \");\n+                return error(Status.BAD_REQUEST,\n+                    BundleUtil.getStringFromBundle(\"admin.api.migrateHDL.failure.must.be.set.for.doi\")\n+                );\n             }\n-            \n+\n             User u = findUserOrDie();\n             if (!u.isSuperuser()) {\n-                logger.info(\"Bad Request Unauthor \" );\n+                logger.info(\"Bad Request Unauthor \");\n                 return error(Status.UNAUTHORIZED, BundleUtil.getStringFromBundle(\"admin.api.auth.mustBeSuperUser\"));\n             }\n \n@@ -1403,205 +1353,184 @@ public class Admin extends AbstractApiBean {\n             if (ds.getIdentifier() != null && !ds.getIdentifier().isEmpty() && ds.getProtocol().equals(GlobalId.HDL_PROTOCOL)) {\n                 execCommand(new RegisterDvObjectCommand(r, ds, true));\n             } else {\n-                return error(Status.BAD_REQUEST, BundleUtil.getStringFromBundle(\"admin.api.migrateHDL.failure.must.be.hdl.dataset\"));\n+                return error(Status.BAD_REQUEST,\n+                    BundleUtil.getStringFromBundle(\"admin.api.migrateHDL.failure.must.be.hdl.dataset\")\n+                );\n             }\n-\n         } catch (WrappedResponse r) {\n             logger.info(\"Failed to migrate Dataset Handle id: \" + id);\n             return badRequest(BundleUtil.getStringFromBundle(\"admin.api.migrateHDL.failure\", Arrays.asList(id)));\n         } catch (Exception e) {\n             logger.info(\"Failed to migrate Dataset Handle id: \" + id + \" Unexpected Exception \" + e.getMessage());\n-            List<String> args = Arrays.asList(id,e.getMessage());\n+            List<String> args = Arrays.asList(id, e.getMessage());\n             return badRequest(BundleUtil.getStringFromBundle(\"admin.api.migrateHDL.failureWithException\", args));\n         }\n-        \n         return ok(BundleUtil.getStringFromBundle(\"admin.api.migrateHDL.success\"));\n     }\n \n-\t@GET\n-\t@Path(\"{id}/registerDataFile\")\n-\tpublic Response registerDataFile(@PathParam(\"id\") String id) {\n-\t\tlogger.info(\"Starting to register  \" + id + \" file id. \" + new Date());\n-\n-\t\ttry {\n-\t\t\tUser u = findUserOrDie();\n-\t\t\tDataverseRequest r = createDataverseRequest(u);\n-\t\t\tDataFile df = findDataFileOrDie(id);\n-\t\t\tif (df.getIdentifier() == null || df.getIdentifier().isEmpty()) {\n-\t\t\t\texecCommand(new RegisterDvObjectCommand(r, df));\n-\t\t\t} else {\n-\t\t\t\treturn ok(\"File was already registered. \");\n-\t\t\t}\n-\n-\t\t} catch (WrappedResponse r) {\n-\t\t\tlogger.info(\"Failed to register file id: \" + id);\n-\t\t} catch (Exception e) {\n-\t\t\tlogger.info(\"Failed to register file id: \" + id + \" Unexpecgted Exception \" + e.getMessage());\n-\t\t}\n-\t\treturn ok(\"Datafile registration complete. File registered successfully.\");\n-\t}\n-\n-\t@GET\n-\t@Path(\"/registerDataFileAll\")\n-\tpublic Response registerDataFileAll() {\n-\t\tInteger count = fileService.findAll().size();\n-\t\tInteger successes = 0;\n-\t\tInteger alreadyRegistered = 0;\n-\t\tInteger released = 0;\n-\t\tInteger draft = 0;\n-\t\tlogger.info(\"Starting to register: analyzing \" + count + \" files. \" + new Date());\n-\t\tlogger.info(\"Only unregistered, published files will be registered.\");\n-\t\tfor (DataFile df : fileService.findAll()) {\n-\t\t\ttry {\n-\t\t\t\tif ((df.getIdentifier() == null || df.getIdentifier().isEmpty())) {\n-\t\t\t\t\tif (df.isReleased()) {\n-\t\t\t\t\t\treleased++;\n-\t\t\t\t\t\tUser u = findAuthenticatedUserOrDie();\n-\t\t\t\t\t\tDataverseRequest r = createDataverseRequest(u);\n-\t\t\t\t\t\texecCommand(new RegisterDvObjectCommand(r, df));\n-\t\t\t\t\t\tsuccesses++;\n-\t\t\t\t\t\tif (successes % 100 == 0) {\n-\t\t\t\t\t\t\tlogger.info(successes + \" of  \" + count + \" files registered successfully. \" + new Date());\n-\t\t\t\t\t\t}\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tdraft++;\n-\t\t\t\t\t\tlogger.info(draft + \" of  \" + count + \" files not yet published\");\n-\t\t\t\t\t}\n-\t\t\t\t} else {\n-\t\t\t\t\talreadyRegistered++;\n-\t\t\t\t\tlogger.info(alreadyRegistered + \" of  \" + count + \" files are already registered. \" + new Date());\n-\t\t\t\t}\n-\t\t\t} catch (WrappedResponse ex) {\n-\t\t\t\treleased++;\n-\t\t\t\tlogger.info(\"Failed to register file id: \" + df.getId());\n-\t\t\t\tLogger.getLogger(Datasets.class.getName()).log(Level.SEVERE, null, ex);\n-\t\t\t} catch (Exception e) {\n-\t\t\t\tlogger.info(\"Unexpected Exception: \" + e.getMessage());\n-\t\t\t}\n-\t\t}\n-\t\tlogger.info(\"Final Results:\");\n-\t\tlogger.info(alreadyRegistered + \" of  \" + count + \" files were already registered. \" + new Date());\n-\t\tlogger.info(draft + \" of  \" + count + \" files are not yet published. \" + new Date());\n-\t\tlogger.info(released + \" of  \" + count + \" unregistered, published files to register. \" + new Date());\n-\t\tlogger.info(successes + \" of  \" + released + \" unregistered, published files registered successfully. \"\n-\t\t\t\t+ new Date());\n-\n-\t\treturn ok(\"Datafile registration complete.\" + successes + \" of  \" + released\n-\t\t\t\t+ \" unregistered, published files registered successfully.\");\n-\t}\n-\n-\t@GET\n-\t@Path(\"/updateHashValues/{alg}\")\n-\tpublic Response updateHashValues(@PathParam(\"alg\") String alg, @QueryParam(\"num\") int num) {\n-\t\tInteger count = fileService.findAll().size();\n-\t\tInteger successes = 0;\n-\t\tInteger alreadyUpdated = 0;\n-\t\tInteger rehashed = 0;\n-\t\tInteger harvested=0;\n-\t\t\n-\t\tif (num <= 0)\n-\t\t\tnum = Integer.MAX_VALUE;\n-\t\tDataFile.ChecksumType cType = null;\n-\t\ttry {\n-\t\t\tcType = DataFile.ChecksumType.fromString(alg);\n-\t\t} catch (IllegalArgumentException iae) {\n-\t\t\treturn error(Status.BAD_REQUEST, \"Unknown algorithm\");\n-\t\t}\n-\t\tlogger.info(\"Starting to rehash: analyzing \" + count + \" files. \" + new Date());\n-\t\tlogger.info(\"Hashes not created with \" + alg + \" will be verified, and, if valid, replaced with a hash using \"\n-\t\t\t\t+ alg);\n-\t\ttry {\n-\t\t\tUser u = findAuthenticatedUserOrDie();\n-\t\t\tif (!u.isSuperuser())\n-\t\t\t\treturn error(Status.UNAUTHORIZED, \"must be superuser\");\n-\t\t} catch (WrappedResponse e1) {\n-\t\t\treturn error(Status.UNAUTHORIZED, \"api key required\");\n-\t\t}\n-\n-\t\tfor (DataFile df : fileService.findAll()) {\n-\t\t\tif (rehashed.intValue() >= num)\n-\t\t\t\tbreak;\n-\t\t\tInputStream in = null;\n-\t\t\tInputStream in2 = null; \n-\t\t\ttry {\n-\t\t\t\tif (df.isHarvested()) {\n-\t\t\t\t\tharvested++;\n-\t\t\t\t} else {\n-\t\t\t\t\tif (!df.getChecksumType().equals(cType)) {\n-\n-\t\t\t\t\t\trehashed++;\n-\t\t\t\t\t\tlogger.fine(rehashed + \": Datafile: \" + df.getFileMetadata().getLabel() + \", \"\n-\t\t\t\t\t\t\t\t+ df.getIdentifier());\n-\t\t\t\t\t\t// verify hash and calc new one to replace it\n-\t\t\t\t\t\tStorageIO<DataFile> storage = df.getStorageIO();\n-\t\t\t\t\t\tstorage.open(DataAccessOption.READ_ACCESS);\n-\t\t\t\t\t\tif (!df.isTabularData()) {\n-\t\t\t\t\t\t\tin = storage.getInputStream();\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t// if this is a tabular file, read the preserved original \"auxiliary file\"\n-\t\t\t\t\t\t\t// instead:\n-\t\t\t\t\t\t\tin = storage.getAuxFileAsInputStream(FileUtil.SAVED_ORIGINAL_FILENAME_EXTENSION);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tif (in == null)\n-\t\t\t\t\t\t\tlogger.warning(\"Cannot retrieve file.\");\n-\t\t\t\t\t\tString currentChecksum = FileUtil.calculateChecksum(in, df.getChecksumType());\n-\t\t\t\t\t\tif (currentChecksum.equals(df.getChecksumValue())) {\n-\t\t\t\t\t\t\tlogger.fine(\"Current checksum for datafile: \" + df.getFileMetadata().getLabel() + \", \"\n-\t\t\t\t\t\t\t\t\t+ df.getIdentifier() + \" is valid\");\n-\t\t\t\t\t\t\tstorage.open(DataAccessOption.READ_ACCESS);\n-\t\t\t\t\t\t\tif (!df.isTabularData()) {\n-\t\t\t\t\t\t\t\tin2 = storage.getInputStream();\n-\t\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t\t// if this is a tabular file, read the preserved original \"auxiliary file\"\n-\t\t\t\t\t\t\t\t// instead:\n-\t\t\t\t\t\t\t\tin2 = storage.getAuxFileAsInputStream(FileUtil.SAVED_ORIGINAL_FILENAME_EXTENSION);\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tif (in2 == null)\n-\t\t\t\t\t\t\t\tlogger.warning(\"Cannot retrieve file to calculate new checksum.\");\n-\t\t\t\t\t\t\tString newChecksum = FileUtil.calculateChecksum(in2, cType);\n-\n-\t\t\t\t\t\t\tdf.setChecksumType(cType);\n-\t\t\t\t\t\t\tdf.setChecksumValue(newChecksum);\n-\t\t\t\t\t\t\tsuccesses++;\n-\t\t\t\t\t\t\tif (successes % 100 == 0) {\n-\t\t\t\t\t\t\t\tlogger.info(\n-\t\t\t\t\t\t\t\t\t\tsuccesses + \" of  \" + count + \" files rehashed successfully. \" + new Date());\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tlogger.warning(\"Problem: Current checksum for datafile: \" + df.getFileMetadata().getLabel()\n-\t\t\t\t\t\t\t\t\t+ \", \" + df.getIdentifier() + \" is INVALID\");\n-\t\t\t\t\t\t}\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\talreadyUpdated++;\n-\t\t\t\t\t\tif (alreadyUpdated % 100 == 0) {\n-\t\t\t\t\t\t\tlogger.info(alreadyUpdated + \" of  \" + count\n-\t\t\t\t\t\t\t\t\t+ \" files are already have hashes with the new algorithm. \" + new Date());\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t} catch (Exception e) {\n-\t\t\t\tlogger.warning(\"Unexpected Exception: \" + e.getMessage());\n-\n-\t\t\t} finally {\n-\t\t\t\tIOUtils.closeQuietly(in);\n-\t\t\t\tIOUtils.closeQuietly(in2);\n-\t\t\t}\n-\t\t}\n-\t\tlogger.info(\"Final Results:\");\n-\t\tlogger.info(harvested + \" harvested files skipped.\");\n-\t\tlogger.info(\n-\t\t\t\talreadyUpdated + \" of  \" + count + \" files already had hashes with the new algorithm. \" + new Date());\n-\t\tlogger.info(rehashed + \" of  \" + count + \" files to rehash. \" + new Date());\n-\t\tlogger.info(\n-\t\t\t\tsuccesses + \" of  \" + rehashed + \" files successfully rehashed with the new algorithm. \" + new Date());\n-\n-\t\treturn ok(\"Datafile rehashing complete.\" + successes + \" of  \" + rehashed + \" files successfully rehashed.\");\n-\t}\n-        \n+    @GET\n+    @Path(\"{id}/registerDataFile\")\n+    public Response registerDataFile(@PathParam(\"id\") String id) {\n+        logger.info(\"Starting to register  \" + id + \" file id. \" + new Date());\n+        try {\n+            User u = findUserOrDie();\n+            DataverseRequest r = createDataverseRequest(u);\n+            DataFile df = findDataFileOrDie(id);\n+            if (df.getIdentifier() == null || df.getIdentifier().isEmpty()) {\n+                execCommand(new RegisterDvObjectCommand(r, df));\n+            } else {\n+                return ok(\"File was already registered. \");\n+            }\n+        } catch (WrappedResponse r) {\n+            logger.info(\"Failed to register file id: \" + id);\n+        } catch (Exception e) {\n+            logger.info(\"Failed to register file id: \" + id + \" Unexpecgted Exception \" + e.getMessage());\n+        }\n+        return ok(\"Datafile registration complete. File registered successfully.\");\n+    }\n+\n+    @GET\n+    @Path(\"/registerDataFileAll\")\n+    public Response registerDataFileAll() {\n+        Integer count = fileService.findAll().size();\n+        Integer successes = 0;\n+        Integer alreadyRegistered = 0;\n+        Integer released = 0;\n+        Integer draft = 0;\n+        logger.info(\"Starting to register: analyzing \" + count + \" files. \" + new Date());\n+        logger.info(\"Only unregistered, published files will be registered.\");\n+\n+        for (DataFile df : fileService.findAll()) {\n+            try {\n+                if ((df.getIdentifier() == null || df.getIdentifier().isEmpty())) {\n+                    if (df.isReleased()) {\n+                        released++;\n+                        User u = findAuthenticatedUserOrDie();\n+                        DataverseRequest r = createDataverseRequest(u);\n+                        execCommand(new RegisterDvObjectCommand(r, df));\n+                        successes++;\n+                        if (successes % 100 == 0) {\n+                            logger.info(successes + \" of  \" + count + \" files registered successfully. \" + new Date());\n+                        }\n+                    } else {\n+                        draft++;\n+                        logger.info(draft + \" of  \" + count + \" files not yet published\");\n+                    }\n+                } else {\n+                    alreadyRegistered++;\n+                    logger.info(alreadyRegistered + \" of  \" + count + \" files are already registered. \" + new Date());\n+                }\n+            } catch (WrappedResponse ex) {\n+                released++;\n+                logger.info(\"Failed to register file id: \" + df.getId());\n+                Logger.getLogger(Datasets.class.getName()).log(Level.SEVERE, null, ex);\n+            } catch (Exception e) {\n+                logger.info(\"Unexpected Exception: \" + e.getMessage());\n+            }\n+        }\n+        logger.info(\"Final Results:\");\n+        logger.info(alreadyRegistered + \" of  \" + count + \" files were already registered. \" + new Date());\n+        logger.info(draft + \" of  \" + count + \" files are not yet published. \" + new Date());\n+        logger.info(released + \" of  \" + count + \" unregistered, published files to register. \" + new Date());\n+        logger.info(successes + \" of  \" + released + \" unregistered, published files registered successfully. \" + new Date());\n+        return ok(\"Datafile registration complete.\" + successes + \" of  \" + released + \" unregistered, published files registered successfully.\");\n+    }\n+\n+    @GET\n+    @Path(\"/updateHashValues/{alg}\")\n+    public Response updateHashValues(@PathParam(\"alg\") String alg, @QueryParam(\"num\") int num) {\n+        Integer count = fileService.findAll().size();\n+        Integer successes = 0;\n+        Integer alreadyUpdated = 0;\n+        Integer rehashed = 0;\n+        Integer harvested = 0;\n+        if (num <= 0) num = Integer.MAX_VALUE;\n+        DataFile.ChecksumType cType = null;\n+        try {\n+            cType = DataFile.ChecksumType.fromString(alg);\n+        } catch (IllegalArgumentException iae) {\n+            return error(Status.BAD_REQUEST, \"Unknown algorithm\");\n+        }\n+        logger.info(\"Starting to rehash: analyzing \" + count + \" files. \" + new Date());\n+        logger.info(\"Hashes not created with \" + alg + \" will be verified, and, if valid, replaced with a hash using \" + alg);\n+        try {\n+            User u = findAuthenticatedUserOrDie();\n+            if (!u.isSuperuser()) return error(Status.UNAUTHORIZED, \"must be superuser\");\n+        } catch (WrappedResponse e1) {\n+            return error(Status.UNAUTHORIZED, \"api key required\");\n+        }\n+\n+        for (DataFile df : fileService.findAll()) {\n+            if (rehashed.intValue() >= num) break;\n+            InputStream in = null;\n+            InputStream in2 = null;\n+            try {\n+                if (df.isHarvested()) {\n+                    harvested++;\n+                } else {\n+                    if (!df.getChecksumType().equals(cType)) {\n+                        rehashed++;\n+                        logger.fine(rehashed + \": Datafile: \" + df.getFileMetadata().getLabel() + \", \" + df.getIdentifier());\n+                        // verify hash and calc new one to replace it\n+                        StorageIO<DataFile> storage = df.getStorageIO();\n+                        storage.open(DataAccessOption.READ_ACCESS);\n+                        if (!df.isTabularData()) {\n+                            in = storage.getInputStream();\n+                        } else {\n+                            // if this is a tabular file, read the preserved original \"auxiliary file\"\n+                            // instead:\n+                            in = storage.getAuxFileAsInputStream(FileUtil.SAVED_ORIGINAL_FILENAME_EXTENSION);\n+                        }\n+\n+                        if (in == null) logger.warning(\"Cannot retrieve file.\");\n+                        String currentChecksum = FileUtil.calculateChecksum(in, df.getChecksumType());\n+                        if (currentChecksum.equals(df.getChecksumValue())) {\n+                            logger.fine(\"Current checksum for datafile: \" + df.getFileMetadata().getLabel() + \", \" + df.getIdentifier() + \" is valid\");\n+                            storage.open(DataAccessOption.READ_ACCESS);\n+                            if (!df.isTabularData()) {\n+                                in2 = storage.getInputStream();\n+                            } else {\n+                                // if this is a tabular file, read the preserved original \"auxiliary file\"\n+                                // instead:\n+                                in2 = storage.getAuxFileAsInputStream(FileUtil.SAVED_ORIGINAL_FILENAME_EXTENSION);\n+                            }\n+\n+                            if (in2 == null) logger.warning(\"Cannot retrieve file to calculate new checksum.\");\n+                            String newChecksum = FileUtil.calculateChecksum(in2, cType);\n+                            df.setChecksumType(cType);\n+                            df.setChecksumValue(newChecksum);\n+                            successes++;\n+                            if (successes % 100 == 0) {\n+                                logger.info(successes + \" of  \" + count + \" files rehashed successfully. \" + new Date());\n+                            }\n+                        } else {\n+                            logger.warning(\"Problem: Current checksum for datafile: \" + df.getFileMetadata().getLabel() + \", \" + df.getIdentifier() + \" is INVALID\");\n+                        }\n+                    } else {\n+                        alreadyUpdated++;\n+                        if (alreadyUpdated % 100 == 0) {\n+                            logger.info(alreadyUpdated + \" of  \" + count + \" files are already have hashes with the new algorithm. \" + new Date());\n+                        }\n+                    }\n+                }\n+            } catch (Exception e) {\n+                logger.warning(\"Unexpected Exception: \" + e.getMessage());\n+            } finally {\n+                IOUtils.closeQuietly(in);\n+                IOUtils.closeQuietly(in2);\n+            }\n+        }\n+        logger.info(\"Final Results:\");\n+        logger.info(harvested + \" harvested files skipped.\");\n+        logger.info(alreadyUpdated + \" of  \" + count + \" files already had hashes with the new algorithm. \" + new Date());\n+        logger.info(rehashed + \" of  \" + count + \" files to rehash. \" + new Date());\n+        logger.info(successes + \" of  \" + rehashed + \" files successfully rehashed with the new algorithm. \" + new Date());\n+        return ok(\"Datafile rehashing complete.\" + successes + \" of  \" + rehashed + \" files successfully rehashed.\");\n+    }\n+\n     @POST\n     @Path(\"/computeDataFileHashValue/{fileId}/algorithm/{alg}\")\n     public Response computeDataFileHashValue(@PathParam(\"fileId\") String fileId, @PathParam(\"alg\") String alg) {\n-\n         try {\n             User u = findAuthenticatedUserOrDie();\n             if (!u.isSuperuser()) {\n@@ -1631,10 +1560,8 @@ public class Admin extends AbstractApiBean {\n         }\n \n         String newChecksum = \"\";\n-\n         InputStream in = null;\n         try {\n-\n             StorageIO<DataFile> storage = fileToUpdate.getStorageIO();\n             storage.open(DataAccessOption.READ_ACCESS);\n             if (!fileToUpdate.isTabularData()) {\n@@ -1642,27 +1569,24 @@ public class Admin extends AbstractApiBean {\n             } else {\n                 in = storage.getAuxFileAsInputStream(FileUtil.SAVED_ORIGINAL_FILENAME_EXTENSION);\n             }\n+\n             if (in == null) {\n                 return error(Status.NOT_FOUND, \"Could not retrieve file with the id: \" + fileId);\n             }\n             newChecksum = FileUtil.calculateChecksum(in, cType);\n             fileToUpdate.setChecksumType(cType);\n             fileToUpdate.setChecksumValue(newChecksum);\n-\n         } catch (Exception e) {\n             logger.warning(\"Unexpected Exception: \" + e.getMessage());\n-\n         } finally {\n             IOUtils.closeQuietly(in);\n         }\n-\n         return ok(\"Datafile rehashing complete. \" + fileId + \"  successfully rehashed. New hash value is: \" + newChecksum);\n     }\n-    \n+\n     @POST\n     @Path(\"/validateDataFileHashValue/{fileId}\")\n     public Response validateDataFileHashValue(@PathParam(\"fileId\") String fileId) {\n-\n         try {\n             User u = findAuthenticatedUserOrDie();\n             if (!u.isSuperuser()) {\n@@ -1696,7 +1620,6 @@ public class Admin extends AbstractApiBean {\n         String calculatedChecksum = \"\";\n         InputStream in = null;\n         try {\n-\n             StorageIO<DataFile> storage = fileToValidate.getStorageIO();\n             storage.open(DataAccessOption.READ_ACCESS);\n             if (!fileToValidate.isTabularData()) {\n@@ -1704,17 +1627,16 @@ public class Admin extends AbstractApiBean {\n             } else {\n                 in = storage.getAuxFileAsInputStream(FileUtil.SAVED_ORIGINAL_FILENAME_EXTENSION);\n             }\n+\n             if (in == null) {\n                 return error(Status.NOT_FOUND, \"Could not retrieve file with the id: \" + fileId);\n             }\n             calculatedChecksum = FileUtil.calculateChecksum(in, cType);\n-\n         } catch (Exception e) {\n             logger.warning(\"Unexpected Exception: \" + e.getMessage());\n             return error(Status.BAD_REQUEST, \"Checksum Validation Unexpected Exception: \" + e.getMessage());\n         } finally {\n             IOUtils.closeQuietly(in);\n-\n         }\n \n         if (currentChecksum.equals(calculatedChecksum)) {\n@@ -1722,34 +1644,31 @@ public class Admin extends AbstractApiBean {\n         } else {\n             return error(Status.EXPECTATION_FAILED, \"Datafile validation failed for \" + fileId + \". The saved hash value is: \" + currentChecksum + \" while the recalculated hash value for the stored file is: \" + calculatedChecksum);\n         }\n-\n     }\n \n     @GET\n     @Path(\"/submitDataVersionToArchive/{id}/{version}\")\n     public Response submitDatasetVersionToArchive(@PathParam(\"id\") String dsid, @PathParam(\"version\") String versionNumber) {\n-\n         try {\n             AuthenticatedUser au = findAuthenticatedUserOrDie();\n-\t\t\t// Note - the user is being set in the session so it becomes part of the\n-\t\t\t// DataverseRequest and is sent to the back-end command where it is used to get\n-\t\t\t// the API Token which is then used to retrieve files (e.g. via S3 direct\n-\t\t\t// downloads) to create the Bag\n+            // Note - the user is being set in the session so it becomes part of the\n+            // DataverseRequest and is sent to the back-end command where it is used to get\n+            // the API Token which is then used to retrieve files (e.g. via S3 direct\n+            // downloads) to create the Bag\n             session.setUser(au); // TODO: Stop using session. Use createDataverseRequest instead.\n             Dataset ds = findDatasetOrDie(dsid);\n-\n             DatasetVersion dv = datasetversionService.findByFriendlyVersionNumber(ds.getId(), versionNumber);\n             if (dv.getArchivalCopyLocation() == null) {\n                 String className = settingsService.getValueForKey(SettingsServiceBean.Key.ArchiverClassName);\n                 AbstractSubmitToArchiveCommand cmd = ArchiverUtil.createSubmitToArchiveCommand(className, dvRequestService.getDataverseRequest(), dv);\n                 if (cmd != null) {\n                     new Thread(new Runnable() {\n+\n                         public void run() {\n                             try {\n                                 DatasetVersion dv = commandEngine.submit(cmd);\n                                 if (dv.getArchivalCopyLocation() != null) {\n-                                    logger.info(\"DatasetVersion id=\" + ds.getGlobalId().toString() + \" v\" + versionNumber + \" submitted to Archive at: \"\n-                                            + dv.getArchivalCopyLocation());\n+                                    logger.info(\"DatasetVersion id=\" + ds.getGlobalId().toString() + \" v\" + versionNumber + \" submitted to Archive at: \" + dv.getArchivalCopyLocation());\n                                 } else {\n                                     logger.severe(\"Error submitting version due to conflict/error at Archive\");\n                                 }\n@@ -1770,22 +1689,22 @@ public class Admin extends AbstractApiBean {\n             return error(Status.UNAUTHORIZED, \"api key required\");\n         }\n     }\n-    \n-\t@DELETE\n-\t@Path(\"/clearMetricsCache\")\n-\tpublic Response clearMetricsCache() {\n-\t\tem.createNativeQuery(\"DELETE FROM metric\").executeUpdate();\n-\t\treturn ok(\"all metric caches cleared.\");\n-\t}\n-\n-\t@DELETE\n-\t@Path(\"/clearMetricsCache/{name}\")\n-\tpublic Response clearMetricsCacheByName(@PathParam(\"name\") String name) {\n-\t\tQuery deleteQuery = em.createNativeQuery(\"DELETE FROM metric where metricname = ?\");\n-\t\tdeleteQuery.setParameter(1, name);\n-\t\tdeleteQuery.executeUpdate();\n-\t\treturn ok(\"metric cache \" + name + \" cleared.\");\n-\t}\n+\n+    @DELETE\n+    @Path(\"/clearMetricsCache\")\n+    public Response clearMetricsCache() {\n+        em.createNativeQuery(\"DELETE FROM metric\").executeUpdate();\n+        return ok(\"all metric caches cleared.\");\n+    }\n+\n+    @DELETE\n+    @Path(\"/clearMetricsCache/{name}\")\n+    public Response clearMetricsCacheByName(@PathParam(\"name\") String name) {\n+        Query deleteQuery = em.createNativeQuery(\"DELETE FROM metric where metricname = ?\");\n+        deleteQuery.setParameter(1, name);\n+        deleteQuery.executeUpdate();\n+        return ok(\"metric cache \" + name + \" cleared.\");\n+    }\n \n     @GET\n     @Path(\"/dataverse/{alias}/addRoleAssignmentsToChildren\")\n@@ -1802,6 +1721,7 @@ public class Admin extends AbstractApiBean {\n         } catch (WrappedResponse wr) {\n             return wr.getResponse();\n         }\n+\n         boolean inheritAllRoles = false;\n         String rolesString = settingsSvc.getValueForKey(SettingsServiceBean.Key.InheritParentRoleAssignments, \"\");\n         if (rolesString.length() > 0) {\n@@ -1814,96 +1734,95 @@ public class Admin extends AbstractApiBean {\n             }\n         }\n         return error(Response.Status.BAD_REQUEST,\n-                \"InheritParentRoleAssignments does not list any roles on this instance\");\n+            \"InheritParentRoleAssignments does not list any roles on this instance\");\n     }\n-    \n+\n     @GET\n     @Path(\"/dataverse/{alias}/storageDriver\")\n     public Response getStorageDriver(@PathParam(\"alias\") String alias) throws WrappedResponse {\n-    \tDataverse dataverse = dataverseSvc.findByAlias(alias);\n-    \tif (dataverse == null) {\n-    \t\treturn error(Response.Status.NOT_FOUND, \"Could not find dataverse based on alias supplied: \" + alias + \".\");\n-    \t}\n-    \ttry {\n-    \t\tAuthenticatedUser user = findAuthenticatedUserOrDie();\n-    \t\tif (!user.isSuperuser()) {\n-    \t\t\treturn error(Response.Status.FORBIDDEN, \"Superusers only.\");\n-    \t\t}\n-    \t} catch (WrappedResponse wr) {\n-    \t\treturn wr.getResponse();\n-    \t}\n-    \t//Note that this returns what's set directly on this dataverse. If null/DataAccess.UNDEFINED_STORAGE_DRIVER_IDENTIFIER, the user would have to recurse the chain of parents to find the effective storageDriver\n-    \treturn ok(dataverse.getStorageDriverId());\n+        Dataverse dataverse = dataverseSvc.findByAlias(alias);\n+        if (dataverse == null) {\n+            return error(Response.Status.NOT_FOUND, \"Could not find dataverse based on alias supplied: \" + alias + \".\");\n+        }\n+        try {\n+            AuthenticatedUser user = findAuthenticatedUserOrDie();\n+            if (!user.isSuperuser()) {\n+                return error(Response.Status.FORBIDDEN, \"Superusers only.\");\n+            }\n+        } catch (WrappedResponse wr) {\n+            return wr.getResponse();\n+        }\n+        //Note that this returns what's set directly on this dataverse. If null/DataAccess.UNDEFINED_STORAGE_DRIVER_IDENTIFIER, the user would have to recurse the chain of parents to find the effective storageDriver\n+        return ok(dataverse.getStorageDriverId());\n     }\n-    \n+\n     @PUT\n     @Path(\"/dataverse/{alias}/storageDriver\")\n     public Response setStorageDriver(@PathParam(\"alias\") String alias, String label) throws WrappedResponse {\n-    \tDataverse dataverse = dataverseSvc.findByAlias(alias);\n-    \tif (dataverse == null) {\n-    \t\treturn error(Response.Status.NOT_FOUND, \"Could not find dataverse based on alias supplied: \" + alias + \".\");\n-    \t}\n-    \ttry {\n-    \t\tAuthenticatedUser user = findAuthenticatedUserOrDie();\n-    \t\tif (!user.isSuperuser()) {\n-    \t\t\treturn error(Response.Status.FORBIDDEN, \"Superusers only.\");\n-    \t\t}\n-    \t} catch (WrappedResponse wr) {\n-    \t\treturn wr.getResponse();\n-    \t}\n-    \tfor (Entry<String, String> store: DataAccess.getStorageDriverLabels().entrySet()) {\n-    \t\tif(store.getKey().equals(label)) {\n-    \t\t\tdataverse.setStorageDriverId(store.getValue());\n-    \t\t\treturn ok(\"Storage set to: \" + store.getKey() + \"/\" + store.getValue());\n-    \t\t}\n-    \t}\n-    \treturn error(Response.Status.BAD_REQUEST,\n-    \t\t\t\"No Storage Driver found for : \" + label);\n+        Dataverse dataverse = dataverseSvc.findByAlias(alias);\n+        if (dataverse == null) {\n+            return error(Response.Status.NOT_FOUND, \"Could not find dataverse based on alias supplied: \" + alias + \".\");\n+        }\n+        try {\n+            AuthenticatedUser user = findAuthenticatedUserOrDie();\n+            if (!user.isSuperuser()) {\n+                return error(Response.Status.FORBIDDEN, \"Superusers only.\");\n+            }\n+        } catch (WrappedResponse wr) {\n+            return wr.getResponse();\n+        }\n+\n+        for (Entry<String, String> store : DataAccess.getStorageDriverLabels().entrySet()) {\n+            if (store.getKey().equals(label)) {\n+                dataverse.setStorageDriverId(store.getValue());\n+                return ok(\"Storage set to: \" + store.getKey() + \"/\" + store.getValue());\n+            }\n+        }\n+        return error(Response.Status.BAD_REQUEST, \"No Storage Driver found for : \" + label);\n     }\n \n     @DELETE\n     @Path(\"/dataverse/{alias}/storageDriver\")\n     public Response resetStorageDriver(@PathParam(\"alias\") String alias) throws WrappedResponse {\n-    \tDataverse dataverse = dataverseSvc.findByAlias(alias);\n-    \tif (dataverse == null) {\n-    \t\treturn error(Response.Status.NOT_FOUND, \"Could not find dataverse based on alias supplied: \" + alias + \".\");\n-    \t}\n-    \ttry {\n-    \t\tAuthenticatedUser user = findAuthenticatedUserOrDie();\n-    \t\tif (!user.isSuperuser()) {\n-    \t\t\treturn error(Response.Status.FORBIDDEN, \"Superusers only.\");\n-    \t\t}\n-    \t} catch (WrappedResponse wr) {\n-    \t\treturn wr.getResponse();\n-    \t}\n-    \tdataverse.setStorageDriverId(\"\");\n-    \treturn ok(\"Storage reset to default: \" + DataAccess.DEFAULT_STORAGE_DRIVER_IDENTIFIER);\n+        Dataverse dataverse = dataverseSvc.findByAlias(alias);\n+        if (dataverse == null) {\n+            return error(Response.Status.NOT_FOUND, \"Could not find dataverse based on alias supplied: \" + alias + \".\");\n+        }\n+        try {\n+            AuthenticatedUser user = findAuthenticatedUserOrDie();\n+            if (!user.isSuperuser()) {\n+                return error(Response.Status.FORBIDDEN, \"Superusers only.\");\n+            }\n+        } catch (WrappedResponse wr) {\n+            return wr.getResponse();\n+        }\n+        dataverse.setStorageDriverId(\"\");\n+        return ok(\"Storage reset to default: \" + DataAccess.DEFAULT_STORAGE_DRIVER_IDENTIFIER);\n     }\n-    \n+\n     @GET\n     @Path(\"/dataverse/storageDrivers\")\n     public Response listStorageDrivers() throws WrappedResponse {\n-    \ttry {\n-    \t\tAuthenticatedUser user = findAuthenticatedUserOrDie();\n-    \t\tif (!user.isSuperuser()) {\n-    \t\t\treturn error(Response.Status.FORBIDDEN, \"Superusers only.\");\n-    \t\t}\n-    \t} catch (WrappedResponse wr) {\n-    \t\treturn wr.getResponse();\n-    \t}\n-    \tJsonObjectBuilder bld = jsonObjectBuilder();\n-    \tDataAccess.getStorageDriverLabels().entrySet().forEach(s -> bld.add(s.getKey(), s.getValue()));\n-\t\treturn ok(bld);\n+        try {\n+            AuthenticatedUser user = findAuthenticatedUserOrDie();\n+            if (!user.isSuperuser()) {\n+                return error(Response.Status.FORBIDDEN, \"Superusers only.\");\n+            }\n+        } catch (WrappedResponse wr) {\n+            return wr.getResponse();\n+        }\n+\n+        JsonObjectBuilder bld = jsonObjectBuilder();\n+        DataAccess.getStorageDriverLabels().entrySet().forEach(s -> bld.add(s.getKey(), s.getValue()));\n+        return ok(bld);\n     }\n-    \n+\n     @POST\n     @Path(\"/bannerMessage\")\n     public Response addBannerMessage(JsonObject jsonObject) throws WrappedResponse {\n-\n         BannerMessage toAdd = new BannerMessage();\n         try {\n             String dismissible = jsonObject.getString(\"dismissibleByUser\");\n-\n             boolean dismissibleByUser = false;\n             if (dismissible.equals(\"true\")) {\n                 dismissibleByUser = true;\n@@ -1922,51 +1841,40 @@ public class Admin extends AbstractApiBean {\n                 messageText.setBannerMessage(toAdd);\n                 toAdd.getBannerMessageTexts().add(messageText);\n             }\n-                bannerMessageService.save(toAdd);\n-                return ok(\"Banner Message added successfully.\");\n-\n+            bannerMessageService.save(toAdd);\n+            return ok(\"Banner Message added successfully.\");\n         } catch (Exception e) {\n             logger.warning(\"Unexpected Exception: \" + e.getMessage());\n             return error(Status.BAD_REQUEST, \"Add Banner Message unexpected exception: \" + e.getMessage());\n         }\n-\n     }\n-    \n+\n     @DELETE\n     @Path(\"/bannerMessage/{id}\")\n     public Response deleteBannerMessage(@PathParam(\"id\") Long id) throws WrappedResponse {\n- \n         BannerMessage message = em.find(BannerMessage.class, id);\n-        if (message == null){\n-            return error(Response.Status.NOT_FOUND, \"Message id = \"  + id + \" not found.\");\n+        if (message == null) {\n+            return error(Response.Status.NOT_FOUND, \"Message id = \" + id + \" not found.\");\n         }\n         bannerMessageService.deleteBannerMessage(id);\n-        \n         return ok(\"Message id =  \" + id + \" deleted.\");\n-\n     }\n-    \n+\n     @PUT\n     @Path(\"/bannerMessage/{id}/deactivate\")\n     public Response deactivateBannerMessage(@PathParam(\"id\") Long id) throws WrappedResponse {\n         BannerMessage message = em.find(BannerMessage.class, id);\n-        if (message == null){\n-            return error(Response.Status.NOT_FOUND, \"Message id = \"  + id + \" not found.\");\n+        if (message == null) {\n+            return error(Response.Status.NOT_FOUND, \"Message id = \" + id + \" not found.\");\n         }\n         bannerMessageService.deactivateBannerMessage(id);\n-        \n         return ok(\"Message id =  \" + id + \" deactivated.\");\n-\n     }\n-    \n+\n     @GET\n     @Path(\"/bannerMessage\")\n     public Response getBannerMessages(@PathParam(\"id\") Long id) throws WrappedResponse {\n-\n-        return ok(bannerMessageService.findAllBannerMessages().stream()\n-                .map(m -> jsonObjectBuilder().add(\"id\", m.getId()).add(\"displayValue\", m.getDisplayValue()))\n-                .collect(toJsonArray()));\n-\n+        return ok(bannerMessageService.findAllBannerMessages().stream().map(m -> jsonObjectBuilder().add(\"id\", m.getId()).add(\"displayValue\", m.getDisplayValue())).collect(toJsonArray()));\n     }\n-    \n-}\n+\n+}\n\\ No newline at end of file\n",
            "diff_size": 1332
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "126",
                    "column": "1",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/1/Admin.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_random/1/Admin.java\nindex 1df51137969..1118ba7d843 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/1/Admin.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_random/1/Admin.java\n@@ -119,7 +119,7 @@ import javax.ws.rs.core.StreamingOutput;\n @Path(\"admin\")\n public class Admin extends AbstractApiBean {\n \n-\tprivate static final Logger logger = Logger.getLogger(Admin.class.getName());\n+private static final Logger logger = Logger.getLogger(Admin.class.getName());\n \n         @EJB\n         AuthenticationProvidersRegistrationServiceBean authProvidersRegistrationSvc;\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "126",
                    "column": "1",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/1/Admin.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_three_grams/1/Admin.java\nindex 1df51137969..ca5a1dc10c4 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/1/Admin.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_three_grams/1/Admin.java\n@@ -119,7 +119,7 @@ import javax.ws.rs.core.StreamingOutput;\n @Path(\"admin\")\n public class Admin extends AbstractApiBean {\n \n-\tprivate static final Logger logger = Logger.getLogger(Admin.class.getName());\n+    private static final Logger logger = Logger.getLogger(Admin.class.getName());\n \n         @EJB\n         AuthenticationProvidersRegistrationServiceBean authProvidersRegistrationSvc;\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "intellij",
        "codebuff"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "styler_random",
        "styler_three_grams"
    ]
}