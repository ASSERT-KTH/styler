{
    "project_name": "findbugsproject-findbugs",
    "error_id": "80",
    "information": {
        "errors": [
            {
                "line": "7",
                "column": "1",
                "severity": "error",
                "message": "File contains tab characters (this is the first instance).",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
            }
        ]
    },
    "source_code": "public class Test {\n\n\t/**\n\t * Benchmark tests for null pointer defect detectors This benchmark tests\n\t * local variable tracking tracking tp1, tp2, tp3, tp4, tp5, tp6 : true\n\t * positive cases fp1, fp2, fp3, fp4 : false positives versions of the above",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "8",
                    "column": "1",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/errored/1/80/Test.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/styler/80/Test.java\nindex de5ab42c1ed..5cd744a334a 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/errored/1/80/Test.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/styler/80/Test.java\n@@ -4,7 +4,7 @@ import edu.umd.cs.findbugs.annotations.ExpectWarning;\n \n public class Test {\n \n-\t/**\n+/**\n \t * Benchmark tests for null pointer defect detectors This benchmark tests\n \t * local variable tracking tracking tp1, tp2, tp3, tp4, tp5, tp6 : true\n \t * positive cases fp1, fp2, fp3, fp4 : false positives versions of the above\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/errored/1/80/Test.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/intellij/80/Test.java\nindex de5ab42c1ed..068c7aa7b92 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/errored/1/80/Test.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/intellij/80/Test.java\n@@ -4,153 +4,176 @@ import edu.umd.cs.findbugs.annotations.ExpectWarning;\n \n public class Test {\n \n-\t/**\n-\t * Benchmark tests for null pointer defect detectors This benchmark tests\n-\t * local variable tracking tracking tp1, tp2, tp3, tp4, tp5, tp6 : true\n-\t * positive cases fp1, fp2, fp3, fp4 : false positives versions of the above\n-\t * ifp1, ifp2, ifp3 : interprocedural false positives itp1 : true versions\n-\t * of the ifp1\n-\t */\n-\n-\tint fp1(int level) {\n-\t\tObject x = null;\n-\t\tif (level > 0)\n-\t\t\tx = new Object();\n-\t\tif (level > 4)\n-\t\t\treturn x.hashCode();\n-\t\treturn 0;\n-\t}\n-\n-\tint tp1(int level) {\n-\t\tObject x = null;\n-\t\tif (level > 0)\n-\t\t\tx = new Object();\n-\t\tif (level < 4)\n-\t\t\treturn x.hashCode();\n-\t\treturn 0;\n-\t}\n-\n-\tint fp2(boolean b) {\n-\t\tObject x = null;\n-\t\tif (b)\n-\t\t\tx = new Object();\n-\t\tif (b)\n-\t\t\treturn x.hashCode();\n-\t\treturn 0;\n-\t}\n-\n-\tint tp2(boolean b) {\n-\t\tObject x = null;\n-\t\tif (b)\n-\t\t\tx = new Object();\n-\t\tif (!b)\n-\t\t\treturn x.hashCode();\n-\t\treturn 0;\n-\t}\n-\n-\tint fp3(Object x) {\n-\t\tObject y = null;\n-\t\tif (x != null)\n-\t\t\ty = new Object();\n-\t\tif (y != null)\n-\t\t\treturn x.hashCode() + y.hashCode();\n-\t\telse\n-\t\t\treturn 0;\n-\t}\n-\n-\t@ExpectWarning(\"NP\")\n-\tint tp3(Object x) {\n-\t\tObject y = null;\n-\t\tif (x != null)\n-\t\t\ty = new Object();\n-\t\tif (y != null)\n-\t\t\treturn x.hashCode() + y.hashCode();\n-\t\telse\n-\t\t\treturn x.hashCode();\n-\t}\n-\n-\tint tp4(boolean b) {\n-\t\tObject x = null;\n-\t\tObject y = null;\n-\t\tif (b)\n-\t\t\tx = \"x\";\n-\t\tif (x != null)\n-\t\t\ty = \"y\";\n-\t\tif (y != null)\n-\t\t\treturn x.hashCode() + y.hashCode();\n-\t\telse\n-\t\t\treturn x.hashCode();\n-\t}\n-\n-\tint fp4(boolean b) {\n-\t\tObject x = null;\n-\t\tObject y = null;\n-\t\tif (b)\n-\t\t\tx = \"x\";\n-\t\tif (x != null)\n-\t\t\ty = \"y\";\n-\t\tif (y != null)\n-\t\t\treturn x.hashCode() + y.hashCode();\n-\t\telse\n-\t\t\treturn 0;\n-\t}\n-\t@ExpectWarning(\"NP\")\n-\tint tp5(Object x) {\n-\t\tif (x == null) {\n-\t\t\treturn x.hashCode();\n-\t\t}\n-\t\treturn 0;\n-\t}\n-\n-\t@ExpectWarning(\"NP\")\n-\tint tp6(Object x) {\n-\t\tif (x == null) {\n-\t\t\tObject y = x;\n-\t\t\treturn y.hashCode();\n-\t\t}\n-\t\treturn 0;\n-\t}\n-\n-\tint itp1(boolean b) {\n-\t\tObject x = null;\n-\t\tif (b)\n-\t\t\tx = new Object();\n-\t\treturn helper1(x, b);\n-\t}\n-\n-\tint ifp1(boolean b) {\n-\t\tObject x = null;\n-\t\tif (!b)\n-\t\t\tx = new Object();\n-\t\treturn helper1(x, b);\n-\t}\n-\n-\t@ExpectWarning(\"NP\")\n-\tint itp2() {\n-\t\treturn helper2(null);\n-\t}\n-\n-\t@ExpectWarning(\"NP\")\n-\tint itp3(boolean b) {\n-\t\tObject x = null;\n-\t\tif (b)\n-\t\t\tx = \"x\";\n-\t\treturn helper3(x);\n-\t}\n-\n-\t// Bug when x is null and b is false\n-\tprivate int helper1(Object x, boolean b) {\n-\t\tif (b)\n-\t\t\treturn 0;\n-\t\treturn x.hashCode();\n-\t}\n-\n-\tprivate int helper2(Object x) {\n-\t\treturn x.hashCode();\n-\t}\n-\n-\tprivate int helper3(Object x) {\n-\t\treturn x.hashCode();\n-\t}\n+    /**\n+     * Benchmark tests for null pointer defect detectors This benchmark tests\n+     * local variable tracking tracking tp1, tp2, tp3, tp4, tp5, tp6 : true\n+     * positive cases fp1, fp2, fp3, fp4 : false positives versions of the above\n+     * ifp1, ifp2, ifp3 : interprocedural false positives itp1 : true versions\n+     * of the ifp1\n+     */\n+\n+    int fp1(int level) {\n+        Object x = null;\n+        if (level > 0) {\n+            x = new Object();\n+        }\n+        if (level > 4) {\n+            return x.hashCode();\n+        }\n+        return 0;\n+    }\n+\n+    int tp1(int level) {\n+        Object x = null;\n+        if (level > 0) {\n+            x = new Object();\n+        }\n+        if (level < 4) {\n+            return x.hashCode();\n+        }\n+        return 0;\n+    }\n+\n+    int fp2(boolean b) {\n+        Object x = null;\n+        if (b) {\n+            x = new Object();\n+        }\n+        if (b) {\n+            return x.hashCode();\n+        }\n+        return 0;\n+    }\n+\n+    int tp2(boolean b) {\n+        Object x = null;\n+        if (b) {\n+            x = new Object();\n+        }\n+        if (!b) {\n+            return x.hashCode();\n+        }\n+        return 0;\n+    }\n+\n+    int fp3(Object x) {\n+        Object y = null;\n+        if (x != null) {\n+            y = new Object();\n+        }\n+        if (y != null) {\n+            return x.hashCode() + y.hashCode();\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    @ExpectWarning(\"NP\")\n+    int tp3(Object x) {\n+        Object y = null;\n+        if (x != null) {\n+            y = new Object();\n+        }\n+        if (y != null) {\n+            return x.hashCode() + y.hashCode();\n+        } else {\n+            return x.hashCode();\n+        }\n+    }\n+\n+    int tp4(boolean b) {\n+        Object x = null;\n+        Object y = null;\n+        if (b) {\n+            x = \"x\";\n+        }\n+        if (x != null) {\n+            y = \"y\";\n+        }\n+        if (y != null) {\n+            return x.hashCode() + y.hashCode();\n+        } else {\n+            return x.hashCode();\n+        }\n+    }\n+\n+    int fp4(boolean b) {\n+        Object x = null;\n+        Object y = null;\n+        if (b) {\n+            x = \"x\";\n+        }\n+        if (x != null) {\n+            y = \"y\";\n+        }\n+        if (y != null) {\n+            return x.hashCode() + y.hashCode();\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    @ExpectWarning(\"NP\")\n+    int tp5(Object x) {\n+        if (x == null) {\n+            return x.hashCode();\n+        }\n+        return 0;\n+    }\n+\n+    @ExpectWarning(\"NP\")\n+    int tp6(Object x) {\n+        if (x == null) {\n+            Object y = x;\n+            return y.hashCode();\n+        }\n+        return 0;\n+    }\n+\n+    int itp1(boolean b) {\n+        Object x = null;\n+        if (b) {\n+            x = new Object();\n+        }\n+        return helper1(x, b);\n+    }\n+\n+    int ifp1(boolean b) {\n+        Object x = null;\n+        if (!b) {\n+            x = new Object();\n+        }\n+        return helper1(x, b);\n+    }\n+\n+    @ExpectWarning(\"NP\")\n+    int itp2() {\n+        return helper2(null);\n+    }\n+\n+    @ExpectWarning(\"NP\")\n+    int itp3(boolean b) {\n+        Object x = null;\n+        if (b) {\n+            x = \"x\";\n+        }\n+        return helper3(x);\n+    }\n+\n+    // Bug when x is null and b is false\n+    private int helper1(Object x, boolean b) {\n+        if (b) {\n+            return 0;\n+        }\n+        return x.hashCode();\n+    }\n+\n+    private int helper2(Object x) {\n+        return x.hashCode();\n+    }\n+\n+    private int helper3(Object x) {\n+        return x.hashCode();\n+    }\n \n }\n",
            "diff_size": 171
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "8",
                    "column": "1",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/errored/1/80/Test.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/naturalize/80/Test.java\nindex de5ab42c1ed..bb2fa7fc5f6 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/errored/1/80/Test.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/naturalize/80/Test.java\n@@ -4,7 +4,7 @@ import edu.umd.cs.findbugs.annotations.ExpectWarning;\n \n public class Test {\n \n-\t/**\n+    /**\n \t * Benchmark tests for null pointer defect detectors This benchmark tests\n \t * local variable tracking tracking tp1, tp2, tp3, tp4, tp5, tp6 : true\n \t * positive cases fp1, fp2, fp3, fp4 : false positives versions of the above\n@@ -13,144 +13,143 @@ public class Test {\n \t */\n \n \tint fp1(int level) {\n-\t\tObject x = null;\n+    Object x = null;\n \t\tif (level > 0)\n-\t\t\tx = new Object();\n-\t\tif (level > 4)\n-\t\t\treturn x.hashCode();\n-\t\treturn 0;\n-\t}\n+    x = new Object();\n+if (level > 4)\n+    return x.hashCode();\n+    return 0;\n+    }\n \n \tint tp1(int level) {\n-\t\tObject x = null;\n+    Object x = null;\n \t\tif (level > 0)\n-\t\t\tx = new Object();\n-\t\tif (level < 4)\n-\t\t\treturn x.hashCode();\n-\t\treturn 0;\n-\t}\n+    x = new Object();\n+if (level < 4)\n+    return x.hashCode();\n+    return 0;\n+    }\n \n \tint fp2(boolean b) {\n-\t\tObject x = null;\n-\t\tif (b)\n-\t\t\tx = new Object();\n+    Object x = null;\n \t\tif (b)\n-\t\t\treturn x.hashCode();\n-\t\treturn 0;\n-\t}\n+    x = new Object();\n+if (b)\n+    return x.hashCode();\n+    return 0;\n+    }\n \n \tint tp2(boolean b) {\n-\t\tObject x = null;\n+    Object x = null;\n \t\tif (b)\n-\t\t\tx = new Object();\n-\t\tif (!b)\n-\t\t\treturn x.hashCode();\n-\t\treturn 0;\n-\t}\n+    x = new Object();\n+if (!b)\n+    return x.hashCode();\n+    return 0;\n+    }\n \n \tint fp3(Object x) {\n-\t\tObject y = null;\n+    Object y = null;\n \t\tif (x != null)\n-\t\t\ty = new Object();\n-\t\tif (y != null)\n-\t\t\treturn x.hashCode() + y.hashCode();\n-\t\telse\n-\t\t\treturn 0;\n-\t}\n+    y = new Object();\n+if (y != null)\n+    return x.hashCode() + y.hashCode();\n+    else\n+    return 0;\n+    }\n \n \t@ExpectWarning(\"NP\")\n \tint tp3(Object x) {\n-\t\tObject y = null;\n+    Object y = null;\n \t\tif (x != null)\n-\t\t\ty = new Object();\n-\t\tif (y != null)\n-\t\t\treturn x.hashCode() + y.hashCode();\n-\t\telse\n-\t\t\treturn x.hashCode();\n-\t}\n+    y = new Object();\n+if (y != null)\n+    return x.hashCode() + y.hashCode();\n+    else\n+    return x.hashCode();\n+    }\n \n \tint tp4(boolean b) {\n-\t\tObject x = null;\n+    Object x = null;\n \t\tObject y = null;\n \t\tif (b)\n-\t\t\tx = \"x\";\n-\t\tif (x != null)\n-\t\t\ty = \"y\";\n-\t\tif (y != null)\n-\t\t\treturn x.hashCode() + y.hashCode();\n-\t\telse\n-\t\t\treturn x.hashCode();\n-\t}\n+    x = \"x\";\n+if (x != null)\n+    y = \"y\";\n+if (y != null)\n+    return x.hashCode() + y.hashCode();\n+    else\n+    return x.hashCode();\n+    }\n \n \tint fp4(boolean b) {\n-\t\tObject x = null;\n+    Object x = null;\n \t\tObject y = null;\n \t\tif (b)\n-\t\t\tx = \"x\";\n-\t\tif (x != null)\n-\t\t\ty = \"y\";\n-\t\tif (y != null)\n-\t\t\treturn x.hashCode() + y.hashCode();\n-\t\telse\n-\t\t\treturn 0;\n-\t}\n+    x = \"x\";\n+if (x != null)\n+    y = \"y\";\n+if (y != null)\n+    return x.hashCode() + y.hashCode();\n+    else\n+    return 0;\n+    }\n \t@ExpectWarning(\"NP\")\n \tint tp5(Object x) {\n-\t\tif (x == null) {\n-\t\t\treturn x.hashCode();\n-\t\t}\n+    if (x == null) {\n+    return x.hashCode();\n+    }\n \t\treturn 0;\n-\t}\n+    }\n \n \t@ExpectWarning(\"NP\")\n \tint tp6(Object x) {\n-\t\tif (x == null) {\n-\t\t\tObject y = x;\n+    if (x == null) {\n+    Object y = x;\n \t\t\treturn y.hashCode();\n-\t\t}\n+    }\n \t\treturn 0;\n-\t}\n+    }\n \n \tint itp1(boolean b) {\n-\t\tObject x = null;\n+    Object x = null;\n \t\tif (b)\n-\t\t\tx = new Object();\n-\t\treturn helper1(x, b);\n-\t}\n+    x = new Object();\n+return helper1(x, b);\n+    }\n \n \tint ifp1(boolean b) {\n-\t\tObject x = null;\n+    Object x = null;\n \t\tif (!b)\n-\t\t\tx = new Object();\n-\t\treturn helper1(x, b);\n-\t}\n+    x = new Object();\n+return helper1(x, b);\n+    }\n \n \t@ExpectWarning(\"NP\")\n \tint itp2() {\n-\t\treturn helper2(null);\n-\t}\n+    return helper2(null);\n+    }\n \n \t@ExpectWarning(\"NP\")\n \tint itp3(boolean b) {\n-\t\tObject x = null;\n+    Object x = null;\n \t\tif (b)\n-\t\t\tx = \"x\";\n-\t\treturn helper3(x);\n-\t}\n+    x = \"x\";\n+    return helper3(x);\n+    }\n \n \t// Bug when x is null and b is false\n \tprivate int helper1(Object x, boolean b) {\n-\t\tif (b)\n-\t\t\treturn 0;\n-\t\treturn x.hashCode();\n-\t}\n+    if (b)\n+    return 0;\n+    return x.hashCode();\n+    }\n \n \tprivate int helper2(Object x) {\n-\t\treturn x.hashCode();\n-\t}\n+    return x.hashCode();\n+    }\n \n \tprivate int helper3(Object x) {\n-\t\treturn x.hashCode();\n-\t}\n-\n-}\n+    return x.hashCode();\n+    }\n+    }\n\\ No newline at end of file\n",
            "diff_size": 91
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/errored/1/80/Test.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/codebuff/80/Test.java\nindex de5ab42c1ed..0f8d6f9a19f 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/errored/1/80/Test.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/codebuff/80/Test.java\n@@ -4,153 +4,157 @@ import edu.umd.cs.findbugs.annotations.ExpectWarning;\n \n public class Test {\n \n-\t/**\n-\t * Benchmark tests for null pointer defect detectors This benchmark tests\n-\t * local variable tracking tracking tp1, tp2, tp3, tp4, tp5, tp6 : true\n-\t * positive cases fp1, fp2, fp3, fp4 : false positives versions of the above\n-\t * ifp1, ifp2, ifp3 : interprocedural false positives itp1 : true versions\n-\t * of the ifp1\n-\t */\n-\n-\tint fp1(int level) {\n-\t\tObject x = null;\n-\t\tif (level > 0)\n-\t\t\tx = new Object();\n-\t\tif (level > 4)\n-\t\t\treturn x.hashCode();\n-\t\treturn 0;\n-\t}\n-\n-\tint tp1(int level) {\n-\t\tObject x = null;\n-\t\tif (level > 0)\n-\t\t\tx = new Object();\n-\t\tif (level < 4)\n-\t\t\treturn x.hashCode();\n-\t\treturn 0;\n-\t}\n-\n-\tint fp2(boolean b) {\n-\t\tObject x = null;\n-\t\tif (b)\n-\t\t\tx = new Object();\n-\t\tif (b)\n-\t\t\treturn x.hashCode();\n-\t\treturn 0;\n-\t}\n-\n-\tint tp2(boolean b) {\n-\t\tObject x = null;\n-\t\tif (b)\n-\t\t\tx = new Object();\n-\t\tif (!b)\n-\t\t\treturn x.hashCode();\n-\t\treturn 0;\n-\t}\n-\n-\tint fp3(Object x) {\n-\t\tObject y = null;\n-\t\tif (x != null)\n-\t\t\ty = new Object();\n-\t\tif (y != null)\n-\t\t\treturn x.hashCode() + y.hashCode();\n-\t\telse\n-\t\t\treturn 0;\n-\t}\n-\n-\t@ExpectWarning(\"NP\")\n-\tint tp3(Object x) {\n-\t\tObject y = null;\n-\t\tif (x != null)\n-\t\t\ty = new Object();\n-\t\tif (y != null)\n-\t\t\treturn x.hashCode() + y.hashCode();\n-\t\telse\n-\t\t\treturn x.hashCode();\n-\t}\n-\n-\tint tp4(boolean b) {\n-\t\tObject x = null;\n-\t\tObject y = null;\n-\t\tif (b)\n-\t\t\tx = \"x\";\n-\t\tif (x != null)\n-\t\t\ty = \"y\";\n-\t\tif (y != null)\n-\t\t\treturn x.hashCode() + y.hashCode();\n-\t\telse\n-\t\t\treturn x.hashCode();\n-\t}\n-\n-\tint fp4(boolean b) {\n-\t\tObject x = null;\n-\t\tObject y = null;\n-\t\tif (b)\n-\t\t\tx = \"x\";\n-\t\tif (x != null)\n-\t\t\ty = \"y\";\n-\t\tif (y != null)\n-\t\t\treturn x.hashCode() + y.hashCode();\n-\t\telse\n-\t\t\treturn 0;\n-\t}\n-\t@ExpectWarning(\"NP\")\n-\tint tp5(Object x) {\n-\t\tif (x == null) {\n-\t\t\treturn x.hashCode();\n-\t\t}\n-\t\treturn 0;\n-\t}\n-\n-\t@ExpectWarning(\"NP\")\n-\tint tp6(Object x) {\n-\t\tif (x == null) {\n-\t\t\tObject y = x;\n-\t\t\treturn y.hashCode();\n-\t\t}\n-\t\treturn 0;\n-\t}\n-\n-\tint itp1(boolean b) {\n-\t\tObject x = null;\n-\t\tif (b)\n-\t\t\tx = new Object();\n-\t\treturn helper1(x, b);\n-\t}\n-\n-\tint ifp1(boolean b) {\n-\t\tObject x = null;\n-\t\tif (!b)\n-\t\t\tx = new Object();\n-\t\treturn helper1(x, b);\n-\t}\n-\n-\t@ExpectWarning(\"NP\")\n-\tint itp2() {\n-\t\treturn helper2(null);\n-\t}\n-\n-\t@ExpectWarning(\"NP\")\n-\tint itp3(boolean b) {\n-\t\tObject x = null;\n-\t\tif (b)\n-\t\t\tx = \"x\";\n-\t\treturn helper3(x);\n-\t}\n-\n-\t// Bug when x is null and b is false\n-\tprivate int helper1(Object x, boolean b) {\n-\t\tif (b)\n-\t\t\treturn 0;\n-\t\treturn x.hashCode();\n-\t}\n-\n-\tprivate int helper2(Object x) {\n-\t\treturn x.hashCode();\n-\t}\n-\n-\tprivate int helper3(Object x) {\n-\t\treturn x.hashCode();\n-\t}\n-\n-}\n+    /**\n+     * Benchmark tests for null pointer defect detectors This benchmark tests\n+     * local variable tracking tracking tp1, tp2, tp3, tp4, tp5, tp6 : true\n+     * positive cases fp1, fp2, fp3, fp4 : false positives versions of the above\n+     * ifp1, ifp2, ifp3 : interprocedural false positives itp1 : true versions\n+     * of the ifp1\n+     */\n+    int fp1(int level) {\n+        Object x = null;\n+        if (level > 0)\n+            x = new Object();\n+        if (level > 4)\n+            return x.hashCode();\n+        return 0;\n+    }\n+\n+    int tp1(int level) {\n+        Object x = null;\n+        if (level > 0)\n+            x = new Object();\n+        if (level < 4)\n+            return x.hashCode();\n+        return 0;\n+    }\n+\n+    int fp2(boolean b) {\n+        Object x = null;\n+        if (b)\n+            x = new Object();\n+        if (b)\n+            return x.hashCode();\n+        return 0;\n+    }\n+\n+    int tp2(boolean b) {\n+        Object x = null;\n+        if (b)\n+            x = new Object();\n+        if (!b)\n+            return x.hashCode();\n+        return 0;\n+    }\n+\n+    int fp3(Object x) {\n+        Object y = null;\n+        if (x != null)\n+            y = new Object();\n+        if (y != null)\n+            return x.hashCode() + y.hashCode();\n+        else\n+            return 0;\n+    }\n+\n+    @ExpectWarning(\"NP\")\n+    int tp3(Object x) {\n+        Object y = null;\n+        if (x != null)\n+            y = new Object();\n+        if (y != null)\n+            return x.hashCode() + y.hashCode();\n+        else\n+            return x.hashCode();\n+    }\n+\n+    int tp4(boolean b) {\n+        Object x = null;\n+        Object y = null;\n+        if (b)\n+            x = \"x\";\n+        if (x != null)\n+            y = \"y\";\n+        if (y != null)\n+            return x.hashCode() + y.hashCode();\n+        else\n+            return x.hashCode();\n+    }\n+\n+    int fp4(boolean b) {\n+        Object x = null;\n+        Object y = null;\n+        if (b)\n+            x = \"x\";\n+        if (x != null)\n+            y = \"y\";\n+        if (y != null)\n+            return x.hashCode() + y.hashCode();\n+        else\n+            return 0;\n+    }\n+\n+    @ExpectWarning(\"NP\")\n+    int tp5(Object x) {\n+        if (x == null) {\n+            return x.hashCode();\n+        }\n+        return 0;\n+    }\n+\n+    @ExpectWarning(\"NP\")\n+    int tp6(Object x) {\n+        if (x == null) {\n+            Object y = x;\n+            return y.hashCode();\n+        }\n+        return 0;\n+    }\n+\n+    int itp1(boolean b) {\n+        Object x = null;\n+        if (b)\n+            x = new Object();\n+        return helper1(x, b);\n+    }\n+\n+    int ifp1(boolean b) {\n+        Object x = null;\n+        if (!b)\n+            x = new Object();\n+        return helper1(x, b);\n+    }\n+\n+    @ExpectWarning(\"NP\")\n+    int itp2() {\n+        return helper2(null);\n+    }\n+\n+    @ExpectWarning(\"NP\")\n+    int itp3(boolean b) {\n+        Object x = null;\n+        if (b)\n+            x = \"x\";\n+        return helper3(x);\n+    }\n+\n+    // Bug when x is null and b is false\n+\n+\n+    private int helper1(Object x, boolean b) {\n+        if (b)\n+            return 0;\n+        return x.hashCode();\n+    }\n+\n+\n+    private int helper2(Object x) {\n+        return x.hashCode();\n+    }\n+\n+\n+    private int helper3(Object x) {\n+        return x.hashCode();\n+    }\n+\n+}\n\\ No newline at end of file\n",
            "diff_size": 154
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "8",
                    "column": "1",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/errored/1/80/Test.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/styler_random/80/Test.java\nindex de5ab42c1ed..5cd744a334a 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/errored/1/80/Test.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/styler_random/80/Test.java\n@@ -4,7 +4,7 @@ import edu.umd.cs.findbugs.annotations.ExpectWarning;\n \n public class Test {\n \n-\t/**\n+/**\n \t * Benchmark tests for null pointer defect detectors This benchmark tests\n \t * local variable tracking tracking tp1, tp2, tp3, tp4, tp5, tp6 : true\n \t * positive cases fp1, fp2, fp3, fp4 : false positives versions of the above\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": null,
            "diff": null
        }
    ],
    "repaired_by": [
        "intellij",
        "codebuff"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "styler_random",
        "styler_three_grams"
    ]
}