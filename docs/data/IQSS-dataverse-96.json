{
    "project_name": "IQSS-dataverse",
    "error_id": "96",
    "information": {
        "errors": [
            {
                "line": "41",
                "column": "1",
                "severity": "error",
                "message": "File contains tab characters (this is the first instance).",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
            }
        ]
    },
    "source_code": "    @PersistenceContext(unitName = \"VDCNet-ejbPU\")\n    protected EntityManager em;\n\t\n    ExplicitGroupProvider provider;\n    \n    /**",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "41",
                    "column": "1",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/96/ExplicitGroupServiceBean.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/intellij/96/ExplicitGroupServiceBean.java\nindex de9b9ba530d..184cfc864d4 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/96/ExplicitGroupServiceBean.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/intellij/96/ExplicitGroupServiceBean.java\n@@ -25,260 +25,266 @@ import javax.persistence.PersistenceContext;\n /**\n  * A bean providing the {@link ExplicitGroupProvider}s with container services,\n  * such as database connectivity.\n- * \n+ *\n  * @author michael\n  */\n @Named\n @Stateless\n public class ExplicitGroupServiceBean {\n-    \n-    private static final Logger logger = Logger.getLogger(ExplicitGroupServiceBean.class.getName());\n-    @EJB\n-    private RoleAssigneeServiceBean roleAssigneeSvc;\n-    \n-    @PersistenceContext(unitName = \"VDCNet-ejbPU\")\n-    protected EntityManager em;\n-\t\n-    ExplicitGroupProvider provider;\n-    \n-    /**\n-     * A PostgreSQL-specific query that returns a group and all the groups\n-     * that contain it, and their parents too (-> recourse up teh containment\n-     * hierarchy of the explicit groups). Takes the group id as a parameter.\n-     */\n-    private static final String FIND_ALL_PARENTS_QUERY_TEMPLATE = \"WITH RECURSIVE\\n\" +\n-        \"explicit_group_graph AS (\\n\" +\n-        \"  SELECT\\n\" +\n-        \"     eg.id as id,\\n\" +\n-        \"     ee.explicitgroup_id as parent_group_id\\n\" +\n-        \"  FROM explicitgroup eg \\n\" +\n-        \"    LEFT JOIN explicitgroup_explicitgroup ee \\n\" +\n-        \"      ON eg.id=ee.containedexplicitgroups_id\\n\" +\n-        \"),\\n\" +\n-        \"parents AS (\\n\" +\n-        \"  SELECT * FROM explicit_group_graph\\n\" +\n-        \"  WHERE \\n\" +\n-        \"    id IN (@IDS)\\n\" +\n-        \"  UNION ALL\\n\" +\n-        \"  SELECT egg.*\\n\" +\n-        \"  FROM explicit_group_graph egg, parents\\n\" +\n-        \"  WHERE parents.parent_group_id = egg.id\\n\" +\n-        \") SELECT * from explicitgroup \\n\" +\n-        \"WHERE id IN (SELECT distinct id FROM parents);\";\n-    \n-    @PostConstruct\n-    void setup() {\n-        provider = new ExplicitGroupProvider(this, roleAssigneeSvc);\n-    }\n-    \n-    public ExplicitGroupProvider getProvider() {\n-        return provider;\n-    }\n-    \n-    public ExplicitGroup persist( ExplicitGroup g ) {\n-        if ( g.getId() == null ) {\n-            em.persist( g );\n-            return g;\n-        } else {\n-            // clean stale data once in a while\n-            if ( Math.random() >= 0.5 ) {\n-                Set<String> stale = new TreeSet<>();\n-                for ( String idtf : g.getContainedRoleAssignees()) {\n-                    if ( roleAssigneeSvc.getRoleAssignee(idtf) == null ) {\n-                        stale.add(idtf);\n-                    }\n-                }\n-                if ( ! stale.isEmpty() ) {\n-                    g.getContainedRoleAssignees().removeAll(stale);\n-                }\n-            }\n-            \n-            return em.merge( g );\n-        }    \n-    }\n-    \n-    public List<ExplicitGroup> findByOwner( Long dvObjectId ) {\n-        return provider.updateProvider(em.createNamedQuery( \"ExplicitGroup.findByOwnerId\", ExplicitGroup.class)\n-                 .setParameter(\"ownerId\", dvObjectId )\n-                 .getResultList());\n-    }\n-    \n-    ExplicitGroup findByAlias(String groupAlias) {\n-        try  {\n-            return provider.updateProvider( em.createNamedQuery(\"ExplicitGroup.findByAlias\", ExplicitGroup.class)\n-                    .setParameter(\"alias\", groupAlias)\n-                    .getSingleResult());\n-        } catch ( NoResultException nre ) {\n-            return null;\n-        }\n-    }\n \n-    public ExplicitGroup findInOwner(Long ownerId, String groupAliasInOwner) {\n-        try  {\n-            return provider.updateProvider( \n-                    em.createNamedQuery(\"ExplicitGroup.findByOwnerIdAndAlias\", ExplicitGroup.class)\n-                        .setParameter(\"alias\", groupAliasInOwner)\n-                        .setParameter(\"ownerId\", ownerId)\n-                        .getSingleResult());\n-        } catch ( NoResultException nre ) {\n-            return null;\n+  private static final Logger logger = Logger.getLogger(ExplicitGroupServiceBean.class.getName());\n+  @EJB\n+  private RoleAssigneeServiceBean roleAssigneeSvc;\n+\n+  @PersistenceContext(unitName = \"VDCNet-ejbPU\")\n+  protected EntityManager em;\n+\n+  ExplicitGroupProvider provider;\n+\n+  /**\n+   * A PostgreSQL-specific query that returns a group and all the groups\n+   * that contain it, and their parents too (-> recourse up teh containment\n+   * hierarchy of the explicit groups). Takes the group id as a parameter.\n+   */\n+  private static final String FIND_ALL_PARENTS_QUERY_TEMPLATE = \"WITH RECURSIVE\\n\" +\n+    \"explicit_group_graph AS (\\n\" +\n+    \"  SELECT\\n\" +\n+    \"     eg.id as id,\\n\" +\n+    \"     ee.explicitgroup_id as parent_group_id\\n\" +\n+    \"  FROM explicitgroup eg \\n\" +\n+    \"    LEFT JOIN explicitgroup_explicitgroup ee \\n\" +\n+    \"      ON eg.id=ee.containedexplicitgroups_id\\n\" +\n+    \"),\\n\" +\n+    \"parents AS (\\n\" +\n+    \"  SELECT * FROM explicit_group_graph\\n\" +\n+    \"  WHERE \\n\" +\n+    \"    id IN (@IDS)\\n\" +\n+    \"  UNION ALL\\n\" +\n+    \"  SELECT egg.*\\n\" +\n+    \"  FROM explicit_group_graph egg, parents\\n\" +\n+    \"  WHERE parents.parent_group_id = egg.id\\n\" +\n+    \") SELECT * from explicitgroup \\n\" +\n+    \"WHERE id IN (SELECT distinct id FROM parents);\";\n+\n+  @PostConstruct\n+  void setup() {\n+    provider = new ExplicitGroupProvider(this, roleAssigneeSvc);\n+  }\n+\n+  public ExplicitGroupProvider getProvider() {\n+    return provider;\n+  }\n+\n+  public ExplicitGroup persist(ExplicitGroup g) {\n+    if (g.getId() == null) {\n+      em.persist(g);\n+      return g;\n+    } else {\n+      // clean stale data once in a while\n+      if (Math.random() >= 0.5) {\n+        Set<String> stale = new TreeSet<>();\n+        for (String idtf : g.getContainedRoleAssignees()) {\n+          if (roleAssigneeSvc.getRoleAssignee(idtf) == null) {\n+            stale.add(idtf);\n+          }\n+        }\n+        if (!stale.isEmpty()) {\n+          g.getContainedRoleAssignees().removeAll(stale);\n         }\n+      }\n+\n+      return em.merge(g);\n     }\n+  }\n+\n+  public List<ExplicitGroup> findByOwner(Long dvObjectId) {\n+    return provider.updateProvider(em.createNamedQuery(\"ExplicitGroup.findByOwnerId\", ExplicitGroup.class)\n+      .setParameter(\"ownerId\", dvObjectId)\n+      .getResultList());\n+  }\n \n-    public void removeGroup(ExplicitGroup explicitGroup) {\n-        em.remove( explicitGroup );\n+  ExplicitGroup findByAlias(String groupAlias) {\n+    try {\n+      return provider.updateProvider(em.createNamedQuery(\"ExplicitGroup.findByAlias\", ExplicitGroup.class)\n+        .setParameter(\"alias\", groupAlias)\n+        .getSingleResult());\n+    } catch (NoResultException nre) {\n+      return null;\n     }\n-    \n-    /**\n-     * Returns all the explicit groups that are available in the context of the passed DvObject.\n-     * @param d The DvObject where the groups are queried\n-     * @return All the explicit groups defined at {@code d} and its ancestors.\n-     */\n-    public Set<ExplicitGroup> findAvailableFor( DvObject d ) {\n-        Set<ExplicitGroup> egs = new HashSet<>();\n-        while ( d != null ) {\n-            egs.addAll( findByOwner(d.getId()) );\n-            d = d.getOwner();\n-        }\n-        return provider.updateProvider( egs );\n+  }\n+\n+  public ExplicitGroup findInOwner(Long ownerId, String groupAliasInOwner) {\n+    try {\n+      return provider.updateProvider(\n+        em.createNamedQuery(\"ExplicitGroup.findByOwnerIdAndAlias\", ExplicitGroup.class)\n+          .setParameter(\"alias\", groupAliasInOwner)\n+          .setParameter(\"ownerId\", ownerId)\n+          .getSingleResult());\n+    } catch (NoResultException nre) {\n+      return null;\n     }\n-    \n-    /**\n-     * Finds all the explicit groups {@code ra} is <b>directly</b> a member of.\n-     * To find all these groups and the groups the contain them (recursively upwards),\n-     * consider using {@link #findGroups(edu.harvard.iq.dataverse.authorization.RoleAssignee)}\n-     * @param ra the role assignee whose membership list we seek\n-     * @return set of the explicit groups that contain {@code ra} directly.\n-     * @see #findGroups(edu.harvard.iq.dataverse.authorization.RoleAssignee)\n-     */\n-    public Set<ExplicitGroup> findDirectlyContainingGroups( RoleAssignee ra ) {\n-        if ( ra instanceof AuthenticatedUser ) {\n-            return provider.updateProvider(\n-                    new HashSet<>(\n-                            em.createNamedQuery(\"ExplicitGroup.findByAuthenticatedUserIdentifier\", ExplicitGroup.class)\n-                              .setParameter(\"authenticatedUserIdentifier\", ra.getIdentifier().substring(1))\n-                              .getResultList()\n-                  ));\n-        } else if ( ra instanceof ExplicitGroup ) {\n-            return provider.updateProvider(\n-                    new HashSet<>(\n-                            em.createNamedQuery(\"ExplicitGroup.findByContainedExplicitGroupId\", ExplicitGroup.class)\n-                              .setParameter(\"containedExplicitGroupId\", ((ExplicitGroup) ra).getId())\n-                              .getResultList()\n-                  ));\n-        } else {\n-            return provider.updateProvider(\n-                    new HashSet<>(\n-                            em.createNamedQuery(\"ExplicitGroup.findByRoleAssgineeIdentifier\", ExplicitGroup.class)\n-                              .setParameter(\"roleAssigneeIdentifier\", ra.getIdentifier())\n-                              .getResultList()\n-                  ));\n-        }\n+  }\n+\n+  public void removeGroup(ExplicitGroup explicitGroup) {\n+    em.remove(explicitGroup);\n+  }\n+\n+  /**\n+   * Returns all the explicit groups that are available in the context of the passed DvObject.\n+   *\n+   * @param d The DvObject where the groups are queried\n+   * @return All the explicit groups defined at {@code d} and its ancestors.\n+   */\n+  public Set<ExplicitGroup> findAvailableFor(DvObject d) {\n+    Set<ExplicitGroup> egs = new HashSet<>();\n+    while (d != null) {\n+      egs.addAll(findByOwner(d.getId()));\n+      d = d.getOwner();\n     }\n+    return provider.updateProvider(egs);\n+  }\n \n-    \n-    /**\n-     * Finds all the explicit groups {@code ra} is a member of.\n-     * @param ra the role assignee whose membership list we seek\n-     * @return set of the explicit groups that contain {@code ra}.\n-     */\n-    public Set<ExplicitGroup> findGroups( RoleAssignee ra ) {\n-        return findClosure(findDirectlyContainingGroups(ra));\n+  /**\n+   * Finds all the explicit groups {@code ra} is <b>directly</b> a member of.\n+   * To find all these groups and the groups the contain them (recursively upwards),\n+   * consider using {@link #findGroups(edu.harvard.iq.dataverse.authorization.RoleAssignee)}\n+   *\n+   * @param ra the role assignee whose membership list we seek\n+   * @return set of the explicit groups that contain {@code ra} directly.\n+   * @see #findGroups(edu.harvard.iq.dataverse.authorization.RoleAssignee)\n+   */\n+  public Set<ExplicitGroup> findDirectlyContainingGroups(RoleAssignee ra) {\n+    if (ra instanceof AuthenticatedUser) {\n+      return provider.updateProvider(\n+        new HashSet<>(\n+          em.createNamedQuery(\"ExplicitGroup.findByAuthenticatedUserIdentifier\", ExplicitGroup.class)\n+            .setParameter(\"authenticatedUserIdentifier\", ra.getIdentifier().substring(1))\n+            .getResultList()\n+        ));\n+    } else if (ra instanceof ExplicitGroup) {\n+      return provider.updateProvider(\n+        new HashSet<>(\n+          em.createNamedQuery(\"ExplicitGroup.findByContainedExplicitGroupId\", ExplicitGroup.class)\n+            .setParameter(\"containedExplicitGroupId\", ((ExplicitGroup) ra).getId())\n+            .getResultList()\n+        ));\n+    } else {\n+      return provider.updateProvider(\n+        new HashSet<>(\n+          em.createNamedQuery(\"ExplicitGroup.findByRoleAssgineeIdentifier\", ExplicitGroup.class)\n+            .setParameter(\"roleAssigneeIdentifier\", ra.getIdentifier())\n+            .getResultList()\n+        ));\n     }\n-    \n-    /**\n-     * Finds all the groups {@code ra} is a member of, in the context of {@code o}.\n-     * This includes both direct and indirect memberships.\n-     * @param ra The role assignee whose memberships we seek.\n-     * @param o The {@link DvObject} whose context we search.\n-     * @return All the groups in {@code o}'s context that {@code ra} is a member of.\n-     */\n-    public Set<ExplicitGroup> findGroups( RoleAssignee ra, DvObject o ) {\n-        return findGroups(ra).stream()\n-                .filter( g -> g.owner.isAncestorOf(o) )\n-                .collect( Collectors.toSet() );\n+  }\n+\n+\n+  /**\n+   * Finds all the explicit groups {@code ra} is a member of.\n+   *\n+   * @param ra the role assignee whose membership list we seek\n+   * @return set of the explicit groups that contain {@code ra}.\n+   */\n+  public Set<ExplicitGroup> findGroups(RoleAssignee ra) {\n+    return findClosure(findDirectlyContainingGroups(ra));\n+  }\n+\n+  /**\n+   * Finds all the groups {@code ra} is a member of, in the context of {@code o}.\n+   * This includes both direct and indirect memberships.\n+   *\n+   * @param ra The role assignee whose memberships we seek.\n+   * @param o  The {@link DvObject} whose context we search.\n+   * @return All the groups in {@code o}'s context that {@code ra} is a member of.\n+   */\n+  public Set<ExplicitGroup> findGroups(RoleAssignee ra, DvObject o) {\n+    return findGroups(ra).stream()\n+      .filter(g -> g.owner.isAncestorOf(o))\n+      .collect(Collectors.toSet());\n+  }\n+\n+  /**\n+   * Finds all the groups {@code ra} directly belongs to in the context of {@code o}. In effect,\n+   * collects all the groups {@code ra} belongs to and that are defined at {@code o}\n+   * or one of its ancestors.\n+   *\n+   * <B>Does not take group containment into account.</B> Use\n+   *\n+   * @param ra The role assignee that belongs to the groups\n+   * @param o  the DvObject that defines the context of the search.\n+   * @return All the groups ra belongs to in the context of o.\n+   */\n+  public Set<ExplicitGroup> findDirectGroups(RoleAssignee ra, DvObject o) {\n+    if (o == null) {\n+      return Collections.emptySet();\n     }\n-    \n-    /**\n-     * Finds all the groups {@code ra} directly belongs to in the context of {@code o}. In effect,\n-     * collects all the groups {@code ra} belongs to and that are defined at {@code o}\n-     * or one of its ancestors.\n-     * \n-     * <B>Does not take group containment into account.</B> Use\n-     * \n-     * @param ra The role assignee that belongs to the groups\n-     * @param o the DvObject that defines the context of the search.\n-     * @return All the groups ra belongs to in the context of o.\n-     */\n-    public Set<ExplicitGroup> findDirectGroups( RoleAssignee ra, DvObject o ) {\n-        if ( o == null ) {\n-            return Collections.emptySet();\n-        }\n-        List<ExplicitGroup> groupList = new LinkedList<>();\n-        \n-        if ( ra instanceof ExplicitGroup ) {\n-            for ( DvObject cur = o; cur != null; cur=cur.getOwner() ) {\n-                groupList.addAll( em.createNamedQuery(\"ExplicitGroup.findByOwnerAndSubExGroupId\", ExplicitGroup.class)\n-                  .setParameter(\"ownerId\", cur.getId())\n-                  .setParameter(\"subExGroupId\", ((ExplicitGroup)ra).getId())\n-                  .getResultList() );\n-            }\n-            \n-        } else if ( ra instanceof AuthenticatedUser ) {\n-            for ( DvObject cur = o; cur != null; cur=cur.getOwner() ) {\n-                groupList.addAll( em.createNamedQuery(\"ExplicitGroup.findByOwnerAndAuthUserId\", ExplicitGroup.class)\n-                  .setParameter(\"ownerId\", cur.getId())\n-                  .setParameter(\"authUserId\", ((AuthenticatedUser)ra).getId())\n-                  .getResultList() );\n-            }\n-            \n-        } else {\n-            for ( DvObject cur = o; cur != null; cur=cur.getOwner() ) {\n-                groupList.addAll( em.createNamedQuery(\"ExplicitGroup.findByOwnerAndRAIdtf\", ExplicitGroup.class)\n-                  .setParameter(\"ownerId\", cur.getId())\n-                  .setParameter(\"raIdtf\", ra.getIdentifier())\n-                  .getResultList() );\n-            }\n-        }\n-        \n-        return provider.updateProvider( new HashSet<>(groupList) );\n+    List<ExplicitGroup> groupList = new LinkedList<>();\n+\n+    if (ra instanceof ExplicitGroup) {\n+      for (DvObject cur = o; cur != null; cur = cur.getOwner()) {\n+        groupList.addAll(em.createNamedQuery(\"ExplicitGroup.findByOwnerAndSubExGroupId\", ExplicitGroup.class)\n+          .setParameter(\"ownerId\", cur.getId())\n+          .setParameter(\"subExGroupId\", ((ExplicitGroup) ra).getId())\n+          .getResultList());\n+      }\n+\n+    } else if (ra instanceof AuthenticatedUser) {\n+      for (DvObject cur = o; cur != null; cur = cur.getOwner()) {\n+        groupList.addAll(em.createNamedQuery(\"ExplicitGroup.findByOwnerAndAuthUserId\", ExplicitGroup.class)\n+          .setParameter(\"ownerId\", cur.getId())\n+          .setParameter(\"authUserId\", ((AuthenticatedUser) ra).getId())\n+          .getResultList());\n+      }\n+\n+    } else {\n+      for (DvObject cur = o; cur != null; cur = cur.getOwner()) {\n+        groupList.addAll(em.createNamedQuery(\"ExplicitGroup.findByOwnerAndRAIdtf\", ExplicitGroup.class)\n+          .setParameter(\"ownerId\", cur.getId())\n+          .setParameter(\"raIdtf\", ra.getIdentifier())\n+          .getResultList());\n+      }\n     }\n-    \n-    /**\n-     * \n-     * Finds all the groups that contain the groups in {@code seed} (including {@code seed}), and the\n-     * groups that contain these groups, an so on.\n-     * \n-     * @param seed the initial set of groups.\n-     * @return Transitive closure (based on group  containment) of the groups in {@code seed}.\n-     */\n-    protected Set<ExplicitGroup> findClosure( Set<ExplicitGroup> seed ) {\n-        \n-        if ( seed.isEmpty() ) return Collections.emptySet();\n-        \n-        String ids = seed.stream().map(eg->Long.toString(eg.getId())).collect( joining(\",\") );\n-        \n-        // PSQL driver has issues with arrays and collections as parameters, so we're using \n-        // string manipulation to create the query here. Not ideal, but seems to be\n-        // the only solution at the Java Persistence level (i.e. without downcasting to org.postgresql.*)\n-        String sqlCode = FIND_ALL_PARENTS_QUERY_TEMPLATE.replace(\"@IDS\", ids);\n-        return new HashSet<>(em.createNativeQuery(sqlCode, ExplicitGroup.class)\n-            .getResultList());\n+\n+    return provider.updateProvider(new HashSet<>(groupList));\n+  }\n+\n+  /**\n+   * Finds all the groups that contain the groups in {@code seed} (including {@code seed}), and the\n+   * groups that contain these groups, an so on.\n+   *\n+   * @param seed the initial set of groups.\n+   * @return Transitive closure (based on group  containment) of the groups in {@code seed}.\n+   */\n+  protected Set<ExplicitGroup> findClosure(Set<ExplicitGroup> seed) {\n+\n+    if (seed.isEmpty()) {\n+      return Collections.emptySet();\n     }\n-    \n-    /**\n-     * \n-     * Fully strips the assignee of membership in all the explicit groups.\n-     * \n-     * @param assignee User or Group \n-     */\n-    public void revokeAllGroupsForAssignee(RoleAssignee assignee) {\n-        if (assignee instanceof AuthenticatedUser) {\n-            em.createNativeQuery(\"DELETE FROM explicitgroup_authenticateduser WHERE containedauthenticatedusers_id=\" + ((AuthenticatedUser) assignee).getId()).executeUpdate();\n-        } else if (assignee instanceof ExplicitGroup) {\n-            em.createNativeQuery(\"DELETE FROM explicitgroup_explicitgroup WHERE containedexplicitgroups_id=\" + ((ExplicitGroup) assignee).getId()).executeUpdate();\n-        }\n+\n+    String ids = seed.stream().map(eg -> Long.toString(eg.getId())).collect(joining(\",\"));\n+\n+    // PSQL driver has issues with arrays and collections as parameters, so we're using\n+    // string manipulation to create the query here. Not ideal, but seems to be\n+    // the only solution at the Java Persistence level (i.e. without downcasting to org.postgresql.*)\n+    String sqlCode = FIND_ALL_PARENTS_QUERY_TEMPLATE.replace(\"@IDS\", ids);\n+    return new HashSet<>(em.createNativeQuery(sqlCode, ExplicitGroup.class)\n+      .getResultList());\n+  }\n+\n+  /**\n+   * Fully strips the assignee of membership in all the explicit groups.\n+   *\n+   * @param assignee User or Group\n+   */\n+  public void revokeAllGroupsForAssignee(RoleAssignee assignee) {\n+    if (assignee instanceof AuthenticatedUser) {\n+      em.createNativeQuery(\"DELETE FROM explicitgroup_authenticateduser WHERE containedauthenticatedusers_id=\" +\n+        ((AuthenticatedUser) assignee).getId()).executeUpdate();\n+    } else if (assignee instanceof ExplicitGroup) {\n+      em.createNativeQuery(\"DELETE FROM explicitgroup_explicitgroup WHERE containedexplicitgroups_id=\" +\n+        ((ExplicitGroup) assignee).getId()).executeUpdate();\n     }\n-    \n-    \n+  }\n+\n+\n }\n",
            "diff_size": 367
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/96/ExplicitGroupServiceBean.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/codebuff/96/ExplicitGroupServiceBean.java\nindex de9b9ba530d..d3c032fbbb4 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/96/ExplicitGroupServiceBean.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/codebuff/96/ExplicitGroupServiceBean.java\n@@ -28,17 +28,19 @@ import javax.persistence.PersistenceContext;\n  * \n  * @author michael\n  */\n+\n+\n @Named\n @Stateless\n public class ExplicitGroupServiceBean {\n-    \n+\n     private static final Logger logger = Logger.getLogger(ExplicitGroupServiceBean.class.getName());\n+\n     @EJB\n     private RoleAssigneeServiceBean roleAssigneeSvc;\n-    \n+\n     @PersistenceContext(unitName = \"VDCNet-ejbPU\")\n     protected EntityManager em;\n-\t\n     ExplicitGroupProvider provider;\n     \n     /**\n@@ -46,87 +48,61 @@ public class ExplicitGroupServiceBean {\n      * that contain it, and their parents too (-> recourse up teh containment\n      * hierarchy of the explicit groups). Takes the group id as a parameter.\n      */\n-    private static final String FIND_ALL_PARENTS_QUERY_TEMPLATE = \"WITH RECURSIVE\\n\" +\n-        \"explicit_group_graph AS (\\n\" +\n-        \"  SELECT\\n\" +\n-        \"     eg.id as id,\\n\" +\n-        \"     ee.explicitgroup_id as parent_group_id\\n\" +\n-        \"  FROM explicitgroup eg \\n\" +\n-        \"    LEFT JOIN explicitgroup_explicitgroup ee \\n\" +\n-        \"      ON eg.id=ee.containedexplicitgroups_id\\n\" +\n-        \"),\\n\" +\n-        \"parents AS (\\n\" +\n-        \"  SELECT * FROM explicit_group_graph\\n\" +\n-        \"  WHERE \\n\" +\n-        \"    id IN (@IDS)\\n\" +\n-        \"  UNION ALL\\n\" +\n-        \"  SELECT egg.*\\n\" +\n-        \"  FROM explicit_group_graph egg, parents\\n\" +\n-        \"  WHERE parents.parent_group_id = egg.id\\n\" +\n-        \") SELECT * from explicitgroup \\n\" +\n-        \"WHERE id IN (SELECT distinct id FROM parents);\";\n-    \n+    private static final String FIND_ALL_PARENTS_QUERY_TEMPLATE = \"WITH RECURSIVE\\n\" + \"explicit_group_graph AS (\\n\" + \"  SELECT\\n\" + \"     eg.id as id,\\n\" + \"     ee.explicitgroup_id as parent_group_id\\n\" + \"  FROM explicitgroup eg \\n\" + \"    LEFT JOIN explicitgroup_explicitgroup ee \\n\" + \"      ON eg.id=ee.containedexplicitgroups_id\\n\" + \"),\\n\" + \"parents AS (\\n\" + \"  SELECT * FROM explicit_group_graph\\n\" + \"  WHERE \\n\" + \"    id IN (@IDS)\\n\" + \"  UNION ALL\\n\" + \"  SELECT egg.*\\n\" + \"  FROM explicit_group_graph egg, parents\\n\" + \"  WHERE parents.parent_group_id = egg.id\\n\" + \") SELECT * from explicitgroup \\n\" + \"WHERE id IN (SELECT distinct id FROM parents);\";\n+\n     @PostConstruct\n     void setup() {\n         provider = new ExplicitGroupProvider(this, roleAssigneeSvc);\n     }\n-    \n+\n     public ExplicitGroupProvider getProvider() {\n         return provider;\n     }\n-    \n-    public ExplicitGroup persist( ExplicitGroup g ) {\n-        if ( g.getId() == null ) {\n-            em.persist( g );\n+\n+    public ExplicitGroup persist(ExplicitGroup g) {\n+        if (g.getId() == null) {\n+            em.persist(g);\n             return g;\n         } else {\n             // clean stale data once in a while\n-            if ( Math.random() >= 0.5 ) {\n+            if (Math.random() >= 0.5) {\n                 Set<String> stale = new TreeSet<>();\n-                for ( String idtf : g.getContainedRoleAssignees()) {\n-                    if ( roleAssigneeSvc.getRoleAssignee(idtf) == null ) {\n+                for (String idtf : g.getContainedRoleAssignees()) {\n+                    if (roleAssigneeSvc.getRoleAssignee(idtf) == null) {\n                         stale.add(idtf);\n                     }\n                 }\n-                if ( ! stale.isEmpty() ) {\n+\n+                if (!stale.isEmpty()) {\n                     g.getContainedRoleAssignees().removeAll(stale);\n                 }\n             }\n-            \n-            return em.merge( g );\n-        }    \n+            return em.merge(g);\n+        }\n     }\n-    \n-    public List<ExplicitGroup> findByOwner( Long dvObjectId ) {\n-        return provider.updateProvider(em.createNamedQuery( \"ExplicitGroup.findByOwnerId\", ExplicitGroup.class)\n-                 .setParameter(\"ownerId\", dvObjectId )\n-                 .getResultList());\n+\n+    public List<ExplicitGroup> findByOwner(Long dvObjectId) {\n+        return provider.updateProvider(em.createNamedQuery(\"ExplicitGroup.findByOwnerId\", ExplicitGroup.class).setParameter(\"ownerId\", dvObjectId).getResultList());\n     }\n-    \n+\n     ExplicitGroup findByAlias(String groupAlias) {\n-        try  {\n-            return provider.updateProvider( em.createNamedQuery(\"ExplicitGroup.findByAlias\", ExplicitGroup.class)\n-                    .setParameter(\"alias\", groupAlias)\n-                    .getSingleResult());\n-        } catch ( NoResultException nre ) {\n+        try {\n+            return provider.updateProvider(em.createNamedQuery(\"ExplicitGroup.findByAlias\", ExplicitGroup.class).setParameter(\"alias\", groupAlias).getSingleResult());\n+        } catch (NoResultException nre) {\n             return null;\n         }\n     }\n \n     public ExplicitGroup findInOwner(Long ownerId, String groupAliasInOwner) {\n-        try  {\n-            return provider.updateProvider( \n-                    em.createNamedQuery(\"ExplicitGroup.findByOwnerIdAndAlias\", ExplicitGroup.class)\n-                        .setParameter(\"alias\", groupAliasInOwner)\n-                        .setParameter(\"ownerId\", ownerId)\n-                        .getSingleResult());\n-        } catch ( NoResultException nre ) {\n+        try {\n+            return provider.updateProvider(em.createNamedQuery(\"ExplicitGroup.findByOwnerIdAndAlias\", ExplicitGroup.class).setParameter(\"alias\", groupAliasInOwner).setParameter(\"ownerId\", ownerId).getSingleResult());\n+        } catch (NoResultException nre) {\n             return null;\n         }\n     }\n \n     public void removeGroup(ExplicitGroup explicitGroup) {\n-        em.remove( explicitGroup );\n+        em.remove(explicitGroup);\n     }\n     \n     /**\n@@ -134,13 +110,14 @@ public class ExplicitGroupServiceBean {\n      * @param d The DvObject where the groups are queried\n      * @return All the explicit groups defined at {@code d} and its ancestors.\n      */\n-    public Set<ExplicitGroup> findAvailableFor( DvObject d ) {\n+\n+    public Set<ExplicitGroup> findAvailableFor(DvObject d) {\n         Set<ExplicitGroup> egs = new HashSet<>();\n-        while ( d != null ) {\n-            egs.addAll( findByOwner(d.getId()) );\n+        while (d != null) {\n+            egs.addAll(findByOwner(d.getId()));\n             d = d.getOwner();\n         }\n-        return provider.updateProvider( egs );\n+        return provider.updateProvider(egs);\n     }\n     \n     /**\n@@ -151,28 +128,14 @@ public class ExplicitGroupServiceBean {\n      * @return set of the explicit groups that contain {@code ra} directly.\n      * @see #findGroups(edu.harvard.iq.dataverse.authorization.RoleAssignee)\n      */\n-    public Set<ExplicitGroup> findDirectlyContainingGroups( RoleAssignee ra ) {\n-        if ( ra instanceof AuthenticatedUser ) {\n-            return provider.updateProvider(\n-                    new HashSet<>(\n-                            em.createNamedQuery(\"ExplicitGroup.findByAuthenticatedUserIdentifier\", ExplicitGroup.class)\n-                              .setParameter(\"authenticatedUserIdentifier\", ra.getIdentifier().substring(1))\n-                              .getResultList()\n-                  ));\n-        } else if ( ra instanceof ExplicitGroup ) {\n-            return provider.updateProvider(\n-                    new HashSet<>(\n-                            em.createNamedQuery(\"ExplicitGroup.findByContainedExplicitGroupId\", ExplicitGroup.class)\n-                              .setParameter(\"containedExplicitGroupId\", ((ExplicitGroup) ra).getId())\n-                              .getResultList()\n-                  ));\n+\n+    public Set<ExplicitGroup> findDirectlyContainingGroups(RoleAssignee ra) {\n+        if (ra instanceof AuthenticatedUser) {\n+            return provider.updateProvider(new HashSet<>(em.createNamedQuery(\"ExplicitGroup.findByAuthenticatedUserIdentifier\", ExplicitGroup.class).setParameter(\"authenticatedUserIdentifier\", ra.getIdentifier().substring(1)).getResultList()));\n+        } else if (ra instanceof ExplicitGroup) {\n+            return provider.updateProvider(new HashSet<>(em.createNamedQuery(\"ExplicitGroup.findByContainedExplicitGroupId\", ExplicitGroup.class).setParameter(\"containedExplicitGroupId\", ((ExplicitGroup) ra).getId()).getResultList()));\n         } else {\n-            return provider.updateProvider(\n-                    new HashSet<>(\n-                            em.createNamedQuery(\"ExplicitGroup.findByRoleAssgineeIdentifier\", ExplicitGroup.class)\n-                              .setParameter(\"roleAssigneeIdentifier\", ra.getIdentifier())\n-                              .getResultList()\n-                  ));\n+            return provider.updateProvider(new HashSet<>(em.createNamedQuery(\"ExplicitGroup.findByRoleAssgineeIdentifier\", ExplicitGroup.class).setParameter(\"roleAssigneeIdentifier\", ra.getIdentifier()).getResultList()));\n         }\n     }\n \n@@ -182,7 +145,8 @@ public class ExplicitGroupServiceBean {\n      * @param ra the role assignee whose membership list we seek\n      * @return set of the explicit groups that contain {@code ra}.\n      */\n-    public Set<ExplicitGroup> findGroups( RoleAssignee ra ) {\n+\n+    public Set<ExplicitGroup> findGroups(RoleAssignee ra) {\n         return findClosure(findDirectlyContainingGroups(ra));\n     }\n     \n@@ -193,10 +157,9 @@ public class ExplicitGroupServiceBean {\n      * @param o The {@link DvObject} whose context we search.\n      * @return All the groups in {@code o}'s context that {@code ra} is a member of.\n      */\n-    public Set<ExplicitGroup> findGroups( RoleAssignee ra, DvObject o ) {\n-        return findGroups(ra).stream()\n-                .filter( g -> g.owner.isAncestorOf(o) )\n-                .collect( Collectors.toSet() );\n+\n+    public Set<ExplicitGroup> findGroups(RoleAssignee ra, DvObject o) {\n+        return findGroups(ra).stream().filter(g -> g.owner.isAncestorOf(o)).collect(Collectors.toSet());\n     }\n     \n     /**\n@@ -210,38 +173,27 @@ public class ExplicitGroupServiceBean {\n      * @param o the DvObject that defines the context of the search.\n      * @return All the groups ra belongs to in the context of o.\n      */\n-    public Set<ExplicitGroup> findDirectGroups( RoleAssignee ra, DvObject o ) {\n-        if ( o == null ) {\n+\n+    public Set<ExplicitGroup> findDirectGroups(RoleAssignee ra, DvObject o) {\n+        if (o == null) {\n             return Collections.emptySet();\n         }\n+\n         List<ExplicitGroup> groupList = new LinkedList<>();\n-        \n-        if ( ra instanceof ExplicitGroup ) {\n-            for ( DvObject cur = o; cur != null; cur=cur.getOwner() ) {\n-                groupList.addAll( em.createNamedQuery(\"ExplicitGroup.findByOwnerAndSubExGroupId\", ExplicitGroup.class)\n-                  .setParameter(\"ownerId\", cur.getId())\n-                  .setParameter(\"subExGroupId\", ((ExplicitGroup)ra).getId())\n-                  .getResultList() );\n+        if (ra instanceof ExplicitGroup) {\n+            for (DvObject cur = o; cur != null; cur = cur.getOwner()) {\n+                groupList.addAll(em.createNamedQuery(\"ExplicitGroup.findByOwnerAndSubExGroupId\", ExplicitGroup.class).setParameter(\"ownerId\", cur.getId()).setParameter(\"subExGroupId\", ((ExplicitGroup) ra).getId()).getResultList());\n             }\n-            \n-        } else if ( ra instanceof AuthenticatedUser ) {\n-            for ( DvObject cur = o; cur != null; cur=cur.getOwner() ) {\n-                groupList.addAll( em.createNamedQuery(\"ExplicitGroup.findByOwnerAndAuthUserId\", ExplicitGroup.class)\n-                  .setParameter(\"ownerId\", cur.getId())\n-                  .setParameter(\"authUserId\", ((AuthenticatedUser)ra).getId())\n-                  .getResultList() );\n+        } else if (ra instanceof AuthenticatedUser) {\n+            for (DvObject cur = o; cur != null; cur = cur.getOwner()) {\n+                groupList.addAll(em.createNamedQuery(\"ExplicitGroup.findByOwnerAndAuthUserId\", ExplicitGroup.class).setParameter(\"ownerId\", cur.getId()).setParameter(\"authUserId\", ((AuthenticatedUser) ra).getId()).getResultList());\n             }\n-            \n         } else {\n-            for ( DvObject cur = o; cur != null; cur=cur.getOwner() ) {\n-                groupList.addAll( em.createNamedQuery(\"ExplicitGroup.findByOwnerAndRAIdtf\", ExplicitGroup.class)\n-                  .setParameter(\"ownerId\", cur.getId())\n-                  .setParameter(\"raIdtf\", ra.getIdentifier())\n-                  .getResultList() );\n+            for (DvObject cur = o; cur != null; cur = cur.getOwner()) {\n+                groupList.addAll(em.createNamedQuery(\"ExplicitGroup.findByOwnerAndRAIdtf\", ExplicitGroup.class).setParameter(\"ownerId\", cur.getId()).setParameter(\"raIdtf\", ra.getIdentifier()).getResultList());\n             }\n         }\n-        \n-        return provider.updateProvider( new HashSet<>(groupList) );\n+        return provider.updateProvider(new HashSet<>(groupList));\n     }\n     \n     /**\n@@ -252,18 +204,17 @@ public class ExplicitGroupServiceBean {\n      * @param seed the initial set of groups.\n      * @return Transitive closure (based on group  containment) of the groups in {@code seed}.\n      */\n-    protected Set<ExplicitGroup> findClosure( Set<ExplicitGroup> seed ) {\n-        \n-        if ( seed.isEmpty() ) return Collections.emptySet();\n-        \n-        String ids = seed.stream().map(eg->Long.toString(eg.getId())).collect( joining(\",\") );\n+\n+\n+    protected Set<ExplicitGroup> findClosure(Set<ExplicitGroup> seed) {\n+        if (seed.isEmpty()) return Collections.emptySet();\n+        String ids = seed.stream().map(eg -> Long.toString(eg.getId())).collect(joining(\",\"));\n         \n         // PSQL driver has issues with arrays and collections as parameters, so we're using \n         // string manipulation to create the query here. Not ideal, but seems to be\n         // the only solution at the Java Persistence level (i.e. without downcasting to org.postgresql.*)\n         String sqlCode = FIND_ALL_PARENTS_QUERY_TEMPLATE.replace(\"@IDS\", ids);\n-        return new HashSet<>(em.createNativeQuery(sqlCode, ExplicitGroup.class)\n-            .getResultList());\n+        return new HashSet<>(em.createNativeQuery(sqlCode, ExplicitGroup.class).getResultList());\n     }\n     \n     /**\n@@ -272,6 +223,7 @@ public class ExplicitGroupServiceBean {\n      * \n      * @param assignee User or Group \n      */\n+\n     public void revokeAllGroupsForAssignee(RoleAssignee assignee) {\n         if (assignee instanceof AuthenticatedUser) {\n             em.createNativeQuery(\"DELETE FROM explicitgroup_authenticateduser WHERE containedauthenticatedusers_id=\" + ((AuthenticatedUser) assignee).getId()).executeUpdate();\n@@ -279,6 +231,5 @@ public class ExplicitGroupServiceBean {\n             em.createNativeQuery(\"DELETE FROM explicitgroup_explicitgroup WHERE containedexplicitgroups_id=\" + ((ExplicitGroup) assignee).getId()).executeUpdate();\n         }\n     }\n-    \n-    \n-}\n+\n+}\n\\ No newline at end of file\n",
            "diff_size": 127
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "41",
                    "column": "1",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "41",
                    "column": "1",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ],
    "repaired_by": [
        "intellij",
        "codebuff"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "styler_random",
        "styler_three_grams"
    ]
}