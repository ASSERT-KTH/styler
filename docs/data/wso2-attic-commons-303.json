{
    "project_name": "wso2-attic-commons",
    "error_id": "303",
    "information": {
        "errors": [
            {
                "line": "345",
                "severity": "error",
                "message": "Line is longer than 120 characters (found 128).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": "        SequenceExecutor sequenceExecutor = null;\n        if (nextExecutor != null) {\n            sequenceExecutor = new SequenceExecutor(nextExecutor.state, nextExecutor.executor, nextExecutor.checkingStreamName);\n\n            if (nextExecutor.isLifeTimeSet()) {\n                sequenceExecutor.lifeTime=(nextExecutor.lifeTime);",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/303/SequenceExecutor.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler/303/SequenceExecutor.java\nindex 2643edbd662..c22a6a012e9 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/303/SequenceExecutor.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler/303/SequenceExecutor.java\n@@ -342,7 +342,8 @@ public class SequenceExecutor implements Executor {\n     public SequenceExecutor getNextNewExecutor() {\n         SequenceExecutor sequenceExecutor = null;\n         if (nextExecutor != null) {\n-            sequenceExecutor = new SequenceExecutor(nextExecutor.state, nextExecutor.executor, nextExecutor.checkingStreamName);\n+            sequenceExecutor = new SequenceExecutor(nextExecutor.\n+                    state, nextExecutor.executor, nextExecutor.checkingStreamName);\n \n             if (nextExecutor.isLifeTimeSet()) {\n                 sequenceExecutor.lifeTime=(nextExecutor.lifeTime);\n",
            "diff_size": 2
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/303/SequenceExecutor.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/intellij/303/SequenceExecutor.java\nindex 2643edbd662..df501eeb3bd 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/303/SequenceExecutor.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/intellij/303/SequenceExecutor.java\n@@ -2,9 +2,9 @@\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n- *\n+ * <p>\n  * http://www.apache.org/licenses/LICENSE-2.0\n- *\n+ * <p>\n  * Unless required by applicable law or agreed to in writing,\n  * software distributed under the License is distributed on an\n  * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n@@ -12,6 +12,7 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n+\n package org.wso2.siddhi.core.node.processor.executor;\n \n import org.wso2.siddhi.core.event.Event;\n@@ -24,347 +25,348 @@ import java.util.Set;\n  */\n public class SequenceExecutor implements Executor {\n \n-    private Executor executor;       //holds the simple executor for this SequenceExecutor\n-    private int state;               // State of the pattern i.e. 0->1->2\n-    private Event[][] arrivedEvents;\n-    private SequenceExecutor nextExecutor;\n-    private long expiringTime = 0;\n-    private String checkingStreamName;\n-    private boolean fireEvent = false;\n-    private boolean isStarExecutor = false;\n-    private long lifeTime = -1;          // -1 indicates the unlimited life time\n-\n-    /**\n-     * Get the life time of the Executor\n-     * @return  life time of the Executor\n-     */\n-    public long getLifeTime() {\n-        return lifeTime;\n-    }\n+  private Executor executor;       //holds the simple executor for this SequenceExecutor\n+  private int state;               // State of the pattern i.e. 0->1->2\n+  private Event[][] arrivedEvents;\n+  private SequenceExecutor nextExecutor;\n+  private long expiringTime = 0;\n+  private String checkingStreamName;\n+  private boolean fireEvent = false;\n+  private boolean isStarExecutor = false;\n+  private long lifeTime = -1;          // -1 indicates the unlimited life time\n \n-    /**\n-     * Set life time of the executor\n-     * @param lifeTime life time of the executor\n-     */\n-    public void setLifeTime(long lifeTime) {\n-        this.lifeTime = lifeTime;\n-    }\n+  /**\n+   * Get the life time of the Executor\n+   * @return life time of the Executor\n+   */\n+  public long getLifeTime() {\n+    return lifeTime;\n+  }\n \n-    /**\n-     * Check whether the lifetime is set\n-     * @return  whether the lifetime is set\n-     */\n-    public boolean isLifeTimeSet() {\n-        if (lifeTime != -1) {\n-            return true;\n-        }\n-        return false;\n-    }\n+  /**\n+   * Set life time of the executor\n+   * @param lifeTime life time of the executor\n+   */\n+  public void setLifeTime(long lifeTime) {\n+    this.lifeTime = lifeTime;\n+  }\n \n-    /**\n-     *  Enable this executor to fire an Event\n-     * @param fireEvent\n-     */\n-    public void enableFireEvent(boolean fireEvent) {\n-        this.fireEvent = fireEvent;\n+  /**\n+   * Check whether the lifetime is set\n+   * @return whether the lifetime is set\n+   */\n+  public boolean isLifeTimeSet() {\n+    if (lifeTime != -1) {\n+      return true;\n     }\n+    return false;\n+  }\n \n-    /**\n-     * Set expiring time of the executor\n-     * @param currentTime current system time\n-     */\n-    public void setExpiringTime(long currentTime) {\n-        this.expiringTime = currentTime + lifeTime;\n-    }\n+  /**\n+   *  Enable this executor to fire an Event\n+   * @param fireEvent\n+   */\n+  public void enableFireEvent(boolean fireEvent) {\n+    this.fireEvent = fireEvent;\n+  }\n \n-    /**\n-     * Get the simple executor of the Pattern executor\n-     * @return executor\n-     */\n-    public Executor getExecutor() {\n-        return executor;\n-    }\n+  /**\n+   * Set expiring time of the executor\n+   * @param currentTime current system time\n+   */\n+  public void setExpiringTime(long currentTime) {\n+    this.expiringTime = currentTime + lifeTime;\n+  }\n \n-    /**\n-     *  Get the state of the executor\n-     * @return  state\n-     */\n-    public int getState() {\n-        return state;\n-    }\n+  /**\n+   * Get the simple executor of the Pattern executor\n+   * @return executor\n+   */\n+  public Executor getExecutor() {\n+    return executor;\n+  }\n \n-    /**\n-     * Clear stored events in the executor\n-     */\n-    public void clearEvents() {\n-        arrivedEvents[state][0] = null;\n-        if (isStarExecutor) {\n-            arrivedEvents[state][1] = null;\n-            arrivedEvents[state][2] = null;\n-        }\n+  /**\n+   *  Get the state of the executor\n+   * @return state\n+   */\n+  public int getState() {\n+    return state;\n+  }\n \n+  /**\n+   * Clear stored events in the executor\n+   */\n+  public void clearEvents() {\n+    arrivedEvents[state][0] = null;\n+    if (isStarExecutor) {\n+      arrivedEvents[state][1] = null;\n+      arrivedEvents[state][2] = null;\n     }\n \n-    /**\n-     *  Pattern Executor\n-     * @param state  state of the executor\n-     * @param executor simple executor for the sequence executor\n-     * @param checkingStreamName stream name\n-     */\n-    public SequenceExecutor(int state, Executor executor, String checkingStreamName) {\n-        this.executor = executor;\n-        this.state = state;\n-        this.checkingStreamName = checkingStreamName;\n-    }\n+  }\n \n   /**\n-     *\n-     * @param state  state of the executor\n-     * @param executor simple executor for the sequence executor\n+   *  Pattern Executor\n+   * @param state  state of the executor\n+   * @param executor simple executor for the sequence executor\n+   * @param checkingStreamName stream name\n+   */\n+  public SequenceExecutor(int state, Executor executor, String checkingStreamName) {\n+    this.executor = executor;\n+    this.state = state;\n+    this.checkingStreamName = checkingStreamName;\n+  }\n+\n+  /**\n+   *\n+   * @param state  state of the executor\n+   * @param executor simple executor for the sequence executor\n    * Used at Condition passer (1st time)\n-     */\n-    public SequenceExecutor(int state, Executor executor) {\n-        this.executor = executor;\n-        this.state = state;\n-        this.checkingStreamName = (String) getCheckingStreamNames().toArray()[0];\n-    }\n+   */\n+  public SequenceExecutor(int state, Executor executor) {\n+    this.executor = executor;\n+    this.state = state;\n+    this.checkingStreamName = (String) getCheckingStreamNames().toArray()[0];\n+  }\n \n-    /**\n-     * @return whether the executor is alive\n-     */\n-    public boolean isAlive() {\n-        if (lifeTime == -1) {\n-            return true;\n-        } else if (expiringTime > System.currentTimeMillis()) {\n-            return true;\n-        }\n-        return false;\n+  /**\n+   * @return whether the executor is alive\n+   */\n+  public boolean isAlive() {\n+    if (lifeTime == -1) {\n+      return true;\n+    } else if (expiringTime > System.currentTimeMillis()) {\n+      return true;\n     }\n+    return false;\n+  }\n \n-    /**\n-     * initialize the arrivedEvents data structure\n-     */\n-    public void initArrivedEvents() {\n-        arrivedEvents = new Event[state + 1][];\n-        if (isStarExecutor) {\n-            arrivedEvents[state] = new Event[3];\n-        } else {\n-            arrivedEvents[state] = new Event[1];\n-        }\n+  /**\n+   * initialize the arrivedEvents data structure\n+   */\n+  public void initArrivedEvents() {\n+    arrivedEvents = new Event[state + 1][];\n+    if (isStarExecutor) {\n+      arrivedEvents[state] = new Event[3];\n+    } else {\n+      arrivedEvents[state] = new Event[1];\n     }\n-\n-    @Override\n-    public boolean execute(Event[] eventArray) {\n-        if (!isStarExecutor) {\n-            arrivedEvents[state][0] = eventArray[0];\n+  }\n+\n+  @Override\n+  public boolean execute(Event[] eventArray) {\n+    if (!isStarExecutor) {\n+      arrivedEvents[state][0] = eventArray[0];\n+    } else {\n+      if (null == arrivedEvents[state][0]) {\n+        arrivedEvents[state][0] = eventArray[0];\n+      } else {\n+        if (null == arrivedEvents[state][1]) {\n+          arrivedEvents[state][2] = arrivedEvents[state][0];\n         } else {\n-            if (null == arrivedEvents[state][0]) {\n-                arrivedEvents[state][0] = eventArray[0];\n-            } else {\n-                if (null == arrivedEvents[state][1]) {\n-                    arrivedEvents[state][2] = arrivedEvents[state][0];\n-                } else {\n-                    arrivedEvents[state][2] = arrivedEvents[state][1];\n-                }\n-                arrivedEvents[state][1] = eventArray[0];\n-            }\n+          arrivedEvents[state][2] = arrivedEvents[state][1];\n         }\n-        return this.executor.execute(arrivedEvents);\n+        arrivedEvents[state][1] = eventArray[0];\n+      }\n     }\n-\n-    @Override\n-    public boolean execute(Event event) {\n-        if (!isStarExecutor) {\n-            arrivedEvents[state][0] = event;\n+    return this.executor.execute(arrivedEvents);\n+  }\n+\n+  @Override\n+  public boolean execute(Event event) {\n+    if (!isStarExecutor) {\n+      arrivedEvents[state][0] = event;\n+    } else {\n+      if (null == arrivedEvents[state][0]) {\n+        arrivedEvents[state][0] = event;\n+      } else {\n+        if (null == arrivedEvents[state][1]) {\n+          arrivedEvents[state][2] = arrivedEvents[state][0];\n         } else {\n-            if (null == arrivedEvents[state][0]) {\n-                arrivedEvents[state][0] = event;\n-            } else {\n-                if (null == arrivedEvents[state][1]) {\n-                    arrivedEvents[state][2] = arrivedEvents[state][0];\n-                } else {\n-                    arrivedEvents[state][2] = arrivedEvents[state][1];\n-                }\n-                arrivedEvents[state][1] = event;\n-            }\n+          arrivedEvents[state][2] = arrivedEvents[state][1];\n         }\n-        return this.executor.execute(arrivedEvents);\n+        arrivedEvents[state][1] = event;\n+      }\n     }\n+    return this.executor.execute(arrivedEvents);\n+  }\n \n-    @Override\n-    public boolean execute(Event[][] eventArray) {\n-        return false;\n-    }\n-\n-    /**\n-     * @param sequenceExecutor\n-     */\n-    public void setNextExecutor(SequenceExecutor sequenceExecutor) {\n-        this.nextExecutor = sequenceExecutor;\n-    }\n-\n-    /**\n-     * Store the arrived events in the next executor and\n-     * @return Next Executor\n-     */\n-    public SequenceExecutor getNextExecutor() {\n-        return nextExecutor;\n-    }\n-\n-    /**\n-     * Check whether the next executor exists\n-     * @return  whether the next executor exists\n-     */\n-    public boolean isNextExecutorExist() {\n-        return nextExecutor != null;\n-    }\n-\n-    /**\n-     *  Check whether to fire an event\n-     * @return whether to fire an event\n-     */\n-    public boolean isFireEvent() {\n-        return fireEvent;\n-    }\n+  @Override\n+  public boolean execute(Event[][] eventArray) {\n+    return false;\n+  }\n \n-    /**\n-     *  Enable executor to fire an event\n-     */\n-    public void enableFireEvent() {\n-        fireEvent = true;\n-    }\n+  /**\n+   * @param sequenceExecutor\n+   */\n+  public void setNextExecutor(SequenceExecutor sequenceExecutor) {\n+    this.nextExecutor = sequenceExecutor;\n+  }\n \n-    /**\n-     * get stored events\n-     * @return the arrivedEvents\n-     */\n-    public Event[][] getArrivedEvents() {\n-        return arrivedEvents;\n-    }\n+  /**\n+   * Store the arrived events in the next executor and\n+   * @return Next Executor\n+   */\n+  public SequenceExecutor getNextExecutor() {\n+    return nextExecutor;\n+  }\n \n-    /**\n-     * Store arrived events\n-     * @param incomingEvents events to be stored\n-     */\n-    public void setArrivedEvents(Event[][] incomingEvents) {\n-        initArrivedEvents();\n-\n-        for (int i=0; i < incomingEvents.length; i++) {\n-                arrivedEvents[i]=new Event[incomingEvents[i].length];\n-            for (int j=0; j< incomingEvents[i].length; j++) {\n-                arrivedEvents[i][j] = incomingEvents[i][j];\n-            }\n-        }\n-    }\n+  /**\n+   * Check whether the next executor exists\n+   * @return whether the next executor exists\n+   */\n+  public boolean isNextExecutorExist() {\n+    return nextExecutor != null;\n+  }\n \n-    /**\n-     * @return checking stream names\n-     */\n-    public Set<String> getCheckingStreamNames() {\n-        return new HashSet<String>(executor.getCheckingStreamNames());\n-    }\n+  /**\n+   *  Check whether to fire an event\n+   * @return whether to fire an event\n+   */\n+  public boolean isFireEvent() {\n+    return fireEvent;\n+  }\n \n-    /**\n-     * @return checking stream name\n-     */\n-    public String getCheckingStreamName() {\n-        return checkingStreamName;\n-    }\n+  /**\n+   *  Enable executor to fire an event\n+   */\n+  public void enableFireEvent() {\n+    fireEvent = true;\n+  }\n \n-    /**\n-     * Check whether the executor is a star executor\n-     * @return whether the executor is a star executor\n-     */\n-    public boolean isStarExecutor() {\n-        return isStarExecutor;\n-    }\n+  /**\n+   * get stored events\n+   * @return the arrivedEvents\n+   */\n+  public Event[][] getArrivedEvents() {\n+    return arrivedEvents;\n+  }\n \n-    /**\n-     * Make executor a star executor\n-     * @param starExecutor\n-     */\n-    public void setStarExecutor(boolean starExecutor) {\n-        isStarExecutor = starExecutor;\n+  /**\n+   * Store arrived events\n+   * @param incomingEvents events to be stored\n+   */\n+  public void setArrivedEvents(Event[][] incomingEvents) {\n+    initArrivedEvents();\n+\n+    for (int i = 0; i < incomingEvents.length; i++) {\n+      arrivedEvents[i] = new Event[incomingEvents[i].length];\n+      for (int j = 0; j < incomingEvents[i].length; j++) {\n+        arrivedEvents[i][j] = incomingEvents[i][j];\n+      }\n     }\n+  }\n \n-    /**\n-     * Get new instance of the Pattern Executor\n-     * @return a new instance of the Pattern Executor\n-     */\n-    public SequenceExecutor getNewInstance() {\n-        SequenceExecutor sequenceExecutor = null;\n-        sequenceExecutor = new SequenceExecutor(state, executor, checkingStreamName);\n-\n-        if (isStarExecutor) {\n-            sequenceExecutor.isStarExecutor=(true);\n-        }\n+  /**\n+   * @return checking stream names\n+   */\n+  public Set<String> getCheckingStreamNames() {\n+    return new HashSet<String>(executor.getCheckingStreamNames());\n+  }\n \n-        if (isFireEvent()) {\n-            sequenceExecutor.enableFireEvent();\n-        }\n+  /**\n+   * @return checking stream name\n+   */\n+  public String getCheckingStreamName() {\n+    return checkingStreamName;\n+  }\n \n-        if (isNextExecutorExist()) {\n-            sequenceExecutor.nextExecutor=(nextExecutor);\n-        }\n+  /**\n+   * Check whether the executor is a star executor\n+   * @return whether the executor is a star executor\n+   */\n+  public boolean isStarExecutor() {\n+    return isStarExecutor;\n+  }\n \n-        sequenceExecutor.initArrivedEvents();\n+  /**\n+   * Make executor a star executor\n+   * @param starExecutor\n+   */\n+  public void setStarExecutor(boolean starExecutor) {\n+    isStarExecutor = starExecutor;\n+  }\n \n-        return sequenceExecutor;\n+  /**\n+   * Get new instance of the Pattern Executor\n+   * @return a new instance of the Pattern Executor\n+   */\n+  public SequenceExecutor getNewInstance() {\n+    SequenceExecutor sequenceExecutor = null;\n+    sequenceExecutor = new SequenceExecutor(state, executor, checkingStreamName);\n+\n+    if (isStarExecutor) {\n+      sequenceExecutor.isStarExecutor = (true);\n     }\n \n-    /**\n-     *\n-     * @return a new instance of the same executor\n-     */\n-    public SequenceExecutor getNextThisExecutor() {\n-        SequenceExecutor sequenceExecutor = null;\n-        sequenceExecutor = new SequenceExecutor(state, executor, checkingStreamName);\n-\n-        if (isStarExecutor) {\n-            sequenceExecutor.isStarExecutor=(true);\n-        }\n-\n-        if (fireEvent) {\n-            sequenceExecutor.enableFireEvent();\n-        }\n-\n-        if (isNextExecutorExist()) {\n-            sequenceExecutor.nextExecutor=(nextExecutor);\n-        }\n-        sequenceExecutor.setArrivedEvents(arrivedEvents);\n+    if (isFireEvent()) {\n+      sequenceExecutor.enableFireEvent();\n+    }\n \n-        return sequenceExecutor;\n+    if (isNextExecutorExist()) {\n+      sequenceExecutor.nextExecutor = (nextExecutor);\n     }\n \n-    /**\n-     * @return as instance of next executor\n-     */\n-    public SequenceExecutor getNextNewExecutor() {\n-        SequenceExecutor sequenceExecutor = null;\n-        if (nextExecutor != null) {\n-            sequenceExecutor = new SequenceExecutor(nextExecutor.state, nextExecutor.executor, nextExecutor.checkingStreamName);\n+    sequenceExecutor.initArrivedEvents();\n \n-            if (nextExecutor.isLifeTimeSet()) {\n-                sequenceExecutor.lifeTime=(nextExecutor.lifeTime);\n-                sequenceExecutor.expiringTime=(System.currentTimeMillis());\n-            }\n+    return sequenceExecutor;\n+  }\n \n-            if (nextExecutor.isStarExecutor) {\n-                sequenceExecutor.isStarExecutor=(true);\n-            }\n+  /**\n+   *\n+   * @return a new instance of the same executor\n+   */\n+  public SequenceExecutor getNextThisExecutor() {\n+    SequenceExecutor sequenceExecutor = null;\n+    sequenceExecutor = new SequenceExecutor(state, executor, checkingStreamName);\n+\n+    if (isStarExecutor) {\n+      sequenceExecutor.isStarExecutor = (true);\n+    }\n \n-            if (nextExecutor.fireEvent) {\n-                sequenceExecutor.enableFireEvent();\n-            }\n+    if (fireEvent) {\n+      sequenceExecutor.enableFireEvent();\n+    }\n \n-            if (nextExecutor.isNextExecutorExist()) {\n-                sequenceExecutor.nextExecutor=(nextExecutor.nextExecutor);\n-            }\n+    if (isNextExecutorExist()) {\n+      sequenceExecutor.nextExecutor = (nextExecutor);\n+    }\n+    sequenceExecutor.setArrivedEvents(arrivedEvents);\n \n-            sequenceExecutor.setArrivedEvents(arrivedEvents);\n-        }\n+    return sequenceExecutor;\n+  }\n \n-        return sequenceExecutor;\n+  /**\n+   * @return as instance of next executor\n+   */\n+  public SequenceExecutor getNextNewExecutor() {\n+    SequenceExecutor sequenceExecutor = null;\n+    if (nextExecutor != null) {\n+      sequenceExecutor =\n+        new SequenceExecutor(nextExecutor.state, nextExecutor.executor, nextExecutor.checkingStreamName);\n+\n+      if (nextExecutor.isLifeTimeSet()) {\n+        sequenceExecutor.lifeTime = (nextExecutor.lifeTime);\n+        sequenceExecutor.expiringTime = (System.currentTimeMillis());\n+      }\n+\n+      if (nextExecutor.isStarExecutor) {\n+        sequenceExecutor.isStarExecutor = (true);\n+      }\n+\n+      if (nextExecutor.fireEvent) {\n+        sequenceExecutor.enableFireEvent();\n+      }\n+\n+      if (nextExecutor.isNextExecutorExist()) {\n+        sequenceExecutor.nextExecutor = (nextExecutor.nextExecutor);\n+      }\n+\n+      sequenceExecutor.setArrivedEvents(arrivedEvents);\n     }\n \n+    return sequenceExecutor;\n+  }\n+\n }\n",
            "diff_size": 408
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "345",
                    "severity": "error",
                    "message": "Line is longer than 120 characters (found 128).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/303/SequenceExecutor.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/naturalize/303/SequenceExecutor.java\nindex 2643edbd662..1c0a0a9f9e4 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/303/SequenceExecutor.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/naturalize/303/SequenceExecutor.java\n@@ -32,7 +32,7 @@ public class SequenceExecutor implements Executor {\n     private String checkingStreamName;\n     private boolean fireEvent = false;\n     private boolean isStarExecutor = false;\n-    private long lifeTime = -1;          // -1 indicates the unlimited life time\n+    private long lifeTime = -1; // -1 indicates the unlimited life time\n \n     /**\n      * Get the life time of the Executor\n@@ -251,7 +251,7 @@ public class SequenceExecutor implements Executor {\n \n         for (int i=0; i < incomingEvents.length; i++) {\n                 arrivedEvents[i]=new Event[incomingEvents[i].length];\n-            for (int j=0; j< incomingEvents[i].length; j++) {\n+            for (int j=0; j < incomingEvents[i].length; j++) {\n                 arrivedEvents[i][j] = incomingEvents[i][j];\n             }\n         }\n@@ -367,4 +367,4 @@ public class SequenceExecutor implements Executor {\n         return sequenceExecutor;\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 3
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "345",
                    "severity": "error",
                    "message": "Line is longer than 120 characters (found 128).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/303/SequenceExecutor.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler_three_grams/303/SequenceExecutor.java\nindex 2643edbd662..c22a6a012e9 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/303/SequenceExecutor.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler_three_grams/303/SequenceExecutor.java\n@@ -342,7 +342,8 @@ public class SequenceExecutor implements Executor {\n     public SequenceExecutor getNextNewExecutor() {\n         SequenceExecutor sequenceExecutor = null;\n         if (nextExecutor != null) {\n-            sequenceExecutor = new SequenceExecutor(nextExecutor.state, nextExecutor.executor, nextExecutor.checkingStreamName);\n+            sequenceExecutor = new SequenceExecutor(nextExecutor.\n+                    state, nextExecutor.executor, nextExecutor.checkingStreamName);\n \n             if (nextExecutor.isLifeTimeSet()) {\n                 sequenceExecutor.lifeTime=(nextExecutor.lifeTime);\n",
            "diff_size": 2
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "naturalize",
        "codebuff",
        "styler_random"
    ]
}