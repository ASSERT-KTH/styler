{
    "project_name": "CESNET-perun",
    "error_id": "236",
    "information": {
        "errors": [
            {
                "line": "310",
                "severity": "error",
                "message": "Line matches the illegal pattern 'Wrong number of tabs before space on next line. Indent must use tab characters.'.",
                "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpCheck"
            }
        ]
    },
    "source_code": "\n\t\tString text;\n\t\ttry {\n\t\t\t text = (String) expr.evaluate(node, XPathConstants.STRING);\n\t\t} catch (XPathExpressionException ex) {\n\t\t\tthrow new InternalErrorException(\"Error when evaluate xpath query on node.\", ex);",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/236/ExtSourceXML.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/styler/236/ExtSourceXML.java\nindex 8a9719bb496..e0f6b219ef6 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/236/ExtSourceXML.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/styler/236/ExtSourceXML.java\n@@ -308,7 +308,7 @@ public class ExtSourceXML extends ExtSource implements ExtSourceApi {\n \n \t\tString text;\n \t\ttry {\n-\t\t\t text = (String) expr.evaluate(node, XPathConstants.STRING);\n+\t\t\ttext = (String) expr.evaluate(node, XPathConstants.STRING);\n \t\t} catch (XPathExpressionException ex) {\n \t\t\tthrow new InternalErrorException(\"Error when evaluate xpath query on node.\", ex);\n \t\t}\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/236/ExtSourceXML.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/intellij/236/ExtSourceXML.java\nindex 8a9719bb496..732266d3087 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/236/ExtSourceXML.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/intellij/236/ExtSourceXML.java\n@@ -8,12 +8,14 @@ import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import java.net.HttpURLConnection;\n+\n import cz.metacentrum.perun.core.api.ExtSource;\n import cz.metacentrum.perun.core.api.GroupsManager;\n import cz.metacentrum.perun.core.api.exceptions.ExtSourceUnsupportedOperationException;\n import cz.metacentrum.perun.core.api.exceptions.InternalErrorException;\n import cz.metacentrum.perun.core.api.exceptions.SubjectNotExistsException;\n import cz.metacentrum.perun.core.implApi.ExtSourceApi;\n+\n import java.io.IOException;\n import javax.xml.xpath.XPathConstants;\n import java.util.HashMap;\n@@ -27,14 +29,17 @@ import javax.xml.xpath.XPath;\n import javax.xml.xpath.XPathExpression;\n import javax.xml.xpath.XPathExpressionException;\n import javax.xml.xpath.XPathFactory;\n+\n import org.w3c.dom.Document;\n import org.w3c.dom.Node;\n import org.w3c.dom.NodeList;\n import org.xml.sax.SAXException;\n+\n import java.io.InputStream;\n import java.net.URL;\n import javax.net.ssl.HttpsURLConnection;\n import javax.net.ssl.SSLSocketFactory;\n+\n import org.codehaus.jackson.annotate.JsonIgnore;\n import org.xml.sax.SAXParseException;\n \n@@ -44,329 +49,344 @@ import org.xml.sax.SAXParseException;\n  */\n public class ExtSourceXML extends ExtSource implements ExtSourceApi {\n \n-\tprivate final static Logger log = LoggerFactory.getLogger(ExtSourceXML.class);\n-\n-\tprivate String query = null;\n-\tprivate String loginQuery = null;\n-\tprivate String file = null;\n-\tprivate String uri = null;\n-\n-\tprivate static PerunBlImpl perunBl;\n-\n-\t// filled by spring (perun-core.xml)\n-\tpublic static PerunBlImpl setPerunBlImpl(PerunBlImpl perun) {\n-\t\tperunBl = perun;\n-\t\treturn perun;\n-\t}\n-\n-\t//URL connection\n-\tprivate HttpURLConnection con = null;\n-\n-\t//Pattern for looking replacement in regex string\n-\tprivate Pattern pattern = Pattern.compile(\"([^\\\\\\\\]|^)(\\\\\\\\\\\\\\\\)*\\\\/([^\\\\\\\\]|$)\");\n-\n-\t@Override\n-\tpublic List<Map<String,String>> findSubjectsLogins(String searchString) throws InternalErrorException, ExtSourceUnsupportedOperationException {\n-\t\treturn findSubjectsLogins(searchString, 0);\n-\t}\n-\n-\t@Override\n-\tpublic List<Map<String,String>> findSubjectsLogins(String searchString, int maxResulsts) throws InternalErrorException, ExtSourceUnsupportedOperationException {\n-\t\tthrow new ExtSourceUnsupportedOperationException(\"For XML is using this method not optimized, use findSubjects instead.\");\n-\t}\n-\n-\t@Override\n-\tpublic List<Map<String,String>> findSubjects(String searchString) throws InternalErrorException, ExtSourceUnsupportedOperationException {\n-\t\treturn findSubjects(searchString, 0);\n-\t}\n-\n-\t@Override\n-\tpublic List<Map<String,String>> findSubjects(String searchString, int maxResults) throws InternalErrorException, ExtSourceUnsupportedOperationException {\n-\t\t//prepare string for xpath (use concat for chars ' and  \")\n-\t\tsearchString = convertToXpathSearchString(searchString);\n-\n-\t\t//Get Query attribute from extSources.xml config file\n-\t\tquery = (String) getAttributes().get(\"xpath\");\n-\t\tif (query == null || query.isEmpty()) {\n-\t\t\tthrow new InternalErrorException(\"query attributes is required\");\n-\t\t}\n-\n-\t\t//Replace '?' by searchString\n-\t\tif(searchString == null) {\n-\t\t\tthrow new InternalErrorException(\"search string can't be null\");\n-\t\t}\n-\t\tquery = query.replaceAll(\"\\\\?\", searchString);\n-\n-\t\t//Get file or uri of xml\n-\t\tprepareEnvironment();\n+    private final static Logger log = LoggerFactory.getLogger(ExtSourceXML.class);\n \n-\t\treturn xpathParsing(query, maxResults);\n-\t}\n+    private String query = null;\n+    private String loginQuery = null;\n+    private String file = null;\n+    private String uri = null;\n+\n+    private static PerunBlImpl perunBl;\n \n-\t@Override\n-\tpublic Map<String, String> getSubjectByLogin(String login) throws InternalErrorException, SubjectNotExistsException {\n-\t\t//prepare string for xpath (use concat for chars ' and  \")\n-\t\tlogin = convertToXpathSearchString(login);\n-\n-\t\t//Get Query attribute from extSources.xml config file\n-\t\tquery = (String) getAttributes().get(\"loginXpath\");\n-\t\tif (query == null || query.isEmpty()) {\n-\t\t\tthrow new InternalErrorException(\"query attributes is required\");\n-\t\t}\n-\n-\t\t//Replace '?' by searchString\n-\t\tif(login == null || login.isEmpty()) {\n-\t\t\tthrow new InternalErrorException(\"login string can't be null or empty\");\n-\t\t}\n-\t\tquery = query.replaceAll(\"\\\\?\", login);\n-\n-\t\t//Get file or uri of xml\n-\t\tprepareEnvironment();\n-\n-\t\tList<Map<String, String>> subjects = this.xpathParsing(query, 0);\n-\n-\t\tif (subjects.size() > 1) {\n-\t\t\tthrow new SubjectNotExistsException(\"There are more than one results for the login: \" + login);\n-\t\t}\n-\n-\t\tif (subjects.size() == 0) {\n-\t\t\tthrow new SubjectNotExistsException(login);\n-\t\t}\n-\n-\t\treturn subjects.get(0);\n-\t}\n-\n-\t@Override\n-\tpublic List<Map<String, String>> getGroupSubjects(Map<String, String> attributes) throws InternalErrorException, ExtSourceUnsupportedOperationException {\n-\t\t// Get the query for the group subjects\n-\t\tString queryForGroup = attributes.get(GroupsManager.GROUPMEMBERSQUERY_ATTRNAME);\n-\n-\t\t//If there is no query for group, throw exception\n-\t\tif(queryForGroup == null) throw new InternalErrorException(\"Attribute \" + GroupsManager.GROUPMEMBERSQUERY_ATTRNAME + \" can't be null.\");\n-\n-\t\t//Get file or uri of xml\n-\t\tprepareEnvironment();\n-\n-\t\treturn xpathParsing(queryForGroup, 0);\n-\t}\n-\n-\tprotected void prepareEnvironment() throws InternalErrorException {\n-\t\t//Get file or uri of xml\n-\t\tfile = (String) getAttributes().get(\"file\");\n-\t\tif(file == null || file.isEmpty()) {\n-\t\t\tfile = null;\n-\t\t\turi = (String) getAttributes().get(\"uri\");\n-\t\t\tif(uri == null || uri.isEmpty()) {\n-\t\t\t\tthrow new InternalErrorException(\"File and uri are both empty, one must exists!.\");\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Get query and maxResults.\n-\t * Prepare document and xpathExpression by query.\n-\t * Get all nodes by xpath from document and parse them one by one.\n-\t *\n-\t * The way of xml take from \"file\" or \"uri\" (configuration file)\n-\t *\n-\t * @param query xpath query from config file\n-\t * @param maxResults never get more than maxResults results (0 mean unlimited)\n-\t *\n-\t * @return List of results, where result is Map<String,String> like <name, value>\n-\t * @throws InternalErrorException\n-\t */\n-\tprotected List<Map<String,String>> xpathParsing(String query, int maxResults) throws InternalErrorException {\n-\t\t//Prepare result list\n-\t\tList<Map<String, String>> subjects = new ArrayList<Map<String, String>>();\n-\n-\t\t//Create new document factory builder\n-\t\tDocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n-\t\tDocumentBuilder builder;\n-\t\ttry {\n-\t\t\tbuilder = factory.newDocumentBuilder();\n-\t\t} catch (ParserConfigurationException ex) {\n-\t\t\tthrow new InternalErrorException(\"Error when creating newDocumentBuilder.\", ex);\n-\t\t}\n-\n-\t\tDocument doc;\n-\t\ttry {\n-\t\t\tif(file != null && !file.isEmpty()) {\n-\t\t\t\tdoc = builder.parse(file);\n-\t\t\t} else if(uri != null && !uri.isEmpty()) {\n-\t\t\t\tdoc = builder.parse(this.createTwoWaySSLConnection(uri));\n-\t\t\t} else {\n-\t\t\t\tthrow new InternalErrorException(\"Document can't be parsed, because there is no way (file or uri) to this document in xpathParser.\");\n-\t\t\t}\n-\t\t} catch (SAXParseException ex) {\n-\t\t\tthrow new InternalErrorException(\"Error when parsing uri by document builder.\", ex);\n-\t\t} catch (SAXException ex) {\n-\t\t\tthrow new InternalErrorException(\"Problem with parsing is more complex, not only invalid characters.\", ex);\n-\t\t} catch (IOException ex) {\n-\t\t\tthrow new InternalErrorException(\"Error when parsing uri by document builder. Problem with input or output.\", ex);\n-\t\t}\n-\n-\t\t//Prepare xpath expression\n-\t\tXPathFactory xPathfactory = XPathFactory.newInstance();\n-\t\tXPath xpath = xPathfactory.newXPath();\n-\t\tXPathExpression queryExpr;\n-\t\ttry {\n-\t\t\tqueryExpr = xpath.compile(query);\n-\t\t} catch (XPathExpressionException ex) {\n-\t\t\tthrow new InternalErrorException(\"Error when compiling xpath query.\", ex);\n-\t\t}\n-\n-\t\t//Call query on document node and get back nodesets\n-\t\tNodeList nodeList;\n-\t\ttry {\n-\t\t\tnodeList = (NodeList) queryExpr.evaluate(doc, XPathConstants.NODESET);\n-\t\t} catch (XPathExpressionException ex) {\n-\t\t\tthrow new InternalErrorException(\"Error when evaluate xpath query on document.\", ex);\n-\t\t}\n-\n-\t\t//Test if there is any nodeset in result\n-\t\tif(nodeList.getLength() == 0) {\n-\t\t\t//There is no results, return empty subjects\n-\t\t\treturn subjects;\n-\t\t}\n-\n-\t\t//Iterate through nodes and convert them to Map<String,String>\n-\t\tfor(int i=0; i<nodeList.getLength(); i++) {\n-\t\t\tNode singleNode = nodeList.item(i);\n-\t\t\t// remove node from original structure in order to keep access time constant (otherwise is exp.)\n-\t\t\tsingleNode.getParentNode().removeChild(singleNode);\n-\t\t\tMap<String,String> map = convertNodeToMap(singleNode);\n-\t\t\tif(map != null) subjects.add(map);\n-\t\t\t//Reducing results by maxResults\n-\t\t\tif(maxResults > 0) {\n-\t\t\t\tif(subjects.size() >= maxResults) break;\n-\t\t\t}\n-\t\t}\n-\n-\t\tthis.close();\n-\t\treturn subjects;\n-\t}\n-\n-\t/**\n-\t * Get XML node and convert all values by \"xmlMapping\" attribute to Map<String,String>\n-\t * In map there are \"name=value\" data.\n-\t *\n-\t * Attribute xmlMapping is from file perun-extSource.xml\n-\t *\n-\t * @param node node for converting\n-\t * @return Map<String,String> like <name,value>\n-\t * @throws InternalErrorException\n-\t */\n-\tprotected Map<String, String> convertNodeToMap(Node node) throws InternalErrorException {\n-\t\tMap<String,String> nodeInMap = new HashMap<String,String>();\n-\t\t//If node is empty, return null\n-\t\tif(node == null) return null;\n-\n-\t\tString mapping = getAttributes().get(\"xmlMapping\");\n-\t\tString[] mappingArray = mapping.split(\",\\n\");\n-\n-\t\tfor(int i=0; i<mappingArray.length; i++) {\n-\t\t\tString attr = mappingArray[i].trim();\n-\n-\t\t\tint index = attr.indexOf(\"=\");\n-\n-\t\t\tif(index <= 0) throw new InternalErrorException(\"There is no text in xmlMapping attribute or there is no '=' character.\");\n-\t\t\tString name = attr.substring(0, index);\n-\t\t\tString value = attr.substring(index +1);\n-\n-\t\t\tif(value.startsWith(\"#\")) {\n-\t\t\t\tvalue = value.substring(1);\n-\t\t\t\tString[] regexAndXpath = value.split(\"#\");\n-\t\t\t\tif(regexAndXpath.length != 2) throw new InternalErrorException(\"There is not only 2 parts (regex and XpathExpression). There are \" + regexAndXpath.length + \" parts.\");\n-\t\t\t\tvalue = extractValueByRegex(getValueFromXpath(node, regexAndXpath[1]), regexAndXpath[0]);\n-\t\t\t} else {\n-\t\t\t\tvalue = getValueFromXpath(node, value);\n-\t\t\t}\n-\t\t\tnodeInMap.put(name.trim(), value.trim());\n-\t\t}\n-\n-\t\treturn nodeInMap;\n-\t}\n-\n-\t/**\n-\t * Get xml Node and xpath expression to get value from node by this xpath.\n-\t *\n-\t * @param node node for getting value from\n-\t * @param xpathExpression expression for xpath to looking for value in node\n-\t * @return string extracted from node by xpath\n-\t * @throws InternalErrorException\n-\t */\n-\tprotected String getValueFromXpath(Node node, String xpathExpression) throws InternalErrorException {\n-\t\t//Prepare xpath expression\n-\t\tXPathFactory xPathfactory = XPathFactory.newInstance();\n-\t\tXPath xpath = xPathfactory.newXPath();\n-\t\tXPathExpression expr;\n-\t\ttry {\n-\t\t\texpr = xpath.compile(xpathExpression);\n-\t\t} catch (XPathExpressionException ex) {\n-\t\t\tthrow new InternalErrorException(\"Error when compiling xpath query.\", ex);\n-\t\t}\n-\n-\t\tString text;\n-\t\ttry {\n-\t\t\t text = (String) expr.evaluate(node, XPathConstants.STRING);\n-\t\t} catch (XPathExpressionException ex) {\n-\t\t\tthrow new InternalErrorException(\"Error when evaluate xpath query on node.\", ex);\n-\t\t}\n-\n-\t\treturn text;\n-\t}\n-\n-\t/**\n-\t * Get regex in format 'regex/replacement' and value to get data from.\n-\t * Use regex and replacement to get data from value.\n-\t *\n-\t * IMPORTANT: Regex must be always in format 'regex/replacement' and must have\n-\t *\t\t\t\t\t\texactly 1 existence of character '/' ex. '[abc](a)[b]/$1'\n-\t *\n-\t * @param value some string\n-\t * @param regex regex in format 'regex/replacement'\n-\t * @return extracted string from value by regex\n-\t *\n-\t * @throws InternalErrorException\n-\t */\n-\tprotected String extractValueByRegex(String value, String regex) throws InternalErrorException {\n-\t\t//trim value to erase newlines and spaces before and after value\n-\t\tvalue = value.trim();\n-\t\t//regex need to be separate to 2 parts (regex) and (replacement) separated by backslash - ex 'regex/replacement'\n-\t\tMatcher match = pattern.matcher(regex);\n-\n-\t\t//need to separate regex to regexPart and replacementPart\n-\t\tString regexPart;\n-\t\tString replacementPart;\n-\t\tif(match.find()) {\n-\t\t\tint i = match.end();\n-\t\t\tif(match.find()) throw new InternalErrorException(\"There is more then one separating forward slash in regex without escaping.\");\n-\t\t\twhile(regex.charAt(i) != '/') {\n-\t\t\t\ti--;\n-\t\t\t\tif(i < 0) throw new InternalErrorException(\"Index of forward slash not found.\");\n-\t\t\t}\n-\t\t\tregexPart = regex.substring(0, i);\n-\t\t\treplacementPart = regex.substring(i+1);\n-\t\t} else {\n-\t\t\tthrow new InternalErrorException(\"There is no replacement in regex.\");\n-\t\t}\n-\n-\t\t//use regex and replacement to get string from value\n-\t\tvalue = value.replaceAll(regexPart, replacementPart);\n-\t\treturn value;\n-\t}\n-\n-\t/**\n-\t * Get https uri of xml document and create two way ssl connection using truststore and keystore.\n-\t *\n-\t * @param uri https uri to xml document\n-\t * @return input stream with xml document\n-\t *\n-\t * @throws IOException if there is some input/output error\n-\t * @throws InternalErrorException if some variables are not correctly filled\n-\t */\n-\tprotected InputStream createTwoWaySSLConnection(String uri) throws IOException, InternalErrorException {\n-\t\tif(uri == null || uri.isEmpty()) throw new InternalErrorException(\"Uri must be filled, can't be null or empty.\");\n+    // filled by spring (perun-core.xml)\n+    public static PerunBlImpl setPerunBlImpl(PerunBlImpl perun) {\n+        perunBl = perun;\n+        return perun;\n+    }\n+\n+    //URL connection\n+    private HttpURLConnection con = null;\n+\n+    //Pattern for looking replacement in regex string\n+    private Pattern pattern = Pattern.compile(\"([^\\\\\\\\]|^)(\\\\\\\\\\\\\\\\)*\\\\/([^\\\\\\\\]|$)\");\n+\n+    @Override\n+    public List<Map<String, String>> findSubjectsLogins(String searchString) throws InternalErrorException, ExtSourceUnsupportedOperationException {\n+        return findSubjectsLogins(searchString, 0);\n+    }\n+\n+    @Override\n+    public List<Map<String, String>> findSubjectsLogins(String searchString, int maxResulsts) throws InternalErrorException, ExtSourceUnsupportedOperationException {\n+        throw new ExtSourceUnsupportedOperationException(\"For XML is using this method not optimized, use findSubjects instead.\");\n+    }\n+\n+    @Override\n+    public List<Map<String, String>> findSubjects(String searchString) throws InternalErrorException, ExtSourceUnsupportedOperationException {\n+        return findSubjects(searchString, 0);\n+    }\n+\n+    @Override\n+    public List<Map<String, String>> findSubjects(String searchString, int maxResults) throws InternalErrorException, ExtSourceUnsupportedOperationException {\n+        //prepare string for xpath (use concat for chars ' and  \")\n+        searchString = convertToXpathSearchString(searchString);\n+\n+        //Get Query attribute from extSources.xml config file\n+        query = (String) getAttributes().get(\"xpath\");\n+        if (query == null || query.isEmpty()) {\n+            throw new InternalErrorException(\"query attributes is required\");\n+        }\n+\n+        //Replace '?' by searchString\n+        if (searchString == null) {\n+            throw new InternalErrorException(\"search string can't be null\");\n+        }\n+        query = query.replaceAll(\"\\\\?\", searchString);\n+\n+        //Get file or uri of xml\n+        prepareEnvironment();\n+\n+        return xpathParsing(query, maxResults);\n+    }\n+\n+    @Override\n+    public Map<String, String> getSubjectByLogin(String login) throws InternalErrorException, SubjectNotExistsException {\n+        //prepare string for xpath (use concat for chars ' and  \")\n+        login = convertToXpathSearchString(login);\n+\n+        //Get Query attribute from extSources.xml config file\n+        query = (String) getAttributes().get(\"loginXpath\");\n+        if (query == null || query.isEmpty()) {\n+            throw new InternalErrorException(\"query attributes is required\");\n+        }\n+\n+        //Replace '?' by searchString\n+        if (login == null || login.isEmpty()) {\n+            throw new InternalErrorException(\"login string can't be null or empty\");\n+        }\n+        query = query.replaceAll(\"\\\\?\", login);\n+\n+        //Get file or uri of xml\n+        prepareEnvironment();\n+\n+        List<Map<String, String>> subjects = this.xpathParsing(query, 0);\n+\n+        if (subjects.size() > 1) {\n+            throw new SubjectNotExistsException(\"There are more than one results for the login: \" + login);\n+        }\n+\n+        if (subjects.size() == 0) {\n+            throw new SubjectNotExistsException(login);\n+        }\n+\n+        return subjects.get(0);\n+    }\n+\n+    @Override\n+    public List<Map<String, String>> getGroupSubjects(Map<String, String> attributes) throws InternalErrorException, ExtSourceUnsupportedOperationException {\n+        // Get the query for the group subjects\n+        String queryForGroup = attributes.get(GroupsManager.GROUPMEMBERSQUERY_ATTRNAME);\n+\n+        //If there is no query for group, throw exception\n+        if (queryForGroup == null) {\n+            throw new InternalErrorException(\"Attribute \" + GroupsManager.GROUPMEMBERSQUERY_ATTRNAME + \" can't be null.\");\n+        }\n+\n+        //Get file or uri of xml\n+        prepareEnvironment();\n+\n+        return xpathParsing(queryForGroup, 0);\n+    }\n+\n+    protected void prepareEnvironment() throws InternalErrorException {\n+        //Get file or uri of xml\n+        file = (String) getAttributes().get(\"file\");\n+        if (file == null || file.isEmpty()) {\n+            file = null;\n+            uri = (String) getAttributes().get(\"uri\");\n+            if (uri == null || uri.isEmpty()) {\n+                throw new InternalErrorException(\"File and uri are both empty, one must exists!.\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get query and maxResults.\n+     * Prepare document and xpathExpression by query.\n+     * Get all nodes by xpath from document and parse them one by one.\n+     * <p>\n+     * The way of xml take from \"file\" or \"uri\" (configuration file)\n+     *\n+     * @param query      xpath query from config file\n+     * @param maxResults never get more than maxResults results (0 mean unlimited)\n+     * @return List of results, where result is Map<String,String> like <name, value>\n+     * @throws InternalErrorException\n+     */\n+    protected List<Map<String, String>> xpathParsing(String query, int maxResults) throws InternalErrorException {\n+        //Prepare result list\n+        List<Map<String, String>> subjects = new ArrayList<Map<String, String>>();\n+\n+        //Create new document factory builder\n+        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n+        DocumentBuilder builder;\n+        try {\n+            builder = factory.newDocumentBuilder();\n+        } catch (ParserConfigurationException ex) {\n+            throw new InternalErrorException(\"Error when creating newDocumentBuilder.\", ex);\n+        }\n+\n+        Document doc;\n+        try {\n+            if (file != null && !file.isEmpty()) {\n+                doc = builder.parse(file);\n+            } else if (uri != null && !uri.isEmpty()) {\n+                doc = builder.parse(this.createTwoWaySSLConnection(uri));\n+            } else {\n+                throw new InternalErrorException(\"Document can't be parsed, because there is no way (file or uri) to this document in xpathParser.\");\n+            }\n+        } catch (SAXParseException ex) {\n+            throw new InternalErrorException(\"Error when parsing uri by document builder.\", ex);\n+        } catch (SAXException ex) {\n+            throw new InternalErrorException(\"Problem with parsing is more complex, not only invalid characters.\", ex);\n+        } catch (IOException ex) {\n+            throw new InternalErrorException(\"Error when parsing uri by document builder. Problem with input or output.\", ex);\n+        }\n+\n+        //Prepare xpath expression\n+        XPathFactory xPathfactory = XPathFactory.newInstance();\n+        XPath xpath = xPathfactory.newXPath();\n+        XPathExpression queryExpr;\n+        try {\n+            queryExpr = xpath.compile(query);\n+        } catch (XPathExpressionException ex) {\n+            throw new InternalErrorException(\"Error when compiling xpath query.\", ex);\n+        }\n+\n+        //Call query on document node and get back nodesets\n+        NodeList nodeList;\n+        try {\n+            nodeList = (NodeList) queryExpr.evaluate(doc, XPathConstants.NODESET);\n+        } catch (XPathExpressionException ex) {\n+            throw new InternalErrorException(\"Error when evaluate xpath query on document.\", ex);\n+        }\n+\n+        //Test if there is any nodeset in result\n+        if (nodeList.getLength() == 0) {\n+            //There is no results, return empty subjects\n+            return subjects;\n+        }\n+\n+        //Iterate through nodes and convert them to Map<String,String>\n+        for (int i = 0; i < nodeList.getLength(); i++) {\n+            Node singleNode = nodeList.item(i);\n+            // remove node from original structure in order to keep access time constant (otherwise is exp.)\n+            singleNode.getParentNode().removeChild(singleNode);\n+            Map<String, String> map = convertNodeToMap(singleNode);\n+            if (map != null) {\n+                subjects.add(map);\n+            }\n+            //Reducing results by maxResults\n+            if (maxResults > 0) {\n+                if (subjects.size() >= maxResults) {\n+                    break;\n+                }\n+            }\n+        }\n+\n+        this.close();\n+        return subjects;\n+    }\n+\n+    /**\n+     * Get XML node and convert all values by \"xmlMapping\" attribute to Map<String,String>\n+     * In map there are \"name=value\" data.\n+     * <p>\n+     * Attribute xmlMapping is from file perun-extSource.xml\n+     *\n+     * @param node node for converting\n+     * @return Map<String, String> like <name,value>\n+     * @throws InternalErrorException\n+     */\n+    protected Map<String, String> convertNodeToMap(Node node) throws InternalErrorException {\n+        Map<String, String> nodeInMap = new HashMap<String, String>();\n+        //If node is empty, return null\n+        if (node == null) {\n+            return null;\n+        }\n+\n+        String mapping = getAttributes().get(\"xmlMapping\");\n+        String[] mappingArray = mapping.split(\",\\n\");\n+\n+        for (int i = 0; i < mappingArray.length; i++) {\n+            String attr = mappingArray[i].trim();\n+\n+            int index = attr.indexOf(\"=\");\n+\n+            if (index <= 0) {\n+                throw new InternalErrorException(\"There is no text in xmlMapping attribute or there is no '=' character.\");\n+            }\n+            String name = attr.substring(0, index);\n+            String value = attr.substring(index + 1);\n+\n+            if (value.startsWith(\"#\")) {\n+                value = value.substring(1);\n+                String[] regexAndXpath = value.split(\"#\");\n+                if (regexAndXpath.length != 2) {\n+                    throw new InternalErrorException(\"There is not only 2 parts (regex and XpathExpression). There are \" + regexAndXpath.length + \" parts.\");\n+                }\n+                value = extractValueByRegex(getValueFromXpath(node, regexAndXpath[1]), regexAndXpath[0]);\n+            } else {\n+                value = getValueFromXpath(node, value);\n+            }\n+            nodeInMap.put(name.trim(), value.trim());\n+        }\n+\n+        return nodeInMap;\n+    }\n+\n+    /**\n+     * Get xml Node and xpath expression to get value from node by this xpath.\n+     *\n+     * @param node            node for getting value from\n+     * @param xpathExpression expression for xpath to looking for value in node\n+     * @return string extracted from node by xpath\n+     * @throws InternalErrorException\n+     */\n+    protected String getValueFromXpath(Node node, String xpathExpression) throws InternalErrorException {\n+        //Prepare xpath expression\n+        XPathFactory xPathfactory = XPathFactory.newInstance();\n+        XPath xpath = xPathfactory.newXPath();\n+        XPathExpression expr;\n+        try {\n+            expr = xpath.compile(xpathExpression);\n+        } catch (XPathExpressionException ex) {\n+            throw new InternalErrorException(\"Error when compiling xpath query.\", ex);\n+        }\n+\n+        String text;\n+        try {\n+            text = (String) expr.evaluate(node, XPathConstants.STRING);\n+        } catch (XPathExpressionException ex) {\n+            throw new InternalErrorException(\"Error when evaluate xpath query on node.\", ex);\n+        }\n+\n+        return text;\n+    }\n+\n+    /**\n+     * Get regex in format 'regex/replacement' and value to get data from.\n+     * Use regex and replacement to get data from value.\n+     * <p>\n+     * IMPORTANT: Regex must be always in format 'regex/replacement' and must have\n+     * exactly 1 existence of character '/' ex. '[abc](a)[b]/$1'\n+     *\n+     * @param value some string\n+     * @param regex regex in format 'regex/replacement'\n+     * @return extracted string from value by regex\n+     * @throws InternalErrorException\n+     */\n+    protected String extractValueByRegex(String value, String regex) throws InternalErrorException {\n+        //trim value to erase newlines and spaces before and after value\n+        value = value.trim();\n+        //regex need to be separate to 2 parts (regex) and (replacement) separated by backslash - ex 'regex/replacement'\n+        Matcher match = pattern.matcher(regex);\n+\n+        //need to separate regex to regexPart and replacementPart\n+        String regexPart;\n+        String replacementPart;\n+        if (match.find()) {\n+            int i = match.end();\n+            if (match.find()) {\n+                throw new InternalErrorException(\"There is more then one separating forward slash in regex without escaping.\");\n+            }\n+            while (regex.charAt(i) != '/') {\n+                i--;\n+                if (i < 0) {\n+                    throw new InternalErrorException(\"Index of forward slash not found.\");\n+                }\n+            }\n+            regexPart = regex.substring(0, i);\n+            replacementPart = regex.substring(i + 1);\n+        } else {\n+            throw new InternalErrorException(\"There is no replacement in regex.\");\n+        }\n+\n+        //use regex and replacement to get string from value\n+        value = value.replaceAll(regexPart, replacementPart);\n+        return value;\n+    }\n+\n+    /**\n+     * Get https uri of xml document and create two way ssl connection using truststore and keystore.\n+     *\n+     * @param uri https uri to xml document\n+     * @return input stream with xml document\n+     * @throws IOException            if there is some input/output error\n+     * @throws InternalErrorException if some variables are not correctly filled\n+     */\n+    protected InputStream createTwoWaySSLConnection(String uri) throws IOException, InternalErrorException {\n+        if (uri == null || uri.isEmpty()) {\n+            throw new InternalErrorException(\"Uri must be filled, can't be null or empty.\");\n+        }\n \n \t\t/*//KeyStore data\n \t\tString keyStore =  getAttributes().get(\"keyStore\");\n@@ -394,114 +414,117 @@ public class ExtSourceXML extends ExtSource implements ExtSourceApi {\n \t\t// register a https protocol handler  - this may be required for previous JDK versions\n \t\tSystem.setProperty(\"java.protocol.handler.pkgs\",\"com.sun.net.ssl.internal.www.protocol\");*/\n \n-\t\t//prepare sslFactory\n-\t\tSSLSocketFactory factory = (SSLSocketFactory) SSLSocketFactory.getDefault();\n-\t\tHttpsURLConnection.setDefaultSSLSocketFactory(factory);\n-\n-\t\tURL myurl = new URL(uri);\n-\t\tcon = (HttpURLConnection) myurl.openConnection();\n-\n-\t\t//set request header if is required (set in extSource xml)\n-\t\tString reqHeaderKey = getAttributes().get(\"requestHeaderKey\");\n-\t\tString reqHeaderValue = getAttributes().get(\"requestHeaderValue\");\n-\t\tif(reqHeaderKey != null) {\n-\t\t\tif(reqHeaderValue == null) reqHeaderValue = \"\";\n-\t\t\tcon.setRequestProperty(reqHeaderKey, reqHeaderValue);\n-\t\t}\n-\n-\t\tint responseCode = con.getResponseCode();\n-\t\tif(responseCode == 200) {\n-\t\t\tInputStream is = con.getInputStream();\n-\t\t\treturn is;\n-\t\t}\n-\n-\t\tthrow new InternalErrorException(\"Wrong response code while opening connection on uri '\" + uri + \"'. Response code: \" + responseCode);\n-\t}\n-\n-\n-\t/**\n-\t * Take plaintext query and create xpath query with concat function if needed.\n-\t * IMPORTANT: especially if there are these characters: ' (single quote) and \" (double quotes)\n-\t *\n-\t * @param query string for xpath query in plain text format\n-\t *\n-\t * @return string for xpath, if there is needed, concat is used, if not, string without concet in quotes is returned, empty string if nothing in query\n-\t */\n-\tprotected String convertToXpathSearchString(String query) {\n-\t\t//if query is empty or null, return empty string\n-\t\tif(query == null || query.isEmpty()) {\n-\t\t\treturn new String();\n-\t\t}\n-\t\t//prepare array with parts of query for concating\n-\t\tList<String> parts = new ArrayList<String>();\n-\n-\t\t//prepare variables for behavior in for cycles through all characters in query\n-\t\tString part = \"\";\n-\t\t//if part contains double quote, doubleQuote = true, if single quote then doubleQuote = false\n-\t\tboolean doubleQuotes = false;\n-\n-\t\t//create parts where single quotes are in double quotes and vice versa\n-\t\tfor(char ch: query.toCharArray()) {\n-\t\t\tif(ch == '\\'') {\n-\t\t\t\tif(!doubleQuotes) {\n-\t\t\t\t\tpart+= ch;\n-\t\t\t\t} else {\n-\t\t\t\t\tparts.add(\"'\" + part + \"',\");\n-\t\t\t\t\tpart = \"\" + ch;\n-\t\t\t\t\tdoubleQuotes = false;\n-\t\t\t\t}\n-\t\t\t} else if (ch == '\"') {\n-\t\t\t\tif(doubleQuotes) {\n-\t\t\t\t\tpart+= ch;\n-\t\t\t\t} else {\n-\t\t\t\t\tparts.add(\"\\\"\" + part + \"\\\",\");\n-\t\t\t\t\tpart = \"\" + ch;\n-\t\t\t\t\tdoubleQuotes = true;\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\tpart+= ch;\n-\t\t\t}\n-\t\t}\n-\n-\t\t//add the last part to the array\n-\t\tif(doubleQuotes) {\n-\t\t\tparts.add(\"'\" + part + \"'\");\n-\t\t} else {\n-\t\t\tparts.add(\"\\\"\" + part + \"\\\"\");\n-\t\t}\n-\n-\t\t//prepare string with concat if needed\n-\t\tString result = \"concat(\";\n-\t\tif(parts.size() > 1 ) {\n-\t\t\tfor(String str: parts) {\n-\t\t\t\tresult+=str;\n-\t\t\t}\n-\t\t\tresult+= \")\";\n-\t\t} else {\n-\t\t\t//return only string if not need concat\n-\t\t\treturn parts.get(0);\n-\t\t}\n-\n-\t\t//return xpath query\n-\t\treturn result;\n-\t}\n-\n-\t@Override\n-\tpublic void close() throws InternalErrorException {\n-\t\tif(con != null) con.disconnect();\n-\t}\n-\n-\t@JsonIgnore\n-\tpublic HttpURLConnection getCon() {\n-\t\treturn con;\n-\t}\n-\n-\t@JsonIgnore\n-\tpublic void setCon(HttpURLConnection con) {\n-\t\tthis.con = con;\n-\t}\n-\n-\tprotected Map<String,String> getAttributes() throws InternalErrorException {\n-\t\treturn perunBl.getExtSourcesManagerBl().getAttributes(this);\n-\t}\n+        //prepare sslFactory\n+        SSLSocketFactory factory = (SSLSocketFactory) SSLSocketFactory.getDefault();\n+        HttpsURLConnection.setDefaultSSLSocketFactory(factory);\n+\n+        URL myurl = new URL(uri);\n+        con = (HttpURLConnection) myurl.openConnection();\n+\n+        //set request header if is required (set in extSource xml)\n+        String reqHeaderKey = getAttributes().get(\"requestHeaderKey\");\n+        String reqHeaderValue = getAttributes().get(\"requestHeaderValue\");\n+        if (reqHeaderKey != null) {\n+            if (reqHeaderValue == null) {\n+                reqHeaderValue = \"\";\n+            }\n+            con.setRequestProperty(reqHeaderKey, reqHeaderValue);\n+        }\n+\n+        int responseCode = con.getResponseCode();\n+        if (responseCode == 200) {\n+            InputStream is = con.getInputStream();\n+            return is;\n+        }\n+\n+        throw new InternalErrorException(\"Wrong response code while opening connection on uri '\" + uri + \"'. Response code: \" + responseCode);\n+    }\n+\n+\n+    /**\n+     * Take plaintext query and create xpath query with concat function if needed.\n+     * IMPORTANT: especially if there are these characters: ' (single quote) and \" (double quotes)\n+     *\n+     * @param query string for xpath query in plain text format\n+     * @return string for xpath, if there is needed, concat is used, if not, string without concet in quotes is returned, empty string if nothing in query\n+     */\n+    protected String convertToXpathSearchString(String query) {\n+        //if query is empty or null, return empty string\n+        if (query == null || query.isEmpty()) {\n+            return new String();\n+        }\n+        //prepare array with parts of query for concating\n+        List<String> parts = new ArrayList<String>();\n+\n+        //prepare variables for behavior in for cycles through all characters in query\n+        String part = \"\";\n+        //if part contains double quote, doubleQuote = true, if single quote then doubleQuote = false\n+        boolean doubleQuotes = false;\n+\n+        //create parts where single quotes are in double quotes and vice versa\n+        for (char ch : query.toCharArray()) {\n+            if (ch == '\\'') {\n+                if (!doubleQuotes) {\n+                    part += ch;\n+                } else {\n+                    parts.add(\"'\" + part + \"',\");\n+                    part = \"\" + ch;\n+                    doubleQuotes = false;\n+                }\n+            } else if (ch == '\"') {\n+                if (doubleQuotes) {\n+                    part += ch;\n+                } else {\n+                    parts.add(\"\\\"\" + part + \"\\\",\");\n+                    part = \"\" + ch;\n+                    doubleQuotes = true;\n+                }\n+            } else {\n+                part += ch;\n+            }\n+        }\n+\n+        //add the last part to the array\n+        if (doubleQuotes) {\n+            parts.add(\"'\" + part + \"'\");\n+        } else {\n+            parts.add(\"\\\"\" + part + \"\\\"\");\n+        }\n+\n+        //prepare string with concat if needed\n+        String result = \"concat(\";\n+        if (parts.size() > 1) {\n+            for (String str : parts) {\n+                result += str;\n+            }\n+            result += \")\";\n+        } else {\n+            //return only string if not need concat\n+            return parts.get(0);\n+        }\n+\n+        //return xpath query\n+        return result;\n+    }\n+\n+    @Override\n+    public void close() throws InternalErrorException {\n+        if (con != null) {\n+            con.disconnect();\n+        }\n+    }\n+\n+    @JsonIgnore\n+    public HttpURLConnection getCon() {\n+        return con;\n+    }\n+\n+    @JsonIgnore\n+    public void setCon(HttpURLConnection con) {\n+        this.con = con;\n+    }\n+\n+    protected Map<String, String> getAttributes() throws InternalErrorException {\n+        return perunBl.getExtSourcesManagerBl().getAttributes(this);\n+    }\n }\n",
            "diff_size": 508
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/236/ExtSourceXML.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/codebuff/236/ExtSourceXML.java\nindex 8a9719bb496..18bccf046fb 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/236/ExtSourceXML.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/codebuff/236/ExtSourceXML.java\n@@ -2,11 +2,9 @@ package cz.metacentrum.perun.core.impl;\n \n import java.util.ArrayList;\n import java.util.List;\n-\n import cz.metacentrum.perun.core.blImpl.PerunBlImpl;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-\n import java.net.HttpURLConnection;\n import cz.metacentrum.perun.core.api.ExtSource;\n import cz.metacentrum.perun.core.api.GroupsManager;\n@@ -42,466 +40,468 @@ import org.xml.sax.SAXParseException;\n /**\n  * @author Michal Stava stavamichal@gmail.com\n  */\n-public class ExtSourceXML extends ExtSource implements ExtSourceApi {\n \n-\tprivate final static Logger log = LoggerFactory.getLogger(ExtSourceXML.class);\n \n-\tprivate String query = null;\n-\tprivate String loginQuery = null;\n-\tprivate String file = null;\n-\tprivate String uri = null;\n+public class ExtSourceXML extends ExtSource implements ExtSourceApi {\n \n-\tprivate static PerunBlImpl perunBl;\n \n-\t// filled by spring (perun-core.xml)\n-\tpublic static PerunBlImpl setPerunBlImpl(PerunBlImpl perun) {\n-\t\tperunBl = perun;\n-\t\treturn perun;\n-\t}\n-\n-\t//URL connection\n-\tprivate HttpURLConnection con = null;\n-\n-\t//Pattern for looking replacement in regex string\n-\tprivate Pattern pattern = Pattern.compile(\"([^\\\\\\\\]|^)(\\\\\\\\\\\\\\\\)*\\\\/([^\\\\\\\\]|$)\");\n-\n-\t@Override\n-\tpublic List<Map<String,String>> findSubjectsLogins(String searchString) throws InternalErrorException, ExtSourceUnsupportedOperationException {\n-\t\treturn findSubjectsLogins(searchString, 0);\n-\t}\n-\n-\t@Override\n-\tpublic List<Map<String,String>> findSubjectsLogins(String searchString, int maxResulsts) throws InternalErrorException, ExtSourceUnsupportedOperationException {\n-\t\tthrow new ExtSourceUnsupportedOperationException(\"For XML is using this method not optimized, use findSubjects instead.\");\n-\t}\n-\n-\t@Override\n-\tpublic List<Map<String,String>> findSubjects(String searchString) throws InternalErrorException, ExtSourceUnsupportedOperationException {\n-\t\treturn findSubjects(searchString, 0);\n-\t}\n-\n-\t@Override\n-\tpublic List<Map<String,String>> findSubjects(String searchString, int maxResults) throws InternalErrorException, ExtSourceUnsupportedOperationException {\n-\t\t//prepare string for xpath (use concat for chars ' and  \")\n-\t\tsearchString = convertToXpathSearchString(searchString);\n-\n-\t\t//Get Query attribute from extSources.xml config file\n-\t\tquery = (String) getAttributes().get(\"xpath\");\n-\t\tif (query == null || query.isEmpty()) {\n-\t\t\tthrow new InternalErrorException(\"query attributes is required\");\n-\t\t}\n-\n-\t\t//Replace '?' by searchString\n-\t\tif(searchString == null) {\n-\t\t\tthrow new InternalErrorException(\"search string can't be null\");\n-\t\t}\n-\t\tquery = query.replaceAll(\"\\\\?\", searchString);\n-\n-\t\t//Get file or uri of xml\n-\t\tprepareEnvironment();\n-\n-\t\treturn xpathParsing(query, maxResults);\n-\t}\n-\n-\t@Override\n-\tpublic Map<String, String> getSubjectByLogin(String login) throws InternalErrorException, SubjectNotExistsException {\n-\t\t//prepare string for xpath (use concat for chars ' and  \")\n-\t\tlogin = convertToXpathSearchString(login);\n-\n-\t\t//Get Query attribute from extSources.xml config file\n-\t\tquery = (String) getAttributes().get(\"loginXpath\");\n-\t\tif (query == null || query.isEmpty()) {\n-\t\t\tthrow new InternalErrorException(\"query attributes is required\");\n-\t\t}\n-\n-\t\t//Replace '?' by searchString\n-\t\tif(login == null || login.isEmpty()) {\n-\t\t\tthrow new InternalErrorException(\"login string can't be null or empty\");\n-\t\t}\n-\t\tquery = query.replaceAll(\"\\\\?\", login);\n-\n-\t\t//Get file or uri of xml\n-\t\tprepareEnvironment();\n-\n-\t\tList<Map<String, String>> subjects = this.xpathParsing(query, 0);\n-\n-\t\tif (subjects.size() > 1) {\n-\t\t\tthrow new SubjectNotExistsException(\"There are more than one results for the login: \" + login);\n-\t\t}\n-\n-\t\tif (subjects.size() == 0) {\n-\t\t\tthrow new SubjectNotExistsException(login);\n-\t\t}\n-\n-\t\treturn subjects.get(0);\n-\t}\n-\n-\t@Override\n-\tpublic List<Map<String, String>> getGroupSubjects(Map<String, String> attributes) throws InternalErrorException, ExtSourceUnsupportedOperationException {\n-\t\t// Get the query for the group subjects\n-\t\tString queryForGroup = attributes.get(GroupsManager.GROUPMEMBERSQUERY_ATTRNAME);\n-\n-\t\t//If there is no query for group, throw exception\n-\t\tif(queryForGroup == null) throw new InternalErrorException(\"Attribute \" + GroupsManager.GROUPMEMBERSQUERY_ATTRNAME + \" can't be null.\");\n-\n-\t\t//Get file or uri of xml\n-\t\tprepareEnvironment();\n-\n-\t\treturn xpathParsing(queryForGroup, 0);\n-\t}\n-\n-\tprotected void prepareEnvironment() throws InternalErrorException {\n-\t\t//Get file or uri of xml\n-\t\tfile = (String) getAttributes().get(\"file\");\n-\t\tif(file == null || file.isEmpty()) {\n-\t\t\tfile = null;\n-\t\t\turi = (String) getAttributes().get(\"uri\");\n-\t\t\tif(uri == null || uri.isEmpty()) {\n-\t\t\t\tthrow new InternalErrorException(\"File and uri are both empty, one must exists!.\");\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Get query and maxResults.\n-\t * Prepare document and xpathExpression by query.\n-\t * Get all nodes by xpath from document and parse them one by one.\n-\t *\n-\t * The way of xml take from \"file\" or \"uri\" (configuration file)\n-\t *\n-\t * @param query xpath query from config file\n-\t * @param maxResults never get more than maxResults results (0 mean unlimited)\n-\t *\n-\t * @return List of results, where result is Map<String,String> like <name, value>\n-\t * @throws InternalErrorException\n-\t */\n-\tprotected List<Map<String,String>> xpathParsing(String query, int maxResults) throws InternalErrorException {\n-\t\t//Prepare result list\n-\t\tList<Map<String, String>> subjects = new ArrayList<Map<String, String>>();\n-\n-\t\t//Create new document factory builder\n-\t\tDocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n-\t\tDocumentBuilder builder;\n-\t\ttry {\n-\t\t\tbuilder = factory.newDocumentBuilder();\n-\t\t} catch (ParserConfigurationException ex) {\n-\t\t\tthrow new InternalErrorException(\"Error when creating newDocumentBuilder.\", ex);\n-\t\t}\n-\n-\t\tDocument doc;\n-\t\ttry {\n-\t\t\tif(file != null && !file.isEmpty()) {\n-\t\t\t\tdoc = builder.parse(file);\n-\t\t\t} else if(uri != null && !uri.isEmpty()) {\n-\t\t\t\tdoc = builder.parse(this.createTwoWaySSLConnection(uri));\n-\t\t\t} else {\n-\t\t\t\tthrow new InternalErrorException(\"Document can't be parsed, because there is no way (file or uri) to this document in xpathParser.\");\n-\t\t\t}\n-\t\t} catch (SAXParseException ex) {\n-\t\t\tthrow new InternalErrorException(\"Error when parsing uri by document builder.\", ex);\n-\t\t} catch (SAXException ex) {\n-\t\t\tthrow new InternalErrorException(\"Problem with parsing is more complex, not only invalid characters.\", ex);\n-\t\t} catch (IOException ex) {\n-\t\t\tthrow new InternalErrorException(\"Error when parsing uri by document builder. Problem with input or output.\", ex);\n-\t\t}\n-\n-\t\t//Prepare xpath expression\n-\t\tXPathFactory xPathfactory = XPathFactory.newInstance();\n-\t\tXPath xpath = xPathfactory.newXPath();\n-\t\tXPathExpression queryExpr;\n-\t\ttry {\n-\t\t\tqueryExpr = xpath.compile(query);\n-\t\t} catch (XPathExpressionException ex) {\n-\t\t\tthrow new InternalErrorException(\"Error when compiling xpath query.\", ex);\n-\t\t}\n-\n-\t\t//Call query on document node and get back nodesets\n-\t\tNodeList nodeList;\n-\t\ttry {\n-\t\t\tnodeList = (NodeList) queryExpr.evaluate(doc, XPathConstants.NODESET);\n-\t\t} catch (XPathExpressionException ex) {\n-\t\t\tthrow new InternalErrorException(\"Error when evaluate xpath query on document.\", ex);\n-\t\t}\n-\n-\t\t//Test if there is any nodeset in result\n-\t\tif(nodeList.getLength() == 0) {\n-\t\t\t//There is no results, return empty subjects\n-\t\t\treturn subjects;\n-\t\t}\n-\n-\t\t//Iterate through nodes and convert them to Map<String,String>\n-\t\tfor(int i=0; i<nodeList.getLength(); i++) {\n-\t\t\tNode singleNode = nodeList.item(i);\n-\t\t\t// remove node from original structure in order to keep access time constant (otherwise is exp.)\n-\t\t\tsingleNode.getParentNode().removeChild(singleNode);\n-\t\t\tMap<String,String> map = convertNodeToMap(singleNode);\n-\t\t\tif(map != null) subjects.add(map);\n-\t\t\t//Reducing results by maxResults\n-\t\t\tif(maxResults > 0) {\n-\t\t\t\tif(subjects.size() >= maxResults) break;\n-\t\t\t}\n-\t\t}\n-\n-\t\tthis.close();\n-\t\treturn subjects;\n-\t}\n-\n-\t/**\n-\t * Get XML node and convert all values by \"xmlMapping\" attribute to Map<String,String>\n-\t * In map there are \"name=value\" data.\n-\t *\n-\t * Attribute xmlMapping is from file perun-extSource.xml\n-\t *\n-\t * @param node node for converting\n-\t * @return Map<String,String> like <name,value>\n-\t * @throws InternalErrorException\n-\t */\n-\tprotected Map<String, String> convertNodeToMap(Node node) throws InternalErrorException {\n-\t\tMap<String,String> nodeInMap = new HashMap<String,String>();\n-\t\t//If node is empty, return null\n-\t\tif(node == null) return null;\n-\n-\t\tString mapping = getAttributes().get(\"xmlMapping\");\n-\t\tString[] mappingArray = mapping.split(\",\\n\");\n-\n-\t\tfor(int i=0; i<mappingArray.length; i++) {\n-\t\t\tString attr = mappingArray[i].trim();\n-\n-\t\t\tint index = attr.indexOf(\"=\");\n-\n-\t\t\tif(index <= 0) throw new InternalErrorException(\"There is no text in xmlMapping attribute or there is no '=' character.\");\n-\t\t\tString name = attr.substring(0, index);\n-\t\t\tString value = attr.substring(index +1);\n-\n-\t\t\tif(value.startsWith(\"#\")) {\n-\t\t\t\tvalue = value.substring(1);\n-\t\t\t\tString[] regexAndXpath = value.split(\"#\");\n-\t\t\t\tif(regexAndXpath.length != 2) throw new InternalErrorException(\"There is not only 2 parts (regex and XpathExpression). There are \" + regexAndXpath.length + \" parts.\");\n-\t\t\t\tvalue = extractValueByRegex(getValueFromXpath(node, regexAndXpath[1]), regexAndXpath[0]);\n-\t\t\t} else {\n-\t\t\t\tvalue = getValueFromXpath(node, value);\n-\t\t\t}\n-\t\t\tnodeInMap.put(name.trim(), value.trim());\n-\t\t}\n-\n-\t\treturn nodeInMap;\n-\t}\n-\n-\t/**\n-\t * Get xml Node and xpath expression to get value from node by this xpath.\n-\t *\n-\t * @param node node for getting value from\n-\t * @param xpathExpression expression for xpath to looking for value in node\n-\t * @return string extracted from node by xpath\n-\t * @throws InternalErrorException\n-\t */\n-\tprotected String getValueFromXpath(Node node, String xpathExpression) throws InternalErrorException {\n-\t\t//Prepare xpath expression\n-\t\tXPathFactory xPathfactory = XPathFactory.newInstance();\n-\t\tXPath xpath = xPathfactory.newXPath();\n-\t\tXPathExpression expr;\n-\t\ttry {\n-\t\t\texpr = xpath.compile(xpathExpression);\n-\t\t} catch (XPathExpressionException ex) {\n-\t\t\tthrow new InternalErrorException(\"Error when compiling xpath query.\", ex);\n-\t\t}\n-\n-\t\tString text;\n-\t\ttry {\n-\t\t\t text = (String) expr.evaluate(node, XPathConstants.STRING);\n-\t\t} catch (XPathExpressionException ex) {\n-\t\t\tthrow new InternalErrorException(\"Error when evaluate xpath query on node.\", ex);\n-\t\t}\n-\n-\t\treturn text;\n-\t}\n-\n-\t/**\n-\t * Get regex in format 'regex/replacement' and value to get data from.\n-\t * Use regex and replacement to get data from value.\n-\t *\n-\t * IMPORTANT: Regex must be always in format 'regex/replacement' and must have\n-\t *\t\t\t\t\t\texactly 1 existence of character '/' ex. '[abc](a)[b]/$1'\n-\t *\n-\t * @param value some string\n-\t * @param regex regex in format 'regex/replacement'\n-\t * @return extracted string from value by regex\n-\t *\n-\t * @throws InternalErrorException\n-\t */\n-\tprotected String extractValueByRegex(String value, String regex) throws InternalErrorException {\n-\t\t//trim value to erase newlines and spaces before and after value\n-\t\tvalue = value.trim();\n-\t\t//regex need to be separate to 2 parts (regex) and (replacement) separated by backslash - ex 'regex/replacement'\n-\t\tMatcher match = pattern.matcher(regex);\n-\n-\t\t//need to separate regex to regexPart and replacementPart\n-\t\tString regexPart;\n-\t\tString replacementPart;\n-\t\tif(match.find()) {\n-\t\t\tint i = match.end();\n-\t\t\tif(match.find()) throw new InternalErrorException(\"There is more then one separating forward slash in regex without escaping.\");\n-\t\t\twhile(regex.charAt(i) != '/') {\n-\t\t\t\ti--;\n-\t\t\t\tif(i < 0) throw new InternalErrorException(\"Index of forward slash not found.\");\n-\t\t\t}\n-\t\t\tregexPart = regex.substring(0, i);\n-\t\t\treplacementPart = regex.substring(i+1);\n-\t\t} else {\n-\t\t\tthrow new InternalErrorException(\"There is no replacement in regex.\");\n-\t\t}\n-\n-\t\t//use regex and replacement to get string from value\n-\t\tvalue = value.replaceAll(regexPart, replacementPart);\n-\t\treturn value;\n-\t}\n-\n-\t/**\n-\t * Get https uri of xml document and create two way ssl connection using truststore and keystore.\n-\t *\n-\t * @param uri https uri to xml document\n-\t * @return input stream with xml document\n-\t *\n-\t * @throws IOException if there is some input/output error\n-\t * @throws InternalErrorException if some variables are not correctly filled\n-\t */\n-\tprotected InputStream createTwoWaySSLConnection(String uri) throws IOException, InternalErrorException {\n-\t\tif(uri == null || uri.isEmpty()) throw new InternalErrorException(\"Uri must be filled, can't be null or empty.\");\n-\n-\t\t/*//KeyStore data\n-\t\tString keyStore =  getAttributes().get(\"keyStore\");\n-\t\tString keyStorePass = getAttributes().get(\"keyStorePass\");\n-\t\tString keyStoreType = getAttributes().get(\"keyStoreType\");\n-\t\tif(keyStore == null || keyStorePass == null || keyStoreType == null) {\n-\t\t\tthrow new InternalErrorException(\"KeystorePath, KeystorePass and KeystoreType must be filled. Please look into configuration file.\");\n-\t\t}\n-\n-\t\t//TrustStore data\n-\t\tString trustStore = getAttributes().get(\"trustStore\");\n-\t\tString trustStorePass = getAttributes().get(\"trustStorePass\");\n-\t\tif(trustStore == null || trustStorePass == null) {\n-\t\t\tthrow new InternalErrorException(\"TrustStorePath and TrustStorePass must be filled. Please look into configuration file.\");\n-\t\t}\n-\n-\t\t//set necessary keystore properties - using a p12 file\n-\t\tSystem.setProperty(\"javax.net.ssl.keyStore\", keyStore);\n-\t\tSystem.setProperty(\"javax.net.ssl.keyStorePassword\", keyStorePass);\n-\t\tSystem.setProperty(\"javax.net.ssl.keyStoreType\", keyStoreType);\n-\n-\t\t//set necessary truststore properties - using JKS\n-\t\tSystem.setProperty(\"javax.net.ssl.trustStore\", trustStore);\n-\t\tSystem.setProperty(\"javax.net.ssl.trustStorePassword\", trustStorePass);\n-\t\t// register a https protocol handler  - this may be required for previous JDK versions\n-\t\tSystem.setProperty(\"java.protocol.handler.pkgs\",\"com.sun.net.ssl.internal.www.protocol\");*/\n-\n-\t\t//prepare sslFactory\n-\t\tSSLSocketFactory factory = (SSLSocketFactory) SSLSocketFactory.getDefault();\n-\t\tHttpsURLConnection.setDefaultSSLSocketFactory(factory);\n-\n-\t\tURL myurl = new URL(uri);\n-\t\tcon = (HttpURLConnection) myurl.openConnection();\n-\n-\t\t//set request header if is required (set in extSource xml)\n-\t\tString reqHeaderKey = getAttributes().get(\"requestHeaderKey\");\n-\t\tString reqHeaderValue = getAttributes().get(\"requestHeaderValue\");\n-\t\tif(reqHeaderKey != null) {\n-\t\t\tif(reqHeaderValue == null) reqHeaderValue = \"\";\n-\t\t\tcon.setRequestProperty(reqHeaderKey, reqHeaderValue);\n-\t\t}\n-\n-\t\tint responseCode = con.getResponseCode();\n-\t\tif(responseCode == 200) {\n-\t\t\tInputStream is = con.getInputStream();\n-\t\t\treturn is;\n-\t\t}\n-\n-\t\tthrow new InternalErrorException(\"Wrong response code while opening connection on uri '\" + uri + \"'. Response code: \" + responseCode);\n-\t}\n-\n-\n-\t/**\n-\t * Take plaintext query and create xpath query with concat function if needed.\n-\t * IMPORTANT: especially if there are these characters: ' (single quote) and \" (double quotes)\n-\t *\n-\t * @param query string for xpath query in plain text format\n-\t *\n-\t * @return string for xpath, if there is needed, concat is used, if not, string without concet in quotes is returned, empty string if nothing in query\n-\t */\n-\tprotected String convertToXpathSearchString(String query) {\n-\t\t//if query is empty or null, return empty string\n-\t\tif(query == null || query.isEmpty()) {\n-\t\t\treturn new String();\n-\t\t}\n-\t\t//prepare array with parts of query for concating\n-\t\tList<String> parts = new ArrayList<String>();\n-\n-\t\t//prepare variables for behavior in for cycles through all characters in query\n-\t\tString part = \"\";\n-\t\t//if part contains double quote, doubleQuote = true, if single quote then doubleQuote = false\n-\t\tboolean doubleQuotes = false;\n-\n-\t\t//create parts where single quotes are in double quotes and vice versa\n-\t\tfor(char ch: query.toCharArray()) {\n-\t\t\tif(ch == '\\'') {\n-\t\t\t\tif(!doubleQuotes) {\n-\t\t\t\t\tpart+= ch;\n-\t\t\t\t} else {\n-\t\t\t\t\tparts.add(\"'\" + part + \"',\");\n-\t\t\t\t\tpart = \"\" + ch;\n-\t\t\t\t\tdoubleQuotes = false;\n-\t\t\t\t}\n-\t\t\t} else if (ch == '\"') {\n-\t\t\t\tif(doubleQuotes) {\n-\t\t\t\t\tpart+= ch;\n-\t\t\t\t} else {\n-\t\t\t\t\tparts.add(\"\\\"\" + part + \"\\\",\");\n-\t\t\t\t\tpart = \"\" + ch;\n-\t\t\t\t\tdoubleQuotes = true;\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\tpart+= ch;\n-\t\t\t}\n-\t\t}\n-\n-\t\t//add the last part to the array\n-\t\tif(doubleQuotes) {\n-\t\t\tparts.add(\"'\" + part + \"'\");\n-\t\t} else {\n-\t\t\tparts.add(\"\\\"\" + part + \"\\\"\");\n-\t\t}\n-\n-\t\t//prepare string with concat if needed\n-\t\tString result = \"concat(\";\n-\t\tif(parts.size() > 1 ) {\n-\t\t\tfor(String str: parts) {\n-\t\t\t\tresult+=str;\n-\t\t\t}\n-\t\t\tresult+= \")\";\n-\t\t} else {\n-\t\t\t//return only string if not need concat\n-\t\t\treturn parts.get(0);\n-\t\t}\n-\n-\t\t//return xpath query\n-\t\treturn result;\n-\t}\n-\n-\t@Override\n-\tpublic void close() throws InternalErrorException {\n-\t\tif(con != null) con.disconnect();\n-\t}\n-\n-\t@JsonIgnore\n-\tpublic HttpURLConnection getCon() {\n-\t\treturn con;\n-\t}\n-\n-\t@JsonIgnore\n-\tpublic void setCon(HttpURLConnection con) {\n-\t\tthis.con = con;\n-\t}\n-\n-\tprotected Map<String,String> getAttributes() throws InternalErrorException {\n-\t\treturn perunBl.getExtSourcesManagerBl().getAttributes(this);\n-\t}\n-}\n+ private final static Logger log = LoggerFactory.getLogger(ExtSourceXML.class);\n+ private String query = null;\n+ private String loginQuery = null;\n+ private String file = null;\n+ private String uri = null;\n+ private static PerunBlImpl perunBl;\n+\n+ // filled by spring (perun-core.xml)\n+\n+ public static PerunBlImpl setPerunBlImpl(PerunBlImpl perun) {\n+  perunBl = perun;\n+  return perun;\n+ }\n+\n+ //URL connection\n+\n+\n+ private HttpURLConnection con = null;\n+\n+ //Pattern for looking replacement in regex string\n+ private Pattern pattern = Pattern.compile(\"([^\\\\\\\\]|^)(\\\\\\\\\\\\\\\\)*\\\\/([^\\\\\\\\]|$)\");\n+\n+ @Override\n+ public List<Map<String, String>> findSubjectsLogins(String searchString) throws InternalErrorException, ExtSourceUnsupportedOperationException {\n+  return findSubjectsLogins(searchString, 0);\n+ }\n+\n+ @Override\n+ public List<Map<String, String>> findSubjectsLogins(String searchString, int maxResulsts) throws InternalErrorException, ExtSourceUnsupportedOperationException {\n+  throw new ExtSourceUnsupportedOperationException(\"For XML is using this method not optimized, use findSubjects instead.\");\n+ }\n+\n+ @Override\n+ public List<Map<String, String>> findSubjects(String searchString) throws InternalErrorException, ExtSourceUnsupportedOperationException {\n+  return findSubjects(searchString, 0);\n+ }\n+\n+ @Override\n+ public List<Map<String, String>> findSubjects(String searchString, int maxResults) throws InternalErrorException, ExtSourceUnsupportedOperationException {\n+  //prepare string for xpath (use concat for chars ' and  \")\n+  searchString = convertToXpathSearchString(searchString);\n+\n+  //Get Query attribute from extSources.xml config file\n+  query = (String) getAttributes().get(\"xpath\");\n+  if (query == null || query.isEmpty()) {\n+   throw new InternalErrorException(\"query attributes is required\");\n+  }\n+\n+  //Replace '?' by searchString\n+  if (searchString == null) {\n+   throw new InternalErrorException(\"search string can't be null\");\n+  }\n+  query = query.replaceAll(\"\\\\?\", searchString);\n+\n+  //Get file or uri of xml\n+  prepareEnvironment();\n+  return xpathParsing(query, maxResults);\n+ }\n+\n+ @Override\n+ public Map<String, String> getSubjectByLogin(String login) throws InternalErrorException, SubjectNotExistsException {\n+  //prepare string for xpath (use concat for chars ' and  \")\n+  login = convertToXpathSearchString(login);\n+\n+  //Get Query attribute from extSources.xml config file\n+  query = (String) getAttributes().get(\"loginXpath\");\n+  if (query == null || query.isEmpty()) {\n+   throw new InternalErrorException(\"query attributes is required\");\n+  }\n+\n+  //Replace '?' by searchString\n+  if (login == null || login.isEmpty()) {\n+   throw new InternalErrorException(\"login string can't be null or empty\");\n+  }\n+  query = query.replaceAll(\"\\\\?\", login);\n+\n+  //Get file or uri of xml\n+  prepareEnvironment();\n+  List<Map<String, String>> subjects = this.xpathParsing(query, 0);\n+  if (subjects.size() > 1) {\n+   throw new SubjectNotExistsException(\"There are more than one results for the login: \" + login);\n+  }\n+  if (subjects.size() == 0) {\n+   throw new SubjectNotExistsException(login);\n+  }\n+\n+  return subjects.get(0);\n+ }\n+\n+ @Override\n+ public List<Map<String, String>> getGroupSubjects(Map<String, String> attributes) throws InternalErrorException, ExtSourceUnsupportedOperationException {\n+  // Get the query for the group subjects\n+  String queryForGroup = attributes.get(GroupsManager.GROUPMEMBERSQUERY_ATTRNAME);\n+\n+  //If there is no query for group, throw exception\n+  if (queryForGroup == null) throw new InternalErrorException(\"Attribute \" + GroupsManager.GROUPMEMBERSQUERY_ATTRNAME + \" can't be null.\");\n+\n+  //Get file or uri of xml\n+  prepareEnvironment();\n+  return xpathParsing(queryForGroup, 0);\n+ }\n+\n+ protected void prepareEnvironment() throws InternalErrorException {\n+  //Get file or uri of xml\n+  file = (String) getAttributes().get(\"file\");\n+  if (file == null || file.isEmpty()) {\n+   file = null;\n+   uri = (String) getAttributes().get(\"uri\");\n+   if (uri == null || uri.isEmpty()) {\n+    throw new InternalErrorException(\"File and uri are both empty, one must exists!.\");\n+   }\n+  }\n+ }\n+\n+ /**\n+  * Get query and maxResults.\n+  * Prepare document and xpathExpression by query.\n+  * Get all nodes by xpath from document and parse them one by one.\n+  *\n+  * The way of xml take from \"file\" or \"uri\" (configuration file)\n+  *\n+  * @param query xpath query from config file\n+  * @param maxResults never get more than maxResults results (0 mean unlimited)\n+  *\n+  * @return List of results, where result is Map<String,String> like <name, value>\n+  * @throws InternalErrorException\n+  */\n+\n+ protected List<Map<String, String>> xpathParsing(String query, int maxResults) throws InternalErrorException {\n+  //Prepare result list\n+  List<Map<String, String>> subjects = new ArrayList<Map<String, String>>();\n+\n+  //Create new document factory builder\n+  DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n+  DocumentBuilder builder;\n+  try {\n+   builder = factory.newDocumentBuilder();\n+  } catch (ParserConfigurationException ex) {\n+   throw new InternalErrorException(\"Error when creating newDocumentBuilder.\", ex);\n+  }\n+  Document doc;\n+  try {\n+   if (file != null && !file.isEmpty()) {\n+    doc = builder.parse(file);\n+   } else if (uri != null && !uri.isEmpty()) {\n+    doc = builder.parse(this.createTwoWaySSLConnection(uri));\n+   } else {\n+    throw new InternalErrorException(\"Document can't be parsed, because there is no way (file or uri) to this document in xpathParser.\");\n+   }\n+  } catch (SAXParseException ex) {\n+   throw new InternalErrorException(\"Error when parsing uri by document builder.\", ex);\n+  } catch (SAXException ex) {\n+   throw new InternalErrorException(\"Problem with parsing is more complex, not only invalid characters.\", ex);\n+  } catch (IOException ex) {\n+   throw new InternalErrorException(\"Error when parsing uri by document builder. Problem with input or output.\", ex);\n+  }\n+\n+  //Prepare xpath expression\n+  XPathFactory xPathfactory = XPathFactory.newInstance();\n+  XPath xpath = xPathfactory.newXPath();\n+  XPathExpression queryExpr;\n+  try {\n+   queryExpr = xpath.compile(query);\n+  } catch (XPathExpressionException ex) {\n+   throw new InternalErrorException(\"Error when compiling xpath query.\", ex);\n+  }\n+\n+  //Call query on document node and get back nodesets\n+  NodeList nodeList;\n+  try {\n+   nodeList = (NodeList) queryExpr.evaluate(doc, XPathConstants.NODESET);\n+  } catch (XPathExpressionException ex) {\n+   throw new InternalErrorException(\"Error when evaluate xpath query on document.\", ex);\n+  }\n+\n+  //Test if there is any nodeset in result\n+  if (nodeList.getLength() == 0) {\n+   //There is no results, return empty subjects\n+   return subjects;\n+  }\n+\n+  //Iterate through nodes and convert them to Map<String,String>\n+\n+  for (int i = 0; i<nodeList.getLength(); i++) {\n+   Node singleNode = nodeList.item(i);\n+   // remove node from original structure in order to keep access time constant (otherwise is exp.)\n+   singleNode.getParentNode().removeChild(singleNode);\n+   Map<String, String> map = convertNodeToMap(singleNode);\n+   if (map != null) subjects.add(map);\n+   //Reducing results by maxResults\n+   if (maxResults > 0) {\n+    if (subjects.size() >= maxResults) break;\n+   }\n+  }\n+\n+  this.close();\n+  return subjects;\n+ }\n+\n+ /**\n+  * Get XML node and convert all values by \"xmlMapping\" attribute to Map<String,String>\n+  * In map there are \"name=value\" data.\n+  *\n+  * Attribute xmlMapping is from file perun-extSource.xml\n+  *\n+  * @param node node for converting\n+  * @return Map<String,String> like <name,value>\n+  * @throws InternalErrorException\n+  */\n+\n+ protected Map<String, String> convertNodeToMap(Node node) throws InternalErrorException {\n+  Map<String, String> nodeInMap = new HashMap<String, String>();\n+  //If node is empty, return null\n+  if (node == null)\n+   return null;\n+  String mapping = getAttributes().get(\"xmlMapping\");\n+  String[] mappingArray = mapping.split(\",\\n\");\n+  for (int i = 0; i<mappingArray.length; i++) {\n+   String attr = mappingArray[i].trim();\n+   int index = attr.indexOf(\"=\");\n+   if (index <= 0) throw new InternalErrorException(\"There is no text in xmlMapping attribute or there is no '=' character.\");\n+   String name = attr.substring(0, index);\n+   String value = attr.substring(index + 1);\n+   if (value.startsWith(\"#\")) {\n+    value = value.substring(1);\n+    String[] regexAndXpath = value.split(\"#\");\n+    if (regexAndXpath.length != 2) throw new InternalErrorException(\"There is not only 2 parts (regex and XpathExpression). There are \" + regexAndXpath.length + \" parts.\");\n+    value = extractValueByRegex(getValueFromXpath(node, regexAndXpath[1]), regexAndXpath[0]);\n+   } else {\n+    value = getValueFromXpath(node, value);\n+   }\n+   nodeInMap.put(name.trim(), value.trim());\n+  }\n+\n+  return nodeInMap;\n+ }\n+\n+ /**\n+  * Get xml Node and xpath expression to get value from node by this xpath.\n+  *\n+  * @param node node for getting value from\n+  * @param xpathExpression expression for xpath to looking for value in node\n+  * @return string extracted from node by xpath\n+  * @throws InternalErrorException\n+  */\n+\n+ protected String getValueFromXpath(Node node, String xpathExpression) throws InternalErrorException {\n+  //Prepare xpath expression\n+  XPathFactory xPathfactory = XPathFactory.newInstance();\n+  XPath xpath = xPathfactory.newXPath();\n+  XPathExpression expr;\n+  try {\n+   expr = xpath.compile(xpathExpression);\n+  } catch (XPathExpressionException ex) {\n+   throw new InternalErrorException(\"Error when compiling xpath query.\", ex);\n+  }\n+  String text;\n+  try {\n+   text = (String) expr.evaluate(node, XPathConstants.STRING);\n+  } catch (XPathExpressionException ex) {\n+   throw new InternalErrorException(\"Error when evaluate xpath query on node.\", ex);\n+  }\n+\n+  return text;\n+ }\n+\n+ /**\n+  * Get regex in format 'regex/replacement' and value to get data from.\n+  * Use regex and replacement to get data from value.\n+  *\n+  * IMPORTANT: Regex must be always in format 'regex/replacement' and must have\n+  *      exactly 1 existence of character '/' ex. '[abc](a)[b]/$1'\n+  *\n+  * @param value some string\n+  * @param regex regex in format 'regex/replacement'\n+  * @return extracted string from value by regex\n+  *\n+  * @throws InternalErrorException\n+  */\n+\n+ protected String extractValueByRegex(String value, String regex) throws InternalErrorException {\n+  //trim value to erase newlines and spaces before and after value\n+  value = value.trim();\n+  //regex need to be separate to 2 parts (regex) and (replacement) separated by backslash - ex 'regex/replacement'\n+  Matcher match = pattern.matcher(regex);\n+\n+  //need to separate regex to regexPart and replacementPart\n+  String regexPart;\n+  String replacementPart;\n+  if (match.find()) {\n+   int i = match.end();\n+   if (match.find()) throw new InternalErrorException(\"There is more then one separating forward slash in regex without escaping.\");\n+   while (regex.charAt(i) != '/') {\n+    i--;\n+    if (i< 0) throw new InternalErrorException(\"Index of forward slash not found.\");\n+   }\n+   regexPart = regex.substring(0, i);\n+   replacementPart = regex.substring(i + 1);\n+  } else {\n+   throw new InternalErrorException(\"There is no replacement in regex.\");\n+  }\n+\n+  //use regex and replacement to get string from value\n+  value = value.replaceAll(regexPart, replacementPart);\n+  return value;\n+ }\n+\n+ /**\n+  * Get https uri of xml document and create two way ssl connection using truststore and keystore.\n+  *\n+  * @param uri https uri to xml document\n+  * @return input stream with xml document\n+  *\n+  * @throws IOException if there is some input/output error\n+  * @throws InternalErrorException if some variables are not correctly filled\n+  */\n+\n+ protected InputStream createTwoWaySSLConnection(String uri) throws IOException, InternalErrorException {\n+  if (uri == null || uri.isEmpty()) throw new InternalErrorException(\"Uri must be filled, can't be null or empty.\");\n+\n+  /*//KeyStore data\n+  String keyStore =  getAttributes().get(\"keyStore\");\n+  String keyStorePass = getAttributes().get(\"keyStorePass\");\n+  String keyStoreType = getAttributes().get(\"keyStoreType\");\n+  if(keyStore == null || keyStorePass == null || keyStoreType == null) {\n+   throw new InternalErrorException(\"KeystorePath, KeystorePass and KeystoreType must be filled. Please look into configuration file.\");\n+  }\n+\n+  //TrustStore data\n+  String trustStore = getAttributes().get(\"trustStore\");\n+  String trustStorePass = getAttributes().get(\"trustStorePass\");\n+  if(trustStore == null || trustStorePass == null) {\n+   throw new InternalErrorException(\"TrustStorePath and TrustStorePass must be filled. Please look into configuration file.\");\n+  }\n+\n+  //set necessary keystore properties - using a p12 file\n+  System.setProperty(\"javax.net.ssl.keyStore\", keyStore);\n+  System.setProperty(\"javax.net.ssl.keyStorePassword\", keyStorePass);\n+  System.setProperty(\"javax.net.ssl.keyStoreType\", keyStoreType);\n+\n+  //set necessary truststore properties - using JKS\n+  System.setProperty(\"javax.net.ssl.trustStore\", trustStore);\n+  System.setProperty(\"javax.net.ssl.trustStorePassword\", trustStorePass);\n+  // register a https protocol handler  - this may be required for previous JDK versions\n+  System.setProperty(\"java.protocol.handler.pkgs\",\"com.sun.net.ssl.internal.www.protocol\");*/\n+\n+  //prepare sslFactory\n+  SSLSocketFactory factory = (SSLSocketFactory) SSLSocketFactory.getDefault();\n+  HttpsURLConnection.setDefaultSSLSocketFactory(factory);\n+  URL myurl = new URL(uri);\n+  con = (HttpURLConnection) myurl.openConnection();\n+\n+  //set request header if is required (set in extSource xml)\n+  String reqHeaderKey = getAttributes().get(\"requestHeaderKey\");\n+  String reqHeaderValue = getAttributes().get(\"requestHeaderValue\");\n+  if (reqHeaderKey != null) {\n+   if (reqHeaderValue == null) reqHeaderValue = \"\";\n+   con.setRequestProperty(reqHeaderKey, reqHeaderValue);\n+  }\n+\n+  int responseCode = con.getResponseCode();\n+  if (responseCode == 200) {\n+   InputStream is = con.getInputStream();\n+   return is;\n+  }\n+\n+  throw new InternalErrorException(\"Wrong response code while opening connection on uri '\" + uri + \"'. Response code: \" + responseCode);\n+ }\n+\n+\n+ /**\n+  * Take plaintext query and create xpath query with concat function if needed.\n+  * IMPORTANT: especially if there are these characters: ' (single quote) and \" (double quotes)\n+  *\n+  * @param query string for xpath query in plain text format\n+  *\n+  * @return string for xpath, if there is needed, concat is used, if not, string without concet in quotes is returned, empty string if nothing in query\n+  */\n+\n+ protected String convertToXpathSearchString(String query) {\n+  //if query is empty or null, return empty string\n+  if (query == null || query.isEmpty()) {\n+   return new String();\n+  }\n+  //prepare array with parts of query for concating\n+  List<String> parts = new ArrayList<String>();\n+\n+  //prepare variables for behavior in for cycles through all characters in query\n+  String part = \"\";\n+  //if part contains double quote, doubleQuote = true, if single quote then doubleQuote = false\n+  boolean doubleQuotes = false;\n+\n+  //create parts where single quotes are in double quotes and vice versa\n+  for (char ch : query.toCharArray()) {\n+   if (ch == '\\'') {\n+    if (!doubleQuotes) {\n+     part += ch;\n+    } else {\n+     parts.add(\"'\" + part + \"',\");\n+     part = \"\" + ch;\n+     doubleQuotes = false;\n+    }\n+   } else if (ch == '\"') {\n+    if (doubleQuotes) {\n+     part += ch;\n+    } else {\n+     parts.add(\"\\\"\" + part + \"\\\",\");\n+     part = \"\" + ch;\n+     doubleQuotes = true;\n+    }\n+   } else {\n+    part += ch;\n+   }\n+  }\n+\n+  //add the last part to the array\n+  if (doubleQuotes) {\n+   parts.add(\"'\" + part + \"'\");\n+  } else {\n+   parts.add(\"\\\"\" + part + \"\\\"\");\n+  }\n+\n+  //prepare string with concat if needed\n+  String result = \"concat(\";\n+  if (parts.size() > 1) {\n+\n+   for (String str : parts) {\n+    result += str;\n+   }\n+   result += \")\";\n+  } else {\n+   //return only string if not need concat\n+   return parts.get(0);\n+  }\n+\n+  //return xpath query\n+\n+  return result;\n+ }\n+\n+ @Override\n+ public void close() throws InternalErrorException {\n+  if (con != null) con.disconnect();\n+ }\n+\n+ @JsonIgnore\n+ public HttpURLConnection getCon() {\n+  return con;\n+ }\n+\n+ @JsonIgnore\n+ public void setCon(HttpURLConnection con) {\n+  this.con = con;\n+ }\n+\n+ protected Map<String, String> getAttributes() throws InternalErrorException {\n+  return perunBl.getExtSourcesManagerBl().getAttributes(this);\n+ }\n+\n+}\n\\ No newline at end of file\n",
            "diff_size": 469
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/236/ExtSourceXML.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/styler_random/236/ExtSourceXML.java\nindex 8a9719bb496..e0f6b219ef6 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/236/ExtSourceXML.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/styler_random/236/ExtSourceXML.java\n@@ -308,7 +308,7 @@ public class ExtSourceXML extends ExtSource implements ExtSourceApi {\n \n \t\tString text;\n \t\ttry {\n-\t\t\t text = (String) expr.evaluate(node, XPathConstants.STRING);\n+\t\t\ttext = (String) expr.evaluate(node, XPathConstants.STRING);\n \t\t} catch (XPathExpressionException ex) {\n \t\t\tthrow new InternalErrorException(\"Error when evaluate xpath query on node.\", ex);\n \t\t}\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/236/ExtSourceXML.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/styler_three_grams/236/ExtSourceXML.java\nindex 8a9719bb496..e0f6b219ef6 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/236/ExtSourceXML.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/styler_three_grams/236/ExtSourceXML.java\n@@ -308,7 +308,7 @@ public class ExtSourceXML extends ExtSource implements ExtSourceApi {\n \n \t\tString text;\n \t\ttry {\n-\t\t\t text = (String) expr.evaluate(node, XPathConstants.STRING);\n+\t\t\ttext = (String) expr.evaluate(node, XPathConstants.STRING);\n \t\t} catch (XPathExpressionException ex) {\n \t\t\tthrow new InternalErrorException(\"Error when evaluate xpath query on node.\", ex);\n \t\t}\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "naturalize"
    ]
}