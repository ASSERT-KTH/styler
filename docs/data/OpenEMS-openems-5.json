{
    "project_name": "OpenEMS-openems",
    "error_id": "5",
    "information": {
        "errors": [
            {
                "line": "177",
                "column": "25",
                "severity": "warning",
                "message": "WhitespaceAround: 'if' is not followed by whitespace. Empty blocks may only be represented as {} when not part of a multi-block statement (4.1.3)",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
            }
        ]
    },
    "source_code": "\t\t */\n\t\tpublic final OpenemsType getMatchingOpenemsType(boolean hasScaleFactor) {\n\t\t\tif(hasScaleFactor) {\n\t\t\t\treturn OpenemsType.FLOAT;\n\t\t\t}\n\t\t\t",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "177",
                    "column": "25",
                    "severity": "warning",
                    "message": "WhitespaceAround: 'if' is not followed by whitespace. Empty blocks may only be represented as {} when not part of a multi-block statement (4.1.3)",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/OpenEMS-openems/errored/1/5/SunSpecPoint.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/OpenEMS-openems/intellij/5/SunSpecPoint.java\nindex 0260cb9d2b8..0e759140610 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/OpenEMS-openems/errored/1/5/SunSpecPoint.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/OpenEMS-openems/intellij/5/SunSpecPoint.java\n@@ -25,275 +25,275 @@ import io.openems.edge.common.channel.EnumDoc;\n  */\n public interface SunSpecPoint {\n \n-\t/**\n-\t * Gets the Point-ID.\n-\t * \n-\t * <p>\n-\t * This method refers to {@link Enum#name()}.\n-\t * \n-\t * @return the ID.\n-\t */\n-\tpublic String name();\n+  /**\n+   * Gets the Point-ID.\n+   *\n+   * <p>\n+   * This method refers to {@link Enum#name()}.\n+   *\n+   * @return the ID.\n+   */\n+  public String name();\n \n-\t/**\n-\t * The internal PointImpl object for easier handling in Enums.\n-\t * \n-\t * @return the internal PointImpl\n-\t */\n-\tpublic PointImpl get();\n+  /**\n+   * The internal PointImpl object for easier handling in Enums.\n+   *\n+   * @return the internal PointImpl\n+   */\n+  public PointImpl get();\n \n-\t/**\n-\t * Returns true if the value represents a 'defined' value in SunSpec.\n-\t * \n-\t * @param value the value\n-\t * @return true for defined values\n-\t */\n-\tpublic default boolean isDefined(Object value) {\n-\t\treturn PointType.isDefined(this.get().type, value);\n-\t}\n+  /**\n+   * Returns true if the value represents a 'defined' value in SunSpec.\n+   *\n+   * @param value the value\n+   * @return true for defined values\n+   */\n+  public default boolean isDefined(Object value) {\n+    return PointType.isDefined(this.get().type, value);\n+  }\n \n-\t/**\n-\t * Gets the {@link ChannelId} for this Point.\n-\t * \n-\t * @return the ChannelId.\n-\t */\n-\tpublic default SunSChannelId<?> getChannelId() {\n-\t\treturn this.get().channelId;\n-\t}\n+  /**\n+   * Gets the {@link ChannelId} for this Point.\n+   *\n+   * @return the ChannelId.\n+   */\n+  public default SunSChannelId<?> getChannelId() {\n+    return this.get().channelId;\n+  }\n \n-\t/**\n-\t * The internal PointImpl object for easier handling in Enums.\n-\t */\n-\tpublic static class PointImpl {\n-\t\tpublic final String label;\n-\t\tpublic final String description;\n-\t\tpublic final String notes;\n-\t\tpublic final PointType type;\n-\t\tpublic final boolean mandatory;\n-\t\tpublic final AccessMode accessMode;\n-\t\tpublic final Unit unit;\n-\t\tpublic final SunSChannelId<?> channelId;\n-\t\tpublic final Optional<String> scaleFactor;\n-\t\tpublic final OptionsEnum[] options;\n+  /**\n+   * The internal PointImpl object for easier handling in Enums.\n+   */\n+  public static class PointImpl {\n+    public final String label;\n+    public final String description;\n+    public final String notes;\n+    public final PointType type;\n+    public final boolean mandatory;\n+    public final AccessMode accessMode;\n+    public final Unit unit;\n+    public final SunSChannelId<?> channelId;\n+    public final Optional<String> scaleFactor;\n+    public final OptionsEnum[] options;\n \n-\t\tpublic PointImpl(String channelId, String label, String description, String notes, PointType type,\n-\t\t\t\tboolean mandatory, AccessMode accessMode, Unit unit, String scaleFactor, OptionsEnum[] options) {\n-\t\t\tthis.label = label;\n-\t\t\tthis.description = description;\n-\t\t\tthis.notes = notes;\n-\t\t\tthis.type = type;\n-\t\t\tthis.mandatory = mandatory;\n-\t\t\tthis.accessMode = accessMode;\n-\t\t\tthis.unit = unit;\n-\t\t\tthis.scaleFactor = Optional.ofNullable(scaleFactor);\n-\t\t\tif (options.length == 0) {\n-\t\t\t\tthis.channelId = new SunSChannelId<>(channelId, //\n-\t\t\t\t\t\tDoc.of(this.getMatchingOpenemsType(this.scaleFactor.isPresent())) //\n-\t\t\t\t\t\t\t\t.unit(unit) //\n-\t\t\t\t\t\t\t\t.accessMode(accessMode));\n-\t\t\t} else {\n-\t\t\t\tthis.channelId = new SunSChannelId<Integer>(channelId, //\n-\t\t\t\t\t\tnew EnumDoc(options) //\n-\t\t\t\t\t\t\t\t.accessMode(accessMode));\n-\t\t\t}\n-\t\t\tthis.options = options;\n-\t\t}\n+    public PointImpl(String channelId, String label, String description, String notes, PointType type,\n+                     boolean mandatory, AccessMode accessMode, Unit unit, String scaleFactor, OptionsEnum[] options) {\n+      this.label = label;\n+      this.description = description;\n+      this.notes = notes;\n+      this.type = type;\n+      this.mandatory = mandatory;\n+      this.accessMode = accessMode;\n+      this.unit = unit;\n+      this.scaleFactor = Optional.ofNullable(scaleFactor);\n+      if (options.length == 0) {\n+        this.channelId = new SunSChannelId<>(channelId, //\n+            Doc.of(this.getMatchingOpenemsType(this.scaleFactor.isPresent())) //\n+                .unit(unit) //\n+                .accessMode(accessMode));\n+      } else {\n+        this.channelId = new SunSChannelId<Integer>(channelId, //\n+            new EnumDoc(options) //\n+                .accessMode(accessMode));\n+      }\n+      this.options = options;\n+    }\n \n-\t\t/**\n-\t\t * Generates a Modbus Element for the given point + startAddress.\n-\t\t * \n-\t\t * @param startAddress the startAddress of the Point\n-\t\t * @return a new Modbus Element\n-\t\t */\n-\t\tpublic final AbstractModbusElement<?> generateModbusElement(Integer startAddress) {\n-\t\t\tswitch (this.type) {\n-\t\t\tcase UINT16:\n-\t\t\tcase ACC16:\n-\t\t\tcase ENUM16:\n-\t\t\tcase BITFIELD16:\n-\t\t\t\treturn new UnsignedWordElement(startAddress);\n-\t\t\tcase INT16:\n-\t\t\tcase SUNSSF:\n-\t\t\tcase COUNT:\n-\t\t\t\treturn new SignedWordElement(startAddress);\n-\t\t\tcase UINT32:\n-\t\t\tcase ACC32:\n-\t\t\tcase ENUM32:\n-\t\t\tcase BITFIELD32:\n-\t\t\tcase IPADDR:\n-\t\t\t\treturn new UnsignedDoublewordElement(startAddress);\n-\t\t\tcase INT32:\n-\t\t\t\treturn new SignedDoublewordElement(startAddress);\n-\t\t\tcase UINT64:\n-\t\t\tcase ACC64:\n-\t\t\t\treturn new UnsignedQuadruplewordElement(startAddress);\n-\t\t\tcase INT64:\n-\t\t\t\treturn new SignedQuadruplewordElement(startAddress);\n-\t\t\tcase FLOAT32:\n-\t\t\t\treturn new FloatDoublewordElement(startAddress);\n-\t\t\tcase PAD:\n-\t\t\t\treturn new DummyRegisterElement(startAddress);\n-\t\t\tcase FLOAT64:\n-\t\t\t\tbreak;\n-\t\t\tcase EUI48:\n-\t\t\t\tbreak;\n-\t\t\tcase IPV6ADDR:\n-\t\t\t\t// TODO this would be UINT128\n-\t\t\t\tbreak;\n-\t\t\tcase STRING2:\n-\t\t\t\treturn new StringWordElement(startAddress, 2);\n-\t\t\tcase STRING4:\n-\t\t\t\treturn new StringWordElement(startAddress, 4);\n-\t\t\tcase STRING5:\n-\t\t\t\treturn new StringWordElement(startAddress, 5);\n-\t\t\tcase STRING6:\n-\t\t\t\treturn new StringWordElement(startAddress, 6);\n-\t\t\tcase STRING7:\n-\t\t\t\treturn new StringWordElement(startAddress, 7);\n-\t\t\tcase STRING8:\n-\t\t\t\treturn new StringWordElement(startAddress, 8);\n-\t\t\tcase STRING12:\n-\t\t\t\treturn new StringWordElement(startAddress, 12);\n-\t\t\tcase STRING16:\n-\t\t\t\treturn new StringWordElement(startAddress, 16);\n-\t\t\tcase STRING20:\n-\t\t\t\treturn new StringWordElement(startAddress, 20);\n-\t\t\tcase STRING25:\n-\t\t\t\treturn new StringWordElement(startAddress, 25);\n-\t\t\t}\n-\t\t\tthrow new IllegalArgumentException(\n-\t\t\t\t\t\"Point [\" + this.label + \"]: Type [\" + this.type + \"] is not supported!\");\n-\t\t}\n+    /**\n+     * Generates a Modbus Element for the given point + startAddress.\n+     *\n+     * @param startAddress the startAddress of the Point\n+     * @return a new Modbus Element\n+     */\n+    public final AbstractModbusElement<?> generateModbusElement(Integer startAddress) {\n+      switch (this.type) {\n+        case UINT16:\n+        case ACC16:\n+        case ENUM16:\n+        case BITFIELD16:\n+          return new UnsignedWordElement(startAddress);\n+        case INT16:\n+        case SUNSSF:\n+        case COUNT:\n+          return new SignedWordElement(startAddress);\n+        case UINT32:\n+        case ACC32:\n+        case ENUM32:\n+        case BITFIELD32:\n+        case IPADDR:\n+          return new UnsignedDoublewordElement(startAddress);\n+        case INT32:\n+          return new SignedDoublewordElement(startAddress);\n+        case UINT64:\n+        case ACC64:\n+          return new UnsignedQuadruplewordElement(startAddress);\n+        case INT64:\n+          return new SignedQuadruplewordElement(startAddress);\n+        case FLOAT32:\n+          return new FloatDoublewordElement(startAddress);\n+        case PAD:\n+          return new DummyRegisterElement(startAddress);\n+        case FLOAT64:\n+          break;\n+        case EUI48:\n+          break;\n+        case IPV6ADDR:\n+          // TODO this would be UINT128\n+          break;\n+        case STRING2:\n+          return new StringWordElement(startAddress, 2);\n+        case STRING4:\n+          return new StringWordElement(startAddress, 4);\n+        case STRING5:\n+          return new StringWordElement(startAddress, 5);\n+        case STRING6:\n+          return new StringWordElement(startAddress, 6);\n+        case STRING7:\n+          return new StringWordElement(startAddress, 7);\n+        case STRING8:\n+          return new StringWordElement(startAddress, 8);\n+        case STRING12:\n+          return new StringWordElement(startAddress, 12);\n+        case STRING16:\n+          return new StringWordElement(startAddress, 16);\n+        case STRING20:\n+          return new StringWordElement(startAddress, 20);\n+        case STRING25:\n+          return new StringWordElement(startAddress, 25);\n+      }\n+      throw new IllegalArgumentException(\n+          \"Point [\" + this.label + \"]: Type [\" + this.type + \"] is not supported!\");\n+    }\n \n-\t\t/**\n-\t\t * Gets the {@link OpenemsType} that matches this SunSpec-Type.\n-\t\t * \n-\t\t * @param hasScaleFactor true if this Point has a ScaleFactor. If true, a\n-\t\t *                       floating point type is applied to avoid rounding\n-\t\t *                       errors.\n-\t\t * @return the {@link OpenemsType}\n-\t\t */\n-\t\tpublic final OpenemsType getMatchingOpenemsType(boolean hasScaleFactor) {\n-\t\t\tif(hasScaleFactor) {\n-\t\t\t\treturn OpenemsType.FLOAT;\n-\t\t\t}\n-\t\t\t\n-\t\t\t// TODO: map to floating point OpenemsType when appropriate\n-\t\t\tswitch (this.type) {\n-\t\t\tcase UINT16:\n-\t\t\tcase ACC16:\n-\t\t\tcase ENUM16:\n-\t\t\tcase BITFIELD16:\n-\t\t\tcase INT16:\n-\t\t\tcase SUNSSF:\n-\t\t\tcase COUNT:\n-\t\t\tcase UINT32:\n-\t\t\tcase ACC32:\n-\t\t\tcase ENUM32:\n-\t\t\tcase BITFIELD32:\n-\t\t\tcase IPADDR:\n-\t\t\tcase INT32:\n-\t\t\tcase PAD: // ignore\n-\t\t\tcase EUI48:\n-\t\t\tcase FLOAT32: // avoid floating point numbers; FLOAT32 might not fit in INTEGER\n-\t\t\t\treturn OpenemsType.INTEGER;\n-\t\t\tcase UINT64:\n-\t\t\tcase ACC64:\n-\t\t\tcase INT64:\n-\t\t\tcase IPV6ADDR:\n-\t\t\tcase FLOAT64: // avoid floating point numbers\n-\t\t\t\treturn OpenemsType.LONG;\n-\t\t\tcase STRING2:\n-\t\t\tcase STRING4:\n-\t\t\tcase STRING5:\n-\t\t\tcase STRING6:\n-\t\t\tcase STRING7:\n-\t\t\tcase STRING8:\n-\t\t\tcase STRING12:\n-\t\t\tcase STRING16:\n-\t\t\tcase STRING20:\n-\t\t\tcase STRING25:\n-\t\t\t\treturn OpenemsType.STRING;\n-\t\t\t}\n-\t\t\tthrow new IllegalArgumentException(\"Unable to get matching OpenemsType for \" + this.type);\n-\t\t}\n-\t}\n+    /**\n+     * Gets the {@link OpenemsType} that matches this SunSpec-Type.\n+     *\n+     * @param hasScaleFactor true if this Point has a ScaleFactor. If true, a\n+     *                       floating point type is applied to avoid rounding\n+     *                       errors.\n+     * @return the {@link OpenemsType}\n+     */\n+    public final OpenemsType getMatchingOpenemsType(boolean hasScaleFactor) {\n+      if (hasScaleFactor) {\n+        return OpenemsType.FLOAT;\n+      }\n \n-\tpublic static enum PointType {\n-\t\tINT16(1), UINT16(1), COUNT(1), ACC16(1), INT32(2), UINT32(2), FLOAT32(2), ACC32(2), INT64(4), UINT64(4),\n-\t\tFLOAT64(4), ACC64(4), ENUM16(1), ENUM32(2), BITFIELD16(1), BITFIELD32(2), SUNSSF(1), STRING2(2), STRING4(4),\n-\t\tSTRING5(5), STRING6(6), STRING7(7), STRING8(8), STRING12(12), STRING16(16), STRING20(20), STRING25(25),\n-\t\t/* use PAD for reserved points */\n-\t\tPAD(1), IPADDR(1), IPV6ADDR(16), EUI48(6);\n+      // TODO: map to floating point OpenemsType when appropriate\n+      switch (this.type) {\n+        case UINT16:\n+        case ACC16:\n+        case ENUM16:\n+        case BITFIELD16:\n+        case INT16:\n+        case SUNSSF:\n+        case COUNT:\n+        case UINT32:\n+        case ACC32:\n+        case ENUM32:\n+        case BITFIELD32:\n+        case IPADDR:\n+        case INT32:\n+        case PAD: // ignore\n+        case EUI48:\n+        case FLOAT32: // avoid floating point numbers; FLOAT32 might not fit in INTEGER\n+          return OpenemsType.INTEGER;\n+        case UINT64:\n+        case ACC64:\n+        case INT64:\n+        case IPV6ADDR:\n+        case FLOAT64: // avoid floating point numbers\n+          return OpenemsType.LONG;\n+        case STRING2:\n+        case STRING4:\n+        case STRING5:\n+        case STRING6:\n+        case STRING7:\n+        case STRING8:\n+        case STRING12:\n+        case STRING16:\n+        case STRING20:\n+        case STRING25:\n+          return OpenemsType.STRING;\n+      }\n+      throw new IllegalArgumentException(\"Unable to get matching OpenemsType for \" + this.type);\n+    }\n+  }\n \n-\t\tpublic final int length;\n+  public static enum PointType {\n+    INT16(1), UINT16(1), COUNT(1), ACC16(1), INT32(2), UINT32(2), FLOAT32(2), ACC32(2), INT64(4), UINT64(4),\n+    FLOAT64(4), ACC64(4), ENUM16(1), ENUM32(2), BITFIELD16(1), BITFIELD32(2), SUNSSF(1), STRING2(2), STRING4(4),\n+    STRING5(5), STRING6(6), STRING7(7), STRING8(8), STRING12(12), STRING16(16), STRING20(20), STRING25(25),\n+    /* use PAD for reserved points */\n+    PAD(1), IPADDR(1), IPV6ADDR(16), EUI48(6);\n \n-\t\tprivate PointType(int length) {\n-\t\t\tthis.length = length;\n-\t\t}\n+    public final int length;\n \n-\t\t/**\n-\t\t * Returns true if the value represents a 'defined' value in SunSpec.\n-\t\t * \n-\t\t * @param type  the PointType\n-\t\t * @param value the value\n-\t\t * @return true for defined values\n-\t\t */\n-\t\tpublic static boolean isDefined(PointType type, Object value) {\n-\t\t\tif (value == null) {\n-\t\t\t\treturn false;\n-\t\t\t}\n-\t\t\tswitch (type) {\n-\t\t\tcase INT16:\n-\t\t\tcase SUNSSF:\n-\t\t\t\treturn !value.equals(Short.MIN_VALUE /* -32768 */);\n-\t\t\tcase UINT16:\n-\t\t\tcase ENUM16:\n-\t\t\tcase BITFIELD16:\n-\t\t\tcase COUNT:\n-\t\t\t\treturn !value.equals(65535);\n-\t\t\tcase ACC16:\n-\t\t\tcase ACC32:\n-\t\t\tcase IPADDR:\n-\t\t\tcase ACC64:\n-\t\t\tcase IPV6ADDR:\n-\t\t\t\treturn !value.equals(0);\n-\t\t\tcase INT32:\n-\t\t\t\treturn !value.equals(0x80000000); // TODO correct?\n-\t\t\tcase UINT32:\n-\t\t\tcase ENUM32:\n-\t\t\tcase BITFIELD32:\n-\t\t\t\treturn !value.equals(4294967295L);\n-\t\t\tcase INT64:\n-\t\t\t\treturn !value.equals(0x8000000000000000L); // TODO correct?\n-\t\t\tcase UINT64:\n-\t\t\t\treturn !value.equals(0xFFFFFFFFFFFFFFFFL); // TODO correct?\n-\t\t\tcase FLOAT32:\n-\t\t\t\treturn !value.equals(Float.NaN);\n-\t\t\tcase FLOAT64:\n-\t\t\t\treturn false; // TODO not implemented\n-\t\t\tcase PAD:\n-\t\t\t\t// This point is never needed/reserved\n-\t\t\t\treturn false;\n-\t\t\tcase STRING12:\n-\t\t\tcase STRING16:\n-\t\t\tcase STRING2:\n-\t\t\tcase STRING20:\n-\t\t\tcase STRING25:\n-\t\t\tcase STRING4:\n-\t\t\tcase STRING5:\n-\t\t\tcase STRING6:\n-\t\t\tcase STRING7:\n-\t\t\tcase STRING8:\n-\t\t\t\treturn !\"\".equals(value);\n-\t\t\tcase EUI48:\n-\t\t\t\treturn false; // TODO not implemented\n-\t\t\t}\n-\t\t\treturn false;\n-\t\t}\n-\t}\n+    private PointType(int length) {\n+      this.length = length;\n+    }\n \n-\tpublic static enum PointCategory {\n-\t\tNONE, MEASUREMENT, METERED, STATUS, EVENT, SETTING, CONTROL;\n-\t}\n+    /**\n+     * Returns true if the value represents a 'defined' value in SunSpec.\n+     *\n+     * @param type  the PointType\n+     * @param value the value\n+     * @return true for defined values\n+     */\n+    public static boolean isDefined(PointType type, Object value) {\n+      if (value == null) {\n+        return false;\n+      }\n+      switch (type) {\n+        case INT16:\n+        case SUNSSF:\n+          return !value.equals(Short.MIN_VALUE /* -32768 */);\n+        case UINT16:\n+        case ENUM16:\n+        case BITFIELD16:\n+        case COUNT:\n+          return !value.equals(65535);\n+        case ACC16:\n+        case ACC32:\n+        case IPADDR:\n+        case ACC64:\n+        case IPV6ADDR:\n+          return !value.equals(0);\n+        case INT32:\n+          return !value.equals(0x80000000); // TODO correct?\n+        case UINT32:\n+        case ENUM32:\n+        case BITFIELD32:\n+          return !value.equals(4294967295L);\n+        case INT64:\n+          return !value.equals(0x8000000000000000L); // TODO correct?\n+        case UINT64:\n+          return !value.equals(0xFFFFFFFFFFFFFFFFL); // TODO correct?\n+        case FLOAT32:\n+          return !value.equals(Float.NaN);\n+        case FLOAT64:\n+          return false; // TODO not implemented\n+        case PAD:\n+          // This point is never needed/reserved\n+          return false;\n+        case STRING12:\n+        case STRING16:\n+        case STRING2:\n+        case STRING20:\n+        case STRING25:\n+        case STRING4:\n+        case STRING5:\n+        case STRING6:\n+        case STRING7:\n+        case STRING8:\n+          return !\"\".equals(value);\n+        case EUI48:\n+          return false; // TODO not implemented\n+      }\n+      return false;\n+    }\n+  }\n+\n+  public static enum PointCategory {\n+    NONE, MEASUREMENT, METERED, STATUS, EVENT, SETTING, CONTROL;\n+  }\n }\n\\ No newline at end of file\n",
            "diff_size": 359
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "177",
                    "column": "25",
                    "severity": "warning",
                    "message": "WhitespaceAround: 'if' is not followed by whitespace. Empty blocks may only be represented as {} when not part of a multi-block statement (4.1.3)",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "177",
                    "column": "25",
                    "severity": "warning",
                    "message": "WhitespaceAround: 'if' is not followed by whitespace. Empty blocks may only be represented as {} when not part of a multi-block statement (4.1.3)",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ],
    "repaired_by": [
        "intellij"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}