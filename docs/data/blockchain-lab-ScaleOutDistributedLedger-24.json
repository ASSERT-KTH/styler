{
    "project_name": "blockchain-lab-ScaleOutDistributedLedger",
    "error_id": "24",
    "information": {
        "errors": [
            {
                "line": "119",
                "column": "19",
                "severity": "warning",
                "message": "'catch' is not followed by whitespace.",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
            }
        ]
    },
    "source_code": "\t\t\t\ttry {\n\t\t\t\t\tlastBlockMessage = blockMessageList.get(blockMessageList.size() - 1);\n\t\t\t\t} catch(NullPointerException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t\tSystem.exit(1);\n\t\t\t\t}",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "119",
                    "column": "19",
                    "severity": "warning",
                    "message": "'catch' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/blockchain-lab-ScaleOutDistributedLedger/errored/1/24/Transaction.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/blockchain-lab-ScaleOutDistributedLedger/intellij/24/Transaction.java\nindex 3f93443e2bc..6860a420c38 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/blockchain-lab-ScaleOutDistributedLedger/errored/1/24/Transaction.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/blockchain-lab-ScaleOutDistributedLedger/intellij/24/Transaction.java\n@@ -24,244 +24,275 @@ import nl.tudelft.blockchain.scaleoutdistributedledger.message.BlockMessage;\n  */\n public class Transaction {\n \n-\t// Represent the sender of a genesis transaction\n-\tpublic static final int GENESIS_SENDER = -1;\n-\t\n-\t@Getter\n-\tprivate final int number;\n+    // Represent the sender of a genesis transaction\n+    public static final int GENESIS_SENDER = -1;\n \n-\t@Getter\n-\tprivate final Node sender;\n+    @Getter\n+    private final int number;\n \n-\t// TODO: change back to final somehow\n-\t@Getter @Setter\n-\tprivate Node receiver;\n+    @Getter\n+    private final Node sender;\n \n-\t@Getter\n-\tprivate final long amount, remainder;\n+    // TODO: change back to final somehow\n+    @Getter\n+    @Setter\n+    private Node receiver;\n \n-\t@Getter\n-\tprivate final Set<Transaction> source;\n+    @Getter\n+    private final long amount, remainder;\n \n-\t// Custem getter\n-\tprivate Sha256Hash hash;\n-\t\n-\tprivate OptionalInt blockNumber;\n+    @Getter\n+    private final Set<Transaction> source;\n \n-\t/**\n-\t * Constructor.\n-\t * @param number - the number of this transaction.\n-\t * @param sender - the sender of this transaction.\n-\t * @param receiver - the receiver of this transaction.\n-\t * @param amount - the amount to be transferred.\n-\t * @param remainder - the remaining amount.\n-\t * @param source - set of transactions that are used as source for this transaction.\n-\t */\n-\tpublic Transaction(int number, Node sender, Node receiver, long amount, long remainder, Set<Transaction> source) {\n-\t\tthis.sender = sender;\n-\t\tthis.receiver = receiver;\n-\t\tthis.amount = amount;\n-\t\tthis.remainder = remainder;\n-\t\tthis.source = source;\n-\t\tthis.number = number;\n-\t\tthis.blockNumber = OptionalInt.empty();\n-\t}\n+    // Custem getter\n+    private Sha256Hash hash;\n \n-\t/**\n-\t * Constructor to decode a transaction message.\n-\t * @param transactionMessage - the message received from a transaction.\n-\t * @param encodedChainUpdates - the received chain of updates\n-\t * @param decodedChainUpdates - current chain of updates, from the decoding process\n-\t * @param localStore - local store, to get each Node object\n-\t * @throws java.io.IOException - error while getting node\n-\t */\n-\tpublic Transaction(TransactionMessage transactionMessage, Map<Integer, List<BlockMessage>> encodedChainUpdates,\n-\t\t\tMap<Node, List<Block>> decodedChainUpdates, LocalStore localStore) throws IOException  {\n-\t\tthis.number = transactionMessage.getNumber();\n-\t\tthis.blockNumber = OptionalInt.of(transactionMessage.getBlockNumber());\n-\t\t\n-\t\t// It's a genesis transaction\n-\t\tif (transactionMessage.getSenderId() == GENESIS_SENDER) {\n-\t\t\tthis.sender = null;\n-\t\t} else {\n-\t\t\tthis.sender = localStore.getNode(transactionMessage.getSenderId());\n-\t\t}\n-\t\tthis.receiver = localStore.getNode(transactionMessage.getReceiverId());\n-\t\tthis.amount = transactionMessage.getAmount();\n-\t\tthis.remainder = transactionMessage.getRemainder();\n-\t\t// Decode transaction messages to normal transactions\n-\t\tthis.source = new HashSet<>();\n-\t\t// Use local store for known sources\n-\t\tfor (Entry<Integer, Integer> knownSourceEntry : transactionMessage.getKnownSource()) {\n-\t\t\tInteger nodeId = knownSourceEntry.getKey();\n-\t\t\tInteger transactionId = knownSourceEntry.getValue();\n-\t\t\t//TODO This might need to be done in a certain order\n-\t\t\tthis.source.add(localStore.getTransactionFromNode(nodeId, transactionId));\n-\t\t}\n-\t\t// Use chain of updates for new sources\n-\t\tfor (Entry<Integer, Integer> newSourceEntry : transactionMessage.getNewSource()) {\n-\t\t\ttry {\n-\t\t\t\t// Try to find the transaction in the local store\n-\t\t\t\tthis.source.add(localStore.getTransactionFromNode(newSourceEntry.getKey(), newSourceEntry.getValue()));\n-\t\t\t\tcontinue;\n-\t\t\t} catch (IllegalStateException ex) {\n-\t\t\t\t// Not in localStore\n-\t\t\t}\n-\t\t\t// Use the transaction from the current chain of updates\n-\t\t\tNode owner = localStore.getNode(newSourceEntry.getKey());\n-\t\t\tif (!decodedChainUpdates.containsKey(owner)) {\n-\t\t\t\t// Get that new chain\n-\t\t\t\tList<BlockMessage> blockMessageList = encodedChainUpdates.get(owner.getId());\n-\t\t\t\t// Decode chain, in REVERSE order\n-\t\t\t\tBlockMessage lastBlockMessage = null;\n-\t\t\t\ttry {\n-\t\t\t\t\tlastBlockMessage = blockMessageList.get(blockMessageList.size() - 1);\n-\t\t\t\t} catch(NullPointerException e) {\n-\t\t\t\t\te.printStackTrace();\n-\t\t\t\t\tSystem.exit(1);\n-\t\t\t\t}\n-\t\t\t\t// Recursively decode the blocks of a chain (in reverse order)\n-\t\t\t\tBlock lastBlockLocal = new Block(lastBlockMessage, encodedChainUpdates, decodedChainUpdates, localStore);\n-\t\t\t\tif (decodedChainUpdates.containsKey(owner)) {\n-\t\t\t\t\t// Add to already created list\n-\t\t\t\t\tdecodedChainUpdates.get(owner).add(lastBlockLocal);\n-\t\t\t\t} else {\n-\t\t\t\t\t// Create a new list\n-\t\t\t\t\tList<Block> blockList = new ArrayList<>();\n-\t\t\t\t\tblockList.add(lastBlockLocal);\n-\t\t\t\t\tdecodedChainUpdates.put(owner, blockList);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\t// TODO [Performance]: Find a way to directly go to the correct block instead of iterating through all of them\n-\t\t\tfor (Block blockAux : decodedChainUpdates.get(owner)) {\n-\t\t\t\tfor (Transaction transactionAux : blockAux.getTransactions()) {\n-\t\t\t\t\tif (transactionAux.getNumber() == newSourceEntry.getValue()) {\n-\t\t\t\t\t\tthis.source.add(transactionAux);\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\tthis.hash = transactionMessage.getHash();\n-\t}\n-\t\n-\t/**\n-\t * Returns the number of the block (if it is in a block).\n-\t * TODO: maybe do this more efficiently (when adding the transaction to the local chain or something)\n-\t * @return - optional that is empty if the transaction is not in a block, and filled with the number of the block otherwise.\n-\t */\n-\tpublic OptionalInt getBlockNumber() {\n-\t\tif (!this.blockNumber.isPresent()) {\n-\t\t\t// It's a genesis transaction\n-\t\t\tif (this.sender == null) {\n-\t\t\t\tthis.blockNumber = OptionalInt.of(Block.GENESIS_BLOCK_NUMBER);\n-\t\t\t} else {\n-\t\t\t\tfor (Block block : sender.getChain().getBlocks()) {\n-\t\t\t\t\tif (block.getTransactions().contains(this)) {\n-\t\t\t\t\t\tthis.blockNumber = OptionalInt.of(block.getNumber());\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn this.blockNumber;\n-\t}\n-\t\n-\t/**\n-\t * Sets the block number of this transaction.\n-\t * @param number - the block number\n-\t */\n-\tpublic void setBlockNumber(int number) {\n-\t\tthis.blockNumber = OptionalInt.of(number);\n-\t}\n+    private OptionalInt blockNumber;\n \n-\t/**\n-\t * Get hash of the transaction.\n-\t * @return Hash SHA256\n-\t */\n-\tpublic Sha256Hash getHash() {\n-\t\tif (this.hash == null) {\n-\t\t\tthis.hash = this.calculateHash();\n-\t\t}\n-\t\treturn this.hash;\n-\t}\n-\t\n-\t/**\n-\t * Calculate the transaction hash.\n-\t * @return Hash SHA256\n-\t */\n-\tprivate Sha256Hash calculateHash() {\n-\t\t// Convert attributes of transaction into an array of bytes\n-\t\tByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n-\t\ttry {\n-\t\t\t// Important to keep the order of writings\n-\t\t\toutputStream.write(Utils.intToByteArray(this.number));\n-\t\t\tif (this.sender != null) {\n-\t\t\t\toutputStream.write(Utils.intToByteArray(this.sender.getId()));\n-\t\t\t}\n-\t\t\toutputStream.write(Utils.intToByteArray(this.receiver.getId()));\n-\t\t\toutputStream.write(Utils.longToByteArray(this.amount));\n-\t\t\toutputStream.write(Utils.longToByteArray(this.remainder));\n-\t\t\t\n-\t\t\t// TODO: check if we really need to do this\n-\t\t\tfor (Transaction tx : this.source) {\n-\t\t\t\toutputStream.write(tx.getHash().getBytes());\n-\t\t\t}\n-\t\t} catch (IOException ex) {\n-\t\t\tLog.log(Level.SEVERE, null, ex);\n-\t\t}\n-\t\tbyte[] transactionInBytes = outputStream.toByteArray();\n-\t\t\n-\t\treturn new Sha256Hash(transactionInBytes);\n-\t}\n-\t\n-\t/**\n-\t * @return - a copy of this transaction\n-\t * @throws UnsupportedOperationException - If this transaction has sources.\n-\t */\n-\tpublic Transaction genesisCopy() {\n-\t\tif (!source.isEmpty()) throw new UnsupportedOperationException(\"Only genesis transactions can be copied\");\n-\t\tTransaction transaction = new Transaction(number, sender, receiver, amount, remainder, new HashSet<>(0));\n-\t\ttransaction.blockNumber = OptionalInt.of(0);\n-\t\treturn transaction;\n-\t}\n+    /**\n+     * Constructor.\n+     *\n+     * @param number    - the number of this transaction.\n+     * @param sender    - the sender of this transaction.\n+     * @param receiver  - the receiver of this transaction.\n+     * @param amount    - the amount to be transferred.\n+     * @param remainder - the remaining amount.\n+     * @param source    - set of transactions that are used as source for this transaction.\n+     */\n+    public Transaction(int number, Node sender, Node receiver, long amount, long remainder, Set<Transaction> source) {\n+        this.sender = sender;\n+        this.receiver = receiver;\n+        this.amount = amount;\n+        this.remainder = remainder;\n+        this.source = source;\n+        this.number = number;\n+        this.blockNumber = OptionalInt.empty();\n+    }\n \n-\t@Override\n-\tpublic int hashCode() {\n-\t\tfinal int prime = 31;\n-\t\tint result = 1;\n-\t\tresult = prime * result + number;\n-\t\tresult = prime * result + receiver.getId();\n-\t\tresult = prime * result + ((sender == null) ? -1 : sender.getId());\n-\t\treturn result;\n-\t}\n+    /**\n+     * Constructor to decode a transaction message.\n+     *\n+     * @param transactionMessage  - the message received from a transaction.\n+     * @param encodedChainUpdates - the received chain of updates\n+     * @param decodedChainUpdates - current chain of updates, from the decoding process\n+     * @param localStore          - local store, to get each Node object\n+     * @throws java.io.IOException - error while getting node\n+     */\n+    public Transaction(TransactionMessage transactionMessage, Map<Integer, List<BlockMessage>> encodedChainUpdates,\n+                       Map<Node, List<Block>> decodedChainUpdates, LocalStore localStore) throws IOException {\n+        this.number = transactionMessage.getNumber();\n+        this.blockNumber = OptionalInt.of(transactionMessage.getBlockNumber());\n \n-\t@Override\n-\tpublic boolean equals(Object obj) {\n-\t\tif (this == obj) return true;\n-\t\tif (!(obj instanceof Transaction)) return false;\n-\t\t\n-\t\tTransaction other = (Transaction) obj;\n-\t\tif (number != other.number) return false;\n-\t\tif (receiver.getId() != other.receiver.getId()) return false;\n-\t\tif (sender == null) {\n-\t\t\tif (other.sender != null) return false;\n-\t\t} else if (other.sender == null || sender.getId() != other.sender.getId()) return false;\n-\t\tif (amount != other.amount) return false;\n-\t\tif (remainder != other.remainder) return false;\n-\t\tif (!hash.equals(other.hash)) return false;\n-\t\tif (!source.equals(other.source)) return false;\n-\t\tif (!blockNumber.equals(other.blockNumber)) return false;\n-\t\treturn true;\n-\t}\n+        // It's a genesis transaction\n+        if (transactionMessage.getSenderId() == GENESIS_SENDER) {\n+            this.sender = null;\n+        } else {\n+            this.sender = localStore.getNode(transactionMessage.getSenderId());\n+        }\n+        this.receiver = localStore.getNode(transactionMessage.getReceiverId());\n+        this.amount = transactionMessage.getAmount();\n+        this.remainder = transactionMessage.getRemainder();\n+        // Decode transaction messages to normal transactions\n+        this.source = new HashSet<>();\n+        // Use local store for known sources\n+        for (Entry<Integer, Integer> knownSourceEntry : transactionMessage.getKnownSource()) {\n+            Integer nodeId = knownSourceEntry.getKey();\n+            Integer transactionId = knownSourceEntry.getValue();\n+            //TODO This might need to be done in a certain order\n+            this.source.add(localStore.getTransactionFromNode(nodeId, transactionId));\n+        }\n+        // Use chain of updates for new sources\n+        for (Entry<Integer, Integer> newSourceEntry : transactionMessage.getNewSource()) {\n+            try {\n+                // Try to find the transaction in the local store\n+                this.source.add(localStore.getTransactionFromNode(newSourceEntry.getKey(), newSourceEntry.getValue()));\n+                continue;\n+            } catch (IllegalStateException ex) {\n+                // Not in localStore\n+            }\n+            // Use the transaction from the current chain of updates\n+            Node owner = localStore.getNode(newSourceEntry.getKey());\n+            if (!decodedChainUpdates.containsKey(owner)) {\n+                // Get that new chain\n+                List<BlockMessage> blockMessageList = encodedChainUpdates.get(owner.getId());\n+                // Decode chain, in REVERSE order\n+                BlockMessage lastBlockMessage = null;\n+                try {\n+                    lastBlockMessage = blockMessageList.get(blockMessageList.size() - 1);\n+                } catch (NullPointerException e) {\n+                    e.printStackTrace();\n+                    System.exit(1);\n+                }\n+                // Recursively decode the blocks of a chain (in reverse order)\n+                Block lastBlockLocal = new Block(lastBlockMessage, encodedChainUpdates, decodedChainUpdates, localStore);\n+                if (decodedChainUpdates.containsKey(owner)) {\n+                    // Add to already created list\n+                    decodedChainUpdates.get(owner).add(lastBlockLocal);\n+                } else {\n+                    // Create a new list\n+                    List<Block> blockList = new ArrayList<>();\n+                    blockList.add(lastBlockLocal);\n+                    decodedChainUpdates.put(owner, blockList);\n+                }\n+            }\n+            // TODO [Performance]: Find a way to directly go to the correct block instead of iterating through all of them\n+            for (Block blockAux : decodedChainUpdates.get(owner)) {\n+                for (Transaction transactionAux : blockAux.getTransactions()) {\n+                    if (transactionAux.getNumber() == newSourceEntry.getValue()) {\n+                        this.source.add(transactionAux);\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+        this.hash = transactionMessage.getHash();\n+    }\n \n-\t@Override\n-\tpublic String toString() {\n-\t\tif (sender == null) {\n-\t\t\treturn \"Transaction(\" + number + \": GENESIS -> \" + receiver.getId() + \" $\" + amount + \")\";\n-\t\t} else {\n-\t\t\treturn \"Transaction(\" + number + \": \" + sender.getId() + \" -> \" + receiver.getId() + \" $\" + amount + \" / $\" + remainder + \")\";\n-\t\t}\n-\t}\n+    /**\n+     * Returns the number of the block (if it is in a block).\n+     * TODO: maybe do this more efficiently (when adding the transaction to the local chain or something)\n+     *\n+     * @return - optional that is empty if the transaction is not in a block, and filled with the number of the block otherwise.\n+     */\n+    public OptionalInt getBlockNumber() {\n+        if (!this.blockNumber.isPresent()) {\n+            // It's a genesis transaction\n+            if (this.sender == null) {\n+                this.blockNumber = OptionalInt.of(Block.GENESIS_BLOCK_NUMBER);\n+            } else {\n+                for (Block block : sender.getChain().getBlocks()) {\n+                    if (block.getTransactions().contains(this)) {\n+                        this.blockNumber = OptionalInt.of(block.getNumber());\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+        return this.blockNumber;\n+    }\n+\n+    /**\n+     * Sets the block number of this transaction.\n+     *\n+     * @param number - the block number\n+     */\n+    public void setBlockNumber(int number) {\n+        this.blockNumber = OptionalInt.of(number);\n+    }\n+\n+    /**\n+     * Get hash of the transaction.\n+     *\n+     * @return Hash SHA256\n+     */\n+    public Sha256Hash getHash() {\n+        if (this.hash == null) {\n+            this.hash = this.calculateHash();\n+        }\n+        return this.hash;\n+    }\n+\n+    /**\n+     * Calculate the transaction hash.\n+     *\n+     * @return Hash SHA256\n+     */\n+    private Sha256Hash calculateHash() {\n+        // Convert attributes of transaction into an array of bytes\n+        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n+        try {\n+            // Important to keep the order of writings\n+            outputStream.write(Utils.intToByteArray(this.number));\n+            if (this.sender != null) {\n+                outputStream.write(Utils.intToByteArray(this.sender.getId()));\n+            }\n+            outputStream.write(Utils.intToByteArray(this.receiver.getId()));\n+            outputStream.write(Utils.longToByteArray(this.amount));\n+            outputStream.write(Utils.longToByteArray(this.remainder));\n+\n+            // TODO: check if we really need to do this\n+            for (Transaction tx : this.source) {\n+                outputStream.write(tx.getHash().getBytes());\n+            }\n+        } catch (IOException ex) {\n+            Log.log(Level.SEVERE, null, ex);\n+        }\n+        byte[] transactionInBytes = outputStream.toByteArray();\n+\n+        return new Sha256Hash(transactionInBytes);\n+    }\n+\n+    /**\n+     * @return - a copy of this transaction\n+     * @throws UnsupportedOperationException - If this transaction has sources.\n+     */\n+    public Transaction genesisCopy() {\n+        if (!source.isEmpty()) {\n+            throw new UnsupportedOperationException(\"Only genesis transactions can be copied\");\n+        }\n+        Transaction transaction = new Transaction(number, sender, receiver, amount, remainder, new HashSet<>(0));\n+        transaction.blockNumber = OptionalInt.of(0);\n+        return transaction;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        final int prime = 31;\n+        int result = 1;\n+        result = prime * result + number;\n+        result = prime * result + receiver.getId();\n+        result = prime * result + ((sender == null) ? -1 : sender.getId());\n+        return result;\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if (!(obj instanceof Transaction)) {\n+            return false;\n+        }\n+\n+        Transaction other = (Transaction) obj;\n+        if (number != other.number) {\n+            return false;\n+        }\n+        if (receiver.getId() != other.receiver.getId()) {\n+            return false;\n+        }\n+        if (sender == null) {\n+            if (other.sender != null) {\n+                return false;\n+            }\n+        } else if (other.sender == null || sender.getId() != other.sender.getId()) {\n+            return false;\n+        }\n+        if (amount != other.amount) {\n+            return false;\n+        }\n+        if (remainder != other.remainder) {\n+            return false;\n+        }\n+        if (!hash.equals(other.hash)) {\n+            return false;\n+        }\n+        if (!source.equals(other.source)) {\n+            return false;\n+        }\n+        if (!blockNumber.equals(other.blockNumber)) {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        if (sender == null) {\n+            return \"Transaction(\" + number + \": GENESIS -> \" + receiver.getId() + \" $\" + amount + \")\";\n+        } else {\n+            return \"Transaction(\" + number + \": \" + sender.getId() + \" -> \" + receiver.getId() + \" $\" + amount + \" / $\" + remainder + \")\";\n+        }\n+    }\n \n }\n",
            "diff_size": 418
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "119",
                    "column": "19",
                    "severity": "warning",
                    "message": "'catch' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "119",
                    "column": "19",
                    "severity": "warning",
                    "message": "'catch' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                },
                {
                    "line": "119",
                    "column": "24",
                    "severity": "warning",
                    "message": "'(' is followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/blockchain-lab-ScaleOutDistributedLedger/errored/1/24/Transaction.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/blockchain-lab-ScaleOutDistributedLedger/styler_three_grams/24/Transaction.java\nindex 3f93443e2bc..4c23346c401 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/blockchain-lab-ScaleOutDistributedLedger/errored/1/24/Transaction.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/blockchain-lab-ScaleOutDistributedLedger/styler_three_grams/24/Transaction.java\n@@ -116,7 +116,7 @@ public class Transaction {\n \t\t\t\tBlockMessage lastBlockMessage = null;\n \t\t\t\ttry {\n \t\t\t\t\tlastBlockMessage = blockMessageList.get(blockMessageList.size() - 1);\n-\t\t\t\t} catch(NullPointerException e) {\n+\t\t\t\t} catch( NullPointerException e) {\n \t\t\t\t\te.printStackTrace();\n \t\t\t\t\tSystem.exit(1);\n \t\t\t\t}\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "intellij"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}