{
    "project_name": "codefollower-H2-Research",
    "error_id": "77",
    "information": {
        "errors": [
            {
                "line": "370",
                "column": "44",
                "severity": "warning",
                "message": "'typecast' is not followed by whitespace.",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAfterCheck"
            }
        ]
    },
    "source_code": "            throw DbException.get(ErrorCode.INVALID_USE_OF_AGGREGATE_FUNCTION_1, getSQL());\n        }\n        AggregateData data = (AggregateData)select.getCurrentGroupExprData(this);\n        if (data == null) {\n            data = AggregateData.create(type);\n            select.setCurrentGroupExprData(this, data);",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/77/Aggregate.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler/77/Aggregate.java\nindex c1adc190471..32a183bd055 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/77/Aggregate.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler/77/Aggregate.java\n@@ -367,7 +367,7 @@ public class Aggregate extends Expression {\n         if (!select.isCurrentGroup()) {\n             throw DbException.get(ErrorCode.INVALID_USE_OF_AGGREGATE_FUNCTION_1, getSQL());\n         }\n-        AggregateData data = (AggregateData)select.getCurrentGroupExprData(this);\n+        AggregateData data = (AggregateData) select.getCurrentGroupExprData(this);\n         if (data == null) {\n             data = AggregateData.create(type);\n             select.setCurrentGroupExprData(this, data);\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/77/Aggregate.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/77/Aggregate.java\nindex c1adc190471..75a00d01fa7 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/77/Aggregate.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/77/Aggregate.java\n@@ -3,12 +3,14 @@\n  * and the EPL 1.0 (http://h2database.com/html/license.html).\n  * Initial Developer: H2 Group\n  */\n+\n package org.h2.expression;\n \n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Comparator;\n import java.util.HashMap;\n+\n import org.h2.api.ErrorCode;\n import org.h2.command.dml.Select;\n import org.h2.command.dml.SelectOrderBy;\n@@ -39,721 +41,721 @@ import org.h2.value.ValueString;\n  */\n public class Aggregate extends Expression {\n \n-    public enum AggregateType {\n-        /**\n-         * The aggregate type for COUNT(*).\n-         */\n-        COUNT_ALL,\n-\n-        /**\n-         * The aggregate type for COUNT(expression).\n-         */\n-        COUNT,\n-\n-        /**\n-         * The aggregate type for GROUP_CONCAT(...).\n-         */\n-        GROUP_CONCAT,\n-\n-        /**\n-         * The aggregate type for SUM(expression).\n-         */\n-        SUM,\n-\n-        /**\n-         * The aggregate type for MIN(expression).\n-         */\n-        MIN,\n-\n-        /**\n-         * The aggregate type for MAX(expression).\n-         */\n-        MAX,\n-\n-        /**\n-         * The aggregate type for AVG(expression).\n-         */\n-        AVG,\n-\n-        /**\n-         * The aggregate type for STDDEV_POP(expression).\n-         */\n-        STDDEV_POP,\n-\n-        /**\n-         * The aggregate type for STDDEV_SAMP(expression).\n-         */\n-        STDDEV_SAMP,\n-\n-        /**\n-         * The aggregate type for VAR_POP(expression).\n-         */\n-        VAR_POP,\n-\n-        /**\n-         * The aggregate type for VAR_SAMP(expression).\n-         */\n-        VAR_SAMP,\n-\n-        /**\n-         * The aggregate type for BOOL_OR(expression).\n-         */\n-        BOOL_OR,\n-\n-        /**\n-         * The aggregate type for BOOL_AND(expression).\n-         */\n-        BOOL_AND,\n-\n-        /**\n-         * The aggregate type for BOOL_OR(expression).\n-         */\n-        BIT_OR,\n-\n-        /**\n-         * The aggregate type for BOOL_AND(expression).\n-         */\n-        BIT_AND,\n-\n-        /**\n-         * The aggregate type for SELECTIVITY(expression).\n-         */\n-        SELECTIVITY,\n-\n-        /**\n-         * The aggregate type for HISTOGRAM(expression).\n-         */\n-        HISTOGRAM,\n-\n-        /**\n-         * The aggregate type for MEDIAN(expression).\n-         */\n-        MEDIAN,\n-        /**\n-         * The aggregate type for ARRAY_AGG(expression).\n-         */\n-        ARRAY_AGG\n-    }\n-\n-    private static final HashMap<String, AggregateType> AGGREGATES = new HashMap<>(64);\n-\n-    private final AggregateType type;\n-    private final Select select;\n-    private final boolean distinct;\n-\n-    private Expression on;\n-    private Expression groupConcatSeparator;\n-    private ArrayList<SelectOrderBy> orderByList;\n-    private SortOrder orderBySort;\n-    private int dataType, scale;\n-    private long precision;\n-    private int displaySize;\n-    private int lastGroupRowId;\n-\n-    private Expression filterCondition;\n+  public enum AggregateType {\n+    /**\n+     * The aggregate type for COUNT(*).\n+     */\n+    COUNT_ALL,\n \n     /**\n-     * Create a new aggregate object.\n-     *\n-     * @param type the aggregate type\n-     * @param on the aggregated expression\n-     * @param select the select statement\n-     * @param distinct if distinct is used\n+     * The aggregate type for COUNT(expression).\n      */\n-    public Aggregate(AggregateType type, Expression on, Select select, boolean distinct) {\n-        this.type = type;\n-        this.on = on;\n-        this.select = select;\n-        this.distinct = distinct;\n-    }\n-\n-    static {\n-        /*\n-         * Update initial size of AGGREGATES after editing the following list.\n-         */\n-        addAggregate(\"COUNT\", AggregateType.COUNT);\n-        addAggregate(\"SUM\", AggregateType.SUM);\n-        addAggregate(\"MIN\", AggregateType.MIN);\n-        addAggregate(\"MAX\", AggregateType.MAX);\n-        addAggregate(\"AVG\", AggregateType.AVG);\n-        addAggregate(\"GROUP_CONCAT\", AggregateType.GROUP_CONCAT);\n-        // PostgreSQL compatibility: string_agg(expression, delimiter)\n-        addAggregate(\"STRING_AGG\", AggregateType.GROUP_CONCAT);\n-        addAggregate(\"STDDEV_SAMP\", AggregateType.STDDEV_SAMP);\n-        addAggregate(\"STDDEV\", AggregateType.STDDEV_SAMP);\n-        addAggregate(\"STDDEV_POP\", AggregateType.STDDEV_POP);\n-        addAggregate(\"STDDEVP\", AggregateType.STDDEV_POP);\n-        addAggregate(\"VAR_POP\", AggregateType.VAR_POP);\n-        addAggregate(\"VARP\", AggregateType.VAR_POP);\n-        addAggregate(\"VAR_SAMP\", AggregateType.VAR_SAMP);\n-        addAggregate(\"VAR\", AggregateType.VAR_SAMP);\n-        addAggregate(\"VARIANCE\", AggregateType.VAR_SAMP);\n-        addAggregate(\"BOOL_OR\", AggregateType.BOOL_OR);\n-        // HSQLDB compatibility, but conflicts with x > EVERY(...)\n-        addAggregate(\"SOME\", AggregateType.BOOL_OR);\n-        addAggregate(\"BOOL_AND\", AggregateType.BOOL_AND);\n-        // HSQLDB compatibility, but conflicts with x > SOME(...)\n-        addAggregate(\"EVERY\", AggregateType.BOOL_AND);\n-        addAggregate(\"SELECTIVITY\", AggregateType.SELECTIVITY);\n-        addAggregate(\"HISTOGRAM\", AggregateType.HISTOGRAM);\n-        addAggregate(\"BIT_OR\", AggregateType.BIT_OR);\n-        addAggregate(\"BIT_AND\", AggregateType.BIT_AND);\n-        addAggregate(\"MEDIAN\", AggregateType.MEDIAN);\n-        addAggregate(\"ARRAY_AGG\", AggregateType.ARRAY_AGG);\n-    }\n-\n-    private static void addAggregate(String name, AggregateType type) {\n-        AGGREGATES.put(name, type);\n-    }\n+    COUNT,\n \n     /**\n-     * Get the aggregate type for this name, or -1 if no aggregate has been\n-     * found.\n-     *\n-     * @param name the aggregate function name\n-     * @return null if no aggregate function has been found, or the aggregate type\n+     * The aggregate type for GROUP_CONCAT(...).\n      */\n-    public static AggregateType getAggregateType(String name) {\n-        return AGGREGATES.get(name);\n-    }\n+    GROUP_CONCAT,\n \n     /**\n-     * Set the order for ARRAY_AGG() or GROUP_CONCAT() aggregate.\n-     *\n-     * @param orderByList the order by list\n+     * The aggregate type for SUM(expression).\n      */\n-    public void setOrderByList(ArrayList<SelectOrderBy> orderByList) {\n-        this.orderByList = orderByList;\n-    }\n+    SUM,\n \n     /**\n-     * Set the separator for the GROUP_CONCAT() aggregate.\n-     *\n-     * @param separator the separator expression\n+     * The aggregate type for MIN(expression).\n      */\n-    public void setGroupConcatSeparator(Expression separator) {\n-        this.groupConcatSeparator = separator;\n-    }\n+    MIN,\n \n     /**\n-     * Sets the FILTER condition.\n-     *\n-     * @param filterCondition condition\n+     * The aggregate type for MAX(expression).\n      */\n-    public void setFilterCondition(Expression filterCondition) {\n-        this.filterCondition = filterCondition;\n-    }\n+    MAX,\n \n-    private SortOrder initOrder(Session session) {\n-        int size = orderByList.size();\n-        int[] index = new int[size];\n-        int[] sortType = new int[size];\n-        for (int i = 0; i < size; i++) {\n-            SelectOrderBy o = orderByList.get(i);\n-            index[i] = i + 1;\n-            sortType[i] = o.sortType;\n-        }\n-        return new SortOrder(session.getDatabase(), index, sortType, null);\n-    }\n-\n-    private void sortWithOrderBy(Value[] array) {\n-        final SortOrder sortOrder = orderBySort;\n-        if (sortOrder != null) {\n-            Arrays.sort(array, new Comparator<Value>() {\n-                @Override\n-                public int compare(Value v1, Value v2) {\n-                    return sortOrder.compare(((ValueArray) v1).getList(), ((ValueArray) v2).getList());\n-                }\n-            });\n-        } else {\n-            Arrays.sort(array, select.getSession().getDatabase().getCompareMode());\n-        }\n-    }\n+    /**\n+     * The aggregate type for AVG(expression).\n+     */\n+    AVG,\n \n-    @Override\n-    public void updateAggregate(Session session) {\n-        // TODO aggregates: check nested MIN(MAX(ID)) and so on\n-        // if (on != null) {\n-        // on.updateAggregate();\n-        // }\n-        if (!select.isCurrentGroup()) {\n-            // this is a different level (the enclosing query)\n-            return;\n-        }\n+    /**\n+     * The aggregate type for STDDEV_POP(expression).\n+     */\n+    STDDEV_POP,\n \n-        int groupRowId = select.getCurrentGroupRowId();\n-        if (lastGroupRowId == groupRowId) {\n-            // already visited\n-            return;\n-        }\n-        lastGroupRowId = groupRowId;\n+    /**\n+     * The aggregate type for STDDEV_SAMP(expression).\n+     */\n+    STDDEV_SAMP,\n \n-        AggregateData data = (AggregateData) select.getCurrentGroupExprData(this);\n-        if (data == null) {\n-            data = AggregateData.create(type);\n-            select.setCurrentGroupExprData(this, data);\n-        }\n-        Value v = on == null ? null : on.getValue(session);\n-        if (type == AggregateType.GROUP_CONCAT) {\n-            if (v != ValueNull.INSTANCE) {\n-                v = v.convertTo(Value.STRING);\n-                if (orderByList != null) {\n-                    int size = orderByList.size();\n-                    Value[] array = new Value[1 + size];\n-                    array[0] = v;\n-                    for (int i = 0; i < size; i++) {\n-                        SelectOrderBy o = orderByList.get(i);\n-                        array[i + 1] = o.expression.getValue(session);\n-                    }\n-                    v = ValueArray.get(array);\n-                }\n-            }\n-        }\n-        if (type == AggregateType.ARRAY_AGG) {\n-            if (v != ValueNull.INSTANCE) {\n-                if (orderByList != null) {\n-                    int size = orderByList.size();\n-                    Value[] array = new Value[1 + size];\n-                    array[0] = v;\n-                    for (int i = 0; i < size; i++) {\n-                        SelectOrderBy o = orderByList.get(i);\n-                        array[i + 1] = o.expression.getValue(session);\n-                    }\n-                    v = ValueArray.get(array);\n-                }\n-            }\n-        }\n-        if (filterCondition != null) {\n-            if (!filterCondition.getBooleanValue(session)) {\n-                return;\n-            }\n-        }\n-        data.add(session.getDatabase(), dataType, distinct, v);\n-    }\n-\n-    @Override\n-    public Value getValue(Session session) {\n-        if (select.isQuickAggregateQuery()) {\n-            switch (type) {\n-            case COUNT:\n-            case COUNT_ALL:\n-                Table table = select.getTopTableFilter().getTable();\n-                return ValueLong.get(table.getRowCount(session));\n-            case MIN:\n-            case MAX: {\n-                boolean first = type == AggregateType.MIN;\n-                Index index = getMinMaxColumnIndex();\n-                int sortType = index.getIndexColumns()[0].sortType;\n-                if ((sortType & SortOrder.DESCENDING) != 0) {\n-                    first = !first;\n-                }\n-                Cursor cursor = index.findFirstOrLast(session, first);\n-                SearchRow row = cursor.getSearchRow();\n-                Value v;\n-                if (row == null) {\n-                    v = ValueNull.INSTANCE;\n-                } else {\n-                    v = row.getValue(index.getColumns()[0].getColumnId());\n-                }\n-                return v;\n-            }\n-            case MEDIAN: {\n-                return AggregateDataMedian.getResultFromIndex(session, on, dataType);\n-            }\n-            default:\n-                DbException.throwInternalError(\"type=\" + type);\n-            }\n-        }\n-        if (!select.isCurrentGroup()) {\n-            throw DbException.get(ErrorCode.INVALID_USE_OF_AGGREGATE_FUNCTION_1, getSQL());\n-        }\n-        AggregateData data = (AggregateData)select.getCurrentGroupExprData(this);\n-        if (data == null) {\n-            data = AggregateData.create(type);\n-            select.setCurrentGroupExprData(this, data);\n-        }\n-        if (type == AggregateType.GROUP_CONCAT) {\n-            Value[] array = ((AggregateDataCollecting) data).getArray();\n-            if (array == null) {\n-                return ValueNull.INSTANCE;\n-            }\n-            if (orderByList != null || distinct) {\n-                sortWithOrderBy(array);\n-            }\n-            StatementBuilder buff = new StatementBuilder();\n-            String sep = groupConcatSeparator == null ?\n-                    \",\" : groupConcatSeparator.getValue(session).getString();\n-            for (Value val : array) {\n-                String s;\n-                if (val.getType() == Value.ARRAY) {\n-                    s = ((ValueArray) val).getList()[0].getString();\n-                } else {\n-                    s = val.getString();\n-                }\n-                if (s == null) {\n-                    continue;\n-                }\n-                if (sep != null) {\n-                    buff.appendExceptFirst(sep);\n-                }\n-                buff.append(s);\n-            }\n-            return ValueString.get(buff.toString());\n-        } else if (type == AggregateType.ARRAY_AGG) {\n-            Value[] array = ((AggregateDataCollecting) data).getArray();\n-            if (array == null) {\n-                return ValueNull.INSTANCE;\n-            }\n-            if (orderByList != null || distinct) {\n-                sortWithOrderBy(array);\n-            }\n-            if (orderByList != null) {\n-                for (int i = 0; i < array.length; i++) {\n-                    array[i] = ((ValueArray) array[i]).getList()[0];\n-                }\n-            }\n-            return ValueArray.get(array);\n-        }\n-        return data.getValue(session.getDatabase(), dataType, distinct);\n+    /**\n+     * The aggregate type for VAR_POP(expression).\n+     */\n+    VAR_POP,\n+\n+    /**\n+     * The aggregate type for VAR_SAMP(expression).\n+     */\n+    VAR_SAMP,\n+\n+    /**\n+     * The aggregate type for BOOL_OR(expression).\n+     */\n+    BOOL_OR,\n+\n+    /**\n+     * The aggregate type for BOOL_AND(expression).\n+     */\n+    BOOL_AND,\n+\n+    /**\n+     * The aggregate type for BOOL_OR(expression).\n+     */\n+    BIT_OR,\n+\n+    /**\n+     * The aggregate type for BOOL_AND(expression).\n+     */\n+    BIT_AND,\n+\n+    /**\n+     * The aggregate type for SELECTIVITY(expression).\n+     */\n+    SELECTIVITY,\n+\n+    /**\n+     * The aggregate type for HISTOGRAM(expression).\n+     */\n+    HISTOGRAM,\n+\n+    /**\n+     * The aggregate type for MEDIAN(expression).\n+     */\n+    MEDIAN,\n+    /**\n+     * The aggregate type for ARRAY_AGG(expression).\n+     */\n+    ARRAY_AGG\n+  }\n+\n+  private static final HashMap<String, AggregateType> AGGREGATES = new HashMap<>(64);\n+\n+  private final AggregateType type;\n+  private final Select select;\n+  private final boolean distinct;\n+\n+  private Expression on;\n+  private Expression groupConcatSeparator;\n+  private ArrayList<SelectOrderBy> orderByList;\n+  private SortOrder orderBySort;\n+  private int dataType, scale;\n+  private long precision;\n+  private int displaySize;\n+  private int lastGroupRowId;\n+\n+  private Expression filterCondition;\n+\n+  /**\n+   * Create a new aggregate object.\n+   *\n+   * @param type     the aggregate type\n+   * @param on       the aggregated expression\n+   * @param select   the select statement\n+   * @param distinct if distinct is used\n+   */\n+  public Aggregate(AggregateType type, Expression on, Select select, boolean distinct) {\n+    this.type = type;\n+    this.on = on;\n+    this.select = select;\n+    this.distinct = distinct;\n+  }\n+\n+  static {\n+    /*\n+     * Update initial size of AGGREGATES after editing the following list.\n+     */\n+    addAggregate(\"COUNT\", AggregateType.COUNT);\n+    addAggregate(\"SUM\", AggregateType.SUM);\n+    addAggregate(\"MIN\", AggregateType.MIN);\n+    addAggregate(\"MAX\", AggregateType.MAX);\n+    addAggregate(\"AVG\", AggregateType.AVG);\n+    addAggregate(\"GROUP_CONCAT\", AggregateType.GROUP_CONCAT);\n+    // PostgreSQL compatibility: string_agg(expression, delimiter)\n+    addAggregate(\"STRING_AGG\", AggregateType.GROUP_CONCAT);\n+    addAggregate(\"STDDEV_SAMP\", AggregateType.STDDEV_SAMP);\n+    addAggregate(\"STDDEV\", AggregateType.STDDEV_SAMP);\n+    addAggregate(\"STDDEV_POP\", AggregateType.STDDEV_POP);\n+    addAggregate(\"STDDEVP\", AggregateType.STDDEV_POP);\n+    addAggregate(\"VAR_POP\", AggregateType.VAR_POP);\n+    addAggregate(\"VARP\", AggregateType.VAR_POP);\n+    addAggregate(\"VAR_SAMP\", AggregateType.VAR_SAMP);\n+    addAggregate(\"VAR\", AggregateType.VAR_SAMP);\n+    addAggregate(\"VARIANCE\", AggregateType.VAR_SAMP);\n+    addAggregate(\"BOOL_OR\", AggregateType.BOOL_OR);\n+    // HSQLDB compatibility, but conflicts with x > EVERY(...)\n+    addAggregate(\"SOME\", AggregateType.BOOL_OR);\n+    addAggregate(\"BOOL_AND\", AggregateType.BOOL_AND);\n+    // HSQLDB compatibility, but conflicts with x > SOME(...)\n+    addAggregate(\"EVERY\", AggregateType.BOOL_AND);\n+    addAggregate(\"SELECTIVITY\", AggregateType.SELECTIVITY);\n+    addAggregate(\"HISTOGRAM\", AggregateType.HISTOGRAM);\n+    addAggregate(\"BIT_OR\", AggregateType.BIT_OR);\n+    addAggregate(\"BIT_AND\", AggregateType.BIT_AND);\n+    addAggregate(\"MEDIAN\", AggregateType.MEDIAN);\n+    addAggregate(\"ARRAY_AGG\", AggregateType.ARRAY_AGG);\n+  }\n+\n+  private static void addAggregate(String name, AggregateType type) {\n+    AGGREGATES.put(name, type);\n+  }\n+\n+  /**\n+   * Get the aggregate type for this name, or -1 if no aggregate has been\n+   * found.\n+   *\n+   * @param name the aggregate function name\n+   * @return null if no aggregate function has been found, or the aggregate type\n+   */\n+  public static AggregateType getAggregateType(String name) {\n+    return AGGREGATES.get(name);\n+  }\n+\n+  /**\n+   * Set the order for ARRAY_AGG() or GROUP_CONCAT() aggregate.\n+   *\n+   * @param orderByList the order by list\n+   */\n+  public void setOrderByList(ArrayList<SelectOrderBy> orderByList) {\n+    this.orderByList = orderByList;\n+  }\n+\n+  /**\n+   * Set the separator for the GROUP_CONCAT() aggregate.\n+   *\n+   * @param separator the separator expression\n+   */\n+  public void setGroupConcatSeparator(Expression separator) {\n+    this.groupConcatSeparator = separator;\n+  }\n+\n+  /**\n+   * Sets the FILTER condition.\n+   *\n+   * @param filterCondition condition\n+   */\n+  public void setFilterCondition(Expression filterCondition) {\n+    this.filterCondition = filterCondition;\n+  }\n+\n+  private SortOrder initOrder(Session session) {\n+    int size = orderByList.size();\n+    int[] index = new int[size];\n+    int[] sortType = new int[size];\n+    for (int i = 0; i < size; i++) {\n+      SelectOrderBy o = orderByList.get(i);\n+      index[i] = i + 1;\n+      sortType[i] = o.sortType;\n+    }\n+    return new SortOrder(session.getDatabase(), index, sortType, null);\n+  }\n+\n+  private void sortWithOrderBy(Value[] array) {\n+    final SortOrder sortOrder = orderBySort;\n+    if (sortOrder != null) {\n+      Arrays.sort(array, new Comparator<Value>() {\n+        @Override\n+        public int compare(Value v1, Value v2) {\n+          return sortOrder.compare(((ValueArray) v1).getList(), ((ValueArray) v2).getList());\n+        }\n+      });\n+    } else {\n+      Arrays.sort(array, select.getSession().getDatabase().getCompareMode());\n+    }\n+  }\n+\n+  @Override\n+  public void updateAggregate(Session session) {\n+    // TODO aggregates: check nested MIN(MAX(ID)) and so on\n+    // if (on != null) {\n+    // on.updateAggregate();\n+    // }\n+    if (!select.isCurrentGroup()) {\n+      // this is a different level (the enclosing query)\n+      return;\n     }\n \n-    @Override\n-    public int getType() {\n-        return dataType;\n+    int groupRowId = select.getCurrentGroupRowId();\n+    if (lastGroupRowId == groupRowId) {\n+      // already visited\n+      return;\n     }\n+    lastGroupRowId = groupRowId;\n \n-    @Override\n-    public void mapColumns(ColumnResolver resolver, int level) {\n-        if (on != null) {\n-            on.mapColumns(resolver, level);\n-        }\n+    AggregateData data = (AggregateData) select.getCurrentGroupExprData(this);\n+    if (data == null) {\n+      data = AggregateData.create(type);\n+      select.setCurrentGroupExprData(this, data);\n+    }\n+    Value v = on == null ? null : on.getValue(session);\n+    if (type == AggregateType.GROUP_CONCAT) {\n+      if (v != ValueNull.INSTANCE) {\n+        v = v.convertTo(Value.STRING);\n         if (orderByList != null) {\n-            for (SelectOrderBy o : orderByList) {\n-                o.expression.mapColumns(resolver, level);\n-            }\n-        }\n-        if (groupConcatSeparator != null) {\n-            groupConcatSeparator.mapColumns(resolver, level);\n-        }\n-        if (filterCondition != null) {\n-            filterCondition.mapColumns(resolver, level);\n+          int size = orderByList.size();\n+          Value[] array = new Value[1 + size];\n+          array[0] = v;\n+          for (int i = 0; i < size; i++) {\n+            SelectOrderBy o = orderByList.get(i);\n+            array[i + 1] = o.expression.getValue(session);\n+          }\n+          v = ValueArray.get(array);\n         }\n+      }\n     }\n-\n-    @Override\n-    public Expression optimize(Session session) {\n-        if (on != null) {\n-            on = on.optimize(session);\n-            dataType = on.getType();\n-            scale = on.getScale();\n-            precision = on.getPrecision();\n-            displaySize = on.getDisplaySize();\n-        }\n+    if (type == AggregateType.ARRAY_AGG) {\n+      if (v != ValueNull.INSTANCE) {\n         if (orderByList != null) {\n-            for (SelectOrderBy o : orderByList) {\n-                o.expression = o.expression.optimize(session);\n-            }\n-            orderBySort = initOrder(session);\n-        }\n-        if (groupConcatSeparator != null) {\n-            groupConcatSeparator = groupConcatSeparator.optimize(session);\n-        }\n-        if (filterCondition != null) {\n-            filterCondition = filterCondition.optimize(session);\n+          int size = orderByList.size();\n+          Value[] array = new Value[1 + size];\n+          array[0] = v;\n+          for (int i = 0; i < size; i++) {\n+            SelectOrderBy o = orderByList.get(i);\n+            array[i + 1] = o.expression.getValue(session);\n+          }\n+          v = ValueArray.get(array);\n         }\n-        switch (type) {\n-        case GROUP_CONCAT:\n-            dataType = Value.STRING;\n-            scale = 0;\n-            precision = displaySize = Integer.MAX_VALUE;\n-            break;\n-        case COUNT_ALL:\n+      }\n+    }\n+    if (filterCondition != null) {\n+      if (!filterCondition.getBooleanValue(session)) {\n+        return;\n+      }\n+    }\n+    data.add(session.getDatabase(), dataType, distinct, v);\n+  }\n+\n+  @Override\n+  public Value getValue(Session session) {\n+    if (select.isQuickAggregateQuery()) {\n+      switch (type) {\n         case COUNT:\n-            dataType = Value.LONG;\n-            scale = 0;\n-            precision = ValueLong.PRECISION;\n-            displaySize = ValueLong.DISPLAY_SIZE;\n-            break;\n-        case SELECTIVITY:\n-            dataType = Value.INT;\n-            scale = 0;\n-            precision = ValueInt.PRECISION;\n-            displaySize = ValueInt.DISPLAY_SIZE;\n-            break;\n-        case HISTOGRAM:\n-            dataType = Value.ARRAY;\n-            scale = 0;\n-            precision = displaySize = Integer.MAX_VALUE;\n-            break;\n-        case SUM:\n-            if (dataType == Value.BOOLEAN) {\n-                // example: sum(id > 3) (count the rows)\n-                dataType = Value.LONG;\n-            } else if (!DataType.supportsAdd(dataType)) {\n-                throw DbException.get(ErrorCode.SUM_OR_AVG_ON_WRONG_DATATYPE_1, getSQL());\n-            } else {\n-                dataType = DataType.getAddProofType(dataType);\n-            }\n-            break;\n-        case AVG:\n-            if (!DataType.supportsAdd(dataType)) {\n-                throw DbException.get(ErrorCode.SUM_OR_AVG_ON_WRONG_DATATYPE_1, getSQL());\n-            }\n-            break;\n+        case COUNT_ALL:\n+          Table table = select.getTopTableFilter().getTable();\n+          return ValueLong.get(table.getRowCount(session));\n         case MIN:\n-        case MAX:\n-        case MEDIAN:\n-            break;\n-        case STDDEV_POP:\n-        case STDDEV_SAMP:\n-        case VAR_POP:\n-        case VAR_SAMP:\n-            dataType = Value.DOUBLE;\n-            precision = ValueDouble.PRECISION;\n-            displaySize = ValueDouble.DISPLAY_SIZE;\n-            scale = 0;\n-            break;\n-        case BOOL_AND:\n-        case BOOL_OR:\n-            dataType = Value.BOOLEAN;\n-            precision = ValueBoolean.PRECISION;\n-            displaySize = ValueBoolean.DISPLAY_SIZE;\n-            scale = 0;\n-            break;\n-        case BIT_AND:\n-        case BIT_OR:\n-            if (!DataType.supportsAdd(dataType)) {\n-                throw DbException.get(ErrorCode.SUM_OR_AVG_ON_WRONG_DATATYPE_1, getSQL());\n-            }\n-            break;\n-        case ARRAY_AGG:\n-            dataType = Value.ARRAY;\n-            scale = 0;\n-            precision = displaySize = Integer.MAX_VALUE;\n-            break;\n-        default:\n-            DbException.throwInternalError(\"type=\" + type);\n+        case MAX: {\n+          boolean first = type == AggregateType.MIN;\n+          Index index = getMinMaxColumnIndex();\n+          int sortType = index.getIndexColumns()[0].sortType;\n+          if ((sortType & SortOrder.DESCENDING) != 0) {\n+            first = !first;\n+          }\n+          Cursor cursor = index.findFirstOrLast(session, first);\n+          SearchRow row = cursor.getSearchRow();\n+          Value v;\n+          if (row == null) {\n+            v = ValueNull.INSTANCE;\n+          } else {\n+            v = row.getValue(index.getColumns()[0].getColumnId());\n+          }\n+          return v;\n+        }\n+        case MEDIAN: {\n+          return AggregateDataMedian.getResultFromIndex(session, on, dataType);\n         }\n-        return this;\n+        default:\n+          DbException.throwInternalError(\"type=\" + type);\n+      }\n     }\n-\n-    @Override\n-    public void setEvaluatable(TableFilter tableFilter, boolean b) {\n-        if (on != null) {\n-            on.setEvaluatable(tableFilter, b);\n-        }\n-        if (orderByList != null) {\n-            for (SelectOrderBy o : orderByList) {\n-                o.expression.setEvaluatable(tableFilter, b);\n-            }\n-        }\n-        if (groupConcatSeparator != null) {\n-            groupConcatSeparator.setEvaluatable(tableFilter, b);\n-        }\n-        if (filterCondition != null) {\n-            filterCondition.setEvaluatable(tableFilter, b);\n-        }\n+    if (!select.isCurrentGroup()) {\n+      throw DbException.get(ErrorCode.INVALID_USE_OF_AGGREGATE_FUNCTION_1, getSQL());\n     }\n-\n-    @Override\n-    public int getScale() {\n-        return scale;\n+    AggregateData data = (AggregateData) select.getCurrentGroupExprData(this);\n+    if (data == null) {\n+      data = AggregateData.create(type);\n+      select.setCurrentGroupExprData(this, data);\n     }\n-\n-    @Override\n-    public long getPrecision() {\n-        return precision;\n+    if (type == AggregateType.GROUP_CONCAT) {\n+      Value[] array = ((AggregateDataCollecting) data).getArray();\n+      if (array == null) {\n+        return ValueNull.INSTANCE;\n+      }\n+      if (orderByList != null || distinct) {\n+        sortWithOrderBy(array);\n+      }\n+      StatementBuilder buff = new StatementBuilder();\n+      String sep = groupConcatSeparator == null ?\n+          \",\" : groupConcatSeparator.getValue(session).getString();\n+      for (Value val : array) {\n+        String s;\n+        if (val.getType() == Value.ARRAY) {\n+          s = ((ValueArray) val).getList()[0].getString();\n+        } else {\n+          s = val.getString();\n+        }\n+        if (s == null) {\n+          continue;\n+        }\n+        if (sep != null) {\n+          buff.appendExceptFirst(sep);\n+        }\n+        buff.append(s);\n+      }\n+      return ValueString.get(buff.toString());\n+    } else if (type == AggregateType.ARRAY_AGG) {\n+      Value[] array = ((AggregateDataCollecting) data).getArray();\n+      if (array == null) {\n+        return ValueNull.INSTANCE;\n+      }\n+      if (orderByList != null || distinct) {\n+        sortWithOrderBy(array);\n+      }\n+      if (orderByList != null) {\n+        for (int i = 0; i < array.length; i++) {\n+          array[i] = ((ValueArray) array[i]).getList()[0];\n+        }\n+      }\n+      return ValueArray.get(array);\n     }\n-\n-    @Override\n-    public int getDisplaySize() {\n-        return displaySize;\n+    return data.getValue(session.getDatabase(), dataType, distinct);\n+  }\n+\n+  @Override\n+  public int getType() {\n+    return dataType;\n+  }\n+\n+  @Override\n+  public void mapColumns(ColumnResolver resolver, int level) {\n+    if (on != null) {\n+      on.mapColumns(resolver, level);\n+    }\n+    if (orderByList != null) {\n+      for (SelectOrderBy o : orderByList) {\n+        o.expression.mapColumns(resolver, level);\n+      }\n     }\n+    if (groupConcatSeparator != null) {\n+      groupConcatSeparator.mapColumns(resolver, level);\n+    }\n+    if (filterCondition != null) {\n+      filterCondition.mapColumns(resolver, level);\n+    }\n+  }\n+\n+  @Override\n+  public Expression optimize(Session session) {\n+    if (on != null) {\n+      on = on.optimize(session);\n+      dataType = on.getType();\n+      scale = on.getScale();\n+      precision = on.getPrecision();\n+      displaySize = on.getDisplaySize();\n+    }\n+    if (orderByList != null) {\n+      for (SelectOrderBy o : orderByList) {\n+        o.expression = o.expression.optimize(session);\n+      }\n+      orderBySort = initOrder(session);\n+    }\n+    if (groupConcatSeparator != null) {\n+      groupConcatSeparator = groupConcatSeparator.optimize(session);\n+    }\n+    if (filterCondition != null) {\n+      filterCondition = filterCondition.optimize(session);\n+    }\n+    switch (type) {\n+      case GROUP_CONCAT:\n+        dataType = Value.STRING;\n+        scale = 0;\n+        precision = displaySize = Integer.MAX_VALUE;\n+        break;\n+      case COUNT_ALL:\n+      case COUNT:\n+        dataType = Value.LONG;\n+        scale = 0;\n+        precision = ValueLong.PRECISION;\n+        displaySize = ValueLong.DISPLAY_SIZE;\n+        break;\n+      case SELECTIVITY:\n+        dataType = Value.INT;\n+        scale = 0;\n+        precision = ValueInt.PRECISION;\n+        displaySize = ValueInt.DISPLAY_SIZE;\n+        break;\n+      case HISTOGRAM:\n+        dataType = Value.ARRAY;\n+        scale = 0;\n+        precision = displaySize = Integer.MAX_VALUE;\n+        break;\n+      case SUM:\n+        if (dataType == Value.BOOLEAN) {\n+          // example: sum(id > 3) (count the rows)\n+          dataType = Value.LONG;\n+        } else if (!DataType.supportsAdd(dataType)) {\n+          throw DbException.get(ErrorCode.SUM_OR_AVG_ON_WRONG_DATATYPE_1, getSQL());\n+        } else {\n+          dataType = DataType.getAddProofType(dataType);\n+        }\n+        break;\n+      case AVG:\n+        if (!DataType.supportsAdd(dataType)) {\n+          throw DbException.get(ErrorCode.SUM_OR_AVG_ON_WRONG_DATATYPE_1, getSQL());\n+        }\n+        break;\n+      case MIN:\n+      case MAX:\n+      case MEDIAN:\n+        break;\n+      case STDDEV_POP:\n+      case STDDEV_SAMP:\n+      case VAR_POP:\n+      case VAR_SAMP:\n+        dataType = Value.DOUBLE;\n+        precision = ValueDouble.PRECISION;\n+        displaySize = ValueDouble.DISPLAY_SIZE;\n+        scale = 0;\n+        break;\n+      case BOOL_AND:\n+      case BOOL_OR:\n+        dataType = Value.BOOLEAN;\n+        precision = ValueBoolean.PRECISION;\n+        displaySize = ValueBoolean.DISPLAY_SIZE;\n+        scale = 0;\n+        break;\n+      case BIT_AND:\n+      case BIT_OR:\n+        if (!DataType.supportsAdd(dataType)) {\n+          throw DbException.get(ErrorCode.SUM_OR_AVG_ON_WRONG_DATATYPE_1, getSQL());\n+        }\n+        break;\n+      case ARRAY_AGG:\n+        dataType = Value.ARRAY;\n+        scale = 0;\n+        precision = displaySize = Integer.MAX_VALUE;\n+        break;\n+      default:\n+        DbException.throwInternalError(\"type=\" + type);\n+    }\n+    return this;\n+  }\n \n-    private String getSQLGroupConcat() {\n-        StatementBuilder buff = new StatementBuilder(\"GROUP_CONCAT(\");\n-        if (distinct) {\n-            buff.append(\"DISTINCT \");\n-        }\n-        buff.append(on.getSQL());\n-        if (orderByList != null) {\n-            buff.append(\" ORDER BY \");\n-            for (SelectOrderBy o : orderByList) {\n-                buff.appendExceptFirst(\", \");\n-                buff.append(o.expression.getSQL());\n-                SortOrder.typeToString(buff.builder(), o.sortType);\n-            }\n-        }\n-        if (groupConcatSeparator != null) {\n-            buff.append(\" SEPARATOR \").append(groupConcatSeparator.getSQL());\n-        }\n-        buff.append(')');\n-        if (filterCondition != null) {\n-            buff.append(\" FILTER (WHERE \").append(filterCondition.getSQL()).append(')');\n-        }\n-        return buff.toString();\n+  @Override\n+  public void setEvaluatable(TableFilter tableFilter, boolean b) {\n+    if (on != null) {\n+      on.setEvaluatable(tableFilter, b);\n+    }\n+    if (orderByList != null) {\n+      for (SelectOrderBy o : orderByList) {\n+        o.expression.setEvaluatable(tableFilter, b);\n+      }\n+    }\n+    if (groupConcatSeparator != null) {\n+      groupConcatSeparator.setEvaluatable(tableFilter, b);\n+    }\n+    if (filterCondition != null) {\n+      filterCondition.setEvaluatable(tableFilter, b);\n+    }\n+  }\n+\n+  @Override\n+  public int getScale() {\n+    return scale;\n+  }\n+\n+  @Override\n+  public long getPrecision() {\n+    return precision;\n+  }\n+\n+  @Override\n+  public int getDisplaySize() {\n+    return displaySize;\n+  }\n+\n+  private String getSQLGroupConcat() {\n+    StatementBuilder buff = new StatementBuilder(\"GROUP_CONCAT(\");\n+    if (distinct) {\n+      buff.append(\"DISTINCT \");\n+    }\n+    buff.append(on.getSQL());\n+    if (orderByList != null) {\n+      buff.append(\" ORDER BY \");\n+      for (SelectOrderBy o : orderByList) {\n+        buff.appendExceptFirst(\", \");\n+        buff.append(o.expression.getSQL());\n+        SortOrder.typeToString(buff.builder(), o.sortType);\n+      }\n     }\n+    if (groupConcatSeparator != null) {\n+      buff.append(\" SEPARATOR \").append(groupConcatSeparator.getSQL());\n+    }\n+    buff.append(')');\n+    if (filterCondition != null) {\n+      buff.append(\" FILTER (WHERE \").append(filterCondition.getSQL()).append(')');\n+    }\n+    return buff.toString();\n+  }\n \n-    private String getSQLArrayAggregate() {\n-        StatementBuilder buff = new StatementBuilder(\"ARRAY_AGG(\");\n-        if (distinct) {\n-            buff.append(\"DISTINCT \");\n-        }\n-        buff.append(on.getSQL());\n-        if (orderByList != null) {\n-            buff.append(\" ORDER BY \");\n-            for (SelectOrderBy o : orderByList) {\n-                buff.appendExceptFirst(\", \");\n-                buff.append(o.expression.getSQL());\n-                SortOrder.typeToString(buff.builder(), o.sortType);\n-            }\n-        }\n-        buff.append(')');\n-        if (filterCondition != null) {\n-            buff.append(\" FILTER (WHERE \").append(filterCondition.getSQL()).append(')');\n-        }\n-        return buff.toString();\n+  private String getSQLArrayAggregate() {\n+    StatementBuilder buff = new StatementBuilder(\"ARRAY_AGG(\");\n+    if (distinct) {\n+      buff.append(\"DISTINCT \");\n+    }\n+    buff.append(on.getSQL());\n+    if (orderByList != null) {\n+      buff.append(\" ORDER BY \");\n+      for (SelectOrderBy o : orderByList) {\n+        buff.appendExceptFirst(\", \");\n+        buff.append(o.expression.getSQL());\n+        SortOrder.typeToString(buff.builder(), o.sortType);\n+      }\n+    }\n+    buff.append(')');\n+    if (filterCondition != null) {\n+      buff.append(\" FILTER (WHERE \").append(filterCondition.getSQL()).append(')');\n+    }\n+    return buff.toString();\n+  }\n+\n+  @Override\n+  public String getSQL() {\n+    String text;\n+    switch (type) {\n+      case GROUP_CONCAT:\n+        return getSQLGroupConcat();\n+      case COUNT_ALL:\n+        return \"COUNT(*)\";\n+      case COUNT:\n+        text = \"COUNT\";\n+        break;\n+      case SELECTIVITY:\n+        text = \"SELECTIVITY\";\n+        break;\n+      case HISTOGRAM:\n+        text = \"HISTOGRAM\";\n+        break;\n+      case SUM:\n+        text = \"SUM\";\n+        break;\n+      case MIN:\n+        text = \"MIN\";\n+        break;\n+      case MAX:\n+        text = \"MAX\";\n+        break;\n+      case AVG:\n+        text = \"AVG\";\n+        break;\n+      case STDDEV_POP:\n+        text = \"STDDEV_POP\";\n+        break;\n+      case STDDEV_SAMP:\n+        text = \"STDDEV_SAMP\";\n+        break;\n+      case VAR_POP:\n+        text = \"VAR_POP\";\n+        break;\n+      case VAR_SAMP:\n+        text = \"VAR_SAMP\";\n+        break;\n+      case BOOL_AND:\n+        text = \"BOOL_AND\";\n+        break;\n+      case BOOL_OR:\n+        text = \"BOOL_OR\";\n+        break;\n+      case BIT_AND:\n+        text = \"BIT_AND\";\n+        break;\n+      case BIT_OR:\n+        text = \"BIT_OR\";\n+        break;\n+      case MEDIAN:\n+        text = \"MEDIAN\";\n+        break;\n+      case ARRAY_AGG:\n+        return getSQLArrayAggregate();\n+      default:\n+        throw DbException.throwInternalError(\"type=\" + type);\n     }\n+    if (distinct) {\n+      text += \"(DISTINCT \" + on.getSQL() + ')';\n+    } else {\n+      text += StringUtils.enclose(on.getSQL());\n+    }\n+    if (filterCondition != null) {\n+      text += \" FILTER (WHERE \" + filterCondition.getSQL() + ')';\n+    }\n+    return text;\n+  }\n+\n+  private Index getMinMaxColumnIndex() {\n+    if (on instanceof ExpressionColumn) {\n+      ExpressionColumn col = (ExpressionColumn) on;\n+      Column column = col.getColumn();\n+      TableFilter filter = col.getTableFilter();\n+      if (filter != null) {\n+        Table table = filter.getTable();\n+        return table.getIndexForColumn(column, true, false);\n+      }\n+    }\n+    return null;\n+  }\n \n-    @Override\n-    public String getSQL() {\n-        String text;\n-        switch (type) {\n-        case GROUP_CONCAT:\n-            return getSQLGroupConcat();\n-        case COUNT_ALL:\n-            return \"COUNT(*)\";\n+  @Override\n+  public boolean isEverything(ExpressionVisitor visitor) {\n+    if (filterCondition != null && !filterCondition.isEverything(visitor)) {\n+      return false;\n+    }\n+    if (visitor.getType() == ExpressionVisitor.OPTIMIZABLE_MIN_MAX_COUNT_ALL) {\n+      switch (type) {\n         case COUNT:\n-            text = \"COUNT\";\n-            break;\n-        case SELECTIVITY:\n-            text = \"SELECTIVITY\";\n-            break;\n-        case HISTOGRAM:\n-            text = \"HISTOGRAM\";\n-            break;\n-        case SUM:\n-            text = \"SUM\";\n-            break;\n+          if (!distinct && on.getNullable() == Column.NOT_NULLABLE) {\n+            return visitor.getTable().canGetRowCount();\n+          }\n+          return false;\n+        case COUNT_ALL:\n+          return visitor.getTable().canGetRowCount();\n         case MIN:\n-            text = \"MIN\";\n-            break;\n         case MAX:\n-            text = \"MAX\";\n-            break;\n-        case AVG:\n-            text = \"AVG\";\n-            break;\n-        case STDDEV_POP:\n-            text = \"STDDEV_POP\";\n-            break;\n-        case STDDEV_SAMP:\n-            text = \"STDDEV_SAMP\";\n-            break;\n-        case VAR_POP:\n-            text = \"VAR_POP\";\n-            break;\n-        case VAR_SAMP:\n-            text = \"VAR_SAMP\";\n-            break;\n-        case BOOL_AND:\n-            text = \"BOOL_AND\";\n-            break;\n-        case BOOL_OR:\n-            text = \"BOOL_OR\";\n-            break;\n-        case BIT_AND:\n-            text = \"BIT_AND\";\n-            break;\n-        case BIT_OR:\n-            text = \"BIT_OR\";\n-            break;\n+          Index index = getMinMaxColumnIndex();\n+          return index != null;\n         case MEDIAN:\n-            text = \"MEDIAN\";\n-            break;\n-        case ARRAY_AGG:\n-            return getSQLArrayAggregate();\n+          if (distinct) {\n+            return false;\n+          }\n+          return AggregateDataMedian.getMedianColumnIndex(on) != null;\n         default:\n-            throw DbException.throwInternalError(\"type=\" + type);\n-        }\n-        if (distinct) {\n-            text += \"(DISTINCT \" + on.getSQL() + ')';\n-        } else {\n-            text += StringUtils.enclose(on.getSQL());\n-        }\n-        if (filterCondition != null) {\n-            text += \" FILTER (WHERE \" + filterCondition.getSQL() + ')';\n-        }\n-        return text;\n-    }\n-\n-    private Index getMinMaxColumnIndex() {\n-        if (on instanceof ExpressionColumn) {\n-            ExpressionColumn col = (ExpressionColumn) on;\n-            Column column = col.getColumn();\n-            TableFilter filter = col.getTableFilter();\n-            if (filter != null) {\n-                Table table = filter.getTable();\n-                return table.getIndexForColumn(column, true, false);\n-            }\n-        }\n-        return null;\n+          return false;\n+      }\n     }\n-\n-    @Override\n-    public boolean isEverything(ExpressionVisitor visitor) {\n-        if (filterCondition != null && !filterCondition.isEverything(visitor)) {\n-            return false;\n-        }\n-        if (visitor.getType() == ExpressionVisitor.OPTIMIZABLE_MIN_MAX_COUNT_ALL) {\n-            switch (type) {\n-            case COUNT:\n-                if (!distinct && on.getNullable() == Column.NOT_NULLABLE) {\n-                    return visitor.getTable().canGetRowCount();\n-                }\n-                return false;\n-            case COUNT_ALL:\n-                return visitor.getTable().canGetRowCount();\n-            case MIN:\n-            case MAX:\n-                Index index = getMinMaxColumnIndex();\n-                return index != null;\n-            case MEDIAN:\n-                if (distinct) {\n-                    return false;\n-                }\n-                return AggregateDataMedian.getMedianColumnIndex(on) != null;\n-            default:\n-                return false;\n-            }\n-        }\n-        if (on != null && !on.isEverything(visitor)) {\n-            return false;\n-        }\n-        if (groupConcatSeparator != null &&\n-                !groupConcatSeparator.isEverything(visitor)) {\n-            return false;\n-        }\n-        if (orderByList != null) {\n-            for (SelectOrderBy o : orderByList) {\n-                if (!o.expression.isEverything(visitor)) {\n-                    return false;\n-                }\n-            }\n-        }\n-        return true;\n+    if (on != null && !on.isEverything(visitor)) {\n+      return false;\n     }\n-\n-    @Override\n-    public int getCost() {\n-        int cost = 1;\n-        if (on != null) {\n-            cost += on.getCost();\n-        }\n-        if (filterCondition != null) {\n-            cost += filterCondition.getCost();\n+    if (groupConcatSeparator != null &&\n+        !groupConcatSeparator.isEverything(visitor)) {\n+      return false;\n+    }\n+    if (orderByList != null) {\n+      for (SelectOrderBy o : orderByList) {\n+        if (!o.expression.isEverything(visitor)) {\n+          return false;\n         }\n-        return cost;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public int getCost() {\n+    int cost = 1;\n+    if (on != null) {\n+      cost += on.getCost();\n+    }\n+    if (filterCondition != null) {\n+      cost += filterCondition.getCost();\n     }\n+    return cost;\n+  }\n \n }\n",
            "diff_size": 1037
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "372",
                    "column": "44",
                    "severity": "warning",
                    "message": "'typecast' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAfterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/77/Aggregate.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/naturalize/77/Aggregate.java\nindex c1adc190471..b9ad0b857d2 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/77/Aggregate.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/naturalize/77/Aggregate.java\n@@ -40,7 +40,8 @@ import org.h2.value.ValueString;\n public class Aggregate extends Expression {\n \n     public enum AggregateType {\n-        /**\n+\n+    /**\n          * The aggregate type for COUNT(*).\n          */\n         COUNT_ALL,\n@@ -129,7 +130,8 @@ public class Aggregate extends Expression {\n          * The aggregate type for MEDIAN(expression).\n          */\n         MEDIAN,\n-        /**\n+\n+/**\n          * The aggregate type for ARRAY_AGG(expression).\n          */\n         ARRAY_AGG\n@@ -756,4 +758,4 @@ public class Aggregate extends Expression {\n         return cost;\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 5
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/77/Aggregate.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/codebuff/77/Aggregate.java\nindex c1adc190471..8e5bcfe7866 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/77/Aggregate.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/codebuff/77/Aggregate.java\n@@ -37,8 +37,11 @@ import org.h2.value.ValueString;\n /**\n  * Implements the integrated aggregate functions, such as COUNT, MAX, SUM.\n  */\n+\n+\n public class Aggregate extends Expression {\n \n+\n     public enum AggregateType {\n         /**\n          * The aggregate type for COUNT(*).\n@@ -48,99 +51,115 @@ public class Aggregate extends Expression {\n         /**\n          * The aggregate type for COUNT(expression).\n          */\n+\n         COUNT,\n \n         /**\n          * The aggregate type for GROUP_CONCAT(...).\n          */\n+\n         GROUP_CONCAT,\n \n         /**\n          * The aggregate type for SUM(expression).\n          */\n+\n         SUM,\n \n         /**\n          * The aggregate type for MIN(expression).\n          */\n+\n         MIN,\n \n         /**\n          * The aggregate type for MAX(expression).\n          */\n+\n         MAX,\n \n         /**\n          * The aggregate type for AVG(expression).\n          */\n+\n         AVG,\n \n         /**\n          * The aggregate type for STDDEV_POP(expression).\n          */\n+\n         STDDEV_POP,\n \n         /**\n          * The aggregate type for STDDEV_SAMP(expression).\n          */\n+\n         STDDEV_SAMP,\n \n         /**\n          * The aggregate type for VAR_POP(expression).\n          */\n+\n         VAR_POP,\n \n         /**\n          * The aggregate type for VAR_SAMP(expression).\n          */\n+\n         VAR_SAMP,\n \n         /**\n          * The aggregate type for BOOL_OR(expression).\n          */\n+\n         BOOL_OR,\n \n         /**\n          * The aggregate type for BOOL_AND(expression).\n          */\n+\n         BOOL_AND,\n \n         /**\n          * The aggregate type for BOOL_OR(expression).\n          */\n+\n         BIT_OR,\n \n         /**\n          * The aggregate type for BOOL_AND(expression).\n          */\n+\n         BIT_AND,\n \n         /**\n          * The aggregate type for SELECTIVITY(expression).\n          */\n+\n         SELECTIVITY,\n \n         /**\n          * The aggregate type for HISTOGRAM(expression).\n          */\n+\n         HISTOGRAM,\n \n         /**\n          * The aggregate type for MEDIAN(expression).\n          */\n+\n         MEDIAN,\n         /**\n          * The aggregate type for ARRAY_AGG(expression).\n          */\n+\n         ARRAY_AGG\n     }\n \n-    private static final HashMap<String, AggregateType> AGGREGATES = new HashMap<>(64);\n-\n+    private static final HashMap<String, AggregateType> AGGREGATES = new HashMap< >(64);\n     private final AggregateType type;\n     private final Select select;\n     private final boolean distinct;\n-\n     private Expression on;\n     private Expression groupConcatSeparator;\n     private ArrayList<SelectOrderBy> orderByList;\n@@ -149,7 +168,6 @@ public class Aggregate extends Expression {\n     private long precision;\n     private int displaySize;\n     private int lastGroupRowId;\n-\n     private Expression filterCondition;\n \n     /**\n@@ -160,7 +178,10 @@ public class Aggregate extends Expression {\n      * @param select the select statement\n      * @param distinct if distinct is used\n      */\n-    public Aggregate(AggregateType type, Expression on, Select select, boolean distinct) {\n+\n+    public Aggregate(AggregateType type,\n+        Expression on,\n+            Select select, boolean distinct) {\n         this.type = type;\n         this.on = on;\n         this.select = select;\n@@ -213,6 +234,8 @@ public class Aggregate extends Expression {\n      * @param name the aggregate function name\n      * @return null if no aggregate function has been found, or the aggregate type\n      */\n+\n+\n     public static AggregateType getAggregateType(String name) {\n         return AGGREGATES.get(name);\n     }\n@@ -222,6 +245,8 @@ public class Aggregate extends Expression {\n      *\n      * @param orderByList the order by list\n      */\n+\n+\n     public void setOrderByList(ArrayList<SelectOrderBy> orderByList) {\n         this.orderByList = orderByList;\n     }\n@@ -231,6 +256,8 @@ public class Aggregate extends Expression {\n      *\n      * @param separator the separator expression\n      */\n+\n+\n     public void setGroupConcatSeparator(Expression separator) {\n         this.groupConcatSeparator = separator;\n     }\n@@ -240,6 +267,8 @@ public class Aggregate extends Expression {\n      *\n      * @param filterCondition condition\n      */\n+\n+\n     public void setFilterCondition(Expression filterCondition) {\n         this.filterCondition = filterCondition;\n     }\n@@ -260,10 +289,10 @@ public class Aggregate extends Expression {\n         final SortOrder sortOrder = orderBySort;\n         if (sortOrder != null) {\n             Arrays.sort(array, new Comparator<Value>() {\n-                @Override\n-                public int compare(Value v1, Value v2) {\n-                    return sortOrder.compare(((ValueArray) v1).getList(), ((ValueArray) v2).getList());\n-                }\n+                                              @Override\n+                                              public int compare(Value v1, Value v2) {\n+                                                  return sortOrder.compare(((ValueArray) v1).getList(), ((ValueArray) v2).getList());\n+                                              }\n             });\n         } else {\n             Arrays.sort(array, select.getSession().getDatabase().getCompareMode());\n@@ -280,14 +309,12 @@ public class Aggregate extends Expression {\n             // this is a different level (the enclosing query)\n             return;\n         }\n-\n         int groupRowId = select.getCurrentGroupRowId();\n         if (lastGroupRowId == groupRowId) {\n             // already visited\n             return;\n         }\n         lastGroupRowId = groupRowId;\n-\n         AggregateData data = (AggregateData) select.getCurrentGroupExprData(this);\n         if (data == null) {\n             data = AggregateData.create(type);\n@@ -367,7 +394,7 @@ public class Aggregate extends Expression {\n         if (!select.isCurrentGroup()) {\n             throw DbException.get(ErrorCode.INVALID_USE_OF_AGGREGATE_FUNCTION_1, getSQL());\n         }\n-        AggregateData data = (AggregateData)select.getCurrentGroupExprData(this);\n+        AggregateData data = (AggregateData) select.getCurrentGroupExprData(this);\n         if (data == null) {\n             data = AggregateData.create(type);\n             select.setCurrentGroupExprData(this, data);\n@@ -381,8 +408,7 @@ public class Aggregate extends Expression {\n                 sortWithOrderBy(array);\n             }\n             StatementBuilder buff = new StatementBuilder();\n-            String sep = groupConcatSeparator == null ?\n-                    \",\" : groupConcatSeparator.getValue(session).getString();\n+            String sep = groupConcatSeparator == null ? \",\" : groupConcatSeparator.getValue(session).getString();\n             for (Value val : array) {\n                 String s;\n                 if (val.getType() == Value.ARRAY) {\n@@ -491,7 +517,7 @@ public class Aggregate extends Expression {\n                 dataType = Value.LONG;\n             } else if (!DataType.supportsAdd(dataType)) {\n                 throw DbException.get(ErrorCode.SUM_OR_AVG_ON_WRONG_DATATYPE_1, getSQL());\n-            } else {\n+        } else {\n                 dataType = DataType.getAddProofType(dataType);\n             }\n             break;\n@@ -730,8 +756,7 @@ public class Aggregate extends Expression {\n         if (on != null && !on.isEverything(visitor)) {\n             return false;\n         }\n-        if (groupConcatSeparator != null &&\n-                !groupConcatSeparator.isEverything(visitor)) {\n+        if (groupConcatSeparator != null && !groupConcatSeparator.isEverything(visitor)) {\n             return false;\n         }\n         if (orderByList != null) {\n@@ -756,4 +781,4 @@ public class Aggregate extends Expression {\n         return cost;\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 50
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/77/Aggregate.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_random/77/Aggregate.java\nindex c1adc190471..32a183bd055 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/77/Aggregate.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_random/77/Aggregate.java\n@@ -367,7 +367,7 @@ public class Aggregate extends Expression {\n         if (!select.isCurrentGroup()) {\n             throw DbException.get(ErrorCode.INVALID_USE_OF_AGGREGATE_FUNCTION_1, getSQL());\n         }\n-        AggregateData data = (AggregateData)select.getCurrentGroupExprData(this);\n+        AggregateData data = (AggregateData) select.getCurrentGroupExprData(this);\n         if (data == null) {\n             data = AggregateData.create(type);\n             select.setCurrentGroupExprData(this, data);\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/77/Aggregate.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/77/Aggregate.java\nindex c1adc190471..32a183bd055 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/77/Aggregate.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/77/Aggregate.java\n@@ -367,7 +367,7 @@ public class Aggregate extends Expression {\n         if (!select.isCurrentGroup()) {\n             throw DbException.get(ErrorCode.INVALID_USE_OF_AGGREGATE_FUNCTION_1, getSQL());\n         }\n-        AggregateData data = (AggregateData)select.getCurrentGroupExprData(this);\n+        AggregateData data = (AggregateData) select.getCurrentGroupExprData(this);\n         if (data == null) {\n             data = AggregateData.create(type);\n             select.setCurrentGroupExprData(this, data);\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "naturalize"
    ]
}