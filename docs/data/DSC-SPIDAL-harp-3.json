{
    "project_name": "DSC-SPIDAL-harp",
    "error_id": "3",
    "information": {
        "errors": [
            {
                "line": "3",
                "severity": "error",
                "message": "Line has trailing spaces.",
                "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
            }
        ]
    },
    "source_code": "/*\n * Copyright 2013-2017 Indiana University\n * \n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "3",
                    "severity": "error",
                    "message": "Line has trailing spaces.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DSC-SPIDAL-harp/errored/1/3/KMeansCollectiveMapper.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DSC-SPIDAL-harp/intellij/3/KMeansCollectiveMapper.java\nindex 9de03b7dfa5..120a110a589 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DSC-SPIDAL-harp/errored/1/3/KMeansCollectiveMapper.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DSC-SPIDAL-harp/intellij/3/KMeansCollectiveMapper.java\n@@ -1,6 +1,6 @@\n /*\r\n  * Copyright 2013-2017 Indiana University\r\n- * \r\n+ *\r\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  * you may not use this file except in compliance with the License.\r\n  * You may obtain a copy of the License at\r\n@@ -35,237 +35,237 @@ import java.util.concurrent.BlockingQueue;\n import java.util.concurrent.LinkedBlockingQueue;\r\n \r\n public class KMeansCollectiveMapper extends\r\n-  CollectiveMapper<String, String, Object, Object> {\r\n-\r\n-  private int pointsPerFile;\r\n-  private int numCentroids;\r\n-  private int vectorSize;\r\n-  private int numCenPars;\r\n-  private int cenVecSize;\r\n-  private int numMappers;\r\n-  private int numThreads;\r\n-  private int numIterations;\r\n-  private String cenDir;\r\n+    CollectiveMapper<String, String, Object, Object> {\r\n \r\n-  /**\r\n-   * Mapper configuration.\r\n-   */\r\n-  @Override\r\n-  protected void setup(Context context)\r\n-    throws IOException, InterruptedException {\r\n-    long startTime = System.currentTimeMillis();\r\n-    Configuration configuration =\r\n-      context.getConfiguration();\r\n-    pointsPerFile = configuration\r\n-      .getInt(Constants.POINTS_PER_FILE, 20);\r\n-    numCentroids = configuration\r\n-      .getInt(Constants.NUM_CENTROIDS, 20);\r\n-    vectorSize = configuration\r\n-      .getInt(Constants.VECTOR_SIZE, 20);\r\n-    numMappers = configuration\r\n-      .getInt(Constants.NUM_MAPPERS, 10);\r\n-    numCenPars = numMappers;\r\n-    cenVecSize = vectorSize + 1;\r\n-    numThreads = configuration\r\n-      .getInt(Constants.NUM_THREADS, 10);\r\n-    numIterations = configuration\r\n-      .getInt(Constants.NUM_ITERATIONS, 10);\r\n-    cenDir = configuration.get(Constants.CEN_DIR);\r\n-    LOG.info(\"Points Per File \" + pointsPerFile);\r\n-    LOG.info(\"Num Centroids \" + numCentroids);\r\n-    LOG.info(\"Vector Size \" + vectorSize);\r\n-    LOG.info(\"Num Mappers \" + numMappers);\r\n-    LOG.info(\"Num Threads \" + numThreads);\r\n-    LOG.info(\"Num Iterations \" + numIterations);\r\n-    LOG.info(\"Cen Dir \" + cenDir);\r\n-    long endTime = System.currentTimeMillis();\r\n-    LOG.info(\r\n-      \"config (ms) :\" + (endTime - startTime));\r\n-  }\r\n+    private int pointsPerFile;\r\n+    private int numCentroids;\r\n+    private int vectorSize;\r\n+    private int numCenPars;\r\n+    private int cenVecSize;\r\n+    private int numMappers;\r\n+    private int numThreads;\r\n+    private int numIterations;\r\n+    private String cenDir;\r\n \r\n-  protected void mapCollective(\r\n-    KeyValReader reader, Context context)\r\n-    throws IOException, InterruptedException {\r\n-    long startTime = System.currentTimeMillis();\r\n-    List<String> pointFiles =\r\n-      new LinkedList<String>();\r\n-    while (reader.nextKeyValue()) {\r\n-      String key = reader.getCurrentKey();\r\n-      String value = reader.getCurrentValue();\r\n-      LOG.info(\r\n-        \"Key: \" + key + \", Value: \" + value);\r\n-      pointFiles.add(value);\r\n+    /**\r\n+     * Mapper configuration.\r\n+     */\r\n+    @Override\r\n+    protected void setup(Context context)\r\n+        throws IOException, InterruptedException {\r\n+        long startTime = System.currentTimeMillis();\r\n+        Configuration configuration =\r\n+            context.getConfiguration();\r\n+        pointsPerFile = configuration\r\n+            .getInt(Constants.POINTS_PER_FILE, 20);\r\n+        numCentroids = configuration\r\n+            .getInt(Constants.NUM_CENTROIDS, 20);\r\n+        vectorSize = configuration\r\n+            .getInt(Constants.VECTOR_SIZE, 20);\r\n+        numMappers = configuration\r\n+            .getInt(Constants.NUM_MAPPERS, 10);\r\n+        numCenPars = numMappers;\r\n+        cenVecSize = vectorSize + 1;\r\n+        numThreads = configuration\r\n+            .getInt(Constants.NUM_THREADS, 10);\r\n+        numIterations = configuration\r\n+            .getInt(Constants.NUM_ITERATIONS, 10);\r\n+        cenDir = configuration.get(Constants.CEN_DIR);\r\n+        LOG.info(\"Points Per File \" + pointsPerFile);\r\n+        LOG.info(\"Num Centroids \" + numCentroids);\r\n+        LOG.info(\"Vector Size \" + vectorSize);\r\n+        LOG.info(\"Num Mappers \" + numMappers);\r\n+        LOG.info(\"Num Threads \" + numThreads);\r\n+        LOG.info(\"Num Iterations \" + numIterations);\r\n+        LOG.info(\"Cen Dir \" + cenDir);\r\n+        long endTime = System.currentTimeMillis();\r\n+        LOG.info(\r\n+            \"config (ms) :\" + (endTime - startTime));\r\n     }\r\n-    Configuration conf =\r\n-      context.getConfiguration();\r\n-    runKmeans(pointFiles, conf, context);\r\n-    LOG.info(\"Total iterations in master view: \"\r\n-      + (System.currentTimeMillis() - startTime));\r\n-  }\r\n \r\n-  private void runKmeans(List<String> fileNames,\r\n-    Configuration conf, Context context)\r\n-    throws IOException {\r\n-    // Load data points\r\n-    List<double[]> pointArrays =\r\n-      KMUtil.loadPoints(fileNames, pointsPerFile,\r\n-        cenVecSize, conf, numThreads);\r\n-    // Create related data structure for holding\r\n-    // the nearest centroid partition+offset and\r\n-    // the distance\r\n-    BlockingQueue<Points> pointsList =\r\n-      new LinkedBlockingQueue<>();\r\n-    pointArrays.parallelStream().forEach(e -> {\r\n-      Points points = new Points();\r\n-      int numPoints = e.length / cenVecSize;\r\n-      points.pointArray = e;\r\n-      points.cenIDs = new int[numPoints][2];\r\n-      pointsList.add(points);\r\n-    });\r\n-    // Generate centroids\r\n-    Table<DoubleArray> cenTable =\r\n-      new Table<>(0, new DoubleArrPlus());\r\n-    generateCenTable(cenTable, numCentroids,\r\n-      numCenPars, cenVecSize);\r\n-    // Initialize tasks\r\n-    List<ExpTask> expTasks = new LinkedList<>();\r\n-    for (int i = 0; i < numThreads; i++) {\r\n-      expTasks\r\n-        .add(new ExpTask(cenTable, cenVecSize));\r\n-    }\r\n-    DynamicScheduler<Points, Object, ExpTask> expCompute =\r\n-      new DynamicScheduler<>(expTasks);\r\n-    List<MaxTask> maxTasks = new LinkedList<>();\r\n-    for (int i = 0; i < numThreads; i++) {\r\n-      maxTasks.add(new MaxTask(pointsList,\r\n-        cenTable, cenVecSize));\r\n-    }\r\n-    DynamicScheduler<CenPair, Object, MaxTask> maxCompute =\r\n-      new DynamicScheduler<>(maxTasks);\r\n-    expCompute.start();\r\n-    maxCompute.start();\r\n-    // ----------------------------------------------------\r\n-    // For iterations\r\n-    for (int i = 0; i < numIterations; i++) {\r\n-      // LOG.info(\"Iteration: \" + i);\r\n-      // Expectation\r\n-      long t1 = System.currentTimeMillis();\r\n-      for (int j = 0; j < this\r\n-        .getNumWorkers(); j++) {\r\n-        // LOG.info(\"Expectation Round: \" + j);\r\n-        for (ExpTask task : expCompute\r\n-          .getTasks()) {\r\n-          task.update();\r\n-        }\r\n-        expCompute.submitAll(pointsList);\r\n-        while (expCompute.hasOutput()) {\r\n-          expCompute.waitForOutput();\r\n+    protected void mapCollective(\r\n+        KeyValReader reader, Context context)\r\n+        throws IOException, InterruptedException {\r\n+        long startTime = System.currentTimeMillis();\r\n+        List<String> pointFiles =\r\n+            new LinkedList<String>();\r\n+        while (reader.nextKeyValue()) {\r\n+            String key = reader.getCurrentKey();\r\n+            String value = reader.getCurrentValue();\r\n+            LOG.info(\r\n+                \"Key: \" + key + \", Value: \" + value);\r\n+            pointFiles.add(value);\r\n         }\r\n-        this.rotate(\"kmeans\",\r\n-          \"exp-rotate-\" + i + \"-\" + j, cenTable,\r\n-          null);\r\n-      }\r\n-      long t2 = System.currentTimeMillis();\r\n-      // Clean centroids\r\n-      cenTable.getPartitions().parallelStream()\r\n-        .forEach(e -> {\r\n-          Arrays.fill(e.get().get(), 0.0);\r\n+        Configuration conf =\r\n+            context.getConfiguration();\r\n+        runKmeans(pointFiles, conf, context);\r\n+        LOG.info(\"Total iterations in master view: \"\r\n+            + (System.currentTimeMillis() - startTime));\r\n+    }\r\n+\r\n+    private void runKmeans(List<String> fileNames,\r\n+                           Configuration conf, Context context)\r\n+        throws IOException {\r\n+        // Load data points\r\n+        List<double[]> pointArrays =\r\n+            KMUtil.loadPoints(fileNames, pointsPerFile,\r\n+                cenVecSize, conf, numThreads);\r\n+        // Create related data structure for holding\r\n+        // the nearest centroid partition+offset and\r\n+        // the distance\r\n+        BlockingQueue<Points> pointsList =\r\n+            new LinkedBlockingQueue<>();\r\n+        pointArrays.parallelStream().forEach(e -> {\r\n+            Points points = new Points();\r\n+            int numPoints = e.length / cenVecSize;\r\n+            points.pointArray = e;\r\n+            points.cenIDs = new int[numPoints][2];\r\n+            pointsList.add(points);\r\n         });\r\n-      // Maximization\r\n-      for (int j = 0; j < this\r\n-        .getNumWorkers(); j++) {\r\n-        // LOG.info(\"Maximization Round: \" + j);\r\n-        for (Partition<DoubleArray> partition : cenTable\r\n-          .getPartitions()) {\r\n-          int id = partition.id();\r\n-          int size = partition.get().size();\r\n-          for (int k = 0; k < size; k +=\r\n-            cenVecSize) {\r\n-            maxCompute.submit(new CenPair(id, k));\r\n-          }\r\n+        // Generate centroids\r\n+        Table<DoubleArray> cenTable =\r\n+            new Table<>(0, new DoubleArrPlus());\r\n+        generateCenTable(cenTable, numCentroids,\r\n+            numCenPars, cenVecSize);\r\n+        // Initialize tasks\r\n+        List<ExpTask> expTasks = new LinkedList<>();\r\n+        for (int i = 0; i < numThreads; i++) {\r\n+            expTasks\r\n+                .add(new ExpTask(cenTable, cenVecSize));\r\n         }\r\n-        while (maxCompute.hasOutput()) {\r\n-          maxCompute.waitForOutput();\r\n+        DynamicScheduler<Points, Object, ExpTask> expCompute =\r\n+            new DynamicScheduler<>(expTasks);\r\n+        List<MaxTask> maxTasks = new LinkedList<>();\r\n+        for (int i = 0; i < numThreads; i++) {\r\n+            maxTasks.add(new MaxTask(pointsList,\r\n+                cenTable, cenVecSize));\r\n         }\r\n-        this.rotate(\"kmeans\",\r\n-          \"max-rotate-\" + i + \"-\" + j, cenTable,\r\n-          null);\r\n-      }\r\n-      long t3 = System.currentTimeMillis();\r\n-      for (Partition<DoubleArray> partition : cenTable\r\n-        .getPartitions()) {\r\n-        double[] doubles = partition.get().get();\r\n-        int size = partition.get().size();\r\n-        for (int j = 0; j < size; j +=\r\n-          cenVecSize) {\r\n-          for (int k = 1; k < cenVecSize; k++) {\r\n-            // Calculate avg\r\n-            if (doubles[j] != 0) {\r\n-              doubles[j + k] /= doubles[j];\r\n+        DynamicScheduler<CenPair, Object, MaxTask> maxCompute =\r\n+            new DynamicScheduler<>(maxTasks);\r\n+        expCompute.start();\r\n+        maxCompute.start();\r\n+        // ----------------------------------------------------\r\n+        // For iterations\r\n+        for (int i = 0; i < numIterations; i++) {\r\n+            // LOG.info(\"Iteration: \" + i);\r\n+            // Expectation\r\n+            long t1 = System.currentTimeMillis();\r\n+            for (int j = 0; j < this\r\n+                .getNumWorkers(); j++) {\r\n+                // LOG.info(\"Expectation Round: \" + j);\r\n+                for (ExpTask task : expCompute\r\n+                    .getTasks()) {\r\n+                    task.update();\r\n+                }\r\n+                expCompute.submitAll(pointsList);\r\n+                while (expCompute.hasOutput()) {\r\n+                    expCompute.waitForOutput();\r\n+                }\r\n+                this.rotate(\"kmeans\",\r\n+                    \"exp-rotate-\" + i + \"-\" + j, cenTable,\r\n+                    null);\r\n+            }\r\n+            long t2 = System.currentTimeMillis();\r\n+            // Clean centroids\r\n+            cenTable.getPartitions().parallelStream()\r\n+                .forEach(e -> {\r\n+                    Arrays.fill(e.get().get(), 0.0);\r\n+                });\r\n+            // Maximization\r\n+            for (int j = 0; j < this\r\n+                .getNumWorkers(); j++) {\r\n+                // LOG.info(\"Maximization Round: \" + j);\r\n+                for (Partition<DoubleArray> partition : cenTable\r\n+                    .getPartitions()) {\r\n+                    int id = partition.id();\r\n+                    int size = partition.get().size();\r\n+                    for (int k = 0; k < size; k +=\r\n+                        cenVecSize) {\r\n+                        maxCompute.submit(new CenPair(id, k));\r\n+                    }\r\n+                }\r\n+                while (maxCompute.hasOutput()) {\r\n+                    maxCompute.waitForOutput();\r\n+                }\r\n+                this.rotate(\"kmeans\",\r\n+                    \"max-rotate-\" + i + \"-\" + j, cenTable,\r\n+                    null);\r\n+            }\r\n+            long t3 = System.currentTimeMillis();\r\n+            for (Partition<DoubleArray> partition : cenTable\r\n+                .getPartitions()) {\r\n+                double[] doubles = partition.get().get();\r\n+                int size = partition.get().size();\r\n+                for (int j = 0; j < size; j +=\r\n+                    cenVecSize) {\r\n+                    for (int k = 1; k < cenVecSize; k++) {\r\n+                        // Calculate avg\r\n+                        if (doubles[j] != 0) {\r\n+                            doubles[j + k] /= doubles[j];\r\n+                        }\r\n+                    }\r\n+                }\r\n             }\r\n-          }\r\n+            long t4 = System.currentTimeMillis();\r\n+            LOG.info(\"Expectation: \" + (t2 - t1)\r\n+                + \", Maximization: \" + (t3 - t2)\r\n+                + \", Averging: \" + (t4 - t3));\r\n+            logMemUsage();\r\n+            logGCTime();\r\n+            context.progress();\r\n         }\r\n-      }\r\n-      long t4 = System.currentTimeMillis();\r\n-      LOG.info(\"Expectation: \" + (t2 - t1)\r\n-        + \", Maximization: \" + (t3 - t2)\r\n-        + \", Averging: \" + (t4 - t3));\r\n-      logMemUsage();\r\n-      logGCTime();\r\n-      context.progress();\r\n+        expCompute.stop();\r\n+        maxCompute.stop();\r\n+        // Write out centroids\r\n+        LOG.info(\"Start to write out centroids.\");\r\n+        long startTime = System.currentTimeMillis();\r\n+        KMUtil.storeCentroids(conf, cenDir, cenTable,\r\n+            cenVecSize, this.getSelfID() + \"\");\r\n+        long endTime = System.currentTimeMillis();\r\n+        LOG.info(\"Store centroids time (ms): \"\r\n+            + (endTime - startTime));\r\n+        cenTable.release();\r\n     }\r\n-    expCompute.stop();\r\n-    maxCompute.stop();\r\n-    // Write out centroids\r\n-    LOG.info(\"Start to write out centroids.\");\r\n-    long startTime = System.currentTimeMillis();\r\n-    KMUtil.storeCentroids(conf, cenDir, cenTable,\r\n-      cenVecSize, this.getSelfID() + \"\");\r\n-    long endTime = System.currentTimeMillis();\r\n-    LOG.info(\"Store centroids time (ms): \"\r\n-      + (endTime - startTime));\r\n-    cenTable.release();\r\n-  }\r\n \r\n-  private void generateCenTable(\r\n-    Table<DoubleArray> cenTable, int numCentroids,\r\n-    int numCenPartitions, int cenVecSize) {\r\n-    int selfID = this.getSelfID();\r\n-    int numWorkers = this.getNumWorkers();\r\n-    Random random =\r\n-      new Random(System.currentTimeMillis());\r\n-    int cenParSize =\r\n-      numCentroids / numCenPartitions;\r\n-    int cenRest = numCentroids % numCenPartitions;\r\n-    for (int i = 0; i < numCenPartitions; i++) {\r\n-      if (cenRest > 0) {\r\n-        int size = (cenParSize + 1) * cenVecSize;\r\n-        cenRest--;\r\n-        if (i % numWorkers == selfID) {\r\n-          DoubleArray array =\r\n-            DoubleArray.create(size, false);\r\n-          double[] doubles = array.get();\r\n-          for (int j = 0; j < size; j++) {\r\n-            doubles[j] =\r\n-              random.nextDouble() * 1000;\r\n-          }\r\n-          cenTable.addPartition(\r\n-            new Partition<>(i, array));\r\n-        }\r\n-      } else if (cenParSize > 0) {\r\n-        int size = cenParSize * cenVecSize;\r\n-        if (i % numWorkers == selfID) {\r\n-          DoubleArray array =\r\n-            DoubleArray.create(size, false);\r\n-          double[] doubles = array.get();\r\n-          for (int j = 0; j < size; j++) {\r\n-            doubles[j] =\r\n-              random.nextDouble() * 1000;\r\n-          }\r\n-          cenTable.addPartition(\r\n-            new Partition<>(i, array));\r\n+    private void generateCenTable(\r\n+        Table<DoubleArray> cenTable, int numCentroids,\r\n+        int numCenPartitions, int cenVecSize) {\r\n+        int selfID = this.getSelfID();\r\n+        int numWorkers = this.getNumWorkers();\r\n+        Random random =\r\n+            new Random(System.currentTimeMillis());\r\n+        int cenParSize =\r\n+            numCentroids / numCenPartitions;\r\n+        int cenRest = numCentroids % numCenPartitions;\r\n+        for (int i = 0; i < numCenPartitions; i++) {\r\n+            if (cenRest > 0) {\r\n+                int size = (cenParSize + 1) * cenVecSize;\r\n+                cenRest--;\r\n+                if (i % numWorkers == selfID) {\r\n+                    DoubleArray array =\r\n+                        DoubleArray.create(size, false);\r\n+                    double[] doubles = array.get();\r\n+                    for (int j = 0; j < size; j++) {\r\n+                        doubles[j] =\r\n+                            random.nextDouble() * 1000;\r\n+                    }\r\n+                    cenTable.addPartition(\r\n+                        new Partition<>(i, array));\r\n+                }\r\n+            } else if (cenParSize > 0) {\r\n+                int size = cenParSize * cenVecSize;\r\n+                if (i % numWorkers == selfID) {\r\n+                    DoubleArray array =\r\n+                        DoubleArray.create(size, false);\r\n+                    double[] doubles = array.get();\r\n+                    for (int j = 0; j < size; j++) {\r\n+                        doubles[j] =\r\n+                            random.nextDouble() * 1000;\r\n+                    }\r\n+                    cenTable.addPartition(\r\n+                        new Partition<>(i, array));\r\n+                }\r\n+            }\r\n         }\r\n-      }\r\n     }\r\n-  }\r\n }\r\n",
            "diff_size": 323
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "3",
                    "severity": "error",
                    "message": "Line has trailing spaces.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DSC-SPIDAL-harp/errored/1/3/KMeansCollectiveMapper.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DSC-SPIDAL-harp/naturalize/3/KMeansCollectiveMapper.java\nindex 9de03b7dfa5..bd39dcd6b70 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DSC-SPIDAL-harp/errored/1/3/KMeansCollectiveMapper.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DSC-SPIDAL-harp/naturalize/3/KMeansCollectiveMapper.java\n@@ -150,8 +150,7 @@ public class KMeansCollectiveMapper extends\n       // LOG.info(\"Iteration: \" + i);\r\n       // Expectation\r\n       long t1 = System.currentTimeMillis();\r\n-      for (int j = 0; j < this\r\n-        .getNumWorkers(); j++) {\r\n+      for (int j = 0; j < this.getNumWorkers(); j++) {\r\n         // LOG.info(\"Expectation Round: \" + j);\r\n         for (ExpTask task : expCompute\r\n           .getTasks()) {\r\n@@ -172,8 +171,7 @@ public class KMeansCollectiveMapper extends\n           Arrays.fill(e.get().get(), 0.0);\r\n         });\r\n       // Maximization\r\n-      for (int j = 0; j < this\r\n-        .getNumWorkers(); j++) {\r\n+      for (int j = 0; j < this.getNumWorkers(); j++) {\r\n         // LOG.info(\"Maximization Round: \" + j);\r\n         for (Partition<DoubleArray> partition : cenTable\r\n           .getPartitions()) {\r\n@@ -207,8 +205,7 @@ public class KMeansCollectiveMapper extends\n         }\r\n       }\r\n       long t4 = System.currentTimeMillis();\r\n-      LOG.info(\"Expectation: \" + (t2 - t1)\r\n-        + \", Maximization: \" + (t3 - t2)\r\n+      LOG.info(\"Expectation: \" + (t2 - t1) + \", Maximization: \" + (t3 - t2)\r\n         + \", Averging: \" + (t4 - t3));\r\n       logMemUsage();\r\n       logGCTime();\r\n@@ -268,4 +265,4 @@ public class KMeansCollectiveMapper extends\n       }\r\n     }\r\n   }\r\n-}\r\n+}\n\\ No newline at end of file\n",
            "diff_size": 7
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "3",
                    "severity": "error",
                    "message": "Line has trailing spaces.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DSC-SPIDAL-harp/errored/1/3/KMeansCollectiveMapper.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DSC-SPIDAL-harp/codebuff/3/KMeansCollectiveMapper.java\nindex 9de03b7dfa5..28001d500a0 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DSC-SPIDAL-harp/errored/1/3/KMeansCollectiveMapper.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DSC-SPIDAL-harp/codebuff/3/KMeansCollectiveMapper.java\n@@ -14,258 +14,227 @@\n  * limitations under the License.\r\n  */\r\n \r\n-package edu.iu.kmeans.rotation;\r\n-\r\n-import edu.iu.harp.example.DoubleArrPlus;\r\n-import edu.iu.harp.partition.Partition;\r\n-import edu.iu.harp.partition.Table;\r\n-import edu.iu.harp.resource.DoubleArray;\r\n-import edu.iu.harp.schdynamic.DynamicScheduler;\r\n-import edu.iu.kmeans.regroupallgather.Constants;\r\n-import edu.iu.kmeans.regroupallgather.KMUtil;\r\n-import org.apache.hadoop.conf.Configuration;\r\n-import org.apache.hadoop.mapred.CollectiveMapper;\r\n-\r\n-import java.io.IOException;\r\n-import java.util.Arrays;\r\n-import java.util.LinkedList;\r\n-import java.util.List;\r\n-import java.util.Random;\r\n-import java.util.concurrent.BlockingQueue;\r\n-import java.util.concurrent.LinkedBlockingQueue;\r\n-\r\n-public class KMeansCollectiveMapper extends\r\n-  CollectiveMapper<String, String, Object, Object> {\r\n-\r\n-  private int pointsPerFile;\r\n-  private int numCentroids;\r\n-  private int vectorSize;\r\n-  private int numCenPars;\r\n-  private int cenVecSize;\r\n-  private int numMappers;\r\n-  private int numThreads;\r\n-  private int numIterations;\r\n+package edu.iu.kmeans.rotation;\n+\n+import edu.iu.harp.example.DoubleArrPlus;\n+import edu.iu.harp.partition.Partition;\n+import edu.iu.harp.partition.Table;\n+import edu.iu.harp.resource.DoubleArray;\n+import edu.iu.harp.schdynamic.DynamicScheduler;\n+import edu.iu.kmeans.regroupallgather.Constants;\n+import edu.iu.kmeans.regroupallgather.KMUtil;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.mapred.CollectiveMapper;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+\n+\n+public class KMeansCollectiveMapper extends\n+  CollectiveMapper<String, String, Object, Object> {\n+  private int pointsPerFile;\n+  private int numCentroids;\n+  private int vectorSize;\n+  private int numCenPars;\n+  private int cenVecSize;\n+  private int numMappers;\n+  private int numThreads;\n+  private int numIterations;\n   private String cenDir;\r\n \r\n   /**\r\n    * Mapper configuration.\r\n-   */\r\n-  @Override\r\n-  protected void setup(Context context)\r\n-    throws IOException, InterruptedException {\r\n-    long startTime = System.currentTimeMillis();\r\n-    Configuration configuration =\r\n-      context.getConfiguration();\r\n-    pointsPerFile = configuration\r\n-      .getInt(Constants.POINTS_PER_FILE, 20);\r\n-    numCentroids = configuration\r\n-      .getInt(Constants.NUM_CENTROIDS, 20);\r\n-    vectorSize = configuration\r\n-      .getInt(Constants.VECTOR_SIZE, 20);\r\n-    numMappers = configuration\r\n-      .getInt(Constants.NUM_MAPPERS, 10);\r\n-    numCenPars = numMappers;\r\n-    cenVecSize = vectorSize + 1;\r\n-    numThreads = configuration\r\n-      .getInt(Constants.NUM_THREADS, 10);\r\n-    numIterations = configuration\r\n-      .getInt(Constants.NUM_ITERATIONS, 10);\r\n-    cenDir = configuration.get(Constants.CEN_DIR);\r\n-    LOG.info(\"Points Per File \" + pointsPerFile);\r\n-    LOG.info(\"Num Centroids \" + numCentroids);\r\n-    LOG.info(\"Vector Size \" + vectorSize);\r\n-    LOG.info(\"Num Mappers \" + numMappers);\r\n-    LOG.info(\"Num Threads \" + numThreads);\r\n-    LOG.info(\"Num Iterations \" + numIterations);\r\n-    LOG.info(\"Cen Dir \" + cenDir);\r\n-    long endTime = System.currentTimeMillis();\r\n-    LOG.info(\r\n-      \"config (ms) :\" + (endTime - startTime));\r\n-  }\r\n-\r\n-  protected void mapCollective(\r\n-    KeyValReader reader, Context context)\r\n-    throws IOException, InterruptedException {\r\n-    long startTime = System.currentTimeMillis();\r\n-    List<String> pointFiles =\r\n-      new LinkedList<String>();\r\n-    while (reader.nextKeyValue()) {\r\n-      String key = reader.getCurrentKey();\r\n-      String value = reader.getCurrentValue();\r\n-      LOG.info(\r\n-        \"Key: \" + key + \", Value: \" + value);\r\n-      pointFiles.add(value);\r\n-    }\r\n-    Configuration conf =\r\n-      context.getConfiguration();\r\n-    runKmeans(pointFiles, conf, context);\r\n-    LOG.info(\"Total iterations in master view: \"\r\n-      + (System.currentTimeMillis() - startTime));\r\n-  }\r\n-\r\n-  private void runKmeans(List<String> fileNames,\r\n-    Configuration conf, Context context)\r\n-    throws IOException {\r\n-    // Load data points\r\n-    List<double[]> pointArrays =\r\n-      KMUtil.loadPoints(fileNames, pointsPerFile,\r\n-        cenVecSize, conf, numThreads);\r\n+   */\n+\n+  @Override\n+  protected void setup(Context context)\n+    throws IOException, InterruptedException {\n+    long startTime = System.currentTimeMillis();\n+    Configuration configuration = context.getConfiguration();\n+    pointsPerFile = configuration.getInt(Constants.POINTS_PER_FILE, 20);\n+    numCentroids = configuration.getInt(Constants.NUM_CENTROIDS, 20);\n+    vectorSize = configuration.getInt(Constants.VECTOR_SIZE, 20);\n+    numMappers = configuration.getInt(Constants.NUM_MAPPERS, 10);\n+    numCenPars = numMappers;\n+    cenVecSize = vectorSize + 1;\n+    numThreads = configuration.getInt(Constants.NUM_THREADS, 10);\n+    numIterations = configuration.getInt(Constants.NUM_ITERATIONS, 10);\n+    cenDir = configuration.get(Constants.CEN_DIR);\n+    LOG.info(\"Points Per File \" + pointsPerFile);\n+    LOG.info(\"Num Centroids \" + numCentroids);\n+    LOG.info(\"Vector Size \" + vectorSize);\n+    LOG.info(\"Num Mappers \" + numMappers);\n+    LOG.info(\"Num Threads \" + numThreads);\n+    LOG.info(\"Num Iterations \" + numIterations);\n+    LOG.info(\"Cen Dir \" + cenDir);\n+\n+    long endTime = System.currentTimeMillis();\n+    LOG.info(\"config (ms) :\" + (endTime - startTime));\n+  }\n+\n+\n+  protected void mapCollective(KeyValReader reader,\n+                               Context context)\n+                               throws IOException, InterruptedException {\n+    long startTime = System.currentTimeMillis();\n+    List<String> pointFiles = new LinkedList<String>();\n+    while (reader.nextKeyValue()) {\n+      String key = reader.getCurrentKey();\n+      String value = reader.getCurrentValue();\n+      LOG.info(\"Key: \" + key + \", Value: \" + value);\n+      pointFiles.add(value);\n+    }\n+    Configuration conf = context.getConfiguration();\n+    runKmeans(pointFiles, conf, context);\n+    LOG.info(\"Total iterations in master view: \" + (System.currentTimeMillis() - startTime));\n+  }\n+\n+  private void runKmeans(List<String> fileNames, Configuration conf,\n+                         Context context)\n+                         throws IOException {\r\n+    // Load data points\n+    List<double[]> pointArrays = KMUtil.loadPoints(fileNames, pointsPerFile, cenVecSize, conf, numThreads);\r\n     // Create related data structure for holding\r\n     // the nearest centroid partition+offset and\r\n-    // the distance\r\n-    BlockingQueue<Points> pointsList =\r\n-      new LinkedBlockingQueue<>();\r\n-    pointArrays.parallelStream().forEach(e -> {\r\n-      Points points = new Points();\r\n-      int numPoints = e.length / cenVecSize;\r\n-      points.pointArray = e;\r\n-      points.cenIDs = new int[numPoints][2];\r\n-      pointsList.add(points);\r\n+    // the distance\n+    BlockingQueue<Points> pointsList = new LinkedBlockingQueue<>();\n+    pointArrays.parallelStream().forEach(e -> {\n+      Points points = new Points();\n+      int numPoints = e.length / cenVecSize;\n+      points.pointArray = e;\n+      points.cenIDs = new int[numPoints][2];\n+      pointsList.add(points);\n     });\r\n-    // Generate centroids\r\n-    Table<DoubleArray> cenTable =\r\n-      new Table<>(0, new DoubleArrPlus());\r\n-    generateCenTable(cenTable, numCentroids,\r\n-      numCenPars, cenVecSize);\r\n-    // Initialize tasks\r\n-    List<ExpTask> expTasks = new LinkedList<>();\r\n-    for (int i = 0; i < numThreads; i++) {\r\n-      expTasks\r\n-        .add(new ExpTask(cenTable, cenVecSize));\r\n-    }\r\n-    DynamicScheduler<Points, Object, ExpTask> expCompute =\r\n-      new DynamicScheduler<>(expTasks);\r\n-    List<MaxTask> maxTasks = new LinkedList<>();\r\n-    for (int i = 0; i < numThreads; i++) {\r\n-      maxTasks.add(new MaxTask(pointsList,\r\n-        cenTable, cenVecSize));\r\n-    }\r\n-    DynamicScheduler<CenPair, Object, MaxTask> maxCompute =\r\n-      new DynamicScheduler<>(maxTasks);\r\n-    expCompute.start();\r\n+    // Generate centroids\n+    Table<DoubleArray> cenTable = new Table<>(0, new DoubleArrPlus());\n+    generateCenTable(cenTable, numCentroids, numCenPars, cenVecSize);\r\n+    // Initialize tasks\n+    List<ExpTask> expTasks = new LinkedList<>();\n+    for (int i = 0; i < numThreads; i++) {\n+      expTasks.add(new ExpTask(cenTable, cenVecSize));\n+    }\n+    DynamicScheduler<Points, Object, ExpTask> expCompute = new DynamicScheduler<>(expTasks);\n+    List<MaxTask> maxTasks = new LinkedList<>();\n+    for (int i = 0; i < numThreads; i++) {\n+      maxTasks.add(new MaxTask(pointsList, cenTable, cenVecSize));\n+    }\n+    DynamicScheduler<CenPair, Object, MaxTask> maxCompute = new DynamicScheduler<>(maxTasks);\n+    expCompute.start();\n     maxCompute.start();\r\n     // ----------------------------------------------------\r\n-    // For iterations\r\n+    // For iterations\n     for (int i = 0; i < numIterations; i++) {\r\n       // LOG.info(\"Iteration: \" + i);\r\n-      // Expectation\r\n-      long t1 = System.currentTimeMillis();\r\n-      for (int j = 0; j < this\r\n-        .getNumWorkers(); j++) {\r\n-        // LOG.info(\"Expectation Round: \" + j);\r\n-        for (ExpTask task : expCompute\r\n-          .getTasks()) {\r\n-          task.update();\r\n-        }\r\n-        expCompute.submitAll(pointsList);\r\n-        while (expCompute.hasOutput()) {\r\n-          expCompute.waitForOutput();\r\n-        }\r\n-        this.rotate(\"kmeans\",\r\n-          \"exp-rotate-\" + i + \"-\" + j, cenTable,\r\n-          null);\r\n-      }\r\n+      // Expectation\n+      long t1 = System.currentTimeMillis();\n+      for (int j = 0; j < this.getNumWorkers(); j++) {\r\n+        // LOG.info(\"Expectation Round: \" + j);\n+        for (ExpTask task : expCompute.getTasks()) {\n+          task.update();\n+        }\n+        expCompute.submitAll(pointsList);\n+        while (expCompute.hasOutput()) {\n+          expCompute.waitForOutput();\n+        }\n+\n+\n+        this.rotate(\n+             \"kmeans\",\n+          \"exp-rotate-\" + i + \"-\" + j, cenTable, null);\n+      }\n+\n       long t2 = System.currentTimeMillis();\r\n-      // Clean centroids\r\n-      cenTable.getPartitions().parallelStream()\r\n-        .forEach(e -> {\r\n-          Arrays.fill(e.get().get(), 0.0);\r\n-        });\r\n-      // Maximization\r\n-      for (int j = 0; j < this\r\n-        .getNumWorkers(); j++) {\r\n-        // LOG.info(\"Maximization Round: \" + j);\r\n-        for (Partition<DoubleArray> partition : cenTable\r\n-          .getPartitions()) {\r\n-          int id = partition.id();\r\n-          int size = partition.get().size();\r\n-          for (int k = 0; k < size; k +=\r\n-            cenVecSize) {\r\n-            maxCompute.submit(new CenPair(id, k));\r\n-          }\r\n-        }\r\n-        while (maxCompute.hasOutput()) {\r\n-          maxCompute.waitForOutput();\r\n-        }\r\n-        this.rotate(\"kmeans\",\r\n-          \"max-rotate-\" + i + \"-\" + j, cenTable,\r\n-          null);\r\n-      }\r\n-      long t3 = System.currentTimeMillis();\r\n-      for (Partition<DoubleArray> partition : cenTable\r\n-        .getPartitions()) {\r\n-        double[] doubles = partition.get().get();\r\n-        int size = partition.get().size();\r\n-        for (int j = 0; j < size; j +=\r\n-          cenVecSize) {\r\n+      // Clean centroids\n+      cenTable.getPartitions().parallelStream().forEach(e -> {\n+        Arrays.fill(e.get().get(), 0.0);\n+      });\r\n+      // Maximization\n+      for (int j = 0; j < this.getNumWorkers(); j++) {\r\n+        // LOG.info(\"Maximization Round: \" + j);\n+        for (Partition<DoubleArray> partition : cenTable.getPartitions()) {\n+        int id = partition.id();\n+        int size = partition.get().size();\n+        for (int k = 0; k < size; k += cenVecSize) {\n+          maxCompute.submit(new CenPair(id, k));\n+        }\n+        }\n+        while (maxCompute.hasOutput()) {\n+          maxCompute.waitForOutput();\n+        }\n+\n+\n+        this.rotate(\n+             \"kmeans\",\n+          \"max-rotate-\" + i + \"-\" + j, cenTable, null);\n+      }\n+\n+      long t3 = System.currentTimeMillis();\n+      for (Partition<DoubleArray> partition : cenTable.getPartitions()) {\n+        double[] doubles = partition.get().get();\n+        int size = partition.get().size();\n+        for (int j = 0; j < size; j += cenVecSize) {\n           for (int k = 1; k < cenVecSize; k++) {\r\n-            // Calculate avg\r\n-            if (doubles[j] != 0) {\r\n-              doubles[j + k] /= doubles[j];\r\n-            }\r\n-          }\r\n-        }\r\n-      }\r\n-      long t4 = System.currentTimeMillis();\r\n-      LOG.info(\"Expectation: \" + (t2 - t1)\r\n-        + \", Maximization: \" + (t3 - t2)\r\n-        + \", Averging: \" + (t4 - t3));\r\n-      logMemUsage();\r\n-      logGCTime();\r\n-      context.progress();\r\n-    }\r\n-    expCompute.stop();\r\n+            // Calculate avg\n+            if (doubles[j] != 0) {\n+              doubles[j + k] /= doubles[j];\n+            }\n+          }\n+        }\n+      }\n+\n+      long t4 = System.currentTimeMillis();\n+      LOG.info(\"Expectation: \" + (t2 - t1) + \", Maximization: \" + (t3 - t2) + \", Averging: \" + (t4 - t3));\n+      logMemUsage();\n+      logGCTime();\n+      context.progress();\n+    }\n+    expCompute.stop();\n     maxCompute.stop();\r\n-    // Write out centroids\r\n-    LOG.info(\"Start to write out centroids.\");\r\n-    long startTime = System.currentTimeMillis();\r\n-    KMUtil.storeCentroids(conf, cenDir, cenTable,\r\n-      cenVecSize, this.getSelfID() + \"\");\r\n-    long endTime = System.currentTimeMillis();\r\n-    LOG.info(\"Store centroids time (ms): \"\r\n-      + (endTime - startTime));\r\n-    cenTable.release();\r\n-  }\r\n-\r\n-  private void generateCenTable(\r\n-    Table<DoubleArray> cenTable, int numCentroids,\r\n-    int numCenPartitions, int cenVecSize) {\r\n-    int selfID = this.getSelfID();\r\n-    int numWorkers = this.getNumWorkers();\r\n-    Random random =\r\n-      new Random(System.currentTimeMillis());\r\n-    int cenParSize =\r\n-      numCentroids / numCenPartitions;\r\n-    int cenRest = numCentroids % numCenPartitions;\r\n-    for (int i = 0; i < numCenPartitions; i++) {\r\n-      if (cenRest > 0) {\r\n-        int size = (cenParSize + 1) * cenVecSize;\r\n-        cenRest--;\r\n-        if (i % numWorkers == selfID) {\r\n-          DoubleArray array =\r\n-            DoubleArray.create(size, false);\r\n-          double[] doubles = array.get();\r\n-          for (int j = 0; j < size; j++) {\r\n-            doubles[j] =\r\n-              random.nextDouble() * 1000;\r\n-          }\r\n-          cenTable.addPartition(\r\n-            new Partition<>(i, array));\r\n-        }\r\n-      } else if (cenParSize > 0) {\r\n-        int size = cenParSize * cenVecSize;\r\n-        if (i % numWorkers == selfID) {\r\n-          DoubleArray array =\r\n-            DoubleArray.create(size, false);\r\n-          double[] doubles = array.get();\r\n-          for (int j = 0; j < size; j++) {\r\n-            doubles[j] =\r\n-              random.nextDouble() * 1000;\r\n-          }\r\n-          cenTable.addPartition(\r\n-            new Partition<>(i, array));\r\n-        }\r\n-      }\r\n-    }\r\n-  }\r\n-}\r\n+    // Write out centroids\n+    LOG.info(\"Start to write out centroids.\");\n+\n+    long startTime = System.currentTimeMillis();\n+    KMUtil.storeCentroids(conf, cenDir, cenTable, cenVecSize, this.getSelfID() + \"\");\n+\n+    long endTime = System.currentTimeMillis();\n+    LOG.info(\"Store centroids time (ms): \" + (endTime - startTime));\n+    cenTable.release();\n+  }\n+\n+  private void generateCenTable(Table<DoubleArray> cenTable, int numCentroids, int numCenPartitions, int cenVecSize) {\n+    int selfID = this.getSelfID();\n+    int numWorkers = this.getNumWorkers();\n+    Random random = new Random(System.currentTimeMillis());\n+    int cenParSize = numCentroids / numCenPartitions;\n+    int cenRest = numCentroids % numCenPartitions;\n+    for (int i = 0; i < numCenPartitions; i++) {\n+      if (cenRest > 0) {\n+        int size =\n+           (cenParSize + 1) * cenVecSize;\n+        cenRest--;\n+        if (i % numWorkers == selfID) {\n+          DoubleArray array = DoubleArray.create(size, false);\n+          double[] doubles = array.get();\n+          for (int j = 0; j < size; j++) {\n+            doubles[j] = random.nextDouble() * 1000;\n+          }\n+          cenTable.addPartition(new Partition<>(i, array));\n+        }\n+      } else if (cenParSize > 0) {\n+               int size = cenParSize * cenVecSize;\n+               if (i % numWorkers == selfID) {\n+                 DoubleArray array = DoubleArray.create(size, false);\n+                 double[] doubles = array.get();\n+                 for (int j = 0; j < size; j++) {\n+                   doubles[j] = random.nextDouble() * 1000;\n+                 }\n+                 cenTable.addPartition(new Partition<>(i, array));\n+               }\n+      }\n+    }\n+  }\n+}\n\\ No newline at end of file\n",
            "diff_size": 242
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "3",
                    "severity": "error",
                    "message": "Line has trailing spaces.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "3",
                    "severity": "error",
                    "message": "Line has trailing spaces.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ],
    "repaired_by": [
        "intellij"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}