{
    "project_name": "codefollower-H2-Research",
    "error_id": "257",
    "information": {
        "errors": [
            {
                "line": "182",
                "column": "13",
                "severity": "warning",
                "message": "File contains tab characters (this is the first instance).",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
            }
        ]
    },
    "source_code": "            right = right.optimize(session);\n            if (right instanceof ExpressionColumn) {\n            \t//\u4f8b\u5982delete top 3 from DeleteTest where 'a1'> name\n            \t//\u8f6c\u6210delete top 3 from DeleteTest where name < 'a1'\n                if (left.isConstant() || left instanceof Parameter) {\n                    Expression temp = left;",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "195",
                    "column": "21",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/257/Comparison.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler/257/Comparison.java\nindex 59b5358753e..d23687c6f8f 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/257/Comparison.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler/257/Comparison.java\n@@ -179,8 +179,8 @@ public class Comparison extends Condition {\n         if (right != null) {\n             right = right.optimize(session);\n             if (right instanceof ExpressionColumn) {\n-            \t//\u4f8b\u5982delete top 3 from DeleteTest where 'a1'> name\n-            \t//\u8f6c\u6210delete top 3 from DeleteTest where name < 'a1'\n+            //\u4f8b\u5982delete top 3 from DeleteTest where 'a1'> name\n+             //\u8f6c\u6210delete top 3 from DeleteTest where name < 'a1'\n                 if (left.isConstant() || left instanceof Parameter) {\n                     Expression temp = left;\n                     left = right;\n",
            "diff_size": 2
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/257/Comparison.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/257/Comparison.java\nindex 59b5358753e..031c1c6b909 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/257/Comparison.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/257/Comparison.java\n@@ -3,9 +3,11 @@\n  * and the EPL 1.0 (http://h2database.com/html/license.html).\n  * Initial Developer: H2 Group\n  */\n+\n package org.h2.expression;\n \n import java.util.Arrays;\n+\n import org.h2.engine.Database;\n import org.h2.engine.Session;\n import org.h2.engine.SysProperties;\n@@ -28,568 +30,568 @@ import org.h2.value.ValueNull;\n  */\n public class Comparison extends Condition {\n \n-    /**\n-     * This is a flag meaning the comparison is null safe (meaning never returns\n-     * NULL even if one operand is NULL). Only EQUAL and NOT_EQUAL are supported\n-     * currently.\n-     */\n-    public static final int NULL_SAFE = 16;\n-\n-    /**\n-     * The comparison type meaning = as in ID=1.\n-     */\n-    public static final int EQUAL = 0;\n-\n-    /**\n-     * The comparison type meaning ID IS 1 (ID IS NOT DISTINCT FROM 1).\n-     */\n-    public static final int EQUAL_NULL_SAFE = EQUAL | NULL_SAFE;\n-\n-    /**\n-     * The comparison type meaning &gt;= as in ID&gt;=1.\n-     */\n-    public static final int BIGGER_EQUAL = 1;\n-\n-    /**\n-     * The comparison type meaning &gt; as in ID&gt;1.\n-     */\n-    public static final int BIGGER = 2;\n-\n-    /**\n-     * The comparison type meaning &lt;= as in ID&lt;=1.\n-     */\n-    public static final int SMALLER_EQUAL = 3;\n-\n-    /**\n-     * The comparison type meaning &lt; as in ID&lt;1.\n-     */\n-    public static final int SMALLER = 4;\n-\n-    /**\n-     * The comparison type meaning &lt;&gt; as in ID&lt;&gt;1.\n-     */\n-    public static final int NOT_EQUAL = 5;\n-\n-    /**\n-     * The comparison type meaning ID IS NOT 1 (ID IS DISTINCT FROM 1).\n-     */\n-    public static final int NOT_EQUAL_NULL_SAFE = NOT_EQUAL | NULL_SAFE;\n-\n-    /**\n-     * The comparison type meaning IS NULL as in NAME IS NULL.\n-     */\n-    public static final int IS_NULL = 6;\n-\n-    /**\n-     * The comparison type meaning IS NOT NULL as in NAME IS NOT NULL.\n-     */\n-    public static final int IS_NOT_NULL = 7;\n-\n-    /**\n-     * This is a pseudo comparison type that is only used for index conditions.\n-     * It means the comparison will always yield FALSE. Example: 1=0.\n-     */\n-    public static final int FALSE = 8;\n-\n-    /**\n-     * This is a pseudo comparison type that is only used for index conditions.\n-     * It means equals any value of a list. Example: IN(1, 2, 3).\n-     */\n-    public static final int IN_LIST = 9;\n-\n-    /**\n-     * This is a pseudo comparison type that is only used for index conditions.\n-     * It means equals any value of a list. Example: IN(SELECT ...).\n-     */\n-    public static final int IN_QUERY = 10;\n-\n-    /**\n-     * This is a comparison type that is only used for spatial index\n-     * conditions (operator \"&&\").\n-     */\n-    public static final int SPATIAL_INTERSECTS = 11;\n-\n-    private final Database database;\n-    private int compareType;\n-    private Expression left;\n-    private Expression right;\n-\n-    public Comparison(Session session, int compareType, Expression left,\n-            Expression right) {\n-        this.database = session.getDatabase();\n-        this.left = left;\n-        this.right = right;\n-        this.compareType = compareType;\n+  /**\n+   * This is a flag meaning the comparison is null safe (meaning never returns\n+   * NULL even if one operand is NULL). Only EQUAL and NOT_EQUAL are supported\n+   * currently.\n+   */\n+  public static final int NULL_SAFE = 16;\n+\n+  /**\n+   * The comparison type meaning = as in ID=1.\n+   */\n+  public static final int EQUAL = 0;\n+\n+  /**\n+   * The comparison type meaning ID IS 1 (ID IS NOT DISTINCT FROM 1).\n+   */\n+  public static final int EQUAL_NULL_SAFE = EQUAL | NULL_SAFE;\n+\n+  /**\n+   * The comparison type meaning &gt;= as in ID&gt;=1.\n+   */\n+  public static final int BIGGER_EQUAL = 1;\n+\n+  /**\n+   * The comparison type meaning &gt; as in ID&gt;1.\n+   */\n+  public static final int BIGGER = 2;\n+\n+  /**\n+   * The comparison type meaning &lt;= as in ID&lt;=1.\n+   */\n+  public static final int SMALLER_EQUAL = 3;\n+\n+  /**\n+   * The comparison type meaning &lt; as in ID&lt;1.\n+   */\n+  public static final int SMALLER = 4;\n+\n+  /**\n+   * The comparison type meaning &lt;&gt; as in ID&lt;&gt;1.\n+   */\n+  public static final int NOT_EQUAL = 5;\n+\n+  /**\n+   * The comparison type meaning ID IS NOT 1 (ID IS DISTINCT FROM 1).\n+   */\n+  public static final int NOT_EQUAL_NULL_SAFE = NOT_EQUAL | NULL_SAFE;\n+\n+  /**\n+   * The comparison type meaning IS NULL as in NAME IS NULL.\n+   */\n+  public static final int IS_NULL = 6;\n+\n+  /**\n+   * The comparison type meaning IS NOT NULL as in NAME IS NOT NULL.\n+   */\n+  public static final int IS_NOT_NULL = 7;\n+\n+  /**\n+   * This is a pseudo comparison type that is only used for index conditions.\n+   * It means the comparison will always yield FALSE. Example: 1=0.\n+   */\n+  public static final int FALSE = 8;\n+\n+  /**\n+   * This is a pseudo comparison type that is only used for index conditions.\n+   * It means equals any value of a list. Example: IN(1, 2, 3).\n+   */\n+  public static final int IN_LIST = 9;\n+\n+  /**\n+   * This is a pseudo comparison type that is only used for index conditions.\n+   * It means equals any value of a list. Example: IN(SELECT ...).\n+   */\n+  public static final int IN_QUERY = 10;\n+\n+  /**\n+   * This is a comparison type that is only used for spatial index\n+   * conditions (operator \"&&\").\n+   */\n+  public static final int SPATIAL_INTERSECTS = 11;\n+\n+  private final Database database;\n+  private int compareType;\n+  private Expression left;\n+  private Expression right;\n+\n+  public Comparison(Session session, int compareType, Expression left,\n+                    Expression right) {\n+    this.database = session.getDatabase();\n+    this.left = left;\n+    this.right = right;\n+    this.compareType = compareType;\n+  }\n+\n+  @Override\n+  public String getSQL() {\n+    String sql;\n+    switch (compareType) {\n+      case IS_NULL:\n+        sql = left.getSQL() + \" IS NULL\";\n+        break;\n+      case IS_NOT_NULL:\n+        sql = left.getSQL() + \" IS NOT NULL\";\n+        break;\n+      case SPATIAL_INTERSECTS:\n+        sql = \"INTERSECTS(\" + left.getSQL() + \", \" + right.getSQL() + \")\";\n+        break;\n+      default:\n+        sql = left.getSQL() + \" \" + getCompareOperator(compareType) +\n+            \" \" + right.getSQL();\n     }\n-\n-    @Override\n-    public String getSQL() {\n-        String sql;\n-        switch (compareType) {\n-        case IS_NULL:\n-            sql = left.getSQL() + \" IS NULL\";\n-            break;\n-        case IS_NOT_NULL:\n-            sql = left.getSQL() + \" IS NOT NULL\";\n-            break;\n-        case SPATIAL_INTERSECTS:\n-            sql = \"INTERSECTS(\" + left.getSQL() + \", \" + right.getSQL() + \")\";\n-            break;\n-        default:\n-            sql = left.getSQL() + \" \" + getCompareOperator(compareType) +\n-                    \" \" + right.getSQL();\n-        }\n-        return \"(\" + sql + \")\";\n-    }\n-\n-    /**\n-     * Get the comparison operator string (\"=\", \">\",...).\n-     *\n-     * @param compareType the compare type\n-     * @return the string\n-     */\n-    static String getCompareOperator(int compareType) {\n-        switch (compareType) {\n-        case EQUAL:\n-            return \"=\";\n-        case EQUAL_NULL_SAFE:\n-            return \"IS\";\n-        case BIGGER_EQUAL:\n-            return \">=\";\n-        case BIGGER:\n-            return \">\";\n-        case SMALLER_EQUAL:\n-            return \"<=\";\n-        case SMALLER:\n-            return \"<\";\n-        case NOT_EQUAL:\n-            return \"<>\";\n-        case NOT_EQUAL_NULL_SAFE:\n-            return \"IS NOT\";\n-        case SPATIAL_INTERSECTS:\n-            return \"&&\";\n-        default:\n-            throw DbException.throwInternalError(\"compareType=\" + compareType);\n-        }\n-    }\n-\n-    @Override\n-    public Expression optimize(Session session) {\n-        left = left.optimize(session);\n-        if (right != null) {\n-            right = right.optimize(session);\n-            if (right instanceof ExpressionColumn) {\n-            \t//\u4f8b\u5982delete top 3 from DeleteTest where 'a1'> name\n-            \t//\u8f6c\u6210delete top 3 from DeleteTest where name < 'a1'\n-                if (left.isConstant() || left instanceof Parameter) {\n-                    Expression temp = left;\n-                    left = right;\n-                    right = temp;\n-                    compareType = getReversedCompareType(compareType);\n-                }\n-            }\n-            if (left instanceof ExpressionColumn) {\n-                if (right.isConstant()) {\n-                    Value r = right.getValue(session);\n-                    if (r == ValueNull.INSTANCE) {\n-                    \t//\u4f8b\u5982: \"delete top 3 from DeleteTest where name = null\n-                        if ((compareType & NULL_SAFE) == 0) {\n-                            return ValueExpression.getNull();\n-                        }\n-                    }\n-                    int colType = left.getType();\n-                    int constType = r.getType();\n-                    int resType = Value.getHigherOrder(colType, constType);\n-                    // If not, the column values will need to be promoted\n-                    // to constant type, but vise versa, then let's do this here\n-                    // once.\n-                    if (constType != resType) {\n-                        right = ValueExpression.get(r.convertTo(resType));\n-                    }\n-                } else if (right instanceof Parameter) {\n-                    ((Parameter) right).setColumn(\n-                            ((ExpressionColumn) left).getColumn());\n-                }\n-            }\n-        }\n-        if (compareType == IS_NULL || compareType == IS_NOT_NULL) {\n-            if (left.isConstant()) {\n-                return ValueExpression.get(getValue(session));\n-            }\n-        } else {\n-            if (SysProperties.CHECK && (left == null || right == null)) {\n-                DbException.throwInternalError(left + \" \" + right);\n-            }\n-            if (left == ValueExpression.getNull() ||\n-                    right == ValueExpression.getNull()) {\n-                // TODO NULL handling: maybe issue a warning when comparing with\n-                // a NULL constants\n-                if ((compareType & NULL_SAFE) == 0) {\n-                    return ValueExpression.getNull();\n-                }\n-            }\n-            if (left.isConstant() && right.isConstant()) {\n-                return ValueExpression.get(getValue(session));\n-            }\n-        }\n-        return this;\n+    return \"(\" + sql + \")\";\n+  }\n+\n+  /**\n+   * Get the comparison operator string (\"=\", \">\",...).\n+   *\n+   * @param compareType the compare type\n+   * @return the string\n+   */\n+  static String getCompareOperator(int compareType) {\n+    switch (compareType) {\n+      case EQUAL:\n+        return \"=\";\n+      case EQUAL_NULL_SAFE:\n+        return \"IS\";\n+      case BIGGER_EQUAL:\n+        return \">=\";\n+      case BIGGER:\n+        return \">\";\n+      case SMALLER_EQUAL:\n+        return \"<=\";\n+      case SMALLER:\n+        return \"<\";\n+      case NOT_EQUAL:\n+        return \"<>\";\n+      case NOT_EQUAL_NULL_SAFE:\n+        return \"IS NOT\";\n+      case SPATIAL_INTERSECTS:\n+        return \"&&\";\n+      default:\n+        throw DbException.throwInternalError(\"compareType=\" + compareType);\n     }\n-\n-    @Override\n-    public Value getValue(Session session) {\n-        Value l = left.getValue(session);\n-        if (right == null) {\n-            boolean result;\n-            switch (compareType) {\n-            case IS_NULL:\n-                result = l == ValueNull.INSTANCE;\n-                break;\n-            case IS_NOT_NULL:\n-                result = !(l == ValueNull.INSTANCE);\n-                break;\n-            default:\n-                throw DbException.throwInternalError(\"type=\" + compareType);\n-            }\n-            return ValueBoolean.get(result);\n+  }\n+\n+  @Override\n+  public Expression optimize(Session session) {\n+    left = left.optimize(session);\n+    if (right != null) {\n+      right = right.optimize(session);\n+      if (right instanceof ExpressionColumn) {\n+        //\u4f8b\u5982delete top 3 from DeleteTest where 'a1'> name\n+        //\u8f6c\u6210delete top 3 from DeleteTest where name < 'a1'\n+        if (left.isConstant() || left instanceof Parameter) {\n+          Expression temp = left;\n+          left = right;\n+          right = temp;\n+          compareType = getReversedCompareType(compareType);\n         }\n-        if (l == ValueNull.INSTANCE) {\n+      }\n+      if (left instanceof ExpressionColumn) {\n+        if (right.isConstant()) {\n+          Value r = right.getValue(session);\n+          if (r == ValueNull.INSTANCE) {\n+            //\u4f8b\u5982: \"delete top 3 from DeleteTest where name = null\n             if ((compareType & NULL_SAFE) == 0) {\n-                return ValueNull.INSTANCE;\n+              return ValueExpression.getNull();\n             }\n+          }\n+          int colType = left.getType();\n+          int constType = r.getType();\n+          int resType = Value.getHigherOrder(colType, constType);\n+          // If not, the column values will need to be promoted\n+          // to constant type, but vise versa, then let's do this here\n+          // once.\n+          if (constType != resType) {\n+            right = ValueExpression.get(r.convertTo(resType));\n+          }\n+        } else if (right instanceof Parameter) {\n+          ((Parameter) right).setColumn(\n+              ((ExpressionColumn) left).getColumn());\n         }\n-        Value r = right.getValue(session);\n-        if (r == ValueNull.INSTANCE) {\n-            if ((compareType & NULL_SAFE) == 0) {\n-                return ValueNull.INSTANCE;\n-            }\n-        }\n-        int dataType = Value.getHigherOrder(left.getType(), right.getType());\n-        l = l.convertTo(dataType);\n-        r = r.convertTo(dataType);\n-        boolean result = compareNotNull(database, l, r, compareType);\n-        return ValueBoolean.get(result);\n+      }\n     }\n-\n-    /**\n-     * Compare two values, given the values are not NULL.\n-     *\n-     * @param database the database\n-     * @param l the first value\n-     * @param r the second value\n-     * @param compareType the compare type\n-     * @return true if the comparison indicated by the comparison type evaluates\n-     *         to true\n-     */\n-    static boolean compareNotNull(Database database, Value l, Value r,\n-            int compareType) {\n-        boolean result;\n-        switch (compareType) {\n-        case EQUAL:\n-        case EQUAL_NULL_SAFE:\n-            result = database.areEqual(l, r);\n-            break;\n-        case NOT_EQUAL:\n-        case NOT_EQUAL_NULL_SAFE:\n-            result = !database.areEqual(l, r);\n-            break;\n-        case BIGGER_EQUAL:\n-            result = database.compare(l, r) >= 0;\n-            break;\n-        case BIGGER:\n-            result = database.compare(l, r) > 0;\n-            break;\n-        case SMALLER_EQUAL:\n-            result = database.compare(l, r) <= 0;\n-            break;\n-        case SMALLER:\n-            result = database.compare(l, r) < 0;\n-            break;\n-        case SPATIAL_INTERSECTS: {\n-            ValueGeometry lg = (ValueGeometry) l.convertTo(Value.GEOMETRY);\n-            ValueGeometry rg = (ValueGeometry) r.convertTo(Value.GEOMETRY);\n-            result = lg.intersectsBoundingBox(rg);\n-            break;\n-        }\n-        default:\n-            throw DbException.throwInternalError(\"type=\" + compareType);\n+    if (compareType == IS_NULL || compareType == IS_NOT_NULL) {\n+      if (left.isConstant()) {\n+        return ValueExpression.get(getValue(session));\n+      }\n+    } else {\n+      if (SysProperties.CHECK && (left == null || right == null)) {\n+        DbException.throwInternalError(left + \" \" + right);\n+      }\n+      if (left == ValueExpression.getNull() ||\n+          right == ValueExpression.getNull()) {\n+        // TODO NULL handling: maybe issue a warning when comparing with\n+        // a NULL constants\n+        if ((compareType & NULL_SAFE) == 0) {\n+          return ValueExpression.getNull();\n         }\n-        return result;\n+      }\n+      if (left.isConstant() && right.isConstant()) {\n+        return ValueExpression.get(getValue(session));\n+      }\n     }\n-\n-    private int getReversedCompareType(int type) {\n-        switch (compareType) {\n-        case EQUAL:\n-        case EQUAL_NULL_SAFE:\n-        case NOT_EQUAL:\n-        case NOT_EQUAL_NULL_SAFE:\n-        case SPATIAL_INTERSECTS:\n-            return type;\n-        case BIGGER_EQUAL:\n-            return SMALLER_EQUAL;\n-        case BIGGER:\n-            return SMALLER;\n-        case SMALLER_EQUAL:\n-            return BIGGER_EQUAL;\n-        case SMALLER:\n-            return BIGGER;\n+    return this;\n+  }\n+\n+  @Override\n+  public Value getValue(Session session) {\n+    Value l = left.getValue(session);\n+    if (right == null) {\n+      boolean result;\n+      switch (compareType) {\n+        case IS_NULL:\n+          result = l == ValueNull.INSTANCE;\n+          break;\n+        case IS_NOT_NULL:\n+          result = !(l == ValueNull.INSTANCE);\n+          break;\n         default:\n-            throw DbException.throwInternalError(\"type=\" + compareType);\n-        }\n+          throw DbException.throwInternalError(\"type=\" + compareType);\n+      }\n+      return ValueBoolean.get(result);\n     }\n-\n-    @Override\n-    public Expression getNotIfPossible(Session session) {\n-        if (compareType == SPATIAL_INTERSECTS) {\n-            return null;\n-        }\n-        int type = getNotCompareType();\n-        return new Comparison(session, type, left, right);\n+    if (l == ValueNull.INSTANCE) {\n+      if ((compareType & NULL_SAFE) == 0) {\n+        return ValueNull.INSTANCE;\n+      }\n+    }\n+    Value r = right.getValue(session);\n+    if (r == ValueNull.INSTANCE) {\n+      if ((compareType & NULL_SAFE) == 0) {\n+        return ValueNull.INSTANCE;\n+      }\n+    }\n+    int dataType = Value.getHigherOrder(left.getType(), right.getType());\n+    l = l.convertTo(dataType);\n+    r = r.convertTo(dataType);\n+    boolean result = compareNotNull(database, l, r, compareType);\n+    return ValueBoolean.get(result);\n+  }\n+\n+  /**\n+   * Compare two values, given the values are not NULL.\n+   *\n+   * @param database    the database\n+   * @param l           the first value\n+   * @param r           the second value\n+   * @param compareType the compare type\n+   * @return true if the comparison indicated by the comparison type evaluates\n+   * to true\n+   */\n+  static boolean compareNotNull(Database database, Value l, Value r,\n+                                int compareType) {\n+    boolean result;\n+    switch (compareType) {\n+      case EQUAL:\n+      case EQUAL_NULL_SAFE:\n+        result = database.areEqual(l, r);\n+        break;\n+      case NOT_EQUAL:\n+      case NOT_EQUAL_NULL_SAFE:\n+        result = !database.areEqual(l, r);\n+        break;\n+      case BIGGER_EQUAL:\n+        result = database.compare(l, r) >= 0;\n+        break;\n+      case BIGGER:\n+        result = database.compare(l, r) > 0;\n+        break;\n+      case SMALLER_EQUAL:\n+        result = database.compare(l, r) <= 0;\n+        break;\n+      case SMALLER:\n+        result = database.compare(l, r) < 0;\n+        break;\n+      case SPATIAL_INTERSECTS: {\n+        ValueGeometry lg = (ValueGeometry) l.convertTo(Value.GEOMETRY);\n+        ValueGeometry rg = (ValueGeometry) r.convertTo(Value.GEOMETRY);\n+        result = lg.intersectsBoundingBox(rg);\n+        break;\n+      }\n+      default:\n+        throw DbException.throwInternalError(\"type=\" + compareType);\n+    }\n+    return result;\n+  }\n+\n+  private int getReversedCompareType(int type) {\n+    switch (compareType) {\n+      case EQUAL:\n+      case EQUAL_NULL_SAFE:\n+      case NOT_EQUAL:\n+      case NOT_EQUAL_NULL_SAFE:\n+      case SPATIAL_INTERSECTS:\n+        return type;\n+      case BIGGER_EQUAL:\n+        return SMALLER_EQUAL;\n+      case BIGGER:\n+        return SMALLER;\n+      case SMALLER_EQUAL:\n+        return BIGGER_EQUAL;\n+      case SMALLER:\n+        return BIGGER;\n+      default:\n+        throw DbException.throwInternalError(\"type=\" + compareType);\n     }\n+  }\n \n-    private int getNotCompareType() {\n-        switch (compareType) {\n-        case EQUAL:\n-            return NOT_EQUAL;\n-        case EQUAL_NULL_SAFE:\n-            return NOT_EQUAL_NULL_SAFE;\n-        case NOT_EQUAL:\n-            return EQUAL;\n-        case NOT_EQUAL_NULL_SAFE:\n-            return EQUAL_NULL_SAFE;\n-        case BIGGER_EQUAL:\n-            return SMALLER;\n-        case BIGGER:\n-            return SMALLER_EQUAL;\n-        case SMALLER_EQUAL:\n-            return BIGGER;\n-        case SMALLER:\n-            return BIGGER_EQUAL;\n-        case IS_NULL:\n-            return IS_NOT_NULL;\n-        case IS_NOT_NULL:\n-            return IS_NULL;\n-        default:\n-            throw DbException.throwInternalError(\"type=\" + compareType);\n-        }\n+  @Override\n+  public Expression getNotIfPossible(Session session) {\n+    if (compareType == SPATIAL_INTERSECTS) {\n+      return null;\n+    }\n+    int type = getNotCompareType();\n+    return new Comparison(session, type, left, right);\n+  }\n+\n+  private int getNotCompareType() {\n+    switch (compareType) {\n+      case EQUAL:\n+        return NOT_EQUAL;\n+      case EQUAL_NULL_SAFE:\n+        return NOT_EQUAL_NULL_SAFE;\n+      case NOT_EQUAL:\n+        return EQUAL;\n+      case NOT_EQUAL_NULL_SAFE:\n+        return EQUAL_NULL_SAFE;\n+      case BIGGER_EQUAL:\n+        return SMALLER;\n+      case BIGGER:\n+        return SMALLER_EQUAL;\n+      case SMALLER_EQUAL:\n+        return BIGGER;\n+      case SMALLER:\n+        return BIGGER_EQUAL;\n+      case IS_NULL:\n+        return IS_NOT_NULL;\n+      case IS_NOT_NULL:\n+        return IS_NULL;\n+      default:\n+        throw DbException.throwInternalError(\"type=\" + compareType);\n     }\n+  }\n \n-    @Override\n-    public void createIndexConditions(Session session, TableFilter filter) {\n-        if (!filter.getTable().isQueryComparable()) {\n-            return;\n-        }\n-        ExpressionColumn l = null;\n-        if (left instanceof ExpressionColumn) {\n-            l = (ExpressionColumn) left;\n-            if (filter != l.getTableFilter()) {\n-                l = null;\n-            }\n-        }\n-        if (right == null) {\n-            if (l != null) {\n-                switch (compareType) {\n-                case IS_NULL:\n-                    if (session.getDatabase().getSettings().optimizeIsNull) {\n-                        filter.addIndexCondition(\n-                                IndexCondition.get(\n-                                        Comparison.EQUAL_NULL_SAFE, l,\n-                                        ValueExpression.getNull()));\n-                    }\n-                }\n-            }\n-            return;\n-        }\n-        ExpressionColumn r = null;\n-        if (right instanceof ExpressionColumn) {\n-            r = (ExpressionColumn) right;\n-            if (filter != r.getTableFilter()) {\n-                r = null;\n-            }\n-        }\n-        // one side must be from the current filter\n-        if (l == null && r == null) {\n-            return;\n-        }\n-        if (l != null && r != null) {\n-            return;\n-        }\n-        if (l == null) {\n-            ExpressionVisitor visitor =\n-                    ExpressionVisitor.getNotFromResolverVisitor(filter);\n-            if (!left.isEverything(visitor)) {\n-                return;\n-            }\n-        } else if (r == null) {\n-            ExpressionVisitor visitor =\n-                    ExpressionVisitor.getNotFromResolverVisitor(filter);\n-            if (!right.isEverything(visitor)) {\n-                return;\n-            }\n-        } else {\n-            // if both sides are part of the same filter, it can't be used for\n-            // index lookup\n-            return;\n-        }\n-        boolean addIndex;\n+  @Override\n+  public void createIndexConditions(Session session, TableFilter filter) {\n+    if (!filter.getTable().isQueryComparable()) {\n+      return;\n+    }\n+    ExpressionColumn l = null;\n+    if (left instanceof ExpressionColumn) {\n+      l = (ExpressionColumn) left;\n+      if (filter != l.getTableFilter()) {\n+        l = null;\n+      }\n+    }\n+    if (right == null) {\n+      if (l != null) {\n         switch (compareType) {\n-        case NOT_EQUAL:\n-        case NOT_EQUAL_NULL_SAFE:\n-            addIndex = false;\n-            break;\n-        case EQUAL:\n-        case EQUAL_NULL_SAFE:\n-        case BIGGER:\n-        case BIGGER_EQUAL:\n-        case SMALLER_EQUAL:\n-        case SMALLER:\n-        case SPATIAL_INTERSECTS:\n-            addIndex = true;\n-            break;\n-        default:\n-            throw DbException.throwInternalError(\"type=\" + compareType);\n-        }\n-        if (addIndex) {\n-            if (l != null) {\n-                filter.addIndexCondition(\n-                        IndexCondition.get(compareType, l, right));\n-            } else if (r != null) {\n-                int compareRev = getReversedCompareType(compareType);\n-                filter.addIndexCondition(\n-                        IndexCondition.get(compareRev, r, left));\n+          case IS_NULL:\n+            if (session.getDatabase().getSettings().optimizeIsNull) {\n+              filter.addIndexCondition(\n+                  IndexCondition.get(\n+                      Comparison.EQUAL_NULL_SAFE, l,\n+                      ValueExpression.getNull()));\n             }\n         }\n+      }\n+      return;\n     }\n-\n-    @Override\n-    public void setEvaluatable(TableFilter tableFilter, boolean b) {\n-        left.setEvaluatable(tableFilter, b);\n-        if (right != null) {\n-            right.setEvaluatable(tableFilter, b);\n-        }\n+    ExpressionColumn r = null;\n+    if (right instanceof ExpressionColumn) {\n+      r = (ExpressionColumn) right;\n+      if (filter != r.getTableFilter()) {\n+        r = null;\n+      }\n     }\n-\n-    @Override\n-    public void updateAggregate(Session session) {\n-        left.updateAggregate(session);\n-        if (right != null) {\n-            right.updateAggregate(session);\n-        }\n+    // one side must be from the current filter\n+    if (l == null && r == null) {\n+      return;\n     }\n-\n-    @Override\n-    public void addFilterConditions(TableFilter filter, boolean outerJoin) {\n-        if (compareType == IS_NULL && outerJoin) {\n-            // can not optimize:\n-            // select * from test t1 left join test t2 on t1.id = t2.id\n-            // where t2.id is null\n-            // to\n-            // select * from test t1 left join test t2\n-            // on t1.id = t2.id and t2.id is null\n-            return;\n-        }\n-        super.addFilterConditions(filter, outerJoin);\n+    if (l != null && r != null) {\n+      return;\n     }\n-\n-    @Override\n-    public void mapColumns(ColumnResolver resolver, int level) {\n-        left.mapColumns(resolver, level);\n-        if (right != null) {\n-            right.mapColumns(resolver, level);\n-        }\n+    if (l == null) {\n+      ExpressionVisitor visitor =\n+          ExpressionVisitor.getNotFromResolverVisitor(filter);\n+      if (!left.isEverything(visitor)) {\n+        return;\n+      }\n+    } else if (r == null) {\n+      ExpressionVisitor visitor =\n+          ExpressionVisitor.getNotFromResolverVisitor(filter);\n+      if (!right.isEverything(visitor)) {\n+        return;\n+      }\n+    } else {\n+      // if both sides are part of the same filter, it can't be used for\n+      // index lookup\n+      return;\n     }\n-\n-    @Override\n-    public boolean isEverything(ExpressionVisitor visitor) {\n-        return left.isEverything(visitor) &&\n-                (right == null || right.isEverything(visitor));\n+    boolean addIndex;\n+    switch (compareType) {\n+      case NOT_EQUAL:\n+      case NOT_EQUAL_NULL_SAFE:\n+        addIndex = false;\n+        break;\n+      case EQUAL:\n+      case EQUAL_NULL_SAFE:\n+      case BIGGER:\n+      case BIGGER_EQUAL:\n+      case SMALLER_EQUAL:\n+      case SMALLER:\n+      case SPATIAL_INTERSECTS:\n+        addIndex = true;\n+        break;\n+      default:\n+        throw DbException.throwInternalError(\"type=\" + compareType);\n     }\n-\n-    @Override\n-    public int getCost() {\n-        return left.getCost() + (right == null ? 0 : right.getCost()) + 1;\n+    if (addIndex) {\n+      if (l != null) {\n+        filter.addIndexCondition(\n+            IndexCondition.get(compareType, l, right));\n+      } else if (r != null) {\n+        int compareRev = getReversedCompareType(compareType);\n+        filter.addIndexCondition(\n+            IndexCondition.get(compareRev, r, left));\n+      }\n     }\n+  }\n \n-    /**\n-     * Get the other expression if this is an equals comparison and the other\n-     * expression matches.\n-     *\n-     * @param match the expression that should match\n-     * @return null if no match, the other expression if there is a match\n-     */\n-    Expression getIfEquals(Expression match) {\n-        if (compareType == EQUAL) {\n-            String sql = match.getSQL();\n-            if (left.getSQL().equals(sql)) {\n-                return right;\n-            } else if (right.getSQL().equals(sql)) {\n-                return left;\n-            }\n-        }\n-        return null;\n+  @Override\n+  public void setEvaluatable(TableFilter tableFilter, boolean b) {\n+    left.setEvaluatable(tableFilter, b);\n+    if (right != null) {\n+      right.setEvaluatable(tableFilter, b);\n     }\n+  }\n \n-    /**\n-     * Get an additional condition if possible. Example: given two conditions\n-     * A=B AND B=C, the new condition A=C is returned. Given the two conditions\n-     * A=1 OR A=2, the new condition A IN(1, 2) is returned.\n-     *\n-     * @param session the session\n-     * @param other the second condition\n-     * @param and true for AND, false for OR\n-     * @return null or the third condition\n-     */\n-    Expression getAdditional(Session session, Comparison other, boolean and) {\n-        if (compareType == other.compareType && compareType == EQUAL) {\n-            boolean lc = left.isConstant();\n-            boolean rc = right.isConstant();\n-            boolean l2c = other.left.isConstant();\n-            boolean r2c = other.right.isConstant();\n-            String l = left.getSQL();\n-            String l2 = other.left.getSQL();\n-            String r = right.getSQL();\n-            String r2 = other.right.getSQL();\n-            if (and) {\n-                // a=b AND a=c\n-                // must not compare constants. example: NOT(B=2 AND B=3)\n-                if (!(rc && r2c) && l.equals(l2)) {\n-                    return new Comparison(session, EQUAL, right, other.right);\n-                } else if (!(rc && l2c) && l.equals(r2)) {\n-                    return new Comparison(session, EQUAL, right, other.left);\n-                } else if (!(lc && r2c) && r.equals(l2)) {\n-                    return new Comparison(session, EQUAL, left, other.right);\n-                } else if (!(lc && l2c) && r.equals(r2)) {\n-                    return new Comparison(session, EQUAL, left, other.left);\n-                }\n-            } else {\n-                // a=b OR a=c\n-                Database db = session.getDatabase();\n-                if (rc && r2c && l.equals(l2)) {\n-                    return new ConditionIn(db, left,\n-                            New.arrayList(Arrays.asList(right, other.right)));\n-                } else if (rc && l2c && l.equals(r2)) {\n-                    return new ConditionIn(db, left,\n-                            New.arrayList(Arrays.asList(right, other.left)));\n-                } else if (lc && r2c && r.equals(l2)) {\n-                    return new ConditionIn(db, right,\n-                            New.arrayList(Arrays.asList(left, other.right)));\n-                } else if (lc && l2c && r.equals(r2)) {\n-                    return new ConditionIn(db, right,\n-                            New.arrayList(Arrays.asList(left, other.left)));\n-                }\n-            }\n-        }\n-        return null;\n+  @Override\n+  public void updateAggregate(Session session) {\n+    left.updateAggregate(session);\n+    if (right != null) {\n+      right.updateAggregate(session);\n     }\n-\n-    /**\n-     * Get the left or the right sub-expression of this condition.\n-     *\n-     * @param getLeft true to get the left sub-expression, false to get the\n-     *            right sub-expression.\n-     * @return the sub-expression\n-     */\n-    public Expression getExpression(boolean getLeft) {\n-        return getLeft ? this.left : right;\n+  }\n+\n+  @Override\n+  public void addFilterConditions(TableFilter filter, boolean outerJoin) {\n+    if (compareType == IS_NULL && outerJoin) {\n+      // can not optimize:\n+      // select * from test t1 left join test t2 on t1.id = t2.id\n+      // where t2.id is null\n+      // to\n+      // select * from test t1 left join test t2\n+      // on t1.id = t2.id and t2.id is null\n+      return;\n+    }\n+    super.addFilterConditions(filter, outerJoin);\n+  }\n+\n+  @Override\n+  public void mapColumns(ColumnResolver resolver, int level) {\n+    left.mapColumns(resolver, level);\n+    if (right != null) {\n+      right.mapColumns(resolver, level);\n+    }\n+  }\n+\n+  @Override\n+  public boolean isEverything(ExpressionVisitor visitor) {\n+    return left.isEverything(visitor) &&\n+        (right == null || right.isEverything(visitor));\n+  }\n+\n+  @Override\n+  public int getCost() {\n+    return left.getCost() + (right == null ? 0 : right.getCost()) + 1;\n+  }\n+\n+  /**\n+   * Get the other expression if this is an equals comparison and the other\n+   * expression matches.\n+   *\n+   * @param match the expression that should match\n+   * @return null if no match, the other expression if there is a match\n+   */\n+  Expression getIfEquals(Expression match) {\n+    if (compareType == EQUAL) {\n+      String sql = match.getSQL();\n+      if (left.getSQL().equals(sql)) {\n+        return right;\n+      } else if (right.getSQL().equals(sql)) {\n+        return left;\n+      }\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * Get an additional condition if possible. Example: given two conditions\n+   * A=B AND B=C, the new condition A=C is returned. Given the two conditions\n+   * A=1 OR A=2, the new condition A IN(1, 2) is returned.\n+   *\n+   * @param session the session\n+   * @param other   the second condition\n+   * @param and     true for AND, false for OR\n+   * @return null or the third condition\n+   */\n+  Expression getAdditional(Session session, Comparison other, boolean and) {\n+    if (compareType == other.compareType && compareType == EQUAL) {\n+      boolean lc = left.isConstant();\n+      boolean rc = right.isConstant();\n+      boolean l2c = other.left.isConstant();\n+      boolean r2c = other.right.isConstant();\n+      String l = left.getSQL();\n+      String l2 = other.left.getSQL();\n+      String r = right.getSQL();\n+      String r2 = other.right.getSQL();\n+      if (and) {\n+        // a=b AND a=c\n+        // must not compare constants. example: NOT(B=2 AND B=3)\n+        if (!(rc && r2c) && l.equals(l2)) {\n+          return new Comparison(session, EQUAL, right, other.right);\n+        } else if (!(rc && l2c) && l.equals(r2)) {\n+          return new Comparison(session, EQUAL, right, other.left);\n+        } else if (!(lc && r2c) && r.equals(l2)) {\n+          return new Comparison(session, EQUAL, left, other.right);\n+        } else if (!(lc && l2c) && r.equals(r2)) {\n+          return new Comparison(session, EQUAL, left, other.left);\n+        }\n+      } else {\n+        // a=b OR a=c\n+        Database db = session.getDatabase();\n+        if (rc && r2c && l.equals(l2)) {\n+          return new ConditionIn(db, left,\n+              New.arrayList(Arrays.asList(right, other.right)));\n+        } else if (rc && l2c && l.equals(r2)) {\n+          return new ConditionIn(db, left,\n+              New.arrayList(Arrays.asList(right, other.left)));\n+        } else if (lc && r2c && r.equals(l2)) {\n+          return new ConditionIn(db, right,\n+              New.arrayList(Arrays.asList(left, other.right)));\n+        } else if (lc && l2c && r.equals(r2)) {\n+          return new ConditionIn(db, right,\n+              New.arrayList(Arrays.asList(left, other.left)));\n+        }\n+      }\n     }\n+    return null;\n+  }\n+\n+  /**\n+   * Get the left or the right sub-expression of this condition.\n+   *\n+   * @param getLeft true to get the left sub-expression, false to get the\n+   *                right sub-expression.\n+   * @return the sub-expression\n+   */\n+  public Expression getExpression(boolean getLeft) {\n+    return getLeft ? this.left : right;\n+  }\n \n }\n",
            "diff_size": 795
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/257/Comparison.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/codebuff/257/Comparison.java\nindex 59b5358753e..11f360179c6 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/257/Comparison.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/codebuff/257/Comparison.java\n@@ -26,6 +26,8 @@ import org.h2.value.ValueNull;\n  * @author Noel Grandin\n  * @author Nicolas Fortin, Atelier SIG, IRSTV FR CNRS 24888\n  */\n+\n+\n public class Comparison extends Condition {\n \n     /**\n@@ -33,89 +35,118 @@ public class Comparison extends Condition {\n      * NULL even if one operand is NULL). Only EQUAL and NOT_EQUAL are supported\n      * currently.\n      */\n+\n+\n     public static final int NULL_SAFE = 16;\n \n     /**\n      * The comparison type meaning = as in ID=1.\n      */\n+\n+\n     public static final int EQUAL = 0;\n \n     /**\n      * The comparison type meaning ID IS 1 (ID IS NOT DISTINCT FROM 1).\n      */\n+\n+\n     public static final int EQUAL_NULL_SAFE = EQUAL | NULL_SAFE;\n \n     /**\n      * The comparison type meaning &gt;= as in ID&gt;=1.\n      */\n+\n+\n     public static final int BIGGER_EQUAL = 1;\n \n     /**\n      * The comparison type meaning &gt; as in ID&gt;1.\n      */\n+\n+\n     public static final int BIGGER = 2;\n \n     /**\n      * The comparison type meaning &lt;= as in ID&lt;=1.\n      */\n+\n+\n     public static final int SMALLER_EQUAL = 3;\n \n     /**\n      * The comparison type meaning &lt; as in ID&lt;1.\n      */\n+\n+\n     public static final int SMALLER = 4;\n \n     /**\n      * The comparison type meaning &lt;&gt; as in ID&lt;&gt;1.\n      */\n+\n+\n     public static final int NOT_EQUAL = 5;\n \n     /**\n      * The comparison type meaning ID IS NOT 1 (ID IS DISTINCT FROM 1).\n      */\n+\n+\n     public static final int NOT_EQUAL_NULL_SAFE = NOT_EQUAL | NULL_SAFE;\n \n     /**\n      * The comparison type meaning IS NULL as in NAME IS NULL.\n      */\n+\n+\n     public static final int IS_NULL = 6;\n \n     /**\n      * The comparison type meaning IS NOT NULL as in NAME IS NOT NULL.\n      */\n+\n+\n     public static final int IS_NOT_NULL = 7;\n \n     /**\n      * This is a pseudo comparison type that is only used for index conditions.\n      * It means the comparison will always yield FALSE. Example: 1=0.\n      */\n+\n+\n     public static final int FALSE = 8;\n \n     /**\n      * This is a pseudo comparison type that is only used for index conditions.\n      * It means equals any value of a list. Example: IN(1, 2, 3).\n      */\n+\n+\n     public static final int IN_LIST = 9;\n \n     /**\n      * This is a pseudo comparison type that is only used for index conditions.\n      * It means equals any value of a list. Example: IN(SELECT ...).\n      */\n+\n+\n     public static final int IN_QUERY = 10;\n \n     /**\n      * This is a comparison type that is only used for spatial index\n      * conditions (operator \"&&\").\n      */\n-    public static final int SPATIAL_INTERSECTS = 11;\n \n+\n+    public static final int SPATIAL_INTERSECTS = 11;\n     private final Database database;\n     private int compareType;\n     private Expression left;\n     private Expression right;\n \n-    public Comparison(Session session, int compareType, Expression left,\n-            Expression right) {\n+    public Comparison(Session session, int compareType,\n+        Expression left, Expression right) {\n         this.database = session.getDatabase();\n         this.left = left;\n         this.right = right;\n@@ -133,11 +164,12 @@ public class Comparison extends Condition {\n             sql = left.getSQL() + \" IS NOT NULL\";\n             break;\n         case SPATIAL_INTERSECTS:\n-            sql = \"INTERSECTS(\" + left.getSQL() + \", \" + right.getSQL() + \")\";\n+            sql = \"INTERSECTS(\" + left.getSQL() + \", \"\n+            + right.getSQL() + \")\";\n             break;\n         default:\n-            sql = left.getSQL() + \" \" + getCompareOperator(compareType) +\n-                    \" \" + right.getSQL();\n+            sql = left.getSQL() + \" \"\n+            + getCompareOperator(compareType) + \" \" + right.getSQL();\n         }\n         return \"(\" + sql + \")\";\n     }\n@@ -148,6 +180,8 @@ public class Comparison extends Condition {\n      * @param compareType the compare type\n      * @return the string\n      */\n+\n+\n     static String getCompareOperator(int compareType) {\n         switch (compareType) {\n         case EQUAL:\n@@ -179,8 +213,8 @@ public class Comparison extends Condition {\n         if (right != null) {\n             right = right.optimize(session);\n             if (right instanceof ExpressionColumn) {\n-            \t//\u4f8b\u5982delete top 3 from DeleteTest where 'a1'> name\n-            \t//\u8f6c\u6210delete top 3 from DeleteTest where name < 'a1'\n+                //\u4f8b\u5982delete top 3 from DeleteTest where 'a1'> name\n+                //\u8f6c\u6210delete top 3 from DeleteTest where name < 'a1'\n                 if (left.isConstant() || left instanceof Parameter) {\n                     Expression temp = left;\n                     left = right;\n@@ -192,7 +226,7 @@ public class Comparison extends Condition {\n                 if (right.isConstant()) {\n                     Value r = right.getValue(session);\n                     if (r == ValueNull.INSTANCE) {\n-                    \t//\u4f8b\u5982: \"delete top 3 from DeleteTest where name = null\n+                        //\u4f8b\u5982: \"delete top 3 from DeleteTest where name = null\n                         if ((compareType & NULL_SAFE) == 0) {\n                             return ValueExpression.getNull();\n                         }\n@@ -207,8 +241,7 @@ public class Comparison extends Condition {\n                         right = ValueExpression.get(r.convertTo(resType));\n                     }\n                 } else if (right instanceof Parameter) {\n-                    ((Parameter) right).setColumn(\n-                            ((ExpressionColumn) left).getColumn());\n+                    ((Parameter) right).setColumn(((ExpressionColumn) left).getColumn());\n                 }\n             }\n         }\n@@ -220,8 +253,7 @@ public class Comparison extends Condition {\n             if (SysProperties.CHECK && (left == null || right == null)) {\n                 DbException.throwInternalError(left + \" \" + right);\n             }\n-            if (left == ValueExpression.getNull() ||\n-                    right == ValueExpression.getNull()) {\n+            if (left == ValueExpression.getNull() || right == ValueExpression.getNull()) {\n                 // TODO NULL handling: maybe issue a warning when comparing with\n                 // a NULL constants\n                 if ((compareType & NULL_SAFE) == 0) {\n@@ -280,8 +312,9 @@ public class Comparison extends Condition {\n      * @return true if the comparison indicated by the comparison type evaluates\n      *         to true\n      */\n-    static boolean compareNotNull(Database database, Value l, Value r,\n-            int compareType) {\n+\n+\n+    static boolean compareNotNull(Database database, Value l, Value r, int compareType) {\n         boolean result;\n         switch (compareType) {\n         case EQUAL:\n@@ -390,10 +423,7 @@ public class Comparison extends Condition {\n                 switch (compareType) {\n                 case IS_NULL:\n                     if (session.getDatabase().getSettings().optimizeIsNull) {\n-                        filter.addIndexCondition(\n-                                IndexCondition.get(\n-                                        Comparison.EQUAL_NULL_SAFE, l,\n-                                        ValueExpression.getNull()));\n+                        filter.addIndexCondition(IndexCondition.get(Comparison.EQUAL_NULL_SAFE, l, ValueExpression.getNull()));\n                     }\n                 }\n             }\n@@ -414,18 +444,16 @@ public class Comparison extends Condition {\n             return;\n         }\n         if (l == null) {\n-            ExpressionVisitor visitor =\n-                    ExpressionVisitor.getNotFromResolverVisitor(filter);\n+            ExpressionVisitor visitor = ExpressionVisitor.getNotFromResolverVisitor(filter);\n             if (!left.isEverything(visitor)) {\n                 return;\n             }\n         } else if (r == null) {\n-            ExpressionVisitor visitor =\n-                    ExpressionVisitor.getNotFromResolverVisitor(filter);\n+            ExpressionVisitor visitor = ExpressionVisitor.getNotFromResolverVisitor(filter);\n             if (!right.isEverything(visitor)) {\n                 return;\n             }\n-        } else {\n+                                                                           } else {\n             // if both sides are part of the same filter, it can't be used for\n             // index lookup\n             return;\n@@ -450,12 +478,10 @@ public class Comparison extends Condition {\n         }\n         if (addIndex) {\n             if (l != null) {\n-                filter.addIndexCondition(\n-                        IndexCondition.get(compareType, l, right));\n+                filter.addIndexCondition(IndexCondition.get(compareType, l, right));\n             } else if (r != null) {\n                 int compareRev = getReversedCompareType(compareType);\n-                filter.addIndexCondition(\n-                        IndexCondition.get(compareRev, r, left));\n+                filter.addIndexCondition(IndexCondition.get(compareRev, r, left));\n             }\n         }\n     }\n@@ -500,8 +526,7 @@ public class Comparison extends Condition {\n \n     @Override\n     public boolean isEverything(ExpressionVisitor visitor) {\n-        return left.isEverything(visitor) &&\n-                (right == null || right.isEverything(visitor));\n+        return left.isEverything(visitor) && (right == null || right.isEverything(visitor));\n     }\n \n     @Override\n@@ -516,6 +541,8 @@ public class Comparison extends Condition {\n      * @param match the expression that should match\n      * @return null if no match, the other expression if there is a match\n      */\n+\n+\n     Expression getIfEquals(Expression match) {\n         if (compareType == EQUAL) {\n             String sql = match.getSQL();\n@@ -538,6 +565,8 @@ public class Comparison extends Condition {\n      * @param and true for AND, false for OR\n      * @return null or the third condition\n      */\n+\n+\n     Expression getAdditional(Session session, Comparison other, boolean and) {\n         if (compareType == other.compareType && compareType == EQUAL) {\n             boolean lc = left.isConstant();\n@@ -555,27 +584,23 @@ public class Comparison extends Condition {\n                     return new Comparison(session, EQUAL, right, other.right);\n                 } else if (!(rc && l2c) && l.equals(r2)) {\n                     return new Comparison(session, EQUAL, right, other.left);\n-                } else if (!(lc && r2c) && r.equals(l2)) {\n+                     } else if (!(lc && r2c) && r.equals(l2)) {\n                     return new Comparison(session, EQUAL, left, other.right);\n                 } else if (!(lc && l2c) && r.equals(r2)) {\n-                    return new Comparison(session, EQUAL, left, other.left);\n-                }\n+                                return new Comparison(session, EQUAL, left, other.left);\n+                            }\n             } else {\n                 // a=b OR a=c\n                 Database db = session.getDatabase();\n                 if (rc && r2c && l.equals(l2)) {\n-                    return new ConditionIn(db, left,\n-                            New.arrayList(Arrays.asList(right, other.right)));\n+                    return new ConditionIn(db, left, New.arrayList(Arrays.asList(right, other.right)));\n                 } else if (rc && l2c && l.equals(r2)) {\n-                    return new ConditionIn(db, left,\n-                            New.arrayList(Arrays.asList(right, other.left)));\n-                } else if (lc && r2c && r.equals(l2)) {\n-                    return new ConditionIn(db, right,\n-                            New.arrayList(Arrays.asList(left, other.right)));\n+                    return new ConditionIn(db, left, New.arrayList(Arrays.asList(right, other.left)));\n+                   } else if (lc && r2c && r.equals(l2)) {\n+                    return new ConditionIn(db, right, New.arrayList(Arrays.asList(left, other.right)));\n                 } else if (lc && l2c && r.equals(r2)) {\n-                    return new ConditionIn(db, right,\n-                            New.arrayList(Arrays.asList(left, other.left)));\n-                }\n+                              return new ConditionIn(db, right, New.arrayList(Arrays.asList(left, other.left)));\n+                          }\n             }\n         }\n         return null;\n@@ -588,8 +613,10 @@ public class Comparison extends Condition {\n      *            right sub-expression.\n      * @return the sub-expression\n      */\n+\n+\n     public Expression getExpression(boolean getLeft) {\n         return getLeft ? this.left : right;\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 86
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "195",
                    "column": "21",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/257/Comparison.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_random/257/Comparison.java\nindex 59b5358753e..d23687c6f8f 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/257/Comparison.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_random/257/Comparison.java\n@@ -179,8 +179,8 @@ public class Comparison extends Condition {\n         if (right != null) {\n             right = right.optimize(session);\n             if (right instanceof ExpressionColumn) {\n-            \t//\u4f8b\u5982delete top 3 from DeleteTest where 'a1'> name\n-            \t//\u8f6c\u6210delete top 3 from DeleteTest where name < 'a1'\n+            //\u4f8b\u5982delete top 3 from DeleteTest where 'a1'> name\n+             //\u8f6c\u6210delete top 3 from DeleteTest where name < 'a1'\n                 if (left.isConstant() || left instanceof Parameter) {\n                     Expression temp = left;\n                     left = right;\n",
            "diff_size": 2
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "195",
                    "column": "21",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/257/Comparison.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/257/Comparison.java\nindex 59b5358753e..21f3ba7c74a 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/257/Comparison.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/257/Comparison.java\n@@ -179,8 +179,8 @@ public class Comparison extends Condition {\n         if (right != null) {\n             right = right.optimize(session);\n             if (right instanceof ExpressionColumn) {\n-            \t//\u4f8b\u5982delete top 3 from DeleteTest where 'a1'> name\n-            \t//\u8f6c\u6210delete top 3 from DeleteTest where name < 'a1'\n+                //\u4f8b\u5982delete top 3 from DeleteTest where 'a1'> name\n+             //\u8f6c\u6210delete top 3 from DeleteTest where name < 'a1'\n                 if (left.isConstant() || left instanceof Parameter) {\n                     Expression temp = left;\n                     left = right;\n",
            "diff_size": 2
        }
    ],
    "repaired_by": [
        "intellij",
        "codebuff"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "styler_random",
        "styler_three_grams"
    ]
}