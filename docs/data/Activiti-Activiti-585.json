{
    "project_name": "Activiti-Activiti",
    "error_id": "585",
    "information": {
        "errors": [
            {
                "line": "16",
                "severity": "error",
                "message": "'package' should be separated from previous statement.",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.EmptyLineSeparatorCheck"
            }
        ]
    },
    "source_code": " * limitations under the License.\n */\npackage org.activiti.runtime.api.impl;\n\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.fasterxml.jackson.databind.ObjectMapper;",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Activiti-Activiti/errored/1/585/ExpressionResolver.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Activiti-Activiti/styler/585/ExpressionResolver.java\nindex 355448fddd0..7f08ba22da0 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Activiti-Activiti/errored/1/585/ExpressionResolver.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Activiti-Activiti/styler/585/ExpressionResolver.java\n@@ -13,6 +13,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+\n package org.activiti.runtime.api.impl;\n \n import com.fasterxml.jackson.core.type.TypeReference;\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Activiti-Activiti/errored/1/585/ExpressionResolver.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Activiti-Activiti/intellij/585/ExpressionResolver.java\nindex 355448fddd0..3d0fa83ff56 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Activiti-Activiti/errored/1/585/ExpressionResolver.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Activiti-Activiti/intellij/585/ExpressionResolver.java\n@@ -13,6 +13,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+\n package org.activiti.runtime.api.impl;\n \n import com.fasterxml.jackson.core.type.TypeReference;\n@@ -49,8 +50,8 @@ public class ExpressionResolver {\n     private ExpressionManager expressionManager;\n \n     public ExpressionResolver(ExpressionManager expressionManager,\n-        ObjectMapper mapper,\n-        DelegateInterceptor delegateInterceptor) {\n+                              ObjectMapper mapper,\n+                              DelegateInterceptor delegateInterceptor) {\n         this.expressionManager = expressionManager;\n         this.mapper = mapper;\n         this.delegateInterceptor = delegateInterceptor;\n@@ -60,17 +61,17 @@ public class ExpressionResolver {\n                                       final Object value) {\n         if (value instanceof String) {\n             return resolveExpressionsString(expressionEvaluator,\n-                                            (String) value);\n+                    (String) value);\n         } else if (value instanceof ObjectNode) {\n             return resolveExpressionsMap(expressionEvaluator,\n-                                         mapper.convertValue(value,\n-                                                             MAP_STRING_OBJECT_TYPE));\n+                    mapper.convertValue(value,\n+                            MAP_STRING_OBJECT_TYPE));\n         } else if (value instanceof Map<?, ?>) {\n             return resolveExpressionsMap(expressionEvaluator,\n-                                         (Map<String, ?>) value);\n+                    (Map<String, ?>) value);\n         } else if (value instanceof List<?>) {\n             return resolveExpressionsList(expressionEvaluator,\n-                                          (List<?>) value);\n+                    (List<?>) value);\n         } else {\n             return value;\n         }\n@@ -80,7 +81,7 @@ public class ExpressionResolver {\n                                                 final List<?> sourceList) {\n         final List<Object> result = new LinkedList<>();\n         sourceList.forEach(value -> result.add(resolveExpressions(expressionEvaluator,\n-                                                                  value)));\n+                value)));\n         return result;\n     }\n \n@@ -89,8 +90,8 @@ public class ExpressionResolver {\n         final Map<String, Object> result = new LinkedHashMap<>();\n         sourceMap.forEach((key,\n                            value) -> result.put(key,\n-                                                resolveExpressions(expressionEvaluator,\n-                                                                   value)));\n+                resolveExpressions(expressionEvaluator,\n+                        value)));\n         return result;\n     }\n \n@@ -101,10 +102,10 @@ public class ExpressionResolver {\n         }\n         if (sourceString.matches(EXPRESSION_PATTERN_STRING)) {\n             return resolveObjectPlaceHolder(expressionEvaluator,\n-                                            sourceString);\n+                    sourceString);\n         } else {\n             return resolveInStringPlaceHolder(expressionEvaluator,\n-                                              sourceString);\n+                    sourceString);\n         }\n     }\n \n@@ -112,10 +113,10 @@ public class ExpressionResolver {\n                                             String sourceString) {\n         try {\n             return expressionEvaluator.evaluate(expressionManager.createExpression(sourceString), expressionManager,\n-                delegateInterceptor);\n+                    delegateInterceptor);\n         } catch (final Exception e) {\n             logger.warn(\"Unable to resolve expression in variables, keeping original value\",\n-                        e);\n+                    e);\n             return sourceString;\n         }\n     }\n@@ -129,12 +130,12 @@ public class ExpressionResolver {\n             final Expression expression = expressionManager.createExpression(expressionKey);\n             try {\n                 final Object value = expressionEvaluator.evaluate(expression, expressionManager,\n-                    delegateInterceptor);\n+                        delegateInterceptor);\n                 matcher.appendReplacement(sb,\n-                                          Objects.toString(value));\n+                        Objects.toString(value));\n             } catch (final Exception e) {\n                 logger.warn(\"Unable to resolve expression in variables, keeping original value\",\n-                            e);\n+                        e);\n             }\n         }\n         matcher.appendTail(sb);\n@@ -148,7 +149,7 @@ public class ExpressionResolver {\n             return containsExpressionString((String) source);\n         } else if (source instanceof ObjectNode) {\n             return containsExpressionMap(mapper.convertValue(source,\n-                                                             MAP_STRING_OBJECT_TYPE));\n+                    MAP_STRING_OBJECT_TYPE));\n         } else if (source instanceof Map<?, ?>) {\n             return containsExpressionMap((Map<String, ?>) source);\n         } else if (source instanceof List<?>) {\n",
            "diff_size": 19
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "16",
                    "severity": "error",
                    "message": "'package' should be separated from previous statement.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.EmptyLineSeparatorCheck"
                },
                {
                    "line": "37",
                    "severity": "error",
                    "message": "'CLASS_DEF' has more than 1 empty lines before.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.EmptyLineSeparatorCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Activiti-Activiti/errored/1/585/ExpressionResolver.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Activiti-Activiti/codebuff/585/ExpressionResolver.java\nindex 355448fddd0..99f823d3e7a 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Activiti-Activiti/errored/1/585/ExpressionResolver.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Activiti-Activiti/codebuff/585/ExpressionResolver.java\n@@ -33,150 +33,137 @@ import org.apache.commons.lang3.StringUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+\n public class ExpressionResolver {\n \n-    private static final TypeReference<Map<String, ?>> MAP_STRING_OBJECT_TYPE = new TypeReference<Map<String, ?>>() {\n-    };\n-    private final Logger logger = LoggerFactory.getLogger(ExpressionResolver.class);\n+  private static final TypeReference<Map<String, ?>> MAP_STRING_OBJECT_TYPE = new TypeReference<Map<String, ?>>() {\n+                                                     };\n \n-    private static final String EXPRESSION_PATTERN_STRING = \"([\\\\$]\\\\{([^\\\\}]*)\\\\})\";\n-    private static final Pattern EXPRESSION_PATTERN = Pattern.compile(EXPRESSION_PATTERN_STRING);\n-    private static final int EXPRESSION_KEY_INDEX = 1;\n+  private final Logger logger = LoggerFactory.getLogger(ExpressionResolver.class);\n \n-    private ObjectMapper mapper;\n-    private final DelegateInterceptor delegateInterceptor;\n+  private static final String EXPRESSION_PATTERN_STRING = \"([\\\\$]\\\\{([^\\\\}]*)\\\\})\";\n \n-    private ExpressionManager expressionManager;\n+  private static final Pattern EXPRESSION_PATTERN = Pattern.compile(EXPRESSION_PATTERN_STRING);\n \n-    public ExpressionResolver(ExpressionManager expressionManager,\n-        ObjectMapper mapper,\n-        DelegateInterceptor delegateInterceptor) {\n-        this.expressionManager = expressionManager;\n-        this.mapper = mapper;\n-        this.delegateInterceptor = delegateInterceptor;\n-    }\n+  private static final int EXPRESSION_KEY_INDEX = 1;\n \n-    private Object resolveExpressions(final ExpressionEvaluator expressionEvaluator,\n-                                      final Object value) {\n-        if (value instanceof String) {\n-            return resolveExpressionsString(expressionEvaluator,\n-                                            (String) value);\n-        } else if (value instanceof ObjectNode) {\n-            return resolveExpressionsMap(expressionEvaluator,\n-                                         mapper.convertValue(value,\n-                                                             MAP_STRING_OBJECT_TYPE));\n-        } else if (value instanceof Map<?, ?>) {\n-            return resolveExpressionsMap(expressionEvaluator,\n-                                         (Map<String, ?>) value);\n-        } else if (value instanceof List<?>) {\n-            return resolveExpressionsList(expressionEvaluator,\n-                                          (List<?>) value);\n-        } else {\n-            return value;\n-        }\n-    }\n+  private ObjectMapper mapper;\n \n-    private List<Object> resolveExpressionsList(final ExpressionEvaluator expressionEvaluator,\n-                                                final List<?> sourceList) {\n-        final List<Object> result = new LinkedList<>();\n-        sourceList.forEach(value -> result.add(resolveExpressions(expressionEvaluator,\n-                                                                  value)));\n-        return result;\n-    }\n+  private final DelegateInterceptor delegateInterceptor;\n \n-    public Map<String, Object> resolveExpressionsMap(final ExpressionEvaluator expressionEvaluator,\n-                                                     final Map<String, ?> sourceMap) {\n-        final Map<String, Object> result = new LinkedHashMap<>();\n-        sourceMap.forEach((key,\n-                           value) -> result.put(key,\n-                                                resolveExpressions(expressionEvaluator,\n-                                                                   value)));\n-        return result;\n-    }\n+  private ExpressionManager expressionManager;\n \n-    private Object resolveExpressionsString(final ExpressionEvaluator expressionEvaluator,\n-                                            final String sourceString) {\n-        if (StringUtils.isBlank(sourceString)) {\n-            return sourceString;\n-        }\n-        if (sourceString.matches(EXPRESSION_PATTERN_STRING)) {\n-            return resolveObjectPlaceHolder(expressionEvaluator,\n-                                            sourceString);\n-        } else {\n-            return resolveInStringPlaceHolder(expressionEvaluator,\n-                                              sourceString);\n-        }\n-    }\n+  public ExpressionResolver(ExpressionManager expressionManager, ObjectMapper mapper, DelegateInterceptor delegateInterceptor) {\n+    this.expressionManager = expressionManager;\n+    this.mapper = mapper;\n+    this.delegateInterceptor = delegateInterceptor;\n+  }\n \n-    private Object resolveObjectPlaceHolder(ExpressionEvaluator expressionEvaluator,\n-                                            String sourceString) {\n-        try {\n-            return expressionEvaluator.evaluate(expressionManager.createExpression(sourceString), expressionManager,\n-                delegateInterceptor);\n-        } catch (final Exception e) {\n-            logger.warn(\"Unable to resolve expression in variables, keeping original value\",\n-                        e);\n-            return sourceString;\n-        }\n-    }\n+  private Object resolveExpressions(final ExpressionEvaluator expressionEvaluator, final Object value) {\n+    if (value instanceof String) {\n+      return resolveExpressionsString(expressionEvaluator, (String) value);\n+    } else if (value instanceof ObjectNode) {\n+      return resolveExpressionsMap(expressionEvaluator,\n+                                   mapper.convertValue(value, MAP_STRING_OBJECT_TYPE));\n+    } else if (value instanceof Map<?, ?>) {\n+      return resolveExpressionsMap(expressionEvaluator, (Map<String, ?>) value);\n+           } else if (value instanceof List<?>) {\n+             return resolveExpressionsList(expressionEvaluator, (List<?>) value);\n+           } else {\n+             return value;\n+           }\n+  }\n \n-    private String resolveInStringPlaceHolder(final ExpressionEvaluator expressionEvaluator,\n-                                              final String sourceString) {\n-        final Matcher matcher = EXPRESSION_PATTERN.matcher(sourceString);\n-        final StringBuffer sb = new StringBuffer();\n-        while (matcher.find()) {\n-            final String expressionKey = matcher.group(EXPRESSION_KEY_INDEX);\n-            final Expression expression = expressionManager.createExpression(expressionKey);\n-            try {\n-                final Object value = expressionEvaluator.evaluate(expression, expressionManager,\n-                    delegateInterceptor);\n-                matcher.appendReplacement(sb,\n-                                          Objects.toString(value));\n-            } catch (final Exception e) {\n-                logger.warn(\"Unable to resolve expression in variables, keeping original value\",\n-                            e);\n-            }\n-        }\n-        matcher.appendTail(sb);\n-        return sb.toString();\n-    }\n+  private List<Object> resolveExpressionsList(final ExpressionEvaluator expressionEvaluator, final List<?> sourceList) {\n+    final List<Object> result = new LinkedList<>();\n+    sourceList.forEach(value -> result.add(resolveExpressions(expressionEvaluator, value)));\n+    return result;\n+  }\n \n-    public boolean containsExpression(final Object source) {\n-        if (source == null) {\n-            return false;\n-        } else if (source instanceof String) {\n-            return containsExpressionString((String) source);\n-        } else if (source instanceof ObjectNode) {\n-            return containsExpressionMap(mapper.convertValue(source,\n-                                                             MAP_STRING_OBJECT_TYPE));\n-        } else if (source instanceof Map<?, ?>) {\n-            return containsExpressionMap((Map<String, ?>) source);\n-        } else if (source instanceof List<?>) {\n-            return containsExpressionList((List<?>) source);\n-        } else {\n-            return false;\n-        }\n-    }\n+  public Map<String, Object> resolveExpressionsMap(final ExpressionEvaluator expressionEvaluator, final Map<String, ?> sourceMap) {\n+    final Map<String, Object> result = new LinkedHashMap<>();\n+    sourceMap.forEach((key,value) -> result.put(key,\n+                                                resolveExpressions(expressionEvaluator, value)));\n+    return result;\n+  }\n \n-    private boolean containsExpressionString(final String sourceString) {\n-        return EXPRESSION_PATTERN.matcher(sourceString).find();\n+  private Object resolveExpressionsString(final ExpressionEvaluator expressionEvaluator, final String sourceString) {\n+    if (StringUtils.isBlank(sourceString)) {\n+      return sourceString;\n     }\n-\n-    private boolean containsExpressionMap(final Map<String, ?> source) {\n-        for (Entry<String, ?> entry : source.entrySet()) {\n-            if (containsExpression(entry.getValue())) {\n-                return true;\n-            }\n-        }\n-        return false;\n+    if (sourceString.matches(EXPRESSION_PATTERN_STRING)) {\n+      return resolveObjectPlaceHolder(expressionEvaluator, sourceString);\n+    } else {\n+      return resolveInStringPlaceHolder(expressionEvaluator, sourceString);\n     }\n-\n-    private boolean containsExpressionList(List<?> source) {\n-        for (Object item : source) {\n-            if (containsExpression(item)) {\n-                return true;\n-            }\n-        }\n-        return false;\n+  }\n+\n+  private Object resolveObjectPlaceHolder(ExpressionEvaluator expressionEvaluator, String sourceString) {\n+    try {\n+      return expressionEvaluator.evaluate(expressionManager.createExpression(sourceString), expressionManager, delegateInterceptor);\n+    } catch (final Exception e) {\n+      logger.warn(\"Unable to resolve expression in variables, keeping original value\",\n+                  e);\n+      return sourceString;\n+    }\n+  }\n+\n+  private String resolveInStringPlaceHolder(final ExpressionEvaluator expressionEvaluator, final String sourceString) {\n+    final Matcher matcher = EXPRESSION_PATTERN.matcher(sourceString);\n+    final StringBuffer sb = new StringBuffer();\n+    while (matcher.find()) {\n+      final String expressionKey = matcher.group(EXPRESSION_KEY_INDEX);\n+      final Expression expression = expressionManager.createExpression(expressionKey);\n+      try {\n+        final Object value = expressionEvaluator.evaluate(expression,\n+                                                          expressionManager,\n+                                                          delegateInterceptor);\n+        matcher.appendReplacement(sb, Objects.toString(value));\n+      } catch (final Exception e) {\n+        logger.warn(\"Unable to resolve expression in variables, keeping original value\",\n+                    e);\n+      }\n     }\n-}\n+    matcher.appendTail(sb);\n+    return sb.toString();\n+  }\n+\n+  public boolean containsExpression(final Object source) {\n+    if (source == null) {\n+      return false;\n+    } else if (source instanceof String) {\n+      return containsExpressionString((String) source);\n+    } else if (source instanceof ObjectNode) {\n+      return containsExpressionMap(mapper.convertValue(source, MAP_STRING_OBJECT_TYPE));\n+           } else if (source instanceof Map<?, ?>) {\n+             return containsExpressionMap((Map<String, ?>) source);\n+           } else if (source instanceof List<?>) {\n+             return containsExpressionList((List<?>) source);\n+                  } else {\n+                    return false;\n+                  }\n+  }\n+\n+  private boolean containsExpressionString(final String sourceString) {\n+    return EXPRESSION_PATTERN.matcher(sourceString).find();\n+  }\n+\n+  private boolean containsExpressionMap(final Map<String, ?> source) {\n+    for (Entry<String, ?> entry : source.entrySet()) {\n+      if (containsExpression(entry.getValue())) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private boolean containsExpressionList(List<?> source) {\n+    for (Object item : source) {\n+      if (containsExpression(item)) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+}\n\\ No newline at end of file\n",
            "diff_size": 196
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Activiti-Activiti/errored/1/585/ExpressionResolver.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Activiti-Activiti/styler_random/585/ExpressionResolver.java\nindex 355448fddd0..7f08ba22da0 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Activiti-Activiti/errored/1/585/ExpressionResolver.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Activiti-Activiti/styler_random/585/ExpressionResolver.java\n@@ -13,6 +13,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+\n package org.activiti.runtime.api.impl;\n \n import com.fasterxml.jackson.core.type.TypeReference;\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Activiti-Activiti/errored/1/585/ExpressionResolver.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Activiti-Activiti/styler_three_grams/585/ExpressionResolver.java\nindex 355448fddd0..7f08ba22da0 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Activiti-Activiti/errored/1/585/ExpressionResolver.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Activiti-Activiti/styler_three_grams/585/ExpressionResolver.java\n@@ -13,6 +13,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+\n package org.activiti.runtime.api.impl;\n \n import com.fasterxml.jackson.core.type.TypeReference;\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "naturalize",
        "codebuff"
    ]
}