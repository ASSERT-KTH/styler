{
    "project_name": "h2database-h2database",
    "error_id": "121",
    "information": {
        "errors": [
            {
                "line": "917",
                "column": "33",
                "severity": "warning",
                "message": "Don't use trailing comments.",
                "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
            }
        ]
    },
    "source_code": "                    WeakReference<V> reference = e.reference;\n                    if (reference != null && reference.get() != null) {\n                        break;  // stop trimming if entry holds a value\n                    }\n                }\n                int hash = getHash(e.key);",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/errored/1/121/CacheLongKeyLIRS.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/styler/121/CacheLongKeyLIRS.java\nindex b4701228336..ebb1871c0b0 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/errored/1/121/CacheLongKeyLIRS.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/styler/121/CacheLongKeyLIRS.java\n@@ -914,8 +914,9 @@ public class CacheLongKeyLIRS<V> {\n                 if (queue2Size <= maxQueue2SizeHigh) {\n                     WeakReference<V> reference = e.reference;\n                     if (reference != null && reference.get() != null) {\n-                        break;  // stop trimming if entry holds a value\n-                    }\n+                        break;\n+                    // stop trimming if entry holds a value\n+                      }\n                 }\n                 int hash = getHash(e.key);\n                 remove(e.key, hash);\n",
            "diff_size": 3
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "923",
                    "column": "33",
                    "severity": "warning",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/errored/1/121/CacheLongKeyLIRS.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/intellij/121/CacheLongKeyLIRS.java\nindex b4701228336..17cb46d5cba 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/errored/1/121/CacheLongKeyLIRS.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/intellij/121/CacheLongKeyLIRS.java\n@@ -3,6 +3,7 @@\n  * and the EPL 1.0 (https://h2database.com/html/license.html).\n  * Initial Developer: H2 Group\n  */\n+\n package org.h2.mvstore.cache;\n \n import java.lang.ref.WeakReference;\n@@ -40,8 +41,8 @@ import org.h2.mvstore.DataUtils;\n  * Write access and moving entries to the top of the stack is synchronized per\n  * segment.\n  *\n- * @author Thomas Mueller\n  * @param <V> the value type\n+ * @author Thomas Mueller\n  */\n public class CacheLongKeyLIRS<V> {\n \n@@ -71,7 +72,8 @@ public class CacheLongKeyLIRS<V> {\n         this.nonResidentQueueSizeHigh = config.nonResidentQueueSizeHigh;\n         DataUtils.checkArgument(\n                 Integer.bitCount(config.segmentCount) == 1,\n-                \"The segment count must be a power of 2, is {0}\", config.segmentCount);\n+                \"The segment count must be a power of 2, is {0}\",\n+                config.segmentCount);\n         this.segmentCount = config.segmentCount;\n         this.segmentMask = segmentCount - 1;\n         this.stackMoveDistance = config.stackMoveDistance;\n@@ -87,13 +89,15 @@ public class CacheLongKeyLIRS<V> {\n     public void clear() {\n         long max = getMaxItemSize();\n         for (int i = 0; i < segmentCount; i++) {\n-            segments[i] = new Segment<>(max, stackMoveDistance, 8, nonResidentQueueSize,\n-                                        nonResidentQueueSizeHigh);\n+            segments[i] = new Segment<>(max, stackMoveDistance, 8,\n+                    nonResidentQueueSize,\n+                    nonResidentQueueSizeHigh);\n         }\n     }\n \n     /**\n      * Determines max size of the data item size to fit into cache\n+     *\n      * @return data items size limit\n      */\n     public long getMaxItemSize() {\n@@ -132,7 +136,7 @@ public class CacheLongKeyLIRS<V> {\n     /**\n      * Add an entry to the cache using the average memory size.\n      *\n-     * @param key the key (may not be null)\n+     * @param key   the key (may not be null)\n      * @param value the value (may not be null)\n      * @return the old value, or null if there was no resident entry\n      */\n@@ -145,8 +149,8 @@ public class CacheLongKeyLIRS<V> {\n      * cache yet. This method will usually mark unknown entries as cold and\n      * known entries as hot.\n      *\n-     * @param key the key (may not be null)\n-     * @param value the value (may not be null)\n+     * @param key    the key (may not be null)\n+     * @param value  the value (may not be null)\n      * @param memory the memory used for the given entry\n      * @return the old value, or null if there was no resident entry\n      */\n@@ -411,7 +415,7 @@ public class CacheLongKeyLIRS<V> {\n      * Get the list of keys. This method allows to read the internal state of\n      * the cache.\n      *\n-     * @param cold if true, only keys for the cold entries are returned\n+     * @param cold        if true, only keys for the cold entries are returned\n      * @param nonResident true for non-resident entries\n      * @return the key list\n      */\n@@ -604,12 +608,13 @@ public class CacheLongKeyLIRS<V> {\n \n         /**\n          * Create a new cache segment.\n-         *  @param maxMemory the maximum memory to use\n-         * @param stackMoveDistance the number of other entries to be moved to\n-         *        the top of the stack before moving an entry to the top\n-         * @param len the number of hash table buckets (must be a power of 2)\n-         * @param nonResidentQueueSize the non-resident queue size low watermark factor\n-         * @param nonResidentQueueSizeHigh  the non-resident queue size high watermark factor\n+         *\n+         * @param maxMemory                the maximum memory to use\n+         * @param stackMoveDistance        the number of other entries to be moved to\n+         *                                 the top of the stack before moving an entry to the top\n+         * @param len                      the number of hash table buckets (must be a power of 2)\n+         * @param nonResidentQueueSize     the non-resident queue size low watermark factor\n+         * @param nonResidentQueueSizeHigh the non-resident queue size high watermark factor\n          */\n         Segment(long maxMemory, int stackMoveDistance, int len,\n                 int nonResidentQueueSize, int nonResidentQueueSizeHigh) {\n@@ -781,9 +786,9 @@ public class CacheLongKeyLIRS<V> {\n          * cache yet. This method will usually mark unknown entries as cold and\n          * known entries as hot.\n          *\n-         * @param key the key (may not be null)\n-         * @param hash the hash\n-         * @param value the value (may not be null)\n+         * @param key    the key (may not be null)\n+         * @param hash   the hash\n+         * @param value  the value (may not be null)\n          * @param memory the memory used for the given entry\n          * @return the old value, or null if there was no resident entry\n          */\n@@ -828,7 +833,7 @@ public class CacheLongKeyLIRS<V> {\n          * Remove an entry. Both resident and non-resident entries can be\n          * removed.\n          *\n-         * @param key the key (may not be null)\n+         * @param key  the key (may not be null)\n          * @param hash the hash\n          * @return the old value, or null if there was no resident entry\n          */\n@@ -889,7 +894,8 @@ public class CacheLongKeyLIRS<V> {\n             // ensure there are not too many hot entries: right shift of 5 is\n             // division by 32, that means if there are only 1/32 (3.125%) or\n             // less cold entries, a hot entry needs to become cold\n-            while (queueSize <= ((mapSize - queue2Size) >>> 5) && stackSize > 0) {\n+            while (queueSize <= ((mapSize - queue2Size) >>> 5) &&\n+                    stackSize > 0) {\n                 convertOldestHotToCold();\n             }\n             // the oldest resident cold entries become non-resident\n@@ -958,7 +964,7 @@ public class CacheLongKeyLIRS<V> {\n         /**\n          * Try to find an entry in the map.\n          *\n-         * @param key the key\n+         * @param key  the key\n          * @param hash the hash\n          * @return the entry (might be a non-resident)\n          */\n@@ -1027,7 +1033,7 @@ public class CacheLongKeyLIRS<V> {\n          * Get the list of keys. This method allows to read the internal state\n          * of the cache.\n          *\n-         * @param cold if true, only keys for the cold entries are returned\n+         * @param cold        if true, only keys for the cold entries are returned\n          * @param nonResident true for non-resident entries\n          * @return the key list\n          */\n@@ -1036,12 +1042,12 @@ public class CacheLongKeyLIRS<V> {\n             if (cold) {\n                 Entry<V> start = nonResident ? queue2 : queue;\n                 for (Entry<V> e = start.queueNext; e != start;\n-                        e = e.queueNext) {\n+                     e = e.queueNext) {\n                     keys.add(e.key);\n                 }\n             } else {\n                 for (Entry<V> e = stack.stackNext; e != stack;\n-                        e = e.stackNext) {\n+                     e = e.stackNext) {\n                     keys.add(e.key);\n                 }\n             }\n@@ -1180,7 +1186,7 @@ public class CacheLongKeyLIRS<V> {\n     public static class Config {\n \n         /**\n-         *  The maximum memory to use (1 or larger).\n+         * The maximum memory to use (1 or larger).\n          */\n         public long maxMemory = 1;\n \n",
            "diff_size": 31
        },
        {
            "tool": "naturalize",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/errored/1/121/CacheLongKeyLIRS.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/naturalize/121/CacheLongKeyLIRS.java\nindex b4701228336..264c5d17825 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/errored/1/121/CacheLongKeyLIRS.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/naturalize/121/CacheLongKeyLIRS.java\n@@ -87,9 +87,8 @@ public class CacheLongKeyLIRS<V> {\n     public void clear() {\n         long max = getMaxItemSize();\n         for (int i = 0; i < segmentCount; i++) {\n-            segments[i] = new Segment<>(max, stackMoveDistance, 8, nonResidentQueueSize,\n-                                        nonResidentQueueSizeHigh);\n-        }\n+            segments[i] = new Segment<>(max, stackMoveDistance, 8, nonResidentQueueSize, nonResidentQueueSizeHigh);\n+    }\n     }\n \n     /**\n@@ -914,7 +913,8 @@ public class CacheLongKeyLIRS<V> {\n                 if (queue2Size <= maxQueue2SizeHigh) {\n                     WeakReference<V> reference = e.reference;\n                     if (reference != null && reference.get() != null) {\n-                        break;  // stop trimming if entry holds a value\n+                        break;\n+// stop trimming if entry holds a value\n                     }\n                 }\n                 int hash = getHash(e.key);\n@@ -1138,9 +1138,7 @@ public class CacheLongKeyLIRS<V> {\n          * The next entry in the map (the chained entry).\n          */\n         Entry<V> mapNext;\n-\n-\n-        Entry() {\n+Entry() {\n             this(0L, null, 0);\n         }\n \n@@ -1207,4 +1205,4 @@ public class CacheLongKeyLIRS<V> {\n          */\n         public final int nonResidentQueueSizeHigh = 12;\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 9
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "996",
                    "column": "33",
                    "severity": "warning",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/errored/1/121/CacheLongKeyLIRS.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/codebuff/121/CacheLongKeyLIRS.java\nindex b4701228336..283ec48ffe3 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/errored/1/121/CacheLongKeyLIRS.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/codebuff/121/CacheLongKeyLIRS.java\n@@ -43,15 +43,16 @@ import org.h2.mvstore.DataUtils;\n  * @author Thomas Mueller\n  * @param <V> the value type\n  */\n+\n+\n public class CacheLongKeyLIRS<V> {\n \n     /**\n      * The maximum memory this cache should use.\n      */\n-    private long maxMemory;\n \n+    private long maxMemory;\n     private final Segment<V>[] segments;\n-\n     private final int segmentCount;\n     private final int segmentShift;\n     private final int segmentMask;\n@@ -64,14 +65,13 @@ public class CacheLongKeyLIRS<V> {\n      *\n      * @param config the configuration\n      */\n+\n     @SuppressWarnings(\"unchecked\")\n     public CacheLongKeyLIRS(Config config) {\n         setMaxMemory(config.maxMemory);\n         this.nonResidentQueueSize = config.nonResidentQueueSize;\n         this.nonResidentQueueSizeHigh = config.nonResidentQueueSizeHigh;\n-        DataUtils.checkArgument(\n-                Integer.bitCount(config.segmentCount) == 1,\n-                \"The segment count must be a power of 2, is {0}\", config.segmentCount);\n+        DataUtils.checkArgument(Integer.bitCount(config.segmentCount) == 1, \"The segment count must be a power of 2, is {0}\", config.segmentCount);\n         this.segmentCount = config.segmentCount;\n         this.segmentMask = segmentCount - 1;\n         this.stackMoveDistance = config.stackMoveDistance;\n@@ -84,11 +84,12 @@ public class CacheLongKeyLIRS<V> {\n     /**\n      * Remove all entries.\n      */\n+\n+\n     public void clear() {\n         long max = getMaxItemSize();\n         for (int i = 0; i < segmentCount; i++) {\n-            segments[i] = new Segment<>(max, stackMoveDistance, 8, nonResidentQueueSize,\n-                                        nonResidentQueueSizeHigh);\n+            segments[i] = new Segment< >(max, stackMoveDistance, 8, nonResidentQueueSize, nonResidentQueueSizeHigh);\n         }\n     }\n \n@@ -96,6 +97,8 @@ public class CacheLongKeyLIRS<V> {\n      * Determines max size of the data item size to fit into cache\n      * @return data items size limit\n      */\n+\n+\n     public long getMaxItemSize() {\n         return Math.max(1, maxMemory / segmentCount);\n     }\n@@ -112,6 +115,8 @@ public class CacheLongKeyLIRS<V> {\n      * @param key the key (may not be null)\n      * @return true if there is a resident entry\n      */\n+\n+\n     public boolean containsKey(long key) {\n         Entry<V> e = find(key);\n         return e != null && e.value != null;\n@@ -124,6 +129,8 @@ public class CacheLongKeyLIRS<V> {\n      * @param key the key (may not be null)\n      * @return the value, or null if there is no resident entry\n      */\n+\n+\n     public V peek(long key) {\n         Entry<V> e = find(key);\n         return e == null ? null : e.getValue();\n@@ -136,6 +143,8 @@ public class CacheLongKeyLIRS<V> {\n      * @param value the value (may not be null)\n      * @return the old value, or null if there was no resident entry\n      */\n+\n+\n     public V put(long key, V value) {\n         return put(key, value, sizeOf(value));\n     }\n@@ -150,10 +159,11 @@ public class CacheLongKeyLIRS<V> {\n      * @param memory the memory used for the given entry\n      * @return the old value, or null if there was no resident entry\n      */\n+\n+\n     public V put(long key, V value, int memory) {\n         if (value == null) {\n-            throw DataUtils.newIllegalArgumentException(\n-                    \"The value may not be null\");\n+            throw DataUtils.newIllegalArgumentException(\"The value may not be null\");\n         }\n         int hash = getHash(key);\n         int segmentIndex = getSegmentIndex(hash);\n@@ -177,7 +187,7 @@ public class CacheLongKeyLIRS<V> {\n         Segment<V> s2 = segments[segmentIndex];\n         if (s == s2) {\n             // no other thread resized, so we do\n-            s = new Segment<>(s, newLen);\n+            s = new Segment< >(s, newLen);\n             segments[segmentIndex] = s;\n         }\n         return s;\n@@ -189,6 +199,7 @@ public class CacheLongKeyLIRS<V> {\n      * @param value the value\n      * @return the size\n      */\n+\n     @SuppressWarnings(\"unused\")\n     protected int sizeOf(V value) {\n         return 1;\n@@ -201,6 +212,8 @@ public class CacheLongKeyLIRS<V> {\n      * @param key the key (may not be null)\n      * @return the old value, or null if there was no resident entry\n      */\n+\n+\n     public V remove(long key) {\n         int hash = getHash(key);\n         int segmentIndex = getSegmentIndex(hash);\n@@ -220,6 +233,8 @@ public class CacheLongKeyLIRS<V> {\n      * @param key the key (may not be null)\n      * @return the memory, or 0 if there is no resident entry\n      */\n+\n+\n     public int getMemory(long key) {\n         Entry<V> e = find(key);\n         return e == null ? 0 : e.getMemory();\n@@ -233,6 +248,8 @@ public class CacheLongKeyLIRS<V> {\n      * @param key the key (may not be null)\n      * @return the value, or null if there is no resident entry\n      */\n+\n+\n     public V get(long key) {\n         int hash = getHash(key);\n         Segment<V> s = getSegment(hash);\n@@ -255,6 +272,8 @@ public class CacheLongKeyLIRS<V> {\n      * @param key the key\n      * @return the hash code\n      */\n+\n+\n     static int getHash(long key) {\n         int hash = (int) ((key >>> 32) ^ key);\n         // a supplemental secondary hash function\n@@ -270,6 +289,8 @@ public class CacheLongKeyLIRS<V> {\n      *\n      * @return the used memory\n      */\n+\n+\n     public long getUsedMemory() {\n         long x = 0;\n         for (Segment<V> s : segments) {\n@@ -285,10 +306,11 @@ public class CacheLongKeyLIRS<V> {\n      *\n      * @param maxMemory the maximum size (1 or larger) in bytes\n      */\n+\n+\n     public void setMaxMemory(long maxMemory) {\n-        DataUtils.checkArgument(\n-                maxMemory > 0,\n-                \"Max memory must be larger than 0, is {0}\", maxMemory);\n+        DataUtils.checkArgument(maxMemory > 0,\n+                                \"Max memory must be larger than 0, is {0}\", maxMemory);\n         this.maxMemory = maxMemory;\n         if (segments != null) {\n             long max = 1 + maxMemory / segments.length;\n@@ -303,6 +325,8 @@ public class CacheLongKeyLIRS<V> {\n      *\n      * @return the maximum memory\n      */\n+\n+\n     public long getMaxMemory() {\n         return maxMemory;\n     }\n@@ -312,6 +336,8 @@ public class CacheLongKeyLIRS<V> {\n      *\n      * @return the entry set\n      */\n+\n+\n     public synchronized Set<Map.Entry<Long, V>> entrySet() {\n         return getMap().entrySet();\n     }\n@@ -321,8 +347,10 @@ public class CacheLongKeyLIRS<V> {\n      *\n      * @return the set of keys\n      */\n+\n+\n     public Set<Long> keySet() {\n-        HashSet<Long> set = new HashSet<>();\n+        HashSet<Long> set = new HashSet< >();\n         for (Segment<V> s : segments) {\n             set.addAll(s.keySet());\n         }\n@@ -334,6 +362,8 @@ public class CacheLongKeyLIRS<V> {\n      *\n      * @return the number of non-resident entries\n      */\n+\n+\n     public int sizeNonResident() {\n         int x = 0;\n         for (Segment<V> s : segments) {\n@@ -347,6 +377,8 @@ public class CacheLongKeyLIRS<V> {\n      *\n      * @return the size of the array\n      */\n+\n+\n     public int sizeMapArray() {\n         int x = 0;\n         for (Segment<V> s : segments) {\n@@ -360,6 +392,8 @@ public class CacheLongKeyLIRS<V> {\n      *\n      * @return the number of hot entries\n      */\n+\n+\n     public int sizeHot() {\n         int x = 0;\n         for (Segment<V> s : segments) {\n@@ -373,6 +407,8 @@ public class CacheLongKeyLIRS<V> {\n      *\n      * @return the cache hits\n      */\n+\n+\n     public long getHits() {\n         long x = 0;\n         for (Segment<V> s : segments) {\n@@ -386,6 +422,8 @@ public class CacheLongKeyLIRS<V> {\n      *\n      * @return the cache misses\n      */\n+\n+\n     public long getMisses() {\n         int x = 0;\n         for (Segment<V> s : segments) {\n@@ -399,6 +437,8 @@ public class CacheLongKeyLIRS<V> {\n      *\n      * @return the number of entries\n      */\n+\n+\n     public int size() {\n         int x = 0;\n         for (Segment<V> s : segments) {\n@@ -415,8 +455,10 @@ public class CacheLongKeyLIRS<V> {\n      * @param nonResident true for non-resident entries\n      * @return the key list\n      */\n+\n+\n     public List<Long> keys(boolean cold, boolean nonResident) {\n-        ArrayList<Long> keys = new ArrayList<>();\n+        ArrayList<Long> keys = new ArrayList< >();\n         for (Segment<V> s : segments) {\n             keys.addAll(s.keys(cold, nonResident));\n         }\n@@ -428,8 +470,10 @@ public class CacheLongKeyLIRS<V> {\n      *\n      * @return the entry set\n      */\n+\n+\n     public List<V> values() {\n-        ArrayList<V> list = new ArrayList<>();\n+        ArrayList<V> list = new ArrayList< >();\n         for (long k : keySet()) {\n             V value = peek(k);\n             if (value != null) {\n@@ -444,6 +488,8 @@ public class CacheLongKeyLIRS<V> {\n      *\n      * @return true if it is empty\n      */\n+\n+\n     public boolean isEmpty() {\n         return size() == 0;\n     }\n@@ -454,6 +500,8 @@ public class CacheLongKeyLIRS<V> {\n      * @param value the value\n      * @return true if it is stored\n      */\n+\n+\n     public boolean containsValue(V value) {\n         return getMap().containsValue(value);\n     }\n@@ -463,8 +511,10 @@ public class CacheLongKeyLIRS<V> {\n      *\n      * @return the map\n      */\n+\n+\n     public Map<Long, V> getMap() {\n-        HashMap<Long, V> map = new HashMap<>();\n+        HashMap<Long, V> map = new HashMap< >();\n         for (long k : keySet()) {\n             V x = peek(k);\n             if (x != null) {\n@@ -479,6 +529,8 @@ public class CacheLongKeyLIRS<V> {\n      *\n      * @param m the map\n      */\n+\n+\n     public void putAll(Map<Long, ? extends V> m) {\n         for (Map.Entry<Long, ? extends V> e : m.entrySet()) {\n             // copy only non-null entries\n@@ -489,6 +541,8 @@ public class CacheLongKeyLIRS<V> {\n     /**\n      * Loop through segments, trimming the non resident queue.\n      */\n+\n+\n     public void trimNonResidentQueue() {\n         for (Segment<V> s : segments) {\n             synchronized (s) {\n@@ -502,41 +556,56 @@ public class CacheLongKeyLIRS<V> {\n      *\n      * @param <V> the value type\n      */\n+\n     private static class Segment<V> {\n \n         /**\n          * The number of (hot, cold, and non-resident) entries in the map.\n          */\n+\n+\n         int mapSize;\n \n         /**\n          * The size of the LIRS queue for resident cold entries.\n          */\n+\n+\n         int queueSize;\n \n         /**\n          * The size of the LIRS queue for non-resident cold entries.\n          */\n+\n+\n         int queue2Size;\n \n         /**\n          * The number of cache hits.\n          */\n+\n+\n         long hits;\n \n         /**\n          * The number of cache misses.\n          */\n+\n+\n         long misses;\n \n         /**\n          * The map array. The size is always a power of 2.\n          */\n+\n+\n         final Entry<V>[] entries;\n \n         /**\n          * The currently used memory.\n          */\n+\n+\n         long usedMemory;\n \n         /**\n@@ -611,8 +680,8 @@ public class CacheLongKeyLIRS<V> {\n          * @param nonResidentQueueSize the non-resident queue size low watermark factor\n          * @param nonResidentQueueSizeHigh  the non-resident queue size high watermark factor\n          */\n-        Segment(long maxMemory, int stackMoveDistance, int len,\n-                int nonResidentQueueSize, int nonResidentQueueSizeHigh) {\n+\n+        Segment(long maxMemory, int stackMoveDistance, int len, int nonResidentQueueSize, int nonResidentQueueSizeHigh) {\n             setMaxMemory(maxMemory);\n             this.stackMoveDistance = stackMoveDistance;\n             this.nonResidentQueueSize = nonResidentQueueSize;\n@@ -622,13 +691,12 @@ public class CacheLongKeyLIRS<V> {\n             mask = len - 1;\n \n             // initialize the stack and queue heads\n-            stack = new Entry<>();\n+            stack = new Entry< >();\n             stack.stackPrev = stack.stackNext = stack;\n-            queue = new Entry<>();\n+            queue = new Entry< >();\n             queue.queuePrev = queue.queueNext = queue;\n-            queue2 = new Entry<>();\n+            queue2 = new Entry< >();\n             queue2.queuePrev = queue2.queueNext = queue2;\n-\n             @SuppressWarnings(\"unchecked\")\n             Entry<V>[] e = new Entry[len];\n             entries = e;\n@@ -642,14 +710,14 @@ public class CacheLongKeyLIRS<V> {\n          * @param old the old segment\n          * @param len the number of hash table buckets (must be a power of 2)\n          */\n+\n         Segment(Segment<V> old, int len) {\n-            this(old.maxMemory, old.stackMoveDistance, len,\n-                    old.nonResidentQueueSize, old.nonResidentQueueSizeHigh);\n+            this(old.maxMemory, old.stackMoveDistance, len, old.nonResidentQueueSize, old.nonResidentQueueSizeHigh);\n             hits = old.hits;\n             misses = old.misses;\n             Entry<V> s = old.stack.stackPrev;\n             while (s != old.stack) {\n-                Entry<V> e = new Entry<>(s);\n+                Entry<V> e = new Entry< >(s);\n                 addToMap(e);\n                 addToStack(e);\n                 s = s.stackPrev;\n@@ -658,7 +726,7 @@ public class CacheLongKeyLIRS<V> {\n             while (s != old.queue) {\n                 Entry<V> e = find(s.key, getHash(s.key));\n                 if (e == null) {\n-                    e = new Entry<>(s);\n+                    e = new Entry< >(s);\n                     addToMap(e);\n                 }\n                 addToQueue(queue, e);\n@@ -668,7 +736,7 @@ public class CacheLongKeyLIRS<V> {\n             while (s != old.queue2) {\n                 Entry<V> e = find(s.key, getHash(s.key));\n                 if (e == null) {\n-                    e = new Entry<>(s);\n+                    e = new Entry< >(s);\n                     addToMap(e);\n                 }\n                 addToQueue(queue2, e);\n@@ -682,6 +750,8 @@ public class CacheLongKeyLIRS<V> {\n          *\n          * @return 0 if no resizing is needed, or the new length\n          */\n+\n+\n         int getNewMapLen() {\n             int len = mask + 1;\n             if (len * 3 < mapSize * 4 && len < (1 << 28)) {\n@@ -710,6 +780,8 @@ public class CacheLongKeyLIRS<V> {\n          * @param e the entry\n          * @return the value, or null if there is no resident entry\n          */\n+\n+\n         synchronized V get(Entry<V> e) {\n             V value = e == null ? null : e.getValue();\n             if (value == null) {\n@@ -729,6 +801,7 @@ public class CacheLongKeyLIRS<V> {\n          *\n          * @param e entry to record access for\n          */\n+\n         private void access(Entry<V> e) {\n             if (e.isHot()) {\n                 if (e != stack.stackNext && e.stackNext != null) {\n@@ -787,6 +860,8 @@ public class CacheLongKeyLIRS<V> {\n          * @param memory the memory used for the given entry\n          * @return the old value, or null if there was no resident entry\n          */\n+\n+\n         synchronized V put(long key, int hash, V value, int memory) {\n             Entry<V> e = find(key, hash);\n             boolean existed = e != null;\n@@ -799,7 +874,7 @@ public class CacheLongKeyLIRS<V> {\n                 // the new entry is too big to fit\n                 return old;\n             }\n-            e = new Entry<>(key, value, memory);\n+            e = new Entry< >(key, value, memory);\n             int index = hash & mask;\n             e.mapNext = entries[index];\n             entries[index] = e;\n@@ -832,6 +907,8 @@ public class CacheLongKeyLIRS<V> {\n          * @param hash the hash\n          * @return the old value, or null if there was no resident entry\n          */\n+\n+\n         synchronized V remove(long key, int hash) {\n             int index = hash & mask;\n             Entry<V> e = entries[index];\n@@ -879,6 +956,7 @@ public class CacheLongKeyLIRS<V> {\n          * is reached. The new entry is added as a cold entry, except if it is\n          * the only entry.\n          */\n+\n         private void evict() {\n             do {\n                 evictBlock();\n@@ -897,7 +975,7 @@ public class CacheLongKeyLIRS<V> {\n                 Entry<V> e = queue.queuePrev;\n                 usedMemory -= e.memory;\n                 removeFromQueue(e);\n-                e.reference = new WeakReference<>(e.value);\n+                e.reference = new WeakReference< >(e.value);\n                 e.value = null;\n                 addToQueue(queue2, e);\n                 // the size of the non-resident-cold entries needs to be limited\n@@ -905,6 +983,7 @@ public class CacheLongKeyLIRS<V> {\n             }\n         }\n \n+\n         void trimNonResidentQueue() {\n             int residentCount = mapSize - queue2Size;\n             int maxQueue2SizeHigh = nonResidentQueueSizeHigh * residentCount;\n@@ -941,6 +1020,7 @@ public class CacheLongKeyLIRS<V> {\n         /**\n          * Ensure the last entry of the stack is cold.\n          */\n+\n         private void pruneStack() {\n             while (true) {\n                 Entry<V> last = stack.stackPrev;\n@@ -962,6 +1042,8 @@ public class CacheLongKeyLIRS<V> {\n          * @param hash the hash\n          * @return the entry (might be a non-resident)\n          */\n+\n+\n         Entry<V> find(long key, int hash) {\n             int index = hash & mask;\n             Entry<V> e = entries[index];\n@@ -993,6 +1075,7 @@ public class CacheLongKeyLIRS<V> {\n          *\n          * @param e the entry\n          */\n+\n         private void removeFromStack(Entry<V> e) {\n             e.stackPrev.stackNext = e.stackNext;\n             e.stackNext.stackPrev = e.stackPrev;\n@@ -1031,17 +1114,17 @@ public class CacheLongKeyLIRS<V> {\n          * @param nonResident true for non-resident entries\n          * @return the key list\n          */\n+\n+\n         synchronized List<Long> keys(boolean cold, boolean nonResident) {\n-            ArrayList<Long> keys = new ArrayList<>();\n+            ArrayList<Long> keys = new ArrayList< >();\n             if (cold) {\n                 Entry<V> start = nonResident ? queue2 : queue;\n-                for (Entry<V> e = start.queueNext; e != start;\n-                        e = e.queueNext) {\n+                for (Entry<V> e = start.queueNext; e != start; e = e.queueNext) {\n                     keys.add(e.key);\n                 }\n             } else {\n-                for (Entry<V> e = stack.stackNext; e != stack;\n-                        e = e.stackNext) {\n+                for (Entry<V> e = stack.stackNext; e != stack; e = e.stackNext) {\n                     keys.add(e.key);\n                 }\n             }\n@@ -1053,8 +1136,10 @@ public class CacheLongKeyLIRS<V> {\n          *\n          * @return the set of keys\n          */\n+\n+\n         synchronized Set<Long> keySet() {\n-            HashSet<Long> set = new HashSet<>();\n+            HashSet<Long> set = new HashSet< >();\n             for (Entry<V> e = stack.stackNext; e != stack; e = e.stackNext) {\n                 set.add(e.key);\n             }\n@@ -1071,6 +1156,8 @@ public class CacheLongKeyLIRS<V> {\n          *\n          * @param maxMemory the maximum size (1 or larger) in bytes\n          */\n+\n+\n         void setMaxMemory(long maxMemory) {\n             this.maxMemory = maxMemory;\n         }\n@@ -1086,60 +1173,81 @@ public class CacheLongKeyLIRS<V> {\n      *\n      * @param <V> the value type\n      */\n+\n+\n     static class Entry<V> {\n \n         /**\n          * The key.\n          */\n+\n+\n         final long key;\n \n         /**\n          * The value. Set to null for non-resident-cold entries.\n          */\n+\n+\n         V value;\n \n         /**\n          * Weak reference to the value. Set to null for resident entries.\n          */\n+\n+\n         WeakReference<V> reference;\n \n         /**\n          * The estimated memory used.\n          */\n+\n+\n         final int memory;\n \n         /**\n          * When the item was last moved to the top of the stack.\n          */\n+\n+\n         int topMove;\n \n         /**\n          * The next entry in the stack.\n          */\n+\n+\n         Entry<V> stackNext;\n \n         /**\n          * The previous entry in the stack.\n          */\n+\n+\n         Entry<V> stackPrev;\n \n         /**\n          * The next entry in the queue (either the resident queue or the\n          * non-resident queue).\n          */\n+\n+\n         Entry<V> queueNext;\n \n         /**\n          * The previous entry in the queue.\n          */\n+\n+\n         Entry<V> queuePrev;\n \n         /**\n          * The next entry in the map (the chained entry).\n          */\n-        Entry<V> mapNext;\n \n \n+        Entry<V> mapNext;\n+\n         Entry() {\n             this(0L, null, 0);\n         }\n@@ -1161,50 +1269,68 @@ public class CacheLongKeyLIRS<V> {\n          *\n          * @return whether the entry is hot\n          */\n+\n+\n         boolean isHot() {\n             return queueNext == null;\n         }\n \n+\n         V getValue() {\n             return value == null ? reference.get() : value;\n         }\n \n+\n         int getMemory() {\n             return value == null ? 0 : memory;\n         }\n+\n     }\n \n     /**\n      * The cache configuration.\n      */\n+\n+\n     public static class Config {\n \n         /**\n          *  The maximum memory to use (1 or larger).\n          */\n+\n+\n         public long maxMemory = 1;\n \n         /**\n          * The number of cache segments (must be a power of 2).\n          */\n+\n+\n         public int segmentCount = 16;\n \n         /**\n          * How many other item are to be moved to the top of the stack before\n          * the current item is moved.\n          */\n+\n+\n         public int stackMoveDistance = 32;\n \n         /**\n          * Low water mark for the number of entries in the non-resident queue,\n          * as a factor of the number of all other entries in the map.\n          */\n+\n+\n         public final int nonResidentQueueSize = 3;\n \n         /**\n          * High watermark for the number of entries in the non-resident queue,\n          * as a factor of the number of all other entries in the map\n          */\n+\n+\n         public final int nonResidentQueueSizeHigh = 12;\n     }\n-}\n+\n+}\n\\ No newline at end of file\n",
            "diff_size": 176
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/errored/1/121/CacheLongKeyLIRS.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/styler_random/121/CacheLongKeyLIRS.java\nindex b4701228336..ebb1871c0b0 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/errored/1/121/CacheLongKeyLIRS.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/styler_random/121/CacheLongKeyLIRS.java\n@@ -914,8 +914,9 @@ public class CacheLongKeyLIRS<V> {\n                 if (queue2Size <= maxQueue2SizeHigh) {\n                     WeakReference<V> reference = e.reference;\n                     if (reference != null && reference.get() != null) {\n-                        break;  // stop trimming if entry holds a value\n-                    }\n+                        break;\n+                    // stop trimming if entry holds a value\n+                      }\n                 }\n                 int hash = getHash(e.key);\n                 remove(e.key, hash);\n",
            "diff_size": 3
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/errored/1/121/CacheLongKeyLIRS.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/styler_three_grams/121/CacheLongKeyLIRS.java\nindex b4701228336..03fec2d3ac2 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/errored/1/121/CacheLongKeyLIRS.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/styler_three_grams/121/CacheLongKeyLIRS.java\n@@ -914,8 +914,9 @@ public class CacheLongKeyLIRS<V> {\n                 if (queue2Size <= maxQueue2SizeHigh) {\n                     WeakReference<V> reference = e.reference;\n                     if (reference != null && reference.get() != null) {\n-                        break;  // stop trimming if entry holds a value\n-                    }\n+                        break;\n+                        // stop trimming if entry holds a value\n+                      }\n                 }\n                 int hash = getHash(e.key);\n                 remove(e.key, hash);\n",
            "diff_size": 3
        }
    ],
    "repaired_by": [
        "styler",
        "naturalize",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "intellij",
        "codebuff"
    ]
}