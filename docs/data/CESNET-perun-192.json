{
    "project_name": "CESNET-perun",
    "error_id": "192",
    "information": {
        "errors": [
            {
                "line": "186",
                "severity": "error",
                "message": "Line has trailing spaces.",
                "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
            }
        ]
    },
    "source_code": "\t// regular expression to match alfanumeric contents\n\tprivate static final Pattern alnumPattern = Pattern.compile(\".*\\\\p{Alnum}+.*\", Pattern.UNICODE_CHARACTER_CLASS);\n\t\n\tprivate final Set<String> runningCreateApplication = new HashSet<>();\n\tprivate final Set<Integer> runningApproveApplication = new HashSet<>();\n\tprivate final Set<Integer> runningRejectApplication = new HashSet<>();",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/192/RegistrarManagerImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/styler/192/RegistrarManagerImpl.java\nindex f9d1101b9d5..77350496d12 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/192/RegistrarManagerImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/styler/192/RegistrarManagerImpl.java\n@@ -183,7 +183,7 @@ public class RegistrarManagerImpl implements RegistrarManager {\n \n \t// regular expression to match alfanumeric contents\n \tprivate static final Pattern alnumPattern = Pattern.compile(\".*\\\\p{Alnum}+.*\", Pattern.UNICODE_CHARACTER_CLASS);\n-\t\n+\n \tprivate final Set<String> runningCreateApplication = new HashSet<>();\n \tprivate final Set<Integer> runningApproveApplication = new HashSet<>();\n \tprivate final Set<Integer> runningRejectApplication = new HashSet<>();\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/192/RegistrarManagerImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/intellij/192/RegistrarManagerImpl.java\nindex f9d1101b9d5..c99a1e237f2 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/192/RegistrarManagerImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/intellij/192/RegistrarManagerImpl.java\n@@ -79,2810 +79,2887 @@ import static cz.metacentrum.perun.registrar.model.ApplicationFormItem.Type.*;\n  */\n public class RegistrarManagerImpl implements RegistrarManager {\n \n-\tprivate final static Logger log = LoggerFactory.getLogger(RegistrarManagerImpl.class);\n-\tprivate final static Set<String> extSourcesWithMultipleIdentifiers = BeansUtils.getCoreConfig().getExtSourcesMultipleIdentifiers();\n-\n-\t// identifiers for selected attributes\n-\tprivate static final String URN_USER_TITLE_BEFORE = \"urn:perun:user:attribute-def:core:titleBefore\";\n-\tprivate static final String URN_USER_TITLE_AFTER = \"urn:perun:user:attribute-def:core:titleAfter\";\n-\tprivate static final String URN_USER_FIRST_NAME = \"urn:perun:user:attribute-def:core:firstName\";\n-\tstatic final String URN_USER_LAST_NAME = \"urn:perun:user:attribute-def:core:lastName\";\n-\tprivate static final String URN_USER_MIDDLE_NAME = \"urn:perun:user:attribute-def:core:middleName\";\n-\tstatic final String URN_USER_DISPLAY_NAME = \"urn:perun:user:attribute-def:core:displayName\";\n-\n-\tprivate static final String DISPLAY_NAME_VO_FROM_EMAIL = \"\\\"From\\\" email address\";\n-\tprivate static final String FRIENDLY_NAME_VO_FROM_EMAIL = \"fromEmail\";\n-\tprivate static final String NAMESPACE_VO_FROM_EMAIL = AttributesManager.NS_VO_ATTR_DEF;\n-\tstatic final String URN_VO_FROM_EMAIL = NAMESPACE_VO_FROM_EMAIL  + \":\" + FRIENDLY_NAME_VO_FROM_EMAIL;\n-\n-\tprivate static final String DISPLAY_NAME_VO_TO_EMAIL = \"\\\"To\\\" email addresses\";\n-\tprivate static final String FRIENDLY_NAME_VO_TO_EMAIL = \"toEmail\";\n-\tprivate static final String NAMESPACE_VO_TO_EMAIL = AttributesManager.NS_VO_ATTR_DEF;\n-\tstatic final String URN_VO_TO_EMAIL = NAMESPACE_VO_TO_EMAIL + \":\" +  FRIENDLY_NAME_VO_TO_EMAIL;\n-\n-\tprivate static final String DISPLAY_NAME_GROUP_TO_EMAIL = \"\\\"To\\\" email addresses\";\n-\tprivate static final String FRIENDLY_NAME_GROUP_TO_EMAIL = \"toEmail\";\n-\tprivate static final String NAMESPACE_GROUP_TO_EMAIL = AttributesManager.NS_GROUP_ATTR_DEF;\n-\tstatic final String URN_GROUP_TO_EMAIL = NAMESPACE_GROUP_TO_EMAIL + \":\" +  FRIENDLY_NAME_GROUP_TO_EMAIL;\n-\n-\tprivate static final String DISPLAY_NAME_GROUP_FROM_EMAIL = \"\\\"From\\\" email address\";\n-\tprivate static final String FRIENDLY_NAME_GROUP_FROM_EMAIL = \"fromEmail\";\n-\tprivate static final String NAMESPACE_GROUP_FROM_EMAIL = AttributesManager.NS_GROUP_ATTR_DEF;\n-\tstatic final String URN_GROUP_FROM_EMAIL = NAMESPACE_GROUP_FROM_EMAIL + \":\" +  FRIENDLY_NAME_GROUP_FROM_EMAIL;\n-\n-\tprivate static final String DISPLAY_NAME_GROUP_FROM_NAME_EMAIL = \"\\\"From\\\" name\";\n-\tprivate static final String FRIENDLY_NAME_GROUP_FROM_NAME_EMAIL = \"fromNameEmail\";\n-\tprivate static final String NAMESPACE_GROUP_FROM_NAME_EMAIL = AttributesManager.NS_GROUP_ATTR_DEF;\n-\tstatic final String URN_GROUP_FROM_NAME_EMAIL = NAMESPACE_GROUP_FROM_EMAIL + \":\" +  FRIENDLY_NAME_GROUP_FROM_NAME_EMAIL;\n-\n-\tprivate static final String DISPLAY_NAME_VO_FROM_NAME_EMAIL = \"\\\"From\\\" name\";\n-\tprivate static final String FRIENDLY_NAME_VO_FROM_NAME_EMAIL = \"fromNameEmail\";\n-\tprivate static final String NAMESPACE_VO_FROM_NAME_EMAIL = AttributesManager.NS_VO_ATTR_DEF;\n-\tstatic final String URN_VO_FROM_NAME_EMAIL = NAMESPACE_VO_FROM_EMAIL + \":\" +  FRIENDLY_NAME_VO_FROM_NAME_EMAIL;\n-\n-\tprivate static final String DISPLAY_NAME_VO_LANGUAGE_EMAIL = \"Notification default language\";\n-\tprivate static final String FRIENDLY_NAME_VO_LANGUAGE_EMAIL = \"notificationsDefLang\";\n-\tprivate static final String NAMESPACE_VO_LANGUAGE_EMAIL = AttributesManager.NS_VO_ATTR_DEF;\n-\tstatic final String URN_VO_LANGUAGE_EMAIL = NAMESPACE_VO_LANGUAGE_EMAIL  + \":\" + FRIENDLY_NAME_VO_LANGUAGE_EMAIL;\n-\n-\tprivate static final String DISPLAY_NAME_GROUP_LANGUAGE_EMAIL = \"Notification default language\";\n-\tprivate static final String FRIENDLY_NAME_GROUP_LANGUAGE_EMAIL = \"notificationsDefLang\";\n-\tprivate static final String NAMESPACE_GROUP_LANGUAGE_EMAIL = AttributesManager.NS_GROUP_ATTR_DEF;\n-\tstatic final String URN_GROUP_LANGUAGE_EMAIL = NAMESPACE_GROUP_LANGUAGE_EMAIL + \":\" +  FRIENDLY_NAME_GROUP_LANGUAGE_EMAIL;\n-\n-\tprivate static final String DISPLAY_NAME_VO_APPLICATION_URL = \"Application form URL\";\n-\tprivate static final String FRIENDLY_NAME_VO_APPLICATION_URL = \"applicationURL\";\n-\tprivate static final String NAMESPACE_VO_APPLICATION_URL = AttributesManager.NS_VO_ATTR_DEF;\n-\tprivate static final String URN_VO_APPLICATION_URL = NAMESPACE_VO_APPLICATION_URL  + \":\" + FRIENDLY_NAME_VO_APPLICATION_URL;\n-\n-\tprivate static final String DISPLAY_NAME_GROUP_APPLICATION_URL = \"Application form URL\";\n-\tprivate static final String FRIENDLY_NAME_GROUP_APPLICATION_URL = \"applicationURL\";\n-\tprivate static final String NAMESPACE_GROUP_APPLICATION_URL = AttributesManager.NS_GROUP_ATTR_DEF;\n-\tprivate static final String URN_GROUP_APPLICATION_URL = NAMESPACE_GROUP_APPLICATION_URL + \":\" +  FRIENDLY_NAME_GROUP_APPLICATION_URL;\n-\n-\tprivate static final String DISPLAY_NAME_VO_REGISTRAR_URL = \"Registrar URL\";\n-\tprivate static final String FRIENDLY_NAME_VO_REGISTRAR_URL = \"registrarURL\";\n-\tprivate static final String NAMESPACE_VO_REGISTRAR_URL = AttributesManager.NS_VO_ATTR_DEF;\n-\tstatic final String URN_VO_REGISTRAR_URL = NAMESPACE_VO_REGISTRAR_URL  + \":\" + FRIENDLY_NAME_VO_REGISTRAR_URL;\n-\n-\tprivate static final String DISPLAY_NAME_GROUP_REGISTRAR_URL = \"Registrar URL\";\n-\tprivate static final String FRIENDLY_NAME_GROUP_REGISTRAR_URL = \"registrarURL\";\n-\tprivate static final String NAMESPACE_GROUP_REGISTRAR_URL = AttributesManager.NS_GROUP_ATTR_DEF;\n-\tstatic final String URN_GROUP_REGISTRAR_URL = NAMESPACE_GROUP_REGISTRAR_URL + \":\" +  FRIENDLY_NAME_GROUP_REGISTRAR_URL;\n-\n-\tprivate static final String DISPLAY_NAME_VO_MAIL_FOOTER = \"Mail Footer\";\n-\tprivate static final String FRIENDLY_NAME_VO_MAIL_FOOTER = \"mailFooter\";\n-\tprivate static final String NAMESPACE_VO_MAIL_FOOTER = AttributesManager.NS_VO_ATTR_DEF;\n-\tstatic final String URN_VO_MAIL_FOOTER = NAMESPACE_VO_MAIL_FOOTER + \":\" + FRIENDLY_NAME_VO_MAIL_FOOTER;\n-\n-\tprivate static final String DISPLAY_NAME_GROUP_MAIL_FOOTER = \"Mail Footer\";\n-\tprivate static final String FRIENDLY_NAME_GROUP_MAIL_FOOTER = \"mailFooter\";\n-\tprivate static final String NAMESPACE_GROUP_MAIL_FOOTER = AttributesManager.NS_GROUP_ATTR_DEF;\n-\tstatic final String URN_GROUP_MAIL_FOOTER = NAMESPACE_GROUP_MAIL_FOOTER + \":\" + FRIENDLY_NAME_GROUP_MAIL_FOOTER;\n-\n-\tprivate static final String MODULE_PACKAGE_PATH = \"cz.metacentrum.perun.registrar.modules.\";\n-\n-\t@Autowired PerunBl perun;\n-\t@Autowired MailManager mailManager;\n-\t@Autowired ConsolidatorManager consolidatorManager;\n-\tprivate RegistrarManager registrarManager;\n-\tprivate PerunSession registrarSession;\n-\tprivate JdbcPerunTemplate jdbc;\n-\tprivate NamedParameterJdbcTemplate namedJdbc;\n-\tprivate AttributesManagerBl attrManager;\n-\tprivate MembersManagerBl membersManager;\n-\tprivate GroupsManagerBl groupsManager;\n-\tprivate UsersManagerBl usersManager;\n-\tprivate VosManagerBl vosManager;\n-\n-\t// federation attribute name constants\n-\tprivate static final String shibDisplayNameVar = \"displayName\";\n-\tprivate static final String shibCommonNameVar = \"cn\";\n-\tprivate static final String shibFirstNameVar = \"givenName\";\n-\tprivate static final String shibLastNameVar = \"sn\";\n-\n-\t// regular expression to match alfanumeric contents\n-\tprivate static final Pattern alnumPattern = Pattern.compile(\".*\\\\p{Alnum}+.*\", Pattern.UNICODE_CHARACTER_CLASS);\n-\t\n-\tprivate final Set<String> runningCreateApplication = new HashSet<>();\n-\tprivate final Set<Integer> runningApproveApplication = new HashSet<>();\n-\tprivate final Set<Integer> runningRejectApplication = new HashSet<>();\n-\tprivate final Set<Integer> runningDeleteApplication = new HashSet<>();\n-\n-\tpublic void setDataSource(DataSource dataSource) {\n-\t\tthis.jdbc = new JdbcPerunTemplate(dataSource);\n-\t\tthis.namedJdbc = new NamedParameterJdbcTemplate(jdbc);\n-\t\tthis.jdbc.setQueryTimeout(BeansUtils.getCoreConfig().getQueryTimeout());\n-\t\tthis.namedJdbc.getJdbcTemplate().setQueryTimeout(BeansUtils.getCoreConfig().getQueryTimeout());\n-\t}\n-\n-\tpublic void setRegistrarManager(RegistrarManager registrarManager) {\n-\t\tthis.registrarManager = registrarManager;\n-\t}\n-\n-\tpublic void setConsolidatorManager(ConsolidatorManager consolidatorManager) {\n-\t\tthis.consolidatorManager = consolidatorManager;\n-\t}\n-\n-\tprotected void initialize() throws PerunException {\n-\n-\t\t// gets session for a system principal \"perunRegistrar\"\n-\t\tfinal PerunPrincipal pp = new PerunPrincipal(\"perunRegistrar\",\n-\t\t\t\tExtSourcesManager.EXTSOURCE_NAME_INTERNAL,\n-\t\t\t\tExtSourcesManager.EXTSOURCE_INTERNAL);\n-\t\tregistrarSession = perun.getPerunSession(pp, new PerunClient());\n-\n-\t\t// set managers\n-\t\tthis.attrManager = perun.getAttributesManagerBl();\n-\t\tthis.membersManager = perun.getMembersManagerBl();\n-\t\tthis.groupsManager = perun.getGroupsManagerBl();\n-\t\tthis.usersManager = perun.getUsersManagerBl();\n-\t\tthis.vosManager = perun.getVosManagerBl();\n-\n-\t\t// check necessary attributes\n-\t\ttry {\n-\t\t\tattrManager.getAttributeDefinition(registrarSession, URN_VO_FROM_EMAIL);\n-\t\t} catch (AttributeNotExistsException ex) {\n-\t\t\t// create attr if not exists\n-\t\t\tAttributeDefinition attrDef = new AttributeDefinition();\n-\t\t\tattrDef.setDisplayName(DISPLAY_NAME_VO_FROM_EMAIL);\n-\t\t\tattrDef.setFriendlyName(FRIENDLY_NAME_VO_FROM_EMAIL);\n-\t\t\tattrDef.setNamespace(NAMESPACE_VO_FROM_EMAIL);\n-\t\t\tattrDef.setDescription(\"Email address used as \\\"from\\\" in mail notifications.\");\n-\t\t\tattrDef.setType(String.class.getName());\n-\t\t\tattrDef = attrManager.createAttribute(registrarSession, attrDef);\n-\t\t\t// set attribute rights\n-\t\t\tList<AttributeRights> rights = new ArrayList<>();\n-\t\t\trights.add(new AttributeRights(attrDef.getId(), Role.VOADMIN, Arrays.asList(ActionType.READ, ActionType.WRITE)));\n-\t\t\tperun.getAttributesManager().setAttributeRights(registrarSession, rights);\n-\t\t}\n-\t\ttry {\n-\t\t\tattrManager.getAttributeDefinition(registrarSession, URN_VO_TO_EMAIL);\n-\t\t} catch (AttributeNotExistsException ex) {\n-\t\t\t// create attr if not exists\n-\t\t\tAttributeDefinition attrDef = new AttributeDefinition();\n-\t\t\tattrDef.setDisplayName(DISPLAY_NAME_VO_TO_EMAIL);\n-\t\t\tattrDef.setFriendlyName(FRIENDLY_NAME_VO_TO_EMAIL);\n-\t\t\tattrDef.setNamespace(NAMESPACE_VO_TO_EMAIL);\n-\t\t\tattrDef.setDescription(\"Email addresses (of VO administrators) used as \\\"to\\\" in mail notifications.\");\n-\t\t\tattrDef.setType(\"java.util.ArrayList\");\n-\t\t\tattrDef = attrManager.createAttribute(registrarSession, attrDef);\n-\t\t\t// set attribute rights\n-\t\t\tList<AttributeRights> rights = new ArrayList<>();\n-\t\t\trights.add(new AttributeRights(attrDef.getId(), Role.VOADMIN, Arrays.asList(ActionType.READ, ActionType.WRITE)));\n-\t\t\tperun.getAttributesManager().setAttributeRights(registrarSession, rights);\n-\t\t}\n-\t\ttry {\n-\t\t\tattrManager.getAttributeDefinition(registrarSession, URN_GROUP_TO_EMAIL);\n-\t\t} catch (AttributeNotExistsException ex) {\n-\t\t\t// create attr if not exists\n-\t\t\tAttributeDefinition attrDef = new AttributeDefinition();\n-\t\t\tattrDef.setDisplayName(DISPLAY_NAME_GROUP_TO_EMAIL);\n-\t\t\tattrDef.setFriendlyName(FRIENDLY_NAME_GROUP_TO_EMAIL);\n-\t\t\tattrDef.setNamespace(NAMESPACE_GROUP_TO_EMAIL);\n-\t\t\tattrDef.setDescription(\"Email addresses (of Group administrators) used as \\\"to\\\" in mail notifications.\");\n-\t\t\tattrDef.setType(\"java.util.ArrayList\");\n-\t\t\tattrDef = attrManager.createAttribute(registrarSession, attrDef);\n-\t\t\t// set attribute rights\n-\t\t\tList<AttributeRights> rights = new ArrayList<>();\n-\t\t\trights.add(new AttributeRights(attrDef.getId(), Role.VOADMIN, Arrays.asList(ActionType.READ, ActionType.WRITE)));\n-\t\t\trights.add(new AttributeRights(attrDef.getId(), Role.GROUPADMIN, Arrays.asList(ActionType.READ, ActionType.WRITE)));\n-\t\t\tperun.getAttributesManager().setAttributeRights(registrarSession, rights);\n-\t\t}\n-\t\ttry {\n-\t\t\tattrManager.getAttributeDefinition(registrarSession, URN_GROUP_FROM_EMAIL);\n-\t\t} catch (AttributeNotExistsException ex) {\n-\t\t\t// create attr if not exists\n-\t\t\tAttributeDefinition attrDef = new AttributeDefinition();\n-\t\t\tattrDef.setDisplayName(DISPLAY_NAME_GROUP_FROM_EMAIL);\n-\t\t\tattrDef.setFriendlyName(FRIENDLY_NAME_GROUP_FROM_EMAIL);\n-\t\t\tattrDef.setNamespace(NAMESPACE_GROUP_FROM_EMAIL);\n-\t\t\tattrDef.setDescription(\"Email address used as \\\"from\\\" in mail notifications.\");\n-\t\t\tattrDef.setType(String.class.getName());\n-\t\t\tattrDef = attrManager.createAttribute(registrarSession, attrDef);\n-\t\t\t// set attribute rights\n-\t\t\tList<AttributeRights> rights = new ArrayList<>();\n-\t\t\trights.add(new AttributeRights(attrDef.getId(), Role.VOADMIN, Arrays.asList(ActionType.READ, ActionType.WRITE)));\n-\t\t\trights.add(new AttributeRights(attrDef.getId(), Role.GROUPADMIN, Arrays.asList(ActionType.READ, ActionType.WRITE)));\n-\t\t\tperun.getAttributesManager().setAttributeRights(registrarSession, rights);\n-\t\t}\n-\t\ttry {\n-\t\t\tattrManager.getAttributeDefinition(registrarSession, URN_GROUP_FROM_NAME_EMAIL);\n-\t\t} catch (AttributeNotExistsException ex) {\n-\t\t\t// create attr if not exists\n-\t\t\tAttributeDefinition attrDef = new AttributeDefinition();\n-\t\t\tattrDef.setDisplayName(DISPLAY_NAME_GROUP_FROM_NAME_EMAIL);\n-\t\t\tattrDef.setFriendlyName(FRIENDLY_NAME_GROUP_FROM_NAME_EMAIL);\n-\t\t\tattrDef.setNamespace(NAMESPACE_GROUP_FROM_NAME_EMAIL);\n-\t\t\tattrDef.setDescription(\"Name of the sender used as \\\"from\\\" in mail notifications.\");\n-\t\t\tattrDef.setType(String.class.getName());\n-\t\t\tattrDef = attrManager.createAttribute(registrarSession, attrDef);\n-\t\t\t// set attribute rights\n-\t\t\tList<AttributeRights> rights = new ArrayList<>();\n-\t\t\trights.add(new AttributeRights(attrDef.getId(), Role.VOADMIN, Arrays.asList(ActionType.READ, ActionType.WRITE)));\n-\t\t\trights.add(new AttributeRights(attrDef.getId(), Role.GROUPADMIN, Arrays.asList(ActionType.READ, ActionType.WRITE)));\n-\t\t\tperun.getAttributesManager().setAttributeRights(registrarSession, rights);\n-\t\t}\n-\t\ttry {\n-\t\t\tattrManager.getAttributeDefinition(registrarSession, URN_VO_FROM_NAME_EMAIL);\n-\t\t} catch (AttributeNotExistsException ex) {\n-\t\t\t// create attr if not exists\n-\t\t\tAttributeDefinition attrDef = new AttributeDefinition();\n-\t\t\tattrDef.setDisplayName(DISPLAY_NAME_VO_FROM_NAME_EMAIL);\n-\t\t\tattrDef.setFriendlyName(FRIENDLY_NAME_VO_FROM_NAME_EMAIL);\n-\t\t\tattrDef.setNamespace(NAMESPACE_VO_FROM_NAME_EMAIL);\n-\t\t\tattrDef.setDescription(\"Name of the sender used as \\\"from\\\" in mail notifications.\");\n-\t\t\tattrDef.setType(String.class.getName());\n-\t\t\tattrDef = attrManager.createAttribute(registrarSession, attrDef);\n-\t\t\t// set attribute rights\n-\t\t\tList<AttributeRights> rights = new ArrayList<>();\n-\t\t\trights.add(new AttributeRights(attrDef.getId(), Role.VOADMIN, Arrays.asList(ActionType.READ, ActionType.WRITE)));\n-\t\t\tperun.getAttributesManager().setAttributeRights(registrarSession, rights);\n-\t\t}\n-\t\ttry {\n-\t\t\tattrManager.getAttributeDefinition(registrarSession, URN_VO_LANGUAGE_EMAIL);\n-\t\t} catch (AttributeNotExistsException ex) {\n-\t\t\t// create attr if not exists\n-\t\t\tAttributeDefinition attrDef = new AttributeDefinition();\n-\t\t\tattrDef.setDisplayName(DISPLAY_NAME_VO_LANGUAGE_EMAIL);\n-\t\t\tattrDef.setFriendlyName(FRIENDLY_NAME_VO_LANGUAGE_EMAIL);\n-\t\t\tattrDef.setNamespace(NAMESPACE_VO_LANGUAGE_EMAIL);\n-\t\t\tattrDef.setDescription(\"Default language used for application notifications to VO administrators.\");\n-\t\t\tattrDef.setType(String.class.getName());\n-\t\t\tattrDef = attrManager.createAttribute(registrarSession, attrDef);\n-\t\t\t// set attribute rights\n-\t\t\tList<AttributeRights> rights = new ArrayList<>();\n-\t\t\trights.add(new AttributeRights(attrDef.getId(), Role.VOADMIN, Arrays.asList(ActionType.READ, ActionType.WRITE)));\n-\t\t\tperun.getAttributesManager().setAttributeRights(registrarSession, rights);\n-\t\t}\n-\t\ttry {\n-\t\t\tattrManager.getAttributeDefinition(registrarSession, URN_GROUP_LANGUAGE_EMAIL);\n-\t\t} catch (AttributeNotExistsException ex) {\n-\t\t\t// create attr if not exists\n-\t\t\tAttributeDefinition attrDef = new AttributeDefinition();\n-\t\t\tattrDef.setDisplayName(DISPLAY_NAME_GROUP_LANGUAGE_EMAIL);\n-\t\t\tattrDef.setFriendlyName(FRIENDLY_NAME_GROUP_LANGUAGE_EMAIL);\n-\t\t\tattrDef.setNamespace(NAMESPACE_GROUP_LANGUAGE_EMAIL);\n-\t\t\tattrDef.setDescription(\"Default language used for application notifications to Group administrators.\");\n-\t\t\tattrDef.setType(String.class.getName());\n-\t\t\tattrDef = attrManager.createAttribute(registrarSession, attrDef);\n-\t\t\t// set attribute rights\n-\t\t\tList<AttributeRights> rights = new ArrayList<>();\n-\t\t\trights.add(new AttributeRights(attrDef.getId(), Role.VOADMIN, Arrays.asList(ActionType.READ, ActionType.WRITE)));\n-\t\t\trights.add(new AttributeRights(attrDef.getId(), Role.GROUPADMIN, Arrays.asList(ActionType.READ, ActionType.WRITE)));\n-\t\t\tperun.getAttributesManager().setAttributeRights(registrarSession, rights);\n-\t\t}\n-\t\ttry {\n-\t\t\tattrManager.getAttributeDefinition(registrarSession, URN_VO_APPLICATION_URL);\n-\t\t} catch (AttributeNotExistsException ex) {\n-\t\t\t// create attr if not exists\n-\t\t\tAttributeDefinition attrDef = new AttributeDefinition();\n-\t\t\tattrDef.setDisplayName(DISPLAY_NAME_VO_APPLICATION_URL);\n-\t\t\tattrDef.setFriendlyName(FRIENDLY_NAME_VO_APPLICATION_URL);\n-\t\t\tattrDef.setNamespace(NAMESPACE_VO_APPLICATION_URL);\n-\t\t\tattrDef.setDescription(\"Custom link to VO's application form used in e-mail invitations.\");\n-\t\t\tattrDef.setType(String.class.getName());\n-\t\t\tattrDef = attrManager.createAttribute(registrarSession, attrDef);\n-\t\t\t// set attribute rights\n-\t\t\tList<AttributeRights> rights = new ArrayList<>();\n-\t\t\trights.add(new AttributeRights(attrDef.getId(), Role.VOADMIN, Arrays.asList(ActionType.READ, ActionType.WRITE)));\n-\t\t\tperun.getAttributesManager().setAttributeRights(registrarSession, rights);\n-\t\t}\n-\t\ttry {\n-\t\t\tattrManager.getAttributeDefinition(registrarSession, URN_GROUP_APPLICATION_URL);\n-\t\t} catch (AttributeNotExistsException ex) {\n-\t\t\t// create attr if not exists\n-\t\t\tAttributeDefinition attrDef = new AttributeDefinition();\n-\t\t\tattrDef.setDisplayName(DISPLAY_NAME_GROUP_APPLICATION_URL);\n-\t\t\tattrDef.setFriendlyName(FRIENDLY_NAME_GROUP_APPLICATION_URL);\n-\t\t\tattrDef.setNamespace(NAMESPACE_GROUP_APPLICATION_URL);\n-\t\t\tattrDef.setDescription(\"Custom link to group's application form used in e-mail invitations.\");\n-\t\t\tattrDef.setType(String.class.getName());\n-\t\t\tattrDef = attrManager.createAttribute(registrarSession, attrDef);\n-\t\t\t// set attribute rights\n-\t\t\tList<AttributeRights> rights = new ArrayList<>();\n-\t\t\trights.add(new AttributeRights(attrDef.getId(), Role.VOADMIN, Arrays.asList(ActionType.READ, ActionType.WRITE)));\n-\t\t\trights.add(new AttributeRights(attrDef.getId(), Role.GROUPADMIN, Arrays.asList(ActionType.READ, ActionType.WRITE)));\n-\t\t\tperun.getAttributesManager().setAttributeRights(registrarSession, rights);\n-\t\t}\n-\t\ttry {\n-\t\t\tattrManager.getAttributeDefinition(registrarSession, URN_VO_REGISTRAR_URL);\n-\t\t} catch (AttributeNotExistsException ex) {\n-\t\t\t// create attr if not exists\n-\t\t\tAttributeDefinition attrDef = new AttributeDefinition();\n-\t\t\tattrDef.setDisplayName(DISPLAY_NAME_VO_REGISTRAR_URL);\n-\t\t\tattrDef.setFriendlyName(FRIENDLY_NAME_VO_REGISTRAR_URL);\n-\t\t\tattrDef.setNamespace(NAMESPACE_VO_REGISTRAR_URL);\n-\t\t\tattrDef.setDescription(\"Custom URL used in registration notifications (hostname without any parameters like: https://hostname.domain/). If not set, default hostname of Perun instance is used.\");\n-\t\t\tattrDef.setType(String.class.getName());\n-\t\t\tattrDef = attrManager.createAttribute(registrarSession, attrDef);\n-\t\t\t// set attribute rights\n-\t\t\tList<AttributeRights> rights = new ArrayList<>();\n-\t\t\trights.add(new AttributeRights(attrDef.getId(), Role.VOADMIN, Arrays.asList(ActionType.READ, ActionType.WRITE)));\n-\t\t\tperun.getAttributesManager().setAttributeRights(registrarSession, rights);\n-\t\t}\n-\t\ttry {\n-\t\t\tattrManager.getAttributeDefinition(registrarSession, URN_GROUP_REGISTRAR_URL);\n-\t\t} catch (AttributeNotExistsException ex) {\n-\t\t\t// create attr if not exists\n-\t\t\tAttributeDefinition attrDef = new AttributeDefinition();\n-\t\t\tattrDef.setDisplayName(DISPLAY_NAME_GROUP_REGISTRAR_URL);\n-\t\t\tattrDef.setFriendlyName(FRIENDLY_NAME_GROUP_REGISTRAR_URL);\n-\t\t\tattrDef.setNamespace(NAMESPACE_GROUP_REGISTRAR_URL);\n-\t\t\tattrDef.setDescription(\"Custom URL used in registration notifications (hostname without any parameters like: https://hostname.domain/). This value override same VO setting. If not set, default hostname of Perun instance is used.\");\n-\t\t\tattrDef.setType(String.class.getName());\n-\t\t\tattrDef = attrManager.createAttribute(registrarSession, attrDef);\n-\t\t\t// set attribute rights\n-\t\t\tList<AttributeRights> rights = new ArrayList<>();\n-\t\t\trights.add(new AttributeRights(attrDef.getId(), Role.VOADMIN, Arrays.asList(ActionType.READ, ActionType.WRITE)));\n-\t\t\trights.add(new AttributeRights(attrDef.getId(), Role.GROUPADMIN, Arrays.asList(ActionType.READ, ActionType.WRITE)));\n-\t\t\tperun.getAttributesManager().setAttributeRights(registrarSession, rights);\n-\t\t}\n-\t\ttry {\n-\t\t\tattrManager.getAttributeDefinition(registrarSession, URN_VO_MAIL_FOOTER);\n-\t\t} catch (AttributeNotExistsException ex) {\n-\t\t\t// create attr if not exists\n-\t\t\tAttributeDefinition attrDef = new AttributeDefinition();\n-\t\t\tattrDef.setDisplayName(DISPLAY_NAME_VO_MAIL_FOOTER);\n-\t\t\tattrDef.setFriendlyName(FRIENDLY_NAME_VO_MAIL_FOOTER);\n-\t\t\tattrDef.setNamespace(NAMESPACE_VO_MAIL_FOOTER);\n-\t\t\tattrDef.setDescription(\"Email footer used in mail notifications by tag {mailFooter}. To edit text whithout loose of formatting, please use notification's GUI!!\");\n-\t\t\tattrDef.setType(String.class.getName());\n-\t\t\tattrDef = attrManager.createAttribute(registrarSession, attrDef);\n-\t\t\t// set attribute rights\n-\t\t\tList<AttributeRights> rights = new ArrayList<>();\n-\t\t\trights.add(new AttributeRights(attrDef.getId(), Role.VOADMIN, Arrays.asList(ActionType.READ, ActionType.WRITE)));\n-\t\t\tperun.getAttributesManager().setAttributeRights(registrarSession, rights);\n-\t\t}\n-\t\ttry {\n-\t\t\tattrManager.getAttributeDefinition(registrarSession, URN_GROUP_MAIL_FOOTER);\n-\t\t} catch (AttributeNotExistsException ex) {\n-\t\t\t// create attr if not exists\n-\t\t\tAttributeDefinition attrDef = new AttributeDefinition();\n-\t\t\tattrDef.setDisplayName(DISPLAY_NAME_GROUP_MAIL_FOOTER);\n-\t\t\tattrDef.setFriendlyName(FRIENDLY_NAME_GROUP_MAIL_FOOTER);\n-\t\t\tattrDef.setNamespace(NAMESPACE_GROUP_MAIL_FOOTER);\n-\t\t\tattrDef.setDescription(\"Email footer used in mail notifications by tag {mailFooter}. To edit text whithout loose of formatting, please use notification's GUI!!\");\n-\t\t\tattrDef.setType(String.class.getName());\n-\t\t\tattrDef = attrManager.createAttribute(registrarSession, attrDef);\n-\t\t\t// set attribute rights\n-\t\t\tList<AttributeRights> rights = new ArrayList<>();\n-\t\t\trights.add(new AttributeRights(attrDef.getId(), Role.VOADMIN, Arrays.asList(ActionType.READ, ActionType.WRITE)));\n-\t\t\trights.add(new AttributeRights(attrDef.getId(), Role.GROUPADMIN, Arrays.asList(ActionType.READ, ActionType.WRITE)));\n-\t\t\tperun.getAttributesManager().setAttributeRights(registrarSession, rights);\n-\t\t}\n-\t\ttry {\n-\t\t\tattrManager.getAttributeDefinition(registrarSession, \"urn:perun:vo:attribute-def:def:voLogoURL\");\n-\t\t} catch (AttributeNotExistsException ex) {\n-\t\t\t// create attr if not exists\n-\t\t\tAttributeDefinition attrDef = new AttributeDefinition();\n-\t\t\tattrDef.setDisplayName(\"VO logo's URL\");\n-\t\t\tattrDef.setFriendlyName(\"voLogoURL\");\n-\t\t\tattrDef.setNamespace(\"urn:perun:vo:attribute-def:def\");\n-\t\t\tattrDef.setDescription(\"Full URL of the VO's logo image (including https://) or base64 encoded data like: 'data:image/png;base64,....'\");\n-\t\t\tattrDef.setType(BeansUtils.largeStringClassName);\n-\t\t\tattrDef = attrManager.createAttribute(registrarSession, attrDef);\n-\t\t\t// set attribute rights\n-\t\t\tList<AttributeRights> rights = new ArrayList<>();\n-\t\t\trights.add(new AttributeRights(attrDef.getId(), Role.VOADMIN, Arrays.asList(ActionType.READ, ActionType.WRITE)));\n-\t\t\tperun.getAttributesManager().setAttributeRights(registrarSession, rights);\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic List<Attribute> initialize(String voShortName, String groupName) throws PerunException {\n-\n-\t\tVo vo = vosManager.getVoByShortName(registrarSession, voShortName);\n-\t\tList<Attribute> list = attrManager.getAttributes(registrarSession, vo);\n-\t\t// load group info if needed\n-\t\tif (groupName != null && !groupName.isEmpty()) {\n-\t\t\tGroup group = groupsManager.getGroupByName(registrarSession, vo, groupName);\n-\t\t\tlist.addAll(attrManager.getAttributes(registrarSession, group));\n-\t\t}\n-\t\treturn list;\n-\n-\t}\n-\n-\t@Override\n-\tpublic Map<String, Object> initRegistrar(PerunSession sess, String voShortName, String groupName) throws PerunException {\n-\n-\t\tMap<String, Object> result = new HashMap<>();\n-\t\tVo vo;\n-\t\tGroup group;\n-\n-\t\ttry {\n-\n-\t\t\t// GET VO\n-\t\t\tvo = vosManager.getVoByShortName(sess, voShortName);\n-\t\t\tList<Attribute> list = attrManager.getAttributes(sess, vo,\n-\t\t\t\t\tArrays.asList(AttributesManager.NS_VO_ATTR_DEF+\":contactEmail\",\n-\t\t\t\t\t\t\tAttributesManager.NS_VO_ATTR_DEF+\":voLogoURL\"));\n-\n-\t\t\tresult.put(\"vo\", vo);\n-\t\t\tresult.put(\"voAttributes\", list);\n-\t\t\tresult.put(\"voForm\", getFormForVo(vo));\n-\n-\t\t\t// GET INITIAL APPLICATION IF POSSIBLE\n-\t\t\ttry {\n-\n-\t\t\t\tresult.put(\"voFormInitial\", getFormItemsWithPrefilledValues(sess, AppType.INITIAL, (ApplicationForm) result.get(\"voForm\")));\n-\n-\t\t\t} catch (DuplicateRegistrationAttemptException ex) {\n-\t\t\t\t// has submitted application\n-\t\t\t\tresult.put(\"voFormInitialException\", ex);\n-\t\t\t} catch (AlreadyRegisteredException ex) {\n-\t\t\t\t// is already member of VO\n-\t\t\t\tresult.put(\"voFormInitialException\", ex);\n-\t\t\t} catch (ExtendMembershipException ex) {\n-\t\t\t\t// can't become member of VO\n-\t\t\t\tresult.put(\"voFormInitialException\", ex);\n-\t\t\t} catch (MissingRequiredDataException ex) {\n-\t\t\t\t// can't display form\n-\t\t\t\tresult.put(\"voFormInitialException\", ex);\n-\t\t\t} catch (CantBeSubmittedException ex) {\n-\t\t\t\t// can't display form / become member by some custom rules\n-\t\t\t\tresult.put(\"voFormInitialException\", ex);\n-\t\t\t}\n-\n-\t\t\t// ONLY EXISTING USERS CAN EXTEND VO MEMBERSHIP\n-\t\t\tif (sess.getPerunPrincipal().getUser() != null) {\n-\n-\t\t\t\ttry {\n-\t\t\t\t\tresult.put(\"voFormExtension\", getFormItemsWithPrefilledValues(sess, AppType.EXTENSION, (ApplicationForm) result.get(\"voForm\")));\n-\t\t\t\t} catch (DuplicateRegistrationAttemptException ex) {\n-\t\t\t\t\t// has submitted application\n-\t\t\t\t\tresult.put(\"voFormExtensionException\", ex);\n-\t\t\t\t} catch (RegistrarException ex) {\n-\t\t\t\t\t// more severe exception like bad input/inconsistency\n-\t\t\t\t\tresult.put(\"voFormExtensionException\", ex);\n-\t\t\t\t} catch (ExtendMembershipException ex) {\n-\t\t\t\t\t// can't extend membership in VO\n-\t\t\t\t\tresult.put(\"voFormExtensionException\", ex);\n-\t\t\t\t} catch (MemberNotExistsException ex) {\n-\t\t\t\t\t// is not member -> can't extend\n-\t\t\t\t\tresult.put(\"voFormExtensionException\", ex);\n-\t\t\t\t} catch (MissingRequiredDataException ex) {\n-\t\t\t\t\t// can't display form\n-\t\t\t\t\tresult.put(\"voFormExtensionException\", ex);\n-\t\t\t\t} catch (CantBeSubmittedException ex) {\n-\t\t\t\t\t// can't display form / extend membership by some custom rules\n-\t\t\t\t\tresult.put(\"voFormExtensionException\", ex);\n-\t\t\t\t}\n-\n-\t\t\t}\n-\n-\t\t\t// GET GROUP IF RELEVANT\n-\t\t\tif (groupName != null && !groupName.isEmpty()) {\n-\n-\t\t\t\tgroup = groupsManager.getGroupByName(sess, vo, groupName);\n-\t\t\t\tresult.put(\"group\", group);\n-\t\t\t\tresult.put(\"groupForm\", getFormForGroup(group));\n-\n-\t\t\t\ttry {\n-\t\t\t\t\tresult.put(\"groupFormInitial\", getFormItemsWithPrefilledValues(sess, AppType.INITIAL, (ApplicationForm) result.get(\"groupForm\")));\n-\t\t\t\t} catch (DuplicateRegistrationAttemptException ex) {\n-\t\t\t\t\t// has submitted application\n-\t\t\t\t\tresult.put(\"groupFormInitialException\", ex);\n-\t\t\t\t} catch (AlreadyRegisteredException ex) {\n-\t\t\t\t\t// is already member of group\n-\t\t\t\t\tresult.put(\"groupFormInitialException\", ex);\n-\t\t\t\t} catch (RegistrarException ex) {\n-\t\t\t\t\t// more severe exception like bad input/inconsistency\n-\t\t\t\t\tresult.put(\"groupFormInitialException\", ex);\n-\t\t\t\t} catch (ExtendMembershipException ex) {\n-\t\t\t\t\t// can't become member of VO -> then can't be member of group either\n-\t\t\t\t\tresult.put(\"groupFormInitialException\", ex);\n-\t\t\t\t}  catch (MissingRequiredDataException ex) {\n-\t\t\t\t\t// can't display form\n-\t\t\t\t\tresult.put(\"groupFormInitialException\", ex);\n-\t\t\t\t} catch (CantBeSubmittedException ex) {\n-\t\t\t\t\t// can't display form / become member by some custom rules\n-\t\t\t\t\tresult.put(\"groupFormInitialException\", ex);\n-\t\t\t\t}\n-\n-\t\t\t}\n-\n-\t\t\t// ONLY EXISTING USERS CAN EXTEND GROUP MEMBERSHIP\n-\t\t\tif (sess.getPerunPrincipal().getUser() != null && groupName != null && !groupName.isEmpty()) {\n-\n-\t\t\t\ttry {\n-\t\t\t\t\tresult.put(\"groupFormExtension\", getFormItemsWithPrefilledValues(sess, AppType.EXTENSION, (ApplicationForm) result.get(\"groupForm\")));\n-\t\t\t\t} catch (DuplicateRegistrationAttemptException ex) {\n-\t\t\t\t\t// has submitted application\n-\t\t\t\t\tresult.put(\"groupFormExtensionException\", ex);\n-\t\t\t\t} catch (RegistrarException ex) {\n-\t\t\t\t\t// more severe exception like bad input/inconsistency\n-\t\t\t\t\tresult.put(\"groupFormExtensionException\", ex);\n-\t\t\t\t} catch (ExtendMembershipException ex) {\n-\t\t\t\t\t// can't extend membership in Group\n-\t\t\t\t\tresult.put(\"groupFormExtensionException\", ex);\n-\t\t\t\t} catch (MemberNotExistsException ex) {\n-\t\t\t\t\t// is not member -> can't extend\n-\t\t\t\t\tresult.put(\"groupFormExtensionException\", ex);\n-\t\t\t\t} catch (NotGroupMemberException ex) {\n-\t\t\t\t\t// is not member of Group -> can't extend\n-\t\t\t\t\tresult.put(\"groupFormExtensionException\", ex);\n-\t\t\t\t} catch (MissingRequiredDataException ex) {\n-\t\t\t\t\t// can't display form\n-\t\t\t\t\tresult.put(\"groupFormExtensionException\", ex);\n-\t\t\t\t} catch (CantBeSubmittedException ex) {\n-\t\t\t\t\t// can't display form / extend membership by some custom rules\n-\t\t\t\t\tresult.put(\"groupFormExtensionException\", ex);\n-\t\t\t\t}\n-\n-\t\t\t}\n-\n-\t\t\t// FIND SIMILAR USERS\n-\t\t\ttry {\n-\t\t\t\tList<Identity> similarUsers = getConsolidatorManager().checkForSimilarUsers(sess);\n-\t\t\t\tif (similarUsers != null && !similarUsers.isEmpty()) {\n-\t\t\t\t\tlog.debug(\"Similar users found for {} / {}: {}\", sess.getPerunPrincipal().getActor(), sess.getPerunPrincipal().getExtSourceName(), similarUsers);\n-\t\t\t\t}\n-\t\t\t\tresult.put(\"similarUsers\", similarUsers);\n-\t\t\t} catch (Exception ex) {\n-\t\t\t\t// not relevant exception in this use-case\n-\t\t\t\tlog.error(\"[REGISTRAR] Exception when searching for similar users.\", ex);\n-\t\t\t}\n-\n-\t\t} catch (Exception ex) {\n-\n-\t\t\t// we don't have to try any more, return exception\n-\t\t\tresult.put(\"exception\", ex);\n-\t\t\treturn result;\n-\n-\t\t}\n-\n-\t\treturn result;\n-\n-\t}\n-\n-\t@Override\n-\tpublic void createApplicationFormInVo(PerunSession sess, Vo vo) throws PrivilegeException, VoNotExistsException {\n-\t\tvosManager.checkVoExists(sess, vo);\n-\n-\t\t//Authorization\n-\t\tif (!AuthzResolver.authorizedInternal(sess, \"createApplicationFormInVo_Vo_policy\", Collections.singletonList(vo))) {\n-\t\t\tthrow new PrivilegeException(sess, \"createApplicationFormInVo\");\n-\t\t}\n-\n-\t\tint id = Utils.getNewId(jdbc, \"APPLICATION_FORM_ID_SEQ\");\n-\t\ttry {\n-\t\t\tjdbc.update(\"insert into application_form(id, vo_id) values (?,?)\", id, vo.getId());\n-\t\t} catch (DuplicateKeyException ex) {\n-\t\t\tthrow new ConsistencyErrorException(\"VO can have defined only one application form. Can't insert another.\", ex);\n-\t\t}\n-\n-\t}\n-\n-\t@Override\n-\tpublic void createApplicationFormInGroup(PerunSession sess, Group group) throws PrivilegeException, GroupNotExistsException {\n-\t\tgroupsManager.checkGroupExists(sess, group);\n-\n-\t\t//Authorization\n-\t\tif (!AuthzResolver.authorizedInternal(sess, \"createApplicationFormInGroup_Group_policy\", Collections.singletonList(group))) {\n-\t\t\tthrow new PrivilegeException(sess, \"createApplicationFormInGroup\");\n-\t\t}\n-\n-\t\tint id = Utils.getNewId(jdbc, \"APPLICATION_FORM_ID_SEQ\");\n-\t\ttry {\n-\t\t\tjdbc.update(\"insert into application_form(id, vo_id, group_id) values (?,?,?)\", id, group.getVoId(), group.getId());\n-\t\t} catch (DuplicateKeyException ex) {\n-\t\t\tthrow new ConsistencyErrorException(\"Group can have defined only one application form. Can't insert another.\", ex);\n-\t\t}\n-\n-\t}\n-\n-\t@Override\n-\tpublic ApplicationForm getFormForVo(final Vo vo) throws FormNotExistsException {\n-\n-\t\tif (vo == null) throw new FormNotExistsException(\"VO can't be null\");\n-\n-\t\ttry {\n-\t\t\treturn jdbc.queryForObject(FORM_SELECT + \" where vo_id=? and group_id is null\", (resultSet, arg1) -> {\n-\t\t\t\tApplicationForm form = new ApplicationForm();\n-\t\t\t\tform.setId(resultSet.getInt(\"id\"));\n-\t\t\t\tform.setAutomaticApproval(resultSet.getBoolean(\"automatic_approval\"));\n-\t\t\t\tform.setAutomaticApprovalExtension(resultSet.getBoolean(\"automatic_approval_extension\"));\n-\t\t\t\tform.setModuleClassName(resultSet.getString(\"module_name\"));\n-\t\t\t\tform.setVo(vo);\n-\t\t\t\treturn form;\n-\t\t\t}, vo.getId());\n-\t\t} catch (EmptyResultDataAccessException ex) {\n-\t\t\tthrow new FormNotExistsException(\"Form for VO: \"+vo.getName()+\" doesn't exists.\");\n-\t\t} catch (Exception ex) {\n-\t\t\tthrow new InternalErrorException(ex.getMessage(), ex);\n-\t\t}\n-\n-\t}\n-\n-\t@Override\n-\tpublic ApplicationForm getFormForGroup(final Group group) throws FormNotExistsException {\n-\n-\t\tif (group == null) throw new FormNotExistsException(\"Group can't be null\");\n-\n-\t\ttry {\n-\t\t\treturn jdbc.queryForObject(FORM_SELECT + \" where vo_id=? and group_id=?\", (resultSet, arg1) -> {\n-\t\t\t\tApplicationForm form = new ApplicationForm();\n-\t\t\t\tform.setId(resultSet.getInt(\"id\"));\n-\t\t\t\tform.setAutomaticApproval(resultSet.getBoolean(\"automatic_approval\"));\n-\t\t\t\tform.setAutomaticApprovalExtension(resultSet.getBoolean(\"automatic_approval_extension\"));\n-\t\t\t\tform.setModuleClassName(resultSet.getString(\"module_name\"));\n-\t\t\t\tform.setGroup(group);\n-\t\t\t\ttry {\n-\t\t\t\t\tform.setVo(vosManager.getVoById(registrarSession, group.getVoId()));\n-\t\t\t\t} catch (Exception ex) {\n-\t\t\t\t\t// we don't care, shouldn't happen for internal identity.\n-\t\t\t\t}\n-\t\t\t\treturn form;\n-\t\t\t}, group.getVoId(), group.getId());\n-\t\t} catch (EmptyResultDataAccessException ex) {\n-\t\t\tthrow new FormNotExistsException(\"Form for Group: \"+group.getName()+\" doesn't exists.\");\n-\t\t} catch (Exception ex) {\n-\t\t\tthrow new InternalErrorException(ex.getMessage(), ex);\n-\t\t}\n-\n-\t}\n-\n-\t@Override\n-\tpublic ApplicationForm getFormById(PerunSession sess, int id) throws PrivilegeException, FormNotExistsException {\n-\n-\t\ttry {\n-\t\t\tApplicationForm form = jdbc.queryForObject(FORM_SELECT + \" where id=?\", (resultSet, arg1) -> {\n-\t\t\t\tApplicationForm form1 = new ApplicationForm();\n-\t\t\t\tform1.setId(resultSet.getInt(\"id\"));\n-\t\t\t\tform1.setAutomaticApproval(resultSet.getBoolean(\"automatic_approval\"));\n-\t\t\t\tform1.setAutomaticApprovalExtension(resultSet.getBoolean(\"automatic_approval_extension\"));\n-\t\t\t\tform1.setModuleClassName(resultSet.getString(\"module_name\"));\n-\t\t\t\ttry {\n-\t\t\t\t\tform1.setVo(vosManager.getVoById(sess, resultSet.getInt(\"vo_id\")));\n-\t\t\t\t} catch (Exception ex) {\n-\t\t\t\t\t// we don't care, shouldn't happen for internal identity.\n-\t\t\t\t}\n-\t\t\t\ttry {\n-\t\t\t\t\tif (resultSet.getInt(\"group_id\") != 0)\n-\t\t\t\t\t\tform1.setGroup(groupsManager.getGroupById(sess, resultSet.getInt(\"group_id\")));\n-\t\t\t\t} catch (Exception ex) {\n-\t\t\t\t\t// we don't care, shouldn't happen for internal identity.\n-\t\t\t\t}\n-\t\t\t\treturn form1;\n-\t\t\t}, id);\n-\n-\t\t\tif (form == null) throw new FormNotExistsException(\"Form with ID: \"+id+\" doesn't exists.\");\n-\n-\t\t\t//Authorization\n-\t\t\tif (Objects.isNull(form.getGroup())) {\n-\t\t\t\t// VO application\n-\t\t\t\tif (!AuthzResolver.authorizedInternal(sess, \"vo-getFormById_int_policy\", Collections.singletonList(form.getVo()))) {\n-\t\t\t\t\tthrow new PrivilegeException(sess, \"getFormById\");\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\tif (!AuthzResolver.authorizedInternal(sess, \"group-getFormById_int_policy\", Arrays.asList(form.getVo(), form.getGroup()))) {\n-\t\t\t\t\tthrow new PrivilegeException(sess, \"getFormById\");\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\treturn form;\n-\n-\t\t} catch (EmptyResultDataAccessException ex) {\n-\t\t\tthrow new FormNotExistsException(\"Form with ID: \"+id+\" doesn't exists.\");\n-\t\t}\n-\n-\t}\n-\n-\t@Override\n-\tpublic ApplicationForm getFormByItemId(PerunSession sess, int id) throws PrivilegeException, FormNotExistsException {\n-\n-\t\ttry {\n-\t\t\tApplicationForm form = jdbc.queryForObject(FORM_SELECT + \" where id=(select form_id from application_form_items where id=?)\", (resultSet, arg1) -> {\n-\t\t\t\tApplicationForm form1 = new ApplicationForm();\n-\t\t\t\tform1.setId(resultSet.getInt(\"id\"));\n-\t\t\t\tform1.setAutomaticApproval(resultSet.getBoolean(\"automatic_approval\"));\n-\t\t\t\tform1.setAutomaticApprovalExtension(resultSet.getBoolean(\"automatic_approval_extension\"));\n-\t\t\t\tform1.setModuleClassName(resultSet.getString(\"module_name\"));\n-\t\t\t\ttry {\n-\t\t\t\t\tform1.setVo(vosManager.getVoById(sess, resultSet.getInt(\"vo_id\")));\n-\t\t\t\t} catch (Exception ex) {\n-\t\t\t\t\t// we don't care, shouldn't happen for internal identity.\n-\t\t\t\t}\n-\t\t\t\ttry {\n-\t\t\t\t\tif (resultSet.getInt(\"group_id\") != 0)\n-\t\t\t\t\t\tform1.setGroup(groupsManager.getGroupById(sess, resultSet.getInt(\"group_id\")));\n-\t\t\t\t} catch (Exception ex) {\n-\t\t\t\t\t// we don't care, shouldn't happen for internal identity.\n-\t\t\t\t}\n-\t\t\t\treturn form1;\n-\t\t\t}, id);\n-\n-\t\t\tif (Objects.isNull(form)) throw new FormNotExistsException(\"Form with ID: \"+id+\" doesn't exists.\");\n-\n-\t\t\t//Authorization\n-\t\t\tif (form.getGroup() == null) {\n-\t\t\t\t// VO application\n-\t\t\t\tif (!AuthzResolver.authorizedInternal(sess, \"vo-getFormByItemId_int_policy\", Collections.singletonList(form.getVo()))) {\n-\t\t\t\t\tthrow new PrivilegeException(sess, \"getFormByItemId\");\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\tif (!AuthzResolver.authorizedInternal(sess, \"group-getFormByItemId_int_policy\", Arrays.asList(form.getVo(), form.getGroup()))) {\n-\t\t\t\t\tthrow new PrivilegeException(sess, \"getFormByItemId\");\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\treturn form;\n-\n-\t\t} catch (EmptyResultDataAccessException ex) {\n-\t\t\tthrow new FormNotExistsException(\"Form with ID: \"+id+\" doesn't exists.\");\n-\t\t}\n-\n-\t}\n-\n-\t@Transactional\n-\t@Override\n-\tpublic ApplicationFormItem addFormItem(PerunSession user, ApplicationForm form, ApplicationFormItem item) throws PrivilegeException {\n-\n-\t\t//Authorization\n-\t\tif (form.getGroup() == null) {\n-\t\t\t// VO application\n-\t\t\tif (!AuthzResolver.authorizedInternal(user, \"vo-addFormItem_ApplicationForm_ApplicationFormItem_policy\", Collections.singletonList(form.getVo()))) {\n-\t\t\t\tthrow new PrivilegeException(user, \"addFormItem\");\n-\t\t\t}\n-\t\t} else {\n-\t\t\tif (!AuthzResolver.authorizedInternal(user, \"group-addFormItem_ApplicationForm_ApplicationFormItem_policy\", Arrays.asList(form.getVo(), form.getGroup()))) {\n-\t\t\t\tthrow new PrivilegeException(user, \"addFormItem\");\n-\t\t\t}\n-\t\t}\n-\n-\t\t// find the ordinal number of the next item\n-\t\tint ordnum = 0;\n-\t\tif (item.getOrdnum() == null || item.getOrdnum() < 0) {\n-\t\t\tif (jdbc.queryForInt(\"select count(*) from application_form_items where form_id=?\", form.getId()) > 0) {\n-\t\t\t\tordnum = jdbc.queryForInt(\"select max(ordnum)+1 from application_form_items where form_id=?\", form.getId());\n-\t\t\t}\n-\t\t} else {\n-\t\t\t// use predefined ordnum\n-\t\t\tordnum = item.getOrdnum();\n-\t\t}\n-\n-\t\tint itemId = Utils.getNewId(jdbc, \"APPLICATION_FORM_ITEMS_ID_SEQ\");\n-\t\tjdbc.update(\n-\t\t\t\t\"insert into application_form_items(id,form_id,ordnum,shortname,required,type,fed_attr,src_attr,dst_attr,regex) values (?,?,?,?,?,?,?,?,?,?)\",\n-\t\t\t\titemId, form.getId(), ordnum, item.getShortname(), item.isRequired(),\n-\t\t\t\titem.getType().name(), item.getFederationAttribute(),\n-\t\t\t\titem.getPerunSourceAttribute(), item.getPerunDestinationAttribute(), item.getRegex());\n-\n-\t\t// create texts\n-\t\tfor (Locale locale : item.getI18n().keySet()) {\n-\t\t\tItemTexts itemTexts = item.getTexts(locale);\n-\t\t\tjdbc.update(\"insert into application_form_item_texts(item_id,locale,label,options,help,error_message) values (?,?,?,?,?,?)\",\n-\t\t\t\t\titemId, locale.getLanguage(), itemTexts.getLabel(),\n-\t\t\t\t\titemTexts.getOptions(), itemTexts.getHelp(),\n-\t\t\t\t\titemTexts.getErrorMessage());\n-\t\t}\n-\t\tfor (AppType appType : item.getApplicationTypes()) {\n-\t\t\tjdbc.update(\"insert into application_form_item_apptypes (item_id,apptype) values (?,?)\",\n-\t\t\t\t\titemId, appType.toString());\n-\t\t}\n-\n-\t\t// set new properties back to object & return\n-\t\titem.setOrdnum(ordnum);\n-\t\titem.setId(itemId);\n-\t\tperun.getAuditer().log(user, new FormItemAdded(form));\n-\t\treturn item;\n-\n-\t}\n-\n-\t@Override\n-\t@Transactional(rollbackFor = Exception.class)\n-\tpublic int updateFormItems(PerunSession sess, ApplicationForm form, List<ApplicationFormItem> items) throws PrivilegeException {\n-\n-\t\t//Authorization\n-\t\tif (form.getGroup() == null) {\n-\t\t\t// VO application\n-\t\t\tif (!AuthzResolver.authorizedInternal(sess, \"vo-updateFormItems_ApplicationForm_List<ApplicationFormItem>_policy\", Collections.singletonList(form.getVo()))) {\n-\t\t\t\tthrow new PrivilegeException(sess, \"updateFormItems\");\n-\t\t\t}\n-\t\t} else {\n-\t\t\tif (!AuthzResolver.authorizedInternal(sess, \"group-updateFormItems_ApplicationForm_List<ApplicationFormItem>_policy\", Arrays.asList(form.getVo(), form.getGroup()))) {\n-\t\t\t\tthrow new PrivilegeException(sess, \"updateFormItems\");\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (items == null) {\n-\t\t\tthrow new NullPointerException(\"ApplicationFormItems to update can't be null\");\n-\t\t}\n-\t\tint finalResult = 0;\n-\t\tfor (ApplicationFormItem item : items) {\n-\n-\t\t\t// is item to create ? => create\n-\t\t\tif (item.getId() == 0 && !item.isForDelete()) {\n-\t\t\t\tif (addFormItem(sess, form, item) != null) {\n-\t\t\t\t\tfinalResult++;\n-\t\t\t\t}\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\t// is item for deletion ? => delete on cascade\n-\t\t\tif (item.isForDelete()) {\n-\t\t\t\tfinalResult += jdbc.update(\"delete from application_form_items where id=?\", item.getId());\n-\t\t\t\tcontinue; // continue to next item\n-\t\t\t}\n-\n-\t\t\t// else update form item\n-\n-\t\t\tint result = jdbc.update(\"update application_form_items set ordnum=?,shortname=?,required=?,type=?,fed_attr=?,src_attr=?,dst_attr=?,regex=? where id=?\",\n-\t\t\t\t\titem.getOrdnum(), item.getShortname(), item.isRequired(),\n-\t\t\t\t\titem.getType().toString(), item.getFederationAttribute(),\n-\t\t\t\t\titem.getPerunSourceAttribute(), item.getPerunDestinationAttribute(),\n-\t\t\t\t\titem.getRegex(), item.getId());\n-\t\t\tfinalResult += result;\n-\t\t\tif (result == 0) {\n-\t\t\t\t// skip whole set if not found for update\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\t// update form item texts (easy way = delete and new insert)\n-\n-\t\t\t// delete\n-\t\t\tjdbc.update(\"delete from application_form_item_texts where item_id=?\", item.getId());\n-\t\t\t// insert new\n-\t\t\tfor (Locale locale : item.getI18n().keySet()) {\n-\t\t\t\tItemTexts itemTexts = item.getTexts(locale);\n-\t\t\t\tjdbc.update(\"insert into application_form_item_texts(item_id,locale,label,options,help,error_message) values (?,?,?,?,?,?)\",\n-\t\t\t\t\t\titem.getId(), locale.getLanguage(), itemTexts.getLabel(),\n-\t\t\t\t\t\titemTexts.getOptions(), itemTexts.getHelp(),\n-\t\t\t\t\t\titemTexts.getErrorMessage());\n-\t\t\t}\n-\n-\t\t\t// update form item app types (easy way = delete and new insert)\n-\n-\t\t\t// delete\n-\t\t\tjdbc.update(\"delete from application_form_item_apptypes where item_id=?\", item.getId());\n-\t\t\t// insert new\n-\t\t\tfor (AppType appType : item.getApplicationTypes()) {\n-\t\t\t\tjdbc.update(\"insert into application_form_item_apptypes (item_id,apptype) values (?,?)\",\n-\t\t\t\t\t\titem.getId(), appType.toString());\n-\t\t\t}\n-\t\t}\n-\n-\t\tperun.getAuditer().log(sess, new FormItemsUpdated(form));\n-\t\t// return number of updated rows\n-\t\treturn finalResult;\n-\n-\t}\n-\n-\t@Override\n-\tpublic int updateForm(PerunSession user, ApplicationForm form) throws PrivilegeException {\n-\n-\t\t//Authorization\n-\t\tif (form.getGroup() == null) {\n-\t\t\t// VO application\n-\t\t\tif (!AuthzResolver.authorizedInternal(user, \"vo-updateForm_ApplicationForm_policy\", Collections.singletonList(form.getVo()))) {\n-\t\t\t\tthrow new PrivilegeException(user, \"updateForm\");\n-\t\t\t}\n-\t\t} else {\n-\t\t\tif (!AuthzResolver.authorizedInternal(user, \"group-updateForm_ApplicationForm_policy\", Arrays.asList(form.getVo(), form.getGroup()))) {\n-\t\t\t\tthrow new PrivilegeException(user, \"updateForm\");\n-\t\t\t}\n-\t\t}\n-\n-\t\tperun.getAuditer().log(user, new FormUpdated((form)));\n-\t\treturn jdbc.update(\n-\t\t\t\t\"update application_form set automatic_approval=?, automatic_approval_extension=?, module_name=? where id=?\",\n-\t\t\t\tform.isAutomaticApproval(), form.isAutomaticApprovalExtension(), form.getModuleClassName(), form.getId());\n-\t}\n-\n-\t@Transactional\n-\t@Override\n-\tpublic void deleteFormItem(PerunSession user, ApplicationForm form, int ordnum) throws PrivilegeException {\n-\n-\t\t//Authorization\n-\t\tif (!AuthzResolver.authorizedInternal(user, \"deleteFormItem_ApplicationForm_int_policy\", Collections.singletonList(form.getVo()))) {\n-\t\t\tthrow new PrivilegeException(user, \"deleteFormItem\");\n-\t\t}\n-\n-\t\tjdbc.update(\"delete from application_form_items where form_id=? and ordnum=?\", form.getId(), ordnum);\n-\t\tjdbc.update(\"update application_form_items set ordnum=ordnum-1 where form_id=? and ordnum>?\", form.getId(), ordnum);\n-\n-\t\tperun.getAuditer().log(user, new FormItemDeleted(form));\n-\n-\t}\n-\n-\t@Transactional\n-\t@Override\n-\tpublic void moveFormItem(PerunSession user, ApplicationForm form, int ordnum, boolean up) throws PrivilegeException {\n-\n-\t\t//Authorization\n-\t\tif (!AuthzResolver.authorizedInternal(user, \"moveFormItem_ApplicationForm_int_boolean_policy\", Collections.singletonList(form.getVo()))) {\n-\t\t\tthrow new PrivilegeException(user, \"moveFormItem\");\n-\t\t}\n-\n-\t\tif (up && ordnum == 0) throw new InternalErrorException(\"cannot move topmost item up\");\n-\n-\t\tint numItems = jdbc.queryForInt(\"select count(*) from application_form_items where form_id=?\", form.getId());\n-\n-\t\tif (!up && ordnum == numItems - 1) throw new InternalErrorException(\"cannot move lowest item down\");\n-\n-\t\tint id1 = jdbc.queryForInt(\n-\t\t\t\t\"select id from application_form_items where form_id=? and ordnum=?\",\n-\t\t\t\tform.getId(), (up ? ordnum - 1 : ordnum));\n-\t\tint id2 = jdbc.queryForInt(\n-\t\t\t\t\"select id from application_form_items where form_id=? and ordnum=?\",\n-\t\t\t\tform.getId(), (up ? ordnum : ordnum + 1));\n-\t\tjdbc.update(\"update application_form_items set ordnum=ordnum+1 where id=?\",\n-\t\t\t\tid1);\n-\t\tjdbc.update(\"update application_form_items set ordnum=ordnum-1 where id=?\",\n-\t\t\t\tid2);\n-\n-\t}\n-\n-\t@Override\n-\tpublic void updateFormItemTexts(PerunSession sess, ApplicationFormItem item, Locale locale) throws PrivilegeException, FormNotExistsException {\n-\n-\t\ttry {\n-\t\t\tgetFormByItemId(sess, item.getId());\n-\t\t} catch (PrivilegeException ex) {\n-\t\t\tthrow new PrivilegeException(sess, \"updateFormItemTexts\");\n-\t\t}\n-\n-\t\tItemTexts texts = item.getTexts(locale);\n-\t\tjdbc.update(\"update application_form_item_texts set label=?,options=?,help=?,error_message=? where item_id=? and locale=?\",\n-\t\t\t\ttexts.getLabel(), texts.getOptions(), texts.getHelp(),\n-\t\t\t\ttexts.getErrorMessage(), item.getId(), locale.getLanguage());\n-\n-\t}\n-\n-\t@Override\n-\tpublic void updateFormItemTexts(PerunSession sess, ApplicationFormItem item) throws PrivilegeException, FormNotExistsException {\n-\n-\t\tApplicationForm form;\n-\n-\t\t// check authz on form\n-\t\ttry {\n-\t\t\tform = getFormByItemId(sess, item.getId());\n-\t\t} catch (PrivilegeException ex) {\n-\t\t\tthrow new PrivilegeException(sess, \"updateFormItemById\");\n-\t\t}\n-\n-\t\t//Authorization\n-\t\tif (form.getGroup() == null) {\n-\t\t\tif (!AuthzResolver.authorizedInternal(sess, \"vo-updateFormItemTexts_ApplicationFormItem_policy\", Collections.singletonList(form.getVo()))) {\n-\t\t\t\tthrow new PrivilegeException(sess, \"updateFormItemById\");\n-\t\t\t}\n-\t\t} else {\n-\t\t\tif (!AuthzResolver.authorizedInternal(sess, \"group-updateFormItemTexts_ApplicationFormItem_policy\", Arrays.asList(form.getVo(), form.getGroup()))) {\n-\t\t\t\tthrow new PrivilegeException(sess, \"updateFormItemById\");\n-\t\t\t}\n-\t\t}\n-\n-\t\t// update form item texts (easy way = delete and new insert)\n-\n-\t\t// delete\n-\t\tjdbc.update(\"delete from application_form_item_texts where item_id=?\", item.getId());\n-\t\t// insert new\n-\t\tfor (Locale locale : item.getI18n().keySet()) {\n-\t\t\tItemTexts itemTexts = item.getTexts(locale);\n-\t\t\tjdbc.update(\"insert into application_form_item_texts(item_id,locale,label,options,help,error_message) values (?,?,?,?,?,?)\",\n-\t\t\t\t\titem.getId(), locale.getLanguage(), itemTexts.getLabel(),\n-\t\t\t\t\titemTexts.getOptions(), itemTexts.getHelp(),\n-\t\t\t\t\titemTexts.getErrorMessage());\n-\t\t}\n-\n-\t}\n-\n-\t@Override\n-\t@Deprecated\n-\tpublic List<ApplicationFormItemData> createApplication(PerunSession session, Application application, List<ApplicationFormItemData> data) throws PerunException {\n-\t\tint appId = processApplication(session, application, data);\n-\t\treturn getApplicationDataById(session, appId);\n-\t}\n-\n-\t@Override\n-\tpublic Application submitApplication(PerunSession session, Application application, List<ApplicationFormItemData> data) throws PerunException {\n-\t\tint appId = processApplication(session, application, data);\n-\t\treturn getApplicationById(appId);\n-\t}\n-\n-\t@Override\n-\t@Transactional(rollbackFor = ApplicationNotCreatedException.class)\n-\tpublic Application createApplicationInternal(PerunSession session, Application application, List<ApplicationFormItemData> data) throws PerunException {\n-\n-\t\t// exceptions to send to vo admin with new app created email\n-\t\tList<Exception> exceptions = new ArrayList<>();\n-\t\tboolean applicationNotCreated = false;\n-\n-\t\ttry {\n-\n-\t\t\t// 1) create application\n-\t\t\tint appId = Utils.getNewId(jdbc, \"APPLICATION_ID_SEQ\");\n-\t\t\tapplication.setId(appId);\n-\n-\t\t\tapplication.setState(AppState.NEW);\n-\n-\t\t\t// optional group\n-\t\t\tInteger groupId = null;\n-\t\t\tInteger userId = null;\n-\t\t\tif (application.getGroup() != null) {\n-\t\t\t\tgroupId = application.getGroup().getId();\n-\t\t\t}\n-\t\t\tif (application.getUser() != null) {\n-\t\t\t\tuserId = application.getUser().getId();\n-\t\t\t}\n-\n-\t\t\tjdbc.update(\"insert into application(id,vo_id,group_id,user_id,apptype,fed_info,extSourceName,extSourceType,extSourceLoa,state,created_by,modified_by) values (?,?,?,?,?,?,?,?,?,?,?,?)\",\n-\t\t\t\t\tappId, application.getVo().getId(), groupId, userId,\n-\t\t\t\t\tapplication.getType().toString(), application.getFedInfo(),\n-\t\t\t\t\tapplication.getExtSourceName(), application.getExtSourceType(),\n-\t\t\t\t\tapplication.getExtSourceLoa(), application.getState().toString(),\n-\t\t\t\t\tapplication.getCreatedBy(),application.getCreatedBy());\n-\n-\t\t\t// 2) process & store app data\n-\t\t\tfor (ApplicationFormItemData itemData : data) {\n-\n-\t\t\t\tType itemType = itemData.getFormItem().getType();\n-\t\t\t\tif (itemType == HTML_COMMENT || itemType == SUBMIT_BUTTON || itemType == AUTO_SUBMIT_BUTTON || itemType == PASSWORD || itemType == HEADING) continue;\n-\n-\t\t\t\t// Check if mails needs to be validated\n-\t\t\t\tif (itemType == VALIDATED_EMAIL) {\n-\t\t\t\t\thandleLoaForValidatedMail(session, itemData);\n-\t\t\t\t}\n-\n-\t\t\t\ttry {\n-\t\t\t\t\titemData.setId(Utils.getNewId(jdbc, \"APPLICATION_DATA_ID_SEQ\"));\n-\t\t\t\t\tjdbc.update(\"insert into application_data(id,app_id,item_id,shortname,value,assurance_level) values (?,?,?,?,?,?)\",\n-\t\t\t\t\t\t\titemData.getId(), appId, itemData.getFormItem().getId(), itemData\n-\t\t\t\t\t\t\t\t\t.getFormItem().getShortname(), itemData.getValue(), ((StringUtils.isBlank(itemData\n-\t\t\t\t\t\t\t\t\t.getAssuranceLevel())) ? null : itemData.getAssuranceLevel()));\n-\t\t\t\t} catch (Exception ex) {\n-\t\t\t\t\t// log and store exception so vo manager could see error in notification.\n-\t\t\t\t\tlog.error(\"[REGISTRAR] Storing form item {} caused exception {}\", itemData, ex);\n-\t\t\t\t\texceptions.add(ex);\n-\t\t\t\t}\n-\n-\t\t\t}\n-\n-\t\t\t// 3) process all logins and passwords\n-\n-\t\t\t// create list of logins and passwords to process\n-\t\t\tList<ApplicationFormItemData> logins = new ArrayList<>();\n-\t\t\tfor (ApplicationFormItemData itemData : data) {\n-\n-\t\t\t\tType itemType = itemData.getFormItem().getType();\n-\t\t\t\tif (itemType == USERNAME || itemType == PASSWORD) {\n-\t\t\t\t\t// skip logins with empty/null value\n-\t\t\t\t\tif (itemData.getValue() == null || itemData.getValue().isEmpty() || itemData.getValue().equals(\"null\")) continue;\n-\t\t\t\t\t// skip unchanged pre-filled logins, since they must have been handled last time\n-\t\t\t\t\tif (itemType == USERNAME && Objects.equals(itemData.getValue(), itemData.getPrefilledValue())) continue;\n-\t\t\t\t\tlogins.add(itemData);\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tfor (ApplicationFormItemData loginItem : logins) {\n-\t\t\t\tif (loginItem.getFormItem().getType() == USERNAME) {\n-\t\t\t\t\t// values to store\n-\t\t\t\t\tString login = loginItem.getValue();\n-\t\t\t\t\tString pass; // filled later\n-\t\t\t\t\t// Get login namespace\n-\t\t\t\t\tString dstAttr = loginItem.getFormItem().getPerunDestinationAttribute();\n-\t\t\t\t\tAttributeDefinition loginAttribute = attrManager.getAttributeDefinition(session, dstAttr);\n-\t\t\t\t\tString loginNamespace = loginAttribute.getFriendlyNameParameter();\n-\n-\t\t\t\t\tboolean loginAvailable = false;\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\tloginAvailable = usersManager.isLoginAvailable(session, loginNamespace, login);\n-\t\t\t\t\t} catch (InvalidLoginException ex) {\n-\t\t\t\t\t\tlog.error(\"[REGISTRAR] Unable to store login: {} in namespace: {} due to {}\", login, loginNamespace, ex);\n-\t\t\t\t\t\tthrow new ApplicationNotCreatedException(\"Application was not created. Reason: Login: \"+login+\" in namespace: \"+loginNamespace+\" is not allowed. Please choose different login.\", login, loginNamespace);\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t// try to book new login in namespace if the application hasn't been approved yet\n-\t\t\t\t\tif (loginAvailable) {\n-\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\t// Reserve login\n-\t\t\t\t\t\t\tjdbc.update(\"insert into application_reserved_logins(login,namespace,app_id,created_by,created_at) values(?,?,?,?,?)\",\n-\t\t\t\t\t\t\t\t\tlogin, loginNamespace, appId, application.getCreatedBy(), new Date());\n-\t\t\t\t\t\t\tlog.debug(\"[REGISTRAR] Added login reservation for login: {} in namespace: {}.\", login, loginNamespace);\n-\n-\t\t\t\t\t\t\t// process password for this login\n-\t\t\t\t\t\t\tfor (ApplicationFormItemData passItem : logins) {\n-\t\t\t\t\t\t\t\tApplicationFormItem item = passItem.getFormItem();\n-\t\t\t\t\t\t\t\tif (item.getType() == PASSWORD && item.getPerunDestinationAttribute() != null) {\n-\t\t\t\t\t\t\t\t\tif (item.getPerunDestinationAttribute().equals(dstAttr)) {\n-\t\t\t\t\t\t\t\t\t\tpass = passItem.getValue();\n-\t\t\t\t\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\t\t\t\t\t// reserve password\n-\t\t\t\t\t\t\t\t\t\t\tusersManager.reservePassword(registrarSession, login, loginNamespace, pass);\n-\t\t\t\t\t\t\t\t\t\t\tlog.debug(\"[REGISTRAR] Password for login: {} in namespace: {} successfully reserved in external system.\", login, loginNamespace);\n-\t\t\t\t\t\t\t\t\t\t} catch (Exception ex) {\n-\t\t\t\t\t\t\t\t\t\t\t// login reservation fail must cause rollback !!\n-\t\t\t\t\t\t\t\t\t\t\tlog.error(\"[REGISTRAR] Unable to reserve password for login: {} in namespace: {} in external system. Exception: {}\", login, loginNamespace, ex);\n-\t\t\t\t\t\t\t\t\t\t\tthrow new ApplicationNotCreatedException(\"Application was not created. Reason: Unable to reserve password for login: \"+login+\" in namespace: \"+loginNamespace+\" in external system. Please contact support to fix this issue before new application submission.\", login, loginNamespace);\n-\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t\tbreak; // use first pass with correct namespace\n-\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t} catch (ApplicationNotCreatedException ex) {\n-\t\t\t\t\t\t\tthrow ex; // re-throw\n-\t\t\t\t\t\t} catch (Exception ex) {\n-\t\t\t\t\t\t\t// unable to book login\n-\t\t\t\t\t\t\tlog.error(\"[REGISTRAR] Unable to reserve login: {} in namespace: {}. Exception: \", login, loginNamespace, ex);\n-\t\t\t\t\t\t\texceptions.add(ex);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\t// login is not available\n-\t\t\t\t\t\tlog.error(\"[REGISTRAR] Login: {} in namespace: {} is already occupied but it shouldn't (race condition).\", login, loginNamespace);\n-\t\t\t\t\t\texceptions.add(new InternalErrorException(\"Login: \" + login  + \" in namespace: \" + loginNamespace + \" is already occupied but it shouldn't.\"));\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t// call registrar module before auto validation so createAction is trigerred first\n-\t\t\tRegistrarModule module;\n-\t\t\tif (application.getGroup() != null) {\n-\t\t\t\tmodule = getRegistrarModule(getFormForGroup(application.getGroup()));\n-\t\t\t} else {\n-\t\t\t\tmodule = getRegistrarModule(getFormForVo(application.getVo()));\n-\t\t\t}\n-\t\t\tif (module != null) {\n-\t\t\t\tmodule.createApplication(session, application, data);\n-\t\t\t}\n-\n-\t\t} catch (ApplicationNotCreatedException ex) {\n-\t\t\tapplicationNotCreated = true; // prevent action in finally block\n-\t\t\tthrow ex; // re-throw\n-\t\t} catch (Exception ex) {\n-\t\t\t// any exception during app creation process => add it to list\n-\t\t\t// exceptions when handling logins are catched before\n-\t\t\tlog.error(\"Unexpected exception when creating application.\", ex);\n-\t\t\texceptions.add(ex);\n-\t\t} finally {\n-\n-\t\t\t// process rest only if it was not exception related to PASSWORDS creation\n-\t\t\tif (!applicationNotCreated) {\n-\n-\t\t\t\tgetMailManager().sendMessage(application, MailType.APP_CREATED_USER, null, null);\n-\t\t\t\tgetMailManager().sendMessage(application, MailType.APP_CREATED_VO_ADMIN, null, exceptions);\n-\t\t\t\t// if there were exceptions, throw some to let know GUI about it\n-\t\t\t\tif (!exceptions.isEmpty()) {\n-\t\t\t\t\tRegistrarException ex = new RegistrarException(\"Your application (ID=\"+ application.getId()+\n-\t\t\t\t\t\t\t\") has been created with errors. Administrator of \" + application.getVo().getName() + \" has been notified. If you want, you can use \\\"Send report to RT\\\" button to send this information to administrators directly.\");\n-\t\t\t\t\tlog.error(\"[REGISTRAR] New application {} created with errors {}. This is case of PerunException {}\",application, exceptions, ex.getErrorId());\n-\t\t\t\t\tthrow ex;\n-\t\t\t\t}\n-\t\t\t\tlog.info(\"New application {} created.\", application);\n-\t\t\t\tperun.getAuditer().log(session, new ApplicationCreated(application));\n-\n-\t\t\t}\n-\t\t}\n-\n-\t\t// return stored data\n-\t\treturn application;\n-\n-\t}\n-\n-\t@Override\n-\tpublic void deleteApplication(PerunSession sess, Application app) throws PerunException {\n-\n-\t\t//Authorization\n-\t\tif (app.getGroup() == null) {\n-\t\t\tif (!AuthzResolver.authorizedInternal(sess, \"vo-deleteApplication_Application_policy\", Collections.singletonList(app.getVo()))) {\n-\t\t\t\tthrow new PrivilegeException(sess, \"deleteApplication\");\n-\t\t\t}\n-\t\t} else {\n-\t\t\tif (!AuthzResolver.authorizedInternal(sess, \"group-deleteApplication_Application_policy\", Arrays.asList(app.getVo(), app.getGroup()))) {\n-\t\t\t\tthrow new PrivilegeException(sess, \"deleteApplication\");\n-\t\t\t}\n-\t\t}\n-\n-\t\t// lock to prevent concurrent runs\n-\t\tsynchronized(runningDeleteApplication) {\n-\t\t\tif (runningDeleteApplication.contains(app.getId())) {\n-\t\t\t\tthrow new AlreadyProcessingException(\"Application deletion is already processing.\");\n-\t\t\t} else {\n-\t\t\t\trunningDeleteApplication.add(app.getId());\n-\t\t\t}\n-\t\t}\n-\n-\t\ttry {\n-\n-\t\t\tif (AppState.NEW.equals(app.getState()) || AppState.REJECTED.equals(app.getState())) {\n-\n-\t\t\t\t// Try to get reservedLogin and reservedNamespace before deletion\n-\t\t\t\tList<Pair<String, String>> logins;\n-\t\t\t\ttry {\n-\t\t\t\t\tlogins = jdbc.query(\"select namespace,login from application_reserved_logins where app_id=?\", (resultSet, arg1) -> new Pair<>(resultSet.getString(\"namespace\"), resultSet.getString(\"login\")), app.getId());\n-\t\t\t\t} catch (EmptyResultDataAccessException e) {\n-\t\t\t\t\t// set empty logins\n-\t\t\t\t\tlogins = new ArrayList<>();\n-\t\t\t\t}\n-\t\t\t\t// delete passwords in KDC\n-\t\t\t\tfor (Pair<String, String> login : logins) {\n-\t\t\t\t\t// delete LOGIN in NAMESPACE\n-\t\t\t\t\tusersManager.deletePassword(sess, login.getRight(), login.getLeft());\n-\t\t\t\t}\n-\n-\t\t\t\t// free any login from reservation when application is rejected\n-\t\t\t\tjdbc.update(\"delete from application_reserved_logins where app_id=?\", app.getId());\n-\n-\t\t\t\t// delete application and data on cascade\n-\t\t\t\tjdbc.update(\"delete from application where id=?\", app.getId());\n-\n-\t\t\t} else {\n-\t\t\t\tif (AppState.VERIFIED.equals(app.getState()))\n-\t\t\t\t\tthrow new RegistrarException(\"Submitted application can't be deleted. Please reject the application first.\");\n-\t\t\t\tif (AppState.APPROVED.equals(app.getState()))\n-\t\t\t\t\tthrow new RegistrarException(\"Approved application can't be deleted. Try to refresh the view to see changes.\");\n-\t\t\t}\n-\t\t\tperun.getAuditer().log(sess, new ApplicationDeleted(app));\n-\n-\t\t} finally {\n-\t\t\tsynchronized (runningDeleteApplication) {\n-\t\t\t\trunningDeleteApplication.remove(app.getId());\n-\t\t\t}\n-\t\t}\n-\n-\t}\n-\n-\t@Override\n-\tpublic Application verifyApplication(PerunSession sess, int appId) throws PerunException {\n-\n-\t\tApplication app = getApplicationById(appId);\n-\t\tif (app == null) throw new RegistrarException(\"Application with ID=\"+appId+\" doesn't exists.\");\n-\n-\t\t//Authorization\n-\t\tif (app.getGroup() == null) {\n-\t\t\tif (!AuthzResolver.authorizedInternal(sess, \"vo-verifyApplication_int_policy\", Collections.singletonList(app.getVo()))) {\n-\t\t\t\tthrow new PrivilegeException(sess, \"verifyApplication\");\n-\t\t\t}\n-\t\t} else {\n-\t\t\tif (!AuthzResolver.authorizedInternal(sess, \"group-verifyApplication_int_policy\", Arrays.asList(app.getVo(), app.getGroup()))) {\n-\t\t\t\tthrow new PrivilegeException(sess, \"verifyApplication\");\n-\t\t\t}\n-\t\t}\n-\n-\t\t// proceed\n-\t\tmarkApplicationVerified(sess, appId);\n-\t\tperun.getAuditer().log(sess, new ApplicationVerified(app));\n-\t\t// return updated application\n-\t\treturn getApplicationById(appId);\n-\n-\t}\n-\n-\t@Override\n-\t@Transactional(rollbackFor = Exception.class)\n-\tpublic Application rejectApplication(PerunSession sess, int appId, String reason) throws PerunException {\n-\n-\t\tApplication app = getApplicationById(appId);\n-\t\tif (app == null) throw new RegistrarException(\"Application with ID=\"+appId+\" doesn't exists.\");\n-\n-\t\t//Authorization\n-\t\tif (app.getGroup() == null) {\n-\t\t\tif (!AuthzResolver.authorizedInternal(sess, \"vo-rejectApplication_int_String_policy\", Collections.singletonList(app.getVo()))) {\n-\t\t\t\tthrow new PrivilegeException(sess, \"rejectApplication\");\n-\t\t\t}\n-\t\t} else {\n-\t\t\tif (!AuthzResolver.authorizedInternal(sess, \"group-rejectApplication_int_String_policy\", Arrays.asList(app.getVo(), app.getGroup()))) {\n-\t\t\t\tthrow new PrivilegeException(sess, \"rejectApplication\");\n-\t\t\t}\n-\t\t}\n-\n-\t\t// only VERIFIED applications can be rejected\n-\t\tif (AppState.APPROVED.equals(app.getState())) {\n-\t\t\tthrow new RegistrarException(\"Approved application can't be rejected ! Try to refresh the view to see changes.\");\n-\t\t} else if (AppState.REJECTED.equals(app.getState())) {\n-\t\t\tthrow new RegistrarException(\"Application is already rejected. Try to refresh the view to see changes.\");\n-\t\t}\n-\n-\t\t// lock to prevent concurrent runs\n-\t\tsynchronized(runningRejectApplication) {\n-\t\t\tif (runningRejectApplication.contains(appId)) {\n-\t\t\t\tthrow new AlreadyProcessingException(\"Application rejection is already processing.\");\n-\t\t\t} else {\n-\t\t\t\trunningRejectApplication.add(appId);\n-\t\t\t}\n-\t\t}\n-\n-\t\ttry {\n-\n-\t\t\t// mark as rejected\n-\t\t\tint result = jdbc.update(\"update application set state=?, modified_by=?, modified_at=? where id=?\", AppState.REJECTED.toString(), sess.getPerunPrincipal().getActor(), new Date(), appId);\n-\t\t\tif (result == 0) {\n-\t\t\t\tthrow new RegistrarException(\"Application with ID=\" + appId + \" not found.\");\n-\t\t\t} else if (result > 1) {\n-\t\t\t\tthrow new ConsistencyErrorException(\"More than one application is stored under ID=\" + appId + \".\");\n-\t\t\t}\n-\t\t\t// set back as rejected\n-\t\t\tapp.setState(AppState.REJECTED);\n-\t\t\tlog.info(\"Application {} marked as REJECTED.\", appId);\n-\n-\t\t\t// get all reserved logins\n-\t\t\tList<Pair<String, String>> logins = jdbc.query(\"select namespace,login from application_reserved_logins where app_id=?\",\n-\t\t\t\t\t(resultSet, arg1) -> new Pair<>(resultSet.getString(\"namespace\"), resultSet.getString(\"login\")), appId);\n-\n-\t\t\t// delete passwords for reserved logins\n-\t\t\tfor (Pair<String, String> login : logins) {\n-\t\t\t\ttry {\n-\t\t\t\t\t// left = namespace / right = login\n-\t\t\t\t\tusersManager.deletePassword(registrarSession, login.getRight(), login.getLeft());\n-\t\t\t\t} catch (LoginNotExistsException ex) {\n-\t\t\t\t\tlog.error(\"[REGISTRAR] Login: {} not exists while deleting passwords in rejected application: {}\", login.getLeft(), appId);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\t// free any login from reservation when application is rejected\n-\t\t\tjdbc.update(\"delete from application_reserved_logins where app_id=?\", appId);\n-\n-\t\t\t// log\n-\t\t\tperun.getAuditer().log(sess, new ApplicationRejected(app));\n-\n-\t\t\t// call registrar module\n-\t\t\tRegistrarModule module;\n-\t\t\tif (app.getGroup() != null) {\n-\t\t\t\tmodule = getRegistrarModule(getFormForGroup(app.getGroup()));\n-\t\t\t} else {\n-\t\t\t\tmodule = getRegistrarModule(getFormForVo(app.getVo()));\n-\t\t\t}\n-\t\t\tif (module != null) {\n-\t\t\t\tmodule.rejectApplication(sess, app, reason);\n-\t\t\t}\n-\n-\t\t\t// send mail\n-\t\t\tgetMailManager().sendMessage(app, MailType.APP_REJECTED_USER, reason, null);\n-\n-\t\t\tperun.getAuditer().log(sess, new ApplicationRejected(app));\n-\n-\t\t\t// return updated application\n-\t\t\treturn app;\n-\n-\t\t} finally {\n-\n-\t\t\t// always release lock\n-\t\t\tsynchronized (runningRejectApplication) {\n-\t\t\t\trunningRejectApplication.remove(appId);\n-\t\t\t}\n-\n-\t\t}\n-\n-\t}\n-\n-\t@Override\n-\tpublic Application approveApplication(PerunSession sess, int appId) throws PerunException {\n-\n-\t\tsynchronized(runningApproveApplication) {\n-\t\t\tif (runningApproveApplication.contains(appId)) {\n-\t\t\t\tthrow new AlreadyProcessingException(\"Application approval is already processing.\");\n-\t\t\t} else {\n-\t\t\t\trunningApproveApplication.add(appId);\n-\t\t\t}\n-\t\t}\n-\n-\t\tApplication app;\n-\t\ttry {\n-\t\t\tapp = registrarManager.approveApplicationInternal(sess, appId);\n-\t\t} catch (AlreadyMemberException ex) {\n-\t\t\t// case when user joined identity after sending initial application and former user was already member of VO\n-\t\t\tthrow new RegistrarException(\"User is already member (with ID: \"+ex.getMember().getId()+\") of your VO/group. (user joined his identities after sending new application). You can reject this application and re-validate old member to keep old data (e.g. login,email).\", ex);\n-\t\t} catch (MemberNotExistsException ex) {\n-\t\t\tthrow new RegistrarException(\"To approve application user must already be member of VO.\", ex);\n-\t\t} catch (NotGroupMemberException ex) {\n-\t\t\tthrow new RegistrarException(\"To approve application user must already be member of Group.\", ex);\n-\t\t} catch (UserNotExistsException | UserExtSourceNotExistsException | ExtSourceNotExistsException ex) {\n-\t\t\tthrow new RegistrarException(\"User specified by the data in application was not found. If you tried to approve application for the Group, try to check, if user already has approved application in the VO. Application to the VO must be approved first.\", ex);\n-\t\t} finally {\n-\t\t\tsynchronized (runningApproveApplication) {\n-\t\t\t\trunningApproveApplication.remove(appId);\n-\t\t\t}\n-\t\t}\n-\n-\t\tMember member = membersManager.getMemberByUser(sess, app.getVo(), app.getUser());\n-\n-\t\ttry {\n-\n-\t\t\t// validate member async when all changes are committed\n-\t\t\t// we can't use existing core method, since we want to approve auto-approval waiting group applications\n-\t\t\t// once member is validated\n-\t\t\tnew Thread(() -> {\n-\n-\t\t\t\ttry {\n-\t\t\t\t\tThread.sleep(5000);\n-\t\t\t\t} catch (InterruptedException e) {\n-\t\t\t\t\t// TODO Auto-generated catch block\n-\t\t\t\t\te.printStackTrace();\n-\t\t\t\t}\n-\n-\t\t\t\ttry {\n-\t\t\t\t\tmembersManager.validateMember(registrarSession, member);\n-\t\t\t\t} catch (InternalErrorException | WrongAttributeValueException | WrongReferenceAttributeValueException e) {\n-\t\t\t\t\tlog.error(\"[REGISTRAR] Exception when validating {} after approving application {}.\", member, app);\n-\t\t\t\t}\n-\n-\t\t\t\ttry {\n-\t\t\t\t\t// get user's group apps with auto-approve and approve them\n-\t\t\t\t\tautoApproveUsersGroupApplications(sess, app.getVo(), app.getUser());\n-\t\t\t\t} catch (PerunException ex) {\n-\t\t\t\t\tlog.error(\"[REGISTRAR] Exception when auto-approving waiting group applications for {} after approving application {}.\", member, app);\n-\t\t\t\t}\n-\n-\t\t\t}).start();\n-\n-\t\t} catch (Exception ex) {\n-\t\t\t// we skip any exception thrown from here\n-\t\t\tlog.error(\"[REGISTRAR] Exception when validating {} after approving application {}.\", member, app);\n-\t\t}\n-\t\tperun.getAuditer().log(sess, new ApplicationApproved(app));\n-\n-\t\tsynchronized (runningApproveApplication) {\n-\t\t\trunningApproveApplication.remove(appId);\n-\t\t}\n-\n-\t\treturn app;\n-\t}\n-\n-\t/**\n-\t * Process application approval in 1 transaction\n-\t * !! WITHOUT members validation !!\n-\t *\n-\t * @param sess session for authz\n-\t * @param appId application ID to approve\n-\t * @return updated application\n-\t * @throws PerunException\n-\t */\n-\t@Transactional(rollbackFor = Exception.class)\n-\tpublic Application approveApplicationInternal(PerunSession sess, int appId) throws PrivilegeException, RegistrarException, FormNotExistsException, UserNotExistsException, ExtSourceNotExistsException, UserExtSourceNotExistsException, LoginNotExistsException, PasswordCreationFailedException, WrongReferenceAttributeValueException, WrongAttributeValueException, MemberNotExistsException, VoNotExistsException, CantBeApprovedException, GroupNotExistsException, NotGroupMemberException, ExternallyManagedException, WrongAttributeAssignmentException, AttributeNotExistsException, AlreadyMemberException, ExtendMembershipException, PasswordDeletionFailedException, PasswordOperationTimeoutException, AlreadyAdminException, InvalidLoginException {\n-\n-\t\tApplication app = getApplicationById(appId);\n-\t\tif (app == null) throw new RegistrarException(\"Application with ID \"+appId+\" doesn't exists.\");\n-\t\tMember member;\n-\n-\t\t//Authorization\n-\t\tif (app.getGroup() == null) {\n-\t\t\tif (!AuthzResolver.authorizedInternal(sess, \"vo-approveApplicationInternal_int_policy\", Collections.singletonList(app.getVo()))) {\n-\t\t\t\tthrow new PrivilegeException(sess, \"approveApplicationInternal\");\n-\t\t\t}\n-\t\t} else {\n-\t\t\tif (!AuthzResolver.authorizedInternal(sess, \"group-approveApplicationInternal_int_policy\", Arrays.asList(app.getVo(), app.getGroup()))) {\n-\t\t\t\tthrow new PrivilegeException(sess, \"approveApplicationInternal\");\n-\t\t\t}\n-\t\t}\n-\n-\t\t// only VERIFIED applications can be approved\n-\t\tif (!AppState.VERIFIED.equals(app.getState())) {\n-\t\t\tif (AppState.APPROVED.equals(app.getState())) throw new RegistrarException(\"Application is already approved. Try to refresh the view to see changes.\");\n-\t\t\tif (AppState.REJECTED.equals(app.getState())) throw new RegistrarException(\"Rejected application cant' be approved. Try to refresh the view to see changes.\");\n-\t\t\tthrow new RegistrarException(\"User didn't verify his email address yet. Please wait until application will be in a 'Submitted' state. You can send mail verification notification to user again if you wish.\");\n-\t\t}\n-\n-\t\tLinkedHashMap<String, String> additionalAttributes = BeansUtils.stringToMapOfAttributes(app.getFedInfo());\n-\t\tPerunPrincipal applicationPrincipal = new PerunPrincipal(app.getCreatedBy(), app.getExtSourceName(), app.getExtSourceType(), app.getExtSourceLoa(), additionalAttributes);\n-\n-\t\t// get registrar module\n-\t\tRegistrarModule module;\n-\t\tif (app.getGroup() != null) {\n-\t\t\tmodule = getRegistrarModule(getFormForGroup(app.getGroup()));\n-\t\t} else {\n-\t\t\tmodule = getRegistrarModule(getFormForVo(app.getVo()));\n-\t\t}\n-\n-\t\tif (module != null) {\n-\t\t\t// call custom logic before approving\n-\t\t\tmodule.beforeApprove(sess, app);\n-\t\t}\n-\n-\t\t// mark as APPROVED\n-\t\tint result = jdbc.update(\"update application set state=?, modified_by=?, modified_at=? where id=?\", AppState.APPROVED.toString(), sess.getPerunPrincipal().getActor(), new Date(), appId);\n-\t\tif (result == 0) {\n-\t\t\tthrow new RegistrarException(\"Application with ID=\"+appId+\" not found.\");\n-\t\t} else if (result > 1) {\n-\t\t\tthrow new ConsistencyErrorException(\"More than one application is stored under ID=\"+appId+\".\");\n-\t\t}\n-\t\t// set back as approved\n-\t\tapp.setState(AppState.APPROVED);\n-\t\tlog.info(\"Application {} marked as APPROVED\", appId);\n-\n-\t\t// Try to get reservedLogin and reservedNamespace before deletion, it will be used for creating userExtSources\n-\t\tList<Pair<String, String>> logins;\n-\t\ttry {\n-\t\t\tlogins = jdbc.query(\"select namespace,login from application_reserved_logins where app_id=?\", (resultSet, arg1) -> new Pair<>(resultSet.getString(\"namespace\"), resultSet.getString(\"login\")), appId);\n-\t\t} catch (EmptyResultDataAccessException e) {\n-\t\t\t// set empty logins\n-\t\t\tlogins = new ArrayList<>();\n-\t\t}\n-\n-\t\t// FOR INITIAL APPLICATION\n-\t\tif (AppType.INITIAL.equals(app.getType())) {\n-\n-\t\t\tif (app.getGroup() != null) {\n-\n-\t\t\t\t// free reserved logins so they can be set as attributes\n-\t\t\t\tjdbc.update(\"delete from application_reserved_logins where app_id=?\", appId);\n-\n-\t\t\t\tif (app.getUser() == null) {\n-\n-\t\t\t\t\t// application for group doesn't have user set, but it can exists in perun (joined identities after submission)\n-\t\t\t\t\tUser u = perun.getUsersManagerBl().getUserByExtSourceInformation(registrarSession, applicationPrincipal);\n-\n-\t\t\t\t\t// put user back to application\n-\t\t\t\t\tapp.setUser(u);\n-\t\t\t\t\t// store user_id in DB\n-\t\t\t\t\tint result2 = jdbc.update(\"update application set user_id=? where id=?\", u.getId(), appId);\n-\t\t\t\t\tif (result2 == 0) {\n-\t\t\t\t\t\tthrow new RegistrarException(\"Application with ID=\"+appId+\" not found.\");\n-\t\t\t\t\t} else if (result2 > 1) {\n-\t\t\t\t\t\tthrow new ConsistencyErrorException(\"More than one application is stored under ID=\"+appId+\".\");\n-\t\t\t\t\t}\n-\n-\t\t\t\t}\n-\n-\t\t\t\t// add new member of VO as member of group (for group applications)\n-\t\t\t\t// !! MUST BE MEMBER OF VO !!\n-\t\t\t\tmember = membersManager.getMemberByUser(registrarSession, app.getVo(), app.getUser());\n-\n-\t\t\t\t// MEMBER must be in a VALID or INVALID state since approval starts validation !!\n-\t\t\t\t// and we don't want to validate expired, suspended or disabled users without VO admin owns action !!\n-\t\t\t\t// meaning, user should submit membership extension application first !!\n-\t\t\t\tif (!Arrays.asList(Status.VALID, Status.INVALID).contains(member.getStatus())) {\n-\t\t\t\t\tthrow new CantBeApprovedException(\"Application of member with membership status: \"+member.getStatus()+\" can't be approved. Please wait until member extends/re-validate own membership in a VO.\");\n-\t\t\t\t}\n-\n-\t\t\t\t// store all attributes (but not logins)\n-\t\t\t\tstoreApplicationAttributes(app);\n-\n-\t\t\t\t// cancel reservation of new duplicate logins and get purely new logins back\n-\t\t\t\tlogins = unreserveNewLoginsFromSameNamespace(logins, app.getUser());\n-\n-\t\t\t\t// store purely new logins to user\n-\t\t\t\tstoreApplicationLoginAttributes(app);\n-\n-\t\t\t\tfor (Pair<String, String> pair : logins) {\n-\t\t\t\t\t// LOGIN IN NAMESPACE IS PURELY NEW => VALIDATE ENTRY IN KDC\n-\t\t\t\t\t// left = namespace, right = login\n-\t\t\t\t\tusersManager.validatePassword(registrarSession, app.getUser(), pair.getLeft());\n-\t\t\t\t}\n-\n-\t\t\t\t// update titles before/after users name if part of application !! USER MUST EXISTS !!\n-\t\t\t\tupdateUserNameTitles(app);\n-\n-\t\t\t\t// Perform checks since we moved from entry to BL\n-\t\t\t\t// Check if the group is externally synchronized\n-\t\t\t\tAttribute attrSynchronizeEnabled = attrManager.getAttribute(sess, app.getGroup(), GROUPSYNCHROENABLED_ATTRNAME);\n-\t\t\t\tif (\"true\".equals(attrSynchronizeEnabled.getValue()) || groupsManager.isGroupInStructureSynchronizationTree(sess, app.getGroup())) {\n-\t\t\t\t\tthrow new ExternallyManagedException(\"Adding of member is not allowed. Group is externally managed.\");\n-\t\t\t\t}\n-\n-\t\t\t\tgroupsManager.addMember(registrarSession, app.getGroup(), member);\n-\n-\t\t\t\tlog.debug(\"[REGISTRAR] Member {} added to Group {}.\",member, app.getGroup());\n-\n-\t\t\t} else {\n-\n-\t\t\t\t// free reserved logins so they can be set as attributes\n-\t\t\t\tjdbc.update(\"delete from application_reserved_logins where app_id=?\", appId);\n-\n-\t\t\t\tUser u;\n-\t\t\t\tif (app.getUser() != null) {\n-\t\t\t\t\tu = app.getUser();\n-\t\t\t\t\tlog.debug(\"[REGISTRAR] Trying to make member from user {}\", u);\n-\t\t\t\t\tmember = membersManager.createMember(sess, app.getVo(), u);\n-\t\t\t\t\t// store all attributes (but not logins)\n-\t\t\t\t\tstoreApplicationAttributes(app);\n-\t\t\t\t\t// if user was already known to perun, createMember() will set attributes\n-\t\t\t\t\t// via setAttributes() method so core attributes are skipped\n-\t\t\t\t\t// ==> updateNameTitles() in case of change in appForm.\n-\t\t\t\t\tupdateUserNameTitles(app);\n-\t\t\t\t} else {\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\tu = perun.getUsersManagerBl().getUserByExtSourceInformation(registrarSession, applicationPrincipal);\n-\t\t\t\t\t\tlog.debug(\"[REGISTRAR] Trying to make member from user {}\", u);\n-\t\t\t\t\t\tmember = membersManager.createMember(sess, app.getVo(), u);\n-\t\t\t\t\t\t// set NEW user id back to application\n-\t\t\t\t\t\tapp.setUser(u);\n-\t\t\t\t\t\t// store all attributes (but not logins)\n-\t\t\t\t\t\tstoreApplicationAttributes(app);\n-\t\t\t\t\t\t// if user was already known to perun, createMember() will set attributes\n-\t\t\t\t\t\t// via setAttributes() method so core attributes are skipped\n-\t\t\t\t\t\t// ==> updateNameTitles() in case of change in appForm.\n-\t\t\t\t\t\tupdateUserNameTitles(app);\n-\t\t\t\t\t} catch (UserExtSourceNotExistsException | UserNotExistsException | ExtSourceNotExistsException  ex) {\n-\t\t\t\t\t\tCandidate candidate = createCandidateFromApplicationData(app);\n-\t\t\t\t\t\t// create member and user\n-\t\t\t\t\t\tlog.debug(\"[REGISTRAR] Trying to make member from candidate {}\", candidate);\n-\n-\t\t\t\t\t\t// added duplicit check, since we switched from entry to bl call of createMember()\n-\t\t\t\t\t\tUtils.checkMaxLength(\"TitleBefore\", candidate.getTitleBefore(), 40);\n-\t\t\t\t\t\tUtils.checkMaxLength(\"TitleAfter\", candidate.getTitleAfter(), 40);\n-\n-\t\t\t\t\t\tmember = membersManager.createMember(sess, app.getVo(), app.getExtSourceName(), app.getExtSourceType(), app.getExtSourceLoa(), app.getCreatedBy(), candidate);\n-\t\t\t\t\t\tu = usersManager.getUserById(registrarSession, member.getUserId());\n-\t\t\t\t\t\t// set NEW user id back to application\n-\t\t\t\t\t\tapp.setUser(u);\n-\t\t\t\t\t}\n-\t\t\t\t\t// user originally not known -> set UserExtSource attributes from source identity for new User and UES\n-\t\t\t\t\tExtSource es = perun.getExtSourcesManagerBl().getExtSourceByName(sess, app.getExtSourceName());\n-\t\t\t\t\tUserExtSource ues = usersManager.getUserExtSourceByExtLogin(sess, es, app.getCreatedBy());\n-\t\t\t\t\t// we have historical data in \"fedInfo\" item, hence we must safely ignore any parsing errors.\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\t((PerunBlImpl)perun).setUserExtSourceAttributes(sess, ues, additionalAttributes);\n-\t\t\t\t\t} catch (Exception ex) {\n-\t\t\t\t\t\tlog.error(\"Unable to store UES attributes from application ID: {}, attributes: {}, with exception: {}\", appId, app.getFedInfo(), ex);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\tresult = jdbc.update(\"update application set user_id=? where id=?\", member.getUserId(), appId);\n-\t\t\t\tif (result == 0) {\n-\t\t\t\t\tthrow new RegistrarException(\"User ID hasn't been associated with the application \" + appId + \", because the application was not found!\");\n-\t\t\t\t} else if (result > 1) {\n-\t\t\t\t\tthrow new ConsistencyErrorException(\"User ID hasn't been associated with the application \" + appId + \", because more than one application exists under the same ID.\");\n-\t\t\t\t}\n-\t\t\t\tlog.info(\"Member {} created for: {} / {}\", member.getId(), app.getCreatedBy(), app.getExtSourceName());\n-\n-\t\t\t\t// unreserve new login if user already have login in same namespace\n-\t\t\t\t// also get back purely new logins\n-\t\t\t\tlogins = unreserveNewLoginsFromSameNamespace(logins, u);\n-\n-\t\t\t\t// store purely new logins to user\n-\t\t\t\tstoreApplicationLoginAttributes(app);\n-\n-\t\t\t\tfor (Pair<String, String> pair : logins) {\n-\t\t\t\t\t// LOGIN IN NAMESPACE IS PURELY NEW => VALIDATE ENTRY IN KDC\n-\t\t\t\t\t// left = namespace, right = login\n-\t\t\t\t\tusersManager.validatePassword(registrarSession, u, pair.getLeft());\n-\t\t\t\t}\n-\n-\t\t\t\t// log\n-\t\t\t\tperun.getAuditer().log(sess, new MemberCreatedForApprovedApp(member,app));\n-\n-\t\t\t}\n-\n-\t\t\t// FOR EXTENSION APPLICATION\n-\t\t} else if (AppType.EXTENSION.equals(app.getType())) {\n-\n-\t\t\t// free reserved logins so they can be set as attributes\n-\t\t\tjdbc.update(\"delete from application_reserved_logins where app_id=?\", app.getId());\n-\n-\t\t\tmember = membersManager.getMemberByUser(registrarSession, app.getVo(), app.getUser());\n-\n-\t\t\tif (app.getGroup() != null) {\n-\n-\t\t\t\t// MEMBER must be in a VALID or INVALID state since approval starts validation !!\n-\t\t\t\t// and we don't want to validate expired, suspended or disabled users without VO admin owns action !!\n-\t\t\t\t// meaning, user should submit membership extension application first !!\n-\t\t\t\tif (!Arrays.asList(Status.VALID, Status.INVALID).contains(member.getStatus())) {\n-\t\t\t\t\tthrow new CantBeApprovedException(\"Application of member with membership status: \"+member.getStatus()+\" can't be approved. Please wait until member extends/re-validate own membership in a VO.\");\n-\t\t\t\t}\n-\n-\t\t\t\t// overwrite member with group context\n-\t\t\t\tmember = groupsManager.getGroupMemberById(registrarSession, app.getGroup(), member.getId());\n-\n-\t\t\t}\n-\n-\t\t\tstoreApplicationAttributes(app);\n-\n-\t\t\tif (app.getGroup() != null) {\n-\t\t\t\t// extends users Group membership\n-\t\t\t\tgroupsManager.extendMembershipInGroup(sess, member, app.getGroup());\n-\t\t\t} else {\n-\t\t\t\t// extend users VO membership\n-\t\t\t\tmembersManager.extendMembership(registrarSession, member);\n-\t\t\t}\n-\n-\t\t\t// unreserve new logins, if user already have login in same namespace\n-\t\t\t// also get back logins, which are purely new\n-\t\t\tlogins = unreserveNewLoginsFromSameNamespace(logins, app.getUser());\n-\n-\t\t\t// store purely new logins from application\n-\t\t\tstoreApplicationLoginAttributes(app);\n-\n-\t\t\t// validate purely new logins in KDC\n-\t\t\tfor (Pair<String, String> pair : logins) {\n-\t\t\t\t// left = namespace, right = login\n-\t\t\t\tusersManager.validatePassword(registrarSession, app.getUser(), pair.getLeft());\n-\t\t\t}\n-\n-\t\t\t// update titles before/after users name if part of application !! USER MUST EXISTS !!\n-\t\t\tupdateUserNameTitles(app);\n-\n-\t\t\t// log\n-\t\t\tperun.getAuditer().log(sess, new MembershipExtendedForMemberInApprovedApp(member,app,app.getVo()));\n-\n-\t\t}\n-\n-\t\t// CONTINUE FOR BOTH APP TYPES\n-\n-\t\tif (module != null) {\n-\t\t\tmodule.approveApplication(sess, app);\n-\t\t}\n-\n-\t\tgetMailManager().sendMessage(app, MailType.APP_APPROVED_USER, null, null);\n-\n-\t\t// return updated application\n-\t\treturn app;\n-\n-\t}\n-\n-\t@Override\n-\tpublic void canBeApproved(PerunSession session, Application application) throws PerunException {\n-\n-\t\t//Authorization\n-\t\tif (application.getGroup() == null) {\n-\t\t\tif (!AuthzResolver.authorizedInternal(session, \"vo-canBeApproved_Application_policy\", Collections.singletonList(application.getVo()))) {\n-\t\t\t\tthrow new PrivilegeException(session, \"canBeApproved\");\n-\t\t\t}\n-\t\t} else {\n-\t\t\tif (!AuthzResolver.authorizedInternal(session, \"group-canBeApproved_Application_policy\", Arrays.asList(application.getVo(), application.getGroup()))) {\n-\t\t\t\tthrow new PrivilegeException(session, \"canBeApproved\");\n-\t\t\t}\n-\t\t}\n-\n-\t\t// get registrar module\n-\t\tRegistrarModule module;\n-\t\tif (application.getGroup() != null) {\n-\t\t\tmodule = getRegistrarModule(getFormForGroup(application.getGroup()));\n-\t\t} else {\n-\t\t\tmodule = getRegistrarModule(getFormForVo(application.getVo()));\n-\t\t}\n-\n-\t\tif (module != null) {\n-\t\t\t// call custom logic before approving\n-\t\t\tmodule.canBeApproved(session, application);\n-\t\t}\n-\n-\t\t// generally for Group applications:\n-\n-\t\t// submitter, must be MEMBER of VO and in VALID or INVALID state since approval starts validation !!\n-\t\t// and we don't want to validate expired, suspended or disabled users without VO admin owns action !!\n-\t\t// meaning, user should submit membership extension application first !!\n-\t\tif (application.getGroup() != null) {\n-\t\t\ttry {\n-\t\t\t\tUser u = application.getUser();\n-\t\t\t\tif (u == null) {\n-\t\t\t\t\tLinkedHashMap<String, String> additionalAttributes = BeansUtils.stringToMapOfAttributes(application.getFedInfo());\n-\t\t\t\t\tPerunPrincipal applicationPrincipal = new PerunPrincipal(application.getCreatedBy(), application.getExtSourceName(), application.getExtSourceType(), application.getExtSourceLoa(), additionalAttributes);\n-\t\t\t\t\tu = perun.getUsersManagerBl().getUserByExtSourceInformation(registrarSession, applicationPrincipal);\n-\t\t\t\t}\n-\t\t\t\tMember member = membersManager.getMemberByUser(registrarSession, application.getVo(), u);\n-\t\t\t\tif (!Arrays.asList(Status.VALID, Status.INVALID).contains(member.getStatus())) {\n-\t\t\t\t\tthrow new CantBeApprovedException(\"Application of member with membership status: \" + member.getStatus() + \" can't be approved. Please wait until member extends/re-validate own membership in a VO.\");\n-\t\t\t\t}\n-\t\t\t} catch (MemberNotExistsException | UserNotExistsException | ExtSourceNotExistsException | UserExtSourceNotExistsException ex) {\n-\t\t\t\tthrow new RegistrarException(\"To approve application user must be a member of VO.\", ex);\n-\t\t\t}\n-\n-\t\t}\n-\n-\t}\n-\n-\t@Override\n-\tpublic Application getApplicationById(PerunSession sess, int appId) throws RegistrarException, PrivilegeException {\n-\n-\t\t// get application\n-\t\tApplication app = getApplicationById(appId);\n-\t\tif (app == null) throw new RegistrarException(\"Application with ID=\"+appId+\" doesn't exists.\");\n-\n-\t\t//Authorization\n-\t\tif (app.getGroup() == null) {\n-\t\t\tif (!AuthzResolver.authorizedInternal(sess, \"vo-getApplicationById_int_policy\", Collections.singletonList(app.getVo()))\n-\t\t\t\t&& !AuthzResolver.selfAuthorizedForApplication(sess, app)) {\n-\t\t\t\tthrow new PrivilegeException(sess, \"getApplicationById\");\n-\t\t\t}\n-\t\t} else {\n-\t\t\tif (!AuthzResolver.authorizedInternal(sess, \"group-getApplicationById_int_policy\", Arrays.asList(app.getVo(), app.getGroup()))\n-\t\t\t\t&& !AuthzResolver.selfAuthorizedForApplication(sess, app)) {\n-\t\t\t\tthrow new PrivilegeException(sess, \"getApplicationById\");\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn app;\n-\n-\t}\n-\n-\t@Override\n-\tpublic List<Application> getApplicationsForVo(PerunSession userSession, Vo vo, List<String> state) throws PerunException {\n-\t\tvosManager.checkVoExists(userSession, vo);\n-\n-\t\t//Authorization\n-\t\tif (!AuthzResolver.authorizedInternal(userSession, \"getApplicationsForVo_Vo_List<String>_policy\", Collections.singletonList(vo))) {\n-\t\t\tthrow new PrivilegeException(userSession, \"getApplicationsForVo\");\n-\t\t}\n-\t\tif (state == null || state.isEmpty()) {\n-\t\t\t// list all\n-\t\t\ttry {\n-\t\t\t\treturn jdbc.query(APP_SELECT + \" where a.vo_id=? order by a.id desc\", APP_MAPPER, vo.getId());\n-\t\t\t} catch (EmptyResultDataAccessException ex) {\n-\t\t\t\treturn new ArrayList<>();\n-\t\t\t}\n-\t\t} else {\n-\t\t\t// filter by state\n-\t\t\ttry {\n-\t\t\t\tMapSqlParameterSource sqlParameterSource = new MapSqlParameterSource();\n-\t\t\t\tsqlParameterSource.addValue(\"voId\", vo.getId());\n-\t\t\t\tsqlParameterSource.addValue(\"states\", state);\n-\t\t\t\treturn namedJdbc.query(APP_SELECT + \" where a.vo_id=:voId and state in ( :states ) order by a.id desc\", sqlParameterSource, APP_MAPPER);\n-\t\t\t} catch (EmptyResultDataAccessException ex) {\n-\t\t\t\treturn new ArrayList<>();\n-\t\t\t}\n-\t\t}\n-\n-\t}\n-\n-\t@Override\n-\tpublic List<Application> getApplicationsForGroup(PerunSession userSession, Group group, List<String> state) throws PerunException {\n-\t\tgroupsManager.checkGroupExists(userSession, group);\n-\n-\t\t//Authorization\n-\t\tif (!AuthzResolver.authorizedInternal(userSession, \"getApplicationsForGroup_Vo_List<String>_policy\", Collections.singletonList(group))) {\n-\t\t\tthrow new PrivilegeException(userSession, \"getApplicationsForGroup\");\n-\t\t}\n-\t\tif (state == null || state.isEmpty()) {\n-\t\t\t// list all\n-\t\t\ttry {\n-\t\t\t\treturn jdbc.query(APP_SELECT + \" where a.group_id=? order by a.id desc\", APP_MAPPER, group.getId());\n-\t\t\t} catch (EmptyResultDataAccessException ex) {\n-\t\t\t\treturn new ArrayList<>();\n-\t\t\t}\n-\t\t} else {\n-\t\t\t// filter by state\n-\t\t\ttry {\n-\t\t\t\tMapSqlParameterSource sqlParameterSource = new MapSqlParameterSource();\n-\t\t\t\tsqlParameterSource.addValue(\"groupId\", group.getId());\n-\t\t\t\tsqlParameterSource.addValue(\"states\", state);\n-\t\t\t\treturn namedJdbc.query(APP_SELECT + \" where a.group_id=:groupId and state in ( :states ) order by a.id desc\", sqlParameterSource, APP_MAPPER);\n-\t\t\t} catch (EmptyResultDataAccessException ex) {\n-\t\t\t\treturn new ArrayList<>();\n-\t\t\t}\n-\t\t}\n-\n-\t}\n-\n-\t@Override\n-\tpublic List<Application> getApplicationsForUser(User user) {\n-\n-\t\ttry {\n-\t\t\t// sort by ID which respect latest applications\n-\t\t\treturn jdbc.query(APP_SELECT + \" where user_id=? order by a.id desc\", APP_MAPPER, user.getId());\n-\t\t} catch (EmptyResultDataAccessException ex) {\n-\t\t\treturn new ArrayList<>();\n-\t\t}\n-\n-\t}\n-\n-\t@Override\n-\tpublic List<Application> getApplicationsForUser(PerunSession sess) {\n-\n-\t\ttry {\n-\t\t\tList<Application> allApplications = jdbc.query(APP_SELECT + \" order by a.id desc\", APP_MAPPER);\n-\t\t\treturn filterPrincipalApplications(sess, allApplications);\n-\t\t} catch (EmptyResultDataAccessException ex) {\n-\t\t\treturn new ArrayList<>();\n-\t\t}\n-\n-\t}\n-\n-\t@Override\n-\tpublic List<Application> getApplicationsForMember(PerunSession sess, Group group, Member member) throws PerunException {\n-\t\tmembersManager.checkMemberExists(sess, member);\n-\n-\t\t//Authorization\n-\t\tif (group == null) {\n-\t\t\tif (!AuthzResolver.authorizedInternal(sess, \"vo-getApplicationsForMember_Group_Member_policy\", Collections.singletonList(member))) {\n-\t\t\t\tthrow new PrivilegeException(sess, \"getApplicationsForMember\");\n-\t\t\t}\n-\t\t} else {\n-\t\t\tif (!AuthzResolver.authorizedInternal(sess, \"group-getApplicationsForMember_Group_Member_policy\", Arrays.asList(member, group))) {\n-\t\t\t\tthrow new PrivilegeException(sess, \"getApplicationsForMember\");\n-\t\t\t}\n-\t\t}\n-\n-\t\ttry {\n-\t\t\tif (group == null) {\n-\t\t\t\treturn jdbc.query(APP_SELECT + \" where user_id=? and a.vo_id=? order by a.id desc\", APP_MAPPER, member.getUserId(), member.getVoId());\n-\t\t\t} else {\n-\t\t\t\treturn jdbc.query(APP_SELECT + \" where user_id=? and a.vo_id=? and a.group_id=? order by a.id desc\", APP_MAPPER, member.getUserId(), member.getVoId(), group.getId());\n-\t\t\t}\n-\t\t} catch (EmptyResultDataAccessException ex) {\n-\t\t\treturn new ArrayList<>();\n-\t\t}\n-\n-\t}\n-\n-\t@Override\n-\tpublic List<ApplicationFormItem> getFormItems(PerunSession sess, ApplicationForm form, AppType appType) throws PerunException {\n-\n-\t\t//Authorization\n-\t\tif (form.getGroup() == null) {\n-\t\t\tif (!AuthzResolver.authorizedInternal(sess, \"vo-getFormItems_ApplicationForm_AppType_policy\", Collections.singletonList(form.getVo()))) {\n-\t\t\t\tthrow new PrivilegeException(\"getFormItems\");\n-\t\t\t}\n-\t\t} else {\n-\t\t\tif (!AuthzResolver.authorizedInternal(sess, \"group-getFormItems_ApplicationForm_AppType_policy\", Arrays.asList(form.getVo(), form.getGroup()))) {\n-\t\t\t\tthrow new PrivilegeException(\"getFormItems\");\n-\t\t\t}\n-\t\t}\n-\n-\t\tList<ApplicationFormItem> items;\n-\t\tif (appType == null) {\n-\t\t\titems = jdbc.query(FORM_ITEM_SELECT+\" where form_id=? order by ordnum asc\", ITEM_MAPPER, form.getId());\n-\t\t} else {\n-\t\t\titems = jdbc.query(FORM_ITEM_SELECT+\" i,application_form_item_apptypes t where form_id=? and i.id=t.item_id and t.apptype=? order by ordnum asc\",\n-\t\t\t\t\tITEM_MAPPER, form.getId(), appType.toString());\n-\t\t}\n-\t\tfor (ApplicationFormItem item : items) {\n-\t\t\tList<ItemTexts> texts = jdbc.query(FORM_ITEM_TEXTS_SELECT + \" where item_id=?\", ITEM_TEXTS_MAPPER, item.getId());\n-\t\t\tfor (ItemTexts itemTexts : texts) {\n-\t\t\t\titem.getI18n().put(itemTexts.getLocale(), itemTexts);\n-\t\t\t}\n-\t\t\tList<AppType> appTypes = jdbc.query(APP_TYPE_SELECT+\" where item_id=?\", APP_TYPE_MAPPER, item.getId());\n-\t\t\titem.setApplicationTypes(appTypes);\n-\t\t}\n-\n-\t\treturn items;\n-\t}\n-\n-\t@Override\n-\tpublic ApplicationFormItem getFormItemById(PerunSession session, int id) throws PrivilegeException {\n-\n-\t\t// authz - can read form -> can get item\n-\t\ttry {\n-\t\t\tgetFormByItemId(session, id);\n-\t\t} catch (PrivilegeException ex) {\n-\t\t\tthrow new PrivilegeException(\"getFormItemById\");\n-\t\t} catch (PerunException ex) {\n-\t\t\t// shouldn't happen\n-\t\t}\n-\n-\t\treturn getFormItemById(id);\n-\n-\t}\n-\n-\t@Override\n-\tpublic ApplicationFormItem getFormItemById(int id) {\n-\n-\t\tApplicationFormItem item;\n-\t\titem = jdbc.queryForObject(FORM_ITEM_SELECT+\" where id=?\", ITEM_MAPPER, id);\n-\t\tif (item != null) {\n-\t\t\tList<ItemTexts> texts = jdbc.query(FORM_ITEM_TEXTS_SELECT+\" where item_id=?\", ITEM_TEXTS_MAPPER, item.getId());\n-\t\t\tfor (ItemTexts itemTexts : texts) {\n-\t\t\t\titem.getI18n().put(itemTexts.getLocale(), itemTexts);\n-\t\t\t}\n-\t\t\tList<AppType> appTypes = jdbc.query(APP_TYPE_SELECT+\" where item_id=?\", APP_TYPE_MAPPER, item.getId());\n-\t\t\titem.setApplicationTypes(appTypes);\n-\t\t}\n-\n-\t\treturn item;\n-\n-\t}\n-\n-\t@Override\n-\tpublic void updateFormItem(PerunSession sess, ApplicationFormItem item) throws PrivilegeException, FormNotExistsException {\n-\n-\t\tApplicationForm form;\n-\n-\t\t// check authz on form\n-\t\ttry {\n-\t\t\tform = getFormByItemId(sess, item.getId());\n-\t\t} catch (PrivilegeException ex) {\n-\t\t\tthrow new PrivilegeException(sess, \"updateFormItemById\");\n-\t\t}\n-\n-\t\t//Authorization\n-\t\tif (form.getGroup() == null) {\n-\t\t\tif (!AuthzResolver.authorizedInternal(sess, \"vo-updateFormItem_ApplicationFormItem_policy\", Collections.singletonList(form.getVo()))) {\n-\t\t\t\tthrow new PrivilegeException(sess, \"updateFormItemById\");\n-\t\t\t}\n-\t\t} else {\n-\t\t\tif (!AuthzResolver.authorizedInternal(sess, \"group-updateFormItem_ApplicationFormItem_policy\", Arrays.asList(form.getVo(), form.getGroup()))) {\n-\t\t\t\tthrow new PrivilegeException(sess, \"updateFormItemById\");\n-\t\t\t}\n-\t\t}\n-\n-\t\t// else update form item\n-\n-\t\tint result = jdbc.update(\"update application_form_items set ordnum=?,shortname=?,required=?,type=?,fed_attr=?,src_attr=?,dst_attr=?,regex=? where id=?\",\n-\t\t\t\titem.getOrdnum(), item.getShortname(), item.isRequired(),\n-\t\t\t\titem.getType().toString(), item.getFederationAttribute(),\n-\t\t\t\titem.getPerunSourceAttribute(), item.getPerunDestinationAttribute(),\n-\t\t\t\titem.getRegex(), item.getId());\n-\n-\t\t// update form item texts (easy way = delete and new insert)\n-\n-\t\t// delete\n-\t\tjdbc.update(\"delete from application_form_item_texts where item_id=?\", item.getId());\n-\t\t// insert new\n-\t\tfor (Locale locale : item.getI18n().keySet()) {\n-\t\t\tItemTexts itemTexts = item.getTexts(locale);\n-\t\t\tjdbc.update(\"insert into application_form_item_texts(item_id,locale,label,options,help,error_message) values (?,?,?,?,?,?)\",\n-\t\t\t\t\titem.getId(), locale.getLanguage(), itemTexts.getLabel(),\n-\t\t\t\t\titemTexts.getOptions(), itemTexts.getHelp(),\n-\t\t\t\t\titemTexts.getErrorMessage());\n-\t\t}\n-\n-\t\t// update form item app types (easy way = delete and new insert)\n-\n-\t\t// delete\n-\t\tjdbc.update(\"delete from application_form_item_apptypes where item_id=?\", item.getId());\n-\t\t// insert new\n-\t\tfor (AppType appType : item.getApplicationTypes()) {\n-\t\t\tjdbc.update(\"insert into application_form_item_apptypes (item_id,apptype) values (?,?)\",\n-\t\t\t\t\titem.getId(), appType.toString());\n-\t\t}\n-\n-\t\tperun.getAuditer().log(sess, new FormItemUpdated(form,item));\n-\n-\t}\n-\n-\t@Override\n-\tpublic List<ApplicationFormItemWithPrefilledValue> getFormItemsWithPrefilledValues(PerunSession sess, AppType appType, ApplicationForm form) throws PerunException {\n-\n-\t\tVo vo = form.getVo();\n-\t\tGroup group = form.getGroup();\n-\n-\t\t// refresh session (user) to get correct data\n-\t\tAuthzResolverBlImpl.refreshSession(sess);\n-\n-\t\t// get necessary params from session\n-\t\tUser user = sess.getPerunPrincipal().getUser();\n-\t\tString actor = sess.getPerunPrincipal().getActor();\n-\t\tString extSourceName = sess.getPerunPrincipal().getExtSourceName();\n-\t\tString extSourceType = sess.getPerunPrincipal().getExtSourceType();\n-\t\tint extSourceLoa = sess.getPerunPrincipal().getExtSourceLoa();\n-\t\tMap<String, String> federValues = sess.getPerunPrincipal().getAdditionalInformations();\n-\n-\t\tRegistrarModule module = getRegistrarModule(form);\n-\t\tif (module != null) module.canBeSubmitted(sess, appType, federValues);\n-\n-\t\t// throws exception if user couldn't submit application - no reason to get form\n-\t\tcheckDuplicateRegistrationAttempt(sess, appType, form);\n-\n-\t\t// PROCEED\n-\t\tMap<String, String> parsedName = extractNames(federValues);\n-\t\tList<ApplicationFormItem> formItems = getFormItems(registrarSession, form, appType);\n-\n-\t\tList<ApplicationFormItemWithPrefilledValue> itemsWithValues = new ArrayList<>();\n-\t\tfor (ApplicationFormItem item : formItems) {\n-\t\t\titemsWithValues.add(new ApplicationFormItemWithPrefilledValue(item, null));\n-\t\t}\n-\n-\t\t// get user and member attributes from DB for existing users\n-\t\tif (user != null) {\n-\n-\t\t\tMap<String, Attribute> map = new HashMap<>();\n-\n-\t\t\t// process user attributes\n-\t\t\tList<Attribute> userAttributes = attrManager.getAttributes(sess, user);\n-\t\t\tfor (Attribute att : userAttributes) {\n-\t\t\t\tmap.put(att.getName(), att);\n-\t\t\t}\n-\t\t\t// process member attributes\n-\t\t\ttry {\n-\t\t\t\tMember member = membersManager.getMemberByUser(sess, vo, user);\n-\t\t\t\tList<Attribute> memberAttributes = attrManager.getAttributes(sess, member);\n-\t\t\t\tfor (Attribute att : memberAttributes) {\n-\t\t\t\t\tmap.put(att.getName(), att);\n-\t\t\t\t}\n-\t\t\t} catch (MemberNotExistsException ex) {\n-\t\t\t\t// we don't care that user is not yet member\n-\t\t\t}\n-\n-\t\t\t// get also vo/group attributes for extended pre-fill !!\n-\t\t\tList<Attribute> voAttributes = attrManager.getAttributes(sess, vo);\n-\t\t\tfor (Attribute att : voAttributes) {\n-\t\t\t\tmap.put(att.getName(), att);\n-\t\t\t}\n-\t\t\tif (group != null) {\n-\t\t\t\tList<Attribute> groupAttributes = attrManager.getAttributes(sess, group);\n-\t\t\t\tfor (Attribute att : groupAttributes) {\n-\t\t\t\t\tmap.put(att.getName(), att);\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tIterator<ApplicationFormItemWithPrefilledValue> it = ((Collection<ApplicationFormItemWithPrefilledValue>) itemsWithValues).iterator();\n-\t\t\twhile (it.hasNext()) {\n-\t\t\t\tApplicationFormItemWithPrefilledValue itemW = it.next();\n-\t\t\t\tString sourceAttribute = itemW.getFormItem().getPerunSourceAttribute();\n-\t\t\t\t// skip items without perun attr reference\n-\t\t\t\tif (sourceAttribute == null || sourceAttribute.equals(\"\"))\n-\t\t\t\t\tcontinue;\n-\t\t\t\t// if attr exist and value != null\n-\t\t\t\tif (map.get(sourceAttribute) != null && map.get(sourceAttribute).getValue() != null) {\n-\t\t\t\t\tif (itemW.getFormItem().getType() == PASSWORD) {\n-\t\t\t\t\t\t// if login in namespace exists, do not return password field\n-\t\t\t\t\t\t// because application form is not place to change login or password\n-\t\t\t\t\t\tit.remove();\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\t// else set value\n-\t\t\t\t\t\titemW.setPrefilledValue(BeansUtils.attributeValueToString(map.get(sourceAttribute)));\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\tList<ApplicationFormItemWithPrefilledValue> itemsWithMissingData = new ArrayList<>();\n-\n-\t\t// get user attributes from federation\n-\t\tIterator<ApplicationFormItemWithPrefilledValue> it = (itemsWithValues).iterator();\n-\t\twhile (it.hasNext()) {\n-\t\t\tApplicationFormItemWithPrefilledValue itemW = it.next();\n-\t\t\tString fa = itemW.getFormItem().getFederationAttribute();\n-\t\t\tif (fa != null && !fa.isEmpty()) {\n-\n-\t\t\t\t// FILL VALUE FROM FEDERATION\n-\t\t\t\tString s = federValues.get(fa);\n-\t\t\t\tif (s != null && !s.isEmpty()) {\n-\t\t\t\t\t// In case of email, value from the federation can contain more than one entries, entries are separated by semi-colon\n-\t\t\t\t\tif (itemW.getFormItem().getType().equals(ApplicationFormItem.Type.VALIDATED_EMAIL)) {\n-\t\t\t\t\t\tif (itemW.getPrefilledValue() != null && !itemW.getPrefilledValue().isEmpty()) {\n-\t\t\t\t\t\t\ts = itemW.getPrefilledValue() + \";\" + s;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\t// remove password field if (login) prefilled from federation\n-\t\t\t\t\tif (itemW.getFormItem().getType() == PASSWORD) {\n-\t\t\t\t\t\tit.remove();\n-\t\t\t\t\t\tcontinue;\n-\t\t\t\t\t}\n-\t\t\t\t\titemW.setPrefilledValue(s);\n-\t\t\t\t\titemW.setAssuranceLevel(String.valueOf(extSourceLoa));\n-\t\t\t\t}\n-\n-\t\t\t\t// TRY TO CONSTRUCT THE VALUE FROM PARTIAL FED-INFO\n-\n-\t\t\t\tApplicationFormItem item = itemW.getFormItem();\n-\t\t\t\tString sourceAttribute = item.getPerunSourceAttribute();\n-\t\t\t\tif (URN_USER_TITLE_BEFORE.equals(sourceAttribute)) {\n-\t\t\t\t\tString titleBefore = parsedName.get(\"titleBefore\");\n-\t\t\t\t\tif (titleBefore != null && !titleBefore.trim().isEmpty())\n-\t\t\t\t\t\titemW.setPrefilledValue(titleBefore);\n-\t\t\t\t} else if (URN_USER_TITLE_AFTER.equals(sourceAttribute)) {\n-\t\t\t\t\tString titleAfter = parsedName.get(\"titleAfter\");\n-\t\t\t\t\tif (titleAfter != null && !titleAfter.trim().isEmpty())\n-\t\t\t\t\t\titemW.setPrefilledValue(titleAfter);\n-\t\t\t\t} else if (URN_USER_FIRST_NAME.equals(sourceAttribute)) {\n-\t\t\t\t\tString firstName = parsedName.get(\"firstName\");\n-\t\t\t\t\tif (firstName != null && !firstName.trim().isEmpty())\n-\t\t\t\t\t\titemW.setPrefilledValue(firstName);\n-\t\t\t\t} else if (URN_USER_MIDDLE_NAME.equals(sourceAttribute)) {\n-\t\t\t\t\tString middleName = parsedName.get(\"middleName\");\n-\t\t\t\t\tif (middleName != null && !middleName.trim().isEmpty()) {\n-\t\t\t\t\t\titemW.setPrefilledValue(middleName);\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\titemW.setPrefilledValue(\"\");\n-\t\t\t\t\t}\n-\t\t\t\t} else if (URN_USER_LAST_NAME.equals(sourceAttribute)) {\n-\t\t\t\t\tString lastName = parsedName.get(\"lastName\");\n-\t\t\t\t\tif (lastName != null && !lastName.trim().isEmpty())\n-\t\t\t\t\t\titemW.setPrefilledValue(lastName);\n-\t\t\t\t} else if (URN_USER_DISPLAY_NAME.equals(sourceAttribute)) {\n-\n-\t\t\t\t\t// overwrite only if not filled by Perun\n-\t\t\t\t\tif (itemW.getPrefilledValue() == null || itemW.getPrefilledValue().isEmpty()) {\n-\n-\t\t\t\t\t\tString displayName = \"\";\n-\n-\t\t\t\t\t\tif (parsedName.get(\"titleBefore\") != null && !parsedName.get(\"titleBefore\").isEmpty())\n-\t\t\t\t\t\t\tdisplayName += parsedName.get(\"titleBefore\");\n-\n-\t\t\t\t\t\tif (parsedName.get(\"firstName\") != null && !parsedName.get(\"firstName\").isEmpty()) {\n-\t\t\t\t\t\t\tif (!displayName.isEmpty()) displayName += \" \";\n-\t\t\t\t\t\t\tdisplayName += parsedName.get(\"firstName\");\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tif (parsedName.get(\"lastName\") != null && !parsedName.get(\"lastName\").isEmpty()) {\n-\t\t\t\t\t\t\tif (!displayName.isEmpty()) displayName += \" \";\n-\t\t\t\t\t\t\tdisplayName += parsedName.get(\"lastName\");\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tif (parsedName.get(\"titleAfter\") != null && !parsedName.get(\"titleAfter\").isEmpty()) {\n-\t\t\t\t\t\t\tif (!displayName.isEmpty()) displayName += \" \";\n-\t\t\t\t\t\t\tdisplayName += parsedName.get(\"titleAfter\");\n-\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\titemW.setPrefilledValue(displayName);\n-\n-\t\t\t\t\t}\n-\n-\t\t\t\t}\n-\n-\t\t\t\t// We do require value from IDP (federation) if attribute is supposed to be pre-filled and item is required and not editable to users\n-\t\t\t\tif ((itemW.getPrefilledValue() == null || itemW.getPrefilledValue().isEmpty()) && itemW.getFormItem().isRequired() &&\n-\t\t\t\t\t\t(Type.FROM_FEDERATION_HIDDEN.equals(itemW.getFormItem().getType()) || Type.FROM_FEDERATION_SHOW.equals(itemW.getFormItem().getType()))) {\n-\n-\t\t\t\t\tif (URN_USER_DISPLAY_NAME.equals(item.getPerunDestinationAttribute())) {\n-\t\t\t\t\t\tlog.error(\"Couldn't resolve displayName from: {}, parsedNames were: {}\", federValues, parsedName);\n-\t\t\t\t\t}\n-\n-\t\t\t\t\titemsWithMissingData.add(itemW);\n-\t\t\t\t}\n-\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (module != null) {\n-\t\t\tmodule.processFormItemsWithData(sess, appType, form, itemsWithValues);\n-\t\t}\n-\n-\t\tif (!itemsWithMissingData.isEmpty() && extSourceType.equals(ExtSourcesManager.EXTSOURCE_IDP)) {\n-\t\t\t// throw exception only if user is logged-in by Federation IDP\n-\t\t\tString IDP = federValues.get(\"originIdentityProvider\");\n-\t\t\tlog.error(\"[REGISTRAR] IDP {} doesn't provide data for following form items: {}\", IDP, itemsWithMissingData);\n-\t\t\tthrow new MissingRequiredDataException(\"Your IDP doesn't provide data required by this application form.\", itemsWithMissingData);\n-\t\t}\n-\n-\t\t// return prefilled form\n-\t\treturn itemsWithValues;\n-\n-\t}\n-\n-\t/**\n-\t * Check if user can submit application for specified form and type.\n-\t * Performs check on VO/Group membership, VO/Group expiration rules, form modules and duplicate (already submitted) applications.\n-\t *\n-\t * @param sess PerunSession for authz\n-\t * @param appType Type of application form\n-\t * @param form Application form\n-\t */\n-\tprivate void checkDuplicateRegistrationAttempt(PerunSession sess, AppType appType, ApplicationForm form) throws DuplicateRegistrationAttemptException, AlreadyRegisteredException, PrivilegeException, ExtendMembershipException, RegistrarException, MemberNotExistsException, CantBeSubmittedException, NotGroupMemberException {\n-\n-\t\tVo vo = form.getVo();\n-\t\tGroup group = form.getGroup();\n-\n-\t\t// get necessary params from session\n-\t\tUser user = sess.getPerunPrincipal().getUser();\n-\t\tint extSourceLoa = sess.getPerunPrincipal().getExtSourceLoa();\n-\n-\t\tif (AppType.INITIAL.equals(appType)) {\n-\t\t\tif (user != null) {\n-\t\t\t\t//user is known\n-\t\t\t\ttry {\n-\t\t\t\t\tMember m = membersManager.getMemberByUser(registrarSession, vo, user);\n-\t\t\t\t\tif (group != null) {\n-\t\t\t\t\t\t// get members groups\n-\t\t\t\t\t\tList<Group> g = groupsManager.getMemberGroups(registrarSession, m);\n-\t\t\t\t\t\tif (g.contains(group)) {\n-\t\t\t\t\t\t\t// user is member of group - can't post more initial applications\n-\t\t\t\t\t\t\tthrow new AlreadyRegisteredException(\"You are already member of group \"+group.getName()+\".\");\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tcheckDupplicateGroupApplications(sess, vo, group, AppType.INITIAL);\n-\t\t\t\t\t\t\t// pass if have approved or rejected app\n-\t\t\t\t\t\t}\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\t// user is member of vo, can't post more initial applications\n-\t\t\t\t\t\tthrow new AlreadyRegisteredException(\"You are already member of VO: \"+vo.getName());\n-\t\t\t\t\t}\n-\t\t\t\t} catch (MemberNotExistsException ex) {\n-\t\t\t\t\t// user is not member of vo\n-\t\t\t\t\tif (group != null) {\n-\t\t\t\t\t\tcheckDupplicateGroupApplications(sess, vo, group, AppType.INITIAL);\n-\t\t\t\t\t\t//throw new InternalErrorException(\"You must be member of vo: \"+vo.getName()+\" to apply for membership in group: \"+group.getName());\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tcheckDupplicateVoApplications(sess, vo, AppType.INITIAL);\n-\t\t\t\t\t\t// pass not member and have only approved or rejected apps\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\t// user is not known\n-\t\t\t\tif (group != null) {\n-\t\t\t\t\tcheckDupplicateGroupApplications(sess, vo, group, AppType.INITIAL);\n-\t\t\t\t\t//throw new InternalErrorException(\"You must be member of vo: \"+vo.getName()+\" to apply for membership in group: \"+group.getName());\n-\t\t\t\t} else {\n-\t\t\t\t\tcheckDupplicateVoApplications(sess, vo, AppType.INITIAL);\n-\t\t\t\t\t// pass not member and have only approved or rejected apps\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\t// if false, throws exception with reason for GUI\n-\t\t\tmembersManager.canBeMemberWithReason(sess, vo, user, String.valueOf(extSourceLoa));\n-\t\t}\n-\t\t// if extension, user != null !!\n-\t\tif (AppType.EXTENSION.equals(appType)) {\n-\t\t\tif (user == null) {\n-\t\t\t\tthrow new RegistrarException(\"Trying to get extension application for non-existing user. Try to log-in with different identity.\");\n-\t\t\t}\n-\t\t\t// check for submitted registrations\n-\t\t\tMember member = membersManager.getMemberByUser(sess, vo, user);\n-\t\t\tif (group != null) {\n-\t\t\t\tmember = groupsManager.getGroupMemberById(registrarSession, group, member.getId());\n-\t\t\t\tcheckDupplicateGroupApplications(sess, vo, group, AppType.EXTENSION);\n-\t\t\t\t// if false, throws exception with reason for GUI\n-\t\t\t\tgroupsManager.canExtendMembershipInGroupWithReason(sess, member, group);\n-\t\t\t\t// vo sponsored members can extend in a group\n-\t\t\t} else {\n-\t\t\t\tcheckDupplicateVoApplications(sess, vo, AppType.EXTENSION);\n-\t\t\t\t// if false, throws exception with reason for GUI\n-\t\t\t\tmembersManager.canExtendMembershipWithReason(sess, member);\n-\t\t\t\t// sponsored vo members cannot be extended in this way\n-\t\t\t\tif (member.isSponsored()) {\n-\t\t\t\t\tthrow new CantBeSubmittedException(\"Sponsored member cannot apply for membership extension, it must be extended by the sponsor.\");\n-\t\t\t\t}\n-\n-\t\t\t}\n-\n-\t\t}\n-\n-\t}\n-\n-\t@Override\n-\tpublic boolean validateEmailFromLink(Map<String, String> urlParameters) throws PerunException {\n-\n-\t\tString idStr = urlParameters.get(\"i\");\n-\t\tif (mailManager.getMessageAuthenticationCode(idStr).equals(urlParameters.get(\"m\"))) {\n-\t\t\tint appDataId = Integer.parseInt(idStr, Character.MAX_RADIX);\n-\t\t\t// validate mail\n-\t\t\tjdbc.update(\"update application_data set assurance_level=1 where id = ?\", appDataId);\n-\t\t\tApplication app = getApplicationById(jdbc.queryForInt(\"select app_id from application_data where id = ?\", appDataId));\n-\t\t\tif (app == null) {\n-\t\t\t\tlog.warn(\"Application for FormItemData ID: {} doesn't exists and therefore mail can't be verified.\", appDataId);\n-\t\t\t\tthrow new RegistrarException(\"Application doesn't exists and therefore mail can't be verified.\");\n-\t\t\t}\n-\n-\t\t\t// if application is already approved or rejected, fake OK on mail validation and do nothing\n-\t\t\tif (Arrays.asList(AppState.APPROVED, AppState.REJECTED).contains(app.getState())) return true;\n-\n-\t\t\tboolean verified = AppState.VERIFIED.equals(app.getState());\n-\t\t\tif (AppState.NEW.equals(app.getState())) {\n-\t\t\t\t// try to verify only new applications\n-\t\t\t\tverified = tryToVerifyApplication(registrarSession, app);\n-\t\t\t}\n-\t\t\tif (verified) {\n-\t\t\t\t// try to APPROVE only verified and only if auto approve\n-\t\t\t\ttry {\n-\t\t\t\t\ttryToAutoApproveApplication(registrarSession, app);\n-\t\t\t\t} catch (PerunException ex) {\n-\t\t\t\t\t// when approval fails, we want this to be silently skipped, since for \"user\" called method did verified his mail address.\n-\t\t\t\t\tlog.warn(\"We couldn't auto-approve application {}, because of error: {}\", app, ex);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\treturn true;\n-\t\t}\n-\t\treturn false;\n-\n-\t}\n-\n-\t@Override\n-\tpublic List<ApplicationFormItem> getFormItems(PerunSession sess, ApplicationForm form) throws PerunException {\n-\t\treturn getFormItems(sess, form, null);\n-\t}\n-\n-\t@Override\n-\tpublic List<ApplicationFormItemData> getApplicationDataById(PerunSession sess, int appId) throws PrivilegeException, RegistrarException {\n-\n-\t\t// this ensure authorization of user on application\n-\t\ttry {\n-\t\t\tgetApplicationById(sess, appId);\n-\t\t} catch (PrivilegeException ex) {\n-\t\t\tthrow new PrivilegeException(sess, \"getApplicationDataById\");\n-\t\t}\n-\n-\t\treturn jdbc.query(\"select id,item_id,shortname,value,assurance_level from application_data where app_id=?\",\n-\t\t\t\t(resultSet, rowNum) -> {\n-\t\t\t\t\tApplicationFormItemData data = new ApplicationFormItemData();\n-\t\t\t\t\tdata.setId(resultSet.getInt(\"id\"));\n-\t\t\t\t\tdata.setFormItem(getFormItemById(resultSet.getInt(\"item_id\")));\n-\t\t\t\t\tdata.setShortname(resultSet.getString(\"shortname\"));\n-\t\t\t\t\tdata.setValue(resultSet.getString(\"value\"));\n-\t\t\t\t\tdata.setAssuranceLevel(resultSet.getString(\"assurance_level\"));\n-\t\t\t\t\treturn data;\n-\t\t\t\t}, appId);\n-\n-\t}\n-\n-\t@Override\n-\tpublic void copyFormFromVoToVo(PerunSession sess, Vo fromVo, Vo toVo) throws PerunException {\n-\t\tvosManager.checkVoExists(sess, fromVo);\n-\t\tvosManager.checkVoExists(sess, toVo);\n-\n-\t\t//Authorization\n-\t\tif (!AuthzResolver.authorizedInternal(sess, \"copyFormFromVoToVo_Vo_Vo_policy\", fromVo) ||\n-\t\t\t!AuthzResolver.authorizedInternal(sess, \"copyFormFromVoToVo_Vo_Vo_policy\", toVo)) {\n-\t\t\tthrow new PrivilegeException(sess, \"copyFormFromVoToVo\");\n-\t\t}\n-\n-\t\tList<ApplicationFormItem> items = getFormItems(sess, getFormForVo(fromVo));\n-\t\tfor (ApplicationFormItem item : items) {\n-\t\t\titem.setOrdnum(null); // reset order, id is always new inside add method\n-\t\t\taddFormItem(sess, getFormForVo(toVo), item);\n-\t\t}\n-\n-\t}\n-\n-\t@Override\n-\tpublic void copyFormFromVoToGroup(PerunSession sess, Vo fromVo, Group toGroup, boolean reverse) throws PerunException {\n-\t\tvosManager.checkVoExists(sess, fromVo);\n-\t\tgroupsManager.checkGroupExists(sess, toGroup);\n-\n-\t\t//Authorization\n-\t\tif (!AuthzResolver.authorizedInternal(sess, \"source-copyFormFromVoToGroup_Vo_Group_Policy\", Collections.singletonList(fromVo))\n-\t\t\t|| !AuthzResolver.authorizedInternal(sess, \"destination-copyFormFromVoToGroup_Vo_Group_Policy\", Collections.singletonList(toGroup))) {\n-\t\t\tthrow new PrivilegeException(sess, \"copyFormFromVoToGroup\");\n-\t\t}\n-\n-\t\tif (reverse) {\n-\n-\t\t\t// copy from group to VO\n-\t\t\tList<ApplicationFormItem> items = getFormItems(sess, getFormForGroup(toGroup));\n-\t\t\tfor (ApplicationFormItem item : items) {\n-\t\t\t\titem.setOrdnum(null); // reset order, id is always new inside add method\n-\t\t\t\taddFormItem(sess, getFormForVo(fromVo), item);\n-\t\t\t}\n-\n-\t\t} else {\n-\n-\t\t\t// copy from VO to group\n-\t\t\tList<ApplicationFormItem> items = getFormItems(sess, getFormForVo(fromVo));\n-\t\t\tfor (ApplicationFormItem item : items) {\n-\t\t\t\titem.setOrdnum(null); // reset order, id is always new inside add method\n-\t\t\t\taddFormItem(sess, getFormForGroup(toGroup), item);\n-\t\t\t}\n-\n-\t\t}\n-\n-\t}\n-\n-\t@Override\n-\tpublic void copyFormFromGroupToGroup(PerunSession sess, Group fromGroup, Group toGroup) throws PerunException {\n-\t\tgroupsManager.checkGroupExists(sess, fromGroup);\n-\t\tgroupsManager.checkGroupExists(sess, toGroup);\n-\n-\t\t//Authorization\n-\t\tif (!AuthzResolver.authorizedInternal(sess, \"source-copyFormFromGroupToGroup_Group_Group_policy\", Collections.singletonList(fromGroup))\n-\t\t\t|| !AuthzResolver.authorizedInternal(sess, \"destination-copyFormFromGroupToGroup_Group_Group_policy\", Collections.singletonList(toGroup))) {\n-\t\t\tthrow new PrivilegeException(sess, \"copyFormFromGroupToGroup\");\n-\t\t}\n-\n-\t\tList<ApplicationFormItem> items = getFormItems(sess, getFormForGroup(fromGroup));\n-\t\tfor (ApplicationFormItem item : items) {\n-\t\t\titem.setOrdnum(null); // reset order, id is always new inside add method\n-\t\t\taddFormItem(sess, getFormForGroup(toGroup), item);\n-\t\t}\n-\n-\t}\n-\n-\tpublic void updateApplicationUser(PerunSession sess, Application app) {\n-\n-\t\tjdbc.update(\"update application set user_id=?, modified_at=\" + Compatibility.getSysdate() + \", modified_by=? where id=?\",\n-\t\t\t\t(app.getUser() != null) ? app.getUser().getId() : null,\n-\t\t\t\tsess.getPerunPrincipal().getActor(),\n-\t\t\t\tapp.getId());\n-\n-\t}\n-\n-\tpublic void updateFormItemData(PerunSession sess, int appId, ApplicationFormItemData data) throws RegistrarException, PrivilegeException {\n-\n-\t\t//Authorization\n-\t\tif (!AuthzResolver.authorizedInternal(sess, \"updateFormItemData_int_ApplicationFormItemData_policy\")) {\n-\t\t\tthrow new PrivilegeException(sess, \"updateFormItemData\");\n-\t\t}\n-\n-\t\tApplication app = getApplicationById(sess, appId);\n-\t\tif (AppState.APPROVED.equals(app.getState()) || AppState.REJECTED.equals(app.getState())) throw new RegistrarException(\"Form items of once approved or rejected applications can't be modified.\");\n-\n-\t\tApplicationFormItemData existingData = getFormItemDataById(data.getId(), appId);\n-\t\tif (existingData == null) throw new RegistrarException(\"Form item data specified by ID: \"+ data.getId() + \" not found or doesn't belong to the application \"+appId);\n-\n-\t\tList<Type> notAllowed = Arrays.asList(FROM_FEDERATION_HIDDEN, FROM_FEDERATION_SHOW, USERNAME, PASSWORD, HEADING, HTML_COMMENT, SUBMIT_BUTTON, AUTO_SUBMIT_BUTTON);\n-\n-\t\tif (notAllowed.contains(existingData.getFormItem().getType())) throw new RegistrarException(\"You are not allowed to modify \"+existingData.getFormItem().getType()+\" type of form items.\");\n-\n-\t\tupdateFormItemData(sess, data);\n-\n-\t}\n-\n-\t@Transactional(rollbackFor = Exception.class)\n-\tpublic void updateFormItemsData(PerunSession sess, int appId, List<ApplicationFormItemData> data) throws PerunException {\n-\n-\t\tApplication app = getApplicationById(appId);\n-\n-\t\tif (app == null) throw new InternalErrorException(\"Application with ID=\"+appId+\" doesn't exist.\");\n-\n-\t\tif (!AuthzResolver.selfAuthorizedForApplication(sess, app)) {\n-\t\t\tthrow new PrivilegeException(sess, \"updateFormItemsData\");\n-\t\t}\n-\n-\t\tif (AppState.APPROVED.equals(app.getState()) || AppState.REJECTED.equals(app.getState())) throw new RegistrarException(\"Form items of once approved or rejected applications can't be modified.\");\n-\n-\t\t// no data to change\n-\t\tif (data == null || data.isEmpty()) return;\n-\n-\t\tfor (ApplicationFormItemData dataItem : data) {\n-\n-\t\t\tApplicationFormItemData existingData = getFormItemDataById(dataItem.getId(), appId);\n-\t\t\tif (existingData == null) throw new RegistrarException(\"Form item data specified by ID: \" + dataItem.getId() + \" not found or doesn't belong to the application \" + appId);\n-\n-\t\t\tList<Type> notAllowed = Arrays.asList(FROM_FEDERATION_HIDDEN, FROM_FEDERATION_SHOW, USERNAME, PASSWORD, HEADING, HTML_COMMENT, SUBMIT_BUTTON, AUTO_SUBMIT_BUTTON);\n-\n-\t\t\tif (notAllowed.contains(existingData.getFormItem().getType()))\n-\t\t\t\tthrow new RegistrarException(\"You are not allowed to modify \" + existingData.getFormItem().getType() + \" type of form items.\");\n-\n-\t\t\tupdateFormItemData(sess, dataItem);\n-\n-\t\t}\n-\n-\t\t// forcefully mark application as NEW and perform verification\n-\t\tsetApplicationState(sess, app.getId(), AppState.NEW);\n-\n-\t\t// in case that user fixed own form, it should be possible to verify and approve it for auto-approval cases\n-\t\tboolean verified = tryToVerifyApplication(sess, app);\n-\t\tif (verified) {\n-\t\t\t// try to APPROVE if auto approve\n-\t\t\ttryToAutoApproveApplication(sess, app);\n-\t\t} else {\n-\t\t\t// send request validation notification\n-\t\t\tgetMailManager().sendMessage(app, MailType.MAIL_VALIDATION, null, null);\n-\t\t}\n-\n-\t}\n-\n-\tprivate void updateFormItemData(PerunSession session, ApplicationFormItemData dataItem) {\n-\t\ttry {\n-\t\t\tif (VALIDATED_EMAIL.equals(dataItem.getFormItem().getType())) {\n-\t\t\t\thandleLoaForValidatedMail(session, dataItem);\n-\t\t\t}\n-\t\t\tint result = jdbc.update(\"update application_data set value=? , assurance_level=? where id=?\",\n-\t\t\t\t\tdataItem.getValue(), ((StringUtils.isBlank(dataItem.getAssuranceLevel())) ? null : dataItem.getAssuranceLevel()),\n-\t\t\t\t\tdataItem.getId());\n-\t\t\tlog.info(\"{} manually updated form item data {}\", session.getPerunPrincipal(), dataItem);\n-\t\t\tif (result != 1) {\n-\t\t\t\tthrow new InternalErrorException(\"Unable to update form item data\");\n-\t\t\t}\n-\t\t} catch (RuntimeException ex) {\n-\t\t\tthrow new InternalErrorException(ex);\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic List<Application> filterPrincipalApplications(PerunSession sess, List<Application> applications) {\n-\t\t// get necessary params from session\n-\t\tPerunPrincipal principal = sess.getPerunPrincipal();\n-\t\tUser user = principal.getUser();\n-\t\tString actor = principal.getActor();\n-\t\tString extSourceName = principal.getExtSourceName();\n-\t\tMap<String, String> additionalInformation = principal.getAdditionalInformations();\n-\n-\t\tList<Application> filteredApplications = new ArrayList<>();\n-\n-\t\t// filter principal's applications\n-\t\tfor (Application application : applications) {\n-\t\t\t// check existing application by user\n-\t\t\tif (user != null && application.getUser() != null && user.getId() == application.getUser().getId()) {\n-\t\t\t\tfilteredApplications.add(application);\n-\t\t\t} else {\n-\t\t\t\t//check existing application by additional identifiers\n-\t\t\t\tString shibIdentityProvider = additionalInformation.get(UsersManagerBl.ORIGIN_IDENTITY_PROVIDER_KEY);\n-\t\t\t\tif (shibIdentityProvider != null && extSourcesWithMultipleIdentifiers.contains(shibIdentityProvider)) {\n-\t\t\t\t\tString principalAdditionalIdentifiers = principal.getAdditionalInformations().get(UsersManagerBl.ADDITIONAL_IDENTIFIERS_ATTRIBUTE_NAME);\n-\t\t\t\t\tif (principalAdditionalIdentifiers == null) {\n-\t\t\t\t\t\t//This should not happen\n-\t\t\t\t\t\tthrow new InternalErrorException(\"Entry \" + UsersManagerBl.ADDITIONAL_IDENTIFIERS_ATTRIBUTE_NAME + \" is not defined in the principal's additional information. Either it was not provided by external source used for sign-in or the mapping configuration is wrong.\");\n-\t\t\t\t\t}\n-\t\t\t\t\tLinkedHashMap<String, String> additionalFedAttributes = BeansUtils.stringToMapOfAttributes(application.getFedInfo());\n-\t\t\t\t\tString applicationAdditionalIdentifiers = additionalFedAttributes.get(UsersManagerBl.ADDITIONAL_IDENTIFIERS_ATTRIBUTE_NAME);\n-\t\t\t\t\tList<String> identifiersInIntersection = BeansUtils.additionalIdentifiersIntersection(principalAdditionalIdentifiers, applicationAdditionalIdentifiers);\n-\t\t\t\t\tif (!identifiersInIntersection.isEmpty()) {\n-\t\t\t\t\t\tfilteredApplications.add(application);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\t//check existing application by extSourceName and extSource login\n-\t\t\t\telse if (extSourceName.equals(application.getExtSourceName()) && actor.equals(application.getCreatedBy())) {\n-\t\t\t\t\tfilteredApplications.add(application);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn filteredApplications;\n-\t}\n-\n-\t@Override\n-\tpublic List<Application> filterUserApplications(PerunSession sess, User user, List<Application> applications) {\n-\n-\t\tList<UserExtSource> userExtSources = usersManager.getUserExtSources(registrarSession, user);\n-\n-\t\tList<Application> resultApps = new ArrayList<>();\n-\n-\t\tfor (Application application : applications) {\n-\t\t\t//check based on user id\n-\t\t\tif (application.getUser() != null && application.getUser().getId() == user.getId()) {\n-\t\t\t\tresultApps.add(application);\n-\t\t\t//check based on user extSources\n-\t\t\t} else {\n-\t\t\t\tfor (UserExtSource ues : userExtSources) {\n-\t\t\t\t\tif (ues.getExtSource().getName().equals(application.getExtSourceName()) &&\n-\t\t\t\t\tues.getExtSource().getType().equals(application.getExtSourceType())) {\n-\t\t\t\t\t\t//login check\n-\t\t\t\t\t\tif (ues.getLogin().equals(application.getCreatedBy())) {\n-\t\t\t\t\t\t\tresultApps.add(application);\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\t//additional identifiers check\n-\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\tAttribute attribute = attrManager.getAttribute(sess, ues, UsersManagerBl.ADDITIONAL_IDENTIFIERS_PERUN_ATTRIBUTE_NAME);\n-\t\t\t\t\t\t\tif (attribute.getValue() != null) {\n-\t\t\t\t\t\t\t\tList<String> userIdentifiers = attribute.valueAsList();\n-\t\t\t\t\t\t\t\t// Creates Arrays from principal and application identifiers and makes intersection between them.\n-\t\t\t\t\t\t\t\tLinkedHashMap<String, String> additionalFedAttributes = BeansUtils.stringToMapOfAttributes(application.getFedInfo());\n-\t\t\t\t\t\t\t\tString applicationAdditionalIdentifiers = additionalFedAttributes.get(UsersManagerBl.ADDITIONAL_IDENTIFIERS_ATTRIBUTE_NAME);\n-\t\t\t\t\t\t\t\tString[] applicationIdentifiersArray = {};\n-\t\t\t\t\t\t\t\tif (applicationAdditionalIdentifiers != null) {\n-\t\t\t\t\t\t\t\t\tapplicationIdentifiersArray = applicationAdditionalIdentifiers.split(UsersManagerBl.MULTIVALUE_ATTRIBUTE_SEPARATOR_REGEX);\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\tHashSet<String> principalIdentifiersSet = new HashSet<>(userIdentifiers);\n-\t\t\t\t\t\t\t\tprincipalIdentifiersSet.retainAll(Arrays.asList(applicationIdentifiersArray));\n-\t\t\t\t\t\t\t\tif (!principalIdentifiersSet.isEmpty()) {\n-\t\t\t\t\t\t\t\t\tresultApps.add(application);\n-\t\t\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t} catch (WrongAttributeAssignmentException | AttributeNotExistsException e) {\n-\t\t\t\t\t\t\t//We can ignore that\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn resultApps;\n-\t}\n-\n-\t/**\n-\t * Retrieve form item data by its ID or NULL if not exists.\n-\t * It also expect, that item belongs to the passed application ID, if not, NULL is returned.\n-\t *\n-\t * @param formItemDataId ID of form item data entry\n-\t * @param applicationId ID of application this item belongs to\n-\t * @return Form item with data submitted by the User.\n-\t * @throws InternalErrorException When implementation fails\n-\t */\n-\tprivate ApplicationFormItemData getFormItemDataById(int formItemDataId, int applicationId) {\n-\n-\t\ttry {\n-\t\t\treturn jdbc.queryForObject(\"select id,item_id,shortname,value,assurance_level from application_data where id=? and app_id=?\",\n-\t\t\t\t\t(resultSet, rowNum) -> {\n-\t\t\t\t\t\tApplicationFormItemData data = new ApplicationFormItemData();\n-\t\t\t\t\t\tdata.setId(resultSet.getInt(\"id\"));\n-\t\t\t\t\t\tdata.setFormItem(getFormItemById(resultSet.getInt(\"item_id\")));\n-\t\t\t\t\t\tdata.setShortname(resultSet.getString(\"shortname\"));\n-\t\t\t\t\t\tdata.setValue(resultSet.getString(\"value\"));\n-\t\t\t\t\t\tdata.setAssuranceLevel(resultSet.getString(\"assurance_level\"));\n-\t\t\t\t\t\treturn data;\n-\t\t\t\t\t}, formItemDataId, applicationId);\n-\t\t} catch (EmptyResultDataAccessException ex) {\n-\t\t\treturn null;\n-\t\t} catch (RuntimeException ex) {\n-\t\t\tthrow new InternalErrorException(\"Unable to get form item data by its ID:\" + formItemDataId + \" and application ID: \" + applicationId, ex);\n-\t\t}\n-\n-\t}\n-\n-\t@Override\n-\tpublic MailManager getMailManager() {\n-\t\treturn this.mailManager;\n-\t}\n-\n-\t@Override\n-\tpublic ConsolidatorManager getConsolidatorManager() {\n-\t\treturn this.consolidatorManager;\n-\t}\n-\n-\t/**\n-\t * Set application to VERIFIED state if all it's\n-\t * mails (VALIDATED_EMAIL) have assuranceLevel >= 1 and have non-empty value (there is anything to validate).\n-\t * Returns TRUE if succeeded, FALSE if some mail still waits for verification.\n-\t *\n-\t * @param sess user who try to verify application\n-\t * @param app application to verify\n-\t * @return TRUE if verified / FALSE if not verified\n-\t * @throws InternalErrorException\n-\t */\n-\tprivate boolean tryToVerifyApplication(PerunSession sess, Application app) throws PerunException {\n-\n-\t\t// test all fields that may need to be validated and are not empty !!\n-\t\tList<Integer> loas = jdbc.query(\"select d.assurance_level\"+Compatibility.castToInteger()+\" from application a, application_form_items i, application_data d \" +\n-\t\t\t\t\t\t\"where d.app_id=a.id and d.item_id=i.id and a.id=? and i.type=? and d.value is not null\",\n-\t\t\t\tnew SingleColumnRowMapper<>(Integer.class), app.getId(), Type.VALIDATED_EMAIL.toString());\n-\n-\t\tboolean allValidated = true;\n-\t\tfor (Integer loa : loas) {\n-\t\t\t// check on null only for backward compatibility, we now always set some value\n-\t\t\tif (loa == null || loa < 1) {\n-\t\t\t\tallValidated = false;\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (allValidated) {\n-\t\t\t// mark VERIFIED\n-\t\t\tmarkApplicationVerified(sess, app.getId());\n-\t\t\tapp.setState(AppState.VERIFIED);\n-\t\t}\n-\n-\t\treturn allValidated;\n-\n-\t}\n-\n-\t/**\n-\t * Forcefully marks application as VERIFIED\n-\t * (only if was in NEW state before)\n-\t *\n-\t * @param sess session info to use for modified_by\n-\t * @param appId ID of application to verify.\n-\t */\n-\tprivate void markApplicationVerified(PerunSession sess, int appId) {\n-\n-\t\ttry {\n-\t\t\tif (jdbc.update(\"update application set state=?, modified_at=\" + Compatibility.getSysdate() + \", modified_by=? where id=? and state=?\", AppState.VERIFIED.toString(), sess.getPerunPrincipal().getActor(), appId, AppState.NEW.toString()) > 0) {\n-\t\t\t\tlog.info(\"Application {} marked as VERIFIED\", appId);\n-\t\t\t} else {\n-\t\t\t\tlog.info(\"Application {} not marked VERIFIED, was not in state NEW\", appId);\n-\t\t\t}\n-\t\t} catch (InternalErrorException ex) {\n-\t\t\tlog.error(\"Application {} NOT marked as VERIFIED due to error {}\", appId, ex);\n-\t\t}\n-\n-\t}\n-\n-\t/**\n-\t * Forcefully set application its state (NEW/VERIFIED/...)\n-\t *\n-\t * @param sess PerunSession\n-\t * @param appId ID of application\n-\t * @param appState AppState to be set\n-\t */\n-\tprivate void setApplicationState(PerunSession sess, int appId, AppState appState) {\n-\t\ttry {\n-\t\t\tjdbc.update(\"update application set state=?, modified_at=\" + Compatibility.getSysdate() + \", modified_by=? where id=?\",\n-\t\t\t\t\tappState.toString(), sess.getPerunPrincipal().getActor(), appId);\n-\t\t} catch (RuntimeException ex) {\n-\t\t\tlog.error(\"Unable to set application state: {}, to application ID: {}\", appState, appId, ex);\n-\t\t\tthrow new InternalErrorException(\"Unable to set application state: \"+appState+\" to application: \"+appId, ex);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Try to approve application if auto-approve is possible\n-\t *\n-\t * @param sess user who try to approves application\n-\t * @param app application to approve\n-\t * @throws InternalErrorException\n-\t */\n-\tprivate void tryToAutoApproveApplication(PerunSession sess, Application app) throws PerunException {\n-\n-\t\tApplicationForm form;\n-\t\tif (app.getGroup() != null) {\n-\t\t\t// group application\n-\t\t\tform = getFormForGroup(app.getGroup());\n-\t\t} else {\n-\t\t\t// vo application\n-\t\t\tform = getFormForVo(app.getVo());\n-\t\t}\n-\t\tAppType type = app.getType();\n-\n-\t\tif (AppType.INITIAL.equals(type) && !form.isAutomaticApproval()) return;\n-\t\tif (AppType.EXTENSION.equals(type) && !form.isAutomaticApprovalExtension()) return;\n-\n-\t\t// do not auto-approve Group applications, if user is not member of VO\n-\t\tif (app.getGroup() != null && app.getVo() != null) {\n-\n-\t\t\ttry {\n-\t\t\t\tif (app.getUser() == null) {\n-\t\t\t\t\tLinkedHashMap<String, String> additionalAttributes = BeansUtils.stringToMapOfAttributes(app.getFedInfo());\n-\t\t\t\t\tPerunPrincipal applicationPrincipal = new PerunPrincipal(app.getCreatedBy(), app.getExtSourceName(), app.getExtSourceType(), app.getExtSourceLoa(), additionalAttributes);\n-\t\t\t\t\tUser u = perun.getUsersManagerBl().getUserByExtSourceInformation(sess, applicationPrincipal);\n-\t\t\t\t\tif (u != null) {\n-\t\t\t\t\t\tmembersManager.getMemberByUser(sess, app.getVo(), u);\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\t// user not found or null, hence can't be member of VO -> do not approve.\n-\t\t\t\t\t\treturn;\n-\t\t\t\t\t}\n-\t\t\t\t} else {\n-\t\t\t\t\t// user known, but maybe not member of a vo\n-\t\t\t\t\tmembersManager.getMemberByUser(sess, app.getVo(), app.getUser());\n-\t\t\t\t}\n-\t\t\t} catch (MemberNotExistsException ex) {\n-\t\t\t\treturn;\n-\t\t\t} catch (UserNotExistsException ex) {\n-\t\t\t\treturn;\n-\t\t\t} catch (UserExtSourceNotExistsException ex) {\n-\t\t\t\treturn;\n-\t\t\t} catch (ExtSourceNotExistsException ex) {\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t}\n-\n-\t\ttry {\n-\t\t\tif (AppState.VERIFIED.equals(app.getState())) {\n-\t\t\t\t// with registrar session, since only VO admin can approve application\n-\n-\t\t\t\t// check if can be approved (we normally call this manually from GUI before calling approve)\n-\t\t\t\tcanBeApproved(registrarSession, app);\n+    private final static Logger log = LoggerFactory.getLogger(RegistrarManagerImpl.class);\n+    private final static Set<String> extSourcesWithMultipleIdentifiers = BeansUtils.getCoreConfig().getExtSourcesMultipleIdentifiers();\n+\n+    // identifiers for selected attributes\n+    private static final String URN_USER_TITLE_BEFORE = \"urn:perun:user:attribute-def:core:titleBefore\";\n+    private static final String URN_USER_TITLE_AFTER = \"urn:perun:user:attribute-def:core:titleAfter\";\n+    private static final String URN_USER_FIRST_NAME = \"urn:perun:user:attribute-def:core:firstName\";\n+    static final String URN_USER_LAST_NAME = \"urn:perun:user:attribute-def:core:lastName\";\n+    private static final String URN_USER_MIDDLE_NAME = \"urn:perun:user:attribute-def:core:middleName\";\n+    static final String URN_USER_DISPLAY_NAME = \"urn:perun:user:attribute-def:core:displayName\";\n+\n+    private static final String DISPLAY_NAME_VO_FROM_EMAIL = \"\\\"From\\\" email address\";\n+    private static final String FRIENDLY_NAME_VO_FROM_EMAIL = \"fromEmail\";\n+    private static final String NAMESPACE_VO_FROM_EMAIL = AttributesManager.NS_VO_ATTR_DEF;\n+    static final String URN_VO_FROM_EMAIL = NAMESPACE_VO_FROM_EMAIL + \":\" + FRIENDLY_NAME_VO_FROM_EMAIL;\n+\n+    private static final String DISPLAY_NAME_VO_TO_EMAIL = \"\\\"To\\\" email addresses\";\n+    private static final String FRIENDLY_NAME_VO_TO_EMAIL = \"toEmail\";\n+    private static final String NAMESPACE_VO_TO_EMAIL = AttributesManager.NS_VO_ATTR_DEF;\n+    static final String URN_VO_TO_EMAIL = NAMESPACE_VO_TO_EMAIL + \":\" + FRIENDLY_NAME_VO_TO_EMAIL;\n+\n+    private static final String DISPLAY_NAME_GROUP_TO_EMAIL = \"\\\"To\\\" email addresses\";\n+    private static final String FRIENDLY_NAME_GROUP_TO_EMAIL = \"toEmail\";\n+    private static final String NAMESPACE_GROUP_TO_EMAIL = AttributesManager.NS_GROUP_ATTR_DEF;\n+    static final String URN_GROUP_TO_EMAIL = NAMESPACE_GROUP_TO_EMAIL + \":\" + FRIENDLY_NAME_GROUP_TO_EMAIL;\n+\n+    private static final String DISPLAY_NAME_GROUP_FROM_EMAIL = \"\\\"From\\\" email address\";\n+    private static final String FRIENDLY_NAME_GROUP_FROM_EMAIL = \"fromEmail\";\n+    private static final String NAMESPACE_GROUP_FROM_EMAIL = AttributesManager.NS_GROUP_ATTR_DEF;\n+    static final String URN_GROUP_FROM_EMAIL = NAMESPACE_GROUP_FROM_EMAIL + \":\" + FRIENDLY_NAME_GROUP_FROM_EMAIL;\n+\n+    private static final String DISPLAY_NAME_GROUP_FROM_NAME_EMAIL = \"\\\"From\\\" name\";\n+    private static final String FRIENDLY_NAME_GROUP_FROM_NAME_EMAIL = \"fromNameEmail\";\n+    private static final String NAMESPACE_GROUP_FROM_NAME_EMAIL = AttributesManager.NS_GROUP_ATTR_DEF;\n+    static final String URN_GROUP_FROM_NAME_EMAIL = NAMESPACE_GROUP_FROM_EMAIL + \":\" + FRIENDLY_NAME_GROUP_FROM_NAME_EMAIL;\n+\n+    private static final String DISPLAY_NAME_VO_FROM_NAME_EMAIL = \"\\\"From\\\" name\";\n+    private static final String FRIENDLY_NAME_VO_FROM_NAME_EMAIL = \"fromNameEmail\";\n+    private static final String NAMESPACE_VO_FROM_NAME_EMAIL = AttributesManager.NS_VO_ATTR_DEF;\n+    static final String URN_VO_FROM_NAME_EMAIL = NAMESPACE_VO_FROM_EMAIL + \":\" + FRIENDLY_NAME_VO_FROM_NAME_EMAIL;\n+\n+    private static final String DISPLAY_NAME_VO_LANGUAGE_EMAIL = \"Notification default language\";\n+    private static final String FRIENDLY_NAME_VO_LANGUAGE_EMAIL = \"notificationsDefLang\";\n+    private static final String NAMESPACE_VO_LANGUAGE_EMAIL = AttributesManager.NS_VO_ATTR_DEF;\n+    static final String URN_VO_LANGUAGE_EMAIL = NAMESPACE_VO_LANGUAGE_EMAIL + \":\" + FRIENDLY_NAME_VO_LANGUAGE_EMAIL;\n+\n+    private static final String DISPLAY_NAME_GROUP_LANGUAGE_EMAIL = \"Notification default language\";\n+    private static final String FRIENDLY_NAME_GROUP_LANGUAGE_EMAIL = \"notificationsDefLang\";\n+    private static final String NAMESPACE_GROUP_LANGUAGE_EMAIL = AttributesManager.NS_GROUP_ATTR_DEF;\n+    static final String URN_GROUP_LANGUAGE_EMAIL = NAMESPACE_GROUP_LANGUAGE_EMAIL + \":\" + FRIENDLY_NAME_GROUP_LANGUAGE_EMAIL;\n+\n+    private static final String DISPLAY_NAME_VO_APPLICATION_URL = \"Application form URL\";\n+    private static final String FRIENDLY_NAME_VO_APPLICATION_URL = \"applicationURL\";\n+    private static final String NAMESPACE_VO_APPLICATION_URL = AttributesManager.NS_VO_ATTR_DEF;\n+    private static final String URN_VO_APPLICATION_URL = NAMESPACE_VO_APPLICATION_URL + \":\" + FRIENDLY_NAME_VO_APPLICATION_URL;\n+\n+    private static final String DISPLAY_NAME_GROUP_APPLICATION_URL = \"Application form URL\";\n+    private static final String FRIENDLY_NAME_GROUP_APPLICATION_URL = \"applicationURL\";\n+    private static final String NAMESPACE_GROUP_APPLICATION_URL = AttributesManager.NS_GROUP_ATTR_DEF;\n+    private static final String URN_GROUP_APPLICATION_URL = NAMESPACE_GROUP_APPLICATION_URL + \":\" + FRIENDLY_NAME_GROUP_APPLICATION_URL;\n+\n+    private static final String DISPLAY_NAME_VO_REGISTRAR_URL = \"Registrar URL\";\n+    private static final String FRIENDLY_NAME_VO_REGISTRAR_URL = \"registrarURL\";\n+    private static final String NAMESPACE_VO_REGISTRAR_URL = AttributesManager.NS_VO_ATTR_DEF;\n+    static final String URN_VO_REGISTRAR_URL = NAMESPACE_VO_REGISTRAR_URL + \":\" + FRIENDLY_NAME_VO_REGISTRAR_URL;\n+\n+    private static final String DISPLAY_NAME_GROUP_REGISTRAR_URL = \"Registrar URL\";\n+    private static final String FRIENDLY_NAME_GROUP_REGISTRAR_URL = \"registrarURL\";\n+    private static final String NAMESPACE_GROUP_REGISTRAR_URL = AttributesManager.NS_GROUP_ATTR_DEF;\n+    static final String URN_GROUP_REGISTRAR_URL = NAMESPACE_GROUP_REGISTRAR_URL + \":\" + FRIENDLY_NAME_GROUP_REGISTRAR_URL;\n+\n+    private static final String DISPLAY_NAME_VO_MAIL_FOOTER = \"Mail Footer\";\n+    private static final String FRIENDLY_NAME_VO_MAIL_FOOTER = \"mailFooter\";\n+    private static final String NAMESPACE_VO_MAIL_FOOTER = AttributesManager.NS_VO_ATTR_DEF;\n+    static final String URN_VO_MAIL_FOOTER = NAMESPACE_VO_MAIL_FOOTER + \":\" + FRIENDLY_NAME_VO_MAIL_FOOTER;\n+\n+    private static final String DISPLAY_NAME_GROUP_MAIL_FOOTER = \"Mail Footer\";\n+    private static final String FRIENDLY_NAME_GROUP_MAIL_FOOTER = \"mailFooter\";\n+    private static final String NAMESPACE_GROUP_MAIL_FOOTER = AttributesManager.NS_GROUP_ATTR_DEF;\n+    static final String URN_GROUP_MAIL_FOOTER = NAMESPACE_GROUP_MAIL_FOOTER + \":\" + FRIENDLY_NAME_GROUP_MAIL_FOOTER;\n+\n+    private static final String MODULE_PACKAGE_PATH = \"cz.metacentrum.perun.registrar.modules.\";\n+\n+    @Autowired\n+    PerunBl perun;\n+    @Autowired\n+    MailManager mailManager;\n+    @Autowired\n+    ConsolidatorManager consolidatorManager;\n+    private RegistrarManager registrarManager;\n+    private PerunSession registrarSession;\n+    private JdbcPerunTemplate jdbc;\n+    private NamedParameterJdbcTemplate namedJdbc;\n+    private AttributesManagerBl attrManager;\n+    private MembersManagerBl membersManager;\n+    private GroupsManagerBl groupsManager;\n+    private UsersManagerBl usersManager;\n+    private VosManagerBl vosManager;\n+\n+    // federation attribute name constants\n+    private static final String shibDisplayNameVar = \"displayName\";\n+    private static final String shibCommonNameVar = \"cn\";\n+    private static final String shibFirstNameVar = \"givenName\";\n+    private static final String shibLastNameVar = \"sn\";\n+\n+    // regular expression to match alfanumeric contents\n+    private static final Pattern alnumPattern = Pattern.compile(\".*\\\\p{Alnum}+.*\", Pattern.UNICODE_CHARACTER_CLASS);\n+\n+    private final Set<String> runningCreateApplication = new HashSet<>();\n+    private final Set<Integer> runningApproveApplication = new HashSet<>();\n+    private final Set<Integer> runningRejectApplication = new HashSet<>();\n+    private final Set<Integer> runningDeleteApplication = new HashSet<>();\n+\n+    public void setDataSource(DataSource dataSource) {\n+        this.jdbc = new JdbcPerunTemplate(dataSource);\n+        this.namedJdbc = new NamedParameterJdbcTemplate(jdbc);\n+        this.jdbc.setQueryTimeout(BeansUtils.getCoreConfig().getQueryTimeout());\n+        this.namedJdbc.getJdbcTemplate().setQueryTimeout(BeansUtils.getCoreConfig().getQueryTimeout());\n+    }\n+\n+    public void setRegistrarManager(RegistrarManager registrarManager) {\n+        this.registrarManager = registrarManager;\n+    }\n+\n+    public void setConsolidatorManager(ConsolidatorManager consolidatorManager) {\n+        this.consolidatorManager = consolidatorManager;\n+    }\n+\n+    protected void initialize() throws PerunException {\n+\n+        // gets session for a system principal \"perunRegistrar\"\n+        final PerunPrincipal pp = new PerunPrincipal(\"perunRegistrar\",\n+                ExtSourcesManager.EXTSOURCE_NAME_INTERNAL,\n+                ExtSourcesManager.EXTSOURCE_INTERNAL);\n+        registrarSession = perun.getPerunSession(pp, new PerunClient());\n+\n+        // set managers\n+        this.attrManager = perun.getAttributesManagerBl();\n+        this.membersManager = perun.getMembersManagerBl();\n+        this.groupsManager = perun.getGroupsManagerBl();\n+        this.usersManager = perun.getUsersManagerBl();\n+        this.vosManager = perun.getVosManagerBl();\n+\n+        // check necessary attributes\n+        try {\n+            attrManager.getAttributeDefinition(registrarSession, URN_VO_FROM_EMAIL);\n+        } catch (AttributeNotExistsException ex) {\n+            // create attr if not exists\n+            AttributeDefinition attrDef = new AttributeDefinition();\n+            attrDef.setDisplayName(DISPLAY_NAME_VO_FROM_EMAIL);\n+            attrDef.setFriendlyName(FRIENDLY_NAME_VO_FROM_EMAIL);\n+            attrDef.setNamespace(NAMESPACE_VO_FROM_EMAIL);\n+            attrDef.setDescription(\"Email address used as \\\"from\\\" in mail notifications.\");\n+            attrDef.setType(String.class.getName());\n+            attrDef = attrManager.createAttribute(registrarSession, attrDef);\n+            // set attribute rights\n+            List<AttributeRights> rights = new ArrayList<>();\n+            rights.add(new AttributeRights(attrDef.getId(), Role.VOADMIN, Arrays.asList(ActionType.READ, ActionType.WRITE)));\n+            perun.getAttributesManager().setAttributeRights(registrarSession, rights);\n+        }\n+        try {\n+            attrManager.getAttributeDefinition(registrarSession, URN_VO_TO_EMAIL);\n+        } catch (AttributeNotExistsException ex) {\n+            // create attr if not exists\n+            AttributeDefinition attrDef = new AttributeDefinition();\n+            attrDef.setDisplayName(DISPLAY_NAME_VO_TO_EMAIL);\n+            attrDef.setFriendlyName(FRIENDLY_NAME_VO_TO_EMAIL);\n+            attrDef.setNamespace(NAMESPACE_VO_TO_EMAIL);\n+            attrDef.setDescription(\"Email addresses (of VO administrators) used as \\\"to\\\" in mail notifications.\");\n+            attrDef.setType(\"java.util.ArrayList\");\n+            attrDef = attrManager.createAttribute(registrarSession, attrDef);\n+            // set attribute rights\n+            List<AttributeRights> rights = new ArrayList<>();\n+            rights.add(new AttributeRights(attrDef.getId(), Role.VOADMIN, Arrays.asList(ActionType.READ, ActionType.WRITE)));\n+            perun.getAttributesManager().setAttributeRights(registrarSession, rights);\n+        }\n+        try {\n+            attrManager.getAttributeDefinition(registrarSession, URN_GROUP_TO_EMAIL);\n+        } catch (AttributeNotExistsException ex) {\n+            // create attr if not exists\n+            AttributeDefinition attrDef = new AttributeDefinition();\n+            attrDef.setDisplayName(DISPLAY_NAME_GROUP_TO_EMAIL);\n+            attrDef.setFriendlyName(FRIENDLY_NAME_GROUP_TO_EMAIL);\n+            attrDef.setNamespace(NAMESPACE_GROUP_TO_EMAIL);\n+            attrDef.setDescription(\"Email addresses (of Group administrators) used as \\\"to\\\" in mail notifications.\");\n+            attrDef.setType(\"java.util.ArrayList\");\n+            attrDef = attrManager.createAttribute(registrarSession, attrDef);\n+            // set attribute rights\n+            List<AttributeRights> rights = new ArrayList<>();\n+            rights.add(new AttributeRights(attrDef.getId(), Role.VOADMIN, Arrays.asList(ActionType.READ, ActionType.WRITE)));\n+            rights.add(new AttributeRights(attrDef.getId(), Role.GROUPADMIN, Arrays.asList(ActionType.READ, ActionType.WRITE)));\n+            perun.getAttributesManager().setAttributeRights(registrarSession, rights);\n+        }\n+        try {\n+            attrManager.getAttributeDefinition(registrarSession, URN_GROUP_FROM_EMAIL);\n+        } catch (AttributeNotExistsException ex) {\n+            // create attr if not exists\n+            AttributeDefinition attrDef = new AttributeDefinition();\n+            attrDef.setDisplayName(DISPLAY_NAME_GROUP_FROM_EMAIL);\n+            attrDef.setFriendlyName(FRIENDLY_NAME_GROUP_FROM_EMAIL);\n+            attrDef.setNamespace(NAMESPACE_GROUP_FROM_EMAIL);\n+            attrDef.setDescription(\"Email address used as \\\"from\\\" in mail notifications.\");\n+            attrDef.setType(String.class.getName());\n+            attrDef = attrManager.createAttribute(registrarSession, attrDef);\n+            // set attribute rights\n+            List<AttributeRights> rights = new ArrayList<>();\n+            rights.add(new AttributeRights(attrDef.getId(), Role.VOADMIN, Arrays.asList(ActionType.READ, ActionType.WRITE)));\n+            rights.add(new AttributeRights(attrDef.getId(), Role.GROUPADMIN, Arrays.asList(ActionType.READ, ActionType.WRITE)));\n+            perun.getAttributesManager().setAttributeRights(registrarSession, rights);\n+        }\n+        try {\n+            attrManager.getAttributeDefinition(registrarSession, URN_GROUP_FROM_NAME_EMAIL);\n+        } catch (AttributeNotExistsException ex) {\n+            // create attr if not exists\n+            AttributeDefinition attrDef = new AttributeDefinition();\n+            attrDef.setDisplayName(DISPLAY_NAME_GROUP_FROM_NAME_EMAIL);\n+            attrDef.setFriendlyName(FRIENDLY_NAME_GROUP_FROM_NAME_EMAIL);\n+            attrDef.setNamespace(NAMESPACE_GROUP_FROM_NAME_EMAIL);\n+            attrDef.setDescription(\"Name of the sender used as \\\"from\\\" in mail notifications.\");\n+            attrDef.setType(String.class.getName());\n+            attrDef = attrManager.createAttribute(registrarSession, attrDef);\n+            // set attribute rights\n+            List<AttributeRights> rights = new ArrayList<>();\n+            rights.add(new AttributeRights(attrDef.getId(), Role.VOADMIN, Arrays.asList(ActionType.READ, ActionType.WRITE)));\n+            rights.add(new AttributeRights(attrDef.getId(), Role.GROUPADMIN, Arrays.asList(ActionType.READ, ActionType.WRITE)));\n+            perun.getAttributesManager().setAttributeRights(registrarSession, rights);\n+        }\n+        try {\n+            attrManager.getAttributeDefinition(registrarSession, URN_VO_FROM_NAME_EMAIL);\n+        } catch (AttributeNotExistsException ex) {\n+            // create attr if not exists\n+            AttributeDefinition attrDef = new AttributeDefinition();\n+            attrDef.setDisplayName(DISPLAY_NAME_VO_FROM_NAME_EMAIL);\n+            attrDef.setFriendlyName(FRIENDLY_NAME_VO_FROM_NAME_EMAIL);\n+            attrDef.setNamespace(NAMESPACE_VO_FROM_NAME_EMAIL);\n+            attrDef.setDescription(\"Name of the sender used as \\\"from\\\" in mail notifications.\");\n+            attrDef.setType(String.class.getName());\n+            attrDef = attrManager.createAttribute(registrarSession, attrDef);\n+            // set attribute rights\n+            List<AttributeRights> rights = new ArrayList<>();\n+            rights.add(new AttributeRights(attrDef.getId(), Role.VOADMIN, Arrays.asList(ActionType.READ, ActionType.WRITE)));\n+            perun.getAttributesManager().setAttributeRights(registrarSession, rights);\n+        }\n+        try {\n+            attrManager.getAttributeDefinition(registrarSession, URN_VO_LANGUAGE_EMAIL);\n+        } catch (AttributeNotExistsException ex) {\n+            // create attr if not exists\n+            AttributeDefinition attrDef = new AttributeDefinition();\n+            attrDef.setDisplayName(DISPLAY_NAME_VO_LANGUAGE_EMAIL);\n+            attrDef.setFriendlyName(FRIENDLY_NAME_VO_LANGUAGE_EMAIL);\n+            attrDef.setNamespace(NAMESPACE_VO_LANGUAGE_EMAIL);\n+            attrDef.setDescription(\"Default language used for application notifications to VO administrators.\");\n+            attrDef.setType(String.class.getName());\n+            attrDef = attrManager.createAttribute(registrarSession, attrDef);\n+            // set attribute rights\n+            List<AttributeRights> rights = new ArrayList<>();\n+            rights.add(new AttributeRights(attrDef.getId(), Role.VOADMIN, Arrays.asList(ActionType.READ, ActionType.WRITE)));\n+            perun.getAttributesManager().setAttributeRights(registrarSession, rights);\n+        }\n+        try {\n+            attrManager.getAttributeDefinition(registrarSession, URN_GROUP_LANGUAGE_EMAIL);\n+        } catch (AttributeNotExistsException ex) {\n+            // create attr if not exists\n+            AttributeDefinition attrDef = new AttributeDefinition();\n+            attrDef.setDisplayName(DISPLAY_NAME_GROUP_LANGUAGE_EMAIL);\n+            attrDef.setFriendlyName(FRIENDLY_NAME_GROUP_LANGUAGE_EMAIL);\n+            attrDef.setNamespace(NAMESPACE_GROUP_LANGUAGE_EMAIL);\n+            attrDef.setDescription(\"Default language used for application notifications to Group administrators.\");\n+            attrDef.setType(String.class.getName());\n+            attrDef = attrManager.createAttribute(registrarSession, attrDef);\n+            // set attribute rights\n+            List<AttributeRights> rights = new ArrayList<>();\n+            rights.add(new AttributeRights(attrDef.getId(), Role.VOADMIN, Arrays.asList(ActionType.READ, ActionType.WRITE)));\n+            rights.add(new AttributeRights(attrDef.getId(), Role.GROUPADMIN, Arrays.asList(ActionType.READ, ActionType.WRITE)));\n+            perun.getAttributesManager().setAttributeRights(registrarSession, rights);\n+        }\n+        try {\n+            attrManager.getAttributeDefinition(registrarSession, URN_VO_APPLICATION_URL);\n+        } catch (AttributeNotExistsException ex) {\n+            // create attr if not exists\n+            AttributeDefinition attrDef = new AttributeDefinition();\n+            attrDef.setDisplayName(DISPLAY_NAME_VO_APPLICATION_URL);\n+            attrDef.setFriendlyName(FRIENDLY_NAME_VO_APPLICATION_URL);\n+            attrDef.setNamespace(NAMESPACE_VO_APPLICATION_URL);\n+            attrDef.setDescription(\"Custom link to VO's application form used in e-mail invitations.\");\n+            attrDef.setType(String.class.getName());\n+            attrDef = attrManager.createAttribute(registrarSession, attrDef);\n+            // set attribute rights\n+            List<AttributeRights> rights = new ArrayList<>();\n+            rights.add(new AttributeRights(attrDef.getId(), Role.VOADMIN, Arrays.asList(ActionType.READ, ActionType.WRITE)));\n+            perun.getAttributesManager().setAttributeRights(registrarSession, rights);\n+        }\n+        try {\n+            attrManager.getAttributeDefinition(registrarSession, URN_GROUP_APPLICATION_URL);\n+        } catch (AttributeNotExistsException ex) {\n+            // create attr if not exists\n+            AttributeDefinition attrDef = new AttributeDefinition();\n+            attrDef.setDisplayName(DISPLAY_NAME_GROUP_APPLICATION_URL);\n+            attrDef.setFriendlyName(FRIENDLY_NAME_GROUP_APPLICATION_URL);\n+            attrDef.setNamespace(NAMESPACE_GROUP_APPLICATION_URL);\n+            attrDef.setDescription(\"Custom link to group's application form used in e-mail invitations.\");\n+            attrDef.setType(String.class.getName());\n+            attrDef = attrManager.createAttribute(registrarSession, attrDef);\n+            // set attribute rights\n+            List<AttributeRights> rights = new ArrayList<>();\n+            rights.add(new AttributeRights(attrDef.getId(), Role.VOADMIN, Arrays.asList(ActionType.READ, ActionType.WRITE)));\n+            rights.add(new AttributeRights(attrDef.getId(), Role.GROUPADMIN, Arrays.asList(ActionType.READ, ActionType.WRITE)));\n+            perun.getAttributesManager().setAttributeRights(registrarSession, rights);\n+        }\n+        try {\n+            attrManager.getAttributeDefinition(registrarSession, URN_VO_REGISTRAR_URL);\n+        } catch (AttributeNotExistsException ex) {\n+            // create attr if not exists\n+            AttributeDefinition attrDef = new AttributeDefinition();\n+            attrDef.setDisplayName(DISPLAY_NAME_VO_REGISTRAR_URL);\n+            attrDef.setFriendlyName(FRIENDLY_NAME_VO_REGISTRAR_URL);\n+            attrDef.setNamespace(NAMESPACE_VO_REGISTRAR_URL);\n+            attrDef.setDescription(\"Custom URL used in registration notifications (hostname without any parameters like: https://hostname.domain/). If not set, default hostname of Perun instance is used.\");\n+            attrDef.setType(String.class.getName());\n+            attrDef = attrManager.createAttribute(registrarSession, attrDef);\n+            // set attribute rights\n+            List<AttributeRights> rights = new ArrayList<>();\n+            rights.add(new AttributeRights(attrDef.getId(), Role.VOADMIN, Arrays.asList(ActionType.READ, ActionType.WRITE)));\n+            perun.getAttributesManager().setAttributeRights(registrarSession, rights);\n+        }\n+        try {\n+            attrManager.getAttributeDefinition(registrarSession, URN_GROUP_REGISTRAR_URL);\n+        } catch (AttributeNotExistsException ex) {\n+            // create attr if not exists\n+            AttributeDefinition attrDef = new AttributeDefinition();\n+            attrDef.setDisplayName(DISPLAY_NAME_GROUP_REGISTRAR_URL);\n+            attrDef.setFriendlyName(FRIENDLY_NAME_GROUP_REGISTRAR_URL);\n+            attrDef.setNamespace(NAMESPACE_GROUP_REGISTRAR_URL);\n+            attrDef.setDescription(\"Custom URL used in registration notifications (hostname without any parameters like: https://hostname.domain/). This value override same VO setting. If not set, default hostname of Perun instance is used.\");\n+            attrDef.setType(String.class.getName());\n+            attrDef = attrManager.createAttribute(registrarSession, attrDef);\n+            // set attribute rights\n+            List<AttributeRights> rights = new ArrayList<>();\n+            rights.add(new AttributeRights(attrDef.getId(), Role.VOADMIN, Arrays.asList(ActionType.READ, ActionType.WRITE)));\n+            rights.add(new AttributeRights(attrDef.getId(), Role.GROUPADMIN, Arrays.asList(ActionType.READ, ActionType.WRITE)));\n+            perun.getAttributesManager().setAttributeRights(registrarSession, rights);\n+        }\n+        try {\n+            attrManager.getAttributeDefinition(registrarSession, URN_VO_MAIL_FOOTER);\n+        } catch (AttributeNotExistsException ex) {\n+            // create attr if not exists\n+            AttributeDefinition attrDef = new AttributeDefinition();\n+            attrDef.setDisplayName(DISPLAY_NAME_VO_MAIL_FOOTER);\n+            attrDef.setFriendlyName(FRIENDLY_NAME_VO_MAIL_FOOTER);\n+            attrDef.setNamespace(NAMESPACE_VO_MAIL_FOOTER);\n+            attrDef.setDescription(\"Email footer used in mail notifications by tag {mailFooter}. To edit text whithout loose of formatting, please use notification's GUI!!\");\n+            attrDef.setType(String.class.getName());\n+            attrDef = attrManager.createAttribute(registrarSession, attrDef);\n+            // set attribute rights\n+            List<AttributeRights> rights = new ArrayList<>();\n+            rights.add(new AttributeRights(attrDef.getId(), Role.VOADMIN, Arrays.asList(ActionType.READ, ActionType.WRITE)));\n+            perun.getAttributesManager().setAttributeRights(registrarSession, rights);\n+        }\n+        try {\n+            attrManager.getAttributeDefinition(registrarSession, URN_GROUP_MAIL_FOOTER);\n+        } catch (AttributeNotExistsException ex) {\n+            // create attr if not exists\n+            AttributeDefinition attrDef = new AttributeDefinition();\n+            attrDef.setDisplayName(DISPLAY_NAME_GROUP_MAIL_FOOTER);\n+            attrDef.setFriendlyName(FRIENDLY_NAME_GROUP_MAIL_FOOTER);\n+            attrDef.setNamespace(NAMESPACE_GROUP_MAIL_FOOTER);\n+            attrDef.setDescription(\"Email footer used in mail notifications by tag {mailFooter}. To edit text whithout loose of formatting, please use notification's GUI!!\");\n+            attrDef.setType(String.class.getName());\n+            attrDef = attrManager.createAttribute(registrarSession, attrDef);\n+            // set attribute rights\n+            List<AttributeRights> rights = new ArrayList<>();\n+            rights.add(new AttributeRights(attrDef.getId(), Role.VOADMIN, Arrays.asList(ActionType.READ, ActionType.WRITE)));\n+            rights.add(new AttributeRights(attrDef.getId(), Role.GROUPADMIN, Arrays.asList(ActionType.READ, ActionType.WRITE)));\n+            perun.getAttributesManager().setAttributeRights(registrarSession, rights);\n+        }\n+        try {\n+            attrManager.getAttributeDefinition(registrarSession, \"urn:perun:vo:attribute-def:def:voLogoURL\");\n+        } catch (AttributeNotExistsException ex) {\n+            // create attr if not exists\n+            AttributeDefinition attrDef = new AttributeDefinition();\n+            attrDef.setDisplayName(\"VO logo's URL\");\n+            attrDef.setFriendlyName(\"voLogoURL\");\n+            attrDef.setNamespace(\"urn:perun:vo:attribute-def:def\");\n+            attrDef.setDescription(\"Full URL of the VO's logo image (including https://) or base64 encoded data like: 'data:image/png;base64,....'\");\n+            attrDef.setType(BeansUtils.largeStringClassName);\n+            attrDef = attrManager.createAttribute(registrarSession, attrDef);\n+            // set attribute rights\n+            List<AttributeRights> rights = new ArrayList<>();\n+            rights.add(new AttributeRights(attrDef.getId(), Role.VOADMIN, Arrays.asList(ActionType.READ, ActionType.WRITE)));\n+            perun.getAttributesManager().setAttributeRights(registrarSession, rights);\n+        }\n+    }\n+\n+    @Override\n+    public List<Attribute> initialize(String voShortName, String groupName) throws PerunException {\n+\n+        Vo vo = vosManager.getVoByShortName(registrarSession, voShortName);\n+        List<Attribute> list = attrManager.getAttributes(registrarSession, vo);\n+        // load group info if needed\n+        if (groupName != null && !groupName.isEmpty()) {\n+            Group group = groupsManager.getGroupByName(registrarSession, vo, groupName);\n+            list.addAll(attrManager.getAttributes(registrarSession, group));\n+        }\n+        return list;\n+\n+    }\n+\n+    @Override\n+    public Map<String, Object> initRegistrar(PerunSession sess, String voShortName, String groupName) throws PerunException {\n+\n+        Map<String, Object> result = new HashMap<>();\n+        Vo vo;\n+        Group group;\n+\n+        try {\n+\n+            // GET VO\n+            vo = vosManager.getVoByShortName(sess, voShortName);\n+            List<Attribute> list = attrManager.getAttributes(sess, vo,\n+                    Arrays.asList(AttributesManager.NS_VO_ATTR_DEF + \":contactEmail\",\n+                            AttributesManager.NS_VO_ATTR_DEF + \":voLogoURL\"));\n+\n+            result.put(\"vo\", vo);\n+            result.put(\"voAttributes\", list);\n+            result.put(\"voForm\", getFormForVo(vo));\n+\n+            // GET INITIAL APPLICATION IF POSSIBLE\n+            try {\n+\n+                result.put(\"voFormInitial\", getFormItemsWithPrefilledValues(sess, AppType.INITIAL, (ApplicationForm) result.get(\"voForm\")));\n+\n+            } catch (DuplicateRegistrationAttemptException ex) {\n+                // has submitted application\n+                result.put(\"voFormInitialException\", ex);\n+            } catch (AlreadyRegisteredException ex) {\n+                // is already member of VO\n+                result.put(\"voFormInitialException\", ex);\n+            } catch (ExtendMembershipException ex) {\n+                // can't become member of VO\n+                result.put(\"voFormInitialException\", ex);\n+            } catch (MissingRequiredDataException ex) {\n+                // can't display form\n+                result.put(\"voFormInitialException\", ex);\n+            } catch (CantBeSubmittedException ex) {\n+                // can't display form / become member by some custom rules\n+                result.put(\"voFormInitialException\", ex);\n+            }\n+\n+            // ONLY EXISTING USERS CAN EXTEND VO MEMBERSHIP\n+            if (sess.getPerunPrincipal().getUser() != null) {\n+\n+                try {\n+                    result.put(\"voFormExtension\", getFormItemsWithPrefilledValues(sess, AppType.EXTENSION, (ApplicationForm) result.get(\"voForm\")));\n+                } catch (DuplicateRegistrationAttemptException ex) {\n+                    // has submitted application\n+                    result.put(\"voFormExtensionException\", ex);\n+                } catch (RegistrarException ex) {\n+                    // more severe exception like bad input/inconsistency\n+                    result.put(\"voFormExtensionException\", ex);\n+                } catch (ExtendMembershipException ex) {\n+                    // can't extend membership in VO\n+                    result.put(\"voFormExtensionException\", ex);\n+                } catch (MemberNotExistsException ex) {\n+                    // is not member -> can't extend\n+                    result.put(\"voFormExtensionException\", ex);\n+                } catch (MissingRequiredDataException ex) {\n+                    // can't display form\n+                    result.put(\"voFormExtensionException\", ex);\n+                } catch (CantBeSubmittedException ex) {\n+                    // can't display form / extend membership by some custom rules\n+                    result.put(\"voFormExtensionException\", ex);\n+                }\n+\n+            }\n+\n+            // GET GROUP IF RELEVANT\n+            if (groupName != null && !groupName.isEmpty()) {\n+\n+                group = groupsManager.getGroupByName(sess, vo, groupName);\n+                result.put(\"group\", group);\n+                result.put(\"groupForm\", getFormForGroup(group));\n+\n+                try {\n+                    result.put(\"groupFormInitial\", getFormItemsWithPrefilledValues(sess, AppType.INITIAL, (ApplicationForm) result.get(\"groupForm\")));\n+                } catch (DuplicateRegistrationAttemptException ex) {\n+                    // has submitted application\n+                    result.put(\"groupFormInitialException\", ex);\n+                } catch (AlreadyRegisteredException ex) {\n+                    // is already member of group\n+                    result.put(\"groupFormInitialException\", ex);\n+                } catch (RegistrarException ex) {\n+                    // more severe exception like bad input/inconsistency\n+                    result.put(\"groupFormInitialException\", ex);\n+                } catch (ExtendMembershipException ex) {\n+                    // can't become member of VO -> then can't be member of group either\n+                    result.put(\"groupFormInitialException\", ex);\n+                } catch (MissingRequiredDataException ex) {\n+                    // can't display form\n+                    result.put(\"groupFormInitialException\", ex);\n+                } catch (CantBeSubmittedException ex) {\n+                    // can't display form / become member by some custom rules\n+                    result.put(\"groupFormInitialException\", ex);\n+                }\n+\n+            }\n+\n+            // ONLY EXISTING USERS CAN EXTEND GROUP MEMBERSHIP\n+            if (sess.getPerunPrincipal().getUser() != null && groupName != null && !groupName.isEmpty()) {\n+\n+                try {\n+                    result.put(\"groupFormExtension\", getFormItemsWithPrefilledValues(sess, AppType.EXTENSION, (ApplicationForm) result.get(\"groupForm\")));\n+                } catch (DuplicateRegistrationAttemptException ex) {\n+                    // has submitted application\n+                    result.put(\"groupFormExtensionException\", ex);\n+                } catch (RegistrarException ex) {\n+                    // more severe exception like bad input/inconsistency\n+                    result.put(\"groupFormExtensionException\", ex);\n+                } catch (ExtendMembershipException ex) {\n+                    // can't extend membership in Group\n+                    result.put(\"groupFormExtensionException\", ex);\n+                } catch (MemberNotExistsException ex) {\n+                    // is not member -> can't extend\n+                    result.put(\"groupFormExtensionException\", ex);\n+                } catch (NotGroupMemberException ex) {\n+                    // is not member of Group -> can't extend\n+                    result.put(\"groupFormExtensionException\", ex);\n+                } catch (MissingRequiredDataException ex) {\n+                    // can't display form\n+                    result.put(\"groupFormExtensionException\", ex);\n+                } catch (CantBeSubmittedException ex) {\n+                    // can't display form / extend membership by some custom rules\n+                    result.put(\"groupFormExtensionException\", ex);\n+                }\n+\n+            }\n+\n+            // FIND SIMILAR USERS\n+            try {\n+                List<Identity> similarUsers = getConsolidatorManager().checkForSimilarUsers(sess);\n+                if (similarUsers != null && !similarUsers.isEmpty()) {\n+                    log.debug(\"Similar users found for {} / {}: {}\", sess.getPerunPrincipal().getActor(), sess.getPerunPrincipal().getExtSourceName(), similarUsers);\n+                }\n+                result.put(\"similarUsers\", similarUsers);\n+            } catch (Exception ex) {\n+                // not relevant exception in this use-case\n+                log.error(\"[REGISTRAR] Exception when searching for similar users.\", ex);\n+            }\n+\n+        } catch (Exception ex) {\n+\n+            // we don't have to try any more, return exception\n+            result.put(\"exception\", ex);\n+            return result;\n+\n+        }\n+\n+        return result;\n+\n+    }\n+\n+    @Override\n+    public void createApplicationFormInVo(PerunSession sess, Vo vo) throws PrivilegeException, VoNotExistsException {\n+        vosManager.checkVoExists(sess, vo);\n+\n+        //Authorization\n+        if (!AuthzResolver.authorizedInternal(sess, \"createApplicationFormInVo_Vo_policy\", Collections.singletonList(vo))) {\n+            throw new PrivilegeException(sess, \"createApplicationFormInVo\");\n+        }\n+\n+        int id = Utils.getNewId(jdbc, \"APPLICATION_FORM_ID_SEQ\");\n+        try {\n+            jdbc.update(\"insert into application_form(id, vo_id) values (?,?)\", id, vo.getId());\n+        } catch (DuplicateKeyException ex) {\n+            throw new ConsistencyErrorException(\"VO can have defined only one application form. Can't insert another.\", ex);\n+        }\n+\n+    }\n+\n+    @Override\n+    public void createApplicationFormInGroup(PerunSession sess, Group group) throws PrivilegeException, GroupNotExistsException {\n+        groupsManager.checkGroupExists(sess, group);\n+\n+        //Authorization\n+        if (!AuthzResolver.authorizedInternal(sess, \"createApplicationFormInGroup_Group_policy\", Collections.singletonList(group))) {\n+            throw new PrivilegeException(sess, \"createApplicationFormInGroup\");\n+        }\n+\n+        int id = Utils.getNewId(jdbc, \"APPLICATION_FORM_ID_SEQ\");\n+        try {\n+            jdbc.update(\"insert into application_form(id, vo_id, group_id) values (?,?,?)\", id, group.getVoId(), group.getId());\n+        } catch (DuplicateKeyException ex) {\n+            throw new ConsistencyErrorException(\"Group can have defined only one application form. Can't insert another.\", ex);\n+        }\n+\n+    }\n+\n+    @Override\n+    public ApplicationForm getFormForVo(final Vo vo) throws FormNotExistsException {\n+\n+        if (vo == null) {\n+            throw new FormNotExistsException(\"VO can't be null\");\n+        }\n+\n+        try {\n+            return jdbc.queryForObject(FORM_SELECT + \" where vo_id=? and group_id is null\", (resultSet, arg1) -> {\n+                ApplicationForm form = new ApplicationForm();\n+                form.setId(resultSet.getInt(\"id\"));\n+                form.setAutomaticApproval(resultSet.getBoolean(\"automatic_approval\"));\n+                form.setAutomaticApprovalExtension(resultSet.getBoolean(\"automatic_approval_extension\"));\n+                form.setModuleClassName(resultSet.getString(\"module_name\"));\n+                form.setVo(vo);\n+                return form;\n+            }, vo.getId());\n+        } catch (EmptyResultDataAccessException ex) {\n+            throw new FormNotExistsException(\"Form for VO: \" + vo.getName() + \" doesn't exists.\");\n+        } catch (Exception ex) {\n+            throw new InternalErrorException(ex.getMessage(), ex);\n+        }\n+\n+    }\n+\n+    @Override\n+    public ApplicationForm getFormForGroup(final Group group) throws FormNotExistsException {\n+\n+        if (group == null) {\n+            throw new FormNotExistsException(\"Group can't be null\");\n+        }\n+\n+        try {\n+            return jdbc.queryForObject(FORM_SELECT + \" where vo_id=? and group_id=?\", (resultSet, arg1) -> {\n+                ApplicationForm form = new ApplicationForm();\n+                form.setId(resultSet.getInt(\"id\"));\n+                form.setAutomaticApproval(resultSet.getBoolean(\"automatic_approval\"));\n+                form.setAutomaticApprovalExtension(resultSet.getBoolean(\"automatic_approval_extension\"));\n+                form.setModuleClassName(resultSet.getString(\"module_name\"));\n+                form.setGroup(group);\n+                try {\n+                    form.setVo(vosManager.getVoById(registrarSession, group.getVoId()));\n+                } catch (Exception ex) {\n+                    // we don't care, shouldn't happen for internal identity.\n+                }\n+                return form;\n+            }, group.getVoId(), group.getId());\n+        } catch (EmptyResultDataAccessException ex) {\n+            throw new FormNotExistsException(\"Form for Group: \" + group.getName() + \" doesn't exists.\");\n+        } catch (Exception ex) {\n+            throw new InternalErrorException(ex.getMessage(), ex);\n+        }\n+\n+    }\n+\n+    @Override\n+    public ApplicationForm getFormById(PerunSession sess, int id) throws PrivilegeException, FormNotExistsException {\n+\n+        try {\n+            ApplicationForm form = jdbc.queryForObject(FORM_SELECT + \" where id=?\", (resultSet, arg1) -> {\n+                ApplicationForm form1 = new ApplicationForm();\n+                form1.setId(resultSet.getInt(\"id\"));\n+                form1.setAutomaticApproval(resultSet.getBoolean(\"automatic_approval\"));\n+                form1.setAutomaticApprovalExtension(resultSet.getBoolean(\"automatic_approval_extension\"));\n+                form1.setModuleClassName(resultSet.getString(\"module_name\"));\n+                try {\n+                    form1.setVo(vosManager.getVoById(sess, resultSet.getInt(\"vo_id\")));\n+                } catch (Exception ex) {\n+                    // we don't care, shouldn't happen for internal identity.\n+                }\n+                try {\n+                    if (resultSet.getInt(\"group_id\") != 0) {\n+                        form1.setGroup(groupsManager.getGroupById(sess, resultSet.getInt(\"group_id\")));\n+                    }\n+                } catch (Exception ex) {\n+                    // we don't care, shouldn't happen for internal identity.\n+                }\n+                return form1;\n+            }, id);\n+\n+            if (form == null) {\n+                throw new FormNotExistsException(\"Form with ID: \" + id + \" doesn't exists.\");\n+            }\n+\n+            //Authorization\n+            if (Objects.isNull(form.getGroup())) {\n+                // VO application\n+                if (!AuthzResolver.authorizedInternal(sess, \"vo-getFormById_int_policy\", Collections.singletonList(form.getVo()))) {\n+                    throw new PrivilegeException(sess, \"getFormById\");\n+                }\n+            } else {\n+                if (!AuthzResolver.authorizedInternal(sess, \"group-getFormById_int_policy\", Arrays.asList(form.getVo(), form.getGroup()))) {\n+                    throw new PrivilegeException(sess, \"getFormById\");\n+                }\n+            }\n+\n+            return form;\n+\n+        } catch (EmptyResultDataAccessException ex) {\n+            throw new FormNotExistsException(\"Form with ID: \" + id + \" doesn't exists.\");\n+        }\n+\n+    }\n+\n+    @Override\n+    public ApplicationForm getFormByItemId(PerunSession sess, int id) throws PrivilegeException, FormNotExistsException {\n+\n+        try {\n+            ApplicationForm form = jdbc.queryForObject(FORM_SELECT + \" where id=(select form_id from application_form_items where id=?)\", (resultSet, arg1) -> {\n+                ApplicationForm form1 = new ApplicationForm();\n+                form1.setId(resultSet.getInt(\"id\"));\n+                form1.setAutomaticApproval(resultSet.getBoolean(\"automatic_approval\"));\n+                form1.setAutomaticApprovalExtension(resultSet.getBoolean(\"automatic_approval_extension\"));\n+                form1.setModuleClassName(resultSet.getString(\"module_name\"));\n+                try {\n+                    form1.setVo(vosManager.getVoById(sess, resultSet.getInt(\"vo_id\")));\n+                } catch (Exception ex) {\n+                    // we don't care, shouldn't happen for internal identity.\n+                }\n+                try {\n+                    if (resultSet.getInt(\"group_id\") != 0) {\n+                        form1.setGroup(groupsManager.getGroupById(sess, resultSet.getInt(\"group_id\")));\n+                    }\n+                } catch (Exception ex) {\n+                    // we don't care, shouldn't happen for internal identity.\n+                }\n+                return form1;\n+            }, id);\n+\n+            if (Objects.isNull(form)) {\n+                throw new FormNotExistsException(\"Form with ID: \" + id + \" doesn't exists.\");\n+            }\n+\n+            //Authorization\n+            if (form.getGroup() == null) {\n+                // VO application\n+                if (!AuthzResolver.authorizedInternal(sess, \"vo-getFormByItemId_int_policy\", Collections.singletonList(form.getVo()))) {\n+                    throw new PrivilegeException(sess, \"getFormByItemId\");\n+                }\n+            } else {\n+                if (!AuthzResolver.authorizedInternal(sess, \"group-getFormByItemId_int_policy\", Arrays.asList(form.getVo(), form.getGroup()))) {\n+                    throw new PrivilegeException(sess, \"getFormByItemId\");\n+                }\n+            }\n+\n+            return form;\n+\n+        } catch (EmptyResultDataAccessException ex) {\n+            throw new FormNotExistsException(\"Form with ID: \" + id + \" doesn't exists.\");\n+        }\n+\n+    }\n+\n+    @Transactional\n+    @Override\n+    public ApplicationFormItem addFormItem(PerunSession user, ApplicationForm form, ApplicationFormItem item) throws PrivilegeException {\n+\n+        //Authorization\n+        if (form.getGroup() == null) {\n+            // VO application\n+            if (!AuthzResolver.authorizedInternal(user, \"vo-addFormItem_ApplicationForm_ApplicationFormItem_policy\", Collections.singletonList(form.getVo()))) {\n+                throw new PrivilegeException(user, \"addFormItem\");\n+            }\n+        } else {\n+            if (!AuthzResolver.authorizedInternal(user, \"group-addFormItem_ApplicationForm_ApplicationFormItem_policy\", Arrays.asList(form.getVo(), form.getGroup()))) {\n+                throw new PrivilegeException(user, \"addFormItem\");\n+            }\n+        }\n+\n+        // find the ordinal number of the next item\n+        int ordnum = 0;\n+        if (item.getOrdnum() == null || item.getOrdnum() < 0) {\n+            if (jdbc.queryForInt(\"select count(*) from application_form_items where form_id=?\", form.getId()) > 0) {\n+                ordnum = jdbc.queryForInt(\"select max(ordnum)+1 from application_form_items where form_id=?\", form.getId());\n+            }\n+        } else {\n+            // use predefined ordnum\n+            ordnum = item.getOrdnum();\n+        }\n+\n+        int itemId = Utils.getNewId(jdbc, \"APPLICATION_FORM_ITEMS_ID_SEQ\");\n+        jdbc.update(\n+                \"insert into application_form_items(id,form_id,ordnum,shortname,required,type,fed_attr,src_attr,dst_attr,regex) values (?,?,?,?,?,?,?,?,?,?)\",\n+                itemId, form.getId(), ordnum, item.getShortname(), item.isRequired(),\n+                item.getType().name(), item.getFederationAttribute(),\n+                item.getPerunSourceAttribute(), item.getPerunDestinationAttribute(), item.getRegex());\n+\n+        // create texts\n+        for (Locale locale : item.getI18n().keySet()) {\n+            ItemTexts itemTexts = item.getTexts(locale);\n+            jdbc.update(\"insert into application_form_item_texts(item_id,locale,label,options,help,error_message) values (?,?,?,?,?,?)\",\n+                    itemId, locale.getLanguage(), itemTexts.getLabel(),\n+                    itemTexts.getOptions(), itemTexts.getHelp(),\n+                    itemTexts.getErrorMessage());\n+        }\n+        for (AppType appType : item.getApplicationTypes()) {\n+            jdbc.update(\"insert into application_form_item_apptypes (item_id,apptype) values (?,?)\",\n+                    itemId, appType.toString());\n+        }\n+\n+        // set new properties back to object & return\n+        item.setOrdnum(ordnum);\n+        item.setId(itemId);\n+        perun.getAuditer().log(user, new FormItemAdded(form));\n+        return item;\n+\n+    }\n+\n+    @Override\n+    @Transactional(rollbackFor = Exception.class)\n+    public int updateFormItems(PerunSession sess, ApplicationForm form, List<ApplicationFormItem> items) throws PrivilegeException {\n+\n+        //Authorization\n+        if (form.getGroup() == null) {\n+            // VO application\n+            if (!AuthzResolver.authorizedInternal(sess, \"vo-updateFormItems_ApplicationForm_List<ApplicationFormItem>_policy\", Collections.singletonList(form.getVo()))) {\n+                throw new PrivilegeException(sess, \"updateFormItems\");\n+            }\n+        } else {\n+            if (!AuthzResolver.authorizedInternal(sess, \"group-updateFormItems_ApplicationForm_List<ApplicationFormItem>_policy\", Arrays.asList(form.getVo(), form.getGroup()))) {\n+                throw new PrivilegeException(sess, \"updateFormItems\");\n+            }\n+        }\n+\n+        if (items == null) {\n+            throw new NullPointerException(\"ApplicationFormItems to update can't be null\");\n+        }\n+        int finalResult = 0;\n+        for (ApplicationFormItem item : items) {\n+\n+            // is item to create ? => create\n+            if (item.getId() == 0 && !item.isForDelete()) {\n+                if (addFormItem(sess, form, item) != null) {\n+                    finalResult++;\n+                }\n+                continue;\n+            }\n+\n+            // is item for deletion ? => delete on cascade\n+            if (item.isForDelete()) {\n+                finalResult += jdbc.update(\"delete from application_form_items where id=?\", item.getId());\n+                continue; // continue to next item\n+            }\n+\n+            // else update form item\n+\n+            int result = jdbc.update(\"update application_form_items set ordnum=?,shortname=?,required=?,type=?,fed_attr=?,src_attr=?,dst_attr=?,regex=? where id=?\",\n+                    item.getOrdnum(), item.getShortname(), item.isRequired(),\n+                    item.getType().toString(), item.getFederationAttribute(),\n+                    item.getPerunSourceAttribute(), item.getPerunDestinationAttribute(),\n+                    item.getRegex(), item.getId());\n+            finalResult += result;\n+            if (result == 0) {\n+                // skip whole set if not found for update\n+                continue;\n+            }\n+\n+            // update form item texts (easy way = delete and new insert)\n+\n+            // delete\n+            jdbc.update(\"delete from application_form_item_texts where item_id=?\", item.getId());\n+            // insert new\n+            for (Locale locale : item.getI18n().keySet()) {\n+                ItemTexts itemTexts = item.getTexts(locale);\n+                jdbc.update(\"insert into application_form_item_texts(item_id,locale,label,options,help,error_message) values (?,?,?,?,?,?)\",\n+                        item.getId(), locale.getLanguage(), itemTexts.getLabel(),\n+                        itemTexts.getOptions(), itemTexts.getHelp(),\n+                        itemTexts.getErrorMessage());\n+            }\n+\n+            // update form item app types (easy way = delete and new insert)\n+\n+            // delete\n+            jdbc.update(\"delete from application_form_item_apptypes where item_id=?\", item.getId());\n+            // insert new\n+            for (AppType appType : item.getApplicationTypes()) {\n+                jdbc.update(\"insert into application_form_item_apptypes (item_id,apptype) values (?,?)\",\n+                        item.getId(), appType.toString());\n+            }\n+        }\n+\n+        perun.getAuditer().log(sess, new FormItemsUpdated(form));\n+        // return number of updated rows\n+        return finalResult;\n+\n+    }\n+\n+    @Override\n+    public int updateForm(PerunSession user, ApplicationForm form) throws PrivilegeException {\n+\n+        //Authorization\n+        if (form.getGroup() == null) {\n+            // VO application\n+            if (!AuthzResolver.authorizedInternal(user, \"vo-updateForm_ApplicationForm_policy\", Collections.singletonList(form.getVo()))) {\n+                throw new PrivilegeException(user, \"updateForm\");\n+            }\n+        } else {\n+            if (!AuthzResolver.authorizedInternal(user, \"group-updateForm_ApplicationForm_policy\", Arrays.asList(form.getVo(), form.getGroup()))) {\n+                throw new PrivilegeException(user, \"updateForm\");\n+            }\n+        }\n+\n+        perun.getAuditer().log(user, new FormUpdated((form)));\n+        return jdbc.update(\n+                \"update application_form set automatic_approval=?, automatic_approval_extension=?, module_name=? where id=?\",\n+                form.isAutomaticApproval(), form.isAutomaticApprovalExtension(), form.getModuleClassName(), form.getId());\n+    }\n+\n+    @Transactional\n+    @Override\n+    public void deleteFormItem(PerunSession user, ApplicationForm form, int ordnum) throws PrivilegeException {\n+\n+        //Authorization\n+        if (!AuthzResolver.authorizedInternal(user, \"deleteFormItem_ApplicationForm_int_policy\", Collections.singletonList(form.getVo()))) {\n+            throw new PrivilegeException(user, \"deleteFormItem\");\n+        }\n+\n+        jdbc.update(\"delete from application_form_items where form_id=? and ordnum=?\", form.getId(), ordnum);\n+        jdbc.update(\"update application_form_items set ordnum=ordnum-1 where form_id=? and ordnum>?\", form.getId(), ordnum);\n+\n+        perun.getAuditer().log(user, new FormItemDeleted(form));\n+\n+    }\n+\n+    @Transactional\n+    @Override\n+    public void moveFormItem(PerunSession user, ApplicationForm form, int ordnum, boolean up) throws PrivilegeException {\n+\n+        //Authorization\n+        if (!AuthzResolver.authorizedInternal(user, \"moveFormItem_ApplicationForm_int_boolean_policy\", Collections.singletonList(form.getVo()))) {\n+            throw new PrivilegeException(user, \"moveFormItem\");\n+        }\n+\n+        if (up && ordnum == 0) {\n+            throw new InternalErrorException(\"cannot move topmost item up\");\n+        }\n+\n+        int numItems = jdbc.queryForInt(\"select count(*) from application_form_items where form_id=?\", form.getId());\n+\n+        if (!up && ordnum == numItems - 1) {\n+            throw new InternalErrorException(\"cannot move lowest item down\");\n+        }\n+\n+        int id1 = jdbc.queryForInt(\n+                \"select id from application_form_items where form_id=? and ordnum=?\",\n+                form.getId(), (up ? ordnum - 1 : ordnum));\n+        int id2 = jdbc.queryForInt(\n+                \"select id from application_form_items where form_id=? and ordnum=?\",\n+                form.getId(), (up ? ordnum : ordnum + 1));\n+        jdbc.update(\"update application_form_items set ordnum=ordnum+1 where id=?\",\n+                id1);\n+        jdbc.update(\"update application_form_items set ordnum=ordnum-1 where id=?\",\n+                id2);\n+\n+    }\n+\n+    @Override\n+    public void updateFormItemTexts(PerunSession sess, ApplicationFormItem item, Locale locale) throws PrivilegeException, FormNotExistsException {\n+\n+        try {\n+            getFormByItemId(sess, item.getId());\n+        } catch (PrivilegeException ex) {\n+            throw new PrivilegeException(sess, \"updateFormItemTexts\");\n+        }\n+\n+        ItemTexts texts = item.getTexts(locale);\n+        jdbc.update(\"update application_form_item_texts set label=?,options=?,help=?,error_message=? where item_id=? and locale=?\",\n+                texts.getLabel(), texts.getOptions(), texts.getHelp(),\n+                texts.getErrorMessage(), item.getId(), locale.getLanguage());\n+\n+    }\n+\n+    @Override\n+    public void updateFormItemTexts(PerunSession sess, ApplicationFormItem item) throws PrivilegeException, FormNotExistsException {\n+\n+        ApplicationForm form;\n+\n+        // check authz on form\n+        try {\n+            form = getFormByItemId(sess, item.getId());\n+        } catch (PrivilegeException ex) {\n+            throw new PrivilegeException(sess, \"updateFormItemById\");\n+        }\n+\n+        //Authorization\n+        if (form.getGroup() == null) {\n+            if (!AuthzResolver.authorizedInternal(sess, \"vo-updateFormItemTexts_ApplicationFormItem_policy\", Collections.singletonList(form.getVo()))) {\n+                throw new PrivilegeException(sess, \"updateFormItemById\");\n+            }\n+        } else {\n+            if (!AuthzResolver.authorizedInternal(sess, \"group-updateFormItemTexts_ApplicationFormItem_policy\", Arrays.asList(form.getVo(), form.getGroup()))) {\n+                throw new PrivilegeException(sess, \"updateFormItemById\");\n+            }\n+        }\n+\n+        // update form item texts (easy way = delete and new insert)\n+\n+        // delete\n+        jdbc.update(\"delete from application_form_item_texts where item_id=?\", item.getId());\n+        // insert new\n+        for (Locale locale : item.getI18n().keySet()) {\n+            ItemTexts itemTexts = item.getTexts(locale);\n+            jdbc.update(\"insert into application_form_item_texts(item_id,locale,label,options,help,error_message) values (?,?,?,?,?,?)\",\n+                    item.getId(), locale.getLanguage(), itemTexts.getLabel(),\n+                    itemTexts.getOptions(), itemTexts.getHelp(),\n+                    itemTexts.getErrorMessage());\n+        }\n+\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public List<ApplicationFormItemData> createApplication(PerunSession session, Application application, List<ApplicationFormItemData> data) throws PerunException {\n+        int appId = processApplication(session, application, data);\n+        return getApplicationDataById(session, appId);\n+    }\n+\n+    @Override\n+    public Application submitApplication(PerunSession session, Application application, List<ApplicationFormItemData> data) throws PerunException {\n+        int appId = processApplication(session, application, data);\n+        return getApplicationById(appId);\n+    }\n+\n+    @Override\n+    @Transactional(rollbackFor = ApplicationNotCreatedException.class)\n+    public Application createApplicationInternal(PerunSession session, Application application, List<ApplicationFormItemData> data) throws PerunException {\n+\n+        // exceptions to send to vo admin with new app created email\n+        List<Exception> exceptions = new ArrayList<>();\n+        boolean applicationNotCreated = false;\n+\n+        try {\n+\n+            // 1) create application\n+            int appId = Utils.getNewId(jdbc, \"APPLICATION_ID_SEQ\");\n+            application.setId(appId);\n+\n+            application.setState(AppState.NEW);\n+\n+            // optional group\n+            Integer groupId = null;\n+            Integer userId = null;\n+            if (application.getGroup() != null) {\n+                groupId = application.getGroup().getId();\n+            }\n+            if (application.getUser() != null) {\n+                userId = application.getUser().getId();\n+            }\n+\n+            jdbc.update(\"insert into application(id,vo_id,group_id,user_id,apptype,fed_info,extSourceName,extSourceType,extSourceLoa,state,created_by,modified_by) values (?,?,?,?,?,?,?,?,?,?,?,?)\",\n+                    appId, application.getVo().getId(), groupId, userId,\n+                    application.getType().toString(), application.getFedInfo(),\n+                    application.getExtSourceName(), application.getExtSourceType(),\n+                    application.getExtSourceLoa(), application.getState().toString(),\n+                    application.getCreatedBy(), application.getCreatedBy());\n+\n+            // 2) process & store app data\n+            for (ApplicationFormItemData itemData : data) {\n+\n+                Type itemType = itemData.getFormItem().getType();\n+                if (itemType == HTML_COMMENT || itemType == SUBMIT_BUTTON || itemType == AUTO_SUBMIT_BUTTON || itemType == PASSWORD || itemType == HEADING) {\n+                    continue;\n+                }\n+\n+                // Check if mails needs to be validated\n+                if (itemType == VALIDATED_EMAIL) {\n+                    handleLoaForValidatedMail(session, itemData);\n+                }\n+\n+                try {\n+                    itemData.setId(Utils.getNewId(jdbc, \"APPLICATION_DATA_ID_SEQ\"));\n+                    jdbc.update(\"insert into application_data(id,app_id,item_id,shortname,value,assurance_level) values (?,?,?,?,?,?)\",\n+                            itemData.getId(), appId, itemData.getFormItem().getId(), itemData\n+                                    .getFormItem().getShortname(), itemData.getValue(), ((StringUtils.isBlank(itemData\n+                                    .getAssuranceLevel())) ? null : itemData.getAssuranceLevel()));\n+                } catch (Exception ex) {\n+                    // log and store exception so vo manager could see error in notification.\n+                    log.error(\"[REGISTRAR] Storing form item {} caused exception {}\", itemData, ex);\n+                    exceptions.add(ex);\n+                }\n+\n+            }\n+\n+            // 3) process all logins and passwords\n+\n+            // create list of logins and passwords to process\n+            List<ApplicationFormItemData> logins = new ArrayList<>();\n+            for (ApplicationFormItemData itemData : data) {\n+\n+                Type itemType = itemData.getFormItem().getType();\n+                if (itemType == USERNAME || itemType == PASSWORD) {\n+                    // skip logins with empty/null value\n+                    if (itemData.getValue() == null || itemData.getValue().isEmpty() || itemData.getValue().equals(\"null\")) {\n+                        continue;\n+                    }\n+                    // skip unchanged pre-filled logins, since they must have been handled last time\n+                    if (itemType == USERNAME && Objects.equals(itemData.getValue(), itemData.getPrefilledValue())) {\n+                        continue;\n+                    }\n+                    logins.add(itemData);\n+                }\n+            }\n+\n+            for (ApplicationFormItemData loginItem : logins) {\n+                if (loginItem.getFormItem().getType() == USERNAME) {\n+                    // values to store\n+                    String login = loginItem.getValue();\n+                    String pass; // filled later\n+                    // Get login namespace\n+                    String dstAttr = loginItem.getFormItem().getPerunDestinationAttribute();\n+                    AttributeDefinition loginAttribute = attrManager.getAttributeDefinition(session, dstAttr);\n+                    String loginNamespace = loginAttribute.getFriendlyNameParameter();\n+\n+                    boolean loginAvailable = false;\n+                    try {\n+                        loginAvailable = usersManager.isLoginAvailable(session, loginNamespace, login);\n+                    } catch (InvalidLoginException ex) {\n+                        log.error(\"[REGISTRAR] Unable to store login: {} in namespace: {} due to {}\", login, loginNamespace, ex);\n+                        throw new ApplicationNotCreatedException(\"Application was not created. Reason: Login: \" + login + \" in namespace: \" + loginNamespace + \" is not allowed. Please choose different login.\", login, loginNamespace);\n+                    }\n+\n+                    // try to book new login in namespace if the application hasn't been approved yet\n+                    if (loginAvailable) {\n+                        try {\n+                            // Reserve login\n+                            jdbc.update(\"insert into application_reserved_logins(login,namespace,app_id,created_by,created_at) values(?,?,?,?,?)\",\n+                                    login, loginNamespace, appId, application.getCreatedBy(), new Date());\n+                            log.debug(\"[REGISTRAR] Added login reservation for login: {} in namespace: {}.\", login, loginNamespace);\n+\n+                            // process password for this login\n+                            for (ApplicationFormItemData passItem : logins) {\n+                                ApplicationFormItem item = passItem.getFormItem();\n+                                if (item.getType() == PASSWORD && item.getPerunDestinationAttribute() != null) {\n+                                    if (item.getPerunDestinationAttribute().equals(dstAttr)) {\n+                                        pass = passItem.getValue();\n+                                        try {\n+                                            // reserve password\n+                                            usersManager.reservePassword(registrarSession, login, loginNamespace, pass);\n+                                            log.debug(\"[REGISTRAR] Password for login: {} in namespace: {} successfully reserved in external system.\", login, loginNamespace);\n+                                        } catch (Exception ex) {\n+                                            // login reservation fail must cause rollback !!\n+                                            log.error(\"[REGISTRAR] Unable to reserve password for login: {} in namespace: {} in external system. Exception: {}\", login, loginNamespace, ex);\n+                                            throw new ApplicationNotCreatedException(\n+                                                    \"Application was not created. Reason: Unable to reserve password for login: \" + login + \" in namespace: \" + loginNamespace + \" in external system. Please contact support to fix this issue before new application submission.\", login, loginNamespace);\n+                                        }\n+                                        break; // use first pass with correct namespace\n+                                    }\n+                                }\n+                            }\n+                        } catch (ApplicationNotCreatedException ex) {\n+                            throw ex; // re-throw\n+                        } catch (Exception ex) {\n+                            // unable to book login\n+                            log.error(\"[REGISTRAR] Unable to reserve login: {} in namespace: {}. Exception: \", login, loginNamespace, ex);\n+                            exceptions.add(ex);\n+                        }\n+                    } else {\n+                        // login is not available\n+                        log.error(\"[REGISTRAR] Login: {} in namespace: {} is already occupied but it shouldn't (race condition).\", login, loginNamespace);\n+                        exceptions.add(new InternalErrorException(\"Login: \" + login + \" in namespace: \" + loginNamespace + \" is already occupied but it shouldn't.\"));\n+                    }\n+                }\n+            }\n+\n+            // call registrar module before auto validation so createAction is trigerred first\n+            RegistrarModule module;\n+            if (application.getGroup() != null) {\n+                module = getRegistrarModule(getFormForGroup(application.getGroup()));\n+            } else {\n+                module = getRegistrarModule(getFormForVo(application.getVo()));\n+            }\n+            if (module != null) {\n+                module.createApplication(session, application, data);\n+            }\n+\n+        } catch (ApplicationNotCreatedException ex) {\n+            applicationNotCreated = true; // prevent action in finally block\n+            throw ex; // re-throw\n+        } catch (Exception ex) {\n+            // any exception during app creation process => add it to list\n+            // exceptions when handling logins are catched before\n+            log.error(\"Unexpected exception when creating application.\", ex);\n+            exceptions.add(ex);\n+        } finally {\n+\n+            // process rest only if it was not exception related to PASSWORDS creation\n+            if (!applicationNotCreated) {\n+\n+                getMailManager().sendMessage(application, MailType.APP_CREATED_USER, null, null);\n+                getMailManager().sendMessage(application, MailType.APP_CREATED_VO_ADMIN, null, exceptions);\n+                // if there were exceptions, throw some to let know GUI about it\n+                if (!exceptions.isEmpty()) {\n+                    RegistrarException ex = new RegistrarException(\"Your application (ID=\" + application.getId() +\n+                            \") has been created with errors. Administrator of \" + application.getVo().getName() + \" has been notified. If you want, you can use \\\"Send report to RT\\\" button to send this information to administrators directly.\");\n+                    log.error(\"[REGISTRAR] New application {} created with errors {}. This is case of PerunException {}\", application, exceptions, ex.getErrorId());\n+                    throw ex;\n+                }\n+                log.info(\"New application {} created.\", application);\n+                perun.getAuditer().log(session, new ApplicationCreated(application));\n+\n+            }\n+        }\n+\n+        // return stored data\n+        return application;\n+\n+    }\n+\n+    @Override\n+    public void deleteApplication(PerunSession sess, Application app) throws PerunException {\n+\n+        //Authorization\n+        if (app.getGroup() == null) {\n+            if (!AuthzResolver.authorizedInternal(sess, \"vo-deleteApplication_Application_policy\", Collections.singletonList(app.getVo()))) {\n+                throw new PrivilegeException(sess, \"deleteApplication\");\n+            }\n+        } else {\n+            if (!AuthzResolver.authorizedInternal(sess, \"group-deleteApplication_Application_policy\", Arrays.asList(app.getVo(), app.getGroup()))) {\n+                throw new PrivilegeException(sess, \"deleteApplication\");\n+            }\n+        }\n+\n+        // lock to prevent concurrent runs\n+        synchronized (runningDeleteApplication) {\n+            if (runningDeleteApplication.contains(app.getId())) {\n+                throw new AlreadyProcessingException(\"Application deletion is already processing.\");\n+            } else {\n+                runningDeleteApplication.add(app.getId());\n+            }\n+        }\n+\n+        try {\n+\n+            if (AppState.NEW.equals(app.getState()) || AppState.REJECTED.equals(app.getState())) {\n+\n+                // Try to get reservedLogin and reservedNamespace before deletion\n+                List<Pair<String, String>> logins;\n+                try {\n+                    logins = jdbc.query(\"select namespace,login from application_reserved_logins where app_id=?\", (resultSet, arg1) -> new Pair<>(resultSet.getString(\"namespace\"), resultSet.getString(\"login\")), app.getId());\n+                } catch (EmptyResultDataAccessException e) {\n+                    // set empty logins\n+                    logins = new ArrayList<>();\n+                }\n+                // delete passwords in KDC\n+                for (Pair<String, String> login : logins) {\n+                    // delete LOGIN in NAMESPACE\n+                    usersManager.deletePassword(sess, login.getRight(), login.getLeft());\n+                }\n+\n+                // free any login from reservation when application is rejected\n+                jdbc.update(\"delete from application_reserved_logins where app_id=?\", app.getId());\n+\n+                // delete application and data on cascade\n+                jdbc.update(\"delete from application where id=?\", app.getId());\n+\n+            } else {\n+                if (AppState.VERIFIED.equals(app.getState())) {\n+                    throw new RegistrarException(\"Submitted application can't be deleted. Please reject the application first.\");\n+                }\n+                if (AppState.APPROVED.equals(app.getState())) {\n+                    throw new RegistrarException(\"Approved application can't be deleted. Try to refresh the view to see changes.\");\n+                }\n+            }\n+            perun.getAuditer().log(sess, new ApplicationDeleted(app));\n+\n+        } finally {\n+            synchronized (runningDeleteApplication) {\n+                runningDeleteApplication.remove(app.getId());\n+            }\n+        }\n+\n+    }\n+\n+    @Override\n+    public Application verifyApplication(PerunSession sess, int appId) throws PerunException {\n+\n+        Application app = getApplicationById(appId);\n+        if (app == null) {\n+            throw new RegistrarException(\"Application with ID=\" + appId + \" doesn't exists.\");\n+        }\n+\n+        //Authorization\n+        if (app.getGroup() == null) {\n+            if (!AuthzResolver.authorizedInternal(sess, \"vo-verifyApplication_int_policy\", Collections.singletonList(app.getVo()))) {\n+                throw new PrivilegeException(sess, \"verifyApplication\");\n+            }\n+        } else {\n+            if (!AuthzResolver.authorizedInternal(sess, \"group-verifyApplication_int_policy\", Arrays.asList(app.getVo(), app.getGroup()))) {\n+                throw new PrivilegeException(sess, \"verifyApplication\");\n+            }\n+        }\n+\n+        // proceed\n+        markApplicationVerified(sess, appId);\n+        perun.getAuditer().log(sess, new ApplicationVerified(app));\n+        // return updated application\n+        return getApplicationById(appId);\n+\n+    }\n+\n+    @Override\n+    @Transactional(rollbackFor = Exception.class)\n+    public Application rejectApplication(PerunSession sess, int appId, String reason) throws PerunException {\n+\n+        Application app = getApplicationById(appId);\n+        if (app == null) {\n+            throw new RegistrarException(\"Application with ID=\" + appId + \" doesn't exists.\");\n+        }\n+\n+        //Authorization\n+        if (app.getGroup() == null) {\n+            if (!AuthzResolver.authorizedInternal(sess, \"vo-rejectApplication_int_String_policy\", Collections.singletonList(app.getVo()))) {\n+                throw new PrivilegeException(sess, \"rejectApplication\");\n+            }\n+        } else {\n+            if (!AuthzResolver.authorizedInternal(sess, \"group-rejectApplication_int_String_policy\", Arrays.asList(app.getVo(), app.getGroup()))) {\n+                throw new PrivilegeException(sess, \"rejectApplication\");\n+            }\n+        }\n+\n+        // only VERIFIED applications can be rejected\n+        if (AppState.APPROVED.equals(app.getState())) {\n+            throw new RegistrarException(\"Approved application can't be rejected ! Try to refresh the view to see changes.\");\n+        } else if (AppState.REJECTED.equals(app.getState())) {\n+            throw new RegistrarException(\"Application is already rejected. Try to refresh the view to see changes.\");\n+        }\n+\n+        // lock to prevent concurrent runs\n+        synchronized (runningRejectApplication) {\n+            if (runningRejectApplication.contains(appId)) {\n+                throw new AlreadyProcessingException(\"Application rejection is already processing.\");\n+            } else {\n+                runningRejectApplication.add(appId);\n+            }\n+        }\n+\n+        try {\n+\n+            // mark as rejected\n+            int result = jdbc.update(\"update application set state=?, modified_by=?, modified_at=? where id=?\", AppState.REJECTED.toString(), sess.getPerunPrincipal().getActor(), new Date(), appId);\n+            if (result == 0) {\n+                throw new RegistrarException(\"Application with ID=\" + appId + \" not found.\");\n+            } else if (result > 1) {\n+                throw new ConsistencyErrorException(\"More than one application is stored under ID=\" + appId + \".\");\n+            }\n+            // set back as rejected\n+            app.setState(AppState.REJECTED);\n+            log.info(\"Application {} marked as REJECTED.\", appId);\n+\n+            // get all reserved logins\n+            List<Pair<String, String>> logins = jdbc.query(\"select namespace,login from application_reserved_logins where app_id=?\",\n+                    (resultSet, arg1) -> new Pair<>(resultSet.getString(\"namespace\"), resultSet.getString(\"login\")), appId);\n+\n+            // delete passwords for reserved logins\n+            for (Pair<String, String> login : logins) {\n+                try {\n+                    // left = namespace / right = login\n+                    usersManager.deletePassword(registrarSession, login.getRight(), login.getLeft());\n+                } catch (LoginNotExistsException ex) {\n+                    log.error(\"[REGISTRAR] Login: {} not exists while deleting passwords in rejected application: {}\", login.getLeft(), appId);\n+                }\n+            }\n+            // free any login from reservation when application is rejected\n+            jdbc.update(\"delete from application_reserved_logins where app_id=?\", appId);\n+\n+            // log\n+            perun.getAuditer().log(sess, new ApplicationRejected(app));\n+\n+            // call registrar module\n+            RegistrarModule module;\n+            if (app.getGroup() != null) {\n+                module = getRegistrarModule(getFormForGroup(app.getGroup()));\n+            } else {\n+                module = getRegistrarModule(getFormForVo(app.getVo()));\n+            }\n+            if (module != null) {\n+                module.rejectApplication(sess, app, reason);\n+            }\n+\n+            // send mail\n+            getMailManager().sendMessage(app, MailType.APP_REJECTED_USER, reason, null);\n+\n+            perun.getAuditer().log(sess, new ApplicationRejected(app));\n+\n+            // return updated application\n+            return app;\n+\n+        } finally {\n+\n+            // always release lock\n+            synchronized (runningRejectApplication) {\n+                runningRejectApplication.remove(appId);\n+            }\n+\n+        }\n+\n+    }\n+\n+    @Override\n+    public Application approveApplication(PerunSession sess, int appId) throws PerunException {\n+\n+        synchronized (runningApproveApplication) {\n+            if (runningApproveApplication.contains(appId)) {\n+                throw new AlreadyProcessingException(\"Application approval is already processing.\");\n+            } else {\n+                runningApproveApplication.add(appId);\n+            }\n+        }\n+\n+        Application app;\n+        try {\n+            app = registrarManager.approveApplicationInternal(sess, appId);\n+        } catch (AlreadyMemberException ex) {\n+            // case when user joined identity after sending initial application and former user was already member of VO\n+            throw new RegistrarException(\"User is already member (with ID: \" + ex.getMember().getId() + \") of your VO/group. (user joined his identities after sending new application). You can reject this application and re-validate old member to keep old data (e.g. login,email).\", ex);\n+        } catch (MemberNotExistsException ex) {\n+            throw new RegistrarException(\"To approve application user must already be member of VO.\", ex);\n+        } catch (NotGroupMemberException ex) {\n+            throw new RegistrarException(\"To approve application user must already be member of Group.\", ex);\n+        } catch (UserNotExistsException | UserExtSourceNotExistsException | ExtSourceNotExistsException ex) {\n+            throw new RegistrarException(\"User specified by the data in application was not found. If you tried to approve application for the Group, try to check, if user already has approved application in the VO. Application to the VO must be approved first.\", ex);\n+        } finally {\n+            synchronized (runningApproveApplication) {\n+                runningApproveApplication.remove(appId);\n+            }\n+        }\n+\n+        Member member = membersManager.getMemberByUser(sess, app.getVo(), app.getUser());\n+\n+        try {\n+\n+            // validate member async when all changes are committed\n+            // we can't use existing core method, since we want to approve auto-approval waiting group applications\n+            // once member is validated\n+            new Thread(() -> {\n+\n+                try {\n+                    Thread.sleep(5000);\n+                } catch (InterruptedException e) {\n+                    // TODO Auto-generated catch block\n+                    e.printStackTrace();\n+                }\n+\n+                try {\n+                    membersManager.validateMember(registrarSession, member);\n+                } catch (InternalErrorException | WrongAttributeValueException | WrongReferenceAttributeValueException e) {\n+                    log.error(\"[REGISTRAR] Exception when validating {} after approving application {}.\", member, app);\n+                }\n+\n+                try {\n+                    // get user's group apps with auto-approve and approve them\n+                    autoApproveUsersGroupApplications(sess, app.getVo(), app.getUser());\n+                } catch (PerunException ex) {\n+                    log.error(\"[REGISTRAR] Exception when auto-approving waiting group applications for {} after approving application {}.\", member, app);\n+                }\n+\n+            }).start();\n+\n+        } catch (Exception ex) {\n+            // we skip any exception thrown from here\n+            log.error(\"[REGISTRAR] Exception when validating {} after approving application {}.\", member, app);\n+        }\n+        perun.getAuditer().log(sess, new ApplicationApproved(app));\n+\n+        synchronized (runningApproveApplication) {\n+            runningApproveApplication.remove(appId);\n+        }\n+\n+        return app;\n+    }\n+\n+    /**\n+     * Process application approval in 1 transaction\n+     * !! WITHOUT members validation !!\n+     *\n+     * @param sess  session for authz\n+     * @param appId application ID to approve\n+     * @return updated application\n+     * @throws PerunException\n+     */\n+    @Transactional(rollbackFor = Exception.class)\n+    public Application approveApplicationInternal(PerunSession sess, int appId)\n+            throws PrivilegeException, RegistrarException, FormNotExistsException, UserNotExistsException, ExtSourceNotExistsException, UserExtSourceNotExistsException, LoginNotExistsException, PasswordCreationFailedException, WrongReferenceAttributeValueException, WrongAttributeValueException,\n+            MemberNotExistsException, VoNotExistsException, CantBeApprovedException, GroupNotExistsException, NotGroupMemberException, ExternallyManagedException, WrongAttributeAssignmentException, AttributeNotExistsException, AlreadyMemberException, ExtendMembershipException,\n+            PasswordDeletionFailedException, PasswordOperationTimeoutException, AlreadyAdminException, InvalidLoginException {\n+\n+        Application app = getApplicationById(appId);\n+        if (app == null) {\n+            throw new RegistrarException(\"Application with ID \" + appId + \" doesn't exists.\");\n+        }\n+        Member member;\n+\n+        //Authorization\n+        if (app.getGroup() == null) {\n+            if (!AuthzResolver.authorizedInternal(sess, \"vo-approveApplicationInternal_int_policy\", Collections.singletonList(app.getVo()))) {\n+                throw new PrivilegeException(sess, \"approveApplicationInternal\");\n+            }\n+        } else {\n+            if (!AuthzResolver.authorizedInternal(sess, \"group-approveApplicationInternal_int_policy\", Arrays.asList(app.getVo(), app.getGroup()))) {\n+                throw new PrivilegeException(sess, \"approveApplicationInternal\");\n+            }\n+        }\n+\n+        // only VERIFIED applications can be approved\n+        if (!AppState.VERIFIED.equals(app.getState())) {\n+            if (AppState.APPROVED.equals(app.getState())) {\n+                throw new RegistrarException(\"Application is already approved. Try to refresh the view to see changes.\");\n+            }\n+            if (AppState.REJECTED.equals(app.getState())) {\n+                throw new RegistrarException(\"Rejected application cant' be approved. Try to refresh the view to see changes.\");\n+            }\n+            throw new RegistrarException(\"User didn't verify his email address yet. Please wait until application will be in a 'Submitted' state. You can send mail verification notification to user again if you wish.\");\n+        }\n+\n+        LinkedHashMap<String, String> additionalAttributes = BeansUtils.stringToMapOfAttributes(app.getFedInfo());\n+        PerunPrincipal applicationPrincipal = new PerunPrincipal(app.getCreatedBy(), app.getExtSourceName(), app.getExtSourceType(), app.getExtSourceLoa(), additionalAttributes);\n+\n+        // get registrar module\n+        RegistrarModule module;\n+        if (app.getGroup() != null) {\n+            module = getRegistrarModule(getFormForGroup(app.getGroup()));\n+        } else {\n+            module = getRegistrarModule(getFormForVo(app.getVo()));\n+        }\n+\n+        if (module != null) {\n+            // call custom logic before approving\n+            module.beforeApprove(sess, app);\n+        }\n+\n+        // mark as APPROVED\n+        int result = jdbc.update(\"update application set state=?, modified_by=?, modified_at=? where id=?\", AppState.APPROVED.toString(), sess.getPerunPrincipal().getActor(), new Date(), appId);\n+        if (result == 0) {\n+            throw new RegistrarException(\"Application with ID=\" + appId + \" not found.\");\n+        } else if (result > 1) {\n+            throw new ConsistencyErrorException(\"More than one application is stored under ID=\" + appId + \".\");\n+        }\n+        // set back as approved\n+        app.setState(AppState.APPROVED);\n+        log.info(\"Application {} marked as APPROVED\", appId);\n+\n+        // Try to get reservedLogin and reservedNamespace before deletion, it will be used for creating userExtSources\n+        List<Pair<String, String>> logins;\n+        try {\n+            logins = jdbc.query(\"select namespace,login from application_reserved_logins where app_id=?\", (resultSet, arg1) -> new Pair<>(resultSet.getString(\"namespace\"), resultSet.getString(\"login\")), appId);\n+        } catch (EmptyResultDataAccessException e) {\n+            // set empty logins\n+            logins = new ArrayList<>();\n+        }\n+\n+        // FOR INITIAL APPLICATION\n+        if (AppType.INITIAL.equals(app.getType())) {\n+\n+            if (app.getGroup() != null) {\n+\n+                // free reserved logins so they can be set as attributes\n+                jdbc.update(\"delete from application_reserved_logins where app_id=?\", appId);\n+\n+                if (app.getUser() == null) {\n+\n+                    // application for group doesn't have user set, but it can exists in perun (joined identities after submission)\n+                    User u = perun.getUsersManagerBl().getUserByExtSourceInformation(registrarSession, applicationPrincipal);\n+\n+                    // put user back to application\n+                    app.setUser(u);\n+                    // store user_id in DB\n+                    int result2 = jdbc.update(\"update application set user_id=? where id=?\", u.getId(), appId);\n+                    if (result2 == 0) {\n+                        throw new RegistrarException(\"Application with ID=\" + appId + \" not found.\");\n+                    } else if (result2 > 1) {\n+                        throw new ConsistencyErrorException(\"More than one application is stored under ID=\" + appId + \".\");\n+                    }\n+\n+                }\n+\n+                // add new member of VO as member of group (for group applications)\n+                // !! MUST BE MEMBER OF VO !!\n+                member = membersManager.getMemberByUser(registrarSession, app.getVo(), app.getUser());\n+\n+                // MEMBER must be in a VALID or INVALID state since approval starts validation !!\n+                // and we don't want to validate expired, suspended or disabled users without VO admin owns action !!\n+                // meaning, user should submit membership extension application first !!\n+                if (!Arrays.asList(Status.VALID, Status.INVALID).contains(member.getStatus())) {\n+                    throw new CantBeApprovedException(\"Application of member with membership status: \" + member.getStatus() + \" can't be approved. Please wait until member extends/re-validate own membership in a VO.\");\n+                }\n+\n+                // store all attributes (but not logins)\n+                storeApplicationAttributes(app);\n+\n+                // cancel reservation of new duplicate logins and get purely new logins back\n+                logins = unreserveNewLoginsFromSameNamespace(logins, app.getUser());\n+\n+                // store purely new logins to user\n+                storeApplicationLoginAttributes(app);\n+\n+                for (Pair<String, String> pair : logins) {\n+                    // LOGIN IN NAMESPACE IS PURELY NEW => VALIDATE ENTRY IN KDC\n+                    // left = namespace, right = login\n+                    usersManager.validatePassword(registrarSession, app.getUser(), pair.getLeft());\n+                }\n+\n+                // update titles before/after users name if part of application !! USER MUST EXISTS !!\n+                updateUserNameTitles(app);\n+\n+                // Perform checks since we moved from entry to BL\n+                // Check if the group is externally synchronized\n+                Attribute attrSynchronizeEnabled = attrManager.getAttribute(sess, app.getGroup(), GROUPSYNCHROENABLED_ATTRNAME);\n+                if (\"true\".equals(attrSynchronizeEnabled.getValue()) || groupsManager.isGroupInStructureSynchronizationTree(sess, app.getGroup())) {\n+                    throw new ExternallyManagedException(\"Adding of member is not allowed. Group is externally managed.\");\n+                }\n+\n+                groupsManager.addMember(registrarSession, app.getGroup(), member);\n+\n+                log.debug(\"[REGISTRAR] Member {} added to Group {}.\", member, app.getGroup());\n+\n+            } else {\n+\n+                // free reserved logins so they can be set as attributes\n+                jdbc.update(\"delete from application_reserved_logins where app_id=?\", appId);\n+\n+                User u;\n+                if (app.getUser() != null) {\n+                    u = app.getUser();\n+                    log.debug(\"[REGISTRAR] Trying to make member from user {}\", u);\n+                    member = membersManager.createMember(sess, app.getVo(), u);\n+                    // store all attributes (but not logins)\n+                    storeApplicationAttributes(app);\n+                    // if user was already known to perun, createMember() will set attributes\n+                    // via setAttributes() method so core attributes are skipped\n+                    // ==> updateNameTitles() in case of change in appForm.\n+                    updateUserNameTitles(app);\n+                } else {\n+                    try {\n+                        u = perun.getUsersManagerBl().getUserByExtSourceInformation(registrarSession, applicationPrincipal);\n+                        log.debug(\"[REGISTRAR] Trying to make member from user {}\", u);\n+                        member = membersManager.createMember(sess, app.getVo(), u);\n+                        // set NEW user id back to application\n+                        app.setUser(u);\n+                        // store all attributes (but not logins)\n+                        storeApplicationAttributes(app);\n+                        // if user was already known to perun, createMember() will set attributes\n+                        // via setAttributes() method so core attributes are skipped\n+                        // ==> updateNameTitles() in case of change in appForm.\n+                        updateUserNameTitles(app);\n+                    } catch (UserExtSourceNotExistsException | UserNotExistsException | ExtSourceNotExistsException ex) {\n+                        Candidate candidate = createCandidateFromApplicationData(app);\n+                        // create member and user\n+                        log.debug(\"[REGISTRAR] Trying to make member from candidate {}\", candidate);\n+\n+                        // added duplicit check, since we switched from entry to bl call of createMember()\n+                        Utils.checkMaxLength(\"TitleBefore\", candidate.getTitleBefore(), 40);\n+                        Utils.checkMaxLength(\"TitleAfter\", candidate.getTitleAfter(), 40);\n+\n+                        member = membersManager.createMember(sess, app.getVo(), app.getExtSourceName(), app.getExtSourceType(), app.getExtSourceLoa(), app.getCreatedBy(), candidate);\n+                        u = usersManager.getUserById(registrarSession, member.getUserId());\n+                        // set NEW user id back to application\n+                        app.setUser(u);\n+                    }\n+                    // user originally not known -> set UserExtSource attributes from source identity for new User and UES\n+                    ExtSource es = perun.getExtSourcesManagerBl().getExtSourceByName(sess, app.getExtSourceName());\n+                    UserExtSource ues = usersManager.getUserExtSourceByExtLogin(sess, es, app.getCreatedBy());\n+                    // we have historical data in \"fedInfo\" item, hence we must safely ignore any parsing errors.\n+                    try {\n+                        ((PerunBlImpl) perun).setUserExtSourceAttributes(sess, ues, additionalAttributes);\n+                    } catch (Exception ex) {\n+                        log.error(\"Unable to store UES attributes from application ID: {}, attributes: {}, with exception: {}\", appId, app.getFedInfo(), ex);\n+                    }\n+                }\n+\n+                result = jdbc.update(\"update application set user_id=? where id=?\", member.getUserId(), appId);\n+                if (result == 0) {\n+                    throw new RegistrarException(\"User ID hasn't been associated with the application \" + appId + \", because the application was not found!\");\n+                } else if (result > 1) {\n+                    throw new ConsistencyErrorException(\"User ID hasn't been associated with the application \" + appId + \", because more than one application exists under the same ID.\");\n+                }\n+                log.info(\"Member {} created for: {} / {}\", member.getId(), app.getCreatedBy(), app.getExtSourceName());\n+\n+                // unreserve new login if user already have login in same namespace\n+                // also get back purely new logins\n+                logins = unreserveNewLoginsFromSameNamespace(logins, u);\n+\n+                // store purely new logins to user\n+                storeApplicationLoginAttributes(app);\n+\n+                for (Pair<String, String> pair : logins) {\n+                    // LOGIN IN NAMESPACE IS PURELY NEW => VALIDATE ENTRY IN KDC\n+                    // left = namespace, right = login\n+                    usersManager.validatePassword(registrarSession, u, pair.getLeft());\n+                }\n+\n+                // log\n+                perun.getAuditer().log(sess, new MemberCreatedForApprovedApp(member, app));\n+\n+            }\n+\n+            // FOR EXTENSION APPLICATION\n+        } else if (AppType.EXTENSION.equals(app.getType())) {\n+\n+            // free reserved logins so they can be set as attributes\n+            jdbc.update(\"delete from application_reserved_logins where app_id=?\", app.getId());\n+\n+            member = membersManager.getMemberByUser(registrarSession, app.getVo(), app.getUser());\n+\n+            if (app.getGroup() != null) {\n+\n+                // MEMBER must be in a VALID or INVALID state since approval starts validation !!\n+                // and we don't want to validate expired, suspended or disabled users without VO admin owns action !!\n+                // meaning, user should submit membership extension application first !!\n+                if (!Arrays.asList(Status.VALID, Status.INVALID).contains(member.getStatus())) {\n+                    throw new CantBeApprovedException(\"Application of member with membership status: \" + member.getStatus() + \" can't be approved. Please wait until member extends/re-validate own membership in a VO.\");\n+                }\n+\n+                // overwrite member with group context\n+                member = groupsManager.getGroupMemberById(registrarSession, app.getGroup(), member.getId());\n+\n+            }\n+\n+            storeApplicationAttributes(app);\n+\n+            if (app.getGroup() != null) {\n+                // extends users Group membership\n+                groupsManager.extendMembershipInGroup(sess, member, app.getGroup());\n+            } else {\n+                // extend users VO membership\n+                membersManager.extendMembership(registrarSession, member);\n+            }\n+\n+            // unreserve new logins, if user already have login in same namespace\n+            // also get back logins, which are purely new\n+            logins = unreserveNewLoginsFromSameNamespace(logins, app.getUser());\n+\n+            // store purely new logins from application\n+            storeApplicationLoginAttributes(app);\n+\n+            // validate purely new logins in KDC\n+            for (Pair<String, String> pair : logins) {\n+                // left = namespace, right = login\n+                usersManager.validatePassword(registrarSession, app.getUser(), pair.getLeft());\n+            }\n+\n+            // update titles before/after users name if part of application !! USER MUST EXISTS !!\n+            updateUserNameTitles(app);\n+\n+            // log\n+            perun.getAuditer().log(sess, new MembershipExtendedForMemberInApprovedApp(member, app, app.getVo()));\n+\n+        }\n+\n+        // CONTINUE FOR BOTH APP TYPES\n+\n+        if (module != null) {\n+            module.approveApplication(sess, app);\n+        }\n+\n+        getMailManager().sendMessage(app, MailType.APP_APPROVED_USER, null, null);\n+\n+        // return updated application\n+        return app;\n+\n+    }\n+\n+    @Override\n+    public void canBeApproved(PerunSession session, Application application) throws PerunException {\n+\n+        //Authorization\n+        if (application.getGroup() == null) {\n+            if (!AuthzResolver.authorizedInternal(session, \"vo-canBeApproved_Application_policy\", Collections.singletonList(application.getVo()))) {\n+                throw new PrivilegeException(session, \"canBeApproved\");\n+            }\n+        } else {\n+            if (!AuthzResolver.authorizedInternal(session, \"group-canBeApproved_Application_policy\", Arrays.asList(application.getVo(), application.getGroup()))) {\n+                throw new PrivilegeException(session, \"canBeApproved\");\n+            }\n+        }\n+\n+        // get registrar module\n+        RegistrarModule module;\n+        if (application.getGroup() != null) {\n+            module = getRegistrarModule(getFormForGroup(application.getGroup()));\n+        } else {\n+            module = getRegistrarModule(getFormForVo(application.getVo()));\n+        }\n+\n+        if (module != null) {\n+            // call custom logic before approving\n+            module.canBeApproved(session, application);\n+        }\n+\n+        // generally for Group applications:\n+\n+        // submitter, must be MEMBER of VO and in VALID or INVALID state since approval starts validation !!\n+        // and we don't want to validate expired, suspended or disabled users without VO admin owns action !!\n+        // meaning, user should submit membership extension application first !!\n+        if (application.getGroup() != null) {\n+            try {\n+                User u = application.getUser();\n+                if (u == null) {\n+                    LinkedHashMap<String, String> additionalAttributes = BeansUtils.stringToMapOfAttributes(application.getFedInfo());\n+                    PerunPrincipal applicationPrincipal = new PerunPrincipal(application.getCreatedBy(), application.getExtSourceName(), application.getExtSourceType(), application.getExtSourceLoa(), additionalAttributes);\n+                    u = perun.getUsersManagerBl().getUserByExtSourceInformation(registrarSession, applicationPrincipal);\n+                }\n+                Member member = membersManager.getMemberByUser(registrarSession, application.getVo(), u);\n+                if (!Arrays.asList(Status.VALID, Status.INVALID).contains(member.getStatus())) {\n+                    throw new CantBeApprovedException(\"Application of member with membership status: \" + member.getStatus() + \" can't be approved. Please wait until member extends/re-validate own membership in a VO.\");\n+                }\n+            } catch (MemberNotExistsException | UserNotExistsException | ExtSourceNotExistsException | UserExtSourceNotExistsException ex) {\n+                throw new RegistrarException(\"To approve application user must be a member of VO.\", ex);\n+            }\n+\n+        }\n+\n+    }\n+\n+    @Override\n+    public Application getApplicationById(PerunSession sess, int appId) throws RegistrarException, PrivilegeException {\n+\n+        // get application\n+        Application app = getApplicationById(appId);\n+        if (app == null) {\n+            throw new RegistrarException(\"Application with ID=\" + appId + \" doesn't exists.\");\n+        }\n+\n+        //Authorization\n+        if (app.getGroup() == null) {\n+            if (!AuthzResolver.authorizedInternal(sess, \"vo-getApplicationById_int_policy\", Collections.singletonList(app.getVo()))\n+                    && !AuthzResolver.selfAuthorizedForApplication(sess, app)) {\n+                throw new PrivilegeException(sess, \"getApplicationById\");\n+            }\n+        } else {\n+            if (!AuthzResolver.authorizedInternal(sess, \"group-getApplicationById_int_policy\", Arrays.asList(app.getVo(), app.getGroup()))\n+                    && !AuthzResolver.selfAuthorizedForApplication(sess, app)) {\n+                throw new PrivilegeException(sess, \"getApplicationById\");\n+            }\n+        }\n+\n+        return app;\n+\n+    }\n+\n+    @Override\n+    public List<Application> getApplicationsForVo(PerunSession userSession, Vo vo, List<String> state) throws PerunException {\n+        vosManager.checkVoExists(userSession, vo);\n+\n+        //Authorization\n+        if (!AuthzResolver.authorizedInternal(userSession, \"getApplicationsForVo_Vo_List<String>_policy\", Collections.singletonList(vo))) {\n+            throw new PrivilegeException(userSession, \"getApplicationsForVo\");\n+        }\n+        if (state == null || state.isEmpty()) {\n+            // list all\n+            try {\n+                return jdbc.query(APP_SELECT + \" where a.vo_id=? order by a.id desc\", APP_MAPPER, vo.getId());\n+            } catch (EmptyResultDataAccessException ex) {\n+                return new ArrayList<>();\n+            }\n+        } else {\n+            // filter by state\n+            try {\n+                MapSqlParameterSource sqlParameterSource = new MapSqlParameterSource();\n+                sqlParameterSource.addValue(\"voId\", vo.getId());\n+                sqlParameterSource.addValue(\"states\", state);\n+                return namedJdbc.query(APP_SELECT + \" where a.vo_id=:voId and state in ( :states ) order by a.id desc\", sqlParameterSource, APP_MAPPER);\n+            } catch (EmptyResultDataAccessException ex) {\n+                return new ArrayList<>();\n+            }\n+        }\n+\n+    }\n+\n+    @Override\n+    public List<Application> getApplicationsForGroup(PerunSession userSession, Group group, List<String> state) throws PerunException {\n+        groupsManager.checkGroupExists(userSession, group);\n+\n+        //Authorization\n+        if (!AuthzResolver.authorizedInternal(userSession, \"getApplicationsForGroup_Vo_List<String>_policy\", Collections.singletonList(group))) {\n+            throw new PrivilegeException(userSession, \"getApplicationsForGroup\");\n+        }\n+        if (state == null || state.isEmpty()) {\n+            // list all\n+            try {\n+                return jdbc.query(APP_SELECT + \" where a.group_id=? order by a.id desc\", APP_MAPPER, group.getId());\n+            } catch (EmptyResultDataAccessException ex) {\n+                return new ArrayList<>();\n+            }\n+        } else {\n+            // filter by state\n+            try {\n+                MapSqlParameterSource sqlParameterSource = new MapSqlParameterSource();\n+                sqlParameterSource.addValue(\"groupId\", group.getId());\n+                sqlParameterSource.addValue(\"states\", state);\n+                return namedJdbc.query(APP_SELECT + \" where a.group_id=:groupId and state in ( :states ) order by a.id desc\", sqlParameterSource, APP_MAPPER);\n+            } catch (EmptyResultDataAccessException ex) {\n+                return new ArrayList<>();\n+            }\n+        }\n+\n+    }\n+\n+    @Override\n+    public List<Application> getApplicationsForUser(User user) {\n+\n+        try {\n+            // sort by ID which respect latest applications\n+            return jdbc.query(APP_SELECT + \" where user_id=? order by a.id desc\", APP_MAPPER, user.getId());\n+        } catch (EmptyResultDataAccessException ex) {\n+            return new ArrayList<>();\n+        }\n+\n+    }\n+\n+    @Override\n+    public List<Application> getApplicationsForUser(PerunSession sess) {\n+\n+        try {\n+            List<Application> allApplications = jdbc.query(APP_SELECT + \" order by a.id desc\", APP_MAPPER);\n+            return filterPrincipalApplications(sess, allApplications);\n+        } catch (EmptyResultDataAccessException ex) {\n+            return new ArrayList<>();\n+        }\n+\n+    }\n+\n+    @Override\n+    public List<Application> getApplicationsForMember(PerunSession sess, Group group, Member member) throws PerunException {\n+        membersManager.checkMemberExists(sess, member);\n+\n+        //Authorization\n+        if (group == null) {\n+            if (!AuthzResolver.authorizedInternal(sess, \"vo-getApplicationsForMember_Group_Member_policy\", Collections.singletonList(member))) {\n+                throw new PrivilegeException(sess, \"getApplicationsForMember\");\n+            }\n+        } else {\n+            if (!AuthzResolver.authorizedInternal(sess, \"group-getApplicationsForMember_Group_Member_policy\", Arrays.asList(member, group))) {\n+                throw new PrivilegeException(sess, \"getApplicationsForMember\");\n+            }\n+        }\n+\n+        try {\n+            if (group == null) {\n+                return jdbc.query(APP_SELECT + \" where user_id=? and a.vo_id=? order by a.id desc\", APP_MAPPER, member.getUserId(), member.getVoId());\n+            } else {\n+                return jdbc.query(APP_SELECT + \" where user_id=? and a.vo_id=? and a.group_id=? order by a.id desc\", APP_MAPPER, member.getUserId(), member.getVoId(), group.getId());\n+            }\n+        } catch (EmptyResultDataAccessException ex) {\n+            return new ArrayList<>();\n+        }\n+\n+    }\n+\n+    @Override\n+    public List<ApplicationFormItem> getFormItems(PerunSession sess, ApplicationForm form, AppType appType) throws PerunException {\n+\n+        //Authorization\n+        if (form.getGroup() == null) {\n+            if (!AuthzResolver.authorizedInternal(sess, \"vo-getFormItems_ApplicationForm_AppType_policy\", Collections.singletonList(form.getVo()))) {\n+                throw new PrivilegeException(\"getFormItems\");\n+            }\n+        } else {\n+            if (!AuthzResolver.authorizedInternal(sess, \"group-getFormItems_ApplicationForm_AppType_policy\", Arrays.asList(form.getVo(), form.getGroup()))) {\n+                throw new PrivilegeException(\"getFormItems\");\n+            }\n+        }\n+\n+        List<ApplicationFormItem> items;\n+        if (appType == null) {\n+            items = jdbc.query(FORM_ITEM_SELECT + \" where form_id=? order by ordnum asc\", ITEM_MAPPER, form.getId());\n+        } else {\n+            items = jdbc.query(FORM_ITEM_SELECT + \" i,application_form_item_apptypes t where form_id=? and i.id=t.item_id and t.apptype=? order by ordnum asc\",\n+                    ITEM_MAPPER, form.getId(), appType.toString());\n+        }\n+        for (ApplicationFormItem item : items) {\n+            List<ItemTexts> texts = jdbc.query(FORM_ITEM_TEXTS_SELECT + \" where item_id=?\", ITEM_TEXTS_MAPPER, item.getId());\n+            for (ItemTexts itemTexts : texts) {\n+                item.getI18n().put(itemTexts.getLocale(), itemTexts);\n+            }\n+            List<AppType> appTypes = jdbc.query(APP_TYPE_SELECT + \" where item_id=?\", APP_TYPE_MAPPER, item.getId());\n+            item.setApplicationTypes(appTypes);\n+        }\n+\n+        return items;\n+    }\n+\n+    @Override\n+    public ApplicationFormItem getFormItemById(PerunSession session, int id) throws PrivilegeException {\n+\n+        // authz - can read form -> can get item\n+        try {\n+            getFormByItemId(session, id);\n+        } catch (PrivilegeException ex) {\n+            throw new PrivilegeException(\"getFormItemById\");\n+        } catch (PerunException ex) {\n+            // shouldn't happen\n+        }\n+\n+        return getFormItemById(id);\n+\n+    }\n+\n+    @Override\n+    public ApplicationFormItem getFormItemById(int id) {\n+\n+        ApplicationFormItem item;\n+        item = jdbc.queryForObject(FORM_ITEM_SELECT + \" where id=?\", ITEM_MAPPER, id);\n+        if (item != null) {\n+            List<ItemTexts> texts = jdbc.query(FORM_ITEM_TEXTS_SELECT + \" where item_id=?\", ITEM_TEXTS_MAPPER, item.getId());\n+            for (ItemTexts itemTexts : texts) {\n+                item.getI18n().put(itemTexts.getLocale(), itemTexts);\n+            }\n+            List<AppType> appTypes = jdbc.query(APP_TYPE_SELECT + \" where item_id=?\", APP_TYPE_MAPPER, item.getId());\n+            item.setApplicationTypes(appTypes);\n+        }\n+\n+        return item;\n+\n+    }\n+\n+    @Override\n+    public void updateFormItem(PerunSession sess, ApplicationFormItem item) throws PrivilegeException, FormNotExistsException {\n+\n+        ApplicationForm form;\n+\n+        // check authz on form\n+        try {\n+            form = getFormByItemId(sess, item.getId());\n+        } catch (PrivilegeException ex) {\n+            throw new PrivilegeException(sess, \"updateFormItemById\");\n+        }\n+\n+        //Authorization\n+        if (form.getGroup() == null) {\n+            if (!AuthzResolver.authorizedInternal(sess, \"vo-updateFormItem_ApplicationFormItem_policy\", Collections.singletonList(form.getVo()))) {\n+                throw new PrivilegeException(sess, \"updateFormItemById\");\n+            }\n+        } else {\n+            if (!AuthzResolver.authorizedInternal(sess, \"group-updateFormItem_ApplicationFormItem_policy\", Arrays.asList(form.getVo(), form.getGroup()))) {\n+                throw new PrivilegeException(sess, \"updateFormItemById\");\n+            }\n+        }\n+\n+        // else update form item\n+\n+        int result = jdbc.update(\"update application_form_items set ordnum=?,shortname=?,required=?,type=?,fed_attr=?,src_attr=?,dst_attr=?,regex=? where id=?\",\n+                item.getOrdnum(), item.getShortname(), item.isRequired(),\n+                item.getType().toString(), item.getFederationAttribute(),\n+                item.getPerunSourceAttribute(), item.getPerunDestinationAttribute(),\n+                item.getRegex(), item.getId());\n+\n+        // update form item texts (easy way = delete and new insert)\n+\n+        // delete\n+        jdbc.update(\"delete from application_form_item_texts where item_id=?\", item.getId());\n+        // insert new\n+        for (Locale locale : item.getI18n().keySet()) {\n+            ItemTexts itemTexts = item.getTexts(locale);\n+            jdbc.update(\"insert into application_form_item_texts(item_id,locale,label,options,help,error_message) values (?,?,?,?,?,?)\",\n+                    item.getId(), locale.getLanguage(), itemTexts.getLabel(),\n+                    itemTexts.getOptions(), itemTexts.getHelp(),\n+                    itemTexts.getErrorMessage());\n+        }\n+\n+        // update form item app types (easy way = delete and new insert)\n+\n+        // delete\n+        jdbc.update(\"delete from application_form_item_apptypes where item_id=?\", item.getId());\n+        // insert new\n+        for (AppType appType : item.getApplicationTypes()) {\n+            jdbc.update(\"insert into application_form_item_apptypes (item_id,apptype) values (?,?)\",\n+                    item.getId(), appType.toString());\n+        }\n+\n+        perun.getAuditer().log(sess, new FormItemUpdated(form, item));\n+\n+    }\n+\n+    @Override\n+    public List<ApplicationFormItemWithPrefilledValue> getFormItemsWithPrefilledValues(PerunSession sess, AppType appType, ApplicationForm form) throws PerunException {\n+\n+        Vo vo = form.getVo();\n+        Group group = form.getGroup();\n+\n+        // refresh session (user) to get correct data\n+        AuthzResolverBlImpl.refreshSession(sess);\n+\n+        // get necessary params from session\n+        User user = sess.getPerunPrincipal().getUser();\n+        String actor = sess.getPerunPrincipal().getActor();\n+        String extSourceName = sess.getPerunPrincipal().getExtSourceName();\n+        String extSourceType = sess.getPerunPrincipal().getExtSourceType();\n+        int extSourceLoa = sess.getPerunPrincipal().getExtSourceLoa();\n+        Map<String, String> federValues = sess.getPerunPrincipal().getAdditionalInformations();\n+\n+        RegistrarModule module = getRegistrarModule(form);\n+        if (module != null) {\n+            module.canBeSubmitted(sess, appType, federValues);\n+        }\n+\n+        // throws exception if user couldn't submit application - no reason to get form\n+        checkDuplicateRegistrationAttempt(sess, appType, form);\n+\n+        // PROCEED\n+        Map<String, String> parsedName = extractNames(federValues);\n+        List<ApplicationFormItem> formItems = getFormItems(registrarSession, form, appType);\n+\n+        List<ApplicationFormItemWithPrefilledValue> itemsWithValues = new ArrayList<>();\n+        for (ApplicationFormItem item : formItems) {\n+            itemsWithValues.add(new ApplicationFormItemWithPrefilledValue(item, null));\n+        }\n+\n+        // get user and member attributes from DB for existing users\n+        if (user != null) {\n+\n+            Map<String, Attribute> map = new HashMap<>();\n+\n+            // process user attributes\n+            List<Attribute> userAttributes = attrManager.getAttributes(sess, user);\n+            for (Attribute att : userAttributes) {\n+                map.put(att.getName(), att);\n+            }\n+            // process member attributes\n+            try {\n+                Member member = membersManager.getMemberByUser(sess, vo, user);\n+                List<Attribute> memberAttributes = attrManager.getAttributes(sess, member);\n+                for (Attribute att : memberAttributes) {\n+                    map.put(att.getName(), att);\n+                }\n+            } catch (MemberNotExistsException ex) {\n+                // we don't care that user is not yet member\n+            }\n+\n+            // get also vo/group attributes for extended pre-fill !!\n+            List<Attribute> voAttributes = attrManager.getAttributes(sess, vo);\n+            for (Attribute att : voAttributes) {\n+                map.put(att.getName(), att);\n+            }\n+            if (group != null) {\n+                List<Attribute> groupAttributes = attrManager.getAttributes(sess, group);\n+                for (Attribute att : groupAttributes) {\n+                    map.put(att.getName(), att);\n+                }\n+            }\n+\n+            Iterator<ApplicationFormItemWithPrefilledValue> it = ((Collection<ApplicationFormItemWithPrefilledValue>) itemsWithValues).iterator();\n+            while (it.hasNext()) {\n+                ApplicationFormItemWithPrefilledValue itemW = it.next();\n+                String sourceAttribute = itemW.getFormItem().getPerunSourceAttribute();\n+                // skip items without perun attr reference\n+                if (sourceAttribute == null || sourceAttribute.equals(\"\")) {\n+                    continue;\n+                }\n+                // if attr exist and value != null\n+                if (map.get(sourceAttribute) != null && map.get(sourceAttribute).getValue() != null) {\n+                    if (itemW.getFormItem().getType() == PASSWORD) {\n+                        // if login in namespace exists, do not return password field\n+                        // because application form is not place to change login or password\n+                        it.remove();\n+                    } else {\n+                        // else set value\n+                        itemW.setPrefilledValue(BeansUtils.attributeValueToString(map.get(sourceAttribute)));\n+                    }\n+                }\n+            }\n+        }\n+\n+        List<ApplicationFormItemWithPrefilledValue> itemsWithMissingData = new ArrayList<>();\n+\n+        // get user attributes from federation\n+        Iterator<ApplicationFormItemWithPrefilledValue> it = (itemsWithValues).iterator();\n+        while (it.hasNext()) {\n+            ApplicationFormItemWithPrefilledValue itemW = it.next();\n+            String fa = itemW.getFormItem().getFederationAttribute();\n+            if (fa != null && !fa.isEmpty()) {\n+\n+                // FILL VALUE FROM FEDERATION\n+                String s = federValues.get(fa);\n+                if (s != null && !s.isEmpty()) {\n+                    // In case of email, value from the federation can contain more than one entries, entries are separated by semi-colon\n+                    if (itemW.getFormItem().getType().equals(ApplicationFormItem.Type.VALIDATED_EMAIL)) {\n+                        if (itemW.getPrefilledValue() != null && !itemW.getPrefilledValue().isEmpty()) {\n+                            s = itemW.getPrefilledValue() + \";\" + s;\n+                        }\n+                    }\n+                    // remove password field if (login) prefilled from federation\n+                    if (itemW.getFormItem().getType() == PASSWORD) {\n+                        it.remove();\n+                        continue;\n+                    }\n+                    itemW.setPrefilledValue(s);\n+                    itemW.setAssuranceLevel(String.valueOf(extSourceLoa));\n+                }\n+\n+                // TRY TO CONSTRUCT THE VALUE FROM PARTIAL FED-INFO\n+\n+                ApplicationFormItem item = itemW.getFormItem();\n+                String sourceAttribute = item.getPerunSourceAttribute();\n+                if (URN_USER_TITLE_BEFORE.equals(sourceAttribute)) {\n+                    String titleBefore = parsedName.get(\"titleBefore\");\n+                    if (titleBefore != null && !titleBefore.trim().isEmpty()) {\n+                        itemW.setPrefilledValue(titleBefore);\n+                    }\n+                } else if (URN_USER_TITLE_AFTER.equals(sourceAttribute)) {\n+                    String titleAfter = parsedName.get(\"titleAfter\");\n+                    if (titleAfter != null && !titleAfter.trim().isEmpty()) {\n+                        itemW.setPrefilledValue(titleAfter);\n+                    }\n+                } else if (URN_USER_FIRST_NAME.equals(sourceAttribute)) {\n+                    String firstName = parsedName.get(\"firstName\");\n+                    if (firstName != null && !firstName.trim().isEmpty()) {\n+                        itemW.setPrefilledValue(firstName);\n+                    }\n+                } else if (URN_USER_MIDDLE_NAME.equals(sourceAttribute)) {\n+                    String middleName = parsedName.get(\"middleName\");\n+                    if (middleName != null && !middleName.trim().isEmpty()) {\n+                        itemW.setPrefilledValue(middleName);\n+                    } else {\n+                        itemW.setPrefilledValue(\"\");\n+                    }\n+                } else if (URN_USER_LAST_NAME.equals(sourceAttribute)) {\n+                    String lastName = parsedName.get(\"lastName\");\n+                    if (lastName != null && !lastName.trim().isEmpty()) {\n+                        itemW.setPrefilledValue(lastName);\n+                    }\n+                } else if (URN_USER_DISPLAY_NAME.equals(sourceAttribute)) {\n+\n+                    // overwrite only if not filled by Perun\n+                    if (itemW.getPrefilledValue() == null || itemW.getPrefilledValue().isEmpty()) {\n+\n+                        String displayName = \"\";\n+\n+                        if (parsedName.get(\"titleBefore\") != null && !parsedName.get(\"titleBefore\").isEmpty()) {\n+                            displayName += parsedName.get(\"titleBefore\");\n+                        }\n+\n+                        if (parsedName.get(\"firstName\") != null && !parsedName.get(\"firstName\").isEmpty()) {\n+                            if (!displayName.isEmpty()) {\n+                                displayName += \" \";\n+                            }\n+                            displayName += parsedName.get(\"firstName\");\n+                        }\n+                        if (parsedName.get(\"lastName\") != null && !parsedName.get(\"lastName\").isEmpty()) {\n+                            if (!displayName.isEmpty()) {\n+                                displayName += \" \";\n+                            }\n+                            displayName += parsedName.get(\"lastName\");\n+                        }\n+                        if (parsedName.get(\"titleAfter\") != null && !parsedName.get(\"titleAfter\").isEmpty()) {\n+                            if (!displayName.isEmpty()) {\n+                                displayName += \" \";\n+                            }\n+                            displayName += parsedName.get(\"titleAfter\");\n+                        }\n+\n+                        itemW.setPrefilledValue(displayName);\n+\n+                    }\n+\n+                }\n+\n+                // We do require value from IDP (federation) if attribute is supposed to be pre-filled and item is required and not editable to users\n+                if ((itemW.getPrefilledValue() == null || itemW.getPrefilledValue().isEmpty()) && itemW.getFormItem().isRequired() &&\n+                        (Type.FROM_FEDERATION_HIDDEN.equals(itemW.getFormItem().getType()) || Type.FROM_FEDERATION_SHOW.equals(itemW.getFormItem().getType()))) {\n+\n+                    if (URN_USER_DISPLAY_NAME.equals(item.getPerunDestinationAttribute())) {\n+                        log.error(\"Couldn't resolve displayName from: {}, parsedNames were: {}\", federValues, parsedName);\n+                    }\n+\n+                    itemsWithMissingData.add(itemW);\n+                }\n+\n+            }\n+        }\n+\n+        if (module != null) {\n+            module.processFormItemsWithData(sess, appType, form, itemsWithValues);\n+        }\n+\n+        if (!itemsWithMissingData.isEmpty() && extSourceType.equals(ExtSourcesManager.EXTSOURCE_IDP)) {\n+            // throw exception only if user is logged-in by Federation IDP\n+            String IDP = federValues.get(\"originIdentityProvider\");\n+            log.error(\"[REGISTRAR] IDP {} doesn't provide data for following form items: {}\", IDP, itemsWithMissingData);\n+            throw new MissingRequiredDataException(\"Your IDP doesn't provide data required by this application form.\", itemsWithMissingData);\n+        }\n+\n+        // return prefilled form\n+        return itemsWithValues;\n+\n+    }\n+\n+    /**\n+     * Check if user can submit application for specified form and type.\n+     * Performs check on VO/Group membership, VO/Group expiration rules, form modules and duplicate (already submitted) applications.\n+     *\n+     * @param sess    PerunSession for authz\n+     * @param appType Type of application form\n+     * @param form    Application form\n+     */\n+    private void checkDuplicateRegistrationAttempt(PerunSession sess, AppType appType, ApplicationForm form)\n+            throws DuplicateRegistrationAttemptException, AlreadyRegisteredException, PrivilegeException, ExtendMembershipException, RegistrarException, MemberNotExistsException, CantBeSubmittedException, NotGroupMemberException {\n+\n+        Vo vo = form.getVo();\n+        Group group = form.getGroup();\n+\n+        // get necessary params from session\n+        User user = sess.getPerunPrincipal().getUser();\n+        int extSourceLoa = sess.getPerunPrincipal().getExtSourceLoa();\n+\n+        if (AppType.INITIAL.equals(appType)) {\n+            if (user != null) {\n+                //user is known\n+                try {\n+                    Member m = membersManager.getMemberByUser(registrarSession, vo, user);\n+                    if (group != null) {\n+                        // get members groups\n+                        List<Group> g = groupsManager.getMemberGroups(registrarSession, m);\n+                        if (g.contains(group)) {\n+                            // user is member of group - can't post more initial applications\n+                            throw new AlreadyRegisteredException(\"You are already member of group \" + group.getName() + \".\");\n+                        } else {\n+                            checkDupplicateGroupApplications(sess, vo, group, AppType.INITIAL);\n+                            // pass if have approved or rejected app\n+                        }\n+                    } else {\n+                        // user is member of vo, can't post more initial applications\n+                        throw new AlreadyRegisteredException(\"You are already member of VO: \" + vo.getName());\n+                    }\n+                } catch (MemberNotExistsException ex) {\n+                    // user is not member of vo\n+                    if (group != null) {\n+                        checkDupplicateGroupApplications(sess, vo, group, AppType.INITIAL);\n+                        //throw new InternalErrorException(\"You must be member of vo: \"+vo.getName()+\" to apply for membership in group: \"+group.getName());\n+                    } else {\n+                        checkDupplicateVoApplications(sess, vo, AppType.INITIAL);\n+                        // pass not member and have only approved or rejected apps\n+                    }\n+                }\n+            } else {\n+                // user is not known\n+                if (group != null) {\n+                    checkDupplicateGroupApplications(sess, vo, group, AppType.INITIAL);\n+                    //throw new InternalErrorException(\"You must be member of vo: \"+vo.getName()+\" to apply for membership in group: \"+group.getName());\n+                } else {\n+                    checkDupplicateVoApplications(sess, vo, AppType.INITIAL);\n+                    // pass not member and have only approved or rejected apps\n+                }\n+            }\n+            // if false, throws exception with reason for GUI\n+            membersManager.canBeMemberWithReason(sess, vo, user, String.valueOf(extSourceLoa));\n+        }\n+        // if extension, user != null !!\n+        if (AppType.EXTENSION.equals(appType)) {\n+            if (user == null) {\n+                throw new RegistrarException(\"Trying to get extension application for non-existing user. Try to log-in with different identity.\");\n+            }\n+            // check for submitted registrations\n+            Member member = membersManager.getMemberByUser(sess, vo, user);\n+            if (group != null) {\n+                member = groupsManager.getGroupMemberById(registrarSession, group, member.getId());\n+                checkDupplicateGroupApplications(sess, vo, group, AppType.EXTENSION);\n+                // if false, throws exception with reason for GUI\n+                groupsManager.canExtendMembershipInGroupWithReason(sess, member, group);\n+                // vo sponsored members can extend in a group\n+            } else {\n+                checkDupplicateVoApplications(sess, vo, AppType.EXTENSION);\n+                // if false, throws exception with reason for GUI\n+                membersManager.canExtendMembershipWithReason(sess, member);\n+                // sponsored vo members cannot be extended in this way\n+                if (member.isSponsored()) {\n+                    throw new CantBeSubmittedException(\"Sponsored member cannot apply for membership extension, it must be extended by the sponsor.\");\n+                }\n+\n+            }\n+\n+        }\n+\n+    }\n+\n+    @Override\n+    public boolean validateEmailFromLink(Map<String, String> urlParameters) throws PerunException {\n+\n+        String idStr = urlParameters.get(\"i\");\n+        if (mailManager.getMessageAuthenticationCode(idStr).equals(urlParameters.get(\"m\"))) {\n+            int appDataId = Integer.parseInt(idStr, Character.MAX_RADIX);\n+            // validate mail\n+            jdbc.update(\"update application_data set assurance_level=1 where id = ?\", appDataId);\n+            Application app = getApplicationById(jdbc.queryForInt(\"select app_id from application_data where id = ?\", appDataId));\n+            if (app == null) {\n+                log.warn(\"Application for FormItemData ID: {} doesn't exists and therefore mail can't be verified.\", appDataId);\n+                throw new RegistrarException(\"Application doesn't exists and therefore mail can't be verified.\");\n+            }\n+\n+            // if application is already approved or rejected, fake OK on mail validation and do nothing\n+            if (Arrays.asList(AppState.APPROVED, AppState.REJECTED).contains(app.getState())) {\n+                return true;\n+            }\n+\n+            boolean verified = AppState.VERIFIED.equals(app.getState());\n+            if (AppState.NEW.equals(app.getState())) {\n+                // try to verify only new applications\n+                verified = tryToVerifyApplication(registrarSession, app);\n+            }\n+            if (verified) {\n+                // try to APPROVE only verified and only if auto approve\n+                try {\n+                    tryToAutoApproveApplication(registrarSession, app);\n+                } catch (PerunException ex) {\n+                    // when approval fails, we want this to be silently skipped, since for \"user\" called method did verified his mail address.\n+                    log.warn(\"We couldn't auto-approve application {}, because of error: {}\", app, ex);\n+                }\n+            }\n+            return true;\n+        }\n+        return false;\n+\n+    }\n+\n+    @Override\n+    public List<ApplicationFormItem> getFormItems(PerunSession sess, ApplicationForm form) throws PerunException {\n+        return getFormItems(sess, form, null);\n+    }\n+\n+    @Override\n+    public List<ApplicationFormItemData> getApplicationDataById(PerunSession sess, int appId) throws PrivilegeException, RegistrarException {\n+\n+        // this ensure authorization of user on application\n+        try {\n+            getApplicationById(sess, appId);\n+        } catch (PrivilegeException ex) {\n+            throw new PrivilegeException(sess, \"getApplicationDataById\");\n+        }\n+\n+        return jdbc.query(\"select id,item_id,shortname,value,assurance_level from application_data where app_id=?\",\n+                (resultSet, rowNum) -> {\n+                    ApplicationFormItemData data = new ApplicationFormItemData();\n+                    data.setId(resultSet.getInt(\"id\"));\n+                    data.setFormItem(getFormItemById(resultSet.getInt(\"item_id\")));\n+                    data.setShortname(resultSet.getString(\"shortname\"));\n+                    data.setValue(resultSet.getString(\"value\"));\n+                    data.setAssuranceLevel(resultSet.getString(\"assurance_level\"));\n+                    return data;\n+                }, appId);\n+\n+    }\n+\n+    @Override\n+    public void copyFormFromVoToVo(PerunSession sess, Vo fromVo, Vo toVo) throws PerunException {\n+        vosManager.checkVoExists(sess, fromVo);\n+        vosManager.checkVoExists(sess, toVo);\n+\n+        //Authorization\n+        if (!AuthzResolver.authorizedInternal(sess, \"copyFormFromVoToVo_Vo_Vo_policy\", fromVo) ||\n+                !AuthzResolver.authorizedInternal(sess, \"copyFormFromVoToVo_Vo_Vo_policy\", toVo)) {\n+            throw new PrivilegeException(sess, \"copyFormFromVoToVo\");\n+        }\n+\n+        List<ApplicationFormItem> items = getFormItems(sess, getFormForVo(fromVo));\n+        for (ApplicationFormItem item : items) {\n+            item.setOrdnum(null); // reset order, id is always new inside add method\n+            addFormItem(sess, getFormForVo(toVo), item);\n+        }\n+\n+    }\n+\n+    @Override\n+    public void copyFormFromVoToGroup(PerunSession sess, Vo fromVo, Group toGroup, boolean reverse) throws PerunException {\n+        vosManager.checkVoExists(sess, fromVo);\n+        groupsManager.checkGroupExists(sess, toGroup);\n+\n+        //Authorization\n+        if (!AuthzResolver.authorizedInternal(sess, \"source-copyFormFromVoToGroup_Vo_Group_Policy\", Collections.singletonList(fromVo))\n+                || !AuthzResolver.authorizedInternal(sess, \"destination-copyFormFromVoToGroup_Vo_Group_Policy\", Collections.singletonList(toGroup))) {\n+            throw new PrivilegeException(sess, \"copyFormFromVoToGroup\");\n+        }\n+\n+        if (reverse) {\n+\n+            // copy from group to VO\n+            List<ApplicationFormItem> items = getFormItems(sess, getFormForGroup(toGroup));\n+            for (ApplicationFormItem item : items) {\n+                item.setOrdnum(null); // reset order, id is always new inside add method\n+                addFormItem(sess, getFormForVo(fromVo), item);\n+            }\n+\n+        } else {\n+\n+            // copy from VO to group\n+            List<ApplicationFormItem> items = getFormItems(sess, getFormForVo(fromVo));\n+            for (ApplicationFormItem item : items) {\n+                item.setOrdnum(null); // reset order, id is always new inside add method\n+                addFormItem(sess, getFormForGroup(toGroup), item);\n+            }\n+\n+        }\n+\n+    }\n+\n+    @Override\n+    public void copyFormFromGroupToGroup(PerunSession sess, Group fromGroup, Group toGroup) throws PerunException {\n+        groupsManager.checkGroupExists(sess, fromGroup);\n+        groupsManager.checkGroupExists(sess, toGroup);\n+\n+        //Authorization\n+        if (!AuthzResolver.authorizedInternal(sess, \"source-copyFormFromGroupToGroup_Group_Group_policy\", Collections.singletonList(fromGroup))\n+                || !AuthzResolver.authorizedInternal(sess, \"destination-copyFormFromGroupToGroup_Group_Group_policy\", Collections.singletonList(toGroup))) {\n+            throw new PrivilegeException(sess, \"copyFormFromGroupToGroup\");\n+        }\n+\n+        List<ApplicationFormItem> items = getFormItems(sess, getFormForGroup(fromGroup));\n+        for (ApplicationFormItem item : items) {\n+            item.setOrdnum(null); // reset order, id is always new inside add method\n+            addFormItem(sess, getFormForGroup(toGroup), item);\n+        }\n+\n+    }\n+\n+    public void updateApplicationUser(PerunSession sess, Application app) {\n+\n+        jdbc.update(\"update application set user_id=?, modified_at=\" + Compatibility.getSysdate() + \", modified_by=? where id=?\",\n+                (app.getUser() != null) ? app.getUser().getId() : null,\n+                sess.getPerunPrincipal().getActor(),\n+                app.getId());\n+\n+    }\n+\n+    public void updateFormItemData(PerunSession sess, int appId, ApplicationFormItemData data) throws RegistrarException, PrivilegeException {\n+\n+        //Authorization\n+        if (!AuthzResolver.authorizedInternal(sess, \"updateFormItemData_int_ApplicationFormItemData_policy\")) {\n+            throw new PrivilegeException(sess, \"updateFormItemData\");\n+        }\n+\n+        Application app = getApplicationById(sess, appId);\n+        if (AppState.APPROVED.equals(app.getState()) || AppState.REJECTED.equals(app.getState())) {\n+            throw new RegistrarException(\"Form items of once approved or rejected applications can't be modified.\");\n+        }\n+\n+        ApplicationFormItemData existingData = getFormItemDataById(data.getId(), appId);\n+        if (existingData == null) {\n+            throw new RegistrarException(\"Form item data specified by ID: \" + data.getId() + \" not found or doesn't belong to the application \" + appId);\n+        }\n+\n+        List<Type> notAllowed = Arrays.asList(FROM_FEDERATION_HIDDEN, FROM_FEDERATION_SHOW, USERNAME, PASSWORD, HEADING, HTML_COMMENT, SUBMIT_BUTTON, AUTO_SUBMIT_BUTTON);\n+\n+        if (notAllowed.contains(existingData.getFormItem().getType())) {\n+            throw new RegistrarException(\"You are not allowed to modify \" + existingData.getFormItem().getType() + \" type of form items.\");\n+        }\n+\n+        updateFormItemData(sess, data);\n+\n+    }\n+\n+    @Transactional(rollbackFor = Exception.class)\n+    public void updateFormItemsData(PerunSession sess, int appId, List<ApplicationFormItemData> data) throws PerunException {\n+\n+        Application app = getApplicationById(appId);\n+\n+        if (app == null) {\n+            throw new InternalErrorException(\"Application with ID=\" + appId + \" doesn't exist.\");\n+        }\n+\n+        if (!AuthzResolver.selfAuthorizedForApplication(sess, app)) {\n+            throw new PrivilegeException(sess, \"updateFormItemsData\");\n+        }\n+\n+        if (AppState.APPROVED.equals(app.getState()) || AppState.REJECTED.equals(app.getState())) {\n+            throw new RegistrarException(\"Form items of once approved or rejected applications can't be modified.\");\n+        }\n+\n+        // no data to change\n+        if (data == null || data.isEmpty()) {\n+            return;\n+        }\n+\n+        for (ApplicationFormItemData dataItem : data) {\n+\n+            ApplicationFormItemData existingData = getFormItemDataById(dataItem.getId(), appId);\n+            if (existingData == null) {\n+                throw new RegistrarException(\"Form item data specified by ID: \" + dataItem.getId() + \" not found or doesn't belong to the application \" + appId);\n+            }\n+\n+            List<Type> notAllowed = Arrays.asList(FROM_FEDERATION_HIDDEN, FROM_FEDERATION_SHOW, USERNAME, PASSWORD, HEADING, HTML_COMMENT, SUBMIT_BUTTON, AUTO_SUBMIT_BUTTON);\n+\n+            if (notAllowed.contains(existingData.getFormItem().getType())) {\n+                throw new RegistrarException(\"You are not allowed to modify \" + existingData.getFormItem().getType() + \" type of form items.\");\n+            }\n+\n+            updateFormItemData(sess, dataItem);\n+\n+        }\n+\n+        // forcefully mark application as NEW and perform verification\n+        setApplicationState(sess, app.getId(), AppState.NEW);\n+\n+        // in case that user fixed own form, it should be possible to verify and approve it for auto-approval cases\n+        boolean verified = tryToVerifyApplication(sess, app);\n+        if (verified) {\n+            // try to APPROVE if auto approve\n+            tryToAutoApproveApplication(sess, app);\n+        } else {\n+            // send request validation notification\n+            getMailManager().sendMessage(app, MailType.MAIL_VALIDATION, null, null);\n+        }\n+\n+    }\n+\n+    private void updateFormItemData(PerunSession session, ApplicationFormItemData dataItem) {\n+        try {\n+            if (VALIDATED_EMAIL.equals(dataItem.getFormItem().getType())) {\n+                handleLoaForValidatedMail(session, dataItem);\n+            }\n+            int result = jdbc.update(\"update application_data set value=? , assurance_level=? where id=?\",\n+                    dataItem.getValue(), ((StringUtils.isBlank(dataItem.getAssuranceLevel())) ? null : dataItem.getAssuranceLevel()),\n+                    dataItem.getId());\n+            log.info(\"{} manually updated form item data {}\", session.getPerunPrincipal(), dataItem);\n+            if (result != 1) {\n+                throw new InternalErrorException(\"Unable to update form item data\");\n+            }\n+        } catch (RuntimeException ex) {\n+            throw new InternalErrorException(ex);\n+        }\n+    }\n+\n+    @Override\n+    public List<Application> filterPrincipalApplications(PerunSession sess, List<Application> applications) {\n+        // get necessary params from session\n+        PerunPrincipal principal = sess.getPerunPrincipal();\n+        User user = principal.getUser();\n+        String actor = principal.getActor();\n+        String extSourceName = principal.getExtSourceName();\n+        Map<String, String> additionalInformation = principal.getAdditionalInformations();\n+\n+        List<Application> filteredApplications = new ArrayList<>();\n+\n+        // filter principal's applications\n+        for (Application application : applications) {\n+            // check existing application by user\n+            if (user != null && application.getUser() != null && user.getId() == application.getUser().getId()) {\n+                filteredApplications.add(application);\n+            } else {\n+                //check existing application by additional identifiers\n+                String shibIdentityProvider = additionalInformation.get(UsersManagerBl.ORIGIN_IDENTITY_PROVIDER_KEY);\n+                if (shibIdentityProvider != null && extSourcesWithMultipleIdentifiers.contains(shibIdentityProvider)) {\n+                    String principalAdditionalIdentifiers = principal.getAdditionalInformations().get(UsersManagerBl.ADDITIONAL_IDENTIFIERS_ATTRIBUTE_NAME);\n+                    if (principalAdditionalIdentifiers == null) {\n+                        //This should not happen\n+                        throw new InternalErrorException(\"Entry \" + UsersManagerBl.ADDITIONAL_IDENTIFIERS_ATTRIBUTE_NAME + \" is not defined in the principal's additional information. Either it was not provided by external source used for sign-in or the mapping configuration is wrong.\");\n+                    }\n+                    LinkedHashMap<String, String> additionalFedAttributes = BeansUtils.stringToMapOfAttributes(application.getFedInfo());\n+                    String applicationAdditionalIdentifiers = additionalFedAttributes.get(UsersManagerBl.ADDITIONAL_IDENTIFIERS_ATTRIBUTE_NAME);\n+                    List<String> identifiersInIntersection = BeansUtils.additionalIdentifiersIntersection(principalAdditionalIdentifiers, applicationAdditionalIdentifiers);\n+                    if (!identifiersInIntersection.isEmpty()) {\n+                        filteredApplications.add(application);\n+                    }\n+                }\n+                //check existing application by extSourceName and extSource login\n+                else if (extSourceName.equals(application.getExtSourceName()) && actor.equals(application.getCreatedBy())) {\n+                    filteredApplications.add(application);\n+                }\n+            }\n+        }\n+        return filteredApplications;\n+    }\n+\n+    @Override\n+    public List<Application> filterUserApplications(PerunSession sess, User user, List<Application> applications) {\n+\n+        List<UserExtSource> userExtSources = usersManager.getUserExtSources(registrarSession, user);\n+\n+        List<Application> resultApps = new ArrayList<>();\n+\n+        for (Application application : applications) {\n+            //check based on user id\n+            if (application.getUser() != null && application.getUser().getId() == user.getId()) {\n+                resultApps.add(application);\n+                //check based on user extSources\n+            } else {\n+                for (UserExtSource ues : userExtSources) {\n+                    if (ues.getExtSource().getName().equals(application.getExtSourceName()) &&\n+                            ues.getExtSource().getType().equals(application.getExtSourceType())) {\n+                        //login check\n+                        if (ues.getLogin().equals(application.getCreatedBy())) {\n+                            resultApps.add(application);\n+                            break;\n+                        }\n+                        //additional identifiers check\n+                        try {\n+                            Attribute attribute = attrManager.getAttribute(sess, ues, UsersManagerBl.ADDITIONAL_IDENTIFIERS_PERUN_ATTRIBUTE_NAME);\n+                            if (attribute.getValue() != null) {\n+                                List<String> userIdentifiers = attribute.valueAsList();\n+                                // Creates Arrays from principal and application identifiers and makes intersection between them.\n+                                LinkedHashMap<String, String> additionalFedAttributes = BeansUtils.stringToMapOfAttributes(application.getFedInfo());\n+                                String applicationAdditionalIdentifiers = additionalFedAttributes.get(UsersManagerBl.ADDITIONAL_IDENTIFIERS_ATTRIBUTE_NAME);\n+                                String[] applicationIdentifiersArray = {};\n+                                if (applicationAdditionalIdentifiers != null) {\n+                                    applicationIdentifiersArray = applicationAdditionalIdentifiers.split(UsersManagerBl.MULTIVALUE_ATTRIBUTE_SEPARATOR_REGEX);\n+                                }\n+                                HashSet<String> principalIdentifiersSet = new HashSet<>(userIdentifiers);\n+                                principalIdentifiersSet.retainAll(Arrays.asList(applicationIdentifiersArray));\n+                                if (!principalIdentifiersSet.isEmpty()) {\n+                                    resultApps.add(application);\n+                                    break;\n+                                }\n+                            }\n+                        } catch (WrongAttributeAssignmentException | AttributeNotExistsException e) {\n+                            //We can ignore that\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        return resultApps;\n+    }\n+\n+    /**\n+     * Retrieve form item data by its ID or NULL if not exists.\n+     * It also expect, that item belongs to the passed application ID, if not, NULL is returned.\n+     *\n+     * @param formItemDataId ID of form item data entry\n+     * @param applicationId  ID of application this item belongs to\n+     * @return Form item with data submitted by the User.\n+     * @throws InternalErrorException When implementation fails\n+     */\n+    private ApplicationFormItemData getFormItemDataById(int formItemDataId, int applicationId) {\n+\n+        try {\n+            return jdbc.queryForObject(\"select id,item_id,shortname,value,assurance_level from application_data where id=? and app_id=?\",\n+                    (resultSet, rowNum) -> {\n+                        ApplicationFormItemData data = new ApplicationFormItemData();\n+                        data.setId(resultSet.getInt(\"id\"));\n+                        data.setFormItem(getFormItemById(resultSet.getInt(\"item_id\")));\n+                        data.setShortname(resultSet.getString(\"shortname\"));\n+                        data.setValue(resultSet.getString(\"value\"));\n+                        data.setAssuranceLevel(resultSet.getString(\"assurance_level\"));\n+                        return data;\n+                    }, formItemDataId, applicationId);\n+        } catch (EmptyResultDataAccessException ex) {\n+            return null;\n+        } catch (RuntimeException ex) {\n+            throw new InternalErrorException(\"Unable to get form item data by its ID:\" + formItemDataId + \" and application ID: \" + applicationId, ex);\n+        }\n+\n+    }\n+\n+    @Override\n+    public MailManager getMailManager() {\n+        return this.mailManager;\n+    }\n+\n+    @Override\n+    public ConsolidatorManager getConsolidatorManager() {\n+        return this.consolidatorManager;\n+    }\n+\n+    /**\n+     * Set application to VERIFIED state if all it's\n+     * mails (VALIDATED_EMAIL) have assuranceLevel >= 1 and have non-empty value (there is anything to validate).\n+     * Returns TRUE if succeeded, FALSE if some mail still waits for verification.\n+     *\n+     * @param sess user who try to verify application\n+     * @param app  application to verify\n+     * @return TRUE if verified / FALSE if not verified\n+     * @throws InternalErrorException\n+     */\n+    private boolean tryToVerifyApplication(PerunSession sess, Application app) throws PerunException {\n+\n+        // test all fields that may need to be validated and are not empty !!\n+        List<Integer> loas = jdbc.query(\"select d.assurance_level\" + Compatibility.castToInteger() + \" from application a, application_form_items i, application_data d \" +\n+                        \"where d.app_id=a.id and d.item_id=i.id and a.id=? and i.type=? and d.value is not null\",\n+                new SingleColumnRowMapper<>(Integer.class), app.getId(), Type.VALIDATED_EMAIL.toString());\n+\n+        boolean allValidated = true;\n+        for (Integer loa : loas) {\n+            // check on null only for backward compatibility, we now always set some value\n+            if (loa == null || loa < 1) {\n+                allValidated = false;\n+                break;\n+            }\n+        }\n+\n+        if (allValidated) {\n+            // mark VERIFIED\n+            markApplicationVerified(sess, app.getId());\n+            app.setState(AppState.VERIFIED);\n+        }\n+\n+        return allValidated;\n+\n+    }\n+\n+    /**\n+     * Forcefully marks application as VERIFIED\n+     * (only if was in NEW state before)\n+     *\n+     * @param sess  session info to use for modified_by\n+     * @param appId ID of application to verify.\n+     */\n+    private void markApplicationVerified(PerunSession sess, int appId) {\n+\n+        try {\n+            if (jdbc.update(\"update application set state=?, modified_at=\" + Compatibility.getSysdate() + \", modified_by=? where id=? and state=?\", AppState.VERIFIED.toString(), sess.getPerunPrincipal().getActor(), appId, AppState.NEW.toString()) > 0) {\n+                log.info(\"Application {} marked as VERIFIED\", appId);\n+            } else {\n+                log.info(\"Application {} not marked VERIFIED, was not in state NEW\", appId);\n+            }\n+        } catch (InternalErrorException ex) {\n+            log.error(\"Application {} NOT marked as VERIFIED due to error {}\", appId, ex);\n+        }\n+\n+    }\n+\n+    /**\n+     * Forcefully set application its state (NEW/VERIFIED/...)\n+     *\n+     * @param sess     PerunSession\n+     * @param appId    ID of application\n+     * @param appState AppState to be set\n+     */\n+    private void setApplicationState(PerunSession sess, int appId, AppState appState) {\n+        try {\n+            jdbc.update(\"update application set state=?, modified_at=\" + Compatibility.getSysdate() + \", modified_by=? where id=?\",\n+                    appState.toString(), sess.getPerunPrincipal().getActor(), appId);\n+        } catch (RuntimeException ex) {\n+            log.error(\"Unable to set application state: {}, to application ID: {}\", appState, appId, ex);\n+            throw new InternalErrorException(\"Unable to set application state: \" + appState + \" to application: \" + appId, ex);\n+        }\n+    }\n+\n+    /**\n+     * Try to approve application if auto-approve is possible\n+     *\n+     * @param sess user who try to approves application\n+     * @param app  application to approve\n+     * @throws InternalErrorException\n+     */\n+    private void tryToAutoApproveApplication(PerunSession sess, Application app) throws PerunException {\n+\n+        ApplicationForm form;\n+        if (app.getGroup() != null) {\n+            // group application\n+            form = getFormForGroup(app.getGroup());\n+        } else {\n+            // vo application\n+            form = getFormForVo(app.getVo());\n+        }\n+        AppType type = app.getType();\n+\n+        if (AppType.INITIAL.equals(type) && !form.isAutomaticApproval()) {\n+            return;\n+        }\n+        if (AppType.EXTENSION.equals(type) && !form.isAutomaticApprovalExtension()) {\n+            return;\n+        }\n+\n+        // do not auto-approve Group applications, if user is not member of VO\n+        if (app.getGroup() != null && app.getVo() != null) {\n+\n+            try {\n+                if (app.getUser() == null) {\n+                    LinkedHashMap<String, String> additionalAttributes = BeansUtils.stringToMapOfAttributes(app.getFedInfo());\n+                    PerunPrincipal applicationPrincipal = new PerunPrincipal(app.getCreatedBy(), app.getExtSourceName(), app.getExtSourceType(), app.getExtSourceLoa(), additionalAttributes);\n+                    User u = perun.getUsersManagerBl().getUserByExtSourceInformation(sess, applicationPrincipal);\n+                    if (u != null) {\n+                        membersManager.getMemberByUser(sess, app.getVo(), u);\n+                    } else {\n+                        // user not found or null, hence can't be member of VO -> do not approve.\n+                        return;\n+                    }\n+                } else {\n+                    // user known, but maybe not member of a vo\n+                    membersManager.getMemberByUser(sess, app.getVo(), app.getUser());\n+                }\n+            } catch (MemberNotExistsException ex) {\n+                return;\n+            } catch (UserNotExistsException ex) {\n+                return;\n+            } catch (UserExtSourceNotExistsException ex) {\n+                return;\n+            } catch (ExtSourceNotExistsException ex) {\n+                return;\n+            }\n+        }\n+\n+        try {\n+            if (AppState.VERIFIED.equals(app.getState())) {\n+                // with registrar session, since only VO admin can approve application\n+\n+                // check if can be approved (we normally call this manually from GUI before calling approve)\n+                canBeApproved(registrarSession, app);\n \n \t\t\t\t/*\n \n@@ -2901,927 +2978,938 @@ public class RegistrarManagerImpl implements RegistrarManager {\n \n \t\t\t\t*/\n \n-\t\t\t\t// other types of application doesn't create new user - continue\n-\t\t\t\tapproveApplication(registrarSession, app.getId());\n-\n-\t\t\t}\n-\t\t} catch (Exception ex) {\n-\n-\t\t\tArrayList<Exception> list = new ArrayList<>();\n-\t\t\tlist.add(ex);\n-\t\t\tgetMailManager().sendMessage(app, MailType.APP_ERROR_VO_ADMIN, null, list);\n-\n-\t\t\tthrow ex;\n-\t\t}\n-\n-\t}\n-\n-\t/**\n-\t * Retrieves whole application object from DB\n-\t * (authz in parent methods)\n-\t *\n-\t * @param appId ID of application to get\n-\t * @return application object / null if not exists\n-\t */\n-\tprivate Application getApplicationById(int appId) {\n-\t\ttry {\n-\t\t\treturn jdbc.queryForObject(APP_SELECT + \" where a.id=?\", APP_MAPPER, appId);\n-\t\t} catch (EmptyResultDataAccessException ex) {\n-\t\t\treturn null;\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Extract names for User from his federation attributes\n-\t *\n-\t * @param federValues map of federation attribute names to their value\n-\t * @return map with exctracted names\n-\t */\n-\tprivate Map<String, String> extractNames(Map<String, String> federValues) {\n-\n-\t\tString commonName = federValues.get(shibCommonNameVar);\n-\t\tString displayName = federValues.get(shibDisplayNameVar);\n-\n-\t\tMap<String, String> parsedName;\n-\t\tif (displayName != null && !displayName.isEmpty()) {\n-\t\t\tparsedName = Utils.parseCommonName(displayName);\n-\t\t} else if (commonName != null && !commonName.isEmpty()) {\n-\t\t\tparsedName = Utils.parseCommonName(commonName);\n-\t\t} else {\n-\t\t\tparsedName = new HashMap<>();\n-\t\t}\n-\t\t// if the idp provided first name or last name, always use it\n-\t\tString fedFirstName = federValues.get(shibFirstNameVar);\n-\t\tString fedLastName = federValues.get(shibLastNameVar);\n-\n-\t\tsetIfNotEmpty(parsedName, fedFirstName, \"firstName\");\n-\t\tsetIfNotEmpty(parsedName, fedLastName, \"lastName\");\n-\n-\t\t// do new parsing heuristic\n-\t\tCandidate candidate = new Candidate();\n-\t\tif (displayName != null && !displayName.isEmpty() &&\n-\t\t\t\tfedFirstName != null && !fedFirstName.isEmpty() &&\n-\t\t\t\tfedLastName != null && !fedLastName.isEmpty()) {\n-\t\t\tparseTitlesAndMiddleName(candidate, displayName, fedFirstName, fedLastName);\n-\t\t}\n-\n-\t\tsetIfNotEmpty(parsedName, candidate.getMiddleName(), \"middleName\");\n-\t\tsetIfNotEmpty(parsedName, candidate.getTitleBefore(), \"titleBefore\");\n-\t\tsetIfNotEmpty(parsedName, candidate.getTitleAfter(), \"titleAfter\");\n-\n-\t\treturn parsedName;\n-\n-\t}\n-\n-\t/**\n-\t * If the given value is not null and not empty, put it in the given map with the given key.\n-\t *\n-\t * @param map map\n-\t * @param value value which is checked\n-\t * @param key key\n-\t */\n-\tprivate void setIfNotEmpty(Map<String, String> map, String value, String key) {\n-\t\tif (value != null && !value.isEmpty()) {\n-\t\t\tmap.put(key, value);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Return RegistrarModule for specific application form (VO or Group)\n-\t * so it can be used for more actions.\n-\t *\n-\t * @param form application form\n-\t * @return RegistrarModule if present or null\n-\t */\n-\tprivate RegistrarModule getRegistrarModule(ApplicationForm form) {\n-\n-\t\tif (form == null) {\n-\t\t\t// wrong input\n-\t\t\tlog.error(\"[REGISTRAR] Application form is null when getting it's registrar module.\");\n-\t\t\tthrow new NullPointerException(\"Application form is null when getting it's registrar module.\");\n-\t\t}\n-\n-\t\tif (form.getModuleClassName() != null && !form.getModuleClassName().trim().isEmpty()) {\n-\n-\t\t\tRegistrarModule module = null;\n-\n-\t\t\ttry {\n-\t\t\t\tlog.debug(\"[REGISTRAR] Attempting to instantiate class: {}\", MODULE_PACKAGE_PATH + form.getModuleClassName());\n-\t\t\t\tmodule = (RegistrarModule) Class.forName(MODULE_PACKAGE_PATH + form.getModuleClassName()).newInstance();\n-\t\t\t\tmodule.setRegistrar(registrarManager);\n-\t\t\t} catch (Exception ex) {\n-\t\t\t\tlog.error(\"[REGISTRAR] Exception when instantiating module.\", ex);\n-\t\t\t\treturn module;\n-\t\t\t}\n-\t\t\tlog.debug(\"[REGISTRAR] Class {} successfully created.\", MODULE_PACKAGE_PATH + form.getModuleClassName());\n-\n-\t\t\treturn module;\n-\n-\t\t}\n-\n-\t\treturn null;\n-\n-\t}\n-\n-\t/**\n-\t * If titles before / after name are part of application form and User exists,\n-\t * update titles for user according to application.\n-\t *\n-\t * This method doesn't clear titles from users name if sent empty in order to prevent\n-\t * accidental removal when user log-in with different IDP without titles provided.\n-\t *\n-\t * @param app Application to update user's titles for.\n-\t */\n-\tprivate void updateUserNameTitles(Application app) {\n-\n-\t\ttry {\n-\n-\t\t\tUser user = usersManager.getUserById(registrarSession, app.getUser().getId());\n-\t\t\tList<ApplicationFormItemData> data = registrarManager.getApplicationDataById(registrarSession, app.getId());\n-\t\t\tboolean found = false;\n-\n-\t\t\t// first check for display name\n-\t\t\tfor (ApplicationFormItemData item : data) {\n-\t\t\t\tif (URN_USER_DISPLAY_NAME.equals(item.getFormItem().getPerunDestinationAttribute())) {\n-\t\t\t\t\tif (item.getValue() != null && !item.getValue().isEmpty()) {\n-\t\t\t\t\t\tMap<String, String> commonName = Utils.parseCommonName(item.getValue());\n-\t\t\t\t\t\tif (commonName.get(\"titleBefore\") != null && !commonName.get(\"titleBefore\").isEmpty()) {\n-\t\t\t\t\t\t\tuser.setTitleBefore(commonName.get(\"titleBefore\"));\n-\t\t\t\t\t\t\tfound = true;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tif (commonName.get(\"titleAfter\") != null && !commonName.get(\"titleAfter\").isEmpty()) {\n-\t\t\t\t\t\t\tuser.setTitleAfter(commonName.get(\"titleAfter\"));\n-\t\t\t\t\t\t\tfound = true;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t// overwrite by specific before/after name title\n-\t\t\tfor (ApplicationFormItemData item : data) {\n-\t\t\t\tif (URN_USER_TITLE_BEFORE.equals(item.getFormItem().getPerunDestinationAttribute())) {\n-\t\t\t\t\tif (item.getValue() != null && !item.getValue().isEmpty()) {\n-\t\t\t\t\t\tuser.setTitleBefore(item.getValue());\n-\t\t\t\t\t\tfound = true;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tif (URN_USER_TITLE_AFTER.equals(item.getFormItem().getPerunDestinationAttribute())) {\n-\t\t\t\t\tif (item.getValue() != null && !item.getValue().isEmpty()) {\n-\t\t\t\t\t\tuser.setTitleAfter(item.getValue());\n-\t\t\t\t\t\tfound = true;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t// titles were part of application form\n-\t\t\tif (found) {\n-\t\t\t\tlog.debug(\"[REGISTRAR] User to update titles: {}\", user);\n-\t\t\t\tusersManager.updateNameTitles(registrarSession, user);\n-\t\t\t}\n-\n-\t\t} catch (Exception ex) {\n-\t\t\tlog.error(\"[REGISTRAR] Exception when updating titles.\", ex);\n-\t\t}\n-\n-\t}\n-\n-\t/**\n-\t * Store values from application data as user/member attributes\n-\t *\n-\t * New values are set if old are empty, or merged if not empty.\n-\t * Empty new values are skipped (not even merged) as well as core attributes.\n-\t *\n-\t * User and Member must already exists !!\n-\t *\n-\t * !! LOGIN ATTRIBUTES ARE SKIPPED BY THIS METHOD AND MUST BE\n-\t * SET LATER BY storeApplicationLoginAttributes() METHOD !!\n-\t * !! USE unreserveNewLoginsFromSameNamespace() BEFORE DOING SO !!\n-\t *\n-\t * @param app Application to process attributes for\n-\t * @throws UserNotExistsException When User present in Application not exists\n-\t * @throws InternalErrorException When implementation fails\n-\t * @throws PrivilegeException When caller is not authorized for some action\n-\t * @throws MemberNotExistsException When Member resolved from VO/User from Application doesn't exist\n-\t * @throws VoNotExistsException When VO resolved from application doesn't exist\n-\t * @throws RegistrarException When implementation fails\n-\t * @throws AttributeNotExistsException When expected attribute doesn't exists\n-\t * @throws WrongAttributeAssignmentException When attribute can't be stored because of wrongly passed params\n-\t * @throws WrongAttributeValueException  When attribute can't be stored because of wrong value\n-\t * @throws WrongReferenceAttributeValueException  When attribute can't be stored because of some specific dynamic constraint (from attribute module)\n-\t */\n-\tprivate void storeApplicationAttributes(Application app) throws UserNotExistsException, PrivilegeException, MemberNotExistsException, VoNotExistsException, RegistrarException, AttributeNotExistsException, WrongAttributeAssignmentException, WrongAttributeValueException, WrongReferenceAttributeValueException {\n-\n-\t\t// user and member must exists if it's extension !!\n-\t\tUser user = usersManager.getUserById(registrarSession, app.getUser().getId());\n-\t\tMember member = membersManager.getMemberByUser(registrarSession, app.getVo(), user);\n-\n-\t\t// get all app items\n-\t\tList<ApplicationFormItemData> items = getApplicationDataById(registrarSession, app.getId());\n-\n-\t\t// attributes to set\n-\t\tList<Attribute> attributes = new ArrayList<>();\n-\t\tfor (ApplicationFormItemData item : items) {\n-\t\t\tString destAttr = item.getFormItem().getPerunDestinationAttribute();\n-\t\t\tString newValue = item.getValue();\n-\t\t\t// do not store null or empty values at all\n-\t\t\tif (newValue == null || newValue.isEmpty()) continue;\n-\t\t\t// if correct destination attribute\n-\t\t\tif (destAttr != null && !destAttr.isEmpty()) {\n-\t\t\t\t// get attribute (for user and member only)\n-\t\t\t\tAttribute a;\n-\t\t\t\tif (destAttr.contains(\"urn:perun:user:\")) {\n-\t\t\t\t\ta = attrManager.getAttribute(registrarSession, user, destAttr);\n-\t\t\t\t} else if (destAttr.contains(\"urn:perun:member:\")) {\n-\t\t\t\t\ta = attrManager.getAttribute(registrarSession, member, destAttr);\n-\t\t\t\t} else {\n-\t\t\t\t\tcontinue;\n-\t\t\t\t}\n-\n-\t\t\t\t// NEVER STORE LOGINS THIS WAY TO PREVENT ACCIDENTAL OVERWRITE\n-\t\t\t\tif (a != null && \"login-namespace\".equals(a.getBaseFriendlyName())) {\n-\t\t\t\t\tcontinue;\n-\t\t\t\t}\n-\n-\t\t\t\t// if attribute exists\n-\t\t\t\tif (a != null) {\n-\t\t\t\t\tif (a.getType().equalsIgnoreCase(LinkedHashMap.class.getName())) {\n-\t\t\t\t\t\t// FIXME do not set hash map attributes - not supported in GUI and registrar\n-\t\t\t\t\t\tcontinue;\n-\t\t\t\t\t} else if (a.getType().equalsIgnoreCase(ArrayList.class.getName()) || a.getType().equalsIgnoreCase(BeansUtils.largeArrayListClassName)) {\n-\t\t\t\t\t\t// we expects that list contains strings\n-\t\t\t\t\t\tArrayList<String> value = a.valueAsList();\n-\t\t\t\t\t\t// if value not present in list => add\n-\t\t\t\t\t\tif (value == null) {\n-\t\t\t\t\t\t\t// set as new value\n-\t\t\t\t\t\t\tvalue = new ArrayList<>();\n-\t\t\t\t\t\t\tvalue.add(newValue);\n-\t\t\t\t\t\t} else if (!value.contains(newValue)) {\n-\t\t\t\t\t\t\t// add value between old values\n-\t\t\t\t\t\t\tvalue.add(newValue);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\ta.setValue(value);\n-\t\t\t\t\t\tattributes.add(a);\n-\t\t\t\t\t\tcontinue;\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\t// other attributes are handled like strings\n-\t\t\t\t\t\ta.setValue(newValue);\n-\t\t\t\t\t\tattributes.add(a);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\t// set attributes\n-\t\tif (!attributes.isEmpty()) {\n-\t\t\t// set them if not empty (member+user)\n-\t\t\tattrManager.setAttributes(registrarSession, member, attributes, true);\n-\t\t}\n-\n-\t}\n-\n-\t/**\n-\t * Store only login attributes from application to user.\n-\t *\n-\t * New values are set only if old are empty to prevent overwrite when joining identities.\n-\t * Empty new values are skipped.\n-\t *\n-\t * User must already exists !!\n-\t *\n-\t * @param app Application to process attributes for\n-\t * @throws UserNotExistsException When User present in Application not exists\n-\t * @throws InternalErrorException When implementation fails\n-\t * @throws PrivilegeException When caller is not authorized for some action\n-\t * @throws RegistrarException When implementation fails\n-\t * @throws AttributeNotExistsException When expected attribute doesn't exists\n-\t * @throws WrongAttributeAssignmentException When login can't be stored because of wrongly passed params\n-\t * @throws WrongAttributeValueException  When login can't be stored because of wrong value\n-\t * @throws WrongReferenceAttributeValueException  When login can't be stored because of some specific dynamic constraint (from attribute module)\n-\t */\n-\tprivate void storeApplicationLoginAttributes(Application app) throws UserNotExistsException, PrivilegeException, RegistrarException, AttributeNotExistsException, WrongAttributeAssignmentException, WrongAttributeValueException, WrongReferenceAttributeValueException {\n-\n-\t\t// user must exists\n-\t\tUser user = usersManager.getUserById(registrarSession, app.getUser().getId());\n-\n-\t\t// get all app items\n-\t\tList<ApplicationFormItemData> items = getApplicationDataById(registrarSession, app.getId());\n-\n-\t\t// attributes to set\n-\t\tList<Attribute> attributes = new ArrayList<>();\n-\t\tfor (ApplicationFormItemData item : items) {\n-\t\t\tString destAttr = item.getFormItem().getPerunDestinationAttribute();\n-\t\t\tString newValue = item.getValue();\n-\t\t\t// do not store null or empty values at all\n-\t\t\tif (newValue == null || newValue.isEmpty()) continue;\n-\t\t\t// if correct destination attribute\n-\t\t\tif (destAttr != null && !destAttr.isEmpty()) {\n-\t\t\t\t// get login attribute (for user only)\n-\t\t\t\tAttribute a;\n-\t\t\t\tif (destAttr.contains(AttributesManager.NS_USER_ATTR_DEF+\":login-namespace:\")) {\n-\t\t\t\t\ta = attrManager.getAttribute(registrarSession, user, destAttr);\n-\t\t\t\t} else {\n-\t\t\t\t\tcontinue;\n-\t\t\t\t}\n-\n-\t\t\t\t// if attribute exists\n-\t\t\t\tif (a != null) {\n-\t\t\t\t\tif (StringUtils.isBlank(a.valueAsString())) {\n-\t\t\t\t\t\t// set login attribute if initial (new) value\n-\t\t\t\t\t\ta.setValue(newValue);\n-\t\t\t\t\t\tattributes.add(a);\n-\t\t\t\t\t}\n-\t\t\t\t\t// skip if login already existed continue\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\t// set attributes\n-\t\tif (!attributes.isEmpty()) {\n-\t\t\t// set them if not empty (user)\n-\t\t\tattrManager.setAttributes(registrarSession, user, attributes);\n-\t\t}\n-\n-\t}\n-\n-\t/**\n-\t * Unreserve new login/password from KDC if user already have login in same namespace\n-\t *\n-\t * !! must be called before setting new attributes from application !!\n-\t *\n-\t * @param logins list of all new logins/namespaces pairs passed by application\n-\t * @param user user to check logins for\n-\t *\n-\t * @return List of login/namespace pairs which are purely new and can be set to user and validated in KDC\n-\t */\n-\tprivate List<Pair<String, String>> unreserveNewLoginsFromSameNamespace(List<Pair<String, String>> logins, User user) throws PasswordDeletionFailedException, PasswordOperationTimeoutException, LoginNotExistsException, InvalidLoginException {\n-\n-\t\tList<Pair<String, String>> result = new ArrayList<>();\n-\n-\t\tList<Attribute> loginAttrs = perun.getAttributesManagerBl().getLogins(registrarSession, user);\n-\n-\t\tfor (Pair<String, String> pair : logins) {\n-\t\t\tboolean found = false;\n-\t\t\tfor (Attribute a : loginAttrs) {\n-\t\t\t\tif (pair.getLeft().equals(a.getFriendlyNameParameter())) {\n-\t\t\t\t\t// old login found in same namespace => unreserve new login from KDC\n-\t\t\t\t\tusersManager.deletePassword(registrarSession, pair.getRight(), pair.getLeft());\n-\t\t\t\t\tlog.debug(\"[REGISTRAR] Unreserving new login: {} in namespace: {} since user already have login: {} in same namespace.\"\n-\t\t\t\t\t\t\t, pair.getRight(), pair.getLeft(), a.getValue());\n-\t\t\t\t\tfound = true;\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tif (!found) {\n-\t\t\t\t// login is purely new\n-\t\t\t\tresult.add(pair);\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn result;\n-\n-\t}\n-\n-\t/**\n-\t * Try to approve all group applications of user with auto-approval (even by user-ext-source)\n-\t * in specified VO.\n-\t *\n-\t * @param sess PerunSession\n-\t * @param vo VO to approve group applications in\n-\t * @param user user to approve applications for\n-\t */\n-\tprivate void autoApproveUsersGroupApplications(PerunSession sess, Vo vo, User user) throws PerunException {\n-\n-\t\t// get group apps based on the vo\n-\t\tList<Application> apps = jdbc.query(\n-\t\t\tAPP_SELECT + \" where a.vo_id=? and a.group_id is not null and a.state=?\",\n-\t\t\tAPP_MAPPER, vo.getId(), AppState.VERIFIED.toString());\n-\n-\t\t//filter only user's apps\n-\t\tList<Application> applications = filterUserApplications(sess, user, apps);\n-\n-\t\tfor (Application a : applications) {\n-\t\t\t// if new => skipp user will approve automatically by verifying email\n-\t\t\tif (a.getState().equals(AppState.NEW)) continue;\n-\n-\t\t\t// approve applications only for auto-approve forms\n-\t\t\tif (!getFormForGroup(a.getGroup()).isAutomaticApproval() && AppType.INITIAL.equals(a.getType())) continue;\n-\t\t\tif (!getFormForGroup(a.getGroup()).isAutomaticApprovalExtension() && AppType.EXTENSION.equals(a.getType())) continue;\n-\n-\t\t\ttry {\n-\t\t\t\tregistrarManager.approveApplicationInternal(sess, a.getId());\n-\t\t\t} catch (RegistrarException ex) {\n-\t\t\t\t// case when user have UNVERIFIED group application\n-\t\t\t\t// will be approved when user verify his email\n-\t\t\t\tlog.error(\"[REGISTRAR] Can't auto-approve group application after vo app approval because of exception.\", ex);\n-\t\t\t}\n-\n-\t\t}\n-\n-\t}\n-\n-\t/**\n-\t * Return string representation (key) of application used for locking main operations like \"create/verify/approve/reject\".\n-\t *\n-\t * @param application Application to get key for\n-\t * @return Key for Application\n-\t */\n-\tprivate String getLockKeyForApplication(Application application) {\n-\n-\t\treturn application.getType().toString() +\n-\t\t\t\tapplication.getVo().getShortName() +\n-\t\t\t\t((application.getGroup() != null) ? application.getGroup().getName() : \"nogroup\") +\n-\t\t\t\tapplication.getCreatedBy()+application.getExtSourceName()+application.getExtSourceType();\n-\n-\t}\n-\n-\t/**\n-\t * If user provided value is the same as was pre-filled from Perun, then we set LOA=2\n-\t * If user provided value is between those provided by Federation, then we keep provided LOA (0 will require mail validation, >0 will skip it).\n-\t * If user provided value is not between any of pre-filled values, then we set LOA=0 to require validation.\n-\t *\n-\t * @param session\n-\t * @param itemData\n-\t */\n-\tprivate void handleLoaForValidatedMail(PerunSession session, ApplicationFormItemData itemData) {\n-\n-\t\t// all mails from federation (lowercased)\n-\t\tList<String> mailsFromFed = new ArrayList<>();\n-\t\tString mailsFed = session.getPerunPrincipal().getAdditionalInformations().get(\"mail\");\n-\t\tif (StringUtils.isNotBlank(mailsFed)) {\n-\t\t\tmailsFromFed.addAll(Arrays.stream(mailsFed.split(\";\")).map(String::toLowerCase).collect(Collectors.toList()));\n-\t\t}\n-\n-\t\t// all prefilled mails (lowercased)\n-\t\tList<String> prefilledValues = new ArrayList<>();\n-\t\tif (StringUtils.isNotBlank(itemData.getPrefilledValue())) {\n-\t\t\tprefilledValues.addAll(Arrays.stream(itemData.getPrefilledValue().split(\";\")).map(String::toLowerCase).collect(Collectors.toList()));\n-\t\t}\n-\n-\t\t// value(s) pre-filled from perun\n-\t\tList<String> valuesFromPerun = new ArrayList<>(prefilledValues);\n-\t\tfor (String fromFed : mailsFromFed) {\n-\t\t\tvaluesFromPerun.remove(fromFed);\n-\t\t}\n-\n-\t\tString actualValue = (StringUtils.isNotBlank(itemData.getValue())) ? itemData.getValue().toLowerCase() : null;\n-\n-\t\tif (valuesFromPerun.contains(actualValue)) {\n-\t\t\t// override incoming LOA, since it was from perun\n-\t\t\titemData.setAssuranceLevel(\"2\");\n-\t\t} else if (!prefilledValues.contains(actualValue)) {\n-\t\t\t// clearing LoA to 0, since value is a new\n-\t\t\titemData.setAssuranceLevel(\"0\");\n-\t\t}\n-\n-\t\t// or else keep incoming LoA since it was one of pre-filled values from Federation.\n-\n-\t\t// normalize empty value\n-\t\tif (StringUtils.isBlank(itemData.getValue())) {\n-\t\t\titemData.setValue(null);\n-\t\t}\n-\n-\t}\n-\n-\t/**\n-\t * Method creates a candidate object from application according to the application id.\n-\t *\n-\t * @param app the application\n-\t * @return Candidate\n-\t */\n-\tprivate Candidate createCandidateFromApplicationData(Application app) {\n-\t\t// put application data into Candidate\n-\t\tfinal Map<String, String> attributes = new HashMap<>();\n-\t\tjdbc.query(\"select dst_attr,value from application_data d, application_form_items i where d.item_id=i.id \"\n-\t\t\t\t+ \"and i.dst_attr is not null and d.value is not null and app_id=?\",\n-\t\t\t(resultSet, i) -> {\n-\t\t\t\tattributes.put(resultSet.getString(\"dst_attr\"), resultSet.getString(\"value\"));\n-\t\t\t\treturn null;\n-\t\t\t}, app.getId());\n-\n-\t\tMap<String, String> fedData = BeansUtils.stringToMapOfAttributes(app.getFedInfo());\n-\n-\t\t// DO NOT STORE LOGINS THROUGH CANDIDATE\n-\t\t// we do not set logins by candidate object to prevent accidental overwrite while joining identities in process\n-\t\tattributes.entrySet().removeIf(entry -> entry.getKey().contains(\"urn:perun:user:attribute-def:def:login-namespace:\"));\n-\n-\t\tCandidate candidate = new Candidate();\n-\t\tcandidate.setAttributes(attributes);\n-\n-\t\tlog.debug(\"[REGISTRAR] Retrieved candidate from DB {}\", candidate);\n-\n-\t\t// first try to parse display_name if not null and not empty\n-\t\tparseNamesFromDisplayNameAndFedInfo(candidate, attributes, fedData);\n-\n-\t\t// if names are separated, used them after\n-\t\tfor (String attrName : attributes.keySet()) {\n-\t\t\t// if value not null or empty - set to candidate\n-\t\t\tif (attributes.get(attrName) != null\n-\t\t\t\t&& !attributes.get(attrName).isEmpty()) {\n-\t\t\t\tif (URN_USER_TITLE_BEFORE.equals(attrName)) {\n-\t\t\t\t\tcandidate.setTitleBefore(attributes.get(attrName));\n-\t\t\t\t} else if (URN_USER_TITLE_AFTER.equals(attrName)) {\n-\t\t\t\t\tcandidate.setTitleAfter(attributes.get(attrName));\n-\t\t\t\t} else if (URN_USER_FIRST_NAME.equals(attrName)) {\n-\t\t\t\t\tcandidate.setFirstName(attributes.get(attrName));\n-\t\t\t\t} else if (URN_USER_LAST_NAME.equals(attrName)) {\n-\t\t\t\t\tcandidate.setLastName(attributes.get(attrName));\n-\t\t\t\t} else if (URN_USER_MIDDLE_NAME.equals(attrName)) {\n-\t\t\t\t\tcandidate.setMiddleName(attributes.get(attrName));\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn candidate;\n-\t}\n-\n-\tpublic void parseNamesFromDisplayName(Candidate candidate, Map<String, String> attributes) {\n-\t\tif (containsNonEmptyValue(attributes, URN_USER_DISPLAY_NAME)) {\n-\t\t\t// parse\n-\t\t\tMap<String, String> commonName = Utils.parseCommonName(attributes.get(URN_USER_DISPLAY_NAME));\n-\t\t\tif (commonName.get(\"titleBefore\") != null\n-\t\t\t\t&& !commonName.get(\"titleBefore\").isEmpty()) {\n-\t\t\t\tcandidate.setTitleBefore(commonName.get(\"titleBefore\"));\n-\t\t\t}\n-\t\t\tif (commonName.get(\"firstName\") != null\n-\t\t\t\t&& !commonName.get(\"firstName\").isEmpty()) {\n-\t\t\t\tcandidate.setFirstName(commonName.get(\"firstName\"));\n-\t\t\t}\n-\t\t\t// FIXME - ? there is no middleName in Utils.parseCommonName() implementation\n-\t\t\tif (commonName.get(\"middleName\") != null\n-\t\t\t\t&& !commonName.get(\"middleName\").isEmpty()) {\n-\t\t\t\tcandidate.setMiddleName(commonName.get(\"middleName\"));\n-\t\t\t}\n-\t\t\tif (commonName.get(\"lastName\") != null\n-\t\t\t\t&& !commonName.get(\"lastName\").isEmpty()) {\n-\t\t\t\tcandidate.setLastName(commonName.get(\"lastName\"));\n-\t\t\t}\n-\t\t\tif (commonName.get(\"titleAfter\") != null\n-\t\t\t\t&& !commonName.get(\"titleAfter\").isEmpty()) {\n-\t\t\t\tcandidate.setTitleAfter(commonName.get(\"titleAfter\"));\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Check if the given fed info contains givenName and sn (surname). If so,\n-\t * it sets it to the candidate and tries to match titles and middle name from\n-\t * display name.\n-\t *\n-\t * @param candidate candidate\n-\t * @param attributes attributes with values\n-\t * @param fedInfo key-value info from idp\n-\t */\n-\tpublic void parseNamesFromDisplayNameAndFedInfo(Candidate candidate, Map<String, String> attributes,\n-\t                                                Map<String, String> fedInfo) {\n-\t\tif (fedInfo != null && containsNonEmptyValue(fedInfo, shibFirstNameVar) &&\n-\t\t\t\tcontainsNonEmptyValue(fedInfo, shibLastNameVar)) {\n-\t\t\tString firstName = fedInfo.get(shibFirstNameVar);\n-\t\t\tString lastName = fedInfo.get(shibLastNameVar);\n-\n-\t\t\tcandidate.setFirstName(firstName);\n-\t\t\tcandidate.setLastName(lastName);\n-\n-\t\t\ttryToParseTitlesAndMiddleName(candidate, attributes, firstName, lastName);\n-\t\t} else {\n-\t\t\tparseNamesFromDisplayName(candidate, attributes);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * If the given map of attributes contains a user display name, it tries to match\n-\t * the given firstName and lastName and find titles and middle name.\n-\t *\n-\t * @param candidate candidate\n-\t * @param attributes map of attributes with values\n-\t * @param firstName first name to match\n-\t * @param lastName last name to match\n-\t */\n-\tprivate void tryToParseTitlesAndMiddleName(Candidate candidate, Map<String, String> attributes, String firstName,\n-\t                                           String lastName) {\n-\t\tif (containsNonEmptyValue(attributes, URN_USER_DISPLAY_NAME)) {\n-\t\t\tString displayName = attributes.get(URN_USER_DISPLAY_NAME);\n-\t\t\tparseTitlesAndMiddleName(candidate, displayName, firstName, lastName);\n-\t\t}\n-\t}\n-\n-\tprivate void parseTitlesAndMiddleName(Candidate candidate, String displayName, String firstName, String lastName) {\n-\t\tPattern pattern = getNamesPattern(firstName, lastName);\n-\t\tif (!tryToParseTitlesAndMiddleNameFromPattern(candidate, displayName, pattern, firstName)) {\n-\t\t\tPattern reversePattern = getNamesPattern(lastName, firstName);\n-\t\t\ttryToParseTitlesAndMiddleNameFromPattern(candidate, displayName, reversePattern, lastName);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Tries to match the given pattern to the given display name. If it matches, its sets\n-\t * titles and middle name from matcher of the given pattern to the given candidate.\n-\t *\n-\t * This method expects the pattern to define 3 groups in order - 1. Titles before, 2. Middle name, 3. Titles after\n-\t *\n-\t * @param candidate candidate\n-\t * @param displayName display name\n-\t * @param pattern pattern with 3 matching groups\n-\t * @return true, if the matcher matched\n-\t */\n-\tprivate boolean tryToParseTitlesAndMiddleNameFromPattern(Candidate candidate, String displayName, Pattern pattern, String firstName) {\n-\t\tMatcher matcher = pattern.matcher(displayName);\n-\t\tif (!matcher.matches()) {\n-\t\t\treturn false;\n-\t\t}\n-\t\tif (matcher.groupCount() != 3) {\n-\t\t\tthrow new InternalErrorException(\"Expected pattern with 3 groups to match - titles before, middle name and \" +\n-\t\t\t\t\t\"titles after, but get \" + matcher.groupCount() + \" groups.\" );\n-\t\t}\n-\n-\t\t// if the middle name equals to the first name placed in displayName (it can be firstName or lastName too)\n-\t\tif (matcher.group(1).contains(firstName)) {\n-\t\t\tcandidate.setTitleBefore(matcher.group(1).split(firstName)[0].trim());\n-\t\t\tcandidate.setMiddleName(firstName);\n-\t\t} else {\n-\t\t\tparseTitlesBefore(candidate, matcher.group(1).trim());\n-\t\t\tparseMiddleName(candidate, matcher.group(2).trim());\n-\t\t}\n-\t\tparseTitlesAfter(candidate, matcher.group(3).trim());\n-\n-\t\treturn true;\n-\t}\n-\n-\t/**\n-\t * To given candidate, sets titleBefore from trim of given value, or null if empty.\n-\t *\n-\t * @param candidate candidate\n-\t * @param value value\n-\t */\n-\tprivate void parseTitlesBefore(Candidate candidate, String value) {\n-\t\tcandidate.setTitleBefore(alnumPattern.matcher(value).matches() ? value : null);\n-\t}\n-\n-\t/**\n-\t * To given candidate, sets middle name from trim of given value.\n-\t * @param candidate candidate\n-\t * @param value value\n-\t */\n-\tprivate void parseMiddleName(Candidate candidate, String value) {\n-\t\tcandidate.setMiddleName(alnumPattern.matcher(value).matches() ? value : null);\n-\t}\n-\n-\t/**\n-\t * To given candidate, sets titleAfter from trim of given value, or null if empty.\n-\t *\n-\t * @param candidate candidate\n-\t * @param value value\n-\t */\n-\tprivate void parseTitlesAfter(Candidate candidate, String value) {\n-\t\tcandidate.setTitleAfter(alnumPattern.matcher(value).matches() ? value : null);\n-\t}\n-\n-\t/**\n-\t * Generates pattern for parsing titles and middle name from given values.\n-\t *\n-\t * The pattern is of format: ^(.*){firstName}(.*){lastName}(.*)$\n-\t *\n-\t * @param firstName first name\n-\t * @param lastName last name\n-\t * @return pattern for parsing titles and middle name\n-\t */\n-\tprivate Pattern getNamesPattern(String firstName, String lastName) {\n-\t\treturn Pattern.compile(\"^(.*)\" + firstName + \"(.*)\" + lastName + \"(.*)$\");\n-\t}\n-\n-\t/**\n-\t * Returns true if the given map contains a non-empty value for given key.\n-\t *\n-\t * @param map map\n-\t * @param key key\n-\t * @return true if the given map contains a non-empty value for given key, false otherwise\n-\t */\n-\tprivate boolean containsNonEmptyValue(Map<String, String> map, String key) {\n-\t\treturn map.containsKey(key) && map.get(key) != null && !map.get(key).isEmpty();\n-\t}\n-\n-\t/**\n-\t * Check whether a principal in perun session has already created application in group\n-\t *\n-\t * @param sess perun session containing principal\n-\t * @param vo for application\n-\t * @param group for application\n-\t * @param applicationType type of application\n-\t * @throws DuplicateRegistrationAttemptException if the principal has already created application\n-\t * @throws RegistrarException\n-\t * @throws PrivilegeException\n-\t */\n-\tprivate void checkDupplicateGroupApplications(PerunSession sess, Vo vo, Group group, AppType applicationType) throws DuplicateRegistrationAttemptException, RegistrarException, PrivilegeException {\n-\t\t// select neccessary information from already existing Group applications\n-\t\tList<Application> applications = new ArrayList<>(jdbc.query(\n-\t\t\t\"select id, user_id, created_by, extSourceName, fed_info from application where apptype=? and vo_id=? and group_id=? and (state=? or state=?)\",\n-\t\t\tIDENTITY_APP_MAPPER,\n-\t\t\tapplicationType.toString(), vo.getId(), group.getId(), AppState.NEW.toString(), AppState.VERIFIED.toString()));\n-\t\t// not member of VO - check for unprocessed applications to Group\n-\t\tList<Application> filteredApplications = filterPrincipalApplications(sess, applications);\n-\t\tif (!filteredApplications.isEmpty()) {\n-\t\t\t// user have unprocessed application for group\n-\t\t\tthrow new DuplicateRegistrationAttemptException(\n-\t\t\t\t\"Application for Group: \"+group.getName()+\" already exists.\",\n-\t\t\t\tgetApplicationById(filteredApplications.get(0).getId()),\n-\t\t\t\tgetApplicationDataById(registrarSession, filteredApplications.get(0).getId()));\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Check whether a principal in perun session has already created application in vo\n-\t *\n-\t * @param sess perun session containing principal\n-\t * @param vo for application\n-\t * @param applicationType type of application\n-\t * @throws DuplicateRegistrationAttemptException if the principal has already created application\n-\t * @throws RegistrarException\n-\t * @throws PrivilegeException\n-\t */\n-\tprivate void checkDupplicateVoApplications(PerunSession sess, Vo vo, AppType applicationType) throws DuplicateRegistrationAttemptException, RegistrarException, PrivilegeException {\n-\t\t// select neccessary information from already existing Vo applications\n-\t\tList<Application> applications = jdbc.query(\n-\t\t\t\"select id, user_id, created_by, extSourceName, fed_info from application where apptype=? and vo_id=? and group_id is null and (state=? or state=?)\",\n-\t\t\tIDENTITY_APP_MAPPER,\n-\t\t\tapplicationType.toString(), vo.getId(), AppState.NEW.toString(), AppState.VERIFIED.toString());\n-\t\t// not member of VO - check for unprocessed applications\n-\t\tList<Application> filteredApplications = filterPrincipalApplications(sess, applications);\n-\t\tif (!filteredApplications.isEmpty()) {\n-\t\t\t// user have unprocessed application for VO - can't post more\n-\t\t\tthrow new DuplicateRegistrationAttemptException(\n-\t\t\t\t\"Application for VO: \"+vo.getName()+\" already exists.\",\n-\t\t\t\tgetApplicationById(filteredApplications.get(0).getId()),\n-\t\t\t\tgetApplicationDataById(registrarSession, filteredApplications.get(0).getId()));\n-\t\t}\n-\t}\n-\n-\tprivate int processApplication(PerunSession session, Application application, List<ApplicationFormItemData> data) throws PerunException {\n-\n-\t\t// If user is known in Perun but unknown in GUI (user joined identity by consolidator)\n-\t\tif (application.getUser() == null && session.getPerunPrincipal().getUser() != null) {\n-\t\t\tapplication.setUser(session.getPerunPrincipal().getUser());\n-\t\t}\n-\n-\t\t// lock to prevent multiple submission of same application on server side\n-\t\tString key = getLockKeyForApplication(application);\n-\n-\t\tsynchronized(runningCreateApplication) {\n-\t\t\tif (runningCreateApplication.contains(key)) {\n-\t\t\t\tthrow new AlreadyProcessingException(\"Your application submission is being processed already.\");\n-\t\t\t} else {\n-\t\t\t\trunningCreateApplication.add(key);\n-\t\t\t}\n-\t\t}\n-\n-\t\t// store user-ext-source attributes from session to application object\n-\t\tLinkedHashMap<String, String> map = new LinkedHashMap<>(session.getPerunPrincipal().getAdditionalInformations());\n-\t\tString additionalAttrs = BeansUtils.attributeValueToString(map, LinkedHashMap.class.getName());\n-\t\tapplication.setFedInfo(additionalAttrs);\n-\n-\t\tApplication app;\n-\t\ttry {\n-\n-\t\t\t// throws exception if user already submitted application or is already a member or can't submit it by VO/Group expiration rules.\n-\t\t\tcheckDuplicateRegistrationAttempt(session, application.getType(), (application.getGroup() != null) ? getFormForGroup(application.getGroup()) : getFormForVo(application.getVo()));\n-\n-\t\t\t// using this to init inner transaction\n-\t\t\t// all minor exceptions inside are catched, if not, it's ok to throw them out\n-\t\t\tapp = this.registrarManager.createApplicationInternal(session, application, data);\n-\t\t} catch (Exception ex) {\n-\t\t\t// clear flag and re-throw exception, since application was processed with exception\n-\t\t\tsynchronized (runningCreateApplication) {\n-\t\t\t\trunningCreateApplication.remove(key);\n-\t\t\t}\n-\t\t\tthrow ex;\n-\t\t}\n-\n-\t\t// try to verify (or even auto-approve) application\n-\t\ttry {\n-\t\t\tboolean verified = tryToVerifyApplication(session, app);\n-\t\t\tif (verified) {\n-\t\t\t\t// try to APPROVE if auto approve\n-\t\t\t\ttryToAutoApproveApplication(session, app);\n-\t\t\t} else {\n-\t\t\t\t// send request validation notification\n-\t\t\t\tgetMailManager().sendMessage(app, MailType.MAIL_VALIDATION, null, null);\n-\t\t\t}\n-\t\t\t// refresh current session, if submission was successful,\n-\t\t\t// since user might have been created.\n-\t\t\tAuthzResolverBlImpl.refreshSession(session);\n-\t\t} catch (Exception ex) {\n-\t\t\tlog.error(\"[REGISTRAR] Unable to verify or auto-approve application {}, because of exception {}\", app, ex);\n-\t\t\t// clear flag and re-throw exception, since application was processed with exception\n-\t\t\tsynchronized (runningCreateApplication) {\n-\t\t\t\trunningCreateApplication.remove(key);\n-\t\t\t}\n-\t\t\tthrow ex;\n-\t\t}\n-\n-\t\t// clear flag, since application was processed\n-\t\tsynchronized (runningCreateApplication) {\n-\t\t\trunningCreateApplication.remove(key);\n-\t\t}\n-\n-\t\treturn app.getId();\n-\n-\t}\n-\n-\t@Override\n-\tpublic void updateApplicationType(PerunSession session, Application application) {\n-\n-\t\t// TODO - add authorization (and add to rpc)\n-\n-\t\tif (jdbc.update(\"update application set apptype=? where id=?\", application.getType().toString(), application.getId()) > 0) {\n-\t\t\tlog.debug(\"Application type changed to + \" + application.getType());\n-\t\t}\n-\t}\n-\n-\t// ------------------ MAPPERS AND SELECTS -------------------------------------\n-\n-\t// FIXME - we are retrieving GROUP name using only \"short_name\" so it's not same as getGroupById()\n-\tstatic final String APP_SELECT = \"select a.id as id,a.vo_id as vo_id, a.group_id as group_id,a.apptype as apptype,a.fed_info as fed_info,a.state as state,\" +\n-\t\t\t\"a.user_id as user_id,a.extsourcename as extsourcename, a.extsourcetype as extsourcetype, a.extsourceloa as extsourceloa, a.user_id as user_id, a.created_at as app_created_at, a.created_by as app_created_by, a.modified_at as app_modified_at, a.modified_by as app_modified_by, \" +\n-\t\t\t\"v.name as vo_name, v.short_name as vo_short_name, v.created_by as vo_created_by, v.created_at as vo_created_at, v.created_by_uid as vo_created_by_uid, v.modified_by as vo_modified_by, \" +\n-\t\t\t\"v.modified_at as vo_modified_at, v.modified_by_uid as vo_modified_by_uid, g.name as group_name, g.dsc as group_description, g.created_by as group_created_by, g.created_at as group_created_at, g.modified_by as group_modified_by, g.created_by_uid as group_created_by_uid, g.modified_by_uid as group_modified_by_uid,\" +\n-\t\t\t\"g.modified_at as group_modified_at, g.vo_id as group_vo_id, g.parent_group_id as group_parent_group_id, g.uu_id as group_uu_id, u.first_name as user_first_name, u.last_name as user_last_name, u.middle_name as user_middle_name, \" +\n-\t\t\t\"u.title_before as user_title_before, u.title_after as user_title_after, u.service_acc as user_service_acc, u.sponsored_acc as user_sponsored_acc , u.uu_id as user_uu_id from application a left outer join vos v on a.vo_id = v.id left outer join groups g on a.group_id = g.id left outer join users u on a.user_id = u.id\";\n-\n-\tprivate static final String APP_TYPE_SELECT = \"select apptype from application_form_item_apptypes\";\n-\n-\tprivate static final String FORM_SELECT = \"select id,vo_id,group_id,automatic_approval,automatic_approval_extension,module_name from application_form\";\n-\n-\tprivate static final String FORM_ITEM_SELECT = \"select id,ordnum,shortname,required,type,fed_attr,src_attr,dst_attr,regex from application_form_items\";\n-\n-\tprivate static final String FORM_ITEM_TEXTS_SELECT = \"select locale,label,options,help,error_message from application_form_item_texts\";\n-\n-\tprivate static final RowMapper<Application> IDENTITY_APP_MAPPER = (resultSet, i) -> {\n-\t\tApplication app = new Application();\n-\t\tapp.setId(resultSet.getInt(\"id\"));\n-\t\tapp.setUser(new User(resultSet.getInt(\"user_id\"),\"\",\"\",\"\",\"\",\"\"));\n-\t\tapp.setCreatedBy(resultSet.getString(\"created_by\"));\n-\t\tapp.setExtSourceName(resultSet.getString(\"extsourcename\"));\n-\t\tapp.setFedInfo(resultSet.getString(\"fed_info\"));\n-\t\treturn app;\n-\t};\n-\n-\tstatic final RowMapper<Application> APP_MAPPER = (resultSet, i) -> {\n-\n-\t\tApplication app = new Application(resultSet.getInt(\"id\"), new Vo(resultSet.getInt(\"vo_id\"),\n-\t\t\t\tresultSet.getString(\"vo_name\"), resultSet.getString(\"vo_short_name\"),\n-\t\t\t\tresultSet.getString(\"vo_created_at\"), resultSet.getString(\"vo_created_by\"),\n-\t\t\t\tresultSet.getString(\"vo_modified_at\"), resultSet.getString(\"vo_modified_by\"),\n-\t\t\t\tresultSet.getInt(\"vo_created_by_uid\"), resultSet.getInt(\"vo_modified_by_uid\")),\n-\t\t\t\tnull, AppType.valueOf(resultSet.getString(\"apptype\")),\n-\t\t\t\tresultSet.getString(\"fed_info\"), AppState.valueOf(resultSet.getString(\"state\")),\n-\t\t\t\tresultSet.getString(\"extsourcename\"), resultSet.getString(\"extsourcetype\"),\n-\t\t\t\tresultSet.getInt(\"extsourceloa\"), null);\n-\n-\t\t// if group present\n-\t\tif (resultSet.getInt(\"group_id\") != 0) {\n-\t\t\tapp.setGroup(new Group(resultSet.getInt(\"group_id\"), resultSet.getString(\"group_name\"),\n-\t\t\t\t\tresultSet.getString(\"group_description\"), resultSet.getString(\"group_created_at\"),\n-\t\t\t\t\tresultSet.getString(\"group_created_by\"), resultSet.getString(\"group_modified_at\"),\n-\t\t\t\t\tresultSet.getString(\"group_modified_by\"), resultSet.getInt(\"group_created_by_uid\"),\n-\t\t\t\t\tresultSet.getInt(\"group_modified_by_uid\")));\n-\t\t\tapp.getGroup().setVoId(resultSet.getInt(\"vo_id\"));\n-\t\t\tapp.getGroup().setUuid(resultSet.getObject(\"group_uu_id\", UUID.class));\n-\n-\t\t\tif (resultSet.getInt(\"group_parent_group_id\") != 0) {\n-\t\t\t\tapp.getGroup().setParentGroupId(resultSet.getInt(\"group_parent_group_id\"));\n-\t\t\t}\n-\n-\t\t}\n-\n-\t\t// if user present\n-\t\tif (resultSet.getInt(\"user_id\") != 0) {\n-\t\t\tapp.setUser(new User(resultSet.getInt(\"user_id\"), resultSet.getString(\"user_first_name\"),\n-\t\t\t\t\tresultSet.getString(\"user_last_name\"), resultSet.getString(\"user_middle_name\"),\n-\t\t\t\t\tresultSet.getString(\"user_title_before\"), resultSet.getString(\"user_title_after\"),\n-\t\t\t\t\tresultSet.getBoolean(\"user_service_acc\"), resultSet.getBoolean(\"user_sponsored_acc\")));\n-\t\t\tapp.getUser().setUuid(resultSet.getObject(\"user_uu_id\", UUID.class));\n-\t\t}\n-\n-\t\tapp.setCreatedAt(resultSet.getString(\"app_created_at\"));\n-\t\tapp.setCreatedBy(resultSet.getString(\"app_created_by\"));\n-\t\tapp.setModifiedAt(resultSet.getString(\"app_modified_at\"));\n-\t\tapp.setModifiedBy(resultSet.getString(\"app_modified_by\"));\n-\n-\t\treturn app;\n-\n-\t};\n-\n-\tprivate static final RowMapper<AppType> APP_TYPE_MAPPER= (resultSet, i) -> AppType.valueOf(resultSet.getString(1));\n-\n-\tprivate static final RowMapper<ApplicationFormItem> ITEM_MAPPER = (resultSet, i) -> {\n-\t\tApplicationFormItem app = new ApplicationFormItem(resultSet.getInt(\"id\"),\n-\t\t\t\tresultSet.getString(\"shortname\"), resultSet.getBoolean(\"required\"),\n-\t\t\t\tType.valueOf(resultSet.getString(\"type\")), resultSet.getString(\"fed_attr\"),\n-\t\t\t\tresultSet.getString(\"src_attr\"), resultSet.getString(\"dst_attr\"), resultSet.getString(\"regex\"));\n-\t\tapp.setOrdnum(resultSet.getInt(\"ordnum\"));\n-\t\treturn app;\n-\t};\n-\n-\tprivate static final RowMapper<ApplicationFormItem.ItemTexts> ITEM_TEXTS_MAPPER = (resultSet, i) -> new ItemTexts(new Locale(resultSet.getString(\"locale\")),\n-\t\t\tresultSet.getString(\"label\"), resultSet.getString(\"options\"), resultSet.getString(\"help\"),\n-\t\t\tresultSet.getString(\"error_message\"));\n+                // other types of application doesn't create new user - continue\n+                approveApplication(registrarSession, app.getId());\n+\n+            }\n+        } catch (Exception ex) {\n+\n+            ArrayList<Exception> list = new ArrayList<>();\n+            list.add(ex);\n+            getMailManager().sendMessage(app, MailType.APP_ERROR_VO_ADMIN, null, list);\n+\n+            throw ex;\n+        }\n+\n+    }\n+\n+    /**\n+     * Retrieves whole application object from DB\n+     * (authz in parent methods)\n+     *\n+     * @param appId ID of application to get\n+     * @return application object / null if not exists\n+     */\n+    private Application getApplicationById(int appId) {\n+        try {\n+            return jdbc.queryForObject(APP_SELECT + \" where a.id=?\", APP_MAPPER, appId);\n+        } catch (EmptyResultDataAccessException ex) {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Extract names for User from his federation attributes\n+     *\n+     * @param federValues map of federation attribute names to their value\n+     * @return map with exctracted names\n+     */\n+    private Map<String, String> extractNames(Map<String, String> federValues) {\n+\n+        String commonName = federValues.get(shibCommonNameVar);\n+        String displayName = federValues.get(shibDisplayNameVar);\n+\n+        Map<String, String> parsedName;\n+        if (displayName != null && !displayName.isEmpty()) {\n+            parsedName = Utils.parseCommonName(displayName);\n+        } else if (commonName != null && !commonName.isEmpty()) {\n+            parsedName = Utils.parseCommonName(commonName);\n+        } else {\n+            parsedName = new HashMap<>();\n+        }\n+        // if the idp provided first name or last name, always use it\n+        String fedFirstName = federValues.get(shibFirstNameVar);\n+        String fedLastName = federValues.get(shibLastNameVar);\n+\n+        setIfNotEmpty(parsedName, fedFirstName, \"firstName\");\n+        setIfNotEmpty(parsedName, fedLastName, \"lastName\");\n+\n+        // do new parsing heuristic\n+        Candidate candidate = new Candidate();\n+        if (displayName != null && !displayName.isEmpty() &&\n+                fedFirstName != null && !fedFirstName.isEmpty() &&\n+                fedLastName != null && !fedLastName.isEmpty()) {\n+            parseTitlesAndMiddleName(candidate, displayName, fedFirstName, fedLastName);\n+        }\n+\n+        setIfNotEmpty(parsedName, candidate.getMiddleName(), \"middleName\");\n+        setIfNotEmpty(parsedName, candidate.getTitleBefore(), \"titleBefore\");\n+        setIfNotEmpty(parsedName, candidate.getTitleAfter(), \"titleAfter\");\n+\n+        return parsedName;\n+\n+    }\n+\n+    /**\n+     * If the given value is not null and not empty, put it in the given map with the given key.\n+     *\n+     * @param map   map\n+     * @param value value which is checked\n+     * @param key   key\n+     */\n+    private void setIfNotEmpty(Map<String, String> map, String value, String key) {\n+        if (value != null && !value.isEmpty()) {\n+            map.put(key, value);\n+        }\n+    }\n+\n+    /**\n+     * Return RegistrarModule for specific application form (VO or Group)\n+     * so it can be used for more actions.\n+     *\n+     * @param form application form\n+     * @return RegistrarModule if present or null\n+     */\n+    private RegistrarModule getRegistrarModule(ApplicationForm form) {\n+\n+        if (form == null) {\n+            // wrong input\n+            log.error(\"[REGISTRAR] Application form is null when getting it's registrar module.\");\n+            throw new NullPointerException(\"Application form is null when getting it's registrar module.\");\n+        }\n+\n+        if (form.getModuleClassName() != null && !form.getModuleClassName().trim().isEmpty()) {\n+\n+            RegistrarModule module = null;\n+\n+            try {\n+                log.debug(\"[REGISTRAR] Attempting to instantiate class: {}\", MODULE_PACKAGE_PATH + form.getModuleClassName());\n+                module = (RegistrarModule) Class.forName(MODULE_PACKAGE_PATH + form.getModuleClassName()).newInstance();\n+                module.setRegistrar(registrarManager);\n+            } catch (Exception ex) {\n+                log.error(\"[REGISTRAR] Exception when instantiating module.\", ex);\n+                return module;\n+            }\n+            log.debug(\"[REGISTRAR] Class {} successfully created.\", MODULE_PACKAGE_PATH + form.getModuleClassName());\n+\n+            return module;\n+\n+        }\n+\n+        return null;\n+\n+    }\n+\n+    /**\n+     * If titles before / after name are part of application form and User exists,\n+     * update titles for user according to application.\n+     * <p>\n+     * This method doesn't clear titles from users name if sent empty in order to prevent\n+     * accidental removal when user log-in with different IDP without titles provided.\n+     *\n+     * @param app Application to update user's titles for.\n+     */\n+    private void updateUserNameTitles(Application app) {\n+\n+        try {\n+\n+            User user = usersManager.getUserById(registrarSession, app.getUser().getId());\n+            List<ApplicationFormItemData> data = registrarManager.getApplicationDataById(registrarSession, app.getId());\n+            boolean found = false;\n+\n+            // first check for display name\n+            for (ApplicationFormItemData item : data) {\n+                if (URN_USER_DISPLAY_NAME.equals(item.getFormItem().getPerunDestinationAttribute())) {\n+                    if (item.getValue() != null && !item.getValue().isEmpty()) {\n+                        Map<String, String> commonName = Utils.parseCommonName(item.getValue());\n+                        if (commonName.get(\"titleBefore\") != null && !commonName.get(\"titleBefore\").isEmpty()) {\n+                            user.setTitleBefore(commonName.get(\"titleBefore\"));\n+                            found = true;\n+                        }\n+                        if (commonName.get(\"titleAfter\") != null && !commonName.get(\"titleAfter\").isEmpty()) {\n+                            user.setTitleAfter(commonName.get(\"titleAfter\"));\n+                            found = true;\n+                        }\n+                    }\n+                    break;\n+                }\n+            }\n+\n+            // overwrite by specific before/after name title\n+            for (ApplicationFormItemData item : data) {\n+                if (URN_USER_TITLE_BEFORE.equals(item.getFormItem().getPerunDestinationAttribute())) {\n+                    if (item.getValue() != null && !item.getValue().isEmpty()) {\n+                        user.setTitleBefore(item.getValue());\n+                        found = true;\n+                    }\n+                }\n+                if (URN_USER_TITLE_AFTER.equals(item.getFormItem().getPerunDestinationAttribute())) {\n+                    if (item.getValue() != null && !item.getValue().isEmpty()) {\n+                        user.setTitleAfter(item.getValue());\n+                        found = true;\n+                    }\n+                }\n+            }\n+\n+            // titles were part of application form\n+            if (found) {\n+                log.debug(\"[REGISTRAR] User to update titles: {}\", user);\n+                usersManager.updateNameTitles(registrarSession, user);\n+            }\n+\n+        } catch (Exception ex) {\n+            log.error(\"[REGISTRAR] Exception when updating titles.\", ex);\n+        }\n+\n+    }\n+\n+    /**\n+     * Store values from application data as user/member attributes\n+     * <p>\n+     * New values are set if old are empty, or merged if not empty.\n+     * Empty new values are skipped (not even merged) as well as core attributes.\n+     * <p>\n+     * User and Member must already exists !!\n+     * <p>\n+     * !! LOGIN ATTRIBUTES ARE SKIPPED BY THIS METHOD AND MUST BE\n+     * SET LATER BY storeApplicationLoginAttributes() METHOD !!\n+     * !! USE unreserveNewLoginsFromSameNamespace() BEFORE DOING SO !!\n+     *\n+     * @param app Application to process attributes for\n+     * @throws UserNotExistsException                When User present in Application not exists\n+     * @throws InternalErrorException                When implementation fails\n+     * @throws PrivilegeException                    When caller is not authorized for some action\n+     * @throws MemberNotExistsException              When Member resolved from VO/User from Application doesn't exist\n+     * @throws VoNotExistsException                  When VO resolved from application doesn't exist\n+     * @throws RegistrarException                    When implementation fails\n+     * @throws AttributeNotExistsException           When expected attribute doesn't exists\n+     * @throws WrongAttributeAssignmentException     When attribute can't be stored because of wrongly passed params\n+     * @throws WrongAttributeValueException          When attribute can't be stored because of wrong value\n+     * @throws WrongReferenceAttributeValueException When attribute can't be stored because of some specific dynamic constraint (from attribute module)\n+     */\n+    private void storeApplicationAttributes(Application app)\n+            throws UserNotExistsException, PrivilegeException, MemberNotExistsException, VoNotExistsException, RegistrarException, AttributeNotExistsException, WrongAttributeAssignmentException, WrongAttributeValueException, WrongReferenceAttributeValueException {\n+\n+        // user and member must exists if it's extension !!\n+        User user = usersManager.getUserById(registrarSession, app.getUser().getId());\n+        Member member = membersManager.getMemberByUser(registrarSession, app.getVo(), user);\n+\n+        // get all app items\n+        List<ApplicationFormItemData> items = getApplicationDataById(registrarSession, app.getId());\n+\n+        // attributes to set\n+        List<Attribute> attributes = new ArrayList<>();\n+        for (ApplicationFormItemData item : items) {\n+            String destAttr = item.getFormItem().getPerunDestinationAttribute();\n+            String newValue = item.getValue();\n+            // do not store null or empty values at all\n+            if (newValue == null || newValue.isEmpty()) {\n+                continue;\n+            }\n+            // if correct destination attribute\n+            if (destAttr != null && !destAttr.isEmpty()) {\n+                // get attribute (for user and member only)\n+                Attribute a;\n+                if (destAttr.contains(\"urn:perun:user:\")) {\n+                    a = attrManager.getAttribute(registrarSession, user, destAttr);\n+                } else if (destAttr.contains(\"urn:perun:member:\")) {\n+                    a = attrManager.getAttribute(registrarSession, member, destAttr);\n+                } else {\n+                    continue;\n+                }\n+\n+                // NEVER STORE LOGINS THIS WAY TO PREVENT ACCIDENTAL OVERWRITE\n+                if (a != null && \"login-namespace\".equals(a.getBaseFriendlyName())) {\n+                    continue;\n+                }\n+\n+                // if attribute exists\n+                if (a != null) {\n+                    if (a.getType().equalsIgnoreCase(LinkedHashMap.class.getName())) {\n+                        // FIXME do not set hash map attributes - not supported in GUI and registrar\n+                        continue;\n+                    } else if (a.getType().equalsIgnoreCase(ArrayList.class.getName()) || a.getType().equalsIgnoreCase(BeansUtils.largeArrayListClassName)) {\n+                        // we expects that list contains strings\n+                        ArrayList<String> value = a.valueAsList();\n+                        // if value not present in list => add\n+                        if (value == null) {\n+                            // set as new value\n+                            value = new ArrayList<>();\n+                            value.add(newValue);\n+                        } else if (!value.contains(newValue)) {\n+                            // add value between old values\n+                            value.add(newValue);\n+                        }\n+                        a.setValue(value);\n+                        attributes.add(a);\n+                        continue;\n+                    } else {\n+                        // other attributes are handled like strings\n+                        a.setValue(newValue);\n+                        attributes.add(a);\n+                    }\n+                }\n+            }\n+        }\n+\n+        // set attributes\n+        if (!attributes.isEmpty()) {\n+            // set them if not empty (member+user)\n+            attrManager.setAttributes(registrarSession, member, attributes, true);\n+        }\n+\n+    }\n+\n+    /**\n+     * Store only login attributes from application to user.\n+     * <p>\n+     * New values are set only if old are empty to prevent overwrite when joining identities.\n+     * Empty new values are skipped.\n+     * <p>\n+     * User must already exists !!\n+     *\n+     * @param app Application to process attributes for\n+     * @throws UserNotExistsException                When User present in Application not exists\n+     * @throws InternalErrorException                When implementation fails\n+     * @throws PrivilegeException                    When caller is not authorized for some action\n+     * @throws RegistrarException                    When implementation fails\n+     * @throws AttributeNotExistsException           When expected attribute doesn't exists\n+     * @throws WrongAttributeAssignmentException     When login can't be stored because of wrongly passed params\n+     * @throws WrongAttributeValueException          When login can't be stored because of wrong value\n+     * @throws WrongReferenceAttributeValueException When login can't be stored because of some specific dynamic constraint (from attribute module)\n+     */\n+    private void storeApplicationLoginAttributes(Application app) throws UserNotExistsException, PrivilegeException, RegistrarException, AttributeNotExistsException, WrongAttributeAssignmentException, WrongAttributeValueException, WrongReferenceAttributeValueException {\n+\n+        // user must exists\n+        User user = usersManager.getUserById(registrarSession, app.getUser().getId());\n+\n+        // get all app items\n+        List<ApplicationFormItemData> items = getApplicationDataById(registrarSession, app.getId());\n+\n+        // attributes to set\n+        List<Attribute> attributes = new ArrayList<>();\n+        for (ApplicationFormItemData item : items) {\n+            String destAttr = item.getFormItem().getPerunDestinationAttribute();\n+            String newValue = item.getValue();\n+            // do not store null or empty values at all\n+            if (newValue == null || newValue.isEmpty()) {\n+                continue;\n+            }\n+            // if correct destination attribute\n+            if (destAttr != null && !destAttr.isEmpty()) {\n+                // get login attribute (for user only)\n+                Attribute a;\n+                if (destAttr.contains(AttributesManager.NS_USER_ATTR_DEF + \":login-namespace:\")) {\n+                    a = attrManager.getAttribute(registrarSession, user, destAttr);\n+                } else {\n+                    continue;\n+                }\n+\n+                // if attribute exists\n+                if (a != null) {\n+                    if (StringUtils.isBlank(a.valueAsString())) {\n+                        // set login attribute if initial (new) value\n+                        a.setValue(newValue);\n+                        attributes.add(a);\n+                    }\n+                    // skip if login already existed continue\n+                }\n+            }\n+        }\n+\n+        // set attributes\n+        if (!attributes.isEmpty()) {\n+            // set them if not empty (user)\n+            attrManager.setAttributes(registrarSession, user, attributes);\n+        }\n+\n+    }\n+\n+    /**\n+     * Unreserve new login/password from KDC if user already have login in same namespace\n+     * <p>\n+     * !! must be called before setting new attributes from application !!\n+     *\n+     * @param logins list of all new logins/namespaces pairs passed by application\n+     * @param user   user to check logins for\n+     * @return List of login/namespace pairs which are purely new and can be set to user and validated in KDC\n+     */\n+    private List<Pair<String, String>> unreserveNewLoginsFromSameNamespace(List<Pair<String, String>> logins, User user) throws PasswordDeletionFailedException, PasswordOperationTimeoutException, LoginNotExistsException, InvalidLoginException {\n+\n+        List<Pair<String, String>> result = new ArrayList<>();\n+\n+        List<Attribute> loginAttrs = perun.getAttributesManagerBl().getLogins(registrarSession, user);\n+\n+        for (Pair<String, String> pair : logins) {\n+            boolean found = false;\n+            for (Attribute a : loginAttrs) {\n+                if (pair.getLeft().equals(a.getFriendlyNameParameter())) {\n+                    // old login found in same namespace => unreserve new login from KDC\n+                    usersManager.deletePassword(registrarSession, pair.getRight(), pair.getLeft());\n+                    log.debug(\"[REGISTRAR] Unreserving new login: {} in namespace: {} since user already have login: {} in same namespace.\"\n+                            , pair.getRight(), pair.getLeft(), a.getValue());\n+                    found = true;\n+                    break;\n+                }\n+            }\n+            if (!found) {\n+                // login is purely new\n+                result.add(pair);\n+            }\n+        }\n+\n+        return result;\n+\n+    }\n+\n+    /**\n+     * Try to approve all group applications of user with auto-approval (even by user-ext-source)\n+     * in specified VO.\n+     *\n+     * @param sess PerunSession\n+     * @param vo   VO to approve group applications in\n+     * @param user user to approve applications for\n+     */\n+    private void autoApproveUsersGroupApplications(PerunSession sess, Vo vo, User user) throws PerunException {\n+\n+        // get group apps based on the vo\n+        List<Application> apps = jdbc.query(\n+                APP_SELECT + \" where a.vo_id=? and a.group_id is not null and a.state=?\",\n+                APP_MAPPER, vo.getId(), AppState.VERIFIED.toString());\n+\n+        //filter only user's apps\n+        List<Application> applications = filterUserApplications(sess, user, apps);\n+\n+        for (Application a : applications) {\n+            // if new => skipp user will approve automatically by verifying email\n+            if (a.getState().equals(AppState.NEW)) {\n+                continue;\n+            }\n+\n+            // approve applications only for auto-approve forms\n+            if (!getFormForGroup(a.getGroup()).isAutomaticApproval() && AppType.INITIAL.equals(a.getType())) {\n+                continue;\n+            }\n+            if (!getFormForGroup(a.getGroup()).isAutomaticApprovalExtension() && AppType.EXTENSION.equals(a.getType())) {\n+                continue;\n+            }\n+\n+            try {\n+                registrarManager.approveApplicationInternal(sess, a.getId());\n+            } catch (RegistrarException ex) {\n+                // case when user have UNVERIFIED group application\n+                // will be approved when user verify his email\n+                log.error(\"[REGISTRAR] Can't auto-approve group application after vo app approval because of exception.\", ex);\n+            }\n+\n+        }\n+\n+    }\n+\n+    /**\n+     * Return string representation (key) of application used for locking main operations like \"create/verify/approve/reject\".\n+     *\n+     * @param application Application to get key for\n+     * @return Key for Application\n+     */\n+    private String getLockKeyForApplication(Application application) {\n+\n+        return application.getType().toString() +\n+                application.getVo().getShortName() +\n+                ((application.getGroup() != null) ? application.getGroup().getName() : \"nogroup\") +\n+                application.getCreatedBy() + application.getExtSourceName() + application.getExtSourceType();\n+\n+    }\n+\n+    /**\n+     * If user provided value is the same as was pre-filled from Perun, then we set LOA=2\n+     * If user provided value is between those provided by Federation, then we keep provided LOA (0 will require mail validation, >0 will skip it).\n+     * If user provided value is not between any of pre-filled values, then we set LOA=0 to require validation.\n+     *\n+     * @param session\n+     * @param itemData\n+     */\n+    private void handleLoaForValidatedMail(PerunSession session, ApplicationFormItemData itemData) {\n+\n+        // all mails from federation (lowercased)\n+        List<String> mailsFromFed = new ArrayList<>();\n+        String mailsFed = session.getPerunPrincipal().getAdditionalInformations().get(\"mail\");\n+        if (StringUtils.isNotBlank(mailsFed)) {\n+            mailsFromFed.addAll(Arrays.stream(mailsFed.split(\";\")).map(String::toLowerCase).collect(Collectors.toList()));\n+        }\n+\n+        // all prefilled mails (lowercased)\n+        List<String> prefilledValues = new ArrayList<>();\n+        if (StringUtils.isNotBlank(itemData.getPrefilledValue())) {\n+            prefilledValues.addAll(Arrays.stream(itemData.getPrefilledValue().split(\";\")).map(String::toLowerCase).collect(Collectors.toList()));\n+        }\n+\n+        // value(s) pre-filled from perun\n+        List<String> valuesFromPerun = new ArrayList<>(prefilledValues);\n+        for (String fromFed : mailsFromFed) {\n+            valuesFromPerun.remove(fromFed);\n+        }\n+\n+        String actualValue = (StringUtils.isNotBlank(itemData.getValue())) ? itemData.getValue().toLowerCase() : null;\n+\n+        if (valuesFromPerun.contains(actualValue)) {\n+            // override incoming LOA, since it was from perun\n+            itemData.setAssuranceLevel(\"2\");\n+        } else if (!prefilledValues.contains(actualValue)) {\n+            // clearing LoA to 0, since value is a new\n+            itemData.setAssuranceLevel(\"0\");\n+        }\n+\n+        // or else keep incoming LoA since it was one of pre-filled values from Federation.\n+\n+        // normalize empty value\n+        if (StringUtils.isBlank(itemData.getValue())) {\n+            itemData.setValue(null);\n+        }\n+\n+    }\n+\n+    /**\n+     * Method creates a candidate object from application according to the application id.\n+     *\n+     * @param app the application\n+     * @return Candidate\n+     */\n+    private Candidate createCandidateFromApplicationData(Application app) {\n+        // put application data into Candidate\n+        final Map<String, String> attributes = new HashMap<>();\n+        jdbc.query(\"select dst_attr,value from application_data d, application_form_items i where d.item_id=i.id \"\n+                        + \"and i.dst_attr is not null and d.value is not null and app_id=?\",\n+                (resultSet, i) -> {\n+                    attributes.put(resultSet.getString(\"dst_attr\"), resultSet.getString(\"value\"));\n+                    return null;\n+                }, app.getId());\n+\n+        Map<String, String> fedData = BeansUtils.stringToMapOfAttributes(app.getFedInfo());\n+\n+        // DO NOT STORE LOGINS THROUGH CANDIDATE\n+        // we do not set logins by candidate object to prevent accidental overwrite while joining identities in process\n+        attributes.entrySet().removeIf(entry -> entry.getKey().contains(\"urn:perun:user:attribute-def:def:login-namespace:\"));\n+\n+        Candidate candidate = new Candidate();\n+        candidate.setAttributes(attributes);\n+\n+        log.debug(\"[REGISTRAR] Retrieved candidate from DB {}\", candidate);\n+\n+        // first try to parse display_name if not null and not empty\n+        parseNamesFromDisplayNameAndFedInfo(candidate, attributes, fedData);\n+\n+        // if names are separated, used them after\n+        for (String attrName : attributes.keySet()) {\n+            // if value not null or empty - set to candidate\n+            if (attributes.get(attrName) != null\n+                    && !attributes.get(attrName).isEmpty()) {\n+                if (URN_USER_TITLE_BEFORE.equals(attrName)) {\n+                    candidate.setTitleBefore(attributes.get(attrName));\n+                } else if (URN_USER_TITLE_AFTER.equals(attrName)) {\n+                    candidate.setTitleAfter(attributes.get(attrName));\n+                } else if (URN_USER_FIRST_NAME.equals(attrName)) {\n+                    candidate.setFirstName(attributes.get(attrName));\n+                } else if (URN_USER_LAST_NAME.equals(attrName)) {\n+                    candidate.setLastName(attributes.get(attrName));\n+                } else if (URN_USER_MIDDLE_NAME.equals(attrName)) {\n+                    candidate.setMiddleName(attributes.get(attrName));\n+                }\n+            }\n+        }\n+\n+        return candidate;\n+    }\n+\n+    public void parseNamesFromDisplayName(Candidate candidate, Map<String, String> attributes) {\n+        if (containsNonEmptyValue(attributes, URN_USER_DISPLAY_NAME)) {\n+            // parse\n+            Map<String, String> commonName = Utils.parseCommonName(attributes.get(URN_USER_DISPLAY_NAME));\n+            if (commonName.get(\"titleBefore\") != null\n+                    && !commonName.get(\"titleBefore\").isEmpty()) {\n+                candidate.setTitleBefore(commonName.get(\"titleBefore\"));\n+            }\n+            if (commonName.get(\"firstName\") != null\n+                    && !commonName.get(\"firstName\").isEmpty()) {\n+                candidate.setFirstName(commonName.get(\"firstName\"));\n+            }\n+            // FIXME - ? there is no middleName in Utils.parseCommonName() implementation\n+            if (commonName.get(\"middleName\") != null\n+                    && !commonName.get(\"middleName\").isEmpty()) {\n+                candidate.setMiddleName(commonName.get(\"middleName\"));\n+            }\n+            if (commonName.get(\"lastName\") != null\n+                    && !commonName.get(\"lastName\").isEmpty()) {\n+                candidate.setLastName(commonName.get(\"lastName\"));\n+            }\n+            if (commonName.get(\"titleAfter\") != null\n+                    && !commonName.get(\"titleAfter\").isEmpty()) {\n+                candidate.setTitleAfter(commonName.get(\"titleAfter\"));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Check if the given fed info contains givenName and sn (surname). If so,\n+     * it sets it to the candidate and tries to match titles and middle name from\n+     * display name.\n+     *\n+     * @param candidate  candidate\n+     * @param attributes attributes with values\n+     * @param fedInfo    key-value info from idp\n+     */\n+    public void parseNamesFromDisplayNameAndFedInfo(Candidate candidate, Map<String, String> attributes,\n+                                                    Map<String, String> fedInfo) {\n+        if (fedInfo != null && containsNonEmptyValue(fedInfo, shibFirstNameVar) &&\n+                containsNonEmptyValue(fedInfo, shibLastNameVar)) {\n+            String firstName = fedInfo.get(shibFirstNameVar);\n+            String lastName = fedInfo.get(shibLastNameVar);\n+\n+            candidate.setFirstName(firstName);\n+            candidate.setLastName(lastName);\n+\n+            tryToParseTitlesAndMiddleName(candidate, attributes, firstName, lastName);\n+        } else {\n+            parseNamesFromDisplayName(candidate, attributes);\n+        }\n+    }\n+\n+    /**\n+     * If the given map of attributes contains a user display name, it tries to match\n+     * the given firstName and lastName and find titles and middle name.\n+     *\n+     * @param candidate  candidate\n+     * @param attributes map of attributes with values\n+     * @param firstName  first name to match\n+     * @param lastName   last name to match\n+     */\n+    private void tryToParseTitlesAndMiddleName(Candidate candidate, Map<String, String> attributes, String firstName,\n+                                               String lastName) {\n+        if (containsNonEmptyValue(attributes, URN_USER_DISPLAY_NAME)) {\n+            String displayName = attributes.get(URN_USER_DISPLAY_NAME);\n+            parseTitlesAndMiddleName(candidate, displayName, firstName, lastName);\n+        }\n+    }\n+\n+    private void parseTitlesAndMiddleName(Candidate candidate, String displayName, String firstName, String lastName) {\n+        Pattern pattern = getNamesPattern(firstName, lastName);\n+        if (!tryToParseTitlesAndMiddleNameFromPattern(candidate, displayName, pattern, firstName)) {\n+            Pattern reversePattern = getNamesPattern(lastName, firstName);\n+            tryToParseTitlesAndMiddleNameFromPattern(candidate, displayName, reversePattern, lastName);\n+        }\n+    }\n+\n+    /**\n+     * Tries to match the given pattern to the given display name. If it matches, its sets\n+     * titles and middle name from matcher of the given pattern to the given candidate.\n+     * <p>\n+     * This method expects the pattern to define 3 groups in order - 1. Titles before, 2. Middle name, 3. Titles after\n+     *\n+     * @param candidate   candidate\n+     * @param displayName display name\n+     * @param pattern     pattern with 3 matching groups\n+     * @return true, if the matcher matched\n+     */\n+    private boolean tryToParseTitlesAndMiddleNameFromPattern(Candidate candidate, String displayName, Pattern pattern, String firstName) {\n+        Matcher matcher = pattern.matcher(displayName);\n+        if (!matcher.matches()) {\n+            return false;\n+        }\n+        if (matcher.groupCount() != 3) {\n+            throw new InternalErrorException(\"Expected pattern with 3 groups to match - titles before, middle name and \" +\n+                    \"titles after, but get \" + matcher.groupCount() + \" groups.\");\n+        }\n+\n+        // if the middle name equals to the first name placed in displayName (it can be firstName or lastName too)\n+        if (matcher.group(1).contains(firstName)) {\n+            candidate.setTitleBefore(matcher.group(1).split(firstName)[0].trim());\n+            candidate.setMiddleName(firstName);\n+        } else {\n+            parseTitlesBefore(candidate, matcher.group(1).trim());\n+            parseMiddleName(candidate, matcher.group(2).trim());\n+        }\n+        parseTitlesAfter(candidate, matcher.group(3).trim());\n+\n+        return true;\n+    }\n+\n+    /**\n+     * To given candidate, sets titleBefore from trim of given value, or null if empty.\n+     *\n+     * @param candidate candidate\n+     * @param value     value\n+     */\n+    private void parseTitlesBefore(Candidate candidate, String value) {\n+        candidate.setTitleBefore(alnumPattern.matcher(value).matches() ? value : null);\n+    }\n+\n+    /**\n+     * To given candidate, sets middle name from trim of given value.\n+     *\n+     * @param candidate candidate\n+     * @param value     value\n+     */\n+    private void parseMiddleName(Candidate candidate, String value) {\n+        candidate.setMiddleName(alnumPattern.matcher(value).matches() ? value : null);\n+    }\n+\n+    /**\n+     * To given candidate, sets titleAfter from trim of given value, or null if empty.\n+     *\n+     * @param candidate candidate\n+     * @param value     value\n+     */\n+    private void parseTitlesAfter(Candidate candidate, String value) {\n+        candidate.setTitleAfter(alnumPattern.matcher(value).matches() ? value : null);\n+    }\n+\n+    /**\n+     * Generates pattern for parsing titles and middle name from given values.\n+     * <p>\n+     * The pattern is of format: ^(.*){firstName}(.*){lastName}(.*)$\n+     *\n+     * @param firstName first name\n+     * @param lastName  last name\n+     * @return pattern for parsing titles and middle name\n+     */\n+    private Pattern getNamesPattern(String firstName, String lastName) {\n+        return Pattern.compile(\"^(.*)\" + firstName + \"(.*)\" + lastName + \"(.*)$\");\n+    }\n+\n+    /**\n+     * Returns true if the given map contains a non-empty value for given key.\n+     *\n+     * @param map map\n+     * @param key key\n+     * @return true if the given map contains a non-empty value for given key, false otherwise\n+     */\n+    private boolean containsNonEmptyValue(Map<String, String> map, String key) {\n+        return map.containsKey(key) && map.get(key) != null && !map.get(key).isEmpty();\n+    }\n+\n+    /**\n+     * Check whether a principal in perun session has already created application in group\n+     *\n+     * @param sess            perun session containing principal\n+     * @param vo              for application\n+     * @param group           for application\n+     * @param applicationType type of application\n+     * @throws DuplicateRegistrationAttemptException if the principal has already created application\n+     * @throws RegistrarException\n+     * @throws PrivilegeException\n+     */\n+    private void checkDupplicateGroupApplications(PerunSession sess, Vo vo, Group group, AppType applicationType) throws DuplicateRegistrationAttemptException, RegistrarException, PrivilegeException {\n+        // select neccessary information from already existing Group applications\n+        List<Application> applications = new ArrayList<>(jdbc.query(\n+                \"select id, user_id, created_by, extSourceName, fed_info from application where apptype=? and vo_id=? and group_id=? and (state=? or state=?)\",\n+                IDENTITY_APP_MAPPER,\n+                applicationType.toString(), vo.getId(), group.getId(), AppState.NEW.toString(), AppState.VERIFIED.toString()));\n+        // not member of VO - check for unprocessed applications to Group\n+        List<Application> filteredApplications = filterPrincipalApplications(sess, applications);\n+        if (!filteredApplications.isEmpty()) {\n+            // user have unprocessed application for group\n+            throw new DuplicateRegistrationAttemptException(\n+                    \"Application for Group: \" + group.getName() + \" already exists.\",\n+                    getApplicationById(filteredApplications.get(0).getId()),\n+                    getApplicationDataById(registrarSession, filteredApplications.get(0).getId()));\n+        }\n+    }\n+\n+    /**\n+     * Check whether a principal in perun session has already created application in vo\n+     *\n+     * @param sess            perun session containing principal\n+     * @param vo              for application\n+     * @param applicationType type of application\n+     * @throws DuplicateRegistrationAttemptException if the principal has already created application\n+     * @throws RegistrarException\n+     * @throws PrivilegeException\n+     */\n+    private void checkDupplicateVoApplications(PerunSession sess, Vo vo, AppType applicationType) throws DuplicateRegistrationAttemptException, RegistrarException, PrivilegeException {\n+        // select neccessary information from already existing Vo applications\n+        List<Application> applications = jdbc.query(\n+                \"select id, user_id, created_by, extSourceName, fed_info from application where apptype=? and vo_id=? and group_id is null and (state=? or state=?)\",\n+                IDENTITY_APP_MAPPER,\n+                applicationType.toString(), vo.getId(), AppState.NEW.toString(), AppState.VERIFIED.toString());\n+        // not member of VO - check for unprocessed applications\n+        List<Application> filteredApplications = filterPrincipalApplications(sess, applications);\n+        if (!filteredApplications.isEmpty()) {\n+            // user have unprocessed application for VO - can't post more\n+            throw new DuplicateRegistrationAttemptException(\n+                    \"Application for VO: \" + vo.getName() + \" already exists.\",\n+                    getApplicationById(filteredApplications.get(0).getId()),\n+                    getApplicationDataById(registrarSession, filteredApplications.get(0).getId()));\n+        }\n+    }\n+\n+    private int processApplication(PerunSession session, Application application, List<ApplicationFormItemData> data) throws PerunException {\n+\n+        // If user is known in Perun but unknown in GUI (user joined identity by consolidator)\n+        if (application.getUser() == null && session.getPerunPrincipal().getUser() != null) {\n+            application.setUser(session.getPerunPrincipal().getUser());\n+        }\n+\n+        // lock to prevent multiple submission of same application on server side\n+        String key = getLockKeyForApplication(application);\n+\n+        synchronized (runningCreateApplication) {\n+            if (runningCreateApplication.contains(key)) {\n+                throw new AlreadyProcessingException(\"Your application submission is being processed already.\");\n+            } else {\n+                runningCreateApplication.add(key);\n+            }\n+        }\n+\n+        // store user-ext-source attributes from session to application object\n+        LinkedHashMap<String, String> map = new LinkedHashMap<>(session.getPerunPrincipal().getAdditionalInformations());\n+        String additionalAttrs = BeansUtils.attributeValueToString(map, LinkedHashMap.class.getName());\n+        application.setFedInfo(additionalAttrs);\n+\n+        Application app;\n+        try {\n+\n+            // throws exception if user already submitted application or is already a member or can't submit it by VO/Group expiration rules.\n+            checkDuplicateRegistrationAttempt(session, application.getType(), (application.getGroup() != null) ? getFormForGroup(application.getGroup()) : getFormForVo(application.getVo()));\n+\n+            // using this to init inner transaction\n+            // all minor exceptions inside are catched, if not, it's ok to throw them out\n+            app = this.registrarManager.createApplicationInternal(session, application, data);\n+        } catch (Exception ex) {\n+            // clear flag and re-throw exception, since application was processed with exception\n+            synchronized (runningCreateApplication) {\n+                runningCreateApplication.remove(key);\n+            }\n+            throw ex;\n+        }\n+\n+        // try to verify (or even auto-approve) application\n+        try {\n+            boolean verified = tryToVerifyApplication(session, app);\n+            if (verified) {\n+                // try to APPROVE if auto approve\n+                tryToAutoApproveApplication(session, app);\n+            } else {\n+                // send request validation notification\n+                getMailManager().sendMessage(app, MailType.MAIL_VALIDATION, null, null);\n+            }\n+            // refresh current session, if submission was successful,\n+            // since user might have been created.\n+            AuthzResolverBlImpl.refreshSession(session);\n+        } catch (Exception ex) {\n+            log.error(\"[REGISTRAR] Unable to verify or auto-approve application {}, because of exception {}\", app, ex);\n+            // clear flag and re-throw exception, since application was processed with exception\n+            synchronized (runningCreateApplication) {\n+                runningCreateApplication.remove(key);\n+            }\n+            throw ex;\n+        }\n+\n+        // clear flag, since application was processed\n+        synchronized (runningCreateApplication) {\n+            runningCreateApplication.remove(key);\n+        }\n+\n+        return app.getId();\n+\n+    }\n+\n+    @Override\n+    public void updateApplicationType(PerunSession session, Application application) {\n+\n+        // TODO - add authorization (and add to rpc)\n+\n+        if (jdbc.update(\"update application set apptype=? where id=?\", application.getType().toString(), application.getId()) > 0) {\n+            log.debug(\"Application type changed to + \" + application.getType());\n+        }\n+    }\n+\n+    // ------------------ MAPPERS AND SELECTS -------------------------------------\n+\n+    // FIXME - we are retrieving GROUP name using only \"short_name\" so it's not same as getGroupById()\n+    static final String APP_SELECT = \"select a.id as id,a.vo_id as vo_id, a.group_id as group_id,a.apptype as apptype,a.fed_info as fed_info,a.state as state,\" +\n+            \"a.user_id as user_id,a.extsourcename as extsourcename, a.extsourcetype as extsourcetype, a.extsourceloa as extsourceloa, a.user_id as user_id, a.created_at as app_created_at, a.created_by as app_created_by, a.modified_at as app_modified_at, a.modified_by as app_modified_by, \" +\n+            \"v.name as vo_name, v.short_name as vo_short_name, v.created_by as vo_created_by, v.created_at as vo_created_at, v.created_by_uid as vo_created_by_uid, v.modified_by as vo_modified_by, \" +\n+            \"v.modified_at as vo_modified_at, v.modified_by_uid as vo_modified_by_uid, g.name as group_name, g.dsc as group_description, g.created_by as group_created_by, g.created_at as group_created_at, g.modified_by as group_modified_by, g.created_by_uid as group_created_by_uid, g.modified_by_uid as group_modified_by_uid,\" +\n+            \"g.modified_at as group_modified_at, g.vo_id as group_vo_id, g.parent_group_id as group_parent_group_id, g.uu_id as group_uu_id, u.first_name as user_first_name, u.last_name as user_last_name, u.middle_name as user_middle_name, \" +\n+            \"u.title_before as user_title_before, u.title_after as user_title_after, u.service_acc as user_service_acc, u.sponsored_acc as user_sponsored_acc , u.uu_id as user_uu_id from application a left outer join vos v on a.vo_id = v.id left outer join groups g on a.group_id = g.id left outer join users u on a.user_id = u.id\";\n+\n+    private static final String APP_TYPE_SELECT = \"select apptype from application_form_item_apptypes\";\n+\n+    private static final String FORM_SELECT = \"select id,vo_id,group_id,automatic_approval,automatic_approval_extension,module_name from application_form\";\n+\n+    private static final String FORM_ITEM_SELECT = \"select id,ordnum,shortname,required,type,fed_attr,src_attr,dst_attr,regex from application_form_items\";\n+\n+    private static final String FORM_ITEM_TEXTS_SELECT = \"select locale,label,options,help,error_message from application_form_item_texts\";\n+\n+    private static final RowMapper<Application> IDENTITY_APP_MAPPER = (resultSet, i) -> {\n+        Application app = new Application();\n+        app.setId(resultSet.getInt(\"id\"));\n+        app.setUser(new User(resultSet.getInt(\"user_id\"), \"\", \"\", \"\", \"\", \"\"));\n+        app.setCreatedBy(resultSet.getString(\"created_by\"));\n+        app.setExtSourceName(resultSet.getString(\"extsourcename\"));\n+        app.setFedInfo(resultSet.getString(\"fed_info\"));\n+        return app;\n+    };\n+\n+    static final RowMapper<Application> APP_MAPPER = (resultSet, i) -> {\n+\n+        Application app = new Application(resultSet.getInt(\"id\"), new Vo(resultSet.getInt(\"vo_id\"),\n+                resultSet.getString(\"vo_name\"), resultSet.getString(\"vo_short_name\"),\n+                resultSet.getString(\"vo_created_at\"), resultSet.getString(\"vo_created_by\"),\n+                resultSet.getString(\"vo_modified_at\"), resultSet.getString(\"vo_modified_by\"),\n+                resultSet.getInt(\"vo_created_by_uid\"), resultSet.getInt(\"vo_modified_by_uid\")),\n+                null, AppType.valueOf(resultSet.getString(\"apptype\")),\n+                resultSet.getString(\"fed_info\"), AppState.valueOf(resultSet.getString(\"state\")),\n+                resultSet.getString(\"extsourcename\"), resultSet.getString(\"extsourcetype\"),\n+                resultSet.getInt(\"extsourceloa\"), null);\n+\n+        // if group present\n+        if (resultSet.getInt(\"group_id\") != 0) {\n+            app.setGroup(new Group(resultSet.getInt(\"group_id\"), resultSet.getString(\"group_name\"),\n+                    resultSet.getString(\"group_description\"), resultSet.getString(\"group_created_at\"),\n+                    resultSet.getString(\"group_created_by\"), resultSet.getString(\"group_modified_at\"),\n+                    resultSet.getString(\"group_modified_by\"), resultSet.getInt(\"group_created_by_uid\"),\n+                    resultSet.getInt(\"group_modified_by_uid\")));\n+            app.getGroup().setVoId(resultSet.getInt(\"vo_id\"));\n+            app.getGroup().setUuid(resultSet.getObject(\"group_uu_id\", UUID.class));\n+\n+            if (resultSet.getInt(\"group_parent_group_id\") != 0) {\n+                app.getGroup().setParentGroupId(resultSet.getInt(\"group_parent_group_id\"));\n+            }\n+\n+        }\n+\n+        // if user present\n+        if (resultSet.getInt(\"user_id\") != 0) {\n+            app.setUser(new User(resultSet.getInt(\"user_id\"), resultSet.getString(\"user_first_name\"),\n+                    resultSet.getString(\"user_last_name\"), resultSet.getString(\"user_middle_name\"),\n+                    resultSet.getString(\"user_title_before\"), resultSet.getString(\"user_title_after\"),\n+                    resultSet.getBoolean(\"user_service_acc\"), resultSet.getBoolean(\"user_sponsored_acc\")));\n+            app.getUser().setUuid(resultSet.getObject(\"user_uu_id\", UUID.class));\n+        }\n+\n+        app.setCreatedAt(resultSet.getString(\"app_created_at\"));\n+        app.setCreatedBy(resultSet.getString(\"app_created_by\"));\n+        app.setModifiedAt(resultSet.getString(\"app_modified_at\"));\n+        app.setModifiedBy(resultSet.getString(\"app_modified_by\"));\n+\n+        return app;\n+\n+    };\n+\n+    private static final RowMapper<AppType> APP_TYPE_MAPPER = (resultSet, i) -> AppType.valueOf(resultSet.getString(1));\n+\n+    private static final RowMapper<ApplicationFormItem> ITEM_MAPPER = (resultSet, i) -> {\n+        ApplicationFormItem app = new ApplicationFormItem(resultSet.getInt(\"id\"),\n+                resultSet.getString(\"shortname\"), resultSet.getBoolean(\"required\"),\n+                Type.valueOf(resultSet.getString(\"type\")), resultSet.getString(\"fed_attr\"),\n+                resultSet.getString(\"src_attr\"), resultSet.getString(\"dst_attr\"), resultSet.getString(\"regex\"));\n+        app.setOrdnum(resultSet.getInt(\"ordnum\"));\n+        return app;\n+    };\n+\n+    private static final RowMapper<ApplicationFormItem.ItemTexts> ITEM_TEXTS_MAPPER = (resultSet, i) -> new ItemTexts(new Locale(resultSet.getString(\"locale\")),\n+            resultSet.getString(\"label\"), resultSet.getString(\"options\"), resultSet.getString(\"help\"),\n+            resultSet.getString(\"error_message\"));\n \n }\n",
            "diff_size": 3814
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/192/RegistrarManagerImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/styler_random/192/RegistrarManagerImpl.java\nindex f9d1101b9d5..77350496d12 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/192/RegistrarManagerImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/styler_random/192/RegistrarManagerImpl.java\n@@ -183,7 +183,7 @@ public class RegistrarManagerImpl implements RegistrarManager {\n \n \t// regular expression to match alfanumeric contents\n \tprivate static final Pattern alnumPattern = Pattern.compile(\".*\\\\p{Alnum}+.*\", Pattern.UNICODE_CHARACTER_CLASS);\n-\t\n+\n \tprivate final Set<String> runningCreateApplication = new HashSet<>();\n \tprivate final Set<Integer> runningApproveApplication = new HashSet<>();\n \tprivate final Set<Integer> runningRejectApplication = new HashSet<>();\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/192/RegistrarManagerImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/styler_three_grams/192/RegistrarManagerImpl.java\nindex f9d1101b9d5..a00280c0819 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/192/RegistrarManagerImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/styler_three_grams/192/RegistrarManagerImpl.java\n@@ -182,9 +182,9 @@ public class RegistrarManagerImpl implements RegistrarManager {\n \tprivate static final String shibLastNameVar = \"sn\";\n \n \t// regular expression to match alfanumeric contents\n-\tprivate static final Pattern alnumPattern = Pattern.compile(\".*\\\\p{Alnum}+.*\", Pattern.UNICODE_CHARACTER_CLASS);\n-\t\n-\tprivate final Set<String> runningCreateApplication = new HashSet<>();\n+\tprivate static final Pattern alnumPattern = Pattern.compile(\".*\\\\p{Alnum}+.*\", Pattern.UNICODE_CHARACTER_CLASS)\n+\n+\t; private final Set<String> runningCreateApplication = new HashSet<>();\n \tprivate final Set<Integer> runningApproveApplication = new HashSet<>();\n \tprivate final Set<Integer> runningRejectApplication = new HashSet<>();\n \tprivate final Set<Integer> runningDeleteApplication = new HashSet<>();\n",
            "diff_size": 3
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "naturalize",
        "codebuff"
    ]
}