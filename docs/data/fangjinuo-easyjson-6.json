{
    "project_name": "fangjinuo-easyjson",
    "error_id": "6",
    "information": {
        "errors": [
            {
                "line": "260",
                "column": "17",
                "severity": "warning",
                "message": "'.' is preceded with whitespace.",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.NoWhitespaceBeforeCheck"
            }
        ]
    },
    "source_code": "        }\n        exceptionMessage.append(\"but got: \").append(token.getClass().getName())\n                .append(\", for type token: \").append(token.toString()).append('.');\n\n        return new AssertionError(exceptionMessage.toString());\n    }",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/errored/1/6/TypeToken.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/styler/6/TypeToken.java\nindex 05a87b194fd..35e31137a64 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/errored/1/6/TypeToken.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/styler/6/TypeToken.java\n@@ -256,8 +256,7 @@ public class TypeToken<T> {\n         for (Class<?> clazz : expected) {\n             exceptionMessage.append(clazz.getName()).append(\", \");\n         }\n-        exceptionMessage.append(\"but got: \").append(token.getClass().getName())\n-                .append(\", for type token: \").append(token.toString()).append('.');\n+        exceptionMessage.append(\"but got: \").append(token.getClass().getName()).append(\", for type token: \").append(token.toString()).append('.');\n \n         return new AssertionError(exceptionMessage.toString());\n     }\n",
            "diff_size": 2
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "260",
                    "column": "13",
                    "severity": "warning",
                    "message": "'.' is preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.NoWhitespaceBeforeCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/errored/1/6/TypeToken.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/intellij/6/TypeToken.java\nindex 05a87b194fd..3192e924e1b 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/errored/1/6/TypeToken.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/intellij/6/TypeToken.java\n@@ -129,13 +129,13 @@ public class TypeToken<T> {\n             return rawType.isAssignableFrom(Types.getRawType(from));\n         } else if (type instanceof ParameterizedType) {\n             return isAssignableFrom(from, (ParameterizedType) type,\n-                    new HashMap<String, Type>());\n+                new HashMap<String, Type>());\n         } else if (type instanceof GenericArrayType) {\n             return rawType.isAssignableFrom(Types.getRawType(from))\n-                    && isAssignableFrom(from, (GenericArrayType) type);\n+                && isAssignableFrom(from, (GenericArrayType) type);\n         } else {\n             throw buildUnexpectedTypeError(\n-                    type, Class.class, ParameterizedType.class, GenericArrayType.class);\n+                type, Class.class, ParameterizedType.class, GenericArrayType.class);\n         }\n     }\n \n@@ -168,7 +168,7 @@ public class TypeToken<T> {\n                 t = classType;\n             }\n             return isAssignableFrom(t, (ParameterizedType) toGenericComponentType,\n-                    new HashMap<String, Type>());\n+                new HashMap<String, Type>());\n         }\n         // No generic defined on \"to\"; therefore, return true and let other\n         // checks determine assignability\n@@ -248,16 +248,16 @@ public class TypeToken<T> {\n     }\n \n     private static AssertionError buildUnexpectedTypeError(\n-            Type token, Class<?>... expected) {\n+        Type token, Class<?>... expected) {\n \n         // Build exception message\n         StringBuilder exceptionMessage =\n-                new StringBuilder(\"Unexpected type. Expected one of: \");\n+            new StringBuilder(\"Unexpected type. Expected one of: \");\n         for (Class<?> clazz : expected) {\n             exceptionMessage.append(clazz.getName()).append(\", \");\n         }\n         exceptionMessage.append(\"but got: \").append(token.getClass().getName())\n-                .append(\", for type token: \").append(token.toString()).append('.');\n+            .append(\", for type token: \").append(token.toString()).append('.');\n \n         return new AssertionError(exceptionMessage.toString());\n     }\n@@ -268,8 +268,8 @@ public class TypeToken<T> {\n      */\n     private static boolean matches(Type from, Type to, Map<String, Type> typeMap) {\n         return to.equals(from)\n-                || (from instanceof TypeVariable\n-                && to.equals(typeMap.get(((TypeVariable<?>) from).getName())));\n+            || (from instanceof TypeVariable\n+            && to.equals(typeMap.get(((TypeVariable<?>) from).getName())));\n \n     }\n \n@@ -281,7 +281,7 @@ public class TypeToken<T> {\n     @Override\n     public final boolean equals(Object o) {\n         return o instanceof TypeToken<?>\n-                && Types.equals(type, ((TypeToken<?>) o).type);\n+            && Types.equals(type, ((TypeToken<?>) o).type);\n     }\n \n     @Override\n",
            "diff_size": 10
        },
        {
            "tool": "naturalize",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/errored/1/6/TypeToken.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/naturalize/6/TypeToken.java\nindex 05a87b194fd..768adceec26 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/errored/1/6/TypeToken.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/naturalize/6/TypeToken.java\n@@ -128,12 +128,11 @@ public class TypeToken<T> {\n         if (type instanceof Class<?>) {\n             return rawType.isAssignableFrom(Types.getRawType(from));\n         } else if (type instanceof ParameterizedType) {\n-            return isAssignableFrom(from, (ParameterizedType) type,\n-                    new HashMap<String, Type>());\n-        } else if (type instanceof GenericArrayType) {\n+            return isAssignableFrom(from, (ParameterizedType) type, new HashMap<String, Type>());\n+    } else if (type instanceof GenericArrayType) {\n             return rawType.isAssignableFrom(Types.getRawType(from))\n                     && isAssignableFrom(from, (GenericArrayType) type);\n-        } else {\n+    } else {\n             throw buildUnexpectedTypeError(\n                     type, Class.class, ParameterizedType.class, GenericArrayType.class);\n         }\n@@ -167,8 +166,7 @@ public class TypeToken<T> {\n                 }\n                 t = classType;\n             }\n-            return isAssignableFrom(t, (ParameterizedType) toGenericComponentType,\n-                    new HashMap<String, Type>());\n+            return isAssignableFrom(t, (ParameterizedType) toGenericComponentType, new HashMap<String, Type>());\n         }\n         // No generic defined on \"to\"; therefore, return true and let other\n         // checks determine assignability\n@@ -179,10 +177,8 @@ public class TypeToken<T> {\n      * Private recursive helper function to actually do the type-safe checking\n      * of assignability.\n      */\n-    private static boolean isAssignableFrom(Type from, ParameterizedType to,\n-                                            Map<String, Type> typeVarMap) {\n-\n-        if (from == null) {\n+    private static boolean isAssignableFrom(Type from, ParameterizedType to, Map<String, Type> typeVarMap) {\n+    if (from == null) {\n             return false;\n         }\n \n@@ -232,9 +228,8 @@ public class TypeToken<T> {\n      * Checks if two parameterized types are exactly equal, under the variable\n      * replacement described in the typeVarMap.\n      */\n-    private static boolean typeEquals(ParameterizedType from,\n-                                      ParameterizedType to, Map<String, Type> typeVarMap) {\n-        if (from.getRawType().equals(to.getRawType())) {\n+    private static boolean typeEquals(ParameterizedType from, ParameterizedType to, Map<String, Type> typeVarMap) {\n+    if (from.getRawType().equals(to.getRawType())) {\n             Type[] fromArgs = from.getActualTypeArguments();\n             Type[] toArgs = to.getActualTypeArguments();\n             for (int i = 0; i < fromArgs.length; i++) {\n@@ -247,19 +242,15 @@ public class TypeToken<T> {\n         return false;\n     }\n \n-    private static AssertionError buildUnexpectedTypeError(\n-            Type token, Class<?>... expected) {\n-\n-        // Build exception message\n+    private static AssertionError buildUnexpectedTypeError(Type token, Class<?>... expected) {\n+    // Build exception message\n         StringBuilder exceptionMessage =\n                 new StringBuilder(\"Unexpected type. Expected one of: \");\n-        for (Class<?> clazz : expected) {\n+for (Class<?> clazz : expected) {\n             exceptionMessage.append(clazz.getName()).append(\", \");\n         }\n-        exceptionMessage.append(\"but got: \").append(token.getClass().getName())\n-                .append(\", for type token: \").append(token.toString()).append('.');\n-\n-        return new AssertionError(exceptionMessage.toString());\n+        exceptionMessage.append(\"but got: \").append(token.getClass().getName()).append(\", for type token: \").append(token.toString()).append('.');\n+return new AssertionError(exceptionMessage.toString());\n     }\n \n     /**\n@@ -269,8 +260,7 @@ public class TypeToken<T> {\n     private static boolean matches(Type from, Type to, Map<String, Type> typeMap) {\n         return to.equals(from)\n                 || (from instanceof TypeVariable\n-                && to.equals(typeMap.get(((TypeVariable<?>) from).getName())));\n-\n+        && to.equals(typeMap.get(((TypeVariable<?>) from).getName())));\n     }\n \n     @Override\n@@ -317,4 +307,4 @@ public class TypeToken<T> {\n     public static TypeToken<?> getArray(Type componentType) {\n         return new TypeToken<Object>(Types.arrayOf(componentType));\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 25
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/errored/1/6/TypeToken.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/codebuff/6/TypeToken.java\nindex 05a87b194fd..8505f6a24e2 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/errored/1/6/TypeToken.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/codebuff/6/TypeToken.java\n@@ -14,11 +14,9 @@\n \n package com.jn.easyjson.core.tree.bind;\n \n-\n import com.jn.langx.util.Preconditions;\n import com.jn.langx.util.reflect.type.ParameterizedTypeImpl;\n import com.jn.langx.util.reflect.type.Types;\n-\n import java.lang.reflect.GenericArrayType;\n import java.lang.reflect.ParameterizedType;\n import java.lang.reflect.Type;\n@@ -41,6 +39,7 @@ import java.util.Map;\n  * <p>This syntax cannot be used to create type literals that have wildcard\n  * parameters, such as {@code Class<?>} or {@code List<? extends CharSequence>}.\n  */\n+\n public class TypeToken<T> {\n     final Class<? super T> rawType;\n     final Type type;\n@@ -54,8 +53,9 @@ public class TypeToken<T> {\n      * parameter in the anonymous class's type hierarchy so we can reconstitute it\n      * at runtime despite erasure.\n      */\n-    @SuppressWarnings(\"unchecked\")\n-    protected TypeToken() {\n+\n+\n+    @SuppressWarnings(\"unchecked\") protected TypeToken() {\n         this.type = getSuperclassTypeParameter(getClass());\n         this.rawType = (Class<? super T>) Types.getRawType(type);\n         this.hashCode = type.hashCode();\n@@ -64,8 +64,9 @@ public class TypeToken<T> {\n     /**\n      * Unsafe. Constructs a type literal manually.\n      */\n-    @SuppressWarnings(\"unchecked\")\n-    TypeToken(Type type) {\n+\n+\n+    @SuppressWarnings(\"unchecked\") TypeToken(Type type) {\n         this.type = ParameterizedTypeImpl.canonicalize(Preconditions.checkNotNull(type));\n         this.rawType = (Class<? super T>) Types.getRawType(this.type);\n         this.hashCode = this.type.hashCode();\n@@ -75,6 +76,7 @@ public class TypeToken<T> {\n      * Returns the type from super class's type parameter in {@link ParameterizedTypeImpl#canonicalize\n      * canonical form}.\n      */\n+\n     static Type getSuperclassTypeParameter(Class<?> subclass) {\n         Type superclass = subclass.getGenericSuperclass();\n         if (superclass instanceof Class) {\n@@ -87,6 +89,7 @@ public class TypeToken<T> {\n     /**\n      * Returns the raw (non-generic) type for this type.\n      */\n+\n     public final Class<? super T> getRawType() {\n         return rawType;\n     }\n@@ -94,6 +97,7 @@ public class TypeToken<T> {\n     /**\n      * Gets underlying {@code Type} instance.\n      */\n+\n     public final Type getType() {\n         return type;\n     }\n@@ -104,6 +108,7 @@ public class TypeToken<T> {\n      * @deprecated this implementation may be inconsistent with javac for types\n      * with wildcards.\n      */\n+\n     @Deprecated\n     public boolean isAssignableFrom(Class<?> cls) {\n         return isAssignableFrom((Type) cls);\n@@ -115,27 +120,23 @@ public class TypeToken<T> {\n      * @deprecated this implementation may be inconsistent with javac for types\n      * with wildcards.\n      */\n+\n     @Deprecated\n     public boolean isAssignableFrom(Type from) {\n         if (from == null) {\n             return false;\n         }\n-\n         if (type.equals(from)) {\n             return true;\n         }\n-\n         if (type instanceof Class<?>) {\n             return rawType.isAssignableFrom(Types.getRawType(from));\n         } else if (type instanceof ParameterizedType) {\n-            return isAssignableFrom(from, (ParameterizedType) type,\n-                    new HashMap<String, Type>());\n+            return isAssignableFrom(from, (ParameterizedType) type, new HashMap<String, Type>());\n         } else if (type instanceof GenericArrayType) {\n-            return rawType.isAssignableFrom(Types.getRawType(from))\n-                    && isAssignableFrom(from, (GenericArrayType) type);\n-        } else {\n-            throw buildUnexpectedTypeError(\n-                    type, Class.class, ParameterizedType.class, GenericArrayType.class);\n+                   return rawType.isAssignableFrom(Types.getRawType(from)) && isAssignableFrom(from, (GenericArrayType) type);\n+               } else {\n+            throw buildUnexpectedTypeError(type, Class.class, ParameterizedType.class, GenericArrayType.class);\n         }\n     }\n \n@@ -145,6 +146,7 @@ public class TypeToken<T> {\n      * @deprecated this implementation may be inconsistent with javac for types\n      * with wildcards.\n      */\n+\n     @Deprecated\n     public boolean isAssignableFrom(TypeToken<?> token) {\n         return isAssignableFrom(token.getType());\n@@ -154,6 +156,7 @@ public class TypeToken<T> {\n      * Private helper function that performs some assignability checks for\n      * the provided GenericArrayType.\n      */\n+\n     private static boolean isAssignableFrom(Type from, GenericArrayType to) {\n         Type toGenericComponentType = to.getGenericComponentType();\n         if (toGenericComponentType instanceof ParameterizedType) {\n@@ -167,8 +170,7 @@ public class TypeToken<T> {\n                 }\n                 t = classType;\n             }\n-            return isAssignableFrom(t, (ParameterizedType) toGenericComponentType,\n-                    new HashMap<String, Type>());\n+            return isAssignableFrom(t, (ParameterizedType) toGenericComponentType, new HashMap<String, Type>());\n         }\n         // No generic defined on \"to\"; therefore, return true and let other\n         // checks determine assignability\n@@ -179,13 +181,11 @@ public class TypeToken<T> {\n      * Private recursive helper function to actually do the type-safe checking\n      * of assignability.\n      */\n-    private static boolean isAssignableFrom(Type from, ParameterizedType to,\n-                                            Map<String, Type> typeVarMap) {\n \n+    private static boolean isAssignableFrom(Type from, ParameterizedType to, Map<String, Type> typeVarMap) {\n         if (from == null) {\n             return false;\n         }\n-\n         if (to.equals(from)) {\n             return true;\n         }\n@@ -216,7 +216,6 @@ public class TypeToken<T> {\n                 return true;\n             }\n         }\n-\n         for (Type itype : clazz.getGenericInterfaces()) {\n             if (isAssignableFrom(itype, to, new HashMap<String, Type>(typeVarMap))) {\n                 return true;\n@@ -232,8 +231,8 @@ public class TypeToken<T> {\n      * Checks if two parameterized types are exactly equal, under the variable\n      * replacement described in the typeVarMap.\n      */\n-    private static boolean typeEquals(ParameterizedType from,\n-                                      ParameterizedType to, Map<String, Type> typeVarMap) {\n+\n+    private static boolean typeEquals(ParameterizedType from, ParameterizedType to, Map<String, Type> typeVarMap) {\n         if (from.getRawType().equals(to.getRawType())) {\n             Type[] fromArgs = from.getActualTypeArguments();\n             Type[] toArgs = to.getActualTypeArguments();\n@@ -247,18 +246,14 @@ public class TypeToken<T> {\n         return false;\n     }\n \n-    private static AssertionError buildUnexpectedTypeError(\n-            Type token, Class<?>... expected) {\n+    private static AssertionError buildUnexpectedTypeError(Type token, Class<?>... expected) {\n \n         // Build exception message\n-        StringBuilder exceptionMessage =\n-                new StringBuilder(\"Unexpected type. Expected one of: \");\n+        StringBuilder exceptionMessage = new StringBuilder(\"Unexpected type. Expected one of: \");\n         for (Class<?> clazz : expected) {\n             exceptionMessage.append(clazz.getName()).append(\", \");\n         }\n-        exceptionMessage.append(\"but got: \").append(token.getClass().getName())\n-                .append(\", for type token: \").append(token.toString()).append('.');\n-\n+        exceptionMessage.append(\"but got: \").append(token.getClass().getName()).append(\", for type token: \").append(token.toString()).append('.');\n         return new AssertionError(exceptionMessage.toString());\n     }\n \n@@ -266,11 +261,9 @@ public class TypeToken<T> {\n      * Checks if two types are the same or are equivalent under a variable mapping\n      * given in the type map that was provided.\n      */\n-    private static boolean matches(Type from, Type to, Map<String, Type> typeMap) {\n-        return to.equals(from)\n-                || (from instanceof TypeVariable\n-                && to.equals(typeMap.get(((TypeVariable<?>) from).getName())));\n \n+    private static boolean matches(Type from, Type to, Map<String, Type> typeMap) {\n+        return to.equals(from) || (from instanceof TypeVariable && to.equals(typeMap.get(((TypeVariable<?>) from).getName())));\n     }\n \n     @Override\n@@ -280,8 +273,7 @@ public class TypeToken<T> {\n \n     @Override\n     public final boolean equals(Object o) {\n-        return o instanceof TypeToken<?>\n-                && Types.equals(type, ((TypeToken<?>) o).type);\n+        return o instanceof TypeToken<?> && Types.equals(type, ((TypeToken<?>) o).type);\n     }\n \n     @Override\n@@ -292,6 +284,7 @@ public class TypeToken<T> {\n     /**\n      * Gets type literal for the given {@code Type} instance.\n      */\n+\n     public static TypeToken<?> get(Type type) {\n         return new TypeToken<Object>(type);\n     }\n@@ -299,6 +292,7 @@ public class TypeToken<T> {\n     /**\n      * Gets type literal for the given {@code Class} instance.\n      */\n+\n     public static <T> TypeToken<T> get(Class<T> type) {\n         return new TypeToken<T>(type);\n     }\n@@ -307,6 +301,7 @@ public class TypeToken<T> {\n      * Gets type literal for the parameterized type represented by applying {@code typeArguments} to\n      * {@code rawType}.\n      */\n+\n     public static TypeToken<?> getParameterized(Type rawType, Type... typeArguments) {\n         return new TypeToken<Object>(Types.getParameterizedTypeWithOwnerType(null, rawType, typeArguments));\n     }\n@@ -314,7 +309,8 @@ public class TypeToken<T> {\n     /**\n      * Gets type literal for the array type whose elements are all instances of {@code componentType}.\n      */\n+\n     public static TypeToken<?> getArray(Type componentType) {\n         return new TypeToken<Object>(Types.arrayOf(componentType));\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 54
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/errored/1/6/TypeToken.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/styler_random/6/TypeToken.java\nindex 05a87b194fd..35e31137a64 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/errored/1/6/TypeToken.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/styler_random/6/TypeToken.java\n@@ -256,8 +256,7 @@ public class TypeToken<T> {\n         for (Class<?> clazz : expected) {\n             exceptionMessage.append(clazz.getName()).append(\", \");\n         }\n-        exceptionMessage.append(\"but got: \").append(token.getClass().getName())\n-                .append(\", for type token: \").append(token.toString()).append('.');\n+        exceptionMessage.append(\"but got: \").append(token.getClass().getName()).append(\", for type token: \").append(token.toString()).append('.');\n \n         return new AssertionError(exceptionMessage.toString());\n     }\n",
            "diff_size": 2
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/errored/1/6/TypeToken.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/styler_three_grams/6/TypeToken.java\nindex 05a87b194fd..35e31137a64 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/errored/1/6/TypeToken.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/styler_three_grams/6/TypeToken.java\n@@ -256,8 +256,7 @@ public class TypeToken<T> {\n         for (Class<?> clazz : expected) {\n             exceptionMessage.append(clazz.getName()).append(\", \");\n         }\n-        exceptionMessage.append(\"but got: \").append(token.getClass().getName())\n-                .append(\", for type token: \").append(token.toString()).append('.');\n+        exceptionMessage.append(\"but got: \").append(token.getClass().getName()).append(\", for type token: \").append(token.toString()).append('.');\n \n         return new AssertionError(exceptionMessage.toString());\n     }\n",
            "diff_size": 2
        }
    ],
    "repaired_by": [
        "styler",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "intellij"
    ]
}