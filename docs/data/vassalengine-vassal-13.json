{
    "project_name": "vassalengine-vassal",
    "error_id": "13",
    "information": {
        "errors": [
            {
                "line": "536",
                "column": "22",
                "severity": "error",
                "message": "'(' is followed by whitespace.",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
            }
        ]
    },
    "source_code": "      final int y  =  (data[i] >> 16) & 0xFF;\n      final int pb = ((data[i] >>  8) & 0xFF) - 128;\n      final int pr = ( data[i]        & 0xFF) - 128;\n\n      final int a  = (data[i] >> 24) & 0xFF;\n      final int r = (int) Math.round(y + 1.402 * pr);",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vassalengine-vassal/errored/1/13/ImageIOImageLoader.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vassalengine-vassal/styler/13/ImageIOImageLoader.java\nindex d08af79ecc9..98ab9ded2e2 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vassalengine-vassal/errored/1/13/ImageIOImageLoader.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vassalengine-vassal/styler/13/ImageIOImageLoader.java\n@@ -533,7 +533,7 @@ public class ImageIOImageLoader implements ImageLoader {\n     for (int i = 0; i < data.length; ++i) {\n       final int y  =  (data[i] >> 16) & 0xFF;\n       final int pb = ((data[i] >>  8) & 0xFF) - 128;\n-      final int pr = ( data[i]        & 0xFF) - 128;\n+      final int pr = (data[i]        & 0xFF) - 128;\n \n       final int a  = (data[i] >> 24) & 0xFF;\n       final int r = (int) Math.round(y + 1.402 * pr);\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vassalengine-vassal/errored/1/13/ImageIOImageLoader.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vassalengine-vassal/intellij/13/ImageIOImageLoader.java\nindex d08af79ecc9..8c70b0454fb 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vassalengine-vassal/errored/1/13/ImageIOImageLoader.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vassalengine-vassal/intellij/13/ImageIOImageLoader.java\n@@ -39,13 +39,13 @@ import VASSAL.tools.lang.Reference;\n \n /**\n  * An image loader which wraps {@link ImageIO}.\n- *\n+ * <p>\n  * This class handles the assorted problems with various versions of\n  * {@link ImageIO}, ensuring that we can reliably load image files to\n  * {link BufferedImages} with a predictable type.\n  *\n- * @since 3.1.0\n  * @author Joel Uckelman\n+ * @since 3.1.0\n  */\n public class ImageIOImageLoader implements ImageLoader {\n \n@@ -55,7 +55,7 @@ public class ImageIOImageLoader implements ImageLoader {\n    * Create an image loader.\n    *\n    * @param tconv the <code>ImageTypeConverter</code> to use for type\n-   * conversions\n+   *              conversions\n    */\n   public ImageIOImageLoader(ImageTypeConverter tconv) {\n     this.tconv = tconv;\n@@ -72,8 +72,7 @@ public class ImageIOImageLoader implements ImageLoader {\n       // We intentionally bypass the normal image loading system\n       // in order to see how ImageIO loads the test image.\n       img = ImageIO.read(new MemoryCacheImageInputStream(in));\n-    }\n-    catch (IOException e) {\n+    } catch (IOException e) {\n       // this should not happen\n       throw new IllegalStateException();\n     }\n@@ -127,16 +126,15 @@ public class ImageIOImageLoader implements ImageLoader {\n   /**\n    * Loads an image.\n    *\n-   * @param name the image name\n-   * @param in the input stream\n-   * @param typeIfOpaque the requested image type for opaque images\n+   * @param name              the image name\n+   * @param in                the input stream\n+   * @param typeIfOpaque      the requested image type for opaque images\n    * @param typeIfTransparent the requested image type for transparent images\n-   * @param managed <code>true</code> if a managed image should be returned\n+   * @param managed           <code>true</code> if a managed image should be returned\n    * @return the image\n-   *\n-   * @throws BrokenImageException if the image is faulty\n+   * @throws BrokenImageException           if the image is faulty\n    * @throws UnrecognizedImageTypeException if the image type is not recognized\n-   * @throws ImageIOException if reading the image goes wrong\n+   * @throws ImageIOException               if reading the image goes wrong\n    */\n   @Override\n   public BufferedImage load(\n@@ -203,7 +201,8 @@ public class ImageIOImageLoader implements ImageLoader {\n             // before the first IDAT chunk; therefore, if we find an IDAT\n             // we're done.\n \n-            DONE_PNG: for (;;) {\n+            DONE_PNG:\n+            for (; ; ) {\n               ch = PNGDecoder.decodeChunk(din);\n \n               switch (ch.type) {\n@@ -234,14 +233,13 @@ public class ImageIOImageLoader implements ImageLoader {\n               // byte of each sample is empty because we are dealing with\n               // 8-bit-per-channel images.\n               tRNS = 0xff000000 |\n-                     ((ch.data[1] & 0xff) << 16) |\n-                     ((ch.data[3] & 0xff) <<  8) |\n-                      (ch.data[5] & 0xff);\n+                ((ch.data[1] & 0xff) << 16) |\n+                ((ch.data[3] & 0xff) << 8) |\n+                (ch.data[5] & 0xff);\n             }\n           }\n         }\n-      }\n-      else if (YCbCrBug) {\n+      } else if (YCbCrBug) {\n         rin.reset();\n         rin.mark(512);\n \n@@ -257,7 +255,8 @@ public class ImageIOImageLoader implements ImageLoader {\n           JPEGDecoder.Chunk ch;\n           fix_YCbCr = true;\n \n-          DONE_JPEG: for (;;) {\n+          DONE_JPEG:\n+          for (; ; ) {\n             ch = JPEGDecoder.decodeChunk(din);\n \n             switch (ch.type) {\n@@ -282,17 +281,17 @@ public class ImageIOImageLoader implements ImageLoader {\n               // whether this JPEG triggers the bug.\n               fix_YCbCr =\n                 ch.data.length == 15 &&\n-                ch.data[5] == 3 &&    // color components\n-                ch.data[7] == ch.data[10] &&\n-                ch.data[7] == ch.data[13];\n+                  ch.data[5] == 3 &&    // color components\n+                  ch.data[7] == ch.data[10] &&\n+                  ch.data[7] == ch.data[13];\n               break DONE_JPEG;\n \n             case JPEGDecoder.APP0:\n               if (ch.data.length >= 4 &&\n-                  ch.data[0] == 'J' &&\n-                  ch.data[1] == 'F' &&\n-                  ch.data[2] == 'I' &&\n-                  ch.data[3] == 'F') {\n+                ch.data[0] == 'J' &&\n+                ch.data[1] == 'F' &&\n+                ch.data[2] == 'I' &&\n+                ch.data[3] == 'F') {\n                 // We've seen a JFIF, this image is ok.\n                 fix_YCbCr = false;\n                 break DONE_JPEG;\n@@ -303,18 +302,18 @@ public class ImageIOImageLoader implements ImageLoader {\n               // Check whether we have a color profile. If so, then ImageIO\n               // can handle decoding the image.\n               if (ch.data.length >= 12 &&\n-                  ch.data[0]  == 'I' &&\n-                  ch.data[1]  == 'C' &&\n-                  ch.data[2]  == 'C' &&\n-                  ch.data[3]  == '_' &&\n-                  ch.data[4]  == 'P' &&\n-                  ch.data[5]  == 'R' &&\n-                  ch.data[6]  == 'O' &&\n-                  ch.data[7]  == 'F' &&\n-                  ch.data[8]  == 'I' &&\n-                  ch.data[9]  == 'L' &&\n-                  ch.data[10] == 'E' &&\n-                  ch.data[11] == 0x00) {\n+                ch.data[0] == 'I' &&\n+                ch.data[1] == 'C' &&\n+                ch.data[2] == 'C' &&\n+                ch.data[3] == '_' &&\n+                ch.data[4] == 'P' &&\n+                ch.data[5] == 'R' &&\n+                ch.data[6] == 'O' &&\n+                ch.data[7] == 'F' &&\n+                ch.data[8] == 'I' &&\n+                ch.data[9] == 'L' &&\n+                ch.data[10] == 'E' &&\n+                ch.data[11] == 0x00) {\n                 // We have a color profile, this image is ok.\n                 fix_YCbCr = false;\n                 break DONE_JPEG;\n@@ -344,18 +343,16 @@ public class ImageIOImageLoader implements ImageLoader {\n       // Load the image\n       rin.reset();\n       img = wrapImageIO(name, rin, readImage);\n-    }\n-    catch (ImageIOException e) {\n+    } catch (ImageIOException e) {\n       // Don't wrap ImageIOExceptions.\n       throw e;\n-    }\n-    catch (IOException e) {\n+    } catch (IOException e) {\n       throw new ImageIOException(name, e);\n     }\n \n     final int type =\n       img.getTransparency() == BufferedImage.OPAQUE && !fix_tRNS\n-      ? typeIfOpaque : typeIfTransparent;\n+        ? typeIfOpaque : typeIfTransparent;\n \n     final Reference<BufferedImage> ref = new Reference<>(img);\n \n@@ -364,8 +361,7 @@ public class ImageIOImageLoader implements ImageLoader {\n       img = null;\n       img = fix_tRNS(ref, tRNS, type);\n       ref.obj = img;\n-    }\n-    else if (fix_YCbCr) {\n+    } else if (fix_YCbCr) {\n       // Fix up color space in misinterpreted JPEGs.\n       img = null;\n       img = fix_YCbCr(ref, type);\n@@ -390,11 +386,10 @@ public class ImageIOImageLoader implements ImageLoader {\n   }\n \n   protected <T> T wrapImageIO(String name, InputStream in, Wrapper<T> w)\n-                                                      throws ImageIOException {\n+    throws ImageIOException {\n     try {\n       return w.run(name, in);\n-    }\n-    catch (ArrayIndexOutOfBoundsException | IllegalArgumentException | CMMException e) {\n+    } catch (ArrayIndexOutOfBoundsException | IllegalArgumentException | CMMException e) {\n       // Note: ImageIO can throw an ArrayIndexOutOfBoundsException for\n       // some corrupt JPEGs. This problem is noted in Sun Bug 6351707,\n       //\n@@ -414,17 +409,17 @@ public class ImageIOImageLoader implements ImageLoader {\n       // http://bugs.sun.com/view_bug.do?bug_id=6444360\n       // http://bugs.sun.com/view_bug.do?bug_id=6839133\n       throw new BrokenImageException(name, e);\n-    }\n-    catch (ImageIOException e) {\n+    } catch (ImageIOException e) {\n       // Don't wrap ImageIOExceptions.\n       throw e;\n-    }\n-    catch (IOException e) {\n+    } catch (IOException e) {\n       throw new ImageIOException(name, e);\n     }\n   }\n \n-  /** A functor for reading images. */\n+  /**\n+   * A functor for reading images.\n+   */\n   protected static final Wrapper<BufferedImage> readImage = new Wrapper<>() {\n     /**\n      * Loads an image.\n@@ -439,13 +434,17 @@ public class ImageIOImageLoader implements ImageLoader {\n     public BufferedImage run(String name, InputStream in) throws IOException {\n       final BufferedImage img =\n         ImageIO.read(new MemoryCacheImageInputStream(in));\n-      if (img == null) throw new UnrecognizedImageTypeException(name);\n+      if (img == null) {\n+        throw new UnrecognizedImageTypeException(name);\n+      }\n \n       return img;\n     }\n   };\n \n-  /** A functor for reading image dimensions. */\n+  /**\n+   * A functor for reading image dimensions.\n+   */\n   protected static final Wrapper<Dimension> readSize = new Wrapper<>() {\n     /**\n      * Gets the size of an image.\n@@ -463,14 +462,15 @@ public class ImageIOImageLoader implements ImageLoader {\n       final ImageInputStream stream = new MemoryCacheImageInputStream(in);\n \n       final Iterator<ImageReader> i = ImageIO.getImageReaders(stream);\n-      if (!i.hasNext()) throw new UnrecognizedImageTypeException(name);\n+      if (!i.hasNext()) {\n+        throw new UnrecognizedImageTypeException(name);\n+      }\n \n       final ImageReader reader = i.next();\n       try {\n         reader.setInput(stream);\n         return new Dimension(reader.getWidth(0), reader.getHeight(0));\n-      }\n-      finally {\n+      } finally {\n         reader.dispose();\n       }\n     }\n@@ -484,12 +484,12 @@ public class ImageIOImageLoader implements ImageLoader {\n     // premultiplied doesn't matter, since fully transparent black pixels\n     // are the same in both.\n     if (img.getType() != BufferedImage.TYPE_INT_ARGB &&\n-        img.getType() != BufferedImage.TYPE_INT_ARGB_PRE) {\n+      img.getType() != BufferedImage.TYPE_INT_ARGB_PRE) {\n \n       // If the requested type is not an ARGB one, then we convert to ARGB\n       // for applying this fix.\n       if (type != BufferedImage.TYPE_INT_ARGB &&\n-          type != BufferedImage.TYPE_INT_ARGB_PRE) {\n+        type != BufferedImage.TYPE_INT_ARGB_PRE) {\n         type = BufferedImage.TYPE_INT_ARGB;\n       }\n \n@@ -503,22 +503,24 @@ public class ImageIOImageLoader implements ImageLoader {\n \n     // Set all pixels of the transparent color to have alpha 0.\n     for (int i = 0; i < data.length; ++i) {\n-      if (data[i] == tRNS) data[i] = 0x00000000;\n+      if (data[i] == tRNS) {\n+        data[i] = 0x00000000;\n+      }\n     }\n \n     return img;\n   }\n \n   protected BufferedImage fix_YCbCr(Reference<BufferedImage> ref, int type)\n-                                                      throws ImageIOException {\n+    throws ImageIOException {\n     BufferedImage img = ref.obj;\n \n     // Ensure that we are working with RGB or ARGB data.\n     if (img.getType() != BufferedImage.TYPE_INT_RGB &&\n-        img.getType() != BufferedImage.TYPE_INT_ARGB) {\n+      img.getType() != BufferedImage.TYPE_INT_ARGB) {\n \n       if (type != BufferedImage.TYPE_INT_RGB &&\n-          type != BufferedImage.TYPE_INT_ARGB) {\n+        type != BufferedImage.TYPE_INT_ARGB) {\n         type = BufferedImage.TYPE_INT_ARGB;\n       }\n \n@@ -531,19 +533,19 @@ public class ImageIOImageLoader implements ImageLoader {\n     final int[] data = db.getData();\n \n     for (int i = 0; i < data.length; ++i) {\n-      final int y  =  (data[i] >> 16) & 0xFF;\n-      final int pb = ((data[i] >>  8) & 0xFF) - 128;\n-      final int pr = ( data[i]        & 0xFF) - 128;\n+      final int y = (data[i] >> 16) & 0xFF;\n+      final int pb = ((data[i] >> 8) & 0xFF) - 128;\n+      final int pr = (data[i] & 0xFF) - 128;\n \n-      final int a  = (data[i] >> 24) & 0xFF;\n+      final int a = (data[i] >> 24) & 0xFF;\n       final int r = (int) Math.round(y + 1.402 * pr);\n       final int g = (int) Math.round(y - 0.34414 * pb - 0.71414 * pr);\n       final int b = (int) Math.round(y + 1.772 * pb);\n \n       data[i] = (a << 24) |\n-                ((r < 0 ? 0 : (r > 0xFF ? 0xFF : r)) << 16) |\n-                ((g < 0 ? 0 : (g > 0xFF ? 0xFF : g)) <<  8) |\n-                 (b < 0 ? 0 : (b > 0xFF ? 0xFF : b));\n+        ((r < 0 ? 0 : (r > 0xFF ? 0xFF : r)) << 16) |\n+        ((g < 0 ? 0 : (g > 0xFF ? 0xFF : g)) << 8) |\n+        (b < 0 ? 0 : (b > 0xFF ? 0xFF : b));\n     }\n \n     return img;\n@@ -553,12 +555,11 @@ public class ImageIOImageLoader implements ImageLoader {\n    * Gets the size of an image.\n    *\n    * @param name the image name\n-   * @param in the input stream\n+   * @param in   the input stream\n    * @return the size of the image\n-   *\n-   * @throws BrokenImageException if the image is faulty\n+   * @throws BrokenImageException           if the image is faulty\n    * @throws UnrecognizedImageTypeException if the image type is not recognized\n-   * @throws ImageIOException if reading the image goes wrong\n+   * @throws ImageIOException               if reading the image goes wrong\n    */\n   @Override\n   public Dimension size(String name, InputStream in) throws ImageIOException {\n",
            "diff_size": 88
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vassalengine-vassal/errored/1/13/ImageIOImageLoader.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vassalengine-vassal/styler_random/13/ImageIOImageLoader.java\nindex d08af79ecc9..98ab9ded2e2 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vassalengine-vassal/errored/1/13/ImageIOImageLoader.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vassalengine-vassal/styler_random/13/ImageIOImageLoader.java\n@@ -533,7 +533,7 @@ public class ImageIOImageLoader implements ImageLoader {\n     for (int i = 0; i < data.length; ++i) {\n       final int y  =  (data[i] >> 16) & 0xFF;\n       final int pb = ((data[i] >>  8) & 0xFF) - 128;\n-      final int pr = ( data[i]        & 0xFF) - 128;\n+      final int pr = (data[i]        & 0xFF) - 128;\n \n       final int a  = (data[i] >> 24) & 0xFF;\n       final int r = (int) Math.round(y + 1.402 * pr);\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vassalengine-vassal/errored/1/13/ImageIOImageLoader.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vassalengine-vassal/styler_three_grams/13/ImageIOImageLoader.java\nindex d08af79ecc9..98ab9ded2e2 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vassalengine-vassal/errored/1/13/ImageIOImageLoader.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vassalengine-vassal/styler_three_grams/13/ImageIOImageLoader.java\n@@ -533,7 +533,7 @@ public class ImageIOImageLoader implements ImageLoader {\n     for (int i = 0; i < data.length; ++i) {\n       final int y  =  (data[i] >> 16) & 0xFF;\n       final int pb = ((data[i] >>  8) & 0xFF) - 128;\n-      final int pr = ( data[i]        & 0xFF) - 128;\n+      final int pr = (data[i]        & 0xFF) - 128;\n \n       final int a  = (data[i] >> 24) & 0xFF;\n       final int r = (int) Math.round(y + 1.402 * pr);\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "naturalize",
        "codebuff"
    ]
}