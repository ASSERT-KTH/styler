{
    "project_name": "wso2-attic-commons",
    "error_id": "298",
    "information": {
        "errors": [
            {
                "line": "378",
                "severity": "error",
                "message": "Line is longer than 120 characters (found 130).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": "     * @return true if access is allowed through concurrent throttling ,o.w false\n     */\n    private boolean doConcurrentThrottling(ConcurrentAccessController concurrentAccessController, MessageContext messageContext) {\n\n        boolean canAccess = true;\n        int available;",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/298/ThrottleHandler.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler/298/ThrottleHandler.java\nindex 25ae6590d7e..063972204b7 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/298/ThrottleHandler.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler/298/ThrottleHandler.java\n@@ -375,9 +375,10 @@ public abstract class ThrottleHandler extends AbstractHandler {\n      * @param messageContext             MessageContext - message level states\r\n      * @return true if access is allowed through concurrent throttling ,o.w false\r\n      */\r\n-    private boolean doConcurrentThrottling(ConcurrentAccessController concurrentAccessController, MessageContext messageContext) {\r\n+    private boolean doConcurrentThrottling(ConcurrentAccessController concurrentAccessController,\r\n+                                               MessageContext messageContext) {\r\n \r\n-        boolean canAccess = true;\r\n+boolean canAccess = true;\r\n         int available;\r\n \r\n         if (concurrentAccessController != null) {\r\n",
            "diff_size": 3
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/298/ThrottleHandler.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/intellij/298/ThrottleHandler.java\nindex 25ae6590d7e..1686c3230a7 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/298/ThrottleHandler.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/intellij/298/ThrottleHandler.java\n@@ -1,20 +1,20 @@\n /*\r\n-* Copyright 2005,2006 WSO2, Inc. http://wso2.com\r\n-*\r\n-* Licensed under the Apache License, Version 2.0 (the \"License\");\r\n-* you may not use this file except in compliance with the License.\r\n-* You may obtain a copy of the License at\r\n-*\r\n-*      http://www.apache.org/licenses/LICENSE-2.0\r\n-*\r\n-* Unless required by applicable law or agreed to in writing, software\r\n-* distributed under the License is distributed on an \"AS IS\" BASIS,\r\n-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n-* See the License for the specific language governing permissions and\r\n-* limitations under the License.\r\n-*\r\n-*\r\n-*/\r\n+ * Copyright 2005,2006 WSO2, Inc. http://wso2.com\r\n+ *\r\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *\r\n+ *      http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ *\r\n+ *\r\n+ */\r\n \r\n package org.wso2.throttle.module.handler;\r\n \r\n@@ -43,507 +43,508 @@ import java.util.Map;\n \r\n public abstract class ThrottleHandler extends AbstractHandler {\r\n \r\n-    private static Log log = LogFactory.getLog(ThrottleHandler.class.getName());\r\n-    /* The AccessRateController - control(limit) access for a remote caller */\r\n-    private AccessRateController accessRateController;\r\n-\r\n-    private RoleBasedAccessRateController roleBasedAccessController;\r\n-\r\n-    private boolean debugOn;\r\n-\r\n-    public ThrottleHandler() {\r\n-        this.debugOn = log.isDebugEnabled();\r\n-        this.accessRateController = new AccessRateController();\r\n-        this.roleBasedAccessController = new RoleBasedAccessRateController();\r\n+  private static Log log = LogFactory.getLog(ThrottleHandler.class.getName());\r\n+  /* The AccessRateController - control(limit) access for a remote caller */\r\n+  private AccessRateController accessRateController;\r\n+\r\n+  private RoleBasedAccessRateController roleBasedAccessController;\r\n+\r\n+  private boolean debugOn;\r\n+\r\n+  public ThrottleHandler() {\r\n+    this.debugOn = log.isDebugEnabled();\r\n+    this.accessRateController = new AccessRateController();\r\n+    this.roleBasedAccessController = new RoleBasedAccessRateController();\r\n+  }\r\n+\r\n+  /**\r\n+   * @return int - indicates the type of the throttle according to the scope\r\n+   */\r\n+  protected abstract int getThrottleType();\r\n+\r\n+  /**\r\n+   * Loads a throttle metadata for a particular throttle type\r\n+   *\r\n+   * @param messageContext - The messageContext\r\n+   * @param throttleType   - The type of throttle\r\n+   * @return IPBaseThrottleConfiguration     - The IPBaseThrottleConfiguration - load from AxisConfiguration\r\n+   * @throws ThrottleException Throws if the throttle type is unsupported\r\n+   */\r\n+\r\n+  public Throttle loadThrottle(MessageContext messageContext,\r\n+                               int throttleType) throws ThrottleException {\r\n+\r\n+    Throttle throttle = null;\r\n+    ConfigurationContext configContext = messageContext.getConfigurationContext();\r\n+    //the Parameter which hold throttle ipbase object\r\n+    // to get throttles map from the configuration context\r\n+\r\n+    Map throttles = (Map) configContext.getPropertyNonReplicable(ThrottleConstants.THROTTLES_MAP);\r\n+    if (throttles == null) {\r\n+      if (debugOn) {\r\n+        log.debug(\"Couldn't find throttles object map .. thottlling will not be occurred \");\r\n+      }\r\n+      return null;\r\n     }\r\n-\r\n-    /**\r\n-     * @return int - indicates the type of the throttle according to the scope\r\n-     */\r\n-    protected abstract int getThrottleType();\r\n-\r\n-    /**\r\n-     * Loads a throttle metadata for a particular throttle type\r\n-     *\r\n-     * @param messageContext - The messageContext\r\n-     * @param throttleType   - The type of throttle\r\n-     * @return IPBaseThrottleConfiguration     - The IPBaseThrottleConfiguration - load from AxisConfiguration\r\n-     * @throws ThrottleException Throws if the throttle type is unsupported\r\n-     */\r\n-\r\n-    public Throttle loadThrottle(MessageContext messageContext,\r\n-                                 int throttleType) throws ThrottleException {\r\n-\r\n-        Throttle throttle = null;\r\n-        ConfigurationContext configContext = messageContext.getConfigurationContext();\r\n-        //the Parameter which hold throttle ipbase object\r\n-        // to get throttles map from the configuration context\r\n-\r\n-        Map throttles = (Map) configContext.getPropertyNonReplicable(ThrottleConstants.THROTTLES_MAP);\r\n-        if (throttles == null) {\r\n-            if (debugOn) {\r\n-                log.debug(\"Couldn't find throttles object map .. thottlling will not be occurred \");\r\n+    switch (throttleType) {\r\n+    case ThrottleConstants.GLOBAL_THROTTLE: {\r\n+      throttle =\r\n+        (Throttle) throttles.get(ThrottleConstants.GLOBAL_THROTTLE_KEY);\r\n+      break;\r\n+    }\r\n+    case ThrottleConstants.OPERATION_BASED_THROTTLE: {\r\n+      AxisOperation axisOperation = messageContext.getAxisOperation();\r\n+      if (axisOperation != null) {\r\n+        QName opName = axisOperation.getName();\r\n+        if (opName != null) {\r\n+          AxisService service = (AxisService) axisOperation.getParent();\r\n+          if (service != null) {\r\n+            String currentServiceName = service.getName();\r\n+            if (currentServiceName != null) {\r\n+              throttle =\r\n+                (Throttle) throttles.get(currentServiceName +\r\n+                  opName.getLocalPart());\r\n             }\r\n-            return null;\r\n+          }\r\n         }\r\n-        switch (throttleType) {\r\n-            case ThrottleConstants.GLOBAL_THROTTLE: {\r\n-                throttle =\r\n-                        (Throttle) throttles.get(ThrottleConstants.GLOBAL_THROTTLE_KEY);\r\n-                break;\r\n-            }\r\n-            case ThrottleConstants.OPERATION_BASED_THROTTLE: {\r\n-                AxisOperation axisOperation = messageContext.getAxisOperation();\r\n-                if (axisOperation != null) {\r\n-                    QName opName = axisOperation.getName();\r\n-                    if (opName != null) {\r\n-                        AxisService service = (AxisService) axisOperation.getParent();\r\n-                        if (service != null) {\r\n-                            String currentServiceName = service.getName();\r\n-                            if (currentServiceName != null) {\r\n-                                throttle =\r\n-                                        (Throttle) throttles.get(currentServiceName +\r\n-                                                opName.getLocalPart());\r\n-                            }\r\n-                        }\r\n-                    }\r\n-                } else {\r\n-                    if (debugOn) {\r\n-                        log.debug(\"Couldn't find axis operation \");\r\n-                    }\r\n-                    return null;\r\n-                }\r\n-                break;\r\n-            }\r\n-            case ThrottleConstants.SERVICE_BASED_THROTTLE: {\r\n-                AxisService axisService = messageContext.getAxisService();\r\n-                if (axisService != null) {\r\n-                    throttle =\r\n-                            (Throttle) throttles.get(axisService.getName());\r\n-                } else {\r\n-                    if (debugOn) {\r\n-                        log.debug(\"Couldn't find axis service \");\r\n-                    }\r\n-                    return null;\r\n-                }\r\n-                break;\r\n-            }\r\n-            default: {\r\n-                throw new ThrottleException(\"Unsupported Throttle type\");\r\n-            }\r\n+      } else {\r\n+        if (debugOn) {\r\n+          log.debug(\"Couldn't find axis operation \");\r\n         }\r\n-        return throttle;\r\n+        return null;\r\n+      }\r\n+      break;\r\n     }\r\n-\r\n-    /**\r\n-     * processing through the throttle\r\n-     * 1) concurrent throttling\r\n-     * 2) access rate based throttling - domain or ip\r\n-     *\r\n-     * @param throttle       The Throttle object - holds all configuration and state data\r\n-     *                       of the throttle\r\n-     * @param messageContext The MessageContext , that holds all data per message basis\r\n-     * @throws AxisFault         Throws when access must deny for caller\r\n-     * @throws ThrottleException    ThrottleException\r\n-     */\r\n-    public void process(Throttle throttle,\r\n-                        MessageContext messageContext) throws ThrottleException, AxisFault {\r\n-\r\n-        String throttleId = throttle.getId();\r\n-        ConfigurationContext cc = messageContext.getConfigurationContext();\r\n-\r\n-        //check the env - whether clustered  or not\r\n-        boolean isClusteringEnable = false;\r\n-        ClusteringAgent clusteringAgent = null;\r\n-        if (cc!=null) {\r\n-            clusteringAgent = cc.getAxisConfiguration().getClusteringAgent();\r\n-        }\r\n-        if (clusteringAgent != null &&\r\n-                clusteringAgent.getStateManager() != null) {\r\n-            isClusteringEnable = true;\r\n+    case ThrottleConstants.SERVICE_BASED_THROTTLE: {\r\n+      AxisService axisService = messageContext.getAxisService();\r\n+      if (axisService != null) {\r\n+        throttle =\r\n+          (Throttle) throttles.get(axisService.getName());\r\n+      } else {\r\n+        if (debugOn) {\r\n+          log.debug(\"Couldn't find axis service \");\r\n         }\r\n+        return null;\r\n+      }\r\n+      break;\r\n+    }\r\n+    default: {\r\n+      throw new ThrottleException(\"Unsupported Throttle type\");\r\n+    }\r\n+    }\r\n+    return throttle;\r\n+  }\r\n+\r\n+  /**\r\n+   * processing through the throttle\r\n+   * 1) concurrent throttling\r\n+   * 2) access rate based throttling - domain or ip\r\n+   *\r\n+   * @param throttle       The Throttle object - holds all configuration and state data\r\n+   *                       of the throttle\r\n+   * @param messageContext The MessageContext , that holds all data per message basis\r\n+   * @throws AxisFault         Throws when access must deny for caller\r\n+   * @throws ThrottleException ThrottleException\r\n+   */\r\n+  public void process(Throttle throttle,\r\n+                      MessageContext messageContext) throws ThrottleException, AxisFault {\r\n+\r\n+    String throttleId = throttle.getId();\r\n+    ConfigurationContext cc = messageContext.getConfigurationContext();\r\n+\r\n+    //check the env - whether clustered  or not\r\n+    boolean isClusteringEnable = false;\r\n+    ClusteringAgent clusteringAgent = null;\r\n+    if (cc != null) {\r\n+      clusteringAgent = cc.getAxisConfiguration().getClusteringAgent();\r\n+    }\r\n+    if (clusteringAgent != null &&\r\n+      clusteringAgent.getStateManager() != null) {\r\n+      isClusteringEnable = true;\r\n+    }\r\n \r\n-        // Get the concurrent access controller\r\n-        ConcurrentAccessController cac;\r\n-        String key = null;\r\n-        if (isClusteringEnable) {\r\n-            // for clustered  env.,gets it from axis configuration context\r\n-            key = ThrottleConstants.THROTTLE_PROPERTY_PREFIX + throttleId\r\n-                    + ThrottleConstants.CAC_SUFFIX;\r\n-            cac = (ConcurrentAccessController) cc.getProperty(key);\r\n-        } else {\r\n-            // for non-clustered  env.,gets it from axis configuration context\r\n-            cac = throttle.getConcurrentAccessController();\r\n-        }\r\n+    // Get the concurrent access controller\r\n+    ConcurrentAccessController cac;\r\n+    String key = null;\r\n+    if (isClusteringEnable) {\r\n+      // for clustered  env.,gets it from axis configuration context\r\n+      key = ThrottleConstants.THROTTLE_PROPERTY_PREFIX + throttleId\r\n+        + ThrottleConstants.CAC_SUFFIX;\r\n+      cac = (ConcurrentAccessController) cc.getProperty(key);\r\n+    } else {\r\n+      // for non-clustered  env.,gets it from axis configuration context\r\n+      cac = throttle.getConcurrentAccessController();\r\n+    }\r\n \r\n-        // check for concurrent access\r\n-        boolean canAccess = doConcurrentThrottling(cac, messageContext);\r\n-\r\n-        if (canAccess) {\r\n-            // if the concurrent access is success then\r\n-            // do the access rate based throttling\r\n-\r\n-            if (messageContext.getFLOW() == MessageContext.IN_FLOW) {\r\n-                //gets the remote caller domain name\r\n-                String domain = null;\r\n-                HttpServletRequest request =\r\n-                        (HttpServletRequest) messageContext.getPropertyNonReplicable(\r\n-                                HTTPConstants.MC_HTTP_SERVLETREQUEST);\r\n-                if (request != null) {\r\n-                    domain = request.getRemoteHost();\r\n-                }\r\n+    // check for concurrent access\r\n+    boolean canAccess = doConcurrentThrottling(cac, messageContext);\r\n+\r\n+    if (canAccess) {\r\n+      // if the concurrent access is success then\r\n+      // do the access rate based throttling\r\n+\r\n+      if (messageContext.getFLOW() == MessageContext.IN_FLOW) {\r\n+        //gets the remote caller domain name\r\n+        String domain = null;\r\n+        HttpServletRequest request =\r\n+          (HttpServletRequest) messageContext.getPropertyNonReplicable(\r\n+            HTTPConstants.MC_HTTP_SERVLETREQUEST);\r\n+        if (request != null) {\r\n+          domain = request.getRemoteHost();\r\n+        }\r\n \r\n-                // Domain name based throttling\r\n-                //check whether a configuration has been defined for this domain name or not\r\n-                String callerId = null;\r\n-                if (domain != null) {\r\n-                    //loads the ThrottleContext\r\n-                    ThrottleContext context =\r\n-                            throttle.getThrottleContext(ThrottleConstants.DOMAIN_BASED_THROTTLE_KEY);\r\n-                    if (context != null) {\r\n-                        //Loads the ThrottleConfiguration\r\n-                        ThrottleConfiguration config = context.getThrottleConfiguration();\r\n-                        if (config != null) {\r\n-                            //check for configuration for this caller\r\n-                            callerId = config.getConfigurationKeyOfCaller(domain);\r\n-                            if (callerId != null) {\r\n-                                // If this is a clustered env.\r\n-                                if (isClusteringEnable) {\r\n-                                    context.setConfigurationContext(cc);\r\n-                                    context.setThrottleId(throttleId);\r\n-                                }\r\n-                                AccessInformation infor =\r\n-                                        accessRateController.canAccess(context, callerId,\r\n-                                                ThrottleConstants.DOMAIN_BASE);\r\n-                                StatCollector.collect(infor,domain,ThrottleConstants.DOMAIN_BASE);\r\n-\r\n-                                //check for the permission for access\r\n-                                if (!infor.isAccessAllowed()) {\r\n-\r\n-                                    //In the case of both of concurrency throttling and\r\n-                                    //rate based throttling have enabled ,\r\n-                                    //if the access rate less than maximum concurrent access ,\r\n-                                    //then it is possible to occur death situation.To avoid that reset,\r\n-                                    //if the access has denied by rate based throttling\r\n-                                    if (cac != null) {\r\n-                                        cac.incrementAndGet();\r\n-                                        // set back if this is a clustered env\r\n-                                        if (isClusteringEnable) {\r\n-                                            cc.setProperty(key, cac);\r\n-                                            //replicate the current state of ConcurrentAccessController\r\n-                                            try {\r\n-                                                if (debugOn) {\r\n-                                                    log.debug(\"Going to replicates the \" +\r\n-                                                            \"states of the ConcurrentAccessController\" +\r\n-                                                            \" with key : \" + key);\r\n-                                                }\r\n-                                                Replicator.replicate(cc, new String[]{key});\r\n-                                            } catch (ClusteringFault clusteringFault) {\r\n-                                                log.error(\"Error during replicating states \",\r\n-                                                        clusteringFault);\r\n-                                            }\r\n-                                        }\r\n-                                    }\r\n-                                    throw new AxisFault(\" Access deny for a \" +\r\n-                                            \"caller with Domain \" + domain + \" \" +\r\n-                                            \" : Reason : \" + infor.getFaultReason());\r\n-                                }\r\n-                            } else {\r\n-                                if (debugOn) {\r\n-                                    log.debug(\"Could not find the Throttle Context for domain-Based \" +\r\n-                                            \"Throttling for domain name \" + domain + \" Throttling for this \" +\r\n-                                            \"domain name may not be configured from policy\");\r\n-                                }\r\n-                            }\r\n-                        }\r\n-                    }\r\n-                } else {\r\n-                    if (debugOn) {\r\n-                        log.debug(\"Could not find the domain of the caller - IP-based throttling may occur\");\r\n-                    }\r\n+        // Domain name based throttling\r\n+        //check whether a configuration has been defined for this domain name or not\r\n+        String callerId = null;\r\n+        if (domain != null) {\r\n+          //loads the ThrottleContext\r\n+          ThrottleContext context =\r\n+            throttle.getThrottleContext(ThrottleConstants.DOMAIN_BASED_THROTTLE_KEY);\r\n+          if (context != null) {\r\n+            //Loads the ThrottleConfiguration\r\n+            ThrottleConfiguration config = context.getThrottleConfiguration();\r\n+            if (config != null) {\r\n+              //check for configuration for this caller\r\n+              callerId = config.getConfigurationKeyOfCaller(domain);\r\n+              if (callerId != null) {\r\n+                // If this is a clustered env.\r\n+                if (isClusteringEnable) {\r\n+                  context.setConfigurationContext(cc);\r\n+                  context.setThrottleId(throttleId);\r\n                 }\r\n-\r\n-                //IP based throttling - Only if there is no configuration for caller domain name\r\n-\r\n-                if (callerId == null) {\r\n-                    String ip = (String) messageContext.getProperty(MessageContext.REMOTE_ADDR);\r\n-                    if (ip != null) {\r\n-                        // loads IP based throttle context\r\n-                        ThrottleContext context =\r\n-                                throttle.getThrottleContext(ThrottleConstants.IP_BASED_THROTTLE_KEY);\r\n-                        if (context != null) {\r\n-                            //Loads the ThrottleConfiguration\r\n-                            ThrottleConfiguration config = context.getThrottleConfiguration();\r\n-                            if (config != null) {\r\n-                                // check for configuration for this ip\r\n-                                callerId = config.getConfigurationKeyOfCaller(ip);\r\n-                                if (callerId != null) {\r\n-                                    // for clustered env.\r\n-                                    if (isClusteringEnable) {\r\n-                                        context.setConfigurationContext(cc);\r\n-                                        context.setThrottleId(throttleId);\r\n-                                    }\r\n-                                    AccessInformation infor =\r\n-                                            accessRateController.canAccess(context, callerId,\r\n-                                                    ThrottleConstants.IP_BASE);\r\n-                                    // check for the permission for access\r\n-                                    StatCollector.collect(infor,ip,ThrottleConstants.IP_BASE);\r\n-                                    if (!infor.isAccessAllowed()) {\r\n-\r\n-                                        //In the case of both of concurrency throttling and\r\n-                                        //rate based throttling have enabled ,\r\n-                                        //if the access rate less than maximum concurrent access ,\r\n-                                        //then it is possible to occur death situation.To avoid that reset,\r\n-                                        //if the access has denied by rate based throttling\r\n-                                        if (cac != null) {\r\n-                                            cac.incrementAndGet();\r\n-                                            // set back if this is a clustered env\r\n-                                            if (isClusteringEnable) {\r\n-                                                cc.setProperty(key, cac);\r\n-                                                //replicate the current state of ConcurrentAccessController\r\n-                                                try {\r\n-                                                    if (debugOn) {\r\n-                                                        log.debug(\"Going to replicates the \" +\r\n-                                                                \"states of the ConcurrentAccessController\" +\r\n-                                                                \" with key : \" + key);\r\n-                                                    }\r\n-                                                    Replicator.replicate(cc, new String[]{key});\r\n-                                                } catch (ClusteringFault clusteringFault) {\r\n-                                                    log.error(\"Error during replicating states \",\r\n-                                                            clusteringFault);\r\n-                                                }\r\n-                                            }\r\n-                                        }\r\n-                                        throw new AxisFault(\" Access deny for a \" +\r\n-                                                \"caller with IP \" + ip + \" \" +\r\n-                                                \" : Reason : \" + infor.getFaultReason());\r\n-                                    }\r\n-                                }\r\n-                            }\r\n-                        } else {\r\n-                            if (debugOn) {\r\n-                                log.debug(\"Could not find the throttle Context for IP-Based throttling\");\r\n-                            }\r\n-                        }\r\n-                    } else {\r\n+                AccessInformation infor =\r\n+                  accessRateController.canAccess(context, callerId,\r\n+                    ThrottleConstants.DOMAIN_BASE);\r\n+                StatCollector.collect(infor, domain, ThrottleConstants.DOMAIN_BASE);\r\n+\r\n+                //check for the permission for access\r\n+                if (!infor.isAccessAllowed()) {\r\n+\r\n+                  //In the case of both of concurrency throttling and\r\n+                  //rate based throttling have enabled ,\r\n+                  //if the access rate less than maximum concurrent access ,\r\n+                  //then it is possible to occur death situation.To avoid that reset,\r\n+                  //if the access has denied by rate based throttling\r\n+                  if (cac != null) {\r\n+                    cac.incrementAndGet();\r\n+                    // set back if this is a clustered env\r\n+                    if (isClusteringEnable) {\r\n+                      cc.setProperty(key, cac);\r\n+                      //replicate the current state of ConcurrentAccessController\r\n+                      try {\r\n                         if (debugOn) {\r\n-                            log.debug(\"Could not find the IP address of the caller \" +\r\n-                                    \"- throttling will not occur\");\r\n+                          log.debug(\"Going to replicates the \" +\r\n+                            \"states of the ConcurrentAccessController\" +\r\n+                            \" with key : \" + key);\r\n                         }\r\n+                        Replicator.replicate(cc, new String[] {key});\r\n+                      } catch (ClusteringFault clusteringFault) {\r\n+                        log.error(\"Error during replicating states \",\r\n+                          clusteringFault);\r\n+                      }\r\n                     }\r\n+                  }\r\n+                  throw new AxisFault(\" Access deny for a \" +\r\n+                    \"caller with Domain \" + domain + \" \" +\r\n+                    \" : Reason : \" + infor.getFaultReason());\r\n                 }\r\n-            }\r\n-            // all the replication functionality of the access rate based throttling handles by itself\r\n-            // just replicate the current state of ConcurrentAccessController\r\n-            if (isClusteringEnable && cac != null) {\r\n-                try {\r\n-                    if (debugOn) {\r\n-                        log.debug(\"Going to replicates the states of the ConcurrentAccessController\" +\r\n-                                \" with key : \" + key);\r\n-                    }\r\n-                    Replicator.replicate(cc, new String[]{key});\r\n-                } catch (ClusteringFault clusteringFault) {\r\n-                    log.error(\"Error during replicating states \", clusteringFault);\r\n+              } else {\r\n+                if (debugOn) {\r\n+                  log.debug(\"Could not find the Throttle Context for domain-Based \" +\r\n+                    \"Throttling for domain name \" + domain + \" Throttling for this \" +\r\n+                    \"domain name may not be configured from policy\");\r\n                 }\r\n+              }\r\n             }\r\n-\r\n-            //finally engage rolebased access throttling if available\r\n-            doRoleBasedAccessThrottling(throttle, messageContext, isClusteringEnable);\r\n+          }\r\n         } else {\r\n-            //replicate the current state of ConcurrentAccessController\r\n-            if (isClusteringEnable) {\r\n-                try {\r\n-                    if (debugOn) {\r\n-                        log.debug(\"Going to replicates the states of the ConcurrentAccessController\" +\r\n-                                \" with key : \" + key);\r\n-                    }\r\n-                    Replicator.replicate(cc, new String[]{key});\r\n-                } catch (ClusteringFault clusteringFault) {\r\n-                    log.error(\"Error during replicating states \", clusteringFault);\r\n-                }\r\n-            }\r\n-            throw new AxisFault(\"Access has currently been denied since \" +\r\n-                    \" maximum concurrent access have exceeded\");\r\n+          if (debugOn) {\r\n+            log.debug(\"Could not find the domain of the caller - IP-based throttling may occur\");\r\n+          }\r\n         }\r\n \r\n-    }\r\n-\r\n-    /**\r\n-     * Helper method for handling concurrent throttling\r\n-     *\r\n-     * @param concurrentAccessController ConcurrentAccessController\r\n-     * @param messageContext             MessageContext - message level states\r\n-     * @return true if access is allowed through concurrent throttling ,o.w false\r\n-     */\r\n-    private boolean doConcurrentThrottling(ConcurrentAccessController concurrentAccessController, MessageContext messageContext) {\r\n-\r\n-        boolean canAccess = true;\r\n-        int available;\r\n-\r\n-        if (concurrentAccessController != null) {\r\n-            if (messageContext.getFLOW() == MessageContext.IN_FLOW) {\r\n-                available = concurrentAccessController.getAndDecrement();\r\n-                canAccess = available > 0;\r\n-                if (debugOn) {\r\n-                    log.debug(\"Concurrency Throttle : Access \" + (canAccess ? \"allowed\" : \"denied\") +\r\n-                            \" :: \" + available + \" of available of \" +\r\n-                            concurrentAccessController.getLimit() + \" connections\");\r\n-                }\r\n-                if (debugOn) {\r\n-                    if (!canAccess) {\r\n-                        log.debug(\"Concurrency Throttle : Access has currently been denied since allowed\" +\r\n-                                \" maximum concurrent access have exceeded\");\r\n+        //IP based throttling - Only if there is no configuration for caller domain name\r\n+\r\n+        if (callerId == null) {\r\n+          String ip = (String) messageContext.getProperty(MessageContext.REMOTE_ADDR);\r\n+          if (ip != null) {\r\n+            // loads IP based throttle context\r\n+            ThrottleContext context =\r\n+              throttle.getThrottleContext(ThrottleConstants.IP_BASED_THROTTLE_KEY);\r\n+            if (context != null) {\r\n+              //Loads the ThrottleConfiguration\r\n+              ThrottleConfiguration config = context.getThrottleConfiguration();\r\n+              if (config != null) {\r\n+                // check for configuration for this ip\r\n+                callerId = config.getConfigurationKeyOfCaller(ip);\r\n+                if (callerId != null) {\r\n+                  // for clustered env.\r\n+                  if (isClusteringEnable) {\r\n+                    context.setConfigurationContext(cc);\r\n+                    context.setThrottleId(throttleId);\r\n+                  }\r\n+                  AccessInformation infor =\r\n+                    accessRateController.canAccess(context, callerId,\r\n+                      ThrottleConstants.IP_BASE);\r\n+                  // check for the permission for access\r\n+                  StatCollector.collect(infor, ip, ThrottleConstants.IP_BASE);\r\n+                  if (!infor.isAccessAllowed()) {\r\n+\r\n+                    //In the case of both of concurrency throttling and\r\n+                    //rate based throttling have enabled ,\r\n+                    //if the access rate less than maximum concurrent access ,\r\n+                    //then it is possible to occur death situation.To avoid that reset,\r\n+                    //if the access has denied by rate based throttling\r\n+                    if (cac != null) {\r\n+                      cac.incrementAndGet();\r\n+                      // set back if this is a clustered env\r\n+                      if (isClusteringEnable) {\r\n+                        cc.setProperty(key, cac);\r\n+                        //replicate the current state of ConcurrentAccessController\r\n+                        try {\r\n+                          if (debugOn) {\r\n+                            log.debug(\"Going to replicates the \" +\r\n+                              \"states of the ConcurrentAccessController\" +\r\n+                              \" with key : \" + key);\r\n+                          }\r\n+                          Replicator.replicate(cc, new String[] {key});\r\n+                        } catch (ClusteringFault clusteringFault) {\r\n+                          log.error(\"Error during replicating states \",\r\n+                            clusteringFault);\r\n+                        }\r\n+                      }\r\n                     }\r\n+                    throw new AxisFault(\" Access deny for a \" +\r\n+                      \"caller with IP \" + ip + \" \" +\r\n+                      \" : Reason : \" + infor.getFaultReason());\r\n+                  }\r\n                 }\r\n-            } else if (messageContext.getFLOW() == MessageContext.OUT_FLOW) {\r\n-                available = concurrentAccessController.incrementAndGet();\r\n-                if (debugOn) {\r\n-                    log.debug(\"Concurrency Throttle : Connection returned\" +\r\n-                            \" :: \" + available + \" of available of \"\r\n-                            + concurrentAccessController.getLimit() + \" connections\");\r\n-                }\r\n+              }\r\n+            } else {\r\n+              if (debugOn) {\r\n+                log.debug(\"Could not find the throttle Context for IP-Based throttling\");\r\n+              }\r\n+            }\r\n+          } else {\r\n+            if (debugOn) {\r\n+              log.debug(\"Could not find the IP address of the caller \" +\r\n+                \"- throttling will not occur\");\r\n             }\r\n+          }\r\n         }\r\n-        return canAccess;\r\n-    }\r\n+      }\r\n+      // all the replication functionality of the access rate based throttling handles by itself\r\n+      // just replicate the current state of ConcurrentAccessController\r\n+      if (isClusteringEnable && cac != null) {\r\n+        try {\r\n+          if (debugOn) {\r\n+            log.debug(\"Going to replicates the states of the ConcurrentAccessController\" +\r\n+              \" with key : \" + key);\r\n+          }\r\n+          Replicator.replicate(cc, new String[] {key});\r\n+        } catch (ClusteringFault clusteringFault) {\r\n+          log.error(\"Error during replicating states \", clusteringFault);\r\n+        }\r\n+      }\r\n \r\n+      //finally engage rolebased access throttling if available\r\n+      doRoleBasedAccessThrottling(throttle, messageContext, isClusteringEnable);\r\n+    } else {\r\n+      //replicate the current state of ConcurrentAccessController\r\n+      if (isClusteringEnable) {\r\n+        try {\r\n+          if (debugOn) {\r\n+            log.debug(\"Going to replicates the states of the ConcurrentAccessController\" +\r\n+              \" with key : \" + key);\r\n+          }\r\n+          Replicator.replicate(cc, new String[] {key});\r\n+        } catch (ClusteringFault clusteringFault) {\r\n+          log.error(\"Error during replicating states \", clusteringFault);\r\n+        }\r\n+      }\r\n+      throw new AxisFault(\"Access has currently been denied since \" +\r\n+        \" maximum concurrent access have exceeded\");\r\n+    }\r\n \r\n-    /**\r\n-     * Helper method for handling role based Access throttling\r\n-     *\r\n-     * @param messageContext             MessageContext - message level states\r\n-     * @return true if access is allowed through concurrent throttling ,o.w false\r\n-     */\r\n-    private boolean doRoleBasedAccessThrottling(Throttle throttle, MessageContext messageContext,\r\n-                                                boolean isClusteringEnable) throws AxisFault,\r\n-                                                                                   ThrottleException {\r\n-\r\n-        boolean canAccess = true;\r\n-        if (throttle.getThrottleContext(ThrottleConstants.ROLE_BASED_THROTTLE_KEY) == null) {\r\n-            //if no role base throttle config return immediately\r\n-            return canAccess;\r\n+  }\r\n+\r\n+  /**\r\n+   * Helper method for handling concurrent throttling\r\n+   *\r\n+   * @param concurrentAccessController ConcurrentAccessController\r\n+   * @param messageContext             MessageContext - message level states\r\n+   * @return true if access is allowed through concurrent throttling ,o.w false\r\n+   */\r\n+  private boolean doConcurrentThrottling(ConcurrentAccessController concurrentAccessController,\r\n+                                         MessageContext messageContext) {\r\n+\r\n+    boolean canAccess = true;\r\n+    int available;\r\n+\r\n+    if (concurrentAccessController != null) {\r\n+      if (messageContext.getFLOW() == MessageContext.IN_FLOW) {\r\n+        available = concurrentAccessController.getAndDecrement();\r\n+        canAccess = available > 0;\r\n+        if (debugOn) {\r\n+          log.debug(\"Concurrency Throttle : Access \" + (canAccess ? \"allowed\" : \"denied\") +\r\n+            \" :: \" + available + \" of available of \" +\r\n+            concurrentAccessController.getLimit() + \" connections\");\r\n         }\r\n-        ConfigurationContext cc = messageContext.getConfigurationContext();\r\n-        String throttleId = throttle.getId();\r\n-\r\n-        String key = null;\r\n-        ConcurrentAccessController cac = null;\r\n-        if (isClusteringEnable) {\r\n-            // for clustered  env.,gets it from axis configuration context\r\n-            key = ThrottleConstants.THROTTLE_PROPERTY_PREFIX + throttleId\r\n-                    + ThrottleConstants.CAC_SUFFIX;\r\n-            cac = (ConcurrentAccessController) cc.getProperty(key);\r\n+        if (debugOn) {\r\n+          if (!canAccess) {\r\n+            log.debug(\"Concurrency Throttle : Access has currently been denied since allowed\" +\r\n+              \" maximum concurrent access have exceeded\");\r\n+          }\r\n         }\r\n+      } else if (messageContext.getFLOW() == MessageContext.OUT_FLOW) {\r\n+        available = concurrentAccessController.incrementAndGet();\r\n+        if (debugOn) {\r\n+          log.debug(\"Concurrency Throttle : Connection returned\" +\r\n+            \" :: \" + available + \" of available of \"\r\n+            + concurrentAccessController.getLimit() + \" connections\");\r\n+        }\r\n+      }\r\n+    }\r\n+    return canAccess;\r\n+  }\r\n+\r\n+\r\n+  /**\r\n+   * Helper method for handling role based Access throttling\r\n+   *\r\n+   * @param messageContext MessageContext - message level states\r\n+   * @return true if access is allowed through concurrent throttling ,o.w false\r\n+   */\r\n+  private boolean doRoleBasedAccessThrottling(Throttle throttle, MessageContext messageContext,\r\n+                                              boolean isClusteringEnable) throws AxisFault,\r\n+    ThrottleException {\r\n+\r\n+    boolean canAccess = true;\r\n+    if (throttle.getThrottleContext(ThrottleConstants.ROLE_BASED_THROTTLE_KEY) == null) {\r\n+      //if no role base throttle config return immediately\r\n+      return canAccess;\r\n+    }\r\n+    ConfigurationContext cc = messageContext.getConfigurationContext();\r\n+    String throttleId = throttle.getId();\r\n+\r\n+    String key = null;\r\n+    ConcurrentAccessController cac = null;\r\n+    if (isClusteringEnable) {\r\n+      // for clustered  env.,gets it from axis configuration context\r\n+      key = ThrottleConstants.THROTTLE_PROPERTY_PREFIX + throttleId\r\n+        + ThrottleConstants.CAC_SUFFIX;\r\n+      cac = (ConcurrentAccessController) cc.getProperty(key);\r\n+    }\r\n \r\n-        if (messageContext.getFLOW() == MessageContext.IN_FLOW) {\r\n-            //gets the remote caller role name\r\n-            String consumerKey = null;\r\n-            boolean isAuthenticated = false;\r\n-            String roleID = null;\r\n-            HttpServletRequest request =\r\n-                    (HttpServletRequest) messageContext.getPropertyNonReplicable(\r\n-                            HTTPConstants.MC_HTTP_SERVLETREQUEST);\r\n-            if (request != null) {\r\n-                String oAuthHeader = request.getHeader(\"OAuth\");\r\n+    if (messageContext.getFLOW() == MessageContext.IN_FLOW) {\r\n+      //gets the remote caller role name\r\n+      String consumerKey = null;\r\n+      boolean isAuthenticated = false;\r\n+      String roleID = null;\r\n+      HttpServletRequest request =\r\n+        (HttpServletRequest) messageContext.getPropertyNonReplicable(\r\n+          HTTPConstants.MC_HTTP_SERVLETREQUEST);\r\n+      if (request != null) {\r\n+        String oAuthHeader = request.getHeader(\"OAuth\");\r\n //                consumerKey = Utils.extractCustomerKeyFromAuthHeader(oAuthHeader);\r\n //                roleID = Utils.extractCustomerKeyFromAuthHeader(oAuthHeader);\r\n-                DummyAuthenticator authFuture = new DummyAuthenticator(oAuthHeader);\r\n-                consumerKey = authFuture.getAPIKey();\r\n-                new DummyHandler().authenticateUser(authFuture);\r\n-                roleID = (String) authFuture.getAuthorizedRoles().get(0);\r\n-                isAuthenticated = authFuture.isAuthenticated();\r\n-            }\r\n-\r\n-            if(!isAuthenticated){\r\n-                throw new AxisFault(\" Access deny for a \" +\r\n-                        \"caller with consumer Key: \" + consumerKey + \" \" +\r\n-                        \" : Reason : Authentication failure\");\r\n-\r\n-            }\r\n-            // Domain name based throttling\r\n-                //check whether a configuration has been defined for this role name or not\r\n-                String consumerRoleID = null;\r\n-                if (consumerKey != null && isAuthenticated) {\r\n-                    //loads the ThrottleContext\r\n-                    ThrottleContext context =\r\n-                            throttle.getThrottleContext(ThrottleConstants.ROLE_BASED_THROTTLE_KEY);\r\n-                    if (context != null) {\r\n-                        //Loads the ThrottleConfiguration\r\n-                        ThrottleConfiguration config = context.getThrottleConfiguration();\r\n-                        if (config != null) {\r\n-                            //check for configuration for this caller\r\n-                            consumerRoleID = config.getConfigurationKeyOfCaller(roleID);\r\n-                            if (consumerRoleID != null) {\r\n-                                // If this is a clustered env.\r\n-                                if (isClusteringEnable) {\r\n-                                    context.setConfigurationContext(cc);\r\n-                                    context.setThrottleId(throttleId);\r\n-                                }\r\n-                                AccessInformation infor =\r\n-                                        roleBasedAccessController.canAccess(context, consumerKey,\r\n-                                                                            consumerRoleID);\r\n-                                StatCollector.collect(infor, consumerKey, ThrottleConstants.ROLE_BASE);\r\n-                                //check for the permission for access\r\n-                                if (!infor.isAccessAllowed()) {\r\n-\r\n-                                    //In the case of both of concurrency throttling and\r\n-                                    //rate based throttling have enabled ,\r\n-                                    //if the access rate less than maximum concurrent access ,\r\n-                                    //then it is possible to occur death situation.To avoid that reset,\r\n-                                    //if the access has denied by rate based throttling\r\n-                                    if (cac != null) {\r\n-                                        cac.incrementAndGet();\r\n-                                        // set back if this is a clustered env\r\n-                                        if (isClusteringEnable) {\r\n-                                            cc.setProperty(key, cac);\r\n-                                            //replicate the current state of ConcurrentAccessController\r\n-                                            try {\r\n-                                                if (debugOn) {\r\n-                                                    log.debug(\"Going to replicates the \" +\r\n-                                                            \"states of the ConcurrentAccessController\" +\r\n-                                                            \" with key : \" + key);\r\n-                                                }\r\n-                                                Replicator.replicate(cc, new String[]{key});\r\n-                                            } catch (ClusteringFault clusteringFault) {\r\n-                                                log.error(\"Error during replicating states \",\r\n-                                                        clusteringFault);\r\n-                                            }\r\n-                                        }\r\n-                                    }\r\n-                                    throw new AxisFault(\" Access deny for a \" +\r\n-                                            \"caller with Domain \" + consumerKey + \" \" +\r\n-                                            \" : Reason : \" + infor.getFaultReason());\r\n-                                }\r\n-                            } else {\r\n-                                if (debugOn) {\r\n-                                    log.debug(\"Could not find the Throttle Context for role-Based \" +\r\n-                                            \"Throttling for role name \" + consumerKey + \" Throttling for this \" +\r\n-                                            \"role name may not be configured from policy\");\r\n-                                }\r\n-                            }\r\n-                        }\r\n-                    }\r\n-                } else {\r\n-                    if (debugOn) {\r\n-                        log.debug(\"Could not find the role of the caller - role based throttling NOT applied\");\r\n+        DummyAuthenticator authFuture = new DummyAuthenticator(oAuthHeader);\r\n+        consumerKey = authFuture.getAPIKey();\r\n+        new DummyHandler().authenticateUser(authFuture);\r\n+        roleID = (String) authFuture.getAuthorizedRoles().get(0);\r\n+        isAuthenticated = authFuture.isAuthenticated();\r\n+      }\r\n+\r\n+      if (!isAuthenticated) {\r\n+        throw new AxisFault(\" Access deny for a \" +\r\n+          \"caller with consumer Key: \" + consumerKey + \" \" +\r\n+          \" : Reason : Authentication failure\");\r\n+\r\n+      }\r\n+      // Domain name based throttling\r\n+      //check whether a configuration has been defined for this role name or not\r\n+      String consumerRoleID = null;\r\n+      if (consumerKey != null && isAuthenticated) {\r\n+        //loads the ThrottleContext\r\n+        ThrottleContext context =\r\n+          throttle.getThrottleContext(ThrottleConstants.ROLE_BASED_THROTTLE_KEY);\r\n+        if (context != null) {\r\n+          //Loads the ThrottleConfiguration\r\n+          ThrottleConfiguration config = context.getThrottleConfiguration();\r\n+          if (config != null) {\r\n+            //check for configuration for this caller\r\n+            consumerRoleID = config.getConfigurationKeyOfCaller(roleID);\r\n+            if (consumerRoleID != null) {\r\n+              // If this is a clustered env.\r\n+              if (isClusteringEnable) {\r\n+                context.setConfigurationContext(cc);\r\n+                context.setThrottleId(throttleId);\r\n+              }\r\n+              AccessInformation infor =\r\n+                roleBasedAccessController.canAccess(context, consumerKey,\r\n+                  consumerRoleID);\r\n+              StatCollector.collect(infor, consumerKey, ThrottleConstants.ROLE_BASE);\r\n+              //check for the permission for access\r\n+              if (!infor.isAccessAllowed()) {\r\n+\r\n+                //In the case of both of concurrency throttling and\r\n+                //rate based throttling have enabled ,\r\n+                //if the access rate less than maximum concurrent access ,\r\n+                //then it is possible to occur death situation.To avoid that reset,\r\n+                //if the access has denied by rate based throttling\r\n+                if (cac != null) {\r\n+                  cac.incrementAndGet();\r\n+                  // set back if this is a clustered env\r\n+                  if (isClusteringEnable) {\r\n+                    cc.setProperty(key, cac);\r\n+                    //replicate the current state of ConcurrentAccessController\r\n+                    try {\r\n+                      if (debugOn) {\r\n+                        log.debug(\"Going to replicates the \" +\r\n+                          \"states of the ConcurrentAccessController\" +\r\n+                          \" with key : \" + key);\r\n+                      }\r\n+                      Replicator.replicate(cc, new String[] {key});\r\n+                    } catch (ClusteringFault clusteringFault) {\r\n+                      log.error(\"Error during replicating states \",\r\n+                        clusteringFault);\r\n                     }\r\n+                  }\r\n                 }\r\n-        }\r\n-        return canAccess;\r\n-    }\r\n-\r\n-    public InvocationResponse invoke(MessageContext msgContext) throws AxisFault {\r\n-        //Load throttle\r\n-        try {\r\n-            Throttle throttle = loadThrottle(msgContext, getThrottleType());\r\n-            if (throttle != null) {\r\n-                process(throttle, msgContext);\r\n+                throw new AxisFault(\" Access deny for a \" +\r\n+                  \"caller with Domain \" + consumerKey + \" \" +\r\n+                  \" : Reason : \" + infor.getFaultReason());\r\n+              }\r\n+            } else {\r\n+              if (debugOn) {\r\n+                log.debug(\"Could not find the Throttle Context for role-Based \" +\r\n+                  \"Throttling for role name \" + consumerKey + \" Throttling for this \" +\r\n+                  \"role name may not be configured from policy\");\r\n+              }\r\n             }\r\n-        } catch (ThrottleException e) {\r\n-            log.error(e.getMessage());\r\n-            throw new AxisFault(e.getMessage());\r\n+          }\r\n         }\r\n-        return InvocationResponse.CONTINUE;\r\n+      } else {\r\n+        if (debugOn) {\r\n+          log.debug(\"Could not find the role of the caller - role based throttling NOT applied\");\r\n+        }\r\n+      }\r\n+    }\r\n+    return canAccess;\r\n+  }\r\n+\r\n+  public InvocationResponse invoke(MessageContext msgContext) throws AxisFault {\r\n+    //Load throttle\r\n+    try {\r\n+      Throttle throttle = loadThrottle(msgContext, getThrottleType());\r\n+      if (throttle != null) {\r\n+        process(throttle, msgContext);\r\n+      }\r\n+    } catch (ThrottleException e) {\r\n+      log.error(e.getMessage());\r\n+      throw new AxisFault(e.getMessage());\r\n     }\r\n+    return InvocationResponse.CONTINUE;\r\n+  }\r\n \r\n }\r\n",
            "diff_size": 694
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "378",
                    "severity": "error",
                    "message": "Line is longer than 120 characters (found 130).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/298/ThrottleHandler.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler_three_grams/298/ThrottleHandler.java\nindex 25ae6590d7e..063972204b7 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/298/ThrottleHandler.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler_three_grams/298/ThrottleHandler.java\n@@ -375,9 +375,10 @@ public abstract class ThrottleHandler extends AbstractHandler {\n      * @param messageContext             MessageContext - message level states\r\n      * @return true if access is allowed through concurrent throttling ,o.w false\r\n      */\r\n-    private boolean doConcurrentThrottling(ConcurrentAccessController concurrentAccessController, MessageContext messageContext) {\r\n+    private boolean doConcurrentThrottling(ConcurrentAccessController concurrentAccessController,\r\n+                                               MessageContext messageContext) {\r\n \r\n-        boolean canAccess = true;\r\n+boolean canAccess = true;\r\n         int available;\r\n \r\n         if (concurrentAccessController != null) {\r\n",
            "diff_size": 3
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "naturalize",
        "codebuff",
        "styler_random"
    ]
}