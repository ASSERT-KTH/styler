{
    "project_name": "wso2-attic-commons",
    "error_id": "222",
    "information": {
        "errors": [
            {
                "line": "133",
                "severity": "error",
                "message": "Line is longer than 120 characters (found 128).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": "    public static final String XKMS_DEFAULT_EXPIRY_INTERVAL = \"org.wso2.xkms2.service.crypto.default.expriy.interval\";\n\n    public static final String XKMS_DEFAULT_PRIVATE_KEY_PASSWORD = \"org.wso2.xkms2.service.crypto.default.private.key.password\";\n\n    public static final String XKMS_ENABLE_PERSISTENCE = \"org.wso2.xkms2.service.crypto.persistence.enabled\";\n",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/222/XKMSServerCrypto.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler/222/XKMSServerCrypto.java\nindex f1ffcfa7722..689c78c5881 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/222/XKMSServerCrypto.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler/222/XKMSServerCrypto.java\n@@ -130,9 +130,10 @@ public class XKMSServerCrypto {\n \n     public static final String XKMS_DEFAULT_EXPIRY_INTERVAL = \"org.wso2.xkms2.service.crypto.default.expriy.interval\";\n \n-    public static final String XKMS_DEFAULT_PRIVATE_KEY_PASSWORD = \"org.wso2.xkms2.service.crypto.default.private.key.password\";\n+    public static final String XKMS_DEFAULT_PRIVATE_KEY_PASSWORD =\n+\t\t\t\t\t\"org.wso2.xkms2.service.crypto.default.private.key.password\";\n \n-    public static final String XKMS_ENABLE_PERSISTENCE = \"org.wso2.xkms2.service.crypto.persistence.enabled\";\n+     public static final String XKMS_ENABLE_PERSISTENCE = \"org.wso2.xkms2.service.crypto.persistence.enabled\";\n \n     public static final String PROP_ID_CERT_PROVIDER = \"org.wso2.xkms2.service.crypto.cert.provider\";\n \n",
            "diff_size": 3
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/222/XKMSServerCrypto.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/intellij/222/XKMSServerCrypto.java\nindex f1ffcfa7722..176a5e71d1a 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/222/XKMSServerCrypto.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/intellij/222/XKMSServerCrypto.java\n@@ -16,6 +16,7 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n+\n package org.wso2.xkms2.service;\n \n import java.io.File;\n@@ -111,1603 +112,1605 @@ import org.wso2.xkms2.util.XKMSUtil;\n \n public class XKMSServerCrypto {\n \n-    private static final Log LOG = LogFactory.getLog((XKMSServerCrypto.class)\n-            .getName());\n+  private static final Log LOG = LogFactory.getLog((XKMSServerCrypto.class)\n+    .getName());\n \n-    public static final String XKMS_SERVER_AUTHENTICATION_CODE = \"org.wso2.xkms2.service.crypto.authen.code\";\n+  public static final String XKMS_SERVER_AUTHENTICATION_CODE = \"org.wso2.xkms2.service.crypto.authen.code\";\n \n-    public static final String XKMS_KEY_STORE_LOCATION = \"org.wso2.xkms2.service.crypto.keystore.location\";\n+  public static final String XKMS_KEY_STORE_LOCATION = \"org.wso2.xkms2.service.crypto.keystore.location\";\n \n-    public static final String XKMS_KEY_STORE_PASSWORD = \"org.wso2.xkms2.service.crypto.keystore.password\";\n+  public static final String XKMS_KEY_STORE_PASSWORD = \"org.wso2.xkms2.service.crypto.keystore.password\";\n \n-    public static final String XKMS_SERVER_CERT_ALIACE = \"org.wso2.xkms2.service.crypto.server.cert.aliase\";\n+  public static final String XKMS_SERVER_CERT_ALIACE = \"org.wso2.xkms2.service.crypto.server.cert.aliase\";\n \n-    public static final String XKMS_SERVER_KEY_PASSWORD = \"org.wso2.xkms2.service.crypto.server.key.password\";\n+  public static final String XKMS_SERVER_KEY_PASSWORD = \"org.wso2.xkms2.service.crypto.server.key.password\";\n \n-    public static final String XKMS_ISSUER_CERT_ALIACE = \"org.wso2.xkms2.service.crypto.issuer.cert.aliase\";\n+  public static final String XKMS_ISSUER_CERT_ALIACE = \"org.wso2.xkms2.service.crypto.issuer.cert.aliase\";\n \n-    public static final String XKMS_ISSUER_KEY_PASSWORD = \"org.wso2.xkms2.service.crypto.issuer.key.password\";\n+  public static final String XKMS_ISSUER_KEY_PASSWORD = \"org.wso2.xkms2.service.crypto.issuer.key.password\";\n \n-    public static final String XKMS_DEFAULT_EXPIRY_INTERVAL = \"org.wso2.xkms2.service.crypto.default.expriy.interval\";\n+  public static final String XKMS_DEFAULT_EXPIRY_INTERVAL = \"org.wso2.xkms2.service.crypto.default.expriy.interval\";\n \n-    public static final String XKMS_DEFAULT_PRIVATE_KEY_PASSWORD = \"org.wso2.xkms2.service.crypto.default.private.key.password\";\n+  public static final String XKMS_DEFAULT_PRIVATE_KEY_PASSWORD =\n+    \"org.wso2.xkms2.service.crypto.default.private.key.password\";\n \n-    public static final String XKMS_ENABLE_PERSISTENCE = \"org.wso2.xkms2.service.crypto.persistence.enabled\";\n+  public static final String XKMS_ENABLE_PERSISTENCE = \"org.wso2.xkms2.service.crypto.persistence.enabled\";\n \n-    public static final String PROP_ID_CERT_PROVIDER = \"org.wso2.xkms2.service.crypto.cert.provider\";\n+  public static final String PROP_ID_CERT_PROVIDER = \"org.wso2.xkms2.service.crypto.cert.provider\";\n \n-    static String SKI_OID = \"2.5.29.14\";\n+  static String SKI_OID = \"2.5.29.14\";\n \n-    private static CertificateFactory certFact;\n+  private static CertificateFactory certFact;\n \n-    /** KeyStore which is used to store X509Certificate and private key entiries */\n-    private KeyStore keystore = null;\n+  /**\n+   * KeyStore which is used to store X509Certificate and private key entiries\n+   */\n+  private KeyStore keystore = null;\n \n-    protected KeyStore cacerts = null;\n+  protected KeyStore cacerts = null;\n \n-    /** Certificate to be used to sign issued X509Certificates */\n-    private X509Certificate cacert = null;\n+  /**\n+   * Certificate to be used to sign issued X509Certificates\n+   */\n+  private X509Certificate cacert = null;\n \n-    /** Private key to be used to sign issued X509Certificates */\n-    private PrivateKey cakey = null;\n+  /**\n+   * Private key to be used to sign issued X509Certificates\n+   */\n+  private PrivateKey cakey = null;\n \n-    /** Private key to be used to sign response messages */\n-    private PrivateKey sekey = null;\n+  /**\n+   * Private key to be used to sign response messages\n+   */\n+  private PrivateKey sekey = null;\n \n-    private Key authkey = null;\n+  private Key authkey = null;\n \n-    private Key enkey = null;\n+  private Key enkey = null;\n \n-    private Date caexpiry = null;\n+  private Date caexpiry = null;\n \n-    private int validityPeriod;\n+  private int validityPeriod;\n \n-    private Properties properties;\n+  private Properties properties;\n \n-    private ClassLoader classLoader;\n+  private ClassLoader classLoader;\n \n-    private boolean canSupportPersistence = false;\n+  private boolean canSupportPersistence = false;\n \n-    private boolean saveKeystore = false;\n+  private boolean saveKeystore = false;\n \n-    private Document doc;\n+  private Document doc;\n \n-    public XKMSServerCrypto(Properties properties) throws XKMSException {\n-        this(properties, XKMSServerCrypto.class.getClassLoader());\n+  public XKMSServerCrypto(Properties properties) throws XKMSException {\n+    this(properties, XKMSServerCrypto.class.getClassLoader());\n \n-    }\n+  }\n \n-    public XKMSServerCrypto(Properties properties, ClassLoader classLoader)\n-            throws XKMSException {\n-        this.properties = properties;\n-        this.classLoader = classLoader;\n-        Init();\n-    }\n+  public XKMSServerCrypto(Properties properties, ClassLoader classLoader)\n+    throws XKMSException {\n+    this.properties = properties;\n+    this.classLoader = classLoader;\n+    Init();\n+  }\n \n-    /*\n-     * Initializes this XKMSServerCrypto instance.\n-     */\n-    private void Init() throws XKMSException {\n-        String alias;\n-        String passcode;\n-\n-        // setting the Server Authentication Key.\n-        passcode = properties\n-                .getProperty(XKMSServerCrypto.XKMS_SERVER_AUTHENTICATION_CODE);\n-        if (passcode != null && passcode.length() > 0) {\n-            authkey = XKMSKeyUtil.getAuthenticationKey(passcode);\n-        }\n+  /*\n+   * Initializes this XKMSServerCrypto instance.\n+   */\n+  private void Init() throws XKMSException {\n+    String alias;\n+    String passcode;\n \n-        // setting the <PrivateKey> encryption key\n-        passcode = properties\n-                .getProperty(XKMSServerCrypto.XKMS_SERVER_AUTHENTICATION_CODE);\n-        if (passcode != null && passcode.length() > 0) {\n-            enkey = XKMSKeyUtil.getPrivateKey(passcode, \"DESede\");\n-        }\n+    // setting the Server Authentication Key.\n+    passcode = properties\n+      .getProperty(XKMSServerCrypto.XKMS_SERVER_AUTHENTICATION_CODE);\n+    if (passcode != null && passcode.length() > 0) {\n+      authkey = XKMSKeyUtil.getAuthenticationKey(passcode);\n+    }\n \n-        loadKeyStore();\n+    // setting the <PrivateKey> encryption key\n+    passcode = properties\n+      .getProperty(XKMSServerCrypto.XKMS_SERVER_AUTHENTICATION_CODE);\n+    if (passcode != null && passcode.length() > 0) {\n+      enkey = XKMSKeyUtil.getPrivateKey(passcode, \"DESede\");\n+    }\n \n-        // settting Issuer certificate\n-        alias = properties.getProperty(XKMS_ISSUER_CERT_ALIACE);\n-        cacert = getCertificate(alias);\n+    loadKeyStore();\n \n-        caexpiry = cacert.getNotAfter();\n+    // settting Issuer certificate\n+    alias = properties.getProperty(XKMS_ISSUER_CERT_ALIACE);\n+    cacert = getCertificate(alias);\n \n-        // setting Issuer key\n-        alias = properties.getProperty(XKMS_ISSUER_CERT_ALIACE);\n-        passcode = properties.getProperty(XKMS_ISSUER_KEY_PASSWORD);\n-        cakey = getPrivateKey(alias, passcode);\n+    caexpiry = cacert.getNotAfter();\n \n-        // setting XKMS response message signing key\n-        alias = properties.getProperty(XKMS_SERVER_CERT_ALIACE);\n-        passcode = properties.getProperty(XKMS_SERVER_KEY_PASSWORD);\n-        sekey = getPrivateKey(alias, passcode);\n+    // setting Issuer key\n+    alias = properties.getProperty(XKMS_ISSUER_CERT_ALIACE);\n+    passcode = properties.getProperty(XKMS_ISSUER_KEY_PASSWORD);\n+    cakey = getPrivateKey(alias, passcode);\n \n-        // setting the validaity period\n-        String noOfDays = properties.getProperty(XKMS_DEFAULT_EXPIRY_INTERVAL);\n-        if (noOfDays != null) {\n-            validityPeriod = Integer.parseInt(noOfDays);\n-        } else {\n-            // the default is one year\n-            validityPeriod = 365;\n-        }\n+    // setting XKMS response message signing key\n+    alias = properties.getProperty(XKMS_SERVER_CERT_ALIACE);\n+    passcode = properties.getProperty(XKMS_SERVER_KEY_PASSWORD);\n+    sekey = getPrivateKey(alias, passcode);\n \n-        // setting persistence flag\n-        String persistence = properties.getProperty(XKMS_ENABLE_PERSISTENCE);\n-        if (persistence != null) {\n-            saveKeystore = Boolean.getBoolean(persistence);\n-        } else {\n-            saveKeystore = false;\n-        }\n+    // setting the validaity period\n+    String noOfDays = properties.getProperty(XKMS_DEFAULT_EXPIRY_INTERVAL);\n+    if (noOfDays != null) {\n+      validityPeriod = Integer.parseInt(noOfDays);\n+    } else {\n+      // the default is one year\n+      validityPeriod = 365;\n+    }\n \n+    // setting persistence flag\n+    String persistence = properties.getProperty(XKMS_ENABLE_PERSISTENCE);\n+    if (persistence != null) {\n+      saveKeystore = Boolean.getBoolean(persistence);\n+    } else {\n+      saveKeystore = false;\n     }\n \n-    public ResultType process(XKMSRequestData data) throws AxisFault {\n+  }\n \n-        RequestAbstractType request = data.getRequest();\n-        this.doc = data.getDocument();\n+  public ResultType process(XKMSRequestData data) throws AxisFault {\n \n-        if (request instanceof RegisterRequest) {\n-            return handleRegisterRequest((RegisterRequest) request);\n+    RequestAbstractType request = data.getRequest();\n+    this.doc = data.getDocument();\n \n-        } else if (request instanceof ValidateRequest) {\n-            return handleValidateRequest((ValidateRequest) request);\n+    if (request instanceof RegisterRequest) {\n+      return handleRegisterRequest((RegisterRequest) request);\n \n-        } else if (request instanceof ReissueRequest) {\n-            return handleReissueRequest((ReissueRequest) request);\n+    } else if (request instanceof ValidateRequest) {\n+      return handleValidateRequest((ValidateRequest) request);\n \n-        } else if (request instanceof LocateRequest) {\n-            return handleLocateRequest((LocateRequest) request);\n+    } else if (request instanceof ReissueRequest) {\n+      return handleReissueRequest((ReissueRequest) request);\n \n-        } else if (request instanceof RecoverRequest) {\n-            return handleRecoverRequest((RecoverRequest) request);\n-        }\n+    } else if (request instanceof LocateRequest) {\n+      return handleLocateRequest((LocateRequest) request);\n \n-        return null;\n+    } else if (request instanceof RecoverRequest) {\n+      return handleRecoverRequest((RecoverRequest) request);\n     }\n \n-    public RegisterResult handleRegisterRequest(RegisterRequest request) {\n-\n-        try {\n-            prepare(request, request.getPrototypeKeyBinding());\n-            validate(request);\n-\n-            PrototypeKeyBinding pkb = request.getPrototypeKeyBinding();\n-            String identifer = getSubjectDN(pkb);\n+    return null;\n+  }\n \n-            if (identifer == null) {\n-                if (LOG.isDebugEnabled()) {\n-                    LOG.debug(\"No SubjectDN is specified\");\n-                }\n+  public RegisterResult handleRegisterRequest(RegisterRequest request) {\n \n-                throw new XKMSException(XKMSException.FAILURE, \"NoSubjectDN\");\n-            }\n+    try {\n+      prepare(request, request.getPrototypeKeyBinding());\n+      validate(request);\n \n-            PublicKey public1 = pkb.getKeyValue();\n-            PrivateKey private1 = null;\n+      PrototypeKeyBinding pkb = request.getPrototypeKeyBinding();\n+      String identifer = getSubjectDN(pkb);\n \n-            // if a public key is not provided we need to generate both the\n-            // public key and private key\n-            if (public1 == null) {\n-                KeyPair keypair = XKMSKeyUtil.generateRSAKeyPair();\n-                public1 = keypair.getPublic();\n-                private1 = keypair.getPrivate();\n-            }\n+      if (identifer == null) {\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"No SubjectDN is specified\");\n+        }\n \n-            // calculating the start and expiery dates.\n-            ValidityInterval validityInterval = pkb.getValidityInterval();\n-            Date[] adjustedInterval;\n-            if (validityInterval != null) {\n-                adjustedInterval = getAdjustedValidityInterval(validityInterval\n-                        .getNotBefore(), validityInterval.getOnOrAfter());\n-            } else {\n-                adjustedInterval = getAdjustedValidityInterval((Date) null,\n-                        (Date) null);\n-            }\n+        throw new XKMSException(XKMSException.FAILURE, \"NoSubjectDN\");\n+      }\n+\n+      PublicKey public1 = pkb.getKeyValue();\n+      PrivateKey private1 = null;\n+\n+      // if a public key is not provided we need to generate both the\n+      // public key and private key\n+      if (public1 == null) {\n+        KeyPair keypair = XKMSKeyUtil.generateRSAKeyPair();\n+        public1 = keypair.getPublic();\n+        private1 = keypair.getPrivate();\n+      }\n+\n+      // calculating the start and expiery dates.\n+      ValidityInterval validityInterval = pkb.getValidityInterval();\n+      Date[] adjustedInterval;\n+      if (validityInterval != null) {\n+        adjustedInterval = getAdjustedValidityInterval(validityInterval\n+          .getNotBefore(), validityInterval.getOnOrAfter());\n+      } else {\n+        adjustedInterval = getAdjustedValidityInterval((Date) null,\n+          (Date) null);\n+      }\n+\n+      long serialNum = nextSerialNumber();\n+      String aliase = createAlias(serialNum);\n+      BigInteger serialNumber = BigInteger.valueOf(serialNum);\n+\n+      X509Certificate cert;\n+\n+      List keyUsage = pkb.getKeyUsage();\n+      if (keyUsage == null\n+        || keyUsage.isEmpty()\n+        || (keyUsage.size() == 1 && keyUsage\n+        .contains(KeyUsage.EXCHANGE))) {\n+        cert = XKMSKeyUtil.getX509Certificate(identifer, serialNumber,\n+          adjustedInterval[0], adjustedInterval[1], public1,\n+          cacert, cakey);\n+\n+      } else {\n+\n+        cert = XKMSKeyUtil.getX509Certificate(identifer, serialNumber,\n+          adjustedInterval[0], adjustedInterval[1], keyUsage\n+            .contains(KeyUsage.SIGNATURE), keyUsage\n+            .contains(KeyUsage.ENCRYPTION), public1,\n+          cacert, cakey);\n+      }\n+\n+      try {\n+        keystore.setCertificateEntry(aliase, cert);\n+        if (LOG.isDebugEnabled()) {\n+          LOG\n+            .debug(\"Adding the newly constructed X509Certificate to the keystore - \\n \"\n+              + cert);\n+        }\n \n-            long serialNum = nextSerialNumber();\n-            String aliase = createAlias(serialNum);\n-            BigInteger serialNumber = BigInteger.valueOf(serialNum);\n+        if (private1 != null) {\n+          Certificate[] chain = new Certificate[] {cert};\n+          keystore.setKeyEntry(aliase, private1,\n+            getPrivateKeyPassword(), chain);\n+\n+          if (LOG.isDebugEnabled()) {\n+            LOG\n+              .debug(\"Added the newly construct Private Key to the keystore - \\n\"\n+                + private1);\n+          }\n+        }\n \n-            X509Certificate cert;\n+        if (saveKeystore) {\n+          saveKeystore();\n+        }\n \n-            List keyUsage = pkb.getKeyUsage();\n-            if (keyUsage == null\n-                    || keyUsage.isEmpty()\n-                    || (keyUsage.size() == 1 && keyUsage\n-                            .contains(KeyUsage.EXCHANGE))) {\n-                cert = XKMSKeyUtil.getX509Certificate(identifer, serialNumber,\n-                        adjustedInterval[0], adjustedInterval[1], public1,\n-                        cacert, cakey);\n+      } catch (KeyStoreException e) {\n+        LOG.error(\"Adding the certificate to keystore failed\", e);\n+        throw new XKMSException(e);\n+      }\n \n-            } else {\n+      RegisterResult result = XKMSUtil.createRegisterResult();\n+      buildResultType(request, result, aliase, keystore);\n+      return result;\n \n-                cert = XKMSKeyUtil.getX509Certificate(identifer, serialNumber,\n-                        adjustedInterval[0], adjustedInterval[1], keyUsage\n-                                .contains(KeyUsage.SIGNATURE), keyUsage\n-                                .contains(KeyUsage.ENCRYPTION), public1,\n-                        cacert, cakey);\n-            }\n+    } catch (XKMSException ex) {\n \n-            try {\n-                keystore.setCertificateEntry(aliase, cert);\n-                if (LOG.isDebugEnabled()) {\n-                    LOG\n-                            .debug(\"Adding the newly constructed X509Certificate to the keystore - \\n \"\n-                                    + cert);\n-                }\n-\n-                if (private1 != null) {\n-                    Certificate[] chain = new Certificate[] { cert };\n-                    keystore.setKeyEntry(aliase, private1,\n-                            getPrivateKeyPassword(), chain);\n-\n-                    if (LOG.isDebugEnabled()) {\n-                        LOG\n-                                .debug(\"Added the newly construct Private Key to the keystore - \\n\"\n-                                        + private1);\n-                    }\n-                }\n-\n-                if (saveKeystore) {\n-                    saveKeystore();\n-                }\n-\n-            } catch (KeyStoreException e) {\n-                LOG.error(\"Adding the certificate to keystore failed\", e);\n-                throw new XKMSException(e);\n-            }\n+      RegisterResult resultType = XKMSUtil.createRegisterResult();\n+      buildFault(request, resultType, ex);\n+      return resultType;\n+    }\n+  }\n \n-            RegisterResult result = XKMSUtil.createRegisterResult();\n-            buildResultType(request, result, aliase, keystore);\n-            return result;\n+  public ReissueResult handleReissueRequest(ReissueRequest request) {\n \n-        } catch (XKMSException ex) {\n+    try {\n+      prepare(request, request.getReissueKeyBinding());\n+      validate(request);\n \n-            RegisterResult resultType = XKMSUtil.createRegisterResult();\n-            buildFault(request, resultType, ex);\n-            return resultType;\n-        }\n-    }\n+      ReissueKeyBinding rkb = request.getReissueKeyBinding();\n+      X509Certificate cert = rkb.getCertValue();\n \n-    public ReissueResult handleReissueRequest(ReissueRequest request) {\n+      if (cert == null) {\n+        throw new XKMSException(XKMSException.FAILURE, \"CertNotPresent\");\n+      }\n \n-        try {\n-            prepare(request, request.getReissueKeyBinding());\n-            validate(request);\n+      String alias = getAliasForX509Cert(cert.getIssuerDN().getName(),\n+        cert.getSerialNumber());\n \n-            ReissueKeyBinding rkb = request.getReissueKeyBinding();\n-            X509Certificate cert = rkb.getCertValue();\n+      if (alias == null) {\n+        throw new XKMSException(XKMSException.FAILURE, \"CertNotFound\");\n+      }\n \n-            if (cert == null) {\n-                throw new XKMSException(XKMSException.FAILURE, \"CertNotPresent\");\n-            }\n+      ReissueResult result = XKMSUtil.creatReissueResult();\n+      buildResultType(request, result, alias, keystore);\n+      return result;\n \n-            String alias = getAliasForX509Cert(cert.getIssuerDN().getName(),\n-                    cert.getSerialNumber());\n+    } catch (XKMSException ex) {\n+      ReissueResult result = XKMSUtil.creatReissueResult();\n+      buildFault(request, result, ex);\n+      return result;\n+    }\n+  }\n+\n+  public RecoverResult handleRecoverRequest(RecoverRequest request) {\n+    try {\n+      prepare(request, request.getRecoverKeyBinding());\n+      // TODO Validate ..\n+      RecoverKeyBinding recoverKeyBinding = request\n+        .getRecoverKeyBinding();\n+      String[] aliases = null;\n+\n+      X509Certificate cert = recoverKeyBinding.getCertValue();\n+      if (cert != null) {\n+        String issuerDN = cert.getIssuerDN().getName();\n+        BigInteger serialNumber = cert.getSerialNumber();\n+\n+        String alias = getAliasForX509Cert(issuerDN, serialNumber);\n+        if (alias != null) {\n+          aliases = new String[] {alias};\n+        }\n \n-            if (alias == null) {\n-                throw new XKMSException(XKMSException.FAILURE, \"CertNotFound\");\n-            }\n+      } else {\n+        String subjectDN = getSubjectDN(recoverKeyBinding);\n \n-            ReissueResult result = XKMSUtil.creatReissueResult();\n-            buildResultType(request, result, alias, keystore);\n-            return result;\n+        if (subjectDN != null) {\n+          aliases = getAliasesForDN(subjectDN);\n+        }\n+      }\n \n-        } catch (XKMSException ex) {\n-            ReissueResult result = XKMSUtil.creatReissueResult();\n-            buildFault(request, result, ex);\n-            return result;\n+      if (aliases == null) {\n+        String keyName = recoverKeyBinding.getKeyName();\n+        if (keyName != null) {\n+          aliases = new String[] {keyName};\n         }\n-    }\n+      }\n \n-    public RecoverResult handleRecoverRequest(RecoverRequest request) {\n-        try {\n-            prepare(request, request.getRecoverKeyBinding());\n-            // TODO Validate ..\n-            RecoverKeyBinding recoverKeyBinding = request\n-                    .getRecoverKeyBinding();\n-            String[] aliases = null;\n-\n-            X509Certificate cert = recoverKeyBinding.getCertValue();\n-            if (cert != null) {\n-                String issuerDN = cert.getIssuerDN().getName();\n-                BigInteger serialNumber = cert.getSerialNumber();\n-\n-                String alias = getAliasForX509Cert(issuerDN, serialNumber);\n-                if (alias != null) {\n-                    aliases = new String[] { alias };\n-                }\n-\n-            } else {\n-                String subjectDN = getSubjectDN(recoverKeyBinding);\n-\n-                if (subjectDN != null) {\n-                    aliases = getAliasesForDN(subjectDN);\n-                }\n-            }\n+      if (aliases == null || aliases.length < 1) {\n+        throw new XKMSException(XKMSException.NO_MATCH, \"keyNotFound\");\n+      }\n \n-            if (aliases == null) {\n-                String keyName = recoverKeyBinding.getKeyName();\n-                if (keyName != null) {\n-                    aliases = new String[] { keyName };\n-                }\n-            }\n+      RecoverResult recoverResult = XKMSUtil.createRecoverResult();\n+      buildResultType(request, recoverResult, aliases[0], keystore);\n+      return recoverResult;\n \n-            if (aliases == null || aliases.length < 1) {\n-                throw new XKMSException(XKMSException.NO_MATCH, \"keyNotFound\");\n-            }\n+    } catch (XKMSException ex) {\n+      RecoverResult recoverResult = XKMSUtil.createRecoverResult();\n+      buildFault(request, recoverResult, ex);\n+      return recoverResult;\n+    }\n \n-            RecoverResult recoverResult = XKMSUtil.createRecoverResult();\n-            buildResultType(request, recoverResult, aliases[0], keystore);\n-            return recoverResult;\n+  }\n \n-        } catch (XKMSException ex) {\n-            RecoverResult recoverResult = XKMSUtil.createRecoverResult();\n-            buildFault(request, recoverResult, ex);\n-            return recoverResult;\n-        }\n+  /**\n+   * @param locate\n+   * @return\n+   */\n+  public LocateResult handleLocateRequest(LocateRequest locate) {\n+    try {\n+      QueryKeyBinding keybinding = locate.getQueryKeyBinding();\n \n-    }\n+      String identifer = getSubjectDN(keybinding);\n+      String[] aliases = null;\n \n-    /**\n-     * @param locate\n-     * @return\n-     */\n-    public LocateResult handleLocateRequest(LocateRequest locate) {\n-        try {\n-            QueryKeyBinding keybinding = locate.getQueryKeyBinding();\n-\n-            String identifer = getSubjectDN(keybinding);\n-            String[] aliases = null;\n-\n-            if (identifer == null) {\n-                KeyInfo keyInfo = keybinding.getKeyInfo();\n-\n-                if (keyInfo != null) {\n-                    try {\n-                        KeyName keyName = keyInfo.itemKeyName(0);\n-                        if (keyName != null) {\n-                            aliases = new String[] { keyName.getKeyName() };\n-                        }\n-                    } catch (XMLSecurityException xme) {\n-                        throw new XKMSException(xme);\n-                    }\n-                }\n-\n-                if (LOG.isDebugEnabled()) {\n-                    LOG.debug(\"No SubjectDN is specified\");\n-                }\n-            } else {\n-                aliases = getAliasesForDN(identifer);\n-            }\n+      if (identifer == null) {\n+        KeyInfo keyInfo = keybinding.getKeyInfo();\n \n-            byte[] skiValue = getSKIValue(keybinding);\n-            if (skiValue != null) {\n-                String alias = getAliasForX509Cert(skiValue);\n-                if (alias != null) {\n-                    aliases = new String[] { alias };\n-                }\n+        if (keyInfo != null) {\n+          try {\n+            KeyName keyName = keyInfo.itemKeyName(0);\n+            if (keyName != null) {\n+              aliases = new String[] {keyName.getKeyName()};\n             }\n+          } catch (XMLSecurityException xme) {\n+            throw new XKMSException(xme);\n+          }\n+        }\n \n-            if (aliases == null || aliases.length == 0) {\n-                throw new XKMSException(\"KeyNotFound\");\n-            }\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"No SubjectDN is specified\");\n+        }\n+      } else {\n+        aliases = getAliasesForDN(identifer);\n+      }\n \n-            List keyUsage = keybinding.getKeyUsage();\n-            boolean digitalSigning = keyUsage.contains(KeyUsage.SIGNATURE);\n-            boolean dataEncryption = keyUsage.contains(KeyUsage.ENCRYPTION);\n-\n-            List list = new ArrayList();\n-            for (int i = 0; i < aliases.length; i++) {\n-                String alias = aliases[i];\n-                X509Certificate cert = getCertificate(alias);\n-\n-                if (cert != null) {\n-                    boolean[] ku = cert.getKeyUsage();\n-\n-                    if (digitalSigning && !ku[0]) {\n-                        continue;\n-                    }\n-                    if (dataEncryption && !ku[3]) {\n-                        continue;\n-                    }\n-                    list.add(alias);\n-                }\n-            }\n+      byte[] skiValue = getSKIValue(keybinding);\n+      if (skiValue != null) {\n+        String alias = getAliasForX509Cert(skiValue);\n+        if (alias != null) {\n+          aliases = new String[] {alias};\n+        }\n+      }\n+\n+      if (aliases == null || aliases.length == 0) {\n+        throw new XKMSException(\"KeyNotFound\");\n+      }\n+\n+      List keyUsage = keybinding.getKeyUsage();\n+      boolean digitalSigning = keyUsage.contains(KeyUsage.SIGNATURE);\n+      boolean dataEncryption = keyUsage.contains(KeyUsage.ENCRYPTION);\n+\n+      List list = new ArrayList();\n+      for (int i = 0; i < aliases.length; i++) {\n+        String alias = aliases[i];\n+        X509Certificate cert = getCertificate(alias);\n+\n+        if (cert != null) {\n+          boolean[] ku = cert.getKeyUsage();\n+\n+          if (digitalSigning && !ku[0]) {\n+            continue;\n+          }\n+          if (dataEncryption && !ku[3]) {\n+            continue;\n+          }\n+          list.add(alias);\n+        }\n+      }\n \n-            if (list.isEmpty()) {\n-                throw new XKMSException(XKMSException.NO_MATCH, \"KeyNotFound\");\n-            }\n+      if (list.isEmpty()) {\n+        throw new XKMSException(XKMSException.NO_MATCH, \"KeyNotFound\");\n+      }\n \n-            LocateResult result = XKMSUtil.createLocateResult();\n-            buildResultType((RequestAbstractType) locate, (ResultType) result);\n+      LocateResult result = XKMSUtil.createLocateResult();\n+      buildResultType((RequestAbstractType) locate, (ResultType) result);\n \n-            for (Iterator iterator = list.iterator(); iterator.hasNext();) {\n-                String alias = (String) iterator.next();\n-                X509Certificate[] certs = getCertificates(alias);\n-                UnverifiedKeyBinding ukb = new UnverifiedKeyBinding();\n+      for (Iterator iterator = list.iterator(); iterator.hasNext(); ) {\n+        String alias = (String) iterator.next();\n+        X509Certificate[] certs = getCertificates(alias);\n+        UnverifiedKeyBinding ukb = new UnverifiedKeyBinding();\n \n-                addKeyInfo(locate.getRespondWith(), alias, certs, ukb);\n-                addKeyUsage(certs[0], ukb);\n-                result.addUnverifiedKeyBinding(ukb);\n-            }\n+        addKeyInfo(locate.getRespondWith(), alias, certs, ukb);\n+        addKeyUsage(certs[0], ukb);\n+        result.addUnverifiedKeyBinding(ukb);\n+      }\n \n-            return result;\n+      return result;\n \n-        } catch (XKMSException ex) {\n-            LocateResult result = XKMSUtil.createLocateResult();\n-            buildFault(locate, result, ex);\n-            return result;\n-        }\n+    } catch (XKMSException ex) {\n+      LocateResult result = XKMSUtil.createLocateResult();\n+      buildFault(locate, result, ex);\n+      return result;\n     }\n+  }\n \n-    public ValidateResult handleValidateRequest(ValidateRequest validateRequest) {\n-\n-        try {\n-            QueryKeyBinding queryKeyBinding = validateRequest\n-                    .getQueryKeyBinding();\n-            List respondWith = validateRequest.getRespondWith();\n-\n-            KeyInfo keyInfo = queryKeyBinding.getKeyInfo();\n-            X509Certificate cert = null;\n-\n-            if (keyInfo != null) {\n-                try {\n-                    cert = keyInfo.getX509Certificate();\n-                } catch (KeyResolverException e) {\n-                    throw new XKMSException(XKMSException.FAILURE, \"keystore\",\n-                            e);\n-                }\n-            }\n+  public ValidateResult handleValidateRequest(ValidateRequest validateRequest) {\n \n-            if (cert == null) {\n-                throw new XKMSException(XKMSException.FAILURE, \"CertNotPresent\");\n-            }\n+    try {\n+      QueryKeyBinding queryKeyBinding = validateRequest\n+        .getQueryKeyBinding();\n+      List respondWith = validateRequest.getRespondWith();\n \n-            if (verifyTrust(cert)) {\n-                ValidateResult validateResult = XKMSUtil.createValidateResult();\n-                buildResultType((RequestAbstractType) validateRequest,\n-                        (ResultType) validateResult);\n+      KeyInfo keyInfo = queryKeyBinding.getKeyInfo();\n+      X509Certificate cert = null;\n \n-                String subjectDN = cert.getIssuerDN().getName();\n-                BigInteger issuerSerial = cert.getSerialNumber();\n+      if (keyInfo != null) {\n+        try {\n+          cert = keyInfo.getX509Certificate();\n+        } catch (KeyResolverException e) {\n+          throw new XKMSException(XKMSException.FAILURE, \"keystore\",\n+            e);\n+        }\n+      }\n \n-                String alias = getAliasForX509Cert(subjectDN, issuerSerial);\n-                X509Certificate[] certs = getCertificates(alias);\n+      if (cert == null) {\n+        throw new XKMSException(XKMSException.FAILURE, \"CertNotPresent\");\n+      }\n \n-                KeyBinding keyBinding = XKMSUtil.createKeyBinding();\n-                validateResult.addKeyBinding(keyBinding);\n+      if (verifyTrust(cert)) {\n+        ValidateResult validateResult = XKMSUtil.createValidateResult();\n+        buildResultType((RequestAbstractType) validateRequest,\n+          (ResultType) validateResult);\n \n-                addKeyInfo(respondWith, alias, certs, keyBinding);\n-                addKeyUsage(certs[0], keyBinding);\n-                addStatus(true, keyBinding);\n+        String subjectDN = cert.getIssuerDN().getName();\n+        BigInteger issuerSerial = cert.getSerialNumber();\n \n-                return validateResult;\n+        String alias = getAliasForX509Cert(subjectDN, issuerSerial);\n+        X509Certificate[] certs = getCertificates(alias);\n \n-            } else {\n+        KeyBinding keyBinding = XKMSUtil.createKeyBinding();\n+        validateResult.addKeyBinding(keyBinding);\n \n-                ValidateResult result = XKMSUtil.createValidateResult();\n-                buildResultType((RequestAbstractType) validateRequest,\n-                        (ResultType) result);\n+        addKeyInfo(respondWith, alias, certs, keyBinding);\n+        addKeyUsage(certs[0], keyBinding);\n+        addStatus(true, keyBinding);\n \n-                KeyBinding keybinding = XKMSUtil.createKeyBinding();\n-                X509Certificate[] certs = new X509Certificate[] { cert };\n+        return validateResult;\n \n-                addKeyInfo(validateRequest.getRespondWith(), null, certs,\n-                        keybinding);\n-                addKeyUsage(certs[0], keybinding);\n-                addStatus(false, keybinding);\n-                result.addKeyBinding(keybinding);\n+      } else {\n \n-                return result;\n-            }\n+        ValidateResult result = XKMSUtil.createValidateResult();\n+        buildResultType((RequestAbstractType) validateRequest,\n+          (ResultType) result);\n \n-        } catch (XKMSException ex) {\n-            ValidateResult resultType = XKMSUtil.createValidateResult();\n-            buildFault(validateRequest, resultType, ex);\n-            return resultType;\n-        }\n-    }\n+        KeyBinding keybinding = XKMSUtil.createKeyBinding();\n+        X509Certificate[] certs = new X509Certificate[] {cert};\n \n-    /*\n-     * Prepares an KRSSRequest message for validation.\n-     */\n-    private void prepare(KRSSRequest request,\n-            KeyBindingAbstractType abstractType) throws XKMSException {\n+        addKeyInfo(validateRequest.getRespondWith(), null, certs,\n+          keybinding);\n+        addKeyUsage(certs[0], keybinding);\n+        addStatus(false, keybinding);\n+        result.addKeyBinding(keybinding);\n \n-        Authentication authentication = request.getAuthentication();\n-        authentication.setKeyBindingAuthenticationKey(authkey);\n+        return result;\n+      }\n \n-        KeyInfo keyInfo = abstractType.getKeyInfo();\n-        if (keyInfo != null) {\n-            try {\n-\n-                KeyName itemKeyName = keyInfo.itemKeyName(0);\n-                if (itemKeyName != null) {\n-                    abstractType.setKeyName(itemKeyName.getKeyName());\n-                }\n-\n-                PublicKey public1 = keyInfo.getPublicKey();\n-                if (public1 != null) {\n-                    abstractType.setKeyValue(public1);\n-                }\n-\n-                X509Certificate cert = keyInfo.getX509Certificate();\n-                if (cert != null) {\n-                    abstractType.setCertValue(cert);\n-                    abstractType.setKeyValue(cert.getPublicKey());\n-                }\n-\n-            } catch (KeyResolverException e) {\n-                LOG.error(\"\", e);\n-                throw new XKMSException(XKMSException.FAILURE, \"noKey\", e);\n-\n-            } catch (XMLSecurityException e) {\n-                LOG.error(\"\", e);\n-                throw new XKMSException(XKMSException.FAILURE, \"noKey\", e);\n-            }\n-        }\n+    } catch (XKMSException ex) {\n+      ValidateResult resultType = XKMSUtil.createValidateResult();\n+      buildFault(validateRequest, resultType, ex);\n+      return resultType;\n     }\n+  }\n \n-    private void validate(ReissueRequest reissueRequest) throws XKMSException {\n-        validate((KRSSRequest) reissueRequest);\n+  /*\n+   * Prepares an KRSSRequest message for validation.\n+   */\n+  private void prepare(KRSSRequest request,\n+                       KeyBindingAbstractType abstractType) throws XKMSException {\n \n-        ReissueKeyBinding rkb = reissueRequest.getReissueKeyBinding();\n-        XMLSignature pop = reissueRequest.getProofOfPocession();\n+    Authentication authentication = request.getAuthentication();\n+    authentication.setKeyBindingAuthenticationKey(authkey);\n \n-        Key key = rkb.getKeyValue();\n-        if (key == null) {\n-            X509Certificate cert = rkb.getCertValue();\n+    KeyInfo keyInfo = abstractType.getKeyInfo();\n+    if (keyInfo != null) {\n+      try {\n \n-            if (cert != null) {\n-                key = cert.getPublicKey();\n-            }\n+        KeyName itemKeyName = keyInfo.itemKeyName(0);\n+        if (itemKeyName != null) {\n+          abstractType.setKeyName(itemKeyName.getKeyName());\n         }\n \n-        if (pop != null && key != null) {\n-            try {\n-                pop.checkSignatureValue(key);\n-            } catch (XMLSignatureException se) {\n-                throw new XKMSException(\n-                        \"Proof-Of-Pocession varification failed\", se);\n-            }\n+        PublicKey public1 = keyInfo.getPublicKey();\n+        if (public1 != null) {\n+          abstractType.setKeyValue(public1);\n         }\n \n-    }\n+        X509Certificate cert = keyInfo.getX509Certificate();\n+        if (cert != null) {\n+          abstractType.setCertValue(cert);\n+          abstractType.setKeyValue(cert.getPublicKey());\n+        }\n \n-    private void validate(RegisterRequest registerRequest) throws XKMSException {\n+      } catch (KeyResolverException e) {\n+        LOG.error(\"\", e);\n+        throw new XKMSException(XKMSException.FAILURE, \"noKey\", e);\n \n-        validate((KRSSRequest) registerRequest);\n+      } catch (XMLSecurityException e) {\n+        LOG.error(\"\", e);\n+        throw new XKMSException(XKMSException.FAILURE, \"noKey\", e);\n+      }\n+    }\n+  }\n \n-        PrototypeKeyBinding pkb = registerRequest.getPrototypeKeyBinding();\n-        XMLSignature proofOfPossession = registerRequest.getProofOfPossession();\n+  private void validate(ReissueRequest reissueRequest) throws XKMSException {\n+    validate((KRSSRequest) reissueRequest);\n \n-        Key key = pkb.getKeyValue();\n+    ReissueKeyBinding rkb = reissueRequest.getReissueKeyBinding();\n+    XMLSignature pop = reissueRequest.getProofOfPocession();\n \n-        if (key != null) {\n-            try {\n-                proofOfPossession.checkSignatureValue(key);\n+    Key key = rkb.getKeyValue();\n+    if (key == null) {\n+      X509Certificate cert = rkb.getCertValue();\n \n-            } catch (XMLSignatureException e) {\n-                LOG.error(\"\", e);\n+      if (cert != null) {\n+        key = cert.getPublicKey();\n+      }\n+    }\n \n-                throw new XKMSException(\n-                        XKMSException.PROOF_OF_POSSESSION_REQUIRED,\n-                        \"popRequired\", e);\n-            }\n-        }\n+    if (pop != null && key != null) {\n+      try {\n+        pop.checkSignatureValue(key);\n+      } catch (XMLSignatureException se) {\n+        throw new XKMSException(\n+          \"Proof-Of-Pocession varification failed\", se);\n+      }\n     }\n \n-    private void validate(KRSSRequest request) throws XKMSException {\n+  }\n \n-        validate((MessageAbstractType) request);\n+  private void validate(RegisterRequest registerRequest) throws XKMSException {\n \n-        Authentication authentication = request.getAuthentication();\n-        XMLSignature keyBindingAuthentication = authentication\n-                .getKeyBindingAuthentication();\n+    validate((KRSSRequest) registerRequest);\n \n-        Key keyBindingAuthenticationKey = authentication\n-                .getKeyBindingAuthenticationKey();\n-        try {\n-            if (!keyBindingAuthentication\n-                    .checkSignatureValue(keyBindingAuthenticationKey)) {\n-                throw new XKMSException(XKMSException.NO_AUTHENTICATION,\n-                        \"invalidXMLSign\");\n-            }\n-            System.out.println(\"success\");\n-        } catch (XMLSignatureException e) {\n-            LOG.error(\"\", e);\n-            throw new XKMSException(XKMSException.NO_AUTHENTICATION,\n-                    \"invalidXMLSign\", e);\n-        }\n-    }\n+    PrototypeKeyBinding pkb = registerRequest.getPrototypeKeyBinding();\n+    XMLSignature proofOfPossession = registerRequest.getProofOfPossession();\n \n-    private void validate(MessageAbstractType abstractType)\n-            throws XKMSException {\n+    Key key = pkb.getKeyValue();\n \n-        XMLSignature signature = abstractType.getSignature();\n-        if (signature != null) {\n-            X509Certificate x509Certificate = abstractType.getSignCert();\n+    if (key != null) {\n+      try {\n+        proofOfPossession.checkSignatureValue(key);\n \n-            try {\n-                signature.checkSignatureValue(x509Certificate);\n-            } catch (XMLSignatureException e) {\n-                LOG.error(\"\", e);\n-                throw new XKMSException(XKMSException.NO_AUTHENTICATION,\n-                        \"failedXMLSign\", e);\n-            }\n-        }\n+      } catch (XMLSignatureException e) {\n+        LOG.error(\"\", e);\n+\n+        throw new XKMSException(\n+          XKMSException.PROOF_OF_POSSESSION_REQUIRED,\n+          \"popRequired\", e);\n+      }\n+    }\n+  }\n+\n+  private void validate(KRSSRequest request) throws XKMSException {\n+\n+    validate((MessageAbstractType) request);\n+\n+    Authentication authentication = request.getAuthentication();\n+    XMLSignature keyBindingAuthentication = authentication\n+      .getKeyBindingAuthentication();\n+\n+    Key keyBindingAuthenticationKey = authentication\n+      .getKeyBindingAuthenticationKey();\n+    try {\n+      if (!keyBindingAuthentication\n+        .checkSignatureValue(keyBindingAuthenticationKey)) {\n+        throw new XKMSException(XKMSException.NO_AUTHENTICATION,\n+          \"invalidXMLSign\");\n+      }\n+      System.out.println(\"success\");\n+    } catch (XMLSignatureException e) {\n+      LOG.error(\"\", e);\n+      throw new XKMSException(XKMSException.NO_AUTHENTICATION,\n+        \"invalidXMLSign\", e);\n     }\n+  }\n+\n+  private void validate(MessageAbstractType abstractType)\n+    throws XKMSException {\n+\n+    XMLSignature signature = abstractType.getSignature();\n+    if (signature != null) {\n+      X509Certificate x509Certificate = abstractType.getSignCert();\n+\n+      try {\n+        signature.checkSignatureValue(x509Certificate);\n+      } catch (XMLSignatureException e) {\n+        LOG.error(\"\", e);\n+        throw new XKMSException(XKMSException.NO_AUTHENTICATION,\n+          \"failedXMLSign\", e);\n+      }\n+    }\n+  }\n \n-    private void buildResultType(RegisterRequest request,\n-            RegisterResult result, String aliase, KeyStore ks)\n-            throws XKMSException {\n+  private void buildResultType(RegisterRequest request,\n+                               RegisterResult result, String aliase, KeyStore ks)\n+    throws XKMSException {\n \n-        buildResultType((RequestAbstractType) request, result, aliase, ks);\n-        org.wso2.xkms2.PrivateKey privateKey = getPrivateKey(aliase, ks);\n+    buildResultType((RequestAbstractType) request, result, aliase, ks);\n+    org.wso2.xkms2.PrivateKey privateKey = getPrivateKey(aliase, ks);\n \n-        if (privateKey != null) {\n-            result.setPrivateKey(privateKey);\n-        }\n+    if (privateKey != null) {\n+      result.setPrivateKey(privateKey);\n     }\n+  }\n \n-    private void buildResultType(ReissueRequest request, ReissueResult result,\n-            String aliase, KeyStore ks) throws XKMSException {\n+  private void buildResultType(ReissueRequest request, ReissueResult result,\n+                               String aliase, KeyStore ks) throws XKMSException {\n \n-        buildResultType((RequestAbstractType) request, (KRSSResult) result,\n-                aliase, ks);\n-    }\n+    buildResultType((RequestAbstractType) request, (KRSSResult) result,\n+      aliase, ks);\n+  }\n \n-    private void buildResultType(RecoverRequest request, RecoverResult result,\n-            String aliase, KeyStore ks) throws XKMSException {\n+  private void buildResultType(RecoverRequest request, RecoverResult result,\n+                               String aliase, KeyStore ks) throws XKMSException {\n \n-        buildResultType((RequestAbstractType) request, (KRSSResult) result,\n-                aliase, ks);\n-        ;\n-        org.wso2.xkms2.PrivateKey privateKey = getPrivateKey(aliase, ks);\n+    buildResultType((RequestAbstractType) request, (KRSSResult) result,\n+      aliase, ks);\n+    ;\n+    org.wso2.xkms2.PrivateKey privateKey = getPrivateKey(aliase, ks);\n \n-        if (privateKey != null) {\n-            result.setPrivateKey(privateKey);\n-        }\n+    if (privateKey != null) {\n+      result.setPrivateKey(privateKey);\n     }\n+  }\n \n-    private void buildResultType(RequestAbstractType request,\n-            KRSSResult result, String aliase, KeyStore ks) throws XKMSException {\n+  private void buildResultType(RequestAbstractType request,\n+                               KRSSResult result, String aliase, KeyStore ks) throws XKMSException {\n \n-        buildResultType((RequestAbstractType) request, (ResultType) result);\n+    buildResultType((RequestAbstractType) request, (ResultType) result);\n \n-        KeyBinding kb = XKMSUtil.createKeyBinding();\n-        result.addKeyBinding(kb);\n+    KeyBinding kb = XKMSUtil.createKeyBinding();\n+    result.addKeyBinding(kb);\n \n-        X509Certificate[] certs = getCertificates(aliase);\n+    X509Certificate[] certs = getCertificates(aliase);\n \n-        List respondWithList = request.getRespondWith();\n-        addKeyInfo(respondWithList, aliase, certs, kb);\n+    List respondWithList = request.getRespondWith();\n+    addKeyInfo(respondWithList, aliase, certs, kb);\n \n-        addValidationInterval(certs[0], kb);\n-        addKeyUsage(certs[0], kb);\n-        addStatus(true, kb);\n-    }\n+    addValidationInterval(certs[0], kb);\n+    addKeyUsage(certs[0], kb);\n+    addStatus(true, kb);\n+  }\n \n-    private void buildResultType(RequestAbstractType request, ResultType result)\n-            throws XKMSException {\n+  private void buildResultType(RequestAbstractType request, ResultType result)\n+    throws XKMSException {\n \n-        result.setServiceURI(request.getServiceURI());\n-        result.setResultMajor(ResultMajor.SUCCESS);\n-        result.setSignKey(sekey);\n-    }\n+    result.setServiceURI(request.getServiceURI());\n+    result.setResultMajor(ResultMajor.SUCCESS);\n+    result.setSignKey(sekey);\n+  }\n \n-    private org.wso2.xkms2.PrivateKey getPrivateKey(String aliase, KeyStore ks)\n-            throws XKMSException {\n+  private org.wso2.xkms2.PrivateKey getPrivateKey(String aliase, KeyStore ks)\n+    throws XKMSException {\n \n-        String passcode = properties\n-                .getProperty(XKMS_DEFAULT_PRIVATE_KEY_PASSWORD);\n+    String passcode = properties\n+      .getProperty(XKMS_DEFAULT_PRIVATE_KEY_PASSWORD);\n \n-        PrivateKey private1 = getPrivateKey(aliase, passcode);\n+    PrivateKey private1 = getPrivateKey(aliase, passcode);\n \n-        if (private1 != null) {\n-            X509Certificate cert = getCertificate(aliase);\n-            PublicKey public1 = cert.getPublicKey();\n-            KeyPair keyPair = new KeyPair(public1, private1);\n-            org.wso2.xkms2.PrivateKey privateKey = new org.wso2.xkms2.PrivateKey();\n-            privateKey.setRSAKeyPair(keyPair);\n-            privateKey.setKey(enkey);\n-            return privateKey;\n+    if (private1 != null) {\n+      X509Certificate cert = getCertificate(aliase);\n+      PublicKey public1 = cert.getPublicKey();\n+      KeyPair keyPair = new KeyPair(public1, private1);\n+      org.wso2.xkms2.PrivateKey privateKey = new org.wso2.xkms2.PrivateKey();\n+      privateKey.setRSAKeyPair(keyPair);\n+      privateKey.setKey(enkey);\n+      return privateKey;\n \n-        } else {\n-            return null;\n-        }\n+    } else {\n+      return null;\n     }\n+  }\n \n-    private String getSubjectDN(KeyBindingAbstractType abstractType) {\n-        List useKeyWiths = abstractType.getUseKeyWith();\n+  private String getSubjectDN(KeyBindingAbstractType abstractType) {\n+    List useKeyWiths = abstractType.getUseKeyWith();\n \n-        if (useKeyWiths == null || useKeyWiths.isEmpty()) {\n-            return null;\n-        }\n-\n-        for (Iterator iterator = useKeyWiths.iterator(); iterator.hasNext();) {\n-            UseKeyWith useKeyWith = (UseKeyWith) iterator.next();\n-\n-            if (UseKeyWith.PKIX.equals(useKeyWith.getApplication())) {\n-                return useKeyWith.getIdentifier();\n-            }\n-        }\n-\n-        return null;\n+    if (useKeyWiths == null || useKeyWiths.isEmpty()) {\n+      return null;\n     }\n \n-    private byte[] getSKIValue(KeyBindingAbstractType abstractType) {\n-        List useKeyWiths = abstractType.getUseKeyWith();\n+    for (Iterator iterator = useKeyWiths.iterator(); iterator.hasNext(); ) {\n+      UseKeyWith useKeyWith = (UseKeyWith) iterator.next();\n \n-        if (useKeyWiths == null || useKeyWiths.isEmpty()) {\n-            return null;\n-        }\n+      if (UseKeyWith.PKIX.equals(useKeyWith.getApplication())) {\n+        return useKeyWith.getIdentifier();\n+      }\n+    }\n \n-        for (Iterator iterator = useKeyWiths.iterator(); iterator.hasNext();) {\n-            UseKeyWith useKeyWith = (UseKeyWith) iterator.next();\n+    return null;\n+  }\n \n-            if (UseKeyWith.SKI.equals(useKeyWith.getApplication())) {\n-                return Base64.decode(useKeyWith.getIdentifier());\n-            }\n-        }\n+  private byte[] getSKIValue(KeyBindingAbstractType abstractType) {\n+    List useKeyWiths = abstractType.getUseKeyWith();\n \n-        return null;\n+    if (useKeyWiths == null || useKeyWiths.isEmpty()) {\n+      return null;\n     }\n \n-    /**\n-     * Returns PKIX keystore of this sample service.\n-     * \n-     * @return the KeyStore of this sample service.\n-     */\n-    private void loadKeyStore() {\n+    for (Iterator iterator = useKeyWiths.iterator(); iterator.hasNext(); ) {\n+      UseKeyWith useKeyWith = (UseKeyWith) iterator.next();\n \n-        InputStream is = null;\n+      if (UseKeyWith.SKI.equals(useKeyWith.getApplication())) {\n+        return Base64.decode(useKeyWith.getIdentifier());\n+      }\n+    }\n \n-        try {\n-            String keyStorelocation = properties\n-                    .getProperty(XKMSServerCrypto.XKMS_KEY_STORE_LOCATION);\n-            String password = properties\n-                    .getProperty(XKMSServerCrypto.XKMS_KEY_STORE_PASSWORD);\n+    return null;\n+  }\n \n-            File keyStoreFile = new File(keyStorelocation);\n+  /**\n+   * Returns PKIX keystore of this sample service.\n+   *\n+   * @return the KeyStore of this sample service.\n+   */\n+  private void loadKeyStore() {\n \n-            if (!keyStoreFile.exists()) {\n-                String wso2wsashome = System.getProperty(\"wso2wsas.home\");\n+    InputStream is = null;\n \n-                if (wso2wsashome != null) {\n-                    keyStoreFile = new File(wso2wsashome + File.separator\n-                            + \"conf\" + File.separator + keyStorelocation);\n-                }\n-            }\n-            /**\n-             * If we don't find it, then look on the file system.\n-             */\n-            if (keyStoreFile.exists()) {\n-                try {\n-                    is = new FileInputStream(keyStorelocation);\n-                    properties.put(XKMS_KEY_STORE_LOCATION, keyStoreFile\n-                            .getAbsolutePath());\n-                    canSupportPersistence = true;\n-\n-                } catch (FileNotFoundException e) {\n-                    throw new Exception(e);\n-                }\n-            }\n+    try {\n+      String keyStorelocation = properties\n+        .getProperty(XKMSServerCrypto.XKMS_KEY_STORE_LOCATION);\n+      String password = properties\n+        .getProperty(XKMSServerCrypto.XKMS_KEY_STORE_PASSWORD);\n \n-            if (is == null) {\n-                // Look for the keystore in classpaths\n-                DiscoverResources disc = new DiscoverResources();\n-                disc.addClassLoader(JDKHooks.getJDKHooks()\n-                        .getThreadContextClassLoader());\n-                disc.addClassLoader(classLoader);\n-\n-                ResourceIterator iterator = disc\n-                        .findResources(keyStorelocation);\n-                if (iterator.hasNext()) {\n-                    Resource resource = iterator.nextResource();\n-                    is = resource.getResourceAsStream();\n-                }\n-\n-                if (is == null) {\n-                    iterator = disc.findResources(\"META-INF/\"\n-                            + keyStorelocation);\n-                    if (iterator.hasNext()) {\n-                        Resource resource = iterator.nextResource();\n-                        is = resource.getResourceAsStream();\n-                    }\n-                }\n-            }\n-            if (is == null) {\n-                throw new Exception(\"specified keystore doesn't exist\");\n-            }\n-\n-            keystore = KeyStore.getInstance(KeyStore.getDefaultType());\n-            keystore.load(is, password.toCharArray());\n+      File keyStoreFile = new File(keyStorelocation);\n \n-        } catch (Exception e) {\n-            throw new RuntimeException(\"Can't load keystore\", e);\n+      if (!keyStoreFile.exists()) {\n+        String wso2wsashome = System.getProperty(\"wso2wsas.home\");\n \n-        } finally {\n-            // is.close();\n+        if (wso2wsashome != null) {\n+          keyStoreFile = new File(wso2wsashome + File.separator\n+            + \"conf\" + File.separator + keyStorelocation);\n         }\n-    }\n+      }\n+      /**\n+       * If we don't find it, then look on the file system.\n+       */\n+      if (keyStoreFile.exists()) {\n+        try {\n+          is = new FileInputStream(keyStorelocation);\n+          properties.put(XKMS_KEY_STORE_LOCATION, keyStoreFile\n+            .getAbsolutePath());\n+          canSupportPersistence = true;\n \n-    /**\n-     * Persist the keystore if persistance is enabled.\n-     * \n-     * @throws XKMSException\n-     */\n-    private void saveKeystore() throws XKMSException {\n-        if (canSupportPersistence) {\n-            try {\n-                String location = properties\n-                        .getProperty(XKMS_KEY_STORE_LOCATION);\n-                FileOutputStream outputStream = new FileOutputStream(location);\n-                String storePass = properties\n-                        .getProperty(XKMS_KEY_STORE_PASSWORD);\n-                keystore.store(outputStream, storePass.toCharArray());\n-\n-            } catch (FileNotFoundException ex) {\n-                throw new XKMSException(ex);\n-            } catch (KeyStoreException e) {\n-                throw new XKMSException(e);\n-            } catch (NoSuchAlgorithmException e) {\n-                throw new XKMSException(e);\n-            } catch (CertificateException e) {\n-                throw new XKMSException(e);\n-            } catch (IOException e) {\n-                throw new XKMSException(e);\n-            }\n+        } catch (FileNotFoundException e) {\n+          throw new Exception(e);\n+        }\n+      }\n+\n+      if (is == null) {\n+        // Look for the keystore in classpaths\n+        DiscoverResources disc = new DiscoverResources();\n+        disc.addClassLoader(JDKHooks.getJDKHooks()\n+          .getThreadContextClassLoader());\n+        disc.addClassLoader(classLoader);\n+\n+        ResourceIterator iterator = disc\n+          .findResources(keyStorelocation);\n+        if (iterator.hasNext()) {\n+          Resource resource = iterator.nextResource();\n+          is = resource.getResourceAsStream();\n         }\n-    }\n-\n-    /**\n-     * @see org.apache.ws.security.components.crypto.Crypto#getPrivateKey(java.lang.String,\n-     *      java.lang.String)\n-     */\n-    public PrivateKey getPrivateKey(String alias, String password)\n-            throws IllegalArgumentException {\n \n-        if (alias == null) {\n-            throw new IllegalArgumentException(\"alias is null\");\n+        if (is == null) {\n+          iterator = disc.findResources(\"META-INF/\"\n+            + keyStorelocation);\n+          if (iterator.hasNext()) {\n+            Resource resource = iterator.nextResource();\n+            is = resource.getResourceAsStream();\n+          }\n         }\n-        try {\n+      }\n+      if (is == null) {\n+        throw new Exception(\"specified keystore doesn't exist\");\n+      }\n \n-            boolean b = keystore.isKeyEntry(alias);\n-            if (!b) {\n-                if (LOG.isDebugEnabled()) {\n-                    LOG.error(\"Cannot find key for alias: \" + alias);\n-                }\n-                return null;\n-            }\n+      keystore = KeyStore.getInstance(KeyStore.getDefaultType());\n+      keystore.load(is, password.toCharArray());\n \n-            Key keyTmp = keystore.getKey(alias, password.toCharArray());\n+    } catch (Exception e) {\n+      throw new RuntimeException(\"Can't load keystore\", e);\n \n-            if (!(keyTmp instanceof PrivateKey)) {\n-                throw new IllegalArgumentException(\n-                        \"Key is not a private key, alias: \" + alias);\n-            }\n+    } finally {\n+      // is.close();\n+    }\n+  }\n+\n+  /**\n+   * Persist the keystore if persistance is enabled.\n+   *\n+   * @throws XKMSException\n+   */\n+  private void saveKeystore() throws XKMSException {\n+    if (canSupportPersistence) {\n+      try {\n+        String location = properties\n+          .getProperty(XKMS_KEY_STORE_LOCATION);\n+        FileOutputStream outputStream = new FileOutputStream(location);\n+        String storePass = properties\n+          .getProperty(XKMS_KEY_STORE_PASSWORD);\n+        keystore.store(outputStream, storePass.toCharArray());\n+\n+      } catch (FileNotFoundException ex) {\n+        throw new XKMSException(ex);\n+      } catch (KeyStoreException e) {\n+        throw new XKMSException(e);\n+      } catch (NoSuchAlgorithmException e) {\n+        throw new XKMSException(e);\n+      } catch (CertificateException e) {\n+        throw new XKMSException(e);\n+      } catch (IOException e) {\n+        throw new XKMSException(e);\n+      }\n+    }\n+  }\n \n-            return (PrivateKey) keyTmp;\n+  /**\n+   * @see org.apache.ws.security.components.crypto.Crypto#getPrivateKey(java.lang.String,\n+   * java.lang.String)\n+   */\n+  public PrivateKey getPrivateKey(String alias, String password)\n+    throws IllegalArgumentException {\n \n-        } catch (Exception e) {\n-            throw new RuntimeException(e);\n-        }\n+    if (alias == null) {\n+      throw new IllegalArgumentException(\"alias is null\");\n     }\n+    try {\n \n-    private void addKeyInfo(List respondWiths, String aliase,\n-            X509Certificate[] certs, KeyBindingAbstractType abstractType) {\n+      boolean b = keystore.isKeyEntry(alias);\n+      if (!b) {\n+        if (LOG.isDebugEnabled()) {\n+          LOG.error(\"Cannot find key for alias: \" + alias);\n+        }\n+        return null;\n+      }\n \n-        KeyInfo keyInfo = new KeyInfo(doc);\n+      Key keyTmp = keystore.getKey(alias, password.toCharArray());\n \n-        for (Iterator iterator = respondWiths.iterator(); iterator.hasNext();) {\n-            RespondWith respondWith = (RespondWith) iterator.next();\n+      if (!(keyTmp instanceof PrivateKey)) {\n+        throw new IllegalArgumentException(\n+          \"Key is not a private key, alias: \" + alias);\n+      }\n \n-            if (respondWith.equals(RespondWith.KEY_NAME)) {\n-                KeyName keyName = new KeyName(doc, aliase);\n-                keyInfo.add(keyName);\n+      return (PrivateKey) keyTmp;\n \n-            } else if (respondWith.equals(RespondWith.KEY_VALUE)) {\n-                PublicKey publicKey = certs[0].getPublicKey();\n-                KeyValue keyValue = new KeyValue(doc, publicKey);\n-                keyInfo.add(keyValue);\n+    } catch (Exception e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n \n-            } else if (respondWith.equals(RespondWith.X_509_CERT)) {\n-                addX509Certificate(certs[0], keyInfo);\n+  private void addKeyInfo(List respondWiths, String aliase,\n+                          X509Certificate[] certs, KeyBindingAbstractType abstractType) {\n \n-            } else if (respondWith.equals(RespondWith.X_509_CHAIN)) {\n-                for (int i = 0; i < certs.length; i++) {\n-                    addX509Certificate(certs[i], keyInfo);\n-                }\n+    KeyInfo keyInfo = new KeyInfo(doc);\n \n-            } else {\n-                // TODO Implement the other RespondWith elements.\n-            }\n-        }\n-        abstractType.setKeyInfo(keyInfo);\n-    }\n+    for (Iterator iterator = respondWiths.iterator(); iterator.hasNext(); ) {\n+      RespondWith respondWith = (RespondWith) iterator.next();\n \n-    private void addX509Certificate(X509Certificate cert, KeyInfo keyInfo) {\n+      if (respondWith.equals(RespondWith.KEY_NAME)) {\n+        KeyName keyName = new KeyName(doc, aliase);\n+        keyInfo.add(keyName);\n \n-        X509Data data = new X509Data(doc);\n-        try {\n-            data.addCertificate(cert);\n-        } catch (XMLSecurityException se) {\n-            throw new RuntimeException(\n-                    \"Adding the X509Certificate to X509Data object failed\", se);\n-        }\n-        keyInfo.add(data);\n-    }\n+      } else if (respondWith.equals(RespondWith.KEY_VALUE)) {\n+        PublicKey publicKey = certs[0].getPublicKey();\n+        KeyValue keyValue = new KeyValue(doc, publicKey);\n+        keyInfo.add(keyValue);\n \n-    private void addKeyUsage(X509Certificate cert, KeyBindingAbstractType kb) {\n+      } else if (respondWith.equals(RespondWith.X_509_CERT)) {\n+        addX509Certificate(certs[0], keyInfo);\n \n-        // CHECKME\n-        // /////////////////////////////////////////////////////////////////////\n-        // setting the KeyUsage values\n-        boolean[] keyUsage = cert.getKeyUsage();\n-        if (keyUsage != null) {\n-            // digitalSignature\n-            if (keyUsage[0]) {\n-                kb.addKeyUsage(KeyUsage.SIGNATURE);\n-            }\n-            // dataEncipherment\n-            if (keyUsage[3]) {\n-                kb.addKeyUsage(KeyUsage.ENCRYPTION);\n-            }\n+      } else if (respondWith.equals(RespondWith.X_509_CHAIN)) {\n+        for (int i = 0; i < certs.length; i++) {\n+          addX509Certificate(certs[i], keyInfo);\n         }\n-        // ////////////////////////////////////////////////////////////////////\n-    }\n \n-    private void addValidationInterval(X509Certificate cert, KeyBinding kb) {\n-        Date start = cert.getNotBefore();\n-        Date expiry = cert.getNotAfter();\n+      } else {\n+        // TODO Implement the other RespondWith elements.\n+      }\n+    }\n+    abstractType.setKeyInfo(keyInfo);\n+  }\n \n-        Calendar notBefore = Calendar.getInstance();\n-        notBefore.setTime(start);\n-        Calendar notAfter = Calendar.getInstance();\n-        notAfter.setTime(expiry);\n+  private void addX509Certificate(X509Certificate cert, KeyInfo keyInfo) {\n \n-        kb.setValidityInterval(notBefore, notAfter);\n+    X509Data data = new X509Data(doc);\n+    try {\n+      data.addCertificate(cert);\n+    } catch (XMLSecurityException se) {\n+      throw new RuntimeException(\n+        \"Adding the X509Certificate to X509Data object failed\", se);\n+    }\n+    keyInfo.add(data);\n+  }\n+\n+  private void addKeyUsage(X509Certificate cert, KeyBindingAbstractType kb) {\n+\n+    // CHECKME\n+    // /////////////////////////////////////////////////////////////////////\n+    // setting the KeyUsage values\n+    boolean[] keyUsage = cert.getKeyUsage();\n+    if (keyUsage != null) {\n+      // digitalSignature\n+      if (keyUsage[0]) {\n+        kb.addKeyUsage(KeyUsage.SIGNATURE);\n+      }\n+      // dataEncipherment\n+      if (keyUsage[3]) {\n+        kb.addKeyUsage(KeyUsage.ENCRYPTION);\n+      }\n+    }\n+    // ////////////////////////////////////////////////////////////////////\n+  }\n+\n+  private void addValidationInterval(X509Certificate cert, KeyBinding kb) {\n+    Date start = cert.getNotBefore();\n+    Date expiry = cert.getNotAfter();\n+\n+    Calendar notBefore = Calendar.getInstance();\n+    notBefore.setTime(start);\n+    Calendar notAfter = Calendar.getInstance();\n+    notAfter.setTime(expiry);\n+\n+    kb.setValidityInterval(notBefore, notAfter);\n+  }\n+\n+  private void addStatus(boolean valid, KeyBinding kb) {\n+    Status status = new Status();\n+    status\n+      .setStatusValue((valid) ? StatusValue.VALID\n+        : StatusValue.INVALID);\n+    if (valid) {\n+      status.addValidReason(ValidReason.ISSUER_TRUST);\n+      status.addValidReason(ValidReason.REVOCATION_STATUS);\n+      status.addValidReason(ValidReason.SIGNATURE);\n+      status.addValidReason(ValidReason.VALIDITY_INTERVAL);\n+    } else {\n+      status.addInvalidReason(InvalidReason.ISSUER_TRUST);\n+      status.addInvalidReason(InvalidReason.REVOCATION_STATUS);\n+      status.addInvalidReason(InvalidReason.SIGNATURE);\n+      status.addInvalidReason(InvalidReason.VALIDITY_INTERVAL);\n+    }\n+    kb.setStatus(status);\n+  }\n+\n+  /*\n+   * Calcuates the start and expiry dates. The arguments are only advisory.\n+   */\n+  private Date[] getAdjustedValidityInterval(Calendar notBefore,\n+                                             Calendar notAfter) {\n+    Date start = (notBefore == null) ? null : notBefore.getTime();\n+    Date expiry = (notAfter == null) ? null : notAfter.getTime();\n+    return getAdjustedValidityInterval(start, expiry);\n+  }\n+\n+  /*\n+   *\n+   */\n+  private Date[] getAdjustedValidityInterval(Date notBefore, Date notAfter) {\n+    Date start;\n+    Date expiryDate;\n+\n+    Calendar ca = Calendar.getInstance();\n+    Date today = ca.getTime();\n+\n+    if (notBefore != null) {\n+      if (notBefore.before(today)) {\n+        start = today;\n+      } else {\n+        start = notBefore;\n+      }\n+    } else {\n+      start = today;\n     }\n \n-    private void addStatus(boolean valid, KeyBinding kb) {\n-        Status status = new Status();\n-        status\n-                .setStatusValue((valid) ? StatusValue.VALID\n-                        : StatusValue.INVALID);\n-        if (valid) {\n-            status.addValidReason(ValidReason.ISSUER_TRUST);\n-            status.addValidReason(ValidReason.REVOCATION_STATUS);\n-            status.addValidReason(ValidReason.SIGNATURE);\n-            status.addValidReason(ValidReason.VALIDITY_INTERVAL);\n-        } else {\n-            status.addInvalidReason(InvalidReason.ISSUER_TRUST);\n-            status.addInvalidReason(InvalidReason.REVOCATION_STATUS);\n-            status.addInvalidReason(InvalidReason.SIGNATURE);\n-            status.addInvalidReason(InvalidReason.VALIDITY_INTERVAL);\n-        }\n-        kb.setStatus(status);\n+    if (notAfter == null) {\n+      ca.add(Calendar.DAY_OF_YEAR, validityPeriod);\n+      notAfter = ca.getTime();\n     }\n \n-    /*\n-     * Calcuates the start and expiry dates. The arguments are only advisory.\n-     */\n-    private Date[] getAdjustedValidityInterval(Calendar notBefore,\n-            Calendar notAfter) {\n-        Date start = (notBefore == null) ? null : notBefore.getTime();\n-        Date expiry = (notAfter == null) ? null : notAfter.getTime();\n-        return getAdjustedValidityInterval(start, expiry);\n+    if (notAfter.after(caexpiry)) {\n+      expiryDate = caexpiry;\n+    } else {\n+      expiryDate = notAfter;\n     }\n \n-    /*\n-     * \n-     */\n-    private Date[] getAdjustedValidityInterval(Date notBefore, Date notAfter) {\n-        Date start;\n-        Date expiryDate;\n-\n-        Calendar ca = Calendar.getInstance();\n-        Date today = ca.getTime();\n-\n-        if (notBefore != null) {\n-            if (notBefore.before(today)) {\n-                start = today;\n-            } else {\n-                start = notBefore;\n-            }\n-        } else {\n-            start = today;\n-        }\n+    return new Date[] {start, expiryDate};\n+  }\n \n-        if (notAfter == null) {\n-            ca.add(Calendar.DAY_OF_YEAR, validityPeriod);\n-            notAfter = ca.getTime();\n-        }\n+  private void buildFault(RequestAbstractType requestType,\n+                          ResultType resultType, XKMSException ex) {\n \n-        if (notAfter.after(caexpiry)) {\n-            expiryDate = caexpiry;\n-        } else {\n-            expiryDate = notAfter;\n-        }\n+    resultType.setServiceURI(requestType.getServiceURI());\n \n-        return new Date[] { start, expiryDate };\n+    Throwable t = ex.getCause();\n+    if (t != null) {\n+      LOG.fatal(\"Exception is thrown when processing\", t);\n     }\n \n-    private void buildFault(RequestAbstractType requestType,\n-            ResultType resultType, XKMSException ex) {\n-\n-        resultType.setServiceURI(requestType.getServiceURI());\n-\n-        Throwable t = ex.getCause();\n-        if (t != null) {\n-            LOG.fatal(\"Exception is thrown when processing\", t);\n+    int errorCode = ex.getErrorCode();\n+    switch (errorCode) {\n+    case XKMSException.NO_AUTHENTICATION:\n+      resultType.setResultMajor(ResultMajor.SENDER);\n+      resultType.setResultMinor(ResultMinor.NO_AUTHENTICATION);\n+      break;\n+    case XKMSException.NO_MATCH:\n+      resultType.setResultMajor(ResultMajor.SUCCESS);\n+      resultType.setResultMinor(ResultMinor.NO_MATCH);\n+      break;\n+    default:\n+\n+      resultType.setResultMajor(ResultMajor.RECEIVER);\n+      resultType.setResultMinor(ResultMinor.FAILURE);\n+    }\n+  }\n+\n+  private char[] getPrivateKeyPassword() {\n+    String password = properties\n+      .getProperty(XKMS_DEFAULT_PRIVATE_KEY_PASSWORD);\n+    return password.toCharArray();\n+  }\n+\n+  /**\n+   * Creates an alias based on serial number\n+   *\n+   * @param serialNum the serial number\n+   * @return the newly created alias\n+   */\n+  private String createAlias(long serialNum) {\n+    String aliase = String.valueOf(serialNum);\n+    return aliase;\n+  }\n+\n+  /**\n+   * We choose the current time of the server in milliseconds as the serial\n+   * number of the issued certificate.\n+   *\n+   * @return serialNumber\n+   */\n+  private long nextSerialNumber() {\n+    return System.currentTimeMillis();\n+  }\n+\n+  /**\n+   * @see org.apache.ws.security.components.crypto.Crypto#getAliasForX509Cert(java.lang.String,\n+   * java.math.BigInteger)\n+   */\n+  public String getAliasForX509Cert(String issuer, BigInteger serialNumber)\n+    throws XKMSException {\n+    return getAliasForX509Cert(issuer, serialNumber, true);\n+  }\n+\n+  /**\n+   * @param issuer\n+   * @param serialNumber\n+   * @param useSerialNumber\n+   * @return\n+   * @throws WSSecurityException\n+   */\n+  private String getAliasForX509Cert(String issuer, BigInteger serialNumber,\n+                                     boolean useSerialNumber) throws XKMSException {\n+    Vector issuerRDN = splitAndTrim(issuer);\n+    X509Certificate x509cert = null;\n+    Vector certRDN = null;\n+    Certificate cert = null;\n+\n+    try {\n+      for (Enumeration e = keystore.aliases(); e.hasMoreElements(); ) {\n+        String alias = (String) e.nextElement();\n+        Certificate[] certs = keystore.getCertificateChain(alias);\n+        if (certs == null || certs.length == 0) {\n+          // no cert chain, so lets check if getCertificate gives us a\n+          // result.\n+          cert = keystore.getCertificate(alias);\n+          if (cert == null) {\n+            return null;\n+          }\n+        } else {\n+          cert = certs[0];\n         }\n-\n-        int errorCode = ex.getErrorCode();\n-        switch (errorCode) {\n-        case XKMSException.NO_AUTHENTICATION:\n-            resultType.setResultMajor(ResultMajor.SENDER);\n-            resultType.setResultMinor(ResultMinor.NO_AUTHENTICATION);\n-            break;\n-        case XKMSException.NO_MATCH:\n-            resultType.setResultMajor(ResultMajor.SUCCESS);\n-            resultType.setResultMinor(ResultMinor.NO_MATCH);\n-            break;\n-        default:\n-\n-            resultType.setResultMajor(ResultMajor.RECEIVER);\n-            resultType.setResultMinor(ResultMinor.FAILURE);\n+        if (!(cert instanceof X509Certificate)) {\n+          continue;\n         }\n+        x509cert = (X509Certificate) cert;\n+        if (!useSerialNumber\n+          || useSerialNumber\n+          && x509cert.getSerialNumber().compareTo(serialNumber) == 0) {\n+          certRDN = splitAndTrim(x509cert.getIssuerDN().getName());\n+          if (certRDN.equals(issuerRDN)) {\n+            return alias;\n+          }\n+        }\n+      }\n+    } catch (KeyStoreException e) {\n+      throw new XKMSException(\"keystore\");\n     }\n+    return null;\n+  }\n \n-    private char[] getPrivateKeyPassword() {\n-        String password = properties\n-                .getProperty(XKMS_DEFAULT_PRIVATE_KEY_PASSWORD);\n-        return password.toCharArray();\n-    }\n+  private Vector splitAndTrim(String inString) {\n+    X509NameTokenizer nmTokens = new X509NameTokenizer(inString);\n+    Vector vr = new Vector();\n \n-    /**\n-     * Creates an alias based on serial number\n-     * \n-     * @param serialNum\n-     *            the serial number\n-     * @return the newly created alias\n-     */\n-    private String createAlias(long serialNum) {\n-        String aliase = String.valueOf(serialNum);\n-        return aliase;\n+    while (nmTokens.hasMoreTokens()) {\n+      vr.add(nmTokens.nextToken());\n     }\n-\n-    /**\n-     * We choose the current time of the server in milliseconds as the serial\n-     * number of the issued certificate.\n-     * \n-     * @return serialNumber\n-     */\n-    private long nextSerialNumber() {\n-        return System.currentTimeMillis();\n+    java.util.Collections.sort(vr);\n+    return vr;\n+  }\n+\n+  /**\n+   * Lookup X509 Certificates in the keystore according to a given DN of the\n+   * subject of the certificate <p/> The search gets all alias names of the\n+   * keystore and gets the certificate (chain) for each alias. Then the DN of\n+   * the certificate is compared with the parameters.\n+   *\n+   * @param subjectDN The DN of subject to look for in the keystore\n+   * @return Vector with all alias of certificates with the same DN as given\n+   * in the parameters\n+   * @throws org.apache.ws.security.WSSecurityException\n+   */\n+  public String[] getAliasesForDN(String subjectDN) throws XKMSException {\n+\n+    // The DN to search the keystore for\n+    Vector subjectRDN = splitAndTrim(subjectDN);\n+    Vector aliases = getAlias(subjectRDN, keystore);\n+\n+    // If we can't find the issuer in the keystore then look at cacerts\n+    if (aliases.size() == 0 && cacerts != null) {\n+      aliases = getAlias(subjectRDN, cacerts);\n     }\n \n-    /**\n-     * @see org.apache.ws.security.components.crypto.Crypto#getAliasForX509Cert(java.lang.String,\n-     *      java.math.BigInteger)\n-     */\n-    public String getAliasForX509Cert(String issuer, BigInteger serialNumber)\n-            throws XKMSException {\n-        return getAliasForX509Cert(issuer, serialNumber, true);\n+    // Convert the vector into an array\n+    String[] result = new String[aliases.size()];\n+    for (int i = 0; i < aliases.size(); i++) {\n+      result[i] = (String) aliases.elementAt(i);\n     }\n \n-    /**\n-     * \n-     * @param issuer\n-     * @param serialNumber\n-     * @param useSerialNumber\n-     * @return\n-     * @throws WSSecurityException\n-     */\n-    private String getAliasForX509Cert(String issuer, BigInteger serialNumber,\n-            boolean useSerialNumber) throws XKMSException {\n-        Vector issuerRDN = splitAndTrim(issuer);\n-        X509Certificate x509cert = null;\n-        Vector certRDN = null;\n-        Certificate cert = null;\n+    return result;\n+  }\n \n-        try {\n-            for (Enumeration e = keystore.aliases(); e.hasMoreElements();) {\n-                String alias = (String) e.nextElement();\n-                Certificate[] certs = keystore.getCertificateChain(alias);\n-                if (certs == null || certs.length == 0) {\n-                    // no cert chain, so lets check if getCertificate gives us a\n-                    // result.\n-                    cert = keystore.getCertificate(alias);\n-                    if (cert == null) {\n-                        return null;\n-                    }\n-                } else {\n-                    cert = certs[0];\n-                }\n-                if (!(cert instanceof X509Certificate)) {\n-                    continue;\n-                }\n-                x509cert = (X509Certificate) cert;\n-                if (!useSerialNumber\n-                        || useSerialNumber\n-                        && x509cert.getSerialNumber().compareTo(serialNumber) == 0) {\n-                    certRDN = splitAndTrim(x509cert.getIssuerDN().getName());\n-                    if (certRDN.equals(issuerRDN)) {\n-                        return alias;\n-                    }\n-                }\n-            }\n-        } catch (KeyStoreException e) {\n-            throw new XKMSException(\"keystore\");\n-        }\n-        return null;\n-    }\n+  private Vector getAlias(Vector subjectRDN, KeyStore store)\n+    throws XKMSException {\n+    // Store the aliases found\n+    Vector aliases = new Vector();\n \n-    private Vector splitAndTrim(String inString) {\n-        X509NameTokenizer nmTokens = new X509NameTokenizer(inString);\n-        Vector vr = new Vector();\n+    Certificate cert = null;\n \n-        while (nmTokens.hasMoreTokens()) {\n-            vr.add(nmTokens.nextToken());\n-        }\n-        java.util.Collections.sort(vr);\n-        return vr;\n-    }\n-\n-    /**\n-     * Lookup X509 Certificates in the keystore according to a given DN of the\n-     * subject of the certificate <p/> The search gets all alias names of the\n-     * keystore and gets the certificate (chain) for each alias. Then the DN of\n-     * the certificate is compared with the parameters.\n-     * \n-     * @param subjectDN\n-     *            The DN of subject to look for in the keystore\n-     * @return Vector with all alias of certificates with the same DN as given\n-     *         in the parameters\n-     * @throws org.apache.ws.security.WSSecurityException\n-     * \n-     */\n-    public String[] getAliasesForDN(String subjectDN) throws XKMSException {\n+    try {\n+      for (Enumeration e = store.aliases(); e.hasMoreElements(); ) {\n+        String alias = (String) e.nextElement();\n \n-        // The DN to search the keystore for\n-        Vector subjectRDN = splitAndTrim(subjectDN);\n-        Vector aliases = getAlias(subjectRDN, keystore);\n-\n-        // If we can't find the issuer in the keystore then look at cacerts\n-        if (aliases.size() == 0 && cacerts != null) {\n-            aliases = getAlias(subjectRDN, cacerts);\n+        Certificate[] certs = store.getCertificateChain(alias);\n+        if (certs == null || certs.length == 0) {\n+          // no cert chain, so lets check if getCertificate gives us a\n+          // result.\n+          cert = store.getCertificate(alias);\n+          if (cert == null) {\n+            return null;\n+          }\n+          certs = new Certificate[] {cert};\n+        } else {\n+          cert = certs[0];\n         }\n+        if (cert instanceof X509Certificate) {\n+          Vector foundRDN = splitAndTrim(((X509Certificate) cert)\n+            .getSubjectDN().getName());\n \n-        // Convert the vector into an array\n-        String[] result = new String[aliases.size()];\n-        for (int i = 0; i < aliases.size(); i++)\n-            result[i] = (String) aliases.elementAt(i);\n-\n-        return result;\n-    }\n-\n-    private Vector getAlias(Vector subjectRDN, KeyStore store)\n-            throws XKMSException {\n-        // Store the aliases found\n-        Vector aliases = new Vector();\n-\n-        Certificate cert = null;\n-\n-        try {\n-            for (Enumeration e = store.aliases(); e.hasMoreElements();) {\n-                String alias = (String) e.nextElement();\n-\n-                Certificate[] certs = store.getCertificateChain(alias);\n-                if (certs == null || certs.length == 0) {\n-                    // no cert chain, so lets check if getCertificate gives us a\n-                    // result.\n-                    cert = store.getCertificate(alias);\n-                    if (cert == null) {\n-                        return null;\n-                    }\n-                    certs = new Certificate[] { cert };\n-                } else {\n-                    cert = certs[0];\n-                }\n-                if (cert instanceof X509Certificate) {\n-                    Vector foundRDN = splitAndTrim(((X509Certificate) cert)\n-                            .getSubjectDN().getName());\n-\n-                    if (subjectRDN.equals(foundRDN)) {\n-                        aliases.add(alias);\n-                    }\n-                }\n-            }\n-        } catch (KeyStoreException e) {\n-            throw new XKMSException(e);\n+          if (subjectRDN.equals(foundRDN)) {\n+            aliases.add(alias);\n+          }\n         }\n-        return aliases;\n+      }\n+    } catch (KeyStoreException e) {\n+      throw new XKMSException(e);\n     }\n-\n-    /**\n-     * @see org.apache.ws.security.components.crypto.Crypto#getCertificateFactory()\n-     */\n-    public CertificateFactory getCertificateFactory() throws XKMSException {\n-        if (certFact == null) {\n-            try {\n-                String provider = properties.getProperty(PROP_ID_CERT_PROVIDER);\n-                if (provider == null || provider.length() == 0) {\n-                    certFact = CertificateFactory.getInstance(\"X.509\");\n-                } else {\n-                    certFact = CertificateFactory\n-                            .getInstance(\"X.509\", provider);\n-                }\n-            } catch (CertificateException e) {\n-                throw new XKMSException(\"unsupportedCertType\");\n-\n-            } catch (NoSuchProviderException e) {\n-                throw new XKMSException(\"noSecProvider\");\n-            }\n+    return aliases;\n+  }\n+\n+  /**\n+   * @see org.apache.ws.security.components.crypto.Crypto#getCertificateFactory()\n+   */\n+  public CertificateFactory getCertificateFactory() throws XKMSException {\n+    if (certFact == null) {\n+      try {\n+        String provider = properties.getProperty(PROP_ID_CERT_PROVIDER);\n+        if (provider == null || provider.length() == 0) {\n+          certFact = CertificateFactory.getInstance(\"X.509\");\n+        } else {\n+          certFact = CertificateFactory\n+            .getInstance(\"X.509\", provider);\n         }\n+      } catch (CertificateException e) {\n+        throw new XKMSException(\"unsupportedCertType\");\n \n-        return certFact;\n+      } catch (NoSuchProviderException e) {\n+        throw new XKMSException(\"noSecProvider\");\n+      }\n     }\n \n-    /**\n-     * Overridden because there's a bug in the base class where they don't use\n-     * the provider variant for the certificate validator.\n-     * \n-     * @param certs\n-     *            Certificate chain to validate\n-     * @return true if the certificate chain is valid, false otherwise\n-     * @throws WSSecurityException\n-     */\n-    public boolean validateCertPath(X509Certificate[] certs)\n-            throws XKMSException {\n+    return certFact;\n+  }\n+\n+  /**\n+   * Overridden because there's a bug in the base class where they don't use\n+   * the provider variant for the certificate validator.\n+   *\n+   * @param certs Certificate chain to validate\n+   * @return true if the certificate chain is valid, false otherwise\n+   * @throws WSSecurityException\n+   */\n+  public boolean validateCertPath(X509Certificate[] certs)\n+    throws XKMSException {\n+\n+    try {\n+      // Generate cert path\n+      List cert_list = Arrays.asList(certs);\n+      CertPath path = getCertificateFactory().generateCertPath(cert_list);\n+\n+      // Use the certificates in the keystore as TrustAnchors\n+      PKIXParameters param = new PKIXParameters(this.keystore);\n+\n+      // Do not check a revocation list\n+      param.setRevocationEnabled(false);\n+\n+      String provider = properties\n+        .getProperty(\"org.apache.ws.security.crypto.merlin.cert.provider\");\n+\n+      CertPathValidator validator = null;\n+\n+      if (provider == null || provider.length() == 0) {\n+        validator = CertPathValidator.getInstance(\"PKIX\");\n+      } else {\n+        validator = CertPathValidator.getInstance(\"PKIX\", provider);\n+      }\n+      validator.validate(path, param);\n+    } catch (java.security.NoSuchProviderException e) {\n+      throw new XKMSException(\"certpath\");\n+    } catch (java.security.NoSuchAlgorithmException e) {\n+      throw new XKMSException(\"certpath\");\n+    } catch (java.security.cert.CertificateException e) {\n+      throw new XKMSException(\"certpath\");\n+    } catch (java.security.InvalidAlgorithmParameterException e) {\n+      throw new XKMSException(\"certpath\");\n+    } catch (java.security.cert.CertPathValidatorException e) {\n+      throw new XKMSException(\"certpath\");\n+    } catch (java.security.KeyStoreException e) {\n+      throw new XKMSException(\"certpath\");\n+    }\n \n-        try {\n-            // Generate cert path\n-            List cert_list = Arrays.asList(certs);\n-            CertPath path = getCertificateFactory().generateCertPath(cert_list);\n+    return true;\n+  }\n+\n+  /**\n+   * Gets the list of certificates for a given alias. <p/>\n+   *\n+   * @param alias Lookup certificate chain for this alias\n+   * @return Array of X509 certificates for this alias name, or null if this\n+   * alias does not exist in the keystore\n+   */\n+  public X509Certificate getCertificate(String alias) throws XKMSException {\n+    Certificate[] certs = null;\n+    Certificate cert = null;\n+    try {\n+      if (this.keystore != null) {\n+        // There's a chance that there can only be a set of trust stores\n+        certs = keystore.getCertificateChain(alias);\n+        if (certs == null || certs.length == 0) {\n+          // no cert chain, so lets check if getCertificate gives us a\n+          // result.\n+          cert = keystore.getCertificate(alias);\n+        }\n+      }\n \n-            // Use the certificates in the keystore as TrustAnchors\n-            PKIXParameters param = new PKIXParameters(this.keystore);\n+      if (certs == null && cert == null && cacerts != null) {\n+        // Now look into the trust stores\n+        certs = cacerts.getCertificateChain(alias);\n+        if (certs == null) {\n+          cert = cacerts.getCertificate(alias);\n+        }\n+      }\n \n-            // Do not check a revocation list\n-            param.setRevocationEnabled(false);\n+      if (cert != null) {\n+        return (X509Certificate) cert;\n \n-            String provider = properties\n-                    .getProperty(\"org.apache.ws.security.crypto.merlin.cert.provider\");\n+      } else if (certs == null) {\n+        // At this pont we don't have certs or a cert\n+        return null;\n+      } else {\n+        return (X509Certificate) certs[0];\n \n-            CertPathValidator validator = null;\n+      }\n+    } catch (KeyStoreException e) {\n+      throw new XKMSException(\"keystore\");\n+    }\n+  }\n+\n+  /**\n+   * Gets the list of certificates for a given alias. <p/>\n+   *\n+   * @param alias Lookup certificate chain for this alias\n+   * @return Array of X509 certificates for this alias name, or null if this\n+   * alias does not exist in the keystore\n+   */\n+  public X509Certificate[] getCertificates(String alias) throws XKMSException {\n+    Certificate[] certs = null;\n+    Certificate cert = null;\n+    try {\n+      if (this.keystore != null) {\n+        // There's a chance that there can only be a set of trust stores\n+        certs = keystore.getCertificateChain(alias);\n+        if (certs == null || certs.length == 0) {\n+          // no cert chain, so lets check if getCertificate gives us a\n+          // result.\n+          cert = keystore.getCertificate(alias);\n+        }\n+      }\n \n-            if (provider == null || provider.length() == 0) {\n-                validator = CertPathValidator.getInstance(\"PKIX\");\n-            } else {\n-                validator = CertPathValidator.getInstance(\"PKIX\", provider);\n-            }\n-            validator.validate(path, param);\n-        } catch (java.security.NoSuchProviderException e) {\n-            throw new XKMSException(\"certpath\");\n-        } catch (java.security.NoSuchAlgorithmException e) {\n-            throw new XKMSException(\"certpath\");\n-        } catch (java.security.cert.CertificateException e) {\n-            throw new XKMSException(\"certpath\");\n-        } catch (java.security.InvalidAlgorithmParameterException e) {\n-            throw new XKMSException(\"certpath\");\n-        } catch (java.security.cert.CertPathValidatorException e) {\n-            throw new XKMSException(\"certpath\");\n-        } catch (java.security.KeyStoreException e) {\n-            throw new XKMSException(\"certpath\");\n+      if (certs == null && cert == null && cacerts != null) {\n+        // Now look into the trust stores\n+        certs = cacerts.getCertificateChain(alias);\n+        if (certs == null) {\n+          cert = cacerts.getCertificate(alias);\n         }\n+      }\n \n-        return true;\n+      if (cert != null) {\n+        certs = new Certificate[] {cert};\n+      } else if (certs == null) {\n+        // At this pont we don't have certs or a cert\n+        return null;\n+      }\n+    } catch (KeyStoreException e) {\n+      throw new XKMSException(\"keystore\");\n     }\n \n-    /**\n-     * Gets the list of certificates for a given alias. <p/>\n-     * \n-     * @param alias\n-     *            Lookup certificate chain for this alias\n-     * @return Array of X509 certificates for this alias name, or null if this\n-     *         alias does not exist in the keystore\n-     */\n-    public X509Certificate getCertificate(String alias) throws XKMSException {\n-        Certificate[] certs = null;\n-        Certificate cert = null;\n-        try {\n-            if (this.keystore != null) {\n-                // There's a chance that there can only be a set of trust stores\n-                certs = keystore.getCertificateChain(alias);\n-                if (certs == null || certs.length == 0) {\n-                    // no cert chain, so lets check if getCertificate gives us a\n-                    // result.\n-                    cert = keystore.getCertificate(alias);\n-                }\n-            }\n-\n-            if (certs == null && cert == null && cacerts != null) {\n-                // Now look into the trust stores\n-                certs = cacerts.getCertificateChain(alias);\n-                if (certs == null) {\n-                    cert = cacerts.getCertificate(alias);\n-                }\n-            }\n+    X509Certificate[] x509certs = new X509Certificate[certs.length];\n+    for (int i = 0; i < certs.length; i++) {\n+      x509certs[i] = (X509Certificate) certs[i];\n+    }\n+    return x509certs;\n+  }\n+\n+  /**\n+   * Evaluate whether a given certificate should be trusted. Hook to allow\n+   * subclasses to implement custom validation methods however they see fit.\n+   * <p/> Policy used in this implementation: 1. Search the keystore for the\n+   * transmitted certificate 2. Search the keystore for a connection to the\n+   * transmitted certificate (that is, search for certificate(s) of the issuer\n+   * of the transmitted certificate 3. Verify the trust path for those\n+   * certificates found because the search for the issuer might be fooled by a\n+   * phony DN (String!)\n+   *\n+   * @param cert the certificate that should be validated against the keystore\n+   * @return true if the certificate is trusted, false if not (AxisFault is\n+   * thrown for exceptions during CertPathValidation)\n+   * @throws WSSecurityException\n+   */\n+  protected boolean verifyTrust(X509Certificate cert) throws XKMSException {\n+\n+    // If no certificate was transmitted, do not trust the signature\n+    if (cert == null) {\n+      return false;\n+    }\n \n-            if (cert != null) {\n-                return (X509Certificate) cert;\n+    String[] aliases = null;\n+    String alias = null;\n+    X509Certificate[] certs;\n \n-            } else if (certs == null) {\n-                // At this pont we don't have certs or a cert\n-                return null;\n-            } else {\n-                return (X509Certificate) certs[0];\n+    String subjectString = cert.getSubjectDN().getName();\n+    String issuerString = cert.getIssuerDN().getName();\n+    BigInteger issuerSerial = cert.getSerialNumber();\n \n-            }\n-        } catch (KeyStoreException e) {\n-            throw new XKMSException(\"keystore\");\n-        }\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(\"WSHandler: Transmitted certificate has subject \"\n+        + subjectString);\n+      LOG.debug(\"WSHandler: Transmitted certificate has issuer \"\n+        + issuerString + \" (serial \" + issuerSerial + \")\");\n     }\n \n-    /**\n-     * Gets the list of certificates for a given alias. <p/>\n-     * \n-     * @param alias\n-     *            Lookup certificate chain for this alias\n-     * @return Array of X509 certificates for this alias name, or null if this\n-     *         alias does not exist in the keystore\n-     */\n-    public X509Certificate[] getCertificates(String alias) throws XKMSException {\n-        Certificate[] certs = null;\n-        Certificate cert = null;\n-        try {\n-            if (this.keystore != null) {\n-                // There's a chance that there can only be a set of trust stores\n-                certs = keystore.getCertificateChain(alias);\n-                if (certs == null || certs.length == 0) {\n-                    // no cert chain, so lets check if getCertificate gives us a\n-                    // result.\n-                    cert = keystore.getCertificate(alias);\n-                }\n-            }\n+    // FIRST step\n+    // Search the keystore for the transmitted certificate\n \n-            if (certs == null && cert == null && cacerts != null) {\n-                // Now look into the trust stores\n-                certs = cacerts.getCertificateChain(alias);\n-                if (certs == null) {\n-                    cert = cacerts.getCertificate(alias);\n-                }\n-            }\n+    // Search the keystore for the alias of the transmitted certificate\n \n-            if (cert != null) {\n-                certs = new Certificate[] { cert };\n-            } else if (certs == null) {\n-                // At this pont we don't have certs or a cert\n-                return null;\n-            }\n-        } catch (KeyStoreException e) {\n-            throw new XKMSException(\"keystore\");\n-        }\n+    alias = getAliasForX509Cert(issuerString, issuerSerial);\n \n-        X509Certificate[] x509certs = new X509Certificate[certs.length];\n-        for (int i = 0; i < certs.length; i++) {\n-            x509certs[i] = (X509Certificate) certs[i];\n+    if (alias != null) {\n+      // Retrieve the certificate for the alias from the keystore\n+\n+      certs = getCertificates(alias);\n+\n+      // If certificates have been found, the certificates must be\n+      // compared\n+      // to ensure againgst phony DNs (compare encoded form including\n+      // signature)\n+      if (certs != null && certs.length > 0 && cert.equals(certs[0])) {\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"Direct trust for certificate with \"\n+            + subjectString);\n         }\n-        return x509certs;\n+        return true;\n+      }\n+    } else {\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"No alias found for subject from issuer with \"\n+          + issuerString + \" (serial \" + issuerSerial + \")\");\n+      }\n     }\n \n-    /**\n-     * Evaluate whether a given certificate should be trusted. Hook to allow\n-     * subclasses to implement custom validation methods however they see fit.\n-     * <p/> Policy used in this implementation: 1. Search the keystore for the\n-     * transmitted certificate 2. Search the keystore for a connection to the\n-     * transmitted certificate (that is, search for certificate(s) of the issuer\n-     * of the transmitted certificate 3. Verify the trust path for those\n-     * certificates found because the search for the issuer might be fooled by a\n-     * phony DN (String!)\n-     * \n-     * @param cert\n-     *            the certificate that should be validated against the keystore\n-     * @return true if the certificate is trusted, false if not (AxisFault is\n-     *         thrown for exceptions during CertPathValidation)\n-     * @throws WSSecurityException\n-     */\n-    protected boolean verifyTrust(X509Certificate cert) throws XKMSException {\n+    // SECOND step\n+    // Search for the issuer of the transmitted certificate in the keystore\n \n-        // If no certificate was transmitted, do not trust the signature\n-        if (cert == null) {\n-            return false;\n-        }\n+    // Search the keystore for the alias of the transmitted certificates\n+    // issuer\n \n-        String[] aliases = null;\n-        String alias = null;\n-        X509Certificate[] certs;\n+    aliases = getAliasesForDN(issuerString);\n \n-        String subjectString = cert.getSubjectDN().getName();\n-        String issuerString = cert.getIssuerDN().getName();\n-        BigInteger issuerSerial = cert.getSerialNumber();\n+    // If the alias has not been found, the issuer is not in the keystore\n+    // As a direct result, do not trust the transmitted certificate\n+    if (aliases == null || aliases.length < 1) {\n+      if (LOG.isDebugEnabled()) {\n+        LOG\n+          .debug(\"No aliases found in keystore for issuer \"\n+            + issuerString + \" of certificate for \"\n+            + subjectString);\n+      }\n+      return false;\n+    }\n \n+    // THIRD step\n+    // Check the certificate trust path for every alias of the issuer found\n+    // in the keystore\n+    for (int i = 0; i < aliases.length; i++) {\n+      alias = aliases[i];\n+\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Preparing to validate certificate path with alias \"\n+          + alias + \" for issuer \" + issuerString);\n+      }\n+\n+      // Retrieve the certificate(s) for the alias from the keystore\n+\n+      certs = getCertificates(alias);\n+\n+      // If no certificates have been found, there has to be an error:\n+      // The keystore can find an alias but no certificate(s)\n+      if (certs == null | certs.length < 1) {\n+        throw new XKMSException(\"noCertForAlias\");\n+      }\n+\n+      // Form a certificate chain from the transmitted certificate\n+      // and the certificate(s) of the issuer from the keystore\n+      // First, create new array\n+      X509Certificate[] x509certs = new X509Certificate[certs.length + 1];\n+      // Then add the first certificate ...\n+      x509certs[0] = cert;\n+      // ... and the other certificates\n+      for (int j = 0; j < certs.length; j++) {\n+        cert = certs[i];\n+        x509certs[certs.length + j] = cert;\n+      }\n+      certs = x509certs;\n+\n+      // Use the validation method from the crypto to check whether the\n+      // subjects certificate was really signed by the issuer stated in\n+      // the certificate\n+\n+      if (validateCertPath(certs)) {\n         if (LOG.isDebugEnabled()) {\n-            LOG.debug(\"WSHandler: Transmitted certificate has subject \"\n-                    + subjectString);\n-            LOG.debug(\"WSHandler: Transmitted certificate has issuer \"\n-                    + issuerString + \" (serial \" + issuerSerial + \")\");\n+          LOG\n+            .debug(\"WSHandler: Certificate path has been verified for certificate with subject \"\n+              + subjectString);\n         }\n+        return true;\n+      }\n+    }\n \n-        // FIRST step\n-        // Search the keystore for the transmitted certificate\n-\n-        // Search the keystore for the alias of the transmitted certificate\n-\n-        alias = getAliasForX509Cert(issuerString, issuerSerial);\n-\n-        if (alias != null) {\n-            // Retrieve the certificate for the alias from the keystore\n-\n-            certs = getCertificates(alias);\n-\n-            // If certificates have been found, the certificates must be\n-            // compared\n-            // to ensure againgst phony DNs (compare encoded form including\n-            // signature)\n-            if (certs != null && certs.length > 0 && cert.equals(certs[0])) {\n-                if (LOG.isDebugEnabled()) {\n-                    LOG.debug(\"Direct trust for certificate with \"\n-                            + subjectString);\n-                }\n-                return true;\n-            }\n+    LOG\n+      .debug(\"WSHandler: Certificate path could not be verified for certificate with subject \"\n+        + subjectString);\n+    return false;\n+  }\n+\n+  public String getAliasForX509Cert(byte[] skiBytes) throws XKMSException {\n+    Certificate cert = null;\n+    boolean found = false;\n+\n+    try {\n+      for (Enumeration e = keystore.aliases(); e.hasMoreElements(); ) {\n+        String alias = (String) e.nextElement();\n+        Certificate[] certs = keystore.getCertificateChain(alias);\n+        if (certs == null || certs.length == 0) {\n+          // no cert chain, so lets check if getCertificate gives us a\n+          // result.\n+          cert = keystore.getCertificate(alias);\n+          if (cert == null) {\n+            return null;\n+          }\n         } else {\n-            if (LOG.isDebugEnabled()) {\n-                LOG.debug(\"No alias found for subject from issuer with \"\n-                        + issuerString + \" (serial \" + issuerSerial + \")\");\n-            }\n+          cert = certs[0];\n         }\n-\n-        // SECOND step\n-        // Search for the issuer of the transmitted certificate in the keystore\n-\n-        // Search the keystore for the alias of the transmitted certificates\n-        // issuer\n-\n-        aliases = getAliasesForDN(issuerString);\n-\n-        // If the alias has not been found, the issuer is not in the keystore\n-        // As a direct result, do not trust the transmitted certificate\n-        if (aliases == null || aliases.length < 1) {\n-            if (LOG.isDebugEnabled()) {\n-                LOG\n-                        .debug(\"No aliases found in keystore for issuer \"\n-                                + issuerString + \" of certificate for \"\n-                                + subjectString);\n-            }\n-            return false;\n+        if (!(cert instanceof X509Certificate)) {\n+          continue;\n         }\n-\n-        // THIRD step\n-        // Check the certificate trust path for every alias of the issuer found\n-        // in the keystore\n-        for (int i = 0; i < aliases.length; i++) {\n-            alias = aliases[i];\n-\n-            if (LOG.isDebugEnabled()) {\n-                LOG.debug(\"Preparing to validate certificate path with alias \"\n-                        + alias + \" for issuer \" + issuerString);\n-            }\n-\n-            // Retrieve the certificate(s) for the alias from the keystore\n-\n-            certs = getCertificates(alias);\n-\n-            // If no certificates have been found, there has to be an error:\n-            // The keystore can find an alias but no certificate(s)\n-            if (certs == null | certs.length < 1) {\n-                throw new XKMSException(\"noCertForAlias\");\n-            }\n-\n-            // Form a certificate chain from the transmitted certificate\n-            // and the certificate(s) of the issuer from the keystore\n-            // First, create new array\n-            X509Certificate[] x509certs = new X509Certificate[certs.length + 1];\n-            // Then add the first certificate ...\n-            x509certs[0] = cert;\n-            // ... and the other certificates\n-            for (int j = 0; j < certs.length; j++) {\n-                cert = certs[i];\n-                x509certs[certs.length + j] = cert;\n-            }\n-            certs = x509certs;\n-\n-            // Use the validation method from the crypto to check whether the\n-            // subjects certificate was really signed by the issuer stated in\n-            // the certificate\n-\n-            if (validateCertPath(certs)) {\n-                if (LOG.isDebugEnabled()) {\n-                    LOG\n-                            .debug(\"WSHandler: Certificate path has been verified for certificate with subject \"\n-                                    + subjectString);\n-                }\n-                return true;\n-            }\n+        byte[] data = getSKIBytesFromCert((X509Certificate) cert);\n+        if (data.length != skiBytes.length) {\n+          continue;\n         }\n-\n-        LOG\n-                .debug(\"WSHandler: Certificate path could not be verified for certificate with subject \"\n-                        + subjectString);\n-        return false;\n-    }\n-\n-    public String getAliasForX509Cert(byte[] skiBytes) throws XKMSException {\n-        Certificate cert = null;\n-        boolean found = false;\n-\n-        try {\n-            for (Enumeration e = keystore.aliases(); e.hasMoreElements();) {\n-                String alias = (String) e.nextElement();\n-                Certificate[] certs = keystore.getCertificateChain(alias);\n-                if (certs == null || certs.length == 0) {\n-                    // no cert chain, so lets check if getCertificate gives us a\n-                    // result.\n-                    cert = keystore.getCertificate(alias);\n-                    if (cert == null) {\n-                        return null;\n-                    }\n-                } else {\n-                    cert = certs[0];\n-                }\n-                if (!(cert instanceof X509Certificate)) {\n-                    continue;\n-                }\n-                byte[] data = getSKIBytesFromCert((X509Certificate) cert);\n-                if (data.length != skiBytes.length) {\n-                    continue;\n-                }\n-                if (Arrays.equals(data, skiBytes)) {\n-                    return alias;\n-                }\n-            }\n-        } catch (KeyStoreException e) {\n-            throw new XKMSException(e);\n+        if (Arrays.equals(data, skiBytes)) {\n+          return alias;\n         }\n-        return null;\n+      }\n+    } catch (KeyStoreException e) {\n+      throw new XKMSException(e);\n     }\n+    return null;\n+  }\n \n-    public byte[] getSKIBytesFromCert(X509Certificate cert)\n-            throws XKMSException {\n-        /*\n-         * Gets the DER-encoded OCTET string for the extension value (extnValue)\n-         * identified by the passed-in oid String. The oid string is represented\n-         * by a set of positive whole numbers separated by periods.\n-         */\n-        byte[] derEncodedValue = cert.getExtensionValue(SKI_OID);\n-\n-        if (cert.getVersion() < 3 || derEncodedValue == null) {\n-            PublicKey key = cert.getPublicKey();\n-            if (!(key instanceof RSAPublicKey)) {\n-                throw new XKMSException(\"noSKIHandling\");\n-            }\n-            byte[] encoded = key.getEncoded();\n-            // remove 22-byte algorithm ID and header\n-            byte[] value = new byte[encoded.length - 22];\n-            System.arraycopy(encoded, 22, value, 0, value.length);\n-            MessageDigest sha;\n-            try {\n-                sha = MessageDigest.getInstance(\"SHA-1\");\n-            } catch (NoSuchAlgorithmException ex) {\n-                throw new XKMSException(\"noSKIHandling\");\n-            }\n-            sha.reset();\n-            sha.update(value);\n-            return sha.digest();\n-        }\n+  public byte[] getSKIBytesFromCert(X509Certificate cert)\n+    throws XKMSException {\n+    /*\n+     * Gets the DER-encoded OCTET string for the extension value (extnValue)\n+     * identified by the passed-in oid String. The oid string is represented\n+     * by a set of positive whole numbers separated by periods.\n+     */\n+    byte[] derEncodedValue = cert.getExtensionValue(SKI_OID);\n+\n+    if (cert.getVersion() < 3 || derEncodedValue == null) {\n+      PublicKey key = cert.getPublicKey();\n+      if (!(key instanceof RSAPublicKey)) {\n+        throw new XKMSException(\"noSKIHandling\");\n+      }\n+      byte[] encoded = key.getEncoded();\n+      // remove 22-byte algorithm ID and header\n+      byte[] value = new byte[encoded.length - 22];\n+      System.arraycopy(encoded, 22, value, 0, value.length);\n+      MessageDigest sha;\n+      try {\n+        sha = MessageDigest.getInstance(\"SHA-1\");\n+      } catch (NoSuchAlgorithmException ex) {\n+        throw new XKMSException(\"noSKIHandling\");\n+      }\n+      sha.reset();\n+      sha.update(value);\n+      return sha.digest();\n+    }\n \n-        /**\n-         * Strip away first four bytes from the DerValue (tag and length of\n-         * ExtensionValue OCTET STRING and KeyIdentifier OCTET STRING)\n-         */\n-        byte abyte0[] = new byte[derEncodedValue.length - 4];\n+    /**\n+     * Strip away first four bytes from the DerValue (tag and length of\n+     * ExtensionValue OCTET STRING and KeyIdentifier OCTET STRING)\n+     */\n+    byte abyte0[] = new byte[derEncodedValue.length - 4];\n \n-        System.arraycopy(derEncodedValue, 4, abyte0, 0, abyte0.length);\n-        return abyte0;\n-    }\n+    System.arraycopy(derEncodedValue, 4, abyte0, 0, abyte0.length);\n+    return abyte0;\n+  }\n }\n",
            "diff_size": 1990
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/222/XKMSServerCrypto.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler_random/222/XKMSServerCrypto.java\nindex f1ffcfa7722..689c78c5881 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/222/XKMSServerCrypto.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler_random/222/XKMSServerCrypto.java\n@@ -130,9 +130,10 @@ public class XKMSServerCrypto {\n \n     public static final String XKMS_DEFAULT_EXPIRY_INTERVAL = \"org.wso2.xkms2.service.crypto.default.expriy.interval\";\n \n-    public static final String XKMS_DEFAULT_PRIVATE_KEY_PASSWORD = \"org.wso2.xkms2.service.crypto.default.private.key.password\";\n+    public static final String XKMS_DEFAULT_PRIVATE_KEY_PASSWORD =\n+\t\t\t\t\t\"org.wso2.xkms2.service.crypto.default.private.key.password\";\n \n-    public static final String XKMS_ENABLE_PERSISTENCE = \"org.wso2.xkms2.service.crypto.persistence.enabled\";\n+     public static final String XKMS_ENABLE_PERSISTENCE = \"org.wso2.xkms2.service.crypto.persistence.enabled\";\n \n     public static final String PROP_ID_CERT_PROVIDER = \"org.wso2.xkms2.service.crypto.cert.provider\";\n \n",
            "diff_size": 3
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/222/XKMSServerCrypto.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler_three_grams/222/XKMSServerCrypto.java\nindex f1ffcfa7722..7570959b1c4 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/222/XKMSServerCrypto.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler_three_grams/222/XKMSServerCrypto.java\n@@ -130,9 +130,10 @@ public class XKMSServerCrypto {\n \n     public static final String XKMS_DEFAULT_EXPIRY_INTERVAL = \"org.wso2.xkms2.service.crypto.default.expriy.interval\";\n \n-    public static final String XKMS_DEFAULT_PRIVATE_KEY_PASSWORD = \"org.wso2.xkms2.service.crypto.default.private.key.password\";\n+    public static final String XKMS_DEFAULT_PRIVATE_KEY_PASSWORD =\n+            \"org.wso2.xkms2.service.crypto.default.private.key.password\";\n \n-    public static final String XKMS_ENABLE_PERSISTENCE = \"org.wso2.xkms2.service.crypto.persistence.enabled\";\n+     public static final String XKMS_ENABLE_PERSISTENCE = \"org.wso2.xkms2.service.crypto.persistence.enabled\";\n \n     public static final String PROP_ID_CERT_PROVIDER = \"org.wso2.xkms2.service.crypto.cert.provider\";\n \n",
            "diff_size": 3
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "naturalize",
        "codebuff"
    ]
}