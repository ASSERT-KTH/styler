{
    "project_name": "codefollower-H2-Research",
    "error_id": "506",
    "information": {
        "errors": [
            {
                "line": "302",
                "column": "1",
                "severity": "warning",
                "message": "File contains tab characters (this is the first instance).",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
            }
        ]
    },
    "source_code": "            if (name.startsWith(CLASSPATH_PREFIX)) {\n                String fileName = name.substring(CLASSPATH_PREFIX.length());\n\t\t// Force absolute resolution in Class.getResourceAsStream\n                if (!fileName.startsWith(\"/\")) {\n                    fileName = \"/\" + fileName;\n                }",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/506/FilePathDisk.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler/506/FilePathDisk.java\nindex 68435939954..40de30d0bcc 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/506/FilePathDisk.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler/506/FilePathDisk.java\n@@ -299,7 +299,7 @@ public class FilePathDisk extends FilePath {\n             // file name with a colon\n             if (name.startsWith(CLASSPATH_PREFIX)) {\n                 String fileName = name.substring(CLASSPATH_PREFIX.length());\n-\t\t// Force absolute resolution in Class.getResourceAsStream\n+                // Force absolute resolution in Class.getResourceAsStream\n                 if (!fileName.startsWith(\"/\")) {\n                     fileName = \"/\" + fileName;\n                 }\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/506/FilePathDisk.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/506/FilePathDisk.java\nindex 68435939954..af5b342e52f 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/506/FilePathDisk.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/506/FilePathDisk.java\n@@ -3,6 +3,7 @@\n  * and the EPL 1.0 (http://h2database.com/html/license.html).\n  * Initial Developer: H2 Group\n  */\n+\n package org.h2.store.fs;\n \n import java.io.File;\n@@ -33,369 +34,369 @@ import org.h2.util.New;\n  */\n public class FilePathDisk extends FilePath {\n \n-    private static final String CLASSPATH_PREFIX = \"classpath:\";\n-\n-    @Override\n-    public FilePathDisk getPath(String path) {\n-        FilePathDisk p = new FilePathDisk();\n-        p.name = translateFileName(path);\n-        return p;\n-    }\n-\n-    @Override\n-    public long size() {\n-        return new File(name).length();\n-    }\n-\n-    /**\n-     * Translate the file name to the native format. This will replace '\\' with\n-     * '/' and expand the home directory ('~').\n-     *\n-     * @param fileName the file name\n-     * @return the native file name\n-     */\n-    protected static String translateFileName(String fileName) {\n-        fileName = fileName.replace('\\\\', '/');\n-        if (fileName.startsWith(\"file:\")) {\n-            fileName = fileName.substring(\"file:\".length());\n+  private static final String CLASSPATH_PREFIX = \"classpath:\";\n+\n+  @Override\n+  public FilePathDisk getPath(String path) {\n+    FilePathDisk p = new FilePathDisk();\n+    p.name = translateFileName(path);\n+    return p;\n+  }\n+\n+  @Override\n+  public long size() {\n+    return new File(name).length();\n+  }\n+\n+  /**\n+   * Translate the file name to the native format. This will replace '\\' with\n+   * '/' and expand the home directory ('~').\n+   *\n+   * @param fileName the file name\n+   * @return the native file name\n+   */\n+  protected static String translateFileName(String fileName) {\n+    fileName = fileName.replace('\\\\', '/');\n+    if (fileName.startsWith(\"file:\")) {\n+      fileName = fileName.substring(\"file:\".length());\n+    }\n+    return expandUserHomeDirectory(fileName);\n+  }\n+\n+  /**\n+   * Expand '~' to the user home directory. It is only be expanded if the '~'\n+   * stands alone, or is followed by '/' or '\\'.\n+   *\n+   * @param fileName the file name\n+   * @return the native file name\n+   */\n+  public static String expandUserHomeDirectory(String fileName) {\n+    if (fileName.startsWith(\"~\") && (fileName.length() == 1 ||\n+        fileName.startsWith(\"~/\"))) {\n+      String userDir = SysProperties.USER_HOME;\n+      fileName = userDir + fileName.substring(1);\n+    }\n+    return fileName;\n+  }\n+\n+  @Override\n+  public void moveTo(FilePath newName, boolean atomicReplace) {\n+    File oldFile = new File(name);\n+    File newFile = new File(newName.name);\n+    if (oldFile.getAbsolutePath().equals(newFile.getAbsolutePath())) {\n+      return;\n+    }\n+    if (!oldFile.exists()) {\n+      throw DbException.get(ErrorCode.FILE_RENAME_FAILED_2,\n+          name + \" (not found)\",\n+          newName.name);\n+    }\n+    // Java 7: use java.nio.file.Files.move(Path source, Path target,\n+    //     CopyOption... options)\n+    // with CopyOptions \"REPLACE_EXISTING\" and \"ATOMIC_MOVE\".\n+    if (atomicReplace) {\n+      boolean ok = oldFile.renameTo(newFile);\n+      if (ok) {\n+        return;\n+      }\n+      throw DbException.get(ErrorCode.FILE_RENAME_FAILED_2,\n+          new String[] {name, newName.name});\n+    }\n+    if (newFile.exists()) {\n+      throw DbException.get(ErrorCode.FILE_RENAME_FAILED_2,\n+          new String[] {name, newName + \" (exists)\"});\n+    }\n+    for (int i = 0; i < SysProperties.MAX_FILE_RETRY; i++) {\n+      IOUtils.trace(\"rename\", name + \" >\" + newName, null);\n+      boolean ok = oldFile.renameTo(newFile);\n+      if (ok) {\n+        return;\n+      }\n+      wait(i);\n+    }\n+    throw DbException.get(ErrorCode.FILE_RENAME_FAILED_2,\n+        new String[] {name, newName.name});\n+  }\n+\n+  private static void wait(int i) {\n+    if (i == 8) {\n+      System.gc();\n+    }\n+    try {\n+      // sleep at most 256 ms\n+      long sleep = Math.min(256, i * i);\n+      Thread.sleep(sleep);\n+    } catch (InterruptedException e) {\n+      // ignore\n+    }\n+  }\n+\n+  @Override\n+  public boolean createFile() {\n+    File file = new File(name);\n+    for (int i = 0; i < SysProperties.MAX_FILE_RETRY; i++) {\n+      try {\n+        return file.createNewFile();\n+      } catch (IOException e) {\n+        // 'access denied' is really a concurrent access problem\n+        wait(i);\n+      }\n+    }\n+    return false;\n+  }\n+\n+  @Override\n+  public boolean exists() {\n+    return new File(name).exists();\n+  }\n+\n+  @Override\n+  public void delete() {\n+    File file = new File(name);\n+    for (int i = 0; i < SysProperties.MAX_FILE_RETRY; i++) {\n+      IOUtils.trace(\"delete\", name, null);\n+      boolean ok = file.delete();\n+      if (ok || !file.exists()) {\n+        return;\n+      }\n+      wait(i);\n+    }\n+    throw DbException.get(ErrorCode.FILE_DELETE_FAILED_1, name);\n+  }\n+\n+  @Override\n+  public List<FilePath> newDirectoryStream() {\n+    ArrayList<FilePath> list = New.arrayList();\n+    File f = new File(name);\n+    try {\n+      String[] files = f.list();\n+      if (files != null) {\n+        String base = f.getCanonicalPath();\n+        if (!base.endsWith(SysProperties.FILE_SEPARATOR)) {\n+          base += SysProperties.FILE_SEPARATOR;\n         }\n-        return expandUserHomeDirectory(fileName);\n-    }\n-\n-    /**\n-     * Expand '~' to the user home directory. It is only be expanded if the '~'\n-     * stands alone, or is followed by '/' or '\\'.\n-     *\n-     * @param fileName the file name\n-     * @return the native file name\n-     */\n-    public static String expandUserHomeDirectory(String fileName) {\n-        if (fileName.startsWith(\"~\") && (fileName.length() == 1 ||\n-                fileName.startsWith(\"~/\"))) {\n-            String userDir = SysProperties.USER_HOME;\n-            fileName = userDir + fileName.substring(1);\n-        }\n-        return fileName;\n-    }\n-\n-    @Override\n-    public void moveTo(FilePath newName, boolean atomicReplace) {\n-        File oldFile = new File(name);\n-        File newFile = new File(newName.name);\n-        if (oldFile.getAbsolutePath().equals(newFile.getAbsolutePath())) {\n-            return;\n-        }\n-        if (!oldFile.exists()) {\n-            throw DbException.get(ErrorCode.FILE_RENAME_FAILED_2,\n-                    name + \" (not found)\",\n-                    newName.name);\n-        }\n-        // Java 7: use java.nio.file.Files.move(Path source, Path target,\n-        //     CopyOption... options)\n-        // with CopyOptions \"REPLACE_EXISTING\" and \"ATOMIC_MOVE\".\n-        if (atomicReplace) {\n-            boolean ok = oldFile.renameTo(newFile);\n-            if (ok) {\n-                return;\n-            }\n-            throw DbException.get(ErrorCode.FILE_RENAME_FAILED_2,\n-                    new String[]{name, newName.name});\n-        }\n-        if (newFile.exists()) {\n-            throw DbException.get(ErrorCode.FILE_RENAME_FAILED_2,\n-                new String[] { name, newName + \" (exists)\" });\n-        }\n-        for (int i = 0; i < SysProperties.MAX_FILE_RETRY; i++) {\n-            IOUtils.trace(\"rename\", name + \" >\" + newName, null);\n-            boolean ok = oldFile.renameTo(newFile);\n-            if (ok) {\n-                return;\n-            }\n-            wait(i);\n-        }\n-        throw DbException.get(ErrorCode.FILE_RENAME_FAILED_2,\n-                new String[]{name, newName.name});\n-    }\n-\n-    private static void wait(int i) {\n-        if (i == 8) {\n-            System.gc();\n-        }\n-        try {\n-            // sleep at most 256 ms\n-            long sleep = Math.min(256, i * i);\n-            Thread.sleep(sleep);\n-        } catch (InterruptedException e) {\n-            // ignore\n-        }\n-    }\n-\n-    @Override\n-    public boolean createFile() {\n-        File file = new File(name);\n-        for (int i = 0; i < SysProperties.MAX_FILE_RETRY; i++) {\n-            try {\n-                return file.createNewFile();\n-            } catch (IOException e) {\n-                // 'access denied' is really a concurrent access problem\n-                wait(i);\n-            }\n+        for (int i = 0, len = files.length; i < len; i++) {\n+          list.add(getPath(base + files[i]));\n         }\n+      }\n+      return list;\n+    } catch (IOException e) {\n+      throw DbException.convertIOException(e, name);\n+    }\n+  }\n+\n+  @Override\n+  public boolean canWrite() {\n+    return canWriteInternal(new File(name));\n+  }\n+\n+  @Override\n+  public boolean setReadOnly() {\n+    File f = new File(name);\n+    return f.setReadOnly();\n+  }\n+\n+  @Override\n+  public FilePathDisk toRealPath() {\n+    try {\n+      String fileName = new File(name).getCanonicalPath();\n+      return getPath(fileName);\n+    } catch (IOException e) {\n+      throw DbException.convertIOException(e, name);\n+    }\n+  }\n+\n+  @Override\n+  public FilePath getParent() {\n+    String p = new File(name).getParent();\n+    return p == null ? null : getPath(p);\n+  }\n+\n+  @Override\n+  public boolean isDirectory() {\n+    return new File(name).isDirectory();\n+  }\n+\n+  @Override\n+  public boolean isAbsolute() {\n+    return new File(name).isAbsolute();\n+  }\n+\n+  @Override\n+  public long lastModified() {\n+    return new File(name).lastModified();\n+  }\n+\n+  private static boolean canWriteInternal(File file) {\n+    try {\n+      if (!file.canWrite()) {\n         return false;\n-    }\n-\n-    @Override\n-    public boolean exists() {\n-        return new File(name).exists();\n-    }\n-\n-    @Override\n-    public void delete() {\n-        File file = new File(name);\n-        for (int i = 0; i < SysProperties.MAX_FILE_RETRY; i++) {\n-            IOUtils.trace(\"delete\", name, null);\n-            boolean ok = file.delete();\n-            if (ok || !file.exists()) {\n-                return;\n-            }\n-            wait(i);\n-        }\n-        throw DbException.get(ErrorCode.FILE_DELETE_FAILED_1, name);\n-    }\n-\n-    @Override\n-    public List<FilePath> newDirectoryStream() {\n-        ArrayList<FilePath> list = New.arrayList();\n-        File f = new File(name);\n+      }\n+    } catch (Exception e) {\n+      // workaround for GAE which throws a\n+      // java.security.AccessControlException\n+      return false;\n+    }\n+    // File.canWrite() does not respect windows user permissions,\n+    // so we must try to open it using the mode \"rw\".\n+    // See also http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4420020\n+    RandomAccessFile r = null;\n+    try {\n+      r = new RandomAccessFile(file, \"rw\");\n+      return true;\n+    } catch (FileNotFoundException e) {\n+      return false;\n+    } finally {\n+      if (r != null) {\n         try {\n-            String[] files = f.list();\n-            if (files != null) {\n-                String base = f.getCanonicalPath();\n-                if (!base.endsWith(SysProperties.FILE_SEPARATOR)) {\n-                    base += SysProperties.FILE_SEPARATOR;\n-                }\n-                for (int i = 0, len = files.length; i < len; i++) {\n-                    list.add(getPath(base + files[i]));\n-                }\n-            }\n-            return list;\n+          r.close();\n         } catch (IOException e) {\n-            throw DbException.convertIOException(e, name);\n+          // ignore\n         }\n+      }\n     }\n+  }\n \n-    @Override\n-    public boolean canWrite() {\n-        return canWriteInternal(new File(name));\n-    }\n-\n-    @Override\n-    public boolean setReadOnly() {\n-        File f = new File(name);\n-        return f.setReadOnly();\n-    }\n-\n-    @Override\n-    public FilePathDisk toRealPath() {\n-        try {\n-            String fileName = new File(name).getCanonicalPath();\n-            return getPath(fileName);\n-        } catch (IOException e) {\n-            throw DbException.convertIOException(e, name);\n+  @Override\n+  public void createDirectory() {\n+    File dir = new File(name);\n+    for (int i = 0; i < SysProperties.MAX_FILE_RETRY; i++) {\n+      if (dir.exists()) {\n+        if (dir.isDirectory()) {\n+          return;\n         }\n-    }\n-\n-    @Override\n-    public FilePath getParent() {\n-        String p = new File(name).getParent();\n-        return p == null ? null : getPath(p);\n-    }\n-\n-    @Override\n-    public boolean isDirectory() {\n-        return new File(name).isDirectory();\n-    }\n-\n-    @Override\n-    public boolean isAbsolute() {\n-        return new File(name).isAbsolute();\n-    }\n-\n-    @Override\n-    public long lastModified() {\n-        return new File(name).lastModified();\n-    }\n-\n-    private static boolean canWriteInternal(File file) {\n-        try {\n-            if (!file.canWrite()) {\n-                return false;\n-            }\n-        } catch (Exception e) {\n-            // workaround for GAE which throws a\n-            // java.security.AccessControlException\n-            return false;\n+        throw DbException.get(ErrorCode.FILE_CREATION_FAILED_1,\n+            name + \" (a file with this name already exists)\");\n+      } else if (dir.mkdir()) {\n+        return;\n+      }\n+      wait(i);\n+    }\n+    throw DbException.get(ErrorCode.FILE_CREATION_FAILED_1, name);\n+  }\n+\n+  @Override\n+  public OutputStream newOutputStream(boolean append) throws IOException {\n+    try {\n+      File file = new File(name);\n+      File parent = file.getParentFile();\n+      if (parent != null) {\n+        FileUtils.createDirectories(parent.getAbsolutePath());\n+      }\n+      FileOutputStream out = new FileOutputStream(name, append);\n+      IOUtils.trace(\"openFileOutputStream\", name, out);\n+      return out;\n+    } catch (IOException e) {\n+      freeMemoryAndFinalize();\n+      return new FileOutputStream(name);\n+    }\n+  }\n+\n+  @Override\n+  public InputStream newInputStream() throws IOException {\n+    if (name.matches(\"[a-zA-Z]{2,19}:.*\")) {\n+      // if the ':' is in position 1, a windows file access is assumed:\n+      // C:.. or D:, and if the ':' is not at the beginning, assume its a\n+      // file name with a colon\n+      if (name.startsWith(CLASSPATH_PREFIX)) {\n+        String fileName = name.substring(CLASSPATH_PREFIX.length());\n+        // Force absolute resolution in Class.getResourceAsStream\n+        if (!fileName.startsWith(\"/\")) {\n+          fileName = \"/\" + fileName;\n         }\n-        // File.canWrite() does not respect windows user permissions,\n-        // so we must try to open it using the mode \"rw\".\n-        // See also http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4420020\n-        RandomAccessFile r = null;\n-        try {\n-            r = new RandomAccessFile(file, \"rw\");\n-            return true;\n-        } catch (FileNotFoundException e) {\n-            return false;\n-        } finally {\n-            if (r != null) {\n-                try {\n-                    r.close();\n-                } catch (IOException e) {\n-                    // ignore\n-                }\n-            }\n+        InputStream in = getClass().getResourceAsStream(fileName);\n+        if (in == null) {\n+          // ClassLoader.getResourceAsStream doesn't need leading \"/\"\n+          in = Thread.currentThread().getContextClassLoader().\n+              getResourceAsStream(fileName.substring(1));\n         }\n-    }\n-\n-    @Override\n-    public void createDirectory() {\n-        File dir = new File(name);\n-        for (int i = 0; i < SysProperties.MAX_FILE_RETRY; i++) {\n-            if (dir.exists()) {\n-                if (dir.isDirectory()) {\n-                    return;\n-                }\n-                throw DbException.get(ErrorCode.FILE_CREATION_FAILED_1,\n-                        name + \" (a file with this name already exists)\");\n-            } else if (dir.mkdir()) {\n-                return;\n-            }\n-            wait(i);\n-        }\n-        throw DbException.get(ErrorCode.FILE_CREATION_FAILED_1, name);\n-    }\n-\n-    @Override\n-    public OutputStream newOutputStream(boolean append) throws IOException {\n-        try {\n-            File file = new File(name);\n-            File parent = file.getParentFile();\n-            if (parent != null) {\n-                FileUtils.createDirectories(parent.getAbsolutePath());\n-            }\n-            FileOutputStream out = new FileOutputStream(name, append);\n-            IOUtils.trace(\"openFileOutputStream\", name, out);\n-            return out;\n-        } catch (IOException e) {\n-            freeMemoryAndFinalize();\n-            return new FileOutputStream(name);\n+        if (in == null) {\n+          throw new FileNotFoundException(\"resource \" + fileName);\n         }\n-    }\n-\n-    @Override\n-    public InputStream newInputStream() throws IOException {\n-        if (name.matches(\"[a-zA-Z]{2,19}:.*\")) {\n-            // if the ':' is in position 1, a windows file access is assumed:\n-            // C:.. or D:, and if the ':' is not at the beginning, assume its a\n-            // file name with a colon\n-            if (name.startsWith(CLASSPATH_PREFIX)) {\n-                String fileName = name.substring(CLASSPATH_PREFIX.length());\n-\t\t// Force absolute resolution in Class.getResourceAsStream\n-                if (!fileName.startsWith(\"/\")) {\n-                    fileName = \"/\" + fileName;\n-                }\n-                InputStream in = getClass().getResourceAsStream(fileName);\n-                if (in == null) {\n-                    // ClassLoader.getResourceAsStream doesn't need leading \"/\"\n-                    in = Thread.currentThread().getContextClassLoader().\n-                            getResourceAsStream(fileName.substring(1));\n-                }\n-                if (in == null) {\n-                    throw new FileNotFoundException(\"resource \" + fileName);\n-                }\n-                return in;\n-            }\n-            // otherwise an URL is assumed\n-            URL url = new URL(name);\n-            InputStream in = url.openStream();\n-            return in;\n-        }\n-        FileInputStream in = new FileInputStream(name);\n-        IOUtils.trace(\"openFileInputStream\", name, in);\n         return in;\n-    }\n-\n-    /**\n-     * Call the garbage collection and run finalization. This close all files\n-     * that were not closed, and are no longer referenced.\n-     */\n-    static void freeMemoryAndFinalize() {\n-        IOUtils.trace(\"freeMemoryAndFinalize\", null, null);\n-        Runtime rt = Runtime.getRuntime();\n-        long mem = rt.freeMemory();\n-        for (int i = 0; i < 16; i++) {\n-            rt.gc();\n-            long now = rt.freeMemory();\n-            rt.runFinalization();\n-            if (now == mem) {\n-                break;\n-            }\n-            mem = now;\n-        }\n-    }\n-\n-    @Override\n-    public FileChannel open(String mode) throws IOException {\n-        FileDisk f;\n+      }\n+      // otherwise an URL is assumed\n+      URL url = new URL(name);\n+      InputStream in = url.openStream();\n+      return in;\n+    }\n+    FileInputStream in = new FileInputStream(name);\n+    IOUtils.trace(\"openFileInputStream\", name, in);\n+    return in;\n+  }\n+\n+  /**\n+   * Call the garbage collection and run finalization. This close all files\n+   * that were not closed, and are no longer referenced.\n+   */\n+  static void freeMemoryAndFinalize() {\n+    IOUtils.trace(\"freeMemoryAndFinalize\", null, null);\n+    Runtime rt = Runtime.getRuntime();\n+    long mem = rt.freeMemory();\n+    for (int i = 0; i < 16; i++) {\n+      rt.gc();\n+      long now = rt.freeMemory();\n+      rt.runFinalization();\n+      if (now == mem) {\n+        break;\n+      }\n+      mem = now;\n+    }\n+  }\n+\n+  @Override\n+  public FileChannel open(String mode) throws IOException {\n+    FileDisk f;\n+    try {\n+      f = new FileDisk(name, mode);\n+      IOUtils.trace(\"open\", name, f);\n+    } catch (IOException e) {\n+      freeMemoryAndFinalize();\n+      try {\n+        f = new FileDisk(name, mode);\n+      } catch (IOException e2) {\n+        throw e;\n+      }\n+    }\n+    return f;\n+  }\n+\n+  @Override\n+  public String getScheme() {\n+    return \"file\";\n+  }\n+\n+  @Override\n+  public FilePath createTempFile(String suffix, boolean deleteOnExit,\n+                                 boolean inTempDir) throws IOException {\n+    String fileName = name + \".\";\n+    String prefix = new File(fileName).getName();\n+    File dir;\n+    if (inTempDir) {\n+      dir = new File(System.getProperty(\"java.io.tmpdir\", \".\"));\n+    } else {\n+      dir = new File(fileName).getAbsoluteFile().getParentFile();\n+    }\n+    FileUtils.createDirectories(dir.getAbsolutePath());\n+    while (true) {\n+      File f = new File(dir, prefix + getNextTempFileNamePart(false) + suffix);\n+      if (f.exists() || !f.createNewFile()) {\n+        // in theory, the random number could collide\n+        getNextTempFileNamePart(true);\n+        continue;\n+      }\n+      if (deleteOnExit) {\n         try {\n-            f = new FileDisk(name, mode);\n-            IOUtils.trace(\"open\", name, f);\n-        } catch (IOException e) {\n-            freeMemoryAndFinalize();\n-            try {\n-                f = new FileDisk(name, mode);\n-            } catch (IOException e2) {\n-                throw e;\n-            }\n-        }\n-        return f;\n-    }\n-\n-    @Override\n-    public String getScheme() {\n-        return \"file\";\n-    }\n-\n-    @Override\n-    public FilePath createTempFile(String suffix, boolean deleteOnExit,\n-            boolean inTempDir) throws IOException {\n-        String fileName = name + \".\";\n-        String prefix = new File(fileName).getName();\n-        File dir;\n-        if (inTempDir) {\n-            dir = new File(System.getProperty(\"java.io.tmpdir\", \".\"));\n-        } else {\n-            dir = new File(fileName).getAbsoluteFile().getParentFile();\n-        }\n-        FileUtils.createDirectories(dir.getAbsolutePath());\n-        while (true) {\n-            File f = new File(dir, prefix + getNextTempFileNamePart(false) + suffix);\n-            if (f.exists() || !f.createNewFile()) {\n-                // in theory, the random number could collide\n-                getNextTempFileNamePart(true);\n-                continue;\n-            }\n-            if (deleteOnExit) {\n-                try {\n-                    f.deleteOnExit();\n-                } catch (Throwable e) {\n-                    // sometimes this throws a NullPointerException\n-                    // at java.io.DeleteOnExitHook.add(DeleteOnExitHook.java:33)\n-                    // we can ignore it\n-                }\n-            }\n-            return get(f.getCanonicalPath());\n+          f.deleteOnExit();\n+        } catch (Throwable e) {\n+          // sometimes this throws a NullPointerException\n+          // at java.io.DeleteOnExitHook.add(DeleteOnExitHook.java:33)\n+          // we can ignore it\n         }\n+      }\n+      return get(f.getCanonicalPath());\n     }\n+  }\n \n }\n \n@@ -404,94 +405,94 @@ public class FilePathDisk extends FilePath {\n  */\n class FileDisk extends FileBase {\n \n-    private final RandomAccessFile file;\n-    private final String name;\n-    private final boolean readOnly;\n-\n-    FileDisk(String fileName, String mode) throws FileNotFoundException {\n-        this.file = new RandomAccessFile(fileName, mode);\n-        this.name = fileName;\n-        this.readOnly = mode.equals(\"r\");\n-    }\n-\n-    @Override\n-    public void force(boolean metaData) throws IOException {\n-        String m = SysProperties.SYNC_METHOD;\n-        if (\"\".equals(m)) {\n-            // do nothing\n-        } else if (\"sync\".equals(m)) {\n-            file.getFD().sync();\n-        } else if (\"force\".equals(m)) {\n-            file.getChannel().force(true);\n-        } else if (\"forceFalse\".equals(m)) {\n-            file.getChannel().force(false);\n-        } else {\n-            file.getFD().sync();\n-        }\n-    }\n-\n-    @Override\n-    public FileChannel truncate(long newLength) throws IOException {\n-        // compatibility with JDK FileChannel#truncate\n-        if (readOnly) {\n-            throw new NonWritableChannelException();\n-        }\n-        /*\n-         * RandomAccessFile.setLength() does not always work here since Java 9 for\n-         * unknown reason so use FileChannel.truncate().\n-         */\n-        file.getChannel().truncate(newLength);\n-        return this;\n-    }\n-\n-    @Override\n-    public synchronized FileLock tryLock(long position, long size,\n-            boolean shared) throws IOException {\n-        return file.getChannel().tryLock(position, size, shared);\n-    }\n-\n-    @Override\n-    public void implCloseChannel() throws IOException {\n-        file.close();\n-    }\n-\n-    @Override\n-    public long position() throws IOException {\n-        return file.getFilePointer();\n-    }\n-\n-    @Override\n-    public long size() throws IOException {\n-        return file.length();\n-    }\n-\n-    @Override\n-    public int read(ByteBuffer dst) throws IOException {\n-        int len = file.read(dst.array(), dst.arrayOffset() + dst.position(),\n-                dst.remaining());\n-        if (len > 0) {\n-            dst.position(dst.position() + len);\n-        }\n-        return len;\n-    }\n-\n-    @Override\n-    public FileChannel position(long pos) throws IOException {\n-        file.seek(pos);\n-        return this;\n-    }\n-\n-    @Override\n-    public int write(ByteBuffer src) throws IOException {\n-        int len = src.remaining();\n-        file.write(src.array(), src.arrayOffset() + src.position(), len);\n-        src.position(src.position() + len);\n-        return len;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return name;\n-    }\n+  private final RandomAccessFile file;\n+  private final String name;\n+  private final boolean readOnly;\n+\n+  FileDisk(String fileName, String mode) throws FileNotFoundException {\n+    this.file = new RandomAccessFile(fileName, mode);\n+    this.name = fileName;\n+    this.readOnly = mode.equals(\"r\");\n+  }\n+\n+  @Override\n+  public void force(boolean metaData) throws IOException {\n+    String m = SysProperties.SYNC_METHOD;\n+    if (\"\".equals(m)) {\n+      // do nothing\n+    } else if (\"sync\".equals(m)) {\n+      file.getFD().sync();\n+    } else if (\"force\".equals(m)) {\n+      file.getChannel().force(true);\n+    } else if (\"forceFalse\".equals(m)) {\n+      file.getChannel().force(false);\n+    } else {\n+      file.getFD().sync();\n+    }\n+  }\n+\n+  @Override\n+  public FileChannel truncate(long newLength) throws IOException {\n+    // compatibility with JDK FileChannel#truncate\n+    if (readOnly) {\n+      throw new NonWritableChannelException();\n+    }\n+    /*\n+     * RandomAccessFile.setLength() does not always work here since Java 9 for\n+     * unknown reason so use FileChannel.truncate().\n+     */\n+    file.getChannel().truncate(newLength);\n+    return this;\n+  }\n+\n+  @Override\n+  public synchronized FileLock tryLock(long position, long size,\n+                                       boolean shared) throws IOException {\n+    return file.getChannel().tryLock(position, size, shared);\n+  }\n+\n+  @Override\n+  public void implCloseChannel() throws IOException {\n+    file.close();\n+  }\n+\n+  @Override\n+  public long position() throws IOException {\n+    return file.getFilePointer();\n+  }\n+\n+  @Override\n+  public long size() throws IOException {\n+    return file.length();\n+  }\n+\n+  @Override\n+  public int read(ByteBuffer dst) throws IOException {\n+    int len = file.read(dst.array(), dst.arrayOffset() + dst.position(),\n+        dst.remaining());\n+    if (len > 0) {\n+      dst.position(dst.position() + len);\n+    }\n+    return len;\n+  }\n+\n+  @Override\n+  public FileChannel position(long pos) throws IOException {\n+    file.seek(pos);\n+    return this;\n+  }\n+\n+  @Override\n+  public int write(ByteBuffer src) throws IOException {\n+    int len = src.remaining();\n+    file.write(src.array(), src.arrayOffset() + src.position(), len);\n+    src.position(src.position() + len);\n+    return len;\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return name;\n+  }\n \n }\n",
            "diff_size": 663
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/506/FilePathDisk.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/codebuff/506/FilePathDisk.java\nindex 68435939954..391c4e1b2f4 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/506/FilePathDisk.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/codebuff/506/FilePathDisk.java\n@@ -20,7 +20,6 @@ import java.nio.channels.FileLock;\n import java.nio.channels.NonWritableChannelException;\n import java.util.ArrayList;\n import java.util.List;\n-\n import org.h2.api.ErrorCode;\n import org.h2.engine.SysProperties;\n import org.h2.message.DbException;\n@@ -31,6 +30,8 @@ import org.h2.util.New;\n  * This file system stores files on disk.\n  * This is the most common file system.\n  */\n+\n+\n public class FilePathDisk extends FilePath {\n \n     private static final String CLASSPATH_PREFIX = \"classpath:\";\n@@ -54,6 +55,8 @@ public class FilePathDisk extends FilePath {\n      * @param fileName the file name\n      * @return the native file name\n      */\n+\n+\n     protected static String translateFileName(String fileName) {\n         fileName = fileName.replace('\\\\', '/');\n         if (fileName.startsWith(\"file:\")) {\n@@ -69,9 +72,10 @@ public class FilePathDisk extends FilePath {\n      * @param fileName the file name\n      * @return the native file name\n      */\n+\n+\n     public static String expandUserHomeDirectory(String fileName) {\n-        if (fileName.startsWith(\"~\") && (fileName.length() == 1 ||\n-                fileName.startsWith(\"~/\"))) {\n+        if (fileName.startsWith(\"~\") && (fileName.length() == 1 || fileName.startsWith(\"~/\"))) {\n             String userDir = SysProperties.USER_HOME;\n             fileName = userDir + fileName.substring(1);\n         }\n@@ -86,9 +90,7 @@ public class FilePathDisk extends FilePath {\n             return;\n         }\n         if (!oldFile.exists()) {\n-            throw DbException.get(ErrorCode.FILE_RENAME_FAILED_2,\n-                    name + \" (not found)\",\n-                    newName.name);\n+            throw DbException.get(ErrorCode.FILE_RENAME_FAILED_2, name + \" (not found)\", newName.name);\n         }\n         // Java 7: use java.nio.file.Files.move(Path source, Path target,\n         //     CopyOption... options)\n@@ -99,11 +101,11 @@ public class FilePathDisk extends FilePath {\n                 return;\n             }\n             throw DbException.get(ErrorCode.FILE_RENAME_FAILED_2,\n-                    new String[]{name, newName.name});\n+                new String[] { name, newName.name });\n         }\n         if (newFile.exists()) {\n             throw DbException.get(ErrorCode.FILE_RENAME_FAILED_2,\n-                new String[] { name, newName + \" (exists)\" });\n+                new String[] { name, newName + \" (exists)\"});\n         }\n         for (int i = 0; i < SysProperties.MAX_FILE_RETRY; i++) {\n             IOUtils.trace(\"rename\", name + \" >\" + newName, null);\n@@ -114,7 +116,7 @@ public class FilePathDisk extends FilePath {\n             wait(i);\n         }\n         throw DbException.get(ErrorCode.FILE_RENAME_FAILED_2,\n-                new String[]{name, newName.name});\n+            new String[] { name, newName.name });\n     }\n \n     private static void wait(int i) {\n@@ -127,6 +129,7 @@ public class FilePathDisk extends FilePath {\n             Thread.sleep(sleep);\n         } catch (InterruptedException e) {\n             // ignore\n+\n         }\n     }\n \n@@ -251,6 +254,7 @@ public class FilePathDisk extends FilePath {\n                     r.close();\n                 } catch (IOException e) {\n                     // ignore\n+\n                 }\n             }\n         }\n@@ -264,8 +268,7 @@ public class FilePathDisk extends FilePath {\n                 if (dir.isDirectory()) {\n                     return;\n                 }\n-                throw DbException.get(ErrorCode.FILE_CREATION_FAILED_1,\n-                        name + \" (a file with this name already exists)\");\n+                throw DbException.get(ErrorCode.FILE_CREATION_FAILED_1, name + \" (a file with this name already exists)\");\n             } else if (dir.mkdir()) {\n                 return;\n             }\n@@ -299,15 +302,14 @@ public class FilePathDisk extends FilePath {\n             // file name with a colon\n             if (name.startsWith(CLASSPATH_PREFIX)) {\n                 String fileName = name.substring(CLASSPATH_PREFIX.length());\n-\t\t// Force absolute resolution in Class.getResourceAsStream\n+        // Force absolute resolution in Class.getResourceAsStream\n                 if (!fileName.startsWith(\"/\")) {\n                     fileName = \"/\" + fileName;\n                 }\n                 InputStream in = getClass().getResourceAsStream(fileName);\n                 if (in == null) {\n                     // ClassLoader.getResourceAsStream doesn't need leading \"/\"\n-                    in = Thread.currentThread().getContextClassLoader().\n-                            getResourceAsStream(fileName.substring(1));\n+                    in = Thread.currentThread().getContextClassLoader().getResourceAsStream(fileName.substring(1));\n                 }\n                 if (in == null) {\n                     throw new FileNotFoundException(\"resource \" + fileName);\n@@ -328,6 +330,8 @@ public class FilePathDisk extends FilePath {\n      * Call the garbage collection and run finalization. This close all files\n      * that were not closed, and are no longer referenced.\n      */\n+\n+\n     static void freeMemoryAndFinalize() {\n         IOUtils.trace(\"freeMemoryAndFinalize\", null, null);\n         Runtime rt = Runtime.getRuntime();\n@@ -366,8 +370,7 @@ public class FilePathDisk extends FilePath {\n     }\n \n     @Override\n-    public FilePath createTempFile(String suffix, boolean deleteOnExit,\n-            boolean inTempDir) throws IOException {\n+    public FilePath createTempFile(String suffix, boolean deleteOnExit, boolean inTempDir) throws IOException {\n         String fileName = name + \".\";\n         String prefix = new File(fileName).getName();\n         File dir;\n@@ -391,6 +394,7 @@ public class FilePathDisk extends FilePath {\n                     // sometimes this throws a NullPointerException\n                     // at java.io.DeleteOnExitHook.add(DeleteOnExitHook.java:33)\n                     // we can ignore it\n+\n                 }\n             }\n             return get(f.getCanonicalPath());\n@@ -402,6 +406,8 @@ public class FilePathDisk extends FilePath {\n /**\n  * Uses java.io.RandomAccessFile to access a file.\n  */\n+\n+\n class FileDisk extends FileBase {\n \n     private final RandomAccessFile file;\n@@ -419,15 +425,16 @@ class FileDisk extends FileBase {\n         String m = SysProperties.SYNC_METHOD;\n         if (\"\".equals(m)) {\n             // do nothing\n+\n         } else if (\"sync\".equals(m)) {\n             file.getFD().sync();\n-        } else if (\"force\".equals(m)) {\n-            file.getChannel().force(true);\n+                                                           } else if (\"force\".equals(m)) {\n+                   file.getChannel().force(true);\n         } else if (\"forceFalse\".equals(m)) {\n-            file.getChannel().force(false);\n+                                                                      file.getChannel().force(false);\n         } else {\n-            file.getFD().sync();\n-        }\n+                                                                      file.getFD().sync();\n+                                                                  }\n     }\n \n     @Override\n@@ -445,8 +452,7 @@ class FileDisk extends FileBase {\n     }\n \n     @Override\n-    public synchronized FileLock tryLock(long position, long size,\n-            boolean shared) throws IOException {\n+    public synchronized FileLock tryLock(long position, long size, boolean shared) throws IOException {\n         return file.getChannel().tryLock(position, size, shared);\n     }\n \n@@ -467,8 +473,7 @@ class FileDisk extends FileBase {\n \n     @Override\n     public int read(ByteBuffer dst) throws IOException {\n-        int len = file.read(dst.array(), dst.arrayOffset() + dst.position(),\n-                dst.remaining());\n+        int len = file.read(dst.array(), dst.arrayOffset() + dst.position(), dst.remaining());\n         if (len > 0) {\n             dst.position(dst.position() + len);\n         }\n@@ -494,4 +499,4 @@ class FileDisk extends FileBase {\n         return name;\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 40
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/506/FilePathDisk.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_random/506/FilePathDisk.java\nindex 68435939954..40de30d0bcc 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/506/FilePathDisk.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_random/506/FilePathDisk.java\n@@ -299,7 +299,7 @@ public class FilePathDisk extends FilePath {\n             // file name with a colon\n             if (name.startsWith(CLASSPATH_PREFIX)) {\n                 String fileName = name.substring(CLASSPATH_PREFIX.length());\n-\t\t// Force absolute resolution in Class.getResourceAsStream\n+                // Force absolute resolution in Class.getResourceAsStream\n                 if (!fileName.startsWith(\"/\")) {\n                     fileName = \"/\" + fileName;\n                 }\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/506/FilePathDisk.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/506/FilePathDisk.java\nindex 68435939954..40de30d0bcc 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/506/FilePathDisk.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/506/FilePathDisk.java\n@@ -299,7 +299,7 @@ public class FilePathDisk extends FilePath {\n             // file name with a colon\n             if (name.startsWith(CLASSPATH_PREFIX)) {\n                 String fileName = name.substring(CLASSPATH_PREFIX.length());\n-\t\t// Force absolute resolution in Class.getResourceAsStream\n+                // Force absolute resolution in Class.getResourceAsStream\n                 if (!fileName.startsWith(\"/\")) {\n                     fileName = \"/\" + fileName;\n                 }\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "naturalize"
    ]
}