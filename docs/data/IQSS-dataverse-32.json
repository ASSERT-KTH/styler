{
    "project_name": "IQSS-dataverse",
    "error_id": "32",
    "information": {
        "errors": [
            {
                "line": "124",
                "column": "1",
                "severity": "error",
                "message": "File contains tab characters (this is the first instance).",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
            }
        ]
    },
    "source_code": "            if ( registerGlobalIdsForFiles ){\n                registerGlobalIdsForFiles = currentGlobalAuthority.equals( theDataset.getAuthority() );\n\t    }\n            \n            boolean validatePhysicalFiles = ctxt.systemConfig().isDatafileValidationOnPublishEnabled();\n",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/32/PublishDatasetCommand.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler/32/PublishDatasetCommand.java\nindex f1bab1901d0..a641b0195d1 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/32/PublishDatasetCommand.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler/32/PublishDatasetCommand.java\n@@ -121,9 +121,8 @@ public class PublishDatasetCommand extends AbstractPublishDatasetCommand<Publish\n             \n             if ( registerGlobalIdsForFiles ){\n                 registerGlobalIdsForFiles = currentGlobalAuthority.equals( theDataset.getAuthority() );\n-\t    }\n-            \n-            boolean validatePhysicalFiles = ctxt.systemConfig().isDatafileValidationOnPublishEnabled();\n+            }\n+                boolean validatePhysicalFiles = ctxt.systemConfig().isDatafileValidationOnPublishEnabled();\n \n             // As of v5.0, publishing a dataset is always done asynchronously, \n             // with the dataset locked for the duration of the operation. \n",
            "diff_size": 3
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/32/PublishDatasetCommand.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/intellij/32/PublishDatasetCommand.java\nindex f1bab1901d0..c2f1b9af3f4 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/32/PublishDatasetCommand.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/intellij/32/PublishDatasetCommand.java\n@@ -24,210 +24,221 @@ import static java.util.stream.Collectors.joining;\n import static edu.harvard.iq.dataverse.engine.command.impl.PublishDatasetResult.Status;\n \n /**\n- * Kick-off a dataset publication process. The process may complete immediately, \n- * but may also result in a workflow being started and pending on some external \n- * response. Either way, the process will be completed by an instance of \n+ * Kick-off a dataset publication process. The process may complete immediately,\n+ * but may also result in a workflow being started and pending on some external\n+ * response. Either way, the process will be completed by an instance of\n  * {@link FinalizeDatasetPublicationCommand}.\n- * \n- * @see FinalizeDatasetPublicationCommand\n- * \n+ *\n  * @author skraffmiller\n  * @author michbarsinai\n+ * @see FinalizeDatasetPublicationCommand\n  */\n @RequiredPermissions(Permission.PublishDataset)\n public class PublishDatasetCommand extends AbstractPublishDatasetCommand<PublishDatasetResult> {\n-    private static final Logger logger = Logger.getLogger(PublishDatasetCommand.class.getName());\n-    boolean minorRelease;\n-    DataverseRequest request;\n-    \n-    /** \n-     * The dataset was already released by an external system, and now Dataverse\n-     * is just internally marking this release version as released. This is happening\n-     * in scenarios like import or migration.\n-     */\n-    final boolean datasetExternallyReleased;\n-    \n-    public PublishDatasetCommand(Dataset datasetIn, DataverseRequest aRequest, boolean minor) {\n-        this( datasetIn, aRequest, minor, false );\n+  private static final Logger logger = Logger.getLogger(PublishDatasetCommand.class.getName());\n+  boolean minorRelease;\n+  DataverseRequest request;\n+\n+  /**\n+   * The dataset was already released by an external system, and now Dataverse\n+   * is just internally marking this release version as released. This is happening\n+   * in scenarios like import or migration.\n+   */\n+  final boolean datasetExternallyReleased;\n+\n+  public PublishDatasetCommand(Dataset datasetIn, DataverseRequest aRequest, boolean minor) {\n+    this(datasetIn, aRequest, minor, false);\n+  }\n+\n+  public PublishDatasetCommand(Dataset datasetIn, DataverseRequest aRequest, boolean minor, boolean isPidPrePublished) {\n+    super(datasetIn, aRequest);\n+    minorRelease = minor;\n+    datasetExternallyReleased = isPidPrePublished;\n+    request = aRequest;\n+  }\n+\n+  @Override\n+  public PublishDatasetResult execute(CommandContext ctxt) throws CommandException {\n+\n+    verifyCommandArguments(ctxt);\n+\n+    // Invariant 1: If we're here, publishing the dataset makes sense, from a \"business logic\" point of view.\n+    // Invariant 2: The latest version of the dataset is the one being published, EVEN IF IT IS NOT DRAFT.\n+    //              When importing a released dataset, the latest version is marked as RELEASED.\n+\n+    Dataset theDataset = getDataset();\n+\n+\n+    //ToDo - any reason to set the version in publish versus finalize? Failure in a prepub workflow or finalize will leave draft versions with an assigned version number as is.\n+    //Changing the dataset in this transaction also potentially makes a race condition with a prepub workflow, possibly resulting in an OptimisticLockException there.\n+\n+    // Set the version numbers:\n+\n+    if (theDataset.getPublicationDate() == null) {\n+      // First Release\n+      theDataset.getLatestVersion()\n+        .setVersionNumber(new Long(1)); // minor release is blocked by #verifyCommandArguments\n+      theDataset.getLatestVersion().setMinorVersionNumber(new Long(0));\n+\n+    } else if (minorRelease) {\n+      theDataset.getLatestVersion().setVersionNumber(new Long(theDataset.getVersionNumber()));\n+      theDataset.getLatestVersion().setMinorVersionNumber(new Long(theDataset.getMinorVersionNumber() + 1));\n+\n+    } else {\n+      // major, non-first release\n+      theDataset.getLatestVersion().setVersionNumber(new Long(theDataset.getVersionNumber() + 1));\n+      theDataset.getLatestVersion().setMinorVersionNumber(new Long(0));\n+    }\n+\n+    //ToDo - should this be in onSuccess()? May relate to todo above\n+    Optional<Workflow> prePubWf = ctxt.workflows().getDefaultWorkflow(TriggerType.PrePublishDataset);\n+    if (prePubWf.isPresent()) {\n+      // We start a workflow\n+      theDataset = ctxt.em().merge(theDataset);\n+      ctxt.em().flush();\n+      ctxt.workflows()\n+        .start(prePubWf.get(), buildContext(theDataset, TriggerType.PrePublishDataset, datasetExternallyReleased),\n+          true);\n+      return new PublishDatasetResult(theDataset, Status.Workflow);\n+\n+    } else {\n+      // We will skip trying to register the global identifiers for datafiles\n+      // if \"dependent\" file-level identifiers are requested, AND the naming\n+      // protocol of the dataset global id is different from the\n+      // one currently configured for the Dataverse. This is to specifically\n+      // address the issue with the datasets with handle ids registered,\n+      // that are currently configured to use DOI.\n+      // If we are registering file-level identifiers, and there are more\n+      // than the configured limit number of files, then call Finalize\n+      // asychronously (default is 10)\n+      // ...\n+      // Additionaly in 4.9.3 we have added a system variable to disable\n+      // registering file PIDs on the installation level.\n+      String currentGlobalIdProtocol = ctxt.settings().getValueForKey(SettingsServiceBean.Key.Protocol, \"\");\n+      String currentGlobalAuthority = ctxt.settings().getValueForKey(SettingsServiceBean.Key.Authority, \"\");\n+      String dataFilePIDFormat = ctxt.settings().getValueForKey(SettingsServiceBean.Key.DataFilePIDFormat, \"DEPENDENT\");\n+      boolean registerGlobalIdsForFiles =\n+        (currentGlobalIdProtocol.equals(theDataset.getProtocol()) || dataFilePIDFormat.equals(\"INDEPENDENT\"))\n+          && ctxt.systemConfig().isFilePIDsEnabled();\n+\n+      if (registerGlobalIdsForFiles) {\n+        registerGlobalIdsForFiles = currentGlobalAuthority.equals(theDataset.getAuthority());\n+      }\n+\n+      boolean validatePhysicalFiles = ctxt.systemConfig().isDatafileValidationOnPublishEnabled();\n+\n+      // As of v5.0, publishing a dataset is always done asynchronously,\n+      // with the dataset locked for the duration of the operation.\n+\n+      //if ((registerGlobalIdsForFiles || validatePhysicalFiles)\n+      //        && theDataset.getFiles().size() > ctxt.systemConfig().getPIDAsynchRegFileCount()) {\n+\n+      String info = \"Publishing the dataset; \";\n+      info += registerGlobalIdsForFiles ? \"Registering PIDs for Datafiles; \" : \"\";\n+      info += validatePhysicalFiles ? \"Validating Datafiles Asynchronously\" : \"\";\n+\n+      AuthenticatedUser user = request.getAuthenticatedUser();\n+      DatasetLock lock = new DatasetLock(DatasetLock.Reason.finalizePublication, user);\n+      lock.setDataset(theDataset);\n+      lock.setInfo(info);\n+      ctxt.datasets().addDatasetLock(theDataset, lock);\n+      theDataset = ctxt.em().merge(theDataset);\n+      // The call to FinalizePublicationCommand has been moved to the new @onSuccess()\n+      // method:\n+      //ctxt.datasets().callFinalizePublishCommandAsynchronously(theDataset.getId(), ctxt, request, datasetExternallyReleased);\n+      return new PublishDatasetResult(theDataset, Status.Inprogress);\n+\n+      /**\n+       * Code for for \"synchronous\" (while-you-wait) publishing\n+       * is preserved below, commented out:\n+       } else {\n+       // Synchronous publishing (no workflow involved)\n+       theDataset = ctxt.engine().submit(new FinalizeDatasetPublicationCommand(theDataset, getRequest(),datasetExternallyReleased));\n+       return new PublishDatasetResult(theDataset, Status.Completed);\n+       } */\n+    }\n+  }\n+\n+  /**\n+   * See that publishing the dataset in the requested manner makes sense, at\n+   * the given state of the dataset.\n+   *\n+   * @throws IllegalCommandException if the publication request is invalid.\n+   */\n+  private void verifyCommandArguments(CommandContext ctxt) throws IllegalCommandException {\n+    if (!getDataset().getOwner().isReleased()) {\n+      throw new IllegalCommandException(\n+        \"This dataset may not be published because its host dataverse (\" + getDataset().getOwner().getAlias() +\n+          \") has not been published.\", this);\n+    }\n+\n+    if (!getUser().isAuthenticated()) {\n+      throw new IllegalCommandException(\n+        \"Only authenticated users can release a Dataset. Please authenticate and try again.\", this);\n+    }\n+\n+    if ((getDataset().isLockedFor(DatasetLock.Reason.Workflow) && !ctxt.permissions()\n+      .isMatchingWorkflowLock(getDataset(), request.getUser().getIdentifier(), request.getWFInvocationId()))\n+      || getDataset().isLockedFor(DatasetLock.Reason.Ingest)\n+      || getDataset().isLockedFor(DatasetLock.Reason.finalizePublication)\n+      || getDataset().isLockedFor(DatasetLock.Reason.EditInProgress)) {\n+      throw new IllegalCommandException(\"This dataset is locked. Reason: \"\n+        + getDataset().getLocks().stream().map(l -> l.getReason().name()).collect(joining(\",\"))\n+        + \". Please try publishing later.\", this);\n     }\n-    \n-    public PublishDatasetCommand(Dataset datasetIn, DataverseRequest aRequest, boolean minor, boolean isPidPrePublished) {\n-        super(datasetIn, aRequest);\n-        minorRelease = minor;\n-        datasetExternallyReleased = isPidPrePublished;\n-        request = aRequest;\n+\n+    if (getDataset().isLockedFor(DatasetLock.Reason.FileValidationFailed)) {\n+      throw new IllegalCommandException(\n+        \"This dataset cannot be published because some files have been found missing or corrupted. \"\n+          + \". Please contact support to address this.\", this);\n     }\n \n-    @Override\n-    public PublishDatasetResult execute(CommandContext ctxt) throws CommandException {\n-        \n-        verifyCommandArguments(ctxt);\n-        \n-        // Invariant 1: If we're here, publishing the dataset makes sense, from a \"business logic\" point of view.\n-        // Invariant 2: The latest version of the dataset is the one being published, EVEN IF IT IS NOT DRAFT.\n-        //              When importing a released dataset, the latest version is marked as RELEASED.\n-\n-        Dataset theDataset = getDataset();\n-\n-        \n-        //ToDo - any reason to set the version in publish versus finalize? Failure in a prepub workflow or finalize will leave draft versions with an assigned version number as is.\n-        //Changing the dataset in this transaction also potentially makes a race condition with a prepub workflow, possibly resulting in an OptimisticLockException there.\n-        \n-        // Set the version numbers:\n-\n-        if (theDataset.getPublicationDate() == null) {\n-            // First Release\n-            theDataset.getLatestVersion().setVersionNumber(new Long(1)); // minor release is blocked by #verifyCommandArguments\n-            theDataset.getLatestVersion().setMinorVersionNumber(new Long(0));\n-            \n-        } else if ( minorRelease ) {\n-            theDataset.getLatestVersion().setVersionNumber(new Long(theDataset.getVersionNumber()));\n-            theDataset.getLatestVersion().setMinorVersionNumber(new Long(theDataset.getMinorVersionNumber() + 1));\n-            \n-        } else {\n-            // major, non-first release\n-            theDataset.getLatestVersion().setVersionNumber(new Long(theDataset.getVersionNumber() + 1));\n-            theDataset.getLatestVersion().setMinorVersionNumber(new Long(0));\n-        }\n-        \n-        //ToDo - should this be in onSuccess()? May relate to todo above \n-        Optional<Workflow> prePubWf = ctxt.workflows().getDefaultWorkflow(TriggerType.PrePublishDataset);\n-        if ( prePubWf.isPresent() ) {\n-            // We start a workflow\n-            theDataset = ctxt.em().merge(theDataset);\n-            ctxt.em().flush();\n-            ctxt.workflows().start(prePubWf.get(), buildContext(theDataset, TriggerType.PrePublishDataset, datasetExternallyReleased), true);\n-            return new PublishDatasetResult(theDataset, Status.Workflow);\n-            \n-        } else{\n-            // We will skip trying to register the global identifiers for datafiles \n-            // if \"dependent\" file-level identifiers are requested, AND the naming \n-            // protocol of the dataset global id is different from the \n-            // one currently configured for the Dataverse. This is to specifically \n-            // address the issue with the datasets with handle ids registered, \n-            // that are currently configured to use DOI.\n-            // If we are registering file-level identifiers, and there are more \n-            // than the configured limit number of files, then call Finalize \n-            // asychronously (default is 10)\n-            // ...\n-            // Additionaly in 4.9.3 we have added a system variable to disable \n-            // registering file PIDs on the installation level.\n-            String currentGlobalIdProtocol = ctxt.settings().getValueForKey(SettingsServiceBean.Key.Protocol, \"\");\n-            String currentGlobalAuthority= ctxt.settings().getValueForKey(SettingsServiceBean.Key.Authority, \"\");\n-            String dataFilePIDFormat = ctxt.settings().getValueForKey(SettingsServiceBean.Key.DataFilePIDFormat, \"DEPENDENT\");\n-            boolean registerGlobalIdsForFiles = \n-                    (currentGlobalIdProtocol.equals(theDataset.getProtocol()) || dataFilePIDFormat.equals(\"INDEPENDENT\")) \n-                    && ctxt.systemConfig().isFilePIDsEnabled();\n-            \n-            if ( registerGlobalIdsForFiles ){\n-                registerGlobalIdsForFiles = currentGlobalAuthority.equals( theDataset.getAuthority() );\n-\t    }\n-            \n-            boolean validatePhysicalFiles = ctxt.systemConfig().isDatafileValidationOnPublishEnabled();\n-\n-            // As of v5.0, publishing a dataset is always done asynchronously, \n-            // with the dataset locked for the duration of the operation. \n-            \n-            //if ((registerGlobalIdsForFiles || validatePhysicalFiles) \n-            //        && theDataset.getFiles().size() > ctxt.systemConfig().getPIDAsynchRegFileCount()) { \n-                \n-            String info = \"Publishing the dataset; \"; \n-            info += registerGlobalIdsForFiles ? \"Registering PIDs for Datafiles; \" : \"\";\n-            info += validatePhysicalFiles ? \"Validating Datafiles Asynchronously\" : \"\";\n-            \n-            AuthenticatedUser user = request.getAuthenticatedUser();\n-            DatasetLock lock = new DatasetLock(DatasetLock.Reason.finalizePublication, user);\n-            lock.setDataset(theDataset);\n-            lock.setInfo(info);\n-            ctxt.datasets().addDatasetLock(theDataset, lock);\n-            theDataset = ctxt.em().merge(theDataset);\n-            // The call to FinalizePublicationCommand has been moved to the new @onSuccess()\n-            // method:\n-            //ctxt.datasets().callFinalizePublishCommandAsynchronously(theDataset.getId(), ctxt, request, datasetExternallyReleased);\n-            return new PublishDatasetResult(theDataset, Status.Inprogress);\n-\n-            /**\n-              * Code for for \"synchronous\" (while-you-wait) publishing \n-              * is preserved below, commented out:\n-            } else {\n-                // Synchronous publishing (no workflow involved)\n-                theDataset = ctxt.engine().submit(new FinalizeDatasetPublicationCommand(theDataset, getRequest(),datasetExternallyReleased));\n-                return new PublishDatasetResult(theDataset, Status.Completed);\n-            } */\n-        }\n+    if (datasetExternallyReleased) {\n+      if (!getDataset().getLatestVersion().isReleased()) {\n+        throw new IllegalCommandException(\n+          \"Latest version of dataset \" + getDataset().getIdentifier() + \" is not marked as releasd.\", this);\n+      }\n+\n+    } else {\n+      if (getDataset().getLatestVersion().isReleased()) {\n+        throw new IllegalCommandException(\"Latest version of dataset \" + getDataset().getIdentifier() +\n+          \" is already released. Only draft versions can be released.\", this);\n+      }\n+\n+      // prevent publishing of 0.1 version\n+      if (minorRelease && getDataset().getVersions().size() == 1 && getDataset().getLatestVersion().isDraft()) {\n+        throw new IllegalCommandException(\"Cannot publish as minor version. Re-try as major release.\", this);\n+      }\n+\n+      if (minorRelease && !getDataset().getLatestVersion().isMinorUpdate()) {\n+        throw new IllegalCommandException(\"Cannot release as minor version. Re-try as major release.\", this);\n+      }\n     }\n-    \n-    /**\n-     * See that publishing the dataset in the requested manner makes sense, at\n-     * the given state of the dataset.\n-     * \n-     * @throws IllegalCommandException if the publication request is invalid.\n-     */\n-    private void verifyCommandArguments(CommandContext ctxt) throws IllegalCommandException {\n-        if (!getDataset().getOwner().isReleased()) {\n-            throw new IllegalCommandException(\"This dataset may not be published because its host dataverse (\" + getDataset().getOwner().getAlias() + \") has not been published.\", this);\n-        }\n-        \n-        if ( ! getUser().isAuthenticated() ) {\n-            throw new IllegalCommandException(\"Only authenticated users can release a Dataset. Please authenticate and try again.\", this);\n-        }\n-        \n-        if ( (getDataset().isLockedFor(DatasetLock.Reason.Workflow)&&!ctxt.permissions().isMatchingWorkflowLock(getDataset(),request.getUser().getIdentifier(),request.getWFInvocationId())) \n-                || getDataset().isLockedFor(DatasetLock.Reason.Ingest) \n-                || getDataset().isLockedFor(DatasetLock.Reason.finalizePublication)\n-                || getDataset().isLockedFor(DatasetLock.Reason.EditInProgress)) {\n-            throw new IllegalCommandException(\"This dataset is locked. Reason: \" \n-                    + getDataset().getLocks().stream().map(l -> l.getReason().name()).collect( joining(\",\") )\n-                    + \". Please try publishing later.\", this);\n-        }\n-        \n-        if ( getDataset().isLockedFor(DatasetLock.Reason.FileValidationFailed)) {\n-            throw new IllegalCommandException(\"This dataset cannot be published because some files have been found missing or corrupted. \" \n-                    + \". Please contact support to address this.\", this);\n-        }\n-        \n-        if ( datasetExternallyReleased ) {\n-            if ( ! getDataset().getLatestVersion().isReleased() ) {\n-                throw new IllegalCommandException(\"Latest version of dataset \" + getDataset().getIdentifier() + \" is not marked as releasd.\", this);\n-            }\n-                \n-        } else {\n-            if (getDataset().getLatestVersion().isReleased()) {\n-                throw new IllegalCommandException(\"Latest version of dataset \" + getDataset().getIdentifier() + \" is already released. Only draft versions can be released.\", this);\n-            }\n-\n-            // prevent publishing of 0.1 version\n-            if (minorRelease && getDataset().getVersions().size() == 1 && getDataset().getLatestVersion().isDraft()) {\n-                throw new IllegalCommandException(\"Cannot publish as minor version. Re-try as major release.\", this);\n-            }\n-\n-            if (minorRelease && !getDataset().getLatestVersion().isMinorUpdate()) {\n-                throw new IllegalCommandException(\"Cannot release as minor version. Re-try as major release.\", this);\n-            }\n-        }\n+  }\n+\n+\n+  @Override\n+  public boolean onSuccess(CommandContext ctxt, Object r) {\n+    Dataset dataset = null;\n+    try {\n+      dataset = (Dataset) r;\n+    } catch (ClassCastException e) {\n+      dataset = ((PublishDatasetResult) r).getDataset();\n     }\n-    \n-    \n-    @Override\n-    public boolean onSuccess(CommandContext ctxt, Object r) {\n-        Dataset dataset = null;\n-        try{\n-            dataset = (Dataset) r;\n-        } catch (ClassCastException e){\n-            dataset  = ((PublishDatasetResult) r).getDataset();\n-        }\n-\n-        if (dataset != null) {\n-            Optional<Workflow> prePubWf = ctxt.workflows().getDefaultWorkflow(TriggerType.PrePublishDataset);\n-            //A pre-publication workflow will call FinalizeDatasetPublicationCommand itself when it completes\n-            if (! prePubWf.isPresent() ) {\n-                logger.fine(\"From onSuccess, calling FinalizeDatasetPublicationCommand for dataset \" + dataset.getGlobalId().asString());\n-                ctxt.datasets().callFinalizePublishCommandAsynchronously(dataset.getId(), ctxt, request, datasetExternallyReleased);\n-            } \n-            return true;\n-        }\n-        \n-        return false;\n+\n+    if (dataset != null) {\n+      Optional<Workflow> prePubWf = ctxt.workflows().getDefaultWorkflow(TriggerType.PrePublishDataset);\n+      //A pre-publication workflow will call FinalizeDatasetPublicationCommand itself when it completes\n+      if (!prePubWf.isPresent()) {\n+        logger.fine(\n+          \"From onSuccess, calling FinalizeDatasetPublicationCommand for dataset \" + dataset.getGlobalId().asString());\n+        ctxt.datasets()\n+          .callFinalizePublishCommandAsynchronously(dataset.getId(), ctxt, request, datasetExternallyReleased);\n+      }\n+      return true;\n     }\n-    \n+\n+    return false;\n+  }\n+\n }\n",
            "diff_size": 335
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/32/PublishDatasetCommand.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/codebuff/32/PublishDatasetCommand.java\nindex f1bab1901d0..bd7b541ba81 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/32/PublishDatasetCommand.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/codebuff/32/PublishDatasetCommand.java\n@@ -34,8 +34,10 @@ import static edu.harvard.iq.dataverse.engine.command.impl.PublishDatasetResult.\n  * @author skraffmiller\n  * @author michbarsinai\n  */\n+\n @RequiredPermissions(Permission.PublishDataset)\n public class PublishDatasetCommand extends AbstractPublishDatasetCommand<PublishDatasetResult> {\n+\n     private static final Logger logger = Logger.getLogger(PublishDatasetCommand.class.getName());\n     boolean minorRelease;\n     DataverseRequest request;\n@@ -46,11 +48,11 @@ public class PublishDatasetCommand extends AbstractPublishDatasetCommand<Publish\n      * in scenarios like import or migration.\n      */\n     final boolean datasetExternallyReleased;\n-    \n+\n     public PublishDatasetCommand(Dataset datasetIn, DataverseRequest aRequest, boolean minor) {\n-        this( datasetIn, aRequest, minor, false );\n+        this(datasetIn, aRequest, minor, false);\n     }\n-    \n+\n     public PublishDatasetCommand(Dataset datasetIn, DataverseRequest aRequest, boolean minor, boolean isPidPrePublished) {\n         super(datasetIn, aRequest);\n         minorRelease = minor;\n@@ -60,13 +62,11 @@ public class PublishDatasetCommand extends AbstractPublishDatasetCommand<Publish\n \n     @Override\n     public PublishDatasetResult execute(CommandContext ctxt) throws CommandException {\n-        \n         verifyCommandArguments(ctxt);\n         \n         // Invariant 1: If we're here, publishing the dataset makes sense, from a \"business logic\" point of view.\n         // Invariant 2: The latest version of the dataset is the one being published, EVEN IF IT IS NOT DRAFT.\n         //              When importing a released dataset, the latest version is marked as RELEASED.\n-\n         Dataset theDataset = getDataset();\n \n         \n@@ -74,16 +74,13 @@ public class PublishDatasetCommand extends AbstractPublishDatasetCommand<Publish\n         //Changing the dataset in this transaction also potentially makes a race condition with a prepub workflow, possibly resulting in an OptimisticLockException there.\n         \n         // Set the version numbers:\n-\n         if (theDataset.getPublicationDate() == null) {\n             // First Release\n             theDataset.getLatestVersion().setVersionNumber(new Long(1)); // minor release is blocked by #verifyCommandArguments\n             theDataset.getLatestVersion().setMinorVersionNumber(new Long(0));\n-            \n-        } else if ( minorRelease ) {\n+        } else if (minorRelease) {\n             theDataset.getLatestVersion().setVersionNumber(new Long(theDataset.getVersionNumber()));\n             theDataset.getLatestVersion().setMinorVersionNumber(new Long(theDataset.getMinorVersionNumber() + 1));\n-            \n         } else {\n             // major, non-first release\n             theDataset.getLatestVersion().setVersionNumber(new Long(theDataset.getVersionNumber() + 1));\n@@ -91,15 +88,17 @@ public class PublishDatasetCommand extends AbstractPublishDatasetCommand<Publish\n         }\n         \n         //ToDo - should this be in onSuccess()? May relate to todo above \n+\n         Optional<Workflow> prePubWf = ctxt.workflows().getDefaultWorkflow(TriggerType.PrePublishDataset);\n-        if ( prePubWf.isPresent() ) {\n+        if (prePubWf.isPresent()) {\n             // We start a workflow\n             theDataset = ctxt.em().merge(theDataset);\n             ctxt.em().flush();\n-            ctxt.workflows().start(prePubWf.get(), buildContext(theDataset, TriggerType.PrePublishDataset, datasetExternallyReleased), true);\n+            ctxt.workflows().start(prePubWf.get(),\n+                                   buildContext(theDataset, TriggerType.PrePublishDataset, datasetExternallyReleased),\n+                true);\n             return new PublishDatasetResult(theDataset, Status.Workflow);\n-            \n-        } else{\n+        } else {\n             // We will skip trying to register the global identifiers for datafiles \n             // if \"dependent\" file-level identifiers are requested, AND the naming \n             // protocol of the dataset global id is different from the \n@@ -113,16 +112,13 @@ public class PublishDatasetCommand extends AbstractPublishDatasetCommand<Publish\n             // Additionaly in 4.9.3 we have added a system variable to disable \n             // registering file PIDs on the installation level.\n             String currentGlobalIdProtocol = ctxt.settings().getValueForKey(SettingsServiceBean.Key.Protocol, \"\");\n-            String currentGlobalAuthority= ctxt.settings().getValueForKey(SettingsServiceBean.Key.Authority, \"\");\n+            String currentGlobalAuthority = ctxt.settings().getValueForKey(SettingsServiceBean.Key.Authority, \"\");\n             String dataFilePIDFormat = ctxt.settings().getValueForKey(SettingsServiceBean.Key.DataFilePIDFormat, \"DEPENDENT\");\n-            boolean registerGlobalIdsForFiles = \n-                    (currentGlobalIdProtocol.equals(theDataset.getProtocol()) || dataFilePIDFormat.equals(\"INDEPENDENT\")) \n-                    && ctxt.systemConfig().isFilePIDsEnabled();\n-            \n-            if ( registerGlobalIdsForFiles ){\n-                registerGlobalIdsForFiles = currentGlobalAuthority.equals( theDataset.getAuthority() );\n-\t    }\n-            \n+            boolean registerGlobalIdsForFiles = (currentGlobalIdProtocol.equals(theDataset.getProtocol()) || dataFilePIDFormat.equals(\"INDEPENDENT\")) && ctxt.systemConfig().isFilePIDsEnabled();\n+            if (registerGlobalIdsForFiles) {\n+                registerGlobalIdsForFiles = currentGlobalAuthority.equals(theDataset.getAuthority());\n+            }\n+\n             boolean validatePhysicalFiles = ctxt.systemConfig().isDatafileValidationOnPublishEnabled();\n \n             // As of v5.0, publishing a dataset is always done asynchronously, \n@@ -130,11 +126,9 @@ public class PublishDatasetCommand extends AbstractPublishDatasetCommand<Publish\n             \n             //if ((registerGlobalIdsForFiles || validatePhysicalFiles) \n             //        && theDataset.getFiles().size() > ctxt.systemConfig().getPIDAsynchRegFileCount()) { \n-                \n-            String info = \"Publishing the dataset; \"; \n+            String info = \"Publishing the dataset; \";\n             info += registerGlobalIdsForFiles ? \"Registering PIDs for Datafiles; \" : \"\";\n             info += validatePhysicalFiles ? \"Validating Datafiles Asynchronously\" : \"\";\n-            \n             AuthenticatedUser user = request.getAuthenticatedUser();\n             DatasetLock lock = new DatasetLock(DatasetLock.Reason.finalizePublication, user);\n             lock.setDataset(theDataset);\n@@ -163,41 +157,38 @@ public class PublishDatasetCommand extends AbstractPublishDatasetCommand<Publish\n      * \n      * @throws IllegalCommandException if the publication request is invalid.\n      */\n+\n     private void verifyCommandArguments(CommandContext ctxt) throws IllegalCommandException {\n         if (!getDataset().getOwner().isReleased()) {\n             throw new IllegalCommandException(\"This dataset may not be published because its host dataverse (\" + getDataset().getOwner().getAlias() + \") has not been published.\", this);\n         }\n-        \n-        if ( ! getUser().isAuthenticated() ) {\n+\n+        if (!getUser().isAuthenticated()) {\n             throw new IllegalCommandException(\"Only authenticated users can release a Dataset. Please authenticate and try again.\", this);\n         }\n-        \n-        if ( (getDataset().isLockedFor(DatasetLock.Reason.Workflow)&&!ctxt.permissions().isMatchingWorkflowLock(getDataset(),request.getUser().getIdentifier(),request.getWFInvocationId())) \n-                || getDataset().isLockedFor(DatasetLock.Reason.Ingest) \n-                || getDataset().isLockedFor(DatasetLock.Reason.finalizePublication)\n-                || getDataset().isLockedFor(DatasetLock.Reason.EditInProgress)) {\n-            throw new IllegalCommandException(\"This dataset is locked. Reason: \" \n-                    + getDataset().getLocks().stream().map(l -> l.getReason().name()).collect( joining(\",\") )\n-                    + \". Please try publishing later.\", this);\n+\n+        if ((getDataset().isLockedFor(DatasetLock.Reason.Workflow) && !ctxt.permissions().isMatchingWorkflowLock(getDataset(), request.getUser().getIdentifier(), request.getWFInvocationId())) || getDataset().isLockedFor(DatasetLock.Reason.Ingest)\n+        || getDataset().isLockedFor(DatasetLock.Reason.finalizePublication) || getDataset().isLockedFor(DatasetLock.Reason.EditInProgress)) {\n+            throw new IllegalCommandException(\"This dataset is locked. Reason: \" + getDataset().getLocks().stream().map(l -> l.getReason().name()).collect(joining(\",\")) + \". Please try publishing later.\", this);\n         }\n-        \n-        if ( getDataset().isLockedFor(DatasetLock.Reason.FileValidationFailed)) {\n-            throw new IllegalCommandException(\"This dataset cannot be published because some files have been found missing or corrupted. \" \n-                    + \". Please contact support to address this.\", this);\n+\n+        if (getDataset().isLockedFor(DatasetLock.Reason.FileValidationFailed)) {\n+            throw new IllegalCommandException(\"This dataset cannot be published because some files have been found missing or corrupted. \" + \". Please contact support to address this.\", this);\n         }\n-        \n-        if ( datasetExternallyReleased ) {\n-            if ( ! getDataset().getLatestVersion().isReleased() ) {\n+\n+        if (datasetExternallyReleased) {\n+            if (!getDataset().getLatestVersion().isReleased()) {\n                 throw new IllegalCommandException(\"Latest version of dataset \" + getDataset().getIdentifier() + \" is not marked as releasd.\", this);\n             }\n-                \n         } else {\n             if (getDataset().getLatestVersion().isReleased()) {\n                 throw new IllegalCommandException(\"Latest version of dataset \" + getDataset().getIdentifier() + \" is already released. Only draft versions can be released.\", this);\n             }\n \n             // prevent publishing of 0.1 version\n-            if (minorRelease && getDataset().getVersions().size() == 1 && getDataset().getLatestVersion().isDraft()) {\n+\n+            if (minorRelease\n+                    && getDataset().getVersions().size() == 1 && getDataset().getLatestVersion().isDraft()) {\n                 throw new IllegalCommandException(\"Cannot publish as minor version. Re-try as major release.\", this);\n             }\n \n@@ -206,28 +197,26 @@ public class PublishDatasetCommand extends AbstractPublishDatasetCommand<Publish\n             }\n         }\n     }\n-    \n-    \n+\n     @Override\n     public boolean onSuccess(CommandContext ctxt, Object r) {\n         Dataset dataset = null;\n-        try{\n+        try {\n             dataset = (Dataset) r;\n-        } catch (ClassCastException e){\n-            dataset  = ((PublishDatasetResult) r).getDataset();\n+        } catch (ClassCastException e) {\n+            dataset = ((PublishDatasetResult) r).getDataset();\n         }\n \n         if (dataset != null) {\n             Optional<Workflow> prePubWf = ctxt.workflows().getDefaultWorkflow(TriggerType.PrePublishDataset);\n             //A pre-publication workflow will call FinalizeDatasetPublicationCommand itself when it completes\n-            if (! prePubWf.isPresent() ) {\n+            if (!prePubWf.isPresent()) {\n                 logger.fine(\"From onSuccess, calling FinalizeDatasetPublicationCommand for dataset \" + dataset.getGlobalId().asString());\n                 ctxt.datasets().callFinalizePublishCommandAsynchronously(dataset.getId(), ctxt, request, datasetExternallyReleased);\n-            } \n+            }\n             return true;\n         }\n-        \n         return false;\n     }\n-    \n-}\n+\n+}\n\\ No newline at end of file\n",
            "diff_size": 62
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/32/PublishDatasetCommand.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_random/32/PublishDatasetCommand.java\nindex f1bab1901d0..a641b0195d1 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/32/PublishDatasetCommand.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_random/32/PublishDatasetCommand.java\n@@ -121,9 +121,8 @@ public class PublishDatasetCommand extends AbstractPublishDatasetCommand<Publish\n             \n             if ( registerGlobalIdsForFiles ){\n                 registerGlobalIdsForFiles = currentGlobalAuthority.equals( theDataset.getAuthority() );\n-\t    }\n-            \n-            boolean validatePhysicalFiles = ctxt.systemConfig().isDatafileValidationOnPublishEnabled();\n+            }\n+                boolean validatePhysicalFiles = ctxt.systemConfig().isDatafileValidationOnPublishEnabled();\n \n             // As of v5.0, publishing a dataset is always done asynchronously, \n             // with the dataset locked for the duration of the operation. \n",
            "diff_size": 3
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/32/PublishDatasetCommand.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_three_grams/32/PublishDatasetCommand.java\nindex f1bab1901d0..e19eae7a025 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/32/PublishDatasetCommand.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_three_grams/32/PublishDatasetCommand.java\n@@ -121,9 +121,9 @@ public class PublishDatasetCommand extends AbstractPublishDatasetCommand<Publish\n             \n             if ( registerGlobalIdsForFiles ){\n                 registerGlobalIdsForFiles = currentGlobalAuthority.equals( theDataset.getAuthority() );\n-\t    }\n-            \n-            boolean validatePhysicalFiles = ctxt.systemConfig().isDatafileValidationOnPublishEnabled();\n+            }\n+\n+                boolean validatePhysicalFiles = ctxt.systemConfig().isDatafileValidationOnPublishEnabled();\n \n             // As of v5.0, publishing a dataset is always done asynchronously, \n             // with the dataset locked for the duration of the operation. \n",
            "diff_size": 3
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "naturalize"
    ]
}