{
    "project_name": "NationalSecurityAgency-datawave",
    "error_id": "79",
    "information": {
        "errors": [
            {
                "line": "10",
                "severity": "error",
                "message": "Accumulo non-public classes imported",
                "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
            }
        ]
    },
    "source_code": "import datawave.webservice.query.logic.QueryLogic;\nimport org.apache.accumulo.core.client.Connector;\nimport org.apache.accumulo.core.util.Pair;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.apache.deltaspike.core.api.exclude.Exclude;\nimport org.apache.log4j.Logger;",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "10",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "10",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/79/CreatedQueryLogicCacheBean.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/intellij/79/CreatedQueryLogicCacheBean.java\nindex aa63f2ab1e8..f6a0c2a8806 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/79/CreatedQueryLogicCacheBean.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/intellij/79/CreatedQueryLogicCacheBean.java\n@@ -35,176 +35,178 @@ import java.util.concurrent.ConcurrentHashMap;\n @LocalBean\n @Exclude(ifProjectStage = DatawaveEmbeddedProjectStageHolder.DatawaveEmbedded.class)\n public class CreatedQueryLogicCacheBean {\n-    \n-    public static class Triple {\n-        final String userID;\n-        final QueryLogic<?> logic;\n-        final Connector cxn;\n-        \n-        public Triple(String userID, QueryLogic<?> logic, Connector cxn) {\n-            super();\n-            this.userID = userID;\n-            this.logic = logic;\n-            this.cxn = cxn;\n-        }\n-        \n-        @Override\n-        public int hashCode() {\n-            return ((new HashCodeBuilder()).append(userID).append(logic).append(cxn)).toHashCode();\n-        }\n-        \n-        @Override\n-        public boolean equals(Object o) {\n-            if (o instanceof Triple) {\n-                Triple other = (Triple) o;\n-                return other.userID.equals(this.userID) && other.logic.equals(this.logic) && other.cxn.equals(this.cxn);\n-            }\n-            \n-            return false;\n-        }\n+\n+  public static class Triple {\n+    final String userID;\n+    final QueryLogic<?> logic;\n+    final Connector cxn;\n+\n+    public Triple(String userID, QueryLogic<?> logic, Connector cxn) {\n+      super();\n+      this.userID = userID;\n+      this.logic = logic;\n+      this.cxn = cxn;\n     }\n-    \n-    private static final Function<Triple,Pair<QueryLogic<?>,Connector>> tripToPair = from -> {\n-        if (null == from) {\n-            return null;\n-        }\n-        return new Pair<>(from.logic, from.cxn);\n-    };\n-    \n-    // returns the logic and connection fields in a triple as a pair\n-    private static final Function<Entry<Pair<String,Long>,Triple>,Entry<String,Pair<QueryLogic<?>,Connector>>> toPair = from -> {\n-        if (from == null) {\n-            return null;\n-        } else {\n-            return Maps.immutableEntry(from.getKey().getFirst(), tripToPair.apply(from.getValue()));\n-        }\n-    };\n-    \n-    private static final Logger log = Logger.getLogger(CreatedQueryLogicCacheBean.class);\n-    \n-    @Inject\n-    private AccumuloConnectionFactory connectionFactory;\n-    private final ConcurrentHashMap<Pair<String,Long>,Triple> cache = new ConcurrentHashMap<>();\n-    \n-    /**\n-     * Add the provided QueryLogic to the QueryLogicCache.\n-     * \n-     * @param queryId\n-     * @param userId\n-     * @param logic\n-     * @param cxn\n-     * @return true if there was no previous mapping for the given queryId in the cache.\n-     */\n-    public boolean add(String queryId, String userId, QueryLogic<?> logic, Connector cxn) {\n-        Triple value = new Triple(userId, logic, cxn);\n-        long updateTime = System.currentTimeMillis();\n-        return cache.putIfAbsent(new Pair<>(queryId, updateTime), value) == null;\n+\n+    @Override\n+    public int hashCode() {\n+      return ((new HashCodeBuilder()).append(userID).append(logic).append(cxn)).toHashCode();\n     }\n-    \n-    public Pair<QueryLogic<?>,Connector> poll(String id) {\n-        Entry<Pair<String,Long>,Triple> entry = get(id);\n-        return entry == null ? null : tripToPair.apply(entry.getValue());\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (o instanceof Triple) {\n+        Triple other = (Triple) o;\n+        return other.userID.equals(this.userID) && other.logic.equals(this.logic) && other.cxn.equals(this.cxn);\n+      }\n+\n+      return false;\n     }\n-    \n-    public Map<String,Pair<QueryLogic<?>,Connector>> snapshot() {\n-        HashMap<Pair<String,Long>,Triple> snapshot = Maps.newHashMap(cache);\n-        HashMap<String,Pair<QueryLogic<?>,Connector>> tformMap = Maps.newHashMapWithExpectedSize(cache.size());\n-        \n-        for (Entry<String,Pair<QueryLogic<?>,Connector>> tform : Iterables.transform(snapshot.entrySet(), toPair)) {\n-            tformMap.put(tform.getKey(), tform.getValue());\n-        }\n-        return tformMap;\n+  }\n+\n+  private static final Function<Triple, Pair<QueryLogic<?>, Connector>> tripToPair = from -> {\n+    if (null == from) {\n+      return null;\n     }\n-    \n-    public Map<String,Pair<QueryLogic<?>,Connector>> entriesOlderThan(final Long now, final Long expiration) {\n-        Iterable<Entry<Pair<String,Long>,Triple>> iter = Iterables.filter(cache.entrySet(), input -> {\n-            Long timeInserted = input.getKey().getSecond();\n-            \n-            // If this entry was inserted more than the TTL 'time' ago, do not return it\n-                        if ((now - expiration) > timeInserted) {\n-                            return true;\n-                        }\n-                        \n-                        return false;\n-                    });\n-        \n-        Map<String,Pair<QueryLogic<?>,Connector>> result = Maps.newHashMapWithExpectedSize(32);\n-        for (Entry<Pair<String,Long>,Triple> entry : iter) {\n-            result.put(entry.getKey().getFirst(), tripToPair.apply(entry.getValue()));\n-        }\n-        \n-        return result;\n+    return new Pair<>(from.logic, from.cxn);\n+  };\n+\n+  // returns the logic and connection fields in a triple as a pair\n+  private static final Function<Entry<Pair<String, Long>, Triple>, Entry<String, Pair<QueryLogic<?>, Connector>>>\n+      toPair = from -> {\n+    if (from == null) {\n+      return null;\n+    } else {\n+      return Maps.immutableEntry(from.getKey().getFirst(), tripToPair.apply(from.getValue()));\n     }\n-    \n-    public Pair<QueryLogic<?>,Connector> pollIfOwnedBy(String queryId, String userId) {\n-        Entry<Pair<String,Long>,Triple> entry = get(queryId);\n-        if (entry != null) {\n-            if (userId.equals(entry.getValue().userID)) {\n-                return tripToPair.apply(entry.getValue());\n-            } else {\n-                cache.put(entry.getKey(), entry.getValue());\n-            }\n-        }\n-        \n-        return null;\n+  };\n+\n+  private static final Logger log = Logger.getLogger(CreatedQueryLogicCacheBean.class);\n+\n+  @Inject\n+  private AccumuloConnectionFactory connectionFactory;\n+  private final ConcurrentHashMap<Pair<String, Long>, Triple> cache = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Add the provided QueryLogic to the QueryLogicCache.\n+   *\n+   * @param queryId\n+   * @param userId\n+   * @param logic\n+   * @param cxn\n+   * @return true if there was no previous mapping for the given queryId in the cache.\n+   */\n+  public boolean add(String queryId, String userId, QueryLogic<?> logic, Connector cxn) {\n+    Triple value = new Triple(userId, logic, cxn);\n+    long updateTime = System.currentTimeMillis();\n+    return cache.putIfAbsent(new Pair<>(queryId, updateTime), value) == null;\n+  }\n+\n+  public Pair<QueryLogic<?>, Connector> poll(String id) {\n+    Entry<Pair<String, Long>, Triple> entry = get(id);\n+    return entry == null ? null : tripToPair.apply(entry.getValue());\n+  }\n+\n+  public Map<String, Pair<QueryLogic<?>, Connector>> snapshot() {\n+    HashMap<Pair<String, Long>, Triple> snapshot = Maps.newHashMap(cache);\n+    HashMap<String, Pair<QueryLogic<?>, Connector>> tformMap = Maps.newHashMapWithExpectedSize(cache.size());\n+\n+    for (Entry<String, Pair<QueryLogic<?>, Connector>> tform : Iterables.transform(snapshot.entrySet(), toPair)) {\n+      tformMap.put(tform.getKey(), tform.getValue());\n     }\n-    \n-    public void clearQueryLogics(long currentTimeMs, long timeToLiveMs) {\n-        Set<Entry<String,Pair<QueryLogic<?>,Connector>>> entrySet = entriesOlderThan(currentTimeMs, timeToLiveMs).entrySet();\n-        clearQueryLogics(entrySet);\n+    return tformMap;\n+  }\n+\n+  public Map<String, Pair<QueryLogic<?>, Connector>> entriesOlderThan(final Long now, final Long expiration) {\n+    Iterable<Entry<Pair<String, Long>, Triple>> iter = Iterables.filter(cache.entrySet(), input -> {\n+      Long timeInserted = input.getKey().getSecond();\n+\n+      // If this entry was inserted more than the TTL 'time' ago, do not return it\n+      if ((now - expiration) > timeInserted) {\n+        return true;\n+      }\n+\n+      return false;\n+    });\n+\n+    Map<String, Pair<QueryLogic<?>, Connector>> result = Maps.newHashMapWithExpectedSize(32);\n+    for (Entry<Pair<String, Long>, Triple> entry : iter) {\n+      result.put(entry.getKey().getFirst(), tripToPair.apply(entry.getValue()));\n     }\n-    \n-    private void clearQueryLogics(Set<Entry<String,Pair<QueryLogic<?>,Connector>>> entrySet) {\n-        int count = 0;\n-        for (Entry<String,Pair<QueryLogic<?>,Connector>> entry : entrySet) {\n-            Pair<QueryLogic<?>,Connector> activePair = poll(entry.getKey());\n-            \n-            if (activePair == null) {\n-                if (log.isDebugEnabled()) {\n-                    log.debug(\"Could not find identified pair needing qlCache eviction. Someone removed him from underneath us\");\n-                }\n-                continue;\n-            }\n-            \n-            try {\n-                activePair.getFirst().close();\n-            } catch (Exception ex) {\n-                log.error(\"Exception caught while closing an uninitialized query logic.\", ex);\n-            }\n-            \n-            try {\n-                connectionFactory.returnConnection(activePair.getSecond());\n-            } catch (Exception ex) {\n-                log.error(\"Could not return connection from: \" + entry.getKey() + \" - \" + activePair, ex);\n-            }\n-            \n-            count++;\n-        }\n-        \n-        if (count > 0 && log.isDebugEnabled()) {\n-            log.debug(count + \" entries evicted from the query logic cache.\");\n+\n+    return result;\n+  }\n+\n+  public Pair<QueryLogic<?>, Connector> pollIfOwnedBy(String queryId, String userId) {\n+    Entry<Pair<String, Long>, Triple> entry = get(queryId);\n+    if (entry != null) {\n+      if (userId.equals(entry.getValue().userID)) {\n+        return tripToPair.apply(entry.getValue());\n+      } else {\n+        cache.put(entry.getKey(), entry.getValue());\n+      }\n+    }\n+\n+    return null;\n+  }\n+\n+  public void clearQueryLogics(long currentTimeMs, long timeToLiveMs) {\n+    Set<Entry<String, Pair<QueryLogic<?>, Connector>>> entrySet =\n+        entriesOlderThan(currentTimeMs, timeToLiveMs).entrySet();\n+    clearQueryLogics(entrySet);\n+  }\n+\n+  private void clearQueryLogics(Set<Entry<String, Pair<QueryLogic<?>, Connector>>> entrySet) {\n+    int count = 0;\n+    for (Entry<String, Pair<QueryLogic<?>, Connector>> entry : entrySet) {\n+      Pair<QueryLogic<?>, Connector> activePair = poll(entry.getKey());\n+\n+      if (activePair == null) {\n+        if (log.isDebugEnabled()) {\n+          log.debug(\"Could not find identified pair needing qlCache eviction. Someone removed him from underneath us\");\n         }\n+        continue;\n+      }\n+\n+      try {\n+        activePair.getFirst().close();\n+      } catch (Exception ex) {\n+        log.error(\"Exception caught while closing an uninitialized query logic.\", ex);\n+      }\n+\n+      try {\n+        connectionFactory.returnConnection(activePair.getSecond());\n+      } catch (Exception ex) {\n+        log.error(\"Could not return connection from: \" + entry.getKey() + \" - \" + activePair, ex);\n+      }\n+\n+      count++;\n     }\n-    \n-    @PreDestroy\n-    public void shutdown() {\n-        clearQueryLogics(snapshot().entrySet());\n+\n+    if (count > 0 && log.isDebugEnabled()) {\n+      log.debug(count + \" entries evicted from the query logic cache.\");\n     }\n-    \n-    /**\n-     * Finds and entry in the underlying cache with the given queryId. Returns null if no such element in the map is found. Will only return the\n-     * arbitrarily-found 'first' entry as we shouldn't have such a collision in the first place\n-     * \n-     * @param queryId\n-     * @return\n-     */\n-    private Entry<Pair<String,Long>,Triple> get(String queryId) {\n-        for (Pair<String,Long> key : cache.keySet()) {\n-            if (key.getFirst().equals(queryId)) {\n-                return Maps.immutableEntry(key, cache.remove(key));\n-            }\n-        }\n-        \n-        return null;\n+  }\n+\n+  @PreDestroy\n+  public void shutdown() {\n+    clearQueryLogics(snapshot().entrySet());\n+  }\n+\n+  /**\n+   * Finds and entry in the underlying cache with the given queryId. Returns null if no such element in the map is found. Will only return the\n+   * arbitrarily-found 'first' entry as we shouldn't have such a collision in the first place\n+   *\n+   * @param queryId\n+   * @return\n+   */\n+  private Entry<Pair<String, Long>, Triple> get(String queryId) {\n+    for (Pair<String, Long> key : cache.keySet()) {\n+      if (key.getFirst().equals(queryId)) {\n+        return Maps.immutableEntry(key, cache.remove(key));\n+      }\n     }\n+\n+    return null;\n+  }\n }\n",
            "diff_size": 225
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "10",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/79/CreatedQueryLogicCacheBean.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/naturalize/79/CreatedQueryLogicCacheBean.java\nindex aa63f2ab1e8..89c33c91e5d 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/79/CreatedQueryLogicCacheBean.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/naturalize/79/CreatedQueryLogicCacheBean.java\n@@ -207,4 +207,4 @@ public class CreatedQueryLogicCacheBean {\n         \n         return null;\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 1
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "10",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/79/CreatedQueryLogicCacheBean.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/codebuff/79/CreatedQueryLogicCacheBean.java\nindex aa63f2ab1e8..c2e66b53ca0 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/79/CreatedQueryLogicCacheBean.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/codebuff/79/CreatedQueryLogicCacheBean.java\n@@ -11,7 +11,6 @@ import org.apache.accumulo.core.util.Pair;\n import org.apache.commons.lang.builder.HashCodeBuilder;\n import org.apache.deltaspike.core.api.exclude.Exclude;\n import org.apache.log4j.Logger;\n-\n import javax.annotation.PreDestroy;\n import javax.annotation.security.PermitAll;\n import javax.annotation.security.RunAs;\n@@ -35,35 +34,35 @@ import java.util.concurrent.ConcurrentHashMap;\n @LocalBean\n @Exclude(ifProjectStage = DatawaveEmbeddedProjectStageHolder.DatawaveEmbedded.class)\n public class CreatedQueryLogicCacheBean {\n-    \n     public static class Triple {\n         final String userID;\n+\n         final QueryLogic<?> logic;\n+\n         final Connector cxn;\n-        \n+\n         public Triple(String userID, QueryLogic<?> logic, Connector cxn) {\n             super();\n             this.userID = userID;\n             this.logic = logic;\n             this.cxn = cxn;\n         }\n-        \n+\n         @Override\n         public int hashCode() {\n             return ((new HashCodeBuilder()).append(userID).append(logic).append(cxn)).toHashCode();\n         }\n-        \n+\n         @Override\n         public boolean equals(Object o) {\n             if (o instanceof Triple) {\n                 Triple other = (Triple) o;\n                 return other.userID.equals(this.userID) && other.logic.equals(this.logic) && other.cxn.equals(this.cxn);\n             }\n-            \n             return false;\n         }\n     }\n-    \n+\n     private static final Function<Triple,Pair<QueryLogic<?>,Connector>> tripToPair = from -> {\n         if (null == from) {\n             return null;\n@@ -79,9 +78,8 @@ public class CreatedQueryLogicCacheBean {\n             return Maps.immutableEntry(from.getKey().getFirst(), tripToPair.apply(from.getValue()));\n         }\n     };\n-    \n     private static final Logger log = Logger.getLogger(CreatedQueryLogicCacheBean.class);\n-    \n+\n     @Inject\n     private AccumuloConnectionFactory connectionFactory;\n     private final ConcurrentHashMap<Pair<String,Long>,Triple> cache = new ConcurrentHashMap<>();\n@@ -95,47 +93,45 @@ public class CreatedQueryLogicCacheBean {\n      * @param cxn\n      * @return true if there was no previous mapping for the given queryId in the cache.\n      */\n+\n     public boolean add(String queryId, String userId, QueryLogic<?> logic, Connector cxn) {\n         Triple value = new Triple(userId, logic, cxn);\n         long updateTime = System.currentTimeMillis();\n         return cache.putIfAbsent(new Pair<>(queryId, updateTime), value) == null;\n     }\n-    \n+\n     public Pair<QueryLogic<?>,Connector> poll(String id) {\n         Entry<Pair<String,Long>,Triple> entry = get(id);\n         return entry == null ? null : tripToPair.apply(entry.getValue());\n     }\n-    \n+\n     public Map<String,Pair<QueryLogic<?>,Connector>> snapshot() {\n         HashMap<Pair<String,Long>,Triple> snapshot = Maps.newHashMap(cache);\n         HashMap<String,Pair<QueryLogic<?>,Connector>> tformMap = Maps.newHashMapWithExpectedSize(cache.size());\n-        \n         for (Entry<String,Pair<QueryLogic<?>,Connector>> tform : Iterables.transform(snapshot.entrySet(), toPair)) {\n             tformMap.put(tform.getKey(), tform.getValue());\n         }\n         return tformMap;\n     }\n-    \n+\n     public Map<String,Pair<QueryLogic<?>,Connector>> entriesOlderThan(final Long now, final Long expiration) {\n-        Iterable<Entry<Pair<String,Long>,Triple>> iter = Iterables.filter(cache.entrySet(), input -> {\n-            Long timeInserted = input.getKey().getSecond();\n+        Iterable<Entry<Pair<String,Long>,Triple>> iter = Iterables.filter(cache.entrySet(),\n+            input -> {\n+                                                             Long timeInserted = input.getKey().getSecond();\n             \n             // If this entry was inserted more than the TTL 'time' ago, do not return it\n-                        if ((now - expiration) > timeInserted) {\n-                            return true;\n-                        }\n-                        \n-                        return false;\n-                    });\n-        \n+                                                             if ((now - expiration) > timeInserted) {\n+                                                                 return true;\n+                                                             }\n+                                                             return false;\n+                                                         });\n         Map<String,Pair<QueryLogic<?>,Connector>> result = Maps.newHashMapWithExpectedSize(32);\n         for (Entry<Pair<String,Long>,Triple> entry : iter) {\n             result.put(entry.getKey().getFirst(), tripToPair.apply(entry.getValue()));\n         }\n-        \n         return result;\n     }\n-    \n+\n     public Pair<QueryLogic<?>,Connector> pollIfOwnedBy(String queryId, String userId) {\n         Entry<Pair<String,Long>,Triple> entry = get(queryId);\n         if (entry != null) {\n@@ -145,47 +141,45 @@ public class CreatedQueryLogicCacheBean {\n                 cache.put(entry.getKey(), entry.getValue());\n             }\n         }\n-        \n         return null;\n     }\n-    \n+\n     public void clearQueryLogics(long currentTimeMs, long timeToLiveMs) {\n         Set<Entry<String,Pair<QueryLogic<?>,Connector>>> entrySet = entriesOlderThan(currentTimeMs, timeToLiveMs).entrySet();\n         clearQueryLogics(entrySet);\n     }\n-    \n+\n     private void clearQueryLogics(Set<Entry<String,Pair<QueryLogic<?>,Connector>>> entrySet) {\n         int count = 0;\n         for (Entry<String,Pair<QueryLogic<?>,Connector>> entry : entrySet) {\n             Pair<QueryLogic<?>,Connector> activePair = poll(entry.getKey());\n-            \n             if (activePair == null) {\n                 if (log.isDebugEnabled()) {\n                     log.debug(\"Could not find identified pair needing qlCache eviction. Someone removed him from underneath us\");\n                 }\n                 continue;\n             }\n-            \n+\n             try {\n                 activePair.getFirst().close();\n             } catch (Exception ex) {\n                 log.error(\"Exception caught while closing an uninitialized query logic.\", ex);\n             }\n-            \n+\n             try {\n                 connectionFactory.returnConnection(activePair.getSecond());\n             } catch (Exception ex) {\n                 log.error(\"Could not return connection from: \" + entry.getKey() + \" - \" + activePair, ex);\n             }\n-            \n             count++;\n         }\n-        \n+\n+\n         if (count > 0 && log.isDebugEnabled()) {\n             log.debug(count + \" entries evicted from the query logic cache.\");\n         }\n     }\n-    \n+\n     @PreDestroy\n     public void shutdown() {\n         clearQueryLogics(snapshot().entrySet());\n@@ -198,13 +192,13 @@ public class CreatedQueryLogicCacheBean {\n      * @param queryId\n      * @return\n      */\n+\n     private Entry<Pair<String,Long>,Triple> get(String queryId) {\n         for (Pair<String,Long> key : cache.keySet()) {\n             if (key.getFirst().equals(queryId)) {\n                 return Maps.immutableEntry(key, cache.remove(key));\n             }\n         }\n-        \n         return null;\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 41
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "10",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "10",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ],
    "repaired_by": [],
    "not_repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}