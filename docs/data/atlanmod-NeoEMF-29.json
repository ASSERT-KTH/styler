{
    "project_name": "atlanmod-NeoEMF",
    "error_id": "29",
    "information": {
        "errors": [
            {
                "line": "56",
                "severity": "warning",
                "message": "'lambda arguments' has incorrect indentation level 12, expected level should be 8.",
                "source": "com.puppycrawl.tools.checkstyle.checks.indentation.IndentationCheck"
            }
        ]
    },
    "source_code": "    protected static final Converter<Id, Object> ID_CONVERTER = Converter.from(\n            Id::toLong,\n            o -> Id.getProvider().fromLong(Long.class.cast(o)));\n\n    /**\n     * The property key used to define the index of an edge.",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "56",
                    "severity": "warning",
                    "message": "'lambda arguments' has incorrect indentation level 12, expected level should be 8.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.IndentationCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/atlanmod-NeoEMF/errored/1/29/AbstractBlueprintsBackend.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/atlanmod-NeoEMF/intellij/29/AbstractBlueprintsBackend.java\nindex a46d925f923..ce76b055e74 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/atlanmod-NeoEMF/errored/1/29/AbstractBlueprintsBackend.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/atlanmod-NeoEMF/intellij/29/AbstractBlueprintsBackend.java\n@@ -52,8 +52,8 @@ abstract class AbstractBlueprintsBackend extends AbstractPersistentBackend imple\n      */\n     @Nonnull\n     protected static final Converter<Id, Object> ID_CONVERTER = Converter.from(\n-            Id::toLong,\n-            o -> Id.getProvider().fromLong(Long.class.cast(o)));\n+        Id::toLong,\n+        o -> Id.getProvider().fromLong(Long.class.cast(o)));\n \n     /**\n      * The property key used to define the index of an edge.\n@@ -100,8 +100,8 @@ abstract class AbstractBlueprintsBackend extends AbstractPersistentBackend imple\n      */\n     @Nonnull\n     private final Cache<Id, Vertex> verticesCache = CacheBuilder.builder()\n-            .softValues()\n-            .build();\n+        .softValues()\n+        .build();\n \n     /**\n      * A set that holds indexed {@link ClassBean}.\n@@ -128,7 +128,6 @@ abstract class AbstractBlueprintsBackend extends AbstractPersistentBackend imple\n      * Constructs a new {@code AbstractBlueprintsBackend} wrapping the provided {@code baseGraph}.\n      *\n      * @param baseGraph the base {@link KeyIndexableGraph} used to access the database\n-     *\n      * @see BlueprintsBackendFactory\n      */\n     protected AbstractBlueprintsBackend(KeyIndexableGraph baseGraph) {\n@@ -144,7 +143,6 @@ abstract class AbstractBlueprintsBackend extends AbstractPersistentBackend imple\n      * Builds the {@link Id} used to identify a {@link ClassBean} {@link Vertex}.\n      *\n      * @param metaClass the {@link ClassBean} to build an {@link Id} from\n-     *\n      * @return the create {@link Id}\n      */\n     @Nonnull\n@@ -157,7 +155,6 @@ abstract class AbstractBlueprintsBackend extends AbstractPersistentBackend imple\n      *\n      * @param prefix the prefix of the property\n      * @param suffix the suffix of the property\n-     *\n      * @return the formatted property\n      */\n     @Nonnull\n@@ -169,7 +166,6 @@ abstract class AbstractBlueprintsBackend extends AbstractPersistentBackend imple\n      * Formats a label.\n      *\n      * @param label the label to format\n-     *\n      * @return the formatted label\n      */\n     @Nonnull\n@@ -181,21 +177,19 @@ abstract class AbstractBlueprintsBackend extends AbstractPersistentBackend imple\n      * Retrieves or create an index for the given {@code name}.\n      *\n      * @param name the name of the index\n-     *\n      * @return the index\n      */\n     @Nonnull\n     private Index<Vertex> getOrCreateIndex(String name) {\n         return Optional.ofNullable(graph.getIndex(name, Vertex.class))\n-                .orElseGet(() -> graph.createIndex(name, Vertex.class));\n+            .orElseGet(() -> graph.createIndex(name, Vertex.class));\n     }\n \n     @Override\n     public void save() {\n         if (graph.getFeatures().supportsTransactions) {\n             graph.commit();\n-        }\n-        else {\n+        } else {\n             graph.shutdown();\n         }\n     }\n@@ -209,8 +203,7 @@ abstract class AbstractBlueprintsBackend extends AbstractPersistentBackend imple\n     protected void innerClose() {\n         try {\n             graph.shutdown();\n-        }\n-        catch (Exception ignored) {\n+        } catch (Exception ignored) {\n         }\n     }\n \n@@ -239,15 +232,15 @@ abstract class AbstractBlueprintsBackend extends AbstractPersistentBackend imple\n         }\n \n         Iterable<Edge> edges = containmentVertex.get().query()\n-                .labels(KEY_CONTAINER)\n-                .direction(Direction.OUT)\n-                .limit(1)\n-                .edges();\n+            .labels(KEY_CONTAINER)\n+            .direction(Direction.OUT)\n+            .limit(1)\n+            .edges();\n \n         return MoreIterables.onlyElement(edges)\n-                .map(e -> SingleFeatureBean.of(\n-                        ID_CONVERTER.revert(e.getVertex(Direction.IN).getId()),\n-                        e.getProperty(KEY_CONTAINING_FEATURE)));\n+            .map(e -> SingleFeatureBean.of(\n+                ID_CONVERTER.revert(e.getVertex(Direction.IN).getId()),\n+                e.getProperty(KEY_CONTAINING_FEATURE)));\n     }\n \n     @Override\n@@ -259,10 +252,10 @@ abstract class AbstractBlueprintsBackend extends AbstractPersistentBackend imple\n         Vertex containerVertex = getOrCreate(container.owner());\n \n         Iterable<Edge> containmentEdges = containmentVertex.query()\n-                .labels(KEY_CONTAINER)\n-                .direction(Direction.OUT)\n-                .limit(1)\n-                .edges();\n+            .labels(KEY_CONTAINER)\n+            .direction(Direction.OUT)\n+            .limit(1)\n+            .edges();\n \n         containmentEdges.forEach(Edge::remove);\n \n@@ -281,10 +274,10 @@ abstract class AbstractBlueprintsBackend extends AbstractPersistentBackend imple\n         }\n \n         Iterable<Edge> containmentEdges = containmentVertex.get().query()\n-                .labels(KEY_CONTAINER)\n-                .direction(Direction.OUT)\n-                .limit(1)\n-                .edges();\n+            .labels(KEY_CONTAINER)\n+            .direction(Direction.OUT)\n+            .limit(1)\n+            .edges();\n \n         containmentEdges.forEach(Edge::remove);\n     }\n@@ -301,15 +294,15 @@ abstract class AbstractBlueprintsBackend extends AbstractPersistentBackend imple\n         }\n \n         Iterable<Vertex> metaClassVertices = vertex.get().query()\n-                .labels(KEY_INSTANCE_OF)\n-                .direction(Direction.OUT)\n-                .limit(1)\n-                .vertices();\n+            .labels(KEY_INSTANCE_OF)\n+            .direction(Direction.OUT)\n+            .limit(1)\n+            .vertices();\n \n         return MoreIterables.onlyElement(metaClassVertices)\n-                .map(v -> ClassBean.of(\n-                        v.getProperty(KEY_NAME),\n-                        v.getProperty(KEY_NS_URI)));\n+            .map(v -> ClassBean.of(\n+                v.getProperty(KEY_NAME),\n+                v.getProperty(KEY_NS_URI)));\n     }\n \n     @Override\n@@ -321,10 +314,10 @@ abstract class AbstractBlueprintsBackend extends AbstractPersistentBackend imple\n \n         // Check the presence of a meta-class\n         Iterable<Edge> instanceEdges = vertex.query()\n-                .labels(KEY_INSTANCE_OF)\n-                .direction(Direction.OUT)\n-                .limit(1)\n-                .edges();\n+            .labels(KEY_INSTANCE_OF)\n+            .direction(Direction.OUT)\n+            .limit(1)\n+            .edges();\n \n         if (MoreIterables.onlyElement(instanceEdges).isPresent()) {\n             return false;\n@@ -354,19 +347,18 @@ abstract class AbstractBlueprintsBackend extends AbstractPersistentBackend imple\n     @Override\n     public Iterable<Id> allInstancesOf(Set<ClassBean> metaClasses) {\n         return metaClasses.stream()\n-                .map(mc -> metaClassIndex.get(KEY_NAME, mc.name()))\n-                .flatMap(MoreIterables::stream)\n-                .map(mcv -> mcv.getVertices(Direction.IN, KEY_INSTANCE_OF))\n-                .flatMap(MoreIterables::stream)\n-                .map(v -> ID_CONVERTER.revert(v.getId()))\n-                .collect(Collectors.toSet());\n+            .map(mc -> metaClassIndex.get(KEY_NAME, mc.name()))\n+            .flatMap(MoreIterables::stream)\n+            .map(mcv -> mcv.getVertices(Direction.IN, KEY_INSTANCE_OF))\n+            .flatMap(MoreIterables::stream)\n+            .map(v -> ID_CONVERTER.revert(v.getId()))\n+            .collect(Collectors.toSet());\n     }\n \n     /**\n      * Retrieves the {@link Vertex} corresponding to the provided {@code id}.\n      *\n      * @param id the {@link Id} of the element to find\n-     *\n      * @return an {@link Optional} containing the {@link Vertex}, or {@link Optional#empty()} if it doesn't exist\n      */\n     @Nonnull\n@@ -379,14 +371,13 @@ abstract class AbstractBlueprintsBackend extends AbstractPersistentBackend imple\n      * created.\n      *\n      * @param id the {@link Id} of the element to find, or create\n-     *\n      * @return the {@link Vertex}\n      */\n     @Nonnull\n     protected Vertex getOrCreate(Id id) {\n         return verticesCache.get(id, i ->\n-                Optional.ofNullable(graph.getVertex(ID_CONVERTER.convert(i)))\n-                        .orElseGet(() -> graph.addVertex(ID_CONVERTER.convert(i))));\n+            Optional.ofNullable(graph.getVertex(ID_CONVERTER.convert(i)))\n+                .orElseGet(() -> graph.addVertex(ID_CONVERTER.convert(i))));\n     }\n \n     /**\n@@ -433,13 +424,12 @@ abstract class AbstractBlueprintsBackend extends AbstractPersistentBackend imple\n          * Creates a new {@link AutoCleanerIdEdge} from another {@link Edge}.\n          *\n          * @param edge the base edge\n-         *\n          * @return an {@link AutoCleanerIdEdge}\n          */\n         private Edge createFrom(@Nullable Edge edge) {\n             return Optional.ofNullable(edge)\n-                    .map(AutoCleanerIdEdge::new)\n-                    .orElse(null);\n+                .map(AutoCleanerIdEdge::new)\n+                .orElse(null);\n         }\n \n         /**\n@@ -469,9 +459,9 @@ abstract class AbstractBlueprintsBackend extends AbstractPersistentBackend imple\n                 super.remove();\n \n                 Iterable<Edge> edges = referencedVertex.query()\n-                        .direction(Direction.IN)\n-                        .limit(1)\n-                        .edges();\n+                    .direction(Direction.IN)\n+                    .limit(1)\n+                    .edges();\n \n                 if (MoreIterables.isEmpty(edges)) {\n                     // If the Vertex has no more incoming edges remove it from the DB\n",
            "diff_size": 56
        },
        {
            "tool": "naturalize",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/atlanmod-NeoEMF/errored/1/29/AbstractBlueprintsBackend.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/atlanmod-NeoEMF/naturalize/29/AbstractBlueprintsBackend.java\nindex a46d925f923..577da9294f6 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/atlanmod-NeoEMF/errored/1/29/AbstractBlueprintsBackend.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/atlanmod-NeoEMF/naturalize/29/AbstractBlueprintsBackend.java\n@@ -51,9 +51,7 @@ abstract class AbstractBlueprintsBackend extends AbstractPersistentBackend imple\n      * The default converter to use {@link Long} instead of {@link Id}.\n      */\n     @Nonnull\n-    protected static final Converter<Id, Object> ID_CONVERTER = Converter.from(\n-            Id::toLong,\n-            o -> Id.getProvider().fromLong(Long.class.cast(o)));\n+    protected static final Converter<Id, Object> ID_CONVERTER = Converter.from(Id::toLong, o -> Id.getProvider().fromLong(Long.class.cast(o)));\n \n     /**\n      * The property key used to define the index of an edge.\n@@ -480,4 +478,4 @@ abstract class AbstractBlueprintsBackend extends AbstractPersistentBackend imple\n             }\n         }\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 4
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "348",
                    "severity": "warning",
                    "message": "'block' child has incorrect indentation level 80, expected level should be 12.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.IndentationCheck"
                },
                {
                    "line": "349",
                    "severity": "warning",
                    "message": "'block' child has incorrect indentation level 80, expected level should be 12.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.IndentationCheck"
                },
                {
                    "line": "350",
                    "severity": "warning",
                    "message": "'block' child has incorrect indentation level 80, expected level should be 12.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.IndentationCheck"
                },
                {
                    "line": "351",
                    "severity": "warning",
                    "message": "'block' child has incorrect indentation level 80, expected level should be 12.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.IndentationCheck"
                },
                {
                    "line": "352",
                    "severity": "warning",
                    "message": "'block' child has incorrect indentation level 80, expected level should be 12.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.IndentationCheck"
                },
                {
                    "line": "353",
                    "severity": "warning",
                    "message": "'block' child has incorrect indentation level 80, expected level should be 12.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.IndentationCheck"
                },
                {
                    "line": "354",
                    "severity": "warning",
                    "message": "'block rcurly' has incorrect indentation level 76, expected level should be 8.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.IndentationCheck"
                },
                {
                    "line": "398",
                    "severity": "warning",
                    "message": "'lambda arguments' has incorrect indentation level 19, expected level should be 12.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.IndentationCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/atlanmod-NeoEMF/errored/1/29/AbstractBlueprintsBackend.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/atlanmod-NeoEMF/codebuff/29/AbstractBlueprintsBackend.java\nindex a46d925f923..573dbcd22fb 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/atlanmod-NeoEMF/errored/1/29/AbstractBlueprintsBackend.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/atlanmod-NeoEMF/codebuff/29/AbstractBlueprintsBackend.java\n@@ -19,7 +19,6 @@ import com.tinkerpop.blueprints.Vertex;\n import com.tinkerpop.blueprints.util.GraphHelper;\n import com.tinkerpop.blueprints.util.wrappers.id.IdEdge;\n import com.tinkerpop.blueprints.util.wrappers.id.IdGraph;\n-\n import fr.inria.atlanmod.commons.Converter;\n import fr.inria.atlanmod.commons.cache.Cache;\n import fr.inria.atlanmod.commons.cache.CacheBuilder;\n@@ -29,12 +28,10 @@ import fr.inria.atlanmod.neoemf.data.AbstractPersistentBackend;\n import fr.inria.atlanmod.neoemf.data.bean.ClassBean;\n import fr.inria.atlanmod.neoemf.data.bean.SingleFeatureBean;\n import fr.inria.atlanmod.neoemf.data.mapping.DataMapper;\n-\n import java.util.HashSet;\n import java.util.Optional;\n import java.util.Set;\n import java.util.stream.Collectors;\n-\n import javax.annotation.Nonnull;\n import javax.annotation.Nullable;\n import javax.annotation.ParametersAreNonnullByDefault;\n@@ -44,64 +41,83 @@ import static fr.inria.atlanmod.commons.Preconditions.checkNotNull;\n /**\n  * An abstract {@link BlueprintsBackend} that provides overall behavior for the management of a Blueprints database.\n  */\n+\n+\n @ParametersAreNonnullByDefault\n abstract class AbstractBlueprintsBackend extends AbstractPersistentBackend implements BlueprintsBackend {\n \n     /**\n      * The default converter to use {@link Long} instead of {@link Id}.\n      */\n+\n+\n     @Nonnull\n-    protected static final Converter<Id, Object> ID_CONVERTER = Converter.from(\n-            Id::toLong,\n-            o -> Id.getProvider().fromLong(Long.class.cast(o)));\n+    protected static final Converter<Id, Object> ID_CONVERTER = Converter.from(Id::toLong, o -> Id.getProvider().fromLong(Long.class.cast(o)));\n \n     /**\n      * The property key used to define the index of an edge.\n      */\n+\n+\n     protected static final String KEY_POSITION = \"p\";\n \n     /**\n      * The label used to define container {@link Edge}s.\n      */\n+\n+\n     protected static final String KEY_CONTAINER = \"c\";\n \n     /**\n      * The property key used to define the opposite containing feature in container {@link Edge}s.\n      */\n+\n+\n     protected static final String KEY_CONTAINING_FEATURE = \"f\";\n \n     /**\n      * The property key used to define the number of edges with a specific label.\n      */\n+\n+\n     protected static final String KEY_SIZE = \"s\";\n \n     /**\n      * The label of type conformance {@link Edge}s.\n      */\n+\n+\n     private static final String KEY_INSTANCE_OF = \"i\";\n \n     /**\n      * The name of the index entry holding meta-class {@link Vertex}s.\n      */\n+\n+\n     private static final String KEY_METACLASSES = \"m\";\n \n     /**\n      * The index key used to retrieve meta-class {@link Vertex}s.\n      */\n+\n+\n     private static final String KEY_NAME = \"n\";\n \n     /**\n      * The property key used to set the namespace URI of meta-class {@link Vertex}s.\n      */\n+\n+\n     private static final String KEY_NS_URI = \"u\";\n \n     /**\n      * In-memory cache that holds recently loaded {@link Vertex}s, identified by the associated object {@link Id}.\n      */\n+\n+\n     @Nonnull\n-    private final Cache<Id, Vertex> verticesCache = CacheBuilder.builder()\n-            .softValues()\n-            .build();\n+    private final Cache<Id, Vertex> verticesCache = CacheBuilder.builder().softValues()\n+                                                                          .build();\n \n     /**\n      * A set that holds indexed {@link ClassBean}.\n@@ -109,18 +125,24 @@ abstract class AbstractBlueprintsBackend extends AbstractPersistentBackend imple\n      * @see #metaClassIndex\n      * @see #innerCopyTo(DataMapper)\n      */\n+\n+\n     @Nonnull\n     private final Set<ClassBean> metaClassSet;\n \n     /**\n      * Index containing meta-classes.\n      */\n+\n+\n     @Nonnull\n     private final Index<Vertex> metaClassIndex;\n \n     /**\n      * The Blueprints graph.\n      */\n+\n+\n     @Nonnull\n     private final IdGraph<KeyIndexableGraph> graph;\n \n@@ -131,11 +153,11 @@ abstract class AbstractBlueprintsBackend extends AbstractPersistentBackend imple\n      *\n      * @see BlueprintsBackendFactory\n      */\n+\n+\n     protected AbstractBlueprintsBackend(KeyIndexableGraph baseGraph) {\n         checkNotNull(baseGraph);\n-\n         graph = new InternalIdGraph(baseGraph);\n-\n         metaClassSet = new HashSet<>();\n         metaClassIndex = getOrCreateIndex(KEY_METACLASSES);\n     }\n@@ -147,6 +169,7 @@ abstract class AbstractBlueprintsBackend extends AbstractPersistentBackend imple\n      *\n      * @return the create {@link Id}\n      */\n+\n     @Nonnull\n     private static Id generateClassId(ClassBean metaClass) {\n         return Id.getProvider().generate(metaClass.name() + metaClass.uri());\n@@ -160,6 +183,7 @@ abstract class AbstractBlueprintsBackend extends AbstractPersistentBackend imple\n      *\n      * @return the formatted property\n      */\n+\n     @Nonnull\n     protected static String formatProperty(Object prefix, Object suffix) {\n         return String.valueOf(prefix) + ':' + String.valueOf(suffix);\n@@ -172,6 +196,7 @@ abstract class AbstractBlueprintsBackend extends AbstractPersistentBackend imple\n      *\n      * @return the formatted label\n      */\n+\n     @Nonnull\n     protected static String formatLabel(Object label) {\n         return String.valueOf(label);\n@@ -184,10 +209,10 @@ abstract class AbstractBlueprintsBackend extends AbstractPersistentBackend imple\n      *\n      * @return the index\n      */\n+\n     @Nonnull\n     private Index<Vertex> getOrCreateIndex(String name) {\n-        return Optional.ofNullable(graph.getIndex(name, Vertex.class))\n-                .orElseGet(() -> graph.createIndex(name, Vertex.class));\n+        return Optional.ofNullable(graph.getIndex(name, Vertex.class)).orElseGet(() -> graph.createIndex(name, Vertex.class));\n     }\n \n     @Override\n@@ -217,11 +242,10 @@ abstract class AbstractBlueprintsBackend extends AbstractPersistentBackend imple\n     @Override\n     protected void innerCopyTo(DataMapper target) {\n         AbstractBlueprintsBackend to = AbstractBlueprintsBackend.class.cast(target);\n-\n         GraphHelper.copyGraph(graph, to.graph);\n-\n         metaClassSet.forEach(m -> {\n             Id id = generateClassId(m);\n+\n             Vertex vertex = get(id).<IllegalStateException>orElseThrow(IllegalStateException::new);\n             to.metaClassIndex.put(KEY_NAME, m.name(), vertex);\n         });\n@@ -233,21 +257,16 @@ abstract class AbstractBlueprintsBackend extends AbstractPersistentBackend imple\n         checkNotNull(id);\n \n         Optional<Vertex> containmentVertex = get(id);\n-\n         if (!containmentVertex.isPresent()) {\n             return Optional.empty();\n         }\n \n         Iterable<Edge> edges = containmentVertex.get().query()\n-                .labels(KEY_CONTAINER)\n-                .direction(Direction.OUT)\n-                .limit(1)\n-                .edges();\n-\n-        return MoreIterables.onlyElement(edges)\n-                .map(e -> SingleFeatureBean.of(\n-                        ID_CONVERTER.revert(e.getVertex(Direction.IN).getId()),\n-                        e.getProperty(KEY_CONTAINING_FEATURE)));\n+                                                      .labels(KEY_CONTAINER)\n+                                                      .direction(Direction.OUT)\n+                                                      .limit(1)\n+                                                      .edges();\n+        return MoreIterables.onlyElement(edges).map(e -> SingleFeatureBean.of(ID_CONVERTER.revert(e.getVertex(Direction.IN).getId()), e.getProperty(KEY_CONTAINING_FEATURE)));\n     }\n \n     @Override\n@@ -256,14 +275,13 @@ abstract class AbstractBlueprintsBackend extends AbstractPersistentBackend imple\n         checkNotNull(container);\n \n         Vertex containmentVertex = getOrCreate(id);\n-        Vertex containerVertex = getOrCreate(container.owner());\n \n-        Iterable<Edge> containmentEdges = containmentVertex.query()\n-                .labels(KEY_CONTAINER)\n-                .direction(Direction.OUT)\n-                .limit(1)\n-                .edges();\n+        Vertex containerVertex = getOrCreate(container.owner());\n \n+        Iterable<Edge> containmentEdges = containmentVertex.query().labels(KEY_CONTAINER)\n+                                                                   .direction(Direction.OUT)\n+                                                                   .limit(1)\n+                                                                   .edges();\n         containmentEdges.forEach(Edge::remove);\n \n         Edge edge = containmentVertex.addEdge(KEY_CONTAINER, containerVertex);\n@@ -275,17 +293,15 @@ abstract class AbstractBlueprintsBackend extends AbstractPersistentBackend imple\n         checkNotNull(id);\n \n         Optional<Vertex> containmentVertex = get(id);\n-\n         if (!containmentVertex.isPresent()) {\n             return;\n         }\n \n         Iterable<Edge> containmentEdges = containmentVertex.get().query()\n-                .labels(KEY_CONTAINER)\n-                .direction(Direction.OUT)\n-                .limit(1)\n-                .edges();\n-\n+                                                                 .labels(KEY_CONTAINER)\n+                                                                 .direction(Direction.OUT)\n+                                                                 .limit(1)\n+                                                                 .edges();\n         containmentEdges.forEach(Edge::remove);\n     }\n \n@@ -295,21 +311,16 @@ abstract class AbstractBlueprintsBackend extends AbstractPersistentBackend imple\n         checkNotNull(id);\n \n         Optional<Vertex> vertex = get(id);\n-\n         if (!vertex.isPresent()) {\n             return Optional.empty();\n         }\n \n         Iterable<Vertex> metaClassVertices = vertex.get().query()\n-                .labels(KEY_INSTANCE_OF)\n-                .direction(Direction.OUT)\n-                .limit(1)\n-                .vertices();\n-\n-        return MoreIterables.onlyElement(metaClassVertices)\n-                .map(v -> ClassBean.of(\n-                        v.getProperty(KEY_NAME),\n-                        v.getProperty(KEY_NS_URI)));\n+                                                         .labels(KEY_INSTANCE_OF)\n+                                                         .direction(Direction.OUT)\n+                                                         .limit(1)\n+                                                         .vertices();\n+        return MoreIterables.onlyElement(metaClassVertices).map(v -> ClassBean.of(v.getProperty(KEY_NAME), v.getProperty(KEY_NS_URI)));\n     }\n \n     @Override\n@@ -320,46 +331,42 @@ abstract class AbstractBlueprintsBackend extends AbstractPersistentBackend imple\n         Vertex vertex = getOrCreate(id);\n \n         // Check the presence of a meta-class\n-        Iterable<Edge> instanceEdges = vertex.query()\n-                .labels(KEY_INSTANCE_OF)\n-                .direction(Direction.OUT)\n-                .limit(1)\n-                .edges();\n \n+        Iterable<Edge> instanceEdges = vertex.query().labels(KEY_INSTANCE_OF)\n+                                                     .direction(Direction.OUT)\n+                                                     .limit(1)\n+                                                     .edges();\n         if (MoreIterables.onlyElement(instanceEdges).isPresent()) {\n             return false;\n         }\n \n         // Retrieve or create the meta-class and store it in the index\n+\n         Iterable<Vertex> instanceVertices = metaClassIndex.get(KEY_NAME, metaClass.name());\n \n         Vertex metaClassVertex = MoreIterables.onlyElement(instanceVertices).orElseGet(() -> {\n-            Vertex mcv = graph.addVertex(ID_CONVERTER.convert(generateClassId(metaClass)));\n-            mcv.setProperty(KEY_NAME, metaClass.name());\n-            mcv.setProperty(KEY_NS_URI, metaClass.uri());\n-\n-            metaClassIndex.put(KEY_NAME, metaClass.name(), mcv);\n-            metaClassSet.add(metaClass);\n-\n-            return mcv;\n-        });\n+                                                                                Vertex mcv = graph.addVertex(ID_CONVERTER.convert(generateClassId(metaClass)));\n+                                                                                mcv.setProperty(KEY_NAME, metaClass.name());\n+                                                                                mcv.setProperty(KEY_NS_URI, metaClass.uri());\n+                                                                                metaClassIndex.put(KEY_NAME, metaClass.name(), mcv);\n+                                                                                metaClassSet.add(metaClass);\n+                                                                                return mcv;\n+                                                                            });\n \n         // Defines the meta-class\n         vertex.addEdge(KEY_INSTANCE_OF, metaClassVertex);\n-\n         return true;\n     }\n \n     @Nonnull\n     @Override\n     public Iterable<Id> allInstancesOf(Set<ClassBean> metaClasses) {\n-        return metaClasses.stream()\n-                .map(mc -> metaClassIndex.get(KEY_NAME, mc.name()))\n-                .flatMap(MoreIterables::stream)\n-                .map(mcv -> mcv.getVertices(Direction.IN, KEY_INSTANCE_OF))\n-                .flatMap(MoreIterables::stream)\n-                .map(v -> ID_CONVERTER.revert(v.getId()))\n-                .collect(Collectors.toSet());\n+        return metaClasses.stream().map(mc -> metaClassIndex.get(KEY_NAME, mc.name()))\n+                                   .flatMap(MoreIterables::stream)\n+                                   .map(mcv -> mcv.getVertices(Direction.IN, KEY_INSTANCE_OF))\n+                                   .flatMap(MoreIterables::stream)\n+                                   .map(v -> ID_CONVERTER.revert(v.getId()))\n+                                   .collect(Collectors.toSet());\n     }\n \n     /**\n@@ -369,6 +376,7 @@ abstract class AbstractBlueprintsBackend extends AbstractPersistentBackend imple\n      *\n      * @return an {@link Optional} containing the {@link Vertex}, or {@link Optional#empty()} if it doesn't exist\n      */\n+\n     @Nonnull\n     protected Optional<Vertex> get(Id id) {\n         return Optional.ofNullable(verticesCache.get(id, i -> graph.getVertex(ID_CONVERTER.convert(i))));\n@@ -382,11 +390,13 @@ abstract class AbstractBlueprintsBackend extends AbstractPersistentBackend imple\n      *\n      * @return the {@link Vertex}\n      */\n+\n     @Nonnull\n     protected Vertex getOrCreate(Id id) {\n-        return verticesCache.get(id, i ->\n-                Optional.ofNullable(graph.getVertex(ID_CONVERTER.convert(i)))\n-                        .orElseGet(() -> graph.addVertex(ID_CONVERTER.convert(i))));\n+        return verticesCache.get(\n+                   id,\n+                   i -> Optional.ofNullable(graph.getVertex(ID_CONVERTER.convert(i))).orElseGet(() -> graph.addVertex(ID_CONVERTER.convert(i)))\n+        );\n     }\n \n     /**\n@@ -397,6 +407,7 @@ abstract class AbstractBlueprintsBackend extends AbstractPersistentBackend imple\n      *\n      * @return the underlying Blueprints {@link IdGraph}\n      */\n+\n     @Nonnull\n     @SuppressWarnings(\"unchecked\")\n     public <T> T getGraph() {\n@@ -406,6 +417,7 @@ abstract class AbstractBlueprintsBackend extends AbstractPersistentBackend imple\n     /**\n      * An {@link IdGraph} that automatically removes unused {@link Vertex}.\n      */\n+\n     @ParametersAreNonnullByDefault\n     private static class InternalIdGraph extends IdGraph<KeyIndexableGraph> {\n \n@@ -414,6 +426,8 @@ abstract class AbstractBlueprintsBackend extends AbstractPersistentBackend imple\n          *\n          * @param baseGraph the base graph\n          */\n+\n+\n         public InternalIdGraph(KeyIndexableGraph baseGraph) {\n             super(baseGraph, true, false);\n             enforceUniqueIds(false);\n@@ -436,15 +450,17 @@ abstract class AbstractBlueprintsBackend extends AbstractPersistentBackend imple\n          *\n          * @return an {@link AutoCleanerIdEdge}\n          */\n+\n+\n         private Edge createFrom(@Nullable Edge edge) {\n-            return Optional.ofNullable(edge)\n-                    .map(AutoCleanerIdEdge::new)\n-                    .orElse(null);\n+            return Optional.ofNullable(edge).map(AutoCleanerIdEdge::new)\n+                                            .orElse(null);\n         }\n \n         /**\n          * An {@link IdEdge} that automatically removes {@link Vertex} that are no longer referenced.\n          */\n+\n         @ParametersAreNonnullByDefault\n         private class AutoCleanerIdEdge extends IdEdge {\n \n@@ -453,6 +469,8 @@ abstract class AbstractBlueprintsBackend extends AbstractPersistentBackend imple\n              *\n              * @param edge the base edge\n              */\n+\n+\n             public AutoCleanerIdEdge(Edge edge) {\n                 super(edge, InternalIdGraph.this);\n             }\n@@ -463,16 +481,15 @@ abstract class AbstractBlueprintsBackend extends AbstractPersistentBackend imple\n              * If the {@link Edge} references a {@link Vertex} with no more incoming {@link Edge}, the referenced {@link\n              * Vertex} is removed as well.\n              */\n+\n             @Override\n             public void remove() {\n                 Vertex referencedVertex = getVertex(Direction.IN);\n                 super.remove();\n \n-                Iterable<Edge> edges = referencedVertex.query()\n-                        .direction(Direction.IN)\n-                        .limit(1)\n-                        .edges();\n-\n+                Iterable<Edge> edges = referencedVertex.query().direction(Direction.IN)\n+                                                               .limit(1)\n+                                                               .edges();\n                 if (MoreIterables.isEmpty(edges)) {\n                     // If the Vertex has no more incoming edges remove it from the DB\n                     referencedVertex.remove();\n@@ -480,4 +497,4 @@ abstract class AbstractBlueprintsBackend extends AbstractPersistentBackend imple\n             }\n         }\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 138
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "56",
                    "severity": "warning",
                    "message": "'lambda arguments' has incorrect indentation level 12, expected level should be 8.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.IndentationCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "57",
                    "severity": "warning",
                    "message": "'o' has incorrect indentation level 4, expected level should be 8.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.IndentationCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/atlanmod-NeoEMF/errored/1/29/AbstractBlueprintsBackend.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/atlanmod-NeoEMF/styler_three_grams/29/AbstractBlueprintsBackend.java\nindex a46d925f923..5669941c7ec 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/atlanmod-NeoEMF/errored/1/29/AbstractBlueprintsBackend.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/atlanmod-NeoEMF/styler_three_grams/29/AbstractBlueprintsBackend.java\n@@ -53,7 +53,10 @@ abstract class AbstractBlueprintsBackend extends AbstractPersistentBackend imple\n     @Nonnull\n     protected static final Converter<Id, Object> ID_CONVERTER = Converter.from(\n             Id::toLong,\n-            o -> Id.getProvider().fromLong(Long.class.cast(o)));\n+\n+    o -> Id.getProvider().fromLong(Long.class.cast(\n+\n+            o)));\n \n     /**\n      * The property key used to define the index of an edge.\n",
            "diff_size": 4
        }
    ],
    "repaired_by": [
        "intellij",
        "naturalize"
    ],
    "not_repaired_by": [
        "styler",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}