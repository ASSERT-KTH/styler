{
    "project_name": "Internet2-grouper",
    "error_id": "49",
    "information": {
        "errors": [
            {
                "line": "841",
                "column": "13",
                "severity": "warning",
                "message": "'if' is not followed by whitespace.",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAfterCheck"
            }
        ]
    },
    "source_code": "\n        } else {\n            if(object.getClass().isArray()) {\n                // 'Switch' on type of array, to dispatch to the correct handler\n                // This handles multi dimensional arrays\n                if (object instanceof long[]) {",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/errored/1/49/HashCodeBuilder.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/styler/49/HashCodeBuilder.java\nindex c69eb5b1457..94dd3384dbd 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/errored/1/49/HashCodeBuilder.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/styler/49/HashCodeBuilder.java\n@@ -838,7 +838,7 @@ public class HashCodeBuilder implements Builder<Integer> {\n             iTotal = iTotal * iConstant;\r\n \r\n         } else {\r\n-            if(object.getClass().isArray()) {\r\n+            if (object.getClass().isArray()) {\r\n                 // 'Switch' on type of array, to dispatch to the correct handler\r\n                 // This handles multi dimensional arrays\r\n                 if (object instanceof long[]) {\r\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/errored/1/49/HashCodeBuilder.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/intellij/49/HashCodeBuilder.java\nindex c69eb5b1457..e0e4bed7f64 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/errored/1/49/HashCodeBuilder.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/intellij/49/HashCodeBuilder.java\n@@ -1,12 +1,12 @@\n /**\r\n  * Copyright 2014 Internet2\r\n- *\r\n+ * <p>\r\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  * you may not use this file except in compliance with the License.\r\n  * You may obtain a copy of the License at\r\n- *\r\n- *   http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n+ * <p>\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ * <p>\r\n  * Unless required by applicable law or agreed to in writing, software\r\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n@@ -113,864 +113,864 @@ import edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.ArrayU\n  * @version $Id: HashCodeBuilder.java 1144929 2011-07-10 18:26:16Z ggregory $\r\n  */\r\n public class HashCodeBuilder implements Builder<Integer> {\r\n-    /**\r\n-     * <p>\r\n-     * A registry of objects used by reflection methods to detect cyclical object references and avoid infinite loops.\r\n-     * </p>\r\n-     *\r\n-     * @since 2.3\r\n-     */\r\n-    private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>();\r\n-\r\n-    /*\r\n-     * NOTE: we cannot store the actual objects in a HashSet, as that would use the very hashCode()\r\n-     * we are in the process of calculating.\r\n-     *\r\n-     * So we generate a one-to-one mapping from the original object to a new object.\r\n-     *\r\n-     * Now HashSet uses equals() to determine if two elements with the same hashcode really\r\n-     * are equal, so we also need to ensure that the replacement objects are only equal\r\n-     * if the original objects are identical.\r\n-     *\r\n-     * The original implementation (2.4 and before) used the System.indentityHashCode()\r\n-     * method - however this is not guaranteed to generate unique ids (e.g. LANG-459)\r\n-     *\r\n-     * We now use the IDKey helper class (adapted from org.apache.axis.utils.IDKey)\r\n-     * to disambiguate the duplicate ids.\r\n-     */\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Returns the registry of objects being traversed by the reflection methods in the current thread.\r\n-     * </p>\r\n-     *\r\n-     * @return Set the registry of objects being traversed\r\n-     * @since 2.3\r\n-     */\r\n-    static Set<IDKey> getRegistry() {\r\n-        return REGISTRY.get();\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Returns <code>true</code> if the registry contains the given object. Used by the reflection methods to avoid\r\n-     * infinite loops.\r\n-     * </p>\r\n-     *\r\n-     * @param value\r\n-     *            The object to lookup in the registry.\r\n-     * @return boolean <code>true</code> if the registry contains the given object.\r\n-     * @since 2.3\r\n-     */\r\n-    static boolean isRegistered(Object value) {\r\n-        Set<IDKey> registry = getRegistry();\r\n-        return registry != null && registry.contains(new IDKey(value));\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Appends the fields and values defined by the given object of the given <code>Class</code>.\r\n-     * </p>\r\n-     *\r\n-     * @param object\r\n-     *            the object to append details of\r\n-     * @param clazz\r\n-     *            the class to append details of\r\n-     * @param builder\r\n-     *            the builder to append to\r\n-     * @param useTransients\r\n-     *            whether to use transient fields\r\n-     * @param excludeFields\r\n-     *            Collection of String field names to exclude from use in calculation of hash code\r\n-     */\r\n-    private static void reflectionAppend(Object object, Class<?> clazz, HashCodeBuilder builder, boolean useTransients,\r\n-            String[] excludeFields) {\r\n-        if (isRegistered(object)) {\r\n-            return;\r\n-        }\r\n-        try {\r\n-            register(object);\r\n-            Field[] fields = clazz.getDeclaredFields();\r\n-            AccessibleObject.setAccessible(fields, true);\r\n-            for (Field field : fields) {\r\n-                if (!ArrayUtils.contains(excludeFields, field.getName())\r\n-                    && (field.getName().indexOf('$') == -1)\r\n-                    && (useTransients || !Modifier.isTransient(field.getModifiers()))\r\n-                    && (!Modifier.isStatic(field.getModifiers()))) {\r\n-                    try {\r\n-                        Object fieldValue = field.get(object);\r\n-                        builder.append(fieldValue);\r\n-                    } catch (IllegalAccessException e) {\r\n-                        // this can't happen. Would get a Security exception instead\r\n-                        // throw a runtime exception in case the impossible happens.\r\n-                        throw new InternalError(\"Unexpected IllegalAccessException\");\r\n-                    }\r\n-                }\r\n-            }\r\n-        } finally {\r\n-            unregister(object);\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * This method uses reflection to build a valid hash code.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\r\n-     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\r\n-     * also not as efficient as testing explicitly.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Transient members will be not be used, as they are likely derived fields, and not part of the value of the\r\n-     * <code>Object</code>.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Static fields will not be tested. Superclass fields will be included.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally these should be different for each class,\r\n-     * however this is not vital. Prime numbers are preferred, especially for the multiplier.\r\n-     * </p>\r\n-     *\r\n-     * @param initialNonZeroOddNumber\r\n-     *            a non-zero, odd number used as the initial value\r\n-     * @param multiplierNonZeroOddNumber\r\n-     *            a non-zero, odd number used as the multiplier\r\n-     * @param object\r\n-     *            the Object to create a <code>hashCode</code> for\r\n-     * @return int hash code\r\n-     * @throws IllegalArgumentException\r\n-     *             if the Object is <code>null</code>\r\n-     * @throws IllegalArgumentException\r\n-     *             if the number is zero or even\r\n-     */\r\n-    public static int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, Object object) {\r\n-        return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, false, null);\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * This method uses reflection to build a valid hash code.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\r\n-     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\r\n-     * also not as efficient as testing explicitly.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * If the TestTransients parameter is set to <code>true</code>, transient members will be tested, otherwise they\r\n-     * are ignored, as they are likely derived fields, and not part of the value of the <code>Object</code>.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Static fields will not be tested. Superclass fields will be included.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally these should be different for each class,\r\n-     * however this is not vital. Prime numbers are preferred, especially for the multiplier.\r\n-     * </p>\r\n-     *\r\n-     * @param initialNonZeroOddNumber\r\n-     *            a non-zero, odd number used as the initial value\r\n-     * @param multiplierNonZeroOddNumber\r\n-     *            a non-zero, odd number used as the multiplier\r\n-     * @param object\r\n-     *            the Object to create a <code>hashCode</code> for\r\n-     * @param testTransients\r\n-     *            whether to include transient fields\r\n-     * @return int hash code\r\n-     * @throws IllegalArgumentException\r\n-     *             if the Object is <code>null</code>\r\n-     * @throws IllegalArgumentException\r\n-     *             if the number is zero or even\r\n-     */\r\n-    public static int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, Object object,\r\n-            boolean testTransients) {\r\n-        return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, testTransients, null);\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * This method uses reflection to build a valid hash code.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\r\n-     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\r\n-     * also not as efficient as testing explicitly.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * If the TestTransients parameter is set to <code>true</code>, transient members will be tested, otherwise they\r\n-     * are ignored, as they are likely derived fields, and not part of the value of the <code>Object</code>.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Static fields will not be included. Superclass fields will be included up to and including the specified\r\n-     * superclass. A null superclass is treated as java.lang.Object.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally these should be different for each class,\r\n-     * however this is not vital. Prime numbers are preferred, especially for the multiplier.\r\n-     * </p>\r\n-     *\r\n-     * @param <T>\r\n-     *            the type of the object involved\r\n-     * @param initialNonZeroOddNumber\r\n-     *            a non-zero, odd number used as the initial value\r\n-     * @param multiplierNonZeroOddNumber\r\n-     *            a non-zero, odd number used as the multiplier\r\n-     * @param object\r\n-     *            the Object to create a <code>hashCode</code> for\r\n-     * @param testTransients\r\n-     *            whether to include transient fields\r\n-     * @param reflectUpToClass\r\n-     *            the superclass to reflect up to (inclusive), may be <code>null</code>\r\n-     * @param excludeFields\r\n-     *            array of field names to exclude from use in calculation of hash code\r\n-     * @return int hash code\r\n-     * @throws IllegalArgumentException\r\n-     *             if the Object is <code>null</code>\r\n-     * @throws IllegalArgumentException\r\n-     *             if the number is zero or even\r\n-     * @since 2.0\r\n-     */\r\n-    public static <T> int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, T object,\r\n-            boolean testTransients, Class<? super T> reflectUpToClass, String... excludeFields) {\r\n-\r\n-        if (object == null) {\r\n-            throw new IllegalArgumentException(\"The object to build a hash code for must not be null\");\r\n-        }\r\n-        HashCodeBuilder builder = new HashCodeBuilder(initialNonZeroOddNumber, multiplierNonZeroOddNumber);\r\n-        Class<?> clazz = object.getClass();\r\n-        reflectionAppend(object, clazz, builder, testTransients, excludeFields);\r\n-        while (clazz.getSuperclass() != null && clazz != reflectUpToClass) {\r\n-            clazz = clazz.getSuperclass();\r\n-            reflectionAppend(object, clazz, builder, testTransients, excludeFields);\r\n-        }\r\n-        return builder.toHashCode();\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * This method uses reflection to build a valid hash code.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * This constructor uses two hard coded choices for the constants needed to build a hash code.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\r\n-     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\r\n-     * also not as efficient as testing explicitly.\r\n-     * </p>\r\n-     *\r\n-     * <P>\r\n-     * If the TestTransients parameter is set to <code>true</code>, transient members will be tested, otherwise they\r\n-     * are ignored, as they are likely derived fields, and not part of the value of the <code>Object</code>.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Static fields will not be tested. Superclass fields will be included.\r\n-     * </p>\r\n-     *\r\n-     * @param object\r\n-     *            the Object to create a <code>hashCode</code> for\r\n-     * @param testTransients\r\n-     *            whether to include transient fields\r\n-     * @return int hash code\r\n-     * @throws IllegalArgumentException\r\n-     *             if the object is <code>null</code>\r\n-     */\r\n-    public static int reflectionHashCode(Object object, boolean testTransients) {\r\n-        return reflectionHashCode(17, 37, object, testTransients, null);\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * This method uses reflection to build a valid hash code.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * This constructor uses two hard coded choices for the constants needed to build a hash code.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\r\n-     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\r\n-     * also not as efficient as testing explicitly.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Transient members will be not be used, as they are likely derived fields, and not part of the value of the\r\n-     * <code>Object</code>.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Static fields will not be tested. Superclass fields will be included.\r\n-     * </p>\r\n-     *\r\n-     * @param object\r\n-     *            the Object to create a <code>hashCode</code> for\r\n-     * @param excludeFields\r\n-     *            Collection of String field names to exclude from use in calculation of hash code\r\n-     * @return int hash code\r\n-     * @throws IllegalArgumentException\r\n-     *             if the object is <code>null</code>\r\n-     */\r\n-    public static int reflectionHashCode(Object object, Collection<String> excludeFields) {\r\n-        return reflectionHashCode(object, ReflectionToStringBuilder.toNoNullStringArray(excludeFields));\r\n-    }\r\n-\r\n-    // -------------------------------------------------------------------------\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * This method uses reflection to build a valid hash code.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * This constructor uses two hard coded choices for the constants needed to build a hash code.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\r\n-     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\r\n-     * also not as efficient as testing explicitly.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Transient members will be not be used, as they are likely derived fields, and not part of the value of the\r\n-     * <code>Object</code>.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Static fields will not be tested. Superclass fields will be included.\r\n-     * </p>\r\n-     *\r\n-     * @param object\r\n-     *            the Object to create a <code>hashCode</code> for\r\n-     * @param excludeFields\r\n-     *            array of field names to exclude from use in calculation of hash code\r\n-     * @return int hash code\r\n-     * @throws IllegalArgumentException\r\n-     *             if the object is <code>null</code>\r\n-     */\r\n-    public static int reflectionHashCode(Object object, String... excludeFields) {\r\n-        return reflectionHashCode(17, 37, object, false, null, excludeFields);\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Registers the given object. Used by the reflection methods to avoid infinite loops.\r\n-     * </p>\r\n-     *\r\n-     * @param value\r\n-     *            The object to register.\r\n-     */\r\n-    static void register(Object value) {\r\n-        synchronized (HashCodeBuilder.class) {\r\n-            if (getRegistry() == null) {\r\n-                REGISTRY.set(new HashSet<IDKey>());\r\n-            }\r\n-        }\r\n-        getRegistry().add(new IDKey(value));\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Unregisters the given object.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Used by the reflection methods to avoid infinite loops.\r\n-     *\r\n-     * @param value\r\n-     *            The object to unregister.\r\n-     * @since 2.3\r\n-     */\r\n-    static void unregister(Object value) {\r\n-        Set<IDKey> registry = getRegistry();\r\n-        if (registry != null) {\r\n-            registry.remove(new IDKey(value));\r\n-            synchronized (HashCodeBuilder.class) {\r\n-                //read again\r\n-                registry = getRegistry();\r\n-                if (registry != null && registry.isEmpty()) {\r\n-                    REGISTRY.remove();\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Constant to use in building the hashCode.\r\n-     */\r\n-    private final int iConstant;\r\n-\r\n-    /**\r\n-     * Running total of the hashCode.\r\n-     */\r\n-    private int iTotal = 0;\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Uses two hard coded choices for the constants needed to build a <code>hashCode</code>.\r\n-     * </p>\r\n-     */\r\n-    public HashCodeBuilder() {\r\n-        iConstant = 37;\r\n-        iTotal = 17;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally these should be different for each class,\r\n-     * however this is not vital.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Prime numbers are preferred, especially for the multiplier.\r\n-     * </p>\r\n-     *\r\n-     * @param initialNonZeroOddNumber\r\n-     *            a non-zero, odd number used as the initial value\r\n-     * @param multiplierNonZeroOddNumber\r\n-     *            a non-zero, odd number used as the multiplier\r\n-     * @throws IllegalArgumentException\r\n-     *             if the number is zero or even\r\n-     */\r\n-    public HashCodeBuilder(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber) {\r\n-        if (initialNonZeroOddNumber == 0) {\r\n-            throw new IllegalArgumentException(\"HashCodeBuilder requires a non zero initial value\");\r\n-        }\r\n-        if (initialNonZeroOddNumber % 2 == 0) {\r\n-            throw new IllegalArgumentException(\"HashCodeBuilder requires an odd initial value\");\r\n-        }\r\n-        if (multiplierNonZeroOddNumber == 0) {\r\n-            throw new IllegalArgumentException(\"HashCodeBuilder requires a non zero multiplier\");\r\n-        }\r\n-        if (multiplierNonZeroOddNumber % 2 == 0) {\r\n-            throw new IllegalArgumentException(\"HashCodeBuilder requires an odd multiplier\");\r\n-        }\r\n-        iConstant = multiplierNonZeroOddNumber;\r\n-        iTotal = initialNonZeroOddNumber;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for a <code>boolean</code>.\r\n-     * </p>\r\n-     * <p>\r\n-     * This adds <code>1</code> when true, and <code>0</code> when false to the <code>hashCode</code>.\r\n-     * </p>\r\n-     * <p>\r\n-     * This is in contrast to the standard <code>java.lang.Boolean.hashCode</code> handling, which computes\r\n-     * a <code>hashCode</code> value of <code>1231</code> for <code>java.lang.Boolean</code> instances\r\n-     * that represent <code>true</code> or <code>1237</code> for <code>java.lang.Boolean</code> instances\r\n-     * that represent <code>false</code>.\r\n-     * </p>\r\n-     * <p>\r\n-     * This is in accordance with the <quote>Effective Java</quote> design.\r\n-     * </p>\r\n-     *\r\n-     * @param value\r\n-     *            the boolean to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    public HashCodeBuilder append(boolean value) {\r\n-        iTotal = iTotal * iConstant + (value ? 0 : 1);\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for a <code>boolean</code> array.\r\n-     * </p>\r\n-     *\r\n-     * @param array\r\n-     *            the array to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    public HashCodeBuilder append(boolean[] array) {\r\n-        if (array == null) {\r\n-            iTotal = iTotal * iConstant;\r\n-        } else {\r\n-            for (boolean element : array) {\r\n-                append(element);\r\n-            }\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    // -------------------------------------------------------------------------\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for a <code>byte</code>.\r\n-     * </p>\r\n-     *\r\n-     * @param value\r\n-     *            the byte to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    public HashCodeBuilder append(byte value) {\r\n-        iTotal = iTotal * iConstant + value;\r\n-        return this;\r\n-    }\r\n-\r\n-    // -------------------------------------------------------------------------\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for a <code>byte</code> array.\r\n-     * </p>\r\n-     *\r\n-     * @param array\r\n-     *            the array to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    public HashCodeBuilder append(byte[] array) {\r\n-        if (array == null) {\r\n-            iTotal = iTotal * iConstant;\r\n-        } else {\r\n-            for (byte element : array) {\r\n-                append(element);\r\n-            }\r\n+  /**\r\n+   * <p>\r\n+   * A registry of objects used by reflection methods to detect cyclical object references and avoid infinite loops.\r\n+   * </p>\r\n+   *\r\n+   * @since 2.3\r\n+   */\r\n+  private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>();\r\n+\r\n+  /*\r\n+   * NOTE: we cannot store the actual objects in a HashSet, as that would use the very hashCode()\r\n+   * we are in the process of calculating.\r\n+   *\r\n+   * So we generate a one-to-one mapping from the original object to a new object.\r\n+   *\r\n+   * Now HashSet uses equals() to determine if two elements with the same hashcode really\r\n+   * are equal, so we also need to ensure that the replacement objects are only equal\r\n+   * if the original objects are identical.\r\n+   *\r\n+   * The original implementation (2.4 and before) used the System.indentityHashCode()\r\n+   * method - however this is not guaranteed to generate unique ids (e.g. LANG-459)\r\n+   *\r\n+   * We now use the IDKey helper class (adapted from org.apache.axis.utils.IDKey)\r\n+   * to disambiguate the duplicate ids.\r\n+   */\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Returns the registry of objects being traversed by the reflection methods in the current thread.\r\n+   * </p>\r\n+   *\r\n+   * @return Set the registry of objects being traversed\r\n+   * @since 2.3\r\n+   */\r\n+  static Set<IDKey> getRegistry() {\r\n+    return REGISTRY.get();\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Returns <code>true</code> if the registry contains the given object. Used by the reflection methods to avoid\r\n+   * infinite loops.\r\n+   * </p>\r\n+   *\r\n+   * @param value\r\n+   *            The object to lookup in the registry.\r\n+   * @return boolean <code>true</code> if the registry contains the given object.\r\n+   * @since 2.3\r\n+   */\r\n+  static boolean isRegistered(Object value) {\r\n+    Set<IDKey> registry = getRegistry();\r\n+    return registry != null && registry.contains(new IDKey(value));\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Appends the fields and values defined by the given object of the given <code>Class</code>.\r\n+   * </p>\r\n+   *\r\n+   * @param object\r\n+   *            the object to append details of\r\n+   * @param clazz\r\n+   *            the class to append details of\r\n+   * @param builder\r\n+   *            the builder to append to\r\n+   * @param useTransients\r\n+   *            whether to use transient fields\r\n+   * @param excludeFields\r\n+   *            Collection of String field names to exclude from use in calculation of hash code\r\n+   */\r\n+  private static void reflectionAppend(Object object, Class<?> clazz, HashCodeBuilder builder, boolean useTransients,\r\n+                                       String[] excludeFields) {\r\n+    if (isRegistered(object)) {\r\n+      return;\r\n+    }\r\n+    try {\r\n+      register(object);\r\n+      Field[] fields = clazz.getDeclaredFields();\r\n+      AccessibleObject.setAccessible(fields, true);\r\n+      for (Field field : fields) {\r\n+        if (!ArrayUtils.contains(excludeFields, field.getName())\r\n+          && (field.getName().indexOf('$') == -1)\r\n+          && (useTransients || !Modifier.isTransient(field.getModifiers()))\r\n+          && (!Modifier.isStatic(field.getModifiers()))) {\r\n+          try {\r\n+            Object fieldValue = field.get(object);\r\n+            builder.append(fieldValue);\r\n+          } catch (IllegalAccessException e) {\r\n+            // this can't happen. Would get a Security exception instead\r\n+            // throw a runtime exception in case the impossible happens.\r\n+            throw new InternalError(\"Unexpected IllegalAccessException\");\r\n+          }\r\n         }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for a <code>char</code>.\r\n-     * </p>\r\n-     *\r\n-     * @param value\r\n-     *            the char to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    public HashCodeBuilder append(char value) {\r\n-        iTotal = iTotal * iConstant + value;\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for a <code>char</code> array.\r\n-     * </p>\r\n-     *\r\n-     * @param array\r\n-     *            the array to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    public HashCodeBuilder append(char[] array) {\r\n-        if (array == null) {\r\n-            iTotal = iTotal * iConstant;\r\n-        } else {\r\n-            for (char element : array) {\r\n-                append(element);\r\n-            }\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for a <code>double</code>.\r\n-     * </p>\r\n-     *\r\n-     * @param value\r\n-     *            the double to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    public HashCodeBuilder append(double value) {\r\n-        return append(Double.doubleToLongBits(value));\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for a <code>double</code> array.\r\n-     * </p>\r\n-     *\r\n-     * @param array\r\n-     *            the array to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    public HashCodeBuilder append(double[] array) {\r\n-        if (array == null) {\r\n-            iTotal = iTotal * iConstant;\r\n-        } else {\r\n-            for (double element : array) {\r\n-                append(element);\r\n-            }\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for a <code>float</code>.\r\n-     * </p>\r\n-     *\r\n-     * @param value\r\n-     *            the float to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    public HashCodeBuilder append(float value) {\r\n-        iTotal = iTotal * iConstant + Float.floatToIntBits(value);\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for a <code>float</code> array.\r\n-     * </p>\r\n-     *\r\n-     * @param array\r\n-     *            the array to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    public HashCodeBuilder append(float[] array) {\r\n-        if (array == null) {\r\n-            iTotal = iTotal * iConstant;\r\n-        } else {\r\n-            for (float element : array) {\r\n-                append(element);\r\n-            }\r\n+      }\r\n+    } finally {\r\n+      unregister(object);\r\n+    }\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * This method uses reflection to build a valid hash code.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\r\n+   * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\r\n+   * also not as efficient as testing explicitly.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * Transient members will be not be used, as they are likely derived fields, and not part of the value of the\r\n+   * <code>Object</code>.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * Static fields will not be tested. Superclass fields will be included.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally these should be different for each class,\r\n+   * however this is not vital. Prime numbers are preferred, especially for the multiplier.\r\n+   * </p>\r\n+   *\r\n+   * @param initialNonZeroOddNumber\r\n+   *            a non-zero, odd number used as the initial value\r\n+   * @param multiplierNonZeroOddNumber\r\n+   *            a non-zero, odd number used as the multiplier\r\n+   * @param object\r\n+   *            the Object to create a <code>hashCode</code> for\r\n+   * @return int hash code\r\n+   * @throws IllegalArgumentException\r\n+   *             if the Object is <code>null</code>\r\n+   * @throws IllegalArgumentException\r\n+   *             if the number is zero or even\r\n+   */\r\n+  public static int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, Object object) {\r\n+    return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, false, null);\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * This method uses reflection to build a valid hash code.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\r\n+   * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\r\n+   * also not as efficient as testing explicitly.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * If the TestTransients parameter is set to <code>true</code>, transient members will be tested, otherwise they\r\n+   * are ignored, as they are likely derived fields, and not part of the value of the <code>Object</code>.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * Static fields will not be tested. Superclass fields will be included.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally these should be different for each class,\r\n+   * however this is not vital. Prime numbers are preferred, especially for the multiplier.\r\n+   * </p>\r\n+   *\r\n+   * @param initialNonZeroOddNumber\r\n+   *            a non-zero, odd number used as the initial value\r\n+   * @param multiplierNonZeroOddNumber\r\n+   *            a non-zero, odd number used as the multiplier\r\n+   * @param object\r\n+   *            the Object to create a <code>hashCode</code> for\r\n+   * @param testTransients\r\n+   *            whether to include transient fields\r\n+   * @return int hash code\r\n+   * @throws IllegalArgumentException\r\n+   *             if the Object is <code>null</code>\r\n+   * @throws IllegalArgumentException\r\n+   *             if the number is zero or even\r\n+   */\r\n+  public static int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, Object object,\r\n+                                       boolean testTransients) {\r\n+    return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, testTransients, null);\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * This method uses reflection to build a valid hash code.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\r\n+   * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\r\n+   * also not as efficient as testing explicitly.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * If the TestTransients parameter is set to <code>true</code>, transient members will be tested, otherwise they\r\n+   * are ignored, as they are likely derived fields, and not part of the value of the <code>Object</code>.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * Static fields will not be included. Superclass fields will be included up to and including the specified\r\n+   * superclass. A null superclass is treated as java.lang.Object.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally these should be different for each class,\r\n+   * however this is not vital. Prime numbers are preferred, especially for the multiplier.\r\n+   * </p>\r\n+   *\r\n+   * @param <T>\r\n+   *            the type of the object involved\r\n+   * @param initialNonZeroOddNumber\r\n+   *            a non-zero, odd number used as the initial value\r\n+   * @param multiplierNonZeroOddNumber\r\n+   *            a non-zero, odd number used as the multiplier\r\n+   * @param object\r\n+   *            the Object to create a <code>hashCode</code> for\r\n+   * @param testTransients\r\n+   *            whether to include transient fields\r\n+   * @param reflectUpToClass\r\n+   *            the superclass to reflect up to (inclusive), may be <code>null</code>\r\n+   * @param excludeFields\r\n+   *            array of field names to exclude from use in calculation of hash code\r\n+   * @return int hash code\r\n+   * @throws IllegalArgumentException\r\n+   *             if the Object is <code>null</code>\r\n+   * @throws IllegalArgumentException\r\n+   *             if the number is zero or even\r\n+   * @since 2.0\r\n+   */\r\n+  public static <T> int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, T object,\r\n+                                           boolean testTransients, Class<? super T> reflectUpToClass, String... excludeFields) {\r\n+\r\n+    if (object == null) {\r\n+      throw new IllegalArgumentException(\"The object to build a hash code for must not be null\");\r\n+    }\r\n+    HashCodeBuilder builder = new HashCodeBuilder(initialNonZeroOddNumber, multiplierNonZeroOddNumber);\r\n+    Class<?> clazz = object.getClass();\r\n+    reflectionAppend(object, clazz, builder, testTransients, excludeFields);\r\n+    while (clazz.getSuperclass() != null && clazz != reflectUpToClass) {\r\n+      clazz = clazz.getSuperclass();\r\n+      reflectionAppend(object, clazz, builder, testTransients, excludeFields);\r\n+    }\r\n+    return builder.toHashCode();\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * This method uses reflection to build a valid hash code.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * This constructor uses two hard coded choices for the constants needed to build a hash code.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\r\n+   * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\r\n+   * also not as efficient as testing explicitly.\r\n+   * </p>\r\n+   *\r\n+   * <P>\r\n+   * If the TestTransients parameter is set to <code>true</code>, transient members will be tested, otherwise they\r\n+   * are ignored, as they are likely derived fields, and not part of the value of the <code>Object</code>.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * Static fields will not be tested. Superclass fields will be included.\r\n+   * </p>\r\n+   *\r\n+   * @param object\r\n+   *            the Object to create a <code>hashCode</code> for\r\n+   * @param testTransients\r\n+   *            whether to include transient fields\r\n+   * @return int hash code\r\n+   * @throws IllegalArgumentException\r\n+   *             if the object is <code>null</code>\r\n+   */\r\n+  public static int reflectionHashCode(Object object, boolean testTransients) {\r\n+    return reflectionHashCode(17, 37, object, testTransients, null);\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * This method uses reflection to build a valid hash code.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * This constructor uses two hard coded choices for the constants needed to build a hash code.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\r\n+   * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\r\n+   * also not as efficient as testing explicitly.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * Transient members will be not be used, as they are likely derived fields, and not part of the value of the\r\n+   * <code>Object</code>.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * Static fields will not be tested. Superclass fields will be included.\r\n+   * </p>\r\n+   *\r\n+   * @param object\r\n+   *            the Object to create a <code>hashCode</code> for\r\n+   * @param excludeFields\r\n+   *            Collection of String field names to exclude from use in calculation of hash code\r\n+   * @return int hash code\r\n+   * @throws IllegalArgumentException\r\n+   *             if the object is <code>null</code>\r\n+   */\r\n+  public static int reflectionHashCode(Object object, Collection<String> excludeFields) {\r\n+    return reflectionHashCode(object, ReflectionToStringBuilder.toNoNullStringArray(excludeFields));\r\n+  }\r\n+\r\n+  // -------------------------------------------------------------------------\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * This method uses reflection to build a valid hash code.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * This constructor uses two hard coded choices for the constants needed to build a hash code.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\r\n+   * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\r\n+   * also not as efficient as testing explicitly.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * Transient members will be not be used, as they are likely derived fields, and not part of the value of the\r\n+   * <code>Object</code>.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * Static fields will not be tested. Superclass fields will be included.\r\n+   * </p>\r\n+   *\r\n+   * @param object\r\n+   *            the Object to create a <code>hashCode</code> for\r\n+   * @param excludeFields\r\n+   *            array of field names to exclude from use in calculation of hash code\r\n+   * @return int hash code\r\n+   * @throws IllegalArgumentException\r\n+   *             if the object is <code>null</code>\r\n+   */\r\n+  public static int reflectionHashCode(Object object, String... excludeFields) {\r\n+    return reflectionHashCode(17, 37, object, false, null, excludeFields);\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Registers the given object. Used by the reflection methods to avoid infinite loops.\r\n+   * </p>\r\n+   *\r\n+   * @param value\r\n+   *            The object to register.\r\n+   */\r\n+  static void register(Object value) {\r\n+    synchronized (HashCodeBuilder.class) {\r\n+      if (getRegistry() == null) {\r\n+        REGISTRY.set(new HashSet<IDKey>());\r\n+      }\r\n+    }\r\n+    getRegistry().add(new IDKey(value));\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Unregisters the given object.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * Used by the reflection methods to avoid infinite loops.\r\n+   *\r\n+   * @param value\r\n+   *            The object to unregister.\r\n+   * @since 2.3\r\n+   */\r\n+  static void unregister(Object value) {\r\n+    Set<IDKey> registry = getRegistry();\r\n+    if (registry != null) {\r\n+      registry.remove(new IDKey(value));\r\n+      synchronized (HashCodeBuilder.class) {\r\n+        //read again\r\n+        registry = getRegistry();\r\n+        if (registry != null && registry.isEmpty()) {\r\n+          REGISTRY.remove();\r\n         }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for an <code>int</code>.\r\n-     * </p>\r\n-     *\r\n-     * @param value\r\n-     *            the int to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    public HashCodeBuilder append(int value) {\r\n-        iTotal = iTotal * iConstant + value;\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for an <code>int</code> array.\r\n-     * </p>\r\n-     *\r\n-     * @param array\r\n-     *            the array to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    public HashCodeBuilder append(int[] array) {\r\n-        if (array == null) {\r\n-            iTotal = iTotal * iConstant;\r\n+      }\r\n+    }\r\n+  }\r\n+\r\n+  /**\r\n+   * Constant to use in building the hashCode.\r\n+   */\r\n+  private final int iConstant;\r\n+\r\n+  /**\r\n+   * Running total of the hashCode.\r\n+   */\r\n+  private int iTotal = 0;\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Uses two hard coded choices for the constants needed to build a <code>hashCode</code>.\r\n+   * </p>\r\n+   */\r\n+  public HashCodeBuilder() {\r\n+    iConstant = 37;\r\n+    iTotal = 17;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally these should be different for each class,\r\n+   * however this is not vital.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * Prime numbers are preferred, especially for the multiplier.\r\n+   * </p>\r\n+   *\r\n+   * @param initialNonZeroOddNumber\r\n+   *            a non-zero, odd number used as the initial value\r\n+   * @param multiplierNonZeroOddNumber\r\n+   *            a non-zero, odd number used as the multiplier\r\n+   * @throws IllegalArgumentException\r\n+   *             if the number is zero or even\r\n+   */\r\n+  public HashCodeBuilder(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber) {\r\n+    if (initialNonZeroOddNumber == 0) {\r\n+      throw new IllegalArgumentException(\"HashCodeBuilder requires a non zero initial value\");\r\n+    }\r\n+    if (initialNonZeroOddNumber % 2 == 0) {\r\n+      throw new IllegalArgumentException(\"HashCodeBuilder requires an odd initial value\");\r\n+    }\r\n+    if (multiplierNonZeroOddNumber == 0) {\r\n+      throw new IllegalArgumentException(\"HashCodeBuilder requires a non zero multiplier\");\r\n+    }\r\n+    if (multiplierNonZeroOddNumber % 2 == 0) {\r\n+      throw new IllegalArgumentException(\"HashCodeBuilder requires an odd multiplier\");\r\n+    }\r\n+    iConstant = multiplierNonZeroOddNumber;\r\n+    iTotal = initialNonZeroOddNumber;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Append a <code>hashCode</code> for a <code>boolean</code>.\r\n+   * </p>\r\n+   * <p>\r\n+   * This adds <code>1</code> when true, and <code>0</code> when false to the <code>hashCode</code>.\r\n+   * </p>\r\n+   * <p>\r\n+   * This is in contrast to the standard <code>java.lang.Boolean.hashCode</code> handling, which computes\r\n+   * a <code>hashCode</code> value of <code>1231</code> for <code>java.lang.Boolean</code> instances\r\n+   * that represent <code>true</code> or <code>1237</code> for <code>java.lang.Boolean</code> instances\r\n+   * that represent <code>false</code>.\r\n+   * </p>\r\n+   * <p>\r\n+   * This is in accordance with the <quote>Effective Java</quote> design.\r\n+   * </p>\r\n+   *\r\n+   * @param value\r\n+   *            the boolean to add to the <code>hashCode</code>\r\n+   * @return this\r\n+   */\r\n+  public HashCodeBuilder append(boolean value) {\r\n+    iTotal = iTotal * iConstant + (value ? 0 : 1);\r\n+    return this;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Append a <code>hashCode</code> for a <code>boolean</code> array.\r\n+   * </p>\r\n+   *\r\n+   * @param array\r\n+   *            the array to add to the <code>hashCode</code>\r\n+   * @return this\r\n+   */\r\n+  public HashCodeBuilder append(boolean[] array) {\r\n+    if (array == null) {\r\n+      iTotal = iTotal * iConstant;\r\n+    } else {\r\n+      for (boolean element : array) {\r\n+        append(element);\r\n+      }\r\n+    }\r\n+    return this;\r\n+  }\r\n+\r\n+  // -------------------------------------------------------------------------\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Append a <code>hashCode</code> for a <code>byte</code>.\r\n+   * </p>\r\n+   *\r\n+   * @param value\r\n+   *            the byte to add to the <code>hashCode</code>\r\n+   * @return this\r\n+   */\r\n+  public HashCodeBuilder append(byte value) {\r\n+    iTotal = iTotal * iConstant + value;\r\n+    return this;\r\n+  }\r\n+\r\n+  // -------------------------------------------------------------------------\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Append a <code>hashCode</code> for a <code>byte</code> array.\r\n+   * </p>\r\n+   *\r\n+   * @param array\r\n+   *            the array to add to the <code>hashCode</code>\r\n+   * @return this\r\n+   */\r\n+  public HashCodeBuilder append(byte[] array) {\r\n+    if (array == null) {\r\n+      iTotal = iTotal * iConstant;\r\n+    } else {\r\n+      for (byte element : array) {\r\n+        append(element);\r\n+      }\r\n+    }\r\n+    return this;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Append a <code>hashCode</code> for a <code>char</code>.\r\n+   * </p>\r\n+   *\r\n+   * @param value\r\n+   *            the char to add to the <code>hashCode</code>\r\n+   * @return this\r\n+   */\r\n+  public HashCodeBuilder append(char value) {\r\n+    iTotal = iTotal * iConstant + value;\r\n+    return this;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Append a <code>hashCode</code> for a <code>char</code> array.\r\n+   * </p>\r\n+   *\r\n+   * @param array\r\n+   *            the array to add to the <code>hashCode</code>\r\n+   * @return this\r\n+   */\r\n+  public HashCodeBuilder append(char[] array) {\r\n+    if (array == null) {\r\n+      iTotal = iTotal * iConstant;\r\n+    } else {\r\n+      for (char element : array) {\r\n+        append(element);\r\n+      }\r\n+    }\r\n+    return this;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Append a <code>hashCode</code> for a <code>double</code>.\r\n+   * </p>\r\n+   *\r\n+   * @param value\r\n+   *            the double to add to the <code>hashCode</code>\r\n+   * @return this\r\n+   */\r\n+  public HashCodeBuilder append(double value) {\r\n+    return append(Double.doubleToLongBits(value));\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Append a <code>hashCode</code> for a <code>double</code> array.\r\n+   * </p>\r\n+   *\r\n+   * @param array\r\n+   *            the array to add to the <code>hashCode</code>\r\n+   * @return this\r\n+   */\r\n+  public HashCodeBuilder append(double[] array) {\r\n+    if (array == null) {\r\n+      iTotal = iTotal * iConstant;\r\n+    } else {\r\n+      for (double element : array) {\r\n+        append(element);\r\n+      }\r\n+    }\r\n+    return this;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Append a <code>hashCode</code> for a <code>float</code>.\r\n+   * </p>\r\n+   *\r\n+   * @param value\r\n+   *            the float to add to the <code>hashCode</code>\r\n+   * @return this\r\n+   */\r\n+  public HashCodeBuilder append(float value) {\r\n+    iTotal = iTotal * iConstant + Float.floatToIntBits(value);\r\n+    return this;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Append a <code>hashCode</code> for a <code>float</code> array.\r\n+   * </p>\r\n+   *\r\n+   * @param array\r\n+   *            the array to add to the <code>hashCode</code>\r\n+   * @return this\r\n+   */\r\n+  public HashCodeBuilder append(float[] array) {\r\n+    if (array == null) {\r\n+      iTotal = iTotal * iConstant;\r\n+    } else {\r\n+      for (float element : array) {\r\n+        append(element);\r\n+      }\r\n+    }\r\n+    return this;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Append a <code>hashCode</code> for an <code>int</code>.\r\n+   * </p>\r\n+   *\r\n+   * @param value\r\n+   *            the int to add to the <code>hashCode</code>\r\n+   * @return this\r\n+   */\r\n+  public HashCodeBuilder append(int value) {\r\n+    iTotal = iTotal * iConstant + value;\r\n+    return this;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Append a <code>hashCode</code> for an <code>int</code> array.\r\n+   * </p>\r\n+   *\r\n+   * @param array\r\n+   *            the array to add to the <code>hashCode</code>\r\n+   * @return this\r\n+   */\r\n+  public HashCodeBuilder append(int[] array) {\r\n+    if (array == null) {\r\n+      iTotal = iTotal * iConstant;\r\n+    } else {\r\n+      for (int element : array) {\r\n+        append(element);\r\n+      }\r\n+    }\r\n+    return this;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Append a <code>hashCode</code> for a <code>long</code>.\r\n+   * </p>\r\n+   *\r\n+   * @param value\r\n+   *            the long to add to the <code>hashCode</code>\r\n+   * @return this\r\n+   */\r\n+  // NOTE: This method uses >> and not >>> as Effective Java and\r\n+  //       Long.hashCode do. Ideally we should switch to >>> at\r\n+  //       some stage. There are backwards compat issues, so\r\n+  //       that will have to wait for the time being. cf LANG-342.\r\n+  public HashCodeBuilder append(long value) {\r\n+    iTotal = iTotal * iConstant + ((int) (value ^ (value >> 32)));\r\n+    return this;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Append a <code>hashCode</code> for a <code>long</code> array.\r\n+   * </p>\r\n+   *\r\n+   * @param array\r\n+   *            the array to add to the <code>hashCode</code>\r\n+   * @return this\r\n+   */\r\n+  public HashCodeBuilder append(long[] array) {\r\n+    if (array == null) {\r\n+      iTotal = iTotal * iConstant;\r\n+    } else {\r\n+      for (long element : array) {\r\n+        append(element);\r\n+      }\r\n+    }\r\n+    return this;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Append a <code>hashCode</code> for an <code>Object</code>.\r\n+   * </p>\r\n+   *\r\n+   * @param object\r\n+   *            the Object to add to the <code>hashCode</code>\r\n+   * @return this\r\n+   */\r\n+  public HashCodeBuilder append(Object object) {\r\n+    if (object == null) {\r\n+      iTotal = iTotal * iConstant;\r\n+\r\n+    } else {\r\n+      if (object.getClass().isArray()) {\r\n+        // 'Switch' on type of array, to dispatch to the correct handler\r\n+        // This handles multi dimensional arrays\r\n+        if (object instanceof long[]) {\r\n+          append((long[]) object);\r\n+        } else if (object instanceof int[]) {\r\n+          append((int[]) object);\r\n+        } else if (object instanceof short[]) {\r\n+          append((short[]) object);\r\n+        } else if (object instanceof char[]) {\r\n+          append((char[]) object);\r\n+        } else if (object instanceof byte[]) {\r\n+          append((byte[]) object);\r\n+        } else if (object instanceof double[]) {\r\n+          append((double[]) object);\r\n+        } else if (object instanceof float[]) {\r\n+          append((float[]) object);\r\n+        } else if (object instanceof boolean[]) {\r\n+          append((boolean[]) object);\r\n         } else {\r\n-            for (int element : array) {\r\n-                append(element);\r\n-            }\r\n+          // Not an array of primitives\r\n+          append((Object[]) object);\r\n         }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for a <code>long</code>.\r\n-     * </p>\r\n-     *\r\n-     * @param value\r\n-     *            the long to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    // NOTE: This method uses >> and not >>> as Effective Java and\r\n-    //       Long.hashCode do. Ideally we should switch to >>> at\r\n-    //       some stage. There are backwards compat issues, so\r\n-    //       that will have to wait for the time being. cf LANG-342.\r\n-    public HashCodeBuilder append(long value) {\r\n-        iTotal = iTotal * iConstant + ((int) (value ^ (value >> 32)));\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for a <code>long</code> array.\r\n-     * </p>\r\n-     *\r\n-     * @param array\r\n-     *            the array to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    public HashCodeBuilder append(long[] array) {\r\n-        if (array == null) {\r\n-            iTotal = iTotal * iConstant;\r\n-        } else {\r\n-            for (long element : array) {\r\n-                append(element);\r\n-            }\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for an <code>Object</code>.\r\n-     * </p>\r\n-     *\r\n-     * @param object\r\n-     *            the Object to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    public HashCodeBuilder append(Object object) {\r\n-        if (object == null) {\r\n-            iTotal = iTotal * iConstant;\r\n-\r\n-        } else {\r\n-            if(object.getClass().isArray()) {\r\n-                // 'Switch' on type of array, to dispatch to the correct handler\r\n-                // This handles multi dimensional arrays\r\n-                if (object instanceof long[]) {\r\n-                    append((long[]) object);\r\n-                } else if (object instanceof int[]) {\r\n-                    append((int[]) object);\r\n-                } else if (object instanceof short[]) {\r\n-                    append((short[]) object);\r\n-                } else if (object instanceof char[]) {\r\n-                    append((char[]) object);\r\n-                } else if (object instanceof byte[]) {\r\n-                    append((byte[]) object);\r\n-                } else if (object instanceof double[]) {\r\n-                    append((double[]) object);\r\n-                } else if (object instanceof float[]) {\r\n-                    append((float[]) object);\r\n-                } else if (object instanceof boolean[]) {\r\n-                    append((boolean[]) object);\r\n-                } else {\r\n-                    // Not an array of primitives\r\n-                    append((Object[]) object);\r\n-                }\r\n-            } else {\r\n-                iTotal = iTotal * iConstant + object.hashCode();\r\n-            }\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for an <code>Object</code> array.\r\n-     * </p>\r\n-     *\r\n-     * @param array\r\n-     *            the array to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    public HashCodeBuilder append(Object[] array) {\r\n-        if (array == null) {\r\n-            iTotal = iTotal * iConstant;\r\n-        } else {\r\n-            for (Object element : array) {\r\n-                append(element);\r\n-            }\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for a <code>short</code>.\r\n-     * </p>\r\n-     *\r\n-     * @param value\r\n-     *            the short to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    public HashCodeBuilder append(short value) {\r\n-        iTotal = iTotal * iConstant + value;\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for a <code>short</code> array.\r\n-     * </p>\r\n-     *\r\n-     * @param array\r\n-     *            the array to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    public HashCodeBuilder append(short[] array) {\r\n-        if (array == null) {\r\n-            iTotal = iTotal * iConstant;\r\n-        } else {\r\n-            for (short element : array) {\r\n-                append(element);\r\n-            }\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Adds the result of super.hashCode() to this builder.\r\n-     * </p>\r\n-     *\r\n-     * @param superHashCode\r\n-     *            the result of calling <code>super.hashCode()</code>\r\n-     * @return this HashCodeBuilder, used to chain calls.\r\n-     * @since 2.0\r\n-     */\r\n-    public HashCodeBuilder appendSuper(int superHashCode) {\r\n-        iTotal = iTotal * iConstant + superHashCode;\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Return the computed <code>hashCode</code>.\r\n-     * </p>\r\n-     *\r\n-     * @return <code>hashCode</code> based on the fields appended\r\n-     */\r\n-    public int toHashCode() {\r\n-        return iTotal;\r\n-    }\r\n-\r\n-    /**\r\n-     * Returns the computed <code>hashCode</code>.\r\n-     *\r\n-     * @return <code>hashCode</code> based on the fields appended\r\n-     *\r\n-     * @since 3.0\r\n-     */\r\n-    public Integer build() {\r\n-        return Integer.valueOf(toHashCode());\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * The computed <code>hashCode</code> from toHashCode() is returned due to the likelihood\r\n-     * of bugs in mis-calling toHashCode() and the unlikeliness of it mattering what the hashCode for\r\n-     * HashCodeBuilder itself is.</p>\r\n-     *\r\n-     * @return <code>hashCode</code> based on the fields appended\r\n-     * @since 2.5\r\n-     */\r\n-    @Override\r\n-    public int hashCode() {\r\n-        return toHashCode();\r\n-    }\r\n+      } else {\r\n+        iTotal = iTotal * iConstant + object.hashCode();\r\n+      }\r\n+    }\r\n+    return this;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Append a <code>hashCode</code> for an <code>Object</code> array.\r\n+   * </p>\r\n+   *\r\n+   * @param array\r\n+   *            the array to add to the <code>hashCode</code>\r\n+   * @return this\r\n+   */\r\n+  public HashCodeBuilder append(Object[] array) {\r\n+    if (array == null) {\r\n+      iTotal = iTotal * iConstant;\r\n+    } else {\r\n+      for (Object element : array) {\r\n+        append(element);\r\n+      }\r\n+    }\r\n+    return this;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Append a <code>hashCode</code> for a <code>short</code>.\r\n+   * </p>\r\n+   *\r\n+   * @param value\r\n+   *            the short to add to the <code>hashCode</code>\r\n+   * @return this\r\n+   */\r\n+  public HashCodeBuilder append(short value) {\r\n+    iTotal = iTotal * iConstant + value;\r\n+    return this;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Append a <code>hashCode</code> for a <code>short</code> array.\r\n+   * </p>\r\n+   *\r\n+   * @param array\r\n+   *            the array to add to the <code>hashCode</code>\r\n+   * @return this\r\n+   */\r\n+  public HashCodeBuilder append(short[] array) {\r\n+    if (array == null) {\r\n+      iTotal = iTotal * iConstant;\r\n+    } else {\r\n+      for (short element : array) {\r\n+        append(element);\r\n+      }\r\n+    }\r\n+    return this;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Adds the result of super.hashCode() to this builder.\r\n+   * </p>\r\n+   *\r\n+   * @param superHashCode\r\n+   *            the result of calling <code>super.hashCode()</code>\r\n+   * @return this HashCodeBuilder, used to chain calls.\r\n+   * @since 2.0\r\n+   */\r\n+  public HashCodeBuilder appendSuper(int superHashCode) {\r\n+    iTotal = iTotal * iConstant + superHashCode;\r\n+    return this;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Return the computed <code>hashCode</code>.\r\n+   * </p>\r\n+   *\r\n+   * @return <code>hashCode</code> based on the fields appended\r\n+   */\r\n+  public int toHashCode() {\r\n+    return iTotal;\r\n+  }\r\n+\r\n+  /**\r\n+   * Returns the computed <code>hashCode</code>.\r\n+   *\r\n+   * @return <code>hashCode</code> based on the fields appended\r\n+   *\r\n+   * @since 3.0\r\n+   */\r\n+  public Integer build() {\r\n+    return Integer.valueOf(toHashCode());\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * The computed <code>hashCode</code> from toHashCode() is returned due to the likelihood\r\n+   * of bugs in mis-calling toHashCode() and the unlikeliness of it mattering what the hashCode for\r\n+   * HashCodeBuilder itself is.</p>\r\n+   *\r\n+   * @return <code>hashCode</code> based on the fields appended\r\n+   * @since 2.5\r\n+   */\r\n+  @Override\r\n+  public int hashCode() {\r\n+    return toHashCode();\r\n+  }\r\n \r\n }\r\n",
            "diff_size": 1380
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "196",
                    "severity": "warning",
                    "message": "Line is longer than 200 characters (found 227).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/errored/1/49/HashCodeBuilder.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/naturalize/49/HashCodeBuilder.java\nindex c69eb5b1457..b717a77a013 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/errored/1/49/HashCodeBuilder.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/naturalize/49/HashCodeBuilder.java\n@@ -193,11 +193,8 @@ public class HashCodeBuilder implements Builder<Integer> {\n             Field[] fields = clazz.getDeclaredFields();\r\n             AccessibleObject.setAccessible(fields, true);\r\n             for (Field field : fields) {\r\n-                if (!ArrayUtils.contains(excludeFields, field.getName())\r\n-                    && (field.getName().indexOf('$') == -1)\r\n-                    && (useTransients || !Modifier.isTransient(field.getModifiers()))\r\n-                    && (!Modifier.isStatic(field.getModifiers()))) {\r\n-                    try {\r\n+                if (!ArrayUtils.contains(excludeFields, field.getName()) && (field.getName().indexOf('$') == -1) && (useTransients || !Modifier.isTransient(field.getModifiers())) && (!Modifier.isStatic(field.getModifiers()))) {\n+    try {\r\n                         Object fieldValue = field.get(object);\r\n                         builder.append(fieldValue);\r\n                     } catch (IllegalAccessException e) {\r\n@@ -345,9 +342,8 @@ public class HashCodeBuilder implements Builder<Integer> {\n      * @since 2.0\r\n      */\r\n     public static <T> int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, T object,\r\n-            boolean testTransients, Class<? super T> reflectUpToClass, String... excludeFields) {\r\n-\r\n-        if (object == null) {\r\n+            boolean testTransients, Class<? super T> reflectUpToClass, String... excludeFields) {\n+    if (object == null) {\r\n             throw new IllegalArgumentException(\"The object to build a hash code for must not be null\");\r\n         }\r\n         HashCodeBuilder builder = new HashCodeBuilder(initialNonZeroOddNumber, multiplierNonZeroOddNumber);\r\n@@ -800,7 +796,7 @@ public class HashCodeBuilder implements Builder<Integer> {\n     //       some stage. There are backwards compat issues, so\r\n     //       that will have to wait for the time being. cf LANG-342.\r\n     public HashCodeBuilder append(long value) {\r\n-        iTotal = iTotal * iConstant + ((int) (value ^ (value >> 32)));\r\n+        iTotal = iTotal * iConstant + ((int)(value ^ (value >> 32)));\r\n         return this;\r\n     }\r\n \r\n@@ -838,7 +834,7 @@ public class HashCodeBuilder implements Builder<Integer> {\n             iTotal = iTotal * iConstant;\r\n \r\n         } else {\r\n-            if(object.getClass().isArray()) {\r\n+            if (object.getClass().isArray()) {\r\n                 // 'Switch' on type of array, to dispatch to the correct handler\r\n                 // This handles multi dimensional arrays\r\n                 if (object instanceof long[]) {\r\n@@ -973,4 +969,4 @@ public class HashCodeBuilder implements Builder<Integer> {\n         return toHashCode();\r\n     }\r\n \r\n-}\r\n+}\n\\ No newline at end of file\n",
            "diff_size": 11
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "361",
                    "severity": "warning",
                    "message": "Line is longer than 200 characters (found 201).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "931",
                    "severity": "warning",
                    "message": "Comment has incorrect indentation level 20, expected is 48, indentation should be the same level as line 932.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/errored/1/49/HashCodeBuilder.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/codebuff/49/HashCodeBuilder.java\nindex c69eb5b1457..d9ebb1a7119 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/errored/1/49/HashCodeBuilder.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/codebuff/49/HashCodeBuilder.java\n@@ -30,15 +30,14 @@\n  * limitations under the License.\r\n  */\r\n \r\n-package edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.builder;\r\n-\r\n-import java.lang.reflect.AccessibleObject;\r\n-import java.lang.reflect.Field;\r\n-import java.lang.reflect.Modifier;\r\n-import java.util.Collection;\r\n-import java.util.HashSet;\r\n-import java.util.Set;\r\n-\r\n+package edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.builder;\n+\n+import java.lang.reflect.AccessibleObject;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n import edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.ArrayUtils;\r\n \r\n /**\r\n@@ -111,7 +110,9 @@ import edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.ArrayU\n  *\r\n  * @since 1.0\r\n  * @version $Id: HashCodeBuilder.java 1144929 2011-07-10 18:26:16Z ggregory $\r\n- */\r\n+ */\n+\n+\n public class HashCodeBuilder implements Builder<Integer> {\r\n     /**\r\n      * <p>\r\n@@ -119,7 +120,8 @@ public class HashCodeBuilder implements Builder<Integer> {\n      * </p>\r\n      *\r\n      * @since 2.3\r\n-     */\r\n+     */\n+\n     private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>();\r\n \r\n     /*\r\n@@ -146,9 +148,9 @@ public class HashCodeBuilder implements Builder<Integer> {\n      *\r\n      * @return Set the registry of objects being traversed\r\n      * @since 2.3\r\n-     */\r\n-    static Set<IDKey> getRegistry() {\r\n-        return REGISTRY.get();\r\n+     */\n+    static Set<IDKey> getRegistry() {\n+        return REGISTRY.get();\n     }\r\n \r\n     /**\r\n@@ -161,10 +163,12 @@ public class HashCodeBuilder implements Builder<Integer> {\n      *            The object to lookup in the registry.\r\n      * @return boolean <code>true</code> if the registry contains the given object.\r\n      * @since 2.3\r\n-     */\r\n-    static boolean isRegistered(Object value) {\r\n-        Set<IDKey> registry = getRegistry();\r\n-        return registry != null && registry.contains(new IDKey(value));\r\n+     */\n+\n+\n+    static boolean isRegistered(Object value) {\n+        Set<IDKey> registry = getRegistry();\n+        return registry != null && registry.contains(new IDKey(value));\n     }\r\n \r\n     /**\r\n@@ -182,34 +186,37 @@ public class HashCodeBuilder implements Builder<Integer> {\n      *            whether to use transient fields\r\n      * @param excludeFields\r\n      *            Collection of String field names to exclude from use in calculation of hash code\r\n-     */\r\n-    private static void reflectionAppend(Object object, Class<?> clazz, HashCodeBuilder builder, boolean useTransients,\r\n-            String[] excludeFields) {\r\n-        if (isRegistered(object)) {\r\n-            return;\r\n-        }\r\n-        try {\r\n-            register(object);\r\n-            Field[] fields = clazz.getDeclaredFields();\r\n-            AccessibleObject.setAccessible(fields, true);\r\n-            for (Field field : fields) {\r\n-                if (!ArrayUtils.contains(excludeFields, field.getName())\r\n-                    && (field.getName().indexOf('$') == -1)\r\n-                    && (useTransients || !Modifier.isTransient(field.getModifiers()))\r\n-                    && (!Modifier.isStatic(field.getModifiers()))) {\r\n-                    try {\r\n-                        Object fieldValue = field.get(object);\r\n-                        builder.append(fieldValue);\r\n+     */\n+\n+\n+    private static void reflectionAppend(Object object,\n+                                         Class<?> clazz,\n+                                         HashCodeBuilder builder,\n+                                         boolean useTransients, String[] excludeFields) {\n+        if (isRegistered(object)) {\n+            return;\n+        }\n+        try {\n+            register(object);\n+            Field[] fields = clazz.getDeclaredFields();\n+            AccessibleObject.setAccessible(fields, true);\n+\n+            for (Field field : fields) {\n+                if (!ArrayUtils.contains(excludeFields, field.getName()) && (field.getName().indexOf('$') == -1) && (useTransients || !Modifier.isTransient(field.getModifiers()))\n+                        && (!Modifier.isStatic(field.getModifiers()))) {\n+                    try {\n+                        Object fieldValue = field.get(object);\n+                        builder.append(fieldValue);\n                     } catch (IllegalAccessException e) {\r\n                         // this can't happen. Would get a Security exception instead\r\n-                        // throw a runtime exception in case the impossible happens.\r\n-                        throw new InternalError(\"Unexpected IllegalAccessException\");\r\n-                    }\r\n-                }\r\n-            }\r\n-        } finally {\r\n-            unregister(object);\r\n-        }\r\n+                        // throw a runtime exception in case the impossible happens.\n+                        throw new InternalError(\"Unexpected IllegalAccessException\");\n+                    }\n+                }\n+            }\n+        } finally {\n+            unregister(object);\n+        }\n     }\r\n \r\n     /**\r\n@@ -248,9 +255,11 @@ public class HashCodeBuilder implements Builder<Integer> {\n      *             if the Object is <code>null</code>\r\n      * @throws IllegalArgumentException\r\n      *             if the number is zero or even\r\n-     */\r\n-    public static int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, Object object) {\r\n-        return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, false, null);\r\n+     */\n+\n+\n+    public static int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, Object object) {\n+        return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, false, null);\n     }\r\n \r\n     /**\r\n@@ -291,10 +300,13 @@ public class HashCodeBuilder implements Builder<Integer> {\n      *             if the Object is <code>null</code>\r\n      * @throws IllegalArgumentException\r\n      *             if the number is zero or even\r\n-     */\r\n-    public static int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, Object object,\r\n-            boolean testTransients) {\r\n-        return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, testTransients, null);\r\n+     */\n+\n+\n+    public static int reflectionHashCode(int initialNonZeroOddNumber,\n+                                         int multiplierNonZeroOddNumber,\n+                                         Object object, boolean testTransients) {\n+        return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, testTransients, null);\n     }\r\n \r\n     /**\r\n@@ -343,21 +355,31 @@ public class HashCodeBuilder implements Builder<Integer> {\n      * @throws IllegalArgumentException\r\n      *             if the number is zero or even\r\n      * @since 2.0\r\n-     */\r\n-    public static <T> int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, T object,\r\n-            boolean testTransients, Class<? super T> reflectUpToClass, String... excludeFields) {\r\n-\r\n-        if (object == null) {\r\n-            throw new IllegalArgumentException(\"The object to build a hash code for must not be null\");\r\n-        }\r\n-        HashCodeBuilder builder = new HashCodeBuilder(initialNonZeroOddNumber, multiplierNonZeroOddNumber);\r\n-        Class<?> clazz = object.getClass();\r\n-        reflectionAppend(object, clazz, builder, testTransients, excludeFields);\r\n-        while (clazz.getSuperclass() != null && clazz != reflectUpToClass) {\r\n-            clazz = clazz.getSuperclass();\r\n-            reflectionAppend(object, clazz, builder, testTransients, excludeFields);\r\n-        }\r\n-        return builder.toHashCode();\r\n+     */\n+\n+\n+    public static <T> int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, T object, boolean testTransients, Class<? super T> reflectUpToClass, String... excludeFields) {\n+        if (object == null) {\n+            throw new IllegalArgumentException(\"The object to build a hash code for must not be null\");\n+        }\n+        HashCodeBuilder builder = new HashCodeBuilder(initialNonZeroOddNumber,\n+                                                      multiplierNonZeroOddNumber);\n+        Class<?> clazz = object.getClass();\n+        reflectionAppend(object,\n+                         clazz,\n+                         builder,\n+                         testTransients,\n+                         excludeFields);\n+\n+        while (clazz.getSuperclass() != null && clazz != reflectUpToClass) {\n+            clazz = clazz.getSuperclass();\n+            reflectionAppend(object,\n+                             clazz,\n+                             builder,\n+                             testTransients,\n+                             excludeFields);\n+        }\n+        return builder.toHashCode();\n     }\r\n \r\n     /**\r\n@@ -391,9 +413,11 @@ public class HashCodeBuilder implements Builder<Integer> {\n      * @return int hash code\r\n      * @throws IllegalArgumentException\r\n      *             if the object is <code>null</code>\r\n-     */\r\n-    public static int reflectionHashCode(Object object, boolean testTransients) {\r\n-        return reflectionHashCode(17, 37, object, testTransients, null);\r\n+     */\n+\n+\n+    public static int reflectionHashCode(Object object, boolean testTransients) {\n+        return reflectionHashCode(17, 37, object, testTransients, null);\n     }\r\n \r\n     /**\r\n@@ -427,9 +451,11 @@ public class HashCodeBuilder implements Builder<Integer> {\n      * @return int hash code\r\n      * @throws IllegalArgumentException\r\n      *             if the object is <code>null</code>\r\n-     */\r\n-    public static int reflectionHashCode(Object object, Collection<String> excludeFields) {\r\n-        return reflectionHashCode(object, ReflectionToStringBuilder.toNoNullStringArray(excludeFields));\r\n+     */\n+\n+\n+    public static int reflectionHashCode(Object object, Collection<String> excludeFields) {\n+        return reflectionHashCode(object, ReflectionToStringBuilder.toNoNullStringArray(excludeFields));\n     }\r\n \r\n     // -------------------------------------------------------------------------\r\n@@ -465,9 +491,11 @@ public class HashCodeBuilder implements Builder<Integer> {\n      * @return int hash code\r\n      * @throws IllegalArgumentException\r\n      *             if the object is <code>null</code>\r\n-     */\r\n-    public static int reflectionHashCode(Object object, String... excludeFields) {\r\n-        return reflectionHashCode(17, 37, object, false, null, excludeFields);\r\n+     */\n+\n+\n+    public static int reflectionHashCode(Object object, String... excludeFields) {\n+        return reflectionHashCode(17, 37, object, false, null, excludeFields);\n     }\r\n \r\n     /**\r\n@@ -477,14 +505,17 @@ public class HashCodeBuilder implements Builder<Integer> {\n      *\r\n      * @param value\r\n      *            The object to register.\r\n-     */\r\n-    static void register(Object value) {\r\n-        synchronized (HashCodeBuilder.class) {\r\n-            if (getRegistry() == null) {\r\n-                REGISTRY.set(new HashSet<IDKey>());\r\n-            }\r\n-        }\r\n-        getRegistry().add(new IDKey(value));\r\n+     */\n+\n+\n+    static void register(Object value) {\n+        synchronized (HashCodeBuilder.class) {\n+            if (getRegistry() == null) {\n+                REGISTRY.set(new HashSet<IDKey>());\n+            }\n+        }\n+\n+        getRegistry().add(new IDKey(value));\n     }\r\n \r\n     /**\r\n@@ -498,39 +529,46 @@ public class HashCodeBuilder implements Builder<Integer> {\n      * @param value\r\n      *            The object to unregister.\r\n      * @since 2.3\r\n-     */\r\n-    static void unregister(Object value) {\r\n-        Set<IDKey> registry = getRegistry();\r\n-        if (registry != null) {\r\n-            registry.remove(new IDKey(value));\r\n+     */\n+\n+\n+    static void unregister(Object value) {\n+        Set<IDKey> registry = getRegistry();\n+\n+        if (registry != null) {\n+            registry.remove(new IDKey(value));\n             synchronized (HashCodeBuilder.class) {\r\n-                //read again\r\n-                registry = getRegistry();\r\n-                if (registry != null && registry.isEmpty()) {\r\n-                    REGISTRY.remove();\r\n-                }\r\n-            }\r\n-        }\r\n+                //read again\n+                registry = getRegistry();\n+\n+                if (registry != null && registry.isEmpty()) {\n+                    REGISTRY.remove();\n+                }\n+            }\n+        }\n     }\r\n \r\n     /**\r\n      * Constant to use in building the hashCode.\r\n-     */\r\n+     */\n+\n+\n     private final int iConstant;\r\n \r\n     /**\r\n      * Running total of the hashCode.\r\n-     */\r\n+     */\n     private int iTotal = 0;\r\n \r\n     /**\r\n      * <p>\r\n      * Uses two hard coded choices for the constants needed to build a <code>hashCode</code>.\r\n      * </p>\r\n-     */\r\n-    public HashCodeBuilder() {\r\n-        iConstant = 37;\r\n-        iTotal = 17;\r\n+     */\n+\n+    public HashCodeBuilder() {\n+        iConstant = 37;\n+        iTotal = 17;\n     }\r\n \r\n     /**\r\n@@ -549,22 +587,24 @@ public class HashCodeBuilder implements Builder<Integer> {\n      *            a non-zero, odd number used as the multiplier\r\n      * @throws IllegalArgumentException\r\n      *             if the number is zero or even\r\n-     */\r\n-    public HashCodeBuilder(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber) {\r\n-        if (initialNonZeroOddNumber == 0) {\r\n-            throw new IllegalArgumentException(\"HashCodeBuilder requires a non zero initial value\");\r\n-        }\r\n-        if (initialNonZeroOddNumber % 2 == 0) {\r\n-            throw new IllegalArgumentException(\"HashCodeBuilder requires an odd initial value\");\r\n-        }\r\n-        if (multiplierNonZeroOddNumber == 0) {\r\n-            throw new IllegalArgumentException(\"HashCodeBuilder requires a non zero multiplier\");\r\n-        }\r\n-        if (multiplierNonZeroOddNumber % 2 == 0) {\r\n-            throw new IllegalArgumentException(\"HashCodeBuilder requires an odd multiplier\");\r\n-        }\r\n-        iConstant = multiplierNonZeroOddNumber;\r\n-        iTotal = initialNonZeroOddNumber;\r\n+     */\n+\n+    public HashCodeBuilder(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber) {\n+        if (initialNonZeroOddNumber == 0) {\n+            throw new IllegalArgumentException(\"HashCodeBuilder requires a non zero initial value\");\n+        }\n+        if (initialNonZeroOddNumber % 2 == 0) {\n+            throw new IllegalArgumentException(\"HashCodeBuilder requires an odd initial value\");\n+        }\n+        if (multiplierNonZeroOddNumber == 0) {\n+            throw new IllegalArgumentException(\"HashCodeBuilder requires a non zero multiplier\");\n+        }\n+        if (multiplierNonZeroOddNumber % 2 == 0) {\n+            throw new IllegalArgumentException(\"HashCodeBuilder requires an odd multiplier\");\n+        }\n+\n+        iConstant = multiplierNonZeroOddNumber;\n+        iTotal = initialNonZeroOddNumber;\n     }\r\n \r\n     /**\r\n@@ -587,10 +627,13 @@ public class HashCodeBuilder implements Builder<Integer> {\n      * @param value\r\n      *            the boolean to add to the <code>hashCode</code>\r\n      * @return this\r\n-     */\r\n-    public HashCodeBuilder append(boolean value) {\r\n-        iTotal = iTotal * iConstant + (value ? 0 : 1);\r\n-        return this;\r\n+     */\n+\n+\n+\n+    public HashCodeBuilder append(boolean value) {\n+        iTotal = iTotal * iConstant + (value ? 0 : 1);\n+        return this;\n     }\r\n \r\n     /**\r\n@@ -601,16 +644,18 @@ public class HashCodeBuilder implements Builder<Integer> {\n      * @param array\r\n      *            the array to add to the <code>hashCode</code>\r\n      * @return this\r\n-     */\r\n-    public HashCodeBuilder append(boolean[] array) {\r\n-        if (array == null) {\r\n-            iTotal = iTotal * iConstant;\r\n-        } else {\r\n-            for (boolean element : array) {\r\n-                append(element);\r\n-            }\r\n-        }\r\n-        return this;\r\n+     */\n+\n+\n+    public HashCodeBuilder append(boolean[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (boolean element : array) {\n+                append(element);\n+            }\n+        }\n+        return this;\n     }\r\n \r\n     // -------------------------------------------------------------------------\r\n@@ -623,10 +668,12 @@ public class HashCodeBuilder implements Builder<Integer> {\n      * @param value\r\n      *            the byte to add to the <code>hashCode</code>\r\n      * @return this\r\n-     */\r\n-    public HashCodeBuilder append(byte value) {\r\n-        iTotal = iTotal * iConstant + value;\r\n-        return this;\r\n+     */\n+\n+\n+    public HashCodeBuilder append(byte value) {\n+        iTotal = iTotal * iConstant + value;\n+        return this;\n     }\r\n \r\n     // -------------------------------------------------------------------------\r\n@@ -639,16 +686,18 @@ public class HashCodeBuilder implements Builder<Integer> {\n      * @param array\r\n      *            the array to add to the <code>hashCode</code>\r\n      * @return this\r\n-     */\r\n-    public HashCodeBuilder append(byte[] array) {\r\n-        if (array == null) {\r\n-            iTotal = iTotal * iConstant;\r\n-        } else {\r\n-            for (byte element : array) {\r\n-                append(element);\r\n-            }\r\n-        }\r\n-        return this;\r\n+     */\n+\n+\n+    public HashCodeBuilder append(byte[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (byte element : array) {\n+                append(element);\n+            }\n+        }\n+        return this;\n     }\r\n \r\n     /**\r\n@@ -659,10 +708,12 @@ public class HashCodeBuilder implements Builder<Integer> {\n      * @param value\r\n      *            the char to add to the <code>hashCode</code>\r\n      * @return this\r\n-     */\r\n-    public HashCodeBuilder append(char value) {\r\n-        iTotal = iTotal * iConstant + value;\r\n-        return this;\r\n+     */\n+\n+\n+    public HashCodeBuilder append(char value) {\n+        iTotal = iTotal * iConstant + value;\n+        return this;\n     }\r\n \r\n     /**\r\n@@ -673,16 +724,18 @@ public class HashCodeBuilder implements Builder<Integer> {\n      * @param array\r\n      *            the array to add to the <code>hashCode</code>\r\n      * @return this\r\n-     */\r\n-    public HashCodeBuilder append(char[] array) {\r\n-        if (array == null) {\r\n-            iTotal = iTotal * iConstant;\r\n-        } else {\r\n-            for (char element : array) {\r\n-                append(element);\r\n-            }\r\n-        }\r\n-        return this;\r\n+     */\n+\n+\n+    public HashCodeBuilder append(char[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (char element : array) {\n+                append(element);\n+            }\n+        }\n+        return this;\n     }\r\n \r\n     /**\r\n@@ -693,9 +746,11 @@ public class HashCodeBuilder implements Builder<Integer> {\n      * @param value\r\n      *            the double to add to the <code>hashCode</code>\r\n      * @return this\r\n-     */\r\n-    public HashCodeBuilder append(double value) {\r\n-        return append(Double.doubleToLongBits(value));\r\n+     */\n+\n+\n+    public HashCodeBuilder append(double value) {\n+        return append(Double.doubleToLongBits(value));\n     }\r\n \r\n     /**\r\n@@ -706,16 +761,18 @@ public class HashCodeBuilder implements Builder<Integer> {\n      * @param array\r\n      *            the array to add to the <code>hashCode</code>\r\n      * @return this\r\n-     */\r\n-    public HashCodeBuilder append(double[] array) {\r\n-        if (array == null) {\r\n-            iTotal = iTotal * iConstant;\r\n-        } else {\r\n-            for (double element : array) {\r\n-                append(element);\r\n-            }\r\n-        }\r\n-        return this;\r\n+     */\n+\n+\n+    public HashCodeBuilder append(double[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (double element : array) {\n+                append(element);\n+            }\n+        }\n+        return this;\n     }\r\n \r\n     /**\r\n@@ -726,10 +783,12 @@ public class HashCodeBuilder implements Builder<Integer> {\n      * @param value\r\n      *            the float to add to the <code>hashCode</code>\r\n      * @return this\r\n-     */\r\n-    public HashCodeBuilder append(float value) {\r\n-        iTotal = iTotal * iConstant + Float.floatToIntBits(value);\r\n-        return this;\r\n+     */\n+\n+\n+    public HashCodeBuilder append(float value) {\n+        iTotal = iTotal * iConstant + Float.floatToIntBits(value);\n+        return this;\n     }\r\n \r\n     /**\r\n@@ -740,16 +799,18 @@ public class HashCodeBuilder implements Builder<Integer> {\n      * @param array\r\n      *            the array to add to the <code>hashCode</code>\r\n      * @return this\r\n-     */\r\n-    public HashCodeBuilder append(float[] array) {\r\n-        if (array == null) {\r\n-            iTotal = iTotal * iConstant;\r\n-        } else {\r\n-            for (float element : array) {\r\n-                append(element);\r\n-            }\r\n-        }\r\n-        return this;\r\n+     */\n+\n+\n+    public HashCodeBuilder append(float[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (float element : array) {\n+                append(element);\n+            }\n+        }\n+        return this;\n     }\r\n \r\n     /**\r\n@@ -760,10 +821,12 @@ public class HashCodeBuilder implements Builder<Integer> {\n      * @param value\r\n      *            the int to add to the <code>hashCode</code>\r\n      * @return this\r\n-     */\r\n-    public HashCodeBuilder append(int value) {\r\n-        iTotal = iTotal * iConstant + value;\r\n-        return this;\r\n+     */\n+\n+\n+    public HashCodeBuilder append(int value) {\n+        iTotal = iTotal * iConstant + value;\n+        return this;\n     }\r\n \r\n     /**\r\n@@ -774,16 +837,18 @@ public class HashCodeBuilder implements Builder<Integer> {\n      * @param array\r\n      *            the array to add to the <code>hashCode</code>\r\n      * @return this\r\n-     */\r\n-    public HashCodeBuilder append(int[] array) {\r\n-        if (array == null) {\r\n-            iTotal = iTotal * iConstant;\r\n-        } else {\r\n-            for (int element : array) {\r\n-                append(element);\r\n-            }\r\n-        }\r\n-        return this;\r\n+     */\n+\n+\n+    public HashCodeBuilder append(int[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (int element : array) {\n+                append(element);\n+            }\n+        }\n+        return this;\n     }\r\n \r\n     /**\r\n@@ -798,10 +863,12 @@ public class HashCodeBuilder implements Builder<Integer> {\n     // NOTE: This method uses >> and not >>> as Effective Java and\r\n     //       Long.hashCode do. Ideally we should switch to >>> at\r\n     //       some stage. There are backwards compat issues, so\r\n-    //       that will have to wait for the time being. cf LANG-342.\r\n-    public HashCodeBuilder append(long value) {\r\n-        iTotal = iTotal * iConstant + ((int) (value ^ (value >> 32)));\r\n-        return this;\r\n+    //       that will have to wait for the time being. cf LANG-342.\n+\n+\n+    public HashCodeBuilder append(long value) {\n+        iTotal = iTotal * iConstant + ((int)(value ^ (value >> 32)));\n+        return this;\n     }\r\n \r\n     /**\r\n@@ -812,16 +879,18 @@ public class HashCodeBuilder implements Builder<Integer> {\n      * @param array\r\n      *            the array to add to the <code>hashCode</code>\r\n      * @return this\r\n-     */\r\n-    public HashCodeBuilder append(long[] array) {\r\n-        if (array == null) {\r\n-            iTotal = iTotal * iConstant;\r\n-        } else {\r\n-            for (long element : array) {\r\n-                append(element);\r\n-            }\r\n-        }\r\n-        return this;\r\n+     */\n+\n+\n+    public HashCodeBuilder append(long[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (long element : array) {\n+                append(element);\n+            }\n+        }\n+        return this;\n     }\r\n \r\n     /**\r\n@@ -832,40 +901,41 @@ public class HashCodeBuilder implements Builder<Integer> {\n      * @param object\r\n      *            the Object to add to the <code>hashCode</code>\r\n      * @return this\r\n-     */\r\n-    public HashCodeBuilder append(Object object) {\r\n-        if (object == null) {\r\n-            iTotal = iTotal * iConstant;\r\n-\r\n-        } else {\r\n-            if(object.getClass().isArray()) {\r\n+     */\n+\n+\n+    public HashCodeBuilder append(Object object) {\n+        if (object == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            if (object.getClass().isArray()) {\r\n                 // 'Switch' on type of array, to dispatch to the correct handler\r\n-                // This handles multi dimensional arrays\r\n-                if (object instanceof long[]) {\r\n-                    append((long[]) object);\r\n-                } else if (object instanceof int[]) {\r\n-                    append((int[]) object);\r\n-                } else if (object instanceof short[]) {\r\n-                    append((short[]) object);\r\n-                } else if (object instanceof char[]) {\r\n-                    append((char[]) object);\r\n-                } else if (object instanceof byte[]) {\r\n-                    append((byte[]) object);\r\n-                } else if (object instanceof double[]) {\r\n-                    append((double[]) object);\r\n-                } else if (object instanceof float[]) {\r\n-                    append((float[]) object);\r\n-                } else if (object instanceof boolean[]) {\r\n-                    append((boolean[]) object);\r\n-                } else {\r\n-                    // Not an array of primitives\r\n-                    append((Object[]) object);\r\n-                }\r\n-            } else {\r\n-                iTotal = iTotal * iConstant + object.hashCode();\r\n-            }\r\n-        }\r\n-        return this;\r\n+                // This handles multi dimensional arrays\n+                if (object instanceof long[]) {\n+                    append((long[]) object);\n+                } else if (object instanceof int[]) {\n+                           append((int[]) object);\n+                } else if (object instanceof short[]) {\n+                           append((short[]) object);\n+                       } else if (object instanceof char[]) {\n+                                  append((char[]) object);\n+                       } else if (object instanceof byte[]) {\n+                                  append((byte[]) object);\n+                              } else if (object instanceof double[]) {\n+                                         append((double[]) object);\n+                              } else if (object instanceof float[]) {\n+                                         append((float[]) object);\n+                                     } else if (object instanceof boolean[]) {\n+                                                append((boolean[]) object);\n+                                     } else {\r\n+                    // Not an array of primitives\n+                                                append((Object[]) object);\n+                                     }\n+            } else {\n+                iTotal = iTotal * iConstant + object.hashCode();\n+            }\n+        }\n+        return this;\n     }\r\n \r\n     /**\r\n@@ -876,16 +946,18 @@ public class HashCodeBuilder implements Builder<Integer> {\n      * @param array\r\n      *            the array to add to the <code>hashCode</code>\r\n      * @return this\r\n-     */\r\n-    public HashCodeBuilder append(Object[] array) {\r\n-        if (array == null) {\r\n-            iTotal = iTotal * iConstant;\r\n-        } else {\r\n-            for (Object element : array) {\r\n-                append(element);\r\n-            }\r\n-        }\r\n-        return this;\r\n+     */\n+\n+\n+    public HashCodeBuilder append(Object[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (Object element : array) {\n+                append(element);\n+            }\n+        }\n+        return this;\n     }\r\n \r\n     /**\r\n@@ -896,10 +968,12 @@ public class HashCodeBuilder implements Builder<Integer> {\n      * @param value\r\n      *            the short to add to the <code>hashCode</code>\r\n      * @return this\r\n-     */\r\n-    public HashCodeBuilder append(short value) {\r\n-        iTotal = iTotal * iConstant + value;\r\n-        return this;\r\n+     */\n+\n+\n+    public HashCodeBuilder append(short value) {\n+        iTotal = iTotal * iConstant + value;\n+        return this;\n     }\r\n \r\n     /**\r\n@@ -910,16 +984,18 @@ public class HashCodeBuilder implements Builder<Integer> {\n      * @param array\r\n      *            the array to add to the <code>hashCode</code>\r\n      * @return this\r\n-     */\r\n-    public HashCodeBuilder append(short[] array) {\r\n-        if (array == null) {\r\n-            iTotal = iTotal * iConstant;\r\n-        } else {\r\n-            for (short element : array) {\r\n-                append(element);\r\n-            }\r\n-        }\r\n-        return this;\r\n+     */\n+\n+\n+    public HashCodeBuilder append(short[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (short element : array) {\n+                append(element);\n+            }\n+        }\n+        return this;\n     }\r\n \r\n     /**\r\n@@ -931,10 +1007,12 @@ public class HashCodeBuilder implements Builder<Integer> {\n      *            the result of calling <code>super.hashCode()</code>\r\n      * @return this HashCodeBuilder, used to chain calls.\r\n      * @since 2.0\r\n-     */\r\n-    public HashCodeBuilder appendSuper(int superHashCode) {\r\n-        iTotal = iTotal * iConstant + superHashCode;\r\n-        return this;\r\n+     */\n+\n+\n+    public HashCodeBuilder appendSuper(int superHashCode) {\n+        iTotal = iTotal * iConstant + superHashCode;\n+        return this;\n     }\r\n \r\n     /**\r\n@@ -943,9 +1021,11 @@ public class HashCodeBuilder implements Builder<Integer> {\n      * </p>\r\n      *\r\n      * @return <code>hashCode</code> based on the fields appended\r\n-     */\r\n-    public int toHashCode() {\r\n-        return iTotal;\r\n+     */\n+\n+\n+    public int toHashCode() {\n+        return iTotal;\n     }\r\n \r\n     /**\r\n@@ -954,9 +1034,11 @@ public class HashCodeBuilder implements Builder<Integer> {\n      * @return <code>hashCode</code> based on the fields appended\r\n      *\r\n      * @since 3.0\r\n-     */\r\n-    public Integer build() {\r\n-        return Integer.valueOf(toHashCode());\r\n+     */\n+\n+\n+    public Integer build() {\n+        return Integer.valueOf(toHashCode());\n     }\r\n \r\n     /**\r\n@@ -967,10 +1049,11 @@ public class HashCodeBuilder implements Builder<Integer> {\n      *\r\n      * @return <code>hashCode</code> based on the fields appended\r\n      * @since 2.5\r\n-     */\r\n-    @Override\r\n-    public int hashCode() {\r\n-        return toHashCode();\r\n-    }\r\n-\r\n-}\r\n+     */\n+\n+\n+    @Override\n+    public int hashCode() {\n+        return toHashCode();\n+    }\n+}\n\\ No newline at end of file\n",
            "diff_size": 372
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/errored/1/49/HashCodeBuilder.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/styler_random/49/HashCodeBuilder.java\nindex c69eb5b1457..94dd3384dbd 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/errored/1/49/HashCodeBuilder.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/styler_random/49/HashCodeBuilder.java\n@@ -838,7 +838,7 @@ public class HashCodeBuilder implements Builder<Integer> {\n             iTotal = iTotal * iConstant;\r\n \r\n         } else {\r\n-            if(object.getClass().isArray()) {\r\n+            if (object.getClass().isArray()) {\r\n                 // 'Switch' on type of array, to dispatch to the correct handler\r\n                 // This handles multi dimensional arrays\r\n                 if (object instanceof long[]) {\r\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/errored/1/49/HashCodeBuilder.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/styler_three_grams/49/HashCodeBuilder.java\nindex c69eb5b1457..94dd3384dbd 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/errored/1/49/HashCodeBuilder.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/styler_three_grams/49/HashCodeBuilder.java\n@@ -838,7 +838,7 @@ public class HashCodeBuilder implements Builder<Integer> {\n             iTotal = iTotal * iConstant;\r\n \r\n         } else {\r\n-            if(object.getClass().isArray()) {\r\n+            if (object.getClass().isArray()) {\r\n                 // 'Switch' on type of array, to dispatch to the correct handler\r\n                 // This handles multi dimensional arrays\r\n                 if (object instanceof long[]) {\r\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "naturalize",
        "codebuff"
    ]
}