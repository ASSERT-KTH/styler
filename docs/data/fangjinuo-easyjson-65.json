{
    "project_name": "fangjinuo-easyjson",
    "error_id": "65",
    "information": {
        "errors": [
            {
                "line": "261",
                "column": "17",
                "severity": "warning",
                "message": "'.' is preceded with whitespace.",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.NoWhitespaceBeforeCheck"
            }
        ]
    },
    "source_code": "        }\n        exceptionMessage.append(\"but got: \").append(token.getClass().getName())\n                .append(\", for type token: \").append(token.toString()).append('.');\n\n        return new AssertionError(exceptionMessage.toString());\n    }",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/errored/1/65/TypeToken.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/styler/65/TypeToken.java\nindex 99be4766407..94e69602f65 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/errored/1/65/TypeToken.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/styler/65/TypeToken.java\n@@ -257,8 +257,7 @@ public class TypeToken<T> {\n         for (Class<?> clazz : expected) {\n             exceptionMessage.append(clazz.getName()).append(\", \");\n         }\n-        exceptionMessage.append(\"but got: \").append(token.getClass().getName())\n-                .append(\", for type token: \").append(token.toString()).append('.');\n+        exceptionMessage.append(\"but got: \").append(token.getClass().getName()).append(\", for type token: \").append(token.toString()).append('.');\n \n         return new AssertionError(exceptionMessage.toString());\n     }\n",
            "diff_size": 2
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "260",
                    "column": "13",
                    "severity": "warning",
                    "message": "'.' is preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.NoWhitespaceBeforeCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/errored/1/65/TypeToken.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/intellij/65/TypeToken.java\nindex 99be4766407..2bd2df4e29f 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/errored/1/65/TypeToken.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/intellij/65/TypeToken.java\n@@ -40,7 +40,6 @@ import java.util.Map;\n  *\n  * <p>This syntax cannot be used to create type literals that have wildcard\n  * parameters, such as {@code Class<?>} or {@code List<? extends CharSequence>}.\n- *\n  */\n public class TypeToken<T> {\n     final Class<? super T> rawType;\n@@ -103,7 +102,7 @@ public class TypeToken<T> {\n      * Check if this type is assignable from the given class object.\n      *\n      * @deprecated this implementation may be inconsistent with javac for types\n-     *     with wildcards.\n+     * with wildcards.\n      */\n     @Deprecated\n     public boolean isAssignableFrom(Class<?> cls) {\n@@ -114,7 +113,7 @@ public class TypeToken<T> {\n      * Check if this type is assignable from the given Type.\n      *\n      * @deprecated this implementation may be inconsistent with javac for types\n-     *     with wildcards.\n+     * with wildcards.\n      */\n     @Deprecated\n     public boolean isAssignableFrom(Type from) {\n@@ -130,13 +129,13 @@ public class TypeToken<T> {\n             return rawType.isAssignableFrom(Types.getRawType(from));\n         } else if (type instanceof ParameterizedType) {\n             return isAssignableFrom(from, (ParameterizedType) type,\n-                    new HashMap<String, Type>());\n+                new HashMap<String, Type>());\n         } else if (type instanceof GenericArrayType) {\n             return rawType.isAssignableFrom(Types.getRawType(from))\n-                    && isAssignableFrom(from, (GenericArrayType) type);\n+                && isAssignableFrom(from, (GenericArrayType) type);\n         } else {\n             throw buildUnexpectedTypeError(\n-                    type, Class.class, ParameterizedType.class, GenericArrayType.class);\n+                type, Class.class, ParameterizedType.class, GenericArrayType.class);\n         }\n     }\n \n@@ -144,7 +143,7 @@ public class TypeToken<T> {\n      * Check if this type is assignable from the given type token.\n      *\n      * @deprecated this implementation may be inconsistent with javac for types\n-     *     with wildcards.\n+     * with wildcards.\n      */\n     @Deprecated\n     public boolean isAssignableFrom(TypeToken<?> token) {\n@@ -169,7 +168,7 @@ public class TypeToken<T> {\n                 t = classType;\n             }\n             return isAssignableFrom(t, (ParameterizedType) toGenericComponentType,\n-                    new HashMap<String, Type>());\n+                new HashMap<String, Type>());\n         }\n         // No generic defined on \"to\"; therefore, return true and let other\n         // checks determine assignability\n@@ -249,16 +248,16 @@ public class TypeToken<T> {\n     }\n \n     private static AssertionError buildUnexpectedTypeError(\n-            Type token, Class<?>... expected) {\n+        Type token, Class<?>... expected) {\n \n         // Build exception message\n         StringBuilder exceptionMessage =\n-                new StringBuilder(\"Unexpected type. Expected one of: \");\n+            new StringBuilder(\"Unexpected type. Expected one of: \");\n         for (Class<?> clazz : expected) {\n             exceptionMessage.append(clazz.getName()).append(\", \");\n         }\n         exceptionMessage.append(\"but got: \").append(token.getClass().getName())\n-                .append(\", for type token: \").append(token.toString()).append('.');\n+            .append(\", for type token: \").append(token.toString()).append('.');\n \n         return new AssertionError(exceptionMessage.toString());\n     }\n@@ -269,21 +268,24 @@ public class TypeToken<T> {\n      */\n     private static boolean matches(Type from, Type to, Map<String, Type> typeMap) {\n         return to.equals(from)\n-                || (from instanceof TypeVariable\n-                && to.equals(typeMap.get(((TypeVariable<?>) from).getName())));\n+            || (from instanceof TypeVariable\n+            && to.equals(typeMap.get(((TypeVariable<?>) from).getName())));\n \n     }\n \n-    @Override public final int hashCode() {\n+    @Override\n+    public final int hashCode() {\n         return this.hashCode;\n     }\n \n-    @Override public final boolean equals(Object o) {\n+    @Override\n+    public final boolean equals(Object o) {\n         return o instanceof TypeToken<?>\n-                && Types.equals(type, ((TypeToken<?>) o).type);\n+            && Types.equals(type, ((TypeToken<?>) o).type);\n     }\n \n-    @Override public final String toString() {\n+    @Override\n+    public final String toString() {\n         return Types.typeToString(type);\n     }\n \n",
            "diff_size": 20
        },
        {
            "tool": "naturalize",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/errored/1/65/TypeToken.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/naturalize/65/TypeToken.java\nindex 99be4766407..4e4f69075a3 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/errored/1/65/TypeToken.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/naturalize/65/TypeToken.java\n@@ -129,12 +129,11 @@ public class TypeToken<T> {\n         if (type instanceof Class<?>) {\n             return rawType.isAssignableFrom(Types.getRawType(from));\n         } else if (type instanceof ParameterizedType) {\n-            return isAssignableFrom(from, (ParameterizedType) type,\n-                    new HashMap<String, Type>());\n-        } else if (type instanceof GenericArrayType) {\n+            return isAssignableFrom(from, (ParameterizedType) type, new HashMap<String, Type>());\n+    } else if (type instanceof GenericArrayType) {\n             return rawType.isAssignableFrom(Types.getRawType(from))\n                     && isAssignableFrom(from, (GenericArrayType) type);\n-        } else {\n+    } else {\n             throw buildUnexpectedTypeError(\n                     type, Class.class, ParameterizedType.class, GenericArrayType.class);\n         }\n@@ -168,8 +167,7 @@ public class TypeToken<T> {\n                 }\n                 t = classType;\n             }\n-            return isAssignableFrom(t, (ParameterizedType) toGenericComponentType,\n-                    new HashMap<String, Type>());\n+            return isAssignableFrom(t, (ParameterizedType) toGenericComponentType, new HashMap<String, Type>());\n         }\n         // No generic defined on \"to\"; therefore, return true and let other\n         // checks determine assignability\n@@ -180,10 +178,8 @@ public class TypeToken<T> {\n      * Private recursive helper function to actually do the type-safe checking\n      * of assignability.\n      */\n-    private static boolean isAssignableFrom(Type from, ParameterizedType to,\n-                                            Map<String, Type> typeVarMap) {\n-\n-        if (from == null) {\n+    private static boolean isAssignableFrom(Type from, ParameterizedType to, Map<String, Type> typeVarMap) {\n+    if (from == null) {\n             return false;\n         }\n \n@@ -233,9 +229,8 @@ public class TypeToken<T> {\n      * Checks if two parameterized types are exactly equal, under the variable\n      * replacement described in the typeVarMap.\n      */\n-    private static boolean typeEquals(ParameterizedType from,\n-                                      ParameterizedType to, Map<String, Type> typeVarMap) {\n-        if (from.getRawType().equals(to.getRawType())) {\n+    private static boolean typeEquals(ParameterizedType from, ParameterizedType to, Map<String, Type> typeVarMap) {\n+    if (from.getRawType().equals(to.getRawType())) {\n             Type[] fromArgs = from.getActualTypeArguments();\n             Type[] toArgs = to.getActualTypeArguments();\n             for (int i = 0; i < fromArgs.length; i++) {\n@@ -248,19 +243,15 @@ public class TypeToken<T> {\n         return false;\n     }\n \n-    private static AssertionError buildUnexpectedTypeError(\n-            Type token, Class<?>... expected) {\n-\n-        // Build exception message\n+    private static AssertionError buildUnexpectedTypeError(Type token, Class<?>... expected) {\n+    // Build exception message\n         StringBuilder exceptionMessage =\n                 new StringBuilder(\"Unexpected type. Expected one of: \");\n-        for (Class<?> clazz : expected) {\n+for (Class<?> clazz : expected) {\n             exceptionMessage.append(clazz.getName()).append(\", \");\n         }\n-        exceptionMessage.append(\"but got: \").append(token.getClass().getName())\n-                .append(\", for type token: \").append(token.toString()).append('.');\n-\n-        return new AssertionError(exceptionMessage.toString());\n+        exceptionMessage.append(\"but got: \").append(token.getClass().getName()).append(\", for type token: \").append(token.toString()).append('.');\n+return new AssertionError(exceptionMessage.toString());\n     }\n \n     /**\n@@ -270,8 +261,7 @@ public class TypeToken<T> {\n     private static boolean matches(Type from, Type to, Map<String, Type> typeMap) {\n         return to.equals(from)\n                 || (from instanceof TypeVariable\n-                && to.equals(typeMap.get(((TypeVariable<?>) from).getName())));\n-\n+        && to.equals(typeMap.get(((TypeVariable<?>) from).getName())));\n     }\n \n     @Override public final int hashCode() {\n@@ -315,4 +305,4 @@ public class TypeToken<T> {\n     public static TypeToken<?> getArray(Type componentType) {\n         return new TypeToken<Object>(Types.arrayOf(componentType));\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 25
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/errored/1/65/TypeToken.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/codebuff/65/TypeToken.java\nindex 99be4766407..ecf4bfd360a 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/errored/1/65/TypeToken.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/codebuff/65/TypeToken.java\n@@ -15,7 +15,6 @@\n \n package com.github.fangjinuo.easyjson.core.tree.bind;\n \n-\n import com.github.fangjinuo.easyjson.core.util.type.ParameterizedTypeImpl;\n import com.github.fangjinuo.easyjson.core.util.type.Types;\n import com.github.fangjinuo.easyjson.core.util.Preconditions;\n@@ -42,6 +41,7 @@ import java.util.Map;\n  * parameters, such as {@code Class<?>} or {@code List<? extends CharSequence>}.\n  *\n  */\n+\n public class TypeToken<T> {\n     final Class<? super T> rawType;\n     final Type type;\n@@ -55,8 +55,9 @@ public class TypeToken<T> {\n      * parameter in the anonymous class's type hierarchy so we can reconstitute it\n      * at runtime despite erasure.\n      */\n-    @SuppressWarnings(\"unchecked\")\n-    protected TypeToken() {\n+\n+\n+    @SuppressWarnings(\"unchecked\") protected TypeToken() {\n         this.type = getSuperclassTypeParameter(getClass());\n         this.rawType = (Class<? super T>) Types.getRawType(type);\n         this.hashCode = type.hashCode();\n@@ -65,8 +66,9 @@ public class TypeToken<T> {\n     /**\n      * Unsafe. Constructs a type literal manually.\n      */\n-    @SuppressWarnings(\"unchecked\")\n-    TypeToken(Type type) {\n+\n+\n+    @SuppressWarnings(\"unchecked\") TypeToken(Type type) {\n         this.type = ParameterizedTypeImpl.canonicalize(Preconditions.checkNotNull(type));\n         this.rawType = (Class<? super T>) Types.getRawType(this.type);\n         this.hashCode = this.type.hashCode();\n@@ -76,6 +78,7 @@ public class TypeToken<T> {\n      * Returns the type from super class's type parameter in {@link ParameterizedTypeImpl#canonicalize\n      * canonical form}.\n      */\n+\n     static Type getSuperclassTypeParameter(Class<?> subclass) {\n         Type superclass = subclass.getGenericSuperclass();\n         if (superclass instanceof Class) {\n@@ -88,6 +91,7 @@ public class TypeToken<T> {\n     /**\n      * Returns the raw (non-generic) type for this type.\n      */\n+\n     public final Class<? super T> getRawType() {\n         return rawType;\n     }\n@@ -95,6 +99,7 @@ public class TypeToken<T> {\n     /**\n      * Gets underlying {@code Type} instance.\n      */\n+\n     public final Type getType() {\n         return type;\n     }\n@@ -105,6 +110,7 @@ public class TypeToken<T> {\n      * @deprecated this implementation may be inconsistent with javac for types\n      *     with wildcards.\n      */\n+\n     @Deprecated\n     public boolean isAssignableFrom(Class<?> cls) {\n         return isAssignableFrom((Type) cls);\n@@ -116,27 +122,23 @@ public class TypeToken<T> {\n      * @deprecated this implementation may be inconsistent with javac for types\n      *     with wildcards.\n      */\n+\n     @Deprecated\n     public boolean isAssignableFrom(Type from) {\n         if (from == null) {\n             return false;\n         }\n-\n         if (type.equals(from)) {\n             return true;\n         }\n-\n         if (type instanceof Class<?>) {\n             return rawType.isAssignableFrom(Types.getRawType(from));\n         } else if (type instanceof ParameterizedType) {\n-            return isAssignableFrom(from, (ParameterizedType) type,\n-                    new HashMap<String, Type>());\n+            return isAssignableFrom(from, (ParameterizedType) type, new HashMap<String, Type>());\n         } else if (type instanceof GenericArrayType) {\n-            return rawType.isAssignableFrom(Types.getRawType(from))\n-                    && isAssignableFrom(from, (GenericArrayType) type);\n-        } else {\n-            throw buildUnexpectedTypeError(\n-                    type, Class.class, ParameterizedType.class, GenericArrayType.class);\n+                   return rawType.isAssignableFrom(Types.getRawType(from)) && isAssignableFrom(from, (GenericArrayType) type);\n+               } else {\n+            throw buildUnexpectedTypeError(type, Class.class, ParameterizedType.class, GenericArrayType.class);\n         }\n     }\n \n@@ -146,6 +148,7 @@ public class TypeToken<T> {\n      * @deprecated this implementation may be inconsistent with javac for types\n      *     with wildcards.\n      */\n+\n     @Deprecated\n     public boolean isAssignableFrom(TypeToken<?> token) {\n         return isAssignableFrom(token.getType());\n@@ -155,6 +158,7 @@ public class TypeToken<T> {\n      * Private helper function that performs some assignability checks for\n      * the provided GenericArrayType.\n      */\n+\n     private static boolean isAssignableFrom(Type from, GenericArrayType to) {\n         Type toGenericComponentType = to.getGenericComponentType();\n         if (toGenericComponentType instanceof ParameterizedType) {\n@@ -168,8 +172,7 @@ public class TypeToken<T> {\n                 }\n                 t = classType;\n             }\n-            return isAssignableFrom(t, (ParameterizedType) toGenericComponentType,\n-                    new HashMap<String, Type>());\n+            return isAssignableFrom(t, (ParameterizedType) toGenericComponentType, new HashMap<String, Type>());\n         }\n         // No generic defined on \"to\"; therefore, return true and let other\n         // checks determine assignability\n@@ -180,13 +183,11 @@ public class TypeToken<T> {\n      * Private recursive helper function to actually do the type-safe checking\n      * of assignability.\n      */\n-    private static boolean isAssignableFrom(Type from, ParameterizedType to,\n-                                            Map<String, Type> typeVarMap) {\n \n+    private static boolean isAssignableFrom(Type from, ParameterizedType to, Map<String, Type> typeVarMap) {\n         if (from == null) {\n             return false;\n         }\n-\n         if (to.equals(from)) {\n             return true;\n         }\n@@ -217,7 +218,6 @@ public class TypeToken<T> {\n                 return true;\n             }\n         }\n-\n         for (Type itype : clazz.getGenericInterfaces()) {\n             if (isAssignableFrom(itype, to, new HashMap<String, Type>(typeVarMap))) {\n                 return true;\n@@ -233,8 +233,8 @@ public class TypeToken<T> {\n      * Checks if two parameterized types are exactly equal, under the variable\n      * replacement described in the typeVarMap.\n      */\n-    private static boolean typeEquals(ParameterizedType from,\n-                                      ParameterizedType to, Map<String, Type> typeVarMap) {\n+\n+    private static boolean typeEquals(ParameterizedType from, ParameterizedType to, Map<String, Type> typeVarMap) {\n         if (from.getRawType().equals(to.getRawType())) {\n             Type[] fromArgs = from.getActualTypeArguments();\n             Type[] toArgs = to.getActualTypeArguments();\n@@ -248,18 +248,14 @@ public class TypeToken<T> {\n         return false;\n     }\n \n-    private static AssertionError buildUnexpectedTypeError(\n-            Type token, Class<?>... expected) {\n+    private static AssertionError buildUnexpectedTypeError(Type token, Class<?>... expected) {\n \n         // Build exception message\n-        StringBuilder exceptionMessage =\n-                new StringBuilder(\"Unexpected type. Expected one of: \");\n+        StringBuilder exceptionMessage = new StringBuilder(\"Unexpected type. Expected one of: \");\n         for (Class<?> clazz : expected) {\n             exceptionMessage.append(clazz.getName()).append(\", \");\n         }\n-        exceptionMessage.append(\"but got: \").append(token.getClass().getName())\n-                .append(\", for type token: \").append(token.toString()).append('.');\n-\n+        exceptionMessage.append(\"but got: \").append(token.getClass().getName()).append(\", for type token: \").append(token.toString()).append('.');\n         return new AssertionError(exceptionMessage.toString());\n     }\n \n@@ -267,29 +263,30 @@ public class TypeToken<T> {\n      * Checks if two types are the same or are equivalent under a variable mapping\n      * given in the type map that was provided.\n      */\n-    private static boolean matches(Type from, Type to, Map<String, Type> typeMap) {\n-        return to.equals(from)\n-                || (from instanceof TypeVariable\n-                && to.equals(typeMap.get(((TypeVariable<?>) from).getName())));\n \n+    private static boolean matches(Type from, Type to, Map<String, Type> typeMap) {\n+        return to.equals(from) || (from instanceof TypeVariable && to.equals(typeMap.get(((TypeVariable<?>) from).getName())));\n     }\n \n-    @Override public final int hashCode() {\n+    @Override\n+    public final int hashCode() {\n         return this.hashCode;\n     }\n \n-    @Override public final boolean equals(Object o) {\n-        return o instanceof TypeToken<?>\n-                && Types.equals(type, ((TypeToken<?>) o).type);\n+    @Override\n+    public final boolean equals(Object o) {\n+        return o instanceof TypeToken<?> && Types.equals(type, ((TypeToken<?>) o).type);\n     }\n \n-    @Override public final String toString() {\n+    @Override\n+    public final String toString() {\n         return Types.typeToString(type);\n     }\n \n     /**\n      * Gets type literal for the given {@code Type} instance.\n      */\n+\n     public static TypeToken<?> get(Type type) {\n         return new TypeToken<Object>(type);\n     }\n@@ -297,6 +294,7 @@ public class TypeToken<T> {\n     /**\n      * Gets type literal for the given {@code Class} instance.\n      */\n+\n     public static <T> TypeToken<T> get(Class<T> type) {\n         return new TypeToken<T>(type);\n     }\n@@ -305,6 +303,7 @@ public class TypeToken<T> {\n      * Gets type literal for the parameterized type represented by applying {@code typeArguments} to\n      * {@code rawType}.\n      */\n+\n     public static TypeToken<?> getParameterized(Type rawType, Type... typeArguments) {\n         return new TypeToken<Object>(Types.getParameterizedTypeWithOwnerType(null, rawType, typeArguments));\n     }\n@@ -312,7 +311,8 @@ public class TypeToken<T> {\n     /**\n      * Gets type literal for the array type whose elements are all instances of {@code componentType}.\n      */\n+\n     public static TypeToken<?> getArray(Type componentType) {\n         return new TypeToken<Object>(Types.arrayOf(componentType));\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 58
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/errored/1/65/TypeToken.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/styler_random/65/TypeToken.java\nindex 99be4766407..94e69602f65 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/errored/1/65/TypeToken.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/styler_random/65/TypeToken.java\n@@ -257,8 +257,7 @@ public class TypeToken<T> {\n         for (Class<?> clazz : expected) {\n             exceptionMessage.append(clazz.getName()).append(\", \");\n         }\n-        exceptionMessage.append(\"but got: \").append(token.getClass().getName())\n-                .append(\", for type token: \").append(token.toString()).append('.');\n+        exceptionMessage.append(\"but got: \").append(token.getClass().getName()).append(\", for type token: \").append(token.toString()).append('.');\n \n         return new AssertionError(exceptionMessage.toString());\n     }\n",
            "diff_size": 2
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/errored/1/65/TypeToken.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/styler_three_grams/65/TypeToken.java\nindex 99be4766407..94e69602f65 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/errored/1/65/TypeToken.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/styler_three_grams/65/TypeToken.java\n@@ -257,8 +257,7 @@ public class TypeToken<T> {\n         for (Class<?> clazz : expected) {\n             exceptionMessage.append(clazz.getName()).append(\", \");\n         }\n-        exceptionMessage.append(\"but got: \").append(token.getClass().getName())\n-                .append(\", for type token: \").append(token.toString()).append('.');\n+        exceptionMessage.append(\"but got: \").append(token.getClass().getName()).append(\", for type token: \").append(token.toString()).append('.');\n \n         return new AssertionError(exceptionMessage.toString());\n     }\n",
            "diff_size": 2
        }
    ],
    "repaired_by": [
        "styler",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "intellij"
    ]
}