{
    "project_name": "ppati000-visualDFA",
    "error_id": "2",
    "information": {
        "errors": [
            {
                "line": "410",
                "column": "38",
                "severity": "warning",
                "message": "'=' should be on a new line.",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.OperatorWrapCheck"
            }
        ]
    },
    "source_code": "                if (nextElementaryBlock == null) {\n                    E basicBlockInState = prevAnalysisState.getBlockState(prevBasicBlock).getInState();\n                    newAnalysisState =\n                            finishBasicBlock(prevBasicBlock, basicBlockInState, prevAnalysisState, visitedBasicBlocks);\n                } else {\n                    E nextOutState = dfa.transition(prevOutState, nextElementaryBlock.getUnit());",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/ppati000-visualDFA/errored/1/2/DFAExecution.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/ppati000-visualDFA/styler/2/DFAExecution.java\nindex 68cd091c290..9da01b7f90b 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/ppati000-visualDFA/errored/1/2/DFAExecution.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/ppati000-visualDFA/styler/2/DFAExecution.java\n@@ -407,8 +407,8 @@ public class DFAExecution<E extends LatticeElement> {\n \r\n                 if (nextElementaryBlock == null) {\r\n                     E basicBlockInState = prevAnalysisState.getBlockState(prevBasicBlock).getInState();\r\n-                    newAnalysisState =\r\n-                            finishBasicBlock(prevBasicBlock, basicBlockInState, prevAnalysisState, visitedBasicBlocks);\r\n+                    newAnalysisState\r\n+                    = finishBasicBlock(prevBasicBlock, basicBlockInState, prevAnalysisState, visitedBasicBlocks);\r\n                 } else {\r\n                     E nextOutState = dfa.transition(prevOutState, nextElementaryBlock.getUnit());\r\n                     BlockState<E> nextBlockState = new BlockState<E>(prevOutState, nextOutState);\r\n",
            "diff_size": 2
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "128",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 127).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "394",
                    "column": "28",
                    "severity": "warning",
                    "message": "'=' should be on a new line.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.OperatorWrapCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/ppati000-visualDFA/errored/1/2/DFAExecution.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/ppati000-visualDFA/intellij/2/DFAExecution.java\nindex 68cd091c290..c5fad6d1be7 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/ppati000-visualDFA/errored/1/2/DFAExecution.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/ppati000-visualDFA/intellij/2/DFAExecution.java\n@@ -10,512 +10,496 @@ import java.util.Set;\n import soot.toolkits.graph.Block;\r\n \r\n /**\r\n+ * @param <E> the type of {@code LatticeElement} used in this {@code DFAExecution}\r\n  * @author Sebastian Rauch\r\n- * \r\n- *         A {@code DFAExecution} precalculates a {@code DataFlowAnalysis} and provides the intermediate analysis-steps.\r\n- *\r\n- * @param <E>\r\n- *        the type of {@code LatticeElement} used in this {@code DFAExecution}\r\n+ * <p>\r\n+ * A {@code DFAExecution} precalculates a {@code DataFlowAnalysis} and provides the intermediate analysis-steps.\r\n  */\r\n public class DFAExecution<E extends LatticeElement> {\r\n \r\n-    private final Worklist initialWorklist;\r\n-\r\n-    private final DFADirection direction;\r\n-\r\n-    private final DataFlowAnalysis<E> dfa;\r\n-\r\n-    private final ControlFlowGraph cfg;\r\n-\r\n-    private List<AnalysisState<E>> analysisStates = new ArrayList<>();\r\n-    private List<Integer> blockSteps = new ArrayList<>();\r\n-\r\n-    private int currentElementaryStep = -1;\r\n-    private int currentBlockStep = -1;\r\n-\r\n-    /**\r\n-     * Creates a {@code DFAExecution} from a given {@code DFAFactory}, an initial {@code Worklist} and a\r\n-     * {@code SimpleBlockGraph}.\r\n-     * \r\n-     * @param dfaFactory\r\n-     *        a {@code DFAFactory} from which a {@code DataFlowAnalysis} will be generated\r\n-     * @param initialWorklist\r\n-     *        an (empty) worklist to use in this {@code DFAExecution}\r\n-     * @param blockGraph\r\n-     *        the {@code SimpleBlockGraph} the analysis is based on\r\n-     * @param precalcController\r\n-     *        a {@code DFAPrecalcController} to control the precalculation of this {@code DFAExecution}\r\n-     * \r\n-     * @throws IllegalArgumentException\r\n-     *         if any of {@code initialWorklist} or {@code blockGraph} is {@code null}\r\n-     * \r\n-     * @throws NullPointerException\r\n-     *         if {@code dfaFactory} is {@code null}\r\n-     */\r\n-    public DFAExecution(DFAFactory<E> dfaFactory, Worklist initialWorklist, SimpleBlockGraph blockGraph,\r\n-            DFAPrecalcController precalcController) {\r\n-        if (initialWorklist == null) {\r\n-            throw new IllegalArgumentException(\"initialWorklist must not be null\");\r\n-        }\r\n-\r\n-        if (blockGraph == null) {\r\n-            throw new IllegalArgumentException(\"blockGraph must not be null\");\r\n-        }\r\n+  private final Worklist initialWorklist;\r\n \r\n-        this.initialWorklist = initialWorklist;\r\n-        this.direction = dfaFactory.getDirection();\r\n+  private final DFADirection direction;\r\n \r\n-        dfa = dfaFactory.getAnalysis(blockGraph);\r\n+  private final DataFlowAnalysis<E> dfa;\r\n \r\n-        this.cfg = new ControlFlowGraph(blockGraph);\r\n+  private final ControlFlowGraph cfg;\r\n \r\n-        precalc(precalcController);\r\n-    }\r\n+  private List<AnalysisState<E>> analysisStates = new ArrayList<>();\r\n+  private List<Integer> blockSteps = new ArrayList<>();\r\n \r\n-    private DFAExecution(DFAExecution<E> copyFrom) {\r\n-        this.initialWorklist = copyFrom.initialWorklist;\r\n-        this.direction = copyFrom.getDirection();\r\n-        this.dfa = copyFrom.dfa;\r\n-        this.cfg = copyFrom.getCFG();\r\n+  private int currentElementaryStep = -1;\r\n+  private int currentBlockStep = -1;\r\n \r\n-        this.analysisStates = copyFrom.analysisStates;\r\n-        this.blockSteps = copyFrom.blockSteps;\r\n-\r\n-        setCurrentElementaryStep(copyFrom.getCurrentElementaryStep());\r\n-        setCurrentBlockStep(copyFrom.getCurrentBlockStep());\r\n+  /**\r\n+   * Creates a {@code DFAExecution} from a given {@code DFAFactory}, an initial {@code Worklist} and a\r\n+   * {@code SimpleBlockGraph}.\r\n+   *\r\n+   * @param dfaFactory        a {@code DFAFactory} from which a {@code DataFlowAnalysis} will be generated\r\n+   * @param initialWorklist   an (empty) worklist to use in this {@code DFAExecution}\r\n+   * @param blockGraph        the {@code SimpleBlockGraph} the analysis is based on\r\n+   * @param precalcController a {@code DFAPrecalcController} to control the precalculation of this {@code DFAExecution}\r\n+   * @throws IllegalArgumentException if any of {@code initialWorklist} or {@code blockGraph} is {@code null}\r\n+   * @throws NullPointerException     if {@code dfaFactory} is {@code null}\r\n+   */\r\n+  public DFAExecution(DFAFactory<E> dfaFactory, Worklist initialWorklist, SimpleBlockGraph blockGraph,\r\n+                      DFAPrecalcController precalcController) {\r\n+    if (initialWorklist == null) {\r\n+      throw new IllegalArgumentException(\"initialWorklist must not be null\");\r\n     }\r\n \r\n-    /**\r\n-     * Returns the {@code ControlFlowGraph} that is used to execute the dataflow-analysis.\r\n-     * \r\n-     * @return the {@code ControlFlowGraph} used to execute the dataflow-analysis\r\n-     */\r\n-    public ControlFlowGraph getCFG() {\r\n-        return cfg;\r\n+    if (blockGraph == null) {\r\n+      throw new IllegalArgumentException(\"blockGraph must not be null\");\r\n     }\r\n \r\n-    /**\r\n-     * Returns the direction of the {@code DataFlowAnalysis} that is executed.\r\n-     * \r\n-     * @return the direction of the {@code DataFlowAnalysis} that is executed\r\n-     */\r\n-    public DFADirection getDirection() {\r\n-        return direction;\r\n+    this.initialWorklist = initialWorklist;\r\n+    this.direction = dfaFactory.getDirection();\r\n+\r\n+    dfa = dfaFactory.getAnalysis(blockGraph);\r\n+\r\n+    this.cfg = new ControlFlowGraph(blockGraph);\r\n+\r\n+    precalc(precalcController);\r\n+  }\r\n+\r\n+  private DFAExecution(DFAExecution<E> copyFrom) {\r\n+    this.initialWorklist = copyFrom.initialWorklist;\r\n+    this.direction = copyFrom.getDirection();\r\n+    this.dfa = copyFrom.dfa;\r\n+    this.cfg = copyFrom.getCFG();\r\n+\r\n+    this.analysisStates = copyFrom.analysisStates;\r\n+    this.blockSteps = copyFrom.blockSteps;\r\n+\r\n+    setCurrentElementaryStep(copyFrom.getCurrentElementaryStep());\r\n+    setCurrentBlockStep(copyFrom.getCurrentBlockStep());\r\n+  }\r\n+\r\n+  /**\r\n+   * Returns the {@code ControlFlowGraph} that is used to execute the dataflow-analysis.\r\n+   *\r\n+   * @return the {@code ControlFlowGraph} used to execute the dataflow-analysis\r\n+   */\r\n+  public ControlFlowGraph getCFG() {\r\n+    return cfg;\r\n+  }\r\n+\r\n+  /**\r\n+   * Returns the direction of the {@code DataFlowAnalysis} that is executed.\r\n+   *\r\n+   * @return the direction of the {@code DataFlowAnalysis} that is executed\r\n+   */\r\n+  public DFADirection getDirection() {\r\n+    return direction;\r\n+  }\r\n+\r\n+  /**\r\n+   * Returns the total number of elementary-steps.\r\n+   *\r\n+   * @return the total number of elementary-steps\r\n+   */\r\n+  public int getTotalElementarySteps() {\r\n+    return analysisStates.size();\r\n+  }\r\n+\r\n+  /**\r\n+   * Returns the total number of block-steps.\r\n+   *\r\n+   * @return the total number of block-steps\r\n+   */\r\n+  public int getTotalBlockSteps() {\r\n+    return blockSteps.size();\r\n+  }\r\n+\r\n+  /**\r\n+   * Returns the current elementary-step.\r\n+   *\r\n+   * @return the current elementary-step, always in range {@code [0, ..., getTotalElementarySteps() - 1]}\r\n+   */\r\n+  public int getCurrentElementaryStep() {\r\n+    return currentElementaryStep;\r\n+  }\r\n+\r\n+  /**\r\n+   * Sets the current elementary-step. The current block-step is updated to be consistent with the current\r\n+   * elementary-step.\r\n+   *\r\n+   * @param elementaryStep the elementary-step to set as current elementary-step\r\n+   * @throws IllegalArgumentException if {@code elementaryStep} is not in range {@code [0, ..., getTotalElementarySteps() - 1]}\r\n+   */\r\n+  public void setCurrentElementaryStep(int elementaryStep) {\r\n+    if (elementaryStep < 0 || elementaryStep >= getTotalElementarySteps()) {\r\n+      throw new IndexOutOfBoundsException(\"invalid elementaryStep: \" + elementaryStep);\r\n     }\r\n \r\n-    /**\r\n-     * Returns the total number of elementary-steps.\r\n-     * \r\n-     * @return the total number of elementary-steps\r\n-     */\r\n-    public int getTotalElementarySteps() {\r\n-        return analysisStates.size();\r\n-    }\r\n+    currentElementaryStep = elementaryStep;\r\n+    int idx = Collections.binarySearch(blockSteps, currentElementaryStep);\r\n \r\n-    /**\r\n-     * Returns the total number of block-steps.\r\n-     * \r\n-     * @return the total number of block-steps\r\n-     */\r\n-    public int getTotalBlockSteps() {\r\n-        return blockSteps.size();\r\n+    if (idx < 0) { // currentElementaryStep has not been found\r\n+      idx = -(idx + 1); // this gives the correct index of the corresponding block-step\r\n     }\r\n-\r\n-    /**\r\n-     * Returns the current elementary-step.\r\n-     * \r\n-     * @return the current elementary-step, always in range {@code [0, ..., getTotalElementarySteps() - 1]}\r\n-     */\r\n-    public int getCurrentElementaryStep() {\r\n-        return currentElementaryStep;\r\n+    currentBlockStep = idx;\r\n+  }\r\n+\r\n+  /**\r\n+   * Returns the current block-step.\r\n+   *\r\n+   * @return the current block-step, always in range {@code [0, ..., getTotalBlockSteps() - 1]}\r\n+   */\r\n+  public int getCurrentBlockStep() {\r\n+    return currentBlockStep;\r\n+  }\r\n+\r\n+  /**\r\n+   * Sets the current block-step. The current elementary-step is updated to be consistent with the current block-step.\r\n+   *\r\n+   * @param blockStep the block-step to set as current block-step\r\n+   * @throws IllegalArgumentException if {@code blockStep} is not in range {@code [0, ..., getTotalBlockSteps() - 1]}\r\n+   */\r\n+  public void setCurrentBlockStep(int blockStep) {\r\n+    if (blockStep < 0 || blockStep >= getTotalBlockSteps()) {\r\n+      throw new IndexOutOfBoundsException(\"invalid blockStep: \" + blockStep);\r\n     }\r\n \r\n-    /**\r\n-     * Sets the current elementary-step. The current block-step is updated to be consistent with the current\r\n-     * elementary-step.\r\n-     * \r\n-     * @param elementaryStep\r\n-     *        the elementary-step to set as current elementary-step\r\n-     * \r\n-     * @throws IllegalArgumentException\r\n-     *         if {@code elementaryStep} is not in range {@code [0, ..., getTotalElementarySteps() - 1]}\r\n-     */\r\n-    public void setCurrentElementaryStep(int elementaryStep) {\r\n-        if (elementaryStep < 0 || elementaryStep >= getTotalElementarySteps()) {\r\n-            throw new IndexOutOfBoundsException(\"invalid elementaryStep: \" + elementaryStep);\r\n-        }\r\n-\r\n-        currentElementaryStep = elementaryStep;\r\n-        int idx = Collections.binarySearch(blockSteps, currentElementaryStep);\r\n-\r\n-        if (idx < 0) { // currentElementaryStep has not been found\r\n-            idx = -(idx + 1); // this gives the correct index of the corresponding block-step\r\n-        }\r\n-        currentBlockStep = idx;\r\n+    currentBlockStep = blockStep;\r\n+    currentElementaryStep = blockSteps.get(blockStep);\r\n+  }\r\n+\r\n+  /**\r\n+   * Increases the current elementary-step (by 1) if possible.\r\n+   *\r\n+   * @return {@code true} if there was a next elementary-step, {@code false} otherwise\r\n+   */\r\n+  public boolean nextElementaryStep() {\r\n+    int nextStep = getCurrentElementaryStep() + 1;\r\n+    if (nextStep < getTotalElementarySteps()) {\r\n+      setCurrentElementaryStep(nextStep);\r\n+      return true;\r\n     }\r\n \r\n-    /**\r\n-     * Returns the current block-step.\r\n-     * \r\n-     * @return the current block-step, always in range {@code [0, ..., getTotalBlockSteps() - 1]}\r\n-     */\r\n-    public int getCurrentBlockStep() {\r\n-        return currentBlockStep;\r\n+    return false;\r\n+  }\r\n+\r\n+  /**\r\n+   * Decreases the current elementary-step by 1 if possible.\r\n+   *\r\n+   * @return {@code true} if there was a next elementary-step, {@code false} otherwise\r\n+   */\r\n+  public boolean previousElementaryStep() {\r\n+    int prevStep = getCurrentElementaryStep() - 1;\r\n+    if (prevStep >= 0) {\r\n+      setCurrentElementaryStep(prevStep);\r\n+      return true;\r\n     }\r\n \r\n-    /**\r\n-     * Sets the current block-step. The current elementary-step is updated to be consistent with the current block-step.\r\n-     * \r\n-     * @param blockStep\r\n-     *        the block-step to set as current block-step\r\n-     * \r\n-     * @throws IllegalArgumentException\r\n-     *         if {@code blockStep} is not in range {@code [0, ..., getTotalBlockSteps() - 1]}\r\n-     */\r\n-    public void setCurrentBlockStep(int blockStep) {\r\n-        if (blockStep < 0 || blockStep >= getTotalBlockSteps()) {\r\n-            throw new IndexOutOfBoundsException(\"invalid blockStep: \" + blockStep);\r\n-        }\r\n-\r\n-        currentBlockStep = blockStep;\r\n-        currentElementaryStep = blockSteps.get(blockStep);\r\n+    return false;\r\n+  }\r\n+\r\n+  /**\r\n+   * Advances the current block-step (by 1) if possible.\r\n+   *\r\n+   * @return {@code true} if there was a next block-step, {@code false} otherwise\r\n+   */\r\n+  public boolean nextBlockStep() {\r\n+    int nextBlockStep = getCurrentBlockStep() + 1;\r\n+    if (nextBlockStep < getTotalBlockSteps()) {\r\n+      setCurrentBlockStep(nextBlockStep);\r\n+      return true;\r\n     }\r\n \r\n-    /**\r\n-     * Increases the current elementary-step (by 1) if possible.\r\n-     * \r\n-     * @return {@code true} if there was a next elementary-step, {@code false} otherwise\r\n-     */\r\n-    public boolean nextElementaryStep() {\r\n-        int nextStep = getCurrentElementaryStep() + 1;\r\n-        if (nextStep < getTotalElementarySteps()) {\r\n-            setCurrentElementaryStep(nextStep);\r\n-            return true;\r\n-        }\r\n-\r\n-        return false;\r\n+    return false;\r\n+  }\r\n+\r\n+  /**\r\n+   * Decreases the current block-step by 1 if possible.\r\n+   *\r\n+   * @return {@code true} if there was a next block-step, {@code false} otherwise\r\n+   */\r\n+  public boolean previousBlockStep() {\r\n+    int currentBlockStep = getCurrentBlockStep() - 1;\r\n+    if (currentBlockStep >= 0) {\r\n+      setCurrentBlockStep(currentBlockStep);\r\n+      return true;\r\n     }\r\n \r\n-    /**\r\n-     * Decreases the current elementary-step by 1 if possible.\r\n-     * \r\n-     * @return {@code true} if there was a next elementary-step, {@code false} otherwise\r\n-     */\r\n-    public boolean previousElementaryStep() {\r\n-        int prevStep = getCurrentElementaryStep() - 1;\r\n-        if (prevStep >= 0) {\r\n-            setCurrentElementaryStep(prevStep);\r\n-            return true;\r\n-        }\r\n-\r\n-        return false;\r\n+    return false;\r\n+  }\r\n+\r\n+  /**\r\n+   * Returns whether the current elementary-step is at {@code ElementaryBlock} that has a breakpoint.\r\n+   *\r\n+   * @return {@code true} if the {@code ElementaryBlock} of the current elementary-step has a breakpoint,\r\n+   * {@code false} otherwise\r\n+   */\r\n+  public boolean isAtBreakpoint() {\r\n+    AnalysisState<? extends LatticeElement> currentState = getCurrentAnalysisState();\r\n+    BasicBlock bBlock = currentState.getCurrentBasicBlock();\r\n+\r\n+    if (bBlock == null) {\r\n+      return false;\r\n     }\r\n \r\n-    /**\r\n-     * Advances the current block-step (by 1) if possible.\r\n-     * \r\n-     * @return {@code true} if there was a next block-step, {@code false} otherwise\r\n-     */\r\n-    public boolean nextBlockStep() {\r\n-        int nextBlockStep = getCurrentBlockStep() + 1;\r\n-        if (nextBlockStep < getTotalBlockSteps()) {\r\n-            setCurrentBlockStep(nextBlockStep);\r\n-            return true;\r\n-        }\r\n-\r\n-        return false;\r\n+    int eBlockIdx = currentState.getCurrentElementaryBlockIndex();\r\n+    return bBlock.getElementaryBlock(eBlockIdx).hasBreakpoint();\r\n+  }\r\n+\r\n+  /**\r\n+   * Returns the current {@code AnalysisState}, i. e. the state of the analysis at the current elementary-step.\r\n+   *\r\n+   * @return the current {@code AnalysisState}\r\n+   */\r\n+  public AnalysisState<? extends LatticeElement> getCurrentAnalysisState() {\r\n+    return analysisStates.get(currentElementaryStep);\r\n+  }\r\n+\r\n+  /**\r\n+   * Creates a <em>shallow copy</em> of this {@code DFAExecution}. The returned copy shares the {@code AnalysisState}s\r\n+   * with the original but can have different current block- or elementary-steps.\r\n+   */\r\n+  @Override\r\n+  public DFAExecution<E> clone() {\r\n+    return new DFAExecution<E>(this);\r\n+  }\r\n+\r\n+  private void precalc(DFAPrecalcController precalcCtrl) {\r\n+    Map<Block, BlockState<E>> initialStates = dfa.getInitialStates();\r\n+\r\n+    BasicBlock startBlock = getStartBlock();\r\n+    if (startBlock == null) {\r\n+      throw new DFAException(\"there is no start block\");\r\n     }\r\n \r\n-    /**\r\n-     * Decreases the current block-step by 1 if possible.\r\n-     * \r\n-     * @return {@code true} if there was a next block-step, {@code false} otherwise\r\n-     */\r\n-    public boolean previousBlockStep() {\r\n-        int currentBlockStep = getCurrentBlockStep() - 1;\r\n-        if (currentBlockStep >= 0) {\r\n-            setCurrentBlockStep(currentBlockStep);\r\n-            return true;\r\n-        }\r\n+    AnalysisState<E> initialState = new AnalysisState<E>(initialWorklist, startBlock, -1);\r\n \r\n-        return false;\r\n-    }\r\n-\r\n-    /**\r\n-     * Returns whether the current elementary-step is at {@code ElementaryBlock} that has a breakpoint.\r\n-     * \r\n-     * @return {@code true} if the {@code ElementaryBlock} of the current elementary-step has a breakpoint,\r\n-     *         {@code false} otherwise\r\n-     */\r\n-    public boolean isAtBreakpoint() {\r\n-        AnalysisState<? extends LatticeElement> currentState = getCurrentAnalysisState();\r\n-        BasicBlock bBlock = currentState.getCurrentBasicBlock();\r\n-\r\n-        if (bBlock == null) {\r\n-            return false;\r\n-        }\r\n+    List<BasicBlock> basicBlocks = cfg.getBasicBlocks();\r\n+    for (BasicBlock bBlock : basicBlocks) {\r\n+      Block sootBlock = bBlock.getSootBlock();\r\n+      BlockState<E> state = initialStates.get(sootBlock);\r\n \r\n-        int eBlockIdx = currentState.getCurrentElementaryBlockIndex();\r\n-        return bBlock.getElementaryBlock(eBlockIdx).hasBreakpoint();\r\n-    }\r\n+      LogicalColor lColor = bBlock.equals(startBlock) ? LogicalColor.CURRENT : LogicalColor.NOT_VISITED;\r\n+      initialState.setBlockState(bBlock, state);\r\n+      initialState.setColor(bBlock, lColor);\r\n \r\n-    /**\r\n-     * Returns the current {@code AnalysisState}, i. e. the state of the analysis at the current elementary-step.\r\n-     * \r\n-     * @return the current {@code AnalysisState}\r\n-     */\r\n-    public AnalysisState<? extends LatticeElement> getCurrentAnalysisState() {\r\n-        return analysisStates.get(currentElementaryStep);\r\n-    }\r\n+      // set all in- and out-states to null for the elementary-blocks\r\n+      List<ElementaryBlock> elementaryBlocks = bBlock.getElementaryBlocks();\r\n+      BlockState<E> nullState = new BlockState<E>(null, null);\r\n+      for (ElementaryBlock eBlock : elementaryBlocks) {\r\n+        initialState.setBlockState(eBlock, nullState);\r\n+      }\r\n \r\n-    /**\r\n-     * Creates a <em>shallow copy</em> of this {@code DFAExecution}. The returned copy shares the {@code AnalysisState}s\r\n-     * with the original but can have different current block- or elementary-steps.\r\n-     */\r\n-    @Override\r\n-    public DFAExecution<E> clone() {\r\n-        return new DFAExecution<E>(this);\r\n     }\r\n \r\n-    private void precalc(DFAPrecalcController precalcCtrl) {\r\n-        Map<Block, BlockState<E>> initialStates = dfa.getInitialStates();\r\n-\r\n-        BasicBlock startBlock = getStartBlock();\r\n-        if (startBlock == null) {\r\n-            throw new DFAException(\"there is no start block\");\r\n-        }\r\n-\r\n-        AnalysisState<E> initialState = new AnalysisState<E>(initialWorklist, startBlock, -1);\r\n-\r\n-        List<BasicBlock> basicBlocks = cfg.getBasicBlocks();\r\n-        for (BasicBlock bBlock : basicBlocks) {\r\n-            Block sootBlock = bBlock.getSootBlock();\r\n-            BlockState<E> state = initialStates.get(sootBlock);\r\n+    analysisStates.add(initialState);\r\n+\r\n+    // elementary step 0 is always a block step\r\n+    blockSteps.add(0);\r\n+\r\n+    iterateToFixpoint(initialState, precalcCtrl);\r\n+  }\r\n+\r\n+  private void iterateToFixpoint(AnalysisState<E> initialState, DFAPrecalcController precalcCtrl) {\r\n+    Set<BasicBlock> visitedBasicBlocks = new HashSet<BasicBlock>();\r\n+    visitedBasicBlocks.add(getStartBlock());\r\n+\r\n+    int elementaryStep = 1;\r\n+    AnalysisState<E> prevAnalysisState = initialState;\r\n+\r\n+    while (true) {\r\n+      switch (precalcCtrl.getPrecalcState()) {\r\n+        case CALCULATING:\r\n+          break; // break switch\r\n+        case COMPLETED:\r\n+          return;\r\n+        case PAUSED:\r\n+          try {\r\n+            Thread.sleep(precalcCtrl.getWaitTime());\r\n+          } catch (InterruptedException e) {\r\n+            e.printStackTrace();\r\n+          }\r\n+          continue;\r\n+        case STOPPED:\r\n+          precalcCtrl.setResult(this, false);\r\n+          return;\r\n+        default:\r\n+          throw new IllegalStateException(\"unknown precalc state: \" + precalcCtrl.getPrecalcState());\r\n+      }\r\n \r\n-            LogicalColor lColor = bBlock.equals(startBlock) ? LogicalColor.CURRENT : LogicalColor.NOT_VISITED;\r\n-            initialState.setBlockState(bBlock, state);\r\n-            initialState.setColor(bBlock, lColor);\r\n+      BasicBlock prevBasicBlock = prevAnalysisState.getCurrentBasicBlock();\r\n \r\n-            // set all in- and out-states to null for the elementary-blocks\r\n-            List<ElementaryBlock> elementaryBlocks = bBlock.getElementaryBlocks();\r\n-            BlockState<E> nullState = new BlockState<E>(null, null);\r\n-            for (ElementaryBlock eBlock : elementaryBlocks) {\r\n-                initialState.setBlockState(eBlock, nullState);\r\n-            }\r\n+      AnalysisState<E> newAnalysisState = null;\r\n+      Worklist prevWorklist = prevAnalysisState.getWorklist();\r\n+      if (prevBasicBlock == null) {\r\n+        // no basic block currently selected, this begins a new basic block step (or completes calculation)\r\n \r\n+        if (prevWorklist.isEmpty()) {\r\n+          // we are at a fixpoint\r\n+          precalcCtrl.setResult(this, true);\r\n+          return;\r\n         }\r\n \r\n-        analysisStates.add(initialState);\r\n+        Worklist newWorklist = prevWorklist.clone();\r\n+        BasicBlock newBasicBlock = newWorklist.poll();\r\n+        visitedBasicBlocks.add(newBasicBlock);\r\n \r\n-        // elementary step 0 is always a block step\r\n-        blockSteps.add(0);\r\n+        newAnalysisState = newState(prevAnalysisState, newWorklist, newBasicBlock, -1);\r\n \r\n-        iterateToFixpoint(initialState, precalcCtrl);\r\n-    }\r\n-\r\n-    private void iterateToFixpoint(AnalysisState<E> initialState, DFAPrecalcController precalcCtrl) {\r\n-        Set<BasicBlock> visitedBasicBlocks = new HashSet<BasicBlock>();\r\n-        visitedBasicBlocks.add(getStartBlock());\r\n-\r\n-        int elementaryStep = 1;\r\n-        AnalysisState<E> prevAnalysisState = initialState;\r\n-\r\n-        while (true) {\r\n-            switch (precalcCtrl.getPrecalcState()) {\r\n-            case CALCULATING:\r\n-                break; // break switch\r\n-            case COMPLETED:\r\n-                return;\r\n-            case PAUSED:\r\n-                try {\r\n-                    Thread.sleep(precalcCtrl.getWaitTime());\r\n-                } catch (InterruptedException e) {\r\n-                    e.printStackTrace();\r\n-                }\r\n-                continue;\r\n-            case STOPPED:\r\n-                precalcCtrl.setResult(this, false);\r\n-                return;\r\n-            default:\r\n-                throw new IllegalStateException(\"unknown precalc state: \" + precalcCtrl.getPrecalcState());\r\n-            }\r\n-\r\n-            BasicBlock prevBasicBlock = prevAnalysisState.getCurrentBasicBlock();\r\n-\r\n-            AnalysisState<E> newAnalysisState = null;\r\n-            Worklist prevWorklist = prevAnalysisState.getWorklist();\r\n-            if (prevBasicBlock == null) {\r\n-                // no basic block currently selected, this begins a new basic block step (or completes calculation)\r\n-\r\n-                if (prevWorklist.isEmpty()) {\r\n-                    // we are at a fixpoint\r\n-                    precalcCtrl.setResult(this, true);\r\n-                    return;\r\n-                }\r\n-\r\n-                Worklist newWorklist = prevWorklist.clone();\r\n-                BasicBlock newBasicBlock = newWorklist.poll();\r\n-                visitedBasicBlocks.add(newBasicBlock);\r\n-\r\n-                newAnalysisState = newState(prevAnalysisState, newWorklist, newBasicBlock, -1);\r\n-\r\n-                // join predecessors out-states\r\n-                List<BasicBlock> preds = getPredecessors(newBasicBlock);\r\n-                Set<E> predOutStates = new HashSet<E>();\r\n-                for (BasicBlock p : preds) {\r\n-                    predOutStates.add(prevAnalysisState.getBlockState(p).getOutState());\r\n-                }\r\n-                E outStatesJoin = dfa.join(predOutStates);\r\n-\r\n-                BlockState<E> prevBlockState = prevAnalysisState.getBlockState(prevBasicBlock);\r\n-                BlockState<E> newBlockState = new BlockState<E>(outStatesJoin, prevBlockState.getOutState());\r\n-                newAnalysisState.setBlockState(newBasicBlock, newBlockState);\r\n-\r\n-                updateColors(prevAnalysisState, newAnalysisState, visitedBasicBlocks);\r\n-\r\n-                analysisStates.add(newAnalysisState);\r\n-\r\n-                // this begins a new block step\r\n-                blockSteps.add(elementaryStep++);\r\n-                continue;\r\n-            }\r\n-\r\n-            // prevBasicBlock is not null (so this is not a new block step)\r\n-            int eBlockIdx = prevAnalysisState.getCurrentElementaryBlockIndex();\r\n-            if (prevBasicBlock.getElementaryBlockCount() == 0) {\r\n-                // handle empty basic block [e. g. artificial end block]\r\n-                E inState = prevAnalysisState.getBlockState(prevBasicBlock).getInState();\r\n-                newAnalysisState = finishBasicBlock(prevBasicBlock, inState, prevAnalysisState, visitedBasicBlocks);\r\n-            } else if (eBlockIdx < prevBasicBlock.getElementaryBlockCount()) {\r\n-                // handle non-empty basic block\r\n-                E prevOutState;\r\n-                ElementaryBlock nextElementaryBlock;\r\n-                if (eBlockIdx < 0) {\r\n-                    // first elementary block\r\n-                    prevOutState = prevAnalysisState.getBlockState(prevBasicBlock).getInState();\r\n-                    nextElementaryBlock = getElementaryBlock(prevBasicBlock, 0);\r\n-                } else if (eBlockIdx < prevBasicBlock.getElementaryBlockCount() - 1) {\r\n-                    // some elementary block that is not the first or last in the basic block\r\n-                    ElementaryBlock prevElementaryBlock = getElementaryBlock(prevBasicBlock, eBlockIdx);\r\n-                    prevOutState = prevAnalysisState.getBlockState(prevElementaryBlock).getOutState();\r\n-                    nextElementaryBlock = getElementaryBlock(prevBasicBlock, eBlockIdx + 1);\r\n-                } else {\r\n-                    ElementaryBlock prevElementaryBlock = getElementaryBlock(prevBasicBlock, eBlockIdx);\r\n-                    prevOutState = prevAnalysisState.getBlockState(prevElementaryBlock).getOutState();\r\n-                    nextElementaryBlock = null;\r\n-                }\r\n-\r\n-                if (nextElementaryBlock == null) {\r\n-                    E basicBlockInState = prevAnalysisState.getBlockState(prevBasicBlock).getInState();\r\n-                    newAnalysisState =\r\n-                            finishBasicBlock(prevBasicBlock, basicBlockInState, prevAnalysisState, visitedBasicBlocks);\r\n-                } else {\r\n-                    E nextOutState = dfa.transition(prevOutState, nextElementaryBlock.getUnit());\r\n-                    BlockState<E> nextBlockState = new BlockState<E>(prevOutState, nextOutState);\r\n-                    newAnalysisState = newState(prevAnalysisState, prevWorklist.clone(), prevBasicBlock, ++eBlockIdx);\r\n-                    newAnalysisState.setBlockState(prevBasicBlock, nextBlockState);\r\n-                }\r\n-\r\n-                analysisStates.add(newAnalysisState);\r\n-                prevAnalysisState = newAnalysisState;\r\n-                ++elementaryStep;\r\n-            }\r\n+        // join predecessors out-states\r\n+        List<BasicBlock> preds = getPredecessors(newBasicBlock);\r\n+        Set<E> predOutStates = new HashSet<E>();\r\n+        for (BasicBlock p : preds) {\r\n+          predOutStates.add(prevAnalysisState.getBlockState(p).getOutState());\r\n         }\r\n-    }\r\n-\r\n-    private BasicBlock getStartBlock() {\r\n-        switch (getDirection()) {\r\n-        case FORWARD:\r\n-            return cfg.getStartBlock();\r\n-        case BACKWARD:\r\n-            return cfg.getEndBlock();\r\n-        default:\r\n-            throw new IllegalStateException(\"unknown direction: \" + getDirection());\r\n+        E outStatesJoin = dfa.join(predOutStates);\r\n+\r\n+        BlockState<E> prevBlockState = prevAnalysisState.getBlockState(prevBasicBlock);\r\n+        BlockState<E> newBlockState = new BlockState<E>(outStatesJoin, prevBlockState.getOutState());\r\n+        newAnalysisState.setBlockState(newBasicBlock, newBlockState);\r\n+\r\n+        updateColors(prevAnalysisState, newAnalysisState, visitedBasicBlocks);\r\n+\r\n+        analysisStates.add(newAnalysisState);\r\n+\r\n+        // this begins a new block step\r\n+        blockSteps.add(elementaryStep++);\r\n+        continue;\r\n+      }\r\n+\r\n+      // prevBasicBlock is not null (so this is not a new block step)\r\n+      int eBlockIdx = prevAnalysisState.getCurrentElementaryBlockIndex();\r\n+      if (prevBasicBlock.getElementaryBlockCount() == 0) {\r\n+        // handle empty basic block [e. g. artificial end block]\r\n+        E inState = prevAnalysisState.getBlockState(prevBasicBlock).getInState();\r\n+        newAnalysisState = finishBasicBlock(prevBasicBlock, inState, prevAnalysisState, visitedBasicBlocks);\r\n+      } else if (eBlockIdx < prevBasicBlock.getElementaryBlockCount()) {\r\n+        // handle non-empty basic block\r\n+        E prevOutState;\r\n+        ElementaryBlock nextElementaryBlock;\r\n+        if (eBlockIdx < 0) {\r\n+          // first elementary block\r\n+          prevOutState = prevAnalysisState.getBlockState(prevBasicBlock).getInState();\r\n+          nextElementaryBlock = getElementaryBlock(prevBasicBlock, 0);\r\n+        } else if (eBlockIdx < prevBasicBlock.getElementaryBlockCount() - 1) {\r\n+          // some elementary block that is not the first or last in the basic block\r\n+          ElementaryBlock prevElementaryBlock = getElementaryBlock(prevBasicBlock, eBlockIdx);\r\n+          prevOutState = prevAnalysisState.getBlockState(prevElementaryBlock).getOutState();\r\n+          nextElementaryBlock = getElementaryBlock(prevBasicBlock, eBlockIdx + 1);\r\n+        } else {\r\n+          ElementaryBlock prevElementaryBlock = getElementaryBlock(prevBasicBlock, eBlockIdx);\r\n+          prevOutState = prevAnalysisState.getBlockState(prevElementaryBlock).getOutState();\r\n+          nextElementaryBlock = null;\r\n         }\r\n-    }\r\n \r\n-    private List<BasicBlock> getPredecessors(BasicBlock bBlock) {\r\n-        switch (direction) {\r\n-        case FORWARD:\r\n-            return cfg.getPredecessors(bBlock);\r\n-        case BACKWARD:\r\n-            return cfg.getSuccessors(bBlock);\r\n-        default:\r\n-            throw new IllegalStateException();\r\n+        if (nextElementaryBlock == null) {\r\n+          E basicBlockInState = prevAnalysisState.getBlockState(prevBasicBlock).getInState();\r\n+          newAnalysisState =\r\n+              finishBasicBlock(prevBasicBlock, basicBlockInState, prevAnalysisState, visitedBasicBlocks);\r\n+        } else {\r\n+          E nextOutState = dfa.transition(prevOutState, nextElementaryBlock.getUnit());\r\n+          BlockState<E> nextBlockState = new BlockState<E>(prevOutState, nextOutState);\r\n+          newAnalysisState = newState(prevAnalysisState, prevWorklist.clone(), prevBasicBlock, ++eBlockIdx);\r\n+          newAnalysisState.setBlockState(prevBasicBlock, nextBlockState);\r\n         }\r\n-    }\r\n \r\n-    private List<BasicBlock> getSuccessors(BasicBlock bBlock) {\r\n-        switch (direction) {\r\n-        case FORWARD:\r\n-            return cfg.getSuccessors(bBlock);\r\n-        case BACKWARD:\r\n-            return cfg.getPredecessors(bBlock);\r\n-        default:\r\n-            throw new IllegalStateException(\"unknown direction: \" + getDirection());\r\n-        }\r\n+        analysisStates.add(newAnalysisState);\r\n+        prevAnalysisState = newAnalysisState;\r\n+        ++elementaryStep;\r\n+      }\r\n     }\r\n-\r\n-    private AnalysisState<E> newState(AnalysisState<E> state, Worklist newWorklist, BasicBlock currentBBlock,\r\n-            int eBlockIdx) {\r\n-        AnalysisState<E> newState = new AnalysisState<E>(newWorklist, currentBBlock, eBlockIdx);\r\n-        return newState;\r\n+  }\r\n+\r\n+  private BasicBlock getStartBlock() {\r\n+    switch (getDirection()) {\r\n+      case FORWARD:\r\n+        return cfg.getStartBlock();\r\n+      case BACKWARD:\r\n+        return cfg.getEndBlock();\r\n+      default:\r\n+        throw new IllegalStateException(\"unknown direction: \" + getDirection());\r\n     }\r\n-\r\n-    /*\r\n-     * updates the color-mapping in newState according to prevState and the worklist and current BasicBlock of newState\r\n-     */\r\n-    private void updateColors(AnalysisState<E> prevState, AnalysisState<E> newState, Set<BasicBlock> visited) {\r\n-        List<BasicBlock> basicBlocks = cfg.getBasicBlocks();\r\n-        Worklist newWorklist = newState.getWorklist();\r\n-\r\n-        for (BasicBlock basicBlock : basicBlocks) {\r\n-            LogicalColor newColor;\r\n-            if (basicBlock.equals(newState.getCurrentBasicBlock())) {\r\n-                newColor = LogicalColor.CURRENT;\r\n-            } else if (newWorklist.contains(basicBlock)) {\r\n-                newColor = LogicalColor.ON_WORKLIST;\r\n-            } else {\r\n-                if (visited.contains(basicBlock)) {\r\n-                    newColor = LogicalColor.VISITED_NOT_ON_WORKLIST;\r\n-                } else {\r\n-                    newColor = LogicalColor.NOT_VISITED;\r\n-                }\r\n-            }\r\n-            newState.setColor(basicBlock, newColor);\r\n-        }\r\n+  }\r\n+\r\n+  private List<BasicBlock> getPredecessors(BasicBlock bBlock) {\r\n+    switch (direction) {\r\n+      case FORWARD:\r\n+        return cfg.getPredecessors(bBlock);\r\n+      case BACKWARD:\r\n+        return cfg.getSuccessors(bBlock);\r\n+      default:\r\n+        throw new IllegalStateException();\r\n     }\r\n-\r\n-    private AnalysisState<E> finishBasicBlock(BasicBlock currentBBlock, E outState, AnalysisState<E> prevAnalysisState,\r\n-            Set<BasicBlock> visited) {\r\n-        Worklist newWorklist = prevAnalysisState.getWorklist().clone();\r\n-        BlockState<E> prevBlockState = prevAnalysisState.getBlockState(currentBBlock);\r\n-\r\n-        List<BasicBlock> successors = getSuccessors(currentBBlock);\r\n-        if (!outState.equals(prevBlockState.getOutState())) {\r\n-            for (BasicBlock bSucc : successors) {\r\n-                newWorklist.add(bSucc);\r\n-            }\r\n+  }\r\n+\r\n+  private List<BasicBlock> getSuccessors(BasicBlock bBlock) {\r\n+    switch (direction) {\r\n+      case FORWARD:\r\n+        return cfg.getSuccessors(bBlock);\r\n+      case BACKWARD:\r\n+        return cfg.getPredecessors(bBlock);\r\n+      default:\r\n+        throw new IllegalStateException(\"unknown direction: \" + getDirection());\r\n+    }\r\n+  }\r\n+\r\n+  private AnalysisState<E> newState(AnalysisState<E> state, Worklist newWorklist, BasicBlock currentBBlock,\r\n+                                    int eBlockIdx) {\r\n+    AnalysisState<E> newState = new AnalysisState<E>(newWorklist, currentBBlock, eBlockIdx);\r\n+    return newState;\r\n+  }\r\n+\r\n+  /*\r\n+   * updates the color-mapping in newState according to prevState and the worklist and current BasicBlock of newState\r\n+   */\r\n+  private void updateColors(AnalysisState<E> prevState, AnalysisState<E> newState, Set<BasicBlock> visited) {\r\n+    List<BasicBlock> basicBlocks = cfg.getBasicBlocks();\r\n+    Worklist newWorklist = newState.getWorklist();\r\n+\r\n+    for (BasicBlock basicBlock : basicBlocks) {\r\n+      LogicalColor newColor;\r\n+      if (basicBlock.equals(newState.getCurrentBasicBlock())) {\r\n+        newColor = LogicalColor.CURRENT;\r\n+      } else if (newWorklist.contains(basicBlock)) {\r\n+        newColor = LogicalColor.ON_WORKLIST;\r\n+      } else {\r\n+        if (visited.contains(basicBlock)) {\r\n+          newColor = LogicalColor.VISITED_NOT_ON_WORKLIST;\r\n+        } else {\r\n+          newColor = LogicalColor.NOT_VISITED;\r\n         }\r\n-\r\n-        AnalysisState<E> newAnalysisState = newState(prevAnalysisState, newWorklist, null, -1);\r\n-        BlockState<E> newBlockState = new BlockState<E>(prevBlockState.getInState(), outState);\r\n-        newAnalysisState.setBlockState(currentBBlock, newBlockState);\r\n-\r\n-        updateColors(prevAnalysisState, newAnalysisState, visited);\r\n-        return newAnalysisState;\r\n+      }\r\n+      newState.setColor(basicBlock, newColor);\r\n+    }\r\n+  }\r\n+\r\n+  private AnalysisState<E> finishBasicBlock(BasicBlock currentBBlock, E outState, AnalysisState<E> prevAnalysisState,\r\n+                                            Set<BasicBlock> visited) {\r\n+    Worklist newWorklist = prevAnalysisState.getWorklist().clone();\r\n+    BlockState<E> prevBlockState = prevAnalysisState.getBlockState(currentBBlock);\r\n+\r\n+    List<BasicBlock> successors = getSuccessors(currentBBlock);\r\n+    if (!outState.equals(prevBlockState.getOutState())) {\r\n+      for (BasicBlock bSucc : successors) {\r\n+        newWorklist.add(bSucc);\r\n+      }\r\n     }\r\n \r\n-    private ElementaryBlock getElementaryBlock(BasicBlock bBlock, int eBlockIdx) {\r\n-        List<ElementaryBlock> elementaryBlocks = bBlock.getElementaryBlocks();\r\n-        switch (direction) {\r\n-        case FORWARD:\r\n-            return elementaryBlocks.get(eBlockIdx);\r\n-        case BACKWARD:\r\n-            return elementaryBlocks.get(bBlock.getElementaryBlockCount() - 1 - eBlockIdx);\r\n-        default:\r\n-            throw new IllegalStateException(\"unknown direction: \" + getDirection());\r\n-        }\r\n+    AnalysisState<E> newAnalysisState = newState(prevAnalysisState, newWorklist, null, -1);\r\n+    BlockState<E> newBlockState = new BlockState<E>(prevBlockState.getInState(), outState);\r\n+    newAnalysisState.setBlockState(currentBBlock, newBlockState);\r\n+\r\n+    updateColors(prevAnalysisState, newAnalysisState, visited);\r\n+    return newAnalysisState;\r\n+  }\r\n+\r\n+  private ElementaryBlock getElementaryBlock(BasicBlock bBlock, int eBlockIdx) {\r\n+    List<ElementaryBlock> elementaryBlocks = bBlock.getElementaryBlocks();\r\n+    switch (direction) {\r\n+      case FORWARD:\r\n+        return elementaryBlocks.get(eBlockIdx);\r\n+      case BACKWARD:\r\n+        return elementaryBlocks.get(bBlock.getElementaryBlockCount() - 1 - eBlockIdx);\r\n+      default:\r\n+        throw new IllegalStateException(\"unknown direction: \" + getDirection());\r\n     }\r\n+  }\r\n \r\n }\r\n",
            "diff_size": 670
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "60",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 146).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "362",
                    "column": "26",
                    "severity": "warning",
                    "message": "'catch' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                },
                {
                    "line": "408",
                    "column": "46",
                    "severity": "warning",
                    "message": "'++' is preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.NoWhitespaceBeforeCheck"
                },
                {
                    "line": "415",
                    "column": "15",
                    "severity": "warning",
                    "message": "'if' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                },
                {
                    "line": "428",
                    "column": "7",
                    "severity": "warning",
                    "message": "'if' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                },
                {
                    "line": "437",
                    "column": "3",
                    "severity": "warning",
                    "message": "'if' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                },
                {
                    "line": "451",
                    "column": "7",
                    "severity": "warning",
                    "message": "'if' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                },
                {
                    "line": "466",
                    "column": "7",
                    "severity": "warning",
                    "message": "'++' is followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.NoWhitespaceAfterCheck"
                },
                {
                    "line": "517",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 126).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "532",
                    "column": "15",
                    "severity": "warning",
                    "message": "'if' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                },
                {
                    "line": "539",
                    "column": "3",
                    "severity": "warning",
                    "message": "'if' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                },
                {
                    "line": "545",
                    "column": "7",
                    "severity": "warning",
                    "message": "'if' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                },
                {
                    "line": "560",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 146).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/ppati000-visualDFA/errored/1/2/DFAExecution.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/ppati000-visualDFA/codebuff/2/DFAExecution.java\nindex 68cd091c290..1fd381a84e7 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/ppati000-visualDFA/errored/1/2/DFAExecution.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/ppati000-visualDFA/codebuff/2/DFAExecution.java\n@@ -1,12 +1,11 @@\n-package dfa.framework;\r\n-\r\n-import java.util.ArrayList;\r\n-import java.util.Collections;\r\n-import java.util.HashSet;\r\n-import java.util.List;\r\n-import java.util.Map;\r\n-import java.util.Set;\r\n-\r\n+package dfa.framework;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n import soot.toolkits.graph.Block;\r\n \r\n /**\r\n@@ -16,21 +15,25 @@ import soot.toolkits.graph.Block;\n  *\r\n  * @param <E>\r\n  *        the type of {@code LatticeElement} used in this {@code DFAExecution}\r\n- */\r\n-public class DFAExecution<E extends LatticeElement> {\r\n-\r\n-    private final Worklist initialWorklist;\r\n-\r\n-    private final DFADirection direction;\r\n-\r\n-    private final DataFlowAnalysis<E> dfa;\r\n-\r\n-    private final ControlFlowGraph cfg;\r\n-\r\n-    private List<AnalysisState<E>> analysisStates = new ArrayList<>();\r\n-    private List<Integer> blockSteps = new ArrayList<>();\r\n-\r\n-    private int currentElementaryStep = -1;\r\n+ */\n+\n+\n+public class DFAExecution<E extends LatticeElement> {\n+\n+    private final Worklist initialWorklist;\n+\n+    private final DFADirection direction;\n+\n+    private final DataFlowAnalysis<E> dfa;\n+\n+    private final ControlFlowGraph cfg;\n+\n+    private List<AnalysisState<E>> analysisStates = new ArrayList<>();\n+\n+    private List<Integer> blockSteps = new ArrayList<>();\n+\n+    private int currentElementaryStep = -1;\n+\n     private int currentBlockStep = -1;\r\n \r\n     /**\r\n@@ -51,83 +54,90 @@ public class DFAExecution<E extends LatticeElement> {\n      * \r\n      * @throws NullPointerException\r\n      *         if {@code dfaFactory} is {@code null}\r\n-     */\r\n-    public DFAExecution(DFAFactory<E> dfaFactory, Worklist initialWorklist, SimpleBlockGraph blockGraph,\r\n-            DFAPrecalcController precalcController) {\r\n-        if (initialWorklist == null) {\r\n-            throw new IllegalArgumentException(\"initialWorklist must not be null\");\r\n-        }\r\n-\r\n-        if (blockGraph == null) {\r\n-            throw new IllegalArgumentException(\"blockGraph must not be null\");\r\n-        }\r\n-\r\n-        this.initialWorklist = initialWorklist;\r\n-        this.direction = dfaFactory.getDirection();\r\n-\r\n-        dfa = dfaFactory.getAnalysis(blockGraph);\r\n-\r\n-        this.cfg = new ControlFlowGraph(blockGraph);\r\n-\r\n-        precalc(precalcController);\r\n-    }\r\n-\r\n-    private DFAExecution(DFAExecution<E> copyFrom) {\r\n-        this.initialWorklist = copyFrom.initialWorklist;\r\n-        this.direction = copyFrom.getDirection();\r\n-        this.dfa = copyFrom.dfa;\r\n-        this.cfg = copyFrom.getCFG();\r\n-\r\n-        this.analysisStates = copyFrom.analysisStates;\r\n-        this.blockSteps = copyFrom.blockSteps;\r\n-\r\n-        setCurrentElementaryStep(copyFrom.getCurrentElementaryStep());\r\n-        setCurrentBlockStep(copyFrom.getCurrentBlockStep());\r\n+     */\n+\n+\n+    public DFAExecution(DFAFactory<E> dfaFactory, Worklist initialWorklist, SimpleBlockGraph blockGraph, DFAPrecalcController precalcController) {\n+        if (initialWorklist == null) {\n+            throw new IllegalArgumentException(\"initialWorklist must not be null\");\n+        }\n+\n+        if (blockGraph == null) {\n+            throw new IllegalArgumentException(\"blockGraph must not be null\");\n+        }\n+\n+        this.initialWorklist = initialWorklist;\n+        this.direction = dfaFactory.getDirection();\n+        dfa = dfaFactory.getAnalysis(blockGraph);\n+        this.cfg = new ControlFlowGraph(blockGraph);\n+        precalc(precalcController);\n+    }\n+\n+\n+    private DFAExecution(DFAExecution<E> copyFrom) {\n+        this.initialWorklist = copyFrom.initialWorklist;\n+        this.direction = copyFrom.getDirection();\n+        this.dfa = copyFrom.dfa;\n+        this.cfg = copyFrom.getCFG();\n+        this.analysisStates = copyFrom.analysisStates;\n+        this.blockSteps = copyFrom.blockSteps;\n+        setCurrentElementaryStep(copyFrom.getCurrentElementaryStep());\n+        setCurrentBlockStep(copyFrom.getCurrentBlockStep());\n     }\r\n \r\n     /**\r\n      * Returns the {@code ControlFlowGraph} that is used to execute the dataflow-analysis.\r\n      * \r\n      * @return the {@code ControlFlowGraph} used to execute the dataflow-analysis\r\n-     */\r\n-    public ControlFlowGraph getCFG() {\r\n-        return cfg;\r\n+     */\n+\n+\n+    public ControlFlowGraph getCFG() {\n+        return cfg;\n     }\r\n \r\n     /**\r\n      * Returns the direction of the {@code DataFlowAnalysis} that is executed.\r\n      * \r\n      * @return the direction of the {@code DataFlowAnalysis} that is executed\r\n-     */\r\n-    public DFADirection getDirection() {\r\n-        return direction;\r\n+     */\n+\n+\n+    public DFADirection getDirection() {\n+        return direction;\n     }\r\n \r\n     /**\r\n      * Returns the total number of elementary-steps.\r\n      * \r\n      * @return the total number of elementary-steps\r\n-     */\r\n-    public int getTotalElementarySteps() {\r\n-        return analysisStates.size();\r\n+     */\n+\n+\n+    public int getTotalElementarySteps() {\n+        return analysisStates.size();\n     }\r\n \r\n     /**\r\n      * Returns the total number of block-steps.\r\n      * \r\n      * @return the total number of block-steps\r\n-     */\r\n-    public int getTotalBlockSteps() {\r\n-        return blockSteps.size();\r\n+     */\n+\n+\n+    public int getTotalBlockSteps() {\n+        return blockSteps.size();\n     }\r\n \r\n     /**\r\n      * Returns the current elementary-step.\r\n      * \r\n      * @return the current elementary-step, always in range {@code [0, ..., getTotalElementarySteps() - 1]}\r\n-     */\r\n-    public int getCurrentElementaryStep() {\r\n-        return currentElementaryStep;\r\n+     */\n+\n+\n+    public int getCurrentElementaryStep() {\n+        return currentElementaryStep;\n     }\r\n \r\n     /**\r\n@@ -139,28 +149,33 @@ public class DFAExecution<E extends LatticeElement> {\n      * \r\n      * @throws IllegalArgumentException\r\n      *         if {@code elementaryStep} is not in range {@code [0, ..., getTotalElementarySteps() - 1]}\r\n-     */\r\n-    public void setCurrentElementaryStep(int elementaryStep) {\r\n-        if (elementaryStep < 0 || elementaryStep >= getTotalElementarySteps()) {\r\n-            throw new IndexOutOfBoundsException(\"invalid elementaryStep: \" + elementaryStep);\r\n-        }\r\n-\r\n-        currentElementaryStep = elementaryStep;\r\n-        int idx = Collections.binarySearch(blockSteps, currentElementaryStep);\r\n-\r\n-        if (idx < 0) { // currentElementaryStep has not been found\r\n-            idx = -(idx + 1); // this gives the correct index of the corresponding block-step\r\n-        }\r\n-        currentBlockStep = idx;\r\n+     */\n+\n+\n+    public void setCurrentElementaryStep(int elementaryStep) {\n+        if (elementaryStep < 0 || elementaryStep >= getTotalElementarySteps()) {\n+            throw new IndexOutOfBoundsException(\"invalid elementaryStep: \" + elementaryStep);\n+        }\n+\n+        currentElementaryStep = elementaryStep;\n+\n+        int idx = Collections.binarySearch(blockSteps, currentElementaryStep);\n+        if (idx < 0) { // currentElementaryStep has not been found\n+            idx = -(idx + 1); // this gives the correct index of the corresponding block-step\n+        }\n+\n+        currentBlockStep = idx;\n     }\r\n \r\n     /**\r\n      * Returns the current block-step.\r\n      * \r\n      * @return the current block-step, always in range {@code [0, ..., getTotalBlockSteps() - 1]}\r\n-     */\r\n-    public int getCurrentBlockStep() {\r\n-        return currentBlockStep;\r\n+     */\n+\n+\n+    public int getCurrentBlockStep() {\n+        return currentBlockStep;\n     }\r\n \r\n     /**\r\n@@ -171,74 +186,84 @@ public class DFAExecution<E extends LatticeElement> {\n      * \r\n      * @throws IllegalArgumentException\r\n      *         if {@code blockStep} is not in range {@code [0, ..., getTotalBlockSteps() - 1]}\r\n-     */\r\n-    public void setCurrentBlockStep(int blockStep) {\r\n-        if (blockStep < 0 || blockStep >= getTotalBlockSteps()) {\r\n-            throw new IndexOutOfBoundsException(\"invalid blockStep: \" + blockStep);\r\n-        }\r\n-\r\n-        currentBlockStep = blockStep;\r\n-        currentElementaryStep = blockSteps.get(blockStep);\r\n+     */\n+\n+\n+    public void setCurrentBlockStep(int blockStep) {\n+        if (blockStep < 0 || blockStep >= getTotalBlockSteps()) {\n+            throw new IndexOutOfBoundsException(\"invalid blockStep: \" + blockStep);\n+        }\n+\n+        currentBlockStep = blockStep;\n+        currentElementaryStep = blockSteps.get(blockStep);\n     }\r\n \r\n     /**\r\n      * Increases the current elementary-step (by 1) if possible.\r\n      * \r\n      * @return {@code true} if there was a next elementary-step, {@code false} otherwise\r\n-     */\r\n-    public boolean nextElementaryStep() {\r\n-        int nextStep = getCurrentElementaryStep() + 1;\r\n-        if (nextStep < getTotalElementarySteps()) {\r\n-            setCurrentElementaryStep(nextStep);\r\n-            return true;\r\n-        }\r\n-\r\n-        return false;\r\n+     */\n+\n+\n+    public boolean nextElementaryStep() {\n+        int nextStep = getCurrentElementaryStep() + 1;\n+        if (nextStep < getTotalElementarySteps()) {\n+            setCurrentElementaryStep(nextStep);\n+            return true;\n+        }\n+\n+        return false;\n     }\r\n \r\n     /**\r\n      * Decreases the current elementary-step by 1 if possible.\r\n      * \r\n      * @return {@code true} if there was a next elementary-step, {@code false} otherwise\r\n-     */\r\n-    public boolean previousElementaryStep() {\r\n-        int prevStep = getCurrentElementaryStep() - 1;\r\n-        if (prevStep >= 0) {\r\n-            setCurrentElementaryStep(prevStep);\r\n-            return true;\r\n-        }\r\n-\r\n-        return false;\r\n+     */\n+\n+\n+    public boolean previousElementaryStep() {\n+        int prevStep = getCurrentElementaryStep() - 1;\n+        if (prevStep >= 0) {\n+            setCurrentElementaryStep(prevStep);\n+            return true;\n+        }\n+\n+        return false;\n     }\r\n \r\n     /**\r\n      * Advances the current block-step (by 1) if possible.\r\n      * \r\n      * @return {@code true} if there was a next block-step, {@code false} otherwise\r\n-     */\r\n-    public boolean nextBlockStep() {\r\n-        int nextBlockStep = getCurrentBlockStep() + 1;\r\n-        if (nextBlockStep < getTotalBlockSteps()) {\r\n-            setCurrentBlockStep(nextBlockStep);\r\n-            return true;\r\n-        }\r\n-\r\n-        return false;\r\n+     */\n+\n+\n+    public boolean nextBlockStep() {\n+        int nextBlockStep = getCurrentBlockStep() + 1;\n+        if (nextBlockStep < getTotalBlockSteps()) {\n+            setCurrentBlockStep(nextBlockStep);\n+            return true;\n+        }\n+\n+        return false;\n     }\r\n \r\n     /**\r\n      * Decreases the current block-step by 1 if possible.\r\n      * \r\n      * @return {@code true} if there was a next block-step, {@code false} otherwise\r\n-     */\r\n-    public boolean previousBlockStep() {\r\n-        int currentBlockStep = getCurrentBlockStep() - 1;\r\n-        if (currentBlockStep >= 0) {\r\n-            setCurrentBlockStep(currentBlockStep);\r\n-            return true;\r\n-        }\r\n-\r\n-        return false;\r\n+     */\n+\n+\n+    public boolean previousBlockStep() {\n+        int currentBlockStep = getCurrentBlockStep() - 1;\n+        if (currentBlockStep >= 0) {\n+            setCurrentBlockStep(currentBlockStep);\n+            return true;\n+        }\n+\n+        return false;\n     }\r\n \r\n     /**\r\n@@ -246,276 +271,323 @@ public class DFAExecution<E extends LatticeElement> {\n      * \r\n      * @return {@code true} if the {@code ElementaryBlock} of the current elementary-step has a breakpoint,\r\n      *         {@code false} otherwise\r\n-     */\r\n-    public boolean isAtBreakpoint() {\r\n-        AnalysisState<? extends LatticeElement> currentState = getCurrentAnalysisState();\r\n-        BasicBlock bBlock = currentState.getCurrentBasicBlock();\r\n-\r\n-        if (bBlock == null) {\r\n-            return false;\r\n-        }\r\n-\r\n-        int eBlockIdx = currentState.getCurrentElementaryBlockIndex();\r\n-        return bBlock.getElementaryBlock(eBlockIdx).hasBreakpoint();\r\n+     */\n+\n+\n+    public boolean isAtBreakpoint() {\n+        AnalysisState<? extends LatticeElement> currentState = getCurrentAnalysisState();\n+        BasicBlock bBlock = currentState.getCurrentBasicBlock();\n+        if (bBlock == null) {\n+            return false;\n+        }\n+\n+        int eBlockIdx = currentState.getCurrentElementaryBlockIndex();\n+        return bBlock.getElementaryBlock(eBlockIdx).hasBreakpoint();\n     }\r\n \r\n     /**\r\n      * Returns the current {@code AnalysisState}, i. e. the state of the analysis at the current elementary-step.\r\n      * \r\n      * @return the current {@code AnalysisState}\r\n-     */\r\n-    public AnalysisState<? extends LatticeElement> getCurrentAnalysisState() {\r\n-        return analysisStates.get(currentElementaryStep);\r\n+     */\n+\n+\n+    public AnalysisState<? extends LatticeElement> getCurrentAnalysisState() {\n+        return analysisStates.get(currentElementaryStep);\n     }\r\n \r\n     /**\r\n      * Creates a <em>shallow copy</em> of this {@code DFAExecution}. The returned copy shares the {@code AnalysisState}s\r\n      * with the original but can have different current block- or elementary-steps.\r\n-     */\r\n-    @Override\r\n-    public DFAExecution<E> clone() {\r\n-        return new DFAExecution<E>(this);\r\n-    }\r\n-\r\n-    private void precalc(DFAPrecalcController precalcCtrl) {\r\n-        Map<Block, BlockState<E>> initialStates = dfa.getInitialStates();\r\n-\r\n-        BasicBlock startBlock = getStartBlock();\r\n-        if (startBlock == null) {\r\n-            throw new DFAException(\"there is no start block\");\r\n-        }\r\n-\r\n-        AnalysisState<E> initialState = new AnalysisState<E>(initialWorklist, startBlock, -1);\r\n-\r\n-        List<BasicBlock> basicBlocks = cfg.getBasicBlocks();\r\n-        for (BasicBlock bBlock : basicBlocks) {\r\n-            Block sootBlock = bBlock.getSootBlock();\r\n-            BlockState<E> state = initialStates.get(sootBlock);\r\n-\r\n-            LogicalColor lColor = bBlock.equals(startBlock) ? LogicalColor.CURRENT : LogicalColor.NOT_VISITED;\r\n-            initialState.setBlockState(bBlock, state);\r\n+     */\n+\n+    @Override\n+    public DFAExecution<E> clone() {\n+        return new DFAExecution<E>(this);\n+    }\n+\n+\n+    private void precalc(DFAPrecalcController precalcCtrl) {\n+        Map<Block, BlockState<E>> initialStates = dfa.getInitialStates();\n+        BasicBlock startBlock = getStartBlock();\n+        if (startBlock == null) {\n+            throw new DFAException(\"there is no start block\");\n+        }\n+\n+        AnalysisState<E> initialState = new AnalysisState<E>(initialWorklist, startBlock, -1);\n+        List<BasicBlock> basicBlocks = cfg.getBasicBlocks();\n+        for (BasicBlock bBlock : basicBlocks) {\n+            Block sootBlock = bBlock.getSootBlock();\n+            BlockState<E> state = initialStates.get(sootBlock);\n+            LogicalColor lColor = bBlock.equals(startBlock) ? LogicalColor.CURRENT : LogicalColor.NOT_VISITED;\n+            initialState.setBlockState(bBlock, state);\n             initialState.setColor(bBlock, lColor);\r\n \r\n-            // set all in- and out-states to null for the elementary-blocks\r\n-            List<ElementaryBlock> elementaryBlocks = bBlock.getElementaryBlocks();\r\n-            BlockState<E> nullState = new BlockState<E>(null, null);\r\n-            for (ElementaryBlock eBlock : elementaryBlocks) {\r\n-                initialState.setBlockState(eBlock, nullState);\r\n-            }\r\n-\r\n-        }\r\n-\r\n+            // set all in- and out-states to null for the elementary-blocks\n+            List<ElementaryBlock> elementaryBlocks = bBlock.getElementaryBlocks();\n+            BlockState<E> nullState = new BlockState<E>(null, null);\n+            for (ElementaryBlock eBlock : elementaryBlocks) {\n+                initialState.setBlockState(eBlock, nullState);\n+            }\n+        }\n+\n         analysisStates.add(initialState);\r\n \r\n-        // elementary step 0 is always a block step\r\n-        blockSteps.add(0);\r\n-\r\n-        iterateToFixpoint(initialState, precalcCtrl);\r\n-    }\r\n-\r\n-    private void iterateToFixpoint(AnalysisState<E> initialState, DFAPrecalcController precalcCtrl) {\r\n-        Set<BasicBlock> visitedBasicBlocks = new HashSet<BasicBlock>();\r\n-        visitedBasicBlocks.add(getStartBlock());\r\n-\r\n-        int elementaryStep = 1;\r\n-        AnalysisState<E> prevAnalysisState = initialState;\r\n-\r\n-        while (true) {\r\n-            switch (precalcCtrl.getPrecalcState()) {\r\n-            case CALCULATING:\r\n-                break; // break switch\r\n-            case COMPLETED:\r\n-                return;\r\n-            case PAUSED:\r\n-                try {\r\n-                    Thread.sleep(precalcCtrl.getWaitTime());\r\n-                } catch (InterruptedException e) {\r\n-                    e.printStackTrace();\r\n-                }\r\n-                continue;\r\n-            case STOPPED:\r\n-                precalcCtrl.setResult(this, false);\r\n-                return;\r\n-            default:\r\n-                throw new IllegalStateException(\"unknown precalc state: \" + precalcCtrl.getPrecalcState());\r\n-            }\r\n-\r\n-            BasicBlock prevBasicBlock = prevAnalysisState.getCurrentBasicBlock();\r\n-\r\n-            AnalysisState<E> newAnalysisState = null;\r\n-            Worklist prevWorklist = prevAnalysisState.getWorklist();\r\n+        // elementary step 0 is always a block step\n+        blockSteps.add(0);\n+        iterateToFixpoint(initialState, precalcCtrl);\n+    }\n+\n+\n+    private void iterateToFixpoint(AnalysisState<E> initialState, DFAPrecalcController precalcCtrl) {\n+        Set<BasicBlock> visitedBasicBlocks = new HashSet<BasicBlock>();\n+        visitedBasicBlocks.add(getStartBlock());\n+\n+        int elementaryStep = 1;\n+        AnalysisState<E> prevAnalysisState = initialState;\n+        while (true) {\n+            switch(precalcCtrl.getPrecalcState()) {\n+                case CALCULATING:\n+                break; // break switch\n+\n+                                                  case COMPLETED:\n+                return;\n+\n+                                                  case PAUSED:\n+                try {\n+                    Thread.sleep(precalcCtrl.getWaitTime());\n+                }\n+\n+\n+                    catch(InterruptedException e) {\n+                    e.printStackTrace();\n+                }\n+\n+                continue;\n+\n+                                                  case STOPPED:\n+                precalcCtrl.setResult(this, false);\n+                return;\n+\n+                                                  default:\n+                throw new IllegalStateException(\"unknown precalc state: \" + precalcCtrl.getPrecalcState());\n+\n+}\n+\n+            BasicBlock prevBasicBlock = prevAnalysisState.getCurrentBasicBlock();\n+            AnalysisState<E> newAnalysisState = null;\n+            Worklist prevWorklist = prevAnalysisState.getWorklist();\n             if (prevBasicBlock == null) {\r\n-                // no basic block currently selected, this begins a new basic block step (or completes calculation)\r\n-\r\n+                // no basic block currently selected, this begins a new basic block step (or completes calculation)\n                 if (prevWorklist.isEmpty()) {\r\n-                    // we are at a fixpoint\r\n-                    precalcCtrl.setResult(this, true);\r\n-                    return;\r\n-                }\r\n-\r\n-                Worklist newWorklist = prevWorklist.clone();\r\n-                BasicBlock newBasicBlock = newWorklist.poll();\r\n-                visitedBasicBlocks.add(newBasicBlock);\r\n-\r\n+                    // we are at a fixpoint\n+                    precalcCtrl.setResult(this, true);\n+                    return;\n+                }\n+\n+                Worklist newWorklist = prevWorklist.clone();\n+                BasicBlock newBasicBlock = newWorklist.poll();\n+                visitedBasicBlocks.add(newBasicBlock);\n                 newAnalysisState = newState(prevAnalysisState, newWorklist, newBasicBlock, -1);\r\n \r\n-                // join predecessors out-states\r\n-                List<BasicBlock> preds = getPredecessors(newBasicBlock);\r\n-                Set<E> predOutStates = new HashSet<E>();\r\n-                for (BasicBlock p : preds) {\r\n-                    predOutStates.add(prevAnalysisState.getBlockState(p).getOutState());\r\n-                }\r\n-                E outStatesJoin = dfa.join(predOutStates);\r\n-\r\n-                BlockState<E> prevBlockState = prevAnalysisState.getBlockState(prevBasicBlock);\r\n-                BlockState<E> newBlockState = new BlockState<E>(outStatesJoin, prevBlockState.getOutState());\r\n-                newAnalysisState.setBlockState(newBasicBlock, newBlockState);\r\n-\r\n-                updateColors(prevAnalysisState, newAnalysisState, visitedBasicBlocks);\r\n-\r\n+                // join predecessors out-states\n+                List<BasicBlock> preds = getPredecessors(newBasicBlock);\n+                Set<E> predOutStates = new HashSet<E>();\n+                for (BasicBlock p : preds) {\n+                    predOutStates.add(prevAnalysisState.getBlockState(p).getOutState());\n+                }\n+\n+                E outStatesJoin = dfa.join(predOutStates);\n+                BlockState<E> prevBlockState = prevAnalysisState.getBlockState(prevBasicBlock);\n+                BlockState<E> newBlockState = new BlockState<E>(outStatesJoin, prevBlockState.getOutState());\n+                newAnalysisState.setBlockState(newBasicBlock, newBlockState);\n+                updateColors(prevAnalysisState, newAnalysisState, visitedBasicBlocks);\n                 analysisStates.add(newAnalysisState);\r\n \r\n-                // this begins a new block step\r\n-                blockSteps.add(elementaryStep++);\r\n-                continue;\r\n+                // this begins a new block step\n+                blockSteps.add(elementaryStep ++);\n+                continue;\n             }\r\n \r\n-            // prevBasicBlock is not null (so this is not a new block step)\r\n-            int eBlockIdx = prevAnalysisState.getCurrentElementaryBlockIndex();\r\n-            if (prevBasicBlock.getElementaryBlockCount() == 0) {\r\n-                // handle empty basic block [e. g. artificial end block]\r\n-                E inState = prevAnalysisState.getBlockState(prevBasicBlock).getInState();\r\n-                newAnalysisState = finishBasicBlock(prevBasicBlock, inState, prevAnalysisState, visitedBasicBlocks);\r\n-            } else if (eBlockIdx < prevBasicBlock.getElementaryBlockCount()) {\r\n-                // handle non-empty basic block\r\n-                E prevOutState;\r\n-                ElementaryBlock nextElementaryBlock;\r\n-                if (eBlockIdx < 0) {\r\n-                    // first elementary block\r\n-                    prevOutState = prevAnalysisState.getBlockState(prevBasicBlock).getInState();\r\n-                    nextElementaryBlock = getElementaryBlock(prevBasicBlock, 0);\r\n-                } else if (eBlockIdx < prevBasicBlock.getElementaryBlockCount() - 1) {\r\n-                    // some elementary block that is not the first or last in the basic block\r\n-                    ElementaryBlock prevElementaryBlock = getElementaryBlock(prevBasicBlock, eBlockIdx);\r\n-                    prevOutState = prevAnalysisState.getBlockState(prevElementaryBlock).getOutState();\r\n-                    nextElementaryBlock = getElementaryBlock(prevBasicBlock, eBlockIdx + 1);\r\n-                } else {\r\n-                    ElementaryBlock prevElementaryBlock = getElementaryBlock(prevBasicBlock, eBlockIdx);\r\n-                    prevOutState = prevAnalysisState.getBlockState(prevElementaryBlock).getOutState();\r\n-                    nextElementaryBlock = null;\r\n-                }\r\n-\r\n-                if (nextElementaryBlock == null) {\r\n-                    E basicBlockInState = prevAnalysisState.getBlockState(prevBasicBlock).getInState();\r\n-                    newAnalysisState =\r\n-                            finishBasicBlock(prevBasicBlock, basicBlockInState, prevAnalysisState, visitedBasicBlocks);\r\n-                } else {\r\n-                    E nextOutState = dfa.transition(prevOutState, nextElementaryBlock.getUnit());\r\n-                    BlockState<E> nextBlockState = new BlockState<E>(prevOutState, nextOutState);\r\n-                    newAnalysisState = newState(prevAnalysisState, prevWorklist.clone(), prevBasicBlock, ++eBlockIdx);\r\n-                    newAnalysisState.setBlockState(prevBasicBlock, nextBlockState);\r\n-                }\r\n-\r\n-                analysisStates.add(newAnalysisState);\r\n-                prevAnalysisState = newAnalysisState;\r\n-                ++elementaryStep;\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    private BasicBlock getStartBlock() {\r\n-        switch (getDirection()) {\r\n-        case FORWARD:\r\n-            return cfg.getStartBlock();\r\n-        case BACKWARD:\r\n-            return cfg.getEndBlock();\r\n-        default:\r\n-            throw new IllegalStateException(\"unknown direction: \" + getDirection());\r\n-        }\r\n-    }\r\n-\r\n-    private List<BasicBlock> getPredecessors(BasicBlock bBlock) {\r\n-        switch (direction) {\r\n-        case FORWARD:\r\n-            return cfg.getPredecessors(bBlock);\r\n-        case BACKWARD:\r\n-            return cfg.getSuccessors(bBlock);\r\n-        default:\r\n-            throw new IllegalStateException();\r\n-        }\r\n-    }\r\n-\r\n-    private List<BasicBlock> getSuccessors(BasicBlock bBlock) {\r\n-        switch (direction) {\r\n-        case FORWARD:\r\n-            return cfg.getSuccessors(bBlock);\r\n-        case BACKWARD:\r\n-            return cfg.getPredecessors(bBlock);\r\n-        default:\r\n-            throw new IllegalStateException(\"unknown direction: \" + getDirection());\r\n-        }\r\n-    }\r\n-\r\n-    private AnalysisState<E> newState(AnalysisState<E> state, Worklist newWorklist, BasicBlock currentBBlock,\r\n-            int eBlockIdx) {\r\n-        AnalysisState<E> newState = new AnalysisState<E>(newWorklist, currentBBlock, eBlockIdx);\r\n-        return newState;\r\n+            // prevBasicBlock is not null (so this is not a new block step)\n+\n+            int eBlockIdx = prevAnalysisState.getCurrentElementaryBlockIndex();\n+            if(prevBasicBlock.getElementaryBlockCount() == 0) {\r\n+                // handle empty basic block [e. g. artificial end block]\n+                E inState = prevAnalysisState.getBlockState(prevBasicBlock).getInState();\n+                newAnalysisState = finishBasicBlock(prevBasicBlock, inState, prevAnalysisState, visitedBasicBlocks);\n+            }\n+\n+\n+else\n+\n+if (eBlockIdx < prevBasicBlock.getElementaryBlockCount()) {\r\n+                // handle non-empty basic block\n+    E prevOutState;\n+    ElementaryBlock nextElementaryBlock;\n+    if(eBlockIdx < 0) {\r\n+                    // first elementary block\n+        prevOutState = prevAnalysisState.getBlockState(prevBasicBlock).getInState();\n+        nextElementaryBlock = getElementaryBlock(prevBasicBlock, 0);\n+    }\n+\n+\n+else\n+\n+if(eBlockIdx < prevBasicBlock.getElementaryBlockCount() - 1) {\r\n+                    // some elementary block that is not the first or last in the basic block\n+    ElementaryBlock prevElementaryBlock = getElementaryBlock(prevBasicBlock, eBlockIdx);\n+    prevOutState = prevAnalysisState.getBlockState(prevElementaryBlock).getOutState();\n+    nextElementaryBlock = getElementaryBlock(prevBasicBlock, eBlockIdx + 1);\n+}\n+\n+\n+    else {\n+    ElementaryBlock prevElementaryBlock = getElementaryBlock(prevBasicBlock, eBlockIdx);\n+    prevOutState = prevAnalysisState.getBlockState(prevElementaryBlock).getOutState();\n+    nextElementaryBlock = null;\n+}\n+\n+    if(nextElementaryBlock == null) {\n+        E basicBlockInState = prevAnalysisState.getBlockState(prevBasicBlock).getInState();\n+        newAnalysisState = finishBasicBlock(prevBasicBlock, basicBlockInState, prevAnalysisState, visitedBasicBlocks);\n+    }\n+\n+\n+else {\n+        E nextOutState = dfa.transition(prevOutState, nextElementaryBlock.getUnit());\n+        BlockState<E> nextBlockState = new BlockState<E>(prevOutState, nextOutState);\n+        newAnalysisState = newState(prevAnalysisState, prevWorklist.clone(), prevBasicBlock, ++eBlockIdx);\n+        newAnalysisState.setBlockState(prevBasicBlock, nextBlockState);\n+    }\n+\n+    analysisStates.add(newAnalysisState);\n+    prevAnalysisState = newAnalysisState;\n+    ++ elementaryStep;\n+}\n+        }\n+    }\n+\n+\n+    private BasicBlock getStartBlock() {\n+        switch(getDirection()) {\n+            case FORWARD:\n+            return cfg.getStartBlock();\n+\n+                               case BACKWARD:\n+            return cfg.getEndBlock();\n+\n+                               default:\n+            throw new IllegalStateException(\"unknown direction: \" + getDirection());\n+\n+        }\n+    }\n+\n+\n+    private List<BasicBlock> getPredecessors(BasicBlock bBlock) {\n+        switch(direction) {\n+            case FORWARD:\n+            return cfg.getPredecessors(bBlock);\n+\n+                          case BACKWARD:\n+            return cfg.getSuccessors(bBlock);\n+\n+                          default:\n+            throw new IllegalStateException();\n+\n+        }\n+    }\n+\n+\n+    private List<BasicBlock> getSuccessors(BasicBlock bBlock) {\n+        switch(direction) {\n+            case FORWARD:\n+            return cfg.getSuccessors(bBlock);\n+\n+                          case BACKWARD:\n+            return cfg.getPredecessors(bBlock);\n+\n+                          default:\n+            throw new IllegalStateException(\"unknown direction: \" + getDirection());\n+\n+        }\n+    }\n+\n+\n+    private AnalysisState<E> newState(AnalysisState<E> state, Worklist newWorklist, BasicBlock currentBBlock, int eBlockIdx) {\n+        AnalysisState<E> newState = new AnalysisState<E>(newWorklist, currentBBlock, eBlockIdx);\n+        return newState;\n     }\r\n \r\n     /*\r\n      * updates the color-mapping in newState according to prevState and the worklist and current BasicBlock of newState\r\n-     */\r\n-    private void updateColors(AnalysisState<E> prevState, AnalysisState<E> newState, Set<BasicBlock> visited) {\r\n-        List<BasicBlock> basicBlocks = cfg.getBasicBlocks();\r\n-        Worklist newWorklist = newState.getWorklist();\r\n-\r\n-        for (BasicBlock basicBlock : basicBlocks) {\r\n-            LogicalColor newColor;\r\n-            if (basicBlock.equals(newState.getCurrentBasicBlock())) {\r\n-                newColor = LogicalColor.CURRENT;\r\n-            } else if (newWorklist.contains(basicBlock)) {\r\n-                newColor = LogicalColor.ON_WORKLIST;\r\n-            } else {\r\n-                if (visited.contains(basicBlock)) {\r\n-                    newColor = LogicalColor.VISITED_NOT_ON_WORKLIST;\r\n-                } else {\r\n-                    newColor = LogicalColor.NOT_VISITED;\r\n-                }\r\n-            }\r\n-            newState.setColor(basicBlock, newColor);\r\n-        }\r\n-    }\r\n-\r\n-    private AnalysisState<E> finishBasicBlock(BasicBlock currentBBlock, E outState, AnalysisState<E> prevAnalysisState,\r\n-            Set<BasicBlock> visited) {\r\n-        Worklist newWorklist = prevAnalysisState.getWorklist().clone();\r\n-        BlockState<E> prevBlockState = prevAnalysisState.getBlockState(currentBBlock);\r\n-\r\n-        List<BasicBlock> successors = getSuccessors(currentBBlock);\r\n-        if (!outState.equals(prevBlockState.getOutState())) {\r\n-            for (BasicBlock bSucc : successors) {\r\n-                newWorklist.add(bSucc);\r\n-            }\r\n-        }\r\n-\r\n-        AnalysisState<E> newAnalysisState = newState(prevAnalysisState, newWorklist, null, -1);\r\n-        BlockState<E> newBlockState = new BlockState<E>(prevBlockState.getInState(), outState);\r\n-        newAnalysisState.setBlockState(currentBBlock, newBlockState);\r\n-\r\n-        updateColors(prevAnalysisState, newAnalysisState, visited);\r\n-        return newAnalysisState;\r\n-    }\r\n-\r\n-    private ElementaryBlock getElementaryBlock(BasicBlock bBlock, int eBlockIdx) {\r\n-        List<ElementaryBlock> elementaryBlocks = bBlock.getElementaryBlocks();\r\n-        switch (direction) {\r\n-        case FORWARD:\r\n-            return elementaryBlocks.get(eBlockIdx);\r\n-        case BACKWARD:\r\n-            return elementaryBlocks.get(bBlock.getElementaryBlockCount() - 1 - eBlockIdx);\r\n-        default:\r\n-            throw new IllegalStateException(\"unknown direction: \" + getDirection());\r\n-        }\r\n-    }\r\n-\r\n-}\r\n+     */\n+\n+\n+    private void updateColors(AnalysisState<E> prevState, AnalysisState<E> newState, Set<BasicBlock> visited) {\n+        List<BasicBlock> basicBlocks = cfg.getBasicBlocks();\n+        Worklist newWorklist = newState.getWorklist();\n+        for (BasicBlock basicBlock : basicBlocks) {\n+            LogicalColor newColor;\n+            if(basicBlock.equals(newState.getCurrentBasicBlock())) {\n+                newColor = LogicalColor.CURRENT;\n+            }\n+\n+\n+else\n+\n+if(newWorklist.contains(basicBlock)) {\n+    newColor = LogicalColor.ON_WORKLIST;\n+}\n+\n+\n+            else {\n+    if(visited.contains(basicBlock)) {\n+        newColor = LogicalColor.VISITED_NOT_ON_WORKLIST;\n+    }\n+\n+\n+else {\n+        newColor = LogicalColor.NOT_VISITED;\n+    }\n+}\n+\n+            newState.setColor(basicBlock, newColor);\n+        }\n+    }\n+\n+\n+    private AnalysisState<E> finishBasicBlock(BasicBlock currentBBlock, E outState, AnalysisState<E> prevAnalysisState, Set<BasicBlock> visited) {\n+        Worklist newWorklist = prevAnalysisState.getWorklist().clone();\n+        BlockState<E> prevBlockState = prevAnalysisState.getBlockState(currentBBlock);\n+        List<BasicBlock> successors = getSuccessors(currentBBlock);\n+        if (!outState.equals(prevBlockState.getOutState())) {\n+            for (BasicBlock bSucc : successors) {\n+                newWorklist.add(bSucc);\n+            }\n+        }\n+\n+        AnalysisState<E> newAnalysisState = newState(prevAnalysisState, newWorklist, null, -1);\n+        BlockState<E> newBlockState = new BlockState<E>(prevBlockState.getInState(), outState);\n+        newAnalysisState.setBlockState(currentBBlock, newBlockState);\n+        updateColors(prevAnalysisState, newAnalysisState, visited);\n+        return newAnalysisState;\n+    }\n+\n+\n+    private ElementaryBlock getElementaryBlock(BasicBlock bBlock, int eBlockIdx) {\n+        List<ElementaryBlock> elementaryBlocks = bBlock.getElementaryBlocks();\n+        switch(direction) {\n+            case FORWARD:\n+            return elementaryBlocks.get(eBlockIdx);\n+\n+            case BACKWARD:\n+            return elementaryBlocks.get(bBlock.getElementaryBlockCount() - 1 - eBlockIdx);\n+\n+            default:\n+            throw new IllegalStateException(\"unknown direction: \" + getDirection());\n+\n+        }\n+    }\n+\n+}\n\\ No newline at end of file\n",
            "diff_size": 459
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/ppati000-visualDFA/errored/1/2/DFAExecution.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/ppati000-visualDFA/styler_random/2/DFAExecution.java\nindex 68cd091c290..9da01b7f90b 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/ppati000-visualDFA/errored/1/2/DFAExecution.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/ppati000-visualDFA/styler_random/2/DFAExecution.java\n@@ -407,8 +407,8 @@ public class DFAExecution<E extends LatticeElement> {\n \r\n                 if (nextElementaryBlock == null) {\r\n                     E basicBlockInState = prevAnalysisState.getBlockState(prevBasicBlock).getInState();\r\n-                    newAnalysisState =\r\n-                            finishBasicBlock(prevBasicBlock, basicBlockInState, prevAnalysisState, visitedBasicBlocks);\r\n+                    newAnalysisState\r\n+                    = finishBasicBlock(prevBasicBlock, basicBlockInState, prevAnalysisState, visitedBasicBlocks);\r\n                 } else {\r\n                     E nextOutState = dfa.transition(prevOutState, nextElementaryBlock.getUnit());\r\n                     BlockState<E> nextBlockState = new BlockState<E>(prevOutState, nextOutState);\r\n",
            "diff_size": 2
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/ppati000-visualDFA/errored/1/2/DFAExecution.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/ppati000-visualDFA/styler_three_grams/2/DFAExecution.java\nindex 68cd091c290..6bf37f573ad 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/ppati000-visualDFA/errored/1/2/DFAExecution.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/ppati000-visualDFA/styler_three_grams/2/DFAExecution.java\n@@ -407,8 +407,8 @@ public class DFAExecution<E extends LatticeElement> {\n \r\n                 if (nextElementaryBlock == null) {\r\n                     E basicBlockInState = prevAnalysisState.getBlockState(prevBasicBlock).getInState();\r\n-                    newAnalysisState =\r\n-                            finishBasicBlock(prevBasicBlock, basicBlockInState, prevAnalysisState, visitedBasicBlocks);\r\n+                    newAnalysisState\r\n+                        = finishBasicBlock(prevBasicBlock, basicBlockInState, prevAnalysisState, visitedBasicBlocks);\r\n                 } else {\r\n                     E nextOutState = dfa.transition(prevOutState, nextElementaryBlock.getUnit());\r\n                     BlockState<E> nextBlockState = new BlockState<E>(prevOutState, nextOutState);\r\n",
            "diff_size": 2
        }
    ],
    "repaired_by": [
        "styler",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "intellij",
        "naturalize",
        "codebuff"
    ]
}