{
    "project_name": "codefollower-H2-Research",
    "error_id": "106",
    "information": {
        "errors": [
            {
                "line": "132",
                "column": "9",
                "severity": "warning",
                "message": "'if' is not followed by whitespace.",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAfterCheck"
            }
        ]
    },
    "source_code": "        super(data);\n        nextAnalyze = database.getSettings().analyzeAuto;\n        if(nextAnalyze <= 0) {\n            nextAnalyze = Integer.MAX_VALUE;\n        }\n        this.store = store;",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/106/MVTable.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler/106/MVTable.java\nindex 6e325d5571f..3768b127631 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/106/MVTable.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler/106/MVTable.java\n@@ -129,7 +129,7 @@ public class MVTable extends TableBase {\n     public MVTable(CreateTableData data, MVTableEngine.Store store) {\n         super(data);\n         nextAnalyze = database.getSettings().analyzeAuto;\n-        if(nextAnalyze <= 0) {\n+        if (nextAnalyze <= 0) {\n             nextAnalyze = Integer.MAX_VALUE;\n         }\n         this.store = store;\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/106/MVTable.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/106/MVTable.java\nindex 6e325d5571f..039113e0609 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/106/MVTable.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/106/MVTable.java\n@@ -3,6 +3,7 @@\n  * and the EPL 1.0 (http://h2database.com/html/license.html).\n  * Initial Developer: H2 Group\n  */\n+\n package org.h2.mvstore.db;\n \n import java.util.ArrayDeque;\n@@ -51,885 +52,886 @@ import org.h2.value.Value;\n  * A table stored in a MVStore.\n  */\n public class MVTable extends TableBase {\n-    /**\n-     * The table name this thread is waiting to lock.\n-     */\n-    public static final DebuggingThreadLocal<String> WAITING_FOR_LOCK;\n-\n-    /**\n-     * The table names this thread has exclusively locked.\n-     */\n-    public static final DebuggingThreadLocal<ArrayList<String>> EXCLUSIVE_LOCKS;\n-\n-    /**\n-     * The tables names this thread has a shared lock on.\n-     */\n-    public static final DebuggingThreadLocal<ArrayList<String>> SHARED_LOCKS;\n-\n-    /**\n-     * The type of trace lock events\n-     */\n-    private enum TraceLockEvent{\n-\n-        TRACE_LOCK_OK(\"ok\"),\n-        TRACE_LOCK_WAITING_FOR(\"waiting for\"),\n-        TRACE_LOCK_REQUESTING_FOR(\"requesting for\"),\n-        TRACE_LOCK_TIMEOUT_AFTER(\"timeout after \"),\n-        TRACE_LOCK_UNLOCK(\"unlock\"),\n-        TRACE_LOCK_ADDED_FOR(\"added for\"),\n-        TRACE_LOCK_ADD_UPGRADED_FOR(\"add (upgraded) for \");\n-\n-        private final String eventText;\n-\n-        TraceLockEvent(String eventText) {\n-            this.eventText = eventText;\n-        }\n-\n-        public String getEventText() {\n-            return eventText;\n-        }\n-    }\n-    private static final String NO_EXTRA_INFO = \"\";\n-\n-    static {\n+  /**\n+   * The table name this thread is waiting to lock.\n+   */\n+  public static final DebuggingThreadLocal<String> WAITING_FOR_LOCK;\n+\n+  /**\n+   * The table names this thread has exclusively locked.\n+   */\n+  public static final DebuggingThreadLocal<ArrayList<String>> EXCLUSIVE_LOCKS;\n+\n+  /**\n+   * The tables names this thread has a shared lock on.\n+   */\n+  public static final DebuggingThreadLocal<ArrayList<String>> SHARED_LOCKS;\n+\n+  /**\n+   * The type of trace lock events\n+   */\n+  private enum TraceLockEvent {\n+\n+    TRACE_LOCK_OK(\"ok\"),\n+    TRACE_LOCK_WAITING_FOR(\"waiting for\"),\n+    TRACE_LOCK_REQUESTING_FOR(\"requesting for\"),\n+    TRACE_LOCK_TIMEOUT_AFTER(\"timeout after \"),\n+    TRACE_LOCK_UNLOCK(\"unlock\"),\n+    TRACE_LOCK_ADDED_FOR(\"added for\"),\n+    TRACE_LOCK_ADD_UPGRADED_FOR(\"add (upgraded) for \");\n+\n+    private final String eventText;\n+\n+    TraceLockEvent(String eventText) {\n+      this.eventText = eventText;\n+    }\n+\n+    public String getEventText() {\n+      return eventText;\n+    }\n+  }\n+\n+  private static final String NO_EXTRA_INFO = \"\";\n+\n+  static {\n+    if (SysProperties.THREAD_DEADLOCK_DETECTOR) {\n+      WAITING_FOR_LOCK = new DebuggingThreadLocal<>();\n+      EXCLUSIVE_LOCKS = new DebuggingThreadLocal<>();\n+      SHARED_LOCKS = new DebuggingThreadLocal<>();\n+    } else {\n+      WAITING_FOR_LOCK = null;\n+      EXCLUSIVE_LOCKS = null;\n+      SHARED_LOCKS = null;\n+    }\n+  }\n+\n+  private MVPrimaryIndex primaryIndex;\n+  private final ArrayList<Index> indexes = Utils.newSmallArrayList();\n+  private volatile long lastModificationId;\n+  private volatile Session lockExclusiveSession;\n+\n+  // using a ConcurrentHashMap as a set\n+  private final ConcurrentHashMap<Session, Session> lockSharedSessions =\n+      new ConcurrentHashMap<>();\n+\n+  /**\n+   * The queue of sessions waiting to lock the table. It is a FIFO queue to\n+   * prevent starvation, since Java's synchronized locking is biased.\n+   */\n+  private final ArrayDeque<Session> waitingSessions = new ArrayDeque<>();\n+  private final Trace traceLock;\n+  private int changesSinceAnalyze;\n+  private int nextAnalyze;\n+  private final boolean containsLargeObject;\n+  private Column rowIdColumn;\n+\n+  private final MVTableEngine.Store store;\n+  private final TransactionStore transactionStore;\n+\n+  public MVTable(CreateTableData data, MVTableEngine.Store store) {\n+    super(data);\n+    nextAnalyze = database.getSettings().analyzeAuto;\n+    if (nextAnalyze <= 0) {\n+      nextAnalyze = Integer.MAX_VALUE;\n+    }\n+    this.store = store;\n+    this.transactionStore = store.getTransactionStore();\n+    this.isHidden = data.isHidden;\n+    boolean b = false;\n+    for (Column col : getColumns()) {\n+      if (DataType.isLargeObject(col.getType())) {\n+        b = true;\n+        break;\n+      }\n+    }\n+    containsLargeObject = b;\n+    traceLock = database.getTrace(Trace.LOCK);\n+  }\n+\n+  /**\n+   * Initialize the table.\n+   *\n+   * @param session the session\n+   */\n+  void init(Session session) {\n+    primaryIndex = new MVPrimaryIndex(session.getDatabase(), this, getId(),\n+        IndexColumn.wrap(getColumns()), IndexType.createScan(true));\n+    indexes.add(primaryIndex);\n+  }\n+\n+  public String getMapName() {\n+    return primaryIndex.getMapName();\n+  }\n+\n+  @Override\n+  public boolean lock(Session session, boolean exclusive,\n+                      boolean forceLockEvenInMvcc) {\n+    int lockMode = database.getLockMode();\n+    if (lockMode == Constants.LOCK_MODE_OFF) {\n+      return false;\n+    }\n+    if (!forceLockEvenInMvcc && database.isMultiVersion()) {\n+      // MVCC: update, delete, and insert use a shared lock.\n+      // Select doesn't lock except when using FOR UPDATE and\n+      // the system property h2.selectForUpdateMvcc\n+      // is not enabled\n+      if (exclusive) {\n+        exclusive = false;\n+      } else {\n+        if (lockExclusiveSession == null) {\n+          return false;\n+        }\n+      }\n+    }\n+    if (lockExclusiveSession == session) {\n+      return true;\n+    }\n+    if (!exclusive && lockSharedSessions.containsKey(session)) {\n+      return true;\n+    }\n+    synchronized (getLockSyncObject()) {\n+      if (!exclusive && lockSharedSessions.containsKey(session)) {\n+        return true;\n+      }\n+      session.setWaitForLock(this, Thread.currentThread());\n+      if (SysProperties.THREAD_DEADLOCK_DETECTOR) {\n+        WAITING_FOR_LOCK.set(getName());\n+      }\n+      waitingSessions.addLast(session);\n+      try {\n+        doLock1(session, lockMode, exclusive);\n+      } finally {\n+        session.setWaitForLock(null, null);\n         if (SysProperties.THREAD_DEADLOCK_DETECTOR) {\n-            WAITING_FOR_LOCK = new DebuggingThreadLocal<>();\n-            EXCLUSIVE_LOCKS = new DebuggingThreadLocal<>();\n-            SHARED_LOCKS = new DebuggingThreadLocal<>();\n-        } else {\n-            WAITING_FOR_LOCK = null;\n-            EXCLUSIVE_LOCKS = null;\n-            SHARED_LOCKS = null;\n-        }\n-    }\n-\n-    private MVPrimaryIndex primaryIndex;\n-    private final ArrayList<Index> indexes = Utils.newSmallArrayList();\n-    private volatile long lastModificationId;\n-    private volatile Session lockExclusiveSession;\n-\n-    // using a ConcurrentHashMap as a set\n-    private final ConcurrentHashMap<Session, Session> lockSharedSessions =\n-            new ConcurrentHashMap<>();\n-\n-    /**\n-     * The queue of sessions waiting to lock the table. It is a FIFO queue to\n-     * prevent starvation, since Java's synchronized locking is biased.\n-     */\n-    private final ArrayDeque<Session> waitingSessions = new ArrayDeque<>();\n-    private final Trace traceLock;\n-    private int changesSinceAnalyze;\n-    private int nextAnalyze;\n-    private final boolean containsLargeObject;\n-    private Column rowIdColumn;\n-\n-    private final MVTableEngine.Store store;\n-    private final TransactionStore transactionStore;\n-\n-    public MVTable(CreateTableData data, MVTableEngine.Store store) {\n-        super(data);\n-        nextAnalyze = database.getSettings().analyzeAuto;\n-        if(nextAnalyze <= 0) {\n-            nextAnalyze = Integer.MAX_VALUE;\n-        }\n-        this.store = store;\n-        this.transactionStore = store.getTransactionStore();\n-        this.isHidden = data.isHidden;\n-        boolean b = false;\n-        for (Column col : getColumns()) {\n-            if (DataType.isLargeObject(col.getType())) {\n-                b = true;\n-                break;\n-            }\n-        }\n-        containsLargeObject = b;\n-        traceLock = database.getTrace(Trace.LOCK);\n-    }\n-\n-    /**\n-     * Initialize the table.\n-     *\n-     * @param session the session\n-     */\n-    void init(Session session) {\n-        primaryIndex = new MVPrimaryIndex(session.getDatabase(), this, getId(),\n-                IndexColumn.wrap(getColumns()), IndexType.createScan(true));\n-        indexes.add(primaryIndex);\n-    }\n-\n-    public String getMapName() {\n-        return primaryIndex.getMapName();\n-    }\n-\n-    @Override\n-    public boolean lock(Session session, boolean exclusive,\n-            boolean forceLockEvenInMvcc) {\n-        int lockMode = database.getLockMode();\n-        if (lockMode == Constants.LOCK_MODE_OFF) {\n-            return false;\n-        }\n-        if (!forceLockEvenInMvcc && database.isMultiVersion()) {\n-            // MVCC: update, delete, and insert use a shared lock.\n-            // Select doesn't lock except when using FOR UPDATE and\n-            // the system property h2.selectForUpdateMvcc\n-            // is not enabled\n-            if (exclusive) {\n-                exclusive = false;\n-            } else {\n-                if (lockExclusiveSession == null) {\n-                    return false;\n-                }\n-            }\n-        }\n-        if (lockExclusiveSession == session) {\n-            return true;\n-        }\n-        if (!exclusive && lockSharedSessions.containsKey(session)) {\n+          WAITING_FOR_LOCK.remove();\n+        }\n+        waitingSessions.remove(session);\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * The the object on which to synchronize and wait on. For the\n+   * multi-threaded mode, this is this object, but for non-multi-threaded, it\n+   * is the database, as in this case all operations are synchronized on the\n+   * database object.\n+   *\n+   * @return the lock sync object\n+   */\n+  private Object getLockSyncObject() {\n+    if (database.isMultiThreaded()) {\n+      return this;\n+    }\n+    return database;\n+  }\n+\n+  private void doLock1(Session session, int lockMode, boolean exclusive) {\n+    traceLock(session, exclusive, TraceLockEvent.TRACE_LOCK_REQUESTING_FOR, NO_EXTRA_INFO);\n+    // don't get the current time unless necessary\n+    long max = 0;\n+    boolean checkDeadlock = false;\n+    while (true) {\n+      // if I'm the next one in the queue\n+      if (waitingSessions.getFirst() == session) {\n+        if (doLock2(session, lockMode, exclusive)) {\n+          return;\n+        }\n+      }\n+      if (checkDeadlock) {\n+        ArrayList<Session> sessions = checkDeadlock(session, null, null);\n+        if (sessions != null) {\n+          throw DbException.get(ErrorCode.DEADLOCK_1,\n+              getDeadlockDetails(sessions, exclusive));\n+        }\n+      } else {\n+        // check for deadlocks from now on\n+        checkDeadlock = true;\n+      }\n+      long now = System.nanoTime();\n+      if (max == 0) {\n+        // try at least one more time\n+        max = now + TimeUnit.MILLISECONDS.toNanos(session.getLockTimeout());\n+      } else if (now >= max) {\n+        traceLock(session, exclusive,\n+            TraceLockEvent.TRACE_LOCK_TIMEOUT_AFTER, NO_EXTRA_INFO + session.getLockTimeout());\n+        throw DbException.get(ErrorCode.LOCK_TIMEOUT_1, getName());\n+      }\n+      try {\n+        traceLock(session, exclusive, TraceLockEvent.TRACE_LOCK_WAITING_FOR, NO_EXTRA_INFO);\n+        if (database.getLockMode() == Constants.LOCK_MODE_TABLE_GC) {\n+          for (int i = 0; i < 20; i++) {\n+            long free = Runtime.getRuntime().freeMemory();\n+            System.gc();\n+            long free2 = Runtime.getRuntime().freeMemory();\n+            if (free == free2) {\n+              break;\n+            }\n+          }\n+        }\n+        // don't wait too long so that deadlocks are detected early\n+        long sleep = Math.min(Constants.DEADLOCK_CHECK,\n+            TimeUnit.NANOSECONDS.toMillis(max - now));\n+        if (sleep == 0) {\n+          sleep = 1;\n+        }\n+        getLockSyncObject().wait(sleep);\n+      } catch (InterruptedException e) {\n+        // ignore\n+      }\n+    }\n+  }\n+\n+  private boolean doLock2(Session session, int lockMode, boolean exclusive) {\n+    if (exclusive) {\n+      if (lockExclusiveSession == null) {\n+        if (lockSharedSessions.isEmpty()) {\n+          traceLock(session, exclusive, TraceLockEvent.TRACE_LOCK_ADDED_FOR, NO_EXTRA_INFO);\n+          session.addLock(this);\n+          lockExclusiveSession = session;\n+          if (SysProperties.THREAD_DEADLOCK_DETECTOR) {\n+            if (EXCLUSIVE_LOCKS.get() == null) {\n+              EXCLUSIVE_LOCKS.set(new ArrayList<String>());\n+            }\n+            EXCLUSIVE_LOCKS.get().add(getName());\n+          }\n+          return true;\n+        } else if (lockSharedSessions.size() == 1 &&\n+            lockSharedSessions.containsKey(session)) {\n+          traceLock(session, exclusive, TraceLockEvent.TRACE_LOCK_ADD_UPGRADED_FOR, NO_EXTRA_INFO);\n+          lockExclusiveSession = session;\n+          if (SysProperties.THREAD_DEADLOCK_DETECTOR) {\n+            if (EXCLUSIVE_LOCKS.get() == null) {\n+              EXCLUSIVE_LOCKS.set(new ArrayList<String>());\n+            }\n+            EXCLUSIVE_LOCKS.get().add(getName());\n+          }\n+          return true;\n+        }\n+      }\n+    } else {\n+      if (lockExclusiveSession == null) {\n+        if (lockMode == Constants.LOCK_MODE_READ_COMMITTED) {\n+          if (!database.isMultiThreaded() &&\n+              !database.isMultiVersion()) {\n+            // READ_COMMITTED: a read lock is acquired,\n+            // but released immediately after the operation\n+            // is complete.\n+            // When allowing only one thread, no lock is\n+            // required.\n+            // Row level locks work like read committed.\n             return true;\n+          }\n         }\n-        synchronized (getLockSyncObject()) {\n-            if (!exclusive && lockSharedSessions.containsKey(session)) {\n-                return true;\n-            }\n-            session.setWaitForLock(this, Thread.currentThread());\n-            if (SysProperties.THREAD_DEADLOCK_DETECTOR) {\n-                WAITING_FOR_LOCK.set(getName());\n-            }\n-            waitingSessions.addLast(session);\n-            try {\n-                doLock1(session, lockMode, exclusive);\n-            } finally {\n-                session.setWaitForLock(null, null);\n-                if (SysProperties.THREAD_DEADLOCK_DETECTOR) {\n-                    WAITING_FOR_LOCK.remove();\n-                }\n-                waitingSessions.remove(session);\n-            }\n-        }\n-        return false;\n-    }\n-\n-    /**\n-     * The the object on which to synchronize and wait on. For the\n-     * multi-threaded mode, this is this object, but for non-multi-threaded, it\n-     * is the database, as in this case all operations are synchronized on the\n-     * database object.\n-     *\n-     * @return the lock sync object\n-     */\n-    private Object getLockSyncObject() {\n-        if (database.isMultiThreaded()) {\n-            return this;\n-        }\n-        return database;\n-    }\n-\n-    private void doLock1(Session session, int lockMode, boolean exclusive) {\n-        traceLock(session, exclusive, TraceLockEvent.TRACE_LOCK_REQUESTING_FOR, NO_EXTRA_INFO);\n-        // don't get the current time unless necessary\n-        long max = 0;\n-        boolean checkDeadlock = false;\n-        while (true) {\n-            // if I'm the next one in the queue\n-            if (waitingSessions.getFirst() == session) {\n-                if (doLock2(session, lockMode, exclusive)) {\n-                    return;\n-                }\n-            }\n-            if (checkDeadlock) {\n-                ArrayList<Session> sessions = checkDeadlock(session, null, null);\n-                if (sessions != null) {\n-                    throw DbException.get(ErrorCode.DEADLOCK_1,\n-                            getDeadlockDetails(sessions, exclusive));\n-                }\n-            } else {\n-                // check for deadlocks from now on\n-                checkDeadlock = true;\n-            }\n-            long now = System.nanoTime();\n-            if (max == 0) {\n-                // try at least one more time\n-                max = now + TimeUnit.MILLISECONDS.toNanos(session.getLockTimeout());\n-            } else if (now >= max) {\n-                traceLock(session, exclusive,\n-                        TraceLockEvent.TRACE_LOCK_TIMEOUT_AFTER, NO_EXTRA_INFO+session.getLockTimeout());\n-                throw DbException.get(ErrorCode.LOCK_TIMEOUT_1, getName());\n-            }\n-            try {\n-                traceLock(session, exclusive, TraceLockEvent.TRACE_LOCK_WAITING_FOR, NO_EXTRA_INFO);\n-                if (database.getLockMode() == Constants.LOCK_MODE_TABLE_GC) {\n-                    for (int i = 0; i < 20; i++) {\n-                        long free = Runtime.getRuntime().freeMemory();\n-                        System.gc();\n-                        long free2 = Runtime.getRuntime().freeMemory();\n-                        if (free == free2) {\n-                            break;\n-                        }\n-                    }\n-                }\n-                // don't wait too long so that deadlocks are detected early\n-                long sleep = Math.min(Constants.DEADLOCK_CHECK,\n-                        TimeUnit.NANOSECONDS.toMillis(max - now));\n-                if (sleep == 0) {\n-                    sleep = 1;\n-                }\n-                getLockSyncObject().wait(sleep);\n-            } catch (InterruptedException e) {\n-                // ignore\n-            }\n-        }\n-    }\n-\n-    private boolean doLock2(Session session, int lockMode, boolean exclusive) {\n-        if (exclusive) {\n-            if (lockExclusiveSession == null) {\n-                if (lockSharedSessions.isEmpty()) {\n-                    traceLock(session, exclusive, TraceLockEvent.TRACE_LOCK_ADDED_FOR, NO_EXTRA_INFO);\n-                    session.addLock(this);\n-                    lockExclusiveSession = session;\n-                    if (SysProperties.THREAD_DEADLOCK_DETECTOR) {\n-                        if (EXCLUSIVE_LOCKS.get() == null) {\n-                            EXCLUSIVE_LOCKS.set(new ArrayList<String>());\n-                        }\n-                        EXCLUSIVE_LOCKS.get().add(getName());\n-                    }\n-                    return true;\n-                } else if (lockSharedSessions.size() == 1 &&\n-                        lockSharedSessions.containsKey(session)) {\n-                    traceLock(session, exclusive, TraceLockEvent.TRACE_LOCK_ADD_UPGRADED_FOR, NO_EXTRA_INFO);\n-                    lockExclusiveSession = session;\n-                    if (SysProperties.THREAD_DEADLOCK_DETECTOR) {\n-                        if (EXCLUSIVE_LOCKS.get() == null) {\n-                            EXCLUSIVE_LOCKS.set(new ArrayList<String>());\n-                        }\n-                        EXCLUSIVE_LOCKS.get().add(getName());\n-                    }\n-                    return true;\n-                }\n-            }\n-        } else {\n-            if (lockExclusiveSession == null) {\n-                if (lockMode == Constants.LOCK_MODE_READ_COMMITTED) {\n-                    if (!database.isMultiThreaded() &&\n-                            !database.isMultiVersion()) {\n-                        // READ_COMMITTED: a read lock is acquired,\n-                        // but released immediately after the operation\n-                        // is complete.\n-                        // When allowing only one thread, no lock is\n-                        // required.\n-                        // Row level locks work like read committed.\n-                        return true;\n-                    }\n-                }\n-                if (lockSharedSessions.putIfAbsent(session, session) == null) {\n-                    traceLock(session, exclusive, TraceLockEvent.TRACE_LOCK_OK, NO_EXTRA_INFO);\n-                    session.addLock(this);\n-                    if (SysProperties.THREAD_DEADLOCK_DETECTOR) {\n-                        ArrayList<String> list = SHARED_LOCKS.get();\n-                        if (list == null) {\n-                            list = new ArrayList<>();\n-                            SHARED_LOCKS.set(list);\n-                        }\n-                        list.add(getName());\n-                    }\n-                }\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    private static String getDeadlockDetails(ArrayList<Session> sessions, boolean exclusive) {\n-        // We add the thread details here to make it easier for customers to\n-        // match up these error messages with their own logs.\n-        StringBuilder buff = new StringBuilder();\n-        for (Session s : sessions) {\n-            Table lock = s.getWaitForLock();\n-            Thread thread = s.getWaitForLockThread();\n-            buff.append(\"\\nSession \").append(s.toString())\n-                    .append(\" on thread \").append(thread.getName())\n-                    .append(\" is waiting to lock \").append(lock.toString())\n-                    .append(exclusive ? \" (exclusive)\" : \" (shared)\")\n-                    .append(\" while locking \");\n-            int i = 0;\n-            for (Table t : s.getLocks()) {\n-                if (i++ > 0) {\n-                    buff.append(\", \");\n-                }\n-                buff.append(t.toString());\n-                if (t instanceof MVTable) {\n-                    if (t.isLockedExclusivelyBy(s)) {\n-                        buff.append(\" (exclusive)\");\n-                    } else {\n-                        buff.append(\" (shared)\");\n-                    }\n-                }\n-            }\n-            buff.append('.');\n-        }\n-        return buff.toString();\n-    }\n-\n-    @Override\n-    public ArrayList<Session> checkDeadlock(Session session, Session clash,\n-            Set<Session> visited) {\n-        // only one deadlock check at any given time\n-        synchronized (MVTable.class) {\n-            if (clash == null) {\n-                // verification is started\n-                clash = session;\n-                visited = new HashSet<>();\n-            } else if (clash == session) {\n-                // we found a circle where this session is involved\n-                return new ArrayList<>(0);\n-            } else if (visited.contains(session)) {\n-                // we have already checked this session.\n-                // there is a circle, but the sessions in the circle need to\n-                // find it out themselves\n-                return null;\n-            }\n-            visited.add(session);\n-            ArrayList<Session> error = null;\n-            for (Session s : lockSharedSessions.keySet()) {\n-                if (s == session) {\n-                    // it doesn't matter if we have locked the object already\n-                    continue;\n-                }\n-                Table t = s.getWaitForLock();\n-                if (t != null) {\n-                    error = t.checkDeadlock(s, clash, visited);\n-                    if (error != null) {\n-                        error.add(session);\n-                        break;\n-                    }\n-                }\n-            }\n-            // take a local copy so we don't see inconsistent data, since we are\n-            // not locked while checking the lockExclusiveSession value\n-            Session copyOfLockExclusiveSession = lockExclusiveSession;\n-            if (error == null && copyOfLockExclusiveSession != null) {\n-                Table t = copyOfLockExclusiveSession.getWaitForLock();\n-                if (t != null) {\n-                    error = t.checkDeadlock(copyOfLockExclusiveSession, clash,\n-                            visited);\n-                    if (error != null) {\n-                        error.add(session);\n-                    }\n-                }\n-            }\n-            return error;\n-        }\n-    }\n-\n-    private void traceLock(Session session, boolean exclusive, TraceLockEvent eventEnum, String extraInfo) {\n-        if (traceLock.isDebugEnabled()) {\n-            traceLock.debug(\"{0} {1} {2} {3} {4}\", session.getId(),\n-                    exclusive ? \"exclusive write lock\" : \"shared read lock\", eventEnum.getEventText(),\n-                    getName(), extraInfo);\n-        }\n-    }\n-\n-    @Override\n-    public boolean isLockedExclusively() {\n-        return lockExclusiveSession != null;\n-    }\n-\n-    @Override\n-    public boolean isLockedExclusivelyBy(Session session) {\n-        return lockExclusiveSession == session;\n-    }\n-\n-    @Override\n-    public void unlock(Session s) {\n-        if (database != null) {\n-            traceLock(s, lockExclusiveSession == s, TraceLockEvent.TRACE_LOCK_UNLOCK, NO_EXTRA_INFO);\n-            if (lockExclusiveSession == s) {\n-                lockSharedSessions.remove(s);\n-                lockExclusiveSession = null;\n-                if (SysProperties.THREAD_DEADLOCK_DETECTOR) {\n-                    if (EXCLUSIVE_LOCKS.get() != null) {\n-                        EXCLUSIVE_LOCKS.get().remove(getName());\n-                    }\n-                }\n-            }\n-            synchronized (getLockSyncObject()) {\n-                if (!lockSharedSessions.isEmpty()) {\n-                    lockSharedSessions.remove(s);\n-                    if (SysProperties.THREAD_DEADLOCK_DETECTOR) {\n-                        if (SHARED_LOCKS.get() != null) {\n-                            SHARED_LOCKS.get().remove(getName());\n-                        }\n-                    }\n-                }\n-                if (!waitingSessions.isEmpty()) {\n-                    getLockSyncObject().notifyAll();\n-                }\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public boolean canTruncate() {\n-        if (getCheckForeignKeyConstraints() &&\n-                database.getReferentialIntegrity()) {\n-            ArrayList<Constraint> constraints = getConstraints();\n-            if (constraints != null) {\n-                for (Constraint c : constraints) {\n-                    if (c.getConstraintType() != Constraint.Type.REFERENTIAL) {\n-                        continue;\n-                    }\n-                    ConstraintReferential ref = (ConstraintReferential) c;\n-                    if (ref.getRefTable() == this) {\n-                        return false;\n-                    }\n-                }\n+        if (lockSharedSessions.putIfAbsent(session, session) == null) {\n+          traceLock(session, exclusive, TraceLockEvent.TRACE_LOCK_OK, NO_EXTRA_INFO);\n+          session.addLock(this);\n+          if (SysProperties.THREAD_DEADLOCK_DETECTOR) {\n+            ArrayList<String> list = SHARED_LOCKS.get();\n+            if (list == null) {\n+              list = new ArrayList<>();\n+              SHARED_LOCKS.set(list);\n             }\n+            list.add(getName());\n+          }\n         }\n         return true;\n-    }\n-\n-    @Override\n-    public void close(Session session) {\n-        // ignore\n-    }\n-\n-    @Override\n-    public Row getRow(Session session, long key) {\n-        return primaryIndex.getRow(session, key);\n-    }\n-\n-    @Override\n-    public Index addIndex(Session session, String indexName, int indexId,\n-            IndexColumn[] cols, IndexType indexType, boolean create,\n-            String indexComment) {\n-        if (indexType.isPrimaryKey()) {\n-            for (IndexColumn c : cols) {\n-                Column column = c.column;\n-                if (column.isNullable()) {\n-                    throw DbException.get(\n-                            ErrorCode.COLUMN_MUST_NOT_BE_NULLABLE_1,\n-                            column.getName());\n-                }\n-                column.setPrimaryKey(true);\n-            }\n-        }\n-        boolean isSessionTemporary = isTemporary() && !isGlobalTemporary();\n-        if (!isSessionTemporary) {\n-            database.lockMeta(session);\n-        }\n-        MVIndex index;\n-        int mainIndexColumn;\n-        mainIndexColumn = getMainIndexColumn(indexType, cols);\n-        if (database.isStarting()) {\n-            if (transactionStore.hasMap(\"index.\" + indexId)) {\n-                mainIndexColumn = SearchRow.ROWID_INDEX;\n-            }\n-        } else if (primaryIndex.getRowCountMax() != 0) {\n-            mainIndexColumn = SearchRow.ROWID_INDEX;\n-        }\n-        if (mainIndexColumn != SearchRow.ROWID_INDEX) {\n-            primaryIndex.setMainIndexColumn(mainIndexColumn);\n-            index = new MVDelegateIndex(this, indexId, indexName, primaryIndex,\n-                    indexType);\n-        } else if (indexType.isSpatial()) {\n-            index = new MVSpatialIndex(session.getDatabase(), this, indexId,\n-                    indexName, cols, indexType);\n-        } else {\n-            index = new MVSecondaryIndex(session.getDatabase(), this, indexId,\n-                    indexName, cols, indexType);\n-        }\n-        if (index.needRebuild()) {\n-            rebuildIndex(session, index, indexName);\n-        }\n-        index.setTemporary(isTemporary());\n-        if (index.getCreateSQL() != null) {\n-            index.setComment(indexComment);\n-            if (isSessionTemporary) {\n-                session.addLocalTempTableIndex(index);\n-            } else {\n-                database.addSchemaObject(session, index);\n-            }\n-        }\n-        indexes.add(index);\n-        setModified();\n-        return index;\n-    }\n-\n-    private void rebuildIndex(Session session, MVIndex index, String indexName) {\n-        try {\n-            if (session.getDatabase().getMvStore() == null ||\n-                    index instanceof MVSpatialIndex) {\n-                // in-memory\n-                rebuildIndexBuffered(session, index);\n-            } else {\n-                rebuildIndexBlockMerge(session, index);\n-            }\n-        } catch (DbException e) {\n-            getSchema().freeUniqueName(indexName);\n-            try {\n-                index.remove(session);\n-            } catch (DbException e2) {\n-                // this could happen, for example on failure in the storage\n-                // but if that is not the case it means\n-                // there is something wrong with the database\n-                trace.error(e2, \"could not remove index\");\n-                throw e2;\n-            }\n-            throw e;\n-        }\n-    }\n-\n-    private void rebuildIndexBlockMerge(Session session, MVIndex index) {\n-        if (index instanceof MVSpatialIndex) {\n-            // the spatial index doesn't support multi-way merge sort\n-            rebuildIndexBuffered(session, index);\n-        }\n-        // Read entries in memory, sort them, write to a new map (in sorted\n-        // order); repeat (using a new map for every block of 1 MB) until all\n-        // record are read. Merge all maps to the target (using merge sort;\n-        // duplicates are detected in the target). For randomly ordered data,\n-        // this should use relatively few write operations.\n-        // A possible optimization is: change the buffer size from \"row count\"\n-        // to \"amount of memory\", and buffer index keys instead of rows.\n-        Index scan = getScanIndex(session);\n-        long remaining = scan.getRowCount(session);\n-        long total = remaining;\n-        Cursor cursor = scan.find(session, null, null);\n-        long i = 0;\n-        Store store = session.getDatabase().getMvStore();\n-\n-        int bufferSize = database.getMaxMemoryRows() / 2;\n-        ArrayList<Row> buffer = new ArrayList<>(bufferSize);\n-        String n = getName() + \":\" + index.getName();\n-        int t = MathUtils.convertLongToInt(total);\n-        ArrayList<String> bufferNames = Utils.newSmallArrayList();\n-        while (cursor.next()) {\n-            Row row = cursor.get();\n-            buffer.add(row);\n-            database.setProgress(DatabaseEventListener.STATE_CREATE_INDEX, n,\n-                    MathUtils.convertLongToInt(i++), t);\n-            if (buffer.size() >= bufferSize) {\n-                sortRows(buffer, index);\n-                String mapName = store.nextTemporaryMapName();\n-                index.addRowsToBuffer(buffer, mapName);\n-                bufferNames.add(mapName);\n-                buffer.clear();\n-            }\n-            remaining--;\n-        }\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private static String getDeadlockDetails(ArrayList<Session> sessions, boolean exclusive) {\n+    // We add the thread details here to make it easier for customers to\n+    // match up these error messages with their own logs.\n+    StringBuilder buff = new StringBuilder();\n+    for (Session s : sessions) {\n+      Table lock = s.getWaitForLock();\n+      Thread thread = s.getWaitForLockThread();\n+      buff.append(\"\\nSession \").append(s.toString())\n+          .append(\" on thread \").append(thread.getName())\n+          .append(\" is waiting to lock \").append(lock.toString())\n+          .append(exclusive ? \" (exclusive)\" : \" (shared)\")\n+          .append(\" while locking \");\n+      int i = 0;\n+      for (Table t : s.getLocks()) {\n+        if (i++ > 0) {\n+          buff.append(\", \");\n+        }\n+        buff.append(t.toString());\n+        if (t instanceof MVTable) {\n+          if (t.isLockedExclusivelyBy(s)) {\n+            buff.append(\" (exclusive)\");\n+          } else {\n+            buff.append(\" (shared)\");\n+          }\n+        }\n+      }\n+      buff.append('.');\n+    }\n+    return buff.toString();\n+  }\n+\n+  @Override\n+  public ArrayList<Session> checkDeadlock(Session session, Session clash,\n+                                          Set<Session> visited) {\n+    // only one deadlock check at any given time\n+    synchronized (MVTable.class) {\n+      if (clash == null) {\n+        // verification is started\n+        clash = session;\n+        visited = new HashSet<>();\n+      } else if (clash == session) {\n+        // we found a circle where this session is involved\n+        return new ArrayList<>(0);\n+      } else if (visited.contains(session)) {\n+        // we have already checked this session.\n+        // there is a circle, but the sessions in the circle need to\n+        // find it out themselves\n+        return null;\n+      }\n+      visited.add(session);\n+      ArrayList<Session> error = null;\n+      for (Session s : lockSharedSessions.keySet()) {\n+        if (s == session) {\n+          // it doesn't matter if we have locked the object already\n+          continue;\n+        }\n+        Table t = s.getWaitForLock();\n+        if (t != null) {\n+          error = t.checkDeadlock(s, clash, visited);\n+          if (error != null) {\n+            error.add(session);\n+            break;\n+          }\n+        }\n+      }\n+      // take a local copy so we don't see inconsistent data, since we are\n+      // not locked while checking the lockExclusiveSession value\n+      Session copyOfLockExclusiveSession = lockExclusiveSession;\n+      if (error == null && copyOfLockExclusiveSession != null) {\n+        Table t = copyOfLockExclusiveSession.getWaitForLock();\n+        if (t != null) {\n+          error = t.checkDeadlock(copyOfLockExclusiveSession, clash,\n+              visited);\n+          if (error != null) {\n+            error.add(session);\n+          }\n+        }\n+      }\n+      return error;\n+    }\n+  }\n+\n+  private void traceLock(Session session, boolean exclusive, TraceLockEvent eventEnum, String extraInfo) {\n+    if (traceLock.isDebugEnabled()) {\n+      traceLock.debug(\"{0} {1} {2} {3} {4}\", session.getId(),\n+          exclusive ? \"exclusive write lock\" : \"shared read lock\", eventEnum.getEventText(),\n+          getName(), extraInfo);\n+    }\n+  }\n+\n+  @Override\n+  public boolean isLockedExclusively() {\n+    return lockExclusiveSession != null;\n+  }\n+\n+  @Override\n+  public boolean isLockedExclusivelyBy(Session session) {\n+    return lockExclusiveSession == session;\n+  }\n+\n+  @Override\n+  public void unlock(Session s) {\n+    if (database != null) {\n+      traceLock(s, lockExclusiveSession == s, TraceLockEvent.TRACE_LOCK_UNLOCK, NO_EXTRA_INFO);\n+      if (lockExclusiveSession == s) {\n+        lockSharedSessions.remove(s);\n+        lockExclusiveSession = null;\n+        if (SysProperties.THREAD_DEADLOCK_DETECTOR) {\n+          if (EXCLUSIVE_LOCKS.get() != null) {\n+            EXCLUSIVE_LOCKS.get().remove(getName());\n+          }\n+        }\n+      }\n+      synchronized (getLockSyncObject()) {\n+        if (!lockSharedSessions.isEmpty()) {\n+          lockSharedSessions.remove(s);\n+          if (SysProperties.THREAD_DEADLOCK_DETECTOR) {\n+            if (SHARED_LOCKS.get() != null) {\n+              SHARED_LOCKS.get().remove(getName());\n+            }\n+          }\n+        }\n+        if (!waitingSessions.isEmpty()) {\n+          getLockSyncObject().notifyAll();\n+        }\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public boolean canTruncate() {\n+    if (getCheckForeignKeyConstraints() &&\n+        database.getReferentialIntegrity()) {\n+      ArrayList<Constraint> constraints = getConstraints();\n+      if (constraints != null) {\n+        for (Constraint c : constraints) {\n+          if (c.getConstraintType() != Constraint.Type.REFERENTIAL) {\n+            continue;\n+          }\n+          ConstraintReferential ref = (ConstraintReferential) c;\n+          if (ref.getRefTable() == this) {\n+            return false;\n+          }\n+        }\n+      }\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public void close(Session session) {\n+    // ignore\n+  }\n+\n+  @Override\n+  public Row getRow(Session session, long key) {\n+    return primaryIndex.getRow(session, key);\n+  }\n+\n+  @Override\n+  public Index addIndex(Session session, String indexName, int indexId,\n+                        IndexColumn[] cols, IndexType indexType, boolean create,\n+                        String indexComment) {\n+    if (indexType.isPrimaryKey()) {\n+      for (IndexColumn c : cols) {\n+        Column column = c.column;\n+        if (column.isNullable()) {\n+          throw DbException.get(\n+              ErrorCode.COLUMN_MUST_NOT_BE_NULLABLE_1,\n+              column.getName());\n+        }\n+        column.setPrimaryKey(true);\n+      }\n+    }\n+    boolean isSessionTemporary = isTemporary() && !isGlobalTemporary();\n+    if (!isSessionTemporary) {\n+      database.lockMeta(session);\n+    }\n+    MVIndex index;\n+    int mainIndexColumn;\n+    mainIndexColumn = getMainIndexColumn(indexType, cols);\n+    if (database.isStarting()) {\n+      if (transactionStore.hasMap(\"index.\" + indexId)) {\n+        mainIndexColumn = SearchRow.ROWID_INDEX;\n+      }\n+    } else if (primaryIndex.getRowCountMax() != 0) {\n+      mainIndexColumn = SearchRow.ROWID_INDEX;\n+    }\n+    if (mainIndexColumn != SearchRow.ROWID_INDEX) {\n+      primaryIndex.setMainIndexColumn(mainIndexColumn);\n+      index = new MVDelegateIndex(this, indexId, indexName, primaryIndex,\n+          indexType);\n+    } else if (indexType.isSpatial()) {\n+      index = new MVSpatialIndex(session.getDatabase(), this, indexId,\n+          indexName, cols, indexType);\n+    } else {\n+      index = new MVSecondaryIndex(session.getDatabase(), this, indexId,\n+          indexName, cols, indexType);\n+    }\n+    if (index.needRebuild()) {\n+      rebuildIndex(session, index, indexName);\n+    }\n+    index.setTemporary(isTemporary());\n+    if (index.getCreateSQL() != null) {\n+      index.setComment(indexComment);\n+      if (isSessionTemporary) {\n+        session.addLocalTempTableIndex(index);\n+      } else {\n+        database.addSchemaObject(session, index);\n+      }\n+    }\n+    indexes.add(index);\n+    setModified();\n+    return index;\n+  }\n+\n+  private void rebuildIndex(Session session, MVIndex index, String indexName) {\n+    try {\n+      if (session.getDatabase().getMvStore() == null ||\n+          index instanceof MVSpatialIndex) {\n+        // in-memory\n+        rebuildIndexBuffered(session, index);\n+      } else {\n+        rebuildIndexBlockMerge(session, index);\n+      }\n+    } catch (DbException e) {\n+      getSchema().freeUniqueName(indexName);\n+      try {\n+        index.remove(session);\n+      } catch (DbException e2) {\n+        // this could happen, for example on failure in the storage\n+        // but if that is not the case it means\n+        // there is something wrong with the database\n+        trace.error(e2, \"could not remove index\");\n+        throw e2;\n+      }\n+      throw e;\n+    }\n+  }\n+\n+  private void rebuildIndexBlockMerge(Session session, MVIndex index) {\n+    if (index instanceof MVSpatialIndex) {\n+      // the spatial index doesn't support multi-way merge sort\n+      rebuildIndexBuffered(session, index);\n+    }\n+    // Read entries in memory, sort them, write to a new map (in sorted\n+    // order); repeat (using a new map for every block of 1 MB) until all\n+    // record are read. Merge all maps to the target (using merge sort;\n+    // duplicates are detected in the target). For randomly ordered data,\n+    // this should use relatively few write operations.\n+    // A possible optimization is: change the buffer size from \"row count\"\n+    // to \"amount of memory\", and buffer index keys instead of rows.\n+    Index scan = getScanIndex(session);\n+    long remaining = scan.getRowCount(session);\n+    long total = remaining;\n+    Cursor cursor = scan.find(session, null, null);\n+    long i = 0;\n+    Store store = session.getDatabase().getMvStore();\n+\n+    int bufferSize = database.getMaxMemoryRows() / 2;\n+    ArrayList<Row> buffer = new ArrayList<>(bufferSize);\n+    String n = getName() + \":\" + index.getName();\n+    int t = MathUtils.convertLongToInt(total);\n+    ArrayList<String> bufferNames = Utils.newSmallArrayList();\n+    while (cursor.next()) {\n+      Row row = cursor.get();\n+      buffer.add(row);\n+      database.setProgress(DatabaseEventListener.STATE_CREATE_INDEX, n,\n+          MathUtils.convertLongToInt(i++), t);\n+      if (buffer.size() >= bufferSize) {\n         sortRows(buffer, index);\n-        if (!bufferNames.isEmpty()) {\n-            String mapName = store.nextTemporaryMapName();\n-            index.addRowsToBuffer(buffer, mapName);\n-            bufferNames.add(mapName);\n-            buffer.clear();\n-            index.addBufferedRows(bufferNames);\n-        } else {\n-            addRowsToIndex(session, buffer, index);\n-        }\n-        if (SysProperties.CHECK && remaining != 0) {\n-            DbException.throwInternalError(\"rowcount remaining=\" + remaining +\n-                    \" \" + getName());\n-        }\n-    }\n-\n-    private void rebuildIndexBuffered(Session session, Index index) {\n-        Index scan = getScanIndex(session);\n-        long remaining = scan.getRowCount(session);\n-        long total = remaining;\n-        Cursor cursor = scan.find(session, null, null);\n-        long i = 0;\n-        int bufferSize = (int) Math.min(total, database.getMaxMemoryRows());\n-        ArrayList<Row> buffer = new ArrayList<>(bufferSize);\n-        String n = getName() + \":\" + index.getName();\n-        int t = MathUtils.convertLongToInt(total);\n-        while (cursor.next()) {\n-            Row row = cursor.get();\n-            buffer.add(row);\n-            database.setProgress(DatabaseEventListener.STATE_CREATE_INDEX, n,\n-                    MathUtils.convertLongToInt(i++), t);\n-            if (buffer.size() >= bufferSize) {\n-                addRowsToIndex(session, buffer, index);\n-            }\n-            remaining--;\n-        }\n+        String mapName = store.nextTemporaryMapName();\n+        index.addRowsToBuffer(buffer, mapName);\n+        bufferNames.add(mapName);\n+        buffer.clear();\n+      }\n+      remaining--;\n+    }\n+    sortRows(buffer, index);\n+    if (!bufferNames.isEmpty()) {\n+      String mapName = store.nextTemporaryMapName();\n+      index.addRowsToBuffer(buffer, mapName);\n+      bufferNames.add(mapName);\n+      buffer.clear();\n+      index.addBufferedRows(bufferNames);\n+    } else {\n+      addRowsToIndex(session, buffer, index);\n+    }\n+    if (SysProperties.CHECK && remaining != 0) {\n+      DbException.throwInternalError(\"rowcount remaining=\" + remaining +\n+          \" \" + getName());\n+    }\n+  }\n+\n+  private void rebuildIndexBuffered(Session session, Index index) {\n+    Index scan = getScanIndex(session);\n+    long remaining = scan.getRowCount(session);\n+    long total = remaining;\n+    Cursor cursor = scan.find(session, null, null);\n+    long i = 0;\n+    int bufferSize = (int) Math.min(total, database.getMaxMemoryRows());\n+    ArrayList<Row> buffer = new ArrayList<>(bufferSize);\n+    String n = getName() + \":\" + index.getName();\n+    int t = MathUtils.convertLongToInt(total);\n+    while (cursor.next()) {\n+      Row row = cursor.get();\n+      buffer.add(row);\n+      database.setProgress(DatabaseEventListener.STATE_CREATE_INDEX, n,\n+          MathUtils.convertLongToInt(i++), t);\n+      if (buffer.size() >= bufferSize) {\n         addRowsToIndex(session, buffer, index);\n-        if (SysProperties.CHECK && remaining != 0) {\n-            DbException.throwInternalError(\"rowcount remaining=\" + remaining +\n-                    \" \" + getName());\n-        }\n-    }\n-\n-    private int getMainIndexColumn(IndexType indexType, IndexColumn[] cols) {\n-        if (primaryIndex.getMainIndexColumn() != SearchRow.ROWID_INDEX) {\n-            return SearchRow.ROWID_INDEX;\n-        }\n-        if (!indexType.isPrimaryKey() || cols.length != 1) {\n-            return SearchRow.ROWID_INDEX;\n-        }\n-        IndexColumn first = cols[0];\n-        if (first.sortType != SortOrder.ASCENDING) {\n-            return SearchRow.ROWID_INDEX;\n-        }\n-        switch (first.column.getType()) {\n-        case Value.BYTE:\n-        case Value.SHORT:\n-        case Value.INT:\n-        case Value.LONG:\n-            break;\n-        default:\n-            return SearchRow.ROWID_INDEX;\n-        }\n-        return first.column.getColumnId();\n-    }\n-\n-    private static void addRowsToIndex(Session session, ArrayList<Row> list,\n-            Index index) {\n-        sortRows(list, index);\n-        for (Row row : list) {\n-            index.add(session, row);\n-        }\n-        list.clear();\n-    }\n-\n-    private static void sortRows(ArrayList<? extends SearchRow> list, final Index index) {\n-        Collections.sort(list, new Comparator<SearchRow>() {\n-            @Override\n-            public int compare(SearchRow r1, SearchRow r2) {\n-                return index.compareRows(r1, r2);\n-            }\n-        });\n-    }\n-\n-    @Override\n-    public void removeRow(Session session, Row row) {\n-        lastModificationId = database.getNextModificationDataId();\n-        Transaction t = session.getTransaction();\n-        long savepoint = t.setSavepoint();\n-        try {\n-            for (int i = indexes.size() - 1; i >= 0; i--) {\n-                Index index = indexes.get(i);\n-                index.remove(session, row);\n-            }\n-        } catch (Throwable e) {\n-            try {\n-                t.rollbackToSavepoint(savepoint);\n-            } catch (Throwable nested) {\n-                e.addSuppressed(nested);\n-            }\n-            throw DbException.convert(e);\n-        }\n-        analyzeIfRequired(session);\n-    }\n-\n-    @Override\n-    public void truncate(Session session) {\n-        lastModificationId = database.getNextModificationDataId();\n-        for (int i = indexes.size() - 1; i >= 0; i--) {\n-            Index index = indexes.get(i);\n-            index.truncate(session);\n-        }\n-        changesSinceAnalyze = 0;\n-    }\n-\n-    @Override\n-    public void addRow(Session session, Row row) {\n-        lastModificationId = database.getNextModificationDataId();\n-        Transaction t = session.getTransaction();\n-        long savepoint = t.setSavepoint();\n-        try {\n-            for (Index index : indexes) {\n-                index.add(session, row);\n-            }\n-        } catch (Throwable e) {\n-            try {\n-                t.rollbackToSavepoint(savepoint);\n-            } catch (Throwable nested) {\n-                e.addSuppressed(nested);\n-            }\n-            throw DbException.convert(e);\n-        }\n-        analyzeIfRequired(session);\n-    }\n-\n-    @Override\n-    public void lockRows(Session session, Iterable<Row> rowsForUpdate) {\n-        primaryIndex.lockRows(session, rowsForUpdate);\n-    }\n-\n-    private void analyzeIfRequired(Session session) {\n-        synchronized (this) {\n-            if (++changesSinceAnalyze <= nextAnalyze) {\n-                return;\n-            }\n-            changesSinceAnalyze = 0;\n-            if (nextAnalyze <= Integer.MAX_VALUE / 2) {\n-                nextAnalyze *= 2;\n-            }\n-        }\n-        session.markTableForAnalyze(this);\n-    }\n-\n-    @Override\n-    public void checkSupportAlter() {\n-        // ok\n-    }\n-\n-    @Override\n-    public TableType getTableType() {\n-        return TableType.TABLE;\n-    }\n-\n-    @Override\n-    public Index getScanIndex(Session session) {\n-        return primaryIndex;\n-    }\n-\n-    @Override\n-    public Index getUniqueIndex() {\n-        return primaryIndex;\n-    }\n-\n-    @Override\n-    public ArrayList<Index> getIndexes() {\n-        return indexes;\n-    }\n-\n-    @Override\n-    public long getMaxDataModificationId() {\n-        return lastModificationId;\n-    }\n-\n-    public boolean getContainsLargeObject() {\n-        return containsLargeObject;\n-    }\n-\n-    @Override\n-    public boolean isDeterministic() {\n-        return true;\n-    }\n-\n-    @Override\n-    public boolean canGetRowCount() {\n-        return true;\n-    }\n-\n-    @Override\n-    public boolean canDrop() {\n-        return true;\n-    }\n-\n-    @Override\n-    public void removeChildrenAndResources(Session session) {\n-        if (containsLargeObject) {\n-            // unfortunately, the data is gone on rollback\n-            truncate(session);\n-            database.getLobStorage().removeAllForTable(getId());\n-            database.lockMeta(session);\n-        }\n-        database.getMvStore().removeTable(this);\n-        super.removeChildrenAndResources(session);\n-        // go backwards because database.removeIndex will\n-        // call table.removeIndex\n-        while (indexes.size() > 1) {\n-            Index index = indexes.get(1);\n-            if (index.getName() != null) {\n-                database.removeSchemaObject(session, index);\n-            }\n-            // needed for session temporary indexes\n-            indexes.remove(index);\n-        }\n-        if (SysProperties.CHECK) {\n-            for (SchemaObject obj : database\n-                    .getAllSchemaObjects(DbObject.INDEX)) {\n-                Index index = (Index) obj;\n-                if (index.getTable() == this) {\n-                    DbException.throwInternalError(\"index not dropped: \" +\n-                            index.getName());\n-                }\n-            }\n-        }\n-        primaryIndex.remove(session);\n-        database.removeMeta(session, getId());\n-        close(session);\n-        invalidate();\n-    }\n-\n-    @Override\n-    public long getRowCount(Session session) {\n-        return primaryIndex.getRowCount(session);\n-    }\n-\n-    @Override\n-    public long getRowCountApproximation() {\n-        return primaryIndex.getRowCountApproximation();\n-    }\n-\n-    @Override\n-    public long getDiskSpaceUsed() {\n-        return primaryIndex.getDiskSpaceUsed();\n-    }\n-\n-    @Override\n-    public void checkRename() {\n-        // ok\n-    }\n-\n-    /**\n-     * Get a new transaction.\n-     *\n-     * @return the transaction\n-     */\n-    Transaction getTransactionBegin() {\n-        // TODO need to commit/rollback the transaction\n-        return transactionStore.begin();\n-    }\n-\n-    @Override\n-    public Column getRowIdColumn() {\n-        if (rowIdColumn == null) {\n-            rowIdColumn = new Column(Column.ROWID, Value.LONG);\n-            rowIdColumn.setTable(this, SearchRow.ROWID_INDEX);\n-        }\n-        return rowIdColumn;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return getSQL();\n-    }\n-\n-    @Override\n-    public boolean isMVStore() {\n-        return true;\n-    }\n-\n-    /**\n-     * Mark the transaction as committed, so that the modification counter of\n-     * the database is incremented.\n-     */\n-    public void commit() {\n-        if (database != null) {\n-            lastModificationId = database.getNextModificationDataId();\n-        }\n-    }\n-\n-    /**\n-     * Convert the illegal state exception to a database exception.\n-     *\n-     * @param e the illegal state exception\n-     * @return the database exception\n-     */\n-    DbException convertException(IllegalStateException e) {\n-        int errorCode = DataUtils.getErrorCode(e.getMessage());\n-        if (errorCode == DataUtils.ERROR_TRANSACTION_LOCKED) {\n-            throw DbException.get(ErrorCode.CONCURRENT_UPDATE_1,\n-                    e, getName());\n-        }\n-        if (errorCode == DataUtils.ERROR_TRANSACTIONS_DEADLOCK) {\n-            throw DbException.get(ErrorCode.DEADLOCK_1,\n-                    e, getName());\n-        }\n-        return store.convertIllegalStateException(e);\n-    }\n+      }\n+      remaining--;\n+    }\n+    addRowsToIndex(session, buffer, index);\n+    if (SysProperties.CHECK && remaining != 0) {\n+      DbException.throwInternalError(\"rowcount remaining=\" + remaining +\n+          \" \" + getName());\n+    }\n+  }\n+\n+  private int getMainIndexColumn(IndexType indexType, IndexColumn[] cols) {\n+    if (primaryIndex.getMainIndexColumn() != SearchRow.ROWID_INDEX) {\n+      return SearchRow.ROWID_INDEX;\n+    }\n+    if (!indexType.isPrimaryKey() || cols.length != 1) {\n+      return SearchRow.ROWID_INDEX;\n+    }\n+    IndexColumn first = cols[0];\n+    if (first.sortType != SortOrder.ASCENDING) {\n+      return SearchRow.ROWID_INDEX;\n+    }\n+    switch (first.column.getType()) {\n+      case Value.BYTE:\n+      case Value.SHORT:\n+      case Value.INT:\n+      case Value.LONG:\n+        break;\n+      default:\n+        return SearchRow.ROWID_INDEX;\n+    }\n+    return first.column.getColumnId();\n+  }\n+\n+  private static void addRowsToIndex(Session session, ArrayList<Row> list,\n+                                     Index index) {\n+    sortRows(list, index);\n+    for (Row row : list) {\n+      index.add(session, row);\n+    }\n+    list.clear();\n+  }\n+\n+  private static void sortRows(ArrayList<? extends SearchRow> list, final Index index) {\n+    Collections.sort(list, new Comparator<SearchRow>() {\n+      @Override\n+      public int compare(SearchRow r1, SearchRow r2) {\n+        return index.compareRows(r1, r2);\n+      }\n+    });\n+  }\n+\n+  @Override\n+  public void removeRow(Session session, Row row) {\n+    lastModificationId = database.getNextModificationDataId();\n+    Transaction t = session.getTransaction();\n+    long savepoint = t.setSavepoint();\n+    try {\n+      for (int i = indexes.size() - 1; i >= 0; i--) {\n+        Index index = indexes.get(i);\n+        index.remove(session, row);\n+      }\n+    } catch (Throwable e) {\n+      try {\n+        t.rollbackToSavepoint(savepoint);\n+      } catch (Throwable nested) {\n+        e.addSuppressed(nested);\n+      }\n+      throw DbException.convert(e);\n+    }\n+    analyzeIfRequired(session);\n+  }\n+\n+  @Override\n+  public void truncate(Session session) {\n+    lastModificationId = database.getNextModificationDataId();\n+    for (int i = indexes.size() - 1; i >= 0; i--) {\n+      Index index = indexes.get(i);\n+      index.truncate(session);\n+    }\n+    changesSinceAnalyze = 0;\n+  }\n+\n+  @Override\n+  public void addRow(Session session, Row row) {\n+    lastModificationId = database.getNextModificationDataId();\n+    Transaction t = session.getTransaction();\n+    long savepoint = t.setSavepoint();\n+    try {\n+      for (Index index : indexes) {\n+        index.add(session, row);\n+      }\n+    } catch (Throwable e) {\n+      try {\n+        t.rollbackToSavepoint(savepoint);\n+      } catch (Throwable nested) {\n+        e.addSuppressed(nested);\n+      }\n+      throw DbException.convert(e);\n+    }\n+    analyzeIfRequired(session);\n+  }\n+\n+  @Override\n+  public void lockRows(Session session, Iterable<Row> rowsForUpdate) {\n+    primaryIndex.lockRows(session, rowsForUpdate);\n+  }\n+\n+  private void analyzeIfRequired(Session session) {\n+    synchronized (this) {\n+      if (++changesSinceAnalyze <= nextAnalyze) {\n+        return;\n+      }\n+      changesSinceAnalyze = 0;\n+      if (nextAnalyze <= Integer.MAX_VALUE / 2) {\n+        nextAnalyze *= 2;\n+      }\n+    }\n+    session.markTableForAnalyze(this);\n+  }\n+\n+  @Override\n+  public void checkSupportAlter() {\n+    // ok\n+  }\n+\n+  @Override\n+  public TableType getTableType() {\n+    return TableType.TABLE;\n+  }\n+\n+  @Override\n+  public Index getScanIndex(Session session) {\n+    return primaryIndex;\n+  }\n+\n+  @Override\n+  public Index getUniqueIndex() {\n+    return primaryIndex;\n+  }\n+\n+  @Override\n+  public ArrayList<Index> getIndexes() {\n+    return indexes;\n+  }\n+\n+  @Override\n+  public long getMaxDataModificationId() {\n+    return lastModificationId;\n+  }\n+\n+  public boolean getContainsLargeObject() {\n+    return containsLargeObject;\n+  }\n+\n+  @Override\n+  public boolean isDeterministic() {\n+    return true;\n+  }\n+\n+  @Override\n+  public boolean canGetRowCount() {\n+    return true;\n+  }\n+\n+  @Override\n+  public boolean canDrop() {\n+    return true;\n+  }\n+\n+  @Override\n+  public void removeChildrenAndResources(Session session) {\n+    if (containsLargeObject) {\n+      // unfortunately, the data is gone on rollback\n+      truncate(session);\n+      database.getLobStorage().removeAllForTable(getId());\n+      database.lockMeta(session);\n+    }\n+    database.getMvStore().removeTable(this);\n+    super.removeChildrenAndResources(session);\n+    // go backwards because database.removeIndex will\n+    // call table.removeIndex\n+    while (indexes.size() > 1) {\n+      Index index = indexes.get(1);\n+      if (index.getName() != null) {\n+        database.removeSchemaObject(session, index);\n+      }\n+      // needed for session temporary indexes\n+      indexes.remove(index);\n+    }\n+    if (SysProperties.CHECK) {\n+      for (SchemaObject obj : database\n+          .getAllSchemaObjects(DbObject.INDEX)) {\n+        Index index = (Index) obj;\n+        if (index.getTable() == this) {\n+          DbException.throwInternalError(\"index not dropped: \" +\n+              index.getName());\n+        }\n+      }\n+    }\n+    primaryIndex.remove(session);\n+    database.removeMeta(session, getId());\n+    close(session);\n+    invalidate();\n+  }\n+\n+  @Override\n+  public long getRowCount(Session session) {\n+    return primaryIndex.getRowCount(session);\n+  }\n+\n+  @Override\n+  public long getRowCountApproximation() {\n+    return primaryIndex.getRowCountApproximation();\n+  }\n+\n+  @Override\n+  public long getDiskSpaceUsed() {\n+    return primaryIndex.getDiskSpaceUsed();\n+  }\n+\n+  @Override\n+  public void checkRename() {\n+    // ok\n+  }\n+\n+  /**\n+   * Get a new transaction.\n+   *\n+   * @return the transaction\n+   */\n+  Transaction getTransactionBegin() {\n+    // TODO need to commit/rollback the transaction\n+    return transactionStore.begin();\n+  }\n+\n+  @Override\n+  public Column getRowIdColumn() {\n+    if (rowIdColumn == null) {\n+      rowIdColumn = new Column(Column.ROWID, Value.LONG);\n+      rowIdColumn.setTable(this, SearchRow.ROWID_INDEX);\n+    }\n+    return rowIdColumn;\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return getSQL();\n+  }\n+\n+  @Override\n+  public boolean isMVStore() {\n+    return true;\n+  }\n+\n+  /**\n+   * Mark the transaction as committed, so that the modification counter of\n+   * the database is incremented.\n+   */\n+  public void commit() {\n+    if (database != null) {\n+      lastModificationId = database.getNextModificationDataId();\n+    }\n+  }\n+\n+  /**\n+   * Convert the illegal state exception to a database exception.\n+   *\n+   * @param e the illegal state exception\n+   * @return the database exception\n+   */\n+  DbException convertException(IllegalStateException e) {\n+    int errorCode = DataUtils.getErrorCode(e.getMessage());\n+    if (errorCode == DataUtils.ERROR_TRANSACTION_LOCKED) {\n+      throw DbException.get(ErrorCode.CONCURRENT_UPDATE_1,\n+          e, getName());\n+    }\n+    if (errorCode == DataUtils.ERROR_TRANSACTIONS_DEADLOCK) {\n+      throw DbException.get(ErrorCode.DEADLOCK_1,\n+          e, getName());\n+    }\n+    return store.convertIllegalStateException(e);\n+  }\n }\n",
            "diff_size": 1163
        },
        {
            "tool": "naturalize",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/106/MVTable.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/naturalize/106/MVTable.java\nindex 6e325d5571f..0388088d666 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/106/MVTable.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/naturalize/106/MVTable.java\n@@ -69,7 +69,7 @@ public class MVTable extends TableBase {\n     /**\n      * The type of trace lock events\n      */\n-    private enum TraceLockEvent{\n+    private enum TraceLockEvent {\n \n         TRACE_LOCK_OK(\"ok\"),\n         TRACE_LOCK_WAITING_FOR(\"waiting for\"),\n@@ -89,7 +89,8 @@ public class MVTable extends TableBase {\n             return eventText;\n         }\n     }\n-    private static final String NO_EXTRA_INFO = \"\";\n+\n+private static final String NO_EXTRA_INFO = \"\";\n \n     static {\n         if (SysProperties.THREAD_DEADLOCK_DETECTOR) {\n@@ -129,7 +130,7 @@ public class MVTable extends TableBase {\n     public MVTable(CreateTableData data, MVTableEngine.Store store) {\n         super(data);\n         nextAnalyze = database.getSettings().analyzeAuto;\n-        if(nextAnalyze <= 0) {\n+        if (nextAnalyze <= 0) {\n             nextAnalyze = Integer.MAX_VALUE;\n         }\n         this.store = store;\n@@ -932,4 +933,4 @@ public class MVTable extends TableBase {\n         }\n         return store.convertIllegalStateException(e);\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 5
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/106/MVTable.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/codebuff/106/MVTable.java\nindex 6e325d5571f..9a0ad745dbe 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/106/MVTable.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/codebuff/106/MVTable.java\n@@ -13,7 +13,6 @@ import java.util.HashSet;\n import java.util.Set;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.TimeUnit;\n-\n import org.h2.api.DatabaseEventListener;\n import org.h2.api.ErrorCode;\n import org.h2.command.ddl.CreateTableData;\n@@ -50,33 +49,46 @@ import org.h2.value.Value;\n /**\n  * A table stored in a MVStore.\n  */\n+\n+\n public class MVTable extends TableBase {\n     /**\n      * The table name this thread is waiting to lock.\n      */\n+\n+\n     public static final DebuggingThreadLocal<String> WAITING_FOR_LOCK;\n \n     /**\n      * The table names this thread has exclusively locked.\n      */\n+\n+\n     public static final DebuggingThreadLocal<ArrayList<String>> EXCLUSIVE_LOCKS;\n \n     /**\n      * The tables names this thread has a shared lock on.\n      */\n+\n+\n     public static final DebuggingThreadLocal<ArrayList<String>> SHARED_LOCKS;\n \n     /**\n      * The type of trace lock events\n      */\n-    private enum TraceLockEvent{\n-\n+    private enum TraceLockEvent {\n         TRACE_LOCK_OK(\"ok\"),\n+\n         TRACE_LOCK_WAITING_FOR(\"waiting for\"),\n+\n         TRACE_LOCK_REQUESTING_FOR(\"requesting for\"),\n+\n         TRACE_LOCK_TIMEOUT_AFTER(\"timeout after \"),\n+\n         TRACE_LOCK_UNLOCK(\"unlock\"),\n+\n         TRACE_LOCK_ADDED_FOR(\"added for\"),\n+\n         TRACE_LOCK_ADD_UPGRADED_FOR(\"add (upgraded) for \");\n \n         private final String eventText;\n@@ -85,17 +97,20 @@ public class MVTable extends TableBase {\n             this.eventText = eventText;\n         }\n \n+\n         public String getEventText() {\n             return eventText;\n         }\n+\n     }\n+\n     private static final String NO_EXTRA_INFO = \"\";\n \n     static {\n         if (SysProperties.THREAD_DEADLOCK_DETECTOR) {\n-            WAITING_FOR_LOCK = new DebuggingThreadLocal<>();\n-            EXCLUSIVE_LOCKS = new DebuggingThreadLocal<>();\n-            SHARED_LOCKS = new DebuggingThreadLocal<>();\n+            WAITING_FOR_LOCK = new DebuggingThreadLocal< >();\n+            EXCLUSIVE_LOCKS = new DebuggingThreadLocal< >();\n+            SHARED_LOCKS = new DebuggingThreadLocal< >();\n         } else {\n             WAITING_FOR_LOCK = null;\n             EXCLUSIVE_LOCKS = null;\n@@ -109,27 +124,25 @@ public class MVTable extends TableBase {\n     private volatile Session lockExclusiveSession;\n \n     // using a ConcurrentHashMap as a set\n-    private final ConcurrentHashMap<Session, Session> lockSharedSessions =\n-            new ConcurrentHashMap<>();\n+    private final ConcurrentHashMap<Session, Session> lockSharedSessions = new ConcurrentHashMap< >();\n \n     /**\n      * The queue of sessions waiting to lock the table. It is a FIFO queue to\n      * prevent starvation, since Java's synchronized locking is biased.\n      */\n-    private final ArrayDeque<Session> waitingSessions = new ArrayDeque<>();\n+    private final ArrayDeque<Session> waitingSessions = new ArrayDeque< >();\n     private final Trace traceLock;\n     private int changesSinceAnalyze;\n     private int nextAnalyze;\n     private final boolean containsLargeObject;\n     private Column rowIdColumn;\n-\n     private final MVTableEngine.Store store;\n     private final TransactionStore transactionStore;\n \n     public MVTable(CreateTableData data, MVTableEngine.Store store) {\n         super(data);\n         nextAnalyze = database.getSettings().analyzeAuto;\n-        if(nextAnalyze <= 0) {\n+        if (nextAnalyze <= 0) {\n             nextAnalyze = Integer.MAX_VALUE;\n         }\n         this.store = store;\n@@ -151,19 +164,20 @@ public class MVTable extends TableBase {\n      *\n      * @param session the session\n      */\n+\n+\n     void init(Session session) {\n-        primaryIndex = new MVPrimaryIndex(session.getDatabase(), this, getId(),\n-                IndexColumn.wrap(getColumns()), IndexType.createScan(true));\n+        primaryIndex = new MVPrimaryIndex(session.getDatabase(), this, getId(), IndexColumn.wrap(getColumns()), IndexType.createScan(true));\n         indexes.add(primaryIndex);\n     }\n \n+\n     public String getMapName() {\n         return primaryIndex.getMapName();\n     }\n \n     @Override\n-    public boolean lock(Session session, boolean exclusive,\n-            boolean forceLockEvenInMvcc) {\n+    public boolean lock(Session session, boolean exclusive, boolean forceLockEvenInMvcc) {\n         int lockMode = database.getLockMode();\n         if (lockMode == Constants.LOCK_MODE_OFF) {\n             return false;\n@@ -217,6 +231,7 @@ public class MVTable extends TableBase {\n      *\n      * @return the lock sync object\n      */\n+\n     private Object getLockSyncObject() {\n         if (database.isMultiThreaded()) {\n             return this;\n@@ -239,8 +254,7 @@ public class MVTable extends TableBase {\n             if (checkDeadlock) {\n                 ArrayList<Session> sessions = checkDeadlock(session, null, null);\n                 if (sessions != null) {\n-                    throw DbException.get(ErrorCode.DEADLOCK_1,\n-                            getDeadlockDetails(sessions, exclusive));\n+                    throw DbException.get(ErrorCode.DEADLOCK_1, getDeadlockDetails(sessions, exclusive));\n                 }\n             } else {\n                 // check for deadlocks from now on\n@@ -251,8 +265,7 @@ public class MVTable extends TableBase {\n                 // try at least one more time\n                 max = now + TimeUnit.MILLISECONDS.toNanos(session.getLockTimeout());\n             } else if (now >= max) {\n-                traceLock(session, exclusive,\n-                        TraceLockEvent.TRACE_LOCK_TIMEOUT_AFTER, NO_EXTRA_INFO+session.getLockTimeout());\n+                traceLock(session, exclusive, TraceLockEvent.TRACE_LOCK_TIMEOUT_AFTER, NO_EXTRA_INFO + session.getLockTimeout());\n                 throw DbException.get(ErrorCode.LOCK_TIMEOUT_1, getName());\n             }\n             try {\n@@ -268,14 +281,14 @@ public class MVTable extends TableBase {\n                     }\n                 }\n                 // don't wait too long so that deadlocks are detected early\n-                long sleep = Math.min(Constants.DEADLOCK_CHECK,\n-                        TimeUnit.NANOSECONDS.toMillis(max - now));\n+                long sleep = Math.min(Constants.DEADLOCK_CHECK, TimeUnit.NANOSECONDS.toMillis(max - now));\n                 if (sleep == 0) {\n                     sleep = 1;\n                 }\n                 getLockSyncObject().wait(sleep);\n             } catch (InterruptedException e) {\n                 // ignore\n+\n             }\n         }\n     }\n@@ -294,8 +307,7 @@ public class MVTable extends TableBase {\n                         EXCLUSIVE_LOCKS.get().add(getName());\n                     }\n                     return true;\n-                } else if (lockSharedSessions.size() == 1 &&\n-                        lockSharedSessions.containsKey(session)) {\n+                } else if (lockSharedSessions.size() == 1 && lockSharedSessions.containsKey(session)) {\n                     traceLock(session, exclusive, TraceLockEvent.TRACE_LOCK_ADD_UPGRADED_FOR, NO_EXTRA_INFO);\n                     lockExclusiveSession = session;\n                     if (SysProperties.THREAD_DEADLOCK_DETECTOR) {\n@@ -310,8 +322,7 @@ public class MVTable extends TableBase {\n         } else {\n             if (lockExclusiveSession == null) {\n                 if (lockMode == Constants.LOCK_MODE_READ_COMMITTED) {\n-                    if (!database.isMultiThreaded() &&\n-                            !database.isMultiVersion()) {\n+                    if (!database.isMultiThreaded() && !database.isMultiVersion()) {\n                         // READ_COMMITTED: a read lock is acquired,\n                         // but released immediately after the operation\n                         // is complete.\n@@ -327,7 +338,7 @@ public class MVTable extends TableBase {\n                     if (SysProperties.THREAD_DEADLOCK_DETECTOR) {\n                         ArrayList<String> list = SHARED_LOCKS.get();\n                         if (list == null) {\n-                            list = new ArrayList<>();\n+                            list = new ArrayList< >();\n                             SHARED_LOCKS.set(list);\n                         }\n                         list.add(getName());\n@@ -346,11 +357,7 @@ public class MVTable extends TableBase {\n         for (Session s : sessions) {\n             Table lock = s.getWaitForLock();\n             Thread thread = s.getWaitForLockThread();\n-            buff.append(\"\\nSession \").append(s.toString())\n-                    .append(\" on thread \").append(thread.getName())\n-                    .append(\" is waiting to lock \").append(lock.toString())\n-                    .append(exclusive ? \" (exclusive)\" : \" (shared)\")\n-                    .append(\" while locking \");\n+            buff.append(\"\\nSession \").append(s.toString()).append(\" on thread \").append(thread.getName()).append(\" is waiting to lock \").append(lock.toString()).append(exclusive ? \" (exclusive)\" : \" (shared)\").append(\" while locking \");\n             int i = 0;\n             for (Table t : s.getLocks()) {\n                 if (i++ > 0) {\n@@ -371,23 +378,22 @@ public class MVTable extends TableBase {\n     }\n \n     @Override\n-    public ArrayList<Session> checkDeadlock(Session session, Session clash,\n-            Set<Session> visited) {\n+    public ArrayList<Session> checkDeadlock(Session session, Session clash, Set<Session> visited) {\n         // only one deadlock check at any given time\n         synchronized (MVTable.class) {\n             if (clash == null) {\n                 // verification is started\n                 clash = session;\n-                visited = new HashSet<>();\n+                visited = new HashSet< >();\n             } else if (clash == session) {\n                 // we found a circle where this session is involved\n-                return new ArrayList<>(0);\n-            } else if (visited.contains(session)) {\n+                return new ArrayList< >(0);\n+                                     } else if (visited.contains(session)) {\n                 // we have already checked this session.\n                 // there is a circle, but the sessions in the circle need to\n                 // find it out themselves\n-                return null;\n-            }\n+                       return null;\n+                   }\n             visited.add(session);\n             ArrayList<Session> error = null;\n             for (Session s : lockSharedSessions.keySet()) {\n@@ -410,8 +416,7 @@ public class MVTable extends TableBase {\n             if (error == null && copyOfLockExclusiveSession != null) {\n                 Table t = copyOfLockExclusiveSession.getWaitForLock();\n                 if (t != null) {\n-                    error = t.checkDeadlock(copyOfLockExclusiveSession, clash,\n-                            visited);\n+                    error = t.checkDeadlock(copyOfLockExclusiveSession, clash, visited);\n                     if (error != null) {\n                         error.add(session);\n                     }\n@@ -423,9 +428,7 @@ public class MVTable extends TableBase {\n \n     private void traceLock(Session session, boolean exclusive, TraceLockEvent eventEnum, String extraInfo) {\n         if (traceLock.isDebugEnabled()) {\n-            traceLock.debug(\"{0} {1} {2} {3} {4}\", session.getId(),\n-                    exclusive ? \"exclusive write lock\" : \"shared read lock\", eventEnum.getEventText(),\n-                    getName(), extraInfo);\n+            traceLock.debug(\"{0} {1} {2} {3} {4}\", session.getId(), exclusive ? \"exclusive write lock\" : \"shared read lock\", eventEnum.getEventText(), getName(), extraInfo);\n         }\n     }\n \n@@ -470,8 +473,7 @@ public class MVTable extends TableBase {\n \n     @Override\n     public boolean canTruncate() {\n-        if (getCheckForeignKeyConstraints() &&\n-                database.getReferentialIntegrity()) {\n+        if (getCheckForeignKeyConstraints() && database.getReferentialIntegrity()) {\n             ArrayList<Constraint> constraints = getConstraints();\n             if (constraints != null) {\n                 for (Constraint c : constraints) {\n@@ -491,6 +493,7 @@ public class MVTable extends TableBase {\n     @Override\n     public void close(Session session) {\n         // ignore\n+\n     }\n \n     @Override\n@@ -499,16 +502,12 @@ public class MVTable extends TableBase {\n     }\n \n     @Override\n-    public Index addIndex(Session session, String indexName, int indexId,\n-            IndexColumn[] cols, IndexType indexType, boolean create,\n-            String indexComment) {\n+    public Index addIndex(Session session, String indexName, int indexId, IndexColumn[] cols, IndexType indexType, boolean create, String indexComment) {\n         if (indexType.isPrimaryKey()) {\n             for (IndexColumn c : cols) {\n                 Column column = c.column;\n                 if (column.isNullable()) {\n-                    throw DbException.get(\n-                            ErrorCode.COLUMN_MUST_NOT_BE_NULLABLE_1,\n-                            column.getName());\n+                    throw DbException.get(ErrorCode.COLUMN_MUST_NOT_BE_NULLABLE_1, column.getName());\n                 }\n                 column.setPrimaryKey(true);\n             }\n@@ -529,14 +528,11 @@ public class MVTable extends TableBase {\n         }\n         if (mainIndexColumn != SearchRow.ROWID_INDEX) {\n             primaryIndex.setMainIndexColumn(mainIndexColumn);\n-            index = new MVDelegateIndex(this, indexId, indexName, primaryIndex,\n-                    indexType);\n+            index = new MVDelegateIndex(this, indexId, indexName, primaryIndex, indexType);\n         } else if (indexType.isSpatial()) {\n-            index = new MVSpatialIndex(session.getDatabase(), this, indexId,\n-                    indexName, cols, indexType);\n-        } else {\n-            index = new MVSecondaryIndex(session.getDatabase(), this, indexId,\n-                    indexName, cols, indexType);\n+            index = new MVSpatialIndex(session.getDatabase(), this, indexId, indexName, cols, indexType);\n+                                                                                                                                                        } else {\n+            index = new MVSecondaryIndex(session.getDatabase(), this, indexId, indexName, cols, indexType);\n         }\n         if (index.needRebuild()) {\n             rebuildIndex(session, index, indexName);\n@@ -557,8 +553,7 @@ public class MVTable extends TableBase {\n \n     private void rebuildIndex(Session session, MVIndex index, String indexName) {\n         try {\n-            if (session.getDatabase().getMvStore() == null ||\n-                    index instanceof MVSpatialIndex) {\n+            if (session.getDatabase().getMvStore() == null || index instanceof MVSpatialIndex) {\n                 // in-memory\n                 rebuildIndexBuffered(session, index);\n             } else {\n@@ -597,17 +592,15 @@ public class MVTable extends TableBase {\n         Cursor cursor = scan.find(session, null, null);\n         long i = 0;\n         Store store = session.getDatabase().getMvStore();\n-\n         int bufferSize = database.getMaxMemoryRows() / 2;\n-        ArrayList<Row> buffer = new ArrayList<>(bufferSize);\n+        ArrayList<Row> buffer = new ArrayList< >(bufferSize);\n         String n = getName() + \":\" + index.getName();\n         int t = MathUtils.convertLongToInt(total);\n         ArrayList<String> bufferNames = Utils.newSmallArrayList();\n         while (cursor.next()) {\n             Row row = cursor.get();\n             buffer.add(row);\n-            database.setProgress(DatabaseEventListener.STATE_CREATE_INDEX, n,\n-                    MathUtils.convertLongToInt(i++), t);\n+            database.setProgress(DatabaseEventListener.STATE_CREATE_INDEX, n, MathUtils.convertLongToInt(i++), t);\n             if (buffer.size() >= bufferSize) {\n                 sortRows(buffer, index);\n                 String mapName = store.nextTemporaryMapName();\n@@ -628,8 +621,7 @@ public class MVTable extends TableBase {\n             addRowsToIndex(session, buffer, index);\n         }\n         if (SysProperties.CHECK && remaining != 0) {\n-            DbException.throwInternalError(\"rowcount remaining=\" + remaining +\n-                    \" \" + getName());\n+            DbException.throwInternalError(\"rowcount remaining=\" + remaining + \" \" + getName());\n         }\n     }\n \n@@ -640,14 +632,13 @@ public class MVTable extends TableBase {\n         Cursor cursor = scan.find(session, null, null);\n         long i = 0;\n         int bufferSize = (int) Math.min(total, database.getMaxMemoryRows());\n-        ArrayList<Row> buffer = new ArrayList<>(bufferSize);\n+        ArrayList<Row> buffer = new ArrayList< >(bufferSize);\n         String n = getName() + \":\" + index.getName();\n         int t = MathUtils.convertLongToInt(total);\n         while (cursor.next()) {\n             Row row = cursor.get();\n             buffer.add(row);\n-            database.setProgress(DatabaseEventListener.STATE_CREATE_INDEX, n,\n-                    MathUtils.convertLongToInt(i++), t);\n+            database.setProgress(DatabaseEventListener.STATE_CREATE_INDEX, n, MathUtils.convertLongToInt(i++), t);\n             if (buffer.size() >= bufferSize) {\n                 addRowsToIndex(session, buffer, index);\n             }\n@@ -655,8 +646,7 @@ public class MVTable extends TableBase {\n         }\n         addRowsToIndex(session, buffer, index);\n         if (SysProperties.CHECK && remaining != 0) {\n-            DbException.throwInternalError(\"rowcount remaining=\" + remaining +\n-                    \" \" + getName());\n+            DbException.throwInternalError(\"rowcount remaining=\" + remaining + \" \" + getName());\n         }\n     }\n \n@@ -683,8 +673,7 @@ public class MVTable extends TableBase {\n         return first.column.getColumnId();\n     }\n \n-    private static void addRowsToIndex(Session session, ArrayList<Row> list,\n-            Index index) {\n+    private static void addRowsToIndex(Session session, ArrayList<Row> list, Index index) {\n         sortRows(list, index);\n         for (Row row : list) {\n             index.add(session, row);\n@@ -694,10 +683,10 @@ public class MVTable extends TableBase {\n \n     private static void sortRows(ArrayList<? extends SearchRow> list, final Index index) {\n         Collections.sort(list, new Comparator<SearchRow>() {\n-            @Override\n-            public int compare(SearchRow r1, SearchRow r2) {\n-                return index.compareRows(r1, r2);\n-            }\n+@Override\n+public int compare(SearchRow r1, SearchRow r2) {\n+    return index.compareRows(r1, r2);\n+}\n         });\n     }\n \n@@ -773,6 +762,7 @@ public class MVTable extends TableBase {\n     @Override\n     public void checkSupportAlter() {\n         // ok\n+\n     }\n \n     @Override\n@@ -800,6 +790,7 @@ public class MVTable extends TableBase {\n         return lastModificationId;\n     }\n \n+\n     public boolean getContainsLargeObject() {\n         return containsLargeObject;\n     }\n@@ -840,12 +831,10 @@ public class MVTable extends TableBase {\n             indexes.remove(index);\n         }\n         if (SysProperties.CHECK) {\n-            for (SchemaObject obj : database\n-                    .getAllSchemaObjects(DbObject.INDEX)) {\n+            for (SchemaObject obj : database.getAllSchemaObjects(DbObject.INDEX)) {\n                 Index index = (Index) obj;\n                 if (index.getTable() == this) {\n-                    DbException.throwInternalError(\"index not dropped: \" +\n-                            index.getName());\n+                    DbException.throwInternalError(\"index not dropped: \" + index.getName());\n                 }\n             }\n         }\n@@ -873,6 +862,7 @@ public class MVTable extends TableBase {\n     @Override\n     public void checkRename() {\n         // ok\n+\n     }\n \n     /**\n@@ -880,6 +870,8 @@ public class MVTable extends TableBase {\n      *\n      * @return the transaction\n      */\n+\n+\n     Transaction getTransactionBegin() {\n         // TODO need to commit/rollback the transaction\n         return transactionStore.begin();\n@@ -908,6 +900,8 @@ public class MVTable extends TableBase {\n      * Mark the transaction as committed, so that the modification counter of\n      * the database is incremented.\n      */\n+\n+\n     public void commit() {\n         if (database != null) {\n             lastModificationId = database.getNextModificationDataId();\n@@ -920,16 +914,17 @@ public class MVTable extends TableBase {\n      * @param e the illegal state exception\n      * @return the database exception\n      */\n+\n+\n     DbException convertException(IllegalStateException e) {\n         int errorCode = DataUtils.getErrorCode(e.getMessage());\n         if (errorCode == DataUtils.ERROR_TRANSACTION_LOCKED) {\n-            throw DbException.get(ErrorCode.CONCURRENT_UPDATE_1,\n-                    e, getName());\n+            throw DbException.get(ErrorCode.CONCURRENT_UPDATE_1, e, getName());\n         }\n         if (errorCode == DataUtils.ERROR_TRANSACTIONS_DEADLOCK) {\n-            throw DbException.get(ErrorCode.DEADLOCK_1,\n-                    e, getName());\n+            throw DbException.get(ErrorCode.DEADLOCK_1, e, getName());\n         }\n         return store.convertIllegalStateException(e);\n     }\n-}\n+\n+}\n\\ No newline at end of file\n",
            "diff_size": 119
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/106/MVTable.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_random/106/MVTable.java\nindex 6e325d5571f..3768b127631 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/106/MVTable.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_random/106/MVTable.java\n@@ -129,7 +129,7 @@ public class MVTable extends TableBase {\n     public MVTable(CreateTableData data, MVTableEngine.Store store) {\n         super(data);\n         nextAnalyze = database.getSettings().analyzeAuto;\n-        if(nextAnalyze <= 0) {\n+        if (nextAnalyze <= 0) {\n             nextAnalyze = Integer.MAX_VALUE;\n         }\n         this.store = store;\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/106/MVTable.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/106/MVTable.java\nindex 6e325d5571f..3768b127631 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/106/MVTable.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/106/MVTable.java\n@@ -129,7 +129,7 @@ public class MVTable extends TableBase {\n     public MVTable(CreateTableData data, MVTableEngine.Store store) {\n         super(data);\n         nextAnalyze = database.getSettings().analyzeAuto;\n-        if(nextAnalyze <= 0) {\n+        if (nextAnalyze <= 0) {\n             nextAnalyze = Integer.MAX_VALUE;\n         }\n         this.store = store;\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": []
}