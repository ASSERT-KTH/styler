{
    "project_name": "fangjinuo-easyjson",
    "error_id": "43",
    "information": {
        "errors": [
            {
                "line": "253",
                "column": "26",
                "severity": "warning",
                "message": "'{' is followed by whitespace.",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.NoWhitespaceAfterCheck"
            }
        ]
    },
    "source_code": "\n  @Override public void close() throws IOException {\n    stack = new Object[] { SENTINEL_CLOSED };\n    stackSize = 1;\n  }\n",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/errored/1/43/JsonTreeReader.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/styler/43/JsonTreeReader.java\nindex a223754aedd..59c3282bcfd 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/errored/1/43/JsonTreeReader.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/styler/43/JsonTreeReader.java\n@@ -250,7 +250,7 @@ public final class JsonTreeReader extends JsonReader {\n   }\n \n   @Override public void close() throws IOException {\n-    stack = new Object[] { SENTINEL_CLOSED };\n+    stack = new Object[] {SENTINEL_CLOSED };\n     stackSize = 1;\n   }\n \n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/errored/1/43/JsonTreeReader.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/intellij/43/JsonTreeReader.java\nindex a223754aedd..6e2b9009abc 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/errored/1/43/JsonTreeReader.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/intellij/43/JsonTreeReader.java\n@@ -36,281 +36,301 @@ import java.util.Arrays;\n  * @author Jesse Wilson\n  */\n public final class JsonTreeReader extends JsonReader {\n-  private static final Reader UNREADABLE_READER = new Reader() {\n-    @Override public int read(char[] buffer, int offset, int count) throws IOException {\n-      throw new AssertionError();\n-    }\n-    @Override public void close() throws IOException {\n-      throw new AssertionError();\n-    }\n-  };\n-  private static final Object SENTINEL_CLOSED = new Object();\n-\n-  /*\n-   * The nesting stack. Using a manual array rather than an ArrayList saves 20%.\n-   */\n-  private Object[] stack = new Object[32];\n-  private int stackSize = 0;\n+    private static final Reader UNREADABLE_READER = new Reader() {\n+        @Override\n+        public int read(char[] buffer, int offset, int count) throws IOException {\n+            throw new AssertionError();\n+        }\n \n-  /*\n-   * The path members. It corresponds directly to stack: At indices where the\n-   * stack contains an object (EMPTY_OBJECT, DANGLING_NAME or NONEMPTY_OBJECT),\n-   * pathNames contains the name at this scope. Where it contains an array\n-   * (EMPTY_ARRAY, NONEMPTY_ARRAY) pathIndices contains the current index in\n-   * that array. Otherwise the value is undefined, and we take advantage of that\n-   * by incrementing pathIndices when doing so isn't useful.\n-   */\n-  private String[] pathNames = new String[32];\n-  private int[] pathIndices = new int[32];\n+        @Override\n+        public void close() throws IOException {\n+            throw new AssertionError();\n+        }\n+    };\n+    private static final Object SENTINEL_CLOSED = new Object();\n \n-  public JsonTreeReader(JsonElement element) {\n-    super(UNREADABLE_READER);\n-    push(element);\n-  }\n+    /*\n+     * The nesting stack. Using a manual array rather than an ArrayList saves 20%.\n+     */\n+    private Object[] stack = new Object[32];\n+    private int stackSize = 0;\n \n-  @Override public void beginArray() throws IOException {\n-    expect(JsonToken.BEGIN_ARRAY);\n-    JsonArray array = (JsonArray) peekStack();\n-    push(array.iterator());\n-    pathIndices[stackSize - 1] = 0;\n-  }\n+    /*\n+     * The path members. It corresponds directly to stack: At indices where the\n+     * stack contains an object (EMPTY_OBJECT, DANGLING_NAME or NONEMPTY_OBJECT),\n+     * pathNames contains the name at this scope. Where it contains an array\n+     * (EMPTY_ARRAY, NONEMPTY_ARRAY) pathIndices contains the current index in\n+     * that array. Otherwise the value is undefined, and we take advantage of that\n+     * by incrementing pathIndices when doing so isn't useful.\n+     */\n+    private String[] pathNames = new String[32];\n+    private int[] pathIndices = new int[32];\n \n-  @Override public void endArray() throws IOException {\n-    expect(JsonToken.END_ARRAY);\n-    popStack(); // empty iterator\n-    popStack(); // array\n-    if (stackSize > 0) {\n-      pathIndices[stackSize - 1]++;\n+    public JsonTreeReader(JsonElement element) {\n+        super(UNREADABLE_READER);\n+        push(element);\n     }\n-  }\n-\n-  @Override public void beginObject() throws IOException {\n-    expect(JsonToken.BEGIN_OBJECT);\n-    JsonObject object = (JsonObject) peekStack();\n-    push(object.entrySet().iterator());\n-  }\n \n-  @Override public void endObject() throws IOException {\n-    expect(JsonToken.END_OBJECT);\n-    popStack(); // empty iterator\n-    popStack(); // object\n-    if (stackSize > 0) {\n-      pathIndices[stackSize - 1]++;\n+    @Override\n+    public void beginArray() throws IOException {\n+        expect(JsonToken.BEGIN_ARRAY);\n+        JsonArray array = (JsonArray) peekStack();\n+        push(array.iterator());\n+        pathIndices[stackSize - 1] = 0;\n     }\n-  }\n \n-  @Override public boolean hasNext() throws IOException {\n-    JsonToken token = peek();\n-    return token != JsonToken.END_OBJECT && token != JsonToken.END_ARRAY;\n-  }\n+    @Override\n+    public void endArray() throws IOException {\n+        expect(JsonToken.END_ARRAY);\n+        popStack(); // empty iterator\n+        popStack(); // array\n+        if (stackSize > 0) {\n+            pathIndices[stackSize - 1]++;\n+        }\n+    }\n \n-  @Override public JsonToken peek() throws IOException {\n-    if (stackSize == 0) {\n-      return JsonToken.END_DOCUMENT;\n+    @Override\n+    public void beginObject() throws IOException {\n+        expect(JsonToken.BEGIN_OBJECT);\n+        JsonObject object = (JsonObject) peekStack();\n+        push(object.entrySet().iterator());\n     }\n \n-    Object o = peekStack();\n-    if (o instanceof Iterator) {\n-      boolean isObject = stack[stackSize - 2] instanceof JsonObject;\n-      Iterator<?> iterator = (Iterator<?>) o;\n-      if (iterator.hasNext()) {\n-        if (isObject) {\n-          return JsonToken.NAME;\n-        } else {\n-          push(iterator.next());\n-          return peek();\n+    @Override\n+    public void endObject() throws IOException {\n+        expect(JsonToken.END_OBJECT);\n+        popStack(); // empty iterator\n+        popStack(); // object\n+        if (stackSize > 0) {\n+            pathIndices[stackSize - 1]++;\n         }\n-      } else {\n-        return isObject ? JsonToken.END_OBJECT : JsonToken.END_ARRAY;\n-      }\n-    } else if (o instanceof JsonObject) {\n-      return JsonToken.BEGIN_OBJECT;\n-    } else if (o instanceof JsonArray) {\n-      return JsonToken.BEGIN_ARRAY;\n-    } else if (o instanceof JsonPrimitive) {\n-      JsonPrimitive primitive = (JsonPrimitive) o;\n-      if (primitive.isString()) {\n-        return JsonToken.STRING;\n-      } else if (primitive.isBoolean()) {\n-        return JsonToken.BOOLEAN;\n-      } else if (primitive.isNumber()) {\n-        return JsonToken.NUMBER;\n-      } else {\n-        throw new AssertionError();\n-      }\n-    } else if (o instanceof JsonNull) {\n-      return JsonToken.NULL;\n-    } else if (o == SENTINEL_CLOSED) {\n-      throw new IllegalStateException(\"JsonReader is closed\");\n-    } else {\n-      throw new AssertionError();\n     }\n-  }\n-\n-  private Object peekStack() {\n-    return stack[stackSize - 1];\n-  }\n-\n-  private Object popStack() {\n-    Object result = stack[--stackSize];\n-    stack[stackSize] = null;\n-    return result;\n-  }\n \n-  private void expect(JsonToken expected) throws IOException {\n-    if (peek() != expected) {\n-      throw new IllegalStateException(\n-          \"Expected \" + expected + \" but was \" + peek() + locationString());\n+    @Override\n+    public boolean hasNext() throws IOException {\n+        JsonToken token = peek();\n+        return token != JsonToken.END_OBJECT && token != JsonToken.END_ARRAY;\n     }\n-  }\n \n-  @Override public String nextName() throws IOException {\n-    expect(JsonToken.NAME);\n-    Iterator<?> i = (Iterator<?>) peekStack();\n-    Map.Entry<?, ?> entry = (Map.Entry<?, ?>) i.next();\n-    String result = (String) entry.getKey();\n-    pathNames[stackSize - 1] = result;\n-    push(entry.getValue());\n-    return result;\n-  }\n+    @Override\n+    public JsonToken peek() throws IOException {\n+        if (stackSize == 0) {\n+            return JsonToken.END_DOCUMENT;\n+        }\n \n-  @Override public String nextString() throws IOException {\n-    JsonToken token = peek();\n-    if (token != JsonToken.STRING && token != JsonToken.NUMBER) {\n-      throw new IllegalStateException(\n-          \"Expected \" + JsonToken.STRING + \" but was \" + token + locationString());\n-    }\n-    String result = ((JsonPrimitive) popStack()).getAsString();\n-    if (stackSize > 0) {\n-      pathIndices[stackSize - 1]++;\n+        Object o = peekStack();\n+        if (o instanceof Iterator) {\n+            boolean isObject = stack[stackSize - 2] instanceof JsonObject;\n+            Iterator<?> iterator = (Iterator<?>) o;\n+            if (iterator.hasNext()) {\n+                if (isObject) {\n+                    return JsonToken.NAME;\n+                } else {\n+                    push(iterator.next());\n+                    return peek();\n+                }\n+            } else {\n+                return isObject ? JsonToken.END_OBJECT : JsonToken.END_ARRAY;\n+            }\n+        } else if (o instanceof JsonObject) {\n+            return JsonToken.BEGIN_OBJECT;\n+        } else if (o instanceof JsonArray) {\n+            return JsonToken.BEGIN_ARRAY;\n+        } else if (o instanceof JsonPrimitive) {\n+            JsonPrimitive primitive = (JsonPrimitive) o;\n+            if (primitive.isString()) {\n+                return JsonToken.STRING;\n+            } else if (primitive.isBoolean()) {\n+                return JsonToken.BOOLEAN;\n+            } else if (primitive.isNumber()) {\n+                return JsonToken.NUMBER;\n+            } else {\n+                throw new AssertionError();\n+            }\n+        } else if (o instanceof JsonNull) {\n+            return JsonToken.NULL;\n+        } else if (o == SENTINEL_CLOSED) {\n+            throw new IllegalStateException(\"JsonReader is closed\");\n+        } else {\n+            throw new AssertionError();\n+        }\n     }\n-    return result;\n-  }\n \n-  @Override public boolean nextBoolean() throws IOException {\n-    expect(JsonToken.BOOLEAN);\n-    boolean result = ((JsonPrimitive) popStack()).getAsBoolean();\n-    if (stackSize > 0) {\n-      pathIndices[stackSize - 1]++;\n+    private Object peekStack() {\n+        return stack[stackSize - 1];\n     }\n-    return result;\n-  }\n \n-  @Override public void nextNull() throws IOException {\n-    expect(JsonToken.NULL);\n-    popStack();\n-    if (stackSize > 0) {\n-      pathIndices[stackSize - 1]++;\n+    private Object popStack() {\n+        Object result = stack[--stackSize];\n+        stack[stackSize] = null;\n+        return result;\n     }\n-  }\n \n-  @Override public double nextDouble() throws IOException {\n-    JsonToken token = peek();\n-    if (token != JsonToken.NUMBER && token != JsonToken.STRING) {\n-      throw new IllegalStateException(\n-          \"Expected \" + JsonToken.NUMBER + \" but was \" + token + locationString());\n-    }\n-    double result = ((JsonPrimitive) peekStack()).getAsDouble();\n-    if (!isLenient() && (Double.isNaN(result) || Double.isInfinite(result))) {\n-      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + result);\n+    private void expect(JsonToken expected) throws IOException {\n+        if (peek() != expected) {\n+            throw new IllegalStateException(\n+                \"Expected \" + expected + \" but was \" + peek() + locationString());\n+        }\n     }\n-    popStack();\n-    if (stackSize > 0) {\n-      pathIndices[stackSize - 1]++;\n+\n+    @Override\n+    public String nextName() throws IOException {\n+        expect(JsonToken.NAME);\n+        Iterator<?> i = (Iterator<?>) peekStack();\n+        Map.Entry<?, ?> entry = (Map.Entry<?, ?>) i.next();\n+        String result = (String) entry.getKey();\n+        pathNames[stackSize - 1] = result;\n+        push(entry.getValue());\n+        return result;\n     }\n-    return result;\n-  }\n \n-  @Override public long nextLong() throws IOException {\n-    JsonToken token = peek();\n-    if (token != JsonToken.NUMBER && token != JsonToken.STRING) {\n-      throw new IllegalStateException(\n-          \"Expected \" + JsonToken.NUMBER + \" but was \" + token + locationString());\n+    @Override\n+    public String nextString() throws IOException {\n+        JsonToken token = peek();\n+        if (token != JsonToken.STRING && token != JsonToken.NUMBER) {\n+            throw new IllegalStateException(\n+                \"Expected \" + JsonToken.STRING + \" but was \" + token + locationString());\n+        }\n+        String result = ((JsonPrimitive) popStack()).getAsString();\n+        if (stackSize > 0) {\n+            pathIndices[stackSize - 1]++;\n+        }\n+        return result;\n     }\n-    long result = ((JsonPrimitive) peekStack()).getAsLong();\n-    popStack();\n-    if (stackSize > 0) {\n-      pathIndices[stackSize - 1]++;\n+\n+    @Override\n+    public boolean nextBoolean() throws IOException {\n+        expect(JsonToken.BOOLEAN);\n+        boolean result = ((JsonPrimitive) popStack()).getAsBoolean();\n+        if (stackSize > 0) {\n+            pathIndices[stackSize - 1]++;\n+        }\n+        return result;\n     }\n-    return result;\n-  }\n \n-  @Override public int nextInt() throws IOException {\n-    JsonToken token = peek();\n-    if (token != JsonToken.NUMBER && token != JsonToken.STRING) {\n-      throw new IllegalStateException(\n-          \"Expected \" + JsonToken.NUMBER + \" but was \" + token + locationString());\n+    @Override\n+    public void nextNull() throws IOException {\n+        expect(JsonToken.NULL);\n+        popStack();\n+        if (stackSize > 0) {\n+            pathIndices[stackSize - 1]++;\n+        }\n     }\n-    int result = ((JsonPrimitive) peekStack()).getAsInt();\n-    popStack();\n-    if (stackSize > 0) {\n-      pathIndices[stackSize - 1]++;\n+\n+    @Override\n+    public double nextDouble() throws IOException {\n+        JsonToken token = peek();\n+        if (token != JsonToken.NUMBER && token != JsonToken.STRING) {\n+            throw new IllegalStateException(\n+                \"Expected \" + JsonToken.NUMBER + \" but was \" + token + locationString());\n+        }\n+        double result = ((JsonPrimitive) peekStack()).getAsDouble();\n+        if (!isLenient() && (Double.isNaN(result) || Double.isInfinite(result))) {\n+            throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + result);\n+        }\n+        popStack();\n+        if (stackSize > 0) {\n+            pathIndices[stackSize - 1]++;\n+        }\n+        return result;\n     }\n-    return result;\n-  }\n \n-  @Override public void close() throws IOException {\n-    stack = new Object[] { SENTINEL_CLOSED };\n-    stackSize = 1;\n-  }\n+    @Override\n+    public long nextLong() throws IOException {\n+        JsonToken token = peek();\n+        if (token != JsonToken.NUMBER && token != JsonToken.STRING) {\n+            throw new IllegalStateException(\n+                \"Expected \" + JsonToken.NUMBER + \" but was \" + token + locationString());\n+        }\n+        long result = ((JsonPrimitive) peekStack()).getAsLong();\n+        popStack();\n+        if (stackSize > 0) {\n+            pathIndices[stackSize - 1]++;\n+        }\n+        return result;\n+    }\n \n-  @Override public void skipValue() throws IOException {\n-    if (peek() == JsonToken.NAME) {\n-      nextName();\n-      pathNames[stackSize - 2] = \"null\";\n-    } else {\n-      popStack();\n-      if (stackSize > 0) {\n-        pathNames[stackSize - 1] = \"null\";\n-      }\n+    @Override\n+    public int nextInt() throws IOException {\n+        JsonToken token = peek();\n+        if (token != JsonToken.NUMBER && token != JsonToken.STRING) {\n+            throw new IllegalStateException(\n+                \"Expected \" + JsonToken.NUMBER + \" but was \" + token + locationString());\n+        }\n+        int result = ((JsonPrimitive) peekStack()).getAsInt();\n+        popStack();\n+        if (stackSize > 0) {\n+            pathIndices[stackSize - 1]++;\n+        }\n+        return result;\n     }\n-    if (stackSize > 0) {\n-      pathIndices[stackSize - 1]++;\n+\n+    @Override\n+    public void close() throws IOException {\n+        stack = new Object[] {SENTINEL_CLOSED};\n+        stackSize = 1;\n     }\n-  }\n \n-  @Override public String toString() {\n-    return getClass().getSimpleName();\n-  }\n+    @Override\n+    public void skipValue() throws IOException {\n+        if (peek() == JsonToken.NAME) {\n+            nextName();\n+            pathNames[stackSize - 2] = \"null\";\n+        } else {\n+            popStack();\n+            if (stackSize > 0) {\n+                pathNames[stackSize - 1] = \"null\";\n+            }\n+        }\n+        if (stackSize > 0) {\n+            pathIndices[stackSize - 1]++;\n+        }\n+    }\n \n-  public void promoteNameToValue() throws IOException {\n-    expect(JsonToken.NAME);\n-    Iterator<?> i = (Iterator<?>) peekStack();\n-    Map.Entry<?, ?> entry = (Map.Entry<?, ?>) i.next();\n-    push(entry.getValue());\n-    push(new JsonPrimitive((String) entry.getKey()));\n-  }\n+    @Override\n+    public String toString() {\n+        return getClass().getSimpleName();\n+    }\n \n-  private void push(Object newTop) {\n-    if (stackSize == stack.length) {\n-      int newLength = stackSize * 2;\n-      stack = Arrays.copyOf(stack, newLength);\n-      pathIndices = Arrays.copyOf(pathIndices, newLength);\n-      pathNames = Arrays.copyOf(pathNames, newLength);\n+    public void promoteNameToValue() throws IOException {\n+        expect(JsonToken.NAME);\n+        Iterator<?> i = (Iterator<?>) peekStack();\n+        Map.Entry<?, ?> entry = (Map.Entry<?, ?>) i.next();\n+        push(entry.getValue());\n+        push(new JsonPrimitive((String) entry.getKey()));\n     }\n-    stack[stackSize++] = newTop;\n-  }\n \n-  @Override public String getPath() {\n-    StringBuilder result = new StringBuilder().append('$');\n-    for (int i = 0; i < stackSize; i++) {\n-      if (stack[i] instanceof JsonArray) {\n-        if (stack[++i] instanceof Iterator) {\n-          result.append('[').append(pathIndices[i]).append(']');\n+    private void push(Object newTop) {\n+        if (stackSize == stack.length) {\n+            int newLength = stackSize * 2;\n+            stack = Arrays.copyOf(stack, newLength);\n+            pathIndices = Arrays.copyOf(pathIndices, newLength);\n+            pathNames = Arrays.copyOf(pathNames, newLength);\n         }\n-      } else if (stack[i] instanceof JsonObject) {\n-        if (stack[++i] instanceof Iterator) {\n-          result.append('.');\n-          if (pathNames[i] != null) {\n-            result.append(pathNames[i]);\n-          }\n+        stack[stackSize++] = newTop;\n+    }\n+\n+    @Override\n+    public String getPath() {\n+        StringBuilder result = new StringBuilder().append('$');\n+        for (int i = 0; i < stackSize; i++) {\n+            if (stack[i] instanceof JsonArray) {\n+                if (stack[++i] instanceof Iterator) {\n+                    result.append('[').append(pathIndices[i]).append(']');\n+                }\n+            } else if (stack[i] instanceof JsonObject) {\n+                if (stack[++i] instanceof Iterator) {\n+                    result.append('.');\n+                    if (pathNames[i] != null) {\n+                        result.append(pathNames[i]);\n+                    }\n+                }\n+            }\n         }\n-      }\n+        return result.toString();\n     }\n-    return result.toString();\n-  }\n \n-  private String locationString() {\n-    return \" at path \" + getPath();\n-  }\n+    private String locationString() {\n+        return \" at path \" + getPath();\n+    }\n }\n",
            "diff_size": 348
        },
        {
            "tool": "naturalize",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/errored/1/43/JsonTreeReader.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/naturalize/43/JsonTreeReader.java\nindex a223754aedd..a4434a07f9d 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/errored/1/43/JsonTreeReader.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/naturalize/43/JsonTreeReader.java\n@@ -36,14 +36,14 @@ import java.util.Arrays;\n  * @author Jesse Wilson\n  */\n public final class JsonTreeReader extends JsonReader {\n-  private static final Reader UNREADABLE_READER = new Reader() {\n+    private static final Reader UNREADABLE_READER = new Reader() {\n     @Override public int read(char[] buffer, int offset, int count) throws IOException {\n-      throw new AssertionError();\n+    throw new AssertionError();\n     }\n     @Override public void close() throws IOException {\n-      throw new AssertionError();\n+    throw new AssertionError();\n     }\n-  };\n+    };\n   private static final Object SENTINEL_CLOSED = new Object();\n \n   /*\n@@ -66,103 +66,102 @@ public final class JsonTreeReader extends JsonReader {\n   public JsonTreeReader(JsonElement element) {\n     super(UNREADABLE_READER);\n     push(element);\n-  }\n+    }\n \n   @Override public void beginArray() throws IOException {\n     expect(JsonToken.BEGIN_ARRAY);\n     JsonArray array = (JsonArray) peekStack();\n     push(array.iterator());\n     pathIndices[stackSize - 1] = 0;\n-  }\n+    }\n \n   @Override public void endArray() throws IOException {\n     expect(JsonToken.END_ARRAY);\n     popStack(); // empty iterator\n     popStack(); // array\n     if (stackSize > 0) {\n-      pathIndices[stackSize - 1]++;\n+    pathIndices[stackSize - 1]++;\n+    }\n     }\n-  }\n \n   @Override public void beginObject() throws IOException {\n     expect(JsonToken.BEGIN_OBJECT);\n     JsonObject object = (JsonObject) peekStack();\n     push(object.entrySet().iterator());\n-  }\n+    }\n \n   @Override public void endObject() throws IOException {\n     expect(JsonToken.END_OBJECT);\n     popStack(); // empty iterator\n     popStack(); // object\n     if (stackSize > 0) {\n-      pathIndices[stackSize - 1]++;\n+    pathIndices[stackSize - 1]++;\n+    }\n     }\n-  }\n \n   @Override public boolean hasNext() throws IOException {\n     JsonToken token = peek();\n     return token != JsonToken.END_OBJECT && token != JsonToken.END_ARRAY;\n-  }\n+    }\n \n   @Override public JsonToken peek() throws IOException {\n     if (stackSize == 0) {\n-      return JsonToken.END_DOCUMENT;\n+    return JsonToken.END_DOCUMENT;\n     }\n \n     Object o = peekStack();\n     if (o instanceof Iterator) {\n-      boolean isObject = stack[stackSize - 2] instanceof JsonObject;\n+    boolean isObject = stack[stackSize - 2] instanceof JsonObject;\n       Iterator<?> iterator = (Iterator<?>) o;\n       if (iterator.hasNext()) {\n-        if (isObject) {\n-          return JsonToken.NAME;\n-        } else {\n-          push(iterator.next());\n+    if (isObject) {\n+    return JsonToken.NAME;\n+    } else {\n+    push(iterator.next());\n           return peek();\n-        }\n-      } else {\n-        return isObject ? JsonToken.END_OBJECT : JsonToken.END_ARRAY;\n-      }\n+    }\n+    } else {\n+    return isObject ? JsonToken.END_OBJECT : JsonToken.END_ARRAY;\n+    }\n     } else if (o instanceof JsonObject) {\n-      return JsonToken.BEGIN_OBJECT;\n+    return JsonToken.BEGIN_OBJECT;\n     } else if (o instanceof JsonArray) {\n-      return JsonToken.BEGIN_ARRAY;\n+    return JsonToken.BEGIN_ARRAY;\n     } else if (o instanceof JsonPrimitive) {\n-      JsonPrimitive primitive = (JsonPrimitive) o;\n+    JsonPrimitive primitive = (JsonPrimitive) o;\n       if (primitive.isString()) {\n-        return JsonToken.STRING;\n-      } else if (primitive.isBoolean()) {\n-        return JsonToken.BOOLEAN;\n-      } else if (primitive.isNumber()) {\n-        return JsonToken.NUMBER;\n-      } else {\n-        throw new AssertionError();\n-      }\n+    return JsonToken.STRING;\n+    } else if (primitive.isBoolean()) {\n+    return JsonToken.BOOLEAN;\n+    } else if (primitive.isNumber()) {\n+    return JsonToken.NUMBER;\n+    } else {\n+    throw new AssertionError();\n+    }\n     } else if (o instanceof JsonNull) {\n-      return JsonToken.NULL;\n+    return JsonToken.NULL;\n     } else if (o == SENTINEL_CLOSED) {\n-      throw new IllegalStateException(\"JsonReader is closed\");\n+    throw new IllegalStateException(\"JsonReader is closed\");\n     } else {\n-      throw new AssertionError();\n+    throw new AssertionError();\n+    }\n     }\n-  }\n \n   private Object peekStack() {\n     return stack[stackSize - 1];\n-  }\n+    }\n \n   private Object popStack() {\n     Object result = stack[--stackSize];\n     stack[stackSize] = null;\n     return result;\n-  }\n+    }\n \n   private void expect(JsonToken expected) throws IOException {\n     if (peek() != expected) {\n-      throw new IllegalStateException(\n-          \"Expected \" + expected + \" but was \" + peek() + locationString());\n+    throw new IllegalStateException(\"Expected \" + expected + \" but was \" + peek() + locationString());\n+    }\n     }\n-  }\n \n   @Override public String nextName() throws IOException {\n     expect(JsonToken.NAME);\n@@ -172,106 +171,103 @@ public final class JsonTreeReader extends JsonReader {\n     pathNames[stackSize - 1] = result;\n     push(entry.getValue());\n     return result;\n-  }\n+    }\n \n   @Override public String nextString() throws IOException {\n     JsonToken token = peek();\n     if (token != JsonToken.STRING && token != JsonToken.NUMBER) {\n-      throw new IllegalStateException(\n-          \"Expected \" + JsonToken.STRING + \" but was \" + token + locationString());\n+    throw new IllegalStateException(\"Expected \" + JsonToken.STRING + \" but was \" + token + locationString());\n     }\n     String result = ((JsonPrimitive) popStack()).getAsString();\n     if (stackSize > 0) {\n-      pathIndices[stackSize - 1]++;\n+    pathIndices[stackSize - 1]++;\n     }\n     return result;\n-  }\n+    }\n \n   @Override public boolean nextBoolean() throws IOException {\n     expect(JsonToken.BOOLEAN);\n     boolean result = ((JsonPrimitive) popStack()).getAsBoolean();\n     if (stackSize > 0) {\n-      pathIndices[stackSize - 1]++;\n+    pathIndices[stackSize - 1]++;\n     }\n     return result;\n-  }\n+    }\n \n   @Override public void nextNull() throws IOException {\n     expect(JsonToken.NULL);\n     popStack();\n     if (stackSize > 0) {\n-      pathIndices[stackSize - 1]++;\n+    pathIndices[stackSize - 1]++;\n+    }\n     }\n-  }\n \n   @Override public double nextDouble() throws IOException {\n     JsonToken token = peek();\n     if (token != JsonToken.NUMBER && token != JsonToken.STRING) {\n-      throw new IllegalStateException(\n-          \"Expected \" + JsonToken.NUMBER + \" but was \" + token + locationString());\n+    throw new IllegalStateException(\"Expected \" + JsonToken.NUMBER + \" but was \" + token + locationString());\n     }\n     double result = ((JsonPrimitive) peekStack()).getAsDouble();\n     if (!isLenient() && (Double.isNaN(result) || Double.isInfinite(result))) {\n-      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + result);\n+    throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + result);\n     }\n     popStack();\n     if (stackSize > 0) {\n-      pathIndices[stackSize - 1]++;\n+    pathIndices[stackSize - 1]++;\n     }\n     return result;\n-  }\n+    }\n \n   @Override public long nextLong() throws IOException {\n     JsonToken token = peek();\n     if (token != JsonToken.NUMBER && token != JsonToken.STRING) {\n-      throw new IllegalStateException(\n-          \"Expected \" + JsonToken.NUMBER + \" but was \" + token + locationString());\n+    throw new IllegalStateException(\"Expected \" + JsonToken.NUMBER + \" but was \" + token + locationString());\n     }\n     long result = ((JsonPrimitive) peekStack()).getAsLong();\n     popStack();\n     if (stackSize > 0) {\n-      pathIndices[stackSize - 1]++;\n+    pathIndices[stackSize - 1]++;\n     }\n     return result;\n-  }\n+    }\n \n   @Override public int nextInt() throws IOException {\n     JsonToken token = peek();\n     if (token != JsonToken.NUMBER && token != JsonToken.STRING) {\n-      throw new IllegalStateException(\n-          \"Expected \" + JsonToken.NUMBER + \" but was \" + token + locationString());\n+    throw new IllegalStateException(\"Expected \" + JsonToken.NUMBER + \" but was \" + token + locationString());\n     }\n     int result = ((JsonPrimitive) peekStack()).getAsInt();\n     popStack();\n     if (stackSize > 0) {\n-      pathIndices[stackSize - 1]++;\n+    pathIndices[stackSize - 1]++;\n     }\n     return result;\n-  }\n+    }\n \n   @Override public void close() throws IOException {\n-    stack = new Object[] { SENTINEL_CLOSED };\n+    stack = new Object[] {\n+    SENTINEL_CLOSED };\n     stackSize = 1;\n-  }\n+    }\n \n   @Override public void skipValue() throws IOException {\n     if (peek() == JsonToken.NAME) {\n-      nextName();\n+    nextName();\n       pathNames[stackSize - 2] = \"null\";\n     } else {\n-      popStack();\n+    popStack();\n       if (stackSize > 0) {\n-        pathNames[stackSize - 1] = \"null\";\n-      }\n+    pathNames[stackSize - 1] = \"null\";\n+    }\n     }\n     if (stackSize > 0) {\n-      pathIndices[stackSize - 1]++;\n+    pathIndices[stackSize - 1]++;\n+    }\n     }\n-  }\n \n   @Override public String toString() {\n     return getClass().getSimpleName();\n-  }\n+    }\n \n   public void promoteNameToValue() throws IOException {\n     expect(JsonToken.NAME);\n@@ -279,38 +275,38 @@ public final class JsonTreeReader extends JsonReader {\n     Map.Entry<?, ?> entry = (Map.Entry<?, ?>) i.next();\n     push(entry.getValue());\n     push(new JsonPrimitive((String) entry.getKey()));\n-  }\n+    }\n \n   private void push(Object newTop) {\n     if (stackSize == stack.length) {\n-      int newLength = stackSize * 2;\n+    int newLength = stackSize * 2;\n       stack = Arrays.copyOf(stack, newLength);\n       pathIndices = Arrays.copyOf(pathIndices, newLength);\n       pathNames = Arrays.copyOf(pathNames, newLength);\n     }\n     stack[stackSize++] = newTop;\n-  }\n+    }\n \n   @Override public String getPath() {\n     StringBuilder result = new StringBuilder().append('$');\n     for (int i = 0; i < stackSize; i++) {\n-      if (stack[i] instanceof JsonArray) {\n-        if (stack[++i] instanceof Iterator) {\n-          result.append('[').append(pathIndices[i]).append(']');\n-        }\n-      } else if (stack[i] instanceof JsonObject) {\n-        if (stack[++i] instanceof Iterator) {\n-          result.append('.');\n+    if (stack[i] instanceof JsonArray) {\n+    if (stack[++i] instanceof Iterator) {\n+    result.append('[').append(pathIndices[i]).append(']');\n+    }\n+    } else if (stack[i] instanceof JsonObject) {\n+    if (stack[++i] instanceof Iterator) {\n+    result.append('.');\n           if (pathNames[i] != null) {\n-            result.append(pathNames[i]);\n-          }\n-        }\n-      }\n+    result.append(pathNames[i]);\n+    }\n+    }\n+    }\n     }\n     return result.toString();\n-  }\n+    }\n \n   private String locationString() {\n     return \" at path \" + getPath();\n-  }\n-}\n+    }\n+    }\n\\ No newline at end of file\n",
            "diff_size": 96
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/errored/1/43/JsonTreeReader.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/codebuff/43/JsonTreeReader.java\nindex a223754aedd..cb68da04e1e 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/errored/1/43/JsonTreeReader.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/codebuff/43/JsonTreeReader.java\n@@ -35,22 +35,26 @@ import java.util.Arrays;\n  *\n  * @author Jesse Wilson\n  */\n+\n public final class JsonTreeReader extends JsonReader {\n-  private static final Reader UNREADABLE_READER = new Reader() {\n-    @Override public int read(char[] buffer, int offset, int count) throws IOException {\n-      throw new AssertionError();\n-    }\n-    @Override public void close() throws IOException {\n-      throw new AssertionError();\n-    }\n-  };\n-  private static final Object SENTINEL_CLOSED = new Object();\n+    private static final Reader UNREADABLE_READER = new Reader() {\n+                                                        @Override\n+                                                        public int read(char[] buffer, int offset, int count) throws IOException {\n+                                                            throw new AssertionError();\n+                                                        }\n+\n+                                                        @Override\n+                                                        public void close() throws IOException {\n+                                                            throw new AssertionError();\n+                                                        }\n+                                                    };\n+    private static final Object SENTINEL_CLOSED = new Object();\n \n   /*\n    * The nesting stack. Using a manual array rather than an ArrayList saves 20%.\n    */\n-  private Object[] stack = new Object[32];\n-  private int stackSize = 0;\n+    private Object[] stack = new Object[32];\n+    private int stackSize = 0;\n \n   /*\n    * The path members. It corresponds directly to stack: At indices where the\n@@ -60,257 +64,277 @@ public final class JsonTreeReader extends JsonReader {\n    * that array. Otherwise the value is undefined, and we take advantage of that\n    * by incrementing pathIndices when doing so isn't useful.\n    */\n-  private String[] pathNames = new String[32];\n-  private int[] pathIndices = new int[32];\n-\n-  public JsonTreeReader(JsonElement element) {\n-    super(UNREADABLE_READER);\n-    push(element);\n-  }\n-\n-  @Override public void beginArray() throws IOException {\n-    expect(JsonToken.BEGIN_ARRAY);\n-    JsonArray array = (JsonArray) peekStack();\n-    push(array.iterator());\n-    pathIndices[stackSize - 1] = 0;\n-  }\n-\n-  @Override public void endArray() throws IOException {\n-    expect(JsonToken.END_ARRAY);\n-    popStack(); // empty iterator\n-    popStack(); // array\n-    if (stackSize > 0) {\n-      pathIndices[stackSize - 1]++;\n+    private String[] pathNames = new String[32];\n+    private int[] pathIndices = new int[32];\n+\n+    public JsonTreeReader(JsonElement element) {\n+        super(UNREADABLE_READER);\n+        push(element);\n+    }\n+\n+    @Override\n+    public void beginArray() throws IOException {\n+        expect(JsonToken.BEGIN_ARRAY);\n+\n+\n+        JsonArray array = (JsonArray) peekStack();\n+        push(array.iterator());\n+        pathIndices[stackSize - 1] = 0;\n     }\n-  }\n-\n-  @Override public void beginObject() throws IOException {\n-    expect(JsonToken.BEGIN_OBJECT);\n-    JsonObject object = (JsonObject) peekStack();\n-    push(object.entrySet().iterator());\n-  }\n-\n-  @Override public void endObject() throws IOException {\n-    expect(JsonToken.END_OBJECT);\n-    popStack(); // empty iterator\n-    popStack(); // object\n-    if (stackSize > 0) {\n-      pathIndices[stackSize - 1]++;\n+\n+    @Override\n+    public void endArray() throws IOException {\n+        expect(JsonToken.END_ARRAY);\n+        popStack(); // empty iterator\n+        popStack(); // array\n+        if (stackSize > 0) {\n+            pathIndices[stackSize - 1]++;\n+        }\n     }\n-  }\n \n-  @Override public boolean hasNext() throws IOException {\n-    JsonToken token = peek();\n-    return token != JsonToken.END_OBJECT && token != JsonToken.END_ARRAY;\n-  }\n+    @Override\n+    public void beginObject() throws IOException {\n+        expect(JsonToken.BEGIN_OBJECT);\n \n-  @Override public JsonToken peek() throws IOException {\n-    if (stackSize == 0) {\n-      return JsonToken.END_DOCUMENT;\n+\n+        JsonObject object = (JsonObject) peekStack();\n+        push(object.entrySet().iterator());\n     }\n \n-    Object o = peekStack();\n-    if (o instanceof Iterator) {\n-      boolean isObject = stack[stackSize - 2] instanceof JsonObject;\n-      Iterator<?> iterator = (Iterator<?>) o;\n-      if (iterator.hasNext()) {\n-        if (isObject) {\n-          return JsonToken.NAME;\n-        } else {\n-          push(iterator.next());\n-          return peek();\n+    @Override\n+    public void endObject() throws IOException {\n+        expect(JsonToken.END_OBJECT);\n+        popStack(); // empty iterator\n+        popStack(); // object\n+        if (stackSize > 0) {\n+            pathIndices[stackSize - 1]++;\n         }\n-      } else {\n-        return isObject ? JsonToken.END_OBJECT : JsonToken.END_ARRAY;\n-      }\n-    } else if (o instanceof JsonObject) {\n-      return JsonToken.BEGIN_OBJECT;\n-    } else if (o instanceof JsonArray) {\n-      return JsonToken.BEGIN_ARRAY;\n-    } else if (o instanceof JsonPrimitive) {\n-      JsonPrimitive primitive = (JsonPrimitive) o;\n-      if (primitive.isString()) {\n-        return JsonToken.STRING;\n-      } else if (primitive.isBoolean()) {\n-        return JsonToken.BOOLEAN;\n-      } else if (primitive.isNumber()) {\n-        return JsonToken.NUMBER;\n-      } else {\n-        throw new AssertionError();\n-      }\n-    } else if (o instanceof JsonNull) {\n-      return JsonToken.NULL;\n-    } else if (o == SENTINEL_CLOSED) {\n-      throw new IllegalStateException(\"JsonReader is closed\");\n-    } else {\n-      throw new AssertionError();\n     }\n-  }\n-\n-  private Object peekStack() {\n-    return stack[stackSize - 1];\n-  }\n-\n-  private Object popStack() {\n-    Object result = stack[--stackSize];\n-    stack[stackSize] = null;\n-    return result;\n-  }\n-\n-  private void expect(JsonToken expected) throws IOException {\n-    if (peek() != expected) {\n-      throw new IllegalStateException(\n-          \"Expected \" + expected + \" but was \" + peek() + locationString());\n+\n+    @Override\n+    public boolean hasNext() throws IOException {\n+        JsonToken token = peek();\n+        return token != JsonToken.END_OBJECT && token != JsonToken.END_ARRAY;\n     }\n-  }\n-\n-  @Override public String nextName() throws IOException {\n-    expect(JsonToken.NAME);\n-    Iterator<?> i = (Iterator<?>) peekStack();\n-    Map.Entry<?, ?> entry = (Map.Entry<?, ?>) i.next();\n-    String result = (String) entry.getKey();\n-    pathNames[stackSize - 1] = result;\n-    push(entry.getValue());\n-    return result;\n-  }\n-\n-  @Override public String nextString() throws IOException {\n-    JsonToken token = peek();\n-    if (token != JsonToken.STRING && token != JsonToken.NUMBER) {\n-      throw new IllegalStateException(\n-          \"Expected \" + JsonToken.STRING + \" but was \" + token + locationString());\n+\n+    @Override\n+    public JsonToken peek() throws IOException {\n+        if (stackSize == 0) {\n+            return JsonToken.END_DOCUMENT;\n+        }\n+        Object o = peekStack();\n+        if (o instanceof Iterator) {\n+            boolean isObject = stack[stackSize - 2] instanceof JsonObject;\n+            Iterator<?> iterator = (Iterator<?>) o;\n+            if (iterator.hasNext()) {\n+                if (isObject) {\n+                    return JsonToken.NAME;\n+                } else {\n+                    push(iterator.next());\n+                    return peek();\n+                }\n+            } else {\n+                return isObject ? JsonToken.END_OBJECT : JsonToken.END_ARRAY;\n+            }\n+        } else if (o instanceof JsonObject) {\n+            return JsonToken.BEGIN_OBJECT;\n+        } else if (o instanceof JsonArray) {\n+                   return JsonToken.BEGIN_ARRAY;\n+               } else if (o instanceof JsonPrimitive) {\n+                   JsonPrimitive primitive = (JsonPrimitive) o;\n+                   if (primitive.isString()) {\n+                       return JsonToken.STRING;\n+                   } else if (primitive.isBoolean()) {\n+                       return JsonToken.BOOLEAN;\n+                   } else if (primitive.isNumber()) {\n+                              return JsonToken.NUMBER;\n+                          } else {\n+                       throw new AssertionError();\n+                   }\n+               } else if (o instanceof JsonNull) {\n+                          return JsonToken.NULL;\n+                      } else if (o == SENTINEL_CLOSED) {\n+            throw new IllegalStateException(\"JsonReader is closed\");\n+                      } else {\n+                          throw new AssertionError();\n+                      }\n     }\n-    String result = ((JsonPrimitive) popStack()).getAsString();\n-    if (stackSize > 0) {\n-      pathIndices[stackSize - 1]++;\n+\n+    private Object peekStack() {\n+        return stack[stackSize - 1];\n     }\n-    return result;\n-  }\n-\n-  @Override public boolean nextBoolean() throws IOException {\n-    expect(JsonToken.BOOLEAN);\n-    boolean result = ((JsonPrimitive) popStack()).getAsBoolean();\n-    if (stackSize > 0) {\n-      pathIndices[stackSize - 1]++;\n+\n+    private Object popStack() {\n+        Object result = stack[--stackSize];\n+        stack[stackSize] = null;\n+        return result;\n     }\n-    return result;\n-  }\n-\n-  @Override public void nextNull() throws IOException {\n-    expect(JsonToken.NULL);\n-    popStack();\n-    if (stackSize > 0) {\n-      pathIndices[stackSize - 1]++;\n+\n+    private void expect(JsonToken expected) throws IOException {\n+        if (peek() != expected) {\n+            throw new IllegalStateException(\"Expected \" + expected + \" but was \" + peek() + locationString());\n+        }\n     }\n-  }\n \n-  @Override public double nextDouble() throws IOException {\n-    JsonToken token = peek();\n-    if (token != JsonToken.NUMBER && token != JsonToken.STRING) {\n-      throw new IllegalStateException(\n-          \"Expected \" + JsonToken.NUMBER + \" but was \" + token + locationString());\n+    @Override\n+    public String nextName() throws IOException {\n+        expect(JsonToken.NAME);\n+\n+\n+        Iterator<?> i = (Iterator<?>) peekStack();\n+        Map.Entry<?, ?> entry = (Map.Entry<?, ?>) i.next();\n+        String result = (String) entry.getKey();\n+        pathNames[stackSize - 1] = result;\n+        push(entry.getValue());\n+        return result;\n+    }\n+\n+    @Override\n+    public String nextString() throws IOException {\n+        JsonToken token = peek();\n+        if (token != JsonToken.STRING && token != JsonToken.NUMBER) {\n+            throw new IllegalStateException(\"Expected \" + JsonToken.STRING + \" but was \" + token + locationString());\n+        }\n+        String result = ((JsonPrimitive) popStack()).getAsString();\n+        if (stackSize > 0) {\n+            pathIndices[stackSize - 1]++;\n+        }\n+        return result;\n     }\n-    double result = ((JsonPrimitive) peekStack()).getAsDouble();\n-    if (!isLenient() && (Double.isNaN(result) || Double.isInfinite(result))) {\n-      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + result);\n+\n+    @Override\n+    public boolean nextBoolean() throws IOException {\n+        expect(JsonToken.BOOLEAN);\n+        boolean result = ((JsonPrimitive) popStack()).getAsBoolean();\n+        if (stackSize > 0) {\n+            pathIndices[stackSize - 1]++;\n+        }\n+        return result;\n     }\n-    popStack();\n-    if (stackSize > 0) {\n-      pathIndices[stackSize - 1]++;\n+\n+    @Override\n+    public void nextNull() throws IOException {\n+        expect(JsonToken.NULL);\n+        popStack();\n+        if (stackSize > 0) {\n+            pathIndices[stackSize - 1]++;\n+        }\n     }\n-    return result;\n-  }\n-\n-  @Override public long nextLong() throws IOException {\n-    JsonToken token = peek();\n-    if (token != JsonToken.NUMBER && token != JsonToken.STRING) {\n-      throw new IllegalStateException(\n-          \"Expected \" + JsonToken.NUMBER + \" but was \" + token + locationString());\n+\n+    @Override\n+    public double nextDouble() throws IOException {\n+        JsonToken token = peek();\n+        if (token != JsonToken.NUMBER && token != JsonToken.STRING) {\n+            throw new IllegalStateException(\"Expected \" + JsonToken.NUMBER + \" but was \" + token + locationString());\n+        }\n+        double result = ((JsonPrimitive) peekStack()).getAsDouble();\n+        if (!isLenient() && (Double.isNaN(result) || Double.isInfinite(result))) {\n+            throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + result);\n+        }\n+        popStack();\n+        if (stackSize > 0) {\n+            pathIndices[stackSize - 1]++;\n+        }\n+        return result;\n     }\n-    long result = ((JsonPrimitive) peekStack()).getAsLong();\n-    popStack();\n-    if (stackSize > 0) {\n-      pathIndices[stackSize - 1]++;\n+\n+    @Override\n+    public long nextLong() throws IOException {\n+        JsonToken token = peek();\n+        if (token != JsonToken.NUMBER && token != JsonToken.STRING) {\n+            throw new IllegalStateException(\"Expected \" + JsonToken.NUMBER + \" but was \" + token + locationString());\n+        }\n+        long result = ((JsonPrimitive) peekStack()).getAsLong();\n+        popStack();\n+        if (stackSize > 0) {\n+            pathIndices[stackSize - 1]++;\n+        }\n+        return result;\n     }\n-    return result;\n-  }\n-\n-  @Override public int nextInt() throws IOException {\n-    JsonToken token = peek();\n-    if (token != JsonToken.NUMBER && token != JsonToken.STRING) {\n-      throw new IllegalStateException(\n-          \"Expected \" + JsonToken.NUMBER + \" but was \" + token + locationString());\n+\n+    @Override\n+    public int nextInt() throws IOException {\n+        JsonToken token = peek();\n+        if (token != JsonToken.NUMBER && token != JsonToken.STRING) {\n+            throw new IllegalStateException(\"Expected \" + JsonToken.NUMBER + \" but was \" + token + locationString());\n+        }\n+\n+        int result = ((JsonPrimitive) peekStack()).getAsInt();\n+        popStack();\n+        if (stackSize > 0) {\n+            pathIndices[stackSize - 1]++;\n+        }\n+        return result;\n     }\n-    int result = ((JsonPrimitive) peekStack()).getAsInt();\n-    popStack();\n-    if (stackSize > 0) {\n-      pathIndices[stackSize - 1]++;\n+\n+    @Override\n+    public void close() throws IOException {\n+        stack = new Object[]{SENTINEL_CLOSED};\n+        stackSize = 1;\n     }\n-    return result;\n-  }\n-\n-  @Override public void close() throws IOException {\n-    stack = new Object[] { SENTINEL_CLOSED };\n-    stackSize = 1;\n-  }\n-\n-  @Override public void skipValue() throws IOException {\n-    if (peek() == JsonToken.NAME) {\n-      nextName();\n-      pathNames[stackSize - 2] = \"null\";\n-    } else {\n-      popStack();\n-      if (stackSize > 0) {\n-        pathNames[stackSize - 1] = \"null\";\n-      }\n+\n+    @Override\n+    public void skipValue() throws IOException {\n+        if (peek() == JsonToken.NAME) {\n+            nextName();\n+            pathNames[stackSize - 2] = \"null\";\n+        } else {\n+            popStack();\n+            if (stackSize > 0) {\n+                pathNames[stackSize - 1] = \"null\";\n+            }\n+        }\n+        if (stackSize > 0) {\n+            pathIndices[stackSize - 1]++;\n+        }\n     }\n-    if (stackSize > 0) {\n-      pathIndices[stackSize - 1]++;\n+\n+    @Override\n+    public String toString() {\n+        return getClass().getSimpleName();\n     }\n-  }\n-\n-  @Override public String toString() {\n-    return getClass().getSimpleName();\n-  }\n-\n-  public void promoteNameToValue() throws IOException {\n-    expect(JsonToken.NAME);\n-    Iterator<?> i = (Iterator<?>) peekStack();\n-    Map.Entry<?, ?> entry = (Map.Entry<?, ?>) i.next();\n-    push(entry.getValue());\n-    push(new JsonPrimitive((String) entry.getKey()));\n-  }\n-\n-  private void push(Object newTop) {\n-    if (stackSize == stack.length) {\n-      int newLength = stackSize * 2;\n-      stack = Arrays.copyOf(stack, newLength);\n-      pathIndices = Arrays.copyOf(pathIndices, newLength);\n-      pathNames = Arrays.copyOf(pathNames, newLength);\n+\n+    public void promoteNameToValue() throws IOException {\n+        expect(JsonToken.NAME);\n+\n+\n+        Iterator<?> i = (Iterator<?>) peekStack();\n+        Map.Entry<?, ?> entry = (Map.Entry<?, ?>) i.next();\n+        push(entry.getValue());\n+        push(new JsonPrimitive((String) entry.getKey()));\n     }\n-    stack[stackSize++] = newTop;\n-  }\n-\n-  @Override public String getPath() {\n-    StringBuilder result = new StringBuilder().append('$');\n-    for (int i = 0; i < stackSize; i++) {\n-      if (stack[i] instanceof JsonArray) {\n-        if (stack[++i] instanceof Iterator) {\n-          result.append('[').append(pathIndices[i]).append(']');\n+\n+    private void push(Object newTop) {\n+        if (stackSize == stack.length) {\n+            int newLength = stackSize * 2;\n+            stack = Arrays.copyOf(stack, newLength);\n+            pathIndices = Arrays.copyOf(pathIndices, newLength);\n+            pathNames = Arrays.copyOf(pathNames, newLength);\n         }\n-      } else if (stack[i] instanceof JsonObject) {\n-        if (stack[++i] instanceof Iterator) {\n-          result.append('.');\n-          if (pathNames[i] != null) {\n-            result.append(pathNames[i]);\n-          }\n+        stack[stackSize++] = newTop;\n+    }\n+\n+    @Override\n+    public String getPath() {\n+        StringBuilder result = new StringBuilder().append('$');\n+        for (int i = 0; i < stackSize; i++) {\n+            if (stack[i] instanceof JsonArray) {\n+                if (stack[++i] instanceof Iterator) {\n+                    result.append('[').append(pathIndices[i]).append(']');\n+                }\n+            } else if (stack[i] instanceof JsonObject) {\n+                       if (stack[++i] instanceof Iterator) {\n+                           result.append('.');\n+                           if (pathNames[i] != null) {\n+                               result.append(pathNames[i]);\n+                           }\n+                       }\n+            }\n         }\n-      }\n+        return result.toString();\n     }\n-    return result.toString();\n-  }\n \n-  private String locationString() {\n-    return \" at path \" + getPath();\n-  }\n-}\n+    private String locationString() {\n+        return \" at path \" + getPath();\n+    }\n+}\n\\ No newline at end of file\n",
            "diff_size": 335
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/errored/1/43/JsonTreeReader.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/styler_random/43/JsonTreeReader.java\nindex a223754aedd..59c3282bcfd 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/errored/1/43/JsonTreeReader.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/styler_random/43/JsonTreeReader.java\n@@ -250,7 +250,7 @@ public final class JsonTreeReader extends JsonReader {\n   }\n \n   @Override public void close() throws IOException {\n-    stack = new Object[] { SENTINEL_CLOSED };\n+    stack = new Object[] {SENTINEL_CLOSED };\n     stackSize = 1;\n   }\n \n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/errored/1/43/JsonTreeReader.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/styler_three_grams/43/JsonTreeReader.java\nindex a223754aedd..d65742e0217 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/errored/1/43/JsonTreeReader.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/styler_three_grams/43/JsonTreeReader.java\n@@ -250,7 +250,7 @@ public final class JsonTreeReader extends JsonReader {\n   }\n \n   @Override public void close() throws IOException {\n-    stack = new Object[] { SENTINEL_CLOSED };\n+    stack = new Object[]{SENTINEL_CLOSED };\n     stackSize = 1;\n   }\n \n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": []
}