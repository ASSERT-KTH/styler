{
    "project_name": "h2database-h2database",
    "error_id": "137",
    "information": {
        "errors": [
            {
                "line": "441",
                "column": "67",
                "severity": "warning",
                "message": "Don't use trailing comments.",
                "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
            }
        ]
    },
    "source_code": "            writeLong(ts.getTimeNanos());\n            int timeZoneOffset = ts.getTimeZoneOffsetSeconds();\n            writeInt(version >= Constants.TCP_PROTOCOL_VERSION_19 //\n                    ? timeZoneOffset : timeZoneOffset / 60);\n            break;\n        }",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/errored/1/137/Transfer.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/styler/137/Transfer.java\nindex efa6250f90c..d0af3059de6 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/errored/1/137/Transfer.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/styler/137/Transfer.java\n@@ -438,8 +438,9 @@ public class Transfer {\n             writeLong(ts.getDateValue());\n             writeLong(ts.getTimeNanos());\n             int timeZoneOffset = ts.getTimeZoneOffsetSeconds();\n-            writeInt(version >= Constants.TCP_PROTOCOL_VERSION_19 //\n-                    ? timeZoneOffset : timeZoneOffset / 60);\n+            writeInt(version >= Constants.TCP_PROTOCOL_VERSION_19\n+                //\n+                     ? timeZoneOffset : timeZoneOffset / 60);\n             break;\n         }\n         case Value.NUMERIC:\n",
            "diff_size": 3
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "447",
                    "column": "71",
                    "severity": "warning",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/errored/1/137/Transfer.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/intellij/137/Transfer.java\nindex efa6250f90c..6b3256e581d 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/errored/1/137/Transfer.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/intellij/137/Transfer.java\n@@ -3,6 +3,7 @@\n  * and the EPL 1.0 (https://h2database.com/html/license.html).\n  * Initial Developer: H2 Group\n  */\n+\n package org.h2.value;\n \n import java.io.BufferedInputStream;\n@@ -84,7 +85,7 @@ public class Transfer {\n      * Create a new transfer object for the specified session.\n      *\n      * @param session the session\n-     * @param s the socket\n+     * @param s       the socket\n      */\n     public Transfer(SessionInterface session, Socket s) {\n         this.session = session;\n@@ -288,11 +289,12 @@ public class Transfer {\n      * Write a number of bytes.\n      *\n      * @param buff the value\n-     * @param off the offset\n-     * @param len the length\n+     * @param off  the offset\n+     * @param len  the length\n      * @return itself\n      */\n-    public Transfer writeBytes(byte[] buff, int off, int len) throws IOException {\n+    public Transfer writeBytes(byte[] buff, int off, int len)\n+            throws IOException {\n         out.write(buff, off, len);\n         return this;\n     }\n@@ -316,8 +318,8 @@ public class Transfer {\n      * Read a number of bytes.\n      *\n      * @param buff the target buffer\n-     * @param off the offset\n-     * @param len the number of bytes to read\n+     * @param off  the offset\n+     * @param len  the number of bytes to read\n      */\n     public void readBytes(byte[] buff, int off, int len) throws IOException {\n         in.readFully(buff, off, len);\n@@ -350,7 +352,8 @@ public class Transfer {\n      * @return itself\n      */\n     public Transfer writeTypeInfo(TypeInfo type) throws IOException {\n-        return writeInt(type.getValueType()).writeLong(type.getPrecision()).writeInt(type.getScale());\n+        return writeInt(type.getValueType()).writeLong(type.getPrecision())\n+                .writeInt(type.getScale());\n     }\n \n     /**\n@@ -370,274 +373,283 @@ public class Transfer {\n     public void writeValue(Value v) throws IOException {\n         int type = v.getValueType();\n         switch (type) {\n-        case Value.NULL:\n-            writeInt(NULL);\n-            break;\n-        case Value.VARBINARY:\n-            writeInt(VARBINARY);\n-            writeBytes(v.getBytesNoCopy());\n-            break;\n-        case Value.JAVA_OBJECT:\n-            writeInt(JAVA_OBJECT);\n-            writeBytes(v.getBytesNoCopy());\n-            break;\n-        case Value.UUID: {\n-            writeInt(UUID);\n-            ValueUuid uuid = (ValueUuid) v;\n-            writeLong(uuid.getHigh());\n-            writeLong(uuid.getLow());\n-            break;\n-        }\n-        case Value.BOOLEAN:\n-            writeInt(BOOLEAN);\n-            writeBoolean(v.getBoolean());\n-            break;\n-        case Value.TINYINT:\n-            writeInt(TINYINT);\n-            writeByte(v.getByte());\n-            break;\n-        case Value.TIME:\n-            writeInt(TIME);\n-            writeLong(((ValueTime) v).getNanos());\n-            break;\n-        case Value.TIME_TZ: {\n-            ValueTimeTimeZone t = (ValueTimeTimeZone) v;\n-            if (version >= Constants.TCP_PROTOCOL_VERSION_19) {\n-                writeInt(TIME_TZ);\n-                writeLong(t.getNanos());\n-                writeInt(t.getTimeZoneOffsetSeconds());\n-            } else {\n-                writeInt(TIME);\n-                /*\n-                 * Don't call SessionRemote.currentTimestamp(), it may require\n-                 * own remote call and old server will not return custom time\n-                 * zone anyway.\n-                 */\n-                ValueTimestampTimeZone current = session.isRemote()\n-                        ? DateTimeUtils.currentTimestamp(DateTimeUtils.getTimeZone()) : session.currentTimestamp();\n-                writeLong(DateTimeUtils.normalizeNanosOfDay(t.getNanos() +\n-                        (t.getTimeZoneOffsetSeconds() - current.getTimeZoneOffsetSeconds())\n-                        * DateTimeUtils.NANOS_PER_DAY));\n-            }\n-            break;\n-        }\n-        case Value.DATE:\n-            writeInt(DATE);\n-            writeLong(((ValueDate) v).getDateValue());\n-            break;\n-        case Value.TIMESTAMP: {\n-            writeInt(TIMESTAMP);\n-            ValueTimestamp ts = (ValueTimestamp) v;\n-            writeLong(ts.getDateValue());\n-            writeLong(ts.getTimeNanos());\n-            break;\n-        }\n-        case Value.TIMESTAMP_TZ: {\n-            writeInt(TIMESTAMP_TZ);\n-            ValueTimestampTimeZone ts = (ValueTimestampTimeZone) v;\n-            writeLong(ts.getDateValue());\n-            writeLong(ts.getTimeNanos());\n-            int timeZoneOffset = ts.getTimeZoneOffsetSeconds();\n-            writeInt(version >= Constants.TCP_PROTOCOL_VERSION_19 //\n-                    ? timeZoneOffset : timeZoneOffset / 60);\n-            break;\n-        }\n-        case Value.NUMERIC:\n-            writeInt(NUMERIC);\n-            writeString(v.getString());\n-            break;\n-        case Value.DOUBLE:\n-            writeInt(DOUBLE);\n-            writeDouble(v.getDouble());\n-            break;\n-        case Value.REAL:\n-            writeInt(REAL);\n-            writeFloat(v.getFloat());\n-            break;\n-        case Value.INTEGER:\n-            writeInt(INTEGER);\n-            writeInt(v.getInt());\n-            break;\n-        case Value.BIGINT:\n-            writeInt(BIGINT);\n-            writeLong(v.getLong());\n-            break;\n-        case Value.SMALLINT:\n-            writeInt(SMALLINT);\n-            writeInt(v.getShort());\n-            break;\n-        case Value.VARCHAR:\n-            writeInt(VARCHAR);\n-            writeString(v.getString());\n-            break;\n-        case Value.VARCHAR_IGNORECASE:\n-            writeInt(VARCHAR_IGNORECASE);\n-            writeString(v.getString());\n-            break;\n-        case Value.CHAR:\n-            writeInt(CHAR);\n-            writeString(v.getString());\n-            break;\n-        case Value.BLOB: {\n-            writeInt(BLOB);\n-            ValueLob lob = (ValueLob) v;\n-            if (lob.isStored()) {\n-                writeLong(-1);\n-                writeInt(lob.getTableId());\n-                writeLong(lob.getLobId());\n-                writeBytes(calculateLobMac(lob.getLobId()));\n-                writeLong(lob.getType().getPrecision());\n+            case Value.NULL:\n+                writeInt(NULL);\n+                break;\n+            case Value.VARBINARY:\n+                writeInt(VARBINARY);\n+                writeBytes(v.getBytesNoCopy());\n+                break;\n+            case Value.JAVA_OBJECT:\n+                writeInt(JAVA_OBJECT);\n+                writeBytes(v.getBytesNoCopy());\n+                break;\n+            case Value.UUID: {\n+                writeInt(UUID);\n+                ValueUuid uuid = (ValueUuid) v;\n+                writeLong(uuid.getHigh());\n+                writeLong(uuid.getLow());\n                 break;\n             }\n-            long length = v.getType().getPrecision();\n-            if (length < 0) {\n-                throw DbException.get(\n-                        ErrorCode.CONNECTION_BROKEN_1, \"length=\" + length);\n-            }\n-            writeLong(length);\n-            long written = IOUtils.copyAndCloseInput(v.getInputStream(), out);\n-            if (written != length) {\n-                throw DbException.get(\n-                        ErrorCode.CONNECTION_BROKEN_1, \"length:\" + length + \" written:\" + written);\n+            case Value.BOOLEAN:\n+                writeInt(BOOLEAN);\n+                writeBoolean(v.getBoolean());\n+                break;\n+            case Value.TINYINT:\n+                writeInt(TINYINT);\n+                writeByte(v.getByte());\n+                break;\n+            case Value.TIME:\n+                writeInt(TIME);\n+                writeLong(((ValueTime) v).getNanos());\n+                break;\n+            case Value.TIME_TZ: {\n+                ValueTimeTimeZone t = (ValueTimeTimeZone) v;\n+                if (version >= Constants.TCP_PROTOCOL_VERSION_19) {\n+                    writeInt(TIME_TZ);\n+                    writeLong(t.getNanos());\n+                    writeInt(t.getTimeZoneOffsetSeconds());\n+                } else {\n+                    writeInt(TIME);\n+                    /*\n+                     * Don't call SessionRemote.currentTimestamp(), it may require\n+                     * own remote call and old server will not return custom time\n+                     * zone anyway.\n+                     */\n+                    ValueTimestampTimeZone current = session.isRemote()\n+                            ? DateTimeUtils\n+                            .currentTimestamp(DateTimeUtils.getTimeZone()) :\n+                            session.currentTimestamp();\n+                    writeLong(DateTimeUtils.normalizeNanosOfDay(t.getNanos() +\n+                            (t.getTimeZoneOffsetSeconds() -\n+                                    current.getTimeZoneOffsetSeconds())\n+                                    * DateTimeUtils.NANOS_PER_DAY));\n+                }\n+                break;\n             }\n-            writeInt(LOB_MAGIC);\n-            break;\n-        }\n-        case Value.CLOB: {\n-            writeInt(CLOB);\n-            ValueLob lob = (ValueLob) v;\n-            if (lob.isStored()) {\n-                writeLong(-1);\n-                writeInt(lob.getTableId());\n-                writeLong(lob.getLobId());\n-                writeBytes(calculateLobMac(lob.getLobId()));\n-                writeLong(lob.getType().getPrecision());\n+            case Value.DATE:\n+                writeInt(DATE);\n+                writeLong(((ValueDate) v).getDateValue());\n+                break;\n+            case Value.TIMESTAMP: {\n+                writeInt(TIMESTAMP);\n+                ValueTimestamp ts = (ValueTimestamp) v;\n+                writeLong(ts.getDateValue());\n+                writeLong(ts.getTimeNanos());\n                 break;\n             }\n-            long length = v.getType().getPrecision();\n-            if (length < 0) {\n-                throw DbException.get(\n-                        ErrorCode.CONNECTION_BROKEN_1, \"length=\" + length);\n+            case Value.TIMESTAMP_TZ: {\n+                writeInt(TIMESTAMP_TZ);\n+                ValueTimestampTimeZone ts = (ValueTimestampTimeZone) v;\n+                writeLong(ts.getDateValue());\n+                writeLong(ts.getTimeNanos());\n+                int timeZoneOffset = ts.getTimeZoneOffsetSeconds();\n+                writeInt(version >= Constants.TCP_PROTOCOL_VERSION_19 //\n+                        ? timeZoneOffset : timeZoneOffset / 60);\n+                break;\n             }\n-            writeLong(length);\n-            Reader reader = v.getReader();\n-            Data.copyString(reader, out);\n-            writeInt(LOB_MAGIC);\n-            break;\n-        }\n-        case Value.ARRAY: {\n-            writeInt(ARRAY);\n-            ValueArray va = (ValueArray) v;\n-            Value[] list = va.getList();\n-            int len = list.length;\n-            writeInt(len);\n-            for (Value value : list) {\n-                writeValue(value);\n+            case Value.NUMERIC:\n+                writeInt(NUMERIC);\n+                writeString(v.getString());\n+                break;\n+            case Value.DOUBLE:\n+                writeInt(DOUBLE);\n+                writeDouble(v.getDouble());\n+                break;\n+            case Value.REAL:\n+                writeInt(REAL);\n+                writeFloat(v.getFloat());\n+                break;\n+            case Value.INTEGER:\n+                writeInt(INTEGER);\n+                writeInt(v.getInt());\n+                break;\n+            case Value.BIGINT:\n+                writeInt(BIGINT);\n+                writeLong(v.getLong());\n+                break;\n+            case Value.SMALLINT:\n+                writeInt(SMALLINT);\n+                writeInt(v.getShort());\n+                break;\n+            case Value.VARCHAR:\n+                writeInt(VARCHAR);\n+                writeString(v.getString());\n+                break;\n+            case Value.VARCHAR_IGNORECASE:\n+                writeInt(VARCHAR_IGNORECASE);\n+                writeString(v.getString());\n+                break;\n+            case Value.CHAR:\n+                writeInt(CHAR);\n+                writeString(v.getString());\n+                break;\n+            case Value.BLOB: {\n+                writeInt(BLOB);\n+                ValueLob lob = (ValueLob) v;\n+                if (lob.isStored()) {\n+                    writeLong(-1);\n+                    writeInt(lob.getTableId());\n+                    writeLong(lob.getLobId());\n+                    writeBytes(calculateLobMac(lob.getLobId()));\n+                    writeLong(lob.getType().getPrecision());\n+                    break;\n+                }\n+                long length = v.getType().getPrecision();\n+                if (length < 0) {\n+                    throw DbException.get(\n+                            ErrorCode.CONNECTION_BROKEN_1, \"length=\" + length);\n+                }\n+                writeLong(length);\n+                long written =\n+                        IOUtils.copyAndCloseInput(v.getInputStream(), out);\n+                if (written != length) {\n+                    throw DbException.get(\n+                            ErrorCode.CONNECTION_BROKEN_1,\n+                            \"length:\" + length + \" written:\" + written);\n+                }\n+                writeInt(LOB_MAGIC);\n+                break;\n             }\n-            break;\n-        }\n-        case Value.ROW: {\n-            writeInt(version >= Constants.TCP_PROTOCOL_VERSION_18 ? ROW : ARRAY);\n-            ValueRow va = (ValueRow) v;\n-            Value[] list = va.getList();\n-            int len = list.length;\n-            writeInt(len);\n-            for (Value value : list) {\n-                writeValue(value);\n+            case Value.CLOB: {\n+                writeInt(CLOB);\n+                ValueLob lob = (ValueLob) v;\n+                if (lob.isStored()) {\n+                    writeLong(-1);\n+                    writeInt(lob.getTableId());\n+                    writeLong(lob.getLobId());\n+                    writeBytes(calculateLobMac(lob.getLobId()));\n+                    writeLong(lob.getType().getPrecision());\n+                    break;\n+                }\n+                long length = v.getType().getPrecision();\n+                if (length < 0) {\n+                    throw DbException.get(\n+                            ErrorCode.CONNECTION_BROKEN_1, \"length=\" + length);\n+                }\n+                writeLong(length);\n+                Reader reader = v.getReader();\n+                Data.copyString(reader, out);\n+                writeInt(LOB_MAGIC);\n+                break;\n             }\n-            break;\n-        }\n-        case Value.ENUM: {\n-            writeInt(ENUM);\n-            writeInt(v.getInt());\n-            writeString(v.getString());\n-            break;\n-        }\n-        case Value.RESULT_SET: {\n-            writeInt(RESULT_SET);\n-            ResultInterface result = ((ValueResultSet) v).getResult();\n-            int columnCount = result.getVisibleColumnCount();\n-            writeInt(columnCount);\n-            for (int i = 0; i < columnCount; i++) {\n-                TypeInfo columnType = result.getColumnType(i);\n-                if (version >= Constants.TCP_PROTOCOL_VERSION_18) {\n-                    writeString(result.getAlias(i));\n-                    writeString(result.getColumnName(i));\n-                    writeTypeInfo(columnType);\n-                } else {\n-                    writeString(result.getColumnName(i));\n-                    writeInt(DataType.getDataType(columnType.getValueType()).sqlType);\n-                    writeInt(MathUtils.convertLongToInt(columnType.getPrecision()));\n-                    writeInt(columnType.getScale());\n+            case Value.ARRAY: {\n+                writeInt(ARRAY);\n+                ValueArray va = (ValueArray) v;\n+                Value[] list = va.getList();\n+                int len = list.length;\n+                writeInt(len);\n+                for (Value value : list) {\n+                    writeValue(value);\n                 }\n+                break;\n             }\n-            while (result.next()) {\n-                writeBoolean(true);\n-                Value[] row = result.currentRow();\n-                for (int i = 0; i < columnCount; i++) {\n-                    writeValue(row[i]);\n+            case Value.ROW: {\n+                writeInt(version >= Constants.TCP_PROTOCOL_VERSION_18 ? ROW :\n+                        ARRAY);\n+                ValueRow va = (ValueRow) v;\n+                Value[] list = va.getList();\n+                int len = list.length;\n+                writeInt(len);\n+                for (Value value : list) {\n+                    writeValue(value);\n                 }\n+                break;\n             }\n-            writeBoolean(false);\n-            break;\n-        }\n-        case Value.GEOMETRY:\n-            writeInt(GEOMETRY);\n-            if (version >= Constants.TCP_PROTOCOL_VERSION_14) {\n-                writeBytes(v.getBytesNoCopy());\n-            } else {\n+            case Value.ENUM: {\n+                writeInt(ENUM);\n+                writeInt(v.getInt());\n                 writeString(v.getString());\n+                break;\n             }\n-            break;\n-        case Value.INTERVAL_YEAR:\n-        case Value.INTERVAL_MONTH:\n-        case Value.INTERVAL_DAY:\n-        case Value.INTERVAL_HOUR:\n-        case Value.INTERVAL_MINUTE:\n-            if (version >= Constants.TCP_PROTOCOL_VERSION_18) {\n-                ValueInterval interval = (ValueInterval) v;\n-                int ordinal = type - Value.INTERVAL_YEAR;\n-                if (interval.isNegative()) {\n-                    ordinal = ~ordinal;\n+            case Value.RESULT_SET: {\n+                writeInt(RESULT_SET);\n+                ResultInterface result = ((ValueResultSet) v).getResult();\n+                int columnCount = result.getVisibleColumnCount();\n+                writeInt(columnCount);\n+                for (int i = 0; i < columnCount; i++) {\n+                    TypeInfo columnType = result.getColumnType(i);\n+                    if (version >= Constants.TCP_PROTOCOL_VERSION_18) {\n+                        writeString(result.getAlias(i));\n+                        writeString(result.getColumnName(i));\n+                        writeTypeInfo(columnType);\n+                    } else {\n+                        writeString(result.getColumnName(i));\n+                        writeInt(DataType.getDataType(\n+                                columnType.getValueType()).sqlType);\n+                        writeInt(MathUtils\n+                                .convertLongToInt(columnType.getPrecision()));\n+                        writeInt(columnType.getScale());\n+                    }\n                 }\n-                writeInt(INTERVAL);\n-                writeByte((byte) ordinal);\n-                writeLong(interval.getLeading());\n-            } else {\n-                writeInt(VARCHAR);\n-                writeString(v.getString());\n+                while (result.next()) {\n+                    writeBoolean(true);\n+                    Value[] row = result.currentRow();\n+                    for (int i = 0; i < columnCount; i++) {\n+                        writeValue(row[i]);\n+                    }\n+                }\n+                writeBoolean(false);\n+                break;\n             }\n-            break;\n-        case Value.INTERVAL_SECOND:\n-        case Value.INTERVAL_YEAR_TO_MONTH:\n-        case Value.INTERVAL_DAY_TO_HOUR:\n-        case Value.INTERVAL_DAY_TO_MINUTE:\n-        case Value.INTERVAL_DAY_TO_SECOND:\n-        case Value.INTERVAL_HOUR_TO_MINUTE:\n-        case Value.INTERVAL_HOUR_TO_SECOND:\n-        case Value.INTERVAL_MINUTE_TO_SECOND:\n-            if (version >= Constants.TCP_PROTOCOL_VERSION_18) {\n-                ValueInterval interval = (ValueInterval) v;\n-                int ordinal = type - Value.INTERVAL_YEAR;\n-                if (interval.isNegative()) {\n-                    ordinal = ~ordinal;\n+            case Value.GEOMETRY:\n+                writeInt(GEOMETRY);\n+                if (version >= Constants.TCP_PROTOCOL_VERSION_14) {\n+                    writeBytes(v.getBytesNoCopy());\n+                } else {\n+                    writeString(v.getString());\n                 }\n-                writeInt(INTERVAL);\n-                writeByte((byte) ordinal);\n-                writeLong(interval.getLeading());\n-                writeLong(interval.getRemaining());\n-            } else {\n-                writeInt(VARCHAR);\n-                writeString(v.getString());\n+                break;\n+            case Value.INTERVAL_YEAR:\n+            case Value.INTERVAL_MONTH:\n+            case Value.INTERVAL_DAY:\n+            case Value.INTERVAL_HOUR:\n+            case Value.INTERVAL_MINUTE:\n+                if (version >= Constants.TCP_PROTOCOL_VERSION_18) {\n+                    ValueInterval interval = (ValueInterval) v;\n+                    int ordinal = type - Value.INTERVAL_YEAR;\n+                    if (interval.isNegative()) {\n+                        ordinal = ~ordinal;\n+                    }\n+                    writeInt(INTERVAL);\n+                    writeByte((byte) ordinal);\n+                    writeLong(interval.getLeading());\n+                } else {\n+                    writeInt(VARCHAR);\n+                    writeString(v.getString());\n+                }\n+                break;\n+            case Value.INTERVAL_SECOND:\n+            case Value.INTERVAL_YEAR_TO_MONTH:\n+            case Value.INTERVAL_DAY_TO_HOUR:\n+            case Value.INTERVAL_DAY_TO_MINUTE:\n+            case Value.INTERVAL_DAY_TO_SECOND:\n+            case Value.INTERVAL_HOUR_TO_MINUTE:\n+            case Value.INTERVAL_HOUR_TO_SECOND:\n+            case Value.INTERVAL_MINUTE_TO_SECOND:\n+                if (version >= Constants.TCP_PROTOCOL_VERSION_18) {\n+                    ValueInterval interval = (ValueInterval) v;\n+                    int ordinal = type - Value.INTERVAL_YEAR;\n+                    if (interval.isNegative()) {\n+                        ordinal = ~ordinal;\n+                    }\n+                    writeInt(INTERVAL);\n+                    writeByte((byte) ordinal);\n+                    writeLong(interval.getLeading());\n+                    writeLong(interval.getRemaining());\n+                } else {\n+                    writeInt(VARCHAR);\n+                    writeString(v.getString());\n+                }\n+                break;\n+            case Value.JSON: {\n+                writeInt(JSON);\n+                writeBytes(v.getBytesNoCopy());\n+                break;\n             }\n-            break;\n-        case Value.JSON: {\n-            writeInt(JSON);\n-            writeBytes(v.getBytesNoCopy());\n-            break;\n-        }\n-        default:\n-            throw DbException.get(ErrorCode.CONNECTION_BROKEN_1, \"type=\" + type);\n+            default:\n+                throw DbException\n+                        .get(ErrorCode.CONNECTION_BROKEN_1, \"type=\" + type);\n         }\n     }\n \n@@ -649,154 +661,167 @@ public class Transfer {\n     public Value readValue() throws IOException {\n         int type = readInt();\n         switch (type) {\n-        case NULL:\n-            return ValueNull.INSTANCE;\n-        case VARBINARY:\n-            return ValueVarbinary.getNoCopy(readBytes());\n-        case UUID:\n-            return ValueUuid.get(readLong(), readLong());\n-        case JAVA_OBJECT:\n-            return ValueJavaObject.getNoCopy(null, readBytes(), session.getDataHandler());\n-        case BOOLEAN:\n-            return ValueBoolean.get(readBoolean());\n-        case TINYINT:\n-            return ValueTinyint.get(readByte());\n-        case DATE:\n-            return ValueDate.fromDateValue(readLong());\n-        case TIME:\n-            return ValueTime.fromNanos(readLong());\n-        case TIME_TZ:\n-            return ValueTimeTimeZone.fromNanos(readLong(), readInt());\n-        case TIMESTAMP:\n-            return ValueTimestamp.fromDateValueAndNanos(readLong(), readLong());\n-        case TIMESTAMP_TZ: {\n-            long dateValue = readLong(), timeNanos = readLong();\n-            int timeZoneOffset = readInt();\n-            return ValueTimestampTimeZone.fromDateValueAndNanos(dateValue, timeNanos,\n-                    version >= Constants.TCP_PROTOCOL_VERSION_19 ? timeZoneOffset : timeZoneOffset * 60);\n-        }\n-        case NUMERIC:\n-            return ValueNumeric.get(new BigDecimal(readString()));\n-        case DOUBLE:\n-            return ValueDouble.get(readDouble());\n-        case REAL:\n-            return ValueReal.get(readFloat());\n-        case ENUM: {\n-            final int ordinal = readInt();\n-            final String label = readString();\n-            return ValueEnumBase.get(label, ordinal);\n-        }\n-        case INTEGER:\n-            return ValueInteger.get(readInt());\n-        case BIGINT:\n-            return ValueBigint.get(readLong());\n-        case SMALLINT:\n-            return ValueSmallint.get((short) readInt());\n-        case VARCHAR:\n-            return ValueVarchar.get(readString());\n-        case VARCHAR_IGNORECASE:\n-            return ValueVarcharIgnoreCase.get(readString());\n-        case CHAR:\n-            return ValueChar.get(readString());\n-        case BLOB: {\n-            long length = readLong();\n-            if (length == -1) {\n-                int tableId = readInt();\n-                long id = readLong();\n-                byte[] hmac = readBytes();\n-                long precision = readLong();\n-                return ValueLob.create(Value.BLOB, session.getDataHandler(), tableId, id, hmac, precision);\n+            case NULL:\n+                return ValueNull.INSTANCE;\n+            case VARBINARY:\n+                return ValueVarbinary.getNoCopy(readBytes());\n+            case UUID:\n+                return ValueUuid.get(readLong(), readLong());\n+            case JAVA_OBJECT:\n+                return ValueJavaObject\n+                        .getNoCopy(null, readBytes(), session.getDataHandler());\n+            case BOOLEAN:\n+                return ValueBoolean.get(readBoolean());\n+            case TINYINT:\n+                return ValueTinyint.get(readByte());\n+            case DATE:\n+                return ValueDate.fromDateValue(readLong());\n+            case TIME:\n+                return ValueTime.fromNanos(readLong());\n+            case TIME_TZ:\n+                return ValueTimeTimeZone.fromNanos(readLong(), readInt());\n+            case TIMESTAMP:\n+                return ValueTimestamp\n+                        .fromDateValueAndNanos(readLong(), readLong());\n+            case TIMESTAMP_TZ: {\n+                long dateValue = readLong(), timeNanos = readLong();\n+                int timeZoneOffset = readInt();\n+                return ValueTimestampTimeZone\n+                        .fromDateValueAndNanos(dateValue, timeNanos,\n+                                version >= Constants.TCP_PROTOCOL_VERSION_19 ?\n+                                        timeZoneOffset : timeZoneOffset * 60);\n             }\n-            Value v = session.getDataHandler().getLobStorage().createBlob(in, length);\n-            int magic = readInt();\n-            if (magic != LOB_MAGIC) {\n-                throw DbException.get(\n-                        ErrorCode.CONNECTION_BROKEN_1, \"magic=\" + magic);\n-            }\n-            return v;\n-        }\n-        case CLOB: {\n-            long length = readLong();\n-            if (length == -1) {\n-                int tableId = readInt();\n-                long id = readLong();\n-                byte[] hmac = readBytes();\n-                long precision = readLong();\n-                return ValueLob.create(Value.CLOB, session.getDataHandler(), tableId, id, hmac, precision);\n+            case NUMERIC:\n+                return ValueNumeric.get(new BigDecimal(readString()));\n+            case DOUBLE:\n+                return ValueDouble.get(readDouble());\n+            case REAL:\n+                return ValueReal.get(readFloat());\n+            case ENUM: {\n+                final int ordinal = readInt();\n+                final String label = readString();\n+                return ValueEnumBase.get(label, ordinal);\n             }\n-            if (length < 0) {\n-                throw DbException.get(\n-                        ErrorCode.CONNECTION_BROKEN_1, \"length=\"+ length);\n-            }\n-            Value v = session.getDataHandler().getLobStorage().\n-                    createClob(new DataReader(in), length);\n-            int magic = readInt();\n-            if (magic != LOB_MAGIC) {\n-                throw DbException.get(\n-                        ErrorCode.CONNECTION_BROKEN_1, \"magic=\" + magic);\n-            }\n-            return v;\n-        }\n-        case ARRAY: {\n-            int len = readInt();\n-            if (len < 0) {\n-                // Unlikely, but possible with H2 1.4.200 and older versions\n-                len = ~len;\n-                readString();\n+            case INTEGER:\n+                return ValueInteger.get(readInt());\n+            case BIGINT:\n+                return ValueBigint.get(readLong());\n+            case SMALLINT:\n+                return ValueSmallint.get((short) readInt());\n+            case VARCHAR:\n+                return ValueVarchar.get(readString());\n+            case VARCHAR_IGNORECASE:\n+                return ValueVarcharIgnoreCase.get(readString());\n+            case CHAR:\n+                return ValueChar.get(readString());\n+            case BLOB: {\n+                long length = readLong();\n+                if (length == -1) {\n+                    int tableId = readInt();\n+                    long id = readLong();\n+                    byte[] hmac = readBytes();\n+                    long precision = readLong();\n+                    return ValueLob.create(Value.BLOB, session.getDataHandler(),\n+                            tableId, id, hmac, precision);\n+                }\n+                Value v = session.getDataHandler().getLobStorage()\n+                        .createBlob(in, length);\n+                int magic = readInt();\n+                if (magic != LOB_MAGIC) {\n+                    throw DbException.get(\n+                            ErrorCode.CONNECTION_BROKEN_1, \"magic=\" + magic);\n+                }\n+                return v;\n             }\n-            Value[] list = new Value[len];\n-            for (int i = 0; i < len; i++) {\n-                list[i] = readValue();\n+            case CLOB: {\n+                long length = readLong();\n+                if (length == -1) {\n+                    int tableId = readInt();\n+                    long id = readLong();\n+                    byte[] hmac = readBytes();\n+                    long precision = readLong();\n+                    return ValueLob.create(Value.CLOB, session.getDataHandler(),\n+                            tableId, id, hmac, precision);\n+                }\n+                if (length < 0) {\n+                    throw DbException.get(\n+                            ErrorCode.CONNECTION_BROKEN_1, \"length=\" + length);\n+                }\n+                Value v = session.getDataHandler().getLobStorage().\n+                        createClob(new DataReader(in), length);\n+                int magic = readInt();\n+                if (magic != LOB_MAGIC) {\n+                    throw DbException.get(\n+                            ErrorCode.CONNECTION_BROKEN_1, \"magic=\" + magic);\n+                }\n+                return v;\n             }\n-            return ValueArray.get(list);\n-        }\n-        case ROW: {\n-            int len = readInt();\n-            Value[] list = new Value[len];\n-            for (int i = 0; i < len; i++) {\n-                list[i] = readValue();\n+            case ARRAY: {\n+                int len = readInt();\n+                if (len < 0) {\n+                    // Unlikely, but possible with H2 1.4.200 and older versions\n+                    len = ~len;\n+                    readString();\n+                }\n+                Value[] list = new Value[len];\n+                for (int i = 0; i < len; i++) {\n+                    list[i] = readValue();\n+                }\n+                return ValueArray.get(list);\n             }\n-            return ValueRow.get(list);\n-        }\n-        case RESULT_SET: {\n-            SimpleResult rs = new SimpleResult();\n-            int columns = readInt();\n-            for (int i = 0; i < columns; i++) {\n-                if (version >= Constants.TCP_PROTOCOL_VERSION_18) {\n-                    rs.addColumn(readString(), readString(), readTypeInfo());\n-                } else {\n-                    String name = readString();\n-                    rs.addColumn(name, name, DataType.convertSQLTypeToValueType(readInt()), readInt(), readInt());\n+            case ROW: {\n+                int len = readInt();\n+                Value[] list = new Value[len];\n+                for (int i = 0; i < len; i++) {\n+                    list[i] = readValue();\n                 }\n+                return ValueRow.get(list);\n             }\n-            while (readBoolean()) {\n-                Value[] o = new Value[columns];\n+            case RESULT_SET: {\n+                SimpleResult rs = new SimpleResult();\n+                int columns = readInt();\n                 for (int i = 0; i < columns; i++) {\n-                    o[i] = readValue();\n+                    if (version >= Constants.TCP_PROTOCOL_VERSION_18) {\n+                        rs.addColumn(readString(), readString(),\n+                                readTypeInfo());\n+                    } else {\n+                        String name = readString();\n+                        rs.addColumn(name, name,\n+                                DataType.convertSQLTypeToValueType(readInt()),\n+                                readInt(), readInt());\n+                    }\n                 }\n-                rs.addRow(o);\n-            }\n-            return ValueResultSet.get(rs);\n-        }\n-        case GEOMETRY:\n-            if (version >= Constants.TCP_PROTOCOL_VERSION_14) {\n-                return ValueGeometry.get(readBytes());\n+                while (readBoolean()) {\n+                    Value[] o = new Value[columns];\n+                    for (int i = 0; i < columns; i++) {\n+                        o[i] = readValue();\n+                    }\n+                    rs.addRow(o);\n+                }\n+                return ValueResultSet.get(rs);\n             }\n-            return ValueGeometry.get(readString());\n-        case INTERVAL: {\n-            int ordinal = readByte();\n-            boolean negative = ordinal < 0;\n-            if (negative) {\n-                ordinal = ~ordinal;\n+            case GEOMETRY:\n+                if (version >= Constants.TCP_PROTOCOL_VERSION_14) {\n+                    return ValueGeometry.get(readBytes());\n+                }\n+                return ValueGeometry.get(readString());\n+            case INTERVAL: {\n+                int ordinal = readByte();\n+                boolean negative = ordinal < 0;\n+                if (negative) {\n+                    ordinal = ~ordinal;\n+                }\n+                return ValueInterval\n+                        .from(IntervalQualifier.valueOf(ordinal), negative,\n+                                readLong(),\n+                                ordinal < 5 ? 0 : readLong());\n             }\n-            return ValueInterval.from(IntervalQualifier.valueOf(ordinal), negative, readLong(),\n-                    ordinal < 5 ? 0 : readLong());\n-        }\n-        case JSON:\n-            // Do not trust the value\n-            return ValueJson.fromJson(readBytes());\n-        default:\n-            throw DbException.get(ErrorCode.CONNECTION_BROKEN_1, \"type=\" + type);\n+            case JSON:\n+                // Do not trust the value\n+                return ValueJson.fromJson(readBytes());\n+            default:\n+                throw DbException\n+                        .get(ErrorCode.CONNECTION_BROKEN_1, \"type=\" + type);\n         }\n     }\n \n@@ -852,13 +877,13 @@ public class Transfer {\n     /**\n      * Verify the HMAC.\n      *\n-     * @param hmac the message authentication code\n+     * @param hmac  the message authentication code\n      * @param lobId the lobId\n      * @throws DbException if the HMAC does not match\n      */\n     public void verifyLobMac(byte[] hmac, long lobId) {\n         byte[] result = calculateLobMac(lobId);\n-        if (!Utils.compareSecure(hmac,  result)) {\n+        if (!Utils.compareSecure(hmac, result)) {\n             throw DbException.get(ErrorCode.CONNECTION_BROKEN_1,\n                     \"Invalid lob hmac; possibly the connection was re-opened internally\");\n         }\n",
            "diff_size": 601
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "441",
                    "column": "66",
                    "severity": "warning",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/errored/1/137/Transfer.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/styler_random/137/Transfer.java\nindex efa6250f90c..438882855df 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/errored/1/137/Transfer.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/styler_random/137/Transfer.java\n@@ -438,7 +438,7 @@ public class Transfer {\n             writeLong(ts.getDateValue());\n             writeLong(ts.getTimeNanos());\n             int timeZoneOffset = ts.getTimeZoneOffsetSeconds();\n-            writeInt(version >= Constants.TCP_PROTOCOL_VERSION_19 //\n+            writeInt(version >= Constants.TCP_PROTOCOL_VERSION_19//\n                     ? timeZoneOffset : timeZoneOffset / 60);\n             break;\n         }\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/errored/1/137/Transfer.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/styler_three_grams/137/Transfer.java\nindex efa6250f90c..d0af3059de6 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/errored/1/137/Transfer.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/styler_three_grams/137/Transfer.java\n@@ -438,8 +438,9 @@ public class Transfer {\n             writeLong(ts.getDateValue());\n             writeLong(ts.getTimeNanos());\n             int timeZoneOffset = ts.getTimeZoneOffsetSeconds();\n-            writeInt(version >= Constants.TCP_PROTOCOL_VERSION_19 //\n-                    ? timeZoneOffset : timeZoneOffset / 60);\n+            writeInt(version >= Constants.TCP_PROTOCOL_VERSION_19\n+                //\n+                     ? timeZoneOffset : timeZoneOffset / 60);\n             break;\n         }\n         case Value.NUMERIC:\n",
            "diff_size": 3
        }
    ],
    "repaired_by": [
        "styler",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random"
    ]
}