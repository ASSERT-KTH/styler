{
    "project_name": "NationalSecurityAgency-datawave",
    "error_id": "81",
    "information": {
        "errors": [
            {
                "line": "88",
                "severity": "error",
                "message": "Accumulo non-public classes imported",
                "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
            }
        ]
    },
    "source_code": "import org.apache.accumulo.core.client.AccumuloClient;\nimport org.apache.accumulo.core.security.Authorizations;\nimport org.apache.accumulo.core.util.Pair;\nimport org.apache.commons.jexl2.parser.TokenMgrError;\nimport org.apache.deltaspike.core.api.exclude.Exclude;\nimport org.apache.htrace.Trace;",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "88",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "88",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/81/QueryExecutorBean.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/intellij/81/QueryExecutorBean.java\nindex 12bd8260ba2..c4dc0d40aa6 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/81/QueryExecutorBean.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/intellij/81/QueryExecutorBean.java\n@@ -166,3406 +166,3464 @@ import static datawave.webservice.query.cache.QueryTraceCache.CacheListener;\n import static datawave.webservice.query.cache.QueryTraceCache.PatternWrapper;\n \n @Path(\"/Query\")\n-@RolesAllowed({\"AuthorizedUser\", \"AuthorizedQueryServer\", \"PrivilegedUser\", \"InternalUser\", \"Administrator\", \"JBossAdministrator\"})\n-@DeclareRoles({\"AuthorizedUser\", \"AuthorizedQueryServer\", \"PrivilegedUser\", \"InternalUser\", \"Administrator\", \"JBossAdministrator\"})\n+@RolesAllowed({\"AuthorizedUser\", \"AuthorizedQueryServer\", \"PrivilegedUser\", \"InternalUser\", \"Administrator\",\n+    \"JBossAdministrator\"})\n+@DeclareRoles({\"AuthorizedUser\", \"AuthorizedQueryServer\", \"PrivilegedUser\", \"InternalUser\", \"Administrator\",\n+    \"JBossAdministrator\"})\n @Stateless\n @LocalBean\n @TransactionAttribute(TransactionAttributeType.NOT_SUPPORTED)\n @TransactionManagement(TransactionManagementType.BEAN)\n @Exclude(ifProjectStage = DatawaveEmbeddedProjectStageHolder.DatawaveEmbedded.class)\n public class QueryExecutorBean implements QueryExecutor {\n-    \n-    private static final String PRIVILEGED_USER = \"PrivilegedUser\";\n-    \n-    /**\n-     * Used when getting a plan prior to creating a query\n-     */\n-    public static final String EXPAND_VALUES = \"expand.values\";\n-    public static final String EXPAND_FIELDS = \"expand.fields\";\n-    \n-    private final Logger log = Logger.getLogger(QueryExecutorBean.class);\n-    \n-    @Inject\n-    private QueryCache queryCache;\n-    \n-    @Inject\n-    private QueryTraceCache queryTraceCache;\n-    \n-    @Inject\n-    private AccumuloConnectionFactory connectionFactory;\n-    \n-    @Inject\n-    private AuditBean auditor;\n-    \n-    @Inject\n-    private QueryMetricsBean metrics;\n-    \n-    @Resource\n-    private ManagedExecutorService executor;\n-    \n-    @Inject\n-    private QueryLogicFactory queryLogicFactory;\n-    \n-    @Inject\n-    private QueryExpirationConfiguration queryExpirationConf;\n-    \n-    @Inject\n-    private Persister persister;\n-    \n-    @Resource\n-    private EJBContext ctx;\n-    \n-    @Resource\n-    private SessionContext sessionContext;\n-    \n-    @Inject\n-    @SpringBean(refreshable = true)\n-    private LookupUUIDConfiguration lookupUUIDConfiguration;\n-    \n-    @Inject\n-    private SecurityMarking marking;\n-    \n-    @Inject\n-    private ResponseObjectFactory responseObjectFactory;\n-    \n-    private LookupUUIDUtil lookupUUIDUtil;\n-    \n-    @Inject\n-    private CreatedQueryLogicCacheBean qlCache;\n-    \n-    @Inject\n-    private QueryPredictor predictor;\n-    \n-    @Inject\n-    private QueryMetricFactory metricFactory;\n-    \n-    @Inject\n-    private AccumuloConnectionRequestBean accumuloConnectionRequestBean;\n-    \n-    private Multimap<String,PatternWrapper> traceInfos;\n-    private CacheListener traceCacheListener;\n-    \n-    @Inject\n-    private ClosedQueryCache closedQueryCache;\n-    \n-    private final int PAGE_TIMEOUT_MIN = 1;\n-    private final int PAGE_TIMEOUT_MAX = QueryExpirationConfiguration.PAGE_TIMEOUT_MIN_DEFAULT;\n-    \n-    @Inject\n-    private QueryParameters qp;\n-    \n-    // A few items that are cached by the validateQuery call\n-    private static class QueryData {\n-        QueryLogic<?> logic = null;\n-        Principal p = null;\n-        Set<String> proxyServers = null;\n-        String userDn = null;\n-        String userid = null;\n-        List<String> dnList = null;\n-    }\n-    \n-    @PostConstruct\n-    public void init() {\n-        \n-        Multimap<String,PatternWrapper> infos = HashMultimap.create();\n-        traceInfos = queryTraceCache.putIfAbsent(\"traceInfos\", infos);\n-        if (traceInfos == null)\n-            traceInfos = infos;\n-        traceCacheListener = (key, traceInfo) -> {\n-            if (\"traceInfos\".equals(key)) {\n-                traceInfos = traceInfo;\n-            }\n-        };\n-        queryTraceCache.addListener(traceCacheListener);\n-        \n-        this.lookupUUIDUtil = new LookupUUIDUtil(this.lookupUUIDConfiguration, this, this.ctx, this.responseObjectFactory);\n-    }\n-    \n-    @PreDestroy\n-    public void close() {\n-        if (queryTraceCache != null && traceCacheListener != null)\n-            queryTraceCache.removeListener(traceCacheListener);\n-    }\n-    \n-    /**\n-     * List QueryLogic types that are currently available\n-     *\n-     * @HTTP 200 Success\n-     * @return datawave.webservice.result.QueryLogicResponse\n-     * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user, by specifying a chain of DNs of the identities to proxy\n-     * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n-     * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n-     */\n-    @Path(\"/listQueryLogic\")\n-    @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\", \"text/html\"})\n-    @GET\n-    @Interceptors({ResponseInterceptor.class})\n-    @Override\n-    @Timed(name = \"dw.query.listQueryLogic\", absolute = true)\n-    public QueryLogicResponse listQueryLogic() {\n-        QueryLogicResponse response = new QueryLogicResponse();\n-        List<QueryLogic<?>> logicList = queryLogicFactory.getQueryLogicList();\n-        List<QueryLogicDescription> logicConfigurationList = new ArrayList<>();\n-        \n-        // reference query necessary to avoid NPEs in getting the Transformer and BaseResponse\n-        Query q = new QueryImpl();\n-        Date now = new Date();\n-        q.setExpirationDate(now);\n-        q.setQuery(\"test\");\n-        q.setQueryAuthorizations(\"ALL\");\n-        ResultsPage emptyList = new ResultsPage();\n-        \n-        for (QueryLogic<?> l : logicList) {\n-            try {\n-                QueryLogicDescription d = new QueryLogicDescription(l.getLogicName());\n-                d.setAuditType(l.getAuditType(null).toString());\n-                d.setLogicDescription(l.getLogicDescription());\n-                \n-                Set<String> optionalQueryParameters = l.getOptionalQueryParameters();\n-                if (optionalQueryParameters != null) {\n-                    d.setSupportedParams(new ArrayList<>(optionalQueryParameters));\n-                }\n-                Set<String> requiredQueryParameters = l.getRequiredQueryParameters();\n-                if (requiredQueryParameters != null) {\n-                    d.setRequiredParams(new ArrayList<>(requiredQueryParameters));\n-                }\n-                Set<String> exampleQueries = l.getExampleQueries();\n-                if (exampleQueries != null) {\n-                    d.setExampleQueries(new ArrayList<>(exampleQueries));\n-                }\n-                Set<String> requiredRoles = l.getRoleManager().getRequiredRoles();\n-                if (requiredRoles != null) {\n-                    List<String> requiredRolesList = new ArrayList<>();\n-                    requiredRolesList.addAll(l.getRoleManager().getRequiredRoles());\n-                    d.setRequiredRoles(requiredRolesList);\n-                }\n-                \n-                try {\n-                    d.setResponseClass(l.getResponseClass(q));\n-                } catch (QueryException e) {\n-                    log.error(e, e);\n-                    response.addException(e);\n-                    d.setResponseClass(\"unknown\");\n-                }\n-                \n-                List<String> querySyntax = new ArrayList<>();\n-                try {\n-                    Method m = l.getClass().getMethod(\"getQuerySyntaxParsers\");\n-                    Object result = m.invoke(l);\n-                    if (result instanceof Map<?,?>) {\n-                        Map<?,?> map = (Map<?,?>) result;\n-                        for (Object o : map.keySet())\n-                            querySyntax.add(o.toString());\n-                    }\n-                } catch (Exception e) {\n-                    log.warn(\"Unable to get query syntax for query logic: \" + l.getClass().getCanonicalName());\n-                }\n-                if (querySyntax.isEmpty()) {\n-                    querySyntax.add(\"CUSTOM\");\n-                }\n-                d.setQuerySyntax(querySyntax);\n-                \n-                logicConfigurationList.add(d);\n-            } catch (Exception e) {\n-                log.error(\"Error setting query logic description\", e);\n-            }\n-        }\n-        Collections.sort(logicConfigurationList, Comparator.comparing(QueryLogicDescription::getName));\n-        response.setQueryLogicList(logicConfigurationList);\n-        \n-        return response;\n-    }\n-    \n-    @Override\n-    @Interceptors({RequiredInterceptor.class, ResponseInterceptor.class})\n-    public GenericResponse<String> defineQuery(@Required(\"logicName\") String queryLogicName, MultivaluedMap<String,String> queryParameters) {\n-        return defineQuery(queryLogicName, queryParameters, null);\n-    }\n-    \n-    /**\n-     * Helper to throw Response Error for create/define Query\n-     */\n-    private void throwBadRequest(DatawaveErrorCode ec, GenericResponse<String> response) {\n-        BadRequestQueryException qe = new BadRequestQueryException(ec);\n-        response.addException(qe);\n-        throw new BadRequestException(qe, response);\n+\n+  private static final String PRIVILEGED_USER = \"PrivilegedUser\";\n+\n+  /**\n+   * Used when getting a plan prior to creating a query\n+   */\n+  public static final String EXPAND_VALUES = \"expand.values\";\n+  public static final String EXPAND_FIELDS = \"expand.fields\";\n+\n+  private final Logger log = Logger.getLogger(QueryExecutorBean.class);\n+\n+  @Inject\n+  private QueryCache queryCache;\n+\n+  @Inject\n+  private QueryTraceCache queryTraceCache;\n+\n+  @Inject\n+  private AccumuloConnectionFactory connectionFactory;\n+\n+  @Inject\n+  private AuditBean auditor;\n+\n+  @Inject\n+  private QueryMetricsBean metrics;\n+\n+  @Resource\n+  private ManagedExecutorService executor;\n+\n+  @Inject\n+  private QueryLogicFactory queryLogicFactory;\n+\n+  @Inject\n+  private QueryExpirationConfiguration queryExpirationConf;\n+\n+  @Inject\n+  private Persister persister;\n+\n+  @Resource\n+  private EJBContext ctx;\n+\n+  @Resource\n+  private SessionContext sessionContext;\n+\n+  @Inject\n+  @SpringBean(refreshable = true)\n+  private LookupUUIDConfiguration lookupUUIDConfiguration;\n+\n+  @Inject\n+  private SecurityMarking marking;\n+\n+  @Inject\n+  private ResponseObjectFactory responseObjectFactory;\n+\n+  private LookupUUIDUtil lookupUUIDUtil;\n+\n+  @Inject\n+  private CreatedQueryLogicCacheBean qlCache;\n+\n+  @Inject\n+  private QueryPredictor predictor;\n+\n+  @Inject\n+  private QueryMetricFactory metricFactory;\n+\n+  @Inject\n+  private AccumuloConnectionRequestBean accumuloConnectionRequestBean;\n+\n+  private Multimap<String, PatternWrapper> traceInfos;\n+  private CacheListener traceCacheListener;\n+\n+  @Inject\n+  private ClosedQueryCache closedQueryCache;\n+\n+  private final int PAGE_TIMEOUT_MIN = 1;\n+  private final int PAGE_TIMEOUT_MAX = QueryExpirationConfiguration.PAGE_TIMEOUT_MIN_DEFAULT;\n+\n+  @Inject\n+  private QueryParameters qp;\n+\n+  // A few items that are cached by the validateQuery call\n+  private static class QueryData {\n+    QueryLogic<?> logic = null;\n+    Principal p = null;\n+    Set<String> proxyServers = null;\n+    String userDn = null;\n+    String userid = null;\n+    List<String> dnList = null;\n+  }\n+\n+  @PostConstruct\n+  public void init() {\n+\n+    Multimap<String, PatternWrapper> infos = HashMultimap.create();\n+    traceInfos = queryTraceCache.putIfAbsent(\"traceInfos\", infos);\n+    if (traceInfos == null) {\n+      traceInfos = infos;\n+    }\n+    traceCacheListener = (key, traceInfo) -> {\n+      if (\"traceInfos\".equals(key)) {\n+        traceInfos = traceInfo;\n+      }\n+    };\n+    queryTraceCache.addListener(traceCacheListener);\n+\n+    this.lookupUUIDUtil = new LookupUUIDUtil(this.lookupUUIDConfiguration, this, this.ctx, this.responseObjectFactory);\n+  }\n+\n+  @PreDestroy\n+  public void close() {\n+    if (queryTraceCache != null && traceCacheListener != null) {\n+      queryTraceCache.removeListener(traceCacheListener);\n     }\n-    \n-    /**\n-     * This method will provide some initial query validation for the define and create query calls.\n-     */\n-    private QueryData validateQuery(String queryLogicName, MultivaluedMap<String,String> queryParameters, HttpHeaders httpHeaders) {\n-        \n-        // Parameter 'logicName' is required and passed in prior to this call. Add to the queryParameters now.\n-        if (!queryParameters.containsKey(QueryParameters.QUERY_LOGIC_NAME)) {\n-            queryParameters.putSingle(QueryParameters.QUERY_LOGIC_NAME, queryLogicName);\n-        }\n-        \n-        QueryData qd = new QueryData();\n-        \n-        log.debug(queryParameters);\n-        qp.clear();\n-        qp.setRequestHeaders(httpHeaders != null ? httpHeaders.getRequestHeaders() : null);\n-        \n-        // Pull \"params\" values into individual query parameters for validation on the query logic.\n-        // This supports the deprecated \"params\" value (both on the old and new API). Once we remove the deprecated\n-        // parameter, this code block can go away.\n-        String params = queryParameters.getFirst(QueryParameters.QUERY_PARAMS);\n-        if (params != null) {\n-            for (Parameter pm : QueryUtil.parseParameters(params)) {\n-                if (!queryParameters.containsKey(pm.getParameterName())) {\n-                    queryParameters.putSingle(pm.getParameterName(), pm.getParameterValue());\n-                }\n-            }\n+  }\n+\n+  /**\n+   * List QueryLogic types that are currently available\n+   *\n+   * @return datawave.webservice.result.QueryLogicResponse\n+   * @HTTP 200 Success\n+   * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user, by specifying a chain of DNs of the identities to proxy\n+   * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n+   * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n+   */\n+  @Path(\"/listQueryLogic\")\n+  @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\",\n+      \"text/html\"})\n+  @GET\n+  @Interceptors({ResponseInterceptor.class})\n+  @Override\n+  @Timed(name = \"dw.query.listQueryLogic\", absolute = true)\n+  public QueryLogicResponse listQueryLogic() {\n+    QueryLogicResponse response = new QueryLogicResponse();\n+    List<QueryLogic<?>> logicList = queryLogicFactory.getQueryLogicList();\n+    List<QueryLogicDescription> logicConfigurationList = new ArrayList<>();\n+\n+    // reference query necessary to avoid NPEs in getting the Transformer and BaseResponse\n+    Query q = new QueryImpl();\n+    Date now = new Date();\n+    q.setExpirationDate(now);\n+    q.setQuery(\"test\");\n+    q.setQueryAuthorizations(\"ALL\");\n+    ResultsPage emptyList = new ResultsPage();\n+\n+    for (QueryLogic<?> l : logicList) {\n+      try {\n+        QueryLogicDescription d = new QueryLogicDescription(l.getLogicName());\n+        d.setAuditType(l.getAuditType(null).toString());\n+        d.setLogicDescription(l.getLogicDescription());\n+\n+        Set<String> optionalQueryParameters = l.getOptionalQueryParameters();\n+        if (optionalQueryParameters != null) {\n+          d.setSupportedParams(new ArrayList<>(optionalQueryParameters));\n         }\n-        queryParameters.remove(AuditParameters.QUERY_SECURITY_MARKING_COLVIZ);\n-        queryParameters.remove(AuditParameters.USER_DN);\n-        queryParameters.remove(AuditParameters.QUERY_AUDIT_TYPE);\n-        \n-        // Ensure that all required parameters exist prior to validating the values.\n-        qp.validate(queryParameters);\n-        \n-        // The pagesize and expirationDate checks will always be false when called from the RemoteQueryExecutor.\n-        // Leaving for now until we can test to ensure that is always the case.\n-        if (qp.getPagesize() <= 0) {\n-            log.error(\"Invalid page size: \" + qp.getPagesize());\n-            GenericResponse<String> response = new GenericResponse<>();\n-            throwBadRequest(DatawaveErrorCode.INVALID_PAGE_SIZE, response);\n-        }\n-        \n-        if (qp.getPageTimeout() != -1 && (qp.getPageTimeout() < PAGE_TIMEOUT_MIN || qp.getPageTimeout() > PAGE_TIMEOUT_MAX)) {\n-            log.error(\"Invalid page timeout: \" + qp.getPageTimeout());\n-            GenericResponse<String> response = new GenericResponse<>();\n-            throwBadRequest(DatawaveErrorCode.INVALID_PAGE_TIMEOUT, response);\n-        }\n-        \n-        if (System.currentTimeMillis() >= qp.getExpirationDate().getTime()) {\n-            log.error(\"Invalid expiration date: \" + qp.getExpirationDate());\n-            GenericResponse<String> response = new GenericResponse<>();\n-            throwBadRequest(DatawaveErrorCode.INVALID_EXPIRATION_DATE, response);\n-        }\n-        \n-        // Ensure begin date does not occur after the end date (if dates are not null)\n-        if ((qp.getBeginDate() != null && qp.getEndDate() != null) && qp.getBeginDate().after(qp.getEndDate())) {\n-            log.error(\"Invalid begin and/or end date: \" + qp.getBeginDate() + \" - \" + qp.getEndDate());\n-            GenericResponse<String> response = new GenericResponse<>();\n-            throwBadRequest(DatawaveErrorCode.BEGIN_DATE_AFTER_END_DATE, response);\n-        }\n-        \n-        // will throw IllegalArgumentException if not defined\n-        try {\n-            qd.logic = queryLogicFactory.getQueryLogic(queryLogicName, ctx.getCallerPrincipal());\n-        } catch (Exception e) {\n-            log.error(\"Failed to get query logic for \" + queryLogicName, e);\n-            BadRequestQueryException qe = new BadRequestQueryException(DatawaveErrorCode.QUERY_LOGIC_ERROR, e);\n-            GenericResponse<String> response = new GenericResponse<>();\n-            response.addException(qe.getBottomQueryException());\n-            throw new BadRequestException(qe, response);\n+        Set<String> requiredQueryParameters = l.getRequiredQueryParameters();\n+        if (requiredQueryParameters != null) {\n+          d.setRequiredParams(new ArrayList<>(requiredQueryParameters));\n         }\n-        qd.logic.validate(queryParameters);\n-        \n-        try {\n-            marking.clear();\n-            marking.validate(queryParameters);\n-        } catch (IllegalArgumentException e) {\n-            log.error(\"Failed security markings validation\", e);\n-            BadRequestQueryException qe = new BadRequestQueryException(DatawaveErrorCode.SECURITY_MARKING_CHECK_ERROR, e);\n-            GenericResponse<String> response = new GenericResponse<>();\n-            response.addException(qe);\n-            throw new BadRequestException(qe, response);\n+        Set<String> exampleQueries = l.getExampleQueries();\n+        if (exampleQueries != null) {\n+          d.setExampleQueries(new ArrayList<>(exampleQueries));\n         }\n-        // Find out who/what called this method\n-        qd.proxyServers = null;\n-        qd.p = ctx.getCallerPrincipal();\n-        qd.userDn = qd.p.getName();\n-        qd.userid = qd.userDn;\n-        qd.dnList = Collections.singletonList(qd.userid);\n-        if (qd.p instanceof DatawavePrincipal) {\n-            DatawavePrincipal dp = (DatawavePrincipal) qd.p;\n-            qd.userid = dp.getShortName();\n-            qd.userDn = dp.getUserDN().subjectDN();\n-            String[] dns = dp.getDNs();\n-            Arrays.sort(dns);\n-            qd.dnList = Arrays.asList(dns);\n-            qd.proxyServers = dp.getProxyServers();\n-        }\n-        log.trace(qd.userid + \" has authorizations \" + ((qd.p instanceof DatawavePrincipal) ? ((DatawavePrincipal) qd.p).getAuthorizations() : \"\"));\n-        \n-        // always check against the max\n-        if (qd.logic.getMaxPageSize() > 0 && qp.getPagesize() > qd.logic.getMaxPageSize()) {\n-            log.error(\"Invalid page size: \" + qp.getPagesize() + \" vs \" + qd.logic.getMaxPageSize());\n-            BadRequestQueryException qe = new BadRequestQueryException(DatawaveErrorCode.PAGE_SIZE_TOO_LARGE, MessageFormat.format(\"Max = {0}.\",\n-                            qd.logic.getMaxPageSize()));\n-            GenericResponse<String> response = new GenericResponse<>();\n-            response.addException(qe);\n-            throw new BadRequestException(qe, response);\n+        Set<String> requiredRoles = l.getRoleManager().getRequiredRoles();\n+        if (requiredRoles != null) {\n+          List<String> requiredRolesList = new ArrayList<>();\n+          requiredRolesList.addAll(l.getRoleManager().getRequiredRoles());\n+          d.setRequiredRoles(requiredRolesList);\n         }\n-        \n-        // validate the max results override relative to the max results on a query logic\n-        // privileged users however can set whatever they want\n-        if (qp.isMaxResultsOverridden() && qd.logic.getMaxResults() >= 0) {\n-            if (!ctx.isCallerInRole(PRIVILEGED_USER)) {\n-                if (qp.getMaxResultsOverride() < 0 || (qd.logic.getMaxResults() < qp.getMaxResultsOverride())) {\n-                    log.error(\"Invalid max results override: \" + qp.getMaxResultsOverride() + \" vs \" + qd.logic.getMaxResults());\n-                    GenericResponse<String> response = new GenericResponse<>();\n-                    throwBadRequest(DatawaveErrorCode.INVALID_MAX_RESULTS_OVERRIDE, response);\n-                }\n-            }\n+\n+        try {\n+          d.setResponseClass(l.getResponseClass(q));\n+        } catch (QueryException e) {\n+          log.error(e, e);\n+          response.addException(e);\n+          d.setResponseClass(\"unknown\");\n         }\n-        \n-        // Set private audit-related parameters, stripping off any that the user might have passed in first.\n-        // These are parameters that aren't passed in by the user, but rather are computed from other sources.\n-        PrivateAuditConstants.stripPrivateParameters(queryParameters);\n-        queryParameters.add(PrivateAuditConstants.LOGIC_CLASS, queryLogicName);\n-        queryParameters.putSingle(PrivateAuditConstants.COLUMN_VISIBILITY, marking.toColumnVisibilityString());\n-        queryParameters.add(PrivateAuditConstants.USER_DN, qd.userDn);\n-        \n-        return qd;\n-    }\n-    \n-    /**\n-     * @param queryLogicName\n-     * @param queryParameters\n-     * @return\n-     */\n-    @POST\n-    @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\", \"application/x-protobuf\",\n-            \"application/x-protostuff\"})\n-    @Path(\"/{logicName}/define\")\n-    @GZIP\n-    @GenerateQuerySessionId(cookieBasePath = \"/DataWave/Query/\")\n-    @EnrichQueryMetrics(methodType = MethodType.CREATE)\n-    @Interceptors({RequiredInterceptor.class, ResponseInterceptor.class})\n-    @Timed(name = \"dw.query.defineQuery\", absolute = true)\n-    public GenericResponse<String> defineQuery(@Required(\"logicName\") @PathParam(\"logicName\") String queryLogicName,\n-                    MultivaluedMap<String,String> queryParameters, @Context HttpHeaders httpHeaders) {\n-        CreateQuerySessionIDFilter.QUERY_ID.set(null);\n-        \n-        QueryData qd = validateQuery(queryLogicName, queryParameters, httpHeaders);\n-        \n-        GenericResponse<String> response = new GenericResponse<>();\n-        \n-        // We need to put a disconnected RunningQuery instance into the cache. Otherwise TRANSIENT queries\n-        // will not exist when reset is called.\n-        TraceScope defineSpan = null;\n-        RunningQuery rq;\n+\n+        List<String> querySyntax = new ArrayList<>();\n         try {\n-            MultivaluedMap<String,String> optionalQueryParameters = qp.getUnknownParameters(queryParameters);\n-            Query q = persister.create(qd.userDn, qd.dnList, marking, queryLogicName, qp, optionalQueryParameters);\n-            response.setResult(q.getId().toString());\n-            \n-            // If we're supposed to trace this query, then turn tracing on and set information about the query\n-            // onto the span so that it is saved in the trace table.\n-            TraceInfo traceInfo = null;\n-            boolean shouldTraceQuery = shouldTraceQuery(qp.getQuery(), qd.userid, false);\n-            if (shouldTraceQuery) {\n-                TraceScope span = Trace.startSpan(\"query:\" + q.getId());\n-                long traceId = (span.getSpan() != null) ? span.getSpan().getTraceId() : -1;\n-                log.debug(\"Tracing query \" + q.getId() + \" [\" + qp.getQuery() + \"] on trace ID \" + Long.toHexString(traceId));\n-                if (span.getSpan() != null) {\n-                    for (Entry<String,List<String>> param : queryParameters.entrySet()) {\n-                        span.getSpan().addKVAnnotation(param.getKey(), param.getValue().get(0));\n-                    }\n-                }\n-                traceInfo = TraceInfo.fromSpan(span.getSpan());\n-                \n-                defineSpan = Trace.startSpan(\"query:define\", traceInfo);\n-            }\n-            \n-            AccumuloConnectionFactory.Priority priority = qd.logic.getConnectionPriority();\n-            \n-            rq = new RunningQuery(metrics, null, priority, qd.logic, q, qp.getAuths(), qd.p, new RunningQueryTimingImpl(queryExpirationConf,\n-                            qp.getPageTimeout()), this.executor, this.predictor, this.metricFactory);\n-            rq.setActiveCall(true);\n-            rq.getMetric().setProxyServers(qd.proxyServers);\n-            rq.setTraceInfo(traceInfo);\n-            queryCache.put(q.getId().toString(), rq);\n-            rq.setActiveCall(false);\n-            CreateQuerySessionIDFilter.QUERY_ID.set(q.getId().toString());\n-            return response;\n-        } catch (DatawaveWebApplicationException e) {\n-            throw e;\n+          Method m = l.getClass().getMethod(\"getQuerySyntaxParsers\");\n+          Object result = m.invoke(l);\n+          if (result instanceof Map<?, ?>) {\n+            Map<?, ?> map = (Map<?, ?>) result;\n+            for (Object o : map.keySet()) {\n+              querySyntax.add(o.toString());\n+            }\n+          }\n         } catch (Exception e) {\n-            log.error(\"Error accessing optional query parameters\", e);\n-            QueryException qe = new QueryException(DatawaveErrorCode.RUNNING_QUERY_CACHE_ERROR, e);\n-            response.addException(qe.getBottomQueryException());\n-            int statusCode = qe.getBottomQueryException().getStatusCode();\n-            throw new DatawaveWebApplicationException(qe, response, statusCode);\n-        } finally {\n-            if (null != defineSpan) {\n-                // Spans aren't recorded if they take no time, so sleep for a\n-                // couple milliseconds just to ensure we get something saved.\n-                try {\n-                    Thread.sleep(2);\n-                } catch (InterruptedException e) {\n-                    // ignore\n-                }\n-                \n-                defineSpan.close();\n-                \n-                // TODO: not sure this makes any sense anymore in Accumulo 1.8.1\n-                // if (null != defineSpan.parent()) {\n-                // // Stop the main query span since we're done working with it on this thread.\n-                // // We'll continue it later.\n-                // defineSpan.parent().stop();\n-                // }\n-            }\n+          log.warn(\"Unable to get query syntax for query logic: \" + l.getClass().getCanonicalName());\n+        }\n+        if (querySyntax.isEmpty()) {\n+          querySyntax.add(\"CUSTOM\");\n         }\n+        d.setQuerySyntax(querySyntax);\n+\n+        logicConfigurationList.add(d);\n+      } catch (Exception e) {\n+        log.error(\"Error setting query logic description\", e);\n+      }\n     }\n-    \n-    @Override\n-    @Interceptors({RequiredInterceptor.class, ResponseInterceptor.class})\n-    public GenericResponse<String> createQuery(@Required(\"logicName\") String queryLogicName, MultivaluedMap<String,String> queryParameters) {\n-        return createQuery(queryLogicName, queryParameters, null);\n+    Collections.sort(logicConfigurationList, Comparator.comparing(QueryLogicDescription::getName));\n+    response.setQueryLogicList(logicConfigurationList);\n+\n+    return response;\n+  }\n+\n+  @Override\n+  @Interceptors({RequiredInterceptor.class, ResponseInterceptor.class})\n+  public GenericResponse<String> defineQuery(@Required(\"logicName\") String queryLogicName,\n+                                             MultivaluedMap<String, String> queryParameters) {\n+    return defineQuery(queryLogicName, queryParameters, null);\n+  }\n+\n+  /**\n+   * Helper to throw Response Error for create/define Query\n+   */\n+  private void throwBadRequest(DatawaveErrorCode ec, GenericResponse<String> response) {\n+    BadRequestQueryException qe = new BadRequestQueryException(ec);\n+    response.addException(qe);\n+    throw new BadRequestException(qe, response);\n+  }\n+\n+  /**\n+   * This method will provide some initial query validation for the define and create query calls.\n+   */\n+  private QueryData validateQuery(String queryLogicName, MultivaluedMap<String, String> queryParameters,\n+                                  HttpHeaders httpHeaders) {\n+\n+    // Parameter 'logicName' is required and passed in prior to this call. Add to the queryParameters now.\n+    if (!queryParameters.containsKey(QueryParameters.QUERY_LOGIC_NAME)) {\n+      queryParameters.putSingle(QueryParameters.QUERY_LOGIC_NAME, queryLogicName);\n     }\n-    \n-    /**\n-     * @param queryLogicName\n-     * @param queryParameters\n-     * @return\n-     */\n-    @POST\n-    @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\", \"application/x-protobuf\",\n-            \"application/x-protostuff\"})\n-    @Path(\"/{logicName}/create\")\n-    @GZIP\n-    @GenerateQuerySessionId(cookieBasePath = \"/DataWave/Query/\")\n-    @EnrichQueryMetrics(methodType = MethodType.CREATE)\n-    @Interceptors({RequiredInterceptor.class, ResponseInterceptor.class})\n-    @Timed(name = \"dw.query.createQuery\", absolute = true)\n-    public GenericResponse<String> createQuery(@Required(\"logicName\") @PathParam(\"logicName\") String queryLogicName,\n-                    MultivaluedMap<String,String> queryParameters, @Context HttpHeaders httpHeaders) {\n-        CreateQuerySessionIDFilter.QUERY_ID.set(null);\n-        \n-        QueryData qd = validateQuery(queryLogicName, queryParameters, httpHeaders);\n-        \n-        GenericResponse<String> response = new GenericResponse<>();\n-        \n-        Query q = null;\n-        AccumuloClient client = null;\n-        AccumuloConnectionFactory.Priority priority;\n-        TraceScope createSpan = null;\n-        RunningQuery rq = null;\n-        try {\n-            // Default hasResults to true. If a query logic is actually able to set this value,\n-            // then their value will overwrite this one. Otherwise, we return true so that\n-            // callers know they have to call next (even though next may not return results).\n-            response.setHasResults(true);\n-            \n-            AuditType auditType = qd.logic.getAuditType(null);\n-            try {\n-                MultivaluedMap<String,String> optionalQueryParameters = qp.getUnknownParameters(queryParameters);\n-                q = persister.create(qd.userDn, qd.dnList, marking, queryLogicName, qp, optionalQueryParameters);\n-                auditType = qd.logic.getAuditType(q);\n-            } finally {\n-                queryParameters.add(PrivateAuditConstants.AUDIT_TYPE, auditType.name());\n-                \n-                if (!auditType.equals(AuditType.NONE)) {\n-                    // audit the query before its executed.\n-                    try {\n-                        try {\n-                            List<String> selectors = qd.logic.getSelectors(q);\n-                            if (selectors != null && !selectors.isEmpty()) {\n-                                queryParameters.put(PrivateAuditConstants.SELECTORS, selectors);\n-                            }\n-                        } catch (Exception e) {\n-                            log.error(\"Error accessing query selector\", e);\n-                        }\n-                        auditor.audit(queryParameters);\n-                    } catch (IllegalArgumentException e) {\n-                        log.error(\"Error validating audit parameters\", e);\n-                        BadRequestQueryException qe = new BadRequestQueryException(DatawaveErrorCode.MISSING_REQUIRED_PARAMETER, e);\n-                        response.addException(qe);\n-                        throw new BadRequestException(qe, response);\n-                    } catch (Exception e) {\n-                        log.error(\"Error auditing query\", e);\n-                        QueryException qe = new QueryException(DatawaveErrorCode.QUERY_AUDITING_ERROR, e);\n-                        response.addException(qe);\n-                        throw qe;\n-                    }\n-                }\n-            }\n-            \n-            priority = qd.logic.getConnectionPriority();\n-            Map<String,String> trackingMap = connectionFactory.getTrackingMap(Thread.currentThread().getStackTrace());\n-            addQueryToTrackingMap(trackingMap, q);\n-            accumuloConnectionRequestBean.requestBegin(q.getId().toString());\n-            try {\n-                client = connectionFactory.getClient(qd.logic.getConnPoolName(), priority, trackingMap);\n-            } finally {\n-                accumuloConnectionRequestBean.requestEnd(q.getId().toString());\n-            }\n-            // If we're supposed to trace this query, then turn tracing on and set information about the query\n-            // onto the span so that it is saved in the trace table.\n-            TraceInfo traceInfo = null;\n-            boolean shouldTraceQuery = shouldTraceQuery(qp.getQuery(), qd.userid, qp.isTrace());\n-            if (shouldTraceQuery) {\n-                TraceScope scope = Trace.startSpan(\"query:\" + q.getId());\n-                long traceId = (scope.getSpan() != null) ? scope.getSpan().getTraceId() : -1;\n-                log.debug(\"Tracing query \" + q.getId() + \" [\" + qp.getQuery() + \"] on trace ID \" + Long.toHexString(traceId));\n-                if (scope.getSpan() != null) {\n-                    for (Entry<String,List<String>> param : queryParameters.entrySet()) {\n-                        scope.getSpan().addKVAnnotation(param.getKey(), param.getValue().get(0));\n-                    }\n-                }\n-                traceInfo = TraceInfo.fromSpan(scope.getSpan());\n-                \n-                createSpan = Trace.startSpan(\"query:create\", traceInfo);\n-            }\n-            \n-            // hold on to a reference of the query logic so we cancel it if need be.\n-            qlCache.add(q.getId().toString(), qd.userid, qd.logic, client);\n-            rq = new RunningQuery(metrics, null, priority, qd.logic, q, qp.getAuths(), qd.p, new RunningQueryTimingImpl(queryExpirationConf,\n-                            qp.getPageTimeout()), this.executor, this.predictor, this.metricFactory);\n-            rq.setActiveCall(true);\n-            rq.setTraceInfo(traceInfo);\n-            rq.getMetric().setProxyServers(qd.proxyServers);\n-            rq.setClient(client);\n-            \n-            // Put in the cache by id. Don't put the cache in by name because multiple users may use the same name\n-            // and only the last one will be in the cache.\n-            queryCache.put(q.getId().toString(), rq);\n-            \n-            response.setResult(q.getId().toString());\n-            rq.setActiveCall(false);\n-            CreateQuerySessionIDFilter.QUERY_ID.set(q.getId().toString());\n-            return response;\n-        } catch (Throwable t) {\n-            response.setHasResults(false);\n-            \n-            if (rq != null) {\n-                rq.getMetric().setError(t);\n-            }\n-            \n-            // close the logic on exception\n-            try {\n-                if (null != qd.logic) {\n-                    qd.logic.close();\n-                }\n-            } catch (Exception e) {\n-                log.error(\"Exception occured while closing query logic; may be innocuous if scanners were running.\", e);\n-            }\n-            \n-            if (null != client) {\n-                try {\n-                    connectionFactory.returnClient(client);\n-                } catch (Exception e) {\n-                    log.error(\"Error returning connection on failed create\", e);\n-                }\n-            }\n-            try {\n-                if (null != q)\n-                    persister.remove(q);\n-            } catch (Exception e) {\n-                response.addException(new QueryException(DatawaveErrorCode.DEPERSIST_ERROR, e).getBottomQueryException());\n-            }\n-            \n-            /*\n-             * Allow web services to throw their own WebApplicationExceptions\n-             */\n-            if (t instanceof Error && !(t instanceof TokenMgrError)) {\n-                log.error(t.getMessage(), t);\n-                throw (Error) t;\n-            } else if (t instanceof WebApplicationException) {\n-                log.error(t.getMessage(), t);\n-                throw ((WebApplicationException) t);\n-            } else if (t instanceof InterruptedException) {\n-                if (rq != null) {\n-                    rq.getMetric().setLifecycle(QueryMetric.Lifecycle.CANCELLED);\n-                }\n-                log.info(\"Query \" + q.getId() + \" canceled on request\");\n-                QueryException qe = new QueryException(DatawaveErrorCode.QUERY_CANCELED, t);\n-                response.addException(qe.getBottomQueryException());\n-                int statusCode = qe.getBottomQueryException().getStatusCode();\n-                throw new DatawaveWebApplicationException(qe, response, statusCode);\n-            } else {\n-                log.error(t.getMessage(), t);\n-                QueryException qe = new QueryException(DatawaveErrorCode.RUNNING_QUERY_CACHE_ERROR, t);\n-                response.addException(qe.getBottomQueryException());\n-                int statusCode = qe.getBottomQueryException().getStatusCode();\n-                throw new DatawaveWebApplicationException(qe, response, statusCode);\n-            }\n-        } finally {\n-            if (createSpan != null) {\n-                createSpan.close();\n-                // TODO: not sure this makes any sense anymore in Accumulo 1.8.1\n-                // Stop the main query span since we're done working with it on this thread.\n-                // We'll continue it later.\n-                // createSpan.parent().stop();\n-            }\n-            if (null != q) {\n-                // - Remove the logic from the cache\n-                qlCache.poll(q.getId().toString());\n-            }\n-        }\n+\n+    QueryData qd = new QueryData();\n+\n+    log.debug(queryParameters);\n+    qp.clear();\n+    qp.setRequestHeaders(httpHeaders != null ? httpHeaders.getRequestHeaders() : null);\n+\n+    // Pull \"params\" values into individual query parameters for validation on the query logic.\n+    // This supports the deprecated \"params\" value (both on the old and new API). Once we remove the deprecated\n+    // parameter, this code block can go away.\n+    String params = queryParameters.getFirst(QueryParameters.QUERY_PARAMS);\n+    if (params != null) {\n+      for (Parameter pm : QueryUtil.parseParameters(params)) {\n+        if (!queryParameters.containsKey(pm.getParameterName())) {\n+          queryParameters.putSingle(pm.getParameterName(), pm.getParameterValue());\n+        }\n+      }\n+    }\n+    queryParameters.remove(AuditParameters.QUERY_SECURITY_MARKING_COLVIZ);\n+    queryParameters.remove(AuditParameters.USER_DN);\n+    queryParameters.remove(AuditParameters.QUERY_AUDIT_TYPE);\n+\n+    // Ensure that all required parameters exist prior to validating the values.\n+    qp.validate(queryParameters);\n+\n+    // The pagesize and expirationDate checks will always be false when called from the RemoteQueryExecutor.\n+    // Leaving for now until we can test to ensure that is always the case.\n+    if (qp.getPagesize() <= 0) {\n+      log.error(\"Invalid page size: \" + qp.getPagesize());\n+      GenericResponse<String> response = new GenericResponse<>();\n+      throwBadRequest(DatawaveErrorCode.INVALID_PAGE_SIZE, response);\n     }\n-    \n-    /**\n-     * @param queryLogicName\n-     * @param queryParameters\n-     * @return\n-     */\n-    @POST\n-    @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\", \"application/x-protobuf\",\n-            \"application/x-protostuff\"})\n-    @Path(\"/{logicName}/plan\")\n-    @Interceptors({RequiredInterceptor.class, ResponseInterceptor.class})\n-    @Timed(name = \"dw.query.planQuery\", absolute = true)\n-    public GenericResponse<String> planQuery(@Required(\"logicName\") @PathParam(\"logicName\") String queryLogicName, MultivaluedMap<String,String> queryParameters) {\n-        QueryData qd = validateQuery(queryLogicName, queryParameters, null);\n-        \n-        GenericResponse<String> response = new GenericResponse<>();\n-        \n-        Query q = null;\n-        AccumuloClient client = null;\n-        AccumuloConnectionFactory.Priority priority;\n-        try {\n-            // Default hasResults to true.\n-            response.setHasResults(true);\n-            \n-            // by default we will expand the fields but not the values.\n-            boolean expandFields = true;\n-            boolean expandValues = false;\n-            if (queryParameters.containsKey(EXPAND_FIELDS)) {\n-                expandFields = Boolean.valueOf(queryParameters.getFirst(EXPAND_FIELDS));\n-            }\n-            if (queryParameters.containsKey(EXPAND_VALUES)) {\n-                expandValues = Boolean.valueOf(queryParameters.getFirst(EXPAND_VALUES));\n-            }\n-            \n-            AuditType auditType = qd.logic.getAuditType(null);\n-            try {\n-                MultivaluedMap<String,String> optionalQueryParameters = qp.getUnknownParameters(queryParameters);\n-                q = persister.create(qd.userDn, qd.dnList, marking, queryLogicName, qp, optionalQueryParameters);\n-                auditType = qd.logic.getAuditType(q);\n-            } finally {\n-                queryParameters.add(PrivateAuditConstants.AUDIT_TYPE, auditType.name());\n-                \n-                // on audit if needed, and we are using the index to expand the values\n-                if (expandValues && !auditType.equals(AuditType.NONE)) {\n-                    // audit the query before its executed.\n-                    try {\n-                        try {\n-                            List<String> selectors = qd.logic.getSelectors(q);\n-                            if (selectors != null && !selectors.isEmpty()) {\n-                                queryParameters.put(PrivateAuditConstants.SELECTORS, selectors);\n-                            }\n-                        } catch (Exception e) {\n-                            log.error(\"Error accessing query selector\", e);\n-                        }\n-                        auditor.audit(queryParameters);\n-                    } catch (IllegalArgumentException e) {\n-                        log.error(\"Error validating audit parameters\", e);\n-                        BadRequestQueryException qe = new BadRequestQueryException(DatawaveErrorCode.MISSING_REQUIRED_PARAMETER, e);\n-                        response.addException(qe);\n-                        throw new BadRequestException(qe, response);\n-                    } catch (Exception e) {\n-                        log.error(\"Error auditing query\", e);\n-                        QueryException qe = new QueryException(DatawaveErrorCode.QUERY_AUDITING_ERROR, e);\n-                        response.addException(qe);\n-                        throw qe;\n-                    }\n-                }\n-            }\n-            \n-            priority = qd.logic.getConnectionPriority();\n-            Map<String,String> trackingMap = connectionFactory.getTrackingMap(Thread.currentThread().getStackTrace());\n-            addQueryToTrackingMap(trackingMap, q);\n-            accumuloConnectionRequestBean.requestBegin(q.getId().toString());\n-            try {\n-                client = connectionFactory.getClient(qd.logic.getConnPoolName(), priority, trackingMap);\n-            } finally {\n-                accumuloConnectionRequestBean.requestEnd(q.getId().toString());\n-            }\n-            \n-            Set<Authorizations> calculatedAuths = AuthorizationsUtil.getDowngradedAuthorizations(qp.getAuths(), qd.p);\n-            String plan = qd.logic.getPlan(client, q, calculatedAuths, expandFields, expandValues);\n-            response.setResult(plan);\n-            \n-            return response;\n-        } catch (Throwable t) {\n-            response.setHasResults(false);\n-            \n-            /*\n-             * Allow web services to throw their own WebApplicationExceptions\n-             */\n-            if (t instanceof Error && !(t instanceof TokenMgrError)) {\n-                log.error(t.getMessage(), t);\n-                throw (Error) t;\n-            } else if (t instanceof WebApplicationException) {\n-                log.error(t.getMessage(), t);\n-                throw ((WebApplicationException) t);\n-            } else {\n-                log.error(t.getMessage(), t);\n-                QueryException qe = new QueryException(DatawaveErrorCode.QUERY_PLAN_ERROR, t);\n-                response.addException(qe.getBottomQueryException());\n-                int statusCode = qe.getBottomQueryException().getStatusCode();\n-                throw new DatawaveWebApplicationException(qe, response, statusCode);\n-            }\n-        } finally {\n-            if (client != null) {\n-                try {\n-                    connectionFactory.returnClient(client);\n-                } catch (Exception e) {\n-                    log.error(\"Failed to close connection for \" + q.getId(), e);\n-                }\n-            }\n-            \n-            // close the logic on exception\n-            try {\n-                if (null != qd.logic) {\n-                    qd.logic.close();\n-                }\n-            } catch (Exception e) {\n-                log.error(\"Exception occured while closing query logic; may be innocuous if scanners were running.\", e);\n-            }\n-            \n-            if (null != client) {\n-                try {\n-                    connectionFactory.returnClient(client);\n-                } catch (Exception e) {\n-                    log.error(\"Error returning connection on failed create\", e);\n-                }\n-            }\n-        }\n+\n+    if (qp.getPageTimeout() != -1 &&\n+        (qp.getPageTimeout() < PAGE_TIMEOUT_MIN || qp.getPageTimeout() > PAGE_TIMEOUT_MAX)) {\n+      log.error(\"Invalid page timeout: \" + qp.getPageTimeout());\n+      GenericResponse<String> response = new GenericResponse<>();\n+      throwBadRequest(DatawaveErrorCode.INVALID_PAGE_TIMEOUT, response);\n     }\n-    \n-    /**\n-     * @param queryLogicName\n-     * @param queryParameters\n-     * @return query predictions\n-     */\n-    @POST\n-    @Path(\"/{logicName}/predict\")\n-    @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\", \"application/x-protobuf\",\n-            \"application/x-protostuff\"})\n-    @Interceptors({RequiredInterceptor.class, ResponseInterceptor.class})\n-    @Timed(name = \"dw.query.predictQuery\", absolute = true)\n-    public GenericResponse<String> predictQuery(@Required(\"logicName\") @PathParam(\"logicName\") String queryLogicName,\n-                    MultivaluedMap<String,String> queryParameters) {\n-        \n-        CreateQuerySessionIDFilter.QUERY_ID.set(null);\n-        \n-        QueryData qd = validateQuery(queryLogicName, queryParameters, null);\n-        \n-        GenericResponse<String> response = new GenericResponse<>();\n-        \n-        if (predictor != null) {\n-            try {\n-                qp.setPersistenceMode(QueryPersistence.TRANSIENT);\n-                MultivaluedMap<String,String> optionalQueryParameters = qp.getUnknownParameters(queryParameters);\n-                Query q = persister.create(qd.userDn, qd.dnList, marking, queryLogicName, qp, optionalQueryParameters);\n-                \n-                BaseQueryMetric metric = metricFactory.createMetric();\n-                q.populateMetric(metric);\n-                metric.setQueryType(RunningQuery.class.getSimpleName());\n-                \n-                Set<Prediction> predictions = predictor.predict(metric);\n-                if (predictions != null && !predictions.isEmpty()) {\n-                    String predictionString = predictions.toString();\n-                    // now we have a predictions, lets broadcast\n-                    log.info(\"Model predictions: \" + predictionString);\n-                    response.setHasResults(true);\n-                    response.setResult(predictionString);\n-                } else {\n-                    response.setHasResults(false);\n-                }\n-            } catch (Throwable t) {\n-                response.setHasResults(false);\n-                \n-                /*\n-                 * Allow web services to throw their own WebApplicationExceptions\n-                 */\n-                \n-                if (t instanceof Error && !(t instanceof TokenMgrError)) {\n-                    log.error(t.getMessage(), t);\n-                    throw (Error) t;\n-                } else if (t instanceof WebApplicationException) {\n-                    log.error(t.getMessage(), t);\n-                    throw ((WebApplicationException) t);\n-                } else {\n-                    log.error(t.getMessage(), t);\n-                    QueryException qe = new QueryException(DatawaveErrorCode.QUERY_PREDICTIONS_ERROR, t);\n-                    response.addException(qe.getBottomQueryException());\n-                    int statusCode = qe.getBottomQueryException().getStatusCode();\n-                    throw new DatawaveWebApplicationException(qe, response, statusCode);\n-                }\n-                \n-            }\n-        } else {\n-            response.setHasResults(false);\n-        }\n-        return response;\n+\n+    if (System.currentTimeMillis() >= qp.getExpirationDate().getTime()) {\n+      log.error(\"Invalid expiration date: \" + qp.getExpirationDate());\n+      GenericResponse<String> response = new GenericResponse<>();\n+      throwBadRequest(DatawaveErrorCode.INVALID_EXPIRATION_DATE, response);\n     }\n-    \n-    @POST\n-    @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\", \"application/x-protobuf\",\n-            \"application/x-protostuff\"})\n-    @Path(\"/{logicName}/async/create\")\n-    @GZIP\n-    @GenerateQuerySessionId(cookieBasePath = \"/DataWave/Query/\")\n-    @EnrichQueryMetrics(methodType = MethodType.CREATE)\n-    @Interceptors({RequiredInterceptor.class, ResponseInterceptor.class})\n-    @Asynchronous\n-    @Timed(name = \"dw.query.createQueryAsync\", absolute = true)\n-    public void createQueryAsync(@Required(\"logicName\") @PathParam(\"logicName\") String queryLogicName, MultivaluedMap<String,String> queryParameters,\n-                    @Suspended AsyncResponse asyncResponse) {\n-        try {\n-            GenericResponse<String> response = createQuery(queryLogicName, queryParameters);\n-            asyncResponse.resume(response);\n-        } catch (Throwable t) {\n-            asyncResponse.resume(t);\n-        }\n-    }\n-    \n-    private List<RunningQuery> getQueryByName(String name) throws Exception {\n-        // Find out who/what called this method\n-        Principal p = ctx.getCallerPrincipal();\n-        String userid = p.getName();\n-        if (p instanceof DatawavePrincipal) {\n-            DatawavePrincipal dp = (DatawavePrincipal) p;\n-            userid = dp.getShortName();\n-        }\n-        log.trace(userid + \" has authorizations \" + ((p instanceof DatawavePrincipal) ? ((DatawavePrincipal) p).getAuthorizations() : \"\"));\n-        List<RunningQuery> results = new ArrayList<>();\n-        \n-        List<Query> queries = persister.findByName(name);\n-        if (null == queries)\n-            throw new NotFoundQueryException(DatawaveErrorCode.NO_QUERY_OBJECT_MATCH);\n-        \n-        for (Query q : queries) {\n-            // Check to make sure that this query belongs to current user.\n-            // Not sure this can ever happen with the current persister. It scans with a range set to your userid, so you\n-            // never get back other people queries. Leaving for now just in case the persister changes.\n-            if (!q.getOwner().equals(userid)) {\n-                throw new UnauthorizedQueryException(DatawaveErrorCode.QUERY_OWNER_MISMATCH, MessageFormat.format(\"{0} != {1}\", userid, q.getOwner()));\n-            }\n-            \n-            // will throw IllegalArgumentException if not defined\n-            QueryLogic<?> logic = queryLogicFactory.getQueryLogic(q.getQueryLogicName(), p);\n-            AccumuloConnectionFactory.Priority priority = logic.getConnectionPriority();\n-            RunningQuery query = new RunningQuery(metrics, null, priority, logic, q, q.getQueryAuthorizations(), p, new RunningQueryTimingImpl(\n-                            queryExpirationConf, qp.getPageTimeout()), this.executor, this.predictor, this.metricFactory);\n-            results.add(query);\n-            // Put in the cache by id if its not already in the cache.\n-            if (!queryCache.containsKey(q.getId().toString()))\n-                queryCache.put(q.getId().toString(), query);\n-        }\n-        return results;\n-    }\n-    \n-    private RunningQuery getQueryById(String id) throws Exception {\n-        return getQueryById(id, ctx.getCallerPrincipal());\n-    }\n-    \n-    private RunningQuery getQueryById(String id, Principal principal) throws Exception {\n-        // Find out who/what called this method\n-        String userid = principal.getName();\n-        if (principal instanceof DatawavePrincipal) {\n-            DatawavePrincipal dp = (DatawavePrincipal) principal;\n-            userid = dp.getShortName();\n-        }\n-        log.trace(userid + \" has authorizations \" + ((principal instanceof DatawavePrincipal) ? ((DatawavePrincipal) principal).getAuthorizations() : \"\"));\n-        \n-        RunningQuery query = queryCache.get(id);\n-        if (null == query) {\n-            log.info(\"Query not found in cache, retrieving from accumulo\");\n-            List<Query> queries = persister.findById(id);\n-            if (null == queries || queries.isEmpty())\n-                throw new NotFoundQueryException(DatawaveErrorCode.NO_QUERY_OBJECT_MATCH);\n-            if (queries.size() > 1)\n-                throw new NotFoundQueryException(DatawaveErrorCode.TOO_MANY_QUERY_OBJECT_MATCHES);\n-            else {\n-                Query q = queries.get(0);\n-                \n-                // will throw IllegalArgumentException if not defined\n-                QueryLogic<?> logic = queryLogicFactory.getQueryLogic(q.getQueryLogicName(), principal);\n-                AccumuloConnectionFactory.Priority priority = logic.getConnectionPriority();\n-                query = new RunningQuery(metrics, null, priority, logic, q, q.getQueryAuthorizations(), principal, new RunningQueryTimingImpl(\n-                                queryExpirationConf, qp.getPageTimeout()), this.executor, this.predictor, this.metricFactory);\n-                // Put in the cache by id and name, we will have two copies that reference the same object\n-                queryCache.put(q.getId().toString(), query);\n-            }\n-        } else {\n-            // Check to make sure that this query belongs to current user.\n-            if (!query.getSettings().getOwner().equals(userid)) {\n-                throw new UnauthorizedQueryException(DatawaveErrorCode.QUERY_OWNER_MISMATCH, MessageFormat.format(\"{0} != {1}\", userid, query.getSettings()\n-                                .getOwner()));\n-            }\n+\n+    // Ensure begin date does not occur after the end date (if dates are not null)\n+    if ((qp.getBeginDate() != null && qp.getEndDate() != null) && qp.getBeginDate().after(qp.getEndDate())) {\n+      log.error(\"Invalid begin and/or end date: \" + qp.getBeginDate() + \" - \" + qp.getEndDate());\n+      GenericResponse<String> response = new GenericResponse<>();\n+      throwBadRequest(DatawaveErrorCode.BEGIN_DATE_AFTER_END_DATE, response);\n+    }\n+\n+    // will throw IllegalArgumentException if not defined\n+    try {\n+      qd.logic = queryLogicFactory.getQueryLogic(queryLogicName, ctx.getCallerPrincipal());\n+    } catch (Exception e) {\n+      log.error(\"Failed to get query logic for \" + queryLogicName, e);\n+      BadRequestQueryException qe = new BadRequestQueryException(DatawaveErrorCode.QUERY_LOGIC_ERROR, e);\n+      GenericResponse<String> response = new GenericResponse<>();\n+      response.addException(qe.getBottomQueryException());\n+      throw new BadRequestException(qe, response);\n+    }\n+    qd.logic.validate(queryParameters);\n+\n+    try {\n+      marking.clear();\n+      marking.validate(queryParameters);\n+    } catch (IllegalArgumentException e) {\n+      log.error(\"Failed security markings validation\", e);\n+      BadRequestQueryException qe = new BadRequestQueryException(DatawaveErrorCode.SECURITY_MARKING_CHECK_ERROR, e);\n+      GenericResponse<String> response = new GenericResponse<>();\n+      response.addException(qe);\n+      throw new BadRequestException(qe, response);\n+    }\n+    // Find out who/what called this method\n+    qd.proxyServers = null;\n+    qd.p = ctx.getCallerPrincipal();\n+    qd.userDn = qd.p.getName();\n+    qd.userid = qd.userDn;\n+    qd.dnList = Collections.singletonList(qd.userid);\n+    if (qd.p instanceof DatawavePrincipal) {\n+      DatawavePrincipal dp = (DatawavePrincipal) qd.p;\n+      qd.userid = dp.getShortName();\n+      qd.userDn = dp.getUserDN().subjectDN();\n+      String[] dns = dp.getDNs();\n+      Arrays.sort(dns);\n+      qd.dnList = Arrays.asList(dns);\n+      qd.proxyServers = dp.getProxyServers();\n+    }\n+    log.trace(qd.userid + \" has authorizations \" +\n+        ((qd.p instanceof DatawavePrincipal) ? ((DatawavePrincipal) qd.p).getAuthorizations() : \"\"));\n+\n+    // always check against the max\n+    if (qd.logic.getMaxPageSize() > 0 && qp.getPagesize() > qd.logic.getMaxPageSize()) {\n+      log.error(\"Invalid page size: \" + qp.getPagesize() + \" vs \" + qd.logic.getMaxPageSize());\n+      BadRequestQueryException qe =\n+          new BadRequestQueryException(DatawaveErrorCode.PAGE_SIZE_TOO_LARGE, MessageFormat.format(\"Max = {0}.\",\n+              qd.logic.getMaxPageSize()));\n+      GenericResponse<String> response = new GenericResponse<>();\n+      response.addException(qe);\n+      throw new BadRequestException(qe, response);\n+    }\n+\n+    // validate the max results override relative to the max results on a query logic\n+    // privileged users however can set whatever they want\n+    if (qp.isMaxResultsOverridden() && qd.logic.getMaxResults() >= 0) {\n+      if (!ctx.isCallerInRole(PRIVILEGED_USER)) {\n+        if (qp.getMaxResultsOverride() < 0 || (qd.logic.getMaxResults() < qp.getMaxResultsOverride())) {\n+          log.error(\"Invalid max results override: \" + qp.getMaxResultsOverride() + \" vs \" + qd.logic.getMaxResults());\n+          GenericResponse<String> response = new GenericResponse<>();\n+          throwBadRequest(DatawaveErrorCode.INVALID_MAX_RESULTS_OVERRIDE, response);\n         }\n-        return query;\n-    }\n-    \n-    private RunningQuery adminGetQueryById(String id) throws Exception {\n-        RunningQuery query = queryCache.get(id);\n-        \n-        if (query == null) {\n-            log.info(\"Query not found in cache, retrieving from accumulo\");\n-            List<Query> queries = persister.adminFindById(id);\n-            \n-            if (queries == null || queries.isEmpty())\n-                throw new NotFoundQueryException(DatawaveErrorCode.NO_QUERY_OBJECT_MATCH);\n-            if (queries.size() > 1)\n-                throw new NotFoundQueryException(DatawaveErrorCode.TOO_MANY_QUERY_OBJECT_MATCHES);\n-            \n-            Query q = queries.get(0);\n-            \n-            final String auths = q.getQueryAuthorizations();\n-            \n-            // will throw IllegalArgumentException if not defined\n-            final QueryLogic<?> logic = queryLogicFactory.getQueryLogic(q.getQueryLogicName(), ctx.getCallerPrincipal());\n-            final AccumuloConnectionFactory.Priority priority = logic.getConnectionPriority();\n-            query = RunningQuery.createQueryWithAuthorizations(metrics, null, priority, logic, q, auths,\n-                            new RunningQueryTimingImpl(queryExpirationConf, qp.getPageTimeout()), this.executor, this.predictor, this.metricFactory);\n-            \n-            // Put in the cache by id and name, we will have two copies that reference the same object\n-            queryCache.put(q.getId().toString(), query);\n-        }\n-        \n-        return query;\n-    }\n-    \n-    /**\n-     * Resets the query named by {@code id}. If the query is not alive, meaning that the current session has expired (due to either timeout, or server failure),\n-     * then this will reload the query and start it over. If the query is alive, it closes it and starts the query over.\n-     *\n-     * @param id\n-     *            the ID of the query to reload/reset\n-     * @return an empty response\n-     *\n-     * @return datawave.webservice.result.VoidResponse\n-     * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user, by specifying a chain of DNs of the identities to proxy\n-     * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n-     * @ResponseHeader query-session-id this header and value will be in the Set-Cookie header, subsequent calls for this session will need to supply the\n-     *                 query-session-id header in the request in a Cookie header or as a query parameter\n-     * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n-     *\n-     * @HTTP 200 success\n-     * @HTTP 400 invalid or missing parameter\n-     * @HTTP 500 internal server error\n-     */\n-    @PUT\n-    @POST\n-    @Path(\"/{id}/reset\")\n-    @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\", \"application/x-protobuf\",\n-            \"application/x-protostuff\"})\n-    @GZIP\n-    @GenerateQuerySessionId(cookieBasePath = \"/DataWave/Query/\")\n-    @Interceptors({ResponseInterceptor.class, RequiredInterceptor.class})\n-    @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)\n-    @Override\n-    @Timed(name = \"dw.query.reset\", absolute = true)\n-    public VoidResponse reset(@Required(\"id\") @PathParam(\"id\") String id) {\n-        CreateQuerySessionIDFilter.QUERY_ID.set(null);\n-        VoidResponse response = new VoidResponse();\n-        AccumuloConnectionFactory.Priority priority;\n-        \n-        AccumuloClient client = null;\n-        RunningQuery query = null;\n-        TraceScope span = null;\n-        \n+      }\n+    }\n+\n+    // Set private audit-related parameters, stripping off any that the user might have passed in first.\n+    // These are parameters that aren't passed in by the user, but rather are computed from other sources.\n+    PrivateAuditConstants.stripPrivateParameters(queryParameters);\n+    queryParameters.add(PrivateAuditConstants.LOGIC_CLASS, queryLogicName);\n+    queryParameters.putSingle(PrivateAuditConstants.COLUMN_VISIBILITY, marking.toColumnVisibilityString());\n+    queryParameters.add(PrivateAuditConstants.USER_DN, qd.userDn);\n+\n+    return qd;\n+  }\n+\n+  /**\n+   * @param queryLogicName\n+   * @param queryParameters\n+   * @return\n+   */\n+  @POST\n+  @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\",\n+      \"application/x-protobuf\",\n+      \"application/x-protostuff\"})\n+  @Path(\"/{logicName}/define\")\n+  @GZIP\n+  @GenerateQuerySessionId(cookieBasePath = \"/DataWave/Query/\")\n+  @EnrichQueryMetrics(methodType = MethodType.CREATE)\n+  @Interceptors({RequiredInterceptor.class, ResponseInterceptor.class})\n+  @Timed(name = \"dw.query.defineQuery\", absolute = true)\n+  public GenericResponse<String> defineQuery(@Required(\"logicName\") @PathParam(\"logicName\") String queryLogicName,\n+                                             MultivaluedMap<String, String> queryParameters,\n+                                             @Context HttpHeaders httpHeaders) {\n+    CreateQuerySessionIDFilter.QUERY_ID.set(null);\n+\n+    QueryData qd = validateQuery(queryLogicName, queryParameters, httpHeaders);\n+\n+    GenericResponse<String> response = new GenericResponse<>();\n+\n+    // We need to put a disconnected RunningQuery instance into the cache. Otherwise TRANSIENT queries\n+    // will not exist when reset is called.\n+    TraceScope defineSpan = null;\n+    RunningQuery rq;\n+    try {\n+      MultivaluedMap<String, String> optionalQueryParameters = qp.getUnknownParameters(queryParameters);\n+      Query q = persister.create(qd.userDn, qd.dnList, marking, queryLogicName, qp, optionalQueryParameters);\n+      response.setResult(q.getId().toString());\n+\n+      // If we're supposed to trace this query, then turn tracing on and set information about the query\n+      // onto the span so that it is saved in the trace table.\n+      TraceInfo traceInfo = null;\n+      boolean shouldTraceQuery = shouldTraceQuery(qp.getQuery(), qd.userid, false);\n+      if (shouldTraceQuery) {\n+        TraceScope span = Trace.startSpan(\"query:\" + q.getId());\n+        long traceId = (span.getSpan() != null) ? span.getSpan().getTraceId() : -1;\n+        log.debug(\"Tracing query \" + q.getId() + \" [\" + qp.getQuery() + \"] on trace ID \" + Long.toHexString(traceId));\n+        if (span.getSpan() != null) {\n+          for (Entry<String, List<String>> param : queryParameters.entrySet()) {\n+            span.getSpan().addKVAnnotation(param.getKey(), param.getValue().get(0));\n+          }\n+        }\n+        traceInfo = TraceInfo.fromSpan(span.getSpan());\n+\n+        defineSpan = Trace.startSpan(\"query:define\", traceInfo);\n+      }\n+\n+      AccumuloConnectionFactory.Priority priority = qd.logic.getConnectionPriority();\n+\n+      rq = new RunningQuery(metrics, null, priority, qd.logic, q, qp.getAuths(), qd.p,\n+          new RunningQueryTimingImpl(queryExpirationConf,\n+              qp.getPageTimeout()), this.executor, this.predictor, this.metricFactory);\n+      rq.setActiveCall(true);\n+      rq.getMetric().setProxyServers(qd.proxyServers);\n+      rq.setTraceInfo(traceInfo);\n+      queryCache.put(q.getId().toString(), rq);\n+      rq.setActiveCall(false);\n+      CreateQuerySessionIDFilter.QUERY_ID.set(q.getId().toString());\n+      return response;\n+    } catch (DatawaveWebApplicationException e) {\n+      throw e;\n+    } catch (Exception e) {\n+      log.error(\"Error accessing optional query parameters\", e);\n+      QueryException qe = new QueryException(DatawaveErrorCode.RUNNING_QUERY_CACHE_ERROR, e);\n+      response.addException(qe.getBottomQueryException());\n+      int statusCode = qe.getBottomQueryException().getStatusCode();\n+      throw new DatawaveWebApplicationException(qe, response, statusCode);\n+    } finally {\n+      if (null != defineSpan) {\n+        // Spans aren't recorded if they take no time, so sleep for a\n+        // couple milliseconds just to ensure we get something saved.\n         try {\n-            ctx.getUserTransaction().begin();\n-            \n-            query = getQueryById(id);\n-            \n-            // If we're tracing this query, then continue the trace for the reset call.\n-            TraceInfo traceInfo = query.getTraceInfo();\n-            if (traceInfo != null) {\n-                span = Trace.startSpan(\"query:reset\", traceInfo);\n-            }\n-            \n-            // Lock this so that this query cannot be used concurrently.\n-            // The lock should be released at the end of the method call.\n-            if (!queryCache.lock(id))\n-                throw new QueryException(DatawaveErrorCode.QUERY_LOCKED_ERROR);\n-            \n-            // We did not allocate a connection when we looked up the query. If\n-            // there's a connection when we get here, then we know it can only be\n-            // because the query was alive and in use, so we need to close that\n-            // connection in order to reset the query. Otherwise, we are truly\n-            // restarting the query, so we should re-audit ().\n-            if (query.getClient() != null) {\n-                query.closeConnection(connectionFactory);\n-            } else {\n-                AuditType auditType = query.getLogic().getAuditType(query.getSettings());\n-                MultivaluedMap<String,String> queryParameters = query.getSettings().toMap();\n-                \n-                queryParameters.putSingle(PrivateAuditConstants.AUDIT_TYPE, auditType.name());\n-                queryParameters.putSingle(PrivateAuditConstants.LOGIC_CLASS, query.getLogic().getLogicName());\n-                queryParameters.putSingle(PrivateAuditConstants.USER_DN, query.getSettings().getUserDN());\n-                queryParameters.putSingle(PrivateAuditConstants.COLUMN_VISIBILITY, query.getSettings().getColumnVisibility());\n-                \n-                if (!auditType.equals(AuditType.NONE)) {\n-                    try {\n-                        try {\n-                            List<String> selectors = query.getLogic().getSelectors(query.getSettings());\n-                            if (selectors != null && !selectors.isEmpty()) {\n-                                queryParameters.put(PrivateAuditConstants.SELECTORS, selectors);\n-                            }\n-                        } catch (Exception e) {\n-                            log.error(\"Error accessing query selector\", e);\n-                        }\n-                        auditor.audit(queryParameters);\n-                    } catch (IllegalArgumentException e) {\n-                        BadRequestQueryException qe = new BadRequestQueryException(DatawaveErrorCode.MISSING_REQUIRED_PARAMETER, e);\n-                        response.addException(qe);\n-                        throw new BadRequestException(qe, response);\n-                    } catch (Exception e) {\n-                        log.error(\"Error auditing query\", e);\n-                        QueryException qe = new QueryException(DatawaveErrorCode.QUERY_AUDITING_ERROR, e);\n-                        response.addException(qe);\n-                        throw qe;\n-                    }\n-                }\n-            }\n-            \n-            // Allocate the connection for this query so we are ready to go when\n-            // they call next.\n-            priority = query.getConnectionPriority();\n-            Map<String,String> trackingMap = connectionFactory.getTrackingMap(Thread.currentThread().getStackTrace());\n-            addQueryToTrackingMap(trackingMap, query.getSettings());\n-            accumuloConnectionRequestBean.requestBegin(id);\n-            try {\n-                client = connectionFactory.getClient(query.getLogic().getConnPoolName(), priority, trackingMap);\n-            } finally {\n-                accumuloConnectionRequestBean.requestEnd(id);\n-            }\n-            query.setClient(client);\n-            response.addMessage(id + \" reset.\");\n-            CreateQuerySessionIDFilter.QUERY_ID.set(id);\n-            return response;\n+          Thread.sleep(2);\n         } catch (InterruptedException e) {\n-            if (query != null) {\n-                query.getMetric().setLifecycle(QueryMetric.Lifecycle.CANCELLED);\n-            }\n-            log.info(\"Query \" + id + \" canceled on request\");\n-            QueryException qe = new QueryException(DatawaveErrorCode.QUERY_CANCELED, e);\n-            response.addException(qe.getBottomQueryException());\n-            int statusCode = qe.getBottomQueryException().getStatusCode();\n-            throw new DatawaveWebApplicationException(qe, response, statusCode);\n-        } catch (Exception e) {\n-            log.error(\"Exception caught on resetting query\", e);\n-            try {\n-                if (null != client) {\n-                    /*\n-                     * if the query exists, we need to make sure the connection isn't set on it because the \"proper\" work flow is to close and/or cancel the\n-                     * query after a failure. we don't want to purge it from the query cache, so setting the connector to null avoids having the connector\n-                     * returned multiple times to the connector pool.\n-                     */\n-                    if (query != null) {\n-                        query.setClient(null);\n-                    }\n-                    connectionFactory.returnClient(client);\n-                }\n-            } catch (Exception e2) {\n-                log.error(\"Error returning connection on failed reset\", e2);\n-            }\n-            QueryException qe = new QueryException(DatawaveErrorCode.QUERY_RESET_ERROR, e);\n-            response.addException(qe.getBottomQueryException());\n-            int statusCode = qe.getBottomQueryException().getStatusCode();\n-            throw new DatawaveWebApplicationException(qe, response, statusCode);\n-        } finally {\n-            queryCache.unlock(id);\n+          // ignore\n+        }\n+\n+        defineSpan.close();\n+\n+        // TODO: not sure this makes any sense anymore in Accumulo 1.8.1\n+        // if (null != defineSpan.parent()) {\n+        // // Stop the main query span since we're done working with it on this thread.\n+        // // We'll continue it later.\n+        // defineSpan.parent().stop();\n+        // }\n+      }\n+    }\n+  }\n+\n+  @Override\n+  @Interceptors({RequiredInterceptor.class, ResponseInterceptor.class})\n+  public GenericResponse<String> createQuery(@Required(\"logicName\") String queryLogicName,\n+                                             MultivaluedMap<String, String> queryParameters) {\n+    return createQuery(queryLogicName, queryParameters, null);\n+  }\n+\n+  /**\n+   * @param queryLogicName\n+   * @param queryParameters\n+   * @return\n+   */\n+  @POST\n+  @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\",\n+      \"application/x-protobuf\",\n+      \"application/x-protostuff\"})\n+  @Path(\"/{logicName}/create\")\n+  @GZIP\n+  @GenerateQuerySessionId(cookieBasePath = \"/DataWave/Query/\")\n+  @EnrichQueryMetrics(methodType = MethodType.CREATE)\n+  @Interceptors({RequiredInterceptor.class, ResponseInterceptor.class})\n+  @Timed(name = \"dw.query.createQuery\", absolute = true)\n+  public GenericResponse<String> createQuery(@Required(\"logicName\") @PathParam(\"logicName\") String queryLogicName,\n+                                             MultivaluedMap<String, String> queryParameters,\n+                                             @Context HttpHeaders httpHeaders) {\n+    CreateQuerySessionIDFilter.QUERY_ID.set(null);\n+\n+    QueryData qd = validateQuery(queryLogicName, queryParameters, httpHeaders);\n+\n+    GenericResponse<String> response = new GenericResponse<>();\n+\n+    Query q = null;\n+    AccumuloClient client = null;\n+    AccumuloConnectionFactory.Priority priority;\n+    TraceScope createSpan = null;\n+    RunningQuery rq = null;\n+    try {\n+      // Default hasResults to true. If a query logic is actually able to set this value,\n+      // then their value will overwrite this one. Otherwise, we return true so that\n+      // callers know they have to call next (even though next may not return results).\n+      response.setHasResults(true);\n+\n+      AuditType auditType = qd.logic.getAuditType(null);\n+      try {\n+        MultivaluedMap<String, String> optionalQueryParameters = qp.getUnknownParameters(queryParameters);\n+        q = persister.create(qd.userDn, qd.dnList, marking, queryLogicName, qp, optionalQueryParameters);\n+        auditType = qd.logic.getAuditType(q);\n+      } finally {\n+        queryParameters.add(PrivateAuditConstants.AUDIT_TYPE, auditType.name());\n+\n+        if (!auditType.equals(AuditType.NONE)) {\n+          // audit the query before its executed.\n+          try {\n             try {\n-                if (ctx.getUserTransaction().getStatus() != Status.STATUS_NO_TRANSACTION) {\n-                    // no reason to commit if transaction not started, ie Query not found exception\n-                    ctx.getUserTransaction().commit();\n-                }\n+              List<String> selectors = qd.logic.getSelectors(q);\n+              if (selectors != null && !selectors.isEmpty()) {\n+                queryParameters.put(PrivateAuditConstants.SELECTORS, selectors);\n+              }\n             } catch (Exception e) {\n-                QueryException qe = new QueryException(DatawaveErrorCode.QUERY_TRANSACTION_ERROR, e);\n-                response.addException(qe.getBottomQueryException());\n-                throw new DatawaveWebApplicationException(qe, response);\n-            } finally {\n-                // Stop timing on this trace, if any\n-                if (span != null) {\n-                    span.close();\n-                }\n+              log.error(\"Error accessing query selector\", e);\n             }\n+            auditor.audit(queryParameters);\n+          } catch (IllegalArgumentException e) {\n+            log.error(\"Error validating audit parameters\", e);\n+            BadRequestQueryException qe = new BadRequestQueryException(DatawaveErrorCode.MISSING_REQUIRED_PARAMETER, e);\n+            response.addException(qe);\n+            throw new BadRequestException(qe, response);\n+          } catch (Exception e) {\n+            log.error(\"Error auditing query\", e);\n+            QueryException qe = new QueryException(DatawaveErrorCode.QUERY_AUDITING_ERROR, e);\n+            response.addException(qe);\n+            throw qe;\n+          }\n         }\n-        \n-    }\n-    \n-    @Override\n-    @Interceptors({ResponseInterceptor.class, RequiredInterceptor.class})\n-    @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)\n-    public BaseQueryResponse createQueryAndNext(String logicName, MultivaluedMap<String,String> queryParameters) {\n-        return createQueryAndNext(logicName, queryParameters, null);\n-    }\n-    \n-    /**\n-     * @param logicName\n-     * @param queryParameters\n-     * @return\n-     */\n-    @POST\n-    @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\", \"application/x-protobuf\",\n-            \"application/x-protostuff\"})\n-    @Path(\"/{logicName}/createAndNext\")\n-    @GZIP\n-    @GenerateQuerySessionId(cookieBasePath = \"/DataWave/Query/\")\n-    @EnrichQueryMetrics(methodType = MethodType.CREATE_AND_NEXT)\n-    @Interceptors({ResponseInterceptor.class, RequiredInterceptor.class})\n-    @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)\n-    @Timed(name = \"dw.query.createAndNext\", absolute = true)\n-    public BaseQueryResponse createQueryAndNext(@Required(\"logicName\") @PathParam(\"logicName\") String logicName, MultivaluedMap<String,String> queryParameters,\n-                    @Context HttpHeaders httpHeaders) {\n-        CreateQuerySessionIDFilter.QUERY_ID.set(null);\n-        \n-        GenericResponse<String> createResponse = createQuery(logicName, queryParameters, httpHeaders);\n-        String queryId = createResponse.getResult();\n-        CreateQuerySessionIDFilter.QUERY_ID.set(queryId);\n-        return next(queryId, false);\n-    }\n-    \n-    @POST\n-    @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\", \"application/x-protobuf\",\n-            \"application/x-protostuff\"})\n-    @Path(\"/{logicName}/async/createAndNext\")\n-    @GZIP\n-    @GenerateQuerySessionId(cookieBasePath = \"/DataWave/Query/\")\n-    @EnrichQueryMetrics(methodType = MethodType.CREATE_AND_NEXT)\n-    @Interceptors({ResponseInterceptor.class, RequiredInterceptor.class})\n-    @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)\n-    @Asynchronous\n-    @Timed(name = \"dw.query.createAndNextAsync\", absolute = true)\n-    public void createQueryAndNextAsync(@Required(\"logicName\") @PathParam(\"logicName\") String logicName, MultivaluedMap<String,String> queryParameters,\n-                    @Suspended AsyncResponse asyncResponse) {\n+      }\n+\n+      priority = qd.logic.getConnectionPriority();\n+      Map<String, String> trackingMap = connectionFactory.getTrackingMap(Thread.currentThread().getStackTrace());\n+      addQueryToTrackingMap(trackingMap, q);\n+      accumuloConnectionRequestBean.requestBegin(q.getId().toString());\n+      try {\n+        client = connectionFactory.getClient(qd.logic.getConnPoolName(), priority, trackingMap);\n+      } finally {\n+        accumuloConnectionRequestBean.requestEnd(q.getId().toString());\n+      }\n+      // If we're supposed to trace this query, then turn tracing on and set information about the query\n+      // onto the span so that it is saved in the trace table.\n+      TraceInfo traceInfo = null;\n+      boolean shouldTraceQuery = shouldTraceQuery(qp.getQuery(), qd.userid, qp.isTrace());\n+      if (shouldTraceQuery) {\n+        TraceScope scope = Trace.startSpan(\"query:\" + q.getId());\n+        long traceId = (scope.getSpan() != null) ? scope.getSpan().getTraceId() : -1;\n+        log.debug(\"Tracing query \" + q.getId() + \" [\" + qp.getQuery() + \"] on trace ID \" + Long.toHexString(traceId));\n+        if (scope.getSpan() != null) {\n+          for (Entry<String, List<String>> param : queryParameters.entrySet()) {\n+            scope.getSpan().addKVAnnotation(param.getKey(), param.getValue().get(0));\n+          }\n+        }\n+        traceInfo = TraceInfo.fromSpan(scope.getSpan());\n+\n+        createSpan = Trace.startSpan(\"query:create\", traceInfo);\n+      }\n+\n+      // hold on to a reference of the query logic so we cancel it if need be.\n+      qlCache.add(q.getId().toString(), qd.userid, qd.logic, client);\n+      rq = new RunningQuery(metrics, null, priority, qd.logic, q, qp.getAuths(), qd.p,\n+          new RunningQueryTimingImpl(queryExpirationConf,\n+              qp.getPageTimeout()), this.executor, this.predictor, this.metricFactory);\n+      rq.setActiveCall(true);\n+      rq.setTraceInfo(traceInfo);\n+      rq.getMetric().setProxyServers(qd.proxyServers);\n+      rq.setClient(client);\n+\n+      // Put in the cache by id. Don't put the cache in by name because multiple users may use the same name\n+      // and only the last one will be in the cache.\n+      queryCache.put(q.getId().toString(), rq);\n+\n+      response.setResult(q.getId().toString());\n+      rq.setActiveCall(false);\n+      CreateQuerySessionIDFilter.QUERY_ID.set(q.getId().toString());\n+      return response;\n+    } catch (Throwable t) {\n+      response.setHasResults(false);\n+\n+      if (rq != null) {\n+        rq.getMetric().setError(t);\n+      }\n+\n+      // close the logic on exception\n+      try {\n+        if (null != qd.logic) {\n+          qd.logic.close();\n+        }\n+      } catch (Exception e) {\n+        log.error(\"Exception occured while closing query logic; may be innocuous if scanners were running.\", e);\n+      }\n+\n+      if (null != client) {\n         try {\n-            BaseQueryResponse response = createQueryAndNext(logicName, queryParameters);\n-            asyncResponse.resume(response);\n-        } catch (Throwable t) {\n-            asyncResponse.resume(t);\n-        }\n-    }\n-    \n-    private BaseQueryResponse _next(RunningQuery query, String queryId, Collection<String> proxyServers, TraceScope span) throws Exception {\n-        // If we're tracing this query, then continue the trace for the next call.\n-        TraceInfo traceInfo = query.getTraceInfo();\n-        if (traceInfo != null) {\n-            span = Trace.startSpan(\"query:next\", traceInfo);\n+          connectionFactory.returnClient(client);\n+        } catch (Exception e) {\n+          log.error(\"Error returning connection on failed create\", e);\n         }\n-        \n-        ResultsPage resultList;\n-        try {\n-            resultList = query.next();\n-        } catch (RejectedExecutionException e) {\n-            // - race condition, query expired while user called next\n-            throw new PreConditionFailedQueryException(DatawaveErrorCode.QUERY_TIMEOUT_OR_SERVER_ERROR, e, MessageFormat.format(\"id = {0}\", queryId));\n-        }\n-        \n-        long pageNum = query.getLastPageNumber();\n-        \n-        BaseQueryResponse response = query.getLogic().getTransformer(query.getSettings()).createResponse(resultList);\n-        if (!resultList.getResults().isEmpty()) {\n-            response.setHasResults(true);\n-        } else {\n-            response.setHasResults(false);\n-        }\n-        response.setPageNumber(pageNum);\n-        response.setLogicName(query.getLogic().getLogicName());\n-        response.setQueryId(queryId);\n-        \n-        if (span != null && span.getSpan() != null) {\n-            span.getSpan().addKVAnnotation(\"pageNumber\", Long.toString(pageNum));\n-        }\n-        \n-        query.getMetric().setProxyServers(proxyServers);\n-        \n-        testForUncaughtException(query.getSettings(), resultList);\n-        \n-        if (resultList.getResults().isEmpty()) {\n-            NoResultsQueryException qe = new NoResultsQueryException(DatawaveErrorCode.NO_QUERY_RESULTS_FOUND, MessageFormat.format(\"{0}\", queryId));\n-            response.addException(qe);\n-            throw new NoResultsException(qe);\n-        } else {\n-            return response;\n+      }\n+      try {\n+        if (null != q) {\n+          persister.remove(q);\n         }\n-        \n-    }\n-    \n-    /**\n-     *\n-     * @param uuid\n-     * @param uuidType\n-     * @param uriInfo\n-     * @param httpHeaders\n-     * @return content results, either as a paged BaseQueryResponse or StreamingOutput\n-     * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user, by specifying a chain of DNs of the identities to proxy\n-     * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n-     * @ResponseHeader query-session-id this header and value will be in the Set-Cookie header, subsequent calls for this session will need to supply the\n-     *                 query-session-id header in the request in a Cookie header or as a query parameter\n-     * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n-     * @ResponseHeader X-Partial-Results true if the page contains less than the requested number of results\n-     *\n-     * @HTTP 200 success\n-     * @HTTP 204 success and no results\n-     * @HTTP 400 invalid or missing parameter\n-     * @HTTP 500 internal server error\n-     */\n-    @GET\n-    @Path(\"/lookupContentUUID/{uuidType}/{uuid}\")\n-    @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\", \"application/x-protobuf\",\n-            \"application/x-protostuff\"})\n-    @Interceptors({RequiredInterceptor.class, ResponseInterceptor.class})\n-    @Override\n-    @Timed(name = \"dw.query.lookupContentUUID\", absolute = true)\n-    public <T> T lookupContentByUUID(@Required(\"uuidType\") @PathParam(\"uuidType\") String uuidType, @Required(\"uuid\") @PathParam(\"uuid\") String uuid,\n-                    @Context UriInfo uriInfo, @Required(\"httpHeaders\") @Context HttpHeaders httpHeaders) {\n-        MultivaluedMapImpl<String,String> queryParameters = new MultivaluedMapImpl<>();\n-        queryParameters.putAll(uriInfo.getQueryParameters());\n-        return this.lookupContentByUUID(uuidType, uuid, queryParameters, httpHeaders);\n-    }\n-    \n-    private <T> T lookupContentByUUID(String uuidType, String uuid, MultivaluedMap<String,String> queryParameters, HttpHeaders httpHeaders) {\n-        T response = null;\n-        String queryId = null;\n-        try {\n-            String streaming = queryParameters.getFirst(\"streaming\");\n-            boolean streamingOutput = false;\n-            if (!StringUtils.isEmpty(streaming)) {\n-                streamingOutput = Boolean.parseBoolean(streaming);\n-            }\n-            // Create the criteria for looking up the respective events, which we need to get the shard IDs and column families\n-            // required for the content lookup\n-            final UUIDType matchingType = this.lookupUUIDUtil.getUUIDType(uuidType.toUpperCase());\n-            final GetUUIDCriteria criteria;\n-            final String view = (null != matchingType) ? matchingType.getDefinedView() : null;\n-            if ((LookupUUIDUtil.UID_QUERY.equals(view) || LookupUUIDUtil.LOOKUP_UID_QUERY.equals(view))) {\n-                criteria = new UIDQueryCriteria(uuid, uuidType, queryParameters);\n-            } else {\n-                criteria = new GetUUIDCriteria(uuid, uuidType, queryParameters);\n-            }\n-            \n-            // Set the HTTP headers if a streamed response is required\n-            if (streamingOutput) {\n-                criteria.setStreamingOutputHeaders(httpHeaders);\n-            }\n-            \n-            response = this.lookupUUIDUtil.lookupContentByUUIDs(criteria);\n-            if (response instanceof BaseQueryResponse) {\n-                queryId = ((BaseQueryResponse) response).getQueryId();\n-            }\n-            return response;\n-        } finally {\n-            if (null != queryId) {\n-                asyncClose(queryId);\n+      } catch (Exception e) {\n+        response.addException(new QueryException(DatawaveErrorCode.DEPERSIST_ERROR, e).getBottomQueryException());\n+      }\n+\n+      /*\n+       * Allow web services to throw their own WebApplicationExceptions\n+       */\n+      if (t instanceof Error && !(t instanceof TokenMgrError)) {\n+        log.error(t.getMessage(), t);\n+        throw (Error) t;\n+      } else if (t instanceof WebApplicationException) {\n+        log.error(t.getMessage(), t);\n+        throw ((WebApplicationException) t);\n+      } else if (t instanceof InterruptedException) {\n+        if (rq != null) {\n+          rq.getMetric().setLifecycle(QueryMetric.Lifecycle.CANCELLED);\n+        }\n+        log.info(\"Query \" + q.getId() + \" canceled on request\");\n+        QueryException qe = new QueryException(DatawaveErrorCode.QUERY_CANCELED, t);\n+        response.addException(qe.getBottomQueryException());\n+        int statusCode = qe.getBottomQueryException().getStatusCode();\n+        throw new DatawaveWebApplicationException(qe, response, statusCode);\n+      } else {\n+        log.error(t.getMessage(), t);\n+        QueryException qe = new QueryException(DatawaveErrorCode.RUNNING_QUERY_CACHE_ERROR, t);\n+        response.addException(qe.getBottomQueryException());\n+        int statusCode = qe.getBottomQueryException().getStatusCode();\n+        throw new DatawaveWebApplicationException(qe, response, statusCode);\n+      }\n+    } finally {\n+      if (createSpan != null) {\n+        createSpan.close();\n+        // TODO: not sure this makes any sense anymore in Accumulo 1.8.1\n+        // Stop the main query span since we're done working with it on this thread.\n+        // We'll continue it later.\n+        // createSpan.parent().stop();\n+      }\n+      if (null != q) {\n+        // - Remove the logic from the cache\n+        qlCache.poll(q.getId().toString());\n+      }\n+    }\n+  }\n+\n+  /**\n+   * @param queryLogicName\n+   * @param queryParameters\n+   * @return\n+   */\n+  @POST\n+  @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\",\n+      \"application/x-protobuf\",\n+      \"application/x-protostuff\"})\n+  @Path(\"/{logicName}/plan\")\n+  @Interceptors({RequiredInterceptor.class, ResponseInterceptor.class})\n+  @Timed(name = \"dw.query.planQuery\", absolute = true)\n+  public GenericResponse<String> planQuery(@Required(\"logicName\") @PathParam(\"logicName\") String queryLogicName,\n+                                           MultivaluedMap<String, String> queryParameters) {\n+    QueryData qd = validateQuery(queryLogicName, queryParameters, null);\n+\n+    GenericResponse<String> response = new GenericResponse<>();\n+\n+    Query q = null;\n+    AccumuloClient client = null;\n+    AccumuloConnectionFactory.Priority priority;\n+    try {\n+      // Default hasResults to true.\n+      response.setHasResults(true);\n+\n+      // by default we will expand the fields but not the values.\n+      boolean expandFields = true;\n+      boolean expandValues = false;\n+      if (queryParameters.containsKey(EXPAND_FIELDS)) {\n+        expandFields = Boolean.valueOf(queryParameters.getFirst(EXPAND_FIELDS));\n+      }\n+      if (queryParameters.containsKey(EXPAND_VALUES)) {\n+        expandValues = Boolean.valueOf(queryParameters.getFirst(EXPAND_VALUES));\n+      }\n+\n+      AuditType auditType = qd.logic.getAuditType(null);\n+      try {\n+        MultivaluedMap<String, String> optionalQueryParameters = qp.getUnknownParameters(queryParameters);\n+        q = persister.create(qd.userDn, qd.dnList, marking, queryLogicName, qp, optionalQueryParameters);\n+        auditType = qd.logic.getAuditType(q);\n+      } finally {\n+        queryParameters.add(PrivateAuditConstants.AUDIT_TYPE, auditType.name());\n+\n+        // on audit if needed, and we are using the index to expand the values\n+        if (expandValues && !auditType.equals(AuditType.NONE)) {\n+          // audit the query before its executed.\n+          try {\n+            try {\n+              List<String> selectors = qd.logic.getSelectors(q);\n+              if (selectors != null && !selectors.isEmpty()) {\n+                queryParameters.put(PrivateAuditConstants.SELECTORS, selectors);\n+              }\n+            } catch (Exception e) {\n+              log.error(\"Error accessing query selector\", e);\n             }\n+            auditor.audit(queryParameters);\n+          } catch (IllegalArgumentException e) {\n+            log.error(\"Error validating audit parameters\", e);\n+            BadRequestQueryException qe = new BadRequestQueryException(DatawaveErrorCode.MISSING_REQUIRED_PARAMETER, e);\n+            response.addException(qe);\n+            throw new BadRequestException(qe, response);\n+          } catch (Exception e) {\n+            log.error(\"Error auditing query\", e);\n+            QueryException qe = new QueryException(DatawaveErrorCode.QUERY_AUDITING_ERROR, e);\n+            response.addException(qe);\n+            throw qe;\n+          }\n         }\n-    }\n-    \n-    /**\n-     *\n-     * @param queryParameters\n-     * @param httpHeaders\n-     * @return content results, either as a paged BaseQueryResponse or StreamingOutput\n-     * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user, by specifying a chain of DNs of the identities to proxy\n-     * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n-     * @ResponseHeader query-session-id this header and value will be in the Set-Cookie header, subsequent calls for this session will need to supply the\n-     *                 query-session-id header in the request in a Cookie header or as a query parameter\n-     * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n-     * @ResponseHeader X-Partial-Results true if the page contains less than the requested number of results\n-     *\n-     * @HTTP 200 success\n-     * @HTTP 204 success and no results\n-     * @HTTP 400 invalid or missing parameter\n-     * @HTTP 500 internal server error\n-     */\n-    @POST\n-    @Path(\"/lookupContentUUID\")\n-    @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\", \"application/x-protobuf\",\n-            \"application/x-protostuff\"})\n-    @GZIP\n-    @GenerateQuerySessionId(cookieBasePath = \"/DataWave/Query/\")\n-    @Interceptors({ResponseInterceptor.class, RequiredInterceptor.class})\n-    @Override\n-    @Timed(name = \"dw.query.lookupContentUUIDBatch\", absolute = true)\n-    public <T> T lookupContentByUUIDBatch(MultivaluedMap<String,String> queryParameters, HttpHeaders httpHeaders) {\n-        if (!queryParameters.containsKey(\"uuidPairs\")) {\n-            throw new BadRequestException(new IllegalArgumentException(\"uuidPairs missing from query parameters\"), new VoidResponse());\n-        }\n-        T response = null;\n-        String queryId = null;\n+      }\n+\n+      priority = qd.logic.getConnectionPriority();\n+      Map<String, String> trackingMap = connectionFactory.getTrackingMap(Thread.currentThread().getStackTrace());\n+      addQueryToTrackingMap(trackingMap, q);\n+      accumuloConnectionRequestBean.requestBegin(q.getId().toString());\n+      try {\n+        client = connectionFactory.getClient(qd.logic.getConnPoolName(), priority, trackingMap);\n+      } finally {\n+        accumuloConnectionRequestBean.requestEnd(q.getId().toString());\n+      }\n+\n+      Set<Authorizations> calculatedAuths = AuthorizationsUtil.getDowngradedAuthorizations(qp.getAuths(), qd.p);\n+      String plan = qd.logic.getPlan(client, q, calculatedAuths, expandFields, expandValues);\n+      response.setResult(plan);\n+\n+      return response;\n+    } catch (Throwable t) {\n+      response.setHasResults(false);\n+\n+      /*\n+       * Allow web services to throw their own WebApplicationExceptions\n+       */\n+      if (t instanceof Error && !(t instanceof TokenMgrError)) {\n+        log.error(t.getMessage(), t);\n+        throw (Error) t;\n+      } else if (t instanceof WebApplicationException) {\n+        log.error(t.getMessage(), t);\n+        throw ((WebApplicationException) t);\n+      } else {\n+        log.error(t.getMessage(), t);\n+        QueryException qe = new QueryException(DatawaveErrorCode.QUERY_PLAN_ERROR, t);\n+        response.addException(qe.getBottomQueryException());\n+        int statusCode = qe.getBottomQueryException().getStatusCode();\n+        throw new DatawaveWebApplicationException(qe, response, statusCode);\n+      }\n+    } finally {\n+      if (client != null) {\n         try {\n-            String uuidPairs = queryParameters.getFirst(\"uuidPairs\");\n-            String streaming = queryParameters.getFirst(\"streaming\");\n-            boolean streamingOutput = false;\n-            if (!StringUtils.isEmpty(streaming)) {\n-                streamingOutput = Boolean.parseBoolean(streaming);\n-            }\n-            // Create the criteria for looking up the respective events, which we need to get the shard IDs and column families\n-            // required for the content lookup\n-            final PostUUIDCriteria criteria = new PostUUIDCriteria(uuidPairs, queryParameters);\n-            \n-            // Set the HTTP headers if a streamed response is required\n-            if (streamingOutput) {\n-                criteria.setStreamingOutputHeaders(httpHeaders);\n-            }\n-            \n-            response = this.lookupUUIDUtil.lookupContentByUUIDs(criteria);\n-            if (response instanceof BaseQueryResponse) {\n-                queryId = ((BaseQueryResponse) response).getQueryId();\n-            }\n-            return response;\n-        } finally {\n-            if (null != queryId) {\n-                asyncClose(queryId);\n-            }\n+          connectionFactory.returnClient(client);\n+        } catch (Exception e) {\n+          log.error(\"Failed to close connection for \" + q.getId(), e);\n         }\n-    }\n-    \n-    /**\n-     *\n-     * @param uuidType\n-     * @param uuid\n-     * @param uriInfo\n-     * @param httpHeaders\n-     * @return\n-     * @return event results, either as a paged BaseQueryResponse (automatically closed upon return) or StreamingOutput\n-     * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user, by specifying a chain of DNs of the identities to proxy\n-     * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n-     * @ResponseHeader query-session-id this header and value will be in the Set-Cookie header, subsequent calls for this session will need to supply the\n-     *                 query-session-id header in the request in a Cookie header or as a query parameter\n-     * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n-     * @ResponseHeader X-Partial-Results true if the page contains less than the requested number of results\n-     *\n-     * @HTTP 200 success\n-     * @HTTP 204 success and no results\n-     * @HTTP 400 invalid or missing parameter\n-     * @HTTP 500 internal server error\n-     */\n-    @GET\n-    @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\", \"application/x-protobuf\",\n-            \"application/x-protostuff\"})\n-    @Path(\"/lookupUUID/{uuidType}/{uuid}\")\n-    @Interceptors({RequiredInterceptor.class, ResponseInterceptor.class})\n-    @Override\n-    @Timed(name = \"dw.query.lookupUUID\", absolute = true)\n-    public <T> T lookupUUID(@Required(\"uuidType\") @PathParam(\"uuidType\") String uuidType, @Required(\"uuid\") @PathParam(\"uuid\") String uuid,\n-                    @Context UriInfo uriInfo, @Required(\"httpHeaders\") @Context HttpHeaders httpHeaders) {\n-        MultivaluedMapImpl<String,String> queryParameters = new MultivaluedMapImpl<>();\n-        queryParameters.putAll(uriInfo.getQueryParameters());\n-        return this.lookupUUID(uuidType, uuid, queryParameters, httpHeaders);\n-    }\n-    \n-    <T> T lookupUUID(String uuidType, String uuid, MultivaluedMap<String,String> queryParameters, HttpHeaders httpHeaders) {\n-        String streaming = queryParameters.getFirst(\"streaming\");\n-        boolean streamingOutput = false;\n-        if (!StringUtils.isEmpty(streaming)) {\n-            streamingOutput = Boolean.parseBoolean(streaming);\n-        }\n-        final UUIDType matchingType = this.lookupUUIDUtil.getUUIDType(uuidType);\n-        String queryId = null;\n-        T response;\n+      }\n+\n+      // close the logic on exception\n+      try {\n+        if (null != qd.logic) {\n+          qd.logic.close();\n+        }\n+      } catch (Exception e) {\n+        log.error(\"Exception occured while closing query logic; may be innocuous if scanners were running.\", e);\n+      }\n+\n+      if (null != client) {\n         try {\n-            // Construct the criteria used to perform the query\n-            final GetUUIDCriteria criteria;\n-            final String view = (null != matchingType) ? matchingType.getDefinedView() : null;\n-            if ((LookupUUIDUtil.UID_QUERY.equals(view) || LookupUUIDUtil.LOOKUP_UID_QUERY.equals(view))) {\n-                criteria = new UIDQueryCriteria(uuid, uuidType, queryParameters);\n-            } else {\n-                criteria = new GetUUIDCriteria(uuid, uuidType, queryParameters);\n-            }\n-            \n-            // Add the HTTP headers in case streaming is required\n-            if (streamingOutput) {\n-                criteria.setStreamingOutputHeaders(httpHeaders);\n-            }\n-            \n-            // Perform the query and get the first set of results\n-            response = this.lookupUUIDUtil.createUUIDQueryAndNext(criteria);\n-            if (response instanceof BaseQueryResponse) {\n-                queryId = ((BaseQueryResponse) response).getQueryId();\n-            }\n-            return response;\n-        } finally {\n-            if (null != queryId) {\n-                asyncClose(queryId);\n-            }\n+          connectionFactory.returnClient(client);\n+        } catch (Exception e) {\n+          log.error(\"Error returning connection on failed create\", e);\n         }\n+      }\n     }\n-    \n-    /**\n-     *\n-     * @param queryParameters\n-     * @param httpHeaders\n-     * @return event results, either as a paged BaseQueryResponse or StreamingOutput\n-     * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user, by specifying a chain of DNs of the identities to proxy\n-     * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n-     * @ResponseHeader query-session-id this header and value will be in the Set-Cookie header, subsequent calls for this session will need to supply the\n-     *                 query-session-id header in the request in a Cookie header or as a query parameter\n-     * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n-     * @ResponseHeader X-Partial-Results true if the page contains less than the requested number of results\n-     *\n-     * @HTTP 200 success\n-     * @HTTP 204 success and no results\n-     * @HTTP 400 invalid or missing parameter\n-     * @HTTP 500 internal server error\n-     */\n-    @POST\n-    @Path(\"/lookupUUID\")\n-    @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\", \"application/x-protobuf\",\n-            \"application/x-protostuff\"})\n-    @GZIP\n-    @GenerateQuerySessionId(cookieBasePath = \"/DataWave/Query/\")\n-    @Interceptors({ResponseInterceptor.class, RequiredInterceptor.class})\n-    @Override\n-    @Timed(name = \"dw.query.lookupUUIDBatch\", absolute = true)\n-    public <T> T lookupUUIDBatch(MultivaluedMap<String,String> queryParameters, @Required(\"httpHeaders\") @Context HttpHeaders httpHeaders) {\n-        if (!queryParameters.containsKey(\"uuidPairs\")) {\n-            throw new BadRequestException(new IllegalArgumentException(\"uuidPairs missing from query parameters\"), new VoidResponse());\n+  }\n+\n+  /**\n+   * @param queryLogicName\n+   * @param queryParameters\n+   * @return query predictions\n+   */\n+  @POST\n+  @Path(\"/{logicName}/predict\")\n+  @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\",\n+      \"application/x-protobuf\",\n+      \"application/x-protostuff\"})\n+  @Interceptors({RequiredInterceptor.class, ResponseInterceptor.class})\n+  @Timed(name = \"dw.query.predictQuery\", absolute = true)\n+  public GenericResponse<String> predictQuery(@Required(\"logicName\") @PathParam(\"logicName\") String queryLogicName,\n+                                              MultivaluedMap<String, String> queryParameters) {\n+\n+    CreateQuerySessionIDFilter.QUERY_ID.set(null);\n+\n+    QueryData qd = validateQuery(queryLogicName, queryParameters, null);\n+\n+    GenericResponse<String> response = new GenericResponse<>();\n+\n+    if (predictor != null) {\n+      try {\n+        qp.setPersistenceMode(QueryPersistence.TRANSIENT);\n+        MultivaluedMap<String, String> optionalQueryParameters = qp.getUnknownParameters(queryParameters);\n+        Query q = persister.create(qd.userDn, qd.dnList, marking, queryLogicName, qp, optionalQueryParameters);\n+\n+        BaseQueryMetric metric = metricFactory.createMetric();\n+        q.populateMetric(metric);\n+        metric.setQueryType(RunningQuery.class.getSimpleName());\n+\n+        Set<Prediction> predictions = predictor.predict(metric);\n+        if (predictions != null && !predictions.isEmpty()) {\n+          String predictionString = predictions.toString();\n+          // now we have a predictions, lets broadcast\n+          log.info(\"Model predictions: \" + predictionString);\n+          response.setHasResults(true);\n+          response.setResult(predictionString);\n+        } else {\n+          response.setHasResults(false);\n         }\n-        T response;\n-        String queryId = null;\n-        try {\n-            String uuidPairs = queryParameters.getFirst(\"uuidPairs\");\n-            String streaming = queryParameters.getFirst(\"streaming\");\n-            boolean streamingOutput = false;\n-            if (!StringUtils.isEmpty(streaming)) {\n-                streamingOutput = Boolean.parseBoolean(streaming);\n-            }\n-            final PostUUIDCriteria criteria = new PostUUIDCriteria(uuidPairs, queryParameters);\n-            if (streamingOutput) {\n-                criteria.setStreamingOutputHeaders(httpHeaders);\n-            }\n-            response = this.lookupUUIDUtil.createUUIDQueryAndNext(criteria);\n-            if (response instanceof BaseQueryResponse) {\n-                queryId = ((BaseQueryResponse) response).getQueryId();\n-            }\n-            return response;\n-        } finally {\n-            if (null != queryId) {\n-                asyncClose(queryId);\n-            }\n+      } catch (Throwable t) {\n+        response.setHasResults(false);\n+\n+        /*\n+         * Allow web services to throw their own WebApplicationExceptions\n+         */\n+\n+        if (t instanceof Error && !(t instanceof TokenMgrError)) {\n+          log.error(t.getMessage(), t);\n+          throw (Error) t;\n+        } else if (t instanceof WebApplicationException) {\n+          log.error(t.getMessage(), t);\n+          throw ((WebApplicationException) t);\n+        } else {\n+          log.error(t.getMessage(), t);\n+          QueryException qe = new QueryException(DatawaveErrorCode.QUERY_PREDICTIONS_ERROR, t);\n+          response.addException(qe.getBottomQueryException());\n+          int statusCode = qe.getBottomQueryException().getStatusCode();\n+          throw new DatawaveWebApplicationException(qe, response, statusCode);\n         }\n-        \n+\n+      }\n+    } else {\n+      response.setHasResults(false);\n     }\n-    \n-    /**\n-     * Pulls back the current plan for a query.\n-     *\n-     * @param id\n-     *            - (@Required)\n-     *\n-     * @return GenericResponse containing plan\n-     * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user, by specifying a chain of DNs of the identities to proxy\n-     * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n-     * @RequestHeader query-session-id session id value used for load balancing purposes. query-session-id can be placed in the request in a Cookie header or as\n-     *                a query parameter\n-     * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n-     *\n-     * @HTTP 200 success\n-     * @HTTP 204 success and no results\n-     * @HTTP 404 if id not found\n-     * @HTTP 412 if the query is no longer alive, client should call {@link #reset(String)} and try again\n-     * @HTTP 500 internal server error\n-     */\n-    @GET\n-    @Path(\"/{id}/plan\")\n-    @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\", \"application/x-protobuf\",\n-            \"application/x-protostuff\"})\n-    @GZIP\n-    @Interceptors({ResponseInterceptor.class, RequiredInterceptor.class})\n-    @Override\n-    @Timed(name = \"dw.query.plan\", absolute = true)\n-    public GenericResponse<String> plan(@Required(\"id\") @PathParam(\"id\") String id) {\n-        // in case we don't make it to creating the response from the QueryLogic\n-        GenericResponse<String> response = new GenericResponse<>();\n-        \n-        Principal p = ctx.getCallerPrincipal();\n-        String userid = p.getName();\n-        if (p instanceof DatawavePrincipal) {\n-            DatawavePrincipal dp = (DatawavePrincipal) p;\n-            userid = dp.getShortName();\n-        }\n-        \n-        try {\n-            // Not calling getQueryById() here. We don't want to pull the persisted definition.\n-            RunningQuery query = queryCache.get(id);\n-            \n-            // When we pulled the query from the cache, we told it not to allocate a connection.\n-            // So if the connection is null here, then either the query wasn't in the cache\n-            // at all, or it was but only because of a call to list. In either case, it's\n-            // an error.\n-            if (null == query || null == query.getClient()) {\n-                // If the query just wasn't in the cache, then check the persister to see if the\n-                // ID exists at all. If it doesn't, then we need to return a 404 rather than 412\n-                // status code.\n-                if (null == query) {\n-                    List<Query> queries = persister.findById(id);\n-                    if (queries == null || queries.size() != 1) {\n-                        throw new NotFoundQueryException(DatawaveErrorCode.NO_QUERY_OBJECT_MATCH, MessageFormat.format(\"{0}\", id));\n-                    }\n-                }\n-                \n-                throw new PreConditionFailedQueryException(DatawaveErrorCode.QUERY_TIMEOUT_OR_SERVER_ERROR, MessageFormat.format(\"id = {0}\", id));\n-            } else {\n-                // Validate the query belongs to the caller\n-                if (!query.getSettings().getOwner().equals(userid)) {\n-                    throw new UnauthorizedQueryException(DatawaveErrorCode.QUERY_OWNER_MISMATCH, MessageFormat.format(\"{0} != {1}\", userid, query.getSettings()\n-                                    .getOwner()));\n-                }\n-                \n-                // pull the plan out of the query metric\n-                String plan = query.getMetric().getPlan();\n-                if (plan != null) {\n-                    response.setResult(plan);\n-                    response.setHasResults(true);\n-                }\n-            }\n-        } catch (Exception e) {\n-            log.error(\"Failed to get query plan\", e);\n-            \n-            QueryException qe = new QueryException(DatawaveErrorCode.QUERY_PLAN_ERROR, e, MessageFormat.format(\"query id: {0}\", id));\n-            log.error(qe, e);\n-            response.addException(qe.getBottomQueryException());\n-            int statusCode = qe.getBottomQueryException().getStatusCode();\n-            throw new DatawaveWebApplicationException(qe, response, statusCode);\n-        }\n-        \n-        return response;\n+    return response;\n+  }\n+\n+  @POST\n+  @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\",\n+      \"application/x-protobuf\",\n+      \"application/x-protostuff\"})\n+  @Path(\"/{logicName}/async/create\")\n+  @GZIP\n+  @GenerateQuerySessionId(cookieBasePath = \"/DataWave/Query/\")\n+  @EnrichQueryMetrics(methodType = MethodType.CREATE)\n+  @Interceptors({RequiredInterceptor.class, ResponseInterceptor.class})\n+  @Asynchronous\n+  @Timed(name = \"dw.query.createQueryAsync\", absolute = true)\n+  public void createQueryAsync(@Required(\"logicName\") @PathParam(\"logicName\") String queryLogicName,\n+                               MultivaluedMap<String, String> queryParameters,\n+                               @Suspended AsyncResponse asyncResponse) {\n+    try {\n+      GenericResponse<String> response = createQuery(queryLogicName, queryParameters);\n+      asyncResponse.resume(response);\n+    } catch (Throwable t) {\n+      asyncResponse.resume(t);\n+    }\n+  }\n+\n+  private List<RunningQuery> getQueryByName(String name) throws Exception {\n+    // Find out who/what called this method\n+    Principal p = ctx.getCallerPrincipal();\n+    String userid = p.getName();\n+    if (p instanceof DatawavePrincipal) {\n+      DatawavePrincipal dp = (DatawavePrincipal) p;\n+      userid = dp.getShortName();\n+    }\n+    log.trace(userid + \" has authorizations \" +\n+        ((p instanceof DatawavePrincipal) ? ((DatawavePrincipal) p).getAuthorizations() : \"\"));\n+    List<RunningQuery> results = new ArrayList<>();\n+\n+    List<Query> queries = persister.findByName(name);\n+    if (null == queries) {\n+      throw new NotFoundQueryException(DatawaveErrorCode.NO_QUERY_OBJECT_MATCH);\n     }\n-    \n-    /**\n-     * Pulls back the current predictions for a query.\n-     *\n-     * @param id\n-     *            - (@Required)\n-     *\n-     * @return GenericResponse containing predictions\n-     * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user, by specifying a chain of DNs of the identities to proxy\n-     * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n-     * @RequestHeader query-session-id session id value used for load balancing purposes. query-session-id can be placed in the request in a Cookie header or as\n-     *                a query parameter\n-     * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n-     *\n-     * @HTTP 200 success\n-     * @HTTP 204 success and no results\n-     * @HTTP 404 if id not found\n-     * @HTTP 412 if the query is no longer alive, client should call {@link #reset(String)} and try again\n-     * @HTTP 500 internal server error\n-     */\n-    @GET\n-    @Path(\"/{id}/predictions\")\n-    @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\", \"application/x-protobuf\",\n-            \"application/x-protostuff\"})\n-    @GZIP\n-    @Interceptors({ResponseInterceptor.class, RequiredInterceptor.class})\n-    @Override\n-    @Timed(name = \"dw.query.predictions\", absolute = true)\n-    public GenericResponse<String> predictions(@Required(\"id\") @PathParam(\"id\") String id) {\n-        // in case we don't make it to creating the response from the QueryLogic\n-        GenericResponse<String> response = new GenericResponse<>();\n-        \n-        Principal p = ctx.getCallerPrincipal();\n-        String userid = p.getName();\n-        if (p instanceof DatawavePrincipal) {\n-            DatawavePrincipal dp = (DatawavePrincipal) p;\n-            userid = dp.getShortName();\n-        }\n-        \n-        try {\n-            // Not calling getQueryById() here. We don't want to pull the persisted definition.\n-            RunningQuery query = queryCache.get(id);\n-            \n-            // When we pulled the query from the cache, we told it not to allocate a connection.\n-            // So if the connection is null here, then either the query wasn't in the cache\n-            // at all, or it was but only because of a call to list. In either case, it's\n-            // an error.\n-            if (null == query || null == query.getClient()) {\n-                // If the query just wasn't in the cache, then check the persister to see if the\n-                // ID exists at all. If it doesn't, then we need to return a 404 rather than 412\n-                // status code.\n-                if (null == query) {\n-                    List<Query> queries = persister.findById(id);\n-                    if (queries == null || queries.size() != 1) {\n-                        throw new NotFoundQueryException(DatawaveErrorCode.NO_QUERY_OBJECT_MATCH, MessageFormat.format(\"{0}\", id));\n-                    }\n-                }\n-                \n-                throw new PreConditionFailedQueryException(DatawaveErrorCode.QUERY_TIMEOUT_OR_SERVER_ERROR, MessageFormat.format(\"id = {0}\", id));\n-            } else {\n-                // Validate the query belongs to the caller\n-                if (!query.getSettings().getOwner().equals(userid)) {\n-                    throw new UnauthorizedQueryException(DatawaveErrorCode.QUERY_OWNER_MISMATCH, MessageFormat.format(\"{0} != {1}\", userid, query.getSettings()\n-                                    .getOwner()));\n-                }\n-                \n-                // pull the predictions out of the query metric\n-                Set<Prediction> predictions = query.getMetric().getPredictions();\n-                if (predictions != null && !predictions.isEmpty()) {\n-                    response.setResult(predictions.toString());\n-                    response.setHasResults(true);\n-                }\n-            }\n-        } catch (Exception e) {\n-            log.error(\"Failed to get query predictions\", e);\n-            \n-            QueryException qe = new QueryException(DatawaveErrorCode.QUERY_PREDICTIONS_ERROR, e, MessageFormat.format(\"query id: {0}\", id));\n-            log.error(qe, e);\n-            response.addException(qe.getBottomQueryException());\n-            int statusCode = qe.getBottomQueryException().getStatusCode();\n-            throw new DatawaveWebApplicationException(qe, response, statusCode);\n-        }\n-        \n-        return response;\n+\n+    for (Query q : queries) {\n+      // Check to make sure that this query belongs to current user.\n+      // Not sure this can ever happen with the current persister. It scans with a range set to your userid, so you\n+      // never get back other people queries. Leaving for now just in case the persister changes.\n+      if (!q.getOwner().equals(userid)) {\n+        throw new UnauthorizedQueryException(DatawaveErrorCode.QUERY_OWNER_MISMATCH,\n+            MessageFormat.format(\"{0} != {1}\", userid, q.getOwner()));\n+      }\n+\n+      // will throw IllegalArgumentException if not defined\n+      QueryLogic<?> logic = queryLogicFactory.getQueryLogic(q.getQueryLogicName(), p);\n+      AccumuloConnectionFactory.Priority priority = logic.getConnectionPriority();\n+      RunningQuery query =\n+          new RunningQuery(metrics, null, priority, logic, q, q.getQueryAuthorizations(), p, new RunningQueryTimingImpl(\n+              queryExpirationConf, qp.getPageTimeout()), this.executor, this.predictor, this.metricFactory);\n+      results.add(query);\n+      // Put in the cache by id if its not already in the cache.\n+      if (!queryCache.containsKey(q.getId().toString())) {\n+        queryCache.put(q.getId().toString(), query);\n+      }\n+    }\n+    return results;\n+  }\n+\n+  private RunningQuery getQueryById(String id) throws Exception {\n+    return getQueryById(id, ctx.getCallerPrincipal());\n+  }\n+\n+  private RunningQuery getQueryById(String id, Principal principal) throws Exception {\n+    // Find out who/what called this method\n+    String userid = principal.getName();\n+    if (principal instanceof DatawavePrincipal) {\n+      DatawavePrincipal dp = (DatawavePrincipal) principal;\n+      userid = dp.getShortName();\n+    }\n+    log.trace(userid + \" has authorizations \" +\n+        ((principal instanceof DatawavePrincipal) ? ((DatawavePrincipal) principal).getAuthorizations() : \"\"));\n+\n+    RunningQuery query = queryCache.get(id);\n+    if (null == query) {\n+      log.info(\"Query not found in cache, retrieving from accumulo\");\n+      List<Query> queries = persister.findById(id);\n+      if (null == queries || queries.isEmpty()) {\n+        throw new NotFoundQueryException(DatawaveErrorCode.NO_QUERY_OBJECT_MATCH);\n+      }\n+      if (queries.size() > 1) {\n+        throw new NotFoundQueryException(DatawaveErrorCode.TOO_MANY_QUERY_OBJECT_MATCHES);\n+      } else {\n+        Query q = queries.get(0);\n+\n+        // will throw IllegalArgumentException if not defined\n+        QueryLogic<?> logic = queryLogicFactory.getQueryLogic(q.getQueryLogicName(), principal);\n+        AccumuloConnectionFactory.Priority priority = logic.getConnectionPriority();\n+        query = new RunningQuery(metrics, null, priority, logic, q, q.getQueryAuthorizations(), principal,\n+            new RunningQueryTimingImpl(\n+                queryExpirationConf, qp.getPageTimeout()), this.executor, this.predictor, this.metricFactory);\n+        // Put in the cache by id and name, we will have two copies that reference the same object\n+        queryCache.put(q.getId().toString(), query);\n+      }\n+    } else {\n+      // Check to make sure that this query belongs to current user.\n+      if (!query.getSettings().getOwner().equals(userid)) {\n+        throw new UnauthorizedQueryException(DatawaveErrorCode.QUERY_OWNER_MISMATCH,\n+            MessageFormat.format(\"{0} != {1}\", userid, query.getSettings()\n+                .getOwner()));\n+      }\n+    }\n+    return query;\n+  }\n+\n+  private RunningQuery adminGetQueryById(String id) throws Exception {\n+    RunningQuery query = queryCache.get(id);\n+\n+    if (query == null) {\n+      log.info(\"Query not found in cache, retrieving from accumulo\");\n+      List<Query> queries = persister.adminFindById(id);\n+\n+      if (queries == null || queries.isEmpty()) {\n+        throw new NotFoundQueryException(DatawaveErrorCode.NO_QUERY_OBJECT_MATCH);\n+      }\n+      if (queries.size() > 1) {\n+        throw new NotFoundQueryException(DatawaveErrorCode.TOO_MANY_QUERY_OBJECT_MATCHES);\n+      }\n+\n+      Query q = queries.get(0);\n+\n+      final String auths = q.getQueryAuthorizations();\n+\n+      // will throw IllegalArgumentException if not defined\n+      final QueryLogic<?> logic = queryLogicFactory.getQueryLogic(q.getQueryLogicName(), ctx.getCallerPrincipal());\n+      final AccumuloConnectionFactory.Priority priority = logic.getConnectionPriority();\n+      query = RunningQuery.createQueryWithAuthorizations(metrics, null, priority, logic, q, auths,\n+          new RunningQueryTimingImpl(queryExpirationConf, qp.getPageTimeout()), this.executor, this.predictor,\n+          this.metricFactory);\n+\n+      // Put in the cache by id and name, we will have two copies that reference the same object\n+      queryCache.put(q.getId().toString(), query);\n     }\n-    \n-    /**\n-     * Attempt to async close a query using the executor. If the executor can't accommodate the close then the query will be closed in-line\n-     * \n-     * @param queryId\n-     *            non-null queryId\n-     */\n-    private void asyncClose(String queryId) {\n-        if (queryId != null) {\n-            final Principal p = ctx.getCallerPrincipal();\n-            final String closeQueryId = queryId;\n+\n+    return query;\n+  }\n+\n+  /**\n+   * Resets the query named by {@code id}. If the query is not alive, meaning that the current session has expired (due to either timeout, or server failure),\n+   * then this will reload the query and start it over. If the query is alive, it closes it and starts the query over.\n+   *\n+   * @param id the ID of the query to reload/reset\n+   * @return an empty response\n+   * @return datawave.webservice.result.VoidResponse\n+   * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user, by specifying a chain of DNs of the identities to proxy\n+   * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n+   * @ResponseHeader query-session-id this header and value will be in the Set-Cookie header, subsequent calls for this session will need to supply the\n+   * query-session-id header in the request in a Cookie header or as a query parameter\n+   * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n+   * @HTTP 200 success\n+   * @HTTP 400 invalid or missing parameter\n+   * @HTTP 500 internal server error\n+   */\n+  @PUT\n+  @POST\n+  @Path(\"/{id}/reset\")\n+  @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\",\n+      \"application/x-protobuf\",\n+      \"application/x-protostuff\"})\n+  @GZIP\n+  @GenerateQuerySessionId(cookieBasePath = \"/DataWave/Query/\")\n+  @Interceptors({ResponseInterceptor.class, RequiredInterceptor.class})\n+  @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)\n+  @Override\n+  @Timed(name = \"dw.query.reset\", absolute = true)\n+  public VoidResponse reset(@Required(\"id\") @PathParam(\"id\") String id) {\n+    CreateQuerySessionIDFilter.QUERY_ID.set(null);\n+    VoidResponse response = new VoidResponse();\n+    AccumuloConnectionFactory.Priority priority;\n+\n+    AccumuloClient client = null;\n+    RunningQuery query = null;\n+    TraceScope span = null;\n+\n+    try {\n+      ctx.getUserTransaction().begin();\n+\n+      query = getQueryById(id);\n+\n+      // If we're tracing this query, then continue the trace for the reset call.\n+      TraceInfo traceInfo = query.getTraceInfo();\n+      if (traceInfo != null) {\n+        span = Trace.startSpan(\"query:reset\", traceInfo);\n+      }\n+\n+      // Lock this so that this query cannot be used concurrently.\n+      // The lock should be released at the end of the method call.\n+      if (!queryCache.lock(id)) {\n+        throw new QueryException(DatawaveErrorCode.QUERY_LOCKED_ERROR);\n+      }\n+\n+      // We did not allocate a connection when we looked up the query. If\n+      // there's a connection when we get here, then we know it can only be\n+      // because the query was alive and in use, so we need to close that\n+      // connection in order to reset the query. Otherwise, we are truly\n+      // restarting the query, so we should re-audit ().\n+      if (query.getClient() != null) {\n+        query.closeConnection(connectionFactory);\n+      } else {\n+        AuditType auditType = query.getLogic().getAuditType(query.getSettings());\n+        MultivaluedMap<String, String> queryParameters = query.getSettings().toMap();\n+\n+        queryParameters.putSingle(PrivateAuditConstants.AUDIT_TYPE, auditType.name());\n+        queryParameters.putSingle(PrivateAuditConstants.LOGIC_CLASS, query.getLogic().getLogicName());\n+        queryParameters.putSingle(PrivateAuditConstants.USER_DN, query.getSettings().getUserDN());\n+        queryParameters.putSingle(PrivateAuditConstants.COLUMN_VISIBILITY, query.getSettings().getColumnVisibility());\n+\n+        if (!auditType.equals(AuditType.NONE)) {\n+          try {\n             try {\n-                executor.submit(() -> {\n-                    close(closeQueryId, p);\n-                });\n-            } catch (RejectedExecutionException e) {\n-                // log only\n-                log.warn(\"close query rejected by executor id=\" + closeQueryId + \" principal=\" + p, e);\n-                // do it the old (slow way)\n-                close(queryId);\n+              List<String> selectors = query.getLogic().getSelectors(query.getSettings());\n+              if (selectors != null && !selectors.isEmpty()) {\n+                queryParameters.put(PrivateAuditConstants.SELECTORS, selectors);\n+              }\n+            } catch (Exception e) {\n+              log.error(\"Error accessing query selector\", e);\n             }\n+            auditor.audit(queryParameters);\n+          } catch (IllegalArgumentException e) {\n+            BadRequestQueryException qe = new BadRequestQueryException(DatawaveErrorCode.MISSING_REQUIRED_PARAMETER, e);\n+            response.addException(qe);\n+            throw new BadRequestException(qe, response);\n+          } catch (Exception e) {\n+            log.error(\"Error auditing query\", e);\n+            QueryException qe = new QueryException(DatawaveErrorCode.QUERY_AUDITING_ERROR, e);\n+            response.addException(qe);\n+            throw qe;\n+          }\n         }\n+      }\n+\n+      // Allocate the connection for this query so we are ready to go when\n+      // they call next.\n+      priority = query.getConnectionPriority();\n+      Map<String, String> trackingMap = connectionFactory.getTrackingMap(Thread.currentThread().getStackTrace());\n+      addQueryToTrackingMap(trackingMap, query.getSettings());\n+      accumuloConnectionRequestBean.requestBegin(id);\n+      try {\n+        client = connectionFactory.getClient(query.getLogic().getConnPoolName(), priority, trackingMap);\n+      } finally {\n+        accumuloConnectionRequestBean.requestEnd(id);\n+      }\n+      query.setClient(client);\n+      response.addMessage(id + \" reset.\");\n+      CreateQuerySessionIDFilter.QUERY_ID.set(id);\n+      return response;\n+    } catch (InterruptedException e) {\n+      if (query != null) {\n+        query.getMetric().setLifecycle(QueryMetric.Lifecycle.CANCELLED);\n+      }\n+      log.info(\"Query \" + id + \" canceled on request\");\n+      QueryException qe = new QueryException(DatawaveErrorCode.QUERY_CANCELED, e);\n+      response.addException(qe.getBottomQueryException());\n+      int statusCode = qe.getBottomQueryException().getStatusCode();\n+      throw new DatawaveWebApplicationException(qe, response, statusCode);\n+    } catch (Exception e) {\n+      log.error(\"Exception caught on resetting query\", e);\n+      try {\n+        if (null != client) {\n+          /*\n+           * if the query exists, we need to make sure the connection isn't set on it because the \"proper\" work flow is to close and/or cancel the\n+           * query after a failure. we don't want to purge it from the query cache, so setting the connector to null avoids having the connector\n+           * returned multiple times to the connector pool.\n+           */\n+          if (query != null) {\n+            query.setClient(null);\n+          }\n+          connectionFactory.returnClient(client);\n+        }\n+      } catch (Exception e2) {\n+        log.error(\"Error returning connection on failed reset\", e2);\n+      }\n+      QueryException qe = new QueryException(DatawaveErrorCode.QUERY_RESET_ERROR, e);\n+      response.addException(qe.getBottomQueryException());\n+      int statusCode = qe.getBottomQueryException().getStatusCode();\n+      throw new DatawaveWebApplicationException(qe, response, statusCode);\n+    } finally {\n+      queryCache.unlock(id);\n+      try {\n+        if (ctx.getUserTransaction().getStatus() != Status.STATUS_NO_TRANSACTION) {\n+          // no reason to commit if transaction not started, ie Query not found exception\n+          ctx.getUserTransaction().commit();\n+        }\n+      } catch (Exception e) {\n+        QueryException qe = new QueryException(DatawaveErrorCode.QUERY_TRANSACTION_ERROR, e);\n+        response.addException(qe.getBottomQueryException());\n+        throw new DatawaveWebApplicationException(qe, response);\n+      } finally {\n+        // Stop timing on this trace, if any\n+        if (span != null) {\n+          span.close();\n+        }\n+      }\n     }\n-    \n-    /**\n-     * Asynchronous version of {@link #next(String)}.\n-     * \n-     * @see #next(String)\n-     */\n-    @GET\n-    @Path(\"/{id}/async/next\")\n-    @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\", \"application/x-protobuf\",\n-            \"application/x-protostuff\"})\n-    @GZIP\n-    @EnrichQueryMetrics(methodType = MethodType.NEXT)\n-    @Interceptors({ResponseInterceptor.class, RequiredInterceptor.class})\n-    @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)\n-    @Asynchronous\n-    @Timed(name = \"dw.query.nextAsync\", absolute = true)\n-    public void nextAsync(@Required(\"id\") @PathParam(\"id\") String id, @Suspended AsyncResponse asyncResponse) {\n-        try {\n-            BaseQueryResponse response = next(id);\n-            asyncResponse.resume(response);\n-        } catch (Throwable t) {\n-            asyncResponse.resume(t);\n-        }\n+\n+  }\n+\n+  @Override\n+  @Interceptors({ResponseInterceptor.class, RequiredInterceptor.class})\n+  @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)\n+  public BaseQueryResponse createQueryAndNext(String logicName, MultivaluedMap<String, String> queryParameters) {\n+    return createQueryAndNext(logicName, queryParameters, null);\n+  }\n+\n+  /**\n+   * @param logicName\n+   * @param queryParameters\n+   * @return\n+   */\n+  @POST\n+  @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\",\n+      \"application/x-protobuf\",\n+      \"application/x-protostuff\"})\n+  @Path(\"/{logicName}/createAndNext\")\n+  @GZIP\n+  @GenerateQuerySessionId(cookieBasePath = \"/DataWave/Query/\")\n+  @EnrichQueryMetrics(methodType = MethodType.CREATE_AND_NEXT)\n+  @Interceptors({ResponseInterceptor.class, RequiredInterceptor.class})\n+  @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)\n+  @Timed(name = \"dw.query.createAndNext\", absolute = true)\n+  public BaseQueryResponse createQueryAndNext(@Required(\"logicName\") @PathParam(\"logicName\") String logicName,\n+                                              MultivaluedMap<String, String> queryParameters,\n+                                              @Context HttpHeaders httpHeaders) {\n+    CreateQuerySessionIDFilter.QUERY_ID.set(null);\n+\n+    GenericResponse<String> createResponse = createQuery(logicName, queryParameters, httpHeaders);\n+    String queryId = createResponse.getResult();\n+    CreateQuerySessionIDFilter.QUERY_ID.set(queryId);\n+    return next(queryId, false);\n+  }\n+\n+  @POST\n+  @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\",\n+      \"application/x-protobuf\",\n+      \"application/x-protostuff\"})\n+  @Path(\"/{logicName}/async/createAndNext\")\n+  @GZIP\n+  @GenerateQuerySessionId(cookieBasePath = \"/DataWave/Query/\")\n+  @EnrichQueryMetrics(methodType = MethodType.CREATE_AND_NEXT)\n+  @Interceptors({ResponseInterceptor.class, RequiredInterceptor.class})\n+  @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)\n+  @Asynchronous\n+  @Timed(name = \"dw.query.createAndNextAsync\", absolute = true)\n+  public void createQueryAndNextAsync(@Required(\"logicName\") @PathParam(\"logicName\") String logicName,\n+                                      MultivaluedMap<String, String> queryParameters,\n+                                      @Suspended AsyncResponse asyncResponse) {\n+    try {\n+      BaseQueryResponse response = createQueryAndNext(logicName, queryParameters);\n+      asyncResponse.resume(response);\n+    } catch (Throwable t) {\n+      asyncResponse.resume(t);\n+    }\n+  }\n+\n+  private BaseQueryResponse _next(RunningQuery query, String queryId, Collection<String> proxyServers, TraceScope span)\n+      throws Exception {\n+    // If we're tracing this query, then continue the trace for the next call.\n+    TraceInfo traceInfo = query.getTraceInfo();\n+    if (traceInfo != null) {\n+      span = Trace.startSpan(\"query:next\", traceInfo);\n     }\n-    \n-    /**\n-     * Gets the next page of results from the query object. If the object is no longer alive, meaning that the current session has expired, then this fail. The\n-     * response object type is dynamic, see the listQueryLogic operation to determine what the response type object will be.\n-     *\n-     * @param id\n-     *            - (@Required)\n-     * @see datawave.webservice.query.runner.QueryExecutorBean#next(String) for the @Required definition\n-     *\n-     * @return datawave.webservice.result.BaseQueryResponse\n-     * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user, by specifying a chain of DNs of the identities to proxy\n-     * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n-     * @RequestHeader query-session-id session id value used for load balancing purposes. query-session-id can be placed in the request in a Cookie header or as\n-     *                a query parameter\n-     * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n-     * @ResponseHeader X-query-page-number page number returned by this call\n-     * @ResponseHeader X-query-last-page if true then there are no more pages for this query, caller should call close()\n-     * @ResponseHeader X-Partial-Results true if the page contains less than the requested number of results\n-     *\n-     * @HTTP 200 success\n-     * @HTTP 204 success and no results\n-     * @HTTP 404 if id not found\n-     * @HTTP 412 if the query is no longer alive, client should call {@link #reset(String)} and try again\n-     * @HTTP 500 internal server error\n-     */\n-    @GET\n-    @Path(\"/{id}/next\")\n-    @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\", \"application/x-protobuf\",\n-            \"application/x-protostuff\"})\n-    @GZIP\n-    @EnrichQueryMetrics(methodType = MethodType.NEXT)\n-    @Interceptors({ResponseInterceptor.class, RequiredInterceptor.class})\n-    @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)\n-    @Override\n-    @Timed(name = \"dw.query.next\", absolute = true)\n-    public BaseQueryResponse next(@Required(\"id\") @PathParam(\"id\") String id) {\n-        return this.next(id, true);\n-    }\n-    \n-    private BaseQueryResponse next(final String id, boolean checkForContentLookup) {\n-        // in case we don't make it to creating the response from the QueryLogic\n-        BaseQueryResponse response = responseObjectFactory.getEventQueryResponse();\n-        \n-        Collection<String> proxyServers = null;\n-        Principal p = ctx.getCallerPrincipal();\n-        String userid = p.getName();\n-        if (p instanceof DatawavePrincipal) {\n-            DatawavePrincipal dp = (DatawavePrincipal) p;\n-            userid = dp.getShortName();\n-            proxyServers = dp.getProxyServers();\n-        }\n-        \n-        TraceScope span = null;\n-        RunningQuery query = null;\n-        Query contentLookupSettings = null;\n-        try {\n-            \n-            ctx.getUserTransaction().begin();\n-            \n-            // Not calling getQueryById() here. We don't want to pull the persisted definition.\n-            query = queryCache.get(id);\n-            \n-            // Lock this so that this query cannot be used concurrently.\n-            // The lock should be released at the end of the method call.\n-            if (!queryCache.lock(id)) {\n-                throw new QueryException(DatawaveErrorCode.QUERY_LOCKED_ERROR);\n-            }\n-            \n-            // When we pulled the query from the cache, we told it not to allocate a connection.\n-            // So if the connection is null here, then either the query wasn't in the cache\n-            // at all, or it was but only because of a call to list. In either case, it's\n-            // an error.\n-            if (null == query || null == query.getClient()) {\n-                // If the query just wasn't in the cache, then check the persister to see if the\n-                // ID exists at all. If it doesn't, then we need to return a 404 rather than 412\n-                // status code.\n-                if (null == query) {\n-                    List<Query> queries = persister.findById(id);\n-                    if (queries == null || queries.size() != 1) {\n-                        throw new NotFoundQueryException(DatawaveErrorCode.NO_QUERY_OBJECT_MATCH, MessageFormat.format(\"{0}\", id));\n-                    }\n-                }\n-                \n-                throw new PreConditionFailedQueryException(DatawaveErrorCode.QUERY_TIMEOUT_OR_SERVER_ERROR, MessageFormat.format(\"id = {0}\", id));\n-            } else {\n-                // Validate the query belongs to the caller\n-                if (!query.getSettings().getOwner().equals(userid)) {\n-                    throw new UnauthorizedQueryException(DatawaveErrorCode.QUERY_OWNER_MISMATCH, MessageFormat.format(\"{0} != {1}\", userid, query.getSettings()\n-                                    .getOwner()));\n-                }\n-                \n-                // Set the active call and get next\n-                query.setActiveCall(true);\n-                response = _next(query, id, proxyServers, span);\n-                \n-                // Conditionally swap the standard response with content\n-                if (checkForContentLookup) {\n-                    final Query settings = query.getSettings();\n-                    final Parameter contentLookupParam = settings.findParameter(LookupUUIDUtil.PARAM_CONTENT_LOOKUP);\n-                    if ((null != contentLookupParam) && Boolean.parseBoolean(contentLookupParam.getParameterValue())) {\n-                        contentLookupSettings = settings;\n-                    }\n-                }\n-                \n-                // Unset the active call and return\n-                query.setActiveCall(false);\n-            }\n-        } catch (NoResultsException e) {\n-            if (query != null) {\n-                query.setActiveCall(false);\n-                if (query.getLogic().getCollectQueryMetrics()) {\n-                    try {\n-                        // do not set the error message here - zero results is not an error that should be added to metrics\n-                        metrics.updateMetric(query.getMetric());\n-                    } catch (Exception e1) {\n-                        log.error(e1.getMessage());\n-                    }\n-                }\n-            }\n-            try {\n-                ctx.getUserTransaction().setRollbackOnly();\n-            } catch (Exception ex) {\n-                log.error(\"Error marking transaction for roll back\", ex);\n-            }\n-            close(id); // close the query, as there were no results and we are done here\n-            closedQueryCache.add(id); // remember that we auto-closed this query\n-            throw e;\n-        } catch (DatawaveWebApplicationException e) {\n-            if (query != null) {\n-                query.setActiveCall(false);\n-                if (query.getLogic().getCollectQueryMetrics()) {\n-                    query.getMetric().setError(e);\n-                    try {\n-                        metrics.updateMetric(query.getMetric());\n-                    } catch (Exception e1) {\n-                        log.error(\"Error updating query metrics\", e1);\n-                    }\n-                }\n-            }\n-            try {\n-                ctx.getUserTransaction().setRollbackOnly();\n-            } catch (Exception ex) {\n-                log.error(\"Error marking transaction for roll back\", ex);\n-            }\n-            if (e.getCause() instanceof NoResultsException) {\n-                close(id);\n-                closedQueryCache.add(id); // remember that we auto-closed this query\n-            }\n-            throw e;\n-        } catch (Exception e) {\n-            log.error(\"Query Failed\", e);\n-            if (query != null) {\n-                query.setActiveCall(false);\n-                if (query.getLogic().getCollectQueryMetrics() == true) {\n-                    query.getMetric().setError(e);\n-                    try {\n-                        metrics.updateMetric(query.getMetric());\n-                    } catch (Exception e1) {\n-                        log.error(\"Error updating query metrics\", e1);\n-                    }\n-                }\n-            }\n-            try {\n-                ctx.getUserTransaction().setRollbackOnly();\n-            } catch (Exception ex) {\n-                log.error(\"Error marking transaction for roll back\", ex);\n-            }\n-            \n-            QueryException qe = new QueryException(DatawaveErrorCode.QUERY_NEXT_ERROR, e, MessageFormat.format(\"query id: {0}\", id));\n-            if (e.getCause() instanceof NoResultsException) {\n-                log.debug(\"Got a nested NoResultsException\", e);\n-                close(id);\n-                closedQueryCache.add(id); // remember that we auto-closed this query\n-            } else {\n-                log.error(qe, e);\n-                response.addException(qe.getBottomQueryException());\n-            }\n-            int statusCode = qe.getBottomQueryException().getStatusCode();\n-            throw new DatawaveWebApplicationException(qe, response, statusCode);\n-        } finally {\n-            queryCache.unlock(id);\n-            try {\n-                if (ctx.getUserTransaction().getStatus() == Status.STATUS_MARKED_ROLLBACK) {\n-                    ctx.getUserTransaction().rollback();\n-                } else if (ctx.getUserTransaction().getStatus() != Status.STATUS_NO_TRANSACTION) {\n-                    // no reason to commit if transaction not started, ie Query not found exception\n-                    ctx.getUserTransaction().commit();\n-                }\n-            } catch (IllegalStateException e) {\n-                log.error(\"Error committing transaction: thread not associated with transaction\", e);\n-            } catch (RollbackException e) {\n-                log.error(\"Error committing transaction: marked for rollback due to error\", e);\n-            } catch (HeuristicMixedException e) {\n-                log.error(\"Error committing transaction: partial commit of resources\", e);\n-            } catch (HeuristicRollbackException e) {\n-                log.error(\"Error committing transaction: resources rolled back transaction\", e);\n-            } catch (Exception e) {\n-                log.error(\"Error committing transaction: Unknown error\", e);\n-            } finally {\n-                // Stop timing on this trace, if any\n-                if (span != null) {\n-                    span.close();\n-                }\n-            }\n+\n+    ResultsPage resultList;\n+    try {\n+      resultList = query.next();\n+    } catch (RejectedExecutionException e) {\n+      // - race condition, query expired while user called next\n+      throw new PreConditionFailedQueryException(DatawaveErrorCode.QUERY_TIMEOUT_OR_SERVER_ERROR, e,\n+          MessageFormat.format(\"id = {0}\", queryId));\n+    }\n+\n+    long pageNum = query.getLastPageNumber();\n+\n+    BaseQueryResponse response = query.getLogic().getTransformer(query.getSettings()).createResponse(resultList);\n+    if (!resultList.getResults().isEmpty()) {\n+      response.setHasResults(true);\n+    } else {\n+      response.setHasResults(false);\n+    }\n+    response.setPageNumber(pageNum);\n+    response.setLogicName(query.getLogic().getLogicName());\n+    response.setQueryId(queryId);\n+\n+    if (span != null && span.getSpan() != null) {\n+      span.getSpan().addKVAnnotation(\"pageNumber\", Long.toString(pageNum));\n+    }\n+\n+    query.getMetric().setProxyServers(proxyServers);\n+\n+    testForUncaughtException(query.getSettings(), resultList);\n+\n+    if (resultList.getResults().isEmpty()) {\n+      NoResultsQueryException qe =\n+          new NoResultsQueryException(DatawaveErrorCode.NO_QUERY_RESULTS_FOUND, MessageFormat.format(\"{0}\", queryId));\n+      response.addException(qe);\n+      throw new NoResultsException(qe);\n+    } else {\n+      return response;\n+    }\n+\n+  }\n+\n+  /**\n+   * @param uuid\n+   * @param uuidType\n+   * @param uriInfo\n+   * @param httpHeaders\n+   * @return content results, either as a paged BaseQueryResponse or StreamingOutput\n+   * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user, by specifying a chain of DNs of the identities to proxy\n+   * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n+   * @ResponseHeader query-session-id this header and value will be in the Set-Cookie header, subsequent calls for this session will need to supply the\n+   * query-session-id header in the request in a Cookie header or as a query parameter\n+   * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n+   * @ResponseHeader X-Partial-Results true if the page contains less than the requested number of results\n+   * @HTTP 200 success\n+   * @HTTP 204 success and no results\n+   * @HTTP 400 invalid or missing parameter\n+   * @HTTP 500 internal server error\n+   */\n+  @GET\n+  @Path(\"/lookupContentUUID/{uuidType}/{uuid}\")\n+  @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\",\n+      \"application/x-protobuf\",\n+      \"application/x-protostuff\"})\n+  @Interceptors({RequiredInterceptor.class, ResponseInterceptor.class})\n+  @Override\n+  @Timed(name = \"dw.query.lookupContentUUID\", absolute = true)\n+  public <T> T lookupContentByUUID(@Required(\"uuidType\") @PathParam(\"uuidType\") String uuidType,\n+                                   @Required(\"uuid\") @PathParam(\"uuid\") String uuid,\n+                                   @Context UriInfo uriInfo,\n+                                   @Required(\"httpHeaders\") @Context HttpHeaders httpHeaders) {\n+    MultivaluedMapImpl<String, String> queryParameters = new MultivaluedMapImpl<>();\n+    queryParameters.putAll(uriInfo.getQueryParameters());\n+    return this.lookupContentByUUID(uuidType, uuid, queryParameters, httpHeaders);\n+  }\n+\n+  private <T> T lookupContentByUUID(String uuidType, String uuid, MultivaluedMap<String, String> queryParameters,\n+                                    HttpHeaders httpHeaders) {\n+    T response = null;\n+    String queryId = null;\n+    try {\n+      String streaming = queryParameters.getFirst(\"streaming\");\n+      boolean streamingOutput = false;\n+      if (!StringUtils.isEmpty(streaming)) {\n+        streamingOutput = Boolean.parseBoolean(streaming);\n+      }\n+      // Create the criteria for looking up the respective events, which we need to get the shard IDs and column families\n+      // required for the content lookup\n+      final UUIDType matchingType = this.lookupUUIDUtil.getUUIDType(uuidType.toUpperCase());\n+      final GetUUIDCriteria criteria;\n+      final String view = (null != matchingType) ? matchingType.getDefinedView() : null;\n+      if ((LookupUUIDUtil.UID_QUERY.equals(view) || LookupUUIDUtil.LOOKUP_UID_QUERY.equals(view))) {\n+        criteria = new UIDQueryCriteria(uuid, uuidType, queryParameters);\n+      } else {\n+        criteria = new GetUUIDCriteria(uuid, uuidType, queryParameters);\n+      }\n+\n+      // Set the HTTP headers if a streamed response is required\n+      if (streamingOutput) {\n+        criteria.setStreamingOutputHeaders(httpHeaders);\n+      }\n+\n+      response = this.lookupUUIDUtil.lookupContentByUUIDs(criteria);\n+      if (response instanceof BaseQueryResponse) {\n+        queryId = ((BaseQueryResponse) response).getQueryId();\n+      }\n+      return response;\n+    } finally {\n+      if (null != queryId) {\n+        asyncClose(queryId);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * @param queryParameters\n+   * @param httpHeaders\n+   * @return content results, either as a paged BaseQueryResponse or StreamingOutput\n+   * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user, by specifying a chain of DNs of the identities to proxy\n+   * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n+   * @ResponseHeader query-session-id this header and value will be in the Set-Cookie header, subsequent calls for this session will need to supply the\n+   * query-session-id header in the request in a Cookie header or as a query parameter\n+   * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n+   * @ResponseHeader X-Partial-Results true if the page contains less than the requested number of results\n+   * @HTTP 200 success\n+   * @HTTP 204 success and no results\n+   * @HTTP 400 invalid or missing parameter\n+   * @HTTP 500 internal server error\n+   */\n+  @POST\n+  @Path(\"/lookupContentUUID\")\n+  @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\",\n+      \"application/x-protobuf\",\n+      \"application/x-protostuff\"})\n+  @GZIP\n+  @GenerateQuerySessionId(cookieBasePath = \"/DataWave/Query/\")\n+  @Interceptors({ResponseInterceptor.class, RequiredInterceptor.class})\n+  @Override\n+  @Timed(name = \"dw.query.lookupContentUUIDBatch\", absolute = true)\n+  public <T> T lookupContentByUUIDBatch(MultivaluedMap<String, String> queryParameters, HttpHeaders httpHeaders) {\n+    if (!queryParameters.containsKey(\"uuidPairs\")) {\n+      throw new BadRequestException(new IllegalArgumentException(\"uuidPairs missing from query parameters\"),\n+          new VoidResponse());\n+    }\n+    T response = null;\n+    String queryId = null;\n+    try {\n+      String uuidPairs = queryParameters.getFirst(\"uuidPairs\");\n+      String streaming = queryParameters.getFirst(\"streaming\");\n+      boolean streamingOutput = false;\n+      if (!StringUtils.isEmpty(streaming)) {\n+        streamingOutput = Boolean.parseBoolean(streaming);\n+      }\n+      // Create the criteria for looking up the respective events, which we need to get the shard IDs and column families\n+      // required for the content lookup\n+      final PostUUIDCriteria criteria = new PostUUIDCriteria(uuidPairs, queryParameters);\n+\n+      // Set the HTTP headers if a streamed response is required\n+      if (streamingOutput) {\n+        criteria.setStreamingOutputHeaders(httpHeaders);\n+      }\n+\n+      response = this.lookupUUIDUtil.lookupContentByUUIDs(criteria);\n+      if (response instanceof BaseQueryResponse) {\n+        queryId = ((BaseQueryResponse) response).getQueryId();\n+      }\n+      return response;\n+    } finally {\n+      if (null != queryId) {\n+        asyncClose(queryId);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * @param uuidType\n+   * @param uuid\n+   * @param uriInfo\n+   * @param httpHeaders\n+   * @return\n+   * @return event results, either as a paged BaseQueryResponse (automatically closed upon return) or StreamingOutput\n+   * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user, by specifying a chain of DNs of the identities to proxy\n+   * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n+   * @ResponseHeader query-session-id this header and value will be in the Set-Cookie header, subsequent calls for this session will need to supply the\n+   * query-session-id header in the request in a Cookie header or as a query parameter\n+   * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n+   * @ResponseHeader X-Partial-Results true if the page contains less than the requested number of results\n+   * @HTTP 200 success\n+   * @HTTP 204 success and no results\n+   * @HTTP 400 invalid or missing parameter\n+   * @HTTP 500 internal server error\n+   */\n+  @GET\n+  @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\",\n+      \"application/x-protobuf\",\n+      \"application/x-protostuff\"})\n+  @Path(\"/lookupUUID/{uuidType}/{uuid}\")\n+  @Interceptors({RequiredInterceptor.class, ResponseInterceptor.class})\n+  @Override\n+  @Timed(name = \"dw.query.lookupUUID\", absolute = true)\n+  public <T> T lookupUUID(@Required(\"uuidType\") @PathParam(\"uuidType\") String uuidType,\n+                          @Required(\"uuid\") @PathParam(\"uuid\") String uuid,\n+                          @Context UriInfo uriInfo, @Required(\"httpHeaders\") @Context HttpHeaders httpHeaders) {\n+    MultivaluedMapImpl<String, String> queryParameters = new MultivaluedMapImpl<>();\n+    queryParameters.putAll(uriInfo.getQueryParameters());\n+    return this.lookupUUID(uuidType, uuid, queryParameters, httpHeaders);\n+  }\n+\n+  <T> T lookupUUID(String uuidType, String uuid, MultivaluedMap<String, String> queryParameters,\n+                   HttpHeaders httpHeaders) {\n+    String streaming = queryParameters.getFirst(\"streaming\");\n+    boolean streamingOutput = false;\n+    if (!StringUtils.isEmpty(streaming)) {\n+      streamingOutput = Boolean.parseBoolean(streaming);\n+    }\n+    final UUIDType matchingType = this.lookupUUIDUtil.getUUIDType(uuidType);\n+    String queryId = null;\n+    T response;\n+    try {\n+      // Construct the criteria used to perform the query\n+      final GetUUIDCriteria criteria;\n+      final String view = (null != matchingType) ? matchingType.getDefinedView() : null;\n+      if ((LookupUUIDUtil.UID_QUERY.equals(view) || LookupUUIDUtil.LOOKUP_UID_QUERY.equals(view))) {\n+        criteria = new UIDQueryCriteria(uuid, uuidType, queryParameters);\n+      } else {\n+        criteria = new GetUUIDCriteria(uuid, uuidType, queryParameters);\n+      }\n+\n+      // Add the HTTP headers in case streaming is required\n+      if (streamingOutput) {\n+        criteria.setStreamingOutputHeaders(httpHeaders);\n+      }\n+\n+      // Perform the query and get the first set of results\n+      response = this.lookupUUIDUtil.createUUIDQueryAndNext(criteria);\n+      if (response instanceof BaseQueryResponse) {\n+        queryId = ((BaseQueryResponse) response).getQueryId();\n+      }\n+      return response;\n+    } finally {\n+      if (null != queryId) {\n+        asyncClose(queryId);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * @param queryParameters\n+   * @param httpHeaders\n+   * @return event results, either as a paged BaseQueryResponse or StreamingOutput\n+   * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user, by specifying a chain of DNs of the identities to proxy\n+   * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n+   * @ResponseHeader query-session-id this header and value will be in the Set-Cookie header, subsequent calls for this session will need to supply the\n+   * query-session-id header in the request in a Cookie header or as a query parameter\n+   * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n+   * @ResponseHeader X-Partial-Results true if the page contains less than the requested number of results\n+   * @HTTP 200 success\n+   * @HTTP 204 success and no results\n+   * @HTTP 400 invalid or missing parameter\n+   * @HTTP 500 internal server error\n+   */\n+  @POST\n+  @Path(\"/lookupUUID\")\n+  @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\",\n+      \"application/x-protobuf\",\n+      \"application/x-protostuff\"})\n+  @GZIP\n+  @GenerateQuerySessionId(cookieBasePath = \"/DataWave/Query/\")\n+  @Interceptors({ResponseInterceptor.class, RequiredInterceptor.class})\n+  @Override\n+  @Timed(name = \"dw.query.lookupUUIDBatch\", absolute = true)\n+  public <T> T lookupUUIDBatch(MultivaluedMap<String, String> queryParameters,\n+                               @Required(\"httpHeaders\") @Context HttpHeaders httpHeaders) {\n+    if (!queryParameters.containsKey(\"uuidPairs\")) {\n+      throw new BadRequestException(new IllegalArgumentException(\"uuidPairs missing from query parameters\"),\n+          new VoidResponse());\n+    }\n+    T response;\n+    String queryId = null;\n+    try {\n+      String uuidPairs = queryParameters.getFirst(\"uuidPairs\");\n+      String streaming = queryParameters.getFirst(\"streaming\");\n+      boolean streamingOutput = false;\n+      if (!StringUtils.isEmpty(streaming)) {\n+        streamingOutput = Boolean.parseBoolean(streaming);\n+      }\n+      final PostUUIDCriteria criteria = new PostUUIDCriteria(uuidPairs, queryParameters);\n+      if (streamingOutput) {\n+        criteria.setStreamingOutputHeaders(httpHeaders);\n+      }\n+      response = this.lookupUUIDUtil.createUUIDQueryAndNext(criteria);\n+      if (response instanceof BaseQueryResponse) {\n+        queryId = ((BaseQueryResponse) response).getQueryId();\n+      }\n+      return response;\n+    } finally {\n+      if (null != queryId) {\n+        asyncClose(queryId);\n+      }\n+    }\n+\n+  }\n+\n+  /**\n+   * Pulls back the current plan for a query.\n+   *\n+   * @param id - (@Required)\n+   * @return GenericResponse containing plan\n+   * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user, by specifying a chain of DNs of the identities to proxy\n+   * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n+   * @RequestHeader query-session-id session id value used for load balancing purposes. query-session-id can be placed in the request in a Cookie header or as\n+   * a query parameter\n+   * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n+   * @HTTP 200 success\n+   * @HTTP 204 success and no results\n+   * @HTTP 404 if id not found\n+   * @HTTP 412 if the query is no longer alive, client should call {@link #reset(String)} and try again\n+   * @HTTP 500 internal server error\n+   */\n+  @GET\n+  @Path(\"/{id}/plan\")\n+  @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\",\n+      \"application/x-protobuf\",\n+      \"application/x-protostuff\"})\n+  @GZIP\n+  @Interceptors({ResponseInterceptor.class, RequiredInterceptor.class})\n+  @Override\n+  @Timed(name = \"dw.query.plan\", absolute = true)\n+  public GenericResponse<String> plan(@Required(\"id\") @PathParam(\"id\") String id) {\n+    // in case we don't make it to creating the response from the QueryLogic\n+    GenericResponse<String> response = new GenericResponse<>();\n+\n+    Principal p = ctx.getCallerPrincipal();\n+    String userid = p.getName();\n+    if (p instanceof DatawavePrincipal) {\n+      DatawavePrincipal dp = (DatawavePrincipal) p;\n+      userid = dp.getShortName();\n+    }\n+\n+    try {\n+      // Not calling getQueryById() here. We don't want to pull the persisted definition.\n+      RunningQuery query = queryCache.get(id);\n+\n+      // When we pulled the query from the cache, we told it not to allocate a connection.\n+      // So if the connection is null here, then either the query wasn't in the cache\n+      // at all, or it was but only because of a call to list. In either case, it's\n+      // an error.\n+      if (null == query || null == query.getClient()) {\n+        // If the query just wasn't in the cache, then check the persister to see if the\n+        // ID exists at all. If it doesn't, then we need to return a 404 rather than 412\n+        // status code.\n+        if (null == query) {\n+          List<Query> queries = persister.findById(id);\n+          if (queries == null || queries.size() != 1) {\n+            throw new NotFoundQueryException(DatawaveErrorCode.NO_QUERY_OBJECT_MATCH, MessageFormat.format(\"{0}\", id));\n+          }\n         }\n-        \n-        // If applicable, perform a paged content lookup (i.e., not streamed), replacing its results in the returned response\n-        if (null != contentLookupSettings) {\n-            final NextContentCriteria criteria = new NextContentCriteria(id, contentLookupSettings);\n-            response = this.lookupUUIDUtil.lookupContentByNextResponse(criteria, response);\n+\n+        throw new PreConditionFailedQueryException(DatawaveErrorCode.QUERY_TIMEOUT_OR_SERVER_ERROR,\n+            MessageFormat.format(\"id = {0}\", id));\n+      } else {\n+        // Validate the query belongs to the caller\n+        if (!query.getSettings().getOwner().equals(userid)) {\n+          throw new UnauthorizedQueryException(DatawaveErrorCode.QUERY_OWNER_MISMATCH,\n+              MessageFormat.format(\"{0} != {1}\", userid, query.getSettings()\n+                  .getOwner()));\n         }\n-        \n-        return response;\n+\n+        // pull the plan out of the query metric\n+        String plan = query.getMetric().getPlan();\n+        if (plan != null) {\n+          response.setResult(plan);\n+          response.setHasResults(true);\n+        }\n+      }\n+    } catch (Exception e) {\n+      log.error(\"Failed to get query plan\", e);\n+\n+      QueryException qe =\n+          new QueryException(DatawaveErrorCode.QUERY_PLAN_ERROR, e, MessageFormat.format(\"query id: {0}\", id));\n+      log.error(qe, e);\n+      response.addException(qe.getBottomQueryException());\n+      int statusCode = qe.getBottomQueryException().getStatusCode();\n+      throw new DatawaveWebApplicationException(qe, response, statusCode);\n     }\n-    \n-    /**\n-     * Releases the resources associated with this query. Any currently running calls to 'next' on the query will continue until they finish. Calls to 'next'\n-     * after a 'close' will start over at page 1.\n-     * \n-     * @param id\n-     *\n-     * @return datawave.webservice.result.VoidResponse\n-     * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user, by specifying a chain of DNs of the identities to proxy\n-     * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n-     * @RequestHeader query-session-id session id value used for load balancing purposes. query-session-id can be placed in the request in a Cookie header or as\n-     *                a query parameter\n-     * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n-     *\n-     * @HTTP 200 success\n-     * @HTTP 404 queries not found using {@code id}\n-     * @HTTP 500 internal server error\n-     */\n-    @PUT\n-    @POST\n-    @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\", \"application/x-protobuf\",\n-            \"application/x-protostuff\"})\n-    @Path(\"/{id}/close\")\n-    @GZIP\n-    @ClearQuerySessionId\n-    @Interceptors({ResponseInterceptor.class, RequiredInterceptor.class})\n-    @Override\n-    @Timed(name = \"dw.query.close\", absolute = true)\n-    public VoidResponse close(@Required(\"id\") @PathParam(\"id\") String id) {\n-        return close(id, ctx.getCallerPrincipal());\n+\n+    return response;\n+  }\n+\n+  /**\n+   * Pulls back the current predictions for a query.\n+   *\n+   * @param id - (@Required)\n+   * @return GenericResponse containing predictions\n+   * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user, by specifying a chain of DNs of the identities to proxy\n+   * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n+   * @RequestHeader query-session-id session id value used for load balancing purposes. query-session-id can be placed in the request in a Cookie header or as\n+   * a query parameter\n+   * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n+   * @HTTP 200 success\n+   * @HTTP 204 success and no results\n+   * @HTTP 404 if id not found\n+   * @HTTP 412 if the query is no longer alive, client should call {@link #reset(String)} and try again\n+   * @HTTP 500 internal server error\n+   */\n+  @GET\n+  @Path(\"/{id}/predictions\")\n+  @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\",\n+      \"application/x-protobuf\",\n+      \"application/x-protostuff\"})\n+  @GZIP\n+  @Interceptors({ResponseInterceptor.class, RequiredInterceptor.class})\n+  @Override\n+  @Timed(name = \"dw.query.predictions\", absolute = true)\n+  public GenericResponse<String> predictions(@Required(\"id\") @PathParam(\"id\") String id) {\n+    // in case we don't make it to creating the response from the QueryLogic\n+    GenericResponse<String> response = new GenericResponse<>();\n+\n+    Principal p = ctx.getCallerPrincipal();\n+    String userid = p.getName();\n+    if (p instanceof DatawavePrincipal) {\n+      DatawavePrincipal dp = (DatawavePrincipal) p;\n+      userid = dp.getShortName();\n     }\n-    \n-    private VoidResponse close(String id, Principal principal) {\n-        VoidResponse response = new VoidResponse();\n-        try {\n-            boolean connectionRequestCanceled = accumuloConnectionRequestBean.cancelConnectionRequest(id, principal);\n-            Pair<QueryLogic<?>,AccumuloClient> tuple = qlCache.pollIfOwnedBy(id, ((DatawavePrincipal) principal).getShortName());\n-            if (tuple == null) {\n-                try {\n-                    RunningQuery query = getQueryById(id, principal);\n-                    close(query);\n-                } catch (Exception e) {\n-                    log.debug(\"Failed to close \" + id + \", checking if closed previously\");\n-                    // if this is a query that is in the closed query cache, then we have already successfully closed this query so ignore\n-                    if (!closedQueryCache.exists(id)) {\n-                        log.debug(\"Failed to close \" + id + \", checking if connection request was canceled\");\n-                        // if connection request was canceled, then the call was successful even if a RunningQuery was not found\n-                        if (!connectionRequestCanceled) {\n-                            log.error(\"Failed to close \" + id, e);\n-                            throw e;\n-                        }\n-                    }\n-                }\n-                response.addMessage(id + \" closed.\");\n-            } else {\n-                QueryLogic<?> logic = tuple.getFirst();\n-                try {\n-                    logic.close();\n-                } catch (Exception e) {\n-                    log.error(\"Exception occurred while closing query logic; may be innocuous if scanners were running.\", e);\n-                }\n-                connectionFactory.returnClient(tuple.getSecond());\n-                response.addMessage(id + \" closed before create completed.\");\n-            }\n-            \n-            // no longer need to remember this query\n-            closedQueryCache.remove(id);\n-            \n-            return response;\n-        } catch (DatawaveWebApplicationException e) {\n-            throw e;\n-        } catch (Exception e) {\n-            QueryException qe = new QueryException(DatawaveErrorCode.CLOSE_ERROR, e, MessageFormat.format(\"query_id: {0}\", id));\n-            log.error(qe, e);\n-            response.addException(qe.getBottomQueryException());\n-            int statusCode = qe.getBottomQueryException().getStatusCode();\n-            throw new DatawaveWebApplicationException(qe, response, statusCode);\n+\n+    try {\n+      // Not calling getQueryById() here. We don't want to pull the persisted definition.\n+      RunningQuery query = queryCache.get(id);\n+\n+      // When we pulled the query from the cache, we told it not to allocate a connection.\n+      // So if the connection is null here, then either the query wasn't in the cache\n+      // at all, or it was but only because of a call to list. In either case, it's\n+      // an error.\n+      if (null == query || null == query.getClient()) {\n+        // If the query just wasn't in the cache, then check the persister to see if the\n+        // ID exists at all. If it doesn't, then we need to return a 404 rather than 412\n+        // status code.\n+        if (null == query) {\n+          List<Query> queries = persister.findById(id);\n+          if (queries == null || queries.size() != 1) {\n+            throw new NotFoundQueryException(DatawaveErrorCode.NO_QUERY_OBJECT_MATCH, MessageFormat.format(\"{0}\", id));\n+          }\n+        }\n+\n+        throw new PreConditionFailedQueryException(DatawaveErrorCode.QUERY_TIMEOUT_OR_SERVER_ERROR,\n+            MessageFormat.format(\"id = {0}\", id));\n+      } else {\n+        // Validate the query belongs to the caller\n+        if (!query.getSettings().getOwner().equals(userid)) {\n+          throw new UnauthorizedQueryException(DatawaveErrorCode.QUERY_OWNER_MISMATCH,\n+              MessageFormat.format(\"{0} != {1}\", userid, query.getSettings()\n+                  .getOwner()));\n         }\n+\n+        // pull the predictions out of the query metric\n+        Set<Prediction> predictions = query.getMetric().getPredictions();\n+        if (predictions != null && !predictions.isEmpty()) {\n+          response.setResult(predictions.toString());\n+          response.setHasResults(true);\n+        }\n+      }\n+    } catch (Exception e) {\n+      log.error(\"Failed to get query predictions\", e);\n+\n+      QueryException qe =\n+          new QueryException(DatawaveErrorCode.QUERY_PREDICTIONS_ERROR, e, MessageFormat.format(\"query id: {0}\", id));\n+      log.error(qe, e);\n+      response.addException(qe.getBottomQueryException());\n+      int statusCode = qe.getBottomQueryException().getStatusCode();\n+      throw new DatawaveWebApplicationException(qe, response, statusCode);\n     }\n-    \n-    /**\n-     * <strong>JBossAdministrator or Administrator credentials required.</strong>\n-     *\n-     * @param id\n-     * @return\n-     */\n-    @PUT\n-    @POST\n-    @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\", \"application/x-protobuf\",\n-            \"application/x-protostuff\"})\n-    @Path(\"/{id}/adminClose\")\n-    @GZIP\n-    @Interceptors({ResponseInterceptor.class, RequiredInterceptor.class})\n-    @RolesAllowed({\"Administrator\", \"JBossAdministrator\"})\n-    @Override\n-    public VoidResponse adminClose(@Required(\"id\") @PathParam(\"id\") String id) {\n-        VoidResponse response = new VoidResponse();\n-        try {\n-            boolean connectionRequestCanceled = accumuloConnectionRequestBean.adminCancelConnectionRequest(id);\n-            Pair<QueryLogic<?>,AccumuloClient> tuple = qlCache.poll(id);\n-            if (tuple == null) {\n-                try {\n-                    RunningQuery query = adminGetQueryById(id);\n-                    close(query);\n-                } catch (Exception e) {\n-                    log.debug(\"Failed to adminClose \" + id + \", checking if connection request was canceled\");\n-                    // if connection request was canceled, then the call was successful even if a RunningQuery was not found\n-                    if (!connectionRequestCanceled) {\n-                        log.error(\"Failed to adminClose \" + id, e);\n-                        throw e;\n-                    }\n-                }\n-                response.addMessage(id + \" closed.\");\n-            } else {\n-                QueryLogic<?> logic = tuple.getFirst();\n-                try {\n-                    logic.close();\n-                } catch (Exception e) {\n-                    log.error(\"Exception occurred while closing query logic; may be innocuous if scanners were running.\", e);\n-                }\n-                connectionFactory.returnClient(tuple.getSecond());\n-                response.addMessage(id + \" closed before create completed.\");\n-            }\n-            \n-            return response;\n-        } catch (DatawaveWebApplicationException e) {\n-            throw e;\n-        } catch (Exception e) {\n-            QueryException qe = new QueryException(DatawaveErrorCode.CLOSE_ERROR);\n-            log.error(qe, e);\n-            response.addException(qe.getBottomQueryException());\n-            int statusCode = qe.getBottomQueryException().getStatusCode();\n-            throw new DatawaveWebApplicationException(qe, response, statusCode);\n-        }\n-    }\n-    \n-    private void close(RunningQuery query) throws Exception {\n-        \n-        String queryId = query.getSettings().getId().toString();\n-        \n-        log.debug(\"Closing \" + queryId);\n-        \n-        try {\n-            query.closeConnection(connectionFactory);\n-        } catch (Exception e) {\n-            log.error(\"Failed to close connection for \" + queryId, e);\n-        }\n-        \n-        queryCache.remove(queryId);\n-        \n-        log.debug(\"Closed \" + queryId);\n-        \n-        // The trace was already stopped, but mark the time we closed it in the trace data.\n-        TraceInfo traceInfo = query.getTraceInfo();\n-        if (traceInfo != null) {\n-            try (TraceScope scope = Trace.startSpan(\"query:close\", traceInfo)) {\n-                if (scope.getSpan() != null) {\n-                    scope.getSpan().addKVAnnotation(\"closedAt\", new Date().toString());\n-                }\n-                // Spans aren't recorded if they take no time, so sleep for a\n-                // couple milliseconds just to ensure we get something saved.\n-                try {\n-                    Thread.sleep(2);\n-                } catch (InterruptedException e) {\n-                    // ignore\n-                }\n-            }\n-            // TODO: not sure this makes any sense anymore in Accumulo 1.8.1\n-            // Tracer.getInstance().flush();\n+\n+    return response;\n+  }\n+\n+  /**\n+   * Attempt to async close a query using the executor. If the executor can't accommodate the close then the query will be closed in-line\n+   *\n+   * @param queryId non-null queryId\n+   */\n+  private void asyncClose(String queryId) {\n+    if (queryId != null) {\n+      final Principal p = ctx.getCallerPrincipal();\n+      final String closeQueryId = queryId;\n+      try {\n+        executor.submit(() -> {\n+          close(closeQueryId, p);\n+        });\n+      } catch (RejectedExecutionException e) {\n+        // log only\n+        log.warn(\"close query rejected by executor id=\" + closeQueryId + \" principal=\" + p, e);\n+        // do it the old (slow way)\n+        close(queryId);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Asynchronous version of {@link #next(String)}.\n+   *\n+   * @see #next(String)\n+   */\n+  @GET\n+  @Path(\"/{id}/async/next\")\n+  @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\",\n+      \"application/x-protobuf\",\n+      \"application/x-protostuff\"})\n+  @GZIP\n+  @EnrichQueryMetrics(methodType = MethodType.NEXT)\n+  @Interceptors({ResponseInterceptor.class, RequiredInterceptor.class})\n+  @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)\n+  @Asynchronous\n+  @Timed(name = \"dw.query.nextAsync\", absolute = true)\n+  public void nextAsync(@Required(\"id\") @PathParam(\"id\") String id, @Suspended AsyncResponse asyncResponse) {\n+    try {\n+      BaseQueryResponse response = next(id);\n+      asyncResponse.resume(response);\n+    } catch (Throwable t) {\n+      asyncResponse.resume(t);\n+    }\n+  }\n+\n+  /**\n+   * Gets the next page of results from the query object. If the object is no longer alive, meaning that the current session has expired, then this fail. The\n+   * response object type is dynamic, see the listQueryLogic operation to determine what the response type object will be.\n+   *\n+   * @param id - (@Required)\n+   * @return datawave.webservice.result.BaseQueryResponse\n+   * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user, by specifying a chain of DNs of the identities to proxy\n+   * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n+   * @RequestHeader query-session-id session id value used for load balancing purposes. query-session-id can be placed in the request in a Cookie header or as\n+   * a query parameter\n+   * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n+   * @ResponseHeader X-query-page-number page number returned by this call\n+   * @ResponseHeader X-query-last-page if true then there are no more pages for this query, caller should call close()\n+   * @ResponseHeader X-Partial-Results true if the page contains less than the requested number of results\n+   * @HTTP 200 success\n+   * @HTTP 204 success and no results\n+   * @HTTP 404 if id not found\n+   * @HTTP 412 if the query is no longer alive, client should call {@link #reset(String)} and try again\n+   * @HTTP 500 internal server error\n+   * @see datawave.webservice.query.runner.QueryExecutorBean#next(String) for the @Required definition\n+   */\n+  @GET\n+  @Path(\"/{id}/next\")\n+  @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\",\n+      \"application/x-protobuf\",\n+      \"application/x-protostuff\"})\n+  @GZIP\n+  @EnrichQueryMetrics(methodType = MethodType.NEXT)\n+  @Interceptors({ResponseInterceptor.class, RequiredInterceptor.class})\n+  @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)\n+  @Override\n+  @Timed(name = \"dw.query.next\", absolute = true)\n+  public BaseQueryResponse next(@Required(\"id\") @PathParam(\"id\") String id) {\n+    return this.next(id, true);\n+  }\n+\n+  private BaseQueryResponse next(final String id, boolean checkForContentLookup) {\n+    // in case we don't make it to creating the response from the QueryLogic\n+    BaseQueryResponse response = responseObjectFactory.getEventQueryResponse();\n+\n+    Collection<String> proxyServers = null;\n+    Principal p = ctx.getCallerPrincipal();\n+    String userid = p.getName();\n+    if (p instanceof DatawavePrincipal) {\n+      DatawavePrincipal dp = (DatawavePrincipal) p;\n+      userid = dp.getShortName();\n+      proxyServers = dp.getProxyServers();\n+    }\n+\n+    TraceScope span = null;\n+    RunningQuery query = null;\n+    Query contentLookupSettings = null;\n+    try {\n+\n+      ctx.getUserTransaction().begin();\n+\n+      // Not calling getQueryById() here. We don't want to pull the persisted definition.\n+      query = queryCache.get(id);\n+\n+      // Lock this so that this query cannot be used concurrently.\n+      // The lock should be released at the end of the method call.\n+      if (!queryCache.lock(id)) {\n+        throw new QueryException(DatawaveErrorCode.QUERY_LOCKED_ERROR);\n+      }\n+\n+      // When we pulled the query from the cache, we told it not to allocate a connection.\n+      // So if the connection is null here, then either the query wasn't in the cache\n+      // at all, or it was but only because of a call to list. In either case, it's\n+      // an error.\n+      if (null == query || null == query.getClient()) {\n+        // If the query just wasn't in the cache, then check the persister to see if the\n+        // ID exists at all. If it doesn't, then we need to return a 404 rather than 412\n+        // status code.\n+        if (null == query) {\n+          List<Query> queries = persister.findById(id);\n+          if (queries == null || queries.size() != 1) {\n+            throw new NotFoundQueryException(DatawaveErrorCode.NO_QUERY_OBJECT_MATCH, MessageFormat.format(\"{0}\", id));\n+          }\n+        }\n+\n+        throw new PreConditionFailedQueryException(DatawaveErrorCode.QUERY_TIMEOUT_OR_SERVER_ERROR,\n+            MessageFormat.format(\"id = {0}\", id));\n+      } else {\n+        // Validate the query belongs to the caller\n+        if (!query.getSettings().getOwner().equals(userid)) {\n+          throw new UnauthorizedQueryException(DatawaveErrorCode.QUERY_OWNER_MISMATCH,\n+              MessageFormat.format(\"{0} != {1}\", userid, query.getSettings()\n+                  .getOwner()));\n         }\n+\n+        // Set the active call and get next\n+        query.setActiveCall(true);\n+        response = _next(query, id, proxyServers, span);\n+\n+        // Conditionally swap the standard response with content\n+        if (checkForContentLookup) {\n+          final Query settings = query.getSettings();\n+          final Parameter contentLookupParam = settings.findParameter(LookupUUIDUtil.PARAM_CONTENT_LOOKUP);\n+          if ((null != contentLookupParam) && Boolean.parseBoolean(contentLookupParam.getParameterValue())) {\n+            contentLookupSettings = settings;\n+          }\n+        }\n+\n+        // Unset the active call and return\n+        query.setActiveCall(false);\n+      }\n+    } catch (NoResultsException e) {\n+      if (query != null) {\n+        query.setActiveCall(false);\n+        if (query.getLogic().getCollectQueryMetrics()) {\n+          try {\n+            // do not set the error message here - zero results is not an error that should be added to metrics\n+            metrics.updateMetric(query.getMetric());\n+          } catch (Exception e1) {\n+            log.error(e1.getMessage());\n+          }\n+        }\n+      }\n+      try {\n+        ctx.getUserTransaction().setRollbackOnly();\n+      } catch (Exception ex) {\n+        log.error(\"Error marking transaction for roll back\", ex);\n+      }\n+      close(id); // close the query, as there were no results and we are done here\n+      closedQueryCache.add(id); // remember that we auto-closed this query\n+      throw e;\n+    } catch (DatawaveWebApplicationException e) {\n+      if (query != null) {\n+        query.setActiveCall(false);\n+        if (query.getLogic().getCollectQueryMetrics()) {\n+          query.getMetric().setError(e);\n+          try {\n+            metrics.updateMetric(query.getMetric());\n+          } catch (Exception e1) {\n+            log.error(\"Error updating query metrics\", e1);\n+          }\n+        }\n+      }\n+      try {\n+        ctx.getUserTransaction().setRollbackOnly();\n+      } catch (Exception ex) {\n+        log.error(\"Error marking transaction for roll back\", ex);\n+      }\n+      if (e.getCause() instanceof NoResultsException) {\n+        close(id);\n+        closedQueryCache.add(id); // remember that we auto-closed this query\n+      }\n+      throw e;\n+    } catch (Exception e) {\n+      log.error(\"Query Failed\", e);\n+      if (query != null) {\n+        query.setActiveCall(false);\n+        if (query.getLogic().getCollectQueryMetrics() == true) {\n+          query.getMetric().setError(e);\n+          try {\n+            metrics.updateMetric(query.getMetric());\n+          } catch (Exception e1) {\n+            log.error(\"Error updating query metrics\", e1);\n+          }\n+        }\n+      }\n+      try {\n+        ctx.getUserTransaction().setRollbackOnly();\n+      } catch (Exception ex) {\n+        log.error(\"Error marking transaction for roll back\", ex);\n+      }\n+\n+      QueryException qe =\n+          new QueryException(DatawaveErrorCode.QUERY_NEXT_ERROR, e, MessageFormat.format(\"query id: {0}\", id));\n+      if (e.getCause() instanceof NoResultsException) {\n+        log.debug(\"Got a nested NoResultsException\", e);\n+        close(id);\n+        closedQueryCache.add(id); // remember that we auto-closed this query\n+      } else {\n+        log.error(qe, e);\n+        response.addException(qe.getBottomQueryException());\n+      }\n+      int statusCode = qe.getBottomQueryException().getStatusCode();\n+      throw new DatawaveWebApplicationException(qe, response, statusCode);\n+    } finally {\n+      queryCache.unlock(id);\n+      try {\n+        if (ctx.getUserTransaction().getStatus() == Status.STATUS_MARKED_ROLLBACK) {\n+          ctx.getUserTransaction().rollback();\n+        } else if (ctx.getUserTransaction().getStatus() != Status.STATUS_NO_TRANSACTION) {\n+          // no reason to commit if transaction not started, ie Query not found exception\n+          ctx.getUserTransaction().commit();\n+        }\n+      } catch (IllegalStateException e) {\n+        log.error(\"Error committing transaction: thread not associated with transaction\", e);\n+      } catch (RollbackException e) {\n+        log.error(\"Error committing transaction: marked for rollback due to error\", e);\n+      } catch (HeuristicMixedException e) {\n+        log.error(\"Error committing transaction: partial commit of resources\", e);\n+      } catch (HeuristicRollbackException e) {\n+        log.error(\"Error committing transaction: resources rolled back transaction\", e);\n+      } catch (Exception e) {\n+        log.error(\"Error committing transaction: Unknown error\", e);\n+      } finally {\n+        // Stop timing on this trace, if any\n+        if (span != null) {\n+          span.close();\n+        }\n+      }\n     }\n-    \n-    /**\n-     * Releases the resources associated with this query. Any currently running calls to 'next' on the query will be stopped. Calls to 'next' after a 'cancel'\n-     * will start over at page 1.\n-     * \n-     * @param id\n-     *\n-     * @return datawave.webservice.result.VoidResponse\n-     * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user, by specifying a chain of DNs of the identities to proxy\n-     * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n-     * @RequestHeader query-session-id session id value used for load balancing purposes. query-session-id can be placed in the request in a Cookie header or as\n-     *                a query parameter\n-     * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n-     *\n-     * @HTTP 200 success\n-     * @HTTP 404 queries not found using {@code id}\n-     * @HTTP 500 internal server error\n-     */\n-    @PUT\n-    @POST\n-    @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\", \"application/x-protobuf\",\n-            \"application/x-protostuff\"})\n-    @Path(\"/{id}/cancel\")\n-    @GZIP\n-    @ClearQuerySessionId\n-    @Interceptors({ResponseInterceptor.class, RequiredInterceptor.class})\n-    @Override\n-    @Timed(name = \"dw.query.cancel\", absolute = true)\n-    public VoidResponse cancel(@Required(\"id\") @PathParam(\"id\") String id) {\n-        VoidResponse response = new VoidResponse();\n+\n+    // If applicable, perform a paged content lookup (i.e., not streamed), replacing its results in the returned response\n+    if (null != contentLookupSettings) {\n+      final NextContentCriteria criteria = new NextContentCriteria(id, contentLookupSettings);\n+      response = this.lookupUUIDUtil.lookupContentByNextResponse(criteria, response);\n+    }\n+\n+    return response;\n+  }\n+\n+  /**\n+   * Releases the resources associated with this query. Any currently running calls to 'next' on the query will continue until they finish. Calls to 'next'\n+   * after a 'close' will start over at page 1.\n+   *\n+   * @param id\n+   * @return datawave.webservice.result.VoidResponse\n+   * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user, by specifying a chain of DNs of the identities to proxy\n+   * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n+   * @RequestHeader query-session-id session id value used for load balancing purposes. query-session-id can be placed in the request in a Cookie header or as\n+   * a query parameter\n+   * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n+   * @HTTP 200 success\n+   * @HTTP 404 queries not found using {@code id}\n+   * @HTTP 500 internal server error\n+   */\n+  @PUT\n+  @POST\n+  @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\",\n+      \"application/x-protobuf\",\n+      \"application/x-protostuff\"})\n+  @Path(\"/{id}/close\")\n+  @GZIP\n+  @ClearQuerySessionId\n+  @Interceptors({ResponseInterceptor.class, RequiredInterceptor.class})\n+  @Override\n+  @Timed(name = \"dw.query.close\", absolute = true)\n+  public VoidResponse close(@Required(\"id\") @PathParam(\"id\") String id) {\n+    return close(id, ctx.getCallerPrincipal());\n+  }\n+\n+  private VoidResponse close(String id, Principal principal) {\n+    VoidResponse response = new VoidResponse();\n+    try {\n+      boolean connectionRequestCanceled = accumuloConnectionRequestBean.cancelConnectionRequest(id, principal);\n+      Pair<QueryLogic<?>, AccumuloClient> tuple =\n+          qlCache.pollIfOwnedBy(id, ((DatawavePrincipal) principal).getShortName());\n+      if (tuple == null) {\n         try {\n-            boolean connectionRequestCanceled = accumuloConnectionRequestBean.cancelConnectionRequest(id);\n-            Pair<QueryLogic<?>,AccumuloClient> tuple = qlCache.pollIfOwnedBy(id, ctx.getCallerPrincipal().getName());\n-            \n-            if (tuple == null) {\n-                try {\n-                    RunningQuery query = getQueryById(id);\n-                    query.cancel();\n-                    close(query);\n-                } catch (Exception e) {\n-                    log.debug(\"Failed to cancel \" + id + \", checking if closed previously\");\n-                    // if this is a query that is in the closed query cache, then we have already successfully closed this query so ignore\n-                    if (!closedQueryCache.exists(id)) {\n-                        log.debug(\"Failed to cancel \" + id + \", checking if connection request was canceled\");\n-                        // if connection request was canceled, then the call was successful even if a RunningQuery was not found\n-                        if (!connectionRequestCanceled) {\n-                            log.error(\"Failed to cancel \" + id, e);\n-                            throw e;\n-                        }\n-                    }\n-                }\n-                response.addMessage(id + \" canceled.\");\n-            } else {\n-                QueryLogic<?> logic = tuple.getFirst();\n-                try {\n-                    logic.close();\n-                } catch (Exception e) {\n-                    log.error(\"Exception occurred while canceling query logic; may be innocuous if scanners were running.\", e);\n-                }\n-                connectionFactory.returnClient(tuple.getSecond());\n-                response.addMessage(id + \" closed before create completed due to cancel.\");\n-            }\n-            \n-            // no longer need to remember this query\n-            closedQueryCache.remove(id);\n-            \n-            return response;\n-        } catch (DatawaveWebApplicationException e) {\n-            throw e;\n+          RunningQuery query = getQueryById(id, principal);\n+          close(query);\n         } catch (Exception e) {\n-            QueryException qe = new QueryException(DatawaveErrorCode.CANCELLATION_ERROR, e, MessageFormat.format(\"query_id: {0}\", id));\n-            log.error(qe, e);\n-            response.addException(qe.getBottomQueryException());\n-            int statusCode = qe.getBottomQueryException().getStatusCode();\n-            throw new DatawaveWebApplicationException(qe, response, statusCode);\n-        }\n-    }\n-    \n-    /**\n-     * <strong>JBossAdministrator or Administrator credentials required.</strong>\n-     *\n-     * @param id\n-     * @return\n-     */\n-    @PUT\n-    @POST\n-    @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\", \"application/x-protobuf\",\n-            \"application/x-protostuff\"})\n-    @Path(\"/{id}/adminCancel\")\n-    @GZIP\n-    @Interceptors({ResponseInterceptor.class, RequiredInterceptor.class})\n-    @RolesAllowed({\"Administrator\", \"JBossAdministrator\"})\n-    @Override\n-    public VoidResponse adminCancel(@Required(\"id\") @PathParam(\"id\") String id) {\n-        VoidResponse response = new VoidResponse();\n+          log.debug(\"Failed to close \" + id + \", checking if closed previously\");\n+          // if this is a query that is in the closed query cache, then we have already successfully closed this query so ignore\n+          if (!closedQueryCache.exists(id)) {\n+            log.debug(\"Failed to close \" + id + \", checking if connection request was canceled\");\n+            // if connection request was canceled, then the call was successful even if a RunningQuery was not found\n+            if (!connectionRequestCanceled) {\n+              log.error(\"Failed to close \" + id, e);\n+              throw e;\n+            }\n+          }\n+        }\n+        response.addMessage(id + \" closed.\");\n+      } else {\n+        QueryLogic<?> logic = tuple.getFirst();\n         try {\n-            boolean connectionRequestCanceled = accumuloConnectionRequestBean.adminCancelConnectionRequest(id);\n-            Pair<QueryLogic<?>,AccumuloClient> tuple = qlCache.poll(id);\n-            if (tuple == null) {\n-                try {\n-                    RunningQuery query = adminGetQueryById(id);\n-                    query.cancel();\n-                    close(query);\n-                } catch (Exception e) {\n-                    log.debug(\"Failed to adminCancel \" + id + \", checking if connection request was canceled\");\n-                    // if connection request was canceled, then the call was successful even if a RunningQuery was not found\n-                    if (!connectionRequestCanceled) {\n-                        log.error(\"Failed to adminCancel \" + id, e);\n-                        throw e;\n-                    }\n-                }\n-                response.addMessage(id + \" closed.\");\n-            } else {\n-                QueryLogic<?> logic = tuple.getFirst();\n-                try {\n-                    logic.close();\n-                } catch (Exception e) {\n-                    log.error(\"Exception occurred while canceling query logic; may be innocuous if scanners were running.\", e);\n-                }\n-                connectionFactory.returnClient(tuple.getSecond());\n-                response.addMessage(id + \" closed before create completed due to cancel.\");\n-            }\n-            \n-            return response;\n-        } catch (DatawaveWebApplicationException e) {\n-            throw e;\n+          logic.close();\n         } catch (Exception e) {\n-            log.error(\"Error cancelling query: \" + id, e);\n-            QueryException qe = new QueryException(DatawaveErrorCode.CANCELLATION_ERROR, e, MessageFormat.format(\"query_id: {0}\", id));\n-            log.error(qe, e);\n-            response.addException(qe.getBottomQueryException());\n-            int statusCode = qe.getBottomQueryException().getStatusCode();\n-            throw new DatawaveWebApplicationException(qe, response, statusCode);\n+          log.error(\"Exception occurred while closing query logic; may be innocuous if scanners were running.\", e);\n         }\n-    }\n-    \n-    /**\n-     * List of current users queries.\n-     * \n-     * @see datawave.webservice.query.runner.QueryExecutorBean#listUserQueries()\n-     *\n-     * @return datawave.webservice.result.QueryImplListResponse\n-     * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user, by specifying a chain of DNs of the identities to proxy\n-     * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n-     * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n-     *\n-     * @HTTP 200 success\n-     * @HTTP 204 success but no results\n-     * @HTTP 500 internal server error\n-     */\n-    @GET\n-    @Path(\"/listAll\")\n-    @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\", \"application/x-protobuf\",\n-            \"application/x-protostuff\"})\n-    @GZIP\n-    @Interceptors(ResponseInterceptor.class)\n-    @Override\n-    @Timed(name = \"dw.query.listUserQueries\", absolute = true)\n-    public QueryImplListResponse listUserQueries() {\n-        QueryImplListResponse response = new QueryImplListResponse();\n+        connectionFactory.returnClient(tuple.getSecond());\n+        response.addMessage(id + \" closed before create completed.\");\n+      }\n+\n+      // no longer need to remember this query\n+      closedQueryCache.remove(id);\n+\n+      return response;\n+    } catch (DatawaveWebApplicationException e) {\n+      throw e;\n+    } catch (Exception e) {\n+      QueryException qe =\n+          new QueryException(DatawaveErrorCode.CLOSE_ERROR, e, MessageFormat.format(\"query_id: {0}\", id));\n+      log.error(qe, e);\n+      response.addException(qe.getBottomQueryException());\n+      int statusCode = qe.getBottomQueryException().getStatusCode();\n+      throw new DatawaveWebApplicationException(qe, response, statusCode);\n+    }\n+  }\n+\n+  /**\n+   * <strong>JBossAdministrator or Administrator credentials required.</strong>\n+   *\n+   * @param id\n+   * @return\n+   */\n+  @PUT\n+  @POST\n+  @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\",\n+      \"application/x-protobuf\",\n+      \"application/x-protostuff\"})\n+  @Path(\"/{id}/adminClose\")\n+  @GZIP\n+  @Interceptors({ResponseInterceptor.class, RequiredInterceptor.class})\n+  @RolesAllowed({\"Administrator\", \"JBossAdministrator\"})\n+  @Override\n+  public VoidResponse adminClose(@Required(\"id\") @PathParam(\"id\") String id) {\n+    VoidResponse response = new VoidResponse();\n+    try {\n+      boolean connectionRequestCanceled = accumuloConnectionRequestBean.adminCancelConnectionRequest(id);\n+      Pair<QueryLogic<?>, AccumuloClient> tuple = qlCache.poll(id);\n+      if (tuple == null) {\n         try {\n-            List<Query> userQueries = persister.findByUser();\n-            if (null == userQueries) {\n-                throw new NoResultsQueryException(DatawaveErrorCode.NO_QUERIES_FOUND);\n-            } else {\n-                response.setQuery(userQueries);\n-                return response;\n-            }\n-        } catch (DatawaveWebApplicationException e) {\n-            throw e;\n+          RunningQuery query = adminGetQueryById(id);\n+          close(query);\n         } catch (Exception e) {\n-            QueryException qe = new QueryException(DatawaveErrorCode.QUERY_LISTING_ERROR, e);\n-            log.error(qe, e);\n-            response.addException(qe.getBottomQueryException());\n-            int statusCode = qe.getBottomQueryException().getStatusCode();\n-            throw new DatawaveWebApplicationException(qe, response, statusCode);\n+          log.debug(\"Failed to adminClose \" + id + \", checking if connection request was canceled\");\n+          // if connection request was canceled, then the call was successful even if a RunningQuery was not found\n+          if (!connectionRequestCanceled) {\n+            log.error(\"Failed to adminClose \" + id, e);\n+            throw e;\n+          }\n         }\n-    }\n-    \n-    /**\n-     * Lists query info for the given id.\n-     *\n-     * @param id\n-     *            - the id of the query to locate (@Required)\n-     * @see datawave.webservice.query.runner.QueryExecutorBean#get(String) get(String) for the @Required definition\n-     *\n-     * @return datawave.webservice.result.QueryImplListResponse\n-     * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user, by specifying a chain of DNs of the identities to proxy\n-     * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n-     * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n-     *\n-     * @HTTP 200 success\n-     * @HTTP 404 queries not found using {@code id}\n-     * @HTTP 500 internal server error\n-     */\n-    @GET\n-    @Path(\"/{id}\")\n-    @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\", \"application/x-protobuf\",\n-            \"application/x-protostuff\"})\n-    @GZIP\n-    @Interceptors({RequiredInterceptor.class, ResponseInterceptor.class})\n-    @Timed(name = \"dw.query.listQueryByID\", absolute = true)\n-    public QueryImplListResponse get(@Required(\"id\") @PathParam(\"id\") String id) {\n-        QueryImplListResponse response = new QueryImplListResponse();\n-        List<Query> results = new ArrayList<>();\n+        response.addMessage(id + \" closed.\");\n+      } else {\n+        QueryLogic<?> logic = tuple.getFirst();\n         try {\n-            RunningQuery query = getQueryById(id);\n-            if (null != query) {\n-                results.add(query.getSettings());\n-            }\n-            response.setQuery(results);\n-            return response;\n-        } catch (DatawaveWebApplicationException e) {\n-            throw e;\n+          logic.close();\n         } catch (Exception e) {\n-            QueryException qe = new QueryException(DatawaveErrorCode.QUERY_GET_ERROR, e, MessageFormat.format(\"queryID: {0}\", id));\n-            log.error(qe, e);\n-            response.addException(qe.getBottomQueryException());\n-            int statusCode = qe.getBottomQueryException().getStatusCode();\n-            throw new DatawaveWebApplicationException(qe, response, statusCode);\n+          log.error(\"Exception occurred while closing query logic; may be innocuous if scanners were running.\", e);\n         }\n+        connectionFactory.returnClient(tuple.getSecond());\n+        response.addMessage(id + \" closed before create completed.\");\n+      }\n+\n+      return response;\n+    } catch (DatawaveWebApplicationException e) {\n+      throw e;\n+    } catch (Exception e) {\n+      QueryException qe = new QueryException(DatawaveErrorCode.CLOSE_ERROR);\n+      log.error(qe, e);\n+      response.addException(qe.getBottomQueryException());\n+      int statusCode = qe.getBottomQueryException().getStatusCode();\n+      throw new DatawaveWebApplicationException(qe, response, statusCode);\n+    }\n+  }\n+\n+  private void close(RunningQuery query) throws Exception {\n+\n+    String queryId = query.getSettings().getId().toString();\n+\n+    log.debug(\"Closing \" + queryId);\n+\n+    try {\n+      query.closeConnection(connectionFactory);\n+    } catch (Exception e) {\n+      log.error(\"Failed to close connection for \" + queryId, e);\n     }\n-    \n-    /**\n-     * Lists queries for the current user with the given name.\n-     *\n-     * @param name\n-     *            the name of the query to locate (@Required)\n-     * @see datawave.webservice.query.runner.QueryExecutorBean#list(String) list(String) for the @Required definition\n-     *\n-     * @return datawave.webservice.result.QueryImplListResponse\n-     * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user, by specifying a chain of DNs of the identities to proxy\n-     * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n-     * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n-     *\n-     * @HTTP 200 success\n-     * @HTTP 404 if the query with {@code name} does not belong to caller, you will never see it\n-     * @HTTP 404 queries not found using {@code name}\n-     * @HTTP 400 if {@code name} parameter is not included\n-     * @HTTP 500 internal server error\n-     */\n-    @GET\n-    @Path(\"/list\")\n-    @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\", \"application/x-protobuf\",\n-            \"application/x-protostuff\"})\n-    @GZIP\n-    @Interceptors({RequiredInterceptor.class, ResponseInterceptor.class})\n-    @Override\n-    @Timed(name = \"dw.query.listQueryByName\", absolute = true)\n-    public QueryImplListResponse list(@Required(\"name\") @QueryParam(\"name\") String name) {\n-        QueryImplListResponse response = new QueryImplListResponse();\n-        List<Query> results = new ArrayList<>();\n+\n+    queryCache.remove(queryId);\n+\n+    log.debug(\"Closed \" + queryId);\n+\n+    // The trace was already stopped, but mark the time we closed it in the trace data.\n+    TraceInfo traceInfo = query.getTraceInfo();\n+    if (traceInfo != null) {\n+      try (TraceScope scope = Trace.startSpan(\"query:close\", traceInfo)) {\n+        if (scope.getSpan() != null) {\n+          scope.getSpan().addKVAnnotation(\"closedAt\", new Date().toString());\n+        }\n+        // Spans aren't recorded if they take no time, so sleep for a\n+        // couple milliseconds just to ensure we get something saved.\n         try {\n-            List<RunningQuery> query = getQueryByName(name);\n-            if (null != query) {\n-                for (RunningQuery rq : query)\n-                    results.add(rq.getSettings());\n-            }\n-            response.setQuery(results);\n-            return response;\n-        } catch (DatawaveWebApplicationException e) {\n-            throw e;\n-        } catch (Exception e) {\n-            QueryException qe = new QueryException(DatawaveErrorCode.LIST_ERROR, e);\n-            response.addException(qe.getBottomQueryException());\n-            int statusCode = qe.getBottomQueryException().getStatusCode();\n-            throw new DatawaveWebApplicationException(qe, response, statusCode);\n+          Thread.sleep(2);\n+        } catch (InterruptedException e) {\n+          // ignore\n         }\n+      }\n+      // TODO: not sure this makes any sense anymore in Accumulo 1.8.1\n+      // Tracer.getInstance().flush();\n     }\n-    \n-    /**\n-     * remove (delete) the query\n-     * \n-     * @param id\n-     *\n-     * @return datawave.webservice.result.VoidResponse\n-     * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user, by specifying a chain of DNs of the identities to proxy\n-     * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n-     * @RequestHeader query-session-id session id value used for load balancing purposes. query-session-id can be placed in the request in a Cookie header or as\n-     *                a query parameter\n-     * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n-     *\n-     * @HTTP 200 success\n-     * @HTTP 404 queries not found using {@code id}\n-     * @HTTP 500 internal server error\n-     */\n-    @DELETE\n-    @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\", \"application/x-protobuf\",\n-            \"application/x-protostuff\"})\n-    @Path(\"/{id}/remove\")\n-    @GZIP\n-    @Interceptors({ResponseInterceptor.class, RequiredInterceptor.class})\n-    @Override\n-    @Timed(name = \"dw.query.remove\", absolute = true)\n-    public VoidResponse remove(@Required(\"id\") @PathParam(\"id\") String id) {\n-        VoidResponse response = new VoidResponse();\n+  }\n+\n+  /**\n+   * Releases the resources associated with this query. Any currently running calls to 'next' on the query will be stopped. Calls to 'next' after a 'cancel'\n+   * will start over at page 1.\n+   *\n+   * @param id\n+   * @return datawave.webservice.result.VoidResponse\n+   * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user, by specifying a chain of DNs of the identities to proxy\n+   * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n+   * @RequestHeader query-session-id session id value used for load balancing purposes. query-session-id can be placed in the request in a Cookie header or as\n+   * a query parameter\n+   * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n+   * @HTTP 200 success\n+   * @HTTP 404 queries not found using {@code id}\n+   * @HTTP 500 internal server error\n+   */\n+  @PUT\n+  @POST\n+  @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\",\n+      \"application/x-protobuf\",\n+      \"application/x-protostuff\"})\n+  @Path(\"/{id}/cancel\")\n+  @GZIP\n+  @ClearQuerySessionId\n+  @Interceptors({ResponseInterceptor.class, RequiredInterceptor.class})\n+  @Override\n+  @Timed(name = \"dw.query.cancel\", absolute = true)\n+  public VoidResponse cancel(@Required(\"id\") @PathParam(\"id\") String id) {\n+    VoidResponse response = new VoidResponse();\n+    try {\n+      boolean connectionRequestCanceled = accumuloConnectionRequestBean.cancelConnectionRequest(id);\n+      Pair<QueryLogic<?>, AccumuloClient> tuple = qlCache.pollIfOwnedBy(id, ctx.getCallerPrincipal().getName());\n+\n+      if (tuple == null) {\n         try {\n-            boolean connectionRequestCanceled = accumuloConnectionRequestBean.cancelConnectionRequest(id);\n-            try {\n-                RunningQuery query = getQueryById(id);\n-                close(query);\n-                persister.remove(query.getSettings());\n-            } catch (Exception e) {\n-                log.debug(\"Failed to remove \" + id + \", checking if closed previously\");\n-                // if this is a query that is in the closed query cache, then we have already successfully closed this query so ignore\n-                if (!closedQueryCache.exists(id)) {\n-                    log.debug(\"Failed to remove \" + id + \", checking if connection request was canceled\");\n-                    // if connection request was canceled, then the call was successful even if a RunningQuery was not found\n-                    if (!connectionRequestCanceled) {\n-                        log.error(\"Failed to remove \" + id, e);\n-                        throw e;\n-                    }\n-                }\n-            }\n-            response.addMessage(id + \" removed.\");\n-            \n-            // no longer need to remember this query\n-            closedQueryCache.remove(id);\n-            \n-            return response;\n-        } catch (DatawaveWebApplicationException e) {\n-            throw e;\n+          RunningQuery query = getQueryById(id);\n+          query.cancel();\n+          close(query);\n         } catch (Exception e) {\n-            QueryException qe = new QueryException(DatawaveErrorCode.QUERY_REMOVAL_ERROR, e, MessageFormat.format(\"query_id: {0}\", id));\n-            log.error(qe, e);\n-            response.addException(qe.getBottomQueryException());\n-            int statusCode = qe.getBottomQueryException().getStatusCode();\n-            throw new DatawaveWebApplicationException(qe, response, statusCode);\n-        }\n-    }\n-    \n-    /**\n-     * Duplicates a query and allows modification of optional properties\n-     *\n-     * @param id\n-     *            - the ID of the query to copy (required)\n-     * @param newQueryName\n-     *            - name of the new query (@Required)\n-     * @param newQueryLogicName\n-     *            - defaults to old logic, name of class that this query should be run with (optional)\n-     * @param newQuery\n-     *            - defaults to old query, string used in lookup (optional, auditing required if changed)\n-     * @param newColumnVisibility\n-     *            - defaults to old column visibility, for query AND justification (optional, auditing required if changed)\n-     * @param newBeginDate\n-     *            - defaults to old begin date, begin range for the query (optional, auditing required if changed)\n-     * @param newEndDate\n-     *            - defaults to old end date, end range for the query (optional, auditing required if changed)\n-     * @param newQueryAuthorizations\n-     *            - defaults to old authorizations, use in the query (optional, auditing required if changed)\n-     * @param newExpirationDate\n-     *            - defaults to old expiration, meaningless if transient (optional)\n-     * @param newPagesize\n-     *            - defaults to old pagesize, number of results to return on each call to next() (optional)\n-     * @param newPageTimeout\n-     *            - specify timeout (in minutes) for each call to next(), defaults to -1 indicating disabled (optional)\n-     * @param newMaxResultsOverride\n-     *            - specify max results (optional)\n-     * @param newPersistenceMode\n-     *            - defaults to PERSISTENT, indicates whether or not the query is persistent (optional)\n-     * @param newParameters\n-     *            - defaults to old, optional parameters to the query, a semi-colon separated list name=value pairs (optional, auditing required if changed)\n-     * @param trace\n-     *            - optional (defaults to {@code false}) indication of whether or not the query should be traced using the distributed tracing mechanism\n-     * @see datawave.webservice.query.runner.QueryExecutorBean#duplicateQuery(String, String, String, String, String, Date, Date, String, Date, Integer,\n-     *      Integer, Long, QueryPersistence, String, boolean)\n-     *\n-     * @return {@code datawave.webservice.result.GenericResponse<String>}\n-     * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user, by specifying a chain of DNs of the identities to proxy\n-     * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n-     * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n-     *\n-     * @HTTP 200 success\n-     * @HTTP 400 if invalid params or missing queryName param\n-     * @HTTP 404 if query not found\n-     * @HTTP 500 internal server error\n-     */\n-    @POST\n-    @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\", \"application/x-protobuf\",\n-            \"application/x-protostuff\"})\n-    @Path(\"/{id}/duplicate\")\n-    @GZIP\n-    @Interceptors({ResponseInterceptor.class, RequiredInterceptor.class})\n-    @Override\n-    @Timed(name = \"dw.query.duplicateQuery\", absolute = true)\n-    public GenericResponse<String> duplicateQuery(@PathParam(\"id\") String id, @Required(\"queryName\") @FormParam(\"queryName\") String newQueryName,\n-                    @FormParam(\"logicName\") String newQueryLogicName, @FormParam(\"query\") String newQuery,\n-                    @FormParam(\"columnVisibility\") String newColumnVisibility,\n-                    @FormParam(\"begin\") @DateFormat(defaultTime = \"000000\", defaultMillisec = \"000\") Date newBeginDate, @FormParam(\"end\") @DateFormat(\n-                                    defaultTime = \"235959\", defaultMillisec = \"999\") Date newEndDate, @FormParam(\"auths\") String newQueryAuthorizations,\n-                    @FormParam(\"expiration\") @DateFormat(defaultTime = \"235959\", defaultMillisec = \"999\") Date newExpirationDate,\n-                    @FormParam(\"pagesize\") Integer newPagesize, @FormParam(\"pageTimeout\") Integer newPageTimeout,\n-                    @FormParam(\"maxResultsOverride\") Long newMaxResultsOverride, @FormParam(\"persistence\") QueryPersistence newPersistenceMode,\n-                    @FormParam(\"params\") String newParameters, @FormParam(\"trace\") @DefaultValue(\"false\") boolean trace) {\n-        \n-        GenericResponse<String> response = new GenericResponse<>();\n-        \n+          log.debug(\"Failed to cancel \" + id + \", checking if closed previously\");\n+          // if this is a query that is in the closed query cache, then we have already successfully closed this query so ignore\n+          if (!closedQueryCache.exists(id)) {\n+            log.debug(\"Failed to cancel \" + id + \", checking if connection request was canceled\");\n+            // if connection request was canceled, then the call was successful even if a RunningQuery was not found\n+            if (!connectionRequestCanceled) {\n+              log.error(\"Failed to cancel \" + id, e);\n+              throw e;\n+            }\n+          }\n+        }\n+        response.addMessage(id + \" canceled.\");\n+      } else {\n+        QueryLogic<?> logic = tuple.getFirst();\n         try {\n-            if (null == newQueryName || newQueryName.length() < 1) {\n-                throw new BadRequestQueryException(DatawaveErrorCode.QUERY_NAME_REQUIRED);\n-            }\n-            \n-            RunningQuery templateQuery = getQueryById(id);\n-            \n-            Query q = templateQuery.getSettings().duplicate(newQueryName);\n-            QueryPersistence persistence = QueryPersistence.PERSISTENT; // default value\n-            // TODO: figure out a way to set this to the same as the existing query\n-            if (null != newPersistenceMode) {\n-                persistence = newPersistenceMode;\n-            }\n-            \n-            // TODO: add validation for all these sets\n-            // maybe set variables instead of stuffing in query\n-            if (newQueryLogicName != null) {\n-                q.setQueryLogicName(queryLogicFactory.getQueryLogic(newQueryLogicName, ctx.getCallerPrincipal()).getLogicName());\n-            }\n-            if (newQuery != null) {\n-                q.setQuery(newQuery);\n-            }\n-            if (newBeginDate != null) {\n-                q.setBeginDate(newBeginDate);\n-            }\n-            if (newEndDate != null) {\n-                q.setEndDate(newEndDate);\n-            }\n-            if (newQueryAuthorizations != null) {\n-                q.setQueryAuthorizations(newQueryAuthorizations);\n-            }\n-            if (newExpirationDate != null) {\n-                q.setExpirationDate(newExpirationDate);\n-            }\n-            if (newPagesize != null) {\n-                q.setPagesize(newPagesize);\n-            }\n-            if (newMaxResultsOverride != null) {\n-                q.setMaxResultsOverride(newMaxResultsOverride);\n-            }\n-            if (newPageTimeout != null) {\n-                q.setPageTimeout(newPageTimeout);\n-            }\n-            Set<Parameter> params = new HashSet<>();\n-            if (newParameters != null) {\n-                String[] param = newParameters.split(QueryImpl.PARAMETER_SEPARATOR);\n-                for (String yyy : param) {\n-                    String[] parts = yyy.split(QueryImpl.PARAMETER_NAME_VALUE_SEPARATOR);\n-                    if (parts.length == 2) {\n-                        params.add(new Parameter(parts[0], parts[1]));\n-                    }\n-                }\n-            }\n-            MultivaluedMap<String,String> newSettings = q.toMap();\n-            newSettings.putSingle(QueryParameters.QUERY_PERSISTENCE, persistence.name());\n-            return createQuery(q.getQueryLogicName(), newSettings);\n-        } catch (DatawaveWebApplicationException e) {\n-            throw e;\n+          logic.close();\n         } catch (Exception e) {\n-            QueryException qe = new QueryException(DatawaveErrorCode.QUERY_DUPLICATION_ERROR, e);\n-            log.error(qe, e);\n-            response.addException(qe.getBottomQueryException());\n-            if (e.getClass() == IllegalArgumentException.class) {\n-                throw new BadRequestException(qe, response);\n-            }\n-            int statusCode = qe.getBottomQueryException().getStatusCode();\n-            throw new DatawaveWebApplicationException(qe, response, statusCode);\n+          log.error(\"Exception occurred while canceling query logic; may be innocuous if scanners were running.\", e);\n         }\n-        \n-    }\n-    \n-    /**\n-     * Updates a query object identified by the id using the updated parameters.\n-     *\n-     * @param id\n-     *            - the ID of the query to update (required)\n-     * @param queryLogicName\n-     *            - name of class that this query should be run with (optional)\n-     * @param query\n-     *            - query string (optional, auditing required if changed)\n-     * @param beginDate\n-     *            - begin date range for the query (optional, auditing required if changed)\n-     * @param endDate\n-     *            - end date range for the query (optional, auditing required if changed)\n-     * @param queryAuthorizations\n-     *            - authorizations for use in the query (optional, auditing required if changed)\n-     * @param expirationDate\n-     *            - meaningless if transient (optional)\n-     * @param pagesize\n-     *            - number of results to return on each call to next() (optional)\n-     * @param pageTimeout\n-     *            - specify timeout (in minutes) for each call to next(), defaults to -1 indicating disabled (optional)\n-     * @param maxResultsOverride\n-     *            - specify max results (optional)\n-     * @param persistenceMode\n-     *            - indicates whether or not the query is persistent (optional)\n-     * @param parameters\n-     *            - optional parameters to the query, a semi-colon separated list name=value pairs (optional, auditing required if changed)\n-     * @see datawave.webservice.query.runner.QueryExecutorBean#updateQuery(String, String, String, String, java.util.Date, java.util.Date, String,\n-     *      java.util.Date, Integer, Integer, Long, datawave.webservice.query.QueryPersistence, String)\n-     *\n-     * @return {@code datawave.webservice.result.GenericResponse<String>}\n-     * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user, by specifying a chain of DNs of the identities to proxy\n-     * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n-     * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n-     *\n-     * @HTTP 200 success\n-     * @HTTP 400 if invalid param or no params\n-     * @HTTP 404 queries not found using {@code name}\n-     * @HTTP 500 internal server error\n-     */\n-    @PUT\n-    @POST\n-    @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\", \"application/x-protobuf\",\n-            \"application/x-protostuff\"})\n-    @Path(\"/{id}/update\")\n-    @GZIP\n-    @Interceptors(ResponseInterceptor.class)\n-    @Timed(name = \"dw.query.updateQuery\", absolute = true)\n-    public GenericResponse<String> updateQuery(@PathParam(\"id\") String id, @FormParam(\"logicName\") String queryLogicName, @FormParam(\"query\") String query,\n-                    @FormParam(\"columnVisibility\") String newColumnVisibility,\n-                    @FormParam(\"begin\") @DateFormat(defaultTime = \"000000\", defaultMillisec = \"000\") Date beginDate, @FormParam(\"end\") @DateFormat(\n-                                    defaultTime = \"235959\", defaultMillisec = \"999\") Date endDate, @FormParam(\"auths\") String queryAuthorizations,\n-                    @FormParam(\"expiration\") @DateFormat(defaultTime = \"235959\", defaultMillisec = \"999\") Date expirationDate,\n-                    @FormParam(\"pagesize\") Integer pagesize, @FormParam(\"pageTimeout\") Integer pageTimeout,\n-                    @FormParam(\"maxResultsOverride\") Long maxResultsOverride, @FormParam(\"persistence\") QueryPersistence persistenceMode,\n-                    @FormParam(\"params\") String parameters) {\n-        GenericResponse<String> response = new GenericResponse<>();\n+        connectionFactory.returnClient(tuple.getSecond());\n+        response.addMessage(id + \" closed before create completed due to cancel.\");\n+      }\n+\n+      // no longer need to remember this query\n+      closedQueryCache.remove(id);\n+\n+      return response;\n+    } catch (DatawaveWebApplicationException e) {\n+      throw e;\n+    } catch (Exception e) {\n+      QueryException qe =\n+          new QueryException(DatawaveErrorCode.CANCELLATION_ERROR, e, MessageFormat.format(\"query_id: {0}\", id));\n+      log.error(qe, e);\n+      response.addException(qe.getBottomQueryException());\n+      int statusCode = qe.getBottomQueryException().getStatusCode();\n+      throw new DatawaveWebApplicationException(qe, response, statusCode);\n+    }\n+  }\n+\n+  /**\n+   * <strong>JBossAdministrator or Administrator credentials required.</strong>\n+   *\n+   * @param id\n+   * @return\n+   */\n+  @PUT\n+  @POST\n+  @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\",\n+      \"application/x-protobuf\",\n+      \"application/x-protostuff\"})\n+  @Path(\"/{id}/adminCancel\")\n+  @GZIP\n+  @Interceptors({ResponseInterceptor.class, RequiredInterceptor.class})\n+  @RolesAllowed({\"Administrator\", \"JBossAdministrator\"})\n+  @Override\n+  public VoidResponse adminCancel(@Required(\"id\") @PathParam(\"id\") String id) {\n+    VoidResponse response = new VoidResponse();\n+    try {\n+      boolean connectionRequestCanceled = accumuloConnectionRequestBean.adminCancelConnectionRequest(id);\n+      Pair<QueryLogic<?>, AccumuloClient> tuple = qlCache.poll(id);\n+      if (tuple == null) {\n         try {\n-            RunningQuery rq = getQueryById(id);\n-            updateQuery(response, rq, queryLogicName, query, beginDate, endDate, queryAuthorizations, expirationDate, pagesize, pageTimeout,\n-                            maxResultsOverride, persistenceMode, parameters);\n-            \n-            response.setResult(id);\n-            return response;\n-        } catch (DatawaveWebApplicationException e) {\n-            throw e;\n+          RunningQuery query = adminGetQueryById(id);\n+          query.cancel();\n+          close(query);\n         } catch (Exception e) {\n-            QueryException qe = new QueryException(DatawaveErrorCode.QUERY_UPDATE_ERROR, e, MessageFormat.format(\"query_id: {0}\", id));\n-            log.error(qe, e);\n-            response.addException(qe.getBottomQueryException());\n-            if (e.getClass() == IllegalArgumentException.class) {\n-                throw new BadRequestException(qe, response);\n-            }\n-            int statusCode = qe.getBottomQueryException().getStatusCode();\n-            throw new DatawaveWebApplicationException(qe, response, statusCode);\n-        }\n-    }\n-    \n-    private void updateQuery(GenericResponse<String> response, RunningQuery runningQuery, String queryLogicName, String query, Date beginDate, Date endDate,\n-                    String queryAuthorizations, Date expirationDate, Integer pagesize, Integer pageTimeout, Long maxResultsOverride,\n-                    QueryPersistence persistenceMode, String parameters) throws Exception {\n-        // Find out who/what called this method\n-        Principal p = ctx.getCallerPrincipal();\n-        String userid = p.getName();\n-        Collection<Collection<String>> cbAuths = new HashSet<>();\n-        if (p instanceof DatawavePrincipal) {\n-            DatawavePrincipal dp = (DatawavePrincipal) p;\n-            userid = dp.getShortName();\n-            cbAuths.addAll(dp.getAuthorizations());\n-        }\n-        log.trace(userid + \" has authorizations \" + cbAuths);\n-        \n-        Query q = runningQuery.getSettings();\n-        \n-        // validate persistence mode first\n-        if (persistenceMode != null) {\n-            switch (persistenceMode) {\n-                case PERSISTENT:\n-                    if (q.getQueryName() == null)\n-                        throw new BadRequestQueryException(DatawaveErrorCode.QUERY_NAME_REQUIRED);\n-                    break;\n-                case TRANSIENT:\n-                    break;\n-                default:\n-                    throw new BadRequestQueryException(DatawaveErrorCode.UNKNOWN_PERSISTENCE_MODE, MessageFormat.format(\"Mode = {0}\", persistenceMode));\n-            }\n+          log.debug(\"Failed to adminCancel \" + id + \", checking if connection request was canceled\");\n+          // if connection request was canceled, then the call was successful even if a RunningQuery was not found\n+          if (!connectionRequestCanceled) {\n+            log.error(\"Failed to adminCancel \" + id, e);\n+            throw e;\n+          }\n         }\n-        \n-        // test for any auditable updates\n-        if (query != null || beginDate != null || endDate != null || queryAuthorizations != null) {\n-            // must clone/audit attempt first\n-            Query duplicate = q.duplicate(q.getQueryName());\n-            duplicate.setId(q.getId());\n-            \n-            updateQueryParams(duplicate, queryLogicName, query, beginDate, endDate, queryAuthorizations, expirationDate, pagesize, pageTimeout,\n-                            maxResultsOverride, parameters);\n-            \n-            // Fire off an audit prior to updating\n-            Set<String> methodAuths = new HashSet<>(Arrays.asList(q.getQueryAuthorizations().split(\"\\\\s*,\\\\s*\")));\n-            cbAuths.retainAll(methodAuths);\n-            AuditType auditType = runningQuery.getLogic().getAuditType(runningQuery.getSettings());\n-            if (!auditType.equals(AuditType.NONE)) {\n-                try {\n-                    auditor.audit(duplicate.toMap());\n-                } catch (IllegalArgumentException e) {\n-                    log.error(\"Error validating audit parameters\", e);\n-                    BadRequestQueryException qe = new BadRequestQueryException(DatawaveErrorCode.MISSING_REQUIRED_PARAMETER, e);\n-                    response.addException(qe);\n-                    throw new BadRequestException(qe, response);\n-                } catch (Exception e) {\n-                    QueryException qe = new QueryException(DatawaveErrorCode.QUERY_AUDITING_ERROR, e);\n-                    log.error(qe, e);\n-                    response.addException(qe.getBottomQueryException());\n-                    throw e;\n-                }\n-            }\n+        response.addMessage(id + \" closed.\");\n+      } else {\n+        QueryLogic<?> logic = tuple.getFirst();\n+        try {\n+          logic.close();\n+        } catch (Exception e) {\n+          log.error(\"Exception occurred while canceling query logic; may be innocuous if scanners were running.\", e);\n         }\n-        \n-        // update the actual running query\n-        updateQueryParams(q, queryLogicName, query, beginDate, endDate, queryAuthorizations, expirationDate, pagesize, pageTimeout, maxResultsOverride,\n-                        parameters);\n-        \n-        // update the persistenceMode post audit\n-        if (persistenceMode != null) {\n-            switch (persistenceMode) {\n-                case PERSISTENT:\n-                    persister.update(q);\n-                    break;\n-                case TRANSIENT:\n-                    persister.remove(q);\n-                    break;\n-            }\n+        connectionFactory.returnClient(tuple.getSecond());\n+        response.addMessage(id + \" closed before create completed due to cancel.\");\n+      }\n+\n+      return response;\n+    } catch (DatawaveWebApplicationException e) {\n+      throw e;\n+    } catch (Exception e) {\n+      log.error(\"Error cancelling query: \" + id, e);\n+      QueryException qe =\n+          new QueryException(DatawaveErrorCode.CANCELLATION_ERROR, e, MessageFormat.format(\"query_id: {0}\", id));\n+      log.error(qe, e);\n+      response.addException(qe.getBottomQueryException());\n+      int statusCode = qe.getBottomQueryException().getStatusCode();\n+      throw new DatawaveWebApplicationException(qe, response, statusCode);\n+    }\n+  }\n+\n+  /**\n+   * List of current users queries.\n+   *\n+   * @return datawave.webservice.result.QueryImplListResponse\n+   * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user, by specifying a chain of DNs of the identities to proxy\n+   * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n+   * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n+   * @HTTP 200 success\n+   * @HTTP 204 success but no results\n+   * @HTTP 500 internal server error\n+   * @see datawave.webservice.query.runner.QueryExecutorBean#listUserQueries()\n+   */\n+  @GET\n+  @Path(\"/listAll\")\n+  @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\",\n+      \"application/x-protobuf\",\n+      \"application/x-protostuff\"})\n+  @GZIP\n+  @Interceptors(ResponseInterceptor.class)\n+  @Override\n+  @Timed(name = \"dw.query.listUserQueries\", absolute = true)\n+  public QueryImplListResponse listUserQueries() {\n+    QueryImplListResponse response = new QueryImplListResponse();\n+    try {\n+      List<Query> userQueries = persister.findByUser();\n+      if (null == userQueries) {\n+        throw new NoResultsQueryException(DatawaveErrorCode.NO_QUERIES_FOUND);\n+      } else {\n+        response.setQuery(userQueries);\n+        return response;\n+      }\n+    } catch (DatawaveWebApplicationException e) {\n+      throw e;\n+    } catch (Exception e) {\n+      QueryException qe = new QueryException(DatawaveErrorCode.QUERY_LISTING_ERROR, e);\n+      log.error(qe, e);\n+      response.addException(qe.getBottomQueryException());\n+      int statusCode = qe.getBottomQueryException().getStatusCode();\n+      throw new DatawaveWebApplicationException(qe, response, statusCode);\n+    }\n+  }\n+\n+  /**\n+   * Lists query info for the given id.\n+   *\n+   * @param id - the id of the query to locate (@Required)\n+   * @return datawave.webservice.result.QueryImplListResponse\n+   * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user, by specifying a chain of DNs of the identities to proxy\n+   * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n+   * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n+   * @HTTP 200 success\n+   * @HTTP 404 queries not found using {@code id}\n+   * @HTTP 500 internal server error\n+   * @see datawave.webservice.query.runner.QueryExecutorBean#get(String) get(String) for the @Required definition\n+   */\n+  @GET\n+  @Path(\"/{id}\")\n+  @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\",\n+      \"application/x-protobuf\",\n+      \"application/x-protostuff\"})\n+  @GZIP\n+  @Interceptors({RequiredInterceptor.class, ResponseInterceptor.class})\n+  @Timed(name = \"dw.query.listQueryByID\", absolute = true)\n+  public QueryImplListResponse get(@Required(\"id\") @PathParam(\"id\") String id) {\n+    QueryImplListResponse response = new QueryImplListResponse();\n+    List<Query> results = new ArrayList<>();\n+    try {\n+      RunningQuery query = getQueryById(id);\n+      if (null != query) {\n+        results.add(query.getSettings());\n+      }\n+      response.setQuery(results);\n+      return response;\n+    } catch (DatawaveWebApplicationException e) {\n+      throw e;\n+    } catch (Exception e) {\n+      QueryException qe =\n+          new QueryException(DatawaveErrorCode.QUERY_GET_ERROR, e, MessageFormat.format(\"queryID: {0}\", id));\n+      log.error(qe, e);\n+      response.addException(qe.getBottomQueryException());\n+      int statusCode = qe.getBottomQueryException().getStatusCode();\n+      throw new DatawaveWebApplicationException(qe, response, statusCode);\n+    }\n+  }\n+\n+  /**\n+   * Lists queries for the current user with the given name.\n+   *\n+   * @param name the name of the query to locate (@Required)\n+   * @return datawave.webservice.result.QueryImplListResponse\n+   * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user, by specifying a chain of DNs of the identities to proxy\n+   * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n+   * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n+   * @HTTP 200 success\n+   * @HTTP 404 if the query with {@code name} does not belong to caller, you will never see it\n+   * @HTTP 404 queries not found using {@code name}\n+   * @HTTP 400 if {@code name} parameter is not included\n+   * @HTTP 500 internal server error\n+   * @see datawave.webservice.query.runner.QueryExecutorBean#list(String) list(String) for the @Required definition\n+   */\n+  @GET\n+  @Path(\"/list\")\n+  @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\",\n+      \"application/x-protobuf\",\n+      \"application/x-protostuff\"})\n+  @GZIP\n+  @Interceptors({RequiredInterceptor.class, ResponseInterceptor.class})\n+  @Override\n+  @Timed(name = \"dw.query.listQueryByName\", absolute = true)\n+  public QueryImplListResponse list(@Required(\"name\") @QueryParam(\"name\") String name) {\n+    QueryImplListResponse response = new QueryImplListResponse();\n+    List<Query> results = new ArrayList<>();\n+    try {\n+      List<RunningQuery> query = getQueryByName(name);\n+      if (null != query) {\n+        for (RunningQuery rq : query) {\n+          results.add(rq.getSettings());\n+        }\n+      }\n+      response.setQuery(results);\n+      return response;\n+    } catch (DatawaveWebApplicationException e) {\n+      throw e;\n+    } catch (Exception e) {\n+      QueryException qe = new QueryException(DatawaveErrorCode.LIST_ERROR, e);\n+      response.addException(qe.getBottomQueryException());\n+      int statusCode = qe.getBottomQueryException().getStatusCode();\n+      throw new DatawaveWebApplicationException(qe, response, statusCode);\n+    }\n+  }\n+\n+  /**\n+   * remove (delete) the query\n+   *\n+   * @param id\n+   * @return datawave.webservice.result.VoidResponse\n+   * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user, by specifying a chain of DNs of the identities to proxy\n+   * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n+   * @RequestHeader query-session-id session id value used for load balancing purposes. query-session-id can be placed in the request in a Cookie header or as\n+   * a query parameter\n+   * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n+   * @HTTP 200 success\n+   * @HTTP 404 queries not found using {@code id}\n+   * @HTTP 500 internal server error\n+   */\n+  @DELETE\n+  @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\",\n+      \"application/x-protobuf\",\n+      \"application/x-protostuff\"})\n+  @Path(\"/{id}/remove\")\n+  @GZIP\n+  @Interceptors({ResponseInterceptor.class, RequiredInterceptor.class})\n+  @Override\n+  @Timed(name = \"dw.query.remove\", absolute = true)\n+  public VoidResponse remove(@Required(\"id\") @PathParam(\"id\") String id) {\n+    VoidResponse response = new VoidResponse();\n+    try {\n+      boolean connectionRequestCanceled = accumuloConnectionRequestBean.cancelConnectionRequest(id);\n+      try {\n+        RunningQuery query = getQueryById(id);\n+        close(query);\n+        persister.remove(query.getSettings());\n+      } catch (Exception e) {\n+        log.debug(\"Failed to remove \" + id + \", checking if closed previously\");\n+        // if this is a query that is in the closed query cache, then we have already successfully closed this query so ignore\n+        if (!closedQueryCache.exists(id)) {\n+          log.debug(\"Failed to remove \" + id + \", checking if connection request was canceled\");\n+          // if connection request was canceled, then the call was successful even if a RunningQuery was not found\n+          if (!connectionRequestCanceled) {\n+            log.error(\"Failed to remove \" + id, e);\n+            throw e;\n+          }\n         }\n-        \n-        // Put in the cache by id\n-        queryCache.put(q.getId().toString(), runningQuery);\n+      }\n+      response.addMessage(id + \" removed.\");\n+\n+      // no longer need to remember this query\n+      closedQueryCache.remove(id);\n+\n+      return response;\n+    } catch (DatawaveWebApplicationException e) {\n+      throw e;\n+    } catch (Exception e) {\n+      QueryException qe =\n+          new QueryException(DatawaveErrorCode.QUERY_REMOVAL_ERROR, e, MessageFormat.format(\"query_id: {0}\", id));\n+      log.error(qe, e);\n+      response.addException(qe.getBottomQueryException());\n+      int statusCode = qe.getBottomQueryException().getStatusCode();\n+      throw new DatawaveWebApplicationException(qe, response, statusCode);\n+    }\n+  }\n+\n+  /**\n+   * Duplicates a query and allows modification of optional properties\n+   *\n+   * @param id                     - the ID of the query to copy (required)\n+   * @param newQueryName           - name of the new query (@Required)\n+   * @param newQueryLogicName      - defaults to old logic, name of class that this query should be run with (optional)\n+   * @param newQuery               - defaults to old query, string used in lookup (optional, auditing required if changed)\n+   * @param newColumnVisibility    - defaults to old column visibility, for query AND justification (optional, auditing required if changed)\n+   * @param newBeginDate           - defaults to old begin date, begin range for the query (optional, auditing required if changed)\n+   * @param newEndDate             - defaults to old end date, end range for the query (optional, auditing required if changed)\n+   * @param newQueryAuthorizations - defaults to old authorizations, use in the query (optional, auditing required if changed)\n+   * @param newExpirationDate      - defaults to old expiration, meaningless if transient (optional)\n+   * @param newPagesize            - defaults to old pagesize, number of results to return on each call to next() (optional)\n+   * @param newPageTimeout         - specify timeout (in minutes) for each call to next(), defaults to -1 indicating disabled (optional)\n+   * @param newMaxResultsOverride  - specify max results (optional)\n+   * @param newPersistenceMode     - defaults to PERSISTENT, indicates whether or not the query is persistent (optional)\n+   * @param newParameters          - defaults to old, optional parameters to the query, a semi-colon separated list name=value pairs (optional, auditing required if changed)\n+   * @param trace                  - optional (defaults to {@code false}) indication of whether or not the query should be traced using the distributed tracing mechanism\n+   * @return {@code datawave.webservice.result.GenericResponse<String>}\n+   * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user, by specifying a chain of DNs of the identities to proxy\n+   * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n+   * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n+   * @HTTP 200 success\n+   * @HTTP 400 if invalid params or missing queryName param\n+   * @HTTP 404 if query not found\n+   * @HTTP 500 internal server error\n+   * @see datawave.webservice.query.runner.QueryExecutorBean#duplicateQuery(String, String, String, String, String, Date, Date, String, Date, Integer,\n+   * Integer, Long, QueryPersistence, String, boolean)\n+   */\n+  @POST\n+  @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\",\n+      \"application/x-protobuf\",\n+      \"application/x-protostuff\"})\n+  @Path(\"/{id}/duplicate\")\n+  @GZIP\n+  @Interceptors({ResponseInterceptor.class, RequiredInterceptor.class})\n+  @Override\n+  @Timed(name = \"dw.query.duplicateQuery\", absolute = true)\n+  public GenericResponse<String> duplicateQuery(@PathParam(\"id\") String id,\n+                                                @Required(\"queryName\") @FormParam(\"queryName\") String newQueryName,\n+                                                @FormParam(\"logicName\") String newQueryLogicName,\n+                                                @FormParam(\"query\") String newQuery,\n+                                                @FormParam(\"columnVisibility\") String newColumnVisibility,\n+                                                @FormParam(\"begin\")\n+                                                @DateFormat(defaultTime = \"000000\", defaultMillisec = \"000\")\n+                                                    Date newBeginDate, @FormParam(\"end\") @DateFormat(\n+      defaultTime = \"235959\", defaultMillisec = \"999\") Date newEndDate,\n+                                                @FormParam(\"auths\") String newQueryAuthorizations,\n+                                                @FormParam(\"expiration\")\n+                                                @DateFormat(defaultTime = \"235959\", defaultMillisec = \"999\")\n+                                                    Date newExpirationDate,\n+                                                @FormParam(\"pagesize\") Integer newPagesize,\n+                                                @FormParam(\"pageTimeout\") Integer newPageTimeout,\n+                                                @FormParam(\"maxResultsOverride\") Long newMaxResultsOverride,\n+                                                @FormParam(\"persistence\") QueryPersistence newPersistenceMode,\n+                                                @FormParam(\"params\") String newParameters,\n+                                                @FormParam(\"trace\") @DefaultValue(\"false\") boolean trace) {\n+\n+    GenericResponse<String> response = new GenericResponse<>();\n+\n+    try {\n+      if (null == newQueryName || newQueryName.length() < 1) {\n+        throw new BadRequestQueryException(DatawaveErrorCode.QUERY_NAME_REQUIRED);\n+      }\n+\n+      RunningQuery templateQuery = getQueryById(id);\n+\n+      Query q = templateQuery.getSettings().duplicate(newQueryName);\n+      QueryPersistence persistence = QueryPersistence.PERSISTENT; // default value\n+      // TODO: figure out a way to set this to the same as the existing query\n+      if (null != newPersistenceMode) {\n+        persistence = newPersistenceMode;\n+      }\n+\n+      // TODO: add validation for all these sets\n+      // maybe set variables instead of stuffing in query\n+      if (newQueryLogicName != null) {\n+        q.setQueryLogicName(\n+            queryLogicFactory.getQueryLogic(newQueryLogicName, ctx.getCallerPrincipal()).getLogicName());\n+      }\n+      if (newQuery != null) {\n+        q.setQuery(newQuery);\n+      }\n+      if (newBeginDate != null) {\n+        q.setBeginDate(newBeginDate);\n+      }\n+      if (newEndDate != null) {\n+        q.setEndDate(newEndDate);\n+      }\n+      if (newQueryAuthorizations != null) {\n+        q.setQueryAuthorizations(newQueryAuthorizations);\n+      }\n+      if (newExpirationDate != null) {\n+        q.setExpirationDate(newExpirationDate);\n+      }\n+      if (newPagesize != null) {\n+        q.setPagesize(newPagesize);\n+      }\n+      if (newMaxResultsOverride != null) {\n+        q.setMaxResultsOverride(newMaxResultsOverride);\n+      }\n+      if (newPageTimeout != null) {\n+        q.setPageTimeout(newPageTimeout);\n+      }\n+      Set<Parameter> params = new HashSet<>();\n+      if (newParameters != null) {\n+        String[] param = newParameters.split(QueryImpl.PARAMETER_SEPARATOR);\n+        for (String yyy : param) {\n+          String[] parts = yyy.split(QueryImpl.PARAMETER_NAME_VALUE_SEPARATOR);\n+          if (parts.length == 2) {\n+            params.add(new Parameter(parts[0], parts[1]));\n+          }\n+        }\n+      }\n+      MultivaluedMap<String, String> newSettings = q.toMap();\n+      newSettings.putSingle(QueryParameters.QUERY_PERSISTENCE, persistence.name());\n+      return createQuery(q.getQueryLogicName(), newSettings);\n+    } catch (DatawaveWebApplicationException e) {\n+      throw e;\n+    } catch (Exception e) {\n+      QueryException qe = new QueryException(DatawaveErrorCode.QUERY_DUPLICATION_ERROR, e);\n+      log.error(qe, e);\n+      response.addException(qe.getBottomQueryException());\n+      if (e.getClass() == IllegalArgumentException.class) {\n+        throw new BadRequestException(qe, response);\n+      }\n+      int statusCode = qe.getBottomQueryException().getStatusCode();\n+      throw new DatawaveWebApplicationException(qe, response, statusCode);\n     }\n-    \n-    private void updateQueryParams(Query q, String queryLogicName, String query, Date beginDate, Date endDate, String queryAuthorizations, Date expirationDate,\n-                    Integer pagesize, Integer pageTimeout, Long maxResultsOverride, String parameters) throws CloneNotSupportedException {\n-        Principal p = ctx.getCallerPrincipal();\n-        // TODO: add validation for all these sets\n-        if (queryLogicName != null) {\n-            QueryLogic<?> logic = queryLogicFactory.getQueryLogic(queryLogicName, p);\n-            q.setQueryLogicName(logic.getLogicName());\n-        }\n-        if (query != null) {\n-            q.setQuery(query);\n-        }\n-        if (beginDate != null) {\n-            q.setBeginDate(beginDate);\n-        }\n-        if (endDate != null) {\n-            q.setEndDate(endDate);\n-        }\n-        if (queryAuthorizations != null) {\n-            q.setQueryAuthorizations(queryAuthorizations);\n-        }\n-        if (expirationDate != null) {\n-            q.setExpirationDate(expirationDate);\n-        }\n-        if (pagesize != null) {\n-            q.setPagesize(pagesize);\n-        }\n-        if (pageTimeout != null) {\n-            q.setPageTimeout(pageTimeout);\n-        }\n-        if (maxResultsOverride != null) {\n-            q.setMaxResultsOverride(maxResultsOverride);\n-        }\n-        if (parameters != null) {\n-            Set<Parameter> params = new HashSet<>();\n-            String[] param = parameters.split(QueryImpl.PARAMETER_SEPARATOR);\n-            for (String yyy : param) {\n-                String[] parts = yyy.split(QueryImpl.PARAMETER_NAME_VALUE_SEPARATOR);\n-                if (parts.length == 2) {\n-                    params.add(new Parameter(parts[0], parts[1]));\n-                }\n-            }\n-            q.setParameters(params);\n-        }\n+\n+  }\n+\n+  /**\n+   * Updates a query object identified by the id using the updated parameters.\n+   *\n+   * @param id                  - the ID of the query to update (required)\n+   * @param queryLogicName      - name of class that this query should be run with (optional)\n+   * @param query               - query string (optional, auditing required if changed)\n+   * @param beginDate           - begin date range for the query (optional, auditing required if changed)\n+   * @param endDate             - end date range for the query (optional, auditing required if changed)\n+   * @param queryAuthorizations - authorizations for use in the query (optional, auditing required if changed)\n+   * @param expirationDate      - meaningless if transient (optional)\n+   * @param pagesize            - number of results to return on each call to next() (optional)\n+   * @param pageTimeout         - specify timeout (in minutes) for each call to next(), defaults to -1 indicating disabled (optional)\n+   * @param maxResultsOverride  - specify max results (optional)\n+   * @param persistenceMode     - indicates whether or not the query is persistent (optional)\n+   * @param parameters          - optional parameters to the query, a semi-colon separated list name=value pairs (optional, auditing required if changed)\n+   * @return {@code datawave.webservice.result.GenericResponse<String>}\n+   * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user, by specifying a chain of DNs of the identities to proxy\n+   * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n+   * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n+   * @HTTP 200 success\n+   * @HTTP 400 if invalid param or no params\n+   * @HTTP 404 queries not found using {@code name}\n+   * @HTTP 500 internal server error\n+   * @see datawave.webservice.query.runner.QueryExecutorBean#updateQuery(String, String, String, String, java.util.Date, java.util.Date, String,\n+   * java.util.Date, Integer, Integer, Long, datawave.webservice.query.QueryPersistence, String)\n+   */\n+  @PUT\n+  @POST\n+  @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\",\n+      \"application/x-protobuf\",\n+      \"application/x-protostuff\"})\n+  @Path(\"/{id}/update\")\n+  @GZIP\n+  @Interceptors(ResponseInterceptor.class)\n+  @Timed(name = \"dw.query.updateQuery\", absolute = true)\n+  public GenericResponse<String> updateQuery(@PathParam(\"id\") String id, @FormParam(\"logicName\") String queryLogicName,\n+                                             @FormParam(\"query\") String query,\n+                                             @FormParam(\"columnVisibility\") String newColumnVisibility,\n+                                             @FormParam(\"begin\")\n+                                             @DateFormat(defaultTime = \"000000\", defaultMillisec = \"000\")\n+                                                 Date beginDate, @FormParam(\"end\") @DateFormat(\n+      defaultTime = \"235959\", defaultMillisec = \"999\") Date endDate, @FormParam(\"auths\") String queryAuthorizations,\n+                                             @FormParam(\"expiration\")\n+                                             @DateFormat(defaultTime = \"235959\", defaultMillisec = \"999\")\n+                                                 Date expirationDate,\n+                                             @FormParam(\"pagesize\") Integer pagesize,\n+                                             @FormParam(\"pageTimeout\") Integer pageTimeout,\n+                                             @FormParam(\"maxResultsOverride\") Long maxResultsOverride,\n+                                             @FormParam(\"persistence\") QueryPersistence persistenceMode,\n+                                             @FormParam(\"params\") String parameters) {\n+    GenericResponse<String> response = new GenericResponse<>();\n+    try {\n+      RunningQuery rq = getQueryById(id);\n+      updateQuery(response, rq, queryLogicName, query, beginDate, endDate, queryAuthorizations, expirationDate,\n+          pagesize, pageTimeout,\n+          maxResultsOverride, persistenceMode, parameters);\n+\n+      response.setResult(id);\n+      return response;\n+    } catch (DatawaveWebApplicationException e) {\n+      throw e;\n+    } catch (Exception e) {\n+      QueryException qe =\n+          new QueryException(DatawaveErrorCode.QUERY_UPDATE_ERROR, e, MessageFormat.format(\"query_id: {0}\", id));\n+      log.error(qe, e);\n+      response.addException(qe.getBottomQueryException());\n+      if (e.getClass() == IllegalArgumentException.class) {\n+        throw new BadRequestException(qe, response);\n+      }\n+      int statusCode = qe.getBottomQueryException().getStatusCode();\n+      throw new DatawaveWebApplicationException(qe, response, statusCode);\n     }\n-    \n-    /**\n-     * <strong>Administrator credentials required.</strong> Returns list of queries for some other user\n-     *\n-     * @return datawave.webservice.result.QueryImplListResponse\n-     * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user, by specifying a chain of DNs of the identities to proxy\n-     * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n-     * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n-     *\n-     * @HTTP 200 success\n-     * @HTTP 204 no results for userid\n-     * @HTTP 401 if the user does not have Administrative credentials\n-     * @HTTP 500 internal server error\n-     */\n-    @GET\n-    @Path(\"/{userid}/listAll\")\n-    @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\", \"application/x-protobuf\",\n-            \"application/x-protostuff\"})\n-    @GZIP\n-    @Interceptors(ResponseInterceptor.class)\n-    @RolesAllowed(\"Administrator\")\n-    public QueryImplListResponse listQueriesForUser(@Required(\"userId\") @PathParam(\"userid\") String userId) {\n-        QueryImplListResponse response = new QueryImplListResponse();\n-        try {\n-            List<Query> userQueries = persister.findByUser(userId);\n-            if (null == userQueries) {\n-                throw new NoResultsException(null);\n-            } else {\n-                response.setQuery(userQueries);\n-                return response;\n-            }\n-        } catch (DatawaveWebApplicationException e) {\n-            throw e;\n-        } catch (Exception e) {\n-            QueryException qe = new QueryException(DatawaveErrorCode.QUERY_LISTING_ERROR, e, MessageFormat.format(\"UserId: {0}\", userId));\n-            log.error(qe, e);\n-            response.addException(qe.getBottomQueryException());\n-            int statusCode = qe.getBottomQueryException().getStatusCode();\n-            throw new DatawaveWebApplicationException(qe, response, statusCode);\n-        }\n+  }\n+\n+  private void updateQuery(GenericResponse<String> response, RunningQuery runningQuery, String queryLogicName,\n+                           String query, Date beginDate, Date endDate,\n+                           String queryAuthorizations, Date expirationDate, Integer pagesize, Integer pageTimeout,\n+                           Long maxResultsOverride,\n+                           QueryPersistence persistenceMode, String parameters) throws Exception {\n+    // Find out who/what called this method\n+    Principal p = ctx.getCallerPrincipal();\n+    String userid = p.getName();\n+    Collection<Collection<String>> cbAuths = new HashSet<>();\n+    if (p instanceof DatawavePrincipal) {\n+      DatawavePrincipal dp = (DatawavePrincipal) p;\n+      userid = dp.getShortName();\n+      cbAuths.addAll(dp.getAuthorizations());\n+    }\n+    log.trace(userid + \" has authorizations \" + cbAuths);\n+\n+    Query q = runningQuery.getSettings();\n+\n+    // validate persistence mode first\n+    if (persistenceMode != null) {\n+      switch (persistenceMode) {\n+        case PERSISTENT:\n+          if (q.getQueryName() == null) {\n+            throw new BadRequestQueryException(DatawaveErrorCode.QUERY_NAME_REQUIRED);\n+          }\n+          break;\n+        case TRANSIENT:\n+          break;\n+        default:\n+          throw new BadRequestQueryException(DatawaveErrorCode.UNKNOWN_PERSISTENCE_MODE,\n+              MessageFormat.format(\"Mode = {0}\", persistenceMode));\n+      }\n     }\n-    \n-    /**\n-     * <strong>Administrator credentials required.</strong> Purges the cache of query objects\n-     *\n-     * @return datawave.webservice.result.VoidResponse\n-     * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user, by specifying a chain of DNs of the identities to proxy\n-     * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n-     * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n-     *\n-     * @HTTP 200 success\n-     * @HTTP 401 if the user does not have Administrative credentials\n-     * @HTTP 500 internal server error\n-     */\n-    @POST\n-    @Path(\"/purgeQueryCache\")\n-    @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\", \"application/x-protobuf\",\n-            \"application/x-protostuff\"})\n-    @GZIP\n-    @Interceptors(ResponseInterceptor.class)\n-    @RolesAllowed(\"Administrator\")\n-    public VoidResponse purgeQueryCache() {\n-        VoidResponse response = new VoidResponse();\n+\n+    // test for any auditable updates\n+    if (query != null || beginDate != null || endDate != null || queryAuthorizations != null) {\n+      // must clone/audit attempt first\n+      Query duplicate = q.duplicate(q.getQueryName());\n+      duplicate.setId(q.getId());\n+\n+      updateQueryParams(duplicate, queryLogicName, query, beginDate, endDate, queryAuthorizations, expirationDate,\n+          pagesize, pageTimeout,\n+          maxResultsOverride, parameters);\n+\n+      // Fire off an audit prior to updating\n+      Set<String> methodAuths = new HashSet<>(Arrays.asList(q.getQueryAuthorizations().split(\"\\\\s*,\\\\s*\")));\n+      cbAuths.retainAll(methodAuths);\n+      AuditType auditType = runningQuery.getLogic().getAuditType(runningQuery.getSettings());\n+      if (!auditType.equals(AuditType.NONE)) {\n         try {\n-            queryCache.clear();\n-            return response;\n+          auditor.audit(duplicate.toMap());\n+        } catch (IllegalArgumentException e) {\n+          log.error(\"Error validating audit parameters\", e);\n+          BadRequestQueryException qe = new BadRequestQueryException(DatawaveErrorCode.MISSING_REQUIRED_PARAMETER, e);\n+          response.addException(qe);\n+          throw new BadRequestException(qe, response);\n         } catch (Exception e) {\n-            QueryException qe = new QueryException(DatawaveErrorCode.QUERY_CACHE_PURGE_ERROR, e);\n-            log.error(qe, e);\n-            response.addException(qe.getBottomQueryException());\n-            int statusCode = qe.getBottomQueryException().getStatusCode();\n-            throw new DatawaveWebApplicationException(qe, response, statusCode);\n+          QueryException qe = new QueryException(DatawaveErrorCode.QUERY_AUDITING_ERROR, e);\n+          log.error(qe, e);\n+          response.addException(qe.getBottomQueryException());\n+          throw e;\n         }\n+      }\n     }\n-    \n-    /**\n-     * <strong>JBossAdministrator or Administrator credentials required.</strong> Enables tracing for all queries whose query string matches a regular\n-     * expression and/or are submitted by a named user. Note that at least one of {@code queryRegex} or {@code user} must be specified. If both are specified,\n-     * then queries submitted by {@code user} that match {@code queryRegex} are traced.\n-     * <p>\n-     * All traces are stored under the query UUID.\n-     *\n-     * @param queryRegex\n-     *            (optional) the query regular expression defining queries to trace\n-     * @param user\n-     *            (optional) the user name for which to trace queries\n-     * @return datawave.webservice.result.VoidResponse\n-     * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user, by specifying a chain of DNs of the identities to proxy\n-     * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n-     * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n-     *\n-     * @HTTP 200 success\n-     * @HTTP 400 if neither queryRegex nor user are specified\n-     * @HTTP 401 if the user does not have Administrative credentials\n-     */\n-    @GET\n-    @Path(\"/enableTracing\")\n-    @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\", \"application/x-protobuf\",\n-            \"application/x-protostuff\"})\n-    @RolesAllowed({\"Administrator\", \"JBossAdministrator\"})\n-    @Override\n-    public VoidResponse enableTracing(@QueryParam(\"queryRegex\") String queryRegex, @QueryParam(\"user\") String user) {\n-        VoidResponse response = new VoidResponse();\n-        if (queryRegex == null && user == null) {\n-            BadRequestQueryException qe = new BadRequestQueryException(DatawaveErrorCode.QUERY_REGEX_OR_USER_REQUIRED);\n-            response.addException(qe);\n-            throw new BadRequestException(qe, response);\n-        } else {\n-            PatternWrapper p = PatternWrapper.wrap(queryRegex);\n-            if (!traceInfos.containsEntry(user, p))\n-                traceInfos.put(user, p);\n-            // Put updated map back in the cache\n-            queryTraceCache.put(\"traceInfos\", traceInfos);\n-            return response;\n-        }\n+\n+    // update the actual running query\n+    updateQueryParams(q, queryLogicName, query, beginDate, endDate, queryAuthorizations, expirationDate, pagesize,\n+        pageTimeout, maxResultsOverride,\n+        parameters);\n+\n+    // update the persistenceMode post audit\n+    if (persistenceMode != null) {\n+      switch (persistenceMode) {\n+        case PERSISTENT:\n+          persister.update(q);\n+          break;\n+        case TRANSIENT:\n+          persister.remove(q);\n+          break;\n+      }\n     }\n-    \n-    /**\n-     * <strong>JBossAdministrator or Administrator credentials required.</strong> Disables tracing that was previously enabled using the\n-     * {@link #enableTracing(String, String)} method.\n-     *\n-     * @param queryRegex\n-     *            (optional) the query regular expression defining queries to disable tracing\n-     * @param user\n-     *            (optional) the user name for which to disable query tracing\n-     * @return datawave.webservice.result.VoidResponse\n-     *\n-     * @HTTP 200 success\n-     * @HTTP 400 if neither queryRegex nor user are specified\n-     * @HTTP 401 if the user does not have Administrative credentials\n-     */\n-    @GET\n-    @Path(\"/disableTracing\")\n-    @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\", \"application/x-protobuf\",\n-            \"application/x-protostuff\"})\n-    @RolesAllowed({\"Administrator\", \"JBossAdministrator\"})\n-    @Override\n-    public VoidResponse disableTracing(@QueryParam(\"queryRegex\") String queryRegex, @QueryParam(\"user\") String user) {\n-        VoidResponse response = new VoidResponse();\n-        if (queryRegex == null && user == null) {\n-            BadRequestQueryException qe = new BadRequestQueryException(DatawaveErrorCode.QUERY_REGEX_OR_USER_REQUIRED);\n-            response.addException(qe);\n-            throw new BadRequestException(qe, response);\n-        } else if (queryRegex == null) {\n-            traceInfos.removeAll(user);\n-            response.addMessage(\"All query tracing for \" + user + \" is disabled.  Per-query tracing is still possible.\");\n-        } else {\n-            traceInfos.remove(user, PatternWrapper.wrap(queryRegex));\n-            response.addMessage(\"Queries for user \" + user + \" matching \" + queryRegex + \" have been disabled. Per-query tracing is still possible.\");\n+\n+    // Put in the cache by id\n+    queryCache.put(q.getId().toString(), runningQuery);\n+  }\n+\n+  private void updateQueryParams(Query q, String queryLogicName, String query, Date beginDate, Date endDate,\n+                                 String queryAuthorizations, Date expirationDate,\n+                                 Integer pagesize, Integer pageTimeout, Long maxResultsOverride, String parameters)\n+      throws CloneNotSupportedException {\n+    Principal p = ctx.getCallerPrincipal();\n+    // TODO: add validation for all these sets\n+    if (queryLogicName != null) {\n+      QueryLogic<?> logic = queryLogicFactory.getQueryLogic(queryLogicName, p);\n+      q.setQueryLogicName(logic.getLogicName());\n+    }\n+    if (query != null) {\n+      q.setQuery(query);\n+    }\n+    if (beginDate != null) {\n+      q.setBeginDate(beginDate);\n+    }\n+    if (endDate != null) {\n+      q.setEndDate(endDate);\n+    }\n+    if (queryAuthorizations != null) {\n+      q.setQueryAuthorizations(queryAuthorizations);\n+    }\n+    if (expirationDate != null) {\n+      q.setExpirationDate(expirationDate);\n+    }\n+    if (pagesize != null) {\n+      q.setPagesize(pagesize);\n+    }\n+    if (pageTimeout != null) {\n+      q.setPageTimeout(pageTimeout);\n+    }\n+    if (maxResultsOverride != null) {\n+      q.setMaxResultsOverride(maxResultsOverride);\n+    }\n+    if (parameters != null) {\n+      Set<Parameter> params = new HashSet<>();\n+      String[] param = parameters.split(QueryImpl.PARAMETER_SEPARATOR);\n+      for (String yyy : param) {\n+        String[] parts = yyy.split(QueryImpl.PARAMETER_NAME_VALUE_SEPARATOR);\n+        if (parts.length == 2) {\n+          params.add(new Parameter(parts[0], parts[1]));\n         }\n-        \n-        // Put updated map back in the cache\n-        queryTraceCache.put(\"traceInfos\", traceInfos);\n+      }\n+      q.setParameters(params);\n+    }\n+  }\n+\n+  /**\n+   * <strong>Administrator credentials required.</strong> Returns list of queries for some other user\n+   *\n+   * @return datawave.webservice.result.QueryImplListResponse\n+   * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user, by specifying a chain of DNs of the identities to proxy\n+   * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n+   * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n+   * @HTTP 200 success\n+   * @HTTP 204 no results for userid\n+   * @HTTP 401 if the user does not have Administrative credentials\n+   * @HTTP 500 internal server error\n+   */\n+  @GET\n+  @Path(\"/{userid}/listAll\")\n+  @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\",\n+      \"application/x-protobuf\",\n+      \"application/x-protostuff\"})\n+  @GZIP\n+  @Interceptors(ResponseInterceptor.class)\n+  @RolesAllowed(\"Administrator\")\n+  public QueryImplListResponse listQueriesForUser(@Required(\"userId\") @PathParam(\"userid\") String userId) {\n+    QueryImplListResponse response = new QueryImplListResponse();\n+    try {\n+      List<Query> userQueries = persister.findByUser(userId);\n+      if (null == userQueries) {\n+        throw new NoResultsException(null);\n+      } else {\n+        response.setQuery(userQueries);\n         return response;\n+      }\n+    } catch (DatawaveWebApplicationException e) {\n+      throw e;\n+    } catch (Exception e) {\n+      QueryException qe =\n+          new QueryException(DatawaveErrorCode.QUERY_LISTING_ERROR, e, MessageFormat.format(\"UserId: {0}\", userId));\n+      log.error(qe, e);\n+      response.addException(qe.getBottomQueryException());\n+      int statusCode = qe.getBottomQueryException().getStatusCode();\n+      throw new DatawaveWebApplicationException(qe, response, statusCode);\n+    }\n+  }\n+\n+  /**\n+   * <strong>Administrator credentials required.</strong> Purges the cache of query objects\n+   *\n+   * @return datawave.webservice.result.VoidResponse\n+   * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user, by specifying a chain of DNs of the identities to proxy\n+   * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n+   * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n+   * @HTTP 200 success\n+   * @HTTP 401 if the user does not have Administrative credentials\n+   * @HTTP 500 internal server error\n+   */\n+  @POST\n+  @Path(\"/purgeQueryCache\")\n+  @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\",\n+      \"application/x-protobuf\",\n+      \"application/x-protostuff\"})\n+  @GZIP\n+  @Interceptors(ResponseInterceptor.class)\n+  @RolesAllowed(\"Administrator\")\n+  public VoidResponse purgeQueryCache() {\n+    VoidResponse response = new VoidResponse();\n+    try {\n+      queryCache.clear();\n+      return response;\n+    } catch (Exception e) {\n+      QueryException qe = new QueryException(DatawaveErrorCode.QUERY_CACHE_PURGE_ERROR, e);\n+      log.error(qe, e);\n+      response.addException(qe.getBottomQueryException());\n+      int statusCode = qe.getBottomQueryException().getStatusCode();\n+      throw new DatawaveWebApplicationException(qe, response, statusCode);\n+    }\n+  }\n+\n+  /**\n+   * <strong>JBossAdministrator or Administrator credentials required.</strong> Enables tracing for all queries whose query string matches a regular\n+   * expression and/or are submitted by a named user. Note that at least one of {@code queryRegex} or {@code user} must be specified. If both are specified,\n+   * then queries submitted by {@code user} that match {@code queryRegex} are traced.\n+   * <p>\n+   * All traces are stored under the query UUID.\n+   *\n+   * @param queryRegex (optional) the query regular expression defining queries to trace\n+   * @param user       (optional) the user name for which to trace queries\n+   * @return datawave.webservice.result.VoidResponse\n+   * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user, by specifying a chain of DNs of the identities to proxy\n+   * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n+   * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n+   * @HTTP 200 success\n+   * @HTTP 400 if neither queryRegex nor user are specified\n+   * @HTTP 401 if the user does not have Administrative credentials\n+   */\n+  @GET\n+  @Path(\"/enableTracing\")\n+  @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\",\n+      \"application/x-protobuf\",\n+      \"application/x-protostuff\"})\n+  @RolesAllowed({\"Administrator\", \"JBossAdministrator\"})\n+  @Override\n+  public VoidResponse enableTracing(@QueryParam(\"queryRegex\") String queryRegex, @QueryParam(\"user\") String user) {\n+    VoidResponse response = new VoidResponse();\n+    if (queryRegex == null && user == null) {\n+      BadRequestQueryException qe = new BadRequestQueryException(DatawaveErrorCode.QUERY_REGEX_OR_USER_REQUIRED);\n+      response.addException(qe);\n+      throw new BadRequestException(qe, response);\n+    } else {\n+      PatternWrapper p = PatternWrapper.wrap(queryRegex);\n+      if (!traceInfos.containsEntry(user, p)) {\n+        traceInfos.put(user, p);\n+      }\n+      // Put updated map back in the cache\n+      queryTraceCache.put(\"traceInfos\", traceInfos);\n+      return response;\n+    }\n+  }\n+\n+  /**\n+   * <strong>JBossAdministrator or Administrator credentials required.</strong> Disables tracing that was previously enabled using the\n+   * {@link #enableTracing(String, String)} method.\n+   *\n+   * @param queryRegex (optional) the query regular expression defining queries to disable tracing\n+   * @param user       (optional) the user name for which to disable query tracing\n+   * @return datawave.webservice.result.VoidResponse\n+   * @HTTP 200 success\n+   * @HTTP 400 if neither queryRegex nor user are specified\n+   * @HTTP 401 if the user does not have Administrative credentials\n+   */\n+  @GET\n+  @Path(\"/disableTracing\")\n+  @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\",\n+      \"application/x-protobuf\",\n+      \"application/x-protostuff\"})\n+  @RolesAllowed({\"Administrator\", \"JBossAdministrator\"})\n+  @Override\n+  public VoidResponse disableTracing(@QueryParam(\"queryRegex\") String queryRegex, @QueryParam(\"user\") String user) {\n+    VoidResponse response = new VoidResponse();\n+    if (queryRegex == null && user == null) {\n+      BadRequestQueryException qe = new BadRequestQueryException(DatawaveErrorCode.QUERY_REGEX_OR_USER_REQUIRED);\n+      response.addException(qe);\n+      throw new BadRequestException(qe, response);\n+    } else if (queryRegex == null) {\n+      traceInfos.removeAll(user);\n+      response.addMessage(\"All query tracing for \" + user + \" is disabled.  Per-query tracing is still possible.\");\n+    } else {\n+      traceInfos.remove(user, PatternWrapper.wrap(queryRegex));\n+      response.addMessage(\"Queries for user \" + user + \" matching \" + queryRegex +\n+          \" have been disabled. Per-query tracing is still possible.\");\n+    }\n+\n+    // Put updated map back in the cache\n+    queryTraceCache.put(\"traceInfos\", traceInfos);\n+    return response;\n+  }\n+\n+  /**\n+   * <strong>JBossAdministrator or Administrator credentials required.</strong> Disables all tracing that was enabled using the\n+   * {@link #enableTracing(String, String)} method. Note that this does not prevent individual queries that are created with the trace parameter specified.\n+   *\n+   * @return datawave.webservice.result.VoidResponse\n+   * @HTTP 200 success\n+   * @HTTP 401 if the user does not have Administrative credentials\n+   */\n+  @GET\n+  @Path(\"/disableAllTracing\")\n+  @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\",\n+      \"application/x-protobuf\",\n+      \"application/x-protostuff\"})\n+  @RolesAllowed({\"Administrator\", \"JBossAdministrator\"})\n+  @Override\n+  public VoidResponse disableAllTracing() {\n+    VoidResponse response = new VoidResponse();\n+    traceInfos.clear();\n+    // Put updated map back in the cache\n+    queryTraceCache.put(\"traceInfos\", traceInfos);\n+    response.addMessage(\"All user/regex traces cleared. Per-query tracing is still possible.\");\n+    return response;\n+  }\n+\n+  private boolean shouldTraceQuery(String queryString, String user, boolean traceRequested) {\n+    boolean shouldTrace = traceRequested;\n+    if (!shouldTrace) {\n+      // Check user-specific regexes (null regex means trace all queries for a user)\n+      for (PatternWrapper regex : traceInfos.get(user)) {\n+        if (regex == null || regex.matches(queryString)) {\n+          shouldTrace = true;\n+          break;\n+        }\n+      }\n+    }\n+    if (!shouldTrace) {\n+      // Check user-agnostic regexes (regex can't be null)\n+      for (PatternWrapper regex : traceInfos.get(null)) {\n+        if (regex.matches(queryString)) {\n+          shouldTrace = true;\n+          break;\n+        }\n+      }\n+    }\n+    return shouldTrace;\n+  }\n+\n+  protected QueryMetricsBean getMetrics() {\n+    return metrics;\n+  }\n+\n+  protected QueryLogicFactory getQueryFactory() {\n+    return queryLogicFactory;\n+  }\n+\n+  protected Persister getPersister() {\n+    return persister;\n+  }\n+\n+  protected QueryCache getQueryCache() {\n+    return queryCache;\n+  }\n+\n+  private void addQueryToTrackingMap(Map<String, String> trackingMap, Query q) {\n+\n+    if (trackingMap == null || q == null) {\n+      return;\n+    }\n+\n+    if (q.getOwner() != null) {\n+      trackingMap.put(\"query.user\", q.getOwner());\n+    }\n+    if (q.getId() != null) {\n+      trackingMap.put(\"query.id\", q.getId().toString());\n+    }\n+    if (q.getId() != null) {\n+      trackingMap.put(\"query.query\", q.getQuery());\n     }\n-    \n+  }\n+\n+  /**\n+   * @param logicName\n+   * @param queryParameters\n+   * @return {@code datawave.webservice.result.GenericResponse<String>}\n+   * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user, by specifying a chain of DNs of the identities to proxy\n+   * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n+   * @ResponseHeader query-session-id this header and value will be in the Set-Cookie header, subsequent calls for this session will need to supply the\n+   * query-session-id header in the request in a Cookie header or as a query parameter\n+   * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n+   * @ResponseHeader X-Partial-Results true if the page contains less than the requested number of results\n+   * @HTTP 200 success\n+   * @HTTP 204 success and no results\n+   * @HTTP 400 invalid or missing parameter\n+   * @HTTP 500 internal server error\n+   */\n+  @POST\n+  @Produces(\"*/*\")\n+  @Path(\"/{logicName}/execute\")\n+  @GZIP\n+  @Interceptors({ResponseInterceptor.class, RequiredInterceptor.class})\n+  @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)\n+  @Override\n+  @Timed(name = \"dw.query.executeQuery\", absolute = true)\n+  public StreamingOutput execute(@PathParam(\"logicName\") String logicName,\n+                                 MultivaluedMap<String, String> queryParameters, @Context HttpHeaders httpHeaders) {\n+\n     /**\n-     * <strong>JBossAdministrator or Administrator credentials required.</strong> Disables all tracing that was enabled using the\n-     * {@link #enableTracing(String, String)} method. Note that this does not prevent individual queries that are created with the trace parameter specified.\n-     *\n-     * @return datawave.webservice.result.VoidResponse\n-     *\n-     * @HTTP 200 success\n-     * @HTTP 401 if the user does not have Administrative credentials\n+     * This method captures the metrics on the query instead of doing it in the QueryMetricsEnrichmentInterceptor. The ExecuteStreamingOutputResponse class\n+     * is returned from this method and executed in the JAX-RS layer. It updates the metrics which are then updated on each call to the _next method.\n      */\n-    @GET\n-    @Path(\"/disableAllTracing\")\n-    @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\", \"application/x-protobuf\",\n-            \"application/x-protostuff\"})\n-    @RolesAllowed({\"Administrator\", \"JBossAdministrator\"})\n-    @Override\n-    public VoidResponse disableAllTracing() {\n-        VoidResponse response = new VoidResponse();\n-        traceInfos.clear();\n-        // Put updated map back in the cache\n-        queryTraceCache.put(\"traceInfos\", traceInfos);\n-        response.addMessage(\"All user/regex traces cleared. Per-query tracing is still possible.\");\n-        return response;\n+    Collection<String> proxyServers = null;\n+    Principal p = ctx.getCallerPrincipal();\n+    DatawavePrincipal dp;\n+    if (p instanceof DatawavePrincipal) {\n+      dp = (DatawavePrincipal) p;\n+      proxyServers = dp.getProxyServers();\n     }\n-    \n-    private boolean shouldTraceQuery(String queryString, String user, boolean traceRequested) {\n-        boolean shouldTrace = traceRequested;\n-        if (!shouldTrace) {\n-            // Check user-specific regexes (null regex means trace all queries for a user)\n-            for (PatternWrapper regex : traceInfos.get(user)) {\n-                if (regex == null || regex.matches(queryString)) {\n-                    shouldTrace = true;\n-                    break;\n-                }\n-            }\n-        }\n-        if (!shouldTrace) {\n-            // Check user-agnostic regexes (regex can't be null)\n-            for (PatternWrapper regex : traceInfos.get(null)) {\n-                if (regex.matches(queryString)) {\n-                    shouldTrace = true;\n-                    break;\n-                }\n-            }\n-        }\n-        return shouldTrace;\n+\n+    final MediaType PB_MEDIA_TYPE = new MediaType(\"application\", \"x-protobuf\");\n+    final MediaType YAML_MEDIA_TYPE = new MediaType(\"application\", \"x-yaml\");\n+    final VoidResponse response = new VoidResponse();\n+\n+    // HttpHeaders.getAcceptableMediaTypes returns a priority sorted list of acceptable response types.\n+    // Find the first one in the list that we support.\n+    MediaType responseType = null;\n+    for (MediaType type : httpHeaders.getAcceptableMediaTypes()) {\n+      if (type.equals(MediaType.APPLICATION_XML_TYPE) || type.equals(MediaType.APPLICATION_JSON_TYPE) ||\n+          type.equals(PB_MEDIA_TYPE)\n+          || type.equals(YAML_MEDIA_TYPE)) {\n+        responseType = type;\n+        break;\n+      }\n+    }\n+    if (null == responseType) {\n+      QueryException qe = new QueryException(DatawaveErrorCode.UNSUPPORTED_MEDIA_TYPE);\n+      response.addException(qe);\n+      throw new DatawaveWebApplicationException(qe, response);\n     }\n-    \n-    protected QueryMetricsBean getMetrics() {\n-        return metrics;\n+\n+    // reference query necessary to avoid NPEs in getting the Transformer and BaseResponse\n+    Query q = new QueryImpl();\n+    Date now = new Date();\n+    q.setBeginDate(now);\n+    q.setEndDate(now);\n+    q.setExpirationDate(now);\n+    q.setQuery(\"test\");\n+    q.setQueryAuthorizations(\"ALL\");\n+    ResultsPage emptyList = new ResultsPage();\n+\n+    // Find the response class\n+    Class<?> responseClass;\n+    try {\n+      QueryLogic<?> l = queryLogicFactory.getQueryLogic(logicName, p);\n+      QueryLogicTransformer t = l.getTransformer(q);\n+      BaseResponse refResponse = t.createResponse(emptyList);\n+      responseClass = refResponse.getClass();\n+    } catch (Exception e) {\n+      QueryException qe = new QueryException(DatawaveErrorCode.QUERY_TRANSFORM_ERROR, e);\n+      log.error(qe, e);\n+      response.addException(qe.getBottomQueryException());\n+      int statusCode = qe.getBottomQueryException().getStatusCode();\n+      throw new DatawaveWebApplicationException(qe, response, statusCode);\n     }\n-    \n-    protected QueryLogicFactory getQueryFactory() {\n-        return queryLogicFactory;\n+\n+    SerializationType s;\n+    if (responseType.equals(MediaType.APPLICATION_XML_TYPE)) {\n+      s = SerializationType.XML;\n+    } else if (responseType.equals(MediaType.APPLICATION_JSON_TYPE)) {\n+      s = SerializationType.JSON;\n+    } else if (responseType.equals(PB_MEDIA_TYPE)) {\n+      if (!(Message.class.isAssignableFrom(responseClass))) {\n+        QueryException qe = new QueryException(DatawaveErrorCode.BAD_RESPONSE_CLASS,\n+            MessageFormat.format(\"Response  class: {0}\", responseClass));\n+        response.addException(qe);\n+        throw new DatawaveWebApplicationException(qe, response);\n+      }\n+      s = SerializationType.PB;\n+    } else if (responseType.equals(YAML_MEDIA_TYPE)) {\n+      if (!(Message.class.isAssignableFrom(responseClass))) {\n+        QueryException qe = new QueryException(DatawaveErrorCode.BAD_RESPONSE_CLASS,\n+            MessageFormat.format(\"Response  class: {0}\", responseClass));\n+        response.addException(qe);\n+        throw new DatawaveWebApplicationException(qe, response);\n+      }\n+      s = SerializationType.YAML;\n+    } else {\n+      QueryException qe = new QueryException(DatawaveErrorCode.INVALID_FORMAT,\n+          MessageFormat.format(\"format: {0}\", responseType.toString()));\n+      response.addException(qe);\n+      throw new DatawaveWebApplicationException(qe, response);\n     }\n-    \n-    protected Persister getPersister() {\n-        return persister;\n+\n+    long start = System.nanoTime();\n+    GenericResponse<String> createResponse = null;\n+    createResponse = this.createQuery(logicName, queryParameters, httpHeaders);\n+    long createCallTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start);\n+    final String queryId = createResponse.getResult();\n+\n+    // We created the query and put into cache, get the RunningQuery object\n+    final RunningQuery rq = queryCache.get(queryId);\n+    rq.getMetric().setCreateCallTime(createCallTime);\n+\n+    final Collection<String> proxies = proxyServers;\n+    final SerializationType serializationType = s;\n+    final Class<?> queryResponseClass = responseClass;\n+\n+    return new ExecuteStreamingOutputResponse(queryId, queryResponseClass, response, rq, serializationType, proxies);\n+  }\n+\n+  /**\n+   * Asynchronous version of {@link #execute(String, MultivaluedMap, HttpHeaders)}\n+   *\n+   * @see #execute(String, MultivaluedMap, HttpHeaders)\n+   */\n+  @POST\n+  @Produces(\"*/*\")\n+  @Path(\"/{logicName}/async/execute\")\n+  @GZIP\n+  @Interceptors({ResponseInterceptor.class, RequiredInterceptor.class})\n+  @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)\n+  @Asynchronous\n+  @Timed(name = \"dw.query.executeQueryAsync\", absolute = true)\n+  public void executeAsync(@PathParam(\"logicName\") String logicName, MultivaluedMap<String, String> queryParameters,\n+                           @Context HttpHeaders httpHeaders,\n+                           @Suspended AsyncResponse asyncResponse) {\n+    try {\n+      StreamingOutput output = execute(logicName, queryParameters, httpHeaders);\n+      asyncResponse.resume(output);\n+    } catch (Throwable t) {\n+      asyncResponse.resume(t);\n+    }\n+  }\n+\n+  @Asynchronous\n+  public Future<?> executeAsync(String logicName, MultivaluedMap<String, String> queryParameters, Long startTime,\n+                                Long loginTime,\n+                                AsyncQueryStatusObserver observer) {\n+    Collection<String> proxyServers = null;\n+    Principal p = ctx.getCallerPrincipal();\n+    DatawavePrincipal dp;\n+    if (p instanceof DatawavePrincipal) {\n+      dp = (DatawavePrincipal) p;\n+      proxyServers = dp.getProxyServers();\n     }\n-    \n-    protected QueryCache getQueryCache() {\n-        return queryCache;\n+\n+    long start = (startTime != null) ? startTime : System.nanoTime();\n+    GenericResponse<String> createResponse;\n+    try {\n+      createResponse = createQuery(logicName, queryParameters);\n+      observer.queryCreated(createResponse);\n+    } catch (DatawaveWebApplicationException e) {\n+      observer.queryCreateException(new QueryException(e));\n+      return new AsyncResult<>(e);\n     }\n-    \n-    private void addQueryToTrackingMap(Map<String,String> trackingMap, Query q) {\n-        \n-        if (trackingMap == null || q == null) {\n-            return;\n-        }\n-        \n-        if (q.getOwner() != null) {\n-            trackingMap.put(\"query.user\", q.getOwner());\n-        }\n-        if (q.getId() != null) {\n-            trackingMap.put(\"query.id\", q.getId().toString());\n-        }\n-        if (q.getId() != null) {\n-            trackingMap.put(\"query.query\", q.getQuery());\n-        }\n+\n+    if (sessionContext.wasCancelCalled()) {\n+      return new AsyncResult<>(\"cancelled\");\n     }\n-    \n-    /**\n-     * @param logicName\n-     * @param queryParameters\n-     *\n-     * @return {@code datawave.webservice.result.GenericResponse<String>}\n-     * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user, by specifying a chain of DNs of the identities to proxy\n-     * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n-     * @ResponseHeader query-session-id this header and value will be in the Set-Cookie header, subsequent calls for this session will need to supply the\n-     *                 query-session-id header in the request in a Cookie header or as a query parameter\n-     * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n-     * @ResponseHeader X-Partial-Results true if the page contains less than the requested number of results\n-     *\n-     * @HTTP 200 success\n-     * @HTTP 204 success and no results\n-     * @HTTP 400 invalid or missing parameter\n-     * @HTTP 500 internal server error\n-     */\n-    @POST\n-    @Produces(\"*/*\")\n-    @Path(\"/{logicName}/execute\")\n-    @GZIP\n-    @Interceptors({ResponseInterceptor.class, RequiredInterceptor.class})\n-    @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)\n-    @Override\n-    @Timed(name = \"dw.query.executeQuery\", absolute = true)\n-    public StreamingOutput execute(@PathParam(\"logicName\") String logicName, MultivaluedMap<String,String> queryParameters, @Context HttpHeaders httpHeaders) {\n-        \n-        /**\n-         * This method captures the metrics on the query instead of doing it in the QueryMetricsEnrichmentInterceptor. The ExecuteStreamingOutputResponse class\n-         * is returned from this method and executed in the JAX-RS layer. It updates the metrics which are then updated on each call to the _next method.\n-         */\n-        Collection<String> proxyServers = null;\n-        Principal p = ctx.getCallerPrincipal();\n-        DatawavePrincipal dp;\n-        if (p instanceof DatawavePrincipal) {\n-            dp = (DatawavePrincipal) p;\n-            proxyServers = dp.getProxyServers();\n-        }\n-        \n-        final MediaType PB_MEDIA_TYPE = new MediaType(\"application\", \"x-protobuf\");\n-        final MediaType YAML_MEDIA_TYPE = new MediaType(\"application\", \"x-yaml\");\n-        final VoidResponse response = new VoidResponse();\n-        \n-        // HttpHeaders.getAcceptableMediaTypes returns a priority sorted list of acceptable response types.\n-        // Find the first one in the list that we support.\n-        MediaType responseType = null;\n-        for (MediaType type : httpHeaders.getAcceptableMediaTypes()) {\n-            if (type.equals(MediaType.APPLICATION_XML_TYPE) || type.equals(MediaType.APPLICATION_JSON_TYPE) || type.equals(PB_MEDIA_TYPE)\n-                            || type.equals(YAML_MEDIA_TYPE)) {\n-                responseType = type;\n-                break;\n-            }\n-        }\n-        if (null == responseType) {\n-            QueryException qe = new QueryException(DatawaveErrorCode.UNSUPPORTED_MEDIA_TYPE);\n-            response.addException(qe);\n-            throw new DatawaveWebApplicationException(qe, response);\n-        }\n-        \n-        // reference query necessary to avoid NPEs in getting the Transformer and BaseResponse\n-        Query q = new QueryImpl();\n-        Date now = new Date();\n-        q.setBeginDate(now);\n-        q.setEndDate(now);\n-        q.setExpirationDate(now);\n-        q.setQuery(\"test\");\n-        q.setQueryAuthorizations(\"ALL\");\n-        ResultsPage emptyList = new ResultsPage();\n-        \n-        // Find the response class\n-        Class<?> responseClass;\n+\n+    long createCallTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start);\n+    final String queryId = createResponse.getResult();\n+\n+    // We created the query and put into cache, get the RunningQuery object\n+    // and update the query metric for call time.\n+    final RunningQuery rq = queryCache.get(queryId);\n+    try {\n+      rq.getMetric().setCreateCallTime(createCallTime);\n+      if (loginTime != null) {\n+        rq.getMetric().setLoginTime(loginTime);\n+      }\n+      try {\n+        metrics.updateMetric(rq.getMetric());\n+      } catch (Exception e) {\n+        log.error(\"Error updating query metric\", e);\n+      }\n+\n+      boolean done = false;\n+      TraceScope span = null;\n+      List<PageMetric> pageMetrics = rq.getMetric().getPageTimes();\n+\n+      // Loop over each page of query results, and notify the observer about each page.\n+      // If we get any exception, then break out of the loop and notify the observer about the problem.\n+      do {\n+        long callStart = System.nanoTime();\n+        rq.setActiveCall(true);\n         try {\n-            QueryLogic<?> l = queryLogicFactory.getQueryLogic(logicName, p);\n-            QueryLogicTransformer t = l.getTransformer(q);\n-            BaseResponse refResponse = t.createResponse(emptyList);\n-            responseClass = refResponse.getClass();\n+          BaseQueryResponse page = _next(rq, queryId, proxyServers, span);\n+          long serializationStart = System.nanoTime();\n+          observer.queryResultsAvailable(page);\n+          long serializationTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - serializationStart);\n+\n+          if (rq.getLogic().getCollectQueryMetrics()) {\n+            PageMetric pm = pageMetrics.get(pageMetrics.size() - 1);\n+            pm.setSerializationTime(serializationTime);\n+            long pageCallTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - callStart);\n+            pm.setCallTime(pageCallTime);\n+          }\n         } catch (Exception e) {\n-            QueryException qe = new QueryException(DatawaveErrorCode.QUERY_TRANSFORM_ERROR, e);\n-            log.error(qe, e);\n-            response.addException(qe.getBottomQueryException());\n-            int statusCode = qe.getBottomQueryException().getStatusCode();\n-            throw new DatawaveWebApplicationException(qe, response, statusCode);\n-        }\n-        \n-        SerializationType s;\n-        if (responseType.equals(MediaType.APPLICATION_XML_TYPE)) {\n-            s = SerializationType.XML;\n-        } else if (responseType.equals(MediaType.APPLICATION_JSON_TYPE)) {\n-            s = SerializationType.JSON;\n-        } else if (responseType.equals(PB_MEDIA_TYPE)) {\n-            if (!(Message.class.isAssignableFrom(responseClass))) {\n-                QueryException qe = new QueryException(DatawaveErrorCode.BAD_RESPONSE_CLASS, MessageFormat.format(\"Response  class: {0}\", responseClass));\n-                response.addException(qe);\n-                throw new DatawaveWebApplicationException(qe, response);\n-            }\n-            s = SerializationType.PB;\n-        } else if (responseType.equals(YAML_MEDIA_TYPE)) {\n-            if (!(Message.class.isAssignableFrom(responseClass))) {\n-                QueryException qe = new QueryException(DatawaveErrorCode.BAD_RESPONSE_CLASS, MessageFormat.format(\"Response  class: {0}\", responseClass));\n-                response.addException(qe);\n-                throw new DatawaveWebApplicationException(qe, response);\n-            }\n-            s = SerializationType.YAML;\n-        } else {\n-            QueryException qe = new QueryException(DatawaveErrorCode.INVALID_FORMAT, MessageFormat.format(\"format: {0}\", responseType.toString()));\n-            response.addException(qe);\n-            throw new DatawaveWebApplicationException(qe, response);\n-        }\n-        \n-        long start = System.nanoTime();\n-        GenericResponse<String> createResponse = null;\n-        createResponse = this.createQuery(logicName, queryParameters, httpHeaders);\n-        long createCallTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start);\n-        final String queryId = createResponse.getResult();\n-        \n-        // We created the query and put into cache, get the RunningQuery object\n-        final RunningQuery rq = queryCache.get(queryId);\n-        rq.getMetric().setCreateCallTime(createCallTime);\n-        \n-        final Collection<String> proxies = proxyServers;\n-        final SerializationType serializationType = s;\n-        final Class<?> queryResponseClass = responseClass;\n-        \n-        return new ExecuteStreamingOutputResponse(queryId, queryResponseClass, response, rq, serializationType, proxies);\n-    }\n-    \n-    /**\n-     * Asynchronous version of {@link #execute(String, MultivaluedMap, HttpHeaders)}\n-     * \n-     * @see #execute(String, MultivaluedMap, HttpHeaders)\n-     */\n-    @POST\n-    @Produces(\"*/*\")\n-    @Path(\"/{logicName}/async/execute\")\n-    @GZIP\n-    @Interceptors({ResponseInterceptor.class, RequiredInterceptor.class})\n-    @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)\n-    @Asynchronous\n-    @Timed(name = \"dw.query.executeQueryAsync\", absolute = true)\n-    public void executeAsync(@PathParam(\"logicName\") String logicName, MultivaluedMap<String,String> queryParameters, @Context HttpHeaders httpHeaders,\n-                    @Suspended AsyncResponse asyncResponse) {\n-        try {\n-            StreamingOutput output = execute(logicName, queryParameters, httpHeaders);\n-            asyncResponse.resume(output);\n-        } catch (Throwable t) {\n-            asyncResponse.resume(t);\n-        }\n-    }\n-    \n-    @Asynchronous\n-    public Future<?> executeAsync(String logicName, MultivaluedMap<String,String> queryParameters, Long startTime, Long loginTime,\n-                    AsyncQueryStatusObserver observer) {\n-        Collection<String> proxyServers = null;\n-        Principal p = ctx.getCallerPrincipal();\n-        DatawavePrincipal dp;\n-        if (p instanceof DatawavePrincipal) {\n-            dp = (DatawavePrincipal) p;\n-            proxyServers = dp.getProxyServers();\n-        }\n-        \n-        long start = (startTime != null) ? startTime : System.nanoTime();\n-        GenericResponse<String> createResponse;\n-        try {\n-            createResponse = createQuery(logicName, queryParameters);\n-            observer.queryCreated(createResponse);\n-        } catch (DatawaveWebApplicationException e) {\n-            observer.queryCreateException(new QueryException(e));\n-            return new AsyncResult<>(e);\n-        }\n-        \n-        if (sessionContext.wasCancelCalled())\n-            return new AsyncResult<>(\"cancelled\");\n-        \n-        long createCallTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start);\n-        final String queryId = createResponse.getResult();\n-        \n-        // We created the query and put into cache, get the RunningQuery object\n-        // and update the query metric for call time.\n-        final RunningQuery rq = queryCache.get(queryId);\n-        try {\n-            rq.getMetric().setCreateCallTime(createCallTime);\n-            if (loginTime != null) {\n-                rq.getMetric().setLoginTime(loginTime);\n-            }\n-            try {\n-                metrics.updateMetric(rq.getMetric());\n-            } catch (Exception e) {\n-                log.error(\"Error updating query metric\", e);\n-            }\n-            \n-            boolean done = false;\n-            TraceScope span = null;\n-            List<PageMetric> pageMetrics = rq.getMetric().getPageTimes();\n-            \n-            // Loop over each page of query results, and notify the observer about each page.\n-            // If we get any exception, then break out of the loop and notify the observer about the problem.\n-            do {\n-                long callStart = System.nanoTime();\n-                rq.setActiveCall(true);\n-                try {\n-                    BaseQueryResponse page = _next(rq, queryId, proxyServers, span);\n-                    long serializationStart = System.nanoTime();\n-                    observer.queryResultsAvailable(page);\n-                    long serializationTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - serializationStart);\n-                    \n-                    if (rq.getLogic().getCollectQueryMetrics()) {\n-                        PageMetric pm = pageMetrics.get(pageMetrics.size() - 1);\n-                        pm.setSerializationTime(serializationTime);\n-                        long pageCallTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - callStart);\n-                        pm.setCallTime(pageCallTime);\n-                    }\n-                } catch (Exception e) {\n-                    if (e instanceof NoResultsException || e.getCause() instanceof NoResultsException) {\n-                        // No more results, break out of loop\n-                        done = true;\n-                    } else if (sessionContext.wasCancelCalled() && e instanceof CancellationException) {\n-                        // We were cancelled by the originating user, so just break out of the loop.\n-                        // If we were cancelled due to an admin cancel, we'll report the exception to the user.\n-                        done = true;\n-                    } else {\n-                        // We had a real problem. Update the query metric with the error and then notify the observer.\n-                        if (rq.getLogic().getCollectQueryMetrics()) {\n-                            rq.getMetric().setError(e);\n-                        }\n-                        QueryException qe = (e instanceof QueryException) ? (QueryException) e : new QueryException(e);\n-                        observer.queryException(qe);\n-                        done = true;\n-                        break;\n-                    }\n-                } finally {\n-                    rq.setActiveCall(false);\n-                    // Update the query metrics for the completion of this page (either successfully or due to error)\n-                    if (rq.getLogic().getCollectQueryMetrics()) {\n-                        try {\n-                            metrics.updateMetric(rq.getMetric());\n-                        } catch (Exception e) {\n-                            log.error(\"Error updating query metric\", e);\n-                        }\n-                    }\n-                }\n-            } while (!done && !sessionContext.wasCancelCalled());\n+          if (e instanceof NoResultsException || e.getCause() instanceof NoResultsException) {\n+            // No more results, break out of loop\n+            done = true;\n+          } else if (sessionContext.wasCancelCalled() && e instanceof CancellationException) {\n+            // We were cancelled by the originating user, so just break out of the loop.\n+            // If we were cancelled due to an admin cancel, we'll report the exception to the user.\n+            done = true;\n+          } else {\n+            // We had a real problem. Update the query metric with the error and then notify the observer.\n+            if (rq.getLogic().getCollectQueryMetrics()) {\n+              rq.getMetric().setError(e);\n+            }\n+            QueryException qe = (e instanceof QueryException) ? (QueryException) e : new QueryException(e);\n+            observer.queryException(qe);\n+            done = true;\n+            break;\n+          }\n         } finally {\n-            // Close the query now that we're done with it.\n+          rq.setActiveCall(false);\n+          // Update the query metrics for the completion of this page (either successfully or due to error)\n+          if (rq.getLogic().getCollectQueryMetrics()) {\n             try {\n-                close(rq);\n+              metrics.updateMetric(rq.getMetric());\n             } catch (Exception e) {\n-                log.error(\"Error closing query\", e);\n+              log.error(\"Error updating query metric\", e);\n             }\n+          }\n         }\n-        \n-        observer.queryFinished(queryId);\n-        \n-        return new AsyncResult<>(queryId);\n-    }\n-    \n-    private enum SerializationType {\n-        JSON, XML, PB, YAML;\n-    }\n-    \n-    public class ExecuteStreamingOutputResponse implements StreamingOutput {\n-        private String queryId = null;\n-        private Class<?> queryResponseClass = null;\n-        private VoidResponse errorResponse = null;\n-        private RunningQuery rq = null;\n-        private SerializationType serializationType = SerializationType.XML;\n-        private Collection<String> proxies = null;\n-        \n-        public ExecuteStreamingOutputResponse(String queryId, Class<?> queryResponseClass, VoidResponse errorResponse, RunningQuery rq,\n-                        SerializationType serializationType, Collection<String> proxies) {\n-            super();\n-            this.queryId = queryId;\n-            this.queryResponseClass = queryResponseClass;\n-            this.errorResponse = errorResponse;\n-            this.rq = rq;\n-            this.serializationType = serializationType;\n-            this.proxies = proxies;\n-        }\n-        \n-        public String getQueryId() {\n-            return queryId;\n-        }\n-        \n-        @Override\n-        public void write(OutputStream out) throws IOException, WebApplicationException {\n-            \n+      } while (!done && !sessionContext.wasCancelCalled());\n+    } finally {\n+      // Close the query now that we're done with it.\n+      try {\n+        close(rq);\n+      } catch (Exception e) {\n+        log.error(\"Error closing query\", e);\n+      }\n+    }\n+\n+    observer.queryFinished(queryId);\n+\n+    return new AsyncResult<>(queryId);\n+  }\n+\n+  private enum SerializationType {\n+    JSON, XML, PB, YAML;\n+  }\n+\n+  public class ExecuteStreamingOutputResponse implements StreamingOutput {\n+    private String queryId = null;\n+    private Class<?> queryResponseClass = null;\n+    private VoidResponse errorResponse = null;\n+    private RunningQuery rq = null;\n+    private SerializationType serializationType = SerializationType.XML;\n+    private Collection<String> proxies = null;\n+\n+    public ExecuteStreamingOutputResponse(String queryId, Class<?> queryResponseClass, VoidResponse errorResponse,\n+                                          RunningQuery rq,\n+                                          SerializationType serializationType, Collection<String> proxies) {\n+      super();\n+      this.queryId = queryId;\n+      this.queryResponseClass = queryResponseClass;\n+      this.errorResponse = errorResponse;\n+      this.rq = rq;\n+      this.serializationType = serializationType;\n+      this.proxies = proxies;\n+    }\n+\n+    public String getQueryId() {\n+      return queryId;\n+    }\n+\n+    @Override\n+    public void write(OutputStream out) throws IOException, WebApplicationException {\n+\n+      try {\n+        LinkedBuffer buffer = LinkedBuffer.allocate(4096);\n+        Marshaller xmlSerializer;\n+        try {\n+          JAXBContext jaxbContext = JAXBContext.newInstance(queryResponseClass);\n+          xmlSerializer = jaxbContext.createMarshaller();\n+        } catch (JAXBException e1) {\n+          QueryException qe = new QueryException(DatawaveErrorCode.JAXB_CONTEXT_ERROR, e1,\n+              MessageFormat.format(\"class: {0}\", queryResponseClass));\n+          log.error(qe, e1);\n+          errorResponse.addException(qe.getBottomQueryException());\n+          throw new DatawaveWebApplicationException(qe, errorResponse);\n+        }\n+        ObjectMapper jsonSerializer = new ObjectMapper();\n+        jsonSerializer.enable(MapperFeature.USE_WRAPPER_NAME_AS_PROPERTY_NAME);\n+        jsonSerializer.setAnnotationIntrospector(\n+            AnnotationIntrospector.pair(new JacksonAnnotationIntrospector(), new JaxbAnnotationIntrospector(\n+                jsonSerializer.getTypeFactory())));\n+        // Don't close the output stream\n+        jsonSerializer.configure(JsonGenerator.Feature.AUTO_CLOSE_TARGET, false);\n+        try (JsonGenerator jsonGenerator = jsonSerializer.getFactory().createGenerator(out, JsonEncoding.UTF8)) {\n+          jsonGenerator.enable(JsonGenerator.Feature.FLUSH_PASSED_TO_STREAM);\n+\n+          boolean sentResults = false;\n+          boolean done = false;\n+          TraceScope span = null;\n+          List<PageMetric> pageMetrics = rq.getMetric().getPageTimes();\n+\n+          do {\n             try {\n-                LinkedBuffer buffer = LinkedBuffer.allocate(4096);\n-                Marshaller xmlSerializer;\n-                try {\n-                    JAXBContext jaxbContext = JAXBContext.newInstance(queryResponseClass);\n-                    xmlSerializer = jaxbContext.createMarshaller();\n-                } catch (JAXBException e1) {\n-                    QueryException qe = new QueryException(DatawaveErrorCode.JAXB_CONTEXT_ERROR, e1, MessageFormat.format(\"class: {0}\", queryResponseClass));\n-                    log.error(qe, e1);\n-                    errorResponse.addException(qe.getBottomQueryException());\n-                    throw new DatawaveWebApplicationException(qe, errorResponse);\n-                }\n-                ObjectMapper jsonSerializer = new ObjectMapper();\n-                jsonSerializer.enable(MapperFeature.USE_WRAPPER_NAME_AS_PROPERTY_NAME);\n-                jsonSerializer.setAnnotationIntrospector(AnnotationIntrospector.pair(new JacksonAnnotationIntrospector(), new JaxbAnnotationIntrospector(\n-                                jsonSerializer.getTypeFactory())));\n-                // Don't close the output stream\n-                jsonSerializer.configure(JsonGenerator.Feature.AUTO_CLOSE_TARGET, false);\n-                try (JsonGenerator jsonGenerator = jsonSerializer.getFactory().createGenerator(out, JsonEncoding.UTF8)) {\n-                    jsonGenerator.enable(JsonGenerator.Feature.FLUSH_PASSED_TO_STREAM);\n-                    \n-                    boolean sentResults = false;\n-                    boolean done = false;\n-                    TraceScope span = null;\n-                    List<PageMetric> pageMetrics = rq.getMetric().getPageTimes();\n-                    \n-                    do {\n-                        try {\n-                            long callStart = System.nanoTime();\n-                            BaseQueryResponse page = _next(rq, queryId, proxies, span);\n-                            PageMetric pm = pageMetrics.get(pageMetrics.size() - 1);\n-                            \n-                            // Wrap the output stream so that we can get a byte count\n-                            CountingOutputStream countingStream = new CountingOutputStream(out);\n-                            \n-                            long serializationStart = System.nanoTime();\n-                            switch (serializationType) {\n-                                case XML:\n-                                    xmlSerializer.marshal(page, countingStream);\n-                                    break;\n-                                case JSON:\n-                                    // First page!\n-                                    if (!sentResults) {\n-                                        jsonGenerator.writeStartObject();\n-                                        jsonGenerator.writeArrayFieldStart(\"Pages\");\n-                                        jsonGenerator.flush();\n-                                    } else {\n-                                        // Delimiter for subsequent pages...\n-                                        countingStream.write(',');\n-                                    }\n-                                    jsonSerializer.writeValue(countingStream, page);\n-                                    break;\n-                                case PB:\n-                                    @SuppressWarnings(\"unchecked\")\n-                                    Message<Object> pb = (Message<Object>) page;\n-                                    Schema<Object> pbSchema = pb.cachedSchema();\n-                                    ProtobufIOUtil.writeTo(countingStream, page, pbSchema, buffer);\n-                                    buffer.clear();\n-                                    break;\n-                                case YAML:\n-                                    @SuppressWarnings(\"unchecked\")\n-                                    Message<Object> yaml = (Message<Object>) page;\n-                                    Schema<Object> yamlSchema = yaml.cachedSchema();\n-                                    YamlIOUtil.writeTo(countingStream, page, yamlSchema, buffer);\n-                                    buffer.clear();\n-                                    break;\n-                            }\n-                            countingStream.flush();\n-                            long serializationTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - serializationStart);\n-                            pm.setSerializationTime(serializationTime);\n-                            long pageCallTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - callStart);\n-                            pm.setCallTime(pageCallTime);\n-                            pm.setBytesWritten(countingStream.getCount());\n-                            sentResults = true;\n-                        } catch (Exception e) {\n-                            if (e instanceof NoResultsException || e.getCause() instanceof NoResultsException) {\n-                                // No more results, break out of loop\n-                                done = true;\n-                                break; // probably redundant\n-                            } else {\n-                                throw e;\n-                            }\n-                        }\n-                    } while (!done);\n-                    \n-                    if (!sentResults)\n-                        throw new NoResultsQueryException(DatawaveErrorCode.RESULTS_NOT_SENT);\n-                    else if (serializationType == SerializationType.JSON) {\n-                        jsonGenerator.writeEndArray();\n-                        jsonGenerator.writeEndObject();\n-                        jsonGenerator.flush();\n-                    }\n-                }\n-            } catch (DatawaveWebApplicationException e) {\n-                throw e;\n+              long callStart = System.nanoTime();\n+              BaseQueryResponse page = _next(rq, queryId, proxies, span);\n+              PageMetric pm = pageMetrics.get(pageMetrics.size() - 1);\n+\n+              // Wrap the output stream so that we can get a byte count\n+              CountingOutputStream countingStream = new CountingOutputStream(out);\n+\n+              long serializationStart = System.nanoTime();\n+              switch (serializationType) {\n+                case XML:\n+                  xmlSerializer.marshal(page, countingStream);\n+                  break;\n+                case JSON:\n+                  // First page!\n+                  if (!sentResults) {\n+                    jsonGenerator.writeStartObject();\n+                    jsonGenerator.writeArrayFieldStart(\"Pages\");\n+                    jsonGenerator.flush();\n+                  } else {\n+                    // Delimiter for subsequent pages...\n+                    countingStream.write(',');\n+                  }\n+                  jsonSerializer.writeValue(countingStream, page);\n+                  break;\n+                case PB:\n+                  @SuppressWarnings(\"unchecked\")\n+                  Message<Object> pb = (Message<Object>) page;\n+                  Schema<Object> pbSchema = pb.cachedSchema();\n+                  ProtobufIOUtil.writeTo(countingStream, page, pbSchema, buffer);\n+                  buffer.clear();\n+                  break;\n+                case YAML:\n+                  @SuppressWarnings(\"unchecked\")\n+                  Message<Object> yaml = (Message<Object>) page;\n+                  Schema<Object> yamlSchema = yaml.cachedSchema();\n+                  YamlIOUtil.writeTo(countingStream, page, yamlSchema, buffer);\n+                  buffer.clear();\n+                  break;\n+              }\n+              countingStream.flush();\n+              long serializationTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - serializationStart);\n+              pm.setSerializationTime(serializationTime);\n+              long pageCallTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - callStart);\n+              pm.setCallTime(pageCallTime);\n+              pm.setBytesWritten(countingStream.getCount());\n+              sentResults = true;\n             } catch (Exception e) {\n-                log.error(\"ExecuteStreamingOutputResponse write Failed\", e);\n-                QueryException qe = new QueryException(DatawaveErrorCode.QUERY_NEXT_ERROR, e, MessageFormat.format(\"query_id: {0}\", rq.getSettings().getId()));\n-                log.error(qe, e);\n-                errorResponse.addException(qe.getBottomQueryException());\n-                int statusCode = qe.getBottomQueryException().getStatusCode();\n-                throw new DatawaveWebApplicationException(qe, errorResponse, statusCode);\n-            } finally {\n-                try {\n-                    close(rq);\n-                } catch (Exception e) {\n-                    log.error(\"Error returning connection on failed create\", e);\n-                    QueryException qe = new QueryException(DatawaveErrorCode.CONNECTION_RETURN_ERROR, e);\n-                    log.error(qe, e);\n-                    errorResponse.addException(qe.getBottomQueryException());\n-                }\n+              if (e instanceof NoResultsException || e.getCause() instanceof NoResultsException) {\n+                // No more results, break out of loop\n+                done = true;\n+                break; // probably redundant\n+              } else {\n+                throw e;\n+              }\n             }\n+          } while (!done);\n+\n+          if (!sentResults) {\n+            throw new NoResultsQueryException(DatawaveErrorCode.RESULTS_NOT_SENT);\n+          } else if (serializationType == SerializationType.JSON) {\n+            jsonGenerator.writeEndArray();\n+            jsonGenerator.writeEndObject();\n+            jsonGenerator.flush();\n+          }\n+        }\n+      } catch (DatawaveWebApplicationException e) {\n+        throw e;\n+      } catch (Exception e) {\n+        log.error(\"ExecuteStreamingOutputResponse write Failed\", e);\n+        QueryException qe = new QueryException(DatawaveErrorCode.QUERY_NEXT_ERROR, e,\n+            MessageFormat.format(\"query_id: {0}\", rq.getSettings().getId()));\n+        log.error(qe, e);\n+        errorResponse.addException(qe.getBottomQueryException());\n+        int statusCode = qe.getBottomQueryException().getStatusCode();\n+        throw new DatawaveWebApplicationException(qe, errorResponse, statusCode);\n+      } finally {\n+        try {\n+          close(rq);\n+        } catch (Exception e) {\n+          log.error(\"Error returning connection on failed create\", e);\n+          QueryException qe = new QueryException(DatawaveErrorCode.CONNECTION_RETURN_ERROR, e);\n+          log.error(qe, e);\n+          errorResponse.addException(qe.getBottomQueryException());\n         }\n-        \n-    }\n-    \n-    private void testForUncaughtException(Query settings, ResultsPage resultList) throws QueryException {\n-        QueryUncaughtExceptionHandler handler = settings.getUncaughtExceptionHandler();\n-        if (handler != null) {\n-            if (handler.getThrowable() != null) {\n-                if (resultList.getResults() != null && !resultList.getResults().isEmpty()) {\n-                    log.warn(\"Exception with Partial Results: resultList.getResults().size() is \" + resultList.getResults().size()\n-                                    + \", and there was an UncaughtException:\" + handler.getThrowable() + \" in thread \" + handler.getThread());\n-                } else {\n-                    if (log.isDebugEnabled()) {\n-                        log.debug(\"Throwing:\" + handler.getThrowable() + \" for query with no results\");\n-                    }\n-                }\n-                if (handler.getThrowable() instanceof QueryException) {\n-                    throw ((QueryException) handler.getThrowable());\n-                }\n-                throw new QueryException(handler.getThrowable());\n-            }\n+      }\n+    }\n+\n+  }\n+\n+  private void testForUncaughtException(Query settings, ResultsPage resultList) throws QueryException {\n+    QueryUncaughtExceptionHandler handler = settings.getUncaughtExceptionHandler();\n+    if (handler != null) {\n+      if (handler.getThrowable() != null) {\n+        if (resultList.getResults() != null && !resultList.getResults().isEmpty()) {\n+          log.warn(\"Exception with Partial Results: resultList.getResults().size() is \" + resultList.getResults().size()\n+              + \", and there was an UncaughtException:\" + handler.getThrowable() + \" in thread \" + handler.getThread());\n+        } else {\n+          if (log.isDebugEnabled()) {\n+            log.debug(\"Throwing:\" + handler.getThrowable() + \" for query with no results\");\n+          }\n+        }\n+        if (handler.getThrowable() instanceof QueryException) {\n+          throw ((QueryException) handler.getThrowable());\n         }\n+        throw new QueryException(handler.getThrowable());\n+      }\n     }\n+  }\n }\n",
            "diff_size": 4912
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "88",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/81/QueryExecutorBean.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/naturalize/81/QueryExecutorBean.java\nindex 12bd8260ba2..8e99945900b 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/81/QueryExecutorBean.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/naturalize/81/QueryExecutorBean.java\n@@ -574,8 +574,7 @@ public class QueryExecutorBean implements QueryExecutor {\n             \n             AccumuloConnectionFactory.Priority priority = qd.logic.getConnectionPriority();\n             \n-            rq = new RunningQuery(metrics, null, priority, qd.logic, q, qp.getAuths(), qd.p, new RunningQueryTimingImpl(queryExpirationConf,\n-                            qp.getPageTimeout()), this.executor, this.predictor, this.metricFactory);\n+            rq = new RunningQuery(metrics, null, priority, qd.logic, q, qp.getAuths(), qd.p, new RunningQueryTimingImpl(queryExpirationConf, qp.getPageTimeout()), this.executor, this.predictor, this.metricFactory);\n             rq.setActiveCall(true);\n             rq.getMetric().setProxyServers(qd.proxyServers);\n             rq.setTraceInfo(traceInfo);\n@@ -943,8 +942,7 @@ public class QueryExecutorBean implements QueryExecutor {\n     @Timed(name = \"dw.query.predictQuery\", absolute = true)\n     public GenericResponse<String> predictQuery(@Required(\"logicName\") @PathParam(\"logicName\") String queryLogicName,\n                     MultivaluedMap<String,String> queryParameters) {\n-        \n-        CreateQuerySessionIDFilter.QUERY_ID.set(null);\n+    CreateQuerySessionIDFilter.QUERY_ID.set(null);\n         \n         QueryData qd = validateQuery(queryLogicName, queryParameters, null);\n         \n@@ -972,12 +970,11 @@ public class QueryExecutorBean implements QueryExecutor {\n                 }\n             } catch (Throwable t) {\n                 response.setHasResults(false);\n-                \n-                /*\n+\n+/*\n                  * Allow web services to throw their own WebApplicationExceptions\n                  */\n-                \n-                if (t instanceof Error && !(t instanceof TokenMgrError)) {\n+            if (t instanceof Error && !(t instanceof TokenMgrError)) {\n                     log.error(t.getMessage(), t);\n                     throw (Error) t;\n                 } else if (t instanceof WebApplicationException) {\n@@ -1697,14 +1694,13 @@ public class QueryExecutorBean implements QueryExecutor {\n                         throw new NotFoundQueryException(DatawaveErrorCode.NO_QUERY_OBJECT_MATCH, MessageFormat.format(\"{0}\", id));\n                     }\n                 }\n-                \n-                throw new PreConditionFailedQueryException(DatawaveErrorCode.QUERY_TIMEOUT_OR_SERVER_ERROR, MessageFormat.format(\"id = {0}\", id));\n+throw new PreConditionFailedQueryException(DatawaveErrorCode.QUERY_TIMEOUT_OR_SERVER_ERROR, MessageFormat.format(\"id = {0}\", id));\n             } else {\n                 // Validate the query belongs to the caller\n                 if (!query.getSettings().getOwner().equals(userid)) {\n                     throw new UnauthorizedQueryException(DatawaveErrorCode.QUERY_OWNER_MISMATCH, MessageFormat.format(\"{0} != {1}\", userid, query.getSettings()\n                                     .getOwner()));\n-                }\n+    }\n                 \n                 // pull the plan out of the query metric\n                 String plan = query.getMetric().getPlan();\n@@ -1782,14 +1778,13 @@ public class QueryExecutorBean implements QueryExecutor {\n                         throw new NotFoundQueryException(DatawaveErrorCode.NO_QUERY_OBJECT_MATCH, MessageFormat.format(\"{0}\", id));\n                     }\n                 }\n-                \n-                throw new PreConditionFailedQueryException(DatawaveErrorCode.QUERY_TIMEOUT_OR_SERVER_ERROR, MessageFormat.format(\"id = {0}\", id));\n+throw new PreConditionFailedQueryException(DatawaveErrorCode.QUERY_TIMEOUT_OR_SERVER_ERROR, MessageFormat.format(\"id = {0}\", id));\n             } else {\n                 // Validate the query belongs to the caller\n                 if (!query.getSettings().getOwner().equals(userid)) {\n                     throw new UnauthorizedQueryException(DatawaveErrorCode.QUERY_OWNER_MISMATCH, MessageFormat.format(\"{0} != {1}\", userid, query.getSettings()\n                                     .getOwner()));\n-                }\n+    }\n                 \n                 // pull the predictions out of the query metric\n                 Set<Prediction> predictions = query.getMetric().getPredictions();\n@@ -1939,14 +1934,13 @@ public class QueryExecutorBean implements QueryExecutor {\n                         throw new NotFoundQueryException(DatawaveErrorCode.NO_QUERY_OBJECT_MATCH, MessageFormat.format(\"{0}\", id));\n                     }\n                 }\n-                \n-                throw new PreConditionFailedQueryException(DatawaveErrorCode.QUERY_TIMEOUT_OR_SERVER_ERROR, MessageFormat.format(\"id = {0}\", id));\n+throw new PreConditionFailedQueryException(DatawaveErrorCode.QUERY_TIMEOUT_OR_SERVER_ERROR, MessageFormat.format(\"id = {0}\", id));\n             } else {\n                 // Validate the query belongs to the caller\n                 if (!query.getSettings().getOwner().equals(userid)) {\n                     throw new UnauthorizedQueryException(DatawaveErrorCode.QUERY_OWNER_MISMATCH, MessageFormat.format(\"{0} != {1}\", userid, query.getSettings()\n                                     .getOwner()));\n-                }\n+    }\n                 \n                 // Set the active call and get next\n                 query.setActiveCall(true);\n@@ -2773,7 +2767,7 @@ public class QueryExecutorBean implements QueryExecutor {\n                             maxResultsOverride, persistenceMode, parameters);\n             \n             response.setResult(id);\n-            return response;\n+return response;\n         } catch (DatawaveWebApplicationException e) {\n             throw e;\n         } catch (Exception e) {\n@@ -2789,8 +2783,7 @@ public class QueryExecutorBean implements QueryExecutor {\n     }\n     \n     private void updateQuery(GenericResponse<String> response, RunningQuery runningQuery, String queryLogicName, String query, Date beginDate, Date endDate,\n-                    String queryAuthorizations, Date expirationDate, Integer pagesize, Integer pageTimeout, Long maxResultsOverride,\n-                    QueryPersistence persistenceMode, String parameters) throws Exception {\n+                    String queryAuthorizations, Date expirationDate, Integer pagesize, Integer pageTimeout, Long maxResultsOverride, QueryPersistence persistenceMode, String parameters) throws Exception {\n         // Find out who/what called this method\n         Principal p = ctx.getCallerPrincipal();\n         String userid = p.getName();\n@@ -2824,8 +2817,7 @@ public class QueryExecutorBean implements QueryExecutor {\n             Query duplicate = q.duplicate(q.getQueryName());\n             duplicate.setId(q.getId());\n             \n-            updateQueryParams(duplicate, queryLogicName, query, beginDate, endDate, queryAuthorizations, expirationDate, pagesize, pageTimeout,\n-                            maxResultsOverride, parameters);\n+            updateQueryParams(duplicate, queryLogicName, query, beginDate, endDate, queryAuthorizations, expirationDate, pagesize, pageTimeout, maxResultsOverride, parameters);\n             \n             // Fire off an audit prior to updating\n             Set<String> methodAuths = new HashSet<>(Arrays.asList(q.getQueryAuthorizations().split(\"\\\\s*,\\\\s*\")));\n@@ -3415,8 +3407,7 @@ public class QueryExecutorBean implements QueryExecutor {\n         private SerializationType serializationType = SerializationType.XML;\n         private Collection<String> proxies = null;\n         \n-        public ExecuteStreamingOutputResponse(String queryId, Class<?> queryResponseClass, VoidResponse errorResponse, RunningQuery rq,\n-                        SerializationType serializationType, Collection<String> proxies) {\n+        public ExecuteStreamingOutputResponse(String queryId, Class<?> queryResponseClass, VoidResponse errorResponse, RunningQuery rq, SerializationType serializationType, Collection<String> proxies) {\n             super();\n             this.queryId = queryId;\n             this.queryResponseClass = queryResponseClass;\n@@ -3455,21 +3446,19 @@ public class QueryExecutorBean implements QueryExecutor {\n                     jsonGenerator.enable(JsonGenerator.Feature.FLUSH_PASSED_TO_STREAM);\n                     \n                     boolean sentResults = false;\n-                    boolean done = false;\n+boolean done = false;\n                     TraceScope span = null;\n                     List<PageMetric> pageMetrics = rq.getMetric().getPageTimes();\n-                    \n-                    do {\n-                        try {\n+do {\n+    try {\n                             long callStart = System.nanoTime();\n                             BaseQueryResponse page = _next(rq, queryId, proxies, span);\n                             PageMetric pm = pageMetrics.get(pageMetrics.size() - 1);\n                             \n                             // Wrap the output stream so that we can get a byte count\n                             CountingOutputStream countingStream = new CountingOutputStream(out);\n-                            \n-                            long serializationStart = System.nanoTime();\n-                            switch (serializationType) {\n+long serializationStart = System.nanoTime();\n+switch (serializationType) {\n                                 case XML:\n                                     xmlSerializer.marshal(page, countingStream);\n                                     break;\n@@ -3519,7 +3508,7 @@ public class QueryExecutorBean implements QueryExecutor {\n                     } while (!done);\n                     \n                     if (!sentResults)\n-                        throw new NoResultsQueryException(DatawaveErrorCode.RESULTS_NOT_SENT);\n+    throw new NoResultsQueryException(DatawaveErrorCode.RESULTS_NOT_SENT);\n                     else if (serializationType == SerializationType.JSON) {\n                         jsonGenerator.writeEndArray();\n                         jsonGenerator.writeEndObject();\n@@ -3568,4 +3557,4 @@ public class QueryExecutorBean implements QueryExecutor {\n             }\n         }\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 33
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "88",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "88",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ],
    "repaired_by": [],
    "not_repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}