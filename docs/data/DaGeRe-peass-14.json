{
    "project_name": "DaGeRe-peass",
    "error_id": "14",
    "information": {
        "errors": [
            {
                "line": "20",
                "column": "44",
                "severity": "error",
                "message": "'{' is not preceded with whitespace.",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
            }
        ]
    },
    "source_code": "\n@JsonDeserialize(using = CallTreeNodeDeserializer.class)\npublic class CallTreeNode extends BasicNode{\n\n   private static final Logger LOG = LogManager.getLogger(CallTreeNode.class);\n",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/errored/1/14/CallTreeNode.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/styler/14/CallTreeNode.java\nindex a0eb81a7820..2f7c5b6afca 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/errored/1/14/CallTreeNode.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/styler/14/CallTreeNode.java\n@@ -17,9 +17,9 @@ import de.peass.dependency.analysis.data.ChangedEntity;\n import de.peass.measurement.analysis.statistics.TestcaseStatistic;\n \n @JsonDeserialize(using = CallTreeNodeDeserializer.class)\n-public class CallTreeNode extends BasicNode{\n+public class CallTreeNode extends BasicNode {\n \n-   private static final Logger LOG = LogManager.getLogger(CallTreeNode.class);\n+\tprivate static final Logger LOG = LogManager.getLogger(CallTreeNode.class);\n \n    @JsonIgnore\n    private final CallTreeNode parent;\n",
            "diff_size": 2
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/errored/1/14/CallTreeNode.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/intellij/14/CallTreeNode.java\nindex a0eb81a7820..a5d6b03339d 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/errored/1/14/CallTreeNode.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/intellij/14/CallTreeNode.java\n@@ -17,221 +17,221 @@ import de.peass.dependency.analysis.data.ChangedEntity;\n import de.peass.measurement.analysis.statistics.TestcaseStatistic;\n \n @JsonDeserialize(using = CallTreeNodeDeserializer.class)\n-public class CallTreeNode extends BasicNode{\n-\n-   private static final Logger LOG = LogManager.getLogger(CallTreeNode.class);\n-\n-   @JsonIgnore\n-   private final CallTreeNode parent;\n-   protected final List<CallTreeNode> children = new ArrayList<>();\n-   protected final Map<String, CallTreeStatistics> data = new HashMap<>();\n-\n-   protected String version, predecessor;\n-\n-   private int warmup;\n-\n-   private CallTreeNode otherVersionNode;\n-\n-   /**\n-    * Creates a root node\n-    */\n-   public CallTreeNode(final String call, final String kiekerPattern) {\n-      super(call, kiekerPattern);\n-      if (!kiekerPattern.contains(call.replace(\"#\", \".\"))) {\n-         throw new RuntimeException(\"Pattern \" + kiekerPattern + \" must contain \" + call);\n-      }\n-      if (kiekerPattern.contains(\"<init>\") && !kiekerPattern.contains(\"new\")) {\n-         throw new RuntimeException(\"Pattern \" + kiekerPattern + \" not legal - Constructor must contain new as return type!\");\n-      }\n-      this.parent = null;\n-   }\n-\n-   protected CallTreeNode(final String call, final String kiekerPattern, final CallTreeNode parent) {\n-      super(call, kiekerPattern);\n-      if (!kiekerPattern.contains(call.replace(\"#\", \".\"))) {\n-         throw new RuntimeException(\"Pattern \" + kiekerPattern + \" must contain \" + call);\n-      }\n-      if (kiekerPattern.contains(\"<init>\") && !kiekerPattern.contains(\"new\")) {\n-         throw new RuntimeException(\"Pattern \" + kiekerPattern + \" not legal - Constructor must contain new as return type!\");\n-      }\n-      this.parent = parent;\n-   }\n-\n-   public List<CallTreeNode> getChildren() {\n-      return children;\n-   }\n-\n-   public CallTreeNode appendChild(final String call, final String kiekerPattern) {\n-      final CallTreeNode added = new CallTreeNode(call, kiekerPattern, this);\n-      children.add(added);\n-      return added;\n-   }\n-\n-   public CallTreeNode getParent() {\n-      return parent;\n-   }\n-\n-   public void addMeasurement(final String version, final Long duration) {\n-      data.get(version).addMeasurement(duration);\n-   }\n-\n-   public void setMeasurement(final String version, final List<StatisticalSummary> statistic) {\n-      data.get(version).setMeasurement(statistic);\n-   }\n-\n-   public boolean hasMeasurement(final String version) {\n-      return data.get(version).getResults().size() > 0;\n-   }\n-\n-   public List<OneVMResult> getResults(final String version) {\n-      return data.get(version).getResults();\n-   }\n-\n-   public void newVM(final String version) {\n-      LOG.debug(\"Adding VM: {}\", version);\n-      final CallTreeStatistics statistics = data.get(version);\n-      LOG.debug(\"VMs: {}\", statistics.getResults().size());\n-      statistics.newResult();\n-   }\n-\n-   private void newVersion(final String version) {\n-      LOG.trace(\"Adding version: {}\", version);\n-      CallTreeStatistics statistics = data.get(version);\n-      if (statistics == null) {\n-         statistics = new CallTreeStatistics(warmup);\n-         data.put(version, statistics);\n-      }\n-   }\n-\n-   public void setWarmup(final int warmup) {\n-      this.warmup = warmup;\n-   }\n-\n-   public SummaryStatistics getStatistics(final String version) {\n-      LOG.debug(\"Getting data: {}\", version);\n-      final CallTreeStatistics statistics = data.get(version);\n-      if (statistics.getStatistics().getN() == 0) {\n-         LOG.error(\"Call createStatistics first for \" + call);\n-      }\n-      return statistics.getStatistics();\n-   }\n-\n-   public void createStatistics(final String version) {\n-      LOG.debug(\"Creating statistics: {}\", version);\n-      final CallTreeStatistics callTreeStatistics = data.get(version);\n-      callTreeStatistics.createStatistics();\n-   }\n-\n-   @Override\n-   public String toString() {\n-      return kiekerPattern.toString();\n-   }\n-\n-   public ChangedEntity toEntity() {\n-      final int index = call.lastIndexOf(ChangedEntity.METHOD_SEPARATOR);\n-      final ChangedEntity entity = new ChangedEntity(call.substring(0, index), \"\", call.substring(index + 1));\n-      return entity;\n-   }\n-\n-   @JsonIgnore\n-   public TestcaseStatistic getTestcaseStatistic() {\n-      final SummaryStatistics current = data.get(version).getStatistics();\n-      final SummaryStatistics previous = data.get(predecessor).getStatistics();\n-      return new TestcaseStatistic(current, previous, data.get(version).getCalls(), data.get(predecessor).getCalls());\n-   }\n-\n-   @JsonIgnore\n-   public void setVersions(final String version, final String predecessor) {\n-      this.version = version;\n-      this.predecessor = predecessor;\n-      resetStatistics();\n-      newVersion(version);\n-      newVersion(predecessor);\n-   }\n-\n-   @JsonIgnore\n-   public int getTreeSize() {\n-      int size = 1;\n-      for (final CallTreeNode child : children) {\n-         size += child.getTreeSize();\n-      }\n-      return size;\n-   }\n-\n-   protected void resetStatistics() {\n-      data.values().forEach(statistics -> statistics.resetResults());\n-   }\n-\n-   @JsonIgnore\n-   public CallTreeNode getOtherVersionNode() {\n-      return otherVersionNode;\n-   }\n-\n-   public void setOtherVersionNode(final CallTreeNode otherVersionNode) {\n-      this.otherVersionNode = otherVersionNode;\n-   }\n-\n-   @JsonIgnore\n-   public String getMethod() {\n-      final String method = call.substring(call.lastIndexOf('#'));\n-      return method;\n-   }\n-\n-   @JsonIgnore\n-   public String getParameters() {\n-      final String parameters = kiekerPattern.substring(kiekerPattern.indexOf('('));\n-      return parameters;\n-   }\n-\n-   @JsonIgnore\n-   public int getEss() {\n-      return parent != null ? parent.getEss() + 1 : 0;\n-   }\n-\n-   @JsonIgnore\n-   public int getEoi() {\n-      final int parentIndex = parent != null ? parent.getChildren().indexOf(this) : 0;\n-      final int parentEoi = parent != null ? parent.getEoi() : 0;\n-      final int eoi = parentEoi + 1 + parentIndex;\n-      return eoi;\n-   }\n-\n-   @JsonIgnore\n-   public int getPosition() {\n-      for (int childIndex = 0; childIndex < parent.getChildren().size(); childIndex++) {\n-         if (parent.getChildren().get(childIndex) == this) {\n-            return childIndex;\n-         }\n+public class CallTreeNode extends BasicNode {\n+\n+  private static final Logger LOG = LogManager.getLogger(CallTreeNode.class);\n+\n+  @JsonIgnore\n+  private final CallTreeNode parent;\n+  protected final List<CallTreeNode> children = new ArrayList<>();\n+  protected final Map<String, CallTreeStatistics> data = new HashMap<>();\n+\n+  protected String version, predecessor;\n+\n+  private int warmup;\n+\n+  private CallTreeNode otherVersionNode;\n+\n+  /**\n+   * Creates a root node\n+   */\n+  public CallTreeNode(final String call, final String kiekerPattern) {\n+    super(call, kiekerPattern);\n+    if (!kiekerPattern.contains(call.replace(\"#\", \".\"))) {\n+      throw new RuntimeException(\"Pattern \" + kiekerPattern + \" must contain \" + call);\n+    }\n+    if (kiekerPattern.contains(\"<init>\") && !kiekerPattern.contains(\"new\")) {\n+      throw new RuntimeException(\"Pattern \" + kiekerPattern + \" not legal - Constructor must contain new as return type!\");\n+    }\n+    this.parent = null;\n+  }\n+\n+  protected CallTreeNode(final String call, final String kiekerPattern, final CallTreeNode parent) {\n+    super(call, kiekerPattern);\n+    if (!kiekerPattern.contains(call.replace(\"#\", \".\"))) {\n+      throw new RuntimeException(\"Pattern \" + kiekerPattern + \" must contain \" + call);\n+    }\n+    if (kiekerPattern.contains(\"<init>\") && !kiekerPattern.contains(\"new\")) {\n+      throw new RuntimeException(\"Pattern \" + kiekerPattern + \" not legal - Constructor must contain new as return type!\");\n+    }\n+    this.parent = parent;\n+  }\n+\n+  public List<CallTreeNode> getChildren() {\n+    return children;\n+  }\n+\n+  public CallTreeNode appendChild(final String call, final String kiekerPattern) {\n+    final CallTreeNode added = new CallTreeNode(call, kiekerPattern, this);\n+    children.add(added);\n+    return added;\n+  }\n+\n+  public CallTreeNode getParent() {\n+    return parent;\n+  }\n+\n+  public void addMeasurement(final String version, final Long duration) {\n+    data.get(version).addMeasurement(duration);\n+  }\n+\n+  public void setMeasurement(final String version, final List<StatisticalSummary> statistic) {\n+    data.get(version).setMeasurement(statistic);\n+  }\n+\n+  public boolean hasMeasurement(final String version) {\n+    return data.get(version).getResults().size() > 0;\n+  }\n+\n+  public List<OneVMResult> getResults(final String version) {\n+    return data.get(version).getResults();\n+  }\n+\n+  public void newVM(final String version) {\n+    LOG.debug(\"Adding VM: {}\", version);\n+    final CallTreeStatistics statistics = data.get(version);\n+    LOG.debug(\"VMs: {}\", statistics.getResults().size());\n+    statistics.newResult();\n+  }\n+\n+  private void newVersion(final String version) {\n+    LOG.trace(\"Adding version: {}\", version);\n+    CallTreeStatistics statistics = data.get(version);\n+    if (statistics == null) {\n+      statistics = new CallTreeStatistics(warmup);\n+      data.put(version, statistics);\n+    }\n+  }\n+\n+  public void setWarmup(final int warmup) {\n+    this.warmup = warmup;\n+  }\n+\n+  public SummaryStatistics getStatistics(final String version) {\n+    LOG.debug(\"Getting data: {}\", version);\n+    final CallTreeStatistics statistics = data.get(version);\n+    if (statistics.getStatistics().getN() == 0) {\n+      LOG.error(\"Call createStatistics first for \" + call);\n+    }\n+    return statistics.getStatistics();\n+  }\n+\n+  public void createStatistics(final String version) {\n+    LOG.debug(\"Creating statistics: {}\", version);\n+    final CallTreeStatistics callTreeStatistics = data.get(version);\n+    callTreeStatistics.createStatistics();\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return kiekerPattern.toString();\n+  }\n+\n+  public ChangedEntity toEntity() {\n+    final int index = call.lastIndexOf(ChangedEntity.METHOD_SEPARATOR);\n+    final ChangedEntity entity = new ChangedEntity(call.substring(0, index), \"\", call.substring(index + 1));\n+    return entity;\n+  }\n+\n+  @JsonIgnore\n+  public TestcaseStatistic getTestcaseStatistic() {\n+    final SummaryStatistics current = data.get(version).getStatistics();\n+    final SummaryStatistics previous = data.get(predecessor).getStatistics();\n+    return new TestcaseStatistic(current, previous, data.get(version).getCalls(), data.get(predecessor).getCalls());\n+  }\n+\n+  @JsonIgnore\n+  public void setVersions(final String version, final String predecessor) {\n+    this.version = version;\n+    this.predecessor = predecessor;\n+    resetStatistics();\n+    newVersion(version);\n+    newVersion(predecessor);\n+  }\n+\n+  @JsonIgnore\n+  public int getTreeSize() {\n+    int size = 1;\n+    for (final CallTreeNode child : children) {\n+      size += child.getTreeSize();\n+    }\n+    return size;\n+  }\n+\n+  protected void resetStatistics() {\n+    data.values().forEach(statistics -> statistics.resetResults());\n+  }\n+\n+  @JsonIgnore\n+  public CallTreeNode getOtherVersionNode() {\n+    return otherVersionNode;\n+  }\n+\n+  public void setOtherVersionNode(final CallTreeNode otherVersionNode) {\n+    this.otherVersionNode = otherVersionNode;\n+  }\n+\n+  @JsonIgnore\n+  public String getMethod() {\n+    final String method = call.substring(call.lastIndexOf('#'));\n+    return method;\n+  }\n+\n+  @JsonIgnore\n+  public String getParameters() {\n+    final String parameters = kiekerPattern.substring(kiekerPattern.indexOf('('));\n+    return parameters;\n+  }\n+\n+  @JsonIgnore\n+  public int getEss() {\n+    return parent != null ? parent.getEss() + 1 : 0;\n+  }\n+\n+  @JsonIgnore\n+  public int getEoi() {\n+    final int parentIndex = parent != null ? parent.getChildren().indexOf(this) : 0;\n+    final int parentEoi = parent != null ? parent.getEoi() : 0;\n+    final int eoi = parentEoi + 1 + parentIndex;\n+    return eoi;\n+  }\n+\n+  @JsonIgnore\n+  public int getPosition() {\n+    for (int childIndex = 0; childIndex < parent.getChildren().size(); childIndex++) {\n+      if (parent.getChildren().get(childIndex) == this) {\n+        return childIndex;\n       }\n-      return -1;\n-   }\n-\n-   public long getCallCount(final String version) {\n-      return data.get(version).getResults().stream().mapToLong(result -> result.getCalls()).sum();\n-   }\n-\n-   @Override\n-   public int hashCode() {\n-      return kiekerPattern.hashCode();\n-   }\n-\n-   @Override\n-   public boolean equals(final Object obj) {\n-      if (obj instanceof CallTreeNode) {\n-         final CallTreeNode other = (CallTreeNode) obj;\n-         boolean equal = other.getKiekerPattern().equals(kiekerPattern);\n-         if (equal) {\n-            if ((this.parent == null) != (other.parent == null)) {\n-               equal = false;\n-            } else if (parent != null) {\n-               equal &= this.parent.equals(other.parent);\n-               equal &= (this.getPosition() == other.getPosition());\n-            }\n-         }\n-         return equal;\n-      } else {\n-         return false;\n+    }\n+    return -1;\n+  }\n+\n+  public long getCallCount(final String version) {\n+    return data.get(version).getResults().stream().mapToLong(result -> result.getCalls()).sum();\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return kiekerPattern.hashCode();\n+  }\n+\n+  @Override\n+  public boolean equals(final Object obj) {\n+    if (obj instanceof CallTreeNode) {\n+      final CallTreeNode other = (CallTreeNode) obj;\n+      boolean equal = other.getKiekerPattern().equals(kiekerPattern);\n+      if (equal) {\n+        if ((this.parent == null) != (other.parent == null)) {\n+          equal = false;\n+        } else if (parent != null) {\n+          equal &= this.parent.equals(other.parent);\n+          equal &= (this.getPosition() == other.getPosition());\n+        }\n       }\n-   }\n+      return equal;\n+    } else {\n+      return false;\n+    }\n+  }\n \n }\n\\ No newline at end of file\n",
            "diff_size": 218
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "17",
                    "column": "57",
                    "severity": "error",
                    "message": "')' is preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/errored/1/14/CallTreeNode.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/codebuff/14/CallTreeNode.java\nindex a0eb81a7820..d186a40d52c 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/errored/1/14/CallTreeNode.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/codebuff/14/CallTreeNode.java\n@@ -4,234 +4,231 @@ import java.util.ArrayList;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n-\n import org.apache.commons.math3.stat.descriptive.StatisticalSummary;\n import org.apache.commons.math3.stat.descriptive.SummaryStatistics;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n-\n import com.fasterxml.jackson.annotation.JsonIgnore;\n import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n-\n import de.peass.dependency.analysis.data.ChangedEntity;\n import de.peass.measurement.analysis.statistics.TestcaseStatistic;\n \n-@JsonDeserialize(using = CallTreeNodeDeserializer.class)\n-public class CallTreeNode extends BasicNode{\n-\n-   private static final Logger LOG = LogManager.getLogger(CallTreeNode.class);\n-\n-   @JsonIgnore\n-   private final CallTreeNode parent;\n-   protected final List<CallTreeNode> children = new ArrayList<>();\n-   protected final Map<String, CallTreeStatistics> data = new HashMap<>();\n \n-   protected String version, predecessor;\n+@JsonDeserialize(using = CallTreeNodeDeserializer.class ) public class CallTreeNode extends BasicNode {\n+ private static final Logger LOG = LogManager.getLogger(CallTreeNode.class);\n \n-   private int warmup;\n-\n-   private CallTreeNode otherVersionNode;\n+ @JsonIgnore private final CallTreeNode parent;\n+ protected final List<CallTreeNode> children = new ArrayList<>();\n+ protected final Map<String, CallTreeStatistics> data = new HashMap<>();\n+ protected String version, predecessor;\n+ private int warmup;\n+ private CallTreeNode otherVersionNode;\n \n    /**\n     * Creates a root node\n     */\n-   public CallTreeNode(final String call, final String kiekerPattern) {\n-      super(call, kiekerPattern);\n-      if (!kiekerPattern.contains(call.replace(\"#\", \".\"))) {\n-         throw new RuntimeException(\"Pattern \" + kiekerPattern + \" must contain \" + call);\n-      }\n-      if (kiekerPattern.contains(\"<init>\") && !kiekerPattern.contains(\"new\")) {\n-         throw new RuntimeException(\"Pattern \" + kiekerPattern + \" not legal - Constructor must contain new as return type!\");\n-      }\n-      this.parent = null;\n-   }\n-\n-   protected CallTreeNode(final String call, final String kiekerPattern, final CallTreeNode parent) {\n-      super(call, kiekerPattern);\n-      if (!kiekerPattern.contains(call.replace(\"#\", \".\"))) {\n-         throw new RuntimeException(\"Pattern \" + kiekerPattern + \" must contain \" + call);\n-      }\n-      if (kiekerPattern.contains(\"<init>\") && !kiekerPattern.contains(\"new\")) {\n-         throw new RuntimeException(\"Pattern \" + kiekerPattern + \" not legal - Constructor must contain new as return type!\");\n-      }\n-      this.parent = parent;\n-   }\n-\n-   public List<CallTreeNode> getChildren() {\n-      return children;\n-   }\n-\n-   public CallTreeNode appendChild(final String call, final String kiekerPattern) {\n-      final CallTreeNode added = new CallTreeNode(call, kiekerPattern, this);\n-      children.add(added);\n-      return added;\n-   }\n-\n-   public CallTreeNode getParent() {\n-      return parent;\n-   }\n-\n-   public void addMeasurement(final String version, final Long duration) {\n-      data.get(version).addMeasurement(duration);\n-   }\n-\n-   public void setMeasurement(final String version, final List<StatisticalSummary> statistic) {\n-      data.get(version).setMeasurement(statistic);\n-   }\n-\n-   public boolean hasMeasurement(final String version) {\n-      return data.get(version).getResults().size() > 0;\n-   }\n-\n-   public List<OneVMResult> getResults(final String version) {\n-      return data.get(version).getResults();\n-   }\n-\n-   public void newVM(final String version) {\n-      LOG.debug(\"Adding VM: {}\", version);\n-      final CallTreeStatistics statistics = data.get(version);\n-      LOG.debug(\"VMs: {}\", statistics.getResults().size());\n-      statistics.newResult();\n-   }\n-\n-   private void newVersion(final String version) {\n-      LOG.trace(\"Adding version: {}\", version);\n-      CallTreeStatistics statistics = data.get(version);\n-      if (statistics == null) {\n-         statistics = new CallTreeStatistics(warmup);\n-         data.put(version, statistics);\n-      }\n-   }\n-\n-   public void setWarmup(final int warmup) {\n-      this.warmup = warmup;\n-   }\n-\n-   public SummaryStatistics getStatistics(final String version) {\n-      LOG.debug(\"Getting data: {}\", version);\n-      final CallTreeStatistics statistics = data.get(version);\n-      if (statistics.getStatistics().getN() == 0) {\n-         LOG.error(\"Call createStatistics first for \" + call);\n-      }\n-      return statistics.getStatistics();\n-   }\n-\n-   public void createStatistics(final String version) {\n-      LOG.debug(\"Creating statistics: {}\", version);\n-      final CallTreeStatistics callTreeStatistics = data.get(version);\n-      callTreeStatistics.createStatistics();\n-   }\n-\n-   @Override\n-   public String toString() {\n-      return kiekerPattern.toString();\n-   }\n-\n-   public ChangedEntity toEntity() {\n-      final int index = call.lastIndexOf(ChangedEntity.METHOD_SEPARATOR);\n-      final ChangedEntity entity = new ChangedEntity(call.substring(0, index), \"\", call.substring(index + 1));\n-      return entity;\n-   }\n-\n-   @JsonIgnore\n-   public TestcaseStatistic getTestcaseStatistic() {\n-      final SummaryStatistics current = data.get(version).getStatistics();\n-      final SummaryStatistics previous = data.get(predecessor).getStatistics();\n-      return new TestcaseStatistic(current, previous, data.get(version).getCalls(), data.get(predecessor).getCalls());\n-   }\n-\n-   @JsonIgnore\n-   public void setVersions(final String version, final String predecessor) {\n-      this.version = version;\n-      this.predecessor = predecessor;\n-      resetStatistics();\n-      newVersion(version);\n-      newVersion(predecessor);\n-   }\n-\n-   @JsonIgnore\n-   public int getTreeSize() {\n-      int size = 1;\n-      for (final CallTreeNode child : children) {\n-         size += child.getTreeSize();\n-      }\n-      return size;\n-   }\n-\n-   protected void resetStatistics() {\n-      data.values().forEach(statistics -> statistics.resetResults());\n-   }\n-\n-   @JsonIgnore\n-   public CallTreeNode getOtherVersionNode() {\n-      return otherVersionNode;\n-   }\n-\n-   public void setOtherVersionNode(final CallTreeNode otherVersionNode) {\n-      this.otherVersionNode = otherVersionNode;\n-   }\n-\n-   @JsonIgnore\n-   public String getMethod() {\n-      final String method = call.substring(call.lastIndexOf('#'));\n-      return method;\n-   }\n-\n-   @JsonIgnore\n-   public String getParameters() {\n-      final String parameters = kiekerPattern.substring(kiekerPattern.indexOf('('));\n-      return parameters;\n-   }\n-\n-   @JsonIgnore\n-   public int getEss() {\n-      return parent != null ? parent.getEss() + 1 : 0;\n-   }\n-\n-   @JsonIgnore\n-   public int getEoi() {\n-      final int parentIndex = parent != null ? parent.getChildren().indexOf(this) : 0;\n-      final int parentEoi = parent != null ? parent.getEoi() : 0;\n-      final int eoi = parentEoi + 1 + parentIndex;\n-      return eoi;\n-   }\n-\n-   @JsonIgnore\n-   public int getPosition() {\n-      for (int childIndex = 0; childIndex < parent.getChildren().size(); childIndex++) {\n-         if (parent.getChildren().get(childIndex) == this) {\n-            return childIndex;\n-         }\n-      }\n-      return -1;\n-   }\n-\n-   public long getCallCount(final String version) {\n-      return data.get(version).getResults().stream().mapToLong(result -> result.getCalls()).sum();\n-   }\n-\n-   @Override\n-   public int hashCode() {\n-      return kiekerPattern.hashCode();\n-   }\n-\n-   @Override\n-   public boolean equals(final Object obj) {\n-      if (obj instanceof CallTreeNode) {\n-         final CallTreeNode other = (CallTreeNode) obj;\n-         boolean equal = other.getKiekerPattern().equals(kiekerPattern);\n-         if (equal) {\n-            if ((this.parent == null) != (other.parent == null)) {\n-               equal = false;\n-            } else if (parent != null) {\n-               equal &= this.parent.equals(other.parent);\n-               equal &= (this.getPosition() == other.getPosition());\n-            }\n-         }\n-         return equal;\n-      } else {\n-         return false;\n-      }\n-   }\n \n+ public CallTreeNode(final String call, final String kiekerPattern) {\n+  super(call, kiekerPattern);\n+  if (!kiekerPattern.contains(call.replace(\"#\", \".\"))) {\n+   throw new RuntimeException(\"Pattern \" + kiekerPattern + \" must contain \" + call);\n+  }\n+  if (kiekerPattern.contains(\"<init>\") && !kiekerPattern.contains(\"new\")) {\n+   throw new RuntimeException(\"Pattern \" + kiekerPattern + \" not legal - Constructor must contain new as return type!\");\n+  }\n+  this.parent = null;\n+ }\n+\n+ protected CallTreeNode(final String call, final String kiekerPattern, final CallTreeNode parent) {\n+  super(call, kiekerPattern);\n+  if (!kiekerPattern.contains(call.replace(\"#\", \".\"))) {\n+   throw new RuntimeException(\"Pattern \" + kiekerPattern + \" must contain \" + call);\n+  }\n+  if (kiekerPattern.contains(\"<init>\") && !kiekerPattern.contains(\"new\")) {\n+   throw new RuntimeException(\"Pattern \" + kiekerPattern + \" not legal - Constructor must contain new as return type!\");\n+  }\n+  this.parent = parent;\n+ }\n+\n+\n+ public List<CallTreeNode> getChildren() {\n+  return children;\n+ }\n+\n+ public CallTreeNode appendChild(final String call, final String kiekerPattern) {\n+  final CallTreeNode added = new CallTreeNode(call, kiekerPattern, this);\n+  children.add(added);\n+  return added;\n+ }\n+\n+ public CallTreeNode getParent() {\n+  return parent;\n+ }\n+\n+ public void addMeasurement(final String version, final Long duration) {\n+  data.get(version).addMeasurement(duration);\n+ }\n+\n+ public void setMeasurement(final String version, final List<StatisticalSummary> statistic) {\n+  data.get(version).setMeasurement(statistic);\n+ }\n+\n+ public boolean hasMeasurement(final String version) {\n+  return data.get(version).getResults().size() > 0;\n+ }\n+\n+ public List<OneVMResult> getResults(final String version) {\n+  return data.get(version).getResults();\n+ }\n+\n+ public void newVM(final String version) {\n+  LOG.debug(\"Adding VM: {}\", version);\n+\n+  final CallTreeStatistics statistics = data.get(version);\n+  LOG.debug(\"VMs: {}\", statistics.getResults().size());\n+  statistics.newResult();\n+ }\n+\n+ private void newVersion(final String version) {\n+  LOG.trace(\"Adding version: {}\", version);\n+\n+  CallTreeStatistics statistics = data.get(version);\n+  if (statistics == null) {\n+   statistics = new CallTreeStatistics(warmup);\n+   data.put(version, statistics);\n+  }\n+ }\n+\n+ public void setWarmup(final int warmup) {\n+  this.warmup = warmup;\n+ }\n+\n+ public SummaryStatistics getStatistics(final String version) {\n+  LOG.debug(\"Getting data: {}\", version);\n+\n+  final CallTreeStatistics statistics = data.get(version);\n+  if (statistics.getStatistics().getN() == 0) {\n+   LOG.error(\"Call createStatistics first for \" + call);\n+  }\n+  return statistics.getStatistics();\n+ }\n+\n+ public void createStatistics(final String version) {\n+  LOG.debug(\"Creating statistics: {}\", version);\n+\n+  final CallTreeStatistics callTreeStatistics = data.get(version);\n+  callTreeStatistics.createStatistics();\n+ }\n+\n+ @Override\n+ public String toString() {\n+  return kiekerPattern.toString();\n+ }\n+\n+ public ChangedEntity toEntity() {\n+  final int index = call.lastIndexOf(ChangedEntity.METHOD_SEPARATOR);\n+  final ChangedEntity entity = new ChangedEntity(call.substring(0, index), \"\", call.substring(index + 1));\n+  return entity;\n+ }\n+\n+ @JsonIgnore\n+ public TestcaseStatistic getTestcaseStatistic() {\n+  final SummaryStatistics current = data.get(version).getStatistics();\n+  final SummaryStatistics previous = data.get(predecessor).getStatistics();\n+  return new TestcaseStatistic(current, previous, data.get(version).getCalls(), data.get(predecessor).getCalls());\n+ }\n+\n+ @JsonIgnore\n+ public void setVersions(final String version, final String predecessor) {\n+  this.version = version;\n+  this.predecessor = predecessor;\n+  resetStatistics();\n+  newVersion(version);\n+  newVersion(predecessor);\n+ }\n+\n+ @JsonIgnore\n+ public int getTreeSize() {\n+  int size = 1;\n+  for (final CallTreeNode child : children) {\n+   size += child.getTreeSize();\n+  }\n+  return size;\n+ }\n+\n+ protected void resetStatistics() {\n+  data.values().forEach(statistics -> statistics.resetResults());\n+ }\n+\n+ @JsonIgnore\n+ public CallTreeNode getOtherVersionNode() {\n+  return otherVersionNode;\n+ }\n+\n+ public void setOtherVersionNode(final CallTreeNode otherVersionNode) {\n+  this.otherVersionNode = otherVersionNode;\n+ }\n+\n+ @JsonIgnore\n+ public String getMethod() {\n+  final String method = call.substring(call.lastIndexOf('#'));\n+  return method;\n+ }\n+\n+ @JsonIgnore\n+ public String getParameters() {\n+  final String parameters = kiekerPattern.substring(kiekerPattern.indexOf('('));\n+  return parameters;\n+ }\n+\n+ @JsonIgnore\n+ public int getEss() {\n+  return parent != null ? parent.getEss() + 1 : 0;\n+ }\n+\n+ @JsonIgnore\n+ public int getEoi() {\n+  final int parentIndex = parent != null ? parent.getChildren().indexOf(this) : 0;\n+  final int parentEoi = parent != null ? parent.getEoi() : 0;\n+  final int eoi = parentEoi + 1 + parentIndex;\n+  return eoi;\n+ }\n+\n+ @JsonIgnore\n+ public int getPosition() {\n+  for (int childIndex = 0; childIndex < parent.getChildren().size(); childIndex++) {\n+   if (parent.getChildren().get(childIndex) == this) {\n+    return childIndex;\n+   }\n+  }\n+  return -1;\n+ }\n+\n+ public long getCallCount(final String version) {\n+  return data.get(version).getResults().stream().mapToLong(result -> result.getCalls()).sum();\n+ }\n+\n+ @Override\n+ public int hashCode() {\n+  return kiekerPattern.hashCode();\n+ }\n+\n+ @Override\n+ public boolean equals(final Object obj) {\n+  if (obj instanceof CallTreeNode) {\n+   final CallTreeNode other = (CallTreeNode) obj;\n+   boolean equal = other.getKiekerPattern().equals(kiekerPattern);\n+   if (equal) {\n+    if ((this.parent == null) != (other.parent == null)) {\n+     equal = false;\n+    } else if (parent != null) {\n+            equal &= this.parent.equals(other.parent);\n+            equal &= (this.getPosition() == other.getPosition());\n+    }\n+   }\n+   return equal;\n+  } else {\n+   return false;\n+  }\n+ }\n }\n\\ No newline at end of file\n",
            "diff_size": 421
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/errored/1/14/CallTreeNode.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/styler_random/14/CallTreeNode.java\nindex a0eb81a7820..2f7c5b6afca 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/errored/1/14/CallTreeNode.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/styler_random/14/CallTreeNode.java\n@@ -17,9 +17,9 @@ import de.peass.dependency.analysis.data.ChangedEntity;\n import de.peass.measurement.analysis.statistics.TestcaseStatistic;\n \n @JsonDeserialize(using = CallTreeNodeDeserializer.class)\n-public class CallTreeNode extends BasicNode{\n+public class CallTreeNode extends BasicNode {\n \n-   private static final Logger LOG = LogManager.getLogger(CallTreeNode.class);\n+\tprivate static final Logger LOG = LogManager.getLogger(CallTreeNode.class);\n \n    @JsonIgnore\n    private final CallTreeNode parent;\n",
            "diff_size": 2
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/errored/1/14/CallTreeNode.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/styler_three_grams/14/CallTreeNode.java\nindex a0eb81a7820..2f7c5b6afca 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/errored/1/14/CallTreeNode.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/styler_three_grams/14/CallTreeNode.java\n@@ -17,9 +17,9 @@ import de.peass.dependency.analysis.data.ChangedEntity;\n import de.peass.measurement.analysis.statistics.TestcaseStatistic;\n \n @JsonDeserialize(using = CallTreeNodeDeserializer.class)\n-public class CallTreeNode extends BasicNode{\n+public class CallTreeNode extends BasicNode {\n \n-   private static final Logger LOG = LogManager.getLogger(CallTreeNode.class);\n+\tprivate static final Logger LOG = LogManager.getLogger(CallTreeNode.class);\n \n    @JsonIgnore\n    private final CallTreeNode parent;\n",
            "diff_size": 2
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "naturalize",
        "codebuff"
    ]
}