{
    "project_name": "Angel-ML-angel",
    "error_id": "159",
    "information": {
        "errors": [
            {
                "line": "6",
                "severity": "error",
                "message": "Line is longer than 100 characters (found 102).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": " * Copyright (C) 2017-2018 THL A29 Limited, a Tencent company. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in\n * compliance with the License. You may obtain a copy of the License at\n *\n * https://opensource.org/licenses/Apache-2.0",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Angel-ML-angel/errored/1/159/HeapQuantileSketch.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Angel-ML-angel/intellij/159/HeapQuantileSketch.java\nindex 735ed2b2630..55acd329c85 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Angel-ML-angel/errored/1/159/HeapQuantileSketch.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Angel-ML-angel/intellij/159/HeapQuantileSketch.java\n@@ -39,7 +39,7 @@ public class HeapQuantileSketch extends QuantileSketch {\n    * garbage. Whether a level buffer used or not is indicated by the bitPattern_. The base buffer\n    * has length 2*K but might not be full and isn't necessarily sorted. The base buffer precedes the\n    * level buffers.\n-   *\n+   * <p>\n    * The levels arrays require quite a bit of explanation, which we defer until later.\n    */\n   private float[] combinedBuffer;\n@@ -252,7 +252,7 @@ public class HeapQuantileSketch extends QuantileSketch {\n   }\n \n   private void inPlacePropagationMerge(int beginLevel, final float[] buf, int bufStart,\n-      final float[] auxBuf, int auxBufStart) {\n+                                       final float[] auxBuf, int auxBufStart) {\n     final float[] levelsArr = combinedBuffer;\n     int endLevel = beginLevel;\n     long tmp = bitPattern >>> beginLevel;\n",
            "diff_size": 2
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "151",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 103).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "250",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 128).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "259",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 106).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Angel-ML-angel/errored/1/159/HeapQuantileSketch.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Angel-ML-angel/naturalize/159/HeapQuantileSketch.java\nindex 735ed2b2630..dfd78f730a2 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Angel-ML-angel/errored/1/159/HeapQuantileSketch.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Angel-ML-angel/naturalize/159/HeapQuantileSketch.java\n@@ -15,7 +15,6 @@\n  *\n  */\n \n-\n package com.tencent.angel.spark.ml.tree.sketch;\n \n \n@@ -143,15 +142,14 @@ public class HeapQuantileSketch extends QuantileSketch {\n   private void inPlacePropagationUpdate(int beginLevel, final float[] buf, int bufBeginPos) {\n     final float[] levelsArr = combinedBuffer;\n     int endLevel = beginLevel;\n-    long tmp = bitPattern >>> beginLevel;\n+    long tmp = bitPattern>>> beginLevel;\n     while ((tmp & 1) != 0) {\n       tmp >>>= 1;\n       endLevel++;\n     }\n     SketchUtils.compactBuffer(buf, bufBeginPos, levelsArr, (endLevel + 2) * k, k);\n-    SketchUtils\n-        .levelwisePropagation(bitPattern, k, beginLevel, endLevel, buf, bufBeginPos, levelsArr);\n-    bitPattern += 1L << beginLevel;\n+    SketchUtils.levelwisePropagation(bitPattern, k, beginLevel, endLevel, buf, bufBeginPos, levelsArr);\n+bitPattern += 1L << beginLevel;\n   }\n \n   public void makeSummary() {\n@@ -234,13 +232,11 @@ public class HeapQuantileSketch extends QuantileSketch {\n       update(other.combinedBuffer[i]);\n     }\n     ensureLevels(totalN);\n-\n-    final float[] auxBuf = new float[k * 2];\n+final float[] auxBuf = new float[k * 2];\n     long bp = other.bitPattern;\n     for (int level = 0; bp != 0L; level++, bp >>>= 1) {\n       if ((bp & 1L) != 0L) {\n-        inPlacePropagationMerge(level, other.combinedBuffer,\n-            k * (level + 2), auxBuf, 0);\n+        inPlacePropagationMerge(level, other.combinedBuffer, k * (level + 2), auxBuf, 0);\n       }\n     }\n \n@@ -251,19 +247,17 @@ public class HeapQuantileSketch extends QuantileSketch {\n     this.weightsArr = null;\n   }\n \n-  private void inPlacePropagationMerge(int beginLevel, final float[] buf, int bufStart,\n-      final float[] auxBuf, int auxBufStart) {\n-    final float[] levelsArr = combinedBuffer;\n+  private void inPlacePropagationMerge(int beginLevel, final float[] buf, int bufStart, final float[] auxBuf, int auxBufStart) {\n+  final float[] levelsArr = combinedBuffer;\n     int endLevel = beginLevel;\n-    long tmp = bitPattern >>> beginLevel;\n+    long tmp = bitPattern>>> beginLevel;\n     while ((tmp & 1) != 0) {\n       tmp >>>= 1;\n       endLevel++;\n     }\n     System.arraycopy(buf, bufStart, levelsArr, k * (endLevel + 2), k);\n-    SketchUtils\n-        .levelwisePropagation(bitPattern, k, beginLevel, endLevel, auxBuf, auxBufStart, levelsArr);\n-    bitPattern += 1L << beginLevel;\n+    SketchUtils.levelwisePropagation(bitPattern, k, beginLevel, endLevel, auxBuf, auxBufStart, levelsArr);\n+bitPattern += 1L << beginLevel;\n   }\n \n   public void copy(HeapQuantileSketch other) {\n@@ -279,7 +273,7 @@ public class HeapQuantileSketch extends QuantileSketch {\n     } else {\n       System.arraycopy(other.combinedBuffer, 0,\n           this.combinedBuffer, 0, other.combinedBufferCapacity);\n-    }\n+  }\n     this.baseBufferCount = other.baseBufferCount;\n     this.bitPattern = other.bitPattern;\n     if (other.samplesArr != null && other.weightsArr != null) {\n@@ -455,4 +449,4 @@ public class HeapQuantileSketch extends QuantileSketch {\n     this.bitPattern = ois.readLong();\n   }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 18
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "155",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 103).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "259",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 128).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "268",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 106).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "283",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 109).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Angel-ML-angel/errored/1/159/HeapQuantileSketch.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Angel-ML-angel/codebuff/159/HeapQuantileSketch.java\nindex 735ed2b2630..a3e1b8929a8 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Angel-ML-angel/errored/1/159/HeapQuantileSketch.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Angel-ML-angel/codebuff/159/HeapQuantileSketch.java\n@@ -18,7 +18,6 @@\n \n package com.tencent.angel.spark.ml.tree.sketch;\n \n-\n import java.io.IOException;\n import java.io.ObjectInputStream;\n import java.io.ObjectOutputStream;\n@@ -28,9 +27,11 @@ import java.util.Arrays;\n /**\n  * Implementation of quantile sketch on the Java heap bashed on `DataSketches` of Yahoo!\n  */\n+\n public class HeapQuantileSketch extends QuantileSketch {\n \n   private int k; // parameter that controls space usage\n+\n   public static final int DEFAULT_K = 128;\n \n   /**\n@@ -79,9 +80,9 @@ public class HeapQuantileSketch extends QuantileSketch {\n     if (estimateN < 0) {\n       combinedBufferCapacity = Math.min(MIN_BASE_BUF_SIZE, k * 2);\n     } else if (estimateN < k * 2) {\n-      combinedBufferCapacity = k * 4;\n+             combinedBufferCapacity = k * 4;\n     } else {\n-      combinedBufferCapacity = SketchUtils.needBufferCapacity(k, estimateN);\n+             combinedBufferCapacity = SketchUtils.needBufferCapacity(k, estimateN);\n     }\n     combinedBuffer = new float[combinedBufferCapacity];\n     baseBufferCount = 0;\n@@ -99,7 +100,6 @@ public class HeapQuantileSketch extends QuantileSketch {\n     }\n     maxValue = Math.max(maxValue, value);\n     minValue = Math.min(minValue, value);\n-\n     if (baseBufferCount + 1 > combinedBufferCapacity) {\n       ensureBaseBuffer();\n     }\n@@ -116,6 +116,7 @@ public class HeapQuantileSketch extends QuantileSketch {\n     if (oldSize >= k * 2) {\n       throw new QuantileSketchException(\"Buffer over size\");\n     }\n+\n     int newSize = Math.max(Math.min(k * 2, oldSize * 2), 1);\n     combinedBufferCapacity = newSize;\n     combinedBuffer = Arrays.copyOf(baseBuffer, newSize);\n@@ -126,6 +127,7 @@ public class HeapQuantileSketch extends QuantileSketch {\n     if (spaceNeeded <= combinedBufferCapacity) {\n       return;\n     }\n+\n     final float[] baseBuffer = combinedBuffer;\n     combinedBuffer = Arrays.copyOf(baseBuffer, spaceNeeded);\n     combinedBufferCapacity = spaceNeeded;\n@@ -133,6 +135,7 @@ public class HeapQuantileSketch extends QuantileSketch {\n \n   private void fullBaseBufferPropagation() {\n     ensureLevels(n);\n+\n     final float[] baseBuffer = combinedBuffer;\n     Arrays.sort(baseBuffer, 0, baseBufferCount);\n     inPlacePropagationUpdate(0, baseBuffer, 0);\n@@ -149,19 +152,18 @@ public class HeapQuantileSketch extends QuantileSketch {\n       endLevel++;\n     }\n     SketchUtils.compactBuffer(buf, bufBeginPos, levelsArr, (endLevel + 2) * k, k);\n-    SketchUtils\n-        .levelwisePropagation(bitPattern, k, beginLevel, endLevel, buf, bufBeginPos, levelsArr);\n+    SketchUtils.levelwisePropagation(bitPattern, k, beginLevel, endLevel, buf, bufBeginPos, levelsArr);\n     bitPattern += 1L << beginLevel;\n   }\n \n   public void makeSummary() {\n     int baseBufferItems = (int) (n % (k * 2));\n     SketchUtils.checkBitPattern(bitPattern, n, k);\n+\n     int validLevels = Long.bitCount(bitPattern);\n     int numSamples = baseBufferItems + validLevels * k;\n     samplesArr = new float[numSamples];\n     weightsArr = new long[numSamples + 1];\n-\n     copyBuf2Arr(numSamples);\n     SketchUtils.blockyMergeSort(samplesArr, weightsArr, numSamples, k);\n \n@@ -192,6 +194,7 @@ public class HeapQuantileSketch extends QuantileSketch {\n     }\n \n     // copy baseBuffer\n+\n     int startBlk = cur;\n     for (int i = 0; i < baseBufferCount; i++) {\n       samplesArr[cur] = combinedBuffer[i];\n@@ -210,8 +213,7 @@ public class HeapQuantileSketch extends QuantileSketch {\n     if (other instanceof HeapQuantileSketch) {\n       merge((HeapQuantileSketch) other);\n     } else {\n-      throw new QuantileSketchException(\"Cannot merge different \" +\n-          \"kinds of quantile sketches\");\n+      throw new QuantileSketchException(\"Cannot merge different \" + \"kinds of quantile sketches\");\n     }\n   }\n \n@@ -219,6 +221,7 @@ public class HeapQuantileSketch extends QuantileSketch {\n     if (other == null || other.isEmpty()) {\n       return;\n     }\n+\n     if (other.k != this.k) {\n       throw new QuantileSketchException(\"Merge sketches with different k\");\n     }\n@@ -229,6 +232,7 @@ public class HeapQuantileSketch extends QuantileSketch {\n     }\n \n     // merge two non-empty quantile sketches\n+\n     long totalN = this.n + other.n;\n     for (int i = 0; i < other.baseBufferCount; i++) {\n       update(other.combinedBuffer[i]);\n@@ -239,11 +243,12 @@ public class HeapQuantileSketch extends QuantileSketch {\n     long bp = other.bitPattern;\n     for (int level = 0; bp != 0L; level++, bp >>>= 1) {\n       if ((bp & 1L) != 0L) {\n-        inPlacePropagationMerge(level, other.combinedBuffer,\n-            k * (level + 2), auxBuf, 0);\n+        inPlacePropagationMerge(level, other.combinedBuffer, k * (level + 2), auxBuf, 0);\n       }\n     }\n \n+\n+\n     this.n = totalN;\n     this.maxValue = Math.max(this.maxValue, other.maxValue);\n     this.minValue = Math.min(this.minValue, other.minValue);\n@@ -251,8 +256,7 @@ public class HeapQuantileSketch extends QuantileSketch {\n     this.weightsArr = null;\n   }\n \n-  private void inPlacePropagationMerge(int beginLevel, final float[] buf, int bufStart,\n-      final float[] auxBuf, int auxBufStart) {\n+  private void inPlacePropagationMerge(int beginLevel, final float[] buf, int bufStart, final float[] auxBuf, int auxBufStart) {\n     final float[] levelsArr = combinedBuffer;\n     int endLevel = beginLevel;\n     long tmp = bitPattern >>> beginLevel;\n@@ -261,8 +265,7 @@ public class HeapQuantileSketch extends QuantileSketch {\n       endLevel++;\n     }\n     System.arraycopy(buf, bufStart, levelsArr, k * (endLevel + 2), k);\n-    SketchUtils\n-        .levelwisePropagation(bitPattern, k, beginLevel, endLevel, auxBuf, auxBufStart, levelsArr);\n+    SketchUtils.levelwisePropagation(bitPattern, k, beginLevel, endLevel, auxBuf, auxBufStart, levelsArr);\n     bitPattern += 1L << beginLevel;\n   }\n \n@@ -277,9 +280,11 @@ public class HeapQuantileSketch extends QuantileSketch {\n       this.combinedBufferCapacity = other.combinedBufferCapacity;\n       this.combinedBuffer = other.combinedBuffer.clone();\n     } else {\n-      System.arraycopy(other.combinedBuffer, 0,\n-          this.combinedBuffer, 0, other.combinedBufferCapacity);\n+             System.arraycopy(other.combinedBuffer, 0, this.combinedBuffer, 0, other.combinedBufferCapacity);\n     }\n+\n+\n+\n     this.baseBufferCount = other.baseBufferCount;\n     this.bitPattern = other.bitPattern;\n     if (other.samplesArr != null && other.weightsArr != null) {\n@@ -302,7 +307,7 @@ public class HeapQuantileSketch extends QuantileSketch {\n     if (fraction == 0.0f) {\n       return minValue;\n     } else if (fraction == 1.0f) {\n-      return maxValue;\n+             return maxValue;\n     } else {\n       return getQuantileFromArr(fraction);\n     }\n@@ -314,7 +319,6 @@ public class HeapQuantileSketch extends QuantileSketch {\n     if (samplesArr == null || weightsArr == null) {\n       makeSummary();\n     }\n-\n     float[] res = new float[fractions.length];\n     if (samplesArr.length == 0) {\n       Arrays.fill(res, Float.NaN);\n@@ -325,9 +329,9 @@ public class HeapQuantileSketch extends QuantileSketch {\n       if (fractions[i] == 0.0f) {\n         res[i] = minValue;\n       } else if (fractions[i] == 1.0f) {\n-        res[i] = maxValue;\n+               res[i] = maxValue;\n       } else {\n-        res[i] = getQuantileFromArr(fractions[i]);\n+               res[i] = getQuantileFromArr(fractions[i]);\n       }\n     }\n     return res;\n@@ -339,21 +343,22 @@ public class HeapQuantileSketch extends QuantileSketch {\n     if (samplesArr == null || weightsArr == null) {\n       makeSummary();\n     }\n-\n     float[] res = new float[evenPartition];\n     if (samplesArr.length == 0) {\n       Arrays.fill(res, Float.NaN);\n       return res;\n     }\n-\n     res[0] = minValue;\n+\n     int index = 0;\n     float curFrac = 0.0f;\n     float step = 1.0f / evenPartition;\n     for (int i = 1; i < evenPartition; i++) {\n       curFrac += step;\n+\n       long rank = (long) (n * curFrac);\n       rank = Math.min(rank, n - 1);\n+\n       int left = index, right = weightsArr.length - 1;\n       while (left + 1 < right) {\n         int mid = left + ((right - left) >> 1);\n@@ -374,6 +379,7 @@ public class HeapQuantileSketch extends QuantileSketch {\n     if (rank == n) {\n       n--;\n     }\n+\n     int left = 0, right = weightsArr.length - 1;\n     while (left + 1 < right) {\n       int mid = left + ((right - left) >> 1);\n@@ -396,6 +402,7 @@ public class HeapQuantileSketch extends QuantileSketch {\n       if (samplesArr[i] < samplesArr[i - 1]) {\n         throw new RuntimeException(String.format(\"%f > %f\", samplesArr[i - 1], samplesArr[i]));\n       }\n+\n       if (samplesArr[i] != samplesArr[i - 1]) {\n         cnt++;\n         if (cnt++ > maxItemNums) {\n@@ -403,9 +410,11 @@ public class HeapQuantileSketch extends QuantileSketch {\n         }\n       }\n     }\n+\n     if (cnt != samplesArr.length) {\n       float[] res = new float[cnt];\n       res[0] = samplesArr[0];\n+\n       int index = 1;\n       for (int i = 1; i < samplesArr.length; i++) {\n         if (samplesArr[i] != samplesArr[i - 1]) {\n@@ -429,8 +438,8 @@ public class HeapQuantileSketch extends QuantileSketch {\n     oos.writeFloat(maxValue);\n     oos.writeInt(k);\n     oos.writeInt(combinedBufferCapacity);\n-    int size = Math.min(combinedBufferCapacity,\n-        SketchUtils.needBufferCapacity(k, n));\n+\n+    int size = Math.min(combinedBufferCapacity, SketchUtils.needBufferCapacity(k, n));\n     for (int i = 0; i < size; i++) {\n       oos.writeFloat(combinedBuffer[i]);\n     }\n@@ -446,13 +455,16 @@ public class HeapQuantileSketch extends QuantileSketch {\n     this.k = ois.readInt();\n     this.combinedBufferCapacity = ois.readInt();\n     this.combinedBuffer = new float[combinedBufferCapacity];\n-    int size = Math.min(combinedBufferCapacity,\n-        SketchUtils.needBufferCapacity(k, n));\n+\n+    int size = Math.min(combinedBufferCapacity, SketchUtils.needBufferCapacity(k, n));\n     for (int i = 0; i < size; i++) {\n       this.combinedBuffer[i] = ois.readFloat();\n     }\n+\n+\n+\n     this.baseBufferCount = ois.readInt();\n     this.bitPattern = ois.readLong();\n   }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 52
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ],
    "repaired_by": [],
    "not_repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}