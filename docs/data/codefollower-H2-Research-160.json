{
    "project_name": "codefollower-H2-Research",
    "error_id": "160",
    "information": {
        "errors": [
            {
                "line": "94",
                "column": "55",
                "severity": "warning",
                "message": "'typecast' is not followed by whitespace.",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAfterCheck"
            }
        ]
    },
    "source_code": "    private static final int LOCAL_DATE = 133;\n    private static final int LOCAL_TIMESTAMP = 134;\n    private static final byte CUSTOM_DATA_TYPE = (byte)135;\n\n    private static final long MILLIS_PER_MINUTE = 1000 * 60;\n",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/160/Data.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler/160/Data.java\nindex fc441d1684e..7f7a60e5ae7 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/160/Data.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler/160/Data.java\n@@ -91,7 +91,7 @@ public class Data {\n     private static final int LOCAL_TIME = 132;\n     private static final int LOCAL_DATE = 133;\n     private static final int LOCAL_TIMESTAMP = 134;\n-    private static final byte CUSTOM_DATA_TYPE = (byte)135;\n+    private static final byte CUSTOM_DATA_TYPE = (byte) 135;\n \n     private static final long MILLIS_PER_MINUTE = 1000 * 60;\n \n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/160/Data.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/160/Data.java\nindex fc441d1684e..e50ad5731b0 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/160/Data.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/160/Data.java\n@@ -6,6 +6,7 @@\n  * The variable size number format code is a port from SQLite,\n  * but stored in reverse order (least significant bits in the first byte).\n  */\n+\n package org.h2.store;\n \n import java.io.IOException;\n@@ -18,6 +19,7 @@ import java.sql.ResultSetMetaData;\n import java.sql.SQLException;\n import java.sql.Timestamp;\n import java.util.Arrays;\n+\n import org.h2.api.ErrorCode;\n import org.h2.api.IntervalQualifier;\n import org.h2.engine.Constants;\n@@ -65,1318 +67,1318 @@ import org.h2.value.ValueUuid;\n  */\n public class Data {\n \n-    /**\n-     * The length of an integer value.\n-     */\n-    public static final int LENGTH_INT = 4;\n+  /**\n+   * The length of an integer value.\n+   */\n+  public static final int LENGTH_INT = 4;\n \n-    /**\n-     * The length of a long value.\n-     */\n-    private static final int LENGTH_LONG = 8;\n+  /**\n+   * The length of a long value.\n+   */\n+  private static final int LENGTH_LONG = 8;\n \n-    private static final int INT_0_15 = 32;\n-    private static final int LONG_0_7 = 48;\n-    private static final int DECIMAL_0_1 = 56;\n-    private static final int DECIMAL_SMALL_0 = 58;\n-    private static final int DECIMAL_SMALL = 59;\n-    private static final int DOUBLE_0_1 = 60;\n-    private static final int FLOAT_0_1 = 62;\n-    private static final int BOOLEAN_FALSE = 64;\n-    private static final int BOOLEAN_TRUE = 65;\n-    private static final int INT_NEG = 66;\n-    private static final int LONG_NEG = 67;\n-    private static final int STRING_0_31 = 68;\n-    private static final int BYTES_0_31 = 100;\n-    private static final int LOCAL_TIME = 132;\n-    private static final int LOCAL_DATE = 133;\n-    private static final int LOCAL_TIMESTAMP = 134;\n-    private static final byte CUSTOM_DATA_TYPE = (byte)135;\n+  private static final int INT_0_15 = 32;\n+  private static final int LONG_0_7 = 48;\n+  private static final int DECIMAL_0_1 = 56;\n+  private static final int DECIMAL_SMALL_0 = 58;\n+  private static final int DECIMAL_SMALL = 59;\n+  private static final int DOUBLE_0_1 = 60;\n+  private static final int FLOAT_0_1 = 62;\n+  private static final int BOOLEAN_FALSE = 64;\n+  private static final int BOOLEAN_TRUE = 65;\n+  private static final int INT_NEG = 66;\n+  private static final int LONG_NEG = 67;\n+  private static final int STRING_0_31 = 68;\n+  private static final int BYTES_0_31 = 100;\n+  private static final int LOCAL_TIME = 132;\n+  private static final int LOCAL_DATE = 133;\n+  private static final int LOCAL_TIMESTAMP = 134;\n+  private static final byte CUSTOM_DATA_TYPE = (byte) 135;\n \n-    private static final long MILLIS_PER_MINUTE = 1000 * 60;\n+  private static final long MILLIS_PER_MINUTE = 1000 * 60;\n \n-    /**\n-     * The data itself.\n-     */\n-    private byte[] data;\n+  /**\n+   * The data itself.\n+   */\n+  private byte[] data;\n \n-    /**\n-     * The current write or read position.\n-     */\n-    private int pos;\n+  /**\n+   * The current write or read position.\n+   */\n+  private int pos;\n \n-    /**\n-     * The data handler responsible for lob objects.\n-     */\n-    private final DataHandler handler;\n+  /**\n+   * The data handler responsible for lob objects.\n+   */\n+  private final DataHandler handler;\n \n-    private Data(DataHandler handler, byte[] data) {\n-        this.handler = handler;\n-        this.data = data;\n-    }\n+  private Data(DataHandler handler, byte[] data) {\n+    this.handler = handler;\n+    this.data = data;\n+  }\n \n-    /**\n-     * Update an integer at the given position.\n-     * The current position is not change.\n-     *\n-     * @param pos the position\n-     * @param x the value\n-     */\n-    public void setInt(int pos, int x) {\n-        Bits.writeInt(data, pos, x);\n-    }\n+  /**\n+   * Update an integer at the given position.\n+   * The current position is not change.\n+   *\n+   * @param pos the position\n+   * @param x   the value\n+   */\n+  public void setInt(int pos, int x) {\n+    Bits.writeInt(data, pos, x);\n+  }\n \n-    /**\n-     * Write an integer at the current position.\n-     * The current position is incremented.\n-     *\n-     * @param x the value\n-     */\n-    public void writeInt(int x) {\n-        Bits.writeInt(data, pos, x);\n-        pos += 4;\n-    }\n+  /**\n+   * Write an integer at the current position.\n+   * The current position is incremented.\n+   *\n+   * @param x the value\n+   */\n+  public void writeInt(int x) {\n+    Bits.writeInt(data, pos, x);\n+    pos += 4;\n+  }\n \n-    /**\n-     * Read an integer at the current position.\n-     * The current position is incremented.\n-     *\n-     * @return the value\n-     */\n-    public int readInt() {\n-        int x = Bits.readInt(data, pos);\n-        pos += 4;\n-        return x;\n-    }\n+  /**\n+   * Read an integer at the current position.\n+   * The current position is incremented.\n+   *\n+   * @return the value\n+   */\n+  public int readInt() {\n+    int x = Bits.readInt(data, pos);\n+    pos += 4;\n+    return x;\n+  }\n \n-    /**\n-     * Get the length of a String. This includes the bytes required to encode\n-     * the length.\n-     *\n-     * @param s the string\n-     * @return the number of bytes required\n-     */\n-    public static int getStringLen(String s) {\n-        int len = s.length();\n-        return getStringWithoutLengthLen(s, len) + getVarIntLen(len);\n-    }\n+  /**\n+   * Get the length of a String. This includes the bytes required to encode\n+   * the length.\n+   *\n+   * @param s the string\n+   * @return the number of bytes required\n+   */\n+  public static int getStringLen(String s) {\n+    int len = s.length();\n+    return getStringWithoutLengthLen(s, len) + getVarIntLen(len);\n+  }\n \n-    /**\n-     * Calculate the length of String, excluding the bytes required to encode\n-     * the length.\n-     * <p>\n-     * For performance reasons the internal representation of a String is\n-     * similar to UTF-8, but not exactly UTF-8.\n-     *\n-     * @param s the string\n-     * @param len the length of the string\n-     * @return the number of bytes required\n-     */\n-    private static int getStringWithoutLengthLen(String s, int len) {\n-        int plus = 0;\n-        for (int i = 0; i < len; i++) {\n-            char c = s.charAt(i);\n-            if (c >= 0x800) {\n-                plus += 2;\n-            } else if (c >= 0x80) {\n-                plus++;\n-            }\n-        }\n-        return len + plus;\n+  /**\n+   * Calculate the length of String, excluding the bytes required to encode\n+   * the length.\n+   * <p>\n+   * For performance reasons the internal representation of a String is\n+   * similar to UTF-8, but not exactly UTF-8.\n+   *\n+   * @param s   the string\n+   * @param len the length of the string\n+   * @return the number of bytes required\n+   */\n+  private static int getStringWithoutLengthLen(String s, int len) {\n+    int plus = 0;\n+    for (int i = 0; i < len; i++) {\n+      char c = s.charAt(i);\n+      if (c >= 0x800) {\n+        plus += 2;\n+      } else if (c >= 0x80) {\n+        plus++;\n+      }\n     }\n+    return len + plus;\n+  }\n \n-    /**\n-     * Read a String value.\n-     * The current position is incremented.\n-     *\n-     * @return the value\n-     */\n-    public String readString() {\n-        int len = readVarInt();\n-        return readString(len);\n-    }\n+  /**\n+   * Read a String value.\n+   * The current position is incremented.\n+   *\n+   * @return the value\n+   */\n+  public String readString() {\n+    int len = readVarInt();\n+    return readString(len);\n+  }\n \n-    /**\n-     * Read a String from the byte array.\n-     * <p>\n-     * For performance reasons the internal representation of a String is\n-     * similar to UTF-8, but not exactly UTF-8.\n-     *\n-     * @param len the length of the resulting string\n-     * @return the String\n-     */\n-    private String readString(int len) {\n-        byte[] buff = data;\n-        int p = pos;\n-        char[] chars = new char[len];\n-        for (int i = 0; i < len; i++) {\n-            int x = buff[p++] & 0xff;\n-            if (x < 0x80) {\n-                chars[i] = (char) x;\n-            } else if (x >= 0xe0) {\n-                chars[i] = (char) (((x & 0xf) << 12) +\n-                        ((buff[p++] & 0x3f) << 6) +\n-                        (buff[p++] & 0x3f));\n-            } else {\n-                chars[i] = (char) (((x & 0x1f) << 6) +\n-                        (buff[p++] & 0x3f));\n-            }\n-        }\n-        pos = p;\n-        return new String(chars);\n+  /**\n+   * Read a String from the byte array.\n+   * <p>\n+   * For performance reasons the internal representation of a String is\n+   * similar to UTF-8, but not exactly UTF-8.\n+   *\n+   * @param len the length of the resulting string\n+   * @return the String\n+   */\n+  private String readString(int len) {\n+    byte[] buff = data;\n+    int p = pos;\n+    char[] chars = new char[len];\n+    for (int i = 0; i < len; i++) {\n+      int x = buff[p++] & 0xff;\n+      if (x < 0x80) {\n+        chars[i] = (char) x;\n+      } else if (x >= 0xe0) {\n+        chars[i] = (char) (((x & 0xf) << 12) +\n+            ((buff[p++] & 0x3f) << 6) +\n+            (buff[p++] & 0x3f));\n+      } else {\n+        chars[i] = (char) (((x & 0x1f) << 6) +\n+            (buff[p++] & 0x3f));\n+      }\n     }\n+    pos = p;\n+    return new String(chars);\n+  }\n \n-    /**\n-     * Write a String.\n-     * The current position is incremented.\n-     *\n-     * @param s the value\n-     */\n-    public void writeString(String s) {\n-        int len = s.length();\n-        writeVarInt(len);\n-        writeStringWithoutLength(s, len);\n-    }\n+  /**\n+   * Write a String.\n+   * The current position is incremented.\n+   *\n+   * @param s the value\n+   */\n+  public void writeString(String s) {\n+    int len = s.length();\n+    writeVarInt(len);\n+    writeStringWithoutLength(s, len);\n+  }\n \n-    /**\n-     * Write a String.\n-     * <p>\n-     * For performance reasons the internal representation of a String is\n-     * similar to UTF-8, but not exactly UTF-8.\n-     *\n-     * @param s the string\n-     * @param len the number of characters to write\n-     */\n-    private void writeStringWithoutLength(String s, int len) {\n-        int p = pos;\n-        byte[] buff = data;\n-        for (int i = 0; i < len; i++) {\n-            int c = s.charAt(i);\n-            if (c < 0x80) {\n-                buff[p++] = (byte) c;\n-            } else if (c >= 0x800) {\n-                buff[p++] = (byte) (0xe0 | (c >> 12));\n-                buff[p++] = (byte) (((c >> 6) & 0x3f));\n-                buff[p++] = (byte) (c & 0x3f);\n-            } else {\n-                buff[p++] = (byte) (0xc0 | (c >> 6));\n-                buff[p++] = (byte) (c & 0x3f);\n-            }\n-        }\n-        pos = p;\n+  /**\n+   * Write a String.\n+   * <p>\n+   * For performance reasons the internal representation of a String is\n+   * similar to UTF-8, but not exactly UTF-8.\n+   *\n+   * @param s   the string\n+   * @param len the number of characters to write\n+   */\n+  private void writeStringWithoutLength(String s, int len) {\n+    int p = pos;\n+    byte[] buff = data;\n+    for (int i = 0; i < len; i++) {\n+      int c = s.charAt(i);\n+      if (c < 0x80) {\n+        buff[p++] = (byte) c;\n+      } else if (c >= 0x800) {\n+        buff[p++] = (byte) (0xe0 | (c >> 12));\n+        buff[p++] = (byte) (((c >> 6) & 0x3f));\n+        buff[p++] = (byte) (c & 0x3f);\n+      } else {\n+        buff[p++] = (byte) (0xc0 | (c >> 6));\n+        buff[p++] = (byte) (c & 0x3f);\n+      }\n     }\n+    pos = p;\n+  }\n \n-    private void writeStringWithoutLength(char[] chars, int len) {\n-        int p = pos;\n-        byte[] buff = data;\n-        for (int i = 0; i < len; i++) {\n-            int c = chars[i];\n-            if (c < 0x80) {\n-                buff[p++] = (byte) c;\n-            } else if (c >= 0x800) {\n-                buff[p++] = (byte) (0xe0 | (c >> 12));\n-                buff[p++] = (byte) (((c >> 6) & 0x3f));\n-                buff[p++] = (byte) (c & 0x3f);\n-            } else {\n-                buff[p++] = (byte) (0xc0 | (c >> 6));\n-                buff[p++] = (byte) (c & 0x3f);\n-            }\n-        }\n-        pos = p;\n+  private void writeStringWithoutLength(char[] chars, int len) {\n+    int p = pos;\n+    byte[] buff = data;\n+    for (int i = 0; i < len; i++) {\n+      int c = chars[i];\n+      if (c < 0x80) {\n+        buff[p++] = (byte) c;\n+      } else if (c >= 0x800) {\n+        buff[p++] = (byte) (0xe0 | (c >> 12));\n+        buff[p++] = (byte) (((c >> 6) & 0x3f));\n+        buff[p++] = (byte) (c & 0x3f);\n+      } else {\n+        buff[p++] = (byte) (0xc0 | (c >> 6));\n+        buff[p++] = (byte) (c & 0x3f);\n+      }\n     }\n+    pos = p;\n+  }\n \n-    /**\n-     * Create a new buffer for the given handler. The\n-     * handler will decide what type of buffer is created.\n-     *\n-     * @param handler the data handler\n-     * @param capacity the initial capacity of the buffer\n-     * @return the buffer\n-     */\n-    public static Data create(DataHandler handler, int capacity) {\n-        return new Data(handler, new byte[capacity]);\n-    }\n+  /**\n+   * Create a new buffer for the given handler. The\n+   * handler will decide what type of buffer is created.\n+   *\n+   * @param handler  the data handler\n+   * @param capacity the initial capacity of the buffer\n+   * @return the buffer\n+   */\n+  public static Data create(DataHandler handler, int capacity) {\n+    return new Data(handler, new byte[capacity]);\n+  }\n \n-    /**\n-     * Create a new buffer using the given data for the given handler. The\n-     * handler will decide what type of buffer is created.\n-     *\n-     * @param handler the data handler\n-     * @param buff the data\n-     * @return the buffer\n-     */\n-    public static Data create(DataHandler handler, byte[] buff) {\n-        return new Data(handler, buff);\n-    }\n+  /**\n+   * Create a new buffer using the given data for the given handler. The\n+   * handler will decide what type of buffer is created.\n+   *\n+   * @param handler the data handler\n+   * @param buff    the data\n+   * @return the buffer\n+   */\n+  public static Data create(DataHandler handler, byte[] buff) {\n+    return new Data(handler, buff);\n+  }\n \n-    /**\n-     * Get the current write position of this buffer, which is the current\n-     * length.\n-     *\n-     * @return the length\n-     */\n-    public int length() {\n-        return pos;\n-    }\n+  /**\n+   * Get the current write position of this buffer, which is the current\n+   * length.\n+   *\n+   * @return the length\n+   */\n+  public int length() {\n+    return pos;\n+  }\n \n-    /**\n-     * Get the byte array used for this page.\n-     *\n-     * @return the byte array\n-     */\n-    public byte[] getBytes() {\n-        return data;\n-    }\n+  /**\n+   * Get the byte array used for this page.\n+   *\n+   * @return the byte array\n+   */\n+  public byte[] getBytes() {\n+    return data;\n+  }\n \n-    /**\n-     * Set the position to 0.\n-     */\n-    public void reset() {\n-        pos = 0;\n-    }\n+  /**\n+   * Set the position to 0.\n+   */\n+  public void reset() {\n+    pos = 0;\n+  }\n \n-    /**\n-     * Append a number of bytes to this buffer.\n-     *\n-     * @param buff the data\n-     * @param off the offset in the data\n-     * @param len the length in bytes\n-     */\n-    public void write(byte[] buff, int off, int len) {\n-        System.arraycopy(buff, off, data, pos, len);\n-        pos += len;\n-    }\n+  /**\n+   * Append a number of bytes to this buffer.\n+   *\n+   * @param buff the data\n+   * @param off  the offset in the data\n+   * @param len  the length in bytes\n+   */\n+  public void write(byte[] buff, int off, int len) {\n+    System.arraycopy(buff, off, data, pos, len);\n+    pos += len;\n+  }\n \n-    /**\n-     * Copy a number of bytes to the given buffer from the current position. The\n-     * current position is incremented accordingly.\n-     *\n-     * @param buff the output buffer\n-     * @param off the offset in the output buffer\n-     * @param len the number of bytes to copy\n-     */\n-    public void read(byte[] buff, int off, int len) {\n-        System.arraycopy(data, pos, buff, off, len);\n-        pos += len;\n-    }\n+  /**\n+   * Copy a number of bytes to the given buffer from the current position. The\n+   * current position is incremented accordingly.\n+   *\n+   * @param buff the output buffer\n+   * @param off  the offset in the output buffer\n+   * @param len  the number of bytes to copy\n+   */\n+  public void read(byte[] buff, int off, int len) {\n+    System.arraycopy(data, pos, buff, off, len);\n+    pos += len;\n+  }\n \n-    /**\n-     * Append one single byte.\n-     *\n-     * @param x the value\n-     */\n-    public void writeByte(byte x) {\n-        data[pos++] = x;\n-    }\n+  /**\n+   * Append one single byte.\n+   *\n+   * @param x the value\n+   */\n+  public void writeByte(byte x) {\n+    data[pos++] = x;\n+  }\n \n-    /**\n-     * Read one single byte.\n-     *\n-     * @return the value\n-     */\n-    public byte readByte() {\n-        return data[pos++];\n-    }\n+  /**\n+   * Read one single byte.\n+   *\n+   * @return the value\n+   */\n+  public byte readByte() {\n+    return data[pos++];\n+  }\n \n-    /**\n-     * Read a long value. This method reads two int values and combines them.\n-     *\n-     * @return the long value\n-     */\n-    public long readLong() {\n-        long x = Bits.readLong(data, pos);\n-        pos += 8;\n-        return x;\n-    }\n+  /**\n+   * Read a long value. This method reads two int values and combines them.\n+   *\n+   * @return the long value\n+   */\n+  public long readLong() {\n+    long x = Bits.readLong(data, pos);\n+    pos += 8;\n+    return x;\n+  }\n \n-    /**\n-     * Append a long value. This method writes two int values.\n-     *\n-     * @param x the value\n-     */\n-    public void writeLong(long x) {\n-        Bits.writeLong(data, pos, x);\n-        pos += 8;\n-    }\n+  /**\n+   * Append a long value. This method writes two int values.\n+   *\n+   * @param x the value\n+   */\n+  public void writeLong(long x) {\n+    Bits.writeLong(data, pos, x);\n+    pos += 8;\n+  }\n \n-    /**\n-     * Append a value.\n-     *\n-     * @param v the value\n-     */\n-    public void writeValue(Value v) {\n-        int start = pos;\n-        if (v == ValueNull.INSTANCE) {\n-            data[pos++] = 0;\n-            return;\n-        }\n-        int type = v.getType();\n-        switch (type) {\n-        case Value.BOOLEAN:\n-            writeByte((byte) (v.getBoolean() ? BOOLEAN_TRUE : BOOLEAN_FALSE));\n-            break;\n-        case Value.BYTE:\n-            writeByte((byte) type);\n-            writeByte(v.getByte());\n-            break;\n-        case Value.SHORT:\n-            writeByte((byte) type);\n-            writeShortInt(v.getShort());\n-            break;\n-        case Value.ENUM:\n-        case Value.INT: {\n-            int x = v.getInt();\n-            if (x < 0) {\n-                writeByte((byte) INT_NEG);\n-                writeVarInt(-x);\n-            } else if (x < 16) {\n-                writeByte((byte) (INT_0_15 + x));\n-            } else {\n-                writeByte((byte) type);\n-                writeVarInt(x);\n-            }\n-            break;\n-        }\n-        case Value.LONG: {\n-            long x = v.getLong();\n-            if (x < 0) {\n-                writeByte((byte) LONG_NEG);\n-                writeVarLong(-x);\n-            } else if (x < 8) {\n-                writeByte((byte) (LONG_0_7 + x));\n-            } else {\n-                writeByte((byte) type);\n-                writeVarLong(x);\n-            }\n-            break;\n-        }\n-        case Value.DECIMAL: {\n-            BigDecimal x = v.getBigDecimal();\n-            if (BigDecimal.ZERO.equals(x)) {\n-                writeByte((byte) DECIMAL_0_1);\n-            } else if (BigDecimal.ONE.equals(x)) {\n-                writeByte((byte) (DECIMAL_0_1 + 1));\n-            } else {\n-                int scale = x.scale();\n-                BigInteger b = x.unscaledValue();\n-                int bits = b.bitLength();\n-                if (bits <= 63) {\n-                    if (scale == 0) {\n-                        writeByte((byte) DECIMAL_SMALL_0);\n-                        writeVarLong(b.longValue());\n-                    } else {\n-                        writeByte((byte) DECIMAL_SMALL);\n-                        writeVarInt(scale);\n-                        writeVarLong(b.longValue());\n-                    }\n-                } else {\n-                    writeByte((byte) type);\n-                    writeVarInt(scale);\n-                    byte[] bytes = b.toByteArray();\n-                    writeVarInt(bytes.length);\n-                    write(bytes, 0, bytes.length);\n-                }\n-            }\n-            break;\n-        }\n-        case Value.TIME:\n-            writeByte((byte) type);\n-            writeVarLong(DateTimeUtils.getTimeLocalWithoutDst(v.getTime()));\n-            break;\n-        case Value.DATE: {\n-            writeByte((byte) type);\n-            long x = DateTimeUtils.getTimeLocalWithoutDst(v.getDate());\n-            writeVarLong(x / MILLIS_PER_MINUTE);\n-            break;\n-        }\n-        case Value.TIMESTAMP: {\n-            Timestamp ts = v.getTimestamp();\n-            writeByte((byte) type);\n-            writeVarLong(DateTimeUtils.getTimeLocalWithoutDst(ts));\n-            writeVarInt(ts.getNanos() % 1_000_000);\n-            break;\n-        }\n-        case Value.TIMESTAMP_TZ: {\n-            ValueTimestampTimeZone ts = (ValueTimestampTimeZone) v;\n-            writeByte((byte) type);\n-            writeVarLong(ts.getDateValue());\n-            writeVarLong(ts.getTimeNanos());\n-            writeVarInt(ts.getTimeZoneOffsetMins());\n-            break;\n-        }\n-        case Value.GEOMETRY:\n-            // fall though\n-        case Value.JAVA_OBJECT: {\n-            writeByte((byte) type);\n-            byte[] b = v.getBytesNoCopy();\n-            int len = b.length;\n-            writeVarInt(len);\n-            write(b, 0, len);\n-            break;\n-        }\n-        case Value.BYTES: {\n-            byte[] b = v.getBytesNoCopy();\n-            int len = b.length;\n-            if (len < 32) {\n-                writeByte((byte) (BYTES_0_31 + len));\n-                write(b, 0, len);\n-            } else {\n-                writeByte((byte) type);\n-                writeVarInt(len);\n-                write(b, 0, len);\n-            }\n-            break;\n-        }\n-        case Value.UUID: {\n-            writeByte((byte) type);\n-            ValueUuid uuid = (ValueUuid) v;\n-            writeLong(uuid.getHigh());\n-            writeLong(uuid.getLow());\n-            break;\n-        }\n-        case Value.STRING: {\n-            String s = v.getString();\n-            int len = s.length();\n-            if (len < 32) {\n-                writeByte((byte) (STRING_0_31 + len));\n-                writeStringWithoutLength(s, len);\n-            } else {\n-                writeByte((byte) type);\n-                writeString(s);\n-            }\n-            break;\n-        }\n-        case Value.STRING_IGNORECASE:\n-        case Value.STRING_FIXED:\n-            writeByte((byte) type);\n-            writeString(v.getString());\n-            break;\n-        case Value.DOUBLE: {\n-            double x = v.getDouble();\n-            if (x == 1.0d) {\n-                writeByte((byte) (DOUBLE_0_1 + 1));\n-            } else {\n-                long d = Double.doubleToLongBits(x);\n-                if (d == ValueDouble.ZERO_BITS) {\n-                    writeByte((byte) DOUBLE_0_1);\n-                } else {\n-                    writeByte((byte) type);\n-                    writeVarLong(Long.reverse(d));\n-                }\n-            }\n-            break;\n-        }\n-        case Value.FLOAT: {\n-            float x = v.getFloat();\n-            if (x == 1.0f) {\n-                writeByte((byte) (FLOAT_0_1 + 1));\n+  /**\n+   * Append a value.\n+   *\n+   * @param v the value\n+   */\n+  public void writeValue(Value v) {\n+    int start = pos;\n+    if (v == ValueNull.INSTANCE) {\n+      data[pos++] = 0;\n+      return;\n+    }\n+    int type = v.getType();\n+    switch (type) {\n+      case Value.BOOLEAN:\n+        writeByte((byte) (v.getBoolean() ? BOOLEAN_TRUE : BOOLEAN_FALSE));\n+        break;\n+      case Value.BYTE:\n+        writeByte((byte) type);\n+        writeByte(v.getByte());\n+        break;\n+      case Value.SHORT:\n+        writeByte((byte) type);\n+        writeShortInt(v.getShort());\n+        break;\n+      case Value.ENUM:\n+      case Value.INT: {\n+        int x = v.getInt();\n+        if (x < 0) {\n+          writeByte((byte) INT_NEG);\n+          writeVarInt(-x);\n+        } else if (x < 16) {\n+          writeByte((byte) (INT_0_15 + x));\n+        } else {\n+          writeByte((byte) type);\n+          writeVarInt(x);\n+        }\n+        break;\n+      }\n+      case Value.LONG: {\n+        long x = v.getLong();\n+        if (x < 0) {\n+          writeByte((byte) LONG_NEG);\n+          writeVarLong(-x);\n+        } else if (x < 8) {\n+          writeByte((byte) (LONG_0_7 + x));\n+        } else {\n+          writeByte((byte) type);\n+          writeVarLong(x);\n+        }\n+        break;\n+      }\n+      case Value.DECIMAL: {\n+        BigDecimal x = v.getBigDecimal();\n+        if (BigDecimal.ZERO.equals(x)) {\n+          writeByte((byte) DECIMAL_0_1);\n+        } else if (BigDecimal.ONE.equals(x)) {\n+          writeByte((byte) (DECIMAL_0_1 + 1));\n+        } else {\n+          int scale = x.scale();\n+          BigInteger b = x.unscaledValue();\n+          int bits = b.bitLength();\n+          if (bits <= 63) {\n+            if (scale == 0) {\n+              writeByte((byte) DECIMAL_SMALL_0);\n+              writeVarLong(b.longValue());\n             } else {\n-                int f = Float.floatToIntBits(x);\n-                if (f == ValueFloat.ZERO_BITS) {\n-                    writeByte((byte) FLOAT_0_1);\n-                } else {\n-                    writeByte((byte) type);\n-                    writeVarInt(Integer.reverse(f));\n-                }\n+              writeByte((byte) DECIMAL_SMALL);\n+              writeVarInt(scale);\n+              writeVarLong(b.longValue());\n             }\n-            break;\n-        }\n-        case Value.BLOB:\n-        case Value.CLOB: {\n+          } else {\n             writeByte((byte) type);\n-            if (v instanceof ValueLob) {\n-                ValueLob lob = (ValueLob) v;\n-                byte[] small = lob.getSmall();\n-                if (small == null) {\n-                    int t = -1;\n-                    if (!lob.isLinkedToTable()) {\n-                        t = -2;\n-                    }\n-                    writeVarInt(t);\n-                    writeVarInt(lob.getTableId());\n-                    writeVarInt(lob.getObjectId());\n-                    writeVarLong(lob.getPrecision());\n-                    writeByte((byte) (lob.isCompressed() ? 1 : 0));\n-                    if (t == -2) {\n-                        writeString(lob.getFileName());\n-                    }\n-                } else {\n-                    writeVarInt(small.length);\n-                    write(small, 0, small.length);\n-                }\n-            } else {\n-                ValueLobDb lob = (ValueLobDb) v;\n-                byte[] small = lob.getSmall();\n-                if (small == null) {\n-                    writeVarInt(-3);\n-                    writeVarInt(lob.getTableId());\n-                    writeVarLong(lob.getLobId());\n-                    writeVarLong(lob.getPrecision());\n-                } else {\n-                    writeVarInt(small.length);\n-                    write(small, 0, small.length);\n-                }\n-            }\n-            break;\n-        }\n-        case Value.ARRAY: {\n+            writeVarInt(scale);\n+            byte[] bytes = b.toByteArray();\n+            writeVarInt(bytes.length);\n+            write(bytes, 0, bytes.length);\n+          }\n+        }\n+        break;\n+      }\n+      case Value.TIME:\n+        writeByte((byte) type);\n+        writeVarLong(DateTimeUtils.getTimeLocalWithoutDst(v.getTime()));\n+        break;\n+      case Value.DATE: {\n+        writeByte((byte) type);\n+        long x = DateTimeUtils.getTimeLocalWithoutDst(v.getDate());\n+        writeVarLong(x / MILLIS_PER_MINUTE);\n+        break;\n+      }\n+      case Value.TIMESTAMP: {\n+        Timestamp ts = v.getTimestamp();\n+        writeByte((byte) type);\n+        writeVarLong(DateTimeUtils.getTimeLocalWithoutDst(ts));\n+        writeVarInt(ts.getNanos() % 1_000_000);\n+        break;\n+      }\n+      case Value.TIMESTAMP_TZ: {\n+        ValueTimestampTimeZone ts = (ValueTimestampTimeZone) v;\n+        writeByte((byte) type);\n+        writeVarLong(ts.getDateValue());\n+        writeVarLong(ts.getTimeNanos());\n+        writeVarInt(ts.getTimeZoneOffsetMins());\n+        break;\n+      }\n+      case Value.GEOMETRY:\n+        // fall though\n+      case Value.JAVA_OBJECT: {\n+        writeByte((byte) type);\n+        byte[] b = v.getBytesNoCopy();\n+        int len = b.length;\n+        writeVarInt(len);\n+        write(b, 0, len);\n+        break;\n+      }\n+      case Value.BYTES: {\n+        byte[] b = v.getBytesNoCopy();\n+        int len = b.length;\n+        if (len < 32) {\n+          writeByte((byte) (BYTES_0_31 + len));\n+          write(b, 0, len);\n+        } else {\n+          writeByte((byte) type);\n+          writeVarInt(len);\n+          write(b, 0, len);\n+        }\n+        break;\n+      }\n+      case Value.UUID: {\n+        writeByte((byte) type);\n+        ValueUuid uuid = (ValueUuid) v;\n+        writeLong(uuid.getHigh());\n+        writeLong(uuid.getLow());\n+        break;\n+      }\n+      case Value.STRING: {\n+        String s = v.getString();\n+        int len = s.length();\n+        if (len < 32) {\n+          writeByte((byte) (STRING_0_31 + len));\n+          writeStringWithoutLength(s, len);\n+        } else {\n+          writeByte((byte) type);\n+          writeString(s);\n+        }\n+        break;\n+      }\n+      case Value.STRING_IGNORECASE:\n+      case Value.STRING_FIXED:\n+        writeByte((byte) type);\n+        writeString(v.getString());\n+        break;\n+      case Value.DOUBLE: {\n+        double x = v.getDouble();\n+        if (x == 1.0d) {\n+          writeByte((byte) (DOUBLE_0_1 + 1));\n+        } else {\n+          long d = Double.doubleToLongBits(x);\n+          if (d == ValueDouble.ZERO_BITS) {\n+            writeByte((byte) DOUBLE_0_1);\n+          } else {\n             writeByte((byte) type);\n-            Value[] list = ((ValueArray) v).getList();\n-            writeVarInt(list.length);\n-            for (Value x : list) {\n-                writeValue(x);\n-            }\n-            break;\n-        }\n-        case Value.RESULT_SET: {\n+            writeVarLong(Long.reverse(d));\n+          }\n+        }\n+        break;\n+      }\n+      case Value.FLOAT: {\n+        float x = v.getFloat();\n+        if (x == 1.0f) {\n+          writeByte((byte) (FLOAT_0_1 + 1));\n+        } else {\n+          int f = Float.floatToIntBits(x);\n+          if (f == ValueFloat.ZERO_BITS) {\n+            writeByte((byte) FLOAT_0_1);\n+          } else {\n             writeByte((byte) type);\n-            try {\n-                ResultSet rs = ((ValueResultSet) v).getResultSet();\n-                rs.beforeFirst();\n-                ResultSetMetaData meta = rs.getMetaData();\n-                int columnCount = meta.getColumnCount();\n-                writeVarInt(columnCount);\n-                for (int i = 0; i < columnCount; i++) {\n-                    writeString(meta.getColumnName(i + 1));\n-                    writeVarInt(meta.getColumnType(i + 1));\n-                    writeVarInt(meta.getPrecision(i + 1));\n-                    writeVarInt(meta.getScale(i + 1));\n-                }\n-                while (rs.next()) {\n-                    writeByte((byte) 1);\n-                    for (int i = 0; i < columnCount; i++) {\n-                        int t = DataType.getValueTypeFromResultSet(meta, i + 1);\n-                        Value val = DataType.readValue(null, rs, i + 1, t);\n-                        writeValue(val);\n-                    }\n-                }\n-                writeByte((byte) 0);\n-                rs.beforeFirst();\n-            } catch (SQLException e) {\n-                throw DbException.convert(e);\n+            writeVarInt(Integer.reverse(f));\n+          }\n+        }\n+        break;\n+      }\n+      case Value.BLOB:\n+      case Value.CLOB: {\n+        writeByte((byte) type);\n+        if (v instanceof ValueLob) {\n+          ValueLob lob = (ValueLob) v;\n+          byte[] small = lob.getSmall();\n+          if (small == null) {\n+            int t = -1;\n+            if (!lob.isLinkedToTable()) {\n+              t = -2;\n             }\n-            break;\n-        }\n-        case Value.INTERVAL_YEAR:\n-        case Value.INTERVAL_MONTH:\n-        case Value.INTERVAL_DAY:\n-        case Value.INTERVAL_HOUR:\n-        case Value.INTERVAL_MINUTE: {\n-            ValueInterval interval = (ValueInterval) v;\n-            int ordinal = type - Value.INTERVAL_YEAR;\n-            if (interval.isNegative()) {\n-                ordinal = ~ordinal;\n+            writeVarInt(t);\n+            writeVarInt(lob.getTableId());\n+            writeVarInt(lob.getObjectId());\n+            writeVarLong(lob.getPrecision());\n+            writeByte((byte) (lob.isCompressed() ? 1 : 0));\n+            if (t == -2) {\n+              writeString(lob.getFileName());\n             }\n-            writeByte((byte) Value.INTERVAL_YEAR);\n-            writeByte((byte) ordinal);\n-            writeVarLong(interval.getLeading());\n-            break;\n-        }\n-        case Value.INTERVAL_SECOND:\n-        case Value.INTERVAL_YEAR_TO_MONTH:\n-        case Value.INTERVAL_DAY_TO_HOUR:\n-        case Value.INTERVAL_DAY_TO_MINUTE:\n-        case Value.INTERVAL_DAY_TO_SECOND:\n-        case Value.INTERVAL_HOUR_TO_MINUTE:\n-        case Value.INTERVAL_HOUR_TO_SECOND:\n-        case Value.INTERVAL_MINUTE_TO_SECOND: {\n-            ValueInterval interval = (ValueInterval) v;\n-            int ordinal = type - Value.INTERVAL_YEAR;\n-            if (interval.isNegative()) {\n-                ordinal = ~ordinal;\n+          } else {\n+            writeVarInt(small.length);\n+            write(small, 0, small.length);\n+          }\n+        } else {\n+          ValueLobDb lob = (ValueLobDb) v;\n+          byte[] small = lob.getSmall();\n+          if (small == null) {\n+            writeVarInt(-3);\n+            writeVarInt(lob.getTableId());\n+            writeVarLong(lob.getLobId());\n+            writeVarLong(lob.getPrecision());\n+          } else {\n+            writeVarInt(small.length);\n+            write(small, 0, small.length);\n+          }\n+        }\n+        break;\n+      }\n+      case Value.ARRAY: {\n+        writeByte((byte) type);\n+        Value[] list = ((ValueArray) v).getList();\n+        writeVarInt(list.length);\n+        for (Value x : list) {\n+          writeValue(x);\n+        }\n+        break;\n+      }\n+      case Value.RESULT_SET: {\n+        writeByte((byte) type);\n+        try {\n+          ResultSet rs = ((ValueResultSet) v).getResultSet();\n+          rs.beforeFirst();\n+          ResultSetMetaData meta = rs.getMetaData();\n+          int columnCount = meta.getColumnCount();\n+          writeVarInt(columnCount);\n+          for (int i = 0; i < columnCount; i++) {\n+            writeString(meta.getColumnName(i + 1));\n+            writeVarInt(meta.getColumnType(i + 1));\n+            writeVarInt(meta.getPrecision(i + 1));\n+            writeVarInt(meta.getScale(i + 1));\n+          }\n+          while (rs.next()) {\n+            writeByte((byte) 1);\n+            for (int i = 0; i < columnCount; i++) {\n+              int t = DataType.getValueTypeFromResultSet(meta, i + 1);\n+              Value val = DataType.readValue(null, rs, i + 1, t);\n+              writeValue(val);\n             }\n-            writeByte((byte) Value.INTERVAL_YEAR);\n-            writeByte((byte) ordinal);\n-            writeVarLong(interval.getLeading());\n-            writeVarLong(interval.getRemaining());\n-            break;\n-        }\n-        default:\n-            if (JdbcUtils.customDataTypesHandler != null) {\n-                byte[] b = v.getBytesNoCopy();\n-                writeByte(CUSTOM_DATA_TYPE);\n-                writeVarInt(type);\n-                writeVarInt(b.length);\n-                write(b, 0, b.length);\n-                break;\n-            }\n-            DbException.throwInternalError(\"type=\" + v.getType());\n-        }\n-        assert pos - start == getValueLen(v, handler)\n-                : \"value size error: got \" + (pos - start) + \" expected \" + getValueLen(v, handler);\n+          }\n+          writeByte((byte) 0);\n+          rs.beforeFirst();\n+        } catch (SQLException e) {\n+          throw DbException.convert(e);\n+        }\n+        break;\n+      }\n+      case Value.INTERVAL_YEAR:\n+      case Value.INTERVAL_MONTH:\n+      case Value.INTERVAL_DAY:\n+      case Value.INTERVAL_HOUR:\n+      case Value.INTERVAL_MINUTE: {\n+        ValueInterval interval = (ValueInterval) v;\n+        int ordinal = type - Value.INTERVAL_YEAR;\n+        if (interval.isNegative()) {\n+          ordinal = ~ordinal;\n+        }\n+        writeByte((byte) Value.INTERVAL_YEAR);\n+        writeByte((byte) ordinal);\n+        writeVarLong(interval.getLeading());\n+        break;\n+      }\n+      case Value.INTERVAL_SECOND:\n+      case Value.INTERVAL_YEAR_TO_MONTH:\n+      case Value.INTERVAL_DAY_TO_HOUR:\n+      case Value.INTERVAL_DAY_TO_MINUTE:\n+      case Value.INTERVAL_DAY_TO_SECOND:\n+      case Value.INTERVAL_HOUR_TO_MINUTE:\n+      case Value.INTERVAL_HOUR_TO_SECOND:\n+      case Value.INTERVAL_MINUTE_TO_SECOND: {\n+        ValueInterval interval = (ValueInterval) v;\n+        int ordinal = type - Value.INTERVAL_YEAR;\n+        if (interval.isNegative()) {\n+          ordinal = ~ordinal;\n+        }\n+        writeByte((byte) Value.INTERVAL_YEAR);\n+        writeByte((byte) ordinal);\n+        writeVarLong(interval.getLeading());\n+        writeVarLong(interval.getRemaining());\n+        break;\n+      }\n+      default:\n+        if (JdbcUtils.customDataTypesHandler != null) {\n+          byte[] b = v.getBytesNoCopy();\n+          writeByte(CUSTOM_DATA_TYPE);\n+          writeVarInt(type);\n+          writeVarInt(b.length);\n+          write(b, 0, b.length);\n+          break;\n+        }\n+        DbException.throwInternalError(\"type=\" + v.getType());\n     }\n+    assert pos - start == getValueLen(v, handler)\n+        : \"value size error: got \" + (pos - start) + \" expected \" + getValueLen(v, handler);\n+  }\n \n-    /**\n-     * Read a value.\n-     *\n-     * @return the value\n-     */\n-    public Value readValue() {\n-        int type = data[pos++] & 255;\n-        switch (type) {\n-        case Value.NULL:\n-            return ValueNull.INSTANCE;\n-        case BOOLEAN_TRUE:\n-            return ValueBoolean.TRUE;\n-        case BOOLEAN_FALSE:\n-            return ValueBoolean.FALSE;\n-        case INT_NEG:\n-            return ValueInt.get(-readVarInt());\n-        case Value.ENUM:\n-        case Value.INT:\n-            return ValueInt.get(readVarInt());\n-        case LONG_NEG:\n-            return ValueLong.get(-readVarLong());\n-        case Value.LONG:\n-            return ValueLong.get(readVarLong());\n-        case Value.BYTE:\n-            return ValueByte.get(readByte());\n-        case Value.SHORT:\n-            return ValueShort.get(readShortInt());\n-        case DECIMAL_0_1:\n-            return (ValueDecimal) ValueDecimal.ZERO;\n-        case DECIMAL_0_1 + 1:\n-            return (ValueDecimal) ValueDecimal.ONE;\n-        case DECIMAL_SMALL_0:\n-            return ValueDecimal.get(BigDecimal.valueOf(readVarLong()));\n-        case DECIMAL_SMALL: {\n-            int scale = readVarInt();\n-            return ValueDecimal.get(BigDecimal.valueOf(readVarLong(), scale));\n-        }\n-        case Value.DECIMAL: {\n-            int scale = readVarInt();\n-            int len = readVarInt();\n-            byte[] buff = Utils.newBytes(len);\n-            read(buff, 0, len);\n-            BigInteger b = new BigInteger(buff);\n-            return ValueDecimal.get(new BigDecimal(b, scale));\n-        }\n-        case LOCAL_DATE: {\n-            return ValueDate.fromDateValue(readVarLong());\n-        }\n-        case Value.DATE: {\n-            long x = readVarLong() * MILLIS_PER_MINUTE;\n-            return ValueDate.fromMillis(DateTimeUtils.getTimeUTCWithoutDst(x));\n-        }\n-        case LOCAL_TIME: {\n-            long nanos = readVarLong() * 1_000_000 + readVarLong();\n-            return ValueTime.fromNanos(nanos);\n-        }\n-        case Value.TIME:\n-            // need to normalize the year, month and day\n-            return ValueTime.fromMillis(\n-                    DateTimeUtils.getTimeUTCWithoutDst(readVarLong()));\n-        case LOCAL_TIMESTAMP: {\n-            long dateValue = readVarLong();\n-            long nanos = readVarLong() * 1_000_000 + readVarLong();\n-            return ValueTimestamp.fromDateValueAndNanos(dateValue, nanos);\n-        }\n-        case Value.TIMESTAMP: {\n-            return ValueTimestamp.fromMillisNanos(\n-                    DateTimeUtils.getTimeUTCWithoutDst(readVarLong()),\n-                    readVarInt() % 1_000_000);\n-        }\n-        case Value.TIMESTAMP_TZ: {\n-            long dateValue = readVarLong();\n-            long nanos = readVarLong();\n-            short tz = (short) readVarInt();\n-            return ValueTimestampTimeZone.fromDateValueAndNanos(dateValue, nanos, tz);\n-        }\n-        case Value.BYTES: {\n-            int len = readVarInt();\n-            byte[] b = Utils.newBytes(len);\n-            read(b, 0, len);\n-            return ValueBytes.getNoCopy(b);\n-        }\n-        case Value.GEOMETRY: {\n-            int len = readVarInt();\n-            byte[] b = Utils.newBytes(len);\n-            read(b, 0, len);\n-            return ValueGeometry.get(b);\n-        }\n-        case Value.JAVA_OBJECT: {\n-            int len = readVarInt();\n-            byte[] b = Utils.newBytes(len);\n-            read(b, 0, len);\n-            return ValueJavaObject.getNoCopy(null, b, handler);\n-        }\n-        case Value.UUID:\n-            return ValueUuid.get(readLong(), readLong());\n-        case Value.STRING:\n-            return ValueString.get(readString());\n-        case Value.STRING_IGNORECASE:\n-            return ValueStringIgnoreCase.get(readString());\n-        case Value.STRING_FIXED:\n-            return ValueStringFixed.get(readString());\n-        case FLOAT_0_1:\n-            return ValueFloat.ZERO;\n-        case FLOAT_0_1 + 1:\n-            return ValueFloat.ONE;\n-        case DOUBLE_0_1:\n-            return ValueDouble.ZERO;\n-        case DOUBLE_0_1 + 1:\n-            return ValueDouble.ONE;\n-        case Value.DOUBLE:\n-            return ValueDouble.get(Double.longBitsToDouble(\n-                    Long.reverse(readVarLong())));\n-        case Value.FLOAT:\n-            return ValueFloat.get(Float.intBitsToFloat(\n-                    Integer.reverse(readVarInt())));\n-        case Value.BLOB:\n-        case Value.CLOB: {\n-            int smallLen = readVarInt();\n-            if (smallLen >= 0) {\n-                byte[] small = Utils.newBytes(smallLen);\n-                read(small, 0, smallLen);\n-                return ValueLobDb.createSmallLob(type, small);\n-            } else if (smallLen == -3) {\n-                int tableId = readVarInt();\n-                long lobId = readVarLong();\n-                long precision = readVarLong();\n-                return ValueLobDb.create(type, handler, tableId,\n-                        lobId, null, precision);\n-            } else {\n-                int tableId = readVarInt();\n-                int objectId = readVarInt();\n-                long precision = 0;\n-                boolean compression = false;\n-                // -1: regular; -2: regular, but not linked (in this case:\n-                // including file name)\n-                if (smallLen == -1 || smallLen == -2) {\n-                    precision = readVarLong();\n-                    compression = readByte() == 1;\n-                }\n-                if (smallLen == -2) {\n-                    String filename = readString();\n-                    return ValueLob.openUnlinked(type, handler, tableId,\n-                            objectId, precision, compression, filename);\n-                }\n-                return ValueLob.openLinked(type, handler, tableId,\n-                        objectId, precision, compression);\n-            }\n-        }\n-        case Value.ARRAY: {\n-            int len = readVarInt();\n-            Value[] list = new Value[len];\n-            for (int i = 0; i < len; i++) {\n-                list[i] = readValue();\n-            }\n-            return ValueArray.get(list);\n-        }\n-        case Value.RESULT_SET: {\n-            SimpleResultSet rs = new SimpleResultSet();\n-            rs.setAutoClose(false);\n-            int columns = readVarInt();\n-            for (int i = 0; i < columns; i++) {\n-                rs.addColumn(readString(), readVarInt(), readVarInt(), readVarInt());\n-            }\n-            while (readByte() != 0) {\n-                Object[] o = new Object[columns];\n-                for (int i = 0; i < columns; i++) {\n-                    o[i] = readValue().getObject();\n-                }\n-                rs.addRow(o);\n-            }\n-            return ValueResultSet.get(rs);\n-        }\n-        case Value.INTERVAL_YEAR: {\n-            int ordinal = readByte();\n-            boolean negative = ordinal < 0;\n-            if (negative) {\n-                ordinal = ~ordinal;\n-            }\n-            return ValueInterval.from(IntervalQualifier.valueOf(ordinal), negative, readVarLong(),\n-                    ordinal < 5 ? 0 : readVarLong());\n-        }\n-        case CUSTOM_DATA_TYPE: {\n-            if (JdbcUtils.customDataTypesHandler != null) {\n-                int customType = readVarInt();\n-                int len = readVarInt();\n-                byte[] b = Utils.newBytes(len);\n-                read(b, 0, len);\n-                return JdbcUtils.customDataTypesHandler.convert(\n-                        ValueBytes.getNoCopy(b), customType);\n-            }\n-            throw DbException.get(ErrorCode.UNKNOWN_DATA_TYPE_1,\n-                    \"No CustomDataTypesHandler has been set up\");\n-        }\n-        default:\n-            if (type >= INT_0_15 && type < INT_0_15 + 16) {\n-                return ValueInt.get(type - INT_0_15);\n-            } else if (type >= LONG_0_7 && type < LONG_0_7 + 8) {\n-                return ValueLong.get(type - LONG_0_7);\n-            } else if (type >= BYTES_0_31 && type < BYTES_0_31 + 32) {\n-                int len = type - BYTES_0_31;\n-                byte[] b = Utils.newBytes(len);\n-                read(b, 0, len);\n-                return ValueBytes.getNoCopy(b);\n-            } else if (type >= STRING_0_31 && type < STRING_0_31 + 32) {\n-                return ValueString.get(readString(type - STRING_0_31));\n-            }\n-            throw DbException.get(ErrorCode.FILE_CORRUPTED_1, \"type: \" + type);\n-        }\n+  /**\n+   * Read a value.\n+   *\n+   * @return the value\n+   */\n+  public Value readValue() {\n+    int type = data[pos++] & 255;\n+    switch (type) {\n+      case Value.NULL:\n+        return ValueNull.INSTANCE;\n+      case BOOLEAN_TRUE:\n+        return ValueBoolean.TRUE;\n+      case BOOLEAN_FALSE:\n+        return ValueBoolean.FALSE;\n+      case INT_NEG:\n+        return ValueInt.get(-readVarInt());\n+      case Value.ENUM:\n+      case Value.INT:\n+        return ValueInt.get(readVarInt());\n+      case LONG_NEG:\n+        return ValueLong.get(-readVarLong());\n+      case Value.LONG:\n+        return ValueLong.get(readVarLong());\n+      case Value.BYTE:\n+        return ValueByte.get(readByte());\n+      case Value.SHORT:\n+        return ValueShort.get(readShortInt());\n+      case DECIMAL_0_1:\n+        return (ValueDecimal) ValueDecimal.ZERO;\n+      case DECIMAL_0_1 + 1:\n+        return (ValueDecimal) ValueDecimal.ONE;\n+      case DECIMAL_SMALL_0:\n+        return ValueDecimal.get(BigDecimal.valueOf(readVarLong()));\n+      case DECIMAL_SMALL: {\n+        int scale = readVarInt();\n+        return ValueDecimal.get(BigDecimal.valueOf(readVarLong(), scale));\n+      }\n+      case Value.DECIMAL: {\n+        int scale = readVarInt();\n+        int len = readVarInt();\n+        byte[] buff = Utils.newBytes(len);\n+        read(buff, 0, len);\n+        BigInteger b = new BigInteger(buff);\n+        return ValueDecimal.get(new BigDecimal(b, scale));\n+      }\n+      case LOCAL_DATE: {\n+        return ValueDate.fromDateValue(readVarLong());\n+      }\n+      case Value.DATE: {\n+        long x = readVarLong() * MILLIS_PER_MINUTE;\n+        return ValueDate.fromMillis(DateTimeUtils.getTimeUTCWithoutDst(x));\n+      }\n+      case LOCAL_TIME: {\n+        long nanos = readVarLong() * 1_000_000 + readVarLong();\n+        return ValueTime.fromNanos(nanos);\n+      }\n+      case Value.TIME:\n+        // need to normalize the year, month and day\n+        return ValueTime.fromMillis(\n+            DateTimeUtils.getTimeUTCWithoutDst(readVarLong()));\n+      case LOCAL_TIMESTAMP: {\n+        long dateValue = readVarLong();\n+        long nanos = readVarLong() * 1_000_000 + readVarLong();\n+        return ValueTimestamp.fromDateValueAndNanos(dateValue, nanos);\n+      }\n+      case Value.TIMESTAMP: {\n+        return ValueTimestamp.fromMillisNanos(\n+            DateTimeUtils.getTimeUTCWithoutDst(readVarLong()),\n+            readVarInt() % 1_000_000);\n+      }\n+      case Value.TIMESTAMP_TZ: {\n+        long dateValue = readVarLong();\n+        long nanos = readVarLong();\n+        short tz = (short) readVarInt();\n+        return ValueTimestampTimeZone.fromDateValueAndNanos(dateValue, nanos, tz);\n+      }\n+      case Value.BYTES: {\n+        int len = readVarInt();\n+        byte[] b = Utils.newBytes(len);\n+        read(b, 0, len);\n+        return ValueBytes.getNoCopy(b);\n+      }\n+      case Value.GEOMETRY: {\n+        int len = readVarInt();\n+        byte[] b = Utils.newBytes(len);\n+        read(b, 0, len);\n+        return ValueGeometry.get(b);\n+      }\n+      case Value.JAVA_OBJECT: {\n+        int len = readVarInt();\n+        byte[] b = Utils.newBytes(len);\n+        read(b, 0, len);\n+        return ValueJavaObject.getNoCopy(null, b, handler);\n+      }\n+      case Value.UUID:\n+        return ValueUuid.get(readLong(), readLong());\n+      case Value.STRING:\n+        return ValueString.get(readString());\n+      case Value.STRING_IGNORECASE:\n+        return ValueStringIgnoreCase.get(readString());\n+      case Value.STRING_FIXED:\n+        return ValueStringFixed.get(readString());\n+      case FLOAT_0_1:\n+        return ValueFloat.ZERO;\n+      case FLOAT_0_1 + 1:\n+        return ValueFloat.ONE;\n+      case DOUBLE_0_1:\n+        return ValueDouble.ZERO;\n+      case DOUBLE_0_1 + 1:\n+        return ValueDouble.ONE;\n+      case Value.DOUBLE:\n+        return ValueDouble.get(Double.longBitsToDouble(\n+            Long.reverse(readVarLong())));\n+      case Value.FLOAT:\n+        return ValueFloat.get(Float.intBitsToFloat(\n+            Integer.reverse(readVarInt())));\n+      case Value.BLOB:\n+      case Value.CLOB: {\n+        int smallLen = readVarInt();\n+        if (smallLen >= 0) {\n+          byte[] small = Utils.newBytes(smallLen);\n+          read(small, 0, smallLen);\n+          return ValueLobDb.createSmallLob(type, small);\n+        } else if (smallLen == -3) {\n+          int tableId = readVarInt();\n+          long lobId = readVarLong();\n+          long precision = readVarLong();\n+          return ValueLobDb.create(type, handler, tableId,\n+              lobId, null, precision);\n+        } else {\n+          int tableId = readVarInt();\n+          int objectId = readVarInt();\n+          long precision = 0;\n+          boolean compression = false;\n+          // -1: regular; -2: regular, but not linked (in this case:\n+          // including file name)\n+          if (smallLen == -1 || smallLen == -2) {\n+            precision = readVarLong();\n+            compression = readByte() == 1;\n+          }\n+          if (smallLen == -2) {\n+            String filename = readString();\n+            return ValueLob.openUnlinked(type, handler, tableId,\n+                objectId, precision, compression, filename);\n+          }\n+          return ValueLob.openLinked(type, handler, tableId,\n+              objectId, precision, compression);\n+        }\n+      }\n+      case Value.ARRAY: {\n+        int len = readVarInt();\n+        Value[] list = new Value[len];\n+        for (int i = 0; i < len; i++) {\n+          list[i] = readValue();\n+        }\n+        return ValueArray.get(list);\n+      }\n+      case Value.RESULT_SET: {\n+        SimpleResultSet rs = new SimpleResultSet();\n+        rs.setAutoClose(false);\n+        int columns = readVarInt();\n+        for (int i = 0; i < columns; i++) {\n+          rs.addColumn(readString(), readVarInt(), readVarInt(), readVarInt());\n+        }\n+        while (readByte() != 0) {\n+          Object[] o = new Object[columns];\n+          for (int i = 0; i < columns; i++) {\n+            o[i] = readValue().getObject();\n+          }\n+          rs.addRow(o);\n+        }\n+        return ValueResultSet.get(rs);\n+      }\n+      case Value.INTERVAL_YEAR: {\n+        int ordinal = readByte();\n+        boolean negative = ordinal < 0;\n+        if (negative) {\n+          ordinal = ~ordinal;\n+        }\n+        return ValueInterval.from(IntervalQualifier.valueOf(ordinal), negative, readVarLong(),\n+            ordinal < 5 ? 0 : readVarLong());\n+      }\n+      case CUSTOM_DATA_TYPE: {\n+        if (JdbcUtils.customDataTypesHandler != null) {\n+          int customType = readVarInt();\n+          int len = readVarInt();\n+          byte[] b = Utils.newBytes(len);\n+          read(b, 0, len);\n+          return JdbcUtils.customDataTypesHandler.convert(\n+              ValueBytes.getNoCopy(b), customType);\n+        }\n+        throw DbException.get(ErrorCode.UNKNOWN_DATA_TYPE_1,\n+            \"No CustomDataTypesHandler has been set up\");\n+      }\n+      default:\n+        if (type >= INT_0_15 && type < INT_0_15 + 16) {\n+          return ValueInt.get(type - INT_0_15);\n+        } else if (type >= LONG_0_7 && type < LONG_0_7 + 8) {\n+          return ValueLong.get(type - LONG_0_7);\n+        } else if (type >= BYTES_0_31 && type < BYTES_0_31 + 32) {\n+          int len = type - BYTES_0_31;\n+          byte[] b = Utils.newBytes(len);\n+          read(b, 0, len);\n+          return ValueBytes.getNoCopy(b);\n+        } else if (type >= STRING_0_31 && type < STRING_0_31 + 32) {\n+          return ValueString.get(readString(type - STRING_0_31));\n+        }\n+        throw DbException.get(ErrorCode.FILE_CORRUPTED_1, \"type: \" + type);\n     }\n+  }\n \n-    /**\n-     * Calculate the number of bytes required to encode the given value.\n-     *\n-     * @param v the value\n-     * @return the number of bytes required to store this value\n-     */\n-    public int getValueLen(Value v) {\n-        return getValueLen(v, handler);\n-    }\n+  /**\n+   * Calculate the number of bytes required to encode the given value.\n+   *\n+   * @param v the value\n+   * @return the number of bytes required to store this value\n+   */\n+  public int getValueLen(Value v) {\n+    return getValueLen(v, handler);\n+  }\n \n-    /**\n-     * Calculate the number of bytes required to encode the given value.\n-     *\n-     * @param v the value\n-     * @param handler the data handler for lobs\n-     * @return the number of bytes required to store this value\n-     */\n-    public static int getValueLen(Value v, DataHandler handler) {\n-        if (v == ValueNull.INSTANCE) {\n-            return 1;\n-        }\n-        switch (v.getType()) {\n-        case Value.BOOLEAN:\n-            return 1;\n-        case Value.BYTE:\n-            return 2;\n-        case Value.SHORT:\n-            return 3;\n-        case Value.ENUM:\n-        case Value.INT: {\n-            int x = v.getInt();\n-            if (x < 0) {\n-                return 1 + getVarIntLen(-x);\n-            } else if (x < 16) {\n-                return 1;\n-            } else {\n-                return 1 + getVarIntLen(x);\n-            }\n-        }\n-        case Value.LONG: {\n-            long x = v.getLong();\n-            if (x < 0) {\n-                return 1 + getVarLongLen(-x);\n-            } else if (x < 8) {\n-                return 1;\n-            } else {\n-                return 1 + getVarLongLen(x);\n-            }\n-        }\n-        case Value.DOUBLE: {\n-            double x = v.getDouble();\n-            if (x == 1.0d) {\n-                return 1;\n-            }\n-            long d = Double.doubleToLongBits(x);\n-            if (d == ValueDouble.ZERO_BITS) {\n-                return 1;\n-            }\n-            return 1 + getVarLongLen(Long.reverse(d));\n-        }\n-        case Value.FLOAT: {\n-            float x = v.getFloat();\n-            if (x == 1.0f) {\n-                return 1;\n-            }\n-            int f = Float.floatToIntBits(x);\n-            if (f == ValueFloat.ZERO_BITS) {\n-                return 1;\n-            }\n-            return 1 + getVarIntLen(Integer.reverse(f));\n-        }\n-        case Value.STRING: {\n-            String s = v.getString();\n-            int len = s.length();\n-            if (len < 32) {\n-                return 1 + getStringWithoutLengthLen(s, len);\n-            }\n-            return 1 + getStringLen(s);\n-        }\n-        case Value.STRING_IGNORECASE:\n-        case Value.STRING_FIXED:\n-            return 1 + getStringLen(v.getString());\n-        case Value.DECIMAL: {\n-            BigDecimal x = v.getBigDecimal();\n-            if (BigDecimal.ZERO.equals(x)) {\n-                return 1;\n-            } else if (BigDecimal.ONE.equals(x)) {\n-                return 1;\n-            }\n-            int scale = x.scale();\n-            BigInteger b = x.unscaledValue();\n-            int bits = b.bitLength();\n-            if (bits <= 63) {\n-                if (scale == 0) {\n-                    return 1 + getVarLongLen(b.longValue());\n-                }\n-                return 1 + getVarIntLen(scale) + getVarLongLen(b.longValue());\n-            }\n-            byte[] bytes = b.toByteArray();\n-            return 1 + getVarIntLen(scale) + getVarIntLen(bytes.length) + bytes.length;\n-        }\n-        case Value.TIME:\n-            return 1 + getVarLongLen(DateTimeUtils.getTimeLocalWithoutDst(v.getTime()));\n-        case Value.DATE: {\n-            long x = DateTimeUtils.getTimeLocalWithoutDst(v.getDate());\n-            return 1 + getVarLongLen(x / MILLIS_PER_MINUTE);\n-        }\n-        case Value.TIMESTAMP: {\n-            Timestamp ts = v.getTimestamp();\n-            return 1 + getVarLongLen(DateTimeUtils.getTimeLocalWithoutDst(ts)) +\n-                    getVarIntLen(ts.getNanos() % 1_000_000);\n-        }\n-        case Value.TIMESTAMP_TZ: {\n-            ValueTimestampTimeZone ts = (ValueTimestampTimeZone) v;\n-            long dateValue = ts.getDateValue();\n-            long nanos = ts.getTimeNanos();\n-            short tz = ts.getTimeZoneOffsetMins();\n-            return 1 + getVarLongLen(dateValue) + getVarLongLen(nanos) +\n-                    getVarIntLen(tz);\n-        }\n-        case Value.GEOMETRY:\n-        case Value.JAVA_OBJECT: {\n-            byte[] b = v.getBytesNoCopy();\n-            return 1 + getVarIntLen(b.length) + b.length;\n-        }\n-        case Value.BYTES: {\n-            byte[] b = v.getBytesNoCopy();\n-            int len = b.length;\n-            if (len < 32) {\n-                return 1 + b.length;\n-            }\n-            return 1 + getVarIntLen(b.length) + b.length;\n-        }\n-        case Value.UUID:\n-            return 1 + LENGTH_LONG + LENGTH_LONG;\n-        case Value.BLOB:\n-        case Value.CLOB: {\n-            int len = 1;\n-            if (v instanceof ValueLob) {\n-                ValueLob lob = (ValueLob) v;\n-                byte[] small = lob.getSmall();\n-                if (small == null) {\n-                    int t = -1;\n-                    if (!lob.isLinkedToTable()) {\n-                        t = -2;\n-                    }\n-                    len += getVarIntLen(t);\n-                    len += getVarIntLen(lob.getTableId());\n-                    len += getVarIntLen(lob.getObjectId());\n-                    len += getVarLongLen(lob.getPrecision());\n-                    len += 1;\n-                    if (t == -2) {\n-                        len += getStringLen(lob.getFileName());\n-                    }\n-                } else {\n-                    len += getVarIntLen(small.length);\n-                    len += small.length;\n-                }\n-            } else {\n-                ValueLobDb lob = (ValueLobDb) v;\n-                byte[] small = lob.getSmall();\n-                if (small == null) {\n-                    len += getVarIntLen(-3);\n-                    len += getVarIntLen(lob.getTableId());\n-                    len += getVarLongLen(lob.getLobId());\n-                    len += getVarLongLen(lob.getPrecision());\n-                } else {\n-                    len += getVarIntLen(small.length);\n-                    len += small.length;\n-                }\n-            }\n-            return len;\n-        }\n-        case Value.ARRAY: {\n-            Value[] list = ((ValueArray) v).getList();\n-            int len = 1 + getVarIntLen(list.length);\n-            for (Value x : list) {\n-                len += getValueLen(x, handler);\n+  /**\n+   * Calculate the number of bytes required to encode the given value.\n+   *\n+   * @param v       the value\n+   * @param handler the data handler for lobs\n+   * @return the number of bytes required to store this value\n+   */\n+  public static int getValueLen(Value v, DataHandler handler) {\n+    if (v == ValueNull.INSTANCE) {\n+      return 1;\n+    }\n+    switch (v.getType()) {\n+      case Value.BOOLEAN:\n+        return 1;\n+      case Value.BYTE:\n+        return 2;\n+      case Value.SHORT:\n+        return 3;\n+      case Value.ENUM:\n+      case Value.INT: {\n+        int x = v.getInt();\n+        if (x < 0) {\n+          return 1 + getVarIntLen(-x);\n+        } else if (x < 16) {\n+          return 1;\n+        } else {\n+          return 1 + getVarIntLen(x);\n+        }\n+      }\n+      case Value.LONG: {\n+        long x = v.getLong();\n+        if (x < 0) {\n+          return 1 + getVarLongLen(-x);\n+        } else if (x < 8) {\n+          return 1;\n+        } else {\n+          return 1 + getVarLongLen(x);\n+        }\n+      }\n+      case Value.DOUBLE: {\n+        double x = v.getDouble();\n+        if (x == 1.0d) {\n+          return 1;\n+        }\n+        long d = Double.doubleToLongBits(x);\n+        if (d == ValueDouble.ZERO_BITS) {\n+          return 1;\n+        }\n+        return 1 + getVarLongLen(Long.reverse(d));\n+      }\n+      case Value.FLOAT: {\n+        float x = v.getFloat();\n+        if (x == 1.0f) {\n+          return 1;\n+        }\n+        int f = Float.floatToIntBits(x);\n+        if (f == ValueFloat.ZERO_BITS) {\n+          return 1;\n+        }\n+        return 1 + getVarIntLen(Integer.reverse(f));\n+      }\n+      case Value.STRING: {\n+        String s = v.getString();\n+        int len = s.length();\n+        if (len < 32) {\n+          return 1 + getStringWithoutLengthLen(s, len);\n+        }\n+        return 1 + getStringLen(s);\n+      }\n+      case Value.STRING_IGNORECASE:\n+      case Value.STRING_FIXED:\n+        return 1 + getStringLen(v.getString());\n+      case Value.DECIMAL: {\n+        BigDecimal x = v.getBigDecimal();\n+        if (BigDecimal.ZERO.equals(x)) {\n+          return 1;\n+        } else if (BigDecimal.ONE.equals(x)) {\n+          return 1;\n+        }\n+        int scale = x.scale();\n+        BigInteger b = x.unscaledValue();\n+        int bits = b.bitLength();\n+        if (bits <= 63) {\n+          if (scale == 0) {\n+            return 1 + getVarLongLen(b.longValue());\n+          }\n+          return 1 + getVarIntLen(scale) + getVarLongLen(b.longValue());\n+        }\n+        byte[] bytes = b.toByteArray();\n+        return 1 + getVarIntLen(scale) + getVarIntLen(bytes.length) + bytes.length;\n+      }\n+      case Value.TIME:\n+        return 1 + getVarLongLen(DateTimeUtils.getTimeLocalWithoutDst(v.getTime()));\n+      case Value.DATE: {\n+        long x = DateTimeUtils.getTimeLocalWithoutDst(v.getDate());\n+        return 1 + getVarLongLen(x / MILLIS_PER_MINUTE);\n+      }\n+      case Value.TIMESTAMP: {\n+        Timestamp ts = v.getTimestamp();\n+        return 1 + getVarLongLen(DateTimeUtils.getTimeLocalWithoutDst(ts)) +\n+            getVarIntLen(ts.getNanos() % 1_000_000);\n+      }\n+      case Value.TIMESTAMP_TZ: {\n+        ValueTimestampTimeZone ts = (ValueTimestampTimeZone) v;\n+        long dateValue = ts.getDateValue();\n+        long nanos = ts.getTimeNanos();\n+        short tz = ts.getTimeZoneOffsetMins();\n+        return 1 + getVarLongLen(dateValue) + getVarLongLen(nanos) +\n+            getVarIntLen(tz);\n+      }\n+      case Value.GEOMETRY:\n+      case Value.JAVA_OBJECT: {\n+        byte[] b = v.getBytesNoCopy();\n+        return 1 + getVarIntLen(b.length) + b.length;\n+      }\n+      case Value.BYTES: {\n+        byte[] b = v.getBytesNoCopy();\n+        int len = b.length;\n+        if (len < 32) {\n+          return 1 + b.length;\n+        }\n+        return 1 + getVarIntLen(b.length) + b.length;\n+      }\n+      case Value.UUID:\n+        return 1 + LENGTH_LONG + LENGTH_LONG;\n+      case Value.BLOB:\n+      case Value.CLOB: {\n+        int len = 1;\n+        if (v instanceof ValueLob) {\n+          ValueLob lob = (ValueLob) v;\n+          byte[] small = lob.getSmall();\n+          if (small == null) {\n+            int t = -1;\n+            if (!lob.isLinkedToTable()) {\n+              t = -2;\n             }\n-            return len;\n-        }\n-        case Value.RESULT_SET: {\n-            int len = 1;\n-            try {\n-                ResultSet rs = ((ValueResultSet) v).getResultSet();\n-                rs.beforeFirst();\n-                ResultSetMetaData meta = rs.getMetaData();\n-                int columnCount = meta.getColumnCount();\n-                len += getVarIntLen(columnCount);\n-                for (int i = 0; i < columnCount; i++) {\n-                    len += getStringLen(meta.getColumnName(i + 1));\n-                    len += getVarIntLen(meta.getColumnType(i + 1));\n-                    len += getVarIntLen(meta.getPrecision(i + 1));\n-                    len += getVarIntLen(meta.getScale(i + 1));\n-                }\n-                while (rs.next()) {\n-                    len++;\n-                    for (int i = 0; i < columnCount; i++) {\n-                        int t = DataType.getValueTypeFromResultSet(meta, i + 1);\n-                        Value val = DataType.readValue(null, rs, i + 1, t);\n-                        len += getValueLen(val, handler);\n-                    }\n-                }\n-                len++;\n-                rs.beforeFirst();\n-            } catch (SQLException e) {\n-                throw DbException.convert(e);\n+            len += getVarIntLen(t);\n+            len += getVarIntLen(lob.getTableId());\n+            len += getVarIntLen(lob.getObjectId());\n+            len += getVarLongLen(lob.getPrecision());\n+            len += 1;\n+            if (t == -2) {\n+              len += getStringLen(lob.getFileName());\n             }\n-            return len;\n-        }\n-        case Value.INTERVAL_YEAR:\n-        case Value.INTERVAL_MONTH:\n-        case Value.INTERVAL_DAY:\n-        case Value.INTERVAL_HOUR:\n-        case Value.INTERVAL_MINUTE: {\n-            ValueInterval interval = (ValueInterval) v;\n-            return 2 + getVarLongLen(interval.getLeading());\n-        }\n-        case Value.INTERVAL_SECOND:\n-        case Value.INTERVAL_YEAR_TO_MONTH:\n-        case Value.INTERVAL_DAY_TO_HOUR:\n-        case Value.INTERVAL_DAY_TO_MINUTE:\n-        case Value.INTERVAL_DAY_TO_SECOND:\n-        case Value.INTERVAL_HOUR_TO_MINUTE:\n-        case Value.INTERVAL_HOUR_TO_SECOND:\n-        case Value.INTERVAL_MINUTE_TO_SECOND: {\n-            ValueInterval interval = (ValueInterval) v;\n-            return 2 + getVarLongLen(interval.getLeading()) + getVarLongLen(interval.getRemaining());\n-        }\n-        default:\n-            if (JdbcUtils.customDataTypesHandler != null) {\n-                byte[] b = v.getBytesNoCopy();\n-                return 1 + getVarIntLen(v.getType())\n-                    + getVarIntLen(b.length) + b.length;\n+          } else {\n+            len += getVarIntLen(small.length);\n+            len += small.length;\n+          }\n+        } else {\n+          ValueLobDb lob = (ValueLobDb) v;\n+          byte[] small = lob.getSmall();\n+          if (small == null) {\n+            len += getVarIntLen(-3);\n+            len += getVarIntLen(lob.getTableId());\n+            len += getVarLongLen(lob.getLobId());\n+            len += getVarLongLen(lob.getPrecision());\n+          } else {\n+            len += getVarIntLen(small.length);\n+            len += small.length;\n+          }\n+        }\n+        return len;\n+      }\n+      case Value.ARRAY: {\n+        Value[] list = ((ValueArray) v).getList();\n+        int len = 1 + getVarIntLen(list.length);\n+        for (Value x : list) {\n+          len += getValueLen(x, handler);\n+        }\n+        return len;\n+      }\n+      case Value.RESULT_SET: {\n+        int len = 1;\n+        try {\n+          ResultSet rs = ((ValueResultSet) v).getResultSet();\n+          rs.beforeFirst();\n+          ResultSetMetaData meta = rs.getMetaData();\n+          int columnCount = meta.getColumnCount();\n+          len += getVarIntLen(columnCount);\n+          for (int i = 0; i < columnCount; i++) {\n+            len += getStringLen(meta.getColumnName(i + 1));\n+            len += getVarIntLen(meta.getColumnType(i + 1));\n+            len += getVarIntLen(meta.getPrecision(i + 1));\n+            len += getVarIntLen(meta.getScale(i + 1));\n+          }\n+          while (rs.next()) {\n+            len++;\n+            for (int i = 0; i < columnCount; i++) {\n+              int t = DataType.getValueTypeFromResultSet(meta, i + 1);\n+              Value val = DataType.readValue(null, rs, i + 1, t);\n+              len += getValueLen(val, handler);\n             }\n-            throw DbException.throwInternalError(\"type=\" + v.getType());\n-        }\n+          }\n+          len++;\n+          rs.beforeFirst();\n+        } catch (SQLException e) {\n+          throw DbException.convert(e);\n+        }\n+        return len;\n+      }\n+      case Value.INTERVAL_YEAR:\n+      case Value.INTERVAL_MONTH:\n+      case Value.INTERVAL_DAY:\n+      case Value.INTERVAL_HOUR:\n+      case Value.INTERVAL_MINUTE: {\n+        ValueInterval interval = (ValueInterval) v;\n+        return 2 + getVarLongLen(interval.getLeading());\n+      }\n+      case Value.INTERVAL_SECOND:\n+      case Value.INTERVAL_YEAR_TO_MONTH:\n+      case Value.INTERVAL_DAY_TO_HOUR:\n+      case Value.INTERVAL_DAY_TO_MINUTE:\n+      case Value.INTERVAL_DAY_TO_SECOND:\n+      case Value.INTERVAL_HOUR_TO_MINUTE:\n+      case Value.INTERVAL_HOUR_TO_SECOND:\n+      case Value.INTERVAL_MINUTE_TO_SECOND: {\n+        ValueInterval interval = (ValueInterval) v;\n+        return 2 + getVarLongLen(interval.getLeading()) + getVarLongLen(interval.getRemaining());\n+      }\n+      default:\n+        if (JdbcUtils.customDataTypesHandler != null) {\n+          byte[] b = v.getBytesNoCopy();\n+          return 1 + getVarIntLen(v.getType())\n+              + getVarIntLen(b.length) + b.length;\n+        }\n+        throw DbException.throwInternalError(\"type=\" + v.getType());\n     }\n+  }\n \n-    /**\n-     * Set the current read / write position.\n-     *\n-     * @param pos the new position\n-     */\n-    public void setPos(int pos) {\n-        this.pos = pos;\n-    }\n+  /**\n+   * Set the current read / write position.\n+   *\n+   * @param pos the new position\n+   */\n+  public void setPos(int pos) {\n+    this.pos = pos;\n+  }\n \n-    /**\n-     * Write a short integer at the current position.\n-     * The current position is incremented.\n-     *\n-     * @param x the value\n-     */\n-    public void writeShortInt(int x) {\n-        byte[] buff = data;\n-        buff[pos++] = (byte) (x >> 8);\n-        buff[pos++] = (byte) x;\n-    }\n+  /**\n+   * Write a short integer at the current position.\n+   * The current position is incremented.\n+   *\n+   * @param x the value\n+   */\n+  public void writeShortInt(int x) {\n+    byte[] buff = data;\n+    buff[pos++] = (byte) (x >> 8);\n+    buff[pos++] = (byte) x;\n+  }\n \n-    /**\n-     * Read an short integer at the current position.\n-     * The current position is incremented.\n-     *\n-     * @return the value\n-     */\n-    public short readShortInt() {\n-        byte[] buff = data;\n-        return (short) (((buff[pos++] & 0xff) << 8) + (buff[pos++] & 0xff));\n-    }\n+  /**\n+   * Read an short integer at the current position.\n+   * The current position is incremented.\n+   *\n+   * @return the value\n+   */\n+  public short readShortInt() {\n+    byte[] buff = data;\n+    return (short) (((buff[pos++] & 0xff) << 8) + (buff[pos++] & 0xff));\n+  }\n \n-    /**\n-     * Shrink the array to this size.\n-     *\n-     * @param size the new size\n-     */\n-    public void truncate(int size) {\n-        if (pos > size) {\n-            byte[] buff = Arrays.copyOf(data, size);\n-            this.pos = size;\n-            data = buff;\n-        }\n+  /**\n+   * Shrink the array to this size.\n+   *\n+   * @param size the new size\n+   */\n+  public void truncate(int size) {\n+    if (pos > size) {\n+      byte[] buff = Arrays.copyOf(data, size);\n+      this.pos = size;\n+      data = buff;\n     }\n+  }\n \n-    /**\n-     * The number of bytes required for a variable size int.\n-     *\n-     * @param x the value\n-     * @return the len\n-     */\n-    private static int getVarIntLen(int x) {\n-        if ((x & (-1 << 7)) == 0) {\n-            return 1;\n-        } else if ((x & (-1 << 14)) == 0) {\n-            return 2;\n-        } else if ((x & (-1 << 21)) == 0) {\n-            return 3;\n-        } else if ((x & (-1 << 28)) == 0) {\n-            return 4;\n-        }\n-        return 5;\n+  /**\n+   * The number of bytes required for a variable size int.\n+   *\n+   * @param x the value\n+   * @return the len\n+   */\n+  private static int getVarIntLen(int x) {\n+    if ((x & (-1 << 7)) == 0) {\n+      return 1;\n+    } else if ((x & (-1 << 14)) == 0) {\n+      return 2;\n+    } else if ((x & (-1 << 21)) == 0) {\n+      return 3;\n+    } else if ((x & (-1 << 28)) == 0) {\n+      return 4;\n     }\n+    return 5;\n+  }\n \n-    /**\n-     * Write a variable size int.\n-     *\n-     * @param x the value\n-     */\n-    public void writeVarInt(int x) {\n-        while ((x & ~0x7f) != 0) {\n-            data[pos++] = (byte) (0x80 | (x & 0x7f));\n-            x >>>= 7;\n-        }\n-        data[pos++] = (byte) x;\n+  /**\n+   * Write a variable size int.\n+   *\n+   * @param x the value\n+   */\n+  public void writeVarInt(int x) {\n+    while ((x & ~0x7f) != 0) {\n+      data[pos++] = (byte) (0x80 | (x & 0x7f));\n+      x >>>= 7;\n     }\n+    data[pos++] = (byte) x;\n+  }\n \n-    /**\n-     * Read a variable size int.\n-     *\n-     * @return the value\n-     */\n-    public int readVarInt() {\n-        int b = data[pos];\n-        if (b >= 0) {\n-            pos++;\n-            return b;\n-        }\n-        // a separate function so that this one can be inlined\n-        return readVarIntRest(b);\n+  /**\n+   * Read a variable size int.\n+   *\n+   * @return the value\n+   */\n+  public int readVarInt() {\n+    int b = data[pos];\n+    if (b >= 0) {\n+      pos++;\n+      return b;\n     }\n+    // a separate function so that this one can be inlined\n+    return readVarIntRest(b);\n+  }\n \n-    private int readVarIntRest(int b) {\n-        int x = b & 0x7f;\n-        b = data[pos + 1];\n-        if (b >= 0) {\n-            pos += 2;\n-            return x | (b << 7);\n-        }\n-        x |= (b & 0x7f) << 7;\n-        b = data[pos + 2];\n-        if (b >= 0) {\n-            pos += 3;\n-            return x | (b << 14);\n-        }\n-        x |= (b & 0x7f) << 14;\n-        b = data[pos + 3];\n-        if (b >= 0) {\n-            pos += 4;\n-            return x | b << 21;\n-        }\n-        x |= ((b & 0x7f) << 21) | (data[pos + 4] << 28);\n-        pos += 5;\n-        return x;\n+  private int readVarIntRest(int b) {\n+    int x = b & 0x7f;\n+    b = data[pos + 1];\n+    if (b >= 0) {\n+      pos += 2;\n+      return x | (b << 7);\n     }\n-\n-    /**\n-     * The number of bytes required for a variable size long.\n-     *\n-     * @param x the value\n-     * @return the len\n-     */\n-    public static int getVarLongLen(long x) {\n-        int i = 1;\n-        while (true) {\n-            x >>>= 7;\n-            if (x == 0) {\n-                return i;\n-            }\n-            i++;\n-        }\n+    x |= (b & 0x7f) << 7;\n+    b = data[pos + 2];\n+    if (b >= 0) {\n+      pos += 3;\n+      return x | (b << 14);\n     }\n-\n-    /**\n-     * Write a variable size long.\n-     *\n-     * @param x the value\n-     */\n-    public void writeVarLong(long x) {\n-        while ((x & ~0x7f) != 0) {\n-            data[pos++] = (byte) ((x & 0x7f) | 0x80);\n-            x >>>= 7;\n-        }\n-        data[pos++] = (byte) x;\n+    x |= (b & 0x7f) << 14;\n+    b = data[pos + 3];\n+    if (b >= 0) {\n+      pos += 4;\n+      return x | b << 21;\n     }\n+    x |= ((b & 0x7f) << 21) | (data[pos + 4] << 28);\n+    pos += 5;\n+    return x;\n+  }\n \n-    /**\n-     * Read a variable size long.\n-     *\n-     * @return the value\n-     */\n-    public long readVarLong() {\n-        long x = data[pos++];\n-        if (x >= 0) {\n-            return x;\n-        }\n-        x &= 0x7f;\n-        for (int s = 7;; s += 7) {\n-            long b = data[pos++];\n-            x |= (b & 0x7f) << s;\n-            if (b >= 0) {\n-                return x;\n-            }\n-        }\n+  /**\n+   * The number of bytes required for a variable size long.\n+   *\n+   * @param x the value\n+   * @return the len\n+   */\n+  public static int getVarLongLen(long x) {\n+    int i = 1;\n+    while (true) {\n+      x >>>= 7;\n+      if (x == 0) {\n+        return i;\n+      }\n+      i++;\n     }\n+  }\n \n-    /**\n-     * Check if there is still enough capacity in the buffer.\n-     * This method extends the buffer if required.\n-     *\n-     * @param plus the number of additional bytes required\n-     */\n-    public void checkCapacity(int plus) {\n-        if (pos + plus >= data.length) {\n-            // a separate method to simplify inlining\n-            expand(plus);\n-        }\n+  /**\n+   * Write a variable size long.\n+   *\n+   * @param x the value\n+   */\n+  public void writeVarLong(long x) {\n+    while ((x & ~0x7f) != 0) {\n+      data[pos++] = (byte) ((x & 0x7f) | 0x80);\n+      x >>>= 7;\n     }\n+    data[pos++] = (byte) x;\n+  }\n \n-    private void expand(int plus) {\n-        // must copy everything, because pos could be 0 and data may be\n-        // still required\n-        data = Utils.copyBytes(data, (data.length + plus) * 2);\n+  /**\n+   * Read a variable size long.\n+   *\n+   * @return the value\n+   */\n+  public long readVarLong() {\n+    long x = data[pos++];\n+    if (x >= 0) {\n+      return x;\n+    }\n+    x &= 0x7f;\n+    for (int s = 7; ; s += 7) {\n+      long b = data[pos++];\n+      x |= (b & 0x7f) << s;\n+      if (b >= 0) {\n+        return x;\n+      }\n     }\n+  }\n \n-    /**\n-     * Fill up the buffer with empty space and an (initially empty) checksum\n-     * until the size is a multiple of Constants.FILE_BLOCK_SIZE.\n-     */\n-    public void fillAligned() {\n-        // 0..6 > 8, 7..14 > 16, 15..22 > 24, ...\n-        int len = MathUtils.roundUpInt(pos + 2, Constants.FILE_BLOCK_SIZE);\n-        pos = len;\n-        if (data.length < len) {\n-            checkCapacity(len - data.length);\n-        }\n+  /**\n+   * Check if there is still enough capacity in the buffer.\n+   * This method extends the buffer if required.\n+   *\n+   * @param plus the number of additional bytes required\n+   */\n+  public void checkCapacity(int plus) {\n+    if (pos + plus >= data.length) {\n+      // a separate method to simplify inlining\n+      expand(plus);\n     }\n+  }\n \n-    /**\n-     * Copy a String from a reader to an output stream.\n-     *\n-     * @param source the reader\n-     * @param target the output stream\n-     */\n-    public static void copyString(Reader source, OutputStream target)\n-            throws IOException {\n-        char[] buff = new char[Constants.IO_BUFFER_SIZE];\n-        Data d = new Data(null, new byte[3 * Constants.IO_BUFFER_SIZE]);\n-        while (true) {\n-            int l = source.read(buff);\n-            if (l < 0) {\n-                break;\n-            }\n-            d.writeStringWithoutLength(buff, l);\n-            target.write(d.data, 0, d.pos);\n-            d.reset();\n-        }\n+  private void expand(int plus) {\n+    // must copy everything, because pos could be 0 and data may be\n+    // still required\n+    data = Utils.copyBytes(data, (data.length + plus) * 2);\n+  }\n+\n+  /**\n+   * Fill up the buffer with empty space and an (initially empty) checksum\n+   * until the size is a multiple of Constants.FILE_BLOCK_SIZE.\n+   */\n+  public void fillAligned() {\n+    // 0..6 > 8, 7..14 > 16, 15..22 > 24, ...\n+    int len = MathUtils.roundUpInt(pos + 2, Constants.FILE_BLOCK_SIZE);\n+    pos = len;\n+    if (data.length < len) {\n+      checkCapacity(len - data.length);\n     }\n+  }\n \n-    public DataHandler getHandler() {\n-        return handler;\n+  /**\n+   * Copy a String from a reader to an output stream.\n+   *\n+   * @param source the reader\n+   * @param target the output stream\n+   */\n+  public static void copyString(Reader source, OutputStream target)\n+      throws IOException {\n+    char[] buff = new char[Constants.IO_BUFFER_SIZE];\n+    Data d = new Data(null, new byte[3 * Constants.IO_BUFFER_SIZE]);\n+    while (true) {\n+      int l = source.read(buff);\n+      if (l < 0) {\n+        break;\n+      }\n+      d.writeStringWithoutLength(buff, l);\n+      target.write(d.data, 0, d.pos);\n+      d.reset();\n     }\n+  }\n+\n+  public DataHandler getHandler() {\n+    return handler;\n+  }\n \n }\n",
            "diff_size": 1480
        },
        {
            "tool": "naturalize",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/160/Data.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/naturalize/160/Data.java\nindex fc441d1684e..9da775a1864 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/160/Data.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/naturalize/160/Data.java\n@@ -91,7 +91,7 @@ public class Data {\n     private static final int LOCAL_TIME = 132;\n     private static final int LOCAL_DATE = 133;\n     private static final int LOCAL_TIMESTAMP = 134;\n-    private static final byte CUSTOM_DATA_TYPE = (byte)135;\n+    private static final byte CUSTOM_DATA_TYPE = (byte) 135;\n \n     private static final long MILLIS_PER_MINUTE = 1000 * 60;\n \n@@ -1149,9 +1149,8 @@ public class Data {\n         default:\n             if (JdbcUtils.customDataTypesHandler != null) {\n                 byte[] b = v.getBytesNoCopy();\n-                return 1 + getVarIntLen(v.getType())\n-                    + getVarIntLen(b.length) + b.length;\n-            }\n+                return 1 + getVarIntLen(v.getType()) + getVarIntLen(b.length) + b.length;\n+    }\n             throw DbException.throwInternalError(\"type=\" + v.getType());\n         }\n     }\n@@ -1379,4 +1378,4 @@ public class Data {\n         return handler;\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 5
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/160/Data.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/codebuff/160/Data.java\nindex fc441d1684e..39f10a15d57 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/160/Data.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/codebuff/160/Data.java\n@@ -63,18 +63,21 @@ import org.h2.value.ValueUuid;\n  * @author Noel Grandin\n  * @author Nicolas Fortin, Atelier SIG, IRSTV FR CNRS 24888\n  */\n+\n+\n public class Data {\n \n     /**\n      * The length of an integer value.\n      */\n+\n+\n     public static final int LENGTH_INT = 4;\n \n     /**\n      * The length of a long value.\n      */\n     private static final int LENGTH_LONG = 8;\n-\n     private static final int INT_0_15 = 32;\n     private static final int LONG_0_7 = 48;\n     private static final int DECIMAL_0_1 = 56;\n@@ -91,8 +94,7 @@ public class Data {\n     private static final int LOCAL_TIME = 132;\n     private static final int LOCAL_DATE = 133;\n     private static final int LOCAL_TIMESTAMP = 134;\n-    private static final byte CUSTOM_DATA_TYPE = (byte)135;\n-\n+    private static final byte CUSTOM_DATA_TYPE = (byte) 135;\n     private static final long MILLIS_PER_MINUTE = 1000 * 60;\n \n     /**\n@@ -122,6 +124,8 @@ public class Data {\n      * @param pos the position\n      * @param x the value\n      */\n+\n+\n     public void setInt(int pos, int x) {\n         Bits.writeInt(data, pos, x);\n     }\n@@ -132,6 +136,8 @@ public class Data {\n      *\n      * @param x the value\n      */\n+\n+\n     public void writeInt(int x) {\n         Bits.writeInt(data, pos, x);\n         pos += 4;\n@@ -143,6 +149,8 @@ public class Data {\n      *\n      * @return the value\n      */\n+\n+\n     public int readInt() {\n         int x = Bits.readInt(data, pos);\n         pos += 4;\n@@ -156,6 +164,8 @@ public class Data {\n      * @param s the string\n      * @return the number of bytes required\n      */\n+\n+\n     public static int getStringLen(String s) {\n         int len = s.length();\n         return getStringWithoutLengthLen(s, len) + getVarIntLen(len);\n@@ -172,6 +182,7 @@ public class Data {\n      * @param len the length of the string\n      * @return the number of bytes required\n      */\n+\n     private static int getStringWithoutLengthLen(String s, int len) {\n         int plus = 0;\n         for (int i = 0; i < len; i++) {\n@@ -191,6 +202,8 @@ public class Data {\n      *\n      * @return the value\n      */\n+\n+\n     public String readString() {\n         int len = readVarInt();\n         return readString(len);\n@@ -205,6 +218,7 @@ public class Data {\n      * @param len the length of the resulting string\n      * @return the String\n      */\n+\n     private String readString(int len) {\n         byte[] buff = data;\n         int p = pos;\n@@ -214,12 +228,9 @@ public class Data {\n             if (x < 0x80) {\n                 chars[i] = (char) x;\n             } else if (x >= 0xe0) {\n-                chars[i] = (char) (((x & 0xf) << 12) +\n-                        ((buff[p++] & 0x3f) << 6) +\n-                        (buff[p++] & 0x3f));\n-            } else {\n-                chars[i] = (char) (((x & 0x1f) << 6) +\n-                        (buff[p++] & 0x3f));\n+                chars[i] = (char) (((x & 0xf) << 12) + ((buff[p++] & 0x3f) << 6) + (buff[p++] & 0x3f));\n+                                      } else {\n+                chars[i] = (char) (((x & 0x1f) << 6) + (buff[p++] & 0x3f));\n             }\n         }\n         pos = p;\n@@ -232,6 +243,8 @@ public class Data {\n      *\n      * @param s the value\n      */\n+\n+\n     public void writeString(String s) {\n         int len = s.length();\n         writeVarInt(len);\n@@ -247,6 +260,7 @@ public class Data {\n      * @param s the string\n      * @param len the number of characters to write\n      */\n+\n     private void writeStringWithoutLength(String s, int len) {\n         int p = pos;\n         byte[] buff = data;\n@@ -258,7 +272,7 @@ public class Data {\n                 buff[p++] = (byte) (0xe0 | (c >> 12));\n                 buff[p++] = (byte) (((c >> 6) & 0x3f));\n                 buff[p++] = (byte) (c & 0x3f);\n-            } else {\n+                                      } else {\n                 buff[p++] = (byte) (0xc0 | (c >> 6));\n                 buff[p++] = (byte) (c & 0x3f);\n             }\n@@ -277,7 +291,7 @@ public class Data {\n                 buff[p++] = (byte) (0xe0 | (c >> 12));\n                 buff[p++] = (byte) (((c >> 6) & 0x3f));\n                 buff[p++] = (byte) (c & 0x3f);\n-            } else {\n+                                      } else {\n                 buff[p++] = (byte) (0xc0 | (c >> 6));\n                 buff[p++] = (byte) (c & 0x3f);\n             }\n@@ -293,6 +307,8 @@ public class Data {\n      * @param capacity the initial capacity of the buffer\n      * @return the buffer\n      */\n+\n+\n     public static Data create(DataHandler handler, int capacity) {\n         return new Data(handler, new byte[capacity]);\n     }\n@@ -305,6 +321,8 @@ public class Data {\n      * @param buff the data\n      * @return the buffer\n      */\n+\n+\n     public static Data create(DataHandler handler, byte[] buff) {\n         return new Data(handler, buff);\n     }\n@@ -315,6 +333,8 @@ public class Data {\n      *\n      * @return the length\n      */\n+\n+\n     public int length() {\n         return pos;\n     }\n@@ -324,6 +344,8 @@ public class Data {\n      *\n      * @return the byte array\n      */\n+\n+\n     public byte[] getBytes() {\n         return data;\n     }\n@@ -331,6 +353,8 @@ public class Data {\n     /**\n      * Set the position to 0.\n      */\n+\n+\n     public void reset() {\n         pos = 0;\n     }\n@@ -342,6 +366,8 @@ public class Data {\n      * @param off the offset in the data\n      * @param len the length in bytes\n      */\n+\n+\n     public void write(byte[] buff, int off, int len) {\n         System.arraycopy(buff, off, data, pos, len);\n         pos += len;\n@@ -355,6 +381,8 @@ public class Data {\n      * @param off the offset in the output buffer\n      * @param len the number of bytes to copy\n      */\n+\n+\n     public void read(byte[] buff, int off, int len) {\n         System.arraycopy(data, pos, buff, off, len);\n         pos += len;\n@@ -365,6 +393,8 @@ public class Data {\n      *\n      * @param x the value\n      */\n+\n+\n     public void writeByte(byte x) {\n         data[pos++] = x;\n     }\n@@ -374,6 +404,8 @@ public class Data {\n      *\n      * @return the value\n      */\n+\n+\n     public byte readByte() {\n         return data[pos++];\n     }\n@@ -383,6 +415,8 @@ public class Data {\n      *\n      * @return the long value\n      */\n+\n+\n     public long readLong() {\n         long x = Bits.readLong(data, pos);\n         pos += 8;\n@@ -394,6 +428,8 @@ public class Data {\n      *\n      * @param x the value\n      */\n+\n+\n     public void writeLong(long x) {\n         Bits.writeLong(data, pos, x);\n         pos += 8;\n@@ -404,6 +440,8 @@ public class Data {\n      *\n      * @param v the value\n      */\n+\n+\n     public void writeValue(Value v) {\n         int start = pos;\n         if (v == ValueNull.INSTANCE) {\n@@ -431,7 +469,7 @@ public class Data {\n                 writeVarInt(-x);\n             } else if (x < 16) {\n                 writeByte((byte) (INT_0_15 + x));\n-            } else {\n+                        } else {\n                 writeByte((byte) type);\n                 writeVarInt(x);\n             }\n@@ -444,7 +482,7 @@ public class Data {\n                 writeVarLong(-x);\n             } else if (x < 8) {\n                 writeByte((byte) (LONG_0_7 + x));\n-            } else {\n+                         } else {\n                 writeByte((byte) type);\n                 writeVarLong(x);\n             }\n@@ -456,7 +494,7 @@ public class Data {\n                 writeByte((byte) DECIMAL_0_1);\n             } else if (BigDecimal.ONE.equals(x)) {\n                 writeByte((byte) (DECIMAL_0_1 + 1));\n-            } else {\n+                            } else {\n                 int scale = x.scale();\n                 BigInteger b = x.unscaledValue();\n                 int bits = b.bitLength();\n@@ -702,8 +740,7 @@ public class Data {\n             }\n             DbException.throwInternalError(\"type=\" + v.getType());\n         }\n-        assert pos - start == getValueLen(v, handler)\n-                : \"value size error: got \" + (pos - start) + \" expected \" + getValueLen(v, handler);\n+        assert pos - start == getValueLen(v, handler) : \"value size error: got \" + (pos - start) + \" expected \" + getValueLen(v, handler);\n     }\n \n     /**\n@@ -711,6 +748,8 @@ public class Data {\n      *\n      * @return the value\n      */\n+\n+\n     public Value readValue() {\n         int type = data[pos++] & 255;\n         switch (type) {\n@@ -764,17 +803,14 @@ public class Data {\n         }\n         case Value.TIME:\n             // need to normalize the year, month and day\n-            return ValueTime.fromMillis(\n-                    DateTimeUtils.getTimeUTCWithoutDst(readVarLong()));\n+            return ValueTime.fromMillis(DateTimeUtils.getTimeUTCWithoutDst(readVarLong()));\n         case LOCAL_TIMESTAMP: {\n             long dateValue = readVarLong();\n             long nanos = readVarLong() * 1_000_000 + readVarLong();\n             return ValueTimestamp.fromDateValueAndNanos(dateValue, nanos);\n         }\n         case Value.TIMESTAMP: {\n-            return ValueTimestamp.fromMillisNanos(\n-                    DateTimeUtils.getTimeUTCWithoutDst(readVarLong()),\n-                    readVarInt() % 1_000_000);\n+            return ValueTimestamp.fromMillisNanos(DateTimeUtils.getTimeUTCWithoutDst(readVarLong()), readVarInt() % 1_000_000);\n         }\n         case Value.TIMESTAMP_TZ: {\n             long dateValue = readVarLong();\n@@ -817,11 +853,9 @@ public class Data {\n         case DOUBLE_0_1 + 1:\n             return ValueDouble.ONE;\n         case Value.DOUBLE:\n-            return ValueDouble.get(Double.longBitsToDouble(\n-                    Long.reverse(readVarLong())));\n+            return ValueDouble.get(Double.longBitsToDouble(Long.reverse(readVarLong())));\n         case Value.FLOAT:\n-            return ValueFloat.get(Float.intBitsToFloat(\n-                    Integer.reverse(readVarInt())));\n+            return ValueFloat.get(Float.intBitsToFloat(Integer.reverse(readVarInt())));\n         case Value.BLOB:\n         case Value.CLOB: {\n             int smallLen = readVarInt();\n@@ -833,9 +867,8 @@ public class Data {\n                 int tableId = readVarInt();\n                 long lobId = readVarLong();\n                 long precision = readVarLong();\n-                return ValueLobDb.create(type, handler, tableId,\n-                        lobId, null, precision);\n-            } else {\n+                return ValueLobDb.create(type, handler, tableId, lobId, null, precision);\n+                         } else {\n                 int tableId = readVarInt();\n                 int objectId = readVarInt();\n                 long precision = 0;\n@@ -848,11 +881,9 @@ public class Data {\n                 }\n                 if (smallLen == -2) {\n                     String filename = readString();\n-                    return ValueLob.openUnlinked(type, handler, tableId,\n-                            objectId, precision, compression, filename);\n+                    return ValueLob.openUnlinked(type, handler, tableId, objectId, precision, compression, filename);\n                 }\n-                return ValueLob.openLinked(type, handler, tableId,\n-                        objectId, precision, compression);\n+                return ValueLob.openLinked(type, handler, tableId, objectId, precision, compression);\n             }\n         }\n         case Value.ARRAY: {\n@@ -885,8 +916,7 @@ public class Data {\n             if (negative) {\n                 ordinal = ~ordinal;\n             }\n-            return ValueInterval.from(IntervalQualifier.valueOf(ordinal), negative, readVarLong(),\n-                    ordinal < 5 ? 0 : readVarLong());\n+            return ValueInterval.from(IntervalQualifier.valueOf(ordinal), negative, readVarLong(), ordinal < 5 ? 0 : readVarLong());\n         }\n         case CUSTOM_DATA_TYPE: {\n             if (JdbcUtils.customDataTypesHandler != null) {\n@@ -894,25 +924,24 @@ public class Data {\n                 int len = readVarInt();\n                 byte[] b = Utils.newBytes(len);\n                 read(b, 0, len);\n-                return JdbcUtils.customDataTypesHandler.convert(\n-                        ValueBytes.getNoCopy(b), customType);\n+                return JdbcUtils.customDataTypesHandler.convert(ValueBytes.getNoCopy(b), customType);\n             }\n             throw DbException.get(ErrorCode.UNKNOWN_DATA_TYPE_1,\n-                    \"No CustomDataTypesHandler has been set up\");\n+                                  \"No CustomDataTypesHandler has been set up\");\n         }\n         default:\n             if (type >= INT_0_15 && type < INT_0_15 + 16) {\n                 return ValueInt.get(type - INT_0_15);\n             } else if (type >= LONG_0_7 && type < LONG_0_7 + 8) {\n                 return ValueLong.get(type - LONG_0_7);\n-            } else if (type >= BYTES_0_31 && type < BYTES_0_31 + 32) {\n-                int len = type - BYTES_0_31;\n-                byte[] b = Utils.newBytes(len);\n-                read(b, 0, len);\n-                return ValueBytes.getNoCopy(b);\n+        } else if (type >= BYTES_0_31 && type < BYTES_0_31 + 32) {\n+                       int len = type - BYTES_0_31;\n+                       byte[] b = Utils.newBytes(len);\n+                       read(b, 0, len);\n+                       return ValueBytes.getNoCopy(b);\n             } else if (type >= STRING_0_31 && type < STRING_0_31 + 32) {\n-                return ValueString.get(readString(type - STRING_0_31));\n-            }\n+                   return ValueString.get(readString(type - STRING_0_31));\n+               }\n             throw DbException.get(ErrorCode.FILE_CORRUPTED_1, \"type: \" + type);\n         }\n     }\n@@ -923,6 +952,8 @@ public class Data {\n      * @param v the value\n      * @return the number of bytes required to store this value\n      */\n+\n+\n     public int getValueLen(Value v) {\n         return getValueLen(v, handler);\n     }\n@@ -934,6 +965,8 @@ public class Data {\n      * @param handler the data handler for lobs\n      * @return the number of bytes required to store this value\n      */\n+\n+\n     public static int getValueLen(Value v, DataHandler handler) {\n         if (v == ValueNull.INSTANCE) {\n             return 1;\n@@ -952,7 +985,7 @@ public class Data {\n                 return 1 + getVarIntLen(-x);\n             } else if (x < 16) {\n                 return 1;\n-            } else {\n+                        } else {\n                 return 1 + getVarIntLen(x);\n             }\n         }\n@@ -962,7 +995,7 @@ public class Data {\n                 return 1 + getVarLongLen(-x);\n             } else if (x < 8) {\n                 return 1;\n-            } else {\n+                         } else {\n                 return 1 + getVarLongLen(x);\n             }\n         }\n@@ -1026,16 +1059,14 @@ public class Data {\n         }\n         case Value.TIMESTAMP: {\n             Timestamp ts = v.getTimestamp();\n-            return 1 + getVarLongLen(DateTimeUtils.getTimeLocalWithoutDst(ts)) +\n-                    getVarIntLen(ts.getNanos() % 1_000_000);\n+            return 1 + getVarLongLen(DateTimeUtils.getTimeLocalWithoutDst(ts)) + getVarIntLen(ts.getNanos() % 1_000_000);\n         }\n         case Value.TIMESTAMP_TZ: {\n             ValueTimestampTimeZone ts = (ValueTimestampTimeZone) v;\n             long dateValue = ts.getDateValue();\n             long nanos = ts.getTimeNanos();\n             short tz = ts.getTimeZoneOffsetMins();\n-            return 1 + getVarLongLen(dateValue) + getVarLongLen(nanos) +\n-                    getVarIntLen(tz);\n+            return 1 + getVarLongLen(dateValue) + getVarLongLen(nanos) + getVarIntLen(tz);\n         }\n         case Value.GEOMETRY:\n         case Value.JAVA_OBJECT: {\n@@ -1149,8 +1180,7 @@ public class Data {\n         default:\n             if (JdbcUtils.customDataTypesHandler != null) {\n                 byte[] b = v.getBytesNoCopy();\n-                return 1 + getVarIntLen(v.getType())\n-                    + getVarIntLen(b.length) + b.length;\n+                return 1 + getVarIntLen(v.getType()) + getVarIntLen(b.length) + b.length;\n             }\n             throw DbException.throwInternalError(\"type=\" + v.getType());\n         }\n@@ -1161,6 +1191,8 @@ public class Data {\n      *\n      * @param pos the new position\n      */\n+\n+\n     public void setPos(int pos) {\n         this.pos = pos;\n     }\n@@ -1171,6 +1203,8 @@ public class Data {\n      *\n      * @param x the value\n      */\n+\n+\n     public void writeShortInt(int x) {\n         byte[] buff = data;\n         buff[pos++] = (byte) (x >> 8);\n@@ -1183,6 +1217,8 @@ public class Data {\n      *\n      * @return the value\n      */\n+\n+\n     public short readShortInt() {\n         byte[] buff = data;\n         return (short) (((buff[pos++] & 0xff) << 8) + (buff[pos++] & 0xff));\n@@ -1193,6 +1229,8 @@ public class Data {\n      *\n      * @param size the new size\n      */\n+\n+\n     public void truncate(int size) {\n         if (pos > size) {\n             byte[] buff = Arrays.copyOf(data, size);\n@@ -1207,16 +1245,17 @@ public class Data {\n      * @param x the value\n      * @return the len\n      */\n+\n     private static int getVarIntLen(int x) {\n         if ((x & (-1 << 7)) == 0) {\n             return 1;\n         } else if ((x & (-1 << 14)) == 0) {\n             return 2;\n-        } else if ((x & (-1 << 21)) == 0) {\n+                                           } else if ((x & (-1 << 21)) == 0) {\n             return 3;\n         } else if ((x & (-1 << 28)) == 0) {\n-            return 4;\n-        }\n+                                                      return 4;\n+                                                  }\n         return 5;\n     }\n \n@@ -1225,6 +1264,8 @@ public class Data {\n      *\n      * @param x the value\n      */\n+\n+\n     public void writeVarInt(int x) {\n         while ((x & ~0x7f) != 0) {\n             data[pos++] = (byte) (0x80 | (x & 0x7f));\n@@ -1238,6 +1279,8 @@ public class Data {\n      *\n      * @return the value\n      */\n+\n+\n     public int readVarInt() {\n         int b = data[pos];\n         if (b >= 0) {\n@@ -1278,6 +1321,8 @@ public class Data {\n      * @param x the value\n      * @return the len\n      */\n+\n+\n     public static int getVarLongLen(long x) {\n         int i = 1;\n         while (true) {\n@@ -1294,6 +1339,8 @@ public class Data {\n      *\n      * @param x the value\n      */\n+\n+\n     public void writeVarLong(long x) {\n         while ((x & ~0x7f) != 0) {\n             data[pos++] = (byte) ((x & 0x7f) | 0x80);\n@@ -1307,6 +1354,8 @@ public class Data {\n      *\n      * @return the value\n      */\n+\n+\n     public long readVarLong() {\n         long x = data[pos++];\n         if (x >= 0) {\n@@ -1328,6 +1377,8 @@ public class Data {\n      *\n      * @param plus the number of additional bytes required\n      */\n+\n+\n     public void checkCapacity(int plus) {\n         if (pos + plus >= data.length) {\n             // a separate method to simplify inlining\n@@ -1345,6 +1396,8 @@ public class Data {\n      * Fill up the buffer with empty space and an (initially empty) checksum\n      * until the size is a multiple of Constants.FILE_BLOCK_SIZE.\n      */\n+\n+\n     public void fillAligned() {\n         // 0..6 > 8, 7..14 > 16, 15..22 > 24, ...\n         int len = MathUtils.roundUpInt(pos + 2, Constants.FILE_BLOCK_SIZE);\n@@ -1360,8 +1413,9 @@ public class Data {\n      * @param source the reader\n      * @param target the output stream\n      */\n-    public static void copyString(Reader source, OutputStream target)\n-            throws IOException {\n+\n+\n+    public static void copyString(Reader source, OutputStream target) throws IOException {\n         char[] buff = new char[Constants.IO_BUFFER_SIZE];\n         Data d = new Data(null, new byte[3 * Constants.IO_BUFFER_SIZE]);\n         while (true) {\n@@ -1375,8 +1429,9 @@ public class Data {\n         }\n     }\n \n+\n     public DataHandler getHandler() {\n         return handler;\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 132
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/160/Data.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_random/160/Data.java\nindex fc441d1684e..7f7a60e5ae7 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/160/Data.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_random/160/Data.java\n@@ -91,7 +91,7 @@ public class Data {\n     private static final int LOCAL_TIME = 132;\n     private static final int LOCAL_DATE = 133;\n     private static final int LOCAL_TIMESTAMP = 134;\n-    private static final byte CUSTOM_DATA_TYPE = (byte)135;\n+    private static final byte CUSTOM_DATA_TYPE = (byte) 135;\n \n     private static final long MILLIS_PER_MINUTE = 1000 * 60;\n \n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/160/Data.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/160/Data.java\nindex fc441d1684e..7f7a60e5ae7 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/160/Data.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/160/Data.java\n@@ -91,7 +91,7 @@ public class Data {\n     private static final int LOCAL_TIME = 132;\n     private static final int LOCAL_DATE = 133;\n     private static final int LOCAL_TIMESTAMP = 134;\n-    private static final byte CUSTOM_DATA_TYPE = (byte)135;\n+    private static final byte CUSTOM_DATA_TYPE = (byte) 135;\n \n     private static final long MILLIS_PER_MINUTE = 1000 * 60;\n \n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": []
}