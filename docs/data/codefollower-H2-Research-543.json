{
    "project_name": "codefollower-H2-Research",
    "error_id": "543",
    "information": {
        "errors": [
            {
                "line": "275",
                "column": "11",
                "severity": "warning",
                "message": "File contains tab characters (this is the first instance).",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
            }
        ]
    },
    "source_code": "//<<<<<<< HEAD\n//        if (!bigger) {\n//        \t//\u5bf9\u4e8eEND\u7684\u573a\u666f\uff0c\u6bd4\u5982\u5047\u8bbea=10\uff0cb=20\uff0c\u6240\u4ee5a.compareTo(b)<0\uff0c\u5373comp=-1\uff0c\u6240\u4ee5comp = -comp = 1\n//        \t//\u5bf9\u4e8ef < 10 and f < 20\u7684\u573a\u666f\uff0c\u663e\u7136\u53ea\u8981f<10\u5c31\u591f\u4e86\uff0c\u6240\u4ee5comp>0\u65f6\u8fd8\u662f\u8fd4\u56dea\n//            comp = -comp;\n//        }",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "275",
                    "column": "11",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "276",
                    "column": "11",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/543/IndexCursor.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/543/IndexCursor.java\nindex 49a4f32e404..a0887e9fad6 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/543/IndexCursor.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/543/IndexCursor.java\n@@ -3,6 +3,7 @@\n  * and the EPL 1.0 (http://h2database.com/html/license.html).\n  * Initial Developer: H2 Group\n  */\n+\n package org.h2.index;\n \n import java.util.ArrayList;\n@@ -35,241 +36,241 @@ import org.h2.value.ValueNull;\n //\u6bd4\u5982where id>10 and id<20\uff0c\u5c31\u610f\u5473\u7740\u8981\u627e(10\uff0c20)\u8fd9\u4e2a\u533a\u95f4\u5185\u7684\u8bb0\u5f55\u3002\n public class IndexCursor implements Cursor {\n \n-    private Session session;\n-    private final TableFilter tableFilter;\n-    private Index index;\n-    private Table table;\n-    private IndexColumn[] indexColumns;\n-    private boolean alwaysFalse;\n+  private Session session;\n+  private final TableFilter tableFilter;\n+  private Index index;\n+  private Table table;\n+  private IndexColumn[] indexColumns;\n+  private boolean alwaysFalse;\n \n-    private SearchRow start, end, intersects;\n-    private Cursor cursor;\n-    private Column inColumn;\n-    private int inListIndex;\n-    private Value[] inList;\n-    private ResultInterface inResult;\n-    private HashSet<Value> inResultTested;\n+  private SearchRow start, end, intersects;\n+  private Cursor cursor;\n+  private Column inColumn;\n+  private int inListIndex;\n+  private Value[] inList;\n+  private ResultInterface inResult;\n+  private HashSet<Value> inResultTested;\n \n-    public IndexCursor(TableFilter filter) {\n-        this.tableFilter = filter;\n-    }\n+  public IndexCursor(TableFilter filter) {\n+    this.tableFilter = filter;\n+  }\n \n-    public void setIndex(Index index) {\n-        this.index = index;\n-        this.table = index.getTable();\n-        Column[] columns = table.getColumns();\n-        //\u628a\u8868\u4e2d\u7684\u6240\u6709\u5b57\u6bb5\u505a\u4e00\u4e0b\u6807\u8bb0\uff0c\u5982\u679c\u662f\u7d22\u5f15\u5b57\u6bb5\uff0c\u90a3\u4e48\u5bf9\u5e94indexColumns\u6570\u7ec4\u4e2d\u7684\u5143\u7d20\u4e0d\u4e3anull\n-        indexColumns = new IndexColumn[columns.length];\n-        IndexColumn[] idxCols = index.getIndexColumns();\n-        if (idxCols != null) {\n-            for (int i = 0, len = columns.length; i < len; i++) {\n-                int idx = index.getColumnIndex(columns[i]);\n-                if (idx >= 0) {\n-                    indexColumns[i] = idxCols[idx];\n-                }\n-            }\n+  public void setIndex(Index index) {\n+    this.index = index;\n+    this.table = index.getTable();\n+    Column[] columns = table.getColumns();\n+    //\u628a\u8868\u4e2d\u7684\u6240\u6709\u5b57\u6bb5\u505a\u4e00\u4e0b\u6807\u8bb0\uff0c\u5982\u679c\u662f\u7d22\u5f15\u5b57\u6bb5\uff0c\u90a3\u4e48\u5bf9\u5e94indexColumns\u6570\u7ec4\u4e2d\u7684\u5143\u7d20\u4e0d\u4e3anull\n+    indexColumns = new IndexColumn[columns.length];\n+    IndexColumn[] idxCols = index.getIndexColumns();\n+    if (idxCols != null) {\n+      for (int i = 0, len = columns.length; i < len; i++) {\n+        int idx = index.getColumnIndex(columns[i]);\n+        if (idx >= 0) {\n+          indexColumns[i] = idxCols[idx];\n         }\n+      }\n     }\n+  }\n \n-    /**\n-     * Prepare this index cursor to make a lookup in index.\n-     *\n-     * @param s Session.\n-     * @param indexConditions Index conditions.\n-     */\n-    public void prepare(Session s, ArrayList<IndexCondition> indexConditions) {\n-        this.session = s;\n-        alwaysFalse = false;\n-        start = end = null;\n-        inList = null;\n-        inColumn = null;\n-        inResult = null;\n-        inResultTested = null;\n-        intersects = null;\n+  /**\n+   * Prepare this index cursor to make a lookup in index.\n+   *\n+   * @param s               Session.\n+   * @param indexConditions Index conditions.\n+   */\n+  public void prepare(Session s, ArrayList<IndexCondition> indexConditions) {\n+    this.session = s;\n+    alwaysFalse = false;\n+    start = end = null;\n+    inList = null;\n+    inColumn = null;\n+    inResult = null;\n+    inResultTested = null;\n+    intersects = null;\n //<<<<<<< HEAD\n //        // don't use enhanced for loop to avoid creating objects\n //        for (int i = 0, size = indexConditions.size(); i < size; i++) {\n //            IndexCondition condition = indexConditions.get(i);\n //            if (condition.isAlwaysFalse()) { //\u5982: \"select * from IndexCursorTest where 2>3\n //=======\n-        for (IndexCondition condition : indexConditions) {\n-            if (condition.isAlwaysFalse()) {\n-                alwaysFalse = true;\n-                break;\n-            }\n-            // If index can perform only full table scan do not try to use it for regular\n-            // lookups, each such lookup will perform an own table scan.\n-            if (index.isFindUsingFullTableScan()) {\n-                continue;\n-            }\n-            Column column = condition.getColumn();\n-            if (condition.getCompareType() == Comparison.IN_LIST) {\n-                if (start == null && end == null) {\n-                    if (canUseIndexForIn(column)) {\n-                        this.inColumn = column;\n-                        inList = condition.getCurrentValueList(s);\n-                        inListIndex = 0;\n-                    }\n-                }\n-            } else if (condition.getCompareType() == Comparison.IN_QUERY) {\n-                if (start == null && end == null) {\n-                    if (canUseIndexForIn(column)) {\n-                        this.inColumn = column;\n-                        inResult = condition.getCurrentResult();\n-                    }\n-                }\n-            } else {\n-                Value v = condition.getCurrentValue(s);\n-                boolean isStart = condition.isStart();\n-                boolean isEnd = condition.isEnd();\n-                boolean isIntersects = condition.isSpatialIntersects();\n-                int columnId = column.getColumnId();\n-                if (columnId != SearchRow.ROWID_INDEX) {\n-                    IndexColumn idxCol = indexColumns[columnId];\n-                    if (idxCol != null && (idxCol.sortType & SortOrder.DESCENDING) != 0) {\n-                        // if the index column is sorted the other way, we swap\n-                        // end and start NULLS_FIRST / NULLS_LAST is not a\n-                        // problem, as nulls never match anyway\n-                        boolean temp = isStart;\n-                        isStart = isEnd;\n-                        isEnd = temp;\n-                    }\n-                }\n-                if (isStart) {\n-                    start = getSearchRow(start, columnId, v, true);\n-                }\n-                if (isEnd) {\n-                    end = getSearchRow(end, columnId, v, false);\n-                }\n-                if (isIntersects) {\n-                    intersects = getSpatialSearchRow(intersects, columnId, v);\n-                }\n-                // An X=? condition will produce less rows than\n-                // an X IN(..) condition, unless the X IN condition can use the index.\n-                if ((isStart || isEnd) && !canUseIndexFor(inColumn)) {\n-                    inColumn = null;\n-                    inList = null;\n-                    inResult = null;\n-                }\n-                //\u5f53OPTIMIZE_IS_NULL\u8bbe\u4e3afalse\u65f6\uff0c\n-                //\u5bf9\u4e8e\u8fd9\u6837\u7684SELECT rownum, * FROM JoinTest1 LEFT OUTER JOIN JoinTest2 ON name2=null\n-                //\u8fd8\u662f\u4f1a\u8fd4\u56deJoinTest1\u7684\u6240\u6709\u8bb0\u5f55\uff0cJoinTest2\u4e2d\u7684\u5168\u4e3anull\n-                if (!session.getDatabase().getSettings().optimizeIsNull) {\n-                    if (isStart && isEnd) {\n-                        if (v == ValueNull.INSTANCE) {\n-                            // join on a column=NULL is always false\n-                            alwaysFalse = true;\n-                        }\n-                    }\n-                }\n-            }\n+    for (IndexCondition condition : indexConditions) {\n+      if (condition.isAlwaysFalse()) {\n+        alwaysFalse = true;\n+        break;\n+      }\n+      // If index can perform only full table scan do not try to use it for regular\n+      // lookups, each such lookup will perform an own table scan.\n+      if (index.isFindUsingFullTableScan()) {\n+        continue;\n+      }\n+      Column column = condition.getColumn();\n+      if (condition.getCompareType() == Comparison.IN_LIST) {\n+        if (start == null && end == null) {\n+          if (canUseIndexForIn(column)) {\n+            this.inColumn = column;\n+            inList = condition.getCurrentValueList(s);\n+            inListIndex = 0;\n+          }\n         }\n-        if (inColumn != null) {\n-            start = table.getTemplateRow();\n+      } else if (condition.getCompareType() == Comparison.IN_QUERY) {\n+        if (start == null && end == null) {\n+          if (canUseIndexForIn(column)) {\n+            this.inColumn = column;\n+            inResult = condition.getCurrentResult();\n+          }\n         }\n-    }\n-\n-    /**\n-     * Re-evaluate the start and end values of the index search for rows.\n-     *\n-     * @param s the session\n-     * @param indexConditions the index conditions\n-     */\n-    public void find(Session s, ArrayList<IndexCondition> indexConditions) {\n-        prepare(s, indexConditions);\n-        if (inColumn != null) {\n-            return;\n+      } else {\n+        Value v = condition.getCurrentValue(s);\n+        boolean isStart = condition.isStart();\n+        boolean isEnd = condition.isEnd();\n+        boolean isIntersects = condition.isSpatialIntersects();\n+        int columnId = column.getColumnId();\n+        if (columnId != SearchRow.ROWID_INDEX) {\n+          IndexColumn idxCol = indexColumns[columnId];\n+          if (idxCol != null && (idxCol.sortType & SortOrder.DESCENDING) != 0) {\n+            // if the index column is sorted the other way, we swap\n+            // end and start NULLS_FIRST / NULLS_LAST is not a\n+            // problem, as nulls never match anyway\n+            boolean temp = isStart;\n+            isStart = isEnd;\n+            isEnd = temp;\n+          }\n+        }\n+        if (isStart) {\n+          start = getSearchRow(start, columnId, v, true);\n+        }\n+        if (isEnd) {\n+          end = getSearchRow(end, columnId, v, false);\n         }\n-        if (!alwaysFalse) {\n-            if (intersects != null && index instanceof SpatialIndex) {\n-                cursor = ((SpatialIndex) index).findByGeometry(tableFilter,\n-                        start, end, intersects);\n-            } else {\n-                cursor = index.find(tableFilter, start, end);\n+        if (isIntersects) {\n+          intersects = getSpatialSearchRow(intersects, columnId, v);\n+        }\n+        // An X=? condition will produce less rows than\n+        // an X IN(..) condition, unless the X IN condition can use the index.\n+        if ((isStart || isEnd) && !canUseIndexFor(inColumn)) {\n+          inColumn = null;\n+          inList = null;\n+          inResult = null;\n+        }\n+        //\u5f53OPTIMIZE_IS_NULL\u8bbe\u4e3afalse\u65f6\uff0c\n+        //\u5bf9\u4e8e\u8fd9\u6837\u7684SELECT rownum, * FROM JoinTest1 LEFT OUTER JOIN JoinTest2 ON name2=null\n+        //\u8fd8\u662f\u4f1a\u8fd4\u56deJoinTest1\u7684\u6240\u6709\u8bb0\u5f55\uff0cJoinTest2\u4e2d\u7684\u5168\u4e3anull\n+        if (!session.getDatabase().getSettings().optimizeIsNull) {\n+          if (isStart && isEnd) {\n+            if (v == ValueNull.INSTANCE) {\n+              // join on a column=NULL is always false\n+              alwaysFalse = true;\n             }\n+          }\n         }\n+      }\n+    }\n+    if (inColumn != null) {\n+      start = table.getTemplateRow();\n     }\n+  }\n \n-    private boolean canUseIndexForIn(Column column) {\n-        if (inColumn != null) {\n-            // only one IN(..) condition can be used at the same time\n-            return false;\n-        }\n-        return canUseIndexFor(column);\n+  /**\n+   * Re-evaluate the start and end values of the index search for rows.\n+   *\n+   * @param s               the session\n+   * @param indexConditions the index conditions\n+   */\n+  public void find(Session s, ArrayList<IndexCondition> indexConditions) {\n+    prepare(s, indexConditions);\n+    if (inColumn != null) {\n+      return;\n+    }\n+    if (!alwaysFalse) {\n+      if (intersects != null && index instanceof SpatialIndex) {\n+        cursor = ((SpatialIndex) index).findByGeometry(tableFilter,\n+            start, end, intersects);\n+      } else {\n+        cursor = index.find(tableFilter, start, end);\n+      }\n     }\n+  }\n \n-    private boolean canUseIndexFor(Column column) {\n-        // The first column of the index must match this column,\n-        // or it must be a VIEW index (where the column is null).\n-        // Multiple IN conditions with views are not supported, see\n-        // IndexCondition.getMask.\n-        IndexColumn[] cols = index.getIndexColumns();\n-        if (cols == null) {\n-            return true;\n-        }\n-        IndexColumn idxCol = cols[0];\n-        //idxCol.column == column\u8fd9\u4e2a\u6761\u4ef6\u80af\u5b9a\u662f\u6ee1\u8db3\u7684\uff0c\u56e0\u4e3a\u5728\u6839\u636ewhere\u6784\u9020\u7d22\u5f15\u6761\u4ef6\u65f6\uff0c\u8fd9\u4e2a\u5b57\u6bb5\u5c31\u662f\u7b2c\u4e00\u4e2a\u7d22\u5f15\u5b57\u6bb5\n-        return idxCol == null || idxCol.column == column;\n+  private boolean canUseIndexForIn(Column column) {\n+    if (inColumn != null) {\n+      // only one IN(..) condition can be used at the same time\n+      return false;\n     }\n+    return canUseIndexFor(column);\n+  }\n \n-    private SearchRow getSpatialSearchRow(SearchRow row, int columnId, Value v) {\n-        if (row == null) {\n-            row = table.getTemplateRow();\n-        } else if (row.getValue(columnId) != null) {\n-            // if an object needs to overlap with both a and b,\n-            // then it needs to overlap with the the union of a and b\n-            // (not the intersection)\n-            ValueGeometry vg = (ValueGeometry) row.getValue(columnId).\n-                    convertTo(Value.GEOMETRY);\n-            v = ((ValueGeometry) v.convertTo(Value.GEOMETRY)).\n-                    getEnvelopeUnion(vg);\n-        }\n-        if (columnId == SearchRow.ROWID_INDEX) {\n-            row.setKey(v.getLong());\n-        } else {\n-            row.setValue(columnId, v);\n-        }\n-        return row;\n+  private boolean canUseIndexFor(Column column) {\n+    // The first column of the index must match this column,\n+    // or it must be a VIEW index (where the column is null).\n+    // Multiple IN conditions with views are not supported, see\n+    // IndexCondition.getMask.\n+    IndexColumn[] cols = index.getIndexColumns();\n+    if (cols == null) {\n+      return true;\n     }\n+    IndexColumn idxCol = cols[0];\n+    //idxCol.column == column\u8fd9\u4e2a\u6761\u4ef6\u80af\u5b9a\u662f\u6ee1\u8db3\u7684\uff0c\u56e0\u4e3a\u5728\u6839\u636ewhere\u6784\u9020\u7d22\u5f15\u6761\u4ef6\u65f6\uff0c\u8fd9\u4e2a\u5b57\u6bb5\u5c31\u662f\u7b2c\u4e00\u4e2a\u7d22\u5f15\u5b57\u6bb5\n+    return idxCol == null || idxCol.column == column;\n+  }\n \n-    private SearchRow getSearchRow(SearchRow row, int columnId, Value v, boolean max) {\n-        if (row == null) {\n-            row = table.getTemplateRow();\n-        } else {\n-            v = getMax(row.getValue(columnId), v, max);\n-        }\n-        if (columnId == SearchRow.ROWID_INDEX) {\n-            row.setKey(v.getLong());\n-        } else {\n-            row.setValue(columnId, v);\n-        }\n-        return row;\n+  private SearchRow getSpatialSearchRow(SearchRow row, int columnId, Value v) {\n+    if (row == null) {\n+      row = table.getTemplateRow();\n+    } else if (row.getValue(columnId) != null) {\n+      // if an object needs to overlap with both a and b,\n+      // then it needs to overlap with the the union of a and b\n+      // (not the intersection)\n+      ValueGeometry vg = (ValueGeometry) row.getValue(columnId).\n+          convertTo(Value.GEOMETRY);\n+      v = ((ValueGeometry) v.convertTo(Value.GEOMETRY)).\n+          getEnvelopeUnion(vg);\n+    }\n+    if (columnId == SearchRow.ROWID_INDEX) {\n+      row.setKey(v.getLong());\n+    } else {\n+      row.setValue(columnId, v);\n     }\n+    return row;\n+  }\n \n-    private Value getMax(Value a, Value b, boolean bigger) {\n-        if (a == null) {\n-            return b;\n-        } else if (b == null) {\n-            return a;\n-        }\n-        if (session.getDatabase().getSettings().optimizeIsNull) {\n-            // IS NULL must be checked later\n-            if (a == ValueNull.INSTANCE) {\n-                return b;\n-            } else if (b == ValueNull.INSTANCE) {\n-                return a;\n-            }\n-        }\n-        int comp = table.getDatabase().compare(a, b);\n-        if (comp == 0) {\n-            return a;\n-        }\n-        if (a == ValueNull.INSTANCE || b == ValueNull.INSTANCE) {\n-            if (session.getDatabase().getSettings().optimizeIsNull) {\n-                // column IS NULL AND column <op> <not null> is always false\n-                return null;\n-            }\n-        }\n+  private SearchRow getSearchRow(SearchRow row, int columnId, Value v, boolean max) {\n+    if (row == null) {\n+      row = table.getTemplateRow();\n+    } else {\n+      v = getMax(row.getValue(columnId), v, max);\n+    }\n+    if (columnId == SearchRow.ROWID_INDEX) {\n+      row.setKey(v.getLong());\n+    } else {\n+      row.setValue(columnId, v);\n+    }\n+    return row;\n+  }\n+\n+  private Value getMax(Value a, Value b, boolean bigger) {\n+    if (a == null) {\n+      return b;\n+    } else if (b == null) {\n+      return a;\n+    }\n+    if (session.getDatabase().getSettings().optimizeIsNull) {\n+      // IS NULL must be checked later\n+      if (a == ValueNull.INSTANCE) {\n+        return b;\n+      } else if (b == ValueNull.INSTANCE) {\n+        return a;\n+      }\n+    }\n+    int comp = table.getDatabase().compare(a, b);\n+    if (comp == 0) {\n+      return a;\n+    }\n+    if (a == ValueNull.INSTANCE || b == ValueNull.INSTANCE) {\n+      if (session.getDatabase().getSettings().optimizeIsNull) {\n+        // column IS NULL AND column <op> <not null> is always false\n+        return null;\n+      }\n+    }\n //<<<<<<< HEAD\n //        if (!bigger) {\n //        \t//\u5bf9\u4e8eEND\u7684\u573a\u666f\uff0c\u6bd4\u5982\u5047\u8bbea=10\uff0cb=20\uff0c\u6240\u4ee5a.compareTo(b)<0\uff0c\u5373comp=-1\uff0c\u6240\u4ee5comp = -comp = 1\n@@ -278,100 +279,100 @@ public class IndexCursor implements Cursor {\n //        }\n //        return comp > 0 ? a : b;\n //=======\n-        return (comp > 0) == bigger ? a : b;\n-    }\n+    return (comp > 0) == bigger ? a : b;\n+  }\n \n-    /**\n-     * Check if the result is empty for sure.\n-     *\n-     * @return true if it is\n-     */\n-    public boolean isAlwaysFalse() {\n-        return alwaysFalse;\n-    }\n+  /**\n+   * Check if the result is empty for sure.\n+   *\n+   * @return true if it is\n+   */\n+  public boolean isAlwaysFalse() {\n+    return alwaysFalse;\n+  }\n \n-    /**\n-     * Get start search row.\n-     *\n-     * @return search row\n-     */\n-    public SearchRow getStart() {\n-        return start;\n-    }\n+  /**\n+   * Get start search row.\n+   *\n+   * @return search row\n+   */\n+  public SearchRow getStart() {\n+    return start;\n+  }\n \n-    /**\n-     * Get end search row.\n-     *\n-     * @return search row\n-     */\n-    public SearchRow getEnd() {\n-        return end;\n-    }\n+  /**\n+   * Get end search row.\n+   *\n+   * @return search row\n+   */\n+  public SearchRow getEnd() {\n+    return end;\n+  }\n \n-    @Override\n-    public Row get() {\n-        if (cursor == null) {\n-            return null;\n-        }\n-        return cursor.get();\n+  @Override\n+  public Row get() {\n+    if (cursor == null) {\n+      return null;\n     }\n+    return cursor.get();\n+  }\n \n-    @Override\n-    public SearchRow getSearchRow() {\n-        return cursor.getSearchRow();\n-    }\n+  @Override\n+  public SearchRow getSearchRow() {\n+    return cursor.getSearchRow();\n+  }\n \n-    @Override\n-    public boolean next() {\n-        while (true) {\n-            if (cursor == null) {\n-                nextCursor();\n-                if (cursor == null) {\n-                    return false;\n-                }\n-            }\n-            if (cursor.next()) {\n-                return true;\n-            }\n-            cursor = null;\n+  @Override\n+  public boolean next() {\n+    while (true) {\n+      if (cursor == null) {\n+        nextCursor();\n+        if (cursor == null) {\n+          return false;\n         }\n+      }\n+      if (cursor.next()) {\n+        return true;\n+      }\n+      cursor = null;\n     }\n+  }\n \n-    private void nextCursor() {\n-        if (inList != null) {\n-            while (inListIndex < inList.length) {\n-                Value v = inList[inListIndex++];\n-                if (v != ValueNull.INSTANCE) {\n-                    find(v);\n-                    break;\n-                }\n-            }\n-        } else if (inResult != null) {\n-            while (inResult.next()) {\n-                Value v = inResult.currentRow()[0];\n-                if (v != ValueNull.INSTANCE) {\n-                    if (inResultTested == null) {\n-                        inResultTested = new HashSet<>();\n-                    }\n-                    if (inResultTested.add(v)) {\n-                        find(v);\n-                        break;\n-                    }\n-                }\n-            }\n+  private void nextCursor() {\n+    if (inList != null) {\n+      while (inListIndex < inList.length) {\n+        Value v = inList[inListIndex++];\n+        if (v != ValueNull.INSTANCE) {\n+          find(v);\n+          break;\n         }\n+      }\n+    } else if (inResult != null) {\n+      while (inResult.next()) {\n+        Value v = inResult.currentRow()[0];\n+        if (v != ValueNull.INSTANCE) {\n+          if (inResultTested == null) {\n+            inResultTested = new HashSet<>();\n+          }\n+          if (inResultTested.add(v)) {\n+            find(v);\n+            break;\n+          }\n+        }\n+      }\n     }\n+  }\n \n-    private void find(Value v) {\n-        v = inColumn.convert(v);\n-        int id = inColumn.getColumnId();\n-        start.setValue(id, v);\n-        cursor = index.find(tableFilter, start, start);\n-    }\n+  private void find(Value v) {\n+    v = inColumn.convert(v);\n+    int id = inColumn.getColumnId();\n+    start.setValue(id, v);\n+    cursor = index.find(tableFilter, start, start);\n+  }\n \n-    @Override\n-    public boolean previous() {\n-        throw DbException.throwInternalError(toString());\n-    }\n+  @Override\n+  public boolean previous() {\n+    throw DbException.throwInternalError(toString());\n+  }\n \n }\n",
            "diff_size": 386
        },
        {
            "tool": "naturalize",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/543/IndexCursor.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/naturalize/543/IndexCursor.java\nindex 49a4f32e404..385dccbba8a 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/543/IndexCursor.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/naturalize/543/IndexCursor.java\n@@ -86,13 +86,8 @@ public class IndexCursor implements Cursor {\n         inResult = null;\n         inResultTested = null;\n         intersects = null;\n-//<<<<<<< HEAD\n-//        // don't use enhanced for loop to avoid creating objects\n-//        for (int i = 0, size = indexConditions.size(); i < size; i++) {\n-//            IndexCondition condition = indexConditions.get(i);\n-//            if (condition.isAlwaysFalse()) { //\u5982: \"select * from IndexCursorTest where 2>3\n-//=======\n-        for (IndexCondition condition : indexConditions) {\n+//<<<<<<< H\n+for (IndexCondition condition : indexConditions) {\n             if (condition.isAlwaysFalse()) {\n                 alwaysFalse = true;\n                 break;\n@@ -271,14 +266,8 @@ public class IndexCursor implements Cursor {\n             }\n         }\n //<<<<<<< HEAD\n-//        if (!bigger) {\n-//        \t//\u5bf9\u4e8eEND\u7684\u573a\u666f\uff0c\u6bd4\u5982\u5047\u8bbea=10\uff0cb=20\uff0c\u6240\u4ee5a.compareTo(b)<0\uff0c\u5373comp=-1\uff0c\u6240\u4ee5comp = -comp = 1\n-//        \t//\u5bf9\u4e8ef < 10 and f < 20\u7684\u573a\u666f\uff0c\u663e\u7136\u53ea\u8981f<10\u5c31\u591f\u4e86\uff0c\u6240\u4ee5comp>0\u65f6\u8fd8\u662f\u8fd4\u56dea\n-//            comp = -comp;\n-//        }\n-//        return comp > 0 ? a : b;\n-//=======\n-        return (comp > 0) == bigger ? a : b;\n+\n+return (comp > 0) == bigger ? a : b;\n     }\n \n     /**\n@@ -374,4 +363,4 @@ public class IndexCursor implements Cursor {\n         throw DbException.throwInternalError(toString());\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 16
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/543/IndexCursor.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/codebuff/543/IndexCursor.java\nindex 49a4f32e404..77050f98635 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/543/IndexCursor.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/codebuff/543/IndexCursor.java\n@@ -7,7 +7,6 @@ package org.h2.index;\n \n import java.util.ArrayList;\n import java.util.HashSet;\n-\n import org.h2.engine.Session;\n import org.h2.expression.Comparison;\n import org.h2.message.DbException;\n@@ -33,6 +32,8 @@ import org.h2.value.ValueNull;\n  */\n //\u6839\u636ewhere\u6761\u4ef6\u4e2d\u7684\u503c\u6765\u5224\u65adindex\u4ece\u54ea\u91cc\u5f00\u59cb\u627e\u4ece\u54ea\u91cc\u7ed3\u675f\uff0c\n //\u6bd4\u5982where id>10 and id<20\uff0c\u5c31\u610f\u5473\u7740\u8981\u627e(10\uff0c20)\u8fd9\u4e2a\u533a\u95f4\u5185\u7684\u8bb0\u5f55\u3002\n+\n+\n public class IndexCursor implements Cursor {\n \n     private Session session;\n@@ -41,7 +42,6 @@ public class IndexCursor implements Cursor {\n     private Table table;\n     private IndexColumn[] indexColumns;\n     private boolean alwaysFalse;\n-\n     private SearchRow start, end, intersects;\n     private Cursor cursor;\n     private Column inColumn;\n@@ -54,6 +54,7 @@ public class IndexCursor implements Cursor {\n         this.tableFilter = filter;\n     }\n \n+\n     public void setIndex(Index index) {\n         this.index = index;\n         this.table = index.getTable();\n@@ -77,6 +78,8 @@ public class IndexCursor implements Cursor {\n      * @param s Session.\n      * @param indexConditions Index conditions.\n      */\n+\n+\n     public void prepare(Session s, ArrayList<IndexCondition> indexConditions) {\n         this.session = s;\n         alwaysFalse = false;\n@@ -118,7 +121,7 @@ public class IndexCursor implements Cursor {\n                         inResult = condition.getCurrentResult();\n                     }\n                 }\n-            } else {\n+                                                         } else {\n                 Value v = condition.getCurrentValue(s);\n                 boolean isStart = condition.isStart();\n                 boolean isEnd = condition.isEnd();\n@@ -175,6 +178,8 @@ public class IndexCursor implements Cursor {\n      * @param s the session\n      * @param indexConditions the index conditions\n      */\n+\n+\n     public void find(Session s, ArrayList<IndexCondition> indexConditions) {\n         prepare(s, indexConditions);\n         if (inColumn != null) {\n@@ -182,8 +187,7 @@ public class IndexCursor implements Cursor {\n         }\n         if (!alwaysFalse) {\n             if (intersects != null && index instanceof SpatialIndex) {\n-                cursor = ((SpatialIndex) index).findByGeometry(tableFilter,\n-                        start, end, intersects);\n+                cursor = ((SpatialIndex) index).findByGeometry(tableFilter, start, end, intersects);\n             } else {\n                 cursor = index.find(tableFilter, start, end);\n             }\n@@ -219,10 +223,8 @@ public class IndexCursor implements Cursor {\n             // if an object needs to overlap with both a and b,\n             // then it needs to overlap with the the union of a and b\n             // (not the intersection)\n-            ValueGeometry vg = (ValueGeometry) row.getValue(columnId).\n-                    convertTo(Value.GEOMETRY);\n-            v = ((ValueGeometry) v.convertTo(Value.GEOMETRY)).\n-                    getEnvelopeUnion(vg);\n+            ValueGeometry vg = (ValueGeometry) row.getValue(columnId).convertTo(Value.GEOMETRY);\n+            v = ((ValueGeometry) v.convertTo(Value.GEOMETRY)).getEnvelopeUnion(vg);\n         }\n         if (columnId == SearchRow.ROWID_INDEX) {\n             row.setKey(v.getLong());\n@@ -272,8 +274,8 @@ public class IndexCursor implements Cursor {\n         }\n //<<<<<<< HEAD\n //        if (!bigger) {\n-//        \t//\u5bf9\u4e8eEND\u7684\u573a\u666f\uff0c\u6bd4\u5982\u5047\u8bbea=10\uff0cb=20\uff0c\u6240\u4ee5a.compareTo(b)<0\uff0c\u5373comp=-1\uff0c\u6240\u4ee5comp = -comp = 1\n-//        \t//\u5bf9\u4e8ef < 10 and f < 20\u7684\u573a\u666f\uff0c\u663e\u7136\u53ea\u8981f<10\u5c31\u591f\u4e86\uff0c\u6240\u4ee5comp>0\u65f6\u8fd8\u662f\u8fd4\u56dea\n+//          //\u5bf9\u4e8eEND\u7684\u573a\u666f\uff0c\u6bd4\u5982\u5047\u8bbea=10\uff0cb=20\uff0c\u6240\u4ee5a.compareTo(b)<0\uff0c\u5373comp=-1\uff0c\u6240\u4ee5comp = -comp = 1\n+//          //\u5bf9\u4e8ef < 10 and f < 20\u7684\u573a\u666f\uff0c\u663e\u7136\u53ea\u8981f<10\u5c31\u591f\u4e86\uff0c\u6240\u4ee5comp>0\u65f6\u8fd8\u662f\u8fd4\u56dea\n //            comp = -comp;\n //        }\n //        return comp > 0 ? a : b;\n@@ -286,6 +288,8 @@ public class IndexCursor implements Cursor {\n      *\n      * @return true if it is\n      */\n+\n+\n     public boolean isAlwaysFalse() {\n         return alwaysFalse;\n     }\n@@ -295,6 +299,8 @@ public class IndexCursor implements Cursor {\n      *\n      * @return search row\n      */\n+\n+\n     public SearchRow getStart() {\n         return start;\n     }\n@@ -304,6 +310,8 @@ public class IndexCursor implements Cursor {\n      *\n      * @return search row\n      */\n+\n+\n     public SearchRow getEnd() {\n         return end;\n     }\n@@ -351,7 +359,7 @@ public class IndexCursor implements Cursor {\n                 Value v = inResult.currentRow()[0];\n                 if (v != ValueNull.INSTANCE) {\n                     if (inResultTested == null) {\n-                        inResultTested = new HashSet<>();\n+                        inResultTested = new HashSet< >();\n                     }\n                     if (inResultTested.add(v)) {\n                         find(v);\n@@ -374,4 +382,4 @@ public class IndexCursor implements Cursor {\n         throw DbException.throwInternalError(toString());\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 26
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "275",
                    "column": "11",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "275",
                    "column": "11",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ],
    "repaired_by": [
        "naturalize",
        "codebuff"
    ],
    "not_repaired_by": [
        "styler",
        "intellij",
        "styler_random",
        "styler_three_grams"
    ]
}