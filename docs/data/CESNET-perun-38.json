{
    "project_name": "CESNET-perun",
    "error_id": "38",
    "information": {
        "errors": [
            {
                "line": "624",
                "severity": "error",
                "message": "Line has trailing spaces.",
                "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
            }
        ]
    },
    "source_code": "\t\tlog.debug(\"Fetched destinations: \" + ( (destinations == null) ?  \"[]\" : destinations.toString()));\n\t\ttask.setDestinations(destinations);\n\t\tif(task.getExecService().getExecServiceType().equals(ExecServiceType.SEND) && \n\t\t   (destinations == null || destinations.isEmpty())) {\n\t\t\tlog.info(\"Task [] has no destination, setting to error.\");\n\t\t\ttask.setEndTime(new Date(System.currentTimeMillis()));",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/38/TaskSchedulerImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/styler/38/TaskSchedulerImpl.java\nindex 2f9ccae80cf..f100d04fb16 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/38/TaskSchedulerImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/styler/38/TaskSchedulerImpl.java\n@@ -621,8 +621,7 @@ public class TaskSchedulerImpl implements TaskScheduler {\n \t\t}\n \t\tlog.debug(\"Fetched destinations: \" + ( (destinations == null) ?  \"[]\" : destinations.toString()));\n \t\ttask.setDestinations(destinations);\n-\t\tif(task.getExecService().getExecServiceType().equals(ExecServiceType.SEND) && \n-\t\t   (destinations == null || destinations.isEmpty())) {\n+\t\tif(task.getExecService().getExecServiceType().equals(ExecServiceType.SEND) && (destinations == null || destinations.isEmpty())) {\n \t\t\tlog.info(\"Task [] has no destination, setting to error.\");\n \t\t\ttask.setEndTime(new Date(System.currentTimeMillis()));\n \t\t\tschedulingPool.setTaskStatus(task, TaskStatus.ERROR);\n",
            "diff_size": 2
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/38/TaskSchedulerImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/intellij/38/TaskSchedulerImpl.java\nindex 2f9ccae80cf..151a037d619 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/38/TaskSchedulerImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/intellij/38/TaskSchedulerImpl.java\n@@ -38,645 +38,645 @@ import cz.metacentrum.perun.taskslib.dao.ExecServiceDependencyDao.DependencyScop\n @org.springframework.stereotype.Service(value = \"taskScheduler\")\n public class TaskSchedulerImpl implements TaskScheduler {\n \n-\tprivate final static Logger log = LoggerFactory.getLogger(TaskSchedulerImpl.class);\n-\n-\t@Autowired\n-\tprivate SchedulingPool schedulingPool;\n-\t@Autowired\n-\tprivate DependenciesResolver dependenciesResolver;\n-\t@Autowired\n-\tprivate PerunBl perun;\n-\tprivate PerunSession perunSession;\n-\t@Autowired\n-\tprivate Properties dispatcherPropertiesBean;\n-\t@Autowired\n-\tprivate DispatcherQueuePool dispatcherQueuePool;\n-\t@Autowired\n-\tprivate DenialsResolver denialsResolver;\n-\t@Autowired\n-\tprivate GeneralServiceManager generalServiceManager;\n-\n-\n-\t@Override\n-\tpublic void processPool() throws InternalErrorException {\n-\t\tinitPerunSession();\n-\t\tlog.debug(\"pool contains \" + schedulingPool.getSize()\n-\t\t\t\t+ \" tasks in total\");\n-\t\tlog.debug(\"  \" + schedulingPool.getWaitingTasks().size()\n-\t\t\t\t+ \" tasks are going to be processed\");\n-\t\tfor (Task task : schedulingPool.getWaitingTasks()) {\n-\t\t\tif (task.getExecService().getExecServiceType()\n-\t\t\t\t\t.equals(ExecServiceType.SEND)) {\n-\t\t\t\tscheduleTask(task);\n-\t\t\t}\n-\t\t\t// GEN tasks are scheduled only as dependencies\n-\t\t}\n-\t}\n-\n-\t// TODO ensure dependant tasks with scope DESTINATION go to the same engine\n-\t@Override\n-\tpublic Boolean scheduleTask(Task task) {\n-\t\tExecService execService = task.getExecService();\n-\t\tFacility facility = task.getFacility();\n-\t\tDate time = new Date(System.currentTimeMillis());\n-\t\tDispatcherQueue dispatcherQueue = null;\n-\n-\t\tif (task.getStatus().equals(TaskStatus.PROCESSING) && !task.isPropagationForced()) {\n-\t\t\tlog.debug(\"Task {} already processing, will not schedule again.\",\n-\t\t\t\t\ttask.toString());\n-\t\t\treturn true;\n-\t\t}\n-\n-\t\tlog.debug(\"Scheduling TASK \" + task.toString());\n-\t\ttry {\n-\t\t\tdispatcherQueue = schedulingPool.getQueueForTask(task);\n-\t\t\tlog.debug(\"Task {} is assigned to queue {}\", task.getId(), (dispatcherQueue == null) ? \"null\" : dispatcherQueue.getClientID());\n-\t\t} catch (InternalErrorException e) {\n-\t\t\tlog.warn(\"Task {} is not assigned to any queue\", task.getId());\n-\t\t}\n-\t\t// check if the engine is still registered\n-\t\tif(dispatcherQueue != null &&\n-\t\t\t\t!dispatcherQueuePool.isThereDispatcherQueueForClient(dispatcherQueue.getClientID())) {\n-\t\t\tdispatcherQueue = null;\n-\t\t}\n-\t\tif (dispatcherQueue == null) {\n-\t\t\t// where should we send the task?\n-\t\t\tdispatcherQueue = dispatcherQueuePool.getAvailableQueue();\n-\t\t\tif(dispatcherQueue != null) {\n-\t\t\t\ttry {\n-\t\t\t\t\tschedulingPool.setQueueForTask(task, dispatcherQueue);\n-\t\t\t\t} catch (InternalErrorException e) {\n-\t\t\t\t\tlog.error(\"Could not set client queue for task {}: {}\", task.getId(), e.getMessage());\n-\t\t\t\t\treturn true;\n-\t\t\t\t}\n-\t\t\t\tlog.debug(\"Assigned new queue \"\n-\t\t\t\t\t\t+ dispatcherQueue.getQueueName() + \" to task \"\n-\t\t\t\t\t\t+ task.getId());\n-\t\t\t} else {\n-\t\t\t\t// bad luck...\n-\t\t\t\tlog.error(\"Task \"\n-\t\t\t\t\t\t+ task.toString()\n-\t\t\t\t\t\t+ \" has no engine assigned and there are no engines registered...\");\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t}\n-\n-\t\tlog.debug(\"Facility to be processed: \" + facility.getId()\n-\t\t\t\t+ \", ExecService to be processed: \" + execService.getId());\n-\n-\n-\t\tBoolean abortTask = false;\n-\t\ttry {\n-\t\t\trefetchTaskInformation(task);\n-\t\t\tList<Service> assignedServices = perun.getServicesManagerBl().getAssignedServices(perunSession, task.getFacility());\n-\t\t\tif (!assignedServices.contains(execService.getService())) {\n-\t\t\t\tlog.debug(\"Task {} has no longer service {} assigned, aborting.\", task.getId(), execService.getId());\n-\t\t\t\tabortTask = true;\n-\t\t\t}\n-\t\t} catch (FacilityNotExistsException e1) {\n-\t\t\tlog.debug(\"Facility {} for task {} no longer exists, aborting\", facility.getId(), task.getId());\n-\t\t\tabortTask = true;\n-\t\t} catch (ServiceNotExistsException e1) {\n-\t\t\tlog.debug(\"Service {} for task {} no longer exists, aborting\", execService.getId(), task.getId());\n-\t\t\tabortTask = true;\n-\t\t} catch (InternalErrorException e1) {\n-\t\t\tlog.error(\"Error checking facility or exec service for updates, task will not run now: {}\", e1.getMessage());\n-\t\t\treturn true;\n-\t\t} catch (PrivilegeException e1) {\n-\t\t\tlog.error(\"Error checking facility or exec service for updates, task will not run now: {}\", e1.getMessage());\n-\t\t\treturn true;\n-\t\t}\n-\t\t// SEND tasks will be aborted later - we have to go on and try to schedule (and abort)\n-\t\t// GEN tasks that we depend on...\n-\t\tif(abortTask && execService.getExecServiceType() == ExecServiceType.GENERATE) {\n-\t\t\t// GEN tasks may be aborted immediately\n-\t\t\tabortTask(task);\n-\t\t\treturn false;\n-\t\t}\n-\n-\t\t// We have to be carefull from now on - the facility and/or exec service contained\n-\t\t// in this task may no longer be valid with respect to the actual database (ie. when abortTask == true).\n-\t\t// On the other hand, the objects themselves are still here, so they may be referenced in code.\n-\n-\t\t// do not perform further checks for task that is going to be aborted\n-\t\tif(!abortTask) {\n-\n-\t\t\tlog.debug(\"Is the execService ID:\" + execService.getId() + \" enabled globally?\");\n-\t\t\tif (execService.isEnabled()) {\n-\t\t\t\tlog.debug(\"   Yes, it is globally enabled.\");\n-\t\t\t} else {\n-\t\t\t\tlog.debug(\"   No, execService ID: \"+ execService.getId() + \" is not enabled globally. Task will not run.\");\n-\t\t\t\treturn true;\n-\t\t\t}\n-\n-\t\t\tlog.debug(\"   Is the execService ID: \" + execService.getId() + \" denied on facility ID:\" + facility.getId() + \"?\");\n-\t\t\ttry {\n-\t\t\t\tif (!denialsResolver.isExecServiceDeniedOnFacility(execService, facility)) {\n-\t\t\t\t\tlog.debug(\"   No, it is not.\");\n-\t\t\t\t} else {\n-\t\t\t\t\tlog.debug(\"   Yes, the execService ID: \" + execService.getId() + \" is denied on facility ID: \"\n-\t\t\t\t\t\t\t+ facility.getId() + \". Task will not run.\");\n-\t\t\t\t\treturn true;\n-\t\t\t\t}\n-\t\t\t} catch (InternalErrorException e) {\n-\t\t\t\tlog.error(\"Error getting disabled status for execService, task will not run now.\");\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t}\n-\n-\t\tList<ExecService> dependantServices = null;\n-\t\tList<Pair<ExecService, DependencyScope>> dependencies = null;\n-\n-\t\t// If any of the ExecServices that depends on this one is running\n-\t\t// PROCESSING\n-\t\t// we will put the ExecService,Facility pair back to the pool.\n-\t\t// #################################################################################\n-\t\tlog.debug(\"   Is there any execService that depends on [\"\n-\t\t\t\t+ execService.getId() + \"] in \\\"PROCESSING\\\" state?\");\n-\t\tdependantServices = dependenciesResolver.listDependantServices(execService);\n-\t\tboolean proceed = true;\n-\t\tfor (ExecService dependantService : dependantServices) {\n-\t\t\tTask dependantServiceTask = schedulingPool.getTask(\n-\t\t\t\t\tdependantService, facility);\n-\t\t\tif (dependantServiceTask != null) {\n-\t\t\t\tif (dependantServiceTask.getStatus().equals(\n-\t\t\t\t\t\tTaskStatus.PROCESSING)) {\n-\t\t\t\t\tlog.debug(\"   There is a service [\" + dependantServiceTask.getId()\n-\t\t\t\t\t\t\t+ \"] running that depends on this one [\"\n-\t\t\t\t\t\t\t+ execService + \"], so we put this to sleep...\");\n-\t\t\t\t\t// schedulingPool.addToPool(new Pair<ExecService,\n-\t\t\t\t\t// Facility>(execService, facility));\n-\t\t\t\t\tproceed = false;\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t\t// This is probably wrong, so commenting out:\n-\t\t\t\t//   1) if there is some dispatcher queue active at the moment, dispatcherQueue is not null\n-\t\t\t\t//   2) if there is no dispatcher queue available, no point in setting the same queue another task has\n-\t\t\t\t//   3) the dependency should be handled the other way round, from dependant to dependent\n-\t\t\t\t/*\n-\t\t\t\t * try {\n-\t\t\t\t *\tif (dispatcherQueue == null &&\n-\t\t\t\t *\t\t\tschedulingPool.getQueueForTask(dependantServiceTask) != null) {\n-\t\t\t\t *\t\tschedulingPool.setQueueForTask(task, schedulingPool.getQueueForTask(dependantServiceTask));\n-\t\t\t\t *\t}\n-\t\t\t\t * } catch (InternalErrorException e) {\n-\t\t\t\t *\tlog.debug(\"    Failed to set destination queue for task. This is weird, aborting.\");\n-\t\t\t\t *\tproceed = false;\n-\t\t\t\t *}\n-\t\t\t\t */\n-\t\t\t}\n-\t\t}\n-\t\tif (proceed) {\n-\t\t\tlog.debug(\"   No, it is not. No dependent service is running, we can proceed.\");\n-\t\t\t// If it is an ExecService of type SEND, we have to check its\n-\t\t\t// dependencies.\n-\t\t\t// We can skip this for GENERATE type (it has no dependencies by\n-\t\t\t// design).\n-\t\t\t// ########################################################################\n-\t\t\tlog.debug(\"   Check whether the execService [\"\n-\t\t\t\t\t+ execService.getId() + \"] is of type SEND\");\n-\t\t\tif (execService.getExecServiceType().equals(ExecServiceType.SEND)) {\n-\t\t\t\tlog.debug(\"   Well, it is, so we have to check it's dependencies.\");\n-\t\t\t\t// We check the status of all the ExecServices this ExecService\n-\t\t\t\t// depends on.\n-\t\t\t\t//\n-\t\t\t\t//\n-\t\t\t\t// Current approach disregards any SEND/GENERATE differences.\n-\t\t\t\t// Dependency on a GENERATE service is being treated as same as\n-\t\t\t\t// any other SEND dependency\n-\t\t\t\t// but for a small exception regarding ERROR and DONE states,\n-\t\t\t\t// see below:\n-\t\t\t\t//\n-\t\t\t\t// If the dependency is in one of the following states, we do:\n-\t\t\t\t// NONE Schedule it and wait (put this [ExecService,Facility]\n-\t\t\t\t// pair back to the SchedulingPool for a while).\n-\t\t\t\t// PROCESSING Wait\n-\t\t\t\t// ERROR IF dependency is GENERATE THEN DO\n-\t\t\t\t// Schedule it and wait (put this [ExecService,Facility] pair\n-\t\t\t\t// back to the SchedulingPool for a while).\n-\t\t\t\t// ELSE IF dependency is SEND THEN DO\n-\t\t\t\t// End with ERROR. (no point in trying, something is probably\n-\t\t\t\t// amiss on destination nodes...)\n-\t\t\t\t// ELSE\n-\t\t\t\t// throw new IllegalArgumentException\n-\t\t\t\t// FI\n-\t\t\t\t// DONE IF dependency is GENERATE THEN DO\n-\t\t\t\t// Schedule it and wait (put this [ExecService,Facility] pair\n-\t\t\t\t// back to the SchedulingPool for a while).\n-\t\t\t\t//\n-\t\t\t\t// It might look like we get an infinite loop where GENERATE\n-\t\t\t\t// will be in DONE and then rescheduled again and again.\n-\t\t\t\t// It is not so because PropagationMaintainer sets its state to\n-\t\t\t\t// NONE as soon as the SEND, that depends on it,\n-\t\t\t\t// enters either DONE or ERROR states (one of its finite\n-\t\t\t\t// states).\n-\t\t\t\t// ELSE IF dependency is SEND THEN DO\n-\t\t\t\t// Proceed (Yes, no need to schedule this dependency, it is done\n-\t\t\t\t// already and we don't care for how long it has been so at this\n-\t\t\t\t// point.)\n-\t\t\t\t// ELSE\n-\t\t\t\t// throw new IllegalArgumentException\n-\t\t\t\t// FI\n-\t\t\t\t// :-)\n-\t\t\t\t// #######################################################################################################\n-\t\t\t\tproceed = true;\n-\t\t\t\tdependencies = dependenciesResolver.listDependenciesAndScope(execService);\n-\t\t\t\tlog.debug(\"   We are about to loop over execService [\"\n-\t\t\t\t\t\t+ execService.getId() + \"] dependencies.\");\n-\t\t\t\tlog.debug(\"   Number of dependencies:\" + dependencies);\n-\t\t\t\tDispatcherQueue dependencyQueue = null;\n-\t\t\t\tfor (Pair<ExecService, DependencyScope> dependencyPair : dependencies) {\n-\t\t\t\t\tExecService dependency = dependencyPair.getLeft();\n-\t\t\t\t\tDependencyScope dependencyScope = dependencyPair.getRight();\n-\t\t\t\t\tTask dependencyServiceTask = schedulingPool.getTask(dependency, facility);\n-\t\t\t\t\tif (dependencyServiceTask == null) {\n-\t\t\t\t\t\tif(abortTask) {\n-\t\t\t\t\t\t\tlog.info(\"   Task {} is going to be aborted, the dependency exec service {} will not be scheduled now.\",\n-\t\t\t\t\t\t\t\t\ttask.getId(), dependency.getId());\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t// Dependency being NULL is equivalent to being in NONE\n-\t\t\t\t\t\t\t// state.\n-\t\t\t\t\t\t\tlog.info(\"   Last Task [dependency:\"\n-\t\t\t\t\t\t\t\t\t+ dependency.getId() + \", facility:\"\n-\t\t\t\t\t\t\t\t\t+ facility.getId()\n-\t\t\t\t\t\t\t\t\t+ \"] was NULL, we are gonna propagate.\");\n-\t\t\t\t\t\t\tif(scheduleItAndWait(dependency, facility, execService,\n-\t\t\t\t\t\t\t\t\tdispatcherQueue, time)) {\n-\t\t\t\t\t\t\t\t// task sucessfully scheduled, nothing to do\n-\t\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t\t// TODO: task aborted - maybe set this one to error?\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tproceed = false;\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tboolean wasDependencyServiceTaskForced = dependencyServiceTask.isPropagationForced();\n-\t\t\t\t\t\tdependencyServiceTask.setPropagationForced(task.isPropagationForced());\n-\t\t\t\t\t\tswitch (dependencyServiceTask.getStatus()) {\n-\t\t\t\t\t\tcase DONE:\n-\t\t\t\t\t\t\tswitch (dependency.getExecServiceType()) {\n-\t\t\t\t\t\t\tcase GENERATE:\n-\t\t\t\t\t\t\t\tif(task.isSourceUpdated()) {\n-\t\t\t\t\t\t\t\t\t// we need to reschedule the GEN task as the source data has changed\n-\t\t\t\t\t\t\t\t\tlog.debug(\"   Dependency ID \"\n-\t\t\t\t\t\t\t\t\t\t\t+ dependency.getId()\n-\t\t\t\t\t\t\t\t\t\t\t+ \" is in DONE and is going to be rescheduled as we need fresh data.\");\n-\t\t\t\t\t\t\t\t\trescheduleTask(dependencyServiceTask, execService, dispatcherQueue);\n-\t\t\t\t\t\t\t\t\tproceed = false;\n-\t\t\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t\t\tlog.debug(\"   Dependency ID \"\n-\t\t\t\t\t\t\t\t\t\t\t+ dependency.getId()\n-\t\t\t\t\t\t\t\t\t\t\t+ \" is in DONE and it is of type GENERATE, we can proceed.\");\n-\t\t\t\t\t\t\t\t\t// Nothing, we can proceed...\n-\t\t\t\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\t\t\t\tdependencyQueue = schedulingPool.getQueueForTask(dependencyServiceTask);\n-\t\t\t\t\t\t\t\t\t} catch (InternalErrorException e) {\n-\t\t\t\t\t\t\t\t\t\tlog.error(\"Could not get queue for task {}\", dependencyServiceTask.getId());\n-\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t\tcase SEND:\n-\t\t\t\t\t\t\t\tlog.debug(\"   Dependency ID \"\n-\t\t\t\t\t\t\t\t\t\t+ dependencyServiceTask.getId()\n-\t\t\t\t\t\t\t\t\t\t+ \" is in DONE and it is of type SEND, we can proceed.\");\n-\t\t\t\t\t\t\t\t// Nothing, we can proceed...\n-\t\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t\tdefault:\n-\t\t\t\t\t\t\t\tthrow new IllegalArgumentException(\n-\t\t\t\t\t\t\t\t\t\t\"Unknown ExecService type. Expected GENERATE or SEND.\");\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\tcase ERROR:\n-\t\t\t\t\t\t\tswitch (dependency.getExecServiceType()) {\n-\t\t\t\t\t\t\tcase GENERATE:\n-\t\t\t\t\t\t\t\tlog.info(\"   Dependency ID \"\n-\t\t\t\t\t\t\t\t\t\t+ dependencyServiceTask.getId()\n-\t\t\t\t\t\t\t\t\t\t+ \" is in ERROR and it is of type GENERATE, we are gonna propagate.\");\n-\t\t\t\t\t\t\t\t// scheduleItAndWait(dependency, facility,\n-\t\t\t\t\t\t\t\t// execService, dispatcherQueue);\n-\t\t\t\t\t\t\t\t// try to run the generate task again\n-\t\t\t\t\t\t\t\trescheduleTask(dependencyServiceTask, execService, dispatcherQueue);\n-\t\t\t\t\t\t\t\tproceed = false;\n-\t\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t\tcase SEND:\n-\t\t\t\t\t\t\t\tlog.info(\"   Dependency ID \"\n-\t\t\t\t\t\t\t\t\t\t+ dependencyServiceTask.getId()\n-\t\t\t\t\t\t\t\t\t\t+ \" is in ERROR and it is of type SEND, we are gonna end with ERROR.\");\n-\t\t\t\t\t\t\t\tproceed = false;\n-\t\t\t\t\t\t\t\t// We end Task with error immediately.\n-\t\t\t\t\t\t\t\tschedulingPool.setTaskStatus(task, TaskStatus.ERROR);\n-\t\t\t\t\t\t\t\t// manipulateTasks(execService, facility, task);\n-\n-\t\t\t\t\t\t\t\t// And we set all its GENERATE dependencies as\n-\t\t\t\t\t\t\t\t// \"dirty\" by switching them to NONE state.\n-\t\t\t\t\t\t\t\t// Note: Yes, there might have been some stored\n-\t\t\t\t\t\t\t\t// from the previous runs...\n-\t\t\t\t\t\t\t\t// propagationMaintainer.setAllGenerateDependenciesToNone(dependencies,\n-\t\t\t\t\t\t\t\t// facility);\n-\t\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t\tdefault:\n-\t\t\t\t\t\t\t\tthrow new IllegalArgumentException(\n-\t\t\t\t\t\t\t\t\t\t\"Unknown ExecService type. Expected GENERATE or SEND.\");\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\tcase NONE:\n-\t\t\t\t\t\t\tlog.info(\"   Last Task {} [dependency:\"\n-\t\t\t\t\t\t\t\t\t+ dependency.getId() + \", facility:\"\n-\t\t\t\t\t\t\t\t\t+ facility.getId()\n-\t\t\t\t\t\t\t\t\t+ \"] was NONE, we are gonna propagate.\", dependencyServiceTask.getId());\n-\t\t\t\t\t\t\trescheduleTask(dependencyServiceTask, execService,\n-\t\t\t\t\t\t\t\t\tdispatcherQueue);\n-\t\t\t\t\t\t\tproceed = false;\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\tcase PLANNED:\n-\t\t\t\t\t\t\tlog.info(\"   Dependency ID \" + dependencyServiceTask.getId()\n-\t\t\t\t\t\t\t\t\t+ \" is in PLANNED so we are gonna wait.\");\n-\t\t\t\t\t\t\t// we do not need to put it back in pool here\n-\t\t\t\t\t\t\t// justWait(facility, execService);\n-\t\t\t\t\t\t\tif (dependencyScope.equals(DependencyScope.SERVICE)) {\n-\t\t\t\t\t\t\t\tproceed = false;\n-\t\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\t\t\tdependencyQueue = schedulingPool.getQueueForTask(dependencyServiceTask);\n-\t\t\t\t\t\t\t\t} catch (InternalErrorException e) {\n-\t\t\t\t\t\t\t\t\tlog.error(\"Could not get queue for task {}\", dependencyServiceTask.getId());\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\tcase PROCESSING:\n-\t\t\t\t\t\t\tlog.info(\"   Dependency ID \" + dependencyServiceTask.getId()\n-\t\t\t\t\t\t\t\t\t+ \" is in PROCESSING so we are gonna wait.\");\n-\t\t\t\t\t\t\t// we do not need to put it back in pool here\n-\t\t\t\t\t\t\t// justWait(facility, execService);\n-\t\t\t\t\t\t\tif (dependencyScope.equals(DependencyScope.SERVICE)) {\n-\t\t\t\t\t\t\t\tproceed = false;\n-\t\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\t\t\tdependencyQueue = schedulingPool.getQueueForTask(dependencyServiceTask);\n-\t\t\t\t\t\t\t\t} catch (InternalErrorException e) {\n-\t\t\t\t\t\t\t\t\tlog.error(\"Could not get queue for task {}\", dependencyServiceTask.getId());\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tif(dependencyServiceTask.isPropagationForced() && !wasDependencyServiceTaskForced) {\n-\t\t\t\t\t\t\t\t// reschedule dependant only if originally was not forced !!!\n-\t\t\t\t\t\t\t\trescheduleTask(dependencyServiceTask, execService, dispatcherQueue);\n-\t\t\t\t\t\t\t\t// XXX - should we proceed here?\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\tdefault:\n-\t\t\t\t\t\t\tthrow new IllegalArgumentException(\n-\t\t\t\t\t\t\t\t\t\"Unknown Task status. Expected DONE, ERROR, NONE, PLANNED or PROCESSING.\");\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\t// Finally, if we can proceed, we proceed...\n-\t\t\t\t// #########################################\n-\t\t\t\tif (proceed) {\n-\t\t\t\t\tif(abortTask) {\n-\t\t\t\t\t\t// the SEND task is going to be aborted now\n-\t\t\t\t\t\tabortTask(task);\n-\t\t\t\t\t\treturn false;\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tif(dependencyQueue != null && dependencyQueue != dispatcherQueue) {\n-\t\t\t\t\t\t\tlog.debug(\"Changing task {} destination queue to {} to match dependency task\",\n-\t\t\t\t\t\t\t\t\ttask.getId(), dependencyQueue.getClientID());\n-\t\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\t\tschedulingPool.setQueueForTask(task, dependencyQueue);\n-\t\t\t\t\t\t\t} catch (InternalErrorException e) {\n-\t\t\t\t\t\t\t\tlog.error(\"Could not change task {} destination queue: {}\",\n-\t\t\t\t\t\t\t\t\t\ttask.getId(), e.getMessage());\n-\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tlog.info(\"   SCHEDULING task [\" + task.getId() + \"], execService [\"\n-\t\t\t\t\t\t\t\t+ execService.getId() + \"] facility [\"\n-\t\t\t\t\t\t\t\t+ facility.getId() + \"] as PLANNED.\");\n-\t\t\t\t\t\ttask.setSchedule(time);\n-\t\t\t\t\t\tschedulingPool.setTaskStatus(task, TaskStatus.PLANNED);\n-\t\t\t\t\t\tsendToEngine(task);\n-\t\t\t\t\t}\n-\t\t\t\t\t// manipulateTasks(execService, facility, task);\n-\t\t\t\t} else {\n-\t\t\t\t\tif(abortTask) {\n-\t\t\t\t\t\t// the SEND task is going to be aborted now\n-\t\t\t\t\t\tabortTask(task);\n-\t\t\t\t\t\treturn false;\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\t// If we can not proceed, we just end here.\n-\t\t\t\t\t\t// ########################################\n-\t\t\t\t\t\t// The current ExecService,Facility pair should be sleeping\n-\t\t\t\t\t\t// in SchedulingPool at the moment...\n-\t\t\t\t\t\tlog.info(\"   Task {} state set to NONE, will be scheduled again at the next cycle.\",\n-\t\t\t\t\t\t\t\ttask.getId());\n-\t\t\t\t\t\tschedulingPool.setTaskStatus(task, TaskStatus.NONE);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t} else if (execService.getExecServiceType().equals(ExecServiceType.GENERATE)) {\n-\t\t\t\tlog.debug(\"   Well, it is not. ExecService of type GENERATE does not have any dependencies by design, so we schedule it immediately.\");\n-\t\t\t\tlog.info(\"   SCHEDULING task [\" + task.getId() + \"], execService [\" + execService.getId()\n-\t\t\t\t\t\t+ \"] facility [\" + facility.getId() + \"] as PLANNED.\");\n-\t\t\t\ttask.setSchedule(time);\n-\t\t\t\tschedulingPool.setTaskStatus(task, TaskStatus.PLANNED);\n-\t\t\t\t// we are going to run the GEN task, so reset the source updated flag to\n-\t\t\t\t// allow rerunning the GEN when data changes before the GEN is complete\n-\t\t\t\tfor (ExecService dependantService : dependantServices) {\n-\t\t\t\t\tTask dependantServiceTask = schedulingPool.getTask(dependantService, facility);\n-\t\t\t\t\tif (dependantServiceTask != null && dependantServiceTask.isSourceUpdated()) {\n-\t\t\t\t\t\tdependantServiceTask.setSourceUpdated(false);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tsendToEngine(task);\n-\t\t\t\t// manipulateTasks(execService, facility, task);\n-\t\t\t} else {\n-\t\t\t\tthrow new IllegalArgumentException(\n-\t\t\t\t\t\t\"Unknown ExecService type. Expected GENERATE or SEND.\");\n-\t\t\t}\n-\t\t} else {\n-\t\t\tlog.debug(\"   We do not proceed, we put the task [\" + task.getId() + \"], [\"\n-\t\t\t\t\t+ execService.getId() + \"] execService to sleep.\");\n-\t\t}\n-\t\treturn true;\n-\t}\n-\n-\tprivate void abortTask(Task task) {\n-\t\tlog.debug(\"Aborting task {}, removing from pool.\", task.getId());\n-\t\tschedulingPool.removeTask(task);\n-\t}\n-\n-\tprivate void refetchTaskInformation(Task task) throws FacilityNotExistsException, InternalErrorException, PrivilegeException, ServiceNotExistsException {\n-\t\t// reread facility\n-\t\tlog.debug(\"Rereading facility and  exec service for task {}\", task.getId());\n-\t\tFacility dbFacility = perun.getFacilitiesManagerBl().getFacilityById(perunSession, task.getFacilityId());\n-\t\tif(dbFacility == null) {\n-\t\t\tthrow new FacilityNotExistsException(\"No facility with id \" + task.getFacilityId());\n-\t\t}\n-\t\tBoolean taskModified = false;\n-\t\tif(!dbFacility.equals(task.getFacility())) {\n-\t\t\ttask.setFacility(dbFacility);\n-\t\t\ttaskModified = true;\n-\t\t}\n-\t\t// reread exec service (and service)\n-\t\tExecService dbExecService = generalServiceManager.getExecService(perunSession, task.getExecServiceId());\n-\t\tif(dbExecService == null) {\n-\t\t\tthrow new ServiceNotExistsException(\"No exec service with id \" + task.getExecServiceId());\n-\t\t}\n-\t\tif(!dbExecService.equals(task.getExecService())) {\n-\t\t\ttask.setExecService(dbExecService);\n-\t\t\ttaskModified = true;\n-\t\t}\n-\t\tif(taskModified) {\n-\t\t\tlog.debug(\"Task components have changed, updating task {}\", task.getId());\n-\t\t\tschedulingPool.setTaskStatus(task, task.getStatus());\n-\t\t}\n-\t}\n-\n-\tprivate Boolean scheduleItAndWait(ExecService dependency, Facility facility,\n-\t\t\tExecService execService, DispatcherQueue dispatcherQueue, Date time) {\n-\t\t// this is called to schedule dependencies of given task\n-\t\tTask task = new Task();\n-\t\ttask.setExecService(dependency);\n-\t\ttask.setFacility(facility);\n-\t\ttask.setSchedule(time);\n-\t\ttry {\n-\t\t\tschedulingPool.addToPool(task, dispatcherQueue);\n-\t\t\treturn scheduleTask(task);\n-\t\t} catch (InternalErrorException e) {\n-\t\t\tlog.error(\"Could not schedule new task: \" + e.getMessage());\n-\t\t\treturn false;\n-\t\t}\n-\t\t// schedulingPool.setTaskStatus(task, TaskStatus.NONE);\n-\t}\n-\n-\tprivate Boolean rescheduleTask(Task dependencyServiceTask,\n-\t\t\tExecService execService, DispatcherQueue dispatcherQueue) {\n-\t\t// task is in the pool already, just go for recursion\n-\t\treturn scheduleTask(dependencyServiceTask);\n-\t}\n-\n-\tprivate void sendToEngine(Task task) {\n-\t\tDispatcherQueue dispatcherQueue;\n-\t\ttry {\n-\t\t\tdispatcherQueue = schedulingPool.getQueueForTask(task);\n-\t\t} catch (InternalErrorException e1) {\n-\t\t\tlog.error(\"No engine set for task \" + task.toString()\n-\t\t\t\t\t+ \", could not send it!\");\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tif (dispatcherQueue == null) {\n-\t\t\t// where should we send the task?\n-\t\t\tif (dispatcherQueuePool.poolSize() > 0) {\n-\t\t\t\tdispatcherQueue = dispatcherQueuePool.getPool().iterator()\n-\t\t\t\t\t\t.next();\n-\t\t\t\ttry {\n-\t\t\t\t\tschedulingPool.setQueueForTask(task, dispatcherQueue);\n-\t\t\t\t} catch (InternalErrorException e) {\n-\t\t\t\t\tlog.error(\"Could not assign new queue for task {}: {}\", task.getId(), e);\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\t\t\t\tlog.debug(\"Assigned new queue \"\n-\t\t\t\t\t\t+ dispatcherQueue.getQueueName() + \" to task \"\n-\t\t\t\t\t\t+ task.getId());\n-\t\t\t} else {\n-\t\t\t\t// bad luck...\n-\t\t\t\tlog.error(\"Task \"\n-\t\t\t\t\t\t+ task.toString()\n-\t\t\t\t\t\t+ \" has no engine assigned and there are no engines registered...\");\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t}\n-\n-\t\t// task|[engine_id]|[task_id][is_forced][exec_service_id][facility]|[destination_list]|[dependency_list]\n-\t\t// - the task|[engine_id] part is added by dispatcherQueue\n-\t\tList<Destination> destinations = task.getDestinations();\n-\t\tif (destinations == null || destinations.isEmpty()) {\n-\t\t\tlog.debug(\"No destinations for task \" + task.toString()\n-\t\t\t\t\t+ \", trying to query the database...\");\n-\t\t\ttry {\n-\t\t\t\tinitPerunSession();\n-\t\t\t\tdestinations = perun.getServicesManager().getDestinations(\n-\t\t\t\t\t\tperunSession, task.getExecService().getService(),\n-\t\t\t\t\t\ttask.getFacility());\n-\t\t\t} catch (ServiceNotExistsException e) {\n-\t\t\t\tlog.error(\"No destinations found for task \" + task.getId());\n-\t\t\t\ttask.setEndTime(new Date(System.currentTimeMillis()));\n-\t\t\t\tschedulingPool.setTaskStatus(task, TaskStatus.ERROR);\n-\t\t\t\treturn;\n-\t\t\t} catch (FacilityNotExistsException e) {\n-\t\t\t\tlog.error(\"Facility for task {} does not exist...\", task.getId());\n-\t\t\t\ttask.setEndTime(new Date(System.currentTimeMillis()));\n-\t\t\t\tschedulingPool.setTaskStatus(task, TaskStatus.ERROR);\n-\t\t\t\treturn;\n-\t\t\t} catch (PrivilegeException e) {\n-\t\t\t\tlog.error(\"Privilege error accessing the database: \"\n-\t\t\t\t\t\t+ e.getMessage());\n-\t\t\t\ttask.setEndTime(new Date(System.currentTimeMillis()));\n-\t\t\t\tschedulingPool.setTaskStatus(task, TaskStatus.ERROR);\n-\t\t\t\treturn;\n-\t\t\t} catch (InternalErrorException e) {\n-\t\t\t\tlog.error(\"Internal error: \" + e.getMessage());\n-\t\t\t\ttask.setEndTime(new Date(System.currentTimeMillis()));\n-\t\t\t\tschedulingPool.setTaskStatus(task, TaskStatus.ERROR);\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t}\n-\t\tlog.debug(\"Fetched destinations: \" + ( (destinations == null) ?  \"[]\" : destinations.toString()));\n-\t\ttask.setDestinations(destinations);\n-\t\tif(task.getExecService().getExecServiceType().equals(ExecServiceType.SEND) && \n-\t\t   (destinations == null || destinations.isEmpty())) {\n-\t\t\tlog.info(\"Task [] has no destination, setting to error.\");\n-\t\t\ttask.setEndTime(new Date(System.currentTimeMillis()));\n-\t\t\tschedulingPool.setTaskStatus(task, TaskStatus.ERROR);\n-\t\t\treturn;\n-\t\t}\n-\t\tStringBuilder destinations_s = new StringBuilder(\"Destinations [\");\n-\t\tif (destinations != null) {\n-\t\t\tfor (Destination destination : destinations) {\n-\t\t\t\tdestinations_s.append(destination.serializeToString() + \", \");\n-\t\t\t}\n-\t\t}\n-\t\tdestinations_s.append(\"]\");\n-\t\tString dependencies = \"\";\n-\t\tdispatcherQueue.sendMessage(\"[\" + task.getId() + \"][\"\n-\t\t\t\t+ task.isPropagationForced() + \"]|[\"\n-\t\t\t\t+ fixStringSeparators(task.getExecService().serializeToString()) + \"]|[\"\n-\t\t\t\t+ fixStringSeparators(task.getFacility().serializeToString()) + \"]|[\"\n-\t\t\t\t+ fixStringSeparators(destinations_s.toString()) + \"]|[\" + dependencies + \"]\");\n-\t\ttask.setStartTime(new Date(System.currentTimeMillis()));\n-\t\ttask.setEndTime(null);\n-\t\tschedulingPool.setTaskStatus(task, TaskStatus.PROCESSING);\n-\t}\n-\n-\tprivate String fixStringSeparators(String data) {\n-\t\tif(data.contains(\"|\")) {\n-\t\t\treturn new String(Base64.encodeBase64(data.getBytes()));\n-\t\t} else {\n-\t\t\treturn data;\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic int getPoolSize() {\n-\t\treturn schedulingPool.getSize();\n-\t}\n-\n-\tpublic SchedulingPool getSchedulingPool() {\n-\t\treturn schedulingPool;\n-\t}\n-\n-\tpublic void setSchedulingPool(SchedulingPool schedulingPool) {\n-\t\tthis.schedulingPool = schedulingPool;\n-\t}\n-\n-\tprivate void initPerunSession() throws InternalErrorException {\n-\t\tif (perunSession == null) {\n-\t\t\tperunSession = perun\n-\t\t\t\t\t.getPerunSession(new PerunPrincipal(\n-\t\t\t\t\t\t\tdispatcherPropertiesBean.getProperty(\"perun.principal.name\"),\n-\t\t\t\t\t\t\tdispatcherPropertiesBean\n-\t\t\t\t\t\t\t\t\t.getProperty(\"perun.principal.extSourceName\"),\n-\t\t\t\t\t\t\tdispatcherPropertiesBean\n-\t\t\t\t\t\t\t\t\t.getProperty(\"perun.principal.extSourceType\")),\n-\t\t\t\t\t\t\tnew PerunClient());\n-\t\t}\n-\t}\n+    private final static Logger log = LoggerFactory.getLogger(TaskSchedulerImpl.class);\n+\n+    @Autowired\n+    private SchedulingPool schedulingPool;\n+    @Autowired\n+    private DependenciesResolver dependenciesResolver;\n+    @Autowired\n+    private PerunBl perun;\n+    private PerunSession perunSession;\n+    @Autowired\n+    private Properties dispatcherPropertiesBean;\n+    @Autowired\n+    private DispatcherQueuePool dispatcherQueuePool;\n+    @Autowired\n+    private DenialsResolver denialsResolver;\n+    @Autowired\n+    private GeneralServiceManager generalServiceManager;\n+\n+\n+    @Override\n+    public void processPool() throws InternalErrorException {\n+        initPerunSession();\n+        log.debug(\"pool contains \" + schedulingPool.getSize()\n+                + \" tasks in total\");\n+        log.debug(\"  \" + schedulingPool.getWaitingTasks().size()\n+                + \" tasks are going to be processed\");\n+        for (Task task : schedulingPool.getWaitingTasks()) {\n+            if (task.getExecService().getExecServiceType()\n+                    .equals(ExecServiceType.SEND)) {\n+                scheduleTask(task);\n+            }\n+            // GEN tasks are scheduled only as dependencies\n+        }\n+    }\n+\n+    // TODO ensure dependant tasks with scope DESTINATION go to the same engine\n+    @Override\n+    public Boolean scheduleTask(Task task) {\n+        ExecService execService = task.getExecService();\n+        Facility facility = task.getFacility();\n+        Date time = new Date(System.currentTimeMillis());\n+        DispatcherQueue dispatcherQueue = null;\n+\n+        if (task.getStatus().equals(TaskStatus.PROCESSING) && !task.isPropagationForced()) {\n+            log.debug(\"Task {} already processing, will not schedule again.\",\n+                    task.toString());\n+            return true;\n+        }\n+\n+        log.debug(\"Scheduling TASK \" + task.toString());\n+        try {\n+            dispatcherQueue = schedulingPool.getQueueForTask(task);\n+            log.debug(\"Task {} is assigned to queue {}\", task.getId(), (dispatcherQueue == null) ? \"null\" : dispatcherQueue.getClientID());\n+        } catch (InternalErrorException e) {\n+            log.warn(\"Task {} is not assigned to any queue\", task.getId());\n+        }\n+        // check if the engine is still registered\n+        if (dispatcherQueue != null &&\n+                !dispatcherQueuePool.isThereDispatcherQueueForClient(dispatcherQueue.getClientID())) {\n+            dispatcherQueue = null;\n+        }\n+        if (dispatcherQueue == null) {\n+            // where should we send the task?\n+            dispatcherQueue = dispatcherQueuePool.getAvailableQueue();\n+            if (dispatcherQueue != null) {\n+                try {\n+                    schedulingPool.setQueueForTask(task, dispatcherQueue);\n+                } catch (InternalErrorException e) {\n+                    log.error(\"Could not set client queue for task {}: {}\", task.getId(), e.getMessage());\n+                    return true;\n+                }\n+                log.debug(\"Assigned new queue \"\n+                        + dispatcherQueue.getQueueName() + \" to task \"\n+                        + task.getId());\n+            } else {\n+                // bad luck...\n+                log.error(\"Task \"\n+                        + task.toString()\n+                        + \" has no engine assigned and there are no engines registered...\");\n+                return true;\n+            }\n+        }\n+\n+        log.debug(\"Facility to be processed: \" + facility.getId()\n+                + \", ExecService to be processed: \" + execService.getId());\n+\n+\n+        Boolean abortTask = false;\n+        try {\n+            refetchTaskInformation(task);\n+            List<Service> assignedServices = perun.getServicesManagerBl().getAssignedServices(perunSession, task.getFacility());\n+            if (!assignedServices.contains(execService.getService())) {\n+                log.debug(\"Task {} has no longer service {} assigned, aborting.\", task.getId(), execService.getId());\n+                abortTask = true;\n+            }\n+        } catch (FacilityNotExistsException e1) {\n+            log.debug(\"Facility {} for task {} no longer exists, aborting\", facility.getId(), task.getId());\n+            abortTask = true;\n+        } catch (ServiceNotExistsException e1) {\n+            log.debug(\"Service {} for task {} no longer exists, aborting\", execService.getId(), task.getId());\n+            abortTask = true;\n+        } catch (InternalErrorException e1) {\n+            log.error(\"Error checking facility or exec service for updates, task will not run now: {}\", e1.getMessage());\n+            return true;\n+        } catch (PrivilegeException e1) {\n+            log.error(\"Error checking facility or exec service for updates, task will not run now: {}\", e1.getMessage());\n+            return true;\n+        }\n+        // SEND tasks will be aborted later - we have to go on and try to schedule (and abort)\n+        // GEN tasks that we depend on...\n+        if (abortTask && execService.getExecServiceType() == ExecServiceType.GENERATE) {\n+            // GEN tasks may be aborted immediately\n+            abortTask(task);\n+            return false;\n+        }\n+\n+        // We have to be carefull from now on - the facility and/or exec service contained\n+        // in this task may no longer be valid with respect to the actual database (ie. when abortTask == true).\n+        // On the other hand, the objects themselves are still here, so they may be referenced in code.\n+\n+        // do not perform further checks for task that is going to be aborted\n+        if (!abortTask) {\n+\n+            log.debug(\"Is the execService ID:\" + execService.getId() + \" enabled globally?\");\n+            if (execService.isEnabled()) {\n+                log.debug(\"   Yes, it is globally enabled.\");\n+            } else {\n+                log.debug(\"   No, execService ID: \" + execService.getId() + \" is not enabled globally. Task will not run.\");\n+                return true;\n+            }\n+\n+            log.debug(\"   Is the execService ID: \" + execService.getId() + \" denied on facility ID:\" + facility.getId() + \"?\");\n+            try {\n+                if (!denialsResolver.isExecServiceDeniedOnFacility(execService, facility)) {\n+                    log.debug(\"   No, it is not.\");\n+                } else {\n+                    log.debug(\"   Yes, the execService ID: \" + execService.getId() + \" is denied on facility ID: \"\n+                            + facility.getId() + \". Task will not run.\");\n+                    return true;\n+                }\n+            } catch (InternalErrorException e) {\n+                log.error(\"Error getting disabled status for execService, task will not run now.\");\n+                return true;\n+            }\n+        }\n+\n+        List<ExecService> dependantServices = null;\n+        List<Pair<ExecService, DependencyScope>> dependencies = null;\n+\n+        // If any of the ExecServices that depends on this one is running\n+        // PROCESSING\n+        // we will put the ExecService,Facility pair back to the pool.\n+        // #################################################################################\n+        log.debug(\"   Is there any execService that depends on [\"\n+                + execService.getId() + \"] in \\\"PROCESSING\\\" state?\");\n+        dependantServices = dependenciesResolver.listDependantServices(execService);\n+        boolean proceed = true;\n+        for (ExecService dependantService : dependantServices) {\n+            Task dependantServiceTask = schedulingPool.getTask(\n+                    dependantService, facility);\n+            if (dependantServiceTask != null) {\n+                if (dependantServiceTask.getStatus().equals(\n+                        TaskStatus.PROCESSING)) {\n+                    log.debug(\"   There is a service [\" + dependantServiceTask.getId()\n+                            + \"] running that depends on this one [\"\n+                            + execService + \"], so we put this to sleep...\");\n+                    // schedulingPool.addToPool(new Pair<ExecService,\n+                    // Facility>(execService, facility));\n+                    proceed = false;\n+                    break;\n+                }\n+                // This is probably wrong, so commenting out:\n+                //   1) if there is some dispatcher queue active at the moment, dispatcherQueue is not null\n+                //   2) if there is no dispatcher queue available, no point in setting the same queue another task has\n+                //   3) the dependency should be handled the other way round, from dependant to dependent\n+                /*\n+                 * try {\n+                 *\tif (dispatcherQueue == null &&\n+                 *\t\t\tschedulingPool.getQueueForTask(dependantServiceTask) != null) {\n+                 *\t\tschedulingPool.setQueueForTask(task, schedulingPool.getQueueForTask(dependantServiceTask));\n+                 *\t}\n+                 * } catch (InternalErrorException e) {\n+                 *\tlog.debug(\"    Failed to set destination queue for task. This is weird, aborting.\");\n+                 *\tproceed = false;\n+                 *}\n+                 */\n+            }\n+        }\n+        if (proceed) {\n+            log.debug(\"   No, it is not. No dependent service is running, we can proceed.\");\n+            // If it is an ExecService of type SEND, we have to check its\n+            // dependencies.\n+            // We can skip this for GENERATE type (it has no dependencies by\n+            // design).\n+            // ########################################################################\n+            log.debug(\"   Check whether the execService [\"\n+                    + execService.getId() + \"] is of type SEND\");\n+            if (execService.getExecServiceType().equals(ExecServiceType.SEND)) {\n+                log.debug(\"   Well, it is, so we have to check it's dependencies.\");\n+                // We check the status of all the ExecServices this ExecService\n+                // depends on.\n+                //\n+                //\n+                // Current approach disregards any SEND/GENERATE differences.\n+                // Dependency on a GENERATE service is being treated as same as\n+                // any other SEND dependency\n+                // but for a small exception regarding ERROR and DONE states,\n+                // see below:\n+                //\n+                // If the dependency is in one of the following states, we do:\n+                // NONE Schedule it and wait (put this [ExecService,Facility]\n+                // pair back to the SchedulingPool for a while).\n+                // PROCESSING Wait\n+                // ERROR IF dependency is GENERATE THEN DO\n+                // Schedule it and wait (put this [ExecService,Facility] pair\n+                // back to the SchedulingPool for a while).\n+                // ELSE IF dependency is SEND THEN DO\n+                // End with ERROR. (no point in trying, something is probably\n+                // amiss on destination nodes...)\n+                // ELSE\n+                // throw new IllegalArgumentException\n+                // FI\n+                // DONE IF dependency is GENERATE THEN DO\n+                // Schedule it and wait (put this [ExecService,Facility] pair\n+                // back to the SchedulingPool for a while).\n+                //\n+                // It might look like we get an infinite loop where GENERATE\n+                // will be in DONE and then rescheduled again and again.\n+                // It is not so because PropagationMaintainer sets its state to\n+                // NONE as soon as the SEND, that depends on it,\n+                // enters either DONE or ERROR states (one of its finite\n+                // states).\n+                // ELSE IF dependency is SEND THEN DO\n+                // Proceed (Yes, no need to schedule this dependency, it is done\n+                // already and we don't care for how long it has been so at this\n+                // point.)\n+                // ELSE\n+                // throw new IllegalArgumentException\n+                // FI\n+                // :-)\n+                // #######################################################################################################\n+                proceed = true;\n+                dependencies = dependenciesResolver.listDependenciesAndScope(execService);\n+                log.debug(\"   We are about to loop over execService [\"\n+                        + execService.getId() + \"] dependencies.\");\n+                log.debug(\"   Number of dependencies:\" + dependencies);\n+                DispatcherQueue dependencyQueue = null;\n+                for (Pair<ExecService, DependencyScope> dependencyPair : dependencies) {\n+                    ExecService dependency = dependencyPair.getLeft();\n+                    DependencyScope dependencyScope = dependencyPair.getRight();\n+                    Task dependencyServiceTask = schedulingPool.getTask(dependency, facility);\n+                    if (dependencyServiceTask == null) {\n+                        if (abortTask) {\n+                            log.info(\"   Task {} is going to be aborted, the dependency exec service {} will not be scheduled now.\",\n+                                    task.getId(), dependency.getId());\n+                        } else {\n+                            // Dependency being NULL is equivalent to being in NONE\n+                            // state.\n+                            log.info(\"   Last Task [dependency:\"\n+                                    + dependency.getId() + \", facility:\"\n+                                    + facility.getId()\n+                                    + \"] was NULL, we are gonna propagate.\");\n+                            if (scheduleItAndWait(dependency, facility, execService,\n+                                    dispatcherQueue, time)) {\n+                                // task sucessfully scheduled, nothing to do\n+                            } else {\n+                                // TODO: task aborted - maybe set this one to error?\n+                            }\n+                        }\n+                        proceed = false;\n+                    } else {\n+                        boolean wasDependencyServiceTaskForced = dependencyServiceTask.isPropagationForced();\n+                        dependencyServiceTask.setPropagationForced(task.isPropagationForced());\n+                        switch (dependencyServiceTask.getStatus()) {\n+                            case DONE:\n+                                switch (dependency.getExecServiceType()) {\n+                                    case GENERATE:\n+                                        if (task.isSourceUpdated()) {\n+                                            // we need to reschedule the GEN task as the source data has changed\n+                                            log.debug(\"   Dependency ID \"\n+                                                    + dependency.getId()\n+                                                    + \" is in DONE and is going to be rescheduled as we need fresh data.\");\n+                                            rescheduleTask(dependencyServiceTask, execService, dispatcherQueue);\n+                                            proceed = false;\n+                                        } else {\n+                                            log.debug(\"   Dependency ID \"\n+                                                    + dependency.getId()\n+                                                    + \" is in DONE and it is of type GENERATE, we can proceed.\");\n+                                            // Nothing, we can proceed...\n+                                            try {\n+                                                dependencyQueue = schedulingPool.getQueueForTask(dependencyServiceTask);\n+                                            } catch (InternalErrorException e) {\n+                                                log.error(\"Could not get queue for task {}\", dependencyServiceTask.getId());\n+                                            }\n+                                        }\n+                                        break;\n+                                    case SEND:\n+                                        log.debug(\"   Dependency ID \"\n+                                                + dependencyServiceTask.getId()\n+                                                + \" is in DONE and it is of type SEND, we can proceed.\");\n+                                        // Nothing, we can proceed...\n+                                        break;\n+                                    default:\n+                                        throw new IllegalArgumentException(\n+                                                \"Unknown ExecService type. Expected GENERATE or SEND.\");\n+                                }\n+                                break;\n+                            case ERROR:\n+                                switch (dependency.getExecServiceType()) {\n+                                    case GENERATE:\n+                                        log.info(\"   Dependency ID \"\n+                                                + dependencyServiceTask.getId()\n+                                                + \" is in ERROR and it is of type GENERATE, we are gonna propagate.\");\n+                                        // scheduleItAndWait(dependency, facility,\n+                                        // execService, dispatcherQueue);\n+                                        // try to run the generate task again\n+                                        rescheduleTask(dependencyServiceTask, execService, dispatcherQueue);\n+                                        proceed = false;\n+                                        break;\n+                                    case SEND:\n+                                        log.info(\"   Dependency ID \"\n+                                                + dependencyServiceTask.getId()\n+                                                + \" is in ERROR and it is of type SEND, we are gonna end with ERROR.\");\n+                                        proceed = false;\n+                                        // We end Task with error immediately.\n+                                        schedulingPool.setTaskStatus(task, TaskStatus.ERROR);\n+                                        // manipulateTasks(execService, facility, task);\n+\n+                                        // And we set all its GENERATE dependencies as\n+                                        // \"dirty\" by switching them to NONE state.\n+                                        // Note: Yes, there might have been some stored\n+                                        // from the previous runs...\n+                                        // propagationMaintainer.setAllGenerateDependenciesToNone(dependencies,\n+                                        // facility);\n+                                        break;\n+                                    default:\n+                                        throw new IllegalArgumentException(\n+                                                \"Unknown ExecService type. Expected GENERATE or SEND.\");\n+                                }\n+                                break;\n+                            case NONE:\n+                                log.info(\"   Last Task {} [dependency:\"\n+                                        + dependency.getId() + \", facility:\"\n+                                        + facility.getId()\n+                                        + \"] was NONE, we are gonna propagate.\", dependencyServiceTask.getId());\n+                                rescheduleTask(dependencyServiceTask, execService,\n+                                        dispatcherQueue);\n+                                proceed = false;\n+                                break;\n+                            case PLANNED:\n+                                log.info(\"   Dependency ID \" + dependencyServiceTask.getId()\n+                                        + \" is in PLANNED so we are gonna wait.\");\n+                                // we do not need to put it back in pool here\n+                                // justWait(facility, execService);\n+                                if (dependencyScope.equals(DependencyScope.SERVICE)) {\n+                                    proceed = false;\n+                                } else {\n+                                    try {\n+                                        dependencyQueue = schedulingPool.getQueueForTask(dependencyServiceTask);\n+                                    } catch (InternalErrorException e) {\n+                                        log.error(\"Could not get queue for task {}\", dependencyServiceTask.getId());\n+                                    }\n+                                }\n+                                break;\n+                            case PROCESSING:\n+                                log.info(\"   Dependency ID \" + dependencyServiceTask.getId()\n+                                        + \" is in PROCESSING so we are gonna wait.\");\n+                                // we do not need to put it back in pool here\n+                                // justWait(facility, execService);\n+                                if (dependencyScope.equals(DependencyScope.SERVICE)) {\n+                                    proceed = false;\n+                                } else {\n+                                    try {\n+                                        dependencyQueue = schedulingPool.getQueueForTask(dependencyServiceTask);\n+                                    } catch (InternalErrorException e) {\n+                                        log.error(\"Could not get queue for task {}\", dependencyServiceTask.getId());\n+                                    }\n+                                }\n+                                if (dependencyServiceTask.isPropagationForced() && !wasDependencyServiceTaskForced) {\n+                                    // reschedule dependant only if originally was not forced !!!\n+                                    rescheduleTask(dependencyServiceTask, execService, dispatcherQueue);\n+                                    // XXX - should we proceed here?\n+                                }\n+                                break;\n+                            default:\n+                                throw new IllegalArgumentException(\n+                                        \"Unknown Task status. Expected DONE, ERROR, NONE, PLANNED or PROCESSING.\");\n+                        }\n+                    }\n+                }\n+                // Finally, if we can proceed, we proceed...\n+                // #########################################\n+                if (proceed) {\n+                    if (abortTask) {\n+                        // the SEND task is going to be aborted now\n+                        abortTask(task);\n+                        return false;\n+                    } else {\n+                        if (dependencyQueue != null && dependencyQueue != dispatcherQueue) {\n+                            log.debug(\"Changing task {} destination queue to {} to match dependency task\",\n+                                    task.getId(), dependencyQueue.getClientID());\n+                            try {\n+                                schedulingPool.setQueueForTask(task, dependencyQueue);\n+                            } catch (InternalErrorException e) {\n+                                log.error(\"Could not change task {} destination queue: {}\",\n+                                        task.getId(), e.getMessage());\n+                            }\n+\n+                        }\n+                        log.info(\"   SCHEDULING task [\" + task.getId() + \"], execService [\"\n+                                + execService.getId() + \"] facility [\"\n+                                + facility.getId() + \"] as PLANNED.\");\n+                        task.setSchedule(time);\n+                        schedulingPool.setTaskStatus(task, TaskStatus.PLANNED);\n+                        sendToEngine(task);\n+                    }\n+                    // manipulateTasks(execService, facility, task);\n+                } else {\n+                    if (abortTask) {\n+                        // the SEND task is going to be aborted now\n+                        abortTask(task);\n+                        return false;\n+                    } else {\n+                        // If we can not proceed, we just end here.\n+                        // ########################################\n+                        // The current ExecService,Facility pair should be sleeping\n+                        // in SchedulingPool at the moment...\n+                        log.info(\"   Task {} state set to NONE, will be scheduled again at the next cycle.\",\n+                                task.getId());\n+                        schedulingPool.setTaskStatus(task, TaskStatus.NONE);\n+                    }\n+                }\n+            } else if (execService.getExecServiceType().equals(ExecServiceType.GENERATE)) {\n+                log.debug(\"   Well, it is not. ExecService of type GENERATE does not have any dependencies by design, so we schedule it immediately.\");\n+                log.info(\"   SCHEDULING task [\" + task.getId() + \"], execService [\" + execService.getId()\n+                        + \"] facility [\" + facility.getId() + \"] as PLANNED.\");\n+                task.setSchedule(time);\n+                schedulingPool.setTaskStatus(task, TaskStatus.PLANNED);\n+                // we are going to run the GEN task, so reset the source updated flag to\n+                // allow rerunning the GEN when data changes before the GEN is complete\n+                for (ExecService dependantService : dependantServices) {\n+                    Task dependantServiceTask = schedulingPool.getTask(dependantService, facility);\n+                    if (dependantServiceTask != null && dependantServiceTask.isSourceUpdated()) {\n+                        dependantServiceTask.setSourceUpdated(false);\n+                    }\n+                }\n+                sendToEngine(task);\n+                // manipulateTasks(execService, facility, task);\n+            } else {\n+                throw new IllegalArgumentException(\n+                        \"Unknown ExecService type. Expected GENERATE or SEND.\");\n+            }\n+        } else {\n+            log.debug(\"   We do not proceed, we put the task [\" + task.getId() + \"], [\"\n+                    + execService.getId() + \"] execService to sleep.\");\n+        }\n+        return true;\n+    }\n+\n+    private void abortTask(Task task) {\n+        log.debug(\"Aborting task {}, removing from pool.\", task.getId());\n+        schedulingPool.removeTask(task);\n+    }\n+\n+    private void refetchTaskInformation(Task task) throws FacilityNotExistsException, InternalErrorException, PrivilegeException, ServiceNotExistsException {\n+        // reread facility\n+        log.debug(\"Rereading facility and  exec service for task {}\", task.getId());\n+        Facility dbFacility = perun.getFacilitiesManagerBl().getFacilityById(perunSession, task.getFacilityId());\n+        if (dbFacility == null) {\n+            throw new FacilityNotExistsException(\"No facility with id \" + task.getFacilityId());\n+        }\n+        Boolean taskModified = false;\n+        if (!dbFacility.equals(task.getFacility())) {\n+            task.setFacility(dbFacility);\n+            taskModified = true;\n+        }\n+        // reread exec service (and service)\n+        ExecService dbExecService = generalServiceManager.getExecService(perunSession, task.getExecServiceId());\n+        if (dbExecService == null) {\n+            throw new ServiceNotExistsException(\"No exec service with id \" + task.getExecServiceId());\n+        }\n+        if (!dbExecService.equals(task.getExecService())) {\n+            task.setExecService(dbExecService);\n+            taskModified = true;\n+        }\n+        if (taskModified) {\n+            log.debug(\"Task components have changed, updating task {}\", task.getId());\n+            schedulingPool.setTaskStatus(task, task.getStatus());\n+        }\n+    }\n+\n+    private Boolean scheduleItAndWait(ExecService dependency, Facility facility,\n+                                      ExecService execService, DispatcherQueue dispatcherQueue, Date time) {\n+        // this is called to schedule dependencies of given task\n+        Task task = new Task();\n+        task.setExecService(dependency);\n+        task.setFacility(facility);\n+        task.setSchedule(time);\n+        try {\n+            schedulingPool.addToPool(task, dispatcherQueue);\n+            return scheduleTask(task);\n+        } catch (InternalErrorException e) {\n+            log.error(\"Could not schedule new task: \" + e.getMessage());\n+            return false;\n+        }\n+        // schedulingPool.setTaskStatus(task, TaskStatus.NONE);\n+    }\n+\n+    private Boolean rescheduleTask(Task dependencyServiceTask,\n+                                   ExecService execService, DispatcherQueue dispatcherQueue) {\n+        // task is in the pool already, just go for recursion\n+        return scheduleTask(dependencyServiceTask);\n+    }\n+\n+    private void sendToEngine(Task task) {\n+        DispatcherQueue dispatcherQueue;\n+        try {\n+            dispatcherQueue = schedulingPool.getQueueForTask(task);\n+        } catch (InternalErrorException e1) {\n+            log.error(\"No engine set for task \" + task.toString()\n+                    + \", could not send it!\");\n+            return;\n+        }\n+\n+        if (dispatcherQueue == null) {\n+            // where should we send the task?\n+            if (dispatcherQueuePool.poolSize() > 0) {\n+                dispatcherQueue = dispatcherQueuePool.getPool().iterator()\n+                        .next();\n+                try {\n+                    schedulingPool.setQueueForTask(task, dispatcherQueue);\n+                } catch (InternalErrorException e) {\n+                    log.error(\"Could not assign new queue for task {}: {}\", task.getId(), e);\n+                    return;\n+                }\n+                log.debug(\"Assigned new queue \"\n+                        + dispatcherQueue.getQueueName() + \" to task \"\n+                        + task.getId());\n+            } else {\n+                // bad luck...\n+                log.error(\"Task \"\n+                        + task.toString()\n+                        + \" has no engine assigned and there are no engines registered...\");\n+                return;\n+            }\n+        }\n+\n+        // task|[engine_id]|[task_id][is_forced][exec_service_id][facility]|[destination_list]|[dependency_list]\n+        // - the task|[engine_id] part is added by dispatcherQueue\n+        List<Destination> destinations = task.getDestinations();\n+        if (destinations == null || destinations.isEmpty()) {\n+            log.debug(\"No destinations for task \" + task.toString()\n+                    + \", trying to query the database...\");\n+            try {\n+                initPerunSession();\n+                destinations = perun.getServicesManager().getDestinations(\n+                        perunSession, task.getExecService().getService(),\n+                        task.getFacility());\n+            } catch (ServiceNotExistsException e) {\n+                log.error(\"No destinations found for task \" + task.getId());\n+                task.setEndTime(new Date(System.currentTimeMillis()));\n+                schedulingPool.setTaskStatus(task, TaskStatus.ERROR);\n+                return;\n+            } catch (FacilityNotExistsException e) {\n+                log.error(\"Facility for task {} does not exist...\", task.getId());\n+                task.setEndTime(new Date(System.currentTimeMillis()));\n+                schedulingPool.setTaskStatus(task, TaskStatus.ERROR);\n+                return;\n+            } catch (PrivilegeException e) {\n+                log.error(\"Privilege error accessing the database: \"\n+                        + e.getMessage());\n+                task.setEndTime(new Date(System.currentTimeMillis()));\n+                schedulingPool.setTaskStatus(task, TaskStatus.ERROR);\n+                return;\n+            } catch (InternalErrorException e) {\n+                log.error(\"Internal error: \" + e.getMessage());\n+                task.setEndTime(new Date(System.currentTimeMillis()));\n+                schedulingPool.setTaskStatus(task, TaskStatus.ERROR);\n+                return;\n+            }\n+        }\n+        log.debug(\"Fetched destinations: \" + ((destinations == null) ? \"[]\" : destinations.toString()));\n+        task.setDestinations(destinations);\n+        if (task.getExecService().getExecServiceType().equals(ExecServiceType.SEND) &&\n+                (destinations == null || destinations.isEmpty())) {\n+            log.info(\"Task [] has no destination, setting to error.\");\n+            task.setEndTime(new Date(System.currentTimeMillis()));\n+            schedulingPool.setTaskStatus(task, TaskStatus.ERROR);\n+            return;\n+        }\n+        StringBuilder destinations_s = new StringBuilder(\"Destinations [\");\n+        if (destinations != null) {\n+            for (Destination destination : destinations) {\n+                destinations_s.append(destination.serializeToString() + \", \");\n+            }\n+        }\n+        destinations_s.append(\"]\");\n+        String dependencies = \"\";\n+        dispatcherQueue.sendMessage(\"[\" + task.getId() + \"][\"\n+                + task.isPropagationForced() + \"]|[\"\n+                + fixStringSeparators(task.getExecService().serializeToString()) + \"]|[\"\n+                + fixStringSeparators(task.getFacility().serializeToString()) + \"]|[\"\n+                + fixStringSeparators(destinations_s.toString()) + \"]|[\" + dependencies + \"]\");\n+        task.setStartTime(new Date(System.currentTimeMillis()));\n+        task.setEndTime(null);\n+        schedulingPool.setTaskStatus(task, TaskStatus.PROCESSING);\n+    }\n+\n+    private String fixStringSeparators(String data) {\n+        if (data.contains(\"|\")) {\n+            return new String(Base64.encodeBase64(data.getBytes()));\n+        } else {\n+            return data;\n+        }\n+    }\n+\n+    @Override\n+    public int getPoolSize() {\n+        return schedulingPool.getSize();\n+    }\n+\n+    public SchedulingPool getSchedulingPool() {\n+        return schedulingPool;\n+    }\n+\n+    public void setSchedulingPool(SchedulingPool schedulingPool) {\n+        this.schedulingPool = schedulingPool;\n+    }\n+\n+    private void initPerunSession() throws InternalErrorException {\n+        if (perunSession == null) {\n+            perunSession = perun\n+                    .getPerunSession(new PerunPrincipal(\n+                                    dispatcherPropertiesBean.getProperty(\"perun.principal.name\"),\n+                                    dispatcherPropertiesBean\n+                                            .getProperty(\"perun.principal.extSourceName\"),\n+                                    dispatcherPropertiesBean\n+                                            .getProperty(\"perun.principal.extSourceType\")),\n+                            new PerunClient());\n+        }\n+    }\n }\n",
            "diff_size": 641
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/38/TaskSchedulerImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/codebuff/38/TaskSchedulerImpl.java\nindex 2f9ccae80cf..02a939db38a 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/38/TaskSchedulerImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/codebuff/38/TaskSchedulerImpl.java\n@@ -3,15 +3,12 @@ package cz.metacentrum.perun.dispatcher.scheduling.impl;\n import java.util.Date;\n import java.util.List;\n import java.util.Properties;\n-\n import cz.metacentrum.perun.controller.service.GeneralServiceManager;\n import cz.metacentrum.perun.core.api.PerunClient;\n-\n import org.apache.commons.codec.binary.Base64;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.springframework.beans.factory.annotation.Autowired;\n-\n import cz.metacentrum.perun.core.api.Destination;\n import cz.metacentrum.perun.core.api.Facility;\n import cz.metacentrum.perun.core.api.Pair;\n@@ -35,648 +32,598 @@ import cz.metacentrum.perun.taskslib.model.Task;\n import cz.metacentrum.perun.taskslib.model.Task.TaskStatus;\n import cz.metacentrum.perun.taskslib.dao.ExecServiceDependencyDao.DependencyScope;\n \n+\n @org.springframework.stereotype.Service(value = \"taskScheduler\")\n public class TaskSchedulerImpl implements TaskScheduler {\n \n-\tprivate final static Logger log = LoggerFactory.getLogger(TaskSchedulerImpl.class);\n-\n-\t@Autowired\n-\tprivate SchedulingPool schedulingPool;\n-\t@Autowired\n-\tprivate DependenciesResolver dependenciesResolver;\n-\t@Autowired\n-\tprivate PerunBl perun;\n-\tprivate PerunSession perunSession;\n-\t@Autowired\n-\tprivate Properties dispatcherPropertiesBean;\n-\t@Autowired\n-\tprivate DispatcherQueuePool dispatcherQueuePool;\n-\t@Autowired\n-\tprivate DenialsResolver denialsResolver;\n-\t@Autowired\n-\tprivate GeneralServiceManager generalServiceManager;\n-\n-\n-\t@Override\n-\tpublic void processPool() throws InternalErrorException {\n-\t\tinitPerunSession();\n-\t\tlog.debug(\"pool contains \" + schedulingPool.getSize()\n-\t\t\t\t+ \" tasks in total\");\n-\t\tlog.debug(\"  \" + schedulingPool.getWaitingTasks().size()\n-\t\t\t\t+ \" tasks are going to be processed\");\n-\t\tfor (Task task : schedulingPool.getWaitingTasks()) {\n-\t\t\tif (task.getExecService().getExecServiceType()\n-\t\t\t\t\t.equals(ExecServiceType.SEND)) {\n-\t\t\t\tscheduleTask(task);\n-\t\t\t}\n-\t\t\t// GEN tasks are scheduled only as dependencies\n-\t\t}\n-\t}\n-\n-\t// TODO ensure dependant tasks with scope DESTINATION go to the same engine\n-\t@Override\n-\tpublic Boolean scheduleTask(Task task) {\n-\t\tExecService execService = task.getExecService();\n-\t\tFacility facility = task.getFacility();\n-\t\tDate time = new Date(System.currentTimeMillis());\n-\t\tDispatcherQueue dispatcherQueue = null;\n-\n-\t\tif (task.getStatus().equals(TaskStatus.PROCESSING) && !task.isPropagationForced()) {\n-\t\t\tlog.debug(\"Task {} already processing, will not schedule again.\",\n-\t\t\t\t\ttask.toString());\n-\t\t\treturn true;\n-\t\t}\n-\n-\t\tlog.debug(\"Scheduling TASK \" + task.toString());\n-\t\ttry {\n-\t\t\tdispatcherQueue = schedulingPool.getQueueForTask(task);\n-\t\t\tlog.debug(\"Task {} is assigned to queue {}\", task.getId(), (dispatcherQueue == null) ? \"null\" : dispatcherQueue.getClientID());\n-\t\t} catch (InternalErrorException e) {\n-\t\t\tlog.warn(\"Task {} is not assigned to any queue\", task.getId());\n-\t\t}\n-\t\t// check if the engine is still registered\n-\t\tif(dispatcherQueue != null &&\n-\t\t\t\t!dispatcherQueuePool.isThereDispatcherQueueForClient(dispatcherQueue.getClientID())) {\n-\t\t\tdispatcherQueue = null;\n-\t\t}\n-\t\tif (dispatcherQueue == null) {\n-\t\t\t// where should we send the task?\n-\t\t\tdispatcherQueue = dispatcherQueuePool.getAvailableQueue();\n-\t\t\tif(dispatcherQueue != null) {\n-\t\t\t\ttry {\n-\t\t\t\t\tschedulingPool.setQueueForTask(task, dispatcherQueue);\n-\t\t\t\t} catch (InternalErrorException e) {\n-\t\t\t\t\tlog.error(\"Could not set client queue for task {}: {}\", task.getId(), e.getMessage());\n-\t\t\t\t\treturn true;\n-\t\t\t\t}\n-\t\t\t\tlog.debug(\"Assigned new queue \"\n-\t\t\t\t\t\t+ dispatcherQueue.getQueueName() + \" to task \"\n-\t\t\t\t\t\t+ task.getId());\n-\t\t\t} else {\n-\t\t\t\t// bad luck...\n-\t\t\t\tlog.error(\"Task \"\n-\t\t\t\t\t\t+ task.toString()\n-\t\t\t\t\t\t+ \" has no engine assigned and there are no engines registered...\");\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t}\n-\n-\t\tlog.debug(\"Facility to be processed: \" + facility.getId()\n-\t\t\t\t+ \", ExecService to be processed: \" + execService.getId());\n-\n-\n-\t\tBoolean abortTask = false;\n-\t\ttry {\n-\t\t\trefetchTaskInformation(task);\n-\t\t\tList<Service> assignedServices = perun.getServicesManagerBl().getAssignedServices(perunSession, task.getFacility());\n-\t\t\tif (!assignedServices.contains(execService.getService())) {\n-\t\t\t\tlog.debug(\"Task {} has no longer service {} assigned, aborting.\", task.getId(), execService.getId());\n-\t\t\t\tabortTask = true;\n-\t\t\t}\n-\t\t} catch (FacilityNotExistsException e1) {\n-\t\t\tlog.debug(\"Facility {} for task {} no longer exists, aborting\", facility.getId(), task.getId());\n-\t\t\tabortTask = true;\n-\t\t} catch (ServiceNotExistsException e1) {\n-\t\t\tlog.debug(\"Service {} for task {} no longer exists, aborting\", execService.getId(), task.getId());\n-\t\t\tabortTask = true;\n-\t\t} catch (InternalErrorException e1) {\n-\t\t\tlog.error(\"Error checking facility or exec service for updates, task will not run now: {}\", e1.getMessage());\n-\t\t\treturn true;\n-\t\t} catch (PrivilegeException e1) {\n-\t\t\tlog.error(\"Error checking facility or exec service for updates, task will not run now: {}\", e1.getMessage());\n-\t\t\treturn true;\n-\t\t}\n-\t\t// SEND tasks will be aborted later - we have to go on and try to schedule (and abort)\n-\t\t// GEN tasks that we depend on...\n-\t\tif(abortTask && execService.getExecServiceType() == ExecServiceType.GENERATE) {\n-\t\t\t// GEN tasks may be aborted immediately\n-\t\t\tabortTask(task);\n-\t\t\treturn false;\n-\t\t}\n-\n-\t\t// We have to be carefull from now on - the facility and/or exec service contained\n-\t\t// in this task may no longer be valid with respect to the actual database (ie. when abortTask == true).\n-\t\t// On the other hand, the objects themselves are still here, so they may be referenced in code.\n-\n-\t\t// do not perform further checks for task that is going to be aborted\n-\t\tif(!abortTask) {\n-\n-\t\t\tlog.debug(\"Is the execService ID:\" + execService.getId() + \" enabled globally?\");\n-\t\t\tif (execService.isEnabled()) {\n-\t\t\t\tlog.debug(\"   Yes, it is globally enabled.\");\n-\t\t\t} else {\n-\t\t\t\tlog.debug(\"   No, execService ID: \"+ execService.getId() + \" is not enabled globally. Task will not run.\");\n-\t\t\t\treturn true;\n-\t\t\t}\n-\n-\t\t\tlog.debug(\"   Is the execService ID: \" + execService.getId() + \" denied on facility ID:\" + facility.getId() + \"?\");\n-\t\t\ttry {\n-\t\t\t\tif (!denialsResolver.isExecServiceDeniedOnFacility(execService, facility)) {\n-\t\t\t\t\tlog.debug(\"   No, it is not.\");\n-\t\t\t\t} else {\n-\t\t\t\t\tlog.debug(\"   Yes, the execService ID: \" + execService.getId() + \" is denied on facility ID: \"\n-\t\t\t\t\t\t\t+ facility.getId() + \". Task will not run.\");\n-\t\t\t\t\treturn true;\n-\t\t\t\t}\n-\t\t\t} catch (InternalErrorException e) {\n-\t\t\t\tlog.error(\"Error getting disabled status for execService, task will not run now.\");\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t}\n-\n-\t\tList<ExecService> dependantServices = null;\n-\t\tList<Pair<ExecService, DependencyScope>> dependencies = null;\n-\n-\t\t// If any of the ExecServices that depends on this one is running\n-\t\t// PROCESSING\n-\t\t// we will put the ExecService,Facility pair back to the pool.\n-\t\t// #################################################################################\n-\t\tlog.debug(\"   Is there any execService that depends on [\"\n-\t\t\t\t+ execService.getId() + \"] in \\\"PROCESSING\\\" state?\");\n-\t\tdependantServices = dependenciesResolver.listDependantServices(execService);\n-\t\tboolean proceed = true;\n-\t\tfor (ExecService dependantService : dependantServices) {\n-\t\t\tTask dependantServiceTask = schedulingPool.getTask(\n-\t\t\t\t\tdependantService, facility);\n-\t\t\tif (dependantServiceTask != null) {\n-\t\t\t\tif (dependantServiceTask.getStatus().equals(\n-\t\t\t\t\t\tTaskStatus.PROCESSING)) {\n-\t\t\t\t\tlog.debug(\"   There is a service [\" + dependantServiceTask.getId()\n-\t\t\t\t\t\t\t+ \"] running that depends on this one [\"\n-\t\t\t\t\t\t\t+ execService + \"], so we put this to sleep...\");\n-\t\t\t\t\t// schedulingPool.addToPool(new Pair<ExecService,\n-\t\t\t\t\t// Facility>(execService, facility));\n-\t\t\t\t\tproceed = false;\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t\t// This is probably wrong, so commenting out:\n-\t\t\t\t//   1) if there is some dispatcher queue active at the moment, dispatcherQueue is not null\n-\t\t\t\t//   2) if there is no dispatcher queue available, no point in setting the same queue another task has\n-\t\t\t\t//   3) the dependency should be handled the other way round, from dependant to dependent\n-\t\t\t\t/*\n-\t\t\t\t * try {\n-\t\t\t\t *\tif (dispatcherQueue == null &&\n-\t\t\t\t *\t\t\tschedulingPool.getQueueForTask(dependantServiceTask) != null) {\n-\t\t\t\t *\t\tschedulingPool.setQueueForTask(task, schedulingPool.getQueueForTask(dependantServiceTask));\n-\t\t\t\t *\t}\n-\t\t\t\t * } catch (InternalErrorException e) {\n-\t\t\t\t *\tlog.debug(\"    Failed to set destination queue for task. This is weird, aborting.\");\n-\t\t\t\t *\tproceed = false;\n-\t\t\t\t *}\n-\t\t\t\t */\n-\t\t\t}\n-\t\t}\n-\t\tif (proceed) {\n-\t\t\tlog.debug(\"   No, it is not. No dependent service is running, we can proceed.\");\n-\t\t\t// If it is an ExecService of type SEND, we have to check its\n-\t\t\t// dependencies.\n-\t\t\t// We can skip this for GENERATE type (it has no dependencies by\n-\t\t\t// design).\n-\t\t\t// ########################################################################\n-\t\t\tlog.debug(\"   Check whether the execService [\"\n-\t\t\t\t\t+ execService.getId() + \"] is of type SEND\");\n-\t\t\tif (execService.getExecServiceType().equals(ExecServiceType.SEND)) {\n-\t\t\t\tlog.debug(\"   Well, it is, so we have to check it's dependencies.\");\n-\t\t\t\t// We check the status of all the ExecServices this ExecService\n-\t\t\t\t// depends on.\n-\t\t\t\t//\n-\t\t\t\t//\n-\t\t\t\t// Current approach disregards any SEND/GENERATE differences.\n-\t\t\t\t// Dependency on a GENERATE service is being treated as same as\n-\t\t\t\t// any other SEND dependency\n-\t\t\t\t// but for a small exception regarding ERROR and DONE states,\n-\t\t\t\t// see below:\n-\t\t\t\t//\n-\t\t\t\t// If the dependency is in one of the following states, we do:\n-\t\t\t\t// NONE Schedule it and wait (put this [ExecService,Facility]\n-\t\t\t\t// pair back to the SchedulingPool for a while).\n-\t\t\t\t// PROCESSING Wait\n-\t\t\t\t// ERROR IF dependency is GENERATE THEN DO\n-\t\t\t\t// Schedule it and wait (put this [ExecService,Facility] pair\n-\t\t\t\t// back to the SchedulingPool for a while).\n-\t\t\t\t// ELSE IF dependency is SEND THEN DO\n-\t\t\t\t// End with ERROR. (no point in trying, something is probably\n-\t\t\t\t// amiss on destination nodes...)\n-\t\t\t\t// ELSE\n-\t\t\t\t// throw new IllegalArgumentException\n-\t\t\t\t// FI\n-\t\t\t\t// DONE IF dependency is GENERATE THEN DO\n-\t\t\t\t// Schedule it and wait (put this [ExecService,Facility] pair\n-\t\t\t\t// back to the SchedulingPool for a while).\n-\t\t\t\t//\n-\t\t\t\t// It might look like we get an infinite loop where GENERATE\n-\t\t\t\t// will be in DONE and then rescheduled again and again.\n-\t\t\t\t// It is not so because PropagationMaintainer sets its state to\n-\t\t\t\t// NONE as soon as the SEND, that depends on it,\n-\t\t\t\t// enters either DONE or ERROR states (one of its finite\n-\t\t\t\t// states).\n-\t\t\t\t// ELSE IF dependency is SEND THEN DO\n-\t\t\t\t// Proceed (Yes, no need to schedule this dependency, it is done\n-\t\t\t\t// already and we don't care for how long it has been so at this\n-\t\t\t\t// point.)\n-\t\t\t\t// ELSE\n-\t\t\t\t// throw new IllegalArgumentException\n-\t\t\t\t// FI\n-\t\t\t\t// :-)\n-\t\t\t\t// #######################################################################################################\n-\t\t\t\tproceed = true;\n-\t\t\t\tdependencies = dependenciesResolver.listDependenciesAndScope(execService);\n-\t\t\t\tlog.debug(\"   We are about to loop over execService [\"\n-\t\t\t\t\t\t+ execService.getId() + \"] dependencies.\");\n-\t\t\t\tlog.debug(\"   Number of dependencies:\" + dependencies);\n-\t\t\t\tDispatcherQueue dependencyQueue = null;\n-\t\t\t\tfor (Pair<ExecService, DependencyScope> dependencyPair : dependencies) {\n-\t\t\t\t\tExecService dependency = dependencyPair.getLeft();\n-\t\t\t\t\tDependencyScope dependencyScope = dependencyPair.getRight();\n-\t\t\t\t\tTask dependencyServiceTask = schedulingPool.getTask(dependency, facility);\n-\t\t\t\t\tif (dependencyServiceTask == null) {\n-\t\t\t\t\t\tif(abortTask) {\n-\t\t\t\t\t\t\tlog.info(\"   Task {} is going to be aborted, the dependency exec service {} will not be scheduled now.\",\n-\t\t\t\t\t\t\t\t\ttask.getId(), dependency.getId());\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t// Dependency being NULL is equivalent to being in NONE\n-\t\t\t\t\t\t\t// state.\n-\t\t\t\t\t\t\tlog.info(\"   Last Task [dependency:\"\n-\t\t\t\t\t\t\t\t\t+ dependency.getId() + \", facility:\"\n-\t\t\t\t\t\t\t\t\t+ facility.getId()\n-\t\t\t\t\t\t\t\t\t+ \"] was NULL, we are gonna propagate.\");\n-\t\t\t\t\t\t\tif(scheduleItAndWait(dependency, facility, execService,\n-\t\t\t\t\t\t\t\t\tdispatcherQueue, time)) {\n-\t\t\t\t\t\t\t\t// task sucessfully scheduled, nothing to do\n-\t\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t\t// TODO: task aborted - maybe set this one to error?\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tproceed = false;\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tboolean wasDependencyServiceTaskForced = dependencyServiceTask.isPropagationForced();\n-\t\t\t\t\t\tdependencyServiceTask.setPropagationForced(task.isPropagationForced());\n-\t\t\t\t\t\tswitch (dependencyServiceTask.getStatus()) {\n-\t\t\t\t\t\tcase DONE:\n-\t\t\t\t\t\t\tswitch (dependency.getExecServiceType()) {\n-\t\t\t\t\t\t\tcase GENERATE:\n-\t\t\t\t\t\t\t\tif(task.isSourceUpdated()) {\n-\t\t\t\t\t\t\t\t\t// we need to reschedule the GEN task as the source data has changed\n-\t\t\t\t\t\t\t\t\tlog.debug(\"   Dependency ID \"\n-\t\t\t\t\t\t\t\t\t\t\t+ dependency.getId()\n-\t\t\t\t\t\t\t\t\t\t\t+ \" is in DONE and is going to be rescheduled as we need fresh data.\");\n-\t\t\t\t\t\t\t\t\trescheduleTask(dependencyServiceTask, execService, dispatcherQueue);\n-\t\t\t\t\t\t\t\t\tproceed = false;\n-\t\t\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t\t\tlog.debug(\"   Dependency ID \"\n-\t\t\t\t\t\t\t\t\t\t\t+ dependency.getId()\n-\t\t\t\t\t\t\t\t\t\t\t+ \" is in DONE and it is of type GENERATE, we can proceed.\");\n-\t\t\t\t\t\t\t\t\t// Nothing, we can proceed...\n-\t\t\t\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\t\t\t\tdependencyQueue = schedulingPool.getQueueForTask(dependencyServiceTask);\n-\t\t\t\t\t\t\t\t\t} catch (InternalErrorException e) {\n-\t\t\t\t\t\t\t\t\t\tlog.error(\"Could not get queue for task {}\", dependencyServiceTask.getId());\n-\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t\tcase SEND:\n-\t\t\t\t\t\t\t\tlog.debug(\"   Dependency ID \"\n-\t\t\t\t\t\t\t\t\t\t+ dependencyServiceTask.getId()\n-\t\t\t\t\t\t\t\t\t\t+ \" is in DONE and it is of type SEND, we can proceed.\");\n-\t\t\t\t\t\t\t\t// Nothing, we can proceed...\n-\t\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t\tdefault:\n-\t\t\t\t\t\t\t\tthrow new IllegalArgumentException(\n-\t\t\t\t\t\t\t\t\t\t\"Unknown ExecService type. Expected GENERATE or SEND.\");\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\tcase ERROR:\n-\t\t\t\t\t\t\tswitch (dependency.getExecServiceType()) {\n-\t\t\t\t\t\t\tcase GENERATE:\n-\t\t\t\t\t\t\t\tlog.info(\"   Dependency ID \"\n-\t\t\t\t\t\t\t\t\t\t+ dependencyServiceTask.getId()\n-\t\t\t\t\t\t\t\t\t\t+ \" is in ERROR and it is of type GENERATE, we are gonna propagate.\");\n-\t\t\t\t\t\t\t\t// scheduleItAndWait(dependency, facility,\n-\t\t\t\t\t\t\t\t// execService, dispatcherQueue);\n-\t\t\t\t\t\t\t\t// try to run the generate task again\n-\t\t\t\t\t\t\t\trescheduleTask(dependencyServiceTask, execService, dispatcherQueue);\n-\t\t\t\t\t\t\t\tproceed = false;\n-\t\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t\tcase SEND:\n-\t\t\t\t\t\t\t\tlog.info(\"   Dependency ID \"\n-\t\t\t\t\t\t\t\t\t\t+ dependencyServiceTask.getId()\n-\t\t\t\t\t\t\t\t\t\t+ \" is in ERROR and it is of type SEND, we are gonna end with ERROR.\");\n-\t\t\t\t\t\t\t\tproceed = false;\n-\t\t\t\t\t\t\t\t// We end Task with error immediately.\n-\t\t\t\t\t\t\t\tschedulingPool.setTaskStatus(task, TaskStatus.ERROR);\n-\t\t\t\t\t\t\t\t// manipulateTasks(execService, facility, task);\n-\n-\t\t\t\t\t\t\t\t// And we set all its GENERATE dependencies as\n-\t\t\t\t\t\t\t\t// \"dirty\" by switching them to NONE state.\n-\t\t\t\t\t\t\t\t// Note: Yes, there might have been some stored\n-\t\t\t\t\t\t\t\t// from the previous runs...\n-\t\t\t\t\t\t\t\t// propagationMaintainer.setAllGenerateDependenciesToNone(dependencies,\n-\t\t\t\t\t\t\t\t// facility);\n-\t\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t\tdefault:\n-\t\t\t\t\t\t\t\tthrow new IllegalArgumentException(\n-\t\t\t\t\t\t\t\t\t\t\"Unknown ExecService type. Expected GENERATE or SEND.\");\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\tcase NONE:\n-\t\t\t\t\t\t\tlog.info(\"   Last Task {} [dependency:\"\n-\t\t\t\t\t\t\t\t\t+ dependency.getId() + \", facility:\"\n-\t\t\t\t\t\t\t\t\t+ facility.getId()\n-\t\t\t\t\t\t\t\t\t+ \"] was NONE, we are gonna propagate.\", dependencyServiceTask.getId());\n-\t\t\t\t\t\t\trescheduleTask(dependencyServiceTask, execService,\n-\t\t\t\t\t\t\t\t\tdispatcherQueue);\n-\t\t\t\t\t\t\tproceed = false;\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\tcase PLANNED:\n-\t\t\t\t\t\t\tlog.info(\"   Dependency ID \" + dependencyServiceTask.getId()\n-\t\t\t\t\t\t\t\t\t+ \" is in PLANNED so we are gonna wait.\");\n-\t\t\t\t\t\t\t// we do not need to put it back in pool here\n-\t\t\t\t\t\t\t// justWait(facility, execService);\n-\t\t\t\t\t\t\tif (dependencyScope.equals(DependencyScope.SERVICE)) {\n-\t\t\t\t\t\t\t\tproceed = false;\n-\t\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\t\t\tdependencyQueue = schedulingPool.getQueueForTask(dependencyServiceTask);\n-\t\t\t\t\t\t\t\t} catch (InternalErrorException e) {\n-\t\t\t\t\t\t\t\t\tlog.error(\"Could not get queue for task {}\", dependencyServiceTask.getId());\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\tcase PROCESSING:\n-\t\t\t\t\t\t\tlog.info(\"   Dependency ID \" + dependencyServiceTask.getId()\n-\t\t\t\t\t\t\t\t\t+ \" is in PROCESSING so we are gonna wait.\");\n-\t\t\t\t\t\t\t// we do not need to put it back in pool here\n-\t\t\t\t\t\t\t// justWait(facility, execService);\n-\t\t\t\t\t\t\tif (dependencyScope.equals(DependencyScope.SERVICE)) {\n-\t\t\t\t\t\t\t\tproceed = false;\n-\t\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\t\t\tdependencyQueue = schedulingPool.getQueueForTask(dependencyServiceTask);\n-\t\t\t\t\t\t\t\t} catch (InternalErrorException e) {\n-\t\t\t\t\t\t\t\t\tlog.error(\"Could not get queue for task {}\", dependencyServiceTask.getId());\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tif(dependencyServiceTask.isPropagationForced() && !wasDependencyServiceTaskForced) {\n-\t\t\t\t\t\t\t\t// reschedule dependant only if originally was not forced !!!\n-\t\t\t\t\t\t\t\trescheduleTask(dependencyServiceTask, execService, dispatcherQueue);\n-\t\t\t\t\t\t\t\t// XXX - should we proceed here?\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\tdefault:\n-\t\t\t\t\t\t\tthrow new IllegalArgumentException(\n-\t\t\t\t\t\t\t\t\t\"Unknown Task status. Expected DONE, ERROR, NONE, PLANNED or PROCESSING.\");\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\t// Finally, if we can proceed, we proceed...\n-\t\t\t\t// #########################################\n-\t\t\t\tif (proceed) {\n-\t\t\t\t\tif(abortTask) {\n-\t\t\t\t\t\t// the SEND task is going to be aborted now\n-\t\t\t\t\t\tabortTask(task);\n-\t\t\t\t\t\treturn false;\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tif(dependencyQueue != null && dependencyQueue != dispatcherQueue) {\n-\t\t\t\t\t\t\tlog.debug(\"Changing task {} destination queue to {} to match dependency task\",\n-\t\t\t\t\t\t\t\t\ttask.getId(), dependencyQueue.getClientID());\n-\t\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\t\tschedulingPool.setQueueForTask(task, dependencyQueue);\n-\t\t\t\t\t\t\t} catch (InternalErrorException e) {\n-\t\t\t\t\t\t\t\tlog.error(\"Could not change task {} destination queue: {}\",\n-\t\t\t\t\t\t\t\t\t\ttask.getId(), e.getMessage());\n-\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tlog.info(\"   SCHEDULING task [\" + task.getId() + \"], execService [\"\n-\t\t\t\t\t\t\t\t+ execService.getId() + \"] facility [\"\n-\t\t\t\t\t\t\t\t+ facility.getId() + \"] as PLANNED.\");\n-\t\t\t\t\t\ttask.setSchedule(time);\n-\t\t\t\t\t\tschedulingPool.setTaskStatus(task, TaskStatus.PLANNED);\n-\t\t\t\t\t\tsendToEngine(task);\n-\t\t\t\t\t}\n-\t\t\t\t\t// manipulateTasks(execService, facility, task);\n-\t\t\t\t} else {\n-\t\t\t\t\tif(abortTask) {\n-\t\t\t\t\t\t// the SEND task is going to be aborted now\n-\t\t\t\t\t\tabortTask(task);\n-\t\t\t\t\t\treturn false;\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\t// If we can not proceed, we just end here.\n-\t\t\t\t\t\t// ########################################\n-\t\t\t\t\t\t// The current ExecService,Facility pair should be sleeping\n-\t\t\t\t\t\t// in SchedulingPool at the moment...\n-\t\t\t\t\t\tlog.info(\"   Task {} state set to NONE, will be scheduled again at the next cycle.\",\n-\t\t\t\t\t\t\t\ttask.getId());\n-\t\t\t\t\t\tschedulingPool.setTaskStatus(task, TaskStatus.NONE);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t} else if (execService.getExecServiceType().equals(ExecServiceType.GENERATE)) {\n-\t\t\t\tlog.debug(\"   Well, it is not. ExecService of type GENERATE does not have any dependencies by design, so we schedule it immediately.\");\n-\t\t\t\tlog.info(\"   SCHEDULING task [\" + task.getId() + \"], execService [\" + execService.getId()\n-\t\t\t\t\t\t+ \"] facility [\" + facility.getId() + \"] as PLANNED.\");\n-\t\t\t\ttask.setSchedule(time);\n-\t\t\t\tschedulingPool.setTaskStatus(task, TaskStatus.PLANNED);\n-\t\t\t\t// we are going to run the GEN task, so reset the source updated flag to\n-\t\t\t\t// allow rerunning the GEN when data changes before the GEN is complete\n-\t\t\t\tfor (ExecService dependantService : dependantServices) {\n-\t\t\t\t\tTask dependantServiceTask = schedulingPool.getTask(dependantService, facility);\n-\t\t\t\t\tif (dependantServiceTask != null && dependantServiceTask.isSourceUpdated()) {\n-\t\t\t\t\t\tdependantServiceTask.setSourceUpdated(false);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tsendToEngine(task);\n-\t\t\t\t// manipulateTasks(execService, facility, task);\n-\t\t\t} else {\n-\t\t\t\tthrow new IllegalArgumentException(\n-\t\t\t\t\t\t\"Unknown ExecService type. Expected GENERATE or SEND.\");\n-\t\t\t}\n-\t\t} else {\n-\t\t\tlog.debug(\"   We do not proceed, we put the task [\" + task.getId() + \"], [\"\n-\t\t\t\t\t+ execService.getId() + \"] execService to sleep.\");\n-\t\t}\n-\t\treturn true;\n-\t}\n-\n-\tprivate void abortTask(Task task) {\n-\t\tlog.debug(\"Aborting task {}, removing from pool.\", task.getId());\n-\t\tschedulingPool.removeTask(task);\n-\t}\n-\n-\tprivate void refetchTaskInformation(Task task) throws FacilityNotExistsException, InternalErrorException, PrivilegeException, ServiceNotExistsException {\n-\t\t// reread facility\n-\t\tlog.debug(\"Rereading facility and  exec service for task {}\", task.getId());\n-\t\tFacility dbFacility = perun.getFacilitiesManagerBl().getFacilityById(perunSession, task.getFacilityId());\n-\t\tif(dbFacility == null) {\n-\t\t\tthrow new FacilityNotExistsException(\"No facility with id \" + task.getFacilityId());\n-\t\t}\n-\t\tBoolean taskModified = false;\n-\t\tif(!dbFacility.equals(task.getFacility())) {\n-\t\t\ttask.setFacility(dbFacility);\n-\t\t\ttaskModified = true;\n-\t\t}\n-\t\t// reread exec service (and service)\n-\t\tExecService dbExecService = generalServiceManager.getExecService(perunSession, task.getExecServiceId());\n-\t\tif(dbExecService == null) {\n-\t\t\tthrow new ServiceNotExistsException(\"No exec service with id \" + task.getExecServiceId());\n-\t\t}\n-\t\tif(!dbExecService.equals(task.getExecService())) {\n-\t\t\ttask.setExecService(dbExecService);\n-\t\t\ttaskModified = true;\n-\t\t}\n-\t\tif(taskModified) {\n-\t\t\tlog.debug(\"Task components have changed, updating task {}\", task.getId());\n-\t\t\tschedulingPool.setTaskStatus(task, task.getStatus());\n-\t\t}\n-\t}\n-\n-\tprivate Boolean scheduleItAndWait(ExecService dependency, Facility facility,\n-\t\t\tExecService execService, DispatcherQueue dispatcherQueue, Date time) {\n-\t\t// this is called to schedule dependencies of given task\n-\t\tTask task = new Task();\n-\t\ttask.setExecService(dependency);\n-\t\ttask.setFacility(facility);\n-\t\ttask.setSchedule(time);\n-\t\ttry {\n-\t\t\tschedulingPool.addToPool(task, dispatcherQueue);\n-\t\t\treturn scheduleTask(task);\n-\t\t} catch (InternalErrorException e) {\n-\t\t\tlog.error(\"Could not schedule new task: \" + e.getMessage());\n-\t\t\treturn false;\n-\t\t}\n-\t\t// schedulingPool.setTaskStatus(task, TaskStatus.NONE);\n-\t}\n-\n-\tprivate Boolean rescheduleTask(Task dependencyServiceTask,\n-\t\t\tExecService execService, DispatcherQueue dispatcherQueue) {\n-\t\t// task is in the pool already, just go for recursion\n-\t\treturn scheduleTask(dependencyServiceTask);\n-\t}\n-\n-\tprivate void sendToEngine(Task task) {\n-\t\tDispatcherQueue dispatcherQueue;\n-\t\ttry {\n-\t\t\tdispatcherQueue = schedulingPool.getQueueForTask(task);\n-\t\t} catch (InternalErrorException e1) {\n-\t\t\tlog.error(\"No engine set for task \" + task.toString()\n-\t\t\t\t\t+ \", could not send it!\");\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tif (dispatcherQueue == null) {\n-\t\t\t// where should we send the task?\n-\t\t\tif (dispatcherQueuePool.poolSize() > 0) {\n-\t\t\t\tdispatcherQueue = dispatcherQueuePool.getPool().iterator()\n-\t\t\t\t\t\t.next();\n-\t\t\t\ttry {\n-\t\t\t\t\tschedulingPool.setQueueForTask(task, dispatcherQueue);\n-\t\t\t\t} catch (InternalErrorException e) {\n-\t\t\t\t\tlog.error(\"Could not assign new queue for task {}: {}\", task.getId(), e);\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\t\t\t\tlog.debug(\"Assigned new queue \"\n-\t\t\t\t\t\t+ dispatcherQueue.getQueueName() + \" to task \"\n-\t\t\t\t\t\t+ task.getId());\n-\t\t\t} else {\n-\t\t\t\t// bad luck...\n-\t\t\t\tlog.error(\"Task \"\n-\t\t\t\t\t\t+ task.toString()\n-\t\t\t\t\t\t+ \" has no engine assigned and there are no engines registered...\");\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t}\n-\n-\t\t// task|[engine_id]|[task_id][is_forced][exec_service_id][facility]|[destination_list]|[dependency_list]\n-\t\t// - the task|[engine_id] part is added by dispatcherQueue\n-\t\tList<Destination> destinations = task.getDestinations();\n-\t\tif (destinations == null || destinations.isEmpty()) {\n-\t\t\tlog.debug(\"No destinations for task \" + task.toString()\n-\t\t\t\t\t+ \", trying to query the database...\");\n-\t\t\ttry {\n-\t\t\t\tinitPerunSession();\n-\t\t\t\tdestinations = perun.getServicesManager().getDestinations(\n-\t\t\t\t\t\tperunSession, task.getExecService().getService(),\n-\t\t\t\t\t\ttask.getFacility());\n-\t\t\t} catch (ServiceNotExistsException e) {\n-\t\t\t\tlog.error(\"No destinations found for task \" + task.getId());\n-\t\t\t\ttask.setEndTime(new Date(System.currentTimeMillis()));\n-\t\t\t\tschedulingPool.setTaskStatus(task, TaskStatus.ERROR);\n-\t\t\t\treturn;\n-\t\t\t} catch (FacilityNotExistsException e) {\n-\t\t\t\tlog.error(\"Facility for task {} does not exist...\", task.getId());\n-\t\t\t\ttask.setEndTime(new Date(System.currentTimeMillis()));\n-\t\t\t\tschedulingPool.setTaskStatus(task, TaskStatus.ERROR);\n-\t\t\t\treturn;\n-\t\t\t} catch (PrivilegeException e) {\n-\t\t\t\tlog.error(\"Privilege error accessing the database: \"\n-\t\t\t\t\t\t+ e.getMessage());\n-\t\t\t\ttask.setEndTime(new Date(System.currentTimeMillis()));\n-\t\t\t\tschedulingPool.setTaskStatus(task, TaskStatus.ERROR);\n-\t\t\t\treturn;\n-\t\t\t} catch (InternalErrorException e) {\n-\t\t\t\tlog.error(\"Internal error: \" + e.getMessage());\n-\t\t\t\ttask.setEndTime(new Date(System.currentTimeMillis()));\n-\t\t\t\tschedulingPool.setTaskStatus(task, TaskStatus.ERROR);\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t}\n-\t\tlog.debug(\"Fetched destinations: \" + ( (destinations == null) ?  \"[]\" : destinations.toString()));\n-\t\ttask.setDestinations(destinations);\n-\t\tif(task.getExecService().getExecServiceType().equals(ExecServiceType.SEND) && \n-\t\t   (destinations == null || destinations.isEmpty())) {\n-\t\t\tlog.info(\"Task [] has no destination, setting to error.\");\n-\t\t\ttask.setEndTime(new Date(System.currentTimeMillis()));\n-\t\t\tschedulingPool.setTaskStatus(task, TaskStatus.ERROR);\n-\t\t\treturn;\n-\t\t}\n-\t\tStringBuilder destinations_s = new StringBuilder(\"Destinations [\");\n-\t\tif (destinations != null) {\n-\t\t\tfor (Destination destination : destinations) {\n-\t\t\t\tdestinations_s.append(destination.serializeToString() + \", \");\n-\t\t\t}\n-\t\t}\n-\t\tdestinations_s.append(\"]\");\n-\t\tString dependencies = \"\";\n-\t\tdispatcherQueue.sendMessage(\"[\" + task.getId() + \"][\"\n-\t\t\t\t+ task.isPropagationForced() + \"]|[\"\n-\t\t\t\t+ fixStringSeparators(task.getExecService().serializeToString()) + \"]|[\"\n-\t\t\t\t+ fixStringSeparators(task.getFacility().serializeToString()) + \"]|[\"\n-\t\t\t\t+ fixStringSeparators(destinations_s.toString()) + \"]|[\" + dependencies + \"]\");\n-\t\ttask.setStartTime(new Date(System.currentTimeMillis()));\n-\t\ttask.setEndTime(null);\n-\t\tschedulingPool.setTaskStatus(task, TaskStatus.PROCESSING);\n-\t}\n-\n-\tprivate String fixStringSeparators(String data) {\n-\t\tif(data.contains(\"|\")) {\n-\t\t\treturn new String(Base64.encodeBase64(data.getBytes()));\n-\t\t} else {\n-\t\t\treturn data;\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic int getPoolSize() {\n-\t\treturn schedulingPool.getSize();\n-\t}\n-\n-\tpublic SchedulingPool getSchedulingPool() {\n-\t\treturn schedulingPool;\n-\t}\n-\n-\tpublic void setSchedulingPool(SchedulingPool schedulingPool) {\n-\t\tthis.schedulingPool = schedulingPool;\n-\t}\n-\n-\tprivate void initPerunSession() throws InternalErrorException {\n-\t\tif (perunSession == null) {\n-\t\t\tperunSession = perun\n-\t\t\t\t\t.getPerunSession(new PerunPrincipal(\n-\t\t\t\t\t\t\tdispatcherPropertiesBean.getProperty(\"perun.principal.name\"),\n-\t\t\t\t\t\t\tdispatcherPropertiesBean\n-\t\t\t\t\t\t\t\t\t.getProperty(\"perun.principal.extSourceName\"),\n-\t\t\t\t\t\t\tdispatcherPropertiesBean\n-\t\t\t\t\t\t\t\t\t.getProperty(\"perun.principal.extSourceType\")),\n-\t\t\t\t\t\t\tnew PerunClient());\n-\t\t}\n-\t}\n-}\n+\n+ private final static Logger log = LoggerFactory.getLogger(TaskSchedulerImpl.class);\n+\n+ @Autowired\n+ private SchedulingPool schedulingPool;\n+\n+ @Autowired\n+ private DependenciesResolver dependenciesResolver;\n+\n+ @Autowired\n+ private PerunBl perun;\n+ private PerunSession perunSession;\n+\n+ @Autowired\n+ private Properties dispatcherPropertiesBean;\n+\n+ @Autowired\n+ private DispatcherQueuePool dispatcherQueuePool;\n+\n+ @Autowired\n+ private DenialsResolver denialsResolver;\n+\n+ @Autowired\n+ private GeneralServiceManager generalServiceManager;\n+\n+ @Override\n+ public void processPool() throws InternalErrorException {\n+  initPerunSession();\n+  log.debug(\"pool contains \" + schedulingPool.getSize() + \" tasks in total\");\n+  log.debug(\"  \" + schedulingPool.getWaitingTasks().size() + \" tasks are going to be processed\");\n+  for (Task task : schedulingPool.getWaitingTasks()) {\n+   if (task.getExecService().getExecServiceType().equals(ExecServiceType.SEND)) {\n+    scheduleTask(task);\n+   }\n+   // GEN tasks are scheduled only as dependencies\n+  }\n+ }\n+\n+ // TODO ensure dependant tasks with scope DESTINATION go to the same engine\n+\n+ @Override\n+ public Boolean scheduleTask(Task task) {\n+  ExecService execService = task.getExecService();\n+  Facility facility = task.getFacility();\n+  Date time = new Date(System.currentTimeMillis());\n+  DispatcherQueue dispatcherQueue = null;\n+  if (task.getStatus().equals(TaskStatus.PROCESSING) && !task.isPropagationForced()) {\n+   log.debug(\"Task {} already processing, will not schedule again.\", task.toString());\n+   return true;\n+  }\n+  log.debug(\"Scheduling TASK \" + task.toString());\n+\n+  try {\n+   dispatcherQueue = schedulingPool.getQueueForTask(task);\n+   log.debug(\"Task {} is assigned to queue {}\",\n+   task.getId(),\n+    (dispatcherQueue == null) ? \"null\" : dispatcherQueue.getClientID());\n+  } catch (InternalErrorException e) {\n+   log.warn(\"Task {} is not assigned to any queue\", task.getId());\n+  }\n+  // check if the engine is still registered\n+  if (dispatcherQueue != null && !dispatcherQueuePool.isThereDispatcherQueueForClient(dispatcherQueue.getClientID())) {\n+   dispatcherQueue = null;\n+  }\n+  if (dispatcherQueue == null) {\n+   // where should we send the task?\n+   dispatcherQueue = dispatcherQueuePool.getAvailableQueue();\n+   if (dispatcherQueue != null) {\n+    try {\n+     schedulingPool.setQueueForTask(task, dispatcherQueue);\n+    } catch (InternalErrorException e) {\n+     log.error(\"Could not set client queue for task {}: {}\", task.getId(), e.getMessage());\n+     return true;\n+    }\n+    log.debug(\"Assigned new queue \" + dispatcherQueue.getQueueName() + \" to task \" + task.getId());\n+   } else {\n+    // bad luck...\n+    log.error(\"Task \" + task.toString() + \" has no engine assigned and there are no engines registered...\");\n+    return true;\n+   }\n+  }\n+  log.debug(\"Facility to be processed: \" + facility.getId() + \", ExecService to be processed: \" + execService.getId());\n+  Boolean abortTask = false;\n+  try {\n+   refetchTaskInformation(task);\n+   List<Service> assignedServices = perun.getServicesManagerBl().getAssignedServices(perunSession, task.getFacility());\n+   if (!assignedServices.contains(execService.getService())) {\n+    log.debug(\"Task {} has no longer service {} assigned, aborting.\", task.getId(), execService.getId());\n+    abortTask = true;\n+   }\n+  } catch (FacilityNotExistsException e1) {\n+   log.debug(\"Facility {} for task {} no longer exists, aborting\", facility.getId(), task.getId());\n+   abortTask = true;\n+  } catch (ServiceNotExistsException e1) {\n+   log.debug(\"Service {} for task {} no longer exists, aborting\", execService.getId(), task.getId());\n+   abortTask = true;\n+  } catch (InternalErrorException e1) {\n+   log.error(\"Error checking facility or exec service for updates, task will not run now: {}\", e1.getMessage());\n+   return true;\n+  } catch (PrivilegeException e1) {\n+   log.error(\"Error checking facility or exec service for updates, task will not run now: {}\", e1.getMessage());\n+   return true;\n+  }\n+  // SEND tasks will be aborted later - we have to go on and try to schedule (and abort)\n+  // GEN tasks that we depend on...\n+  if (abortTask && execService.getExecServiceType() == ExecServiceType.GENERATE) {\n+   // GEN tasks may be aborted immediately\n+   abortTask(task);\n+   return false;\n+  }\n+\n+  // We have to be carefull from now on - the facility and/or exec service contained\n+  // in this task may no longer be valid with respect to the actual database (ie. when abortTask == true).\n+  // On the other hand, the objects themselves are still here, so they may be referenced in code.\n+\n+  // do not perform further checks for task that is going to be aborted\n+  if (!abortTask) {\n+   log.debug(\"Is the execService ID:\" + execService.getId() + \" enabled globally?\");\n+   if (execService.isEnabled()) {\n+    log.debug(\"   Yes, it is globally enabled.\");\n+   } else {\n+    log.debug(\"   No, execService ID: \" + execService.getId() + \" is not enabled globally. Task will not run.\");\n+    return true;\n+   }\n+   log.debug(\"   Is the execService ID: \" + execService.getId() + \" denied on facility ID:\" + facility.getId() + \"?\");\n+\n+   try {\n+    if (!denialsResolver.isExecServiceDeniedOnFacility(execService, facility)) {\n+     log.debug(\"   No, it is not.\");\n+    } else {\n+     log.debug(\"   Yes, the execService ID: \" + execService.getId() + \" is denied on facility ID: \" + facility.getId() + \". Task will not run.\");\n+     return true;\n+    }\n+   } catch (InternalErrorException e) {\n+    log.error(\"Error getting disabled status for execService, task will not run now.\");\n+    return true;\n+   }\n+  }\n+  List<ExecService> dependantServices = null;\n+  List<Pair<ExecService, DependencyScope>> dependencies = null;\n+\n+  // If any of the ExecServices that depends on this one is running\n+  // PROCESSING\n+  // we will put the ExecService,Facility pair back to the pool.\n+  // #################################################################################\n+  log.debug(\"   Is there any execService that depends on [\" + execService.getId() + \"] in \\\"PROCESSING\\\" state?\");\n+  dependantServices = dependenciesResolver.listDependantServices(execService);\n+\n+  boolean proceed = true;\n+  for (ExecService dependantService : dependantServices) {\n+   Task dependantServiceTask = schedulingPool.getTask(dependantService, facility);\n+   if (dependantServiceTask != null) {\n+    if (dependantServiceTask.getStatus().equals(TaskStatus.PROCESSING)) {\n+     log.debug(\"   There is a service [\" + dependantServiceTask.getId() + \"] running that depends on this one [\" + execService + \"], so we put this to sleep...\");\n+     // schedulingPool.addToPool(new Pair<ExecService,\n+     // Facility>(execService, facility));\n+     proceed = false;\n+     break;\n+    }\n+    // This is probably wrong, so commenting out:\n+    //   1) if there is some dispatcher queue active at the moment, dispatcherQueue is not null\n+    //   2) if there is no dispatcher queue available, no point in setting the same queue another task has\n+    //   3) the dependency should be handled the other way round, from dependant to dependent\n+    /*\n+     * try {\n+     * if (dispatcherQueue == null &&\n+     *   schedulingPool.getQueueForTask(dependantServiceTask) != null) {\n+     *  schedulingPool.setQueueForTask(task, schedulingPool.getQueueForTask(dependantServiceTask));\n+     * }\n+     * } catch (InternalErrorException e) {\n+     * log.debug(\"    Failed to set destination queue for task. This is weird, aborting.\");\n+     * proceed = false;\n+     *}\n+     */\n+   }\n+  }\n+  if (proceed) {\n+   log.debug(\"   No, it is not. No dependent service is running, we can proceed.\");\n+   // If it is an ExecService of type SEND, we have to check its\n+   // dependencies.\n+   // We can skip this for GENERATE type (it has no dependencies by\n+   // design).\n+   // ########################################################################\n+   log.debug(\"   Check whether the execService [\" + execService.getId() + \"] is of type SEND\");\n+   if (execService.getExecServiceType().equals(ExecServiceType.SEND)) {\n+    log.debug(\"   Well, it is, so we have to check it's dependencies.\");\n+    // We check the status of all the ExecServices this ExecService\n+    // depends on.\n+    //\n+    //\n+    // Current approach disregards any SEND/GENERATE differences.\n+    // Dependency on a GENERATE service is being treated as same as\n+    // any other SEND dependency\n+    // but for a small exception regarding ERROR and DONE states,\n+    // see below:\n+    //\n+    // If the dependency is in one of the following states, we do:\n+    // NONE Schedule it and wait (put this [ExecService,Facility]\n+    // pair back to the SchedulingPool for a while).\n+    // PROCESSING Wait\n+    // ERROR IF dependency is GENERATE THEN DO\n+    // Schedule it and wait (put this [ExecService,Facility] pair\n+    // back to the SchedulingPool for a while).\n+    // ELSE IF dependency is SEND THEN DO\n+    // End with ERROR. (no point in trying, something is probably\n+    // amiss on destination nodes...)\n+    // ELSE\n+    // throw new IllegalArgumentException\n+    // FI\n+    // DONE IF dependency is GENERATE THEN DO\n+    // Schedule it and wait (put this [ExecService,Facility] pair\n+    // back to the SchedulingPool for a while).\n+    //\n+    // It might look like we get an infinite loop where GENERATE\n+    // will be in DONE and then rescheduled again and again.\n+    // It is not so because PropagationMaintainer sets its state to\n+    // NONE as soon as the SEND, that depends on it,\n+    // enters either DONE or ERROR states (one of its finite\n+    // states).\n+    // ELSE IF dependency is SEND THEN DO\n+    // Proceed (Yes, no need to schedule this dependency, it is done\n+    // already and we don't care for how long it has been so at this\n+    // point.)\n+    // ELSE\n+    // throw new IllegalArgumentException\n+    // FI\n+    // :-)\n+    // #######################################################################################################\n+    proceed = true;\n+    dependencies = dependenciesResolver.listDependenciesAndScope(execService);\n+    log.debug(\"   We are about to loop over execService [\" + execService.getId() + \"] dependencies.\");\n+    log.debug(\"   Number of dependencies:\" + dependencies);\n+    DispatcherQueue dependencyQueue = null;\n+    for (Pair<ExecService, DependencyScope> dependencyPair : dependencies) {\n+     ExecService dependency = dependencyPair.getLeft();\n+     DependencyScope dependencyScope = dependencyPair.getRight();\n+     Task dependencyServiceTask = schedulingPool.getTask(dependency, facility);\n+     if (dependencyServiceTask == null) {\n+      if (abortTask) {\n+       log.info(\"   Task {} is going to be aborted, the dependency exec service {} will not be scheduled now.\", task.getId(), dependency.getId());\n+      } else {\n+       // Dependency being NULL is equivalent to being in NONE\n+       // state.\n+       log.info(\"   Last Task [dependency:\" + dependency.getId() + \", facility:\" + facility.getId() + \"] was NULL, we are gonna propagate.\");\n+       if (scheduleItAndWait(dependency, facility, execService, dispatcherQueue, time)) {\n+        // task sucessfully scheduled, nothing to do\n+\n+       } else {\n+        // TODO: task aborted - maybe set this one to error?\n+\n+       }\n+      }\n+      proceed = false;\n+     } else {\n+\n+      boolean wasDependencyServiceTaskForced = dependencyServiceTask.isPropagationForced();\n+      dependencyServiceTask.setPropagationForced(task.isPropagationForced());\n+      switch (dependencyServiceTask.getStatus()) {\n+       case DONE:\n+        switch (dependency.getExecServiceType()) {\n+         case GENERATE:\n+          if (task.isSourceUpdated()) {\n+         // we need to reschedule the GEN task as the source data has changed\n+           log.debug(\"   Dependency ID \" + dependency.getId() + \" is in DONE and is going to be rescheduled as we need fresh data.\");\n+           rescheduleTask(dependencyServiceTask, execService, dispatcherQueue);\n+           proceed = false;\n+          } else {\n+           log.debug(\"   Dependency ID \" + dependency.getId() + \" is in DONE and it is of type GENERATE, we can proceed.\");\n+         // Nothing, we can proceed...\n+\n+           try {\n+            dependencyQueue = schedulingPool.getQueueForTask(dependencyServiceTask);\n+           } catch (InternalErrorException e) {\n+            log.error(\"Could not get queue for task {}\", dependencyServiceTask.getId());\n+           }\n+          }\n+          break;\n+         case SEND:\n+          log.debug(\"   Dependency ID \" + dependencyServiceTask.getId() + \" is in DONE and it is of type SEND, we can proceed.\");\n+        // Nothing, we can proceed...\n+          break;\n+         default:\n+          throw new IllegalArgumentException(\"Unknown ExecService type. Expected GENERATE or SEND.\");\n+        }\n+        break;\n+       case ERROR:\n+        switch (dependency.getExecServiceType()) {\n+         case GENERATE:\n+          log.info(\"   Dependency ID \" + dependencyServiceTask.getId() + \" is in ERROR and it is of type GENERATE, we are gonna propagate.\");\n+        // scheduleItAndWait(dependency, facility,\n+        // execService, dispatcherQueue);\n+        // try to run the generate task again\n+          rescheduleTask(dependencyServiceTask, execService, dispatcherQueue);\n+          proceed = false;\n+          break;\n+         case SEND:\n+          log.info(\"   Dependency ID \" + dependencyServiceTask.getId() + \" is in ERROR and it is of type SEND, we are gonna end with ERROR.\");\n+          proceed = false;\n+        // We end Task with error immediately.\n+          schedulingPool.setTaskStatus(task, TaskStatus.ERROR);\n+        // manipulateTasks(execService, facility, task);\n+\n+        // And we set all its GENERATE dependencies as\n+        // \"dirty\" by switching them to NONE state.\n+        // Note: Yes, there might have been some stored\n+        // from the previous runs...\n+        // propagationMaintainer.setAllGenerateDependenciesToNone(dependencies,\n+        // facility);\n+          break;\n+         default:\n+          throw new IllegalArgumentException(\"Unknown ExecService type. Expected GENERATE or SEND.\");\n+        }\n+        break;\n+       case NONE:\n+        log.info(\"   Last Task {} [dependency:\" + dependency.getId() + \", facility:\" + facility.getId() + \"] was NONE, we are gonna propagate.\", dependencyServiceTask.getId());\n+        rescheduleTask(dependencyServiceTask, execService, dispatcherQueue);\n+        proceed = false;\n+        break;\n+       case PLANNED:\n+        log.info(\"   Dependency ID \" + dependencyServiceTask.getId() + \" is in PLANNED so we are gonna wait.\");\n+       // we do not need to put it back in pool here\n+       // justWait(facility, execService);\n+        if (dependencyScope.equals(DependencyScope.SERVICE)) {\n+         proceed = false;\n+        } else {\n+         try {\n+          dependencyQueue = schedulingPool.getQueueForTask(dependencyServiceTask);\n+         } catch (InternalErrorException e) {\n+          log.error(\"Could not get queue for task {}\", dependencyServiceTask.getId());\n+         }\n+        }\n+        break;\n+       case PROCESSING:\n+        log.info(\"   Dependency ID \" + dependencyServiceTask.getId() + \" is in PROCESSING so we are gonna wait.\");\n+       // we do not need to put it back in pool here\n+       // justWait(facility, execService);\n+        if (dependencyScope.equals(DependencyScope.SERVICE)) {\n+         proceed = false;\n+        } else {\n+         try {\n+          dependencyQueue = schedulingPool.getQueueForTask(dependencyServiceTask);\n+         } catch (InternalErrorException e) {\n+          log.error(\"Could not get queue for task {}\", dependencyServiceTask.getId());\n+         }\n+        }\n+        if (dependencyServiceTask.isPropagationForced() && !wasDependencyServiceTaskForced) {\n+        // reschedule dependant only if originally was not forced !!!\n+         rescheduleTask(dependencyServiceTask, execService, dispatcherQueue);\n+        // XXX - should we proceed here?\n+        }\n+        break;\n+       default:\n+        throw new IllegalArgumentException(\"Unknown Task status. Expected DONE, ERROR, NONE, PLANNED or PROCESSING.\");\n+      }\n+     }\n+    }\n+    // Finally, if we can proceed, we proceed...\n+    // #########################################\n+    if (proceed) {\n+     if (abortTask) {\n+      // the SEND task is going to be aborted now\n+      abortTask(task);\n+      return false;\n+     } else {\n+      if (dependencyQueue != null && dependencyQueue != dispatcherQueue) {\n+       log.debug(\"Changing task {} destination queue to {} to match dependency task\",\n+       task.getId(),\n+       dependencyQueue.getClientID());\n+\n+       try {\n+        schedulingPool.setQueueForTask(task, dependencyQueue);\n+       } catch (InternalErrorException e) {\n+        log.error(\"Could not change task {} destination queue: {}\", task.getId(), e.getMessage());\n+       }\n+      }\n+      log.info(\"   SCHEDULING task [\" + task.getId() + \"], execService [\" + execService.getId() + \"] facility [\" + facility.getId() + \"] as PLANNED.\");\n+      task.setSchedule(time);\n+      schedulingPool.setTaskStatus(task, TaskStatus.PLANNED);\n+      sendToEngine(task);\n+     }\n+     // manipulateTasks(execService, facility, task);\n+    } else {\n+     if (abortTask) {\n+      // the SEND task is going to be aborted now\n+      abortTask(task);\n+      return false;\n+     } else {\n+      // If we can not proceed, we just end here.\n+      // ########################################\n+      // The current ExecService,Facility pair should be sleeping\n+      // in SchedulingPool at the moment...\n+      log.info(\"   Task {} state set to NONE, will be scheduled again at the next cycle.\", task.getId());\n+      schedulingPool.setTaskStatus(task, TaskStatus.NONE);\n+     }\n+    }\n+   } else if (execService.getExecServiceType().equals(ExecServiceType.GENERATE)) {\n+    log.debug(\"   Well, it is not. ExecService of type GENERATE does not have any dependencies by design, so we schedule it immediately.\");\n+    log.info(\"   SCHEDULING task [\" + task.getId() + \"], execService [\" + execService.getId() + \"] facility [\" + facility.getId() + \"] as PLANNED.\");\n+    task.setSchedule(time);\n+    schedulingPool.setTaskStatus(task, TaskStatus.PLANNED);\n+    // we are going to run the GEN task, so reset the source updated flag to\n+    // allow rerunning the GEN when data changes before the GEN is complete\n+    for (ExecService dependantService : dependantServices) {\n+     Task dependantServiceTask = schedulingPool.getTask(dependantService, facility);\n+     if (dependantServiceTask != null && dependantServiceTask.isSourceUpdated()) {\n+      dependantServiceTask.setSourceUpdated(false);\n+     }\n+    }\n+    sendToEngine(task);\n+    // manipulateTasks(execService, facility, task);\n+   } else {\n+    throw new IllegalArgumentException(\"Unknown ExecService type. Expected GENERATE or SEND.\");\n+   }\n+  } else {\n+   log.debug(\"   We do not proceed, we put the task [\" + task.getId() + \"], [\" + execService.getId() + \"] execService to sleep.\");\n+  }\n+\n+  return true;\n+ }\n+\n+\n+ private void abortTask(Task task) {\n+  log.debug(\"Aborting task {}, removing from pool.\", task.getId());\n+  schedulingPool.removeTask(task);\n+ }\n+\n+\n+ private void refetchTaskInformation(Task task) throws FacilityNotExistsException, InternalErrorException, PrivilegeException, ServiceNotExistsException {\n+  // reread facility\n+  log.debug(\"Rereading facility and  exec service for task {}\", task.getId());\n+  Facility dbFacility = perun.getFacilitiesManagerBl().getFacilityById(perunSession, task.getFacilityId());\n+  if (dbFacility == null) {\n+   throw new FacilityNotExistsException(\"No facility with id \" + task.getFacilityId());\n+  }\n+  Boolean taskModified = false;\n+  if (!dbFacility.equals(task.getFacility())) {\n+   task.setFacility(dbFacility);\n+   taskModified = true;\n+  }\n+  // reread exec service (and service)\n+  ExecService dbExecService = generalServiceManager.getExecService(perunSession, task.getExecServiceId());\n+  if (dbExecService == null) {\n+   throw new ServiceNotExistsException(\"No exec service with id \" + task.getExecServiceId());\n+  }\n+  if (!dbExecService.equals(task.getExecService())) {\n+   task.setExecService(dbExecService);\n+   taskModified = true;\n+  }\n+  if (taskModified) {\n+   log.debug(\"Task components have changed, updating task {}\", task.getId());\n+   schedulingPool.setTaskStatus(task, task.getStatus());\n+  }\n+ }\n+\n+\n+ private Boolean scheduleItAndWait(ExecService dependency, Facility facility, ExecService execService, DispatcherQueue dispatcherQueue, Date time) {\n+  // this is called to schedule dependencies of given task\n+  Task task = new Task();\n+  task.setExecService(dependency);\n+  task.setFacility(facility);\n+  task.setSchedule(time);\n+\n+  try {\n+   schedulingPool.addToPool(task, dispatcherQueue);\n+   return scheduleTask(task);\n+  } catch (InternalErrorException e) {\n+   log.error(\"Could not schedule new task: \" + e.getMessage());\n+   return false;\n+  }\n+  // schedulingPool.setTaskStatus(task, TaskStatus.NONE);\n+ }\n+\n+\n+ private Boolean rescheduleTask(Task dependencyServiceTask, ExecService execService, DispatcherQueue dispatcherQueue) {\n+  // task is in the pool already, just go for recursion\n+  return scheduleTask(dependencyServiceTask);\n+ }\n+\n+\n+ private void sendToEngine(Task task) {\n+  DispatcherQueue dispatcherQueue;\n+  try {\n+   dispatcherQueue = schedulingPool.getQueueForTask(task);\n+  } catch (InternalErrorException e1) {\n+   log.error(\"No engine set for task \" + task.toString() + \", could not send it!\");\n+   return;\n+  }\n+  if (dispatcherQueue == null) {\n+   // where should we send the task?\n+   if (dispatcherQueuePool.poolSize() > 0) {\n+    dispatcherQueue = dispatcherQueuePool.getPool().iterator().next();\n+\n+    try {\n+     schedulingPool.setQueueForTask(task, dispatcherQueue);\n+    } catch (InternalErrorException e) {\n+     log.error(\"Could not assign new queue for task {}: {}\", task.getId(), e);\n+     return;\n+    }\n+    log.debug(\"Assigned new queue \" + dispatcherQueue.getQueueName() + \" to task \" + task.getId());\n+   } else {\n+    // bad luck...\n+    log.error(\"Task \" + task.toString() + \" has no engine assigned and there are no engines registered...\");\n+    return;\n+   }\n+  }\n+\n+  // task|[engine_id]|[task_id][is_forced][exec_service_id][facility]|[destination_list]|[dependency_list]\n+  // - the task|[engine_id] part is added by dispatcherQueue\n+  List<Destination> destinations = task.getDestinations();\n+  if (destinations == null || destinations.isEmpty()) {\n+   log.debug(\"No destinations for task \" + task.toString() + \", trying to query the database...\");\n+\n+   try {\n+    initPerunSession();\n+    destinations = perun.getServicesManager().getDestinations(perunSession, task.getExecService().getService(), task.getFacility());\n+   } catch (ServiceNotExistsException e) {\n+    log.error(\"No destinations found for task \" + task.getId());\n+    task.setEndTime(new Date(System.currentTimeMillis()));\n+    schedulingPool.setTaskStatus(task, TaskStatus.ERROR);\n+    return;\n+   } catch (FacilityNotExistsException e) {\n+    log.error(\"Facility for task {} does not exist...\", task.getId());\n+    task.setEndTime(new Date(System.currentTimeMillis()));\n+    schedulingPool.setTaskStatus(task, TaskStatus.ERROR);\n+    return;\n+   } catch (PrivilegeException e) {\n+    log.error(\"Privilege error accessing the database: \" + e.getMessage());\n+    task.setEndTime(new Date(System.currentTimeMillis()));\n+    schedulingPool.setTaskStatus(task, TaskStatus.ERROR);\n+    return;\n+   } catch (InternalErrorException e) {\n+    log.error(\"Internal error: \" + e.getMessage());\n+    task.setEndTime(new Date(System.currentTimeMillis()));\n+    schedulingPool.setTaskStatus(task, TaskStatus.ERROR);\n+    return;\n+   }\n+  }\n+  log.debug(\"Fetched destinations: \" + ((destinations == null) ? \"[]\" : destinations.toString()));\n+  task.setDestinations(destinations);\n+  if (task.getExecService().getExecServiceType().equals(ExecServiceType.SEND) && (destinations == null || destinations.isEmpty())) {\n+   log.info(\"Task [] has no destination, setting to error.\");\n+   task.setEndTime(new Date(System.currentTimeMillis()));\n+   schedulingPool.setTaskStatus(task, TaskStatus.ERROR);\n+   return;\n+  }\n+  StringBuilder destinations_s = new StringBuilder(\"Destinations [\");\n+  if (destinations != null) {\n+\n+   for (Destination destination : destinations) {\n+    destinations_s.append(destination.serializeToString() + \", \");\n+   }\n+  }\n+  destinations_s.append(\"]\");\n+  String dependencies = \"\";\n+  dispatcherQueue.sendMessage(\"[\" + task.getId() + \"][\" + task.isPropagationForced() + \"]|[\" + fixStringSeparators(task.getExecService().serializeToString()) + \"]|[\" + fixStringSeparators(task.getFacility().serializeToString()) + \"]|[\" + fixStringSeparators(destinations_s.toString()) + \"]|[\" + dependencies + \"]\");\n+  task.setStartTime(new Date(System.currentTimeMillis()));\n+  task.setEndTime(null);\n+  schedulingPool.setTaskStatus(task, TaskStatus.PROCESSING);\n+ }\n+\n+\n+ private String fixStringSeparators(String data) {\n+  if (data.contains(\"|\")) {\n+   return new String(Base64.encodeBase64(data.getBytes()));\n+  } else {\n+   return data;\n+  }\n+ }\n+\n+ @Override\n+ public int getPoolSize() {\n+  return schedulingPool.getSize();\n+ }\n+\n+ public SchedulingPool getSchedulingPool() {\n+  return schedulingPool;\n+ }\n+\n+ public void setSchedulingPool(SchedulingPool schedulingPool) {\n+  this.schedulingPool = schedulingPool;\n+ }\n+\n+\n+ private void initPerunSession() throws InternalErrorException {\n+  if (perunSession == null) {\n+   perunSession = perun.getPerunSession(\n+    new PerunPrincipal(dispatcherPropertiesBean.getProperty(\"perun.principal.name\"), dispatcherPropertiesBean.getProperty(\"perun.principal.extSourceName\"), dispatcherPropertiesBean.getProperty(\"perun.principal.extSourceType\")), new PerunClient());\n+  }\n+ }\n+\n+}\n\\ No newline at end of file\n",
            "diff_size": 646
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/38/TaskSchedulerImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/styler_random/38/TaskSchedulerImpl.java\nindex 2f9ccae80cf..f100d04fb16 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/38/TaskSchedulerImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/styler_random/38/TaskSchedulerImpl.java\n@@ -621,8 +621,7 @@ public class TaskSchedulerImpl implements TaskScheduler {\n \t\t}\n \t\tlog.debug(\"Fetched destinations: \" + ( (destinations == null) ?  \"[]\" : destinations.toString()));\n \t\ttask.setDestinations(destinations);\n-\t\tif(task.getExecService().getExecServiceType().equals(ExecServiceType.SEND) && \n-\t\t   (destinations == null || destinations.isEmpty())) {\n+\t\tif(task.getExecService().getExecServiceType().equals(ExecServiceType.SEND) && (destinations == null || destinations.isEmpty())) {\n \t\t\tlog.info(\"Task [] has no destination, setting to error.\");\n \t\t\ttask.setEndTime(new Date(System.currentTimeMillis()));\n \t\t\tschedulingPool.setTaskStatus(task, TaskStatus.ERROR);\n",
            "diff_size": 2
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/38/TaskSchedulerImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/styler_three_grams/38/TaskSchedulerImpl.java\nindex 2f9ccae80cf..377272b355a 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/38/TaskSchedulerImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/styler_three_grams/38/TaskSchedulerImpl.java\n@@ -621,8 +621,7 @@ public class TaskSchedulerImpl implements TaskScheduler {\n \t\t}\n \t\tlog.debug(\"Fetched destinations: \" + ( (destinations == null) ?  \"[]\" : destinations.toString()));\n \t\ttask.setDestinations(destinations);\n-\t\tif(task.getExecService().getExecServiceType().equals(ExecServiceType.SEND) && \n-\t\t   (destinations == null || destinations.isEmpty())) {\n+\t\tif(task.getExecService().getExecServiceType().equals ( ExecServiceType .SEND ) && ( destinations == null || destinations.isEmpty())) {\n \t\t\tlog.info(\"Task [] has no destination, setting to error.\");\n \t\t\ttask.setEndTime(new Date(System.currentTimeMillis()));\n \t\t\tschedulingPool.setTaskStatus(task, TaskStatus.ERROR);\n",
            "diff_size": 2
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "naturalize"
    ]
}