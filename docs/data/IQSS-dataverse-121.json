{
    "project_name": "IQSS-dataverse",
    "error_id": "121",
    "information": {
        "errors": [
            {
                "line": "515",
                "column": "116",
                "severity": "error",
                "message": "File contains tab characters (this is the first instance).",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
            }
        ]
    },
    "source_code": "        //Now get the language-specific value if it exists\n        if (!language.equalsIgnoreCase(BundleUtil.getDefaultLocale().getLanguage())) {\n            appTermsOfUse = settingsService.getValueForKey(SettingsServiceBean.Key.ApplicationTermsOfUse, language,\tappTermsOfUse);\n        }\n        return appTermsOfUse;\n    }",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "1058",
                    "column": "1",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/121/SystemConfig.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler/121/SystemConfig.java\nindex 71accdaa8c8..d6447515b34 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/121/SystemConfig.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler/121/SystemConfig.java\n@@ -512,7 +512,7 @@ public class SystemConfig {\n         String appTermsOfUse = settingsService.getValueForKey(SettingsServiceBean.Key.ApplicationTermsOfUse, saneDefaultForAppTermsOfUse);\n         //Now get the language-specific value if it exists\n         if (!language.equalsIgnoreCase(BundleUtil.getDefaultLocale().getLanguage())) {\n-            appTermsOfUse = settingsService.getValueForKey(SettingsServiceBean.Key.ApplicationTermsOfUse, language,\tappTermsOfUse);\n+            appTermsOfUse = settingsService.getValueForKey(SettingsServiceBean.Key.ApplicationTermsOfUse, language,appTermsOfUse);\n         }\n         return appTermsOfUse;\n     }\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/121/SystemConfig.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/intellij/121/SystemConfig.java\nindex 71accdaa8c8..99d925ffa39 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/121/SystemConfig.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/intellij/121/SystemConfig.java\n@@ -36,1032 +36,1070 @@ import org.apache.commons.io.IOUtils;\n @Named\n public class SystemConfig {\n \n-    private static final Logger logger = Logger.getLogger(SystemConfig.class.getCanonicalName());\n+  private static final Logger logger = Logger.getLogger(SystemConfig.class.getCanonicalName());\n+\n+  @EJB\n+  SettingsServiceBean settingsService;\n+\n+  @EJB\n+  DataverseServiceBean dataverseService;\n+\n+  @EJB\n+  AuthenticationServiceBean authenticationService;\n+\n+  public static final String DATAVERSE_PATH = \"/dataverse/\";\n+\n+  /**\n+   * A JVM option for the advertised fully qualified domain name (hostname) of\n+   * the Dataverse installation, such as \"dataverse.example.com\", which may\n+   * differ from the hostname that the server knows itself as.\n+   * <p>\n+   * The equivalent in DVN 3.x was \"dvn.inetAddress\".\n+   */\n+  public static final String FQDN = \"dataverse.fqdn\";\n+\n+  /**\n+   * A JVM option for specifying the \"official\" URL of the site.\n+   * Unlike the FQDN option above, this would be a complete URL,\n+   * with the protocol, port number etc.\n+   */\n+  public static final String SITE_URL = \"dataverse.siteUrl\";\n+\n+  /**\n+   * A JVM option for where files are stored on the file system.\n+   */\n+  public static final String FILES_DIRECTORY = \"dataverse.files.directory\";\n+\n+  /**\n+   * Some installations may not want download URLs to their files to be\n+   * available in Schema.org JSON-LD output.\n+   */\n+  public static final String FILES_HIDE_SCHEMA_DOT_ORG_DOWNLOAD_URLS =\n+    \"dataverse.files.hide-schema-dot-org-download-urls\";\n+\n+  /**\n+   * A JVM option to override the number of minutes for which a password reset\n+   * token is valid ({@link #minutesUntilPasswordResetTokenExpires}).\n+   */\n+  private static final String PASSWORD_RESET_TIMEOUT_IN_MINUTES = \"dataverse.auth.password-reset-timeout-in-minutes\";\n+\n+  /**\n+   * A common place to find the String for a sane Solr hostname:port\n+   * combination.\n+   */\n+  private String saneDefaultForSolrHostColonPort = \"localhost:8983\";\n+\n+  /**\n+   * The default number of datafiles that we allow to be created through\n+   * zip file upload.\n+   */\n+  private static final int defaultZipUploadFilesLimit = 1000;\n+  private static final int defaultMultipleUploadFilesLimit = 1000;\n+  private static final int defaultLoginSessionTimeout = 480; // = 8 hours\n+\n+  private static String appVersionString = null;\n+  private static String buildNumberString = null;\n+\n+  private static final String JVM_TIMER_SERVER_OPTION = \"dataverse.timerServer\";\n+\n+  private static final long DEFAULT_GUESTBOOK_RESPONSES_DISPLAY_LIMIT = 5000L;\n+\n+  public String getVersion() {\n+    return getVersion(false);\n+  }\n+\n+  public String getVersion(boolean withBuildNumber) {\n+\n+    if (appVersionString == null) {\n+\n+      // The Version Number is no longer supplied in a .properties file - so\n+      // we can't just do\n+      //  return BundleUtil.getStringFromBundle(\"version.number\", null, ResourceBundle.getBundle(\"VersionNumber\", Locale.US));\n+      //\n+      // Instead, we'll rely on Maven placing the version number into the\n+      // Manifest, and getting it from there:\n+      // (this is considered a better practice, and will also allow us\n+      // to maintain this number in only one place - the pom.xml file)\n+      // -- L.A. 4.0.2\n+\n+      // One would assume, that once the version is in the MANIFEST.MF,\n+      // as Implementation-Version:, it would be possible to obtain\n+      // said version simply as\n+      //    appVersionString = getClass().getPackage().getImplementationVersion();\n+      // alas - that's not working, for whatever reason. (perhaps that's\n+      // only how it works with jar-ed packages; not with .war files).\n+      // People on the interwebs suggest that one should instead\n+      // open the Manifest as a resource, then extract its attributes.\n+      // There were some complications with that too. Plus, relying solely\n+      // on the MANIFEST.MF would NOT work for those of the developers who\n+      // are using \"in place deployment\" (i.e., where\n+      // Netbeans runs their builds directly from the local target\n+      // directory, bypassing the war file deployment; and the Manifest\n+      // is only available in the .war file). For that reason, I am\n+      // going to rely on the pom.properties file, and use java.util.Properties\n+      // to read it. We have to look for this file in 2 different places\n+      // depending on whether this is a .war file deployment, or a\n+      // developers build. (the app-level META-INF is only populated when\n+      // a .war file is built; the \"maven-archiver\" directory, on the other\n+      // hand, is only available when it's a local build deployment).\n+      // So, long story short, I'm resorting to the convoluted steps below.\n+      // It may look hacky, but it should actually be pretty solid and\n+      // reliable.\n+\n+\n+      // First, find the absolute path url of the application persistence file\n+      // always supplied with the Dataverse app:\n+      java.net.URL fileUrl = Thread.currentThread().getContextClassLoader().getResource(\"META-INF/persistence.xml\");\n+      String filePath = null;\n+\n+\n+      if (fileUrl != null) {\n+        filePath = fileUrl.getFile();\n+        if (filePath != null) {\n+          InputStream mavenPropertiesInputStream = null;\n+          String mavenPropertiesFilePath;\n+          Properties mavenProperties = new Properties();\n+\n+\n+          filePath = filePath.replaceFirst(\"/[^/]*$\", \"/\");\n+          // Using a relative path, find the location of the maven pom.properties file.\n+          // First, try to look for it in the app-level META-INF. This will only be\n+          // available if it's a war file deployment:\n+          mavenPropertiesFilePath = filePath.concat(\"../../../META-INF/maven/edu.harvard.iq/dataverse/pom.properties\");\n+\n+          try {\n+            mavenPropertiesInputStream = new FileInputStream(mavenPropertiesFilePath);\n+          } catch (IOException ioex) {\n+            // OK, let's hope this is a local dev. build.\n+            // In that case the properties file should be available in\n+            // the maven-archiver directory:\n+\n+            mavenPropertiesFilePath = filePath.concat(\"../../../../maven-archiver/pom.properties\");\n+\n+            // try again:\n \n-    @EJB\n-    SettingsServiceBean settingsService;\n-\n-    @EJB\n-    DataverseServiceBean dataverseService;\n-\n-    @EJB\n-    AuthenticationServiceBean authenticationService;\n-    \n-   public static final String DATAVERSE_PATH = \"/dataverse/\";\n-\n-    /**\n-     * A JVM option for the advertised fully qualified domain name (hostname) of\n-     * the Dataverse installation, such as \"dataverse.example.com\", which may\n-     * differ from the hostname that the server knows itself as.\n-     *\n-     * The equivalent in DVN 3.x was \"dvn.inetAddress\".\n-     */\n-    public static final String FQDN = \"dataverse.fqdn\";\n-    \n-    /**\n-     * A JVM option for specifying the \"official\" URL of the site.\n-     * Unlike the FQDN option above, this would be a complete URL, \n-     * with the protocol, port number etc. \n-     */\n-    public static final String SITE_URL = \"dataverse.siteUrl\";\n-\n-    /**\n-     * A JVM option for where files are stored on the file system.\n-     */\n-    public static final String FILES_DIRECTORY = \"dataverse.files.directory\";\n-\n-    /**\n-     * Some installations may not want download URLs to their files to be\n-     * available in Schema.org JSON-LD output.\n-     */\n-    public static final String FILES_HIDE_SCHEMA_DOT_ORG_DOWNLOAD_URLS = \"dataverse.files.hide-schema-dot-org-download-urls\";\n-\n-    /**\n-     * A JVM option to override the number of minutes for which a password reset\n-     * token is valid ({@link #minutesUntilPasswordResetTokenExpires}).\n-     */\n-    private static final String PASSWORD_RESET_TIMEOUT_IN_MINUTES = \"dataverse.auth.password-reset-timeout-in-minutes\";\n-\n-    /**\n-     * A common place to find the String for a sane Solr hostname:port\n-     * combination.\n-     */\n-    private String saneDefaultForSolrHostColonPort = \"localhost:8983\";\n-\n-    /**\n-     * The default number of datafiles that we allow to be created through \n-     * zip file upload.\n-     */\n-    private static final int defaultZipUploadFilesLimit = 1000; \n-    private static final int defaultMultipleUploadFilesLimit = 1000;\n-    private static final int defaultLoginSessionTimeout = 480; // = 8 hours\n-\n-    private static String appVersionString = null; \n-    private static String buildNumberString = null; \n-    \n-    private static final String JVM_TIMER_SERVER_OPTION = \"dataverse.timerServer\";\n-    \n-    private static final long DEFAULT_GUESTBOOK_RESPONSES_DISPLAY_LIMIT = 5000L; \n-    \n-    public String getVersion() {\n-        return getVersion(false);\n-    }\n-    \n-    public String getVersion(boolean withBuildNumber) {\n-        \n-        if (appVersionString == null) {\n-\n-            // The Version Number is no longer supplied in a .properties file - so\n-            // we can't just do \n-            //  return BundleUtil.getStringFromBundle(\"version.number\", null, ResourceBundle.getBundle(\"VersionNumber\", Locale.US));\n-            //\n-            // Instead, we'll rely on Maven placing the version number into the\n-            // Manifest, and getting it from there:\n-            // (this is considered a better practice, and will also allow us\n-            // to maintain this number in only one place - the pom.xml file)\n-            // -- L.A. 4.0.2\n-            \n-            // One would assume, that once the version is in the MANIFEST.MF, \n-            // as Implementation-Version:, it would be possible to obtain \n-            // said version simply as \n-            //    appVersionString = getClass().getPackage().getImplementationVersion();\n-            // alas - that's not working, for whatever reason. (perhaps that's \n-            // only how it works with jar-ed packages; not with .war files).\n-            // People on the interwebs suggest that one should instead \n-            // open the Manifest as a resource, then extract its attributes. \n-            // There were some complications with that too. Plus, relying solely \n-            // on the MANIFEST.MF would NOT work for those of the developers who \n-            // are using \"in place deployment\" (i.e., where \n-            // Netbeans runs their builds directly from the local target \n-            // directory, bypassing the war file deployment; and the Manifest \n-            // is only available in the .war file). For that reason, I am \n-            // going to rely on the pom.properties file, and use java.util.Properties \n-            // to read it. We have to look for this file in 2 different places\n-            // depending on whether this is a .war file deployment, or a \n-            // developers build. (the app-level META-INF is only populated when\n-            // a .war file is built; the \"maven-archiver\" directory, on the other \n-            // hand, is only available when it's a local build deployment).\n-            // So, long story short, I'm resorting to the convoluted steps below. \n-            // It may look hacky, but it should actually be pretty solid and \n-            // reliable. \n-            \n-            \n-            // First, find the absolute path url of the application persistence file\n-            // always supplied with the Dataverse app:\n-            java.net.URL fileUrl = Thread.currentThread().getContextClassLoader().getResource(\"META-INF/persistence.xml\");\n-            String filePath = null;\n-\n-\n-            if (fileUrl != null) {\n-                filePath = fileUrl.getFile();\n-                if (filePath != null) {\n-                    InputStream mavenPropertiesInputStream = null;\n-                    String mavenPropertiesFilePath; \n-                    Properties mavenProperties = new Properties();\n-\n-                    \n-                    filePath = filePath.replaceFirst(\"/[^/]*$\", \"/\");\n-                    // Using a relative path, find the location of the maven pom.properties file. \n-                    // First, try to look for it in the app-level META-INF. This will only be \n-                    // available if it's a war file deployment: \n-                    mavenPropertiesFilePath = filePath.concat(\"../../../META-INF/maven/edu.harvard.iq/dataverse/pom.properties\");                                     \n-                    \n-                    try {\n-                        mavenPropertiesInputStream = new FileInputStream(mavenPropertiesFilePath);\n-                    } catch (IOException ioex) {\n-                        // OK, let's hope this is a local dev. build. \n-                        // In that case the properties file should be available in \n-                        // the maven-archiver directory: \n-                        \n-                        mavenPropertiesFilePath = filePath.concat(\"../../../../maven-archiver/pom.properties\");\n-                        \n-                        // try again: \n-                        \n-                        try {\n-                            mavenPropertiesInputStream = new FileInputStream(mavenPropertiesFilePath);\n-                        } catch (IOException ioex2) {\n-                            logger.warning(\"Failed to find and/or open for reading the pom.properties file.\");\n-                            mavenPropertiesInputStream = null; \n-                        }\n-                    }\n-                    \n-                    if (mavenPropertiesInputStream != null) {\n-                        try {\n-                            mavenProperties.load(mavenPropertiesInputStream);\n-                            appVersionString = mavenProperties.getProperty(\"version\");                        \n-                        } catch (IOException ioex) {\n-                            logger.warning(\"caught IOException trying to read and parse the pom properties file.\");\n-                        } finally {\n-                            IOUtils.closeQuietly(mavenPropertiesInputStream);\n-                        }\n-                    }\n-                    \n-                } else {\n-                    logger.warning(\"Null file path representation of the location of persistence.xml in the webapp root directory!\"); \n-                }\n-            } else {\n-                logger.warning(\"Could not find the location of persistence.xml in the webapp root directory!\");\n-            }\n-\n-            \n-            if (appVersionString == null) {\n-                // still null? - defaulting to 4.0:    \n-                appVersionString = \"4.0\";\n-            }\n-        }\n-            \n-        if (withBuildNumber) {\n-            if (buildNumberString == null) {\n-                // (build number is still in a .properties file in the source tree; it only \n-                // contains a real build number if this war file was built by \n-                // Jenkins) \n-                        \n-                try {\n-                    buildNumberString = ResourceBundle.getBundle(\"BuildNumber\").getString(\"build.number\");\n-                } catch (MissingResourceException ex) {\n-                    buildNumberString = null; \n-                }\n-            }\n-            \n-            if (buildNumberString != null && !buildNumberString.equals(\"\")) {\n-                return appVersionString + \" build \" + buildNumberString; \n-            } \n-        }        \n-        \n-        return appVersionString; \n-    }\n-\n-    public String getSolrHostColonPort() {\n-        String SolrHost;\n-        if ( System.getenv(\"SOLR_SERVICE_HOST\") != null && System.getenv(\"SOLR_SERVICE_HOST\") != \"\"){\n-            SolrHost = System.getenv(\"SOLR_SERVICE_HOST\");\n-        }\n-        else SolrHost = saneDefaultForSolrHostColonPort;\n-        String solrHostColonPort = settingsService.getValueForKey(SettingsServiceBean.Key.SolrHostColonPort, SolrHost);\n-        return solrHostColonPort;\n-    }\n-\n-    public boolean isProvCollectionEnabled() {\n-        String provCollectionEnabled = settingsService.getValueForKey(SettingsServiceBean.Key.ProvCollectionEnabled, null);\n-        if(\"true\".equalsIgnoreCase(provCollectionEnabled)){         \n-            return true;\n-        }\n-        return false;\n-\n-    }\n-    \n-    public int getMetricsCacheTimeoutMinutes() {\n-        int defaultValue = 10080; //one week in minutes\n-        SettingsServiceBean.Key key = SettingsServiceBean.Key.MetricsCacheTimeoutMinutes;\n-        String metricsCacheTimeString = settingsService.getValueForKey(key);\n-        if (metricsCacheTimeString != null) {\n-            int returnInt = 0;\n             try {\n-                returnInt = Integer.parseInt(metricsCacheTimeString);\n-                if (returnInt >= 0) {\n-                    return returnInt;\n-                } else {\n-                    logger.info(\"Returning \" + defaultValue + \" for \" + key + \" because value must be greater than zero, not \\\"\" + metricsCacheTimeString + \"\\\".\");\n-                }\n-            } catch (NumberFormatException ex) {\n-                logger.info(\"Returning \" + defaultValue + \" for \" + key + \" because value must be an integer greater than zero, not \\\"\" + metricsCacheTimeString + \"\\\".\");\n+              mavenPropertiesInputStream = new FileInputStream(mavenPropertiesFilePath);\n+            } catch (IOException ioex2) {\n+              logger.warning(\"Failed to find and/or open for reading the pom.properties file.\");\n+              mavenPropertiesInputStream = null;\n             }\n-        }\n-        return defaultValue;\n-    }\n-    \n-    public int getMinutesUntilConfirmEmailTokenExpires() {\n-        final int minutesInOneDay = 1440;\n-        final int reasonableDefault = minutesInOneDay;\n-        SettingsServiceBean.Key key = SettingsServiceBean.Key.MinutesUntilConfirmEmailTokenExpires;\n-        String valueFromDatabase = settingsService.getValueForKey(key);\n-        if (valueFromDatabase != null) {\n-            try {\n-                int intFromDatabase = Integer.parseInt(valueFromDatabase);\n-                if (intFromDatabase > 0) {\n-                    return intFromDatabase;\n-                } else {\n-                    logger.info(\"Returning \" + reasonableDefault + \" for \" + key + \" because value must be greater than zero, not \\\"\" + intFromDatabase + \"\\\".\");\n-                }\n-            } catch (NumberFormatException ex) {\n-                logger.info(\"Returning \" + reasonableDefault + \" for \" + key + \" because value must be an integer greater than zero, not \\\"\" + valueFromDatabase + \"\\\".\");\n-            }\n-        }\n-        logger.fine(\"Returning \" + reasonableDefault + \" for \" + key);\n-        return reasonableDefault;\n-    }\n+          }\n \n-    /**\n-     * The number of minutes for which a password reset token is valid. Can be\n-     * overridden by {@link #PASSWORD_RESET_TIMEOUT_IN_MINUTES}.\n-     */\n-    public static int getMinutesUntilPasswordResetTokenExpires() {\n-        final int reasonableDefault = 60;\n-        String configuredValueAsString = System.getProperty(PASSWORD_RESET_TIMEOUT_IN_MINUTES);\n-        if (configuredValueAsString != null) {\n-            int configuredValueAsInteger = 0;\n-            try {\n-                configuredValueAsInteger = Integer.parseInt(configuredValueAsString);\n-                if (configuredValueAsInteger > 0) {\n-                    return configuredValueAsInteger;\n-                } else {\n-                    logger.info(PASSWORD_RESET_TIMEOUT_IN_MINUTES + \" is configured as a negative number \\\"\" + configuredValueAsInteger + \"\\\". Using default value instead: \" + reasonableDefault);\n-                    return reasonableDefault;\n-                }\n-            } catch (NumberFormatException ex) {\n-                logger.info(\"Unable to convert \" + PASSWORD_RESET_TIMEOUT_IN_MINUTES + \" from \\\"\" + configuredValueAsString + \"\\\" into an integer value: \" + ex + \". Using default value \" + reasonableDefault);\n-            }\n-        }\n-        return reasonableDefault;\n-    }\n-    \n-    /**\n-     * The \"official\", designated URL of the site;\n-     * can be defined as a complete URL; or derived from the \n-     * \"official\" hostname. If none of these options is set,\n-     * defaults to the InetAddress.getLocalHOst() and https;\n-     * These are legacy JVM options. Will be eventualy replaced\n-     * by the Settings Service configuration.\n-     */\n-    public String getDataverseSiteUrl() {\n-        return getDataverseSiteUrlStatic();\n-    }\n-    \n-    public static String getDataverseSiteUrlStatic() {\n-        String hostUrl = System.getProperty(SITE_URL);\n-        if (hostUrl != null && !\"\".equals(hostUrl)) {\n-            return hostUrl;\n-        }\n-        String hostName = System.getProperty(FQDN);\n-        if (hostName == null) {\n+          if (mavenPropertiesInputStream != null) {\n             try {\n-                hostName = InetAddress.getLocalHost().getCanonicalHostName();\n-            } catch (UnknownHostException e) {\n-                return null;\n+              mavenProperties.load(mavenPropertiesInputStream);\n+              appVersionString = mavenProperties.getProperty(\"version\");\n+            } catch (IOException ioex) {\n+              logger.warning(\"caught IOException trying to read and parse the pom properties file.\");\n+            } finally {\n+              IOUtils.closeQuietly(mavenPropertiesInputStream);\n             }\n-        }\n-        hostUrl = \"https://\" + hostName;\n-        return hostUrl;\n-    }\n-    \n-    /**\n-     * URL Tracking: \n-     */\n-    public String getPageURLWithQueryString() {\n-        return PrettyContext.getCurrentInstance().getRequestURL().toURL() + PrettyContext.getCurrentInstance().getRequestQueryString().toQueryString();\n-    }\n+          }\n \n-    /**\n-     * The \"official\" server's fully-qualified domain name: \n-     */\n-    public String getDataverseServer() {\n-        // still reliese on a JVM option: \n-        String fqdn = System.getProperty(FQDN);\n-        if (fqdn == null) {\n-            try {\n-                fqdn = InetAddress.getLocalHost().getCanonicalHostName();\n-            } catch (UnknownHostException e) {\n-                return null;\n-            }\n+        } else {\n+          logger\n+            .warning(\"Null file path representation of the location of persistence.xml in the webapp root directory!\");\n         }\n-        return fqdn;\n-    }\n-\n-    public String getGuidesBaseUrl() {\n-        String saneDefault = \"https://guides.dataverse.org\";\n-        String guidesBaseUrl = settingsService.getValueForKey(SettingsServiceBean.Key.GuidesBaseUrl, saneDefault);\n-        return guidesBaseUrl + \"/\" + getGuidesLanguage();\n-    }\n-\n-    private String getGuidesLanguage() {\n-        String saneDefault = \"en\";\n-        return saneDefault;\n-    }\n+      } else {\n+        logger.warning(\"Could not find the location of persistence.xml in the webapp root directory!\");\n+      }\n \n-    public String getGuidesVersion() {\n-        String saneDefault = getVersion();\n-        String guidesVersion = settingsService.getValueForKey(SettingsServiceBean.Key.GuidesVersion, saneDefault);\n-        if (guidesVersion != null) {\n-            return guidesVersion;\n-        }\n-        return saneDefault;\n-    }\n \n-    public String getMetricsUrl() {\n-        String saneDefault = null;\n-        String metricsUrl = settingsService.getValueForKey(SettingsServiceBean.Key.MetricsUrl, saneDefault);\n-        return metricsUrl;\n+      if (appVersionString == null) {\n+        // still null? - defaulting to 4.0:\n+        appVersionString = \"4.0\";\n+      }\n     }\n \n-    static long getLongLimitFromStringOrDefault(String limitSetting, Long defaultValue) {\n-        Long limit = null;\n+    if (withBuildNumber) {\n+      if (buildNumberString == null) {\n+        // (build number is still in a .properties file in the source tree; it only\n+        // contains a real build number if this war file was built by\n+        // Jenkins)\n \n-        if (limitSetting != null && !limitSetting.equals(\"\")) {\n-            try {\n-                limit = new Long(limitSetting);\n-            } catch (NumberFormatException nfe) {\n-                limit = null;\n-            }\n+        try {\n+          buildNumberString = ResourceBundle.getBundle(\"BuildNumber\").getString(\"build.number\");\n+        } catch (MissingResourceException ex) {\n+          buildNumberString = null;\n         }\n-\n-        return limit != null ? limit : defaultValue;\n-    }\n-\n-    static int getIntLimitFromStringOrDefault(String limitSetting, Integer defaultValue) {\n-        Integer limit = null;\n-\n-        if (limitSetting != null && !limitSetting.equals(\"\")) {\n-            try {\n-                limit = new Integer(limitSetting);\n-            } catch (NumberFormatException nfe) {\n-                limit = null;\n-            }\n+      }\n+\n+      if (buildNumberString != null && !buildNumberString.equals(\"\")) {\n+        return appVersionString + \" build \" + buildNumberString;\n+      }\n+    }\n+\n+    return appVersionString;\n+  }\n+\n+  public String getSolrHostColonPort() {\n+    String SolrHost;\n+    if (System.getenv(\"SOLR_SERVICE_HOST\") != null && System.getenv(\"SOLR_SERVICE_HOST\") != \"\") {\n+      SolrHost = System.getenv(\"SOLR_SERVICE_HOST\");\n+    } else {\n+      SolrHost = saneDefaultForSolrHostColonPort;\n+    }\n+    String solrHostColonPort = settingsService.getValueForKey(SettingsServiceBean.Key.SolrHostColonPort, SolrHost);\n+    return solrHostColonPort;\n+  }\n+\n+  public boolean isProvCollectionEnabled() {\n+    String provCollectionEnabled = settingsService.getValueForKey(SettingsServiceBean.Key.ProvCollectionEnabled, null);\n+    if (\"true\".equalsIgnoreCase(provCollectionEnabled)) {\n+      return true;\n+    }\n+    return false;\n+\n+  }\n+\n+  public int getMetricsCacheTimeoutMinutes() {\n+    int defaultValue = 10080; //one week in minutes\n+    SettingsServiceBean.Key key = SettingsServiceBean.Key.MetricsCacheTimeoutMinutes;\n+    String metricsCacheTimeString = settingsService.getValueForKey(key);\n+    if (metricsCacheTimeString != null) {\n+      int returnInt = 0;\n+      try {\n+        returnInt = Integer.parseInt(metricsCacheTimeString);\n+        if (returnInt >= 0) {\n+          return returnInt;\n+        } else {\n+          logger.info(\"Returning \" + defaultValue + \" for \" + key + \" because value must be greater than zero, not \\\"\" +\n+            metricsCacheTimeString + \"\\\".\");\n         }\n-\n-        return limit != null ? limit : defaultValue;\n-    }\n+      } catch (NumberFormatException ex) {\n+        logger.info(\n+          \"Returning \" + defaultValue + \" for \" + key + \" because value must be an integer greater than zero, not \\\"\" +\n+            metricsCacheTimeString + \"\\\".\");\n+      }\n+    }\n+    return defaultValue;\n+  }\n+\n+  public int getMinutesUntilConfirmEmailTokenExpires() {\n+    final int minutesInOneDay = 1440;\n+    final int reasonableDefault = minutesInOneDay;\n+    SettingsServiceBean.Key key = SettingsServiceBean.Key.MinutesUntilConfirmEmailTokenExpires;\n+    String valueFromDatabase = settingsService.getValueForKey(key);\n+    if (valueFromDatabase != null) {\n+      try {\n+        int intFromDatabase = Integer.parseInt(valueFromDatabase);\n+        if (intFromDatabase > 0) {\n+          return intFromDatabase;\n+        } else {\n+          logger.info(\n+            \"Returning \" + reasonableDefault + \" for \" + key + \" because value must be greater than zero, not \\\"\" +\n+              intFromDatabase + \"\\\".\");\n+        }\n+      } catch (NumberFormatException ex) {\n+        logger.info(\"Returning \" + reasonableDefault + \" for \" + key +\n+          \" because value must be an integer greater than zero, not \\\"\" + valueFromDatabase + \"\\\".\");\n+      }\n+    }\n+    logger.fine(\"Returning \" + reasonableDefault + \" for \" + key);\n+    return reasonableDefault;\n+  }\n+\n+  /**\n+   * The number of minutes for which a password reset token is valid. Can be\n+   * overridden by {@link #PASSWORD_RESET_TIMEOUT_IN_MINUTES}.\n+   */\n+  public static int getMinutesUntilPasswordResetTokenExpires() {\n+    final int reasonableDefault = 60;\n+    String configuredValueAsString = System.getProperty(PASSWORD_RESET_TIMEOUT_IN_MINUTES);\n+    if (configuredValueAsString != null) {\n+      int configuredValueAsInteger = 0;\n+      try {\n+        configuredValueAsInteger = Integer.parseInt(configuredValueAsString);\n+        if (configuredValueAsInteger > 0) {\n+          return configuredValueAsInteger;\n+        } else {\n+          logger.info(\n+            PASSWORD_RESET_TIMEOUT_IN_MINUTES + \" is configured as a negative number \\\"\" + configuredValueAsInteger +\n+              \"\\\". Using default value instead: \" + reasonableDefault);\n+          return reasonableDefault;\n+        }\n+      } catch (NumberFormatException ex) {\n+        logger.info(\"Unable to convert \" + PASSWORD_RESET_TIMEOUT_IN_MINUTES + \" from \\\"\" + configuredValueAsString +\n+          \"\\\" into an integer value: \" + ex + \". Using default value \" + reasonableDefault);\n+      }\n+    }\n+    return reasonableDefault;\n+  }\n+\n+  /**\n+   * The \"official\", designated URL of the site;\n+   * can be defined as a complete URL; or derived from the\n+   * \"official\" hostname. If none of these options is set,\n+   * defaults to the InetAddress.getLocalHOst() and https;\n+   * These are legacy JVM options. Will be eventualy replaced\n+   * by the Settings Service configuration.\n+   */\n+  public String getDataverseSiteUrl() {\n+    return getDataverseSiteUrlStatic();\n+  }\n+\n+  public static String getDataverseSiteUrlStatic() {\n+    String hostUrl = System.getProperty(SITE_URL);\n+    if (hostUrl != null && !\"\".equals(hostUrl)) {\n+      return hostUrl;\n+    }\n+    String hostName = System.getProperty(FQDN);\n+    if (hostName == null) {\n+      try {\n+        hostName = InetAddress.getLocalHost().getCanonicalHostName();\n+      } catch (UnknownHostException e) {\n+        return null;\n+      }\n+    }\n+    hostUrl = \"https://\" + hostName;\n+    return hostUrl;\n+  }\n+\n+  /**\n+   * URL Tracking:\n+   */\n+  public String getPageURLWithQueryString() {\n+    return PrettyContext.getCurrentInstance().getRequestURL().toURL() +\n+      PrettyContext.getCurrentInstance().getRequestQueryString().toQueryString();\n+  }\n+\n+  /**\n+   * The \"official\" server's fully-qualified domain name:\n+   */\n+  public String getDataverseServer() {\n+    // still reliese on a JVM option:\n+    String fqdn = System.getProperty(FQDN);\n+    if (fqdn == null) {\n+      try {\n+        fqdn = InetAddress.getLocalHost().getCanonicalHostName();\n+      } catch (UnknownHostException e) {\n+        return null;\n+      }\n+    }\n+    return fqdn;\n+  }\n+\n+  public String getGuidesBaseUrl() {\n+    String saneDefault = \"https://guides.dataverse.org\";\n+    String guidesBaseUrl = settingsService.getValueForKey(SettingsServiceBean.Key.GuidesBaseUrl, saneDefault);\n+    return guidesBaseUrl + \"/\" + getGuidesLanguage();\n+  }\n+\n+  private String getGuidesLanguage() {\n+    String saneDefault = \"en\";\n+    return saneDefault;\n+  }\n+\n+  public String getGuidesVersion() {\n+    String saneDefault = getVersion();\n+    String guidesVersion = settingsService.getValueForKey(SettingsServiceBean.Key.GuidesVersion, saneDefault);\n+    if (guidesVersion != null) {\n+      return guidesVersion;\n+    }\n+    return saneDefault;\n+  }\n+\n+  public String getMetricsUrl() {\n+    String saneDefault = null;\n+    String metricsUrl = settingsService.getValueForKey(SettingsServiceBean.Key.MetricsUrl, saneDefault);\n+    return metricsUrl;\n+  }\n+\n+  static long getLongLimitFromStringOrDefault(String limitSetting, Long defaultValue) {\n+    Long limit = null;\n+\n+    if (limitSetting != null && !limitSetting.equals(\"\")) {\n+      try {\n+        limit = new Long(limitSetting);\n+      } catch (NumberFormatException nfe) {\n+        limit = null;\n+      }\n+    }\n+\n+    return limit != null ? limit : defaultValue;\n+  }\n+\n+  static int getIntLimitFromStringOrDefault(String limitSetting, Integer defaultValue) {\n+    Integer limit = null;\n+\n+    if (limitSetting != null && !limitSetting.equals(\"\")) {\n+      try {\n+        limit = new Integer(limitSetting);\n+      } catch (NumberFormatException nfe) {\n+        limit = null;\n+      }\n+    }\n+\n+    return limit != null ? limit : defaultValue;\n+  }\n+\n+  /**\n+   * Download-as-zip size limit.\n+   * returns 0 if not specified;\n+   * (the file zipper will then use the default value)\n+   * set to -1 to disable zip downloads.\n+   */\n+  public long getZipDownloadLimit() {\n+    String zipLimitOption = settingsService.getValueForKey(SettingsServiceBean.Key.ZipDownloadLimit);\n+    return getLongLimitFromStringOrDefault(zipLimitOption, 0L);\n+  }\n+\n+  public int getZipUploadFilesLimit() {\n+    String limitOption = settingsService.getValueForKey(SettingsServiceBean.Key.ZipUploadFilesLimit);\n+    return getIntLimitFromStringOrDefault(limitOption, defaultZipUploadFilesLimit);\n+  }\n+\n+  /**\n+   * Session timeout, in minutes.\n+   * (default value provided)\n+   */\n+  public int getLoginSessionTimeout() {\n+    return getIntLimitFromStringOrDefault(\n+      settingsService.getValueForKey(SettingsServiceBean.Key.LoginSessionTimeout),\n+      defaultLoginSessionTimeout);\n+  }\n+\n+  /*\n+  `   the number of files the GUI user is allowed to upload in one batch,\n+      via drag-and-drop, or through the file select dialog\n+  */\n+  public int getMultipleUploadFilesLimit() {\n+    String limitOption = settingsService.getValueForKey(SettingsServiceBean.Key.MultipleUploadFilesLimit);\n+    return getIntLimitFromStringOrDefault(limitOption, defaultMultipleUploadFilesLimit);\n+  }\n+\n+  public long getGuestbookResponsesPageDisplayLimit() {\n+    String limitSetting = settingsService.getValueForKey(SettingsServiceBean.Key.GuestbookResponsesPageDisplayLimit);\n+    return getLongLimitFromStringOrDefault(limitSetting, DEFAULT_GUESTBOOK_RESPONSES_DISPLAY_LIMIT);\n+  }\n+\n+  public long getUploadLogoSizeLimit() {\n+    return 500000;\n+  }\n+\n+  // TODO: (?)\n+  // create sensible defaults for these things? -- 4.2.2\n+  public long getThumbnailSizeLimitImage() {\n+    long limit = getThumbnailSizeLimit(\"Image\");\n+    return limit == 0 ? 500000 : limit;\n+  }\n+\n+  public long getThumbnailSizeLimitPDF() {\n+    long limit = getThumbnailSizeLimit(\"PDF\");\n+    return limit == 0 ? 500000 : limit;\n+  }\n+\n+  public long getThumbnailSizeLimit(String type) {\n+    String option = null;\n+\n+    //get options via jvm options\n+\n+    if (\"Image\".equals(type)) {\n+      option = System.getProperty(\"dataverse.dataAccess.thumbnail.image.limit\");\n+    } else if (\"PDF\".equals(type)) {\n+      option = System.getProperty(\"dataverse.dataAccess.thumbnail.pdf.limit\");\n+    }\n+\n+    return getLongLimitFromStringOrDefault(option, 0L);\n+  }\n+\n+  public boolean isThumbnailGenerationDisabledForType(String type) {\n+    return getThumbnailSizeLimit(type) == -1l;\n+  }\n+\n+  public boolean isThumbnailGenerationDisabledForImages() {\n+    return isThumbnailGenerationDisabledForType(\"Image\");\n+  }\n+\n+  public boolean isThumbnailGenerationDisabledForPDF() {\n+    return isThumbnailGenerationDisabledForType(\"PDF\");\n+  }\n+\n+  public String getApplicationTermsOfUse() {\n+    String language = BundleUtil.getCurrentLocale().getLanguage();\n+    String saneDefaultForAppTermsOfUse = BundleUtil.getStringFromBundle(\"system.app.terms\");\n+    // Get the value for the defaultLocale. IT will either be used as the return\n+    // value, or as a better default than the saneDefaultForAppTermsOfUse if there\n+    // is no language-specific value\n+    String appTermsOfUse =\n+      settingsService.getValueForKey(SettingsServiceBean.Key.ApplicationTermsOfUse, saneDefaultForAppTermsOfUse);\n+    //Now get the language-specific value if it exists\n+    if (!language.equalsIgnoreCase(BundleUtil.getDefaultLocale().getLanguage())) {\n+      appTermsOfUse =\n+        settingsService.getValueForKey(SettingsServiceBean.Key.ApplicationTermsOfUse, language, appTermsOfUse);\n+    }\n+    return appTermsOfUse;\n+  }\n+\n+  public String getApiTermsOfUse() {\n+    String saneDefaultForApiTermsOfUse = BundleUtil.getStringFromBundle(\"system.api.terms\");\n+    String apiTermsOfUse =\n+      settingsService.getValueForKey(SettingsServiceBean.Key.ApiTermsOfUse, saneDefaultForApiTermsOfUse);\n+    return apiTermsOfUse;\n+  }\n+\n+  // TODO:\n+  // remove this method!\n+  // pages should be using settingsWrapper.get(\":ApplicationPrivacyPolicyUrl\") instead. -- 4.2.1\n+  public String getApplicationPrivacyPolicyUrl() {\n+    String saneDefaultForPrivacyPolicyUrl = null;\n+    String appPrivacyPolicyUrl = settingsService\n+      .getValueForKey(SettingsServiceBean.Key.ApplicationPrivacyPolicyUrl, saneDefaultForPrivacyPolicyUrl);\n+    return appPrivacyPolicyUrl;\n+  }\n+\n+  public boolean myDataDoesNotUsePermissionDocs() {\n+    boolean safeDefaultIfKeyNotFound = false;\n+    return settingsService\n+      .isTrueForKey(SettingsServiceBean.Key.MyDataDoesNotUseSolrPermissionDocs, safeDefaultIfKeyNotFound);\n+  }\n+\n+  public boolean isFilesOnDatasetPageFromSolr() {\n+    boolean safeDefaultIfKeyNotFound = false;\n+    return settingsService.isTrueForKey(SettingsServiceBean.Key.FilesOnDatasetPageFromSolr, safeDefaultIfKeyNotFound);\n+  }\n+\n+  public Long getMaxFileUploadSizeForStore(String driverId) {\n+    return settingsService.getValueForCompoundKeyAsLong(SettingsServiceBean.Key.MaxFileUploadSizeInBytes, driverId);\n+  }\n+\n+  public Integer getSearchHighlightFragmentSize() {\n+    String fragSize = settingsService.getValueForKey(SettingsServiceBean.Key.SearchHighlightFragmentSize);\n+    if (fragSize != null) {\n+      try {\n+        return new Integer(fragSize);\n+      } catch (NumberFormatException nfe) {\n+        logger.info(\"Could not convert \" + SettingsServiceBean.Key.SearchHighlightFragmentSize + \" to int: \" + nfe);\n+      }\n+    }\n+    return null;\n+  }\n+\n+  public long getTabularIngestSizeLimit() {\n+    // This method will return the blanket ingestable size limit, if\n+    // set on the system. I.e., the universal limit that applies to all\n+    // tabular ingests, regardless of fromat:\n+\n+    String limitEntry = settingsService.getValueForKey(SettingsServiceBean.Key.TabularIngestSizeLimit);\n+\n+    if (limitEntry != null) {\n+      try {\n+        Long sizeOption = new Long(limitEntry);\n+        return sizeOption;\n+      } catch (NumberFormatException nfe) {\n+        logger.warning(\"Invalid value for TabularIngestSizeLimit option? - \" + limitEntry);\n+      }\n+    }\n+    // -1 means no limit is set;\n+    // 0 on the other hand would mean that ingest is fully disabled for\n+    // tabular data.\n+    return -1;\n+  }\n+\n+  public long getTabularIngestSizeLimit(String formatName) {\n+    // This method returns the size limit set specifically for this format name,\n+    // if available, otherwise - the blanket limit that applies to all tabular\n+    // ingests regardless of a format.\n+\n+    if (formatName == null || formatName.equals(\"\")) {\n+      return getTabularIngestSizeLimit();\n+    }\n+\n+    String limitEntry =\n+      settingsService.get(SettingsServiceBean.Key.TabularIngestSizeLimit.toString() + \":\" + formatName);\n+\n+    if (limitEntry != null) {\n+      try {\n+        Long sizeOption = new Long(limitEntry);\n+        return sizeOption;\n+      } catch (NumberFormatException nfe) {\n+        logger.warning(\"Invalid value for TabularIngestSizeLimit:\" + formatName + \"? - \" + limitEntry);\n+      }\n+    }\n+\n+    return getTabularIngestSizeLimit();\n+  }\n+\n+  public boolean isOAIServerEnabled() {\n+    boolean defaultResponse = false;\n+    return settingsService.isTrueForKey(SettingsServiceBean.Key.OAIServerEnabled, defaultResponse);\n+  }\n+\n+  public void enableOAIServer() {\n+    settingsService.setValueForKey(SettingsServiceBean.Key.OAIServerEnabled, \"true\");\n+  }\n+\n+  public void disableOAIServer() {\n+    settingsService.deleteValueForKey(SettingsServiceBean.Key.OAIServerEnabled);\n+  }\n+\n+  public boolean isTimerServer() {\n+    String optionValue = System.getProperty(JVM_TIMER_SERVER_OPTION);\n+    if (\"true\".equalsIgnoreCase(optionValue)) {\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  public String getFooterCopyrightAndYear() {\n+    return BundleUtil.getStringFromBundle(\"footer.copyright\", Arrays.asList(Year.now().getValue() + \"\"));\n+  }\n+\n+  public DataFile.ChecksumType getFileFixityChecksumAlgorithm() {\n+    DataFile.ChecksumType saneDefault = DataFile.ChecksumType.MD5;\n+    String checksumStringFromDatabase =\n+      settingsService.getValueForKey(SettingsServiceBean.Key.FileFixityChecksumAlgorithm, saneDefault.toString());\n+    try {\n+      DataFile.ChecksumType checksumTypeFromDatabase = DataFile.ChecksumType.fromString(checksumStringFromDatabase);\n+      return checksumTypeFromDatabase;\n+    } catch (IllegalArgumentException ex) {\n+      logger.info(\n+        \"The setting \" + SettingsServiceBean.Key.FileFixityChecksumAlgorithm + \" is misconfigured. \" + ex.getMessage() +\n+          \" Returning sane default: \" + saneDefault + \".\");\n+      return saneDefault;\n+    }\n+  }\n+\n+  public String getDefaultAuthProvider() {\n+    String saneDefault = BuiltinAuthenticationProvider.PROVIDER_ID;\n+    String settingInDatabase = settingsService.getValueForKey(SettingsServiceBean.Key.DefaultAuthProvider, saneDefault);\n+    if (settingInDatabase != null && !settingInDatabase.isEmpty()) {\n+      /**\n+       * @todo Add more sanity checking.\n+       */\n+      return settingInDatabase;\n+    }\n+    return saneDefault;\n+  }\n+\n+  public String getNameOfInstallation() {\n+    return dataverseService.getRootDataverseName();\n+  }\n+\n+  public AbstractOAuth2AuthenticationProvider.DevOAuthAccountType getDevOAuthAccountType() {\n+    AbstractOAuth2AuthenticationProvider.DevOAuthAccountType saneDefault =\n+      AbstractOAuth2AuthenticationProvider.DevOAuthAccountType.PRODUCTION;\n+    String settingReturned = settingsService.getValueForKey(SettingsServiceBean.Key.DebugOAuthAccountType);\n+    logger.fine(\"setting returned: \" + settingReturned);\n+    if (settingReturned != null) {\n+      try {\n+        AbstractOAuth2AuthenticationProvider.DevOAuthAccountType parsedValue =\n+          AbstractOAuth2AuthenticationProvider.DevOAuthAccountType.valueOf(settingReturned);\n+        return parsedValue;\n+      } catch (IllegalArgumentException ex) {\n+        logger.info(\"Couldn't parse value: \" + ex + \" - returning a sane default: \" + saneDefault);\n+        return saneDefault;\n+      }\n+    } else {\n+      logger.fine(\"OAuth dev mode has not been configured. Returning a sane default: \" + saneDefault);\n+      return saneDefault;\n+    }\n+  }\n+\n+  public String getOAuth2CallbackUrl() {\n+    String saneDefault = getDataverseSiteUrl() + \"/oauth2/callback.xhtml\";\n+    String settingReturned = settingsService.getValueForKey(SettingsServiceBean.Key.OAuth2CallbackUrl);\n+    logger.fine(\"getOAuth2CallbackUrl setting returned: \" + settingReturned);\n+    if (settingReturned != null) {\n+      return settingReturned;\n+    }\n+    return saneDefault;\n+  }\n+\n+  public boolean isShibPassiveLoginEnabled() {\n+    boolean defaultResponse = false;\n+    return settingsService.isTrueForKey(SettingsServiceBean.Key.ShibPassiveLoginEnabled, defaultResponse);\n+  }\n+\n+  public boolean isShibAttributeCharacterSetConversionEnabled() {\n+    boolean defaultResponse = true;\n+    return settingsService\n+      .isTrueForKey(SettingsServiceBean.Key.ShibAttributeCharacterSetConversionEnabled, defaultResponse);\n+  }\n+\n+  /**\n+   * getPVDictionaries\n+   *\n+   * @return A string of one or more pipe (|) separated file paths.\n+   */\n+  public String getPVDictionaries() {\n+    return settingsService.get(SettingsServiceBean.Key.PVDictionaries.toString());\n+  }\n+\n+  /**\n+   * getPVGoodStrength\n+   * <p>\n+   * Get the minimum length of a valid password to apply an expiration rule.\n+   * Defaults to 20.\n+   *\n+   * @return The length.\n+   */\n+  public int getPVGoodStrength() {\n+    // FIXME: Change this to 21 to match Harvard's requirements or implement a way to disable the rule (0 or -1) and have the default be disabled.\n+    int goodStrengthLength = 20;\n+    //String _goodStrengthLength = System.getProperty(\"pv.goodstrength\", settingsService.get(SettingsServiceBean.Key.PVGoodStrength.toString()));\n+    String _goodStrengthLength = settingsService.get(SettingsServiceBean.Key.PVGoodStrength.toString());\n+    try {\n+      goodStrengthLength = Integer.parseInt(_goodStrengthLength);\n+    } catch (NumberFormatException nfe) {\n+      logger.fine(\"Invalid value for PVGoodStrength: \" + _goodStrengthLength);\n+    }\n+    return goodStrengthLength;\n+  }\n+\n+  /**\n+   * getPVMinLength\n+   * <p>\n+   * Get the minimum length of a valid password. Defaults to 6.\n+   *\n+   * @return The length.\n+   */\n+  public int getPVMinLength() {\n+    int passportValidatorMinLength = 6;\n+    String _passportValidatorMinLength = settingsService.get(SettingsServiceBean.Key.PVMinLength.toString());\n+    try {\n+      passportValidatorMinLength = Integer.parseInt(_passportValidatorMinLength);\n+    } catch (NumberFormatException nfe) {\n+      logger.fine(\"Invalid value for PwMinLength: \" + _passportValidatorMinLength);\n+    }\n+    return passportValidatorMinLength;\n+  }\n+\n+  /**\n+   * getPVMaxLength\n+   * <p>\n+   * Get the maximum length of a valid password. Defaults to 0 (disabled).\n+   *\n+   * @return The length.\n+   */\n+  public int getPVMaxLength() {\n+    int passportValidatorMaxLength = 0;\n+    String _passportValidatorMaxLength = settingsService.get(SettingsServiceBean.Key.PVMaxLength.toString());\n+    try {\n+      passportValidatorMaxLength = Integer.parseInt(_passportValidatorMaxLength);\n+    } catch (NumberFormatException nfe) {\n+      logger.fine(\"Invalid value for PwMaxLength: \" + _passportValidatorMaxLength);\n+    }\n+    return passportValidatorMaxLength;\n+  }\n+\n+  /**\n+   * One letter, 2 special characters, etc. Defaults to:\n+   * <p>\n+   * - one uppercase\n+   * <p>\n+   * - one lowercase\n+   * <p>\n+   * - one digit\n+   * <p>\n+   * - one special character\n+   * <p>\n+   * TODO: This is more strict than what Dataverse 4.0 shipped with. Consider\n+   * keeping the default the same.\n+   */\n+  public List<CharacterRule> getPVCharacterRules() {\n+    String characterRulesString = settingsService.get(SettingsServiceBean.Key.PVCharacterRules.toString());\n+    return PasswordValidatorUtil.getCharacterRules(characterRulesString);\n+  }\n+\n+  /**\n+   * getPVNumberOfCharacteristics\n+   * <p>\n+   * Get the number M characteristics. Defaults to 3.\n+   *\n+   * @return The number.\n+   * <p>\n+   * TODO: Consider changing the out-of-the-box rules to be the same as Dataverse 4.0, which was 2 (one letter, one number).\n+   */\n+  public int getPVNumberOfCharacteristics() {\n+    int numberOfCharacteristics = 2;\n+    String _numberOfCharacteristics = settingsService.get(SettingsServiceBean.Key.PVNumberOfCharacteristics.toString());\n+    try {\n+      numberOfCharacteristics = Integer.parseInt(_numberOfCharacteristics);\n+    } catch (NumberFormatException nfe) {\n+      logger.fine(\"Invalid value for PVNumberOfCharacteristics: \" + _numberOfCharacteristics);\n+    }\n+    return numberOfCharacteristics;\n+  }\n+\n+  /**\n+   * Get the number of consecutive digits allowed. Defaults to highest int\n+   * possible.\n+   */\n+  public int getPVNumberOfConsecutiveDigitsAllowed() {\n+    int numConsecutiveDigitsAllowed = Integer.MAX_VALUE;\n+    String _numberOfConsecutiveDigitsAllowed =\n+      settingsService.get(SettingsServiceBean.Key.PVNumberOfConsecutiveDigitsAllowed.toString());\n+    try {\n+      numConsecutiveDigitsAllowed = Integer.parseInt(_numberOfConsecutiveDigitsAllowed);\n+    } catch (NumberFormatException nfe) {\n+      logger.fine(\"Invalid value for \" + SettingsServiceBean.Key.PVNumberOfConsecutiveDigitsAllowed + \": \" +\n+        _numberOfConsecutiveDigitsAllowed);\n+    }\n+    return numConsecutiveDigitsAllowed;\n+  }\n+\n+  /**\n+   * Below are three related enums having to do with big data support:\n+   * <p>\n+   * - FileUploadMethods\n+   * <p>\n+   * - FileDownloadMethods\n+   * <p>\n+   * - TransferProtocols\n+   * <p>\n+   * There is a good chance these will be consolidated in the future.\n+   */\n+  public enum FileUploadMethods {\n \n     /**\n-     * Download-as-zip size limit.\n-     * returns 0 if not specified; \n-     * (the file zipper will then use the default value)\n-     * set to -1 to disable zip downloads. \n+     * DCM stands for Data Capture Module. Right now it supports upload over\n+     * rsync+ssh but DCM may support additional methods in the future.\n      */\n-    public long getZipDownloadLimit() {\n-        String zipLimitOption = settingsService.getValueForKey(SettingsServiceBean.Key.ZipDownloadLimit);\n-        return getLongLimitFromStringOrDefault(zipLimitOption, 0L);\n-    }\n-    \n-    public int getZipUploadFilesLimit() {\n-        String limitOption = settingsService.getValueForKey(SettingsServiceBean.Key.ZipUploadFilesLimit);\n-        return getIntLimitFromStringOrDefault(limitOption, defaultZipUploadFilesLimit);\n-    }\n-    \n+    RSYNC(\"dcm/rsync+ssh\"),\n     /**\n-     * Session timeout, in minutes. \n-     * (default value provided)\n+     * Traditional Dataverse file handling, which tends to involve users\n+     * uploading and downloading files using a browser or APIs.\n      */\n-    public int getLoginSessionTimeout() {\n-        return getIntLimitFromStringOrDefault(\n-                settingsService.getValueForKey(SettingsServiceBean.Key.LoginSessionTimeout), \n-                defaultLoginSessionTimeout); \n-    }\n-    \n-    /*\n-    `   the number of files the GUI user is allowed to upload in one batch, \n-        via drag-and-drop, or through the file select dialog\n-    */\n-    public int getMultipleUploadFilesLimit() {\n-        String limitOption = settingsService.getValueForKey(SettingsServiceBean.Key.MultipleUploadFilesLimit);\n-        return getIntLimitFromStringOrDefault(limitOption, defaultMultipleUploadFilesLimit);\n-    }\n-    \n-    public long getGuestbookResponsesPageDisplayLimit() {\n-        String limitSetting = settingsService.getValueForKey(SettingsServiceBean.Key.GuestbookResponsesPageDisplayLimit);\n-        return getLongLimitFromStringOrDefault(limitSetting, DEFAULT_GUESTBOOK_RESPONSES_DISPLAY_LIMIT);\n-    }\n-    \n-    public long getUploadLogoSizeLimit(){\n-        return 500000;\n-    }\n-\n-    // TODO: (?)\n-    // create sensible defaults for these things? -- 4.2.2\n-    public long getThumbnailSizeLimitImage() {\n-        long limit = getThumbnailSizeLimit(\"Image\");\n-        return limit == 0 ? 500000 : limit;\n-    } \n-    \n-    public long getThumbnailSizeLimitPDF() {\n-        long limit = getThumbnailSizeLimit(\"PDF\");\n-        return limit == 0 ? 500000 : limit;\n-    }\n-    \n-    public long getThumbnailSizeLimit(String type) {\n-        String option = null; \n-        \n-        //get options via jvm options\n-        \n-        if (\"Image\".equals(type)) {\n-            option = System.getProperty(\"dataverse.dataAccess.thumbnail.image.limit\");\n-        } else if (\"PDF\".equals(type)) {\n-            option = System.getProperty(\"dataverse.dataAccess.thumbnail.pdf.limit\");\n-        }\n-\n-        return getLongLimitFromStringOrDefault(option, 0L);\n-    }\n-    \n-    public boolean isThumbnailGenerationDisabledForType(String type) {\n-        return getThumbnailSizeLimit(type) == -1l;\n-    }\n-    \n-    public boolean isThumbnailGenerationDisabledForImages() {\n-        return isThumbnailGenerationDisabledForType(\"Image\");\n-    }\n-    \n-    public boolean isThumbnailGenerationDisabledForPDF() {\n-        return isThumbnailGenerationDisabledForType(\"PDF\");\n-    }\n-    \n-    public String getApplicationTermsOfUse() {\n-        String language = BundleUtil.getCurrentLocale().getLanguage();\n-        String saneDefaultForAppTermsOfUse = BundleUtil.getStringFromBundle(\"system.app.terms\");\n-        // Get the value for the defaultLocale. IT will either be used as the return\n-        // value, or as a better default than the saneDefaultForAppTermsOfUse if there\n-        // is no language-specific value\n-        String appTermsOfUse = settingsService.getValueForKey(SettingsServiceBean.Key.ApplicationTermsOfUse, saneDefaultForAppTermsOfUse);\n-        //Now get the language-specific value if it exists\n-        if (!language.equalsIgnoreCase(BundleUtil.getDefaultLocale().getLanguage())) {\n-            appTermsOfUse = settingsService.getValueForKey(SettingsServiceBean.Key.ApplicationTermsOfUse, language,\tappTermsOfUse);\n-        }\n-        return appTermsOfUse;\n-    }\n-\n-    public String getApiTermsOfUse() {\n-        String saneDefaultForApiTermsOfUse = BundleUtil.getStringFromBundle(\"system.api.terms\");\n-        String apiTermsOfUse = settingsService.getValueForKey(SettingsServiceBean.Key.ApiTermsOfUse, saneDefaultForApiTermsOfUse);\n-        return apiTermsOfUse;\n-    }\n-\n-    // TODO: \n-    // remove this method!\n-    // pages should be using settingsWrapper.get(\":ApplicationPrivacyPolicyUrl\") instead. -- 4.2.1\n-    public String getApplicationPrivacyPolicyUrl() {\n-        String saneDefaultForPrivacyPolicyUrl = null;\n-        String appPrivacyPolicyUrl = settingsService.getValueForKey(SettingsServiceBean.Key.ApplicationPrivacyPolicyUrl, saneDefaultForPrivacyPolicyUrl);\n-        return appPrivacyPolicyUrl;\n-    }\n-\n-    public boolean myDataDoesNotUsePermissionDocs() {\n-        boolean safeDefaultIfKeyNotFound = false;\n-        return settingsService.isTrueForKey(SettingsServiceBean.Key.MyDataDoesNotUseSolrPermissionDocs, safeDefaultIfKeyNotFound);\n-    }\n-\n-    public boolean isFilesOnDatasetPageFromSolr() {\n-        boolean safeDefaultIfKeyNotFound = false;\n-        return settingsService.isTrueForKey(SettingsServiceBean.Key.FilesOnDatasetPageFromSolr, safeDefaultIfKeyNotFound);\n-    }\n+    NATIVE(\"native/http\");\n \n-    public Long getMaxFileUploadSizeForStore(String driverId){\n-         return settingsService.getValueForCompoundKeyAsLong(SettingsServiceBean.Key.MaxFileUploadSizeInBytes, driverId);\n-     }\n-    \n-    public Integer getSearchHighlightFragmentSize() {\n-        String fragSize = settingsService.getValueForKey(SettingsServiceBean.Key.SearchHighlightFragmentSize);\n-        if (fragSize != null) {\n-            try {\n-                return new Integer(fragSize);\n-            } catch (NumberFormatException nfe) {\n-                logger.info(\"Could not convert \" + SettingsServiceBean.Key.SearchHighlightFragmentSize + \" to int: \" + nfe);\n-            }\n-        }\n-        return null;\n-    }\n-    \n-    public long getTabularIngestSizeLimit() {\n-        // This method will return the blanket ingestable size limit, if \n-        // set on the system. I.e., the universal limit that applies to all \n-        // tabular ingests, regardless of fromat: \n-        \n-        String limitEntry = settingsService.getValueForKey(SettingsServiceBean.Key.TabularIngestSizeLimit); \n-        \n-        if (limitEntry != null) {\n-            try {\n-                Long sizeOption = new Long(limitEntry);\n-                return sizeOption;\n-            } catch (NumberFormatException nfe) {\n-                logger.warning(\"Invalid value for TabularIngestSizeLimit option? - \" + limitEntry);\n-            }\n-        }\n-        // -1 means no limit is set; \n-        // 0 on the other hand would mean that ingest is fully disabled for \n-        // tabular data. \n-        return -1; \n-    }\n-    \n-    public long getTabularIngestSizeLimit(String formatName) {\n-        // This method returns the size limit set specifically for this format name,\n-        // if available, otherwise - the blanket limit that applies to all tabular \n-        // ingests regardless of a format. \n-        \n-        if (formatName == null || formatName.equals(\"\")) {\n-            return getTabularIngestSizeLimit(); \n-        }\n-        \n-        String limitEntry = settingsService.get(SettingsServiceBean.Key.TabularIngestSizeLimit.toString() + \":\" + formatName); \n-                \n-        if (limitEntry != null) {\n-            try {\n-                Long sizeOption = new Long(limitEntry);\n-                return sizeOption;\n-            } catch (NumberFormatException nfe) {\n-                logger.warning(\"Invalid value for TabularIngestSizeLimit:\" + formatName + \"? - \" + limitEntry );\n-            }\n-        }\n-        \n-        return getTabularIngestSizeLimit();        \n-    }\n \n-    public boolean isOAIServerEnabled() {\n-        boolean defaultResponse = false;\n-        return settingsService.isTrueForKey(SettingsServiceBean.Key.OAIServerEnabled, defaultResponse);\n-    }\n-    \n-    public void enableOAIServer() {\n-        settingsService.setValueForKey(SettingsServiceBean.Key.OAIServerEnabled, \"true\");\n-    }\n-    \n-    public void disableOAIServer() {\n-        settingsService.deleteValueForKey(SettingsServiceBean.Key.OAIServerEnabled);\n-    }   \n-    \n-    public boolean isTimerServer() {\n-        String optionValue = System.getProperty(JVM_TIMER_SERVER_OPTION);\n-        if (\"true\".equalsIgnoreCase(optionValue)) {\n-            return true;\n-        }\n-        return false;\n-    }\n+    private final String text;\n \n-    public String getFooterCopyrightAndYear() {\n-        return BundleUtil.getStringFromBundle(\"footer.copyright\", Arrays.asList(Year.now().getValue() + \"\"));\n+    private FileUploadMethods(final String text) {\n+      this.text = text;\n     }\n \n-    public DataFile.ChecksumType getFileFixityChecksumAlgorithm() {\n-        DataFile.ChecksumType saneDefault = DataFile.ChecksumType.MD5;\n-        String checksumStringFromDatabase = settingsService.getValueForKey(SettingsServiceBean.Key.FileFixityChecksumAlgorithm, saneDefault.toString());\n-        try {\n-            DataFile.ChecksumType checksumTypeFromDatabase = DataFile.ChecksumType.fromString(checksumStringFromDatabase);\n-            return checksumTypeFromDatabase;\n-        } catch (IllegalArgumentException ex) {\n-            logger.info(\"The setting \" + SettingsServiceBean.Key.FileFixityChecksumAlgorithm + \" is misconfigured. \" + ex.getMessage() + \" Returning sane default: \" + saneDefault + \".\");\n-            return saneDefault;\n+    public static FileUploadMethods fromString(String text) {\n+      if (text != null) {\n+        for (FileUploadMethods fileUploadMethods : FileUploadMethods.values()) {\n+          if (text.equals(fileUploadMethods.text)) {\n+            return fileUploadMethods;\n+          }\n         }\n+      }\n+      throw new IllegalArgumentException(\n+        \"FileUploadMethods must be one of these values: \" + Arrays.asList(FileUploadMethods.values()) + \".\");\n     }\n \n-    public String getDefaultAuthProvider() {\n-        String saneDefault = BuiltinAuthenticationProvider.PROVIDER_ID;\n-        String settingInDatabase = settingsService.getValueForKey(SettingsServiceBean.Key.DefaultAuthProvider, saneDefault);\n-        if (settingInDatabase != null && !settingInDatabase.isEmpty()) {\n-            /**\n-             * @todo Add more sanity checking.\n-             */\n-            return settingInDatabase;\n-        }\n-        return saneDefault;\n+    @Override\n+    public String toString() {\n+      return text;\n     }\n \n-    public String getNameOfInstallation() {\n-        return dataverseService.getRootDataverseName();\n-    }\n \n-    public AbstractOAuth2AuthenticationProvider.DevOAuthAccountType getDevOAuthAccountType() {\n-        AbstractOAuth2AuthenticationProvider.DevOAuthAccountType saneDefault = AbstractOAuth2AuthenticationProvider.DevOAuthAccountType.PRODUCTION;\n-        String settingReturned = settingsService.getValueForKey(SettingsServiceBean.Key.DebugOAuthAccountType);\n-        logger.fine(\"setting returned: \" + settingReturned);\n-        if (settingReturned != null) {\n-            try {\n-                AbstractOAuth2AuthenticationProvider.DevOAuthAccountType parsedValue = AbstractOAuth2AuthenticationProvider.DevOAuthAccountType.valueOf(settingReturned);\n-                return parsedValue;\n-            } catch (IllegalArgumentException ex) {\n-                logger.info(\"Couldn't parse value: \" + ex + \" - returning a sane default: \" + saneDefault);\n-                return saneDefault;\n-            }\n-        } else {\n-            logger.fine(\"OAuth dev mode has not been configured. Returning a sane default: \" + saneDefault);\n-            return saneDefault;\n-        }\n-    }\n-\n-    public String getOAuth2CallbackUrl() {\n-        String saneDefault = getDataverseSiteUrl() + \"/oauth2/callback.xhtml\";\n-        String settingReturned = settingsService.getValueForKey(SettingsServiceBean.Key.OAuth2CallbackUrl);\n-        logger.fine(\"getOAuth2CallbackUrl setting returned: \" + settingReturned);\n-        if (settingReturned != null) {\n-            return settingReturned;\n-        }\n-        return saneDefault;\n-    }\n-    \n-    public boolean isShibPassiveLoginEnabled() {\n-        boolean defaultResponse = false;\n-        return settingsService.isTrueForKey(SettingsServiceBean.Key.ShibPassiveLoginEnabled, defaultResponse);\n-    }\n-    public boolean isShibAttributeCharacterSetConversionEnabled() {\n-        boolean defaultResponse = true;\n-        return settingsService.isTrueForKey(SettingsServiceBean.Key.ShibAttributeCharacterSetConversionEnabled, defaultResponse);\n-    }\n+  }\n \n+  /**\n+   * See FileUploadMethods.\n+   * <p>\n+   * TODO: Consider if dataverse.files.<id>.download-redirect belongs here since\n+   * it's a way to bypass Glassfish when downloading.\n+   */\n+  public enum FileDownloadMethods {\n     /**\n-     * getPVDictionaries\n-     *\n-     * @return A string of one or more pipe (|) separated file paths.\n+     * RSAL stands for Repository Storage Abstraction Layer. Downloads don't\n+     * go through Glassfish.\n      */\n-    public String getPVDictionaries() {\n-        return settingsService.get(SettingsServiceBean.Key.PVDictionaries.toString());\n-    }\n+    RSYNC(\"rsal/rsync\"),\n+    NATIVE(\"native/http\");\n+    private final String text;\n \n-    /**\n-     * getPVGoodStrength\n-     *\n-     * Get the minimum length of a valid password to apply an expiration rule.\n-     * Defaults to 20.\n-     *\n-     * @return The length.\n-     */\n-    public int getPVGoodStrength() {\n-        // FIXME: Change this to 21 to match Harvard's requirements or implement a way to disable the rule (0 or -1) and have the default be disabled.\n-        int goodStrengthLength = 20;\n-        //String _goodStrengthLength = System.getProperty(\"pv.goodstrength\", settingsService.get(SettingsServiceBean.Key.PVGoodStrength.toString()));\n-        String _goodStrengthLength = settingsService.get(SettingsServiceBean.Key.PVGoodStrength.toString());\n-        try {\n-            goodStrengthLength = Integer.parseInt(_goodStrengthLength);\n-        } catch (NumberFormatException nfe) {\n-            logger.fine(\"Invalid value for PVGoodStrength: \" + _goodStrengthLength);\n-        }\n-        return goodStrengthLength;\n+    private FileDownloadMethods(final String text) {\n+      this.text = text;\n     }\n \n-    /**\n-     * getPVMinLength\n-     *\n-     * Get the minimum length of a valid password. Defaults to 6.\n-     *\n-     * @return The length.\n-     */\n-    public int getPVMinLength() {\n-        int passportValidatorMinLength = 6;\n-        String _passportValidatorMinLength = settingsService.get(SettingsServiceBean.Key.PVMinLength.toString());\n-        try {\n-            passportValidatorMinLength = Integer.parseInt(_passportValidatorMinLength);\n-        } catch (NumberFormatException nfe) {\n-            logger.fine(\"Invalid value for PwMinLength: \" + _passportValidatorMinLength);\n+    public static FileUploadMethods fromString(String text) {\n+      if (text != null) {\n+        for (FileUploadMethods fileUploadMethods : FileUploadMethods.values()) {\n+          if (text.equals(fileUploadMethods.text)) {\n+            return fileUploadMethods;\n+          }\n         }\n-        return passportValidatorMinLength;\n+      }\n+      throw new IllegalArgumentException(\n+        \"FileDownloadMethods must be one of these values: \" + Arrays.asList(FileDownloadMethods.values()) + \".\");\n     }\n \n-    /**\n-     * getPVMaxLength\n-     *\n-     * Get the maximum length of a valid password. Defaults to 0 (disabled).\n-     *\n-     * @return The length.\n-     */\n-    public int getPVMaxLength() {\n-        int passportValidatorMaxLength = 0;\n-        String _passportValidatorMaxLength = settingsService.get(SettingsServiceBean.Key.PVMaxLength.toString());\n-        try {\n-            passportValidatorMaxLength = Integer.parseInt(_passportValidatorMaxLength);\n-        } catch (NumberFormatException nfe) {\n-            logger.fine(\"Invalid value for PwMaxLength: \" + _passportValidatorMaxLength);\n-        }\n-        return passportValidatorMaxLength;\n+    @Override\n+    public String toString() {\n+      return text;\n     }\n \n-    /**\n-     * One letter, 2 special characters, etc. Defaults to:\n-     *\n-     * - one uppercase\n-     *\n-     * - one lowercase\n-     *\n-     * - one digit\n-     *\n-     * - one special character\n-     *\n-     * TODO: This is more strict than what Dataverse 4.0 shipped with. Consider\n-     * keeping the default the same.\n-     */\n-    public List<CharacterRule> getPVCharacterRules() {\n-        String characterRulesString = settingsService.get(SettingsServiceBean.Key.PVCharacterRules.toString());\n-        return PasswordValidatorUtil.getCharacterRules(characterRulesString);\n-    }\n+  }\n \n-    /**\n-     * getPVNumberOfCharacteristics\n-     *\n-     * Get the number M characteristics. Defaults to 3.\n-     *\n-     * @return The number.\n-     * \n-     * TODO: Consider changing the out-of-the-box rules to be the same as Dataverse 4.0, which was 2 (one letter, one number).\n-     */\n-    public int getPVNumberOfCharacteristics() {\n-        int numberOfCharacteristics = 2;\n-        String _numberOfCharacteristics = settingsService.get(SettingsServiceBean.Key.PVNumberOfCharacteristics.toString());\n-        try {\n-            numberOfCharacteristics = Integer.parseInt(_numberOfCharacteristics);\n-        } catch (NumberFormatException nfe) {\n-            logger.fine(\"Invalid value for PVNumberOfCharacteristics: \" + _numberOfCharacteristics);\n-        }\n-        return numberOfCharacteristics;\n-    }\n+  public enum DataFilePIDFormat {\n+    DEPENDENT(\"DEPENDENT\"),\n+    INDEPENDENT(\"INDEPENDENT\");\n+    private final String text;\n \n-    /**\n-     * Get the number of consecutive digits allowed. Defaults to highest int\n-     * possible.\n-     */\n-    public int getPVNumberOfConsecutiveDigitsAllowed() {\n-        int numConsecutiveDigitsAllowed = Integer.MAX_VALUE;\n-        String _numberOfConsecutiveDigitsAllowed = settingsService.get(SettingsServiceBean.Key.PVNumberOfConsecutiveDigitsAllowed.toString());\n-        try {\n-            numConsecutiveDigitsAllowed = Integer.parseInt(_numberOfConsecutiveDigitsAllowed);\n-        } catch (NumberFormatException nfe) {\n-            logger.fine(\"Invalid value for \" + SettingsServiceBean.Key.PVNumberOfConsecutiveDigitsAllowed + \": \" + _numberOfConsecutiveDigitsAllowed);\n-        }\n-        return numConsecutiveDigitsAllowed;\n+    public String getText() {\n+      return text;\n     }\n \n-    /**\n-     * Below are three related enums having to do with big data support:\n-     *\n-     * - FileUploadMethods\n-     *\n-     * - FileDownloadMethods\n-     *\n-     * - TransferProtocols\n-     *\n-     * There is a good chance these will be consolidated in the future.\n-     */\n-    public enum FileUploadMethods {\n-\n-        /**\n-         * DCM stands for Data Capture Module. Right now it supports upload over\n-         * rsync+ssh but DCM may support additional methods in the future.\n-         */\n-        RSYNC(\"dcm/rsync+ssh\"),\n-        /**\n-         * Traditional Dataverse file handling, which tends to involve users\n-         * uploading and downloading files using a browser or APIs.\n-         */\n-        NATIVE(\"native/http\");\n-\n-\n-        private final String text;\n-\n-        private FileUploadMethods(final String text) {\n-            this.text = text;\n-        }\n-\n-        public static FileUploadMethods fromString(String text) {\n-            if (text != null) {\n-                for (FileUploadMethods fileUploadMethods : FileUploadMethods.values()) {\n-                    if (text.equals(fileUploadMethods.text)) {\n-                        return fileUploadMethods;\n-                    }\n-                }\n-            }\n-            throw new IllegalArgumentException(\"FileUploadMethods must be one of these values: \" + Arrays.asList(FileUploadMethods.values()) + \".\");\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return text;\n-        }\n-        \n-        \n+    private DataFilePIDFormat(final String text) {\n+      this.text = text;\n     }\n \n-    /**\n-     * See FileUploadMethods.\n-     *\n-     * TODO: Consider if dataverse.files.<id>.download-redirect belongs here since\n-     * it's a way to bypass Glassfish when downloading.\n-     */\n-    public enum FileDownloadMethods {\n-        /**\n-         * RSAL stands for Repository Storage Abstraction Layer. Downloads don't\n-         * go through Glassfish.\n-         */\n-        RSYNC(\"rsal/rsync\"),\n-        NATIVE(\"native/http\");\n-        private final String text;\n-\n-        private FileDownloadMethods(final String text) {\n-            this.text = text;\n-        }\n+    @Override\n+    public String toString() {\n+      return text;\n+    }\n \n-        public static FileUploadMethods fromString(String text) {\n-            if (text != null) {\n-                for (FileUploadMethods fileUploadMethods : FileUploadMethods.values()) {\n-                    if (text.equals(fileUploadMethods.text)) {\n-                        return fileUploadMethods;\n-                    }\n-                }\n-            }\n-            throw new IllegalArgumentException(\"FileDownloadMethods must be one of these values: \" + Arrays.asList(FileDownloadMethods.values()) + \".\");\n-        }\n+  }\n \n-        @Override\n-        public String toString() {\n-            return text;\n-        }\n-        \n-    }\n-    \n-    public enum DataFilePIDFormat {\n-        DEPENDENT(\"DEPENDENT\"),\n-        INDEPENDENT(\"INDEPENDENT\");\n-        private final String text;\n-\n-        public String getText() {\n-            return text;\n-        }\n-        \n-        private DataFilePIDFormat(final String text){\n-            this.text = text;\n-        }\n-        \n-        @Override\n-        public String toString() {\n-            return text;\n-        }\n-        \n-    }\n+  /**\n+   * See FileUploadMethods.\n+   */\n+  public enum TransferProtocols {\n \n+    RSYNC(\"rsync\"),\n     /**\n-     * See FileUploadMethods.\n+     * POSIX includes NFS. This is related to Key.LocalDataAccessPath in\n+     * SettingsServiceBean.\n      */\n-    public enum TransferProtocols {\n-\n-        RSYNC(\"rsync\"),\n-        /**\n-         * POSIX includes NFS. This is related to Key.LocalDataAccessPath in\n-         * SettingsServiceBean.\n-         */\n-        POSIX(\"posix\"),\n-        GLOBUS(\"globus\");\n-\n-        private final String text;\n-\n-        private TransferProtocols(final String text) {\n-            this.text = text;\n-        }\n+    POSIX(\"posix\"),\n+    GLOBUS(\"globus\");\n \n-        public static TransferProtocols fromString(String text) {\n-            if (text != null) {\n-                for (TransferProtocols transferProtocols : TransferProtocols.values()) {\n-                    if (text.equals(transferProtocols.text)) {\n-                        return transferProtocols;\n-                    }\n-                }\n-            }\n-            throw new IllegalArgumentException(\"TransferProtocols must be one of these values: \" + Arrays.asList(TransferProtocols.values()) + \".\");\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return text;\n-        }\n+    private final String text;\n \n+    private TransferProtocols(final String text) {\n+      this.text = text;\n     }\n \n-    public boolean isPublicInstall(){\n-        boolean saneDefault = false;\n-        return settingsService.isTrueForKey(SettingsServiceBean.Key.PublicInstall, saneDefault);\n-    }\n-    \n-    public boolean isRsyncUpload(){\n-        return getUploadMethodAvailable(SystemConfig.FileUploadMethods.RSYNC.toString());\n-    }\n-    \n-    // Controls if HTTP upload is enabled for both GUI and API.\n-    public boolean isHTTPUpload(){       \n-        return getUploadMethodAvailable(SystemConfig.FileUploadMethods.NATIVE.toString());       \n-    }\n-    \n-    public boolean isRsyncOnly(){       \n-        String downloadMethods = settingsService.getValueForKey(SettingsServiceBean.Key.DownloadMethods);\n-        if(downloadMethods == null){\n-            return false;\n-        }\n-        if (!downloadMethods.toLowerCase().equals(SystemConfig.FileDownloadMethods.RSYNC.toString())){\n-            return false;\n-        }\n-        String uploadMethods = settingsService.getValueForKey(SettingsServiceBean.Key.UploadMethods);\n-        if (uploadMethods==null){\n-            return false;\n-        } else {\n-           return  Arrays.asList(uploadMethods.toLowerCase().split(\"\\\\s*,\\\\s*\")).size() == 1 && uploadMethods.toLowerCase().equals(SystemConfig.FileUploadMethods.RSYNC.toString());\n-        }        \n-    }\n-    \n-    public boolean isRsyncDownload() {\n-        String downloadMethods = settingsService.getValueForKey(SettingsServiceBean.Key.DownloadMethods);\n-        return downloadMethods !=null && downloadMethods.toLowerCase().contains(SystemConfig.FileDownloadMethods.RSYNC.toString());\n-    }\n-    \n-    public boolean isHTTPDownload() {\n-        String downloadMethods = settingsService.getValueForKey(SettingsServiceBean.Key.DownloadMethods);\n-        logger.warning(\"Download Methods:\" + downloadMethods);\n-        return downloadMethods !=null && downloadMethods.toLowerCase().contains(SystemConfig.FileDownloadMethods.NATIVE.toString());\n-    }\n-    \n-    private Boolean getUploadMethodAvailable(String method){\n-        String uploadMethods = settingsService.getValueForKey(SettingsServiceBean.Key.UploadMethods); \n-        if (uploadMethods==null){\n-            return false;\n-        } else {\n-           return  Arrays.asList(uploadMethods.toLowerCase().split(\"\\\\s*,\\\\s*\")).contains(method);\n-        }\n-    }\n-    \n-    public Integer getUploadMethodCount(){\n-        String uploadMethods = settingsService.getValueForKey(SettingsServiceBean.Key.UploadMethods); \n-        if (uploadMethods==null){\n-            return 0;\n-        } else {\n-           return  Arrays.asList(uploadMethods.toLowerCase().split(\"\\\\s*,\\\\s*\")).size();\n-        }       \n-    }\n-    public boolean isDataFilePIDSequentialDependent(){\n-        String doiIdentifierType = settingsService.getValueForKey(SettingsServiceBean.Key.IdentifierGenerationStyle, \"randomString\");\n-        String doiDataFileFormat = settingsService.getValueForKey(SettingsServiceBean.Key.DataFilePIDFormat, \"DEPENDENT\");\n-        if (doiIdentifierType.equals(\"sequentialNumber\") && doiDataFileFormat.equals(\"DEPENDENT\")){\n-            return true;\n-        }\n-        return false;\n-    }\n-    \n-    public int getPIDAsynchRegFileCount() {\n-        String fileCount = settingsService.getValueForKey(SettingsServiceBean.Key.PIDAsynchRegFileCount, \"10\");\n-        int retVal = 10;\n-        try {\n-            retVal = Integer.parseInt(fileCount);\n-        } catch (NumberFormatException e) {           \n-            //if no number in the setting we'll return 10\n+    public static TransferProtocols fromString(String text) {\n+      if (text != null) {\n+        for (TransferProtocols transferProtocols : TransferProtocols.values()) {\n+          if (text.equals(transferProtocols.text)) {\n+            return transferProtocols;\n+          }\n         }\n-        return retVal;\n-    }\n-    \n-    public boolean isFilePIDsEnabled() {\n-        boolean safeDefaultIfKeyNotFound = true;\n-        return settingsService.isTrueForKey(SettingsServiceBean.Key.FilePIDsEnabled, safeDefaultIfKeyNotFound);\n-    }\n-    \n-    public boolean isIndependentHandleService() {\n-        boolean safeDefaultIfKeyNotFound = false;\n-        return settingsService.isTrueForKey(SettingsServiceBean.Key.IndependentHandleService, safeDefaultIfKeyNotFound);\n-    \n-    }\n-    \n-    public String getMDCLogPath() {\n-        String mDCLogPath = settingsService.getValueForKey(SettingsServiceBean.Key.MDCLogPath, null);\n-        return mDCLogPath;\n-    }\n-    \n-    public boolean isDatafileValidationOnPublishEnabled() {\n-        boolean safeDefaultIfKeyNotFound = true;\n-        return settingsService.isTrueForKey(SettingsServiceBean.Key.FileValidationOnPublishEnabled, safeDefaultIfKeyNotFound);\n-    }\n-\n-\tpublic boolean directUploadEnabled(DvObjectContainer container) {\n-    \treturn Boolean.getBoolean(\"dataverse.files.\" + container.getEffectiveStorageDriverId() + \".upload-redirect\");\n-\t}\n-\t\n-\tpublic String getDataCiteRestApiUrlString() {\n-\t\t//As of 5.0 the 'doi.dataciterestapiurlstring' is the documented jvm option. Prior versions used 'doi.mdcbaseurlstring' or were hardcoded to api.datacite.org, so the defaults are for backward compatibility.\n-        return System.getProperty(\"doi.dataciterestapiurlstring\", System.getProperty(\"doi.mdcbaseurlstring\", \"https://api.datacite.org\"));\n-\t}\n+      }\n+      throw new IllegalArgumentException(\n+        \"TransferProtocols must be one of these values: \" + Arrays.asList(TransferProtocols.values()) + \".\");\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return text;\n+    }\n+\n+  }\n+\n+  public boolean isPublicInstall() {\n+    boolean saneDefault = false;\n+    return settingsService.isTrueForKey(SettingsServiceBean.Key.PublicInstall, saneDefault);\n+  }\n+\n+  public boolean isRsyncUpload() {\n+    return getUploadMethodAvailable(SystemConfig.FileUploadMethods.RSYNC.toString());\n+  }\n+\n+  // Controls if HTTP upload is enabled for both GUI and API.\n+  public boolean isHTTPUpload() {\n+    return getUploadMethodAvailable(SystemConfig.FileUploadMethods.NATIVE.toString());\n+  }\n+\n+  public boolean isRsyncOnly() {\n+    String downloadMethods = settingsService.getValueForKey(SettingsServiceBean.Key.DownloadMethods);\n+    if (downloadMethods == null) {\n+      return false;\n+    }\n+    if (!downloadMethods.toLowerCase().equals(SystemConfig.FileDownloadMethods.RSYNC.toString())) {\n+      return false;\n+    }\n+    String uploadMethods = settingsService.getValueForKey(SettingsServiceBean.Key.UploadMethods);\n+    if (uploadMethods == null) {\n+      return false;\n+    } else {\n+      return Arrays.asList(uploadMethods.toLowerCase().split(\"\\\\s*,\\\\s*\")).size() == 1 &&\n+        uploadMethods.toLowerCase().equals(SystemConfig.FileUploadMethods.RSYNC.toString());\n+    }\n+  }\n+\n+  public boolean isRsyncDownload() {\n+    String downloadMethods = settingsService.getValueForKey(SettingsServiceBean.Key.DownloadMethods);\n+    return downloadMethods != null &&\n+      downloadMethods.toLowerCase().contains(SystemConfig.FileDownloadMethods.RSYNC.toString());\n+  }\n+\n+  public boolean isHTTPDownload() {\n+    String downloadMethods = settingsService.getValueForKey(SettingsServiceBean.Key.DownloadMethods);\n+    logger.warning(\"Download Methods:\" + downloadMethods);\n+    return downloadMethods != null &&\n+      downloadMethods.toLowerCase().contains(SystemConfig.FileDownloadMethods.NATIVE.toString());\n+  }\n+\n+  private Boolean getUploadMethodAvailable(String method) {\n+    String uploadMethods = settingsService.getValueForKey(SettingsServiceBean.Key.UploadMethods);\n+    if (uploadMethods == null) {\n+      return false;\n+    } else {\n+      return Arrays.asList(uploadMethods.toLowerCase().split(\"\\\\s*,\\\\s*\")).contains(method);\n+    }\n+  }\n+\n+  public Integer getUploadMethodCount() {\n+    String uploadMethods = settingsService.getValueForKey(SettingsServiceBean.Key.UploadMethods);\n+    if (uploadMethods == null) {\n+      return 0;\n+    } else {\n+      return Arrays.asList(uploadMethods.toLowerCase().split(\"\\\\s*,\\\\s*\")).size();\n+    }\n+  }\n+\n+  public boolean isDataFilePIDSequentialDependent() {\n+    String doiIdentifierType =\n+      settingsService.getValueForKey(SettingsServiceBean.Key.IdentifierGenerationStyle, \"randomString\");\n+    String doiDataFileFormat = settingsService.getValueForKey(SettingsServiceBean.Key.DataFilePIDFormat, \"DEPENDENT\");\n+    if (doiIdentifierType.equals(\"sequentialNumber\") && doiDataFileFormat.equals(\"DEPENDENT\")) {\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  public int getPIDAsynchRegFileCount() {\n+    String fileCount = settingsService.getValueForKey(SettingsServiceBean.Key.PIDAsynchRegFileCount, \"10\");\n+    int retVal = 10;\n+    try {\n+      retVal = Integer.parseInt(fileCount);\n+    } catch (NumberFormatException e) {\n+      //if no number in the setting we'll return 10\n+    }\n+    return retVal;\n+  }\n+\n+  public boolean isFilePIDsEnabled() {\n+    boolean safeDefaultIfKeyNotFound = true;\n+    return settingsService.isTrueForKey(SettingsServiceBean.Key.FilePIDsEnabled, safeDefaultIfKeyNotFound);\n+  }\n+\n+  public boolean isIndependentHandleService() {\n+    boolean safeDefaultIfKeyNotFound = false;\n+    return settingsService.isTrueForKey(SettingsServiceBean.Key.IndependentHandleService, safeDefaultIfKeyNotFound);\n+\n+  }\n+\n+  public String getMDCLogPath() {\n+    String mDCLogPath = settingsService.getValueForKey(SettingsServiceBean.Key.MDCLogPath, null);\n+    return mDCLogPath;\n+  }\n+\n+  public boolean isDatafileValidationOnPublishEnabled() {\n+    boolean safeDefaultIfKeyNotFound = true;\n+    return settingsService\n+      .isTrueForKey(SettingsServiceBean.Key.FileValidationOnPublishEnabled, safeDefaultIfKeyNotFound);\n+  }\n+\n+  public boolean directUploadEnabled(DvObjectContainer container) {\n+    return Boolean.getBoolean(\"dataverse.files.\" + container.getEffectiveStorageDriverId() + \".upload-redirect\");\n+  }\n+\n+  public String getDataCiteRestApiUrlString() {\n+    //As of 5.0 the 'doi.dataciterestapiurlstring' is the documented jvm option. Prior versions used 'doi.mdcbaseurlstring' or were hardcoded to api.datacite.org, so the defaults are for backward compatibility.\n+    return System.getProperty(\"doi.dataciterestapiurlstring\",\n+      System.getProperty(\"doi.mdcbaseurlstring\", \"https://api.datacite.org\"));\n+  }\n \n }\n",
            "diff_size": 1837
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "1058",
                    "column": "1",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/121/SystemConfig.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_random/121/SystemConfig.java\nindex 71accdaa8c8..d6447515b34 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/121/SystemConfig.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_random/121/SystemConfig.java\n@@ -512,7 +512,7 @@ public class SystemConfig {\n         String appTermsOfUse = settingsService.getValueForKey(SettingsServiceBean.Key.ApplicationTermsOfUse, saneDefaultForAppTermsOfUse);\n         //Now get the language-specific value if it exists\n         if (!language.equalsIgnoreCase(BundleUtil.getDefaultLocale().getLanguage())) {\n-            appTermsOfUse = settingsService.getValueForKey(SettingsServiceBean.Key.ApplicationTermsOfUse, language,\tappTermsOfUse);\n+            appTermsOfUse = settingsService.getValueForKey(SettingsServiceBean.Key.ApplicationTermsOfUse, language,appTermsOfUse);\n         }\n         return appTermsOfUse;\n     }\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "1058",
                    "column": "1",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/121/SystemConfig.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_three_grams/121/SystemConfig.java\nindex 71accdaa8c8..286decd6246 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/121/SystemConfig.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_three_grams/121/SystemConfig.java\n@@ -512,7 +512,7 @@ public class SystemConfig {\n         String appTermsOfUse = settingsService.getValueForKey(SettingsServiceBean.Key.ApplicationTermsOfUse, saneDefaultForAppTermsOfUse);\n         //Now get the language-specific value if it exists\n         if (!language.equalsIgnoreCase(BundleUtil.getDefaultLocale().getLanguage())) {\n-            appTermsOfUse = settingsService.getValueForKey(SettingsServiceBean.Key.ApplicationTermsOfUse, language,\tappTermsOfUse);\n+            appTermsOfUse = settingsService.getValueForKey(SettingsServiceBean.Key.ApplicationTermsOfUse, language, appTermsOfUse);\n         }\n         return appTermsOfUse;\n     }\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "intellij"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}