{
    "project_name": "findbugsproject-findbugs",
    "error_id": "10",
    "information": {
        "errors": [
            {
                "line": "1344",
                "column": "21",
                "severity": "error",
                "message": "File contains tab characters (this is the first instance).",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
            }
        ]
    },
    "source_code": "                        break;\n                    case IF_ICMPGE:\n                    \t takeJump = lC >= rC;\n                         handled = true;\n                         break;\n                    case IF_ICMPGT:",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/errored/1/10/OpcodeStack.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/styler/10/OpcodeStack.java\nindex 6c3e1fc04c5..0ce65f7fa89 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/errored/1/10/OpcodeStack.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/styler/10/OpcodeStack.java\n@@ -1341,7 +1341,7 @@ public class OpcodeStack implements Constants2 {\n                         handled = true;\n                         break;\n                     case IF_ICMPGE:\n-                    \t takeJump = lC >= rC;\n+                            takeJump = lC >= rC;\n                          handled = true;\n                          break;\n                     case IF_ICMPGT:\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/errored/1/10/OpcodeStack.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/intellij/10/OpcodeStack.java\nindex 6c3e1fc04c5..2f688722a0f 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/errored/1/10/OpcodeStack.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/intellij/10/OpcodeStack.java\n@@ -125,7 +125,7 @@ public class OpcodeStack implements Constants2 {\n     private boolean seenTransferOfControl = false;\n \n     private final boolean useIterativeAnalysis = AnalysisContext.currentAnalysisContext().getBoolProperty(\n-            AnalysisFeatures.INTERATIVE_OPCODE_STACK_ANALYSIS);\n+        AnalysisFeatures.INTERATIVE_OPCODE_STACK_ANALYSIS);\n \n     public static class Item {\n \n@@ -254,8 +254,9 @@ public class OpcodeStack implements Constants2 {\n         }\n \n         public int getSize() {\n-            if (signature.equals(\"J\") || signature.equals(\"D\"))\n+            if (signature.equals(\"J\") || signature.equals(\"D\")) {\n                 return 2;\n+            }\n             return 1;\n         }\n \n@@ -274,14 +275,17 @@ public class OpcodeStack implements Constants2 {\n         @Override\n         public int hashCode() {\n             int r = 42 + specialKind;\n-            if (signature != null)\n+            if (signature != null) {\n                 r += signature.hashCode();\n+            }\n             r *= 31;\n-            if (constValue != null)\n+            if (constValue != null) {\n                 r += constValue.hashCode();\n+            }\n             r *= 31;\n-            if (source != null)\n+            if (source != null) {\n                 r += source.hashCode();\n+            }\n             r *= 31;\n             r += flags;\n             r *= 31;\n@@ -292,15 +296,16 @@ public class OpcodeStack implements Constants2 {\n \n         @Override\n         public boolean equals(Object o) {\n-            if (!(o instanceof Item))\n+            if (!(o instanceof Item)) {\n                 return false;\n+            }\n             Item that = (Item) o;\n \n             return Util.nullSafeEquals(this.signature, that.signature) && Util.nullSafeEquals(this.constValue, that.constValue)\n-                    && Util.nullSafeEquals(this.source, that.source) && Util.nullSafeEquals(this.userValue, that.userValue)\n-                    && Util.nullSafeEquals(this.injection, that.injection) && this.specialKind == that.specialKind\n-                    && this.registerNumber == that.registerNumber && this.flags == that.flags\n-                    && this.fieldLoadedFromRegister == that.fieldLoadedFromRegister;\n+                && Util.nullSafeEquals(this.source, that.source) && Util.nullSafeEquals(this.userValue, that.userValue)\n+                && Util.nullSafeEquals(this.injection, that.injection) && this.specialKind == that.specialKind\n+                && this.registerNumber == that.registerNumber && this.flags == that.flags\n+                && this.fieldLoadedFromRegister == that.fieldLoadedFromRegister;\n \n         }\n \n@@ -309,76 +314,76 @@ public class OpcodeStack implements Constants2 {\n             StringBuilder buf = new StringBuilder(\"< \");\n             buf.append(signature);\n             switch (specialKind) {\n-            case SIGNED_BYTE:\n-                buf.append(\", signed_byte\");\n-                break;\n-            case RANDOM_INT:\n-                buf.append(\", random_int\");\n-                break;\n-            case LOW_8_BITS_CLEAR:\n-                buf.append(\", low8clear\");\n-                break;\n-            case HASHCODE_INT:\n-                buf.append(\", hashcode_int\");\n-                break;\n-            case INTEGER_SUM:\n-                buf.append(\", int_sum\");\n-                break;\n-            case AVERAGE_COMPUTED_USING_DIVISION:\n-                buf.append(\", averageComputingUsingDivision\");\n-                break;\n-            case FLOAT_MATH:\n-                buf.append(\", floatMath\");\n-                break;\n-            case NASTY_FLOAT_MATH:\n-                buf.append(\", nastyFloatMath\");\n-                break;\n-            case HASHCODE_INT_REMAINDER:\n-                buf.append(\", hashcode_int_rem\");\n-                break;\n-            case RANDOM_INT_REMAINDER:\n-                buf.append(\", random_int_rem\");\n-                break;\n-            case MATH_ABS_OF_RANDOM:\n-                buf.append(\", abs_of_random\");\n-                break;\n-            case MATH_ABS_OF_HASHCODE:\n-                buf.append(\", abs_of_hashcode\");\n-                break;\n-            case FILE_SEPARATOR_STRING:\n-                buf.append(\", file_separator_string\");\n-                break;\n-            case MATH_ABS:\n-                buf.append(\", Math.abs\");\n-                break;\n-            case NON_NEGATIVE:\n-                buf.append(\", non_negative\");\n-                break;\n-            case FILE_OPENED_IN_APPEND_MODE:\n-                buf.append(\", file opened in append mode\");\n-                break;\n-            case SERVLET_REQUEST_TAINTED:\n-                buf.append(\", servlet request tainted\");\n-                break;\n-            case NEWLY_ALLOCATED:\n-                buf.append(\", new\");\n-                break;\n-            case ZERO_MEANS_NULL:\n-                buf.append(\", zero means null\");\n-                break;\n-            case NONZERO_MEANS_NULL:\n-                buf.append(\", nonzero means null\");\n-                break;\n-            case SERVLET_OUTPUT:\n-                buf.append(\", servlet_output\");\n-                break;\n+                case SIGNED_BYTE:\n+                    buf.append(\", signed_byte\");\n+                    break;\n+                case RANDOM_INT:\n+                    buf.append(\", random_int\");\n+                    break;\n+                case LOW_8_BITS_CLEAR:\n+                    buf.append(\", low8clear\");\n+                    break;\n+                case HASHCODE_INT:\n+                    buf.append(\", hashcode_int\");\n+                    break;\n+                case INTEGER_SUM:\n+                    buf.append(\", int_sum\");\n+                    break;\n+                case AVERAGE_COMPUTED_USING_DIVISION:\n+                    buf.append(\", averageComputingUsingDivision\");\n+                    break;\n+                case FLOAT_MATH:\n+                    buf.append(\", floatMath\");\n+                    break;\n+                case NASTY_FLOAT_MATH:\n+                    buf.append(\", nastyFloatMath\");\n+                    break;\n+                case HASHCODE_INT_REMAINDER:\n+                    buf.append(\", hashcode_int_rem\");\n+                    break;\n+                case RANDOM_INT_REMAINDER:\n+                    buf.append(\", random_int_rem\");\n+                    break;\n+                case MATH_ABS_OF_RANDOM:\n+                    buf.append(\", abs_of_random\");\n+                    break;\n+                case MATH_ABS_OF_HASHCODE:\n+                    buf.append(\", abs_of_hashcode\");\n+                    break;\n+                case FILE_SEPARATOR_STRING:\n+                    buf.append(\", file_separator_string\");\n+                    break;\n+                case MATH_ABS:\n+                    buf.append(\", Math.abs\");\n+                    break;\n+                case NON_NEGATIVE:\n+                    buf.append(\", non_negative\");\n+                    break;\n+                case FILE_OPENED_IN_APPEND_MODE:\n+                    buf.append(\", file opened in append mode\");\n+                    break;\n+                case SERVLET_REQUEST_TAINTED:\n+                    buf.append(\", servlet request tainted\");\n+                    break;\n+                case NEWLY_ALLOCATED:\n+                    buf.append(\", new\");\n+                    break;\n+                case ZERO_MEANS_NULL:\n+                    buf.append(\", zero means null\");\n+                    break;\n+                case NONZERO_MEANS_NULL:\n+                    buf.append(\", nonzero means null\");\n+                    break;\n+                case SERVLET_OUTPUT:\n+                    buf.append(\", servlet_output\");\n+                    break;\n \n-            case NOT_SPECIAL:\n-                break;\n-            default:\n-                buf.append(\", #\" + specialKind);\n-                buf.append(\"(\" + specialKindNames.get(specialKind) + \")\");\n-                break;\n+                case NOT_SPECIAL:\n+                    break;\n+                default:\n+                    buf.append(\", #\" + specialKind);\n+                    buf.append(\"(\" + specialKindNames.get(specialKind) + \")\");\n+                    break;\n \n             }\n             if (constValue != UNKNOWN) {\n@@ -393,8 +398,9 @@ public class OpcodeStack implements Constants2 {\n             }\n             if (source instanceof XField) {\n                 buf.append(\", \");\n-                if (fieldLoadedFromRegister != -1 && fieldLoadedFromRegister != Integer.MAX_VALUE)\n+                if (fieldLoadedFromRegister != -1 && fieldLoadedFromRegister != Integer.MAX_VALUE) {\n                     buf.append(fieldLoadedFromRegister).append(':');\n+                }\n                 buf.append(source);\n             }\n             if (source instanceof XMethod) {\n@@ -412,51 +418,62 @@ public class OpcodeStack implements Constants2 {\n                 buf.append(\", r\");\n                 buf.append(registerNumber);\n             }\n-            if (isCouldBeZero())\n+            if (isCouldBeZero()) {\n                 buf.append(\", cbz\");\n+            }\n             if (userValue != null) {\n                 buf.append(\", uv: \");\n                 buf.append(userValue.toString());\n             }\n-            \n+\n             buf.append(\" >\");\n             return buf.toString();\n         }\n \n         public static Item merge(Item i1, Item i2) {\n-            if (i1 == null)\n+            if (i1 == null) {\n                 return i2;\n-            if (i2 == null)\n+            }\n+            if (i2 == null) {\n                 return i1;\n-            if (i1.equals(i2))\n+            }\n+            if (i1.equals(i2)) {\n                 return i1;\n+            }\n             Item m = new Item();\n             m.flags = i1.flags & i2.flags;\n             m.setCouldBeZero(i1.isCouldBeZero() || i2.isCouldBeZero());\n-            if (i1.pc == i2.pc)\n+            if (i1.pc == i2.pc) {\n                 m.pc = i1.pc;\n-            if (Util.nullSafeEquals(i1.signature, i2.signature))\n+            }\n+            if (Util.nullSafeEquals(i1.signature, i2.signature)) {\n                 m.signature = i1.signature;\n-            else if (i1.isNull())\n+            } else if (i1.isNull()) {\n                 m.signature = i2.signature;\n-            else if (i2.isNull())\n+            } else if (i2.isNull()) {\n                 m.signature = i1.signature;\n-            if (Util.nullSafeEquals(i1.constValue, i2.constValue))\n+            }\n+            if (Util.nullSafeEquals(i1.constValue, i2.constValue)) {\n                 m.constValue = i1.constValue;\n+            }\n             if (Util.nullSafeEquals(i1.source, i2.source)) {\n                 m.source = i1.source;\n-            } else if (\"\".equals(i1.constValue))\n+            } else if (\"\".equals(i1.constValue)) {\n                 m.source = i2.source;\n-            else if (\"\".equals(i2.constValue))\n+            } else if (\"\".equals(i2.constValue)) {\n                 m.source = i1.source;\n+            }\n \n-            if (Util.nullSafeEquals(i1.userValue, i2.userValue))\n+            if (Util.nullSafeEquals(i1.userValue, i2.userValue)) {\n                 m.userValue = i1.userValue;\n+            }\n \n-            if (i1.registerNumber == i2.registerNumber)\n+            if (i1.registerNumber == i2.registerNumber) {\n                 m.registerNumber = i1.registerNumber;\n-            if (i1.fieldLoadedFromRegister == i2.fieldLoadedFromRegister)\n+            }\n+            if (i1.fieldLoadedFromRegister == i2.fieldLoadedFromRegister) {\n                 m.fieldLoadedFromRegister = i1.fieldLoadedFromRegister;\n+            }\n \n             if (i1.specialKind == SERVLET_REQUEST_TAINTED) {\n                 m.specialKind = SERVLET_REQUEST_TAINTED;\n@@ -464,14 +481,16 @@ public class OpcodeStack implements Constants2 {\n             } else if (i2.specialKind == SERVLET_REQUEST_TAINTED) {\n                 m.specialKind = SERVLET_REQUEST_TAINTED;\n                 m.injection = i2.injection;\n-            } else if (i1.specialKind == i2.specialKind)\n+            } else if (i1.specialKind == i2.specialKind) {\n                 m.specialKind = i1.specialKind;\n-            else if (i1.specialKind == NASTY_FLOAT_MATH || i2.specialKind == NASTY_FLOAT_MATH)\n+            } else if (i1.specialKind == NASTY_FLOAT_MATH || i2.specialKind == NASTY_FLOAT_MATH) {\n                 m.specialKind = NASTY_FLOAT_MATH;\n-            else if (i1.specialKind == FLOAT_MATH || i2.specialKind == FLOAT_MATH)\n+            } else if (i1.specialKind == FLOAT_MATH || i2.specialKind == FLOAT_MATH) {\n                 m.specialKind = FLOAT_MATH;\n-            if (DEBUG)\n+            }\n+            if (DEBUG) {\n                 System.out.println(\"Merge \" + i1 + \" and \" + i2 + \" gives \" + m);\n+            }\n             return m;\n         }\n \n@@ -500,14 +519,15 @@ public class OpcodeStack implements Constants2 {\n             this.signature = DescriptorFactory.canonicalizeString(signature);\n             if (constValue instanceof Number) {\n                 Number constantNumericValue = (Number) constValue;\n-                if (signature.equals(\"B\"))\n+                if (signature.equals(\"B\")) {\n                     this.constValue = constantNumericValue.byteValue();\n-                else if (signature.equals(\"S\"))\n+                } else if (signature.equals(\"S\")) {\n                     this.constValue = constantNumericValue.shortValue();\n-                else if (signature.equals(\"C\"))\n+                } else if (signature.equals(\"C\")) {\n                     this.constValue = (char) constantNumericValue.intValue();\n-                else if (signature.equals(\"I\"))\n+                } else if (signature.equals(\"I\")) {\n                     this.constValue = constantNumericValue.intValue();\n+                }\n \n             }\n             setSpecialKindFromSignature();\n@@ -521,15 +541,17 @@ public class OpcodeStack implements Constants2 {\n         public Item(String signature, FieldAnnotation f) {\n             this.signature = DescriptorFactory.canonicalizeString(signature);\n             setSpecialKindFromSignature();\n-            if (f != null)\n+            if (f != null) {\n                 source = XFactory.createXField(f);\n+            }\n             fieldLoadedFromRegister = -1;\n         }\n \n         public Item(String signature, FieldAnnotation f, int fieldLoadedFromRegister) {\n             this.signature = DescriptorFactory.canonicalizeString(signature);\n-            if (f != null)\n+            if (f != null) {\n                 source = XFactory.createXField(f);\n+            }\n             this.fieldLoadedFromRegister = fieldLoadedFromRegister;\n         }\n \n@@ -539,8 +561,8 @@ public class OpcodeStack implements Constants2 {\n          * If Integer.MAX value, the value was loaded from a static field\n          * If -1, we don't know or don't have the register containing the object that\n          * the field was loaded from.\n-         * @return\n          *\n+         * @return\n          */\n         public int getFieldLoadedFromRegister() {\n             return fieldLoadedFromRegister;\n@@ -554,18 +576,22 @@ public class OpcodeStack implements Constants2 {\n \n         public @CheckForNull\n         String getHttpParameterName() {\n-            if (!isServletParameterTainted())\n+            if (!isServletParameterTainted()) {\n                 throw new IllegalStateException();\n-            if (injection == null)\n+            }\n+            if (injection == null) {\n                 return null;\n+            }\n             return injection.parameterName;\n         }\n \n         public int getInjectionPC() {\n-            if (!isServletParameterTainted())\n+            if (!isServletParameterTainted()) {\n                 throw new IllegalStateException();\n-            if (injection == null)\n+            }\n+            if (injection == null) {\n                 return -1;\n+            }\n             return injection.pc;\n         }\n \n@@ -575,28 +601,34 @@ public class OpcodeStack implements Constants2 {\n             constValue = constantValue;\n             if (constantValue instanceof Integer) {\n                 int value = ((Integer) constantValue).intValue();\n-                if (value != 0 && (value & 0xff) == 0)\n+                if (value != 0 && (value & 0xff) == 0) {\n                     specialKind = LOW_8_BITS_CLEAR;\n-                if (value == 0)\n+                }\n+                if (value == 0) {\n                     setCouldBeZero(true);\n+                }\n \n             } else if (constantValue instanceof Long) {\n                 long value = ((Long) constantValue).longValue();\n-                if (value != 0 && (value & 0xff) == 0)\n+                if (value != 0 && (value & 0xff) == 0) {\n                     specialKind = LOW_8_BITS_CLEAR;\n-                if (value == 0)\n+                }\n+                if (value == 0) {\n                     setCouldBeZero(true);\n+                }\n             }\n \n         }\n \n         private void setSpecialKindFromSignature() {\n-            if (false && specialKind != NOT_SPECIAL)\n+            if (false && specialKind != NOT_SPECIAL) {\n                 return;\n-            if (signature.equals(\"B\"))\n+            }\n+            if (signature.equals(\"B\")) {\n                 specialKind = SIGNED_BYTE;\n-            else if (signature.equals(\"C\"))\n+            } else if (signature.equals(\"C\")) {\n                 specialKind = NON_NEGATIVE;\n+            }\n         }\n \n         public Item() {\n@@ -612,18 +644,22 @@ public class OpcodeStack implements Constants2 {\n             return item;\n         }\n \n-        /** Returns null for primitive and arrays */\n+        /**\n+         * Returns null for primitive and arrays\n+         */\n         public @CheckForNull\n         JavaClass getJavaClass() throws ClassNotFoundException {\n             String baseSig;\n \n-            if (isPrimitive() || isArray())\n+            if (isPrimitive() || isArray()) {\n                 return null;\n+            }\n \n             baseSig = signature;\n \n-            if (baseSig.length() == 0)\n+            if (baseSig.length() == 0) {\n                 return null;\n+            }\n             baseSig = baseSig.substring(1, baseSig.length() - 1);\n             baseSig = baseSig.replace('/', '.');\n             return Repository.lookupClass(baseSig);\n@@ -635,14 +671,15 @@ public class OpcodeStack implements Constants2 {\n \n         @Deprecated\n         public String getElementSignature() {\n-            if (!isArray())\n+            if (!isArray()) {\n                 return signature;\n-            else {\n+            } else {\n                 int pos = 0;\n                 int len = signature.length();\n                 while (pos < len) {\n-                    if (signature.charAt(pos) != '[')\n+                    if (signature.charAt(pos) != '[') {\n                         break;\n+                    }\n                     pos++;\n                 }\n                 return signature.substring(pos);\n@@ -650,8 +687,9 @@ public class OpcodeStack implements Constants2 {\n         }\n \n         public boolean isNonNegative() {\n-            if (specialKind == NON_NEGATIVE)\n+            if (specialKind == NON_NEGATIVE) {\n                 return true;\n+            }\n             if (constValue instanceof Number) {\n                 double value = ((Number) constValue).doubleValue();\n                 return value >= 0;\n@@ -680,21 +718,23 @@ public class OpcodeStack implements Constants2 {\n             return constValue;\n         }\n \n-        /** Use getXField instead */\n+        /**\n+         * Use getXField instead\n+         */\n         @Deprecated\n         public FieldAnnotation getFieldAnnotation() {\n             return FieldAnnotation.fromXField(getXField());\n         }\n \n         public XField getXField() {\n-            if (source instanceof XField)\n+            if (source instanceof XField) {\n                 return (XField) source;\n+            }\n             return null;\n         }\n \n         /**\n-         * @param specialKind\n-         *            The specialKind to set.\n+         * @param specialKind The specialKind to set.\n          */\n         public void setSpecialKind(@SpecialKind int specialKind) {\n             this.specialKind = specialKind;\n@@ -724,22 +764,21 @@ public class OpcodeStack implements Constants2 {\n         /**\n          * attaches a detector specified value to this item\n          *\n-         * @param value\n-         *            the custom value to set\n+         * @param value the custom value to set\n          */\n         public void setUserValue(Object value) {\n             userValue = value;\n         }\n \n         /**\n-         *\n          * @return if this value is the return value of a method, give the\n-         *         method invoked\n+         * method invoked\n          */\n         public @CheckForNull\n         XMethod getReturnValueOf() {\n-            if (source instanceof XMethod)\n+            if (source instanceof XMethod) {\n                 return (XMethod) source;\n+            }\n             return null;\n         }\n \n@@ -768,67 +807,75 @@ public class OpcodeStack implements Constants2 {\n         public void setServletParameterTainted() {\n             setSpecialKind(Item.SERVLET_REQUEST_TAINTED);\n         }\n+\n         public void setIsServletWriter() {\n             setSpecialKind(Item.SERVLET_OUTPUT);\n         }\n \n \n-        public  boolean isServletWriter() {\n-            if (getSpecialKind() == Item.SERVLET_OUTPUT)\n+        public boolean isServletWriter() {\n+            if (getSpecialKind() == Item.SERVLET_OUTPUT) {\n                 return true;\n-            if (getSignature().equals(\"Ljavax/servlet/ServletOutputStream;\"))\n+            }\n+            if (getSignature().equals(\"Ljavax/servlet/ServletOutputStream;\")) {\n                 return true;\n+            }\n             XMethod writingToSource = getReturnValueOf();\n \n \n             return writingToSource != null && writingToSource.getClassName().equals(\"javax.servlet.http.HttpServletResponse\")\n-                    && (writingToSource.getName().equals(\"getWriter\") || writingToSource.getName().equals(\"getOutputStream\"));\n+                && (writingToSource.getName().equals(\"getWriter\") || writingToSource.getName().equals(\"getOutputStream\"));\n         }\n \n         public boolean valueCouldBeNegative() {\n             return !isNonNegative()\n-                    && (getSpecialKind() == Item.RANDOM_INT || getSpecialKind() == Item.SIGNED_BYTE\n-                            || getSpecialKind() == Item.HASHCODE_INT || getSpecialKind() == Item.RANDOM_INT_REMAINDER\n-                            || getSpecialKind() == Item.HASHCODE_INT_REMAINDER || getSpecialKind() == Item.MATH_ABS_OF_RANDOM || getSpecialKind() == Item.MATH_ABS_OF_HASHCODE);\n+                && (getSpecialKind() == Item.RANDOM_INT || getSpecialKind() == Item.SIGNED_BYTE\n+                || getSpecialKind() == Item.HASHCODE_INT || getSpecialKind() == Item.RANDOM_INT_REMAINDER\n+                || getSpecialKind() == Item.HASHCODE_INT_REMAINDER || getSpecialKind() == Item.MATH_ABS_OF_RANDOM || getSpecialKind() == Item.MATH_ABS_OF_HASHCODE);\n \n         }\n \n-        public @SpecialKind int getSpecialKindForAbs() {\n+        public @SpecialKind\n+        int getSpecialKindForAbs() {\n             switch (getSpecialKind()) {\n-            case Item.HASHCODE_INT:\n-                return Item.MATH_ABS_OF_HASHCODE;\n-            case Item.RANDOM_INT:\n-                return Item.MATH_ABS_OF_RANDOM;\n-            default:\n-                return Item.MATH_ABS;\n+                case Item.HASHCODE_INT:\n+                    return Item.MATH_ABS_OF_HASHCODE;\n+                case Item.RANDOM_INT:\n+                    return Item.MATH_ABS_OF_RANDOM;\n+                default:\n+                    return Item.MATH_ABS;\n             }\n         }\n \n-        public @SpecialKind int getSpecialKindForRemainder() {\n+        public @SpecialKind\n+        int getSpecialKindForRemainder() {\n             switch (getSpecialKind()) {\n-            case Item.HASHCODE_INT:\n-                return Item.HASHCODE_INT_REMAINDER;\n-            case Item.RANDOM_INT:\n-                return Item.RANDOM_INT_REMAINDER;\n-            default:\n-                return Item.NOT_SPECIAL;\n+                case Item.HASHCODE_INT:\n+                    return Item.HASHCODE_INT_REMAINDER;\n+                case Item.RANDOM_INT:\n+                    return Item.RANDOM_INT_REMAINDER;\n+                default:\n+                    return Item.NOT_SPECIAL;\n             }\n         }\n \n-        /** Value could be Integer.MIN_VALUE */\n+        /**\n+         * Value could be Integer.MIN_VALUE\n+         */\n         public boolean checkForIntegerMinValue() {\n             return !isNonNegative() && (getSpecialKind() == Item.RANDOM_INT || getSpecialKind() == Item.HASHCODE_INT);\n         }\n \n-        /** The result of applying Math.abs to a checkForIntegerMinValue() value */\n+        /**\n+         * The result of applying Math.abs to a checkForIntegerMinValue() value\n+         */\n         public boolean mightRarelyBeNegative() {\n             return !isNonNegative()\n-                    && (getSpecialKind() == Item.MATH_ABS_OF_RANDOM || getSpecialKind() == Item.MATH_ABS_OF_HASHCODE);\n+                && (getSpecialKind() == Item.MATH_ABS_OF_RANDOM || getSpecialKind() == Item.MATH_ABS_OF_HASHCODE);\n         }\n \n         /**\n-         * @param isInitialParameter\n-         *            The isInitialParameter to set.\n+         * @param isInitialParameter The isInitialParameter to set.\n          */\n         private void setInitialParameter(boolean isInitialParameter) {\n             setFlag(isInitialParameter, IS_INITIAL_PARAMETER_FLAG);\n@@ -842,8 +889,7 @@ public class OpcodeStack implements Constants2 {\n         }\n \n         /**\n-         * @param couldBeZero\n-         *            The couldBeZero to set.\n+         * @param couldBeZero The couldBeZero to set.\n          */\n         private void setCouldBeZero(boolean couldBeZero) {\n             setFlag(couldBeZero, COULD_BE_ZERO_FLAG);\n@@ -857,18 +903,18 @@ public class OpcodeStack implements Constants2 {\n         }\n \n         /**\n-         * @param isNull\n-         *            The isNull to set.\n+         * @param isNull The isNull to set.\n          */\n         private void setNull(boolean isNull) {\n             setFlag(isNull, IS_NULL_FLAG);\n         }\n \n         private void setFlag(boolean value, int flagBit) {\n-            if (value)\n+            if (value) {\n                 flags |= flagBit;\n-            else\n+            } else {\n                 flags &= ~flagBit;\n+            }\n         }\n \n         /**\n@@ -883,8 +929,9 @@ public class OpcodeStack implements Constants2 {\n          */\n         public void clearNewlyAllocated() {\n             if (specialKind == NEWLY_ALLOCATED) {\n-                if (signature.startsWith(\"Ljava/lang/StringB\"))\n+                if (signature.startsWith(\"Ljava/lang/StringB\")) {\n                     constValue = null;\n+                }\n                 specialKind = NOT_SPECIAL;\n             }\n         }\n@@ -898,22 +945,25 @@ public class OpcodeStack implements Constants2 {\n          * @return\n          */\n         public boolean hasConstantValue(int value) {\n-            if (constValue instanceof Number)\n+            if (constValue instanceof Number) {\n                 return ((Number) constValue).intValue() == value;\n+            }\n             return false;\n         }\n \n         public boolean hasConstantValue(long value) {\n-            if (constValue instanceof Number)\n+            if (constValue instanceof Number) {\n                 return ((Number) constValue).longValue() == value;\n+            }\n             return false;\n         }\n     }\n \n     @Override\n     public String toString() {\n-        if (isTop())\n+        if (isTop()) {\n             return \"TOP\";\n+        }\n         return stack.toString() + \"::\" + lvValues.toString();\n     }\n \n@@ -933,34 +983,39 @@ public class OpcodeStack implements Constants2 {\n     private boolean reachOnlyByBranch = false;\n \n     public static String getExceptionSig(DismantleBytecode dbc, CodeException e) {\n-        if (e.getCatchType() == 0)\n+        if (e.getCatchType() == 0) {\n             return \"Ljava/lang/Throwable;\";\n+        }\n         Constant c = dbc.getConstantPool().getConstant(e.getCatchType());\n-        if (c instanceof ConstantClass)\n+        if (c instanceof ConstantClass) {\n             return \"L\" + ((ConstantClass) c).getBytes(dbc.getConstantPool()) + \";\";\n+        }\n         return \"Ljava/lang/Throwable;\";\n     }\n \n     public void mergeJumps(DismantleBytecode dbc) {\n-        if (!needToMerge)\n+        if (!needToMerge) {\n             return;\n+        }\n         needToMerge = false;\n         if (dbc.getPC() == zeroOneComing) {\n             pop();\n             top = false;\n             OpcodeStack.Item item = new Item(\"I\");\n-            if (oneMeansNull)\n+            if (oneMeansNull) {\n                 item.setSpecialKind(Item.NONZERO_MEANS_NULL);\n-            else\n+            } else {\n                 item.setSpecialKind(Item.ZERO_MEANS_NULL);\n+            }\n             item.setPC(dbc.getPC() - 8);\n             item.setCouldBeZero(true);\n \n             push(item);\n \n             zeroOneComing = -1;\n-            if (DEBUG)\n+            if (DEBUG) {\n                 System.out.println(\"Updated to \" + this);\n+            }\n             return;\n         }\n \n@@ -975,12 +1030,13 @@ public class OpcodeStack implements Constants2 {\n         }\n \n         List<Item> jumpEntry = null;\n-        if (jumpEntryLocations.get(dbc.getPC()))\n+        if (jumpEntryLocations.get(dbc.getPC())) {\n             jumpEntry = jumpEntries.get(Integer.valueOf(dbc.getPC()));\n+        }\n         if (jumpEntry != null) {\n             setReachOnlyByBranch(false);\n             List<Item> jumpStackEntry = jumpStackEntries.get(Integer.valueOf(dbc.getPC()));\n-            \n+\n             if (DEBUG2) {\n                 System.out.println(\"XXXXXXX \" + isReachOnlyByBranch());\n                 System.out.println(\"merging lvValues at jump target \" + dbc.getPC() + \" -> \" + jumpEntry);\n@@ -991,10 +1047,11 @@ public class OpcodeStack implements Constants2 {\n             }\n             if (isTop()) {\n                 lvValues = new ArrayList<Item>(jumpEntry);\n-                if (jumpStackEntry != null)\n+                if (jumpStackEntry != null) {\n                     stack = new ArrayList<Item>(jumpStackEntry);\n-                else\n+                } else {\n                     stack.clear();\n+                }\n                 setTop(false);\n                 return;\n             }\n@@ -1002,20 +1059,23 @@ public class OpcodeStack implements Constants2 {\n                 setTop(false);\n                 lvValues = new ArrayList<Item>(jumpEntry);\n                 if (!stackUpdated) {\n-                    if (jumpStackEntry != null)\n+                    if (jumpStackEntry != null) {\n                         stack = new ArrayList<Item>(jumpStackEntry);\n-                    else\n+                    } else {\n                         stack.clear();\n+                    }\n                 }\n \n             } else {\n                 setTop(false);\n                 mergeLists(lvValues, jumpEntry, false);\n-                if (!stackUpdated && jumpStackEntry != null)\n+                if (!stackUpdated && jumpStackEntry != null) {\n                     mergeLists(stack, jumpStackEntry, false);\n+                }\n             }\n-            if (DEBUG)\n+            if (DEBUG) {\n                 System.out.println(\" merged lvValues \" + lvValues);\n+            }\n         } else if (isReachOnlyByBranch() && !stackUpdated) {\n             stack.clear();\n \n@@ -1040,14 +1100,16 @@ public class OpcodeStack implements Constants2 {\n     int registerTestedFoundToBeNonnegative = -1;\n \n     private void setLastUpdate(int reg, int pc) {\n-        while (lastUpdate.size() <= reg)\n+        while (lastUpdate.size() <= reg) {\n             lastUpdate.add(Integer.valueOf(0));\n+        }\n         lastUpdate.set(reg, Integer.valueOf(pc));\n     }\n \n     public int getLastUpdate(int reg) {\n-        if (lastUpdate.size() <= reg)\n+        if (lastUpdate.size() <= reg) {\n             return 0;\n+        }\n         return lastUpdate.get(reg).intValue();\n     }\n \n@@ -1067,8 +1129,9 @@ public class OpcodeStack implements Constants2 {\n \n         // System.out.printf(\"%3d %12s%s%n\", dbc.getPC(), OPCODE_NAMES[seen],\n         // this);\n-        if (dbc.isRegisterStore())\n+        if (dbc.isRegisterStore()) {\n             setLastUpdate(dbc.getRegisterOperand(), dbc.getPC());\n+        }\n \n         precomputation(dbc);\n         needToMerge = true;\n@@ -1088,173 +1151,178 @@ public class OpcodeStack implements Constants2 {\n                         int nextOpcode = dbc.getCodeByte(dbc.getPC() + 3);\n \n                         if ((prevOpcode1 == ICONST_0 || prevOpcode1 == ICONST_1)\n-                                && (prevOpcode2 == IFNULL || prevOpcode2 == IFNONNULL)\n-                                && (nextOpcode == ICONST_0 || nextOpcode == ICONST_1) && prevOpcode1 != nextOpcode) {\n+                            && (prevOpcode2 == IFNULL || prevOpcode2 == IFNONNULL)\n+                            && (nextOpcode == ICONST_0 || nextOpcode == ICONST_1) && prevOpcode1 != nextOpcode) {\n                             oneMeansNull = prevOpcode1 == ICONST_0;\n-                            if (prevOpcode2 != IFNULL)\n+                            if (prevOpcode2 != IFNULL) {\n                                 oneMeansNull = !oneMeansNull;\n+                            }\n                             zeroOneComing = nextPC + 1;\n                             convertJumpToOneZeroState = convertJumpToZeroOneState = 0;\n                         }\n                     } catch (ArrayIndexOutOfBoundsException e) {\n                         throw e; // throw new\n-                                 // ArrayIndexOutOfBoundsException(nextPC + \" \"\n-                                 // + dbc.getMaxPC());\n+                        // ArrayIndexOutOfBoundsException(nextPC + \" \"\n+                        // + dbc.getMaxPC());\n                     }\n                 }\n             }\n \n             switch (seen) {\n-            case ICONST_1:\n-                convertJumpToOneZeroState = 1;\n-                break;\n-            case GOTO:\n-                if (convertJumpToOneZeroState == 1 && dbc.getBranchOffset() == 4)\n-                    convertJumpToOneZeroState = 2;\n-                else\n-                    convertJumpToOneZeroState = 0;\n-                break;\n-            case ICONST_0:\n-                if (convertJumpToOneZeroState == 2)\n-                    convertJumpToOneZeroState = 3;\n-                else\n+                case ICONST_1:\n+                    convertJumpToOneZeroState = 1;\n+                    break;\n+                case GOTO:\n+                    if (convertJumpToOneZeroState == 1 && dbc.getBranchOffset() == 4) {\n+                        convertJumpToOneZeroState = 2;\n+                    } else {\n+                        convertJumpToOneZeroState = 0;\n+                    }\n+                    break;\n+                case ICONST_0:\n+                    if (convertJumpToOneZeroState == 2) {\n+                        convertJumpToOneZeroState = 3;\n+                    } else {\n+                        convertJumpToOneZeroState = 0;\n+                    }\n+                    break;\n+                default:\n                     convertJumpToOneZeroState = 0;\n-                break;\n-            default:\n-                convertJumpToOneZeroState = 0;\n \n             }\n             switch (seen) {\n-            case ICONST_0:\n-                convertJumpToZeroOneState = 1;\n-                break;\n-            case GOTO:\n-                if (convertJumpToZeroOneState == 1 && dbc.getBranchOffset() == 4)\n-                    convertJumpToZeroOneState = 2;\n-                else\n-                    convertJumpToZeroOneState = 0;\n-                break;\n-            case ICONST_1:\n-                if (convertJumpToZeroOneState == 2)\n-                    convertJumpToZeroOneState = 3;\n-                else\n+                case ICONST_0:\n+                    convertJumpToZeroOneState = 1;\n+                    break;\n+                case GOTO:\n+                    if (convertJumpToZeroOneState == 1 && dbc.getBranchOffset() == 4) {\n+                        convertJumpToZeroOneState = 2;\n+                    } else {\n+                        convertJumpToZeroOneState = 0;\n+                    }\n+                    break;\n+                case ICONST_1:\n+                    if (convertJumpToZeroOneState == 2) {\n+                        convertJumpToZeroOneState = 3;\n+                    } else {\n+                        convertJumpToZeroOneState = 0;\n+                    }\n+                    break;\n+                default:\n                     convertJumpToZeroOneState = 0;\n-                break;\n-            default:\n-                convertJumpToZeroOneState = 0;\n             }\n \n             switch (seen) {\n-            case ALOAD:\n-                pushByLocalObjectLoad(dbc, dbc.getRegisterOperand());\n-                break;\n+                case ALOAD:\n+                    pushByLocalObjectLoad(dbc, dbc.getRegisterOperand());\n+                    break;\n \n-            case ALOAD_0:\n-            case ALOAD_1:\n-            case ALOAD_2:\n-            case ALOAD_3:\n-                pushByLocalObjectLoad(dbc, seen - ALOAD_0);\n-                break;\n+                case ALOAD_0:\n+                case ALOAD_1:\n+                case ALOAD_2:\n+                case ALOAD_3:\n+                    pushByLocalObjectLoad(dbc, seen - ALOAD_0);\n+                    break;\n \n-            case DLOAD:\n-                pushByLocalLoad(\"D\", dbc.getRegisterOperand());\n-                break;\n+                case DLOAD:\n+                    pushByLocalLoad(\"D\", dbc.getRegisterOperand());\n+                    break;\n \n-            case DLOAD_0:\n-            case DLOAD_1:\n-            case DLOAD_2:\n-            case DLOAD_3:\n-                pushByLocalLoad(\"D\", seen - DLOAD_0);\n-                break;\n+                case DLOAD_0:\n+                case DLOAD_1:\n+                case DLOAD_2:\n+                case DLOAD_3:\n+                    pushByLocalLoad(\"D\", seen - DLOAD_0);\n+                    break;\n \n-            case FLOAD:\n-                pushByLocalLoad(\"F\", dbc.getRegisterOperand());\n-                break;\n+                case FLOAD:\n+                    pushByLocalLoad(\"F\", dbc.getRegisterOperand());\n+                    break;\n \n-            case FLOAD_0:\n-            case FLOAD_1:\n-            case FLOAD_2:\n-            case FLOAD_3:\n-                pushByLocalLoad(\"F\", seen - FLOAD_0);\n-                break;\n+                case FLOAD_0:\n+                case FLOAD_1:\n+                case FLOAD_2:\n+                case FLOAD_3:\n+                    pushByLocalLoad(\"F\", seen - FLOAD_0);\n+                    break;\n \n-            case ILOAD:\n-                pushByLocalLoad(\"I\", dbc.getRegisterOperand());\n-                break;\n+                case ILOAD:\n+                    pushByLocalLoad(\"I\", dbc.getRegisterOperand());\n+                    break;\n \n-            case ILOAD_0:\n-            case ILOAD_1:\n-            case ILOAD_2:\n-            case ILOAD_3:\n-                pushByLocalLoad(\"I\", seen - ILOAD_0);\n-                break;\n+                case ILOAD_0:\n+                case ILOAD_1:\n+                case ILOAD_2:\n+                case ILOAD_3:\n+                    pushByLocalLoad(\"I\", seen - ILOAD_0);\n+                    break;\n \n-            case LLOAD:\n-                pushByLocalLoad(\"J\", dbc.getRegisterOperand());\n-                break;\n+                case LLOAD:\n+                    pushByLocalLoad(\"J\", dbc.getRegisterOperand());\n+                    break;\n \n-            case LLOAD_0:\n-            case LLOAD_1:\n-            case LLOAD_2:\n-            case LLOAD_3:\n-                pushByLocalLoad(\"J\", seen - LLOAD_0);\n-                break;\n+                case LLOAD_0:\n+                case LLOAD_1:\n+                case LLOAD_2:\n+                case LLOAD_3:\n+                    pushByLocalLoad(\"J\", seen - LLOAD_0);\n+                    break;\n \n-            case GETSTATIC: {\n-                FieldSummary fieldSummary = AnalysisContext.currentAnalysisContext().getFieldSummary();\n-                XField fieldOperand = dbc.getXFieldOperand();\n+                case GETSTATIC: {\n+                    FieldSummary fieldSummary = AnalysisContext.currentAnalysisContext().getFieldSummary();\n+                    XField fieldOperand = dbc.getXFieldOperand();\n \n-                if (fieldOperand != null && fieldSummary.isComplete() && !fieldOperand.isPublic()) {\n-                    OpcodeStack.Item item = fieldSummary.getSummary(fieldOperand);\n-                    if (item != null) {\n-                        Item itm = new Item(item);\n-                        itm.setLoadedFromField(fieldOperand, Integer.MAX_VALUE);\n-                        push(itm);\n-                        break;\n+                    if (fieldOperand != null && fieldSummary.isComplete() && !fieldOperand.isPublic()) {\n+                        OpcodeStack.Item item = fieldSummary.getSummary(fieldOperand);\n+                        if (item != null) {\n+                            Item itm = new Item(item);\n+                            itm.setLoadedFromField(fieldOperand, Integer.MAX_VALUE);\n+                            push(itm);\n+                            break;\n+                        }\n+                    }\n+                    FieldAnnotation field = FieldAnnotation.fromReferencedField(dbc);\n+                    Item i = new Item(dbc.getSigConstantOperand(), field, Integer.MAX_VALUE);\n+                    if (field.getFieldName().equals(\"separator\") && field.getClassName().equals(\"java.io.File\")) {\n+                        i.setSpecialKind(Item.FILE_SEPARATOR_STRING);\n                     }\n-                }\n-                FieldAnnotation field = FieldAnnotation.fromReferencedField(dbc);\n-                Item i = new Item(dbc.getSigConstantOperand(), field, Integer.MAX_VALUE);\n-                if (field.getFieldName().equals(\"separator\") && field.getClassName().equals(\"java.io.File\")) {\n-                    i.setSpecialKind(Item.FILE_SEPARATOR_STRING);\n-                }\n \n-                push(i);\n-                break;\n-            }\n+                    push(i);\n+                    break;\n+                }\n \n-            case LDC:\n-            case LDC_W:\n-            case LDC2_W:\n-                cons = dbc.getConstantRefOperand();\n-                pushByConstant(dbc, cons);\n-                break;\n+                case LDC:\n+                case LDC_W:\n+                case LDC2_W:\n+                    cons = dbc.getConstantRefOperand();\n+                    pushByConstant(dbc, cons);\n+                    break;\n \n-            case INSTANCEOF:\n-                pop();\n-                push(new Item(\"I\"));\n-                break;\n+                case INSTANCEOF:\n+                    pop();\n+                    push(new Item(\"I\"));\n+                    break;\n \n-            case IFNONNULL:\n-            case IFNULL:\n-                // {\n-                // Item topItem = pop();\n-                // if (seen == IFNONNULL && topItem.isNull())\n-                // break;\n-                // seenTransferOfControl = true;\n-                // addJumpValue(dbc.getPC(), dbc.getBranchTarget());\n-                //\n-                // break;\n-                // }\n-\n-            case IFEQ:\n-            case IFNE:\n-            case IFLT:\n-            case IFLE:\n-            case IFGT:\n-            case IFGE:\n-\n-                seenTransferOfControl = true;\n+                case IFNONNULL:\n+                case IFNULL:\n+                    // {\n+                    // Item topItem = pop();\n+                    // if (seen == IFNONNULL && topItem.isNull())\n+                    // break;\n+                    // seenTransferOfControl = true;\n+                    // addJumpValue(dbc.getPC(), dbc.getBranchTarget());\n+                    //\n+                    // break;\n+                    // }\n+\n+                case IFEQ:\n+                case IFNE:\n+                case IFLT:\n+                case IFLE:\n+                case IFGT:\n+                case IFGE:\n+\n+                    seenTransferOfControl = true;\n                 {\n                     Item topItem = pop();\n \n@@ -1268,606 +1336,618 @@ public class OpcodeStack implements Constants2 {\n                     // reset all other such values on the opcode stack\n                     if (topItem.valueCouldBeNegative() && (seen == IFLT || seen == IFLE || seen == IFGT || seen == IFGE)) {\n                         int specialKind = topItem.getSpecialKind();\n-                        for (Item item : stack)\n-                            if (item != null && item.getSpecialKind() == specialKind)\n+                        for (Item item : stack) {\n+                            if (item != null && item.getSpecialKind() == specialKind) {\n                                 item.setSpecialKind(Item.NOT_SPECIAL);\n-                        for (Item item : lvValues)\n-                            if (item != null && item.getSpecialKind() == specialKind)\n+                            }\n+                        }\n+                        for (Item item : lvValues) {\n+                            if (item != null && item.getSpecialKind() == specialKind) {\n                                 item.setSpecialKind(Item.NOT_SPECIAL);\n+                            }\n+                        }\n \n                     }\n                 }\n                 addJumpValue(dbc.getPC(), dbc.getBranchTarget());\n \n                 break;\n-            case LOOKUPSWITCH:\n+                case LOOKUPSWITCH:\n \n-            case TABLESWITCH:\n-                seenTransferOfControl = true;\n-                setReachOnlyByBranch(true);\n-                pop();\n-                addJumpValue(dbc.getPC(), dbc.getBranchTarget());\n-                int pc = dbc.getBranchTarget() - dbc.getBranchOffset();\n-                for (int offset : dbc.getSwitchOffsets())\n-                    addJumpValue(dbc.getPC(), offset + pc);\n+                case TABLESWITCH:\n+                    seenTransferOfControl = true;\n+                    setReachOnlyByBranch(true);\n+                    pop();\n+                    addJumpValue(dbc.getPC(), dbc.getBranchTarget());\n+                    int pc = dbc.getBranchTarget() - dbc.getBranchOffset();\n+                    for (int offset : dbc.getSwitchOffsets()) {\n+                        addJumpValue(dbc.getPC(), offset + pc);\n+                    }\n \n-                break;\n-            case ARETURN:\n-            case DRETURN:\n-            case FRETURN:\n+                    break;\n+                case ARETURN:\n+                case DRETURN:\n+                case FRETURN:\n \n-            case IRETURN:\n-            case LRETURN:\n+                case IRETURN:\n+                case LRETURN:\n \n-                seenTransferOfControl = true;\n-                setReachOnlyByBranch(true);\n-                pop();\n-                break;\n-            case MONITORENTER:\n-            case MONITOREXIT:\n-            case POP:\n-            case PUTSTATIC:\n-                pop();\n-                break;\n+                    seenTransferOfControl = true;\n+                    setReachOnlyByBranch(true);\n+                    pop();\n+                    break;\n+                case MONITORENTER:\n+                case MONITOREXIT:\n+                case POP:\n+                case PUTSTATIC:\n+                    pop();\n+                    break;\n \n-            case IF_ACMPEQ:\n-            case IF_ACMPNE:\n-            case IF_ICMPEQ:\n-            case IF_ICMPNE:\n-            case IF_ICMPLT:\n-            case IF_ICMPLE:\n-            case IF_ICMPGT:\n-            case IF_ICMPGE:\n-\n-            {\n-                seenTransferOfControl = true;\n-                Item right = pop();\n-                Item left = pop();\n-                \n-                Object lConstant = left.getConstant();\n-                Object rConstant = right.getConstant();\n-                if (lConstant instanceof Integer && rConstant instanceof Integer) {\n-                    boolean takeJump = false;\n-                    boolean handled = false;\n-                    int lC = ((Integer)lConstant).intValue();\n-                    int rC = ((Integer)rConstant).intValue();\n-                    switch(seen) {\n-                    case IF_ICMPEQ:\n-                        takeJump = lC == rC;\n-                        handled = true;\n-                        break;\n-                    case IF_ICMPNE:\n-                        takeJump = lC != rC;\n-                        handled = true;\n-                        break;\n-                    case IF_ICMPGE:\n-                    \t takeJump = lC >= rC;\n-                         handled = true;\n-                         break;\n-                    case IF_ICMPGT:\n-                        takeJump = lC > rC;\n-                        handled = true;\n-                        break;\n-                    case IF_ICMPLE:\n-                        takeJump = lC <= rC;\n-                        handled = true;\n-                        break;\n-                   case IF_ICMPLT:\n-                       takeJump = lC < rC;\n-                       handled = true;\n-                       break;\n-                    }\n-                    if (handled) {\n-                        if (takeJump) {\n-                            int branchTarget = dbc.getBranchTarget();\n-                            addJumpValue(dbc.getPC(), branchTarget);\n-                            setTop(true);\n-                            break;\n-                        } else {\n-                            break;\n+                case IF_ACMPEQ:\n+                case IF_ACMPNE:\n+                case IF_ICMPEQ:\n+                case IF_ICMPNE:\n+                case IF_ICMPLT:\n+                case IF_ICMPLE:\n+                case IF_ICMPGT:\n+                case IF_ICMPGE: {\n+                    seenTransferOfControl = true;\n+                    Item right = pop();\n+                    Item left = pop();\n+\n+                    Object lConstant = left.getConstant();\n+                    Object rConstant = right.getConstant();\n+                    if (lConstant instanceof Integer && rConstant instanceof Integer) {\n+                        boolean takeJump = false;\n+                        boolean handled = false;\n+                        int lC = ((Integer) lConstant).intValue();\n+                        int rC = ((Integer) rConstant).intValue();\n+                        switch (seen) {\n+                            case IF_ICMPEQ:\n+                                takeJump = lC == rC;\n+                                handled = true;\n+                                break;\n+                            case IF_ICMPNE:\n+                                takeJump = lC != rC;\n+                                handled = true;\n+                                break;\n+                            case IF_ICMPGE:\n+                                takeJump = lC >= rC;\n+                                handled = true;\n+                                break;\n+                            case IF_ICMPGT:\n+                                takeJump = lC > rC;\n+                                handled = true;\n+                                break;\n+                            case IF_ICMPLE:\n+                                takeJump = lC <= rC;\n+                                handled = true;\n+                                break;\n+                            case IF_ICMPLT:\n+                                takeJump = lC < rC;\n+                                handled = true;\n+                                break;\n                         }\n+                        if (handled) {\n+                            if (takeJump) {\n+                                int branchTarget = dbc.getBranchTarget();\n+                                addJumpValue(dbc.getPC(), branchTarget);\n+                                setTop(true);\n+                                break;\n+                            } else {\n+                                break;\n+                            }\n+                        }\n+\n                     }\n-                    \n-                }\n-                if (right.hasConstantValue(Integer.MIN_VALUE) && left.mightRarelyBeNegative()\n+                    if (right.hasConstantValue(Integer.MIN_VALUE) && left.mightRarelyBeNegative()\n                         || left.hasConstantValue(Integer.MIN_VALUE) && right.mightRarelyBeNegative()) {\n-                    for (Item i : stack)\n-                        if (i != null && i.mightRarelyBeNegative())\n-                            i.setSpecialKind(Item.NOT_SPECIAL);\n-                    for (Item i : lvValues)\n-                        if (i != null && i.mightRarelyBeNegative())\n-                            i.setSpecialKind(Item.NOT_SPECIAL);\n+                        for (Item i : stack) {\n+                            if (i != null && i.mightRarelyBeNegative()) {\n+                                i.setSpecialKind(Item.NOT_SPECIAL);\n+                            }\n+                        }\n+                        for (Item i : lvValues) {\n+                            if (i != null && i.mightRarelyBeNegative()) {\n+                                i.setSpecialKind(Item.NOT_SPECIAL);\n+                            }\n+                        }\n+                    }\n+                    int branchTarget = dbc.getBranchTarget();\n+                    addJumpValue(dbc.getPC(), branchTarget);\n+                    break;\n                 }\n-                int branchTarget = dbc.getBranchTarget();\n-                addJumpValue(dbc.getPC(), branchTarget);\n-                break;\n-            }\n \n-            case POP2:\n-                it = pop();\n-                if (it.getSize() == 1)\n-                    pop();\n-                break;\n-            case PUTFIELD:\n-                pop(2);\n-                break;\n+                case POP2:\n+                    it = pop();\n+                    if (it.getSize() == 1) {\n+                        pop();\n+                    }\n+                    break;\n+                case PUTFIELD:\n+                    pop(2);\n+                    break;\n \n-            case IALOAD:\n-            case SALOAD:\n-                pop(2);\n-                push(new Item(\"I\"));\n-                break;\n+                case IALOAD:\n+                case SALOAD:\n+                    pop(2);\n+                    push(new Item(\"I\"));\n+                    break;\n \n-            case DUP:\n-                handleDup();\n-                break;\n+                case DUP:\n+                    handleDup();\n+                    break;\n \n-            case DUP2:\n-                handleDup2();\n-                break;\n+                case DUP2:\n+                    handleDup2();\n+                    break;\n \n-            case DUP_X1:\n-                handleDupX1();\n-                break;\n+                case DUP_X1:\n+                    handleDupX1();\n+                    break;\n \n-            case DUP_X2:\n+                case DUP_X2:\n \n-                handleDupX2();\n-                break;\n+                    handleDupX2();\n+                    break;\n \n-            case DUP2_X1:\n-                handleDup2X1();\n-                break;\n+                case DUP2_X1:\n+                    handleDup2X1();\n+                    break;\n \n-            case DUP2_X2:\n-                handleDup2X2();\n-                break;\n+                case DUP2_X2:\n+                    handleDup2X2();\n+                    break;\n \n-            case IINC:\n-                register = dbc.getRegisterOperand();\n-                it = getLVValue(register);\n-                it2 = new Item(\"I\", dbc.getIntConstant());\n-                pushByIntMath(dbc, IADD, it2, it);\n-                pushByLocalStore(register);\n-                break;\n+                case IINC:\n+                    register = dbc.getRegisterOperand();\n+                    it = getLVValue(register);\n+                    it2 = new Item(\"I\", dbc.getIntConstant());\n+                    pushByIntMath(dbc, IADD, it2, it);\n+                    pushByLocalStore(register);\n+                    break;\n \n-            case ATHROW:\n-                pop();\n-                seenTransferOfControl = true;\n-                setReachOnlyByBranch(true);\n-                setTop(true);\n-                break;\n+                case ATHROW:\n+                    pop();\n+                    seenTransferOfControl = true;\n+                    setReachOnlyByBranch(true);\n+                    setTop(true);\n+                    break;\n \n-            case CHECKCAST: {\n-                String castTo = dbc.getClassConstantOperand();\n+                case CHECKCAST: {\n+                    String castTo = dbc.getClassConstantOperand();\n \n-                if (castTo.charAt(0) != '[')\n-                    castTo = \"L\" + castTo + \";\";\n-                it = pop();\n+                    if (castTo.charAt(0) != '[') {\n+                        castTo = \"L\" + castTo + \";\";\n+                    }\n+                    it = pop();\n \n-                if (!it.signature.equals(castTo)) {\n-                    it = new Item(it, castTo);\n-                }\n-                push(it);\n-                break;\n+                    if (!it.signature.equals(castTo)) {\n+                        it = new Item(it, castTo);\n+                    }\n+                    push(it);\n+                    break;\n \n-            }\n-            case NOP:\n-                break;\n-            case RET:\n-            case RETURN:\n-                seenTransferOfControl = true;\n-                setReachOnlyByBranch(true);\n-                break;\n+                }\n+                case NOP:\n+                    break;\n+                case RET:\n+                case RETURN:\n+                    seenTransferOfControl = true;\n+                    setReachOnlyByBranch(true);\n+                    break;\n \n-            case GOTO:\n-            case GOTO_W:\n-                seenTransferOfControl = true;\n-                setReachOnlyByBranch(true);\n-                addJumpValue(dbc.getPC(), dbc.getBranchTarget());\n-                stack.clear();\n-                setTop(true);\n+                case GOTO:\n+                case GOTO_W:\n+                    seenTransferOfControl = true;\n+                    setReachOnlyByBranch(true);\n+                    addJumpValue(dbc.getPC(), dbc.getBranchTarget());\n+                    stack.clear();\n+                    setTop(true);\n \n-                break;\n+                    break;\n \n-            case SWAP:\n-                handleSwap();\n-                break;\n+                case SWAP:\n+                    handleSwap();\n+                    break;\n \n-            case ICONST_M1:\n-            case ICONST_0:\n-            case ICONST_1:\n-            case ICONST_2:\n-            case ICONST_3:\n-            case ICONST_4:\n-            case ICONST_5:\n-                push(new Item(\"I\", (seen - ICONST_0)));\n-                break;\n+                case ICONST_M1:\n+                case ICONST_0:\n+                case ICONST_1:\n+                case ICONST_2:\n+                case ICONST_3:\n+                case ICONST_4:\n+                case ICONST_5:\n+                    push(new Item(\"I\", (seen - ICONST_0)));\n+                    break;\n \n-            case LCONST_0:\n-            case LCONST_1:\n-                push(new Item(\"J\", Long.valueOf(seen - LCONST_0)));\n-                break;\n+                case LCONST_0:\n+                case LCONST_1:\n+                    push(new Item(\"J\", Long.valueOf(seen - LCONST_0)));\n+                    break;\n \n-            case DCONST_0:\n-            case DCONST_1:\n-                push(new Item(\"D\", Double.valueOf(seen - DCONST_0)));\n-                break;\n+                case DCONST_0:\n+                case DCONST_1:\n+                    push(new Item(\"D\", Double.valueOf(seen - DCONST_0)));\n+                    break;\n \n-            case FCONST_0:\n-            case FCONST_1:\n-            case FCONST_2:\n-                push(new Item(\"F\", Float.valueOf(seen - FCONST_0)));\n-                break;\n+                case FCONST_0:\n+                case FCONST_1:\n+                case FCONST_2:\n+                    push(new Item(\"F\", Float.valueOf(seen - FCONST_0)));\n+                    break;\n \n-            case ACONST_NULL:\n-                push(new Item());\n-                break;\n+                case ACONST_NULL:\n+                    push(new Item());\n+                    break;\n \n-            case ASTORE:\n-            case DSTORE:\n-            case FSTORE:\n-            case ISTORE:\n-            case LSTORE:\n-                pushByLocalStore(dbc.getRegisterOperand());\n-                break;\n+                case ASTORE:\n+                case DSTORE:\n+                case FSTORE:\n+                case ISTORE:\n+                case LSTORE:\n+                    pushByLocalStore(dbc.getRegisterOperand());\n+                    break;\n \n-            case ASTORE_0:\n-            case ASTORE_1:\n-            case ASTORE_2:\n-            case ASTORE_3:\n-                pushByLocalStore(seen - ASTORE_0);\n-                break;\n+                case ASTORE_0:\n+                case ASTORE_1:\n+                case ASTORE_2:\n+                case ASTORE_3:\n+                    pushByLocalStore(seen - ASTORE_0);\n+                    break;\n \n-            case DSTORE_0:\n-            case DSTORE_1:\n-            case DSTORE_2:\n-            case DSTORE_3:\n-                pushByLocalStore(seen - DSTORE_0);\n-                break;\n+                case DSTORE_0:\n+                case DSTORE_1:\n+                case DSTORE_2:\n+                case DSTORE_3:\n+                    pushByLocalStore(seen - DSTORE_0);\n+                    break;\n \n-            case FSTORE_0:\n-            case FSTORE_1:\n-            case FSTORE_2:\n-            case FSTORE_3:\n-                pushByLocalStore(seen - FSTORE_0);\n-                break;\n+                case FSTORE_0:\n+                case FSTORE_1:\n+                case FSTORE_2:\n+                case FSTORE_3:\n+                    pushByLocalStore(seen - FSTORE_0);\n+                    break;\n \n-            case ISTORE_0:\n-            case ISTORE_1:\n-            case ISTORE_2:\n-            case ISTORE_3:\n-                pushByLocalStore(seen - ISTORE_0);\n-                break;\n+                case ISTORE_0:\n+                case ISTORE_1:\n+                case ISTORE_2:\n+                case ISTORE_3:\n+                    pushByLocalStore(seen - ISTORE_0);\n+                    break;\n \n-            case LSTORE_0:\n-            case LSTORE_1:\n-            case LSTORE_2:\n-            case LSTORE_3:\n-                pushByLocalStore(seen - LSTORE_0);\n-                break;\n+                case LSTORE_0:\n+                case LSTORE_1:\n+                case LSTORE_2:\n+                case LSTORE_3:\n+                    pushByLocalStore(seen - LSTORE_0);\n+                    break;\n \n-            case GETFIELD: {\n-                FieldSummary fieldSummary = AnalysisContext.currentAnalysisContext().getFieldSummary();\n-                XField fieldOperand = dbc.getXFieldOperand();\n-                if (fieldOperand != null && fieldSummary.isComplete() && !fieldOperand.isPublic()) {\n-                    OpcodeStack.Item item = fieldSummary.getSummary(fieldOperand);\n-                    if (item != null) {\n-                        Item addr = pop();\n-                        Item itm = new Item(item);\n-                        itm.setLoadedFromField(fieldOperand, addr.getRegisterNumber());\n-                        push(itm);\n-                        break;\n+                case GETFIELD: {\n+                    FieldSummary fieldSummary = AnalysisContext.currentAnalysisContext().getFieldSummary();\n+                    XField fieldOperand = dbc.getXFieldOperand();\n+                    if (fieldOperand != null && fieldSummary.isComplete() && !fieldOperand.isPublic()) {\n+                        OpcodeStack.Item item = fieldSummary.getSummary(fieldOperand);\n+                        if (item != null) {\n+                            Item addr = pop();\n+                            Item itm = new Item(item);\n+                            itm.setLoadedFromField(fieldOperand, addr.getRegisterNumber());\n+                            push(itm);\n+                            break;\n+                        }\n                     }\n-                }\n-                Item item = pop();\n-                int reg = item.getRegisterNumber();\n-                push(new Item(dbc.getSigConstantOperand(), FieldAnnotation.fromReferencedField(dbc), reg));\n-\n-            }\n-                break;\n-\n-            case ARRAYLENGTH: {\n-                pop();\n-                Item newItem = new Item(\"I\");\n-                newItem.setSpecialKind(Item.NON_NEGATIVE);\n-                push(newItem);\n-            }\n-                break;\n+                    Item item = pop();\n+                    int reg = item.getRegisterNumber();\n+                    push(new Item(dbc.getSigConstantOperand(), FieldAnnotation.fromReferencedField(dbc), reg));\n \n-            case BALOAD: {\n-                pop(2);\n-                Item newItem = new Item(\"I\");\n-                newItem.setSpecialKind(Item.SIGNED_BYTE);\n-                push(newItem);\n-                break;\n-            }\n-            case CALOAD:\n-                pop(2);\n-                push(new Item(\"I\"));\n-                break;\n-\n-            case DALOAD:\n-                pop(2);\n-                push(new Item(\"D\"));\n-                break;\n-\n-            case FALOAD:\n-                pop(2);\n-                push(new Item(\"F\"));\n-                break;\n-\n-            case LALOAD:\n-                pop(2);\n-                push(new Item(\"J\"));\n-                break;\n-\n-            case AASTORE:\n-            case BASTORE:\n-            case CASTORE:\n-            case DASTORE:\n-            case FASTORE:\n-            case IASTORE:\n-            case LASTORE:\n-            case SASTORE:\n-                pop(3);\n-                break;\n-\n-            case BIPUSH:\n-            case SIPUSH:\n-                push(new Item(\"I\", Integer.valueOf(dbc.getIntConstant())));\n-                break;\n-\n-            case IADD:\n-            case ISUB:\n-            case IMUL:\n-            case IDIV:\n-            case IAND:\n-            case IOR:\n-            case IXOR:\n-            case ISHL:\n-            case ISHR:\n-            case IREM:\n-            case IUSHR:\n-                it = pop();\n-                it2 = pop();\n-                pushByIntMath(dbc, seen, it2, it);\n-                break;\n-\n-            case INEG:\n-                it = pop();\n-                if (it.getConstant() instanceof Integer) {\n-                    push(new Item(\"I\", Integer.valueOf(-constantToInt(it))));\n-                } else {\n-                    push(new Item(\"I\"));\n-                }\n-                break;\n-\n-            case LNEG:\n-                it = pop();\n-                if (it.getConstant() instanceof Long) {\n-                    push(new Item(\"J\", Long.valueOf(-constantToLong(it))));\n-                } else {\n-                    push(new Item(\"J\"));\n-                }\n-                break;\n-            case FNEG:\n-                it = pop();\n-                if (it.getConstant() instanceof Float) {\n-                    push(new Item(\"F\", Float.valueOf(-constantToFloat(it))));\n-                } else {\n-                    push(new Item(\"F\"));\n-                }\n-                break;\n-            case DNEG:\n-                it = pop();\n-                if (it.getConstant() instanceof Double) {\n-                    push(new Item(\"D\", Double.valueOf(-constantToDouble(it))));\n-                } else {\n-                    push(new Item(\"D\"));\n                 }\n                 break;\n \n-            case LADD:\n-            case LSUB:\n-            case LMUL:\n-            case LDIV:\n-            case LAND:\n-            case LOR:\n-            case LXOR:\n-            case LSHL:\n-            case LSHR:\n-            case LREM:\n-            case LUSHR:\n-\n-                it = pop();\n-                it2 = pop();\n-                pushByLongMath(seen, it2, it);\n+                case ARRAYLENGTH: {\n+                    pop();\n+                    Item newItem = new Item(\"I\");\n+                    newItem.setSpecialKind(Item.NON_NEGATIVE);\n+                    push(newItem);\n+                }\n                 break;\n \n-            case LCMP:\n-                handleLcmp();\n-                break;\n+                case BALOAD: {\n+                    pop(2);\n+                    Item newItem = new Item(\"I\");\n+                    newItem.setSpecialKind(Item.SIGNED_BYTE);\n+                    push(newItem);\n+                    break;\n+                }\n+                case CALOAD:\n+                    pop(2);\n+                    push(new Item(\"I\"));\n+                    break;\n \n-            case FCMPG:\n-            case FCMPL:\n-                handleFcmp(seen);\n-                break;\n+                case DALOAD:\n+                    pop(2);\n+                    push(new Item(\"D\"));\n+                    break;\n \n-            case DCMPG:\n-            case DCMPL:\n-                handleDcmp(seen);\n-                break;\n+                case FALOAD:\n+                    pop(2);\n+                    push(new Item(\"F\"));\n+                    break;\n \n-            case FADD:\n-            case FSUB:\n-            case FMUL:\n-            case FDIV:\n-            case FREM:\n-                it = pop();\n-                it2 = pop();\n-                pushByFloatMath(seen, it, it2);\n-                break;\n+                case LALOAD:\n+                    pop(2);\n+                    push(new Item(\"J\"));\n+                    break;\n \n-            case DADD:\n-            case DSUB:\n-            case DMUL:\n-            case DDIV:\n-            case DREM:\n-                it = pop();\n-                it2 = pop();\n-                pushByDoubleMath(seen, it, it2);\n-                break;\n+                case AASTORE:\n+                case BASTORE:\n+                case CASTORE:\n+                case DASTORE:\n+                case FASTORE:\n+                case IASTORE:\n+                case LASTORE:\n+                case SASTORE:\n+                    pop(3);\n+                    break;\n \n-            case I2B: {\n-                it = pop();\n-                Item newValue = new Item(it, \"B\");\n+                case BIPUSH:\n+                case SIPUSH:\n+                    push(new Item(\"I\", Integer.valueOf(dbc.getIntConstant())));\n+                    break;\n \n-                push(newValue);\n-            }\n-                break;\n+                case IADD:\n+                case ISUB:\n+                case IMUL:\n+                case IDIV:\n+                case IAND:\n+                case IOR:\n+                case IXOR:\n+                case ISHL:\n+                case ISHR:\n+                case IREM:\n+                case IUSHR:\n+                    it = pop();\n+                    it2 = pop();\n+                    pushByIntMath(dbc, seen, it2, it);\n+                    break;\n+\n+                case INEG:\n+                    it = pop();\n+                    if (it.getConstant() instanceof Integer) {\n+                        push(new Item(\"I\", Integer.valueOf(-constantToInt(it))));\n+                    } else {\n+                        push(new Item(\"I\"));\n+                    }\n+                    break;\n \n+                case LNEG:\n+                    it = pop();\n+                    if (it.getConstant() instanceof Long) {\n+                        push(new Item(\"J\", Long.valueOf(-constantToLong(it))));\n+                    } else {\n+                        push(new Item(\"J\"));\n+                    }\n+                    break;\n+                case FNEG:\n+                    it = pop();\n+                    if (it.getConstant() instanceof Float) {\n+                        push(new Item(\"F\", Float.valueOf(-constantToFloat(it))));\n+                    } else {\n+                        push(new Item(\"F\"));\n+                    }\n+                    break;\n+                case DNEG:\n+                    it = pop();\n+                    if (it.getConstant() instanceof Double) {\n+                        push(new Item(\"D\", Double.valueOf(-constantToDouble(it))));\n+                    } else {\n+                        push(new Item(\"D\"));\n+                    }\n+                    break;\n \n+                case LADD:\n+                case LSUB:\n+                case LMUL:\n+                case LDIV:\n+                case LAND:\n+                case LOR:\n+                case LXOR:\n+                case LSHL:\n+                case LSHR:\n+                case LREM:\n+                case LUSHR:\n+\n+                    it = pop();\n+                    it2 = pop();\n+                    pushByLongMath(seen, it2, it);\n+                    break;\n \n-            case I2C: {\n-                it = pop();\n-                Item newValue = new Item(it, \"C\");\n+                case LCMP:\n+                    handleLcmp();\n+                    break;\n \n-                push(newValue);\n-            }\n-                break;\n+                case FCMPG:\n+                case FCMPL:\n+                    handleFcmp(seen);\n+                    break;\n \n-            case I2L:\n-            case D2L:\n-            case F2L: {\n-                it = pop();\n-                Item newValue = new Item(it, \"J\");\n+                case DCMPG:\n+                case DCMPL:\n+                    handleDcmp(seen);\n+                    break;\n \n-                int specialKind = it.getSpecialKind();\n+                case FADD:\n+                case FSUB:\n+                case FMUL:\n+                case FDIV:\n+                case FREM:\n+                    it = pop();\n+                    it2 = pop();\n+                    pushByFloatMath(seen, it, it2);\n+                    break;\n \n-                if (specialKind != Item.SIGNED_BYTE && seen == I2L)\n-                    newValue.setSpecialKind(Item.RESULT_OF_I2L);\n+                case DADD:\n+                case DSUB:\n+                case DMUL:\n+                case DDIV:\n+                case DREM:\n+                    it = pop();\n+                    it2 = pop();\n+                    pushByDoubleMath(seen, it, it2);\n+                    break;\n \n-                push(newValue);\n-            }\n-            break;\n+                case I2B: {\n+                    it = pop();\n+                    Item newValue = new Item(it, \"B\");\n \n-            case I2S:\n-                changeSignatureOfTopElement(\"S\");\n+                    push(newValue);\n+                }\n                 break;\n \n-            case L2I:\n-            case D2I:\n-            case F2I:\n-                it = pop();\n-                int oldSpecialKind = it.getSpecialKind();\n-                it = new Item(it, \"I\");\n-\n-                if (oldSpecialKind == Item.NOT_SPECIAL)\n-                    it.setSpecialKind(Item.RESULT_OF_L2I);\n-                push(it);\n \n-                break;\n+                case I2C: {\n+                    it = pop();\n+                    Item newValue = new Item(it, \"C\");\n \n-            case L2F:\n-            case D2F:\n-            case I2F:\n-                it = pop();\n-                if (it.getConstant() != null) {\n-                    push(new Item(\"F\", Float.valueOf(constantToFloat(it))));\n-                } else {\n-                    push(new Item(\"F\"));\n+                    push(newValue);\n                 }\n                 break;\n \n-            case F2D:\n-            case I2D:\n-            case L2D:\n-                it = pop();\n-                if (it.getConstant() != null) {\n-                    push(new Item(\"D\", Double.valueOf(constantToDouble(it))));\n-                } else {\n-                    push(new Item(\"D\"));\n+                case I2L:\n+                case D2L:\n+                case F2L: {\n+                    it = pop();\n+                    Item newValue = new Item(it, \"J\");\n+\n+                    int specialKind = it.getSpecialKind();\n+\n+                    if (specialKind != Item.SIGNED_BYTE && seen == I2L) {\n+                        newValue.setSpecialKind(Item.RESULT_OF_I2L);\n+                    }\n+\n+                    push(newValue);\n                 }\n                 break;\n \n-            case NEW: {\n-                Item item = new Item(\"L\" + dbc.getClassConstantOperand() + \";\", (Object) null);\n-                item.setSpecialKind(Item.NEWLY_ALLOCATED);\n-                push(item);\n-            }\n-                break;\n+                case I2S:\n+                    changeSignatureOfTopElement(\"S\");\n+                    break;\n \n-            case NEWARRAY:\n-                pop();\n-                signature = \"[\" + BasicType.getType((byte) dbc.getIntConstant()).getSignature();\n-                pushBySignature(signature, dbc);\n-                break;\n+                case L2I:\n+                case D2I:\n+                case F2I:\n+                    it = pop();\n+                    int oldSpecialKind = it.getSpecialKind();\n+                    it = new Item(it, \"I\");\n+\n+                    if (oldSpecialKind == Item.NOT_SPECIAL) {\n+                        it.setSpecialKind(Item.RESULT_OF_L2I);\n+                    }\n+                    push(it);\n+\n+                    break;\n+\n+                case L2F:\n+                case D2F:\n+                case I2F:\n+                    it = pop();\n+                    if (it.getConstant() != null) {\n+                        push(new Item(\"F\", Float.valueOf(constantToFloat(it))));\n+                    } else {\n+                        push(new Item(\"F\"));\n+                    }\n+                    break;\n+\n+                case F2D:\n+                case I2D:\n+                case L2D:\n+                    it = pop();\n+                    if (it.getConstant() != null) {\n+                        push(new Item(\"D\", Double.valueOf(constantToDouble(it))));\n+                    } else {\n+                        push(new Item(\"D\"));\n+                    }\n+                    break;\n \n-            // According to the VM Spec 4.4.1, anewarray and multianewarray\n-            // can refer to normal class/interface types (encoded in\n-            // \"internal form\"), or array classes (encoded as signatures\n-            // beginning with \"[\").\n-\n-            case ANEWARRAY:\n-                pop();\n-                signature = dbc.getClassConstantOperand();\n-                if (signature.charAt(0) == '[')\n-                    signature = \"[\" + signature;\n-                else\n-                    signature = \"[L\" + signature + \";\";\n-                pushBySignature(signature, dbc);\n+                case NEW: {\n+                    Item item = new Item(\"L\" + dbc.getClassConstantOperand() + \";\", (Object) null);\n+                    item.setSpecialKind(Item.NEWLY_ALLOCATED);\n+                    push(item);\n+                }\n                 break;\n \n-            case MULTIANEWARRAY:\n-                int dims = dbc.getIntConstant();\n-                for (int i = 0; i < dims; i++)\n+                case NEWARRAY:\n                     pop();\n+                    signature = \"[\" + BasicType.getType((byte) dbc.getIntConstant()).getSignature();\n+                    pushBySignature(signature, dbc);\n+                    break;\n \n-                signature = dbc.getClassConstantOperand();\n-                pushBySignature(signature, dbc);\n-                break;\n+                // According to the VM Spec 4.4.1, anewarray and multianewarray\n+                // can refer to normal class/interface types (encoded in\n+                // \"internal form\"), or array classes (encoded as signatures\n+                // beginning with \"[\").\n \n-            case AALOAD: {\n-                pop();\n-                it = pop();\n-                String arraySig = it.getSignature();\n-                if (arraySig.charAt(0) == '[')\n-                    pushBySignature(arraySig.substring(1), dbc);\n-                else\n-                    push(new Item());\n-            }\n-                break;\n+                case ANEWARRAY:\n+                    pop();\n+                    signature = dbc.getClassConstantOperand();\n+                    if (signature.charAt(0) == '[') {\n+                        signature = \"[\" + signature;\n+                    } else {\n+                        signature = \"[L\" + signature + \";\";\n+                    }\n+                    pushBySignature(signature, dbc);\n+                    break;\n \n-            case JSR:\n-                seenTransferOfControl = true;\n-                setReachOnlyByBranch(false);\n-                push(new Item(\"\")); // push return address on stack\n-                addJumpValue(dbc.getPC(), dbc.getBranchTarget());\n-                pop();\n-                if (dbc.getBranchOffset() < 0) {\n-                    // OK, backwards JSRs are weird; reset the stack.\n-                    int stackSize = stack.size();\n-                    stack.clear();\n-                    for (int i = 0; i < stackSize; i++)\n-                        stack.add(new Item());\n+                case MULTIANEWARRAY:\n+                    int dims = dbc.getIntConstant();\n+                    for (int i = 0; i < dims; i++) {\n+                        pop();\n+                    }\n+\n+                    signature = dbc.getClassConstantOperand();\n+                    pushBySignature(signature, dbc);\n+                    break;\n+\n+                case AALOAD: {\n+                    pop();\n+                    it = pop();\n+                    String arraySig = it.getSignature();\n+                    if (arraySig.charAt(0) == '[') {\n+                        pushBySignature(arraySig.substring(1), dbc);\n+                    } else {\n+                        push(new Item());\n+                    }\n                 }\n-                setTop(false);\n                 break;\n \n-            case INVOKEINTERFACE:\n-            case INVOKESPECIAL:\n-            case INVOKESTATIC:\n-            case INVOKEVIRTUAL:\n-                processMethodCall(dbc, seen);\n-                break;\n+                case JSR:\n+                    seenTransferOfControl = true;\n+                    setReachOnlyByBranch(false);\n+                    push(new Item(\"\")); // push return address on stack\n+                    addJumpValue(dbc.getPC(), dbc.getBranchTarget());\n+                    pop();\n+                    if (dbc.getBranchOffset() < 0) {\n+                        // OK, backwards JSRs are weird; reset the stack.\n+                        int stackSize = stack.size();\n+                        stack.clear();\n+                        for (int i = 0; i < stackSize; i++) {\n+                            stack.add(new Item());\n+                        }\n+                    }\n+                    setTop(false);\n+                    break;\n \n-            default:\n-                throw new UnsupportedOperationException(\"OpCode \" + OPCODE_NAMES[seen] + \" not supported \");\n-            }\n-        }\n+                case INVOKEINTERFACE:\n+                case INVOKESPECIAL:\n+                case INVOKESTATIC:\n+                case INVOKEVIRTUAL:\n+                    processMethodCall(dbc, seen);\n+                    break;\n \n-        catch (RuntimeException e) {\n+                default:\n+                    throw new UnsupportedOperationException(\"OpCode \" + OPCODE_NAMES[seen] + \" not supported \");\n+            }\n+        } catch (RuntimeException e) {\n             // If an error occurs, we clear the stack and locals. one of two\n             // things will occur.\n             // Either the client will expect more stack items than really exist,\n@@ -1876,10 +1956,11 @@ public class OpcodeStack implements Constants2 {\n             // positives\n \n             String msg = \"Error processing opcode \" + OPCODE_NAMES[seen] + \" @ \" + dbc.getPC() + \" in \"\n-                    + dbc.getFullyQualifiedMethodName();\n+                + dbc.getFullyQualifiedMethodName();\n             AnalysisContext.logError(msg, e);\n-            if (DEBUG)\n+            if (DEBUG) {\n                 e.printStackTrace();\n+            }\n             clear();\n         } finally {\n             if (DEBUG) {\n@@ -1905,13 +1986,15 @@ public class OpcodeStack implements Constants2 {\n         if (registerTestedFoundToBeNonnegative >= 0) {\n             for (int i = 0; i < stack.size(); i++) {\n                 Item item = stack.get(i);\n-                if (item != null && item.registerNumber == registerTestedFoundToBeNonnegative)\n+                if (item != null && item.registerNumber == registerTestedFoundToBeNonnegative) {\n                     stack.set(i, item.cloneAndSetSpecialKind(Item.NON_NEGATIVE));\n+                }\n             }\n             for (int i = 0; i < lvValues.size(); i++) {\n                 Item item = lvValues.get(i);\n-                if (item != null && item.registerNumber == registerTestedFoundToBeNonnegative)\n+                if (item != null && item.registerNumber == registerTestedFoundToBeNonnegative) {\n                     lvValues.set(i, item.cloneAndSetSpecialKind(Item.NON_NEGATIVE));\n+                }\n             }\n         }\n         registerTestedFoundToBeNonnegative = -1;\n@@ -1959,7 +2042,6 @@ public class OpcodeStack implements Constants2 {\n \n     /**\n      * handle dcmp\n-     *\n      */\n     private void handleDcmp(int opcode) {\n         Item it = pop();\n@@ -1969,17 +2051,19 @@ public class OpcodeStack implements Constants2 {\n             double d = constantToDouble(it);\n             double d2 = constantToDouble(it2);\n             if (Double.isNaN(d) || Double.isNaN(d2)) {\n-                if (opcode == DCMPG)\n+                if (opcode == DCMPG) {\n                     push(new Item(\"I\", Integer.valueOf(1)));\n-                else\n+                } else {\n                     push(new Item(\"I\", Integer.valueOf(-1)));\n+                }\n             }\n-            if (d2 < d)\n+            if (d2 < d) {\n                 push(new Item(\"I\", Integer.valueOf(-1)));\n-            else if (d2 > d)\n+            } else if (d2 > d) {\n                 push(new Item(\"I\", Integer.valueOf(1)));\n-            else\n+            } else {\n                 push(new Item(\"I\", Integer.valueOf(0)));\n+            }\n         } else {\n             push(new Item(\"I\"));\n         }\n@@ -1987,7 +2071,6 @@ public class OpcodeStack implements Constants2 {\n \n     /**\n      * handle fcmp\n-     *\n      */\n     private void handleFcmp(int opcode) {\n         Item it = pop();\n@@ -1996,17 +2079,19 @@ public class OpcodeStack implements Constants2 {\n             float f = constantToFloat(it);\n             float f2 = constantToFloat(it2);\n             if (Float.isNaN(f) || Float.isNaN(f2)) {\n-                if (opcode == FCMPG)\n+                if (opcode == FCMPG) {\n                     push(new Item(\"I\", Integer.valueOf(1)));\n-                else\n+                } else {\n                     push(new Item(\"I\", Integer.valueOf(-1)));\n+                }\n             }\n-            if (f2 < f)\n+            if (f2 < f) {\n                 push(new Item(\"I\", Integer.valueOf(-1)));\n-            else if (f2 > f)\n+            } else if (f2 > f) {\n                 push(new Item(\"I\", Integer.valueOf(1)));\n-            else\n+            } else {\n                 push(new Item(\"I\", Integer.valueOf(0)));\n+            }\n         } else {\n             push(new Item(\"I\"));\n         }\n@@ -2022,12 +2107,13 @@ public class OpcodeStack implements Constants2 {\n         if ((it.getConstant() != null) && it2.getConstant() != null) {\n             long l = constantToLong(it);\n             long l2 = constantToLong(it2);\n-            if (l2 < l)\n+            if (l2 < l) {\n                 push(new Item(\"I\", Integer.valueOf(-1)));\n-            else if (l2 > l)\n+            } else if (l2 > l) {\n                 push(new Item(\"I\", Integer.valueOf(1)));\n-            else\n+            } else {\n                 push(new Item(\"I\", Integer.valueOf(0)));\n+            }\n         } else {\n             push(new Item(\"I\"));\n         }\n@@ -2189,7 +2275,7 @@ public class OpcodeStack implements Constants2 {\n \n     static {\n         addBoxedType(Integer.class, Long.class, Double.class, Short.class, Float.class, Boolean.class, Character.class,\n-                Byte.class);\n+            Byte.class);\n     }\n \n     private void processMethodCall(DismantleBytecode dbc, int seen) {\n@@ -2201,26 +2287,29 @@ public class OpcodeStack implements Constants2 {\n         boolean sawUnknownAppend = false;\n         Item sbItem = null;\n         Item topItem = null;\n-        if (getStackDepth() > 0)\n+        if (getStackDepth() > 0) {\n             topItem = getStackItem(0);\n+        }\n \n         int numberArguments = PreorderVisitor.getNumberArguments(signature);\n \n         if (boxedTypes.containsKey(clsName)\n-                && topItem != null\n-                && (methodName.equals(\"valueOf\") && !signature.contains(\"String\") || methodName.equals(boxedTypes.get(clsName)\n-                        + \"Value\"))) {\n+            && topItem != null\n+            && (methodName.equals(\"valueOf\") && !signature.contains(\"String\") || methodName.equals(boxedTypes.get(clsName)\n+            + \"Value\"))) {\n             // boxing/unboxing conversion\n             Item value = pop();\n             String newSignature = Type.getReturnType(signature).getSignature();\n             Item newValue = new Item(value, newSignature);\n-            if (newValue.source == null)\n+            if (newValue.source == null) {\n                 newValue.source = XFactory.createReferencedXMethod(dbc);\n+            }\n             if (newValue.specialKind == Item.NOT_SPECIAL) {\n-                if (newSignature.equals(\"B\") || newSignature.equals(\"Ljava/lang/Boolean;\"))\n+                if (newSignature.equals(\"B\") || newSignature.equals(\"Ljava/lang/Boolean;\")) {\n                     newValue.specialKind = Item.SIGNED_BYTE;\n-                else if (newSignature.equals(\"C\") || newSignature.equals(\"Ljava/lang/Character;\"))\n+                } else if (newSignature.equals(\"C\") || newSignature.equals(\"Ljava/lang/Character;\")) {\n                     newValue.specialKind = Item.NON_NEGATIVE;\n+                }\n             }\n             push(newValue);\n             return;\n@@ -2228,24 +2317,28 @@ public class OpcodeStack implements Constants2 {\n \n         int firstArgument = seen == INVOKESTATIC ? 0 : 1;\n         for (int i = firstArgument; i < firstArgument + numberArguments; i++) {\n-            if (i >= getStackDepth())\n+            if (i >= getStackDepth()) {\n                 break;\n+            }\n             Item item = getStackItem(i);\n             String itemSignature = item.getSignature();\n-            if (itemSignature.equals(\"Ljava/lang/StringBuilder;\") || itemSignature.equals(\"Ljava/lang/StringBuffer;\"))\n+            if (itemSignature.equals(\"Ljava/lang/StringBuilder;\") || itemSignature.equals(\"Ljava/lang/StringBuffer;\")) {\n                 item.constValue = null;\n+            }\n         }\n         boolean initializingServletWriter = false;\n         if (seen == INVOKESPECIAL && methodName.equals(\"<init>\") && clsName.startsWith(\"java/io\") && clsName.endsWith(\"Writer\")\n-                && numberArguments > 0) {\n-            Item firstArg = getStackItem(numberArguments-1);\n-            if (firstArg.isServletWriter())\n+            && numberArguments > 0) {\n+            Item firstArg = getStackItem(numberArguments - 1);\n+            if (firstArg.isServletWriter()) {\n                 initializingServletWriter = true;\n+            }\n         }\n         boolean topIsTainted = topItem != null && topItem.isServletParameterTainted();\n         HttpParameterInjection injection = null;\n-        if (topIsTainted)\n+        if (topIsTainted) {\n             injection = topItem.injection;\n+        }\n \n         // TODO: stack merging for trinaries kills the constant.. would be nice\n         // to maintain.\n@@ -2254,45 +2347,50 @@ public class OpcodeStack implements Constants2 {\n                 if (\"(Ljava/lang/String;)V\".equals(signature)) {\n                     Item i = getStackItem(0);\n                     appenderValue = (String) i.getConstant();\n-                    if (i.isServletParameterTainted())\n+                    if (i.isServletParameterTainted()) {\n                         servletRequestParameterTainted = true;\n+                    }\n                 } else if (\"()V\".equals(signature)) {\n                     appenderValue = \"\";\n                 }\n             } else if (\"toString\".equals(methodName) && getStackDepth() >= 1) {\n                 Item i = getStackItem(0);\n                 appenderValue = (String) i.getConstant();\n-                if (i.isServletParameterTainted())\n+                if (i.isServletParameterTainted()) {\n                     servletRequestParameterTainted = true;\n+                }\n             } else if (\"append\".equals(methodName)) {\n                 if (signature.indexOf(\"II)\") == -1 && getStackDepth() >= 2) {\n                     sbItem = getStackItem(1);\n                     Item i = getStackItem(0);\n-                    if (i.isServletParameterTainted() || sbItem.isServletParameterTainted())\n+                    if (i.isServletParameterTainted() || sbItem.isServletParameterTainted()) {\n                         servletRequestParameterTainted = true;\n+                    }\n                     Object sbVal = sbItem.getConstant();\n                     Object sVal = i.getConstant();\n                     if ((sbVal != null) && (sVal != null)) {\n                         appenderValue = sbVal + sVal.toString();\n                     } else if (sbItem.registerNumber >= 0) {\n                         OpcodeStack.Item item = getLVValue(sbItem.registerNumber);\n-                        if (item != null)\n+                        if (item != null) {\n                             item.constValue = null;\n+                        }\n                     }\n                 } else if (signature.startsWith(\"([CII)\")) {\n                     sawUnknownAppend = true;\n                     sbItem = getStackItem(3);\n                     if (sbItem.registerNumber >= 0) {\n                         OpcodeStack.Item item = getLVValue(sbItem.registerNumber);\n-                        if (item != null)\n+                        if (item != null) {\n                             item.constValue = null;\n+                        }\n                     }\n                 } else {\n                     sawUnknownAppend = true;\n                 }\n             }\n         } else if (seen == INVOKESPECIAL && clsName.equals(\"java/io/FileOutputStream\") && methodName.equals(\"<init>\")\n-                && (signature.equals(\"(Ljava/io/File;Z)V\") || signature.equals(\"(Ljava/lang/String;Z)V\")) && stack.size() > 3) {\n+            && (signature.equals(\"(Ljava/io/File;Z)V\") || signature.equals(\"(Ljava/lang/String;Z)V\")) && stack.size() > 3) {\n             OpcodeStack.Item item = getStackItem(0);\n             Object value = item.getConstant();\n             if (value instanceof Integer && ((Integer) value).intValue() == 1) {\n@@ -2306,10 +2404,10 @@ public class OpcodeStack implements Constants2 {\n                 return;\n             }\n         } else if (seen == INVOKESPECIAL && clsName.equals(\"java/io/BufferedOutputStream\") && methodName.equals(\"<init>\")\n-                && signature.equals(\"(Ljava/io/OutputStream;)V\")) {\n+            && signature.equals(\"(Ljava/io/OutputStream;)V\")) {\n \n             if (getStackItem(0).getSpecialKind() == Item.FILE_OPENED_IN_APPEND_MODE\n-                    && getStackItem(2).signature.equals(\"Ljava/io/BufferedOutputStream;\")) {\n+                && getStackItem(2).signature.equals(\"Ljava/io/BufferedOutputStream;\")) {\n \n                 pop(2);\n                 Item newTop = getStackItem(0);\n@@ -2319,22 +2417,23 @@ public class OpcodeStack implements Constants2 {\n                 return;\n             }\n         } else if (seen == INVOKEINTERFACE && methodName.equals(\"getParameter\")\n-                && clsName.equals(\"javax/servlet/http/HttpServletRequest\") || clsName.equals(\"javax/servlet/http/ServletRequest\")) {\n+            && clsName.equals(\"javax/servlet/http/HttpServletRequest\") || clsName.equals(\"javax/servlet/http/ServletRequest\")) {\n             Item requestParameter = pop();\n             pop();\n             Item result = new Item(\"Ljava/lang/String;\");\n             result.setServletParameterTainted();\n             result.source = XFactory.createReferencedXMethod(dbc);\n             String parameterName = null;\n-            if (requestParameter.getConstant() instanceof String)\n+            if (requestParameter.getConstant() instanceof String) {\n                 parameterName = (String) requestParameter.getConstant();\n+            }\n \n             result.injection = new HttpParameterInjection(parameterName, dbc.getPC());\n             result.setPC(dbc.getPC());\n             push(result);\n             return;\n         } else if (seen == INVOKEINTERFACE && methodName.equals(\"getQueryString\")\n-                && clsName.equals(\"javax/servlet/http/HttpServletRequest\") || clsName.equals(\"javax/servlet/http/ServletRequest\")) {\n+            && clsName.equals(\"javax/servlet/http/HttpServletRequest\") || clsName.equals(\"javax/servlet/http/ServletRequest\")) {\n             pop();\n             Item result = new Item(\"Ljava/lang/String;\");\n             result.setServletParameterTainted();\n@@ -2343,8 +2442,9 @@ public class OpcodeStack implements Constants2 {\n             push(result);\n             return;\n         } else if (seen == INVOKEINTERFACE && methodName.equals(\"getHeader\")\n-                && clsName.equals(\"javax/servlet/http/HttpServletRequest\") || clsName.equals(\"javax/servlet/http/ServletRequest\")) {\n-            /* Item requestParameter = */pop();\n+            && clsName.equals(\"javax/servlet/http/HttpServletRequest\") || clsName.equals(\"javax/servlet/http/ServletRequest\")) {\n+            /* Item requestParameter = */\n+            pop();\n             pop();\n             Item result = new Item(\"Ljava/lang/String;\");\n             result.setServletParameterTainted();\n@@ -2353,12 +2453,13 @@ public class OpcodeStack implements Constants2 {\n             push(result);\n             return;\n         } else if (seen == INVOKESTATIC && methodName.equals(\"asList\") && clsName.equals(\"java/util/Arrays\")) {\n-            /* Item requestParameter = */pop();\n+            /* Item requestParameter = */\n+            pop();\n             Item result = new Item(JAVA_UTIL_ARRAYS_ARRAY_LIST);\n             push(result);\n             return;\n         } else if (seen == INVOKESTATIC && signature.equals(\"(Ljava/util/List;)Ljava/util/List;\")\n-                && clsName.equals(\"java/util/Collections\")) {\n+            && clsName.equals(\"java/util/Collections\")) {\n             Item requestParameter = pop();\n             if (requestParameter.getSignature().equals(JAVA_UTIL_ARRAYS_ARRAY_LIST)) {\n                 Item result = new Item(JAVA_UTIL_ARRAYS_ARRAY_LIST);\n@@ -2370,8 +2471,9 @@ public class OpcodeStack implements Constants2 {\n \n         pushByInvoke(dbc, seen != INVOKESTATIC);\n \n-        if (initializingServletWriter)\n+        if (initializingServletWriter) {\n             this.getStackItem(0).setIsServletWriter();\n+        }\n \n         if ((sawUnknownAppend || appenderValue != null || servletRequestParameterTainted) && getStackDepth() > 0) {\n             Item i = this.getStackItem(0);\n@@ -2383,43 +2485,47 @@ public class OpcodeStack implements Constants2 {\n             if (sbItem != null) {\n                 i.registerNumber = sbItem.registerNumber;\n                 i.source = sbItem.source;\n-                if (i.injection == null)\n+                if (i.injection == null) {\n                     i.injection = sbItem.injection;\n-                if (sbItem.registerNumber >= 0)\n+                }\n+                if (sbItem.registerNumber >= 0) {\n                     setLVValue(sbItem.registerNumber, i);\n+                }\n             }\n             return;\n         }\n \n         if ((clsName.equals(\"java/util/Random\") || clsName.equals(\"java/security/SecureRandom\")) && methodName.equals(\"nextInt\")\n-                && signature.equals(\"()I\")) {\n+            && signature.equals(\"()I\")) {\n             Item i = pop();\n             i.setSpecialKind(Item.RANDOM_INT);\n             push(i);\n-        } else if (methodName.equals(\"size\") && signature.equals(\"()I\") \n-                && Subtypes2.instanceOf(ClassName.toDottedClassName(clsName), \"java.util.Collection\")) {\n+        } else if (methodName.equals(\"size\") && signature.equals(\"()I\")\n+            && Subtypes2.instanceOf(ClassName.toDottedClassName(clsName), \"java.util.Collection\")) {\n             Item i = pop();\n-            if (i.getSpecialKind() == Item.NOT_SPECIAL)\n-                    i.setSpecialKind(Item.NON_NEGATIVE);\n+            if (i.getSpecialKind() == Item.NOT_SPECIAL) {\n+                i.setSpecialKind(Item.NON_NEGATIVE);\n+            }\n             push(i);\n         } else if (ClassName.isMathClass(clsName) && methodName.equals(\"abs\")) {\n             Item i = pop();\n-            if (i.getSpecialKind() == Item.HASHCODE_INT)\n+            if (i.getSpecialKind() == Item.HASHCODE_INT) {\n                 i.setSpecialKind(Item.MATH_ABS_OF_HASHCODE);\n-            else if (i.getSpecialKind() == Item.RANDOM_INT)\n+            } else if (i.getSpecialKind() == Item.RANDOM_INT) {\n                 i.setSpecialKind(Item.MATH_ABS_OF_RANDOM);\n-            else\n+            } else {\n                 i.setSpecialKind(Item.MATH_ABS);\n+            }\n             push(i);\n         } else if (seen == INVOKEVIRTUAL && methodName.equals(\"hashCode\") && signature.equals(\"()I\") || seen == INVOKESTATIC\n-                && clsName.equals(\"java/lang/System\") && methodName.equals(\"identityHashCode\")\n-                && signature.equals(\"(Ljava/lang/Object;)I\")) {\n+            && clsName.equals(\"java/lang/System\") && methodName.equals(\"identityHashCode\")\n+            && signature.equals(\"(Ljava/lang/Object;)I\")) {\n             Item i = pop();\n             i.setSpecialKind(Item.HASHCODE_INT);\n             push(i);\n         } else if (topIsTainted\n-                && (methodName.startsWith(\"encode\") && clsName.equals(\"javax/servlet/http/HttpServletResponse\") || methodName\n-                        .equals(\"trim\") && clsName.equals(\"java/lang/String\"))) {\n+            && (methodName.startsWith(\"encode\") && clsName.equals(\"javax/servlet/http/HttpServletResponse\") || methodName\n+            .equals(\"trim\") && clsName.equals(\"java/lang/String\"))) {\n             Item i = pop();\n             i.setSpecialKind(Item.SERVLET_REQUEST_TAINTED);\n             i.injection = injection;\n@@ -2446,16 +2552,18 @@ public class OpcodeStack implements Constants2 {\n             }\n         } else {\n             if (DEBUG2) {\n-                if (intoSize == fromSize)\n+                if (intoSize == fromSize) {\n                     System.out.println(\"Merging items\");\n-                else\n+                } else {\n                     System.out.println(\"Bad merging items\");\n+                }\n                 System.out.println(\"current items: \" + mergeInto);\n                 System.out.println(\"jump items: \" + mergeFrom);\n             }\n \n-            for (int i = 0; i < Math.min(intoSize, fromSize); i++)\n+            for (int i = 0; i < Math.min(intoSize, fromSize); i++) {\n                 mergeInto.set(i, Item.merge(mergeInto.get(i), mergeFrom.get(i)));\n+            }\n             if (DEBUG2) {\n                 System.out.println(\"merged items: \" + mergeInto);\n             }\n@@ -2530,7 +2638,7 @@ public class OpcodeStack implements Constants2 {\n          * @return\n          */\n         public static JumpInfo computeJumpInfo(JavaClass jclass, Method method, final OpcodeStack stack,\n-                DismantleBytecode branchAnalysis) {\n+                                               DismantleBytecode branchAnalysis) {\n             branchAnalysis.setupVisitorForClass(jclass);\n             MethodInfo xMethod = (MethodInfo) XFactory.createXMethod(jclass, method);\n             int oldCount = 0;\n@@ -2540,11 +2648,12 @@ public class OpcodeStack implements Constants2 {\n                 int newCount = stack.jumpEntries.size();\n                 if (xMethod.hasBackBranch() != stack.backwardsBranch) {\n                     AnalysisContext.logError(\n-                            String.format(\"For %s, mismatch on existing of backedge: %s for precomputation, %s for bytecode analysis\",\n-                                    xMethod, xMethod.hasBackBranch(), stack.backwardsBranch));\n+                        String.format(\"For %s, mismatch on existing of backedge: %s for precomputation, %s for bytecode analysis\",\n+                            xMethod, xMethod.hasBackBranch(), stack.backwardsBranch));\n                 }\n-                if (newCount == oldCount || !stack.encountedTop || !stack.backwardsBranch)\n+                if (newCount == oldCount || !stack.encountedTop || !stack.backwardsBranch) {\n                     break;\n+                }\n                 oldCount = newCount;\n             }\n \n@@ -2557,15 +2666,18 @@ public class OpcodeStack implements Constants2 {\n     }\n \n     private void addJumpValue(int from, int target) {\n-        if (DEBUG)\n+        if (DEBUG) {\n             System.out.println(\"Set jump entry at \" + methodName + \":\" + target + \"pc to \" + stack + \" : \" + lvValues);\n+        }\n \n-        if (from >= target)\n+        if (from >= target) {\n             backwardsBranch = true;\n+        }\n         List<Item> atTarget = jumpEntries.get(Integer.valueOf(target));\n         if (atTarget == null) {\n-            if (DEBUG)\n+            if (DEBUG) {\n                 System.out.println(\"Was null\");\n+            }\n \n             jumpEntries.put(Integer.valueOf(target), new ArrayList<Item>(lvValues));\n             jumpEntryLocations.set(target);\n@@ -2576,10 +2688,12 @@ public class OpcodeStack implements Constants2 {\n         }\n         mergeLists(atTarget, lvValues, false);\n         List<Item> stackAtTarget = jumpStackEntries.get(Integer.valueOf(target));\n-        if (stack.size() > 0 && stackAtTarget != null)\n+        if (stack.size() > 0 && stackAtTarget != null) {\n             mergeLists(stackAtTarget, stack, false);\n-        if (DEBUG)\n+        }\n+        if (DEBUG) {\n             System.out.println(\"merge target for \" + methodName + \":\" + target + \"pc is \" + atTarget);\n+        }\n     }\n \n     private String methodName;\n@@ -2612,8 +2726,9 @@ public class OpcodeStack implements Constants2 {\n \n         int result = resetForMethodEntry0(v);\n         Code code = v.getMethod().getCode();\n-        if (code == null)\n+        if (code == null) {\n             return result;\n+        }\n \n         if (useIterativeAnalysis) {\n             JumpInfo jump = null;\n@@ -2621,8 +2736,9 @@ public class OpcodeStack implements Constants2 {\n                 jump = ((OpcodeStackDetector.WithCustomJumpInfo) visitor).customJumpInfo();\n             }\n \n-            if (jump == null)\n+            if (jump == null) {\n                 jump = getJumpInfo();\n+            }\n             if (jump != null) {\n                 learnFrom(jump);\n             }\n@@ -2638,8 +2754,9 @@ public class OpcodeStack implements Constants2 {\n         XMethod xMethod = XFactory.createXMethod(v.getThisClass(), v.getMethod());\n         if (xMethod instanceof MethodInfo) {\n             MethodInfo mi = (MethodInfo) xMethod;\n-            if (!mi.hasBackBranch())\n+            if (!mi.hasBackBranch()) {\n                 return null;\n+            }\n         }\n         try {\n             return analysisCache.getMethodAnalysis(JumpInfo.class, xMethod.getMethodDescriptor());\n@@ -2656,8 +2773,9 @@ public class OpcodeStack implements Constants2 {\n     private int resetForMethodEntry0(@SlashedClassName String className, Method m) {\n         methodName = m.getName();\n \n-        if (DEBUG)\n+        if (DEBUG) {\n             System.out.println(\" --- \");\n+        }\n         String signature = m.getSignature();\n         stack.clear();\n         lvValues.clear();\n@@ -2671,12 +2789,15 @@ public class OpcodeStack implements Constants2 {\n         Code code = m.getCode();\n         if (code != null) {\n             CodeException[] exceptionTable = code.getExceptionTable();\n-            if (exceptionTable != null)\n-                for (CodeException ex : exceptionTable)\n+            if (exceptionTable != null) {\n+                for (CodeException ex : exceptionTable) {\n                     exceptionHandlers.set(ex.getHandlerPC());\n+                }\n+            }\n         }\n-        if (DEBUG)\n+        if (DEBUG) {\n             System.out.println(\" --- \" + className + \" \" + m.getName() + \" \" + signature);\n+        }\n         Type[] argTypes = Type.getArgumentTypes(signature);\n         int reg = 0;\n         if (!m.isStatic()) {\n@@ -2703,8 +2824,8 @@ public class OpcodeStack implements Constants2 {\n     public Item getStackItem(int stackOffset) {\n         if (stackOffset < 0 || stackOffset >= stack.size()) {\n             AnalysisContext.logError(\"Can't get stack offset \" + stackOffset + \" from \" + stack.toString() + \" @ \" + v.getPC()\n-                    + \" in \" + v.getFullyQualifiedMethodName(), new IllegalArgumentException(stackOffset\n-                    + \" is not a value stack offset\"));\n+                + \" in \" + v.getFullyQualifiedMethodName(), new IllegalArgumentException(stackOffset\n+                + \" is not a value stack offset\"));\n             return new Item(\"Lfindbugs/OpcodeStackError;\");\n \n         }\n@@ -2714,7 +2835,7 @@ public class OpcodeStack implements Constants2 {\n             return stack.get(pos);\n         } catch (ArrayIndexOutOfBoundsException e) {\n             throw new ArrayIndexOutOfBoundsException(\"Requested item at offset \" + stackOffset + \" in a stack of size \"\n-                    + stack.size() + \", made request for position \" + pos);\n+                + stack.size() + \", made request for position \" + pos);\n         }\n     }\n \n@@ -2728,8 +2849,9 @@ public class OpcodeStack implements Constants2 {\n     }\n \n     private void pop(int count) {\n-        while ((count--) > 0)\n+        while ((count--) > 0) {\n             pop();\n+        }\n     }\n \n     private void push(Item i) {\n@@ -2738,21 +2860,22 @@ public class OpcodeStack implements Constants2 {\n \n     private void pushByConstant(DismantleBytecode dbc, Constant c) {\n \n-        if (c instanceof ConstantClass)\n+        if (c instanceof ConstantClass) {\n             push(new Item(\"Ljava/lang/Class;\", ((ConstantClass) c).getConstantValue(dbc.getConstantPool())));\n-        else if (c instanceof ConstantInteger)\n+        } else if (c instanceof ConstantInteger) {\n             push(new Item(\"I\", Integer.valueOf(((ConstantInteger) c).getBytes())));\n-        else if (c instanceof ConstantString) {\n+        } else if (c instanceof ConstantString) {\n             int s = ((ConstantString) c).getStringIndex();\n             push(new Item(\"Ljava/lang/String;\", getStringFromIndex(dbc, s)));\n-        } else if (c instanceof ConstantFloat)\n+        } else if (c instanceof ConstantFloat) {\n             push(new Item(\"F\", Float.valueOf(((ConstantFloat) c).getBytes())));\n-        else if (c instanceof ConstantDouble)\n+        } else if (c instanceof ConstantDouble) {\n             push(new Item(\"D\", Double.valueOf(((ConstantDouble) c).getBytes())));\n-        else if (c instanceof ConstantLong)\n+        } else if (c instanceof ConstantLong) {\n             push(new Item(\"J\", Long.valueOf(((ConstantLong) c).getBytes())));\n-        else\n+        } else {\n             throw new UnsupportedOperationException(\"Constant type not expected\");\n+        }\n     }\n \n     private void pushByLocalObjectLoad(DismantleBytecode dbc, int register) {\n@@ -2777,9 +2900,10 @@ public class OpcodeStack implements Constants2 {\n         }\n \n         try {\n-            if (DEBUG)\n+            if (DEBUG) {\n                 System.out.println(\"pushByIntMath \" + dbc.getFullyQualifiedMethodName() + \" @ \" + dbc.getPC() + \" : \" + lhs\n-                        + OPCODE_NAMES[seen] + rhs);\n+                    + OPCODE_NAMES[seen] + rhs);\n+            }\n \n             if (rhs.getConstant() != null && lhs.getConstant() != null) {\n                 int lhsValue = constantToInt(lhs);\n@@ -2790,76 +2914,82 @@ public class OpcodeStack implements Constants2 {\n                 }\n                 switch (seen) {\n \n-                case IADD:\n-                    newValue = new Item(\"I\", lhsValue + rhsValue);\n-                    break;\n-                case ISUB:\n-                    newValue = new Item(\"I\", lhsValue - rhsValue);\n-                    break;\n-                case IMUL:\n-                    newValue = new Item(\"I\", lhsValue * rhsValue);\n-                    break;\n-                case IDIV:\n-                    newValue = new Item(\"I\", lhsValue / rhsValue);\n-                    break;\n-                case IREM:\n-                    newValue = new Item(\"I\", lhsValue % rhsValue);\n-                    break;\n-                case IAND:\n-                    newValue = new Item(\"I\", lhsValue & rhsValue);\n-                    if ((rhsValue & 0xff) == 0 && rhsValue != 0 || (lhsValue & 0xff) == 0 && lhsValue != 0)\n-                        newValue.setSpecialKind(Item.LOW_8_BITS_CLEAR);\n+                    case IADD:\n+                        newValue = new Item(\"I\", lhsValue + rhsValue);\n+                        break;\n+                    case ISUB:\n+                        newValue = new Item(\"I\", lhsValue - rhsValue);\n+                        break;\n+                    case IMUL:\n+                        newValue = new Item(\"I\", lhsValue * rhsValue);\n+                        break;\n+                    case IDIV:\n+                        newValue = new Item(\"I\", lhsValue / rhsValue);\n+                        break;\n+                    case IREM:\n+                        newValue = new Item(\"I\", lhsValue % rhsValue);\n+                        break;\n+                    case IAND:\n+                        newValue = new Item(\"I\", lhsValue & rhsValue);\n+                        if ((rhsValue & 0xff) == 0 && rhsValue != 0 || (lhsValue & 0xff) == 0 && lhsValue != 0) {\n+                            newValue.setSpecialKind(Item.LOW_8_BITS_CLEAR);\n+                        }\n \n-                    break;\n-                case IOR:\n-                    newValue = new Item(\"I\", lhsValue | rhsValue);\n-                    break;\n-                case IXOR:\n-                    newValue = new Item(\"I\", lhsValue ^ rhsValue);\n-                    break;\n-                case ISHL:\n-                    newValue = new Item(\"I\", lhsValue << rhsValue);\n-                    if (rhsValue >= 8)\n-                        newValue.setSpecialKind(Item.LOW_8_BITS_CLEAR);\n+                        break;\n+                    case IOR:\n+                        newValue = new Item(\"I\", lhsValue | rhsValue);\n+                        break;\n+                    case IXOR:\n+                        newValue = new Item(\"I\", lhsValue ^ rhsValue);\n+                        break;\n+                    case ISHL:\n+                        newValue = new Item(\"I\", lhsValue << rhsValue);\n+                        if (rhsValue >= 8) {\n+                            newValue.setSpecialKind(Item.LOW_8_BITS_CLEAR);\n+                        }\n \n-                    break;\n-                case ISHR:\n-                    newValue = new Item(\"I\", lhsValue >> rhsValue);\n+                        break;\n+                    case ISHR:\n+                        newValue = new Item(\"I\", lhsValue >> rhsValue);\n \n-                    break;\n-                case IUSHR:\n-                    newValue = new Item(\"I\", lhsValue >>> rhsValue);\n+                        break;\n+                    case IUSHR:\n+                        newValue = new Item(\"I\", lhsValue >>> rhsValue);\n \n                 }\n \n             } else if ((seen == ISHL || seen == ISHR || seen == IUSHR)) {\n                 if (rhs.getConstant() != null) {\n                     int constant = constantToInt(rhs);\n-                    if ((constant & 0x1f) == 0)\n+                    if ((constant & 0x1f) == 0) {\n                         newValue = new Item(lhs);\n-                    else if (seen == ISHL && (constant & 0x1f) >= 8)\n+                    } else if (seen == ISHL && (constant & 0x1f) >= 8) {\n                         newValue.setSpecialKind(Item.LOW_8_BITS_CLEAR);\n+                    }\n                 } else if (lhs.getConstant() != null) {\n                     int constant = constantToInt(lhs);\n-                    if (constant == 0)\n+                    if (constant == 0) {\n                         newValue = new Item(\"I\", 0);\n+                    }\n                 }\n             } else if (lhs.getConstant() != null && seen == IAND) {\n                 int value = constantToInt(lhs);\n-                if (value == 0)\n+                if (value == 0) {\n                     newValue = new Item(\"I\", 0);\n-                else if ((value & 0xff) == 0)\n+                } else if ((value & 0xff) == 0) {\n                     newValue.setSpecialKind(Item.LOW_8_BITS_CLEAR);\n-                else if (value >= 0)\n+                } else if (value >= 0) {\n                     newValue.setSpecialKind(Item.NON_NEGATIVE);\n+                }\n             } else if (rhs.getConstant() != null && seen == IAND) {\n                 int value = constantToInt(rhs);\n-                if (value == 0)\n+                if (value == 0) {\n                     newValue = new Item(\"I\", 0);\n-                else if ((value & 0xff) == 0)\n+                } else if ((value & 0xff) == 0) {\n                     newValue.setSpecialKind(Item.LOW_8_BITS_CLEAR);\n-                else if (value >= 0)\n+                } else if (value >= 0) {\n                     newValue.setSpecialKind(Item.NON_NEGATIVE);\n+                }\n             } else if (seen == IAND && lhs.getSpecialKind() == Item.ZERO_MEANS_NULL) {\n                 newValue.setSpecialKind(Item.ZERO_MEANS_NULL);\n                 newValue.setPC(lhs.getPC());\n@@ -2877,32 +3007,39 @@ public class OpcodeStack implements Constants2 {\n             assert true; // ignore it\n         } catch (RuntimeException e) {\n             String msg = \"Error processing2 \" + lhs + OPCODE_NAMES[seen] + rhs + \" @ \" + dbc.getPC() + \" in \"\n-                    + dbc.getFullyQualifiedMethodName();\n+                + dbc.getFullyQualifiedMethodName();\n             AnalysisContext.logError(msg, e);\n \n         }\n         if (lhs.getSpecialKind() == Item.INTEGER_SUM && rhs.getConstant() != null) {\n             int rhsValue = constantToInt(rhs);\n-            if (seen == IDIV && rhsValue == 2 || seen == ISHR && rhsValue == 1)\n+            if (seen == IDIV && rhsValue == 2 || seen == ISHR && rhsValue == 1) {\n                 newValue.setSpecialKind(Item.AVERAGE_COMPUTED_USING_DIVISION);\n+            }\n         }\n         if (seen == IADD && newValue.getSpecialKind() == Item.NOT_SPECIAL && lhs.getConstant() == null\n-                && rhs.getConstant() == null)\n+            && rhs.getConstant() == null) {\n             newValue.setSpecialKind(Item.INTEGER_SUM);\n-        if (seen == IREM && lhs.getSpecialKind() == Item.HASHCODE_INT)\n+        }\n+        if (seen == IREM && lhs.getSpecialKind() == Item.HASHCODE_INT) {\n             newValue.setSpecialKind(Item.HASHCODE_INT_REMAINDER);\n-        if (seen == IREM && lhs.getSpecialKind() == Item.RANDOM_INT)\n+        }\n+        if (seen == IREM && lhs.getSpecialKind() == Item.RANDOM_INT) {\n             newValue.setSpecialKind(Item.RANDOM_INT_REMAINDER);\n+        }\n         if (seen == IREM && lhs.checkForIntegerMinValue()) {\n             if (rhs.getConstant() != null) {\n                 int rhsValue = constantToInt(rhs);\n-                if (!Util.isPowerOfTwo(rhsValue))\n+                if (!Util.isPowerOfTwo(rhsValue)) {\n                     newValue.setSpecialKind(lhs.getSpecialKindForRemainder());\n-            } else\n+                }\n+            } else {\n                 newValue.setSpecialKind(lhs.getSpecialKindForRemainder());\n+            }\n         }\n-        if (DEBUG)\n+        if (DEBUG) {\n             System.out.println(\"push: \" + newValue);\n+        }\n         newValue.setPC(dbc.getPC());\n         push(newValue);\n     }\n@@ -2916,40 +3053,43 @@ public class OpcodeStack implements Constants2 {\n                 long lhsValue = constantToLong(lhs);\n                 if (seen == LSHL) {\n                     newValue = new Item(\"J\", Long.valueOf(lhsValue << constantToInt(rhs)));\n-                    if (constantToInt(rhs) >= 8)\n+                    if (constantToInt(rhs) >= 8) {\n                         newValue.setSpecialKind(Item.LOW_8_BITS_CLEAR);\n-                } else if (seen == LSHR)\n+                    }\n+                } else if (seen == LSHR) {\n                     newValue = new Item(\"J\", Long.valueOf(lhsValue >> constantToInt(rhs)));\n-                else if (seen == LUSHR)\n+                } else if (seen == LUSHR) {\n                     newValue = new Item(\"J\", Long.valueOf(lhsValue >>> constantToInt(rhs)));\n-\n-                else {\n+                } else {\n                     long rhsValue = constantToLong(rhs);\n-                    if (seen == LADD)\n+                    if (seen == LADD) {\n                         newValue = new Item(\"J\", Long.valueOf(lhsValue + rhsValue));\n-                    else if (seen == LSUB)\n+                    } else if (seen == LSUB) {\n                         newValue = new Item(\"J\", Long.valueOf(lhsValue - rhsValue));\n-                    else if (seen == LMUL)\n+                    } else if (seen == LMUL) {\n                         newValue = new Item(\"J\", Long.valueOf(lhsValue * rhsValue));\n-                    else if (seen == LDIV)\n+                    } else if (seen == LDIV) {\n                         newValue = new Item(\"J\", Long.valueOf(lhsValue / rhsValue));\n-                    else if (seen == LAND) {\n+                    } else if (seen == LAND) {\n                         newValue = new Item(\"J\", Long.valueOf(lhsValue & rhsValue));\n-                        if ((rhsValue & 0xff) == 0 && rhsValue != 0 || (lhsValue & 0xff) == 0 && lhsValue != 0)\n+                        if ((rhsValue & 0xff) == 0 && rhsValue != 0 || (lhsValue & 0xff) == 0 && lhsValue != 0) {\n                             newValue.setSpecialKind(Item.LOW_8_BITS_CLEAR);\n-                    } else if (seen == LOR)\n+                        }\n+                    } else if (seen == LOR) {\n                         newValue = new Item(\"J\", Long.valueOf(lhsValue | rhsValue));\n-                    else if (seen == LXOR)\n+                    } else if (seen == LXOR) {\n                         newValue = new Item(\"J\", Long.valueOf(lhsValue ^ rhsValue));\n-                    else if (seen == LREM)\n+                    } else if (seen == LREM) {\n                         newValue = new Item(\"J\", Long.valueOf(lhsValue % rhsValue));\n+                    }\n                 }\n-            } else if (rhs.getConstant() != null && seen == LSHL && constantToInt(rhs) >= 8)\n+            } else if (rhs.getConstant() != null && seen == LSHL && constantToInt(rhs) >= 8) {\n                 newValue.setSpecialKind(Item.LOW_8_BITS_CLEAR);\n-            else if (lhs.getConstant() != null && seen == LAND && (constantToLong(lhs) & 0xff) == 0)\n+            } else if (lhs.getConstant() != null && seen == LAND && (constantToLong(lhs) & 0xff) == 0) {\n                 newValue.setSpecialKind(Item.LOW_8_BITS_CLEAR);\n-            else if (rhs.getConstant() != null && seen == LAND && (constantToLong(rhs) & 0xff) == 0)\n+            } else if (rhs.getConstant() != null && seen == LAND && (constantToLong(rhs) & 0xff) == 0) {\n                 newValue.setSpecialKind(Item.LOW_8_BITS_CLEAR);\n+            }\n         } catch (RuntimeException e) {\n             // ignore it\n         }\n@@ -2960,22 +3100,24 @@ public class OpcodeStack implements Constants2 {\n         Item result;\n         int specialKind = Item.FLOAT_MATH;\n         if ((it.getConstant() instanceof Float) && it2.getConstant() instanceof Float) {\n-            if (seen == FADD)\n+            if (seen == FADD) {\n                 result = new Item(\"F\", Float.valueOf(constantToFloat(it2) + constantToFloat(it)));\n-            else if (seen == FSUB)\n+            } else if (seen == FSUB) {\n                 result = new Item(\"F\", Float.valueOf(constantToFloat(it2) - constantToFloat(it)));\n-            else if (seen == FMUL)\n+            } else if (seen == FMUL) {\n                 result = new Item(\"F\", Float.valueOf(constantToFloat(it2) * constantToFloat(it)));\n-            else if (seen == FDIV)\n+            } else if (seen == FDIV) {\n                 result = new Item(\"F\", Float.valueOf(constantToFloat(it2) / constantToFloat(it)));\n-            else if (seen == FREM)\n+            } else if (seen == FREM) {\n                 result = new Item(\"F\", Float.valueOf(constantToFloat(it2) % constantToFloat(it)));\n-            else\n+            } else {\n                 result = new Item(\"F\");\n+            }\n         } else {\n             result = new Item(\"F\");\n-            if (seen == DDIV)\n+            if (seen == DDIV) {\n                 specialKind = Item.NASTY_FLOAT_MATH;\n+            }\n         }\n         result.setSpecialKind(specialKind);\n         push(result);\n@@ -2985,22 +3127,24 @@ public class OpcodeStack implements Constants2 {\n         Item result;\n         int specialKind = Item.FLOAT_MATH;\n         if ((it.getConstant() instanceof Double) && it2.getConstant() instanceof Double) {\n-            if (seen == DADD)\n+            if (seen == DADD) {\n                 result = new Item(\"D\", Double.valueOf(constantToDouble(it2) + constantToDouble(it)));\n-            else if (seen == DSUB)\n+            } else if (seen == DSUB) {\n                 result = new Item(\"D\", Double.valueOf(constantToDouble(it2) - constantToDouble(it)));\n-            else if (seen == DMUL)\n+            } else if (seen == DMUL) {\n                 result = new Item(\"D\", Double.valueOf(constantToDouble(it2) * constantToDouble(it)));\n-            else if (seen == DDIV)\n+            } else if (seen == DDIV) {\n                 result = new Item(\"D\", Double.valueOf(constantToDouble(it2) / constantToDouble(it)));\n-            else if (seen == DREM)\n+            } else if (seen == DREM) {\n                 result = new Item(\"D\", Double.valueOf(constantToDouble(it2) % constantToDouble(it)));\n-            else\n+            } else {\n                 result = new Item(\"D\"); // ?\n+            }\n         } else {\n             result = new Item(\"D\");\n-            if (seen == DDIV)\n+            if (seen == DDIV) {\n                 specialKind = Item.NASTY_FLOAT_MATH;\n+            }\n         }\n         result.setSpecialKind(specialKind);\n         push(result);\n@@ -3027,13 +3171,13 @@ public class OpcodeStack implements Constants2 {\n     public Item getItemMethodInvokedOn(DismantleBytecode dbc) {\n         int opcode = dbc.getOpcode();\n         switch (opcode) {\n-        case INVOKEVIRTUAL:\n-        case INVOKEINTERFACE:\n-        case INVOKESPECIAL:\n-            String signature = dbc.getSigConstantOperand();\n-            int stackOffset = PreorderVisitor.getNumberArguments(signature);\n+            case INVOKEVIRTUAL:\n+            case INVOKEINTERFACE:\n+            case INVOKESPECIAL:\n+                String signature = dbc.getSigConstantOperand();\n+                int stackOffset = PreorderVisitor.getNumberArguments(signature);\n \n-            return getStackItem(stackOffset);\n+                return getStackItem(stackOffset);\n         }\n         throw new IllegalArgumentException(\"Not visiting an instance method call\");\n     }\n@@ -3044,35 +3188,44 @@ public class OpcodeStack implements Constants2 {\n     }\n \n     private void pushBySignature(String s, DismantleBytecode dbc) {\n-        if (\"V\".equals(s))\n+        if (\"V\".equals(s)) {\n             return;\n+        }\n         Item item = new Item(s, (Object) null);\n-        if (dbc != null)\n+        if (dbc != null) {\n             item.setPC(dbc.getPC());\n-        if (\"B\".equals(s))\n+        }\n+        if (\"B\".equals(s)) {\n             item.setSpecialKind(Item.SIGNED_BYTE);\n-        else if (\"C\".equals(s))\n+        } else if (\"C\".equals(s)) {\n             item.setSpecialKind(Item.NON_NEGATIVE);\n+        }\n         push(item);\n     }\n \n     private void pushByLocalStore(int register) {\n         Item it = pop();\n         if (it.getRegisterNumber() != register) {\n-            for (Item i : lvValues)\n+            for (Item i : lvValues) {\n                 if (i != null) {\n-                    if (i.registerNumber == register)\n+                    if (i.registerNumber == register) {\n                         i.registerNumber = -1;\n-                    if (i.fieldLoadedFromRegister == register)\n+                    }\n+                    if (i.fieldLoadedFromRegister == register) {\n                         i.fieldLoadedFromRegister = -1;\n+                    }\n                 }\n-            for (Item i : stack)\n+            }\n+            for (Item i : stack) {\n                 if (i != null) {\n-                    if (i.registerNumber == register)\n+                    if (i.registerNumber == register) {\n                         i.registerNumber = -1;\n-                    if (i.fieldLoadedFromRegister == register)\n+                    }\n+                    if (i.fieldLoadedFromRegister == register) {\n                         i.fieldLoadedFromRegister = -1;\n+                    }\n                 }\n+            }\n         }\n         setLVValue(register, it);\n     }\n@@ -3091,8 +3244,9 @@ public class OpcodeStack implements Constants2 {\n                 newItem.signature = signature;\n             }\n             if (newItem.getRegisterNumber() < 0) {\n-                if (newItem == oldItem)\n+                if (newItem == oldItem) {\n                     newItem = new Item(oldItem);\n+                }\n                 newItem.registerNumber = register;\n             }\n         }\n@@ -3103,20 +3257,24 @@ public class OpcodeStack implements Constants2 {\n \n     private void setLVValue(int index, Item value) {\n         int addCount = index - lvValues.size() + 1;\n-        while ((addCount--) > 0)\n+        while ((addCount--) > 0) {\n             lvValues.add(null);\n-        if (!useIterativeAnalysis && seenTransferOfControl)\n+        }\n+        if (!useIterativeAnalysis && seenTransferOfControl) {\n             value = Item.merge(value, lvValues.get(index));\n+        }\n         lvValues.set(index, value);\n     }\n \n     public Item getLVValue(int index) {\n-        if (index >= lvValues.size())\n+        if (index >= lvValues.size()) {\n             return new Item();\n+        }\n \n         Item item = lvValues.get(index);\n-        if (item != null)\n+        if (item != null) {\n             return item;\n+        }\n \n         return new Item();\n     }\n@@ -3126,33 +3284,35 @@ public class OpcodeStack implements Constants2 {\n     }\n \n     /**\n-     * @param top\n-     *            The top to set.\n+     * @param top The top to set.\n      */\n     private void setTop(boolean top) {\n         if (top) {\n-            if (!this.top)\n+            if (!this.top) {\n                 this.top = true;\n-        } else if (this.top)\n+            }\n+        } else if (this.top) {\n             this.top = false;\n+        }\n     }\n \n     /**\n      * @return Returns the top.\n      */\n     public boolean isTop() {\n-        if (top)\n+        if (top) {\n             return true;\n+        }\n         return false;\n     }\n \n     /**\n-     * @param reachOnlyByBranch\n-     *            The reachOnlyByBranch to set.\n+     * @param reachOnlyByBranch The reachOnlyByBranch to set.\n      */\n     void setReachOnlyByBranch(boolean reachOnlyByBranch) {\n-        if (reachOnlyByBranch)\n+        if (reachOnlyByBranch) {\n             setTop(true);\n+        }\n         this.reachOnlyByBranch = reachOnlyByBranch;\n     }\n \n",
            "diff_size": 1382
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/errored/1/10/OpcodeStack.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/codebuff/10/OpcodeStack.java\nindex 6c3e1fc04c5..f18d7e96317 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/errored/1/10/OpcodeStack.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/codebuff/10/OpcodeStack.java\n@@ -28,9 +28,7 @@ import java.util.BitSet;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n-\n import javax.annotation.meta.TypeQualifier;\n-\n import org.apache.bcel.Repository;\n import org.apache.bcel.classfile.Code;\n import org.apache.bcel.classfile.CodeException;\n@@ -48,7 +46,6 @@ import org.apache.bcel.classfile.LocalVariableTable;\n import org.apache.bcel.classfile.Method;\n import org.apache.bcel.generic.BasicType;\n import org.apache.bcel.generic.Type;\n-\n import edu.umd.cs.findbugs.annotations.CheckForNull;\n import edu.umd.cs.findbugs.ba.AnalysisContext;\n import edu.umd.cs.findbugs.ba.AnalysisFeatures;\n@@ -93,6 +90,7 @@ import edu.umd.cs.findbugs.visitclass.PreorderVisitor;\n  * <li>wide</li>\n  * </ul>\n  */\n+\n public class OpcodeStack implements Constants2 {\n     /**\n      *\n@@ -120,15 +118,15 @@ public class OpcodeStack implements Constants2 {\n         String parameterName;\n \n         int pc;\n+\n     }\n \n+\n     private boolean seenTransferOfControl = false;\n \n-    private final boolean useIterativeAnalysis = AnalysisContext.currentAnalysisContext().getBoolProperty(\n-            AnalysisFeatures.INTERATIVE_OPCODE_STACK_ANALYSIS);\n+    private final boolean useIterativeAnalysis = AnalysisContext.currentAnalysisContext().getBoolProperty(AnalysisFeatures.INTERATIVE_OPCODE_STACK_ANALYSIS);\n \n     public static class Item {\n-\n         @Documented\n         @TypeQualifier(applicableTo = Integer.class)\n         @Retention(RetentionPolicy.RUNTIME)\n@@ -217,6 +215,7 @@ public class OpcodeStack implements Constants2 {\n             return nextSpecialKind++;\n         }\n \n+\n         private static final int IS_INITIAL_PARAMETER_FLAG = 1;\n \n         private static final int COULD_BE_ZERO_FLAG = 2;\n@@ -287,7 +286,6 @@ public class OpcodeStack implements Constants2 {\n             r *= 31;\n             r += registerNumber;\n             return r;\n-\n         }\n \n         @Override\n@@ -295,13 +293,11 @@ public class OpcodeStack implements Constants2 {\n             if (!(o instanceof Item))\n                 return false;\n             Item that = (Item) o;\n-\n             return Util.nullSafeEquals(this.signature, that.signature) && Util.nullSafeEquals(this.constValue, that.constValue)\n-                    && Util.nullSafeEquals(this.source, that.source) && Util.nullSafeEquals(this.userValue, that.userValue)\n-                    && Util.nullSafeEquals(this.injection, that.injection) && this.specialKind == that.specialKind\n-                    && this.registerNumber == that.registerNumber && this.flags == that.flags\n-                    && this.fieldLoadedFromRegister == that.fieldLoadedFromRegister;\n-\n+&& Util.nullSafeEquals(this.source, that.source)\n+                   && Util.nullSafeEquals(this.userValue, that.userValue)\n+                   && Util.nullSafeEquals(this.injection, that.injection)\n+                   && this.specialKind == that.specialKind && this.registerNumber == that.registerNumber && this.flags == that.flags && this.fieldLoadedFromRegister == that.fieldLoadedFromRegister;\n         }\n \n         @Override\n@@ -372,14 +368,12 @@ public class OpcodeStack implements Constants2 {\n             case SERVLET_OUTPUT:\n                 buf.append(\", servlet_output\");\n                 break;\n-\n             case NOT_SPECIAL:\n                 break;\n             default:\n                 buf.append(\", #\" + specialKind);\n                 buf.append(\"(\" + specialKindNames.get(specialKind) + \")\");\n                 break;\n-\n             }\n             if (constValue != UNKNOWN) {\n                 if (constValue instanceof String) {\n@@ -407,7 +401,6 @@ public class OpcodeStack implements Constants2 {\n             if (isNull()) {\n                 buf.append(\", isNull\");\n             }\n-\n             if (registerNumber != -1) {\n                 buf.append(\", r\");\n                 buf.append(registerNumber);\n@@ -418,7 +411,6 @@ public class OpcodeStack implements Constants2 {\n                 buf.append(\", uv: \");\n                 buf.append(userValue.toString());\n             }\n-            \n             buf.append(\" >\");\n             return buf.toString();\n         }\n@@ -449,15 +441,12 @@ public class OpcodeStack implements Constants2 {\n                 m.source = i2.source;\n             else if (\"\".equals(i2.constValue))\n                 m.source = i1.source;\n-\n             if (Util.nullSafeEquals(i1.userValue, i2.userValue))\n                 m.userValue = i1.userValue;\n-\n             if (i1.registerNumber == i2.registerNumber)\n                 m.registerNumber = i1.registerNumber;\n             if (i1.fieldLoadedFromRegister == i2.fieldLoadedFromRegister)\n                 m.fieldLoadedFromRegister = i1.fieldLoadedFromRegister;\n-\n             if (i1.specialKind == SERVLET_REQUEST_TAINTED) {\n                 m.specialKind = SERVLET_REQUEST_TAINTED;\n                 m.injection = i1.injection;\n@@ -465,16 +454,17 @@ public class OpcodeStack implements Constants2 {\n                 m.specialKind = SERVLET_REQUEST_TAINTED;\n                 m.injection = i2.injection;\n             } else if (i1.specialKind == i2.specialKind)\n-                m.specialKind = i1.specialKind;\n-            else if (i1.specialKind == NASTY_FLOAT_MATH || i2.specialKind == NASTY_FLOAT_MATH)\n-                m.specialKind = NASTY_FLOAT_MATH;\n-            else if (i1.specialKind == FLOAT_MATH || i2.specialKind == FLOAT_MATH)\n-                m.specialKind = FLOAT_MATH;\n+                  m.specialKind = i1.specialKind;\n+              else if (i1.specialKind == NASTY_FLOAT_MATH || i2.specialKind == NASTY_FLOAT_MATH)\n+                  m.specialKind = NASTY_FLOAT_MATH;\n+              else if (i1.specialKind == FLOAT_MATH || i2.specialKind == FLOAT_MATH)\n+                  m.specialKind = FLOAT_MATH;\n             if (DEBUG)\n                 System.out.println(\"Merge \" + i1 + \" and \" + i2 + \" gives \" + m);\n             return m;\n         }\n \n+\n         public Item(String signature, int constValue) {\n             this(signature, Integer.valueOf(constValue));\n         }\n@@ -508,7 +498,6 @@ public class OpcodeStack implements Constants2 {\n                     this.constValue = (char) constantNumericValue.intValue();\n                 else if (signature.equals(\"I\"))\n                     this.constValue = constantNumericValue.intValue();\n-\n             }\n             setSpecialKindFromSignature();\n         }\n@@ -542,6 +531,8 @@ public class OpcodeStack implements Constants2 {\n          * @return\n          *\n          */\n+\n+\n         public int getFieldLoadedFromRegister() {\n             return fieldLoadedFromRegister;\n         }\n@@ -569,6 +560,7 @@ public class OpcodeStack implements Constants2 {\n             return injection.pc;\n         }\n \n+\n         public Item(String signature, Object constantValue) {\n             this.signature = DescriptorFactory.canonicalizeString(signature);\n             setSpecialKindFromSignature();\n@@ -579,7 +571,6 @@ public class OpcodeStack implements Constants2 {\n                     specialKind = LOW_8_BITS_CLEAR;\n                 if (value == 0)\n                     setCouldBeZero(true);\n-\n             } else if (constantValue instanceof Long) {\n                 long value = ((Long) constantValue).longValue();\n                 if (value != 0 && (value & 0xff) == 0)\n@@ -587,7 +578,6 @@ public class OpcodeStack implements Constants2 {\n                 if (value == 0)\n                     setCouldBeZero(true);\n             }\n-\n         }\n \n         private void setSpecialKindFromSignature() {\n@@ -599,12 +589,14 @@ public class OpcodeStack implements Constants2 {\n                 specialKind = NON_NEGATIVE;\n         }\n \n+\n         public Item() {\n             signature = \"Ljava/lang/Object;\";\n             constValue = null;\n             setNull(true);\n         }\n \n+\n         public static Item nullItem(String signature) {\n             Item item = new Item(signature);\n             item.constValue = null;\n@@ -613,15 +605,13 @@ public class OpcodeStack implements Constants2 {\n         }\n \n         /** Returns null for primitive and arrays */\n+\n         public @CheckForNull\n         JavaClass getJavaClass() throws ClassNotFoundException {\n             String baseSig;\n-\n             if (isPrimitive() || isArray())\n                 return null;\n-\n             baseSig = signature;\n-\n             if (baseSig.length() == 0)\n                 return null;\n             baseSig = baseSig.substring(1, baseSig.length() - 1);\n@@ -676,11 +666,13 @@ public class OpcodeStack implements Constants2 {\n          * is a constant Class object, the constant value returned is the name\n          * of the class.\n          */\n+\n         public Object getConstant() {\n             return constValue;\n         }\n \n         /** Use getXField instead */\n+\n         @Deprecated\n         public FieldAnnotation getFieldAnnotation() {\n             return FieldAnnotation.fromXField(getXField());\n@@ -696,6 +688,7 @@ public class OpcodeStack implements Constants2 {\n          * @param specialKind\n          *            The specialKind to set.\n          */\n+\n         public void setSpecialKind(@SpecialKind int specialKind) {\n             this.specialKind = specialKind;\n         }\n@@ -709,6 +702,7 @@ public class OpcodeStack implements Constants2 {\n         /**\n          * @return Returns the specialKind.\n          */\n+\n         public @SpecialKind\n         int getSpecialKind() {\n             return specialKind;\n@@ -717,6 +711,7 @@ public class OpcodeStack implements Constants2 {\n         /**\n          * @return Returns the specialKind.\n          */\n+\n         public boolean isBooleanNullnessValue() {\n             return specialKind == ZERO_MEANS_NULL || specialKind == NONZERO_MEANS_NULL;\n         }\n@@ -727,6 +722,7 @@ public class OpcodeStack implements Constants2 {\n          * @param value\n          *            the custom value to set\n          */\n+\n         public void setUserValue(Object value) {\n             userValue = value;\n         }\n@@ -736,6 +732,7 @@ public class OpcodeStack implements Constants2 {\n          * @return if this value is the return value of a method, give the\n          *         method invoked\n          */\n+\n         public @CheckForNull\n         XMethod getReturnValueOf() {\n             if (source instanceof XMethod)\n@@ -757,6 +754,7 @@ public class OpcodeStack implements Constants2 {\n          *\n          * @return the custom value\n          */\n+\n         public Object getUserValue() {\n             return userValue;\n         }\n@@ -768,32 +766,26 @@ public class OpcodeStack implements Constants2 {\n         public void setServletParameterTainted() {\n             setSpecialKind(Item.SERVLET_REQUEST_TAINTED);\n         }\n+\n         public void setIsServletWriter() {\n             setSpecialKind(Item.SERVLET_OUTPUT);\n         }\n \n-\n-        public  boolean isServletWriter() {\n+        public boolean isServletWriter() {\n             if (getSpecialKind() == Item.SERVLET_OUTPUT)\n                 return true;\n             if (getSignature().equals(\"Ljavax/servlet/ServletOutputStream;\"))\n                 return true;\n             XMethod writingToSource = getReturnValueOf();\n-\n-\n-            return writingToSource != null && writingToSource.getClassName().equals(\"javax.servlet.http.HttpServletResponse\")\n-                    && (writingToSource.getName().equals(\"getWriter\") || writingToSource.getName().equals(\"getOutputStream\"));\n+            return writingToSource != null && writingToSource.getClassName().equals(\"javax.servlet.http.HttpServletResponse\") && (writingToSource.getName().equals(\"getWriter\") || writingToSource.getName().equals(\"getOutputStream\"));\n         }\n \n         public boolean valueCouldBeNegative() {\n-            return !isNonNegative()\n-                    && (getSpecialKind() == Item.RANDOM_INT || getSpecialKind() == Item.SIGNED_BYTE\n-                            || getSpecialKind() == Item.HASHCODE_INT || getSpecialKind() == Item.RANDOM_INT_REMAINDER\n-                            || getSpecialKind() == Item.HASHCODE_INT_REMAINDER || getSpecialKind() == Item.MATH_ABS_OF_RANDOM || getSpecialKind() == Item.MATH_ABS_OF_HASHCODE);\n-\n+            return !isNonNegative() && (getSpecialKind() == Item.RANDOM_INT || getSpecialKind() == Item.SIGNED_BYTE || getSpecialKind() == Item.HASHCODE_INT || getSpecialKind() == Item.RANDOM_INT_REMAINDER || getSpecialKind() == Item.HASHCODE_INT_REMAINDER || getSpecialKind() == Item.MATH_ABS_OF_RANDOM || getSpecialKind() == Item.MATH_ABS_OF_HASHCODE);\n         }\n \n-        public @SpecialKind int getSpecialKindForAbs() {\n+        public @SpecialKind\n+        int getSpecialKindForAbs() {\n             switch (getSpecialKind()) {\n             case Item.HASHCODE_INT:\n                 return Item.MATH_ABS_OF_HASHCODE;\n@@ -804,7 +796,8 @@ public class OpcodeStack implements Constants2 {\n             }\n         }\n \n-        public @SpecialKind int getSpecialKindForRemainder() {\n+        public @SpecialKind\n+        int getSpecialKindForRemainder() {\n             switch (getSpecialKind()) {\n             case Item.HASHCODE_INT:\n                 return Item.HASHCODE_INT_REMAINDER;\n@@ -816,20 +809,23 @@ public class OpcodeStack implements Constants2 {\n         }\n \n         /** Value could be Integer.MIN_VALUE */\n+\n         public boolean checkForIntegerMinValue() {\n             return !isNonNegative() && (getSpecialKind() == Item.RANDOM_INT || getSpecialKind() == Item.HASHCODE_INT);\n         }\n \n         /** The result of applying Math.abs to a checkForIntegerMinValue() value */\n+\n         public boolean mightRarelyBeNegative() {\n-            return !isNonNegative()\n-                    && (getSpecialKind() == Item.MATH_ABS_OF_RANDOM || getSpecialKind() == Item.MATH_ABS_OF_HASHCODE);\n+            return !isNonNegative() && (getSpecialKind() == Item.MATH_ABS_OF_RANDOM || getSpecialKind() == Item.MATH_ABS_OF_HASHCODE);\n         }\n \n         /**\n          * @param isInitialParameter\n          *            The isInitialParameter to set.\n          */\n+\n+\n         private void setInitialParameter(boolean isInitialParameter) {\n             setFlag(isInitialParameter, IS_INITIAL_PARAMETER_FLAG);\n         }\n@@ -837,6 +833,7 @@ public class OpcodeStack implements Constants2 {\n         /**\n          * @return Returns the isInitialParameter.\n          */\n+\n         public boolean isInitialParameter() {\n             return (flags & IS_INITIAL_PARAMETER_FLAG) != 0;\n         }\n@@ -845,6 +842,8 @@ public class OpcodeStack implements Constants2 {\n          * @param couldBeZero\n          *            The couldBeZero to set.\n          */\n+\n+\n         private void setCouldBeZero(boolean couldBeZero) {\n             setFlag(couldBeZero, COULD_BE_ZERO_FLAG);\n         }\n@@ -852,6 +851,8 @@ public class OpcodeStack implements Constants2 {\n         /**\n          * @return Returns the couldBeZero.\n          */\n+\n+\n         private boolean isCouldBeZero() {\n             return (flags & COULD_BE_ZERO_FLAG) != 0;\n         }\n@@ -860,10 +861,13 @@ public class OpcodeStack implements Constants2 {\n          * @param isNull\n          *            The isNull to set.\n          */\n+\n+\n         private void setNull(boolean isNull) {\n             setFlag(isNull, IS_NULL_FLAG);\n         }\n \n+\n         private void setFlag(boolean value, int flagBit) {\n             if (value)\n                 flags |= flagBit;\n@@ -874,6 +878,7 @@ public class OpcodeStack implements Constants2 {\n         /**\n          * @return Returns the isNull.\n          */\n+\n         public boolean isNull() {\n             return (flags & IS_NULL_FLAG) != 0;\n         }\n@@ -881,6 +886,7 @@ public class OpcodeStack implements Constants2 {\n         /**\n          *\n          */\n+\n         public void clearNewlyAllocated() {\n             if (specialKind == NEWLY_ALLOCATED) {\n                 if (signature.startsWith(\"Ljava/lang/StringB\"))\n@@ -897,6 +903,7 @@ public class OpcodeStack implements Constants2 {\n          * @param i\n          * @return\n          */\n+\n         public boolean hasConstantValue(int value) {\n             if (constValue instanceof Number)\n                 return ((Number) constValue).intValue() == value;\n@@ -917,15 +924,16 @@ public class OpcodeStack implements Constants2 {\n         return stack.toString() + \"::\" + lvValues.toString();\n     }\n \n+\n     public OpcodeStack() {\n         stack = new ArrayList<Item>();\n         lvValues = new ArrayList<Item>();\n         lastUpdate = new ArrayList<Integer>();\n     }\n \n+\n     public boolean hasIncomingBranches(int pc) {\n         return jumpEntryLocations.get(pc) && jumpEntries.get(pc) != null;\n-\n     }\n \n     boolean needToMerge = true;\n@@ -955,15 +963,12 @@ public class OpcodeStack implements Constants2 {\n                 item.setSpecialKind(Item.ZERO_MEANS_NULL);\n             item.setPC(dbc.getPC() - 8);\n             item.setCouldBeZero(true);\n-\n             push(item);\n-\n             zeroOneComing = -1;\n             if (DEBUG)\n                 System.out.println(\"Updated to \" + this);\n             return;\n         }\n-\n         boolean stackUpdated = false;\n         if (!isTop() && (convertJumpToOneZeroState == 3 || convertJumpToZeroOneState == 3)) {\n             pop();\n@@ -973,21 +978,18 @@ public class OpcodeStack implements Constants2 {\n             convertJumpToOneZeroState = convertJumpToZeroOneState = 0;\n             stackUpdated = true;\n         }\n-\n         List<Item> jumpEntry = null;\n         if (jumpEntryLocations.get(dbc.getPC()))\n             jumpEntry = jumpEntries.get(Integer.valueOf(dbc.getPC()));\n         if (jumpEntry != null) {\n             setReachOnlyByBranch(false);\n             List<Item> jumpStackEntry = jumpStackEntries.get(Integer.valueOf(dbc.getPC()));\n-            \n             if (DEBUG2) {\n                 System.out.println(\"XXXXXXX \" + isReachOnlyByBranch());\n                 System.out.println(\"merging lvValues at jump target \" + dbc.getPC() + \" -> \" + jumpEntry);\n                 System.out.println(\" current lvValues \" + lvValues);\n                 System.out.println(\" merging stack entry \" + jumpStackEntry);\n                 System.out.println(\" current stack values \" + stack);\n-\n             }\n             if (isTop()) {\n                 lvValues = new ArrayList<Item>(jumpEntry);\n@@ -1007,7 +1009,6 @@ public class OpcodeStack implements Constants2 {\n                     else\n                         stack.clear();\n                 }\n-\n             } else {\n                 setTop(false);\n                 mergeLists(lvValues, jumpEntry, false);\n@@ -1018,19 +1019,16 @@ public class OpcodeStack implements Constants2 {\n                 System.out.println(\" merged lvValues \" + lvValues);\n         } else if (isReachOnlyByBranch() && !stackUpdated) {\n             stack.clear();\n-\n             for (CodeException e : dbc.getCode().getExceptionTable()) {\n                 if (e.getHandlerPC() == dbc.getPC()) {\n                     push(new Item(getExceptionSig(dbc, e)));\n                     setReachOnlyByBranch(false);\n                     setTop(false);\n                     return;\n-\n                 }\n             }\n             setTop(true);\n         }\n-\n     }\n \n     int convertJumpToOneZeroState = 0;\n@@ -1069,7 +1067,6 @@ public class OpcodeStack implements Constants2 {\n         // this);\n         if (dbc.isRegisterStore())\n             setLastUpdate(dbc.getRegisterOperand(), dbc.getPC());\n-\n         precomputation(dbc);\n         needToMerge = true;\n         try {\n@@ -1077,19 +1074,15 @@ public class OpcodeStack implements Constants2 {\n                 encountedTop = true;\n                 return;\n             }\n-\n             if (seen == GOTO) {\n                 int nextPC = dbc.getPC() + 3;\n                 if (nextPC <= dbc.getMaxPC()) {\n-\n                     int prevOpcode1 = dbc.getPrevOpcode(1);\n                     int prevOpcode2 = dbc.getPrevOpcode(2);\n                     try {\n                         int nextOpcode = dbc.getCodeByte(dbc.getPC() + 3);\n-\n-                        if ((prevOpcode1 == ICONST_0 || prevOpcode1 == ICONST_1)\n-                                && (prevOpcode2 == IFNULL || prevOpcode2 == IFNONNULL)\n-                                && (nextOpcode == ICONST_0 || nextOpcode == ICONST_1) && prevOpcode1 != nextOpcode) {\n+                        if ((prevOpcode1 == ICONST_0 || prevOpcode1 == ICONST_1) && (prevOpcode2 == IFNULL || prevOpcode2 == IFNONNULL)\n+                           && (nextOpcode == ICONST_0 || nextOpcode == ICONST_1) && prevOpcode1 != nextOpcode) {\n                             oneMeansNull = prevOpcode1 == ICONST_0;\n                             if (prevOpcode2 != IFNULL)\n                                 oneMeansNull = !oneMeansNull;\n@@ -1122,8 +1115,8 @@ public class OpcodeStack implements Constants2 {\n                 break;\n             default:\n                 convertJumpToOneZeroState = 0;\n-\n             }\n+\n             switch (seen) {\n             case ICONST_0:\n                 convertJumpToZeroOneState = 1;\n@@ -1148,62 +1141,51 @@ public class OpcodeStack implements Constants2 {\n             case ALOAD:\n                 pushByLocalObjectLoad(dbc, dbc.getRegisterOperand());\n                 break;\n-\n             case ALOAD_0:\n             case ALOAD_1:\n             case ALOAD_2:\n             case ALOAD_3:\n                 pushByLocalObjectLoad(dbc, seen - ALOAD_0);\n                 break;\n-\n             case DLOAD:\n                 pushByLocalLoad(\"D\", dbc.getRegisterOperand());\n                 break;\n-\n             case DLOAD_0:\n             case DLOAD_1:\n             case DLOAD_2:\n             case DLOAD_3:\n                 pushByLocalLoad(\"D\", seen - DLOAD_0);\n                 break;\n-\n             case FLOAD:\n                 pushByLocalLoad(\"F\", dbc.getRegisterOperand());\n                 break;\n-\n             case FLOAD_0:\n             case FLOAD_1:\n             case FLOAD_2:\n             case FLOAD_3:\n                 pushByLocalLoad(\"F\", seen - FLOAD_0);\n                 break;\n-\n             case ILOAD:\n                 pushByLocalLoad(\"I\", dbc.getRegisterOperand());\n                 break;\n-\n             case ILOAD_0:\n             case ILOAD_1:\n             case ILOAD_2:\n             case ILOAD_3:\n                 pushByLocalLoad(\"I\", seen - ILOAD_0);\n                 break;\n-\n             case LLOAD:\n                 pushByLocalLoad(\"J\", dbc.getRegisterOperand());\n                 break;\n-\n             case LLOAD_0:\n             case LLOAD_1:\n             case LLOAD_2:\n             case LLOAD_3:\n                 pushByLocalLoad(\"J\", seen - LLOAD_0);\n                 break;\n-\n             case GETSTATIC: {\n                 FieldSummary fieldSummary = AnalysisContext.currentAnalysisContext().getFieldSummary();\n                 XField fieldOperand = dbc.getXFieldOperand();\n-\n                 if (fieldOperand != null && fieldSummary.isComplete() && !fieldOperand.isPublic()) {\n                     OpcodeStack.Item item = fieldSummary.getSummary(fieldOperand);\n                     if (item != null) {\n@@ -1218,23 +1200,19 @@ public class OpcodeStack implements Constants2 {\n                 if (field.getFieldName().equals(\"separator\") && field.getClassName().equals(\"java.io.File\")) {\n                     i.setSpecialKind(Item.FILE_SEPARATOR_STRING);\n                 }\n-\n                 push(i);\n                 break;\n             }\n-\n             case LDC:\n             case LDC_W:\n             case LDC2_W:\n                 cons = dbc.getConstantRefOperand();\n                 pushByConstant(dbc, cons);\n                 break;\n-\n             case INSTANCEOF:\n                 pop();\n                 push(new Item(\"I\"));\n                 break;\n-\n             case IFNONNULL:\n             case IFNULL:\n                 // {\n@@ -1246,14 +1224,12 @@ public class OpcodeStack implements Constants2 {\n                 //\n                 // break;\n                 // }\n-\n             case IFEQ:\n             case IFNE:\n             case IFLT:\n             case IFLE:\n             case IFGT:\n             case IFGE:\n-\n                 seenTransferOfControl = true;\n                 {\n                     Item topItem = pop();\n@@ -1274,14 +1250,11 @@ public class OpcodeStack implements Constants2 {\n                         for (Item item : lvValues)\n                             if (item != null && item.getSpecialKind() == specialKind)\n                                 item.setSpecialKind(Item.NOT_SPECIAL);\n-\n                     }\n-                }\n+            }\n                 addJumpValue(dbc.getPC(), dbc.getBranchTarget());\n-\n                 break;\n             case LOOKUPSWITCH:\n-\n             case TABLESWITCH:\n                 seenTransferOfControl = true;\n                 setReachOnlyByBranch(true);\n@@ -1290,15 +1263,12 @@ public class OpcodeStack implements Constants2 {\n                 int pc = dbc.getBranchTarget() - dbc.getBranchOffset();\n                 for (int offset : dbc.getSwitchOffsets())\n                     addJumpValue(dbc.getPC(), offset + pc);\n-\n                 break;\n             case ARETURN:\n             case DRETURN:\n             case FRETURN:\n-\n             case IRETURN:\n             case LRETURN:\n-\n                 seenTransferOfControl = true;\n                 setReachOnlyByBranch(true);\n                 pop();\n@@ -1309,7 +1279,6 @@ public class OpcodeStack implements Constants2 {\n             case PUTSTATIC:\n                 pop();\n                 break;\n-\n             case IF_ACMPEQ:\n             case IF_ACMPNE:\n             case IF_ICMPEQ:\n@@ -1317,21 +1286,18 @@ public class OpcodeStack implements Constants2 {\n             case IF_ICMPLT:\n             case IF_ICMPLE:\n             case IF_ICMPGT:\n-            case IF_ICMPGE:\n-\n-            {\n+            case IF_ICMPGE: {\n                 seenTransferOfControl = true;\n                 Item right = pop();\n                 Item left = pop();\n-                \n                 Object lConstant = left.getConstant();\n                 Object rConstant = right.getConstant();\n                 if (lConstant instanceof Integer && rConstant instanceof Integer) {\n                     boolean takeJump = false;\n                     boolean handled = false;\n-                    int lC = ((Integer)lConstant).intValue();\n-                    int rC = ((Integer)rConstant).intValue();\n-                    switch(seen) {\n+                    int lC = ((Integer) lConstant).intValue();\n+                    int rC = ((Integer) rConstant).intValue();\n+                    switch (seen) {\n                     case IF_ICMPEQ:\n                         takeJump = lC == rC;\n                         handled = true;\n@@ -1341,9 +1307,9 @@ public class OpcodeStack implements Constants2 {\n                         handled = true;\n                         break;\n                     case IF_ICMPGE:\n-                    \t takeJump = lC >= rC;\n-                         handled = true;\n-                         break;\n+                        takeJump = lC >= rC;\n+                        handled = true;\n+                        break;\n                     case IF_ICMPGT:\n                         takeJump = lC > rC;\n                         handled = true;\n@@ -1352,10 +1318,10 @@ public class OpcodeStack implements Constants2 {\n                         takeJump = lC <= rC;\n                         handled = true;\n                         break;\n-                   case IF_ICMPLT:\n-                       takeJump = lC < rC;\n-                       handled = true;\n-                       break;\n+                    case IF_ICMPLT:\n+                        takeJump = lC < rC;\n+                        handled = true;\n+                        break;\n                     }\n                     if (handled) {\n                         if (takeJump) {\n@@ -1367,10 +1333,8 @@ public class OpcodeStack implements Constants2 {\n                             break;\n                         }\n                     }\n-                    \n                 }\n-                if (right.hasConstantValue(Integer.MIN_VALUE) && left.mightRarelyBeNegative()\n-                        || left.hasConstantValue(Integer.MIN_VALUE) && right.mightRarelyBeNegative()) {\n+                if (right.hasConstantValue(Integer.MIN_VALUE) && left.mightRarelyBeNegative() || left.hasConstantValue(Integer.MIN_VALUE) && right.mightRarelyBeNegative()) {\n                     for (Item i : stack)\n                         if (i != null && i.mightRarelyBeNegative())\n                             i.setSpecialKind(Item.NOT_SPECIAL);\n@@ -1382,7 +1346,6 @@ public class OpcodeStack implements Constants2 {\n                 addJumpValue(dbc.getPC(), branchTarget);\n                 break;\n             }\n-\n             case POP2:\n                 it = pop();\n                 if (it.getSize() == 1)\n@@ -1391,38 +1354,29 @@ public class OpcodeStack implements Constants2 {\n             case PUTFIELD:\n                 pop(2);\n                 break;\n-\n             case IALOAD:\n             case SALOAD:\n                 pop(2);\n                 push(new Item(\"I\"));\n                 break;\n-\n             case DUP:\n                 handleDup();\n                 break;\n-\n             case DUP2:\n                 handleDup2();\n                 break;\n-\n             case DUP_X1:\n                 handleDupX1();\n                 break;\n-\n             case DUP_X2:\n-\n                 handleDupX2();\n                 break;\n-\n             case DUP2_X1:\n                 handleDup2X1();\n                 break;\n-\n             case DUP2_X2:\n                 handleDup2X2();\n                 break;\n-\n             case IINC:\n                 register = dbc.getRegisterOperand();\n                 it = getLVValue(register);\n@@ -1430,27 +1384,22 @@ public class OpcodeStack implements Constants2 {\n                 pushByIntMath(dbc, IADD, it2, it);\n                 pushByLocalStore(register);\n                 break;\n-\n             case ATHROW:\n                 pop();\n                 seenTransferOfControl = true;\n                 setReachOnlyByBranch(true);\n                 setTop(true);\n                 break;\n-\n             case CHECKCAST: {\n                 String castTo = dbc.getClassConstantOperand();\n-\n                 if (castTo.charAt(0) != '[')\n                     castTo = \"L\" + castTo + \";\";\n                 it = pop();\n-\n                 if (!it.signature.equals(castTo)) {\n                     it = new Item(it, castTo);\n                 }\n                 push(it);\n                 break;\n-\n             }\n             case NOP:\n                 break;\n@@ -1459,7 +1408,6 @@ public class OpcodeStack implements Constants2 {\n                 seenTransferOfControl = true;\n                 setReachOnlyByBranch(true);\n                 break;\n-\n             case GOTO:\n             case GOTO_W:\n                 seenTransferOfControl = true;\n@@ -1467,13 +1415,10 @@ public class OpcodeStack implements Constants2 {\n                 addJumpValue(dbc.getPC(), dbc.getBranchTarget());\n                 stack.clear();\n                 setTop(true);\n-\n                 break;\n-\n             case SWAP:\n                 handleSwap();\n                 break;\n-\n             case ICONST_M1:\n             case ICONST_0:\n             case ICONST_1:\n@@ -1483,27 +1428,22 @@ public class OpcodeStack implements Constants2 {\n             case ICONST_5:\n                 push(new Item(\"I\", (seen - ICONST_0)));\n                 break;\n-\n             case LCONST_0:\n             case LCONST_1:\n                 push(new Item(\"J\", Long.valueOf(seen - LCONST_0)));\n                 break;\n-\n             case DCONST_0:\n             case DCONST_1:\n                 push(new Item(\"D\", Double.valueOf(seen - DCONST_0)));\n                 break;\n-\n             case FCONST_0:\n             case FCONST_1:\n             case FCONST_2:\n                 push(new Item(\"F\", Float.valueOf(seen - FCONST_0)));\n                 break;\n-\n             case ACONST_NULL:\n                 push(new Item());\n                 break;\n-\n             case ASTORE:\n             case DSTORE:\n             case FSTORE:\n@@ -1511,42 +1451,36 @@ public class OpcodeStack implements Constants2 {\n             case LSTORE:\n                 pushByLocalStore(dbc.getRegisterOperand());\n                 break;\n-\n             case ASTORE_0:\n             case ASTORE_1:\n             case ASTORE_2:\n             case ASTORE_3:\n                 pushByLocalStore(seen - ASTORE_0);\n                 break;\n-\n             case DSTORE_0:\n             case DSTORE_1:\n             case DSTORE_2:\n             case DSTORE_3:\n                 pushByLocalStore(seen - DSTORE_0);\n                 break;\n-\n             case FSTORE_0:\n             case FSTORE_1:\n             case FSTORE_2:\n             case FSTORE_3:\n                 pushByLocalStore(seen - FSTORE_0);\n                 break;\n-\n             case ISTORE_0:\n             case ISTORE_1:\n             case ISTORE_2:\n             case ISTORE_3:\n                 pushByLocalStore(seen - ISTORE_0);\n                 break;\n-\n             case LSTORE_0:\n             case LSTORE_1:\n             case LSTORE_2:\n             case LSTORE_3:\n                 pushByLocalStore(seen - LSTORE_0);\n                 break;\n-\n             case GETFIELD: {\n                 FieldSummary fieldSummary = AnalysisContext.currentAnalysisContext().getFieldSummary();\n                 XField fieldOperand = dbc.getXFieldOperand();\n@@ -1563,18 +1497,15 @@ public class OpcodeStack implements Constants2 {\n                 Item item = pop();\n                 int reg = item.getRegisterNumber();\n                 push(new Item(dbc.getSigConstantOperand(), FieldAnnotation.fromReferencedField(dbc), reg));\n-\n             }\n-                break;\n-\n+                           break;\n             case ARRAYLENGTH: {\n                 pop();\n                 Item newItem = new Item(\"I\");\n                 newItem.setSpecialKind(Item.NON_NEGATIVE);\n                 push(newItem);\n             }\n-                break;\n-\n+                              break;\n             case BALOAD: {\n                 pop(2);\n                 Item newItem = new Item(\"I\");\n@@ -1586,22 +1517,18 @@ public class OpcodeStack implements Constants2 {\n                 pop(2);\n                 push(new Item(\"I\"));\n                 break;\n-\n             case DALOAD:\n                 pop(2);\n                 push(new Item(\"D\"));\n                 break;\n-\n             case FALOAD:\n                 pop(2);\n                 push(new Item(\"F\"));\n                 break;\n-\n             case LALOAD:\n                 pop(2);\n                 push(new Item(\"J\"));\n                 break;\n-\n             case AASTORE:\n             case BASTORE:\n             case CASTORE:\n@@ -1612,12 +1539,10 @@ public class OpcodeStack implements Constants2 {\n             case SASTORE:\n                 pop(3);\n                 break;\n-\n             case BIPUSH:\n             case SIPUSH:\n                 push(new Item(\"I\", Integer.valueOf(dbc.getIntConstant())));\n                 break;\n-\n             case IADD:\n             case ISUB:\n             case IMUL:\n@@ -1633,7 +1558,6 @@ public class OpcodeStack implements Constants2 {\n                 it2 = pop();\n                 pushByIntMath(dbc, seen, it2, it);\n                 break;\n-\n             case INEG:\n                 it = pop();\n                 if (it.getConstant() instanceof Integer) {\n@@ -1642,7 +1566,6 @@ public class OpcodeStack implements Constants2 {\n                     push(new Item(\"I\"));\n                 }\n                 break;\n-\n             case LNEG:\n                 it = pop();\n                 if (it.getConstant() instanceof Long) {\n@@ -1667,7 +1590,6 @@ public class OpcodeStack implements Constants2 {\n                     push(new Item(\"D\"));\n                 }\n                 break;\n-\n             case LADD:\n             case LSUB:\n             case LMUL:\n@@ -1679,26 +1601,21 @@ public class OpcodeStack implements Constants2 {\n             case LSHR:\n             case LREM:\n             case LUSHR:\n-\n                 it = pop();\n                 it2 = pop();\n                 pushByLongMath(seen, it2, it);\n                 break;\n-\n             case LCMP:\n                 handleLcmp();\n                 break;\n-\n             case FCMPG:\n             case FCMPL:\n                 handleFcmp(seen);\n                 break;\n-\n             case DCMPG:\n             case DCMPL:\n                 handleDcmp(seen);\n                 break;\n-\n             case FADD:\n             case FSUB:\n             case FMUL:\n@@ -1708,7 +1625,6 @@ public class OpcodeStack implements Constants2 {\n                 it2 = pop();\n                 pushByFloatMath(seen, it, it2);\n                 break;\n-\n             case DADD:\n             case DSUB:\n             case DMUL:\n@@ -1718,57 +1634,42 @@ public class OpcodeStack implements Constants2 {\n                 it2 = pop();\n                 pushByDoubleMath(seen, it, it2);\n                 break;\n-\n             case I2B: {\n                 it = pop();\n                 Item newValue = new Item(it, \"B\");\n-\n                 push(newValue);\n             }\n-                break;\n-\n-\n-\n+                      break;\n             case I2C: {\n                 it = pop();\n                 Item newValue = new Item(it, \"C\");\n-\n                 push(newValue);\n             }\n-                break;\n-\n+                      break;\n             case I2L:\n             case D2L:\n             case F2L: {\n                 it = pop();\n                 Item newValue = new Item(it, \"J\");\n-\n                 int specialKind = it.getSpecialKind();\n-\n                 if (specialKind != Item.SIGNED_BYTE && seen == I2L)\n                     newValue.setSpecialKind(Item.RESULT_OF_I2L);\n-\n                 push(newValue);\n             }\n-            break;\n-\n+                      break;\n             case I2S:\n                 changeSignatureOfTopElement(\"S\");\n                 break;\n-\n             case L2I:\n             case D2I:\n             case F2I:\n                 it = pop();\n                 int oldSpecialKind = it.getSpecialKind();\n                 it = new Item(it, \"I\");\n-\n                 if (oldSpecialKind == Item.NOT_SPECIAL)\n                     it.setSpecialKind(Item.RESULT_OF_L2I);\n                 push(it);\n-\n                 break;\n-\n             case L2F:\n             case D2F:\n             case I2F:\n@@ -1779,7 +1680,6 @@ public class OpcodeStack implements Constants2 {\n                     push(new Item(\"F\"));\n                 }\n                 break;\n-\n             case F2D:\n             case I2D:\n             case L2D:\n@@ -1790,14 +1690,12 @@ public class OpcodeStack implements Constants2 {\n                     push(new Item(\"D\"));\n                 }\n                 break;\n-\n             case NEW: {\n                 Item item = new Item(\"L\" + dbc.getClassConstantOperand() + \";\", (Object) null);\n                 item.setSpecialKind(Item.NEWLY_ALLOCATED);\n                 push(item);\n             }\n-                break;\n-\n+                      break;\n             case NEWARRAY:\n                 pop();\n                 signature = \"[\" + BasicType.getType((byte) dbc.getIntConstant()).getSignature();\n@@ -1808,7 +1706,6 @@ public class OpcodeStack implements Constants2 {\n             // can refer to normal class/interface types (encoded in\n             // \"internal form\"), or array classes (encoded as signatures\n             // beginning with \"[\").\n-\n             case ANEWARRAY:\n                 pop();\n                 signature = dbc.getClassConstantOperand();\n@@ -1818,16 +1715,13 @@ public class OpcodeStack implements Constants2 {\n                     signature = \"[L\" + signature + \";\";\n                 pushBySignature(signature, dbc);\n                 break;\n-\n             case MULTIANEWARRAY:\n                 int dims = dbc.getIntConstant();\n                 for (int i = 0; i < dims; i++)\n                     pop();\n-\n                 signature = dbc.getClassConstantOperand();\n                 pushBySignature(signature, dbc);\n                 break;\n-\n             case AALOAD: {\n                 pop();\n                 it = pop();\n@@ -1837,8 +1731,7 @@ public class OpcodeStack implements Constants2 {\n                 else\n                     push(new Item());\n             }\n-                break;\n-\n+                         break;\n             case JSR:\n                 seenTransferOfControl = true;\n                 setReachOnlyByBranch(false);\n@@ -1854,29 +1747,23 @@ public class OpcodeStack implements Constants2 {\n                 }\n                 setTop(false);\n                 break;\n-\n             case INVOKEINTERFACE:\n             case INVOKESPECIAL:\n             case INVOKESTATIC:\n             case INVOKEVIRTUAL:\n                 processMethodCall(dbc, seen);\n                 break;\n-\n             default:\n                 throw new UnsupportedOperationException(\"OpCode \" + OPCODE_NAMES[seen] + \" not supported \");\n             }\n-        }\n-\n-        catch (RuntimeException e) {\n+        } catch (RuntimeException e) {\n             // If an error occurs, we clear the stack and locals. one of two\n             // things will occur.\n             // Either the client will expect more stack items than really exist,\n             // and so they're condition check will fail,\n             // or the stack will resync with the code. But hopefully not false\n             // positives\n-\n-            String msg = \"Error processing opcode \" + OPCODE_NAMES[seen] + \" @ \" + dbc.getPC() + \" in \"\n-                    + dbc.getFullyQualifiedMethodName();\n+            String msg = \"Error processing opcode \" + OPCODE_NAMES[seen] + \" @ \" + dbc.getPC() + \" in \" + dbc.getFullyQualifiedMethodName();\n             AnalysisContext.logError(msg, e);\n             if (DEBUG)\n                 e.printStackTrace();\n@@ -1892,12 +1779,13 @@ public class OpcodeStack implements Constants2 {\n     /**\n      *\n      */\n+\n+\n     private void changeSignatureOfTopElement(String newSignature) {\n         {\n-            Item item = pop();\n-            Item newValue = new Item(item, newSignature);\n-\n-            push(newValue);\n+        Item item = pop();\n+        Item newValue = new Item(item, newSignature);\n+        push(newValue);\n         }\n     }\n \n@@ -1908,6 +1796,7 @@ public class OpcodeStack implements Constants2 {\n                 if (item != null && item.registerNumber == registerTestedFoundToBeNonnegative)\n                     stack.set(i, item.cloneAndSetSpecialKind(Item.NON_NEGATIVE));\n             }\n+\n             for (int i = 0; i < lvValues.size(); i++) {\n                 Item item = lvValues.get(i);\n                 if (item != null && item.registerNumber == registerTestedFoundToBeNonnegative)\n@@ -1922,6 +1811,8 @@ public class OpcodeStack implements Constants2 {\n      * @param it\n      * @return\n      */\n+\n+\n     private int constantToInt(Item it) {\n         Object constant = it.getConstant();\n         if (constant instanceof Number) {\n@@ -1937,6 +1828,8 @@ public class OpcodeStack implements Constants2 {\n      * @param it\n      * @return\n      */\n+\n+\n     private float constantToFloat(Item it) {\n         return ((Number) it.getConstant()).floatValue();\n     }\n@@ -1945,6 +1838,8 @@ public class OpcodeStack implements Constants2 {\n      * @param it\n      * @return\n      */\n+\n+\n     private double constantToDouble(Item it) {\n         return ((Number) it.getConstant()).doubleValue();\n     }\n@@ -1953,6 +1848,8 @@ public class OpcodeStack implements Constants2 {\n      * @param it\n      * @return\n      */\n+\n+\n     private long constantToLong(Item it) {\n         return ((Number) it.getConstant()).longValue();\n     }\n@@ -1961,10 +1858,11 @@ public class OpcodeStack implements Constants2 {\n      * handle dcmp\n      *\n      */\n+\n+\n     private void handleDcmp(int opcode) {\n         Item it = pop();\n         Item it2 = pop();\n-\n         if ((it.getConstant() != null) && it2.getConstant() != null) {\n             double d = constantToDouble(it);\n             double d2 = constantToDouble(it2);\n@@ -1989,6 +1887,8 @@ public class OpcodeStack implements Constants2 {\n      * handle fcmp\n      *\n      */\n+\n+\n     private void handleFcmp(int opcode) {\n         Item it = pop();\n         Item it2 = pop();\n@@ -2015,10 +1915,11 @@ public class OpcodeStack implements Constants2 {\n     /**\n      * handle lcmp\n      */\n+\n+\n     private void handleLcmp() {\n         Item it = pop();\n         Item it2 = pop();\n-\n         if ((it.getConstant() != null) && it2.getConstant() != null) {\n             long l = constantToLong(it);\n             long l2 = constantToLong(it2);\n@@ -2031,12 +1932,13 @@ public class OpcodeStack implements Constants2 {\n         } else {\n             push(new Item(\"I\"));\n         }\n-\n     }\n \n     /**\n      * handle swap\n      */\n+\n+\n     private void handleSwap() {\n         Item i1 = pop();\n         Item i2 = pop();\n@@ -2047,6 +1949,8 @@ public class OpcodeStack implements Constants2 {\n     /**\n      * handleDup\n      */\n+\n+\n     private void handleDup() {\n         Item it;\n         it = pop();\n@@ -2057,6 +1961,8 @@ public class OpcodeStack implements Constants2 {\n     /**\n      * handle dupX1\n      */\n+\n+\n     private void handleDupX1() {\n         Item it;\n         Item it2;\n@@ -2070,6 +1976,8 @@ public class OpcodeStack implements Constants2 {\n     /**\n      * handle dup2\n      */\n+\n+\n     private void handleDup2() {\n         Item it, it2;\n         it = pop();\n@@ -2088,14 +1996,14 @@ public class OpcodeStack implements Constants2 {\n     /**\n      * handle Dup2x1\n      */\n+\n+\n     private void handleDup2X1() {\n         String signature;\n         Item it;\n         Item it2;\n         Item it3;\n-\n         it = pop();\n-\n         it2 = pop();\n         signature = it.getSignature();\n         if (signature.equals(\"J\") || signature.equals(\"D\")) {\n@@ -2112,10 +2020,10 @@ public class OpcodeStack implements Constants2 {\n         }\n     }\n \n+\n     private void handleDup2X2() {\n         Item it = pop();\n         Item it2 = pop();\n-\n         if (it.isWide()) {\n             if (it2.isWide()) {\n                 push(it);\n@@ -2151,6 +2059,8 @@ public class OpcodeStack implements Constants2 {\n     /**\n      * Handle DupX2\n      */\n+\n+\n     private void handleDupX2() {\n         String signature;\n         Item it;\n@@ -2183,17 +2093,16 @@ public class OpcodeStack implements Constants2 {\n             } catch (Exception e) {\n                 throw new AssertionError(e);\n             }\n-\n         }\n     }\n \n     static {\n-        addBoxedType(Integer.class, Long.class, Double.class, Short.class, Float.class, Boolean.class, Character.class,\n-                Byte.class);\n+        addBoxedType(Integer.class, Long.class, Double.class, Short.class, Float.class, Boolean.class, Character.class, Byte.class);\n     }\n \n     private void processMethodCall(DismantleBytecode dbc, int seen) {\n-        @SlashedClassName String clsName = dbc.getClassConstantOperand();\n+        @SlashedClassName\n+        String clsName = dbc.getClassConstantOperand();\n         String methodName = dbc.getNameConstantOperand();\n         String signature = dbc.getSigConstantOperand();\n         String appenderValue = null;\n@@ -2203,13 +2112,8 @@ public class OpcodeStack implements Constants2 {\n         Item topItem = null;\n         if (getStackDepth() > 0)\n             topItem = getStackItem(0);\n-\n         int numberArguments = PreorderVisitor.getNumberArguments(signature);\n-\n-        if (boxedTypes.containsKey(clsName)\n-                && topItem != null\n-                && (methodName.equals(\"valueOf\") && !signature.contains(\"String\") || methodName.equals(boxedTypes.get(clsName)\n-                        + \"Value\"))) {\n+        if (boxedTypes.containsKey(clsName) && topItem != null && (methodName.equals(\"valueOf\") && !signature.contains(\"String\") || methodName.equals(boxedTypes.get(clsName) + \"Value\"))) {\n             // boxing/unboxing conversion\n             Item value = pop();\n             String newSignature = Type.getReturnType(signature).getSignature();\n@@ -2225,7 +2129,6 @@ public class OpcodeStack implements Constants2 {\n             push(newValue);\n             return;\n         }\n-\n         int firstArgument = seen == INVOKESTATIC ? 0 : 1;\n         for (int i = firstArgument; i < firstArgument + numberArguments; i++) {\n             if (i >= getStackDepth())\n@@ -2236,9 +2139,10 @@ public class OpcodeStack implements Constants2 {\n                 item.constValue = null;\n         }\n         boolean initializingServletWriter = false;\n-        if (seen == INVOKESPECIAL && methodName.equals(\"<init>\") && clsName.startsWith(\"java/io\") && clsName.endsWith(\"Writer\")\n-                && numberArguments > 0) {\n-            Item firstArg = getStackItem(numberArguments-1);\n+        if (seen == INVOKESPECIAL && methodName.equals(\"<init>\")\n+        && clsName.startsWith(\"java/io\")\n+           && clsName.endsWith(\"Writer\") && numberArguments > 0) {\n+            Item firstArg = getStackItem(numberArguments - 1);\n             if (firstArg.isServletWriter())\n                 initializingServletWriter = true;\n         }\n@@ -2265,34 +2169,35 @@ public class OpcodeStack implements Constants2 {\n                 if (i.isServletParameterTainted())\n                     servletRequestParameterTainted = true;\n             } else if (\"append\".equals(methodName)) {\n-                if (signature.indexOf(\"II)\") == -1 && getStackDepth() >= 2) {\n-                    sbItem = getStackItem(1);\n-                    Item i = getStackItem(0);\n-                    if (i.isServletParameterTainted() || sbItem.isServletParameterTainted())\n-                        servletRequestParameterTainted = true;\n-                    Object sbVal = sbItem.getConstant();\n-                    Object sVal = i.getConstant();\n-                    if ((sbVal != null) && (sVal != null)) {\n-                        appenderValue = sbVal + sVal.toString();\n-                    } else if (sbItem.registerNumber >= 0) {\n-                        OpcodeStack.Item item = getLVValue(sbItem.registerNumber);\n-                        if (item != null)\n-                            item.constValue = null;\n-                    }\n-                } else if (signature.startsWith(\"([CII)\")) {\n-                    sawUnknownAppend = true;\n-                    sbItem = getStackItem(3);\n-                    if (sbItem.registerNumber >= 0) {\n-                        OpcodeStack.Item item = getLVValue(sbItem.registerNumber);\n-                        if (item != null)\n-                            item.constValue = null;\n-                    }\n-                } else {\n-                    sawUnknownAppend = true;\n-                }\n-            }\n-        } else if (seen == INVOKESPECIAL && clsName.equals(\"java/io/FileOutputStream\") && methodName.equals(\"<init>\")\n-                && (signature.equals(\"(Ljava/io/File;Z)V\") || signature.equals(\"(Ljava/lang/String;Z)V\")) && stack.size() > 3) {\n+                       if (signature.indexOf(\"II)\") == -1 && getStackDepth() >= 2) {\n+                           sbItem = getStackItem(1);\n+                           Item i = getStackItem(0);\n+                           if (i.isServletParameterTainted() || sbItem.isServletParameterTainted())\n+                               servletRequestParameterTainted = true;\n+                           Object sbVal = sbItem.getConstant();\n+                           Object sVal = i.getConstant();\n+                           if ((sbVal != null) && (sVal != null)) {\n+                               appenderValue = sbVal + sVal.toString();\n+                           } else if (sbItem.registerNumber >= 0) {\n+                               OpcodeStack.Item item = getLVValue(sbItem.registerNumber);\n+                               if (item != null)\n+                                   item.constValue = null;\n+                           }\n+                       } else if (signature.startsWith(\"([CII)\")) {\n+                           sawUnknownAppend = true;\n+                           sbItem = getStackItem(3);\n+                           if (sbItem.registerNumber >= 0) {\n+                               OpcodeStack.Item item = getLVValue(sbItem.registerNumber);\n+                               if (item != null)\n+                                   item.constValue = null;\n+                           }\n+                       } else {\n+                           sawUnknownAppend = true;\n+                       }\n+                   }\n+        } else if (seen == INVOKESPECIAL && clsName.equals(\"java/io/FileOutputStream\")\n+        && methodName.equals(\"<init>\")\n+                  && (signature.equals(\"(Ljava/io/File;Z)V\") || signature.equals(\"(Ljava/lang/String;Z)V\")) && stack.size() > 3) {\n             OpcodeStack.Item item = getStackItem(0);\n             Object value = item.getConstant();\n             if (value instanceof Integer && ((Integer) value).intValue() == 1) {\n@@ -2305,74 +2210,65 @@ public class OpcodeStack implements Constants2 {\n                 }\n                 return;\n             }\n-        } else if (seen == INVOKESPECIAL && clsName.equals(\"java/io/BufferedOutputStream\") && methodName.equals(\"<init>\")\n-                && signature.equals(\"(Ljava/io/OutputStream;)V\")) {\n-\n-            if (getStackItem(0).getSpecialKind() == Item.FILE_OPENED_IN_APPEND_MODE\n-                    && getStackItem(2).signature.equals(\"Ljava/io/BufferedOutputStream;\")) {\n-\n-                pop(2);\n-                Item newTop = getStackItem(0);\n-                newTop.setSpecialKind(Item.FILE_OPENED_IN_APPEND_MODE);\n-                newTop.source = XFactory.createReferencedXMethod(dbc);\n-                newTop.setPC(dbc.getPC());\n-                return;\n-            }\n-        } else if (seen == INVOKEINTERFACE && methodName.equals(\"getParameter\")\n-                && clsName.equals(\"javax/servlet/http/HttpServletRequest\") || clsName.equals(\"javax/servlet/http/ServletRequest\")) {\n-            Item requestParameter = pop();\n-            pop();\n-            Item result = new Item(\"Ljava/lang/String;\");\n-            result.setServletParameterTainted();\n-            result.source = XFactory.createReferencedXMethod(dbc);\n-            String parameterName = null;\n-            if (requestParameter.getConstant() instanceof String)\n-                parameterName = (String) requestParameter.getConstant();\n-\n-            result.injection = new HttpParameterInjection(parameterName, dbc.getPC());\n-            result.setPC(dbc.getPC());\n-            push(result);\n-            return;\n-        } else if (seen == INVOKEINTERFACE && methodName.equals(\"getQueryString\")\n-                && clsName.equals(\"javax/servlet/http/HttpServletRequest\") || clsName.equals(\"javax/servlet/http/ServletRequest\")) {\n-            pop();\n-            Item result = new Item(\"Ljava/lang/String;\");\n-            result.setServletParameterTainted();\n-            result.source = XFactory.createReferencedXMethod(dbc);\n-            result.setPC(dbc.getPC());\n-            push(result);\n-            return;\n-        } else if (seen == INVOKEINTERFACE && methodName.equals(\"getHeader\")\n-                && clsName.equals(\"javax/servlet/http/HttpServletRequest\") || clsName.equals(\"javax/servlet/http/ServletRequest\")) {\n-            /* Item requestParameter = */pop();\n-            pop();\n-            Item result = new Item(\"Ljava/lang/String;\");\n-            result.setServletParameterTainted();\n-            result.source = XFactory.createReferencedXMethod(dbc);\n-            result.setPC(dbc.getPC());\n-            push(result);\n-            return;\n-        } else if (seen == INVOKESTATIC && methodName.equals(\"asList\") && clsName.equals(\"java/util/Arrays\")) {\n-            /* Item requestParameter = */pop();\n-            Item result = new Item(JAVA_UTIL_ARRAYS_ARRAY_LIST);\n-            push(result);\n-            return;\n-        } else if (seen == INVOKESTATIC && signature.equals(\"(Ljava/util/List;)Ljava/util/List;\")\n-                && clsName.equals(\"java/util/Collections\")) {\n-            Item requestParameter = pop();\n-            if (requestParameter.getSignature().equals(JAVA_UTIL_ARRAYS_ARRAY_LIST)) {\n-                Item result = new Item(JAVA_UTIL_ARRAYS_ARRAY_LIST);\n-                push(result);\n-                return;\n-            }\n-            push(requestParameter); // fall back to standard logic\n-        }\n-\n+        } else if (seen == INVOKESPECIAL && clsName.equals(\"java/io/BufferedOutputStream\")\n+                  && methodName.equals(\"<init>\") && signature.equals(\"(Ljava/io/OutputStream;)V\")) {\n+                   if (getStackItem(0).getSpecialKind() == Item.FILE_OPENED_IN_APPEND_MODE && getStackItem(2).signature.equals(\"Ljava/io/BufferedOutputStream;\")) {\n+                       pop(2);\n+                       Item newTop = getStackItem(0);\n+                       newTop.setSpecialKind(Item.FILE_OPENED_IN_APPEND_MODE);\n+                       newTop.source = XFactory.createReferencedXMethod(dbc);\n+                       newTop.setPC(dbc.getPC());\n+                       return;\n+                   }\n+               } else if (seen == INVOKEINTERFACE && methodName.equals(\"getParameter\") && clsName.equals(\"javax/servlet/http/HttpServletRequest\") || clsName.equals(\"javax/servlet/http/ServletRequest\")) {\n+                   Item requestParameter = pop();\n+                   pop();\n+                   Item result = new Item(\"Ljava/lang/String;\");\n+                   result.setServletParameterTainted();\n+                   result.source = XFactory.createReferencedXMethod(dbc);\n+                   String parameterName = null;\n+                   if (requestParameter.getConstant() instanceof String)\n+                       parameterName = (String) requestParameter.getConstant();\n+                   result.injection = new HttpParameterInjection(parameterName, dbc.getPC());\n+                   result.setPC(dbc.getPC());\n+                   push(result);\n+                   return;\n+               } else if (seen == INVOKEINTERFACE && methodName.equals(\"getQueryString\") && clsName.equals(\"javax/servlet/http/HttpServletRequest\") || clsName.equals(\"javax/servlet/http/ServletRequest\")) {\n+                          pop();\n+                          Item result = new Item(\"Ljava/lang/String;\");\n+                          result.setServletParameterTainted();\n+                          result.source = XFactory.createReferencedXMethod(dbc);\n+                          result.setPC(dbc.getPC());\n+                          push(result);\n+                          return;\n+                      } else if (seen == INVOKEINTERFACE && methodName.equals(\"getHeader\") && clsName.equals(\"javax/servlet/http/HttpServletRequest\") || clsName.equals(\"javax/servlet/http/ServletRequest\")) {\n+            /* Item requestParameter = */\n+                          pop();\n+                          pop();\n+                          Item result = new Item(\"Ljava/lang/String;\");\n+                          result.setServletParameterTainted();\n+                          result.source = XFactory.createReferencedXMethod(dbc);\n+                          result.setPC(dbc.getPC());\n+                          push(result);\n+                          return;\n+                      } else if (seen == INVOKESTATIC && methodName.equals(\"asList\") && clsName.equals(\"java/util/Arrays\")) {\n+            /* Item requestParameter = */\n+                                 pop();\n+                                 Item result = new Item(JAVA_UTIL_ARRAYS_ARRAY_LIST);\n+                                 push(result);\n+                                 return;\n+                             } else if (seen == INVOKESTATIC && signature.equals(\"(Ljava/util/List;)Ljava/util/List;\") && clsName.equals(\"java/util/Collections\")) {\n+                                 Item requestParameter = pop();\n+                                 if (requestParameter.getSignature().equals(JAVA_UTIL_ARRAYS_ARRAY_LIST)) {\n+                                     Item result = new Item(JAVA_UTIL_ARRAYS_ARRAY_LIST);\n+                                     push(result);\n+                                     return;\n+                                 }\n+                                 push(requestParameter); // fall back to standard logic\n+                             }\n         pushByInvoke(dbc, seen != INVOKESTATIC);\n-\n         if (initializingServletWriter)\n             this.getStackItem(0).setIsServletWriter();\n-\n         if ((sawUnknownAppend || appenderValue != null || servletRequestParameterTainted) && getStackDepth() > 0) {\n             Item i = this.getStackItem(0);\n             i.constValue = appenderValue;\n@@ -2390,50 +2286,44 @@ public class OpcodeStack implements Constants2 {\n             }\n             return;\n         }\n-\n-        if ((clsName.equals(\"java/util/Random\") || clsName.equals(\"java/security/SecureRandom\")) && methodName.equals(\"nextInt\")\n-                && signature.equals(\"()I\")) {\n+        if ((clsName.equals(\"java/util/Random\") || clsName.equals(\"java/security/SecureRandom\")) && methodName.equals(\"nextInt\") && signature.equals(\"()I\")) {\n             Item i = pop();\n             i.setSpecialKind(Item.RANDOM_INT);\n             push(i);\n-        } else if (methodName.equals(\"size\") && signature.equals(\"()I\") \n-                && Subtypes2.instanceOf(ClassName.toDottedClassName(clsName), \"java.util.Collection\")) {\n+        } else if (methodName.equals(\"size\") && signature.equals(\"()I\") && Subtypes2.instanceOf(ClassName.toDottedClassName(clsName), \"java.util.Collection\")) {\n             Item i = pop();\n             if (i.getSpecialKind() == Item.NOT_SPECIAL)\n-                    i.setSpecialKind(Item.NON_NEGATIVE);\n+                i.setSpecialKind(Item.NON_NEGATIVE);\n             push(i);\n         } else if (ClassName.isMathClass(clsName) && methodName.equals(\"abs\")) {\n-            Item i = pop();\n-            if (i.getSpecialKind() == Item.HASHCODE_INT)\n-                i.setSpecialKind(Item.MATH_ABS_OF_HASHCODE);\n-            else if (i.getSpecialKind() == Item.RANDOM_INT)\n-                i.setSpecialKind(Item.MATH_ABS_OF_RANDOM);\n-            else\n-                i.setSpecialKind(Item.MATH_ABS);\n-            push(i);\n-        } else if (seen == INVOKEVIRTUAL && methodName.equals(\"hashCode\") && signature.equals(\"()I\") || seen == INVOKESTATIC\n-                && clsName.equals(\"java/lang/System\") && methodName.equals(\"identityHashCode\")\n-                && signature.equals(\"(Ljava/lang/Object;)I\")) {\n-            Item i = pop();\n-            i.setSpecialKind(Item.HASHCODE_INT);\n-            push(i);\n-        } else if (topIsTainted\n-                && (methodName.startsWith(\"encode\") && clsName.equals(\"javax/servlet/http/HttpServletResponse\") || methodName\n-                        .equals(\"trim\") && clsName.equals(\"java/lang/String\"))) {\n-            Item i = pop();\n-            i.setSpecialKind(Item.SERVLET_REQUEST_TAINTED);\n-            i.injection = injection;\n-            push(i);\n-        }\n-\n+                   Item i = pop();\n+                   if (i.getSpecialKind() == Item.HASHCODE_INT)\n+                       i.setSpecialKind(Item.MATH_ABS_OF_HASHCODE);\n+                   else if (i.getSpecialKind() == Item.RANDOM_INT)\n+                       i.setSpecialKind(Item.MATH_ABS_OF_RANDOM);\n+                   else\n+                       i.setSpecialKind(Item.MATH_ABS);\n+                   push(i);\n+               } else if (seen == INVOKEVIRTUAL && methodName.equals(\"hashCode\") && signature.equals(\"()I\") || seen == INVOKESTATIC && clsName.equals(\"java/lang/System\")\n+               && methodName.equals(\"identityHashCode\")\n+               && signature.equals(\"(Ljava/lang/Object;)I\")) {\n+                   Item i = pop();\n+                   i.setSpecialKind(Item.HASHCODE_INT);\n+                   push(i);\n+               } else if (topIsTainted && (methodName.startsWith(\"encode\") && clsName.equals(\"javax/servlet/http/HttpServletResponse\") || methodName.equals(\"trim\") && clsName.equals(\"java/lang/String\"))) {\n+                          Item i = pop();\n+                          i.setSpecialKind(Item.SERVLET_REQUEST_TAINTED);\n+                          i.injection = injection;\n+                          push(i);\n+                      }\n         if (!signature.endsWith(\")V\")) {\n             Item i = pop();\n             i.source = XFactory.createReferencedXMethod(dbc);\n             push(i);\n         }\n-\n     }\n \n+\n     private void mergeLists(List<Item> mergeInto, List<Item> mergeFrom, boolean errorIfSizesDoNotMatch) {\n         // merge stacks\n         int intoSize = mergeInto.size();\n@@ -2480,6 +2370,7 @@ public class OpcodeStack implements Constants2 {\n     private BitSet jumpEntryLocations = new BitSet();\n \n     public static class JumpInfo {\n+\n         final Map<Integer, List<Item>> jumpEntries;\n \n         final Map<Integer, List<Item>> jumpStackEntries;\n@@ -2492,6 +2383,7 @@ public class OpcodeStack implements Constants2 {\n             this.jumpEntryLocations = jumpEntryLocations;\n         }\n \n+\n         public int getNextJump(int pc) {\n             return jumpEntryLocations.nextSetBit(pc);\n         }\n@@ -2503,22 +2395,21 @@ public class OpcodeStack implements Constants2 {\n             super(\"Jump info for opcode stack\", JumpInfo.class);\n         }\n \n+\n         public JumpInfo analyze(IAnalysisCache analysisCache, MethodDescriptor descriptor) throws CheckedAnalysisException {\n             Method method = analysisCache.getMethodAnalysis(Method.class, descriptor);\n             JavaClass jclass = getJavaClass(analysisCache, descriptor.getClassDescriptor());\n-\n             Code code = method.getCode();\n             if (code == null) {\n                 return null;\n             }\n             final OpcodeStack stack = new OpcodeStack();\n-\n             DismantleBytecode branchAnalysis = new DismantleBytecode() {\n-                @Override\n-                public void sawOpcode(int seen) {\n-                    stack.sawOpcode(this, seen);\n-                }\n-            };\n+                                  @Override\n+                                  public void sawOpcode(int seen) {\n+                                      stack.sawOpcode(this, seen);\n+                                  }\n+                              };\n             return computeJumpInfo(jclass, method, stack, branchAnalysis);\n         }\n \n@@ -2529,8 +2420,8 @@ public class OpcodeStack implements Constants2 {\n          * @param branchAnalysis\n          * @return\n          */\n-        public static JumpInfo computeJumpInfo(JavaClass jclass, Method method, final OpcodeStack stack,\n-                DismantleBytecode branchAnalysis) {\n+\n+        public static JumpInfo computeJumpInfo(JavaClass jclass, Method method, final OpcodeStack stack, DismantleBytecode branchAnalysis) {\n             branchAnalysis.setupVisitorForClass(jclass);\n             MethodInfo xMethod = (MethodInfo) XFactory.createXMethod(jclass, method);\n             int oldCount = 0;\n@@ -2539,15 +2430,15 @@ public class OpcodeStack implements Constants2 {\n                 branchAnalysis.doVisitMethod(method);\n                 int newCount = stack.jumpEntries.size();\n                 if (xMethod.hasBackBranch() != stack.backwardsBranch) {\n-                    AnalysisContext.logError(\n-                            String.format(\"For %s, mismatch on existing of backedge: %s for precomputation, %s for bytecode analysis\",\n-                                    xMethod, xMethod.hasBackBranch(), stack.backwardsBranch));\n+                    AnalysisContext.logError(String.format(\"For %s, mismatch on existing of backedge: %s for precomputation, %s for bytecode analysis\",\n+xMethod,\n+xMethod.hasBackBranch(),\n+stack.backwardsBranch));\n                 }\n                 if (newCount == oldCount || !stack.encountedTop || !stack.backwardsBranch)\n                     break;\n                 oldCount = newCount;\n             }\n-\n             return new JumpInfo(stack.jumpEntries, stack.jumpStackEntries, stack.jumpEntryLocations);\n         }\n     }\n@@ -2556,17 +2447,16 @@ public class OpcodeStack implements Constants2 {\n         return jumpEntryLocations.get(pc);\n     }\n \n+\n     private void addJumpValue(int from, int target) {\n         if (DEBUG)\n             System.out.println(\"Set jump entry at \" + methodName + \":\" + target + \"pc to \" + stack + \" : \" + lvValues);\n-\n         if (from >= target)\n             backwardsBranch = true;\n         List<Item> atTarget = jumpEntries.get(Integer.valueOf(target));\n         if (atTarget == null) {\n             if (DEBUG)\n                 System.out.println(\"Was null\");\n-\n             jumpEntries.put(Integer.valueOf(target), new ArrayList<Item>(lvValues));\n             jumpEntryLocations.set(target);\n             if (stack.size() > 0) {\n@@ -2582,6 +2472,7 @@ public class OpcodeStack implements Constants2 {\n             System.out.println(\"merge target for \" + methodName + \":\" + target + \"pc is \" + atTarget);\n     }\n \n+\n     private String methodName;\n \n     DismantleBytecode v;\n@@ -2609,30 +2500,25 @@ public class OpcodeStack implements Constants2 {\n     public int resetForMethodEntry(final DismantleBytecode visitor) {\n         this.v = visitor;\n         initialize();\n-\n         int result = resetForMethodEntry0(v);\n         Code code = v.getMethod().getCode();\n         if (code == null)\n             return result;\n-\n         if (useIterativeAnalysis) {\n             JumpInfo jump = null;\n             if (visitor instanceof OpcodeStackDetector.WithCustomJumpInfo) {\n                 jump = ((OpcodeStackDetector.WithCustomJumpInfo) visitor).customJumpInfo();\n             }\n-\n             if (jump == null)\n                 jump = getJumpInfo();\n             if (jump != null) {\n                 learnFrom(jump);\n             }\n-\n         }\n-\n         return result;\n-\n     }\n \n+\n     private JumpInfo getJumpInfo() {\n         IAnalysisCache analysisCache = Global.getAnalysisCache();\n         XMethod xMethod = XFactory.createXMethod(v.getThisClass(), v.getMethod());\n@@ -2649,13 +2535,14 @@ public class OpcodeStack implements Constants2 {\n         }\n     }\n \n+\n     private int resetForMethodEntry0(PreorderVisitor visitor) {\n         return resetForMethodEntry0(visitor.getClassName(), visitor.getMethod());\n     }\n \n+\n     private int resetForMethodEntry0(@SlashedClassName String className, Method m) {\n         methodName = m.getName();\n-\n         if (DEBUG)\n             System.out.println(\" --- \");\n         String signature = m.getSignature();\n@@ -2664,7 +2551,6 @@ public class OpcodeStack implements Constants2 {\n         top = false;\n         encountedTop = false;\n         backwardsBranch = false;\n-\n         setReachOnlyByBranch(false);\n         seenTransferOfControl = false;\n         exceptionHandlers.clear();\n@@ -2686,6 +2572,7 @@ public class OpcodeStack implements Constants2 {\n             setLVValue(reg, it);\n             reg += it.getSize();\n         }\n+\n         for (Type argType : argTypes) {\n             Item it = new Item(argType.getSignature());\n             it.registerNumber = reg;\n@@ -2702,22 +2589,19 @@ public class OpcodeStack implements Constants2 {\n \n     public Item getStackItem(int stackOffset) {\n         if (stackOffset < 0 || stackOffset >= stack.size()) {\n-            AnalysisContext.logError(\"Can't get stack offset \" + stackOffset + \" from \" + stack.toString() + \" @ \" + v.getPC()\n-                    + \" in \" + v.getFullyQualifiedMethodName(), new IllegalArgumentException(stackOffset\n-                    + \" is not a value stack offset\"));\n+            AnalysisContext.logError(\"Can't get stack offset \" + stackOffset + \" from \" + stack.toString() + \" @ \" + v.getPC() + \" in \" + v.getFullyQualifiedMethodName(), new IllegalArgumentException(stackOffset + \" is not a value stack offset\"));\n             return new Item(\"Lfindbugs/OpcodeStackError;\");\n-\n         }\n         int tos = stack.size() - 1;\n         int pos = tos - stackOffset;\n         try {\n             return stack.get(pos);\n         } catch (ArrayIndexOutOfBoundsException e) {\n-            throw new ArrayIndexOutOfBoundsException(\"Requested item at offset \" + stackOffset + \" in a stack of size \"\n-                    + stack.size() + \", made request for position \" + pos);\n+            throw new ArrayIndexOutOfBoundsException(\"Requested item at offset \" + stackOffset + \" in a stack of size \" + stack.size() + \", made request for position \" + pos);\n         }\n     }\n \n+\n     private Item pop() {\n         return stack.remove(stack.size() - 1);\n     }\n@@ -2727,17 +2611,19 @@ public class OpcodeStack implements Constants2 {\n         push(newTop);\n     }\n \n+\n     private void pop(int count) {\n         while ((count--) > 0)\n             pop();\n     }\n \n+\n     private void push(Item i) {\n         stack.add(i);\n     }\n \n-    private void pushByConstant(DismantleBytecode dbc, Constant c) {\n \n+    private void pushByConstant(DismantleBytecode dbc, Constant c) {\n         if (c instanceof ConstantClass)\n             push(new Item(\"Ljava/lang/Class;\", ((ConstantClass) c).getConstantValue(dbc.getConstantPool())));\n         else if (c instanceof ConstantInteger)\n@@ -2745,16 +2631,17 @@ public class OpcodeStack implements Constants2 {\n         else if (c instanceof ConstantString) {\n             int s = ((ConstantString) c).getStringIndex();\n             push(new Item(\"Ljava/lang/String;\", getStringFromIndex(dbc, s)));\n-        } else if (c instanceof ConstantFloat)\n-            push(new Item(\"F\", Float.valueOf(((ConstantFloat) c).getBytes())));\n-        else if (c instanceof ConstantDouble)\n-            push(new Item(\"D\", Double.valueOf(((ConstantDouble) c).getBytes())));\n-        else if (c instanceof ConstantLong)\n-            push(new Item(\"J\", Long.valueOf(((ConstantLong) c).getBytes())));\n-        else\n-            throw new UnsupportedOperationException(\"Constant type not expected\");\n+             } else if (c instanceof ConstantFloat)\n+                   push(new Item(\"F\", Float.valueOf(((ConstantFloat) c).getBytes())));\n+               else if (c instanceof ConstantDouble)\n+                   push(new Item(\"D\", Double.valueOf(((ConstantDouble) c).getBytes())));\n+               else if (c instanceof ConstantLong)\n+                   push(new Item(\"J\", Long.valueOf(((ConstantLong) c).getBytes())));\n+               else\n+                   throw new UnsupportedOperationException(\"Constant type not expected\");\n     }\n \n+\n     private void pushByLocalObjectLoad(DismantleBytecode dbc, int register) {\n         Method m = dbc.getMethod();\n         LocalVariableTable lvt = m.getLocalVariableTable();\n@@ -2769,18 +2656,16 @@ public class OpcodeStack implements Constants2 {\n         pushByLocalLoad(\"Ljava/lang/Object;\", register);\n     }\n \n+\n     private void pushByIntMath(DismantleBytecode dbc, int seen, Item lhs, Item rhs) {\n         Item newValue = new Item(\"I\");\n         if (lhs == null || rhs == null) {\n             push(newValue);\n             return;\n         }\n-\n         try {\n             if (DEBUG)\n-                System.out.println(\"pushByIntMath \" + dbc.getFullyQualifiedMethodName() + \" @ \" + dbc.getPC() + \" : \" + lhs\n-                        + OPCODE_NAMES[seen] + rhs);\n-\n+                System.out.println(\"pushByIntMath \" + dbc.getFullyQualifiedMethodName() + \" @ \" + dbc.getPC() + \" : \" + lhs + OPCODE_NAMES[seen] + rhs);\n             if (rhs.getConstant() != null && lhs.getConstant() != null) {\n                 int lhsValue = constantToInt(lhs);\n                 int rhsValue = constantToInt(rhs);\n@@ -2788,8 +2673,8 @@ public class OpcodeStack implements Constants2 {\n                     push(newValue);\n                     return;\n                 }\n-                switch (seen) {\n \n+                switch (seen) {\n                 case IADD:\n                     newValue = new Item(\"I\", lhsValue + rhsValue);\n                     break;\n@@ -2809,7 +2694,6 @@ public class OpcodeStack implements Constants2 {\n                     newValue = new Item(\"I\", lhsValue & rhsValue);\n                     if ((rhsValue & 0xff) == 0 && rhsValue != 0 || (lhsValue & 0xff) == 0 && lhsValue != 0)\n                         newValue.setSpecialKind(Item.LOW_8_BITS_CLEAR);\n-\n                     break;\n                 case IOR:\n                     newValue = new Item(\"I\", lhsValue | rhsValue);\n@@ -2821,17 +2705,13 @@ public class OpcodeStack implements Constants2 {\n                     newValue = new Item(\"I\", lhsValue << rhsValue);\n                     if (rhsValue >= 8)\n                         newValue.setSpecialKind(Item.LOW_8_BITS_CLEAR);\n-\n                     break;\n                 case ISHR:\n                     newValue = new Item(\"I\", lhsValue >> rhsValue);\n-\n                     break;\n                 case IUSHR:\n                     newValue = new Item(\"I\", lhsValue >>> rhsValue);\n-\n                 }\n-\n             } else if ((seen == ISHL || seen == ISHR || seen == IUSHR)) {\n                 if (rhs.getConstant() != null) {\n                     int constant = constantToInt(rhs);\n@@ -2845,49 +2725,46 @@ public class OpcodeStack implements Constants2 {\n                         newValue = new Item(\"I\", 0);\n                 }\n             } else if (lhs.getConstant() != null && seen == IAND) {\n-                int value = constantToInt(lhs);\n-                if (value == 0)\n-                    newValue = new Item(\"I\", 0);\n-                else if ((value & 0xff) == 0)\n-                    newValue.setSpecialKind(Item.LOW_8_BITS_CLEAR);\n-                else if (value >= 0)\n-                    newValue.setSpecialKind(Item.NON_NEGATIVE);\n-            } else if (rhs.getConstant() != null && seen == IAND) {\n-                int value = constantToInt(rhs);\n-                if (value == 0)\n-                    newValue = new Item(\"I\", 0);\n-                else if ((value & 0xff) == 0)\n-                    newValue.setSpecialKind(Item.LOW_8_BITS_CLEAR);\n-                else if (value >= 0)\n-                    newValue.setSpecialKind(Item.NON_NEGATIVE);\n-            } else if (seen == IAND && lhs.getSpecialKind() == Item.ZERO_MEANS_NULL) {\n-                newValue.setSpecialKind(Item.ZERO_MEANS_NULL);\n-                newValue.setPC(lhs.getPC());\n-            } else if (seen == IAND && rhs.getSpecialKind() == Item.ZERO_MEANS_NULL) {\n-                newValue.setSpecialKind(Item.ZERO_MEANS_NULL);\n-                newValue.setPC(rhs.getPC());\n-            } else if (seen == IOR && lhs.getSpecialKind() == Item.NONZERO_MEANS_NULL) {\n-                newValue.setSpecialKind(Item.NONZERO_MEANS_NULL);\n-                newValue.setPC(lhs.getPC());\n-            } else if (seen == IOR && rhs.getSpecialKind() == Item.NONZERO_MEANS_NULL) {\n-                newValue.setSpecialKind(Item.NONZERO_MEANS_NULL);\n-                newValue.setPC(rhs.getPC());\n-            }\n+                  int value = constantToInt(lhs);\n+                  if (value == 0)\n+                      newValue = new Item(\"I\", 0);\n+                  else if ((value & 0xff) == 0)\n+                      newValue.setSpecialKind(Item.LOW_8_BITS_CLEAR);\n+                  else if (value >= 0)\n+                      newValue.setSpecialKind(Item.NON_NEGATIVE);\n+                   } else if (rhs.getConstant() != null && seen == IAND) {\n+                         int value = constantToInt(rhs);\n+                         if (value == 0)\n+                             newValue = new Item(\"I\", 0);\n+                         else if ((value & 0xff) == 0)\n+                             newValue.setSpecialKind(Item.LOW_8_BITS_CLEAR);\n+                         else if (value >= 0)\n+                             newValue.setSpecialKind(Item.NON_NEGATIVE);\n+                   } else if (seen == IAND && lhs.getSpecialKind() == Item.ZERO_MEANS_NULL) {\n+                              newValue.setSpecialKind(Item.ZERO_MEANS_NULL);\n+                              newValue.setPC(lhs.getPC());\n+                          } else if (seen == IAND && rhs.getSpecialKind() == Item.ZERO_MEANS_NULL) {\n+                              newValue.setSpecialKind(Item.ZERO_MEANS_NULL);\n+                              newValue.setPC(rhs.getPC());\n+                          } else if (seen == IOR && lhs.getSpecialKind() == Item.NONZERO_MEANS_NULL) {\n+                                     newValue.setSpecialKind(Item.NONZERO_MEANS_NULL);\n+                                     newValue.setPC(lhs.getPC());\n+                                 } else if (seen == IOR && rhs.getSpecialKind() == Item.NONZERO_MEANS_NULL) {\n+                                     newValue.setSpecialKind(Item.NONZERO_MEANS_NULL);\n+                                     newValue.setPC(rhs.getPC());\n+                                 }\n         } catch (ArithmeticException e) {\n             assert true; // ignore it\n         } catch (RuntimeException e) {\n-            String msg = \"Error processing2 \" + lhs + OPCODE_NAMES[seen] + rhs + \" @ \" + dbc.getPC() + \" in \"\n-                    + dbc.getFullyQualifiedMethodName();\n+            String msg = \"Error processing2 \" + lhs + OPCODE_NAMES[seen] + rhs + \" @ \" + dbc.getPC() + \" in \" + dbc.getFullyQualifiedMethodName();\n             AnalysisContext.logError(msg, e);\n-\n         }\n         if (lhs.getSpecialKind() == Item.INTEGER_SUM && rhs.getConstant() != null) {\n             int rhsValue = constantToInt(rhs);\n             if (seen == IDIV && rhsValue == 2 || seen == ISHR && rhsValue == 1)\n                 newValue.setSpecialKind(Item.AVERAGE_COMPUTED_USING_DIVISION);\n         }\n-        if (seen == IADD && newValue.getSpecialKind() == Item.NOT_SPECIAL && lhs.getConstant() == null\n-                && rhs.getConstant() == null)\n+        if (seen == IADD && newValue.getSpecialKind() == Item.NOT_SPECIAL && lhs.getConstant() == null && rhs.getConstant() == null)\n             newValue.setSpecialKind(Item.INTEGER_SUM);\n         if (seen == IREM && lhs.getSpecialKind() == Item.HASHCODE_INT)\n             newValue.setSpecialKind(Item.HASHCODE_INT_REMAINDER);\n@@ -2907,12 +2784,11 @@ public class OpcodeStack implements Constants2 {\n         push(newValue);\n     }\n \n+\n     private void pushByLongMath(int seen, Item lhs, Item rhs) {\n         Item newValue = new Item(\"J\");\n         try {\n-\n             if ((rhs.getConstant() != null) && lhs.getConstant() != null) {\n-\n                 long lhsValue = constantToLong(lhs);\n                 if (seen == LSHL) {\n                     newValue = new Item(\"J\", Long.valueOf(lhsValue << constantToInt(rhs)));\n@@ -2922,28 +2798,27 @@ public class OpcodeStack implements Constants2 {\n                     newValue = new Item(\"J\", Long.valueOf(lhsValue >> constantToInt(rhs)));\n                 else if (seen == LUSHR)\n                     newValue = new Item(\"J\", Long.valueOf(lhsValue >>> constantToInt(rhs)));\n-\n                 else {\n-                    long rhsValue = constantToLong(rhs);\n-                    if (seen == LADD)\n-                        newValue = new Item(\"J\", Long.valueOf(lhsValue + rhsValue));\n-                    else if (seen == LSUB)\n-                        newValue = new Item(\"J\", Long.valueOf(lhsValue - rhsValue));\n-                    else if (seen == LMUL)\n-                        newValue = new Item(\"J\", Long.valueOf(lhsValue * rhsValue));\n-                    else if (seen == LDIV)\n-                        newValue = new Item(\"J\", Long.valueOf(lhsValue / rhsValue));\n-                    else if (seen == LAND) {\n-                        newValue = new Item(\"J\", Long.valueOf(lhsValue & rhsValue));\n-                        if ((rhsValue & 0xff) == 0 && rhsValue != 0 || (lhsValue & 0xff) == 0 && lhsValue != 0)\n-                            newValue.setSpecialKind(Item.LOW_8_BITS_CLEAR);\n-                    } else if (seen == LOR)\n-                        newValue = new Item(\"J\", Long.valueOf(lhsValue | rhsValue));\n-                    else if (seen == LXOR)\n-                        newValue = new Item(\"J\", Long.valueOf(lhsValue ^ rhsValue));\n-                    else if (seen == LREM)\n-                        newValue = new Item(\"J\", Long.valueOf(lhsValue % rhsValue));\n-                }\n+                           long rhsValue = constantToLong(rhs);\n+                           if (seen == LADD)\n+                               newValue = new Item(\"J\", Long.valueOf(lhsValue + rhsValue));\n+                           else if (seen == LSUB)\n+                               newValue = new Item(\"J\", Long.valueOf(lhsValue - rhsValue));\n+                           else if (seen == LMUL)\n+                               newValue = new Item(\"J\", Long.valueOf(lhsValue * rhsValue));\n+                           else if (seen == LDIV)\n+                               newValue = new Item(\"J\", Long.valueOf(lhsValue / rhsValue));\n+                           else if (seen == LAND) {\n+                                    newValue = new Item(\"J\", Long.valueOf(lhsValue & rhsValue));\n+                                    if ((rhsValue & 0xff) == 0 && rhsValue != 0 || (lhsValue & 0xff) == 0 && lhsValue != 0)\n+                                        newValue.setSpecialKind(Item.LOW_8_BITS_CLEAR);\n+                                } else if (seen == LOR)\n+                                      newValue = new Item(\"J\", Long.valueOf(lhsValue | rhsValue));\n+                                  else if (seen == LXOR)\n+                                      newValue = new Item(\"J\", Long.valueOf(lhsValue ^ rhsValue));\n+                                  else if (seen == LREM)\n+                                      newValue = new Item(\"J\", Long.valueOf(lhsValue % rhsValue));\n+                       }\n             } else if (rhs.getConstant() != null && seen == LSHL && constantToInt(rhs) >= 8)\n                 newValue.setSpecialKind(Item.LOW_8_BITS_CLEAR);\n             else if (lhs.getConstant() != null && seen == LAND && (constantToLong(lhs) & 0xff) == 0)\n@@ -2952,10 +2827,12 @@ public class OpcodeStack implements Constants2 {\n                 newValue.setSpecialKind(Item.LOW_8_BITS_CLEAR);\n         } catch (RuntimeException e) {\n             // ignore it\n+\n         }\n         push(newValue);\n     }\n \n+\n     private void pushByFloatMath(int seen, Item it, Item it2) {\n         Item result;\n         int specialKind = Item.FLOAT_MATH;\n@@ -2981,6 +2858,7 @@ public class OpcodeStack implements Constants2 {\n         push(result);\n     }\n \n+\n     private void pushByDoubleMath(int seen, Item it, Item it2) {\n         Item result;\n         int specialKind = Item.FLOAT_MATH;\n@@ -3006,6 +2884,7 @@ public class OpcodeStack implements Constants2 {\n         push(result);\n     }\n \n+\n     private void pushByInvoke(DismantleBytecode dbc, boolean popThis) {\n         String signature = dbc.getSigConstantOperand();\n         if (dbc.getNameConstantOperand().equals(\"<init>\") && signature.endsWith(\")V\") && popThis) {\n@@ -3032,17 +2911,18 @@ public class OpcodeStack implements Constants2 {\n         case INVOKESPECIAL:\n             String signature = dbc.getSigConstantOperand();\n             int stackOffset = PreorderVisitor.getNumberArguments(signature);\n-\n             return getStackItem(stackOffset);\n         }\n         throw new IllegalArgumentException(\"Not visiting an instance method call\");\n     }\n \n+\n     private String getStringFromIndex(DismantleBytecode dbc, int i) {\n         ConstantUtf8 name = (ConstantUtf8) dbc.getConstantPool().getConstant(i);\n         return name.getBytes();\n     }\n \n+\n     private void pushBySignature(String s, DismantleBytecode dbc) {\n         if (\"V\".equals(s))\n             return;\n@@ -3056,6 +2936,7 @@ public class OpcodeStack implements Constants2 {\n         push(item);\n     }\n \n+\n     private void pushByLocalStore(int register) {\n         Item it = pop();\n         if (it.getRegisterNumber() != register) {\n@@ -3066,6 +2947,7 @@ public class OpcodeStack implements Constants2 {\n                     if (i.fieldLoadedFromRegister == register)\n                         i.fieldLoadedFromRegister = -1;\n                 }\n+\n             for (Item i : stack)\n                 if (i != null) {\n                     if (i.registerNumber == register)\n@@ -3077,9 +2959,9 @@ public class OpcodeStack implements Constants2 {\n         setLVValue(register, it);\n     }\n \n+\n     private void pushByLocalLoad(String signature, int register) {\n         Item oldItem = getLVValue(register);\n-\n         Item newItem;\n         if (oldItem == null) {\n             newItem = new Item(signature);\n@@ -3096,11 +2978,10 @@ public class OpcodeStack implements Constants2 {\n                 newItem.registerNumber = register;\n             }\n         }\n-\n         push(newItem);\n-\n     }\n \n+\n     private void setLVValue(int index, Item value) {\n         int addCount = index - lvValues.size() + 1;\n         while ((addCount--) > 0)\n@@ -3113,11 +2994,9 @@ public class OpcodeStack implements Constants2 {\n     public Item getLVValue(int index) {\n         if (index >= lvValues.size())\n             return new Item();\n-\n         Item item = lvValues.get(index);\n         if (item != null)\n             return item;\n-\n         return new Item();\n     }\n \n@@ -3129,6 +3008,8 @@ public class OpcodeStack implements Constants2 {\n      * @param top\n      *            The top to set.\n      */\n+\n+\n     private void setTop(boolean top) {\n         if (top) {\n             if (!this.top)\n@@ -3140,6 +3021,7 @@ public class OpcodeStack implements Constants2 {\n     /**\n      * @return Returns the top.\n      */\n+\n     public boolean isTop() {\n         if (top)\n             return true;\n@@ -3150,6 +3032,7 @@ public class OpcodeStack implements Constants2 {\n      * @param reachOnlyByBranch\n      *            The reachOnlyByBranch to set.\n      */\n+\n     void setReachOnlyByBranch(boolean reachOnlyByBranch) {\n         if (reachOnlyByBranch)\n             setTop(true);\n@@ -3159,9 +3042,8 @@ public class OpcodeStack implements Constants2 {\n     /**\n      * @return Returns the reachOnlyByBranch.\n      */\n+\n     boolean isReachOnlyByBranch() {\n         return reachOnlyByBranch;\n     }\n-}\n-\n-// vim:ts=4\n+}\n\\ No newline at end of file\n",
            "diff_size": 560
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/errored/1/10/OpcodeStack.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/styler_random/10/OpcodeStack.java\nindex 6c3e1fc04c5..0ce65f7fa89 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/errored/1/10/OpcodeStack.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/styler_random/10/OpcodeStack.java\n@@ -1341,7 +1341,7 @@ public class OpcodeStack implements Constants2 {\n                         handled = true;\n                         break;\n                     case IF_ICMPGE:\n-                    \t takeJump = lC >= rC;\n+                            takeJump = lC >= rC;\n                          handled = true;\n                          break;\n                     case IF_ICMPGT:\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": null,
            "diff": null
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "codebuff",
        "styler_random"
    ],
    "not_repaired_by": [
        "naturalize",
        "styler_three_grams"
    ]
}