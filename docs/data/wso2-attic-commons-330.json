{
    "project_name": "wso2-attic-commons",
    "error_id": "330",
    "information": {
        "errors": [
            {
                "line": "90",
                "severity": "error",
                "message": "Line is longer than 120 characters (found 121).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": "     * The standard URI for the default subject category value\n     */\n    public static final String SUBJECT_CATEGORY_DEFAULT = \"urn:oasis:names:tc:xacml:1.0:subject-category:access-subject\";\n\n    // helper array of strings\n    static final private String[] targetTypes = { \"Subject\", \"Resource\", \"Action\", \"Environment\" };",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/330/AttributeDesignator.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler/330/AttributeDesignator.java\nindex 5f28bd9f4ab..99a05545059 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/330/AttributeDesignator.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler/330/AttributeDesignator.java\n@@ -87,10 +87,11 @@ public class AttributeDesignator implements Evaluatable {\n     /**\n      * The standard URI for the default subject category value\n      */\n-    public static final String SUBJECT_CATEGORY_DEFAULT = \"urn:oasis:names:tc:xacml:1.0:subject-category:access-subject\";\n+    public static final String SUBJECT_CATEGORY_DEFAULT =\n+\t\t\t\t\t\"urn:oasis:names:tc:xacml:1.0:subject-category:access-subject\";\n \n-    // helper array of strings\n-    static final private String[] targetTypes = { \"Subject\", \"Resource\", \"Action\", \"Environment\" };\n+     // helper array of strings\n+     static final private String[] targetTypes = { \"Subject\", \"Resource\", \"Action\", \"Environment\" };\n \n     // the type of designator we are\n     private int target;\n",
            "diff_size": 4
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/330/AttributeDesignator.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/intellij/330/AttributeDesignator.java\nindex 5f28bd9f4ab..02d4581fccf 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/330/AttributeDesignator.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/intellij/330/AttributeDesignator.java\n@@ -8,7 +8,7 @@\n  *\n  *   1. Redistribution of source code must retain the above copyright notice,\n  *      this list of conditions and the following disclaimer.\n- * \n+ *\n  *   2. Redistribution in binary form must reproduce the above copyright\n  *      notice, this list of conditions and the following disclaimer in the\n  *      documentation and/or other materials provided with the distribution.\n@@ -16,7 +16,7 @@\n  * Neither the name of Sun Microsystems, Inc. or the names of contributors may\n  * be used to endorse or promote products derived from this software without\n  * specific prior written permission.\n- * \n+ *\n  * This software is provided \"AS IS,\" without a warranty of any kind. ALL\n  * EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND WARRANTIES, INCLUDING\n  * ANY IMPLIED WARRANTY OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE\n@@ -58,427 +58,429 @@ import org.w3c.dom.Node;\n \n /**\n  * Represents all four kinds of Designators in XACML.\n- * \n- * @since 1.0\n+ *\n  * @author Seth Proctor\n+ * @since 1.0\n  */\n public class AttributeDesignator implements Evaluatable {\n \n-    /**\n-     * Tells designator to search in the subject section of the request\n-     */\n-    public static final int SUBJECT_TARGET = 0;\n-\n-    /**\n-     * Tells designator to search in the resource section of the request\n-     */\n-    public static final int RESOURCE_TARGET = 1;\n-\n-    /**\n-     * Tells designator to search in the action section of the request\n-     */\n-    public static final int ACTION_TARGET = 2;\n-\n-    /**\n-     * Tells designator to search in the environment section of the request\n-     */\n-    public static final int ENVIRONMENT_TARGET = 3;\n-\n-    /**\n-     * The standard URI for the default subject category value\n-     */\n-    public static final String SUBJECT_CATEGORY_DEFAULT = \"urn:oasis:names:tc:xacml:1.0:subject-category:access-subject\";\n-\n-    // helper array of strings\n-    static final private String[] targetTypes = { \"Subject\", \"Resource\", \"Action\", \"Environment\" };\n-\n-    // the type of designator we are\n-    private int target;\n-\n-    // required attributes\n-    private URI type;\n-    private URI id;\n-\n-    // optional attribute\n-    private URI issuer;\n-\n-    // must resolution find something\n-    private boolean mustBePresent;\n-\n-    // if we're a subject this is the category\n-    private URI subjectCategory;\n-\n-    /**\n-     * XACML 3 \n-     */\n-    private URI category;\n-\n-    // the logger we'll use for all messages\n-    private static Log logger = LogFactory.getLog(AttributeDesignator.class);\n-\n-    /**\n-     * Creates a new <code>AttributeDesignator</code> without the optional issuer.\n-     * \n-     * @param target the type of designator as specified by the 4 member *_TARGET fields\n-     * @param type the data type resolved by this designator\n-     * @param id the attribute id looked for by this designator\n-     * @param mustBePresent whether resolution must find a value\n-     */\n-    public AttributeDesignator(int target, URI type, URI id, boolean mustBePresent, URI category) {\n-        this(target, type, id, mustBePresent, null, category);\n+  /**\n+   * Tells designator to search in the subject section of the request\n+   */\n+  public static final int SUBJECT_TARGET = 0;\n+\n+  /**\n+   * Tells designator to search in the resource section of the request\n+   */\n+  public static final int RESOURCE_TARGET = 1;\n+\n+  /**\n+   * Tells designator to search in the action section of the request\n+   */\n+  public static final int ACTION_TARGET = 2;\n+\n+  /**\n+   * Tells designator to search in the environment section of the request\n+   */\n+  public static final int ENVIRONMENT_TARGET = 3;\n+\n+  /**\n+   * The standard URI for the default subject category value\n+   */\n+  public static final String SUBJECT_CATEGORY_DEFAULT = \"urn:oasis:names:tc:xacml:1.0:subject-category:access-subject\";\n+\n+  // helper array of strings\n+  static final private String[] targetTypes = {\"Subject\", \"Resource\", \"Action\", \"Environment\"};\n+\n+  // the type of designator we are\n+  private int target;\n+\n+  // required attributes\n+  private URI type;\n+  private URI id;\n+\n+  // optional attribute\n+  private URI issuer;\n+\n+  // must resolution find something\n+  private boolean mustBePresent;\n+\n+  // if we're a subject this is the category\n+  private URI subjectCategory;\n+\n+  /**\n+   * XACML 3\n+   */\n+  private URI category;\n+\n+  // the logger we'll use for all messages\n+  private static Log logger = LogFactory.getLog(AttributeDesignator.class);\n+\n+  /**\n+   * Creates a new <code>AttributeDesignator</code> without the optional issuer.\n+   *\n+   * @param target        the type of designator as specified by the 4 member *_TARGET fields\n+   * @param type          the data type resolved by this designator\n+   * @param id            the attribute id looked for by this designator\n+   * @param mustBePresent whether resolution must find a value\n+   */\n+  public AttributeDesignator(int target, URI type, URI id, boolean mustBePresent, URI category) {\n+    this(target, type, id, mustBePresent, null, category);\n+  }\n+\n+  /**\n+   * Creates a new <code>AttributeDesignator</code> with the optional issuer.\n+   *\n+   * @param target        the type of designator as specified by the 4 member *_TARGET fields\n+   * @param type          the data type resolved by this designator\n+   * @param id            the attribute id looked for by this designator\n+   * @param mustBePresent whether resolution must find a value\n+   * @param issuer        the issuer of the values to search for or null if no issuer is specified\n+   * @throws IllegalArgumentException if the input target isn't a valid value\n+   */\n+  public AttributeDesignator(int target, URI type, URI id, boolean mustBePresent, URI issuer,\n+                             URI category) throws IllegalArgumentException {\n+\n+    // check if input target is a valid value\n+    if ((target != SUBJECT_TARGET) && (target != RESOURCE_TARGET) && (target != ACTION_TARGET)\n+      && (target != ENVIRONMENT_TARGET)) {\n+      throw new IllegalArgumentException(\"Input target is not a valid\" + \"value\");\n     }\n-\n-    /**\n-     * Creates a new <code>AttributeDesignator</code> with the optional issuer.\n-     * \n-     * @param target the type of designator as specified by the 4 member *_TARGET fields\n-     * @param type the data type resolved by this designator\n-     * @param id the attribute id looked for by this designator\n-     * @param mustBePresent whether resolution must find a value\n-     * @param issuer the issuer of the values to search for or null if no issuer is specified\n-     * \n-     * @throws IllegalArgumentException if the input target isn't a valid value\n-     */\n-    public AttributeDesignator(int target, URI type, URI id, boolean mustBePresent, URI issuer,\n-                               URI category) throws IllegalArgumentException {\n-\n-        // check if input target is a valid value\n-        if ((target != SUBJECT_TARGET) && (target != RESOURCE_TARGET) && (target != ACTION_TARGET)\n-                && (target != ENVIRONMENT_TARGET))\n-            throw new IllegalArgumentException(\"Input target is not a valid\" + \"value\");\n-        this.target = target;\n-        this.type = type;\n-        this.id = id;\n-        this.mustBePresent = mustBePresent;\n-        this.issuer = issuer;\n-        this.category = category;\n-    }\n-\n-    /**\n-     * Sets the category if this is a SubjectAttributeDesignatorType\n-     * \n-     * @param category the subject category\n-     */\n-    public void setSubjectCategory(URI category) {\n-        if (target == SUBJECT_TARGET)\n-            subjectCategory = category;\n+    this.target = target;\n+    this.type = type;\n+    this.id = id;\n+    this.mustBePresent = mustBePresent;\n+    this.issuer = issuer;\n+    this.category = category;\n+  }\n+\n+  /**\n+   * Sets the category if this is a SubjectAttributeDesignatorType\n+   *\n+   * @param category the subject category\n+   */\n+  public void setSubjectCategory(URI category) {\n+    if (target == SUBJECT_TARGET) {\n+      subjectCategory = category;\n     }\n-\n-    /**\n-     * Creates a new <code>AttributeDesignator</code> based on the DOM root of the XML data.\n-     * \n-     * @deprecated As of 2.0 you should avoid using this method and should instead use the version\n-     *             that takes a <code>PolicyMetaData</code> instance. This method will only work for\n-     *             XACML 1.x policies.\n-     * \n-     * @param root the DOM root of the AttributeDesignatorType XML type\n-     * @param target the type of designator to create as specified in the four member *_TARGET\n-     *            fields\n-     * \n-     * @return the designator\n-     * \n-     * @throws ParsingException if the AttributeDesignatorType was invalid\n-     */\n-    public static AttributeDesignator getInstance(Node root, int target) throws ParsingException {\n-        return getInstance(root, target, new PolicyMetaData());\n+  }\n+\n+  /**\n+   * Creates a new <code>AttributeDesignator</code> based on the DOM root of the XML data.\n+   *\n+   * @param root   the DOM root of the AttributeDesignatorType XML type\n+   * @param target the type of designator to create as specified in the four member *_TARGET\n+   *               fields\n+   * @return the designator\n+   * @throws ParsingException if the AttributeDesignatorType was invalid\n+   * @deprecated As of 2.0 you should avoid using this method and should instead use the version\n+   * that takes a <code>PolicyMetaData</code> instance. This method will only work for\n+   * XACML 1.x policies.\n+   */\n+  public static AttributeDesignator getInstance(Node root, int target) throws ParsingException {\n+    return getInstance(root, target, new PolicyMetaData());\n+  }\n+\n+  /**\n+   * Creates a new <code>AttributeDesignator</code> based on the DOM root of the XML data.\n+   *\n+   * @param root     the DOM root of the AttributeDesignatorType XML type\n+   * @param target   the type of designator to create as specified in the four member *_TARGET\n+   *                 fields\n+   * @param metaData the meta-data associated with the containing policy\n+   * @return the designator\n+   * @throws ParsingException if the AttributeDesignatorType was invalid\n+   */\n+  public static AttributeDesignator getInstance(Node root, int target, PolicyMetaData metaData)\n+    throws ParsingException {\n+    URI type = null;\n+    URI id = null;\n+    URI issuer = null;\n+    URI category = null;\n+    boolean mustBePresent = false;\n+    URI subjectCategory = null;\n+\n+    NamedNodeMap attrs = root.getAttributes();\n+\n+    try {\n+      // there's always an Id\n+      id = new URI(attrs.getNamedItem(\"AttributeId\").getNodeValue());\n+    } catch (Exception e) {\n+      throw new ParsingException(\"Required AttributeId missing in \" + \"AttributeDesignator\",\n+        e);\n     }\n \n-    /**\n-     * Creates a new <code>AttributeDesignator</code> based on the DOM root of the XML data.\n-     * \n-     * @param root the DOM root of the AttributeDesignatorType XML type\n-     * @param target the type of designator to create as specified in the four member *_TARGET\n-     *            fields\n-     * @param metaData the meta-data associated with the containing policy\n-     * \n-     * @return the designator\n-     * \n-     * @throws ParsingException if the AttributeDesignatorType was invalid\n-     */\n-    public static AttributeDesignator getInstance(Node root, int target, PolicyMetaData metaData)\n-            throws ParsingException {\n-        URI type = null;\n-        URI id = null;\n-        URI issuer = null;\n-        URI category = null;\n-        boolean mustBePresent = false;\n-        URI subjectCategory = null;\n-\n-        NamedNodeMap attrs = root.getAttributes();\n-\n-        try {\n-            // there's always an Id\n-            id = new URI(attrs.getNamedItem(\"AttributeId\").getNodeValue());\n-        } catch (Exception e) {\n-            throw new ParsingException(\"Required AttributeId missing in \" + \"AttributeDesignator\",\n-                    e);\n+    if (PolicyMetaData.XACML_VERSION_3_0 == metaData.getXACMLVersion()) {\n+      try {\n+        // there's always an Id\n+        category = new URI(attrs.getNamedItem(\"Category\").getNodeValue());\n+\n+        if (XACMLConstants.SUBJECT_CATEGORY.equals(category.toString())) {\n+          target = SUBJECT_TARGET;\n+        } else if (XACMLConstants.RESOURCE_CATEGORY.equals(category.toString())) {\n+          target = RESOURCE_TARGET;\n+        } else if (XACMLConstants.ACTION_CATEGORY.equals(category.toString())) {\n+          target = ACTION_TARGET;\n+        } else if (XACMLConstants.ENT_CATEGORY.equals(category.toString())) {\n+          target = ENVIRONMENT_TARGET;\n         }\n \n-        if(PolicyMetaData.XACML_VERSION_3_0 == metaData.getXACMLVersion()){\n-            try {\n-                // there's always an Id\n-                category = new URI(attrs.getNamedItem(\"Category\").getNodeValue());\n-\n-                if(XACMLConstants.SUBJECT_CATEGORY.equals(category.toString())){\n-                    target = SUBJECT_TARGET;\n-                } else if(XACMLConstants.RESOURCE_CATEGORY.equals(category.toString())){\n-                    target = RESOURCE_TARGET;\n-                } else if(XACMLConstants.ACTION_CATEGORY.equals(category.toString())){\n-                    target = ACTION_TARGET;\n-                } else if(XACMLConstants.ENT_CATEGORY.equals(category.toString())){\n-                    target = ENVIRONMENT_TARGET;   \n-                }\n-\n-            } catch (Exception e) {\n-                throw new ParsingException(\"Required Category missing in \" + \"AttributeDesignator\", e);\n-            }\n-\n-            try {\n-                // there's always a data type\n-                String nodeValue = attrs.getNamedItem(\"MustBePresent\").getNodeValue();\n-                if(\"true\".equals(nodeValue)){\n-                    mustBePresent = true;\n-                }\n-            } catch (Exception e) {\n-                throw new ParsingException(\"Required DataType missing in \" + \"AttributeDesignator\", e);\n-            }            \n-        }\n-\n-        try {\n-            // there's always a data type\n-            type = new URI(attrs.getNamedItem(\"DataType\").getNodeValue());\n-        } catch (Exception e) {\n-            throw new ParsingException(\"Required DataType missing in \" + \"AttributeDesignator\", e);\n-        }\n+      } catch (Exception e) {\n+        throw new ParsingException(\"Required Category missing in \" + \"AttributeDesignator\", e);\n+      }\n \n-        try {\n-            // there might be an issuer\n-            Node node = attrs.getNamedItem(\"Issuer\");\n-            if (node != null)\n-                issuer = new URI(node.getNodeValue());\n-\n-            // if it's for the Subject section, there's another attr\n-            if (target == SUBJECT_TARGET) {\n-                Node scnode = attrs.getNamedItem(\"SubjectCategory\");\n-                if (scnode != null)\n-                    subjectCategory = new URI(scnode.getNodeValue());\n-                else\n-                    subjectCategory = new URI(SUBJECT_CATEGORY_DEFAULT);\n-            }\n-\n-            // there might be a mustBePresent flag\n-            if(!(PolicyMetaData.XACML_VERSION_3_0 == metaData.getXACMLVersion())){\n-                node = attrs.getNamedItem(\"MustBePresent\");\n-                if (node != null)\n-                    if (node.getNodeValue().equals(\"true\"))\n-                        mustBePresent = true;\n-            }\n-        } catch (Exception e) {\n-            // this shouldn't ever happen, but in theory something could go\n-            // wrong in the code in this try block\n-            throw new ParsingException(\n-                    \"Error parsing AttributeDesignator \" + \"optional attributes\", e);\n+      try {\n+        // there's always a data type\n+        String nodeValue = attrs.getNamedItem(\"MustBePresent\").getNodeValue();\n+        if (\"true\".equals(nodeValue)) {\n+          mustBePresent = true;\n         }\n-\n-        AttributeDesignator ad = new AttributeDesignator(target, type, id, mustBePresent, issuer, category);\n-        ad.setSubjectCategory(subjectCategory);\n-\n-        return ad;\n-    }\n-\n-    /**\n-     * Returns the type of this designator as specified by the *_TARGET fields.\n-     * \n-     * @return the designator type\n-     */\n-    public int getDesignatorType() {\n-        return target;\n-    }\n-\n-    /**\n-     * Returns the type of attribute that is resolved by this designator. While an AD will always\n-     * return a bag, this method will always return the type that is stored in the bag.\n-     * \n-     * @return the attribute type\n-     */\n-    public URI getType() {\n-        return type;\n+      } catch (Exception e) {\n+        throw new ParsingException(\"Required DataType missing in \" + \"AttributeDesignator\", e);\n+      }\n     }\n \n-    /**\n-     * Returns the AttributeId of the values resolved by this designator.\n-     * \n-     * @return identifier for the values to resolve\n-     */\n-    public URI getId() {\n-        return id;\n+    try {\n+      // there's always a data type\n+      type = new URI(attrs.getNamedItem(\"DataType\").getNodeValue());\n+    } catch (Exception e) {\n+      throw new ParsingException(\"Required DataType missing in \" + \"AttributeDesignator\", e);\n     }\n \n-    /**\n-     * Returns the subject category for this designator. If this is not a SubjectAttributeDesignator\n-     * then this will always return null.\n-     * \n-     * @return the subject category or null if this isn't a SubjectAttributeDesignator\n-     */\n-    public URI getCategory() {\n-        return subjectCategory;\n-    }\n-\n-    /**\n-     * Returns the issuer of the values resolved by this designator if specified.\n-     * \n-     * @return the attribute issuer or null if unspecified\n-     */\n-    public URI getIssuer() {\n-        return issuer;\n-    }\n-\n-    /**\n-     * Returns whether or not a value is required to be resolved by this designator.\n-     * \n-     * @return true if a value is required, false otherwise\n-     */\n-    public boolean mustBePresent() {\n-        return mustBePresent;\n+    try {\n+      // there might be an issuer\n+      Node node = attrs.getNamedItem(\"Issuer\");\n+      if (node != null) {\n+        issuer = new URI(node.getNodeValue());\n+      }\n+\n+      // if it's for the Subject section, there's another attr\n+      if (target == SUBJECT_TARGET) {\n+        Node scnode = attrs.getNamedItem(\"SubjectCategory\");\n+        if (scnode != null) {\n+          subjectCategory = new URI(scnode.getNodeValue());\n+        } else {\n+          subjectCategory = new URI(SUBJECT_CATEGORY_DEFAULT);\n+        }\n+      }\n+\n+      // there might be a mustBePresent flag\n+      if (!(PolicyMetaData.XACML_VERSION_3_0 == metaData.getXACMLVersion())) {\n+        node = attrs.getNamedItem(\"MustBePresent\");\n+        if (node != null) {\n+          if (node.getNodeValue().equals(\"true\")) {\n+            mustBePresent = true;\n+          }\n+        }\n+      }\n+    } catch (Exception e) {\n+      // this shouldn't ever happen, but in theory something could go\n+      // wrong in the code in this try block\n+      throw new ParsingException(\n+        \"Error parsing AttributeDesignator \" + \"optional attributes\", e);\n     }\n \n-    /**\n-     * Always returns true, since a designator always returns a bag of attribute values.\n-     * \n-     * @return true\n-     */\n-    public boolean returnsBag() {\n-        return true;\n+    AttributeDesignator ad = new AttributeDesignator(target, type, id, mustBePresent, issuer, category);\n+    ad.setSubjectCategory(subjectCategory);\n+\n+    return ad;\n+  }\n+\n+  /**\n+   * Returns the type of this designator as specified by the *_TARGET fields.\n+   *\n+   * @return the designator type\n+   */\n+  public int getDesignatorType() {\n+    return target;\n+  }\n+\n+  /**\n+   * Returns the type of attribute that is resolved by this designator. While an AD will always\n+   * return a bag, this method will always return the type that is stored in the bag.\n+   *\n+   * @return the attribute type\n+   */\n+  public URI getType() {\n+    return type;\n+  }\n+\n+  /**\n+   * Returns the AttributeId of the values resolved by this designator.\n+   *\n+   * @return identifier for the values to resolve\n+   */\n+  public URI getId() {\n+    return id;\n+  }\n+\n+  /**\n+   * Returns the subject category for this designator. If this is not a SubjectAttributeDesignator\n+   * then this will always return null.\n+   *\n+   * @return the subject category or null if this isn't a SubjectAttributeDesignator\n+   */\n+  public URI getCategory() {\n+    return subjectCategory;\n+  }\n+\n+  /**\n+   * Returns the issuer of the values resolved by this designator if specified.\n+   *\n+   * @return the attribute issuer or null if unspecified\n+   */\n+  public URI getIssuer() {\n+    return issuer;\n+  }\n+\n+  /**\n+   * Returns whether or not a value is required to be resolved by this designator.\n+   *\n+   * @return true if a value is required, false otherwise\n+   */\n+  public boolean mustBePresent() {\n+    return mustBePresent;\n+  }\n+\n+  /**\n+   * Always returns true, since a designator always returns a bag of attribute values.\n+   *\n+   * @return true\n+   */\n+  public boolean returnsBag() {\n+    return true;\n+  }\n+\n+  /**\n+   * Always returns true, since a designator always returns a bag of attribute values.\n+   *\n+   * @return true\n+   * @deprecated As of 2.0, you should use the <code>returnsBag</code> method from the\n+   * super-interface <code>Expression</code>.\n+   */\n+  public boolean evaluatesToBag() {\n+    return true;\n+  }\n+\n+  /**\n+   * Always returns an empty list since designators never have children.\n+   *\n+   * @return an empty <code>List</code>\n+   */\n+  public List getChildren() {\n+    return Collections.EMPTY_LIST;\n+  }\n+\n+  /**\n+   * Evaluates the pre-assigned meta-data against the given context, trying to find some matching\n+   * values.\n+   *\n+   * @param context the representation of the request\n+   * @return a result containing a bag either empty because no values were found or containing at\n+   * least one value, or status associated with an Indeterminate result\n+   */\n+  public EvaluationResult evaluate(EvaluationCtx context) {\n+    EvaluationResult result = null;\n+\n+    // look in the right section for some attribute values\n+    switch (target) {\n+    case SUBJECT_TARGET:\n+      result = context.getSubjectAttribute(type, id, issuer, subjectCategory);\n+      break;\n+    case RESOURCE_TARGET:\n+      result = context.getResourceAttribute(type, id, issuer);\n+      break;\n+    case ACTION_TARGET:\n+      result = context.getActionAttribute(type, id, issuer);\n+      break;\n+    case ENVIRONMENT_TARGET:\n+      result = context.getEnvironmentAttribute(type, id, issuer);\n+      break;\n     }\n \n-    /**\n-     * Always returns true, since a designator always returns a bag of attribute values.\n-     * \n-     * @deprecated As of 2.0, you should use the <code>returnsBag</code> method from the\n-     *             super-interface <code>Expression</code>.\n-     * \n-     * @return true\n-     */\n-    public boolean evaluatesToBag() {\n-        return true;\n+    // if the lookup was indeterminate, then we return immediately\n+    if (result.indeterminate()) {\n+      return result;\n     }\n \n-    /**\n-     * Always returns an empty list since designators never have children.\n-     * \n-     * @return an empty <code>List</code>\n-     */\n-    public List getChildren() {\n-        return Collections.EMPTY_LIST;\n-    }\n+    BagAttribute bag = (BagAttribute) (result.getAttributeValue());\n \n-    /**\n-     * Evaluates the pre-assigned meta-data against the given context, trying to find some matching\n-     * values.\n-     * \n-     * @param context the representation of the request\n-     * \n-     * @return a result containing a bag either empty because no values were found or containing at\n-     *         least one value, or status associated with an Indeterminate result\n-     */\n-    public EvaluationResult evaluate(EvaluationCtx context) {\n-        EvaluationResult result = null;\n-\n-        // look in the right section for some attribute values\n-        switch (target) {\n-        case SUBJECT_TARGET:\n-            result = context.getSubjectAttribute(type, id, issuer, subjectCategory);\n-            break;\n-        case RESOURCE_TARGET:\n-            result = context.getResourceAttribute(type, id, issuer);\n-            break;\n-        case ACTION_TARGET:\n-            result = context.getActionAttribute(type, id, issuer);\n-            break;\n-        case ENVIRONMENT_TARGET:\n-            result = context.getEnvironmentAttribute(type, id, issuer);\n-            break;\n+    if (bag.isEmpty()) {\n+      // if it's empty, this may be an error\n+      if (mustBePresent) {\n+        if (logger.isDebugEnabled()) {\n+          logger.debug(\"AttributeDesignator failed to resolve a \"\n+            + \"value for a required attribute: \" + id.toString());\n         }\n \n-        // if the lookup was indeterminate, then we return immediately\n-        if (result.indeterminate())\n-            return result;\n-\n-        BagAttribute bag = (BagAttribute) (result.getAttributeValue());\n-\n-        if (bag.isEmpty()) {\n-            // if it's empty, this may be an error\n-            if (mustBePresent) {\n-                if (logger.isDebugEnabled()) {\n-                    logger.debug(\"AttributeDesignator failed to resolve a \"\n-                            + \"value for a required attribute: \" + id.toString());\n-                }\n+        ArrayList code = new ArrayList();\n+        code.add(Status.STATUS_MISSING_ATTRIBUTE);\n \n-                ArrayList code = new ArrayList();\n-                code.add(Status.STATUS_MISSING_ATTRIBUTE);\n+        String message = \"Couldn't find \" + targetTypes[target]\n+          + \"AttributeDesignator attribute\";\n \n-                String message = \"Couldn't find \" + targetTypes[target]\n-                        + \"AttributeDesignator attribute\";\n+        // Note that there is a bug in the XACML spec. You can't\n+        // specify an identifier without specifying acceptable\n+        // values. Until this is fixed, this code will only\n+        // return the status code, and not any hints about what\n+        // was missing\n \n-                // Note that there is a bug in the XACML spec. You can't\n-                // specify an identifier without specifying acceptable\n-                // values. Until this is fixed, this code will only\n-                // return the status code, and not any hints about what\n-                // was missing\n+        /*\n+         * List attrs = new ArrayList(); attrs.add(new Attribute(id, ((issuer == null) ?\n+         * null : issuer.toString()), null, null)); StatusDetail detail = new\n+         * StatusDetail(attrs);\n+         */\n \n-                /*\n-                 * List attrs = new ArrayList(); attrs.add(new Attribute(id, ((issuer == null) ?\n-                 * null : issuer.toString()), null, null)); StatusDetail detail = new\n-                 * StatusDetail(attrs);\n-                 */\n-\n-                return new EvaluationResult(new Status(code, message));\n-            }\n-        }\n-\n-        // if we got here the bag wasn't empty, or mustBePresent was false,\n-        // so we just return the result\n-        return result;\n+        return new EvaluationResult(new Status(code, message));\n+      }\n     }\n \n-    /**\n-     * Encodes this designator into its XML representation and writes this encoding to the given\n-     * <code>OutputStream</code> with no indentation.\n-     * \n-     * @param output a stream into which the XML-encoded data is written\n-     */\n-    public void encode(OutputStream output) {\n-        encode(output, new Indenter(0));\n+    // if we got here the bag wasn't empty, or mustBePresent was false,\n+    // so we just return the result\n+    return result;\n+  }\n+\n+  /**\n+   * Encodes this designator into its XML representation and writes this encoding to the given\n+   * <code>OutputStream</code> with no indentation.\n+   *\n+   * @param output a stream into which the XML-encoded data is written\n+   */\n+  public void encode(OutputStream output) {\n+    encode(output, new Indenter(0));\n+  }\n+\n+  /**\n+   * Encodes this designator into its XML representation and writes this encoding to the given\n+   * <code>OutputStream</code> with indentation.\n+   *\n+   * @param output   a stream into which the XML-encoded data is written\n+   * @param indenter an object that creates indentation strings\n+   */\n+  public void encode(OutputStream output, Indenter indenter) {\n+    PrintStream out = new PrintStream(output);\n+    String indent = indenter.makeString();\n+\n+    String tag = \"<\" + targetTypes[target] + \"AttributeDesignator\";\n+\n+    if ((target == SUBJECT_TARGET) && (subjectCategory != null)) {\n+      tag += \" SubjectCategory=\\\"\" + subjectCategory.toString() + \"\\\"\";\n     }\n \n-    /**\n-     * Encodes this designator into its XML representation and writes this encoding to the given\n-     * <code>OutputStream</code> with indentation.\n-     * \n-     * @param output a stream into which the XML-encoded data is written\n-     * @param indenter an object that creates indentation strings\n-     */\n-    public void encode(OutputStream output, Indenter indenter) {\n-        PrintStream out = new PrintStream(output);\n-        String indent = indenter.makeString();\n-\n-        String tag = \"<\" + targetTypes[target] + \"AttributeDesignator\";\n-\n-        if ((target == SUBJECT_TARGET) && (subjectCategory != null))\n-            tag += \" SubjectCategory=\\\"\" + subjectCategory.toString() + \"\\\"\";\n+    tag += \" AttributeId=\\\"\" + id.toString() + \"\\\"\";\n+    tag += \" DataType=\\\"\" + type.toString() + \"\\\"\";\n \n-        tag += \" AttributeId=\\\"\" + id.toString() + \"\\\"\";\n-        tag += \" DataType=\\\"\" + type.toString() + \"\\\"\";\n-\n-        if (issuer != null)\n-            tag += \" Issuer=\\\"\" + issuer.toString() + \"\\\"\";\n+    if (issuer != null) {\n+      tag += \" Issuer=\\\"\" + issuer.toString() + \"\\\"\";\n+    }\n \n-        if (mustBePresent)\n-            tag += \" MustBePresent=\\\"true\\\"\";\n+    if (mustBePresent) {\n+      tag += \" MustBePresent=\\\"true\\\"\";\n+    }\n \n-        tag += \"/>\";\n+    tag += \"/>\";\n \n-        out.println(indent + tag);\n-    }\n+    out.println(indent + tag);\n+  }\n \n }\n",
            "diff_size": 574
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "90",
                    "severity": "error",
                    "message": "Line is longer than 120 characters (found 121).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "142",
                    "severity": "error",
                    "message": "Line is longer than 120 characters (found 143).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/330/AttributeDesignator.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/naturalize/330/AttributeDesignator.java\nindex 5f28bd9f4ab..4177d83fb34 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/330/AttributeDesignator.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/naturalize/330/AttributeDesignator.java\n@@ -139,10 +139,8 @@ public class AttributeDesignator implements Evaluatable {\n      * \n      * @throws IllegalArgumentException if the input target isn't a valid value\n      */\n-    public AttributeDesignator(int target, URI type, URI id, boolean mustBePresent, URI issuer,\n-                               URI category) throws IllegalArgumentException {\n-\n-        // check if input target is a valid value\n+    public AttributeDesignator(int target, URI type, URI id, boolean mustBePresent, URI issuer, URI category) throws IllegalArgumentException {\n+// check if input target is a valid value\n         if ((target != SUBJECT_TARGET) && (target != RESOURCE_TARGET) && (target != ACTION_TARGET)\n                 && (target != ENVIRONMENT_TARGET))\n             throw new IllegalArgumentException(\"Input target is not a valid\" + \"value\");\n@@ -226,10 +224,9 @@ public class AttributeDesignator implements Evaluatable {\n                 } else if(XACMLConstants.ACTION_CATEGORY.equals(category.toString())){\n                     target = ACTION_TARGET;\n                 } else if(XACMLConstants.ENT_CATEGORY.equals(category.toString())){\n-                    target = ENVIRONMENT_TARGET;   \n-                }\n-\n-            } catch (Exception e) {\n+                    target = ENVIRONMENT_TARGET;\n+   }\n+       } catch (Exception e) {\n                 throw new ParsingException(\"Required Category missing in \" + \"AttributeDesignator\", e);\n             }\n \n@@ -417,8 +414,7 @@ public class AttributeDesignator implements Evaluatable {\n                 ArrayList code = new ArrayList();\n                 code.add(Status.STATUS_MISSING_ATTRIBUTE);\n \n-                String message = \"Couldn't find \" + targetTypes[target]\n-                        + \"AttributeDesignator attribute\";\n+                String message = \"Couldn't find \" + targetTypes[target] + \"AttributeDesignator attribute\";\n \n                 // Note that there is a bug in the XACML spec. You can't\n                 // specify an identifier without specifying acceptable\n@@ -481,4 +477,4 @@ public class AttributeDesignator implements Evaluatable {\n         out.println(indent + tag);\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 11
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/330/AttributeDesignator.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler_random/330/AttributeDesignator.java\nindex 5f28bd9f4ab..99a05545059 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/330/AttributeDesignator.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler_random/330/AttributeDesignator.java\n@@ -87,10 +87,11 @@ public class AttributeDesignator implements Evaluatable {\n     /**\n      * The standard URI for the default subject category value\n      */\n-    public static final String SUBJECT_CATEGORY_DEFAULT = \"urn:oasis:names:tc:xacml:1.0:subject-category:access-subject\";\n+    public static final String SUBJECT_CATEGORY_DEFAULT =\n+\t\t\t\t\t\"urn:oasis:names:tc:xacml:1.0:subject-category:access-subject\";\n \n-    // helper array of strings\n-    static final private String[] targetTypes = { \"Subject\", \"Resource\", \"Action\", \"Environment\" };\n+     // helper array of strings\n+     static final private String[] targetTypes = { \"Subject\", \"Resource\", \"Action\", \"Environment\" };\n \n     // the type of designator we are\n     private int target;\n",
            "diff_size": 4
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/330/AttributeDesignator.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler_three_grams/330/AttributeDesignator.java\nindex 5f28bd9f4ab..3f002017da8 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/330/AttributeDesignator.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler_three_grams/330/AttributeDesignator.java\n@@ -87,10 +87,11 @@ public class AttributeDesignator implements Evaluatable {\n     /**\n      * The standard URI for the default subject category value\n      */\n-    public static final String SUBJECT_CATEGORY_DEFAULT = \"urn:oasis:names:tc:xacml:1.0:subject-category:access-subject\";\n+    public static final String\n+        SUBJECT_CATEGORY_DEFAULT = \"urn:oasis:names:tc:xacml:1.0:subject-category:access-subject\";\n \n-    // helper array of strings\n-    static final private String[] targetTypes = { \"Subject\", \"Resource\", \"Action\", \"Environment\" };\n+     // helper array of strings\n+     static final private String[] targetTypes = { \"Subject\", \"Resource\", \"Action\", \"Environment\" };\n \n     // the type of designator we are\n     private int target;\n",
            "diff_size": 4
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "naturalize",
        "codebuff"
    ]
}