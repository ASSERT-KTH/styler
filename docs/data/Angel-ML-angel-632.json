{
    "project_name": "Angel-ML-angel",
    "error_id": "632",
    "information": {
        "errors": [
            {
                "line": "6",
                "severity": "error",
                "message": "Line is longer than 100 characters (found 102).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": " * Copyright (C) 2017-2018 THL A29 Limited, a Tencent company. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in\n * compliance with the License. You may obtain a copy of the License at\n *\n * https://opensource.org/licenses/Apache-2.0",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "134",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "224",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "337",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "450",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "563",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "633",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "723",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "836",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "949",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1019",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1109",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1222",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1292",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1382",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1468",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1521",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1597",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1673",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1749",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1813",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1866",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1942",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "2018",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "2082",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "2135",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "2211",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "2275",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "2328",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Angel-ML-angel/errored/1/632/SimpleDotExecutor.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Angel-ML-angel/naturalize/632/SimpleDotExecutor.java\nindex c17d34f942d..e353ea2688f 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Angel-ML-angel/errored/1/632/SimpleDotExecutor.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Angel-ML-angel/naturalize/632/SimpleDotExecutor.java\n@@ -15,7 +15,6 @@\n  *\n  */\n \n-\n package com.tencent.angel.ml.math2.ufuncs.executor.simple;\n \n import com.tencent.angel.exception.AngelException;\n@@ -132,9 +131,8 @@ public class SimpleDotExecutor {\n         dot += v1Values[idxs[i]];\n       }\n     } else if (v1.isSparse()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+  ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Int2DoubleMap.Entry entry = iter.next();\n           dot += entry.getDoubleValue() * v2.get(entry.getIntKey());\n@@ -223,9 +221,8 @@ public class SimpleDotExecutor {\n         }\n       }\n     } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+  ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Int2DoubleMap.Entry entry = iter.next();\n           dot += entry.getDoubleValue() * v2.get(entry.getIntKey());\n@@ -241,7 +238,7 @@ public class SimpleDotExecutor {\n     } else if (v1.isSorted() && v2.isSparse()) {\n       if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n           && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2DoubleMap.Entry> iter = v2.getStorage().entryIterator();\n+  ObjectIterator<Int2DoubleMap.Entry> iter = v2.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Int2DoubleMap.Entry entry = iter.next();\n           dot += entry.getDoubleValue() * v1.get(entry.getIntKey());\n@@ -337,9 +334,8 @@ public class SimpleDotExecutor {\n         }\n       }\n     } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+  ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Int2DoubleMap.Entry entry = iter.next();\n           dot += entry.getDoubleValue() * v2.get(entry.getIntKey());\n@@ -355,7 +351,7 @@ public class SimpleDotExecutor {\n     } else if (v1.isSorted() && v2.isSparse()) {\n       if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n           && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2FloatMap.Entry> iter = v2.getStorage().entryIterator();\n+  ObjectIterator<Int2FloatMap.Entry> iter = v2.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Int2FloatMap.Entry entry = iter.next();\n           dot += entry.getFloatValue() * v1.get(entry.getIntKey());\n@@ -451,9 +447,8 @@ public class SimpleDotExecutor {\n         }\n       }\n     } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+  ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Int2DoubleMap.Entry entry = iter.next();\n           dot += entry.getDoubleValue() * v2.get(entry.getIntKey());\n@@ -469,7 +464,7 @@ public class SimpleDotExecutor {\n     } else if (v1.isSorted() && v2.isSparse()) {\n       if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n           && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2LongMap.Entry> iter = v2.getStorage().entryIterator();\n+  ObjectIterator<Int2LongMap.Entry> iter = v2.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Int2LongMap.Entry entry = iter.next();\n           dot += entry.getLongValue() * v1.get(entry.getIntKey());\n@@ -565,9 +560,8 @@ public class SimpleDotExecutor {\n         }\n       }\n     } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+  ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Int2DoubleMap.Entry entry = iter.next();\n           dot += entry.getDoubleValue() * v2.get(entry.getIntKey());\n@@ -583,7 +577,7 @@ public class SimpleDotExecutor {\n     } else if (v1.isSorted() && v2.isSparse()) {\n       if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n           && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n+  ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Int2IntMap.Entry entry = iter.next();\n           dot += entry.getIntValue() * v1.get(entry.getIntKey());\n@@ -636,9 +630,8 @@ public class SimpleDotExecutor {\n         dot += v1Values[idxs[i]];\n       }\n     } else if (v1.isSparse()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+  ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Int2FloatMap.Entry entry = iter.next();\n           dot += entry.getFloatValue() * v2.get(entry.getIntKey());\n@@ -727,9 +720,8 @@ public class SimpleDotExecutor {\n         }\n       }\n     } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+  ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Int2FloatMap.Entry entry = iter.next();\n           dot += entry.getFloatValue() * v2.get(entry.getIntKey());\n@@ -745,7 +737,7 @@ public class SimpleDotExecutor {\n     } else if (v1.isSorted() && v2.isSparse()) {\n       if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n           && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2FloatMap.Entry> iter = v2.getStorage().entryIterator();\n+  ObjectIterator<Int2FloatMap.Entry> iter = v2.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Int2FloatMap.Entry entry = iter.next();\n           dot += entry.getFloatValue() * v1.get(entry.getIntKey());\n@@ -841,9 +833,8 @@ public class SimpleDotExecutor {\n         }\n       }\n     } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+  ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Int2FloatMap.Entry entry = iter.next();\n           dot += entry.getFloatValue() * v2.get(entry.getIntKey());\n@@ -859,7 +850,7 @@ public class SimpleDotExecutor {\n     } else if (v1.isSorted() && v2.isSparse()) {\n       if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n           && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2LongMap.Entry> iter = v2.getStorage().entryIterator();\n+  ObjectIterator<Int2LongMap.Entry> iter = v2.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Int2LongMap.Entry entry = iter.next();\n           dot += entry.getLongValue() * v1.get(entry.getIntKey());\n@@ -955,9 +946,8 @@ public class SimpleDotExecutor {\n         }\n       }\n     } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+  ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Int2FloatMap.Entry entry = iter.next();\n           dot += entry.getFloatValue() * v2.get(entry.getIntKey());\n@@ -973,7 +963,7 @@ public class SimpleDotExecutor {\n     } else if (v1.isSorted() && v2.isSparse()) {\n       if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n           && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n+  ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Int2IntMap.Entry entry = iter.next();\n           dot += entry.getIntValue() * v1.get(entry.getIntKey());\n@@ -1026,9 +1016,8 @@ public class SimpleDotExecutor {\n         dot += v1Values[idxs[i]];\n       }\n     } else if (v1.isSparse()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2LongMap.Entry> iter = v1.getStorage().entryIterator();\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+  ObjectIterator<Int2LongMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Int2LongMap.Entry entry = iter.next();\n           dot += entry.getLongValue() * v2.get(entry.getIntKey());\n@@ -1117,9 +1106,8 @@ public class SimpleDotExecutor {\n         }\n       }\n     } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2LongMap.Entry> iter = v1.getStorage().entryIterator();\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+  ObjectIterator<Int2LongMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Int2LongMap.Entry entry = iter.next();\n           dot += entry.getLongValue() * v2.get(entry.getIntKey());\n@@ -1135,7 +1123,7 @@ public class SimpleDotExecutor {\n     } else if (v1.isSorted() && v2.isSparse()) {\n       if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n           && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2LongMap.Entry> iter = v2.getStorage().entryIterator();\n+  ObjectIterator<Int2LongMap.Entry> iter = v2.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Int2LongMap.Entry entry = iter.next();\n           dot += entry.getLongValue() * v1.get(entry.getIntKey());\n@@ -1231,9 +1219,8 @@ public class SimpleDotExecutor {\n         }\n       }\n     } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2LongMap.Entry> iter = v1.getStorage().entryIterator();\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+  ObjectIterator<Int2LongMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Int2LongMap.Entry entry = iter.next();\n           dot += entry.getLongValue() * v2.get(entry.getIntKey());\n@@ -1249,7 +1236,7 @@ public class SimpleDotExecutor {\n     } else if (v1.isSorted() && v2.isSparse()) {\n       if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n           && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n+  ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Int2IntMap.Entry entry = iter.next();\n           dot += entry.getIntValue() * v1.get(entry.getIntKey());\n@@ -1302,9 +1289,8 @@ public class SimpleDotExecutor {\n         dot += v1Values[idxs[i]];\n       }\n     } else if (v1.isSparse()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2IntMap.Entry> iter = v1.getStorage().entryIterator();\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+  ObjectIterator<Int2IntMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Int2IntMap.Entry entry = iter.next();\n           dot += entry.getIntValue() * v2.get(entry.getIntKey());\n@@ -1393,9 +1379,8 @@ public class SimpleDotExecutor {\n         }\n       }\n     } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2IntMap.Entry> iter = v1.getStorage().entryIterator();\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+  ObjectIterator<Int2IntMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Int2IntMap.Entry entry = iter.next();\n           dot += entry.getIntValue() * v2.get(entry.getIntKey());\n@@ -1411,7 +1396,7 @@ public class SimpleDotExecutor {\n     } else if (v1.isSorted() && v2.isSparse()) {\n       if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n           && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n+  ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Int2IntMap.Entry entry = iter.next();\n           dot += entry.getIntValue() * v1.get(entry.getIntKey());\n@@ -1480,9 +1465,8 @@ public class SimpleDotExecutor {\n     double dot = 0.0;\n     long[] idxs = v2.getIndices();\n     if (v1.isSparse()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+  ObjectIterator<Long2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Long2DoubleMap.Entry entry = iter.next();\n           dot += entry.getDoubleValue() * v2.get(entry.getLongKey());\n@@ -1534,9 +1518,8 @@ public class SimpleDotExecutor {\n         }\n       }\n     } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+  ObjectIterator<Long2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Long2DoubleMap.Entry entry = iter.next();\n           dot += entry.getDoubleValue() * v2.get(entry.getLongKey());\n@@ -1552,7 +1535,7 @@ public class SimpleDotExecutor {\n     } else if (v1.isSorted() && v2.isSparse()) {\n       if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n           && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2DoubleMap.Entry> iter = v2.getStorage().entryIterator();\n+  ObjectIterator<Long2DoubleMap.Entry> iter = v2.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Long2DoubleMap.Entry entry = iter.next();\n           dot += entry.getDoubleValue() * v1.get(entry.getLongKey());\n@@ -1611,9 +1594,8 @@ public class SimpleDotExecutor {\n         }\n       }\n     } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+  ObjectIterator<Long2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Long2DoubleMap.Entry entry = iter.next();\n           dot += entry.getDoubleValue() * v2.get(entry.getLongKey());\n@@ -1629,7 +1611,7 @@ public class SimpleDotExecutor {\n     } else if (v1.isSorted() && v2.isSparse()) {\n       if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n           && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2FloatMap.Entry> iter = v2.getStorage().entryIterator();\n+  ObjectIterator<Long2FloatMap.Entry> iter = v2.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Long2FloatMap.Entry entry = iter.next();\n           dot += entry.getFloatValue() * v1.get(entry.getLongKey());\n@@ -1688,9 +1670,8 @@ public class SimpleDotExecutor {\n         }\n       }\n     } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+  ObjectIterator<Long2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Long2DoubleMap.Entry entry = iter.next();\n           dot += entry.getDoubleValue() * v2.get(entry.getLongKey());\n@@ -1706,7 +1687,7 @@ public class SimpleDotExecutor {\n     } else if (v1.isSorted() && v2.isSparse()) {\n       if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n           && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2LongMap.Entry> iter = v2.getStorage().entryIterator();\n+  ObjectIterator<Long2LongMap.Entry> iter = v2.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Long2LongMap.Entry entry = iter.next();\n           dot += entry.getLongValue() * v1.get(entry.getLongKey());\n@@ -1765,9 +1746,8 @@ public class SimpleDotExecutor {\n         }\n       }\n     } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+  ObjectIterator<Long2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Long2DoubleMap.Entry entry = iter.next();\n           dot += entry.getDoubleValue() * v2.get(entry.getLongKey());\n@@ -1783,7 +1763,7 @@ public class SimpleDotExecutor {\n     } else if (v1.isSorted() && v2.isSparse()) {\n       if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n           && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2IntMap.Entry> iter = v2.getStorage().entryIterator();\n+  ObjectIterator<Long2IntMap.Entry> iter = v2.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Long2IntMap.Entry entry = iter.next();\n           dot += entry.getIntValue() * v1.get(entry.getLongKey());\n@@ -1830,9 +1810,8 @@ public class SimpleDotExecutor {\n     double dot = 0.0;\n     long[] idxs = v2.getIndices();\n     if (v1.isSparse()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+  ObjectIterator<Long2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Long2FloatMap.Entry entry = iter.next();\n           dot += entry.getFloatValue() * v2.get(entry.getLongKey());\n@@ -1884,9 +1863,8 @@ public class SimpleDotExecutor {\n         }\n       }\n     } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+  ObjectIterator<Long2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Long2FloatMap.Entry entry = iter.next();\n           dot += entry.getFloatValue() * v2.get(entry.getLongKey());\n@@ -1902,7 +1880,7 @@ public class SimpleDotExecutor {\n     } else if (v1.isSorted() && v2.isSparse()) {\n       if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n           && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2FloatMap.Entry> iter = v2.getStorage().entryIterator();\n+  ObjectIterator<Long2FloatMap.Entry> iter = v2.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Long2FloatMap.Entry entry = iter.next();\n           dot += entry.getFloatValue() * v1.get(entry.getLongKey());\n@@ -1961,9 +1939,8 @@ public class SimpleDotExecutor {\n         }\n       }\n     } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+  ObjectIterator<Long2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Long2FloatMap.Entry entry = iter.next();\n           dot += entry.getFloatValue() * v2.get(entry.getLongKey());\n@@ -1979,7 +1956,7 @@ public class SimpleDotExecutor {\n     } else if (v1.isSorted() && v2.isSparse()) {\n       if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n           && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2LongMap.Entry> iter = v2.getStorage().entryIterator();\n+  ObjectIterator<Long2LongMap.Entry> iter = v2.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Long2LongMap.Entry entry = iter.next();\n           dot += entry.getLongValue() * v1.get(entry.getLongKey());\n@@ -2038,9 +2015,8 @@ public class SimpleDotExecutor {\n         }\n       }\n     } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+  ObjectIterator<Long2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Long2FloatMap.Entry entry = iter.next();\n           dot += entry.getFloatValue() * v2.get(entry.getLongKey());\n@@ -2056,7 +2032,7 @@ public class SimpleDotExecutor {\n     } else if (v1.isSorted() && v2.isSparse()) {\n       if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n           && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2IntMap.Entry> iter = v2.getStorage().entryIterator();\n+  ObjectIterator<Long2IntMap.Entry> iter = v2.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Long2IntMap.Entry entry = iter.next();\n           dot += entry.getIntValue() * v1.get(entry.getLongKey());\n@@ -2103,9 +2079,8 @@ public class SimpleDotExecutor {\n     double dot = 0.0;\n     long[] idxs = v2.getIndices();\n     if (v1.isSparse()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2LongMap.Entry> iter = v1.getStorage().entryIterator();\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+  ObjectIterator<Long2LongMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Long2LongMap.Entry entry = iter.next();\n           dot += entry.getLongValue() * v2.get(entry.getLongKey());\n@@ -2157,9 +2132,8 @@ public class SimpleDotExecutor {\n         }\n       }\n     } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2LongMap.Entry> iter = v1.getStorage().entryIterator();\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+  ObjectIterator<Long2LongMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Long2LongMap.Entry entry = iter.next();\n           dot += entry.getLongValue() * v2.get(entry.getLongKey());\n@@ -2175,7 +2149,7 @@ public class SimpleDotExecutor {\n     } else if (v1.isSorted() && v2.isSparse()) {\n       if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n           && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2LongMap.Entry> iter = v2.getStorage().entryIterator();\n+  ObjectIterator<Long2LongMap.Entry> iter = v2.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Long2LongMap.Entry entry = iter.next();\n           dot += entry.getLongValue() * v1.get(entry.getLongKey());\n@@ -2234,9 +2208,8 @@ public class SimpleDotExecutor {\n         }\n       }\n     } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2LongMap.Entry> iter = v1.getStorage().entryIterator();\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+  ObjectIterator<Long2LongMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Long2LongMap.Entry entry = iter.next();\n           dot += entry.getLongValue() * v2.get(entry.getLongKey());\n@@ -2252,7 +2225,7 @@ public class SimpleDotExecutor {\n     } else if (v1.isSorted() && v2.isSparse()) {\n       if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n           && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2IntMap.Entry> iter = v2.getStorage().entryIterator();\n+  ObjectIterator<Long2IntMap.Entry> iter = v2.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Long2IntMap.Entry entry = iter.next();\n           dot += entry.getIntValue() * v1.get(entry.getLongKey());\n@@ -2299,9 +2272,8 @@ public class SimpleDotExecutor {\n     double dot = 0.0;\n     long[] idxs = v2.getIndices();\n     if (v1.isSparse()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2IntMap.Entry> iter = v1.getStorage().entryIterator();\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+  ObjectIterator<Long2IntMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Long2IntMap.Entry entry = iter.next();\n           dot += entry.getIntValue() * v2.get(entry.getLongKey());\n@@ -2353,9 +2325,8 @@ public class SimpleDotExecutor {\n         }\n       }\n     } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2IntMap.Entry> iter = v1.getStorage().entryIterator();\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+  ObjectIterator<Long2IntMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Long2IntMap.Entry entry = iter.next();\n           dot += entry.getIntValue() * v2.get(entry.getLongKey());\n@@ -2371,7 +2342,7 @@ public class SimpleDotExecutor {\n     } else if (v1.isSorted() && v2.isSparse()) {\n       if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n           && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2IntMap.Entry> iter = v2.getStorage().entryIterator();\n+  ObjectIterator<Long2IntMap.Entry> iter = v2.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Long2IntMap.Entry entry = iter.next();\n           dot += entry.getIntValue() * v1.get(entry.getLongKey());\n@@ -2413,4 +2384,4 @@ public class SimpleDotExecutor {\n     return dot;\n   }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 106
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "55",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 104).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "57",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 103).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "59",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 112).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "60",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "61",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 109).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "63",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 118).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "64",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 108).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "65",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 120).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "66",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 110).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "67",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 131).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "68",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 121).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "69",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 130).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "70",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 120).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "71",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 136).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "72",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 126).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "73",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 135).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "74",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "75",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 144).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "76",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 134).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "77",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 143).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "78",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 133).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "79",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 149).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "80",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 139).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "81",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 148).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "82",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 138).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "83",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 157).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "84",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 147).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "85",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 155).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "86",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 145).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "87",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 161).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "88",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 151).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "89",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 163).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "90",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 153).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "91",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 167).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "92",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 157).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "93",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 169).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "94",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 159).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "95",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 178).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "96",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 168).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "97",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 110).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "98",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 160).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "99",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 103).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "134",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "222",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 146).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "223",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 104).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "237",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 146).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "238",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 104).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "331",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 146).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "332",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 104).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "346",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 146).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "347",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 103).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "440",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 146).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "441",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 104).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "455",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 146).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "456",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "549",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 146).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "550",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 104).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "564",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 146).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "565",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 101).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "615",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "703",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 146).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "704",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 103).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "718",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 146).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "719",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 103).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "812",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 146).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "813",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 103).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "827",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 146).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "828",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "921",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 146).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "922",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 103).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "936",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 146).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "937",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 101).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "987",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1075",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 146).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1076",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1090",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 146).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1091",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1184",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 146).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1185",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1199",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 146).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1200",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 101).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1250",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1338",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 146).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1339",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 101).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1353",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 146).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1354",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 101).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1419",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1470",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1485",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 132).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1542",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1557",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 132).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1614",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1629",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 132).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1686",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1701",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 132).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1746",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1797",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1812",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 132).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1869",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1884",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 132).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1941",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1956",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 132).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "2001",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "2052",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "2067",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 132).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "2124",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "2139",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 132).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "2184",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "2235",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "2250",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 132).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Angel-ML-angel/errored/1/632/SimpleDotExecutor.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Angel-ML-angel/codebuff/632/SimpleDotExecutor.java\nindex c17d34f942d..007d66bf553 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Angel-ML-angel/errored/1/632/SimpleDotExecutor.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Angel-ML-angel/codebuff/632/SimpleDotExecutor.java\n@@ -37,66 +37,66 @@ public class SimpleDotExecutor {\n     if (v1 instanceof IntDoubleVector && v2 instanceof IntDoubleVector) {\n       return apply((IntDoubleVector) v1, (IntDoubleVector) v2);\n     } else if (v1 instanceof IntDoubleVector && v2 instanceof IntFloatVector) {\n-      return apply((IntDoubleVector) v1, (IntFloatVector) v2);\n+             return apply((IntDoubleVector) v1, (IntFloatVector) v2);\n     } else if (v1 instanceof IntDoubleVector && v2 instanceof IntLongVector) {\n-      return apply((IntDoubleVector) v1, (IntLongVector) v2);\n-    } else if (v1 instanceof IntDoubleVector && v2 instanceof IntIntVector) {\n-      return apply((IntDoubleVector) v1, (IntIntVector) v2);\n-    } else if (v1 instanceof IntDoubleVector && v2 instanceof IntDummyVector) {\n-      return apply((IntDoubleVector) v1, (IntDummyVector) v2);\n-    } else if (v1 instanceof IntFloatVector && v2 instanceof IntFloatVector) {\n-      return apply((IntFloatVector) v1, (IntFloatVector) v2);\n-    } else if (v1 instanceof IntFloatVector && v2 instanceof IntLongVector) {\n-      return apply((IntFloatVector) v1, (IntLongVector) v2);\n-    } else if (v1 instanceof IntFloatVector && v2 instanceof IntIntVector) {\n-      return apply((IntFloatVector) v1, (IntIntVector) v2);\n-    } else if (v1 instanceof IntFloatVector && v2 instanceof IntDummyVector) {\n-      return apply((IntFloatVector) v1, (IntDummyVector) v2);\n-    } else if (v1 instanceof IntLongVector && v2 instanceof IntLongVector) {\n-      return apply((IntLongVector) v1, (IntLongVector) v2);\n-    } else if (v1 instanceof IntLongVector && v2 instanceof IntIntVector) {\n-      return apply((IntLongVector) v1, (IntIntVector) v2);\n-    } else if (v1 instanceof IntLongVector && v2 instanceof IntDummyVector) {\n-      return apply((IntLongVector) v1, (IntDummyVector) v2);\n-    } else if (v1 instanceof IntIntVector && v2 instanceof IntIntVector) {\n-      return apply((IntIntVector) v1, (IntIntVector) v2);\n-    } else if (v1 instanceof IntIntVector && v2 instanceof IntDummyVector) {\n-      return apply((IntIntVector) v1, (IntDummyVector) v2);\n-    } else if (v1 instanceof IntDummyVector && v2 instanceof IntDummyVector) {\n-      return apply((IntDummyVector) v1, (IntDummyVector) v2);\n-    } else if (v1 instanceof LongDoubleVector && v2 instanceof LongDoubleVector) {\n-      return apply((LongDoubleVector) v1, (LongDoubleVector) v2);\n-    } else if (v1 instanceof LongDoubleVector && v2 instanceof LongFloatVector) {\n-      return apply((LongDoubleVector) v1, (LongFloatVector) v2);\n-    } else if (v1 instanceof LongDoubleVector && v2 instanceof LongLongVector) {\n-      return apply((LongDoubleVector) v1, (LongLongVector) v2);\n-    } else if (v1 instanceof LongDoubleVector && v2 instanceof LongIntVector) {\n-      return apply((LongDoubleVector) v1, (LongIntVector) v2);\n-    } else if (v1 instanceof LongDoubleVector && v2 instanceof LongDummyVector) {\n-      return apply((LongDoubleVector) v1, (LongDummyVector) v2);\n-    } else if (v1 instanceof LongFloatVector && v2 instanceof LongFloatVector) {\n-      return apply((LongFloatVector) v1, (LongFloatVector) v2);\n-    } else if (v1 instanceof LongFloatVector && v2 instanceof LongLongVector) {\n-      return apply((LongFloatVector) v1, (LongLongVector) v2);\n-    } else if (v1 instanceof LongFloatVector && v2 instanceof LongIntVector) {\n-      return apply((LongFloatVector) v1, (LongIntVector) v2);\n-    } else if (v1 instanceof LongFloatVector && v2 instanceof LongDummyVector) {\n-      return apply((LongFloatVector) v1, (LongDummyVector) v2);\n-    } else if (v1 instanceof LongLongVector && v2 instanceof LongLongVector) {\n-      return apply((LongLongVector) v1, (LongLongVector) v2);\n-    } else if (v1 instanceof LongLongVector && v2 instanceof LongIntVector) {\n-      return apply((LongLongVector) v1, (LongIntVector) v2);\n-    } else if (v1 instanceof LongLongVector && v2 instanceof LongDummyVector) {\n-      return apply((LongLongVector) v1, (LongDummyVector) v2);\n-    } else if (v1 instanceof LongIntVector && v2 instanceof LongIntVector) {\n-      return apply((LongIntVector) v1, (LongIntVector) v2);\n-    } else if (v1 instanceof LongIntVector && v2 instanceof LongDummyVector) {\n-      return apply((LongIntVector) v1, (LongDummyVector) v2);\n-    } else if (v1 instanceof LongDummyVector && v2 instanceof LongDummyVector) {\n-      return apply((LongDummyVector) v1, (LongDummyVector) v2);\n-    } else {\n-      throw new AngelException(\"Vector type is not support!\");\n-    }\n+             return apply((IntDoubleVector) v1, (IntLongVector) v2);\n+           } else if (v1 instanceof IntDoubleVector && v2 instanceof IntIntVector) {\n+                    return apply((IntDoubleVector) v1, (IntIntVector) v2);\n+           } else if (v1 instanceof IntDoubleVector && v2 instanceof IntDummyVector) {\n+                    return apply((IntDoubleVector) v1, (IntDummyVector) v2);\n+                  } else if (v1 instanceof IntFloatVector && v2 instanceof IntFloatVector) {\n+                           return apply((IntFloatVector) v1, (IntFloatVector) v2);\n+                  } else if (v1 instanceof IntFloatVector && v2 instanceof IntLongVector) {\n+                           return apply((IntFloatVector) v1, (IntLongVector) v2);\n+                         } else if (v1 instanceof IntFloatVector && v2 instanceof IntIntVector) {\n+                                  return apply((IntFloatVector) v1, (IntIntVector) v2);\n+                         } else if (v1 instanceof IntFloatVector && v2 instanceof IntDummyVector) {\n+                                  return apply((IntFloatVector) v1, (IntDummyVector) v2);\n+                                } else if (v1 instanceof IntLongVector && v2 instanceof IntLongVector) {\n+                                         return apply((IntLongVector) v1, (IntLongVector) v2);\n+                                } else if (v1 instanceof IntLongVector && v2 instanceof IntIntVector) {\n+                                         return apply((IntLongVector) v1, (IntIntVector) v2);\n+                                       } else if (v1 instanceof IntLongVector && v2 instanceof IntDummyVector) {\n+                                                return apply((IntLongVector) v1, (IntDummyVector) v2);\n+                                       } else if (v1 instanceof IntIntVector && v2 instanceof IntIntVector) {\n+                                                return apply((IntIntVector) v1, (IntIntVector) v2);\n+                                              } else if (v1 instanceof IntIntVector && v2 instanceof IntDummyVector) {\n+                                                       return apply((IntIntVector) v1, (IntDummyVector) v2);\n+                                              } else if (v1 instanceof IntDummyVector && v2 instanceof IntDummyVector) {\n+                                                       return apply((IntDummyVector) v1, (IntDummyVector) v2);\n+                                                     } else if (v1 instanceof LongDoubleVector && v2 instanceof LongDoubleVector) {\n+                                                              return apply((LongDoubleVector) v1, (LongDoubleVector) v2);\n+                                                     } else if (v1 instanceof LongDoubleVector && v2 instanceof LongFloatVector) {\n+                                                              return apply((LongDoubleVector) v1, (LongFloatVector) v2);\n+                                                            } else if (v1 instanceof LongDoubleVector && v2 instanceof LongLongVector) {\n+                                                                     return apply((LongDoubleVector) v1, (LongLongVector) v2);\n+                                                            } else if (v1 instanceof LongDoubleVector && v2 instanceof LongIntVector) {\n+                                                                     return apply((LongDoubleVector) v1, (LongIntVector) v2);\n+                                                                   } else if (v1 instanceof LongDoubleVector && v2 instanceof LongDummyVector) {\n+                                                                            return apply((LongDoubleVector) v1, (LongDummyVector) v2);\n+                                                                   } else if (v1 instanceof LongFloatVector && v2 instanceof LongFloatVector) {\n+                                                                            return apply((LongFloatVector) v1, (LongFloatVector) v2);\n+                                                                          } else if (v1 instanceof LongFloatVector && v2 instanceof LongLongVector) {\n+                                                                                   return apply((LongFloatVector) v1, (LongLongVector) v2);\n+                                                                          } else if (v1 instanceof LongFloatVector && v2 instanceof LongIntVector) {\n+                                                                                   return apply((LongFloatVector) v1, (LongIntVector) v2);\n+                                                                                 } else if (v1 instanceof LongFloatVector && v2 instanceof LongDummyVector) {\n+                                                                                          return apply((LongFloatVector) v1, (LongDummyVector) v2);\n+                                                                                 } else if (v1 instanceof LongLongVector && v2 instanceof LongLongVector) {\n+                                                                                          return apply((LongLongVector) v1, (LongLongVector) v2);\n+                                                                                        } else if (v1 instanceof LongLongVector && v2 instanceof LongIntVector) {\n+                                                                                                 return apply((LongLongVector) v1, (LongIntVector) v2);\n+                                                                                        } else if (v1 instanceof LongLongVector && v2 instanceof LongDummyVector) {\n+                                                                                                 return apply((LongLongVector) v1, (LongDummyVector) v2);\n+                                                                                               } else if (v1 instanceof LongIntVector && v2 instanceof LongIntVector) {\n+                                                                                                        return apply((LongIntVector) v1, (LongIntVector) v2);\n+                                                                                               } else if (v1 instanceof LongIntVector && v2 instanceof LongDummyVector) {\n+                                                                                                        return apply((LongIntVector) v1, (LongDummyVector) v2);\n+                                                                                                      } else if (v1 instanceof LongDummyVector && v2 instanceof LongDummyVector) {\n+                                                                                                               return apply((LongDummyVector) v1, (LongDummyVector) v2);\n+                                                                                                      } else {\n+                                                                                                        throw new AngelException(\"Vector type is not support!\");\n+                                                                                                      }\n   }\n \n   private static double apply(IntDummyVector v1, IntDummyVector v2) {\n@@ -106,16 +106,15 @@ public class SimpleDotExecutor {\n     int[] keys2 = v2.getIndices();\n     int v1Pointor = 0;\n     int v2Pointor = 0;\n-\n     while (v1Pointor < keys1.length && v2Pointor < keys2.length) {\n       if (keys1[v1Pointor] == keys2[v2Pointor]) {\n         dot += 1.0;\n         v2Pointor++;\n         v1Pointor++;\n       } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n-        v2Pointor++;\n+               v2Pointor++;\n       } else {\n-        v1Pointor++;\n+               v1Pointor++;\n       }\n     }\n     return dot;\n@@ -132,8 +131,7 @@ public class SimpleDotExecutor {\n         dot += v1Values[idxs[i]];\n       }\n     } else if (v1.isSparse()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n         ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Int2DoubleMap.Entry entry = iter.next();\n@@ -148,21 +146,19 @@ public class SimpleDotExecutor {\n     } else {\n       int[] keys1 = v1.getStorage().getIndices();\n       double[] v1Values = v1.getStorage().getValues();\n-\n       int v1Pointor = 0;\n       int v2Pointor = 0;\n       int size1 = v1.size();\n       int size2 = v2.size();\n-\n       while (v1Pointor < size1 && v2Pointor < size2) {\n         if (keys1[v1Pointor] == idxs[v2Pointor]) {\n           dot += v1Values[v1Pointor];\n           v2Pointor++;\n           v1Pointor++;\n         } else if (keys1[v1Pointor] > idxs[v2Pointor]) {\n-          v2Pointor++;\n+                 v2Pointor++;\n         } else {\n-          v1Pointor++;\n+                 v1Pointor++;\n         }\n       }\n     }\n@@ -186,100 +182,95 @@ public class SimpleDotExecutor {\n         dot += entry.getDoubleValue() * v1Values[entry.getIntKey()];\n       }\n     } else if (v1.isDense() && v2.isSorted()) {\n-      double[] v1Values = v1.getStorage().getValues();\n-      int[] keys = v2.getStorage().getIndices();\n-      double[] v2Values = v2.getStorage().getValues();\n-      int size = v2.size();\n-      for (int i = 0; i < size; i++) {\n-        dot += v2Values[i] * v1Values[keys[i]];\n-      }\n-    } else if (v1.isSparse() && v2.isDense()) {\n-      double[] v2Values = v2.getStorage().getValues();\n-      ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n-      while (iter.hasNext()) {\n-        Int2DoubleMap.Entry entry = iter.next();\n-        dot += entry.getDoubleValue() * v2Values[entry.getIntKey()];\n-      }\n-    } else if (v1.isSorted() && v2.isDense()) {\n-      int[] keys = v1.getStorage().getIndices();\n-      double[] v1Values = v1.getStorage().getValues();\n-      double[] v2Values = v2.getStorage().getValues();\n-      int size = v1.size();\n-      for (int i = 0; i < size; i++) {\n-        dot += v1Values[i] * v2Values[keys[i]];\n-      }\n-    } else if (v1.isSparse() && v2.isSparse()) {\n-      if (v1.size() < v2.size()) {\n-        ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2DoubleMap.Entry entry = iter.next();\n-          dot += entry.getDoubleValue() * v2.get(entry.getIntKey());\n-        }\n-      } else {\n-        ObjectIterator<Int2DoubleMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2DoubleMap.Entry entry = iter.next();\n-          dot += entry.getDoubleValue() * v1.get(entry.getIntKey());\n-        }\n-      }\n-    } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2DoubleMap.Entry entry = iter.next();\n-          dot += entry.getDoubleValue() * v2.get(entry.getIntKey());\n-        }\n-      } else {\n-        int[] keys = v2.getStorage().getIndices();\n-        double[] v2Values = v2.getStorage().getValues();\n-        int size = v2.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v2Values[i] * v1.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSparse()) {\n-      if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n-          && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2DoubleMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2DoubleMap.Entry entry = iter.next();\n-          dot += entry.getDoubleValue() * v1.get(entry.getIntKey());\n-        }\n-      } else {\n-        int[] keys = v1.getStorage().getIndices();\n-        double[] v1Values = v1.getStorage().getValues();\n-        int size = v1.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v1Values[i] * v2.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSorted()) {\n-      int[] keys1 = v1.getStorage().getIndices();\n-      double[] v1Values = v1.getStorage().getValues();\n-      int[] keys2 = v2.getStorage().getIndices();\n-      double[] v2Values = v2.getStorage().getValues();\n-\n-      int v1Pointor = 0;\n-      int v2Pointor = 0;\n-      int size1 = v1.size();\n-      int size2 = v2.size();\n-\n-      while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n-          dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n-          v2Pointor++;\n-          v1Pointor++;\n-        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n-          v2Pointor++;\n-        } else {\n-          v1Pointor++;\n-        }\n-      }\n-    } else {\n-      throw new AngelException(\"the operation is not support!\");\n-    }\n-\n+             double[] v1Values = v1.getStorage().getValues();\n+             int[] keys = v2.getStorage().getIndices();\n+             double[] v2Values = v2.getStorage().getValues();\n+             int size = v2.size();\n+             for (int i = 0; i < size; i++) {\n+               dot += v2Values[i] * v1Values[keys[i]];\n+             }\n+           } else if (v1.isSparse() && v2.isDense()) {\n+             double[] v2Values = v2.getStorage().getValues();\n+             ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+             while (iter.hasNext()) {\n+               Int2DoubleMap.Entry entry = iter.next();\n+               dot += entry.getDoubleValue() * v2Values[entry.getIntKey()];\n+             }\n+           } else if (v1.isSorted() && v2.isDense()) {\n+                    int[] keys = v1.getStorage().getIndices();\n+                    double[] v1Values = v1.getStorage().getValues();\n+                    double[] v2Values = v2.getStorage().getValues();\n+                    int size = v1.size();\n+                    for (int i = 0; i < size; i++) {\n+                      dot += v1Values[i] * v2Values[keys[i]];\n+                    }\n+                  } else if (v1.isSparse() && v2.isSparse()) {\n+                    if (v1.size() < v2.size()) {\n+                      ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+                      while (iter.hasNext()) {\n+                        Int2DoubleMap.Entry entry = iter.next();\n+                        dot += entry.getDoubleValue() * v2.get(entry.getIntKey());\n+                      }\n+                    } else {\n+                      ObjectIterator<Int2DoubleMap.Entry> iter = v2.getStorage().entryIterator();\n+                      while (iter.hasNext()) {\n+                        Int2DoubleMap.Entry entry = iter.next();\n+                        dot += entry.getDoubleValue() * v1.get(entry.getIntKey());\n+                      }\n+                    }\n+                  } else if (v1.isSparse() && v2.isSorted()) {\n+                           if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+                             ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+                             while (iter.hasNext()) {\n+                               Int2DoubleMap.Entry entry = iter.next();\n+                               dot += entry.getDoubleValue() * v2.get(entry.getIntKey());\n+                             }\n+                           } else {\n+                             int[] keys = v2.getStorage().getIndices();\n+                             double[] v2Values = v2.getStorage().getValues();\n+                             int size = v2.size();\n+                             for (int i = 0; i < size; i++) {\n+                               dot += v2Values[i] * v1.get(keys[i]);\n+                             }\n+                           }\n+                         } else if (v1.isSorted() && v2.isSparse()) {\n+                           if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size() && v1.size() > Constant.sortedThreshold * v1.dim()) {\n+                             ObjectIterator<Int2DoubleMap.Entry> iter = v2.getStorage().entryIterator();\n+                             while (iter.hasNext()) {\n+                               Int2DoubleMap.Entry entry = iter.next();\n+                               dot += entry.getDoubleValue() * v1.get(entry.getIntKey());\n+                             }\n+                           } else {\n+                             int[] keys = v1.getStorage().getIndices();\n+                             double[] v1Values = v1.getStorage().getValues();\n+                             int size = v1.size();\n+                             for (int i = 0; i < size; i++) {\n+                               dot += v1Values[i] * v2.get(keys[i]);\n+                             }\n+                           }\n+                         } else if (v1.isSorted() && v2.isSorted()) {\n+                                  int[] keys1 = v1.getStorage().getIndices();\n+                                  double[] v1Values = v1.getStorage().getValues();\n+                                  int[] keys2 = v2.getStorage().getIndices();\n+                                  double[] v2Values = v2.getStorage().getValues();\n+                                  int v1Pointor = 0;\n+                                  int v2Pointor = 0;\n+                                  int size1 = v1.size();\n+                                  int size2 = v2.size();\n+                                  while (v1Pointor < size1 && v2Pointor < size2) {\n+                                    if (keys1[v1Pointor] == keys2[v2Pointor]) {\n+                                      dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n+                                      v2Pointor++;\n+                                      v1Pointor++;\n+                                    } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n+                                             v2Pointor++;\n+                                    } else {\n+                                             v1Pointor++;\n+                                    }\n+                                  }\n+                                } else {\n+                                  throw new AngelException(\"the operation is not support!\");\n+                                }\n     return dot;\n   }\n \n@@ -300,100 +291,95 @@ public class SimpleDotExecutor {\n         dot += entry.getFloatValue() * v1Values[entry.getIntKey()];\n       }\n     } else if (v1.isDense() && v2.isSorted()) {\n-      double[] v1Values = v1.getStorage().getValues();\n-      int[] keys = v2.getStorage().getIndices();\n-      float[] v2Values = v2.getStorage().getValues();\n-      int size = v2.size();\n-      for (int i = 0; i < size; i++) {\n-        dot += v2Values[i] * v1Values[keys[i]];\n-      }\n-    } else if (v1.isSparse() && v2.isDense()) {\n-      float[] v2Values = v2.getStorage().getValues();\n-      ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n-      while (iter.hasNext()) {\n-        Int2DoubleMap.Entry entry = iter.next();\n-        dot += entry.getDoubleValue() * v2Values[entry.getIntKey()];\n-      }\n-    } else if (v1.isSorted() && v2.isDense()) {\n-      int[] keys = v1.getStorage().getIndices();\n-      double[] v1Values = v1.getStorage().getValues();\n-      float[] v2Values = v2.getStorage().getValues();\n-      int size = v1.size();\n-      for (int i = 0; i < size; i++) {\n-        dot += v1Values[i] * v2Values[keys[i]];\n-      }\n-    } else if (v1.isSparse() && v2.isSparse()) {\n-      if (v1.size() < v2.size()) {\n-        ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2DoubleMap.Entry entry = iter.next();\n-          dot += entry.getDoubleValue() * v2.get(entry.getIntKey());\n-        }\n-      } else {\n-        ObjectIterator<Int2FloatMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2FloatMap.Entry entry = iter.next();\n-          dot += entry.getFloatValue() * v1.get(entry.getIntKey());\n-        }\n-      }\n-    } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2DoubleMap.Entry entry = iter.next();\n-          dot += entry.getDoubleValue() * v2.get(entry.getIntKey());\n-        }\n-      } else {\n-        int[] keys = v2.getStorage().getIndices();\n-        float[] v2Values = v2.getStorage().getValues();\n-        int size = v2.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v2Values[i] * v1.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSparse()) {\n-      if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n-          && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2FloatMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2FloatMap.Entry entry = iter.next();\n-          dot += entry.getFloatValue() * v1.get(entry.getIntKey());\n-        }\n-      } else {\n-        int[] keys = v1.getStorage().getIndices();\n-        double[] v1Values = v1.getStorage().getValues();\n-        int size = v1.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v1Values[i] * v2.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSorted()) {\n-      int[] keys1 = v1.getStorage().getIndices();\n-      double[] v1Values = v1.getStorage().getValues();\n-      int[] keys2 = v2.getStorage().getIndices();\n-      float[] v2Values = v2.getStorage().getValues();\n-\n-      int v1Pointor = 0;\n-      int v2Pointor = 0;\n-      int size1 = v1.size();\n-      int size2 = v2.size();\n-\n-      while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n-          dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n-          v2Pointor++;\n-          v1Pointor++;\n-        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n-          v2Pointor++;\n-        } else {\n-          v1Pointor++;\n-        }\n-      }\n-    } else {\n-      throw new AngelException(\"the operation is not support!\");\n-    }\n-\n+             double[] v1Values = v1.getStorage().getValues();\n+             int[] keys = v2.getStorage().getIndices();\n+             float[] v2Values = v2.getStorage().getValues();\n+             int size = v2.size();\n+             for (int i = 0; i < size; i++) {\n+               dot += v2Values[i] * v1Values[keys[i]];\n+             }\n+           } else if (v1.isSparse() && v2.isDense()) {\n+             float[] v2Values = v2.getStorage().getValues();\n+             ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+             while (iter.hasNext()) {\n+               Int2DoubleMap.Entry entry = iter.next();\n+               dot += entry.getDoubleValue() * v2Values[entry.getIntKey()];\n+             }\n+           } else if (v1.isSorted() && v2.isDense()) {\n+                    int[] keys = v1.getStorage().getIndices();\n+                    double[] v1Values = v1.getStorage().getValues();\n+                    float[] v2Values = v2.getStorage().getValues();\n+                    int size = v1.size();\n+                    for (int i = 0; i < size; i++) {\n+                      dot += v1Values[i] * v2Values[keys[i]];\n+                    }\n+                  } else if (v1.isSparse() && v2.isSparse()) {\n+                    if (v1.size() < v2.size()) {\n+                      ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+                      while (iter.hasNext()) {\n+                        Int2DoubleMap.Entry entry = iter.next();\n+                        dot += entry.getDoubleValue() * v2.get(entry.getIntKey());\n+                      }\n+                    } else {\n+                      ObjectIterator<Int2FloatMap.Entry> iter = v2.getStorage().entryIterator();\n+                      while (iter.hasNext()) {\n+                        Int2FloatMap.Entry entry = iter.next();\n+                        dot += entry.getFloatValue() * v1.get(entry.getIntKey());\n+                      }\n+                    }\n+                  } else if (v1.isSparse() && v2.isSorted()) {\n+                           if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+                             ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+                             while (iter.hasNext()) {\n+                               Int2DoubleMap.Entry entry = iter.next();\n+                               dot += entry.getDoubleValue() * v2.get(entry.getIntKey());\n+                             }\n+                           } else {\n+                             int[] keys = v2.getStorage().getIndices();\n+                             float[] v2Values = v2.getStorage().getValues();\n+                             int size = v2.size();\n+                             for (int i = 0; i < size; i++) {\n+                               dot += v2Values[i] * v1.get(keys[i]);\n+                             }\n+                           }\n+                         } else if (v1.isSorted() && v2.isSparse()) {\n+                           if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size() && v1.size() > Constant.sortedThreshold * v1.dim()) {\n+                             ObjectIterator<Int2FloatMap.Entry> iter = v2.getStorage().entryIterator();\n+                             while (iter.hasNext()) {\n+                               Int2FloatMap.Entry entry = iter.next();\n+                               dot += entry.getFloatValue() * v1.get(entry.getIntKey());\n+                             }\n+                           } else {\n+                             int[] keys = v1.getStorage().getIndices();\n+                             double[] v1Values = v1.getStorage().getValues();\n+                             int size = v1.size();\n+                             for (int i = 0; i < size; i++) {\n+                               dot += v1Values[i] * v2.get(keys[i]);\n+                             }\n+                           }\n+                         } else if (v1.isSorted() && v2.isSorted()) {\n+                                  int[] keys1 = v1.getStorage().getIndices();\n+                                  double[] v1Values = v1.getStorage().getValues();\n+                                  int[] keys2 = v2.getStorage().getIndices();\n+                                  float[] v2Values = v2.getStorage().getValues();\n+                                  int v1Pointor = 0;\n+                                  int v2Pointor = 0;\n+                                  int size1 = v1.size();\n+                                  int size2 = v2.size();\n+                                  while (v1Pointor < size1 && v2Pointor < size2) {\n+                                    if (keys1[v1Pointor] == keys2[v2Pointor]) {\n+                                      dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n+                                      v2Pointor++;\n+                                      v1Pointor++;\n+                                    } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n+                                             v2Pointor++;\n+                                    } else {\n+                                             v1Pointor++;\n+                                    }\n+                                  }\n+                                } else {\n+                                  throw new AngelException(\"the operation is not support!\");\n+                                }\n     return dot;\n   }\n \n@@ -414,880 +400,839 @@ public class SimpleDotExecutor {\n         dot += entry.getLongValue() * v1Values[entry.getIntKey()];\n       }\n     } else if (v1.isDense() && v2.isSorted()) {\n+             double[] v1Values = v1.getStorage().getValues();\n+             int[] keys = v2.getStorage().getIndices();\n+             long[] v2Values = v2.getStorage().getValues();\n+             int size = v2.size();\n+             for (int i = 0; i < size; i++) {\n+               dot += v2Values[i] * v1Values[keys[i]];\n+             }\n+           } else if (v1.isSparse() && v2.isDense()) {\n+             long[] v2Values = v2.getStorage().getValues();\n+             ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+             while (iter.hasNext()) {\n+               Int2DoubleMap.Entry entry = iter.next();\n+               dot += entry.getDoubleValue() * v2Values[entry.getIntKey()];\n+             }\n+           } else if (v1.isSorted() && v2.isDense()) {\n+                    int[] keys = v1.getStorage().getIndices();\n+                    double[] v1Values = v1.getStorage().getValues();\n+                    long[] v2Values = v2.getStorage().getValues();\n+                    int size = v1.size();\n+                    for (int i = 0; i < size; i++) {\n+                      dot += v1Values[i] * v2Values[keys[i]];\n+                    }\n+                  } else if (v1.isSparse() && v2.isSparse()) {\n+                    if (v1.size() < v2.size()) {\n+                      ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+                      while (iter.hasNext()) {\n+                        Int2DoubleMap.Entry entry = iter.next();\n+                        dot += entry.getDoubleValue() * v2.get(entry.getIntKey());\n+                      }\n+                    } else {\n+                      ObjectIterator<Int2LongMap.Entry> iter = v2.getStorage().entryIterator();\n+                      while (iter.hasNext()) {\n+                        Int2LongMap.Entry entry = iter.next();\n+                        dot += entry.getLongValue() * v1.get(entry.getIntKey());\n+                      }\n+                    }\n+                  } else if (v1.isSparse() && v2.isSorted()) {\n+                           if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+                             ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+                             while (iter.hasNext()) {\n+                               Int2DoubleMap.Entry entry = iter.next();\n+                               dot += entry.getDoubleValue() * v2.get(entry.getIntKey());\n+                             }\n+                           } else {\n+                             int[] keys = v2.getStorage().getIndices();\n+                             long[] v2Values = v2.getStorage().getValues();\n+                             int size = v2.size();\n+                             for (int i = 0; i < size; i++) {\n+                               dot += v2Values[i] * v1.get(keys[i]);\n+                             }\n+                           }\n+                         } else if (v1.isSorted() && v2.isSparse()) {\n+                           if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size() && v1.size() > Constant.sortedThreshold * v1.dim()) {\n+                             ObjectIterator<Int2LongMap.Entry> iter = v2.getStorage().entryIterator();\n+                             while (iter.hasNext()) {\n+                               Int2LongMap.Entry entry = iter.next();\n+                               dot += entry.getLongValue() * v1.get(entry.getIntKey());\n+                             }\n+                           } else {\n+                             int[] keys = v1.getStorage().getIndices();\n+                             double[] v1Values = v1.getStorage().getValues();\n+                             int size = v1.size();\n+                             for (int i = 0; i < size; i++) {\n+                               dot += v1Values[i] * v2.get(keys[i]);\n+                             }\n+                           }\n+                         } else if (v1.isSorted() && v2.isSorted()) {\n+                                  int[] keys1 = v1.getStorage().getIndices();\n+                                  double[] v1Values = v1.getStorage().getValues();\n+                                  int[] keys2 = v2.getStorage().getIndices();\n+                                  long[] v2Values = v2.getStorage().getValues();\n+                                  int v1Pointor = 0;\n+                                  int v2Pointor = 0;\n+                                  int size1 = v1.size();\n+                                  int size2 = v2.size();\n+                                  while (v1Pointor < size1 && v2Pointor < size2) {\n+                                    if (keys1[v1Pointor] == keys2[v2Pointor]) {\n+                                      dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n+                                      v2Pointor++;\n+                                      v1Pointor++;\n+                                    } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n+                                             v2Pointor++;\n+                                    } else {\n+                                             v1Pointor++;\n+                                    }\n+                                  }\n+                                } else {\n+                                  throw new AngelException(\"the operation is not support!\");\n+                                }\n+    return dot;\n+  }\n+\n+  private static double apply(IntDoubleVector v1, IntIntVector v2) {\n+    double dot = 0.0;\n+    if (v1.isDense() && v2.isDense()) {\n       double[] v1Values = v1.getStorage().getValues();\n-      int[] keys = v2.getStorage().getIndices();\n-      long[] v2Values = v2.getStorage().getValues();\n-      int size = v2.size();\n-      for (int i = 0; i < size; i++) {\n-        dot += v2Values[i] * v1Values[keys[i]];\n+      int[] v2Values = v2.getStorage().getValues();\n+      int length = v1Values.length;\n+      for (int i = 0; i < length; i++) {\n+        dot += v1Values[i] * v2Values[i];\n       }\n-    } else if (v1.isSparse() && v2.isDense()) {\n-      long[] v2Values = v2.getStorage().getValues();\n-      ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+    } else if (v1.isDense() && v2.isSparse()) {\n+      double[] v1Values = v1.getStorage().getValues();\n+      ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n       while (iter.hasNext()) {\n-        Int2DoubleMap.Entry entry = iter.next();\n-        dot += entry.getDoubleValue() * v2Values[entry.getIntKey()];\n+        Int2IntMap.Entry entry = iter.next();\n+        dot += entry.getIntValue() * v1Values[entry.getIntKey()];\n       }\n-    } else if (v1.isSorted() && v2.isDense()) {\n-      int[] keys = v1.getStorage().getIndices();\n-      double[] v1Values = v1.getStorage().getValues();\n-      long[] v2Values = v2.getStorage().getValues();\n-      int size = v1.size();\n+    } else if (v1.isDense() && v2.isSorted()) {\n+             double[] v1Values = v1.getStorage().getValues();\n+             int[] keys = v2.getStorage().getIndices();\n+             int[] v2Values = v2.getStorage().getValues();\n+             int size = v2.size();\n+             for (int i = 0; i < size; i++) {\n+               dot += v2Values[i] * v1Values[keys[i]];\n+             }\n+           } else if (v1.isSparse() && v2.isDense()) {\n+             int[] v2Values = v2.getStorage().getValues();\n+             ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+             while (iter.hasNext()) {\n+               Int2DoubleMap.Entry entry = iter.next();\n+               dot += entry.getDoubleValue() * v2Values[entry.getIntKey()];\n+             }\n+           } else if (v1.isSorted() && v2.isDense()) {\n+                    int[] keys = v1.getStorage().getIndices();\n+                    double[] v1Values = v1.getStorage().getValues();\n+                    int[] v2Values = v2.getStorage().getValues();\n+                    int size = v1.size();\n+                    for (int i = 0; i < size; i++) {\n+                      dot += v1Values[i] * v2Values[keys[i]];\n+                    }\n+                  } else if (v1.isSparse() && v2.isSparse()) {\n+                    if (v1.size() < v2.size()) {\n+                      ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+                      while (iter.hasNext()) {\n+                        Int2DoubleMap.Entry entry = iter.next();\n+                        dot += entry.getDoubleValue() * v2.get(entry.getIntKey());\n+                      }\n+                    } else {\n+                      ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n+                      while (iter.hasNext()) {\n+                        Int2IntMap.Entry entry = iter.next();\n+                        dot += entry.getIntValue() * v1.get(entry.getIntKey());\n+                      }\n+                    }\n+                  } else if (v1.isSparse() && v2.isSorted()) {\n+                           if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+                             ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+                             while (iter.hasNext()) {\n+                               Int2DoubleMap.Entry entry = iter.next();\n+                               dot += entry.getDoubleValue() * v2.get(entry.getIntKey());\n+                             }\n+                           } else {\n+                             int[] keys = v2.getStorage().getIndices();\n+                             int[] v2Values = v2.getStorage().getValues();\n+                             int size = v2.size();\n+                             for (int i = 0; i < size; i++) {\n+                               dot += v2Values[i] * v1.get(keys[i]);\n+                             }\n+                           }\n+                         } else if (v1.isSorted() && v2.isSparse()) {\n+                           if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size() && v1.size() > Constant.sortedThreshold * v1.dim()) {\n+                             ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n+                             while (iter.hasNext()) {\n+                               Int2IntMap.Entry entry = iter.next();\n+                               dot += entry.getIntValue() * v1.get(entry.getIntKey());\n+                             }\n+                           } else {\n+                             int[] keys = v1.getStorage().getIndices();\n+                             double[] v1Values = v1.getStorage().getValues();\n+                             int size = v1.size();\n+                             for (int i = 0; i < size; i++) {\n+                               dot += v1Values[i] * v2.get(keys[i]);\n+                             }\n+                           }\n+                         } else if (v1.isSorted() && v2.isSorted()) {\n+                                  int[] keys1 = v1.getStorage().getIndices();\n+                                  double[] v1Values = v1.getStorage().getValues();\n+                                  int[] keys2 = v2.getStorage().getIndices();\n+                                  int[] v2Values = v2.getStorage().getValues();\n+                                  int v1Pointor = 0;\n+                                  int v2Pointor = 0;\n+                                  int size1 = v1.size();\n+                                  int size2 = v2.size();\n+                                  while (v1Pointor < size1 && v2Pointor < size2) {\n+                                    if (keys1[v1Pointor] == keys2[v2Pointor]) {\n+                                      dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n+                                      v2Pointor++;\n+                                      v1Pointor++;\n+                                    } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n+                                             v2Pointor++;\n+                                    } else {\n+                                             v1Pointor++;\n+                                    }\n+                                  }\n+                                } else {\n+                                  throw new AngelException(\"the operation is not support!\");\n+                                }\n+    return dot;\n+  }\n+\n+  private static double apply(IntFloatVector v1, IntDummyVector v2) {\n+    assert v1.getDim() == v2.getDim();\n+    double dot = 0.0;\n+    int[] idxs = v2.getIndices();\n+    if (v1.isDense()) {\n+      float[] v1Values = v1.getStorage().getValues();\n+      int size = v2.size();\n       for (int i = 0; i < size; i++) {\n-        dot += v1Values[i] * v2Values[keys[i]];\n-      }\n-    } else if (v1.isSparse() && v2.isSparse()) {\n-      if (v1.size() < v2.size()) {\n-        ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2DoubleMap.Entry entry = iter.next();\n-          dot += entry.getDoubleValue() * v2.get(entry.getIntKey());\n-        }\n-      } else {\n-        ObjectIterator<Int2LongMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2LongMap.Entry entry = iter.next();\n-          dot += entry.getLongValue() * v1.get(entry.getIntKey());\n-        }\n+        dot += v1Values[idxs[i]];\n       }\n-    } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+    } else if (v1.isSparse()) {\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+        ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n-          Int2DoubleMap.Entry entry = iter.next();\n-          dot += entry.getDoubleValue() * v2.get(entry.getIntKey());\n+          Int2FloatMap.Entry entry = iter.next();\n+          dot += entry.getFloatValue() * v2.get(entry.getIntKey());\n         }\n       } else {\n-        int[] keys = v2.getStorage().getIndices();\n-        long[] v2Values = v2.getStorage().getValues();\n         int size = v2.size();\n         for (int i = 0; i < size; i++) {\n-          dot += v2Values[i] * v1.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSparse()) {\n-      if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n-          && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2LongMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2LongMap.Entry entry = iter.next();\n-          dot += entry.getLongValue() * v1.get(entry.getIntKey());\n-        }\n-      } else {\n-        int[] keys = v1.getStorage().getIndices();\n-        double[] v1Values = v1.getStorage().getValues();\n-        int size = v1.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v1Values[i] * v2.get(keys[i]);\n+          dot += v1.get(idxs[i]);\n         }\n       }\n-    } else if (v1.isSorted() && v2.isSorted()) {\n+    } else {\n       int[] keys1 = v1.getStorage().getIndices();\n-      double[] v1Values = v1.getStorage().getValues();\n-      int[] keys2 = v2.getStorage().getIndices();\n-      long[] v2Values = v2.getStorage().getValues();\n-\n+      float[] v1Values = v1.getStorage().getValues();\n       int v1Pointor = 0;\n       int v2Pointor = 0;\n       int size1 = v1.size();\n       int size2 = v2.size();\n-\n       while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n-          dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n+        if (keys1[v1Pointor] == idxs[v2Pointor]) {\n+          dot += v1Values[v1Pointor];\n           v2Pointor++;\n           v1Pointor++;\n-        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n-          v2Pointor++;\n+        } else if (keys1[v1Pointor] > idxs[v2Pointor]) {\n+                 v2Pointor++;\n         } else {\n-          v1Pointor++;\n+                 v1Pointor++;\n         }\n       }\n-    } else {\n-      throw new AngelException(\"the operation is not support!\");\n     }\n-\n     return dot;\n   }\n \n-  private static double apply(IntDoubleVector v1, IntIntVector v2) {\n+  private static double apply(IntFloatVector v1, IntFloatVector v2) {\n     double dot = 0.0;\n     if (v1.isDense() && v2.isDense()) {\n-      double[] v1Values = v1.getStorage().getValues();\n-      int[] v2Values = v2.getStorage().getValues();\n+      float[] v1Values = v1.getStorage().getValues();\n+      float[] v2Values = v2.getStorage().getValues();\n       int length = v1Values.length;\n       for (int i = 0; i < length; i++) {\n         dot += v1Values[i] * v2Values[i];\n       }\n     } else if (v1.isDense() && v2.isSparse()) {\n-      double[] v1Values = v1.getStorage().getValues();\n-      ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n+      float[] v1Values = v1.getStorage().getValues();\n+      ObjectIterator<Int2FloatMap.Entry> iter = v2.getStorage().entryIterator();\n       while (iter.hasNext()) {\n-        Int2IntMap.Entry entry = iter.next();\n-        dot += entry.getIntValue() * v1Values[entry.getIntKey()];\n+        Int2FloatMap.Entry entry = iter.next();\n+        dot += entry.getFloatValue() * v1Values[entry.getIntKey()];\n       }\n     } else if (v1.isDense() && v2.isSorted()) {\n-      double[] v1Values = v1.getStorage().getValues();\n-      int[] keys = v2.getStorage().getIndices();\n-      int[] v2Values = v2.getStorage().getValues();\n-      int size = v2.size();\n-      for (int i = 0; i < size; i++) {\n-        dot += v2Values[i] * v1Values[keys[i]];\n-      }\n-    } else if (v1.isSparse() && v2.isDense()) {\n-      int[] v2Values = v2.getStorage().getValues();\n-      ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n-      while (iter.hasNext()) {\n-        Int2DoubleMap.Entry entry = iter.next();\n-        dot += entry.getDoubleValue() * v2Values[entry.getIntKey()];\n-      }\n-    } else if (v1.isSorted() && v2.isDense()) {\n-      int[] keys = v1.getStorage().getIndices();\n-      double[] v1Values = v1.getStorage().getValues();\n-      int[] v2Values = v2.getStorage().getValues();\n-      int size = v1.size();\n-      for (int i = 0; i < size; i++) {\n-        dot += v1Values[i] * v2Values[keys[i]];\n-      }\n-    } else if (v1.isSparse() && v2.isSparse()) {\n-      if (v1.size() < v2.size()) {\n-        ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2DoubleMap.Entry entry = iter.next();\n-          dot += entry.getDoubleValue() * v2.get(entry.getIntKey());\n-        }\n-      } else {\n-        ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2IntMap.Entry entry = iter.next();\n-          dot += entry.getIntValue() * v1.get(entry.getIntKey());\n-        }\n-      }\n-    } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2DoubleMap.Entry entry = iter.next();\n-          dot += entry.getDoubleValue() * v2.get(entry.getIntKey());\n-        }\n-      } else {\n-        int[] keys = v2.getStorage().getIndices();\n-        int[] v2Values = v2.getStorage().getValues();\n-        int size = v2.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v2Values[i] * v1.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSparse()) {\n-      if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n-          && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2IntMap.Entry entry = iter.next();\n-          dot += entry.getIntValue() * v1.get(entry.getIntKey());\n-        }\n-      } else {\n-        int[] keys = v1.getStorage().getIndices();\n-        double[] v1Values = v1.getStorage().getValues();\n-        int size = v1.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v1Values[i] * v2.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSorted()) {\n-      int[] keys1 = v1.getStorage().getIndices();\n-      double[] v1Values = v1.getStorage().getValues();\n-      int[] keys2 = v2.getStorage().getIndices();\n-      int[] v2Values = v2.getStorage().getValues();\n-\n-      int v1Pointor = 0;\n-      int v2Pointor = 0;\n-      int size1 = v1.size();\n-      int size2 = v2.size();\n-\n-      while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n-          dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n-          v2Pointor++;\n-          v1Pointor++;\n-        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n-          v2Pointor++;\n-        } else {\n-          v1Pointor++;\n-        }\n-      }\n-    } else {\n-      throw new AngelException(\"the operation is not support!\");\n-    }\n-\n-    return dot;\n-  }\n-\n-  private static double apply(IntFloatVector v1, IntDummyVector v2) {\n-    assert v1.getDim() == v2.getDim();\n-    double dot = 0.0;\n-    int[] idxs = v2.getIndices();\n-    if (v1.isDense()) {\n-      float[] v1Values = v1.getStorage().getValues();\n-      int size = v2.size();\n-      for (int i = 0; i < size; i++) {\n-        dot += v1Values[idxs[i]];\n-      }\n-    } else if (v1.isSparse()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2FloatMap.Entry entry = iter.next();\n-          dot += entry.getFloatValue() * v2.get(entry.getIntKey());\n-        }\n-      } else {\n-        int size = v2.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v1.get(idxs[i]);\n-        }\n-      }\n-    } else {\n-      int[] keys1 = v1.getStorage().getIndices();\n-      float[] v1Values = v1.getStorage().getValues();\n-\n-      int v1Pointor = 0;\n-      int v2Pointor = 0;\n-      int size1 = v1.size();\n-      int size2 = v2.size();\n-\n-      while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == idxs[v2Pointor]) {\n-          dot += v1Values[v1Pointor];\n-          v2Pointor++;\n-          v1Pointor++;\n-        } else if (keys1[v1Pointor] > idxs[v2Pointor]) {\n-          v2Pointor++;\n-        } else {\n-          v1Pointor++;\n-        }\n-      }\n-    }\n-    return dot;\n-  }\n-\n-  private static double apply(IntFloatVector v1, IntFloatVector v2) {\n-    double dot = 0.0;\n-    if (v1.isDense() && v2.isDense()) {\n-      float[] v1Values = v1.getStorage().getValues();\n-      float[] v2Values = v2.getStorage().getValues();\n-      int length = v1Values.length;\n-      for (int i = 0; i < length; i++) {\n-        dot += v1Values[i] * v2Values[i];\n-      }\n-    } else if (v1.isDense() && v2.isSparse()) {\n-      float[] v1Values = v1.getStorage().getValues();\n-      ObjectIterator<Int2FloatMap.Entry> iter = v2.getStorage().entryIterator();\n-      while (iter.hasNext()) {\n-        Int2FloatMap.Entry entry = iter.next();\n-        dot += entry.getFloatValue() * v1Values[entry.getIntKey()];\n-      }\n-    } else if (v1.isDense() && v2.isSorted()) {\n-      float[] v1Values = v1.getStorage().getValues();\n-      int[] keys = v2.getStorage().getIndices();\n-      float[] v2Values = v2.getStorage().getValues();\n-      int size = v2.size();\n-      for (int i = 0; i < size; i++) {\n-        dot += v2Values[i] * v1Values[keys[i]];\n-      }\n-    } else if (v1.isSparse() && v2.isDense()) {\n-      float[] v2Values = v2.getStorage().getValues();\n-      ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n-      while (iter.hasNext()) {\n-        Int2FloatMap.Entry entry = iter.next();\n-        dot += entry.getFloatValue() * v2Values[entry.getIntKey()];\n-      }\n-    } else if (v1.isSorted() && v2.isDense()) {\n-      int[] keys = v1.getStorage().getIndices();\n-      float[] v1Values = v1.getStorage().getValues();\n-      float[] v2Values = v2.getStorage().getValues();\n-      int size = v1.size();\n-      for (int i = 0; i < size; i++) {\n-        dot += v1Values[i] * v2Values[keys[i]];\n-      }\n-    } else if (v1.isSparse() && v2.isSparse()) {\n-      if (v1.size() < v2.size()) {\n-        ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2FloatMap.Entry entry = iter.next();\n-          dot += entry.getFloatValue() * v2.get(entry.getIntKey());\n-        }\n-      } else {\n-        ObjectIterator<Int2FloatMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2FloatMap.Entry entry = iter.next();\n-          dot += entry.getFloatValue() * v1.get(entry.getIntKey());\n-        }\n-      }\n-    } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2FloatMap.Entry entry = iter.next();\n-          dot += entry.getFloatValue() * v2.get(entry.getIntKey());\n-        }\n-      } else {\n-        int[] keys = v2.getStorage().getIndices();\n-        float[] v2Values = v2.getStorage().getValues();\n-        int size = v2.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v2Values[i] * v1.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSparse()) {\n-      if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n-          && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2FloatMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2FloatMap.Entry entry = iter.next();\n-          dot += entry.getFloatValue() * v1.get(entry.getIntKey());\n-        }\n-      } else {\n-        int[] keys = v1.getStorage().getIndices();\n-        float[] v1Values = v1.getStorage().getValues();\n-        int size = v1.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v1Values[i] * v2.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSorted()) {\n-      int[] keys1 = v1.getStorage().getIndices();\n-      float[] v1Values = v1.getStorage().getValues();\n-      int[] keys2 = v2.getStorage().getIndices();\n-      float[] v2Values = v2.getStorage().getValues();\n-\n-      int v1Pointor = 0;\n-      int v2Pointor = 0;\n-      int size1 = v1.size();\n-      int size2 = v2.size();\n-\n-      while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n-          dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n-          v2Pointor++;\n-          v1Pointor++;\n-        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n-          v2Pointor++;\n-        } else {\n-          v1Pointor++;\n-        }\n-      }\n-    } else {\n-      throw new AngelException(\"the operation is not support!\");\n-    }\n-\n-    return dot;\n-  }\n-\n-  private static double apply(IntFloatVector v1, IntLongVector v2) {\n-    double dot = 0.0;\n-    if (v1.isDense() && v2.isDense()) {\n-      float[] v1Values = v1.getStorage().getValues();\n-      long[] v2Values = v2.getStorage().getValues();\n-      int length = v1Values.length;\n-      for (int i = 0; i < length; i++) {\n-        dot += v1Values[i] * v2Values[i];\n-      }\n-    } else if (v1.isDense() && v2.isSparse()) {\n-      float[] v1Values = v1.getStorage().getValues();\n-      ObjectIterator<Int2LongMap.Entry> iter = v2.getStorage().entryIterator();\n-      while (iter.hasNext()) {\n-        Int2LongMap.Entry entry = iter.next();\n-        dot += entry.getLongValue() * v1Values[entry.getIntKey()];\n-      }\n-    } else if (v1.isDense() && v2.isSorted()) {\n-      float[] v1Values = v1.getStorage().getValues();\n-      int[] keys = v2.getStorage().getIndices();\n-      long[] v2Values = v2.getStorage().getValues();\n-      int size = v2.size();\n-      for (int i = 0; i < size; i++) {\n-        dot += v2Values[i] * v1Values[keys[i]];\n-      }\n-    } else if (v1.isSparse() && v2.isDense()) {\n-      long[] v2Values = v2.getStorage().getValues();\n-      ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n-      while (iter.hasNext()) {\n-        Int2FloatMap.Entry entry = iter.next();\n-        dot += entry.getFloatValue() * v2Values[entry.getIntKey()];\n-      }\n-    } else if (v1.isSorted() && v2.isDense()) {\n-      int[] keys = v1.getStorage().getIndices();\n-      float[] v1Values = v1.getStorage().getValues();\n-      long[] v2Values = v2.getStorage().getValues();\n-      int size = v1.size();\n-      for (int i = 0; i < size; i++) {\n-        dot += v1Values[i] * v2Values[keys[i]];\n-      }\n-    } else if (v1.isSparse() && v2.isSparse()) {\n-      if (v1.size() < v2.size()) {\n-        ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2FloatMap.Entry entry = iter.next();\n-          dot += entry.getFloatValue() * v2.get(entry.getIntKey());\n-        }\n-      } else {\n-        ObjectIterator<Int2LongMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2LongMap.Entry entry = iter.next();\n-          dot += entry.getLongValue() * v1.get(entry.getIntKey());\n-        }\n-      }\n-    } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2FloatMap.Entry entry = iter.next();\n-          dot += entry.getFloatValue() * v2.get(entry.getIntKey());\n-        }\n-      } else {\n-        int[] keys = v2.getStorage().getIndices();\n-        long[] v2Values = v2.getStorage().getValues();\n-        int size = v2.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v2Values[i] * v1.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSparse()) {\n-      if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n-          && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2LongMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2LongMap.Entry entry = iter.next();\n-          dot += entry.getLongValue() * v1.get(entry.getIntKey());\n-        }\n-      } else {\n-        int[] keys = v1.getStorage().getIndices();\n-        float[] v1Values = v1.getStorage().getValues();\n-        int size = v1.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v1Values[i] * v2.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSorted()) {\n-      int[] keys1 = v1.getStorage().getIndices();\n-      float[] v1Values = v1.getStorage().getValues();\n-      int[] keys2 = v2.getStorage().getIndices();\n-      long[] v2Values = v2.getStorage().getValues();\n-\n-      int v1Pointor = 0;\n-      int v2Pointor = 0;\n-      int size1 = v1.size();\n-      int size2 = v2.size();\n-\n-      while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n-          dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n-          v2Pointor++;\n-          v1Pointor++;\n-        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n-          v2Pointor++;\n-        } else {\n-          v1Pointor++;\n-        }\n-      }\n-    } else {\n-      throw new AngelException(\"the operation is not support!\");\n-    }\n-\n-    return dot;\n-  }\n-\n-  private static double apply(IntFloatVector v1, IntIntVector v2) {\n-    double dot = 0.0;\n-    if (v1.isDense() && v2.isDense()) {\n-      float[] v1Values = v1.getStorage().getValues();\n-      int[] v2Values = v2.getStorage().getValues();\n-      int length = v1Values.length;\n-      for (int i = 0; i < length; i++) {\n-        dot += v1Values[i] * v2Values[i];\n-      }\n-    } else if (v1.isDense() && v2.isSparse()) {\n-      float[] v1Values = v1.getStorage().getValues();\n-      ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n-      while (iter.hasNext()) {\n-        Int2IntMap.Entry entry = iter.next();\n-        dot += entry.getIntValue() * v1Values[entry.getIntKey()];\n-      }\n-    } else if (v1.isDense() && v2.isSorted()) {\n-      float[] v1Values = v1.getStorage().getValues();\n-      int[] keys = v2.getStorage().getIndices();\n-      int[] v2Values = v2.getStorage().getValues();\n-      int size = v2.size();\n-      for (int i = 0; i < size; i++) {\n-        dot += v2Values[i] * v1Values[keys[i]];\n-      }\n-    } else if (v1.isSparse() && v2.isDense()) {\n-      int[] v2Values = v2.getStorage().getValues();\n-      ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n-      while (iter.hasNext()) {\n-        Int2FloatMap.Entry entry = iter.next();\n-        dot += entry.getFloatValue() * v2Values[entry.getIntKey()];\n-      }\n-    } else if (v1.isSorted() && v2.isDense()) {\n-      int[] keys = v1.getStorage().getIndices();\n-      float[] v1Values = v1.getStorage().getValues();\n-      int[] v2Values = v2.getStorage().getValues();\n-      int size = v1.size();\n-      for (int i = 0; i < size; i++) {\n-        dot += v1Values[i] * v2Values[keys[i]];\n-      }\n-    } else if (v1.isSparse() && v2.isSparse()) {\n-      if (v1.size() < v2.size()) {\n-        ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2FloatMap.Entry entry = iter.next();\n-          dot += entry.getFloatValue() * v2.get(entry.getIntKey());\n-        }\n-      } else {\n-        ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2IntMap.Entry entry = iter.next();\n-          dot += entry.getIntValue() * v1.get(entry.getIntKey());\n-        }\n-      }\n-    } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2FloatMap.Entry entry = iter.next();\n-          dot += entry.getFloatValue() * v2.get(entry.getIntKey());\n-        }\n-      } else {\n-        int[] keys = v2.getStorage().getIndices();\n-        int[] v2Values = v2.getStorage().getValues();\n-        int size = v2.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v2Values[i] * v1.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSparse()) {\n-      if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n-          && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2IntMap.Entry entry = iter.next();\n-          dot += entry.getIntValue() * v1.get(entry.getIntKey());\n-        }\n-      } else {\n-        int[] keys = v1.getStorage().getIndices();\n-        float[] v1Values = v1.getStorage().getValues();\n-        int size = v1.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v1Values[i] * v2.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSorted()) {\n-      int[] keys1 = v1.getStorage().getIndices();\n-      float[] v1Values = v1.getStorage().getValues();\n-      int[] keys2 = v2.getStorage().getIndices();\n-      int[] v2Values = v2.getStorage().getValues();\n-\n-      int v1Pointor = 0;\n-      int v2Pointor = 0;\n-      int size1 = v1.size();\n-      int size2 = v2.size();\n-\n-      while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n-          dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n-          v2Pointor++;\n-          v1Pointor++;\n-        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n-          v2Pointor++;\n-        } else {\n-          v1Pointor++;\n-        }\n-      }\n-    } else {\n-      throw new AngelException(\"the operation is not support!\");\n-    }\n-\n-    return dot;\n-  }\n-\n-  private static double apply(IntLongVector v1, IntDummyVector v2) {\n-    assert v1.getDim() == v2.getDim();\n-    double dot = 0.0;\n-    int[] idxs = v2.getIndices();\n-    if (v1.isDense()) {\n-      long[] v1Values = v1.getStorage().getValues();\n-      int size = v2.size();\n-      for (int i = 0; i < size; i++) {\n-        dot += v1Values[idxs[i]];\n-      }\n-    } else if (v1.isSparse()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2LongMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2LongMap.Entry entry = iter.next();\n-          dot += entry.getLongValue() * v2.get(entry.getIntKey());\n-        }\n-      } else {\n-        int size = v2.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v1.get(idxs[i]);\n-        }\n-      }\n-    } else {\n-      int[] keys1 = v1.getStorage().getIndices();\n-      long[] v1Values = v1.getStorage().getValues();\n-\n-      int v1Pointor = 0;\n-      int v2Pointor = 0;\n-      int size1 = v1.size();\n-      int size2 = v2.size();\n-\n-      while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == idxs[v2Pointor]) {\n-          dot += v1Values[v1Pointor];\n-          v2Pointor++;\n-          v1Pointor++;\n-        } else if (keys1[v1Pointor] > idxs[v2Pointor]) {\n-          v2Pointor++;\n-        } else {\n-          v1Pointor++;\n-        }\n-      }\n-    }\n-    return dot;\n-  }\n-\n-  private static double apply(IntLongVector v1, IntLongVector v2) {\n-    double dot = 0.0;\n-    if (v1.isDense() && v2.isDense()) {\n-      long[] v1Values = v1.getStorage().getValues();\n-      long[] v2Values = v2.getStorage().getValues();\n-      int length = v1Values.length;\n-      for (int i = 0; i < length; i++) {\n-        dot += v1Values[i] * v2Values[i];\n-      }\n-    } else if (v1.isDense() && v2.isSparse()) {\n-      long[] v1Values = v1.getStorage().getValues();\n-      ObjectIterator<Int2LongMap.Entry> iter = v2.getStorage().entryIterator();\n-      while (iter.hasNext()) {\n-        Int2LongMap.Entry entry = iter.next();\n-        dot += entry.getLongValue() * v1Values[entry.getIntKey()];\n-      }\n-    } else if (v1.isDense() && v2.isSorted()) {\n-      long[] v1Values = v1.getStorage().getValues();\n-      int[] keys = v2.getStorage().getIndices();\n-      long[] v2Values = v2.getStorage().getValues();\n-      int size = v2.size();\n-      for (int i = 0; i < size; i++) {\n-        dot += v2Values[i] * v1Values[keys[i]];\n-      }\n-    } else if (v1.isSparse() && v2.isDense()) {\n-      long[] v2Values = v2.getStorage().getValues();\n-      ObjectIterator<Int2LongMap.Entry> iter = v1.getStorage().entryIterator();\n-      while (iter.hasNext()) {\n-        Int2LongMap.Entry entry = iter.next();\n-        dot += entry.getLongValue() * v2Values[entry.getIntKey()];\n-      }\n-    } else if (v1.isSorted() && v2.isDense()) {\n-      int[] keys = v1.getStorage().getIndices();\n-      long[] v1Values = v1.getStorage().getValues();\n-      long[] v2Values = v2.getStorage().getValues();\n-      int size = v1.size();\n-      for (int i = 0; i < size; i++) {\n-        dot += v1Values[i] * v2Values[keys[i]];\n-      }\n-    } else if (v1.isSparse() && v2.isSparse()) {\n-      if (v1.size() < v2.size()) {\n-        ObjectIterator<Int2LongMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2LongMap.Entry entry = iter.next();\n-          dot += entry.getLongValue() * v2.get(entry.getIntKey());\n-        }\n-      } else {\n-        ObjectIterator<Int2LongMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2LongMap.Entry entry = iter.next();\n-          dot += entry.getLongValue() * v1.get(entry.getIntKey());\n-        }\n-      }\n-    } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2LongMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2LongMap.Entry entry = iter.next();\n-          dot += entry.getLongValue() * v2.get(entry.getIntKey());\n-        }\n-      } else {\n-        int[] keys = v2.getStorage().getIndices();\n-        long[] v2Values = v2.getStorage().getValues();\n-        int size = v2.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v2Values[i] * v1.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSparse()) {\n-      if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n-          && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2LongMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2LongMap.Entry entry = iter.next();\n-          dot += entry.getLongValue() * v1.get(entry.getIntKey());\n-        }\n-      } else {\n-        int[] keys = v1.getStorage().getIndices();\n-        long[] v1Values = v1.getStorage().getValues();\n-        int size = v1.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v1Values[i] * v2.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSorted()) {\n-      int[] keys1 = v1.getStorage().getIndices();\n-      long[] v1Values = v1.getStorage().getValues();\n-      int[] keys2 = v2.getStorage().getIndices();\n-      long[] v2Values = v2.getStorage().getValues();\n-\n-      int v1Pointor = 0;\n-      int v2Pointor = 0;\n-      int size1 = v1.size();\n-      int size2 = v2.size();\n-\n-      while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n-          dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n-          v2Pointor++;\n-          v1Pointor++;\n-        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n-          v2Pointor++;\n-        } else {\n-          v1Pointor++;\n-        }\n-      }\n-    } else {\n-      throw new AngelException(\"the operation is not support!\");\n-    }\n+             float[] v1Values = v1.getStorage().getValues();\n+             int[] keys = v2.getStorage().getIndices();\n+             float[] v2Values = v2.getStorage().getValues();\n+             int size = v2.size();\n+             for (int i = 0; i < size; i++) {\n+               dot += v2Values[i] * v1Values[keys[i]];\n+             }\n+           } else if (v1.isSparse() && v2.isDense()) {\n+             float[] v2Values = v2.getStorage().getValues();\n+             ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n+             while (iter.hasNext()) {\n+               Int2FloatMap.Entry entry = iter.next();\n+               dot += entry.getFloatValue() * v2Values[entry.getIntKey()];\n+             }\n+           } else if (v1.isSorted() && v2.isDense()) {\n+                    int[] keys = v1.getStorage().getIndices();\n+                    float[] v1Values = v1.getStorage().getValues();\n+                    float[] v2Values = v2.getStorage().getValues();\n+                    int size = v1.size();\n+                    for (int i = 0; i < size; i++) {\n+                      dot += v1Values[i] * v2Values[keys[i]];\n+                    }\n+                  } else if (v1.isSparse() && v2.isSparse()) {\n+                    if (v1.size() < v2.size()) {\n+                      ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n+                      while (iter.hasNext()) {\n+                        Int2FloatMap.Entry entry = iter.next();\n+                        dot += entry.getFloatValue() * v2.get(entry.getIntKey());\n+                      }\n+                    } else {\n+                      ObjectIterator<Int2FloatMap.Entry> iter = v2.getStorage().entryIterator();\n+                      while (iter.hasNext()) {\n+                        Int2FloatMap.Entry entry = iter.next();\n+                        dot += entry.getFloatValue() * v1.get(entry.getIntKey());\n+                      }\n+                    }\n+                  } else if (v1.isSparse() && v2.isSorted()) {\n+                           if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+                             ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n+                             while (iter.hasNext()) {\n+                               Int2FloatMap.Entry entry = iter.next();\n+                               dot += entry.getFloatValue() * v2.get(entry.getIntKey());\n+                             }\n+                           } else {\n+                             int[] keys = v2.getStorage().getIndices();\n+                             float[] v2Values = v2.getStorage().getValues();\n+                             int size = v2.size();\n+                             for (int i = 0; i < size; i++) {\n+                               dot += v2Values[i] * v1.get(keys[i]);\n+                             }\n+                           }\n+                         } else if (v1.isSorted() && v2.isSparse()) {\n+                           if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size() && v1.size() > Constant.sortedThreshold * v1.dim()) {\n+                             ObjectIterator<Int2FloatMap.Entry> iter = v2.getStorage().entryIterator();\n+                             while (iter.hasNext()) {\n+                               Int2FloatMap.Entry entry = iter.next();\n+                               dot += entry.getFloatValue() * v1.get(entry.getIntKey());\n+                             }\n+                           } else {\n+                             int[] keys = v1.getStorage().getIndices();\n+                             float[] v1Values = v1.getStorage().getValues();\n+                             int size = v1.size();\n+                             for (int i = 0; i < size; i++) {\n+                               dot += v1Values[i] * v2.get(keys[i]);\n+                             }\n+                           }\n+                         } else if (v1.isSorted() && v2.isSorted()) {\n+                                  int[] keys1 = v1.getStorage().getIndices();\n+                                  float[] v1Values = v1.getStorage().getValues();\n+                                  int[] keys2 = v2.getStorage().getIndices();\n+                                  float[] v2Values = v2.getStorage().getValues();\n+                                  int v1Pointor = 0;\n+                                  int v2Pointor = 0;\n+                                  int size1 = v1.size();\n+                                  int size2 = v2.size();\n+                                  while (v1Pointor < size1 && v2Pointor < size2) {\n+                                    if (keys1[v1Pointor] == keys2[v2Pointor]) {\n+                                      dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n+                                      v2Pointor++;\n+                                      v1Pointor++;\n+                                    } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n+                                             v2Pointor++;\n+                                    } else {\n+                                             v1Pointor++;\n+                                    }\n+                                  }\n+                                } else {\n+                                  throw new AngelException(\"the operation is not support!\");\n+                                }\n+    return dot;\n+  }\n \n+  private static double apply(IntFloatVector v1, IntLongVector v2) {\n+    double dot = 0.0;\n+    if (v1.isDense() && v2.isDense()) {\n+      float[] v1Values = v1.getStorage().getValues();\n+      long[] v2Values = v2.getStorage().getValues();\n+      int length = v1Values.length;\n+      for (int i = 0; i < length; i++) {\n+        dot += v1Values[i] * v2Values[i];\n+      }\n+    } else if (v1.isDense() && v2.isSparse()) {\n+      float[] v1Values = v1.getStorage().getValues();\n+      ObjectIterator<Int2LongMap.Entry> iter = v2.getStorage().entryIterator();\n+      while (iter.hasNext()) {\n+        Int2LongMap.Entry entry = iter.next();\n+        dot += entry.getLongValue() * v1Values[entry.getIntKey()];\n+      }\n+    } else if (v1.isDense() && v2.isSorted()) {\n+             float[] v1Values = v1.getStorage().getValues();\n+             int[] keys = v2.getStorage().getIndices();\n+             long[] v2Values = v2.getStorage().getValues();\n+             int size = v2.size();\n+             for (int i = 0; i < size; i++) {\n+               dot += v2Values[i] * v1Values[keys[i]];\n+             }\n+           } else if (v1.isSparse() && v2.isDense()) {\n+             long[] v2Values = v2.getStorage().getValues();\n+             ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n+             while (iter.hasNext()) {\n+               Int2FloatMap.Entry entry = iter.next();\n+               dot += entry.getFloatValue() * v2Values[entry.getIntKey()];\n+             }\n+           } else if (v1.isSorted() && v2.isDense()) {\n+                    int[] keys = v1.getStorage().getIndices();\n+                    float[] v1Values = v1.getStorage().getValues();\n+                    long[] v2Values = v2.getStorage().getValues();\n+                    int size = v1.size();\n+                    for (int i = 0; i < size; i++) {\n+                      dot += v1Values[i] * v2Values[keys[i]];\n+                    }\n+                  } else if (v1.isSparse() && v2.isSparse()) {\n+                    if (v1.size() < v2.size()) {\n+                      ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n+                      while (iter.hasNext()) {\n+                        Int2FloatMap.Entry entry = iter.next();\n+                        dot += entry.getFloatValue() * v2.get(entry.getIntKey());\n+                      }\n+                    } else {\n+                      ObjectIterator<Int2LongMap.Entry> iter = v2.getStorage().entryIterator();\n+                      while (iter.hasNext()) {\n+                        Int2LongMap.Entry entry = iter.next();\n+                        dot += entry.getLongValue() * v1.get(entry.getIntKey());\n+                      }\n+                    }\n+                  } else if (v1.isSparse() && v2.isSorted()) {\n+                           if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+                             ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n+                             while (iter.hasNext()) {\n+                               Int2FloatMap.Entry entry = iter.next();\n+                               dot += entry.getFloatValue() * v2.get(entry.getIntKey());\n+                             }\n+                           } else {\n+                             int[] keys = v2.getStorage().getIndices();\n+                             long[] v2Values = v2.getStorage().getValues();\n+                             int size = v2.size();\n+                             for (int i = 0; i < size; i++) {\n+                               dot += v2Values[i] * v1.get(keys[i]);\n+                             }\n+                           }\n+                         } else if (v1.isSorted() && v2.isSparse()) {\n+                           if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size() && v1.size() > Constant.sortedThreshold * v1.dim()) {\n+                             ObjectIterator<Int2LongMap.Entry> iter = v2.getStorage().entryIterator();\n+                             while (iter.hasNext()) {\n+                               Int2LongMap.Entry entry = iter.next();\n+                               dot += entry.getLongValue() * v1.get(entry.getIntKey());\n+                             }\n+                           } else {\n+                             int[] keys = v1.getStorage().getIndices();\n+                             float[] v1Values = v1.getStorage().getValues();\n+                             int size = v1.size();\n+                             for (int i = 0; i < size; i++) {\n+                               dot += v1Values[i] * v2.get(keys[i]);\n+                             }\n+                           }\n+                         } else if (v1.isSorted() && v2.isSorted()) {\n+                                  int[] keys1 = v1.getStorage().getIndices();\n+                                  float[] v1Values = v1.getStorage().getValues();\n+                                  int[] keys2 = v2.getStorage().getIndices();\n+                                  long[] v2Values = v2.getStorage().getValues();\n+                                  int v1Pointor = 0;\n+                                  int v2Pointor = 0;\n+                                  int size1 = v1.size();\n+                                  int size2 = v2.size();\n+                                  while (v1Pointor < size1 && v2Pointor < size2) {\n+                                    if (keys1[v1Pointor] == keys2[v2Pointor]) {\n+                                      dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n+                                      v2Pointor++;\n+                                      v1Pointor++;\n+                                    } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n+                                             v2Pointor++;\n+                                    } else {\n+                                             v1Pointor++;\n+                                    }\n+                                  }\n+                                } else {\n+                                  throw new AngelException(\"the operation is not support!\");\n+                                }\n     return dot;\n   }\n \n-  private static double apply(IntLongVector v1, IntIntVector v2) {\n+  private static double apply(IntFloatVector v1, IntIntVector v2) {\n     double dot = 0.0;\n     if (v1.isDense() && v2.isDense()) {\n-      long[] v1Values = v1.getStorage().getValues();\n+      float[] v1Values = v1.getStorage().getValues();\n       int[] v2Values = v2.getStorage().getValues();\n       int length = v1Values.length;\n       for (int i = 0; i < length; i++) {\n         dot += v1Values[i] * v2Values[i];\n       }\n     } else if (v1.isDense() && v2.isSparse()) {\n-      long[] v1Values = v1.getStorage().getValues();\n+      float[] v1Values = v1.getStorage().getValues();\n       ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n       while (iter.hasNext()) {\n         Int2IntMap.Entry entry = iter.next();\n         dot += entry.getIntValue() * v1Values[entry.getIntKey()];\n       }\n     } else if (v1.isDense() && v2.isSorted()) {\n+             float[] v1Values = v1.getStorage().getValues();\n+             int[] keys = v2.getStorage().getIndices();\n+             int[] v2Values = v2.getStorage().getValues();\n+             int size = v2.size();\n+             for (int i = 0; i < size; i++) {\n+               dot += v2Values[i] * v1Values[keys[i]];\n+             }\n+           } else if (v1.isSparse() && v2.isDense()) {\n+             int[] v2Values = v2.getStorage().getValues();\n+             ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n+             while (iter.hasNext()) {\n+               Int2FloatMap.Entry entry = iter.next();\n+               dot += entry.getFloatValue() * v2Values[entry.getIntKey()];\n+             }\n+           } else if (v1.isSorted() && v2.isDense()) {\n+                    int[] keys = v1.getStorage().getIndices();\n+                    float[] v1Values = v1.getStorage().getValues();\n+                    int[] v2Values = v2.getStorage().getValues();\n+                    int size = v1.size();\n+                    for (int i = 0; i < size; i++) {\n+                      dot += v1Values[i] * v2Values[keys[i]];\n+                    }\n+                  } else if (v1.isSparse() && v2.isSparse()) {\n+                    if (v1.size() < v2.size()) {\n+                      ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n+                      while (iter.hasNext()) {\n+                        Int2FloatMap.Entry entry = iter.next();\n+                        dot += entry.getFloatValue() * v2.get(entry.getIntKey());\n+                      }\n+                    } else {\n+                      ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n+                      while (iter.hasNext()) {\n+                        Int2IntMap.Entry entry = iter.next();\n+                        dot += entry.getIntValue() * v1.get(entry.getIntKey());\n+                      }\n+                    }\n+                  } else if (v1.isSparse() && v2.isSorted()) {\n+                           if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+                             ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n+                             while (iter.hasNext()) {\n+                               Int2FloatMap.Entry entry = iter.next();\n+                               dot += entry.getFloatValue() * v2.get(entry.getIntKey());\n+                             }\n+                           } else {\n+                             int[] keys = v2.getStorage().getIndices();\n+                             int[] v2Values = v2.getStorage().getValues();\n+                             int size = v2.size();\n+                             for (int i = 0; i < size; i++) {\n+                               dot += v2Values[i] * v1.get(keys[i]);\n+                             }\n+                           }\n+                         } else if (v1.isSorted() && v2.isSparse()) {\n+                           if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size() && v1.size() > Constant.sortedThreshold * v1.dim()) {\n+                             ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n+                             while (iter.hasNext()) {\n+                               Int2IntMap.Entry entry = iter.next();\n+                               dot += entry.getIntValue() * v1.get(entry.getIntKey());\n+                             }\n+                           } else {\n+                             int[] keys = v1.getStorage().getIndices();\n+                             float[] v1Values = v1.getStorage().getValues();\n+                             int size = v1.size();\n+                             for (int i = 0; i < size; i++) {\n+                               dot += v1Values[i] * v2.get(keys[i]);\n+                             }\n+                           }\n+                         } else if (v1.isSorted() && v2.isSorted()) {\n+                                  int[] keys1 = v1.getStorage().getIndices();\n+                                  float[] v1Values = v1.getStorage().getValues();\n+                                  int[] keys2 = v2.getStorage().getIndices();\n+                                  int[] v2Values = v2.getStorage().getValues();\n+                                  int v1Pointor = 0;\n+                                  int v2Pointor = 0;\n+                                  int size1 = v1.size();\n+                                  int size2 = v2.size();\n+                                  while (v1Pointor < size1 && v2Pointor < size2) {\n+                                    if (keys1[v1Pointor] == keys2[v2Pointor]) {\n+                                      dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n+                                      v2Pointor++;\n+                                      v1Pointor++;\n+                                    } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n+                                             v2Pointor++;\n+                                    } else {\n+                                             v1Pointor++;\n+                                    }\n+                                  }\n+                                } else {\n+                                  throw new AngelException(\"the operation is not support!\");\n+                                }\n+    return dot;\n+  }\n+\n+  private static double apply(IntLongVector v1, IntDummyVector v2) {\n+    assert v1.getDim() == v2.getDim();\n+    double dot = 0.0;\n+    int[] idxs = v2.getIndices();\n+    if (v1.isDense()) {\n       long[] v1Values = v1.getStorage().getValues();\n-      int[] keys = v2.getStorage().getIndices();\n-      int[] v2Values = v2.getStorage().getValues();\n       int size = v2.size();\n       for (int i = 0; i < size; i++) {\n-        dot += v2Values[i] * v1Values[keys[i]];\n-      }\n-    } else if (v1.isSparse() && v2.isDense()) {\n-      int[] v2Values = v2.getStorage().getValues();\n-      ObjectIterator<Int2LongMap.Entry> iter = v1.getStorage().entryIterator();\n-      while (iter.hasNext()) {\n-        Int2LongMap.Entry entry = iter.next();\n-        dot += entry.getLongValue() * v2Values[entry.getIntKey()];\n-      }\n-    } else if (v1.isSorted() && v2.isDense()) {\n-      int[] keys = v1.getStorage().getIndices();\n-      long[] v1Values = v1.getStorage().getValues();\n-      int[] v2Values = v2.getStorage().getValues();\n-      int size = v1.size();\n-      for (int i = 0; i < size; i++) {\n-        dot += v1Values[i] * v2Values[keys[i]];\n-      }\n-    } else if (v1.isSparse() && v2.isSparse()) {\n-      if (v1.size() < v2.size()) {\n-        ObjectIterator<Int2LongMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2LongMap.Entry entry = iter.next();\n-          dot += entry.getLongValue() * v2.get(entry.getIntKey());\n-        }\n-      } else {\n-        ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2IntMap.Entry entry = iter.next();\n-          dot += entry.getIntValue() * v1.get(entry.getIntKey());\n-        }\n+        dot += v1Values[idxs[i]];\n       }\n-    } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+    } else if (v1.isSparse()) {\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n         ObjectIterator<Int2LongMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Int2LongMap.Entry entry = iter.next();\n           dot += entry.getLongValue() * v2.get(entry.getIntKey());\n         }\n       } else {\n-        int[] keys = v2.getStorage().getIndices();\n-        int[] v2Values = v2.getStorage().getValues();\n         int size = v2.size();\n         for (int i = 0; i < size; i++) {\n-          dot += v2Values[i] * v1.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSparse()) {\n-      if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n-          && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2IntMap.Entry entry = iter.next();\n-          dot += entry.getIntValue() * v1.get(entry.getIntKey());\n-        }\n-      } else {\n-        int[] keys = v1.getStorage().getIndices();\n-        long[] v1Values = v1.getStorage().getValues();\n-        int size = v1.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v1Values[i] * v2.get(keys[i]);\n+          dot += v1.get(idxs[i]);\n         }\n       }\n-    } else if (v1.isSorted() && v2.isSorted()) {\n+    } else {\n       int[] keys1 = v1.getStorage().getIndices();\n       long[] v1Values = v1.getStorage().getValues();\n-      int[] keys2 = v2.getStorage().getIndices();\n-      int[] v2Values = v2.getStorage().getValues();\n-\n       int v1Pointor = 0;\n       int v2Pointor = 0;\n       int size1 = v1.size();\n       int size2 = v2.size();\n-\n       while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n-          dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n+        if (keys1[v1Pointor] == idxs[v2Pointor]) {\n+          dot += v1Values[v1Pointor];\n           v2Pointor++;\n           v1Pointor++;\n-        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n-          v2Pointor++;\n+        } else if (keys1[v1Pointor] > idxs[v2Pointor]) {\n+                 v2Pointor++;\n         } else {\n-          v1Pointor++;\n+                 v1Pointor++;\n         }\n       }\n-    } else {\n-      throw new AngelException(\"the operation is not support!\");\n     }\n+    return dot;\n+  }\n+\n+  private static double apply(IntLongVector v1, IntLongVector v2) {\n+    double dot = 0.0;\n+    if (v1.isDense() && v2.isDense()) {\n+      long[] v1Values = v1.getStorage().getValues();\n+      long[] v2Values = v2.getStorage().getValues();\n+      int length = v1Values.length;\n+      for (int i = 0; i < length; i++) {\n+        dot += v1Values[i] * v2Values[i];\n+      }\n+    } else if (v1.isDense() && v2.isSparse()) {\n+      long[] v1Values = v1.getStorage().getValues();\n+      ObjectIterator<Int2LongMap.Entry> iter = v2.getStorage().entryIterator();\n+      while (iter.hasNext()) {\n+        Int2LongMap.Entry entry = iter.next();\n+        dot += entry.getLongValue() * v1Values[entry.getIntKey()];\n+      }\n+    } else if (v1.isDense() && v2.isSorted()) {\n+             long[] v1Values = v1.getStorage().getValues();\n+             int[] keys = v2.getStorage().getIndices();\n+             long[] v2Values = v2.getStorage().getValues();\n+             int size = v2.size();\n+             for (int i = 0; i < size; i++) {\n+               dot += v2Values[i] * v1Values[keys[i]];\n+             }\n+           } else if (v1.isSparse() && v2.isDense()) {\n+             long[] v2Values = v2.getStorage().getValues();\n+             ObjectIterator<Int2LongMap.Entry> iter = v1.getStorage().entryIterator();\n+             while (iter.hasNext()) {\n+               Int2LongMap.Entry entry = iter.next();\n+               dot += entry.getLongValue() * v2Values[entry.getIntKey()];\n+             }\n+           } else if (v1.isSorted() && v2.isDense()) {\n+                    int[] keys = v1.getStorage().getIndices();\n+                    long[] v1Values = v1.getStorage().getValues();\n+                    long[] v2Values = v2.getStorage().getValues();\n+                    int size = v1.size();\n+                    for (int i = 0; i < size; i++) {\n+                      dot += v1Values[i] * v2Values[keys[i]];\n+                    }\n+                  } else if (v1.isSparse() && v2.isSparse()) {\n+                    if (v1.size() < v2.size()) {\n+                      ObjectIterator<Int2LongMap.Entry> iter = v1.getStorage().entryIterator();\n+                      while (iter.hasNext()) {\n+                        Int2LongMap.Entry entry = iter.next();\n+                        dot += entry.getLongValue() * v2.get(entry.getIntKey());\n+                      }\n+                    } else {\n+                      ObjectIterator<Int2LongMap.Entry> iter = v2.getStorage().entryIterator();\n+                      while (iter.hasNext()) {\n+                        Int2LongMap.Entry entry = iter.next();\n+                        dot += entry.getLongValue() * v1.get(entry.getIntKey());\n+                      }\n+                    }\n+                  } else if (v1.isSparse() && v2.isSorted()) {\n+                           if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+                             ObjectIterator<Int2LongMap.Entry> iter = v1.getStorage().entryIterator();\n+                             while (iter.hasNext()) {\n+                               Int2LongMap.Entry entry = iter.next();\n+                               dot += entry.getLongValue() * v2.get(entry.getIntKey());\n+                             }\n+                           } else {\n+                             int[] keys = v2.getStorage().getIndices();\n+                             long[] v2Values = v2.getStorage().getValues();\n+                             int size = v2.size();\n+                             for (int i = 0; i < size; i++) {\n+                               dot += v2Values[i] * v1.get(keys[i]);\n+                             }\n+                           }\n+                         } else if (v1.isSorted() && v2.isSparse()) {\n+                           if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size() && v1.size() > Constant.sortedThreshold * v1.dim()) {\n+                             ObjectIterator<Int2LongMap.Entry> iter = v2.getStorage().entryIterator();\n+                             while (iter.hasNext()) {\n+                               Int2LongMap.Entry entry = iter.next();\n+                               dot += entry.getLongValue() * v1.get(entry.getIntKey());\n+                             }\n+                           } else {\n+                             int[] keys = v1.getStorage().getIndices();\n+                             long[] v1Values = v1.getStorage().getValues();\n+                             int size = v1.size();\n+                             for (int i = 0; i < size; i++) {\n+                               dot += v1Values[i] * v2.get(keys[i]);\n+                             }\n+                           }\n+                         } else if (v1.isSorted() && v2.isSorted()) {\n+                                  int[] keys1 = v1.getStorage().getIndices();\n+                                  long[] v1Values = v1.getStorage().getValues();\n+                                  int[] keys2 = v2.getStorage().getIndices();\n+                                  long[] v2Values = v2.getStorage().getValues();\n+                                  int v1Pointor = 0;\n+                                  int v2Pointor = 0;\n+                                  int size1 = v1.size();\n+                                  int size2 = v2.size();\n+                                  while (v1Pointor < size1 && v2Pointor < size2) {\n+                                    if (keys1[v1Pointor] == keys2[v2Pointor]) {\n+                                      dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n+                                      v2Pointor++;\n+                                      v1Pointor++;\n+                                    } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n+                                             v2Pointor++;\n+                                    } else {\n+                                             v1Pointor++;\n+                                    }\n+                                  }\n+                                } else {\n+                                  throw new AngelException(\"the operation is not support!\");\n+                                }\n+    return dot;\n+  }\n \n+  private static double apply(IntLongVector v1, IntIntVector v2) {\n+    double dot = 0.0;\n+    if (v1.isDense() && v2.isDense()) {\n+      long[] v1Values = v1.getStorage().getValues();\n+      int[] v2Values = v2.getStorage().getValues();\n+      int length = v1Values.length;\n+      for (int i = 0; i < length; i++) {\n+        dot += v1Values[i] * v2Values[i];\n+      }\n+    } else if (v1.isDense() && v2.isSparse()) {\n+      long[] v1Values = v1.getStorage().getValues();\n+      ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n+      while (iter.hasNext()) {\n+        Int2IntMap.Entry entry = iter.next();\n+        dot += entry.getIntValue() * v1Values[entry.getIntKey()];\n+      }\n+    } else if (v1.isDense() && v2.isSorted()) {\n+             long[] v1Values = v1.getStorage().getValues();\n+             int[] keys = v2.getStorage().getIndices();\n+             int[] v2Values = v2.getStorage().getValues();\n+             int size = v2.size();\n+             for (int i = 0; i < size; i++) {\n+               dot += v2Values[i] * v1Values[keys[i]];\n+             }\n+           } else if (v1.isSparse() && v2.isDense()) {\n+             int[] v2Values = v2.getStorage().getValues();\n+             ObjectIterator<Int2LongMap.Entry> iter = v1.getStorage().entryIterator();\n+             while (iter.hasNext()) {\n+               Int2LongMap.Entry entry = iter.next();\n+               dot += entry.getLongValue() * v2Values[entry.getIntKey()];\n+             }\n+           } else if (v1.isSorted() && v2.isDense()) {\n+                    int[] keys = v1.getStorage().getIndices();\n+                    long[] v1Values = v1.getStorage().getValues();\n+                    int[] v2Values = v2.getStorage().getValues();\n+                    int size = v1.size();\n+                    for (int i = 0; i < size; i++) {\n+                      dot += v1Values[i] * v2Values[keys[i]];\n+                    }\n+                  } else if (v1.isSparse() && v2.isSparse()) {\n+                    if (v1.size() < v2.size()) {\n+                      ObjectIterator<Int2LongMap.Entry> iter = v1.getStorage().entryIterator();\n+                      while (iter.hasNext()) {\n+                        Int2LongMap.Entry entry = iter.next();\n+                        dot += entry.getLongValue() * v2.get(entry.getIntKey());\n+                      }\n+                    } else {\n+                      ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n+                      while (iter.hasNext()) {\n+                        Int2IntMap.Entry entry = iter.next();\n+                        dot += entry.getIntValue() * v1.get(entry.getIntKey());\n+                      }\n+                    }\n+                  } else if (v1.isSparse() && v2.isSorted()) {\n+                           if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+                             ObjectIterator<Int2LongMap.Entry> iter = v1.getStorage().entryIterator();\n+                             while (iter.hasNext()) {\n+                               Int2LongMap.Entry entry = iter.next();\n+                               dot += entry.getLongValue() * v2.get(entry.getIntKey());\n+                             }\n+                           } else {\n+                             int[] keys = v2.getStorage().getIndices();\n+                             int[] v2Values = v2.getStorage().getValues();\n+                             int size = v2.size();\n+                             for (int i = 0; i < size; i++) {\n+                               dot += v2Values[i] * v1.get(keys[i]);\n+                             }\n+                           }\n+                         } else if (v1.isSorted() && v2.isSparse()) {\n+                           if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size() && v1.size() > Constant.sortedThreshold * v1.dim()) {\n+                             ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n+                             while (iter.hasNext()) {\n+                               Int2IntMap.Entry entry = iter.next();\n+                               dot += entry.getIntValue() * v1.get(entry.getIntKey());\n+                             }\n+                           } else {\n+                             int[] keys = v1.getStorage().getIndices();\n+                             long[] v1Values = v1.getStorage().getValues();\n+                             int size = v1.size();\n+                             for (int i = 0; i < size; i++) {\n+                               dot += v1Values[i] * v2.get(keys[i]);\n+                             }\n+                           }\n+                         } else if (v1.isSorted() && v2.isSorted()) {\n+                                  int[] keys1 = v1.getStorage().getIndices();\n+                                  long[] v1Values = v1.getStorage().getValues();\n+                                  int[] keys2 = v2.getStorage().getIndices();\n+                                  int[] v2Values = v2.getStorage().getValues();\n+                                  int v1Pointor = 0;\n+                                  int v2Pointor = 0;\n+                                  int size1 = v1.size();\n+                                  int size2 = v2.size();\n+                                  while (v1Pointor < size1 && v2Pointor < size2) {\n+                                    if (keys1[v1Pointor] == keys2[v2Pointor]) {\n+                                      dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n+                                      v2Pointor++;\n+                                      v1Pointor++;\n+                                    } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n+                                             v2Pointor++;\n+                                    } else {\n+                                             v1Pointor++;\n+                                    }\n+                                  }\n+                                } else {\n+                                  throw new AngelException(\"the operation is not support!\");\n+                                }\n     return dot;\n   }\n \n@@ -1302,8 +1247,7 @@ public class SimpleDotExecutor {\n         dot += v1Values[idxs[i]];\n       }\n     } else if (v1.isSparse()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n         ObjectIterator<Int2IntMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Int2IntMap.Entry entry = iter.next();\n@@ -1318,21 +1262,19 @@ public class SimpleDotExecutor {\n     } else {\n       int[] keys1 = v1.getStorage().getIndices();\n       int[] v1Values = v1.getStorage().getValues();\n-\n       int v1Pointor = 0;\n       int v2Pointor = 0;\n       int size1 = v1.size();\n       int size2 = v2.size();\n-\n       while (v1Pointor < size1 && v2Pointor < size2) {\n         if (keys1[v1Pointor] == idxs[v2Pointor]) {\n           dot += v1Values[v1Pointor];\n           v2Pointor++;\n           v1Pointor++;\n         } else if (keys1[v1Pointor] > idxs[v2Pointor]) {\n-          v2Pointor++;\n+                 v2Pointor++;\n         } else {\n-          v1Pointor++;\n+                 v1Pointor++;\n         }\n       }\n     }\n@@ -1356,100 +1298,95 @@ public class SimpleDotExecutor {\n         dot += entry.getIntValue() * v1Values[entry.getIntKey()];\n       }\n     } else if (v1.isDense() && v2.isSorted()) {\n-      int[] v1Values = v1.getStorage().getValues();\n-      int[] keys = v2.getStorage().getIndices();\n-      int[] v2Values = v2.getStorage().getValues();\n-      int size = v2.size();\n-      for (int i = 0; i < size; i++) {\n-        dot += v2Values[i] * v1Values[keys[i]];\n-      }\n-    } else if (v1.isSparse() && v2.isDense()) {\n-      int[] v2Values = v2.getStorage().getValues();\n-      ObjectIterator<Int2IntMap.Entry> iter = v1.getStorage().entryIterator();\n-      while (iter.hasNext()) {\n-        Int2IntMap.Entry entry = iter.next();\n-        dot += entry.getIntValue() * v2Values[entry.getIntKey()];\n-      }\n-    } else if (v1.isSorted() && v2.isDense()) {\n-      int[] keys = v1.getStorage().getIndices();\n-      int[] v1Values = v1.getStorage().getValues();\n-      int[] v2Values = v2.getStorage().getValues();\n-      int size = v1.size();\n-      for (int i = 0; i < size; i++) {\n-        dot += v1Values[i] * v2Values[keys[i]];\n-      }\n-    } else if (v1.isSparse() && v2.isSparse()) {\n-      if (v1.size() < v2.size()) {\n-        ObjectIterator<Int2IntMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2IntMap.Entry entry = iter.next();\n-          dot += entry.getIntValue() * v2.get(entry.getIntKey());\n-        }\n-      } else {\n-        ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2IntMap.Entry entry = iter.next();\n-          dot += entry.getIntValue() * v1.get(entry.getIntKey());\n-        }\n-      }\n-    } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2IntMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2IntMap.Entry entry = iter.next();\n-          dot += entry.getIntValue() * v2.get(entry.getIntKey());\n-        }\n-      } else {\n-        int[] keys = v2.getStorage().getIndices();\n-        int[] v2Values = v2.getStorage().getValues();\n-        int size = v2.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v2Values[i] * v1.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSparse()) {\n-      if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n-          && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2IntMap.Entry entry = iter.next();\n-          dot += entry.getIntValue() * v1.get(entry.getIntKey());\n-        }\n-      } else {\n-        int[] keys = v1.getStorage().getIndices();\n-        int[] v1Values = v1.getStorage().getValues();\n-        int size = v1.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v1Values[i] * v2.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSorted()) {\n-      int[] keys1 = v1.getStorage().getIndices();\n-      int[] v1Values = v1.getStorage().getValues();\n-      int[] keys2 = v2.getStorage().getIndices();\n-      int[] v2Values = v2.getStorage().getValues();\n-\n-      int v1Pointor = 0;\n-      int v2Pointor = 0;\n-      int size1 = v1.size();\n-      int size2 = v2.size();\n-\n-      while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n-          dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n-          v2Pointor++;\n-          v1Pointor++;\n-        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n-          v2Pointor++;\n-        } else {\n-          v1Pointor++;\n-        }\n-      }\n-    } else {\n-      throw new AngelException(\"the operation is not support!\");\n-    }\n-\n+             int[] v1Values = v1.getStorage().getValues();\n+             int[] keys = v2.getStorage().getIndices();\n+             int[] v2Values = v2.getStorage().getValues();\n+             int size = v2.size();\n+             for (int i = 0; i < size; i++) {\n+               dot += v2Values[i] * v1Values[keys[i]];\n+             }\n+           } else if (v1.isSparse() && v2.isDense()) {\n+             int[] v2Values = v2.getStorage().getValues();\n+             ObjectIterator<Int2IntMap.Entry> iter = v1.getStorage().entryIterator();\n+             while (iter.hasNext()) {\n+               Int2IntMap.Entry entry = iter.next();\n+               dot += entry.getIntValue() * v2Values[entry.getIntKey()];\n+             }\n+           } else if (v1.isSorted() && v2.isDense()) {\n+                    int[] keys = v1.getStorage().getIndices();\n+                    int[] v1Values = v1.getStorage().getValues();\n+                    int[] v2Values = v2.getStorage().getValues();\n+                    int size = v1.size();\n+                    for (int i = 0; i < size; i++) {\n+                      dot += v1Values[i] * v2Values[keys[i]];\n+                    }\n+                  } else if (v1.isSparse() && v2.isSparse()) {\n+                    if (v1.size() < v2.size()) {\n+                      ObjectIterator<Int2IntMap.Entry> iter = v1.getStorage().entryIterator();\n+                      while (iter.hasNext()) {\n+                        Int2IntMap.Entry entry = iter.next();\n+                        dot += entry.getIntValue() * v2.get(entry.getIntKey());\n+                      }\n+                    } else {\n+                      ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n+                      while (iter.hasNext()) {\n+                        Int2IntMap.Entry entry = iter.next();\n+                        dot += entry.getIntValue() * v1.get(entry.getIntKey());\n+                      }\n+                    }\n+                  } else if (v1.isSparse() && v2.isSorted()) {\n+                           if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+                             ObjectIterator<Int2IntMap.Entry> iter = v1.getStorage().entryIterator();\n+                             while (iter.hasNext()) {\n+                               Int2IntMap.Entry entry = iter.next();\n+                               dot += entry.getIntValue() * v2.get(entry.getIntKey());\n+                             }\n+                           } else {\n+                             int[] keys = v2.getStorage().getIndices();\n+                             int[] v2Values = v2.getStorage().getValues();\n+                             int size = v2.size();\n+                             for (int i = 0; i < size; i++) {\n+                               dot += v2Values[i] * v1.get(keys[i]);\n+                             }\n+                           }\n+                         } else if (v1.isSorted() && v2.isSparse()) {\n+                           if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size() && v1.size() > Constant.sortedThreshold * v1.dim()) {\n+                             ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n+                             while (iter.hasNext()) {\n+                               Int2IntMap.Entry entry = iter.next();\n+                               dot += entry.getIntValue() * v1.get(entry.getIntKey());\n+                             }\n+                           } else {\n+                             int[] keys = v1.getStorage().getIndices();\n+                             int[] v1Values = v1.getStorage().getValues();\n+                             int size = v1.size();\n+                             for (int i = 0; i < size; i++) {\n+                               dot += v1Values[i] * v2.get(keys[i]);\n+                             }\n+                           }\n+                         } else if (v1.isSorted() && v2.isSorted()) {\n+                                  int[] keys1 = v1.getStorage().getIndices();\n+                                  int[] v1Values = v1.getStorage().getValues();\n+                                  int[] keys2 = v2.getStorage().getIndices();\n+                                  int[] v2Values = v2.getStorage().getValues();\n+                                  int v1Pointor = 0;\n+                                  int v2Pointor = 0;\n+                                  int size1 = v1.size();\n+                                  int size2 = v2.size();\n+                                  while (v1Pointor < size1 && v2Pointor < size2) {\n+                                    if (keys1[v1Pointor] == keys2[v2Pointor]) {\n+                                      dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n+                                      v2Pointor++;\n+                                      v1Pointor++;\n+                                    } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n+                                             v2Pointor++;\n+                                    } else {\n+                                             v1Pointor++;\n+                                    }\n+                                  }\n+                                } else {\n+                                  throw new AngelException(\"the operation is not support!\");\n+                                }\n     return dot;\n   }\n \n@@ -1460,16 +1397,15 @@ public class SimpleDotExecutor {\n     long[] keys2 = v2.getIndices();\n     int v1Pointor = 0;\n     int v2Pointor = 0;\n-\n     while (v1Pointor < keys1.length && v2Pointor < keys2.length) {\n       if (keys1[v1Pointor] == keys2[v2Pointor]) {\n         dot += 1.0;\n         v2Pointor++;\n         v1Pointor++;\n       } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n-        v2Pointor++;\n+               v2Pointor++;\n       } else {\n-        v1Pointor++;\n+               v1Pointor++;\n       }\n     }\n     return dot;\n@@ -1480,8 +1416,7 @@ public class SimpleDotExecutor {\n     double dot = 0.0;\n     long[] idxs = v2.getIndices();\n     if (v1.isSparse()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n         ObjectIterator<Long2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Long2DoubleMap.Entry entry = iter.next();\n@@ -1496,21 +1431,19 @@ public class SimpleDotExecutor {\n     } else {\n       long[] keys1 = v1.getStorage().getIndices();\n       double[] v1Values = v1.getStorage().getValues();\n-\n       int v1Pointor = 0;\n       int v2Pointor = 0;\n       long size1 = v1.size();\n       long size2 = v2.size();\n-\n       while (v1Pointor < size1 && v2Pointor < size2) {\n         if (keys1[v1Pointor] == idxs[v2Pointor]) {\n           dot += v1Values[v1Pointor];\n           v2Pointor++;\n           v1Pointor++;\n         } else if (keys1[v1Pointor] > idxs[v2Pointor]) {\n-          v2Pointor++;\n+                 v2Pointor++;\n         } else {\n-          v1Pointor++;\n+                 v1Pointor++;\n         }\n       }\n     }\n@@ -1534,8 +1467,7 @@ public class SimpleDotExecutor {\n         }\n       }\n     } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n         ObjectIterator<Long2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Long2DoubleMap.Entry entry = iter.next();\n@@ -1550,47 +1482,43 @@ public class SimpleDotExecutor {\n         }\n       }\n     } else if (v1.isSorted() && v2.isSparse()) {\n-      if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n-          && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2DoubleMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2DoubleMap.Entry entry = iter.next();\n-          dot += entry.getDoubleValue() * v1.get(entry.getLongKey());\n-        }\n-      } else {\n-        long[] keys = v1.getStorage().getIndices();\n-        double[] v1Values = v1.getStorage().getValues();\n-        long size = v1.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v1Values[i] * v2.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSorted()) {\n-      long[] keys1 = v1.getStorage().getIndices();\n-      double[] v1Values = v1.getStorage().getValues();\n-      long[] keys2 = v2.getStorage().getIndices();\n-      double[] v2Values = v2.getStorage().getValues();\n-\n-      int v1Pointor = 0;\n-      int v2Pointor = 0;\n-      long size1 = v1.size();\n-      long size2 = v2.size();\n-\n-      while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n-          dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n-          v2Pointor++;\n-          v1Pointor++;\n-        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n-          v2Pointor++;\n-        } else {\n-          v1Pointor++;\n-        }\n-      }\n-    } else {\n-      throw new AngelException(\"the operation is not support!\");\n-    }\n-\n+             if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size() && v1.size() > Constant.sortedThreshold * v1.dim()) {\n+               ObjectIterator<Long2DoubleMap.Entry> iter = v2.getStorage().entryIterator();\n+               while (iter.hasNext()) {\n+                 Long2DoubleMap.Entry entry = iter.next();\n+                 dot += entry.getDoubleValue() * v1.get(entry.getLongKey());\n+               }\n+             } else {\n+               long[] keys = v1.getStorage().getIndices();\n+               double[] v1Values = v1.getStorage().getValues();\n+               long size = v1.size();\n+               for (int i = 0; i < size; i++) {\n+                 dot += v1Values[i] * v2.get(keys[i]);\n+               }\n+             }\n+           } else if (v1.isSorted() && v2.isSorted()) {\n+             long[] keys1 = v1.getStorage().getIndices();\n+             double[] v1Values = v1.getStorage().getValues();\n+             long[] keys2 = v2.getStorage().getIndices();\n+             double[] v2Values = v2.getStorage().getValues();\n+             int v1Pointor = 0;\n+             int v2Pointor = 0;\n+             long size1 = v1.size();\n+             long size2 = v2.size();\n+             while (v1Pointor < size1 && v2Pointor < size2) {\n+               if (keys1[v1Pointor] == keys2[v2Pointor]) {\n+                 dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n+                 v2Pointor++;\n+                 v1Pointor++;\n+               } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n+                        v2Pointor++;\n+               } else {\n+                        v1Pointor++;\n+               }\n+             }\n+           } else {\n+             throw new AngelException(\"the operation is not support!\");\n+           }\n     return dot;\n   }\n \n@@ -1611,63 +1539,58 @@ public class SimpleDotExecutor {\n         }\n       }\n     } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n         ObjectIterator<Long2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Long2DoubleMap.Entry entry = iter.next();\n-          dot += entry.getDoubleValue() * v2.get(entry.getLongKey());\n-        }\n-      } else {\n-        long[] keys = v2.getStorage().getIndices();\n-        float[] v2Values = v2.getStorage().getValues();\n-        long size = v2.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v2Values[i] * v1.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSparse()) {\n-      if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n-          && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2FloatMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2FloatMap.Entry entry = iter.next();\n-          dot += entry.getFloatValue() * v1.get(entry.getLongKey());\n-        }\n-      } else {\n-        long[] keys = v1.getStorage().getIndices();\n-        double[] v1Values = v1.getStorage().getValues();\n-        long size = v1.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v1Values[i] * v2.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSorted()) {\n-      long[] keys1 = v1.getStorage().getIndices();\n-      double[] v1Values = v1.getStorage().getValues();\n-      long[] keys2 = v2.getStorage().getIndices();\n-      float[] v2Values = v2.getStorage().getValues();\n-\n-      int v1Pointor = 0;\n-      int v2Pointor = 0;\n-      long size1 = v1.size();\n-      long size2 = v2.size();\n-\n-      while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n-          dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n-          v2Pointor++;\n-          v1Pointor++;\n-        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n-          v2Pointor++;\n-        } else {\n-          v1Pointor++;\n+          dot += entry.getDoubleValue() * v2.get(entry.getLongKey());\n+        }\n+      } else {\n+        long[] keys = v2.getStorage().getIndices();\n+        float[] v2Values = v2.getStorage().getValues();\n+        long size = v2.size();\n+        for (int i = 0; i < size; i++) {\n+          dot += v2Values[i] * v1.get(keys[i]);\n         }\n       }\n-    } else {\n-      throw new AngelException(\"the operation is not support!\");\n-    }\n-\n+    } else if (v1.isSorted() && v2.isSparse()) {\n+             if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size() && v1.size() > Constant.sortedThreshold * v1.dim()) {\n+               ObjectIterator<Long2FloatMap.Entry> iter = v2.getStorage().entryIterator();\n+               while (iter.hasNext()) {\n+                 Long2FloatMap.Entry entry = iter.next();\n+                 dot += entry.getFloatValue() * v1.get(entry.getLongKey());\n+               }\n+             } else {\n+               long[] keys = v1.getStorage().getIndices();\n+               double[] v1Values = v1.getStorage().getValues();\n+               long size = v1.size();\n+               for (int i = 0; i < size; i++) {\n+                 dot += v1Values[i] * v2.get(keys[i]);\n+               }\n+             }\n+           } else if (v1.isSorted() && v2.isSorted()) {\n+             long[] keys1 = v1.getStorage().getIndices();\n+             double[] v1Values = v1.getStorage().getValues();\n+             long[] keys2 = v2.getStorage().getIndices();\n+             float[] v2Values = v2.getStorage().getValues();\n+             int v1Pointor = 0;\n+             int v2Pointor = 0;\n+             long size1 = v1.size();\n+             long size2 = v2.size();\n+             while (v1Pointor < size1 && v2Pointor < size2) {\n+               if (keys1[v1Pointor] == keys2[v2Pointor]) {\n+                 dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n+                 v2Pointor++;\n+                 v1Pointor++;\n+               } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n+                        v2Pointor++;\n+               } else {\n+                        v1Pointor++;\n+               }\n+             }\n+           } else {\n+             throw new AngelException(\"the operation is not support!\");\n+           }\n     return dot;\n   }\n \n@@ -1688,8 +1611,7 @@ public class SimpleDotExecutor {\n         }\n       }\n     } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n         ObjectIterator<Long2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Long2DoubleMap.Entry entry = iter.next();\n@@ -1704,47 +1626,43 @@ public class SimpleDotExecutor {\n         }\n       }\n     } else if (v1.isSorted() && v2.isSparse()) {\n-      if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n-          && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2LongMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2LongMap.Entry entry = iter.next();\n-          dot += entry.getLongValue() * v1.get(entry.getLongKey());\n-        }\n-      } else {\n-        long[] keys = v1.getStorage().getIndices();\n-        double[] v1Values = v1.getStorage().getValues();\n-        long size = v1.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v1Values[i] * v2.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSorted()) {\n-      long[] keys1 = v1.getStorage().getIndices();\n-      double[] v1Values = v1.getStorage().getValues();\n-      long[] keys2 = v2.getStorage().getIndices();\n-      long[] v2Values = v2.getStorage().getValues();\n-\n-      int v1Pointor = 0;\n-      int v2Pointor = 0;\n-      long size1 = v1.size();\n-      long size2 = v2.size();\n-\n-      while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n-          dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n-          v2Pointor++;\n-          v1Pointor++;\n-        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n-          v2Pointor++;\n-        } else {\n-          v1Pointor++;\n-        }\n-      }\n-    } else {\n-      throw new AngelException(\"the operation is not support!\");\n-    }\n-\n+             if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size() && v1.size() > Constant.sortedThreshold * v1.dim()) {\n+               ObjectIterator<Long2LongMap.Entry> iter = v2.getStorage().entryIterator();\n+               while (iter.hasNext()) {\n+                 Long2LongMap.Entry entry = iter.next();\n+                 dot += entry.getLongValue() * v1.get(entry.getLongKey());\n+               }\n+             } else {\n+               long[] keys = v1.getStorage().getIndices();\n+               double[] v1Values = v1.getStorage().getValues();\n+               long size = v1.size();\n+               for (int i = 0; i < size; i++) {\n+                 dot += v1Values[i] * v2.get(keys[i]);\n+               }\n+             }\n+           } else if (v1.isSorted() && v2.isSorted()) {\n+             long[] keys1 = v1.getStorage().getIndices();\n+             double[] v1Values = v1.getStorage().getValues();\n+             long[] keys2 = v2.getStorage().getIndices();\n+             long[] v2Values = v2.getStorage().getValues();\n+             int v1Pointor = 0;\n+             int v2Pointor = 0;\n+             long size1 = v1.size();\n+             long size2 = v2.size();\n+             while (v1Pointor < size1 && v2Pointor < size2) {\n+               if (keys1[v1Pointor] == keys2[v2Pointor]) {\n+                 dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n+                 v2Pointor++;\n+                 v1Pointor++;\n+               } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n+                        v2Pointor++;\n+               } else {\n+                        v1Pointor++;\n+               }\n+             }\n+           } else {\n+             throw new AngelException(\"the operation is not support!\");\n+           }\n     return dot;\n   }\n \n@@ -1765,8 +1683,7 @@ public class SimpleDotExecutor {\n         }\n       }\n     } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n         ObjectIterator<Long2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Long2DoubleMap.Entry entry = iter.next();\n@@ -1781,47 +1698,43 @@ public class SimpleDotExecutor {\n         }\n       }\n     } else if (v1.isSorted() && v2.isSparse()) {\n-      if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n-          && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2IntMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2IntMap.Entry entry = iter.next();\n-          dot += entry.getIntValue() * v1.get(entry.getLongKey());\n-        }\n-      } else {\n-        long[] keys = v1.getStorage().getIndices();\n-        double[] v1Values = v1.getStorage().getValues();\n-        long size = v1.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v1Values[i] * v2.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSorted()) {\n-      long[] keys1 = v1.getStorage().getIndices();\n-      double[] v1Values = v1.getStorage().getValues();\n-      long[] keys2 = v2.getStorage().getIndices();\n-      int[] v2Values = v2.getStorage().getValues();\n-\n-      int v1Pointor = 0;\n-      int v2Pointor = 0;\n-      long size1 = v1.size();\n-      long size2 = v2.size();\n-\n-      while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n-          dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n-          v2Pointor++;\n-          v1Pointor++;\n-        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n-          v2Pointor++;\n-        } else {\n-          v1Pointor++;\n-        }\n-      }\n-    } else {\n-      throw new AngelException(\"the operation is not support!\");\n-    }\n-\n+             if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size() && v1.size() > Constant.sortedThreshold * v1.dim()) {\n+               ObjectIterator<Long2IntMap.Entry> iter = v2.getStorage().entryIterator();\n+               while (iter.hasNext()) {\n+                 Long2IntMap.Entry entry = iter.next();\n+                 dot += entry.getIntValue() * v1.get(entry.getLongKey());\n+               }\n+             } else {\n+               long[] keys = v1.getStorage().getIndices();\n+               double[] v1Values = v1.getStorage().getValues();\n+               long size = v1.size();\n+               for (int i = 0; i < size; i++) {\n+                 dot += v1Values[i] * v2.get(keys[i]);\n+               }\n+             }\n+           } else if (v1.isSorted() && v2.isSorted()) {\n+             long[] keys1 = v1.getStorage().getIndices();\n+             double[] v1Values = v1.getStorage().getValues();\n+             long[] keys2 = v2.getStorage().getIndices();\n+             int[] v2Values = v2.getStorage().getValues();\n+             int v1Pointor = 0;\n+             int v2Pointor = 0;\n+             long size1 = v1.size();\n+             long size2 = v2.size();\n+             while (v1Pointor < size1 && v2Pointor < size2) {\n+               if (keys1[v1Pointor] == keys2[v2Pointor]) {\n+                 dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n+                 v2Pointor++;\n+                 v1Pointor++;\n+               } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n+                        v2Pointor++;\n+               } else {\n+                        v1Pointor++;\n+               }\n+             }\n+           } else {\n+             throw new AngelException(\"the operation is not support!\");\n+           }\n     return dot;\n   }\n \n@@ -1830,8 +1743,7 @@ public class SimpleDotExecutor {\n     double dot = 0.0;\n     long[] idxs = v2.getIndices();\n     if (v1.isSparse()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n         ObjectIterator<Long2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Long2FloatMap.Entry entry = iter.next();\n@@ -1846,21 +1758,19 @@ public class SimpleDotExecutor {\n     } else {\n       long[] keys1 = v1.getStorage().getIndices();\n       float[] v1Values = v1.getStorage().getValues();\n-\n       int v1Pointor = 0;\n       int v2Pointor = 0;\n       long size1 = v1.size();\n       long size2 = v2.size();\n-\n       while (v1Pointor < size1 && v2Pointor < size2) {\n         if (keys1[v1Pointor] == idxs[v2Pointor]) {\n           dot += v1Values[v1Pointor];\n           v2Pointor++;\n           v1Pointor++;\n         } else if (keys1[v1Pointor] > idxs[v2Pointor]) {\n-          v2Pointor++;\n+                 v2Pointor++;\n         } else {\n-          v1Pointor++;\n+                 v1Pointor++;\n         }\n       }\n     }\n@@ -1884,8 +1794,7 @@ public class SimpleDotExecutor {\n         }\n       }\n     } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n         ObjectIterator<Long2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Long2FloatMap.Entry entry = iter.next();\n@@ -1900,47 +1809,43 @@ public class SimpleDotExecutor {\n         }\n       }\n     } else if (v1.isSorted() && v2.isSparse()) {\n-      if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n-          && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2FloatMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2FloatMap.Entry entry = iter.next();\n-          dot += entry.getFloatValue() * v1.get(entry.getLongKey());\n-        }\n-      } else {\n-        long[] keys = v1.getStorage().getIndices();\n-        float[] v1Values = v1.getStorage().getValues();\n-        long size = v1.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v1Values[i] * v2.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSorted()) {\n-      long[] keys1 = v1.getStorage().getIndices();\n-      float[] v1Values = v1.getStorage().getValues();\n-      long[] keys2 = v2.getStorage().getIndices();\n-      float[] v2Values = v2.getStorage().getValues();\n-\n-      int v1Pointor = 0;\n-      int v2Pointor = 0;\n-      long size1 = v1.size();\n-      long size2 = v2.size();\n-\n-      while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n-          dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n-          v2Pointor++;\n-          v1Pointor++;\n-        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n-          v2Pointor++;\n-        } else {\n-          v1Pointor++;\n-        }\n-      }\n-    } else {\n-      throw new AngelException(\"the operation is not support!\");\n-    }\n-\n+             if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size() && v1.size() > Constant.sortedThreshold * v1.dim()) {\n+               ObjectIterator<Long2FloatMap.Entry> iter = v2.getStorage().entryIterator();\n+               while (iter.hasNext()) {\n+                 Long2FloatMap.Entry entry = iter.next();\n+                 dot += entry.getFloatValue() * v1.get(entry.getLongKey());\n+               }\n+             } else {\n+               long[] keys = v1.getStorage().getIndices();\n+               float[] v1Values = v1.getStorage().getValues();\n+               long size = v1.size();\n+               for (int i = 0; i < size; i++) {\n+                 dot += v1Values[i] * v2.get(keys[i]);\n+               }\n+             }\n+           } else if (v1.isSorted() && v2.isSorted()) {\n+             long[] keys1 = v1.getStorage().getIndices();\n+             float[] v1Values = v1.getStorage().getValues();\n+             long[] keys2 = v2.getStorage().getIndices();\n+             float[] v2Values = v2.getStorage().getValues();\n+             int v1Pointor = 0;\n+             int v2Pointor = 0;\n+             long size1 = v1.size();\n+             long size2 = v2.size();\n+             while (v1Pointor < size1 && v2Pointor < size2) {\n+               if (keys1[v1Pointor] == keys2[v2Pointor]) {\n+                 dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n+                 v2Pointor++;\n+                 v1Pointor++;\n+               } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n+                        v2Pointor++;\n+               } else {\n+                        v1Pointor++;\n+               }\n+             }\n+           } else {\n+             throw new AngelException(\"the operation is not support!\");\n+           }\n     return dot;\n   }\n \n@@ -1961,8 +1866,7 @@ public class SimpleDotExecutor {\n         }\n       }\n     } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n         ObjectIterator<Long2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Long2FloatMap.Entry entry = iter.next();\n@@ -1977,47 +1881,43 @@ public class SimpleDotExecutor {\n         }\n       }\n     } else if (v1.isSorted() && v2.isSparse()) {\n-      if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n-          && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2LongMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2LongMap.Entry entry = iter.next();\n-          dot += entry.getLongValue() * v1.get(entry.getLongKey());\n-        }\n-      } else {\n-        long[] keys = v1.getStorage().getIndices();\n-        float[] v1Values = v1.getStorage().getValues();\n-        long size = v1.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v1Values[i] * v2.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSorted()) {\n-      long[] keys1 = v1.getStorage().getIndices();\n-      float[] v1Values = v1.getStorage().getValues();\n-      long[] keys2 = v2.getStorage().getIndices();\n-      long[] v2Values = v2.getStorage().getValues();\n-\n-      int v1Pointor = 0;\n-      int v2Pointor = 0;\n-      long size1 = v1.size();\n-      long size2 = v2.size();\n-\n-      while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n-          dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n-          v2Pointor++;\n-          v1Pointor++;\n-        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n-          v2Pointor++;\n-        } else {\n-          v1Pointor++;\n-        }\n-      }\n-    } else {\n-      throw new AngelException(\"the operation is not support!\");\n-    }\n-\n+             if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size() && v1.size() > Constant.sortedThreshold * v1.dim()) {\n+               ObjectIterator<Long2LongMap.Entry> iter = v2.getStorage().entryIterator();\n+               while (iter.hasNext()) {\n+                 Long2LongMap.Entry entry = iter.next();\n+                 dot += entry.getLongValue() * v1.get(entry.getLongKey());\n+               }\n+             } else {\n+               long[] keys = v1.getStorage().getIndices();\n+               float[] v1Values = v1.getStorage().getValues();\n+               long size = v1.size();\n+               for (int i = 0; i < size; i++) {\n+                 dot += v1Values[i] * v2.get(keys[i]);\n+               }\n+             }\n+           } else if (v1.isSorted() && v2.isSorted()) {\n+             long[] keys1 = v1.getStorage().getIndices();\n+             float[] v1Values = v1.getStorage().getValues();\n+             long[] keys2 = v2.getStorage().getIndices();\n+             long[] v2Values = v2.getStorage().getValues();\n+             int v1Pointor = 0;\n+             int v2Pointor = 0;\n+             long size1 = v1.size();\n+             long size2 = v2.size();\n+             while (v1Pointor < size1 && v2Pointor < size2) {\n+               if (keys1[v1Pointor] == keys2[v2Pointor]) {\n+                 dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n+                 v2Pointor++;\n+                 v1Pointor++;\n+               } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n+                        v2Pointor++;\n+               } else {\n+                        v1Pointor++;\n+               }\n+             }\n+           } else {\n+             throw new AngelException(\"the operation is not support!\");\n+           }\n     return dot;\n   }\n \n@@ -2038,8 +1938,7 @@ public class SimpleDotExecutor {\n         }\n       }\n     } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n         ObjectIterator<Long2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Long2FloatMap.Entry entry = iter.next();\n@@ -2054,47 +1953,43 @@ public class SimpleDotExecutor {\n         }\n       }\n     } else if (v1.isSorted() && v2.isSparse()) {\n-      if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n-          && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2IntMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2IntMap.Entry entry = iter.next();\n-          dot += entry.getIntValue() * v1.get(entry.getLongKey());\n-        }\n-      } else {\n-        long[] keys = v1.getStorage().getIndices();\n-        float[] v1Values = v1.getStorage().getValues();\n-        long size = v1.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v1Values[i] * v2.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSorted()) {\n-      long[] keys1 = v1.getStorage().getIndices();\n-      float[] v1Values = v1.getStorage().getValues();\n-      long[] keys2 = v2.getStorage().getIndices();\n-      int[] v2Values = v2.getStorage().getValues();\n-\n-      int v1Pointor = 0;\n-      int v2Pointor = 0;\n-      long size1 = v1.size();\n-      long size2 = v2.size();\n-\n-      while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n-          dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n-          v2Pointor++;\n-          v1Pointor++;\n-        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n-          v2Pointor++;\n-        } else {\n-          v1Pointor++;\n-        }\n-      }\n-    } else {\n-      throw new AngelException(\"the operation is not support!\");\n-    }\n-\n+             if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size() && v1.size() > Constant.sortedThreshold * v1.dim()) {\n+               ObjectIterator<Long2IntMap.Entry> iter = v2.getStorage().entryIterator();\n+               while (iter.hasNext()) {\n+                 Long2IntMap.Entry entry = iter.next();\n+                 dot += entry.getIntValue() * v1.get(entry.getLongKey());\n+               }\n+             } else {\n+               long[] keys = v1.getStorage().getIndices();\n+               float[] v1Values = v1.getStorage().getValues();\n+               long size = v1.size();\n+               for (int i = 0; i < size; i++) {\n+                 dot += v1Values[i] * v2.get(keys[i]);\n+               }\n+             }\n+           } else if (v1.isSorted() && v2.isSorted()) {\n+             long[] keys1 = v1.getStorage().getIndices();\n+             float[] v1Values = v1.getStorage().getValues();\n+             long[] keys2 = v2.getStorage().getIndices();\n+             int[] v2Values = v2.getStorage().getValues();\n+             int v1Pointor = 0;\n+             int v2Pointor = 0;\n+             long size1 = v1.size();\n+             long size2 = v2.size();\n+             while (v1Pointor < size1 && v2Pointor < size2) {\n+               if (keys1[v1Pointor] == keys2[v2Pointor]) {\n+                 dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n+                 v2Pointor++;\n+                 v1Pointor++;\n+               } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n+                        v2Pointor++;\n+               } else {\n+                        v1Pointor++;\n+               }\n+             }\n+           } else {\n+             throw new AngelException(\"the operation is not support!\");\n+           }\n     return dot;\n   }\n \n@@ -2103,8 +1998,7 @@ public class SimpleDotExecutor {\n     double dot = 0.0;\n     long[] idxs = v2.getIndices();\n     if (v1.isSparse()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n         ObjectIterator<Long2LongMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Long2LongMap.Entry entry = iter.next();\n@@ -2119,21 +2013,19 @@ public class SimpleDotExecutor {\n     } else {\n       long[] keys1 = v1.getStorage().getIndices();\n       long[] v1Values = v1.getStorage().getValues();\n-\n       int v1Pointor = 0;\n       int v2Pointor = 0;\n       long size1 = v1.size();\n       long size2 = v2.size();\n-\n       while (v1Pointor < size1 && v2Pointor < size2) {\n         if (keys1[v1Pointor] == idxs[v2Pointor]) {\n           dot += v1Values[v1Pointor];\n           v2Pointor++;\n           v1Pointor++;\n         } else if (keys1[v1Pointor] > idxs[v2Pointor]) {\n-          v2Pointor++;\n+                 v2Pointor++;\n         } else {\n-          v1Pointor++;\n+                 v1Pointor++;\n         }\n       }\n     }\n@@ -2157,8 +2049,7 @@ public class SimpleDotExecutor {\n         }\n       }\n     } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n         ObjectIterator<Long2LongMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Long2LongMap.Entry entry = iter.next();\n@@ -2173,47 +2064,43 @@ public class SimpleDotExecutor {\n         }\n       }\n     } else if (v1.isSorted() && v2.isSparse()) {\n-      if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n-          && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2LongMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2LongMap.Entry entry = iter.next();\n-          dot += entry.getLongValue() * v1.get(entry.getLongKey());\n-        }\n-      } else {\n-        long[] keys = v1.getStorage().getIndices();\n-        long[] v1Values = v1.getStorage().getValues();\n-        long size = v1.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v1Values[i] * v2.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSorted()) {\n-      long[] keys1 = v1.getStorage().getIndices();\n-      long[] v1Values = v1.getStorage().getValues();\n-      long[] keys2 = v2.getStorage().getIndices();\n-      long[] v2Values = v2.getStorage().getValues();\n-\n-      int v1Pointor = 0;\n-      int v2Pointor = 0;\n-      long size1 = v1.size();\n-      long size2 = v2.size();\n-\n-      while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n-          dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n-          v2Pointor++;\n-          v1Pointor++;\n-        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n-          v2Pointor++;\n-        } else {\n-          v1Pointor++;\n-        }\n-      }\n-    } else {\n-      throw new AngelException(\"the operation is not support!\");\n-    }\n-\n+             if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size() && v1.size() > Constant.sortedThreshold * v1.dim()) {\n+               ObjectIterator<Long2LongMap.Entry> iter = v2.getStorage().entryIterator();\n+               while (iter.hasNext()) {\n+                 Long2LongMap.Entry entry = iter.next();\n+                 dot += entry.getLongValue() * v1.get(entry.getLongKey());\n+               }\n+             } else {\n+               long[] keys = v1.getStorage().getIndices();\n+               long[] v1Values = v1.getStorage().getValues();\n+               long size = v1.size();\n+               for (int i = 0; i < size; i++) {\n+                 dot += v1Values[i] * v2.get(keys[i]);\n+               }\n+             }\n+           } else if (v1.isSorted() && v2.isSorted()) {\n+             long[] keys1 = v1.getStorage().getIndices();\n+             long[] v1Values = v1.getStorage().getValues();\n+             long[] keys2 = v2.getStorage().getIndices();\n+             long[] v2Values = v2.getStorage().getValues();\n+             int v1Pointor = 0;\n+             int v2Pointor = 0;\n+             long size1 = v1.size();\n+             long size2 = v2.size();\n+             while (v1Pointor < size1 && v2Pointor < size2) {\n+               if (keys1[v1Pointor] == keys2[v2Pointor]) {\n+                 dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n+                 v2Pointor++;\n+                 v1Pointor++;\n+               } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n+                        v2Pointor++;\n+               } else {\n+                        v1Pointor++;\n+               }\n+             }\n+           } else {\n+             throw new AngelException(\"the operation is not support!\");\n+           }\n     return dot;\n   }\n \n@@ -2234,8 +2121,7 @@ public class SimpleDotExecutor {\n         }\n       }\n     } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n         ObjectIterator<Long2LongMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Long2LongMap.Entry entry = iter.next();\n@@ -2250,47 +2136,43 @@ public class SimpleDotExecutor {\n         }\n       }\n     } else if (v1.isSorted() && v2.isSparse()) {\n-      if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n-          && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2IntMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2IntMap.Entry entry = iter.next();\n-          dot += entry.getIntValue() * v1.get(entry.getLongKey());\n-        }\n-      } else {\n-        long[] keys = v1.getStorage().getIndices();\n-        long[] v1Values = v1.getStorage().getValues();\n-        long size = v1.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v1Values[i] * v2.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSorted()) {\n-      long[] keys1 = v1.getStorage().getIndices();\n-      long[] v1Values = v1.getStorage().getValues();\n-      long[] keys2 = v2.getStorage().getIndices();\n-      int[] v2Values = v2.getStorage().getValues();\n-\n-      int v1Pointor = 0;\n-      int v2Pointor = 0;\n-      long size1 = v1.size();\n-      long size2 = v2.size();\n-\n-      while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n-          dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n-          v2Pointor++;\n-          v1Pointor++;\n-        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n-          v2Pointor++;\n-        } else {\n-          v1Pointor++;\n-        }\n-      }\n-    } else {\n-      throw new AngelException(\"the operation is not support!\");\n-    }\n-\n+             if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size() && v1.size() > Constant.sortedThreshold * v1.dim()) {\n+               ObjectIterator<Long2IntMap.Entry> iter = v2.getStorage().entryIterator();\n+               while (iter.hasNext()) {\n+                 Long2IntMap.Entry entry = iter.next();\n+                 dot += entry.getIntValue() * v1.get(entry.getLongKey());\n+               }\n+             } else {\n+               long[] keys = v1.getStorage().getIndices();\n+               long[] v1Values = v1.getStorage().getValues();\n+               long size = v1.size();\n+               for (int i = 0; i < size; i++) {\n+                 dot += v1Values[i] * v2.get(keys[i]);\n+               }\n+             }\n+           } else if (v1.isSorted() && v2.isSorted()) {\n+             long[] keys1 = v1.getStorage().getIndices();\n+             long[] v1Values = v1.getStorage().getValues();\n+             long[] keys2 = v2.getStorage().getIndices();\n+             int[] v2Values = v2.getStorage().getValues();\n+             int v1Pointor = 0;\n+             int v2Pointor = 0;\n+             long size1 = v1.size();\n+             long size2 = v2.size();\n+             while (v1Pointor < size1 && v2Pointor < size2) {\n+               if (keys1[v1Pointor] == keys2[v2Pointor]) {\n+                 dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n+                 v2Pointor++;\n+                 v1Pointor++;\n+               } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n+                        v2Pointor++;\n+               } else {\n+                        v1Pointor++;\n+               }\n+             }\n+           } else {\n+             throw new AngelException(\"the operation is not support!\");\n+           }\n     return dot;\n   }\n \n@@ -2299,8 +2181,7 @@ public class SimpleDotExecutor {\n     double dot = 0.0;\n     long[] idxs = v2.getIndices();\n     if (v1.isSparse()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n         ObjectIterator<Long2IntMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Long2IntMap.Entry entry = iter.next();\n@@ -2315,21 +2196,19 @@ public class SimpleDotExecutor {\n     } else {\n       long[] keys1 = v1.getStorage().getIndices();\n       int[] v1Values = v1.getStorage().getValues();\n-\n       int v1Pointor = 0;\n       int v2Pointor = 0;\n       long size1 = v1.size();\n       long size2 = v2.size();\n-\n       while (v1Pointor < size1 && v2Pointor < size2) {\n         if (keys1[v1Pointor] == idxs[v2Pointor]) {\n           dot += v1Values[v1Pointor];\n           v2Pointor++;\n           v1Pointor++;\n         } else if (keys1[v1Pointor] > idxs[v2Pointor]) {\n-          v2Pointor++;\n+                 v2Pointor++;\n         } else {\n-          v1Pointor++;\n+                 v1Pointor++;\n         }\n       }\n     }\n@@ -2353,8 +2232,7 @@ public class SimpleDotExecutor {\n         }\n       }\n     } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n         ObjectIterator<Long2IntMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Long2IntMap.Entry entry = iter.next();\n@@ -2369,48 +2247,44 @@ public class SimpleDotExecutor {\n         }\n       }\n     } else if (v1.isSorted() && v2.isSparse()) {\n-      if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n-          && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2IntMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2IntMap.Entry entry = iter.next();\n-          dot += entry.getIntValue() * v1.get(entry.getLongKey());\n-        }\n-      } else {\n-        long[] keys = v1.getStorage().getIndices();\n-        int[] v1Values = v1.getStorage().getValues();\n-        long size = v1.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v1Values[i] * v2.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSorted()) {\n-      long[] keys1 = v1.getStorage().getIndices();\n-      int[] v1Values = v1.getStorage().getValues();\n-      long[] keys2 = v2.getStorage().getIndices();\n-      int[] v2Values = v2.getStorage().getValues();\n-\n-      int v1Pointor = 0;\n-      int v2Pointor = 0;\n-      long size1 = v1.size();\n-      long size2 = v2.size();\n-\n-      while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n-          dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n-          v2Pointor++;\n-          v1Pointor++;\n-        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n-          v2Pointor++;\n-        } else {\n-          v1Pointor++;\n-        }\n-      }\n-    } else {\n-      throw new AngelException(\"the operation is not support!\");\n-    }\n-\n+             if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size() && v1.size() > Constant.sortedThreshold * v1.dim()) {\n+               ObjectIterator<Long2IntMap.Entry> iter = v2.getStorage().entryIterator();\n+               while (iter.hasNext()) {\n+                 Long2IntMap.Entry entry = iter.next();\n+                 dot += entry.getIntValue() * v1.get(entry.getLongKey());\n+               }\n+             } else {\n+               long[] keys = v1.getStorage().getIndices();\n+               int[] v1Values = v1.getStorage().getValues();\n+               long size = v1.size();\n+               for (int i = 0; i < size; i++) {\n+                 dot += v1Values[i] * v2.get(keys[i]);\n+               }\n+             }\n+           } else if (v1.isSorted() && v2.isSorted()) {\n+             long[] keys1 = v1.getStorage().getIndices();\n+             int[] v1Values = v1.getStorage().getValues();\n+             long[] keys2 = v2.getStorage().getIndices();\n+             int[] v2Values = v2.getStorage().getValues();\n+             int v1Pointor = 0;\n+             int v2Pointor = 0;\n+             long size1 = v1.size();\n+             long size2 = v2.size();\n+             while (v1Pointor < size1 && v2Pointor < size2) {\n+               if (keys1[v1Pointor] == keys2[v2Pointor]) {\n+                 dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n+                 v2Pointor++;\n+                 v1Pointor++;\n+               } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n+                        v2Pointor++;\n+               } else {\n+                        v1Pointor++;\n+               }\n+             }\n+           } else {\n+             throw new AngelException(\"the operation is not support!\");\n+           }\n     return dot;\n   }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 2257
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ],
    "repaired_by": [],
    "not_repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}