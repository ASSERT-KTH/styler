{
    "project_name": "moquette-io-moquette",
    "error_id": "3",
    "information": {
        "errors": [
            {
                "line": "238",
                "severity": "warning",
                "message": "Line is longer than 120 characters (found 124).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": "            ByteBuffer bb = (ByteBuffer) ByteBuffer.allocate(willPayload.length).put(willPayload).flip();\n            // save the will testament in the clientID store\n            WillMessage will = new WillMessage(msg.payload().willTopic(), bb, msg.variableHeader().isWillRetain(), willQos);\n            willMessages.put(clientId, will);\n            LOG.debug(\"MQTT last will and testament has been configured. CId={}\", clientId);\n        }",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "238",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 124).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/errored/1/3/DurableSession.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/intellij/3/DurableSession.java\nindex 467c48773de..ffb6dcb039a 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/errored/1/3/DurableSession.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/intellij/3/DurableSession.java\n@@ -13,6 +13,7 @@\n  *\n  * You may elect to redistribute this code under either of these licenses.\n  */\n+\n package io.moquette.spi;\n \n import io.moquette.spi.impl.WillMessage;\n@@ -32,222 +33,222 @@ import java.util.concurrent.ConcurrentMap;\n \n public class DurableSession extends ClientSession {\n \n-    class OutboundFlightZone {\n-\n-        /**\n-         * Save the binding messageID, clientID - message\n-         *\n-         * @param messageID the packet ID used in transmission\n-         * @param msg the message to put in flight zone\n-         */\n-        void waitingAck(int messageID, IMessagesStore.StoredMessage msg) {\n-            if (LOG.isTraceEnabled()) {\n-                LOG.trace(\"Adding to inflight {}, guid <{}>\", messageID, msg.getGuid());\n-            }\n-            sessionsStore.inFlight(clientID, messageID, msg);\n-        }\n-\n-        IMessagesStore.StoredMessage acknowledged(int messageID) {\n-            if (LOG.isTraceEnabled()) {\n-                LOG.trace(\"Acknowledging inflight, clientID <{}> messageID {}\", clientID, messageID);\n-            }\n-            return sessionsStore.inFlightAck(clientID, messageID);\n-        }\n-    }\n-\n-    private static final Logger LOG = LoggerFactory.getLogger(DurableSession.class);\n-\n-    private final ISessionsStore sessionsStore;\n-    private final ISubscriptionsStore subscriptionsStore;\n-\n-    private final OutboundFlightZone outboundFlightZone;\n-    private final InboundFlightZone inboundFlightZone;\n-    private final ConcurrentMap<String, WillMessage> willMessages;\n-\n-    public DurableSession(String clientID, ISessionsStore sessions, ISubscriptionsStore subscriptionsStore,\n-                          ConcurrentMap<String, WillMessage> willMessages) {\n-        super(clientID);\n-        this.subscriptionsStore = subscriptionsStore;\n-        this.sessionsStore = sessions;\n-        this.willMessages = willMessages;\n-        this.outboundFlightZone = new OutboundFlightZone();\n-        this.inboundFlightZone = new InboundFlightZone();\n-    }\n-\n-    public void reloadAllSubscriptionsFromStore() {\n-        Collection<Subscription> reloadedSubscriptions = this.subscriptionsStore.listClientSubscriptions(this.clientID);\n-        this.subscriptions.addAll(reloadedSubscriptions);\n-    }\n-\n-    @Override\n-    public boolean isCleanSession() {\n-        return false;\n-    }\n-\n-    @Override\n-    public boolean subscribe(Subscription newSubscription) {\n-        LOG.info(\"Adding new subscription. CId={}, topics={}, qos={}\", newSubscription.getClientId(),\n-            newSubscription.getTopicFilter(), newSubscription.getRequestedQos());\n-        boolean validTopic = newSubscription.getTopicFilter().isValid();\n-        if (!validTopic) {\n-            LOG.warn(\"The topic filter is not valid. CId={}, topics={}\", newSubscription.getClientId(),\n-                newSubscription.getTopicFilter());\n-            // send SUBACK with 0x80 for this topic filter\n-            return false;\n-        }\n-        Subscription existingSub = subscriptionsStore.reload(newSubscription);\n-        // update the selected subscriptions if not present or if has a greater qos\n-        if (existingSub == null || existingSub.qosLessThan(newSubscription)) {\n-            if (existingSub != null) {\n-                LOG.info(\"Subscription already existed with a lower QoS value. It will be updated. CId={}, \" +\n-                        \"topics={}, existingQos={}, newQos={}\", newSubscription.getClientId(),\n-                    newSubscription.getTopicFilter(), existingSub.getRequestedQos(), newSubscription.getRequestedQos());\n-                subscriptions.remove(newSubscription);\n-            }\n-            subscriptions.add(newSubscription);\n-            subscriptionsStore.addNewSubscription(newSubscription);\n-        }\n-        return true;\n-    }\n-\n-    @Override\n-    public void unsubscribeFrom(Topic topicFilter) {\n-        LOG.info(\"Removing subscription. CId={}, topics={}\", clientID, topicFilter);\n-        subscriptionsStore.removeSubscription(topicFilter, clientID);\n-        Set<Subscription> subscriptionsToRemove = new HashSet<>();\n-        for (Subscription sub : this.subscriptions) {\n-            if (sub.getTopicFilter().equals(topicFilter)) {\n-                subscriptionsToRemove.add(sub);\n-            }\n-        }\n-        subscriptions.removeAll(subscriptionsToRemove);\n-    }\n-\n-    @Override\n-    public void cleanSession() {\n-        sessionsStore.removeTemporaryQoS2(this.clientID);\n-        LOG.info(\"Wiping existing subscriptions. ClientId={}\", clientID);\n-        subscriptionsStore.wipeSubscriptions(clientID);\n-\n-        LOG.info(\"Removing queues. ClientId={}\", clientID);\n-        sessionsStore.dropQueue(clientID);\n-    }\n-\n-    @Override\n-    public void disconnect() {\n-        LOG.info(\"Client disconnected. Removing its subscriptions. CId={}\", clientID);\n-        // cleanup topic subscriptions\n-        cleanSession();\n-    }\n-\n-    @Override\n-    protected int nextPacketId() {\n-        return this.sessionsStore.nextPacketID(this.clientID);\n-    }\n-\n-    @Override\n-    public IMessagesStore.StoredMessage inFlightAcknowledged(int messageID) {\n-        return outboundFlightZone.acknowledged(messageID);\n-    }\n-\n-    @Override\n-    public int inFlightAckWaiting(IMessagesStore.StoredMessage msg) {\n-        LOG.debug(\"Adding message to inflight zone. CId={}\", clientID);\n-        int messageId = this.nextPacketId();\n-        outboundFlightZone.waitingAck(messageId, msg);\n-        return messageId;\n-    }\n-\n-    @Override\n-    public IMessagesStore.StoredMessage inboundInflight(int messageID) {\n-        return inboundFlightZone.lookup(messageID);\n-    }\n-\n-    @Override\n-    public void markAsInboundInflight(int messageID, IMessagesStore.StoredMessage msg) {\n-        inboundFlightZone.waitingRel(messageID, msg);\n-    }\n-\n-    @Override\n-    public void moveInFlightToSecondPhaseAckWaiting(int messageID, IMessagesStore.StoredMessage msg) {\n-        this.sessionsStore.moveInFlightToSecondPhaseAckWaiting(this.clientID, messageID, msg);\n-    }\n-\n-    @Override\n-    public boolean isEmptyQueue() {\n-        return this.sessionsStore.queue(clientID).isEmpty();\n-    }\n-\n-    @Override\n-    public void dropQueue() {\n-        LOG.debug(\"Removing messages of session. CId={}\", this.clientID);\n-        this.sessionsStore.dropQueue(this.clientID);\n-        LOG.debug(\"Messages of the session have been removed. CId={}\", this.clientID);\n-    }\n-\n-    @Override\n-    public EnqueuedMessage poll() {\n-        IMessagesStore.StoredMessage msg = this.sessionsStore.queue(clientID).poll();\n-        if (msg == null) {\n-            return null;\n-        }\n-        int messageId = this.inFlightAckWaiting(msg);\n-        return new EnqueuedMessage(msg, messageId);\n-    }\n-\n-    @Override\n-    public void enqueue(IMessagesStore.StoredMessage message) {\n-        this.sessionsStore.queue(this.clientID).add(message);\n-    }\n-\n-    @Override\n-    public IMessagesStore.StoredMessage completeReleasedPublish(int messageID) {\n-        return this.sessionsStore.completeReleasedPublish(clientID, messageID);\n-    }\n-\n-    @Override\n-    public int getPendingPublishMessagesNo() {\n-        return this.sessionsStore.queue(clientID).size();\n-    }\n-\n-    @Override\n-    public int countPubReleaseWaitingPubComplete() {\n-        return this.sessionsStore.countPubReleaseWaitingPubComplete(clientID);\n-    }\n-\n-    @Override\n-    public int getInflightMessagesNo() {\n-        return this.sessionsStore.getInflightMessagesNo(clientID);\n-    }\n-\n-    @Override\n-    public void wipeSubscriptions() {\n-        this.subscriptionsStore.wipeSubscriptions(clientID);\n-    }\n-\n-    @Override\n-    public void storeWillMessage(MqttConnectMessage msg, String clientId) {\n-        // Handle will flag\n-        if (msg.variableHeader().isWillFlag()) {\n-            MqttQoS willQos = MqttQoS.valueOf(msg.variableHeader().willQos());\n-            LOG.debug(\"Configuring MQTT last will and testament CId={}, willQos={}, willTopic={}, willRetain={}\",\n-                clientId, willQos, msg.payload().willTopic(), msg.variableHeader().isWillRetain());\n-            byte[] willPayload = msg.payload().willMessage().getBytes(StandardCharsets.UTF_8);\n-            ByteBuffer bb = (ByteBuffer) ByteBuffer.allocate(willPayload.length).put(willPayload).flip();\n-            // save the will testament in the clientID store\n-            WillMessage will = new WillMessage(msg.payload().willTopic(), bb, msg.variableHeader().isWillRetain(), willQos);\n-            willMessages.put(clientId, will);\n-            LOG.debug(\"MQTT last will and testament has been configured. CId={}\", clientId);\n-        }\n-    }\n-\n-    @Override\n-    public void removeWill() {\n-        willMessages.remove(clientID);\n-    }\n-\n-    @Override\n-    public WillMessage willMessage() {\n-        return willMessages.get(clientID);\n-    }\n+  class OutboundFlightZone {\n+\n+    /**\n+     * Save the binding messageID, clientID - message\n+     *\n+     * @param messageID the packet ID used in transmission\n+     * @param msg       the message to put in flight zone\n+     */\n+    void waitingAck(int messageID, IMessagesStore.StoredMessage msg) {\n+      if (LOG.isTraceEnabled()) {\n+        LOG.trace(\"Adding to inflight {}, guid <{}>\", messageID, msg.getGuid());\n+      }\n+      sessionsStore.inFlight(clientID, messageID, msg);\n+    }\n+\n+    IMessagesStore.StoredMessage acknowledged(int messageID) {\n+      if (LOG.isTraceEnabled()) {\n+        LOG.trace(\"Acknowledging inflight, clientID <{}> messageID {}\", clientID, messageID);\n+      }\n+      return sessionsStore.inFlightAck(clientID, messageID);\n+    }\n+  }\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DurableSession.class);\n+\n+  private final ISessionsStore sessionsStore;\n+  private final ISubscriptionsStore subscriptionsStore;\n+\n+  private final OutboundFlightZone outboundFlightZone;\n+  private final InboundFlightZone inboundFlightZone;\n+  private final ConcurrentMap<String, WillMessage> willMessages;\n+\n+  public DurableSession(String clientID, ISessionsStore sessions, ISubscriptionsStore subscriptionsStore,\n+                        ConcurrentMap<String, WillMessage> willMessages) {\n+    super(clientID);\n+    this.subscriptionsStore = subscriptionsStore;\n+    this.sessionsStore = sessions;\n+    this.willMessages = willMessages;\n+    this.outboundFlightZone = new OutboundFlightZone();\n+    this.inboundFlightZone = new InboundFlightZone();\n+  }\n+\n+  public void reloadAllSubscriptionsFromStore() {\n+    Collection<Subscription> reloadedSubscriptions = this.subscriptionsStore.listClientSubscriptions(this.clientID);\n+    this.subscriptions.addAll(reloadedSubscriptions);\n+  }\n+\n+  @Override\n+  public boolean isCleanSession() {\n+    return false;\n+  }\n+\n+  @Override\n+  public boolean subscribe(Subscription newSubscription) {\n+    LOG.info(\"Adding new subscription. CId={}, topics={}, qos={}\", newSubscription.getClientId(),\n+        newSubscription.getTopicFilter(), newSubscription.getRequestedQos());\n+    boolean validTopic = newSubscription.getTopicFilter().isValid();\n+    if (!validTopic) {\n+      LOG.warn(\"The topic filter is not valid. CId={}, topics={}\", newSubscription.getClientId(),\n+          newSubscription.getTopicFilter());\n+      // send SUBACK with 0x80 for this topic filter\n+      return false;\n+    }\n+    Subscription existingSub = subscriptionsStore.reload(newSubscription);\n+    // update the selected subscriptions if not present or if has a greater qos\n+    if (existingSub == null || existingSub.qosLessThan(newSubscription)) {\n+      if (existingSub != null) {\n+        LOG.info(\"Subscription already existed with a lower QoS value. It will be updated. CId={}, \" +\n+                \"topics={}, existingQos={}, newQos={}\", newSubscription.getClientId(),\n+            newSubscription.getTopicFilter(), existingSub.getRequestedQos(), newSubscription.getRequestedQos());\n+        subscriptions.remove(newSubscription);\n+      }\n+      subscriptions.add(newSubscription);\n+      subscriptionsStore.addNewSubscription(newSubscription);\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public void unsubscribeFrom(Topic topicFilter) {\n+    LOG.info(\"Removing subscription. CId={}, topics={}\", clientID, topicFilter);\n+    subscriptionsStore.removeSubscription(topicFilter, clientID);\n+    Set<Subscription> subscriptionsToRemove = new HashSet<>();\n+    for (Subscription sub : this.subscriptions) {\n+      if (sub.getTopicFilter().equals(topicFilter)) {\n+        subscriptionsToRemove.add(sub);\n+      }\n+    }\n+    subscriptions.removeAll(subscriptionsToRemove);\n+  }\n+\n+  @Override\n+  public void cleanSession() {\n+    sessionsStore.removeTemporaryQoS2(this.clientID);\n+    LOG.info(\"Wiping existing subscriptions. ClientId={}\", clientID);\n+    subscriptionsStore.wipeSubscriptions(clientID);\n+\n+    LOG.info(\"Removing queues. ClientId={}\", clientID);\n+    sessionsStore.dropQueue(clientID);\n+  }\n+\n+  @Override\n+  public void disconnect() {\n+    LOG.info(\"Client disconnected. Removing its subscriptions. CId={}\", clientID);\n+    // cleanup topic subscriptions\n+    cleanSession();\n+  }\n+\n+  @Override\n+  protected int nextPacketId() {\n+    return this.sessionsStore.nextPacketID(this.clientID);\n+  }\n+\n+  @Override\n+  public IMessagesStore.StoredMessage inFlightAcknowledged(int messageID) {\n+    return outboundFlightZone.acknowledged(messageID);\n+  }\n+\n+  @Override\n+  public int inFlightAckWaiting(IMessagesStore.StoredMessage msg) {\n+    LOG.debug(\"Adding message to inflight zone. CId={}\", clientID);\n+    int messageId = this.nextPacketId();\n+    outboundFlightZone.waitingAck(messageId, msg);\n+    return messageId;\n+  }\n+\n+  @Override\n+  public IMessagesStore.StoredMessage inboundInflight(int messageID) {\n+    return inboundFlightZone.lookup(messageID);\n+  }\n+\n+  @Override\n+  public void markAsInboundInflight(int messageID, IMessagesStore.StoredMessage msg) {\n+    inboundFlightZone.waitingRel(messageID, msg);\n+  }\n+\n+  @Override\n+  public void moveInFlightToSecondPhaseAckWaiting(int messageID, IMessagesStore.StoredMessage msg) {\n+    this.sessionsStore.moveInFlightToSecondPhaseAckWaiting(this.clientID, messageID, msg);\n+  }\n+\n+  @Override\n+  public boolean isEmptyQueue() {\n+    return this.sessionsStore.queue(clientID).isEmpty();\n+  }\n+\n+  @Override\n+  public void dropQueue() {\n+    LOG.debug(\"Removing messages of session. CId={}\", this.clientID);\n+    this.sessionsStore.dropQueue(this.clientID);\n+    LOG.debug(\"Messages of the session have been removed. CId={}\", this.clientID);\n+  }\n+\n+  @Override\n+  public EnqueuedMessage poll() {\n+    IMessagesStore.StoredMessage msg = this.sessionsStore.queue(clientID).poll();\n+    if (msg == null) {\n+      return null;\n+    }\n+    int messageId = this.inFlightAckWaiting(msg);\n+    return new EnqueuedMessage(msg, messageId);\n+  }\n+\n+  @Override\n+  public void enqueue(IMessagesStore.StoredMessage message) {\n+    this.sessionsStore.queue(this.clientID).add(message);\n+  }\n+\n+  @Override\n+  public IMessagesStore.StoredMessage completeReleasedPublish(int messageID) {\n+    return this.sessionsStore.completeReleasedPublish(clientID, messageID);\n+  }\n+\n+  @Override\n+  public int getPendingPublishMessagesNo() {\n+    return this.sessionsStore.queue(clientID).size();\n+  }\n+\n+  @Override\n+  public int countPubReleaseWaitingPubComplete() {\n+    return this.sessionsStore.countPubReleaseWaitingPubComplete(clientID);\n+  }\n+\n+  @Override\n+  public int getInflightMessagesNo() {\n+    return this.sessionsStore.getInflightMessagesNo(clientID);\n+  }\n+\n+  @Override\n+  public void wipeSubscriptions() {\n+    this.subscriptionsStore.wipeSubscriptions(clientID);\n+  }\n+\n+  @Override\n+  public void storeWillMessage(MqttConnectMessage msg, String clientId) {\n+    // Handle will flag\n+    if (msg.variableHeader().isWillFlag()) {\n+      MqttQoS willQos = MqttQoS.valueOf(msg.variableHeader().willQos());\n+      LOG.debug(\"Configuring MQTT last will and testament CId={}, willQos={}, willTopic={}, willRetain={}\",\n+          clientId, willQos, msg.payload().willTopic(), msg.variableHeader().isWillRetain());\n+      byte[] willPayload = msg.payload().willMessage().getBytes(StandardCharsets.UTF_8);\n+      ByteBuffer bb = (ByteBuffer) ByteBuffer.allocate(willPayload.length).put(willPayload).flip();\n+      // save the will testament in the clientID store\n+      WillMessage will = new WillMessage(msg.payload().willTopic(), bb, msg.variableHeader().isWillRetain(), willQos);\n+      willMessages.put(clientId, will);\n+      LOG.debug(\"MQTT last will and testament has been configured. CId={}\", clientId);\n+    }\n+  }\n+\n+  @Override\n+  public void removeWill() {\n+    willMessages.remove(clientID);\n+  }\n+\n+  @Override\n+  public WillMessage willMessage() {\n+    return willMessages.get(clientID);\n+  }\n }\n",
            "diff_size": 219
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "67",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 158).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "237",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 124).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/errored/1/3/DurableSession.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/naturalize/3/DurableSession.java\nindex 467c48773de..898641bbbb6 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/errored/1/3/DurableSession.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/naturalize/3/DurableSession.java\n@@ -64,9 +64,8 @@ public class DurableSession extends ClientSession {\n     private final InboundFlightZone inboundFlightZone;\n     private final ConcurrentMap<String, WillMessage> willMessages;\n \n-    public DurableSession(String clientID, ISessionsStore sessions, ISubscriptionsStore subscriptionsStore,\n-                          ConcurrentMap<String, WillMessage> willMessages) {\n-        super(clientID);\n+    public DurableSession(String clientID, ISessionsStore sessions, ISubscriptionsStore subscriptionsStore, ConcurrentMap<String, WillMessage> willMessages) {\n+    super(clientID);\n         this.subscriptionsStore = subscriptionsStore;\n         this.sessionsStore = sessions;\n         this.willMessages = willMessages;\n@@ -232,7 +231,7 @@ public class DurableSession extends ClientSession {\n             MqttQoS willQos = MqttQoS.valueOf(msg.variableHeader().willQos());\n             LOG.debug(\"Configuring MQTT last will and testament CId={}, willQos={}, willTopic={}, willRetain={}\",\n                 clientId, willQos, msg.payload().willTopic(), msg.variableHeader().isWillRetain());\n-            byte[] willPayload = msg.payload().willMessage().getBytes(StandardCharsets.UTF_8);\n+byte[] willPayload = msg.payload().willMessage().getBytes(StandardCharsets.UTF_8);\n             ByteBuffer bb = (ByteBuffer) ByteBuffer.allocate(willPayload.length).put(willPayload).flip();\n             // save the will testament in the clientID store\n             WillMessage will = new WillMessage(msg.payload().willTopic(), bb, msg.variableHeader().isWillRetain(), willQos);\n@@ -250,4 +249,4 @@ public class DurableSession extends ClientSession {\n     public WillMessage willMessage() {\n         return willMessages.get(clientID);\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 5
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "66",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 158).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "87",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 171).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "101",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 282).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "232",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 197).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "238",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 124).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/errored/1/3/DurableSession.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/codebuff/3/DurableSession.java\nindex 467c48773de..2fb2d686521 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/errored/1/3/DurableSession.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/codebuff/3/DurableSession.java\n@@ -22,7 +22,6 @@ import io.netty.handler.codec.mqtt.MqttConnectMessage;\n import io.netty.handler.codec.mqtt.MqttQoS;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-\n import java.nio.ByteBuffer;\n import java.nio.charset.StandardCharsets;\n import java.util.Collection;\n@@ -30,6 +29,7 @@ import java.util.HashSet;\n import java.util.Set;\n import java.util.concurrent.ConcurrentMap;\n \n+\n public class DurableSession extends ClientSession {\n \n     class OutboundFlightZone {\n@@ -40,6 +40,7 @@ public class DurableSession extends ClientSession {\n          * @param messageID the packet ID used in transmission\n          * @param msg the message to put in flight zone\n          */\n+\n         void waitingAck(int messageID, IMessagesStore.StoredMessage msg) {\n             if (LOG.isTraceEnabled()) {\n                 LOG.trace(\"Adding to inflight {}, guid <{}>\", messageID, msg.getGuid());\n@@ -56,16 +57,13 @@ public class DurableSession extends ClientSession {\n     }\n \n     private static final Logger LOG = LoggerFactory.getLogger(DurableSession.class);\n-\n     private final ISessionsStore sessionsStore;\n     private final ISubscriptionsStore subscriptionsStore;\n-\n     private final OutboundFlightZone outboundFlightZone;\n     private final InboundFlightZone inboundFlightZone;\n     private final ConcurrentMap<String, WillMessage> willMessages;\n \n-    public DurableSession(String clientID, ISessionsStore sessions, ISubscriptionsStore subscriptionsStore,\n-                          ConcurrentMap<String, WillMessage> willMessages) {\n+    public DurableSession(String clientID, ISessionsStore sessions, ISubscriptionsStore subscriptionsStore, ConcurrentMap<String, WillMessage> willMessages) {\n         super(clientID);\n         this.subscriptionsStore = subscriptionsStore;\n         this.sessionsStore = sessions;\n@@ -86,22 +84,21 @@ public class DurableSession extends ClientSession {\n \n     @Override\n     public boolean subscribe(Subscription newSubscription) {\n-        LOG.info(\"Adding new subscription. CId={}, topics={}, qos={}\", newSubscription.getClientId(),\n-            newSubscription.getTopicFilter(), newSubscription.getRequestedQos());\n+        LOG.info(\"Adding new subscription. CId={}, topics={}, qos={}\", newSubscription.getClientId(), newSubscription.getTopicFilter(), newSubscription.getRequestedQos());\n         boolean validTopic = newSubscription.getTopicFilter().isValid();\n         if (!validTopic) {\n-            LOG.warn(\"The topic filter is not valid. CId={}, topics={}\", newSubscription.getClientId(),\n+            LOG.warn(\"The topic filter is not valid. CId={}, topics={}\",\n+                newSubscription.getClientId(),\n                 newSubscription.getTopicFilter());\n             // send SUBACK with 0x80 for this topic filter\n             return false;\n         }\n+\n         Subscription existingSub = subscriptionsStore.reload(newSubscription);\n         // update the selected subscriptions if not present or if has a greater qos\n         if (existingSub == null || existingSub.qosLessThan(newSubscription)) {\n             if (existingSub != null) {\n-                LOG.info(\"Subscription already existed with a lower QoS value. It will be updated. CId={}, \" +\n-                        \"topics={}, existingQos={}, newQos={}\", newSubscription.getClientId(),\n-                    newSubscription.getTopicFilter(), existingSub.getRequestedQos(), newSubscription.getRequestedQos());\n+                LOG.info(\"Subscription already existed with a lower QoS value. It will be updated. CId={}, \" + \"topics={}, existingQos={}, newQos={}\", newSubscription.getClientId(), newSubscription.getTopicFilter(), existingSub.getRequestedQos(), newSubscription.getRequestedQos());\n                 subscriptions.remove(newSubscription);\n             }\n             subscriptions.add(newSubscription);\n@@ -128,7 +125,6 @@ public class DurableSession extends ClientSession {\n         sessionsStore.removeTemporaryQoS2(this.clientID);\n         LOG.info(\"Wiping existing subscriptions. ClientId={}\", clientID);\n         subscriptionsStore.wipeSubscriptions(clientID);\n-\n         LOG.info(\"Removing queues. ClientId={}\", clientID);\n         sessionsStore.dropQueue(clientID);\n     }\n@@ -175,7 +171,8 @@ public class DurableSession extends ClientSession {\n \n     @Override\n     public boolean isEmptyQueue() {\n-        return this.sessionsStore.queue(clientID).isEmpty();\n+        return this.sessionsStore.queue(clientID)\n+.isEmpty();\n     }\n \n     @Override\n@@ -187,7 +184,8 @@ public class DurableSession extends ClientSession {\n \n     @Override\n     public EnqueuedMessage poll() {\n-        IMessagesStore.StoredMessage msg = this.sessionsStore.queue(clientID).poll();\n+        IMessagesStore.StoredMessage msg = this.sessionsStore.queue(clientID)\n+.poll();\n         if (msg == null) {\n             return null;\n         }\n@@ -207,7 +205,8 @@ public class DurableSession extends ClientSession {\n \n     @Override\n     public int getPendingPublishMessagesNo() {\n-        return this.sessionsStore.queue(clientID).size();\n+        return this.sessionsStore.queue(clientID)\n+.size();\n     }\n \n     @Override\n@@ -230,10 +229,11 @@ public class DurableSession extends ClientSession {\n         // Handle will flag\n         if (msg.variableHeader().isWillFlag()) {\n             MqttQoS willQos = MqttQoS.valueOf(msg.variableHeader().willQos());\n-            LOG.debug(\"Configuring MQTT last will and testament CId={}, willQos={}, willTopic={}, willRetain={}\",\n-                clientId, willQos, msg.payload().willTopic(), msg.variableHeader().isWillRetain());\n-            byte[] willPayload = msg.payload().willMessage().getBytes(StandardCharsets.UTF_8);\n-            ByteBuffer bb = (ByteBuffer) ByteBuffer.allocate(willPayload.length).put(willPayload).flip();\n+            LOG.debug(\"Configuring MQTT last will and testament CId={}, willQos={}, willTopic={}, willRetain={}\", clientId, willQos, msg.payload().willTopic(), msg.variableHeader().isWillRetain());\n+            byte[] willPayload = msg.payload().willMessage()\n+.getBytes(StandardCharsets.UTF_8);\n+            ByteBuffer bb = (ByteBuffer) ByteBuffer.allocate(willPayload.length).put(willPayload)\n+.flip();\n             // save the will testament in the clientID store\n             WillMessage will = new WillMessage(msg.payload().willTopic(), bb, msg.variableHeader().isWillRetain(), willQos);\n             willMessages.put(clientId, will);\n@@ -250,4 +250,4 @@ public class DurableSession extends ClientSession {\n     public WillMessage willMessage() {\n         return willMessages.get(clientID);\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 28
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "238",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 124).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": null,
            "diff": null
        }
    ],
    "repaired_by": [
        "intellij"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}