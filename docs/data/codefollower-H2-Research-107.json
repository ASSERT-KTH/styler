{
    "project_name": "codefollower-H2-Research",
    "error_id": "107",
    "information": {
        "errors": [
            {
                "line": "163",
                "column": "72",
                "severity": "warning",
                "message": "Don't use trailing comments.",
                "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
            }
        ]
    },
    "source_code": "                        newModified = true;\n                    } else if (dependentTable.getSchema() != this) {\n                        throw DbException.get(ErrorCode.CANNOT_DROP_2, //\n                                obj.getSQL(false), dependentTable.getSQL(false));\n                    } else if (!modified) {\n                        dependentTable.removeColumnExpressionsDependencies(session);",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/107/Schema.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler/107/Schema.java\nindex 4ba3d83e74d..cc95826bd5f 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/107/Schema.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler/107/Schema.java\n@@ -160,8 +160,9 @@ public class Schema extends DbObjectBase {\n                         database.removeSchemaObject(session, obj);\n                         newModified = true;\n                     } else if (dependentTable.getSchema() != this) {\n-                        throw DbException.get(ErrorCode.CANNOT_DROP_2, //\n-                                obj.getSQL(false), dependentTable.getSQL(false));\n+                        throw DbException.get(ErrorCode.CANNOT_DROP_2,\n+                            //\n+                                 obj.getSQL(false), dependentTable.getSQL(false));\n                     } else if (!modified) {\n                         dependentTable.removeColumnExpressionsDependencies(session);\n                         dependentTable.setModified();\n",
            "diff_size": 3
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "164",
                    "column": "60",
                    "severity": "warning",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/107/Schema.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/107/Schema.java\nindex 4ba3d83e74d..c01508ba326 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/107/Schema.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/107/Schema.java\n@@ -3,6 +3,7 @@\n  * and the EPL 1.0 (https://h2database.com/html/license.html).\n  * Initial Developer: H2 Group\n  */\n+\n package org.h2.schema;\n \n import java.util.ArrayList;\n@@ -42,736 +43,734 @@ import org.h2.util.Utils;\n  */\n public class Schema extends DbObjectBase {\n \n-    private User owner;\n-    private final boolean system;\n-    private ArrayList<String> tableEngineParams;\n-\n-    private final ConcurrentHashMap<String, Table> tablesAndViews;\n-    private final ConcurrentHashMap<String, Domain> domains;\n-    private final ConcurrentHashMap<String, TableSynonym> synonyms;\n-    private final ConcurrentHashMap<String, Index> indexes;\n-    private final ConcurrentHashMap<String, Sequence> sequences;\n-    private final ConcurrentHashMap<String, TriggerObject> triggers;\n-    private final ConcurrentHashMap<String, Constraint> constraints;\n-    private final ConcurrentHashMap<String, Constant> constants;\n-    private final ConcurrentHashMap<String, FunctionAlias> functions;\n-\n-    /**\n-     * The set of returned unique names that are not yet stored. It is used to\n-     * avoid returning the same unique name twice when multiple threads\n-     * concurrently create objects.\n-     */\n-    private final HashSet<String> temporaryUniqueNames = new HashSet<>();\n-\n-    /**\n-     * Create a new schema object.\n-     *\n-     * @param database the database\n-     * @param id the object id\n-     * @param schemaName the schema name\n-     * @param owner the owner of the schema\n-     * @param system if this is a system schema (such a schema can not be\n-     *            dropped)\n-     */\n-    public Schema(Database database, int id, String schemaName, User owner,\n-            boolean system) {\n-        super(database, id, schemaName, Trace.SCHEMA);\n-        tablesAndViews = database.newConcurrentStringMap();\n-        domains = database.newConcurrentStringMap();\n-        synonyms = database.newConcurrentStringMap();\n-        indexes = database.newConcurrentStringMap();\n-        sequences = database.newConcurrentStringMap();\n-        triggers = database.newConcurrentStringMap();\n-        constraints = database.newConcurrentStringMap();\n-        constants = database.newConcurrentStringMap();\n-        functions = database.newConcurrentStringMap();\n-        this.owner = owner;\n-        this.system = system;\n-    }\n-\n-    /**\n-     * Check if this schema can be dropped. System schemas can not be dropped.\n-     *\n-     * @return true if it can be dropped\n-     */\n-    public boolean canDrop() {\n-        return !system;\n-    }\n-\n-    @Override\n-    public String getCreateSQLForCopy(Table table, String quotedName) {\n-        throw DbException.throwInternalError(toString());\n-    }\n-\n-    @Override\n-    public String getCreateSQL() {\n-        if (system) {\n-            return null;\n-        }\n-        StringBuilder builder = new StringBuilder(\"CREATE SCHEMA IF NOT EXISTS \");\n-        getSQL(builder, true).append(\" AUTHORIZATION \");\n-        owner.getSQL(builder, true);\n-        return builder.toString();\n-    }\n-\n-    @Override\n-    public int getType() {\n-        return DbObject.SCHEMA;\n-    }\n-\n-    /**\n-     * Return whether is this schema is empty (does not contain any objects).\n-     *\n-     * @return {@code true} if this schema is empty, {@code false} otherwise\n-     */\n-    public boolean isEmpty() {\n-        return tablesAndViews.isEmpty() && domains.isEmpty() && synonyms.isEmpty() && indexes.isEmpty()\n-                && sequences.isEmpty() && triggers.isEmpty() && constraints.isEmpty() && constants.isEmpty()\n-                && functions.isEmpty();\n-    }\n-\n-    @Override\n-    public ArrayList<DbObject> getChildren() {\n-        ArrayList<DbObject> children = Utils.newSmallArrayList();\n-        ArrayList<Right> rights = database.getAllRights();\n-        for (Right right : rights) {\n-            if (right.getGrantedObject() == this) {\n-                children.add(right);\n-            }\n+  private User owner;\n+  private final boolean system;\n+  private ArrayList<String> tableEngineParams;\n+\n+  private final ConcurrentHashMap<String, Table> tablesAndViews;\n+  private final ConcurrentHashMap<String, Domain> domains;\n+  private final ConcurrentHashMap<String, TableSynonym> synonyms;\n+  private final ConcurrentHashMap<String, Index> indexes;\n+  private final ConcurrentHashMap<String, Sequence> sequences;\n+  private final ConcurrentHashMap<String, TriggerObject> triggers;\n+  private final ConcurrentHashMap<String, Constraint> constraints;\n+  private final ConcurrentHashMap<String, Constant> constants;\n+  private final ConcurrentHashMap<String, FunctionAlias> functions;\n+\n+  /**\n+   * The set of returned unique names that are not yet stored. It is used to\n+   * avoid returning the same unique name twice when multiple threads\n+   * concurrently create objects.\n+   */\n+  private final HashSet<String> temporaryUniqueNames = new HashSet<>();\n+\n+  /**\n+   * Create a new schema object.\n+   *\n+   * @param database   the database\n+   * @param id         the object id\n+   * @param schemaName the schema name\n+   * @param owner      the owner of the schema\n+   * @param system     if this is a system schema (such a schema can not be\n+   *                   dropped)\n+   */\n+  public Schema(Database database, int id, String schemaName, User owner,\n+                boolean system) {\n+    super(database, id, schemaName, Trace.SCHEMA);\n+    tablesAndViews = database.newConcurrentStringMap();\n+    domains = database.newConcurrentStringMap();\n+    synonyms = database.newConcurrentStringMap();\n+    indexes = database.newConcurrentStringMap();\n+    sequences = database.newConcurrentStringMap();\n+    triggers = database.newConcurrentStringMap();\n+    constraints = database.newConcurrentStringMap();\n+    constants = database.newConcurrentStringMap();\n+    functions = database.newConcurrentStringMap();\n+    this.owner = owner;\n+    this.system = system;\n+  }\n+\n+  /**\n+   * Check if this schema can be dropped. System schemas can not be dropped.\n+   *\n+   * @return true if it can be dropped\n+   */\n+  public boolean canDrop() {\n+    return !system;\n+  }\n+\n+  @Override\n+  public String getCreateSQLForCopy(Table table, String quotedName) {\n+    throw DbException.throwInternalError(toString());\n+  }\n+\n+  @Override\n+  public String getCreateSQL() {\n+    if (system) {\n+      return null;\n+    }\n+    StringBuilder builder = new StringBuilder(\"CREATE SCHEMA IF NOT EXISTS \");\n+    getSQL(builder, true).append(\" AUTHORIZATION \");\n+    owner.getSQL(builder, true);\n+    return builder.toString();\n+  }\n+\n+  @Override\n+  public int getType() {\n+    return DbObject.SCHEMA;\n+  }\n+\n+  /**\n+   * Return whether is this schema is empty (does not contain any objects).\n+   *\n+   * @return {@code true} if this schema is empty, {@code false} otherwise\n+   */\n+  public boolean isEmpty() {\n+    return tablesAndViews.isEmpty() && domains.isEmpty() && synonyms.isEmpty() && indexes.isEmpty()\n+        && sequences.isEmpty() && triggers.isEmpty() && constraints.isEmpty() && constants.isEmpty()\n+        && functions.isEmpty();\n+  }\n+\n+  @Override\n+  public ArrayList<DbObject> getChildren() {\n+    ArrayList<DbObject> children = Utils.newSmallArrayList();\n+    ArrayList<Right> rights = database.getAllRights();\n+    for (Right right : rights) {\n+      if (right.getGrantedObject() == this) {\n+        children.add(right);\n+      }\n+    }\n+    return children;\n+  }\n+\n+  @Override\n+  public void removeChildrenAndResources(Session session) {\n+    removeChildrenFromMap(session, triggers);\n+    removeChildrenFromMap(session, constraints);\n+    // There can be dependencies between tables e.g. using computed columns,\n+    // so we might need to loop over them multiple times.\n+    boolean modified = true;\n+    while (!tablesAndViews.isEmpty()) {\n+      boolean newModified = false;\n+      for (Table obj : tablesAndViews.values()) {\n+        if (obj.getName() != null) {\n+          // Database.removeSchemaObject() removes the object from\n+          // the map too, but it is safe for ConcurrentHashMap.\n+          Table dependentTable = database.getDependentTable(obj, obj);\n+          if (dependentTable == null) {\n+            database.removeSchemaObject(session, obj);\n+            newModified = true;\n+          } else if (dependentTable.getSchema() != this) {\n+            throw DbException.get(ErrorCode.CANNOT_DROP_2, //\n+                obj.getSQL(false), dependentTable.getSQL(false));\n+          } else if (!modified) {\n+            dependentTable.removeColumnExpressionsDependencies(session);\n+            dependentTable.setModified();\n+            database.updateMeta(session, dependentTable);\n+          }\n         }\n-        return children;\n-    }\n-\n-    @Override\n-    public void removeChildrenAndResources(Session session) {\n-        removeChildrenFromMap(session, triggers);\n-        removeChildrenFromMap(session, constraints);\n-        // There can be dependencies between tables e.g. using computed columns,\n-        // so we might need to loop over them multiple times.\n-        boolean modified = true;\n-        while (!tablesAndViews.isEmpty()) {\n-            boolean newModified = false;\n-            for (Table obj : tablesAndViews.values()) {\n-                if (obj.getName() != null) {\n-                    // Database.removeSchemaObject() removes the object from\n-                    // the map too, but it is safe for ConcurrentHashMap.\n-                    Table dependentTable = database.getDependentTable(obj, obj);\n-                    if (dependentTable == null) {\n-                        database.removeSchemaObject(session, obj);\n-                        newModified = true;\n-                    } else if (dependentTable.getSchema() != this) {\n-                        throw DbException.get(ErrorCode.CANNOT_DROP_2, //\n-                                obj.getSQL(false), dependentTable.getSQL(false));\n-                    } else if (!modified) {\n-                        dependentTable.removeColumnExpressionsDependencies(session);\n-                        dependentTable.setModified();\n-                        database.updateMeta(session, dependentTable);\n-                    }\n-                }\n-            }\n-            modified = newModified;\n+      }\n+      modified = newModified;\n+    }\n+    removeChildrenFromMap(session, domains);\n+    removeChildrenFromMap(session, indexes);\n+    removeChildrenFromMap(session, sequences);\n+    removeChildrenFromMap(session, constants);\n+    removeChildrenFromMap(session, functions);\n+    for (Right right : database.getAllRights()) {\n+      if (right.getGrantedObject() == this) {\n+        database.removeDatabaseObject(session, right);\n+      }\n+    }\n+    database.removeMeta(session, getId());\n+    owner = null;\n+    invalidate();\n+  }\n+\n+  private void removeChildrenFromMap(Session session, ConcurrentHashMap<String, ? extends SchemaObject> map) {\n+    if (!map.isEmpty()) {\n+      for (SchemaObject obj : map.values()) {\n+        // Database.removeSchemaObject() removes the object from\n+        // the map too, but it is safe for ConcurrentHashMap.\n+        database.removeSchemaObject(session, obj);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Get the owner of this schema.\n+   *\n+   * @return the owner\n+   */\n+  public User getOwner() {\n+    return owner;\n+  }\n+\n+  /**\n+   * Get table engine params of this schema.\n+   *\n+   * @return default table engine params\n+   */\n+  public ArrayList<String> getTableEngineParams() {\n+    return tableEngineParams;\n+  }\n+\n+  /**\n+   * Set table engine params of this schema.\n+   *\n+   * @param tableEngineParams default table engine params\n+   */\n+  public void setTableEngineParams(ArrayList<String> tableEngineParams) {\n+    this.tableEngineParams = tableEngineParams;\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private Map<String, SchemaObject> getMap(int type) {\n+    Map<String, ? extends SchemaObject> result;\n+    switch (type) {\n+      case DbObject.TABLE_OR_VIEW:\n+        result = tablesAndViews;\n+        break;\n+      case DbObject.DOMAIN:\n+        result = domains;\n+        break;\n+      case DbObject.SYNONYM:\n+        result = synonyms;\n+        break;\n+      case DbObject.SEQUENCE:\n+        result = sequences;\n+        break;\n+      case DbObject.INDEX:\n+        result = indexes;\n+        break;\n+      case DbObject.TRIGGER:\n+        result = triggers;\n+        break;\n+      case DbObject.CONSTRAINT:\n+        result = constraints;\n+        break;\n+      case DbObject.CONSTANT:\n+        result = constants;\n+        break;\n+      case DbObject.FUNCTION_ALIAS:\n+        result = functions;\n+        break;\n+      default:\n+        throw DbException.throwInternalError(\"type=\" + type);\n+    }\n+    return (Map<String, SchemaObject>) result;\n+  }\n+\n+  /**\n+   * Add an object to this schema.\n+   * This method must not be called within CreateSchemaObject;\n+   * use Database.addSchemaObject() instead\n+   *\n+   * @param obj the object to add\n+   */\n+  public void add(SchemaObject obj) {\n+    if (obj.getSchema() != this) {\n+      DbException.throwInternalError(\"wrong schema\");\n+    }\n+    String name = obj.getName();\n+    Map<String, SchemaObject> map = getMap(obj.getType());\n+    if (SysProperties.CHECK && map.get(name) != null) {\n+      DbException.throwInternalError(\"object already exists: \" + name);\n+    }\n+    map.put(name, obj);\n+    freeUniqueName(name);\n+  }\n+\n+  /**\n+   * Rename an object.\n+   *\n+   * @param obj     the object to rename\n+   * @param newName the new name\n+   */\n+  public void rename(SchemaObject obj, String newName) {\n+    int type = obj.getType();\n+    Map<String, SchemaObject> map = getMap(type);\n+    if (SysProperties.CHECK) {\n+      if (!map.containsKey(obj.getName())) {\n+        DbException.throwInternalError(\"not found: \" + obj.getName());\n+      }\n+      if (obj.getName().equals(newName) || map.containsKey(newName)) {\n+        DbException.throwInternalError(\"object already exists: \" + newName);\n+      }\n+    }\n+    obj.checkRename();\n+    map.remove(obj.getName());\n+    freeUniqueName(obj.getName());\n+    obj.rename(newName);\n+    map.put(newName, obj);\n+    freeUniqueName(newName);\n+  }\n+\n+  /**\n+   * Try to find a table or view with this name. This method returns null if\n+   * no object with this name exists. Local temporary tables are also\n+   * returned. Synonyms are not returned or resolved.\n+   *\n+   * @param session the session\n+   * @param name    the object name\n+   * @return the object or null\n+   */\n+  public Table findTableOrView(Session session, String name) {\n+    Table table = tablesAndViews.get(name);\n+    if (table == null && session != null) {\n+      table = session.findLocalTempTable(name);\n+    }\n+    return table;\n+  }\n+\n+  /**\n+   * Try to find a table or view with this name. This method returns null if\n+   * no object with this name exists. Local temporary tables are also\n+   * returned. If a synonym with this name exists, the backing table of the\n+   * synonym is returned\n+   *\n+   * @param session the session\n+   * @param name    the object name\n+   * @return the object or null\n+   */\n+  public Table resolveTableOrView(Session session, String name) {\n+    Table table = findTableOrView(session, name);\n+    if (table == null) {\n+      TableSynonym synonym = synonyms.get(name);\n+      if (synonym != null) {\n+        return synonym.getSynonymFor();\n+      }\n+    }\n+    return table;\n+  }\n+\n+  /**\n+   * Try to find a synonym with this name. This method returns null if\n+   * no object with this name exists.\n+   *\n+   * @param name the object name\n+   * @return the object or null\n+   */\n+  public TableSynonym getSynonym(String name) {\n+    return synonyms.get(name);\n+  }\n+\n+  /**\n+   * Get the domain if it exists, or null if not.\n+   *\n+   * @param name the name of the domain\n+   * @return the domain or null\n+   */\n+  public Domain findDomain(String name) {\n+    return domains.get(name);\n+  }\n+\n+  /**\n+   * Try to find an index with this name. This method returns null if\n+   * no object with this name exists.\n+   *\n+   * @param session the session\n+   * @param name    the object name\n+   * @return the object or null\n+   */\n+  public Index findIndex(Session session, String name) {\n+    Index index = indexes.get(name);\n+    if (index == null) {\n+      index = session.findLocalTempTableIndex(name);\n+    }\n+    return index;\n+  }\n+\n+  /**\n+   * Try to find a trigger with this name. This method returns null if\n+   * no object with this name exists.\n+   *\n+   * @param name the object name\n+   * @return the object or null\n+   */\n+  public TriggerObject findTrigger(String name) {\n+    return triggers.get(name);\n+  }\n+\n+  /**\n+   * Try to find a sequence with this name. This method returns null if\n+   * no object with this name exists.\n+   *\n+   * @param sequenceName the object name\n+   * @return the object or null\n+   */\n+  public Sequence findSequence(String sequenceName) {\n+    return sequences.get(sequenceName);\n+  }\n+\n+  /**\n+   * Try to find a constraint with this name. This method returns null if no\n+   * object with this name exists.\n+   *\n+   * @param session the session\n+   * @param name    the object name\n+   * @return the object or null\n+   */\n+  public Constraint findConstraint(Session session, String name) {\n+    Constraint constraint = constraints.get(name);\n+    if (constraint == null) {\n+      constraint = session.findLocalTempTableConstraint(name);\n+    }\n+    return constraint;\n+  }\n+\n+  /**\n+   * Try to find a user defined constant with this name. This method returns\n+   * null if no object with this name exists.\n+   *\n+   * @param constantName the object name\n+   * @return the object or null\n+   */\n+  public Constant findConstant(String constantName) {\n+    return constants.get(constantName);\n+  }\n+\n+  /**\n+   * Try to find a user defined function with this name. This method returns\n+   * null if no object with this name exists.\n+   *\n+   * @param functionAlias the object name\n+   * @return the object or null\n+   */\n+  public FunctionAlias findFunction(String functionAlias) {\n+    return functions.get(functionAlias);\n+  }\n+\n+  /**\n+   * Release a unique object name.\n+   *\n+   * @param name the object name\n+   */\n+  public void freeUniqueName(String name) {\n+    if (name != null) {\n+      synchronized (temporaryUniqueNames) {\n+        temporaryUniqueNames.remove(name);\n+      }\n+    }\n+  }\n+\n+  private String getUniqueName(DbObject obj,\n+                               Map<String, ? extends SchemaObject> map, String prefix) {\n+    String hash = StringUtils.toUpperEnglish(Integer.toHexString(obj.getName().hashCode()));\n+    String name = null;\n+    synchronized (temporaryUniqueNames) {\n+      for (int i = 1, len = hash.length(); i < len; i++) {\n+        name = prefix + hash.substring(0, i);\n+        if (!map.containsKey(name) && !temporaryUniqueNames.contains(name)) {\n+          break;\n         }\n-        removeChildrenFromMap(session, domains);\n-        removeChildrenFromMap(session, indexes);\n-        removeChildrenFromMap(session, sequences);\n-        removeChildrenFromMap(session, constants);\n-        removeChildrenFromMap(session, functions);\n-        for (Right right : database.getAllRights()) {\n-            if (right.getGrantedObject() == this) {\n-                database.removeDatabaseObject(session, right);\n-            }\n-        }\n-        database.removeMeta(session, getId());\n-        owner = null;\n-        invalidate();\n-    }\n-\n-    private void removeChildrenFromMap(Session session, ConcurrentHashMap<String, ? extends SchemaObject> map) {\n-        if (!map.isEmpty()) {\n-            for (SchemaObject obj : map.values()) {\n-                // Database.removeSchemaObject() removes the object from\n-                // the map too, but it is safe for ConcurrentHashMap.\n-                database.removeSchemaObject(session, obj);\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Get the owner of this schema.\n-     *\n-     * @return the owner\n-     */\n-    public User getOwner() {\n-        return owner;\n-    }\n-\n-    /**\n-     * Get table engine params of this schema.\n-     *\n-     * @return default table engine params\n-     */\n-    public ArrayList<String> getTableEngineParams() {\n-        return tableEngineParams;\n-    }\n-\n-    /**\n-     * Set table engine params of this schema.\n-     * @param tableEngineParams default table engine params\n-     */\n-    public void setTableEngineParams(ArrayList<String> tableEngineParams) {\n-        this.tableEngineParams = tableEngineParams;\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private Map<String, SchemaObject> getMap(int type) {\n-        Map<String, ? extends SchemaObject> result;\n-        switch (type) {\n-        case DbObject.TABLE_OR_VIEW:\n-            result = tablesAndViews;\n-            break;\n-        case DbObject.DOMAIN:\n-            result = domains;\n-            break;\n-        case DbObject.SYNONYM:\n-            result = synonyms;\n-            break;\n-        case DbObject.SEQUENCE:\n-            result = sequences;\n+        name = null;\n+      }\n+      if (name == null) {\n+        prefix = prefix + hash + \"_\";\n+        for (int i = 0; ; i++) {\n+          name = prefix + i;\n+          if (!map.containsKey(name) && !temporaryUniqueNames.contains(name)) {\n             break;\n-        case DbObject.INDEX:\n-            result = indexes;\n-            break;\n-        case DbObject.TRIGGER:\n-            result = triggers;\n-            break;\n-        case DbObject.CONSTRAINT:\n-            result = constraints;\n-            break;\n-        case DbObject.CONSTANT:\n-            result = constants;\n-            break;\n-        case DbObject.FUNCTION_ALIAS:\n-            result = functions;\n-            break;\n-        default:\n-            throw DbException.throwInternalError(\"type=\" + type);\n-        }\n-        return (Map<String, SchemaObject>) result;\n-    }\n-\n-    /**\n-     * Add an object to this schema.\n-     * This method must not be called within CreateSchemaObject;\n-     * use Database.addSchemaObject() instead\n-     *\n-     * @param obj the object to add\n-     */\n-    public void add(SchemaObject obj) {\n-        if (obj.getSchema() != this) {\n-            DbException.throwInternalError(\"wrong schema\");\n+          }\n         }\n-        String name = obj.getName();\n-        Map<String, SchemaObject> map = getMap(obj.getType());\n-        if (SysProperties.CHECK && map.get(name) != null) {\n-            DbException.throwInternalError(\"object already exists: \" + name);\n+      }\n+      temporaryUniqueNames.add(name);\n+    }\n+    return name;\n+  }\n+\n+  /**\n+   * Create a unique constraint name.\n+   *\n+   * @param session the session\n+   * @param table   the constraint table\n+   * @return the unique name\n+   */\n+  public String getUniqueConstraintName(Session session, Table table) {\n+    Map<String, Constraint> tableConstraints;\n+    if (table.isTemporary() && !table.isGlobalTemporary()) {\n+      tableConstraints = session.getLocalTempTableConstraints();\n+    } else {\n+      tableConstraints = constraints;\n+    }\n+    return getUniqueName(table, tableConstraints, \"CONSTRAINT_\");\n+  }\n+\n+  /**\n+   * Create a unique constraint name.\n+   *\n+   * @param session the session\n+   * @param domain  the constraint domain\n+   * @return the unique name\n+   */\n+  public String getUniqueDomainConstraintName(Session session, Domain domain) {\n+    return getUniqueName(domain, constraints, \"CONSTRAINT_\");\n+  }\n+\n+  /**\n+   * Create a unique index name.\n+   *\n+   * @param session the session\n+   * @param table   the indexed table\n+   * @param prefix  the index name prefix\n+   * @return the unique name\n+   */\n+  public String getUniqueIndexName(Session session, Table table, String prefix) {\n+    Map<String, Index> tableIndexes;\n+    if (table.isTemporary() && !table.isGlobalTemporary()) {\n+      tableIndexes = session.getLocalTempTableIndexes();\n+    } else {\n+      tableIndexes = indexes;\n+    }\n+    return getUniqueName(table, tableIndexes, prefix);\n+  }\n+\n+  /**\n+   * Get the table or view with the given name.\n+   * Local temporary tables are also returned.\n+   *\n+   * @param session the session\n+   * @param name    the table or view name\n+   * @return the table or view\n+   * @throws DbException if no such object exists\n+   */\n+  public Table getTableOrView(Session session, String name) {\n+    Table table = tablesAndViews.get(name);\n+    if (table == null) {\n+      if (session != null) {\n+        table = session.findLocalTempTable(name);\n+      }\n+      if (table == null) {\n+        throw DbException.get(ErrorCode.TABLE_OR_VIEW_NOT_FOUND_1, name);\n+      }\n+    }\n+    return table;\n+  }\n+\n+  /**\n+   * Get the domain with the given name.\n+   *\n+   * @param name the domain name\n+   * @return the domain\n+   * @throws DbException if no such object exists\n+   */\n+  public Domain getDomain(String name) {\n+    Domain domain = domains.get(name);\n+    if (domain == null) {\n+      throw DbException.get(ErrorCode.DOMAIN_NOT_FOUND_1, name);\n+    }\n+    return domain;\n+  }\n+\n+  /**\n+   * Get the index with the given name.\n+   *\n+   * @param name the index name\n+   * @return the index\n+   * @throws DbException if no such object exists\n+   */\n+  public Index getIndex(String name) {\n+    Index index = indexes.get(name);\n+    if (index == null) {\n+      throw DbException.get(ErrorCode.INDEX_NOT_FOUND_1, name);\n+    }\n+    return index;\n+  }\n+\n+  /**\n+   * Get the constraint with the given name.\n+   *\n+   * @param name the constraint name\n+   * @return the constraint\n+   * @throws DbException if no such object exists\n+   */\n+  public Constraint getConstraint(String name) {\n+    Constraint constraint = constraints.get(name);\n+    if (constraint == null) {\n+      throw DbException.get(ErrorCode.CONSTRAINT_NOT_FOUND_1, name);\n+    }\n+    return constraint;\n+  }\n+\n+  /**\n+   * Get the user defined constant with the given name.\n+   *\n+   * @param constantName the constant name\n+   * @return the constant\n+   * @throws DbException if no such object exists\n+   */\n+  public Constant getConstant(String constantName) {\n+    Constant constant = constants.get(constantName);\n+    if (constant == null) {\n+      throw DbException.get(ErrorCode.CONSTANT_NOT_FOUND_1, constantName);\n+    }\n+    return constant;\n+  }\n+\n+  /**\n+   * Get the sequence with the given name.\n+   *\n+   * @param sequenceName the sequence name\n+   * @return the sequence\n+   * @throws DbException if no such object exists\n+   */\n+  public Sequence getSequence(String sequenceName) {\n+    Sequence sequence = sequences.get(sequenceName);\n+    if (sequence == null) {\n+      throw DbException.get(ErrorCode.SEQUENCE_NOT_FOUND_1, sequenceName);\n+    }\n+    return sequence;\n+  }\n+\n+  /**\n+   * Get all objects.\n+   *\n+   * @param addTo list to add objects to, or {@code null} to allocate a new\n+   *              list\n+   * @return the specified list with added objects, or a new (possibly empty) list\n+   * with all objects\n+   */\n+  public ArrayList<SchemaObject> getAll(ArrayList<SchemaObject> addTo) {\n+    if (addTo == null) {\n+      addTo = Utils.newSmallArrayList();\n+    }\n+    addTo.addAll(tablesAndViews.values());\n+    addTo.addAll(domains.values());\n+    addTo.addAll(synonyms.values());\n+    addTo.addAll(sequences.values());\n+    addTo.addAll(indexes.values());\n+    addTo.addAll(triggers.values());\n+    addTo.addAll(constraints.values());\n+    addTo.addAll(constants.values());\n+    addTo.addAll(functions.values());\n+    return addTo;\n+  }\n+\n+  /**\n+   * Get all objects of the given type.\n+   *\n+   * @param type  the object type\n+   * @param addTo list to add objects to, or {@code null} to allocate a new\n+   *              list\n+   * @return the specified list with added objects, or a new (possibly empty) list\n+   * with objects of the given type\n+   */\n+  public ArrayList<SchemaObject> getAll(int type, ArrayList<SchemaObject> addTo) {\n+    Collection<SchemaObject> values = getMap(type).values();\n+    if (addTo != null) {\n+      addTo.addAll(values);\n+    } else {\n+      addTo = new ArrayList<>(values);\n+    }\n+    return addTo;\n+  }\n+\n+  /**\n+   * Get all tables and views.\n+   *\n+   * @return a (possible empty) list of all objects\n+   */\n+  public Collection<Table> getAllTablesAndViews() {\n+    return tablesAndViews.values();\n+  }\n+\n+\n+  public Collection<TableSynonym> getAllSynonyms() {\n+    return synonyms.values();\n+  }\n+\n+  /**\n+   * Get the table with the given name, if any.\n+   *\n+   * @param name the table name\n+   * @return the table or null if not found\n+   */\n+  public Table getTableOrViewByName(String name) {\n+    return tablesAndViews.get(name);\n+  }\n+\n+  /**\n+   * Remove an object from this schema.\n+   *\n+   * @param obj the object to remove\n+   */\n+  public void remove(SchemaObject obj) {\n+    String objName = obj.getName();\n+    Map<String, SchemaObject> map = getMap(obj.getType());\n+    if (map.remove(objName) == null) {\n+      DbException.throwInternalError(\"not found: \" + objName);\n+    }\n+    freeUniqueName(objName);\n+  }\n+\n+  /**\n+   * Add a table to the schema.\n+   *\n+   * @param data the create table information\n+   * @return the created {@link Table} object\n+   */\n+  public Table createTable(CreateTableData data) {\n+    synchronized (database) {\n+      if (!data.temporary || data.globalTemporary) {\n+        database.lockMeta(data.session);\n+      }\n+      data.schema = this;\n+      if (data.tableEngine == null) {\n+        DbSettings s = database.getSettings();\n+        if (s.defaultTableEngine != null) {\n+          data.tableEngine = s.defaultTableEngine;\n+        } else if (s.mvStore) {\n+          data.tableEngine = MVTableEngine.class.getName();\n         }\n-        map.put(name, obj);\n-        freeUniqueName(name);\n-    }\n-\n-    /**\n-     * Rename an object.\n-     *\n-     * @param obj the object to rename\n-     * @param newName the new name\n-     */\n-    public void rename(SchemaObject obj, String newName) {\n-        int type = obj.getType();\n-        Map<String, SchemaObject> map = getMap(type);\n-        if (SysProperties.CHECK) {\n-            if (!map.containsKey(obj.getName())) {\n-                DbException.throwInternalError(\"not found: \" + obj.getName());\n-            }\n-            if (obj.getName().equals(newName) || map.containsKey(newName)) {\n-                DbException.throwInternalError(\"object already exists: \" + newName);\n-            }\n-        }\n-        obj.checkRename();\n-        map.remove(obj.getName());\n-        freeUniqueName(obj.getName());\n-        obj.rename(newName);\n-        map.put(newName, obj);\n-        freeUniqueName(newName);\n-    }\n-\n-    /**\n-     * Try to find a table or view with this name. This method returns null if\n-     * no object with this name exists. Local temporary tables are also\n-     * returned. Synonyms are not returned or resolved.\n-     *\n-     * @param session the session\n-     * @param name the object name\n-     * @return the object or null\n-     */\n-    public Table findTableOrView(Session session, String name) {\n-        Table table = tablesAndViews.get(name);\n-        if (table == null && session != null) {\n-            table = session.findLocalTempTable(name);\n-        }\n-        return table;\n-    }\n-\n-    /**\n-     * Try to find a table or view with this name. This method returns null if\n-     * no object with this name exists. Local temporary tables are also\n-     * returned. If a synonym with this name exists, the backing table of the\n-     * synonym is returned\n-     *\n-     * @param session the session\n-     * @param name the object name\n-     * @return the object or null\n-     */\n-    public Table resolveTableOrView(Session session, String name) {\n-        Table table = findTableOrView(session, name);\n-        if (table == null) {\n-            TableSynonym synonym = synonyms.get(name);\n-            if (synonym != null) {\n-                return synonym.getSynonymFor();\n-            }\n+      }\n+      if (data.tableEngine != null) {\n+        if (data.tableEngineParams == null) {\n+          data.tableEngineParams = this.tableEngineParams;\n         }\n-        return table;\n-    }\n-\n-    /**\n-     * Try to find a synonym with this name. This method returns null if\n-     * no object with this name exists.\n-     *\n-     * @param name the object name\n-     * @return the object or null\n-     */\n-    public TableSynonym getSynonym(String name) {\n-        return synonyms.get(name);\n-    }\n-\n-    /**\n-     * Get the domain if it exists, or null if not.\n-     *\n-     * @param name the name of the domain\n-     * @return the domain or null\n-     */\n-    public Domain findDomain(String name) {\n-        return domains.get(name);\n-    }\n-\n-    /**\n-     * Try to find an index with this name. This method returns null if\n-     * no object with this name exists.\n-     *\n-     * @param session the session\n-     * @param name the object name\n-     * @return the object or null\n-     */\n-    public Index findIndex(Session session, String name) {\n-        Index index = indexes.get(name);\n-        if (index == null) {\n-            index = session.findLocalTempTableIndex(name);\n-        }\n-        return index;\n-    }\n-\n-    /**\n-     * Try to find a trigger with this name. This method returns null if\n-     * no object with this name exists.\n-     *\n-     * @param name the object name\n-     * @return the object or null\n-     */\n-    public TriggerObject findTrigger(String name) {\n-        return triggers.get(name);\n-    }\n-\n-    /**\n-     * Try to find a sequence with this name. This method returns null if\n-     * no object with this name exists.\n-     *\n-     * @param sequenceName the object name\n-     * @return the object or null\n-     */\n-    public Sequence findSequence(String sequenceName) {\n-        return sequences.get(sequenceName);\n-    }\n-\n-    /**\n-     * Try to find a constraint with this name. This method returns null if no\n-     * object with this name exists.\n-     *\n-     * @param session the session\n-     * @param name the object name\n-     * @return the object or null\n-     */\n-    public Constraint findConstraint(Session session, String name) {\n-        Constraint constraint = constraints.get(name);\n-        if (constraint == null) {\n-            constraint = session.findLocalTempTableConstraint(name);\n-        }\n-        return constraint;\n-    }\n-\n-    /**\n-     * Try to find a user defined constant with this name. This method returns\n-     * null if no object with this name exists.\n-     *\n-     * @param constantName the object name\n-     * @return the object or null\n-     */\n-    public Constant findConstant(String constantName) {\n-        return constants.get(constantName);\n-    }\n-\n-    /**\n-     * Try to find a user defined function with this name. This method returns\n-     * null if no object with this name exists.\n-     *\n-     * @param functionAlias the object name\n-     * @return the object or null\n-     */\n-    public FunctionAlias findFunction(String functionAlias) {\n-        return functions.get(functionAlias);\n-    }\n-\n-    /**\n-     * Release a unique object name.\n-     *\n-     * @param name the object name\n-     */\n-    public void freeUniqueName(String name) {\n-        if (name != null) {\n-            synchronized (temporaryUniqueNames) {\n-                temporaryUniqueNames.remove(name);\n-            }\n-        }\n-    }\n-\n-    private String getUniqueName(DbObject obj,\n-            Map<String, ? extends SchemaObject> map, String prefix) {\n-        String hash = StringUtils.toUpperEnglish(Integer.toHexString(obj.getName().hashCode()));\n-        String name = null;\n-        synchronized (temporaryUniqueNames) {\n-            for (int i = 1, len = hash.length(); i < len; i++) {\n-                name = prefix + hash.substring(0, i);\n-                if (!map.containsKey(name) && !temporaryUniqueNames.contains(name)) {\n-                    break;\n-                }\n-                name = null;\n-            }\n-            if (name == null) {\n-                prefix = prefix + hash + \"_\";\n-                for (int i = 0;; i++) {\n-                    name = prefix + i;\n-                    if (!map.containsKey(name) && !temporaryUniqueNames.contains(name)) {\n-                        break;\n-                    }\n-                }\n-            }\n-            temporaryUniqueNames.add(name);\n-        }\n-        return name;\n-    }\n-\n-    /**\n-     * Create a unique constraint name.\n-     *\n-     * @param session the session\n-     * @param table the constraint table\n-     * @return the unique name\n-     */\n-    public String getUniqueConstraintName(Session session, Table table) {\n-        Map<String, Constraint> tableConstraints;\n-        if (table.isTemporary() && !table.isGlobalTemporary()) {\n-            tableConstraints = session.getLocalTempTableConstraints();\n-        } else {\n-            tableConstraints = constraints;\n-        }\n-        return getUniqueName(table, tableConstraints, \"CONSTRAINT_\");\n-    }\n-\n-    /**\n-     * Create a unique constraint name.\n-     *\n-     * @param session the session\n-     * @param domain the constraint domain\n-     * @return the unique name\n-     */\n-    public String getUniqueDomainConstraintName(Session session, Domain domain) {\n-        return getUniqueName(domain, constraints, \"CONSTRAINT_\");\n-    }\n-\n-    /**\n-     * Create a unique index name.\n-     *\n-     * @param session the session\n-     * @param table the indexed table\n-     * @param prefix the index name prefix\n-     * @return the unique name\n-     */\n-    public String getUniqueIndexName(Session session, Table table, String prefix) {\n-        Map<String, Index> tableIndexes;\n-        if (table.isTemporary() && !table.isGlobalTemporary()) {\n-            tableIndexes = session.getLocalTempTableIndexes();\n-        } else {\n-            tableIndexes = indexes;\n-        }\n-        return getUniqueName(table, tableIndexes, prefix);\n-    }\n-\n-    /**\n-     * Get the table or view with the given name.\n-     * Local temporary tables are also returned.\n-     *\n-     * @param session the session\n-     * @param name the table or view name\n-     * @return the table or view\n-     * @throws DbException if no such object exists\n-     */\n-    public Table getTableOrView(Session session, String name) {\n-        Table table = tablesAndViews.get(name);\n-        if (table == null) {\n-            if (session != null) {\n-                table = session.findLocalTempTable(name);\n-            }\n-            if (table == null) {\n-                throw DbException.get(ErrorCode.TABLE_OR_VIEW_NOT_FOUND_1, name);\n-            }\n-        }\n-        return table;\n-    }\n-\n-    /**\n-     * Get the domain with the given name.\n-     *\n-     * @param name the domain name\n-     * @return the domain\n-     * @throws DbException if no such object exists\n-     */\n-    public Domain getDomain(String name) {\n-        Domain domain = domains.get(name);\n-        if (domain == null) {\n-            throw DbException.get(ErrorCode.DOMAIN_NOT_FOUND_1, name);\n-        }\n-        return domain;\n-    }\n-\n-    /**\n-     * Get the index with the given name.\n-     *\n-     * @param name the index name\n-     * @return the index\n-     * @throws DbException if no such object exists\n-     */\n-    public Index getIndex(String name) {\n-        Index index = indexes.get(name);\n-        if (index == null) {\n-            throw DbException.get(ErrorCode.INDEX_NOT_FOUND_1, name);\n-        }\n-        return index;\n-    }\n-\n-    /**\n-     * Get the constraint with the given name.\n-     *\n-     * @param name the constraint name\n-     * @return the constraint\n-     * @throws DbException if no such object exists\n-     */\n-    public Constraint getConstraint(String name) {\n-        Constraint constraint = constraints.get(name);\n-        if (constraint == null) {\n-            throw DbException.get(ErrorCode.CONSTRAINT_NOT_FOUND_1, name);\n-        }\n-        return constraint;\n-    }\n-\n-    /**\n-     * Get the user defined constant with the given name.\n-     *\n-     * @param constantName the constant name\n-     * @return the constant\n-     * @throws DbException if no such object exists\n-     */\n-    public Constant getConstant(String constantName) {\n-        Constant constant = constants.get(constantName);\n-        if (constant == null) {\n-            throw DbException.get(ErrorCode.CONSTANT_NOT_FOUND_1, constantName);\n-        }\n-        return constant;\n-    }\n-\n-    /**\n-     * Get the sequence with the given name.\n-     *\n-     * @param sequenceName the sequence name\n-     * @return the sequence\n-     * @throws DbException if no such object exists\n-     */\n-    public Sequence getSequence(String sequenceName) {\n-        Sequence sequence = sequences.get(sequenceName);\n-        if (sequence == null) {\n-            throw DbException.get(ErrorCode.SEQUENCE_NOT_FOUND_1, sequenceName);\n-        }\n-        return sequence;\n-    }\n-\n-    /**\n-     * Get all objects.\n-     *\n-     * @param addTo\n-     *                  list to add objects to, or {@code null} to allocate a new\n-     *                  list\n-     * @return the specified list with added objects, or a new (possibly empty) list\n-     *         with all objects\n-     */\n-    public ArrayList<SchemaObject> getAll(ArrayList<SchemaObject> addTo) {\n-        if (addTo == null) {\n-            addTo = Utils.newSmallArrayList();\n-        }\n-        addTo.addAll(tablesAndViews.values());\n-        addTo.addAll(domains.values());\n-        addTo.addAll(synonyms.values());\n-        addTo.addAll(sequences.values());\n-        addTo.addAll(indexes.values());\n-        addTo.addAll(triggers.values());\n-        addTo.addAll(constraints.values());\n-        addTo.addAll(constants.values());\n-        addTo.addAll(functions.values());\n-        return addTo;\n-    }\n-\n-    /**\n-     * Get all objects of the given type.\n-     *\n-     * @param type\n-     *                  the object type\n-     * @param addTo\n-     *                  list to add objects to, or {@code null} to allocate a new\n-     *                  list\n-     * @return the specified list with added objects, or a new (possibly empty) list\n-     *         with objects of the given type\n-     */\n-    public ArrayList<SchemaObject> getAll(int type, ArrayList<SchemaObject> addTo) {\n-        Collection<SchemaObject> values = getMap(type).values();\n-        if (addTo != null) {\n-            addTo.addAll(values);\n-        } else {\n-            addTo = new ArrayList<>(values);\n-        }\n-        return addTo;\n-    }\n-\n-    /**\n-     * Get all tables and views.\n-     *\n-     * @return a (possible empty) list of all objects\n-     */\n-    public Collection<Table> getAllTablesAndViews() {\n-        return tablesAndViews.values();\n-    }\n-\n-\n-    public Collection<TableSynonym> getAllSynonyms() {\n-        return synonyms.values();\n-    }\n-\n-    /**\n-     * Get the table with the given name, if any.\n-     *\n-     * @param name the table name\n-     * @return the table or null if not found\n-     */\n-    public Table getTableOrViewByName(String name) {\n-        return tablesAndViews.get(name);\n-    }\n-\n-    /**\n-     * Remove an object from this schema.\n-     *\n-     * @param obj the object to remove\n-     */\n-    public void remove(SchemaObject obj) {\n-        String objName = obj.getName();\n-        Map<String, SchemaObject> map = getMap(obj.getType());\n-        if (map.remove(objName) == null) {\n-            DbException.throwInternalError(\"not found: \" + objName);\n-        }\n-        freeUniqueName(objName);\n-    }\n-\n-    /**\n-     * Add a table to the schema.\n-     *\n-     * @param data the create table information\n-     * @return the created {@link Table} object\n-     */\n-    public Table createTable(CreateTableData data) {\n-        synchronized (database) {\n-            if (!data.temporary || data.globalTemporary) {\n-                database.lockMeta(data.session);\n-            }\n-            data.schema = this;\n-            if (data.tableEngine == null) {\n-                DbSettings s = database.getSettings();\n-                if (s.defaultTableEngine != null) {\n-                    data.tableEngine = s.defaultTableEngine;\n-                } else if (s.mvStore) {\n-                    data.tableEngine = MVTableEngine.class.getName();\n-                }\n-            }\n-            if (data.tableEngine != null) {\n-                if (data.tableEngineParams == null) {\n-                    data.tableEngineParams = this.tableEngineParams;\n-                }\n-                return database.getTableEngine(data.tableEngine).createTable(data);\n-            }\n-            return new PageStoreTable(data);\n-        }\n-    }\n-\n-    /**\n-     * Add a table synonym to the schema.\n-     *\n-     * @param data the create synonym information\n-     * @return the created {@link TableSynonym} object\n-     */\n-    public TableSynonym createSynonym(CreateSynonymData data) {\n-        synchronized (database) {\n-            database.lockMeta(data.session);\n-            data.schema = this;\n-            return new TableSynonym(data);\n-        }\n-    }\n-\n-    /**\n-     * Add a linked table to the schema.\n-     *\n-     * @param id the object id\n-     * @param tableName the table name of the alias\n-     * @param driver the driver class name\n-     * @param url the database URL\n-     * @param user the user name\n-     * @param password the password\n-     * @param originalSchema the schema name of the target table\n-     * @param originalTable the table name of the target table\n-     * @param emitUpdates if updates should be emitted instead of delete/insert\n-     * @param force create the object even if the database can not be accessed\n-     * @return the {@link TableLink} object\n-     */\n-    public TableLink createTableLink(int id, String tableName, String driver,\n-            String url, String user, String password, String originalSchema,\n-            String originalTable, boolean emitUpdates, boolean force) {\n-        synchronized (database) {\n-            return new TableLink(this, id, tableName,\n-                    driver, url, user, password,\n-                    originalSchema, originalTable, emitUpdates, force);\n-        }\n-    }\n+        return database.getTableEngine(data.tableEngine).createTable(data);\n+      }\n+      return new PageStoreTable(data);\n+    }\n+  }\n+\n+  /**\n+   * Add a table synonym to the schema.\n+   *\n+   * @param data the create synonym information\n+   * @return the created {@link TableSynonym} object\n+   */\n+  public TableSynonym createSynonym(CreateSynonymData data) {\n+    synchronized (database) {\n+      database.lockMeta(data.session);\n+      data.schema = this;\n+      return new TableSynonym(data);\n+    }\n+  }\n+\n+  /**\n+   * Add a linked table to the schema.\n+   *\n+   * @param id             the object id\n+   * @param tableName      the table name of the alias\n+   * @param driver         the driver class name\n+   * @param url            the database URL\n+   * @param user           the user name\n+   * @param password       the password\n+   * @param originalSchema the schema name of the target table\n+   * @param originalTable  the table name of the target table\n+   * @param emitUpdates    if updates should be emitted instead of delete/insert\n+   * @param force          create the object even if the database can not be accessed\n+   * @return the {@link TableLink} object\n+   */\n+  public TableLink createTableLink(int id, String tableName, String driver,\n+                                   String url, String user, String password, String originalSchema,\n+                                   String originalTable, boolean emitUpdates, boolean force) {\n+    synchronized (database) {\n+      return new TableLink(this, id, tableName,\n+          driver, url, user, password,\n+          originalSchema, originalTable, emitUpdates, force);\n+    }\n+  }\n \n }\n",
            "diff_size": 1262
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "163",
                    "column": "72",
                    "severity": "warning",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/107/Schema.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_random/107/Schema.java\nindex 4ba3d83e74d..63b219cafcf 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/107/Schema.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_random/107/Schema.java\n@@ -161,7 +161,7 @@ public class Schema extends DbObjectBase {\n                         newModified = true;\n                     } else if (dependentTable.getSchema() != this) {\n                         throw DbException.get(ErrorCode.CANNOT_DROP_2, //\n-                                obj.getSQL(false), dependentTable.getSQL(false));\n+                            obj.getSQL(false), dependentTable.getSQL(false));\n                     } else if (!modified) {\n                         dependentTable.removeColumnExpressionsDependencies(session);\n                         dependentTable.setModified();\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/107/Schema.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/107/Schema.java\nindex 4ba3d83e74d..cc95826bd5f 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/107/Schema.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/107/Schema.java\n@@ -160,8 +160,9 @@ public class Schema extends DbObjectBase {\n                         database.removeSchemaObject(session, obj);\n                         newModified = true;\n                     } else if (dependentTable.getSchema() != this) {\n-                        throw DbException.get(ErrorCode.CANNOT_DROP_2, //\n-                                obj.getSQL(false), dependentTable.getSQL(false));\n+                        throw DbException.get(ErrorCode.CANNOT_DROP_2,\n+                            //\n+                                 obj.getSQL(false), dependentTable.getSQL(false));\n                     } else if (!modified) {\n                         dependentTable.removeColumnExpressionsDependencies(session);\n                         dependentTable.setModified();\n",
            "diff_size": 3
        }
    ],
    "repaired_by": [
        "styler",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random"
    ]
}