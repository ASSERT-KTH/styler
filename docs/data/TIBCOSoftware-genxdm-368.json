{
    "project_name": "TIBCOSoftware-genxdm",
    "error_id": "368",
    "information": {
        "errors": [
            {
                "line": "77",
                "column": "1",
                "severity": "warning",
                "message": "File contains tab characters (this is the first instance).",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
            }
        ]
    },
    "source_code": "final class ModelPSVI implements VxPSVI, Locatable\n{\n\tprivate ModelPSVI m_parentItem;\n\n\tpublic ModelPSVI getParent()\n\t{",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "79",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/368/ModelPSVI.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler/368/ModelPSVI.java\nindex 2477f43087b..75612a609ba 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/368/ModelPSVI.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler/368/ModelPSVI.java\n@@ -74,7 +74,7 @@ import org.genxdm.xs.types.UnionSimpleType;\n  */\n final class ModelPSVI implements VxPSVI, Locatable\n {\n-\tprivate ModelPSVI m_parentItem;\n+private ModelPSVI m_parentItem;\n \n \tpublic ModelPSVI getParent()\n \t{\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/368/ModelPSVI.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/intellij/368/ModelPSVI.java\nindex 2477f43087b..d87f9518557 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/368/ModelPSVI.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/intellij/368/ModelPSVI.java\n@@ -1,18 +1,19 @@\n /**\n  * Copyright (c) 2009-2010 TIBCO Software Inc.\n- *\n+ * <p>\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+\n package org.genxdm.processor.w3c.xs.validation.impl;\n \n import java.util.ArrayList;\n@@ -72,735 +73,621 @@ import org.genxdm.xs.types.UnionSimpleType;\n  * child pointers and supply push and pop methods. Also note that the objects are recycled by the push method using the\n  * child pointer.\n  */\n-final class ModelPSVI implements VxPSVI, Locatable\n-{\n-\tprivate ModelPSVI m_parentItem;\n-\n-\tpublic ModelPSVI getParent()\n-\t{\n-\t\treturn m_parentItem;\n-\t}\n-\n-\tprivate final ValidationCache cache;\n-\tprivate final ComponentProvider metaBridge;\n-\n-\tprivate ModelPSVI m_childItem; // for recycling\n-\n-\tprivate final NodeKind m_nodeKind;\n-\n-\t// The name of the element information item.\n-\tprivate QName m_elementName;\n-\n-\tpublic QName getName()\n-\t{\n-\t\treturn m_elementName;\n-\t}\n-\n-\tprivate int m_lineNumber;\n-\tprivate int m_columnNumber;\n-\tprivate int m_characterOffset;\n-\tprivate String m_publicId;\n-\tprivate String m_systemId;\n-\n-\tpublic LocationInSchema getLocation()\n-\t{\n-\t\treturn new SrcFrozenLocation(m_lineNumber, m_columnNumber, m_characterOffset, m_publicId, m_systemId);\n-\t}\n-\n-\tprivate Type m_type;\n-\tprivate SmContentFiniteStateMachine m_machine;\n-\n-\tprivate ProcessContentsMode m_processContents;\n-\n-\t// The XML Schema specification does not specify what a validating processor should do after\n-\t// it encounters an error. It is not obliged to report more than the first error.\n-\tprivate boolean m_suspendChecking;\n-\n-\tprivate ElementDefinition m_elementDecl;\n-\n-\t// Did the instance use xsi:nil=\"true\"?\n-\tprivate boolean m_nilled;\n-\n-\t/**\n-\t * Identity scopes may exist for an element information item.\n-\t */\n-\tpublic final ArrayList<IdentityScope> m_identityScopes = new ArrayList<IdentityScope>();\n-\tpublic final HashMap<IdentityConstraint, IdentityScope> m_keyScopes = new HashMap<IdentityConstraint, IdentityScope>();\n-\n-\tprivate ModelPSVI(final ModelPSVI parent, final NodeKind nodeKind, final ProcessContentsMode processContents, final ComponentProvider metaBridge, final ValidationCache cache)\n-\t{\n-\t\tthis.m_parentItem = parent;\n-\t\tthis.m_nodeKind = PreCondition.assertArgumentNotNull(nodeKind, \"nodeKind\");\n-\t\tthis.metaBridge = PreCondition.assertArgumentNotNull(metaBridge, \"metaBridge\");\n-\t\tthis.cache = PreCondition.assertArgumentNotNull(cache, \"cache\");\n-\t\treset(processContents);\n-\t}\n-\n-\tpublic ModelPSVI(final ProcessContentsMode processContents, final ComponentProvider metaBridge, final ValidationCache cache)\n-\t{\n-\t\tthis(null, NodeKind.DOCUMENT, processContents, metaBridge, cache);\n-\t}\n-\n-\tpublic ModelPSVI push(final QName elementName)\n-\t{\n-\t\tif (m_childItem == null)\n-\t\t{\n-\t\t\tm_childItem = new ModelPSVI(this, NodeKind.ELEMENT, getProcessContents(), this.metaBridge, this.cache);\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tm_childItem.reset(getProcessContents());\n-\t\t}\n-\t\tm_childItem.m_elementName = PreCondition.assertArgumentNotNull(elementName, \"elementName\");\n-\n-\t\t// TODO: Need to get the element location.\n-\t\tm_childItem.m_lineNumber = -1;\n-\t\tm_childItem.m_columnNumber = -1;\n-\t\tm_childItem.m_characterOffset = -1;\n-\t\tm_childItem.m_publicId = null;\n-\t\tm_childItem.m_systemId = null;\n-\n-\t\treturn m_childItem;\n-\t}\n-\n-\tpublic boolean declExists()\n-\t{\n-\t\treturn (null != m_elementDecl);\n-\t}\n-\n-\t/**\n-\t * Computes the {nilled} property for the element information item by checking the interaction of the xsi:nil and\n-\t * the {nillable} property of the element declaration.\n-\t */\n-\tpublic boolean computeNilled(final Boolean explicitNil, final SchemaExceptionHandler errors) throws AbortException\n-\t{\n-\t\tif (null != explicitNil)\n-\t\t{\n-\t\t\tif (null != m_elementDecl)\n-\t\t\t{\n-\t\t\t\tif (m_elementDecl.isNillable())\n-\t\t\t\t{\n-\t\t\t\t\tif (explicitNil)\n-\t\t\t\t\t{\n-\t\t\t\t\t\tfinal ValueConstraint valueConstraint = m_elementDecl.getValueConstraint();\n-\t\t\t\t\t\tif (null != valueConstraint && valueConstraint.getVariety().isFixed())\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\terrors.error(new CvcElementFixedAndNilledException(m_elementDecl, getLocation()));\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\telse\n-\t\t\t\t{\n-\t\t\t\t\terrors.error(new CvcElementNotNillableException(m_elementDecl, getLocation()));\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\treturn explicitNil;\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\treturn false;\n-\t\t}\n-\t}\n-\n-\tpublic boolean step(final QName childName, final Locatable childLocatable, final SchemaExceptionHandler errors) throws AbortException\n-\t{\n-\t\tfinal Type elementType = getType();\n-\t\tif (null == elementType)\n-\t\t{\n-\t\t\t// TODO: We should really see if locally valid wrt to type has been flagged.\n-\t\t\t// Do nothing if there is no type annotation.\n-\t\t\treturn false;\n-\t\t}\n-\n-\t\tif (elementType instanceof SimpleType)\n-\t\t{\n-\t\t\t// TODO: Do we include the xs:anySimpleType (simple ur-type)?\n-\t\t\terrors.error(new CvcElementInSimpleTypeException(getName(), getLocation(), childName, childLocatable.getLocation()));\n-\t\t\treturn false;\n-\t\t}\n-\t\telse if (elementType instanceof ComplexType)\n-\t\t{\n-\t\t\tfinal ComplexType complexType = (ComplexType)elementType;\n-\t\t\tif (m_suspendChecking)\n-\t\t\t{\n-\t\t\t\treturn false;\n-\t\t\t}\n-\n-\t\t\tswitch (getProcessContents())\n-\t\t\t{\n-\t\t\t\tcase Lax:\n-\t\t\t\t{\n-\t\t\t\t\t// Fall through\n-\t\t\t\t}\n-\t\t\t\tbreak;\n-\t\t\t\tcase Skip:\n-\t\t\t\t{\n-\t\t\t\t\treturn false;\n-\t\t\t\t}\n-\t\t\t\tcase Strict:\n-\t\t\t\t{\n-\t\t\t\t\t// Fall through\n-\t\t\t\t}\n-\t\t\t\tbreak;\n-\t\t\t\tdefault:\n-\t\t\t\t{\n-\t\t\t\t\tthrow new AssertionError(getProcessContents().name());\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tif (m_nilled && (null != m_elementDecl))\n-\t\t\t{\n-\t\t\t\terrors.error(new CvcElementUnexpectedChildInNilledElementException(m_elementDecl, getLocation()));\n-\t\t\t\treturn false;\n-\t\t\t}\n-\t\t\tswitch (complexType.getContentType().getKind())\n-\t\t\t{\n-\t\t\t\tcase Empty:\n-\t\t\t\t{\n-\t\t\t\t\terrors.error(new CvcElementInEmptyContentException(getName(), getLocation(), childName, childLocatable.getLocation()));\n-\t\t\t\t\treturn false;\n-\t\t\t\t}\n-\t\t\t\tcase Simple:\n-\t\t\t\t{\n-\t\t\t\t\terrors.error(new CvcElementInSimpleContentTypeException(getName(), getLocation(), childName, childLocatable.getLocation()));\n-\t\t\t\t\treturn false;\n-\t\t\t\t}\n-\t\t\t\tcase ElementOnly:\n-\t\t\t\tcase Mixed:\n-\t\t\t\t{\n-\t\t\t\t\tswitch (m_nodeKind)\n-\t\t\t\t\t{\n-\t\t\t\t\t\tcase ELEMENT:\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tif (null != m_machine)\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tif (m_machine.step(childName))\n-\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\treturn true;\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\telse\n-\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\terrors.error(new SmUnexpectedElementException(getName(), getLocation(), childName, childLocatable.getLocation()));\n-\t\t\t\t\t\t\t\t\tm_suspendChecking = true;\n-\t\t\t\t\t\t\t\t\treturn false;\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\telse\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tswitch (getProcessContents())\n-\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\tcase Strict:\n-\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\terrors.error(new SmUnexpectedElementException(getName(), getLocation(), childName, childLocatable.getLocation()));\n-\t\t\t\t\t\t\t\t\t\tm_suspendChecking = true;\n-\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\tdefault:\n-\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\treturn false;\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tcase DOCUMENT:\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\treturn false;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tdefault:\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tthrow new AssertionError(m_nodeKind);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tdefault:\n-\t\t\t\t{\n-\t\t\t\t\tthrow new AssertionError(complexType.getContentType().getKind());\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tthrow new AssertionError(elementType);\n-\t\t}\n-\t}\n-\n-\tpublic void checkForUnexpectedEndOfContent(final SchemaExceptionHandler errors) throws AbortException\n-\t{\n-\t\tif (m_suspendChecking)\n-\t\t{\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tswitch (getProcessContents())\n-\t\t{\n-\t\t\tcase Lax:\n-\t\t\t{\n-\t\t\t\t// Fall through\n-\t\t\t}\n-\t\t\tbreak;\n-\t\t\tcase Skip:\n-\t\t\t{\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t\tcase Strict:\n-\t\t\t{\n-\t\t\t\t// Fall through\n-\t\t\t}\n-\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t{\n-\t\t\t\tthrow new AssertionError(getProcessContents().name());\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (!m_nilled)\n-\t\t{\n-\t\t\t// We don't want an exception in startElement (causing a null machine) to be masked by a NPE.\n-\t\t\tif (null != m_machine)\n-\t\t\t{\n-\t\t\t\tif (!m_machine.end())\n-\t\t\t\t{\n-\t\t\t\t\terrors.error(new SmUnexpectedEndException(getName(), getLocation()));\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic ModelPSVI pop()\n-\t{\n-\t\treturn m_parentItem;\n-\t}\n-\n-\tprivate void reset(final ProcessContentsMode processContents)\n-\t{\n-\t\tm_elementDecl = null;\n-\t\tm_type = null;\n-\t\tm_machine = null;\n-\n-\t\tsetProcessContents(processContents);\n-\t\tm_suspendChecking = (null != m_parentItem) && m_parentItem.m_suspendChecking;\n-\n-\t\tm_nilled = false;\n-\t}\n-\n-\tpublic void annotate(final Type type)\n-\t{\n-\t\tm_type = PreCondition.assertArgumentNotNull(type);\n-\t\tif (type instanceof ComplexType)\n-\t\t{\n-\t\t\tfinal ComplexType complexType = (ComplexType)type;\n-\t\t\tfinal ContentTypeKind kind = complexType.getContentType().getKind();\n-\t\t\tif (kind.isComplex())\n-\t\t\t{\n-\t\t\t\tm_machine = cache.getMachine(complexType);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic ElementDefinition getDeclaration()\n-\t{\n-\t\treturn m_elementDecl;\n-\t}\n-\n-\tpublic Type getType()\n-\t{\n-\t\treturn m_type;\n-\t}\n-\n-\tpublic boolean isNilled()\n-\t{\n-\t\treturn m_nilled;\n-\t}\n-\n-\tpublic void setNilled(boolean nilled)\n-\t{\n-\t\tm_nilled = nilled;\n-\t}\n-\n-\tpublic ProcessContentsMode getProcessContents()\n-\t{\n-\t\treturn m_processContents;\n-\t}\n-\n-\tpublic void setProcessContents(final ProcessContentsMode processContents)\n-\t{\n-\t\tm_processContents = PreCondition.assertArgumentNotNull(processContents);\n-\t}\n-\n-\tpublic boolean getSuspendChecking()\n-\t{\n-\t\treturn m_suspendChecking;\n-\t}\n-\n-\tpublic static  void assignPSVI(final ModelPSVI elementItem, final Type localType, final SchemaExceptionHandler errors) throws AbortException, SchemaException\n-\t{\n-\t\tfinal SmContentFiniteStateMachine machine = elementItem.m_parentItem.m_machine;\n-\t\tif (null != machine)\n-\t\t{\n-\t\t\tif (machine.isElementMatch())\n-\t\t\t{\n-\t\t\t\telementItem.m_elementDecl = machine.getElement();\n-\t\t\t\tcheckDeclNotAbstract(elementItem.m_elementDecl, elementItem, errors);\n-\t\t\t\tfinal Type dynamicType;\n-\t\t\t\tif (null != localType)\n-\t\t\t\t{\n-\t\t\t\t\tdynamicType = localType;\n-\t\t\t\t\tcheckLocalTypeValidlyDerivedFromElementType(elementItem.m_elementDecl, localType, elementItem);\n-\t\t\t\t}\n-\t\t\t\telse\n-\t\t\t\t{\n-\t\t\t\t\tdynamicType = elementItem.m_elementDecl.getType();\n-\t\t\t\t}\n-\t\t\t\tfinal ElementDefinition substitutionGroup = elementItem.m_elementDecl.getSubstitutionGroup();\n-\t\t\t\tif (null != substitutionGroup)\n-\t\t\t\t{\n-\t\t\t\t\tcheckDeclSubstitutionsNotBlocked(elementItem.m_elementDecl, dynamicType, errors, elementItem);\n-\t\t\t\t}\n-\t\t\t\telementItem.annotate(dynamicType);\n-\t\t\t}\n-\t\t\telse\n-\t\t\t{\n-\t\t\t\t// It must be a wildcard match.\n-\t\t\t\tfinal SchemaWildcard wildcard = machine.getWildcard();\n-\t\t\t\telementItem.setProcessContents(wildcard.getProcessContents());\n-\n-\t\t\t\telementItem.recoverPSVI(localType, errors);\n-\t\t\t}\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\t// TODO: Why don't we annotate with the localType?\n-\t\t}\n-\t}\n-\n-\tpublic void recoverPSVI(final Type localType, final SchemaExceptionHandler errors) throws AbortException, SchemaException\n-\t{\n-\t\tfinal QName elementName = getName();\n-\n-\t\tswitch (getProcessContents())\n-\t\t{\n-\t\t\tcase Strict:\n-\t\t\t{\n-\t\t\t\tm_elementDecl = metaBridge.getElementDeclaration(elementName);\n-\t\t\t\tif (null != m_elementDecl)\n-\t\t\t\t{\n-\t\t\t\t\tcheckDeclNotAbstract(m_elementDecl, this, errors);\n-\t\t\t\t\tif (null != localType)\n-\t\t\t\t\t{\n-\t\t\t\t\t\tcheckLocalTypeValidlyDerivedFromElementType(m_elementDecl, localType, this);\n-\n-\t\t\t\t\t\tif (m_elementDecl.hasSubstitutionGroup())\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tcheckDeclSubstitutionsNotBlocked(m_elementDecl, localType, errors, this);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tannotate(localType);\n-\t\t\t\t\t}\n-\t\t\t\t\telse\n-\t\t\t\t\t{\n-\t\t\t\t\t\tfinal Type elementType = m_elementDecl.getType();\n-\n-\t\t\t\t\t\tif (m_elementDecl.hasSubstitutionGroup())\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tcheckDeclSubstitutionsNotBlocked(m_elementDecl, elementType, errors, this);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tannotate(elementType);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\telse\n-\t\t\t\t{\n-\t\t\t\t\tif (null != localType)\n-\t\t\t\t\t{\n-\t\t\t\t\t\tannotate(localType);\n-\t\t\t\t\t}\n-\t\t\t\t\telse\n-\t\t\t\t\t{\n-\t\t\t\t\t\terrors.error(new CvcElementDeclarationAndTypeException(elementName, getLocation()));\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tbreak;\n-\t\t\tcase Lax:\n-\t\t\t{\n-\t\t\t\tm_elementDecl = metaBridge.getElementDeclaration(elementName);\n-\t\t\t\tif (null != m_elementDecl)\n-\t\t\t\t{\n-\t\t\t\t\tcheckDeclNotAbstract(m_elementDecl, this, errors);\n-\t\t\t\t\tif (null != localType)\n-\t\t\t\t\t{\n-\t\t\t\t\t\tcheckLocalTypeValidlyDerivedFromElementType(m_elementDecl, localType, this);\n-\n-\t\t\t\t\t\tif (m_elementDecl.hasSubstitutionGroup())\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tcheckDeclSubstitutionsNotBlocked(m_elementDecl, localType, errors, this);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tannotate(localType);\n-\t\t\t\t\t}\n-\t\t\t\t\telse\n-\t\t\t\t\t{\n-\t\t\t\t\t\tfinal Type elementType = m_elementDecl.getType();\n-\n-\t\t\t\t\t\tif (m_elementDecl.hasSubstitutionGroup())\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tcheckDeclSubstitutionsNotBlocked(m_elementDecl, elementType, errors, this);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tannotate(elementType);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\telse\n-\t\t\t\t{\n-\t\t\t\t\tif (null != localType)\n-\t\t\t\t\t{\n-\t\t\t\t\t\tannotate(localType);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tbreak;\n-\t\t\tcase Skip:\n-\t\t\t{\n-\t\t\t}\n-\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t{\n-\t\t\t\tthrow new AssertionError(getProcessContents());\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate static void checkDeclNotAbstract(final ElementDefinition elementDeclaration, final Locatable locatable, final SchemaExceptionHandler errors) throws AbortException\n-\t{\n-\t\t// Check that the declaration is not abstract.\n-\t\tif (elementDeclaration.isAbstract())\n-\t\t{\n-\t\t\terrors.error(new CvcElementAbstractException(elementDeclaration, locatable.getLocation()));\n-\t\t}\n-\t}\n-\n-\tprivate static void checkDeclSubstitutionsNotBlocked(final ElementDefinition elementDeclaration, final Type elementType, final SchemaExceptionHandler errors, final Locatable locatable) throws AbortException\n-\t{\n-\t\t// Note: Substitution can be blocked by extension and restriction as well.\n-\t\tfinal ElementDefinition substitutionGroup = elementDeclaration.getSubstitutionGroup();\n-\t\tfinal Set<DerivationMethod> block = substitutionGroup.getDisallowedSubtitutions();\n-\t\tif (block.contains(DerivationMethod.Substitution))\n-\t\t{\n-\t\t\t// Substitutions are blocked outright by the substitution group declaration.\n-\t\t\terrors.error(new CvcSubstitutionBlockedByHeadDeclarationException(elementDeclaration, substitutionGroup, locatable.getLocation()));\n-\t\t}\n-\n-\t\tfinal Type headType = substitutionGroup.getType();\n-\n-\t\tif (block.contains(DerivationMethod.Extension))\n-\t\t{\n-\t\t\tif (elementType.derivedFromType(headType, EnumSet.of(DerivationMethod.Extension)))\n-\t\t\t{\n-\t\t\t\terrors.error(new CvcSubstitutionBlockedByHeadDeclarationException(elementDeclaration, substitutionGroup, locatable.getLocation()));\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (block.contains(DerivationMethod.Restriction))\n-\t\t{\n-\t\t\tif (elementType.derivedFromType(headType, EnumSet.of(DerivationMethod.Restriction)))\n-\t\t\t{\n-\t\t\t\terrors.error(new CvcSubstitutionBlockedByHeadDeclarationException(elementDeclaration, substitutionGroup, locatable.getLocation()));\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (headType instanceof ComplexType)\n-\t\t{\n-\t\t\tfinal ComplexType complexType = (ComplexType)headType;\n-\t\t\tfinal Set<DerivationMethod> prohibitedSubstitutions = complexType.getProhibitedSubstitutions();\n-\t\t\tif (prohibitedSubstitutions.contains(DerivationMethod.Substitution))\n-\t\t\t{\n-\t\t\t\tthrow new AssertionError(\"Isn't this dead code?\");\n-\t\t\t\t// Substitutions are blocked outright by the substitution group type.\n-\t\t\t\t// errors.error(new CvcSubstitutionBlockedByHeadTypeException(elementDeclaration,\n-\t\t\t\t// locatable.getLocation()));\n-\t\t\t}\n-\n-\t\t\tif (prohibitedSubstitutions.contains(DerivationMethod.Extension))\n-\t\t\t{\n-\t\t\t\tif (elementType.derivedFromType(headType, EnumSet.of(DerivationMethod.Extension)))\n-\t\t\t\t{\n-\t\t\t\t\terrors.error(new CvcSubstitutionBlockedByHeadTypeException(elementDeclaration, locatable.getLocation()));\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tif (prohibitedSubstitutions.contains(DerivationMethod.Restriction))\n-\t\t\t{\n-\t\t\t\tif (elementType.derivedFromType(headType, EnumSet.of(DerivationMethod.Restriction)))\n-\t\t\t\t{\n-\t\t\t\t\terrors.error(new CvcSubstitutionBlockedByHeadTypeException(elementDeclaration, locatable.getLocation()));\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate static void checkLocalTypeValidlyDerivedFromElementType(final ElementDefinition elementDeclaration, final Type localType, final Locatable locatable) throws CvcElementLocalTypeDerivationException\n-\t{\n-\t\tfinal Set<DerivationMethod> block = elementDeclaration.getDisallowedSubtitutions();\n-\t\tfinal Type elementType = elementDeclaration.getType();\n-\t\tif (localType instanceof SimpleType)\n-\t\t{\n-\t\t\ttry\n-\t\t\t{\n-\t\t\t\tcheckTypeDerivationOKSimple((SimpleType)localType, elementType, block);\n-\t\t\t}\n-\t\t\tcatch (final ComponentConstraintException e)\n-\t\t\t{\n-\t\t\t\tthrow new CvcElementLocalTypeDerivationException(localType, elementDeclaration, e, locatable.getLocation());\n-\t\t\t}\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tfinal Set<DerivationMethod> union = new HashSet<DerivationMethod>();\n-\n-\t\t\tunion.addAll(block);\n-\t\t\tif (elementType instanceof ComplexType)\n-\t\t\t{\n-\t\t\t\tfinal ComplexType complexType = (ComplexType)elementType;\n-\t\t\t\tunion.addAll(complexType.getProhibitedSubstitutions());\n-\t\t\t}\n-\n-\t\t\ttry\n-\t\t\t{\n-\t\t\t\tcheckTypeDerivationOKComplex(localType, elementType, union);\n-\t\t\t}\n-\t\t\tcatch (final ComponentConstraintException e)\n-\t\t\t{\n-\t\t\t\tthrow new CvcElementLocalTypeDerivationException(localType, elementDeclaration, e, locatable.getLocation());\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Type Derivation OK (Simple) (3.14.6)\n-\t */\n-\tprivate static void checkTypeDerivationOKSimple(final SimpleType D, final Type B, final Set<DerivationMethod> subset) throws ComponentConstraintException\n-\t{\n-\t\tif (D.getName().equals(B.getName()))\n-\t\t{\n-\t\t\t// They are the same type definition.\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tfinal Type deesBaseType = D.getBaseType();\n-\t\t\tif (subset.contains(DerivationMethod.Restriction) || deesBaseType.getFinal().contains(DerivationMethod.Restriction))\n-\t\t\t{\n-\t\t\t\tthrow new SccSimpleTypeDerivationRestrictionException(D.getName());\n-\t\t\t}\n-\n-\t\t\tboolean isOK = false;\n-\t\t\tif (deesBaseType.getName().equals(B.getName()))\n-\t\t\t{\n-\t\t\t\tisOK = true;\n-\t\t\t}\n-\t\t\telse if (!deesBaseType.isComplexUrType() && ModelPSVI.isTypeDerivationOK(deesBaseType, B, subset))\n-\t\t\t{\n-\t\t\t\tisOK = true;\n-\t\t\t}\n-\t\t\telse if (!D.isSimpleUrType() && (D.isListType() || D.isUnionType()) && B.isSimpleUrType())\n-\t\t\t{\n-\t\t\t\tisOK = true;\n-\t\t\t}\n-\t\t\telse if (B instanceof UnionSimpleType)\n-\t\t\t{\n-\t\t\t\tfinal UnionSimpleType unionType = (UnionSimpleType)B;\n-\t\t\t\tfor (final SimpleType memberType : unionType.getMemberTypes())\n-\t\t\t\t{\n-\t\t\t\t\tif (isTypeDerivationOK(D, memberType, subset))\n-\t\t\t\t\t{\n-\t\t\t\t\t\tisOK = true;\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tif (!isOK)\n-\t\t\t{\n-\t\t\t\tthrow new SccSimpleTypeDerivationException(D.getName());\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate static <A, S> void checkTypeDerivationOKComplex(final Type D, final Type B, final Set<DerivationMethod> subset) throws ComponentConstraintException\n-\t{\n-\t\tif (D.getName().equals(B.getName()))\n-\t\t{\n-\t\t\t// They are the same type definition.\n-\t\t}\n-\t\telse if (D.isComplexUrType())\n-\t\t{\n-\t\t\tthrow new SccComplexTypeDerivationHierarchyException(D, B, subset);\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tif (subset.contains(D.getDerivationMethod()))\n-\t\t\t{\n-\t\t\t\tthrow new SccComplexTypeDerivationMethodException(D, B, subset);\n-\t\t\t}\n-\n-\t\t\tfinal Type deeBaseType = D.getBaseType();\n-\t\t\tif (deeBaseType.getName().equals(B.getName()))\n-\t\t\t{\n-\t\t\t\t// B is D's {base type definition}\n-\t\t\t}\n-\t\t\telse\n-\t\t\t{\n-\t\t\t\tif (deeBaseType.isComplexUrType())\n-\t\t\t\t{\n-\t\t\t\t\tthrow new SccComplexTypeBaseUrTypeException(D, B, subset);\n-\t\t\t\t}\n-\t\t\t\telse\n-\t\t\t\t{\n-\t\t\t\t\tif (deeBaseType instanceof ComplexType)\n-\t\t\t\t\t{\n-\t\t\t\t\t\ttry\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tcheckTypeDerivationOK((ComplexType)deeBaseType, B, subset);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tcatch (final ComponentConstraintException e)\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tthrow new SccComplexTypeBaseComplexDerivationException(D, B, subset, e);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\telse\n-\t\t\t\t\t{\n-\t\t\t\t\t\ttry\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tcheckTypeDerivationOKSimple((SimpleType)deeBaseType, B, subset);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tcatch (final ComponentConstraintException e)\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tthrow new SccComplexTypeBaseSimpleDerivationException(D, B, subset, e);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate static void checkTypeDerivationOK(final Type D, final Type B, final Set<DerivationMethod> subset) throws ComponentConstraintException\n-\t{\n-\t\tif (D instanceof SimpleType)\n-\t\t{\n-\t\t\tcheckTypeDerivationOKSimple((SimpleType)D, B, subset);\n-\t\t}\n-\t\telse if (D instanceof ComplexType)\n-\t\t{\n-\t\t\tcheckTypeDerivationOKComplex(D, B, subset);\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tthrow new AssertionError(D);\n-\t\t}\n-\t}\n-\n-\tprivate static boolean isTypeDerivationOK(final Type D, final Type B, final Set<DerivationMethod> subset)\n-\t{\n-\t\ttry\n-\t\t{\n-\t\t\tcheckTypeDerivationOK(D, B, subset);\n-\t\t}\n-\t\tcatch (final SchemaException e)\n-\t\t{\n-\t\t\treturn false;\n-\t\t}\n-\t\treturn true;\n-\t}\n+final class ModelPSVI implements VxPSVI, Locatable {\n+    private ModelPSVI m_parentItem;\n+\n+    public ModelPSVI getParent() {\n+        return m_parentItem;\n+    }\n+\n+    private final ValidationCache cache;\n+\n+    private final ComponentProvider metaBridge;\n+\n+    private ModelPSVI m_childItem; // for recycling\n+\n+    private final NodeKind m_nodeKind;\n+\n+    // The name of the element information item.\n+    private QName m_elementName;\n+\n+    public QName getName() {\n+        return m_elementName;\n+    }\n+\n+    private int m_lineNumber;\n+\n+    private int m_columnNumber;\n+\n+    private int m_characterOffset;\n+\n+    private String m_publicId;\n+\n+    private String m_systemId;\n+\n+    public LocationInSchema getLocation() {\n+        return new SrcFrozenLocation(m_lineNumber, m_columnNumber, m_characterOffset, m_publicId,\n+            m_systemId);\n+    }\n+\n+    private Type m_type;\n+\n+    private SmContentFiniteStateMachine m_machine;\n+\n+    private ProcessContentsMode m_processContents;\n+\n+    // The XML Schema specification does not specify what a validating processor should do after\n+    // it encounters an error. It is not obliged to report more than the first error.\n+    private boolean m_suspendChecking;\n+\n+    private ElementDefinition m_elementDecl;\n+\n+    // Did the instance use xsi:nil=\"true\"?\n+    private boolean m_nilled;\n+\n+    /**\n+     * Identity scopes may exist for an element information item.\n+     */\n+    public final ArrayList<IdentityScope> m_identityScopes = new ArrayList<IdentityScope>();\n+\n+    public final HashMap<IdentityConstraint, IdentityScope> m_keyScopes =\n+        new HashMap<IdentityConstraint, IdentityScope>();\n+\n+    private ModelPSVI(final ModelPSVI parent, final NodeKind nodeKind,\n+                      final ProcessContentsMode processContents, final ComponentProvider metaBridge,\n+                      final ValidationCache cache) {\n+        this.m_parentItem = parent;\n+        this.m_nodeKind = PreCondition.assertArgumentNotNull(nodeKind, \"nodeKind\");\n+        this.metaBridge = PreCondition.assertArgumentNotNull(metaBridge, \"metaBridge\");\n+        this.cache = PreCondition.assertArgumentNotNull(cache, \"cache\");\n+        reset(processContents);\n+    }\n+\n+    public ModelPSVI(final ProcessContentsMode processContents, final ComponentProvider metaBridge,\n+                     final ValidationCache cache) {\n+        this(null, NodeKind.DOCUMENT, processContents, metaBridge, cache);\n+    }\n+\n+    public ModelPSVI push(final QName elementName) {\n+        if (m_childItem == null) {\n+            m_childItem =\n+                new ModelPSVI(this, NodeKind.ELEMENT, getProcessContents(), this.metaBridge,\n+                    this.cache);\n+        } else {\n+            m_childItem.reset(getProcessContents());\n+        }\n+        m_childItem.m_elementName = PreCondition.assertArgumentNotNull(elementName, \"elementName\");\n+\n+        // TODO: Need to get the element location.\n+        m_childItem.m_lineNumber = -1;\n+        m_childItem.m_columnNumber = -1;\n+        m_childItem.m_characterOffset = -1;\n+        m_childItem.m_publicId = null;\n+        m_childItem.m_systemId = null;\n+\n+        return m_childItem;\n+    }\n+\n+    public boolean declExists() {\n+        return (null != m_elementDecl);\n+    }\n+\n+    /**\n+     * Computes the {nilled} property for the element information item by checking the interaction of the xsi:nil and\n+     * the {nillable} property of the element declaration.\n+     */\n+    public boolean computeNilled(final Boolean explicitNil, final SchemaExceptionHandler errors)\n+        throws AbortException {\n+        if (null != explicitNil) {\n+            if (null != m_elementDecl) {\n+                if (m_elementDecl.isNillable()) {\n+                    if (explicitNil) {\n+                        final ValueConstraint valueConstraint = m_elementDecl.getValueConstraint();\n+                        if (null != valueConstraint && valueConstraint.getVariety().isFixed()) {\n+                            errors.error(new CvcElementFixedAndNilledException(m_elementDecl,\n+                                getLocation()));\n+                        }\n+                    }\n+                } else {\n+                    errors.error(new CvcElementNotNillableException(m_elementDecl, getLocation()));\n+                }\n+            }\n+            return explicitNil;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    public boolean step(final QName childName, final Locatable childLocatable,\n+                        final SchemaExceptionHandler errors) throws AbortException {\n+        final Type elementType = getType();\n+        if (null == elementType) {\n+            // TODO: We should really see if locally valid wrt to type has been flagged.\n+            // Do nothing if there is no type annotation.\n+            return false;\n+        }\n+\n+        if (elementType instanceof SimpleType) {\n+            // TODO: Do we include the xs:anySimpleType (simple ur-type)?\n+            errors.error(new CvcElementInSimpleTypeException(getName(), getLocation(), childName,\n+                childLocatable.getLocation()));\n+            return false;\n+        } else if (elementType instanceof ComplexType) {\n+            final ComplexType complexType = (ComplexType) elementType;\n+            if (m_suspendChecking) {\n+                return false;\n+            }\n+\n+            switch (getProcessContents()) {\n+                case Lax: {\n+                    // Fall through\n+                }\n+                break;\n+                case Skip: {\n+                    return false;\n+                }\n+                case Strict: {\n+                    // Fall through\n+                }\n+                break;\n+                default: {\n+                    throw new AssertionError(getProcessContents().name());\n+                }\n+            }\n+            if (m_nilled && (null != m_elementDecl)) {\n+                errors.error(new CvcElementUnexpectedChildInNilledElementException(m_elementDecl,\n+                    getLocation()));\n+                return false;\n+            }\n+            switch (complexType.getContentType().getKind()) {\n+                case Empty: {\n+                    errors.error(\n+                        new CvcElementInEmptyContentException(getName(), getLocation(), childName,\n+                            childLocatable.getLocation()));\n+                    return false;\n+                }\n+                case Simple: {\n+                    errors.error(\n+                        new CvcElementInSimpleContentTypeException(getName(), getLocation(),\n+                            childName, childLocatable.getLocation()));\n+                    return false;\n+                }\n+                case ElementOnly:\n+                case Mixed: {\n+                    switch (m_nodeKind) {\n+                        case ELEMENT: {\n+                            if (null != m_machine) {\n+                                if (m_machine.step(childName)) {\n+                                    return true;\n+                                } else {\n+                                    errors.error(\n+                                        new SmUnexpectedElementException(getName(), getLocation(),\n+                                            childName, childLocatable.getLocation()));\n+                                    m_suspendChecking = true;\n+                                    return false;\n+                                }\n+                            } else {\n+                                switch (getProcessContents()) {\n+                                    case Strict: {\n+                                        errors.error(new SmUnexpectedElementException(getName(),\n+                                            getLocation(), childName,\n+                                            childLocatable.getLocation()));\n+                                        m_suspendChecking = true;\n+                                    }\n+                                    default: {\n+                                    }\n+                                }\n+                                return false;\n+                            }\n+                        }\n+                        case DOCUMENT: {\n+                            return false;\n+                        }\n+                        default: {\n+                            throw new AssertionError(m_nodeKind);\n+                        }\n+                    }\n+                }\n+                default: {\n+                    throw new AssertionError(complexType.getContentType().getKind());\n+                }\n+            }\n+        } else {\n+            throw new AssertionError(elementType);\n+        }\n+    }\n+\n+    public void checkForUnexpectedEndOfContent(final SchemaExceptionHandler errors)\n+        throws AbortException {\n+        if (m_suspendChecking) {\n+            return;\n+        }\n+\n+        switch (getProcessContents()) {\n+            case Lax: {\n+                // Fall through\n+            }\n+            break;\n+            case Skip: {\n+                return;\n+            }\n+            case Strict: {\n+                // Fall through\n+            }\n+            break;\n+            default: {\n+                throw new AssertionError(getProcessContents().name());\n+            }\n+        }\n+\n+        if (!m_nilled) {\n+            // We don't want an exception in startElement (causing a null machine) to be masked by a NPE.\n+            if (null != m_machine) {\n+                if (!m_machine.end()) {\n+                    errors.error(new SmUnexpectedEndException(getName(), getLocation()));\n+                }\n+            }\n+        }\n+    }\n+\n+    public ModelPSVI pop() {\n+        return m_parentItem;\n+    }\n+\n+    private void reset(final ProcessContentsMode processContents) {\n+        m_elementDecl = null;\n+        m_type = null;\n+        m_machine = null;\n+\n+        setProcessContents(processContents);\n+        m_suspendChecking = (null != m_parentItem) && m_parentItem.m_suspendChecking;\n+\n+        m_nilled = false;\n+    }\n+\n+    public void annotate(final Type type) {\n+        m_type = PreCondition.assertArgumentNotNull(type);\n+        if (type instanceof ComplexType) {\n+            final ComplexType complexType = (ComplexType) type;\n+            final ContentTypeKind kind = complexType.getContentType().getKind();\n+            if (kind.isComplex()) {\n+                m_machine = cache.getMachine(complexType);\n+            }\n+        }\n+    }\n+\n+    public ElementDefinition getDeclaration() {\n+        return m_elementDecl;\n+    }\n+\n+    public Type getType() {\n+        return m_type;\n+    }\n+\n+    public boolean isNilled() {\n+        return m_nilled;\n+    }\n+\n+    public void setNilled(boolean nilled) {\n+        m_nilled = nilled;\n+    }\n+\n+    public ProcessContentsMode getProcessContents() {\n+        return m_processContents;\n+    }\n+\n+    public void setProcessContents(final ProcessContentsMode processContents) {\n+        m_processContents = PreCondition.assertArgumentNotNull(processContents);\n+    }\n+\n+    public boolean getSuspendChecking() {\n+        return m_suspendChecking;\n+    }\n+\n+    public static void assignPSVI(final ModelPSVI elementItem, final Type localType,\n+                                  final SchemaExceptionHandler errors)\n+        throws AbortException, SchemaException {\n+        final SmContentFiniteStateMachine machine = elementItem.m_parentItem.m_machine;\n+        if (null != machine) {\n+            if (machine.isElementMatch()) {\n+                elementItem.m_elementDecl = machine.getElement();\n+                checkDeclNotAbstract(elementItem.m_elementDecl, elementItem, errors);\n+                final Type dynamicType;\n+                if (null != localType) {\n+                    dynamicType = localType;\n+                    checkLocalTypeValidlyDerivedFromElementType(elementItem.m_elementDecl,\n+                        localType, elementItem);\n+                } else {\n+                    dynamicType = elementItem.m_elementDecl.getType();\n+                }\n+                final ElementDefinition substitutionGroup =\n+                    elementItem.m_elementDecl.getSubstitutionGroup();\n+                if (null != substitutionGroup) {\n+                    checkDeclSubstitutionsNotBlocked(elementItem.m_elementDecl, dynamicType, errors,\n+                        elementItem);\n+                }\n+                elementItem.annotate(dynamicType);\n+            } else {\n+                // It must be a wildcard match.\n+                final SchemaWildcard wildcard = machine.getWildcard();\n+                elementItem.setProcessContents(wildcard.getProcessContents());\n+\n+                elementItem.recoverPSVI(localType, errors);\n+            }\n+        } else {\n+            // TODO: Why don't we annotate with the localType?\n+        }\n+    }\n+\n+    public void recoverPSVI(final Type localType, final SchemaExceptionHandler errors)\n+        throws AbortException, SchemaException {\n+        final QName elementName = getName();\n+\n+        switch (getProcessContents()) {\n+            case Strict: {\n+                m_elementDecl = metaBridge.getElementDeclaration(elementName);\n+                if (null != m_elementDecl) {\n+                    checkDeclNotAbstract(m_elementDecl, this, errors);\n+                    if (null != localType) {\n+                        checkLocalTypeValidlyDerivedFromElementType(m_elementDecl, localType, this);\n+\n+                        if (m_elementDecl.hasSubstitutionGroup()) {\n+                            checkDeclSubstitutionsNotBlocked(m_elementDecl, localType, errors,\n+                                this);\n+                        }\n+                        annotate(localType);\n+                    } else {\n+                        final Type elementType = m_elementDecl.getType();\n+\n+                        if (m_elementDecl.hasSubstitutionGroup()) {\n+                            checkDeclSubstitutionsNotBlocked(m_elementDecl, elementType, errors,\n+                                this);\n+                        }\n+                        annotate(elementType);\n+                    }\n+                } else {\n+                    if (null != localType) {\n+                        annotate(localType);\n+                    } else {\n+                        errors.error(\n+                            new CvcElementDeclarationAndTypeException(elementName, getLocation()));\n+                    }\n+                }\n+            }\n+            break;\n+            case Lax: {\n+                m_elementDecl = metaBridge.getElementDeclaration(elementName);\n+                if (null != m_elementDecl) {\n+                    checkDeclNotAbstract(m_elementDecl, this, errors);\n+                    if (null != localType) {\n+                        checkLocalTypeValidlyDerivedFromElementType(m_elementDecl, localType, this);\n+\n+                        if (m_elementDecl.hasSubstitutionGroup()) {\n+                            checkDeclSubstitutionsNotBlocked(m_elementDecl, localType, errors,\n+                                this);\n+                        }\n+                        annotate(localType);\n+                    } else {\n+                        final Type elementType = m_elementDecl.getType();\n+\n+                        if (m_elementDecl.hasSubstitutionGroup()) {\n+                            checkDeclSubstitutionsNotBlocked(m_elementDecl, elementType, errors,\n+                                this);\n+                        }\n+                        annotate(elementType);\n+                    }\n+                } else {\n+                    if (null != localType) {\n+                        annotate(localType);\n+                    }\n+                }\n+            }\n+            break;\n+            case Skip: {\n+            }\n+            break;\n+            default: {\n+                throw new AssertionError(getProcessContents());\n+            }\n+        }\n+    }\n+\n+    private static void checkDeclNotAbstract(final ElementDefinition elementDeclaration,\n+                                             final Locatable locatable,\n+                                             final SchemaExceptionHandler errors)\n+        throws AbortException {\n+        // Check that the declaration is not abstract.\n+        if (elementDeclaration.isAbstract()) {\n+            errors.error(\n+                new CvcElementAbstractException(elementDeclaration, locatable.getLocation()));\n+        }\n+    }\n+\n+    private static void checkDeclSubstitutionsNotBlocked(final ElementDefinition elementDeclaration,\n+                                                         final Type elementType,\n+                                                         final SchemaExceptionHandler errors,\n+                                                         final Locatable locatable)\n+        throws AbortException {\n+        // Note: Substitution can be blocked by extension and restriction as well.\n+        final ElementDefinition substitutionGroup = elementDeclaration.getSubstitutionGroup();\n+        final Set<DerivationMethod> block = substitutionGroup.getDisallowedSubtitutions();\n+        if (block.contains(DerivationMethod.Substitution)) {\n+            // Substitutions are blocked outright by the substitution group declaration.\n+            errors.error(new CvcSubstitutionBlockedByHeadDeclarationException(elementDeclaration,\n+                substitutionGroup, locatable.getLocation()));\n+        }\n+\n+        final Type headType = substitutionGroup.getType();\n+\n+        if (block.contains(DerivationMethod.Extension)) {\n+            if (elementType.derivedFromType(headType, EnumSet.of(DerivationMethod.Extension))) {\n+                errors.error(\n+                    new CvcSubstitutionBlockedByHeadDeclarationException(elementDeclaration,\n+                        substitutionGroup, locatable.getLocation()));\n+            }\n+        }\n+\n+        if (block.contains(DerivationMethod.Restriction)) {\n+            if (elementType.derivedFromType(headType, EnumSet.of(DerivationMethod.Restriction))) {\n+                errors.error(\n+                    new CvcSubstitutionBlockedByHeadDeclarationException(elementDeclaration,\n+                        substitutionGroup, locatable.getLocation()));\n+            }\n+        }\n+\n+        if (headType instanceof ComplexType) {\n+            final ComplexType complexType = (ComplexType) headType;\n+            final Set<DerivationMethod> prohibitedSubstitutions =\n+                complexType.getProhibitedSubstitutions();\n+            if (prohibitedSubstitutions.contains(DerivationMethod.Substitution)) {\n+                throw new AssertionError(\"Isn't this dead code?\");\n+                // Substitutions are blocked outright by the substitution group type.\n+                // errors.error(new CvcSubstitutionBlockedByHeadTypeException(elementDeclaration,\n+                // locatable.getLocation()));\n+            }\n+\n+            if (prohibitedSubstitutions.contains(DerivationMethod.Extension)) {\n+                if (elementType.derivedFromType(headType, EnumSet.of(DerivationMethod.Extension))) {\n+                    errors.error(new CvcSubstitutionBlockedByHeadTypeException(elementDeclaration,\n+                        locatable.getLocation()));\n+                }\n+            }\n+\n+            if (prohibitedSubstitutions.contains(DerivationMethod.Restriction)) {\n+                if (elementType\n+                    .derivedFromType(headType, EnumSet.of(DerivationMethod.Restriction))) {\n+                    errors.error(new CvcSubstitutionBlockedByHeadTypeException(elementDeclaration,\n+                        locatable.getLocation()));\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void checkLocalTypeValidlyDerivedFromElementType(\n+        final ElementDefinition elementDeclaration, final Type localType, final Locatable locatable)\n+        throws CvcElementLocalTypeDerivationException {\n+        final Set<DerivationMethod> block = elementDeclaration.getDisallowedSubtitutions();\n+        final Type elementType = elementDeclaration.getType();\n+        if (localType instanceof SimpleType) {\n+            try {\n+                checkTypeDerivationOKSimple((SimpleType) localType, elementType, block);\n+            } catch (final ComponentConstraintException e) {\n+                throw new CvcElementLocalTypeDerivationException(localType, elementDeclaration, e,\n+                    locatable.getLocation());\n+            }\n+        } else {\n+            final Set<DerivationMethod> union = new HashSet<DerivationMethod>();\n+\n+            union.addAll(block);\n+            if (elementType instanceof ComplexType) {\n+                final ComplexType complexType = (ComplexType) elementType;\n+                union.addAll(complexType.getProhibitedSubstitutions());\n+            }\n+\n+            try {\n+                checkTypeDerivationOKComplex(localType, elementType, union);\n+            } catch (final ComponentConstraintException e) {\n+                throw new CvcElementLocalTypeDerivationException(localType, elementDeclaration, e,\n+                    locatable.getLocation());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Type Derivation OK (Simple) (3.14.6)\n+     */\n+    private static void checkTypeDerivationOKSimple(final SimpleType D, final Type B,\n+                                                    final Set<DerivationMethod> subset)\n+        throws ComponentConstraintException {\n+        if (D.getName().equals(B.getName())) {\n+            // They are the same type definition.\n+        } else {\n+            final Type deesBaseType = D.getBaseType();\n+            if (subset.contains(DerivationMethod.Restriction) ||\n+                deesBaseType.getFinal().contains(DerivationMethod.Restriction)) {\n+                throw new SccSimpleTypeDerivationRestrictionException(D.getName());\n+            }\n+\n+            boolean isOK = false;\n+            if (deesBaseType.getName().equals(B.getName())) {\n+                isOK = true;\n+            } else if (!deesBaseType.isComplexUrType() &&\n+                ModelPSVI.isTypeDerivationOK(deesBaseType, B, subset)) {\n+                isOK = true;\n+            } else if (!D.isSimpleUrType() && (D.isListType() || D.isUnionType()) &&\n+                B.isSimpleUrType()) {\n+                isOK = true;\n+            } else if (B instanceof UnionSimpleType) {\n+                final UnionSimpleType unionType = (UnionSimpleType) B;\n+                for (final SimpleType memberType : unionType.getMemberTypes()) {\n+                    if (isTypeDerivationOK(D, memberType, subset)) {\n+                        isOK = true;\n+                        break;\n+                    }\n+                }\n+            }\n+            if (!isOK) {\n+                throw new SccSimpleTypeDerivationException(D.getName());\n+            }\n+        }\n+    }\n+\n+    private static <A, S> void checkTypeDerivationOKComplex(final Type D, final Type B,\n+                                                            final Set<DerivationMethod> subset)\n+        throws ComponentConstraintException {\n+        if (D.getName().equals(B.getName())) {\n+            // They are the same type definition.\n+        } else if (D.isComplexUrType()) {\n+            throw new SccComplexTypeDerivationHierarchyException(D, B, subset);\n+        } else {\n+            if (subset.contains(D.getDerivationMethod())) {\n+                throw new SccComplexTypeDerivationMethodException(D, B, subset);\n+            }\n+\n+            final Type deeBaseType = D.getBaseType();\n+            if (deeBaseType.getName().equals(B.getName())) {\n+                // B is D's {base type definition}\n+            } else {\n+                if (deeBaseType.isComplexUrType()) {\n+                    throw new SccComplexTypeBaseUrTypeException(D, B, subset);\n+                } else {\n+                    if (deeBaseType instanceof ComplexType) {\n+                        try {\n+                            checkTypeDerivationOK((ComplexType) deeBaseType, B, subset);\n+                        } catch (final ComponentConstraintException e) {\n+                            throw new SccComplexTypeBaseComplexDerivationException(D, B, subset, e);\n+                        }\n+                    } else {\n+                        try {\n+                            checkTypeDerivationOKSimple((SimpleType) deeBaseType, B, subset);\n+                        } catch (final ComponentConstraintException e) {\n+                            throw new SccComplexTypeBaseSimpleDerivationException(D, B, subset, e);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void checkTypeDerivationOK(final Type D, final Type B,\n+                                              final Set<DerivationMethod> subset)\n+        throws ComponentConstraintException {\n+        if (D instanceof SimpleType) {\n+            checkTypeDerivationOKSimple((SimpleType) D, B, subset);\n+        } else if (D instanceof ComplexType) {\n+            checkTypeDerivationOKComplex(D, B, subset);\n+        } else {\n+            throw new AssertionError(D);\n+        }\n+    }\n+\n+    private static boolean isTypeDerivationOK(final Type D, final Type B,\n+                                              final Set<DerivationMethod> subset) {\n+        try {\n+            checkTypeDerivationOK(D, B, subset);\n+        } catch (final SchemaException e) {\n+            return false;\n+        }\n+        return true;\n+    }\n }\n",
            "diff_size": 736
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/368/ModelPSVI.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/codebuff/368/ModelPSVI.java\nindex 2477f43087b..331537f504b 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/368/ModelPSVI.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/codebuff/368/ModelPSVI.java\n@@ -20,9 +20,7 @@ import java.util.EnumSet;\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.Set;\n-\n import javax.xml.namespace.QName;\n-\n import org.genxdm.NodeKind;\n import org.genxdm.exceptions.PreCondition;\n import org.genxdm.processor.w3c.xs.exception.cvc.CvcElementAbstractException;\n@@ -72,735 +70,734 @@ import org.genxdm.xs.types.UnionSimpleType;\n  * child pointers and supply push and pop methods. Also note that the objects are recycled by the push method using the\n  * child pointer.\n  */\n+\n final class ModelPSVI implements VxPSVI, Locatable\n {\n-\tprivate ModelPSVI m_parentItem;\n-\n-\tpublic ModelPSVI getParent()\n-\t{\n-\t\treturn m_parentItem;\n-\t}\n-\n-\tprivate final ValidationCache cache;\n-\tprivate final ComponentProvider metaBridge;\n-\n-\tprivate ModelPSVI m_childItem; // for recycling\n-\n-\tprivate final NodeKind m_nodeKind;\n-\n-\t// The name of the element information item.\n-\tprivate QName m_elementName;\n-\n-\tpublic QName getName()\n-\t{\n-\t\treturn m_elementName;\n-\t}\n-\n-\tprivate int m_lineNumber;\n-\tprivate int m_columnNumber;\n-\tprivate int m_characterOffset;\n-\tprivate String m_publicId;\n-\tprivate String m_systemId;\n-\n-\tpublic LocationInSchema getLocation()\n-\t{\n-\t\treturn new SrcFrozenLocation(m_lineNumber, m_columnNumber, m_characterOffset, m_publicId, m_systemId);\n-\t}\n-\n-\tprivate Type m_type;\n-\tprivate SmContentFiniteStateMachine m_machine;\n-\n-\tprivate ProcessContentsMode m_processContents;\n-\n-\t// The XML Schema specification does not specify what a validating processor should do after\n-\t// it encounters an error. It is not obliged to report more than the first error.\n-\tprivate boolean m_suspendChecking;\n-\n-\tprivate ElementDefinition m_elementDecl;\n-\n-\t// Did the instance use xsi:nil=\"true\"?\n-\tprivate boolean m_nilled;\n-\n-\t/**\n-\t * Identity scopes may exist for an element information item.\n-\t */\n-\tpublic final ArrayList<IdentityScope> m_identityScopes = new ArrayList<IdentityScope>();\n-\tpublic final HashMap<IdentityConstraint, IdentityScope> m_keyScopes = new HashMap<IdentityConstraint, IdentityScope>();\n-\n-\tprivate ModelPSVI(final ModelPSVI parent, final NodeKind nodeKind, final ProcessContentsMode processContents, final ComponentProvider metaBridge, final ValidationCache cache)\n-\t{\n-\t\tthis.m_parentItem = parent;\n-\t\tthis.m_nodeKind = PreCondition.assertArgumentNotNull(nodeKind, \"nodeKind\");\n-\t\tthis.metaBridge = PreCondition.assertArgumentNotNull(metaBridge, \"metaBridge\");\n-\t\tthis.cache = PreCondition.assertArgumentNotNull(cache, \"cache\");\n-\t\treset(processContents);\n-\t}\n-\n-\tpublic ModelPSVI(final ProcessContentsMode processContents, final ComponentProvider metaBridge, final ValidationCache cache)\n-\t{\n-\t\tthis(null, NodeKind.DOCUMENT, processContents, metaBridge, cache);\n-\t}\n-\n-\tpublic ModelPSVI push(final QName elementName)\n-\t{\n-\t\tif (m_childItem == null)\n-\t\t{\n-\t\t\tm_childItem = new ModelPSVI(this, NodeKind.ELEMENT, getProcessContents(), this.metaBridge, this.cache);\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tm_childItem.reset(getProcessContents());\n-\t\t}\n-\t\tm_childItem.m_elementName = PreCondition.assertArgumentNotNull(elementName, \"elementName\");\n-\n-\t\t// TODO: Need to get the element location.\n-\t\tm_childItem.m_lineNumber = -1;\n-\t\tm_childItem.m_columnNumber = -1;\n-\t\tm_childItem.m_characterOffset = -1;\n-\t\tm_childItem.m_publicId = null;\n-\t\tm_childItem.m_systemId = null;\n-\n-\t\treturn m_childItem;\n-\t}\n-\n-\tpublic boolean declExists()\n-\t{\n-\t\treturn (null != m_elementDecl);\n-\t}\n-\n-\t/**\n-\t * Computes the {nilled} property for the element information item by checking the interaction of the xsi:nil and\n-\t * the {nillable} property of the element declaration.\n-\t */\n-\tpublic boolean computeNilled(final Boolean explicitNil, final SchemaExceptionHandler errors) throws AbortException\n-\t{\n-\t\tif (null != explicitNil)\n-\t\t{\n-\t\t\tif (null != m_elementDecl)\n-\t\t\t{\n-\t\t\t\tif (m_elementDecl.isNillable())\n-\t\t\t\t{\n-\t\t\t\t\tif (explicitNil)\n-\t\t\t\t\t{\n-\t\t\t\t\t\tfinal ValueConstraint valueConstraint = m_elementDecl.getValueConstraint();\n-\t\t\t\t\t\tif (null != valueConstraint && valueConstraint.getVariety().isFixed())\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\terrors.error(new CvcElementFixedAndNilledException(m_elementDecl, getLocation()));\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\telse\n-\t\t\t\t{\n-\t\t\t\t\terrors.error(new CvcElementNotNillableException(m_elementDecl, getLocation()));\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\treturn explicitNil;\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\treturn false;\n-\t\t}\n-\t}\n-\n-\tpublic boolean step(final QName childName, final Locatable childLocatable, final SchemaExceptionHandler errors) throws AbortException\n-\t{\n-\t\tfinal Type elementType = getType();\n-\t\tif (null == elementType)\n-\t\t{\n-\t\t\t// TODO: We should really see if locally valid wrt to type has been flagged.\n-\t\t\t// Do nothing if there is no type annotation.\n-\t\t\treturn false;\n-\t\t}\n-\n-\t\tif (elementType instanceof SimpleType)\n-\t\t{\n-\t\t\t// TODO: Do we include the xs:anySimpleType (simple ur-type)?\n-\t\t\terrors.error(new CvcElementInSimpleTypeException(getName(), getLocation(), childName, childLocatable.getLocation()));\n-\t\t\treturn false;\n-\t\t}\n-\t\telse if (elementType instanceof ComplexType)\n-\t\t{\n-\t\t\tfinal ComplexType complexType = (ComplexType)elementType;\n-\t\t\tif (m_suspendChecking)\n-\t\t\t{\n-\t\t\t\treturn false;\n-\t\t\t}\n-\n-\t\t\tswitch (getProcessContents())\n-\t\t\t{\n-\t\t\t\tcase Lax:\n-\t\t\t\t{\n-\t\t\t\t\t// Fall through\n-\t\t\t\t}\n-\t\t\t\tbreak;\n-\t\t\t\tcase Skip:\n-\t\t\t\t{\n-\t\t\t\t\treturn false;\n-\t\t\t\t}\n-\t\t\t\tcase Strict:\n-\t\t\t\t{\n-\t\t\t\t\t// Fall through\n-\t\t\t\t}\n-\t\t\t\tbreak;\n-\t\t\t\tdefault:\n-\t\t\t\t{\n-\t\t\t\t\tthrow new AssertionError(getProcessContents().name());\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tif (m_nilled && (null != m_elementDecl))\n-\t\t\t{\n-\t\t\t\terrors.error(new CvcElementUnexpectedChildInNilledElementException(m_elementDecl, getLocation()));\n-\t\t\t\treturn false;\n-\t\t\t}\n-\t\t\tswitch (complexType.getContentType().getKind())\n-\t\t\t{\n-\t\t\t\tcase Empty:\n-\t\t\t\t{\n-\t\t\t\t\terrors.error(new CvcElementInEmptyContentException(getName(), getLocation(), childName, childLocatable.getLocation()));\n-\t\t\t\t\treturn false;\n-\t\t\t\t}\n-\t\t\t\tcase Simple:\n-\t\t\t\t{\n-\t\t\t\t\terrors.error(new CvcElementInSimpleContentTypeException(getName(), getLocation(), childName, childLocatable.getLocation()));\n-\t\t\t\t\treturn false;\n-\t\t\t\t}\n-\t\t\t\tcase ElementOnly:\n-\t\t\t\tcase Mixed:\n-\t\t\t\t{\n-\t\t\t\t\tswitch (m_nodeKind)\n-\t\t\t\t\t{\n-\t\t\t\t\t\tcase ELEMENT:\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tif (null != m_machine)\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tif (m_machine.step(childName))\n-\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\treturn true;\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\telse\n-\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\terrors.error(new SmUnexpectedElementException(getName(), getLocation(), childName, childLocatable.getLocation()));\n-\t\t\t\t\t\t\t\t\tm_suspendChecking = true;\n-\t\t\t\t\t\t\t\t\treturn false;\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\telse\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tswitch (getProcessContents())\n-\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\tcase Strict:\n-\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\terrors.error(new SmUnexpectedElementException(getName(), getLocation(), childName, childLocatable.getLocation()));\n-\t\t\t\t\t\t\t\t\t\tm_suspendChecking = true;\n-\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\tdefault:\n-\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\treturn false;\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tcase DOCUMENT:\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\treturn false;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tdefault:\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tthrow new AssertionError(m_nodeKind);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tdefault:\n-\t\t\t\t{\n-\t\t\t\t\tthrow new AssertionError(complexType.getContentType().getKind());\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tthrow new AssertionError(elementType);\n-\t\t}\n-\t}\n-\n-\tpublic void checkForUnexpectedEndOfContent(final SchemaExceptionHandler errors) throws AbortException\n-\t{\n-\t\tif (m_suspendChecking)\n-\t\t{\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tswitch (getProcessContents())\n-\t\t{\n-\t\t\tcase Lax:\n-\t\t\t{\n-\t\t\t\t// Fall through\n-\t\t\t}\n-\t\t\tbreak;\n-\t\t\tcase Skip:\n-\t\t\t{\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t\tcase Strict:\n-\t\t\t{\n-\t\t\t\t// Fall through\n-\t\t\t}\n-\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t{\n-\t\t\t\tthrow new AssertionError(getProcessContents().name());\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (!m_nilled)\n-\t\t{\n-\t\t\t// We don't want an exception in startElement (causing a null machine) to be masked by a NPE.\n-\t\t\tif (null != m_machine)\n-\t\t\t{\n-\t\t\t\tif (!m_machine.end())\n-\t\t\t\t{\n-\t\t\t\t\terrors.error(new SmUnexpectedEndException(getName(), getLocation()));\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic ModelPSVI pop()\n-\t{\n-\t\treturn m_parentItem;\n-\t}\n-\n-\tprivate void reset(final ProcessContentsMode processContents)\n-\t{\n-\t\tm_elementDecl = null;\n-\t\tm_type = null;\n-\t\tm_machine = null;\n-\n-\t\tsetProcessContents(processContents);\n-\t\tm_suspendChecking = (null != m_parentItem) && m_parentItem.m_suspendChecking;\n-\n-\t\tm_nilled = false;\n-\t}\n-\n-\tpublic void annotate(final Type type)\n-\t{\n-\t\tm_type = PreCondition.assertArgumentNotNull(type);\n-\t\tif (type instanceof ComplexType)\n-\t\t{\n-\t\t\tfinal ComplexType complexType = (ComplexType)type;\n-\t\t\tfinal ContentTypeKind kind = complexType.getContentType().getKind();\n-\t\t\tif (kind.isComplex())\n-\t\t\t{\n-\t\t\t\tm_machine = cache.getMachine(complexType);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic ElementDefinition getDeclaration()\n-\t{\n-\t\treturn m_elementDecl;\n-\t}\n-\n-\tpublic Type getType()\n-\t{\n-\t\treturn m_type;\n-\t}\n-\n-\tpublic boolean isNilled()\n-\t{\n-\t\treturn m_nilled;\n-\t}\n-\n-\tpublic void setNilled(boolean nilled)\n-\t{\n-\t\tm_nilled = nilled;\n-\t}\n-\n-\tpublic ProcessContentsMode getProcessContents()\n-\t{\n-\t\treturn m_processContents;\n-\t}\n-\n-\tpublic void setProcessContents(final ProcessContentsMode processContents)\n-\t{\n-\t\tm_processContents = PreCondition.assertArgumentNotNull(processContents);\n-\t}\n-\n-\tpublic boolean getSuspendChecking()\n-\t{\n-\t\treturn m_suspendChecking;\n-\t}\n-\n-\tpublic static  void assignPSVI(final ModelPSVI elementItem, final Type localType, final SchemaExceptionHandler errors) throws AbortException, SchemaException\n-\t{\n-\t\tfinal SmContentFiniteStateMachine machine = elementItem.m_parentItem.m_machine;\n-\t\tif (null != machine)\n-\t\t{\n-\t\t\tif (machine.isElementMatch())\n-\t\t\t{\n-\t\t\t\telementItem.m_elementDecl = machine.getElement();\n-\t\t\t\tcheckDeclNotAbstract(elementItem.m_elementDecl, elementItem, errors);\n-\t\t\t\tfinal Type dynamicType;\n-\t\t\t\tif (null != localType)\n-\t\t\t\t{\n-\t\t\t\t\tdynamicType = localType;\n-\t\t\t\t\tcheckLocalTypeValidlyDerivedFromElementType(elementItem.m_elementDecl, localType, elementItem);\n-\t\t\t\t}\n-\t\t\t\telse\n-\t\t\t\t{\n-\t\t\t\t\tdynamicType = elementItem.m_elementDecl.getType();\n-\t\t\t\t}\n-\t\t\t\tfinal ElementDefinition substitutionGroup = elementItem.m_elementDecl.getSubstitutionGroup();\n-\t\t\t\tif (null != substitutionGroup)\n-\t\t\t\t{\n-\t\t\t\t\tcheckDeclSubstitutionsNotBlocked(elementItem.m_elementDecl, dynamicType, errors, elementItem);\n-\t\t\t\t}\n-\t\t\t\telementItem.annotate(dynamicType);\n-\t\t\t}\n-\t\t\telse\n-\t\t\t{\n-\t\t\t\t// It must be a wildcard match.\n-\t\t\t\tfinal SchemaWildcard wildcard = machine.getWildcard();\n-\t\t\t\telementItem.setProcessContents(wildcard.getProcessContents());\n-\n-\t\t\t\telementItem.recoverPSVI(localType, errors);\n-\t\t\t}\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\t// TODO: Why don't we annotate with the localType?\n-\t\t}\n-\t}\n-\n-\tpublic void recoverPSVI(final Type localType, final SchemaExceptionHandler errors) throws AbortException, SchemaException\n-\t{\n-\t\tfinal QName elementName = getName();\n-\n-\t\tswitch (getProcessContents())\n-\t\t{\n-\t\t\tcase Strict:\n-\t\t\t{\n-\t\t\t\tm_elementDecl = metaBridge.getElementDeclaration(elementName);\n-\t\t\t\tif (null != m_elementDecl)\n-\t\t\t\t{\n-\t\t\t\t\tcheckDeclNotAbstract(m_elementDecl, this, errors);\n-\t\t\t\t\tif (null != localType)\n-\t\t\t\t\t{\n-\t\t\t\t\t\tcheckLocalTypeValidlyDerivedFromElementType(m_elementDecl, localType, this);\n-\n-\t\t\t\t\t\tif (m_elementDecl.hasSubstitutionGroup())\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tcheckDeclSubstitutionsNotBlocked(m_elementDecl, localType, errors, this);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tannotate(localType);\n-\t\t\t\t\t}\n-\t\t\t\t\telse\n-\t\t\t\t\t{\n-\t\t\t\t\t\tfinal Type elementType = m_elementDecl.getType();\n-\n-\t\t\t\t\t\tif (m_elementDecl.hasSubstitutionGroup())\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tcheckDeclSubstitutionsNotBlocked(m_elementDecl, elementType, errors, this);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tannotate(elementType);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\telse\n-\t\t\t\t{\n-\t\t\t\t\tif (null != localType)\n-\t\t\t\t\t{\n-\t\t\t\t\t\tannotate(localType);\n-\t\t\t\t\t}\n-\t\t\t\t\telse\n-\t\t\t\t\t{\n-\t\t\t\t\t\terrors.error(new CvcElementDeclarationAndTypeException(elementName, getLocation()));\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tbreak;\n-\t\t\tcase Lax:\n-\t\t\t{\n-\t\t\t\tm_elementDecl = metaBridge.getElementDeclaration(elementName);\n-\t\t\t\tif (null != m_elementDecl)\n-\t\t\t\t{\n-\t\t\t\t\tcheckDeclNotAbstract(m_elementDecl, this, errors);\n-\t\t\t\t\tif (null != localType)\n-\t\t\t\t\t{\n-\t\t\t\t\t\tcheckLocalTypeValidlyDerivedFromElementType(m_elementDecl, localType, this);\n-\n-\t\t\t\t\t\tif (m_elementDecl.hasSubstitutionGroup())\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tcheckDeclSubstitutionsNotBlocked(m_elementDecl, localType, errors, this);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tannotate(localType);\n-\t\t\t\t\t}\n-\t\t\t\t\telse\n-\t\t\t\t\t{\n-\t\t\t\t\t\tfinal Type elementType = m_elementDecl.getType();\n-\n-\t\t\t\t\t\tif (m_elementDecl.hasSubstitutionGroup())\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tcheckDeclSubstitutionsNotBlocked(m_elementDecl, elementType, errors, this);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tannotate(elementType);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\telse\n-\t\t\t\t{\n-\t\t\t\t\tif (null != localType)\n-\t\t\t\t\t{\n-\t\t\t\t\t\tannotate(localType);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tbreak;\n-\t\t\tcase Skip:\n-\t\t\t{\n-\t\t\t}\n-\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t{\n-\t\t\t\tthrow new AssertionError(getProcessContents());\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate static void checkDeclNotAbstract(final ElementDefinition elementDeclaration, final Locatable locatable, final SchemaExceptionHandler errors) throws AbortException\n-\t{\n-\t\t// Check that the declaration is not abstract.\n-\t\tif (elementDeclaration.isAbstract())\n-\t\t{\n-\t\t\terrors.error(new CvcElementAbstractException(elementDeclaration, locatable.getLocation()));\n-\t\t}\n-\t}\n-\n-\tprivate static void checkDeclSubstitutionsNotBlocked(final ElementDefinition elementDeclaration, final Type elementType, final SchemaExceptionHandler errors, final Locatable locatable) throws AbortException\n-\t{\n-\t\t// Note: Substitution can be blocked by extension and restriction as well.\n-\t\tfinal ElementDefinition substitutionGroup = elementDeclaration.getSubstitutionGroup();\n-\t\tfinal Set<DerivationMethod> block = substitutionGroup.getDisallowedSubtitutions();\n-\t\tif (block.contains(DerivationMethod.Substitution))\n-\t\t{\n-\t\t\t// Substitutions are blocked outright by the substitution group declaration.\n-\t\t\terrors.error(new CvcSubstitutionBlockedByHeadDeclarationException(elementDeclaration, substitutionGroup, locatable.getLocation()));\n-\t\t}\n-\n-\t\tfinal Type headType = substitutionGroup.getType();\n-\n-\t\tif (block.contains(DerivationMethod.Extension))\n-\t\t{\n-\t\t\tif (elementType.derivedFromType(headType, EnumSet.of(DerivationMethod.Extension)))\n-\t\t\t{\n-\t\t\t\terrors.error(new CvcSubstitutionBlockedByHeadDeclarationException(elementDeclaration, substitutionGroup, locatable.getLocation()));\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (block.contains(DerivationMethod.Restriction))\n-\t\t{\n-\t\t\tif (elementType.derivedFromType(headType, EnumSet.of(DerivationMethod.Restriction)))\n-\t\t\t{\n-\t\t\t\terrors.error(new CvcSubstitutionBlockedByHeadDeclarationException(elementDeclaration, substitutionGroup, locatable.getLocation()));\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (headType instanceof ComplexType)\n-\t\t{\n-\t\t\tfinal ComplexType complexType = (ComplexType)headType;\n-\t\t\tfinal Set<DerivationMethod> prohibitedSubstitutions = complexType.getProhibitedSubstitutions();\n-\t\t\tif (prohibitedSubstitutions.contains(DerivationMethod.Substitution))\n-\t\t\t{\n-\t\t\t\tthrow new AssertionError(\"Isn't this dead code?\");\n-\t\t\t\t// Substitutions are blocked outright by the substitution group type.\n-\t\t\t\t// errors.error(new CvcSubstitutionBlockedByHeadTypeException(elementDeclaration,\n-\t\t\t\t// locatable.getLocation()));\n-\t\t\t}\n-\n-\t\t\tif (prohibitedSubstitutions.contains(DerivationMethod.Extension))\n-\t\t\t{\n-\t\t\t\tif (elementType.derivedFromType(headType, EnumSet.of(DerivationMethod.Extension)))\n-\t\t\t\t{\n-\t\t\t\t\terrors.error(new CvcSubstitutionBlockedByHeadTypeException(elementDeclaration, locatable.getLocation()));\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tif (prohibitedSubstitutions.contains(DerivationMethod.Restriction))\n-\t\t\t{\n-\t\t\t\tif (elementType.derivedFromType(headType, EnumSet.of(DerivationMethod.Restriction)))\n-\t\t\t\t{\n-\t\t\t\t\terrors.error(new CvcSubstitutionBlockedByHeadTypeException(elementDeclaration, locatable.getLocation()));\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate static void checkLocalTypeValidlyDerivedFromElementType(final ElementDefinition elementDeclaration, final Type localType, final Locatable locatable) throws CvcElementLocalTypeDerivationException\n-\t{\n-\t\tfinal Set<DerivationMethod> block = elementDeclaration.getDisallowedSubtitutions();\n-\t\tfinal Type elementType = elementDeclaration.getType();\n-\t\tif (localType instanceof SimpleType)\n-\t\t{\n-\t\t\ttry\n-\t\t\t{\n-\t\t\t\tcheckTypeDerivationOKSimple((SimpleType)localType, elementType, block);\n-\t\t\t}\n-\t\t\tcatch (final ComponentConstraintException e)\n-\t\t\t{\n-\t\t\t\tthrow new CvcElementLocalTypeDerivationException(localType, elementDeclaration, e, locatable.getLocation());\n-\t\t\t}\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tfinal Set<DerivationMethod> union = new HashSet<DerivationMethod>();\n-\n-\t\t\tunion.addAll(block);\n-\t\t\tif (elementType instanceof ComplexType)\n-\t\t\t{\n-\t\t\t\tfinal ComplexType complexType = (ComplexType)elementType;\n-\t\t\t\tunion.addAll(complexType.getProhibitedSubstitutions());\n-\t\t\t}\n-\n-\t\t\ttry\n-\t\t\t{\n-\t\t\t\tcheckTypeDerivationOKComplex(localType, elementType, union);\n-\t\t\t}\n-\t\t\tcatch (final ComponentConstraintException e)\n-\t\t\t{\n-\t\t\t\tthrow new CvcElementLocalTypeDerivationException(localType, elementDeclaration, e, locatable.getLocation());\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Type Derivation OK (Simple) (3.14.6)\n-\t */\n-\tprivate static void checkTypeDerivationOKSimple(final SimpleType D, final Type B, final Set<DerivationMethod> subset) throws ComponentConstraintException\n-\t{\n-\t\tif (D.getName().equals(B.getName()))\n-\t\t{\n-\t\t\t// They are the same type definition.\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tfinal Type deesBaseType = D.getBaseType();\n-\t\t\tif (subset.contains(DerivationMethod.Restriction) || deesBaseType.getFinal().contains(DerivationMethod.Restriction))\n-\t\t\t{\n-\t\t\t\tthrow new SccSimpleTypeDerivationRestrictionException(D.getName());\n-\t\t\t}\n-\n-\t\t\tboolean isOK = false;\n-\t\t\tif (deesBaseType.getName().equals(B.getName()))\n-\t\t\t{\n-\t\t\t\tisOK = true;\n-\t\t\t}\n-\t\t\telse if (!deesBaseType.isComplexUrType() && ModelPSVI.isTypeDerivationOK(deesBaseType, B, subset))\n-\t\t\t{\n-\t\t\t\tisOK = true;\n-\t\t\t}\n-\t\t\telse if (!D.isSimpleUrType() && (D.isListType() || D.isUnionType()) && B.isSimpleUrType())\n-\t\t\t{\n-\t\t\t\tisOK = true;\n-\t\t\t}\n-\t\t\telse if (B instanceof UnionSimpleType)\n-\t\t\t{\n-\t\t\t\tfinal UnionSimpleType unionType = (UnionSimpleType)B;\n-\t\t\t\tfor (final SimpleType memberType : unionType.getMemberTypes())\n-\t\t\t\t{\n-\t\t\t\t\tif (isTypeDerivationOK(D, memberType, subset))\n-\t\t\t\t\t{\n-\t\t\t\t\t\tisOK = true;\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tif (!isOK)\n-\t\t\t{\n-\t\t\t\tthrow new SccSimpleTypeDerivationException(D.getName());\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate static <A, S> void checkTypeDerivationOKComplex(final Type D, final Type B, final Set<DerivationMethod> subset) throws ComponentConstraintException\n-\t{\n-\t\tif (D.getName().equals(B.getName()))\n-\t\t{\n-\t\t\t// They are the same type definition.\n-\t\t}\n-\t\telse if (D.isComplexUrType())\n-\t\t{\n-\t\t\tthrow new SccComplexTypeDerivationHierarchyException(D, B, subset);\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tif (subset.contains(D.getDerivationMethod()))\n-\t\t\t{\n-\t\t\t\tthrow new SccComplexTypeDerivationMethodException(D, B, subset);\n-\t\t\t}\n-\n-\t\t\tfinal Type deeBaseType = D.getBaseType();\n-\t\t\tif (deeBaseType.getName().equals(B.getName()))\n-\t\t\t{\n-\t\t\t\t// B is D's {base type definition}\n-\t\t\t}\n-\t\t\telse\n-\t\t\t{\n-\t\t\t\tif (deeBaseType.isComplexUrType())\n-\t\t\t\t{\n-\t\t\t\t\tthrow new SccComplexTypeBaseUrTypeException(D, B, subset);\n-\t\t\t\t}\n-\t\t\t\telse\n-\t\t\t\t{\n-\t\t\t\t\tif (deeBaseType instanceof ComplexType)\n-\t\t\t\t\t{\n-\t\t\t\t\t\ttry\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tcheckTypeDerivationOK((ComplexType)deeBaseType, B, subset);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tcatch (final ComponentConstraintException e)\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tthrow new SccComplexTypeBaseComplexDerivationException(D, B, subset, e);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\telse\n-\t\t\t\t\t{\n-\t\t\t\t\t\ttry\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tcheckTypeDerivationOKSimple((SimpleType)deeBaseType, B, subset);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tcatch (final ComponentConstraintException e)\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tthrow new SccComplexTypeBaseSimpleDerivationException(D, B, subset, e);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate static void checkTypeDerivationOK(final Type D, final Type B, final Set<DerivationMethod> subset) throws ComponentConstraintException\n-\t{\n-\t\tif (D instanceof SimpleType)\n-\t\t{\n-\t\t\tcheckTypeDerivationOKSimple((SimpleType)D, B, subset);\n-\t\t}\n-\t\telse if (D instanceof ComplexType)\n-\t\t{\n-\t\t\tcheckTypeDerivationOKComplex(D, B, subset);\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tthrow new AssertionError(D);\n-\t\t}\n-\t}\n-\n-\tprivate static boolean isTypeDerivationOK(final Type D, final Type B, final Set<DerivationMethod> subset)\n-\t{\n-\t\ttry\n-\t\t{\n-\t\t\tcheckTypeDerivationOK(D, B, subset);\n-\t\t}\n-\t\tcatch (final SchemaException e)\n-\t\t{\n-\t\t\treturn false;\n-\t\t}\n-\t\treturn true;\n-\t}\n-}\n+    private ModelPSVI m_parentItem;\n+    public ModelPSVI getParent()\n+    {\n+        return m_parentItem;\n+    }\n+\n+    private final ValidationCache cache;\n+    private final ComponentProvider metaBridge;\n+    private ModelPSVI m_childItem; // for recycling\n+    private final NodeKind m_nodeKind;\n+\n+    // The name of the element information item.\n+    private QName m_elementName;\n+    public QName getName()\n+    {\n+        return m_elementName;\n+    }\n+\n+    private int m_lineNumber;\n+    private int m_columnNumber;\n+    private int m_characterOffset;\n+    private String m_publicId;\n+    private String m_systemId;\n+    public LocationInSchema getLocation()\n+    {\n+        return new SrcFrozenLocation(m_lineNumber, m_columnNumber, m_characterOffset, m_publicId, m_systemId);\n+    }\n+\n+    private Type m_type;\n+    private SmContentFiniteStateMachine m_machine;\n+    private ProcessContentsMode m_processContents;\n+\n+    // The XML Schema specification does not specify what a validating processor should do after\n+    // it encounters an error. It is not obliged to report more than the first error.\n+    private boolean m_suspendChecking;\n+    private ElementDefinition m_elementDecl;\n+\n+    // Did the instance use xsi:nil=\"true\"?\n+    private boolean m_nilled;\n+\n+    /**\n+     * Identity scopes may exist for an element information item.\n+     */\n+    public final ArrayList<IdentityScope> m_identityScopes = new ArrayList<IdentityScope>();\n+    public final HashMap<IdentityConstraint, IdentityScope> m_keyScopes = new HashMap<IdentityConstraint, IdentityScope>();\n+\n+    private ModelPSVI(final ModelPSVI parent, final NodeKind nodeKind, final ProcessContentsMode processContents, final ComponentProvider metaBridge, final ValidationCache cache)\n+    {\n+        this.m_parentItem = parent;\n+        this.m_nodeKind = PreCondition.assertArgumentNotNull(nodeKind, \"nodeKind\");\n+        this.metaBridge = PreCondition.assertArgumentNotNull(metaBridge, \"metaBridge\");\n+        this.cache = PreCondition.assertArgumentNotNull(cache, \"cache\");\n+        reset(processContents);\n+    }\n+\n+    public ModelPSVI(final ProcessContentsMode processContents, final ComponentProvider metaBridge, final ValidationCache cache)\n+    {\n+        this(null, NodeKind.DOCUMENT, processContents, metaBridge, cache);\n+    }\n+\n+    public ModelPSVI push(final QName elementName)\n+    {\n+        if (m_childItem == null)\n+        {\n+            m_childItem = new ModelPSVI(this, NodeKind.ELEMENT, getProcessContents(), this.metaBridge, this.cache);\n+        }\n+        else\n+        {\n+            m_childItem.reset(getProcessContents());\n+        }\n+        m_childItem.m_elementName = PreCondition.assertArgumentNotNull(elementName, \"elementName\");\n+\n+        // TODO: Need to get the element location.\n+        m_childItem.m_lineNumber = -1;\n+        m_childItem.m_columnNumber = -1;\n+        m_childItem.m_characterOffset = -1;\n+        m_childItem.m_publicId = null;\n+        m_childItem.m_systemId = null;\n+        return m_childItem;\n+    }\n+\n+    public boolean declExists()\n+    {\n+        return (null != m_elementDecl);\n+    }\n+\n+    /**\n+     * Computes the {nilled} property for the element information item by checking the interaction of the xsi:nil and\n+     * the {nillable} property of the element declaration.\n+     */\n+\n+    public boolean computeNilled(final Boolean explicitNil, final SchemaExceptionHandler errors)\n+        throws AbortException\n+    {\n+        if (null != explicitNil)\n+        {\n+            if (null != m_elementDecl)\n+            {\n+                if (m_elementDecl.isNillable())\n+                {\n+                    if (explicitNil)\n+                    {\n+                        final ValueConstraint valueConstraint = m_elementDecl.getValueConstraint();\n+                        if (null != valueConstraint && valueConstraint.getVariety().isFixed())\n+                        {\n+                            errors.error(new CvcElementFixedAndNilledException(m_elementDecl, getLocation()));\n+                        }\n+                    }\n+                }\n+                else\n+                {\n+                    errors.error(new CvcElementNotNillableException(m_elementDecl, getLocation()));\n+                }\n+            }\n+            return explicitNil;\n+        }\n+        else\n+        {\n+            return false;\n+        }\n+    }\n+\n+    public boolean step(final QName childName, final Locatable childLocatable, final SchemaExceptionHandler errors)\n+        throws AbortException\n+    {\n+        final Type elementType = getType();\n+        if (null == elementType)\n+        {\n+            // TODO: We should really see if locally valid wrt to type has been flagged.\n+            // Do nothing if there is no type annotation.\n+            return false;\n+        }\n+        if (elementType instanceof SimpleType)\n+        {\n+            // TODO: Do we include the xs:anySimpleType (simple ur-type)?\n+            errors.error(new CvcElementInSimpleTypeException(getName(), getLocation(), childName, childLocatable.getLocation()));\n+            return false;\n+        }\n+        else if (elementType instanceof ComplexType)\n+        {\n+            final ComplexType complexType = (ComplexType)elementType;\n+            if (m_suspendChecking)\n+            {\n+                return false;\n+            }\n+            switch (getProcessContents())\n+            {\n+                case Lax:\n+                {\n+                    // Fall through\n+\n+                }\n+                break;\n+                case Skip:\n+                {\n+                    return false;\n+                }\n+                case Strict:\n+                {\n+                    // Fall through\n+\n+                }\n+                break;\n+                default:\n+                {\n+                    throw new AssertionError(getProcessContents().name());\n+                }\n+            }\n+            if (m_nilled && (null != m_elementDecl))\n+            {\n+                errors.error(new CvcElementUnexpectedChildInNilledElementException(m_elementDecl, getLocation()));\n+                return false;\n+            }\n+            switch (complexType.getContentType().getKind())\n+            {\n+                case Empty:\n+                {\n+                    errors.error(new CvcElementInEmptyContentException(getName(), getLocation(), childName, childLocatable.getLocation()));\n+                    return false;\n+                }\n+                case Simple:\n+                {\n+                    errors.error(new CvcElementInSimpleContentTypeException(getName(), getLocation(), childName, childLocatable.getLocation()));\n+                    return false;\n+                }\n+                case ElementOnly:\n+                case Mixed:\n+                {\n+                    switch (m_nodeKind)\n+                    {\n+                        case ELEMENT:\n+                        {\n+                            if (null != m_machine)\n+                            {\n+                                if (m_machine.step(childName))\n+                                {\n+                                    return true;\n+                                }\n+                                else\n+                                {\n+                                    errors.error(new SmUnexpectedElementException(getName(), getLocation(), childName, childLocatable.getLocation()));\n+                                    m_suspendChecking = true;\n+                                    return false;\n+                                }\n+                            }\n+                            else\n+                            {\n+                                switch (getProcessContents())\n+                                {\n+                                    case Strict:\n+                                    {\n+                                        errors.error(new SmUnexpectedElementException(getName(), getLocation(), childName, childLocatable.getLocation()));\n+                                        m_suspendChecking = true;\n+                                    }\n+                                    default:\n+                                    {\n+\n+                                    }\n+                                }\n+                                return false;\n+                            }\n+                        }\n+                        case DOCUMENT:\n+                        {\n+                            return false;\n+                        }\n+                        default:\n+                        {\n+                            throw new AssertionError(m_nodeKind);\n+                        }\n+                    }\n+                }\n+                default:\n+                {\n+                    throw new AssertionError(complexType.getContentType().getKind());\n+                }\n+            }\n+        }\n+        else\n+        {\n+            throw new AssertionError(elementType);\n+        }\n+    }\n+\n+    public void checkForUnexpectedEndOfContent(final SchemaExceptionHandler errors)\n+        throws AbortException\n+    {\n+        if (m_suspendChecking)\n+        {\n+            return;\n+        }\n+        switch (getProcessContents())\n+        {\n+            case Lax:\n+            {\n+                // Fall through\n+\n+            }\n+            break;\n+            case Skip:\n+            {\n+                return;\n+            }\n+            case Strict:\n+            {\n+                // Fall through\n+\n+            }\n+            break;\n+            default:\n+            {\n+                throw new AssertionError(getProcessContents().name());\n+            }\n+        }\n+        if (!m_nilled)\n+        {\n+            // We don't want an exception in startElement (causing a null machine) to be masked by a NPE.\n+            if (null != m_machine)\n+            {\n+                if (!m_machine.end())\n+                {\n+                    errors.error(new SmUnexpectedEndException(getName(), getLocation()));\n+                }\n+            }\n+        }\n+    }\n+\n+    public ModelPSVI pop()\n+    {\n+        return m_parentItem;\n+    }\n+\n+    private void reset(final ProcessContentsMode processContents)\n+    {\n+        m_elementDecl = null;\n+        m_type = null;\n+        m_machine = null;\n+        setProcessContents(processContents);\n+        m_suspendChecking = (null != m_parentItem) && m_parentItem.m_suspendChecking;\n+        m_nilled = false;\n+    }\n+\n+    public void annotate(final Type type)\n+    {\n+        m_type = PreCondition.assertArgumentNotNull(type);\n+        if (type instanceof ComplexType)\n+        {\n+            final ComplexType complexType = (ComplexType)type;\n+            final ContentTypeKind kind = complexType.getContentType().getKind();\n+            if (kind.isComplex())\n+            {\n+                m_machine = cache.getMachine(complexType);\n+            }\n+        }\n+    }\n+\n+    public ElementDefinition getDeclaration()\n+    {\n+        return m_elementDecl;\n+    }\n+\n+    public Type getType()\n+    {\n+        return m_type;\n+    }\n+\n+    public boolean isNilled()\n+    {\n+        return m_nilled;\n+    }\n+\n+    public void setNilled(boolean nilled)\n+    {\n+        m_nilled = nilled;\n+    }\n+\n+    public ProcessContentsMode getProcessContents()\n+    {\n+        return m_processContents;\n+    }\n+\n+    public void setProcessContents(final ProcessContentsMode processContents)\n+    {\n+        m_processContents = PreCondition.assertArgumentNotNull(processContents);\n+    }\n+\n+    public boolean getSuspendChecking()\n+    {\n+        return m_suspendChecking;\n+    }\n+\n+    public static void assignPSVI(final ModelPSVI elementItem, final Type localType, final SchemaExceptionHandler errors)\n+        throws AbortException, SchemaException\n+    {\n+        final SmContentFiniteStateMachine machine = elementItem.m_parentItem.m_machine;\n+        if (null != machine)\n+        {\n+            if (machine.isElementMatch())\n+            {\n+                elementItem.m_elementDecl = machine.getElement();\n+                checkDeclNotAbstract(elementItem.m_elementDecl, elementItem, errors);\n+\n+                final Type dynamicType;\n+                if (null != localType)\n+                {\n+                    dynamicType = localType;\n+                    checkLocalTypeValidlyDerivedFromElementType(elementItem.m_elementDecl, localType, elementItem);\n+                }\n+                else\n+                {\n+                    dynamicType = elementItem.m_elementDecl.getType();\n+                }\n+\n+                final ElementDefinition substitutionGroup = elementItem.m_elementDecl.getSubstitutionGroup();\n+                if (null != substitutionGroup)\n+                {\n+                    checkDeclSubstitutionsNotBlocked(elementItem.m_elementDecl, dynamicType, errors, elementItem);\n+                }\n+                elementItem.annotate(dynamicType);\n+            }\n+            else\n+            {\n+                // It must be a wildcard match.\n+                final SchemaWildcard wildcard = machine.getWildcard();\n+                elementItem.setProcessContents(wildcard.getProcessContents());\n+                elementItem.recoverPSVI(localType, errors);\n+            }\n+        }\n+        else\n+        {\n+            // TODO: Why don't we annotate with the localType?\n+\n+        }\n+    }\n+\n+    public void recoverPSVI(final Type localType, final SchemaExceptionHandler errors)\n+        throws AbortException, SchemaException\n+    {\n+        final QName elementName = getName();\n+\n+        switch (getProcessContents())\n+        {\n+            case Strict:\n+            {\n+                m_elementDecl = metaBridge.getElementDeclaration(elementName);\n+                if (null != m_elementDecl)\n+                {\n+                    checkDeclNotAbstract(m_elementDecl, this, errors);\n+                    if (null != localType)\n+                    {\n+                        checkLocalTypeValidlyDerivedFromElementType(m_elementDecl, localType, this);\n+                        if (m_elementDecl.hasSubstitutionGroup())\n+                        {\n+                            checkDeclSubstitutionsNotBlocked(m_elementDecl, localType, errors, this);\n+                        }\n+                        annotate(localType);\n+                    }\n+                    else\n+                    {\n+                        final Type elementType = m_elementDecl.getType();\n+                        if (m_elementDecl.hasSubstitutionGroup())\n+                        {\n+                            checkDeclSubstitutionsNotBlocked(m_elementDecl, elementType, errors, this);\n+                        }\n+                        annotate(elementType);\n+                    }\n+                }\n+                else\n+                {\n+                    if (null != localType)\n+                    {\n+                        annotate(localType);\n+                    }\n+                    else\n+                    {\n+                        errors.error(new CvcElementDeclarationAndTypeException(elementName, getLocation()));\n+                    }\n+                }\n+            }\n+            break;\n+            case Lax:\n+            {\n+                m_elementDecl = metaBridge.getElementDeclaration(elementName);\n+                if (null != m_elementDecl)\n+                {\n+                    checkDeclNotAbstract(m_elementDecl, this, errors);\n+                    if (null != localType)\n+                    {\n+                        checkLocalTypeValidlyDerivedFromElementType(m_elementDecl, localType, this);\n+                        if (m_elementDecl.hasSubstitutionGroup())\n+                        {\n+                            checkDeclSubstitutionsNotBlocked(m_elementDecl, localType, errors, this);\n+                        }\n+                        annotate(localType);\n+                    }\n+                    else\n+                    {\n+                        final Type elementType = m_elementDecl.getType();\n+                        if (m_elementDecl.hasSubstitutionGroup())\n+                        {\n+                            checkDeclSubstitutionsNotBlocked(m_elementDecl, elementType, errors, this);\n+                        }\n+                        annotate(elementType);\n+                    }\n+                }\n+                else\n+                {\n+                    if (null != localType)\n+                    {\n+                        annotate(localType);\n+                    }\n+                }\n+            }\n+            break;\n+            case Skip:\n+            {\n+\n+            }\n+            break;\n+            default:\n+            {\n+                throw new AssertionError(getProcessContents());\n+            }\n+        }\n+    }\n+\n+    private static void checkDeclNotAbstract(final ElementDefinition elementDeclaration, final Locatable locatable, final SchemaExceptionHandler errors)\n+        throws AbortException\n+    {\n+        // Check that the declaration is not abstract.\n+        if (elementDeclaration.isAbstract())\n+        {\n+            errors.error(new CvcElementAbstractException(elementDeclaration, locatable.getLocation()));\n+        }\n+    }\n+\n+    private static void checkDeclSubstitutionsNotBlocked(final ElementDefinition elementDeclaration, final Type elementType, final SchemaExceptionHandler errors, final Locatable locatable)\n+        throws AbortException\n+    {\n+        // Note: Substitution can be blocked by extension and restriction as well.\n+        final ElementDefinition substitutionGroup = elementDeclaration.getSubstitutionGroup();\n+        final Set<DerivationMethod> block = substitutionGroup.getDisallowedSubtitutions();\n+        if (block.contains(DerivationMethod.Substitution))\n+        {\n+            // Substitutions are blocked outright by the substitution group declaration.\n+            errors.error(new CvcSubstitutionBlockedByHeadDeclarationException(elementDeclaration, substitutionGroup, locatable.getLocation()));\n+        }\n+\n+        final Type headType = substitutionGroup.getType();\n+        if (block.contains(DerivationMethod.Extension))\n+        {\n+            if (elementType.derivedFromType(headType, EnumSet.of(DerivationMethod.Extension)))\n+            {\n+                errors.error(new CvcSubstitutionBlockedByHeadDeclarationException(elementDeclaration, substitutionGroup, locatable.getLocation()));\n+            }\n+        }\n+        if (block.contains(DerivationMethod.Restriction))\n+        {\n+            if (elementType.derivedFromType(headType, EnumSet.of(DerivationMethod.Restriction)))\n+            {\n+                errors.error(new CvcSubstitutionBlockedByHeadDeclarationException(elementDeclaration, substitutionGroup, locatable.getLocation()));\n+            }\n+        }\n+        if (headType instanceof ComplexType)\n+        {\n+            final ComplexType complexType = (ComplexType)headType;\n+            final Set<DerivationMethod> prohibitedSubstitutions = complexType.getProhibitedSubstitutions();\n+            if (prohibitedSubstitutions.contains(DerivationMethod.Substitution))\n+            {\n+                throw new AssertionError(\"Isn't this dead code?\");\n+                // Substitutions are blocked outright by the substitution group type.\n+                // errors.error(new CvcSubstitutionBlockedByHeadTypeException(elementDeclaration,\n+                // locatable.getLocation()));\n+            }\n+            if (prohibitedSubstitutions.contains(DerivationMethod.Extension))\n+            {\n+                if (elementType.derivedFromType(headType, EnumSet.of(DerivationMethod.Extension)))\n+                {\n+                    errors.error(new CvcSubstitutionBlockedByHeadTypeException(elementDeclaration, locatable.getLocation()));\n+                }\n+            }\n+            if (prohibitedSubstitutions.contains(DerivationMethod.Restriction))\n+            {\n+                if (elementType.derivedFromType(headType, EnumSet.of(DerivationMethod.Restriction)))\n+                {\n+                    errors.error(new CvcSubstitutionBlockedByHeadTypeException(elementDeclaration, locatable.getLocation()));\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void checkLocalTypeValidlyDerivedFromElementType(final ElementDefinition elementDeclaration, final Type localType, final Locatable locatable)\n+        throws CvcElementLocalTypeDerivationException\n+    {\n+        final Set<DerivationMethod> block = elementDeclaration.getDisallowedSubtitutions();\n+        final Type elementType = elementDeclaration.getType();\n+        if (localType instanceof SimpleType)\n+        {\n+            try\n+            {\n+                checkTypeDerivationOKSimple((SimpleType)localType, elementType, block);\n+            }\n+            catch (final ComponentConstraintException e)\n+            {\n+                throw new CvcElementLocalTypeDerivationException(localType, elementDeclaration, e, locatable.getLocation());\n+            }\n+        }\n+        else\n+        {\n+            final Set<DerivationMethod> union = new HashSet<DerivationMethod>();\n+            union.addAll(block);\n+            if (elementType instanceof ComplexType)\n+            {\n+                final ComplexType complexType = (ComplexType)elementType;\n+                union.addAll(complexType.getProhibitedSubstitutions());\n+            }\n+            try\n+            {\n+                checkTypeDerivationOKComplex(localType, elementType, union);\n+            }\n+            catch (final ComponentConstraintException e)\n+            {\n+                throw new CvcElementLocalTypeDerivationException(localType, elementDeclaration, e, locatable.getLocation());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Type Derivation OK (Simple) (3.14.6)\n+     */\n+\n+    private static void checkTypeDerivationOKSimple(final SimpleType D, final Type B, final Set<DerivationMethod> subset)\n+        throws ComponentConstraintException\n+    {\n+        if (D.getName().equals(B.getName()))\n+        {\n+            // They are the same type definition.\n+\n+        }\n+        else\n+        {\n+            final Type deesBaseType = D.getBaseType();\n+            if (subset.contains(DerivationMethod.Restriction) || deesBaseType.getFinal().contains(DerivationMethod.Restriction))\n+            {\n+                throw new SccSimpleTypeDerivationRestrictionException(D.getName());\n+            }\n+\n+            boolean isOK = false;\n+            if (deesBaseType.getName().equals(B.getName()))\n+            {\n+                isOK = true;\n+            }\n+            else if (!deesBaseType.isComplexUrType() && ModelPSVI.isTypeDerivationOK(deesBaseType, B, subset))\n+            {\n+                isOK = true;\n+            }\n+            else if (!D.isSimpleUrType() && (D.isListType() || D.isUnionType()) && B.isSimpleUrType())\n+            {\n+                isOK = true;\n+            }\n+            else if (B instanceof UnionSimpleType)\n+            {\n+                final UnionSimpleType unionType = (UnionSimpleType)B;\n+                for (final SimpleType memberType : unionType.getMemberTypes())\n+                {\n+                    if (isTypeDerivationOK(D, memberType, subset))\n+                    {\n+                        isOK = true;\n+                        break;\n+                    }\n+                }\n+            }\n+            if (!isOK)\n+            {\n+                throw new SccSimpleTypeDerivationException(D.getName());\n+            }\n+        }\n+    }\n+\n+    private static <A, S> void checkTypeDerivationOKComplex(final Type D, final Type B, final Set<DerivationMethod> subset) throws ComponentConstraintException\n+    {\n+        if (D.getName().equals(B.getName()))\n+        {\n+            // They are the same type definition.\n+\n+        }\n+        else if (D.isComplexUrType())\n+        {\n+            throw new SccComplexTypeDerivationHierarchyException(D, B, subset);\n+        }\n+        else\n+        {\n+            if (subset.contains(D.getDerivationMethod()))\n+            {\n+                throw new SccComplexTypeDerivationMethodException(D, B, subset);\n+            }\n+\n+            final Type deeBaseType = D.getBaseType();\n+            if (deeBaseType.getName().equals(B.getName()))\n+            {\n+                // B is D's {base type definition}\n+\n+            }\n+            else\n+            {\n+                if (deeBaseType.isComplexUrType())\n+                {\n+                    throw new SccComplexTypeBaseUrTypeException(D, B, subset);\n+                }\n+                else\n+                {\n+                    if (deeBaseType instanceof ComplexType)\n+                    {\n+                        try\n+                        {\n+                            checkTypeDerivationOK((ComplexType)deeBaseType, B, subset);\n+                        }\n+                        catch (final ComponentConstraintException e)\n+                        {\n+                            throw new SccComplexTypeBaseComplexDerivationException(D, B, subset, e);\n+                        }\n+                    }\n+                    else\n+                    {\n+                        try\n+                        {\n+                            checkTypeDerivationOKSimple((SimpleType)deeBaseType, B, subset);\n+                        }\n+                        catch (final ComponentConstraintException e)\n+                        {\n+                            throw new SccComplexTypeBaseSimpleDerivationException(D, B, subset, e);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void checkTypeDerivationOK(final Type D, final Type B, final Set<DerivationMethod> subset)\n+        throws ComponentConstraintException\n+    {\n+        if (D instanceof SimpleType)\n+        {\n+            checkTypeDerivationOKSimple((SimpleType)D, B, subset);\n+        }\n+        else if (D instanceof ComplexType)\n+        {\n+            checkTypeDerivationOKComplex(D, B, subset);\n+        }\n+        else\n+        {\n+            throw new AssertionError(D);\n+        }\n+    }\n+\n+    private static boolean isTypeDerivationOK(final Type D, final Type B, final Set<DerivationMethod> subset)\n+    {\n+        try\n+        {\n+            checkTypeDerivationOK(D, B, subset);\n+        }\n+        catch (final SchemaException e)\n+        {\n+            return false;\n+        }\n+        return true;\n+    }\n+}\n\\ No newline at end of file\n",
            "diff_size": 733
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "79",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/368/ModelPSVI.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_random/368/ModelPSVI.java\nindex 2477f43087b..75612a609ba 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/368/ModelPSVI.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_random/368/ModelPSVI.java\n@@ -74,7 +74,7 @@ import org.genxdm.xs.types.UnionSimpleType;\n  */\n final class ModelPSVI implements VxPSVI, Locatable\n {\n-\tprivate ModelPSVI m_parentItem;\n+private ModelPSVI m_parentItem;\n \n \tpublic ModelPSVI getParent()\n \t{\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "79",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/368/ModelPSVI.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_three_grams/368/ModelPSVI.java\nindex 2477f43087b..4eef068d826 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/368/ModelPSVI.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_three_grams/368/ModelPSVI.java\n@@ -74,7 +74,7 @@ import org.genxdm.xs.types.UnionSimpleType;\n  */\n final class ModelPSVI implements VxPSVI, Locatable\n {\n-\tprivate ModelPSVI m_parentItem;\n+    private ModelPSVI m_parentItem;\n \n \tpublic ModelPSVI getParent()\n \t{\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "intellij",
        "codebuff"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "styler_random",
        "styler_three_grams"
    ]
}