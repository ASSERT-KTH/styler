{
    "project_name": "CESNET-perun",
    "error_id": "386",
    "information": {
        "errors": [
            {
                "line": "71",
                "severity": "error",
                "message": "Line matches the illegal pattern 'Wrong number of tabs before space on next line. Indent must use tab characters.'.",
                "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpCheck"
            }
        ]
    },
    "source_code": "\tpublic final static List<String> reservedNamesForUnixGroups = Arrays.asList(\"root\", \"daemon\", \"tty\", \"bin\", \"sys\", \"sudo\", \"nogroup\",\n\t          \"hadoop\", \"hdfs\", \"mapred\", \"yarn\", \"hsqldb\", \"derby\", \"jetty\", \"hbase\", \"zookeeper\", \"users\");\n\tpublic final static List<String> unpermittedNamesForUserLogins = Arrays.asList(\"arraysvcs\", \"at\", \"backup\", \"bin\", \"daemon\", \"Debian-exim\", \"flexlm\", \"ftp\", \"games\",\n\t\t        \"gdm\", \"glite\", \"gnats\", \"haldaemon\", \"identd\", \"irc\", \"libuuid\", \"list\", \"lp\", \"mail\", \"man\",\n\t\t        \"messagebus\", \"news\", \"nobody\", \"ntp\", \"openslp\", \"pcp\", \"polkituser\", \"postfix\", \"proxy\",\n\t\t        \"pulse\", \"puppet\", \"root\", \"saned\", \"smmsp\", \"smmta\", \"sshd\", \"statd\", \"suse-ncc\", \"sync\",",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/386/ModulesUtilsBlImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/styler/386/ModulesUtilsBlImpl.java\nindex 17f40b462e4..1b98291ce22 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/386/ModulesUtilsBlImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/styler/386/ModulesUtilsBlImpl.java\n@@ -68,8 +68,8 @@ public class ModulesUtilsBlImpl implements ModulesUtilsBl {\n \n \tpublic final static List<String> reservedNamesForUnixGroups = Arrays.asList(\"root\", \"daemon\", \"tty\", \"bin\", \"sys\", \"sudo\", \"nogroup\",\n \t          \"hadoop\", \"hdfs\", \"mapred\", \"yarn\", \"hsqldb\", \"derby\", \"jetty\", \"hbase\", \"zookeeper\", \"users\");\n-\tpublic final static List<String> unpermittedNamesForUserLogins = Arrays.asList(\"arraysvcs\", \"at\", \"backup\", \"bin\", \"daemon\", \"Debian-exim\", \"flexlm\", \"ftp\", \"games\",\n-\t\t        \"gdm\", \"glite\", \"gnats\", \"haldaemon\", \"identd\", \"irc\", \"libuuid\", \"list\", \"lp\", \"mail\", \"man\",\n+\n+public final static List<String> unpermittedNamesForUserLogins = Arrays.asList(\"arraysvcs\", \"at\", \"backup\", \"bin\", \"daemon\", \"Debian-exim\", \"flexlm\", \"ftp\", \"games\", \"gdm\", \"glite\", \"gnats\", \"haldaemon\", \"identd\", \"irc\", \"libuuid\", \"list\", \"lp\", \"mail\", \"man\",\n \t\t        \"messagebus\", \"news\", \"nobody\", \"ntp\", \"openslp\", \"pcp\", \"polkituser\", \"postfix\", \"proxy\",\n \t\t        \"pulse\", \"puppet\", \"root\", \"saned\", \"smmsp\", \"smmta\", \"sshd\", \"statd\", \"suse-ncc\", \"sync\",\n \t\t        \"sys\", \"uucp\", \"uuidd\", \"www-data\", \"wwwrun\", \"zenssh\", \"tomcat6\", \"tomcat7\", \"tomcat8\",\n",
            "diff_size": 2
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/386/ModulesUtilsBlImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/intellij/386/ModulesUtilsBlImpl.java\nindex 17f40b462e4..72420a5d590 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/386/ModulesUtilsBlImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/intellij/386/ModulesUtilsBlImpl.java\n@@ -22,6 +22,7 @@ import cz.metacentrum.perun.core.bl.ModulesUtilsBl;\n import cz.metacentrum.perun.core.bl.PerunBl;\n import cz.metacentrum.perun.core.impl.PerunSessionImpl;\n import cz.metacentrum.perun.core.impl.Utils;\n+\n import java.math.BigDecimal;\n import java.util.ArrayList;\n import java.util.Arrays;\n@@ -45,1007 +46,1140 @@ import org.slf4j.LoggerFactory;\n  */\n public class ModulesUtilsBlImpl implements ModulesUtilsBl {\n \n-\tfinal static Logger log = LoggerFactory.getLogger(ServicesManagerBlImpl.class);\n-\tprivate PerunBl perunBl;\n-\tMap<String,String> perunNamespaces = null;\n-\n-\tpublic static final String A_E_namespace_minGID = AttributesManager.NS_ENTITYLESS_ATTR_DEF + \":namespace-minGID\";\n-\tpublic static final String A_E_namespace_maxGID = AttributesManager.NS_ENTITYLESS_ATTR_DEF + \":namespace-maxGID\";\n-\tpublic static final String A_G_unixGID_namespace = AttributesManager.NS_GROUP_ATTR_DEF + \":unixGID-namespace\";\n-\tpublic static final String A_G_unixGroupName_namespace = AttributesManager.NS_GROUP_ATTR_DEF + \":unixGroupName-namespace\";\n-\tpublic static final String A_R_unixGID_namespace = AttributesManager.NS_RESOURCE_ATTR_DEF + \":unixGID-namespace\";\n-\tpublic static final String A_R_unixGroupName_namespace = AttributesManager.NS_RESOURCE_ATTR_DEF + \":unixGroupName-namespace\";\n-\tpublic static final String A_F_unixGID_namespace = AttributesManager.NS_FACILITY_ATTR_DEF + \":unixGID-namespace\";\n-\tpublic static final String A_F_unixGroupName_namespace = AttributesManager.NS_FACILITY_ATTR_DEF + \":unixGroupName-namespace\";\n-\tpublic static final String A_F_googleGroupName_namespace = AttributesManager.NS_FACILITY_ATTR_DEF + \":googleGroupNameNamespace\";\n-\tprivate static final String A_E_usedGids = AttributesManager.NS_ENTITYLESS_ATTR_DEF + \":usedGids\";\n-\n-\t//Often used patterns\n-\tpublic static final Pattern quotaWithMetricsPattern = Pattern.compile(\"^([0-9]+([.][0-9]+)?[KMGTPE]?):([0-9]+([.][0-9]+)?[KMGTPE]?)$\");\n-\tpublic static final Pattern quotaWithoutMetricsPattern = Pattern.compile(\"^([0-9]+)(:)([0-9]+)$\");\n-\tpublic static final Pattern numberPattern = Pattern.compile(\"[0-9]+([.][0-9]+)?\");\n-\tpublic static final Pattern letterPattern = Pattern.compile(\"[A-Z]\");\n-\n-\tpublic final static List<String> reservedNamesForUnixGroups = Arrays.asList(\"root\", \"daemon\", \"tty\", \"bin\", \"sys\", \"sudo\", \"nogroup\",\n-\t          \"hadoop\", \"hdfs\", \"mapred\", \"yarn\", \"hsqldb\", \"derby\", \"jetty\", \"hbase\", \"zookeeper\", \"users\");\n-\tpublic final static List<String> unpermittedNamesForUserLogins = Arrays.asList(\"arraysvcs\", \"at\", \"backup\", \"bin\", \"daemon\", \"Debian-exim\", \"flexlm\", \"ftp\", \"games\",\n-\t\t        \"gdm\", \"glite\", \"gnats\", \"haldaemon\", \"identd\", \"irc\", \"libuuid\", \"list\", \"lp\", \"mail\", \"man\",\n-\t\t        \"messagebus\", \"news\", \"nobody\", \"ntp\", \"openslp\", \"pcp\", \"polkituser\", \"postfix\", \"proxy\",\n-\t\t        \"pulse\", \"puppet\", \"root\", \"saned\", \"smmsp\", \"smmta\", \"sshd\", \"statd\", \"suse-ncc\", \"sync\",\n-\t\t        \"sys\", \"uucp\", \"uuidd\", \"www-data\", \"wwwrun\", \"zenssh\", \"tomcat6\", \"tomcat7\", \"tomcat8\",\n-\t\t        \"nn\", \"dn\", \"rm\", \"nm\", \"sn\", \"jn\", \"jhs\", \"http\", \"yarn\", \"hdfs\", \"mapred\", \"hadoop\", \"hsqldb\", \"derby\",\n-\t\t        \"jetty\", \"hbase\", \"zookeeper\", \"hive\", \"hue\");\n-\n-\t//Definition of K = KB, M = MB etc.\n-\tpublic static final long M = 1024;\n-\tpublic static final long G = M * 1024;\n-\tpublic static final long T = G * 1024;\n-\tpublic static final long P = T * 1024;\n-\tpublic static final long E = P * 1024;\n-\n-\tpublic ModulesUtilsBlImpl() {\n-\t}\n-\n-\tpublic boolean isNamespaceEqualsToFacilityUnixGroupNameNamespace(PerunSessionImpl sess, Facility facility, String namespace) throws InternalErrorException, AttributeNotExistsException, WrongAttributeAssignmentException{\n-\t\tUtils.notNull(facility, \"facility\");\n-\t\tUtils.notNull(namespace, \"namespace\");\n-\t\tUtils.notNull(sess, \"perunSessionImpl\");\n-\t\tAttribute facilityNamespaceAttr = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, facility, A_F_unixGroupName_namespace + \":\" + namespace);\n-\t\tif(facilityNamespaceAttr.getValue() == null) return false;\n-\t\tif(!namespace.equals(facilityNamespaceAttr.getValue())) {\n-\t\t\treturn false;\n-\t\t}\n-\t\treturn true;\n-\t}\n-\n-\tpublic List<Resource> findCollisionResourcesWithSameGroupName(PerunSessionImpl sess, Resource resource, String namespace) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException {\n-\t\tUtils.notNull(sess, \"perunSessionImpl\");\n-\t\tUtils.notNull(resource, \"resource\");\n-\t\tAttribute resourceUnixGroupName = getPerunBl().getAttributesManagerBl().getAttribute(sess, resource, A_R_unixGroupName_namespace + \":\" + namespace);\n-\t\tList<Resource> resourcesWithSameUnixGroupName = getPerunBl().getResourcesManagerBl().getResourcesByAttribute(sess, resourceUnixGroupName);\n-\t\tresourcesWithSameUnixGroupName.remove(resource);\n-\t\treturn resourcesWithSameUnixGroupName;\n-\t}\n-\n-\tpublic List<Resource> findCollisionResourcesWithSameGroupName(PerunSessionImpl sess, Group group, String namespace) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException {\n-\t\tUtils.notNull(sess, \"perunSessionImpl\");\n-\t\tUtils.notNull(group, \"group\");\n-\t\tUtils.notNull(namespace, \"namespace\");\n-\t\tAttribute groupUnixGroupName = getPerunBl().getAttributesManagerBl().getAttribute(sess, group, A_G_unixGroupName_namespace + \":\" + namespace);\n-\t\tAttribute copyResourceUnixGroupName = new Attribute(getPerunBl().getAttributesManagerBl().getAttributeDefinition(sess, A_R_unixGroupName_namespace + \":\" + namespace));\n-\t\tcopyResourceUnixGroupName.setValue(groupUnixGroupName.getValue());\n-\t\treturn getPerunBl().getResourcesManagerBl().getResourcesByAttribute(sess, copyResourceUnixGroupName);\n-\t}\n-\n-\tpublic List<Group> findCollisionGroupsWithSamgeGroupName(PerunSessionImpl sess, Resource resource, String namespace) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException {\n-\t\tUtils.notNull(sess, \"perunSessionImpl\");\n-\t\tUtils.notNull(resource, \"resource\");\n-\t\tUtils.notNull(namespace, \"namespace\");\n-\t\tAttribute resourceUnixGroupName = getPerunBl().getAttributesManagerBl().getAttribute(sess, resource, A_R_unixGroupName_namespace + \":\" + namespace);\n-\t\tAttribute copyGroupUnixGroupName = new Attribute(getPerunBl().getAttributesManagerBl().getAttributeDefinition(sess, A_G_unixGroupName_namespace + \":\" + namespace));\n-\t\tcopyGroupUnixGroupName.setValue(resourceUnixGroupName.getValue());\n-\t\treturn getPerunBl().getGroupsManagerBl().getGroupsByAttribute(sess, copyGroupUnixGroupName);\n-\n-\t}\n-\n-\tpublic List<Group> findCollisionGroupsWithSamgeGroupName(PerunSessionImpl sess, Group group, String namespace) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException {\n-\t\tUtils.notNull(sess, \"perunSessionImpl\");\n-\t\tUtils.notNull(group, \"group\");\n-\t\tUtils.notNull(namespace, \"namespace\");\n-\t\tAttribute groupUnixGroupName = getPerunBl().getAttributesManagerBl().getAttribute(sess, group, A_G_unixGroupName_namespace + \":\" + namespace);\n-\t\tList<Group> groupsWithsameGroupName = getPerunBl().getGroupsManagerBl().getGroupsByAttribute(sess, groupUnixGroupName);\n-\t\tgroupsWithsameGroupName.remove(group);\n-\t\treturn groupsWithsameGroupName;\n-\t}\n-\n-\tpublic List<Resource> findCollisionResourcesWithSameGid(PerunSessionImpl sess, Resource resource, String namespace) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException {\n-\t\tUtils.notNull(sess, \"perunSessionImpl\");\n-\t\tUtils.notNull(resource, \"resource\");\n-\t\tUtils.notNull(namespace, \"namespace\");\n-\t\tAttribute resourceUnixGid = getPerunBl().getAttributesManagerBl().getAttribute(sess, resource, A_R_unixGID_namespace + \":\" + namespace);\n-\t\tList<Resource> resourcesWithSameGid = getPerunBl().getResourcesManagerBl().getResourcesByAttribute(sess, resourceUnixGid);\n-\t\tresourcesWithSameGid.remove(resource);\n-\t\treturn resourcesWithSameGid;\n-\t}\n-\n-\tpublic List<Resource> findCollisionResourcesWithSameGid(PerunSessionImpl sess, Group group, String namespace) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException {\n-\t\tUtils.notNull(sess, \"perunSessionImpl\");\n-\t\tUtils.notNull(group, \"group\");\n-\t\tUtils.notNull(namespace, \"namespace\");\n-\t\tAttribute groupUnixGid = getPerunBl().getAttributesManagerBl().getAttribute(sess, group, A_G_unixGID_namespace + \":\" + namespace);\n-\t\tAttribute copyResourceUnixGid = new Attribute(getPerunBl().getAttributesManagerBl().getAttributeDefinition(sess, A_R_unixGID_namespace + \":\" + namespace));\n-\t\tcopyResourceUnixGid.setValue(groupUnixGid.getValue());\n-\t\treturn getPerunBl().getResourcesManagerBl().getResourcesByAttribute(sess, copyResourceUnixGid);\n-\t}\n-\n-\tpublic List<Group> findCollisionGroupsWithSamgeGroupGid(PerunSessionImpl sess, Resource resource, String namespace) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException {\n-\t\tUtils.notNull(sess, \"perunSessionImpl\");\n-\t\tUtils.notNull(resource, \"resource\");\n-\t\tUtils.notNull(namespace, \"namespace\");\n-\t\tAttribute resourceUnixGid = getPerunBl().getAttributesManagerBl().getAttribute(sess, resource, A_R_unixGID_namespace + \":\" + namespace);\n-\t\tAttribute copyGroupUnixGid = new Attribute(getPerunBl().getAttributesManagerBl().getAttributeDefinition(sess, A_G_unixGID_namespace + \":\" + namespace));\n-\t\tcopyGroupUnixGid.setValue(resourceUnixGid.getValue());\n-\t\treturn getPerunBl().getGroupsManagerBl().getGroupsByAttribute(sess, copyGroupUnixGid);\n-\t}\n-\n-\tpublic List<Group> findCollisionGroupsWithSamgeGroupGid(PerunSessionImpl sess, Group group, String namespace) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException {\n-\t\tUtils.notNull(sess, \"perunSessionImpl\");\n-\t\tUtils.notNull(group, \"group\");\n-\t\tUtils.notNull(namespace, \"namespace\");\n-\t\tAttribute groupUnixGid = getPerunBl().getAttributesManagerBl().getAttribute(sess, group, A_G_unixGID_namespace + \":\" + namespace);\n-\t\tList<Group> groupsWithSameUnixGid = getPerunBl().getGroupsManagerBl().getGroupsByAttribute(sess, groupUnixGid);\n-\t\tgroupsWithSameUnixGid.remove(group);\n-\t\treturn groupsWithSameUnixGid;\n-\t}\n-\n-\tpublic boolean hasAccessToWriteToAttributeForAnyResource(PerunSessionImpl sess, AttributeDefinition attrDef, List<Resource> resources) throws InternalErrorException {\n-\t\tUtils.notNull(sess, \"perunSessionImpl\");\n-\t\tUtils.notNull(attrDef, \"attributeDefinition\");\n-\t\tif(resources == null || resources.isEmpty()) return false;\n-\t\tfor(Resource r: resources) {\n-\t\t\tif(AuthzResolver.isAuthorizedForAttribute(sess, ActionType.WRITE, attrDef , r, null)) return true;\n-\t\t}\n-\t\treturn false;\n-\t}\n-\n-\tpublic boolean hasAccessToWriteToAttributeForAnyGroup(PerunSessionImpl sess, AttributeDefinition attrDef, List<Group> groups) throws InternalErrorException {\n-\t\tUtils.notNull(sess, \"perunSessionImpl\");\n-\t\tUtils.notNull(attrDef, \"attributeDefinition\");\n-\t\tif(groups == null || groups.isEmpty()) return false;\n-\t\tfor(Group g: groups) {\n-\t\t\tif(AuthzResolver.isAuthorizedForAttribute(sess, ActionType.WRITE, attrDef, g, null)) return true;\n-\t\t}\n-\t\treturn false;\n-\t}\n-\n-\tpublic Pair<Integer, Integer> getMinAndMaxGidForNamespace(PerunSessionImpl sess, String namespace) throws InternalErrorException, AttributeNotExistsException, WrongAttributeAssignmentException {\n-\t\tUtils.notNull(sess, \"perunSessionImpl\");\n-\t\tUtils.notNull(namespace, \"namespace\");\n-\t\tAttribute minGidAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, namespace, A_E_namespace_minGID);\n-\t\tInteger minGid = null;\n-\t\tif(minGidAttribute.getValue() != null) minGid = (Integer) minGidAttribute.getValue();\n-\n-\t\tAttribute maxGidAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, namespace, A_E_namespace_maxGID);\n-\t\tInteger maxGid = null;\n-\t\tif(maxGidAttribute.getValue() != null) maxGid = (Integer) maxGidAttribute.getValue();\n-\n-\t\treturn new Pair(minGid, maxGid);\n-\t}\n-\n-\tpublic Integer getFirstFreeGidForResourceOrGroup(PerunSessionImpl sess, String namespace) throws InternalErrorException, AttributeNotExistsException, WrongAttributeAssignmentException {\n-\t\tUtils.notNull(sess, \"perunSessionImpl\");\n-\t\tUtils.notNull(namespace, \"namespace\");\n-\t\tPair<Integer, Integer> minAndMaxGid = this.getMinAndMaxGidForNamespace(sess, namespace);\n-\n-\t\t//If there is no min or max gid, return null instead of number, its same like no free gid was able\n-\t\tif(minAndMaxGid == null || minAndMaxGid.getLeft() == null || minAndMaxGid.getRight() == null) return null;\n-\n-\t\tAttributeDefinition resourceUnixGid = getPerunBl().getAttributesManagerBl().getAttributeDefinition(sess, A_R_unixGID_namespace + \":\" + namespace);\n-\t\tList<Object> allGids = sess.getPerunBl().getAttributesManagerBl().getAllValues(sess, resourceUnixGid);\n-\t\tAttributeDefinition groupUnixGid = getPerunBl().getAttributesManagerBl().getAttributeDefinition(sess, A_G_unixGID_namespace + \":\" + namespace);\n-\t\tallGids.addAll(sess.getPerunBl().getAttributesManagerBl().getAllValues(sess, groupUnixGid)); //note: it doesn't matter if the group is not active (isUnixGroup attribute != 1)\n-\n-\t\tfor(int i = minAndMaxGid.getLeft(); i < minAndMaxGid.getRight(); i++) {\n-\t\t\tif(!allGids.contains(i)) {\n-\t\t\t\treturn i;\n-\t\t\t}\n-\t\t}\n-\t\treturn null;\n-\t}\n-\n-\tpublic void checkIfGIDIsWithinRange(PerunSessionImpl sess, Attribute attribute) throws InternalErrorException, WrongReferenceAttributeValueException, WrongAttributeAssignmentException, AttributeNotExistsException, WrongAttributeValueException {\n-\t\tUtils.notNull(attribute, \"attribute\");\n-\t\tInteger gid = null;\n-\t\tif(attribute.getValue() != null) gid = (Integer) attribute.getValue();\n-\n-\t\tif(gid == null) throw new WrongAttributeValueException(attribute, \"Gid with null value is not allowed.\");\n-\n-\t\tString gidNamespace = attribute.getFriendlyNameParameter();\n-\n-\t\tAttribute minGidAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, gidNamespace, A_E_namespace_minGID);\n-\t\tif(minGidAttribute.getValue() == null) throw new WrongReferenceAttributeValueException(attribute, minGidAttribute);\n-\t\tInteger minGid = (Integer) minGidAttribute.getValue();\n-\n-\t\tAttribute maxGidAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, gidNamespace, A_E_namespace_maxGID);\n-\t\tif(maxGidAttribute.getValue() == null) throw new WrongReferenceAttributeValueException(attribute, maxGidAttribute);\n-\t\tInteger maxGid = (Integer) maxGidAttribute.getValue();\n-\n-\t\tif ( gid < minGid || gid > maxGid ) {\n-\t\t\tthrow new WrongAttributeValueException(attribute,\"GID number is not in allowed values min: \"+minGid+\", max:\"+maxGid);\n-\t\t}\n-\t}\n-\n-\tpublic void checkIfListOfGIDIsWithinRange(PerunSessionImpl sess, User user, Attribute attribute) throws InternalErrorException, WrongReferenceAttributeValueException, WrongAttributeAssignmentException, AttributeNotExistsException, WrongAttributeValueException {\n-\t\tUtils.notNull(attribute, \"attribute\");\n-\t\tList<String> gIDs = (List<String>)attribute.getValue();\n-\t\tif (gIDs != null){\n-\t\t\tfor(String sGid : gIDs){\n-\t\t\t\ttry{\n-\t\t\t\t\tInteger gid = new Integer(sGid);\n-\t\t\t\t\tString gidNamespace = attribute.getFriendlyNameParameter();\n-\n-\t\t\t\t\tAttribute minGidAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, gidNamespace, A_E_namespace_minGID);\n-\t\t\t\t\tif(minGidAttribute.getValue() == null) throw new WrongReferenceAttributeValueException(attribute, minGidAttribute, \"Attribute minGid cannot be null\");\n-\t\t\t\t\tInteger minGid = (Integer) minGidAttribute.getValue();\n-\n-\t\t\t\t\tAttribute maxGidAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, gidNamespace, A_E_namespace_maxGID);\n-\t\t\t\t\tif(maxGidAttribute.getValue() == null) throw new WrongReferenceAttributeValueException(attribute, maxGidAttribute, \"Attribute maxGid cannot be null\");\n-\t\t\t\t\tInteger maxGid = (Integer) maxGidAttribute.getValue();\n-\n-\t\t\t\t\tif ( gid < minGid || gid > maxGid ) {\n-\t\t\t\t\t\tthrow new WrongAttributeValueException(attribute,\"GID number is not in allowed values min: \"+minGid+\", max:\"+maxGid);\n-\t\t\t\t\t}\n-\t\t\t\t}catch(NumberFormatException ex){\n-\t\t\t\t\tthrow new WrongAttributeValueException(attribute ,user,\"attribute is not a number\", ex);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic Integer getFreeGID(PerunSessionImpl sess, Attribute attribute) throws InternalErrorException, AttributeNotExistsException, WrongAttributeAssignmentException {\n-\t\tUtils.notNull(attribute, \"attribute\");\n-\t\tString gidNamespace = attribute.getFriendlyNameParameter();\n-\n-\t\tAttribute minGidAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, gidNamespace, A_E_namespace_minGID);\n-\t\tif(minGidAttribute.getValue() == null) return 0;\n-\t\tInteger minGid = (Integer) minGidAttribute.getValue();\n-\n-\t\tAttribute maxGidAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, gidNamespace, A_E_namespace_maxGID);\n-\t\tif(maxGidAttribute.getValue() == null) return 0;\n-\t\tInteger maxGid = (Integer) maxGidAttribute.getValue();\n-\n-\t\tList<Integer> allGids = new ArrayList<>();\n-\t\tAttribute usedGids = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, gidNamespace, A_E_usedGids);\n-\n-\t\tif(usedGids.getValue() == null) return minGid;\n-\t\telse {\n-\t\t\tMap<String,String> usedGidsValue = (Map<String, String>) usedGids.getValue();\n-\t\t\tSet<String> keys = usedGidsValue.keySet();\n-\n-\t\t\tfor(String key: keys) {\n-\t\t\t\tallGids.add(Integer.parseInt(usedGidsValue.get(key)));\n-\t\t\t}\n-\t\t}\n-\n-\t\tfor(int i = minGid; i < maxGid; i++) {\n-\t\t\tif(!allGids.contains(i)) {\n-\t\t\t\treturn i;\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn null;\n-\t}\n-\n-\tpublic Integer getCommonGIDOfGroupsWithSameNameInSameNamespace(PerunSessionImpl sess, List<Group> groupsWithSameGroupNameInSameNamespace, String gidNamespace, Integer commonGID) throws InternalErrorException, WrongAttributeAssignmentException {\n-\t\t//If there are no groups, return commonGID from param (it can be null)\n-\t\tif(groupsWithSameGroupNameInSameNamespace == null || groupsWithSameGroupNameInSameNamespace.isEmpty()) return commonGID;\n-\t\tUtils.notNull(gidNamespace, \"gidNamespace\");\n-\n-\t\tGroup commonGIDGroup = null;  //only for more verbose exception messages\n-\t\tfor(Group g: groupsWithSameGroupNameInSameNamespace) {\n-\t\t\ttry {\n-\t\t\t\tAttribute attr = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, g, A_G_unixGID_namespace + \":\" + gidNamespace);\n-\t\t\t\tif(attr.getValue() != null) {\n-\t\t\t\t\tif(commonGID == null) {\n-\t\t\t\t\t\tcommonGIDGroup = g;\n-\t\t\t\t\t\tcommonGID = (Integer) attr.getValue();\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tif(!commonGID.equals((Integer) attr.getValue())) throw new ConsistencyErrorException(\"There are at least 1 groups/resources with same GroupName in same namespace but with different GID in same namespaces. Conflict found: \"  + g + \"(gid=\" + attr.getValue()+ \") and \" + commonGIDGroup + \"(gid=\" + commonGID + \")\");\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t} catch (AttributeNotExistsException ex) {\n-\t\t\t\tthrow new ConsistencyErrorException(ex);\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn commonGID;\n-\t}\n-\n-\tpublic Integer getCommonGIDOfResourcesWithSameNameInSameNamespace(PerunSessionImpl sess, List<Resource> resourcesWithSameGroupNameInSameNamespace, String gidNamespace, Integer commonGID) throws InternalErrorException, WrongAttributeAssignmentException {\n-\t\t//If there are no resources, return commonGID from param (it can be null)\n-\t\tif(resourcesWithSameGroupNameInSameNamespace == null || resourcesWithSameGroupNameInSameNamespace.isEmpty()) return commonGID;\n-\t\tUtils.notNull(gidNamespace,\"gidNamespace\");\n-\n-\t\tResource commonGIDResource = null;   //only for more verbose exception messages\n-\t\tfor(Resource r: resourcesWithSameGroupNameInSameNamespace) {\n-\t\t\ttry {\n-\t\t\t\tAttribute attr = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, r, A_R_unixGID_namespace + \":\" + gidNamespace);\n-\t\t\t\tif(attr.getValue() != null) {\n-\t\t\t\t\tif(commonGID == null) {\n-\t\t\t\t\t\tcommonGIDResource = r;\n-\t\t\t\t\t\tcommonGID = (Integer) attr.getValue();\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tif(!commonGID.equals((Integer) attr.getValue())) throw new ConsistencyErrorException(\"There are at least 1 groups/resources with same GroupName in same namespace but with different GID in same namespaces. Conflict found: \" + r + \"(gid=\" + attr.getValue()+ \") and \" + commonGIDResource + \"(gid=\" + commonGID + \")\");\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t} catch (AttributeNotExistsException ex) {\n-\t\t\t\tthrow new ConsistencyErrorException(ex);\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn commonGID;\n-\t}\n-\n-\tpublic int haveTheSameAttributeWithTheSameNamespace(PerunSessionImpl sess, Group group, Attribute attr) throws InternalErrorException, WrongAttributeAssignmentException {\n-\t\tUtils.notNull(group, \"group\");\n-\t\tUtils.notNull(attr, \"attr\");\n-\n-\t\tString attributeNamespace = attr.getFriendlyNameParameter();\n-\t\tif(attributeNamespace == null || attributeNamespace.isEmpty()) throw new InternalErrorException(\"Attribute has no namespace, this method can't be use.\");\n-\n-\t\ttry {\n-\t\t\tAttribute testingAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, group, attr.getName());\n-\t\t\tif(testingAttribute.getValue() == null) return -1;\n-\t\t\telse {\n-\t\t\t\tif(!testingAttribute.getValue().equals(attr.getValue())) return 1;\n-\t\t\t}\n-\t\t} catch (AttributeNotExistsException ex) {\n-\t\t\tthrow new ConsistencyErrorException(ex);\n-\t\t}\n-\t\treturn 0;\n-\t}\n-\n-\tpublic int haveTheSameAttributeWithTheSameNamespace(PerunSessionImpl sess, Resource resource, Attribute attr) throws InternalErrorException, WrongAttributeAssignmentException{\n-\t\tUtils.notNull(resource, \"resource\");\n-\t\tUtils.notNull(attr, \"attr\");\n-\n-\t\tString attributeNamespace = attr.getFriendlyNameParameter();\n-\t\tif(attributeNamespace == null || attributeNamespace.isEmpty()) throw new InternalErrorException(\"Attribute has no namespace, this method can't be use.\");\n-\n-\t\ttry {\n-\t\t\tAttribute testingAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, resource, attr.getName());\n-\t\t\tif(testingAttribute.getValue() == null) return -1;\n-\t\t\telse {\n-\t\t\t\tif(!testingAttribute.getValue().equals(attr.getValue())) return 1;\n-\t\t\t}\n-\t\t} catch (AttributeNotExistsException ex) {\n-\t\t\tthrow new ConsistencyErrorException(ex);\n-\t\t}\n-\t\treturn 0;\n-\t}\n-\n-\tpublic boolean haveRightToWriteAttributeInAnyGroupOrResource(PerunSessionImpl sess, List<Group> groups, List<Resource> resources, AttributeDefinition groupAttribute, AttributeDefinition resourceAttribute) throws InternalErrorException {\n-\t\tif(groups != null && !groups.isEmpty() && groupAttribute != null) {\n-\t\t\tfor(Group g: groups) {\n-\t\t\t\tif(AuthzResolver.isAuthorizedForAttribute(sess, ActionType.WRITE, groupAttribute, g, null)) return true;\n-\t\t\t}\n-\t\t}\n-\n-\t\tif(resources != null && !resources.isEmpty() && resourceAttribute != null) {\n-\t\t\tfor(Resource r: resources) {\n-\t\t\t\tif(AuthzResolver.isAuthorizedForAttribute(sess, ActionType.WRITE, resourceAttribute, r, null)) return true;\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn false;\n-\t}\n-\n-\tpublic List<Attribute> getListOfResourceGIDsFromListOfGroupGIDs(PerunSessionImpl sess, List<Attribute> groupGIDs) throws InternalErrorException, AttributeNotExistsException {\n-\t\tList<Attribute> resourceGIDs = new ArrayList<Attribute>();\n-\t\tif(groupGIDs == null || groupGIDs.isEmpty()) {\n-\t\t\treturn resourceGIDs;\n-\t\t}\n-\n-\t\tfor(Attribute a: groupGIDs) {\n-\t\t\tAttribute resourceGID = new Attribute(sess.getPerunBl().getAttributesManagerBl().getAttributeDefinition(sess, A_R_unixGID_namespace + \":\" + a.getFriendlyNameParameter()));\n-\t\t\tresourceGID.setValue(a.getValue());\n-\t\t\tresourceGIDs.add(resourceGID);\n-\t\t}\n-\n-\t\treturn resourceGIDs;\n-\t}\n-\n-\tpublic List<Attribute> getListOfGroupGIDsFromListOfResourceGIDs(PerunSessionImpl sess, List<Attribute> resourceGIDs) throws InternalErrorException, AttributeNotExistsException {\n-\t\tList<Attribute> groupGIDs = new ArrayList<Attribute>();\n-\t\tif(resourceGIDs == null || resourceGIDs.isEmpty()) {\n-\t\t\treturn groupGIDs;\n-\t\t}\n-\n-\t\tfor(Attribute a: resourceGIDs) {\n-\t\t\tAttribute groupGID = new Attribute(sess.getPerunBl().getAttributesManagerBl().getAttributeDefinition(sess, A_G_unixGID_namespace + \":\" + a.getFriendlyNameParameter()));\n-\t\t\tgroupGID.setValue(a.getValue());\n-\t\t\tgroupGIDs.add(groupGID);\n-\t\t}\n-\n-\t\treturn groupGIDs;\n-\t}\n-\n-\tpublic Set<String> getSetOfGIDNamespacesWhereFacilitiesHasTheSameGroupNameNamespace(PerunSessionImpl sess, List<Facility> facilities, Attribute unixGroupNameNamespace) throws InternalErrorException, WrongAttributeAssignmentException, WrongReferenceAttributeValueException {\n-\t\tSet<String> gidNamespaces = new HashSet<String>();\n-\t\tif(facilities == null || facilities.isEmpty()) return gidNamespaces;\n-\t\tUtils.notNull(facilities, \"facilities\");\n-\n-\t\tfor(Facility f: facilities) {\n-\t\t\tAttribute facilityGroupNameNamespace;\n-\t\t\ttry {\n-\t\t\t\tfacilityGroupNameNamespace = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, f, A_F_unixGroupName_namespace);\n-\t\t\t\tif(facilityGroupNameNamespace.getValue() != null) {\n-\t\t\t\t\t//if they are same, save GID-namespace from this facility to hashSet\n-\t\t\t\t\tif(unixGroupNameNamespace.getFriendlyNameParameter().equals((String) facilityGroupNameNamespace.getValue())) {\n-\t\t\t\t\t\tAttribute facilityGIDNamespace = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, f, A_F_unixGID_namespace);\n-\t\t\t\t\t\t//If facilityGIDNamespace exists and is not null, save to the hashSet of gidNamespaces\n-\t\t\t\t\t\tif(facilityGIDNamespace.getValue() != null) {\n-\t\t\t\t\t\t\tgidNamespaces.add((String) facilityGIDNamespace.getValue());\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t} catch (AttributeNotExistsException ex) {\n-\t\t\t\tthrow new ConsistencyErrorException(ex);\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn gidNamespaces;\n-\t}\n-\n-\tpublic Set<String> getSetOfGroupNameNamespacesWhereFacilitiesHasTheSameGIDNamespace(PerunSessionImpl sess, List<Facility> facilities, Attribute unixGIDNamespace) throws InternalErrorException, WrongAttributeAssignmentException, WrongReferenceAttributeValueException {\n-\t\tSet<String> groupNameNamespaces = new HashSet<String>();\n-\t\tif(facilities == null || facilities.isEmpty()) return groupNameNamespaces;\n-\t\tUtils.notNull(unixGIDNamespace, \"unixGIDNamespace\");\n-\n-\t\tfor(Facility f: facilities) {\n-\t\t\tAttribute facilityGIDNamespace;\n-\t\t\ttry {\n-\t\t\t\tfacilityGIDNamespace = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, f, A_F_unixGID_namespace);\n-\t\t\t\tif(facilityGIDNamespace.getValue() != null) {\n-\t\t\t\t\t//if they are same, save GroupName-namespace from this facility to hashSet\n-\t\t\t\t\tif(unixGIDNamespace.getFriendlyNameParameter().equals((String) facilityGIDNamespace.getValue())) {\n-\t\t\t\t\t\tAttribute facilityGroupNameNamespace = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, f, A_F_unixGroupName_namespace);\n-\t\t\t\t\t\t//If facilityGroupNameNamespace exists and is not null, save to the hashSet of gidNamespaces\n-\t\t\t\t\t\tif(facilityGroupNameNamespace.getValue() != null) {\n-\t\t\t\t\t\t\tgroupNameNamespaces.add((String) facilityGroupNameNamespace.getValue());\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tthrow new WrongReferenceAttributeValueException(unixGIDNamespace, facilityGroupNameNamespace, \"Facility has gidNamespace set, but groupNameNamespace not set.\");\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t} catch (AttributeNotExistsException ex) {\n-\t\t\t\tthrow new ConsistencyErrorException(ex);\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn groupNameNamespaces;\n-\t}\n-\n-\tpublic void checkReservedUnixGroupNames(Attribute groupNameAttribute) throws InternalErrorException, WrongAttributeValueException {\n-\t\tif(groupNameAttribute == null) return;\n-\t\tcheckPerunNamespacesMap();\n-\n-\t\tString reservedNames = perunNamespaces.get(groupNameAttribute.getFriendlyName() + \":reservedNames\");\n-\t\tif (reservedNames != null) {\n-\t\t\tList<String> reservedNamesList = Arrays.asList(reservedNames.split(\"\\\\s*,\\\\s*\"));\n-\t\t\tif (reservedNamesList.contains(groupNameAttribute.getValue()))\n-\t\t\t\tthrow new WrongAttributeValueException(groupNameAttribute, \"This groupName is reserved.\");\n-\t\t} else {\n-\t\t\t//Property not found in our attribute map, so we will use the default hardcoded values instead\n-\t\t\tif (reservedNamesForUnixGroups.contains(groupNameAttribute.getValue()))\n-\t\t\t\tthrow new WrongAttributeValueException(groupNameAttribute, \"This groupName is reserved.\");\n-\t\t}\n-\t}\n-\n-\tpublic void checkUnpermittedUserLogins(Attribute loginAttribute) throws InternalErrorException, WrongAttributeValueException {\n-\t\tif(loginAttribute == null) return;\n-\t\tcheckPerunNamespacesMap();\n-\n-\t\tString unpermittedNames = perunNamespaces.get(loginAttribute.getFriendlyName() + \":reservedNames\");\n-\t\tif (unpermittedNames != null) {\n-\t\t\tList<String> unpermittedNamesList = Arrays.asList(unpermittedNames.split(\"\\\\s*,\\\\s*\"));\n-\t\t\tif (unpermittedNamesList.contains(loginAttribute.getValue()))\n-\t\t\t\tthrow new WrongAttributeValueException(loginAttribute, \"This login is not permitted.\");\n-\t\t} else {\n-\t\t\t//Property not found in our attribute map, so we will use the default hardcoded values instead\n-\t\t\tif (unpermittedNamesForUserLogins.contains(loginAttribute.getValue()))\n-\t\t\t\tthrow new WrongAttributeValueException(loginAttribute, \"This login is not permitted.\");\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic Attribute getGoogleGroupNameNamespaceAttributeWithNotNullValue(PerunSessionImpl sess, Resource resource) throws InternalErrorException, WrongReferenceAttributeValueException {\n-\t\tFacility facility = sess.getPerunBl().getResourcesManagerBl().getFacility(sess, resource);\n-\t\ttry {\n-\t\t\tAttribute googleGroupNameNamespaceAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, facility, A_F_googleGroupName_namespace);\n-\t\t\tif(googleGroupNameNamespaceAttribute.getValue() == null) throw new WrongReferenceAttributeValueException(googleGroupNameNamespaceAttribute);\n-\t\t\treturn googleGroupNameNamespaceAttribute;\n-\t\t} catch(AttributeNotExistsException ex) {\n-\t\t\tthrow new ConsistencyErrorException(ex);\n-\t\t} catch(WrongAttributeAssignmentException ex) {\n-\t\t\tthrow new InternalErrorException(ex);\n-\t\t}\n-\t}\n-\n-\tpublic Attribute getUnixGroupNameNamespaceAttributeWithNotNullValue(PerunSessionImpl sess, Resource resource) throws InternalErrorException, WrongReferenceAttributeValueException {\n-\t\tFacility facility = sess.getPerunBl().getResourcesManagerBl().getFacility(sess, resource);\n-\t\ttry {\n-\t\t\tAttribute unixGroupNameNamespaceAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, facility, A_F_unixGroupName_namespace);\n-\t\t\tif(unixGroupNameNamespaceAttribute.getValue() == null) throw new WrongReferenceAttributeValueException(unixGroupNameNamespaceAttribute);\n-\t\t\treturn unixGroupNameNamespaceAttribute;\n-\t\t} catch(AttributeNotExistsException ex) {\n-\t\t\tthrow new ConsistencyErrorException(ex);\n-\t\t} catch(WrongAttributeAssignmentException ex) {\n-\t\t\tthrow new InternalErrorException(ex);\n-\t\t}\n-\t}\n-\n-\tpublic Attribute getUnixGIDNamespaceAttributeWithNotNullValue(PerunSessionImpl sess, Resource resource) throws InternalErrorException, WrongReferenceAttributeValueException {\n-\t\tFacility facility = sess.getPerunBl().getResourcesManagerBl().getFacility(sess, resource);\n-\t\ttry {\n-\t\t\tAttribute unixGIDNamespaceAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, facility, A_F_unixGID_namespace);\n-\t\t\tif(unixGIDNamespaceAttribute.getValue() == null) throw new WrongReferenceAttributeValueException(unixGIDNamespaceAttribute);\n-\t\t\treturn unixGIDNamespaceAttribute;\n-\t\t} catch(AttributeNotExistsException ex) {\n-\t\t\tthrow new ConsistencyErrorException(ex);\n-\t\t} catch(WrongAttributeAssignmentException ex) {\n-\t\t\tthrow new InternalErrorException(ex);\n-\t\t}\n-\t}\n-\n-\tpublic boolean isGroupUnixGIDNamespaceFillable(PerunSessionImpl sess, Group group, Attribute groupUnixGIDNamespace) throws InternalErrorException, WrongReferenceAttributeValueException, WrongAttributeAssignmentException {\n-\t\tUtils.notNull(group, \"group\");\n-\t\tUtils.notNull(groupUnixGIDNamespace, \"groupUnixGIDNamespace\");\n-\n-\t\t//Get All Facilities from group\n-\t\tSet<Facility> facilitiesOfGroup = new HashSet<Facility>();\n-\t\tList<Resource> resourcesOfGroup = sess.getPerunBl().getResourcesManagerBl().getAssignedResources(sess, group);\n-\t\tfor(Resource r: resourcesOfGroup) {\n-\t\t\tfacilitiesOfGroup.add(sess.getPerunBl().getResourcesManagerBl().getFacility(sess, r));\n-\t\t}\n-\n-\t\t//Prepare list of gid namespaces of all facilities which have the same groupName namespace like this unixGroupName namespace\n-\t\tSet<String> groupNameNamespaces = this.getSetOfGroupNameNamespacesWhereFacilitiesHasTheSameGIDNamespace(sess, new ArrayList<Facility>(facilitiesOfGroup), groupUnixGIDNamespace);\n-\n-\t\tif(!groupNameNamespaces.isEmpty()) {\n-\t\t\tfor(String s: groupNameNamespaces) {\n-\t\t\t\ttry {\n-\t\t\t\t\tAttribute groupNameNamespace = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, group, A_G_unixGroupName_namespace + \":\" + s);\n-\t\t\t\t\tif(groupNameNamespace.getValue() != null) {\n-\t\t\t\t\t\treturn true;\n-\t\t\t\t\t}\n-\t\t\t\t} catch (AttributeNotExistsException ex) {\n-\t\t\t\t\tthrow new ConsistencyErrorException(ex);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn false;\n-\t}\n-\n-\t@Override\n-\tpublic boolean isNameOfEmailValid(PerunSessionImpl sess, String email) {\n-\t\tif (email == null) return false;\n-\n-\t\tMatcher emailMatcher = Utils.emailPattern.matcher(email);\n-\t\tif (emailMatcher.find()) return true;\n-\n-\t\treturn false;\n-\t}\n-\n-\tpublic void checkFormatOfShell(String shell, Attribute attribute) throws WrongAttributeValueException {\n-\t\t//previous regex ^/[-a-zA-Z0-9_/]*$\"\n-\t\tPattern pattern = Pattern.compile(\"^(/[-_a-zA-Z0-9]+)+$\");\n-\n-\t\tMatcher match = pattern.matcher(shell);\n-\n-\t\tif (!match.matches()) {\n-\t\t\tthrow new WrongAttributeValueException(attribute, \"Bad shell attribute format \" + shell);\n-\t\t}\n-\t}\n-\n-\tpublic void checkAttributeRegex(Attribute attribute, String defaultRegex) throws InternalErrorException, WrongAttributeValueException {\n-\t\tif (attribute == null || attribute.getValue() == null) throw new InternalErrorException(\"Attribute or it's value is null.\");\n-\t\tString attributeValue = (String) attribute.getValue();\n-\t\tcheckPerunNamespacesMap();\n-\n-\t\tString regex = perunNamespaces.get(attribute.getFriendlyName() + \":regex\");\n-\t\tif (regex != null) {\n-\t\t\t//Check if regex is valid\n-\t\t\ttry {\n-\t\t\t\tPattern.compile(regex);\n-\t\t\t} catch (PatternSyntaxException e) {\n-\t\t\t\tlog.error(\"Regex pattern \\\"\" + regex + \"\\\" from \\\"\" + attribute.getFriendlyName() + \":regex\\\"\" + \" property of perun-namespaces.properties file is invalid.\");\n-\t\t\t\tthrow new InternalErrorException(\"Regex pattern \\\"\" + regex + \"\\\" from \\\"\" + attribute.getFriendlyName() + \":regex\\\"\" + \" property of perun-namespaces.properties file is invalid.\");\n-\t\t\t}\n-\t\t\tif(!attributeValue.matches(regex)) {\n-\t\t\t\tthrow new WrongAttributeValueException(attribute, \"Wrong format. Regex: \\\"\" + regex +\"\\\" expected for this attribute:\");\n-\t\t\t}\n-\t\t} else {\n-\t\t\t//Regex property not found in our attribute map, so use the default hardcoded regex\n-\t\t\tif (defaultRegex == null) return;\n-\t\t\tif (!attributeValue.matches(defaultRegex)) {\n-\t\t\t\tthrow new WrongAttributeValueException(attribute, \"Wrong format. Regex: \\\"\" + defaultRegex +\"\\\" expected for this attribute:\");\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Internal protected method.\n-\t * Checks this.perunNamespaces map, which is always initialized as null.\n-\t * If null, it tries to load the configuration into this map from a perun-namespaces.properties file.\n-\t * If the file does not exist, it creates an empty HashMap, so it's not null anymore.\n-\t */\n-\tprotected void checkPerunNamespacesMap() {\n-\t\tif (perunNamespaces == null) {\n-\t\t\ttry {\n-\t\t\t\tperunNamespaces = BeansUtils.getAllPropertiesFromCustomConfiguration(\"perun-namespaces.properties\");\n-\t\t\t} catch (InternalErrorException e) {\n-\t\t\t\tperunNamespaces = new HashMap<>();\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic Map<String, Pair<BigDecimal, BigDecimal>> checkAndTransferQuotas(Attribute quotasAttribute, PerunBean firstPlaceholder, PerunBean secondPlaceholder, boolean withMetrics) throws InternalErrorException, WrongAttributeValueException {\n-\t\t//firstPlaceholder can't be null\n-\t\tif(firstPlaceholder == null) throw new InternalErrorException(\"Missing first mandatory placeHolder (PerunBean).\");\n-\t\t//Quotas attribute must exists with not null value\n-\t\tif(quotasAttribute == null || quotasAttribute.getValue() == null) throw new InternalErrorException(\"Attribute quotas for checking and transfering can't be null.\");\n-\n-\t\t//Prepare result container and value of attribute\n-\t\tMap<String, Pair<BigDecimal, BigDecimal>> transferedQuotas = new HashMap<>();\n-\t\tMap<String, String> defaultQuotasMap = (Map<String, String>) quotasAttribute.getValue();\n-\n-\t\t//List to test if all paths are unique (/var/log and /var/log/ are the same so these two paths are not unique)\n-\t\tList<String> uniquePaths = new ArrayList<>();\n-\t\tfor(String path: defaultQuotasMap.keySet()) {\n-\t\t\t//null is not correct path for volume on File System\n-\t\t\tif(path == null || path.isEmpty()) throw new WrongAttributeValueException(quotasAttribute, firstPlaceholder, secondPlaceholder, \"The path of some volume where quota should be set is null.\");\n-\n-\t\t\t//testing if path is unique\n-\t\t\tString canonicalPath;\n-\t\t\ttry {\n-\t\t\t\tcanonicalPath = new URI(path).normalize().getPath();\n-\t\t\t\tif(!canonicalPath.endsWith(\"/\")) canonicalPath = canonicalPath.concat(\"/\");\n-\t\t\t} catch (URISyntaxException ex) {\n-\t\t\t\tthrow new WrongAttributeValueException(quotasAttribute, firstPlaceholder, secondPlaceholder, \"Path '\" + path + \"' is not correct form.\");\n-\t\t\t}\n-\n-\t\t\tif(uniquePaths.contains(canonicalPath)) throw new WrongAttributeValueException(quotasAttribute, firstPlaceholder, secondPlaceholder, \"Paths are not unique, there are two same paths: \" + path);\n-\t\t\telse uniquePaths.add(canonicalPath);\n-\n-\t\t\tString quota = defaultQuotasMap.get(path);\n-\t\t\t//quota can't be null, if exists in attribute, must be set in some way\n-\t\t\tif(quota == null) throw new WrongAttributeValueException(quotasAttribute, firstPlaceholder, secondPlaceholder, \"The quota of some volume where quota should be set is null.\");\n-\n-\t\t\t//check format of quota parameter (for data with metrics, for count of files without metrics)\n-\t\t\tMatcher quotaMatcher;\n-\t\t\tif(withMetrics) {\n-\t\t\t\tquotaMatcher = ModulesUtilsBlImpl.quotaWithMetricsPattern.matcher(quota);\n-\t\t\t\tif(!quotaMatcher.matches()) throw new WrongAttributeValueException(quotasAttribute, firstPlaceholder, secondPlaceholder, \"Format of quota in quotas attribute is not correct.\");\n-\t\t\t} else {\n-\t\t\t\tquotaMatcher = ModulesUtilsBlImpl.quotaWithoutMetricsPattern.matcher(quota);\n-\t\t\t\tif(!quotaMatcher.matches()) throw new WrongAttributeValueException(quotasAttribute, firstPlaceholder, secondPlaceholder, \"Format of quota in quotas attribute is not correct.\");\n-\t\t\t}\n-\n-\t\t\t//Parse quotas to variables\n-\t\t\tString softQuota = quotaMatcher.group(1);\n-\t\t\tString hardQuota = quotaMatcher.group(3);\n-\n-\t\t\t//Parse number pattern and letter pattern from whole quotas\n-\n-\t\t\t//SoftQuotaNumber\n-\t\t\tBigDecimal softQuotaAfterTransfer;\n-\t\t\tBigDecimal hardQuotaAfterTransfer;\n-\t\t\t//special behavior with metrics\n-\t\t\tif(withMetrics) {\n-\t\t\t\tString softQuotaNumber = null;\n-\t\t\t\tMatcher numberMatcher = numberPattern.matcher(softQuota);\n-\t\t\t\tif(!numberMatcher.find()) throw new ConsistencyErrorException(\"Matcher can't find number in softQuota '\" + softQuota + \"' in attribute \" + quotasAttribute);\n-\t\t\t\tsoftQuotaNumber = numberMatcher.group();\n-\n-\t\t\t\t//SoftQuotaLetter\n-\t\t\t\tString softQuotaLetter = null;\n-\t\t\t\tMatcher letterMatcher = letterPattern.matcher(softQuota);\n-\t\t\t\t//in this case no letter means default and default is G\n-\t\t\t\tif(!letterMatcher.find()) softQuotaLetter = \"G\";\n-\t\t\t\telse softQuotaLetter = letterMatcher.group();\n-\n-\t\t\t\t//HardQuotaNumber\n-\t\t\t\tString hardQuotaNumber = null;\n-\t\t\t\tnumberMatcher = numberPattern.matcher(hardQuota);\n-\t\t\t\tif(!numberMatcher.find()) throw new ConsistencyErrorException(\"Matcher can't find number in hardQuota '\" + hardQuota + \"' in attribute \" + quotasAttribute);\n-\t\t\t\thardQuotaNumber = numberMatcher.group();\n-\n-\t\t\t\t//HardQuotaLetter\n-\t\t\t\tString hardQuotaLetter;\n-\t\t\t\tletterMatcher = letterPattern.matcher(hardQuota);\n-\t\t\t\t//in this case no letter means default and default is G\n-\t\t\t\tif(!letterMatcher.find()) hardQuotaLetter = \"G\";\n-\t\t\t\telse hardQuotaLetter = letterMatcher.group();\n-\n-\t\t\t\t//Prepare whole big decimal numbers\n-\t\t\t\tsoftQuotaAfterTransfer = new BigDecimal(softQuotaNumber);\n-\t\t\t\thardQuotaAfterTransfer = new BigDecimal(hardQuotaNumber);\n-\n-\t\t\t\t//multiplying for softQuota\n-\t\t\t\tswitch (softQuotaLetter) {\n-\t\t\t\t\tcase \"K\":\n-\t\t\t\t\t\tbreak; //K is basic metric, no need to multiply it\n-\t\t\t\t\tcase \"G\":\n-\t\t\t\t\t\tsoftQuotaAfterTransfer = softQuotaAfterTransfer.multiply(BigDecimal.valueOf(G));\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\tcase \"M\":\n-\t\t\t\t\t\tsoftQuotaAfterTransfer = softQuotaAfterTransfer.multiply(BigDecimal.valueOf(M));\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\tcase \"T\":\n-\t\t\t\t\t\tsoftQuotaAfterTransfer = softQuotaAfterTransfer.multiply(BigDecimal.valueOf(T));\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\tcase \"P\":\n-\t\t\t\t\t\tsoftQuotaAfterTransfer = softQuotaAfterTransfer.multiply(BigDecimal.valueOf(P));\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\tcase \"E\":\n-\t\t\t\t\t\tsoftQuotaAfterTransfer = softQuotaAfterTransfer.multiply(BigDecimal.valueOf(E));\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\tdefault:\n-\t\t\t\t\t\tthrow new ConsistencyErrorException(\"There is not allowed character in soft quota letter '\" + softQuotaLetter + \"'.\");\n-\t\t\t\t}\n-\n-\t\t\t\t//multiplying for softQuota\n-\t\t\t\tswitch (hardQuotaLetter) {\n-\t\t\t\t\tcase \"K\":\n-\t\t\t\t\t\tbreak; //K is basic metric, no need to multiply it\n-\t\t\t\t\tcase \"G\":\n-\t\t\t\t\t\thardQuotaAfterTransfer = hardQuotaAfterTransfer.multiply(BigDecimal.valueOf(G));\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\tcase \"M\":\n-\t\t\t\t\t\thardQuotaAfterTransfer = hardQuotaAfterTransfer.multiply(BigDecimal.valueOf(M));\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\tcase \"T\":\n-\t\t\t\t\t\thardQuotaAfterTransfer = hardQuotaAfterTransfer.multiply(BigDecimal.valueOf(T));\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\tcase \"P\":\n-\t\t\t\t\t\thardQuotaAfterTransfer = hardQuotaAfterTransfer.multiply(BigDecimal.valueOf(P));\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\tcase \"E\":\n-\t\t\t\t\t\thardQuotaAfterTransfer = hardQuotaAfterTransfer.multiply(BigDecimal.valueOf(E));\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\tdefault:\n-\t\t\t\t\t\tthrow new ConsistencyErrorException(\"There is not allowed character in hard quota letter '\" + hardQuotaLetter + \"'.\");\n-\t\t\t\t}\n-\t\t\t//easy way without metrics\n-\t\t\t} else {\n-\t\t\t\tsoftQuotaAfterTransfer = new BigDecimal(softQuota);\n-\t\t\t\thardQuotaAfterTransfer = new BigDecimal(hardQuota);\n-\t\t\t}\n-\n-\t\t\t//test comparing softQuota and hardQuota (softQuota must be less or equals than hardQuota, 0 means unlimited)\n-\t\t\t//1] if softQuota is unlimited, but hardQuota not = exception\n-\t\t\tif(softQuotaAfterTransfer.compareTo(BigDecimal.valueOf(0)) == 0 && hardQuotaAfterTransfer.compareTo(BigDecimal.valueOf(0)) != 0) {\n-\t\t\t\tthrow new WrongAttributeValueException(quotasAttribute, firstPlaceholder, secondPlaceholder, \"SoftQuota is set to unlimited (0) but hardQuota is limited to '\" + hardQuota + \"'.\");\n-\t\t\t//2] if hardQuota is not unlimited but still it is less then softQuota = exception\n-\t\t\t} else if(hardQuotaAfterTransfer.compareTo(BigDecimal.valueOf(0)) != 0 && hardQuotaAfterTransfer.compareTo(softQuotaAfterTransfer) < 0) {\n-\t\t\t\tthrow new WrongAttributeValueException(quotasAttribute, firstPlaceholder, secondPlaceholder, \"One of quotas is not correct. HardQuota '\" + hardQuota + \"' is less then softQuota '\" + softQuota + \"'.\");\n-\t\t\t}\n-\t\t\t//other cases are ok\n-\n-\t\t\ttransferedQuotas.put(canonicalPath, new Pair(softQuotaAfterTransfer, hardQuotaAfterTransfer));\n-\t\t}\n-\n-\t\treturn transferedQuotas;\n-\t}\n-\n-\t@Override\n-\tpublic Map<String, String> transferQuotasBackToAttributeValue(Map<String, Pair<BigDecimal, BigDecimal>> transferedQuotasMap, boolean withMetrics) throws InternalErrorException {\n-\t\tMap<String, String> attributeQuotasValue = new HashMap<>();\n-\t\t//if null or empty, return empty attribute value map for quotas\n-\t\tif(transferedQuotasMap == null || transferedQuotasMap.isEmpty()) return attributeQuotasValue;\n-\n-\t\t//every path with quotas transfer step by step\n-\t\tfor(String path: transferedQuotasMap.keySet()) {\n-\t\t\tPair<BigDecimal, BigDecimal> quotas =  transferedQuotasMap.get(path);\n-\t\t\tBigDecimal softQuotaBD = quotas.getLeft();\n-\t\t\tBigDecimal hardQuotaBD = quotas.getRight();\n-\n-\t\t\t//Divide decimal till it is still natural number\n-\t\t\t//Soft Quota\n-\t\t\tString softQuota = \"0\";\n-\t\t\t//Zero means unlimited, stay the same\n-\t\t\tif(softQuotaBD.compareTo(BigDecimal.ZERO) != 0) {\n-\t\t\t\tif(withMetrics) softQuota = Utils.bigDecimalBytesToReadableStringWithMetric(softQuotaBD);\n-\t\t\t\telse softQuota = softQuotaBD.toPlainString();\n-\t\t\t}\n-\t\t\t//Hard Quota\n-\t\t\tString hardQuota = \"0\";\n-\t\t\t//Zero means unlimited, stay the same\n-\t\t\tif(hardQuotaBD.compareTo(BigDecimal.ZERO) != 0) {\n-\t\t\t\tif(withMetrics) hardQuota = Utils.bigDecimalBytesToReadableStringWithMetric(hardQuotaBD);\n-\t\t\t\telse hardQuota = hardQuotaBD.toPlainString();\n-\t\t\t}\n-\n-\t\t\t//add softQuota and hardQuota to result (50T:60T)\n-\t\t\tattributeQuotasValue.put(path, softQuota + \":\" + hardQuota);\n-\t\t}\n-\t\treturn attributeQuotasValue;\n-\t}\n-\n-\t@Override\n-\tpublic Map<String,Pair<BigDecimal, BigDecimal>> mergeMemberAndResourceTransferedQuotas(Map<String, Pair<BigDecimal, BigDecimal>> firstQuotas, Map<String, Pair<BigDecimal, BigDecimal>> secondQuotas) {\n-\t\t//if one of them is empty, return the other one (even if it is empty too)\n-\t\tif(firstQuotas.isEmpty()) return secondQuotas;\n-\t\tif(secondQuotas.isEmpty()) return firstQuotas;\n-\n-\t\tMap<String,Pair<BigDecimal, BigDecimal>> mergedTransferedQuotas = new HashMap<>();\n-\t\t//first go through firstQuotas values\n-\t\tfor(String path: firstQuotas.keySet()) {\n-\t\t\tPair<BigDecimal, BigDecimal> newValue;\n-\t\t\tPair<BigDecimal, BigDecimal> firstQuotasValue = firstQuotas.get(path);\n-\t\t\tPair<BigDecimal, BigDecimal> secondQuotasValue = secondQuotas.get(path);\n-\n-\t\t\t//if there is no values for merge, use them\n-\t\t\tif(secondQuotasValue == null) {\n-\t\t\t\tnewValue = firstQuotasValue;\n-\t\t\t\tmergedTransferedQuotas.put(path, newValue);\n-\t\t\t//if there are values to merge, merge them\n-\t\t\t} else {\n-\t\t\t\tBigDecimal softQuota;\n-\t\t\t\tBigDecimal hardQuota;\n-\t\t\t\t//merge softQuota\n-\t\t\t\tif(firstQuotasValue.getLeft().compareTo(new BigDecimal(\"0\")) == 0 || secondQuotasValue.getLeft().compareTo(new BigDecimal(\"0\")) == 0) softQuota = new BigDecimal(\"0\");\n-\t\t\t\telse {\n-\t\t\t\t\tif(firstQuotasValue.getLeft().compareTo(secondQuotasValue.getLeft()) >= 0) softQuota = firstQuotasValue.getLeft();\n-\t\t\t\t\telse softQuota = secondQuotasValue.getLeft();\n-\t\t\t\t}\n-\t\t\t\t//merge hardQuota\n-\t\t\t\tif(firstQuotasValue.getRight().compareTo(new BigDecimal(\"0\")) == 0 || secondQuotasValue.getRight().compareTo(new BigDecimal(\"0\")) == 0) hardQuota = new BigDecimal(\"0\");\n-\t\t\t\telse {\n-\t\t\t\t\tif(firstQuotasValue.getRight().compareTo(secondQuotasValue.getRight()) >= 0) hardQuota = firstQuotasValue.getRight();\n-\t\t\t\t\telse hardQuota = secondQuotasValue.getRight();\n-\t\t\t\t}\n-\t\t\t\t//set new merged values\n-\t\t\t\tnewValue = new Pair(softQuota, hardQuota);\n-\t\t\t\tmergedTransferedQuotas.put(path, newValue);\n-\t\t\t\t//remove them from second quotas (they are not unique)\n-\t\t\t\tsecondQuotas.remove(path);\n-\t\t\t}\n-\t\t}\n-\t\t//save rest of values from secondQuotas (only unique in second quotas are still there, not exists in first quotas)\n-\t\tfor(String path: secondQuotas.keySet()) {\n-\t\t\tmergedTransferedQuotas.put(path, secondQuotas.get(path));\n-\t\t}\n-\n-\t\treturn mergedTransferedQuotas;\n-\t}\n-\n-\tpublic Map<String, Pair<BigDecimal, BigDecimal>> countUserFacilityQuotas(List<Map<String, Pair<BigDecimal, BigDecimal>>> allUserQuotas) {\n-\t\tMap<String, Pair<BigDecimal, BigDecimal>> resultTransferredQuotas = new HashMap<>();\n-\t\t//for every transfered map of merged quotas count one result transfered map\n-\t\tfor(Map<String, Pair<BigDecimal, BigDecimal>> mapValue : allUserQuotas) {\n-\t\t\t//for every path in one transfered map\n-\t\t\tfor(String pathKey: mapValue.keySet()) {\n-\t\t\t\t//if path not exists in result map, add it with it's values\n-\t\t\t\tif(!resultTransferredQuotas.containsKey(pathKey)) {\n-\t\t\t\t\tresultTransferredQuotas.put(pathKey, mapValue.get(pathKey));\n-\t\t\t\t//if path already exists in result map, sum their quotas together\n-\t\t\t\t} else {\n-\t\t\t\t\tPair<BigDecimal, BigDecimal> quotasValue1 = resultTransferredQuotas.get(pathKey);\n-\t\t\t\t\tPair<BigDecimal, BigDecimal> quotasValue2 = mapValue.get(pathKey);\n-\t\t\t\t\t//for soft quota (left part of pair)\n-\t\t\t\t\tBigDecimal softQuota = BigDecimal.ZERO;\n-\t\t\t\t\tif(quotasValue1.getLeft().compareTo(BigDecimal.ZERO) != 0 && quotasValue2.getLeft().compareTo(BigDecimal.ZERO) != 0) {\n-\t\t\t\t\t\tsoftQuota = quotasValue1.getLeft().add(quotasValue2.getLeft());\n-\t\t\t\t\t}\n-\t\t\t\t\t//for hard quota (right part of pair)\n-\t\t\t\t\tBigDecimal hardQuota = BigDecimal.ZERO;\n-\t\t\t\t\tif(quotasValue1.getRight().compareTo(BigDecimal.ZERO) != 0 && quotasValue2.getRight().compareTo(BigDecimal.ZERO) != 0) {\n-\t\t\t\t\t\thardQuota = quotasValue1.getRight().add(quotasValue2.getRight());\n-\t\t\t\t\t}\n-\t\t\t\t\t//create new pair of summed numbers\n-\t\t\t\t\tPair<BigDecimal, BigDecimal> finalQuotasValue = new Pair(softQuota, hardQuota);\n-\t\t\t\t\t//add new summed pair to the result map\n-\t\t\t\t\tresultTransferredQuotas.put(pathKey, finalQuotasValue);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\t//return result map\n-\t\treturn resultTransferredQuotas;\n-\t}\n-\n-\t/**\n-\t * Get list of login-namespaces which have logins generated by Perun\n-\t *\n-\t * @return List of login-namespaces with generated logins\n-\t */\n-\tpublic static List<String> getGeneratedLoginNamespaces() {\n-\n-\t\t// load namespaces to generate login for\n-\t\tList<String> namespaces;\n-\t\ttry {\n-\t\t\tString nmspc = BeansUtils.getPropertyFromConfiguration(\"perun.loginNamespace.generated\");\n-\t\t\tnamespaces = new ArrayList<String>(Arrays.asList(nmspc.split(\",\")));\n-\t\t\tIterator<String> nameIter = namespaces.listIterator();\n-\t\t\t// trim and remove empty namespaces\n-\t\t\twhile (nameIter.hasNext()) {\n-\t\t\t\tString namespace = nameIter.next();\n-\t\t\t\tnamespace = namespace.trim();\n-\t\t\t\tif (namespace.isEmpty()) nameIter.remove();\n-\t\t\t}\n-\t\t} catch (InternalErrorException ex) {\n-\t\t\t// without value\n-\t\t\treturn new ArrayList<String>();\n-\t\t}\n-\n-\t\treturn namespaces;\n-\n-\t}\n-\n-\t/**\n-\t * Normalize string for purpose of generating safe login value.\n-\t *\n-\t * @return normalized string\n-\t */\n-\tpublic static String normalizeStringForLogin(String toBeNormalized) {\n-\n-\t\tif (toBeNormalized == null || toBeNormalized.trim().isEmpty()) return null;\n-\n-\t\ttoBeNormalized = toBeNormalized.toLowerCase();\n-\t\ttoBeNormalized = java.text.Normalizer.normalize(toBeNormalized, java.text.Normalizer.Form.NFD).replaceAll(\"\\\\p{InCombiningDiacriticalMarks}+\",\"\");\n-\t\ttoBeNormalized = toBeNormalized.replaceAll(\"[^a-zA-Z]+\", \"\");\n-\n-\t\t// unable to fill login for users without name or with partial name\n-\t\tif (toBeNormalized == null || toBeNormalized.isEmpty()) {\n-\t\t\treturn null;\n-\t\t}\n-\n-\t\treturn toBeNormalized;\n-\n-\t}\n-\n-\t/**\n-\t * Shared logic for purpose of login generation\n-\t */\n-\tpublic static class LoginGenerator {\n-\n-\t\t/**\n-\t\t * Define joining function for anonymous classes\n-\t\t */\n-\t\tpublic interface LoginGeneratorFunction {\n-\n-\t\t\t/**\n-\t\t\t * Generate login for user using his name\n-\t\t\t * @param firstName\n-\t\t\t * @param lastName\n-\t\t\t * @return generated login\n-\t\t\t */\n-\t\t\tpublic String generateLogin(String firstName, String lastName);\n-\n-\t\t}\n-\n-\t\t/**\n-\t\t * Generate login for user using his name and joining function\n-\t\t *\n-\t\t * @param user User to get data from\n-\t\t * @param function Function to join fist/lastName to login\n-\t\t * @return generated login\n-\t\t */\n-\t\tpublic String generateLogin(User user, LoginGeneratorFunction function) {\n-\n-\t\t\tString firstName = user.getFirstName();\n-\t\t\tString lastName = user.getLastName();\n-\n-\t\t\t// get only first part of first name and remove spec. chars\n-\t\t\tif (firstName != null && !firstName.isEmpty()) {\n-\t\t\t\tfirstName = ModulesUtilsBlImpl.normalizeStringForLogin(firstName.split(\" \")[0]);\n-\t\t\t}\n-\n-\t\t\t// get only last part of last name and remove spec. chars\n-\t\t\tif (lastName != null && !lastName.isEmpty()) {\n-\t\t\t\tList<String> names = Arrays.asList(lastName.split(\" \"));\n-\t\t\t\tlastName = names.get(names.size() - 1);\n-\t\t\t\tlastName = ModulesUtilsBlImpl.normalizeStringForLogin(lastName.split(\" \")[0]);\n-\t\t\t}\n-\n-\t\t\t// unable to fill login for users without name or with partial name\n-\t\t\tif (firstName == null || firstName.isEmpty() || lastName == null || lastName.isEmpty()) {\n-\t\t\t\treturn null;\n-\t\t\t}\n-\n-\t\t\treturn function.generateLogin(firstName, lastName);\n-\n-\t\t}\n-\n-\t}\n-\n-\tpublic PerunBl getPerunBl() {\n-\t\treturn this.perunBl;\n-\t}\n-\n-\tpublic void setPerunBl(PerunBl perunBl) {\n-\t\tthis.perunBl = perunBl;\n-\t}\n+    final static Logger log = LoggerFactory.getLogger(ServicesManagerBlImpl.class);\n+    private PerunBl perunBl;\n+    Map<String, String> perunNamespaces = null;\n+\n+    public static final String A_E_namespace_minGID = AttributesManager.NS_ENTITYLESS_ATTR_DEF + \":namespace-minGID\";\n+    public static final String A_E_namespace_maxGID = AttributesManager.NS_ENTITYLESS_ATTR_DEF + \":namespace-maxGID\";\n+    public static final String A_G_unixGID_namespace = AttributesManager.NS_GROUP_ATTR_DEF + \":unixGID-namespace\";\n+    public static final String A_G_unixGroupName_namespace = AttributesManager.NS_GROUP_ATTR_DEF + \":unixGroupName-namespace\";\n+    public static final String A_R_unixGID_namespace = AttributesManager.NS_RESOURCE_ATTR_DEF + \":unixGID-namespace\";\n+    public static final String A_R_unixGroupName_namespace = AttributesManager.NS_RESOURCE_ATTR_DEF + \":unixGroupName-namespace\";\n+    public static final String A_F_unixGID_namespace = AttributesManager.NS_FACILITY_ATTR_DEF + \":unixGID-namespace\";\n+    public static final String A_F_unixGroupName_namespace = AttributesManager.NS_FACILITY_ATTR_DEF + \":unixGroupName-namespace\";\n+    public static final String A_F_googleGroupName_namespace = AttributesManager.NS_FACILITY_ATTR_DEF + \":googleGroupNameNamespace\";\n+    private static final String A_E_usedGids = AttributesManager.NS_ENTITYLESS_ATTR_DEF + \":usedGids\";\n+\n+    //Often used patterns\n+    public static final Pattern quotaWithMetricsPattern = Pattern.compile(\"^([0-9]+([.][0-9]+)?[KMGTPE]?):([0-9]+([.][0-9]+)?[KMGTPE]?)$\");\n+    public static final Pattern quotaWithoutMetricsPattern = Pattern.compile(\"^([0-9]+)(:)([0-9]+)$\");\n+    public static final Pattern numberPattern = Pattern.compile(\"[0-9]+([.][0-9]+)?\");\n+    public static final Pattern letterPattern = Pattern.compile(\"[A-Z]\");\n+\n+    public final static List<String> reservedNamesForUnixGroups = Arrays.asList(\"root\", \"daemon\", \"tty\", \"bin\", \"sys\", \"sudo\", \"nogroup\",\n+            \"hadoop\", \"hdfs\", \"mapred\", \"yarn\", \"hsqldb\", \"derby\", \"jetty\", \"hbase\", \"zookeeper\", \"users\");\n+    public final static List<String> unpermittedNamesForUserLogins = Arrays.asList(\"arraysvcs\", \"at\", \"backup\", \"bin\", \"daemon\", \"Debian-exim\", \"flexlm\", \"ftp\", \"games\",\n+            \"gdm\", \"glite\", \"gnats\", \"haldaemon\", \"identd\", \"irc\", \"libuuid\", \"list\", \"lp\", \"mail\", \"man\",\n+            \"messagebus\", \"news\", \"nobody\", \"ntp\", \"openslp\", \"pcp\", \"polkituser\", \"postfix\", \"proxy\",\n+            \"pulse\", \"puppet\", \"root\", \"saned\", \"smmsp\", \"smmta\", \"sshd\", \"statd\", \"suse-ncc\", \"sync\",\n+            \"sys\", \"uucp\", \"uuidd\", \"www-data\", \"wwwrun\", \"zenssh\", \"tomcat6\", \"tomcat7\", \"tomcat8\",\n+            \"nn\", \"dn\", \"rm\", \"nm\", \"sn\", \"jn\", \"jhs\", \"http\", \"yarn\", \"hdfs\", \"mapred\", \"hadoop\", \"hsqldb\", \"derby\",\n+            \"jetty\", \"hbase\", \"zookeeper\", \"hive\", \"hue\");\n+\n+    //Definition of K = KB, M = MB etc.\n+    public static final long M = 1024;\n+    public static final long G = M * 1024;\n+    public static final long T = G * 1024;\n+    public static final long P = T * 1024;\n+    public static final long E = P * 1024;\n+\n+    public ModulesUtilsBlImpl() {\n+    }\n+\n+    public boolean isNamespaceEqualsToFacilityUnixGroupNameNamespace(PerunSessionImpl sess, Facility facility, String namespace) throws InternalErrorException, AttributeNotExistsException, WrongAttributeAssignmentException {\n+        Utils.notNull(facility, \"facility\");\n+        Utils.notNull(namespace, \"namespace\");\n+        Utils.notNull(sess, \"perunSessionImpl\");\n+        Attribute facilityNamespaceAttr = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, facility, A_F_unixGroupName_namespace + \":\" + namespace);\n+        if (facilityNamespaceAttr.getValue() == null) {\n+            return false;\n+        }\n+        if (!namespace.equals(facilityNamespaceAttr.getValue())) {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    public List<Resource> findCollisionResourcesWithSameGroupName(PerunSessionImpl sess, Resource resource, String namespace) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException {\n+        Utils.notNull(sess, \"perunSessionImpl\");\n+        Utils.notNull(resource, \"resource\");\n+        Attribute resourceUnixGroupName = getPerunBl().getAttributesManagerBl().getAttribute(sess, resource, A_R_unixGroupName_namespace + \":\" + namespace);\n+        List<Resource> resourcesWithSameUnixGroupName = getPerunBl().getResourcesManagerBl().getResourcesByAttribute(sess, resourceUnixGroupName);\n+        resourcesWithSameUnixGroupName.remove(resource);\n+        return resourcesWithSameUnixGroupName;\n+    }\n+\n+    public List<Resource> findCollisionResourcesWithSameGroupName(PerunSessionImpl sess, Group group, String namespace) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException {\n+        Utils.notNull(sess, \"perunSessionImpl\");\n+        Utils.notNull(group, \"group\");\n+        Utils.notNull(namespace, \"namespace\");\n+        Attribute groupUnixGroupName = getPerunBl().getAttributesManagerBl().getAttribute(sess, group, A_G_unixGroupName_namespace + \":\" + namespace);\n+        Attribute copyResourceUnixGroupName = new Attribute(getPerunBl().getAttributesManagerBl().getAttributeDefinition(sess, A_R_unixGroupName_namespace + \":\" + namespace));\n+        copyResourceUnixGroupName.setValue(groupUnixGroupName.getValue());\n+        return getPerunBl().getResourcesManagerBl().getResourcesByAttribute(sess, copyResourceUnixGroupName);\n+    }\n+\n+    public List<Group> findCollisionGroupsWithSamgeGroupName(PerunSessionImpl sess, Resource resource, String namespace) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException {\n+        Utils.notNull(sess, \"perunSessionImpl\");\n+        Utils.notNull(resource, \"resource\");\n+        Utils.notNull(namespace, \"namespace\");\n+        Attribute resourceUnixGroupName = getPerunBl().getAttributesManagerBl().getAttribute(sess, resource, A_R_unixGroupName_namespace + \":\" + namespace);\n+        Attribute copyGroupUnixGroupName = new Attribute(getPerunBl().getAttributesManagerBl().getAttributeDefinition(sess, A_G_unixGroupName_namespace + \":\" + namespace));\n+        copyGroupUnixGroupName.setValue(resourceUnixGroupName.getValue());\n+        return getPerunBl().getGroupsManagerBl().getGroupsByAttribute(sess, copyGroupUnixGroupName);\n+\n+    }\n+\n+    public List<Group> findCollisionGroupsWithSamgeGroupName(PerunSessionImpl sess, Group group, String namespace) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException {\n+        Utils.notNull(sess, \"perunSessionImpl\");\n+        Utils.notNull(group, \"group\");\n+        Utils.notNull(namespace, \"namespace\");\n+        Attribute groupUnixGroupName = getPerunBl().getAttributesManagerBl().getAttribute(sess, group, A_G_unixGroupName_namespace + \":\" + namespace);\n+        List<Group> groupsWithsameGroupName = getPerunBl().getGroupsManagerBl().getGroupsByAttribute(sess, groupUnixGroupName);\n+        groupsWithsameGroupName.remove(group);\n+        return groupsWithsameGroupName;\n+    }\n+\n+    public List<Resource> findCollisionResourcesWithSameGid(PerunSessionImpl sess, Resource resource, String namespace) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException {\n+        Utils.notNull(sess, \"perunSessionImpl\");\n+        Utils.notNull(resource, \"resource\");\n+        Utils.notNull(namespace, \"namespace\");\n+        Attribute resourceUnixGid = getPerunBl().getAttributesManagerBl().getAttribute(sess, resource, A_R_unixGID_namespace + \":\" + namespace);\n+        List<Resource> resourcesWithSameGid = getPerunBl().getResourcesManagerBl().getResourcesByAttribute(sess, resourceUnixGid);\n+        resourcesWithSameGid.remove(resource);\n+        return resourcesWithSameGid;\n+    }\n+\n+    public List<Resource> findCollisionResourcesWithSameGid(PerunSessionImpl sess, Group group, String namespace) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException {\n+        Utils.notNull(sess, \"perunSessionImpl\");\n+        Utils.notNull(group, \"group\");\n+        Utils.notNull(namespace, \"namespace\");\n+        Attribute groupUnixGid = getPerunBl().getAttributesManagerBl().getAttribute(sess, group, A_G_unixGID_namespace + \":\" + namespace);\n+        Attribute copyResourceUnixGid = new Attribute(getPerunBl().getAttributesManagerBl().getAttributeDefinition(sess, A_R_unixGID_namespace + \":\" + namespace));\n+        copyResourceUnixGid.setValue(groupUnixGid.getValue());\n+        return getPerunBl().getResourcesManagerBl().getResourcesByAttribute(sess, copyResourceUnixGid);\n+    }\n+\n+    public List<Group> findCollisionGroupsWithSamgeGroupGid(PerunSessionImpl sess, Resource resource, String namespace) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException {\n+        Utils.notNull(sess, \"perunSessionImpl\");\n+        Utils.notNull(resource, \"resource\");\n+        Utils.notNull(namespace, \"namespace\");\n+        Attribute resourceUnixGid = getPerunBl().getAttributesManagerBl().getAttribute(sess, resource, A_R_unixGID_namespace + \":\" + namespace);\n+        Attribute copyGroupUnixGid = new Attribute(getPerunBl().getAttributesManagerBl().getAttributeDefinition(sess, A_G_unixGID_namespace + \":\" + namespace));\n+        copyGroupUnixGid.setValue(resourceUnixGid.getValue());\n+        return getPerunBl().getGroupsManagerBl().getGroupsByAttribute(sess, copyGroupUnixGid);\n+    }\n+\n+    public List<Group> findCollisionGroupsWithSamgeGroupGid(PerunSessionImpl sess, Group group, String namespace) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException {\n+        Utils.notNull(sess, \"perunSessionImpl\");\n+        Utils.notNull(group, \"group\");\n+        Utils.notNull(namespace, \"namespace\");\n+        Attribute groupUnixGid = getPerunBl().getAttributesManagerBl().getAttribute(sess, group, A_G_unixGID_namespace + \":\" + namespace);\n+        List<Group> groupsWithSameUnixGid = getPerunBl().getGroupsManagerBl().getGroupsByAttribute(sess, groupUnixGid);\n+        groupsWithSameUnixGid.remove(group);\n+        return groupsWithSameUnixGid;\n+    }\n+\n+    public boolean hasAccessToWriteToAttributeForAnyResource(PerunSessionImpl sess, AttributeDefinition attrDef, List<Resource> resources) throws InternalErrorException {\n+        Utils.notNull(sess, \"perunSessionImpl\");\n+        Utils.notNull(attrDef, \"attributeDefinition\");\n+        if (resources == null || resources.isEmpty()) {\n+            return false;\n+        }\n+        for (Resource r : resources) {\n+            if (AuthzResolver.isAuthorizedForAttribute(sess, ActionType.WRITE, attrDef, r, null)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public boolean hasAccessToWriteToAttributeForAnyGroup(PerunSessionImpl sess, AttributeDefinition attrDef, List<Group> groups) throws InternalErrorException {\n+        Utils.notNull(sess, \"perunSessionImpl\");\n+        Utils.notNull(attrDef, \"attributeDefinition\");\n+        if (groups == null || groups.isEmpty()) {\n+            return false;\n+        }\n+        for (Group g : groups) {\n+            if (AuthzResolver.isAuthorizedForAttribute(sess, ActionType.WRITE, attrDef, g, null)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public Pair<Integer, Integer> getMinAndMaxGidForNamespace(PerunSessionImpl sess, String namespace) throws InternalErrorException, AttributeNotExistsException, WrongAttributeAssignmentException {\n+        Utils.notNull(sess, \"perunSessionImpl\");\n+        Utils.notNull(namespace, \"namespace\");\n+        Attribute minGidAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, namespace, A_E_namespace_minGID);\n+        Integer minGid = null;\n+        if (minGidAttribute.getValue() != null) {\n+            minGid = (Integer) minGidAttribute.getValue();\n+        }\n+\n+        Attribute maxGidAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, namespace, A_E_namespace_maxGID);\n+        Integer maxGid = null;\n+        if (maxGidAttribute.getValue() != null) {\n+            maxGid = (Integer) maxGidAttribute.getValue();\n+        }\n+\n+        return new Pair(minGid, maxGid);\n+    }\n+\n+    public Integer getFirstFreeGidForResourceOrGroup(PerunSessionImpl sess, String namespace) throws InternalErrorException, AttributeNotExistsException, WrongAttributeAssignmentException {\n+        Utils.notNull(sess, \"perunSessionImpl\");\n+        Utils.notNull(namespace, \"namespace\");\n+        Pair<Integer, Integer> minAndMaxGid = this.getMinAndMaxGidForNamespace(sess, namespace);\n+\n+        //If there is no min or max gid, return null instead of number, its same like no free gid was able\n+        if (minAndMaxGid == null || minAndMaxGid.getLeft() == null || minAndMaxGid.getRight() == null) {\n+            return null;\n+        }\n+\n+        AttributeDefinition resourceUnixGid = getPerunBl().getAttributesManagerBl().getAttributeDefinition(sess, A_R_unixGID_namespace + \":\" + namespace);\n+        List<Object> allGids = sess.getPerunBl().getAttributesManagerBl().getAllValues(sess, resourceUnixGid);\n+        AttributeDefinition groupUnixGid = getPerunBl().getAttributesManagerBl().getAttributeDefinition(sess, A_G_unixGID_namespace + \":\" + namespace);\n+        allGids.addAll(sess.getPerunBl().getAttributesManagerBl().getAllValues(sess, groupUnixGid)); //note: it doesn't matter if the group is not active (isUnixGroup attribute != 1)\n+\n+        for (int i = minAndMaxGid.getLeft(); i < minAndMaxGid.getRight(); i++) {\n+            if (!allGids.contains(i)) {\n+                return i;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    public void checkIfGIDIsWithinRange(PerunSessionImpl sess, Attribute attribute) throws InternalErrorException, WrongReferenceAttributeValueException, WrongAttributeAssignmentException, AttributeNotExistsException, WrongAttributeValueException {\n+        Utils.notNull(attribute, \"attribute\");\n+        Integer gid = null;\n+        if (attribute.getValue() != null) {\n+            gid = (Integer) attribute.getValue();\n+        }\n+\n+        if (gid == null) {\n+            throw new WrongAttributeValueException(attribute, \"Gid with null value is not allowed.\");\n+        }\n+\n+        String gidNamespace = attribute.getFriendlyNameParameter();\n+\n+        Attribute minGidAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, gidNamespace, A_E_namespace_minGID);\n+        if (minGidAttribute.getValue() == null) {\n+            throw new WrongReferenceAttributeValueException(attribute, minGidAttribute);\n+        }\n+        Integer minGid = (Integer) minGidAttribute.getValue();\n+\n+        Attribute maxGidAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, gidNamespace, A_E_namespace_maxGID);\n+        if (maxGidAttribute.getValue() == null) {\n+            throw new WrongReferenceAttributeValueException(attribute, maxGidAttribute);\n+        }\n+        Integer maxGid = (Integer) maxGidAttribute.getValue();\n+\n+        if (gid < minGid || gid > maxGid) {\n+            throw new WrongAttributeValueException(attribute, \"GID number is not in allowed values min: \" + minGid + \", max:\" + maxGid);\n+        }\n+    }\n+\n+    public void checkIfListOfGIDIsWithinRange(PerunSessionImpl sess, User user, Attribute attribute) throws InternalErrorException, WrongReferenceAttributeValueException, WrongAttributeAssignmentException, AttributeNotExistsException, WrongAttributeValueException {\n+        Utils.notNull(attribute, \"attribute\");\n+        List<String> gIDs = (List<String>) attribute.getValue();\n+        if (gIDs != null) {\n+            for (String sGid : gIDs) {\n+                try {\n+                    Integer gid = new Integer(sGid);\n+                    String gidNamespace = attribute.getFriendlyNameParameter();\n+\n+                    Attribute minGidAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, gidNamespace, A_E_namespace_minGID);\n+                    if (minGidAttribute.getValue() == null) {\n+                        throw new WrongReferenceAttributeValueException(attribute, minGidAttribute, \"Attribute minGid cannot be null\");\n+                    }\n+                    Integer minGid = (Integer) minGidAttribute.getValue();\n+\n+                    Attribute maxGidAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, gidNamespace, A_E_namespace_maxGID);\n+                    if (maxGidAttribute.getValue() == null) {\n+                        throw new WrongReferenceAttributeValueException(attribute, maxGidAttribute, \"Attribute maxGid cannot be null\");\n+                    }\n+                    Integer maxGid = (Integer) maxGidAttribute.getValue();\n+\n+                    if (gid < minGid || gid > maxGid) {\n+                        throw new WrongAttributeValueException(attribute, \"GID number is not in allowed values min: \" + minGid + \", max:\" + maxGid);\n+                    }\n+                } catch (NumberFormatException ex) {\n+                    throw new WrongAttributeValueException(attribute, user, \"attribute is not a number\", ex);\n+                }\n+            }\n+        }\n+    }\n+\n+    public Integer getFreeGID(PerunSessionImpl sess, Attribute attribute) throws InternalErrorException, AttributeNotExistsException, WrongAttributeAssignmentException {\n+        Utils.notNull(attribute, \"attribute\");\n+        String gidNamespace = attribute.getFriendlyNameParameter();\n+\n+        Attribute minGidAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, gidNamespace, A_E_namespace_minGID);\n+        if (minGidAttribute.getValue() == null) {\n+            return 0;\n+        }\n+        Integer minGid = (Integer) minGidAttribute.getValue();\n+\n+        Attribute maxGidAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, gidNamespace, A_E_namespace_maxGID);\n+        if (maxGidAttribute.getValue() == null) {\n+            return 0;\n+        }\n+        Integer maxGid = (Integer) maxGidAttribute.getValue();\n+\n+        List<Integer> allGids = new ArrayList<>();\n+        Attribute usedGids = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, gidNamespace, A_E_usedGids);\n+\n+        if (usedGids.getValue() == null) {\n+            return minGid;\n+        } else {\n+            Map<String, String> usedGidsValue = (Map<String, String>) usedGids.getValue();\n+            Set<String> keys = usedGidsValue.keySet();\n+\n+            for (String key : keys) {\n+                allGids.add(Integer.parseInt(usedGidsValue.get(key)));\n+            }\n+        }\n+\n+        for (int i = minGid; i < maxGid; i++) {\n+            if (!allGids.contains(i)) {\n+                return i;\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    public Integer getCommonGIDOfGroupsWithSameNameInSameNamespace(PerunSessionImpl sess, List<Group> groupsWithSameGroupNameInSameNamespace, String gidNamespace, Integer commonGID) throws InternalErrorException, WrongAttributeAssignmentException {\n+        //If there are no groups, return commonGID from param (it can be null)\n+        if (groupsWithSameGroupNameInSameNamespace == null || groupsWithSameGroupNameInSameNamespace.isEmpty()) {\n+            return commonGID;\n+        }\n+        Utils.notNull(gidNamespace, \"gidNamespace\");\n+\n+        Group commonGIDGroup = null;  //only for more verbose exception messages\n+        for (Group g : groupsWithSameGroupNameInSameNamespace) {\n+            try {\n+                Attribute attr = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, g, A_G_unixGID_namespace + \":\" + gidNamespace);\n+                if (attr.getValue() != null) {\n+                    if (commonGID == null) {\n+                        commonGIDGroup = g;\n+                        commonGID = (Integer) attr.getValue();\n+                    } else {\n+                        if (!commonGID.equals((Integer) attr.getValue())) {\n+                            throw new ConsistencyErrorException(\"There are at least 1 groups/resources with same GroupName in same namespace but with different GID in same namespaces. Conflict found: \" + g + \"(gid=\" + attr.getValue() + \") and \" + commonGIDGroup + \"(gid=\" + commonGID + \")\");\n+                        }\n+                    }\n+                }\n+            } catch (AttributeNotExistsException ex) {\n+                throw new ConsistencyErrorException(ex);\n+            }\n+        }\n+\n+        return commonGID;\n+    }\n+\n+    public Integer getCommonGIDOfResourcesWithSameNameInSameNamespace(PerunSessionImpl sess, List<Resource> resourcesWithSameGroupNameInSameNamespace, String gidNamespace, Integer commonGID) throws InternalErrorException, WrongAttributeAssignmentException {\n+        //If there are no resources, return commonGID from param (it can be null)\n+        if (resourcesWithSameGroupNameInSameNamespace == null || resourcesWithSameGroupNameInSameNamespace.isEmpty()) {\n+            return commonGID;\n+        }\n+        Utils.notNull(gidNamespace, \"gidNamespace\");\n+\n+        Resource commonGIDResource = null;   //only for more verbose exception messages\n+        for (Resource r : resourcesWithSameGroupNameInSameNamespace) {\n+            try {\n+                Attribute attr = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, r, A_R_unixGID_namespace + \":\" + gidNamespace);\n+                if (attr.getValue() != null) {\n+                    if (commonGID == null) {\n+                        commonGIDResource = r;\n+                        commonGID = (Integer) attr.getValue();\n+                    } else {\n+                        if (!commonGID.equals((Integer) attr.getValue())) {\n+                            throw new ConsistencyErrorException(\"There are at least 1 groups/resources with same GroupName in same namespace but with different GID in same namespaces. Conflict found: \" + r + \"(gid=\" + attr.getValue() + \") and \" + commonGIDResource + \"(gid=\" + commonGID + \")\");\n+                        }\n+                    }\n+                }\n+            } catch (AttributeNotExistsException ex) {\n+                throw new ConsistencyErrorException(ex);\n+            }\n+        }\n+\n+        return commonGID;\n+    }\n+\n+    public int haveTheSameAttributeWithTheSameNamespace(PerunSessionImpl sess, Group group, Attribute attr) throws InternalErrorException, WrongAttributeAssignmentException {\n+        Utils.notNull(group, \"group\");\n+        Utils.notNull(attr, \"attr\");\n+\n+        String attributeNamespace = attr.getFriendlyNameParameter();\n+        if (attributeNamespace == null || attributeNamespace.isEmpty()) {\n+            throw new InternalErrorException(\"Attribute has no namespace, this method can't be use.\");\n+        }\n+\n+        try {\n+            Attribute testingAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, group, attr.getName());\n+            if (testingAttribute.getValue() == null) {\n+                return -1;\n+            } else {\n+                if (!testingAttribute.getValue().equals(attr.getValue())) {\n+                    return 1;\n+                }\n+            }\n+        } catch (AttributeNotExistsException ex) {\n+            throw new ConsistencyErrorException(ex);\n+        }\n+        return 0;\n+    }\n+\n+    public int haveTheSameAttributeWithTheSameNamespace(PerunSessionImpl sess, Resource resource, Attribute attr) throws InternalErrorException, WrongAttributeAssignmentException {\n+        Utils.notNull(resource, \"resource\");\n+        Utils.notNull(attr, \"attr\");\n+\n+        String attributeNamespace = attr.getFriendlyNameParameter();\n+        if (attributeNamespace == null || attributeNamespace.isEmpty()) {\n+            throw new InternalErrorException(\"Attribute has no namespace, this method can't be use.\");\n+        }\n+\n+        try {\n+            Attribute testingAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, resource, attr.getName());\n+            if (testingAttribute.getValue() == null) {\n+                return -1;\n+            } else {\n+                if (!testingAttribute.getValue().equals(attr.getValue())) {\n+                    return 1;\n+                }\n+            }\n+        } catch (AttributeNotExistsException ex) {\n+            throw new ConsistencyErrorException(ex);\n+        }\n+        return 0;\n+    }\n+\n+    public boolean haveRightToWriteAttributeInAnyGroupOrResource(PerunSessionImpl sess, List<Group> groups, List<Resource> resources, AttributeDefinition groupAttribute, AttributeDefinition resourceAttribute) throws InternalErrorException {\n+        if (groups != null && !groups.isEmpty() && groupAttribute != null) {\n+            for (Group g : groups) {\n+                if (AuthzResolver.isAuthorizedForAttribute(sess, ActionType.WRITE, groupAttribute, g, null)) {\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        if (resources != null && !resources.isEmpty() && resourceAttribute != null) {\n+            for (Resource r : resources) {\n+                if (AuthzResolver.isAuthorizedForAttribute(sess, ActionType.WRITE, resourceAttribute, r, null)) {\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    public List<Attribute> getListOfResourceGIDsFromListOfGroupGIDs(PerunSessionImpl sess, List<Attribute> groupGIDs) throws InternalErrorException, AttributeNotExistsException {\n+        List<Attribute> resourceGIDs = new ArrayList<Attribute>();\n+        if (groupGIDs == null || groupGIDs.isEmpty()) {\n+            return resourceGIDs;\n+        }\n+\n+        for (Attribute a : groupGIDs) {\n+            Attribute resourceGID = new Attribute(sess.getPerunBl().getAttributesManagerBl().getAttributeDefinition(sess, A_R_unixGID_namespace + \":\" + a.getFriendlyNameParameter()));\n+            resourceGID.setValue(a.getValue());\n+            resourceGIDs.add(resourceGID);\n+        }\n+\n+        return resourceGIDs;\n+    }\n+\n+    public List<Attribute> getListOfGroupGIDsFromListOfResourceGIDs(PerunSessionImpl sess, List<Attribute> resourceGIDs) throws InternalErrorException, AttributeNotExistsException {\n+        List<Attribute> groupGIDs = new ArrayList<Attribute>();\n+        if (resourceGIDs == null || resourceGIDs.isEmpty()) {\n+            return groupGIDs;\n+        }\n+\n+        for (Attribute a : resourceGIDs) {\n+            Attribute groupGID = new Attribute(sess.getPerunBl().getAttributesManagerBl().getAttributeDefinition(sess, A_G_unixGID_namespace + \":\" + a.getFriendlyNameParameter()));\n+            groupGID.setValue(a.getValue());\n+            groupGIDs.add(groupGID);\n+        }\n+\n+        return groupGIDs;\n+    }\n+\n+    public Set<String> getSetOfGIDNamespacesWhereFacilitiesHasTheSameGroupNameNamespace(PerunSessionImpl sess, List<Facility> facilities, Attribute unixGroupNameNamespace) throws InternalErrorException, WrongAttributeAssignmentException, WrongReferenceAttributeValueException {\n+        Set<String> gidNamespaces = new HashSet<String>();\n+        if (facilities == null || facilities.isEmpty()) {\n+            return gidNamespaces;\n+        }\n+        Utils.notNull(facilities, \"facilities\");\n+\n+        for (Facility f : facilities) {\n+            Attribute facilityGroupNameNamespace;\n+            try {\n+                facilityGroupNameNamespace = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, f, A_F_unixGroupName_namespace);\n+                if (facilityGroupNameNamespace.getValue() != null) {\n+                    //if they are same, save GID-namespace from this facility to hashSet\n+                    if (unixGroupNameNamespace.getFriendlyNameParameter().equals((String) facilityGroupNameNamespace.getValue())) {\n+                        Attribute facilityGIDNamespace = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, f, A_F_unixGID_namespace);\n+                        //If facilityGIDNamespace exists and is not null, save to the hashSet of gidNamespaces\n+                        if (facilityGIDNamespace.getValue() != null) {\n+                            gidNamespaces.add((String) facilityGIDNamespace.getValue());\n+                        }\n+                    }\n+                }\n+            } catch (AttributeNotExistsException ex) {\n+                throw new ConsistencyErrorException(ex);\n+            }\n+        }\n+\n+        return gidNamespaces;\n+    }\n+\n+    public Set<String> getSetOfGroupNameNamespacesWhereFacilitiesHasTheSameGIDNamespace(PerunSessionImpl sess, List<Facility> facilities, Attribute unixGIDNamespace) throws InternalErrorException, WrongAttributeAssignmentException, WrongReferenceAttributeValueException {\n+        Set<String> groupNameNamespaces = new HashSet<String>();\n+        if (facilities == null || facilities.isEmpty()) {\n+            return groupNameNamespaces;\n+        }\n+        Utils.notNull(unixGIDNamespace, \"unixGIDNamespace\");\n+\n+        for (Facility f : facilities) {\n+            Attribute facilityGIDNamespace;\n+            try {\n+                facilityGIDNamespace = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, f, A_F_unixGID_namespace);\n+                if (facilityGIDNamespace.getValue() != null) {\n+                    //if they are same, save GroupName-namespace from this facility to hashSet\n+                    if (unixGIDNamespace.getFriendlyNameParameter().equals((String) facilityGIDNamespace.getValue())) {\n+                        Attribute facilityGroupNameNamespace = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, f, A_F_unixGroupName_namespace);\n+                        //If facilityGroupNameNamespace exists and is not null, save to the hashSet of gidNamespaces\n+                        if (facilityGroupNameNamespace.getValue() != null) {\n+                            groupNameNamespaces.add((String) facilityGroupNameNamespace.getValue());\n+                        } else {\n+                            throw new WrongReferenceAttributeValueException(unixGIDNamespace, facilityGroupNameNamespace, \"Facility has gidNamespace set, but groupNameNamespace not set.\");\n+                        }\n+                    }\n+                }\n+            } catch (AttributeNotExistsException ex) {\n+                throw new ConsistencyErrorException(ex);\n+            }\n+        }\n+\n+        return groupNameNamespaces;\n+    }\n+\n+    public void checkReservedUnixGroupNames(Attribute groupNameAttribute) throws InternalErrorException, WrongAttributeValueException {\n+        if (groupNameAttribute == null) {\n+            return;\n+        }\n+        checkPerunNamespacesMap();\n+\n+        String reservedNames = perunNamespaces.get(groupNameAttribute.getFriendlyName() + \":reservedNames\");\n+        if (reservedNames != null) {\n+            List<String> reservedNamesList = Arrays.asList(reservedNames.split(\"\\\\s*,\\\\s*\"));\n+            if (reservedNamesList.contains(groupNameAttribute.getValue())) {\n+                throw new WrongAttributeValueException(groupNameAttribute, \"This groupName is reserved.\");\n+            }\n+        } else {\n+            //Property not found in our attribute map, so we will use the default hardcoded values instead\n+            if (reservedNamesForUnixGroups.contains(groupNameAttribute.getValue())) {\n+                throw new WrongAttributeValueException(groupNameAttribute, \"This groupName is reserved.\");\n+            }\n+        }\n+    }\n+\n+    public void checkUnpermittedUserLogins(Attribute loginAttribute) throws InternalErrorException, WrongAttributeValueException {\n+        if (loginAttribute == null) {\n+            return;\n+        }\n+        checkPerunNamespacesMap();\n+\n+        String unpermittedNames = perunNamespaces.get(loginAttribute.getFriendlyName() + \":reservedNames\");\n+        if (unpermittedNames != null) {\n+            List<String> unpermittedNamesList = Arrays.asList(unpermittedNames.split(\"\\\\s*,\\\\s*\"));\n+            if (unpermittedNamesList.contains(loginAttribute.getValue())) {\n+                throw new WrongAttributeValueException(loginAttribute, \"This login is not permitted.\");\n+            }\n+        } else {\n+            //Property not found in our attribute map, so we will use the default hardcoded values instead\n+            if (unpermittedNamesForUserLogins.contains(loginAttribute.getValue())) {\n+                throw new WrongAttributeValueException(loginAttribute, \"This login is not permitted.\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public Attribute getGoogleGroupNameNamespaceAttributeWithNotNullValue(PerunSessionImpl sess, Resource resource) throws InternalErrorException, WrongReferenceAttributeValueException {\n+        Facility facility = sess.getPerunBl().getResourcesManagerBl().getFacility(sess, resource);\n+        try {\n+            Attribute googleGroupNameNamespaceAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, facility, A_F_googleGroupName_namespace);\n+            if (googleGroupNameNamespaceAttribute.getValue() == null) {\n+                throw new WrongReferenceAttributeValueException(googleGroupNameNamespaceAttribute);\n+            }\n+            return googleGroupNameNamespaceAttribute;\n+        } catch (AttributeNotExistsException ex) {\n+            throw new ConsistencyErrorException(ex);\n+        } catch (WrongAttributeAssignmentException ex) {\n+            throw new InternalErrorException(ex);\n+        }\n+    }\n+\n+    public Attribute getUnixGroupNameNamespaceAttributeWithNotNullValue(PerunSessionImpl sess, Resource resource) throws InternalErrorException, WrongReferenceAttributeValueException {\n+        Facility facility = sess.getPerunBl().getResourcesManagerBl().getFacility(sess, resource);\n+        try {\n+            Attribute unixGroupNameNamespaceAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, facility, A_F_unixGroupName_namespace);\n+            if (unixGroupNameNamespaceAttribute.getValue() == null) {\n+                throw new WrongReferenceAttributeValueException(unixGroupNameNamespaceAttribute);\n+            }\n+            return unixGroupNameNamespaceAttribute;\n+        } catch (AttributeNotExistsException ex) {\n+            throw new ConsistencyErrorException(ex);\n+        } catch (WrongAttributeAssignmentException ex) {\n+            throw new InternalErrorException(ex);\n+        }\n+    }\n+\n+    public Attribute getUnixGIDNamespaceAttributeWithNotNullValue(PerunSessionImpl sess, Resource resource) throws InternalErrorException, WrongReferenceAttributeValueException {\n+        Facility facility = sess.getPerunBl().getResourcesManagerBl().getFacility(sess, resource);\n+        try {\n+            Attribute unixGIDNamespaceAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, facility, A_F_unixGID_namespace);\n+            if (unixGIDNamespaceAttribute.getValue() == null) {\n+                throw new WrongReferenceAttributeValueException(unixGIDNamespaceAttribute);\n+            }\n+            return unixGIDNamespaceAttribute;\n+        } catch (AttributeNotExistsException ex) {\n+            throw new ConsistencyErrorException(ex);\n+        } catch (WrongAttributeAssignmentException ex) {\n+            throw new InternalErrorException(ex);\n+        }\n+    }\n+\n+    public boolean isGroupUnixGIDNamespaceFillable(PerunSessionImpl sess, Group group, Attribute groupUnixGIDNamespace) throws InternalErrorException, WrongReferenceAttributeValueException, WrongAttributeAssignmentException {\n+        Utils.notNull(group, \"group\");\n+        Utils.notNull(groupUnixGIDNamespace, \"groupUnixGIDNamespace\");\n+\n+        //Get All Facilities from group\n+        Set<Facility> facilitiesOfGroup = new HashSet<Facility>();\n+        List<Resource> resourcesOfGroup = sess.getPerunBl().getResourcesManagerBl().getAssignedResources(sess, group);\n+        for (Resource r : resourcesOfGroup) {\n+            facilitiesOfGroup.add(sess.getPerunBl().getResourcesManagerBl().getFacility(sess, r));\n+        }\n+\n+        //Prepare list of gid namespaces of all facilities which have the same groupName namespace like this unixGroupName namespace\n+        Set<String> groupNameNamespaces = this.getSetOfGroupNameNamespacesWhereFacilitiesHasTheSameGIDNamespace(sess, new ArrayList<Facility>(facilitiesOfGroup), groupUnixGIDNamespace);\n+\n+        if (!groupNameNamespaces.isEmpty()) {\n+            for (String s : groupNameNamespaces) {\n+                try {\n+                    Attribute groupNameNamespace = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, group, A_G_unixGroupName_namespace + \":\" + s);\n+                    if (groupNameNamespace.getValue() != null) {\n+                        return true;\n+                    }\n+                } catch (AttributeNotExistsException ex) {\n+                    throw new ConsistencyErrorException(ex);\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isNameOfEmailValid(PerunSessionImpl sess, String email) {\n+        if (email == null) {\n+            return false;\n+        }\n+\n+        Matcher emailMatcher = Utils.emailPattern.matcher(email);\n+        if (emailMatcher.find()) {\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    public void checkFormatOfShell(String shell, Attribute attribute) throws WrongAttributeValueException {\n+        //previous regex ^/[-a-zA-Z0-9_/]*$\"\n+        Pattern pattern = Pattern.compile(\"^(/[-_a-zA-Z0-9]+)+$\");\n+\n+        Matcher match = pattern.matcher(shell);\n+\n+        if (!match.matches()) {\n+            throw new WrongAttributeValueException(attribute, \"Bad shell attribute format \" + shell);\n+        }\n+    }\n+\n+    public void checkAttributeRegex(Attribute attribute, String defaultRegex) throws InternalErrorException, WrongAttributeValueException {\n+        if (attribute == null || attribute.getValue() == null) {\n+            throw new InternalErrorException(\"Attribute or it's value is null.\");\n+        }\n+        String attributeValue = (String) attribute.getValue();\n+        checkPerunNamespacesMap();\n+\n+        String regex = perunNamespaces.get(attribute.getFriendlyName() + \":regex\");\n+        if (regex != null) {\n+            //Check if regex is valid\n+            try {\n+                Pattern.compile(regex);\n+            } catch (PatternSyntaxException e) {\n+                log.error(\"Regex pattern \\\"\" + regex + \"\\\" from \\\"\" + attribute.getFriendlyName() + \":regex\\\"\" + \" property of perun-namespaces.properties file is invalid.\");\n+                throw new InternalErrorException(\"Regex pattern \\\"\" + regex + \"\\\" from \\\"\" + attribute.getFriendlyName() + \":regex\\\"\" + \" property of perun-namespaces.properties file is invalid.\");\n+            }\n+            if (!attributeValue.matches(regex)) {\n+                throw new WrongAttributeValueException(attribute, \"Wrong format. Regex: \\\"\" + regex + \"\\\" expected for this attribute:\");\n+            }\n+        } else {\n+            //Regex property not found in our attribute map, so use the default hardcoded regex\n+            if (defaultRegex == null) {\n+                return;\n+            }\n+            if (!attributeValue.matches(defaultRegex)) {\n+                throw new WrongAttributeValueException(attribute, \"Wrong format. Regex: \\\"\" + defaultRegex + \"\\\" expected for this attribute:\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Internal protected method.\n+     * Checks this.perunNamespaces map, which is always initialized as null.\n+     * If null, it tries to load the configuration into this map from a perun-namespaces.properties file.\n+     * If the file does not exist, it creates an empty HashMap, so it's not null anymore.\n+     */\n+    protected void checkPerunNamespacesMap() {\n+        if (perunNamespaces == null) {\n+            try {\n+                perunNamespaces = BeansUtils.getAllPropertiesFromCustomConfiguration(\"perun-namespaces.properties\");\n+            } catch (InternalErrorException e) {\n+                perunNamespaces = new HashMap<>();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public Map<String, Pair<BigDecimal, BigDecimal>> checkAndTransferQuotas(Attribute quotasAttribute, PerunBean firstPlaceholder, PerunBean secondPlaceholder, boolean withMetrics) throws InternalErrorException, WrongAttributeValueException {\n+        //firstPlaceholder can't be null\n+        if (firstPlaceholder == null) {\n+            throw new InternalErrorException(\"Missing first mandatory placeHolder (PerunBean).\");\n+        }\n+        //Quotas attribute must exists with not null value\n+        if (quotasAttribute == null || quotasAttribute.getValue() == null) {\n+            throw new InternalErrorException(\"Attribute quotas for checking and transfering can't be null.\");\n+        }\n+\n+        //Prepare result container and value of attribute\n+        Map<String, Pair<BigDecimal, BigDecimal>> transferedQuotas = new HashMap<>();\n+        Map<String, String> defaultQuotasMap = (Map<String, String>) quotasAttribute.getValue();\n+\n+        //List to test if all paths are unique (/var/log and /var/log/ are the same so these two paths are not unique)\n+        List<String> uniquePaths = new ArrayList<>();\n+        for (String path : defaultQuotasMap.keySet()) {\n+            //null is not correct path for volume on File System\n+            if (path == null || path.isEmpty()) {\n+                throw new WrongAttributeValueException(quotasAttribute, firstPlaceholder, secondPlaceholder, \"The path of some volume where quota should be set is null.\");\n+            }\n+\n+            //testing if path is unique\n+            String canonicalPath;\n+            try {\n+                canonicalPath = new URI(path).normalize().getPath();\n+                if (!canonicalPath.endsWith(\"/\")) {\n+                    canonicalPath = canonicalPath.concat(\"/\");\n+                }\n+            } catch (URISyntaxException ex) {\n+                throw new WrongAttributeValueException(quotasAttribute, firstPlaceholder, secondPlaceholder, \"Path '\" + path + \"' is not correct form.\");\n+            }\n+\n+            if (uniquePaths.contains(canonicalPath)) {\n+                throw new WrongAttributeValueException(quotasAttribute, firstPlaceholder, secondPlaceholder, \"Paths are not unique, there are two same paths: \" + path);\n+            } else {\n+                uniquePaths.add(canonicalPath);\n+            }\n+\n+            String quota = defaultQuotasMap.get(path);\n+            //quota can't be null, if exists in attribute, must be set in some way\n+            if (quota == null) {\n+                throw new WrongAttributeValueException(quotasAttribute, firstPlaceholder, secondPlaceholder, \"The quota of some volume where quota should be set is null.\");\n+            }\n+\n+            //check format of quota parameter (for data with metrics, for count of files without metrics)\n+            Matcher quotaMatcher;\n+            if (withMetrics) {\n+                quotaMatcher = ModulesUtilsBlImpl.quotaWithMetricsPattern.matcher(quota);\n+                if (!quotaMatcher.matches()) {\n+                    throw new WrongAttributeValueException(quotasAttribute, firstPlaceholder, secondPlaceholder, \"Format of quota in quotas attribute is not correct.\");\n+                }\n+            } else {\n+                quotaMatcher = ModulesUtilsBlImpl.quotaWithoutMetricsPattern.matcher(quota);\n+                if (!quotaMatcher.matches()) {\n+                    throw new WrongAttributeValueException(quotasAttribute, firstPlaceholder, secondPlaceholder, \"Format of quota in quotas attribute is not correct.\");\n+                }\n+            }\n+\n+            //Parse quotas to variables\n+            String softQuota = quotaMatcher.group(1);\n+            String hardQuota = quotaMatcher.group(3);\n+\n+            //Parse number pattern and letter pattern from whole quotas\n+\n+            //SoftQuotaNumber\n+            BigDecimal softQuotaAfterTransfer;\n+            BigDecimal hardQuotaAfterTransfer;\n+            //special behavior with metrics\n+            if (withMetrics) {\n+                String softQuotaNumber = null;\n+                Matcher numberMatcher = numberPattern.matcher(softQuota);\n+                if (!numberMatcher.find()) {\n+                    throw new ConsistencyErrorException(\"Matcher can't find number in softQuota '\" + softQuota + \"' in attribute \" + quotasAttribute);\n+                }\n+                softQuotaNumber = numberMatcher.group();\n+\n+                //SoftQuotaLetter\n+                String softQuotaLetter = null;\n+                Matcher letterMatcher = letterPattern.matcher(softQuota);\n+                //in this case no letter means default and default is G\n+                if (!letterMatcher.find()) {\n+                    softQuotaLetter = \"G\";\n+                } else {\n+                    softQuotaLetter = letterMatcher.group();\n+                }\n+\n+                //HardQuotaNumber\n+                String hardQuotaNumber = null;\n+                numberMatcher = numberPattern.matcher(hardQuota);\n+                if (!numberMatcher.find()) {\n+                    throw new ConsistencyErrorException(\"Matcher can't find number in hardQuota '\" + hardQuota + \"' in attribute \" + quotasAttribute);\n+                }\n+                hardQuotaNumber = numberMatcher.group();\n+\n+                //HardQuotaLetter\n+                String hardQuotaLetter;\n+                letterMatcher = letterPattern.matcher(hardQuota);\n+                //in this case no letter means default and default is G\n+                if (!letterMatcher.find()) {\n+                    hardQuotaLetter = \"G\";\n+                } else {\n+                    hardQuotaLetter = letterMatcher.group();\n+                }\n+\n+                //Prepare whole big decimal numbers\n+                softQuotaAfterTransfer = new BigDecimal(softQuotaNumber);\n+                hardQuotaAfterTransfer = new BigDecimal(hardQuotaNumber);\n+\n+                //multiplying for softQuota\n+                switch (softQuotaLetter) {\n+                    case \"K\":\n+                        break; //K is basic metric, no need to multiply it\n+                    case \"G\":\n+                        softQuotaAfterTransfer = softQuotaAfterTransfer.multiply(BigDecimal.valueOf(G));\n+                        break;\n+                    case \"M\":\n+                        softQuotaAfterTransfer = softQuotaAfterTransfer.multiply(BigDecimal.valueOf(M));\n+                        break;\n+                    case \"T\":\n+                        softQuotaAfterTransfer = softQuotaAfterTransfer.multiply(BigDecimal.valueOf(T));\n+                        break;\n+                    case \"P\":\n+                        softQuotaAfterTransfer = softQuotaAfterTransfer.multiply(BigDecimal.valueOf(P));\n+                        break;\n+                    case \"E\":\n+                        softQuotaAfterTransfer = softQuotaAfterTransfer.multiply(BigDecimal.valueOf(E));\n+                        break;\n+                    default:\n+                        throw new ConsistencyErrorException(\"There is not allowed character in soft quota letter '\" + softQuotaLetter + \"'.\");\n+                }\n+\n+                //multiplying for softQuota\n+                switch (hardQuotaLetter) {\n+                    case \"K\":\n+                        break; //K is basic metric, no need to multiply it\n+                    case \"G\":\n+                        hardQuotaAfterTransfer = hardQuotaAfterTransfer.multiply(BigDecimal.valueOf(G));\n+                        break;\n+                    case \"M\":\n+                        hardQuotaAfterTransfer = hardQuotaAfterTransfer.multiply(BigDecimal.valueOf(M));\n+                        break;\n+                    case \"T\":\n+                        hardQuotaAfterTransfer = hardQuotaAfterTransfer.multiply(BigDecimal.valueOf(T));\n+                        break;\n+                    case \"P\":\n+                        hardQuotaAfterTransfer = hardQuotaAfterTransfer.multiply(BigDecimal.valueOf(P));\n+                        break;\n+                    case \"E\":\n+                        hardQuotaAfterTransfer = hardQuotaAfterTransfer.multiply(BigDecimal.valueOf(E));\n+                        break;\n+                    default:\n+                        throw new ConsistencyErrorException(\"There is not allowed character in hard quota letter '\" + hardQuotaLetter + \"'.\");\n+                }\n+                //easy way without metrics\n+            } else {\n+                softQuotaAfterTransfer = new BigDecimal(softQuota);\n+                hardQuotaAfterTransfer = new BigDecimal(hardQuota);\n+            }\n+\n+            //test comparing softQuota and hardQuota (softQuota must be less or equals than hardQuota, 0 means unlimited)\n+            //1] if softQuota is unlimited, but hardQuota not = exception\n+            if (softQuotaAfterTransfer.compareTo(BigDecimal.valueOf(0)) == 0 && hardQuotaAfterTransfer.compareTo(BigDecimal.valueOf(0)) != 0) {\n+                throw new WrongAttributeValueException(quotasAttribute, firstPlaceholder, secondPlaceholder, \"SoftQuota is set to unlimited (0) but hardQuota is limited to '\" + hardQuota + \"'.\");\n+                //2] if hardQuota is not unlimited but still it is less then softQuota = exception\n+            } else if (hardQuotaAfterTransfer.compareTo(BigDecimal.valueOf(0)) != 0 && hardQuotaAfterTransfer.compareTo(softQuotaAfterTransfer) < 0) {\n+                throw new WrongAttributeValueException(quotasAttribute, firstPlaceholder, secondPlaceholder, \"One of quotas is not correct. HardQuota '\" + hardQuota + \"' is less then softQuota '\" + softQuota + \"'.\");\n+            }\n+            //other cases are ok\n+\n+            transferedQuotas.put(canonicalPath, new Pair(softQuotaAfterTransfer, hardQuotaAfterTransfer));\n+        }\n+\n+        return transferedQuotas;\n+    }\n+\n+    @Override\n+    public Map<String, String> transferQuotasBackToAttributeValue(Map<String, Pair<BigDecimal, BigDecimal>> transferedQuotasMap, boolean withMetrics) throws InternalErrorException {\n+        Map<String, String> attributeQuotasValue = new HashMap<>();\n+        //if null or empty, return empty attribute value map for quotas\n+        if (transferedQuotasMap == null || transferedQuotasMap.isEmpty()) {\n+            return attributeQuotasValue;\n+        }\n+\n+        //every path with quotas transfer step by step\n+        for (String path : transferedQuotasMap.keySet()) {\n+            Pair<BigDecimal, BigDecimal> quotas = transferedQuotasMap.get(path);\n+            BigDecimal softQuotaBD = quotas.getLeft();\n+            BigDecimal hardQuotaBD = quotas.getRight();\n+\n+            //Divide decimal till it is still natural number\n+            //Soft Quota\n+            String softQuota = \"0\";\n+            //Zero means unlimited, stay the same\n+            if (softQuotaBD.compareTo(BigDecimal.ZERO) != 0) {\n+                if (withMetrics) {\n+                    softQuota = Utils.bigDecimalBytesToReadableStringWithMetric(softQuotaBD);\n+                } else {\n+                    softQuota = softQuotaBD.toPlainString();\n+                }\n+            }\n+            //Hard Quota\n+            String hardQuota = \"0\";\n+            //Zero means unlimited, stay the same\n+            if (hardQuotaBD.compareTo(BigDecimal.ZERO) != 0) {\n+                if (withMetrics) {\n+                    hardQuota = Utils.bigDecimalBytesToReadableStringWithMetric(hardQuotaBD);\n+                } else {\n+                    hardQuota = hardQuotaBD.toPlainString();\n+                }\n+            }\n+\n+            //add softQuota and hardQuota to result (50T:60T)\n+            attributeQuotasValue.put(path, softQuota + \":\" + hardQuota);\n+        }\n+        return attributeQuotasValue;\n+    }\n+\n+    @Override\n+    public Map<String, Pair<BigDecimal, BigDecimal>> mergeMemberAndResourceTransferedQuotas(Map<String, Pair<BigDecimal, BigDecimal>> firstQuotas, Map<String, Pair<BigDecimal, BigDecimal>> secondQuotas) {\n+        //if one of them is empty, return the other one (even if it is empty too)\n+        if (firstQuotas.isEmpty()) {\n+            return secondQuotas;\n+        }\n+        if (secondQuotas.isEmpty()) {\n+            return firstQuotas;\n+        }\n+\n+        Map<String, Pair<BigDecimal, BigDecimal>> mergedTransferedQuotas = new HashMap<>();\n+        //first go through firstQuotas values\n+        for (String path : firstQuotas.keySet()) {\n+            Pair<BigDecimal, BigDecimal> newValue;\n+            Pair<BigDecimal, BigDecimal> firstQuotasValue = firstQuotas.get(path);\n+            Pair<BigDecimal, BigDecimal> secondQuotasValue = secondQuotas.get(path);\n+\n+            //if there is no values for merge, use them\n+            if (secondQuotasValue == null) {\n+                newValue = firstQuotasValue;\n+                mergedTransferedQuotas.put(path, newValue);\n+                //if there are values to merge, merge them\n+            } else {\n+                BigDecimal softQuota;\n+                BigDecimal hardQuota;\n+                //merge softQuota\n+                if (firstQuotasValue.getLeft().compareTo(new BigDecimal(\"0\")) == 0 || secondQuotasValue.getLeft().compareTo(new BigDecimal(\"0\")) == 0) {\n+                    softQuota = new BigDecimal(\"0\");\n+                } else {\n+                    if (firstQuotasValue.getLeft().compareTo(secondQuotasValue.getLeft()) >= 0) {\n+                        softQuota = firstQuotasValue.getLeft();\n+                    } else {\n+                        softQuota = secondQuotasValue.getLeft();\n+                    }\n+                }\n+                //merge hardQuota\n+                if (firstQuotasValue.getRight().compareTo(new BigDecimal(\"0\")) == 0 || secondQuotasValue.getRight().compareTo(new BigDecimal(\"0\")) == 0) {\n+                    hardQuota = new BigDecimal(\"0\");\n+                } else {\n+                    if (firstQuotasValue.getRight().compareTo(secondQuotasValue.getRight()) >= 0) {\n+                        hardQuota = firstQuotasValue.getRight();\n+                    } else {\n+                        hardQuota = secondQuotasValue.getRight();\n+                    }\n+                }\n+                //set new merged values\n+                newValue = new Pair(softQuota, hardQuota);\n+                mergedTransferedQuotas.put(path, newValue);\n+                //remove them from second quotas (they are not unique)\n+                secondQuotas.remove(path);\n+            }\n+        }\n+        //save rest of values from secondQuotas (only unique in second quotas are still there, not exists in first quotas)\n+        for (String path : secondQuotas.keySet()) {\n+            mergedTransferedQuotas.put(path, secondQuotas.get(path));\n+        }\n+\n+        return mergedTransferedQuotas;\n+    }\n+\n+    public Map<String, Pair<BigDecimal, BigDecimal>> countUserFacilityQuotas(List<Map<String, Pair<BigDecimal, BigDecimal>>> allUserQuotas) {\n+        Map<String, Pair<BigDecimal, BigDecimal>> resultTransferredQuotas = new HashMap<>();\n+        //for every transfered map of merged quotas count one result transfered map\n+        for (Map<String, Pair<BigDecimal, BigDecimal>> mapValue : allUserQuotas) {\n+            //for every path in one transfered map\n+            for (String pathKey : mapValue.keySet()) {\n+                //if path not exists in result map, add it with it's values\n+                if (!resultTransferredQuotas.containsKey(pathKey)) {\n+                    resultTransferredQuotas.put(pathKey, mapValue.get(pathKey));\n+                    //if path already exists in result map, sum their quotas together\n+                } else {\n+                    Pair<BigDecimal, BigDecimal> quotasValue1 = resultTransferredQuotas.get(pathKey);\n+                    Pair<BigDecimal, BigDecimal> quotasValue2 = mapValue.get(pathKey);\n+                    //for soft quota (left part of pair)\n+                    BigDecimal softQuota = BigDecimal.ZERO;\n+                    if (quotasValue1.getLeft().compareTo(BigDecimal.ZERO) != 0 && quotasValue2.getLeft().compareTo(BigDecimal.ZERO) != 0) {\n+                        softQuota = quotasValue1.getLeft().add(quotasValue2.getLeft());\n+                    }\n+                    //for hard quota (right part of pair)\n+                    BigDecimal hardQuota = BigDecimal.ZERO;\n+                    if (quotasValue1.getRight().compareTo(BigDecimal.ZERO) != 0 && quotasValue2.getRight().compareTo(BigDecimal.ZERO) != 0) {\n+                        hardQuota = quotasValue1.getRight().add(quotasValue2.getRight());\n+                    }\n+                    //create new pair of summed numbers\n+                    Pair<BigDecimal, BigDecimal> finalQuotasValue = new Pair(softQuota, hardQuota);\n+                    //add new summed pair to the result map\n+                    resultTransferredQuotas.put(pathKey, finalQuotasValue);\n+                }\n+            }\n+        }\n+        //return result map\n+        return resultTransferredQuotas;\n+    }\n+\n+    /**\n+     * Get list of login-namespaces which have logins generated by Perun\n+     *\n+     * @return List of login-namespaces with generated logins\n+     */\n+    public static List<String> getGeneratedLoginNamespaces() {\n+\n+        // load namespaces to generate login for\n+        List<String> namespaces;\n+        try {\n+            String nmspc = BeansUtils.getPropertyFromConfiguration(\"perun.loginNamespace.generated\");\n+            namespaces = new ArrayList<String>(Arrays.asList(nmspc.split(\",\")));\n+            Iterator<String> nameIter = namespaces.listIterator();\n+            // trim and remove empty namespaces\n+            while (nameIter.hasNext()) {\n+                String namespace = nameIter.next();\n+                namespace = namespace.trim();\n+                if (namespace.isEmpty()) {\n+                    nameIter.remove();\n+                }\n+            }\n+        } catch (InternalErrorException ex) {\n+            // without value\n+            return new ArrayList<String>();\n+        }\n+\n+        return namespaces;\n+\n+    }\n+\n+    /**\n+     * Normalize string for purpose of generating safe login value.\n+     *\n+     * @return normalized string\n+     */\n+    public static String normalizeStringForLogin(String toBeNormalized) {\n+\n+        if (toBeNormalized == null || toBeNormalized.trim().isEmpty()) {\n+            return null;\n+        }\n+\n+        toBeNormalized = toBeNormalized.toLowerCase();\n+        toBeNormalized = java.text.Normalizer.normalize(toBeNormalized, java.text.Normalizer.Form.NFD).replaceAll(\"\\\\p{InCombiningDiacriticalMarks}+\", \"\");\n+        toBeNormalized = toBeNormalized.replaceAll(\"[^a-zA-Z]+\", \"\");\n+\n+        // unable to fill login for users without name or with partial name\n+        if (toBeNormalized == null || toBeNormalized.isEmpty()) {\n+            return null;\n+        }\n+\n+        return toBeNormalized;\n+\n+    }\n+\n+    /**\n+     * Shared logic for purpose of login generation\n+     */\n+    public static class LoginGenerator {\n+\n+        /**\n+         * Define joining function for anonymous classes\n+         */\n+        public interface LoginGeneratorFunction {\n+\n+            /**\n+             * Generate login for user using his name\n+             *\n+             * @param firstName\n+             * @param lastName\n+             * @return generated login\n+             */\n+            public String generateLogin(String firstName, String lastName);\n+\n+        }\n+\n+        /**\n+         * Generate login for user using his name and joining function\n+         *\n+         * @param user     User to get data from\n+         * @param function Function to join fist/lastName to login\n+         * @return generated login\n+         */\n+        public String generateLogin(User user, LoginGeneratorFunction function) {\n+\n+            String firstName = user.getFirstName();\n+            String lastName = user.getLastName();\n+\n+            // get only first part of first name and remove spec. chars\n+            if (firstName != null && !firstName.isEmpty()) {\n+                firstName = ModulesUtilsBlImpl.normalizeStringForLogin(firstName.split(\" \")[0]);\n+            }\n+\n+            // get only last part of last name and remove spec. chars\n+            if (lastName != null && !lastName.isEmpty()) {\n+                List<String> names = Arrays.asList(lastName.split(\" \"));\n+                lastName = names.get(names.size() - 1);\n+                lastName = ModulesUtilsBlImpl.normalizeStringForLogin(lastName.split(\" \")[0]);\n+            }\n+\n+            // unable to fill login for users without name or with partial name\n+            if (firstName == null || firstName.isEmpty() || lastName == null || lastName.isEmpty()) {\n+                return null;\n+            }\n+\n+            return function.generateLogin(firstName, lastName);\n+\n+        }\n+\n+    }\n+\n+    public PerunBl getPerunBl() {\n+        return this.perunBl;\n+    }\n+\n+    public void setPerunBl(PerunBl perunBl) {\n+        this.perunBl = perunBl;\n+    }\n }\n",
            "diff_size": 1137
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/386/ModulesUtilsBlImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/codebuff/386/ModulesUtilsBlImpl.java\nindex 17f40b462e4..646d9dd5a34 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/386/ModulesUtilsBlImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/codebuff/386/ModulesUtilsBlImpl.java\n@@ -36,1016 +36,1061 @@ import java.util.regex.Pattern;\n import java.util.regex.PatternSyntaxException;\n import java.net.URI;\n import java.net.URISyntaxException;\n-\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n /**\n  * @author Michal Stava <stavamichal@gmail.com>\n  */\n+\n+\n public class ModulesUtilsBlImpl implements ModulesUtilsBl {\n \n-\tfinal static Logger log = LoggerFactory.getLogger(ServicesManagerBlImpl.class);\n-\tprivate PerunBl perunBl;\n-\tMap<String,String> perunNamespaces = null;\n-\n-\tpublic static final String A_E_namespace_minGID = AttributesManager.NS_ENTITYLESS_ATTR_DEF + \":namespace-minGID\";\n-\tpublic static final String A_E_namespace_maxGID = AttributesManager.NS_ENTITYLESS_ATTR_DEF + \":namespace-maxGID\";\n-\tpublic static final String A_G_unixGID_namespace = AttributesManager.NS_GROUP_ATTR_DEF + \":unixGID-namespace\";\n-\tpublic static final String A_G_unixGroupName_namespace = AttributesManager.NS_GROUP_ATTR_DEF + \":unixGroupName-namespace\";\n-\tpublic static final String A_R_unixGID_namespace = AttributesManager.NS_RESOURCE_ATTR_DEF + \":unixGID-namespace\";\n-\tpublic static final String A_R_unixGroupName_namespace = AttributesManager.NS_RESOURCE_ATTR_DEF + \":unixGroupName-namespace\";\n-\tpublic static final String A_F_unixGID_namespace = AttributesManager.NS_FACILITY_ATTR_DEF + \":unixGID-namespace\";\n-\tpublic static final String A_F_unixGroupName_namespace = AttributesManager.NS_FACILITY_ATTR_DEF + \":unixGroupName-namespace\";\n-\tpublic static final String A_F_googleGroupName_namespace = AttributesManager.NS_FACILITY_ATTR_DEF + \":googleGroupNameNamespace\";\n-\tprivate static final String A_E_usedGids = AttributesManager.NS_ENTITYLESS_ATTR_DEF + \":usedGids\";\n-\n-\t//Often used patterns\n-\tpublic static final Pattern quotaWithMetricsPattern = Pattern.compile(\"^([0-9]+([.][0-9]+)?[KMGTPE]?):([0-9]+([.][0-9]+)?[KMGTPE]?)$\");\n-\tpublic static final Pattern quotaWithoutMetricsPattern = Pattern.compile(\"^([0-9]+)(:)([0-9]+)$\");\n-\tpublic static final Pattern numberPattern = Pattern.compile(\"[0-9]+([.][0-9]+)?\");\n-\tpublic static final Pattern letterPattern = Pattern.compile(\"[A-Z]\");\n-\n-\tpublic final static List<String> reservedNamesForUnixGroups = Arrays.asList(\"root\", \"daemon\", \"tty\", \"bin\", \"sys\", \"sudo\", \"nogroup\",\n-\t          \"hadoop\", \"hdfs\", \"mapred\", \"yarn\", \"hsqldb\", \"derby\", \"jetty\", \"hbase\", \"zookeeper\", \"users\");\n-\tpublic final static List<String> unpermittedNamesForUserLogins = Arrays.asList(\"arraysvcs\", \"at\", \"backup\", \"bin\", \"daemon\", \"Debian-exim\", \"flexlm\", \"ftp\", \"games\",\n-\t\t        \"gdm\", \"glite\", \"gnats\", \"haldaemon\", \"identd\", \"irc\", \"libuuid\", \"list\", \"lp\", \"mail\", \"man\",\n-\t\t        \"messagebus\", \"news\", \"nobody\", \"ntp\", \"openslp\", \"pcp\", \"polkituser\", \"postfix\", \"proxy\",\n-\t\t        \"pulse\", \"puppet\", \"root\", \"saned\", \"smmsp\", \"smmta\", \"sshd\", \"statd\", \"suse-ncc\", \"sync\",\n-\t\t        \"sys\", \"uucp\", \"uuidd\", \"www-data\", \"wwwrun\", \"zenssh\", \"tomcat6\", \"tomcat7\", \"tomcat8\",\n-\t\t        \"nn\", \"dn\", \"rm\", \"nm\", \"sn\", \"jn\", \"jhs\", \"http\", \"yarn\", \"hdfs\", \"mapred\", \"hadoop\", \"hsqldb\", \"derby\",\n-\t\t        \"jetty\", \"hbase\", \"zookeeper\", \"hive\", \"hue\");\n-\n-\t//Definition of K = KB, M = MB etc.\n-\tpublic static final long M = 1024;\n-\tpublic static final long G = M * 1024;\n-\tpublic static final long T = G * 1024;\n-\tpublic static final long P = T * 1024;\n-\tpublic static final long E = P * 1024;\n-\n-\tpublic ModulesUtilsBlImpl() {\n-\t}\n-\n-\tpublic boolean isNamespaceEqualsToFacilityUnixGroupNameNamespace(PerunSessionImpl sess, Facility facility, String namespace) throws InternalErrorException, AttributeNotExistsException, WrongAttributeAssignmentException{\n-\t\tUtils.notNull(facility, \"facility\");\n-\t\tUtils.notNull(namespace, \"namespace\");\n-\t\tUtils.notNull(sess, \"perunSessionImpl\");\n-\t\tAttribute facilityNamespaceAttr = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, facility, A_F_unixGroupName_namespace + \":\" + namespace);\n-\t\tif(facilityNamespaceAttr.getValue() == null) return false;\n-\t\tif(!namespace.equals(facilityNamespaceAttr.getValue())) {\n-\t\t\treturn false;\n-\t\t}\n-\t\treturn true;\n-\t}\n-\n-\tpublic List<Resource> findCollisionResourcesWithSameGroupName(PerunSessionImpl sess, Resource resource, String namespace) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException {\n-\t\tUtils.notNull(sess, \"perunSessionImpl\");\n-\t\tUtils.notNull(resource, \"resource\");\n-\t\tAttribute resourceUnixGroupName = getPerunBl().getAttributesManagerBl().getAttribute(sess, resource, A_R_unixGroupName_namespace + \":\" + namespace);\n-\t\tList<Resource> resourcesWithSameUnixGroupName = getPerunBl().getResourcesManagerBl().getResourcesByAttribute(sess, resourceUnixGroupName);\n-\t\tresourcesWithSameUnixGroupName.remove(resource);\n-\t\treturn resourcesWithSameUnixGroupName;\n-\t}\n-\n-\tpublic List<Resource> findCollisionResourcesWithSameGroupName(PerunSessionImpl sess, Group group, String namespace) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException {\n-\t\tUtils.notNull(sess, \"perunSessionImpl\");\n-\t\tUtils.notNull(group, \"group\");\n-\t\tUtils.notNull(namespace, \"namespace\");\n-\t\tAttribute groupUnixGroupName = getPerunBl().getAttributesManagerBl().getAttribute(sess, group, A_G_unixGroupName_namespace + \":\" + namespace);\n-\t\tAttribute copyResourceUnixGroupName = new Attribute(getPerunBl().getAttributesManagerBl().getAttributeDefinition(sess, A_R_unixGroupName_namespace + \":\" + namespace));\n-\t\tcopyResourceUnixGroupName.setValue(groupUnixGroupName.getValue());\n-\t\treturn getPerunBl().getResourcesManagerBl().getResourcesByAttribute(sess, copyResourceUnixGroupName);\n-\t}\n-\n-\tpublic List<Group> findCollisionGroupsWithSamgeGroupName(PerunSessionImpl sess, Resource resource, String namespace) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException {\n-\t\tUtils.notNull(sess, \"perunSessionImpl\");\n-\t\tUtils.notNull(resource, \"resource\");\n-\t\tUtils.notNull(namespace, \"namespace\");\n-\t\tAttribute resourceUnixGroupName = getPerunBl().getAttributesManagerBl().getAttribute(sess, resource, A_R_unixGroupName_namespace + \":\" + namespace);\n-\t\tAttribute copyGroupUnixGroupName = new Attribute(getPerunBl().getAttributesManagerBl().getAttributeDefinition(sess, A_G_unixGroupName_namespace + \":\" + namespace));\n-\t\tcopyGroupUnixGroupName.setValue(resourceUnixGroupName.getValue());\n-\t\treturn getPerunBl().getGroupsManagerBl().getGroupsByAttribute(sess, copyGroupUnixGroupName);\n-\n-\t}\n-\n-\tpublic List<Group> findCollisionGroupsWithSamgeGroupName(PerunSessionImpl sess, Group group, String namespace) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException {\n-\t\tUtils.notNull(sess, \"perunSessionImpl\");\n-\t\tUtils.notNull(group, \"group\");\n-\t\tUtils.notNull(namespace, \"namespace\");\n-\t\tAttribute groupUnixGroupName = getPerunBl().getAttributesManagerBl().getAttribute(sess, group, A_G_unixGroupName_namespace + \":\" + namespace);\n-\t\tList<Group> groupsWithsameGroupName = getPerunBl().getGroupsManagerBl().getGroupsByAttribute(sess, groupUnixGroupName);\n-\t\tgroupsWithsameGroupName.remove(group);\n-\t\treturn groupsWithsameGroupName;\n-\t}\n-\n-\tpublic List<Resource> findCollisionResourcesWithSameGid(PerunSessionImpl sess, Resource resource, String namespace) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException {\n-\t\tUtils.notNull(sess, \"perunSessionImpl\");\n-\t\tUtils.notNull(resource, \"resource\");\n-\t\tUtils.notNull(namespace, \"namespace\");\n-\t\tAttribute resourceUnixGid = getPerunBl().getAttributesManagerBl().getAttribute(sess, resource, A_R_unixGID_namespace + \":\" + namespace);\n-\t\tList<Resource> resourcesWithSameGid = getPerunBl().getResourcesManagerBl().getResourcesByAttribute(sess, resourceUnixGid);\n-\t\tresourcesWithSameGid.remove(resource);\n-\t\treturn resourcesWithSameGid;\n-\t}\n-\n-\tpublic List<Resource> findCollisionResourcesWithSameGid(PerunSessionImpl sess, Group group, String namespace) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException {\n-\t\tUtils.notNull(sess, \"perunSessionImpl\");\n-\t\tUtils.notNull(group, \"group\");\n-\t\tUtils.notNull(namespace, \"namespace\");\n-\t\tAttribute groupUnixGid = getPerunBl().getAttributesManagerBl().getAttribute(sess, group, A_G_unixGID_namespace + \":\" + namespace);\n-\t\tAttribute copyResourceUnixGid = new Attribute(getPerunBl().getAttributesManagerBl().getAttributeDefinition(sess, A_R_unixGID_namespace + \":\" + namespace));\n-\t\tcopyResourceUnixGid.setValue(groupUnixGid.getValue());\n-\t\treturn getPerunBl().getResourcesManagerBl().getResourcesByAttribute(sess, copyResourceUnixGid);\n-\t}\n-\n-\tpublic List<Group> findCollisionGroupsWithSamgeGroupGid(PerunSessionImpl sess, Resource resource, String namespace) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException {\n-\t\tUtils.notNull(sess, \"perunSessionImpl\");\n-\t\tUtils.notNull(resource, \"resource\");\n-\t\tUtils.notNull(namespace, \"namespace\");\n-\t\tAttribute resourceUnixGid = getPerunBl().getAttributesManagerBl().getAttribute(sess, resource, A_R_unixGID_namespace + \":\" + namespace);\n-\t\tAttribute copyGroupUnixGid = new Attribute(getPerunBl().getAttributesManagerBl().getAttributeDefinition(sess, A_G_unixGID_namespace + \":\" + namespace));\n-\t\tcopyGroupUnixGid.setValue(resourceUnixGid.getValue());\n-\t\treturn getPerunBl().getGroupsManagerBl().getGroupsByAttribute(sess, copyGroupUnixGid);\n-\t}\n-\n-\tpublic List<Group> findCollisionGroupsWithSamgeGroupGid(PerunSessionImpl sess, Group group, String namespace) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException {\n-\t\tUtils.notNull(sess, \"perunSessionImpl\");\n-\t\tUtils.notNull(group, \"group\");\n-\t\tUtils.notNull(namespace, \"namespace\");\n-\t\tAttribute groupUnixGid = getPerunBl().getAttributesManagerBl().getAttribute(sess, group, A_G_unixGID_namespace + \":\" + namespace);\n-\t\tList<Group> groupsWithSameUnixGid = getPerunBl().getGroupsManagerBl().getGroupsByAttribute(sess, groupUnixGid);\n-\t\tgroupsWithSameUnixGid.remove(group);\n-\t\treturn groupsWithSameUnixGid;\n-\t}\n-\n-\tpublic boolean hasAccessToWriteToAttributeForAnyResource(PerunSessionImpl sess, AttributeDefinition attrDef, List<Resource> resources) throws InternalErrorException {\n-\t\tUtils.notNull(sess, \"perunSessionImpl\");\n-\t\tUtils.notNull(attrDef, \"attributeDefinition\");\n-\t\tif(resources == null || resources.isEmpty()) return false;\n-\t\tfor(Resource r: resources) {\n-\t\t\tif(AuthzResolver.isAuthorizedForAttribute(sess, ActionType.WRITE, attrDef , r, null)) return true;\n-\t\t}\n-\t\treturn false;\n-\t}\n-\n-\tpublic boolean hasAccessToWriteToAttributeForAnyGroup(PerunSessionImpl sess, AttributeDefinition attrDef, List<Group> groups) throws InternalErrorException {\n-\t\tUtils.notNull(sess, \"perunSessionImpl\");\n-\t\tUtils.notNull(attrDef, \"attributeDefinition\");\n-\t\tif(groups == null || groups.isEmpty()) return false;\n-\t\tfor(Group g: groups) {\n-\t\t\tif(AuthzResolver.isAuthorizedForAttribute(sess, ActionType.WRITE, attrDef, g, null)) return true;\n-\t\t}\n-\t\treturn false;\n-\t}\n-\n-\tpublic Pair<Integer, Integer> getMinAndMaxGidForNamespace(PerunSessionImpl sess, String namespace) throws InternalErrorException, AttributeNotExistsException, WrongAttributeAssignmentException {\n-\t\tUtils.notNull(sess, \"perunSessionImpl\");\n-\t\tUtils.notNull(namespace, \"namespace\");\n-\t\tAttribute minGidAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, namespace, A_E_namespace_minGID);\n-\t\tInteger minGid = null;\n-\t\tif(minGidAttribute.getValue() != null) minGid = (Integer) minGidAttribute.getValue();\n-\n-\t\tAttribute maxGidAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, namespace, A_E_namespace_maxGID);\n-\t\tInteger maxGid = null;\n-\t\tif(maxGidAttribute.getValue() != null) maxGid = (Integer) maxGidAttribute.getValue();\n-\n-\t\treturn new Pair(minGid, maxGid);\n-\t}\n-\n-\tpublic Integer getFirstFreeGidForResourceOrGroup(PerunSessionImpl sess, String namespace) throws InternalErrorException, AttributeNotExistsException, WrongAttributeAssignmentException {\n-\t\tUtils.notNull(sess, \"perunSessionImpl\");\n-\t\tUtils.notNull(namespace, \"namespace\");\n-\t\tPair<Integer, Integer> minAndMaxGid = this.getMinAndMaxGidForNamespace(sess, namespace);\n-\n-\t\t//If there is no min or max gid, return null instead of number, its same like no free gid was able\n-\t\tif(minAndMaxGid == null || minAndMaxGid.getLeft() == null || minAndMaxGid.getRight() == null) return null;\n-\n-\t\tAttributeDefinition resourceUnixGid = getPerunBl().getAttributesManagerBl().getAttributeDefinition(sess, A_R_unixGID_namespace + \":\" + namespace);\n-\t\tList<Object> allGids = sess.getPerunBl().getAttributesManagerBl().getAllValues(sess, resourceUnixGid);\n-\t\tAttributeDefinition groupUnixGid = getPerunBl().getAttributesManagerBl().getAttributeDefinition(sess, A_G_unixGID_namespace + \":\" + namespace);\n-\t\tallGids.addAll(sess.getPerunBl().getAttributesManagerBl().getAllValues(sess, groupUnixGid)); //note: it doesn't matter if the group is not active (isUnixGroup attribute != 1)\n-\n-\t\tfor(int i = minAndMaxGid.getLeft(); i < minAndMaxGid.getRight(); i++) {\n-\t\t\tif(!allGids.contains(i)) {\n-\t\t\t\treturn i;\n-\t\t\t}\n-\t\t}\n-\t\treturn null;\n-\t}\n-\n-\tpublic void checkIfGIDIsWithinRange(PerunSessionImpl sess, Attribute attribute) throws InternalErrorException, WrongReferenceAttributeValueException, WrongAttributeAssignmentException, AttributeNotExistsException, WrongAttributeValueException {\n-\t\tUtils.notNull(attribute, \"attribute\");\n-\t\tInteger gid = null;\n-\t\tif(attribute.getValue() != null) gid = (Integer) attribute.getValue();\n-\n-\t\tif(gid == null) throw new WrongAttributeValueException(attribute, \"Gid with null value is not allowed.\");\n-\n-\t\tString gidNamespace = attribute.getFriendlyNameParameter();\n-\n-\t\tAttribute minGidAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, gidNamespace, A_E_namespace_minGID);\n-\t\tif(minGidAttribute.getValue() == null) throw new WrongReferenceAttributeValueException(attribute, minGidAttribute);\n-\t\tInteger minGid = (Integer) minGidAttribute.getValue();\n-\n-\t\tAttribute maxGidAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, gidNamespace, A_E_namespace_maxGID);\n-\t\tif(maxGidAttribute.getValue() == null) throw new WrongReferenceAttributeValueException(attribute, maxGidAttribute);\n-\t\tInteger maxGid = (Integer) maxGidAttribute.getValue();\n-\n-\t\tif ( gid < minGid || gid > maxGid ) {\n-\t\t\tthrow new WrongAttributeValueException(attribute,\"GID number is not in allowed values min: \"+minGid+\", max:\"+maxGid);\n-\t\t}\n-\t}\n-\n-\tpublic void checkIfListOfGIDIsWithinRange(PerunSessionImpl sess, User user, Attribute attribute) throws InternalErrorException, WrongReferenceAttributeValueException, WrongAttributeAssignmentException, AttributeNotExistsException, WrongAttributeValueException {\n-\t\tUtils.notNull(attribute, \"attribute\");\n-\t\tList<String> gIDs = (List<String>)attribute.getValue();\n-\t\tif (gIDs != null){\n-\t\t\tfor(String sGid : gIDs){\n-\t\t\t\ttry{\n-\t\t\t\t\tInteger gid = new Integer(sGid);\n-\t\t\t\t\tString gidNamespace = attribute.getFriendlyNameParameter();\n-\n-\t\t\t\t\tAttribute minGidAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, gidNamespace, A_E_namespace_minGID);\n-\t\t\t\t\tif(minGidAttribute.getValue() == null) throw new WrongReferenceAttributeValueException(attribute, minGidAttribute, \"Attribute minGid cannot be null\");\n-\t\t\t\t\tInteger minGid = (Integer) minGidAttribute.getValue();\n-\n-\t\t\t\t\tAttribute maxGidAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, gidNamespace, A_E_namespace_maxGID);\n-\t\t\t\t\tif(maxGidAttribute.getValue() == null) throw new WrongReferenceAttributeValueException(attribute, maxGidAttribute, \"Attribute maxGid cannot be null\");\n-\t\t\t\t\tInteger maxGid = (Integer) maxGidAttribute.getValue();\n-\n-\t\t\t\t\tif ( gid < minGid || gid > maxGid ) {\n-\t\t\t\t\t\tthrow new WrongAttributeValueException(attribute,\"GID number is not in allowed values min: \"+minGid+\", max:\"+maxGid);\n-\t\t\t\t\t}\n-\t\t\t\t}catch(NumberFormatException ex){\n-\t\t\t\t\tthrow new WrongAttributeValueException(attribute ,user,\"attribute is not a number\", ex);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic Integer getFreeGID(PerunSessionImpl sess, Attribute attribute) throws InternalErrorException, AttributeNotExistsException, WrongAttributeAssignmentException {\n-\t\tUtils.notNull(attribute, \"attribute\");\n-\t\tString gidNamespace = attribute.getFriendlyNameParameter();\n-\n-\t\tAttribute minGidAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, gidNamespace, A_E_namespace_minGID);\n-\t\tif(minGidAttribute.getValue() == null) return 0;\n-\t\tInteger minGid = (Integer) minGidAttribute.getValue();\n-\n-\t\tAttribute maxGidAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, gidNamespace, A_E_namespace_maxGID);\n-\t\tif(maxGidAttribute.getValue() == null) return 0;\n-\t\tInteger maxGid = (Integer) maxGidAttribute.getValue();\n-\n-\t\tList<Integer> allGids = new ArrayList<>();\n-\t\tAttribute usedGids = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, gidNamespace, A_E_usedGids);\n-\n-\t\tif(usedGids.getValue() == null) return minGid;\n-\t\telse {\n-\t\t\tMap<String,String> usedGidsValue = (Map<String, String>) usedGids.getValue();\n-\t\t\tSet<String> keys = usedGidsValue.keySet();\n-\n-\t\t\tfor(String key: keys) {\n-\t\t\t\tallGids.add(Integer.parseInt(usedGidsValue.get(key)));\n-\t\t\t}\n-\t\t}\n-\n-\t\tfor(int i = minGid; i < maxGid; i++) {\n-\t\t\tif(!allGids.contains(i)) {\n-\t\t\t\treturn i;\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn null;\n-\t}\n-\n-\tpublic Integer getCommonGIDOfGroupsWithSameNameInSameNamespace(PerunSessionImpl sess, List<Group> groupsWithSameGroupNameInSameNamespace, String gidNamespace, Integer commonGID) throws InternalErrorException, WrongAttributeAssignmentException {\n-\t\t//If there are no groups, return commonGID from param (it can be null)\n-\t\tif(groupsWithSameGroupNameInSameNamespace == null || groupsWithSameGroupNameInSameNamespace.isEmpty()) return commonGID;\n-\t\tUtils.notNull(gidNamespace, \"gidNamespace\");\n-\n-\t\tGroup commonGIDGroup = null;  //only for more verbose exception messages\n-\t\tfor(Group g: groupsWithSameGroupNameInSameNamespace) {\n-\t\t\ttry {\n-\t\t\t\tAttribute attr = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, g, A_G_unixGID_namespace + \":\" + gidNamespace);\n-\t\t\t\tif(attr.getValue() != null) {\n-\t\t\t\t\tif(commonGID == null) {\n-\t\t\t\t\t\tcommonGIDGroup = g;\n-\t\t\t\t\t\tcommonGID = (Integer) attr.getValue();\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tif(!commonGID.equals((Integer) attr.getValue())) throw new ConsistencyErrorException(\"There are at least 1 groups/resources with same GroupName in same namespace but with different GID in same namespaces. Conflict found: \"  + g + \"(gid=\" + attr.getValue()+ \") and \" + commonGIDGroup + \"(gid=\" + commonGID + \")\");\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t} catch (AttributeNotExistsException ex) {\n-\t\t\t\tthrow new ConsistencyErrorException(ex);\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn commonGID;\n-\t}\n-\n-\tpublic Integer getCommonGIDOfResourcesWithSameNameInSameNamespace(PerunSessionImpl sess, List<Resource> resourcesWithSameGroupNameInSameNamespace, String gidNamespace, Integer commonGID) throws InternalErrorException, WrongAttributeAssignmentException {\n-\t\t//If there are no resources, return commonGID from param (it can be null)\n-\t\tif(resourcesWithSameGroupNameInSameNamespace == null || resourcesWithSameGroupNameInSameNamespace.isEmpty()) return commonGID;\n-\t\tUtils.notNull(gidNamespace,\"gidNamespace\");\n-\n-\t\tResource commonGIDResource = null;   //only for more verbose exception messages\n-\t\tfor(Resource r: resourcesWithSameGroupNameInSameNamespace) {\n-\t\t\ttry {\n-\t\t\t\tAttribute attr = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, r, A_R_unixGID_namespace + \":\" + gidNamespace);\n-\t\t\t\tif(attr.getValue() != null) {\n-\t\t\t\t\tif(commonGID == null) {\n-\t\t\t\t\t\tcommonGIDResource = r;\n-\t\t\t\t\t\tcommonGID = (Integer) attr.getValue();\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tif(!commonGID.equals((Integer) attr.getValue())) throw new ConsistencyErrorException(\"There are at least 1 groups/resources with same GroupName in same namespace but with different GID in same namespaces. Conflict found: \" + r + \"(gid=\" + attr.getValue()+ \") and \" + commonGIDResource + \"(gid=\" + commonGID + \")\");\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t} catch (AttributeNotExistsException ex) {\n-\t\t\t\tthrow new ConsistencyErrorException(ex);\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn commonGID;\n-\t}\n-\n-\tpublic int haveTheSameAttributeWithTheSameNamespace(PerunSessionImpl sess, Group group, Attribute attr) throws InternalErrorException, WrongAttributeAssignmentException {\n-\t\tUtils.notNull(group, \"group\");\n-\t\tUtils.notNull(attr, \"attr\");\n-\n-\t\tString attributeNamespace = attr.getFriendlyNameParameter();\n-\t\tif(attributeNamespace == null || attributeNamespace.isEmpty()) throw new InternalErrorException(\"Attribute has no namespace, this method can't be use.\");\n-\n-\t\ttry {\n-\t\t\tAttribute testingAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, group, attr.getName());\n-\t\t\tif(testingAttribute.getValue() == null) return -1;\n-\t\t\telse {\n-\t\t\t\tif(!testingAttribute.getValue().equals(attr.getValue())) return 1;\n-\t\t\t}\n-\t\t} catch (AttributeNotExistsException ex) {\n-\t\t\tthrow new ConsistencyErrorException(ex);\n-\t\t}\n-\t\treturn 0;\n-\t}\n-\n-\tpublic int haveTheSameAttributeWithTheSameNamespace(PerunSessionImpl sess, Resource resource, Attribute attr) throws InternalErrorException, WrongAttributeAssignmentException{\n-\t\tUtils.notNull(resource, \"resource\");\n-\t\tUtils.notNull(attr, \"attr\");\n-\n-\t\tString attributeNamespace = attr.getFriendlyNameParameter();\n-\t\tif(attributeNamespace == null || attributeNamespace.isEmpty()) throw new InternalErrorException(\"Attribute has no namespace, this method can't be use.\");\n-\n-\t\ttry {\n-\t\t\tAttribute testingAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, resource, attr.getName());\n-\t\t\tif(testingAttribute.getValue() == null) return -1;\n-\t\t\telse {\n-\t\t\t\tif(!testingAttribute.getValue().equals(attr.getValue())) return 1;\n-\t\t\t}\n-\t\t} catch (AttributeNotExistsException ex) {\n-\t\t\tthrow new ConsistencyErrorException(ex);\n-\t\t}\n-\t\treturn 0;\n-\t}\n-\n-\tpublic boolean haveRightToWriteAttributeInAnyGroupOrResource(PerunSessionImpl sess, List<Group> groups, List<Resource> resources, AttributeDefinition groupAttribute, AttributeDefinition resourceAttribute) throws InternalErrorException {\n-\t\tif(groups != null && !groups.isEmpty() && groupAttribute != null) {\n-\t\t\tfor(Group g: groups) {\n-\t\t\t\tif(AuthzResolver.isAuthorizedForAttribute(sess, ActionType.WRITE, groupAttribute, g, null)) return true;\n-\t\t\t}\n-\t\t}\n-\n-\t\tif(resources != null && !resources.isEmpty() && resourceAttribute != null) {\n-\t\t\tfor(Resource r: resources) {\n-\t\t\t\tif(AuthzResolver.isAuthorizedForAttribute(sess, ActionType.WRITE, resourceAttribute, r, null)) return true;\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn false;\n-\t}\n-\n-\tpublic List<Attribute> getListOfResourceGIDsFromListOfGroupGIDs(PerunSessionImpl sess, List<Attribute> groupGIDs) throws InternalErrorException, AttributeNotExistsException {\n-\t\tList<Attribute> resourceGIDs = new ArrayList<Attribute>();\n-\t\tif(groupGIDs == null || groupGIDs.isEmpty()) {\n-\t\t\treturn resourceGIDs;\n-\t\t}\n-\n-\t\tfor(Attribute a: groupGIDs) {\n-\t\t\tAttribute resourceGID = new Attribute(sess.getPerunBl().getAttributesManagerBl().getAttributeDefinition(sess, A_R_unixGID_namespace + \":\" + a.getFriendlyNameParameter()));\n-\t\t\tresourceGID.setValue(a.getValue());\n-\t\t\tresourceGIDs.add(resourceGID);\n-\t\t}\n-\n-\t\treturn resourceGIDs;\n-\t}\n-\n-\tpublic List<Attribute> getListOfGroupGIDsFromListOfResourceGIDs(PerunSessionImpl sess, List<Attribute> resourceGIDs) throws InternalErrorException, AttributeNotExistsException {\n-\t\tList<Attribute> groupGIDs = new ArrayList<Attribute>();\n-\t\tif(resourceGIDs == null || resourceGIDs.isEmpty()) {\n-\t\t\treturn groupGIDs;\n-\t\t}\n-\n-\t\tfor(Attribute a: resourceGIDs) {\n-\t\t\tAttribute groupGID = new Attribute(sess.getPerunBl().getAttributesManagerBl().getAttributeDefinition(sess, A_G_unixGID_namespace + \":\" + a.getFriendlyNameParameter()));\n-\t\t\tgroupGID.setValue(a.getValue());\n-\t\t\tgroupGIDs.add(groupGID);\n-\t\t}\n-\n-\t\treturn groupGIDs;\n-\t}\n-\n-\tpublic Set<String> getSetOfGIDNamespacesWhereFacilitiesHasTheSameGroupNameNamespace(PerunSessionImpl sess, List<Facility> facilities, Attribute unixGroupNameNamespace) throws InternalErrorException, WrongAttributeAssignmentException, WrongReferenceAttributeValueException {\n-\t\tSet<String> gidNamespaces = new HashSet<String>();\n-\t\tif(facilities == null || facilities.isEmpty()) return gidNamespaces;\n-\t\tUtils.notNull(facilities, \"facilities\");\n-\n-\t\tfor(Facility f: facilities) {\n-\t\t\tAttribute facilityGroupNameNamespace;\n-\t\t\ttry {\n-\t\t\t\tfacilityGroupNameNamespace = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, f, A_F_unixGroupName_namespace);\n-\t\t\t\tif(facilityGroupNameNamespace.getValue() != null) {\n-\t\t\t\t\t//if they are same, save GID-namespace from this facility to hashSet\n-\t\t\t\t\tif(unixGroupNameNamespace.getFriendlyNameParameter().equals((String) facilityGroupNameNamespace.getValue())) {\n-\t\t\t\t\t\tAttribute facilityGIDNamespace = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, f, A_F_unixGID_namespace);\n-\t\t\t\t\t\t//If facilityGIDNamespace exists and is not null, save to the hashSet of gidNamespaces\n-\t\t\t\t\t\tif(facilityGIDNamespace.getValue() != null) {\n-\t\t\t\t\t\t\tgidNamespaces.add((String) facilityGIDNamespace.getValue());\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t} catch (AttributeNotExistsException ex) {\n-\t\t\t\tthrow new ConsistencyErrorException(ex);\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn gidNamespaces;\n-\t}\n-\n-\tpublic Set<String> getSetOfGroupNameNamespacesWhereFacilitiesHasTheSameGIDNamespace(PerunSessionImpl sess, List<Facility> facilities, Attribute unixGIDNamespace) throws InternalErrorException, WrongAttributeAssignmentException, WrongReferenceAttributeValueException {\n-\t\tSet<String> groupNameNamespaces = new HashSet<String>();\n-\t\tif(facilities == null || facilities.isEmpty()) return groupNameNamespaces;\n-\t\tUtils.notNull(unixGIDNamespace, \"unixGIDNamespace\");\n-\n-\t\tfor(Facility f: facilities) {\n-\t\t\tAttribute facilityGIDNamespace;\n-\t\t\ttry {\n-\t\t\t\tfacilityGIDNamespace = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, f, A_F_unixGID_namespace);\n-\t\t\t\tif(facilityGIDNamespace.getValue() != null) {\n-\t\t\t\t\t//if they are same, save GroupName-namespace from this facility to hashSet\n-\t\t\t\t\tif(unixGIDNamespace.getFriendlyNameParameter().equals((String) facilityGIDNamespace.getValue())) {\n-\t\t\t\t\t\tAttribute facilityGroupNameNamespace = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, f, A_F_unixGroupName_namespace);\n-\t\t\t\t\t\t//If facilityGroupNameNamespace exists and is not null, save to the hashSet of gidNamespaces\n-\t\t\t\t\t\tif(facilityGroupNameNamespace.getValue() != null) {\n-\t\t\t\t\t\t\tgroupNameNamespaces.add((String) facilityGroupNameNamespace.getValue());\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tthrow new WrongReferenceAttributeValueException(unixGIDNamespace, facilityGroupNameNamespace, \"Facility has gidNamespace set, but groupNameNamespace not set.\");\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t} catch (AttributeNotExistsException ex) {\n-\t\t\t\tthrow new ConsistencyErrorException(ex);\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn groupNameNamespaces;\n-\t}\n-\n-\tpublic void checkReservedUnixGroupNames(Attribute groupNameAttribute) throws InternalErrorException, WrongAttributeValueException {\n-\t\tif(groupNameAttribute == null) return;\n-\t\tcheckPerunNamespacesMap();\n-\n-\t\tString reservedNames = perunNamespaces.get(groupNameAttribute.getFriendlyName() + \":reservedNames\");\n-\t\tif (reservedNames != null) {\n-\t\t\tList<String> reservedNamesList = Arrays.asList(reservedNames.split(\"\\\\s*,\\\\s*\"));\n-\t\t\tif (reservedNamesList.contains(groupNameAttribute.getValue()))\n-\t\t\t\tthrow new WrongAttributeValueException(groupNameAttribute, \"This groupName is reserved.\");\n-\t\t} else {\n-\t\t\t//Property not found in our attribute map, so we will use the default hardcoded values instead\n-\t\t\tif (reservedNamesForUnixGroups.contains(groupNameAttribute.getValue()))\n-\t\t\t\tthrow new WrongAttributeValueException(groupNameAttribute, \"This groupName is reserved.\");\n-\t\t}\n-\t}\n-\n-\tpublic void checkUnpermittedUserLogins(Attribute loginAttribute) throws InternalErrorException, WrongAttributeValueException {\n-\t\tif(loginAttribute == null) return;\n-\t\tcheckPerunNamespacesMap();\n-\n-\t\tString unpermittedNames = perunNamespaces.get(loginAttribute.getFriendlyName() + \":reservedNames\");\n-\t\tif (unpermittedNames != null) {\n-\t\t\tList<String> unpermittedNamesList = Arrays.asList(unpermittedNames.split(\"\\\\s*,\\\\s*\"));\n-\t\t\tif (unpermittedNamesList.contains(loginAttribute.getValue()))\n-\t\t\t\tthrow new WrongAttributeValueException(loginAttribute, \"This login is not permitted.\");\n-\t\t} else {\n-\t\t\t//Property not found in our attribute map, so we will use the default hardcoded values instead\n-\t\t\tif (unpermittedNamesForUserLogins.contains(loginAttribute.getValue()))\n-\t\t\t\tthrow new WrongAttributeValueException(loginAttribute, \"This login is not permitted.\");\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic Attribute getGoogleGroupNameNamespaceAttributeWithNotNullValue(PerunSessionImpl sess, Resource resource) throws InternalErrorException, WrongReferenceAttributeValueException {\n-\t\tFacility facility = sess.getPerunBl().getResourcesManagerBl().getFacility(sess, resource);\n-\t\ttry {\n-\t\t\tAttribute googleGroupNameNamespaceAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, facility, A_F_googleGroupName_namespace);\n-\t\t\tif(googleGroupNameNamespaceAttribute.getValue() == null) throw new WrongReferenceAttributeValueException(googleGroupNameNamespaceAttribute);\n-\t\t\treturn googleGroupNameNamespaceAttribute;\n-\t\t} catch(AttributeNotExistsException ex) {\n-\t\t\tthrow new ConsistencyErrorException(ex);\n-\t\t} catch(WrongAttributeAssignmentException ex) {\n-\t\t\tthrow new InternalErrorException(ex);\n-\t\t}\n-\t}\n-\n-\tpublic Attribute getUnixGroupNameNamespaceAttributeWithNotNullValue(PerunSessionImpl sess, Resource resource) throws InternalErrorException, WrongReferenceAttributeValueException {\n-\t\tFacility facility = sess.getPerunBl().getResourcesManagerBl().getFacility(sess, resource);\n-\t\ttry {\n-\t\t\tAttribute unixGroupNameNamespaceAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, facility, A_F_unixGroupName_namespace);\n-\t\t\tif(unixGroupNameNamespaceAttribute.getValue() == null) throw new WrongReferenceAttributeValueException(unixGroupNameNamespaceAttribute);\n-\t\t\treturn unixGroupNameNamespaceAttribute;\n-\t\t} catch(AttributeNotExistsException ex) {\n-\t\t\tthrow new ConsistencyErrorException(ex);\n-\t\t} catch(WrongAttributeAssignmentException ex) {\n-\t\t\tthrow new InternalErrorException(ex);\n-\t\t}\n-\t}\n-\n-\tpublic Attribute getUnixGIDNamespaceAttributeWithNotNullValue(PerunSessionImpl sess, Resource resource) throws InternalErrorException, WrongReferenceAttributeValueException {\n-\t\tFacility facility = sess.getPerunBl().getResourcesManagerBl().getFacility(sess, resource);\n-\t\ttry {\n-\t\t\tAttribute unixGIDNamespaceAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, facility, A_F_unixGID_namespace);\n-\t\t\tif(unixGIDNamespaceAttribute.getValue() == null) throw new WrongReferenceAttributeValueException(unixGIDNamespaceAttribute);\n-\t\t\treturn unixGIDNamespaceAttribute;\n-\t\t} catch(AttributeNotExistsException ex) {\n-\t\t\tthrow new ConsistencyErrorException(ex);\n-\t\t} catch(WrongAttributeAssignmentException ex) {\n-\t\t\tthrow new InternalErrorException(ex);\n-\t\t}\n-\t}\n-\n-\tpublic boolean isGroupUnixGIDNamespaceFillable(PerunSessionImpl sess, Group group, Attribute groupUnixGIDNamespace) throws InternalErrorException, WrongReferenceAttributeValueException, WrongAttributeAssignmentException {\n-\t\tUtils.notNull(group, \"group\");\n-\t\tUtils.notNull(groupUnixGIDNamespace, \"groupUnixGIDNamespace\");\n-\n-\t\t//Get All Facilities from group\n-\t\tSet<Facility> facilitiesOfGroup = new HashSet<Facility>();\n-\t\tList<Resource> resourcesOfGroup = sess.getPerunBl().getResourcesManagerBl().getAssignedResources(sess, group);\n-\t\tfor(Resource r: resourcesOfGroup) {\n-\t\t\tfacilitiesOfGroup.add(sess.getPerunBl().getResourcesManagerBl().getFacility(sess, r));\n-\t\t}\n-\n-\t\t//Prepare list of gid namespaces of all facilities which have the same groupName namespace like this unixGroupName namespace\n-\t\tSet<String> groupNameNamespaces = this.getSetOfGroupNameNamespacesWhereFacilitiesHasTheSameGIDNamespace(sess, new ArrayList<Facility>(facilitiesOfGroup), groupUnixGIDNamespace);\n-\n-\t\tif(!groupNameNamespaces.isEmpty()) {\n-\t\t\tfor(String s: groupNameNamespaces) {\n-\t\t\t\ttry {\n-\t\t\t\t\tAttribute groupNameNamespace = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, group, A_G_unixGroupName_namespace + \":\" + s);\n-\t\t\t\t\tif(groupNameNamespace.getValue() != null) {\n-\t\t\t\t\t\treturn true;\n-\t\t\t\t\t}\n-\t\t\t\t} catch (AttributeNotExistsException ex) {\n-\t\t\t\t\tthrow new ConsistencyErrorException(ex);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn false;\n-\t}\n-\n-\t@Override\n-\tpublic boolean isNameOfEmailValid(PerunSessionImpl sess, String email) {\n-\t\tif (email == null) return false;\n-\n-\t\tMatcher emailMatcher = Utils.emailPattern.matcher(email);\n-\t\tif (emailMatcher.find()) return true;\n-\n-\t\treturn false;\n-\t}\n-\n-\tpublic void checkFormatOfShell(String shell, Attribute attribute) throws WrongAttributeValueException {\n-\t\t//previous regex ^/[-a-zA-Z0-9_/]*$\"\n-\t\tPattern pattern = Pattern.compile(\"^(/[-_a-zA-Z0-9]+)+$\");\n-\n-\t\tMatcher match = pattern.matcher(shell);\n-\n-\t\tif (!match.matches()) {\n-\t\t\tthrow new WrongAttributeValueException(attribute, \"Bad shell attribute format \" + shell);\n-\t\t}\n-\t}\n-\n-\tpublic void checkAttributeRegex(Attribute attribute, String defaultRegex) throws InternalErrorException, WrongAttributeValueException {\n-\t\tif (attribute == null || attribute.getValue() == null) throw new InternalErrorException(\"Attribute or it's value is null.\");\n-\t\tString attributeValue = (String) attribute.getValue();\n-\t\tcheckPerunNamespacesMap();\n-\n-\t\tString regex = perunNamespaces.get(attribute.getFriendlyName() + \":regex\");\n-\t\tif (regex != null) {\n-\t\t\t//Check if regex is valid\n-\t\t\ttry {\n-\t\t\t\tPattern.compile(regex);\n-\t\t\t} catch (PatternSyntaxException e) {\n-\t\t\t\tlog.error(\"Regex pattern \\\"\" + regex + \"\\\" from \\\"\" + attribute.getFriendlyName() + \":regex\\\"\" + \" property of perun-namespaces.properties file is invalid.\");\n-\t\t\t\tthrow new InternalErrorException(\"Regex pattern \\\"\" + regex + \"\\\" from \\\"\" + attribute.getFriendlyName() + \":regex\\\"\" + \" property of perun-namespaces.properties file is invalid.\");\n-\t\t\t}\n-\t\t\tif(!attributeValue.matches(regex)) {\n-\t\t\t\tthrow new WrongAttributeValueException(attribute, \"Wrong format. Regex: \\\"\" + regex +\"\\\" expected for this attribute:\");\n-\t\t\t}\n-\t\t} else {\n-\t\t\t//Regex property not found in our attribute map, so use the default hardcoded regex\n-\t\t\tif (defaultRegex == null) return;\n-\t\t\tif (!attributeValue.matches(defaultRegex)) {\n-\t\t\t\tthrow new WrongAttributeValueException(attribute, \"Wrong format. Regex: \\\"\" + defaultRegex +\"\\\" expected for this attribute:\");\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Internal protected method.\n-\t * Checks this.perunNamespaces map, which is always initialized as null.\n-\t * If null, it tries to load the configuration into this map from a perun-namespaces.properties file.\n-\t * If the file does not exist, it creates an empty HashMap, so it's not null anymore.\n-\t */\n-\tprotected void checkPerunNamespacesMap() {\n-\t\tif (perunNamespaces == null) {\n-\t\t\ttry {\n-\t\t\t\tperunNamespaces = BeansUtils.getAllPropertiesFromCustomConfiguration(\"perun-namespaces.properties\");\n-\t\t\t} catch (InternalErrorException e) {\n-\t\t\t\tperunNamespaces = new HashMap<>();\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic Map<String, Pair<BigDecimal, BigDecimal>> checkAndTransferQuotas(Attribute quotasAttribute, PerunBean firstPlaceholder, PerunBean secondPlaceholder, boolean withMetrics) throws InternalErrorException, WrongAttributeValueException {\n-\t\t//firstPlaceholder can't be null\n-\t\tif(firstPlaceholder == null) throw new InternalErrorException(\"Missing first mandatory placeHolder (PerunBean).\");\n-\t\t//Quotas attribute must exists with not null value\n-\t\tif(quotasAttribute == null || quotasAttribute.getValue() == null) throw new InternalErrorException(\"Attribute quotas for checking and transfering can't be null.\");\n-\n-\t\t//Prepare result container and value of attribute\n-\t\tMap<String, Pair<BigDecimal, BigDecimal>> transferedQuotas = new HashMap<>();\n-\t\tMap<String, String> defaultQuotasMap = (Map<String, String>) quotasAttribute.getValue();\n-\n-\t\t//List to test if all paths are unique (/var/log and /var/log/ are the same so these two paths are not unique)\n-\t\tList<String> uniquePaths = new ArrayList<>();\n-\t\tfor(String path: defaultQuotasMap.keySet()) {\n-\t\t\t//null is not correct path for volume on File System\n-\t\t\tif(path == null || path.isEmpty()) throw new WrongAttributeValueException(quotasAttribute, firstPlaceholder, secondPlaceholder, \"The path of some volume where quota should be set is null.\");\n-\n-\t\t\t//testing if path is unique\n-\t\t\tString canonicalPath;\n-\t\t\ttry {\n-\t\t\t\tcanonicalPath = new URI(path).normalize().getPath();\n-\t\t\t\tif(!canonicalPath.endsWith(\"/\")) canonicalPath = canonicalPath.concat(\"/\");\n-\t\t\t} catch (URISyntaxException ex) {\n-\t\t\t\tthrow new WrongAttributeValueException(quotasAttribute, firstPlaceholder, secondPlaceholder, \"Path '\" + path + \"' is not correct form.\");\n-\t\t\t}\n-\n-\t\t\tif(uniquePaths.contains(canonicalPath)) throw new WrongAttributeValueException(quotasAttribute, firstPlaceholder, secondPlaceholder, \"Paths are not unique, there are two same paths: \" + path);\n-\t\t\telse uniquePaths.add(canonicalPath);\n-\n-\t\t\tString quota = defaultQuotasMap.get(path);\n-\t\t\t//quota can't be null, if exists in attribute, must be set in some way\n-\t\t\tif(quota == null) throw new WrongAttributeValueException(quotasAttribute, firstPlaceholder, secondPlaceholder, \"The quota of some volume where quota should be set is null.\");\n-\n-\t\t\t//check format of quota parameter (for data with metrics, for count of files without metrics)\n-\t\t\tMatcher quotaMatcher;\n-\t\t\tif(withMetrics) {\n-\t\t\t\tquotaMatcher = ModulesUtilsBlImpl.quotaWithMetricsPattern.matcher(quota);\n-\t\t\t\tif(!quotaMatcher.matches()) throw new WrongAttributeValueException(quotasAttribute, firstPlaceholder, secondPlaceholder, \"Format of quota in quotas attribute is not correct.\");\n-\t\t\t} else {\n-\t\t\t\tquotaMatcher = ModulesUtilsBlImpl.quotaWithoutMetricsPattern.matcher(quota);\n-\t\t\t\tif(!quotaMatcher.matches()) throw new WrongAttributeValueException(quotasAttribute, firstPlaceholder, secondPlaceholder, \"Format of quota in quotas attribute is not correct.\");\n-\t\t\t}\n-\n-\t\t\t//Parse quotas to variables\n-\t\t\tString softQuota = quotaMatcher.group(1);\n-\t\t\tString hardQuota = quotaMatcher.group(3);\n-\n-\t\t\t//Parse number pattern and letter pattern from whole quotas\n-\n-\t\t\t//SoftQuotaNumber\n-\t\t\tBigDecimal softQuotaAfterTransfer;\n-\t\t\tBigDecimal hardQuotaAfterTransfer;\n-\t\t\t//special behavior with metrics\n-\t\t\tif(withMetrics) {\n-\t\t\t\tString softQuotaNumber = null;\n-\t\t\t\tMatcher numberMatcher = numberPattern.matcher(softQuota);\n-\t\t\t\tif(!numberMatcher.find()) throw new ConsistencyErrorException(\"Matcher can't find number in softQuota '\" + softQuota + \"' in attribute \" + quotasAttribute);\n-\t\t\t\tsoftQuotaNumber = numberMatcher.group();\n-\n-\t\t\t\t//SoftQuotaLetter\n-\t\t\t\tString softQuotaLetter = null;\n-\t\t\t\tMatcher letterMatcher = letterPattern.matcher(softQuota);\n-\t\t\t\t//in this case no letter means default and default is G\n-\t\t\t\tif(!letterMatcher.find()) softQuotaLetter = \"G\";\n-\t\t\t\telse softQuotaLetter = letterMatcher.group();\n-\n-\t\t\t\t//HardQuotaNumber\n-\t\t\t\tString hardQuotaNumber = null;\n-\t\t\t\tnumberMatcher = numberPattern.matcher(hardQuota);\n-\t\t\t\tif(!numberMatcher.find()) throw new ConsistencyErrorException(\"Matcher can't find number in hardQuota '\" + hardQuota + \"' in attribute \" + quotasAttribute);\n-\t\t\t\thardQuotaNumber = numberMatcher.group();\n-\n-\t\t\t\t//HardQuotaLetter\n-\t\t\t\tString hardQuotaLetter;\n-\t\t\t\tletterMatcher = letterPattern.matcher(hardQuota);\n-\t\t\t\t//in this case no letter means default and default is G\n-\t\t\t\tif(!letterMatcher.find()) hardQuotaLetter = \"G\";\n-\t\t\t\telse hardQuotaLetter = letterMatcher.group();\n-\n-\t\t\t\t//Prepare whole big decimal numbers\n-\t\t\t\tsoftQuotaAfterTransfer = new BigDecimal(softQuotaNumber);\n-\t\t\t\thardQuotaAfterTransfer = new BigDecimal(hardQuotaNumber);\n-\n-\t\t\t\t//multiplying for softQuota\n-\t\t\t\tswitch (softQuotaLetter) {\n-\t\t\t\t\tcase \"K\":\n-\t\t\t\t\t\tbreak; //K is basic metric, no need to multiply it\n-\t\t\t\t\tcase \"G\":\n-\t\t\t\t\t\tsoftQuotaAfterTransfer = softQuotaAfterTransfer.multiply(BigDecimal.valueOf(G));\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\tcase \"M\":\n-\t\t\t\t\t\tsoftQuotaAfterTransfer = softQuotaAfterTransfer.multiply(BigDecimal.valueOf(M));\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\tcase \"T\":\n-\t\t\t\t\t\tsoftQuotaAfterTransfer = softQuotaAfterTransfer.multiply(BigDecimal.valueOf(T));\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\tcase \"P\":\n-\t\t\t\t\t\tsoftQuotaAfterTransfer = softQuotaAfterTransfer.multiply(BigDecimal.valueOf(P));\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\tcase \"E\":\n-\t\t\t\t\t\tsoftQuotaAfterTransfer = softQuotaAfterTransfer.multiply(BigDecimal.valueOf(E));\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\tdefault:\n-\t\t\t\t\t\tthrow new ConsistencyErrorException(\"There is not allowed character in soft quota letter '\" + softQuotaLetter + \"'.\");\n-\t\t\t\t}\n-\n-\t\t\t\t//multiplying for softQuota\n-\t\t\t\tswitch (hardQuotaLetter) {\n-\t\t\t\t\tcase \"K\":\n-\t\t\t\t\t\tbreak; //K is basic metric, no need to multiply it\n-\t\t\t\t\tcase \"G\":\n-\t\t\t\t\t\thardQuotaAfterTransfer = hardQuotaAfterTransfer.multiply(BigDecimal.valueOf(G));\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\tcase \"M\":\n-\t\t\t\t\t\thardQuotaAfterTransfer = hardQuotaAfterTransfer.multiply(BigDecimal.valueOf(M));\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\tcase \"T\":\n-\t\t\t\t\t\thardQuotaAfterTransfer = hardQuotaAfterTransfer.multiply(BigDecimal.valueOf(T));\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\tcase \"P\":\n-\t\t\t\t\t\thardQuotaAfterTransfer = hardQuotaAfterTransfer.multiply(BigDecimal.valueOf(P));\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\tcase \"E\":\n-\t\t\t\t\t\thardQuotaAfterTransfer = hardQuotaAfterTransfer.multiply(BigDecimal.valueOf(E));\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\tdefault:\n-\t\t\t\t\t\tthrow new ConsistencyErrorException(\"There is not allowed character in hard quota letter '\" + hardQuotaLetter + \"'.\");\n-\t\t\t\t}\n-\t\t\t//easy way without metrics\n-\t\t\t} else {\n-\t\t\t\tsoftQuotaAfterTransfer = new BigDecimal(softQuota);\n-\t\t\t\thardQuotaAfterTransfer = new BigDecimal(hardQuota);\n-\t\t\t}\n-\n-\t\t\t//test comparing softQuota and hardQuota (softQuota must be less or equals than hardQuota, 0 means unlimited)\n-\t\t\t//1] if softQuota is unlimited, but hardQuota not = exception\n-\t\t\tif(softQuotaAfterTransfer.compareTo(BigDecimal.valueOf(0)) == 0 && hardQuotaAfterTransfer.compareTo(BigDecimal.valueOf(0)) != 0) {\n-\t\t\t\tthrow new WrongAttributeValueException(quotasAttribute, firstPlaceholder, secondPlaceholder, \"SoftQuota is set to unlimited (0) but hardQuota is limited to '\" + hardQuota + \"'.\");\n-\t\t\t//2] if hardQuota is not unlimited but still it is less then softQuota = exception\n-\t\t\t} else if(hardQuotaAfterTransfer.compareTo(BigDecimal.valueOf(0)) != 0 && hardQuotaAfterTransfer.compareTo(softQuotaAfterTransfer) < 0) {\n-\t\t\t\tthrow new WrongAttributeValueException(quotasAttribute, firstPlaceholder, secondPlaceholder, \"One of quotas is not correct. HardQuota '\" + hardQuota + \"' is less then softQuota '\" + softQuota + \"'.\");\n-\t\t\t}\n-\t\t\t//other cases are ok\n-\n-\t\t\ttransferedQuotas.put(canonicalPath, new Pair(softQuotaAfterTransfer, hardQuotaAfterTransfer));\n-\t\t}\n-\n-\t\treturn transferedQuotas;\n-\t}\n-\n-\t@Override\n-\tpublic Map<String, String> transferQuotasBackToAttributeValue(Map<String, Pair<BigDecimal, BigDecimal>> transferedQuotasMap, boolean withMetrics) throws InternalErrorException {\n-\t\tMap<String, String> attributeQuotasValue = new HashMap<>();\n-\t\t//if null or empty, return empty attribute value map for quotas\n-\t\tif(transferedQuotasMap == null || transferedQuotasMap.isEmpty()) return attributeQuotasValue;\n-\n-\t\t//every path with quotas transfer step by step\n-\t\tfor(String path: transferedQuotasMap.keySet()) {\n-\t\t\tPair<BigDecimal, BigDecimal> quotas =  transferedQuotasMap.get(path);\n-\t\t\tBigDecimal softQuotaBD = quotas.getLeft();\n-\t\t\tBigDecimal hardQuotaBD = quotas.getRight();\n-\n-\t\t\t//Divide decimal till it is still natural number\n-\t\t\t//Soft Quota\n-\t\t\tString softQuota = \"0\";\n-\t\t\t//Zero means unlimited, stay the same\n-\t\t\tif(softQuotaBD.compareTo(BigDecimal.ZERO) != 0) {\n-\t\t\t\tif(withMetrics) softQuota = Utils.bigDecimalBytesToReadableStringWithMetric(softQuotaBD);\n-\t\t\t\telse softQuota = softQuotaBD.toPlainString();\n-\t\t\t}\n-\t\t\t//Hard Quota\n-\t\t\tString hardQuota = \"0\";\n-\t\t\t//Zero means unlimited, stay the same\n-\t\t\tif(hardQuotaBD.compareTo(BigDecimal.ZERO) != 0) {\n-\t\t\t\tif(withMetrics) hardQuota = Utils.bigDecimalBytesToReadableStringWithMetric(hardQuotaBD);\n-\t\t\t\telse hardQuota = hardQuotaBD.toPlainString();\n-\t\t\t}\n-\n-\t\t\t//add softQuota and hardQuota to result (50T:60T)\n-\t\t\tattributeQuotasValue.put(path, softQuota + \":\" + hardQuota);\n-\t\t}\n-\t\treturn attributeQuotasValue;\n-\t}\n-\n-\t@Override\n-\tpublic Map<String,Pair<BigDecimal, BigDecimal>> mergeMemberAndResourceTransferedQuotas(Map<String, Pair<BigDecimal, BigDecimal>> firstQuotas, Map<String, Pair<BigDecimal, BigDecimal>> secondQuotas) {\n-\t\t//if one of them is empty, return the other one (even if it is empty too)\n-\t\tif(firstQuotas.isEmpty()) return secondQuotas;\n-\t\tif(secondQuotas.isEmpty()) return firstQuotas;\n-\n-\t\tMap<String,Pair<BigDecimal, BigDecimal>> mergedTransferedQuotas = new HashMap<>();\n-\t\t//first go through firstQuotas values\n-\t\tfor(String path: firstQuotas.keySet()) {\n-\t\t\tPair<BigDecimal, BigDecimal> newValue;\n-\t\t\tPair<BigDecimal, BigDecimal> firstQuotasValue = firstQuotas.get(path);\n-\t\t\tPair<BigDecimal, BigDecimal> secondQuotasValue = secondQuotas.get(path);\n-\n-\t\t\t//if there is no values for merge, use them\n-\t\t\tif(secondQuotasValue == null) {\n-\t\t\t\tnewValue = firstQuotasValue;\n-\t\t\t\tmergedTransferedQuotas.put(path, newValue);\n-\t\t\t//if there are values to merge, merge them\n-\t\t\t} else {\n-\t\t\t\tBigDecimal softQuota;\n-\t\t\t\tBigDecimal hardQuota;\n-\t\t\t\t//merge softQuota\n-\t\t\t\tif(firstQuotasValue.getLeft().compareTo(new BigDecimal(\"0\")) == 0 || secondQuotasValue.getLeft().compareTo(new BigDecimal(\"0\")) == 0) softQuota = new BigDecimal(\"0\");\n-\t\t\t\telse {\n-\t\t\t\t\tif(firstQuotasValue.getLeft().compareTo(secondQuotasValue.getLeft()) >= 0) softQuota = firstQuotasValue.getLeft();\n-\t\t\t\t\telse softQuota = secondQuotasValue.getLeft();\n-\t\t\t\t}\n-\t\t\t\t//merge hardQuota\n-\t\t\t\tif(firstQuotasValue.getRight().compareTo(new BigDecimal(\"0\")) == 0 || secondQuotasValue.getRight().compareTo(new BigDecimal(\"0\")) == 0) hardQuota = new BigDecimal(\"0\");\n-\t\t\t\telse {\n-\t\t\t\t\tif(firstQuotasValue.getRight().compareTo(secondQuotasValue.getRight()) >= 0) hardQuota = firstQuotasValue.getRight();\n-\t\t\t\t\telse hardQuota = secondQuotasValue.getRight();\n-\t\t\t\t}\n-\t\t\t\t//set new merged values\n-\t\t\t\tnewValue = new Pair(softQuota, hardQuota);\n-\t\t\t\tmergedTransferedQuotas.put(path, newValue);\n-\t\t\t\t//remove them from second quotas (they are not unique)\n-\t\t\t\tsecondQuotas.remove(path);\n-\t\t\t}\n-\t\t}\n-\t\t//save rest of values from secondQuotas (only unique in second quotas are still there, not exists in first quotas)\n-\t\tfor(String path: secondQuotas.keySet()) {\n-\t\t\tmergedTransferedQuotas.put(path, secondQuotas.get(path));\n-\t\t}\n-\n-\t\treturn mergedTransferedQuotas;\n-\t}\n-\n-\tpublic Map<String, Pair<BigDecimal, BigDecimal>> countUserFacilityQuotas(List<Map<String, Pair<BigDecimal, BigDecimal>>> allUserQuotas) {\n-\t\tMap<String, Pair<BigDecimal, BigDecimal>> resultTransferredQuotas = new HashMap<>();\n-\t\t//for every transfered map of merged quotas count one result transfered map\n-\t\tfor(Map<String, Pair<BigDecimal, BigDecimal>> mapValue : allUserQuotas) {\n-\t\t\t//for every path in one transfered map\n-\t\t\tfor(String pathKey: mapValue.keySet()) {\n-\t\t\t\t//if path not exists in result map, add it with it's values\n-\t\t\t\tif(!resultTransferredQuotas.containsKey(pathKey)) {\n-\t\t\t\t\tresultTransferredQuotas.put(pathKey, mapValue.get(pathKey));\n-\t\t\t\t//if path already exists in result map, sum their quotas together\n-\t\t\t\t} else {\n-\t\t\t\t\tPair<BigDecimal, BigDecimal> quotasValue1 = resultTransferredQuotas.get(pathKey);\n-\t\t\t\t\tPair<BigDecimal, BigDecimal> quotasValue2 = mapValue.get(pathKey);\n-\t\t\t\t\t//for soft quota (left part of pair)\n-\t\t\t\t\tBigDecimal softQuota = BigDecimal.ZERO;\n-\t\t\t\t\tif(quotasValue1.getLeft().compareTo(BigDecimal.ZERO) != 0 && quotasValue2.getLeft().compareTo(BigDecimal.ZERO) != 0) {\n-\t\t\t\t\t\tsoftQuota = quotasValue1.getLeft().add(quotasValue2.getLeft());\n-\t\t\t\t\t}\n-\t\t\t\t\t//for hard quota (right part of pair)\n-\t\t\t\t\tBigDecimal hardQuota = BigDecimal.ZERO;\n-\t\t\t\t\tif(quotasValue1.getRight().compareTo(BigDecimal.ZERO) != 0 && quotasValue2.getRight().compareTo(BigDecimal.ZERO) != 0) {\n-\t\t\t\t\t\thardQuota = quotasValue1.getRight().add(quotasValue2.getRight());\n-\t\t\t\t\t}\n-\t\t\t\t\t//create new pair of summed numbers\n-\t\t\t\t\tPair<BigDecimal, BigDecimal> finalQuotasValue = new Pair(softQuota, hardQuota);\n-\t\t\t\t\t//add new summed pair to the result map\n-\t\t\t\t\tresultTransferredQuotas.put(pathKey, finalQuotasValue);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\t//return result map\n-\t\treturn resultTransferredQuotas;\n-\t}\n-\n-\t/**\n-\t * Get list of login-namespaces which have logins generated by Perun\n-\t *\n-\t * @return List of login-namespaces with generated logins\n-\t */\n-\tpublic static List<String> getGeneratedLoginNamespaces() {\n-\n-\t\t// load namespaces to generate login for\n-\t\tList<String> namespaces;\n-\t\ttry {\n-\t\t\tString nmspc = BeansUtils.getPropertyFromConfiguration(\"perun.loginNamespace.generated\");\n-\t\t\tnamespaces = new ArrayList<String>(Arrays.asList(nmspc.split(\",\")));\n-\t\t\tIterator<String> nameIter = namespaces.listIterator();\n-\t\t\t// trim and remove empty namespaces\n-\t\t\twhile (nameIter.hasNext()) {\n-\t\t\t\tString namespace = nameIter.next();\n-\t\t\t\tnamespace = namespace.trim();\n-\t\t\t\tif (namespace.isEmpty()) nameIter.remove();\n-\t\t\t}\n-\t\t} catch (InternalErrorException ex) {\n-\t\t\t// without value\n-\t\t\treturn new ArrayList<String>();\n-\t\t}\n-\n-\t\treturn namespaces;\n-\n-\t}\n-\n-\t/**\n-\t * Normalize string for purpose of generating safe login value.\n-\t *\n-\t * @return normalized string\n-\t */\n-\tpublic static String normalizeStringForLogin(String toBeNormalized) {\n-\n-\t\tif (toBeNormalized == null || toBeNormalized.trim().isEmpty()) return null;\n-\n-\t\ttoBeNormalized = toBeNormalized.toLowerCase();\n-\t\ttoBeNormalized = java.text.Normalizer.normalize(toBeNormalized, java.text.Normalizer.Form.NFD).replaceAll(\"\\\\p{InCombiningDiacriticalMarks}+\",\"\");\n-\t\ttoBeNormalized = toBeNormalized.replaceAll(\"[^a-zA-Z]+\", \"\");\n-\n-\t\t// unable to fill login for users without name or with partial name\n-\t\tif (toBeNormalized == null || toBeNormalized.isEmpty()) {\n-\t\t\treturn null;\n-\t\t}\n-\n-\t\treturn toBeNormalized;\n-\n-\t}\n-\n-\t/**\n-\t * Shared logic for purpose of login generation\n-\t */\n-\tpublic static class LoginGenerator {\n-\n-\t\t/**\n-\t\t * Define joining function for anonymous classes\n-\t\t */\n-\t\tpublic interface LoginGeneratorFunction {\n-\n-\t\t\t/**\n-\t\t\t * Generate login for user using his name\n-\t\t\t * @param firstName\n-\t\t\t * @param lastName\n-\t\t\t * @return generated login\n-\t\t\t */\n-\t\t\tpublic String generateLogin(String firstName, String lastName);\n-\n-\t\t}\n-\n-\t\t/**\n-\t\t * Generate login for user using his name and joining function\n-\t\t *\n-\t\t * @param user User to get data from\n-\t\t * @param function Function to join fist/lastName to login\n-\t\t * @return generated login\n-\t\t */\n-\t\tpublic String generateLogin(User user, LoginGeneratorFunction function) {\n-\n-\t\t\tString firstName = user.getFirstName();\n-\t\t\tString lastName = user.getLastName();\n-\n-\t\t\t// get only first part of first name and remove spec. chars\n-\t\t\tif (firstName != null && !firstName.isEmpty()) {\n-\t\t\t\tfirstName = ModulesUtilsBlImpl.normalizeStringForLogin(firstName.split(\" \")[0]);\n-\t\t\t}\n-\n-\t\t\t// get only last part of last name and remove spec. chars\n-\t\t\tif (lastName != null && !lastName.isEmpty()) {\n-\t\t\t\tList<String> names = Arrays.asList(lastName.split(\" \"));\n-\t\t\t\tlastName = names.get(names.size() - 1);\n-\t\t\t\tlastName = ModulesUtilsBlImpl.normalizeStringForLogin(lastName.split(\" \")[0]);\n-\t\t\t}\n-\n-\t\t\t// unable to fill login for users without name or with partial name\n-\t\t\tif (firstName == null || firstName.isEmpty() || lastName == null || lastName.isEmpty()) {\n-\t\t\t\treturn null;\n-\t\t\t}\n-\n-\t\t\treturn function.generateLogin(firstName, lastName);\n-\n-\t\t}\n-\n-\t}\n-\n-\tpublic PerunBl getPerunBl() {\n-\t\treturn this.perunBl;\n-\t}\n-\n-\tpublic void setPerunBl(PerunBl perunBl) {\n-\t\tthis.perunBl = perunBl;\n-\t}\n-}\n+ final static Logger log = LoggerFactory.getLogger(ServicesManagerBlImpl.class);\n+ private PerunBl perunBl;\n+ Map<String, String> perunNamespaces = null;\n+\n+ public static final String A_E_namespace_minGID = AttributesManager.NS_ENTITYLESS_ATTR_DEF + \":namespace-minGID\";\n+\n+ public static final String A_E_namespace_maxGID = AttributesManager.NS_ENTITYLESS_ATTR_DEF + \":namespace-maxGID\";\n+\n+ public static final String A_G_unixGID_namespace = AttributesManager.NS_GROUP_ATTR_DEF + \":unixGID-namespace\";\n+\n+ public static final String A_G_unixGroupName_namespace = AttributesManager.NS_GROUP_ATTR_DEF + \":unixGroupName-namespace\";\n+\n+ public static final String A_R_unixGID_namespace = AttributesManager.NS_RESOURCE_ATTR_DEF + \":unixGID-namespace\";\n+\n+ public static final String A_R_unixGroupName_namespace = AttributesManager.NS_RESOURCE_ATTR_DEF + \":unixGroupName-namespace\";\n+\n+ public static final String A_F_unixGID_namespace = AttributesManager.NS_FACILITY_ATTR_DEF + \":unixGID-namespace\";\n+\n+ public static final String A_F_unixGroupName_namespace = AttributesManager.NS_FACILITY_ATTR_DEF + \":unixGroupName-namespace\";\n+\n+ public static final String A_F_googleGroupName_namespace = AttributesManager.NS_FACILITY_ATTR_DEF + \":googleGroupNameNamespace\";\n+ private static final String A_E_usedGids = AttributesManager.NS_ENTITYLESS_ATTR_DEF + \":usedGids\";\n+\n+ //Often used patterns\n+\n+ public static final Pattern quotaWithMetricsPattern = Pattern.compile(\"^([0-9]+([.][0-9]+)?[KMGTPE]?):([0-9]+([.][0-9]+)?[KMGTPE]?)$\");\n+\n+ public static final Pattern quotaWithoutMetricsPattern = Pattern.compile(\"^([0-9]+)(:)([0-9]+)$\");\n+\n+ public static final Pattern numberPattern = Pattern.compile(\"[0-9]+([.][0-9]+)?\");\n+\n+ public static final Pattern letterPattern = Pattern.compile(\"[A-Z]\");\n+\n+ public final static List<String> reservedNamesForUnixGroups = Arrays.asList(\"root\",\n+                                                                             \"daemon\",\n+                                                                             \"tty\",\n+                                                                             \"bin\",\n+                                                                             \"sys\",\n+                                                                             \"sudo\",\n+                                                                             \"nogroup\",\n+                                                                             \"hadoop\",\n+                                                                             \"hdfs\",\n+                                                                             \"mapred\",\n+                                                                             \"yarn\",\n+                                                                             \"hsqldb\",\n+                                                                             \"derby\",\n+                                                                             \"jetty\",\n+                                                                             \"hbase\",\n+                                                                             \"zookeeper\",\n+                                                                             \"users\"\n+                                  );\n+\n+ public final static List<String> unpermittedNamesForUserLogins = Arrays.asList(\"arraysvcs\", \"at\", \"backup\", \"bin\", \"daemon\", \"Debian-exim\", \"flexlm\", \"ftp\", \"games\", \"gdm\", \"glite\", \"gnats\", \"haldaemon\", \"identd\", \"irc\", \"libuuid\", \"list\", \"lp\", \"mail\", \"man\", \"messagebus\", \"news\", \"nobody\", \"ntp\", \"openslp\", \"pcp\", \"polkituser\", \"postfix\", \"proxy\", \"pulse\", \"puppet\", \"root\", \"saned\", \"smmsp\", \"smmta\", \"sshd\", \"statd\", \"suse-ncc\", \"sync\", \"sys\", \"uucp\", \"uuidd\", \"www-data\", \"wwwrun\", \"zenssh\", \"tomcat6\", \"tomcat7\", \"tomcat8\", \"nn\", \"dn\", \"rm\", \"nm\", \"sn\", \"jn\", \"jhs\", \"http\", \"yarn\", \"hdfs\", \"mapred\", \"hadoop\", \"hsqldb\", \"derby\", \"jetty\", \"hbase\", \"zookeeper\", \"hive\", \"hue\");\n+\n+ //Definition of K = KB, M = MB etc.\n+\n+ public static final long M = 1024;\n+\n+ public static final long G = M * 1024;\n+\n+ public static final long T = G * 1024;\n+\n+ public static final long P = T * 1024;\n+\n+ public static final long E = P * 1024;\n+\n+\n+ public ModulesUtilsBlImpl() {}\n+\n+\n+ public boolean isNamespaceEqualsToFacilityUnixGroupNameNamespace(PerunSessionImpl sess, Facility facility, String namespace) throws InternalErrorException, AttributeNotExistsException, WrongAttributeAssignmentException {\n+  Utils.notNull(facility, \"facility\");\n+  Utils.notNull(namespace, \"namespace\");\n+  Utils.notNull(sess, \"perunSessionImpl\");\n+  Attribute facilityNamespaceAttr = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, facility, A_F_unixGroupName_namespace + \":\" + namespace);\n+  if (facilityNamespaceAttr.getValue() == null)\n+   return false;\n+  if (!namespace.equals(facilityNamespaceAttr.getValue())) {\n+   return false;\n+  }\n+\n+  return true;\n+ }\n+\n+ public List<Resource> findCollisionResourcesWithSameGroupName(PerunSessionImpl sess, Resource resource, String namespace) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException {\n+  Utils.notNull(sess, \"perunSessionImpl\");\n+  Utils.notNull(resource, \"resource\");\n+  Attribute resourceUnixGroupName = getPerunBl().getAttributesManagerBl().getAttribute(sess, resource, A_R_unixGroupName_namespace + \":\" + namespace);\n+  List<Resource> resourcesWithSameUnixGroupName = getPerunBl().getResourcesManagerBl().getResourcesByAttribute(sess, resourceUnixGroupName);\n+  resourcesWithSameUnixGroupName.remove(resource);\n+  return resourcesWithSameUnixGroupName;\n+ }\n+\n+ public List<Resource> findCollisionResourcesWithSameGroupName(PerunSessionImpl sess, Group group, String namespace) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException {\n+  Utils.notNull(sess, \"perunSessionImpl\");\n+  Utils.notNull(group, \"group\");\n+  Utils.notNull(namespace, \"namespace\");\n+  Attribute groupUnixGroupName = getPerunBl().getAttributesManagerBl().getAttribute(sess, group, A_G_unixGroupName_namespace + \":\" + namespace);\n+  Attribute copyResourceUnixGroupName = new Attribute(getPerunBl().getAttributesManagerBl().getAttributeDefinition(sess, A_R_unixGroupName_namespace + \":\" + namespace));\n+  copyResourceUnixGroupName.setValue(groupUnixGroupName.getValue());\n+  return getPerunBl().getResourcesManagerBl().getResourcesByAttribute(sess, copyResourceUnixGroupName);\n+ }\n+\n+ public List<Group> findCollisionGroupsWithSamgeGroupName(PerunSessionImpl sess, Resource resource, String namespace) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException {\n+  Utils.notNull(sess, \"perunSessionImpl\");\n+  Utils.notNull(resource, \"resource\");\n+  Utils.notNull(namespace, \"namespace\");\n+  Attribute resourceUnixGroupName = getPerunBl().getAttributesManagerBl().getAttribute(sess, resource, A_R_unixGroupName_namespace + \":\" + namespace);\n+  Attribute copyGroupUnixGroupName = new Attribute(getPerunBl().getAttributesManagerBl().getAttributeDefinition(sess, A_G_unixGroupName_namespace + \":\" + namespace));\n+  copyGroupUnixGroupName.setValue(resourceUnixGroupName.getValue());\n+  return getPerunBl().getGroupsManagerBl().getGroupsByAttribute(sess, copyGroupUnixGroupName);\n+ }\n+\n+ public List<Group> findCollisionGroupsWithSamgeGroupName(PerunSessionImpl sess, Group group, String namespace) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException {\n+  Utils.notNull(sess, \"perunSessionImpl\");\n+  Utils.notNull(group, \"group\");\n+  Utils.notNull(namespace, \"namespace\");\n+  Attribute groupUnixGroupName = getPerunBl().getAttributesManagerBl().getAttribute(sess, group, A_G_unixGroupName_namespace + \":\" + namespace);\n+  List<Group> groupsWithsameGroupName = getPerunBl().getGroupsManagerBl().getGroupsByAttribute(sess, groupUnixGroupName);\n+  groupsWithsameGroupName.remove(group);\n+  return groupsWithsameGroupName;\n+ }\n+\n+ public List<Resource> findCollisionResourcesWithSameGid(PerunSessionImpl sess, Resource resource, String namespace) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException {\n+  Utils.notNull(sess, \"perunSessionImpl\");\n+  Utils.notNull(resource, \"resource\");\n+  Utils.notNull(namespace, \"namespace\");\n+  Attribute resourceUnixGid = getPerunBl().getAttributesManagerBl().getAttribute(sess, resource, A_R_unixGID_namespace + \":\" + namespace);\n+  List<Resource> resourcesWithSameGid = getPerunBl().getResourcesManagerBl().getResourcesByAttribute(sess, resourceUnixGid);\n+  resourcesWithSameGid.remove(resource);\n+  return resourcesWithSameGid;\n+ }\n+\n+ public List<Resource> findCollisionResourcesWithSameGid(PerunSessionImpl sess, Group group, String namespace) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException {\n+  Utils.notNull(sess, \"perunSessionImpl\");\n+  Utils.notNull(group, \"group\");\n+  Utils.notNull(namespace, \"namespace\");\n+  Attribute groupUnixGid = getPerunBl().getAttributesManagerBl().getAttribute(sess, group, A_G_unixGID_namespace + \":\" + namespace);\n+  Attribute copyResourceUnixGid = new Attribute(getPerunBl().getAttributesManagerBl().getAttributeDefinition(sess, A_R_unixGID_namespace + \":\" + namespace));\n+  copyResourceUnixGid.setValue(groupUnixGid.getValue());\n+  return getPerunBl().getResourcesManagerBl().getResourcesByAttribute(sess, copyResourceUnixGid);\n+ }\n+\n+ public List<Group> findCollisionGroupsWithSamgeGroupGid(PerunSessionImpl sess, Resource resource, String namespace) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException {\n+  Utils.notNull(sess, \"perunSessionImpl\");\n+  Utils.notNull(resource, \"resource\");\n+  Utils.notNull(namespace, \"namespace\");\n+  Attribute resourceUnixGid = getPerunBl().getAttributesManagerBl().getAttribute(sess, resource, A_R_unixGID_namespace + \":\" + namespace);\n+  Attribute copyGroupUnixGid = new Attribute(getPerunBl().getAttributesManagerBl().getAttributeDefinition(sess, A_G_unixGID_namespace + \":\" + namespace));\n+  copyGroupUnixGid.setValue(resourceUnixGid.getValue());\n+  return getPerunBl().getGroupsManagerBl().getGroupsByAttribute(sess, copyGroupUnixGid);\n+ }\n+\n+ public List<Group> findCollisionGroupsWithSamgeGroupGid(PerunSessionImpl sess, Group group, String namespace) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException {\n+  Utils.notNull(sess, \"perunSessionImpl\");\n+  Utils.notNull(group, \"group\");\n+  Utils.notNull(namespace, \"namespace\");\n+  Attribute groupUnixGid = getPerunBl().getAttributesManagerBl().getAttribute(sess, group, A_G_unixGID_namespace + \":\" + namespace);\n+  List<Group> groupsWithSameUnixGid = getPerunBl().getGroupsManagerBl().getGroupsByAttribute(sess, groupUnixGid);\n+  groupsWithSameUnixGid.remove(group);\n+  return groupsWithSameUnixGid;\n+ }\n+\n+ public boolean hasAccessToWriteToAttributeForAnyResource(PerunSessionImpl sess, AttributeDefinition attrDef, List<Resource> resources) throws InternalErrorException {\n+  Utils.notNull(sess, \"perunSessionImpl\");\n+  Utils.notNull(attrDef, \"attributeDefinition\");\n+  if (resources == null || resources.isEmpty())\n+   return false;\n+  for (Resource r : resources) {\n+   if (AuthzResolver.isAuthorizedForAttribute(sess, ActionType.WRITE, attrDef, r, null))\n+    return true;\n+  }\n+\n+  return false;\n+ }\n+\n+ public boolean hasAccessToWriteToAttributeForAnyGroup(PerunSessionImpl sess, AttributeDefinition attrDef, List<Group> groups) throws InternalErrorException {\n+  Utils.notNull(sess, \"perunSessionImpl\");\n+  Utils.notNull(attrDef, \"attributeDefinition\");\n+  if (groups == null || groups.isEmpty())\n+   return false;\n+  for (Group g : groups) {\n+   if (AuthzResolver.isAuthorizedForAttribute(sess, ActionType.WRITE, attrDef, g, null))\n+    return true;\n+  }\n+\n+  return false;\n+ }\n+\n+ public Pair<Integer, Integer> getMinAndMaxGidForNamespace(PerunSessionImpl sess, String namespace) throws InternalErrorException, AttributeNotExistsException, WrongAttributeAssignmentException {\n+  Utils.notNull(sess, \"perunSessionImpl\");\n+  Utils.notNull(namespace, \"namespace\");\n+  Attribute minGidAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, namespace, A_E_namespace_minGID);\n+  Integer minGid = null;\n+  if (minGidAttribute.getValue() != null) minGid = (Integer) minGidAttribute.getValue();\n+  Attribute maxGidAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, namespace, A_E_namespace_maxGID);\n+  Integer maxGid = null;\n+  if (maxGidAttribute.getValue() != null) maxGid = (Integer) maxGidAttribute.getValue();\n+  return new Pair(minGid, maxGid);\n+ }\n+\n+ public Integer getFirstFreeGidForResourceOrGroup(PerunSessionImpl sess, String namespace) throws InternalErrorException, AttributeNotExistsException, WrongAttributeAssignmentException {\n+  Utils.notNull(sess, \"perunSessionImpl\");\n+  Utils.notNull(namespace, \"namespace\");\n+  Pair<Integer, Integer> minAndMaxGid = this.getMinAndMaxGidForNamespace(sess, namespace);\n+\n+  //If there is no min or max gid, return null instead of number, its same like no free gid was able\n+  if (minAndMaxGid == null || minAndMaxGid.getLeft() == null || minAndMaxGid.getRight() == null)\n+   return null;\n+  AttributeDefinition resourceUnixGid = getPerunBl().getAttributesManagerBl().getAttributeDefinition(sess, A_R_unixGID_namespace + \":\" + namespace);\n+  List<Object> allGids = sess.getPerunBl().getAttributesManagerBl().getAllValues(sess, resourceUnixGid);\n+  AttributeDefinition groupUnixGid = getPerunBl().getAttributesManagerBl().getAttributeDefinition(sess, A_G_unixGID_namespace + \":\" + namespace);\n+  allGids.addAll(sess.getPerunBl().getAttributesManagerBl().getAllValues(sess, groupUnixGid)); //note: it doesn't matter if the group is not active (isUnixGroup attribute != 1)\n+  for (int i = minAndMaxGid.getLeft(); i<minAndMaxGid.getRight(); i++) {\n+   if (!allGids.contains(i)) {\n+    return i;\n+   }\n+  }\n+\n+  return null;\n+ }\n+\n+ public void checkIfGIDIsWithinRange(PerunSessionImpl sess, Attribute attribute) throws InternalErrorException, WrongReferenceAttributeValueException, WrongAttributeAssignmentException, AttributeNotExistsException, WrongAttributeValueException {\n+  Utils.notNull(attribute, \"attribute\");\n+  Integer gid = null;\n+  if (attribute.getValue() != null) gid = (Integer) attribute.getValue();\n+  if (gid == null) throw new WrongAttributeValueException(attribute, \"Gid with null value is not allowed.\");\n+  String gidNamespace = attribute.getFriendlyNameParameter();\n+  Attribute minGidAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, gidNamespace, A_E_namespace_minGID);\n+  if (minGidAttribute.getValue() == null) throw new WrongReferenceAttributeValueException(attribute, minGidAttribute);\n+  Integer minGid = (Integer) minGidAttribute.getValue();\n+  Attribute maxGidAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, gidNamespace, A_E_namespace_maxGID);\n+  if (maxGidAttribute.getValue() == null) throw new WrongReferenceAttributeValueException(attribute, maxGidAttribute);\n+  Integer maxGid = (Integer) maxGidAttribute.getValue();\n+  if (gid<minGid || gid > maxGid) {\n+   throw new WrongAttributeValueException(attribute, \"GID number is not in allowed values min: \" + minGid + \", max:\" + maxGid);\n+  }\n+ }\n+\n+ public void checkIfListOfGIDIsWithinRange(PerunSessionImpl sess, User user, Attribute attribute) throws InternalErrorException, WrongReferenceAttributeValueException, WrongAttributeAssignmentException, AttributeNotExistsException, WrongAttributeValueException {\n+  Utils.notNull(attribute, \"attribute\");\n+  List<String> gIDs = (List<String>) attribute.getValue();\n+  if (gIDs != null) {\n+\n+   for (String sGid : gIDs) {\n+    try {\n+     Integer gid = new Integer(sGid);\n+     String gidNamespace = attribute.getFriendlyNameParameter();\n+     Attribute minGidAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, gidNamespace, A_E_namespace_minGID);\n+     if (minGidAttribute.getValue() == null) throw new WrongReferenceAttributeValueException(attribute, minGidAttribute, \"Attribute minGid cannot be null\");\n+     Integer minGid = (Integer) minGidAttribute.getValue();\n+     Attribute maxGidAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, gidNamespace, A_E_namespace_maxGID);\n+     if (maxGidAttribute.getValue() == null) throw new WrongReferenceAttributeValueException(attribute, maxGidAttribute, \"Attribute maxGid cannot be null\");\n+     Integer maxGid = (Integer) maxGidAttribute.getValue();\n+     if (gid<minGid || gid > maxGid) {\n+      throw new WrongAttributeValueException(attribute, \"GID number is not in allowed values min: \" + minGid + \", max:\" + maxGid);\n+     }\n+    } catch (NumberFormatException ex) {\n+     throw new WrongAttributeValueException(attribute, user, \"attribute is not a number\", ex);\n+    }\n+   }\n+  }\n+ }\n+\n+ public Integer getFreeGID(PerunSessionImpl sess, Attribute attribute) throws InternalErrorException, AttributeNotExistsException, WrongAttributeAssignmentException {\n+  Utils.notNull(attribute, \"attribute\");\n+  String gidNamespace = attribute.getFriendlyNameParameter();\n+  Attribute minGidAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, gidNamespace, A_E_namespace_minGID);\n+  if (minGidAttribute.getValue() == null)\n+   return 0;\n+  Integer minGid = (Integer) minGidAttribute.getValue();\n+  Attribute maxGidAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, gidNamespace, A_E_namespace_maxGID);\n+  if (maxGidAttribute.getValue() == null)\n+   return 0;\n+  Integer maxGid = (Integer) maxGidAttribute.getValue();\n+  List<Integer> allGids = new ArrayList<>();\n+  Attribute usedGids = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, gidNamespace, A_E_usedGids);\n+  if (usedGids.getValue() == null) return minGid;\n+  else {\n+   Map<String, String> usedGidsValue = (Map<String, String>) usedGids.getValue();\n+   Set<String> keys = usedGidsValue.keySet();\n+   for (String key : keys) {\n+    allGids.add(Integer.parseInt(usedGidsValue.get(key)));\n+   }\n+  }\n+\n+  for (int i = minGid; i<maxGid; i++) {\n+   if (!allGids.contains(i)) {\n+    return i;\n+   }\n+  }\n+\n+  return null;\n+ }\n+\n+ public Integer getCommonGIDOfGroupsWithSameNameInSameNamespace(PerunSessionImpl sess, List<Group> groupsWithSameGroupNameInSameNamespace, String gidNamespace, Integer commonGID) throws InternalErrorException, WrongAttributeAssignmentException {\n+  //If there are no groups, return commonGID from param (it can be null)\n+  if (groupsWithSameGroupNameInSameNamespace == null || groupsWithSameGroupNameInSameNamespace.isEmpty())\n+   return commonGID;\n+  Utils.notNull(gidNamespace, \"gidNamespace\");\n+  Group commonGIDGroup = null;  //only for more verbose exception messages\n+  for (Group g : groupsWithSameGroupNameInSameNamespace) {\n+   try {\n+    Attribute attr = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, g, A_G_unixGID_namespace + \":\" + gidNamespace);\n+    if (attr.getValue() != null) {\n+     if (commonGID == null) {\n+      commonGIDGroup = g;\n+      commonGID = (Integer) attr.getValue();\n+     } else {\n+      if (!commonGID.equals((Integer) attr.getValue())) throw new ConsistencyErrorException(\"There are at least 1 groups/resources with same GroupName in same namespace but with different GID in same namespaces. Conflict found: \" + g + \"(gid=\" + attr.getValue() + \") and \" + commonGIDGroup + \"(gid=\" + commonGID + \")\");\n+     }\n+    }\n+   } catch (AttributeNotExistsException ex) {\n+    throw new ConsistencyErrorException(ex);\n+   }\n+  }\n+\n+  return commonGID;\n+ }\n+\n+ public Integer getCommonGIDOfResourcesWithSameNameInSameNamespace(PerunSessionImpl sess, List<Resource> resourcesWithSameGroupNameInSameNamespace, String gidNamespace, Integer commonGID) throws InternalErrorException, WrongAttributeAssignmentException {\n+  //If there are no resources, return commonGID from param (it can be null)\n+  if (resourcesWithSameGroupNameInSameNamespace == null || resourcesWithSameGroupNameInSameNamespace.isEmpty())\n+   return commonGID;\n+  Utils.notNull(gidNamespace, \"gidNamespace\");\n+  Resource commonGIDResource = null;   //only for more verbose exception messages\n+  for (Resource r : resourcesWithSameGroupNameInSameNamespace) {\n+   try {\n+    Attribute attr = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, r, A_R_unixGID_namespace + \":\" + gidNamespace);\n+    if (attr.getValue() != null) {\n+     if (commonGID == null) {\n+      commonGIDResource = r;\n+      commonGID = (Integer) attr.getValue();\n+     } else {\n+      if (!commonGID.equals((Integer) attr.getValue())) throw new ConsistencyErrorException(\"There are at least 1 groups/resources with same GroupName in same namespace but with different GID in same namespaces. Conflict found: \" + r + \"(gid=\" + attr.getValue() + \") and \" + commonGIDResource + \"(gid=\" + commonGID + \")\");\n+     }\n+    }\n+   } catch (AttributeNotExistsException ex) {\n+    throw new ConsistencyErrorException(ex);\n+   }\n+  }\n+\n+  return commonGID;\n+ }\n+\n+ public int haveTheSameAttributeWithTheSameNamespace(PerunSessionImpl sess, Group group, Attribute attr) throws InternalErrorException, WrongAttributeAssignmentException {\n+  Utils.notNull(group, \"group\");\n+  Utils.notNull(attr, \"attr\");\n+  String attributeNamespace = attr.getFriendlyNameParameter();\n+  if (attributeNamespace == null || attributeNamespace.isEmpty()) throw new InternalErrorException(\"Attribute has no namespace, this method can't be use.\");\n+\n+  try {\n+   Attribute testingAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, group, attr.getName());\n+   if (testingAttribute.getValue() == null) return -1;\n+   else {\n+    if (!testingAttribute.getValue().equals(attr.getValue()))\n+     return 1;\n+   }\n+  } catch (AttributeNotExistsException ex) {\n+   throw new ConsistencyErrorException(ex);\n+  }\n+\n+  return 0;\n+ }\n+\n+ public int haveTheSameAttributeWithTheSameNamespace(PerunSessionImpl sess, Resource resource, Attribute attr) throws InternalErrorException, WrongAttributeAssignmentException {\n+  Utils.notNull(resource, \"resource\");\n+  Utils.notNull(attr, \"attr\");\n+  String attributeNamespace = attr.getFriendlyNameParameter();\n+  if (attributeNamespace == null || attributeNamespace.isEmpty()) throw new InternalErrorException(\"Attribute has no namespace, this method can't be use.\");\n+\n+  try {\n+   Attribute testingAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, resource, attr.getName());\n+   if (testingAttribute.getValue() == null) return -1;\n+   else {\n+    if (!testingAttribute.getValue().equals(attr.getValue()))\n+     return 1;\n+   }\n+  } catch (AttributeNotExistsException ex) {\n+   throw new ConsistencyErrorException(ex);\n+  }\n+\n+  return 0;\n+ }\n+\n+ public boolean haveRightToWriteAttributeInAnyGroupOrResource(PerunSessionImpl sess, List<Group> groups, List<Resource> resources, AttributeDefinition groupAttribute, AttributeDefinition resourceAttribute) throws InternalErrorException {\n+  if (groups != null && !groups.isEmpty() && groupAttribute != null) {\n+\n+   for (Group g : groups) {\n+    if (AuthzResolver.isAuthorizedForAttribute(sess, ActionType.WRITE, groupAttribute, g, null))\n+     return true;\n+   }\n+  }\n+  if (resources != null && !resources.isEmpty() && resourceAttribute != null) {\n+\n+   for (Resource r : resources) {\n+    if (AuthzResolver.isAuthorizedForAttribute(sess, ActionType.WRITE, resourceAttribute, r, null))\n+     return true;\n+   }\n+  }\n+\n+  return false;\n+ }\n+\n+ public List<Attribute> getListOfResourceGIDsFromListOfGroupGIDs(PerunSessionImpl sess, List<Attribute> groupGIDs) throws InternalErrorException, AttributeNotExistsException {\n+  List<Attribute> resourceGIDs = new ArrayList<Attribute>();\n+  if (groupGIDs == null || groupGIDs.isEmpty()) {\n+   return resourceGIDs;\n+  }\n+\n+  for (Attribute a : groupGIDs) {\n+   Attribute resourceGID = new Attribute(sess.getPerunBl().getAttributesManagerBl().getAttributeDefinition(sess, A_R_unixGID_namespace + \":\" + a.getFriendlyNameParameter()));\n+   resourceGID.setValue(a.getValue());\n+   resourceGIDs.add(resourceGID);\n+  }\n+\n+  return resourceGIDs;\n+ }\n+\n+ public List<Attribute> getListOfGroupGIDsFromListOfResourceGIDs(PerunSessionImpl sess, List<Attribute> resourceGIDs) throws InternalErrorException, AttributeNotExistsException {\n+  List<Attribute> groupGIDs = new ArrayList<Attribute>();\n+  if (resourceGIDs == null || resourceGIDs.isEmpty()) {\n+   return groupGIDs;\n+  }\n+\n+  for (Attribute a : resourceGIDs) {\n+   Attribute groupGID = new Attribute(sess.getPerunBl().getAttributesManagerBl().getAttributeDefinition(sess, A_G_unixGID_namespace + \":\" + a.getFriendlyNameParameter()));\n+   groupGID.setValue(a.getValue());\n+   groupGIDs.add(groupGID);\n+  }\n+\n+  return groupGIDs;\n+ }\n+\n+ public Set<String> getSetOfGIDNamespacesWhereFacilitiesHasTheSameGroupNameNamespace(PerunSessionImpl sess, List<Facility> facilities, Attribute unixGroupNameNamespace) throws InternalErrorException, WrongAttributeAssignmentException, WrongReferenceAttributeValueException {\n+  Set<String> gidNamespaces = new HashSet<String>();\n+  if (facilities == null || facilities.isEmpty())\n+   return gidNamespaces;\n+  Utils.notNull(facilities, \"facilities\");\n+  for (Facility f : facilities) {\n+   Attribute facilityGroupNameNamespace;\n+   try {\n+    facilityGroupNameNamespace = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, f, A_F_unixGroupName_namespace);\n+    if (facilityGroupNameNamespace.getValue() != null) {\n+     //if they are same, save GID-namespace from this facility to hashSet\n+     if (unixGroupNameNamespace.getFriendlyNameParameter().equals((String) facilityGroupNameNamespace.getValue())) {\n+      Attribute facilityGIDNamespace = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, f, A_F_unixGID_namespace);\n+      //If facilityGIDNamespace exists and is not null, save to the hashSet of gidNamespaces\n+      if (facilityGIDNamespace.getValue() != null) {\n+       gidNamespaces.add((String) facilityGIDNamespace.getValue());\n+      }\n+     }\n+    }\n+   } catch (AttributeNotExistsException ex) {\n+    throw new ConsistencyErrorException(ex);\n+   }\n+  }\n+\n+  return gidNamespaces;\n+ }\n+\n+ public Set<String> getSetOfGroupNameNamespacesWhereFacilitiesHasTheSameGIDNamespace(PerunSessionImpl sess, List<Facility> facilities, Attribute unixGIDNamespace) throws InternalErrorException, WrongAttributeAssignmentException, WrongReferenceAttributeValueException {\n+  Set<String> groupNameNamespaces = new HashSet<String>();\n+  if (facilities == null || facilities.isEmpty())\n+   return groupNameNamespaces;\n+  Utils.notNull(unixGIDNamespace, \"unixGIDNamespace\");\n+  for (Facility f : facilities) {\n+   Attribute facilityGIDNamespace;\n+   try {\n+    facilityGIDNamespace = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, f, A_F_unixGID_namespace);\n+    if (facilityGIDNamespace.getValue() != null) {\n+     //if they are same, save GroupName-namespace from this facility to hashSet\n+     if (unixGIDNamespace.getFriendlyNameParameter().equals((String) facilityGIDNamespace.getValue())) {\n+      Attribute facilityGroupNameNamespace = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, f, A_F_unixGroupName_namespace);\n+      //If facilityGroupNameNamespace exists and is not null, save to the hashSet of gidNamespaces\n+      if (facilityGroupNameNamespace.getValue() != null) {\n+       groupNameNamespaces.add((String) facilityGroupNameNamespace.getValue());\n+      } else {\n+       throw new WrongReferenceAttributeValueException(unixGIDNamespace,\n+facilityGroupNameNamespace,\n+\"Facility has gidNamespace set, but groupNameNamespace not set.\");\n+      }\n+     }\n+    }\n+   } catch (AttributeNotExistsException ex) {\n+    throw new ConsistencyErrorException(ex);\n+   }\n+  }\n+\n+  return groupNameNamespaces;\n+ }\n+\n+ public void checkReservedUnixGroupNames(Attribute groupNameAttribute) throws InternalErrorException, WrongAttributeValueException {\n+  if (groupNameAttribute == null)\n+   return;\n+  checkPerunNamespacesMap();\n+  String reservedNames = perunNamespaces.get(groupNameAttribute.getFriendlyName() + \":reservedNames\");\n+  if (reservedNames != null) {\n+   List<String> reservedNamesList = Arrays.asList(reservedNames.split(\"\\\\s*,\\\\s*\"));\n+   if (reservedNamesList.contains(groupNameAttribute.getValue())) throw new WrongAttributeValueException(groupNameAttribute, \"This groupName is reserved.\");\n+  } else {\n+   //Property not found in our attribute map, so we will use the default hardcoded values instead\n+   if (reservedNamesForUnixGroups.contains(groupNameAttribute.getValue())) throw new WrongAttributeValueException(groupNameAttribute, \"This groupName is reserved.\");\n+  }\n+ }\n+\n+ public void checkUnpermittedUserLogins(Attribute loginAttribute) throws InternalErrorException, WrongAttributeValueException {\n+  if (loginAttribute == null)\n+   return;\n+  checkPerunNamespacesMap();\n+  String unpermittedNames = perunNamespaces.get(loginAttribute.getFriendlyName() + \":reservedNames\");\n+  if (unpermittedNames != null) {\n+   List<String> unpermittedNamesList = Arrays.asList(unpermittedNames.split(\"\\\\s*,\\\\s*\"));\n+   if (unpermittedNamesList.contains(loginAttribute.getValue())) throw new WrongAttributeValueException(loginAttribute, \"This login is not permitted.\");\n+  } else {\n+   //Property not found in our attribute map, so we will use the default hardcoded values instead\n+   if (unpermittedNamesForUserLogins.contains(loginAttribute.getValue())) throw new WrongAttributeValueException(loginAttribute, \"This login is not permitted.\");\n+  }\n+ }\n+\n+ @Override\n+ public Attribute getGoogleGroupNameNamespaceAttributeWithNotNullValue(PerunSessionImpl sess, Resource resource) throws InternalErrorException, WrongReferenceAttributeValueException {\n+  Facility facility = sess.getPerunBl().getResourcesManagerBl().getFacility(sess, resource);\n+  try {\n+   Attribute googleGroupNameNamespaceAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, facility, A_F_googleGroupName_namespace);\n+   if (googleGroupNameNamespaceAttribute.getValue() == null) throw new WrongReferenceAttributeValueException(googleGroupNameNamespaceAttribute);\n+   return googleGroupNameNamespaceAttribute;\n+  } catch (AttributeNotExistsException ex) {\n+   throw new ConsistencyErrorException(ex);\n+  } catch (WrongAttributeAssignmentException ex) {\n+   throw new InternalErrorException(ex);\n+  }\n+ }\n+\n+ public Attribute getUnixGroupNameNamespaceAttributeWithNotNullValue(PerunSessionImpl sess, Resource resource) throws InternalErrorException, WrongReferenceAttributeValueException {\n+  Facility facility = sess.getPerunBl().getResourcesManagerBl().getFacility(sess, resource);\n+  try {\n+   Attribute unixGroupNameNamespaceAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, facility, A_F_unixGroupName_namespace);\n+   if (unixGroupNameNamespaceAttribute.getValue() == null) throw new WrongReferenceAttributeValueException(unixGroupNameNamespaceAttribute);\n+   return unixGroupNameNamespaceAttribute;\n+  } catch (AttributeNotExistsException ex) {\n+   throw new ConsistencyErrorException(ex);\n+  } catch (WrongAttributeAssignmentException ex) {\n+   throw new InternalErrorException(ex);\n+  }\n+ }\n+\n+ public Attribute getUnixGIDNamespaceAttributeWithNotNullValue(PerunSessionImpl sess, Resource resource) throws InternalErrorException, WrongReferenceAttributeValueException {\n+  Facility facility = sess.getPerunBl().getResourcesManagerBl().getFacility(sess, resource);\n+  try {\n+   Attribute unixGIDNamespaceAttribute = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, facility, A_F_unixGID_namespace);\n+   if (unixGIDNamespaceAttribute.getValue() == null) throw new WrongReferenceAttributeValueException(unixGIDNamespaceAttribute);\n+   return unixGIDNamespaceAttribute;\n+  } catch (AttributeNotExistsException ex) {\n+   throw new ConsistencyErrorException(ex);\n+  } catch (WrongAttributeAssignmentException ex) {\n+   throw new InternalErrorException(ex);\n+  }\n+ }\n+\n+ public boolean isGroupUnixGIDNamespaceFillable(PerunSessionImpl sess, Group group, Attribute groupUnixGIDNamespace) throws InternalErrorException, WrongReferenceAttributeValueException, WrongAttributeAssignmentException {\n+  Utils.notNull(group, \"group\");\n+  Utils.notNull(groupUnixGIDNamespace, \"groupUnixGIDNamespace\");\n+\n+  //Get All Facilities from group\n+  Set<Facility> facilitiesOfGroup = new HashSet<Facility>();\n+  List<Resource> resourcesOfGroup = sess.getPerunBl().getResourcesManagerBl().getAssignedResources(sess, group);\n+  for (Resource r : resourcesOfGroup) {\n+   facilitiesOfGroup.add(sess.getPerunBl().getResourcesManagerBl().getFacility(sess, r));\n+  }\n+\n+  //Prepare list of gid namespaces of all facilities which have the same groupName namespace like this unixGroupName namespace\n+  Set<String> groupNameNamespaces = this.getSetOfGroupNameNamespacesWhereFacilitiesHasTheSameGIDNamespace(sess, new ArrayList<Facility>(facilitiesOfGroup), groupUnixGIDNamespace);\n+  if (!groupNameNamespaces.isEmpty()) {\n+\n+   for (String s : groupNameNamespaces) {\n+    try {\n+     Attribute groupNameNamespace = sess.getPerunBl().getAttributesManagerBl().getAttribute(sess, group, A_G_unixGroupName_namespace + \":\" + s);\n+     if (groupNameNamespace.getValue() != null) {\n+      return true;\n+     }\n+    } catch (AttributeNotExistsException ex) {\n+     throw new ConsistencyErrorException(ex);\n+    }\n+   }\n+  }\n+\n+  return false;\n+ }\n+\n+ @Override\n+ public boolean isNameOfEmailValid(PerunSessionImpl sess, String email) {\n+  if (email == null)\n+   return false;\n+  Matcher emailMatcher = Utils.emailPattern.matcher(email);\n+  if (emailMatcher.find())\n+   return true;\n+  return false;\n+ }\n+\n+ public void checkFormatOfShell(String shell, Attribute attribute) throws WrongAttributeValueException {\n+  //previous regex ^/[-a-zA-Z0-9_/]*$\"\n+  Pattern pattern = Pattern.compile(\"^(/[-_a-zA-Z0-9]+)+$\");\n+  Matcher match = pattern.matcher(shell);\n+  if (!match.matches()) {\n+   throw new WrongAttributeValueException(attribute, \"Bad shell attribute format \" + shell);\n+  }\n+ }\n+\n+ public void checkAttributeRegex(Attribute attribute, String defaultRegex) throws InternalErrorException, WrongAttributeValueException {\n+  if (attribute == null || attribute.getValue() == null) throw new InternalErrorException(\"Attribute or it's value is null.\");\n+  String attributeValue = (String) attribute.getValue();\n+  checkPerunNamespacesMap();\n+  String regex = perunNamespaces.get(attribute.getFriendlyName() + \":regex\");\n+  if (regex != null) {\n+   //Check if regex is valid\n+   try {\n+    Pattern.compile(regex);\n+   } catch (PatternSyntaxException e) {\n+    log.error(\"Regex pattern \\\"\" + regex + \"\\\" from \\\"\" + attribute.getFriendlyName() + \":regex\\\"\" + \" property of perun-namespaces.properties file is invalid.\");\n+    throw new InternalErrorException(\"Regex pattern \\\"\" + regex + \"\\\" from \\\"\" + attribute.getFriendlyName() + \":regex\\\"\" + \" property of perun-namespaces.properties file is invalid.\");\n+   }\n+   if (!attributeValue.matches(regex)) {\n+    throw new WrongAttributeValueException(attribute, \"Wrong format. Regex: \\\"\" + regex + \"\\\" expected for this attribute:\");\n+   }\n+  } else {\n+   //Regex property not found in our attribute map, so use the default hardcoded regex\n+   if (defaultRegex == null)\n+    return;\n+   if (!attributeValue.matches(defaultRegex)) {\n+    throw new WrongAttributeValueException(attribute, \"Wrong format. Regex: \\\"\" + defaultRegex + \"\\\" expected for this attribute:\");\n+   }\n+  }\n+ }\n+\n+ /**\n+  * Internal protected method.\n+  * Checks this.perunNamespaces map, which is always initialized as null.\n+  * If null, it tries to load the configuration into this map from a perun-namespaces.properties file.\n+  * If the file does not exist, it creates an empty HashMap, so it's not null anymore.\n+  */\n+\n+ protected void checkPerunNamespacesMap() {\n+  if (perunNamespaces == null) {\n+   try {\n+    perunNamespaces = BeansUtils.getAllPropertiesFromCustomConfiguration(\"perun-namespaces.properties\");\n+   } catch (InternalErrorException e) {\n+    perunNamespaces = new HashMap<>();\n+   }\n+  }\n+ }\n+\n+ @Override\n+ public Map<String, Pair<BigDecimal, BigDecimal>> checkAndTransferQuotas(Attribute quotasAttribute, PerunBean firstPlaceholder, PerunBean secondPlaceholder, boolean withMetrics) throws InternalErrorException, WrongAttributeValueException {\n+  //firstPlaceholder can't be null\n+  if (firstPlaceholder == null) throw new InternalErrorException(\"Missing first mandatory placeHolder (PerunBean).\");\n+  //Quotas attribute must exists with not null value\n+  if (quotasAttribute == null || quotasAttribute.getValue() == null) throw new InternalErrorException(\"Attribute quotas for checking and transfering can't be null.\");\n+\n+  //Prepare result container and value of attribute\n+  Map<String, Pair<BigDecimal, BigDecimal>> transferedQuotas = new HashMap<>();\n+  Map<String, String> defaultQuotasMap = (Map<String, String>) quotasAttribute.getValue();\n+\n+  //List to test if all paths are unique (/var/log and /var/log/ are the same so these two paths are not unique)\n+  List<String> uniquePaths = new ArrayList<>();\n+  for (String path : defaultQuotasMap.keySet()) {\n+   //null is not correct path for volume on File System\n+   if (path == null || path.isEmpty()) throw new WrongAttributeValueException(quotasAttribute,\n+firstPlaceholder,\n+secondPlaceholder,\n+\"The path of some volume where quota should be set is null.\");\n+\n+   //testing if path is unique\n+   String canonicalPath;\n+   try {\n+    canonicalPath = new URI(path).normalize().getPath();\n+    if (!canonicalPath.endsWith(\"/\")) canonicalPath = canonicalPath.concat(\"/\");\n+   } catch (URISyntaxException ex) {\n+    throw new WrongAttributeValueException(quotasAttribute, firstPlaceholder, secondPlaceholder, \"Path '\" + path + \"' is not correct form.\");\n+   }\n+   if (uniquePaths.contains(canonicalPath)) throw new WrongAttributeValueException(quotasAttribute,\n+firstPlaceholder,\n+secondPlaceholder,\n+\"Paths are not unique, there are two same paths: \" + path);\n+   else uniquePaths.add(canonicalPath);\n+   String quota = defaultQuotasMap.get(path);\n+   //quota can't be null, if exists in attribute, must be set in some way\n+   if (quota == null) throw new WrongAttributeValueException(quotasAttribute,\n+firstPlaceholder,\n+secondPlaceholder,\n+\"The quota of some volume where quota should be set is null.\");\n+\n+   //check format of quota parameter (for data with metrics, for count of files without metrics)\n+   Matcher quotaMatcher;\n+   if (withMetrics) {\n+    quotaMatcher = ModulesUtilsBlImpl.quotaWithMetricsPattern.matcher(quota);\n+    if (!quotaMatcher.matches()) throw new WrongAttributeValueException(quotasAttribute,\n+firstPlaceholder,\n+secondPlaceholder,\n+\"Format of quota in quotas attribute is not correct.\");\n+   } else {\n+    quotaMatcher = ModulesUtilsBlImpl.quotaWithoutMetricsPattern.matcher(quota);\n+    if (!quotaMatcher.matches()) throw new WrongAttributeValueException(quotasAttribute,\n+firstPlaceholder,\n+secondPlaceholder,\n+\"Format of quota in quotas attribute is not correct.\");\n+   }\n+\n+   //Parse quotas to variables\n+   String softQuota = quotaMatcher.group(1);\n+   String hardQuota = quotaMatcher.group(3);\n+\n+   //Parse number pattern and letter pattern from whole quotas\n+\n+   //SoftQuotaNumber\n+   BigDecimal softQuotaAfterTransfer;\n+   BigDecimal hardQuotaAfterTransfer;\n+   //special behavior with metrics\n+   if (withMetrics) {\n+    String softQuotaNumber = null;\n+    Matcher numberMatcher = numberPattern.matcher(softQuota);\n+    if (!numberMatcher.find()) throw new ConsistencyErrorException(\"Matcher can't find number in softQuota '\" + softQuota + \"' in attribute \" + quotasAttribute);\n+    softQuotaNumber = numberMatcher.group();\n+\n+    //SoftQuotaLetter\n+    String softQuotaLetter = null;\n+    Matcher letterMatcher = letterPattern.matcher(softQuota);\n+    //in this case no letter means default and default is G\n+    if (!letterMatcher.find()) softQuotaLetter = \"G\";\n+    else softQuotaLetter = letterMatcher.group();\n+\n+    //HardQuotaNumber\n+    String hardQuotaNumber = null;\n+    numberMatcher = numberPattern.matcher(hardQuota);\n+    if (!numberMatcher.find()) throw new ConsistencyErrorException(\"Matcher can't find number in hardQuota '\" + hardQuota + \"' in attribute \" + quotasAttribute);\n+    hardQuotaNumber = numberMatcher.group();\n+\n+    //HardQuotaLetter\n+    String hardQuotaLetter;\n+    letterMatcher = letterPattern.matcher(hardQuota);\n+    //in this case no letter means default and default is G\n+    if (!letterMatcher.find()) hardQuotaLetter = \"G\";\n+    else hardQuotaLetter = letterMatcher.group();\n+\n+    //Prepare whole big decimal numbers\n+    softQuotaAfterTransfer = new BigDecimal(softQuotaNumber);\n+    hardQuotaAfterTransfer = new BigDecimal(hardQuotaNumber);\n+\n+    //multiplying for softQuota\n+    switch (softQuotaLetter) {\n+     case \"K\":\n+      break; //K is basic metric, no need to multiply it\n+     case \"G\":\n+      softQuotaAfterTransfer = softQuotaAfterTransfer.multiply(BigDecimal.valueOf(G));\n+      break;\n+     case \"M\":\n+      softQuotaAfterTransfer = softQuotaAfterTransfer.multiply(BigDecimal.valueOf(M));\n+      break;\n+     case \"T\":\n+      softQuotaAfterTransfer = softQuotaAfterTransfer.multiply(BigDecimal.valueOf(T));\n+      break;\n+     case \"P\":\n+      softQuotaAfterTransfer = softQuotaAfterTransfer.multiply(BigDecimal.valueOf(P));\n+      break;\n+     case \"E\":\n+      softQuotaAfterTransfer = softQuotaAfterTransfer.multiply(BigDecimal.valueOf(E));\n+      break;\n+     default:\n+      throw new ConsistencyErrorException(\"There is not allowed character in soft quota letter '\" + softQuotaLetter + \"'.\");\n+    }\n+\n+    //multiplying for softQuota\n+    switch (hardQuotaLetter) {\n+     case \"K\":\n+      break; //K is basic metric, no need to multiply it\n+     case \"G\":\n+      hardQuotaAfterTransfer = hardQuotaAfterTransfer.multiply(BigDecimal.valueOf(G));\n+      break;\n+     case \"M\":\n+      hardQuotaAfterTransfer = hardQuotaAfterTransfer.multiply(BigDecimal.valueOf(M));\n+      break;\n+     case \"T\":\n+      hardQuotaAfterTransfer = hardQuotaAfterTransfer.multiply(BigDecimal.valueOf(T));\n+      break;\n+     case \"P\":\n+      hardQuotaAfterTransfer = hardQuotaAfterTransfer.multiply(BigDecimal.valueOf(P));\n+      break;\n+     case \"E\":\n+      hardQuotaAfterTransfer = hardQuotaAfterTransfer.multiply(BigDecimal.valueOf(E));\n+      break;\n+     default:\n+      throw new ConsistencyErrorException(\"There is not allowed character in hard quota letter '\" + hardQuotaLetter + \"'.\");\n+    }\n+   //easy way without metrics\n+   } else {\n+    softQuotaAfterTransfer = new BigDecimal(softQuota);\n+    hardQuotaAfterTransfer = new BigDecimal(hardQuota);\n+   }\n+\n+   //test comparing softQuota and hardQuota (softQuota must be less or equals than hardQuota, 0 means unlimited)\n+   //1] if softQuota is unlimited, but hardQuota not = exception\n+   if (softQuotaAfterTransfer.compareTo(BigDecimal.valueOf(0)) == 0 && hardQuotaAfterTransfer.compareTo(BigDecimal.valueOf(0)) != 0) {\n+    throw new WrongAttributeValueException(quotasAttribute, firstPlaceholder, secondPlaceholder, \"SoftQuota is set to unlimited (0) but hardQuota is limited to '\" + hardQuota + \"'.\");\n+   //2] if hardQuota is not unlimited but still it is less then softQuota = exception\n+   } else if (hardQuotaAfterTransfer.compareTo(BigDecimal.valueOf(0)) != 0 && hardQuotaAfterTransfer.compareTo(softQuotaAfterTransfer) < 0) {\n+    throw new WrongAttributeValueException(quotasAttribute, firstPlaceholder, secondPlaceholder, \"One of quotas is not correct. HardQuota '\" + hardQuota + \"' is less then softQuota '\" + softQuota + \"'.\");\n+   }\n+   //other cases are ok\n+   transferedQuotas.put(canonicalPath, new Pair(softQuotaAfterTransfer, hardQuotaAfterTransfer));\n+  }\n+\n+  return transferedQuotas;\n+ }\n+\n+ @Override\n+ public Map<String, String> transferQuotasBackToAttributeValue(Map<String, Pair<BigDecimal, BigDecimal>> transferedQuotasMap, boolean withMetrics) throws InternalErrorException {\n+  Map<String, String> attributeQuotasValue = new HashMap<>();\n+  //if null or empty, return empty attribute value map for quotas\n+  if (transferedQuotasMap == null || transferedQuotasMap.isEmpty())\n+   return attributeQuotasValue;\n+\n+  //every path with quotas transfer step by step\n+  for (String path : transferedQuotasMap.keySet()) {\n+   Pair<BigDecimal, BigDecimal> quotas = transferedQuotasMap.get(path);\n+   BigDecimal softQuotaBD = quotas.getLeft();\n+   BigDecimal hardQuotaBD = quotas.getRight();\n+\n+   //Divide decimal till it is still natural number\n+   //Soft Quota\n+   String softQuota = \"0\";\n+   //Zero means unlimited, stay the same\n+   if (softQuotaBD.compareTo(BigDecimal.ZERO) != 0) {\n+    if (withMetrics) softQuota = Utils.bigDecimalBytesToReadableStringWithMetric(softQuotaBD);\n+    else softQuota = softQuotaBD.toPlainString();\n+   }\n+   //Hard Quota\n+   String hardQuota = \"0\";\n+   //Zero means unlimited, stay the same\n+   if (hardQuotaBD.compareTo(BigDecimal.ZERO) != 0) {\n+    if (withMetrics) hardQuota = Utils.bigDecimalBytesToReadableStringWithMetric(hardQuotaBD);\n+    else hardQuota = hardQuotaBD.toPlainString();\n+   }\n+\n+   //add softQuota and hardQuota to result (50T:60T)\n+   attributeQuotasValue.put(path, softQuota + \":\" + hardQuota);\n+  }\n+\n+  return attributeQuotasValue;\n+ }\n+\n+ @Override\n+ public Map<String, Pair<BigDecimal, BigDecimal>> mergeMemberAndResourceTransferedQuotas(Map<String, Pair<BigDecimal, BigDecimal>> firstQuotas, Map<String, Pair<BigDecimal, BigDecimal>> secondQuotas) {\n+  //if one of them is empty, return the other one (even if it is empty too)\n+  if (firstQuotas.isEmpty())\n+   return secondQuotas;\n+  if (secondQuotas.isEmpty())\n+   return firstQuotas;\n+  Map<String, Pair<BigDecimal, BigDecimal>> mergedTransferedQuotas = new HashMap<>();\n+  //first go through firstQuotas values\n+  for (String path : firstQuotas.keySet()) {\n+   Pair<BigDecimal, BigDecimal> newValue;\n+   Pair<BigDecimal, BigDecimal> firstQuotasValue = firstQuotas.get(path);\n+   Pair<BigDecimal, BigDecimal> secondQuotasValue = secondQuotas.get(path);\n+\n+   //if there is no values for merge, use them\n+   if (secondQuotasValue == null) {\n+    newValue = firstQuotasValue;\n+    mergedTransferedQuotas.put(path, newValue);\n+   //if there are values to merge, merge them\n+   } else {\n+    BigDecimal softQuota;\n+    BigDecimal hardQuota;\n+    //merge softQuota\n+    if (firstQuotasValue.getLeft().compareTo(new BigDecimal(\"0\")) == 0 || secondQuotasValue.getLeft().compareTo(new BigDecimal(\"0\")) == 0) softQuota = new BigDecimal(\"0\");\n+    else {\n+     if (firstQuotasValue.getLeft().compareTo(secondQuotasValue.getLeft()) >= 0) softQuota = firstQuotasValue.getLeft();\n+     else softQuota = secondQuotasValue.getLeft();\n+    }\n+    //merge hardQuota\n+    if (firstQuotasValue.getRight().compareTo(new BigDecimal(\"0\")) == 0 || secondQuotasValue.getRight().compareTo(new BigDecimal(\"0\")) == 0) hardQuota = new BigDecimal(\"0\");\n+    else {\n+     if (firstQuotasValue.getRight().compareTo(secondQuotasValue.getRight()) >= 0) hardQuota = firstQuotasValue.getRight();\n+     else hardQuota = secondQuotasValue.getRight();\n+    }\n+    //set new merged values\n+    newValue = new Pair(softQuota, hardQuota);\n+    mergedTransferedQuotas.put(path, newValue);\n+    //remove them from second quotas (they are not unique)\n+    secondQuotas.remove(path);\n+   }\n+  }\n+  //save rest of values from secondQuotas (only unique in second quotas are still there, not exists in first quotas)\n+\n+  for (String path : secondQuotas.keySet()) {\n+   mergedTransferedQuotas.put(path, secondQuotas.get(path));\n+  }\n+\n+  return mergedTransferedQuotas;\n+ }\n+\n+ public Map<String, Pair<BigDecimal, BigDecimal>> countUserFacilityQuotas(List<Map<String, Pair<BigDecimal, BigDecimal>>> allUserQuotas) {\n+  Map<String, Pair<BigDecimal, BigDecimal>> resultTransferredQuotas = new HashMap<>();\n+  //for every transfered map of merged quotas count one result transfered map\n+  for (Map<String, Pair<BigDecimal, BigDecimal>> mapValue : allUserQuotas) {\n+   //for every path in one transfered map\n+\n+   for (String pathKey : mapValue.keySet()) {\n+    //if path not exists in result map, add it with it's values\n+    if (!resultTransferredQuotas.containsKey(pathKey)) {\n+     resultTransferredQuotas.put(pathKey, mapValue.get(pathKey));\n+    //if path already exists in result map, sum their quotas together\n+    } else {\n+     Pair<BigDecimal, BigDecimal> quotasValue1 = resultTransferredQuotas.get(pathKey);\n+     Pair<BigDecimal, BigDecimal> quotasValue2 = mapValue.get(pathKey);\n+     //for soft quota (left part of pair)\n+     BigDecimal softQuota = BigDecimal.ZERO;\n+     if (quotasValue1.getLeft().compareTo(BigDecimal.ZERO) != 0 && quotasValue2.getLeft().compareTo(BigDecimal.ZERO) != 0) {\n+      softQuota = quotasValue1.getLeft().add(quotasValue2.getLeft());\n+     }\n+     //for hard quota (right part of pair)\n+     BigDecimal hardQuota = BigDecimal.ZERO;\n+     if (quotasValue1.getRight().compareTo(BigDecimal.ZERO) != 0 && quotasValue2.getRight().compareTo(BigDecimal.ZERO) != 0) {\n+      hardQuota = quotasValue1.getRight().add(quotasValue2.getRight());\n+     }\n+     //create new pair of summed numbers\n+     Pair<BigDecimal, BigDecimal> finalQuotasValue = new Pair(softQuota, hardQuota);\n+     //add new summed pair to the result map\n+     resultTransferredQuotas.put(pathKey, finalQuotasValue);\n+    }\n+   }\n+  }\n+  //return result map\n+\n+  return resultTransferredQuotas;\n+ }\n+\n+ /**\n+  * Get list of login-namespaces which have logins generated by Perun\n+  *\n+  * @return List of login-namespaces with generated logins\n+  */\n+\n+ public static List<String> getGeneratedLoginNamespaces() {\n+\n+  // load namespaces to generate login for\n+  List<String> namespaces;\n+  try {\n+   String nmspc = BeansUtils.getPropertyFromConfiguration(\"perun.loginNamespace.generated\");\n+   namespaces = new ArrayList<String>(Arrays.asList(nmspc.split(\",\")));\n+   Iterator<String> nameIter = namespaces.listIterator();\n+   // trim and remove empty namespaces\n+   while (nameIter.hasNext()) {\n+    String namespace = nameIter.next();\n+    namespace = namespace.trim();\n+    if (namespace.isEmpty()) nameIter.remove();\n+   }\n+  } catch (InternalErrorException ex) {\n+   // without value\n+   return new ArrayList<String>();\n+  }\n+\n+  return namespaces;\n+ }\n+\n+ /**\n+  * Normalize string for purpose of generating safe login value.\n+  *\n+  * @return normalized string\n+  */\n+\n+ public static String normalizeStringForLogin(String toBeNormalized) {\n+  if (toBeNormalized == null || toBeNormalized.trim().isEmpty())\n+   return null;\n+  toBeNormalized = toBeNormalized.toLowerCase();\n+  toBeNormalized = java.text.Normalizer.normalize(toBeNormalized, java.text.Normalizer.Form.NFD).replaceAll(\"\\\\p{InCombiningDiacriticalMarks}+\", \"\");\n+  toBeNormalized = toBeNormalized.replaceAll(\"[^a-zA-Z]+\", \"\");\n+\n+  // unable to fill login for users without name or with partial name\n+  if (toBeNormalized == null || toBeNormalized.isEmpty()) {\n+   return null;\n+  }\n+\n+  return toBeNormalized;\n+ }\n+\n+ /**\n+  * Shared logic for purpose of login generation\n+  */\n+\n+ public static class LoginGenerator {\n+\n+  /**\n+   * Define joining function for anonymous classes\n+   */\n+  public interface LoginGeneratorFunction {\n+\n+   /**\n+    * Generate login for user using his name\n+    * @param firstName\n+    * @param lastName\n+    * @return generated login\n+    */\n+\n+\n+   public String generateLogin(String firstName, String lastName);\n+  }\n+\n+  /**\n+   * Generate login for user using his name and joining function\n+   *\n+   * @param user User to get data from\n+   * @param function Function to join fist/lastName to login\n+   * @return generated login\n+   */\n+\n+  public String generateLogin(User user, LoginGeneratorFunction function) {\n+   String firstName = user.getFirstName();\n+   String lastName = user.getLastName();\n+\n+   // get only first part of first name and remove spec. chars\n+   if (firstName != null && !firstName.isEmpty()) {\n+    firstName = ModulesUtilsBlImpl.normalizeStringForLogin(firstName.split(\" \")[0]);\n+   }\n+\n+   // get only last part of last name and remove spec. chars\n+   if (lastName != null && !lastName.isEmpty()) {\n+    List<String> names = Arrays.asList(lastName.split(\" \"));\n+    lastName = names.get(names.size()-1);\n+    lastName = ModulesUtilsBlImpl.normalizeStringForLogin(lastName.split(\" \")[0]);\n+   }\n+\n+   // unable to fill login for users without name or with partial name\n+   if (firstName == null || firstName.isEmpty() || lastName == null || lastName.isEmpty()) {\n+    return null;\n+   }\n+\n+   return function.generateLogin(firstName, lastName);\n+  }\n+ }\n+\n+ public PerunBl getPerunBl() {\n+  return this.perunBl;\n+ }\n+\n+ public void setPerunBl(PerunBl perunBl) {\n+  this.perunBl = perunBl;\n+ }\n+}\n\\ No newline at end of file\n",
            "diff_size": 1051
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/386/ModulesUtilsBlImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/styler_random/386/ModulesUtilsBlImpl.java\nindex 17f40b462e4..1b98291ce22 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/386/ModulesUtilsBlImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/styler_random/386/ModulesUtilsBlImpl.java\n@@ -68,8 +68,8 @@ public class ModulesUtilsBlImpl implements ModulesUtilsBl {\n \n \tpublic final static List<String> reservedNamesForUnixGroups = Arrays.asList(\"root\", \"daemon\", \"tty\", \"bin\", \"sys\", \"sudo\", \"nogroup\",\n \t          \"hadoop\", \"hdfs\", \"mapred\", \"yarn\", \"hsqldb\", \"derby\", \"jetty\", \"hbase\", \"zookeeper\", \"users\");\n-\tpublic final static List<String> unpermittedNamesForUserLogins = Arrays.asList(\"arraysvcs\", \"at\", \"backup\", \"bin\", \"daemon\", \"Debian-exim\", \"flexlm\", \"ftp\", \"games\",\n-\t\t        \"gdm\", \"glite\", \"gnats\", \"haldaemon\", \"identd\", \"irc\", \"libuuid\", \"list\", \"lp\", \"mail\", \"man\",\n+\n+public final static List<String> unpermittedNamesForUserLogins = Arrays.asList(\"arraysvcs\", \"at\", \"backup\", \"bin\", \"daemon\", \"Debian-exim\", \"flexlm\", \"ftp\", \"games\", \"gdm\", \"glite\", \"gnats\", \"haldaemon\", \"identd\", \"irc\", \"libuuid\", \"list\", \"lp\", \"mail\", \"man\",\n \t\t        \"messagebus\", \"news\", \"nobody\", \"ntp\", \"openslp\", \"pcp\", \"polkituser\", \"postfix\", \"proxy\",\n \t\t        \"pulse\", \"puppet\", \"root\", \"saned\", \"smmsp\", \"smmta\", \"sshd\", \"statd\", \"suse-ncc\", \"sync\",\n \t\t        \"sys\", \"uucp\", \"uuidd\", \"www-data\", \"wwwrun\", \"zenssh\", \"tomcat6\", \"tomcat7\", \"tomcat8\",\n",
            "diff_size": 2
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/386/ModulesUtilsBlImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/styler_three_grams/386/ModulesUtilsBlImpl.java\nindex 17f40b462e4..50fd937dba6 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/386/ModulesUtilsBlImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/styler_three_grams/386/ModulesUtilsBlImpl.java\n@@ -68,8 +68,10 @@ public class ModulesUtilsBlImpl implements ModulesUtilsBl {\n \n \tpublic final static List<String> reservedNamesForUnixGroups = Arrays.asList(\"root\", \"daemon\", \"tty\", \"bin\", \"sys\", \"sudo\", \"nogroup\",\n \t          \"hadoop\", \"hdfs\", \"mapred\", \"yarn\", \"hsqldb\", \"derby\", \"jetty\", \"hbase\", \"zookeeper\", \"users\");\n-\tpublic final static List<String> unpermittedNamesForUserLogins = Arrays.asList(\"arraysvcs\", \"at\", \"backup\", \"bin\", \"daemon\", \"Debian-exim\", \"flexlm\", \"ftp\", \"games\",\n-\t\t        \"gdm\", \"glite\", \"gnats\", \"haldaemon\", \"identd\", \"irc\", \"libuuid\", \"list\", \"lp\", \"mail\", \"man\",\n+\n+           public final static List<String> unpermittedNamesForUserLogins = Arrays.asList(\"arraysvcs\", \"at\", \"backup\", \"bin\", \"daemon\", \"Debian-exim\", \"flexlm\",\n+          \"ftp\", \"games\",\n+           \"gdm\", \"glite\", \"gnats\", \"haldaemon\", \"identd\", \"irc\", \"libuuid\", \"list\", \"lp\", \"mail\", \"man\",\n \t\t        \"messagebus\", \"news\", \"nobody\", \"ntp\", \"openslp\", \"pcp\", \"polkituser\", \"postfix\", \"proxy\",\n \t\t        \"pulse\", \"puppet\", \"root\", \"saned\", \"smmsp\", \"smmta\", \"sshd\", \"statd\", \"suse-ncc\", \"sync\",\n \t\t        \"sys\", \"uucp\", \"uuidd\", \"www-data\", \"wwwrun\", \"zenssh\", \"tomcat6\", \"tomcat7\", \"tomcat8\",\n",
            "diff_size": 4
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "naturalize"
    ]
}