{
    "project_name": "TIBCOSoftware-genxdm",
    "error_id": "117",
    "information": {
        "errors": [
            {
                "line": "33",
                "column": "1",
                "severity": "warning",
                "message": "File contains tab characters (this is the first instance).",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
            }
        ]
    },
    "source_code": "final class NfaStepper<E, T> implements RegExMachine<E, T>\n{\n\t// The current list of states that the NFA is in...\n\tprivate LinkedList<NfaMatchState<E>> m_clist = new LinkedList<NfaMatchState<E>>();\n\n\tprivate List<E> m_followers;",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "35",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/117/NfaStepper.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler/117/NfaStepper.java\nindex 324557cd91c..0494b46cba8 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/117/NfaStepper.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler/117/NfaStepper.java\n@@ -30,7 +30,8 @@ import org.genxdm.processor.w3c.xs.regex.api.RegExMachine;\n  */\n final class NfaStepper<E, T> implements RegExMachine<E, T>\n {\n-\t// The current list of states that the NFA is in...\n+// The current list of states that the NFA is in... private LinkedList<NfaMatchState<E>> m_clist = new LinkedList<NfaMatchState<E>>();\n+\n \tprivate LinkedList<NfaMatchState<E>> m_clist = new LinkedList<NfaMatchState<E>>();\n \n \tprivate List<E> m_followers;\n",
            "diff_size": 2
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/117/NfaStepper.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/intellij/117/NfaStepper.java\nindex 324557cd91c..147c8803e53 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/117/NfaStepper.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/intellij/117/NfaStepper.java\n@@ -13,6 +13,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+\n package org.genxdm.processor.w3c.xs.regex.nfa;\n \n import java.util.ArrayList;\n@@ -28,240 +29,191 @@ import org.genxdm.processor.w3c.xs.regex.api.RegExMachine;\n  * Pattern internal class for matching input against a state machine one input token at a time. <br/>\n  * This class simulates the NFA.\n  */\n-final class NfaStepper<E, T> implements RegExMachine<E, T>\n-{\n-\t// The current list of states that the NFA is in...\n-\tprivate LinkedList<NfaMatchState<E>> m_clist = new LinkedList<NfaMatchState<E>>();\n+final class NfaStepper<E, T> implements RegExMachine<E, T> {\n+    // The current list of states that the NFA is in...\n+    private LinkedList<NfaMatchState<E>> m_clist = new LinkedList<NfaMatchState<E>>();\n+\n+    private List<E> m_followers;\n+\n+    private RegExBridge<E, T> m_bridge;\n+\n+    private NfaMatchAllState<E> allState; // can only be one of these active at a time\n+\n+    private List<E> remainingOptional; // used for \"all\" processing\n \n-\tprivate List<E> m_followers;\n-\tprivate RegExBridge<E, T> m_bridge;\n-\tprivate NfaMatchAllState<E> allState; // can only be one of these active at a time\n-\tprivate List<E> remainingOptional; // used for \"all\" processing\n-\tprivate List<E> remainingRequired; // used for \"all\" processing\n+    private List<E> remainingRequired; // used for \"all\" processing\n \n-\t/**\n-\t * Creates a stepper and supplies a place to put follower terms.\n-\t * \n-\t * @param start\n-\t *            the initial state of a state machine to step through\n-\t * @param followers\n-\t *            output list of PatternTerms, to be filled during operation\n-\t */\n-\tpublic NfaStepper(final NfaMatchState<E> start, final List<E> followers, final RegExBridge<E, T> bridge)\n-\t{\n-\t\t// Initialize the current list of states to the starting state.\n-\t\tm_clist.addFirst(start);\n-\t\tm_followers = followers;\n-\t\tm_bridge = PreCondition.assertArgumentNotNull(bridge, \"bridge\");\n-\t}\n+    /**\n+     * Creates a stepper and supplies a place to put follower terms.\n+     *\n+     * @param start     the initial state of a state machine to step through\n+     * @param followers output list of PatternTerms, to be filled during operation\n+     */\n+    public NfaStepper(final NfaMatchState<E> start, final List<E> followers,\n+                      final RegExBridge<E, T> bridge) {\n+        // Initialize the current list of states to the starting state.\n+        m_clist.addFirst(start);\n+        m_followers = followers;\n+        m_bridge = PreCondition.assertArgumentNotNull(bridge, \"bridge\");\n+    }\n \n-\t/**\n-\t * Processes the given token with the state machine. if token is null, then we are at the end of input, and so make\n-\t * sure the state machine is in an end state\n-\t * \n-\t * @param token\n-\t *            an input token or null\n-\t * @param matchers\n-\t *            output List containing PatternTerms that matched the input\n-\t * @return true if the token can be consumed by the pattern or if input is null and state machine is at an end state\n-\t */\n-\tpublic boolean step(final T token, final List<? super E> matchers)\n-\t{\n-\t\tif (m_followers != null)\n-\t\t{\n-\t\t\tm_followers.clear();\n-\t\t}\n+    /**\n+     * Processes the given token with the state machine. if token is null, then we are at the end of input, and so make\n+     * sure the state machine is in an end state\n+     *\n+     * @param token    an input token or null\n+     * @param matchers output List containing PatternTerms that matched the input\n+     * @return true if the token can be consumed by the pattern or if input is null and state machine is at an end state\n+     */\n+    public boolean step(final T token, final List<? super E> matchers) {\n+        if (m_followers != null) {\n+            m_followers.clear();\n+        }\n \n-\t\tif (allState != null)\n-\t\t{\n-\t\t\treturn allStep(token, matchers);\n-\t\t}\n+        if (allState != null) {\n+            return allStep(token, matchers);\n+        }\n \n-\t\t// TODO: Find a more efficient way to do this? Some solutions use a generation number but that\n-\t\t// TODO: would mean labelling the states diectly.\n-\t\tList<NfaMatchState<E>> visitedThisTurn = new ArrayList<NfaMatchState<E>>(23);\n-\t\t// Map visitedThisTurn = new HashMap();\n+        // TODO: Find a more efficient way to do this? Some solutions use a generation number but that\n+        // TODO: would mean labelling the states diectly.\n+        List<NfaMatchState<E>> visitedThisTurn = new ArrayList<NfaMatchState<E>>(23);\n+        // Map visitedThisTurn = new HashMap();\n \n-\t\t// Append a marker (null) to separate the current states from the next states\n-\t\tm_clist.add(null); // null separates steps in the deque\n+        // Append a marker (null) to separate the current states from the next states\n+        m_clist.add(null); // null separates steps in the deque\n \n-\t\twhile (true)\n-\t\t{\n-\t\t\tfinal NfaMatchState<E> curState = m_clist.removeFirst();\n-\t\t\tif (curState == null)\n-\t\t\t{\n-\t\t\t\t// we're done with this step\n-\t\t\t\tif (m_clist.size() == 0)\n-\t\t\t\t{\n-\t\t\t\t\t// This is the error condition. We no states for next time\n-\t\t\t\t\t// so we definitely can't find ourselves in an accept (end) state.\n-\t\t\t\t\t// The follower expressions are already synchronized (empty).\n-\t\t\t\t\treturn false;\n-\t\t\t\t}\n-\t\t\t\telse\n-\t\t\t\t{\n-\t\t\t\t\tif (token == null)\n-\t\t\t\t\t{\n-\t\t\t\t\t\t// We should have returned by now with the accept condition\n-\t\t\t\t\t\t// so the fact that we have not says that we didn't satisfy\n-\t\t\t\t\t\t// the accept condition.\n-\t\t\t\t\t\tNfaHelper.updateFollowers(m_clist, m_followers);\n-\t\t\t\t\t\treturn false;\n-\t\t\t\t\t}\n-\t\t\t\t\telse\n-\t\t\t\t\t{\n-\t\t\t\t\t\t// TODO: Why don't we update the followers - for design time tools that is.\n-\t\t\t\t\t\treturn true; // we added work for the next step\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\telse if (curState.isEnd())\n-\t\t\t{\n-\t\t\t\tif (token == null)\n-\t\t\t\t{\n-\t\t\t\t\t// TODO: We're bailing out early so the follower list as actually incomplete.\n-\t\t\t\t\tNfaHelper.updateFollowers(m_clist, m_followers);\n-\t\t\t\t\treturn true; // This is the accept condition.\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\telse if (curState.isAll())\n-\t\t\t{\n-\t\t\t\t// TODO: Don't understand this yet.\n-\t\t\t\tif (allState == null)\n-\t\t\t\t{\n-\t\t\t\t\tallState = (NfaMatchAllState<E>)curState;\n-\t\t\t\t\tremainingOptional = new ArrayList<E>(allState.getOptionalTerms());\n-\t\t\t\t\tremainingRequired = new ArrayList<E>(allState.getRequiredTerms());\n-\t\t\t\t\treturn allStep(token, matchers);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\telse if (curState.getTerm() == null)\n-\t\t\t{\n-\t\t\t\t// There is no exit condition so we need to process the next states.\n-\t\t\t\t// Furthermore, these states need to be processed with the incoming token parameter,\n-\t\t\t\t// so we are going to push them onto the deque and handle them immediately.\n-\t\t\t\tfor (final NfaMatchState<E> next : curState.nextStates())\n-\t\t\t\t{\n-\t\t\t\t\t/*\n-\t\t\t\t\t * if (!visitedThisTurn.containsKey(next)) { visitedThisTurn.put(next, next); work.addHead(next); }\n-\t\t\t\t\t */\n-\t\t\t\t\tif (visitedThisTurn.indexOf(next) == -1)\n-\t\t\t\t\t{\n-\t\t\t\t\t\tvisitedThisTurn.add(next);\n-\t\t\t\t\t\tm_clist.addFirst(next); // push onto deque so as not to be behind the marker\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\telse if (token != null && m_bridge.matches(curState.getTerm(), token))\n-\t\t\t{\n-\t\t\t\tif (matchers != null)\n-\t\t\t\t{\n-\t\t\t\t\tmatchers.add(curState.getTerm());\n-\t\t\t\t}\n-\t\t\t\tfor (final NfaMatchState<E> e : curState.nextStates())\n-\t\t\t\t{\n-\t\t\t\t\tm_clist.add(e);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\telse if (token == null && m_bridge.matches(curState.getTerm(), null))\n-\t\t\t{\n-\t\t\t\t// There is no exit condition so we need to process the next states.\n-\t\t\t\t// Furthermore, these states need to be processed with the incoming token parameter,\n-\t\t\t\t// so we are going to push them onto the deque and handle them immediately.\n-\t\t\t\tfor (final NfaMatchState<E> next : curState.nextStates())\n-\t\t\t\t{\n-\t\t\t\t\t/*\n-\t\t\t\t\t * if (!visitedThisTurn.containsKey(next)) { visitedThisTurn.put(next, next); work.addHead(next); }\n-\t\t\t\t\t */\n-\t\t\t\t\tif (visitedThisTurn.indexOf(next) == -1)\n-\t\t\t\t\t{\n-\t\t\t\t\t\tvisitedThisTurn.add(next);\n-\t\t\t\t\t\tm_clist.addFirst(next); // push onto deque so as not to be behind the marker\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\telse\n-\t\t\t{\n-\t\t\t\t// TODO: This just looks broken. What is it for?\n-\t\t\t\t// nothing consumed, remember for possible error reporting\n-\t\t\t\tif (m_followers != null)\n-\t\t\t\t{\n-\t\t\t\t\tm_followers.add(curState.getTerm());\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n+        while (true) {\n+            final NfaMatchState<E> curState = m_clist.removeFirst();\n+            if (curState == null) {\n+                // we're done with this step\n+                if (m_clist.size() == 0) {\n+                    // This is the error condition. We no states for next time\n+                    // so we definitely can't find ourselves in an accept (end) state.\n+                    // The follower expressions are already synchronized (empty).\n+                    return false;\n+                } else {\n+                    if (token == null) {\n+                        // We should have returned by now with the accept condition\n+                        // so the fact that we have not says that we didn't satisfy\n+                        // the accept condition.\n+                        NfaHelper.updateFollowers(m_clist, m_followers);\n+                        return false;\n+                    } else {\n+                        // TODO: Why don't we update the followers - for design time tools that is.\n+                        return true; // we added work for the next step\n+                    }\n+                }\n+            } else if (curState.isEnd()) {\n+                if (token == null) {\n+                    // TODO: We're bailing out early so the follower list as actually incomplete.\n+                    NfaHelper.updateFollowers(m_clist, m_followers);\n+                    return true; // This is the accept condition.\n+                }\n+            } else if (curState.isAll()) {\n+                // TODO: Don't understand this yet.\n+                if (allState == null) {\n+                    allState = (NfaMatchAllState<E>) curState;\n+                    remainingOptional = new ArrayList<E>(allState.getOptionalTerms());\n+                    remainingRequired = new ArrayList<E>(allState.getRequiredTerms());\n+                    return allStep(token, matchers);\n+                }\n+            } else if (curState.getTerm() == null) {\n+                // There is no exit condition so we need to process the next states.\n+                // Furthermore, these states need to be processed with the incoming token parameter,\n+                // so we are going to push them onto the deque and handle them immediately.\n+                for (final NfaMatchState<E> next : curState.nextStates()) {\n+                    /*\n+                     * if (!visitedThisTurn.containsKey(next)) { visitedThisTurn.put(next, next); work.addHead(next); }\n+                     */\n+                    if (visitedThisTurn.indexOf(next) == -1) {\n+                        visitedThisTurn.add(next);\n+                        m_clist.addFirst(next); // push onto deque so as not to be behind the marker\n+                    }\n+                }\n+            } else if (token != null && m_bridge.matches(curState.getTerm(), token)) {\n+                if (matchers != null) {\n+                    matchers.add(curState.getTerm());\n+                }\n+                for (final NfaMatchState<E> e : curState.nextStates()) {\n+                    m_clist.add(e);\n+                }\n+            } else if (token == null && m_bridge.matches(curState.getTerm(), null)) {\n+                // There is no exit condition so we need to process the next states.\n+                // Furthermore, these states need to be processed with the incoming token parameter,\n+                // so we are going to push them onto the deque and handle them immediately.\n+                for (final NfaMatchState<E> next : curState.nextStates()) {\n+                    /*\n+                     * if (!visitedThisTurn.containsKey(next)) { visitedThisTurn.put(next, next); work.addHead(next); }\n+                     */\n+                    if (visitedThisTurn.indexOf(next) == -1) {\n+                        visitedThisTurn.add(next);\n+                        m_clist.addFirst(next); // push onto deque so as not to be behind the marker\n+                    }\n+                }\n+            } else {\n+                // TODO: This just looks broken. What is it for?\n+                // nothing consumed, remember for possible error reporting\n+                if (m_followers != null) {\n+                    m_followers.add(curState.getTerm());\n+                }\n+            }\n+        }\n+    }\n \n-\t/**\n-\t * Processes the given token with the state machine. if token is null, then we are at the end of input, and so make\n-\t * sure the state machine is in an end state\n-\t * <p/>\n-\t * Special case for handling the \"all\" content model type.\n-\t * \n-\t * @param token\n-\t *            an input token or null\n-\t * @param matchers\n-\t *            output List containing PatternTerms that matched the input\n-\t * @return true if the token can be consumed by the pattern or if input is null and state machine is at an end state\n-\t */\n-\tpublic boolean allStep(T token, List<? super E> matchers)\n-\t{\n-\t\tif (token == null)\n-\t\t{\n-\t\t\t// end of input, should have consumed all required items\n-\t\t\tif (m_followers != null)\n-\t\t\t{\n-\t\t\t\t// update followers\n-\t\t\t\tfor (final E e : remainingRequired)\n-\t\t\t\t{\n-\t\t\t\t\tm_followers.add(e);\n-\t\t\t\t}\n-\t\t\t\tfor (final E e : remainingOptional)\n-\t\t\t\t{\n-\t\t\t\t\tm_followers.add(e);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\treturn remainingRequired.size() == 0;\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tfor (int i = 0; i < remainingRequired.size(); i++)\n-\t\t\t{\n-\t\t\t\tE t = remainingRequired.get(i);\n-\t\t\t\tif (m_bridge.matches(t, token))\n-\t\t\t\t{\n-\t\t\t\t\tif (matchers != null)\n-\t\t\t\t\t\tmatchers.add(t);\n-\t\t\t\t\tremainingRequired.remove(i);\n-\t\t\t\t\treturn true; // got a match for token\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tfor (int i = 0; i < remainingOptional.size(); i++)\n-\t\t\t{\n-\t\t\t\tE t = remainingOptional.get(i);\n-\t\t\t\tif (m_bridge.matches(t, token))\n-\t\t\t\t{\n-\t\t\t\t\tif (matchers != null)\n-\t\t\t\t\t{\n-\t\t\t\t\t\tmatchers.add(t);\n-\t\t\t\t\t}\n-\t\t\t\t\tremainingOptional.remove(i);\n-\t\t\t\t\treturn true; // got a match for token\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tif (m_followers != null)\n-\t\t\t{\n-\t\t\t\t// update followers\n-\t\t\t\tfor (final E e : remainingRequired)\n-\t\t\t\t{\n-\t\t\t\t\tm_followers.add(e);\n-\t\t\t\t}\n-\t\t\t\tfor (final E e : remainingOptional)\n-\t\t\t\t{\n-\t\t\t\t\tm_followers.add(e);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\treturn false;\n-\t\t}\n-\t}\n+    /**\n+     * Processes the given token with the state machine. if token is null, then we are at the end of input, and so make\n+     * sure the state machine is in an end state\n+     * <p/>\n+     * Special case for handling the \"all\" content model type.\n+     *\n+     * @param token    an input token or null\n+     * @param matchers output List containing PatternTerms that matched the input\n+     * @return true if the token can be consumed by the pattern or if input is null and state machine is at an end state\n+     */\n+    public boolean allStep(T token, List<? super E> matchers) {\n+        if (token == null) {\n+            // end of input, should have consumed all required items\n+            if (m_followers != null) {\n+                // update followers\n+                for (final E e : remainingRequired) {\n+                    m_followers.add(e);\n+                }\n+                for (final E e : remainingOptional) {\n+                    m_followers.add(e);\n+                }\n+            }\n+            return remainingRequired.size() == 0;\n+        } else {\n+            for (int i = 0; i < remainingRequired.size(); i++) {\n+                E t = remainingRequired.get(i);\n+                if (m_bridge.matches(t, token)) {\n+                    if (matchers != null) {\n+                        matchers.add(t);\n+                    }\n+                    remainingRequired.remove(i);\n+                    return true; // got a match for token\n+                }\n+            }\n+            for (int i = 0; i < remainingOptional.size(); i++) {\n+                E t = remainingOptional.get(i);\n+                if (m_bridge.matches(t, token)) {\n+                    if (matchers != null) {\n+                        matchers.add(t);\n+                    }\n+                    remainingOptional.remove(i);\n+                    return true; // got a match for token\n+                }\n+            }\n+            if (m_followers != null) {\n+                // update followers\n+                for (final E e : remainingRequired) {\n+                    m_followers.add(e);\n+                }\n+                for (final E e : remainingOptional) {\n+                    m_followers.add(e);\n+                }\n+            }\n+            return false;\n+        }\n+    }\n }\n",
            "diff_size": 236
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/117/NfaStepper.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/codebuff/117/NfaStepper.java\nindex 324557cd91c..710e1f1363f 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/117/NfaStepper.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/codebuff/117/NfaStepper.java\n@@ -18,7 +18,6 @@ package org.genxdm.processor.w3c.xs.regex.nfa;\n import java.util.ArrayList;\n import java.util.LinkedList;\n import java.util.List;\n-\n import org.genxdm.exceptions.PreCondition;\n import org.genxdm.processor.w3c.xs.regex.api.RegExBridge;\n import org.genxdm.processor.w3c.xs.regex.api.RegExMachine;\n@@ -28,240 +27,241 @@ import org.genxdm.processor.w3c.xs.regex.api.RegExMachine;\n  * Pattern internal class for matching input against a state machine one input token at a time. <br/>\n  * This class simulates the NFA.\n  */\n+\n final class NfaStepper<E, T> implements RegExMachine<E, T>\n {\n-\t// The current list of states that the NFA is in...\n-\tprivate LinkedList<NfaMatchState<E>> m_clist = new LinkedList<NfaMatchState<E>>();\n+    // The current list of states that the NFA is in...\n+    private LinkedList<NfaMatchState<E>> m_clist = new LinkedList<NfaMatchState<E>>();\n+    private List<E> m_followers;\n+    private RegExBridge<E, T> m_bridge;\n+    private NfaMatchAllState<E> allState; // can only be one of these active at a time\n+    private List<E> remainingOptional; // used for \"all\" processing\n+    private List<E> remainingRequired; // used for \"all\" processing\n \n-\tprivate List<E> m_followers;\n-\tprivate RegExBridge<E, T> m_bridge;\n-\tprivate NfaMatchAllState<E> allState; // can only be one of these active at a time\n-\tprivate List<E> remainingOptional; // used for \"all\" processing\n-\tprivate List<E> remainingRequired; // used for \"all\" processing\n+    /**\n+     * Creates a stepper and supplies a place to put follower terms.\n+     * \n+     * @param start\n+     *            the initial state of a state machine to step through\n+     * @param followers\n+     *            output list of PatternTerms, to be filled during operation\n+     */\n \n-\t/**\n-\t * Creates a stepper and supplies a place to put follower terms.\n-\t * \n-\t * @param start\n-\t *            the initial state of a state machine to step through\n-\t * @param followers\n-\t *            output list of PatternTerms, to be filled during operation\n-\t */\n-\tpublic NfaStepper(final NfaMatchState<E> start, final List<E> followers, final RegExBridge<E, T> bridge)\n-\t{\n-\t\t// Initialize the current list of states to the starting state.\n-\t\tm_clist.addFirst(start);\n-\t\tm_followers = followers;\n-\t\tm_bridge = PreCondition.assertArgumentNotNull(bridge, \"bridge\");\n-\t}\n+    public NfaStepper(final NfaMatchState<E> start, final List<E> followers, final RegExBridge<E, T> bridge)\n+    {\n+        // Initialize the current list of states to the starting state.\n+        m_clist.addFirst(start);\n+        m_followers = followers;\n+        m_bridge = PreCondition.assertArgumentNotNull(bridge, \"bridge\");\n+    }\n \n-\t/**\n-\t * Processes the given token with the state machine. if token is null, then we are at the end of input, and so make\n-\t * sure the state machine is in an end state\n-\t * \n-\t * @param token\n-\t *            an input token or null\n-\t * @param matchers\n-\t *            output List containing PatternTerms that matched the input\n-\t * @return true if the token can be consumed by the pattern or if input is null and state machine is at an end state\n-\t */\n-\tpublic boolean step(final T token, final List<? super E> matchers)\n-\t{\n-\t\tif (m_followers != null)\n-\t\t{\n-\t\t\tm_followers.clear();\n-\t\t}\n+    /**\n+     * Processes the given token with the state machine. if token is null, then we are at the end of input, and so make\n+     * sure the state machine is in an end state\n+     * \n+     * @param token\n+     *            an input token or null\n+     * @param matchers\n+     *            output List containing PatternTerms that matched the input\n+     * @return true if the token can be consumed by the pattern or if input is null and state machine is at an end state\n+     */\n \n-\t\tif (allState != null)\n-\t\t{\n-\t\t\treturn allStep(token, matchers);\n-\t\t}\n+    public boolean step(final T token, final List<? super E> matchers)\n+    {\n+        if (m_followers != null)\n+        {\n+            m_followers.clear();\n+        }\n+        if (allState != null)\n+        {\n+            return allStep(token, matchers);\n+        }\n \n-\t\t// TODO: Find a more efficient way to do this? Some solutions use a generation number but that\n-\t\t// TODO: would mean labelling the states diectly.\n-\t\tList<NfaMatchState<E>> visitedThisTurn = new ArrayList<NfaMatchState<E>>(23);\n-\t\t// Map visitedThisTurn = new HashMap();\n+        // TODO: Find a more efficient way to do this? Some solutions use a generation number but that\n+        // TODO: would mean labelling the states diectly.\n+        List<NfaMatchState<E>> visitedThisTurn = new ArrayList<NfaMatchState<E>>(23);\n+        // Map visitedThisTurn = new HashMap();\n \n-\t\t// Append a marker (null) to separate the current states from the next states\n-\t\tm_clist.add(null); // null separates steps in the deque\n+        // Append a marker (null) to separate the current states from the next states\n+        m_clist.add(null); // null separates steps in the deque\n+        while (true)\n+        {\n+            final NfaMatchState<E> curState = m_clist.removeFirst();\n+            if (curState == null)\n+            {\n+                // we're done with this step\n+                if (m_clist.size() == 0)\n+                {\n+                    // This is the error condition. We no states for next time\n+                    // so we definitely can't find ourselves in an accept (end) state.\n+                    // The follower expressions are already synchronized (empty).\n+                    return false;\n+                }\n+                else\n+                {\n+                    if (token == null)\n+                    {\n+                        // We should have returned by now with the accept condition\n+                        // so the fact that we have not says that we didn't satisfy\n+                        // the accept condition.\n+                        NfaHelper.updateFollowers(m_clist, m_followers);\n+                        return false;\n+                    }\n+                    else\n+                    {\n+                        // TODO: Why don't we update the followers - for design time tools that is.\n+                        return true; // we added work for the next step\n+                    }\n+                }\n+            }\n+            else if (curState.isEnd())\n+            {\n+                if (token == null)\n+                {\n+                    // TODO: We're bailing out early so the follower list as actually incomplete.\n+                    NfaHelper.updateFollowers(m_clist, m_followers);\n+                    return true; // This is the accept condition.\n+                }\n+            }\n+            else if (curState.isAll())\n+            {\n+                // TODO: Don't understand this yet.\n+                if (allState == null)\n+                {\n+                    allState = (NfaMatchAllState<E>)curState;\n+                    remainingOptional = new ArrayList<E>(allState.getOptionalTerms());\n+                    remainingRequired = new ArrayList<E>(allState.getRequiredTerms());\n+                    return allStep(token, matchers);\n+                }\n+            }\n+            else if (curState.getTerm() == null)\n+            {\n+                // There is no exit condition so we need to process the next states.\n+                // Furthermore, these states need to be processed with the incoming token parameter,\n+                // so we are going to push them onto the deque and handle them immediately.\n+                for (final NfaMatchState<E> next : curState.nextStates())\n+                {\n+                    /*\n+                     * if (!visitedThisTurn.containsKey(next)) { visitedThisTurn.put(next, next); work.addHead(next); }\n+                     */\n+                    if (visitedThisTurn.indexOf(next) == -1)\n+                    {\n+                        visitedThisTurn.add(next);\n+                        m_clist.addFirst(next); // push onto deque so as not to be behind the marker\n+                    }\n+                }\n+            }\n+            else if (token != null && m_bridge.matches(curState.getTerm(), token))\n+            {\n+                if (matchers != null)\n+                {\n+                    matchers.add(curState.getTerm());\n+                }\n+                for (final NfaMatchState<E> e : curState.nextStates())\n+                {\n+                    m_clist.add(e);\n+                }\n+            }\n+            else if (token == null && m_bridge.matches(curState.getTerm(), null))\n+            {\n+                // There is no exit condition so we need to process the next states.\n+                // Furthermore, these states need to be processed with the incoming token parameter,\n+                // so we are going to push them onto the deque and handle them immediately.\n+                for (final NfaMatchState<E> next : curState.nextStates())\n+                {\n+                    /*\n+                     * if (!visitedThisTurn.containsKey(next)) { visitedThisTurn.put(next, next); work.addHead(next); }\n+                     */\n+                    if (visitedThisTurn.indexOf(next) == -1)\n+                    {\n+                        visitedThisTurn.add(next);\n+                        m_clist.addFirst(next); // push onto deque so as not to be behind the marker\n+                    }\n+                }\n+            }\n+            else\n+            {\n+                // TODO: This just looks broken. What is it for?\n+                // nothing consumed, remember for possible error reporting\n+                if (m_followers != null)\n+                {\n+                    m_followers.add(curState.getTerm());\n+                }\n+            }\n+        }\n+    }\n \n-\t\twhile (true)\n-\t\t{\n-\t\t\tfinal NfaMatchState<E> curState = m_clist.removeFirst();\n-\t\t\tif (curState == null)\n-\t\t\t{\n-\t\t\t\t// we're done with this step\n-\t\t\t\tif (m_clist.size() == 0)\n-\t\t\t\t{\n-\t\t\t\t\t// This is the error condition. We no states for next time\n-\t\t\t\t\t// so we definitely can't find ourselves in an accept (end) state.\n-\t\t\t\t\t// The follower expressions are already synchronized (empty).\n-\t\t\t\t\treturn false;\n-\t\t\t\t}\n-\t\t\t\telse\n-\t\t\t\t{\n-\t\t\t\t\tif (token == null)\n-\t\t\t\t\t{\n-\t\t\t\t\t\t// We should have returned by now with the accept condition\n-\t\t\t\t\t\t// so the fact that we have not says that we didn't satisfy\n-\t\t\t\t\t\t// the accept condition.\n-\t\t\t\t\t\tNfaHelper.updateFollowers(m_clist, m_followers);\n-\t\t\t\t\t\treturn false;\n-\t\t\t\t\t}\n-\t\t\t\t\telse\n-\t\t\t\t\t{\n-\t\t\t\t\t\t// TODO: Why don't we update the followers - for design time tools that is.\n-\t\t\t\t\t\treturn true; // we added work for the next step\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\telse if (curState.isEnd())\n-\t\t\t{\n-\t\t\t\tif (token == null)\n-\t\t\t\t{\n-\t\t\t\t\t// TODO: We're bailing out early so the follower list as actually incomplete.\n-\t\t\t\t\tNfaHelper.updateFollowers(m_clist, m_followers);\n-\t\t\t\t\treturn true; // This is the accept condition.\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\telse if (curState.isAll())\n-\t\t\t{\n-\t\t\t\t// TODO: Don't understand this yet.\n-\t\t\t\tif (allState == null)\n-\t\t\t\t{\n-\t\t\t\t\tallState = (NfaMatchAllState<E>)curState;\n-\t\t\t\t\tremainingOptional = new ArrayList<E>(allState.getOptionalTerms());\n-\t\t\t\t\tremainingRequired = new ArrayList<E>(allState.getRequiredTerms());\n-\t\t\t\t\treturn allStep(token, matchers);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\telse if (curState.getTerm() == null)\n-\t\t\t{\n-\t\t\t\t// There is no exit condition so we need to process the next states.\n-\t\t\t\t// Furthermore, these states need to be processed with the incoming token parameter,\n-\t\t\t\t// so we are going to push them onto the deque and handle them immediately.\n-\t\t\t\tfor (final NfaMatchState<E> next : curState.nextStates())\n-\t\t\t\t{\n-\t\t\t\t\t/*\n-\t\t\t\t\t * if (!visitedThisTurn.containsKey(next)) { visitedThisTurn.put(next, next); work.addHead(next); }\n-\t\t\t\t\t */\n-\t\t\t\t\tif (visitedThisTurn.indexOf(next) == -1)\n-\t\t\t\t\t{\n-\t\t\t\t\t\tvisitedThisTurn.add(next);\n-\t\t\t\t\t\tm_clist.addFirst(next); // push onto deque so as not to be behind the marker\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\telse if (token != null && m_bridge.matches(curState.getTerm(), token))\n-\t\t\t{\n-\t\t\t\tif (matchers != null)\n-\t\t\t\t{\n-\t\t\t\t\tmatchers.add(curState.getTerm());\n-\t\t\t\t}\n-\t\t\t\tfor (final NfaMatchState<E> e : curState.nextStates())\n-\t\t\t\t{\n-\t\t\t\t\tm_clist.add(e);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\telse if (token == null && m_bridge.matches(curState.getTerm(), null))\n-\t\t\t{\n-\t\t\t\t// There is no exit condition so we need to process the next states.\n-\t\t\t\t// Furthermore, these states need to be processed with the incoming token parameter,\n-\t\t\t\t// so we are going to push them onto the deque and handle them immediately.\n-\t\t\t\tfor (final NfaMatchState<E> next : curState.nextStates())\n-\t\t\t\t{\n-\t\t\t\t\t/*\n-\t\t\t\t\t * if (!visitedThisTurn.containsKey(next)) { visitedThisTurn.put(next, next); work.addHead(next); }\n-\t\t\t\t\t */\n-\t\t\t\t\tif (visitedThisTurn.indexOf(next) == -1)\n-\t\t\t\t\t{\n-\t\t\t\t\t\tvisitedThisTurn.add(next);\n-\t\t\t\t\t\tm_clist.addFirst(next); // push onto deque so as not to be behind the marker\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\telse\n-\t\t\t{\n-\t\t\t\t// TODO: This just looks broken. What is it for?\n-\t\t\t\t// nothing consumed, remember for possible error reporting\n-\t\t\t\tif (m_followers != null)\n-\t\t\t\t{\n-\t\t\t\t\tm_followers.add(curState.getTerm());\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n+    /**\n+     * Processes the given token with the state machine. if token is null, then we are at the end of input, and so make\n+     * sure the state machine is in an end state\n+     * <p/>\n+     * Special case for handling the \"all\" content model type.\n+     * \n+     * @param token\n+     *            an input token or null\n+     * @param matchers\n+     *            output List containing PatternTerms that matched the input\n+     * @return true if the token can be consumed by the pattern or if input is null and state machine is at an end state\n+     */\n \n-\t/**\n-\t * Processes the given token with the state machine. if token is null, then we are at the end of input, and so make\n-\t * sure the state machine is in an end state\n-\t * <p/>\n-\t * Special case for handling the \"all\" content model type.\n-\t * \n-\t * @param token\n-\t *            an input token or null\n-\t * @param matchers\n-\t *            output List containing PatternTerms that matched the input\n-\t * @return true if the token can be consumed by the pattern or if input is null and state machine is at an end state\n-\t */\n-\tpublic boolean allStep(T token, List<? super E> matchers)\n-\t{\n-\t\tif (token == null)\n-\t\t{\n-\t\t\t// end of input, should have consumed all required items\n-\t\t\tif (m_followers != null)\n-\t\t\t{\n-\t\t\t\t// update followers\n-\t\t\t\tfor (final E e : remainingRequired)\n-\t\t\t\t{\n-\t\t\t\t\tm_followers.add(e);\n-\t\t\t\t}\n-\t\t\t\tfor (final E e : remainingOptional)\n-\t\t\t\t{\n-\t\t\t\t\tm_followers.add(e);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\treturn remainingRequired.size() == 0;\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tfor (int i = 0; i < remainingRequired.size(); i++)\n-\t\t\t{\n-\t\t\t\tE t = remainingRequired.get(i);\n-\t\t\t\tif (m_bridge.matches(t, token))\n-\t\t\t\t{\n-\t\t\t\t\tif (matchers != null)\n-\t\t\t\t\t\tmatchers.add(t);\n-\t\t\t\t\tremainingRequired.remove(i);\n-\t\t\t\t\treturn true; // got a match for token\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tfor (int i = 0; i < remainingOptional.size(); i++)\n-\t\t\t{\n-\t\t\t\tE t = remainingOptional.get(i);\n-\t\t\t\tif (m_bridge.matches(t, token))\n-\t\t\t\t{\n-\t\t\t\t\tif (matchers != null)\n-\t\t\t\t\t{\n-\t\t\t\t\t\tmatchers.add(t);\n-\t\t\t\t\t}\n-\t\t\t\t\tremainingOptional.remove(i);\n-\t\t\t\t\treturn true; // got a match for token\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tif (m_followers != null)\n-\t\t\t{\n-\t\t\t\t// update followers\n-\t\t\t\tfor (final E e : remainingRequired)\n-\t\t\t\t{\n-\t\t\t\t\tm_followers.add(e);\n-\t\t\t\t}\n-\t\t\t\tfor (final E e : remainingOptional)\n-\t\t\t\t{\n-\t\t\t\t\tm_followers.add(e);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\treturn false;\n-\t\t}\n-\t}\n-}\n+    public boolean allStep(T token, List<? super E> matchers)\n+    {\n+        if (token == null)\n+        {\n+            // end of input, should have consumed all required items\n+            if (m_followers != null)\n+            {\n+                // update followers\n+                for (final E e : remainingRequired)\n+                {\n+                    m_followers.add(e);\n+                }\n+                for (final E e : remainingOptional)\n+                {\n+                    m_followers.add(e);\n+                }\n+            }\n+            return remainingRequired.size() == 0;\n+        }\n+        else\n+        {\n+            for (int i = 0; i < remainingRequired.size() ; i++)\n+            {\n+                E t = remainingRequired.get(i);\n+                if (m_bridge.matches(t, token))\n+                {\n+                    if (matchers != null)\n+                        matchers.add(t);\n+                    remainingRequired.remove(i);\n+                    return true; // got a match for token\n+                }\n+            }\n+            for (int i = 0; i < remainingOptional.size() ; i++)\n+            {\n+                E t = remainingOptional.get(i);\n+                if (m_bridge.matches(t, token))\n+                {\n+                    if (matchers != null)\n+                    {\n+                        matchers.add(t);\n+                    }\n+                    remainingOptional.remove(i);\n+                    return true; // got a match for token\n+                }\n+            }\n+            if (m_followers != null)\n+            {\n+                // update followers\n+                for (final E e : remainingRequired)\n+                {\n+                    m_followers.add(e);\n+                }\n+                for (final E e : remainingOptional)\n+                {\n+                    m_followers.add(e);\n+                }\n+            }\n+            return false;\n+        }\n+    }\n+}\n\\ No newline at end of file\n",
            "diff_size": 349
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "35",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/117/NfaStepper.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_random/117/NfaStepper.java\nindex 324557cd91c..0494b46cba8 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/117/NfaStepper.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_random/117/NfaStepper.java\n@@ -30,7 +30,8 @@ import org.genxdm.processor.w3c.xs.regex.api.RegExMachine;\n  */\n final class NfaStepper<E, T> implements RegExMachine<E, T>\n {\n-\t// The current list of states that the NFA is in...\n+// The current list of states that the NFA is in... private LinkedList<NfaMatchState<E>> m_clist = new LinkedList<NfaMatchState<E>>();\n+\n \tprivate LinkedList<NfaMatchState<E>> m_clist = new LinkedList<NfaMatchState<E>>();\n \n \tprivate List<E> m_followers;\n",
            "diff_size": 2
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "36",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/117/NfaStepper.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_three_grams/117/NfaStepper.java\nindex 324557cd91c..2e13a18dd60 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/117/NfaStepper.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_three_grams/117/NfaStepper.java\n@@ -30,8 +30,8 @@ import org.genxdm.processor.w3c.xs.regex.api.RegExMachine;\n  */\n final class NfaStepper<E, T> implements RegExMachine<E, T>\n {\n-\t// The current list of states that the NFA is in...\n-\tprivate LinkedList<NfaMatchState<E>> m_clist = new LinkedList<NfaMatchState<E>>();\n+// The current list of states that the NFA is in...\n+ private LinkedList<NfaMatchState<E>> m_clist = new LinkedList<NfaMatchState<E>>();\n \n \tprivate List<E> m_followers;\n \tprivate RegExBridge<E, T> m_bridge;\n",
            "diff_size": 2
        }
    ],
    "repaired_by": [
        "intellij",
        "codebuff"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "styler_random",
        "styler_three_grams"
    ]
}