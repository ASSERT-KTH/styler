{
    "project_name": "CESNET-perun",
    "error_id": "492",
    "information": {
        "errors": [
            {
                "line": "78",
                "severity": "error",
                "message": "Space before tab.",
                "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
            }
        ]
    },
    "source_code": "\t *            true if the cell modifies the selection state\n\t * @param editable\n\t * \t\t\t\ttrue if show enabled checkboxes when core group\n\t */\n\tpublic PerunCheckboxCell(boolean dependsOnSelection, boolean handlesSelection, boolean editable) {\n\t\tsuper(\"change\", \"keydown\");",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "78",
                    "severity": "error",
                    "message": "Space before tab.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/492/PerunCheckboxCell.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/intellij/492/PerunCheckboxCell.java\nindex 80ef928d42b..3785cba166c 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/492/PerunCheckboxCell.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/intellij/492/PerunCheckboxCell.java\n@@ -21,185 +21,181 @@ import cz.metacentrum.perun.webgui.model.*;\n  */\n public class PerunCheckboxCell<T extends JavaScriptObject> extends AbstractEditableCell<T, Boolean> {\n \n-\t/**\n-\t * Whether to show the checkbox, if core group\n-\t */\n-\tprivate boolean editable = false;\n-\n-\t/**\n-\t * An html string representation of a checked input box.\n-\t */\n-\tprivate static final SafeHtml INPUT_CHECKED = SafeHtmlUtils\n-\t\t.fromSafeConstant(\"<input type=\\\"checkbox\\\" tabindex=\\\"-1\\\" checked/>\");\n-\n-\t/**\n-\t * An html string representation of an unchecked input box.\n-\t */\n-\tprivate static final SafeHtml INPUT_UNCHECKED = SafeHtmlUtils\n-\t\t.fromSafeConstant(\"<input type=\\\"checkbox\\\" tabindex=\\\"-1\\\"/>\");\n-\n-\t/**\n-\t * An html string representation of a disabled input box.\n-\t */\n-\tprivate static final SafeHtml INPUT_DISABLED = SafeHtmlUtils\n-\t\t.fromSafeConstant(\"<input type=\\\"checkbox\\\" tabindex=\\\"-1\\\" disabled/>\");\n-\n-\n-\tprivate final boolean dependsOnSelection;\n-\tprivate final boolean handlesSelection;\n-\n-\t/**\n-\t * Construct a new {@link CheckboxCell}.\n-\t */\n-\tpublic PerunCheckboxCell() {\n-\t\tthis(false);\n-\t}\n-\n-\t/**\n-\t * Construct a new {@link CheckboxCell} that optionally controls selection.\n-\t *\n-\t * @param isSelectBox\n-\t *            true if the cell controls the selection state\n-\t * @deprecated use {@link #CheckboxCell(boolean, boolean)} instead\n-\t */\n-\t@Deprecated\n-\tpublic PerunCheckboxCell(boolean isSelectBox) {\n-\t\tthis(isSelectBox, isSelectBox, false);\n-\t}\n-\n-\t/**\n-\t * Construct a new {@link CheckboxCell} that optionally controls selection.\n-\t *\n-\t * @param dependsOnSelection\n-\t *            true if the cell depends on the selection state\n-\t * @param handlesSelection\n-\t *            true if the cell modifies the selection state\n-\t * @param editable\n-\t * \t\t\t\ttrue if show enabled checkboxes when core group\n-\t */\n-\tpublic PerunCheckboxCell(boolean dependsOnSelection, boolean handlesSelection, boolean editable) {\n-\t\tsuper(\"change\", \"keydown\");\n-\t\tthis.dependsOnSelection = dependsOnSelection;\n-\t\tthis.handlesSelection = handlesSelection;\n-\t\tthis.editable = editable;\n-\t}\n-\n-\t@Override\n-\tpublic boolean dependsOnSelection() {\n-\t\treturn dependsOnSelection;\n-\t}\n-\n-\t@Override\n-\tpublic boolean handlesSelection() {\n-\t\treturn handlesSelection;\n-\t}\n-\n-\t@Override\n-\tpublic boolean isEditing(Context context, Element parent, JavaScriptObject value) {\n-\t\t// A checkbox is never in \"edit mode\". There is no intermediate state\n-\t\t// between checked and unchecked.\n-\t\treturn false;\n-\t}\n-\n-\t@Override\n-\tpublic void onBrowserEvent(Context context, Element parent, T value,\n-\t\t\tNativeEvent event, ValueUpdater<T> valueUpdater) {\n-\t\tString type = event.getType();\n-\n-\t\tboolean enterPressed = \"keydown\".equals(type)\n-\t\t\t&& event.getKeyCode() == KeyCodes.KEY_ENTER;\n-\t\tif (\"change\".equals(type) || enterPressed) {\n-\t\t\tInputElement input = parent.getFirstChild().cast();\n-\t\t\tBoolean isChecked = input.isChecked();\n-\n-\t\t\t/*\n-\t\t\t * Toggle the value if the enter key was pressed and the cell\n-\t\t\t * handles selection or doesn't depend on selection. If the cell\n-\t\t\t * depends on selection but doesn't handle selection, then ignore\n-\t\t\t * the enter key and let the SelectionEventManager determine which\n-\t\t\t * keys will trigger a change.\n-\t\t\t */\n-\t\t\tif (enterPressed && (handlesSelection() || !dependsOnSelection())) {\n-\t\t\t\tisChecked = !isChecked;\n-\t\t\t\tinput.setChecked(isChecked);\n-\t\t\t}\n-\n-\t\t\t/*\n-\t\t\t * Save the new value. However, if the cell depends on the\n-\t\t\t * selection, then do not save the value because we can get into an\n-\t\t\t * inconsistent state.\n-\t\t\t */\n-\t\t\tif (((GeneralObject)value).isChecked() != isChecked && !dependsOnSelection()) {\n-\t\t\t\tsetViewData(context.getKey(), isChecked);\n-\t\t\t} else {\n-\t\t\t\tclearViewData(context.getKey());\n-\t\t\t}\n-\n-\t\t\tif (valueUpdater != null) {\n-\t\t\t\t((GeneralObject)value).setChecked(isChecked);\n-\t\t\t\tvalueUpdater.update(value);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void render(Context context, T value, SafeHtmlBuilder sb) {\n-\n-\t\t// Render disabled for different kinds of Types from Perun\n-\n-\t\t// is core group\n-\t\tif (((GeneralObject)value).getObjectType().equalsIgnoreCase(\"Group\") || ((GeneralObject)value).getObjectType().equalsIgnoreCase(\"RichGroup\")) {\n-\t\t\tif(((Group)value).isCoreGroup() && !editable){\n-\t\t\t\tsb.append(INPUT_DISABLED);\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t}\n-\n-\t\t// is service disabled on facility\n-\t\tif (((GeneralObject)value).getObjectType().equalsIgnoreCase(\"ServiceForGUI\")) {\n-\t\t\tif(((RichService)value).getAllowedOnFacility().equalsIgnoreCase(\"Denied\") && !editable){\n-\t\t\t\tsb.append(INPUT_DISABLED);\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t}\n-\n-\t\t// is user ext source persistent\n-\t\tif (((GeneralObject)value).getObjectType().equalsIgnoreCase(\"UserExtSource\")) {\n-\t\t\tif(((UserExtSource)value).isPersistent() && !editable){\n-\t\t\t\tsb.append(INPUT_DISABLED);\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t}\n-\n-\t\t// is service disabled on facility\n-\t\tif (((GeneralObject)value).getObjectType().equalsIgnoreCase(\"RichMember\")) {\n-\t\t\tif(((RichMember)value).getMembershipType().equalsIgnoreCase(\"INDIRECT\") && !editable){\n-\t\t\t\tsb.append(INPUT_DISABLED);\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t}\n-\n-\t\t// attribute is read only (better don't allow selection)\n-\t\tif (((GeneralObject)value).getObjectType().equalsIgnoreCase(\"Attribute\")) {\n-\t\t\tif(((Attribute)value).isWritable() == false){\n-\t\t\t\tsb.append(INPUT_DISABLED);\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t}\n-\n-\t\t// Get the view data.\n-\t\tObject key = context.getKey();\n-\t\tBoolean viewData = getViewData(key);\n-\t\tif (viewData != null && viewData.equals(((GeneralObject)value).isChecked())) {\n-\t\t\tclearViewData(key);\n-\t\t\tviewData = null;\n-\t\t}\n-\n-\t\tif (value != null && ((viewData != null) ? viewData : ((GeneralObject)value).isChecked())) {\n-\t\t\tsb.append(INPUT_CHECKED);\n-\t\t} else {\n-\t\t\tsb.append(INPUT_UNCHECKED);\n-\t\t}\n-\t}\n+    /**\n+     * Whether to show the checkbox, if core group\n+     */\n+    private boolean editable = false;\n+\n+    /**\n+     * An html string representation of a checked input box.\n+     */\n+    private static final SafeHtml INPUT_CHECKED = SafeHtmlUtils\n+            .fromSafeConstant(\"<input type=\\\"checkbox\\\" tabindex=\\\"-1\\\" checked/>\");\n+\n+    /**\n+     * An html string representation of an unchecked input box.\n+     */\n+    private static final SafeHtml INPUT_UNCHECKED = SafeHtmlUtils\n+            .fromSafeConstant(\"<input type=\\\"checkbox\\\" tabindex=\\\"-1\\\"/>\");\n+\n+    /**\n+     * An html string representation of a disabled input box.\n+     */\n+    private static final SafeHtml INPUT_DISABLED = SafeHtmlUtils\n+            .fromSafeConstant(\"<input type=\\\"checkbox\\\" tabindex=\\\"-1\\\" disabled/>\");\n+\n+\n+    private final boolean dependsOnSelection;\n+    private final boolean handlesSelection;\n+\n+    /**\n+     * Construct a new {@link CheckboxCell}.\n+     */\n+    public PerunCheckboxCell() {\n+        this(false);\n+    }\n+\n+    /**\n+     * Construct a new {@link CheckboxCell} that optionally controls selection.\n+     *\n+     * @param isSelectBox true if the cell controls the selection state\n+     * @deprecated use {@link #CheckboxCell(boolean, boolean)} instead\n+     */\n+    @Deprecated\n+    public PerunCheckboxCell(boolean isSelectBox) {\n+        this(isSelectBox, isSelectBox, false);\n+    }\n+\n+    /**\n+     * Construct a new {@link CheckboxCell} that optionally controls selection.\n+     *\n+     * @param dependsOnSelection true if the cell depends on the selection state\n+     * @param handlesSelection   true if the cell modifies the selection state\n+     * @param editable           true if show enabled checkboxes when core group\n+     */\n+    public PerunCheckboxCell(boolean dependsOnSelection, boolean handlesSelection, boolean editable) {\n+        super(\"change\", \"keydown\");\n+        this.dependsOnSelection = dependsOnSelection;\n+        this.handlesSelection = handlesSelection;\n+        this.editable = editable;\n+    }\n+\n+    @Override\n+    public boolean dependsOnSelection() {\n+        return dependsOnSelection;\n+    }\n+\n+    @Override\n+    public boolean handlesSelection() {\n+        return handlesSelection;\n+    }\n+\n+    @Override\n+    public boolean isEditing(Context context, Element parent, JavaScriptObject value) {\n+        // A checkbox is never in \"edit mode\". There is no intermediate state\n+        // between checked and unchecked.\n+        return false;\n+    }\n+\n+    @Override\n+    public void onBrowserEvent(Context context, Element parent, T value,\n+                               NativeEvent event, ValueUpdater<T> valueUpdater) {\n+        String type = event.getType();\n+\n+        boolean enterPressed = \"keydown\".equals(type)\n+                && event.getKeyCode() == KeyCodes.KEY_ENTER;\n+        if (\"change\".equals(type) || enterPressed) {\n+            InputElement input = parent.getFirstChild().cast();\n+            Boolean isChecked = input.isChecked();\n+\n+            /*\n+             * Toggle the value if the enter key was pressed and the cell\n+             * handles selection or doesn't depend on selection. If the cell\n+             * depends on selection but doesn't handle selection, then ignore\n+             * the enter key and let the SelectionEventManager determine which\n+             * keys will trigger a change.\n+             */\n+            if (enterPressed && (handlesSelection() || !dependsOnSelection())) {\n+                isChecked = !isChecked;\n+                input.setChecked(isChecked);\n+            }\n+\n+            /*\n+             * Save the new value. However, if the cell depends on the\n+             * selection, then do not save the value because we can get into an\n+             * inconsistent state.\n+             */\n+            if (((GeneralObject) value).isChecked() != isChecked && !dependsOnSelection()) {\n+                setViewData(context.getKey(), isChecked);\n+            } else {\n+                clearViewData(context.getKey());\n+            }\n+\n+            if (valueUpdater != null) {\n+                ((GeneralObject) value).setChecked(isChecked);\n+                valueUpdater.update(value);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void render(Context context, T value, SafeHtmlBuilder sb) {\n+\n+        // Render disabled for different kinds of Types from Perun\n+\n+        // is core group\n+        if (((GeneralObject) value).getObjectType().equalsIgnoreCase(\"Group\") || ((GeneralObject) value).getObjectType().equalsIgnoreCase(\"RichGroup\")) {\n+            if (((Group) value).isCoreGroup() && !editable) {\n+                sb.append(INPUT_DISABLED);\n+                return;\n+            }\n+        }\n+\n+        // is service disabled on facility\n+        if (((GeneralObject) value).getObjectType().equalsIgnoreCase(\"ServiceForGUI\")) {\n+            if (((RichService) value).getAllowedOnFacility().equalsIgnoreCase(\"Denied\") && !editable) {\n+                sb.append(INPUT_DISABLED);\n+                return;\n+            }\n+        }\n+\n+        // is user ext source persistent\n+        if (((GeneralObject) value).getObjectType().equalsIgnoreCase(\"UserExtSource\")) {\n+            if (((UserExtSource) value).isPersistent() && !editable) {\n+                sb.append(INPUT_DISABLED);\n+                return;\n+            }\n+        }\n+\n+        // is service disabled on facility\n+        if (((GeneralObject) value).getObjectType().equalsIgnoreCase(\"RichMember\")) {\n+            if (((RichMember) value).getMembershipType().equalsIgnoreCase(\"INDIRECT\") && !editable) {\n+                sb.append(INPUT_DISABLED);\n+                return;\n+            }\n+        }\n+\n+        // attribute is read only (better don't allow selection)\n+        if (((GeneralObject) value).getObjectType().equalsIgnoreCase(\"Attribute\")) {\n+            if (((Attribute) value).isWritable() == false) {\n+                sb.append(INPUT_DISABLED);\n+                return;\n+            }\n+        }\n+\n+        // Get the view data.\n+        Object key = context.getKey();\n+        Boolean viewData = getViewData(key);\n+        if (viewData != null && viewData.equals(((GeneralObject) value).isChecked())) {\n+            clearViewData(key);\n+            viewData = null;\n+        }\n+\n+        if (value != null && ((viewData != null) ? viewData : ((GeneralObject) value).isChecked())) {\n+            sb.append(INPUT_CHECKED);\n+        } else {\n+            sb.append(INPUT_UNCHECKED);\n+        }\n+    }\n \n }\n",
            "diff_size": 180
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/492/PerunCheckboxCell.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/codebuff/492/PerunCheckboxCell.java\nindex 80ef928d42b..1edfdf42534 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/492/PerunCheckboxCell.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/codebuff/492/PerunCheckboxCell.java\n@@ -19,187 +19,185 @@ import cz.metacentrum.perun.webgui.model.*;\n  * @author Vaclav Mach <374430@mail.muni.cz>\n  * @author Pavel Zlamal <256627@mail.muni.cz>\n  */\n+\n+\n public class PerunCheckboxCell<T extends JavaScriptObject> extends AbstractEditableCell<T, Boolean> {\n \n-\t/**\n-\t * Whether to show the checkbox, if core group\n-\t */\n-\tprivate boolean editable = false;\n-\n-\t/**\n-\t * An html string representation of a checked input box.\n-\t */\n-\tprivate static final SafeHtml INPUT_CHECKED = SafeHtmlUtils\n-\t\t.fromSafeConstant(\"<input type=\\\"checkbox\\\" tabindex=\\\"-1\\\" checked/>\");\n-\n-\t/**\n-\t * An html string representation of an unchecked input box.\n-\t */\n-\tprivate static final SafeHtml INPUT_UNCHECKED = SafeHtmlUtils\n-\t\t.fromSafeConstant(\"<input type=\\\"checkbox\\\" tabindex=\\\"-1\\\"/>\");\n-\n-\t/**\n-\t * An html string representation of a disabled input box.\n-\t */\n-\tprivate static final SafeHtml INPUT_DISABLED = SafeHtmlUtils\n-\t\t.fromSafeConstant(\"<input type=\\\"checkbox\\\" tabindex=\\\"-1\\\" disabled/>\");\n-\n-\n-\tprivate final boolean dependsOnSelection;\n-\tprivate final boolean handlesSelection;\n-\n-\t/**\n-\t * Construct a new {@link CheckboxCell}.\n-\t */\n-\tpublic PerunCheckboxCell() {\n-\t\tthis(false);\n-\t}\n-\n-\t/**\n-\t * Construct a new {@link CheckboxCell} that optionally controls selection.\n-\t *\n-\t * @param isSelectBox\n-\t *            true if the cell controls the selection state\n-\t * @deprecated use {@link #CheckboxCell(boolean, boolean)} instead\n-\t */\n-\t@Deprecated\n-\tpublic PerunCheckboxCell(boolean isSelectBox) {\n-\t\tthis(isSelectBox, isSelectBox, false);\n-\t}\n-\n-\t/**\n-\t * Construct a new {@link CheckboxCell} that optionally controls selection.\n-\t *\n-\t * @param dependsOnSelection\n-\t *            true if the cell depends on the selection state\n-\t * @param handlesSelection\n-\t *            true if the cell modifies the selection state\n-\t * @param editable\n-\t * \t\t\t\ttrue if show enabled checkboxes when core group\n-\t */\n-\tpublic PerunCheckboxCell(boolean dependsOnSelection, boolean handlesSelection, boolean editable) {\n-\t\tsuper(\"change\", \"keydown\");\n-\t\tthis.dependsOnSelection = dependsOnSelection;\n-\t\tthis.handlesSelection = handlesSelection;\n-\t\tthis.editable = editable;\n-\t}\n-\n-\t@Override\n-\tpublic boolean dependsOnSelection() {\n-\t\treturn dependsOnSelection;\n-\t}\n-\n-\t@Override\n-\tpublic boolean handlesSelection() {\n-\t\treturn handlesSelection;\n-\t}\n-\n-\t@Override\n-\tpublic boolean isEditing(Context context, Element parent, JavaScriptObject value) {\n-\t\t// A checkbox is never in \"edit mode\". There is no intermediate state\n-\t\t// between checked and unchecked.\n-\t\treturn false;\n-\t}\n-\n-\t@Override\n-\tpublic void onBrowserEvent(Context context, Element parent, T value,\n-\t\t\tNativeEvent event, ValueUpdater<T> valueUpdater) {\n-\t\tString type = event.getType();\n-\n-\t\tboolean enterPressed = \"keydown\".equals(type)\n-\t\t\t&& event.getKeyCode() == KeyCodes.KEY_ENTER;\n-\t\tif (\"change\".equals(type) || enterPressed) {\n-\t\t\tInputElement input = parent.getFirstChild().cast();\n-\t\t\tBoolean isChecked = input.isChecked();\n-\n-\t\t\t/*\n-\t\t\t * Toggle the value if the enter key was pressed and the cell\n-\t\t\t * handles selection or doesn't depend on selection. If the cell\n-\t\t\t * depends on selection but doesn't handle selection, then ignore\n-\t\t\t * the enter key and let the SelectionEventManager determine which\n-\t\t\t * keys will trigger a change.\n-\t\t\t */\n-\t\t\tif (enterPressed && (handlesSelection() || !dependsOnSelection())) {\n-\t\t\t\tisChecked = !isChecked;\n-\t\t\t\tinput.setChecked(isChecked);\n-\t\t\t}\n-\n-\t\t\t/*\n-\t\t\t * Save the new value. However, if the cell depends on the\n-\t\t\t * selection, then do not save the value because we can get into an\n-\t\t\t * inconsistent state.\n-\t\t\t */\n-\t\t\tif (((GeneralObject)value).isChecked() != isChecked && !dependsOnSelection()) {\n-\t\t\t\tsetViewData(context.getKey(), isChecked);\n-\t\t\t} else {\n-\t\t\t\tclearViewData(context.getKey());\n-\t\t\t}\n-\n-\t\t\tif (valueUpdater != null) {\n-\t\t\t\t((GeneralObject)value).setChecked(isChecked);\n-\t\t\t\tvalueUpdater.update(value);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void render(Context context, T value, SafeHtmlBuilder sb) {\n-\n-\t\t// Render disabled for different kinds of Types from Perun\n-\n-\t\t// is core group\n-\t\tif (((GeneralObject)value).getObjectType().equalsIgnoreCase(\"Group\") || ((GeneralObject)value).getObjectType().equalsIgnoreCase(\"RichGroup\")) {\n-\t\t\tif(((Group)value).isCoreGroup() && !editable){\n-\t\t\t\tsb.append(INPUT_DISABLED);\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t}\n-\n-\t\t// is service disabled on facility\n-\t\tif (((GeneralObject)value).getObjectType().equalsIgnoreCase(\"ServiceForGUI\")) {\n-\t\t\tif(((RichService)value).getAllowedOnFacility().equalsIgnoreCase(\"Denied\") && !editable){\n-\t\t\t\tsb.append(INPUT_DISABLED);\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t}\n-\n-\t\t// is user ext source persistent\n-\t\tif (((GeneralObject)value).getObjectType().equalsIgnoreCase(\"UserExtSource\")) {\n-\t\t\tif(((UserExtSource)value).isPersistent() && !editable){\n-\t\t\t\tsb.append(INPUT_DISABLED);\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t}\n-\n-\t\t// is service disabled on facility\n-\t\tif (((GeneralObject)value).getObjectType().equalsIgnoreCase(\"RichMember\")) {\n-\t\t\tif(((RichMember)value).getMembershipType().equalsIgnoreCase(\"INDIRECT\") && !editable){\n-\t\t\t\tsb.append(INPUT_DISABLED);\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t}\n-\n-\t\t// attribute is read only (better don't allow selection)\n-\t\tif (((GeneralObject)value).getObjectType().equalsIgnoreCase(\"Attribute\")) {\n-\t\t\tif(((Attribute)value).isWritable() == false){\n-\t\t\t\tsb.append(INPUT_DISABLED);\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t}\n-\n-\t\t// Get the view data.\n-\t\tObject key = context.getKey();\n-\t\tBoolean viewData = getViewData(key);\n-\t\tif (viewData != null && viewData.equals(((GeneralObject)value).isChecked())) {\n-\t\t\tclearViewData(key);\n-\t\t\tviewData = null;\n-\t\t}\n-\n-\t\tif (value != null && ((viewData != null) ? viewData : ((GeneralObject)value).isChecked())) {\n-\t\t\tsb.append(INPUT_CHECKED);\n-\t\t} else {\n-\t\t\tsb.append(INPUT_UNCHECKED);\n-\t\t}\n-\t}\n-\n-}\n+ /**\n+  * Whether to show the checkbox, if core group\n+  */\n+\n+\n+ private boolean editable = false;\n+\n+ /**\n+  * An html string representation of a checked input box.\n+  */\n+ private static final SafeHtml INPUT_CHECKED = SafeHtmlUtils.fromSafeConstant(\"<input type=\\\"checkbox\\\" tabindex=\\\"-1\\\" checked/>\");\n+\n+ /**\n+  * An html string representation of an unchecked input box.\n+  */\n+ private static final SafeHtml INPUT_UNCHECKED = SafeHtmlUtils.fromSafeConstant(\"<input type=\\\"checkbox\\\" tabindex=\\\"-1\\\"/>\");\n+\n+ /**\n+  * An html string representation of a disabled input box.\n+  */\n+ private static final SafeHtml INPUT_DISABLED = SafeHtmlUtils.fromSafeConstant(\"<input type=\\\"checkbox\\\" tabindex=\\\"-1\\\" disabled/>\");\n+ private final boolean dependsOnSelection;\n+ private final boolean handlesSelection;\n+\n+ /**\n+  * Construct a new {@link CheckboxCell}.\n+  */\n+\n+\n+ public PerunCheckboxCell() {\n+  this(false);\n+ }\n+\n+ /**\n+  * Construct a new {@link CheckboxCell} that optionally controls selection.\n+  *\n+  * @param isSelectBox\n+  *            true if the cell controls the selection state\n+  * @deprecated use {@link #CheckboxCell(boolean, boolean)} instead\n+  */\n+\n+ @Deprecated\n+ public PerunCheckboxCell(boolean isSelectBox) {\n+  this(isSelectBox, isSelectBox, false);\n+ }\n+\n+ /**\n+  * Construct a new {@link CheckboxCell} that optionally controls selection.\n+  *\n+  * @param dependsOnSelection\n+  *            true if the cell depends on the selection state\n+  * @param handlesSelection\n+  *            true if the cell modifies the selection state\n+  * @param editable\n+  *     true if show enabled checkboxes when core group\n+  */\n+\n+ public PerunCheckboxCell(boolean dependsOnSelection, boolean handlesSelection, boolean editable) {\n+  super(\"change\", \"keydown\");\n+  this.dependsOnSelection = dependsOnSelection;\n+  this.handlesSelection = handlesSelection;\n+  this.editable = editable;\n+ }\n+\n+ @Override\n+ public boolean dependsOnSelection() {\n+  return dependsOnSelection;\n+ }\n+\n+ @Override\n+ public boolean handlesSelection() {\n+  return handlesSelection;\n+ }\n+\n+ @Override\n+ public boolean isEditing(Context context, Element parent, JavaScriptObject value) {\n+  // A checkbox is never in \"edit mode\". There is no intermediate state\n+  // between checked and unchecked.\n+  return false;\n+ }\n+\n+ @Override\n+ public void onBrowserEvent(Context context, Element parent, T value, NativeEvent event, ValueUpdater<T> valueUpdater) {\n+  String type = event.getType();\n+  boolean enterPressed = \"keydown\".equals(type) && event.getKeyCode() == KeyCodes.KEY_ENTER;\n+  if (\"change\".equals(type) || enterPressed) {\n+   InputElement input = parent.getFirstChild().cast();\n+   Boolean isChecked = input.isChecked();\n+\n+   /*\n+    * Toggle the value if the enter key was pressed and the cell\n+    * handles selection or doesn't depend on selection. If the cell\n+    * depends on selection but doesn't handle selection, then ignore\n+    * the enter key and let the SelectionEventManager determine which\n+    * keys will trigger a change.\n+    */\n+   if (enterPressed && (handlesSelection() || !dependsOnSelection())) {\n+    isChecked = !isChecked;\n+    input.setChecked(isChecked);\n+   }\n+\n+   /*\n+    * Save the new value. However, if the cell depends on the\n+    * selection, then do not save the value because we can get into an\n+    * inconsistent state.\n+    */\n+   if (((GeneralObject) value).isChecked() != isChecked && !dependsOnSelection()) {\n+    setViewData(context.getKey(), isChecked);\n+   } else {\n+    clearViewData(context.getKey());\n+   }\n+   if (valueUpdater != null) {\n+    ((GeneralObject) value).setChecked(isChecked);\n+    valueUpdater.update(value);\n+   }\n+  }\n+ }\n+\n+ @Override\n+ public void render(Context context, T value, SafeHtmlBuilder sb) {\n+\n+  // Render disabled for different kinds of Types from Perun\n+\n+  // is core group\n+  if (((GeneralObject) value).getObjectType().equalsIgnoreCase(\"Group\") || ((GeneralObject) value).getObjectType().equalsIgnoreCase(\"RichGroup\")) {\n+   if (((Group) value).isCoreGroup() && !editable) {\n+    sb.append(INPUT_DISABLED);\n+    return;\n+   }\n+  }\n+\n+  // is service disabled on facility\n+  if (((GeneralObject) value).getObjectType().equalsIgnoreCase(\"ServiceForGUI\")) {\n+   if (((RichService) value).getAllowedOnFacility().equalsIgnoreCase(\"Denied\") && !editable) {\n+    sb.append(INPUT_DISABLED);\n+    return;\n+   }\n+  }\n+\n+  // is user ext source persistent\n+  if (((GeneralObject) value).getObjectType().equalsIgnoreCase(\"UserExtSource\")) {\n+   if (((UserExtSource) value).isPersistent() && !editable) {\n+    sb.append(INPUT_DISABLED);\n+    return;\n+   }\n+  }\n+\n+  // is service disabled on facility\n+  if (((GeneralObject) value).getObjectType().equalsIgnoreCase(\"RichMember\")) {\n+   if (((RichMember) value).getMembershipType().equalsIgnoreCase(\"INDIRECT\") && !editable) {\n+    sb.append(INPUT_DISABLED);\n+    return;\n+   }\n+  }\n+\n+  // attribute is read only (better don't allow selection)\n+  if (((GeneralObject) value).getObjectType().equalsIgnoreCase(\"Attribute\")) {\n+   if (((Attribute) value).isWritable() == false) {\n+    sb.append(INPUT_DISABLED);\n+    return;\n+   }\n+  }\n+\n+  // Get the view data.\n+  Object key = context.getKey();\n+  Boolean viewData = getViewData(key);\n+  if (viewData != null && viewData.equals(((GeneralObject) value).isChecked())) {\n+   clearViewData(key);\n+   viewData = null;\n+  }\n+  if (value != null && ((viewData != null) ? viewData : ((GeneralObject) value).isChecked())) {\n+   sb.append(INPUT_CHECKED);\n+  } else {\n+   sb.append(INPUT_UNCHECKED);\n+  }\n+ }\n+\n+}\n\\ No newline at end of file\n",
            "diff_size": 184
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "78",
                    "severity": "error",
                    "message": "Space before tab.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "78",
                    "severity": "error",
                    "message": "Space before tab.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ],
    "repaired_by": [
        "intellij",
        "codebuff"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "styler_random",
        "styler_three_grams"
    ]
}