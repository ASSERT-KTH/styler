{
    "project_name": "IQSS-dataverse",
    "error_id": "13",
    "information": {
        "errors": [
            {
                "line": "140",
                "column": "1",
                "severity": "error",
                "message": "File contains tab characters (this is the first instance).",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
            }
        ]
    },
    "source_code": "    \n    public String getCachedRworkSpace(){\n\treturn this.savedRworkSpace; \n    }\n\n",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/13/RJobRequest.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler/13/RJobRequest.java\nindex 9171b8313ff..aaa6f114f2c 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/13/RJobRequest.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler/13/RJobRequest.java\n@@ -137,7 +137,7 @@ public class RJobRequest {\n     }\n     \n     public String getCachedRworkSpace(){\n-\treturn this.savedRworkSpace; \n+        return this.savedRworkSpace; \n     }\n \n \n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/13/RJobRequest.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/intellij/13/RJobRequest.java\nindex 9171b8313ff..53f1a46b196 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/13/RJobRequest.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/intellij/13/RJobRequest.java\n@@ -17,13 +17,16 @@\n    Developed at the Institute for Quantitative Social Science, Harvard University.\n    Version 3.0.\n */\n+\n package edu.harvard.iq.dataverse.rserve;\n \n /**\n  * original\n+ *\n  * @author Akio Sone (DVN 2.*)\n  * @author Leonid Andreev\n  */\n+\n import edu.harvard.iq.dataverse.datavariable.DataVariable;\n \n import java.util.ArrayList;\n@@ -38,379 +41,374 @@ import org.apache.commons.lang3.StringUtils;\n \n public class RJobRequest {\n \n-    private static final Logger dbgLog = Logger.getLogger(RJobRequest.class.getCanonicalName());\n+  private static final Logger dbgLog = Logger.getLogger(RJobRequest.class.getCanonicalName());\n \n \n-    private Map<String,String> variableFormats = new HashMap<>(); \n-    \n-    /**\n-     * 4 parameter Constructor:\n-     * @param dv\n-     * @param vts\n-     * @param categoryOrders\n-     */\n-    public RJobRequest(\n-            List <DataVariable> dv, \n-            Map <String, Map<String, String>> vts,\n-            Map <String, List<String>> categoryOrders\n-            ) {\n-        dataVariablesForRequest = dv;\n-                \n-        valueTables = vts;\n-        categoryValueOrders=categoryOrders;\n-        dbgLog.fine(\"***** DvnRJobRequest: within the default constructor : initial *****\");\n-        dbgLog.fine(\"DvnRJobRequest: variables=\"+dataVariablesForRequest);\n-        dbgLog.fine(\"DvnRJobRequest: value table=\"+valueTables);\n-        dbgLog.fine(\"DvnRJobRequest: category value orders=\"+categoryValueOrders);\n-        \n-        \n-        checkVariableNames();\n-        \n-        dbgLog.fine(\"***** DvnRJobRequest: within the default constructor ends here *****\");\n-    }\n+  private Map<String, String> variableFormats = new HashMap<>();\n \n-    \n-    public RJobRequest(\n-            List<DataVariable> dv, \n-            Map <String, Map <String, String>> vts\n-            ) {\n-      this(dv,vts,null);\n-    }\n+  /**\n+   * 4 parameter Constructor:\n+   * @param dv\n+   * @param vts\n+   * @param categoryOrders\n+   */\n+  public RJobRequest(\n+    List<DataVariable> dv,\n+    Map<String, Map<String, String>> vts,\n+    Map<String, List<String>> categoryOrders\n+  ) {\n+    dataVariablesForRequest = dv;\n \n-    \n+    valueTables = vts;\n+    categoryValueOrders = categoryOrders;\n+    dbgLog.fine(\"***** DvnRJobRequest: within the default constructor : initial *****\");\n+    dbgLog.fine(\"DvnRJobRequest: variables=\" + dataVariablesForRequest);\n+    dbgLog.fine(\"DvnRJobRequest: value table=\" + valueTables);\n+    dbgLog.fine(\"DvnRJobRequest: category value orders=\" + categoryValueOrders);\n \n-    private List<DataVariable> dataVariablesForRequest;\n \n-    private String tabularDataFileName; \n-    \n-    private String requestType;\n-    // Note: the only \"request type\" supported in 4.0 (as of currently\n-    // planned is \"convert\" - for converting tab files to data frames)\n-    \n-    private String formatRequested; \n-    // Again, the plan is have \"RData\" as the only format supported; \n-    // but we'll keep the mechanism in place for supporting multiple formats. \n-    \n-    // R work space, saved and cached on the Application side\n-    private String savedRworkSpace;\n-    \n-    private Map<String, Map<String, String>> valueTables;\n-    \n-    /** list-type (one-to-many) parameter */\n-    private Map<String, List<String>> categoryValueOrders;\n-    \n-    public String[] safeVarNames = null;\n-    public String[] renamedVariableArray=null;\n-    public String[] renamedResultArray=null;\n-    public Map<String, String> raw2safeTable = null;\n-    \n-    public Map<String, String> safe2rawTable = null;\n+    checkVariableNames();\n \n-    public boolean hasUnsafeVariableNames = false;\n-    \n-    public void setRequestType (String requestType) {\n-        this.requestType = requestType; \n-    }\n-    \n-    public String getRequestType() {\n-        return this.requestType;\n-    }\n+    dbgLog.fine(\"***** DvnRJobRequest: within the default constructor ends here *****\");\n+  }\n \n-    public void setFormatRequested (String formatRequested) {\n-        this.formatRequested = formatRequested; \n-    }\n-    \n-    public String getFormatRequested() {\n-        return this.formatRequested;\n-    }\n-    \n-    public void setTabularDataFileName(String tabularDataFileName) {\n-        this.tabularDataFileName = tabularDataFileName;\n-    }\n-    \n-    public String getTabularDataFileName() {\n-        return this.tabularDataFileName;\n-    }\n-    \n-    public List<DataVariable> getDataVariablesForRequest(){\n-        return this.dataVariablesForRequest;\n-    }\n-    \n-    public String getCachedRworkSpace(){\n-\treturn this.savedRworkSpace; \n-    }\n \n+  public RJobRequest(\n+    List<DataVariable> dv,\n+    Map<String, Map<String, String>> vts\n+  ) {\n+    this(dv, vts, null);\n+  }\n \n-    /**\n-     * getVariableTypes()\n-     * @return    An array of variable types(0, 1, 2, 3)\n-     * (3 is for Boolean)\n-     */\n-    public int[] getVariableTypes() {\n-        List<Integer> rw = new ArrayList<>();\n-        for (DataVariable dv : dataVariablesForRequest) {\n-            if (!StringUtils.isEmpty(dv.getFormatCategory())){\n-                if (dv.getFormatCategory().toLowerCase().equals(\"date\") ||\n-                        (dv.getFormatCategory().toLowerCase().equals(\"time\"))){\n-                    rw.add(0);\n-                    continue;\n-                } else if (dv.getFormatCategory().equals(\"Boolean\")) {\n-                    rw.add(3); \n-                    continue;\n-                }\n-            }\n-            \n-            if (dv.isTypeNumeric()) {\n-                if (dv.getInterval() == null || dv.isIntervalContinuous()) {\n-                    rw.add(2);\n-                } else {\n-                    rw.add(1);\n-                }\n-            } else if (dv.isTypeCharacter()) {\n-                rw.add(0);\n-            }\n+\n+  private List<DataVariable> dataVariablesForRequest;\n+\n+  private String tabularDataFileName;\n+\n+  private String requestType;\n+  // Note: the only \"request type\" supported in 4.0 (as of currently\n+  // planned is \"convert\" - for converting tab files to data frames)\n+\n+  private String formatRequested;\n+  // Again, the plan is have \"RData\" as the only format supported;\n+  // but we'll keep the mechanism in place for supporting multiple formats.\n+\n+  // R work space, saved and cached on the Application side\n+  private String savedRworkSpace;\n+\n+  private Map<String, Map<String, String>> valueTables;\n+\n+  /** list-type (one-to-many) parameter */\n+  private Map<String, List<String>> categoryValueOrders;\n+\n+  public String[] safeVarNames = null;\n+  public String[] renamedVariableArray = null;\n+  public String[] renamedResultArray = null;\n+  public Map<String, String> raw2safeTable = null;\n+\n+  public Map<String, String> safe2rawTable = null;\n+\n+  public boolean hasUnsafeVariableNames = false;\n+\n+  public void setRequestType(String requestType) {\n+    this.requestType = requestType;\n+  }\n+\n+  public String getRequestType() {\n+    return this.requestType;\n+  }\n+\n+  public void setFormatRequested(String formatRequested) {\n+    this.formatRequested = formatRequested;\n+  }\n+\n+  public String getFormatRequested() {\n+    return this.formatRequested;\n+  }\n+\n+  public void setTabularDataFileName(String tabularDataFileName) {\n+    this.tabularDataFileName = tabularDataFileName;\n+  }\n+\n+  public String getTabularDataFileName() {\n+    return this.tabularDataFileName;\n+  }\n+\n+  public List<DataVariable> getDataVariablesForRequest() {\n+    return this.dataVariablesForRequest;\n+  }\n+\n+  public String getCachedRworkSpace() {\n+    return this.savedRworkSpace;\n+  }\n+\n+\n+  /**\n+   * getVariableTypes()\n+   * @return An array of variable types(0, 1, 2, 3)\n+   * (3 is for Boolean)\n+   */\n+  public int[] getVariableTypes() {\n+    List<Integer> rw = new ArrayList<>();\n+    for (DataVariable dv : dataVariablesForRequest) {\n+      if (!StringUtils.isEmpty(dv.getFormatCategory())) {\n+        if (dv.getFormatCategory().toLowerCase().equals(\"date\") ||\n+          (dv.getFormatCategory().toLowerCase().equals(\"time\"))) {\n+          rw.add(0);\n+          continue;\n+        } else if (dv.getFormatCategory().equals(\"Boolean\")) {\n+          rw.add(3);\n+          continue;\n         }\n-        int[] variableTypes = new int[rw.size()];\n-        for (int j=0; j<rw.size(); j++){\n-            variableTypes[j] = rw.get(j);\n+      }\n+\n+      if (dv.isTypeNumeric()) {\n+        if (dv.getInterval() == null || dv.isIntervalContinuous()) {\n+          rw.add(2);\n+        } else {\n+          rw.add(1);\n         }\n-        return variableTypes;\n+      } else if (dv.isTypeCharacter()) {\n+        rw.add(0);\n+      }\n     }\n+    int[] variableTypes = new int[rw.size()];\n+    for (int j = 0; j < rw.size(); j++) {\n+      variableTypes[j] = rw.get(j);\n+    }\n+    return variableTypes;\n+  }\n+\n+  /**\n+   * Getter for property variable formats\n+   *\n+   * @return A Map that maps a format to\n+   *            its corresponding type, either time or date\n+   */\n+  public Map<String, String> getVariableFormats() {\n+    Map<String, String> variableFormats = new LinkedHashMap<>();\n+    for (int i = 0; i < dataVariablesForRequest.size(); i++) {\n+      DataVariable dv = dataVariablesForRequest.get(i);\n+\n+      //dbgLog.fine(String.format(\"DvnRJobRequest: column[%d] schema = %s\", i, dv.getFormatSchema()));\n+      dbgLog.fine(String.format(\"DvnRJobRequest: column[%d] category = %s\", i, dv.getFormatCategory()));\n+\n+      //experiment dbgLog.fine(i+\"-th \\tformatschema=\"+dv.getFormatSchema());\n+      dbgLog.fine(i + \"-th \\tformatcategory=\" + dv.getFormatCategory());\n+\n+      // TODO:\n+      // clean this up! -- L.A. 4.0 beta15\n \n-    /**\n-     * Getter for property variable formats\n-     *\n-     * @return    A Map that maps a format to\n-     *            its corresponding type, either time or date\n-     */\n-    public Map<String, String> getVariableFormats() {\n-        Map<String, String> variableFormats = new LinkedHashMap<>();\n-        for(int i=0;i < dataVariablesForRequest.size(); i++){\n-            DataVariable dv = dataVariablesForRequest.get(i);\n-\n-            //dbgLog.fine(String.format(\"DvnRJobRequest: column[%d] schema = %s\", i, dv.getFormatSchema()));\n-            dbgLog.fine(String.format(\"DvnRJobRequest: column[%d] category = %s\", i, dv.getFormatCategory()));\n-            \n-            //experiment dbgLog.fine(i+\"-th \\tformatschema=\"+dv.getFormatSchema());\n-            dbgLog.fine(i+\"-th \\tformatcategory=\"+dv.getFormatCategory());\n-            \n-            // TODO: \n-            // clean this up! -- L.A. 4.0 beta15\n-            \n-            if (!StringUtils.isEmpty(dv.getFormatCategory())) {\n-                //if (dv.getFormatSchema().toLowerCase().equals(\"spss\")){\n-                if (dv.getDataTable().getOriginalFileFormat().toLowerCase().startsWith(\"application/x-spss\")) {\n-                    if (dv.getFormatCategory().toLowerCase().equals(\"date\")){\n-                        // add this var to this map value D\n-                        // (but only if it's a full date format! - partial dates, like \"year only\" \n-                        // are not going to be treated as dates)\n-                        if (\"yyyy-MM-dd\".equals(dv.getFormat())) {\n-                            variableFormats.put(getSafeVariableName(dv.getName()), \"D\");\n-                        }\n-                    } else if (dv.getFormatCategory().toLowerCase().equals(\"time\")){\n-                        // add this var to this map\n-                        if ( dv.getFormatCategory().toLowerCase().startsWith(\"dtime\")){\n-                            // value JT\n-                            variableFormats.put(getSafeVariableName(dv.getName()), \"JT\");\n-                            \n-                        } else if ( dv.getFormatCategory().toLowerCase().startsWith(\"datetime\")){\n-                            // value DT\n-                            variableFormats.put(getSafeVariableName(dv.getName()), \"DT\");\n-                        } else {\n-                            // value T\n-                            variableFormats.put(getSafeVariableName(dv.getName()), \"T\");\n-                        }\n-                    }\n-                }\n-                //else if (dv.getFormatSchema().toLowerCase().equals(\"rdata\")) {\n-                else if (dv.getDataTable().getOriginalFileFormat().toLowerCase().startsWith(\"application/x-rlang-transport\")) { // TODO: double-check that this is what we save for the original format!!\n-                  if (dv.getFormatCategory().toLowerCase().equals(\"date\")) {\n-                      // (but only if it's a full date format! - partial dates, like \"year only\" \n-                      // are not going to be treated as dates)\n-                      if (\"yyyy-MM-dd\".equals(dv.getFormat())) {\n-                        variableFormats.put(getSafeVariableName(dv.getName()), \"D\");\n-                      }\n-                  }\n-                  else if (dv.getFormatCategory().toLowerCase().equals(\"time\")) {\n-                    // add this var to this map\n-                    if ( dv.getFormatCategory().toLowerCase().startsWith(\"dtime\")){\n-                      // value JT\n-                      variableFormats.put(getSafeVariableName(dv.getName()), \"JT\");\n-                    }\n-                    else if (dv.getFormatCategory().toLowerCase().startsWith(\"datetime\")) {\n-                      // Set as date-time-timezone, DT\n-                      variableFormats.put(getSafeVariableName(dv.getName()), \"DT\");\n-                    }\n-                    else if (dv.getFormatCategory().toLowerCase().startsWith(\"time\")) {\n-                      // Set as date-time-timezone, DT\n-                      variableFormats.put(getSafeVariableName(dv.getName()), \"DT\");\n-                    }\n-                    else {\n-                      // value T\n-                      variableFormats.put(getSafeVariableName(dv.getName()), \"T\");\n-                    }\n-                  }\n-                }\n-                else /* if (dv.getFormatSchema().toLowerCase().equals(\"other\")) ?? */{\n-                  if (dv.getFormatCategory().toLowerCase().equals(\"date\")) {\n-                    // value = D\n-                    // (but only if it's a full date format! - partial dates, like \"year only\" \n-                    // are not going to be treated as dates)\n-                    if (\"yyyy-MM-dd\".equals(dv.getFormat())) {\n-                        variableFormats.put(getSafeVariableName(dv.getName()), \"D\");\n-                    }\n-                  }\n-                }\n-                // TODO: (?)\n-                // What about STATA? -- L.A.\n+      if (!StringUtils.isEmpty(dv.getFormatCategory())) {\n+        //if (dv.getFormatSchema().toLowerCase().equals(\"spss\")){\n+        if (dv.getDataTable().getOriginalFileFormat().toLowerCase().startsWith(\"application/x-spss\")) {\n+          if (dv.getFormatCategory().toLowerCase().equals(\"date\")) {\n+            // add this var to this map value D\n+            // (but only if it's a full date format! - partial dates, like \"year only\"\n+            // are not going to be treated as dates)\n+            if (\"yyyy-MM-dd\".equals(dv.getFormat())) {\n+              variableFormats.put(getSafeVariableName(dv.getName()), \"D\");\n+            }\n+          } else if (dv.getFormatCategory().toLowerCase().equals(\"time\")) {\n+            // add this var to this map\n+            if (dv.getFormatCategory().toLowerCase().startsWith(\"dtime\")) {\n+              // value JT\n+              variableFormats.put(getSafeVariableName(dv.getName()), \"JT\");\n+\n+            } else if (dv.getFormatCategory().toLowerCase().startsWith(\"datetime\")) {\n+              // value DT\n+              variableFormats.put(getSafeVariableName(dv.getName()), \"DT\");\n             } else {\n-                dbgLog.fine(i+\"\\t var: not date or time variable\");\n+              // value T\n+              variableFormats.put(getSafeVariableName(dv.getName()), \"T\");\n             }\n+          }\n         }\n-        dbgLog.fine(\"format=\"+variableFormats);\n-        return variableFormats;\n-    }\n-        \n-    private String getSafeVariableName(String raw){\n-        String safe =null;\n-        if ((raw2safeTable == null) || (raw2safeTable.isEmpty())) {\n-            // use raw\n-            dbgLog.fine(\"no unsafe variables\");\n-            safe = raw;\n-        } else {\n-            // check this var is unsafe\n-            \n-            if (raw2safeTable.containsKey(raw)){\n-                dbgLog.fine(\"this var is unsafe=\"+raw);\n-                safe = raw2safeTable.get(raw);\n-                dbgLog.fine(\"safe var is:\"+ safe);\n+        //else if (dv.getFormatSchema().toLowerCase().equals(\"rdata\")) {\n+        else if (dv.getDataTable().getOriginalFileFormat().toLowerCase().startsWith(\n+          \"application/x-rlang-transport\")) { // TODO: double-check that this is what we save for the original format!!\n+          if (dv.getFormatCategory().toLowerCase().equals(\"date\")) {\n+            // (but only if it's a full date format! - partial dates, like \"year only\"\n+            // are not going to be treated as dates)\n+            if (\"yyyy-MM-dd\".equals(dv.getFormat())) {\n+              variableFormats.put(getSafeVariableName(dv.getName()), \"D\");\n+            }\n+          } else if (dv.getFormatCategory().toLowerCase().equals(\"time\")) {\n+            // add this var to this map\n+            if (dv.getFormatCategory().toLowerCase().startsWith(\"dtime\")) {\n+              // value JT\n+              variableFormats.put(getSafeVariableName(dv.getName()), \"JT\");\n+            } else if (dv.getFormatCategory().toLowerCase().startsWith(\"datetime\")) {\n+              // Set as date-time-timezone, DT\n+              variableFormats.put(getSafeVariableName(dv.getName()), \"DT\");\n+            } else if (dv.getFormatCategory().toLowerCase().startsWith(\"time\")) {\n+              // Set as date-time-timezone, DT\n+              variableFormats.put(getSafeVariableName(dv.getName()), \"DT\");\n             } else {\n-                dbgLog.fine(\"not on the unsafe list\");\n-                safe = raw;\n+              // value T\n+              variableFormats.put(getSafeVariableName(dv.getName()), \"T\");\n             }\n+          }\n+        } else /* if (dv.getFormatSchema().toLowerCase().equals(\"other\")) ?? */ {\n+          if (dv.getFormatCategory().toLowerCase().equals(\"date\")) {\n+            // value = D\n+            // (but only if it's a full date format! - partial dates, like \"year only\"\n+            // are not going to be treated as dates)\n+            if (\"yyyy-MM-dd\".equals(dv.getFormat())) {\n+              variableFormats.put(getSafeVariableName(dv.getName()), \"D\");\n+            }\n+          }\n         }\n-        return safe;\n-    }\n-    \n-    public String[] getVariableNames() {\n-        String[] variableNames=null;\n-        \n-        List<String> rw = new ArrayList<>();\n-        for (DataVariable dv : dataVariablesForRequest) {\n-            rw.add(dv.getName());\n-        }\n-        \n-        variableNames = rw.toArray(new String[rw.size()]);\n-        return variableNames;\n-    }\n-    \n-    /**\n-     * Getter for property raw-to-safe-variable-name list\n-     * @return    A Map that maps an unsafe variable name to \n-     *            a safe one\n-     */\n-    public Map<String, String> getRaw2SafeVarNameTable(){\n-        return raw2safeTable;\n+        // TODO: (?)\n+        // What about STATA? -- L.A.\n+      } else {\n+        dbgLog.fine(i + \"\\t var: not date or time variable\");\n+      }\n     }\n+    dbgLog.fine(\"format=\" + variableFormats);\n+    return variableFormats;\n+  }\n \n-    public void checkVariableNames(){\n-        \n-        VariableNameCheckerForR nf = new VariableNameCheckerForR(getVariableNames());\n-        if (nf.hasRenamedVariables()){\n-             safeVarNames  = nf.getFilteredVarNames();\n-             hasUnsafeVariableNames = true;\n-        }\n-        \n-        raw2safeTable = nf.getRaw2safeTable();\n-        safe2rawTable = nf.getSafe2rawTable();\n-        renamedVariableArray = nf.getRenamedVariableArray();\n-        renamedResultArray   = nf.getRenamedResultArray();\n+  private String getSafeVariableName(String raw) {\n+    String safe = null;\n+    if ((raw2safeTable == null) || (raw2safeTable.isEmpty())) {\n+      // use raw\n+      dbgLog.fine(\"no unsafe variables\");\n+      safe = raw;\n+    } else {\n+      // check this var is unsafe\n+\n+      if (raw2safeTable.containsKey(raw)) {\n+        dbgLog.fine(\"this var is unsafe=\" + raw);\n+        safe = raw2safeTable.get(raw);\n+        dbgLog.fine(\"safe var is:\" + safe);\n+      } else {\n+        dbgLog.fine(\"not on the unsafe list\");\n+        safe = raw;\n+      }\n     }\n-    \n-    public List<String> getFilteredVarNameSet(List<String> varIdSet){\n-        List<String> varNameSet = new ArrayList<>();\n-        for (String vid : varIdSet){\n-            dbgLog.fine(\"name list: vid=\"+vid);\n-            String raw = getVarIdToRawVarNameTable().get(vid);\n-            if (raw != null){\n-                dbgLog.fine(\"raw is not null case=\"+raw);\n-                if (raw2safeTable.containsKey(raw)){\n-                    dbgLog.fine(\"raw is unsafe case\");\n-                    varNameSet.add(raw2safeTable.get(raw));\n-                } else {\n-                    dbgLog.fine(\"raw is safe case\");\n-                    varNameSet.add(raw);\n-                }\n-            } else {\n-                dbgLog.fine(\"raw is null-case\");\n-            }\n-        }\n-        dbgLog.fine(\"varNameSet=\"+varNameSet);\n-        return varNameSet;\n+    return safe;\n+  }\n+\n+  public String[] getVariableNames() {\n+    String[] variableNames = null;\n+\n+    List<String> rw = new ArrayList<>();\n+    for (DataVariable dv : dataVariablesForRequest) {\n+      rw.add(dv.getName());\n     }\n-    \n-    public String[] getVariableIds(){\n-        String[] variableIds=null;\n-        List<String> rw = new ArrayList<>();\n-        for (DataVariable dv : dataVariablesForRequest) {\n-            rw.add(\"v\"+dv.getId().toString());\n-        }\n-        \n-        variableIds = rw.toArray(new String[rw.size()]);\n-        return variableIds;\n+\n+    variableNames = rw.toArray(new String[rw.size()]);\n+    return variableNames;\n+  }\n+\n+  /**\n+   * Getter for property raw-to-safe-variable-name list\n+   * @return A Map that maps an unsafe variable name to\n+   *            a safe one\n+   */\n+  public Map<String, String> getRaw2SafeVarNameTable() {\n+    return raw2safeTable;\n+  }\n+\n+  public void checkVariableNames() {\n+\n+    VariableNameCheckerForR nf = new VariableNameCheckerForR(getVariableNames());\n+    if (nf.hasRenamedVariables()) {\n+      safeVarNames = nf.getFilteredVarNames();\n+      hasUnsafeVariableNames = true;\n     }\n \n-    public Map<String, String> getVarIdToRawVarNameTable(){\n-        Map<String, String> vi2rwn = new HashMap<>();\n-        \n-        for(DataVariable dv :dataVariablesForRequest){\n-            vi2rwn.put(\"v\"+dv.getId(), dv.getName());\n+    raw2safeTable = nf.getRaw2safeTable();\n+    safe2rawTable = nf.getSafe2rawTable();\n+    renamedVariableArray = nf.getRenamedVariableArray();\n+    renamedResultArray = nf.getRenamedResultArray();\n+  }\n+\n+  public List<String> getFilteredVarNameSet(List<String> varIdSet) {\n+    List<String> varNameSet = new ArrayList<>();\n+    for (String vid : varIdSet) {\n+      dbgLog.fine(\"name list: vid=\" + vid);\n+      String raw = getVarIdToRawVarNameTable().get(vid);\n+      if (raw != null) {\n+        dbgLog.fine(\"raw is not null case=\" + raw);\n+        if (raw2safeTable.containsKey(raw)) {\n+          dbgLog.fine(\"raw is unsafe case\");\n+          varNameSet.add(raw2safeTable.get(raw));\n+        } else {\n+          dbgLog.fine(\"raw is safe case\");\n+          varNameSet.add(raw);\n         }\n-        return vi2rwn;\n+      } else {\n+        dbgLog.fine(\"raw is null-case\");\n+      }\n     }\n+    dbgLog.fine(\"varNameSet=\" + varNameSet);\n+    return varNameSet;\n+  }\n \n-    public Map<String, String> getRawVarNameToVarIdTable(){\n-        Map<String, String> rwn2Id = new HashMap<>();\n-        \n-        for(DataVariable dv :dataVariablesForRequest){\n-            rwn2Id.put(dv.getName(), \"v\"+dv.getId());\n-        }\n-        return rwn2Id;\n+  public String[] getVariableIds() {\n+    String[] variableIds = null;\n+    List<String> rw = new ArrayList<>();\n+    for (DataVariable dv : dataVariablesForRequest) {\n+      rw.add(\"v\" + dv.getId().toString());\n     }\n \n-    public String[] getUpdatedVariableNames(){\n-        List<String> tmp = new ArrayList<>();\n-        if (!hasUnsafeVariableNames){\n-            // neither renemaed nor recoded vars\n-            return  getVariableNames();\n-        } \n-            \n-        return safeVarNames;\n+    variableIds = rw.toArray(new String[rw.size()]);\n+    return variableIds;\n+  }\n+\n+  public Map<String, String> getVarIdToRawVarNameTable() {\n+    Map<String, String> vi2rwn = new HashMap<>();\n+\n+    for (DataVariable dv : dataVariablesForRequest) {\n+      vi2rwn.put(\"v\" + dv.getId(), dv.getName());\n     }\n+    return vi2rwn;\n+  }\n \n-    /**\n-     * Getter for property variable labels\n-     *\n-     * @return    A String array of variable labels\n-     */\n-    public String[] getVariableLabels(){\n-        String [] variableLabels=null;\n-        List<String> rw = new ArrayList<>();\n-        for (DataVariable dv : dataVariablesForRequest) {\n-                rw.add(dv.getLabel());\n-        }\n-        \n-        variableLabels = rw.toArray(new String[rw.size()]);\n-        return variableLabels;\n+  public Map<String, String> getRawVarNameToVarIdTable() {\n+    Map<String, String> rwn2Id = new HashMap<>();\n+\n+    for (DataVariable dv : dataVariablesForRequest) {\n+      rwn2Id.put(dv.getName(), \"v\" + dv.getId());\n     }\n+    return rwn2Id;\n+  }\n \n-    public Map<String, Map<String,String>> getValueTable(){\n-        return valueTables;\n+  public String[] getUpdatedVariableNames() {\n+    List<String> tmp = new ArrayList<>();\n+    if (!hasUnsafeVariableNames) {\n+      // neither renemaed nor recoded vars\n+      return getVariableNames();\n     }\n-    \n-    public Map<String, List<String>> getCategoryValueOrders (){\n-      return this.categoryValueOrders;\n+\n+    return safeVarNames;\n+  }\n+\n+  /**\n+   * Getter for property variable labels\n+   *\n+   * @return A String array of variable labels\n+   */\n+  public String[] getVariableLabels() {\n+    String[] variableLabels = null;\n+    List<String> rw = new ArrayList<>();\n+    for (DataVariable dv : dataVariablesForRequest) {\n+      rw.add(dv.getLabel());\n     }\n+\n+    variableLabels = rw.toArray(new String[rw.size()]);\n+    return variableLabels;\n+  }\n+\n+  public Map<String, Map<String, String>> getValueTable() {\n+    return valueTables;\n+  }\n+\n+  public Map<String, List<String>> getCategoryValueOrders() {\n+    return this.categoryValueOrders;\n+  }\n     /*\n     public String[] getBaseVarIdSet(){\n         List<String> bvid = listParametersForRequest.get(\"baseVarIdSet\");\n@@ -425,15 +423,15 @@ public class RJobRequest {\n         return tmp;\n     }\n     */\n-    \n-    public String[] String2StringArray(String token) {\n-        char[] temp = token.toCharArray();\n-        String[] tmp = new String[temp.length];\n-        for (int i=0; i<temp.length; i++) {\n-           tmp[i] = String.valueOf(temp[i]);\n-        }\n-        return tmp;\n+\n+  public String[] String2StringArray(String token) {\n+    char[] temp = token.toCharArray();\n+    String[] tmp = new String[temp.length];\n+    for (int i = 0; i < temp.length; i++) {\n+      tmp[i] = String.valueOf(temp[i]);\n     }\n+    return tmp;\n+  }\n+\n \n-    \n }\n",
            "diff_size": 533
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/13/RJobRequest.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_random/13/RJobRequest.java\nindex 9171b8313ff..aaa6f114f2c 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/13/RJobRequest.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_random/13/RJobRequest.java\n@@ -137,7 +137,7 @@ public class RJobRequest {\n     }\n     \n     public String getCachedRworkSpace(){\n-\treturn this.savedRworkSpace; \n+        return this.savedRworkSpace; \n     }\n \n \n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/13/RJobRequest.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_three_grams/13/RJobRequest.java\nindex 9171b8313ff..aaa6f114f2c 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/13/RJobRequest.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_three_grams/13/RJobRequest.java\n@@ -137,7 +137,7 @@ public class RJobRequest {\n     }\n     \n     public String getCachedRworkSpace(){\n-\treturn this.savedRworkSpace; \n+        return this.savedRworkSpace; \n     }\n \n \n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "naturalize",
        "codebuff"
    ]
}