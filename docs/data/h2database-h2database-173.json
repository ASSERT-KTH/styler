{
    "project_name": "h2database-h2database",
    "error_id": "173",
    "information": {
        "errors": [
            {
                "line": "329",
                "column": "9",
                "severity": "warning",
                "message": "'if' is not followed by whitespace.",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAfterCheck"
            }
        ]
    },
    "source_code": "\n    private String convertColumnName(String columnName) {\n        if(targetsMySql) {\n            // MySQL column names are not case-sensitive on any platform\n            columnName = StringUtils.toUpperEnglish(columnName);\n        } else if ((storesMixedCase || storesLowerCase) &&",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/errored/1/173/TableLink.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/styler/173/TableLink.java\nindex 0982dbb195e..f9da61338d8 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/errored/1/173/TableLink.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/styler/173/TableLink.java\n@@ -326,7 +326,7 @@ public class TableLink extends Table {\n     }\n \n     private String convertColumnName(String columnName) {\n-        if(targetsMySql) {\n+        if (targetsMySql) {\n             // MySQL column names are not case-sensitive on any platform\n             columnName = StringUtils.toUpperEnglish(columnName);\n         } else if ((storesMixedCase || storesLowerCase) &&\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "193",
                    "column": "62",
                    "severity": "warning",
                    "message": "';' is followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.EmptyForIteratorPadCheck"
                },
                {
                    "line": "547",
                    "column": "71",
                    "severity": "warning",
                    "message": "';' is followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.EmptyForIteratorPadCheck"
                },
                {
                    "line": "660",
                    "column": "48",
                    "severity": "warning",
                    "message": "';' is followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.EmptyForIteratorPadCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/errored/1/173/TableLink.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/intellij/173/TableLink.java\nindex 0982dbb195e..b6d603d096b 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/errored/1/173/TableLink.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/intellij/173/TableLink.java\n@@ -3,6 +3,7 @@\n  * and the EPL 1.0 (https://h2database.com/html/license.html).\n  * Initial Developer: H2 Group\n  */\n+\n package org.h2.table;\n \n import java.sql.DatabaseMetaData;\n@@ -50,7 +51,8 @@ public class TableLink extends Table {\n     private static final long ROW_COUNT_APPROXIMATION = 100_000;\n \n     private final String originalSchema;\n-    private String driver, url, user, password, originalTable, qualifiedTableName;\n+    private String driver, url, user, password, originalTable,\n+            qualifiedTableName;\n     private TableLinkConnection conn;\n     private HashMap<String, PreparedStatement> preparedMap = new HashMap<>();\n     private final ArrayList<Index> indexes = Utils.newSmallArrayList();\n@@ -66,8 +68,9 @@ public class TableLink extends Table {\n     private boolean targetsMySql;\n \n     public TableLink(Schema schema, int id, String name, String driver,\n-            String url, String user, String password, String originalSchema,\n-            String originalTable, boolean emitUpdates, boolean force) {\n+                     String url, String user, String password,\n+                     String originalSchema,\n+                     String originalTable, boolean emitUpdates, boolean force) {\n         super(schema, id, name, false, true);\n         this.driver = driver;\n         this.url = url;\n@@ -83,7 +86,7 @@ public class TableLink extends Table {\n             if (!force) {\n                 throw e;\n             }\n-            Column[] cols = { };\n+            Column[] cols = {};\n             setColumns(cols);\n             linkedIndex = new LinkedIndex(this, id, IndexColumn.wrap(cols),\n                     IndexType.createNonUnique(false));\n@@ -93,7 +96,7 @@ public class TableLink extends Table {\n \n     private void connect() {\n         connectException = null;\n-        for (int retry = 0;; retry++) {\n+        for (int retry = 0; ; retry++) {\n             try {\n                 conn = database.getLinkConnection(driver, url, user, password);\n                 synchronized (conn) {\n@@ -127,12 +130,15 @@ public class TableLink extends Table {\n         String schema = null;\n         boolean isQuery = originalTable.startsWith(\"(\");\n         if (!isQuery) {\n-            try (ResultSet rs = meta.getTables(null, originalSchema, originalTable, null)) {\n+            try (ResultSet rs = meta\n+                    .getTables(null, originalSchema, originalTable, null)) {\n                 if (rs.next() && rs.next()) {\n-                    throw DbException.get(ErrorCode.SCHEMA_NAME_MUST_MATCH, originalTable);\n+                    throw DbException.get(ErrorCode.SCHEMA_NAME_MUST_MATCH,\n+                            originalTable);\n                 }\n             }\n-            try (ResultSet rs = meta.getColumns(null, originalSchema, originalTable, null)) {\n+            try (ResultSet rs = meta\n+                    .getColumns(null, originalSchema, originalTable, null)) {\n                 int i = 0;\n                 String catalog = null;\n                 while (rs.next()) {\n@@ -160,14 +166,18 @@ public class TableLink extends Table {\n                     precision = convertPrecision(sqlType, precision);\n                     int scale = rs.getInt(\"DECIMAL_DIGITS\");\n                     scale = convertScale(sqlType, scale);\n-                    int type = DataType.convertSQLTypeToValueType(sqlType, sqlTypeName);\n-                    Column col = new Column(n, TypeInfo.getTypeInfo(type, precision, scale, null), this, i++);\n+                    int type = DataType.convertSQLTypeToValueType(sqlType,\n+                            sqlTypeName);\n+                    Column col = new Column(n,\n+                            TypeInfo.getTypeInfo(type, precision, scale, null),\n+                            this, i++);\n                     columnList.add(col);\n                     columnMap.put(n, col);\n                 }\n             }\n         }\n-        if (originalTable.indexOf('.') < 0 && !StringUtils.isNullOrEmpty(schema)) {\n+        if (originalTable.indexOf('.') < 0 &&\n+                !StringUtils.isNullOrEmpty(schema)) {\n             qualifiedTableName = schema + '.' + originalTable;\n         } else {\n             qualifiedTableName = originalTable;\n@@ -175,11 +185,12 @@ public class TableLink extends Table {\n         // check if the table is accessible\n \n         try (Statement stat = conn.getConnection().createStatement();\n-                ResultSet rs = stat.executeQuery(\"SELECT * FROM \" + qualifiedTableName + \" T WHERE 1=0\")) {\n+             ResultSet rs = stat.executeQuery(\n+                     \"SELECT * FROM \" + qualifiedTableName + \" T WHERE 1=0\")) {\n             if (columnList.isEmpty()) {\n                 // alternative solution\n                 ResultSetMetaData rsMeta = rs.getMetaData();\n-                for (int i = 0; i < rsMeta.getColumnCount();) {\n+                for (int i = 0; i < rsMeta.getColumnCount(); ) {\n                     String n = rsMeta.getColumnName(i + 1);\n                     n = convertColumnName(n);\n                     int sqlType = rsMeta.getColumnType(i + 1);\n@@ -187,8 +198,11 @@ public class TableLink extends Table {\n                     precision = convertPrecision(sqlType, precision);\n                     int scale = rsMeta.getScale(i + 1);\n                     scale = convertScale(sqlType, scale);\n-                    int type = DataType.getValueTypeFromResultSet(rsMeta, i + 1);\n-                    Column col = new Column(n, TypeInfo.getTypeInfo(type, precision, scale, null), this, i++);\n+                    int type =\n+                            DataType.getValueTypeFromResultSet(rsMeta, i + 1);\n+                    Column col = new Column(n,\n+                            TypeInfo.getTypeInfo(type, precision, scale, null),\n+                            this, i++);\n                     columnList.add(col);\n                     columnMap.put(n, col);\n                 }\n@@ -208,9 +222,11 @@ public class TableLink extends Table {\n         }\n     }\n \n-    private void readIndexes(DatabaseMetaData meta, HashMap<String, Column> columnMap) {\n+    private void readIndexes(DatabaseMetaData meta,\n+                             HashMap<String, Column> columnMap) {\n         String pkName = null;\n-        try (ResultSet rs = meta.getPrimaryKeys(null, originalSchema, originalTable)) {\n+        try (ResultSet rs = meta\n+                .getPrimaryKeys(null, originalSchema, originalTable)) {\n             if (rs.next()) {\n                 pkName = readPrimaryKey(rs, columnMap);\n             }\n@@ -219,7 +235,9 @@ public class TableLink extends Table {\n             // some combinations of \"DataDirect SequeLink(R) for JDBC\"\n             // https://www.progress.com/odbc/sequelink\n         }\n-        try (ResultSet rs = meta.getIndexInfo(null, originalSchema, originalTable, false, true)) {\n+        try (ResultSet rs = meta\n+                .getIndexInfo(null, originalSchema, originalTable, false,\n+                        true)) {\n             readIndexes(rs, columnMap, pkName);\n         } catch (Exception e) {\n             // Oracle throws an exception if the table is not found or is a\n@@ -227,7 +245,9 @@ public class TableLink extends Table {\n         }\n     }\n \n-    private String readPrimaryKey(ResultSet rs, HashMap<String, Column> columnMap) throws SQLException {\n+    private String readPrimaryKey(ResultSet rs,\n+                                  HashMap<String, Column> columnMap)\n+            throws SQLException {\n         String pkName = null;\n         // the problem is, the rows are not sorted by KEY_SEQ\n         ArrayList<Column> list = Utils.newSmallArrayList();\n@@ -253,7 +273,8 @@ public class TableLink extends Table {\n         return pkName;\n     }\n \n-    private void readIndexes(ResultSet rs, HashMap<String, Column> columnMap, String pkName) throws SQLException {\n+    private void readIndexes(ResultSet rs, HashMap<String, Column> columnMap,\n+                             String pkName) throws SQLException {\n         String indexName = null;\n         ArrayList<Column> list = Utils.newSmallArrayList();\n         IndexType indexType = null;\n@@ -292,21 +313,22 @@ public class TableLink extends Table {\n         // for DATE columns, the reported precision is 7\n         // for DECIMAL columns, the reported precision is 0\n         switch (sqlType) {\n-        case Types.DECIMAL:\n-        case Types.NUMERIC:\n-            if (precision == 0) {\n-                precision = 65535;\n-            }\n-            break;\n-        case Types.DATE:\n-            precision = Math.max(ValueDate.PRECISION, precision);\n-            break;\n-        case Types.TIMESTAMP:\n-            precision = Math.max(ValueTimestamp.MAXIMUM_PRECISION, precision);\n-            break;\n-        case Types.TIME:\n-            precision = Math.max(ValueTime.MAXIMUM_PRECISION, precision);\n-            break;\n+            case Types.DECIMAL:\n+            case Types.NUMERIC:\n+                if (precision == 0) {\n+                    precision = 65535;\n+                }\n+                break;\n+            case Types.DATE:\n+                precision = Math.max(ValueDate.PRECISION, precision);\n+                break;\n+            case Types.TIMESTAMP:\n+                precision =\n+                        Math.max(ValueTimestamp.MAXIMUM_PRECISION, precision);\n+                break;\n+            case Types.TIME:\n+                precision = Math.max(ValueTime.MAXIMUM_PRECISION, precision);\n+                break;\n         }\n         return precision;\n     }\n@@ -315,18 +337,18 @@ public class TableLink extends Table {\n         // workaround for an Oracle problem:\n         // for DECIMAL columns, the reported precision is -127\n         switch (sqlType) {\n-        case Types.DECIMAL:\n-        case Types.NUMERIC:\n-            if (scale < 0) {\n-                scale = 32767;\n-            }\n-            break;\n+            case Types.DECIMAL:\n+            case Types.NUMERIC:\n+                if (scale < 0) {\n+                    scale = 32767;\n+                }\n+                break;\n         }\n         return scale;\n     }\n \n     private String convertColumnName(String columnName) {\n-        if(targetsMySql) {\n+        if (targetsMySql) {\n             // MySQL column names are not case-sensitive on any platform\n             columnName = StringUtils.toUpperEnglish(columnName);\n         } else if ((storesMixedCase || storesLowerCase) &&\n@@ -351,12 +373,14 @@ public class TableLink extends Table {\n             return;\n         } else if (firstNull > 0) {\n             trace.info(\"Unrecognized columns in linked index. \" +\n-                    \"Registering the index against the leading {0} \" +\n-                    \"recognized columns of {1} total columns.\", firstNull, list.size());\n+                            \"Registering the index against the leading {0} \" +\n+                            \"recognized columns of {1} total columns.\", firstNull,\n+                    list.size());\n             list = list.subList(0, firstNull);\n         }\n         Column[] cols = list.toArray(new Column[0]);\n-        Index index = new LinkedIndex(this, 0, IndexColumn.wrap(cols), indexType);\n+        Index index =\n+                new LinkedIndex(this, 0, IndexColumn.wrap(cols), indexType);\n         indexes.add(index);\n     }\n \n@@ -401,13 +425,15 @@ public class TableLink extends Table {\n \n     @Override\n     public Index addIndex(Session session, String indexName, int indexId,\n-            IndexColumn[] cols, IndexType indexType, boolean create,\n-            String indexComment) {\n+                          IndexColumn[] cols, IndexType indexType,\n+                          boolean create,\n+                          String indexComment) {\n         throw DbException.getUnsupportedException(\"LINK\");\n     }\n \n     @Override\n-    public boolean lock(Session session, boolean exclusive, boolean forceLockEvenInMvcc) {\n+    public boolean lock(Session session, boolean exclusive,\n+                        boolean forceLockEvenInMvcc) {\n         // nothing to do\n         return false;\n     }\n@@ -477,7 +503,7 @@ public class TableLink extends Table {\n      * Wrap a SQL exception that occurred while accessing a linked table.\n      *\n      * @param sql the SQL statement\n-     * @param ex the exception from the remote database\n+     * @param ex  the exception from the remote database\n      * @return the wrapped exception\n      */\n     public static DbException wrapException(String sql, Exception ex) {\n@@ -494,17 +520,18 @@ public class TableLink extends Table {\n      * Execute a SQL statement using the given parameters. Prepared\n      * statements are kept in a hash map to avoid re-creating them.\n      *\n-     * @param sql the SQL statement\n-     * @param params the parameters or null\n+     * @param sql           the SQL statement\n+     * @param params        the parameters or null\n      * @param reusePrepared if the prepared statement can be re-used immediately\n-     * @param session the session\n+     * @param session       the session\n      * @return the prepared statement, or null if it is re-used\n      */\n-    public PreparedStatement execute(String sql, ArrayList<Value> params, boolean reusePrepared, Session session) {\n+    public PreparedStatement execute(String sql, ArrayList<Value> params,\n+                                     boolean reusePrepared, Session session) {\n         if (conn == null) {\n             throw connectException;\n         }\n-        for (int retry = 0;; retry++) {\n+        for (int retry = 0; ; retry++) {\n             try {\n                 synchronized (conn) {\n                     PreparedStatement prep = preparedMap.remove(sql);\n@@ -512,10 +539,12 @@ public class TableLink extends Table {\n                         prep = conn.getConnection().prepareStatement(sql);\n                     }\n                     if (trace.isDebugEnabled()) {\n-                        StringBuilder builder = new StringBuilder(getName()).append(\":\\n\").append(sql);\n+                        StringBuilder builder =\n+                                new StringBuilder(getName()).append(\":\\n\")\n+                                        .append(sql);\n                         if (params != null && !params.isEmpty()) {\n                             builder.append(\" {\");\n-                            for (int i = 0, l = params.size(); i < l;) {\n+                            for (int i = 0, l = params.size(); i < l; ) {\n                                 Value v = params.get(i);\n                                 if (i > 0) {\n                                     builder.append(\", \");\n@@ -529,7 +558,8 @@ public class TableLink extends Table {\n                         trace.debug(builder.toString());\n                     }\n                     if (params != null) {\n-                        JdbcConnection ownConnection = session.createConnection(false);\n+                        JdbcConnection ownConnection =\n+                                session.createConnection(false);\n                         for (int i = 0, size = params.size(); i < size; i++) {\n                             Value v = params.get(i);\n                             JdbcUtils.set(prep, i + 1, v, ownConnection);\n@@ -627,7 +657,7 @@ public class TableLink extends Table {\n     public void updateRows(Prepared prepared, Session session, RowList rows) {\n         checkReadOnly();\n         if (emitUpdates) {\n-            for (rows.reset(); rows.hasNext();) {\n+            for (rows.reset(); rows.hasNext(); ) {\n                 prepared.checkCanceled();\n                 Row oldRow = rows.next();\n                 Row newRow = rows.next();\n@@ -662,7 +692,7 @@ public class TableLink extends Table {\n      * Add this prepared statement to the list of cached statements.\n      *\n      * @param prep the prepared statement\n-     * @param sql the SQL statement\n+     * @param sql  the SQL statement\n      */\n     public void reusePreparedStatement(PreparedStatement prep, String sql) {\n         synchronized (conn) {\n@@ -689,7 +719,7 @@ public class TableLink extends Table {\n      * null).\n      *\n      * @param session the session\n-     * @param row the row\n+     * @param row     the row\n      */\n     @Override\n     public void validateConvertUpdateSequence(Session session, Row row) {\n@@ -698,7 +728,8 @@ public class TableLink extends Table {\n             if (value != null) {\n                 // null means use the default value\n                 Column column = columns[i];\n-                Value v2 = column.validateConvertUpdateSequence(session, value, row);\n+                Value v2 = column.validateConvertUpdateSequence(session, value,\n+                        row);\n                 if (v2 != value) {\n                     row.setValue(i, v2);\n                 }\n",
            "diff_size": 92
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "171",
                    "column": "9",
                    "severity": "warning",
                    "message": "'try' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/errored/1/173/TableLink.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/codebuff/173/TableLink.java\nindex 0982dbb195e..3baa554ffc1 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/errored/1/173/TableLink.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/codebuff/173/TableLink.java\n@@ -16,7 +16,6 @@ import java.util.ArrayList;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Objects;\n-\n import org.h2.api.ErrorCode;\n import org.h2.command.Prepared;\n import org.h2.engine.Session;\n@@ -43,16 +42,16 @@ import org.h2.value.ValueTimestamp;\n  * A linked table contains connection information for a table accessible by\n  * JDBC. The table may be stored in a different database.\n  */\n+\n+\n public class TableLink extends Table {\n \n     private static final int MAX_RETRY = 2;\n-\n     private static final long ROW_COUNT_APPROXIMATION = 100_000;\n-\n     private final String originalSchema;\n     private String driver, url, user, password, originalTable, qualifiedTableName;\n     private TableLinkConnection conn;\n-    private HashMap<String, PreparedStatement> preparedMap = new HashMap<>();\n+    private HashMap<String, PreparedStatement> preparedMap = new HashMap< >();\n     private final ArrayList<Index> indexes = Utils.newSmallArrayList();\n     private final boolean emitUpdates;\n     private LinkedIndex linkedIndex;\n@@ -65,9 +64,7 @@ public class TableLink extends Table {\n     private boolean readOnly;\n     private boolean targetsMySql;\n \n-    public TableLink(Schema schema, int id, String name, String driver,\n-            String url, String user, String password, String originalSchema,\n-            String originalTable, boolean emitUpdates, boolean force) {\n+    public TableLink(Schema schema, int id, String name, String driver, String url, String user, String password, String originalSchema, String originalTable, boolean emitUpdates, boolean force) {\n         super(schema, id, name, false, true);\n         this.driver = driver;\n         this.url = url;\n@@ -83,10 +80,9 @@ public class TableLink extends Table {\n             if (!force) {\n                 throw e;\n             }\n-            Column[] cols = { };\n+            Column[] cols = {};\n             setColumns(cols);\n-            linkedIndex = new LinkedIndex(this, id, IndexColumn.wrap(cols),\n-                    IndexType.createNonUnique(false));\n+            linkedIndex = new LinkedIndex(this, id, IndexColumn.wrap(cols), IndexType.createNonUnique(false));\n             indexes.add(linkedIndex);\n         }\n     }\n@@ -123,7 +119,7 @@ public class TableLink extends Table {\n         storesMixedCaseQuoted = meta.storesMixedCaseQuotedIdentifiers();\n         supportsMixedCaseIdentifiers = meta.supportsMixedCaseIdentifiers();\n         ArrayList<Column> columnList = Utils.newSmallArrayList();\n-        HashMap<String, Column> columnMap = new HashMap<>();\n+        HashMap<String, Column> columnMap = new HashMap< >();\n         String schema = null;\n         boolean isQuery = originalTable.startsWith(\"(\");\n         if (!isQuery) {\n@@ -144,8 +140,7 @@ public class TableLink extends Table {\n                     if (schema == null) {\n                         schema = thisSchema;\n                     }\n-                    if (!Objects.equals(catalog, thisCatalog) ||\n-                            !Objects.equals(schema, thisSchema)) {\n+                    if (!Objects.equals(catalog, thisCatalog) || !Objects.equals(schema, thisSchema)) {\n                         // if the table exists in multiple schemas or tables,\n                         // use the alternative solution\n                         columnMap.clear();\n@@ -173,9 +168,7 @@ public class TableLink extends Table {\n             qualifiedTableName = originalTable;\n         }\n         // check if the table is accessible\n-\n-        try (Statement stat = conn.getConnection().createStatement();\n-                ResultSet rs = stat.executeQuery(\"SELECT * FROM \" + qualifiedTableName + \" T WHERE 1=0\")) {\n+        try(Statement stat = conn.getConnection().createStatement(); ResultSet rs = stat.executeQuery(\"SELECT * FROM \" + qualifiedTableName + \" T WHERE 1=0\")) {\n             if (columnList.isEmpty()) {\n                 // alternative solution\n                 ResultSetMetaData rsMeta = rs.getMetaData();\n@@ -194,14 +187,12 @@ public class TableLink extends Table {\n                 }\n             }\n         } catch (Exception e) {\n-            throw DbException.get(ErrorCode.TABLE_OR_VIEW_NOT_FOUND_1, e,\n-                    originalTable + '(' + e.toString() + ')');\n+            throw DbException.get(ErrorCode.TABLE_OR_VIEW_NOT_FOUND_1, e, originalTable + '(' + e.toString() + ')');\n         }\n         Column[] cols = columnList.toArray(new Column[0]);\n         setColumns(cols);\n         int id = getId();\n-        linkedIndex = new LinkedIndex(this, id, IndexColumn.wrap(cols),\n-                IndexType.createNonUnique(false));\n+        linkedIndex = new LinkedIndex(this, id, IndexColumn.wrap(cols), IndexType.createNonUnique(false));\n         indexes.add(linkedIndex);\n         if (!isQuery) {\n             readIndexes(meta, columnMap);\n@@ -218,12 +209,14 @@ public class TableLink extends Table {\n             // Some ODBC bridge drivers don't support it:\n             // some combinations of \"DataDirect SequeLink(R) for JDBC\"\n             // https://www.progress.com/odbc/sequelink\n+\n         }\n         try (ResultSet rs = meta.getIndexInfo(null, originalSchema, originalTable, false, true)) {\n             readIndexes(rs, columnMap, pkName);\n         } catch (Exception e) {\n             // Oracle throws an exception if the table is not found or is a\n             // SYNONYM\n+\n         }\n     }\n \n@@ -253,7 +246,8 @@ public class TableLink extends Table {\n         return pkName;\n     }\n \n-    private void readIndexes(ResultSet rs, HashMap<String, Column> columnMap, String pkName) throws SQLException {\n+    private void readIndexes(ResultSet rs,\n+            HashMap<String, Column> columnMap, String pkName) throws SQLException {\n         String indexName = null;\n         ArrayList<Column> list = Utils.newSmallArrayList();\n         IndexType indexType = null;\n@@ -275,8 +269,7 @@ public class TableLink extends Table {\n                 list.clear();\n             }\n             boolean unique = !rs.getBoolean(\"NON_UNIQUE\");\n-            indexType = unique ? IndexType.createUnique(false, false) :\n-                    IndexType.createNonUnique(false);\n+            indexType = unique ? IndexType.createUnique(false, false) : IndexType.createNonUnique(false);\n             String col = rs.getString(\"COLUMN_NAME\");\n             col = convertColumnName(col);\n             Column column = columnMap.get(col);\n@@ -326,19 +319,18 @@ public class TableLink extends Table {\n     }\n \n     private String convertColumnName(String columnName) {\n-        if(targetsMySql) {\n+        if (targetsMySql) {\n             // MySQL column names are not case-sensitive on any platform\n             columnName = StringUtils.toUpperEnglish(columnName);\n-        } else if ((storesMixedCase || storesLowerCase) &&\n-                columnName.equals(StringUtils.toLowerEnglish(columnName))) {\n+        } else if ((storesMixedCase || storesLowerCase) && columnName.equals(StringUtils.toLowerEnglish(columnName))) {\n             columnName = StringUtils.toUpperEnglish(columnName);\n-        } else if (storesMixedCase && !supportsMixedCaseIdentifiers) {\n+                                                        } else if (storesMixedCase && !supportsMixedCaseIdentifiers) {\n             // TeraData\n-            columnName = StringUtils.toUpperEnglish(columnName);\n+                   columnName = StringUtils.toUpperEnglish(columnName);\n         } else if (storesMixedCase && storesMixedCaseQuoted) {\n             // MS SQL Server (identifiers are case insensitive even if quoted)\n-            columnName = StringUtils.toUpperEnglish(columnName);\n-        }\n+                                                                   columnName = StringUtils.toUpperEnglish(columnName);\n+                                                               }\n         return columnName;\n     }\n \n@@ -350,9 +342,7 @@ public class TableLink extends Table {\n             trace.info(\"Omitting linked index - no recognized columns.\");\n             return;\n         } else if (firstNull > 0) {\n-            trace.info(\"Unrecognized columns in linked index. \" +\n-                    \"Registering the index against the leading {0} \" +\n-                    \"recognized columns of {1} total columns.\", firstNull, list.size());\n+            trace.info(\"Unrecognized columns in linked index. \" + \"Registering the index against the leading {0} \" + \"recognized columns of {1} total columns.\", firstNull, list.size());\n             list = list.subList(0, firstNull);\n         }\n         Column[] cols = list.toArray(new Column[0]);\n@@ -400,9 +390,7 @@ public class TableLink extends Table {\n     }\n \n     @Override\n-    public Index addIndex(Session session, String indexName, int indexId,\n-            IndexColumn[] cols, IndexType indexType, boolean create,\n-            String indexComment) {\n+    public Index addIndex(Session session, String indexName, int indexId, IndexColumn[] cols, IndexType indexType, boolean create, String indexComment) {\n         throw DbException.getUnsupportedException(\"LINK\");\n     }\n \n@@ -480,12 +468,14 @@ public class TableLink extends Table {\n      * @param ex the exception from the remote database\n      * @return the wrapped exception\n      */\n+\n+\n     public static DbException wrapException(String sql, Exception ex) {\n         SQLException e = DbException.toSQLException(ex);\n-        return DbException.get(ErrorCode.ERROR_ACCESSING_LINKED_TABLE_2,\n-                e, sql, e.toString());\n+        return DbException.get(ErrorCode.ERROR_ACCESSING_LINKED_TABLE_2, e, sql, e.toString());\n     }\n \n+\n     public String getQualifiedTable() {\n         return qualifiedTableName;\n     }\n@@ -500,6 +490,8 @@ public class TableLink extends Table {\n      * @param session the session\n      * @return the prepared statement, or null if it is re-used\n      */\n+\n+\n     public PreparedStatement execute(String sql, ArrayList<Value> params, boolean reusePrepared, Session session) {\n         if (conn == null) {\n             throw connectException;\n@@ -555,6 +547,7 @@ public class TableLink extends Table {\n     @Override\n     public void unlock(Session s) {\n         // nothing to do\n+\n     }\n \n     @Override\n@@ -593,13 +586,13 @@ public class TableLink extends Table {\n         invalidate();\n     }\n \n+\n     public boolean isOracle() {\n         return url.startsWith(\"jdbc:oracle:\");\n     }\n \n     private static boolean isMySqlUrl(String url) {\n-        return url.startsWith(\"jdbc:mysql:\")\n-                || url.startsWith(\"jdbc:mariadb:\");\n+        return url.startsWith(\"jdbc:mysql:\") || url.startsWith(\"jdbc:mariadb:\");\n     }\n \n     @Override\n@@ -640,10 +633,12 @@ public class TableLink extends Table {\n         }\n     }\n \n+\n     public void setGlobalTemporary(boolean globalTemporary) {\n         this.globalTemporary = globalTemporary;\n     }\n \n+\n     public void setReadOnly(boolean readOnly) {\n         this.readOnly = readOnly;\n     }\n@@ -664,6 +659,8 @@ public class TableLink extends Table {\n      * @param prep the prepared statement\n      * @param sql the SQL statement\n      */\n+\n+\n     public void reusePreparedStatement(PreparedStatement prep, String sql) {\n         synchronized (conn) {\n             preparedMap.put(sql, prep);\n@@ -679,9 +676,11 @@ public class TableLink extends Table {\n      * Linked tables don't know if they are readonly. This overwrites\n      * the default handling.\n      */\n+\n     @Override\n     public void checkWritingAllowed() {\n         // only the target database can verify this\n+\n     }\n \n     /**\n@@ -691,6 +690,7 @@ public class TableLink extends Table {\n      * @param session the session\n      * @param row the row\n      */\n+\n     @Override\n     public void validateConvertUpdateSequence(Session session, Row row) {\n         for (int i = 0; i < columns.length; i++) {\n@@ -706,4 +706,4 @@ public class TableLink extends Table {\n         }\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 60
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/errored/1/173/TableLink.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/styler_random/173/TableLink.java\nindex 0982dbb195e..f9da61338d8 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/errored/1/173/TableLink.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/styler_random/173/TableLink.java\n@@ -326,7 +326,7 @@ public class TableLink extends Table {\n     }\n \n     private String convertColumnName(String columnName) {\n-        if(targetsMySql) {\n+        if (targetsMySql) {\n             // MySQL column names are not case-sensitive on any platform\n             columnName = StringUtils.toUpperEnglish(columnName);\n         } else if ((storesMixedCase || storesLowerCase) &&\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/errored/1/173/TableLink.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/styler_three_grams/173/TableLink.java\nindex 0982dbb195e..f9da61338d8 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/errored/1/173/TableLink.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/styler_three_grams/173/TableLink.java\n@@ -326,7 +326,7 @@ public class TableLink extends Table {\n     }\n \n     private String convertColumnName(String columnName) {\n-        if(targetsMySql) {\n+        if (targetsMySql) {\n             // MySQL column names are not case-sensitive on any platform\n             columnName = StringUtils.toUpperEnglish(columnName);\n         } else if ((storesMixedCase || storesLowerCase) &&\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "styler",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "intellij",
        "naturalize",
        "codebuff"
    ]
}