{
    "project_name": "EMResearch-EMB",
    "error_id": "90",
    "information": {
        "errors": [
            {
                "line": "30",
                "severity": "warning",
                "message": "Line is longer than 120 characters (found 136).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": " * A {@link Match} is the configuration of an algorithm used to match {@link AnalyzedTokenReadings}s.\n * In XML, it's the {@code <match/>} element.\n * Use {@link #createState(Synthesizer, AnalyzedTokenReadings)} and {@link #createState(Synthesizer, AnalyzedTokenReadings[], int, int)}\n * to create a {@link MatchState} used to actually match {@link AnalyzedTokenReadings}.\n *\n * @author Marcin Mi\u0142kowski",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "30",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 136).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "31",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 136).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/EMResearch-EMB/errored/1/90/Match.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/EMResearch-EMB/intellij/90/Match.java\nindex 4e3ed4c3ab2..ef529485fe9 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/EMResearch-EMB/errored/1/90/Match.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/EMResearch-EMB/intellij/90/Match.java\n@@ -1,6 +1,6 @@\n-/* LanguageTool, a natural language style checker \n+/* LanguageTool, a natural language style checker\n  * Copyright (C) 2005 Daniel Naber (http://www.danielnaber.de)\n- * \n+ *\n  * This library is free software; you can redistribute it and/or\n  * modify it under the terms of the GNU Lesser General Public\n  * License as published by the Free Software Foundation; either\n@@ -16,6 +16,7 @@\n  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301\n  * USA\n  */\n+\n package org.languagetool.rules.patterns;\n \n import java.util.regex.Pattern;\n@@ -34,198 +35,229 @@ import org.languagetool.tools.StringTools;\n  */\n public final class Match {\n \n-  /** Possible string case conversions. **/\n-  public enum CaseConversion {\n-    NONE, STARTLOWER, STARTUPPER, ALLLOWER, ALLUPPER, PRESERVE\n-  }\n-\n-  public enum IncludeRange {\n-    NONE, FOLLOWING, ALL\n-  }\n-\n-  private final String posTag;\n-  private final boolean suppressMisspelled;\n-  private final String regexReplace;\n-  private final String posTagReplace;\n-  private final CaseConversion caseConversionType;\n-  private final IncludeRange includeSkipped;\n-  // Pattern used to define parts of the matched token:\n-  private final Pattern pRegexMatch;\n-  // True if this match element is used for formatting POS token:\n-  private final boolean setPos;\n-\n-  private boolean postagRegexp;\n-  // True if this match element formats a statically defined lemma which is\n-  // enclosed by the element, e.g., <match...>word</match>:\n-  private boolean staticLemma;\n-  private String lemma;\n-  private int tokenRef;\n-  // Pattern used to define parts of the matched POS token:\n-  private Pattern pPosRegexMatch;\n-  // True when the match is not in the suggestion:\n-  private boolean inMessageOnly;\n-\n-  public Match(String posTag, String posTagReplace,\n-      boolean postagRegexp, String regexMatch,\n-      String regexReplace, CaseConversion caseConversionType,\n-      boolean setPOS,\n-      boolean suppressMisspelled,\n-      IncludeRange includeSkipped) {\n-    this.posTag = posTag;\n-    this.postagRegexp = postagRegexp;\n-    this.caseConversionType = caseConversionType;\n-    pRegexMatch = regexMatch != null ? Pattern.compile(regexMatch) : null;\n-    if (postagRegexp && posTag != null) {\n-      pPosRegexMatch = Pattern.compile(posTag);\n-    }\n-    this.regexReplace = regexReplace;\n-    this.posTagReplace = posTagReplace;\n-    this.setPos = setPOS;\n-    this.includeSkipped = includeSkipped;\n-    this.suppressMisspelled = suppressMisspelled;\n-  }\n-\n-  /**\n-   * Creates a state used for actually matching a token.\n-   * @since 2.3\n-   */\n-  public MatchState createState(Synthesizer synthesizer, AnalyzedTokenReadings token) {\n-    MatchState state = new MatchState(this, synthesizer);\n-    state.setToken(token);\n-    return state;\n-  }\n-\n-  /**\n-   * Creates a state used for actually matching a token.\n-   * @since 2.3\n-   */\n-  public MatchState createState(Synthesizer synthesizer, AnalyzedTokenReadings[] tokens, int index, int next) {\n-    MatchState state = new MatchState(this, synthesizer);\n-    state.setToken(tokens, index, next);\n-    return state;\n-  }\n-\n-  /**\n-   * Checks if the Match element is used for setting the part of speech: {@code setpos=\"yes\"} in XML.\n-   * @return True if Match sets POS.\n-   */\n-  public boolean setsPos() {\n-    return setPos;\n-  }\n-\n-  /**\n-   * Checks if the Match element uses regexp-based form of the POS tag.\n-   * @return True if regexp is used in POS.\n-   */\n-  public boolean posRegExp() {\n-    return postagRegexp;\n-  }\n-\n-  /**\n-   * Sets a base form (lemma) that will be formatted, or synthesized, using the\n-   * specified POS regular expressions.\n-   * @param lemmaString String that specifies the base form.\n-   */\n-  public void setLemmaString(String lemmaString) {\n-    if (!StringTools.isEmpty(lemmaString)) {\n-      lemma = lemmaString;\n-      staticLemma = true;\n-      postagRegexp = true;\n-      if (posTag != null) {\n-        pPosRegexMatch = Pattern.compile(posTag);\n-      }\n-    }\n-  }\n-\n-  /** @since 2.3 */\n-  public String getLemma() {\n-    return lemma;\n-  }\n-\n-  /** @since 2.3 */\n-  public boolean isStaticLemma() {\n-    return staticLemma;\n-  }\n-\n-  /**\n-   * Used to tell whether the Match class will spell-check the result so\n-   * that misspelled suggestions are suppressed.\n-   * @return True if this is so.\n-   */\n-  public boolean checksSpelling() {\n-    return suppressMisspelled;\n-  }\n-\n-  /**\n-   * Sets the token number referenced by the match.\n-   * @param i Token number.\n-   */\n-  public void setTokenRef(int i) {\n-    tokenRef = i;\n-  }\n-\n-  /**\n-   * Gets the token number referenced by the match.\n-   * @return token number.\n-   */\n-  public int getTokenRef() {\n-    return tokenRef;\n-  }\n-\n-  /**\n-   * Used to let LT know that it should change the case of the match.\n-   * @return true if match converts the case of the token.\n-   */\n-  public boolean convertsCase() {\n-    return caseConversionType != CaseConversion.NONE;\n-  }\n-\n-  /** @since 2.3 */\n-  public CaseConversion getCaseConversionType() {\n-    return caseConversionType;\n-  }\n-\n-  public void setInMessageOnly(boolean inMessageOnly) {\n-    this.inMessageOnly = inMessageOnly;\n-  }\n-\n-  public boolean isInMessageOnly() {\n-    return inMessageOnly;\n-  }\n-\n-  /** @since 2.3 */\n-  public String getPosTag() {\n-    return posTag;\n-  }\n-\n-  /** @since 2.3 */\n-  public Pattern getRegexMatch() {\n-    return pRegexMatch;\n-  }\n-\n-  /** @since 2.3 */\n-  public String getRegexReplace() {\n-    return regexReplace;\n-  }\n-\n-  /** @since 2.3 */\n-  public Pattern getPosRegexMatch() {\n-    return pPosRegexMatch;\n-  }\n-\n-  /** @since 2.3 */\n-  public boolean isPostagRegexp() {\n-    return postagRegexp;\n-  }\n-\n-  /** @since 2.3 */\n-  public String getPosTagReplace() {\n-    return posTagReplace;\n-  }\n-\n-  /** @since 2.3 */\n-  public IncludeRange getIncludeSkipped() {\n-    return includeSkipped;\n-  }\n+    /**\n+     * Possible string case conversions.\n+     **/\n+    public enum CaseConversion {\n+        NONE, STARTLOWER, STARTUPPER, ALLLOWER, ALLUPPER, PRESERVE\n+    }\n+\n+    public enum IncludeRange {\n+        NONE, FOLLOWING, ALL\n+    }\n+\n+    private final String posTag;\n+    private final boolean suppressMisspelled;\n+    private final String regexReplace;\n+    private final String posTagReplace;\n+    private final CaseConversion caseConversionType;\n+    private final IncludeRange includeSkipped;\n+    // Pattern used to define parts of the matched token:\n+    private final Pattern pRegexMatch;\n+    // True if this match element is used for formatting POS token:\n+    private final boolean setPos;\n+\n+    private boolean postagRegexp;\n+    // True if this match element formats a statically defined lemma which is\n+    // enclosed by the element, e.g., <match...>word</match>:\n+    private boolean staticLemma;\n+    private String lemma;\n+    private int tokenRef;\n+    // Pattern used to define parts of the matched POS token:\n+    private Pattern pPosRegexMatch;\n+    // True when the match is not in the suggestion:\n+    private boolean inMessageOnly;\n+\n+    public Match(String posTag, String posTagReplace,\n+                 boolean postagRegexp, String regexMatch,\n+                 String regexReplace, CaseConversion caseConversionType,\n+                 boolean setPOS,\n+                 boolean suppressMisspelled,\n+                 IncludeRange includeSkipped) {\n+        this.posTag = posTag;\n+        this.postagRegexp = postagRegexp;\n+        this.caseConversionType = caseConversionType;\n+        pRegexMatch = regexMatch != null ? Pattern.compile(regexMatch) : null;\n+        if (postagRegexp && posTag != null) {\n+            pPosRegexMatch = Pattern.compile(posTag);\n+        }\n+        this.regexReplace = regexReplace;\n+        this.posTagReplace = posTagReplace;\n+        this.setPos = setPOS;\n+        this.includeSkipped = includeSkipped;\n+        this.suppressMisspelled = suppressMisspelled;\n+    }\n+\n+    /**\n+     * Creates a state used for actually matching a token.\n+     *\n+     * @since 2.3\n+     */\n+    public MatchState createState(Synthesizer synthesizer, AnalyzedTokenReadings token) {\n+        MatchState state = new MatchState(this, synthesizer);\n+        state.setToken(token);\n+        return state;\n+    }\n+\n+    /**\n+     * Creates a state used for actually matching a token.\n+     *\n+     * @since 2.3\n+     */\n+    public MatchState createState(Synthesizer synthesizer, AnalyzedTokenReadings[] tokens, int index, int next) {\n+        MatchState state = new MatchState(this, synthesizer);\n+        state.setToken(tokens, index, next);\n+        return state;\n+    }\n+\n+    /**\n+     * Checks if the Match element is used for setting the part of speech: {@code setpos=\"yes\"} in XML.\n+     *\n+     * @return True if Match sets POS.\n+     */\n+    public boolean setsPos() {\n+        return setPos;\n+    }\n+\n+    /**\n+     * Checks if the Match element uses regexp-based form of the POS tag.\n+     *\n+     * @return True if regexp is used in POS.\n+     */\n+    public boolean posRegExp() {\n+        return postagRegexp;\n+    }\n+\n+    /**\n+     * Sets a base form (lemma) that will be formatted, or synthesized, using the\n+     * specified POS regular expressions.\n+     *\n+     * @param lemmaString String that specifies the base form.\n+     */\n+    public void setLemmaString(String lemmaString) {\n+        if (!StringTools.isEmpty(lemmaString)) {\n+            lemma = lemmaString;\n+            staticLemma = true;\n+            postagRegexp = true;\n+            if (posTag != null) {\n+                pPosRegexMatch = Pattern.compile(posTag);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * @since 2.3\n+     */\n+    public String getLemma() {\n+        return lemma;\n+    }\n+\n+    /**\n+     * @since 2.3\n+     */\n+    public boolean isStaticLemma() {\n+        return staticLemma;\n+    }\n+\n+    /**\n+     * Used to tell whether the Match class will spell-check the result so\n+     * that misspelled suggestions are suppressed.\n+     *\n+     * @return True if this is so.\n+     */\n+    public boolean checksSpelling() {\n+        return suppressMisspelled;\n+    }\n+\n+    /**\n+     * Sets the token number referenced by the match.\n+     *\n+     * @param i Token number.\n+     */\n+    public void setTokenRef(int i) {\n+        tokenRef = i;\n+    }\n+\n+    /**\n+     * Gets the token number referenced by the match.\n+     *\n+     * @return token number.\n+     */\n+    public int getTokenRef() {\n+        return tokenRef;\n+    }\n+\n+    /**\n+     * Used to let LT know that it should change the case of the match.\n+     *\n+     * @return true if match converts the case of the token.\n+     */\n+    public boolean convertsCase() {\n+        return caseConversionType != CaseConversion.NONE;\n+    }\n+\n+    /**\n+     * @since 2.3\n+     */\n+    public CaseConversion getCaseConversionType() {\n+        return caseConversionType;\n+    }\n+\n+    public void setInMessageOnly(boolean inMessageOnly) {\n+        this.inMessageOnly = inMessageOnly;\n+    }\n+\n+    public boolean isInMessageOnly() {\n+        return inMessageOnly;\n+    }\n+\n+    /**\n+     * @since 2.3\n+     */\n+    public String getPosTag() {\n+        return posTag;\n+    }\n+\n+    /**\n+     * @since 2.3\n+     */\n+    public Pattern getRegexMatch() {\n+        return pRegexMatch;\n+    }\n+\n+    /**\n+     * @since 2.3\n+     */\n+    public String getRegexReplace() {\n+        return regexReplace;\n+    }\n+\n+    /**\n+     * @since 2.3\n+     */\n+    public Pattern getPosRegexMatch() {\n+        return pPosRegexMatch;\n+    }\n+\n+    /**\n+     * @since 2.3\n+     */\n+    public boolean isPostagRegexp() {\n+        return postagRegexp;\n+    }\n+\n+    /**\n+     * @since 2.3\n+     */\n+    public String getPosTagReplace() {\n+        return posTagReplace;\n+    }\n+\n+    /**\n+     * @since 2.3\n+     */\n+    public IncludeRange getIncludeSkipped() {\n+        return includeSkipped;\n+    }\n \n }\n",
            "diff_size": 227
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "30",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 136).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/EMResearch-EMB/errored/1/90/Match.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/EMResearch-EMB/naturalize/90/Match.java\nindex 4e3ed4c3ab2..50031edcb87 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/EMResearch-EMB/errored/1/90/Match.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/EMResearch-EMB/naturalize/90/Match.java\n@@ -67,9 +67,7 @@ public final class Match {\n \n   public Match(String posTag, String posTagReplace,\n       boolean postagRegexp, String regexMatch,\n-      String regexReplace, CaseConversion caseConversionType,\n-      boolean setPOS,\n-      boolean suppressMisspelled,\n+      String regexReplace, CaseConversion caseConversionType, boolean setPOS, boolean suppressMisspelled,\n       IncludeRange includeSkipped) {\n     this.posTag = posTag;\n     this.postagRegexp = postagRegexp;\n@@ -228,4 +226,4 @@ public final class Match {\n     return includeSkipped;\n   }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 4
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "29",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 136).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "83",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 225).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/EMResearch-EMB/errored/1/90/Match.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/EMResearch-EMB/codebuff/90/Match.java\nindex 4e3ed4c3ab2..a2bc03069b5 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/EMResearch-EMB/errored/1/90/Match.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/EMResearch-EMB/codebuff/90/Match.java\n@@ -19,7 +19,6 @@\n package org.languagetool.rules.patterns;\n \n import java.util.regex.Pattern;\n-\n import org.languagetool.AnalyzedTokenReadings;\n import org.languagetool.synthesis.Synthesizer;\n import org.languagetool.tools.StringTools;\n@@ -32,200 +31,229 @@ import org.languagetool.tools.StringTools;\n  *\n  * @author Marcin Mi\u0142kowski\n  */\n+\n+\n public final class Match {\n \n   /** Possible string case conversions. **/\n-  public enum CaseConversion {\n-    NONE, STARTLOWER, STARTUPPER, ALLLOWER, ALLUPPER, PRESERVE\n-  }\n-\n-  public enum IncludeRange {\n-    NONE, FOLLOWING, ALL\n-  }\n-\n-  private final String posTag;\n-  private final boolean suppressMisspelled;\n-  private final String regexReplace;\n-  private final String posTagReplace;\n-  private final CaseConversion caseConversionType;\n-  private final IncludeRange includeSkipped;\n+\n+    public enum CaseConversion {\n+        NONE,\n+\n+        STARTLOWER,\n+\n+        STARTUPPER,\n+\n+        ALLLOWER,\n+\n+        ALLUPPER,\n+\n+        PRESERVE\n+    }\n+\n+    public enum IncludeRange {\n+        NONE,\n+\n+        FOLLOWING,\n+\n+        ALL\n+    }\n+\n+    private final String posTag;\n+    private final boolean suppressMisspelled;\n+    private final String regexReplace;\n+    private final String posTagReplace;\n+    private final CaseConversion caseConversionType;\n+    private final IncludeRange includeSkipped;\n   // Pattern used to define parts of the matched token:\n-  private final Pattern pRegexMatch;\n+    private final Pattern pRegexMatch;\n   // True if this match element is used for formatting POS token:\n-  private final boolean setPos;\n-\n-  private boolean postagRegexp;\n+    private final boolean setPos;\n+    private boolean postagRegexp;\n   // True if this match element formats a statically defined lemma which is\n   // enclosed by the element, e.g., <match...>word</match>:\n-  private boolean staticLemma;\n-  private String lemma;\n-  private int tokenRef;\n+    private boolean staticLemma;\n+    private String lemma;\n+    private int tokenRef;\n   // Pattern used to define parts of the matched POS token:\n-  private Pattern pPosRegexMatch;\n+    private Pattern pPosRegexMatch;\n   // True when the match is not in the suggestion:\n-  private boolean inMessageOnly;\n-\n-  public Match(String posTag, String posTagReplace,\n-      boolean postagRegexp, String regexMatch,\n-      String regexReplace, CaseConversion caseConversionType,\n-      boolean setPOS,\n-      boolean suppressMisspelled,\n-      IncludeRange includeSkipped) {\n-    this.posTag = posTag;\n-    this.postagRegexp = postagRegexp;\n-    this.caseConversionType = caseConversionType;\n-    pRegexMatch = regexMatch != null ? Pattern.compile(regexMatch) : null;\n-    if (postagRegexp && posTag != null) {\n-      pPosRegexMatch = Pattern.compile(posTag);\n-    }\n-    this.regexReplace = regexReplace;\n-    this.posTagReplace = posTagReplace;\n-    this.setPos = setPOS;\n-    this.includeSkipped = includeSkipped;\n-    this.suppressMisspelled = suppressMisspelled;\n-  }\n+    private boolean inMessageOnly;\n+\n+    public Match(String posTag, String posTagReplace, boolean postagRegexp, String regexMatch, String regexReplace, CaseConversion caseConversionType, boolean setPOS, boolean suppressMisspelled, IncludeRange includeSkipped) {\n+        this.posTag = posTag;\n+        this.postagRegexp = postagRegexp;\n+        this.caseConversionType = caseConversionType;\n+        pRegexMatch = regexMatch != null ? Pattern.compile(regexMatch) : null;\n+        if (postagRegexp && posTag != null) {\n+            pPosRegexMatch = Pattern.compile(posTag);\n+        }\n+        this.regexReplace = regexReplace;\n+        this.posTagReplace = posTagReplace;\n+        this.setPos = setPOS;\n+        this.includeSkipped = includeSkipped;\n+        this.suppressMisspelled = suppressMisspelled;\n+    }\n \n   /**\n    * Creates a state used for actually matching a token.\n    * @since 2.3\n    */\n-  public MatchState createState(Synthesizer synthesizer, AnalyzedTokenReadings token) {\n-    MatchState state = new MatchState(this, synthesizer);\n-    state.setToken(token);\n-    return state;\n-  }\n+\n+    public MatchState createState(Synthesizer synthesizer, AnalyzedTokenReadings token) {\n+        MatchState state = new MatchState(this, synthesizer);\n+        state.setToken(token);\n+        return state;\n+    }\n \n   /**\n    * Creates a state used for actually matching a token.\n    * @since 2.3\n    */\n-  public MatchState createState(Synthesizer synthesizer, AnalyzedTokenReadings[] tokens, int index, int next) {\n-    MatchState state = new MatchState(this, synthesizer);\n-    state.setToken(tokens, index, next);\n-    return state;\n-  }\n+\n+    public MatchState createState(Synthesizer synthesizer, AnalyzedTokenReadings[] tokens, int index, int next) {\n+        MatchState state = new MatchState(this, synthesizer);\n+        state.setToken(tokens, index, next);\n+        return state;\n+    }\n \n   /**\n    * Checks if the Match element is used for setting the part of speech: {@code setpos=\"yes\"} in XML.\n    * @return True if Match sets POS.\n    */\n-  public boolean setsPos() {\n-    return setPos;\n-  }\n+\n+    public boolean setsPos() {\n+        return setPos;\n+    }\n \n   /**\n    * Checks if the Match element uses regexp-based form of the POS tag.\n    * @return True if regexp is used in POS.\n    */\n-  public boolean posRegExp() {\n-    return postagRegexp;\n-  }\n+\n+    public boolean posRegExp() {\n+        return postagRegexp;\n+    }\n \n   /**\n    * Sets a base form (lemma) that will be formatted, or synthesized, using the\n    * specified POS regular expressions.\n    * @param lemmaString String that specifies the base form.\n    */\n-  public void setLemmaString(String lemmaString) {\n-    if (!StringTools.isEmpty(lemmaString)) {\n-      lemma = lemmaString;\n-      staticLemma = true;\n-      postagRegexp = true;\n-      if (posTag != null) {\n-        pPosRegexMatch = Pattern.compile(posTag);\n-      }\n+\n+    public void setLemmaString(String lemmaString) {\n+        if (!StringTools.isEmpty(lemmaString)) {\n+            lemma = lemmaString;\n+            staticLemma = true;\n+            postagRegexp = true;\n+            if (posTag != null) {\n+                pPosRegexMatch = Pattern.compile(posTag);\n+            }\n+        }\n     }\n-  }\n \n   /** @since 2.3 */\n-  public String getLemma() {\n-    return lemma;\n-  }\n+\n+    public String getLemma() {\n+        return lemma;\n+    }\n \n   /** @since 2.3 */\n-  public boolean isStaticLemma() {\n-    return staticLemma;\n-  }\n+\n+    public boolean isStaticLemma() {\n+        return staticLemma;\n+    }\n \n   /**\n    * Used to tell whether the Match class will spell-check the result so\n    * that misspelled suggestions are suppressed.\n    * @return True if this is so.\n    */\n-  public boolean checksSpelling() {\n-    return suppressMisspelled;\n-  }\n+\n+    public boolean checksSpelling() {\n+        return suppressMisspelled;\n+    }\n \n   /**\n    * Sets the token number referenced by the match.\n    * @param i Token number.\n    */\n-  public void setTokenRef(int i) {\n-    tokenRef = i;\n-  }\n+\n+    public void setTokenRef(int i) {\n+        tokenRef = i;\n+    }\n \n   /**\n    * Gets the token number referenced by the match.\n    * @return token number.\n    */\n-  public int getTokenRef() {\n-    return tokenRef;\n-  }\n+\n+    public int getTokenRef() {\n+        return tokenRef;\n+    }\n \n   /**\n    * Used to let LT know that it should change the case of the match.\n    * @return true if match converts the case of the token.\n    */\n-  public boolean convertsCase() {\n-    return caseConversionType != CaseConversion.NONE;\n-  }\n+\n+    public boolean convertsCase() {\n+        return caseConversionType != CaseConversion.NONE;\n+    }\n \n   /** @since 2.3 */\n-  public CaseConversion getCaseConversionType() {\n-    return caseConversionType;\n-  }\n \n-  public void setInMessageOnly(boolean inMessageOnly) {\n-    this.inMessageOnly = inMessageOnly;\n-  }\n+    public CaseConversion getCaseConversionType() {\n+        return caseConversionType;\n+    }\n+\n+    public void setInMessageOnly(boolean inMessageOnly) {\n+        this.inMessageOnly = inMessageOnly;\n+    }\n \n-  public boolean isInMessageOnly() {\n-    return inMessageOnly;\n-  }\n+    public boolean isInMessageOnly() {\n+        return inMessageOnly;\n+    }\n \n   /** @since 2.3 */\n-  public String getPosTag() {\n-    return posTag;\n-  }\n+\n+    public String getPosTag() {\n+        return posTag;\n+    }\n \n   /** @since 2.3 */\n-  public Pattern getRegexMatch() {\n-    return pRegexMatch;\n-  }\n+\n+    public Pattern getRegexMatch() {\n+        return pRegexMatch;\n+    }\n \n   /** @since 2.3 */\n-  public String getRegexReplace() {\n-    return regexReplace;\n-  }\n+\n+    public String getRegexReplace() {\n+        return regexReplace;\n+    }\n \n   /** @since 2.3 */\n-  public Pattern getPosRegexMatch() {\n-    return pPosRegexMatch;\n-  }\n+\n+    public Pattern getPosRegexMatch() {\n+        return pPosRegexMatch;\n+    }\n \n   /** @since 2.3 */\n-  public boolean isPostagRegexp() {\n-    return postagRegexp;\n-  }\n+\n+    public boolean isPostagRegexp() {\n+        return postagRegexp;\n+    }\n \n   /** @since 2.3 */\n-  public String getPosTagReplace() {\n-    return posTagReplace;\n-  }\n+\n+    public String getPosTagReplace() {\n+        return posTagReplace;\n+    }\n \n   /** @since 2.3 */\n-  public IncludeRange getIncludeSkipped() {\n-    return includeSkipped;\n-  }\n \n-}\n+    public IncludeRange getIncludeSkipped() {\n+        return includeSkipped;\n+    }\n+}\n\\ No newline at end of file\n",
            "diff_size": 160
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "30",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 136).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "30",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 136).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ],
    "repaired_by": [],
    "not_repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}