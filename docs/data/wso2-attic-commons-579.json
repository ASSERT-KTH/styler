{
    "project_name": "wso2-attic-commons",
    "error_id": "579",
    "information": {
        "errors": [
            {
                "line": "128",
                "severity": "error",
                "message": "Line is longer than 120 characters (found 172).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": "        Node node = source.getExpression();\n        if (node == null) {\n            throw new CompilationException(__msgs.errEmptyExpression(source.getURI(), new QName(source.getElement().getNamespaceURI(), source.getElement().getNodeName())));\n        }\n        if (node.getNodeType() != Node.TEXT_NODE) {\n            throw new CompilationException(__msgs.errUnexpectedNodeTypeForXPath(DOMUtils.domToString(node)));",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/579/XPath20ExpressionCompilerImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler/579/XPath20ExpressionCompilerImpl.java\nindex 4ff4ea03dd9..997fb8fa586 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/579/XPath20ExpressionCompilerImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler/579/XPath20ExpressionCompilerImpl.java\n@@ -125,9 +125,10 @@ public class XPath20ExpressionCompilerImpl implements ExpressionCompiler {\n         String xpathStr;\n         Node node = source.getExpression();\n         if (node == null) {\n-            throw new CompilationException(__msgs.errEmptyExpression(source.getURI(), new QName(source.getElement().getNamespaceURI(), source.getElement().getNodeName())));\n-        }\n-        if (node.getNodeType() != Node.TEXT_NODE) {\n+            throw new CompilationException(__msgs.errEmptyExpression(source.getURI(),\n+                                new QName(source.getElement().getNamespaceURI(), source.getElement().getNodeName())));\n+         }\n+         if (node.getNodeType() != Node.TEXT_NODE) {\n             throw new CompilationException(__msgs.errUnexpectedNodeTypeForXPath(DOMUtils.domToString(node)));\n         }\n         xpathStr = node.getNodeValue();\n",
            "diff_size": 4
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/579/XPath20ExpressionCompilerImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/intellij/579/XPath20ExpressionCompilerImpl.java\nindex 4ff4ea03dd9..1d3c901b657 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/579/XPath20ExpressionCompilerImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/intellij/579/XPath20ExpressionCompilerImpl.java\n@@ -54,222 +54,226 @@ import org.w3c.dom.Node;\n \n /**\n  * XPath compiler based on the SAXON implementation.\n+ *\n  * @author Matthieu Riou <mriou at apache dot org>\n  */\n public class XPath20ExpressionCompilerImpl implements ExpressionCompiler {\n \n-    protected static final Log __log = LogFactory.getLog(XPath20ExpressionCompilerBPEL20.class);\n+  protected static final Log __log = LogFactory.getLog(XPath20ExpressionCompilerBPEL20.class);\n \n-    protected String _bpelNS;\n-    protected QName _qnLinkStatus;\n-    protected QName _qnVarProp;\n-    protected QName _qnVarData;\n-    protected QName _qnXslTransform;\n+  protected String _bpelNS;\n+  protected QName _qnLinkStatus;\n+  protected QName _qnVarProp;\n+  protected QName _qnVarData;\n+  protected QName _qnXslTransform;\n \n-    protected final XPathMessages __msgs = MessageBundle.getMessages(XPathMessages.class);\n-    protected Map<String, String> _properties = new HashMap<String, String>();\n-    protected CompilerContext _compilerContext;\n+  protected final XPathMessages __msgs = MessageBundle.getMessages(XPathMessages.class);\n+  protected Map<String, String> _properties = new HashMap<String, String>();\n+  protected CompilerContext _compilerContext;\n \n-    public XPath20ExpressionCompilerImpl(String bpelNS) {\n-        _bpelNS = bpelNS;\n-        _qnLinkStatus = new QName(_bpelNS, Constants.EXT_FUNCTION_GETLINKSTATUS);\n-        _qnVarProp = new QName(_bpelNS, Constants.EXT_FUNCTION_GETVARIABLEPROPERTY);\n-        _qnVarData = new QName(_bpelNS, Constants.EXT_FUNCTION_GETVARIABLEDATA);\n-        _qnXslTransform = new QName(_bpelNS, Constants.EXT_FUNCTION_DOXSLTRANSFORM);\n+  public XPath20ExpressionCompilerImpl(String bpelNS) {\n+    _bpelNS = bpelNS;\n+    _qnLinkStatus = new QName(_bpelNS, Constants.EXT_FUNCTION_GETLINKSTATUS);\n+    _qnVarProp = new QName(_bpelNS, Constants.EXT_FUNCTION_GETVARIABLEPROPERTY);\n+    _qnVarData = new QName(_bpelNS, Constants.EXT_FUNCTION_GETVARIABLEDATA);\n+    _qnXslTransform = new QName(_bpelNS, Constants.EXT_FUNCTION_DOXSLTRANSFORM);\n \n-        _properties.put(\"runtime-class\", \"org.apache.ode.bpel.elang.xpath20.runtime.XPath20ExpressionRuntime\");\n-        TransformerFactory trsf = new net.sf.saxon.TransformerFactoryImpl();\n-        XslTransformHandler.getInstance().setTransformerFactory(trsf);\n-    }\n+    _properties.put(\"runtime-class\", \"org.apache.ode.bpel.elang.xpath20.runtime.XPath20ExpressionRuntime\");\n+    TransformerFactory trsf = new net.sf.saxon.TransformerFactoryImpl();\n+    XslTransformHandler.getInstance().setTransformerFactory(trsf);\n+  }\n \n-    public void setCompilerContext(CompilerContext compilerContext) {\n-        _compilerContext = compilerContext;\n-        XslCompilationErrorListener xe = new XslCompilationErrorListener(compilerContext);\n-        XslTransformHandler.getInstance().setErrorListener(xe);\n-    }\n+  public void setCompilerContext(CompilerContext compilerContext) {\n+    _compilerContext = compilerContext;\n+    XslCompilationErrorListener xe = new XslCompilationErrorListener(compilerContext);\n+    XslTransformHandler.getInstance().setErrorListener(xe);\n+  }\n \n-    /**\n-     * @see org.apache.ode.bpel.compiler.api.ExpressionCompiler#compileJoinCondition(java.lang.Object)\n-     */\n-    public OExpression compileJoinCondition(Object source) throws CompilationException {\n-        return _compile((Expression) source, true);\n-    }\n+  /**\n+   * @see org.apache.ode.bpel.compiler.api.ExpressionCompiler#compileJoinCondition(java.lang.Object)\n+   */\n+  public OExpression compileJoinCondition(Object source) throws CompilationException {\n+    return _compile((Expression) source, true);\n+  }\n \n-    /**\n-     * @see org.apache.ode.bpel.compiler.api.ExpressionCompiler#compile(java.lang.Object)\n-     */\n-    public OExpression compile(Object source) throws CompilationException {\n-        return _compile((Expression) source, false);\n-    }\n+  /**\n+   * @see org.apache.ode.bpel.compiler.api.ExpressionCompiler#compile(java.lang.Object)\n+   */\n+  public OExpression compile(Object source) throws CompilationException {\n+    return _compile((Expression) source, false);\n+  }\n+\n+  /**\n+   * @see org.apache.ode.bpel.compiler.api.ExpressionCompiler#compileLValue(java.lang.Object)\n+   */\n+  public OLValueExpression compileLValue(Object source) throws CompilationException {\n+    return (OLValueExpression) _compile((Expression) source, false);\n+  }\n \n-    /**\n-     * @see org.apache.ode.bpel.compiler.api.ExpressionCompiler#compileLValue(java.lang.Object)\n-     */\n-    public OLValueExpression compileLValue(Object source) throws CompilationException {\n-        return (OLValueExpression) _compile((Expression) source, false);\n+  /**\n+   * @see org.apache.ode.bpel.compiler.api.ExpressionCompiler#compile(java.lang.Object)\n+   */\n+  private OExpression _compile(org.apache.ode.bpel.compiler.bom.Expression xpath, boolean isJoinCondition)\n+    throws CompilationException {\n+    OXPath20ExpressionBPEL20 oexp = new OXPath20ExpressionBPEL20(_compilerContext.getOProcess(), _qnVarData,\n+      _qnVarProp, _qnLinkStatus, _qnXslTransform, isJoinCondition);\n+    oexp.namespaceCtx = _compilerContext.tryCacheNamespaceContext(xpath.getNamespaceContext());\n+    doJaxpCompile(oexp, xpath);\n+    return oexp;\n+  }\n+\n+  private void doJaxpCompile(OXPath20ExpressionBPEL20 out, Expression source) throws CompilationException {\n+    String xpathStr;\n+    Node node = source.getExpression();\n+    if (node == null) {\n+      throw new CompilationException(__msgs.errEmptyExpression(source.getURI(),\n+        new QName(source.getElement().getNamespaceURI(), source.getElement().getNodeName())));\n+    }\n+    if (node.getNodeType() != Node.TEXT_NODE) {\n+      throw new CompilationException(__msgs.errUnexpectedNodeTypeForXPath(DOMUtils.domToString(node)));\n     }\n-    \n-    /**\n-     * @see org.apache.ode.bpel.compiler.api.ExpressionCompiler#compile(java.lang.Object)\n-     */\n-    private OExpression _compile(org.apache.ode.bpel.compiler.bom.Expression xpath, boolean isJoinCondition)\n-            throws CompilationException {\n-        OXPath20ExpressionBPEL20 oexp = new OXPath20ExpressionBPEL20(_compilerContext.getOProcess(), _qnVarData,\n-                _qnVarProp, _qnLinkStatus, _qnXslTransform, isJoinCondition);\n-        oexp.namespaceCtx = _compilerContext.tryCacheNamespaceContext(xpath.getNamespaceContext());\n-        doJaxpCompile(oexp, xpath);\n-        return oexp;\n+    xpathStr = node.getNodeValue();\n+    xpathStr = xpathStr.trim();\n+    if (xpathStr.length() == 0) {\n+      throw new CompilationException(__msgs.warnXPath20Syntax(DOMUtils.domToString(node), \"empty string\"));\n     }\n \n-    private void doJaxpCompile(OXPath20ExpressionBPEL20 out, Expression source) throws CompilationException {\n-        String xpathStr;\n-        Node node = source.getExpression();\n-        if (node == null) {\n-            throw new CompilationException(__msgs.errEmptyExpression(source.getURI(), new QName(source.getElement().getNamespaceURI(), source.getElement().getNodeName())));\n-        }\n-        if (node.getNodeType() != Node.TEXT_NODE) {\n-            throw new CompilationException(__msgs.errUnexpectedNodeTypeForXPath(DOMUtils.domToString(node)));\n-        }\n-        xpathStr = node.getNodeValue();\n-        xpathStr = xpathStr.trim();\n-        if (xpathStr.length() == 0) {\n-            throw new CompilationException(__msgs.warnXPath20Syntax(DOMUtils.domToString(node), \"empty string\"));\n+    out.xpath = xpathStr;\n+    try {\n+      __log.debug(\"Compiling expression \" + xpathStr);\n+      XPathFactory xpf = new XPathFactoryImpl();\n+      JaxpFunctionResolver funcResolver = new JaxpFunctionResolver(\n+        _compilerContext, out, source.getNamespaceContext(), _bpelNS);\n+      JaxpVariableResolver varResolver = new JaxpVariableResolver(_compilerContext, out);\n+      XPath xpe = xpf.newXPath();\n+      xpe.setXPathFunctionResolver(funcResolver);\n+      xpe.setXPathVariableResolver(varResolver);\n+      xpe.setNamespaceContext(source.getNamespaceContext());\n+      XPathExpression expr = xpe.compile(xpathStr);\n+      // evaluate the expression so as to initialize the variables\n+      try {\n+        expr.evaluate(node);\n+      } catch (XPathExpressionException xpee) {\n+        // swallow errors caused by uninitialized variable\n+      }\n+      for (String varExpr : extractVariableExprs(xpathStr)) {\n+        expr = xpe.compile(varExpr);\n+        try {\n+          expr.evaluate(node);\n+        } catch (XPathExpressionException xpee) {\n+          // swallow errors caused by uninitialized variable\n         }\n-\n-        out.xpath = xpathStr;\n+      }\n+      for (String functionExpr : extractFunctionExprs(xpathStr)) {\n+        expr = xpe.compile(functionExpr);\n         try {\n-            __log.debug(\"Compiling expression \" + xpathStr);\n-            XPathFactory xpf = new XPathFactoryImpl();\n-            JaxpFunctionResolver funcResolver = new JaxpFunctionResolver(\n-                    _compilerContext, out, source.getNamespaceContext(), _bpelNS);\n-            JaxpVariableResolver varResolver = new JaxpVariableResolver(_compilerContext, out);\n-            XPath xpe = xpf.newXPath();\n-            xpe.setXPathFunctionResolver(funcResolver);\n-            xpe.setXPathVariableResolver(varResolver);\n-            xpe.setNamespaceContext(source.getNamespaceContext());\n-            XPathExpression expr = xpe.compile(xpathStr);\n-            // evaluate the expression so as to initialize the variables\n-            try {\n-                expr.evaluate(node);\n-            } catch (XPathExpressionException xpee) {\n-                // swallow errors caused by uninitialized variable\n-            }\n-            for (String varExpr : extractVariableExprs(xpathStr)) {\n-                expr = xpe.compile(varExpr);\n-                try {\n-                    expr.evaluate(node);\n-                } catch (XPathExpressionException xpee) {\n-                    // swallow errors caused by uninitialized variable\n-                }\n-            }\n-            for (String functionExpr : extractFunctionExprs(xpathStr)) {\n-                expr = xpe.compile(functionExpr);\n-                try {\n-                    expr.evaluate(node);\n-                } catch (XPathExpressionException xpee) {\n-                    // swallow errors caused by uninitialized variable\n-                }\n-            }\n-        } catch (XPathExpressionException e) {\n-            __log.debug(e);\n-            __log.info(\"Couldn't validate properly expression \" + xpathStr);\n-        } catch (WrappedResolverException wre) {\n-            if (wre._compilationMsg != null)\n-                throw new CompilationException(wre._compilationMsg, wre);\n-            if (wre.getCause() instanceof CompilationException)\n-                throw (CompilationException) wre.getCause();\n-            throw wre;\n+          expr.evaluate(node);\n+        } catch (XPathExpressionException xpee) {\n+          // swallow errors caused by uninitialized variable\n         }\n+      }\n+    } catch (XPathExpressionException e) {\n+      __log.debug(e);\n+      __log.info(\"Couldn't validate properly expression \" + xpathStr);\n+    } catch (WrappedResolverException wre) {\n+      if (wre._compilationMsg != null) {\n+        throw new CompilationException(wre._compilationMsg, wre);\n+      }\n+      if (wre.getCause() instanceof CompilationException) {\n+        throw (CompilationException) wre.getCause();\n+      }\n+      throw wre;\n     }\n+  }\n \n-    /**\n-     * Returns the list of variable references in the given XPath expression\n-     * that may not have been resolved properly, which is the case especially\n-     * if the expression contains a function, which short circuited the evaluation.\n-     *\n-     * @param xpathStr\n-     * @return list of variable expressions that may not have been resolved properly\n-     */\n-    private List<String> extractVariableExprs(String xpathStr) {\n-        ArrayList<String> variableExprs = new ArrayList<String>();\n-        int firstVariable = xpathStr.indexOf(\"$\"),\n-            lastVariable = xpathStr.lastIndexOf(\"$\"),\n-            firstFunction = xpathStr.indexOf(\"(\");\n-        StringBuffer variableExpr = new StringBuffer();\n-        if ((firstVariable > 0 && // the xpath references a variable\n-                firstFunction > 0) || // the xpath contains a function\n-            (firstVariable < lastVariable)) { // the xpath references multiple variables\n-            // most likely, the variable reference has not been resolved, so make that happen\n-            boolean quoted = false, doubleQuoted = false, variable = false;\n-            Name11Checker nameChecker = Name11Checker.getInstance();\n-            for (int index = 0; index < xpathStr.length(); index++) {\n-                char ch = xpathStr.charAt(index);\n-                if (ch == '\\''){\n-                    quoted = !quoted;\n-                }\n-                if (ch == '\\\"') {\n-                    doubleQuoted = !doubleQuoted;\n-                }\n-                if (quoted || doubleQuoted){\n-                    continue;\n-                }\n-                if (ch == '$') {\n-                    variable = true;\n-                    variableExpr.setLength(0);\n-                    variableExpr.append(ch);\n-                } else {\n-                    if (variable) {\n-                        variableExpr.append(ch);\n-                        // in the name is qualified, don't check if its a qname when we're at the \":\" character\n-                        if (ch == ':') {\n-                            continue;\n-                        }\n-                        if (index == xpathStr.length() ||\n-                                !nameChecker.isQName(variableExpr.substring(1))) {\n-                            variable = false;\n-                            variableExpr.setLength(variableExpr.length() - 1);\n-                            variableExprs.add(variableExpr.toString());\n-                            variableExpr.setLength(0);\n-                        }\n-                    }\n-                }\n+  /**\n+   * Returns the list of variable references in the given XPath expression\n+   * that may not have been resolved properly, which is the case especially\n+   * if the expression contains a function, which short circuited the evaluation.\n+   *\n+   * @param xpathStr\n+   * @return list of variable expressions that may not have been resolved properly\n+   */\n+  private List<String> extractVariableExprs(String xpathStr) {\n+    ArrayList<String> variableExprs = new ArrayList<String>();\n+    int firstVariable = xpathStr.indexOf(\"$\"),\n+      lastVariable = xpathStr.lastIndexOf(\"$\"),\n+      firstFunction = xpathStr.indexOf(\"(\");\n+    StringBuffer variableExpr = new StringBuffer();\n+    if ((firstVariable > 0 && // the xpath references a variable\n+      firstFunction > 0) || // the xpath contains a function\n+      (firstVariable < lastVariable)) { // the xpath references multiple variables\n+      // most likely, the variable reference has not been resolved, so make that happen\n+      boolean quoted = false, doubleQuoted = false, variable = false;\n+      Name11Checker nameChecker = Name11Checker.getInstance();\n+      for (int index = 0; index < xpathStr.length(); index++) {\n+        char ch = xpathStr.charAt(index);\n+        if (ch == '\\'') {\n+          quoted = !quoted;\n+        }\n+        if (ch == '\\\"') {\n+          doubleQuoted = !doubleQuoted;\n+        }\n+        if (quoted || doubleQuoted) {\n+          continue;\n+        }\n+        if (ch == '$') {\n+          variable = true;\n+          variableExpr.setLength(0);\n+          variableExpr.append(ch);\n+        } else {\n+          if (variable) {\n+            variableExpr.append(ch);\n+            // in the name is qualified, don't check if its a qname when we're at the \":\" character\n+            if (ch == ':') {\n+              continue;\n             }\n-            if (variableExpr.length() > 0) {\n-                variableExprs.add(variableExpr.toString());\n+            if (index == xpathStr.length() ||\n+              !nameChecker.isQName(variableExpr.substring(1))) {\n+              variable = false;\n+              variableExpr.setLength(variableExpr.length() - 1);\n+              variableExprs.add(variableExpr.toString());\n+              variableExpr.setLength(0);\n             }\n+          }\n         }\n-        return variableExprs;\n+      }\n+      if (variableExpr.length() > 0) {\n+        variableExprs.add(variableExpr.toString());\n+      }\n     }\n+    return variableExprs;\n+  }\n \n-    /**\n-     * Returns the list of function references in the given XPath expression\n-     * that may not have been resolved properly, which is the case especially\n-     * if the expression contains a preceding function, which short circuited the evaluation.\n-     *\n-     * @param xpathStr\n-     * @return list of function expressions that may not have been resolved properly\n-     */\n-    private List<String> extractFunctionExprs(String xpathStr) {\n-        ArrayList<String> functionExprs = new ArrayList<String>();\n-        // Match the prefix : function name ( all contents except the ) and the closing )'s that may occur\n+  /**\n+   * Returns the list of function references in the given XPath expression\n+   * that may not have been resolved properly, which is the case especially\n+   * if the expression contains a preceding function, which short circuited the evaluation.\n+   *\n+   * @param xpathStr\n+   * @return list of function expressions that may not have been resolved properly\n+   */\n+  private List<String> extractFunctionExprs(String xpathStr) {\n+    ArrayList<String> functionExprs = new ArrayList<String>();\n+    // Match the prefix : function name ( all contents except the ) and the closing )'s that may occur\n //        final String FUNCTION_REGEX = \"\\\\w+:\\\\w+\\\\([.[^\\\\)]]*\\\\)*\";\n-        final String FUNCTION_REGEX = \"(\\\\w+:)?\\\\w+\\\\((.+)?\\\\)\";\n-        int firstFunction = xpathStr.indexOf(\"(\"),\n-            lastFunction = xpathStr.lastIndexOf(\"(\");\n-        if ((firstFunction > 0 && firstFunction < lastFunction)) {\n-            Pattern regex = Pattern.compile(FUNCTION_REGEX);\n-            Matcher matcher = regex.matcher(xpathStr);\n+    final String FUNCTION_REGEX = \"(\\\\w+:)?\\\\w+\\\\((.+)?\\\\)\";\n+    int firstFunction = xpathStr.indexOf(\"(\"),\n+      lastFunction = xpathStr.lastIndexOf(\"(\");\n+    if ((firstFunction > 0 && firstFunction < lastFunction)) {\n+      Pattern regex = Pattern.compile(FUNCTION_REGEX);\n+      Matcher matcher = regex.matcher(xpathStr);\n \n-            while (matcher.find()) {\n-                String function = matcher.group();\n-                functionExprs.add(function);\n-            }\n-        }\n-        return functionExprs;\n+      while (matcher.find()) {\n+        String function = matcher.group();\n+        functionExprs.add(function);\n+      }\n     }\n+    return functionExprs;\n+  }\n \n-    public Map<String, String> getProperties() {\n-        return _properties;\n-    }\n+  public Map<String, String> getProperties() {\n+    return _properties;\n+  }\n \n }\n",
            "diff_size": 249
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "128",
                    "severity": "error",
                    "message": "Line is longer than 120 characters (found 172).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/579/XPath20ExpressionCompilerImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler_three_grams/579/XPath20ExpressionCompilerImpl.java\nindex 4ff4ea03dd9..997fb8fa586 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/579/XPath20ExpressionCompilerImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler_three_grams/579/XPath20ExpressionCompilerImpl.java\n@@ -125,9 +125,10 @@ public class XPath20ExpressionCompilerImpl implements ExpressionCompiler {\n         String xpathStr;\n         Node node = source.getExpression();\n         if (node == null) {\n-            throw new CompilationException(__msgs.errEmptyExpression(source.getURI(), new QName(source.getElement().getNamespaceURI(), source.getElement().getNodeName())));\n-        }\n-        if (node.getNodeType() != Node.TEXT_NODE) {\n+            throw new CompilationException(__msgs.errEmptyExpression(source.getURI(),\n+                                new QName(source.getElement().getNamespaceURI(), source.getElement().getNodeName())));\n+         }\n+         if (node.getNodeType() != Node.TEXT_NODE) {\n             throw new CompilationException(__msgs.errUnexpectedNodeTypeForXPath(DOMUtils.domToString(node)));\n         }\n         xpathStr = node.getNodeValue();\n",
            "diff_size": 4
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "naturalize",
        "codebuff",
        "styler_random"
    ]
}