{
    "project_name": "OpenEMS-openems",
    "error_id": "30",
    "information": {
        "errors": [
            {
                "line": "83",
                "column": "17",
                "severity": "warning",
                "message": "WhitespaceAround: 'if' is not followed by whitespace. Empty blocks may only be represented as {} when not part of a multi-block statement (4.1.3)",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
            }
        ]
    },
    "source_code": "\n\t\t// make sure the ModbusRecord is available\n\t\tif(record == null) {\n\t\t\tthrow new MyIllegalAddressException(this,\n\t\t\t\t\t\"Record for Modbus address [\" + ref + \"] is not available.\");\n\t\t}",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "83",
                    "column": "17",
                    "severity": "warning",
                    "message": "WhitespaceAround: 'if' is not followed by whitespace. Empty blocks may only be represented as {} when not part of a multi-block statement (4.1.3)",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/OpenEMS-openems/errored/1/30/MyProcessImage.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/OpenEMS-openems/intellij/30/MyProcessImage.java\nindex c2572c6784c..9e68f839e03 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/OpenEMS-openems/errored/1/30/MyProcessImage.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/OpenEMS-openems/intellij/30/MyProcessImage.java\n@@ -24,202 +24,202 @@ import io.openems.edge.common.modbusslave.ModbusRecord;\n  */\n public class MyProcessImage implements ProcessImage {\n \n-\tprivate final Logger log = LoggerFactory.getLogger(MyProcessImage.class);\n-\n-\tprotected final AbstractModbusTcpApi parent;\n-\n-\tprotected MyProcessImage(AbstractModbusTcpApi parent) {\n-\t\tthis.parent = parent;\n-\t}\n-\n-\t@Override\n-\tpublic synchronized InputRegister[] getInputRegisterRange(int offset, int count) throws MyIllegalAddressException {\n-\t\tthis.parent.logDebug(this.log, \"Reading Input Registers. Address [\" + offset + \"] Count [\" + count + \"].\");\n-\t\tRegister[] registers = this.getRegisterRange(offset, count);\n-\t\tRegister[] result = new Register[registers.length];\n-\t\tfor (int i = 0; i < registers.length; i++) {\n-\t\t\tresult[i] = registers[i];\n-\t\t}\n-\t\treturn result;\n-\t}\n-\n-\t@Override\n-\tpublic synchronized Register[] getRegisterRange(int offset, int count) throws MyIllegalAddressException {\n-\t\tthis.parent.logDebug(this.log, \"Reading Registers. Address [\" + offset + \"] Count [\" + count + \"].\");\n-\t\tSortedMap<Integer, ModbusRecord> records = this.parent.records.subMap(offset, offset + count);\n-\t\tRegister[] result = new Register[count];\n-\t\tfor (int i = 0; i < count;) {\n-\t\t\t// Get record for modbus address\n-\t\t\tint ref = i + offset;\n-\t\t\tModbusRecord record = records.get(ref);\n-\t\t\tif (record == null) {\n-\t\t\t\tthrow new MyIllegalAddressException(this, \"Record for Modbus address [\" + ref + \"] is undefined.\");\n-\t\t\t}\n-\n-\t\t\t// Get Registers from Record\n-\t\t\tRegister[] registers = this.getRecordValueRegisters(record);\n-\n-\t\t\t// make sure this Record fits\n-\t\t\tif (result.length < i + registers.length) {\n-\t\t\t\tthrow new MyIllegalAddressException(this,\n-\t\t\t\t\t\t\"Record for Modbus address [\" + ref + \"] does not fit in Result.\");\n-\t\t\t}\n-\t\t\tfor (int j = 0; j < registers.length; j++) {\n-\t\t\t\tresult[i + j] = registers[j];\n-\t\t\t}\n-\n-\t\t\t// increase i by word length\n-\t\t\ti += registers.length;\n-\t\t}\n-\t\treturn result;\n-\t}\n-\n-\t@Override\n-\tpublic synchronized Register getRegister(int ref) throws MyIllegalAddressException {\n-\t\tthis.parent.logDebug(this.log, \"Get Register. Address [\" + ref + \"].\");\n-\t\tModbusRecord record = this.parent.records.get(ref);\n-\n-\t\t// make sure the ModbusRecord is available\n-\t\tif(record == null) {\n-\t\t\tthrow new MyIllegalAddressException(this,\n-\t\t\t\t\t\"Record for Modbus address [\" + ref + \"] is not available.\");\n-\t\t}\n-\t\t\n-\t\t// Get Registers from Record\n-\t\tRegister[] registers = this.getRecordValueRegisters(record);\n-\n-\t\t// make sure this Record requires only one Register/Word\n-\t\tif (registers.length > 1) {\n-\t\t\tthrow new MyIllegalAddressException(this,\n-\t\t\t\t\t\"Record for Modbus address [\" + ref + \"] requires more than one Register.\");\n-\t\t}\n-\n-\t\treturn registers[0];\n-\t}\n-\n-\t/**\n-\t * Get value as byte-array and convert it to InputRegisters.\n-\t * \n-\t * @param record the record\n-\t * @return the Register\n-\t */\n-\tprivate Register[] getRecordValueRegisters(ModbusRecord record) {\n-\t\tMyRegister[] result = new MyRegister[record.getType().getWords()];\n-\t\tOpenemsComponent component = this.parent.getComponent(record.getComponentId());\n-\t\tbyte[] value = record.getValue(component);\n-\t\tfor (int j = 0; j < value.length / 2; j++) {\n-\t\t\tresult[j] = new MyRegister(j, value[j * 2], value[j * 2 + 1], //\n-\t\t\t\t\t/*\n-\t\t\t\t\t * On Set-Value event:\n-\t\t\t\t\t */\n-\t\t\t\t\t(register) -> {\n-\t\t\t\t\t\trecord.writeValue(component, register.getIndex(), register.getByte1(), register.getByte2());\n-\t\t\t\t\t});\n-\t\t}\n-\t\treturn result;\n-\t}\n-\n-\t/**********************************************\n-\t * From here, the methods are not implemented!.\n-\t **********************************************\n-\t */\n-\n-\t@Override\n-\tpublic synchronized InputRegister getInputRegister(int ref) {\n-\t\tthis.parent.logWarn(this.log, \"getInputRegister is not implemented\");\n-\t\treturn new SimpleInputRegister(0);\n-\t}\n-\n-\t@Override\n-\tpublic synchronized int getInputRegisterCount() {\n-\t\tthis.parent.logWarn(this.log, \"getInputRegisterCount is not implemented\");\n-\t\treturn 0;\n-\t}\n-\n-\t@Override\n-\tpublic synchronized DigitalOut[] getDigitalOutRange(int offset, int count) {\n-\t\tthis.parent.logWarn(this.log, \"getDigitalOutRange is not implemented\");\n-\t\tDigitalOut[] result = new DigitalOut[count];\n-\t\tfor (int i = 0; i < count; i++) {\n-\t\t\tresult[i] = new SimpleDigitalOut(false);\n-\t\t}\n-\t\treturn result;\n-\t}\n-\n-\t@Override\n-\tpublic synchronized DigitalOut getDigitalOut(int ref) {\n-\t\tthis.parent.logWarn(this.log, \"getDigitalOut is not implemented\");\n-\t\treturn new SimpleDigitalOut(false);\n-\t}\n-\n-\t@Override\n-\tpublic synchronized int getDigitalOutCount() {\n-\t\tthis.parent.logWarn(this.log, \"getDigitalOutCount is not implemented\");\n-\t\treturn 0;\n-\t}\n-\n-\t@Override\n-\tpublic synchronized DigitalIn[] getDigitalInRange(int offset, int count) {\n-\t\tthis.parent.logWarn(this.log, \"getDigitalInRange is not implemented\");\n-\t\tDigitalIn[] result = new DigitalIn[count];\n-\t\tfor (int i = 0; i < count; i++) {\n-\t\t\tresult[i] = new SimpleDigitalIn(false);\n-\t\t}\n-\t\treturn result;\n-\t}\n-\n-\t@Override\n-\tpublic synchronized DigitalIn getDigitalIn(int ref) {\n-\t\tthis.parent.logWarn(this.log, \"getDigitalInRange is not implemented\");\n-\t\treturn new SimpleDigitalIn(false);\n-\t}\n-\n-\t@Override\n-\tpublic synchronized int getDigitalInCount() {\n-\t\tthis.parent.logWarn(this.log, \"getDigitalInRange is not implemented\");\n-\t\treturn 0;\n-\t}\n-\n-\t@Override\n-\tpublic synchronized int getRegisterCount() {\n-\t\tthis.parent.logWarn(this.log, \"getRegisterCount is not implemented\");\n-\t\treturn 0;\n-\t}\n-\n-\t@Override\n-\tpublic synchronized File getFile(int ref) {\n-\t\tthis.parent.logWarn(this.log, \"getFile is not implemented\");\n-\t\treturn null;\n-\t}\n-\n-\t@Override\n-\tpublic synchronized File getFileByNumber(int ref) {\n-\t\tthis.parent.logWarn(this.log, \"getFileByNumber is not implemented\");\n-\t\treturn null;\n-\t}\n-\n-\t@Override\n-\tpublic synchronized int getFileCount() {\n-\t\tthis.parent.logWarn(this.log, \"getFileByNumber is not implemented\");\n-\t\treturn 0;\n-\t}\n-\n-\t@Override\n-\tpublic synchronized FIFO getFIFO(int ref) {\n-\t\tthis.parent.logWarn(this.log, \"getFIFO is not implemented\");\n-\t\treturn null;\n-\t}\n-\n-\t@Override\n-\tpublic synchronized FIFO getFIFOByAddress(int ref) {\n-\t\tthis.parent.logWarn(this.log, \"getFIFOByAddress is not implemented\");\n-\t\treturn null;\n-\t}\n-\n-\t@Override\n-\tpublic synchronized int getFIFOCount() {\n-\t\tthis.parent.logWarn(this.log, \"getFIFOCount is not implemented\");\n-\t\treturn 0;\n-\t}\n+  private final Logger log = LoggerFactory.getLogger(MyProcessImage.class);\n+\n+  protected final AbstractModbusTcpApi parent;\n+\n+  protected MyProcessImage(AbstractModbusTcpApi parent) {\n+    this.parent = parent;\n+  }\n+\n+  @Override\n+  public synchronized InputRegister[] getInputRegisterRange(int offset, int count) throws MyIllegalAddressException {\n+    this.parent.logDebug(this.log, \"Reading Input Registers. Address [\" + offset + \"] Count [\" + count + \"].\");\n+    Register[] registers = this.getRegisterRange(offset, count);\n+    Register[] result = new Register[registers.length];\n+    for (int i = 0; i < registers.length; i++) {\n+      result[i] = registers[i];\n+    }\n+    return result;\n+  }\n+\n+  @Override\n+  public synchronized Register[] getRegisterRange(int offset, int count) throws MyIllegalAddressException {\n+    this.parent.logDebug(this.log, \"Reading Registers. Address [\" + offset + \"] Count [\" + count + \"].\");\n+    SortedMap<Integer, ModbusRecord> records = this.parent.records.subMap(offset, offset + count);\n+    Register[] result = new Register[count];\n+    for (int i = 0; i < count; ) {\n+      // Get record for modbus address\n+      int ref = i + offset;\n+      ModbusRecord record = records.get(ref);\n+      if (record == null) {\n+        throw new MyIllegalAddressException(this, \"Record for Modbus address [\" + ref + \"] is undefined.\");\n+      }\n+\n+      // Get Registers from Record\n+      Register[] registers = this.getRecordValueRegisters(record);\n+\n+      // make sure this Record fits\n+      if (result.length < i + registers.length) {\n+        throw new MyIllegalAddressException(this,\n+            \"Record for Modbus address [\" + ref + \"] does not fit in Result.\");\n+      }\n+      for (int j = 0; j < registers.length; j++) {\n+        result[i + j] = registers[j];\n+      }\n+\n+      // increase i by word length\n+      i += registers.length;\n+    }\n+    return result;\n+  }\n+\n+  @Override\n+  public synchronized Register getRegister(int ref) throws MyIllegalAddressException {\n+    this.parent.logDebug(this.log, \"Get Register. Address [\" + ref + \"].\");\n+    ModbusRecord record = this.parent.records.get(ref);\n+\n+    // make sure the ModbusRecord is available\n+    if (record == null) {\n+      throw new MyIllegalAddressException(this,\n+          \"Record for Modbus address [\" + ref + \"] is not available.\");\n+    }\n+\n+    // Get Registers from Record\n+    Register[] registers = this.getRecordValueRegisters(record);\n+\n+    // make sure this Record requires only one Register/Word\n+    if (registers.length > 1) {\n+      throw new MyIllegalAddressException(this,\n+          \"Record for Modbus address [\" + ref + \"] requires more than one Register.\");\n+    }\n+\n+    return registers[0];\n+  }\n+\n+  /**\n+   * Get value as byte-array and convert it to InputRegisters.\n+   *\n+   * @param record the record\n+   * @return the Register\n+   */\n+  private Register[] getRecordValueRegisters(ModbusRecord record) {\n+    MyRegister[] result = new MyRegister[record.getType().getWords()];\n+    OpenemsComponent component = this.parent.getComponent(record.getComponentId());\n+    byte[] value = record.getValue(component);\n+    for (int j = 0; j < value.length / 2; j++) {\n+      result[j] = new MyRegister(j, value[j * 2], value[j * 2 + 1], //\n+          /*\n+           * On Set-Value event:\n+           */\n+          (register) -> {\n+            record.writeValue(component, register.getIndex(), register.getByte1(), register.getByte2());\n+          });\n+    }\n+    return result;\n+  }\n+\n+  /**********************************************\n+   * From here, the methods are not implemented!.\n+   **********************************************\n+   */\n+\n+  @Override\n+  public synchronized InputRegister getInputRegister(int ref) {\n+    this.parent.logWarn(this.log, \"getInputRegister is not implemented\");\n+    return new SimpleInputRegister(0);\n+  }\n+\n+  @Override\n+  public synchronized int getInputRegisterCount() {\n+    this.parent.logWarn(this.log, \"getInputRegisterCount is not implemented\");\n+    return 0;\n+  }\n+\n+  @Override\n+  public synchronized DigitalOut[] getDigitalOutRange(int offset, int count) {\n+    this.parent.logWarn(this.log, \"getDigitalOutRange is not implemented\");\n+    DigitalOut[] result = new DigitalOut[count];\n+    for (int i = 0; i < count; i++) {\n+      result[i] = new SimpleDigitalOut(false);\n+    }\n+    return result;\n+  }\n+\n+  @Override\n+  public synchronized DigitalOut getDigitalOut(int ref) {\n+    this.parent.logWarn(this.log, \"getDigitalOut is not implemented\");\n+    return new SimpleDigitalOut(false);\n+  }\n+\n+  @Override\n+  public synchronized int getDigitalOutCount() {\n+    this.parent.logWarn(this.log, \"getDigitalOutCount is not implemented\");\n+    return 0;\n+  }\n+\n+  @Override\n+  public synchronized DigitalIn[] getDigitalInRange(int offset, int count) {\n+    this.parent.logWarn(this.log, \"getDigitalInRange is not implemented\");\n+    DigitalIn[] result = new DigitalIn[count];\n+    for (int i = 0; i < count; i++) {\n+      result[i] = new SimpleDigitalIn(false);\n+    }\n+    return result;\n+  }\n+\n+  @Override\n+  public synchronized DigitalIn getDigitalIn(int ref) {\n+    this.parent.logWarn(this.log, \"getDigitalInRange is not implemented\");\n+    return new SimpleDigitalIn(false);\n+  }\n+\n+  @Override\n+  public synchronized int getDigitalInCount() {\n+    this.parent.logWarn(this.log, \"getDigitalInRange is not implemented\");\n+    return 0;\n+  }\n+\n+  @Override\n+  public synchronized int getRegisterCount() {\n+    this.parent.logWarn(this.log, \"getRegisterCount is not implemented\");\n+    return 0;\n+  }\n+\n+  @Override\n+  public synchronized File getFile(int ref) {\n+    this.parent.logWarn(this.log, \"getFile is not implemented\");\n+    return null;\n+  }\n+\n+  @Override\n+  public synchronized File getFileByNumber(int ref) {\n+    this.parent.logWarn(this.log, \"getFileByNumber is not implemented\");\n+    return null;\n+  }\n+\n+  @Override\n+  public synchronized int getFileCount() {\n+    this.parent.logWarn(this.log, \"getFileByNumber is not implemented\");\n+    return 0;\n+  }\n+\n+  @Override\n+  public synchronized FIFO getFIFO(int ref) {\n+    this.parent.logWarn(this.log, \"getFIFO is not implemented\");\n+    return null;\n+  }\n+\n+  @Override\n+  public synchronized FIFO getFIFOByAddress(int ref) {\n+    this.parent.logWarn(this.log, \"getFIFOByAddress is not implemented\");\n+    return null;\n+  }\n+\n+  @Override\n+  public synchronized int getFIFOCount() {\n+    this.parent.logWarn(this.log, \"getFIFOCount is not implemented\");\n+    return 0;\n+  }\n \n }\n",
            "diff_size": 197
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "88",
                    "column": "1",
                    "severity": "warning",
                    "message": "Comment has incorrect indentation level 0, expected is 2, indentation should be the same level as line 89.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "112",
                    "column": "41",
                    "severity": "warning",
                    "message": "Block comment has incorrect indentation level 5, expected is 9, indentation should be the same level as line 114.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "121",
                    "column": "9",
                    "severity": "warning",
                    "message": "Block comment has incorrect indentation level 1, expected is 0, indentation should be the same level as line 125.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/OpenEMS-openems/errored/1/30/MyProcessImage.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/OpenEMS-openems/naturalize/30/MyProcessImage.java\nindex c2572c6784c..0a0eaa85cab 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/OpenEMS-openems/errored/1/30/MyProcessImage.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/OpenEMS-openems/naturalize/30/MyProcessImage.java\n@@ -80,12 +80,12 @@ public class MyProcessImage implements ProcessImage {\n \t\tModbusRecord record = this.parent.records.get(ref);\n \n \t\t// make sure the ModbusRecord is available\n-\t\tif(record == null) {\n+\t\tif (record == null) {\n \t\t\tthrow new MyIllegalAddressException(this,\n \t\t\t\t\t\"Record for Modbus address [\" + ref + \"] is not available.\");\n \t\t}\n-\t\t\n-\t\t// Get Registers from Record\n+\n+// Get Registers from Record\n \t\tRegister[] registers = this.getRecordValueRegisters(record);\n \n \t\t// make sure this Record requires only one Register/Word\n@@ -111,8 +111,7 @@ public class MyProcessImage implements ProcessImage {\n \t\t\tresult[j] = new MyRegister(j, value[j * 2], value[j * 2 + 1], //\n \t\t\t\t\t/*\n \t\t\t\t\t * On Set-Value event:\n-\t\t\t\t\t */\n-\t\t\t\t\t(register) -> {\n+\t\t\t\t\t */ (register) -> {\n \t\t\t\t\t\trecord.writeValue(component, register.getIndex(), register.getByte1(), register.getByte2());\n \t\t\t\t\t});\n \t\t}\n@@ -123,8 +122,7 @@ public class MyProcessImage implements ProcessImage {\n \t * From here, the methods are not implemented!.\n \t **********************************************\n \t */\n-\n-\t@Override\n+@Override\n \tpublic synchronized InputRegister getInputRegister(int ref) {\n \t\tthis.parent.logWarn(this.log, \"getInputRegister is not implemented\");\n \t\treturn new SimpleInputRegister(0);\n@@ -222,4 +220,4 @@ public class MyProcessImage implements ProcessImage {\n \t\treturn 0;\n \t}\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 8
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "126",
                    "column": "6",
                    "severity": "warning",
                    "message": "Block comment has incorrect indentation level 5, expected is 30, indentation should be the same level as line 129.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/OpenEMS-openems/errored/1/30/MyProcessImage.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/OpenEMS-openems/codebuff/30/MyProcessImage.java\nindex c2572c6784c..90c5c68034e 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/OpenEMS-openems/errored/1/30/MyProcessImage.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/OpenEMS-openems/codebuff/30/MyProcessImage.java\n@@ -1,10 +1,8 @@\n package io.openems.edge.controller.api.modbus;\n \n import java.util.SortedMap;\n-\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-\n import com.ghgande.j2mod.modbus.procimg.DigitalIn;\n import com.ghgande.j2mod.modbus.procimg.DigitalOut;\n import com.ghgande.j2mod.modbus.procimg.FIFO;\n@@ -15,211 +13,260 @@ import com.ghgande.j2mod.modbus.procimg.Register;\n import com.ghgande.j2mod.modbus.procimg.SimpleDigitalIn;\n import com.ghgande.j2mod.modbus.procimg.SimpleDigitalOut;\n import com.ghgande.j2mod.modbus.procimg.SimpleInputRegister;\n-\n import io.openems.edge.common.component.OpenemsComponent;\n import io.openems.edge.common.modbusslave.ModbusRecord;\n \n /**\n  * This implementation answers Modbus-TCP Slave requests.\n  */\n+\n public class MyProcessImage implements ProcessImage {\n \n-\tprivate final Logger log = LoggerFactory.getLogger(MyProcessImage.class);\n-\n-\tprotected final AbstractModbusTcpApi parent;\n-\n-\tprotected MyProcessImage(AbstractModbusTcpApi parent) {\n-\t\tthis.parent = parent;\n-\t}\n-\n-\t@Override\n-\tpublic synchronized InputRegister[] getInputRegisterRange(int offset, int count) throws MyIllegalAddressException {\n-\t\tthis.parent.logDebug(this.log, \"Reading Input Registers. Address [\" + offset + \"] Count [\" + count + \"].\");\n-\t\tRegister[] registers = this.getRegisterRange(offset, count);\n-\t\tRegister[] result = new Register[registers.length];\n-\t\tfor (int i = 0; i < registers.length; i++) {\n-\t\t\tresult[i] = registers[i];\n-\t\t}\n-\t\treturn result;\n-\t}\n-\n-\t@Override\n-\tpublic synchronized Register[] getRegisterRange(int offset, int count) throws MyIllegalAddressException {\n-\t\tthis.parent.logDebug(this.log, \"Reading Registers. Address [\" + offset + \"] Count [\" + count + \"].\");\n-\t\tSortedMap<Integer, ModbusRecord> records = this.parent.records.subMap(offset, offset + count);\n-\t\tRegister[] result = new Register[count];\n-\t\tfor (int i = 0; i < count;) {\n-\t\t\t// Get record for modbus address\n-\t\t\tint ref = i + offset;\n-\t\t\tModbusRecord record = records.get(ref);\n-\t\t\tif (record == null) {\n-\t\t\t\tthrow new MyIllegalAddressException(this, \"Record for Modbus address [\" + ref + \"] is undefined.\");\n-\t\t\t}\n-\n-\t\t\t// Get Registers from Record\n-\t\t\tRegister[] registers = this.getRecordValueRegisters(record);\n-\n-\t\t\t// make sure this Record fits\n-\t\t\tif (result.length < i + registers.length) {\n-\t\t\t\tthrow new MyIllegalAddressException(this,\n-\t\t\t\t\t\t\"Record for Modbus address [\" + ref + \"] does not fit in Result.\");\n-\t\t\t}\n-\t\t\tfor (int j = 0; j < registers.length; j++) {\n-\t\t\t\tresult[i + j] = registers[j];\n-\t\t\t}\n-\n-\t\t\t// increase i by word length\n-\t\t\ti += registers.length;\n-\t\t}\n-\t\treturn result;\n-\t}\n-\n-\t@Override\n-\tpublic synchronized Register getRegister(int ref) throws MyIllegalAddressException {\n-\t\tthis.parent.logDebug(this.log, \"Get Register. Address [\" + ref + \"].\");\n-\t\tModbusRecord record = this.parent.records.get(ref);\n-\n-\t\t// make sure the ModbusRecord is available\n-\t\tif(record == null) {\n-\t\t\tthrow new MyIllegalAddressException(this,\n-\t\t\t\t\t\"Record for Modbus address [\" + ref + \"] is not available.\");\n-\t\t}\n-\t\t\n-\t\t// Get Registers from Record\n-\t\tRegister[] registers = this.getRecordValueRegisters(record);\n-\n-\t\t// make sure this Record requires only one Register/Word\n-\t\tif (registers.length > 1) {\n-\t\t\tthrow new MyIllegalAddressException(this,\n-\t\t\t\t\t\"Record for Modbus address [\" + ref + \"] requires more than one Register.\");\n-\t\t}\n-\n-\t\treturn registers[0];\n-\t}\n-\n-\t/**\n-\t * Get value as byte-array and convert it to InputRegisters.\n-\t * \n-\t * @param record the record\n-\t * @return the Register\n-\t */\n-\tprivate Register[] getRecordValueRegisters(ModbusRecord record) {\n-\t\tMyRegister[] result = new MyRegister[record.getType().getWords()];\n-\t\tOpenemsComponent component = this.parent.getComponent(record.getComponentId());\n-\t\tbyte[] value = record.getValue(component);\n-\t\tfor (int j = 0; j < value.length / 2; j++) {\n-\t\t\tresult[j] = new MyRegister(j, value[j * 2], value[j * 2 + 1], //\n-\t\t\t\t\t/*\n-\t\t\t\t\t * On Set-Value event:\n-\t\t\t\t\t */\n-\t\t\t\t\t(register) -> {\n-\t\t\t\t\t\trecord.writeValue(component, register.getIndex(), register.getByte1(), register.getByte2());\n-\t\t\t\t\t});\n-\t\t}\n-\t\treturn result;\n-\t}\n-\n-\t/**********************************************\n-\t * From here, the methods are not implemented!.\n-\t **********************************************\n-\t */\n-\n-\t@Override\n-\tpublic synchronized InputRegister getInputRegister(int ref) {\n-\t\tthis.parent.logWarn(this.log, \"getInputRegister is not implemented\");\n-\t\treturn new SimpleInputRegister(0);\n-\t}\n-\n-\t@Override\n-\tpublic synchronized int getInputRegisterCount() {\n-\t\tthis.parent.logWarn(this.log, \"getInputRegisterCount is not implemented\");\n-\t\treturn 0;\n-\t}\n-\n-\t@Override\n-\tpublic synchronized DigitalOut[] getDigitalOutRange(int offset, int count) {\n-\t\tthis.parent.logWarn(this.log, \"getDigitalOutRange is not implemented\");\n-\t\tDigitalOut[] result = new DigitalOut[count];\n-\t\tfor (int i = 0; i < count; i++) {\n-\t\t\tresult[i] = new SimpleDigitalOut(false);\n-\t\t}\n-\t\treturn result;\n-\t}\n-\n-\t@Override\n-\tpublic synchronized DigitalOut getDigitalOut(int ref) {\n-\t\tthis.parent.logWarn(this.log, \"getDigitalOut is not implemented\");\n-\t\treturn new SimpleDigitalOut(false);\n-\t}\n-\n-\t@Override\n-\tpublic synchronized int getDigitalOutCount() {\n-\t\tthis.parent.logWarn(this.log, \"getDigitalOutCount is not implemented\");\n-\t\treturn 0;\n-\t}\n-\n-\t@Override\n-\tpublic synchronized DigitalIn[] getDigitalInRange(int offset, int count) {\n-\t\tthis.parent.logWarn(this.log, \"getDigitalInRange is not implemented\");\n-\t\tDigitalIn[] result = new DigitalIn[count];\n-\t\tfor (int i = 0; i < count; i++) {\n-\t\t\tresult[i] = new SimpleDigitalIn(false);\n-\t\t}\n-\t\treturn result;\n-\t}\n-\n-\t@Override\n-\tpublic synchronized DigitalIn getDigitalIn(int ref) {\n-\t\tthis.parent.logWarn(this.log, \"getDigitalInRange is not implemented\");\n-\t\treturn new SimpleDigitalIn(false);\n-\t}\n-\n-\t@Override\n-\tpublic synchronized int getDigitalInCount() {\n-\t\tthis.parent.logWarn(this.log, \"getDigitalInRange is not implemented\");\n-\t\treturn 0;\n-\t}\n-\n-\t@Override\n-\tpublic synchronized int getRegisterCount() {\n-\t\tthis.parent.logWarn(this.log, \"getRegisterCount is not implemented\");\n-\t\treturn 0;\n-\t}\n-\n-\t@Override\n-\tpublic synchronized File getFile(int ref) {\n-\t\tthis.parent.logWarn(this.log, \"getFile is not implemented\");\n-\t\treturn null;\n-\t}\n-\n-\t@Override\n-\tpublic synchronized File getFileByNumber(int ref) {\n-\t\tthis.parent.logWarn(this.log, \"getFileByNumber is not implemented\");\n-\t\treturn null;\n-\t}\n-\n-\t@Override\n-\tpublic synchronized int getFileCount() {\n-\t\tthis.parent.logWarn(this.log, \"getFileByNumber is not implemented\");\n-\t\treturn 0;\n-\t}\n-\n-\t@Override\n-\tpublic synchronized FIFO getFIFO(int ref) {\n-\t\tthis.parent.logWarn(this.log, \"getFIFO is not implemented\");\n-\t\treturn null;\n-\t}\n-\n-\t@Override\n-\tpublic synchronized FIFO getFIFOByAddress(int ref) {\n-\t\tthis.parent.logWarn(this.log, \"getFIFOByAddress is not implemented\");\n-\t\treturn null;\n-\t}\n-\n-\t@Override\n-\tpublic synchronized int getFIFOCount() {\n-\t\tthis.parent.logWarn(this.log, \"getFIFOCount is not implemented\");\n-\t\treturn 0;\n-\t}\n-\n-}\n+ private final Logger log = LoggerFactory.getLogger(MyProcessImage.class);\n+\n+\n+ protected final AbstractModbusTcpApi parent;\n+\n+ protected MyProcessImage(AbstractModbusTcpApi parent) {\n+  this.parent = parent;\n+ }\n+\n+ @Override\n+ public synchronized InputRegister[] getInputRegisterRange(int offset, int count) throws MyIllegalAddressException {\n+  this.parent.logDebug(this.log,\n+                       \"Reading Input Registers. Address [\" + offset + \"] Count [\" + count + \"].\");\n+\n+  Register[] registers = this.getRegisterRange(offset,\n+   count);\n+  Register[] result = new Register[registers.length];\n+  for (int i = 0; i < registers.length; i++) {\n+   result[i] = registers[i];\n+  }\n+  return result;\n+ }\n+\n+ @Override\n+ public synchronized Register[] getRegisterRange(int offset, int count) throws MyIllegalAddressException {\n+  this.parent.logDebug(this.log,\n+                       \"Reading Registers. Address [\" + offset + \"] Count [\" + count + \"].\");\n+\n+  SortedMap<Integer, ModbusRecord> records = this.parent.records.subMap(offset,\n+   offset + count);\n+  Register[] result = new Register[count];\n+  for (int i = 0; i < count;) {\n+   // Get record for modbus address\n+   int ref = i + offset;\n+   ModbusRecord record = records.get(ref);\n+   if (record == null) {\n+    throw new MyIllegalAddressException(this,\n+                                        \"Record for Modbus address [\" + ref + \"] is undefined.\");\n+   }\n+\n+   // Get Registers from Record\n+   Register[] registers = this.getRecordValueRegisters(record);\n+\n+   // make sure this Record fits\n+   if (result.length < i + registers.length) {\n+    throw new MyIllegalAddressException(this,\n+                                        \"Record for Modbus address [\" + ref + \"] does not fit in Result.\");\n+   }\n+\n+\n+   for (int j = 0; j < registers.length; j++) {\n+    result[i + j] = registers[j];\n+   }\n+\n+   // increase i by word length\n+   i += registers.length;\n+  }\n+  return result;\n+ }\n+\n+ @Override\n+ public synchronized Register getRegister(int ref) throws MyIllegalAddressException {\n+  this.parent.logDebug(this.log,\n+                       \"Get Register. Address [\" + ref + \"].\");\n+\n+  ModbusRecord record = this.parent.records.get(ref);\n+\n+  // make sure the ModbusRecord is available\n+  if (record == null) {\n+   throw new MyIllegalAddressException(this,\n+                                       \"Record for Modbus address [\" + ref + \"] is not available.\");\n+  }\n+  \n+  // Get Registers from Record\n+  Register[] registers = this.getRecordValueRegisters(record);\n+\n+  // make sure this Record requires only one Register/Word\n+  if (registers.length > 1) {\n+   throw new MyIllegalAddressException(this,\n+                                       \"Record for Modbus address [\" + ref + \"] requires more than one Register.\");\n+  }\n+  return registers[0];\n+ }\n+\n+ /**\n+  * Get value as byte-array and convert it to InputRegisters.\n+  * \n+  * @param record the record\n+  * @return the Register\n+  */\n+\n+\n+ private Register[] getRecordValueRegisters(ModbusRecord record) {\n+  MyRegister[] result = new MyRegister[record.getType()\n+   .getWords()];\n+  OpenemsComponent component = this.parent.getComponent(record.getComponentId());\n+  byte[] value = record.getValue(component);\n+  for (int j = 0; j < value.length / 2; j++) {\n+   result[j] = new MyRegister(j,\n+value[j * 2],\n+value[j * 2 + 1], //\n+     /*\n+      * On Set-Value event:\n+      */\n+                              (register) -> {\n+                               record.writeValue(component,\n+                                register.getIndex(),\n+                                 register.getByte1(),\n+                                  register.getByte2());\n+                              });\n+  }\n+  return result;\n+ }\n+\n+ /**********************************************\n+  * From here, the methods are not implemented!.\n+  **********************************************\n+  */\n+\n+ @Override\n+ public synchronized InputRegister getInputRegister(int ref) {\n+  this.parent.logWarn(this.log,\n+                      \"getInputRegister is not implemented\");\n+\n+  return new SimpleInputRegister(0);\n+ }\n+\n+ @Override\n+ public synchronized int getInputRegisterCount() {\n+  this.parent.logWarn(this.log,\n+                      \"getInputRegisterCount is not implemented\");\n+\n+  return 0;\n+ }\n+\n+ @Override\n+ public synchronized DigitalOut[] getDigitalOutRange(int offset, int count) {\n+  this.parent.logWarn(this.log,\n+                      \"getDigitalOutRange is not implemented\");\n+\n+  DigitalOut[] result = new DigitalOut[count];\n+  for (int i = 0; i < count; i++) {\n+   result[i] = new SimpleDigitalOut(false);\n+  }\n+  return result;\n+ }\n+\n+ @Override\n+ public synchronized DigitalOut getDigitalOut(int ref) {\n+  this.parent.logWarn(this.log,\n+                      \"getDigitalOut is not implemented\");\n+\n+  return new SimpleDigitalOut(false);\n+ }\n+\n+ @Override\n+ public synchronized int getDigitalOutCount() {\n+  this.parent.logWarn(this.log,\n+                      \"getDigitalOutCount is not implemented\");\n+\n+  return 0;\n+ }\n+\n+ @Override\n+ public synchronized DigitalIn[] getDigitalInRange(int offset, int count) {\n+  this.parent.logWarn(this.log,\n+                      \"getDigitalInRange is not implemented\");\n+\n+  DigitalIn[] result = new DigitalIn[count];\n+  for (int i = 0; i < count; i++) {\n+   result[i] = new SimpleDigitalIn(false);\n+  }\n+  return result;\n+ }\n+\n+ @Override\n+ public synchronized DigitalIn getDigitalIn(int ref) {\n+  this.parent.logWarn(this.log,\n+                      \"getDigitalInRange is not implemented\");\n+\n+  return new SimpleDigitalIn(false);\n+ }\n+\n+ @Override\n+ public synchronized int getDigitalInCount() {\n+  this.parent.logWarn(this.log,\n+                      \"getDigitalInRange is not implemented\");\n+\n+  return 0;\n+ }\n+\n+ @Override\n+ public synchronized int getRegisterCount() {\n+  this.parent.logWarn(this.log,\n+                      \"getRegisterCount is not implemented\");\n+\n+  return 0;\n+ }\n+\n+ @Override\n+ public synchronized File getFile(int ref) {\n+  this.parent.logWarn(this.log,\n+                      \"getFile is not implemented\");\n+\n+  return null;\n+ }\n+\n+ @Override\n+ public synchronized File getFileByNumber(int ref) {\n+  this.parent.logWarn(this.log,\n+                      \"getFileByNumber is not implemented\");\n+\n+  return null;\n+ }\n+\n+ @Override\n+ public synchronized int getFileCount() {\n+  this.parent.logWarn(this.log,\n+                      \"getFileByNumber is not implemented\");\n+\n+  return 0;\n+ }\n+\n+ @Override\n+ public synchronized FIFO getFIFO(int ref) {\n+  this.parent.logWarn(this.log,\n+                      \"getFIFO is not implemented\");\n+\n+  return null;\n+ }\n+\n+ @Override\n+ public synchronized FIFO getFIFOByAddress(int ref) {\n+  this.parent.logWarn(this.log,\n+                      \"getFIFOByAddress is not implemented\");\n+\n+  return null;\n+ }\n+\n+ @Override\n+ public synchronized int getFIFOCount() {\n+  this.parent.logWarn(this.log,\n+                      \"getFIFOCount is not implemented\");\n+\n+  return 0;\n+ }\n+\n+}\n\\ No newline at end of file\n",
            "diff_size": 252
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "83",
                    "column": "17",
                    "severity": "warning",
                    "message": "WhitespaceAround: 'if' is not followed by whitespace. Empty blocks may only be represented as {} when not part of a multi-block statement (4.1.3)",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "83",
                    "column": "17",
                    "severity": "warning",
                    "message": "WhitespaceAround: 'if' is not followed by whitespace. Empty blocks may only be represented as {} when not part of a multi-block statement (4.1.3)",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ],
    "repaired_by": [
        "intellij"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}