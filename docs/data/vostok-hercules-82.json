{
    "project_name": "vostok-hercules",
    "error_id": "82",
    "information": {
        "errors": [
            {
                "line": "115",
                "severity": "warning",
                "message": "Line is longer than 160 characters (found 181).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": "                                    if (originalContentLength.isError()) {\n                                        tryComplete(HttpStatusCodes.BAD_REQUEST, callback);\n                                        LOGGER.warn(\"Request has header Content-Encoding, but there is no valid Original-Content-Length: \" + originalContentLength.result().error());\n                                        return;\n                                    }\n                                    requestUncompressedSizeBytes = originalContentLength.get();",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "115",
                    "severity": "warning",
                    "message": "Line is longer than 160 characters (found 181).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/82/SendRequestProcessor.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/intellij/82/SendRequestProcessor.java\nindex 18ecec39ae9..8a3d5a7d907 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/82/SendRequestProcessor.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/intellij/82/SendRequestProcessor.java\n@@ -33,274 +33,274 @@ import java.util.concurrent.atomic.AtomicInteger;\n  * @author Gregory Koshelev\n  */\n public class SendRequestProcessor {\n-    private static final Logger LOGGER = LoggerFactory.getLogger(SendRequestProcessor.class);\n+  private static final Logger LOGGER = LoggerFactory.getLogger(SendRequestProcessor.class);\n \n-    private static final Parameter<Integer> ORIGINAL_CONTENT_LENGTH =\n-            Parameter.integerParameter(HttpHeaders.ORIGINAL_CONTENT_LENGTH).\n-                    required().\n-                    withValidator(IntegerValidators.range(0, 100 * 1024 * 1024)).\n-                    build();\n+  private static final Parameter<Integer> ORIGINAL_CONTENT_LENGTH =\n+    Parameter.integerParameter(HttpHeaders.ORIGINAL_CONTENT_LENGTH).\n+      required().\n+      withValidator(IntegerValidators.range(0, 100 * 1024 * 1024)).\n+      build();\n \n-    private final EventSender eventSender;\n-    private final TimeSource time;\n+  private final EventSender eventSender;\n+  private final TimeSource time;\n \n-    private final EventValidator eventValidator;\n-    private final Lz4Decompressor lz4Decompressor = new Lz4Decompressor();\n+  private final EventValidator eventValidator;\n+  private final Lz4Decompressor lz4Decompressor = new Lz4Decompressor();\n \n-    private final SendRequestMetrics metrics;\n+  private final SendRequestMetrics metrics;\n \n-    public SendRequestProcessor(Properties properties, EventSender eventSender, EventValidator eventValidator, MetricsCollector metricsCollector) {\n-        this(properties, eventSender, eventValidator, metricsCollector, TimeSource.SYSTEM);\n-    }\n+  public SendRequestProcessor(Properties properties, EventSender eventSender, EventValidator eventValidator, MetricsCollector metricsCollector) {\n+    this(properties, eventSender, eventValidator, metricsCollector, TimeSource.SYSTEM);\n+  }\n \n-    SendRequestProcessor(Properties properties, EventSender eventSender, EventValidator eventValidator, MetricsCollector metricsCollector, TimeSource time) {\n-        this.eventSender = eventSender;\n-        this.eventValidator = eventValidator;\n-        this.time = time;\n-        this.metrics = new SendRequestMetrics(PropertiesUtil.ofScope(properties, Scopes.METRICS), metricsCollector);\n-    }\n+  SendRequestProcessor(Properties properties, EventSender eventSender, EventValidator eventValidator, MetricsCollector metricsCollector, TimeSource time) {\n+    this.eventSender = eventSender;\n+    this.eventValidator = eventValidator;\n+    this.time = time;\n+    this.metrics = new SendRequestMetrics(PropertiesUtil.ofScope(properties, Scopes.METRICS), metricsCollector);\n+  }\n \n-    public void processAsync(HttpServerRequest request, SendRequestContext context, Callback callback) {\n-        new SendRequest(request, context).processAsync(callback);\n-    }\n+  public void processAsync(HttpServerRequest request, SendRequestContext context, Callback callback) {\n+    new SendRequest(request, context).processAsync(callback);\n+  }\n \n-    public class SendRequest {\n+  public class SendRequest {\n \n-        private final HttpServerRequest request;\n-        private final SendRequestContext context;\n+    private final HttpServerRequest request;\n+    private final SendRequestContext context;\n \n-        private volatile long receivingStartedAtMs = Long.MAX_VALUE;\n-        private volatile long receivingEndedAtMs;\n-        private volatile long decompressionTimeMs;\n-        private volatile long sendingEventsStartedAtMs = Long.MAX_VALUE;\n-        private volatile long sendingEventsEndedAtMs;\n+    private volatile long receivingStartedAtMs = Long.MAX_VALUE;\n+    private volatile long receivingEndedAtMs;\n+    private volatile long decompressionTimeMs;\n+    private volatile long sendingEventsStartedAtMs = Long.MAX_VALUE;\n+    private volatile long sendingEventsEndedAtMs;\n \n-        private volatile long requestCompletionTimestampMs;\n+    private volatile long requestCompletionTimestampMs;\n \n-        private volatile int requestCompressedSizeBytes;\n-        private volatile int requestUncompressedSizeBytes;\n+    private volatile int requestCompressedSizeBytes;\n+    private volatile int requestUncompressedSizeBytes;\n \n-        private volatile int totalEvents;\n+    private volatile int totalEvents;\n \n-        public SendRequest(HttpServerRequest request, SendRequestContext context) {\n-            this.request = request;\n-            this.context = context;\n-        }\n-\n-        /**\n-         * Asynchronously process the request and call completion callback when processing has been completed.\n-         *\n-         * @param callback completion callback\n-         */\n-        public void processAsync(Callback callback) {\n-            receivingStartedAtMs = time.milliseconds();\n-            try {\n-                request.readBodyAsync(\n-                        (r, bytes) -> r.dispatchAsync(() -> {\n-                            receivingEndedAtMs = time.milliseconds();\n-                            requestUncompressedSizeBytes = requestCompressedSizeBytes = bytes.length;\n-\n-                            ByteBuffer buffer = null;\n-                            try {\n-                                initMDC();\n-\n-                                String contentEncoding = request.getHeader(HttpHeaders.CONTENT_ENCODING);\n-                                if (contentEncoding == null) {\n-                                    buffer = ByteBuffer.wrap(bytes);\n-                                } else if (ContentEncodings.LZ4.equals(contentEncoding)) {\n-                                    Parameter<Integer>.ParameterValue originalContentLength =\n-                                            HeaderUtil.get(ORIGINAL_CONTENT_LENGTH, request);\n-                                    if (originalContentLength.isError()) {\n-                                        tryComplete(HttpStatusCodes.BAD_REQUEST, callback);\n-                                        LOGGER.warn(\"Request has header Content-Encoding, but there is no valid Original-Content-Length: \" + originalContentLength.result().error());\n-                                        return;\n-                                    }\n-                                    requestUncompressedSizeBytes = originalContentLength.get();\n-                                    buffer = decompressLz4(bytes, originalContentLength.get());\n-                                } else {\n-                                    tryComplete(HttpStatusCodes.UNSUPPORTED_MEDIA_TYPE, callback);\n-                                    return;\n-                                }\n-\n-                                sendEvents(buffer, callback);\n-                            } catch (RuntimeException ex) {\n-                                tryComplete(HttpStatusCodes.BAD_REQUEST, callback);\n-                                LOGGER.error(\"Cannot process request due to exception\", ex);\n-                            } finally {\n-                                if (buffer != null) {\n-                                    ByteBufferPool.release(buffer);\n-                                }\n-\n-                                cleanMDC();\n-                            }\n-                        }),\n-                        (r, exception) -> {\n-                            receivingEndedAtMs = time.milliseconds();\n-\n-                            tryComplete(exception.getStatusCodeOrDefault(HttpStatusCodes.INTERNAL_SERVER_ERROR), callback);\n-                            LOGGER.error(\"Request body was read with exception\", exception);\n-                        });\n-            } catch (Throwable throwable) {\n-                // Should never happened\n-                callback.call();\n-                LOGGER.error(\"Error on request body read full bytes\", throwable);\n-                throw throwable;\n-            }\n-        }\n+    public SendRequest(HttpServerRequest request, SendRequestContext context) {\n+      this.request = request;\n+      this.context = context;\n+    }\n \n-        private void sendEvents(ByteBuffer buffer, Callback callback) {\n-            ReaderIterator<Event> reader;\n+    /**\n+     * Asynchronously process the request and call completion callback when processing has been completed.\n+     *\n+     * @param callback completion callback\n+     */\n+    public void processAsync(Callback callback) {\n+      receivingStartedAtMs = time.milliseconds();\n+      try {\n+        request.readBodyAsync(\n+          (r, bytes) -> r.dispatchAsync(() -> {\n+            receivingEndedAtMs = time.milliseconds();\n+            requestUncompressedSizeBytes = requestCompressedSizeBytes = bytes.length;\n+\n+            ByteBuffer buffer = null;\n             try {\n-                reader = new ReaderIterator<>(new Decoder(buffer), EventReader.readTags(context.tags()));\n-            } catch (InvalidDataException ex) {\n-                tryComplete(HttpStatusCodes.BAD_REQUEST, callback);\n-                LOGGER.error(\"Request is malformed\", ex);\n+              initMDC();\n+\n+              String contentEncoding = request.getHeader(HttpHeaders.CONTENT_ENCODING);\n+              if (contentEncoding == null) {\n+                buffer = ByteBuffer.wrap(bytes);\n+              } else if (ContentEncodings.LZ4.equals(contentEncoding)) {\n+                Parameter<Integer>.ParameterValue originalContentLength =\n+                  HeaderUtil.get(ORIGINAL_CONTENT_LENGTH, request);\n+                if (originalContentLength.isError()) {\n+                  tryComplete(HttpStatusCodes.BAD_REQUEST, callback);\n+                  LOGGER.warn(\"Request has header Content-Encoding, but there is no valid Original-Content-Length: \" + originalContentLength.result().error());\n+                  return;\n+                }\n+                requestUncompressedSizeBytes = originalContentLength.get();\n+                buffer = decompressLz4(bytes, originalContentLength.get());\n+              } else {\n+                tryComplete(HttpStatusCodes.UNSUPPORTED_MEDIA_TYPE, callback);\n                 return;\n-            }\n+              }\n \n-            if (reader.getTotal() == 0) {\n-                tryComplete(HttpStatusCodes.OK, callback);\n-                return;\n+              sendEvents(buffer, callback);\n+            } catch (RuntimeException ex) {\n+              tryComplete(HttpStatusCodes.BAD_REQUEST, callback);\n+              LOGGER.error(\"Cannot process request due to exception\", ex);\n+            } finally {\n+              if (buffer != null) {\n+                ByteBufferPool.release(buffer);\n+              }\n+\n+              cleanMDC();\n             }\n+          }),\n+          (r, exception) -> {\n+            receivingEndedAtMs = time.milliseconds();\n+\n+            tryComplete(exception.getStatusCodeOrDefault(HttpStatusCodes.INTERNAL_SERVER_ERROR), callback);\n+            LOGGER.error(\"Request body was read with exception\", exception);\n+          });\n+      } catch (Throwable throwable) {\n+        // Should never happened\n+        callback.call();\n+        LOGGER.error(\"Error on request body read full bytes\", throwable);\n+        throw throwable;\n+      }\n+    }\n \n-            AtomicInteger pendingEvents = new AtomicInteger(reader.getTotal());\n-            AtomicBoolean processed = new AtomicBoolean(false);\n-            totalEvents = reader.getTotal();\n-            sendingEventsStartedAtMs = time.milliseconds();\n-            while (reader.hasNext()) {\n-                Event event;\n-                try {\n-                    event = reader.next();\n-                    if (!eventValidator.validate(event)) {\n-                        if (processed.compareAndSet(false, true)) {\n-                            tryComplete(HttpStatusCodes.BAD_REQUEST, callback);\n-                        }\n-                        //TODO: Metrics are coming!\n-                        LOGGER.warn(\"Invalid event data\");\n-                        return;\n-                    }\n-                } catch (Exception ex) {\n-                    if (processed.compareAndSet(false, true)) {\n-                        tryComplete(HttpStatusCodes.BAD_REQUEST, callback);\n-                    }\n-                    LOGGER.error(\"Exception on validation event\", ex);\n-                    //TODO: Metrics are coming!\n-                    return;\n-                }\n-                if (!context.validator().validate(event)) {\n-                    //TODO: should to log filtered events\n-                    if (pendingEvents.decrementAndGet() == 0 && processed.compareAndSet(false, true)) {\n-                        if (!isAsync()) {\n-                            tryComplete(HttpStatusCodes.OK, callback);\n-                        } else {\n-                            callback.call();\n-                        }\n-                    }\n-                    continue;\n-                }\n-                eventSender.send(\n-                        event,\n-                        event.getUuid(),//TODO: Think hard about this!\n-                        context.stream(),\n-                        context.partitions(),\n-                        context.shardingKey(),\n-                        () -> {\n-                            if (pendingEvents.decrementAndGet() == 0 && processed.compareAndSet(false, true)) {\n-                                if (!isAsync()) {\n-                                    tryComplete(HttpStatusCodes.OK, callback);\n-                                } else {\n-                                    callback.call();\n-                                }\n-                            }\n-                        },\n-                        () -> {\n-                            if (processed.compareAndSet(false, true)) {\n-                                if (!isAsync()) {\n-                                    tryComplete(HttpStatusCodes.INTERNAL_SERVER_ERROR, callback);\n-                                } else {\n-                                    callback.call();\n-                                }\n-                            }\n-                        }\n-                );\n+    private void sendEvents(ByteBuffer buffer, Callback callback) {\n+      ReaderIterator<Event> reader;\n+      try {\n+        reader = new ReaderIterator<>(new Decoder(buffer), EventReader.readTags(context.tags()));\n+      } catch (InvalidDataException ex) {\n+        tryComplete(HttpStatusCodes.BAD_REQUEST, callback);\n+        LOGGER.error(\"Request is malformed\", ex);\n+        return;\n+      }\n+\n+      if (reader.getTotal() == 0) {\n+        tryComplete(HttpStatusCodes.OK, callback);\n+        return;\n+      }\n+\n+      AtomicInteger pendingEvents = new AtomicInteger(reader.getTotal());\n+      AtomicBoolean processed = new AtomicBoolean(false);\n+      totalEvents = reader.getTotal();\n+      sendingEventsStartedAtMs = time.milliseconds();\n+      while (reader.hasNext()) {\n+        Event event;\n+        try {\n+          event = reader.next();\n+          if (!eventValidator.validate(event)) {\n+            if (processed.compareAndSet(false, true)) {\n+              tryComplete(HttpStatusCodes.BAD_REQUEST, callback);\n             }\n-            sendingEventsEndedAtMs = time.milliseconds();\n-            if (isAsync()) {\n-                tryComplete(HttpStatusCodes.OK, Callback.empty());\n+            //TODO: Metrics are coming!\n+            LOGGER.warn(\"Invalid event data\");\n+            return;\n+          }\n+        } catch (Exception ex) {\n+          if (processed.compareAndSet(false, true)) {\n+            tryComplete(HttpStatusCodes.BAD_REQUEST, callback);\n+          }\n+          LOGGER.error(\"Exception on validation event\", ex);\n+          //TODO: Metrics are coming!\n+          return;\n+        }\n+        if (!context.validator().validate(event)) {\n+          //TODO: should to log filtered events\n+          if (pendingEvents.decrementAndGet() == 0 && processed.compareAndSet(false, true)) {\n+            if (!isAsync()) {\n+              tryComplete(HttpStatusCodes.OK, callback);\n+            } else {\n+              callback.call();\n             }\n+          }\n+          continue;\n         }\n-\n-        public void tryComplete(int code, Callback callback) {\n-            try {\n-                requestCompletionTimestampMs = time.milliseconds();\n-                request.complete(code);\n-            } catch (Exception ex) {\n-                LOGGER.error(\"Error on request completion\", ex);\n-            } finally {\n+        eventSender.send(\n+          event,\n+          event.getUuid(),//TODO: Think hard about this!\n+          context.stream(),\n+          context.partitions(),\n+          context.shardingKey(),\n+          () -> {\n+            if (pendingEvents.decrementAndGet() == 0 && processed.compareAndSet(false, true)) {\n+              if (!isAsync()) {\n+                tryComplete(HttpStatusCodes.OK, callback);\n+              } else {\n                 callback.call();\n-                metrics.update(this, code);\n+              }\n             }\n-        }\n+          },\n+          () -> {\n+            if (processed.compareAndSet(false, true)) {\n+              if (!isAsync()) {\n+                tryComplete(HttpStatusCodes.INTERNAL_SERVER_ERROR, callback);\n+              } else {\n+                callback.call();\n+              }\n+            }\n+          }\n+        );\n+      }\n+      sendingEventsEndedAtMs = time.milliseconds();\n+      if (isAsync()) {\n+        tryComplete(HttpStatusCodes.OK, Callback.empty());\n+      }\n+    }\n \n-        public boolean isAsync() {\n-            return context.isAsync();\n-        }\n+    public void tryComplete(int code, Callback callback) {\n+      try {\n+        requestCompletionTimestampMs = time.milliseconds();\n+        request.complete(code);\n+      } catch (Exception ex) {\n+        LOGGER.error(\"Error on request completion\", ex);\n+      } finally {\n+        callback.call();\n+        metrics.update(this, code);\n+      }\n+    }\n \n-        public long receivingTimeMs() {\n-            return Math.max(receivingEndedAtMs - receivingStartedAtMs, 0L);\n-        }\n+    public boolean isAsync() {\n+      return context.isAsync();\n+    }\n \n-        public long decompressionTimeMs() {\n-            return decompressionTimeMs;\n-        }\n+    public long receivingTimeMs() {\n+      return Math.max(receivingEndedAtMs - receivingStartedAtMs, 0L);\n+    }\n \n-        public long sendingEventsTimeMs() {\n-            return Math.max(sendingEventsEndedAtMs - sendingEventsStartedAtMs, 0L);\n-        }\n+    public long decompressionTimeMs() {\n+      return decompressionTimeMs;\n+    }\n \n-        public long processingTimeMs() {\n-            return Math.max(requestCompletionTimestampMs - context.requestTimestampMs(), 0L);\n-        }\n+    public long sendingEventsTimeMs() {\n+      return Math.max(sendingEventsEndedAtMs - sendingEventsStartedAtMs, 0L);\n+    }\n \n-        public int requestCompressedSizeBytes() {\n-            return requestCompressedSizeBytes;\n-        }\n+    public long processingTimeMs() {\n+      return Math.max(requestCompletionTimestampMs - context.requestTimestampMs(), 0L);\n+    }\n \n-        public int requestUncompressedSizeBytes() {\n-            return requestUncompressedSizeBytes;\n-        }\n+    public int requestCompressedSizeBytes() {\n+      return requestCompressedSizeBytes;\n+    }\n \n-        public int totalEvents() {\n-            return totalEvents;\n-        }\n+    public int requestUncompressedSizeBytes() {\n+      return requestUncompressedSizeBytes;\n+    }\n \n-        public String stream() {\n-            return context.stream();\n-        }\n+    public int totalEvents() {\n+      return totalEvents;\n+    }\n \n-        private ByteBuffer decompressLz4(byte[] bytes, int originalContentLength) {\n-            ByteBuffer buffer = ByteBufferPool.acquire(originalContentLength);\n-            decompressionTimeMs = TimeSource.SYSTEM.measureMs(() -> lz4Decompressor.decompress(bytes, buffer));\n-            return buffer;\n-        }\n+    public String stream() {\n+      return context.stream();\n+    }\n \n-        private String getProtectedApiKey() {\n-            String apiKey = request.getHeader(\"apiKey\");\n-            int pos = apiKey.lastIndexOf('_') + 1;\n-            if (pos > 0) {\n-                return StringUtil.mask(apiKey, '*', pos);\n-            }\n-            return StringUtil.mask(apiKey, '*', apiKey.length() / 2);\n-        }\n+    private ByteBuffer decompressLz4(byte[] bytes, int originalContentLength) {\n+      ByteBuffer buffer = ByteBufferPool.acquire(originalContentLength);\n+      decompressionTimeMs = TimeSource.SYSTEM.measureMs(() -> lz4Decompressor.decompress(bytes, buffer));\n+      return buffer;\n+    }\n \n-        private void initMDC() {\n-            MDC.put(\"stream\", stream());\n-            MDC.put(\"apiKey\", getProtectedApiKey());\n-        }\n+    private String getProtectedApiKey() {\n+      String apiKey = request.getHeader(\"apiKey\");\n+      int pos = apiKey.lastIndexOf('_') + 1;\n+      if (pos > 0) {\n+        return StringUtil.mask(apiKey, '*', pos);\n+      }\n+      return StringUtil.mask(apiKey, '*', apiKey.length() / 2);\n+    }\n \n-        private void cleanMDC() {\n-            MDC.remove(\"stream\");\n-            MDC.remove(\"apiKey\");\n-        }\n+    private void initMDC() {\n+      MDC.put(\"stream\", stream());\n+      MDC.put(\"apiKey\", getProtectedApiKey());\n+    }\n+\n+    private void cleanMDC() {\n+      MDC.remove(\"stream\");\n+      MDC.remove(\"apiKey\");\n     }\n+  }\n }\n",
            "diff_size": 331
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "112",
                    "severity": "warning",
                    "message": "Line is longer than 160 characters (found 181).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/82/SendRequestProcessor.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/naturalize/82/SendRequestProcessor.java\nindex 18ecec39ae9..34526e47652 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/82/SendRequestProcessor.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/naturalize/82/SendRequestProcessor.java\n@@ -36,12 +36,9 @@ public class SendRequestProcessor {\n     private static final Logger LOGGER = LoggerFactory.getLogger(SendRequestProcessor.class);\n \n     private static final Parameter<Integer> ORIGINAL_CONTENT_LENGTH =\n-            Parameter.integerParameter(HttpHeaders.ORIGINAL_CONTENT_LENGTH).\n-                    required().\n-                    withValidator(IntegerValidators.range(0, 100 * 1024 * 1024)).\n-                    build();\n+            Parameter.integerParameter(HttpHeaders.ORIGINAL_CONTENT_LENGTH).required().withValidator(IntegerValidators.range(0, 100 * 1024 * 1024)).build();\n \n-    private final EventSender eventSender;\n+private final EventSender eventSender;\n     private final TimeSource time;\n \n     private final EventValidator eventValidator;\n@@ -200,7 +197,8 @@ public class SendRequestProcessor {\n                 }\n                 eventSender.send(\n                         event,\n-                        event.getUuid(),//TODO: Think hard about this!\n+                        event.getUuid(),\n+//TODO: Think hard about this!\n                         context.stream(),\n                         context.partitions(),\n                         context.shardingKey(),\n@@ -303,4 +301,4 @@ public class SendRequestProcessor {\n             MDC.remove(\"apiKey\");\n         }\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 8
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "115",
                    "severity": "warning",
                    "message": "Line is longer than 160 characters (found 181).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "115",
                    "severity": "warning",
                    "message": "Line is longer than 160 characters (found 181).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "115",
                    "column": "139",
                    "severity": "warning",
                    "message": "'+' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/82/SendRequestProcessor.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/styler_three_grams/82/SendRequestProcessor.java\nindex 18ecec39ae9..231883dea67 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/82/SendRequestProcessor.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/styler_three_grams/82/SendRequestProcessor.java\n@@ -112,7 +112,7 @@ public class SendRequestProcessor {\n                                             HeaderUtil.get(ORIGINAL_CONTENT_LENGTH, request);\n                                     if (originalContentLength.isError()) {\n                                         tryComplete(HttpStatusCodes.BAD_REQUEST, callback);\n-                                        LOGGER.warn(\"Request has header Content-Encoding, but there is no valid Original-Content-Length: \" + originalContentLength.result().error());\n+                                        LOGGER.warn(\"Request has header Content-Encoding, but there is no valid Original-Content-Length: \"+ originalContentLength .result().error());\n                                         return;\n                                     }\n                                     requestUncompressedSizeBytes = originalContentLength.get();\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "intellij"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}