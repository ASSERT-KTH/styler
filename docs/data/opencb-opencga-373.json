{
    "project_name": "opencb-opencga",
    "error_id": "373",
    "information": {
        "errors": [
            {
                "line": "365",
                "severity": "error",
                "message": "Line is longer than 140 characters (found 143).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": "            if (StringUtils.isNotEmpty(query.getString(IndividualDBAdaptor.QueryParams.SAMPLES.key()))) {\n                Query newQuery = new Query()\n                        .append(IndividualDBAdaptor.QueryParams.SAMPLES.key(), query.getString(IndividualDBAdaptor.QueryParams.SAMPLES.key()));\n                QueryOptions options = new QueryOptions(QueryOptions.INCLUDE, IndividualDBAdaptor.QueryParams.UID.key());\n                OpenCGAResult<Individual> individualResult = catalogManager.getIndividualManager()\n                        .search(study.getFqn(), newQuery, options, sessionId);",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "365",
                    "severity": "error",
                    "message": "Line is longer than 140 characters (found 143).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/373/FamilyManager.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/intellij/373/FamilyManager.java\nindex 095fea6f2b0..211d98cae3b 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/373/FamilyManager.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/intellij/373/FamilyManager.java\n@@ -75,1448 +75,1448 @@ import static org.opencb.opencga.core.common.JacksonUtils.getDefaultObjectMapper\n  */\n public class FamilyManager extends AnnotationSetManager<Family> {\n \n-    protected static Logger logger = LoggerFactory.getLogger(FamilyManager.class);\n-    private UserManager userManager;\n-    private StudyManager studyManager;\n-\n-    private final String defaultFacet = \"creationYear>>creationMonth;status;phenotypes;expectedSize;numMembers[0..20]:2\";\n-\n-    public static final QueryOptions INCLUDE_FAMILY_IDS = new QueryOptions(QueryOptions.INCLUDE, Arrays.asList(\n-            FamilyDBAdaptor.QueryParams.ID.key(), FamilyDBAdaptor.QueryParams.UID.key(), FamilyDBAdaptor.QueryParams.UUID.key(),\n-            FamilyDBAdaptor.QueryParams.VERSION.key(), FamilyDBAdaptor.QueryParams.STUDY_UID.key()));\n-\n-    FamilyManager(AuthorizationManager authorizationManager, AuditManager auditManager, CatalogManager catalogManager,\n-                  DBAdaptorFactory catalogDBAdaptorFactory, Configuration configuration) {\n-        super(authorizationManager, auditManager, catalogManager, catalogDBAdaptorFactory, configuration);\n-\n-        this.userManager = catalogManager.getUserManager();\n-        this.studyManager = catalogManager.getStudyManager();\n+  protected static Logger logger = LoggerFactory.getLogger(FamilyManager.class);\n+  private UserManager userManager;\n+  private StudyManager studyManager;\n+\n+  private final String defaultFacet = \"creationYear>>creationMonth;status;phenotypes;expectedSize;numMembers[0..20]:2\";\n+\n+  public static final QueryOptions INCLUDE_FAMILY_IDS = new QueryOptions(QueryOptions.INCLUDE, Arrays.asList(\n+      FamilyDBAdaptor.QueryParams.ID.key(), FamilyDBAdaptor.QueryParams.UID.key(), FamilyDBAdaptor.QueryParams.UUID.key(),\n+      FamilyDBAdaptor.QueryParams.VERSION.key(), FamilyDBAdaptor.QueryParams.STUDY_UID.key()));\n+\n+  FamilyManager(AuthorizationManager authorizationManager, AuditManager auditManager, CatalogManager catalogManager,\n+                DBAdaptorFactory catalogDBAdaptorFactory, Configuration configuration) {\n+    super(authorizationManager, auditManager, catalogManager, catalogDBAdaptorFactory, configuration);\n+\n+    this.userManager = catalogManager.getUserManager();\n+    this.studyManager = catalogManager.getStudyManager();\n+  }\n+\n+  @Override\n+  Enums.Resource getEntity() {\n+    return Enums.Resource.FAMILY;\n+  }\n+\n+  @Override\n+  InternalGetDataResult<Family> internalGet(long studyUid, List<String> entryList, @Nullable Query query, QueryOptions options,\n+                                            String user, boolean ignoreException) throws CatalogException {\n+    if (ListUtils.isEmpty(entryList)) {\n+      throw new CatalogException(\"Missing family entries.\");\n     }\n+    List<String> uniqueList = ListUtils.unique(entryList);\n \n-    @Override\n-    Enums.Resource getEntity() {\n-        return Enums.Resource.FAMILY;\n-    }\n-\n-    @Override\n-    InternalGetDataResult<Family> internalGet(long studyUid, List<String> entryList, @Nullable Query query, QueryOptions options,\n-                                              String user, boolean ignoreException) throws CatalogException {\n-        if (ListUtils.isEmpty(entryList)) {\n-            throw new CatalogException(\"Missing family entries.\");\n-        }\n-        List<String> uniqueList = ListUtils.unique(entryList);\n-\n-        QueryOptions queryOptions = options != null ? new QueryOptions(options) : new QueryOptions();\n-        Query queryCopy = query == null ? new Query() : new Query(query);\n-        queryCopy.put(FamilyDBAdaptor.QueryParams.STUDY_UID.key(), studyUid);\n-\n-        boolean versioned = queryCopy.getBoolean(Constants.ALL_VERSIONS)\n-                || queryCopy.containsKey(FamilyDBAdaptor.QueryParams.VERSION.key());\n-        if (versioned && uniqueList.size() > 1) {\n-            throw new CatalogException(\"Only one family allowed when requesting multiple versions\");\n-        }\n-\n-        Function<Family, String> familyStringFunction = Family::getId;\n-        FamilyDBAdaptor.QueryParams idQueryParam = null;\n-        for (String entry : uniqueList) {\n-            FamilyDBAdaptor.QueryParams param = FamilyDBAdaptor.QueryParams.ID;\n-            if (UuidUtils.isOpenCgaUuid(entry)) {\n-                param = FamilyDBAdaptor.QueryParams.UUID;\n-                familyStringFunction = Family::getUuid;\n-            }\n-            if (idQueryParam == null) {\n-                idQueryParam = param;\n-            }\n-            if (idQueryParam != param) {\n-                throw new CatalogException(\"Found uuids and ids in the same query. Please, choose one or do two different queries.\");\n-            }\n-        }\n-        queryCopy.put(idQueryParam.key(), uniqueList);\n-\n-        // Ensure the field by which we are querying for will be kept in the results\n-        queryOptions = keepFieldInQueryOptions(queryOptions, idQueryParam.key());\n+    QueryOptions queryOptions = options != null ? new QueryOptions(options) : new QueryOptions();\n+    Query queryCopy = query == null ? new Query() : new Query(query);\n+    queryCopy.put(FamilyDBAdaptor.QueryParams.STUDY_UID.key(), studyUid);\n \n-        OpenCGAResult<Family> familyDataResult = familyDBAdaptor.get(studyUid, queryCopy, queryOptions, user);\n-\n-        if (ignoreException || familyDataResult.getNumResults() >= uniqueList.size()) {\n-            return keepOriginalOrder(uniqueList, familyStringFunction, familyDataResult, ignoreException, versioned);\n-        }\n-        // Query without adding the user check\n-        OpenCGAResult<Family> resultsNoCheck = familyDBAdaptor.get(queryCopy, queryOptions);\n-\n-        if (resultsNoCheck.getNumResults() == familyDataResult.getNumResults()) {\n-            throw CatalogException.notFound(\"families\",\n-                    getMissingFields(uniqueList, familyDataResult.getResults(), familyStringFunction));\n-        } else {\n-            throw new CatalogAuthorizationException(\"Permission denied. \" + user + \" is not allowed to see some or none of the families.\");\n-        }\n+    boolean versioned = queryCopy.getBoolean(Constants.ALL_VERSIONS)\n+        || queryCopy.containsKey(FamilyDBAdaptor.QueryParams.VERSION.key());\n+    if (versioned && uniqueList.size() > 1) {\n+      throw new CatalogException(\"Only one family allowed when requesting multiple versions\");\n     }\n \n-    private OpenCGAResult<Family> getFamily(long studyUid, String familyUuid, QueryOptions options) throws CatalogException {\n-        Query query = new Query()\n-                .append(FamilyDBAdaptor.QueryParams.STUDY_UID.key(), studyUid)\n-                .append(FamilyDBAdaptor.QueryParams.UUID.key(), familyUuid);\n-        return familyDBAdaptor.get(query, options);\n+    Function<Family, String> familyStringFunction = Family::getId;\n+    FamilyDBAdaptor.QueryParams idQueryParam = null;\n+    for (String entry : uniqueList) {\n+      FamilyDBAdaptor.QueryParams param = FamilyDBAdaptor.QueryParams.ID;\n+      if (UuidUtils.isOpenCgaUuid(entry)) {\n+        param = FamilyDBAdaptor.QueryParams.UUID;\n+        familyStringFunction = Family::getUuid;\n+      }\n+      if (idQueryParam == null) {\n+        idQueryParam = param;\n+      }\n+      if (idQueryParam != param) {\n+        throw new CatalogException(\"Found uuids and ids in the same query. Please, choose one or do two different queries.\");\n+      }\n     }\n+    queryCopy.put(idQueryParam.key(), uniqueList);\n \n-    @Override\n-    public DBIterator<Family> iterator(String studyStr, Query query, QueryOptions options, String token) throws CatalogException {\n-        ParamUtils.checkObj(token, \"sessionId\");\n-        query = ParamUtils.defaultObject(query, Query::new);\n-        options = ParamUtils.defaultObject(options, QueryOptions::new);\n-\n-        String userId = userManager.getUserId(token);\n-        Study study = catalogManager.getStudyManager().resolveId(studyStr, userId);\n+    // Ensure the field by which we are querying for will be kept in the results\n+    queryOptions = keepFieldInQueryOptions(queryOptions, idQueryParam.key());\n \n-        Query finalQuery = new Query(query);\n-        fixQueryObject(study, finalQuery, token);\n-        // Fix query if it contains any annotation\n-        AnnotationUtils.fixQueryAnnotationSearch(study, finalQuery);\n-        AnnotationUtils.fixQueryOptionAnnotation(options);\n-        finalQuery.append(FamilyDBAdaptor.QueryParams.STUDY_UID.key(), study.getUid());\n+    OpenCGAResult<Family> familyDataResult = familyDBAdaptor.get(studyUid, queryCopy, queryOptions, user);\n \n-        return familyDBAdaptor.iterator(study.getUid(), finalQuery, options, userId);\n+    if (ignoreException || familyDataResult.getNumResults() >= uniqueList.size()) {\n+      return keepOriginalOrder(uniqueList, familyStringFunction, familyDataResult, ignoreException, versioned);\n     }\n-\n-    @Override\n-    public OpenCGAResult<Family> create(String studyStr, Family family, QueryOptions options, String token) throws CatalogException {\n-        return create(studyStr, family, null, options, token);\n+    // Query without adding the user check\n+    OpenCGAResult<Family> resultsNoCheck = familyDBAdaptor.get(queryCopy, queryOptions);\n+\n+    if (resultsNoCheck.getNumResults() == familyDataResult.getNumResults()) {\n+      throw CatalogException.notFound(\"families\",\n+          getMissingFields(uniqueList, familyDataResult.getResults(), familyStringFunction));\n+    } else {\n+      throw new CatalogAuthorizationException(\"Permission denied. \" + user + \" is not allowed to see some or none of the families.\");\n+    }\n+  }\n+\n+  private OpenCGAResult<Family> getFamily(long studyUid, String familyUuid, QueryOptions options) throws CatalogException {\n+    Query query = new Query()\n+        .append(FamilyDBAdaptor.QueryParams.STUDY_UID.key(), studyUid)\n+        .append(FamilyDBAdaptor.QueryParams.UUID.key(), familyUuid);\n+    return familyDBAdaptor.get(query, options);\n+  }\n+\n+  @Override\n+  public DBIterator<Family> iterator(String studyStr, Query query, QueryOptions options, String token) throws CatalogException {\n+    ParamUtils.checkObj(token, \"sessionId\");\n+    query = ParamUtils.defaultObject(query, Query::new);\n+    options = ParamUtils.defaultObject(options, QueryOptions::new);\n+\n+    String userId = userManager.getUserId(token);\n+    Study study = catalogManager.getStudyManager().resolveId(studyStr, userId);\n+\n+    Query finalQuery = new Query(query);\n+    fixQueryObject(study, finalQuery, token);\n+    // Fix query if it contains any annotation\n+    AnnotationUtils.fixQueryAnnotationSearch(study, finalQuery);\n+    AnnotationUtils.fixQueryOptionAnnotation(options);\n+    finalQuery.append(FamilyDBAdaptor.QueryParams.STUDY_UID.key(), study.getUid());\n+\n+    return familyDBAdaptor.iterator(study.getUid(), finalQuery, options, userId);\n+  }\n+\n+  @Override\n+  public OpenCGAResult<Family> create(String studyStr, Family family, QueryOptions options, String token) throws CatalogException {\n+    return create(studyStr, family, null, options, token);\n+  }\n+\n+  public OpenCGAResult<Family> create(String studyStr, Family family, List<String> members, QueryOptions options, String token)\n+      throws CatalogException {\n+    options = ParamUtils.defaultObject(options, QueryOptions::new);\n+    String userId = catalogManager.getUserManager().getUserId(token);\n+    Study study = catalogManager.getStudyManager().resolveId(studyStr, userId, StudyManager.INCLUDE_VARIABLE_SET);\n+\n+    ObjectMap auditParams = new ObjectMap()\n+        .append(\"study\", studyStr)\n+        .append(\"family\", family)\n+        .append(\"members\", members)\n+        .append(\"options\", options)\n+        .append(\"token\", token);\n+    try {\n+      authorizationManager.checkStudyPermission(study.getUid(), userId, StudyAclEntry.StudyPermissions.WRITE_FAMILIES);\n+\n+      ParamUtils.checkObj(family, \"family\");\n+      ParamUtils.checkAlias(family.getId(), \"id\");\n+      family.setName(ParamUtils.defaultObject(family.getName(), family.getId()));\n+      family.setMembers(ParamUtils.defaultObject(family.getMembers(), Collections.emptyList()));\n+      family.setPhenotypes(ParamUtils.defaultObject(family.getPhenotypes(), Collections.emptyList()));\n+      family.setDisorders(ParamUtils.defaultObject(family.getDisorders(), Collections.emptyList()));\n+      family.setCreationDate(TimeUtils.getTime());\n+      family.setDescription(ParamUtils.defaultString(family.getDescription(), \"\"));\n+      family.setInternal(ParamUtils.defaultObject(family.getInternal(), FamilyInternal::new));\n+      family.getInternal().setStatus(new FamilyStatus());\n+      family.setAnnotationSets(ParamUtils.defaultObject(family.getAnnotationSets(), Collections.emptyList()));\n+      family.setStatus(ParamUtils.defaultObject(family.getStatus(), CustomStatus::new));\n+      family.setQualityControl(ParamUtils.defaultObject(family.getQualityControl(), FamilyQualityControl::new));\n+      family.setRelease(catalogManager.getStudyManager().getCurrentRelease(study));\n+      family.setVersion(1);\n+      family.setAttributes(ParamUtils.defaultObject(family.getAttributes(), Collections.emptyMap()));\n+\n+      // Check the id is not in use\n+      Query query = new Query()\n+          .append(FamilyDBAdaptor.QueryParams.STUDY_UID.key(), study.getUid())\n+          .append(FamilyDBAdaptor.QueryParams.ID.key(), family.getId());\n+      if (familyDBAdaptor.count(query).getNumMatches() > 0) {\n+        throw new CatalogException(\"Family '\" + family.getId() + \"' already exists.\");\n+      }\n+\n+      validateNewAnnotationSets(study.getVariableSets(), family.getAnnotationSets());\n+\n+      boolean membersToCreate = family.getMembers() != null && family.getMembers().size() > 0;\n+\n+      autoCompleteFamilyMembers(study, family, members, userId);\n+      validateFamily(family);\n+      validatePhenotypes(family);\n+      validateDisorders(family);\n+      if (!membersToCreate) {\n+        calculateRoles(study, family, userId);\n+      }\n+\n+      options = ParamUtils.defaultObject(options, QueryOptions::new);\n+      family.setUuid(UuidUtils.generateOpenCgaUuid(UuidUtils.Entity.FAMILY));\n+\n+      familyDBAdaptor.insert(study.getUid(), family, study.getVariableSets(), options);\n+      OpenCGAResult<Family> queryResult = getFamily(study.getUid(), family.getUuid(), options);\n+      if (membersToCreate) {\n+        calculateRoles(study, queryResult.first(), userId);\n+        ObjectMap params = new ObjectMap(FamilyDBAdaptor.QueryParams.ROLES.key(), queryResult.first().getRoles());\n+        familyDBAdaptor.update(family.getUid(), params, QueryOptions.empty());\n+      }\n+\n+      auditManager.auditCreate(userId, Enums.Resource.FAMILY, family.getId(), family.getUuid(), study.getId(), study.getUuid(),\n+          auditParams, new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS));\n+\n+      return queryResult;\n+    } catch (CatalogException e) {\n+      auditManager.auditCreate(userId, Enums.Resource.FAMILY, family.getId(), \"\", study.getId(), study.getUuid(), auditParams,\n+          new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()));\n+      throw e;\n     }\n+  }\n \n-    public OpenCGAResult<Family> create(String studyStr, Family family, List<String> members, QueryOptions options, String token)\n-            throws CatalogException {\n-        options = ParamUtils.defaultObject(options, QueryOptions::new);\n-        String userId = catalogManager.getUserManager().getUserId(token);\n-        Study study = catalogManager.getStudyManager().resolveId(studyStr, userId, StudyManager.INCLUDE_VARIABLE_SET);\n-\n-        ObjectMap auditParams = new ObjectMap()\n-                .append(\"study\", studyStr)\n-                .append(\"family\", family)\n-                .append(\"members\", members)\n-                .append(\"options\", options)\n-                .append(\"token\", token);\n-        try {\n-            authorizationManager.checkStudyPermission(study.getUid(), userId, StudyAclEntry.StudyPermissions.WRITE_FAMILIES);\n-\n-            ParamUtils.checkObj(family, \"family\");\n-            ParamUtils.checkAlias(family.getId(), \"id\");\n-            family.setName(ParamUtils.defaultObject(family.getName(), family.getId()));\n-            family.setMembers(ParamUtils.defaultObject(family.getMembers(), Collections.emptyList()));\n-            family.setPhenotypes(ParamUtils.defaultObject(family.getPhenotypes(), Collections.emptyList()));\n-            family.setDisorders(ParamUtils.defaultObject(family.getDisorders(), Collections.emptyList()));\n-            family.setCreationDate(TimeUtils.getTime());\n-            family.setDescription(ParamUtils.defaultString(family.getDescription(), \"\"));\n-            family.setInternal(ParamUtils.defaultObject(family.getInternal(), FamilyInternal::new));\n-            family.getInternal().setStatus(new FamilyStatus());\n-            family.setAnnotationSets(ParamUtils.defaultObject(family.getAnnotationSets(), Collections.emptyList()));\n-            family.setStatus(ParamUtils.defaultObject(family.getStatus(), CustomStatus::new));\n-            family.setQualityControl(ParamUtils.defaultObject(family.getQualityControl(), FamilyQualityControl::new));\n-            family.setRelease(catalogManager.getStudyManager().getCurrentRelease(study));\n-            family.setVersion(1);\n-            family.setAttributes(ParamUtils.defaultObject(family.getAttributes(), Collections.emptyMap()));\n-\n-            // Check the id is not in use\n-            Query query = new Query()\n-                    .append(FamilyDBAdaptor.QueryParams.STUDY_UID.key(), study.getUid())\n-                    .append(FamilyDBAdaptor.QueryParams.ID.key(), family.getId());\n-            if (familyDBAdaptor.count(query).getNumMatches() > 0) {\n-                throw new CatalogException(\"Family '\" + family.getId() + \"' already exists.\");\n-            }\n+  public OpenCGAResult<Family> search(String studyId, Query query, QueryOptions options, String token) throws CatalogException {\n+    query = ParamUtils.defaultObject(query, Query::new);\n+    Query finalQuery = new Query(query);\n+    options = ParamUtils.defaultObject(options, QueryOptions::new);\n \n-            validateNewAnnotationSets(study.getVariableSets(), family.getAnnotationSets());\n+    String userId = catalogManager.getUserManager().getUserId(token);\n+    Study study = studyManager.resolveId(studyId, userId, new QueryOptions(QueryOptions.INCLUDE,\n+        StudyDBAdaptor.QueryParams.VARIABLE_SET.key()));\n \n-            boolean membersToCreate = family.getMembers() != null && family.getMembers().size() > 0;\n+    ObjectMap auditParams = new ObjectMap()\n+        .append(\"studyId\", studyId)\n+        .append(\"query\", new Query(query))\n+        .append(\"options\", options)\n+        .append(\"token\", token);\n+    try {\n+      fixQueryObject(study, finalQuery, token);\n \n-            autoCompleteFamilyMembers(study, family, members, userId);\n-            validateFamily(family);\n-            validatePhenotypes(family);\n-            validateDisorders(family);\n-            if (!membersToCreate) {\n-                calculateRoles(study, family, userId);\n-            }\n+      // Fix query if it contains any annotation\n+      AnnotationUtils.fixQueryAnnotationSearch(study, finalQuery);\n+      AnnotationUtils.fixQueryOptionAnnotation(options);\n \n-            options = ParamUtils.defaultObject(options, QueryOptions::new);\n-            family.setUuid(UuidUtils.generateOpenCgaUuid(UuidUtils.Entity.FAMILY));\n+      finalQuery.append(FamilyDBAdaptor.QueryParams.STUDY_UID.key(), study.getUid());\n \n-            familyDBAdaptor.insert(study.getUid(), family, study.getVariableSets(), options);\n-            OpenCGAResult<Family> queryResult = getFamily(study.getUid(), family.getUuid(), options);\n-            if (membersToCreate) {\n-                calculateRoles(study, queryResult.first(), userId);\n-                ObjectMap params = new ObjectMap(FamilyDBAdaptor.QueryParams.ROLES.key(), queryResult.first().getRoles());\n-                familyDBAdaptor.update(family.getUid(), params, QueryOptions.empty());\n-            }\n+      OpenCGAResult<Family> queryResult = familyDBAdaptor.get(study.getUid(), finalQuery, options, userId);\n \n-            auditManager.auditCreate(userId, Enums.Resource.FAMILY, family.getId(), family.getUuid(), study.getId(), study.getUuid(),\n-                    auditParams, new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS));\n+      auditManager.auditSearch(userId, Enums.Resource.FAMILY, study.getId(), study.getUuid(), auditParams,\n+          new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS));\n \n-            return queryResult;\n-        } catch (CatalogException e) {\n-            auditManager.auditCreate(userId, Enums.Resource.FAMILY, family.getId(), \"\", study.getId(), study.getUuid(), auditParams,\n-                    new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()));\n-            throw e;\n-        }\n+      return queryResult;\n+    } catch (CatalogException e) {\n+      auditManager.auditSearch(userId, Enums.Resource.FAMILY, study.getId(), study.getUuid(), auditParams,\n+          new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()));\n+      throw e;\n     }\n+  }\n+\n+  @Override\n+  public OpenCGAResult<?> distinct(String studyId, String field, Query query, String token) throws CatalogException {\n+    query = ParamUtils.defaultObject(query, Query::new);\n+\n+    String userId = userManager.getUserId(token);\n+    Study study = catalogManager.getStudyManager().resolveId(studyId, userId, new QueryOptions(QueryOptions.INCLUDE,\n+        StudyDBAdaptor.QueryParams.VARIABLE_SET.key()));\n+\n+    ObjectMap auditParams = new ObjectMap()\n+        .append(\"studyId\", studyId)\n+        .append(\"field\", new Query(query))\n+        .append(\"query\", new Query(query))\n+        .append(\"token\", token);\n+    try {\n+      FamilyDBAdaptor.QueryParams param = FamilyDBAdaptor.QueryParams.getParam(field);\n+      if (param == null) {\n+        throw new CatalogException(\"Unknown '\" + field + \"' parameter.\");\n+      }\n+      Class<?> clazz = getTypeClass(param.type());\n+\n+      fixQueryObject(study, query, userId);\n+      // Fix query if it contains any annotation\n+      AnnotationUtils.fixQueryAnnotationSearch(study, query);\n+\n+      query.append(FamilyDBAdaptor.QueryParams.STUDY_UID.key(), study.getUid());\n+      OpenCGAResult<?> result = familyDBAdaptor.distinct(study.getUid(), field, query, userId, clazz);\n+\n+      auditManager.auditDistinct(userId, Enums.Resource.FAMILY, study.getId(), study.getUuid(), auditParams,\n+          new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS));\n+\n+      return result;\n+    } catch (CatalogException e) {\n+      auditManager.auditDistinct(userId, Enums.Resource.FAMILY, study.getId(), study.getUuid(), auditParams,\n+          new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()));\n+      throw e;\n+    }\n+  }\n \n-    public OpenCGAResult<Family> search(String studyId, Query query, QueryOptions options, String token) throws CatalogException {\n-        query = ParamUtils.defaultObject(query, Query::new);\n-        Query finalQuery = new Query(query);\n-        options = ParamUtils.defaultObject(options, QueryOptions::new);\n-\n-        String userId = catalogManager.getUserManager().getUserId(token);\n-        Study study = studyManager.resolveId(studyId, userId, new QueryOptions(QueryOptions.INCLUDE,\n-                StudyDBAdaptor.QueryParams.VARIABLE_SET.key()));\n-\n-        ObjectMap auditParams = new ObjectMap()\n-                .append(\"studyId\", studyId)\n-                .append(\"query\", new Query(query))\n-                .append(\"options\", options)\n-                .append(\"token\", token);\n-        try {\n-            fixQueryObject(study, finalQuery, token);\n-\n-            // Fix query if it contains any annotation\n-            AnnotationUtils.fixQueryAnnotationSearch(study, finalQuery);\n-            AnnotationUtils.fixQueryOptionAnnotation(options);\n-\n-            finalQuery.append(FamilyDBAdaptor.QueryParams.STUDY_UID.key(), study.getUid());\n-\n-            OpenCGAResult<Family> queryResult = familyDBAdaptor.get(study.getUid(), finalQuery, options, userId);\n-\n-            auditManager.auditSearch(userId, Enums.Resource.FAMILY, study.getId(), study.getUuid(), auditParams,\n-                    new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS));\n+  private void fixQueryObject(Study study, Query query, String sessionId) throws CatalogException {\n+    super.fixQueryObject(query);\n \n-            return queryResult;\n-        } catch (CatalogException e) {\n-            auditManager.auditSearch(userId, Enums.Resource.FAMILY, study.getId(), study.getUuid(), auditParams,\n-                    new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()));\n-            throw e;\n-        }\n+    if (StringUtils.isNotEmpty(query.getString(FamilyDBAdaptor.QueryParams.MEMBERS.key()))\n+        && StringUtils.isNotEmpty(query.getString(IndividualDBAdaptor.QueryParams.SAMPLES.key()))) {\n+      throw new CatalogException(\"Cannot look for samples and members at the same time\");\n     }\n \n-    @Override\n-    public OpenCGAResult<?> distinct(String studyId, String field, Query query, String token) throws CatalogException {\n-        query = ParamUtils.defaultObject(query, Query::new);\n-\n-        String userId = userManager.getUserId(token);\n-        Study study = catalogManager.getStudyManager().resolveId(studyId, userId, new QueryOptions(QueryOptions.INCLUDE,\n-                StudyDBAdaptor.QueryParams.VARIABLE_SET.key()));\n-\n-        ObjectMap auditParams = new ObjectMap()\n-                .append(\"studyId\", studyId)\n-                .append(\"field\", new Query(query))\n-                .append(\"query\", new Query(query))\n-                .append(\"token\", token);\n-        try {\n-            FamilyDBAdaptor.QueryParams param = FamilyDBAdaptor.QueryParams.getParam(field);\n-            if (param == null) {\n-                throw new CatalogException(\"Unknown '\" + field + \"' parameter.\");\n-            }\n-            Class<?> clazz = getTypeClass(param.type());\n+    // The individuals introduced could be either ids or names. As so, we should use the smart resolutor to do this.\n+    // We change the MEMBERS parameters for MEMBER_UID which is what the DBAdaptor understands\n+    if (query.containsKey(FamilyDBAdaptor.QueryParams.MEMBERS.key())) {\n+      String userId = userManager.getUserId(sessionId);\n+\n+      List<Individual> memberList = catalogManager.getIndividualManager().internalGet(study.getUid(),\n+          query.getAsStringList(FamilyDBAdaptor.QueryParams.MEMBERS.key()), IndividualManager.INCLUDE_INDIVIDUAL_IDS, userId,\n+          true).getResults();\n+      if (ListUtils.isNotEmpty(memberList)) {\n+        query.put(FamilyDBAdaptor.QueryParams.MEMBER_UID.key(), memberList.stream().map(Individual::getUid)\n+            .collect(Collectors.toList()));\n+      } else {\n+        // Add -1 to query so no results are obtained\n+        query.put(FamilyDBAdaptor.QueryParams.MEMBER_UID.key(), -1);\n+      }\n+\n+      query.remove(FamilyDBAdaptor.QueryParams.MEMBERS.key());\n+    }\n \n-            fixQueryObject(study, query, userId);\n-            // Fix query if it contains any annotation\n-            AnnotationUtils.fixQueryAnnotationSearch(study, query);\n+    // We look for the individuals containing those samples\n+    if (query.containsKey(IndividualDBAdaptor.QueryParams.SAMPLES.key())) {\n+      if (StringUtils.isNotEmpty(query.getString(IndividualDBAdaptor.QueryParams.SAMPLES.key()))) {\n+        Query newQuery = new Query()\n+            .append(IndividualDBAdaptor.QueryParams.SAMPLES.key(), query.getString(IndividualDBAdaptor.QueryParams.SAMPLES.key()));\n+        QueryOptions options = new QueryOptions(QueryOptions.INCLUDE, IndividualDBAdaptor.QueryParams.UID.key());\n+        OpenCGAResult<Individual> individualResult = catalogManager.getIndividualManager()\n+            .search(study.getFqn(), newQuery, options, sessionId);\n+\n+        if (individualResult.getNumResults() == 0) {\n+          // Add -1 to query so no results are obtained\n+          query.put(FamilyDBAdaptor.QueryParams.MEMBER_UID.key(), -1);\n+        } else {\n+          // Look for the individuals containing those samples\n+          query.put(FamilyDBAdaptor.QueryParams.MEMBER_UID.key(),\n+              individualResult.getResults().stream().map(Individual::getUid).collect(Collectors.toList()));\n+        }\n+      }\n \n-            query.append(FamilyDBAdaptor.QueryParams.STUDY_UID.key(), study.getUid());\n-            OpenCGAResult<?> result = familyDBAdaptor.distinct(study.getUid(), field, query, userId, clazz);\n+      query.remove(IndividualDBAdaptor.QueryParams.SAMPLES.key());\n+    }\n+  }\n+\n+  public OpenCGAResult<Family> count(String studyId, Query query, String token) throws CatalogException {\n+    query = ParamUtils.defaultObject(query, Query::new);\n+    Query finalQuery = new Query(query);\n+\n+    String userId = catalogManager.getUserManager().getUserId(token);\n+    Study study = studyManager.resolveId(studyId, userId, new QueryOptions(QueryOptions.INCLUDE,\n+        StudyDBAdaptor.QueryParams.VARIABLE_SET.key()));\n+\n+    ObjectMap auditParams = new ObjectMap()\n+        .append(\"studyId\", studyId)\n+        .append(\"query\", query)\n+        .append(\"token\", token);\n+    try {\n+      // Fix query if it contains any annotation\n+      AnnotationUtils.fixQueryAnnotationSearch(study, finalQuery);\n+      fixQueryObject(study, finalQuery, token);\n+\n+      finalQuery.append(FamilyDBAdaptor.QueryParams.STUDY_UID.key(), study.getUid());\n+      OpenCGAResult<Long> queryResultAux = familyDBAdaptor.count(finalQuery, userId);\n+\n+      auditManager.auditCount(userId, Enums.Resource.FAMILY, study.getId(), study.getUuid(), auditParams,\n+          new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS));\n+\n+      return new OpenCGAResult<>(queryResultAux.getTime(), queryResultAux.getEvents(), 0, Collections.emptyList(),\n+          queryResultAux.getNumMatches());\n+    } catch (CatalogException e) {\n+      auditManager.auditCount(userId, Enums.Resource.FAMILY, study.getId(), study.getUuid(), auditParams,\n+          new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()));\n+      throw e;\n+    }\n+  }\n+\n+  @Override\n+  public OpenCGAResult delete(String studyStr, List<String> familyIds, QueryOptions options, String token) throws CatalogException {\n+    return delete(studyStr, familyIds, options, false, token);\n+  }\n+\n+  public OpenCGAResult delete(String studyStr, List<String> familyIds, ObjectMap params, boolean ignoreException, String token)\n+      throws CatalogException {\n+    String userId = catalogManager.getUserManager().getUserId(token);\n+    Study study = studyManager.resolveId(studyStr, userId, new QueryOptions(QueryOptions.INCLUDE,\n+        StudyDBAdaptor.QueryParams.VARIABLE_SET.key()));\n+\n+    String operationUuid = UuidUtils.generateOpenCgaUuid(UuidUtils.Entity.AUDIT);\n+\n+    ObjectMap auditParams = new ObjectMap()\n+        .append(\"study\", studyStr)\n+        .append(\"familyIds\", familyIds)\n+        .append(\"params\", params)\n+        .append(\"ignoreException\", ignoreException)\n+        .append(\"token\", token);\n+\n+    boolean checkPermissions;\n+    try {\n+      // If the user is the owner or the admin, we won't check if he has permissions for every single entry\n+      checkPermissions = !authorizationManager.isOwnerOrAdmin(study.getUid(), userId);\n+    } catch (CatalogException e) {\n+      auditManager.auditDelete(operationUuid, userId, Enums.Resource.FAMILY, \"\", \"\", study.getId(), study.getUuid(),\n+          auditParams, new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()));\n+      throw e;\n+    }\n \n-            auditManager.auditDistinct(userId, Enums.Resource.FAMILY, study.getId(), study.getUuid(), auditParams,\n-                    new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS));\n+    auditManager.initAuditBatch(operationUuid);\n+    OpenCGAResult result = OpenCGAResult.empty();\n+    for (String id : familyIds) {\n+      String familyId = id;\n+      String familyUuid = \"\";\n \n-            return result;\n-        } catch (CatalogException e) {\n-            auditManager.auditDistinct(userId, Enums.Resource.FAMILY, study.getId(), study.getUuid(), auditParams,\n-                    new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()));\n-            throw e;\n+      try {\n+        OpenCGAResult<Family> internalResult = internalGet(study.getUid(), id, INCLUDE_FAMILY_IDS, userId);\n+        if (internalResult.getNumResults() == 0) {\n+          throw new CatalogException(\"Family '\" + id + \"' not found\");\n         }\n-    }\n \n-    private void fixQueryObject(Study study, Query query, String sessionId) throws CatalogException {\n-        super.fixQueryObject(query);\n+        Family family = internalResult.first();\n+        // We set the proper values for the audit\n+        familyId = family.getId();\n+        familyUuid = family.getUuid();\n \n-        if (StringUtils.isNotEmpty(query.getString(FamilyDBAdaptor.QueryParams.MEMBERS.key()))\n-                && StringUtils.isNotEmpty(query.getString(IndividualDBAdaptor.QueryParams.SAMPLES.key()))) {\n-            throw new CatalogException(\"Cannot look for samples and members at the same time\");\n+        if (checkPermissions) {\n+          authorizationManager.checkFamilyPermission(study.getUid(), family.getUid(), userId,\n+              FamilyAclEntry.FamilyPermissions.DELETE);\n         }\n \n-        // The individuals introduced could be either ids or names. As so, we should use the smart resolutor to do this.\n-        // We change the MEMBERS parameters for MEMBER_UID which is what the DBAdaptor understands\n-        if (query.containsKey(FamilyDBAdaptor.QueryParams.MEMBERS.key())) {\n-            String userId = userManager.getUserId(sessionId);\n-\n-            List<Individual> memberList = catalogManager.getIndividualManager().internalGet(study.getUid(),\n-                    query.getAsStringList(FamilyDBAdaptor.QueryParams.MEMBERS.key()), IndividualManager.INCLUDE_INDIVIDUAL_IDS, userId,\n-                    true).getResults();\n-            if (ListUtils.isNotEmpty(memberList)) {\n-                query.put(FamilyDBAdaptor.QueryParams.MEMBER_UID.key(), memberList.stream().map(Individual::getUid)\n-                        .collect(Collectors.toList()));\n-            } else {\n-                // Add -1 to query so no results are obtained\n-                query.put(FamilyDBAdaptor.QueryParams.MEMBER_UID.key(), -1);\n-            }\n+        // TODO: Check if the family is used in a clinical analysis. At this point, it can be deleted no matter what.\n \n-            query.remove(FamilyDBAdaptor.QueryParams.MEMBERS.key());\n-        }\n+        // Delete the family\n+        result.append(familyDBAdaptor.delete(family));\n \n-        // We look for the individuals containing those samples\n-        if (query.containsKey(IndividualDBAdaptor.QueryParams.SAMPLES.key())) {\n-            if (StringUtils.isNotEmpty(query.getString(IndividualDBAdaptor.QueryParams.SAMPLES.key()))) {\n-                Query newQuery = new Query()\n-                        .append(IndividualDBAdaptor.QueryParams.SAMPLES.key(), query.getString(IndividualDBAdaptor.QueryParams.SAMPLES.key()));\n-                QueryOptions options = new QueryOptions(QueryOptions.INCLUDE, IndividualDBAdaptor.QueryParams.UID.key());\n-                OpenCGAResult<Individual> individualResult = catalogManager.getIndividualManager()\n-                        .search(study.getFqn(), newQuery, options, sessionId);\n-\n-                if (individualResult.getNumResults() == 0) {\n-                    // Add -1 to query so no results are obtained\n-                    query.put(FamilyDBAdaptor.QueryParams.MEMBER_UID.key(), -1);\n-                } else {\n-                    // Look for the individuals containing those samples\n-                    query.put(FamilyDBAdaptor.QueryParams.MEMBER_UID.key(),\n-                            individualResult.getResults().stream().map(Individual::getUid).collect(Collectors.toList()));\n-                }\n-            }\n+        auditManager.auditDelete(operationUuid, userId, Enums.Resource.FAMILY, family.getId(), family.getUuid(),\n+            study.getId(), study.getUuid(), auditParams, new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS));\n+      } catch (CatalogException e) {\n+        Event event = new Event(Event.Type.ERROR, familyId, e.getMessage());\n+        result.getEvents().add(event);\n \n-            query.remove(IndividualDBAdaptor.QueryParams.SAMPLES.key());\n-        }\n+        logger.error(\"Cannot delete family {}: {}\", familyId, e.getMessage(), e);\n+        auditManager.auditDelete(operationUuid, userId, Enums.Resource.FAMILY, familyId, familyUuid,\n+            study.getId(), study.getUuid(), auditParams, new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()));\n+      }\n     }\n-\n-    public OpenCGAResult<Family> count(String studyId, Query query, String token) throws CatalogException {\n-        query = ParamUtils.defaultObject(query, Query::new);\n-        Query finalQuery = new Query(query);\n-\n-        String userId = catalogManager.getUserManager().getUserId(token);\n-        Study study = studyManager.resolveId(studyId, userId, new QueryOptions(QueryOptions.INCLUDE,\n-                StudyDBAdaptor.QueryParams.VARIABLE_SET.key()));\n-\n-        ObjectMap auditParams = new ObjectMap()\n-                .append(\"studyId\", studyId)\n-                .append(\"query\", query)\n-                .append(\"token\", token);\n-        try {\n-            // Fix query if it contains any annotation\n-            AnnotationUtils.fixQueryAnnotationSearch(study, finalQuery);\n-            fixQueryObject(study, finalQuery, token);\n-\n-            finalQuery.append(FamilyDBAdaptor.QueryParams.STUDY_UID.key(), study.getUid());\n-            OpenCGAResult<Long> queryResultAux = familyDBAdaptor.count(finalQuery, userId);\n-\n-            auditManager.auditCount(userId, Enums.Resource.FAMILY, study.getId(), study.getUuid(), auditParams,\n-                    new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS));\n-\n-            return new OpenCGAResult<>(queryResultAux.getTime(), queryResultAux.getEvents(), 0, Collections.emptyList(),\n-                    queryResultAux.getNumMatches());\n-        } catch (CatalogException e) {\n-            auditManager.auditCount(userId, Enums.Resource.FAMILY, study.getId(), study.getUuid(), auditParams,\n-                    new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()));\n-            throw e;\n-        }\n+    auditManager.finishAuditBatch(operationUuid);\n+\n+    return endResult(result, ignoreException);\n+  }\n+\n+  @Override\n+  public OpenCGAResult delete(String studyStr, Query query, QueryOptions options, String token) throws CatalogException {\n+    return delete(studyStr, query, options, false, token);\n+  }\n+\n+  public OpenCGAResult delete(String studyStr, Query query, ObjectMap params, boolean ignoreException, String token)\n+      throws CatalogException {\n+    Query finalQuery = new Query(ParamUtils.defaultObject(query, Query::new));\n+    OpenCGAResult result = OpenCGAResult.empty();\n+\n+    String userId = catalogManager.getUserManager().getUserId(token);\n+    Study study = studyManager.resolveId(studyStr, userId, new QueryOptions(QueryOptions.INCLUDE,\n+        StudyDBAdaptor.QueryParams.VARIABLE_SET.key()));\n+\n+    String operationUuid = UuidUtils.generateOpenCgaUuid(UuidUtils.Entity.AUDIT);\n+\n+    ObjectMap auditParams = new ObjectMap()\n+        .append(\"study\", studyStr)\n+        .append(\"query\", new Query(query))\n+        .append(\"params\", params)\n+        .append(\"ignoreException\", ignoreException)\n+        .append(\"token\", token);\n+\n+    // If the user is the owner or the admin, we won't check if he has permissions for every single entry\n+    boolean checkPermissions;\n+\n+    // We try to get an iterator containing all the families to be deleted\n+    DBIterator<Family> iterator;\n+    try {\n+      // Fix query if it contains any annotation\n+      AnnotationUtils.fixQueryAnnotationSearch(study, finalQuery);\n+      fixQueryObject(study, finalQuery, token);\n+      finalQuery.append(FamilyDBAdaptor.QueryParams.STUDY_UID.key(), study.getUid());\n+\n+      iterator = familyDBAdaptor.iterator(study.getUid(), finalQuery, INCLUDE_FAMILY_IDS, userId);\n+\n+      // If the user is the owner or the admin, we won't check if he has permissions for every single entry\n+      checkPermissions = !authorizationManager.isOwnerOrAdmin(study.getUid(), userId);\n+    } catch (CatalogException e) {\n+      auditManager.auditDelete(operationUuid, userId, Enums.Resource.FAMILY, \"\", \"\", study.getId(), study.getUuid(),\n+          auditParams, new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()));\n+      throw e;\n     }\n \n-    @Override\n-    public OpenCGAResult delete(String studyStr, List<String> familyIds, QueryOptions options, String token) throws CatalogException {\n-        return delete(studyStr, familyIds, options, false, token);\n-    }\n+    auditManager.initAuditBatch(operationUuid);\n+    while (iterator.hasNext()) {\n+      Family family = iterator.next();\n \n-    public OpenCGAResult delete(String studyStr, List<String> familyIds, ObjectMap params, boolean ignoreException, String token)\n-            throws CatalogException {\n-        String userId = catalogManager.getUserManager().getUserId(token);\n-        Study study = studyManager.resolveId(studyStr, userId, new QueryOptions(QueryOptions.INCLUDE,\n-                StudyDBAdaptor.QueryParams.VARIABLE_SET.key()));\n-\n-        String operationUuid = UuidUtils.generateOpenCgaUuid(UuidUtils.Entity.AUDIT);\n-\n-        ObjectMap auditParams = new ObjectMap()\n-                .append(\"study\", studyStr)\n-                .append(\"familyIds\", familyIds)\n-                .append(\"params\", params)\n-                .append(\"ignoreException\", ignoreException)\n-                .append(\"token\", token);\n-\n-        boolean checkPermissions;\n-        try {\n-            // If the user is the owner or the admin, we won't check if he has permissions for every single entry\n-            checkPermissions = !authorizationManager.isOwnerOrAdmin(study.getUid(), userId);\n-        } catch (CatalogException e) {\n-            auditManager.auditDelete(operationUuid, userId, Enums.Resource.FAMILY, \"\", \"\", study.getId(), study.getUuid(),\n-                    auditParams, new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()));\n-            throw e;\n+      try {\n+        if (checkPermissions) {\n+          authorizationManager.checkFamilyPermission(study.getUid(), family.getUid(), userId,\n+              FamilyAclEntry.FamilyPermissions.DELETE);\n         }\n \n-        auditManager.initAuditBatch(operationUuid);\n-        OpenCGAResult result = OpenCGAResult.empty();\n-        for (String id : familyIds) {\n-            String familyId = id;\n-            String familyUuid = \"\";\n-\n-            try {\n-                OpenCGAResult<Family> internalResult = internalGet(study.getUid(), id, INCLUDE_FAMILY_IDS, userId);\n-                if (internalResult.getNumResults() == 0) {\n-                    throw new CatalogException(\"Family '\" + id + \"' not found\");\n-                }\n+        // TODO: Check if the family is used in a clinical analysis. At this point, it can be deleted no matter what.\n \n-                Family family = internalResult.first();\n-                // We set the proper values for the audit\n-                familyId = family.getId();\n-                familyUuid = family.getUuid();\n+        // Delete the family\n+        result.append(familyDBAdaptor.delete(family));\n \n-                if (checkPermissions) {\n-                    authorizationManager.checkFamilyPermission(study.getUid(), family.getUid(), userId,\n-                            FamilyAclEntry.FamilyPermissions.DELETE);\n-                }\n+        auditManager.auditDelete(operationUuid, userId, Enums.Resource.FAMILY, family.getId(), family.getUuid(),\n+            study.getId(), study.getUuid(), auditParams, new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS));\n+      } catch (CatalogException e) {\n+        String errorMsg = \"Cannot delete family \" + family.getId() + \": \" + e.getMessage();\n \n-                // TODO: Check if the family is used in a clinical analysis. At this point, it can be deleted no matter what.\n+        Event event = new Event(Event.Type.ERROR, family.getId(), e.getMessage());\n+        result.getEvents().add(event);\n \n-                // Delete the family\n-                result.append(familyDBAdaptor.delete(family));\n-\n-                auditManager.auditDelete(operationUuid, userId, Enums.Resource.FAMILY, family.getId(), family.getUuid(),\n-                        study.getId(), study.getUuid(), auditParams, new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS));\n-            } catch (CatalogException e) {\n-                Event event = new Event(Event.Type.ERROR, familyId, e.getMessage());\n-                result.getEvents().add(event);\n-\n-                logger.error(\"Cannot delete family {}: {}\", familyId, e.getMessage(), e);\n-                auditManager.auditDelete(operationUuid, userId, Enums.Resource.FAMILY, familyId, familyUuid,\n-                        study.getId(), study.getUuid(), auditParams, new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()));\n-            }\n-        }\n-        auditManager.finishAuditBatch(operationUuid);\n-\n-        return endResult(result, ignoreException);\n+        logger.error(errorMsg, e);\n+        auditManager.auditDelete(operationUuid, userId, Enums.Resource.FAMILY, family.getId(), family.getUuid(),\n+            study.getId(), study.getUuid(), auditParams, new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()));\n+      }\n     }\n-\n-    @Override\n-    public OpenCGAResult delete(String studyStr, Query query, QueryOptions options, String token) throws CatalogException {\n-        return delete(studyStr, query, options, false, token);\n+    auditManager.finishAuditBatch(operationUuid);\n+\n+    return endResult(result, ignoreException);\n+  }\n+\n+  @Override\n+  public OpenCGAResult rank(String studyStr, Query query, String field, int numResults, boolean asc, String sessionId) throws\n+      CatalogException {\n+    return null;\n+  }\n+\n+  @Override\n+  public OpenCGAResult groupBy(@Nullable String studyStr, Query query, List<String> fields, QueryOptions options, String sessionId)\n+      throws CatalogException {\n+    query = ParamUtils.defaultObject(query, Query::new);\n+    options = ParamUtils.defaultObject(options, QueryOptions::new);\n+    if (fields == null || fields.size() == 0) {\n+      throw new CatalogException(\"Empty fields parameter.\");\n     }\n \n-    public OpenCGAResult delete(String studyStr, Query query, ObjectMap params, boolean ignoreException, String token)\n-            throws CatalogException {\n-        Query finalQuery = new Query(ParamUtils.defaultObject(query, Query::new));\n-        OpenCGAResult result = OpenCGAResult.empty();\n-\n-        String userId = catalogManager.getUserManager().getUserId(token);\n-        Study study = studyManager.resolveId(studyStr, userId, new QueryOptions(QueryOptions.INCLUDE,\n-                StudyDBAdaptor.QueryParams.VARIABLE_SET.key()));\n-\n-        String operationUuid = UuidUtils.generateOpenCgaUuid(UuidUtils.Entity.AUDIT);\n-\n-        ObjectMap auditParams = new ObjectMap()\n-                .append(\"study\", studyStr)\n-                .append(\"query\", new Query(query))\n-                .append(\"params\", params)\n-                .append(\"ignoreException\", ignoreException)\n-                .append(\"token\", token);\n-\n-        // If the user is the owner or the admin, we won't check if he has permissions for every single entry\n-        boolean checkPermissions;\n-\n-        // We try to get an iterator containing all the families to be deleted\n-        DBIterator<Family> iterator;\n-        try {\n-            // Fix query if it contains any annotation\n-            AnnotationUtils.fixQueryAnnotationSearch(study, finalQuery);\n-            fixQueryObject(study, finalQuery, token);\n-            finalQuery.append(FamilyDBAdaptor.QueryParams.STUDY_UID.key(), study.getUid());\n-\n-            iterator = familyDBAdaptor.iterator(study.getUid(), finalQuery, INCLUDE_FAMILY_IDS, userId);\n-\n-            // If the user is the owner or the admin, we won't check if he has permissions for every single entry\n-            checkPermissions = !authorizationManager.isOwnerOrAdmin(study.getUid(), userId);\n-        } catch (CatalogException e) {\n-            auditManager.auditDelete(operationUuid, userId, Enums.Resource.FAMILY, \"\", \"\", study.getId(), study.getUuid(),\n-                    auditParams, new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()));\n-            throw e;\n-        }\n-\n-        auditManager.initAuditBatch(operationUuid);\n-        while (iterator.hasNext()) {\n-            Family family = iterator.next();\n-\n-            try {\n-                if (checkPermissions) {\n-                    authorizationManager.checkFamilyPermission(study.getUid(), family.getUid(), userId,\n-                            FamilyAclEntry.FamilyPermissions.DELETE);\n-                }\n+    String userId = userManager.getUserId(sessionId);\n+    Study study = studyManager.resolveId(studyStr, userId);\n+\n+    Query finalQuery = new Query(query);\n+    fixQueryObject(study, finalQuery, sessionId);\n+\n+    // Fix query if it contains any annotation\n+    AnnotationUtils.fixQueryAnnotationSearch(study, userId, query, authorizationManager);\n+    AnnotationUtils.fixQueryOptionAnnotation(options);\n+\n+    // Add study id to the query\n+    finalQuery.put(FamilyDBAdaptor.QueryParams.STUDY_UID.key(), study.getUid());\n+\n+    OpenCGAResult queryResult = familyDBAdaptor.groupBy(finalQuery, fields, options, userId);\n+\n+    return ParamUtils.defaultObject(queryResult, OpenCGAResult::new);\n+  }\n+\n+  public OpenCGAResult<Family> updateAnnotationSet(String studyStr, String familyStr, List<AnnotationSet> annotationSetList,\n+                                                   ParamUtils.BasicUpdateAction action, QueryOptions options, String token)\n+      throws CatalogException {\n+    FamilyUpdateParams updateParams = new FamilyUpdateParams().setAnnotationSets(annotationSetList);\n+    options = ParamUtils.defaultObject(options, QueryOptions::new);\n+    options.put(Constants.ACTIONS, new ObjectMap(AnnotationSetManager.ANNOTATION_SETS, action));\n+\n+    return update(studyStr, familyStr, updateParams, options, token);\n+  }\n+\n+  public OpenCGAResult<Family> addAnnotationSet(String studyStr, String familyStr, AnnotationSet annotationSet, QueryOptions options,\n+                                                String token) throws CatalogException {\n+    return addAnnotationSets(studyStr, familyStr, Collections.singletonList(annotationSet), options, token);\n+  }\n+\n+  public OpenCGAResult<Family> addAnnotationSets(String studyStr, String familyStr, List<AnnotationSet> annotationSetList,\n+                                                 QueryOptions options, String token) throws CatalogException {\n+    return updateAnnotationSet(studyStr, familyStr, annotationSetList, ParamUtils.BasicUpdateAction.ADD, options, token);\n+  }\n+\n+  public OpenCGAResult<Family> setAnnotationSet(String studyStr, String familyStr, AnnotationSet annotationSet, QueryOptions options,\n+                                                String token) throws CatalogException {\n+    return setAnnotationSets(studyStr, familyStr, Collections.singletonList(annotationSet), options, token);\n+  }\n+\n+  public OpenCGAResult<Family> setAnnotationSets(String studyStr, String familyStr, List<AnnotationSet> annotationSetList,\n+                                                 QueryOptions options, String token) throws CatalogException {\n+    return updateAnnotationSet(studyStr, familyStr, annotationSetList, ParamUtils.BasicUpdateAction.SET, options, token);\n+  }\n+\n+  public OpenCGAResult<Family> removeAnnotationSet(String studyStr, String familyStr, String annotationSetId, QueryOptions options,\n+                                                   String token) throws CatalogException {\n+    return removeAnnotationSets(studyStr, familyStr, Collections.singletonList(annotationSetId), options, token);\n+  }\n+\n+  public OpenCGAResult<Family> removeAnnotationSets(String studyStr, String familyStr, List<String> annotationSetIdList,\n+                                                    QueryOptions options, String token) throws CatalogException {\n+    List<AnnotationSet> annotationSetList = annotationSetIdList\n+        .stream()\n+        .map(id -> new AnnotationSet().setId(id))\n+        .collect(Collectors.toList());\n+    return updateAnnotationSet(studyStr, familyStr, annotationSetList, ParamUtils.BasicUpdateAction.REMOVE, options, token);\n+  }\n+\n+  public OpenCGAResult<Family> updateAnnotations(String studyStr, String familyStr, String annotationSetId,\n+                                                 Map<String, Object> annotations, ParamUtils.CompleteUpdateAction action,\n+                                                 QueryOptions options, String token) throws CatalogException {\n+    if (annotations == null || annotations.isEmpty()) {\n+      throw new CatalogException(\"Missing array of annotations.\");\n+    }\n+    FamilyUpdateParams updateParams = new FamilyUpdateParams()\n+        .setAnnotationSets(Collections.singletonList(new AnnotationSet(annotationSetId, \"\", annotations)));\n+    options = ParamUtils.defaultObject(options, QueryOptions::new);\n+    options.put(Constants.ACTIONS, new ObjectMap(AnnotationSetManager.ANNOTATIONS, action));\n+\n+    return update(studyStr, familyStr, updateParams, options, token);\n+  }\n+\n+  public OpenCGAResult<Family> removeAnnotations(String studyStr, String familyStr, String annotationSetId,\n+                                                 List<String> annotations, QueryOptions options, String token) throws CatalogException {\n+    return updateAnnotations(studyStr, familyStr, annotationSetId, new ObjectMap(\"remove\", StringUtils.join(annotations, \",\")),\n+        ParamUtils.CompleteUpdateAction.REMOVE, options, token);\n+  }\n+\n+  public OpenCGAResult<Family> resetAnnotations(String studyStr, String familyStr, String annotationSetId, List<String> annotations,\n+                                                QueryOptions options, String token) throws CatalogException {\n+    return updateAnnotations(studyStr, familyStr, annotationSetId, new ObjectMap(\"reset\", StringUtils.join(annotations, \",\")),\n+        ParamUtils.CompleteUpdateAction.RESET, options, token);\n+  }\n+\n+  public OpenCGAResult<Family> update(String studyStr, Query query, FamilyUpdateParams updateParams, QueryOptions options,\n+                                      String token) throws CatalogException {\n+    return update(studyStr, query, updateParams, false, options, token);\n+  }\n+\n+  public OpenCGAResult<Family> update(String studyStr, Query query, FamilyUpdateParams updateParams, boolean ignoreException,\n+                                      QueryOptions options, String token) throws CatalogException {\n+    String userId = userManager.getUserId(token);\n+    Study study = studyManager.resolveId(studyStr, userId, StudyManager.INCLUDE_VARIABLE_SET);\n+\n+    String operationId = UuidUtils.generateOpenCgaUuid(UuidUtils.Entity.AUDIT);\n+\n+    ObjectMap updateMap;\n+    try {\n+      updateMap = updateParams != null ? updateParams.getUpdateMap() : null;\n+    } catch (JsonProcessingException e) {\n+      throw new CatalogException(\"Could not parse FamilyUpdateParams object: \" + e.getMessage(), e);\n+    }\n \n-                // TODO: Check if the family is used in a clinical analysis. At this point, it can be deleted no matter what.\n+    ObjectMap auditParams = new ObjectMap()\n+        .append(\"study\", studyStr)\n+        .append(\"query\", query)\n+        .append(\"updateParams\", updateMap)\n+        .append(\"ignoreException\", ignoreException)\n+        .append(\"options\", options)\n+        .append(\"token\", token);\n \n-                // Delete the family\n-                result.append(familyDBAdaptor.delete(family));\n+    Query finalQuery = new Query(ParamUtils.defaultObject(query, Query::new));\n \n-                auditManager.auditDelete(operationUuid, userId, Enums.Resource.FAMILY, family.getId(), family.getUuid(),\n-                        study.getId(), study.getUuid(), auditParams, new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS));\n-            } catch (CatalogException e) {\n-                String errorMsg = \"Cannot delete family \" + family.getId() + \": \" + e.getMessage();\n+    DBIterator<Family> iterator;\n+    try {\n+      fixQueryObject(study, finalQuery, token);\n \n-                Event event = new Event(Event.Type.ERROR, family.getId(), e.getMessage());\n-                result.getEvents().add(event);\n+      // Fix query if it contains any annotation\n+      AnnotationUtils.fixQueryAnnotationSearch(study, finalQuery);\n \n-                logger.error(errorMsg, e);\n-                auditManager.auditDelete(operationUuid, userId, Enums.Resource.FAMILY, family.getId(), family.getUuid(),\n-                        study.getId(), study.getUuid(), auditParams, new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()));\n-            }\n-        }\n-        auditManager.finishAuditBatch(operationUuid);\n+      finalQuery.append(FamilyDBAdaptor.QueryParams.STUDY_UID.key(), study.getUid());\n \n-        return endResult(result, ignoreException);\n+      iterator = familyDBAdaptor.iterator(study.getUid(), finalQuery, QueryOptions.empty(), userId);\n+    } catch (CatalogException e) {\n+      auditManager.auditUpdate(operationId, userId, Enums.Resource.FAMILY, \"\", \"\", study.getId(), study.getUuid(),\n+          auditParams, new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()));\n+      throw e;\n     }\n \n-    @Override\n-    public OpenCGAResult rank(String studyStr, Query query, String field, int numResults, boolean asc, String sessionId) throws\n-            CatalogException {\n-        return null;\n+    auditManager.initAuditBatch(operationId);\n+    OpenCGAResult<Family> result = OpenCGAResult.empty();\n+    while (iterator.hasNext()) {\n+      Family family = iterator.next();\n+      try {\n+        OpenCGAResult<Family> queryResult = update(study, family, updateParams, options, userId);\n+        result.append(queryResult);\n+\n+        auditManager.auditUpdate(operationId, userId, Enums.Resource.FAMILY, family.getId(), family.getUuid(), study.getId(),\n+            study.getUuid(), auditParams, new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS));\n+      } catch (CatalogException e) {\n+        Event event = new Event(Event.Type.ERROR, family.getId(), e.getMessage());\n+        result.getEvents().add(event);\n+\n+        logger.error(\"Cannot update family {}: {}\", family.getId(), e.getMessage(), e);\n+        auditManager.auditUpdate(operationId, userId, Enums.Resource.FAMILY, family.getId(), family.getUuid(), study.getId(),\n+            study.getUuid(), auditParams, new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()));\n+      }\n     }\n+    auditManager.finishAuditBatch(operationId);\n \n-    @Override\n-    public OpenCGAResult groupBy(@Nullable String studyStr, Query query, List<String> fields, QueryOptions options, String sessionId)\n-            throws CatalogException {\n-        query = ParamUtils.defaultObject(query, Query::new);\n-        options = ParamUtils.defaultObject(options, QueryOptions::new);\n-        if (fields == null || fields.size() == 0) {\n-            throw new CatalogException(\"Empty fields parameter.\");\n-        }\n-\n-        String userId = userManager.getUserId(sessionId);\n-        Study study = studyManager.resolveId(studyStr, userId);\n+    return endResult(result, ignoreException);\n+  }\n \n-        Query finalQuery = new Query(query);\n-        fixQueryObject(study, finalQuery, sessionId);\n+  public OpenCGAResult<Family> update(String studyStr, String familyId, FamilyUpdateParams updateParams, QueryOptions options,\n+                                      String token) throws CatalogException {\n+    String userId = userManager.getUserId(token);\n+    Study study = studyManager.resolveId(studyStr, userId, StudyManager.INCLUDE_VARIABLE_SET);\n \n-        // Fix query if it contains any annotation\n-        AnnotationUtils.fixQueryAnnotationSearch(study, userId, query, authorizationManager);\n-        AnnotationUtils.fixQueryOptionAnnotation(options);\n+    String operationId = UuidUtils.generateOpenCgaUuid(UuidUtils.Entity.AUDIT);\n \n-        // Add study id to the query\n-        finalQuery.put(FamilyDBAdaptor.QueryParams.STUDY_UID.key(), study.getUid());\n+    ObjectMap updateMap;\n+    try {\n+      updateMap = updateParams != null ? updateParams.getUpdateMap() : null;\n+    } catch (JsonProcessingException e) {\n+      throw new CatalogException(\"Could not parse FamilyUpdateParams object: \" + e.getMessage(), e);\n+    }\n \n-        OpenCGAResult queryResult = familyDBAdaptor.groupBy(finalQuery, fields, options, userId);\n+    ObjectMap auditParams = new ObjectMap()\n+        .append(\"study\", studyStr)\n+        .append(\"familyId\", familyId)\n+        .append(\"updateParams\", updateMap)\n+        .append(\"options\", options)\n+        .append(\"token\", token);\n+\n+    OpenCGAResult<Family> result = OpenCGAResult.empty();\n+    String familyUuid = \"\";\n+\n+    try {\n+      OpenCGAResult<Family> internalResult = internalGet(study.getUid(), familyId, QueryOptions.empty(), userId);\n+      if (internalResult.getNumResults() == 0) {\n+        throw new CatalogException(\"Family '\" + familyId + \"' not found\");\n+      }\n+      Family family = internalResult.first();\n+\n+      // We set the proper values for the audit\n+      familyId = family.getId();\n+      familyUuid = family.getUuid();\n+\n+      OpenCGAResult<Family> updateResult = update(study, family, updateParams, options, userId);\n+      result.append(updateResult);\n+\n+      auditManager.auditUpdate(operationId, userId, Enums.Resource.FAMILY, family.getId(), family.getUuid(), study.getId(),\n+          study.getUuid(), auditParams, new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS));\n+    } catch (CatalogException e) {\n+      Event event = new Event(Event.Type.ERROR, familyId, e.getMessage());\n+      result.getEvents().add(event);\n+\n+      logger.error(\"Cannot update family {}: {}\", familyId, e.getMessage());\n+      auditManager.auditUpdate(operationId, userId, Enums.Resource.FAMILY, familyId, familyUuid, study.getId(),\n+          study.getUuid(), auditParams, new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()));\n+      throw e;\n+    }\n \n-        return ParamUtils.defaultObject(queryResult, OpenCGAResult::new);\n+    return result;\n+  }\n+\n+  /**\n+   * Update families from catalog.\n+   *\n+   * @param studyStr     Study id in string format. Could be one of [id|user@aliasProject:aliasStudy|aliasProject:aliasStudy|aliasStudy].\n+   * @param familyIds    List of family ids. Could be either the id or uuid.\n+   * @param updateParams Data model filled only with the parameters to be updated.\n+   * @param options      QueryOptions object.\n+   * @param token        Session id of the user logged in.\n+   * @return A OpenCGAResult.\n+   * @throws CatalogException if there is any internal error, the user does not have proper permissions or a parameter passed does not\n+   *                          exist or is not allowed to be updated.\n+   */\n+  public OpenCGAResult<Family> update(String studyStr, List<String> familyIds, FamilyUpdateParams updateParams, QueryOptions options,\n+                                      String token) throws CatalogException {\n+    return update(studyStr, familyIds, updateParams, false, options, token);\n+  }\n+\n+  public OpenCGAResult<Family> update(String studyStr, List<String> familyIds, FamilyUpdateParams updateParams, boolean ignoreException,\n+                                      QueryOptions options, String token) throws CatalogException {\n+    String userId = userManager.getUserId(token);\n+    Study study = studyManager.resolveId(studyStr, userId, StudyManager.INCLUDE_VARIABLE_SET);\n+\n+    String operationId = UuidUtils.generateOpenCgaUuid(UuidUtils.Entity.AUDIT);\n+\n+    ObjectMap updateMap;\n+    try {\n+      updateMap = updateParams != null ? updateParams.getUpdateMap() : null;\n+    } catch (JsonProcessingException e) {\n+      throw new CatalogException(\"Could not parse FamilyUpdateParams object: \" + e.getMessage(), e);\n     }\n \n-    public OpenCGAResult<Family> updateAnnotationSet(String studyStr, String familyStr, List<AnnotationSet> annotationSetList,\n-                                                     ParamUtils.BasicUpdateAction action, QueryOptions options, String token)\n-            throws CatalogException {\n-        FamilyUpdateParams updateParams = new FamilyUpdateParams().setAnnotationSets(annotationSetList);\n-        options = ParamUtils.defaultObject(options, QueryOptions::new);\n-        options.put(Constants.ACTIONS, new ObjectMap(AnnotationSetManager.ANNOTATION_SETS, action));\n+    ObjectMap auditParams = new ObjectMap()\n+        .append(\"study\", studyStr)\n+        .append(\"familyIds\", familyIds)\n+        .append(\"updateParams\", updateMap)\n+        .append(\"ignoreException\", ignoreException)\n+        .append(\"options\", options)\n+        .append(\"token\", token);\n+\n+    auditManager.initAuditBatch(operationId);\n+    OpenCGAResult<Family> result = OpenCGAResult.empty();\n+    for (String id : familyIds) {\n+      String familyId = id;\n+      String familyUuid = \"\";\n+\n+      try {\n+        OpenCGAResult<Family> internalResult = internalGet(study.getUid(), familyId, QueryOptions.empty(), userId);\n+        if (internalResult.getNumResults() == 0) {\n+          throw new CatalogException(\"Family '\" + id + \"' not found\");\n+        }\n+        Family family = internalResult.first();\n \n-        return update(studyStr, familyStr, updateParams, options, token);\n-    }\n+        // We set the proper values for the audit\n+        familyId = family.getId();\n+        familyUuid = family.getUuid();\n \n-    public OpenCGAResult<Family> addAnnotationSet(String studyStr, String familyStr, AnnotationSet annotationSet, QueryOptions options,\n-                                                  String token) throws CatalogException {\n-        return addAnnotationSets(studyStr, familyStr, Collections.singletonList(annotationSet), options, token);\n-    }\n+        OpenCGAResult<Family> updateResult = update(study, family, updateParams, options, userId);\n+        result.append(updateResult);\n \n-    public OpenCGAResult<Family> addAnnotationSets(String studyStr, String familyStr, List<AnnotationSet> annotationSetList,\n-                                                   QueryOptions options, String token) throws CatalogException {\n-        return updateAnnotationSet(studyStr, familyStr, annotationSetList, ParamUtils.BasicUpdateAction.ADD, options, token);\n-    }\n+        auditManager.auditUpdate(operationId, userId, Enums.Resource.FAMILY, family.getId(), family.getUuid(), study.getId(),\n+            study.getUuid(), auditParams, new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS));\n+      } catch (CatalogException e) {\n+        Event event = new Event(Event.Type.ERROR, id, e.getMessage());\n+        result.getEvents().add(event);\n \n-    public OpenCGAResult<Family> setAnnotationSet(String studyStr, String familyStr, AnnotationSet annotationSet, QueryOptions options,\n-                                                  String token) throws CatalogException {\n-        return setAnnotationSets(studyStr, familyStr, Collections.singletonList(annotationSet), options, token);\n+        logger.error(\"Cannot update family {}: {}\", familyId, e.getMessage());\n+        auditManager.auditUpdate(operationId, userId, Enums.Resource.FAMILY, familyId, familyUuid, study.getId(),\n+            study.getUuid(), auditParams, new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()));\n+      }\n     }\n-\n-    public OpenCGAResult<Family> setAnnotationSets(String studyStr, String familyStr, List<AnnotationSet> annotationSetList,\n-                                                   QueryOptions options, String token) throws CatalogException {\n-        return updateAnnotationSet(studyStr, familyStr, annotationSetList, ParamUtils.BasicUpdateAction.SET, options, token);\n+    auditManager.finishAuditBatch(operationId);\n+\n+    return endResult(result, ignoreException);\n+  }\n+\n+  private OpenCGAResult<Family> update(Study study, Family family, FamilyUpdateParams updateParams, QueryOptions options, String userId)\n+      throws CatalogException {\n+    options = ParamUtils.defaultObject(options, QueryOptions::new);\n+\n+    ObjectMap parameters = new ObjectMap();\n+    if (updateParams != null) {\n+      try {\n+        parameters = updateParams.getUpdateMap();\n+      } catch (JsonProcessingException e) {\n+        throw new CatalogException(\"Could not parse FamilyUpdateParams object: \" + e.getMessage(), e);\n+      }\n     }\n \n-    public OpenCGAResult<Family> removeAnnotationSet(String studyStr, String familyStr, String annotationSetId, QueryOptions options,\n-                                                     String token) throws CatalogException {\n-        return removeAnnotationSets(studyStr, familyStr, Collections.singletonList(annotationSetId), options, token);\n+    // If there is nothing to update, we fail\n+    if (parameters.isEmpty() && !options.getBoolean(Constants.REFRESH, false)\n+        && !options.getBoolean(Constants.INCREMENT_VERSION, false)\n+        && !options.getBoolean(ParamConstants.FAMILY_UPDATE_ROLES_PARAM, false)) {\n+      ParamUtils.checkUpdateParametersMap(parameters);\n     }\n \n-    public OpenCGAResult<Family> removeAnnotationSets(String studyStr, String familyStr, List<String> annotationSetIdList,\n-                                                      QueryOptions options, String token) throws CatalogException {\n-        List<AnnotationSet> annotationSetList = annotationSetIdList\n-                .stream()\n-                .map(id -> new AnnotationSet().setId(id))\n-                .collect(Collectors.toList());\n-        return updateAnnotationSet(studyStr, familyStr, annotationSetList, ParamUtils.BasicUpdateAction.REMOVE, options, token);\n+    if (parameters.containsKey(SampleDBAdaptor.QueryParams.ANNOTATION_SETS.key())) {\n+      Map<String, Object> actionMap = options.getMap(Constants.ACTIONS, new HashMap<>());\n+      if (!actionMap.containsKey(AnnotationSetManager.ANNOTATION_SETS)\n+          && !actionMap.containsKey(AnnotationSetManager.ANNOTATIONS)) {\n+        logger.warn(\"Assuming the user wants to add the list of annotation sets provided\");\n+        actionMap.put(AnnotationSetManager.ANNOTATION_SETS, ParamUtils.BasicUpdateAction.ADD);\n+        options.put(Constants.ACTIONS, actionMap);\n+      }\n     }\n \n-    public OpenCGAResult<Family> updateAnnotations(String studyStr, String familyStr, String annotationSetId,\n-                                                   Map<String, Object> annotations, ParamUtils.CompleteUpdateAction action,\n-                                                   QueryOptions options, String token) throws CatalogException {\n-        if (annotations == null || annotations.isEmpty()) {\n-            throw new CatalogException(\"Missing array of annotations.\");\n-        }\n-        FamilyUpdateParams updateParams = new FamilyUpdateParams()\n-                .setAnnotationSets(Collections.singletonList(new AnnotationSet(annotationSetId, \"\", annotations)));\n-        options = ParamUtils.defaultObject(options, QueryOptions::new);\n-        options.put(Constants.ACTIONS, new ObjectMap(AnnotationSetManager.ANNOTATIONS, action));\n-\n-        return update(studyStr, familyStr, updateParams, options, token);\n+    // Check permissions...\n+    // Only check write annotation permissions if the user wants to update the annotation sets\n+    if (updateParams != null && updateParams.getAnnotationSets() != null) {\n+      authorizationManager.checkFamilyPermission(study.getUid(), family.getUid(), userId,\n+          FamilyAclEntry.FamilyPermissions.WRITE_ANNOTATIONS);\n     }\n-\n-    public OpenCGAResult<Family> removeAnnotations(String studyStr, String familyStr, String annotationSetId,\n-                                                   List<String> annotations, QueryOptions options, String token) throws CatalogException {\n-        return updateAnnotations(studyStr, familyStr, annotationSetId, new ObjectMap(\"remove\", StringUtils.join(annotations, \",\")),\n-                ParamUtils.CompleteUpdateAction.REMOVE, options, token);\n+    // Only check update permissions if the user wants to update anything apart from the annotation sets\n+    if ((parameters.size() == 1 && !parameters.containsKey(FamilyDBAdaptor.QueryParams.ANNOTATION_SETS.key()))\n+        || parameters.size() > 1) {\n+      authorizationManager.checkFamilyPermission(study.getUid(), family.getUid(), userId,\n+          FamilyAclEntry.FamilyPermissions.UPDATE);\n     }\n \n-    public OpenCGAResult<Family> resetAnnotations(String studyStr, String familyStr, String annotationSetId, List<String> annotations,\n-                                                  QueryOptions options, String token) throws CatalogException {\n-        return updateAnnotations(studyStr, familyStr, annotationSetId, new ObjectMap(\"reset\", StringUtils.join(annotations, \",\")),\n-                ParamUtils.CompleteUpdateAction.RESET, options, token);\n+    if (updateParams != null && StringUtils.isNotEmpty(updateParams.getId())) {\n+      ParamUtils.checkAlias(updateParams.getId(), FamilyDBAdaptor.QueryParams.ID.key());\n     }\n \n-    public OpenCGAResult<Family> update(String studyStr, Query query, FamilyUpdateParams updateParams, QueryOptions options,\n-                                        String token) throws CatalogException {\n-        return update(studyStr, query, updateParams, false, options, token);\n+    boolean updateRoles = options.getBoolean(ParamConstants.FAMILY_UPDATE_ROLES_PARAM);\n+\n+    if (updateRoles || (updateParams != null && (ListUtils.isNotEmpty(updateParams.getPhenotypes())\n+        || ListUtils.isNotEmpty(updateParams.getMembers()) || ListUtils.isNotEmpty(updateParams.getDisorders())))) {\n+      Family tmpFamily = new Family();\n+      if (updateParams != null && ListUtils.isNotEmpty(updateParams.getMembers())) {\n+        // We obtain the members from catalog\n+        autoCompleteFamilyMembers(study, tmpFamily, updateParams.getMembers(), userId);\n+      } else {\n+        // We use the list of members from the stored family\n+        tmpFamily.setMembers(family.getMembers());\n+      }\n+\n+      if (updateParams != null && ListUtils.isNotEmpty(updateParams.getPhenotypes())) {\n+        tmpFamily.setPhenotypes(updateParams.getPhenotypes());\n+      } else {\n+        tmpFamily.setPhenotypes(family.getPhenotypes());\n+      }\n+      if (updateParams != null && ListUtils.isNotEmpty(updateParams.getDisorders())) {\n+        tmpFamily.setDisorders(updateParams.getDisorders());\n+      } else {\n+        tmpFamily.setDisorders(family.getDisorders());\n+      }\n+\n+      validateFamily(tmpFamily);\n+      validatePhenotypes(tmpFamily);\n+      validateDisorders(tmpFamily);\n+\n+      ObjectMap tmpParams;\n+      try {\n+        ObjectMapper objectMapper = getDefaultObjectMapper();\n+        tmpParams = new ObjectMap(objectMapper.writeValueAsString(tmpFamily));\n+      } catch (JsonProcessingException e) {\n+        logger.error(\"{}\", e.getMessage(), e);\n+        throw new CatalogException(e);\n+      }\n+\n+      if (parameters.containsKey(FamilyDBAdaptor.QueryParams.MEMBERS.key())) {\n+        parameters.put(FamilyDBAdaptor.QueryParams.MEMBERS.key(), tmpParams.get(FamilyDBAdaptor.QueryParams.MEMBERS.key()));\n+\n+        // Recalculate roles\n+        calculateRoles(study, tmpFamily, userId);\n+        parameters.put(FamilyDBAdaptor.QueryParams.ROLES.key(), tmpFamily.getRoles());\n+      } else if (updateRoles) {\n+        // Recalculate roles\n+        calculateRoles(study, tmpFamily, userId);\n+        parameters.put(FamilyDBAdaptor.QueryParams.ROLES.key(), tmpFamily.getRoles());\n+      }\n+      if (parameters.containsKey(FamilyDBAdaptor.QueryParams.PHENOTYPES.key())) {\n+        parameters.put(FamilyDBAdaptor.QueryParams.PHENOTYPES.key(),\n+            tmpParams.get(FamilyDBAdaptor.QueryParams.PHENOTYPES.key()));\n+      }\n+      if (parameters.containsKey(FamilyDBAdaptor.QueryParams.DISORDERS.key())) {\n+        parameters.put(FamilyDBAdaptor.QueryParams.DISORDERS.key(), tmpParams.get(FamilyDBAdaptor.QueryParams.DISORDERS.key()));\n+      }\n     }\n \n-    public OpenCGAResult<Family> update(String studyStr, Query query, FamilyUpdateParams updateParams, boolean ignoreException,\n-                                        QueryOptions options, String token) throws CatalogException {\n-        String userId = userManager.getUserId(token);\n-        Study study = studyManager.resolveId(studyStr, userId, StudyManager.INCLUDE_VARIABLE_SET);\n-\n-        String operationId = UuidUtils.generateOpenCgaUuid(UuidUtils.Entity.AUDIT);\n-\n-        ObjectMap updateMap;\n-        try {\n-            updateMap = updateParams != null ? updateParams.getUpdateMap() : null;\n-        } catch (JsonProcessingException e) {\n-            throw new CatalogException(\"Could not parse FamilyUpdateParams object: \" + e.getMessage(), e);\n-        }\n-\n-        ObjectMap auditParams = new ObjectMap()\n-                .append(\"study\", studyStr)\n-                .append(\"query\", query)\n-                .append(\"updateParams\", updateMap)\n-                .append(\"ignoreException\", ignoreException)\n-                .append(\"options\", options)\n-                .append(\"token\", token);\n-\n-        Query finalQuery = new Query(ParamUtils.defaultObject(query, Query::new));\n-\n-        DBIterator<Family> iterator;\n-        try {\n-            fixQueryObject(study, finalQuery, token);\n-\n-            // Fix query if it contains any annotation\n-            AnnotationUtils.fixQueryAnnotationSearch(study, finalQuery);\n-\n-            finalQuery.append(FamilyDBAdaptor.QueryParams.STUDY_UID.key(), study.getUid());\n-\n-            iterator = familyDBAdaptor.iterator(study.getUid(), finalQuery, QueryOptions.empty(), userId);\n-        } catch (CatalogException e) {\n-            auditManager.auditUpdate(operationId, userId, Enums.Resource.FAMILY, \"\", \"\", study.getId(), study.getUuid(),\n-                    auditParams, new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()));\n-            throw e;\n-        }\n-\n-        auditManager.initAuditBatch(operationId);\n-        OpenCGAResult<Family> result = OpenCGAResult.empty();\n-        while (iterator.hasNext()) {\n-            Family family = iterator.next();\n-            try {\n-                OpenCGAResult<Family> queryResult = update(study, family, updateParams, options, userId);\n-                result.append(queryResult);\n-\n-                auditManager.auditUpdate(operationId, userId, Enums.Resource.FAMILY, family.getId(), family.getUuid(), study.getId(),\n-                        study.getUuid(), auditParams, new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS));\n-            } catch (CatalogException e) {\n-                Event event = new Event(Event.Type.ERROR, family.getId(), e.getMessage());\n-                result.getEvents().add(event);\n-\n-                logger.error(\"Cannot update family {}: {}\", family.getId(), e.getMessage(), e);\n-                auditManager.auditUpdate(operationId, userId, Enums.Resource.FAMILY, family.getId(), family.getUuid(), study.getId(),\n-                        study.getUuid(), auditParams, new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()));\n-            }\n-        }\n-        auditManager.finishAuditBatch(operationId);\n+    checkUpdateAnnotations(study, family, parameters, options, VariableSet.AnnotableDataModels.FAMILY, familyDBAdaptor,\n+        userId);\n \n-        return endResult(result, ignoreException);\n+    if (options.getBoolean(Constants.INCREMENT_VERSION)) {\n+      // We do need to get the current release to properly create a new version\n+      options.put(Constants.CURRENT_RELEASE, studyManager.getCurrentRelease(study));\n     }\n \n-    public OpenCGAResult<Family> update(String studyStr, String familyId, FamilyUpdateParams updateParams, QueryOptions options,\n-                                        String token) throws CatalogException {\n-        String userId = userManager.getUserId(token);\n-        Study study = studyManager.resolveId(studyStr, userId, StudyManager.INCLUDE_VARIABLE_SET);\n-\n-        String operationId = UuidUtils.generateOpenCgaUuid(UuidUtils.Entity.AUDIT);\n-\n-        ObjectMap updateMap;\n-        try {\n-            updateMap = updateParams != null ? updateParams.getUpdateMap() : null;\n-        } catch (JsonProcessingException e) {\n-            throw new CatalogException(\"Could not parse FamilyUpdateParams object: \" + e.getMessage(), e);\n+    return familyDBAdaptor.update(family.getUid(), parameters, study.getVariableSets(), options);\n+  }\n+\n+  public Map<String, List<String>> calculateFamilyGenotypes(String studyStr, String clinicalAnalysisId, String familyId,\n+                                                            ClinicalProperty.ModeOfInheritance moi, String disorderId,\n+                                                            Penetrance penetrance, String token) throws CatalogException {\n+    Pedigree pedigree;\n+    Disorder disorder = null;\n+\n+    if (StringUtils.isNotEmpty(clinicalAnalysisId)) {\n+      OpenCGAResult<ClinicalAnalysis> clinicalAnalysisDataResult = catalogManager.getClinicalAnalysisManager().get(studyStr,\n+          clinicalAnalysisId, new QueryOptions(QueryOptions.INCLUDE, Arrays.asList(\n+              ClinicalAnalysisDBAdaptor.QueryParams.PROBAND.key(), ClinicalAnalysisDBAdaptor.QueryParams.FAMILY.key(),\n+              ClinicalAnalysisDBAdaptor.QueryParams.DISORDER.key())), token);\n+      if (clinicalAnalysisDataResult.getNumResults() == 0) {\n+        throw new CatalogException(\"Clinical analysis \" + clinicalAnalysisId + \" not found\");\n+      }\n+\n+      disorder = clinicalAnalysisDataResult.first().getDisorder();\n+      pedigree = getPedigreeFromFamily(clinicalAnalysisDataResult.first().getFamily(),\n+          clinicalAnalysisDataResult.first().getProband().getId());\n+\n+    } else if (StringUtils.isNotEmpty(familyId) && StringUtils.isNotEmpty(disorderId)) {\n+      OpenCGAResult<Family> familyDataResult = get(studyStr, familyId, QueryOptions.empty(), token);\n+\n+      if (familyDataResult.getNumResults() == 0) {\n+        throw new CatalogException(\"Family \" + familyId + \" not found\");\n+      }\n+\n+      for (Disorder tmpDisorder : familyDataResult.first().getDisorders()) {\n+        if (tmpDisorder.getId().equals(disorderId)) {\n+          disorder = tmpDisorder;\n+          break;\n         }\n+      }\n+      if (disorder == null) {\n+        throw new CatalogException(\"Disorder \" + disorderId + \" not found in any member of the family\");\n+      }\n+\n+      pedigree = getPedigreeFromFamily(familyDataResult.first(), null);\n+    } else {\n+      throw new CatalogException(\"Missing 'clinicalAnalysis' or ('family' and 'disorderId') parameters\");\n+    }\n \n-        ObjectMap auditParams = new ObjectMap()\n-                .append(\"study\", studyStr)\n-                .append(\"familyId\", familyId)\n-                .append(\"updateParams\", updateMap)\n-                .append(\"options\", options)\n-                .append(\"token\", token);\n-\n-        OpenCGAResult<Family> result = OpenCGAResult.empty();\n-        String familyUuid = \"\";\n-\n-        try {\n-            OpenCGAResult<Family> internalResult = internalGet(study.getUid(), familyId, QueryOptions.empty(), userId);\n-            if (internalResult.getNumResults() == 0) {\n-                throw new CatalogException(\"Family '\" + familyId + \"' not found\");\n+    switch (moi) {\n+      case AUTOSOMAL_DOMINANT:\n+        return ModeOfInheritance.dominant(pedigree, disorder, penetrance);\n+      case AUTOSOMAL_RECESSIVE:\n+        return ModeOfInheritance.recessive(pedigree, disorder, penetrance);\n+      case X_LINKED_RECESSIVE:\n+        return ModeOfInheritance.xLinked(pedigree, disorder, false, penetrance);\n+      case X_LINKED_DOMINANT:\n+        return ModeOfInheritance.xLinked(pedigree, disorder, true, penetrance);\n+      case Y_LINKED:\n+        return ModeOfInheritance.yLinked(pedigree, disorder, penetrance);\n+      case MITOCHONDRIAL:\n+        return ModeOfInheritance.mitochondrial(pedigree, disorder, penetrance);\n+      case DE_NOVO:\n+        return ModeOfInheritance.deNovo(pedigree);\n+      case COMPOUND_HETEROZYGOUS:\n+        return ModeOfInheritance.compoundHeterozygous(pedigree);\n+      default:\n+        throw new CatalogException(\"Unsupported or unknown mode of inheritance \" + moi);\n+    }\n+  }\n+\n+  // **************************   ACLs  ******************************** //\n+  public OpenCGAResult<Map<String, List<String>>> getAcls(String studyId, List<String> familyList, String member, boolean ignoreException,\n+                                                          String token) throws CatalogException {\n+    String user = userManager.getUserId(token);\n+    Study study = studyManager.resolveId(studyId, user);\n+\n+    String operationId = UuidUtils.generateOpenCgaUuid(UuidUtils.Entity.AUDIT);\n+    ObjectMap auditParams = new ObjectMap()\n+        .append(\"studyId\", studyId)\n+        .append(\"familyList\", familyList)\n+        .append(\"member\", member)\n+        .append(\"ignoreException\", ignoreException)\n+        .append(\"token\", token);\n+\n+    try {\n+      OpenCGAResult<Map<String, List<String>>> familyAclList = OpenCGAResult.empty();\n+      InternalGetDataResult<Family> familyDataResult = internalGet(study.getUid(), familyList, INCLUDE_FAMILY_IDS, user,\n+          ignoreException);\n+\n+      Map<String, InternalGetDataResult.Missing> missingMap = new HashMap<>();\n+      if (familyDataResult.getMissing() != null) {\n+        missingMap = familyDataResult.getMissing().stream()\n+            .collect(Collectors.toMap(InternalGetDataResult.Missing::getId, Function.identity()));\n+      }\n+      int counter = 0;\n+      for (String familyId : familyList) {\n+        if (!missingMap.containsKey(familyId)) {\n+          Family family = familyDataResult.getResults().get(counter);\n+          try {\n+            OpenCGAResult<Map<String, List<String>>> allFamilyAcls;\n+            if (StringUtils.isNotEmpty(member)) {\n+              allFamilyAcls = authorizationManager.getFamilyAcl(study.getUid(), family.getUid(), user, member);\n+            } else {\n+              allFamilyAcls = authorizationManager.getAllFamilyAcls(study.getUid(), family.getUid(), user);\n             }\n-            Family family = internalResult.first();\n-\n-            // We set the proper values for the audit\n-            familyId = family.getId();\n-            familyUuid = family.getUuid();\n-\n-            OpenCGAResult<Family> updateResult = update(study, family, updateParams, options, userId);\n-            result.append(updateResult);\n-\n-            auditManager.auditUpdate(operationId, userId, Enums.Resource.FAMILY, family.getId(), family.getUuid(), study.getId(),\n-                    study.getUuid(), auditParams, new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS));\n-        } catch (CatalogException e) {\n-            Event event = new Event(Event.Type.ERROR, familyId, e.getMessage());\n-            result.getEvents().add(event);\n+            familyAclList.append(allFamilyAcls);\n+\n+            auditManager.audit(operationId, user, Enums.Action.FETCH_ACLS, Enums.Resource.FAMILY, family.getId(),\n+                family.getUuid(), study.getId(), study.getUuid(), auditParams,\n+                new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS), new ObjectMap());\n+          } catch (CatalogException e) {\n+            auditManager.audit(operationId, user, Enums.Action.FETCH_ACLS, Enums.Resource.FAMILY, family.getId(),\n+                family.getUuid(), study.getId(), study.getUuid(), auditParams,\n+                new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()), new ObjectMap());\n+\n+            if (!ignoreException) {\n+              throw e;\n+            } else {\n+              Event event = new Event(Event.Type.ERROR, familyId, missingMap.get(familyId).getErrorMsg());\n+              familyAclList.append(new OpenCGAResult<>(0, Collections.singletonList(event), 0,\n+                  Collections.singletonList(Collections.emptyMap()), 0));\n+            }\n+          }\n+          counter += 1;\n+        } else {\n+          Event event = new Event(Event.Type.ERROR, familyId, missingMap.get(familyId).getErrorMsg());\n+          familyAclList.append(new OpenCGAResult<>(0, Collections.singletonList(event), 0,\n+              Collections.singletonList(Collections.emptyMap()), 0));\n \n-            logger.error(\"Cannot update family {}: {}\", familyId, e.getMessage());\n-            auditManager.auditUpdate(operationId, userId, Enums.Resource.FAMILY, familyId, familyUuid, study.getId(),\n-                    study.getUuid(), auditParams, new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()));\n-            throw e;\n+          auditManager.audit(operationId, user, Enums.Action.FETCH_ACLS, Enums.Resource.FAMILY, familyId, \"\",\n+              study.getId(), study.getUuid(), auditParams, new AuditRecord.Status(AuditRecord.Status.Result.ERROR,\n+                  new Error(0, \"\", missingMap.get(familyId).getErrorMsg())), new ObjectMap());\n+        }\n+      }\n+      return familyAclList;\n+    } catch (CatalogException e) {\n+      for (String familyId : familyList) {\n+        auditManager.audit(operationId, user, Enums.Action.FETCH_ACLS, Enums.Resource.FAMILY, familyId, \"\",\n+            study.getId(), study.getUuid(), auditParams, new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()),\n+            new ObjectMap());\n+      }\n+      throw e;\n+    }\n+  }\n+\n+  public OpenCGAResult<Map<String, List<String>>> updateAcl(String studyId, List<String> familyStrList, String memberList,\n+                                                            AclParams aclParams, ParamUtils.AclAction action, String token)\n+      throws CatalogException {\n+    String user = userManager.getUserId(token);\n+    Study study = studyManager.resolveId(studyId, user);\n+\n+    ObjectMap auditParams = new ObjectMap()\n+        .append(\"studyId\", studyId)\n+        .append(\"familyStrList\", familyStrList)\n+        .append(\"memberList\", memberList)\n+        .append(\"aclParams\", aclParams)\n+        .append(\"action\", action)\n+        .append(\"token\", token);\n+    String operationId = UuidUtils.generateOpenCgaUuid(UuidUtils.Entity.AUDIT);\n+\n+    try {\n+      if (familyStrList == null || familyStrList.isEmpty()) {\n+        throw new CatalogException(\"Update ACL: Missing family parameter\");\n+      }\n+\n+      if (action == null) {\n+        throw new CatalogException(\"Invalid action found. Please choose a valid action to be performed.\");\n+      }\n+\n+      List<String> permissions = Collections.emptyList();\n+      if (StringUtils.isNotEmpty(aclParams.getPermissions())) {\n+        permissions = Arrays.asList(aclParams.getPermissions().trim().replaceAll(\"\\\\s\", \"\").split(\",\"));\n+        checkPermissions(permissions, FamilyAclEntry.FamilyPermissions::valueOf);\n+      }\n+\n+      List<Family> familyList = internalGet(study.getUid(), familyStrList, INCLUDE_FAMILY_IDS, user, false).getResults();\n+\n+      authorizationManager.checkCanAssignOrSeePermissions(study.getUid(), user);\n+\n+      // Validate that the members are actually valid members\n+      List<String> members;\n+      if (memberList != null && !memberList.isEmpty()) {\n+        members = Arrays.asList(memberList.split(\",\"));\n+      } else {\n+        members = Collections.emptyList();\n+      }\n+      authorizationManager.checkNotAssigningPermissionsToAdminsGroup(members);\n+      checkMembers(study.getUid(), members);\n+\n+      List<Long> familyUids = familyList.stream().map(Family::getUid).collect(Collectors.toList());\n+      AuthorizationManager.CatalogAclParams catalogAclParams = new AuthorizationManager.CatalogAclParams(familyUids, permissions,\n+          Enums.Resource.FAMILY);\n+\n+      OpenCGAResult<Map<String, List<String>>> aclResults;\n+      switch (action) {\n+        case SET:\n+          aclResults = authorizationManager.setAcls(study.getUid(), members, catalogAclParams);\n+          break;\n+        case ADD:\n+          aclResults = authorizationManager.addAcls(study.getUid(), members, catalogAclParams);\n+          break;\n+        case REMOVE:\n+          aclResults = authorizationManager.removeAcls(members, catalogAclParams);\n+          break;\n+        case RESET:\n+          catalogAclParams.setPermissions(null);\n+          aclResults = authorizationManager.removeAcls(members, catalogAclParams);\n+          break;\n+        default:\n+          throw new CatalogException(\"Unexpected error occurred. No valid action found.\");\n+      }\n+\n+      for (Family family : familyList) {\n+        auditManager.audit(operationId, user, Enums.Action.UPDATE_ACLS, Enums.Resource.FAMILY, family.getId(),\n+            family.getUuid(), study.getId(), study.getUuid(), auditParams,\n+            new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS), new ObjectMap());\n+      }\n+      return aclResults;\n+    } catch (CatalogException e) {\n+      if (familyStrList != null) {\n+        for (String familyId : familyStrList) {\n+          auditManager.audit(operationId, user, Enums.Action.UPDATE_ACLS, Enums.Resource.FAMILY, familyId, \"\",\n+              study.getId(), study.getUuid(), auditParams, new AuditRecord.Status(AuditRecord.Status.Result.ERROR,\n+                  e.getError()), new ObjectMap());\n         }\n+      }\n+      throw e;\n+    }\n+  }\n+\n+  public DataResult<FacetField> facet(String studyId, Query query, QueryOptions options, boolean defaultStats, String token)\n+      throws CatalogException {\n+    ParamUtils.defaultObject(query, Query::new);\n+    ParamUtils.defaultObject(options, QueryOptions::new);\n+\n+    String userId = userManager.getUserId(token);\n+    // We need to add variableSets and groups to avoid additional queries as it will be used in the catalogSolrManager\n+    Study study = catalogManager.getStudyManager().resolveId(studyId, userId, new QueryOptions(QueryOptions.INCLUDE,\n+        Arrays.asList(StudyDBAdaptor.QueryParams.VARIABLE_SET.key(), StudyDBAdaptor.QueryParams.GROUPS.key())));\n+\n+    ObjectMap auditParams = new ObjectMap()\n+        .append(\"studyId\", studyId)\n+        .append(\"query\", new Query(query))\n+        .append(\"options\", options)\n+        .append(\"defaultStats\", defaultStats)\n+        .append(\"token\", token);\n+\n+    try {\n+      if (defaultStats || StringUtils.isEmpty(options.getString(QueryOptions.FACET))) {\n+        String facet = options.getString(QueryOptions.FACET);\n+        options.put(QueryOptions.FACET, StringUtils.isNotEmpty(facet) ? defaultFacet + \";\" + facet : defaultFacet);\n+      }\n+\n+      AnnotationUtils.fixQueryAnnotationSearch(study, userId, query, authorizationManager);\n+\n+      try (CatalogSolrManager catalogSolrManager = new CatalogSolrManager(catalogManager)) {\n+        DataResult<FacetField> result = catalogSolrManager.facetedQuery(study, CatalogSolrManager.FAMILY_SOLR_COLLECTION, query,\n+            options, userId);\n+        auditManager.auditFacet(userId, Enums.Resource.FAMILY, study.getId(), study.getUuid(), auditParams,\n+            new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS));\n \n         return result;\n+      }\n+    } catch (CatalogException e) {\n+      auditManager.auditFacet(userId, Enums.Resource.FAMILY, study.getId(), study.getUuid(), auditParams,\n+          new AuditRecord.Status(AuditRecord.Status.Result.ERROR, new Error(0, \"\", e.getMessage())));\n+      throw e;\n     }\n-\n-    /**\n-     * Update families from catalog.\n-     *\n-     * @param studyStr   Study id in string format. Could be one of [id|user@aliasProject:aliasStudy|aliasProject:aliasStudy|aliasStudy].\n-     * @param familyIds  List of family ids. Could be either the id or uuid.\n-     * @param updateParams Data model filled only with the parameters to be updated.\n-     * @param options      QueryOptions object.\n-     * @param token  Session id of the user logged in.\n-     * @return A OpenCGAResult.\n-     * @throws CatalogException if there is any internal error, the user does not have proper permissions or a parameter passed does not\n-     *                          exist or is not allowed to be updated.\n-     */\n-    public OpenCGAResult<Family> update(String studyStr, List<String> familyIds, FamilyUpdateParams updateParams, QueryOptions options,\n-                                        String token) throws CatalogException {\n-        return update(studyStr, familyIds, updateParams, false, options, token);\n+  }\n+\n+  public static Pedigree getPedigreeFromFamily(Family family, String probandId) {\n+    List<Individual> members = family.getMembers();\n+    Map<String, Member> individualMap = new HashMap<>();\n+\n+    // Parse all the individuals\n+    for (Individual member : members) {\n+      Member individual = new Member(\n+          member.getId(), member.getName(), null, null, null,\n+          Member.Sex.getEnum(member.getSex().toString()), member.getLifeStatus(),\n+          member.getPhenotypes(), member.getDisorders(), member.getAttributes());\n+      individualMap.put(individual.getId(), individual);\n     }\n \n-    public OpenCGAResult<Family> update(String studyStr, List<String> familyIds, FamilyUpdateParams updateParams, boolean ignoreException,\n-                                        QueryOptions options, String token) throws CatalogException {\n-        String userId = userManager.getUserId(token);\n-        Study study = studyManager.resolveId(studyStr, userId, StudyManager.INCLUDE_VARIABLE_SET);\n-\n-        String operationId = UuidUtils.generateOpenCgaUuid(UuidUtils.Entity.AUDIT);\n-\n-        ObjectMap updateMap;\n-        try {\n-            updateMap = updateParams != null ? updateParams.getUpdateMap() : null;\n-        } catch (JsonProcessingException e) {\n-            throw new CatalogException(\"Could not parse FamilyUpdateParams object: \" + e.getMessage(), e);\n-        }\n-\n-        ObjectMap auditParams = new ObjectMap()\n-                .append(\"study\", studyStr)\n-                .append(\"familyIds\", familyIds)\n-                .append(\"updateParams\", updateMap)\n-                .append(\"ignoreException\", ignoreException)\n-                .append(\"options\", options)\n-                .append(\"token\", token);\n-\n-        auditManager.initAuditBatch(operationId);\n-        OpenCGAResult<Family> result = OpenCGAResult.empty();\n-        for (String id : familyIds) {\n-            String familyId = id;\n-            String familyUuid = \"\";\n-\n-            try {\n-                OpenCGAResult<Family> internalResult = internalGet(study.getUid(), familyId, QueryOptions.empty(), userId);\n-                if (internalResult.getNumResults() == 0) {\n-                    throw new CatalogException(\"Family '\" + id + \"' not found\");\n-                }\n-                Family family = internalResult.first();\n+    // Fill parent information\n+    for (Individual member : members) {\n+      if (member.getFather() != null && StringUtils.isNotEmpty(member.getFather().getId())) {\n+        individualMap.get(member.getId()).setFather(individualMap.get(member.getFather().getId()));\n+      }\n+      if (member.getMother() != null && StringUtils.isNotEmpty(member.getMother().getId())) {\n+        individualMap.get(member.getId()).setMother(individualMap.get(member.getMother().getId()));\n+      }\n+    }\n \n-                // We set the proper values for the audit\n-                familyId = family.getId();\n-                familyUuid = family.getUuid();\n+    Member proband = null;\n+    if (StringUtils.isNotEmpty(probandId)) {\n+      proband = individualMap.get(probandId);\n+    }\n \n-                OpenCGAResult<Family> updateResult = update(study, family, updateParams, options, userId);\n-                result.append(updateResult);\n+    List<Member> individuals = new ArrayList<>(individualMap.values());\n+    return new Pedigree(family.getId(), individuals, proband, family.getPhenotypes(), family.getDisorders(), family.getAttributes());\n+  }\n+\n+  /**\n+   * Validate the list of members provided in the members list already exists (and retrieves their information).\n+   * It also makes sure the members provided inside the family object are valid and can be successfully created.\n+   * It merges all those members inside the family object afterwards.\n+   *\n+   * @param study   study.\n+   * @param family  family object.\n+   * @param members Already existing members.\n+   * @param userId  user id.\n+   * @throws CatalogException if there is any kind of error.\n+   */\n+  private void autoCompleteFamilyMembers(Study study, Family family, List<String> members, String userId) throws CatalogException {\n+    List<Individual> memberList = new ArrayList<>();\n+\n+    if (family.getMembers() != null && !family.getMembers().isEmpty()) {\n+      // Check the user can create new individuals\n+      authorizationManager.checkStudyPermission(study.getUid(), userId, StudyAclEntry.StudyPermissions.WRITE_INDIVIDUALS);\n+\n+      // Validate the individuals can be created and are valid\n+      for (Individual individual : family.getMembers()) {\n+        catalogManager.getIndividualManager().validateNewIndividual(study, individual, null, userId, false);\n+        memberList.add(individual);\n+      }\n+    }\n \n-                auditManager.auditUpdate(operationId, userId, Enums.Resource.FAMILY, family.getId(), family.getUuid(), study.getId(),\n-                        study.getUuid(), auditParams, new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS));\n-            } catch (CatalogException e) {\n-                Event event = new Event(Event.Type.ERROR, id, e.getMessage());\n-                result.getEvents().add(event);\n+    if (members != null && !members.isEmpty()) {\n+      // We remove any possible duplicate\n+      ArrayList<String> deduplicatedMemberIds = new ArrayList<>(new HashSet<>(members));\n \n-                logger.error(\"Cannot update family {}: {}\", familyId, e.getMessage());\n-                auditManager.auditUpdate(operationId, userId, Enums.Resource.FAMILY, familyId, familyUuid, study.getId(),\n-                        study.getUuid(), auditParams, new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()));\n-            }\n-        }\n-        auditManager.finishAuditBatch(operationId);\n+      InternalGetDataResult<Individual> individualDataResult = catalogManager.getIndividualManager().internalGet(study.getUid(),\n+          deduplicatedMemberIds, IndividualManager.INCLUDE_INDIVIDUAL_DISORDERS_PHENOTYPES, userId, false);\n \n-        return endResult(result, ignoreException);\n+      memberList.addAll(individualDataResult.getResults());\n     }\n \n-    private OpenCGAResult<Family> update(Study study, Family family, FamilyUpdateParams updateParams, QueryOptions options, String userId)\n-            throws CatalogException {\n-        options = ParamUtils.defaultObject(options, QueryOptions::new);\n+    family.setMembers(memberList);\n+  }\n \n-        ObjectMap parameters = new ObjectMap();\n-        if (updateParams != null) {\n-            try {\n-                parameters = updateParams.getUpdateMap();\n-            } catch (JsonProcessingException e) {\n-                throw new CatalogException(\"Could not parse FamilyUpdateParams object: \" + e.getMessage(), e);\n-            }\n-        }\n-\n-        // If there is nothing to update, we fail\n-        if (parameters.isEmpty() && !options.getBoolean(Constants.REFRESH, false)\n-                && !options.getBoolean(Constants.INCREMENT_VERSION, false)\n-                && !options.getBoolean(ParamConstants.FAMILY_UPDATE_ROLES_PARAM, false)) {\n-            ParamUtils.checkUpdateParametersMap(parameters);\n-        }\n+  private void validateFamily(Family family) throws CatalogException {\n+    if (family.getMembers() == null || family.getMembers().isEmpty()) {\n+      return;\n+    }\n \n-        if (parameters.containsKey(SampleDBAdaptor.QueryParams.ANNOTATION_SETS.key())) {\n-            Map<String, Object> actionMap = options.getMap(Constants.ACTIONS, new HashMap<>());\n-            if (!actionMap.containsKey(AnnotationSetManager.ANNOTATION_SETS)\n-                    && !actionMap.containsKey(AnnotationSetManager.ANNOTATIONS)) {\n-                logger.warn(\"Assuming the user wants to add the list of annotation sets provided\");\n-                actionMap.put(AnnotationSetManager.ANNOTATION_SETS, ParamUtils.BasicUpdateAction.ADD);\n-                options.put(Constants.ACTIONS, actionMap);\n-            }\n+    Map<String, Individual> membersMap = new HashMap<>();       // individualName|individualId: Individual\n+    Map<String, List<Individual>> parentsMap = new HashMap<>(); // motherName||F---fatherName||M: List<children>\n+    Set<Individual> noParentsSet = new HashSet<>();             // Set with individuals without parents\n+\n+    // 1. Fill in the objects initialised above\n+    for (Individual individual : family.getMembers()) {\n+      membersMap.put(individual.getId(), individual);\n+      if (individual.getUid() > 0) {\n+        membersMap.put(String.valueOf(individual.getUid()), individual);\n+      }\n+\n+      String parentsKey = null;\n+      if (individual.getMother() != null) {\n+        if (individual.getMother().getUid() > 0) {\n+          individual.getMother().setId(String.valueOf(individual.getMother().getUid()));\n         }\n-\n-        // Check permissions...\n-        // Only check write annotation permissions if the user wants to update the annotation sets\n-        if (updateParams != null && updateParams.getAnnotationSets() != null) {\n-            authorizationManager.checkFamilyPermission(study.getUid(), family.getUid(), userId,\n-                    FamilyAclEntry.FamilyPermissions.WRITE_ANNOTATIONS);\n+        if (!StringUtils.isEmpty(individual.getMother().getId())) {\n+          parentsKey = individual.getMother().getId() + \"||F\";\n         }\n-        // Only check update permissions if the user wants to update anything apart from the annotation sets\n-        if ((parameters.size() == 1 && !parameters.containsKey(FamilyDBAdaptor.QueryParams.ANNOTATION_SETS.key()))\n-                || parameters.size() > 1) {\n-            authorizationManager.checkFamilyPermission(study.getUid(), family.getUid(), userId,\n-                    FamilyAclEntry.FamilyPermissions.UPDATE);\n+      }\n+      if (individual.getFather() != null) {\n+        if (parentsKey != null) {\n+          parentsKey += \"---\";\n         }\n-\n-        if (updateParams != null && StringUtils.isNotEmpty(updateParams.getId())) {\n-            ParamUtils.checkAlias(updateParams.getId(), FamilyDBAdaptor.QueryParams.ID.key());\n+        if (individual.getFather().getUid() > 0) {\n+          individual.getFather().setId(String.valueOf(individual.getFather().getUid()));\n         }\n-\n-        boolean updateRoles = options.getBoolean(ParamConstants.FAMILY_UPDATE_ROLES_PARAM);\n-\n-        if (updateRoles || (updateParams != null && (ListUtils.isNotEmpty(updateParams.getPhenotypes())\n-                || ListUtils.isNotEmpty(updateParams.getMembers()) || ListUtils.isNotEmpty(updateParams.getDisorders())))) {\n-            Family tmpFamily = new Family();\n-            if (updateParams != null && ListUtils.isNotEmpty(updateParams.getMembers())) {\n-                // We obtain the members from catalog\n-                autoCompleteFamilyMembers(study, tmpFamily, updateParams.getMembers(), userId);\n-            } else {\n-                // We use the list of members from the stored family\n-                tmpFamily.setMembers(family.getMembers());\n-            }\n-\n-            if (updateParams != null && ListUtils.isNotEmpty(updateParams.getPhenotypes())) {\n-                tmpFamily.setPhenotypes(updateParams.getPhenotypes());\n-            } else {\n-                tmpFamily.setPhenotypes(family.getPhenotypes());\n-            }\n-            if (updateParams != null && ListUtils.isNotEmpty(updateParams.getDisorders())) {\n-                tmpFamily.setDisorders(updateParams.getDisorders());\n-            } else {\n-                tmpFamily.setDisorders(family.getDisorders());\n-            }\n-\n-            validateFamily(tmpFamily);\n-            validatePhenotypes(tmpFamily);\n-            validateDisorders(tmpFamily);\n-\n-            ObjectMap tmpParams;\n-            try {\n-                ObjectMapper objectMapper = getDefaultObjectMapper();\n-                tmpParams = new ObjectMap(objectMapper.writeValueAsString(tmpFamily));\n-            } catch (JsonProcessingException e) {\n-                logger.error(\"{}\", e.getMessage(), e);\n-                throw new CatalogException(e);\n-            }\n-\n-            if (parameters.containsKey(FamilyDBAdaptor.QueryParams.MEMBERS.key())) {\n-                parameters.put(FamilyDBAdaptor.QueryParams.MEMBERS.key(), tmpParams.get(FamilyDBAdaptor.QueryParams.MEMBERS.key()));\n-\n-                // Recalculate roles\n-                calculateRoles(study, tmpFamily, userId);\n-                parameters.put(FamilyDBAdaptor.QueryParams.ROLES.key(), tmpFamily.getRoles());\n-            } else if (updateRoles) {\n-                // Recalculate roles\n-                calculateRoles(study, tmpFamily, userId);\n-                parameters.put(FamilyDBAdaptor.QueryParams.ROLES.key(), tmpFamily.getRoles());\n-            }\n-            if (parameters.containsKey(FamilyDBAdaptor.QueryParams.PHENOTYPES.key())) {\n-                parameters.put(FamilyDBAdaptor.QueryParams.PHENOTYPES.key(),\n-                        tmpParams.get(FamilyDBAdaptor.QueryParams.PHENOTYPES.key()));\n-            }\n-            if (parameters.containsKey(FamilyDBAdaptor.QueryParams.DISORDERS.key())) {\n-                parameters.put(FamilyDBAdaptor.QueryParams.DISORDERS.key(), tmpParams.get(FamilyDBAdaptor.QueryParams.DISORDERS.key()));\n-            }\n+        if (!StringUtils.isEmpty(individual.getFather().getId())) {\n+          if (parentsKey != null) {\n+            parentsKey += individual.getFather().getId() + \"||M\";\n+          } else {\n+            parentsKey = individual.getFather().getId() + \"||M\";\n+          }\n         }\n-\n-        checkUpdateAnnotations(study, family, parameters, options, VariableSet.AnnotableDataModels.FAMILY, familyDBAdaptor,\n-                userId);\n-\n-        if (options.getBoolean(Constants.INCREMENT_VERSION)) {\n-            // We do need to get the current release to properly create a new version\n-            options.put(Constants.CURRENT_RELEASE, studyManager.getCurrentRelease(study));\n+      }\n+      if (parentsKey == null) {\n+        noParentsSet.add(individual);\n+      } else {\n+        if (!parentsMap.containsKey(parentsKey)) {\n+          parentsMap.put(parentsKey, new ArrayList<>());\n         }\n-\n-        return familyDBAdaptor.update(family.getUid(), parameters, study.getVariableSets(), options);\n+        parentsMap.get(parentsKey).add(individual);\n+      }\n     }\n \n-    public Map<String, List<String>> calculateFamilyGenotypes(String studyStr, String clinicalAnalysisId, String familyId,\n-                                                              ClinicalProperty.ModeOfInheritance moi, String disorderId,\n-                                                              Penetrance penetrance, String token) throws CatalogException {\n-        Pedigree pedigree;\n-        Disorder disorder = null;\n-\n-        if (StringUtils.isNotEmpty(clinicalAnalysisId)) {\n-            OpenCGAResult<ClinicalAnalysis> clinicalAnalysisDataResult = catalogManager.getClinicalAnalysisManager().get(studyStr,\n-                    clinicalAnalysisId, new QueryOptions(QueryOptions.INCLUDE, Arrays.asList(\n-                            ClinicalAnalysisDBAdaptor.QueryParams.PROBAND.key(), ClinicalAnalysisDBAdaptor.QueryParams.FAMILY.key(),\n-                            ClinicalAnalysisDBAdaptor.QueryParams.DISORDER.key())), token);\n-            if (clinicalAnalysisDataResult.getNumResults() == 0) {\n-                throw new CatalogException(\"Clinical analysis \" + clinicalAnalysisId + \" not found\");\n-            }\n-\n-            disorder = clinicalAnalysisDataResult.first().getDisorder();\n-            pedigree = getPedigreeFromFamily(clinicalAnalysisDataResult.first().getFamily(),\n-                    clinicalAnalysisDataResult.first().getProband().getId());\n-\n-        } else if (StringUtils.isNotEmpty(familyId) && StringUtils.isNotEmpty(disorderId)) {\n-            OpenCGAResult<Family> familyDataResult = get(studyStr, familyId, QueryOptions.empty(), token);\n-\n-            if (familyDataResult.getNumResults() == 0) {\n-                throw new CatalogException(\"Family \" + familyId + \" not found\");\n-            }\n-\n-            for (Disorder tmpDisorder : familyDataResult.first().getDisorders()) {\n-                if (tmpDisorder.getId().equals(disorderId)) {\n-                    disorder = tmpDisorder;\n-                    break;\n-                }\n-            }\n-            if (disorder == null) {\n-                throw new CatalogException(\"Disorder \" + disorderId + \" not found in any member of the family\");\n-            }\n-\n-            pedigree = getPedigreeFromFamily(familyDataResult.first(), null);\n+    // 2. Loop over the parentsMap object. We will be emptying the noParentsSet as soon as we find a parent in the set. Once,\n+    // everything finishes, that set should be empty. Otherwise, it will mean that parent is not in use\n+    // On the other hand, all the parents should exist in the membersMap, otherwise it will mean that is missing in the family\n+    for (Map.Entry<String, List<Individual>> parentListEntry : parentsMap.entrySet()) {\n+      String[] split = parentListEntry.getKey().split(\"---\");\n+      for (String parentName : split) {\n+        String[] splitNameSex = parentName.split(\"\\\\|\\\\|\");\n+        String name = splitNameSex[0];\n+        IndividualProperty.Sex sex = splitNameSex[1].equals(\"F\") ? IndividualProperty.Sex.FEMALE : IndividualProperty.Sex.MALE;\n+\n+        if (!membersMap.containsKey(name)) {\n+          throw new CatalogException(\"The parent \" + name + \" is not present in the members list\");\n         } else {\n-            throw new CatalogException(\"Missing 'clinicalAnalysis' or ('family' and 'disorderId') parameters\");\n-        }\n-\n-        switch (moi) {\n-            case AUTOSOMAL_DOMINANT:\n-                return ModeOfInheritance.dominant(pedigree, disorder, penetrance);\n-            case AUTOSOMAL_RECESSIVE:\n-                return ModeOfInheritance.recessive(pedigree, disorder, penetrance);\n-            case X_LINKED_RECESSIVE:\n-                return ModeOfInheritance.xLinked(pedigree, disorder, false, penetrance);\n-            case X_LINKED_DOMINANT:\n-                return ModeOfInheritance.xLinked(pedigree, disorder, true, penetrance);\n-            case Y_LINKED:\n-                return ModeOfInheritance.yLinked(pedigree, disorder, penetrance);\n-            case MITOCHONDRIAL:\n-                return ModeOfInheritance.mitochondrial(pedigree, disorder, penetrance);\n-            case DE_NOVO:\n-                return ModeOfInheritance.deNovo(pedigree);\n-            case COMPOUND_HETEROZYGOUS:\n-                return ModeOfInheritance.compoundHeterozygous(pedigree);\n-            default:\n-                throw new CatalogException(\"Unsupported or unknown mode of inheritance \" + moi);\n-        }\n-    }\n-\n-    // **************************   ACLs  ******************************** //\n-    public OpenCGAResult<Map<String, List<String>>> getAcls(String studyId, List<String> familyList, String member, boolean ignoreException,\n-                                                            String token) throws CatalogException {\n-        String user = userManager.getUserId(token);\n-        Study study = studyManager.resolveId(studyId, user);\n-\n-        String operationId = UuidUtils.generateOpenCgaUuid(UuidUtils.Entity.AUDIT);\n-        ObjectMap auditParams = new ObjectMap()\n-                .append(\"studyId\", studyId)\n-                .append(\"familyList\", familyList)\n-                .append(\"member\", member)\n-                .append(\"ignoreException\", ignoreException)\n-                .append(\"token\", token);\n-\n-        try {\n-            OpenCGAResult<Map<String, List<String>>> familyAclList = OpenCGAResult.empty();\n-            InternalGetDataResult<Family> familyDataResult = internalGet(study.getUid(), familyList, INCLUDE_FAMILY_IDS, user,\n-                    ignoreException);\n-\n-            Map<String, InternalGetDataResult.Missing> missingMap = new HashMap<>();\n-            if (familyDataResult.getMissing() != null) {\n-                missingMap = familyDataResult.getMissing().stream()\n-                        .collect(Collectors.toMap(InternalGetDataResult.Missing::getId, Function.identity()));\n-            }\n-            int counter = 0;\n-            for (String familyId : familyList) {\n-                if (!missingMap.containsKey(familyId)) {\n-                    Family family = familyDataResult.getResults().get(counter);\n-                    try {\n-                        OpenCGAResult<Map<String, List<String>>> allFamilyAcls;\n-                        if (StringUtils.isNotEmpty(member)) {\n-                            allFamilyAcls = authorizationManager.getFamilyAcl(study.getUid(), family.getUid(), user, member);\n-                        } else {\n-                            allFamilyAcls = authorizationManager.getAllFamilyAcls(study.getUid(), family.getUid(), user);\n-                        }\n-                        familyAclList.append(allFamilyAcls);\n-\n-                        auditManager.audit(operationId, user, Enums.Action.FETCH_ACLS, Enums.Resource.FAMILY, family.getId(),\n-                                family.getUuid(), study.getId(), study.getUuid(), auditParams,\n-                                new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS), new ObjectMap());\n-                    } catch (CatalogException e) {\n-                        auditManager.audit(operationId, user, Enums.Action.FETCH_ACLS, Enums.Resource.FAMILY, family.getId(),\n-                                family.getUuid(), study.getId(), study.getUuid(), auditParams,\n-                                new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()), new ObjectMap());\n-\n-                        if (!ignoreException) {\n-                            throw e;\n-                        } else {\n-                            Event event = new Event(Event.Type.ERROR, familyId, missingMap.get(familyId).getErrorMsg());\n-                            familyAclList.append(new OpenCGAResult<>(0, Collections.singletonList(event), 0,\n-                                    Collections.singletonList(Collections.emptyMap()), 0));\n-                        }\n-                    }\n-                    counter += 1;\n-                } else {\n-                    Event event = new Event(Event.Type.ERROR, familyId, missingMap.get(familyId).getErrorMsg());\n-                    familyAclList.append(new OpenCGAResult<>(0, Collections.singletonList(event), 0,\n-                            Collections.singletonList(Collections.emptyMap()), 0));\n-\n-                    auditManager.audit(operationId, user, Enums.Action.FETCH_ACLS, Enums.Resource.FAMILY, familyId, \"\",\n-                            study.getId(), study.getUuid(), auditParams, new AuditRecord.Status(AuditRecord.Status.Result.ERROR,\n-                                    new Error(0, \"\", missingMap.get(familyId).getErrorMsg())), new ObjectMap());\n-                }\n-            }\n-            return familyAclList;\n-        } catch (CatalogException e) {\n-            for (String familyId : familyList) {\n-                auditManager.audit(operationId, user, Enums.Action.FETCH_ACLS, Enums.Resource.FAMILY, familyId, \"\",\n-                        study.getId(), study.getUuid(), auditParams, new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()),\n-                        new ObjectMap());\n-            }\n-            throw e;\n+          // Check if the sex is correct\n+          IndividualProperty.Sex sex1 = membersMap.get(name).getSex();\n+          if (sex1 != null && sex1 != sex && sex1 != IndividualProperty.Sex.UNKNOWN) {\n+            throw new CatalogException(\"Sex of parent \" + name + \" is incorrect or the relationship is incorrect. In \"\n+                + \"principle, it should be \" + sex);\n+          }\n+          membersMap.get(name).setSex(sex);\n+\n+          // We attempt to remove the individual from the noParentsSet\n+          noParentsSet.remove(membersMap.get(name));\n         }\n+      }\n     }\n \n-    public OpenCGAResult<Map<String, List<String>>> updateAcl(String studyId, List<String> familyStrList, String memberList,\n-                                                              AclParams aclParams, ParamUtils.AclAction action, String token)\n-            throws CatalogException {\n-        String user = userManager.getUserId(token);\n-        Study study = studyManager.resolveId(studyId, user);\n-\n-        ObjectMap auditParams = new ObjectMap()\n-                .append(\"studyId\", studyId)\n-                .append(\"familyStrList\", familyStrList)\n-                .append(\"memberList\", memberList)\n-                .append(\"aclParams\", aclParams)\n-                .append(\"action\", action)\n-                .append(\"token\", token);\n-        String operationId = UuidUtils.generateOpenCgaUuid(UuidUtils.Entity.AUDIT);\n-\n-        try {\n-            if (familyStrList == null || familyStrList.isEmpty()) {\n-                throw new CatalogException(\"Update ACL: Missing family parameter\");\n-            }\n-\n-            if (action == null) {\n-                throw new CatalogException(\"Invalid action found. Please choose a valid action to be performed.\");\n-            }\n-\n-            List<String> permissions = Collections.emptyList();\n-            if (StringUtils.isNotEmpty(aclParams.getPermissions())) {\n-                permissions = Arrays.asList(aclParams.getPermissions().trim().replaceAll(\"\\\\s\", \"\").split(\",\"));\n-                checkPermissions(permissions, FamilyAclEntry.FamilyPermissions::valueOf);\n-            }\n-\n-            List<Family> familyList = internalGet(study.getUid(), familyStrList, INCLUDE_FAMILY_IDS, user, false).getResults();\n-\n-            authorizationManager.checkCanAssignOrSeePermissions(study.getUid(), user);\n-\n-            // Validate that the members are actually valid members\n-            List<String> members;\n-            if (memberList != null && !memberList.isEmpty()) {\n-                members = Arrays.asList(memberList.split(\",\"));\n-            } else {\n-                members = Collections.emptyList();\n-            }\n-            authorizationManager.checkNotAssigningPermissionsToAdminsGroup(members);\n-            checkMembers(study.getUid(), members);\n-\n-            List<Long> familyUids = familyList.stream().map(Family::getUid).collect(Collectors.toList());\n-            AuthorizationManager.CatalogAclParams catalogAclParams = new AuthorizationManager.CatalogAclParams(familyUids, permissions,\n-                    Enums.Resource.FAMILY);\n-\n-            OpenCGAResult<Map<String, List<String>>> aclResults;\n-            switch (action) {\n-                case SET:\n-                    aclResults = authorizationManager.setAcls(study.getUid(), members, catalogAclParams);\n-                    break;\n-                case ADD:\n-                    aclResults = authorizationManager.addAcls(study.getUid(), members, catalogAclParams);\n-                    break;\n-                case REMOVE:\n-                    aclResults = authorizationManager.removeAcls(members, catalogAclParams);\n-                    break;\n-                case RESET:\n-                    catalogAclParams.setPermissions(null);\n-                    aclResults = authorizationManager.removeAcls(members, catalogAclParams);\n-                    break;\n-                default:\n-                    throw new CatalogException(\"Unexpected error occurred. No valid action found.\");\n-            }\n-\n-            for (Family family : familyList) {\n-                auditManager.audit(operationId, user, Enums.Action.UPDATE_ACLS, Enums.Resource.FAMILY, family.getId(),\n-                        family.getUuid(), study.getId(), study.getUuid(), auditParams,\n-                        new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS), new ObjectMap());\n-            }\n-            return aclResults;\n-        } catch (CatalogException e) {\n-            if (familyStrList != null) {\n-                for (String familyId : familyStrList) {\n-                    auditManager.audit(operationId, user, Enums.Action.UPDATE_ACLS, Enums.Resource.FAMILY, familyId, \"\",\n-                            study.getId(), study.getUuid(), auditParams, new AuditRecord.Status(AuditRecord.Status.Result.ERROR,\n-                                    e.getError()), new ObjectMap());\n-                }\n-            }\n-            throw e;\n-        }\n-    }\n-\n-    public DataResult<FacetField> facet(String studyId, Query query, QueryOptions options, boolean defaultStats, String token)\n-            throws CatalogException {\n-        ParamUtils.defaultObject(query, Query::new);\n-        ParamUtils.defaultObject(options, QueryOptions::new);\n-\n-        String userId = userManager.getUserId(token);\n-        // We need to add variableSets and groups to avoid additional queries as it will be used in the catalogSolrManager\n-        Study study = catalogManager.getStudyManager().resolveId(studyId, userId, new QueryOptions(QueryOptions.INCLUDE,\n-                Arrays.asList(StudyDBAdaptor.QueryParams.VARIABLE_SET.key(), StudyDBAdaptor.QueryParams.GROUPS.key())));\n-\n-        ObjectMap auditParams = new ObjectMap()\n-                .append(\"studyId\", studyId)\n-                .append(\"query\", new Query(query))\n-                .append(\"options\", options)\n-                .append(\"defaultStats\", defaultStats)\n-                .append(\"token\", token);\n-\n-        try {\n-            if (defaultStats || StringUtils.isEmpty(options.getString(QueryOptions.FACET))) {\n-                String facet = options.getString(QueryOptions.FACET);\n-                options.put(QueryOptions.FACET, StringUtils.isNotEmpty(facet) ? defaultFacet + \";\" + facet : defaultFacet);\n-            }\n-\n-            AnnotationUtils.fixQueryAnnotationSearch(study, userId, query, authorizationManager);\n-\n-            try (CatalogSolrManager catalogSolrManager = new CatalogSolrManager(catalogManager)) {\n-                DataResult<FacetField> result = catalogSolrManager.facetedQuery(study, CatalogSolrManager.FAMILY_SOLR_COLLECTION, query,\n-                        options, userId);\n-                auditManager.auditFacet(userId, Enums.Resource.FAMILY, study.getId(), study.getUuid(), auditParams,\n-                        new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS));\n-\n-                return result;\n-            }\n-        } catch (CatalogException e) {\n-            auditManager.auditFacet(userId, Enums.Resource.FAMILY, study.getId(), study.getUuid(), auditParams,\n-                    new AuditRecord.Status(AuditRecord.Status.Result.ERROR, new Error(0, \"\", e.getMessage())));\n-            throw e;\n-        }\n+    // FIXME Pedro: this is a quick fix to allow create families without the parents, this needs to be reviewed.\n+    if (noParentsSet.size() > 0) {\n+//            throw new CatalogException(\"Some members that are not related to any other have been found: \"\n+//                    + noParentsSet.stream().map(Individual::getName).collect(Collectors.joining(\", \")));\n+      logger.warn(\"Some members that are not related to any other have been found: {}\",\n+          noParentsSet.stream().map(Individual::getId).collect(Collectors.joining(\", \")));\n     }\n+  }\n \n-    public static Pedigree getPedigreeFromFamily(Family family, String probandId) {\n-        List<Individual> members = family.getMembers();\n-        Map<String, Member> individualMap = new HashMap<>();\n-\n-        // Parse all the individuals\n-        for (Individual member : members) {\n-            Member individual = new Member(\n-                    member.getId(), member.getName(), null, null, null,\n-                    Member.Sex.getEnum(member.getSex().toString()), member.getLifeStatus(),\n-                    member.getPhenotypes(), member.getDisorders(), member.getAttributes());\n-            individualMap.put(individual.getId(), individual);\n-        }\n-\n-        // Fill parent information\n-        for (Individual member : members) {\n-            if (member.getFather() != null && StringUtils.isNotEmpty(member.getFather().getId())) {\n-                individualMap.get(member.getId()).setFather(individualMap.get(member.getFather().getId()));\n-            }\n-            if (member.getMother() != null && StringUtils.isNotEmpty(member.getMother().getId())) {\n-                individualMap.get(member.getId()).setMother(individualMap.get(member.getMother().getId()));\n-            }\n-        }\n-\n-        Member proband = null;\n-        if (StringUtils.isNotEmpty(probandId)) {\n-            proband = individualMap.get(probandId);\n-        }\n-\n-        List<Member> individuals = new ArrayList<>(individualMap.values());\n-        return new Pedigree(family.getId(), individuals, proband, family.getPhenotypes(), family.getDisorders(), family.getAttributes());\n-    }\n+  private void validatePhenotypes(Family family) throws CatalogException {\n+    if (family.getPhenotypes() == null || family.getPhenotypes().isEmpty()) {\n+      if (ListUtils.isNotEmpty(family.getMembers())) {\n+        Map<String, Phenotype> phenotypeMap = new HashMap<>();\n \n-    /**\n-     * Validate the list of members provided in the members list already exists (and retrieves their information).\n-     * It also makes sure the members provided inside the family object are valid and can be successfully created.\n-     * It merges all those members inside the family object afterwards.\n-     *\n-     * @param study     study.\n-     * @param family    family object.\n-     * @param members   Already existing members.\n-     * @param userId    user id.\n-     * @throws CatalogException if there is any kind of error.\n-     */\n-    private void autoCompleteFamilyMembers(Study study, Family family, List<String> members, String userId) throws CatalogException {\n-        List<Individual> memberList = new ArrayList<>();\n-\n-        if (family.getMembers() != null && !family.getMembers().isEmpty()) {\n-            // Check the user can create new individuals\n-            authorizationManager.checkStudyPermission(study.getUid(), userId, StudyAclEntry.StudyPermissions.WRITE_INDIVIDUALS);\n-\n-            // Validate the individuals can be created and are valid\n-            for (Individual individual : family.getMembers()) {\n-                catalogManager.getIndividualManager().validateNewIndividual(study, individual, null, userId, false);\n-                memberList.add(individual);\n+        for (Individual member : family.getMembers()) {\n+          if (ListUtils.isNotEmpty(member.getPhenotypes())) {\n+            for (Phenotype phenotype : member.getPhenotypes()) {\n+              phenotypeMap.put(phenotype.getId(), phenotype);\n             }\n+          }\n         }\n \n-        if (members != null && !members.isEmpty()) {\n-            // We remove any possible duplicate\n-            ArrayList<String> deduplicatedMemberIds = new ArrayList<>(new HashSet<>(members));\n-\n-            InternalGetDataResult<Individual> individualDataResult = catalogManager.getIndividualManager().internalGet(study.getUid(),\n-                    deduplicatedMemberIds, IndividualManager.INCLUDE_INDIVIDUAL_DISORDERS_PHENOTYPES, userId, false);\n-\n-            memberList.addAll(individualDataResult.getResults());\n+        // Set the new phenotype list\n+        List<Phenotype> phenotypeList = new ArrayList<>(phenotypeMap.values());\n+        family.setPhenotypes(phenotypeList);\n+      }\n+    } else {\n+      // We need to validate the phenotypes are actually correct\n+      if (family.getMembers() == null || family.getMembers().isEmpty()) {\n+        throw new CatalogException(\"Missing family members\");\n+      }\n+\n+      // Validate all the phenotypes are contained in at least one individual\n+      Set<String> memberPhenotypes = new HashSet<>();\n+      for (Individual individual : family.getMembers()) {\n+        if (individual.getPhenotypes() != null && !individual.getPhenotypes().isEmpty()) {\n+          memberPhenotypes.addAll(individual.getPhenotypes().stream().map(Phenotype::getId).collect(Collectors.toSet()));\n         }\n-\n-        family.setMembers(memberList);\n+      }\n+      Set<String> familyPhenotypes = family.getPhenotypes().stream().map(Phenotype::getId).collect(Collectors.toSet());\n+      if (!familyPhenotypes.containsAll(memberPhenotypes)) {\n+        throw new CatalogException(\"Some of the phenotypes are not present in any member of the family\");\n+      }\n     }\n+  }\n \n-    private void validateFamily(Family family) throws CatalogException {\n-        if (family.getMembers() == null || family.getMembers().isEmpty()) {\n-            return;\n-        }\n-\n-        Map<String, Individual> membersMap = new HashMap<>();       // individualName|individualId: Individual\n-        Map<String, List<Individual>> parentsMap = new HashMap<>(); // motherName||F---fatherName||M: List<children>\n-        Set<Individual> noParentsSet = new HashSet<>();             // Set with individuals without parents\n+  private void validateDisorders(Family family) throws CatalogException {\n+    if (ListUtils.isEmpty(family.getDisorders())) {\n+      if (ListUtils.isNotEmpty(family.getMembers())) {\n+        // Obtain the union of all disorders\n+        Map<String, Disorder> disorderMap = new HashMap<>();\n+        Map<String, Map<String, Phenotype>> disorderPhenotypeMap = new HashMap<>();\n \n-        // 1. Fill in the objects initialised above\n-        for (Individual individual : family.getMembers()) {\n-            membersMap.put(individual.getId(), individual);\n-            if (individual.getUid() > 0) {\n-                membersMap.put(String.valueOf(individual.getUid()), individual);\n-            }\n+        for (Individual member : family.getMembers()) {\n+          if (ListUtils.isNotEmpty(member.getDisorders())) {\n+            for (Disorder disorder : member.getDisorders()) {\n+              disorderMap.put(disorder.getId(), disorder);\n \n-            String parentsKey = null;\n-            if (individual.getMother() != null) {\n-                if (individual.getMother().getUid() > 0) {\n-                    individual.getMother().setId(String.valueOf(individual.getMother().getUid()));\n-                }\n-                if (!StringUtils.isEmpty(individual.getMother().getId())) {\n-                    parentsKey = individual.getMother().getId() + \"||F\";\n-                }\n-            }\n-            if (individual.getFather() != null) {\n-                if (parentsKey != null) {\n-                    parentsKey += \"---\";\n-                }\n-                if (individual.getFather().getUid() > 0) {\n-                    individual.getFather().setId(String.valueOf(individual.getFather().getUid()));\n-                }\n-                if (!StringUtils.isEmpty(individual.getFather().getId())) {\n-                    if (parentsKey != null) {\n-                        parentsKey += individual.getFather().getId() + \"||M\";\n-                    } else {\n-                        parentsKey = individual.getFather().getId() + \"||M\";\n-                    }\n-                }\n-            }\n-            if (parentsKey == null) {\n-                noParentsSet.add(individual);\n-            } else {\n-                if (!parentsMap.containsKey(parentsKey)) {\n-                    parentsMap.put(parentsKey, new ArrayList<>());\n+              if (ListUtils.isNotEmpty(disorder.getEvidences())) {\n+                if (!disorderPhenotypeMap.containsKey(disorder.getId())) {\n+                  disorderPhenotypeMap.put(disorder.getId(), new HashMap<>());\n                 }\n-                parentsMap.get(parentsKey).add(individual);\n-            }\n-        }\n \n-        // 2. Loop over the parentsMap object. We will be emptying the noParentsSet as soon as we find a parent in the set. Once,\n-        // everything finishes, that set should be empty. Otherwise, it will mean that parent is not in use\n-        // On the other hand, all the parents should exist in the membersMap, otherwise it will mean that is missing in the family\n-        for (Map.Entry<String, List<Individual>> parentListEntry : parentsMap.entrySet()) {\n-            String[] split = parentListEntry.getKey().split(\"---\");\n-            for (String parentName : split) {\n-                String[] splitNameSex = parentName.split(\"\\\\|\\\\|\");\n-                String name = splitNameSex[0];\n-                IndividualProperty.Sex sex = splitNameSex[1].equals(\"F\") ? IndividualProperty.Sex.FEMALE : IndividualProperty.Sex.MALE;\n-\n-                if (!membersMap.containsKey(name)) {\n-                    throw new CatalogException(\"The parent \" + name + \" is not present in the members list\");\n-                } else {\n-                    // Check if the sex is correct\n-                    IndividualProperty.Sex sex1 = membersMap.get(name).getSex();\n-                    if (sex1 != null && sex1 != sex && sex1 != IndividualProperty.Sex.UNKNOWN) {\n-                        throw new CatalogException(\"Sex of parent \" + name + \" is incorrect or the relationship is incorrect. In \"\n-                                + \"principle, it should be \" + sex);\n-                    }\n-                    membersMap.get(name).setSex(sex);\n-\n-                    // We attempt to remove the individual from the noParentsSet\n-                    noParentsSet.remove(membersMap.get(name));\n+                for (Phenotype evidence : disorder.getEvidences()) {\n+                  disorderPhenotypeMap.get(disorder.getId()).put(evidence.getId(), evidence);\n                 }\n+              }\n             }\n+          }\n         }\n \n-        // FIXME Pedro: this is a quick fix to allow create families without the parents, this needs to be reviewed.\n-        if (noParentsSet.size() > 0) {\n-//            throw new CatalogException(\"Some members that are not related to any other have been found: \"\n-//                    + noParentsSet.stream().map(Individual::getName).collect(Collectors.joining(\", \")));\n-            logger.warn(\"Some members that are not related to any other have been found: {}\",\n-                    noParentsSet.stream().map(Individual::getId).collect(Collectors.joining(\", \")));\n+        // Set the new disorder list\n+        List<Disorder> disorderList = new ArrayList<>(disorderMap.size());\n+        for (Disorder disorder : disorderMap.values()) {\n+          List<Phenotype> phenotypeList = null;\n+          if (disorderPhenotypeMap.get(disorder.getId()) != null) {\n+            phenotypeList = new ArrayList<>(disorderPhenotypeMap.get(disorder.getId()).values());\n+          }\n+          disorder.setEvidences(phenotypeList);\n+          disorderList.add(disorder);\n         }\n-    }\n-\n-    private void validatePhenotypes(Family family) throws CatalogException {\n-        if (family.getPhenotypes() == null || family.getPhenotypes().isEmpty()) {\n-            if (ListUtils.isNotEmpty(family.getMembers())) {\n-                Map<String, Phenotype> phenotypeMap = new HashMap<>();\n-\n-                for (Individual member : family.getMembers()) {\n-                    if (ListUtils.isNotEmpty(member.getPhenotypes())) {\n-                        for (Phenotype phenotype : member.getPhenotypes()) {\n-                            phenotypeMap.put(phenotype.getId(), phenotype);\n-                        }\n-                    }\n-                }\n-\n-                // Set the new phenotype list\n-                List<Phenotype> phenotypeList = new ArrayList<>(phenotypeMap.values());\n-                family.setPhenotypes(phenotypeList);\n-            }\n-        } else {\n-            // We need to validate the phenotypes are actually correct\n-            if (family.getMembers() == null || family.getMembers().isEmpty()) {\n-                throw new CatalogException(\"Missing family members\");\n-            }\n \n-            // Validate all the phenotypes are contained in at least one individual\n-            Set<String> memberPhenotypes = new HashSet<>();\n-            for (Individual individual : family.getMembers()) {\n-                if (individual.getPhenotypes() != null && !individual.getPhenotypes().isEmpty()) {\n-                    memberPhenotypes.addAll(individual.getPhenotypes().stream().map(Phenotype::getId).collect(Collectors.toSet()));\n-                }\n-            }\n-            Set<String> familyPhenotypes = family.getPhenotypes().stream().map(Phenotype::getId).collect(Collectors.toSet());\n-            if (!familyPhenotypes.containsAll(memberPhenotypes)) {\n-                throw new CatalogException(\"Some of the phenotypes are not present in any member of the family\");\n-            }\n+        family.setDisorders(disorderList);\n+      }\n+    } else {\n+      // We need to validate the disorders are actually correct\n+      if (family.getMembers() == null || family.getMembers().isEmpty()) {\n+        throw new CatalogException(\"Missing family members\");\n+      }\n+\n+      // Validate all the disorders are contained in at least one individual\n+      Set<String> memberDisorders = new HashSet<>();\n+      for (Individual individual : family.getMembers()) {\n+        if (ListUtils.isNotEmpty(individual.getDisorders())) {\n+          memberDisorders.addAll(individual.getDisorders().stream().map(Disorder::getId).collect(Collectors.toSet()));\n         }\n+      }\n+      Set<String> familyDisorders = family.getDisorders().stream().map(Disorder::getId).collect(Collectors.toSet());\n+      if (!familyDisorders.containsAll(memberDisorders)) {\n+        throw new CatalogException(\"Some of the disorders are not present in any member of the family\");\n+      }\n     }\n+  }\n \n-    private void validateDisorders(Family family) throws CatalogException {\n-        if (ListUtils.isEmpty(family.getDisorders())) {\n-            if (ListUtils.isNotEmpty(family.getMembers())) {\n-                // Obtain the union of all disorders\n-                Map<String, Disorder> disorderMap = new HashMap<>();\n-                Map<String, Map<String, Phenotype>> disorderPhenotypeMap = new HashMap<>();\n-\n-                for (Individual member : family.getMembers()) {\n-                    if (ListUtils.isNotEmpty(member.getDisorders())) {\n-                        for (Disorder disorder : member.getDisorders()) {\n-                            disorderMap.put(disorder.getId(), disorder);\n-\n-                            if (ListUtils.isNotEmpty(disorder.getEvidences())) {\n-                                if (!disorderPhenotypeMap.containsKey(disorder.getId())) {\n-                                    disorderPhenotypeMap.put(disorder.getId(), new HashMap<>());\n-                                }\n-\n-                                for (Phenotype evidence : disorder.getEvidences()) {\n-                                    disorderPhenotypeMap.get(disorder.getId()).put(evidence.getId(), evidence);\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-\n-                // Set the new disorder list\n-                List<Disorder> disorderList = new ArrayList<>(disorderMap.size());\n-                for (Disorder disorder : disorderMap.values()) {\n-                    List<Phenotype> phenotypeList = null;\n-                    if (disorderPhenotypeMap.get(disorder.getId()) != null) {\n-                        phenotypeList = new ArrayList<>(disorderPhenotypeMap.get(disorder.getId()).values());\n-                    }\n-                    disorder.setEvidences(phenotypeList);\n-                    disorderList.add(disorder);\n-                }\n \n-                family.setDisorders(disorderList);\n-            }\n-        } else {\n-            // We need to validate the disorders are actually correct\n-            if (family.getMembers() == null || family.getMembers().isEmpty()) {\n-                throw new CatalogException(\"Missing family members\");\n-            }\n-\n-            // Validate all the disorders are contained in at least one individual\n-            Set<String> memberDisorders = new HashSet<>();\n-            for (Individual individual : family.getMembers()) {\n-                if (ListUtils.isNotEmpty(individual.getDisorders())) {\n-                    memberDisorders.addAll(individual.getDisorders().stream().map(Disorder::getId).collect(Collectors.toSet()));\n-                }\n-            }\n-            Set<String> familyDisorders = family.getDisorders().stream().map(Disorder::getId).collect(Collectors.toSet());\n-            if (!familyDisorders.containsAll(memberDisorders)) {\n-                throw new CatalogException(\"Some of the disorders are not present in any member of the family\");\n-            }\n-        }\n+  private void calculateRoles(Study study, Family family, String user)\n+      throws CatalogDBException, CatalogParameterException, CatalogAuthorizationException {\n+    if (family.getMembers() == null || family.getMembers().size() <= 1) {\n+      family.setRoles(Collections.emptyMap());\n+      // Nothing to calculate\n+      return;\n     }\n \n+    Set<String> individualIds = family.getMembers().stream().map(Individual::getId).collect(Collectors.toSet());\n \n-    private void calculateRoles(Study study, Family family, String user)\n-            throws CatalogDBException, CatalogParameterException, CatalogAuthorizationException {\n-        if (family.getMembers() == null || family.getMembers().size() <= 1) {\n-            family.setRoles(Collections.emptyMap());\n-            // Nothing to calculate\n-            return;\n+    QueryOptions options = new QueryOptions(QueryOptions.INCLUDE, IndividualDBAdaptor.QueryParams.ID.key());\n+    Map<String, Map<String, Family.FamiliarRelationship>> roles = new HashMap<>();\n+    for (Individual member : family.getMembers()) {\n+      List<Individual> individualList = catalogManager.getIndividualManager().calculateRelationship(study, member, 2, options, user);\n+      Map<String, Family.FamiliarRelationship> memberRelation = new HashMap<>();\n+      for (Individual individual : individualList) {\n+        if (individualIds.contains(individual.getId())) {\n+          memberRelation.put(individual.getId(), IndividualManager.extractIndividualRelation(individual));\n         }\n-\n-        Set<String> individualIds = family.getMembers().stream().map(Individual::getId).collect(Collectors.toSet());\n-\n-        QueryOptions options = new QueryOptions(QueryOptions.INCLUDE, IndividualDBAdaptor.QueryParams.ID.key());\n-        Map<String, Map<String, Family.FamiliarRelationship>> roles = new HashMap<>();\n-        for (Individual member : family.getMembers()) {\n-            List<Individual> individualList = catalogManager.getIndividualManager().calculateRelationship(study, member, 2, options, user);\n-            Map<String, Family.FamiliarRelationship> memberRelation = new HashMap<>();\n-            for (Individual individual : individualList) {\n-                if (individualIds.contains(individual.getId())) {\n-                    memberRelation.put(individual.getId(), IndividualManager.extractIndividualRelation(individual));\n-                }\n-            }\n-            roles.put(member.getId(), memberRelation);\n-        }\n-\n-        family.setRoles(roles);\n+      }\n+      roles.put(member.getId(), memberRelation);\n     }\n \n+    family.setRoles(roles);\n+  }\n+\n }\n",
            "diff_size": 2113
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "365",
                    "severity": "error",
                    "message": "Line is longer than 140 characters (found 143).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "599",
                    "severity": "error",
                    "message": "Line is longer than 140 characters (found 199).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "608",
                    "severity": "error",
                    "message": "Line is longer than 140 characters (found 175).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "617",
                    "severity": "error",
                    "message": "Line is longer than 140 characters (found 175).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "641",
                    "severity": "error",
                    "message": "Line is longer than 140 characters (found 185).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "659",
                    "severity": "error",
                    "message": "Line is longer than 140 characters (found 196).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "976",
                    "severity": "error",
                    "message": "Line is longer than 140 characters (found 244).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1112",
                    "severity": "error",
                    "message": "Line is longer than 140 characters (found 214).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/373/FamilyManager.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/naturalize/373/FamilyManager.java\nindex 095fea6f2b0..38afe0e5053 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/373/FamilyManager.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/naturalize/373/FamilyManager.java\n@@ -596,8 +596,7 @@ public class FamilyManager extends AnnotationSetManager<Family> {\n         return ParamUtils.defaultObject(queryResult, OpenCGAResult::new);\n     }\n \n-    public OpenCGAResult<Family> updateAnnotationSet(String studyStr, String familyStr, List<AnnotationSet> annotationSetList,\n-                                                     ParamUtils.BasicUpdateAction action, QueryOptions options, String token)\n+    public OpenCGAResult<Family> updateAnnotationSet(String studyStr, String familyStr, List<AnnotationSet> annotationSetList, ParamUtils.BasicUpdateAction action, QueryOptions options, String token)\n             throws CatalogException {\n         FamilyUpdateParams updateParams = new FamilyUpdateParams().setAnnotationSets(annotationSetList);\n         options = ParamUtils.defaultObject(options, QueryOptions::new);\n@@ -606,9 +605,8 @@ public class FamilyManager extends AnnotationSetManager<Family> {\n         return update(studyStr, familyStr, updateParams, options, token);\n     }\n \n-    public OpenCGAResult<Family> addAnnotationSet(String studyStr, String familyStr, AnnotationSet annotationSet, QueryOptions options,\n-                                                  String token) throws CatalogException {\n-        return addAnnotationSets(studyStr, familyStr, Collections.singletonList(annotationSet), options, token);\n+    public OpenCGAResult<Family> addAnnotationSet(String studyStr, String familyStr, AnnotationSet annotationSet, QueryOptions options, String token) throws CatalogException {\n+    return addAnnotationSets(studyStr, familyStr, Collections.singletonList(annotationSet), options, token);\n     }\n \n     public OpenCGAResult<Family> addAnnotationSets(String studyStr, String familyStr, List<AnnotationSet> annotationSetList,\n@@ -616,9 +614,8 @@ public class FamilyManager extends AnnotationSetManager<Family> {\n         return updateAnnotationSet(studyStr, familyStr, annotationSetList, ParamUtils.BasicUpdateAction.ADD, options, token);\n     }\n \n-    public OpenCGAResult<Family> setAnnotationSet(String studyStr, String familyStr, AnnotationSet annotationSet, QueryOptions options,\n-                                                  String token) throws CatalogException {\n-        return setAnnotationSets(studyStr, familyStr, Collections.singletonList(annotationSet), options, token);\n+    public OpenCGAResult<Family> setAnnotationSet(String studyStr, String familyStr, AnnotationSet annotationSet, QueryOptions options, String token) throws CatalogException {\n+    return setAnnotationSets(studyStr, familyStr, Collections.singletonList(annotationSet), options, token);\n     }\n \n     public OpenCGAResult<Family> setAnnotationSets(String studyStr, String familyStr, List<AnnotationSet> annotationSetList,\n@@ -633,7 +630,7 @@ public class FamilyManager extends AnnotationSetManager<Family> {\n \n     public OpenCGAResult<Family> removeAnnotationSets(String studyStr, String familyStr, List<String> annotationSetIdList,\n                                                       QueryOptions options, String token) throws CatalogException {\n-        List<AnnotationSet> annotationSetList = annotationSetIdList\n+    List<AnnotationSet> annotationSetList = annotationSetIdList\n                 .stream()\n                 .map(id -> new AnnotationSet().setId(id))\n                 .collect(Collectors.toList());\n@@ -641,8 +638,7 @@ public class FamilyManager extends AnnotationSetManager<Family> {\n     }\n \n     public OpenCGAResult<Family> updateAnnotations(String studyStr, String familyStr, String annotationSetId,\n-                                                   Map<String, Object> annotations, ParamUtils.CompleteUpdateAction action,\n-                                                   QueryOptions options, String token) throws CatalogException {\n+                                                   Map<String, Object> annotations, ParamUtils.CompleteUpdateAction action, QueryOptions options, String token) throws CatalogException {\n         if (annotations == null || annotations.isEmpty()) {\n             throw new CatalogException(\"Missing array of annotations.\");\n         }\n@@ -660,20 +656,19 @@ public class FamilyManager extends AnnotationSetManager<Family> {\n                 ParamUtils.CompleteUpdateAction.REMOVE, options, token);\n     }\n \n-    public OpenCGAResult<Family> resetAnnotations(String studyStr, String familyStr, String annotationSetId, List<String> annotations,\n-                                                  QueryOptions options, String token) throws CatalogException {\n-        return updateAnnotations(studyStr, familyStr, annotationSetId, new ObjectMap(\"reset\", StringUtils.join(annotations, \",\")),\n+    public OpenCGAResult<Family> resetAnnotations(String studyStr, String familyStr, String annotationSetId, List<String> annotations, QueryOptions options, String token) throws CatalogException {\n+    return updateAnnotations(studyStr, familyStr, annotationSetId, new ObjectMap(\"reset\", StringUtils.join(annotations, \",\")),\n                 ParamUtils.CompleteUpdateAction.RESET, options, token);\n     }\n \n     public OpenCGAResult<Family> update(String studyStr, Query query, FamilyUpdateParams updateParams, QueryOptions options,\n                                         String token) throws CatalogException {\n-        return update(studyStr, query, updateParams, false, options, token);\n+    return update(studyStr, query, updateParams, false, options, token);\n     }\n \n     public OpenCGAResult<Family> update(String studyStr, Query query, FamilyUpdateParams updateParams, boolean ignoreException,\n                                         QueryOptions options, String token) throws CatalogException {\n-        String userId = userManager.getUserId(token);\n+    String userId = userManager.getUserId(token);\n         Study study = studyManager.resolveId(studyStr, userId, StudyManager.INCLUDE_VARIABLE_SET);\n \n         String operationId = UuidUtils.generateOpenCgaUuid(UuidUtils.Entity.AUDIT);\n@@ -737,7 +732,7 @@ public class FamilyManager extends AnnotationSetManager<Family> {\n \n     public OpenCGAResult<Family> update(String studyStr, String familyId, FamilyUpdateParams updateParams, QueryOptions options,\n                                         String token) throws CatalogException {\n-        String userId = userManager.getUserId(token);\n+    String userId = userManager.getUserId(token);\n         Study study = studyManager.resolveId(studyStr, userId, StudyManager.INCLUDE_VARIABLE_SET);\n \n         String operationId = UuidUtils.generateOpenCgaUuid(UuidUtils.Entity.AUDIT);\n@@ -802,12 +797,12 @@ public class FamilyManager extends AnnotationSetManager<Family> {\n      */\n     public OpenCGAResult<Family> update(String studyStr, List<String> familyIds, FamilyUpdateParams updateParams, QueryOptions options,\n                                         String token) throws CatalogException {\n-        return update(studyStr, familyIds, updateParams, false, options, token);\n+    return update(studyStr, familyIds, updateParams, false, options, token);\n     }\n \n     public OpenCGAResult<Family> update(String studyStr, List<String> familyIds, FamilyUpdateParams updateParams, boolean ignoreException,\n                                         QueryOptions options, String token) throws CatalogException {\n-        String userId = userManager.getUserId(token);\n+    String userId = userManager.getUserId(token);\n         Study study = studyManager.resolveId(studyStr, userId, StudyManager.INCLUDE_VARIABLE_SET);\n \n         String operationId = UuidUtils.generateOpenCgaUuid(UuidUtils.Entity.AUDIT);\n@@ -978,10 +973,8 @@ public class FamilyManager extends AnnotationSetManager<Family> {\n         return familyDBAdaptor.update(family.getUid(), parameters, study.getVariableSets(), options);\n     }\n \n-    public Map<String, List<String>> calculateFamilyGenotypes(String studyStr, String clinicalAnalysisId, String familyId,\n-                                                              ClinicalProperty.ModeOfInheritance moi, String disorderId,\n-                                                              Penetrance penetrance, String token) throws CatalogException {\n-        Pedigree pedigree;\n+    public Map<String, List<String>> calculateFamilyGenotypes(String studyStr, String clinicalAnalysisId, String familyId, ClinicalProperty.ModeOfInheritance moi, String disorderId, Penetrance penetrance, String token) throws CatalogException {\n+    Pedigree pedigree;\n         Disorder disorder = null;\n \n         if (StringUtils.isNotEmpty(clinicalAnalysisId)) {\n@@ -1116,9 +1109,7 @@ public class FamilyManager extends AnnotationSetManager<Family> {\n         }\n     }\n \n-    public OpenCGAResult<Map<String, List<String>>> updateAcl(String studyId, List<String> familyStrList, String memberList,\n-                                                              AclParams aclParams, ParamUtils.AclAction action, String token)\n-            throws CatalogException {\n+    public OpenCGAResult<Map<String, List<String>>> updateAcl(String studyId, List<String> familyStrList, String memberList, AclParams aclParams, ParamUtils.AclAction action, String token) throws CatalogException {\n         String user = userManager.getUserId(token);\n         Study study = studyManager.resolveId(studyId, user);\n \n@@ -1181,7 +1172,7 @@ public class FamilyManager extends AnnotationSetManager<Family> {\n                     break;\n                 default:\n                     throw new CatalogException(\"Unexpected error occurred. No valid action found.\");\n-            }\n+    }\n \n             for (Family family : familyList) {\n                 auditManager.audit(operationId, user, Enums.Action.UPDATE_ACLS, Enums.Resource.FAMILY, family.getId(),\n@@ -1519,4 +1510,4 @@ public class FamilyManager extends AnnotationSetManager<Family> {\n         family.setRoles(roles);\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 28
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "365",
                    "severity": "error",
                    "message": "Line is longer than 140 characters (found 143).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "365",
                    "column": "46",
                    "severity": "error",
                    "message": "'.' is followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.NoWhitespaceAfterCheck"
                },
                {
                    "line": "365",
                    "column": "74",
                    "severity": "error",
                    "message": "',' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAfterCheck"
                },
                {
                    "line": "367",
                    "column": "13",
                    "severity": "error",
                    "message": "'(' is preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.MethodParamPadCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/373/FamilyManager.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/styler_three_grams/373/FamilyManager.java\nindex 095fea6f2b0..a620159ff9e 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/373/FamilyManager.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/styler_three_grams/373/FamilyManager.java\n@@ -362,7 +362,9 @@ public class FamilyManager extends AnnotationSetManager<Family> {\n         if (query.containsKey(IndividualDBAdaptor.QueryParams.SAMPLES.key())) {\n             if (StringUtils.isNotEmpty(query.getString(IndividualDBAdaptor.QueryParams.SAMPLES.key()))) {\n                 Query newQuery = new Query()\n-                        .append(IndividualDBAdaptor.QueryParams.SAMPLES.key(), query.getString(IndividualDBAdaptor.QueryParams.SAMPLES.key()));\n+                .append(IndividualDBAdaptor . QueryParams .SAMPLES.key(),query.getString(\n+                        IndividualDBAdaptor.QueryParams.SAMPLES.\n+        key ()));\n                 QueryOptions options = new QueryOptions(QueryOptions.INCLUDE, IndividualDBAdaptor.QueryParams.UID.key());\n                 OpenCGAResult<Individual> individualResult = catalogManager.getIndividualManager()\n                         .search(study.getFqn(), newQuery, options, sessionId);\n",
            "diff_size": 3
        }
    ],
    "repaired_by": [
        "intellij"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}