{
    "project_name": "wso2-attic-commons",
    "error_id": "265",
    "information": {
        "errors": [
            {
                "line": "456",
                "severity": "error",
                "message": "Line is longer than 120 characters (found 121).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": "                        AxisOperation axisOperation = mercuryMessageContext.getMessageContext().getAxisOperation();\n                        if (axisOperation.getMessage(WSDLConstants.MESSAGE_LABEL_OUT_VALUE) != null){\n                            faultContext.setAxisMessage(axisOperation.getMessage(WSDLConstants.MESSAGE_LABEL_OUT_VALUE));\n                        } else {\n                            faultContext.setAxisMessage(axisOperation.getMessage(WSDLConstants.MESSAGE_LABEL_IN_VALUE));\n                        }",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/265/InvokerBuffer.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler/265/InvokerBuffer.java\nindex 3a3d8f05f6d..f01999ada8c 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/265/InvokerBuffer.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler/265/InvokerBuffer.java\n@@ -453,7 +453,7 @@ public class InvokerBuffer {\n                         //TODO: set the fault message it is available.\n                         AxisOperation axisOperation = mercuryMessageContext.getMessageContext().getAxisOperation();\n                         if (axisOperation.getMessage(WSDLConstants.MESSAGE_LABEL_OUT_VALUE) != null){\n-                            faultContext.setAxisMessage(axisOperation.getMessage(WSDLConstants.MESSAGE_LABEL_OUT_VALUE));\n+                        faultContext.setAxisMessage(axisOperation.getMessage(WSDLConstants.MESSAGE_LABEL_OUT_VALUE));\n                         } else {\n                             faultContext.setAxisMessage(axisOperation.getMessage(WSDLConstants.MESSAGE_LABEL_IN_VALUE));\n                         }\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/265/InvokerBuffer.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/intellij/265/InvokerBuffer.java\nindex 3a3d8f05f6d..eac85ea9338 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/265/InvokerBuffer.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/intellij/265/InvokerBuffer.java\n@@ -13,6 +13,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+\n package org.wso2.mercury.state;\n \n import org.wso2.mercury.context.MercuryMessageContext;\n@@ -82,831 +83,831 @@ import java.io.ByteArrayInputStream;\n \n public class InvokerBuffer {\n \n-    private static Log log = LogFactory.getLog(InvokerBuffer.class);\n+  private static Log log = LogFactory.getLog(InvokerBuffer.class);\n \n-    public static final int STATE_000 = 1;\n-    public static final int STATE_010 = 2;\n-    public static final int STATE_011 = 3;\n-    public static final int STATE_111 = 4;\n-    public static final int STATE_110 = 5;\n-    public static final int STATE_COMPLETE = 6;\n+  public static final int STATE_000 = 1;\n+  public static final int STATE_010 = 2;\n+  public static final int STATE_011 = 3;\n+  public static final int STATE_111 = 4;\n+  public static final int STATE_110 = 5;\n+  public static final int STATE_COMPLETE = 6;\n \n-    private int state;\n+  private int state;\n \n-    private long timeoutTime;\n+  private long timeoutTime;\n \n-    // message buffer contains the Message ID and the RMMessage context with\n-    // application message inside\n-    private Map messageBuffer;\n+  // message buffer contains the Message ID and the RMMessage context with\n+  // application message inside\n+  private Map messageBuffer;\n \n-    private Set receivedMessageNumbers;\n+  private Set receivedMessageNumbers;\n \n-    // this is the last message number of the original message\n-    // sequence.\n-    private long lastMessageNumber = 0;\n-    private long lastAccessTime = 0;\n+  // this is the last message number of the original message\n+  // sequence.\n+  private long lastMessageNumber = 0;\n+  private long lastAccessTime = 0;\n \n-    // this is the heighest message number send to the applicaiton\n-    private long lastMessageSendToApplication = 0;\n+  // this is the heighest message number send to the applicaiton\n+  private long lastMessageSendToApplication = 0;\n \n-    private InvokerBufferDto persistanceDto;\n-    private PersistenceManager persistenceManager;\n+  private InvokerBufferDto persistanceDto;\n+  private PersistenceManager persistenceManager;\n \n-    private boolean isAnonymous;\n+  private boolean isAnonymous;\n \n-    // this is used when sending the last message correctly\n-    private EndpointReference acksTo;\n+  // this is used when sending the last message correctly\n+  private EndpointReference acksTo;\n \n-    private InvokerWorker invokerWorker;\n+  private InvokerWorker invokerWorker;\n \n-    public InvokerBuffer(int state) {\n-        this.state = state;\n-        this.messageBuffer = new HashMap();\n-        this.receivedMessageNumbers = new HashSet();\n-        this.lastAccessTime = System.currentTimeMillis();\n-    }\n+  public InvokerBuffer(int state) {\n+    this.state = state;\n+    this.messageBuffer = new HashMap();\n+    this.receivedMessageNumbers = new HashSet();\n+    this.lastAccessTime = System.currentTimeMillis();\n+  }\n \n-    public synchronized void applicatinMessageReceived(\n-            long messageNumber,\n-            MercuryMessageContext mercuryMessageContext,\n-            RMDSequenceDto rmdSequenceDto) throws PersistenceException {\n-\n-        this.lastAccessTime = System.currentTimeMillis();\n-        if (!this.receivedMessageNumbers.contains(new Long(messageNumber))) {\n-            //change the state\n-            int currentState = this.state;\n-            switch (state) {\n-                case STATE_000 : {\n-                    state = STATE_010;\n-                    if (this.persistanceDto != null){\n-                       this.persistanceDto.setState(state);\n-                    }\n-                    break;\n-                }\n-                case STATE_010 : {\n-                    break;\n-                }\n-                case STATE_011 : {\n-                    // application message can not be received in this stage\n-                    break;\n-                }\n-                case STATE_111 : {\n-                    // application message can not be received in this stage\n-                    break;\n-                }\n-                case STATE_110 : {\n-                    // application message can not be received in this stage\n-                    break;\n-                }\n-                case STATE_COMPLETE : {\n-                    break;\n-                }\n-            }\n+  public synchronized void applicatinMessageReceived(\n+    long messageNumber,\n+    MercuryMessageContext mercuryMessageContext,\n+    RMDSequenceDto rmdSequenceDto) throws PersistenceException {\n \n-            // here we have to assume that that there is not state change in\n-            // RMD Sequence if it is not a new message.\n-            // further always the receivedMessageNumbers in RMDSeqnce is always equals to the\n-            // receivedNumbers in the invoker buffer.\n-\n-            if (this.persistenceManager != null){\n-                SequenceReceivedNumberDto sequenceReceivedNumberDto = new SequenceReceivedNumberDto();\n-                sequenceReceivedNumberDto.setNumber(messageNumber);\n-                sequenceReceivedNumberDto.setRmdSequenceID(rmdSequenceDto.getId());\n-                if (mercuryMessageContext.getMessageContext().getRelatesTo() != null){\n-                   sequenceReceivedNumberDto.setRelatesToMessageID(\n-                           mercuryMessageContext.getMessageContext().getRelatesTo().getValue()); \n-                }\n-\n-                BufferReceivedNumberDto bufferReceivedNumberDto = new BufferReceivedNumberDto();\n-                bufferReceivedNumberDto.setNumber(messageNumber);\n-                bufferReceivedNumberDto.setInternalBufferID(this.persistanceDto.getId());\n-\n-                RMDMessageDto rmdMessageDto = new RMDMessageDto();\n-                rmdMessageDto.setMessageNumber(messageNumber);\n-                rmdMessageDto.setSoapEnvelope(mercuryMessageContext.getMessageContext().getEnvelope().toString());\n-                rmdMessageDto.setSend(false);\n-                rmdMessageDto.setInternalBufferID(this.persistanceDto.getId());\n-                rmdMessageDto.setOperationName(\n-                        mercuryMessageContext.getMessageContext().getAxisOperation().getName());\n-                rmdMessageDto.setAction(mercuryMessageContext.getMessageContext().getOptions().getAction());\n-                rmdMessageDto.setTo(mercuryMessageContext.getMessageContext().getTo().getAddress());\n-                rmdMessageDto.setReplyTo(mercuryMessageContext.getMessageContext().getReplyTo().getAddress());\n-                rmdMessageDto.setMessageID(mercuryMessageContext.getMessageContext().getMessageID());\n-\n-                // update the persistence storage\n-                try {\n-                    persistenceManager.updateMessageDetails(rmdSequenceDto,\n-                            this.persistanceDto,\n-                            sequenceReceivedNumberDto,\n-                            bufferReceivedNumberDto,\n-                            rmdMessageDto);\n-                    //store the persistence dto for future updates\n-                    mercuryMessageContext.setRmdPersistanceDto(rmdMessageDto);\n-                } catch (PersistenceException e) {\n-                    e.printStackTrace();\n-                    this.state = currentState;\n-                    this.persistanceDto.setState(currentState);\n-                    log.error(\"Can not update the persistence manager for message\" +\n-                            \" with message number ==> \" + messageNumber, e);\n-                    throw new PersistenceException(\"Can not update the persistence manager for message\" +\n-                            \" with message number ==> \" + messageNumber, e);\n-                }\n-\n-            }\n-            // exactly one delivary. duplicate messages are avoid\n-            this.messageBuffer.put(new Long(messageNumber), mercuryMessageContext);\n-            this.receivedMessageNumbers.add(new Long(messageNumber));\n+    this.lastAccessTime = System.currentTimeMillis();\n+    if (!this.receivedMessageNumbers.contains(new Long(messageNumber))) {\n+      //change the state\n+      int currentState = this.state;\n+      switch (state) {\n+      case STATE_000: {\n+        state = STATE_010;\n+        if (this.persistanceDto != null) {\n+          this.persistanceDto.setState(state);\n         }\n-    }\n-\n-    public synchronized void lastMessageReceived(\n-            long messageNumber,\n-            MercuryMessageContext mercuryMessageContext,\n-            RMDSequenceDto rmdSequenceDto) throws PersistenceException {\n-        this.lastAccessTime = System.currentTimeMillis();\n-\n-        if (!this.receivedMessageNumbers.contains(new Long(messageNumber))) {\n-            int currentState = this.state;\n-            //change the state\n-            switch (state) {\n-                case STATE_000 : {\n-                    state = STATE_110;\n-                    if (this.persistanceDto != null){\n-                        this.persistanceDto.setState(state);\n-                    }\n-                    break;\n-                }\n-                case STATE_010 : {\n-                    state = STATE_110;\n-                    if (this.persistanceDto != null){\n-                        this.persistanceDto.setState(state);\n-                    }\n-                    break;\n-                }\n-                case STATE_011 : {\n-                    // application message can not be received in this stage\n-                    break;\n-                }\n-                case STATE_111 : {\n-                    // application message can not be received in this stage\n-                    break;\n-                }\n-                case STATE_110 : {\n-                    // application message can not be received in this stage\n-                    break;\n-                }\n-                case STATE_COMPLETE : {\n-                    break;\n-                }\n-            }\n-\n-            if (this.persistenceManager != null){\n-                // we have to udate the persistence storage\n-                SequenceReceivedNumberDto sequenceReceivedNumberDto = new SequenceReceivedNumberDto();\n-                sequenceReceivedNumberDto.setNumber(messageNumber);\n-                sequenceReceivedNumberDto.setRmdSequenceID(rmdSequenceDto.getId());\n-                if (mercuryMessageContext.getMessageContext().getRelatesTo() != null){\n-                   sequenceReceivedNumberDto.setRelatesToMessageID(\n-                           mercuryMessageContext.getMessageContext().getRelatesTo().getValue());\n-                }\n-\n-                BufferReceivedNumberDto bufferReceivedNumberDto = new BufferReceivedNumberDto();\n-                bufferReceivedNumberDto.setNumber(messageNumber);\n-                bufferReceivedNumberDto.setInternalBufferID(this.persistanceDto.getId());\n-\n-                RMDMessageDto rmdMessageDto = new RMDMessageDto();\n-                rmdMessageDto.setMessageNumber(messageNumber);\n-                rmdMessageDto.setSoapEnvelope(\n-                        mercuryMessageContext.getMessageContext().getEnvelope().toString());\n-                rmdMessageDto.setSend(false);\n-                rmdMessageDto.setInternalBufferID(this.persistanceDto.getId());\n-                rmdMessageDto.setOperationName(\n-                        mercuryMessageContext.getMessageContext().getAxisOperation().getName());\n-                rmdMessageDto.setAction(mercuryMessageContext.getMessageContext().getOptions().getAction());\n-                rmdMessageDto.setTo(mercuryMessageContext.getMessageContext().getTo().getAddress());\n-                rmdMessageDto.setReplyTo(mercuryMessageContext.getMessageContext().getReplyTo().getAddress());\n-                rmdMessageDto.setMessageID(mercuryMessageContext.getMessageContext().getMessageID());\n-\n-                this.persistanceDto.setLastMessage(messageNumber);\n-\n-                // update the persistence storage\n-                try {\n-                    persistenceManager.updateMessageDetails(rmdSequenceDto,\n-                            this.persistanceDto,\n-                            sequenceReceivedNumberDto,\n-                            bufferReceivedNumberDto,\n-                            rmdMessageDto);\n-                    //store the persistence dto for future updates\n-                    mercuryMessageContext.setRmdPersistanceDto(rmdMessageDto);\n-                } catch (PersistenceException e) {\n-                    this.state = currentState;\n-                    this.persistanceDto.setState(currentState);\n-                    // unset the last message number since it shold not have set\n-                    // if we don't have received the last message number.\n-                    this.persistanceDto.setLastMessage(0);\n-                    log.error(\"Can not update the persistence manager for message\" +\n-                            \" with message number ==> \" + messageNumber, e);\n-                    throw new PersistenceException(\"Can not update the persistence manager for message\" +\n-                            \" with message number ==> \" + messageNumber, e);\n-                }\n-            }\n-\n-            this.lastMessageNumber = messageNumber;\n-            this.messageBuffer.put(new Long(messageNumber), mercuryMessageContext);\n-            this.receivedMessageNumbers.add(new Long(messageNumber));\n-\n+        break;\n+      }\n+      case STATE_010: {\n+        break;\n+      }\n+      case STATE_011: {\n+        // application message can not be received in this stage\n+        break;\n+      }\n+      case STATE_111: {\n+        // application message can not be received in this stage\n+        break;\n+      }\n+      case STATE_110: {\n+        // application message can not be received in this stage\n+        break;\n+      }\n+      case STATE_COMPLETE: {\n+        break;\n+      }\n+      }\n+\n+      // here we have to assume that that there is not state change in\n+      // RMD Sequence if it is not a new message.\n+      // further always the receivedMessageNumbers in RMDSeqnce is always equals to the\n+      // receivedNumbers in the invoker buffer.\n+\n+      if (this.persistenceManager != null) {\n+        SequenceReceivedNumberDto sequenceReceivedNumberDto = new SequenceReceivedNumberDto();\n+        sequenceReceivedNumberDto.setNumber(messageNumber);\n+        sequenceReceivedNumberDto.setRmdSequenceID(rmdSequenceDto.getId());\n+        if (mercuryMessageContext.getMessageContext().getRelatesTo() != null) {\n+          sequenceReceivedNumberDto.setRelatesToMessageID(\n+            mercuryMessageContext.getMessageContext().getRelatesTo().getValue());\n         }\n-    }\n-\n-    public boolean isMessagesCompleted() {\n-        // this means me must sure that we have received all the messages.\n-        return (lastMessageNumber != 0) && (receivedMessageNumbers.size() == lastMessageNumber);\n-    }\n-\n-    public synchronized void doActions() throws AxisFault {\n-        // first send what ever possible messages to the application\n-        while (this.messageBuffer.keySet().contains(new Long(lastMessageSendToApplication + 1))) {\n-            // if we have the next number in the buffer that must be send to the application\n-            lastMessageSendToApplication++;\n-            log.debug(\"Sending application message \" + lastMessageSendToApplication + \" to application\");\n-            MercuryMessageContext mercuryMessageContext =\n-                    (MercuryMessageContext) this.messageBuffer.remove(new Long(lastMessageSendToApplication));\n-            //here we need to update the state per message since persistence storage\n-            // updation should happen atomically\n-            // update the state of this object\n-            int currentState = this.state;\n-            switch (state) {\n-                case STATE_000 : {\n-                    break;\n-                }\n-                case STATE_010 : {\n-                    if (this.messageBuffer.size() == 0) {\n-                        state = STATE_000;\n-                        if (this.persistanceDto != null) {\n-                            this.persistanceDto.setState(state);\n-                        }\n-                    }\n-                    break;\n-                }\n-                case STATE_011 : {\n-                    if (this.messageBuffer.size() == 0) {\n-                        state = STATE_COMPLETE;\n-                        if (this.persistanceDto != null) {\n-                            this.persistanceDto.setState(state);\n-                        }\n-                    }\n-                    break;\n-                }\n-                case STATE_111 : {\n-                    if (this.messageBuffer.size() == 0) {\n-                        state = STATE_COMPLETE;\n-                        if (this.persistanceDto != null) {\n-                            this.persistanceDto.setState(state);\n-                        }\n-                    }\n-                    break;\n-                }\n-                case STATE_110 : {\n-                    if (this.messageBuffer.size() == 0) {\n-                        state = STATE_COMPLETE;\n-                        if (this.persistanceDto != null) {\n-                            this.persistanceDto.setState(state);\n-                        }\n-                    }\n-                    break;\n-                }\n-                case STATE_COMPLETE : {\n-                    break;\n-                }\n-            }\n \n-            //set this message as send\n-            if (this.persistenceManager != null) {\n-                // update the rmd message\n-                try {\n-                    this.persistanceDto.setLastMessageToApplication(lastMessageSendToApplication);\n-                    mercuryMessageContext.getRmdPersistanceDto().setSend(true);\n-                    this.persistenceManager.update(\n-                            mercuryMessageContext.getRmdPersistanceDto(), this.persistanceDto);\n-                } catch (PersistenceException e) {\n-                    this.state = currentState;\n-                    this.persistanceDto.setState(state);\n-                    this.messageBuffer.put(new Long(lastMessageSendToApplication), mercuryMessageContext);\n-                    mercuryMessageContext.getRmdPersistanceDto().setSend(false);\n-                    lastMessageSendToApplication--;\n-                    log.error(\"Problem when updating the data base to send the message to application\", e);\n-                    break;\n-                }\n-            }\n-\n-            // AxisEngine.resumeReceive method invokes the last handler again\n-            // to avoid this problem we set the this message context as and mercury controll message.\n-            mercuryMessageContext.getMessageContext().setProperty(\n-                    MercuryConstants.PROCESS_RM_CONTROL_MESSAGE, Constants.VALUE_TRUE);\n-            // send the message to upper later.\n-            if (isAnonymous && !mercuryMessageContext.getMessageContext().isServerSide()) {\n-                // if this is an annonymous client side response. then we can not initiate\n-                // threads for this. the only thing we have to do is to notify the listning thread\n-                this.notifyAll();\n-            } else {\n-                // we can not start seperate threads here.\n-                // since we have to gurantee the inorder delivary\n-                try{\n-                   MessageContext applicationMsgContext = mercuryMessageContext.getMessageContext();\n-                   // dummy last messages should not send to the application.\n-                   if (!applicationMsgContext.getOptions().getAction().equals(\n-                           MercuryConstants.LAST_MESSAGE_ACTION)){\n-                       AxisEngine.resumeReceive(mercuryMessageContext.getMessageContext());\n-                   } else {\n-                       // mep can be inout only at the server side\n-                       // we send this to in only sequences as well but those will stop at the\n-                       // mercury out handler level.\n-                       String sessionID = mercuryMessageContext.getRmApplicationMessage().getSequence().getSequenceID();\n-                       MessageContext outMessageContext =\n-                               getNewMessageContextForLastMessage(applicationMsgContext, sessionID);\n-                       outMessageContext.setProperty(AddressingConstants.WS_ADDRESSING_VERSION,\n-                               applicationMsgContext.getProperty(AddressingConstants.WS_ADDRESSING_VERSION));\n-                       outMessageContext.getOptions().setAction(MercuryConstants.LAST_MESSAGE_ACTION);\n-                       outMessageContext.setProperty(MercuryClientConstants.INTERNAL_KEY,\n-                               applicationMsgContext.getProperty(MercuryConstants.SESSION_ID));\n-                       outMessageContext.setProperty(MercuryClientConstants.LAST_MESSAGE, Constants.VALUE_TRUE);\n-\n-\n-                       AxisOperation axisOperation = applicationMsgContext.getAxisService().getOperationByAction(\n-                               MercuryConstants.LAST_MESSAGE_ACTION);\n-                       outMessageContext.setAxisMessage(axisOperation.getMessage(WSDLConstants.MESSAGE_LABEL_IN_VALUE));\n-\n-                       OperationContext operationContext =\n-                               applicationMsgContext.getServiceContext().createOperationContext(axisOperation);\n-                       axisOperation.registerOperationContext(outMessageContext, operationContext);\n-                       AxisEngine.send(outMessageContext);\n-                   }\n-\n-                } catch (AxisFault e){\n-                   // throw it back with the new message context.\n-                    if (e.getFaultType() == Constants.APPLICATION_FAULT) {\n-                        MessageContext faultContext =\n-                                MessageContextBuilder.createFaultMessageContext(\n-                                        mercuryMessageContext.getMessageContext(), e);\n-                        // set the Axis Message as the out message if a fault message is not\n-                        // there\n-                        //TODO: set the fault message it is available.\n-                        AxisOperation axisOperation = mercuryMessageContext.getMessageContext().getAxisOperation();\n-                        if (axisOperation.getMessage(WSDLConstants.MESSAGE_LABEL_OUT_VALUE) != null){\n-                            faultContext.setAxisMessage(axisOperation.getMessage(WSDLConstants.MESSAGE_LABEL_OUT_VALUE));\n-                        } else {\n-                            faultContext.setAxisMessage(axisOperation.getMessage(WSDLConstants.MESSAGE_LABEL_IN_VALUE));\n-                        }\n-\n-                        faultContext.setProperty(\"RECV_RESULTS\",\n-                                mercuryMessageContext.getMessageContext().getProperty(\"RECV_RESULTS\"));\n-\n-                        faultContext.setProperty(Constants.APPLICATION_FAULT_STRING, Constants.VALUE_TRUE);\n-                        // set the servlet transport property\n-                        faultContext.setProperty(HTTPConstants.MC_HTTP_SERVLETRESPONSE,\n-                                mercuryMessageContext.getMessageContext().getProperty(\n-                                        HTTPConstants.MC_HTTP_SERVLETRESPONSE));\n-                        AxisFault axisFault = new AxisFault(e.getMessage(), faultContext);\n-                        axisFault.setDetail(e.getDetail());\n-                        axisFault.setFaultCode(e.getFaultCode());\n-                        axisFault.setFaultAction(e.getFaultAction());\n-                        axisFault.setFaultType(e.getFaultType());\n-                        throw axisFault;\n-                    } else {\n-                        //TODO: what to do with these exceptions??\n-                        log.error(\"Non application type fault occurs when sending the message to application \", e);\n-                    }\n-                } finally {\n-                    // duplex mode threads should wait until method invokations is over.\n-                    if (mercuryMessageContext.getMessageContext().isServerSide()) {\n-                        if (!isAnonymous || mercuryMessageContext.getMessageContext().getAxisOperation()\n-                                .getMessageExchangePattern().equals(WSDL2Constants.MEP_URI_IN_ONLY)) {\n-                            synchronized (mercuryMessageContext) {\n-                                mercuryMessageContext.notify();\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n+        BufferReceivedNumberDto bufferReceivedNumberDto = new BufferReceivedNumberDto();\n+        bufferReceivedNumberDto.setNumber(messageNumber);\n+        bufferReceivedNumberDto.setInternalBufferID(this.persistanceDto.getId());\n+\n+        RMDMessageDto rmdMessageDto = new RMDMessageDto();\n+        rmdMessageDto.setMessageNumber(messageNumber);\n+        rmdMessageDto.setSoapEnvelope(mercuryMessageContext.getMessageContext().getEnvelope().toString());\n+        rmdMessageDto.setSend(false);\n+        rmdMessageDto.setInternalBufferID(this.persistanceDto.getId());\n+        rmdMessageDto.setOperationName(\n+          mercuryMessageContext.getMessageContext().getAxisOperation().getName());\n+        rmdMessageDto.setAction(mercuryMessageContext.getMessageContext().getOptions().getAction());\n+        rmdMessageDto.setTo(mercuryMessageContext.getMessageContext().getTo().getAddress());\n+        rmdMessageDto.setReplyTo(mercuryMessageContext.getMessageContext().getReplyTo().getAddress());\n+        rmdMessageDto.setMessageID(mercuryMessageContext.getMessageContext().getMessageID());\n+\n+        // update the persistence storage\n+        try {\n+          persistenceManager.updateMessageDetails(rmdSequenceDto,\n+            this.persistanceDto,\n+            sequenceReceivedNumberDto,\n+            bufferReceivedNumberDto,\n+            rmdMessageDto);\n+          //store the persistence dto for future updates\n+          mercuryMessageContext.setRmdPersistanceDto(rmdMessageDto);\n+        } catch (PersistenceException e) {\n+          e.printStackTrace();\n+          this.state = currentState;\n+          this.persistanceDto.setState(currentState);\n+          log.error(\"Can not update the persistence manager for message\" +\n+            \" with message number ==> \" + messageNumber, e);\n+          throw new PersistenceException(\"Can not update the persistence manager for message\" +\n+            \" with message number ==> \" + messageNumber, e);\n         }\n-    }\n-\n-    private MessageContext getNewMessageContextForLastMessage(\n-            MessageContext inMessageContext, String sessionID)\n-            throws AxisFault {\n-        MessageContext messageContext = new MessageContext();\n-        messageContext.setServiceContext(inMessageContext.getServiceContext());\n \n-        String soapNamespace = inMessageContext.getEnvelope().getNamespace().getNamespaceURI();\n-        SOAPFactory soapFactory = null;\n-        if (soapNamespace.equals(SOAP12Constants.SOAP_ENVELOPE_NAMESPACE_URI)){\n-            soapFactory = OMAbstractFactory.getSOAP12Factory();\n-        } else {\n-            soapFactory = OMAbstractFactory.getSOAP11Factory();\n+      }\n+      // exactly one delivary. duplicate messages are avoid\n+      this.messageBuffer.put(new Long(messageNumber), mercuryMessageContext);\n+      this.receivedMessageNumbers.add(new Long(messageNumber));\n+    }\n+  }\n+\n+  public synchronized void lastMessageReceived(\n+    long messageNumber,\n+    MercuryMessageContext mercuryMessageContext,\n+    RMDSequenceDto rmdSequenceDto) throws PersistenceException {\n+    this.lastAccessTime = System.currentTimeMillis();\n+\n+    if (!this.receivedMessageNumbers.contains(new Long(messageNumber))) {\n+      int currentState = this.state;\n+      //change the state\n+      switch (state) {\n+      case STATE_000: {\n+        state = STATE_110;\n+        if (this.persistanceDto != null) {\n+          this.persistanceDto.setState(state);\n         }\n-\n-        messageContext.getOptions().setSoapVersionURI(soapNamespace);\n-        messageContext.setEnvelope(soapFactory.getDefaultEnvelope());\n-        messageContext.setMessageID(UUIDGenerator.getUUID());\n-\n-        inMessageContext.getOptions().setFrom(null);\n-        messageContext.setOptions(inMessageContext.getOptions());\n-        messageContext.setServerSide(inMessageContext.isServerSide());\n-\n-        // set some security related properties\n-        // TODO: read these from the module xml file\n-        messageContext.setProperty(\"RECV_RESULTS\", inMessageContext.getProperty(\"RECV_RESULTS\"));\n-\n-        messageContext.getOptions().setTo(this.acksTo);\n-        if (!this.isAnonymous) {\n-            messageContext.setTransportOut(inMessageContext.getTransportOut());\n-        } else {\n-            // i.e we have to send the message using the backchanel of the incomming message\n-            messageContext.setProperty(Constants.Configuration.MESSAGE_TYPE,\n-                              inMessageContext.getProperty(Constants.Configuration.MESSAGE_TYPE));\n-            messageContext.setTransportOut(inMessageContext.getTransportOut());\n-            messageContext.setProperty(MessageContext.TRANSPORT_OUT,\n-                    inMessageContext.getProperty(MessageContext.TRANSPORT_OUT));\n-            messageContext.setProperty(Constants.OUT_TRANSPORT_INFO,\n-                    inMessageContext.getProperty(Constants.OUT_TRANSPORT_INFO));\n-            // this is very important in writting the message using the same channel\n-            // once response input stream is written it updates this property\n-            messageContext.setProperty(RequestResponseTransport.TRANSPORT_CONTROL,\n-                    inMessageContext.getProperty(RequestResponseTransport.TRANSPORT_CONTROL));\n-            messageContext.setProperty(HTTPConstants.HTTP_HEADERS,\n-                    inMessageContext.getProperty(HTTPConstants.HTTP_HEADERS));\n+        break;\n+      }\n+      case STATE_010: {\n+        state = STATE_110;\n+        if (this.persistanceDto != null) {\n+          this.persistanceDto.setState(state);\n         }\n-        return messageContext;\n-\n-    }\n-\n-    public synchronized void terminateMessageReceived(RMDSequenceDto rmdSequenceDto) throws PersistenceException {\n-        // terminate mesage has received\n-        // update the state machine accordingly\n-        this.lastAccessTime = System.currentTimeMillis();\n-        int currentState = this.state;\n-        switch (state) {\n-            case STATE_000 : {\n-                state = STATE_COMPLETE;\n-                if (this.persistanceDto != null){\n-                    this.persistanceDto.setState(state);\n-                }\n-                break;\n-            }\n-            case STATE_010 : {\n-                state = STATE_011;\n-                if (this.persistanceDto != null) {\n-                    this.persistanceDto.setState(state);\n-                }\n-                break;\n-            }\n-            case STATE_011 : {\n-                // terminate has already received\n-                break;\n-            }\n-            case STATE_111 : {\n-                // terminate has already received\n-                break;\n-            }\n-            case STATE_110 : {\n-                state = STATE_111;\n-                if (this.persistanceDto != null) {\n-                    this.persistanceDto.setState(state);\n-                }\n-                break;\n-            }\n-            case STATE_COMPLETE : {\n-                break;\n-            }\n+        break;\n+      }\n+      case STATE_011: {\n+        // application message can not be received in this stage\n+        break;\n+      }\n+      case STATE_111: {\n+        // application message can not be received in this stage\n+        break;\n+      }\n+      case STATE_110: {\n+        // application message can not be received in this stage\n+        break;\n+      }\n+      case STATE_COMPLETE: {\n+        break;\n+      }\n+      }\n+\n+      if (this.persistenceManager != null) {\n+        // we have to udate the persistence storage\n+        SequenceReceivedNumberDto sequenceReceivedNumberDto = new SequenceReceivedNumberDto();\n+        sequenceReceivedNumberDto.setNumber(messageNumber);\n+        sequenceReceivedNumberDto.setRmdSequenceID(rmdSequenceDto.getId());\n+        if (mercuryMessageContext.getMessageContext().getRelatesTo() != null) {\n+          sequenceReceivedNumberDto.setRelatesToMessageID(\n+            mercuryMessageContext.getMessageContext().getRelatesTo().getValue());\n         }\n \n-        if (this.persistenceManager != null){\n-            try {\n-                persistenceManager.update(this.persistanceDto,rmdSequenceDto);\n-            } catch (PersistenceException e) {\n-                this.state = currentState;\n-                this.persistanceDto.setState(currentState);\n-                log.error(\"Can not update the buffer sate\", e);\n-                throw new PersistenceException(\"Can not update the buffer sate\", e);\n-            }\n+        BufferReceivedNumberDto bufferReceivedNumberDto = new BufferReceivedNumberDto();\n+        bufferReceivedNumberDto.setNumber(messageNumber);\n+        bufferReceivedNumberDto.setInternalBufferID(this.persistanceDto.getId());\n+\n+        RMDMessageDto rmdMessageDto = new RMDMessageDto();\n+        rmdMessageDto.setMessageNumber(messageNumber);\n+        rmdMessageDto.setSoapEnvelope(\n+          mercuryMessageContext.getMessageContext().getEnvelope().toString());\n+        rmdMessageDto.setSend(false);\n+        rmdMessageDto.setInternalBufferID(this.persistanceDto.getId());\n+        rmdMessageDto.setOperationName(\n+          mercuryMessageContext.getMessageContext().getAxisOperation().getName());\n+        rmdMessageDto.setAction(mercuryMessageContext.getMessageContext().getOptions().getAction());\n+        rmdMessageDto.setTo(mercuryMessageContext.getMessageContext().getTo().getAddress());\n+        rmdMessageDto.setReplyTo(mercuryMessageContext.getMessageContext().getReplyTo().getAddress());\n+        rmdMessageDto.setMessageID(mercuryMessageContext.getMessageContext().getMessageID());\n+\n+        this.persistanceDto.setLastMessage(messageNumber);\n+\n+        // update the persistence storage\n+        try {\n+          persistenceManager.updateMessageDetails(rmdSequenceDto,\n+            this.persistanceDto,\n+            sequenceReceivedNumberDto,\n+            bufferReceivedNumberDto,\n+            rmdMessageDto);\n+          //store the persistence dto for future updates\n+          mercuryMessageContext.setRmdPersistanceDto(rmdMessageDto);\n+        } catch (PersistenceException e) {\n+          this.state = currentState;\n+          this.persistanceDto.setState(currentState);\n+          // unset the last message number since it shold not have set\n+          // if we don't have received the last message number.\n+          this.persistanceDto.setLastMessage(0);\n+          log.error(\"Can not update the persistence manager for message\" +\n+            \" with message number ==> \" + messageNumber, e);\n+          throw new PersistenceException(\"Can not update the persistence manager for message\" +\n+            \" with message number ==> \" + messageNumber, e);\n         }\n-    }\n-\n-    /**\n-     * saves both RMD Sequence and Invoker buffer objects at once.\n-     * @param rmdSequenceDto\n-     * @throws PersistenceException\n-     */\n-    public void save(RMDSequenceDto rmdSequenceDto,\n-                     Axis2InfoDto axis2InfoDto)\n-            throws PersistenceException {\n-        this.persistanceDto = new InvokerBufferDto();\n-        this.persistanceDto.setState(this.state);\n-        this.persistanceDto.setLastMessage(this.lastMessageNumber);\n-        this.persistanceDto.setLastMessageToApplication(this.lastMessageSendToApplication);\n-        this.persistenceManager.save(this.persistanceDto,rmdSequenceDto, axis2InfoDto);\n-\n-    }\n-\n-    public void loadInvokerBufferDetails(MessageContext messageContext) throws PersistenceException, AxisFault {\n-        // load the BufferReceivedMessageNumbers\n-        List bufferReceivedNumbers =\n-                this.persistenceManager.getBufferReceivedNumbersWithInvokerBufferID(this.persistanceDto.getId());\n-        BufferReceivedNumberDto bufferReceivedNumberDto = null;\n-        for (Iterator iter = bufferReceivedNumbers.iterator();iter.hasNext();){\n-            bufferReceivedNumberDto = (BufferReceivedNumberDto) iter.next();\n-            this.receivedMessageNumbers.add(new Long(bufferReceivedNumberDto.getNumber()));\n+      }\n+\n+      this.lastMessageNumber = messageNumber;\n+      this.messageBuffer.put(new Long(messageNumber), mercuryMessageContext);\n+      this.receivedMessageNumbers.add(new Long(messageNumber));\n+\n+    }\n+  }\n+\n+  public boolean isMessagesCompleted() {\n+    // this means me must sure that we have received all the messages.\n+    return (lastMessageNumber != 0) && (receivedMessageNumbers.size() == lastMessageNumber);\n+  }\n+\n+  public synchronized void doActions() throws AxisFault {\n+    // first send what ever possible messages to the application\n+    while (this.messageBuffer.keySet().contains(new Long(lastMessageSendToApplication + 1))) {\n+      // if we have the next number in the buffer that must be send to the application\n+      lastMessageSendToApplication++;\n+      log.debug(\"Sending application message \" + lastMessageSendToApplication + \" to application\");\n+      MercuryMessageContext mercuryMessageContext =\n+        (MercuryMessageContext) this.messageBuffer.remove(new Long(lastMessageSendToApplication));\n+      //here we need to update the state per message since persistence storage\n+      // updation should happen atomically\n+      // update the state of this object\n+      int currentState = this.state;\n+      switch (state) {\n+      case STATE_000: {\n+        break;\n+      }\n+      case STATE_010: {\n+        if (this.messageBuffer.size() == 0) {\n+          state = STATE_000;\n+          if (this.persistanceDto != null) {\n+            this.persistanceDto.setState(state);\n+          }\n         }\n-\n-        // load the messages\n-        List bufferMessages = persistenceManager.getRMDMessagesWithInvokerBufferID(this.persistanceDto.getId());\n-        RMDMessageDto rmdMessageDto = null;\n-        for (Iterator iter = bufferMessages.iterator();iter.hasNext();){\n-            rmdMessageDto = (RMDMessageDto) iter.next();\n-\n-            // creating a new message context\n-            MessageContext newMessageContext = new MessageContext();\n-\n-            newMessageContext.setCurrentHandlerIndex(messageContext.getCurrentHandlerIndex());\n-            newMessageContext.setCurrentPhaseIndex(messageContext.getCurrentPhaseIndex());\n-            newMessageContext.setExecutionChain(messageContext.getExecutionChain());\n-\n-            newMessageContext.setServiceContext(messageContext.getServiceContext());\n-            newMessageContext.setMessageID(rmdMessageDto.getMessageID());\n-            newMessageContext.setTransportIn(messageContext.getTransportIn());\n-            newMessageContext.setTransportOut(messageContext.getTransportOut());\n-\n-            newMessageContext.setTo(messageContext.getTo());\n-            newMessageContext.setReplyTo(messageContext.getReplyTo());\n-\n-            newMessageContext.setOptions(new Options());\n-            newMessageContext.getOptions().setTo(messageContext.getTo());\n-            newMessageContext.getOptions().setUseSeparateListener(messageContext.getOptions().isUseSeparateListener());\n-            newMessageContext.getOptions().setAction(rmdMessageDto.getAction());\n-            newMessageContext.setServerSide(messageContext.isServerSide());\n-\n-\n-            AxisOperation inOutOperation = messageContext.getAxisOperation();\n-            OperationContext operationContext =\n-                    messageContext.getServiceContext().createOperationContext(inOutOperation);\n-            inOutOperation.registerOperationContext(newMessageContext, operationContext);\n-            newMessageContext.setAxisMessage(inOutOperation.getMessage(WSDLConstants.MESSAGE_LABEL_IN_VALUE));\n-\n-            RMApplicationMessage rmApplicationMessage =\n-                    new RMApplicationMessage(getSoapEnvelope(rmdMessageDto.getSoapEnvelope()));\n-            Sequence sequence = new Sequence();\n-            rmApplicationMessage.setSequence(sequence);\n-            sequence.setMessageNumber(rmdMessageDto.getMessageNumber());\n-            rmApplicationMessage.setSequenceHeaderAdded(true);\n-            try {\n-                newMessageContext.setEnvelope(rmApplicationMessage.toSOAPEnvelope());\n-            } catch (RMMessageBuildingException e) {\n-                log.error(\"Can not build the soap envelope\", e);\n-                throw new PersistenceException(\"Can not build the soap envelope\", e);\n-            }\n-\n-            MercuryMessageContext mercuryMessageContext =\n-                    new MercuryMessageContext(rmApplicationMessage, newMessageContext);\n-            mercuryMessageContext.setRmdPersistanceDto(rmdMessageDto);\n-            this.messageBuffer.put(new Long(rmdMessageDto.getMessageNumber()), mercuryMessageContext);\n+        break;\n+      }\n+      case STATE_011: {\n+        if (this.messageBuffer.size() == 0) {\n+          state = STATE_COMPLETE;\n+          if (this.persistanceDto != null) {\n+            this.persistanceDto.setState(state);\n+          }\n         }\n-\n-    }\n-\n-    /**\n-     * this method is used when starting the sequences directly from the persistance storage.\n-     *\n-     * @throws PersistenceException\n-     * @throws AxisFault\n-     */\n-\n-    public void loadInvokerBufferDetails(Axis2InfoDto axis2InfoDto,\n-                                         ConfigurationContext configurationContext,\n-                                         ServiceContext serviceContext) throws PersistenceException, AxisFault {\n-        // load the BufferReceivedMessageNumbers\n-        List bufferReceivedNumbers =\n-                this.persistenceManager.getBufferReceivedNumbersWithInvokerBufferID(this.persistanceDto.getId());\n-        BufferReceivedNumberDto bufferReceivedNumberDto = null;\n-        for (Iterator iter = bufferReceivedNumbers.iterator(); iter.hasNext();) {\n-            bufferReceivedNumberDto = (BufferReceivedNumberDto) iter.next();\n-            this.receivedMessageNumbers.add(new Long(bufferReceivedNumberDto.getNumber()));\n+        break;\n+      }\n+      case STATE_111: {\n+        if (this.messageBuffer.size() == 0) {\n+          state = STATE_COMPLETE;\n+          if (this.persistanceDto != null) {\n+            this.persistanceDto.setState(state);\n+          }\n         }\n-\n-        AxisService axisServce\n-                = configurationContext.getAxisConfiguration().getService(axis2InfoDto.getServiceName());\n-\n-        // load the messages\n-        List bufferMessages = persistenceManager.getRMDMessagesWithInvokerBufferID(this.persistanceDto.getId());\n-        RMDMessageDto rmdMessageDto = null;\n-        for (Iterator iter = bufferMessages.iterator(); iter.hasNext();) {\n-            rmdMessageDto = (RMDMessageDto) iter.next();\n-\n-            // creating a new message context\n-            MessageContext newMessageContext = new MessageContext();\n-            AxisOperation axisOperation = axisServce.getOperation(rmdMessageDto.getOperationName());\n-\n-            newMessageContext.setCurrentHandlerIndex(axis2InfoDto.getCurrentHanlderIndex());\n-            newMessageContext.setCurrentPhaseIndex(axis2InfoDto.getCurrentPhaseIndex());\n-            newMessageContext.setExecutionChain(axisOperation.getRemainingPhasesInFlow());\n-\n-            newMessageContext.setServiceContext(serviceContext);\n-            newMessageContext.setMessageID(rmdMessageDto.getMessageID());\n-\n-\n-            newMessageContext.setTo(new EndpointReference(rmdMessageDto.getTo()));\n-            newMessageContext.setReplyTo(new EndpointReference(rmdMessageDto.getReplyTo()));\n-\n-\n-            newMessageContext.setOptions(new Options());\n-            newMessageContext.getOptions().setTo(new EndpointReference(rmdMessageDto.getTo()));\n-            newMessageContext.getOptions().setAction(rmdMessageDto.getAction());\n-            newMessageContext.setServerSide(axis2InfoDto.isServerSide());\n-\n-\n-\n-            OperationContext operationContext =\n-                    serviceContext.createOperationContext(axisOperation);\n-            axisOperation.registerOperationContext(newMessageContext, operationContext);\n-            newMessageContext.setAxisMessage(axisOperation.getMessage(WSDLConstants.MESSAGE_LABEL_IN_VALUE));\n-\n-            RMApplicationMessage rmApplicationMessage =\n-                    new RMApplicationMessage(getSoapEnvelope(rmdMessageDto.getSoapEnvelope()));\n-            Sequence sequence = new Sequence();\n-            rmApplicationMessage.setSequence(sequence);\n-            sequence.setMessageNumber(rmdMessageDto.getMessageNumber());\n-            rmApplicationMessage.setSequenceHeaderAdded(true);\n-            try {\n-                newMessageContext.setEnvelope(rmApplicationMessage.toSOAPEnvelope());\n-            } catch (RMMessageBuildingException e) {\n-                log.error(\"Can not build the soap envelope\", e);\n-                throw new PersistenceException(\"Can not build the soap envelope\", e);\n-            }\n-\n-            MercuryMessageContext mercuryMessageContext =\n-                    new MercuryMessageContext(rmApplicationMessage, newMessageContext);\n-            mercuryMessageContext.setRmdPersistanceDto(rmdMessageDto);\n-            this.messageBuffer.put(new Long(rmdMessageDto.getMessageNumber()), mercuryMessageContext);\n+        break;\n+      }\n+      case STATE_110: {\n+        if (this.messageBuffer.size() == 0) {\n+          state = STATE_COMPLETE;\n+          if (this.persistanceDto != null) {\n+            this.persistanceDto.setState(state);\n+          }\n         }\n-\n-    }\n-\n-    private SOAPEnvelope getSoapEnvelope(String soapEnvelpe)\n-            throws PersistenceException {\n+        break;\n+      }\n+      case STATE_COMPLETE: {\n+        break;\n+      }\n+      }\n+\n+      //set this message as send\n+      if (this.persistenceManager != null) {\n+        // update the rmd message\n         try {\n-            XMLStreamReader xmlReader =\n-                    StAXUtils.createXMLStreamReader(new ByteArrayInputStream(soapEnvelpe.getBytes()));\n-            StAXBuilder builder = new StAXSOAPModelBuilder(xmlReader);\n-            SOAPEnvelope soapEnvelope = (SOAPEnvelope) builder.getDocumentElement();\n-            soapEnvelope.build();\n-            String soapNamespace = soapEnvelope.getNamespace().getNamespaceURI();\n-            if (soapEnvelope.getHeader() == null){\n-                SOAPFactory soapFactory = null;\n-                if (soapNamespace.equals(SOAP12Constants.SOAP_ENVELOPE_NAMESPACE_URI)) {\n-                    soapFactory = OMAbstractFactory.getSOAP12Factory();\n-                } else {\n-                    soapFactory = OMAbstractFactory.getSOAP11Factory();\n-                }\n-                soapFactory.createSOAPHeader(soapEnvelope);\n-            }\n-            return soapEnvelope;\n-        } catch (XMLStreamException e) {\n-            log.error(\"Problem with the stored message\", e);\n-            throw new PersistenceException(\"Problem with the stored message\", e);\n+          this.persistanceDto.setLastMessageToApplication(lastMessageSendToApplication);\n+          mercuryMessageContext.getRmdPersistanceDto().setSend(true);\n+          this.persistenceManager.update(\n+            mercuryMessageContext.getRmdPersistanceDto(), this.persistanceDto);\n+        } catch (PersistenceException e) {\n+          this.state = currentState;\n+          this.persistanceDto.setState(state);\n+          this.messageBuffer.put(new Long(lastMessageSendToApplication), mercuryMessageContext);\n+          mercuryMessageContext.getRmdPersistanceDto().setSend(false);\n+          lastMessageSendToApplication--;\n+          log.error(\"Problem when updating the data base to send the message to application\", e);\n+          break;\n         }\n-    }\n+      }\n+\n+      // AxisEngine.resumeReceive method invokes the last handler again\n+      // to avoid this problem we set the this message context as and mercury controll message.\n+      mercuryMessageContext.getMessageContext().setProperty(\n+        MercuryConstants.PROCESS_RM_CONTROL_MESSAGE, Constants.VALUE_TRUE);\n+      // send the message to upper later.\n+      if (isAnonymous && !mercuryMessageContext.getMessageContext().isServerSide()) {\n+        // if this is an annonymous client side response. then we can not initiate\n+        // threads for this. the only thing we have to do is to notify the listning thread\n+        this.notifyAll();\n+      } else {\n+        // we can not start seperate threads here.\n+        // since we have to gurantee the inorder delivary\n+        try {\n+          MessageContext applicationMsgContext = mercuryMessageContext.getMessageContext();\n+          // dummy last messages should not send to the application.\n+          if (!applicationMsgContext.getOptions().getAction().equals(\n+            MercuryConstants.LAST_MESSAGE_ACTION)) {\n+            AxisEngine.resumeReceive(mercuryMessageContext.getMessageContext());\n+          } else {\n+            // mep can be inout only at the server side\n+            // we send this to in only sequences as well but those will stop at the\n+            // mercury out handler level.\n+            String sessionID = mercuryMessageContext.getRmApplicationMessage().getSequence().getSequenceID();\n+            MessageContext outMessageContext =\n+              getNewMessageContextForLastMessage(applicationMsgContext, sessionID);\n+            outMessageContext.setProperty(AddressingConstants.WS_ADDRESSING_VERSION,\n+              applicationMsgContext.getProperty(AddressingConstants.WS_ADDRESSING_VERSION));\n+            outMessageContext.getOptions().setAction(MercuryConstants.LAST_MESSAGE_ACTION);\n+            outMessageContext.setProperty(MercuryClientConstants.INTERNAL_KEY,\n+              applicationMsgContext.getProperty(MercuryConstants.SESSION_ID));\n+            outMessageContext.setProperty(MercuryClientConstants.LAST_MESSAGE, Constants.VALUE_TRUE);\n+\n+\n+            AxisOperation axisOperation = applicationMsgContext.getAxisService().getOperationByAction(\n+              MercuryConstants.LAST_MESSAGE_ACTION);\n+            outMessageContext.setAxisMessage(axisOperation.getMessage(WSDLConstants.MESSAGE_LABEL_IN_VALUE));\n+\n+            OperationContext operationContext =\n+              applicationMsgContext.getServiceContext().createOperationContext(axisOperation);\n+            axisOperation.registerOperationContext(outMessageContext, operationContext);\n+            AxisEngine.send(outMessageContext);\n+          }\n+\n+        } catch (AxisFault e) {\n+          // throw it back with the new message context.\n+          if (e.getFaultType() == Constants.APPLICATION_FAULT) {\n+            MessageContext faultContext =\n+              MessageContextBuilder.createFaultMessageContext(\n+                mercuryMessageContext.getMessageContext(), e);\n+            // set the Axis Message as the out message if a fault message is not\n+            // there\n+            //TODO: set the fault message it is available.\n+            AxisOperation axisOperation = mercuryMessageContext.getMessageContext().getAxisOperation();\n+            if (axisOperation.getMessage(WSDLConstants.MESSAGE_LABEL_OUT_VALUE) != null) {\n+              faultContext.setAxisMessage(axisOperation.getMessage(WSDLConstants.MESSAGE_LABEL_OUT_VALUE));\n+            } else {\n+              faultContext.setAxisMessage(axisOperation.getMessage(WSDLConstants.MESSAGE_LABEL_IN_VALUE));\n+            }\n \n-    /**\n-     * this method is used to wait the client side thread in annonymous invocations\n-     * until invoker message passes it.\n-     */\n-\n-    public synchronized void waitUntilMessageInvoke(long messageNumber) {\n-        // this is an annonymous client response. this thread should have started\n-        // at the axis2 kernal level. but we can not let this thread proceed\n-        // all the sequence messages comes. here we wait this thread in\n-        // Mercury message context. at the invoke buffer level this thread will\n-        // notify when the time comes.\n-        // here we have to wait only if the invoker buffer has not\n-        // decided to release this message\n-\n-        if (messageNumber > lastMessageSendToApplication) {\n-            try {\n-                // call continueWork to wake up InvokerWorker\n-                // this is an performance improvement to start the\n-                // invoker worker immediately\n-                // otherwise it would take a SLEEP time to wake up the thread\n-\n-                // this thread has already has acquired the lock for Invoker buffer.\n-                // So wake up actually starts work after wait calls in next line.\n-                continueWork();\n-\n-                this.wait();\n-                waitUntilMessageInvoke(messageNumber);\n-            } catch (InterruptedException e) {\n+            faultContext.setProperty(\"RECV_RESULTS\",\n+              mercuryMessageContext.getMessageContext().getProperty(\"RECV_RESULTS\"));\n+\n+            faultContext.setProperty(Constants.APPLICATION_FAULT_STRING, Constants.VALUE_TRUE);\n+            // set the servlet transport property\n+            faultContext.setProperty(HTTPConstants.MC_HTTP_SERVLETRESPONSE,\n+              mercuryMessageContext.getMessageContext().getProperty(\n+                HTTPConstants.MC_HTTP_SERVLETRESPONSE));\n+            AxisFault axisFault = new AxisFault(e.getMessage(), faultContext);\n+            axisFault.setDetail(e.getDetail());\n+            axisFault.setFaultCode(e.getFaultCode());\n+            axisFault.setFaultAction(e.getFaultAction());\n+            axisFault.setFaultType(e.getFaultType());\n+            throw axisFault;\n+          } else {\n+            //TODO: what to do with these exceptions??\n+            log.error(\"Non application type fault occurs when sending the message to application \", e);\n+          }\n+        } finally {\n+          // duplex mode threads should wait until method invokations is over.\n+          if (mercuryMessageContext.getMessageContext().isServerSide()) {\n+            if (!isAnonymous || mercuryMessageContext.getMessageContext().getAxisOperation()\n+              .getMessageExchangePattern().equals(WSDL2Constants.MEP_URI_IN_ONLY)) {\n+              synchronized (mercuryMessageContext) {\n+                mercuryMessageContext.notify();\n+              }\n             }\n+          }\n         }\n-    }\n-\n-    /**\n-     * this method is called in an unexpected terminateion\n-     */\n-    public synchronized void terminate(){\n-        this.state = STATE_COMPLETE;\n-    }\n-\n-    public void continueWork() {\n-        log.debug(\"continueWork\");\n-        if (invokerWorker != null) {\n-            invokerWorker.wakeUp();\n+      }\n+    }\n+  }\n+\n+  private MessageContext getNewMessageContextForLastMessage(\n+    MessageContext inMessageContext, String sessionID)\n+    throws AxisFault {\n+    MessageContext messageContext = new MessageContext();\n+    messageContext.setServiceContext(inMessageContext.getServiceContext());\n+\n+    String soapNamespace = inMessageContext.getEnvelope().getNamespace().getNamespaceURI();\n+    SOAPFactory soapFactory = null;\n+    if (soapNamespace.equals(SOAP12Constants.SOAP_ENVELOPE_NAMESPACE_URI)) {\n+      soapFactory = OMAbstractFactory.getSOAP12Factory();\n+    } else {\n+      soapFactory = OMAbstractFactory.getSOAP11Factory();\n+    }\n+\n+    messageContext.getOptions().setSoapVersionURI(soapNamespace);\n+    messageContext.setEnvelope(soapFactory.getDefaultEnvelope());\n+    messageContext.setMessageID(UUIDGenerator.getUUID());\n+\n+    inMessageContext.getOptions().setFrom(null);\n+    messageContext.setOptions(inMessageContext.getOptions());\n+    messageContext.setServerSide(inMessageContext.isServerSide());\n+\n+    // set some security related properties\n+    // TODO: read these from the module xml file\n+    messageContext.setProperty(\"RECV_RESULTS\", inMessageContext.getProperty(\"RECV_RESULTS\"));\n+\n+    messageContext.getOptions().setTo(this.acksTo);\n+    if (!this.isAnonymous) {\n+      messageContext.setTransportOut(inMessageContext.getTransportOut());\n+    } else {\n+      // i.e we have to send the message using the backchanel of the incomming message\n+      messageContext.setProperty(Constants.Configuration.MESSAGE_TYPE,\n+        inMessageContext.getProperty(Constants.Configuration.MESSAGE_TYPE));\n+      messageContext.setTransportOut(inMessageContext.getTransportOut());\n+      messageContext.setProperty(MessageContext.TRANSPORT_OUT,\n+        inMessageContext.getProperty(MessageContext.TRANSPORT_OUT));\n+      messageContext.setProperty(Constants.OUT_TRANSPORT_INFO,\n+        inMessageContext.getProperty(Constants.OUT_TRANSPORT_INFO));\n+      // this is very important in writting the message using the same channel\n+      // once response input stream is written it updates this property\n+      messageContext.setProperty(RequestResponseTransport.TRANSPORT_CONTROL,\n+        inMessageContext.getProperty(RequestResponseTransport.TRANSPORT_CONTROL));\n+      messageContext.setProperty(HTTPConstants.HTTP_HEADERS,\n+        inMessageContext.getProperty(HTTPConstants.HTTP_HEADERS));\n+    }\n+    return messageContext;\n+\n+  }\n+\n+  public synchronized void terminateMessageReceived(RMDSequenceDto rmdSequenceDto) throws PersistenceException {\n+    // terminate mesage has received\n+    // update the state machine accordingly\n+    this.lastAccessTime = System.currentTimeMillis();\n+    int currentState = this.state;\n+    switch (state) {\n+    case STATE_000: {\n+      state = STATE_COMPLETE;\n+      if (this.persistanceDto != null) {\n+        this.persistanceDto.setState(state);\n+      }\n+      break;\n+    }\n+    case STATE_010: {\n+      state = STATE_011;\n+      if (this.persistanceDto != null) {\n+        this.persistanceDto.setState(state);\n+      }\n+      break;\n+    }\n+    case STATE_011: {\n+      // terminate has already received\n+      break;\n+    }\n+    case STATE_111: {\n+      // terminate has already received\n+      break;\n+    }\n+    case STATE_110: {\n+      state = STATE_111;\n+      if (this.persistanceDto != null) {\n+        this.persistanceDto.setState(state);\n+      }\n+      break;\n+    }\n+    case STATE_COMPLETE: {\n+      break;\n+    }\n+    }\n+\n+    if (this.persistenceManager != null) {\n+      try {\n+        persistenceManager.update(this.persistanceDto, rmdSequenceDto);\n+      } catch (PersistenceException e) {\n+        this.state = currentState;\n+        this.persistanceDto.setState(currentState);\n+        log.error(\"Can not update the buffer sate\", e);\n+        throw new PersistenceException(\"Can not update the buffer sate\", e);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * saves both RMD Sequence and Invoker buffer objects at once.\n+   *\n+   * @param rmdSequenceDto\n+   * @throws PersistenceException\n+   */\n+  public void save(RMDSequenceDto rmdSequenceDto,\n+                   Axis2InfoDto axis2InfoDto)\n+    throws PersistenceException {\n+    this.persistanceDto = new InvokerBufferDto();\n+    this.persistanceDto.setState(this.state);\n+    this.persistanceDto.setLastMessage(this.lastMessageNumber);\n+    this.persistanceDto.setLastMessageToApplication(this.lastMessageSendToApplication);\n+    this.persistenceManager.save(this.persistanceDto, rmdSequenceDto, axis2InfoDto);\n+\n+  }\n+\n+  public void loadInvokerBufferDetails(MessageContext messageContext) throws PersistenceException, AxisFault {\n+    // load the BufferReceivedMessageNumbers\n+    List bufferReceivedNumbers =\n+      this.persistenceManager.getBufferReceivedNumbersWithInvokerBufferID(this.persistanceDto.getId());\n+    BufferReceivedNumberDto bufferReceivedNumberDto = null;\n+    for (Iterator iter = bufferReceivedNumbers.iterator(); iter.hasNext(); ) {\n+      bufferReceivedNumberDto = (BufferReceivedNumberDto) iter.next();\n+      this.receivedMessageNumbers.add(new Long(bufferReceivedNumberDto.getNumber()));\n+    }\n+\n+    // load the messages\n+    List bufferMessages = persistenceManager.getRMDMessagesWithInvokerBufferID(this.persistanceDto.getId());\n+    RMDMessageDto rmdMessageDto = null;\n+    for (Iterator iter = bufferMessages.iterator(); iter.hasNext(); ) {\n+      rmdMessageDto = (RMDMessageDto) iter.next();\n+\n+      // creating a new message context\n+      MessageContext newMessageContext = new MessageContext();\n+\n+      newMessageContext.setCurrentHandlerIndex(messageContext.getCurrentHandlerIndex());\n+      newMessageContext.setCurrentPhaseIndex(messageContext.getCurrentPhaseIndex());\n+      newMessageContext.setExecutionChain(messageContext.getExecutionChain());\n+\n+      newMessageContext.setServiceContext(messageContext.getServiceContext());\n+      newMessageContext.setMessageID(rmdMessageDto.getMessageID());\n+      newMessageContext.setTransportIn(messageContext.getTransportIn());\n+      newMessageContext.setTransportOut(messageContext.getTransportOut());\n+\n+      newMessageContext.setTo(messageContext.getTo());\n+      newMessageContext.setReplyTo(messageContext.getReplyTo());\n+\n+      newMessageContext.setOptions(new Options());\n+      newMessageContext.getOptions().setTo(messageContext.getTo());\n+      newMessageContext.getOptions().setUseSeparateListener(messageContext.getOptions().isUseSeparateListener());\n+      newMessageContext.getOptions().setAction(rmdMessageDto.getAction());\n+      newMessageContext.setServerSide(messageContext.isServerSide());\n+\n+\n+      AxisOperation inOutOperation = messageContext.getAxisOperation();\n+      OperationContext operationContext =\n+        messageContext.getServiceContext().createOperationContext(inOutOperation);\n+      inOutOperation.registerOperationContext(newMessageContext, operationContext);\n+      newMessageContext.setAxisMessage(inOutOperation.getMessage(WSDLConstants.MESSAGE_LABEL_IN_VALUE));\n+\n+      RMApplicationMessage rmApplicationMessage =\n+        new RMApplicationMessage(getSoapEnvelope(rmdMessageDto.getSoapEnvelope()));\n+      Sequence sequence = new Sequence();\n+      rmApplicationMessage.setSequence(sequence);\n+      sequence.setMessageNumber(rmdMessageDto.getMessageNumber());\n+      rmApplicationMessage.setSequenceHeaderAdded(true);\n+      try {\n+        newMessageContext.setEnvelope(rmApplicationMessage.toSOAPEnvelope());\n+      } catch (RMMessageBuildingException e) {\n+        log.error(\"Can not build the soap envelope\", e);\n+        throw new PersistenceException(\"Can not build the soap envelope\", e);\n+      }\n+\n+      MercuryMessageContext mercuryMessageContext =\n+        new MercuryMessageContext(rmApplicationMessage, newMessageContext);\n+      mercuryMessageContext.setRmdPersistanceDto(rmdMessageDto);\n+      this.messageBuffer.put(new Long(rmdMessageDto.getMessageNumber()), mercuryMessageContext);\n+    }\n+\n+  }\n+\n+  /**\n+   * this method is used when starting the sequences directly from the persistance storage.\n+   *\n+   * @throws PersistenceException\n+   * @throws AxisFault\n+   */\n+\n+  public void loadInvokerBufferDetails(Axis2InfoDto axis2InfoDto,\n+                                       ConfigurationContext configurationContext,\n+                                       ServiceContext serviceContext) throws PersistenceException, AxisFault {\n+    // load the BufferReceivedMessageNumbers\n+    List bufferReceivedNumbers =\n+      this.persistenceManager.getBufferReceivedNumbersWithInvokerBufferID(this.persistanceDto.getId());\n+    BufferReceivedNumberDto bufferReceivedNumberDto = null;\n+    for (Iterator iter = bufferReceivedNumbers.iterator(); iter.hasNext(); ) {\n+      bufferReceivedNumberDto = (BufferReceivedNumberDto) iter.next();\n+      this.receivedMessageNumbers.add(new Long(bufferReceivedNumberDto.getNumber()));\n+    }\n+\n+    AxisService axisServce\n+      = configurationContext.getAxisConfiguration().getService(axis2InfoDto.getServiceName());\n+\n+    // load the messages\n+    List bufferMessages = persistenceManager.getRMDMessagesWithInvokerBufferID(this.persistanceDto.getId());\n+    RMDMessageDto rmdMessageDto = null;\n+    for (Iterator iter = bufferMessages.iterator(); iter.hasNext(); ) {\n+      rmdMessageDto = (RMDMessageDto) iter.next();\n+\n+      // creating a new message context\n+      MessageContext newMessageContext = new MessageContext();\n+      AxisOperation axisOperation = axisServce.getOperation(rmdMessageDto.getOperationName());\n+\n+      newMessageContext.setCurrentHandlerIndex(axis2InfoDto.getCurrentHanlderIndex());\n+      newMessageContext.setCurrentPhaseIndex(axis2InfoDto.getCurrentPhaseIndex());\n+      newMessageContext.setExecutionChain(axisOperation.getRemainingPhasesInFlow());\n+\n+      newMessageContext.setServiceContext(serviceContext);\n+      newMessageContext.setMessageID(rmdMessageDto.getMessageID());\n+\n+\n+      newMessageContext.setTo(new EndpointReference(rmdMessageDto.getTo()));\n+      newMessageContext.setReplyTo(new EndpointReference(rmdMessageDto.getReplyTo()));\n+\n+\n+      newMessageContext.setOptions(new Options());\n+      newMessageContext.getOptions().setTo(new EndpointReference(rmdMessageDto.getTo()));\n+      newMessageContext.getOptions().setAction(rmdMessageDto.getAction());\n+      newMessageContext.setServerSide(axis2InfoDto.isServerSide());\n+\n+\n+      OperationContext operationContext =\n+        serviceContext.createOperationContext(axisOperation);\n+      axisOperation.registerOperationContext(newMessageContext, operationContext);\n+      newMessageContext.setAxisMessage(axisOperation.getMessage(WSDLConstants.MESSAGE_LABEL_IN_VALUE));\n+\n+      RMApplicationMessage rmApplicationMessage =\n+        new RMApplicationMessage(getSoapEnvelope(rmdMessageDto.getSoapEnvelope()));\n+      Sequence sequence = new Sequence();\n+      rmApplicationMessage.setSequence(sequence);\n+      sequence.setMessageNumber(rmdMessageDto.getMessageNumber());\n+      rmApplicationMessage.setSequenceHeaderAdded(true);\n+      try {\n+        newMessageContext.setEnvelope(rmApplicationMessage.toSOAPEnvelope());\n+      } catch (RMMessageBuildingException e) {\n+        log.error(\"Can not build the soap envelope\", e);\n+        throw new PersistenceException(\"Can not build the soap envelope\", e);\n+      }\n+\n+      MercuryMessageContext mercuryMessageContext =\n+        new MercuryMessageContext(rmApplicationMessage, newMessageContext);\n+      mercuryMessageContext.setRmdPersistanceDto(rmdMessageDto);\n+      this.messageBuffer.put(new Long(rmdMessageDto.getMessageNumber()), mercuryMessageContext);\n+    }\n+\n+  }\n+\n+  private SOAPEnvelope getSoapEnvelope(String soapEnvelpe)\n+    throws PersistenceException {\n+    try {\n+      XMLStreamReader xmlReader =\n+        StAXUtils.createXMLStreamReader(new ByteArrayInputStream(soapEnvelpe.getBytes()));\n+      StAXBuilder builder = new StAXSOAPModelBuilder(xmlReader);\n+      SOAPEnvelope soapEnvelope = (SOAPEnvelope) builder.getDocumentElement();\n+      soapEnvelope.build();\n+      String soapNamespace = soapEnvelope.getNamespace().getNamespaceURI();\n+      if (soapEnvelope.getHeader() == null) {\n+        SOAPFactory soapFactory = null;\n+        if (soapNamespace.equals(SOAP12Constants.SOAP_ENVELOPE_NAMESPACE_URI)) {\n+          soapFactory = OMAbstractFactory.getSOAP12Factory();\n         } else {\n-            // not an error\n-            log.debug(\"NO Invoker Worker ??? \");\n+          soapFactory = OMAbstractFactory.getSOAP11Factory();\n         }\n-    }\n-\n-\n-    public synchronized int getState() {\n-        return state;\n-    }\n-\n-    public void setState(int state) {\n-        this.state = state;\n-    }\n-\n-    public Map getMessageBuffer() {\n-        return messageBuffer;\n-    }\n-\n-    public void setMessageBuffer(Map messageBuffer) {\n-        this.messageBuffer = messageBuffer;\n-    }\n+        soapFactory.createSOAPHeader(soapEnvelope);\n+      }\n+      return soapEnvelope;\n+    } catch (XMLStreamException e) {\n+      log.error(\"Problem with the stored message\", e);\n+      throw new PersistenceException(\"Problem with the stored message\", e);\n+    }\n+  }\n+\n+  /**\n+   * this method is used to wait the client side thread in annonymous invocations\n+   * until invoker message passes it.\n+   */\n+\n+  public synchronized void waitUntilMessageInvoke(long messageNumber) {\n+    // this is an annonymous client response. this thread should have started\n+    // at the axis2 kernal level. but we can not let this thread proceed\n+    // all the sequence messages comes. here we wait this thread in\n+    // Mercury message context. at the invoke buffer level this thread will\n+    // notify when the time comes.\n+    // here we have to wait only if the invoker buffer has not\n+    // decided to release this message\n+\n+    if (messageNumber > lastMessageSendToApplication) {\n+      try {\n+        // call continueWork to wake up InvokerWorker\n+        // this is an performance improvement to start the\n+        // invoker worker immediately\n+        // otherwise it would take a SLEEP time to wake up the thread\n+\n+        // this thread has already has acquired the lock for Invoker buffer.\n+        // So wake up actually starts work after wait calls in next line.\n+        continueWork();\n+\n+        this.wait();\n+        waitUntilMessageInvoke(messageNumber);\n+      } catch (InterruptedException e) {\n+      }\n+    }\n+  }\n+\n+  /**\n+   * this method is called in an unexpected terminateion\n+   */\n+  public synchronized void terminate() {\n+    this.state = STATE_COMPLETE;\n+  }\n+\n+  public void continueWork() {\n+    log.debug(\"continueWork\");\n+    if (invokerWorker != null) {\n+      invokerWorker.wakeUp();\n+    } else {\n+      // not an error\n+      log.debug(\"NO Invoker Worker ??? \");\n+    }\n+  }\n+\n+\n+  public synchronized int getState() {\n+    return state;\n+  }\n+\n+  public void setState(int state) {\n+    this.state = state;\n+  }\n+\n+  public Map getMessageBuffer() {\n+    return messageBuffer;\n+  }\n+\n+  public void setMessageBuffer(Map messageBuffer) {\n+    this.messageBuffer = messageBuffer;\n+  }\n+\n+  public synchronized long getLastAccessTime() {\n+    return lastAccessTime;\n+  }\n+\n+  public void setLastAccessTime(long lastAccessTime) {\n+    this.lastAccessTime = lastAccessTime;\n+  }\n+\n+  public PersistenceManager getPersistanceManager() {\n+    return persistenceManager;\n+  }\n+\n+  public void setPersistanceManager(PersistenceManager persistenceManager) {\n+    this.persistenceManager = persistenceManager;\n+  }\n+\n+  public long getLastMessageNumber() {\n+    return lastMessageNumber;\n+  }\n+\n+  public void setLastMessageNumber(long lastMessageNumber) {\n+    this.lastMessageNumber = lastMessageNumber;\n+  }\n+\n+  public synchronized long getLastMessageSendToApplication() {\n+    return lastMessageSendToApplication;\n+  }\n+\n+  public InvokerBufferDto getPersistanceDto() {\n+    return persistanceDto;\n+  }\n+\n+  public void setPersistanceDto(InvokerBufferDto persistanceDto) {\n+    this.persistanceDto = persistanceDto;\n+  }\n+\n+  public void setLastMessageSendToApplication(long lastMessageSendToApplication) {\n+    this.lastMessageSendToApplication = lastMessageSendToApplication;\n+  }\n+\n+  public boolean isAnonymous() {\n+    return isAnonymous;\n+  }\n+\n+  public void setAnonymous(boolean anonymous) {\n+    isAnonymous = anonymous;\n+  }\n+\n+  public EndpointReference getAcksTo() {\n+    return acksTo;\n+  }\n+\n+  public void setAcksTo(EndpointReference acksTo) {\n+    this.acksTo = acksTo;\n+  }\n+\n+  public void setInvokerWorker(InvokerWorker w) {\n+    this.invokerWorker = w;\n+  }\n+\n+  public long getTimeoutTime() {\n+    return timeoutTime;\n+  }\n \n-    public synchronized long getLastAccessTime() {\n-        return lastAccessTime;\n-    }\n-\n-    public void setLastAccessTime(long lastAccessTime) {\n-        this.lastAccessTime = lastAccessTime;\n-    }\n-\n-    public PersistenceManager getPersistanceManager() {\n-        return persistenceManager;\n-    }\n-\n-    public void setPersistanceManager(PersistenceManager persistenceManager) {\n-        this.persistenceManager = persistenceManager;\n-    }\n-\n-    public long getLastMessageNumber() {\n-        return lastMessageNumber;\n-    }\n-\n-    public void setLastMessageNumber(long lastMessageNumber) {\n-        this.lastMessageNumber = lastMessageNumber;\n-    }\n-\n-    public synchronized long getLastMessageSendToApplication() {\n-        return lastMessageSendToApplication;\n-    }\n-\n-    public InvokerBufferDto getPersistanceDto() {\n-        return persistanceDto;\n-    }\n-\n-    public void setPersistanceDto(InvokerBufferDto persistanceDto) {\n-        this.persistanceDto = persistanceDto;\n-    }\n-\n-    public void setLastMessageSendToApplication(long lastMessageSendToApplication) {\n-        this.lastMessageSendToApplication = lastMessageSendToApplication;\n-    }\n-\n-    public boolean isAnonymous() {\n-        return isAnonymous;\n-    }\n-\n-    public void setAnonymous(boolean anonymous) {\n-        isAnonymous = anonymous;\n-    }\n-\n-    public EndpointReference getAcksTo() {\n-        return acksTo;\n-    }\n-\n-    public void setAcksTo(EndpointReference acksTo) {\n-        this.acksTo = acksTo;\n-    }\n-\n-    public void setInvokerWorker(InvokerWorker w) {\n-        this.invokerWorker = w;\n-    }\n-\n-    public long getTimeoutTime() {\n-        return timeoutTime;\n-    }\n-\n-    public void setTimeoutTime(long timeoutTime) {\n-        this.timeoutTime = timeoutTime;\n-    }\n+  public void setTimeoutTime(long timeoutTime) {\n+    this.timeoutTime = timeoutTime;\n+  }\n \n }\n",
            "diff_size": 1293
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/265/InvokerBuffer.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler_random/265/InvokerBuffer.java\nindex 3a3d8f05f6d..f01999ada8c 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/265/InvokerBuffer.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler_random/265/InvokerBuffer.java\n@@ -453,7 +453,7 @@ public class InvokerBuffer {\n                         //TODO: set the fault message it is available.\n                         AxisOperation axisOperation = mercuryMessageContext.getMessageContext().getAxisOperation();\n                         if (axisOperation.getMessage(WSDLConstants.MESSAGE_LABEL_OUT_VALUE) != null){\n-                            faultContext.setAxisMessage(axisOperation.getMessage(WSDLConstants.MESSAGE_LABEL_OUT_VALUE));\n+                        faultContext.setAxisMessage(axisOperation.getMessage(WSDLConstants.MESSAGE_LABEL_OUT_VALUE));\n                         } else {\n                             faultContext.setAxisMessage(axisOperation.getMessage(WSDLConstants.MESSAGE_LABEL_IN_VALUE));\n                         }\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/265/InvokerBuffer.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler_three_grams/265/InvokerBuffer.java\nindex 3a3d8f05f6d..30875da7f2e 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/265/InvokerBuffer.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler_three_grams/265/InvokerBuffer.java\n@@ -453,8 +453,8 @@ public class InvokerBuffer {\n                         //TODO: set the fault message it is available.\n                         AxisOperation axisOperation = mercuryMessageContext.getMessageContext().getAxisOperation();\n                         if (axisOperation.getMessage(WSDLConstants.MESSAGE_LABEL_OUT_VALUE) != null){\n-                            faultContext.setAxisMessage(axisOperation.getMessage(WSDLConstants.MESSAGE_LABEL_OUT_VALUE));\n-                        } else {\n+                            faultContext.setAxisMessage(axisOperation.getMessage(WSDLConstants.MESSAGE_LABEL_OUT_VALUE))\n+                        ; } else {\n                             faultContext.setAxisMessage(axisOperation.getMessage(WSDLConstants.MESSAGE_LABEL_IN_VALUE));\n                         }\n \n",
            "diff_size": 2
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "naturalize",
        "codebuff"
    ]
}