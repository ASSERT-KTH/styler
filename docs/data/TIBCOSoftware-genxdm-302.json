{
    "project_name": "TIBCOSoftware-genxdm",
    "error_id": "302",
    "information": {
        "errors": [
            {
                "line": "30",
                "column": "1",
                "severity": "warning",
                "message": "File contains tab characters (this is the first instance).",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
            }
        ]
    },
    "source_code": "final class ValidationPrefixResolver implements PrefixResolver\n{\n\tprivate static final Iterable<String> UNARY_DEFAULT_NS_PREFIX_ITERABLE = new UnaryIterable<String>(XMLConstants.DEFAULT_NS_PREFIX);\n\tprivate static final Iterable<String> UNARY_XML_NS_PREFIX_ITERABLE = new UnaryIterable<String>(XMLConstants.XML_NS_PREFIX);\n\tprivate static final Iterable<String> UNARY_XMLNS_ATTRIBUTE_ITERABLE = new UnaryIterable<String>(XMLConstants.XMLNS_ATTRIBUTE);\n",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "31",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/302/ValidationPrefixResolver.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler/302/ValidationPrefixResolver.java\nindex 5b592617574..9b8d52260df 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/302/ValidationPrefixResolver.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler/302/ValidationPrefixResolver.java\n@@ -27,7 +27,7 @@ import org.genxdm.names.PrefixResolver;\n \n final class ValidationPrefixResolver implements PrefixResolver\n {\n-\tprivate static final Iterable<String> UNARY_DEFAULT_NS_PREFIX_ITERABLE = new UnaryIterable<String>(XMLConstants.DEFAULT_NS_PREFIX);\n+private static final Iterable<String> UNARY_DEFAULT_NS_PREFIX_ITERABLE = new UnaryIterable<String>(XMLConstants.DEFAULT_NS_PREFIX);\n \tprivate static final Iterable<String> UNARY_XML_NS_PREFIX_ITERABLE = new UnaryIterable<String>(XMLConstants.XML_NS_PREFIX);\n \tprivate static final Iterable<String> UNARY_XMLNS_ATTRIBUTE_ITERABLE = new UnaryIterable<String>(XMLConstants.XMLNS_ATTRIBUTE);\n \n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/302/ValidationPrefixResolver.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/intellij/302/ValidationPrefixResolver.java\nindex 5b592617574..1d21e13f178 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/302/ValidationPrefixResolver.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/intellij/302/ValidationPrefixResolver.java\n@@ -1,18 +1,19 @@\n /**\n  * Copyright (c) 2009-2010 TIBCO Software Inc.\n- *\n+ * <p>\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+\n package org.genxdm.processor.w3c.xs.validation.impl;\n \n import java.util.ArrayList;\n@@ -25,342 +26,295 @@ import org.genxdm.exceptions.PreCondition;\n import org.genxdm.names.NameSource;\n import org.genxdm.names.PrefixResolver;\n \n-final class ValidationPrefixResolver implements PrefixResolver\n-{\n-\tprivate static final Iterable<String> UNARY_DEFAULT_NS_PREFIX_ITERABLE = new UnaryIterable<String>(XMLConstants.DEFAULT_NS_PREFIX);\n-\tprivate static final Iterable<String> UNARY_XML_NS_PREFIX_ITERABLE = new UnaryIterable<String>(XMLConstants.XML_NS_PREFIX);\n-\tprivate static final Iterable<String> UNARY_XMLNS_ATTRIBUTE_ITERABLE = new UnaryIterable<String>(XMLConstants.XMLNS_ATTRIBUTE);\n-\n-\tValidationPrefixResolver(final NameSource nameBridge)\n-\t{\n-\t\tthis.m_prefixes = new String[8];\n-\t\tthis.m_uris = new String [8];\n-\t\treset();\n-\t}\n-\n-\t/**\n-\t * The index of the currently active context. The first context has index zero.\n-\t */\n-\tprivate int m_idxContext = -1;\n-\n-\t/**\n-\t * Parallel array of prefixes and uris and a count of the number used.\n-\t */\n-\tprivate String[] m_prefixes;\n-\tprivate String[] m_uris;\n-\tprivate int m_numMappings = 0;\n-\n-\t/**\n-\t * Index into m_prefixes or m_uris of the start of a context.\n-\t */\n-\tprivate int[] m_idxStartContext = new int[8];\n-\n-\t/**\n-\t * Reset this NamespaceSupport for object reuse.\n-\t */\n-\tpublic void reset()\n-\t{\n-\t\tm_idxContext = -1;\n-\t\tm_numMappings = 0;\n-\n-\t\tpushContext();\n-\t}\n-\n-\tpublic void pushContext()\n-\t{\n-\t\tm_idxContext++;\n-\n-\t\t// Grow the local arrays if required.\n-\t\tif (m_idxContext >= m_idxStartContext.length)\n-\t\t{\n-\t\t\tint[] s = m_idxStartContext;\n-\t\t\tm_idxStartContext = new int[m_idxStartContext.length * 2];\n-\t\t\tSystem.arraycopy(s, 0, m_idxStartContext, 0, s.length);\n-\t\t}\n-\n-\t\tm_idxStartContext[m_idxContext] = m_numMappings;\n-\t}\n-\n-\tpublic void popContext()\n-\t{\n-\t\tm_numMappings = m_idxStartContext[m_idxContext];\n-\n-\t\tm_idxContext--;\n-\t}\n-\n-\tpublic void declarePrefix(final String prefix, final String uri)\n-\t{\n-\t\t// Do not remove! This prefix check is an invariant of the API.\n-\t\tPreCondition.assertArgumentNotNull(prefix, \"prefix\");\n-\t\t// Do not remove! This uri check is an invariant of the API.\n-\t\tPreCondition.assertArgumentNotNull(uri, \"uri\");\n-\n-\t\t// Search for a mapping from the top of the array, but limited to the\n-\t\t// current context.\n-\t\tfor (int i = m_numMappings - 1; i >= m_idxStartContext[m_idxContext]; i--)\n-\t\t{\n-\t\t\tif (equals(prefix, m_prefixes[i]))\n-\t\t\t{\n-\t\t\t\tm_uris[i] = uri;\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t}\n-\n-\t\tfinal boolean isXmlNamespacePrefix = equals(XMLConstants.XML_NS_PREFIX, prefix);\n-\t\tfinal boolean isXmlNamespaceURI = (XMLConstants.XML_NS_URI == uri);\n-\n-\t\tif (isXmlNamespacePrefix && !isXmlNamespaceURI)\n-\t\t{\n-\t\t\tthrow new IllegalArgumentException(\"The prefix '\" + XMLConstants.XML_NS_PREFIX + \"' can only be bound to '\" + XMLConstants.XML_NS_URI + \".\");\n-\t\t}\n-\n-\t\tif (isXmlNamespaceURI && !isXmlNamespacePrefix)\n-\t\t{\n-\t\t\tthrow new IllegalArgumentException(\"The namespace '\" + XMLConstants.XML_NS_URI + \"' can only have the prefix '\" + XMLConstants.XML_NS_PREFIX + \".\");\n-\t\t}\n-\n-\t\tif (XMLConstants.XMLNS_ATTRIBUTE.equals(prefix) || XMLConstants.XMLNS_ATTRIBUTE_NS_URI.equals(uri))\n-\t\t{\n-\t\t\tthrow new IllegalArgumentException(\"Neither the prefix '\" + XMLConstants.XMLNS_ATTRIBUTE + \"' nor the URI '\" + XMLConstants.XMLNS_ATTRIBUTE_NS_URI + \"' can be bound.\");\n-\t\t}\n-\n-\t\t// if (!\"\".equals(prefix) && !XML11Char.isXML11ValidNCName(prefix))\n-\t\t// {\n-\t\t// throw new IllegalArgumentException(\"Prefix '\" + prefix +\n-\t\t// \"' is not a valid XML 1.1 NCName\");\n-\t\t// }\n-\n-\t\t// Grow the arrays if required.\n-\t\tif (m_numMappings >= m_prefixes.length)\n-\t\t{\n-\t\t\tString[] p = m_prefixes;\n-\t\t\tm_prefixes = new String[m_prefixes.length * 2];\n-\t\t\tSystem.arraycopy(p, 0, m_prefixes, 0, p.length);\n-\n-\t\t\tString[] u = m_uris;\n-\t\t\tm_uris = new String[m_uris.length * 2];\n-\t\t\tSystem.arraycopy(u, 0, m_uris, 0, u.length);\n-\t\t}\n-\n-\t\t// Define the new mapping.\n-\t\tm_prefixes[m_numMappings] = prefix;\n-\t\tm_uris[m_numMappings] = uri;\n-\n-\t\t// Keep track of the total number of mappings.\n-\t\tm_numMappings++;\n-\t}\n-\n-\tpublic String getNamespace(final String prefix)\n-\t{\n-\t\tPreCondition.assertArgumentNotNull(prefix);\n-\n-\t\t// Search for a mapping from the top of the array.\n-\t\tfor (int i = m_numMappings - 1; i >= 0; i--)\n-\t\t{\n-\t\t\tif (equals(prefix, m_prefixes[i]))\n-\t\t\t{\n-\t\t\t\treturn m_uris[i];\n-\t\t\t}\n-\t\t}\n-\n-\t\tfinal int length = prefix.length();\n-\n-\t\tif (3 == length)\n-\t\t{\n-\t\t\tif (equals(XMLConstants.XML_NS_PREFIX, prefix))\n-\t\t\t{\n-\t\t\t\treturn XMLConstants.XML_NS_URI;\n-\t\t\t}\n-\t\t\telse\n-\t\t\t{\n-\t\t\t\treturn null;\n-\t\t\t}\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\treturn null;\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Given a namespace-namespaceURI, get the corresponding prefix. In the case of ambiguity, the contract for this\n-\t * interface is to return a prefix that does not correspond to the prefix mapping for the default namespace.\n-\t * \n-\t * @param namespaceURI\n-\t *            The namespace URI to look up.\n-\t * @return The associated prefix.\n-\t */\n-\tpublic Iterable<String> getPrefixes(final String namespaceURI)\n-\t{\n-\t\tArrayList<String> prefixes = null;\n-\n-\t\t// Search for a mapping from the top of the array.\n-\t\tfor (int i = m_numMappings - 1; i >= 0; i--)\n-\t\t{\n-\t\t\tif (namespaceURI.equals(m_uris[i]))\n-\t\t\t{\n-\t\t\t\tif (null == prefixes)\n-\t\t\t\t{\n-\t\t\t\t\tprefixes = new ArrayList<String>();\n-\t\t\t\t}\n-\t\t\t\tprefixes.add(m_prefixes[i]);\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (null != prefixes)\n-\t\t{\n-\t\t\treturn prefixes;\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tif (namespaceURI.equals(XMLConstants.NULL_NS_URI))\n-\t\t\t{\n-\t\t\t\treturn UNARY_DEFAULT_NS_PREFIX_ITERABLE;\n-\t\t\t}\n-\t\t\tif (namespaceURI.equals(XMLConstants.XML_NS_URI))\n-\t\t\t{\n-\t\t\t\treturn UNARY_XML_NS_PREFIX_ITERABLE;\n-\t\t\t}\n-\t\t\telse if (namespaceURI.equals(XMLConstants.XMLNS_ATTRIBUTE_NS_URI))\n-\t\t\t{\n-\t\t\t\treturn UNARY_XMLNS_ATTRIBUTE_ITERABLE;\n-\t\t\t}\n-\t\t\telse\n-\t\t\t{\n-\t\t\t\treturn Collections.emptyList();\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Returns a prefix that is associated with the specified namespace-uri. If there are no viable prefix mappings then\n-\t * <code>null</code> is returned.\n-\t * \n-\t * <p>\n-\t * If there is ambiguity in the mappings available, a prefix hint can be used to suggest the most appropriate\n-\t * alternative. The prefix hint may be supplied as <code>null</code> to indicate no preference. The prefix hint will\n-\t * normally be supplied from the original parsed document. This practice can be used to make an output document\n-\t * similar to an input document.\n-\t * </p>\n-\t * <p>\n-\t * A mapping for the default (zero-length) prefix will only be considered if <code>mayUseDefaultMapping</code> is\n-\t * set to <code>true</code>. When determining the prefix for element names, the setting should be <code>true</code>.\n-\t * For attribute names, the setting should be <code>false</code>.\n-\t * </p>\n-\t * \n-\t * @param namespaceURI\n-\t *            The namespace-uri for which the prefix is required. May not be <code>null</code>.\n-\t * @param prefixHint\n-\t *            A prefix hint for selecting from alternative mappings. May be <code>null</code> to indicate no\n-\t *            preference.\n-\t * @param mayUseDefaultMapping\n-\t *            Determines whether the default namespace prefix is acceptable.\n-\t */\n-\tpublic String getPrefix(final String namespaceURI, final String prefixHint, final boolean mayUseDefaultMapping)\n-\t{\n-\t\tPreCondition.assertArgumentNotNull(namespaceURI, \"namespaceURI\");\n-\n-\t\tString bestPrefix = null;\n-\n-\t\t// Search for a mapping from the top of the array.\n-\t\tfor (int i = m_numMappings - 1; i >= 0; i--)\n-\t\t{\n-\t\t\tif (namespaceURI.equals(m_uris[i]))\n-\t\t\t{\n-\t\t\t\tfinal String currentPrefix = m_prefixes[i];\n-\n-\t\t\t\tif ((currentPrefix.length() > 0) || mayUseDefaultMapping)\n-\t\t\t\t{\n-\t\t\t\t\tif (null != prefixHint)\n-\t\t\t\t\t{\n-\t\t\t\t\t\tif (equals(currentPrefix, prefixHint))\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\treturn currentPrefix;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\n-\t\t\t\t\tif (null == bestPrefix)\n-\t\t\t\t\t{\n-\t\t\t\t\t\tbestPrefix = currentPrefix;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (null != bestPrefix)\n-\t\t{\n-\t\t\treturn bestPrefix;\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tif (namespaceURI.equals(XMLConstants.NULL_NS_URI))\n-\t\t\t{\n-\t\t\t\tif (mayUseDefaultMapping)\n-\t\t\t\t{\n-\t\t\t\t\treturn XMLConstants.DEFAULT_NS_PREFIX;\n-\t\t\t\t}\n-\t\t\t\telse\n-\t\t\t\t{\n-\t\t\t\t\treturn null;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\telse if (namespaceURI.equals(XMLConstants.XML_NS_URI))\n-\t\t\t{\n-\t\t\t\treturn XMLConstants.XML_NS_PREFIX;\n-\t\t\t}\n-\t\t\telse if (namespaceURI.equals(XMLConstants.XMLNS_ATTRIBUTE_NS_URI))\n-\t\t\t{\n-\t\t\t\treturn XMLConstants.XMLNS_ATTRIBUTE;\n-\t\t\t}\n-\t\t\telse\n-\t\t\t{\n-\t\t\t\treturn null;\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic Enumeration<String> getDeclaredPrefixes()\n-\t{\n-\t\treturn new DeclaredPrefixEnumeration();\n-\t}\n-\n-\tpublic boolean anyDeclaredPrefixes()\n-\t{\n-\t\t// There is no danger of an ArrayIndexOutOfBoundsException\n-\t\t// because the context at the bottom of the stack is initialized\n-\t\t// to contain the reserved \"xml\" prefix.\n-\t\treturn m_idxStartContext[m_idxContext] < m_numMappings;\n-\t}\n-\n-\tclass DeclaredPrefixEnumeration implements Enumeration<String>\n-\t{\n-\t\t/**\n-\t\t * Index into m_prefixes. We'll start it at the bottom of the context to preserve arrival sequence and\n-\t\t * increment.\n-\t\t */\n-\t\tprivate int m_idxMapping;\n-\n-\t\tpublic DeclaredPrefixEnumeration()\n-\t\t{\n-\t\t\tm_idxMapping = m_idxStartContext[m_idxContext];\n-\t\t}\n-\n-\t\tpublic boolean hasMoreElements()\n-\t\t{\n-\t\t\treturn m_idxMapping < m_numMappings;\n-\t\t}\n-\n-\t\tpublic String nextElement()\n-\t\t{\n-\t\t\treturn m_prefixes[m_idxMapping++];\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Type-safe function, non-virtual S/B minimal overhead.\n-\t */\n-\tprivate static boolean equals(final String lhs, final String rhs)\n-\t{\n-\t\treturn lhs.equals(rhs);\n-\t}\n+final class ValidationPrefixResolver implements PrefixResolver {\n+    private static final Iterable<String> UNARY_DEFAULT_NS_PREFIX_ITERABLE =\n+        new UnaryIterable<String>(XMLConstants.DEFAULT_NS_PREFIX);\n+\n+    private static final Iterable<String> UNARY_XML_NS_PREFIX_ITERABLE =\n+        new UnaryIterable<String>(XMLConstants.XML_NS_PREFIX);\n+\n+    private static final Iterable<String> UNARY_XMLNS_ATTRIBUTE_ITERABLE =\n+        new UnaryIterable<String>(XMLConstants.XMLNS_ATTRIBUTE);\n+\n+    ValidationPrefixResolver(final NameSource nameBridge) {\n+        this.m_prefixes = new String[8];\n+        this.m_uris = new String[8];\n+        reset();\n+    }\n+\n+    /**\n+     * The index of the currently active context. The first context has index zero.\n+     */\n+    private int m_idxContext = -1;\n+\n+    /**\n+     * Parallel array of prefixes and uris and a count of the number used.\n+     */\n+    private String[] m_prefixes;\n+\n+    private String[] m_uris;\n+\n+    private int m_numMappings = 0;\n+\n+    /**\n+     * Index into m_prefixes or m_uris of the start of a context.\n+     */\n+    private int[] m_idxStartContext = new int[8];\n+\n+    /**\n+     * Reset this NamespaceSupport for object reuse.\n+     */\n+    public void reset() {\n+        m_idxContext = -1;\n+        m_numMappings = 0;\n+\n+        pushContext();\n+    }\n+\n+    public void pushContext() {\n+        m_idxContext++;\n+\n+        // Grow the local arrays if required.\n+        if (m_idxContext >= m_idxStartContext.length) {\n+            int[] s = m_idxStartContext;\n+            m_idxStartContext = new int[m_idxStartContext.length * 2];\n+            System.arraycopy(s, 0, m_idxStartContext, 0, s.length);\n+        }\n+\n+        m_idxStartContext[m_idxContext] = m_numMappings;\n+    }\n+\n+    public void popContext() {\n+        m_numMappings = m_idxStartContext[m_idxContext];\n+\n+        m_idxContext--;\n+    }\n+\n+    public void declarePrefix(final String prefix, final String uri) {\n+        // Do not remove! This prefix check is an invariant of the API.\n+        PreCondition.assertArgumentNotNull(prefix, \"prefix\");\n+        // Do not remove! This uri check is an invariant of the API.\n+        PreCondition.assertArgumentNotNull(uri, \"uri\");\n+\n+        // Search for a mapping from the top of the array, but limited to the\n+        // current context.\n+        for (int i = m_numMappings - 1; i >= m_idxStartContext[m_idxContext]; i--) {\n+            if (equals(prefix, m_prefixes[i])) {\n+                m_uris[i] = uri;\n+                return;\n+            }\n+        }\n+\n+        final boolean isXmlNamespacePrefix = equals(XMLConstants.XML_NS_PREFIX, prefix);\n+        final boolean isXmlNamespaceURI = (XMLConstants.XML_NS_URI == uri);\n+\n+        if (isXmlNamespacePrefix && !isXmlNamespaceURI) {\n+            throw new IllegalArgumentException(\n+                \"The prefix '\" + XMLConstants.XML_NS_PREFIX + \"' can only be bound to '\" +\n+                    XMLConstants.XML_NS_URI + \".\");\n+        }\n+\n+        if (isXmlNamespaceURI && !isXmlNamespacePrefix) {\n+            throw new IllegalArgumentException(\n+                \"The namespace '\" + XMLConstants.XML_NS_URI + \"' can only have the prefix '\" +\n+                    XMLConstants.XML_NS_PREFIX + \".\");\n+        }\n+\n+        if (XMLConstants.XMLNS_ATTRIBUTE.equals(prefix) ||\n+            XMLConstants.XMLNS_ATTRIBUTE_NS_URI.equals(uri)) {\n+            throw new IllegalArgumentException(\n+                \"Neither the prefix '\" + XMLConstants.XMLNS_ATTRIBUTE + \"' nor the URI '\" +\n+                    XMLConstants.XMLNS_ATTRIBUTE_NS_URI + \"' can be bound.\");\n+        }\n+\n+        // if (!\"\".equals(prefix) && !XML11Char.isXML11ValidNCName(prefix))\n+        // {\n+        // throw new IllegalArgumentException(\"Prefix '\" + prefix +\n+        // \"' is not a valid XML 1.1 NCName\");\n+        // }\n+\n+        // Grow the arrays if required.\n+        if (m_numMappings >= m_prefixes.length) {\n+            String[] p = m_prefixes;\n+            m_prefixes = new String[m_prefixes.length * 2];\n+            System.arraycopy(p, 0, m_prefixes, 0, p.length);\n+\n+            String[] u = m_uris;\n+            m_uris = new String[m_uris.length * 2];\n+            System.arraycopy(u, 0, m_uris, 0, u.length);\n+        }\n+\n+        // Define the new mapping.\n+        m_prefixes[m_numMappings] = prefix;\n+        m_uris[m_numMappings] = uri;\n+\n+        // Keep track of the total number of mappings.\n+        m_numMappings++;\n+    }\n+\n+    public String getNamespace(final String prefix) {\n+        PreCondition.assertArgumentNotNull(prefix);\n+\n+        // Search for a mapping from the top of the array.\n+        for (int i = m_numMappings - 1; i >= 0; i--) {\n+            if (equals(prefix, m_prefixes[i])) {\n+                return m_uris[i];\n+            }\n+        }\n+\n+        final int length = prefix.length();\n+\n+        if (3 == length) {\n+            if (equals(XMLConstants.XML_NS_PREFIX, prefix)) {\n+                return XMLConstants.XML_NS_URI;\n+            } else {\n+                return null;\n+            }\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Given a namespace-namespaceURI, get the corresponding prefix. In the case of ambiguity, the contract for this\n+     * interface is to return a prefix that does not correspond to the prefix mapping for the default namespace.\n+     *\n+     * @param namespaceURI\n+     *            The namespace URI to look up.\n+     * @return The associated prefix.\n+     */\n+    public Iterable<String> getPrefixes(final String namespaceURI) {\n+        ArrayList<String> prefixes = null;\n+\n+        // Search for a mapping from the top of the array.\n+        for (int i = m_numMappings - 1; i >= 0; i--) {\n+            if (namespaceURI.equals(m_uris[i])) {\n+                if (null == prefixes) {\n+                    prefixes = new ArrayList<String>();\n+                }\n+                prefixes.add(m_prefixes[i]);\n+            }\n+        }\n+\n+        if (null != prefixes) {\n+            return prefixes;\n+        } else {\n+            if (namespaceURI.equals(XMLConstants.NULL_NS_URI)) {\n+                return UNARY_DEFAULT_NS_PREFIX_ITERABLE;\n+            }\n+            if (namespaceURI.equals(XMLConstants.XML_NS_URI)) {\n+                return UNARY_XML_NS_PREFIX_ITERABLE;\n+            } else if (namespaceURI.equals(XMLConstants.XMLNS_ATTRIBUTE_NS_URI)) {\n+                return UNARY_XMLNS_ATTRIBUTE_ITERABLE;\n+            } else {\n+                return Collections.emptyList();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns a prefix that is associated with the specified namespace-uri. If there are no viable prefix mappings then\n+     * <code>null</code> is returned.\n+     *\n+     * <p>\n+     * If there is ambiguity in the mappings available, a prefix hint can be used to suggest the most appropriate\n+     * alternative. The prefix hint may be supplied as <code>null</code> to indicate no preference. The prefix hint will\n+     * normally be supplied from the original parsed document. This practice can be used to make an output document\n+     * similar to an input document.\n+     * </p>\n+     * <p>\n+     * A mapping for the default (zero-length) prefix will only be considered if <code>mayUseDefaultMapping</code> is\n+     * set to <code>true</code>. When determining the prefix for element names, the setting should be <code>true</code>.\n+     * For attribute names, the setting should be <code>false</code>.\n+     * </p>\n+     *\n+     * @param namespaceURI\n+     *            The namespace-uri for which the prefix is required. May not be <code>null</code>.\n+     * @param prefixHint\n+     *            A prefix hint for selecting from alternative mappings. May be <code>null</code> to indicate no\n+     *            preference.\n+     * @param mayUseDefaultMapping\n+     *            Determines whether the default namespace prefix is acceptable.\n+     */\n+    public String getPrefix(final String namespaceURI, final String prefixHint,\n+                            final boolean mayUseDefaultMapping) {\n+        PreCondition.assertArgumentNotNull(namespaceURI, \"namespaceURI\");\n+\n+        String bestPrefix = null;\n+\n+        // Search for a mapping from the top of the array.\n+        for (int i = m_numMappings - 1; i >= 0; i--) {\n+            if (namespaceURI.equals(m_uris[i])) {\n+                final String currentPrefix = m_prefixes[i];\n+\n+                if ((currentPrefix.length() > 0) || mayUseDefaultMapping) {\n+                    if (null != prefixHint) {\n+                        if (equals(currentPrefix, prefixHint)) {\n+                            return currentPrefix;\n+                        }\n+                    }\n+\n+                    if (null == bestPrefix) {\n+                        bestPrefix = currentPrefix;\n+                    }\n+                }\n+            }\n+        }\n+\n+        if (null != bestPrefix) {\n+            return bestPrefix;\n+        } else {\n+            if (namespaceURI.equals(XMLConstants.NULL_NS_URI)) {\n+                if (mayUseDefaultMapping) {\n+                    return XMLConstants.DEFAULT_NS_PREFIX;\n+                } else {\n+                    return null;\n+                }\n+            } else if (namespaceURI.equals(XMLConstants.XML_NS_URI)) {\n+                return XMLConstants.XML_NS_PREFIX;\n+            } else if (namespaceURI.equals(XMLConstants.XMLNS_ATTRIBUTE_NS_URI)) {\n+                return XMLConstants.XMLNS_ATTRIBUTE;\n+            } else {\n+                return null;\n+            }\n+        }\n+    }\n+\n+    public Enumeration<String> getDeclaredPrefixes() {\n+        return new DeclaredPrefixEnumeration();\n+    }\n+\n+    public boolean anyDeclaredPrefixes() {\n+        // There is no danger of an ArrayIndexOutOfBoundsException\n+        // because the context at the bottom of the stack is initialized\n+        // to contain the reserved \"xml\" prefix.\n+        return m_idxStartContext[m_idxContext] < m_numMappings;\n+    }\n+\n+    class DeclaredPrefixEnumeration implements Enumeration<String> {\n+        /**\n+         * Index into m_prefixes. We'll start it at the bottom of the context to preserve arrival sequence and\n+         * increment.\n+         */\n+        private int m_idxMapping;\n+\n+        public DeclaredPrefixEnumeration() {\n+            m_idxMapping = m_idxStartContext[m_idxContext];\n+        }\n+\n+        public boolean hasMoreElements() {\n+            return m_idxMapping < m_numMappings;\n+        }\n+\n+        public String nextElement() {\n+            return m_prefixes[m_idxMapping++];\n+        }\n+    }\n+\n+    /**\n+     * Type-safe function, non-virtual S/B minimal overhead.\n+     */\n+    private static boolean equals(final String lhs, final String rhs) {\n+        return lhs.equals(rhs);\n+    }\n }\n",
            "diff_size": 343
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "31",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/302/ValidationPrefixResolver.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/naturalize/302/ValidationPrefixResolver.java\nindex 5b592617574..ba3d7afd737 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/302/ValidationPrefixResolver.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/naturalize/302/ValidationPrefixResolver.java\n@@ -27,16 +27,16 @@ import org.genxdm.names.PrefixResolver;\n \n final class ValidationPrefixResolver implements PrefixResolver\n {\n-\tprivate static final Iterable<String> UNARY_DEFAULT_NS_PREFIX_ITERABLE = new UnaryIterable<String>(XMLConstants.DEFAULT_NS_PREFIX);\n+    private static final Iterable<String> UNARY_DEFAULT_NS_PREFIX_ITERABLE = new UnaryIterable<String>(XMLConstants.DEFAULT_NS_PREFIX);\n \tprivate static final Iterable<String> UNARY_XML_NS_PREFIX_ITERABLE = new UnaryIterable<String>(XMLConstants.XML_NS_PREFIX);\n \tprivate static final Iterable<String> UNARY_XMLNS_ATTRIBUTE_ITERABLE = new UnaryIterable<String>(XMLConstants.XMLNS_ATTRIBUTE);\n \n \tValidationPrefixResolver(final NameSource nameBridge)\n \t{\n-\t\tthis.m_prefixes = new String[8];\n-\t\tthis.m_uris = new String [8];\n+    this.m_prefixes = new String[8];\n+\t\tthis.m_uris = new String[8];\n \t\treset();\n-\t}\n+    }\n \n \t/**\n \t * The index of the currently active context. The first context has index zero.\n@@ -60,37 +60,37 @@ final class ValidationPrefixResolver implements PrefixResolver\n \t */\n \tpublic void reset()\n \t{\n-\t\tm_idxContext = -1;\n+    m_idxContext = -1;\n \t\tm_numMappings = 0;\n \n \t\tpushContext();\n-\t}\n+    }\n \n \tpublic void pushContext()\n \t{\n-\t\tm_idxContext++;\n+    m_idxContext++;\n \n \t\t// Grow the local arrays if required.\n \t\tif (m_idxContext >= m_idxStartContext.length)\n \t\t{\n-\t\t\tint[] s = m_idxStartContext;\n+    int[] s = m_idxStartContext;\n \t\t\tm_idxStartContext = new int[m_idxStartContext.length * 2];\n \t\t\tSystem.arraycopy(s, 0, m_idxStartContext, 0, s.length);\n-\t\t}\n+    }\n \n \t\tm_idxStartContext[m_idxContext] = m_numMappings;\n-\t}\n+    }\n \n \tpublic void popContext()\n \t{\n-\t\tm_numMappings = m_idxStartContext[m_idxContext];\n+    m_numMappings = m_idxStartContext[m_idxContext];\n \n \t\tm_idxContext--;\n-\t}\n+    }\n \n \tpublic void declarePrefix(final String prefix, final String uri)\n \t{\n-\t\t// Do not remove! This prefix check is an invariant of the API.\n+    // Do not remove! This prefix check is an invariant of the API.\n \t\tPreCondition.assertArgumentNotNull(prefix, \"prefix\");\n \t\t// Do not remove! This uri check is an invariant of the API.\n \t\tPreCondition.assertArgumentNotNull(uri, \"uri\");\n@@ -99,30 +99,30 @@ final class ValidationPrefixResolver implements PrefixResolver\n \t\t// current context.\n \t\tfor (int i = m_numMappings - 1; i >= m_idxStartContext[m_idxContext]; i--)\n \t\t{\n-\t\t\tif (equals(prefix, m_prefixes[i]))\n+    if (equals(prefix, m_prefixes[i]))\n \t\t\t{\n-\t\t\t\tm_uris[i] = uri;\n+    m_uris[i] = uri;\n \t\t\t\treturn;\n-\t\t\t}\n-\t\t}\n+    }\n+    }\n \n \t\tfinal boolean isXmlNamespacePrefix = equals(XMLConstants.XML_NS_PREFIX, prefix);\n \t\tfinal boolean isXmlNamespaceURI = (XMLConstants.XML_NS_URI == uri);\n \n \t\tif (isXmlNamespacePrefix && !isXmlNamespaceURI)\n \t\t{\n-\t\t\tthrow new IllegalArgumentException(\"The prefix '\" + XMLConstants.XML_NS_PREFIX + \"' can only be bound to '\" + XMLConstants.XML_NS_URI + \".\");\n-\t\t}\n+    throw new IllegalArgumentException(\"The prefix '\" + XMLConstants.XML_NS_PREFIX + \"' can only be bound to '\" + XMLConstants.XML_NS_URI + \".\");\n+    }\n \n \t\tif (isXmlNamespaceURI && !isXmlNamespacePrefix)\n \t\t{\n-\t\t\tthrow new IllegalArgumentException(\"The namespace '\" + XMLConstants.XML_NS_URI + \"' can only have the prefix '\" + XMLConstants.XML_NS_PREFIX + \".\");\n-\t\t}\n+    throw new IllegalArgumentException(\"The namespace '\" + XMLConstants.XML_NS_URI + \"' can only have the prefix '\" + XMLConstants.XML_NS_PREFIX + \".\");\n+    }\n \n \t\tif (XMLConstants.XMLNS_ATTRIBUTE.equals(prefix) || XMLConstants.XMLNS_ATTRIBUTE_NS_URI.equals(uri))\n \t\t{\n-\t\t\tthrow new IllegalArgumentException(\"Neither the prefix '\" + XMLConstants.XMLNS_ATTRIBUTE + \"' nor the URI '\" + XMLConstants.XMLNS_ATTRIBUTE_NS_URI + \"' can be bound.\");\n-\t\t}\n+    throw new IllegalArgumentException(\"Neither the prefix '\" + XMLConstants.XMLNS_ATTRIBUTE + \"' nor the URI '\" + XMLConstants.XMLNS_ATTRIBUTE_NS_URI + \"' can be bound.\");\n+    }\n \n \t\t// if (!\"\".equals(prefix) && !XML11Char.isXML11ValidNCName(prefix))\n \t\t// {\n@@ -133,14 +133,14 @@ final class ValidationPrefixResolver implements PrefixResolver\n \t\t// Grow the arrays if required.\n \t\tif (m_numMappings >= m_prefixes.length)\n \t\t{\n-\t\t\tString[] p = m_prefixes;\n+    String[] p = m_prefixes;\n \t\t\tm_prefixes = new String[m_prefixes.length * 2];\n \t\t\tSystem.arraycopy(p, 0, m_prefixes, 0, p.length);\n \n \t\t\tString[] u = m_uris;\n \t\t\tm_uris = new String[m_uris.length * 2];\n \t\t\tSystem.arraycopy(u, 0, m_uris, 0, u.length);\n-\t\t}\n+    }\n \n \t\t// Define the new mapping.\n \t\tm_prefixes[m_numMappings] = prefix;\n@@ -148,39 +148,39 @@ final class ValidationPrefixResolver implements PrefixResolver\n \n \t\t// Keep track of the total number of mappings.\n \t\tm_numMappings++;\n-\t}\n+    }\n \n \tpublic String getNamespace(final String prefix)\n \t{\n-\t\tPreCondition.assertArgumentNotNull(prefix);\n+    PreCondition.assertArgumentNotNull(prefix);\n \n \t\t// Search for a mapping from the top of the array.\n \t\tfor (int i = m_numMappings - 1; i >= 0; i--)\n \t\t{\n-\t\t\tif (equals(prefix, m_prefixes[i]))\n+    if (equals(prefix, m_prefixes[i]))\n \t\t\t{\n-\t\t\t\treturn m_uris[i];\n-\t\t\t}\n-\t\t}\n+    return m_uris[i];\n+    }\n+    }\n \n \t\tfinal int length = prefix.length();\n \n \t\tif (3 == length)\n \t\t{\n-\t\t\tif (equals(XMLConstants.XML_NS_PREFIX, prefix))\n+    if (equals(XMLConstants.XML_NS_PREFIX, prefix))\n \t\t\t{\n-\t\t\t\treturn XMLConstants.XML_NS_URI;\n-\t\t\t}\n+    return XMLConstants.XML_NS_URI;\n+    }\n \t\t\telse\n \t\t\t{\n-\t\t\t\treturn null;\n-\t\t\t}\n-\t\t}\n+    return null;\n+    }\n+    }\n \t\telse\n \t\t{\n-\t\t\treturn null;\n-\t\t}\n-\t}\n+    return null;\n+    }\n+    }\n \n \t/**\n \t * Given a namespace-namespaceURI, get the corresponding prefix. In the case of ambiguity, the contract for this\n@@ -192,45 +192,45 @@ final class ValidationPrefixResolver implements PrefixResolver\n \t */\n \tpublic Iterable<String> getPrefixes(final String namespaceURI)\n \t{\n-\t\tArrayList<String> prefixes = null;\n+    ArrayList<String> prefixes = null;\n \n \t\t// Search for a mapping from the top of the array.\n \t\tfor (int i = m_numMappings - 1; i >= 0; i--)\n \t\t{\n-\t\t\tif (namespaceURI.equals(m_uris[i]))\n+    if (namespaceURI.equals(m_uris[i]))\n \t\t\t{\n-\t\t\t\tif (null == prefixes)\n+    if (null == prefixes)\n \t\t\t\t{\n-\t\t\t\t\tprefixes = new ArrayList<String>();\n-\t\t\t\t}\n+    prefixes = new ArrayList<String>();\n+    }\n \t\t\t\tprefixes.add(m_prefixes[i]);\n-\t\t\t}\n-\t\t}\n+    }\n+    }\n \n \t\tif (null != prefixes)\n \t\t{\n-\t\t\treturn prefixes;\n-\t\t}\n+    return prefixes;\n+    }\n \t\telse\n \t\t{\n-\t\t\tif (namespaceURI.equals(XMLConstants.NULL_NS_URI))\n+    if (namespaceURI.equals(XMLConstants.NULL_NS_URI))\n \t\t\t{\n-\t\t\t\treturn UNARY_DEFAULT_NS_PREFIX_ITERABLE;\n-\t\t\t}\n+    return UNARY_DEFAULT_NS_PREFIX_ITERABLE;\n+    }\n \t\t\tif (namespaceURI.equals(XMLConstants.XML_NS_URI))\n \t\t\t{\n-\t\t\t\treturn UNARY_XML_NS_PREFIX_ITERABLE;\n-\t\t\t}\n+    return UNARY_XML_NS_PREFIX_ITERABLE;\n+    }\n \t\t\telse if (namespaceURI.equals(XMLConstants.XMLNS_ATTRIBUTE_NS_URI))\n \t\t\t{\n-\t\t\t\treturn UNARY_XMLNS_ATTRIBUTE_ITERABLE;\n-\t\t\t}\n+    return UNARY_XMLNS_ATTRIBUTE_ITERABLE;\n+    }\n \t\t\telse\n \t\t\t{\n-\t\t\t\treturn Collections.emptyList();\n-\t\t\t}\n-\t\t}\n-\t}\n+    return Collections.emptyList();\n+    }\n+    }\n+    }\n \n \t/**\n \t * Returns a prefix that is associated with the specified namespace-uri. If there are no viable prefix mappings then\n@@ -258,83 +258,83 @@ final class ValidationPrefixResolver implements PrefixResolver\n \t */\n \tpublic String getPrefix(final String namespaceURI, final String prefixHint, final boolean mayUseDefaultMapping)\n \t{\n-\t\tPreCondition.assertArgumentNotNull(namespaceURI, \"namespaceURI\");\n+    PreCondition.assertArgumentNotNull(namespaceURI, \"namespaceURI\");\n \n \t\tString bestPrefix = null;\n \n \t\t// Search for a mapping from the top of the array.\n \t\tfor (int i = m_numMappings - 1; i >= 0; i--)\n \t\t{\n-\t\t\tif (namespaceURI.equals(m_uris[i]))\n+    if (namespaceURI.equals(m_uris[i]))\n \t\t\t{\n-\t\t\t\tfinal String currentPrefix = m_prefixes[i];\n+    final String currentPrefix = m_prefixes[i];\n \n \t\t\t\tif ((currentPrefix.length() > 0) || mayUseDefaultMapping)\n \t\t\t\t{\n-\t\t\t\t\tif (null != prefixHint)\n+    if (null != prefixHint)\n \t\t\t\t\t{\n-\t\t\t\t\t\tif (equals(currentPrefix, prefixHint))\n+    if (equals(currentPrefix, prefixHint))\n \t\t\t\t\t\t{\n-\t\t\t\t\t\t\treturn currentPrefix;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n+    return currentPrefix;\n+    }\n+    }\n \n \t\t\t\t\tif (null == bestPrefix)\n \t\t\t\t\t{\n-\t\t\t\t\t\tbestPrefix = currentPrefix;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n+    bestPrefix = currentPrefix;\n+    }\n+    }\n+    }\n+    }\n \n \t\tif (null != bestPrefix)\n \t\t{\n-\t\t\treturn bestPrefix;\n-\t\t}\n+    return bestPrefix;\n+    }\n \t\telse\n \t\t{\n-\t\t\tif (namespaceURI.equals(XMLConstants.NULL_NS_URI))\n+    if (namespaceURI.equals(XMLConstants.NULL_NS_URI))\n \t\t\t{\n-\t\t\t\tif (mayUseDefaultMapping)\n+    if (mayUseDefaultMapping)\n \t\t\t\t{\n-\t\t\t\t\treturn XMLConstants.DEFAULT_NS_PREFIX;\n-\t\t\t\t}\n+    return XMLConstants.DEFAULT_NS_PREFIX;\n+    }\n \t\t\t\telse\n \t\t\t\t{\n-\t\t\t\t\treturn null;\n-\t\t\t\t}\n-\t\t\t}\n+    return null;\n+    }\n+    }\n \t\t\telse if (namespaceURI.equals(XMLConstants.XML_NS_URI))\n \t\t\t{\n-\t\t\t\treturn XMLConstants.XML_NS_PREFIX;\n-\t\t\t}\n+    return XMLConstants.XML_NS_PREFIX;\n+    }\n \t\t\telse if (namespaceURI.equals(XMLConstants.XMLNS_ATTRIBUTE_NS_URI))\n \t\t\t{\n-\t\t\t\treturn XMLConstants.XMLNS_ATTRIBUTE;\n-\t\t\t}\n+    return XMLConstants.XMLNS_ATTRIBUTE;\n+    }\n \t\t\telse\n \t\t\t{\n-\t\t\t\treturn null;\n-\t\t\t}\n-\t\t}\n-\t}\n+    return null;\n+    }\n+    }\n+    }\n \n \tpublic Enumeration<String> getDeclaredPrefixes()\n \t{\n-\t\treturn new DeclaredPrefixEnumeration();\n-\t}\n+    return new DeclaredPrefixEnumeration();\n+    }\n \n \tpublic boolean anyDeclaredPrefixes()\n \t{\n-\t\t// There is no danger of an ArrayIndexOutOfBoundsException\n+    // There is no danger of an ArrayIndexOutOfBoundsException\n \t\t// because the context at the bottom of the stack is initialized\n \t\t// to contain the reserved \"xml\" prefix.\n \t\treturn m_idxStartContext[m_idxContext] < m_numMappings;\n-\t}\n+    }\n \n \tclass DeclaredPrefixEnumeration implements Enumeration<String>\n \t{\n-\t\t/**\n+    /**\n \t\t * Index into m_prefixes. We'll start it at the bottom of the context to preserve arrival sequence and\n \t\t * increment.\n \t\t */\n@@ -342,25 +342,25 @@ final class ValidationPrefixResolver implements PrefixResolver\n \n \t\tpublic DeclaredPrefixEnumeration()\n \t\t{\n-\t\t\tm_idxMapping = m_idxStartContext[m_idxContext];\n-\t\t}\n+    m_idxMapping = m_idxStartContext[m_idxContext];\n+    }\n \n \t\tpublic boolean hasMoreElements()\n \t\t{\n-\t\t\treturn m_idxMapping < m_numMappings;\n-\t\t}\n+    return m_idxMapping < m_numMappings;\n+    }\n \n \t\tpublic String nextElement()\n \t\t{\n-\t\t\treturn m_prefixes[m_idxMapping++];\n-\t\t}\n-\t}\n+    return m_prefixes[m_idxMapping++];\n+    }\n+    }\n \n \t/**\n \t * Type-safe function, non-virtual S/B minimal overhead.\n \t */\n \tprivate static boolean equals(final String lhs, final String rhs)\n \t{\n-\t\treturn lhs.equals(rhs);\n-\t}\n-}\n+    return lhs.equals(rhs);\n+    }\n+    }\n\\ No newline at end of file\n",
            "diff_size": 105
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/302/ValidationPrefixResolver.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/codebuff/302/ValidationPrefixResolver.java\nindex 5b592617574..f6681638655 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/302/ValidationPrefixResolver.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/codebuff/302/ValidationPrefixResolver.java\n@@ -18,349 +18,338 @@ package org.genxdm.processor.w3c.xs.validation.impl;\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.Enumeration;\n-\n import javax.xml.XMLConstants;\n-\n import org.genxdm.exceptions.PreCondition;\n import org.genxdm.names.NameSource;\n import org.genxdm.names.PrefixResolver;\n \n final class ValidationPrefixResolver implements PrefixResolver\n {\n-\tprivate static final Iterable<String> UNARY_DEFAULT_NS_PREFIX_ITERABLE = new UnaryIterable<String>(XMLConstants.DEFAULT_NS_PREFIX);\n-\tprivate static final Iterable<String> UNARY_XML_NS_PREFIX_ITERABLE = new UnaryIterable<String>(XMLConstants.XML_NS_PREFIX);\n-\tprivate static final Iterable<String> UNARY_XMLNS_ATTRIBUTE_ITERABLE = new UnaryIterable<String>(XMLConstants.XMLNS_ATTRIBUTE);\n-\n-\tValidationPrefixResolver(final NameSource nameBridge)\n-\t{\n-\t\tthis.m_prefixes = new String[8];\n-\t\tthis.m_uris = new String [8];\n-\t\treset();\n-\t}\n-\n-\t/**\n-\t * The index of the currently active context. The first context has index zero.\n-\t */\n-\tprivate int m_idxContext = -1;\n-\n-\t/**\n-\t * Parallel array of prefixes and uris and a count of the number used.\n-\t */\n-\tprivate String[] m_prefixes;\n-\tprivate String[] m_uris;\n-\tprivate int m_numMappings = 0;\n-\n-\t/**\n-\t * Index into m_prefixes or m_uris of the start of a context.\n-\t */\n-\tprivate int[] m_idxStartContext = new int[8];\n-\n-\t/**\n-\t * Reset this NamespaceSupport for object reuse.\n-\t */\n-\tpublic void reset()\n-\t{\n-\t\tm_idxContext = -1;\n-\t\tm_numMappings = 0;\n-\n-\t\tpushContext();\n-\t}\n-\n-\tpublic void pushContext()\n-\t{\n-\t\tm_idxContext++;\n-\n-\t\t// Grow the local arrays if required.\n-\t\tif (m_idxContext >= m_idxStartContext.length)\n-\t\t{\n-\t\t\tint[] s = m_idxStartContext;\n-\t\t\tm_idxStartContext = new int[m_idxStartContext.length * 2];\n-\t\t\tSystem.arraycopy(s, 0, m_idxStartContext, 0, s.length);\n-\t\t}\n-\n-\t\tm_idxStartContext[m_idxContext] = m_numMappings;\n-\t}\n-\n-\tpublic void popContext()\n-\t{\n-\t\tm_numMappings = m_idxStartContext[m_idxContext];\n-\n-\t\tm_idxContext--;\n-\t}\n-\n-\tpublic void declarePrefix(final String prefix, final String uri)\n-\t{\n-\t\t// Do not remove! This prefix check is an invariant of the API.\n-\t\tPreCondition.assertArgumentNotNull(prefix, \"prefix\");\n-\t\t// Do not remove! This uri check is an invariant of the API.\n-\t\tPreCondition.assertArgumentNotNull(uri, \"uri\");\n-\n-\t\t// Search for a mapping from the top of the array, but limited to the\n-\t\t// current context.\n-\t\tfor (int i = m_numMappings - 1; i >= m_idxStartContext[m_idxContext]; i--)\n-\t\t{\n-\t\t\tif (equals(prefix, m_prefixes[i]))\n-\t\t\t{\n-\t\t\t\tm_uris[i] = uri;\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t}\n-\n-\t\tfinal boolean isXmlNamespacePrefix = equals(XMLConstants.XML_NS_PREFIX, prefix);\n-\t\tfinal boolean isXmlNamespaceURI = (XMLConstants.XML_NS_URI == uri);\n-\n-\t\tif (isXmlNamespacePrefix && !isXmlNamespaceURI)\n-\t\t{\n-\t\t\tthrow new IllegalArgumentException(\"The prefix '\" + XMLConstants.XML_NS_PREFIX + \"' can only be bound to '\" + XMLConstants.XML_NS_URI + \".\");\n-\t\t}\n-\n-\t\tif (isXmlNamespaceURI && !isXmlNamespacePrefix)\n-\t\t{\n-\t\t\tthrow new IllegalArgumentException(\"The namespace '\" + XMLConstants.XML_NS_URI + \"' can only have the prefix '\" + XMLConstants.XML_NS_PREFIX + \".\");\n-\t\t}\n-\n-\t\tif (XMLConstants.XMLNS_ATTRIBUTE.equals(prefix) || XMLConstants.XMLNS_ATTRIBUTE_NS_URI.equals(uri))\n-\t\t{\n-\t\t\tthrow new IllegalArgumentException(\"Neither the prefix '\" + XMLConstants.XMLNS_ATTRIBUTE + \"' nor the URI '\" + XMLConstants.XMLNS_ATTRIBUTE_NS_URI + \"' can be bound.\");\n-\t\t}\n-\n-\t\t// if (!\"\".equals(prefix) && !XML11Char.isXML11ValidNCName(prefix))\n-\t\t// {\n-\t\t// throw new IllegalArgumentException(\"Prefix '\" + prefix +\n-\t\t// \"' is not a valid XML 1.1 NCName\");\n-\t\t// }\n-\n-\t\t// Grow the arrays if required.\n-\t\tif (m_numMappings >= m_prefixes.length)\n-\t\t{\n-\t\t\tString[] p = m_prefixes;\n-\t\t\tm_prefixes = new String[m_prefixes.length * 2];\n-\t\t\tSystem.arraycopy(p, 0, m_prefixes, 0, p.length);\n-\n-\t\t\tString[] u = m_uris;\n-\t\t\tm_uris = new String[m_uris.length * 2];\n-\t\t\tSystem.arraycopy(u, 0, m_uris, 0, u.length);\n-\t\t}\n-\n-\t\t// Define the new mapping.\n-\t\tm_prefixes[m_numMappings] = prefix;\n-\t\tm_uris[m_numMappings] = uri;\n-\n-\t\t// Keep track of the total number of mappings.\n-\t\tm_numMappings++;\n-\t}\n-\n-\tpublic String getNamespace(final String prefix)\n-\t{\n-\t\tPreCondition.assertArgumentNotNull(prefix);\n-\n-\t\t// Search for a mapping from the top of the array.\n-\t\tfor (int i = m_numMappings - 1; i >= 0; i--)\n-\t\t{\n-\t\t\tif (equals(prefix, m_prefixes[i]))\n-\t\t\t{\n-\t\t\t\treturn m_uris[i];\n-\t\t\t}\n-\t\t}\n-\n-\t\tfinal int length = prefix.length();\n-\n-\t\tif (3 == length)\n-\t\t{\n-\t\t\tif (equals(XMLConstants.XML_NS_PREFIX, prefix))\n-\t\t\t{\n-\t\t\t\treturn XMLConstants.XML_NS_URI;\n-\t\t\t}\n-\t\t\telse\n-\t\t\t{\n-\t\t\t\treturn null;\n-\t\t\t}\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\treturn null;\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Given a namespace-namespaceURI, get the corresponding prefix. In the case of ambiguity, the contract for this\n-\t * interface is to return a prefix that does not correspond to the prefix mapping for the default namespace.\n-\t * \n-\t * @param namespaceURI\n-\t *            The namespace URI to look up.\n-\t * @return The associated prefix.\n-\t */\n-\tpublic Iterable<String> getPrefixes(final String namespaceURI)\n-\t{\n-\t\tArrayList<String> prefixes = null;\n-\n-\t\t// Search for a mapping from the top of the array.\n-\t\tfor (int i = m_numMappings - 1; i >= 0; i--)\n-\t\t{\n-\t\t\tif (namespaceURI.equals(m_uris[i]))\n-\t\t\t{\n-\t\t\t\tif (null == prefixes)\n-\t\t\t\t{\n-\t\t\t\t\tprefixes = new ArrayList<String>();\n-\t\t\t\t}\n-\t\t\t\tprefixes.add(m_prefixes[i]);\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (null != prefixes)\n-\t\t{\n-\t\t\treturn prefixes;\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tif (namespaceURI.equals(XMLConstants.NULL_NS_URI))\n-\t\t\t{\n-\t\t\t\treturn UNARY_DEFAULT_NS_PREFIX_ITERABLE;\n-\t\t\t}\n-\t\t\tif (namespaceURI.equals(XMLConstants.XML_NS_URI))\n-\t\t\t{\n-\t\t\t\treturn UNARY_XML_NS_PREFIX_ITERABLE;\n-\t\t\t}\n-\t\t\telse if (namespaceURI.equals(XMLConstants.XMLNS_ATTRIBUTE_NS_URI))\n-\t\t\t{\n-\t\t\t\treturn UNARY_XMLNS_ATTRIBUTE_ITERABLE;\n-\t\t\t}\n-\t\t\telse\n-\t\t\t{\n-\t\t\t\treturn Collections.emptyList();\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Returns a prefix that is associated with the specified namespace-uri. If there are no viable prefix mappings then\n-\t * <code>null</code> is returned.\n-\t * \n-\t * <p>\n-\t * If there is ambiguity in the mappings available, a prefix hint can be used to suggest the most appropriate\n-\t * alternative. The prefix hint may be supplied as <code>null</code> to indicate no preference. The prefix hint will\n-\t * normally be supplied from the original parsed document. This practice can be used to make an output document\n-\t * similar to an input document.\n-\t * </p>\n-\t * <p>\n-\t * A mapping for the default (zero-length) prefix will only be considered if <code>mayUseDefaultMapping</code> is\n-\t * set to <code>true</code>. When determining the prefix for element names, the setting should be <code>true</code>.\n-\t * For attribute names, the setting should be <code>false</code>.\n-\t * </p>\n-\t * \n-\t * @param namespaceURI\n-\t *            The namespace-uri for which the prefix is required. May not be <code>null</code>.\n-\t * @param prefixHint\n-\t *            A prefix hint for selecting from alternative mappings. May be <code>null</code> to indicate no\n-\t *            preference.\n-\t * @param mayUseDefaultMapping\n-\t *            Determines whether the default namespace prefix is acceptable.\n-\t */\n-\tpublic String getPrefix(final String namespaceURI, final String prefixHint, final boolean mayUseDefaultMapping)\n-\t{\n-\t\tPreCondition.assertArgumentNotNull(namespaceURI, \"namespaceURI\");\n-\n-\t\tString bestPrefix = null;\n-\n-\t\t// Search for a mapping from the top of the array.\n-\t\tfor (int i = m_numMappings - 1; i >= 0; i--)\n-\t\t{\n-\t\t\tif (namespaceURI.equals(m_uris[i]))\n-\t\t\t{\n-\t\t\t\tfinal String currentPrefix = m_prefixes[i];\n-\n-\t\t\t\tif ((currentPrefix.length() > 0) || mayUseDefaultMapping)\n-\t\t\t\t{\n-\t\t\t\t\tif (null != prefixHint)\n-\t\t\t\t\t{\n-\t\t\t\t\t\tif (equals(currentPrefix, prefixHint))\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\treturn currentPrefix;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\n-\t\t\t\t\tif (null == bestPrefix)\n-\t\t\t\t\t{\n-\t\t\t\t\t\tbestPrefix = currentPrefix;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (null != bestPrefix)\n-\t\t{\n-\t\t\treturn bestPrefix;\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tif (namespaceURI.equals(XMLConstants.NULL_NS_URI))\n-\t\t\t{\n-\t\t\t\tif (mayUseDefaultMapping)\n-\t\t\t\t{\n-\t\t\t\t\treturn XMLConstants.DEFAULT_NS_PREFIX;\n-\t\t\t\t}\n-\t\t\t\telse\n-\t\t\t\t{\n-\t\t\t\t\treturn null;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\telse if (namespaceURI.equals(XMLConstants.XML_NS_URI))\n-\t\t\t{\n-\t\t\t\treturn XMLConstants.XML_NS_PREFIX;\n-\t\t\t}\n-\t\t\telse if (namespaceURI.equals(XMLConstants.XMLNS_ATTRIBUTE_NS_URI))\n-\t\t\t{\n-\t\t\t\treturn XMLConstants.XMLNS_ATTRIBUTE;\n-\t\t\t}\n-\t\t\telse\n-\t\t\t{\n-\t\t\t\treturn null;\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic Enumeration<String> getDeclaredPrefixes()\n-\t{\n-\t\treturn new DeclaredPrefixEnumeration();\n-\t}\n-\n-\tpublic boolean anyDeclaredPrefixes()\n-\t{\n-\t\t// There is no danger of an ArrayIndexOutOfBoundsException\n-\t\t// because the context at the bottom of the stack is initialized\n-\t\t// to contain the reserved \"xml\" prefix.\n-\t\treturn m_idxStartContext[m_idxContext] < m_numMappings;\n-\t}\n-\n-\tclass DeclaredPrefixEnumeration implements Enumeration<String>\n-\t{\n-\t\t/**\n-\t\t * Index into m_prefixes. We'll start it at the bottom of the context to preserve arrival sequence and\n-\t\t * increment.\n-\t\t */\n-\t\tprivate int m_idxMapping;\n-\n-\t\tpublic DeclaredPrefixEnumeration()\n-\t\t{\n-\t\t\tm_idxMapping = m_idxStartContext[m_idxContext];\n-\t\t}\n-\n-\t\tpublic boolean hasMoreElements()\n-\t\t{\n-\t\t\treturn m_idxMapping < m_numMappings;\n-\t\t}\n-\n-\t\tpublic String nextElement()\n-\t\t{\n-\t\t\treturn m_prefixes[m_idxMapping++];\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Type-safe function, non-virtual S/B minimal overhead.\n-\t */\n-\tprivate static boolean equals(final String lhs, final String rhs)\n-\t{\n-\t\treturn lhs.equals(rhs);\n-\t}\n-}\n+    private static final Iterable<String> UNARY_DEFAULT_NS_PREFIX_ITERABLE = new UnaryIterable<String>(XMLConstants.DEFAULT_NS_PREFIX);\n+    private static final Iterable<String> UNARY_XML_NS_PREFIX_ITERABLE = new UnaryIterable<String>(XMLConstants.XML_NS_PREFIX);\n+    private static final Iterable<String> UNARY_XMLNS_ATTRIBUTE_ITERABLE = new UnaryIterable<String>(XMLConstants.XMLNS_ATTRIBUTE);\n+\n+    ValidationPrefixResolver(final NameSource nameBridge)\n+    {\n+        this.m_prefixes = new String[8];\n+        this.m_uris = new String[8];\n+        reset();\n+    }\n+\n+    /**\n+     * The index of the currently active context. The first context has index zero.\n+     */\n+\n+    private int m_idxContext = -1;\n+\n+    /**\n+     * Parallel array of prefixes and uris and a count of the number used.\n+     */\n+    private String[] m_prefixes;\n+    private String[] m_uris;\n+    private int m_numMappings = 0;\n+\n+    /**\n+     * Index into m_prefixes or m_uris of the start of a context.\n+     */\n+    private int[] m_idxStartContext = new int[8];\n+\n+    /**\n+     * Reset this NamespaceSupport for object reuse.\n+     */\n+    public void reset()\n+    {\n+        m_idxContext = -1;\n+        m_numMappings = 0;\n+        pushContext();\n+    }\n+\n+    public void pushContext()\n+    {\n+        m_idxContext++;\n+\n+        // Grow the local arrays if required.\n+        if (m_idxContext >= m_idxStartContext.length)\n+        {\n+            int[] s = m_idxStartContext;\n+            m_idxStartContext = new int[m_idxStartContext.length * 2];\n+            System.arraycopy(s, 0, m_idxStartContext, 0, s.length);\n+        }\n+        m_idxStartContext[m_idxContext] = m_numMappings;\n+    }\n+\n+    public void popContext()\n+    {\n+        m_numMappings = m_idxStartContext[m_idxContext];\n+        m_idxContext--;\n+    }\n+\n+    public void declarePrefix(final String prefix, final String uri)\n+    {\n+        // Do not remove! This prefix check is an invariant of the API.\n+        PreCondition.assertArgumentNotNull(prefix, \"prefix\");\n+        // Do not remove! This uri check is an invariant of the API.\n+        PreCondition.assertArgumentNotNull(uri, \"uri\");\n+\n+        // Search for a mapping from the top of the array, but limited to the\n+        // current context.\n+        for (int i = m_numMappings - 1; i >= m_idxStartContext[m_idxContext]; i--)\n+        {\n+            if (equals(prefix, m_prefixes[i]))\n+            {\n+                m_uris[i] = uri;\n+                return;\n+            }\n+        }\n+\n+        final boolean isXmlNamespacePrefix = equals(XMLConstants.XML_NS_PREFIX, prefix);\n+        final boolean isXmlNamespaceURI = (XMLConstants.XML_NS_URI == uri);\n+        if (isXmlNamespacePrefix && !isXmlNamespaceURI)\n+        {\n+            throw new IllegalArgumentException(\"The prefix '\" + XMLConstants.XML_NS_PREFIX + \"' can only be bound to '\" + XMLConstants.XML_NS_URI + \".\");\n+        }\n+        if (isXmlNamespaceURI && !isXmlNamespacePrefix)\n+        {\n+            throw new IllegalArgumentException(\"The namespace '\" + XMLConstants.XML_NS_URI + \"' can only have the prefix '\" + XMLConstants.XML_NS_PREFIX + \".\");\n+        }\n+        if (XMLConstants.XMLNS_ATTRIBUTE.equals(prefix) || XMLConstants.XMLNS_ATTRIBUTE_NS_URI.equals(uri))\n+        {\n+            throw new IllegalArgumentException(\"Neither the prefix '\" + XMLConstants.XMLNS_ATTRIBUTE + \"' nor the URI '\" + XMLConstants.XMLNS_ATTRIBUTE_NS_URI + \"' can be bound.\");\n+        }\n+\n+        // if (!\"\".equals(prefix) && !XML11Char.isXML11ValidNCName(prefix))\n+        // {\n+        // throw new IllegalArgumentException(\"Prefix '\" + prefix +\n+        // \"' is not a valid XML 1.1 NCName\");\n+        // }\n+\n+        // Grow the arrays if required.\n+        if (m_numMappings >= m_prefixes.length)\n+        {\n+            String[] p = m_prefixes;\n+            m_prefixes = new String[m_prefixes.length * 2];\n+            System.arraycopy(p, 0, m_prefixes, 0, p.length);\n+            String[] u = m_uris;\n+            m_uris = new String[m_uris.length * 2];\n+            System.arraycopy(u, 0, m_uris, 0, u.length);\n+        }\n+\n+        // Define the new mapping.\n+        m_prefixes[m_numMappings] = prefix;\n+        m_uris[m_numMappings] = uri;\n+\n+        // Keep track of the total number of mappings.\n+        m_numMappings++;\n+    }\n+\n+    public String getNamespace(final String prefix)\n+    {\n+        PreCondition.assertArgumentNotNull(prefix);\n+\n+        // Search for a mapping from the top of the array.\n+        for (int i = m_numMappings - 1; i >= 0; i--)\n+        {\n+            if (equals(prefix, m_prefixes[i]))\n+            {\n+                return m_uris[i];\n+            }\n+        }\n+\n+        final int length = prefix.length();\n+        if (3 == length)\n+        {\n+            if (equals(XMLConstants.XML_NS_PREFIX, prefix))\n+            {\n+                return XMLConstants.XML_NS_URI;\n+            }\n+            else\n+            {\n+                return null;\n+            }\n+        }\n+        else\n+        {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Given a namespace-namespaceURI, get the corresponding prefix. In the case of ambiguity, the contract for this\n+     * interface is to return a prefix that does not correspond to the prefix mapping for the default namespace.\n+     * \n+     * @param namespaceURI\n+     *            The namespace URI to look up.\n+     * @return The associated prefix.\n+     */\n+\n+    public Iterable<String> getPrefixes(final String namespaceURI)\n+    {\n+        ArrayList<String> prefixes = null;\n+\n+        // Search for a mapping from the top of the array.\n+        for (int i = m_numMappings - 1; i >= 0; i--)\n+        {\n+            if (namespaceURI.equals(m_uris[i]))\n+            {\n+                if (null == prefixes)\n+                {\n+                    prefixes = new ArrayList<String>();\n+                }\n+                prefixes.add(m_prefixes[i]);\n+            }\n+        }\n+        if (null != prefixes)\n+        {\n+            return prefixes;\n+        }\n+        else\n+        {\n+            if (namespaceURI.equals(XMLConstants.NULL_NS_URI))\n+            {\n+                return UNARY_DEFAULT_NS_PREFIX_ITERABLE;\n+            }\n+            if (namespaceURI.equals(XMLConstants.XML_NS_URI))\n+            {\n+                return UNARY_XML_NS_PREFIX_ITERABLE;\n+            }\n+            else if (namespaceURI.equals(XMLConstants.XMLNS_ATTRIBUTE_NS_URI))\n+            {\n+                return UNARY_XMLNS_ATTRIBUTE_ITERABLE;\n+            }\n+            else\n+            {\n+                return Collections.emptyList();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns a prefix that is associated with the specified namespace-uri. If there are no viable prefix mappings then\n+     * <code>null</code> is returned.\n+     * \n+     * <p>\n+     * If there is ambiguity in the mappings available, a prefix hint can be used to suggest the most appropriate\n+     * alternative. The prefix hint may be supplied as <code>null</code> to indicate no preference. The prefix hint will\n+     * normally be supplied from the original parsed document. This practice can be used to make an output document\n+     * similar to an input document.\n+     * </p>\n+     * <p>\n+     * A mapping for the default (zero-length) prefix will only be considered if <code>mayUseDefaultMapping</code> is\n+     * set to <code>true</code>. When determining the prefix for element names, the setting should be <code>true</code>.\n+     * For attribute names, the setting should be <code>false</code>.\n+     * </p>\n+     * \n+     * @param namespaceURI\n+     *            The namespace-uri for which the prefix is required. May not be <code>null</code>.\n+     * @param prefixHint\n+     *            A prefix hint for selecting from alternative mappings. May be <code>null</code> to indicate no\n+     *            preference.\n+     * @param mayUseDefaultMapping\n+     *            Determines whether the default namespace prefix is acceptable.\n+     */\n+\n+    public String getPrefix(final String namespaceURI, final String prefixHint, final boolean mayUseDefaultMapping)\n+    {\n+        PreCondition.assertArgumentNotNull(namespaceURI, \"namespaceURI\");\n+        String bestPrefix = null;\n+\n+        // Search for a mapping from the top of the array.\n+        for (int i = m_numMappings - 1; i >= 0; i--)\n+        {\n+            if (namespaceURI.equals(m_uris[i]))\n+            {\n+                final String currentPrefix = m_prefixes[i];\n+                if ( (currentPrefix.length() > 0) || mayUseDefaultMapping)\n+                {\n+                    if (null != prefixHint)\n+                    {\n+                        if (equals(currentPrefix, prefixHint))\n+                        {\n+                            return currentPrefix;\n+                        }\n+                    }\n+                    if (null == bestPrefix)\n+                    {\n+                        bestPrefix = currentPrefix;\n+                    }\n+                }\n+            }\n+        }\n+        if (null != bestPrefix)\n+        {\n+            return bestPrefix;\n+        }\n+        else\n+        {\n+            if (namespaceURI.equals(XMLConstants.NULL_NS_URI))\n+            {\n+                if (mayUseDefaultMapping)\n+                {\n+                    return XMLConstants.DEFAULT_NS_PREFIX;\n+                }\n+                else\n+                {\n+                    return null;\n+                }\n+            }\n+            else if (namespaceURI.equals(XMLConstants.XML_NS_URI))\n+            {\n+                return XMLConstants.XML_NS_PREFIX;\n+            }\n+            else if (namespaceURI.equals(XMLConstants.XMLNS_ATTRIBUTE_NS_URI))\n+            {\n+                return XMLConstants.XMLNS_ATTRIBUTE;\n+            }\n+            else\n+            {\n+                return null;\n+            }\n+        }\n+    }\n+\n+    public Enumeration<String> getDeclaredPrefixes()\n+    {\n+        return new DeclaredPrefixEnumeration();\n+    }\n+\n+    public boolean anyDeclaredPrefixes()\n+    {\n+        // There is no danger of an ArrayIndexOutOfBoundsException\n+        // because the context at the bottom of the stack is initialized\n+        // to contain the reserved \"xml\" prefix.\n+        return m_idxStartContext[m_idxContext] < m_numMappings;\n+    }\n+\n+    class DeclaredPrefixEnumeration implements Enumeration<String>\n+    {\n+        /**\n+         * Index into m_prefixes. We'll start it at the bottom of the context to preserve arrival sequence and\n+         * increment.\n+         */\n+        private int m_idxMapping;\n+\n+        public DeclaredPrefixEnumeration()\n+        {\n+            m_idxMapping = m_idxStartContext[m_idxContext];\n+        }\n+\n+        public boolean hasMoreElements()\n+        {\n+            return m_idxMapping < m_numMappings;\n+        }\n+\n+        public String nextElement()\n+        {\n+            return m_prefixes[m_idxMapping++];\n+        }\n+    }\n+\n+    /**\n+     * Type-safe function, non-virtual S/B minimal overhead.\n+     */\n+\n+    private static boolean equals(final String lhs, final String rhs)\n+    {\n+        return lhs.equals(rhs);\n+    }\n+}\n\\ No newline at end of file\n",
            "diff_size": 339
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "31",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/302/ValidationPrefixResolver.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_random/302/ValidationPrefixResolver.java\nindex 5b592617574..9b8d52260df 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/302/ValidationPrefixResolver.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_random/302/ValidationPrefixResolver.java\n@@ -27,7 +27,7 @@ import org.genxdm.names.PrefixResolver;\n \n final class ValidationPrefixResolver implements PrefixResolver\n {\n-\tprivate static final Iterable<String> UNARY_DEFAULT_NS_PREFIX_ITERABLE = new UnaryIterable<String>(XMLConstants.DEFAULT_NS_PREFIX);\n+private static final Iterable<String> UNARY_DEFAULT_NS_PREFIX_ITERABLE = new UnaryIterable<String>(XMLConstants.DEFAULT_NS_PREFIX);\n \tprivate static final Iterable<String> UNARY_XML_NS_PREFIX_ITERABLE = new UnaryIterable<String>(XMLConstants.XML_NS_PREFIX);\n \tprivate static final Iterable<String> UNARY_XMLNS_ATTRIBUTE_ITERABLE = new UnaryIterable<String>(XMLConstants.XMLNS_ATTRIBUTE);\n \n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "31",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/302/ValidationPrefixResolver.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_three_grams/302/ValidationPrefixResolver.java\nindex 5b592617574..197e0c2d269 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/302/ValidationPrefixResolver.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_three_grams/302/ValidationPrefixResolver.java\n@@ -27,7 +27,7 @@ import org.genxdm.names.PrefixResolver;\n \n final class ValidationPrefixResolver implements PrefixResolver\n {\n-\tprivate static final Iterable<String> UNARY_DEFAULT_NS_PREFIX_ITERABLE = new UnaryIterable<String>(XMLConstants.DEFAULT_NS_PREFIX);\n+    private static final Iterable<String> UNARY_DEFAULT_NS_PREFIX_ITERABLE = new UnaryIterable<String>(XMLConstants.DEFAULT_NS_PREFIX);\n \tprivate static final Iterable<String> UNARY_XML_NS_PREFIX_ITERABLE = new UnaryIterable<String>(XMLConstants.XML_NS_PREFIX);\n \tprivate static final Iterable<String> UNARY_XMLNS_ATTRIBUTE_ITERABLE = new UnaryIterable<String>(XMLConstants.XMLNS_ATTRIBUTE);\n \n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "intellij",
        "codebuff"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "styler_random",
        "styler_three_grams"
    ]
}