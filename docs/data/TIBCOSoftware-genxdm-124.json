{
    "project_name": "TIBCOSoftware-genxdm",
    "error_id": "124",
    "information": {
        "errors": [
            {
                "line": "116",
                "column": "9",
                "severity": "warning",
                "message": "File contains tab characters (this is the first instance).",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
            }
        ]
    },
    "source_code": "        else if (type instanceof ComplexUrType)\n        {\n        \tvisitor.complexUrType(type);\n        }\n        else if (type instanceof ComplexType)\n        {",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "120",
                    "column": "9",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/124/TypesBridgeImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler/124/TypesBridgeImpl.java\nindex 7b177851583..7b5945f1060 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/124/TypesBridgeImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler/124/TypesBridgeImpl.java\n@@ -113,7 +113,7 @@ public final class TypesBridgeImpl implements TypesBridge\n         }\r\n         else if (type instanceof ComplexUrType)\r\n         {\r\n-        \tvisitor.complexUrType(type);\r\n+        visitor.complexUrType(type);\r\n         }\r\n         else if (type instanceof ComplexType)\r\n         {\r\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/124/TypesBridgeImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/intellij/124/TypesBridgeImpl.java\nindex 7b177851583..4fe2fcd1018 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/124/TypesBridgeImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/intellij/124/TypesBridgeImpl.java\n@@ -13,6 +13,7 @@\n  * See the License for the specific language governing permissions and\r\n  * limitations under the License.\r\n  */\r\n+\r\n package org.genxdm.bridgekit.xs;\r\n \r\n import static org.genxdm.bridgekit.names.QNameAsSet.ESCAPE;\r\n@@ -76,11 +77,9 @@ import org.genxdm.xs.types.SimpleType;\n import org.genxdm.xs.types.TextNodeType;\r\n import org.genxdm.xs.types.Type;\r\n \r\n-public final class TypesBridgeImpl implements TypesBridge\r\n-{\r\n-    public TypesBridgeImpl()\r\n-    {\r\n-        ANY_ATOMIC_TYPE = BuiltInSchema.SINGLETON.ANY_ATOMIC_TYPE; \r\n+public final class TypesBridgeImpl implements TypesBridge {\r\n+    public TypesBridgeImpl() {\r\n+        ANY_ATOMIC_TYPE = BuiltInSchema.SINGLETON.ANY_ATOMIC_TYPE;\r\n \r\n         ELEMENT = new ElementNodeTypeImpl(WILDNAME, null, false);\r\n         NAMESPACE = new NamespaceNodeTypeImpl();\r\n@@ -88,112 +87,82 @@ public final class TypesBridgeImpl implements TypesBridge\n         COMMENT = new CommentNodeTypeImpl();\r\n         PROCESSING_INSTRUCTION = new ProcessingInstructionNodeTypeImpl(null);\r\n         TEXT = new TextNodeTypeImpl();\r\n-        final SequenceType X = ZMultiplyType.zeroOrMore(ZPrimeChoiceType.choice(ELEMENT, ZPrimeChoiceType.choice(TEXT, ZPrimeChoiceType.choice(COMMENT, PROCESSING_INSTRUCTION))));\r\n+        final SequenceType X = ZMultiplyType.zeroOrMore(ZPrimeChoiceType.choice(ELEMENT,\r\n+            ZPrimeChoiceType\r\n+                .choice(TEXT, ZPrimeChoiceType.choice(COMMENT, PROCESSING_INSTRUCTION))));\r\n         DOCUMENT = new DocumentNodeTypeImpl(X);\r\n \r\n-        ANY_KIND = ZPrimeChoiceType.choice(ELEMENT, ZPrimeChoiceType.choice(ATTRIBUTE, ZPrimeChoiceType.choice(TEXT, ZPrimeChoiceType.choice(DOCUMENT, ZPrimeChoiceType.choice(COMMENT, ZPrimeChoiceType.choice(NAMESPACE, PROCESSING_INSTRUCTION))))));\r\n+        ANY_KIND = ZPrimeChoiceType.choice(ELEMENT, ZPrimeChoiceType.choice(ATTRIBUTE,\r\n+            ZPrimeChoiceType.choice(TEXT, ZPrimeChoiceType.choice(DOCUMENT, ZPrimeChoiceType\r\n+                .choice(COMMENT, ZPrimeChoiceType.choice(NAMESPACE, PROCESSING_INSTRUCTION))))));\r\n         ANY_ITEM = ZPrimeChoiceType.choice(ANY_KIND, ANY_ATOMIC_TYPE);\r\n     }\r\n \r\n     @Override\r\n-    public void accept(final SequenceType type, final MetaVisitor visitor)\r\n-    {\r\n-        if (type instanceof SimpleType)\r\n-        {\r\n-            final SimpleType simpleType = (SimpleType)type;\r\n-            if (simpleType.isAtomicType())\r\n-            {\r\n+    public void accept(final SequenceType type, final MetaVisitor visitor) {\r\n+        if (type instanceof SimpleType) {\r\n+            final SimpleType simpleType = (SimpleType) type;\r\n+            if (simpleType.isAtomicType()) {\r\n                 visitor.atomicType(simpleType, simpleType.getName(), simpleType.getBaseType());\r\n-            }\r\n-            else\r\n-            {\r\n+            } else {\r\n                 // TODO: handle the case of accept for a list simple type, i guess.\r\n                 throw new UnsupportedOperationException();\r\n             }\r\n-        }\r\n-        else if (type instanceof ComplexUrType)\r\n-        {\r\n-        \tvisitor.complexUrType(type);\r\n-        }\r\n-        else if (type instanceof ComplexType)\r\n-        {\r\n-        \tfinal ComplexType complexType = (ComplexType)type;\r\n-        \tvisitor.complexType(complexType, complexType.getName(), complexType.getBaseType());\r\n-        }\r\n-        else if (type instanceof AttributeNodeType)\r\n-        {\r\n-            final AttributeNodeType attribute = (AttributeNodeType)type;\r\n+        } else if (type instanceof ComplexUrType) {\r\n+            visitor.complexUrType(type);\r\n+        } else if (type instanceof ComplexType) {\r\n+            final ComplexType complexType = (ComplexType) type;\r\n+            visitor.complexType(complexType, complexType.getName(), complexType.getBaseType());\r\n+        } else if (type instanceof AttributeNodeType) {\r\n+            final AttributeNodeType attribute = (AttributeNodeType) type;\r\n             visitor.attributeType(attribute, attribute.getName(), attribute.getType());\r\n-        }\r\n-        else if (type instanceof ChoiceType)\r\n-        {\r\n-            final ChoiceType choice = (ChoiceType)type;\r\n+        } else if (type instanceof ChoiceType) {\r\n+            final ChoiceType choice = (ChoiceType) type;\r\n             visitor.choiceType(choice, choice.getLHS(), choice.getRHS());\r\n-        }\r\n-        else if (type instanceof CommentNodeType)\r\n-        {\r\n-            final CommentNodeType comment = (CommentNodeType)type;\r\n+        } else if (type instanceof CommentNodeType) {\r\n+            final CommentNodeType comment = (CommentNodeType) type;\r\n             visitor.textType(comment);\r\n-        }\r\n-        else if (type instanceof DocumentNodeType)\r\n-        {\r\n-            final DocumentNodeType document = (DocumentNodeType)type;\r\n+        } else if (type instanceof DocumentNodeType) {\r\n+            final DocumentNodeType document = (DocumentNodeType) type;\r\n             visitor.documentType(document, document.getContentType());\r\n-        }\r\n-        else if (type instanceof ElementNodeType)\r\n-        {\r\n-            final ElementNodeType element = (ElementNodeType)type;\r\n-            visitor.elementType(element, element.getName(), element.getType(), element.isNillable());\r\n-        }\r\n-        else if (type instanceof EmptyType)\r\n-        {\r\n-            final EmptyType emptyType = (EmptyType)type;\r\n+        } else if (type instanceof ElementNodeType) {\r\n+            final ElementNodeType element = (ElementNodeType) type;\r\n+            visitor\r\n+                .elementType(element, element.getName(), element.getType(), element.isNillable());\r\n+        } else if (type instanceof EmptyType) {\r\n+            final EmptyType emptyType = (EmptyType) type;\r\n             visitor.emptyType(emptyType);\r\n-        }\r\n-        else if (type instanceof MultiplyType)\r\n-        {\r\n-            final MultiplyType multiply = (MultiplyType)type;\r\n+        } else if (type instanceof MultiplyType) {\r\n+            final MultiplyType multiply = (MultiplyType) type;\r\n             visitor.multiplyType(multiply, multiply.getArgument(), multiply.getMultiplier());\r\n-        }\r\n-        else if (type instanceof NamespaceNodeType)\r\n-        {\r\n-            final NamespaceNodeType namespace = (NamespaceNodeType)type;\r\n+        } else if (type instanceof NamespaceNodeType) {\r\n+            final NamespaceNodeType namespace = (NamespaceNodeType) type;\r\n             visitor.namespaceType(namespace);\r\n-        }\r\n-        else if (type instanceof NoneType)\r\n-        {\r\n-            final NoneType errorType = (NoneType)type;\r\n+        } else if (type instanceof NoneType) {\r\n+            final NoneType errorType = (NoneType) type;\r\n             visitor.noneType(errorType);\r\n-        }\r\n-        else if (type instanceof ProcessingInstructionNodeType)\r\n-        {\r\n-            final ProcessingInstructionNodeType pi = (ProcessingInstructionNodeType)type;\r\n+        } else if (type instanceof ProcessingInstructionNodeType) {\r\n+            final ProcessingInstructionNodeType pi = (ProcessingInstructionNodeType) type;\r\n             visitor.processingInstructionType(pi, pi.getName());\r\n-        }\r\n-        else if (type instanceof TextNodeType)\r\n-        {\r\n-            final TextNodeType text = (TextNodeType)type;\r\n+        } else if (type instanceof TextNodeType) {\r\n+            final TextNodeType text = (TextNodeType) type;\r\n             visitor.textType(text);\r\n-        }\r\n-        else\r\n-        {\r\n+        } else {\r\n             throw new UnsupportedOperationException(\"accept(\" + type.getClass().getName() + \")\");\r\n         }\r\n     }\r\n \r\n     @Override\r\n-    public SequenceType ancestorAxis(final SequenceType type)\r\n-    {\r\n+    public SequenceType ancestorAxis(final SequenceType type) {\r\n         final PrimeType prime = type.prime();\r\n-        switch (prime.getKind())\r\n-        {\r\n-            case CHOICE:\r\n-            {\r\n-                final PrimeChoiceType choiceType = (PrimeChoiceType)prime;\r\n-                return multiply(choice(ancestorAxis(choiceType.getLHS()), ancestorAxis(choiceType.getRHS())), type.quantifier());\r\n+        switch (prime.getKind()) {\r\n+            case CHOICE: {\r\n+                final PrimeChoiceType choiceType = (PrimeChoiceType) prime;\r\n+                return multiply(\r\n+                    choice(ancestorAxis(choiceType.getLHS()), ancestorAxis(choiceType.getRHS())),\r\n+                    type.quantifier());\r\n             }\r\n-            case DOCUMENT:\r\n-            {\r\n+            case DOCUMENT: {\r\n                 return emptyType();\r\n             }\r\n             case ELEMENT:\r\n@@ -203,241 +172,200 @@ public final class TypesBridgeImpl implements TypesBridge\n             case COMMENT:\r\n             case NAMESPACE:\r\n             case PROCESSING_INSTRUCTION:\r\n-            case TEXT:\r\n-            {\r\n-                return multiply(choice(documentType(null), zeroOrMore(elementType(null, null, true))), type.quantifier());\r\n+            case TEXT: {\r\n+                return multiply(\r\n+                    choice(documentType(null), zeroOrMore(elementType(null, null, true))),\r\n+                    type.quantifier());\r\n             }\r\n-            case NONE:\r\n-            {\r\n+            case NONE: {\r\n                 return noneType();\r\n             }\r\n-            default:\r\n-            {\r\n+            default: {\r\n                 return emptyType();\r\n             }\r\n         }\r\n     }\r\n \r\n     @Override\r\n-    public SequenceType ancestorOrSelfAxis(final SequenceType contextType)\r\n-    {\r\n+    public SequenceType ancestorOrSelfAxis(final SequenceType contextType) {\r\n         return zeroOrMore(nodeType());\r\n     }\r\n \r\n     @Override\r\n-    public SequenceType atomSet(final SequenceType type)\r\n-    {\r\n-        if (type instanceof SimpleType)\r\n-        {\r\n+    public SequenceType atomSet(final SequenceType type) {\r\n+        if (type instanceof SimpleType) {\r\n             return (SimpleType) type;\r\n-        }\r\n-        else\r\n-        {\r\n+        } else {\r\n             return zeroOrMore(BuiltInSchema.SINGLETON.ANY_ATOMIC_TYPE);\r\n         }\r\n     }\r\n \r\n     @Override\r\n-    public SequenceType attributeAxis(final SequenceType type)\r\n-    {\r\n+    public SequenceType attributeAxis(final SequenceType type) {\r\n         final PrimeType prime = type.prime();\r\n-        switch (prime.getKind())\r\n-        {\r\n-            case CHOICE:\r\n-            {\r\n+        switch (prime.getKind()) {\r\n+            case CHOICE: {\r\n                 final PrimeChoiceType choiceType = (PrimeChoiceType) prime;\r\n-                return multiply(choice(attributeAxis(choiceType.getLHS()), attributeAxis(choiceType.getRHS())), type.quantifier());\r\n+                return multiply(\r\n+                    choice(attributeAxis(choiceType.getLHS()), attributeAxis(choiceType.getRHS())),\r\n+                    type.quantifier());\r\n             }\r\n-            case ELEMENT:\r\n-            {\r\n+            case ELEMENT: {\r\n                 return attributeWild(BuiltInSchema.SINGLETON.UNTYPED_ATOMIC);\r\n             }\r\n-            case SCHEMA_ELEMENT:\r\n-            {\r\n+            case SCHEMA_ELEMENT: {\r\n                 final ElementDefinition elementDecl = (ElementDefinition) prime;\r\n                 final Type smType = elementDecl.getType();\r\n-                if (smType instanceof ComplexType)\r\n-                {\r\n+                if (smType instanceof ComplexType) {\r\n                     final ComplexType complexType = (ComplexType) smType;\r\n                     return attributeAxisFromComplexType(complexType, elementDecl);\r\n-                }\r\n-                else if (smType instanceof SimpleType)\r\n-                {\r\n+                } else if (smType instanceof SimpleType) {\r\n                     return emptyType();\r\n-                }\r\n-                else\r\n-                {\r\n+                } else {\r\n                     // The type must be either a simple or a complex type.\r\n                     throw new AssertionError();\r\n                 }\r\n             }\r\n-            case COMPLEX:\r\n-            {\r\n+            case COMPLEX: {\r\n                 final ComplexType complexType = (ComplexType) prime;\r\n                 return attributeAxisFromComplexType(complexType, null);\r\n             }\r\n-            case NONE:\r\n-            {\r\n+            case NONE: {\r\n                 return noneType();\r\n             }\r\n-            default:\r\n-            {\r\n+            default: {\r\n                 return emptyType();\r\n             }\r\n         }\r\n     }\r\n \r\n     @Override\r\n-    public AttributeNodeType attributeType(final QName name, final SequenceType type)\r\n-    {\r\n-        if (name != null)\r\n+    public AttributeNodeType attributeType(final QName name, final SequenceType type) {\r\n+        if (name != null) {\r\n             return new AttributeNodeTypeImpl(name, type);\r\n+        }\r\n         return attributeWild(type);\r\n     }\r\n \r\n     @Override\r\n-    public AttributeNodeType attributeWild(SequenceType type)\r\n-    {\r\n+    public AttributeNodeType attributeWild(SequenceType type) {\r\n         return new AttributeNodeTypeImpl(WILDNAME, type);\r\n     }\r\n \r\n     @Override\r\n-    public SequenceType childAxis(final SequenceType type)\r\n-    {\r\n+    public SequenceType childAxis(final SequenceType type) {\r\n         final PrimeType prime = type.prime();\r\n-        switch (prime.getKind())\r\n-        {\r\n-            case CHOICE:\r\n-            {\r\n+        switch (prime.getKind()) {\r\n+            case CHOICE: {\r\n                 final PrimeChoiceType choiceType = (PrimeChoiceType) prime;\r\n-                return multiply(choice(childAxis(choiceType.getLHS()), childAxis(choiceType.getRHS())), type.quantifier());\r\n+                return multiply(\r\n+                    choice(childAxis(choiceType.getLHS()), childAxis(choiceType.getRHS())),\r\n+                    type.quantifier());\r\n             }\r\n-            case DOCUMENT:\r\n-            {\r\n+            case DOCUMENT: {\r\n                 final DocumentNodeType documentNodeType = (DocumentNodeType) prime;\r\n                 final SequenceType contentType = documentNodeType.getContentType();\r\n-                if (null != contentType)\r\n-                {\r\n+                if (null != contentType) {\r\n                     return contentType;\r\n-                }\r\n-                else\r\n-                {\r\n+                } else {\r\n                     final ElementNodeType elementType = elementWild(null, true);\r\n                     final TextNodeType textType = textType();\r\n                     final CommentNodeType commentType = commentType();\r\n-                    final ProcessingInstructionNodeType processingInstructionType = processingInstructionType(null);\r\n+                    final ProcessingInstructionNodeType processingInstructionType =\r\n+                        processingInstructionType(null);\r\n \r\n-                    return multiply(zeroOrMore(choice(elementType, choice(textType, choice(commentType, processingInstructionType)))), type.quantifier());\r\n+                    return multiply(zeroOrMore(choice(elementType,\r\n+                        choice(textType, choice(commentType, processingInstructionType)))),\r\n+                        type.quantifier());\r\n                 }\r\n             }\r\n-            case ELEMENT:\r\n-            {\r\n+            case ELEMENT: {\r\n                 final ElementNodeType element = (ElementNodeType) prime;\r\n                 final SequenceType dataType = element.getType();\r\n-                if (subtype(dataType, zeroOrMore(nodeType())))\r\n-                {\r\n+                if (subtype(dataType, zeroOrMore(nodeType()))) {\r\n                     return dataType;\r\n-                }\r\n-                else\r\n-                {\r\n+                } else {\r\n                     final PrimeType elementType = elementWild(null, true);\r\n                     final TextNodeType textType = textType();\r\n                     final CommentNodeType commentType = commentType();\r\n-                    final ProcessingInstructionNodeType processingInstructionType = processingInstructionType(null);\r\n+                    final ProcessingInstructionNodeType processingInstructionType =\r\n+                        processingInstructionType(null);\r\n \r\n-                    return multiply(zeroOrMore(choice(elementType, choice(textType, choice(commentType, processingInstructionType)))), type.quantifier());\r\n+                    return multiply(zeroOrMore(choice(elementType,\r\n+                        choice(textType, choice(commentType, processingInstructionType)))),\r\n+                        type.quantifier());\r\n                 }\r\n             }\r\n-            case SCHEMA_ELEMENT:\r\n-            {\r\n+            case SCHEMA_ELEMENT: {\r\n                 final ElementDefinition elementDecl = (ElementDefinition) prime;\r\n                 final Type t = elementDecl.getType();\r\n-                if (t instanceof ComplexType)\r\n-                {\r\n+                if (t instanceof ComplexType) {\r\n                     final ComplexType complexType = (ComplexType) t;\r\n                     return childAxisFromComplexType(complexType, elementDecl);\r\n-                }\r\n-                else if (t instanceof SimpleType)\r\n-                {\r\n+                } else if (t instanceof SimpleType) {\r\n                     return emptyType();\r\n-                }\r\n-                else\r\n-                {\r\n+                } else {\r\n                     // The type must be either a simple or a complex type.\r\n                     throw new AssertionError();\r\n                 }\r\n             }\r\n-            case COMPLEX:\r\n-            {\r\n+            case COMPLEX: {\r\n                 // TODO: This appears to be unreachable...\r\n                 final ComplexType complexType = (ComplexType) prime;\r\n                 return childAxisFromComplexType(complexType, null);\r\n             }\r\n-            case NONE:\r\n-            {\r\n+            case NONE: {\r\n                 return noneType();\r\n             }\r\n-            default:\r\n-            {\r\n+            default: {\r\n                 return emptyType();\r\n             }\r\n         }\r\n     }\r\n \r\n     @Override\r\n-    public SequenceType choice(final SequenceType one, final SequenceType two)\r\n-    {\r\n+    public SequenceType choice(final SequenceType one, final SequenceType two) {\r\n         return ZChoiceType.choice(one, two);\r\n     }\r\n \r\n     @Override\r\n-    public SequenceType commentTest(final SequenceType arg)\r\n-    {\r\n+    public SequenceType commentTest(final SequenceType arg) {\r\n         final PrimeType primeType = arg.prime();\r\n-        switch (primeType.getKind())\r\n-        {\r\n-            case CHOICE:\r\n-            {\r\n-                final PrimeChoiceType choiceType = (PrimeChoiceType)primeType;\r\n+        switch (primeType.getKind()) {\r\n+            case CHOICE: {\r\n+                final PrimeChoiceType choiceType = (PrimeChoiceType) primeType;\r\n \r\n-                return multiply(choice(commentTest(choiceType.getLHS()), commentTest(choiceType.getRHS())), arg.quantifier());\r\n+                return multiply(\r\n+                    choice(commentTest(choiceType.getLHS()), commentTest(choiceType.getRHS())),\r\n+                    arg.quantifier());\r\n             }\r\n-            case COMMENT:\r\n-            {\r\n+            case COMMENT: {\r\n                 return arg;\r\n             }\r\n-            case NONE:\r\n-            {\r\n+            case NONE: {\r\n                 return noneType();\r\n             }\r\n-            default:\r\n-            {\r\n+            default: {\r\n                 return emptyType();\r\n             }\r\n         }\r\n     }\r\n \r\n     @Override\r\n-    public CommentNodeType commentType()\r\n-    {\r\n+    public CommentNodeType commentType() {\r\n         return COMMENT;\r\n     }\r\n \r\n     @Override\r\n-    public SequenceType concat(final SequenceType lhs, final SequenceType rhs)\r\n-    {\r\n+    public SequenceType concat(final SequenceType lhs, final SequenceType rhs) {\r\n         return ZConcatType.concat(lhs, rhs);\r\n     }\r\n \r\n     @Override\r\n-    public SequenceType contentType(final SequenceType type)\r\n-    {\r\n-        if (type instanceof DocumentNodeType)\r\n-        {\r\n-            return ((DocumentNodeType)type).getContentType();\r\n-        }\r\n-        else\r\n-        {\r\n+    public SequenceType contentType(final SequenceType type) {\r\n+        if (type instanceof DocumentNodeType) {\r\n+            return ((DocumentNodeType) type).getContentType();\r\n+        } else {\r\n             // TODO: errr ... WTF is going on here? I can't tell whether this is\r\n             // appropriate or not. there's a method on TypesBridge that only applies to\r\n             // DocumentNodeType? Really? And it can't be in the argument? Really really?\r\n@@ -446,61 +374,58 @@ public final class TypesBridgeImpl implements TypesBridge\n     }\r\n \r\n     @Override\r\n-    public SequenceType descendantAxis(final SequenceType type)\r\n-    {\r\n+    public SequenceType descendantAxis(final SequenceType type) {\r\n         final PrimeType prime = type.prime();\r\n-        switch (prime.getKind())\r\n-        {\r\n-            case CHOICE:\r\n-            {\r\n-                final PrimeChoiceType choiceType = (PrimeChoiceType)prime;\r\n-                return multiply(choice(descendantAxis(choiceType.getLHS()), descendantAxis(choiceType.getRHS())), type.quantifier());\r\n+        switch (prime.getKind()) {\r\n+            case CHOICE: {\r\n+                final PrimeChoiceType choiceType = (PrimeChoiceType) prime;\r\n+                return multiply(choice(descendantAxis(choiceType.getLHS()),\r\n+                    descendantAxis(choiceType.getRHS())), type.quantifier());\r\n             }\r\n             case DOCUMENT:\r\n-            case ELEMENT:\r\n-            {\r\n+            case ELEMENT: {\r\n                 final ElementNodeType elementType = elementWild(null, true);\r\n                 final TextNodeType textType = textType();\r\n                 final CommentNodeType commentType = commentType();\r\n-                final ProcessingInstructionNodeType processingInstructionType = processingInstructionType(null);\r\n+                final ProcessingInstructionNodeType processingInstructionType =\r\n+                    processingInstructionType(null);\r\n \r\n-                return multiply(zeroOrMore(choice(elementType, choice(textType, choice(commentType, processingInstructionType)))), type.quantifier());\r\n+                return multiply(zeroOrMore(choice(elementType,\r\n+                    choice(textType, choice(commentType, processingInstructionType)))),\r\n+                    type.quantifier());\r\n             }\r\n-            case SCHEMA_ELEMENT:\r\n-            {\r\n+            case SCHEMA_ELEMENT: {\r\n                 final ElementNodeType elementType = elementWild(null, true);\r\n                 final TextNodeType textType = textType();\r\n                 final CommentNodeType commentType = commentType();\r\n-                final ProcessingInstructionNodeType processingInstructionType = processingInstructionType(null);\r\n+                final ProcessingInstructionNodeType processingInstructionType =\r\n+                    processingInstructionType(null);\r\n \r\n-                return multiply(zeroOrMore(choice(elementType, choice(textType, choice(commentType, processingInstructionType)))), type.quantifier());\r\n+                return multiply(zeroOrMore(choice(elementType,\r\n+                    choice(textType, choice(commentType, processingInstructionType)))),\r\n+                    type.quantifier());\r\n             }\r\n-            case NONE:\r\n-            {\r\n+            case NONE: {\r\n                 return noneType();\r\n             }\r\n-            default:\r\n-            {\r\n+            default: {\r\n                 return emptyType();\r\n             }\r\n         }\r\n     }\r\n \r\n     @Override\r\n-    public SequenceType descendantOrSelfAxis(final SequenceType type)\r\n-    {\r\n+    public SequenceType descendantOrSelfAxis(final SequenceType type) {\r\n         final PrimeType prime = type.prime();\r\n-        switch (prime.getKind())\r\n-        {\r\n-            case CHOICE:\r\n-            {\r\n-                final PrimeChoiceType choiceType = (PrimeChoiceType)prime;\r\n-                return multiply(choice(descendantOrSelfAxis(choiceType.getLHS()), descendantOrSelfAxis(choiceType.getRHS())), type.quantifier());\r\n+        switch (prime.getKind()) {\r\n+            case CHOICE: {\r\n+                final PrimeChoiceType choiceType = (PrimeChoiceType) prime;\r\n+                return multiply(choice(descendantOrSelfAxis(choiceType.getLHS()),\r\n+                    descendantOrSelfAxis(choiceType.getRHS())), type.quantifier());\r\n             }\r\n             case ELEMENT:\r\n             case SCHEMA_ELEMENT:\r\n-            case DOCUMENT:\r\n-            {\r\n+            case DOCUMENT: {\r\n                 final SequenceType kids = branchChildAxis();\r\n                 return multiply(choice(kids, prime), type.quantifier());\r\n             }\r\n@@ -509,171 +434,147 @@ public final class TypesBridgeImpl implements TypesBridge\n             case COMMENT:\r\n             case NAMESPACE:\r\n             case PROCESSING_INSTRUCTION:\r\n-            case TEXT:\r\n-            {\r\n+            case TEXT: {\r\n                 return type;\r\n             }\r\n-            case NONE:\r\n-            {\r\n+            case NONE: {\r\n                 return noneType();\r\n             }\r\n-            default:\r\n-            {\r\n+            default: {\r\n                 return emptyType();\r\n             }\r\n         }\r\n     }\r\n \r\n     @Override\r\n-    public DocumentNodeType documentType(final SequenceType contentType)\r\n-    {\r\n-        if (contentType != null)\r\n+    public DocumentNodeType documentType(final SequenceType contentType) {\r\n+        if (contentType != null) {\r\n             return new DocumentNodeTypeImpl(contentType);\r\n+        }\r\n         return DOCUMENT;\r\n     }\r\n \r\n     @Override\r\n-    public SequenceType elementTest(final SequenceType arg)\r\n-    {\r\n+    public SequenceType elementTest(final SequenceType arg) {\r\n         final PrimeType primeType = arg.prime();\r\n-        switch (primeType.getKind())\r\n-        {\r\n-            case CHOICE:\r\n-            {\r\n-                final PrimeChoiceType choiceType = (PrimeChoiceType)primeType;\r\n+        switch (primeType.getKind()) {\r\n+            case CHOICE: {\r\n+                final PrimeChoiceType choiceType = (PrimeChoiceType) primeType;\r\n \r\n-                return multiply(choice(elementTest(choiceType.getLHS()), elementTest(choiceType.getRHS())), arg.quantifier());\r\n+                return multiply(\r\n+                    choice(elementTest(choiceType.getLHS()), elementTest(choiceType.getRHS())),\r\n+                    arg.quantifier());\r\n             }\r\n             case ELEMENT:\r\n-            case SCHEMA_ELEMENT:\r\n-            {\r\n+            case SCHEMA_ELEMENT: {\r\n                 return arg;\r\n             }\r\n-            default:\r\n-            {\r\n+            default: {\r\n                 return emptyType();\r\n             }\r\n         }\r\n     }\r\n \r\n     @Override\r\n-    public ElementNodeType elementType(final QName name, final SequenceType type, final boolean nillable)\r\n-    {\r\n-        if (name != null)\r\n+    public ElementNodeType elementType(final QName name, final SequenceType type,\r\n+                                       final boolean nillable) {\r\n+        if (name != null) {\r\n             return new ElementNodeTypeImpl(name, type, nillable);\r\n+        }\r\n         return elementWild(type, nillable);\r\n     }\r\n \r\n     @Override\r\n-    public ElementNodeType elementWild(SequenceType type, boolean nillable)\r\n-    {\r\n+    public ElementNodeType elementWild(SequenceType type, boolean nillable) {\r\n         return new ElementNodeTypeImpl(WILDNAME, type, nillable);\r\n     }\r\n \r\n     @Override\r\n-    public EmptyType emptyType()\r\n-    {\r\n+    public EmptyType emptyType() {\r\n         return EMPTY;\r\n     }\r\n \r\n     @Override\r\n-    public SequenceType followingAxis(final SequenceType contextType)\r\n-    {\r\n+    public SequenceType followingAxis(final SequenceType contextType) {\r\n         return zeroOrMore(nodeType());\r\n     }\r\n \r\n     @Override\r\n-    public SequenceType followingSiblingAxis(final SequenceType type)\r\n-    {\r\n+    public SequenceType followingSiblingAxis(final SequenceType type) {\r\n         final PrimeType prime = type.prime();\r\n-        switch (prime.getKind())\r\n-        {\r\n-            case CHOICE:\r\n-            {\r\n-                final PrimeChoiceType choiceType = (PrimeChoiceType)prime;\r\n-                return multiply(choice(followingSiblingAxis(choiceType.getLHS()), followingSiblingAxis(choiceType.getRHS())), type.quantifier());\r\n+        switch (prime.getKind()) {\r\n+            case CHOICE: {\r\n+                final PrimeChoiceType choiceType = (PrimeChoiceType) prime;\r\n+                return multiply(choice(followingSiblingAxis(choiceType.getLHS()),\r\n+                    followingSiblingAxis(choiceType.getRHS())), type.quantifier());\r\n             }\r\n-            case ATTRIBUTE:\r\n-            {\r\n-                return multiply(zeroOrMore(attributeType(null, BuiltInSchema.SINGLETON.UNTYPED_ATOMIC)), type.quantifier());\r\n+            case ATTRIBUTE: {\r\n+                return multiply(\r\n+                    zeroOrMore(attributeType(null, BuiltInSchema.SINGLETON.UNTYPED_ATOMIC)),\r\n+                    type.quantifier());\r\n             }\r\n-            case SCHEMA_ATTRIBUTE:\r\n-            {\r\n+            case SCHEMA_ATTRIBUTE: {\r\n                 // TODO: This should come from the complex type, if it exists (otherwise empty).\r\n                 return multiply(zeroOrMore(attributeType(null, null)), type.quantifier());\r\n             }\r\n-            case NAMESPACE:\r\n-            {\r\n+            case NAMESPACE: {\r\n                 return multiply(zeroOrMore(namespaceType()), type.quantifier());\r\n             }\r\n-            case DOCUMENT:\r\n-            {\r\n+            case DOCUMENT: {\r\n                 return emptyType();\r\n             }\r\n             case ELEMENT:\r\n             case SCHEMA_ELEMENT:\r\n             case COMMENT:\r\n             case PROCESSING_INSTRUCTION:\r\n-            case TEXT:\r\n-            {\r\n+            case TEXT: {\r\n                 final ElementNodeType elementType = elementWild(null, true);\r\n                 final TextNodeType textType = textType();\r\n                 final CommentNodeType commentType = commentType();\r\n-                final ProcessingInstructionNodeType processingInstructionType = processingInstructionType(null);\r\n+                final ProcessingInstructionNodeType processingInstructionType =\r\n+                    processingInstructionType(null);\r\n \r\n-                return multiply(zeroOrMore(choice(elementType, choice(textType, choice(commentType, processingInstructionType)))), type.quantifier());\r\n+                return multiply(zeroOrMore(choice(elementType,\r\n+                    choice(textType, choice(commentType, processingInstructionType)))),\r\n+                    type.quantifier());\r\n             }\r\n-            case NONE:\r\n-            {\r\n+            case NONE: {\r\n                 return noneType();\r\n             }\r\n-            default:\r\n-            {\r\n+            default: {\r\n                 return emptyType();\r\n             }\r\n         }\r\n     }\r\n \r\n     @Override\r\n-    public SequenceType getBinaryLHS(final SequenceType type)\r\n-    {\r\n-        if (type instanceof ChoiceType)\r\n-        {\r\n-            final ChoiceType choice = (ChoiceType)type;\r\n+    public SequenceType getBinaryLHS(final SequenceType type) {\r\n+        if (type instanceof ChoiceType) {\r\n+            final ChoiceType choice = (ChoiceType) type;\r\n             return choice.getLHS();\r\n-        }\r\n-        else\r\n-        {\r\n+        } else {\r\n             // TODO: implement?\r\n             throw new UnsupportedOperationException(\"getBinaryLHS(\" + type.getClass() + \")\");\r\n         }\r\n     }\r\n \r\n     @Override\r\n-    public SequenceType getBinaryRHS(final SequenceType type)\r\n-    {\r\n-        if (type instanceof ChoiceType)\r\n-        {\r\n-            final ChoiceType choice = (ChoiceType)type;\r\n+    public SequenceType getBinaryRHS(final SequenceType type) {\r\n+        if (type instanceof ChoiceType) {\r\n+            final ChoiceType choice = (ChoiceType) type;\r\n             return choice.getRHS();\r\n-        }\r\n-        else\r\n-        {\r\n+        } else {\r\n             // TODO: implement?\r\n             throw new UnsupportedOperationException(\"getBinaryRHS(\" + type.getClass() + \")\");\r\n         }\r\n     }\r\n \r\n     @Override\r\n-    public QName getErrorCode(final SequenceType noneType)\r\n-    {\r\n-        if (noneType instanceof NoneType)\r\n-        {\r\n-            final NoneType error = (NoneType)noneType;\r\n+    public QName getErrorCode(final SequenceType noneType) {\r\n+        if (noneType instanceof NoneType) {\r\n+            final NoneType error = (NoneType) noneType;\r\n             return error.getErrorCode();\r\n-        }\r\n-        else\r\n-        {\r\n+        } else {\r\n             PreCondition.assertArgumentNotNull(noneType, \"noneType\");\r\n             PreCondition.assertTrue(isNone(noneType), \"isNone(noneType)\");\r\n             throw new AssertionError();\r\n@@ -681,188 +582,148 @@ public final class TypesBridgeImpl implements TypesBridge\n     }\r\n \r\n     @Override\r\n-    public QName getName(final SequenceType type)\r\n-    {\r\n-        if (type instanceof Type)\r\n-        {\r\n+    public QName getName(final SequenceType type) {\r\n+        if (type instanceof Type) {\r\n             final Type itemType = (Type) type;\r\n             return itemType.getName();\r\n-        }\r\n-        else if (type instanceof AttributeDefinition)\r\n-        {\r\n+        } else if (type instanceof AttributeDefinition) {\r\n             final AttributeDefinition attType = (AttributeDefinition) type;\r\n             return attType.getName();\r\n-        }\r\n-        else if (type instanceof AttributeNodeType)\r\n-        {\r\n+        } else if (type instanceof AttributeNodeType) {\r\n             final AttributeNodeType attributeNodeType = (AttributeNodeType) type;\r\n             return attributeNodeType.getName();\r\n-        }\r\n-        else if (type instanceof ElementNodeType)\r\n-        {\r\n+        } else if (type instanceof ElementNodeType) {\r\n             final ElementNodeType elementNodeType = (ElementNodeType) type;\r\n             return elementNodeType.getName();\r\n-        }\r\n-        else\r\n-        {\r\n+        } else {\r\n             throw new AssertionError(\"getName(\" + type.getClass() + \")\");\r\n         }\r\n     }\r\n \r\n     @Override\r\n-    public SequenceType handle(final SequenceType sequenceType)\r\n-    {\r\n+    public SequenceType handle(final SequenceType sequenceType) {\r\n         return sequenceType;\r\n     }\r\n \r\n     @Override\r\n-    public SequenceType interleave(final SequenceType one, final SequenceType two)\r\n-    {\r\n+    public SequenceType interleave(final SequenceType one, final SequenceType two) {\r\n         return ZInterleaveType.interleave(one, two);\r\n     }\r\n \r\n     @Override\r\n-    public boolean isAttributeNodeType(final SequenceType type)\r\n-    {\r\n+    public boolean isAttributeNodeType(final SequenceType type) {\r\n         return type instanceof AttributeNodeType;\r\n     }\r\n \r\n     @Override\r\n-    public boolean isChoice(final SequenceType type)\r\n-    {\r\n+    public boolean isChoice(final SequenceType type) {\r\n         return (type instanceof ChoiceType);\r\n     }\r\n \r\n     @Override\r\n-    public boolean isCommentNodeType(final SequenceType type)\r\n-    {\r\n+    public boolean isCommentNodeType(final SequenceType type) {\r\n         return type instanceof CommentNodeType;\r\n     }\r\n \r\n     @Override\r\n-    public boolean isDocumentNodeType(final SequenceType type)\r\n-    {\r\n+    public boolean isDocumentNodeType(final SequenceType type) {\r\n         return type instanceof DocumentNodeType;\r\n     }\r\n \r\n     @Override\r\n-    public boolean isElementNodeType(final SequenceType type)\r\n-    {\r\n+    public boolean isElementNodeType(final SequenceType type) {\r\n         return (type instanceof ElementNodeType);\r\n     }\r\n \r\n     @Override\r\n-    public boolean isEmpty(final SequenceType type)\r\n-    {\r\n+    public boolean isEmpty(final SequenceType type) {\r\n         return type instanceof EmptyType;\r\n     }\r\n \r\n     @Override\r\n-    public boolean isNamespaceNodeType(final SequenceType type)\r\n-    {\r\n+    public boolean isNamespaceNodeType(final SequenceType type) {\r\n         return type instanceof NamespaceNodeType;\r\n     }\r\n \r\n     @Override\r\n-    public boolean isNone(final SequenceType type)\r\n-    {\r\n+    public boolean isNone(final SequenceType type) {\r\n         return (type instanceof NoneType);\r\n     }\r\n \r\n     @Override\r\n-    public boolean isProcessingInstructionNodeType(final SequenceType type)\r\n-    {\r\n+    public boolean isProcessingInstructionNodeType(final SequenceType type) {\r\n         return type instanceof ProcessingInstructionNodeType;\r\n     }\r\n \r\n     @Override\r\n-    public boolean isTextNodeType(final SequenceType type)\r\n-    {\r\n+    public boolean isTextNodeType(final SequenceType type) {\r\n         return type instanceof TextNodeType;\r\n     }\r\n \r\n     @Override\r\n-    public PrimeType itemType()\r\n-    {\r\n+    public PrimeType itemType() {\r\n         return ANY_ITEM;\r\n     }\r\n \r\n     @Override\r\n-    public SequenceType multiply(final SequenceType argument, final Quantifier multiplier)\r\n-    {\r\n+    public SequenceType multiply(final SequenceType argument, final Quantifier multiplier) {\r\n         PreCondition.assertArgumentNotNull(argument, \"argument\");\r\n-        if (null != argument)\r\n-        {\r\n-            if (sameAs(argument, emptyType()))\r\n-            {\r\n+        if (null != argument) {\r\n+            if (sameAs(argument, emptyType())) {\r\n                 return argument;\r\n-            }\r\n-            else if (sameAs(argument, noneType()))\r\n-            {\r\n+            } else if (sameAs(argument, noneType())) {\r\n                 return argument;\r\n-            }\r\n-            else if (multiplier.isExactlyOne())\r\n-            {\r\n+            } else if (multiplier.isExactlyOne()) {\r\n                 return argument;\r\n-            }\r\n-            else\r\n-            {\r\n+            } else {\r\n                 return ZMultiplyType.multiply(argument, multiplier);\r\n             }\r\n-        }\r\n-        else\r\n-        {\r\n+        } else {\r\n             // TODO: We need to assert that the type is not null. This is a patch.\r\n             return null;\r\n         }\r\n     }\r\n \r\n     @Override\r\n-    public SequenceType namespaceAxis(final SequenceType contextType)\r\n-    {\r\n+    public SequenceType namespaceAxis(final SequenceType contextType) {\r\n         return zeroOrMore(nodeType());\r\n     }\r\n \r\n     @Override\r\n-    public SequenceType namespaceTest(final SequenceType arg)\r\n-    {\r\n+    public SequenceType namespaceTest(final SequenceType arg) {\r\n         final PrimeType primeType = arg.prime();\r\n-        switch (primeType.getKind())\r\n-        {\r\n-            case CHOICE:\r\n-            {\r\n-                final PrimeChoiceType choiceType = (PrimeChoiceType)primeType;\r\n+        switch (primeType.getKind()) {\r\n+            case CHOICE: {\r\n+                final PrimeChoiceType choiceType = (PrimeChoiceType) primeType;\r\n \r\n-                return multiply(choice(namespaceTest(choiceType.getLHS()), namespaceTest(choiceType.getRHS())), arg.quantifier());\r\n+                return multiply(\r\n+                    choice(namespaceTest(choiceType.getLHS()), namespaceTest(choiceType.getRHS())),\r\n+                    arg.quantifier());\r\n             }\r\n-            case NAMESPACE:\r\n-            {\r\n+            case NAMESPACE: {\r\n                 return arg;\r\n             }\r\n-            default:\r\n-            {\r\n+            default: {\r\n                 return emptyType();\r\n             }\r\n         }\r\n     }\r\n \r\n     @Override\r\n-    public NamespaceNodeType namespaceType()\r\n-    {\r\n+    public NamespaceNodeType namespaceType() {\r\n         return NAMESPACE;\r\n     }\r\n \r\n     @Override\r\n-    public SequenceType nodeTest(final SequenceType arg)\r\n-    {\r\n+    public SequenceType nodeTest(final SequenceType arg) {\r\n         final PrimeType primeType = arg.prime();\r\n-        switch (primeType.getKind())\r\n-        {\r\n-            case CHOICE:\r\n-            {\r\n-                final PrimeChoiceType choiceType = (PrimeChoiceType)primeType;\r\n+        switch (primeType.getKind()) {\r\n+            case CHOICE: {\r\n+                final PrimeChoiceType choiceType = (PrimeChoiceType) primeType;\r\n \r\n-                return multiply(choice(nodeTest(choiceType.getLHS()), nodeTest(choiceType.getRHS())), arg.quantifier());\r\n+                return multiply(\r\n+                    choice(nodeTest(choiceType.getLHS()), nodeTest(choiceType.getRHS())),\r\n+                    arg.quantifier());\r\n             }\r\n             case ATTRIBUTE:\r\n             case SCHEMA_ATTRIBUTE:\r\n@@ -875,345 +736,296 @@ public final class TypesBridgeImpl implements TypesBridge\n             case TEXT:\r\n             case EMPTY:\r\n             case ANY_ATOMIC_TYPE:\r\n-            case ATOM:\r\n-            {\r\n+            case ATOM: {\r\n                 return arg;\r\n             }\r\n-            case NONE:\r\n-            {\r\n+            case NONE: {\r\n                 return noneType();\r\n             }\r\n-            default:\r\n-            {\r\n+            default: {\r\n                 return emptyType();\r\n             }\r\n         }\r\n     }\r\n \r\n     @Override\r\n-    public PrimeType nodeType()\r\n-    {\r\n+    public PrimeType nodeType() {\r\n         return ANY_KIND;\r\n     }\r\n \r\n     @Override\r\n-    public NoneType noneType()\r\n-    {\r\n+    public NoneType noneType() {\r\n         return new NoneTypeImpl();\r\n     }\r\n \r\n     @Override\r\n-    public NoneType noneType(final QName errorCode)\r\n-    {\r\n+    public NoneType noneType(final QName errorCode) {\r\n         return new NoneTypeImpl(errorCode);\r\n     }\r\n \r\n     @Override\r\n-    public SequenceType oneOrMore(final SequenceType type)\r\n-    {\r\n+    public SequenceType oneOrMore(final SequenceType type) {\r\n         return multiply(type, Quantifier.ONE_OR_MORE);\r\n     }\r\n \r\n     @Override\r\n-    public SequenceType optional(final SequenceType type)\r\n-    {\r\n-        if (null != type)\r\n-        {\r\n+    public SequenceType optional(final SequenceType type) {\r\n+        if (null != type) {\r\n             return multiply(type, Quantifier.OPTIONAL);\r\n-        }\r\n-        else\r\n-        {\r\n+        } else {\r\n             return null;\r\n         }\r\n     }\r\n \r\n     @Override\r\n-    public SequenceType parentAxis(final SequenceType contextType)\r\n-    {\r\n+    public SequenceType parentAxis(final SequenceType contextType) {\r\n         return optional(nodeType());\r\n     }\r\n \r\n     @Override\r\n-    public SequenceType precedingAxis(final SequenceType contextType)\r\n-    {\r\n+    public SequenceType precedingAxis(final SequenceType contextType) {\r\n         return zeroOrMore(nodeType());\r\n     }\r\n \r\n     @Override\r\n-    public SequenceType precedingSiblingAxis(final SequenceType type)\r\n-    {\r\n+    public SequenceType precedingSiblingAxis(final SequenceType type) {\r\n         final PrimeType prime = type.prime();\r\n-        switch (prime.getKind())\r\n-        {\r\n-            case CHOICE:\r\n-            {\r\n-                final PrimeChoiceType choiceType = (PrimeChoiceType)prime;\r\n-                return multiply(choice(precedingSiblingAxis(choiceType.getLHS()), precedingSiblingAxis(choiceType.getRHS())), type.quantifier());\r\n+        switch (prime.getKind()) {\r\n+            case CHOICE: {\r\n+                final PrimeChoiceType choiceType = (PrimeChoiceType) prime;\r\n+                return multiply(choice(precedingSiblingAxis(choiceType.getLHS()),\r\n+                    precedingSiblingAxis(choiceType.getRHS())), type.quantifier());\r\n             }\r\n-            case ATTRIBUTE:\r\n-            {\r\n-                return multiply(zeroOrMore(attributeType(null, BuiltInSchema.SINGLETON.UNTYPED_ATOMIC)), type.quantifier());\r\n+            case ATTRIBUTE: {\r\n+                return multiply(\r\n+                    zeroOrMore(attributeType(null, BuiltInSchema.SINGLETON.UNTYPED_ATOMIC)),\r\n+                    type.quantifier());\r\n             }\r\n-            case SCHEMA_ATTRIBUTE:\r\n-            {\r\n+            case SCHEMA_ATTRIBUTE: {\r\n                 // TODO: This should come from the complex type, if it exists (otherwise empty).\r\n                 return multiply(zeroOrMore(attributeType(null, null)), type.quantifier());\r\n             }\r\n-            case NAMESPACE:\r\n-            {\r\n+            case NAMESPACE: {\r\n                 return multiply(zeroOrMore(namespaceType()), type.quantifier());\r\n             }\r\n-            case DOCUMENT:\r\n-            {\r\n+            case DOCUMENT: {\r\n                 return emptyType();\r\n             }\r\n             case ELEMENT:\r\n             case SCHEMA_ELEMENT:\r\n             case COMMENT:\r\n             case PROCESSING_INSTRUCTION:\r\n-            case TEXT:\r\n-            {\r\n+            case TEXT: {\r\n                 final ElementNodeType elementType = elementWild(null, true);\r\n                 final TextNodeType textType = textType();\r\n                 final CommentNodeType commentType = commentType();\r\n-                final ProcessingInstructionNodeType processingInstructionType = processingInstructionType(null);\r\n+                final ProcessingInstructionNodeType processingInstructionType =\r\n+                    processingInstructionType(null);\r\n \r\n-                return multiply(zeroOrMore(choice(elementType, choice(textType, choice(commentType, processingInstructionType)))), type.quantifier());\r\n+                return multiply(zeroOrMore(choice(elementType,\r\n+                    choice(textType, choice(commentType, processingInstructionType)))),\r\n+                    type.quantifier());\r\n             }\r\n-            case NONE:\r\n-            {\r\n+            case NONE: {\r\n                 return noneType();\r\n             }\r\n-            default:\r\n-            {\r\n+            default: {\r\n                 return emptyType();\r\n             }\r\n         }\r\n     }\r\n \r\n     @Override\r\n-    public PrimeType prime(final SequenceType type)\r\n-    {\r\n+    public PrimeType prime(final SequenceType type) {\r\n         return type.prime();\r\n     }\r\n \r\n     @Override\r\n-    public SequenceType processingInstructionTest(final SequenceType arg, final String name)\r\n-    {\r\n+    public SequenceType processingInstructionTest(final SequenceType arg, final String name) {\r\n         final PrimeType primeType = arg.prime();\r\n-        switch (primeType.getKind())\r\n-        {\r\n-            case CHOICE:\r\n-            {\r\n-                final PrimeChoiceType choiceType = (PrimeChoiceType)primeType;\r\n-                return multiply(choice(processingInstructionTest(choiceType.getLHS(), name), processingInstructionTest(choiceType.getRHS(), name)), arg.quantifier());\r\n+        switch (primeType.getKind()) {\r\n+            case CHOICE: {\r\n+                final PrimeChoiceType choiceType = (PrimeChoiceType) primeType;\r\n+                return multiply(choice(processingInstructionTest(choiceType.getLHS(), name),\r\n+                    processingInstructionTest(choiceType.getRHS(), name)), arg.quantifier());\r\n             }\r\n-            case PROCESSING_INSTRUCTION:\r\n-            {\r\n+            case PROCESSING_INSTRUCTION: {\r\n                 return arg;\r\n             }\r\n-            default:\r\n-            {\r\n+            default: {\r\n                 return emptyType();\r\n             }\r\n         }\r\n     }\r\n \r\n     @Override\r\n-    public ProcessingInstructionNodeType processingInstructionType(final String name)\r\n-    {\r\n-        if (name != null)\r\n+    public ProcessingInstructionNodeType processingInstructionType(final String name) {\r\n+        if (name != null) {\r\n             return new ProcessingInstructionNodeTypeImpl(name);\r\n+        }\r\n         return PROCESSING_INSTRUCTION;\r\n     }\r\n \r\n     @Override\r\n-    public Quantifier quantifier(final SequenceType type)\r\n-    {\r\n+    public Quantifier quantifier(final SequenceType type) {\r\n         return type.quantifier();\r\n     }\r\n \r\n     @Override\r\n-    public boolean sameAs(final SequenceType one, final SequenceType two)\r\n-    {\r\n+    public boolean sameAs(final SequenceType one, final SequenceType two) {\r\n         PreCondition.assertArgumentNotNull(one, \"one\");\r\n         PreCondition.assertArgumentNotNull(two, \"two\");\r\n         return subtype(one, two) && subtype(two, one);\r\n     }\r\n \r\n     @Override\r\n-    public SequenceType selfAxis(final SequenceType type)\r\n-    {\r\n+    public SequenceType selfAxis(final SequenceType type) {\r\n         final PrimeType prime = type.prime();\r\n-        switch (prime.getKind())\r\n-        {\r\n-            case CHOICE:\r\n-            {\r\n-                final PrimeChoiceType choiceType = (PrimeChoiceType)prime;\r\n-                return multiply(choice(selfAxis(choiceType.getLHS()), selfAxis(choiceType.getRHS())), type.quantifier());\r\n+        switch (prime.getKind()) {\r\n+            case CHOICE: {\r\n+                final PrimeChoiceType choiceType = (PrimeChoiceType) prime;\r\n+                return multiply(\r\n+                    choice(selfAxis(choiceType.getLHS()), selfAxis(choiceType.getRHS())),\r\n+                    type.quantifier());\r\n             }\r\n             case EMPTY:\r\n             case ATOM:\r\n-            case ANY_ATOMIC_TYPE:\r\n-            {\r\n+            case ANY_ATOMIC_TYPE: {\r\n                 return emptyType();\r\n             }\r\n-            case NONE:\r\n-            {\r\n+            case NONE: {\r\n                 return noneType();\r\n             }\r\n-            default:\r\n-            {\r\n+            default: {\r\n                 return type;\r\n             }\r\n         }\r\n     }\r\n \r\n     @Override\r\n-    public boolean subtype(final SequenceType lhs, final SequenceType rhs)\r\n-    {\r\n+    public boolean subtype(final SequenceType lhs, final SequenceType rhs) {\r\n         PreCondition.assertArgumentNotNull(lhs, \"lhs\");\r\n         PreCondition.assertArgumentNotNull(rhs, \"rhs\");\r\n         return SchemaSupport.subtype(lhs, rhs);\r\n     }\r\n \r\n     @Override\r\n-    public SequenceType textTest(final SequenceType arg)\r\n-    {\r\n+    public SequenceType textTest(final SequenceType arg) {\r\n         final PrimeType primeType = arg.prime();\r\n-        switch (primeType.getKind())\r\n-        {\r\n-            case CHOICE:\r\n-            {\r\n-                final PrimeChoiceType choiceType = (PrimeChoiceType)primeType;\r\n-                return multiply(choice(textTest(choiceType.getLHS()), textTest(choiceType.getRHS())), arg.quantifier());\r\n-            }\r\n-            case TEXT:\r\n-            {\r\n+        switch (primeType.getKind()) {\r\n+            case CHOICE: {\r\n+                final PrimeChoiceType choiceType = (PrimeChoiceType) primeType;\r\n+                return multiply(\r\n+                    choice(textTest(choiceType.getLHS()), textTest(choiceType.getRHS())),\r\n+                    arg.quantifier());\r\n+            }\r\n+            case TEXT: {\r\n                 return arg;\r\n             }\r\n-            case NONE:\r\n-            {\r\n+            case NONE: {\r\n                 return arg;\r\n             }\r\n-            default:\r\n-            {\r\n+            default: {\r\n                 return emptyType();\r\n             }\r\n         }\r\n     }\r\n \r\n     @Override\r\n-    public TextNodeType textType()\r\n-    {\r\n+    public TextNodeType textType() {\r\n         return TEXT;\r\n     }\r\n \r\n     @Override\r\n-    public String toString(final SequenceType type, final NamespaceResolver mappings, final String defaultElementAndTypeNamespace) throws GenXDMException\r\n-    {\r\n+    public String toString(final SequenceType type, final NamespaceResolver mappings,\r\n+                           final String defaultElementAndTypeNamespace) throws GenXDMException {\r\n         return type.toString();\r\n     }\r\n \r\n     @Override\r\n-    public SequenceType[] typeArray(final int size)\r\n-    {\r\n+    public SequenceType[] typeArray(final int size) {\r\n         return new SequenceType[size];\r\n     }\r\n \r\n     @Override\r\n-    public SequenceType zeroOrMore(final SequenceType type)\r\n-    {\r\n+    public SequenceType zeroOrMore(final SequenceType type) {\r\n         return multiply(type, Quantifier.ZERO_OR_MORE);\r\n     }\r\n \r\n-    private SequenceType attributeAxisFromComplexType(final ComplexType complexType, final ElementDefinition parentAxis)\r\n-    {\r\n+    private SequenceType attributeAxisFromComplexType(final ComplexType complexType,\r\n+                                                      final ElementDefinition parentAxis) {\r\n         final ArrayList<AttributeUse> attributeUses = ensureAttributeUses(complexType);\r\n         SequenceType result = null;\r\n-        for (final AttributeUse attributeUse : attributeUses)\r\n-        {\r\n+        for (final AttributeUse attributeUse : attributeUses) {\r\n             final SequenceType attributeType = attributeUseType(attributeUse, parentAxis);\r\n-            if (result == null)\r\n-            {\r\n+            if (result == null) {\r\n                 result = attributeType;\r\n-            }\r\n-            else\r\n-            {\r\n+            } else {\r\n                 result = interleave(result, attributeType);\r\n             }\r\n         }\r\n         return result == null ? emptyType() : result;\r\n     }\r\n \r\n-    private SequenceType attributeUseType(final AttributeUse attributeUse, final ElementDefinition parentAxis)\r\n-    {\r\n+    private SequenceType attributeUseType(final AttributeUse attributeUse,\r\n+                                          final ElementDefinition parentAxis) {\r\n         final AttributeDefinition attribute = attributeUse.getAttribute();\r\n-        if (null != parentAxis)\r\n-        {\r\n-            return multiply(new AttributeDeclWithParentAxisType(attribute, parentAxis), attributeUse.isRequired() ? Quantifier.EXACTLY_ONE : Quantifier.OPTIONAL);\r\n-        }\r\n-        else\r\n-        {\r\n-            return multiply(attribute, attributeUse.isRequired() ? Quantifier.EXACTLY_ONE : Quantifier.OPTIONAL);\r\n+        if (null != parentAxis) {\r\n+            return multiply(new AttributeDeclWithParentAxisType(attribute, parentAxis),\r\n+                attributeUse.isRequired() ? Quantifier.EXACTLY_ONE : Quantifier.OPTIONAL);\r\n+        } else {\r\n+            return multiply(attribute,\r\n+                attributeUse.isRequired() ? Quantifier.EXACTLY_ONE : Quantifier.OPTIONAL);\r\n         }\r\n     }\r\n \r\n-    private SequenceType branchChildAxis()\r\n-    {\r\n+    private SequenceType branchChildAxis() {\r\n         final ElementNodeType elementType = elementWild(null, true);\r\n         final TextNodeType textType = textType();\r\n         final CommentNodeType commentType = commentType();\r\n-        final ProcessingInstructionNodeType processingInstructionType = processingInstructionType(null);\r\n+        final ProcessingInstructionNodeType processingInstructionType =\r\n+            processingInstructionType(null);\r\n \r\n-        return zeroOrMore(choice(elementType, choice(textType, choice(commentType, processingInstructionType))));\r\n+        return zeroOrMore(\r\n+            choice(elementType, choice(textType, choice(commentType, processingInstructionType))));\r\n     }\r\n \r\n     // TODO: The suggestion here is that we can factor out this function, maybe embed in the\r\n     // complex type so that it can be cached.\r\n-    private SequenceType childAxisFromComplexType(final ComplexType complexType, final ElementDefinition parentDecl)\r\n-    {\r\n+    private SequenceType childAxisFromComplexType(final ComplexType complexType,\r\n+                                                  final ElementDefinition parentDecl) {\r\n         final ContentType contentType = complexType.getContentType();\r\n-        if (contentType.isMixed() || contentType.isElementOnly())\r\n-        {\r\n+        if (contentType.isMixed() || contentType.isElementOnly()) {\r\n             return modelGroupUseType(contentType.getContentModel(), parentDecl);\r\n-        }\r\n-        else\r\n-        {\r\n+        } else {\r\n             // TODO: handle the simple type case\r\n             throw new UnsupportedOperationException();\r\n         }\r\n     }\r\n \r\n-    private SequenceType elementUseType(final ElementUse elementUse, final ElementDefinition parentDecl)\r\n-    {\r\n+    private SequenceType elementUseType(final ElementUse elementUse,\r\n+                                        final ElementDefinition parentDecl) {\r\n         final int minOccurs = elementUse.getMinOccurs();\r\n         // Use Integer.MAX_VALUE to represent unbounded; okay in this case because call to Quantifier.approximate\r\n         // only acts upon values of 0, 1, or > 1\r\n-        final int maxOccurs = elementUse.isMaxOccursUnbounded() ? Integer.MAX_VALUE : elementUse.getMaxOccurs();\r\n+        final int maxOccurs =\r\n+            elementUse.isMaxOccursUnbounded() ? Integer.MAX_VALUE : elementUse.getMaxOccurs();\r\n         final ElementDefinition elementDecl = elementUse.getTerm();\r\n-        if (null != parentDecl)\r\n-        {\r\n-            return multiply(new ElementDeclWithParentAxisType(elementDecl, parentDecl), Quantifier.approximate(minOccurs, maxOccurs));\r\n-        }\r\n-        else\r\n-        {\r\n+        if (null != parentDecl) {\r\n+            return multiply(new ElementDeclWithParentAxisType(elementDecl, parentDecl),\r\n+                Quantifier.approximate(minOccurs, maxOccurs));\r\n+        } else {\r\n             return multiply(elementDecl, Quantifier.approximate(minOccurs, maxOccurs));\r\n         }\r\n     }\r\n \r\n-    private ArrayList<AttributeUse> ensureAttributeUses(final ComplexType complexType)\r\n-    {\r\n+    private ArrayList<AttributeUse> ensureAttributeUses(final ComplexType complexType) {\r\n         final ArrayList<AttributeUse> cachedAttributeUses = m_attributeUses.get(complexType);\r\n-        if (null != cachedAttributeUses)\r\n-        {\r\n+        if (null != cachedAttributeUses) {\r\n             return cachedAttributeUses;\r\n-        }\r\n-        else\r\n-        {\r\n+        } else {\r\n             final ArrayList<AttributeUse> attributeUses = new ArrayList<AttributeUse>();\r\n-            for (final AttributeUse attributeUse : complexType.getAttributeUses().values())\r\n-            {\r\n+            for (final AttributeUse attributeUse : complexType.getAttributeUses().values()) {\r\n                 attributeUses.add(attributeUse);\r\n             }\r\n             m_attributeUses.put(complexType, attributeUses);\r\n@@ -1221,143 +1033,133 @@ public final class TypesBridgeImpl implements TypesBridge\n         }\r\n     }\r\n \r\n-    private SequenceType modelGroupUseType(final ModelGroupUse modelGroupUse, final ElementDefinition parentDecl)\r\n-    {\r\n+    private SequenceType modelGroupUseType(final ModelGroupUse modelGroupUse,\r\n+                                           final ElementDefinition parentDecl) {\r\n         final int minOccurs = modelGroupUse.getMinOccurs();\r\n         // Use Integer.MAX_VALUE to represent unbounded; okay in this case because call to Quantifier.approximate\r\n         // only acts upon values of 0, 1, or > 1\r\n-        final int maxOccurs = modelGroupUse.isMaxOccursUnbounded() ? Integer.MAX_VALUE : modelGroupUse.getMaxOccurs();\r\n+        final int maxOccurs =\r\n+            modelGroupUse.isMaxOccursUnbounded() ? Integer.MAX_VALUE : modelGroupUse.getMaxOccurs();\r\n         final ModelGroup modelGroup = modelGroupUse.getTerm();\r\n         final ModelGroup.SmCompositor compositor = modelGroup.getCompositor();\r\n \r\n         SequenceType contentModel = null;\r\n-        for (final SchemaParticle particle : modelGroup.getParticles())\r\n-        {\r\n+        for (final SchemaParticle particle : modelGroup.getParticles()) {\r\n             final SequenceType type = particle(particle, parentDecl);\r\n-            if (null != contentModel)\r\n-            {\r\n-                switch (compositor)\r\n-                {\r\n-                case Sequence:\r\n-                {\r\n-                    contentModel = concat(contentModel, type);\r\n-                }\r\n+            if (null != contentModel) {\r\n+                switch (compositor) {\r\n+                    case Sequence: {\r\n+                        contentModel = concat(contentModel, type);\r\n+                    }\r\n                     break;\r\n-                case Choice:\r\n-                {\r\n-                    contentModel = choice(contentModel, type);\r\n-                }\r\n+                    case Choice: {\r\n+                        contentModel = choice(contentModel, type);\r\n+                    }\r\n                     break;\r\n-                case All:\r\n-                {\r\n-                    contentModel = interleave(contentModel, type);\r\n-                }\r\n+                    case All: {\r\n+                        contentModel = interleave(contentModel, type);\r\n+                    }\r\n                     break;\r\n-                default:\r\n-                {\r\n-                    // Unexpected compositor.\r\n-                    throw new AssertionError(compositor);\r\n+                    default: {\r\n+                        // Unexpected compositor.\r\n+                        throw new AssertionError(compositor);\r\n+                    }\r\n                 }\r\n-                }\r\n-            }\r\n-            else\r\n-            {\r\n+            } else {\r\n                 contentModel = type;\r\n             }\r\n         }\r\n-        if (null != contentModel)\r\n-        {\r\n+        if (null != contentModel) {\r\n             return multiply(contentModel, Quantifier.approximate(minOccurs, maxOccurs));\r\n-        }\r\n-        else\r\n-        {\r\n+        } else {\r\n             return emptyType();\r\n         }\r\n     }\r\n \r\n-    private SequenceType particle(final SchemaParticle particle, final ElementDefinition parentDecl)\r\n-    {\r\n-        if (particle instanceof ElementUse)\r\n-        {\r\n+    private SequenceType particle(final SchemaParticle particle,\r\n+                                  final ElementDefinition parentDecl) {\r\n+        if (particle instanceof ElementUse) {\r\n             return elementUseType((ElementUse) particle, parentDecl);\r\n-        }\r\n-        else if (particle instanceof ModelGroupUse)\r\n-        {\r\n+        } else if (particle instanceof ModelGroupUse) {\r\n             return modelGroupUseType((ModelGroupUse) particle, parentDecl);\r\n-        }\r\n-        else if (particle instanceof WildcardUse)\r\n-        {\r\n+        } else if (particle instanceof WildcardUse) {\r\n             return wildcardUseType((WildcardUse) particle, parentDecl);\r\n-        }\r\n-        else\r\n-        {\r\n+        } else {\r\n             // There shouldn't be anything else beside element, model group and wildcard.\r\n             throw new AssertionError(particle);\r\n         }\r\n     }\r\n \r\n-    private SequenceType wildcardUseType(final WildcardUse wildcardUse, final ElementDefinition parentDecl)\r\n-    {\r\n+    private SequenceType wildcardUseType(final WildcardUse wildcardUse,\r\n+                                         final ElementDefinition parentDecl) {\r\n         final int minOccurs = wildcardUse.getMinOccurs();\r\n         // Use Integer.MAX_VALUE to represent unbounded; okay in this case because call to Quantifier.approximate\r\n         // only acts upon values of 0, 1, or > 1\r\n-        final int maxOccurs = wildcardUse.isMaxOccursUnbounded() ? Integer.MAX_VALUE : wildcardUse.getMaxOccurs();\r\n+        final int maxOccurs =\r\n+            wildcardUse.isMaxOccursUnbounded() ? Integer.MAX_VALUE : wildcardUse.getMaxOccurs();\r\n         final SchemaWildcard term = wildcardUse.getTerm();\r\n         // final ProcessContentsMode processContents = term.getProcessContents();\r\n         final NamespaceConstraint namespaceConstraint = term.getNamespaceConstraint();\r\n-        switch (namespaceConstraint.getMode())\r\n-        {\r\n-        case Any:\r\n-        {\r\n-            return multiply(new ElementNodeWithParentAxisType(elementWild(null, true), parentDecl), Quantifier.approximate(minOccurs, maxOccurs));\r\n-        }\r\n-        case Include:\r\n-        {\r\n-            SequenceType type = null;\r\n-            for (final String namespace : namespaceConstraint.getNamespaces())\r\n-            {\r\n-                final ElementNodeWithParentAxisType append = \r\n-                    new ElementNodeWithParentAxisType(new ElementNodeTypeImpl(new QName(namespace, null), null, true), parentDecl);\r\n-                if (null != type)\r\n-                {\r\n-                    type = choice(type, append);\r\n-                }\r\n-                else\r\n-                {\r\n-                    type = append;\r\n+        switch (namespaceConstraint.getMode()) {\r\n+            case Any: {\r\n+                return multiply(\r\n+                    new ElementNodeWithParentAxisType(elementWild(null, true), parentDecl),\r\n+                    Quantifier.approximate(minOccurs, maxOccurs));\r\n+            }\r\n+            case Include: {\r\n+                SequenceType type = null;\r\n+                for (final String namespace : namespaceConstraint.getNamespaces()) {\r\n+                    final ElementNodeWithParentAxisType append =\r\n+                        new ElementNodeWithParentAxisType(\r\n+                            new ElementNodeTypeImpl(new QName(namespace, null), null, true),\r\n+                            parentDecl);\r\n+                    if (null != type) {\r\n+                        type = choice(type, append);\r\n+                    } else {\r\n+                        type = append;\r\n+                    }\r\n                 }\r\n+                return multiply(type, Quantifier.approximate(minOccurs, maxOccurs));\r\n+            }\r\n+            case Exclude: {\r\n+                // TODO: How do we define a regular expression type that excludes certain namespaces?\r\n+                // TODO: We don't even have the concept of AND.\r\n+                return multiply(\r\n+                    new ElementNodeWithParentAxisType(new ElementNodeTypeImpl(WILDNAME, null, true),\r\n+                        parentDecl), Quantifier.approximate(minOccurs,\r\n+                        maxOccurs));\r\n+            }\r\n+            default: {\r\n+                throw new AssertionError();\r\n             }\r\n-            return multiply(type, Quantifier.approximate(minOccurs, maxOccurs));\r\n-        }\r\n-        case Exclude:\r\n-        {\r\n-            // TODO: How do we define a regular expression type that excludes certain namespaces?\r\n-            // TODO: We don't even have the concept of AND.\r\n-            return multiply(new ElementNodeWithParentAxisType(new ElementNodeTypeImpl(WILDNAME, null, true), parentDecl), Quantifier.approximate(minOccurs,\r\n-                    maxOccurs));\r\n-        }\r\n-        default:\r\n-        {\r\n-            throw new AssertionError();\r\n-        }\r\n         }\r\n     }\r\n+\r\n     private final PrimeType ANY_KIND;\r\n+\r\n     private final PrimeType ANY_ITEM;\r\n+\r\n     private final AtomicUrType ANY_ATOMIC_TYPE;\r\n+\r\n     private final EmptyType EMPTY = new ZEmptyType();\r\n \r\n     private final DocumentNodeType DOCUMENT;\r\n+\r\n     private final ElementNodeType ELEMENT;\r\n+\r\n     private final CommentNodeType COMMENT;\r\n+\r\n     private final ProcessingInstructionNodeType PROCESSING_INSTRUCTION;\r\n+\r\n     private final TextNodeType TEXT;\r\n \r\n     private final AttributeNodeType ATTRIBUTE;\r\n+\r\n     private final NamespaceNodeType NAMESPACE;\r\n \r\n-    \r\n-    private final ConcurrentHashMap<Type, ArrayList<AttributeUse>> m_attributeUses = new ConcurrentHashMap<Type, ArrayList<AttributeUse>>();\r\n+\r\n+    private final ConcurrentHashMap<Type, ArrayList<AttributeUse>> m_attributeUses =\r\n+        new ConcurrentHashMap<Type, ArrayList<AttributeUse>>();\r\n \r\n     private final QName WILDNAME = new QName(ESCAPE, ESCAPE);\r\n \r\n",
            "diff_size": 703
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "121",
                    "column": "9",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/124/TypesBridgeImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/naturalize/124/TypesBridgeImpl.java\nindex 7b177851583..78946c7eb76 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/124/TypesBridgeImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/naturalize/124/TypesBridgeImpl.java\n@@ -112,14 +112,14 @@ public final class TypesBridgeImpl implements TypesBridge\n             }\r\n         }\r\n         else if (type instanceof ComplexUrType)\r\n-        {\r\n-        \tvisitor.complexUrType(type);\r\n-        }\r\n+        {\n+    visitor.complexUrType(type);\n+    }\r\n         else if (type instanceof ComplexType)\r\n-        {\r\n-        \tfinal ComplexType complexType = (ComplexType)type;\r\n-        \tvisitor.complexType(complexType, complexType.getName(), complexType.getBaseType());\r\n-        }\r\n+        {\n+    final ComplexType complexType = (ComplexType)type;\r\n+        \tvisitor.complexType(complexType, complexType.getName(), complexType.getBaseType());\n+    }\r\n         else if (type instanceof AttributeNodeType)\r\n         {\r\n             final AttributeNodeType attribute = (AttributeNodeType)type;\r\n@@ -1333,8 +1333,7 @@ public final class TypesBridgeImpl implements TypesBridge\n         {\r\n             // TODO: How do we define a regular expression type that excludes certain namespaces?\r\n             // TODO: We don't even have the concept of AND.\r\n-            return multiply(new ElementNodeWithParentAxisType(new ElementNodeTypeImpl(WILDNAME, null, true), parentDecl), Quantifier.approximate(minOccurs,\r\n-                    maxOccurs));\r\n+            return multiply(new ElementNodeWithParentAxisType(new ElementNodeTypeImpl(WILDNAME, null, true), parentDecl), Quantifier.approximate(minOccurs, maxOccurs));\r\n         }\r\n         default:\r\n         {\r\n@@ -1361,4 +1360,4 @@ public final class TypesBridgeImpl implements TypesBridge\n \r\n     private final QName WILDNAME = new QName(ESCAPE, ESCAPE);\r\n \r\n-}\r\n+}\n\\ No newline at end of file\n",
            "diff_size": 10
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/124/TypesBridgeImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/codebuff/124/TypesBridgeImpl.java\nindex 7b177851583..45be06d5cd8 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/124/TypesBridgeImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/codebuff/124/TypesBridgeImpl.java\n@@ -13,1352 +13,1351 @@\n  * See the License for the specific language governing permissions and\r\n  * limitations under the License.\r\n  */\r\n-package org.genxdm.bridgekit.xs;\r\n-\r\n-import static org.genxdm.bridgekit.names.QNameAsSet.ESCAPE;\r\n-\r\n-import java.util.ArrayList;\r\n-import java.util.concurrent.ConcurrentHashMap;\r\n-\r\n-import javax.xml.namespace.QName;\r\n-\r\n-import org.genxdm.bridgekit.xs.complex.AttributeDeclWithParentAxisType;\r\n-import org.genxdm.bridgekit.xs.complex.AttributeNodeTypeImpl;\r\n-import org.genxdm.bridgekit.xs.complex.CommentNodeTypeImpl;\r\n-import org.genxdm.bridgekit.xs.complex.DocumentNodeTypeImpl;\r\n-import org.genxdm.bridgekit.xs.complex.ElementDeclWithParentAxisType;\r\n-import org.genxdm.bridgekit.xs.complex.ElementNodeTypeImpl;\r\n-import org.genxdm.bridgekit.xs.complex.ElementNodeWithParentAxisType;\r\n-import org.genxdm.bridgekit.xs.complex.NamespaceNodeTypeImpl;\r\n-import org.genxdm.bridgekit.xs.complex.NoneTypeImpl;\r\n-import org.genxdm.bridgekit.xs.complex.ProcessingInstructionNodeTypeImpl;\r\n-import org.genxdm.bridgekit.xs.complex.TextNodeTypeImpl;\r\n-import org.genxdm.bridgekit.xs.complex.ZChoiceType;\r\n-import org.genxdm.bridgekit.xs.complex.ZConcatType;\r\n-import org.genxdm.bridgekit.xs.complex.ZEmptyType;\r\n-import org.genxdm.bridgekit.xs.complex.ZInterleaveType;\r\n-import org.genxdm.bridgekit.xs.complex.ZMultiplyType;\r\n-import org.genxdm.bridgekit.xs.complex.ZPrimeChoiceType;\r\n-import org.genxdm.exceptions.GenXDMException;\r\n-import org.genxdm.exceptions.PreCondition;\r\n-import org.genxdm.names.NamespaceResolver;\r\n-import org.genxdm.typed.types.MetaVisitor;\r\n-import org.genxdm.typed.types.Quantifier;\r\n-import org.genxdm.typed.types.TypesBridge;\r\n-import org.genxdm.xs.components.AttributeDefinition;\r\n-import org.genxdm.xs.components.ElementDefinition;\r\n-import org.genxdm.xs.components.ModelGroup;\r\n-import org.genxdm.xs.components.SchemaParticle;\r\n-import org.genxdm.xs.components.SchemaWildcard;\r\n-import org.genxdm.xs.constraints.AttributeUse;\r\n-import org.genxdm.xs.constraints.ElementUse;\r\n-import org.genxdm.xs.constraints.ModelGroupUse;\r\n-import org.genxdm.xs.constraints.NamespaceConstraint;\r\n-import org.genxdm.xs.constraints.WildcardUse;\r\n-import org.genxdm.xs.types.AtomicUrType;\r\n-import org.genxdm.xs.types.AttributeNodeType;\r\n-import org.genxdm.xs.types.ChoiceType;\r\n-import org.genxdm.xs.types.CommentNodeType;\r\n-import org.genxdm.xs.types.ComplexType;\r\n-import org.genxdm.xs.types.ComplexUrType;\r\n-import org.genxdm.xs.types.ContentType;\r\n-import org.genxdm.xs.types.DocumentNodeType;\r\n-import org.genxdm.xs.types.ElementNodeType;\r\n-import org.genxdm.xs.types.EmptyType;\r\n-import org.genxdm.xs.types.MultiplyType;\r\n-import org.genxdm.xs.types.NamespaceNodeType;\r\n-import org.genxdm.xs.types.NoneType;\r\n-import org.genxdm.xs.types.PrimeChoiceType;\r\n-import org.genxdm.xs.types.PrimeType;\r\n-import org.genxdm.xs.types.ProcessingInstructionNodeType;\r\n-import org.genxdm.xs.types.SequenceType;\r\n-import org.genxdm.xs.types.SimpleType;\r\n-import org.genxdm.xs.types.TextNodeType;\r\n-import org.genxdm.xs.types.Type;\r\n-\r\n-public final class TypesBridgeImpl implements TypesBridge\r\n-{\r\n-    public TypesBridgeImpl()\r\n-    {\r\n-        ANY_ATOMIC_TYPE = BuiltInSchema.SINGLETON.ANY_ATOMIC_TYPE; \r\n-\r\n-        ELEMENT = new ElementNodeTypeImpl(WILDNAME, null, false);\r\n-        NAMESPACE = new NamespaceNodeTypeImpl();\r\n-        ATTRIBUTE = new AttributeNodeTypeImpl(WILDNAME, null);\r\n-        COMMENT = new CommentNodeTypeImpl();\r\n-        PROCESSING_INSTRUCTION = new ProcessingInstructionNodeTypeImpl(null);\r\n-        TEXT = new TextNodeTypeImpl();\r\n-        final SequenceType X = ZMultiplyType.zeroOrMore(ZPrimeChoiceType.choice(ELEMENT, ZPrimeChoiceType.choice(TEXT, ZPrimeChoiceType.choice(COMMENT, PROCESSING_INSTRUCTION))));\r\n-        DOCUMENT = new DocumentNodeTypeImpl(X);\r\n-\r\n-        ANY_KIND = ZPrimeChoiceType.choice(ELEMENT, ZPrimeChoiceType.choice(ATTRIBUTE, ZPrimeChoiceType.choice(TEXT, ZPrimeChoiceType.choice(DOCUMENT, ZPrimeChoiceType.choice(COMMENT, ZPrimeChoiceType.choice(NAMESPACE, PROCESSING_INSTRUCTION))))));\r\n-        ANY_ITEM = ZPrimeChoiceType.choice(ANY_KIND, ANY_ATOMIC_TYPE);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void accept(final SequenceType type, final MetaVisitor visitor)\r\n-    {\r\n-        if (type instanceof SimpleType)\r\n-        {\r\n-            final SimpleType simpleType = (SimpleType)type;\r\n-            if (simpleType.isAtomicType())\r\n-            {\r\n-                visitor.atomicType(simpleType, simpleType.getName(), simpleType.getBaseType());\r\n-            }\r\n-            else\r\n-            {\r\n-                // TODO: handle the case of accept for a list simple type, i guess.\r\n-                throw new UnsupportedOperationException();\r\n-            }\r\n-        }\r\n-        else if (type instanceof ComplexUrType)\r\n-        {\r\n-        \tvisitor.complexUrType(type);\r\n-        }\r\n-        else if (type instanceof ComplexType)\r\n-        {\r\n-        \tfinal ComplexType complexType = (ComplexType)type;\r\n-        \tvisitor.complexType(complexType, complexType.getName(), complexType.getBaseType());\r\n-        }\r\n-        else if (type instanceof AttributeNodeType)\r\n-        {\r\n-            final AttributeNodeType attribute = (AttributeNodeType)type;\r\n-            visitor.attributeType(attribute, attribute.getName(), attribute.getType());\r\n-        }\r\n-        else if (type instanceof ChoiceType)\r\n-        {\r\n-            final ChoiceType choice = (ChoiceType)type;\r\n-            visitor.choiceType(choice, choice.getLHS(), choice.getRHS());\r\n-        }\r\n-        else if (type instanceof CommentNodeType)\r\n-        {\r\n-            final CommentNodeType comment = (CommentNodeType)type;\r\n-            visitor.textType(comment);\r\n-        }\r\n-        else if (type instanceof DocumentNodeType)\r\n-        {\r\n-            final DocumentNodeType document = (DocumentNodeType)type;\r\n-            visitor.documentType(document, document.getContentType());\r\n-        }\r\n-        else if (type instanceof ElementNodeType)\r\n-        {\r\n-            final ElementNodeType element = (ElementNodeType)type;\r\n-            visitor.elementType(element, element.getName(), element.getType(), element.isNillable());\r\n-        }\r\n-        else if (type instanceof EmptyType)\r\n-        {\r\n-            final EmptyType emptyType = (EmptyType)type;\r\n-            visitor.emptyType(emptyType);\r\n-        }\r\n-        else if (type instanceof MultiplyType)\r\n-        {\r\n-            final MultiplyType multiply = (MultiplyType)type;\r\n-            visitor.multiplyType(multiply, multiply.getArgument(), multiply.getMultiplier());\r\n-        }\r\n-        else if (type instanceof NamespaceNodeType)\r\n-        {\r\n-            final NamespaceNodeType namespace = (NamespaceNodeType)type;\r\n-            visitor.namespaceType(namespace);\r\n-        }\r\n-        else if (type instanceof NoneType)\r\n-        {\r\n-            final NoneType errorType = (NoneType)type;\r\n-            visitor.noneType(errorType);\r\n-        }\r\n-        else if (type instanceof ProcessingInstructionNodeType)\r\n-        {\r\n-            final ProcessingInstructionNodeType pi = (ProcessingInstructionNodeType)type;\r\n-            visitor.processingInstructionType(pi, pi.getName());\r\n-        }\r\n-        else if (type instanceof TextNodeType)\r\n-        {\r\n-            final TextNodeType text = (TextNodeType)type;\r\n-            visitor.textType(text);\r\n-        }\r\n-        else\r\n-        {\r\n-            throw new UnsupportedOperationException(\"accept(\" + type.getClass().getName() + \")\");\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public SequenceType ancestorAxis(final SequenceType type)\r\n-    {\r\n-        final PrimeType prime = type.prime();\r\n-        switch (prime.getKind())\r\n-        {\r\n-            case CHOICE:\r\n-            {\r\n-                final PrimeChoiceType choiceType = (PrimeChoiceType)prime;\r\n-                return multiply(choice(ancestorAxis(choiceType.getLHS()), ancestorAxis(choiceType.getRHS())), type.quantifier());\r\n-            }\r\n-            case DOCUMENT:\r\n-            {\r\n-                return emptyType();\r\n-            }\r\n-            case ELEMENT:\r\n-            case SCHEMA_ELEMENT:\r\n-            case ATTRIBUTE:\r\n-            case SCHEMA_ATTRIBUTE:\r\n-            case COMMENT:\r\n-            case NAMESPACE:\r\n-            case PROCESSING_INSTRUCTION:\r\n-            case TEXT:\r\n-            {\r\n-                return multiply(choice(documentType(null), zeroOrMore(elementType(null, null, true))), type.quantifier());\r\n-            }\r\n-            case NONE:\r\n-            {\r\n-                return noneType();\r\n-            }\r\n-            default:\r\n-            {\r\n-                return emptyType();\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public SequenceType ancestorOrSelfAxis(final SequenceType contextType)\r\n-    {\r\n-        return zeroOrMore(nodeType());\r\n-    }\r\n-\r\n-    @Override\r\n-    public SequenceType atomSet(final SequenceType type)\r\n-    {\r\n-        if (type instanceof SimpleType)\r\n-        {\r\n-            return (SimpleType) type;\r\n-        }\r\n-        else\r\n-        {\r\n-            return zeroOrMore(BuiltInSchema.SINGLETON.ANY_ATOMIC_TYPE);\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public SequenceType attributeAxis(final SequenceType type)\r\n-    {\r\n-        final PrimeType prime = type.prime();\r\n-        switch (prime.getKind())\r\n-        {\r\n-            case CHOICE:\r\n-            {\r\n-                final PrimeChoiceType choiceType = (PrimeChoiceType) prime;\r\n-                return multiply(choice(attributeAxis(choiceType.getLHS()), attributeAxis(choiceType.getRHS())), type.quantifier());\r\n-            }\r\n-            case ELEMENT:\r\n-            {\r\n-                return attributeWild(BuiltInSchema.SINGLETON.UNTYPED_ATOMIC);\r\n-            }\r\n-            case SCHEMA_ELEMENT:\r\n-            {\r\n-                final ElementDefinition elementDecl = (ElementDefinition) prime;\r\n-                final Type smType = elementDecl.getType();\r\n-                if (smType instanceof ComplexType)\r\n-                {\r\n-                    final ComplexType complexType = (ComplexType) smType;\r\n-                    return attributeAxisFromComplexType(complexType, elementDecl);\r\n-                }\r\n-                else if (smType instanceof SimpleType)\r\n+package org.genxdm.bridgekit.xs;\n+\n+import static org.genxdm.bridgekit.names.QNameAsSet.ESCAPE;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.ConcurrentHashMap;\n+import javax.xml.namespace.QName;\n+import org.genxdm.bridgekit.xs.complex.AttributeDeclWithParentAxisType;\n+import org.genxdm.bridgekit.xs.complex.AttributeNodeTypeImpl;\n+import org.genxdm.bridgekit.xs.complex.CommentNodeTypeImpl;\n+import org.genxdm.bridgekit.xs.complex.DocumentNodeTypeImpl;\n+import org.genxdm.bridgekit.xs.complex.ElementDeclWithParentAxisType;\n+import org.genxdm.bridgekit.xs.complex.ElementNodeTypeImpl;\n+import org.genxdm.bridgekit.xs.complex.ElementNodeWithParentAxisType;\n+import org.genxdm.bridgekit.xs.complex.NamespaceNodeTypeImpl;\n+import org.genxdm.bridgekit.xs.complex.NoneTypeImpl;\n+import org.genxdm.bridgekit.xs.complex.ProcessingInstructionNodeTypeImpl;\n+import org.genxdm.bridgekit.xs.complex.TextNodeTypeImpl;\n+import org.genxdm.bridgekit.xs.complex.ZChoiceType;\n+import org.genxdm.bridgekit.xs.complex.ZConcatType;\n+import org.genxdm.bridgekit.xs.complex.ZEmptyType;\n+import org.genxdm.bridgekit.xs.complex.ZInterleaveType;\n+import org.genxdm.bridgekit.xs.complex.ZMultiplyType;\n+import org.genxdm.bridgekit.xs.complex.ZPrimeChoiceType;\n+import org.genxdm.exceptions.GenXDMException;\n+import org.genxdm.exceptions.PreCondition;\n+import org.genxdm.names.NamespaceResolver;\n+import org.genxdm.typed.types.MetaVisitor;\n+import org.genxdm.typed.types.Quantifier;\n+import org.genxdm.typed.types.TypesBridge;\n+import org.genxdm.xs.components.AttributeDefinition;\n+import org.genxdm.xs.components.ElementDefinition;\n+import org.genxdm.xs.components.ModelGroup;\n+import org.genxdm.xs.components.SchemaParticle;\n+import org.genxdm.xs.components.SchemaWildcard;\n+import org.genxdm.xs.constraints.AttributeUse;\n+import org.genxdm.xs.constraints.ElementUse;\n+import org.genxdm.xs.constraints.ModelGroupUse;\n+import org.genxdm.xs.constraints.NamespaceConstraint;\n+import org.genxdm.xs.constraints.WildcardUse;\n+import org.genxdm.xs.types.AtomicUrType;\n+import org.genxdm.xs.types.AttributeNodeType;\n+import org.genxdm.xs.types.ChoiceType;\n+import org.genxdm.xs.types.CommentNodeType;\n+import org.genxdm.xs.types.ComplexType;\n+import org.genxdm.xs.types.ComplexUrType;\n+import org.genxdm.xs.types.ContentType;\n+import org.genxdm.xs.types.DocumentNodeType;\n+import org.genxdm.xs.types.ElementNodeType;\n+import org.genxdm.xs.types.EmptyType;\n+import org.genxdm.xs.types.MultiplyType;\n+import org.genxdm.xs.types.NamespaceNodeType;\n+import org.genxdm.xs.types.NoneType;\n+import org.genxdm.xs.types.PrimeChoiceType;\n+import org.genxdm.xs.types.PrimeType;\n+import org.genxdm.xs.types.ProcessingInstructionNodeType;\n+import org.genxdm.xs.types.SequenceType;\n+import org.genxdm.xs.types.SimpleType;\n+import org.genxdm.xs.types.TextNodeType;\n+import org.genxdm.xs.types.Type;\n+\n+public final class TypesBridgeImpl implements TypesBridge\n+{\n+    public TypesBridgeImpl()\n+    {\n+        ANY_ATOMIC_TYPE = BuiltInSchema.SINGLETON.ANY_ATOMIC_TYPE;\n+        ELEMENT = new ElementNodeTypeImpl(WILDNAME, null, false);\n+        NAMESPACE = new NamespaceNodeTypeImpl();\n+        ATTRIBUTE = new AttributeNodeTypeImpl(WILDNAME, null);\n+        COMMENT = new CommentNodeTypeImpl();\n+        PROCESSING_INSTRUCTION = new ProcessingInstructionNodeTypeImpl(null);\n+        TEXT = new TextNodeTypeImpl();\n+\n+        final SequenceType X = ZMultiplyType.zeroOrMore(ZPrimeChoiceType.choice(ELEMENT, ZPrimeChoiceType.choice(TEXT, ZPrimeChoiceType.choice(COMMENT, PROCESSING_INSTRUCTION))));\n+        DOCUMENT = new DocumentNodeTypeImpl(X);\n+        ANY_KIND = ZPrimeChoiceType.choice(ELEMENT, ZPrimeChoiceType.choice(ATTRIBUTE, ZPrimeChoiceType.choice(TEXT, ZPrimeChoiceType.choice(DOCUMENT, ZPrimeChoiceType.choice(COMMENT, ZPrimeChoiceType.choice(NAMESPACE, PROCESSING_INSTRUCTION))))));\n+        ANY_ITEM = ZPrimeChoiceType.choice(ANY_KIND, ANY_ATOMIC_TYPE);\n+    }\n+\n+    @Override\n+    public void accept(final SequenceType type, final MetaVisitor visitor)\n+    {\n+        if (type instanceof SimpleType)\n+        {\n+            final SimpleType simpleType = (SimpleType)type;\n+            if (simpleType.isAtomicType())\n+            {\n+                visitor.atomicType(simpleType, simpleType.getName(), simpleType.getBaseType());\n+            }\n+            else\n+            {\r\n+                // TODO: handle the case of accept for a list simple type, i guess.\n+                throw new UnsupportedOperationException();\n+            }\n+        }\n+        else if (type instanceof ComplexUrType)\n+        {\n+            visitor.complexUrType(type);\n+        }\n+        else if (type instanceof ComplexType)\n+        {\n+            final ComplexType complexType = (ComplexType)type;\n+            visitor.complexType(complexType, complexType.getName(), complexType.getBaseType());\n+        }\n+        else if (type instanceof AttributeNodeType)\n+        {\n+            final AttributeNodeType attribute = (AttributeNodeType)type;\n+            visitor.attributeType(attribute, attribute.getName(), attribute.getType());\n+        }\n+        else if (type instanceof ChoiceType)\n+        {\n+            final ChoiceType choice = (ChoiceType)type;\n+            visitor.choiceType(choice, choice.getLHS(), choice.getRHS());\n+        }\n+        else if (type instanceof CommentNodeType)\n+        {\n+            final CommentNodeType comment = (CommentNodeType)type;\n+            visitor.textType(comment);\n+        }\n+        else if (type instanceof DocumentNodeType)\n+        {\n+            final DocumentNodeType document = (DocumentNodeType)type;\n+            visitor.documentType(document, document.getContentType());\n+        }\n+        else if (type instanceof ElementNodeType)\n+        {\n+            final ElementNodeType element = (ElementNodeType)type;\n+            visitor.elementType(element,\n+element.getName(),\n+element.getType(),\n+element.isNillable());\n+        }\n+        else if (type instanceof EmptyType)\n+        {\n+            final EmptyType emptyType = (EmptyType)type;\n+            visitor.emptyType(emptyType);\n+        }\n+        else if (type instanceof MultiplyType)\n+        {\n+            final MultiplyType multiply = (MultiplyType)type;\n+            visitor.multiplyType(multiply, multiply.getArgument(), multiply.getMultiplier());\n+        }\n+        else if (type instanceof NamespaceNodeType)\n+        {\n+            final NamespaceNodeType namespace = (NamespaceNodeType)type;\n+            visitor.namespaceType(namespace);\n+        }\n+        else if (type instanceof NoneType)\n+        {\n+            final NoneType errorType = (NoneType)type;\n+            visitor.noneType(errorType);\n+        }\n+        else if (type instanceof ProcessingInstructionNodeType)\n+        {\n+            final ProcessingInstructionNodeType pi = (ProcessingInstructionNodeType)type;\n+            visitor.processingInstructionType(pi, pi.getName());\n+        }\n+        else if (type instanceof TextNodeType)\n+        {\n+            final TextNodeType text = (TextNodeType)type;\n+            visitor.textType(text);\n+        }\n+        else\n+        {\n+            throw new UnsupportedOperationException(\"accept(\" + type.getClass().getName() + \")\");\n+        }\n+    }\n+\n+    @Override\n+    public SequenceType ancestorAxis(final SequenceType type)\n+    {\n+        final PrimeType prime = type.prime();\n+\n+        switch (prime.getKind())\n+        {\n+            case CHOICE:\n+            {\n+                final PrimeChoiceType choiceType = (PrimeChoiceType)prime;\n+                return multiply(choice(ancestorAxis(choiceType.getLHS()), ancestorAxis(choiceType.getRHS())), type.quantifier());\n+            }\n+            case DOCUMENT:\n+            {\n+                return emptyType();\n+            }\n+            case ELEMENT:\n+            case SCHEMA_ELEMENT:\n+            case ATTRIBUTE:\n+            case SCHEMA_ATTRIBUTE:\n+            case COMMENT:\n+            case NAMESPACE:\n+            case PROCESSING_INSTRUCTION:\n+            case TEXT:\n+            {\n+                return multiply(choice(documentType(null), zeroOrMore(elementType(null, null, true))), type.quantifier());\n+            }\n+            case NONE:\n+            {\n+                return noneType();\n+            }\n+            default:\n+            {\n+                return emptyType();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public SequenceType ancestorOrSelfAxis(final SequenceType contextType)\n+    {\n+        return zeroOrMore(nodeType());\n+    }\n+\n+    @Override\n+    public SequenceType atomSet(final SequenceType type)\n+    {\n+        if (type instanceof SimpleType)\n+        {\n+            return (SimpleType)type;\n+        }\n+        else\n+        {\n+            return zeroOrMore(BuiltInSchema.SINGLETON.ANY_ATOMIC_TYPE);\n+        }\n+    }\n+\n+    @Override\n+    public SequenceType attributeAxis(final SequenceType type)\n+    {\n+        final PrimeType prime = type.prime();\n+\n+        switch (prime.getKind())\n+        {\n+            case CHOICE:\n+            {\n+                final PrimeChoiceType choiceType = (PrimeChoiceType)prime;\n+                return multiply(choice(attributeAxis(choiceType.getLHS()), attributeAxis(choiceType.getRHS())), type.quantifier());\n+            }\n+            case ELEMENT:\n+            {\n+                return attributeWild(BuiltInSchema.SINGLETON.UNTYPED_ATOMIC);\n+            }\n+            case SCHEMA_ELEMENT:\n+            {\n+                final ElementDefinition elementDecl = (ElementDefinition)prime;\n+                final Type smType = elementDecl.getType();\n+                if (smType instanceof ComplexType)\n+                {\n+                    final ComplexType complexType = (ComplexType)smType;\n+                    return attributeAxisFromComplexType(complexType, elementDecl);\n+                }\n+                else if (smType instanceof SimpleType)\n+                {\n+                    return emptyType();\n+                }\n+                else\n                 {\r\n-                    return emptyType();\r\n-                }\r\n-                else\r\n+                    // The type must be either a simple or a complex type.\n+                    throw new AssertionError();\n+                }\n+            }\n+            case COMPLEX:\n+            {\n+                final ComplexType complexType = (ComplexType)prime;\n+                return attributeAxisFromComplexType(complexType, null);\n+            }\n+            case NONE:\n+            {\n+                return noneType();\n+            }\n+            default:\n+            {\n+                return emptyType();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public AttributeNodeType attributeType(final QName name, final SequenceType type)\n+    {\n+        if (name != null)\n+            return new AttributeNodeTypeImpl(name, type);\n+        return attributeWild(type);\n+    }\n+\n+    @Override\n+    public AttributeNodeType attributeWild(SequenceType type)\n+    {\n+        return new AttributeNodeTypeImpl(WILDNAME, type);\n+    }\n+\n+    @Override\n+    public SequenceType childAxis(final SequenceType type)\n+    {\n+        final PrimeType prime = type.prime();\n+\n+        switch (prime.getKind())\n+        {\n+            case CHOICE:\n+            {\n+                final PrimeChoiceType choiceType = (PrimeChoiceType)prime;\n+                return multiply(choice(childAxis(choiceType.getLHS()),\n+                    childAxis(choiceType.getRHS())), type.quantifier());\n+            }\n+            case DOCUMENT:\n+            {\n+                final DocumentNodeType documentNodeType = (DocumentNodeType)prime;\n+                final SequenceType contentType = documentNodeType.getContentType();\n+                if (null != contentType)\n+                {\n+                    return contentType;\n+                }\n+                else\n+                {\n+                    final ElementNodeType elementType = elementWild(null, true);\n+                    final TextNodeType textType = textType();\n+                    final CommentNodeType commentType = commentType();\n+                    final ProcessingInstructionNodeType processingInstructionType = processingInstructionType(null);\n+                    return multiply(zeroOrMore(choice(elementType, choice(textType, choice(commentType, processingInstructionType)))), type.quantifier());\n+                }\n+            }\n+            case ELEMENT:\n+            {\n+                final ElementNodeType element = (ElementNodeType)prime;\n+                final SequenceType dataType = element.getType();\n+                if (subtype(dataType, zeroOrMore(nodeType())))\n+                {\n+                    return dataType;\n+                }\n+                else\n+                {\n+                    final PrimeType elementType = elementWild(null, true);\n+                    final TextNodeType textType = textType();\n+                    final CommentNodeType commentType = commentType();\n+                    final ProcessingInstructionNodeType processingInstructionType = processingInstructionType(null);\n+                    return multiply(zeroOrMore(choice(elementType, choice(textType, choice(commentType, processingInstructionType)))), type.quantifier());\n+                }\n+            }\n+            case SCHEMA_ELEMENT:\n+            {\n+                final ElementDefinition elementDecl = (ElementDefinition)prime;\n+                final Type t = elementDecl.getType();\n+                if (t instanceof ComplexType)\n+                {\n+                    final ComplexType complexType = (ComplexType)t;\n+                    return childAxisFromComplexType(complexType, elementDecl);\n+                }\n+                else if (t instanceof SimpleType)\n+                {\n+                    return emptyType();\n+                }\n+                else\n                 {\r\n-                    // The type must be either a simple or a complex type.\r\n-                    throw new AssertionError();\r\n-                }\r\n-            }\r\n-            case COMPLEX:\r\n-            {\r\n-                final ComplexType complexType = (ComplexType) prime;\r\n-                return attributeAxisFromComplexType(complexType, null);\r\n-            }\r\n-            case NONE:\r\n-            {\r\n-                return noneType();\r\n-            }\r\n-            default:\r\n-            {\r\n-                return emptyType();\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public AttributeNodeType attributeType(final QName name, final SequenceType type)\r\n-    {\r\n-        if (name != null)\r\n-            return new AttributeNodeTypeImpl(name, type);\r\n-        return attributeWild(type);\r\n-    }\r\n-\r\n-    @Override\r\n-    public AttributeNodeType attributeWild(SequenceType type)\r\n-    {\r\n-        return new AttributeNodeTypeImpl(WILDNAME, type);\r\n-    }\r\n-\r\n-    @Override\r\n-    public SequenceType childAxis(final SequenceType type)\r\n-    {\r\n-        final PrimeType prime = type.prime();\r\n-        switch (prime.getKind())\r\n-        {\r\n-            case CHOICE:\r\n-            {\r\n-                final PrimeChoiceType choiceType = (PrimeChoiceType) prime;\r\n-                return multiply(choice(childAxis(choiceType.getLHS()), childAxis(choiceType.getRHS())), type.quantifier());\r\n-            }\r\n-            case DOCUMENT:\r\n-            {\r\n-                final DocumentNodeType documentNodeType = (DocumentNodeType) prime;\r\n-                final SequenceType contentType = documentNodeType.getContentType();\r\n-                if (null != contentType)\r\n-                {\r\n-                    return contentType;\r\n-                }\r\n-                else\r\n-                {\r\n-                    final ElementNodeType elementType = elementWild(null, true);\r\n-                    final TextNodeType textType = textType();\r\n-                    final CommentNodeType commentType = commentType();\r\n-                    final ProcessingInstructionNodeType processingInstructionType = processingInstructionType(null);\r\n-\r\n-                    return multiply(zeroOrMore(choice(elementType, choice(textType, choice(commentType, processingInstructionType)))), type.quantifier());\r\n-                }\r\n-            }\r\n-            case ELEMENT:\r\n-            {\r\n-                final ElementNodeType element = (ElementNodeType) prime;\r\n-                final SequenceType dataType = element.getType();\r\n-                if (subtype(dataType, zeroOrMore(nodeType())))\r\n-                {\r\n-                    return dataType;\r\n-                }\r\n-                else\r\n-                {\r\n-                    final PrimeType elementType = elementWild(null, true);\r\n-                    final TextNodeType textType = textType();\r\n-                    final CommentNodeType commentType = commentType();\r\n-                    final ProcessingInstructionNodeType processingInstructionType = processingInstructionType(null);\r\n-\r\n-                    return multiply(zeroOrMore(choice(elementType, choice(textType, choice(commentType, processingInstructionType)))), type.quantifier());\r\n-                }\r\n-            }\r\n-            case SCHEMA_ELEMENT:\r\n-            {\r\n-                final ElementDefinition elementDecl = (ElementDefinition) prime;\r\n-                final Type t = elementDecl.getType();\r\n-                if (t instanceof ComplexType)\r\n-                {\r\n-                    final ComplexType complexType = (ComplexType) t;\r\n-                    return childAxisFromComplexType(complexType, elementDecl);\r\n-                }\r\n-                else if (t instanceof SimpleType)\r\n-                {\r\n-                    return emptyType();\r\n-                }\r\n-                else\r\n-                {\r\n-                    // The type must be either a simple or a complex type.\r\n-                    throw new AssertionError();\r\n-                }\r\n-            }\r\n-            case COMPLEX:\r\n-            {\r\n-                // TODO: This appears to be unreachable...\r\n-                final ComplexType complexType = (ComplexType) prime;\r\n-                return childAxisFromComplexType(complexType, null);\r\n-            }\r\n-            case NONE:\r\n-            {\r\n-                return noneType();\r\n-            }\r\n-            default:\r\n-            {\r\n-                return emptyType();\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public SequenceType choice(final SequenceType one, final SequenceType two)\r\n-    {\r\n-        return ZChoiceType.choice(one, two);\r\n-    }\r\n-\r\n-    @Override\r\n-    public SequenceType commentTest(final SequenceType arg)\r\n-    {\r\n-        final PrimeType primeType = arg.prime();\r\n-        switch (primeType.getKind())\r\n-        {\r\n-            case CHOICE:\r\n-            {\r\n-                final PrimeChoiceType choiceType = (PrimeChoiceType)primeType;\r\n-\r\n-                return multiply(choice(commentTest(choiceType.getLHS()), commentTest(choiceType.getRHS())), arg.quantifier());\r\n-            }\r\n-            case COMMENT:\r\n-            {\r\n-                return arg;\r\n-            }\r\n-            case NONE:\r\n-            {\r\n-                return noneType();\r\n-            }\r\n-            default:\r\n-            {\r\n-                return emptyType();\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public CommentNodeType commentType()\r\n-    {\r\n-        return COMMENT;\r\n-    }\r\n-\r\n-    @Override\r\n-    public SequenceType concat(final SequenceType lhs, final SequenceType rhs)\r\n-    {\r\n-        return ZConcatType.concat(lhs, rhs);\r\n-    }\r\n-\r\n-    @Override\r\n-    public SequenceType contentType(final SequenceType type)\r\n-    {\r\n-        if (type instanceof DocumentNodeType)\r\n-        {\r\n-            return ((DocumentNodeType)type).getContentType();\r\n-        }\r\n-        else\r\n+                    // The type must be either a simple or a complex type.\n+                    throw new AssertionError();\n+                }\n+            }\n+            case COMPLEX:\n+            {\r\n+                // TODO: This appears to be unreachable...\n+                final ComplexType complexType = (ComplexType)prime;\n+                return childAxisFromComplexType(complexType, null);\n+            }\n+            case NONE:\n+            {\n+                return noneType();\n+            }\n+            default:\n+            {\n+                return emptyType();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public SequenceType choice(final SequenceType one, final SequenceType two)\n+    {\n+        return ZChoiceType.choice(one, two);\n+    }\n+\n+    @Override\n+    public SequenceType commentTest(final SequenceType arg)\n+    {\n+        final PrimeType primeType = arg.prime();\n+\n+        switch (primeType.getKind())\n+        {\n+            case CHOICE:\n+            {\n+                final PrimeChoiceType choiceType = (PrimeChoiceType)primeType;\n+                return multiply(choice(commentTest(choiceType.getLHS()), commentTest(choiceType.getRHS())), arg.quantifier());\n+            }\n+            case COMMENT:\n+            {\n+                return arg;\n+            }\n+            case NONE:\n+            {\n+                return noneType();\n+            }\n+            default:\n+            {\n+                return emptyType();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public CommentNodeType commentType()\n+    {\n+        return COMMENT;\n+    }\n+\n+    @Override\n+    public SequenceType concat(final SequenceType lhs, final SequenceType rhs)\n+    {\n+        return ZConcatType.concat(lhs, rhs);\n+    }\n+\n+    @Override\n+    public SequenceType contentType(final SequenceType type)\n+    {\n+        if (type instanceof DocumentNodeType)\n+        {\n+            return ((DocumentNodeType)type).getContentType();\n+        }\n+        else\n         {\r\n             // TODO: errr ... WTF is going on here? I can't tell whether this is\r\n             // appropriate or not. there's a method on TypesBridge that only applies to\r\n-            // DocumentNodeType? Really? And it can't be in the argument? Really really?\r\n-            throw new AssertionError(type);\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public SequenceType descendantAxis(final SequenceType type)\r\n-    {\r\n-        final PrimeType prime = type.prime();\r\n-        switch (prime.getKind())\r\n-        {\r\n-            case CHOICE:\r\n-            {\r\n-                final PrimeChoiceType choiceType = (PrimeChoiceType)prime;\r\n-                return multiply(choice(descendantAxis(choiceType.getLHS()), descendantAxis(choiceType.getRHS())), type.quantifier());\r\n-            }\r\n-            case DOCUMENT:\r\n-            case ELEMENT:\r\n-            {\r\n-                final ElementNodeType elementType = elementWild(null, true);\r\n-                final TextNodeType textType = textType();\r\n-                final CommentNodeType commentType = commentType();\r\n-                final ProcessingInstructionNodeType processingInstructionType = processingInstructionType(null);\r\n-\r\n-                return multiply(zeroOrMore(choice(elementType, choice(textType, choice(commentType, processingInstructionType)))), type.quantifier());\r\n-            }\r\n-            case SCHEMA_ELEMENT:\r\n-            {\r\n-                final ElementNodeType elementType = elementWild(null, true);\r\n-                final TextNodeType textType = textType();\r\n-                final CommentNodeType commentType = commentType();\r\n-                final ProcessingInstructionNodeType processingInstructionType = processingInstructionType(null);\r\n-\r\n-                return multiply(zeroOrMore(choice(elementType, choice(textType, choice(commentType, processingInstructionType)))), type.quantifier());\r\n-            }\r\n-            case NONE:\r\n-            {\r\n-                return noneType();\r\n-            }\r\n-            default:\r\n-            {\r\n-                return emptyType();\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public SequenceType descendantOrSelfAxis(final SequenceType type)\r\n-    {\r\n-        final PrimeType prime = type.prime();\r\n-        switch (prime.getKind())\r\n-        {\r\n-            case CHOICE:\r\n-            {\r\n-                final PrimeChoiceType choiceType = (PrimeChoiceType)prime;\r\n-                return multiply(choice(descendantOrSelfAxis(choiceType.getLHS()), descendantOrSelfAxis(choiceType.getRHS())), type.quantifier());\r\n-            }\r\n-            case ELEMENT:\r\n-            case SCHEMA_ELEMENT:\r\n-            case DOCUMENT:\r\n-            {\r\n-                final SequenceType kids = branchChildAxis();\r\n-                return multiply(choice(kids, prime), type.quantifier());\r\n-            }\r\n-            case ATTRIBUTE:\r\n-            case SCHEMA_ATTRIBUTE:\r\n-            case COMMENT:\r\n-            case NAMESPACE:\r\n-            case PROCESSING_INSTRUCTION:\r\n-            case TEXT:\r\n-            {\r\n-                return type;\r\n-            }\r\n-            case NONE:\r\n-            {\r\n-                return noneType();\r\n-            }\r\n-            default:\r\n-            {\r\n-                return emptyType();\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public DocumentNodeType documentType(final SequenceType contentType)\r\n-    {\r\n-        if (contentType != null)\r\n-            return new DocumentNodeTypeImpl(contentType);\r\n-        return DOCUMENT;\r\n-    }\r\n-\r\n-    @Override\r\n-    public SequenceType elementTest(final SequenceType arg)\r\n-    {\r\n-        final PrimeType primeType = arg.prime();\r\n-        switch (primeType.getKind())\r\n-        {\r\n-            case CHOICE:\r\n-            {\r\n-                final PrimeChoiceType choiceType = (PrimeChoiceType)primeType;\r\n-\r\n-                return multiply(choice(elementTest(choiceType.getLHS()), elementTest(choiceType.getRHS())), arg.quantifier());\r\n-            }\r\n-            case ELEMENT:\r\n-            case SCHEMA_ELEMENT:\r\n-            {\r\n-                return arg;\r\n-            }\r\n-            default:\r\n-            {\r\n-                return emptyType();\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public ElementNodeType elementType(final QName name, final SequenceType type, final boolean nillable)\r\n-    {\r\n-        if (name != null)\r\n-            return new ElementNodeTypeImpl(name, type, nillable);\r\n-        return elementWild(type, nillable);\r\n-    }\r\n-\r\n-    @Override\r\n-    public ElementNodeType elementWild(SequenceType type, boolean nillable)\r\n-    {\r\n-        return new ElementNodeTypeImpl(WILDNAME, type, nillable);\r\n-    }\r\n-\r\n-    @Override\r\n-    public EmptyType emptyType()\r\n-    {\r\n-        return EMPTY;\r\n-    }\r\n-\r\n-    @Override\r\n-    public SequenceType followingAxis(final SequenceType contextType)\r\n-    {\r\n-        return zeroOrMore(nodeType());\r\n-    }\r\n-\r\n-    @Override\r\n-    public SequenceType followingSiblingAxis(final SequenceType type)\r\n-    {\r\n-        final PrimeType prime = type.prime();\r\n-        switch (prime.getKind())\r\n-        {\r\n-            case CHOICE:\r\n-            {\r\n-                final PrimeChoiceType choiceType = (PrimeChoiceType)prime;\r\n-                return multiply(choice(followingSiblingAxis(choiceType.getLHS()), followingSiblingAxis(choiceType.getRHS())), type.quantifier());\r\n-            }\r\n-            case ATTRIBUTE:\r\n-            {\r\n-                return multiply(zeroOrMore(attributeType(null, BuiltInSchema.SINGLETON.UNTYPED_ATOMIC)), type.quantifier());\r\n-            }\r\n-            case SCHEMA_ATTRIBUTE:\r\n-            {\r\n-                // TODO: This should come from the complex type, if it exists (otherwise empty).\r\n-                return multiply(zeroOrMore(attributeType(null, null)), type.quantifier());\r\n-            }\r\n-            case NAMESPACE:\r\n-            {\r\n-                return multiply(zeroOrMore(namespaceType()), type.quantifier());\r\n-            }\r\n-            case DOCUMENT:\r\n-            {\r\n-                return emptyType();\r\n-            }\r\n-            case ELEMENT:\r\n-            case SCHEMA_ELEMENT:\r\n-            case COMMENT:\r\n-            case PROCESSING_INSTRUCTION:\r\n-            case TEXT:\r\n-            {\r\n-                final ElementNodeType elementType = elementWild(null, true);\r\n-                final TextNodeType textType = textType();\r\n-                final CommentNodeType commentType = commentType();\r\n-                final ProcessingInstructionNodeType processingInstructionType = processingInstructionType(null);\r\n-\r\n-                return multiply(zeroOrMore(choice(elementType, choice(textType, choice(commentType, processingInstructionType)))), type.quantifier());\r\n-            }\r\n-            case NONE:\r\n-            {\r\n-                return noneType();\r\n-            }\r\n-            default:\r\n-            {\r\n-                return emptyType();\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public SequenceType getBinaryLHS(final SequenceType type)\r\n-    {\r\n-        if (type instanceof ChoiceType)\r\n-        {\r\n-            final ChoiceType choice = (ChoiceType)type;\r\n-            return choice.getLHS();\r\n-        }\r\n-        else\r\n-        {\r\n-            // TODO: implement?\r\n-            throw new UnsupportedOperationException(\"getBinaryLHS(\" + type.getClass() + \")\");\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public SequenceType getBinaryRHS(final SequenceType type)\r\n-    {\r\n-        if (type instanceof ChoiceType)\r\n-        {\r\n-            final ChoiceType choice = (ChoiceType)type;\r\n-            return choice.getRHS();\r\n-        }\r\n-        else\r\n-        {\r\n-            // TODO: implement?\r\n-            throw new UnsupportedOperationException(\"getBinaryRHS(\" + type.getClass() + \")\");\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public QName getErrorCode(final SequenceType noneType)\r\n-    {\r\n-        if (noneType instanceof NoneType)\r\n-        {\r\n-            final NoneType error = (NoneType)noneType;\r\n-            return error.getErrorCode();\r\n-        }\r\n-        else\r\n-        {\r\n-            PreCondition.assertArgumentNotNull(noneType, \"noneType\");\r\n-            PreCondition.assertTrue(isNone(noneType), \"isNone(noneType)\");\r\n-            throw new AssertionError();\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public QName getName(final SequenceType type)\r\n-    {\r\n-        if (type instanceof Type)\r\n-        {\r\n-            final Type itemType = (Type) type;\r\n-            return itemType.getName();\r\n-        }\r\n-        else if (type instanceof AttributeDefinition)\r\n-        {\r\n-            final AttributeDefinition attType = (AttributeDefinition) type;\r\n-            return attType.getName();\r\n-        }\r\n-        else if (type instanceof AttributeNodeType)\r\n-        {\r\n-            final AttributeNodeType attributeNodeType = (AttributeNodeType) type;\r\n-            return attributeNodeType.getName();\r\n-        }\r\n-        else if (type instanceof ElementNodeType)\r\n-        {\r\n-            final ElementNodeType elementNodeType = (ElementNodeType) type;\r\n-            return elementNodeType.getName();\r\n-        }\r\n-        else\r\n-        {\r\n-            throw new AssertionError(\"getName(\" + type.getClass() + \")\");\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public SequenceType handle(final SequenceType sequenceType)\r\n-    {\r\n-        return sequenceType;\r\n-    }\r\n-\r\n-    @Override\r\n-    public SequenceType interleave(final SequenceType one, final SequenceType two)\r\n-    {\r\n-        return ZInterleaveType.interleave(one, two);\r\n-    }\r\n-\r\n-    @Override\r\n-    public boolean isAttributeNodeType(final SequenceType type)\r\n-    {\r\n-        return type instanceof AttributeNodeType;\r\n-    }\r\n-\r\n-    @Override\r\n-    public boolean isChoice(final SequenceType type)\r\n-    {\r\n-        return (type instanceof ChoiceType);\r\n-    }\r\n-\r\n-    @Override\r\n-    public boolean isCommentNodeType(final SequenceType type)\r\n-    {\r\n-        return type instanceof CommentNodeType;\r\n-    }\r\n-\r\n-    @Override\r\n-    public boolean isDocumentNodeType(final SequenceType type)\r\n-    {\r\n-        return type instanceof DocumentNodeType;\r\n-    }\r\n-\r\n-    @Override\r\n-    public boolean isElementNodeType(final SequenceType type)\r\n-    {\r\n-        return (type instanceof ElementNodeType);\r\n-    }\r\n-\r\n-    @Override\r\n-    public boolean isEmpty(final SequenceType type)\r\n-    {\r\n-        return type instanceof EmptyType;\r\n-    }\r\n-\r\n-    @Override\r\n-    public boolean isNamespaceNodeType(final SequenceType type)\r\n-    {\r\n-        return type instanceof NamespaceNodeType;\r\n-    }\r\n-\r\n-    @Override\r\n-    public boolean isNone(final SequenceType type)\r\n-    {\r\n-        return (type instanceof NoneType);\r\n-    }\r\n-\r\n-    @Override\r\n-    public boolean isProcessingInstructionNodeType(final SequenceType type)\r\n-    {\r\n-        return type instanceof ProcessingInstructionNodeType;\r\n-    }\r\n-\r\n-    @Override\r\n-    public boolean isTextNodeType(final SequenceType type)\r\n-    {\r\n-        return type instanceof TextNodeType;\r\n-    }\r\n-\r\n-    @Override\r\n-    public PrimeType itemType()\r\n-    {\r\n-        return ANY_ITEM;\r\n-    }\r\n-\r\n-    @Override\r\n-    public SequenceType multiply(final SequenceType argument, final Quantifier multiplier)\r\n-    {\r\n-        PreCondition.assertArgumentNotNull(argument, \"argument\");\r\n-        if (null != argument)\r\n-        {\r\n-            if (sameAs(argument, emptyType()))\r\n-            {\r\n-                return argument;\r\n-            }\r\n-            else if (sameAs(argument, noneType()))\r\n-            {\r\n-                return argument;\r\n-            }\r\n-            else if (multiplier.isExactlyOne())\r\n-            {\r\n-                return argument;\r\n-            }\r\n-            else\r\n-            {\r\n-                return ZMultiplyType.multiply(argument, multiplier);\r\n-            }\r\n-        }\r\n-        else\r\n-        {\r\n-            // TODO: We need to assert that the type is not null. This is a patch.\r\n-            return null;\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public SequenceType namespaceAxis(final SequenceType contextType)\r\n-    {\r\n-        return zeroOrMore(nodeType());\r\n-    }\r\n-\r\n-    @Override\r\n-    public SequenceType namespaceTest(final SequenceType arg)\r\n-    {\r\n-        final PrimeType primeType = arg.prime();\r\n-        switch (primeType.getKind())\r\n-        {\r\n-            case CHOICE:\r\n-            {\r\n-                final PrimeChoiceType choiceType = (PrimeChoiceType)primeType;\r\n-\r\n-                return multiply(choice(namespaceTest(choiceType.getLHS()), namespaceTest(choiceType.getRHS())), arg.quantifier());\r\n-            }\r\n-            case NAMESPACE:\r\n-            {\r\n-                return arg;\r\n-            }\r\n-            default:\r\n-            {\r\n-                return emptyType();\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public NamespaceNodeType namespaceType()\r\n-    {\r\n-        return NAMESPACE;\r\n-    }\r\n-\r\n-    @Override\r\n-    public SequenceType nodeTest(final SequenceType arg)\r\n-    {\r\n-        final PrimeType primeType = arg.prime();\r\n-        switch (primeType.getKind())\r\n-        {\r\n-            case CHOICE:\r\n-            {\r\n-                final PrimeChoiceType choiceType = (PrimeChoiceType)primeType;\r\n-\r\n-                return multiply(choice(nodeTest(choiceType.getLHS()), nodeTest(choiceType.getRHS())), arg.quantifier());\r\n-            }\r\n-            case ATTRIBUTE:\r\n-            case SCHEMA_ATTRIBUTE:\r\n-            case COMMENT:\r\n-            case DOCUMENT:\r\n-            case ELEMENT:\r\n-            case SCHEMA_ELEMENT:\r\n-            case NAMESPACE:\r\n-            case PROCESSING_INSTRUCTION:\r\n-            case TEXT:\r\n-            case EMPTY:\r\n-            case ANY_ATOMIC_TYPE:\r\n-            case ATOM:\r\n-            {\r\n-                return arg;\r\n-            }\r\n-            case NONE:\r\n-            {\r\n-                return noneType();\r\n-            }\r\n-            default:\r\n-            {\r\n-                return emptyType();\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public PrimeType nodeType()\r\n-    {\r\n-        return ANY_KIND;\r\n-    }\r\n-\r\n-    @Override\r\n-    public NoneType noneType()\r\n-    {\r\n-        return new NoneTypeImpl();\r\n-    }\r\n-\r\n-    @Override\r\n-    public NoneType noneType(final QName errorCode)\r\n-    {\r\n-        return new NoneTypeImpl(errorCode);\r\n-    }\r\n-\r\n-    @Override\r\n-    public SequenceType oneOrMore(final SequenceType type)\r\n-    {\r\n-        return multiply(type, Quantifier.ONE_OR_MORE);\r\n-    }\r\n-\r\n-    @Override\r\n-    public SequenceType optional(final SequenceType type)\r\n-    {\r\n-        if (null != type)\r\n-        {\r\n-            return multiply(type, Quantifier.OPTIONAL);\r\n-        }\r\n-        else\r\n-        {\r\n-            return null;\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public SequenceType parentAxis(final SequenceType contextType)\r\n-    {\r\n-        return optional(nodeType());\r\n-    }\r\n-\r\n-    @Override\r\n-    public SequenceType precedingAxis(final SequenceType contextType)\r\n-    {\r\n-        return zeroOrMore(nodeType());\r\n-    }\r\n-\r\n-    @Override\r\n-    public SequenceType precedingSiblingAxis(final SequenceType type)\r\n-    {\r\n-        final PrimeType prime = type.prime();\r\n-        switch (prime.getKind())\r\n-        {\r\n-            case CHOICE:\r\n-            {\r\n-                final PrimeChoiceType choiceType = (PrimeChoiceType)prime;\r\n-                return multiply(choice(precedingSiblingAxis(choiceType.getLHS()), precedingSiblingAxis(choiceType.getRHS())), type.quantifier());\r\n-            }\r\n-            case ATTRIBUTE:\r\n-            {\r\n-                return multiply(zeroOrMore(attributeType(null, BuiltInSchema.SINGLETON.UNTYPED_ATOMIC)), type.quantifier());\r\n-            }\r\n-            case SCHEMA_ATTRIBUTE:\r\n-            {\r\n-                // TODO: This should come from the complex type, if it exists (otherwise empty).\r\n-                return multiply(zeroOrMore(attributeType(null, null)), type.quantifier());\r\n-            }\r\n-            case NAMESPACE:\r\n-            {\r\n-                return multiply(zeroOrMore(namespaceType()), type.quantifier());\r\n-            }\r\n-            case DOCUMENT:\r\n-            {\r\n-                return emptyType();\r\n-            }\r\n-            case ELEMENT:\r\n-            case SCHEMA_ELEMENT:\r\n-            case COMMENT:\r\n-            case PROCESSING_INSTRUCTION:\r\n-            case TEXT:\r\n-            {\r\n-                final ElementNodeType elementType = elementWild(null, true);\r\n-                final TextNodeType textType = textType();\r\n-                final CommentNodeType commentType = commentType();\r\n-                final ProcessingInstructionNodeType processingInstructionType = processingInstructionType(null);\r\n-\r\n-                return multiply(zeroOrMore(choice(elementType, choice(textType, choice(commentType, processingInstructionType)))), type.quantifier());\r\n-            }\r\n-            case NONE:\r\n-            {\r\n-                return noneType();\r\n-            }\r\n-            default:\r\n-            {\r\n-                return emptyType();\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public PrimeType prime(final SequenceType type)\r\n-    {\r\n-        return type.prime();\r\n-    }\r\n-\r\n-    @Override\r\n-    public SequenceType processingInstructionTest(final SequenceType arg, final String name)\r\n-    {\r\n-        final PrimeType primeType = arg.prime();\r\n-        switch (primeType.getKind())\r\n-        {\r\n-            case CHOICE:\r\n-            {\r\n-                final PrimeChoiceType choiceType = (PrimeChoiceType)primeType;\r\n-                return multiply(choice(processingInstructionTest(choiceType.getLHS(), name), processingInstructionTest(choiceType.getRHS(), name)), arg.quantifier());\r\n-            }\r\n-            case PROCESSING_INSTRUCTION:\r\n-            {\r\n-                return arg;\r\n-            }\r\n-            default:\r\n-            {\r\n-                return emptyType();\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public ProcessingInstructionNodeType processingInstructionType(final String name)\r\n-    {\r\n-        if (name != null)\r\n-            return new ProcessingInstructionNodeTypeImpl(name);\r\n-        return PROCESSING_INSTRUCTION;\r\n-    }\r\n-\r\n-    @Override\r\n-    public Quantifier quantifier(final SequenceType type)\r\n-    {\r\n-        return type.quantifier();\r\n-    }\r\n-\r\n-    @Override\r\n-    public boolean sameAs(final SequenceType one, final SequenceType two)\r\n-    {\r\n-        PreCondition.assertArgumentNotNull(one, \"one\");\r\n-        PreCondition.assertArgumentNotNull(two, \"two\");\r\n-        return subtype(one, two) && subtype(two, one);\r\n-    }\r\n-\r\n-    @Override\r\n-    public SequenceType selfAxis(final SequenceType type)\r\n-    {\r\n-        final PrimeType prime = type.prime();\r\n-        switch (prime.getKind())\r\n-        {\r\n-            case CHOICE:\r\n-            {\r\n-                final PrimeChoiceType choiceType = (PrimeChoiceType)prime;\r\n-                return multiply(choice(selfAxis(choiceType.getLHS()), selfAxis(choiceType.getRHS())), type.quantifier());\r\n-            }\r\n-            case EMPTY:\r\n-            case ATOM:\r\n-            case ANY_ATOMIC_TYPE:\r\n-            {\r\n-                return emptyType();\r\n-            }\r\n-            case NONE:\r\n-            {\r\n-                return noneType();\r\n-            }\r\n-            default:\r\n-            {\r\n-                return type;\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public boolean subtype(final SequenceType lhs, final SequenceType rhs)\r\n-    {\r\n-        PreCondition.assertArgumentNotNull(lhs, \"lhs\");\r\n-        PreCondition.assertArgumentNotNull(rhs, \"rhs\");\r\n-        return SchemaSupport.subtype(lhs, rhs);\r\n-    }\r\n-\r\n-    @Override\r\n-    public SequenceType textTest(final SequenceType arg)\r\n-    {\r\n-        final PrimeType primeType = arg.prime();\r\n-        switch (primeType.getKind())\r\n-        {\r\n-            case CHOICE:\r\n-            {\r\n-                final PrimeChoiceType choiceType = (PrimeChoiceType)primeType;\r\n-                return multiply(choice(textTest(choiceType.getLHS()), textTest(choiceType.getRHS())), arg.quantifier());\r\n-            }\r\n-            case TEXT:\r\n-            {\r\n-                return arg;\r\n-            }\r\n-            case NONE:\r\n-            {\r\n-                return arg;\r\n-            }\r\n-            default:\r\n-            {\r\n-                return emptyType();\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public TextNodeType textType()\r\n-    {\r\n-        return TEXT;\r\n-    }\r\n-\r\n-    @Override\r\n-    public String toString(final SequenceType type, final NamespaceResolver mappings, final String defaultElementAndTypeNamespace) throws GenXDMException\r\n-    {\r\n-        return type.toString();\r\n-    }\r\n-\r\n-    @Override\r\n-    public SequenceType[] typeArray(final int size)\r\n-    {\r\n-        return new SequenceType[size];\r\n-    }\r\n-\r\n-    @Override\r\n-    public SequenceType zeroOrMore(final SequenceType type)\r\n-    {\r\n-        return multiply(type, Quantifier.ZERO_OR_MORE);\r\n-    }\r\n-\r\n-    private SequenceType attributeAxisFromComplexType(final ComplexType complexType, final ElementDefinition parentAxis)\r\n-    {\r\n-        final ArrayList<AttributeUse> attributeUses = ensureAttributeUses(complexType);\r\n-        SequenceType result = null;\r\n-        for (final AttributeUse attributeUse : attributeUses)\r\n-        {\r\n-            final SequenceType attributeType = attributeUseType(attributeUse, parentAxis);\r\n-            if (result == null)\r\n-            {\r\n-                result = attributeType;\r\n-            }\r\n-            else\r\n-            {\r\n-                result = interleave(result, attributeType);\r\n-            }\r\n-        }\r\n-        return result == null ? emptyType() : result;\r\n-    }\r\n-\r\n-    private SequenceType attributeUseType(final AttributeUse attributeUse, final ElementDefinition parentAxis)\r\n-    {\r\n-        final AttributeDefinition attribute = attributeUse.getAttribute();\r\n-        if (null != parentAxis)\r\n-        {\r\n-            return multiply(new AttributeDeclWithParentAxisType(attribute, parentAxis), attributeUse.isRequired() ? Quantifier.EXACTLY_ONE : Quantifier.OPTIONAL);\r\n-        }\r\n-        else\r\n-        {\r\n-            return multiply(attribute, attributeUse.isRequired() ? Quantifier.EXACTLY_ONE : Quantifier.OPTIONAL);\r\n-        }\r\n-    }\r\n-\r\n-    private SequenceType branchChildAxis()\r\n-    {\r\n-        final ElementNodeType elementType = elementWild(null, true);\r\n-        final TextNodeType textType = textType();\r\n-        final CommentNodeType commentType = commentType();\r\n-        final ProcessingInstructionNodeType processingInstructionType = processingInstructionType(null);\r\n-\r\n-        return zeroOrMore(choice(elementType, choice(textType, choice(commentType, processingInstructionType))));\r\n+            // DocumentNodeType? Really? And it can't be in the argument? Really really?\n+            throw new AssertionError(type);\n+        }\n+    }\n+\n+    @Override\n+    public SequenceType descendantAxis(final SequenceType type)\n+    {\n+        final PrimeType prime = type.prime();\n+\n+        switch (prime.getKind())\n+        {\n+            case CHOICE:\n+            {\n+                final PrimeChoiceType choiceType = (PrimeChoiceType)prime;\n+                return multiply(choice(descendantAxis(choiceType.getLHS()), descendantAxis(choiceType.getRHS())), type.quantifier());\n+            }\n+            case DOCUMENT:\n+            case ELEMENT:\n+            {\n+                final ElementNodeType elementType = elementWild(null, true);\n+                final TextNodeType textType = textType();\n+                final CommentNodeType commentType = commentType();\n+                final ProcessingInstructionNodeType processingInstructionType = processingInstructionType(null);\n+                return multiply(zeroOrMore(choice(elementType, choice(textType, choice(commentType, processingInstructionType)))), type.quantifier());\n+            }\n+            case SCHEMA_ELEMENT:\n+            {\n+                final ElementNodeType elementType = elementWild(null, true);\n+                final TextNodeType textType = textType();\n+                final CommentNodeType commentType = commentType();\n+                final ProcessingInstructionNodeType processingInstructionType = processingInstructionType(null);\n+                return multiply(zeroOrMore(choice(elementType, choice(textType, choice(commentType, processingInstructionType)))), type.quantifier());\n+            }\n+            case NONE:\n+            {\n+                return noneType();\n+            }\n+            default:\n+            {\n+                return emptyType();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public SequenceType descendantOrSelfAxis(final SequenceType type)\n+    {\n+        final PrimeType prime = type.prime();\n+\n+        switch (prime.getKind())\n+        {\n+            case CHOICE:\n+            {\n+                final PrimeChoiceType choiceType = (PrimeChoiceType)prime;\n+                return multiply(choice(descendantOrSelfAxis(choiceType.getLHS()), descendantOrSelfAxis(choiceType.getRHS())), type.quantifier());\n+            }\n+            case ELEMENT:\n+            case SCHEMA_ELEMENT:\n+            case DOCUMENT:\n+            {\n+                final SequenceType kids = branchChildAxis();\n+                return multiply(choice(kids, prime), type.quantifier());\n+            }\n+            case ATTRIBUTE:\n+            case SCHEMA_ATTRIBUTE:\n+            case COMMENT:\n+            case NAMESPACE:\n+            case PROCESSING_INSTRUCTION:\n+            case TEXT:\n+            {\n+                return type;\n+            }\n+            case NONE:\n+            {\n+                return noneType();\n+            }\n+            default:\n+            {\n+                return emptyType();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public DocumentNodeType documentType(final SequenceType contentType)\n+    {\n+        if (contentType != null)\n+            return new DocumentNodeTypeImpl(contentType);\n+        return DOCUMENT;\n+    }\n+\n+    @Override\n+    public SequenceType elementTest(final SequenceType arg)\n+    {\n+        final PrimeType primeType = arg.prime();\n+\n+        switch (primeType.getKind())\n+        {\n+            case CHOICE:\n+            {\n+                final PrimeChoiceType choiceType = (PrimeChoiceType)primeType;\n+                return multiply(choice(elementTest(choiceType.getLHS()), elementTest(choiceType.getRHS())), arg.quantifier());\n+            }\n+            case ELEMENT:\n+            case SCHEMA_ELEMENT:\n+            {\n+                return arg;\n+            }\n+            default:\n+            {\n+                return emptyType();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public ElementNodeType elementType(final QName name, final SequenceType type, final boolean nillable)\n+    {\n+        if (name != null)\n+            return new ElementNodeTypeImpl(name, type, nillable);\n+        return elementWild(type, nillable);\n+    }\n+\n+    @Override\n+    public ElementNodeType elementWild(SequenceType type, boolean nillable)\n+    {\n+        return new ElementNodeTypeImpl(WILDNAME, type, nillable);\n+    }\n+\n+    @Override\n+    public EmptyType emptyType()\n+    {\n+        return EMPTY;\n+    }\n+\n+    @Override\n+    public SequenceType followingAxis(final SequenceType contextType)\n+    {\n+        return zeroOrMore(nodeType());\n+    }\n+\n+    @Override\n+    public SequenceType followingSiblingAxis(final SequenceType type)\n+    {\n+        final PrimeType prime = type.prime();\n+\n+        switch (prime.getKind())\n+        {\n+            case CHOICE:\n+            {\n+                final PrimeChoiceType choiceType = (PrimeChoiceType)prime;\n+                return multiply(choice(followingSiblingAxis(choiceType.getLHS()), followingSiblingAxis(choiceType.getRHS())), type.quantifier());\n+            }\n+            case ATTRIBUTE:\n+            {\n+                return multiply(zeroOrMore(attributeType(null, BuiltInSchema.SINGLETON.UNTYPED_ATOMIC)), type.quantifier());\n+            }\n+            case SCHEMA_ATTRIBUTE:\n+            {\r\n+                // TODO: This should come from the complex type, if it exists (otherwise empty).\n+                return multiply(zeroOrMore(attributeType(null, null)), type.quantifier());\n+            }\n+            case NAMESPACE:\n+            {\n+                return multiply(zeroOrMore(namespaceType()), type.quantifier());\n+            }\n+            case DOCUMENT:\n+            {\n+                return emptyType();\n+            }\n+            case ELEMENT:\n+            case SCHEMA_ELEMENT:\n+            case COMMENT:\n+            case PROCESSING_INSTRUCTION:\n+            case TEXT:\n+            {\n+                final ElementNodeType elementType = elementWild(null, true);\n+                final TextNodeType textType = textType();\n+                final CommentNodeType commentType = commentType();\n+                final ProcessingInstructionNodeType processingInstructionType = processingInstructionType(null);\n+                return multiply(zeroOrMore(choice(elementType, choice(textType, choice(commentType, processingInstructionType)))), type.quantifier());\n+            }\n+            case NONE:\n+            {\n+                return noneType();\n+            }\n+            default:\n+            {\n+                return emptyType();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public SequenceType getBinaryLHS(final SequenceType type)\n+    {\n+        if (type instanceof ChoiceType)\n+        {\n+            final ChoiceType choice = (ChoiceType)type;\n+            return choice.getLHS();\n+        }\n+        else\n+        {\r\n+            // TODO: implement?\n+            throw new UnsupportedOperationException(\"getBinaryLHS(\" + type.getClass() + \")\");\n+        }\n+    }\n+\n+    @Override\n+    public SequenceType getBinaryRHS(final SequenceType type)\n+    {\n+        if (type instanceof ChoiceType)\n+        {\n+            final ChoiceType choice = (ChoiceType)type;\n+            return choice.getRHS();\n+        }\n+        else\n+        {\r\n+            // TODO: implement?\n+            throw new UnsupportedOperationException(\"getBinaryRHS(\" + type.getClass() + \")\");\n+        }\n+    }\n+\n+    @Override\n+    public QName getErrorCode(final SequenceType noneType)\n+    {\n+        if (noneType instanceof NoneType)\n+        {\n+            final NoneType error = (NoneType)noneType;\n+            return error.getErrorCode();\n+        }\n+        else\n+        {\n+            PreCondition.assertArgumentNotNull(noneType, \"noneType\");\n+            PreCondition.assertTrue(isNone(noneType), \"isNone(noneType)\");\n+            throw new AssertionError();\n+        }\n+    }\n+\n+    @Override\n+    public QName getName(final SequenceType type)\n+    {\n+        if (type instanceof Type)\n+        {\n+            final Type itemType = (Type)type;\n+            return itemType.getName();\n+        }\n+        else if (type instanceof AttributeDefinition)\n+        {\n+            final AttributeDefinition attType = (AttributeDefinition)type;\n+            return attType.getName();\n+        }\n+        else if (type instanceof AttributeNodeType)\n+        {\n+            final AttributeNodeType attributeNodeType = (AttributeNodeType)type;\n+            return attributeNodeType.getName();\n+        }\n+        else if (type instanceof ElementNodeType)\n+        {\n+            final ElementNodeType elementNodeType = (ElementNodeType)type;\n+            return elementNodeType.getName();\n+        }\n+        else\n+        {\n+            throw new AssertionError(\"getName(\" + type.getClass() + \")\");\n+        }\n+    }\n+\n+    @Override\n+    public SequenceType handle(final SequenceType sequenceType)\n+    {\n+        return sequenceType;\n+    }\n+\n+    @Override\n+    public SequenceType interleave(final SequenceType one, final SequenceType two)\n+    {\n+        return ZInterleaveType.interleave(one, two);\n+    }\n+\n+    @Override\n+    public boolean isAttributeNodeType(final SequenceType type)\n+    {\n+        return type instanceof AttributeNodeType;\n+    }\n+\n+    @Override\n+    public boolean isChoice(final SequenceType type)\n+    {\n+        return (type instanceof ChoiceType);\n+    }\n+\n+    @Override\n+    public boolean isCommentNodeType(final SequenceType type)\n+    {\n+        return type instanceof CommentNodeType;\n+    }\n+\n+    @Override\n+    public boolean isDocumentNodeType(final SequenceType type)\n+    {\n+        return type instanceof DocumentNodeType;\n+    }\n+\n+    @Override\n+    public boolean isElementNodeType(final SequenceType type)\n+    {\n+        return (type instanceof ElementNodeType);\n+    }\n+\n+    @Override\n+    public boolean isEmpty(final SequenceType type)\n+    {\n+        return type instanceof EmptyType;\n+    }\n+\n+    @Override\n+    public boolean isNamespaceNodeType(final SequenceType type)\n+    {\n+        return type instanceof NamespaceNodeType;\n+    }\n+\n+    @Override\n+    public boolean isNone(final SequenceType type)\n+    {\n+        return (type instanceof NoneType);\n+    }\n+\n+    @Override\n+    public boolean isProcessingInstructionNodeType(final SequenceType type)\n+    {\n+        return type instanceof ProcessingInstructionNodeType;\n+    }\n+\n+    @Override\n+    public boolean isTextNodeType(final SequenceType type)\n+    {\n+        return type instanceof TextNodeType;\n+    }\n+\n+    @Override\n+    public PrimeType itemType()\n+    {\n+        return ANY_ITEM;\n+    }\n+\n+    @Override\n+    public SequenceType multiply(final SequenceType argument, final Quantifier multiplier)\n+    {\n+        PreCondition.assertArgumentNotNull(argument, \"argument\");\n+        if (null != argument)\n+        {\n+            if (sameAs(argument, emptyType()))\n+            {\n+                return argument;\n+            }\n+            else if (sameAs(argument, noneType()))\n+            {\n+                return argument;\n+            }\n+            else if (multiplier.isExactlyOne())\n+            {\n+                return argument;\n+            }\n+            else\n+            {\n+                return ZMultiplyType.multiply(argument, multiplier);\n+            }\n+        }\n+        else\n+        {\r\n+            // TODO: We need to assert that the type is not null. This is a patch.\n+            return null;\n+        }\n+    }\n+\n+    @Override\n+    public SequenceType namespaceAxis(final SequenceType contextType)\n+    {\n+        return zeroOrMore(nodeType());\n+    }\n+\n+    @Override\n+    public SequenceType namespaceTest(final SequenceType arg)\n+    {\n+        final PrimeType primeType = arg.prime();\n+\n+        switch (primeType.getKind())\n+        {\n+            case CHOICE:\n+            {\n+                final PrimeChoiceType choiceType = (PrimeChoiceType)primeType;\n+                return multiply(choice(namespaceTest(choiceType.getLHS()), namespaceTest(choiceType.getRHS())), arg.quantifier());\n+            }\n+            case NAMESPACE:\n+            {\n+                return arg;\n+            }\n+            default:\n+            {\n+                return emptyType();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public NamespaceNodeType namespaceType()\n+    {\n+        return NAMESPACE;\n+    }\n+\n+    @Override\n+    public SequenceType nodeTest(final SequenceType arg)\n+    {\n+        final PrimeType primeType = arg.prime();\n+\n+        switch (primeType.getKind())\n+        {\n+            case CHOICE:\n+            {\n+                final PrimeChoiceType choiceType = (PrimeChoiceType)primeType;\n+                return multiply(choice(nodeTest(choiceType.getLHS()), nodeTest(choiceType.getRHS())), arg.quantifier());\n+            }\n+            case ATTRIBUTE:\n+            case SCHEMA_ATTRIBUTE:\n+            case COMMENT:\n+            case DOCUMENT:\n+            case ELEMENT:\n+            case SCHEMA_ELEMENT:\n+            case NAMESPACE:\n+            case PROCESSING_INSTRUCTION:\n+            case TEXT:\n+            case EMPTY:\n+            case ANY_ATOMIC_TYPE:\n+            case ATOM:\n+            {\n+                return arg;\n+            }\n+            case NONE:\n+            {\n+                return noneType();\n+            }\n+            default:\n+            {\n+                return emptyType();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public PrimeType nodeType()\n+    {\n+        return ANY_KIND;\n+    }\n+\n+    @Override\n+    public NoneType noneType()\n+    {\n+        return new NoneTypeImpl();\n+    }\n+\n+    @Override\n+    public NoneType noneType(final QName errorCode)\n+    {\n+        return new NoneTypeImpl(errorCode);\n+    }\n+\n+    @Override\n+    public SequenceType oneOrMore(final SequenceType type)\n+    {\n+        return multiply(type, Quantifier.ONE_OR_MORE);\n+    }\n+\n+    @Override\n+    public SequenceType optional(final SequenceType type)\n+    {\n+        if (null != type)\n+        {\n+            return multiply(type, Quantifier.OPTIONAL);\n+        }\n+        else\n+        {\n+            return null;\n+        }\n+    }\n+\n+    @Override\n+    public SequenceType parentAxis(final SequenceType contextType)\n+    {\n+        return optional(nodeType());\n+    }\n+\n+    @Override\n+    public SequenceType precedingAxis(final SequenceType contextType)\n+    {\n+        return zeroOrMore(nodeType());\n+    }\n+\n+    @Override\n+    public SequenceType precedingSiblingAxis(final SequenceType type)\n+    {\n+        final PrimeType prime = type.prime();\n+\n+        switch (prime.getKind())\n+        {\n+            case CHOICE:\n+            {\n+                final PrimeChoiceType choiceType = (PrimeChoiceType)prime;\n+                return multiply(choice(precedingSiblingAxis(choiceType.getLHS()), precedingSiblingAxis(choiceType.getRHS())), type.quantifier());\n+            }\n+            case ATTRIBUTE:\n+            {\n+                return multiply(zeroOrMore(attributeType(null, BuiltInSchema.SINGLETON.UNTYPED_ATOMIC)), type.quantifier());\n+            }\n+            case SCHEMA_ATTRIBUTE:\n+            {\r\n+                // TODO: This should come from the complex type, if it exists (otherwise empty).\n+                return multiply(zeroOrMore(attributeType(null, null)), type.quantifier());\n+            }\n+            case NAMESPACE:\n+            {\n+                return multiply(zeroOrMore(namespaceType()), type.quantifier());\n+            }\n+            case DOCUMENT:\n+            {\n+                return emptyType();\n+            }\n+            case ELEMENT:\n+            case SCHEMA_ELEMENT:\n+            case COMMENT:\n+            case PROCESSING_INSTRUCTION:\n+            case TEXT:\n+            {\n+                final ElementNodeType elementType = elementWild(null, true);\n+                final TextNodeType textType = textType();\n+                final CommentNodeType commentType = commentType();\n+                final ProcessingInstructionNodeType processingInstructionType = processingInstructionType(null);\n+                return multiply(zeroOrMore(choice(elementType, choice(textType, choice(commentType, processingInstructionType)))), type.quantifier());\n+            }\n+            case NONE:\n+            {\n+                return noneType();\n+            }\n+            default:\n+            {\n+                return emptyType();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public PrimeType prime(final SequenceType type)\n+    {\n+        return type.prime();\n+    }\n+\n+    @Override\n+    public SequenceType processingInstructionTest(final SequenceType arg, final String name)\n+    {\n+        final PrimeType primeType = arg.prime();\n+\n+        switch (primeType.getKind())\n+        {\n+            case CHOICE:\n+            {\n+                final PrimeChoiceType choiceType = (PrimeChoiceType)primeType;\n+                return multiply(choice(processingInstructionTest(choiceType.getLHS(), name), processingInstructionTest(choiceType.getRHS(), name)), arg.quantifier());\n+            }\n+            case PROCESSING_INSTRUCTION:\n+            {\n+                return arg;\n+            }\n+            default:\n+            {\n+                return emptyType();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public ProcessingInstructionNodeType processingInstructionType(final String name)\n+    {\n+        if (name != null)\n+            return new ProcessingInstructionNodeTypeImpl(name);\n+        return PROCESSING_INSTRUCTION;\n+    }\n+\n+    @Override\n+    public Quantifier quantifier(final SequenceType type)\n+    {\n+        return type.quantifier();\n+    }\n+\n+    @Override\n+    public boolean sameAs(final SequenceType one, final SequenceType two)\n+    {\n+        PreCondition.assertArgumentNotNull(one, \"one\");\n+        PreCondition.assertArgumentNotNull(two, \"two\");\n+        return subtype(one, two) && subtype(two, one);\n+    }\n+\n+    @Override\n+    public SequenceType selfAxis(final SequenceType type)\n+    {\n+        final PrimeType prime = type.prime();\n+\n+        switch (prime.getKind())\n+        {\n+            case CHOICE:\n+            {\n+                final PrimeChoiceType choiceType = (PrimeChoiceType)prime;\n+                return multiply(choice(selfAxis(choiceType.getLHS()), selfAxis(choiceType.getRHS())), type.quantifier());\n+            }\n+            case EMPTY:\n+            case ATOM:\n+            case ANY_ATOMIC_TYPE:\n+            {\n+                return emptyType();\n+            }\n+            case NONE:\n+            {\n+                return noneType();\n+            }\n+            default:\n+            {\n+                return type;\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public boolean subtype(final SequenceType lhs, final SequenceType rhs)\n+    {\n+        PreCondition.assertArgumentNotNull(lhs, \"lhs\");\n+        PreCondition.assertArgumentNotNull(rhs, \"rhs\");\n+        return SchemaSupport.subtype(lhs, rhs);\n+    }\n+\n+    @Override\n+    public SequenceType textTest(final SequenceType arg)\n+    {\n+        final PrimeType primeType = arg.prime();\n+\n+        switch (primeType.getKind())\n+        {\n+            case CHOICE:\n+            {\n+                final PrimeChoiceType choiceType = (PrimeChoiceType)primeType;\n+                return multiply(choice(textTest(choiceType.getLHS()), textTest(choiceType.getRHS())), arg.quantifier());\n+            }\n+            case TEXT:\n+            {\n+                return arg;\n+            }\n+            case NONE:\n+            {\n+                return arg;\n+            }\n+            default:\n+            {\n+                return emptyType();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public TextNodeType textType()\n+    {\n+        return TEXT;\n+    }\n+\n+    @Override\n+    public String toString(final SequenceType type, final NamespaceResolver mappings, final String defaultElementAndTypeNamespace)\n+        throws GenXDMException\n+    {\n+        return type.toString();\n+    }\n+\n+    @Override\n+    public SequenceType[] typeArray(final int size)\n+    {\n+        return new SequenceType[size];\n+    }\n+\n+    @Override\n+    public SequenceType zeroOrMore(final SequenceType type)\n+    {\n+        return multiply(type, Quantifier.ZERO_OR_MORE);\n+    }\n+\n+    private SequenceType attributeAxisFromComplexType(final ComplexType complexType, final ElementDefinition parentAxis)\n+    {\n+        final ArrayList<AttributeUse> attributeUses = ensureAttributeUses(complexType);\n+        SequenceType result = null;\n+        for (final AttributeUse attributeUse : attributeUses)\n+        {\n+            final SequenceType attributeType = attributeUseType(attributeUse, parentAxis);\n+            if (result == null)\n+            {\n+                result = attributeType;\n+            }\n+            else\n+            {\n+                result = interleave(result, attributeType);\n+            }\n+        }\n+        return result == null ? emptyType() : result;\n+    }\n+\n+    private SequenceType attributeUseType(final AttributeUse attributeUse, final ElementDefinition parentAxis)\n+    {\n+        final AttributeDefinition attribute = attributeUse.getAttribute();\n+        if (null != parentAxis)\n+        {\n+            return multiply(new AttributeDeclWithParentAxisType(attribute, parentAxis), attributeUse.isRequired() ? Quantifier.EXACTLY_ONE : Quantifier.OPTIONAL);\n+        }\n+        else\n+        {\n+            return multiply(attribute, attributeUse.isRequired() ? Quantifier.EXACTLY_ONE : Quantifier.OPTIONAL);\n+        }\n+    }\n+\n+    private SequenceType branchChildAxis()\n+    {\n+        final ElementNodeType elementType = elementWild(null, true);\n+        final TextNodeType textType = textType();\n+        final CommentNodeType commentType = commentType();\n+        final ProcessingInstructionNodeType processingInstructionType = processingInstructionType(null);\n+        return zeroOrMore(choice(elementType, choice(textType, choice(commentType, processingInstructionType))));\n     }\r\n \r\n     // TODO: The suggestion here is that we can factor out this function, maybe embed in the\r\n-    // complex type so that it can be cached.\r\n-    private SequenceType childAxisFromComplexType(final ComplexType complexType, final ElementDefinition parentDecl)\r\n-    {\r\n-        final ContentType contentType = complexType.getContentType();\r\n-        if (contentType.isMixed() || contentType.isElementOnly())\r\n-        {\r\n-            return modelGroupUseType(contentType.getContentModel(), parentDecl);\r\n-        }\r\n-        else\r\n-        {\r\n-            // TODO: handle the simple type case\r\n-            throw new UnsupportedOperationException();\r\n-        }\r\n-    }\r\n-\r\n-    private SequenceType elementUseType(final ElementUse elementUse, final ElementDefinition parentDecl)\r\n-    {\r\n+    // complex type so that it can be cached.\n+\n+    private SequenceType childAxisFromComplexType(final ComplexType complexType, final ElementDefinition parentDecl)\n+    {\n+        final ContentType contentType = complexType.getContentType();\n+        if (contentType.isMixed() || contentType.isElementOnly())\n+        {\n+            return modelGroupUseType(contentType.getContentModel(), parentDecl);\n+        }\n+        else\n+        {\r\n+            // TODO: handle the simple type case\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+\n+    private SequenceType elementUseType(final ElementUse elementUse, final ElementDefinition parentDecl)\n+    {\n         final int minOccurs = elementUse.getMinOccurs();\r\n         // Use Integer.MAX_VALUE to represent unbounded; okay in this case because call to Quantifier.approximate\r\n-        // only acts upon values of 0, 1, or > 1\r\n-        final int maxOccurs = elementUse.isMaxOccursUnbounded() ? Integer.MAX_VALUE : elementUse.getMaxOccurs();\r\n-        final ElementDefinition elementDecl = elementUse.getTerm();\r\n-        if (null != parentDecl)\r\n-        {\r\n-            return multiply(new ElementDeclWithParentAxisType(elementDecl, parentDecl), Quantifier.approximate(minOccurs, maxOccurs));\r\n-        }\r\n-        else\r\n-        {\r\n-            return multiply(elementDecl, Quantifier.approximate(minOccurs, maxOccurs));\r\n-        }\r\n-    }\r\n-\r\n-    private ArrayList<AttributeUse> ensureAttributeUses(final ComplexType complexType)\r\n-    {\r\n-        final ArrayList<AttributeUse> cachedAttributeUses = m_attributeUses.get(complexType);\r\n-        if (null != cachedAttributeUses)\r\n-        {\r\n-            return cachedAttributeUses;\r\n-        }\r\n-        else\r\n-        {\r\n-            final ArrayList<AttributeUse> attributeUses = new ArrayList<AttributeUse>();\r\n-            for (final AttributeUse attributeUse : complexType.getAttributeUses().values())\r\n-            {\r\n-                attributeUses.add(attributeUse);\r\n-            }\r\n-            m_attributeUses.put(complexType, attributeUses);\r\n-            return attributeUses;\r\n-        }\r\n-    }\r\n-\r\n-    private SequenceType modelGroupUseType(final ModelGroupUse modelGroupUse, final ElementDefinition parentDecl)\r\n-    {\r\n+        // only acts upon values of 0, 1, or > 1\n+        final int maxOccurs = elementUse.isMaxOccursUnbounded() ? Integer.MAX_VALUE : elementUse.getMaxOccurs();\n+        final ElementDefinition elementDecl = elementUse.getTerm();\n+        if (null != parentDecl)\n+        {\n+            return multiply(new ElementDeclWithParentAxisType(elementDecl, parentDecl), Quantifier.approximate(minOccurs, maxOccurs));\n+        }\n+        else\n+        {\n+            return multiply(elementDecl, Quantifier.approximate(minOccurs, maxOccurs));\n+        }\n+    }\n+\n+    private ArrayList<AttributeUse> ensureAttributeUses(final ComplexType complexType)\n+    {\n+        final ArrayList<AttributeUse> cachedAttributeUses = m_attributeUses.get(complexType);\n+        if (null != cachedAttributeUses)\n+        {\n+            return cachedAttributeUses;\n+        }\n+        else\n+        {\n+            final ArrayList<AttributeUse> attributeUses = new ArrayList<AttributeUse>();\n+            for (final AttributeUse attributeUse : complexType.getAttributeUses().values())\n+            {\n+                attributeUses.add(attributeUse);\n+            }\n+            m_attributeUses.put(complexType, attributeUses);\n+            return attributeUses;\n+        }\n+    }\n+\n+    private SequenceType modelGroupUseType(final ModelGroupUse modelGroupUse, final ElementDefinition parentDecl)\n+    {\n         final int minOccurs = modelGroupUse.getMinOccurs();\r\n         // Use Integer.MAX_VALUE to represent unbounded; okay in this case because call to Quantifier.approximate\r\n-        // only acts upon values of 0, 1, or > 1\r\n-        final int maxOccurs = modelGroupUse.isMaxOccursUnbounded() ? Integer.MAX_VALUE : modelGroupUse.getMaxOccurs();\r\n-        final ModelGroup modelGroup = modelGroupUse.getTerm();\r\n-        final ModelGroup.SmCompositor compositor = modelGroup.getCompositor();\r\n-\r\n-        SequenceType contentModel = null;\r\n-        for (final SchemaParticle particle : modelGroup.getParticles())\r\n-        {\r\n-            final SequenceType type = particle(particle, parentDecl);\r\n-            if (null != contentModel)\r\n-            {\r\n-                switch (compositor)\r\n-                {\r\n-                case Sequence:\r\n-                {\r\n-                    contentModel = concat(contentModel, type);\r\n-                }\r\n-                    break;\r\n-                case Choice:\r\n-                {\r\n-                    contentModel = choice(contentModel, type);\r\n-                }\r\n-                    break;\r\n-                case All:\r\n-                {\r\n-                    contentModel = interleave(contentModel, type);\r\n-                }\r\n-                    break;\r\n-                default:\r\n-                {\r\n-                    // Unexpected compositor.\r\n-                    throw new AssertionError(compositor);\r\n-                }\r\n-                }\r\n-            }\r\n-            else\r\n-            {\r\n-                contentModel = type;\r\n-            }\r\n-        }\r\n-        if (null != contentModel)\r\n-        {\r\n-            return multiply(contentModel, Quantifier.approximate(minOccurs, maxOccurs));\r\n-        }\r\n-        else\r\n-        {\r\n-            return emptyType();\r\n-        }\r\n-    }\r\n-\r\n-    private SequenceType particle(final SchemaParticle particle, final ElementDefinition parentDecl)\r\n-    {\r\n-        if (particle instanceof ElementUse)\r\n-        {\r\n-            return elementUseType((ElementUse) particle, parentDecl);\r\n-        }\r\n-        else if (particle instanceof ModelGroupUse)\r\n-        {\r\n-            return modelGroupUseType((ModelGroupUse) particle, parentDecl);\r\n-        }\r\n-        else if (particle instanceof WildcardUse)\r\n-        {\r\n-            return wildcardUseType((WildcardUse) particle, parentDecl);\r\n-        }\r\n-        else\r\n-        {\r\n-            // There shouldn't be anything else beside element, model group and wildcard.\r\n-            throw new AssertionError(particle);\r\n-        }\r\n-    }\r\n-\r\n-    private SequenceType wildcardUseType(final WildcardUse wildcardUse, final ElementDefinition parentDecl)\r\n-    {\r\n+        // only acts upon values of 0, 1, or > 1\n+        final int maxOccurs = modelGroupUse.isMaxOccursUnbounded() ? Integer.MAX_VALUE : modelGroupUse.getMaxOccurs();\n+        final ModelGroup modelGroup = modelGroupUse.getTerm();\n+        final ModelGroup.SmCompositor compositor = modelGroup.getCompositor();\n+        SequenceType contentModel = null;\n+        for (final SchemaParticle particle : modelGroup.getParticles())\n+        {\n+            final SequenceType type = particle(particle, parentDecl);\n+            if (null != contentModel)\n+            {\n+                switch (compositor)\n+                {\n+                    case Sequence:\n+                    {\n+                        contentModel = concat(contentModel, type);\n+                    }\n+                    break;\n+                    case Choice:\n+                    {\n+                        contentModel = choice(contentModel, type);\n+                    }\n+                    break;\n+                    case All:\n+                    {\n+                        contentModel = interleave(contentModel, type);\n+                    }\n+                    break;\n+                    default:\n+                    {\r\n+                    // Unexpected compositor.\n+                        throw new AssertionError(compositor);\n+                    }\n+                }\n+            }\n+            else\n+            {\n+                contentModel = type;\n+            }\n+        }\n+        if (null != contentModel)\n+        {\n+            return multiply(contentModel, Quantifier.approximate(minOccurs, maxOccurs));\n+        }\n+        else\n+        {\n+            return emptyType();\n+        }\n+    }\n+\n+    private SequenceType particle(final SchemaParticle particle, final ElementDefinition parentDecl)\n+    {\n+        if (particle instanceof ElementUse)\n+        {\n+            return elementUseType((ElementUse)particle, parentDecl);\n+        }\n+        else if (particle instanceof ModelGroupUse)\n+        {\n+            return modelGroupUseType((ModelGroupUse)particle, parentDecl);\n+        }\n+        else if (particle instanceof WildcardUse)\n+        {\n+            return wildcardUseType((WildcardUse)particle, parentDecl);\n+        }\n+        else\n+        {\r\n+            // There shouldn't be anything else beside element, model group and wildcard.\n+            throw new AssertionError(particle);\n+        }\n+    }\n+\n+    private SequenceType wildcardUseType(final WildcardUse wildcardUse, final ElementDefinition parentDecl)\n+    {\n         final int minOccurs = wildcardUse.getMinOccurs();\r\n         // Use Integer.MAX_VALUE to represent unbounded; okay in this case because call to Quantifier.approximate\r\n-        // only acts upon values of 0, 1, or > 1\r\n-        final int maxOccurs = wildcardUse.isMaxOccursUnbounded() ? Integer.MAX_VALUE : wildcardUse.getMaxOccurs();\r\n+        // only acts upon values of 0, 1, or > 1\n+        final int maxOccurs = wildcardUse.isMaxOccursUnbounded() ? Integer.MAX_VALUE : wildcardUse.getMaxOccurs();\n         final SchemaWildcard term = wildcardUse.getTerm();\r\n-        // final ProcessContentsMode processContents = term.getProcessContents();\r\n-        final NamespaceConstraint namespaceConstraint = term.getNamespaceConstraint();\r\n-        switch (namespaceConstraint.getMode())\r\n-        {\r\n-        case Any:\r\n-        {\r\n-            return multiply(new ElementNodeWithParentAxisType(elementWild(null, true), parentDecl), Quantifier.approximate(minOccurs, maxOccurs));\r\n-        }\r\n-        case Include:\r\n-        {\r\n-            SequenceType type = null;\r\n-            for (final String namespace : namespaceConstraint.getNamespaces())\r\n+        // final ProcessContentsMode processContents = term.getProcessContents();\n+        final NamespaceConstraint namespaceConstraint = term.getNamespaceConstraint();\n+\n+        switch (namespaceConstraint.getMode())\n+        {\n+            case Any:\n+            {\n+                return multiply(new ElementNodeWithParentAxisType(elementWild(null, true), parentDecl), Quantifier.approximate(minOccurs, maxOccurs));\n+            }\n+            case Include:\n+            {\n+                SequenceType type = null;\n+                for (final String namespace : namespaceConstraint.getNamespaces())\n+                {\n+                    final ElementNodeWithParentAxisType append = new ElementNodeWithParentAxisType(new ElementNodeTypeImpl(new QName(namespace, null), null, true), parentDecl);\n+                    if (null != type)\n+                    {\n+                        type = choice(type, append);\n+                    }\n+                    else\n+                    {\n+                        type = append;\n+                    }\n+                }\n+                return multiply(type, Quantifier.approximate(minOccurs, maxOccurs));\n+            }\n+            case Exclude:\n             {\r\n-                final ElementNodeWithParentAxisType append = \r\n-                    new ElementNodeWithParentAxisType(new ElementNodeTypeImpl(new QName(namespace, null), null, true), parentDecl);\r\n-                if (null != type)\r\n-                {\r\n-                    type = choice(type, append);\r\n-                }\r\n-                else\r\n-                {\r\n-                    type = append;\r\n-                }\r\n-            }\r\n-            return multiply(type, Quantifier.approximate(minOccurs, maxOccurs));\r\n-        }\r\n-        case Exclude:\r\n-        {\r\n             // TODO: How do we define a regular expression type that excludes certain namespaces?\r\n-            // TODO: We don't even have the concept of AND.\r\n-            return multiply(new ElementNodeWithParentAxisType(new ElementNodeTypeImpl(WILDNAME, null, true), parentDecl), Quantifier.approximate(minOccurs,\r\n-                    maxOccurs));\r\n-        }\r\n-        default:\r\n-        {\r\n-            throw new AssertionError();\r\n-        }\r\n-        }\r\n-    }\r\n-    private final PrimeType ANY_KIND;\r\n-    private final PrimeType ANY_ITEM;\r\n-    private final AtomicUrType ANY_ATOMIC_TYPE;\r\n-    private final EmptyType EMPTY = new ZEmptyType();\r\n-\r\n-    private final DocumentNodeType DOCUMENT;\r\n-    private final ElementNodeType ELEMENT;\r\n-    private final CommentNodeType COMMENT;\r\n-    private final ProcessingInstructionNodeType PROCESSING_INSTRUCTION;\r\n-    private final TextNodeType TEXT;\r\n-\r\n-    private final AttributeNodeType ATTRIBUTE;\r\n-    private final NamespaceNodeType NAMESPACE;\r\n-\r\n-    \r\n-    private final ConcurrentHashMap<Type, ArrayList<AttributeUse>> m_attributeUses = new ConcurrentHashMap<Type, ArrayList<AttributeUse>>();\r\n-\r\n-    private final QName WILDNAME = new QName(ESCAPE, ESCAPE);\r\n-\r\n-}\r\n+            // TODO: We don't even have the concept of AND.\n+                return multiply(new ElementNodeWithParentAxisType(new ElementNodeTypeImpl(WILDNAME, null, true), parentDecl), Quantifier.approximate(minOccurs, maxOccurs));\n+            }\n+            default:\n+            {\n+                throw new AssertionError();\n+            }\n+        }\n+    }\n+\n+    private final PrimeType ANY_KIND;\n+    private final PrimeType ANY_ITEM;\n+    private final AtomicUrType ANY_ATOMIC_TYPE;\n+    private final EmptyType EMPTY = new ZEmptyType();\n+    private final DocumentNodeType DOCUMENT;\n+    private final ElementNodeType ELEMENT;\n+    private final CommentNodeType COMMENT;\n+    private final ProcessingInstructionNodeType PROCESSING_INSTRUCTION;\n+    private final TextNodeType TEXT;\n+    private final AttributeNodeType ATTRIBUTE;\n+    private final NamespaceNodeType NAMESPACE;\n+    private final ConcurrentHashMap<Type, ArrayList<AttributeUse>> m_attributeUses = new ConcurrentHashMap<Type, ArrayList<AttributeUse>>();\n+    private final QName WILDNAME = new QName(ESCAPE, ESCAPE);\n+}\n\\ No newline at end of file\n",
            "diff_size": 1449
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "120",
                    "column": "9",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/124/TypesBridgeImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_random/124/TypesBridgeImpl.java\nindex 7b177851583..7b5945f1060 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/124/TypesBridgeImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_random/124/TypesBridgeImpl.java\n@@ -113,7 +113,7 @@ public final class TypesBridgeImpl implements TypesBridge\n         }\r\n         else if (type instanceof ComplexUrType)\r\n         {\r\n-        \tvisitor.complexUrType(type);\r\n+        visitor.complexUrType(type);\r\n         }\r\n         else if (type instanceof ComplexType)\r\n         {\r\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "120",
                    "column": "9",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/124/TypesBridgeImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_three_grams/124/TypesBridgeImpl.java\nindex 7b177851583..92f28847278 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/124/TypesBridgeImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_three_grams/124/TypesBridgeImpl.java\n@@ -113,7 +113,7 @@ public final class TypesBridgeImpl implements TypesBridge\n         }\r\n         else if (type instanceof ComplexUrType)\r\n         {\r\n-        \tvisitor.complexUrType(type);\r\n+            visitor.complexUrType(type);\r\n         }\r\n         else if (type instanceof ComplexType)\r\n         {\r\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "intellij",
        "codebuff"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "styler_random",
        "styler_three_grams"
    ]
}