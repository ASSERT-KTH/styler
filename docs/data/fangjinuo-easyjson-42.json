{
    "project_name": "fangjinuo-easyjson",
    "error_id": "42",
    "information": {
        "errors": [
            {
                "line": "263",
                "column": "9",
                "severity": "warning",
                "message": "'.' is preceded with whitespace.",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.NoWhitespaceBeforeCheck"
            }
        ]
    },
    "source_code": "    }\n    exceptionMessage.append(\"but got: \").append(token.getClass().getName())\n        .append(\", for type token: \").append(token.toString()).append('.');\n\n    return new AssertionError(exceptionMessage.toString());\n  }",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/errored/1/42/TypeToken.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/styler/42/TypeToken.java\nindex 3fb8af2bcfb..9998e34cff2 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/errored/1/42/TypeToken.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/styler/42/TypeToken.java\n@@ -259,8 +259,7 @@ public class TypeToken<T> {\n     for (Class<?> clazz : expected) {\n       exceptionMessage.append(clazz.getName()).append(\", \");\n     }\n-    exceptionMessage.append(\"but got: \").append(token.getClass().getName())\n-        .append(\", for type token: \").append(token.toString()).append('.');\n+    exceptionMessage.append(\"but got: \").append(token.getClass().getName()).append(\", for type token: \").append(token.toString()).append('.');\n \n     return new AssertionError(exceptionMessage.toString());\n   }\n",
            "diff_size": 2
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "263",
                    "column": "13",
                    "severity": "warning",
                    "message": "'.' is preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.NoWhitespaceBeforeCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/errored/1/42/TypeToken.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/intellij/42/TypeToken.java\nindex 3fb8af2bcfb..a2700b2a28c 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/errored/1/42/TypeToken.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/intellij/42/TypeToken.java\n@@ -45,276 +45,279 @@ import java.util.Map;\n  * @author Jesse Wilson\n  */\n public class TypeToken<T> {\n-  final Class<? super T> rawType;\n-  final Type type;\n-  final int hashCode;\n-\n-  /**\n-   * Constructs a new type literal. Derives represented class from type\n-   * parameter.\n-   *\n-   * <p>Clients create an empty anonymous subclass. Doing so embeds the type\n-   * parameter in the anonymous class's type hierarchy so we can reconstitute it\n-   * at runtime despite erasure.\n-   */\n-  @SuppressWarnings(\"unchecked\")\n-  protected TypeToken() {\n-    this.type = getSuperclassTypeParameter(getClass());\n-    this.rawType = (Class<? super T>) $Gson$Types.getRawType(type);\n-    this.hashCode = type.hashCode();\n-  }\n-\n-  /**\n-   * Unsafe. Constructs a type literal manually.\n-   */\n-  @SuppressWarnings(\"unchecked\")\n-  TypeToken(Type type) {\n-    this.type = $Gson$Types.canonicalize($Gson$Preconditions.checkNotNull(type));\n-    this.rawType = (Class<? super T>) $Gson$Types.getRawType(this.type);\n-    this.hashCode = this.type.hashCode();\n-  }\n-\n-  /**\n-   * Returns the type from super class's type parameter in {@link $Gson$Types#canonicalize\n-   * canonical form}.\n-   */\n-  static Type getSuperclassTypeParameter(Class<?> subclass) {\n-    Type superclass = subclass.getGenericSuperclass();\n-    if (superclass instanceof Class) {\n-      throw new RuntimeException(\"Missing type parameter.\");\n-    }\n-    ParameterizedType parameterized = (ParameterizedType) superclass;\n-    return $Gson$Types.canonicalize(parameterized.getActualTypeArguments()[0]);\n-  }\n-\n-  /**\n-   * Returns the raw (non-generic) type for this type.\n-   */\n-  public final Class<? super T> getRawType() {\n-    return rawType;\n-  }\n-\n-  /**\n-   * Gets underlying {@code Type} instance.\n-   */\n-  public final Type getType() {\n-    return type;\n-  }\n-\n-  /**\n-   * Check if this type is assignable from the given class object.\n-   *\n-   * @deprecated this implementation may be inconsistent with javac for types\n-   *     with wildcards.\n-   */\n-  @Deprecated\n-  public boolean isAssignableFrom(Class<?> cls) {\n-    return isAssignableFrom((Type) cls);\n-  }\n-\n-  /**\n-   * Check if this type is assignable from the given Type.\n-   *\n-   * @deprecated this implementation may be inconsistent with javac for types\n-   *     with wildcards.\n-   */\n-  @Deprecated\n-  public boolean isAssignableFrom(Type from) {\n-    if (from == null) {\n-      return false;\n+    final Class<? super T> rawType;\n+    final Type type;\n+    final int hashCode;\n+\n+    /**\n+     * Constructs a new type literal. Derives represented class from type\n+     * parameter.\n+     *\n+     * <p>Clients create an empty anonymous subclass. Doing so embeds the type\n+     * parameter in the anonymous class's type hierarchy so we can reconstitute it\n+     * at runtime despite erasure.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    protected TypeToken() {\n+        this.type = getSuperclassTypeParameter(getClass());\n+        this.rawType = (Class<? super T>) $Gson$Types.getRawType(type);\n+        this.hashCode = type.hashCode();\n     }\n \n-    if (type.equals(from)) {\n-      return true;\n+    /**\n+     * Unsafe. Constructs a type literal manually.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    TypeToken(Type type) {\n+        this.type = $Gson$Types.canonicalize($Gson$Preconditions.checkNotNull(type));\n+        this.rawType = (Class<? super T>) $Gson$Types.getRawType(this.type);\n+        this.hashCode = this.type.hashCode();\n     }\n \n-    if (type instanceof Class<?>) {\n-      return rawType.isAssignableFrom($Gson$Types.getRawType(from));\n-    } else if (type instanceof ParameterizedType) {\n-      return isAssignableFrom(from, (ParameterizedType) type,\n-          new HashMap<String, Type>());\n-    } else if (type instanceof GenericArrayType) {\n-      return rawType.isAssignableFrom($Gson$Types.getRawType(from))\n-          && isAssignableFrom(from, (GenericArrayType) type);\n-    } else {\n-      throw buildUnexpectedTypeError(\n-          type, Class.class, ParameterizedType.class, GenericArrayType.class);\n-    }\n-  }\n-\n-  /**\n-   * Check if this type is assignable from the given type token.\n-   *\n-   * @deprecated this implementation may be inconsistent with javac for types\n-   *     with wildcards.\n-   */\n-  @Deprecated\n-  public boolean isAssignableFrom(TypeToken<?> token) {\n-    return isAssignableFrom(token.getType());\n-  }\n-\n-  /**\n-   * Private helper function that performs some assignability checks for\n-   * the provided GenericArrayType.\n-   */\n-  private static boolean isAssignableFrom(Type from, GenericArrayType to) {\n-    Type toGenericComponentType = to.getGenericComponentType();\n-    if (toGenericComponentType instanceof ParameterizedType) {\n-      Type t = from;\n-      if (from instanceof GenericArrayType) {\n-        t = ((GenericArrayType) from).getGenericComponentType();\n-      } else if (from instanceof Class<?>) {\n-        Class<?> classType = (Class<?>) from;\n-        while (classType.isArray()) {\n-          classType = classType.getComponentType();\n+    /**\n+     * Returns the type from super class's type parameter in {@link $Gson$Types#canonicalize\n+     * canonical form}.\n+     */\n+    static Type getSuperclassTypeParameter(Class<?> subclass) {\n+        Type superclass = subclass.getGenericSuperclass();\n+        if (superclass instanceof Class) {\n+            throw new RuntimeException(\"Missing type parameter.\");\n         }\n-        t = classType;\n-      }\n-      return isAssignableFrom(t, (ParameterizedType) toGenericComponentType,\n-          new HashMap<String, Type>());\n+        ParameterizedType parameterized = (ParameterizedType) superclass;\n+        return $Gson$Types.canonicalize(parameterized.getActualTypeArguments()[0]);\n     }\n-    // No generic defined on \"to\"; therefore, return true and let other\n-    // checks determine assignability\n-    return true;\n-  }\n-\n-  /**\n-   * Private recursive helper function to actually do the type-safe checking\n-   * of assignability.\n-   */\n-  private static boolean isAssignableFrom(Type from, ParameterizedType to,\n-      Map<String, Type> typeVarMap) {\n-\n-    if (from == null) {\n-      return false;\n+\n+    /**\n+     * Returns the raw (non-generic) type for this type.\n+     */\n+    public final Class<? super T> getRawType() {\n+        return rawType;\n     }\n \n-    if (to.equals(from)) {\n-      return true;\n+    /**\n+     * Gets underlying {@code Type} instance.\n+     */\n+    public final Type getType() {\n+        return type;\n     }\n \n-    // First figure out the class and any type information.\n-    Class<?> clazz = $Gson$Types.getRawType(from);\n-    ParameterizedType ptype = null;\n-    if (from instanceof ParameterizedType) {\n-      ptype = (ParameterizedType) from;\n+    /**\n+     * Check if this type is assignable from the given class object.\n+     *\n+     * @deprecated this implementation may be inconsistent with javac for types\n+     * with wildcards.\n+     */\n+    @Deprecated\n+    public boolean isAssignableFrom(Class<?> cls) {\n+        return isAssignableFrom((Type) cls);\n     }\n \n-    // Load up parameterized variable info if it was parameterized.\n-    if (ptype != null) {\n-      Type[] tArgs = ptype.getActualTypeArguments();\n-      TypeVariable<?>[] tParams = clazz.getTypeParameters();\n-      for (int i = 0; i < tArgs.length; i++) {\n-        Type arg = tArgs[i];\n-        TypeVariable<?> var = tParams[i];\n-        while (arg instanceof TypeVariable<?>) {\n-          TypeVariable<?> v = (TypeVariable<?>) arg;\n-          arg = typeVarMap.get(v.getName());\n+    /**\n+     * Check if this type is assignable from the given Type.\n+     *\n+     * @deprecated this implementation may be inconsistent with javac for types\n+     * with wildcards.\n+     */\n+    @Deprecated\n+    public boolean isAssignableFrom(Type from) {\n+        if (from == null) {\n+            return false;\n         }\n-        typeVarMap.put(var.getName(), arg);\n-      }\n \n-      // check if they are equivalent under our current mapping.\n-      if (typeEquals(ptype, to, typeVarMap)) {\n-        return true;\n-      }\n+        if (type.equals(from)) {\n+            return true;\n+        }\n+\n+        if (type instanceof Class<?>) {\n+            return rawType.isAssignableFrom($Gson$Types.getRawType(from));\n+        } else if (type instanceof ParameterizedType) {\n+            return isAssignableFrom(from, (ParameterizedType) type,\n+                new HashMap<String, Type>());\n+        } else if (type instanceof GenericArrayType) {\n+            return rawType.isAssignableFrom($Gson$Types.getRawType(from))\n+                && isAssignableFrom(from, (GenericArrayType) type);\n+        } else {\n+            throw buildUnexpectedTypeError(\n+                type, Class.class, ParameterizedType.class, GenericArrayType.class);\n+        }\n+    }\n+\n+    /**\n+     * Check if this type is assignable from the given type token.\n+     *\n+     * @deprecated this implementation may be inconsistent with javac for types\n+     * with wildcards.\n+     */\n+    @Deprecated\n+    public boolean isAssignableFrom(TypeToken<?> token) {\n+        return isAssignableFrom(token.getType());\n     }\n \n-    for (Type itype : clazz.getGenericInterfaces()) {\n-      if (isAssignableFrom(itype, to, new HashMap<String, Type>(typeVarMap))) {\n+    /**\n+     * Private helper function that performs some assignability checks for\n+     * the provided GenericArrayType.\n+     */\n+    private static boolean isAssignableFrom(Type from, GenericArrayType to) {\n+        Type toGenericComponentType = to.getGenericComponentType();\n+        if (toGenericComponentType instanceof ParameterizedType) {\n+            Type t = from;\n+            if (from instanceof GenericArrayType) {\n+                t = ((GenericArrayType) from).getGenericComponentType();\n+            } else if (from instanceof Class<?>) {\n+                Class<?> classType = (Class<?>) from;\n+                while (classType.isArray()) {\n+                    classType = classType.getComponentType();\n+                }\n+                t = classType;\n+            }\n+            return isAssignableFrom(t, (ParameterizedType) toGenericComponentType,\n+                new HashMap<String, Type>());\n+        }\n+        // No generic defined on \"to\"; therefore, return true and let other\n+        // checks determine assignability\n         return true;\n-      }\n     }\n \n-    // Interfaces didn't work, try the superclass.\n-    Type sType = clazz.getGenericSuperclass();\n-    return isAssignableFrom(sType, to, new HashMap<String, Type>(typeVarMap));\n-  }\n-\n-  /**\n-   * Checks if two parameterized types are exactly equal, under the variable\n-   * replacement described in the typeVarMap.\n-   */\n-  private static boolean typeEquals(ParameterizedType from,\n-      ParameterizedType to, Map<String, Type> typeVarMap) {\n-    if (from.getRawType().equals(to.getRawType())) {\n-      Type[] fromArgs = from.getActualTypeArguments();\n-      Type[] toArgs = to.getActualTypeArguments();\n-      for (int i = 0; i < fromArgs.length; i++) {\n-        if (!matches(fromArgs[i], toArgs[i], typeVarMap)) {\n-          return false;\n+    /**\n+     * Private recursive helper function to actually do the type-safe checking\n+     * of assignability.\n+     */\n+    private static boolean isAssignableFrom(Type from, ParameterizedType to,\n+                                            Map<String, Type> typeVarMap) {\n+\n+        if (from == null) {\n+            return false;\n+        }\n+\n+        if (to.equals(from)) {\n+            return true;\n+        }\n+\n+        // First figure out the class and any type information.\n+        Class<?> clazz = $Gson$Types.getRawType(from);\n+        ParameterizedType ptype = null;\n+        if (from instanceof ParameterizedType) {\n+            ptype = (ParameterizedType) from;\n+        }\n+\n+        // Load up parameterized variable info if it was parameterized.\n+        if (ptype != null) {\n+            Type[] tArgs = ptype.getActualTypeArguments();\n+            TypeVariable<?>[] tParams = clazz.getTypeParameters();\n+            for (int i = 0; i < tArgs.length; i++) {\n+                Type arg = tArgs[i];\n+                TypeVariable<?> var = tParams[i];\n+                while (arg instanceof TypeVariable<?>) {\n+                    TypeVariable<?> v = (TypeVariable<?>) arg;\n+                    arg = typeVarMap.get(v.getName());\n+                }\n+                typeVarMap.put(var.getName(), arg);\n+            }\n+\n+            // check if they are equivalent under our current mapping.\n+            if (typeEquals(ptype, to, typeVarMap)) {\n+                return true;\n+            }\n+        }\n+\n+        for (Type itype : clazz.getGenericInterfaces()) {\n+            if (isAssignableFrom(itype, to, new HashMap<String, Type>(typeVarMap))) {\n+                return true;\n+            }\n+        }\n+\n+        // Interfaces didn't work, try the superclass.\n+        Type sType = clazz.getGenericSuperclass();\n+        return isAssignableFrom(sType, to, new HashMap<String, Type>(typeVarMap));\n+    }\n+\n+    /**\n+     * Checks if two parameterized types are exactly equal, under the variable\n+     * replacement described in the typeVarMap.\n+     */\n+    private static boolean typeEquals(ParameterizedType from,\n+                                      ParameterizedType to, Map<String, Type> typeVarMap) {\n+        if (from.getRawType().equals(to.getRawType())) {\n+            Type[] fromArgs = from.getActualTypeArguments();\n+            Type[] toArgs = to.getActualTypeArguments();\n+            for (int i = 0; i < fromArgs.length; i++) {\n+                if (!matches(fromArgs[i], toArgs[i], typeVarMap)) {\n+                    return false;\n+                }\n+            }\n+            return true;\n         }\n-      }\n-      return true;\n+        return false;\n     }\n-    return false;\n-  }\n \n-  private static AssertionError buildUnexpectedTypeError(\n-      Type token, Class<?>... expected) {\n+    private static AssertionError buildUnexpectedTypeError(\n+        Type token, Class<?>... expected) {\n+\n+        // Build exception message\n+        StringBuilder exceptionMessage =\n+            new StringBuilder(\"Unexpected type. Expected one of: \");\n+        for (Class<?> clazz : expected) {\n+            exceptionMessage.append(clazz.getName()).append(\", \");\n+        }\n+        exceptionMessage.append(\"but got: \").append(token.getClass().getName())\n+            .append(\", for type token: \").append(token.toString()).append('.');\n+\n+        return new AssertionError(exceptionMessage.toString());\n+    }\n+\n+    /**\n+     * Checks if two types are the same or are equivalent under a variable mapping\n+     * given in the type map that was provided.\n+     */\n+    private static boolean matches(Type from, Type to, Map<String, Type> typeMap) {\n+        return to.equals(from)\n+            || (from instanceof TypeVariable\n+            && to.equals(typeMap.get(((TypeVariable<?>) from).getName())));\n+\n+    }\n+\n+    @Override\n+    public final int hashCode() {\n+        return this.hashCode;\n+    }\n+\n+    @Override\n+    public final boolean equals(Object o) {\n+        return o instanceof TypeToken<?>\n+            && $Gson$Types.equals(type, ((TypeToken<?>) o).type);\n+    }\n+\n+    @Override\n+    public final String toString() {\n+        return $Gson$Types.typeToString(type);\n+    }\n+\n+    /**\n+     * Gets type literal for the given {@code Type} instance.\n+     */\n+    public static TypeToken<?> get(Type type) {\n+        return new TypeToken<Object>(type);\n+    }\n+\n+    /**\n+     * Gets type literal for the given {@code Class} instance.\n+     */\n+    public static <T> TypeToken<T> get(Class<T> type) {\n+        return new TypeToken<T>(type);\n+    }\n+\n+    /**\n+     * Gets type literal for the parameterized type represented by applying {@code typeArguments} to\n+     * {@code rawType}.\n+     */\n+    public static TypeToken<?> getParameterized(Type rawType, Type... typeArguments) {\n+        return new TypeToken<Object>($Gson$Types.newParameterizedTypeWithOwner(null, rawType, typeArguments));\n+    }\n \n-    // Build exception message\n-    StringBuilder exceptionMessage =\n-        new StringBuilder(\"Unexpected type. Expected one of: \");\n-    for (Class<?> clazz : expected) {\n-      exceptionMessage.append(clazz.getName()).append(\", \");\n+    /**\n+     * Gets type literal for the array type whose elements are all instances of {@code componentType}.\n+     */\n+    public static TypeToken<?> getArray(Type componentType) {\n+        return new TypeToken<Object>($Gson$Types.arrayOf(componentType));\n     }\n-    exceptionMessage.append(\"but got: \").append(token.getClass().getName())\n-        .append(\", for type token: \").append(token.toString()).append('.');\n-\n-    return new AssertionError(exceptionMessage.toString());\n-  }\n-\n-  /**\n-   * Checks if two types are the same or are equivalent under a variable mapping\n-   * given in the type map that was provided.\n-   */\n-  private static boolean matches(Type from, Type to, Map<String, Type> typeMap) {\n-    return to.equals(from)\n-        || (from instanceof TypeVariable\n-        && to.equals(typeMap.get(((TypeVariable<?>) from).getName())));\n-\n-  }\n-\n-  @Override public final int hashCode() {\n-    return this.hashCode;\n-  }\n-\n-  @Override public final boolean equals(Object o) {\n-    return o instanceof TypeToken<?>\n-        && $Gson$Types.equals(type, ((TypeToken<?>) o).type);\n-  }\n-\n-  @Override public final String toString() {\n-    return $Gson$Types.typeToString(type);\n-  }\n-\n-  /**\n-   * Gets type literal for the given {@code Type} instance.\n-   */\n-  public static TypeToken<?> get(Type type) {\n-    return new TypeToken<Object>(type);\n-  }\n-\n-  /**\n-   * Gets type literal for the given {@code Class} instance.\n-   */\n-  public static <T> TypeToken<T> get(Class<T> type) {\n-    return new TypeToken<T>(type);\n-  }\n-\n-  /**\n-   * Gets type literal for the parameterized type represented by applying {@code typeArguments} to\n-   * {@code rawType}.\n-   */\n-  public static TypeToken<?> getParameterized(Type rawType, Type... typeArguments) {\n-    return new TypeToken<Object>($Gson$Types.newParameterizedTypeWithOwner(null, rawType, typeArguments));\n-  }\n-\n-  /**\n-   * Gets type literal for the array type whose elements are all instances of {@code componentType}.\n-   */\n-  public static TypeToken<?> getArray(Type componentType) {\n-    return new TypeToken<Object>($Gson$Types.arrayOf(componentType));\n-  }\n }\n",
            "diff_size": 416
        },
        {
            "tool": "naturalize",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/errored/1/42/TypeToken.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/naturalize/42/TypeToken.java\nindex 3fb8af2bcfb..bdde2b8a1b6 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/errored/1/42/TypeToken.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/naturalize/42/TypeToken.java\n@@ -45,7 +45,7 @@ import java.util.Map;\n  * @author Jesse Wilson\n  */\n public class TypeToken<T> {\n-  final Class<? super T> rawType;\n+    final Class<? super T> rawType;\n   final Type type;\n   final int hashCode;\n \n@@ -62,7 +62,7 @@ public class TypeToken<T> {\n     this.type = getSuperclassTypeParameter(getClass());\n     this.rawType = (Class<? super T>) $Gson$Types.getRawType(type);\n     this.hashCode = type.hashCode();\n-  }\n+    }\n \n   /**\n    * Unsafe. Constructs a type literal manually.\n@@ -72,7 +72,7 @@ public class TypeToken<T> {\n     this.type = $Gson$Types.canonicalize($Gson$Preconditions.checkNotNull(type));\n     this.rawType = (Class<? super T>) $Gson$Types.getRawType(this.type);\n     this.hashCode = this.type.hashCode();\n-  }\n+    }\n \n   /**\n    * Returns the type from super class's type parameter in {@link $Gson$Types#canonicalize\n@@ -81,25 +81,25 @@ public class TypeToken<T> {\n   static Type getSuperclassTypeParameter(Class<?> subclass) {\n     Type superclass = subclass.getGenericSuperclass();\n     if (superclass instanceof Class) {\n-      throw new RuntimeException(\"Missing type parameter.\");\n+    throw new RuntimeException(\"Missing type parameter.\");\n     }\n     ParameterizedType parameterized = (ParameterizedType) superclass;\n     return $Gson$Types.canonicalize(parameterized.getActualTypeArguments()[0]);\n-  }\n+    }\n \n   /**\n    * Returns the raw (non-generic) type for this type.\n    */\n   public final Class<? super T> getRawType() {\n     return rawType;\n-  }\n+    }\n \n   /**\n    * Gets underlying {@code Type} instance.\n    */\n   public final Type getType() {\n     return type;\n-  }\n+    }\n \n   /**\n    * Check if this type is assignable from the given class object.\n@@ -110,7 +110,7 @@ public class TypeToken<T> {\n   @Deprecated\n   public boolean isAssignableFrom(Class<?> cls) {\n     return isAssignableFrom((Type) cls);\n-  }\n+    }\n \n   /**\n    * Check if this type is assignable from the given Type.\n@@ -121,26 +121,24 @@ public class TypeToken<T> {\n   @Deprecated\n   public boolean isAssignableFrom(Type from) {\n     if (from == null) {\n-      return false;\n+    return false;\n     }\n \n     if (type.equals(from)) {\n-      return true;\n+    return true;\n     }\n \n     if (type instanceof Class<?>) {\n-      return rawType.isAssignableFrom($Gson$Types.getRawType(from));\n+    return rawType.isAssignableFrom($Gson$Types.getRawType(from));\n     } else if (type instanceof ParameterizedType) {\n-      return isAssignableFrom(from, (ParameterizedType) type,\n-          new HashMap<String, Type>());\n+    return isAssignableFrom(from, (ParameterizedType) type, new HashMap<String, Type>());\n     } else if (type instanceof GenericArrayType) {\n-      return rawType.isAssignableFrom($Gson$Types.getRawType(from))\n-          && isAssignableFrom(from, (GenericArrayType) type);\n+    return rawType.isAssignableFrom($Gson$Types.getRawType(from))\n+        && isAssignableFrom(from, (GenericArrayType) type);\n     } else {\n-      throw buildUnexpectedTypeError(\n-          type, Class.class, ParameterizedType.class, GenericArrayType.class);\n+    throw buildUnexpectedTypeError(type, Class.class, ParameterizedType.class, GenericArrayType.class);\n+    }\n     }\n-  }\n \n   /**\n    * Check if this type is assignable from the given type token.\n@@ -151,7 +149,7 @@ public class TypeToken<T> {\n   @Deprecated\n   public boolean isAssignableFrom(TypeToken<?> token) {\n     return isAssignableFrom(token.getType());\n-  }\n+    }\n \n   /**\n    * Private helper function that performs some assignability checks for\n@@ -160,148 +158,136 @@ public class TypeToken<T> {\n   private static boolean isAssignableFrom(Type from, GenericArrayType to) {\n     Type toGenericComponentType = to.getGenericComponentType();\n     if (toGenericComponentType instanceof ParameterizedType) {\n-      Type t = from;\n+    Type t = from;\n       if (from instanceof GenericArrayType) {\n-        t = ((GenericArrayType) from).getGenericComponentType();\n-      } else if (from instanceof Class<?>) {\n-        Class<?> classType = (Class<?>) from;\n+    t = ((GenericArrayType) from).getGenericComponentType();\n+    } else if (from instanceof Class<?>) {\n+    Class<?> classType = (Class<?>) from;\n         while (classType.isArray()) {\n-          classType = classType.getComponentType();\n-        }\n+    classType = classType.getComponentType();\n+    }\n         t = classType;\n-      }\n-      return isAssignableFrom(t, (ParameterizedType) toGenericComponentType,\n-          new HashMap<String, Type>());\n+    }\n+      return isAssignableFrom(t, (ParameterizedType) toGenericComponentType, new HashMap<String, Type>());\n     }\n     // No generic defined on \"to\"; therefore, return true and let other\n     // checks determine assignability\n     return true;\n-  }\n+    }\n \n   /**\n    * Private recursive helper function to actually do the type-safe checking\n    * of assignability.\n    */\n-  private static boolean isAssignableFrom(Type from, ParameterizedType to,\n-      Map<String, Type> typeVarMap) {\n-\n+  private static boolean isAssignableFrom(Type from, ParameterizedType to, Map<String, Type> typeVarMap) {\n     if (from == null) {\n-      return false;\n+    return false;\n     }\n \n     if (to.equals(from)) {\n-      return true;\n+    return true;\n     }\n \n     // First figure out the class and any type information.\n     Class<?> clazz = $Gson$Types.getRawType(from);\n     ParameterizedType ptype = null;\n     if (from instanceof ParameterizedType) {\n-      ptype = (ParameterizedType) from;\n+    ptype = (ParameterizedType) from;\n     }\n \n     // Load up parameterized variable info if it was parameterized.\n     if (ptype != null) {\n-      Type[] tArgs = ptype.getActualTypeArguments();\n+    Type[] tArgs = ptype.getActualTypeArguments();\n       TypeVariable<?>[] tParams = clazz.getTypeParameters();\n       for (int i = 0; i < tArgs.length; i++) {\n-        Type arg = tArgs[i];\n+    Type arg = tArgs[i];\n         TypeVariable<?> var = tParams[i];\n         while (arg instanceof TypeVariable<?>) {\n-          TypeVariable<?> v = (TypeVariable<?>) arg;\n+    TypeVariable<?> v = (TypeVariable<?>) arg;\n           arg = typeVarMap.get(v.getName());\n-        }\n+    }\n         typeVarMap.put(var.getName(), arg);\n-      }\n+    }\n \n       // check if they are equivalent under our current mapping.\n       if (typeEquals(ptype, to, typeVarMap)) {\n-        return true;\n-      }\n+    return true;\n+    }\n     }\n \n     for (Type itype : clazz.getGenericInterfaces()) {\n-      if (isAssignableFrom(itype, to, new HashMap<String, Type>(typeVarMap))) {\n-        return true;\n-      }\n+    if (isAssignableFrom(itype, to, new HashMap<String, Type>(typeVarMap))) {\n+    return true;\n+    }\n     }\n \n     // Interfaces didn't work, try the superclass.\n     Type sType = clazz.getGenericSuperclass();\n     return isAssignableFrom(sType, to, new HashMap<String, Type>(typeVarMap));\n-  }\n+    }\n \n   /**\n    * Checks if two parameterized types are exactly equal, under the variable\n    * replacement described in the typeVarMap.\n    */\n-  private static boolean typeEquals(ParameterizedType from,\n-      ParameterizedType to, Map<String, Type> typeVarMap) {\n+  private static boolean typeEquals(ParameterizedType from, ParameterizedType to, Map<String, Type> typeVarMap) {\n     if (from.getRawType().equals(to.getRawType())) {\n-      Type[] fromArgs = from.getActualTypeArguments();\n+    Type[] fromArgs = from.getActualTypeArguments();\n       Type[] toArgs = to.getActualTypeArguments();\n       for (int i = 0; i < fromArgs.length; i++) {\n-        if (!matches(fromArgs[i], toArgs[i], typeVarMap)) {\n-          return false;\n-        }\n-      }\n+    if (!matches(fromArgs[i], toArgs[i], typeVarMap)) {\n+    return false;\n+    }\n+    }\n       return true;\n     }\n     return false;\n-  }\n-\n-  private static AssertionError buildUnexpectedTypeError(\n-      Type token, Class<?>... expected) {\n+    }\n \n+  private static AssertionError buildUnexpectedTypeError(Type token, Class<?>... expected) {\n     // Build exception message\n-    StringBuilder exceptionMessage =\n-        new StringBuilder(\"Unexpected type. Expected one of: \");\n-    for (Class<?> clazz : expected) {\n-      exceptionMessage.append(clazz.getName()).append(\", \");\n+    StringBuilder exceptionMessage = new StringBuilder(\"Unexpected type. Expected one of: \");\n+for (Class<?> clazz : expected) {\n+    exceptionMessage.append(clazz.getName()).append(\", \");\n+    }\n+    exceptionMessage.append(\"but got: \").append(token.getClass().getName()).append(\", for type token: \").append(token.toString()).append('.');\n+return new AssertionError(exceptionMessage.toString());\n     }\n-    exceptionMessage.append(\"but got: \").append(token.getClass().getName())\n-        .append(\", for type token: \").append(token.toString()).append('.');\n-\n-    return new AssertionError(exceptionMessage.toString());\n-  }\n \n   /**\n    * Checks if two types are the same or are equivalent under a variable mapping\n    * given in the type map that was provided.\n    */\n   private static boolean matches(Type from, Type to, Map<String, Type> typeMap) {\n-    return to.equals(from)\n-        || (from instanceof TypeVariable\n+    return to.equals(from) || (from instanceof TypeVariable\n         && to.equals(typeMap.get(((TypeVariable<?>) from).getName())));\n-\n-  }\n+    }\n \n   @Override public final int hashCode() {\n     return this.hashCode;\n-  }\n+    }\n \n   @Override public final boolean equals(Object o) {\n-    return o instanceof TypeToken<?>\n-        && $Gson$Types.equals(type, ((TypeToken<?>) o).type);\n-  }\n+    return o instanceof TypeToken<?> && $Gson$Types.equals(type, ((TypeToken<?>) o).type);\n+    }\n \n   @Override public final String toString() {\n     return $Gson$Types.typeToString(type);\n-  }\n+    }\n \n   /**\n    * Gets type literal for the given {@code Type} instance.\n    */\n   public static TypeToken<?> get(Type type) {\n     return new TypeToken<Object>(type);\n-  }\n+    }\n \n   /**\n    * Gets type literal for the given {@code Class} instance.\n    */\n   public static <T> TypeToken<T> get(Class<T> type) {\n     return new TypeToken<T>(type);\n-  }\n+    }\n \n   /**\n    * Gets type literal for the parameterized type represented by applying {@code typeArguments} to\n@@ -309,12 +295,12 @@ public class TypeToken<T> {\n    */\n   public static TypeToken<?> getParameterized(Type rawType, Type... typeArguments) {\n     return new TypeToken<Object>($Gson$Types.newParameterizedTypeWithOwner(null, rawType, typeArguments));\n-  }\n+    }\n \n   /**\n    * Gets type literal for the array type whose elements are all instances of {@code componentType}.\n    */\n   public static TypeToken<?> getArray(Type componentType) {\n     return new TypeToken<Object>($Gson$Types.arrayOf(componentType));\n-  }\n-}\n+    }\n+    }\n\\ No newline at end of file\n",
            "diff_size": 83
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/errored/1/42/TypeToken.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/codebuff/42/TypeToken.java\nindex 3fb8af2bcfb..f62f963979a 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/errored/1/42/TypeToken.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/codebuff/42/TypeToken.java\n@@ -44,10 +44,11 @@ import java.util.Map;\n  * @author Sven Mawson\n  * @author Jesse Wilson\n  */\n+\n public class TypeToken<T> {\n-  final Class<? super T> rawType;\n-  final Type type;\n-  final int hashCode;\n+    final Class<? super T> rawType;\n+    final Type type;\n+    final int hashCode;\n \n   /**\n    * Constructs a new type literal. Derives represented class from type\n@@ -57,49 +58,54 @@ public class TypeToken<T> {\n    * parameter in the anonymous class's type hierarchy so we can reconstitute it\n    * at runtime despite erasure.\n    */\n-  @SuppressWarnings(\"unchecked\")\n-  protected TypeToken() {\n-    this.type = getSuperclassTypeParameter(getClass());\n-    this.rawType = (Class<? super T>) $Gson$Types.getRawType(type);\n-    this.hashCode = type.hashCode();\n-  }\n+\n+\n+    @SuppressWarnings(\"unchecked\") protected TypeToken() {\n+        this.type = getSuperclassTypeParameter(getClass());\n+        this.rawType = (Class<? super T>) $Gson$Types.getRawType(type);\n+        this.hashCode = type.hashCode();\n+    }\n \n   /**\n    * Unsafe. Constructs a type literal manually.\n    */\n-  @SuppressWarnings(\"unchecked\")\n-  TypeToken(Type type) {\n-    this.type = $Gson$Types.canonicalize($Gson$Preconditions.checkNotNull(type));\n-    this.rawType = (Class<? super T>) $Gson$Types.getRawType(this.type);\n-    this.hashCode = this.type.hashCode();\n-  }\n+\n+\n+    @SuppressWarnings(\"unchecked\") TypeToken(Type type) {\n+        this.type = $Gson$Types.canonicalize($Gson$Preconditions.checkNotNull(type));\n+        this.rawType = (Class<? super T>) $Gson$Types.getRawType(this.type);\n+        this.hashCode = this.type.hashCode();\n+    }\n \n   /**\n    * Returns the type from super class's type parameter in {@link $Gson$Types#canonicalize\n    * canonical form}.\n    */\n-  static Type getSuperclassTypeParameter(Class<?> subclass) {\n-    Type superclass = subclass.getGenericSuperclass();\n-    if (superclass instanceof Class) {\n-      throw new RuntimeException(\"Missing type parameter.\");\n+\n+    static Type getSuperclassTypeParameter(Class<?> subclass) {\n+        Type superclass = subclass.getGenericSuperclass();\n+        if (superclass instanceof Class) {\n+            throw new RuntimeException(\"Missing type parameter.\");\n+        }\n+        ParameterizedType parameterized = (ParameterizedType) superclass;\n+        return $Gson$Types.canonicalize(parameterized.getActualTypeArguments()[0]);\n     }\n-    ParameterizedType parameterized = (ParameterizedType) superclass;\n-    return $Gson$Types.canonicalize(parameterized.getActualTypeArguments()[0]);\n-  }\n \n   /**\n    * Returns the raw (non-generic) type for this type.\n    */\n-  public final Class<? super T> getRawType() {\n-    return rawType;\n-  }\n+\n+    public final Class<? super T> getRawType() {\n+        return rawType;\n+    }\n \n   /**\n    * Gets underlying {@code Type} instance.\n    */\n-  public final Type getType() {\n-    return type;\n-  }\n+\n+    public final Type getType() {\n+        return type;\n+    }\n \n   /**\n    * Check if this type is assignable from the given class object.\n@@ -107,10 +113,11 @@ public class TypeToken<T> {\n    * @deprecated this implementation may be inconsistent with javac for types\n    *     with wildcards.\n    */\n-  @Deprecated\n-  public boolean isAssignableFrom(Class<?> cls) {\n-    return isAssignableFrom((Type) cls);\n-  }\n+\n+    @Deprecated\n+    public boolean isAssignableFrom(Class<?> cls) {\n+        return isAssignableFrom((Type) cls);\n+    }\n \n   /**\n    * Check if this type is assignable from the given Type.\n@@ -118,29 +125,25 @@ public class TypeToken<T> {\n    * @deprecated this implementation may be inconsistent with javac for types\n    *     with wildcards.\n    */\n-  @Deprecated\n-  public boolean isAssignableFrom(Type from) {\n-    if (from == null) {\n-      return false;\n-    }\n-\n-    if (type.equals(from)) {\n-      return true;\n-    }\n \n-    if (type instanceof Class<?>) {\n-      return rawType.isAssignableFrom($Gson$Types.getRawType(from));\n-    } else if (type instanceof ParameterizedType) {\n-      return isAssignableFrom(from, (ParameterizedType) type,\n-          new HashMap<String, Type>());\n-    } else if (type instanceof GenericArrayType) {\n-      return rawType.isAssignableFrom($Gson$Types.getRawType(from))\n-          && isAssignableFrom(from, (GenericArrayType) type);\n-    } else {\n-      throw buildUnexpectedTypeError(\n-          type, Class.class, ParameterizedType.class, GenericArrayType.class);\n+    @Deprecated\n+    public boolean isAssignableFrom(Type from) {\n+        if (from == null) {\n+            return false;\n+        }\n+        if (type.equals(from)) {\n+            return true;\n+        }\n+        if (type instanceof Class<?>) {\n+            return rawType.isAssignableFrom($Gson$Types.getRawType(from));\n+        } else if (type instanceof ParameterizedType) {\n+            return isAssignableFrom(from, (ParameterizedType) type, new HashMap<String, Type>());\n+        } else if (type instanceof GenericArrayType) {\n+                   return rawType.isAssignableFrom($Gson$Types.getRawType(from)) && isAssignableFrom(from, (GenericArrayType) type);\n+               } else {\n+            throw buildUnexpectedTypeError(type, Class.class, ParameterizedType.class, GenericArrayType.class);\n+        }\n     }\n-  }\n \n   /**\n    * Check if this type is assignable from the given type token.\n@@ -148,173 +151,171 @@ public class TypeToken<T> {\n    * @deprecated this implementation may be inconsistent with javac for types\n    *     with wildcards.\n    */\n-  @Deprecated\n-  public boolean isAssignableFrom(TypeToken<?> token) {\n-    return isAssignableFrom(token.getType());\n-  }\n+\n+    @Deprecated\n+    public boolean isAssignableFrom(TypeToken<?> token) {\n+        return isAssignableFrom(token.getType());\n+    }\n \n   /**\n    * Private helper function that performs some assignability checks for\n    * the provided GenericArrayType.\n    */\n-  private static boolean isAssignableFrom(Type from, GenericArrayType to) {\n-    Type toGenericComponentType = to.getGenericComponentType();\n-    if (toGenericComponentType instanceof ParameterizedType) {\n-      Type t = from;\n-      if (from instanceof GenericArrayType) {\n-        t = ((GenericArrayType) from).getGenericComponentType();\n-      } else if (from instanceof Class<?>) {\n-        Class<?> classType = (Class<?>) from;\n-        while (classType.isArray()) {\n-          classType = classType.getComponentType();\n+\n+    private static boolean isAssignableFrom(Type from, GenericArrayType to) {\n+        Type toGenericComponentType = to.getGenericComponentType();\n+        if (toGenericComponentType instanceof ParameterizedType) {\n+            Type t = from;\n+            if (from instanceof GenericArrayType) {\n+                t = ((GenericArrayType) from).getGenericComponentType();\n+            } else if (from instanceof Class<?>) {\n+                Class<?> classType = (Class<?>) from;\n+                while (classType.isArray()) {\n+                    classType = classType.getComponentType();\n+                }\n+                t = classType;\n+            }\n+            return isAssignableFrom(t, (ParameterizedType) toGenericComponentType, new HashMap<String, Type>());\n         }\n-        t = classType;\n-      }\n-      return isAssignableFrom(t, (ParameterizedType) toGenericComponentType,\n-          new HashMap<String, Type>());\n-    }\n     // No generic defined on \"to\"; therefore, return true and let other\n     // checks determine assignability\n-    return true;\n-  }\n+        return true;\n+    }\n \n   /**\n    * Private recursive helper function to actually do the type-safe checking\n    * of assignability.\n    */\n-  private static boolean isAssignableFrom(Type from, ParameterizedType to,\n-      Map<String, Type> typeVarMap) {\n-\n-    if (from == null) {\n-      return false;\n-    }\n \n-    if (to.equals(from)) {\n-      return true;\n-    }\n+    private static boolean isAssignableFrom(Type from, ParameterizedType to, Map<String, Type> typeVarMap) {\n+        if (from == null) {\n+            return false;\n+        }\n+        if (to.equals(from)) {\n+            return true;\n+        }\n \n     // First figure out the class and any type information.\n-    Class<?> clazz = $Gson$Types.getRawType(from);\n-    ParameterizedType ptype = null;\n-    if (from instanceof ParameterizedType) {\n-      ptype = (ParameterizedType) from;\n-    }\n+        Class<?> clazz = $Gson$Types.getRawType(from);\n+        ParameterizedType ptype = null;\n+        if (from instanceof ParameterizedType) {\n+            ptype = (ParameterizedType) from;\n+        }\n \n     // Load up parameterized variable info if it was parameterized.\n-    if (ptype != null) {\n-      Type[] tArgs = ptype.getActualTypeArguments();\n-      TypeVariable<?>[] tParams = clazz.getTypeParameters();\n-      for (int i = 0; i < tArgs.length; i++) {\n-        Type arg = tArgs[i];\n-        TypeVariable<?> var = tParams[i];\n-        while (arg instanceof TypeVariable<?>) {\n-          TypeVariable<?> v = (TypeVariable<?>) arg;\n-          arg = typeVarMap.get(v.getName());\n-        }\n-        typeVarMap.put(var.getName(), arg);\n-      }\n+        if (ptype != null) {\n+            Type[] tArgs = ptype.getActualTypeArguments();\n+            TypeVariable<?>[] tParams = clazz.getTypeParameters();\n+            for (int i = 0; i < tArgs.length; i++) {\n+                Type arg = tArgs[i];\n+                TypeVariable<?> var = tParams[i];\n+                while (arg instanceof TypeVariable<?>) {\n+                    TypeVariable<?> v = (TypeVariable<?>) arg;\n+                    arg = typeVarMap.get(v.getName());\n+                }\n+                typeVarMap.put(var.getName(), arg);\n+            }\n \n       // check if they are equivalent under our current mapping.\n-      if (typeEquals(ptype, to, typeVarMap)) {\n-        return true;\n-      }\n-    }\n-\n-    for (Type itype : clazz.getGenericInterfaces()) {\n-      if (isAssignableFrom(itype, to, new HashMap<String, Type>(typeVarMap))) {\n-        return true;\n-      }\n-    }\n+            if (typeEquals(ptype, to, typeVarMap)) {\n+                return true;\n+            }\n+        }\n+        for (Type itype : clazz.getGenericInterfaces()) {\n+            if (isAssignableFrom(itype, to, new HashMap<String, Type>(typeVarMap))) {\n+                return true;\n+            }\n+        }\n \n     // Interfaces didn't work, try the superclass.\n-    Type sType = clazz.getGenericSuperclass();\n-    return isAssignableFrom(sType, to, new HashMap<String, Type>(typeVarMap));\n-  }\n+        Type sType = clazz.getGenericSuperclass();\n+        return isAssignableFrom(sType, to, new HashMap<String, Type>(typeVarMap));\n+    }\n \n   /**\n    * Checks if two parameterized types are exactly equal, under the variable\n    * replacement described in the typeVarMap.\n    */\n-  private static boolean typeEquals(ParameterizedType from,\n-      ParameterizedType to, Map<String, Type> typeVarMap) {\n-    if (from.getRawType().equals(to.getRawType())) {\n-      Type[] fromArgs = from.getActualTypeArguments();\n-      Type[] toArgs = to.getActualTypeArguments();\n-      for (int i = 0; i < fromArgs.length; i++) {\n-        if (!matches(fromArgs[i], toArgs[i], typeVarMap)) {\n-          return false;\n+\n+    private static boolean typeEquals(ParameterizedType from, ParameterizedType to, Map<String, Type> typeVarMap) {\n+        if (from.getRawType().equals(to.getRawType())) {\n+            Type[] fromArgs = from.getActualTypeArguments();\n+            Type[] toArgs = to.getActualTypeArguments();\n+            for (int i = 0; i < fromArgs.length; i++) {\n+                if (!matches(fromArgs[i], toArgs[i], typeVarMap)) {\n+                    return false;\n+                }\n+            }\n+            return true;\n         }\n-      }\n-      return true;\n+        return false;\n     }\n-    return false;\n-  }\n \n-  private static AssertionError buildUnexpectedTypeError(\n-      Type token, Class<?>... expected) {\n+    private static AssertionError buildUnexpectedTypeError(Type token, Class<?>... expected) {\n \n     // Build exception message\n-    StringBuilder exceptionMessage =\n-        new StringBuilder(\"Unexpected type. Expected one of: \");\n-    for (Class<?> clazz : expected) {\n-      exceptionMessage.append(clazz.getName()).append(\", \");\n+        StringBuilder exceptionMessage = new StringBuilder(\"Unexpected type. Expected one of: \");\n+        for (Class<?> clazz : expected) {\n+            exceptionMessage.append(clazz.getName()).append(\", \");\n+        }\n+        exceptionMessage.append(\"but got: \").append(token.getClass().getName()).append(\", for type token: \").append(token.toString()).append('.');\n+        return new AssertionError(exceptionMessage.toString());\n     }\n-    exceptionMessage.append(\"but got: \").append(token.getClass().getName())\n-        .append(\", for type token: \").append(token.toString()).append('.');\n-\n-    return new AssertionError(exceptionMessage.toString());\n-  }\n \n   /**\n    * Checks if two types are the same or are equivalent under a variable mapping\n    * given in the type map that was provided.\n    */\n-  private static boolean matches(Type from, Type to, Map<String, Type> typeMap) {\n-    return to.equals(from)\n-        || (from instanceof TypeVariable\n-        && to.equals(typeMap.get(((TypeVariable<?>) from).getName())));\n \n-  }\n+    private static boolean matches(Type from, Type to, Map<String, Type> typeMap) {\n+        return to.equals(from) || (from instanceof TypeVariable && to.equals(typeMap.get(((TypeVariable<?>) from).getName())));\n+    }\n \n-  @Override public final int hashCode() {\n-    return this.hashCode;\n-  }\n+    @Override\n+    public final int hashCode() {\n+        return this.hashCode;\n+    }\n \n-  @Override public final boolean equals(Object o) {\n-    return o instanceof TypeToken<?>\n-        && $Gson$Types.equals(type, ((TypeToken<?>) o).type);\n-  }\n+    @Override\n+    public final boolean equals(Object o) {\n+        return o instanceof TypeToken<?> && $Gson$Types.equals(type, ((TypeToken<?>) o).type);\n+    }\n \n-  @Override public final String toString() {\n-    return $Gson$Types.typeToString(type);\n-  }\n+    @Override\n+    public final String toString() {\n+        return $Gson$Types.typeToString(type);\n+    }\n \n   /**\n    * Gets type literal for the given {@code Type} instance.\n    */\n-  public static TypeToken<?> get(Type type) {\n-    return new TypeToken<Object>(type);\n-  }\n+\n+    public static TypeToken<?> get(Type type) {\n+        return new TypeToken<Object>(type);\n+    }\n \n   /**\n    * Gets type literal for the given {@code Class} instance.\n    */\n-  public static <T> TypeToken<T> get(Class<T> type) {\n-    return new TypeToken<T>(type);\n-  }\n+\n+    public static <T> TypeToken<T> get(Class<T> type) {\n+        return new TypeToken<T>(type);\n+    }\n \n   /**\n    * Gets type literal for the parameterized type represented by applying {@code typeArguments} to\n    * {@code rawType}.\n    */\n-  public static TypeToken<?> getParameterized(Type rawType, Type... typeArguments) {\n-    return new TypeToken<Object>($Gson$Types.newParameterizedTypeWithOwner(null, rawType, typeArguments));\n-  }\n+\n+    public static TypeToken<?> getParameterized(Type rawType, Type... typeArguments) {\n+        return new TypeToken<Object>($Gson$Types.newParameterizedTypeWithOwner(null, rawType, typeArguments));\n+    }\n \n   /**\n    * Gets type literal for the array type whose elements are all instances of {@code componentType}.\n    */\n-  public static TypeToken<?> getArray(Type componentType) {\n-    return new TypeToken<Object>($Gson$Types.arrayOf(componentType));\n-  }\n-}\n+\n+    public static TypeToken<?> getArray(Type componentType) {\n+        return new TypeToken<Object>($Gson$Types.arrayOf(componentType));\n+    }\n+}\n\\ No newline at end of file\n",
            "diff_size": 203
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/errored/1/42/TypeToken.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/styler_random/42/TypeToken.java\nindex 3fb8af2bcfb..9998e34cff2 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/errored/1/42/TypeToken.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/styler_random/42/TypeToken.java\n@@ -259,8 +259,7 @@ public class TypeToken<T> {\n     for (Class<?> clazz : expected) {\n       exceptionMessage.append(clazz.getName()).append(\", \");\n     }\n-    exceptionMessage.append(\"but got: \").append(token.getClass().getName())\n-        .append(\", for type token: \").append(token.toString()).append('.');\n+    exceptionMessage.append(\"but got: \").append(token.getClass().getName()).append(\", for type token: \").append(token.toString()).append('.');\n \n     return new AssertionError(exceptionMessage.toString());\n   }\n",
            "diff_size": 2
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/errored/1/42/TypeToken.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/styler_three_grams/42/TypeToken.java\nindex 3fb8af2bcfb..9998e34cff2 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/errored/1/42/TypeToken.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/styler_three_grams/42/TypeToken.java\n@@ -259,8 +259,7 @@ public class TypeToken<T> {\n     for (Class<?> clazz : expected) {\n       exceptionMessage.append(clazz.getName()).append(\", \");\n     }\n-    exceptionMessage.append(\"but got: \").append(token.getClass().getName())\n-        .append(\", for type token: \").append(token.toString()).append('.');\n+    exceptionMessage.append(\"but got: \").append(token.getClass().getName()).append(\", for type token: \").append(token.toString()).append('.');\n \n     return new AssertionError(exceptionMessage.toString());\n   }\n",
            "diff_size": 2
        }
    ],
    "repaired_by": [
        "styler",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "intellij"
    ]
}