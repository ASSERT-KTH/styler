{
    "project_name": "codefollower-H2-Research",
    "error_id": "480",
    "information": {
        "errors": [
            {
                "line": "218",
                "column": "23",
                "severity": "warning",
                "message": "File contains tab characters (this is the first instance).",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
            }
        ]
    },
    "source_code": "//                } else {\n//                    if ((mask & IndexCondition.START) != 0) {\n//                    \t//\u4f8b\u5982:sql = \"select * from my_view where f2 > 'b1'\";\n//                    \t//\u5b9e\u9645\u662fSELECT ID, NAME FROM CreateViewTest WHERE NAME >= ?1\n//                    \t//\u5728org.h2.index.IndexCondition.getMask(ArrayList<IndexCondition>)\u90a3\u91cc\u628a\n//                    \t//BIGGER_EQUAL\u3001BIGGER\u90fd\u5f53\u6210\u4e86START\uff0c\u800c\u8fd9\u91cc\u7edf\u4e00\u8f6c\u6210BIGGER_EQUAL\uff0c\u5f53view\u8981\u8fc7\u6ee4\u8bb0\u5f55\u65f6\u518d\u6309\u5927\u4e8e\u8fc7\u6ee4",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "218",
                    "column": "23",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "219",
                    "column": "23",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                },
                {
                    "line": "473",
                    "column": "30",
                    "severity": "warning",
                    "message": "';' is followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.EmptyForIteratorPadCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/480/ViewIndex.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/480/ViewIndex.java\nindex 9247200fc15..b2c0fac5c59 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/480/ViewIndex.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/480/ViewIndex.java\n@@ -3,6 +3,7 @@\n  * and the EPL 1.0 (https://h2database.com/html/license.html).\n  * Initial Developer: H2 Group\n  */\n+\n package org.h2.index;\n \n import java.util.ArrayList;\n@@ -38,117 +39,117 @@ import org.h2.value.Value;\n  */\n public class ViewIndex extends BaseIndex implements SpatialIndex {\n \n-    private static final long MAX_AGE_NANOS =\n-            TimeUnit.MILLISECONDS.toNanos(Constants.VIEW_COST_CACHE_MAX_AGE);\n-\n-    private final TableView view;\n-    private final String querySQL;\n-    private final ArrayList<Parameter> originalParameters;\n-    private boolean recursive;\n-    private final int[] indexMasks;\n-    private Query query;\n-    private final Session createSession;\n-\n-    /**\n-     * The time in nanoseconds when this index (and its cost) was calculated.\n-     */\n-    private final long evaluatedAt;\n-\n-    /**\n-     * Constructor for the original index in {@link TableView}.\n-     *\n-     * @param view the table view\n-     * @param querySQL the query SQL\n-     * @param originalParameters the original parameters\n-     * @param recursive if the view is recursive\n-     */\n-    public ViewIndex(TableView view, String querySQL,\n-            ArrayList<Parameter> originalParameters, boolean recursive) {\n-        super(view, 0, null, null, IndexType.createNonUnique(false));\n-        this.view = view;\n-        this.querySQL = querySQL;\n-        this.originalParameters = originalParameters;\n-        this.recursive = recursive;\n-        columns = new Column[0];\n-        this.createSession = null;\n-        this.indexMasks = null;\n-        // this is a main index of TableView, it does not need eviction time\n-        // stamp\n-        evaluatedAt = Long.MIN_VALUE;\n-    }\n-\n-    /**\n-     * Constructor for plan item generation. Over this index the query will be\n-     * executed.\n-     *\n-     * @param view the table view\n-     * @param index the view index\n-     * @param session the session\n-     * @param masks the masks\n-     * @param filters table filters\n-     * @param filter current filter\n-     * @param sortOrder sort order\n-     */\n-    public ViewIndex(TableView view, ViewIndex index, Session session,\n-            int[] masks, TableFilter[] filters, int filter, SortOrder sortOrder) {\n-        super(view, 0, null, null, IndexType.createNonUnique(false));\n-        this.view = view;\n-        this.querySQL = index.querySQL;\n-        this.originalParameters = index.originalParameters;\n-        this.recursive = index.recursive;\n-        this.indexMasks = masks;\n-        this.createSession = session;\n-        columns = new Column[0];\n-        if (!recursive) {\n-            query = getQuery(session, masks, filters, filter, sortOrder);\n-        }\n-        // we don't need eviction for recursive views since we can't calculate\n-        // their cost if it is a sub-query we don't need eviction as well\n-        // because the whole ViewIndex cache is getting dropped in\n-        // Session.prepareLocal\n-        evaluatedAt = recursive || view.getTopQuery() != null ? Long.MAX_VALUE : System.nanoTime();\n-    }\n-\n-    @Override\n-    public IndexLookupBatch createLookupBatch(TableFilter[] filters, int filter) {\n-        if (recursive) {\n-            // we do not support batching for recursive queries\n-            return null;\n-        }\n-        return JoinBatch.createViewIndexLookupBatch(this);\n-    }\n-\n-    public Session getSession() {\n-        return createSession;\n-    }\n-\n-    public boolean isExpired() {\n-        assert evaluatedAt != Long.MIN_VALUE : \"must not be called for main index of TableView\";\n-        return !recursive && view.getTopQuery() == null &&\n-                System.nanoTime() - evaluatedAt > MAX_AGE_NANOS;\n-    }\n-\n-    @Override\n-    public String getPlanSQL() {\n-        return query == null ? null : query.getPlanSQL(false);\n-    }\n-\n-    @Override\n-    public void close(Session session) {\n-        // nothing to do\n+  private static final long MAX_AGE_NANOS =\n+      TimeUnit.MILLISECONDS.toNanos(Constants.VIEW_COST_CACHE_MAX_AGE);\n+\n+  private final TableView view;\n+  private final String querySQL;\n+  private final ArrayList<Parameter> originalParameters;\n+  private boolean recursive;\n+  private final int[] indexMasks;\n+  private Query query;\n+  private final Session createSession;\n+\n+  /**\n+   * The time in nanoseconds when this index (and its cost) was calculated.\n+   */\n+  private final long evaluatedAt;\n+\n+  /**\n+   * Constructor for the original index in {@link TableView}.\n+   *\n+   * @param view               the table view\n+   * @param querySQL           the query SQL\n+   * @param originalParameters the original parameters\n+   * @param recursive          if the view is recursive\n+   */\n+  public ViewIndex(TableView view, String querySQL,\n+                   ArrayList<Parameter> originalParameters, boolean recursive) {\n+    super(view, 0, null, null, IndexType.createNonUnique(false));\n+    this.view = view;\n+    this.querySQL = querySQL;\n+    this.originalParameters = originalParameters;\n+    this.recursive = recursive;\n+    columns = new Column[0];\n+    this.createSession = null;\n+    this.indexMasks = null;\n+    // this is a main index of TableView, it does not need eviction time\n+    // stamp\n+    evaluatedAt = Long.MIN_VALUE;\n+  }\n+\n+  /**\n+   * Constructor for plan item generation. Over this index the query will be\n+   * executed.\n+   *\n+   * @param view      the table view\n+   * @param index     the view index\n+   * @param session   the session\n+   * @param masks     the masks\n+   * @param filters   table filters\n+   * @param filter    current filter\n+   * @param sortOrder sort order\n+   */\n+  public ViewIndex(TableView view, ViewIndex index, Session session,\n+                   int[] masks, TableFilter[] filters, int filter, SortOrder sortOrder) {\n+    super(view, 0, null, null, IndexType.createNonUnique(false));\n+    this.view = view;\n+    this.querySQL = index.querySQL;\n+    this.originalParameters = index.originalParameters;\n+    this.recursive = index.recursive;\n+    this.indexMasks = masks;\n+    this.createSession = session;\n+    columns = new Column[0];\n+    if (!recursive) {\n+      query = getQuery(session, masks, filters, filter, sortOrder);\n     }\n-\n-    @Override\n-    public void add(Session session, Row row) {\n-        throw DbException.getUnsupportedException(\"VIEW\");\n-    }\n-\n-    @Override\n-    public void remove(Session session, Row row) {\n-        throw DbException.getUnsupportedException(\"VIEW\");\n+    // we don't need eviction for recursive views since we can't calculate\n+    // their cost if it is a sub-query we don't need eviction as well\n+    // because the whole ViewIndex cache is getting dropped in\n+    // Session.prepareLocal\n+    evaluatedAt = recursive || view.getTopQuery() != null ? Long.MAX_VALUE : System.nanoTime();\n+  }\n+\n+  @Override\n+  public IndexLookupBatch createLookupBatch(TableFilter[] filters, int filter) {\n+    if (recursive) {\n+      // we do not support batching for recursive queries\n+      return null;\n     }\n-\n-//<<<<<<< HEAD\n+    return JoinBatch.createViewIndexLookupBatch(this);\n+  }\n+\n+  public Session getSession() {\n+    return createSession;\n+  }\n+\n+  public boolean isExpired() {\n+    assert evaluatedAt != Long.MIN_VALUE : \"must not be called for main index of TableView\";\n+    return !recursive && view.getTopQuery() == null &&\n+        System.nanoTime() - evaluatedAt > MAX_AGE_NANOS;\n+  }\n+\n+  @Override\n+  public String getPlanSQL() {\n+    return query == null ? null : query.getPlanSQL(false);\n+  }\n+\n+  @Override\n+  public void close(Session session) {\n+    // nothing to do\n+  }\n+\n+  @Override\n+  public void add(Session session, Row row) {\n+    throw DbException.getUnsupportedException(\"VIEW\");\n+  }\n+\n+  @Override\n+  public void remove(Session session, Row row) {\n+    throw DbException.getUnsupportedException(\"VIEW\");\n+  }\n+\n+  //<<<<<<< HEAD\n //    /**\n //     * A calculated cost value.\n //     */\n@@ -239,38 +240,38 @@ public class ViewIndex extends BaseIndex implements SpatialIndex {\n //        costCache.put(masksArray, cachedCost);\n //        return cost;\n //=======\n-    @Override\n-    public double getCost(Session session, int[] masks,\n-            TableFilter[] filters, int filter, SortOrder sortOrder,\n-            AllColumnsForPlan allColumnsSet) {\n-        return recursive ? 1000 : query.getCost();\n+  @Override\n+  public double getCost(Session session, int[] masks,\n+                        TableFilter[] filters, int filter, SortOrder sortOrder,\n+                        AllColumnsForPlan allColumnsSet) {\n+    return recursive ? 1000 : query.getCost();\n+  }\n+\n+  @Override\n+  public Cursor find(Session session, SearchRow first, SearchRow last) {\n+    return find(session, first, last, null);\n+  }\n+\n+  @Override\n+  public Cursor findByGeometry(TableFilter filter, SearchRow first,\n+                               SearchRow last, SearchRow intersection) {\n+    return find(filter.getSession(), first, last, intersection);\n+  }\n+\n+  private static Query prepareSubQuery(String sql, Session session, int[] masks,\n+                                       TableFilter[] filters, int filter, SortOrder sortOrder) {\n+    Prepared p;\n+    session.pushSubQueryInfo(masks, filters, filter, sortOrder);\n+    try {\n+      p = session.prepare(sql, true, true);\n+    } finally {\n+      session.popSubQueryInfo();\n     }\n+    return (Query) p;\n+  }\n \n-    @Override\n-    public Cursor find(Session session, SearchRow first, SearchRow last) {\n-        return find(session, first, last, null);\n-    }\n-\n-    @Override\n-    public Cursor findByGeometry(TableFilter filter, SearchRow first,\n-            SearchRow last, SearchRow intersection) {\n-        return find(filter.getSession(), first, last, intersection);\n-    }\n-\n-    private static Query prepareSubQuery(String sql, Session session, int[] masks,\n-            TableFilter[] filters, int filter, SortOrder sortOrder) {\n-        Prepared p;\n-        session.pushSubQueryInfo(masks, filters, filter, sortOrder);\n-        try {\n-            p = session.prepare(sql, true, true);\n-        } finally {\n-            session.popSubQueryInfo();\n-        }\n-        return (Query) p;\n-    }\n-\n-    private Cursor findRecursive(SearchRow first, SearchRow last) {\n-        assert recursive;\n+  private Cursor findRecursive(SearchRow first, SearchRow last) {\n+    assert recursive;\n //<<<<<<< HEAD\n //        // \u5982 WITH RECURSIVE my_tmp_table(f1,f2)\n //        // AS(select id,name from CreateViewTest UNION ALL select 1, 2) select f1, f2 from my_tmp_table\n@@ -280,43 +281,43 @@ public class ViewIndex extends BaseIndex implements SpatialIndex {\n //            recResult.reset();\n //            return new ViewCursor(this, recResult, first, last);\n //=======\n-        ResultInterface recursiveResult = view.getRecursiveResult();\n-        if (recursiveResult != null) {\n-            recursiveResult.reset();\n-            return new ViewCursor(this, recursiveResult, first, last);\n-        }\n-        if (query == null) {\n-            Parser parser = new Parser(createSession);\n-            parser.setRightsChecked(true);\n-            parser.setSuppliedParameterList(originalParameters);\n-            query = (Query) parser.prepare(querySQL);\n-            query.setNeverLazy(true);\n-        }\n-        if (!query.isUnion()) {\n-            throw DbException.get(ErrorCode.SYNTAX_ERROR_2,\n-                    \"recursive queries without UNION\");\n-        }\n-        SelectUnion union = (SelectUnion) query;\n-        Query left = union.getLeft();\n-        left.setNeverLazy(true);\n-        // to ensure the last result is not closed\n-        left.disableCache();\n-        ResultInterface resultInterface = left.query(0);\n-        LocalResult localResult = union.getEmptyResult();\n-        // ensure it is not written to disk,\n-        // because it is not closed normally\n-        localResult.setMaxMemoryRows(Integer.MAX_VALUE);\n-        while (resultInterface.next()) {\n-            Value[] cr = resultInterface.currentRow();\n-            localResult.addRow(cr);\n-        }\n-        Query right = union.getRight();\n-        right.setNeverLazy(true);\n-        resultInterface.reset();\n-        view.setRecursiveResult(resultInterface);\n-        // to ensure the last result is not closed\n-        right.disableCache();\n-        while (true) {\n+    ResultInterface recursiveResult = view.getRecursiveResult();\n+    if (recursiveResult != null) {\n+      recursiveResult.reset();\n+      return new ViewCursor(this, recursiveResult, first, last);\n+    }\n+    if (query == null) {\n+      Parser parser = new Parser(createSession);\n+      parser.setRightsChecked(true);\n+      parser.setSuppliedParameterList(originalParameters);\n+      query = (Query) parser.prepare(querySQL);\n+      query.setNeverLazy(true);\n+    }\n+    if (!query.isUnion()) {\n+      throw DbException.get(ErrorCode.SYNTAX_ERROR_2,\n+          \"recursive queries without UNION\");\n+    }\n+    SelectUnion union = (SelectUnion) query;\n+    Query left = union.getLeft();\n+    left.setNeverLazy(true);\n+    // to ensure the last result is not closed\n+    left.disableCache();\n+    ResultInterface resultInterface = left.query(0);\n+    LocalResult localResult = union.getEmptyResult();\n+    // ensure it is not written to disk,\n+    // because it is not closed normally\n+    localResult.setMaxMemoryRows(Integer.MAX_VALUE);\n+    while (resultInterface.next()) {\n+      Value[] cr = resultInterface.currentRow();\n+      localResult.addRow(cr);\n+    }\n+    Query right = union.getRight();\n+    right.setNeverLazy(true);\n+    resultInterface.reset();\n+    view.setRecursiveResult(resultInterface);\n+    // to ensure the last result is not closed\n+    right.disableCache();\n+    while (true) {\n //<<<<<<< HEAD\n //            // \u5982 WITH RECURSIVE my_tmp_table(f1,f2)\n //            // AS(select id,name from CreateViewTest UNION ALL select 1, 2) select f1, f2 from my_tmp_table\n@@ -325,14 +326,14 @@ public class ViewIndex extends BaseIndex implements SpatialIndex {\n //            r = right.query(0);\n //            if (!r.hasNext()) {\n //=======\n-            resultInterface = right.query(0);\n-            if (!resultInterface.hasNext()) {\n-                break;\n-            }\n-            while (resultInterface.next()) {\n-                Value[] cr = resultInterface.currentRow();\n-                localResult.addRow(cr);\n-            }\n+      resultInterface = right.query(0);\n+      if (!resultInterface.hasNext()) {\n+        break;\n+      }\n+      while (resultInterface.next()) {\n+        Value[] cr = resultInterface.currentRow();\n+        localResult.addRow(cr);\n+      }\n //<<<<<<< HEAD\n //            r.reset();\n //            view.setRecursiveResult(r);\n@@ -342,111 +343,111 @@ public class ViewIndex extends BaseIndex implements SpatialIndex {\n //                break;\n //            }\n //=======\n-            resultInterface.reset();\n-            view.setRecursiveResult(resultInterface);\n-        }\n-        view.setRecursiveResult(null);\n-        localResult.done();\n-        return new ViewCursor(this, localResult, first, last);\n+      resultInterface.reset();\n+      view.setRecursiveResult(resultInterface);\n     }\n-\n-    /**\n-     * Set the query parameters.\n-     *\n-     * @param session the session\n-     * @param first the lower bound\n-     * @param last the upper bound\n-     * @param intersection the intersection\n-     */\n-    public void setupQueryParameters(Session session, SearchRow first, SearchRow last,\n-            SearchRow intersection) {\n-        ArrayList<Parameter> paramList = query.getParameters();\n-        if (originalParameters != null) {\n-            for (Parameter orig : originalParameters) {\n-                int idx = orig.getIndex();\n-                Value value = orig.getValue(session);\n-                setParameter(paramList, idx, value);\n-            }\n-        }\n-        int len;\n-        if (first != null) {\n-            len = first.getColumnCount();\n-        } else if (last != null) {\n-            len = last.getColumnCount();\n-        } else if (intersection != null) {\n-            len = intersection.getColumnCount();\n-        } else {\n-            len = 0;\n-        }\n-        //view\u4e2d\u5df2\u7ed9select\u52a0\u4e86\u5916\u90e8\u6761\u4ef6\uff0c\u6240\u4ee5\u591a\u4e86Parameter\uff0c\u8fd9\u91cc\u5c31\u662f\u7ed9\u8fd9\u4e9bParameter\u8d4b\u503c\n-        int idx = view.getParameterOffset(originalParameters);\n-        for (int i = 0; i < len; i++) {\n-            int mask = indexMasks[i];\n-            if ((mask & IndexCondition.EQUALITY) != 0) {\n-                setParameter(paramList, idx++, first.getValue(i));\n-            }\n-            if ((mask & IndexCondition.START) != 0) {\n-                setParameter(paramList, idx++, first.getValue(i));\n-            }\n-            if ((mask & IndexCondition.END) != 0) {\n-                setParameter(paramList, idx++, last.getValue(i));\n-            }\n-            if ((mask & IndexCondition.SPATIAL_INTERSECTS) != 0) {\n-                setParameter(paramList, idx++, intersection.getValue(i));\n-            }\n-        }\n+    view.setRecursiveResult(null);\n+    localResult.done();\n+    return new ViewCursor(this, localResult, first, last);\n+  }\n+\n+  /**\n+   * Set the query parameters.\n+   *\n+   * @param session      the session\n+   * @param first        the lower bound\n+   * @param last         the upper bound\n+   * @param intersection the intersection\n+   */\n+  public void setupQueryParameters(Session session, SearchRow first, SearchRow last,\n+                                   SearchRow intersection) {\n+    ArrayList<Parameter> paramList = query.getParameters();\n+    if (originalParameters != null) {\n+      for (Parameter orig : originalParameters) {\n+        int idx = orig.getIndex();\n+        Value value = orig.getValue(session);\n+        setParameter(paramList, idx, value);\n+      }\n     }\n-\n-    private Cursor find(Session session, SearchRow first, SearchRow last,\n-            SearchRow intersection) {\n-        if (recursive) {\n-            return findRecursive(first, last);\n-        }\n-        setupQueryParameters(session, first, last, intersection);\n-        ResultInterface result = query.query(0);\n-        return new ViewCursor(this, result, first, last);\n+    int len;\n+    if (first != null) {\n+      len = first.getColumnCount();\n+    } else if (last != null) {\n+      len = last.getColumnCount();\n+    } else if (intersection != null) {\n+      len = intersection.getColumnCount();\n+    } else {\n+      len = 0;\n     }\n-\n-    private static void setParameter(ArrayList<Parameter> paramList, int x,\n-            Value v) {\n-        if (x >= paramList.size()) {\n-            // the parameter may be optimized away as in\n-            // select * from (select null as x) where x=1;\n-            return;\n-        }\n-        Parameter param = paramList.get(x);\n-        param.setValue(v);\n+    //view\u4e2d\u5df2\u7ed9select\u52a0\u4e86\u5916\u90e8\u6761\u4ef6\uff0c\u6240\u4ee5\u591a\u4e86Parameter\uff0c\u8fd9\u91cc\u5c31\u662f\u7ed9\u8fd9\u4e9bParameter\u8d4b\u503c\n+    int idx = view.getParameterOffset(originalParameters);\n+    for (int i = 0; i < len; i++) {\n+      int mask = indexMasks[i];\n+      if ((mask & IndexCondition.EQUALITY) != 0) {\n+        setParameter(paramList, idx++, first.getValue(i));\n+      }\n+      if ((mask & IndexCondition.START) != 0) {\n+        setParameter(paramList, idx++, first.getValue(i));\n+      }\n+      if ((mask & IndexCondition.END) != 0) {\n+        setParameter(paramList, idx++, last.getValue(i));\n+      }\n+      if ((mask & IndexCondition.SPATIAL_INTERSECTS) != 0) {\n+        setParameter(paramList, idx++, intersection.getValue(i));\n+      }\n     }\n+  }\n \n-    public Query getQuery() {\n-        return query;\n+  private Cursor find(Session session, SearchRow first, SearchRow last,\n+                      SearchRow intersection) {\n+    if (recursive) {\n+      return findRecursive(first, last);\n     }\n-\n-    // \u76ee\u7684\u662f\u4e3a\u4e86\u5bf9indexColumns\u8d4b\u503c\uff0cindexColumns\u53e6\u6709\u5b83\u7528\n-    // \u6bd4\u5982\u5728org.h2.command.dml.Select.prepare()\u4e2d\u5c31\u6709\u5e94\u7528(cost = preparePlan\u90a3\u884c\u4ee3\u7801\u4e4b\u540e)\n-    private Query getQuery(Session session, int[] masks,\n-            TableFilter[] filters, int filter, SortOrder sortOrder) {\n-        Query q = prepareSubQuery(querySQL, session, masks, filters, filter, sortOrder);\n-        if (masks == null) {\n-            return q;\n-        }\n-        //\u6bd4\u5982AS SELECT top 2 id,name FROM CreateViewTest order by id\n-        //limitExpr\u548csort\u90fd\u4e0d\u4e3a\u7a7a\uff0c\u6b64\u65f6\u4e0d\u5141\u8bb8\u52a0\u5168\u5c40\u6761\u4ef6\u5230select\u4e2d\n-        if (!q.allowGlobalConditions()) {\n-            return q;\n-        }\n-        int firstIndexParam = view.getParameterOffset(originalParameters);\n-        // the column index of each parameter\n-        // (for example: paramColumnIndex {0, 0} mean\n-        // param[0] is column 0, and param[1] is also column 0)\n-        IntArray paramColumnIndex = new IntArray();\n-        int indexColumnCount = 0;\n-        for (int i = 0; i < masks.length; i++) {\n-            int mask = masks[i];\n-            if (mask == 0) {\n-                continue;\n-            }\n-            indexColumnCount++;\n+    setupQueryParameters(session, first, last, intersection);\n+    ResultInterface result = query.query(0);\n+    return new ViewCursor(this, result, first, last);\n+  }\n+\n+  private static void setParameter(ArrayList<Parameter> paramList, int x,\n+                                   Value v) {\n+    if (x >= paramList.size()) {\n+      // the parameter may be optimized away as in\n+      // select * from (select null as x) where x=1;\n+      return;\n+    }\n+    Parameter param = paramList.get(x);\n+    param.setValue(v);\n+  }\n+\n+  public Query getQuery() {\n+    return query;\n+  }\n+\n+  // \u76ee\u7684\u662f\u4e3a\u4e86\u5bf9indexColumns\u8d4b\u503c\uff0cindexColumns\u53e6\u6709\u5b83\u7528\n+  // \u6bd4\u5982\u5728org.h2.command.dml.Select.prepare()\u4e2d\u5c31\u6709\u5e94\u7528(cost = preparePlan\u90a3\u884c\u4ee3\u7801\u4e4b\u540e)\n+  private Query getQuery(Session session, int[] masks,\n+                         TableFilter[] filters, int filter, SortOrder sortOrder) {\n+    Query q = prepareSubQuery(querySQL, session, masks, filters, filter, sortOrder);\n+    if (masks == null) {\n+      return q;\n+    }\n+    //\u6bd4\u5982AS SELECT top 2 id,name FROM CreateViewTest order by id\n+    //limitExpr\u548csort\u90fd\u4e0d\u4e3a\u7a7a\uff0c\u6b64\u65f6\u4e0d\u5141\u8bb8\u52a0\u5168\u5c40\u6761\u4ef6\u5230select\u4e2d\n+    if (!q.allowGlobalConditions()) {\n+      return q;\n+    }\n+    int firstIndexParam = view.getParameterOffset(originalParameters);\n+    // the column index of each parameter\n+    // (for example: paramColumnIndex {0, 0} mean\n+    // param[0] is column 0, and param[1] is also column 0)\n+    IntArray paramColumnIndex = new IntArray();\n+    int indexColumnCount = 0;\n+    for (int i = 0; i < masks.length; i++) {\n+      int mask = masks[i];\n+      if (mask == 0) {\n+        continue;\n+      }\n+      indexColumnCount++;\n //<<<<<<< HEAD\n //            paramIndex.add(i);\n //            //\u4e3a1\u7684bit\u4e2a\u6570\uff0c\u6bd4\u5982mask=3\u65f6\uff0c\u5c31\u662f0011\uff0c\u6240\u4ee5bitCount=2\n@@ -459,132 +460,132 @@ public class ViewIndex extends BaseIndex implements SpatialIndex {\n //        }\n //        int len = paramIndex.size(); //paramIndex\u4e2d\u653e\u7684\u662f\u5217id\n //=======\n-            // the number of parameters depends on the mask;\n-            // for range queries it is 2: >= x AND <= y\n-            // but bitMask could also be 7 (=, and <=, and >=)\n-            int bitCount = Integer.bitCount(mask);\n-            for (int j = 0; j < bitCount; j++) {\n-                paramColumnIndex.add(i);\n-            }\n-        }\n-        int len = paramColumnIndex.size();\n-        ArrayList<Column> columnList = new ArrayList<>(len);\n-        for (int i = 0; i < len;) {\n-            int idx = paramColumnIndex.get(i);\n-            columnList.add(table.getColumn(idx));\n-            int mask = masks[idx];\n-            if ((mask & IndexCondition.EQUALITY) != 0) {\n-                Parameter param = new Parameter(firstIndexParam + i);\n-                q.addGlobalCondition(param, idx, Comparison.EQUAL_NULL_SAFE);\n-                i++;\n-            }\n-            if ((mask & IndexCondition.START) != 0) {\n-                Parameter param = new Parameter(firstIndexParam + i);\n-                q.addGlobalCondition(param, idx, Comparison.BIGGER_EQUAL);\n-                i++;\n-            }\n-            if ((mask & IndexCondition.END) != 0) {\n-                Parameter param = new Parameter(firstIndexParam + i);\n-                q.addGlobalCondition(param, idx, Comparison.SMALLER_EQUAL);\n-                i++;\n-            }\n-            if ((mask & IndexCondition.SPATIAL_INTERSECTS) != 0) {\n-                Parameter param = new Parameter(firstIndexParam + i);\n-                q.addGlobalCondition(param, idx, Comparison.SPATIAL_INTERSECTS);\n-                i++;\n-            }\n-        }\n-        columns = columnList.toArray(new Column[0]);\n-\n-        // reconstruct the index columns from the masks\n-        this.indexColumns = new IndexColumn[indexColumnCount];\n-        this.columnIds = new int[indexColumnCount];\n-        //type\u4ece0\u52301\uff0c\u4e5f\u5c31\u662f\u5faa\u73af\u4e24\u6b21\u8fd0\u884c\u5b50\u5faa\u73af\n-        //\u5f53type\u4e3a0\u65f6\uff0c\u53ea\u53d6where\u6761\u4ef6\u4e2d\u7684\"\u7b49\u4e8e\"\u5173\u7cfb\u8868\u8fbe\u5f0f\n-        //\u5f53type\u4e3a1\u65f6\uff0c\u53ea\u53d6where\u6761\u4ef6\u4e2d\u7684\u9664\"\u7b49\u4e8e\"\u5173\u7cfb\u8868\u8fbe\u5f0f\u4e4b\u4e0a\u7684\u8868\u8fbe\u5f0f\n-        //\u5982select * from my_view where f1=2 and f2 between 'b1' and 'b2'\n-        //\u5f53type\u4e3a0\u65f6\uff0c\u53ea\u53d6f1=2\n-        //\u5f53type\u4e3a1\u65f6\uff0c\u53ea\u53d6f2 between 'b1' and 'b2'\n-        for (int type = 0, indexColumnId = 0; type < 2; type++) {\n-            for (int i = 0; i < masks.length; i++) {\n-                int mask = masks[i];\n-                if (mask == 0) {\n-                    continue;\n-                }\n-                if (type == 0) {\n-                    if ((mask & IndexCondition.EQUALITY) == 0) {\n-                        // the first columns need to be equality conditions\n-                        continue;\n-                    }\n-                } else {\n-                    if ((mask & IndexCondition.EQUALITY) != 0) {\n-                        // after that only range conditions\n-                        continue;\n-                    }\n-                }\n-                IndexColumn c = new IndexColumn();\n-                c.column = table.getColumn(i);\n-                indexColumns[indexColumnId] = c;\n-                columnIds[indexColumnId] = c.column.getColumnId();\n-                indexColumnId++;\n-            }\n-        }\n-\n-        String sql = q.getPlanSQL(true);\n-        q = prepareSubQuery(sql, session, masks, filters, filter, sortOrder);\n-        return q;\n-    }\n-\n-    @Override\n-    public void remove(Session session) {\n-        throw DbException.getUnsupportedException(\"VIEW\");\n-    }\n-\n-    @Override\n-    public void truncate(Session session) {\n-        throw DbException.getUnsupportedException(\"VIEW\");\n-    }\n-\n-    @Override\n-    public void checkRename() {\n-        throw DbException.getUnsupportedException(\"VIEW\");\n-    }\n-\n-    @Override\n-    public boolean needRebuild() {\n-        return false;\n+      // the number of parameters depends on the mask;\n+      // for range queries it is 2: >= x AND <= y\n+      // but bitMask could also be 7 (=, and <=, and >=)\n+      int bitCount = Integer.bitCount(mask);\n+      for (int j = 0; j < bitCount; j++) {\n+        paramColumnIndex.add(i);\n+      }\n     }\n-\n-    @Override\n-    public boolean canGetFirstOrLast() {\n-        return false;\n-    }\n-\n-    @Override\n-    public Cursor findFirstOrLast(Session session, boolean first) {\n-        throw DbException.getUnsupportedException(\"VIEW\");\n-    }\n-\n-    public void setRecursive(boolean value) {\n-        this.recursive = value;\n+    int len = paramColumnIndex.size();\n+    ArrayList<Column> columnList = new ArrayList<>(len);\n+    for (int i = 0; i < len; ) {\n+      int idx = paramColumnIndex.get(i);\n+      columnList.add(table.getColumn(idx));\n+      int mask = masks[idx];\n+      if ((mask & IndexCondition.EQUALITY) != 0) {\n+        Parameter param = new Parameter(firstIndexParam + i);\n+        q.addGlobalCondition(param, idx, Comparison.EQUAL_NULL_SAFE);\n+        i++;\n+      }\n+      if ((mask & IndexCondition.START) != 0) {\n+        Parameter param = new Parameter(firstIndexParam + i);\n+        q.addGlobalCondition(param, idx, Comparison.BIGGER_EQUAL);\n+        i++;\n+      }\n+      if ((mask & IndexCondition.END) != 0) {\n+        Parameter param = new Parameter(firstIndexParam + i);\n+        q.addGlobalCondition(param, idx, Comparison.SMALLER_EQUAL);\n+        i++;\n+      }\n+      if ((mask & IndexCondition.SPATIAL_INTERSECTS) != 0) {\n+        Parameter param = new Parameter(firstIndexParam + i);\n+        q.addGlobalCondition(param, idx, Comparison.SPATIAL_INTERSECTS);\n+        i++;\n+      }\n     }\n-\n-    @Override\n-    public long getRowCount(Session session) {\n-        return 0;\n-    }\n-\n-    @Override\n-    public long getRowCountApproximation() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public long getDiskSpaceUsed() {\n-        return 0;\n+    columns = columnList.toArray(new Column[0]);\n+\n+    // reconstruct the index columns from the masks\n+    this.indexColumns = new IndexColumn[indexColumnCount];\n+    this.columnIds = new int[indexColumnCount];\n+    //type\u4ece0\u52301\uff0c\u4e5f\u5c31\u662f\u5faa\u73af\u4e24\u6b21\u8fd0\u884c\u5b50\u5faa\u73af\n+    //\u5f53type\u4e3a0\u65f6\uff0c\u53ea\u53d6where\u6761\u4ef6\u4e2d\u7684\"\u7b49\u4e8e\"\u5173\u7cfb\u8868\u8fbe\u5f0f\n+    //\u5f53type\u4e3a1\u65f6\uff0c\u53ea\u53d6where\u6761\u4ef6\u4e2d\u7684\u9664\"\u7b49\u4e8e\"\u5173\u7cfb\u8868\u8fbe\u5f0f\u4e4b\u4e0a\u7684\u8868\u8fbe\u5f0f\n+    //\u5982select * from my_view where f1=2 and f2 between 'b1' and 'b2'\n+    //\u5f53type\u4e3a0\u65f6\uff0c\u53ea\u53d6f1=2\n+    //\u5f53type\u4e3a1\u65f6\uff0c\u53ea\u53d6f2 between 'b1' and 'b2'\n+    for (int type = 0, indexColumnId = 0; type < 2; type++) {\n+      for (int i = 0; i < masks.length; i++) {\n+        int mask = masks[i];\n+        if (mask == 0) {\n+          continue;\n+        }\n+        if (type == 0) {\n+          if ((mask & IndexCondition.EQUALITY) == 0) {\n+            // the first columns need to be equality conditions\n+            continue;\n+          }\n+        } else {\n+          if ((mask & IndexCondition.EQUALITY) != 0) {\n+            // after that only range conditions\n+            continue;\n+          }\n+        }\n+        IndexColumn c = new IndexColumn();\n+        c.column = table.getColumn(i);\n+        indexColumns[indexColumnId] = c;\n+        columnIds[indexColumnId] = c.column.getColumnId();\n+        indexColumnId++;\n+      }\n     }\n \n-    public boolean isRecursive() {\n-        return recursive;\n-    }\n+    String sql = q.getPlanSQL(true);\n+    q = prepareSubQuery(sql, session, masks, filters, filter, sortOrder);\n+    return q;\n+  }\n+\n+  @Override\n+  public void remove(Session session) {\n+    throw DbException.getUnsupportedException(\"VIEW\");\n+  }\n+\n+  @Override\n+  public void truncate(Session session) {\n+    throw DbException.getUnsupportedException(\"VIEW\");\n+  }\n+\n+  @Override\n+  public void checkRename() {\n+    throw DbException.getUnsupportedException(\"VIEW\");\n+  }\n+\n+  @Override\n+  public boolean needRebuild() {\n+    return false;\n+  }\n+\n+  @Override\n+  public boolean canGetFirstOrLast() {\n+    return false;\n+  }\n+\n+  @Override\n+  public Cursor findFirstOrLast(Session session, boolean first) {\n+    throw DbException.getUnsupportedException(\"VIEW\");\n+  }\n+\n+  public void setRecursive(boolean value) {\n+    this.recursive = value;\n+  }\n+\n+  @Override\n+  public long getRowCount(Session session) {\n+    return 0;\n+  }\n+\n+  @Override\n+  public long getRowCountApproximation() {\n+    return 0;\n+  }\n+\n+  @Override\n+  public long getDiskSpaceUsed() {\n+    return 0;\n+  }\n+\n+  public boolean isRecursive() {\n+    return recursive;\n+  }\n }\n",
            "diff_size": 581
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "218",
                    "column": "23",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/480/ViewIndex.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/naturalize/480/ViewIndex.java\nindex 9247200fc15..8e9383efaba 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/480/ViewIndex.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/naturalize/480/ViewIndex.java\n@@ -272,15 +272,8 @@ public class ViewIndex extends BaseIndex implements SpatialIndex {\n     private Cursor findRecursive(SearchRow first, SearchRow last) {\n         assert recursive;\n //<<<<<<< HEAD\n-//        // \u5982 WITH RECURSIVE my_tmp_table(f1,f2)\n-//        // AS(select id,name from CreateViewTest UNION ALL select 1, 2) select f1, f2 from my_tmp_table\n-//        // \u4e0d\u8fc7\u6709bug\n-//        ResultInterface recResult = view.getRecursiveResult();\n-//        if (recResult != null) {\n-//            recResult.reset();\n-//            return new ViewCursor(this, recResult, first, last);\n-//=======\n-        ResultInterface recursiveResult = view.getRecursiveResult();\n+//\n+ResultInterface recursiveResult = view.getRecursiveResult();\n         if (recursiveResult != null) {\n             recursiveResult.reset();\n             return new ViewCursor(this, recursiveResult, first, last);\n@@ -318,14 +311,8 @@ public class ViewIndex extends BaseIndex implements SpatialIndex {\n         right.disableCache();\n         while (true) {\n //<<<<<<< HEAD\n-//            // \u5982 WITH RECURSIVE my_tmp_table(f1,f2)\n-//            // AS(select id,name from CreateViewTest UNION ALL select 1, 2) select f1, f2 from my_tmp_table\n-//            // \u4e0d\u8fc7\u6709bug\n-//            // \u8fd9\u91cc\u4f1a\u4e00\u76f4\u662f\u6b7b\u5faa\u73af\uff0c\u56e0\u4e3aright.query(0)\u4e0d\u4f1a\u8fd4\u56de\u4e00\u4e2a\u7a7a\u7ed3\u679c\u96c6\n-//            r = right.query(0);\n-//            if (!r.hasNext()) {\n-//=======\n-            resultInterface = right.query(0);\n+\n+resultInterface = right.query(0);\n             if (!resultInterface.hasNext()) {\n                 break;\n             }\n@@ -334,15 +321,8 @@ public class ViewIndex extends BaseIndex implements SpatialIndex {\n                 localResult.addRow(cr);\n             }\n //<<<<<<< HEAD\n-//            r.reset();\n-//            view.setRecursiveResult(r);\n-//            // \u6211\u52a0\u4e0a\u7684\n-//            // \u907f\u514d\u6b7b\u5faa\u73af\uff0c\u56e0\u4e3a\u6b64\u65f6union all\u7684\u53f3\u8fb9\u5b50\u53e5\u4e0d\u662f\u5f53\u524dview\n-//            if (!right.getTables().contains(view)) {\n-//                break;\n-//            }\n-//=======\n-            resultInterface.reset();\n+//\n+resultInterface.reset();\n             view.setRecursiveResult(resultInterface);\n         }\n         view.setRecursiveResult(null);\n@@ -448,18 +428,8 @@ public class ViewIndex extends BaseIndex implements SpatialIndex {\n             }\n             indexColumnCount++;\n //<<<<<<< HEAD\n-//            paramIndex.add(i);\n-//            //\u4e3a1\u7684bit\u4e2a\u6570\uff0c\u6bd4\u5982mask=3\u65f6\uff0c\u5c31\u662f0011\uff0c\u6240\u4ee5bitCount=2\n-//            //mask=6\u65f6\uff0c\u5c31\u662f0110\uff0c\u4e5f\u5c31\u662fRANGE = START | END\n-//            //\u5982select * from my_view where f2 between 'b1' and 'b2'\n-//            if (Integer.bitCount(mask) > 1) {\n-//                // two parameters for range queries: >= x AND <= y\n-//                paramIndex.add(i);\n-//            }\n-//        }\n-//        int len = paramIndex.size(); //paramIndex\u4e2d\u653e\u7684\u662f\u5217id\n-//=======\n-            // the number of parameters depends on the mask;\n+//      \n+// the number of parameters depends on the mask;\n             // for range queries it is 2: >= x AND <= y\n             // but bitMask could also be 7 (=, and <=, and >=)\n             int bitCount = Integer.bitCount(mask);\n@@ -587,4 +557,4 @@ public class ViewIndex extends BaseIndex implements SpatialIndex {\n     public boolean isRecursive() {\n         return recursive;\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 39
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/480/ViewIndex.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/codebuff/480/ViewIndex.java\nindex 9247200fc15..52376637000 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/480/ViewIndex.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/codebuff/480/ViewIndex.java\n@@ -7,7 +7,6 @@ package org.h2.index;\n \n import java.util.ArrayList;\n import java.util.concurrent.TimeUnit;\n-\n import org.h2.api.ErrorCode;\n import org.h2.command.Parser;\n import org.h2.command.Prepared;\n@@ -36,11 +35,11 @@ import org.h2.value.Value;\n  * This object represents a virtual index for a query.\n  * Actually it only represents a prepared SELECT statement.\n  */\n-public class ViewIndex extends BaseIndex implements SpatialIndex {\n \n-    private static final long MAX_AGE_NANOS =\n-            TimeUnit.MILLISECONDS.toNanos(Constants.VIEW_COST_CACHE_MAX_AGE);\n \n+public class ViewIndex extends BaseIndex implements SpatialIndex {\n+\n+    private static final long MAX_AGE_NANOS = TimeUnit.MILLISECONDS.toNanos(Constants.VIEW_COST_CACHE_MAX_AGE);\n     private final TableView view;\n     private final String querySQL;\n     private final ArrayList<Parameter> originalParameters;\n@@ -62,8 +61,8 @@ public class ViewIndex extends BaseIndex implements SpatialIndex {\n      * @param originalParameters the original parameters\n      * @param recursive if the view is recursive\n      */\n-    public ViewIndex(TableView view, String querySQL,\n-            ArrayList<Parameter> originalParameters, boolean recursive) {\n+\n+    public ViewIndex(TableView view, String querySQL, ArrayList<Parameter> originalParameters, boolean recursive) {\n         super(view, 0, null, null, IndexType.createNonUnique(false));\n         this.view = view;\n         this.querySQL = querySQL;\n@@ -89,8 +88,8 @@ public class ViewIndex extends BaseIndex implements SpatialIndex {\n      * @param filter current filter\n      * @param sortOrder sort order\n      */\n-    public ViewIndex(TableView view, ViewIndex index, Session session,\n-            int[] masks, TableFilter[] filters, int filter, SortOrder sortOrder) {\n+\n+    public ViewIndex(TableView view, ViewIndex index, Session session, int[] masks, TableFilter[] filters, int filter, SortOrder sortOrder) {\n         super(view, 0, null, null, IndexType.createNonUnique(false));\n         this.view = view;\n         this.querySQL = index.querySQL;\n@@ -118,14 +117,15 @@ public class ViewIndex extends BaseIndex implements SpatialIndex {\n         return JoinBatch.createViewIndexLookupBatch(this);\n     }\n \n+\n     public Session getSession() {\n         return createSession;\n     }\n \n+\n     public boolean isExpired() {\n         assert evaluatedAt != Long.MIN_VALUE : \"must not be called for main index of TableView\";\n-        return !recursive && view.getTopQuery() == null &&\n-                System.nanoTime() - evaluatedAt > MAX_AGE_NANOS;\n+        return !recursive && view.getTopQuery() == null && System.nanoTime() - evaluatedAt > MAX_AGE_NANOS;\n     }\n \n     @Override\n@@ -136,6 +136,7 @@ public class ViewIndex extends BaseIndex implements SpatialIndex {\n     @Override\n     public void close(Session session) {\n         // nothing to do\n+\n     }\n \n     @Override\n@@ -215,10 +216,10 @@ public class ViewIndex extends BaseIndex implements SpatialIndex {\n //                    q.addGlobalCondition(param, idx, Comparison.SPATIAL_INTERSECTS);\n //                } else {\n //                    if ((mask & IndexCondition.START) != 0) {\n-//                    \t//\u4f8b\u5982:sql = \"select * from my_view where f2 > 'b1'\";\n-//                    \t//\u5b9e\u9645\u662fSELECT ID, NAME FROM CreateViewTest WHERE NAME >= ?1\n-//                    \t//\u5728org.h2.index.IndexCondition.getMask(ArrayList<IndexCondition>)\u90a3\u91cc\u628a\n-//                    \t//BIGGER_EQUAL\u3001BIGGER\u90fd\u5f53\u6210\u4e86START\uff0c\u800c\u8fd9\u91cc\u7edf\u4e00\u8f6c\u6210BIGGER_EQUAL\uff0c\u5f53view\u8981\u8fc7\u6ee4\u8bb0\u5f55\u65f6\u518d\u6309\u5927\u4e8e\u8fc7\u6ee4\n+//                      //\u4f8b\u5982:sql = \"select * from my_view where f2 > 'b1'\";\n+//                      //\u5b9e\u9645\u662fSELECT ID, NAME FROM CreateViewTest WHERE NAME >= ?1\n+//                      //\u5728org.h2.index.IndexCondition.getMask(ArrayList<IndexCondition>)\u90a3\u91cc\u628a\n+//                      //BIGGER_EQUAL\u3001BIGGER\u90fd\u5f53\u6210\u4e86START\uff0c\u800c\u8fd9\u91cc\u7edf\u4e00\u8f6c\u6210BIGGER_EQUAL\uff0c\u5f53view\u8981\u8fc7\u6ee4\u8bb0\u5f55\u65f6\u518d\u6309\u5927\u4e8e\u8fc7\u6ee4\n //                        Parameter param = new Parameter(nextParamIndex);\n //                        q.addGlobalCondition(param, idx, Comparison.BIGGER_EQUAL);\n //                    }\n@@ -239,10 +240,9 @@ public class ViewIndex extends BaseIndex implements SpatialIndex {\n //        costCache.put(masksArray, cachedCost);\n //        return cost;\n //=======\n+\n     @Override\n-    public double getCost(Session session, int[] masks,\n-            TableFilter[] filters, int filter, SortOrder sortOrder,\n-            AllColumnsForPlan allColumnsSet) {\n+    public double getCost(Session session, int[] masks, TableFilter[] filters, int filter, SortOrder sortOrder, AllColumnsForPlan allColumnsSet) {\n         return recursive ? 1000 : query.getCost();\n     }\n \n@@ -252,13 +252,11 @@ public class ViewIndex extends BaseIndex implements SpatialIndex {\n     }\n \n     @Override\n-    public Cursor findByGeometry(TableFilter filter, SearchRow first,\n-            SearchRow last, SearchRow intersection) {\n+    public Cursor findByGeometry(TableFilter filter, SearchRow first, SearchRow last, SearchRow intersection) {\n         return find(filter.getSession(), first, last, intersection);\n     }\n \n-    private static Query prepareSubQuery(String sql, Session session, int[] masks,\n-            TableFilter[] filters, int filter, SortOrder sortOrder) {\n+    private static Query prepareSubQuery(String sql, Session session, int[] masks, TableFilter[] filters, int filter, SortOrder sortOrder) {\n         Prepared p;\n         session.pushSubQueryInfo(masks, filters, filter, sortOrder);\n         try {\n@@ -294,7 +292,7 @@ public class ViewIndex extends BaseIndex implements SpatialIndex {\n         }\n         if (!query.isUnion()) {\n             throw DbException.get(ErrorCode.SYNTAX_ERROR_2,\n-                    \"recursive queries without UNION\");\n+                                  \"recursive queries without UNION\");\n         }\n         SelectUnion union = (SelectUnion) query;\n         Query left = union.getLeft();\n@@ -358,8 +356,11 @@ public class ViewIndex extends BaseIndex implements SpatialIndex {\n      * @param last the upper bound\n      * @param intersection the intersection\n      */\n-    public void setupQueryParameters(Session session, SearchRow first, SearchRow last,\n-            SearchRow intersection) {\n+\n+\n+    public void setupQueryParameters(Session session,\n+           SearchRow first,\n+           SearchRow last, SearchRow intersection) {\n         ArrayList<Parameter> paramList = query.getParameters();\n         if (originalParameters != null) {\n             for (Parameter orig : originalParameters) {\n@@ -373,11 +374,11 @@ public class ViewIndex extends BaseIndex implements SpatialIndex {\n             len = first.getColumnCount();\n         } else if (last != null) {\n             len = last.getColumnCount();\n-        } else if (intersection != null) {\n-            len = intersection.getColumnCount();\n+                                                   } else if (intersection != null) {\n+                   len = intersection.getColumnCount();\n         } else {\n-            len = 0;\n-        }\n+                   len = 0;\n+               }\n         //view\u4e2d\u5df2\u7ed9select\u52a0\u4e86\u5916\u90e8\u6761\u4ef6\uff0c\u6240\u4ee5\u591a\u4e86Parameter\uff0c\u8fd9\u91cc\u5c31\u662f\u7ed9\u8fd9\u4e9bParameter\u8d4b\u503c\n         int idx = view.getParameterOffset(originalParameters);\n         for (int i = 0; i < len; i++) {\n@@ -397,8 +398,9 @@ public class ViewIndex extends BaseIndex implements SpatialIndex {\n         }\n     }\n \n-    private Cursor find(Session session, SearchRow first, SearchRow last,\n-            SearchRow intersection) {\n+    private Cursor find(Session session,\n+            SearchRow first,\n+            SearchRow last, SearchRow intersection) {\n         if (recursive) {\n             return findRecursive(first, last);\n         }\n@@ -407,8 +409,7 @@ public class ViewIndex extends BaseIndex implements SpatialIndex {\n         return new ViewCursor(this, result, first, last);\n     }\n \n-    private static void setParameter(ArrayList<Parameter> paramList, int x,\n-            Value v) {\n+    private static void setParameter(ArrayList<Parameter> paramList, int x, Value v) {\n         if (x >= paramList.size()) {\n             // the parameter may be optimized away as in\n             // select * from (select null as x) where x=1;\n@@ -418,14 +419,15 @@ public class ViewIndex extends BaseIndex implements SpatialIndex {\n         param.setValue(v);\n     }\n \n+\n     public Query getQuery() {\n         return query;\n     }\n \n     // \u76ee\u7684\u662f\u4e3a\u4e86\u5bf9indexColumns\u8d4b\u503c\uff0cindexColumns\u53e6\u6709\u5b83\u7528\n     // \u6bd4\u5982\u5728org.h2.command.dml.Select.prepare()\u4e2d\u5c31\u6709\u5e94\u7528(cost = preparePlan\u90a3\u884c\u4ee3\u7801\u4e4b\u540e)\n-    private Query getQuery(Session session, int[] masks,\n-            TableFilter[] filters, int filter, SortOrder sortOrder) {\n+\n+    private Query getQuery(Session session, int[] masks, TableFilter[] filters, int filter, SortOrder sortOrder) {\n         Query q = prepareSubQuery(querySQL, session, masks, filters, filter, sortOrder);\n         if (masks == null) {\n             return q;\n@@ -468,7 +470,7 @@ public class ViewIndex extends BaseIndex implements SpatialIndex {\n             }\n         }\n         int len = paramColumnIndex.size();\n-        ArrayList<Column> columnList = new ArrayList<>(len);\n+        ArrayList<Column> columnList = new ArrayList< >(len);\n         for (int i = 0; i < len;) {\n             int idx = paramColumnIndex.get(i);\n             columnList.add(table.getColumn(idx));\n@@ -529,7 +531,6 @@ public class ViewIndex extends BaseIndex implements SpatialIndex {\n                 indexColumnId++;\n             }\n         }\n-\n         String sql = q.getPlanSQL(true);\n         q = prepareSubQuery(sql, session, masks, filters, filter, sortOrder);\n         return q;\n@@ -565,6 +566,7 @@ public class ViewIndex extends BaseIndex implements SpatialIndex {\n         throw DbException.getUnsupportedException(\"VIEW\");\n     }\n \n+\n     public void setRecursive(boolean value) {\n         this.recursive = value;\n     }\n@@ -584,7 +586,9 @@ public class ViewIndex extends BaseIndex implements SpatialIndex {\n         return 0;\n     }\n \n+\n     public boolean isRecursive() {\n         return recursive;\n     }\n-}\n+\n+}\n\\ No newline at end of file\n",
            "diff_size": 52
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "218",
                    "column": "23",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "218",
                    "column": "23",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/480/ViewIndex.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/480/ViewIndex.java\nindex 9247200fc15..c2789d2dc2a 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/480/ViewIndex.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/480/ViewIndex.java\n@@ -215,7 +215,7 @@ public class ViewIndex extends BaseIndex implements SpatialIndex {\n //                    q.addGlobalCondition(param, idx, Comparison.SPATIAL_INTERSECTS);\n //                } else {\n //                    if ((mask & IndexCondition.START) != 0) {\n-//                    \t//\u4f8b\u5982:sql = \"select * from my_view where f2 > 'b1'\";\n+//                    \t//\u5b9e\u9645\u662fSELECT ID, NAME FROM CreateViewTest WHERE NAME >= ?1\n //                    \t//\u5b9e\u9645\u662fSELECT ID, NAME FROM CreateViewTest WHERE NAME >= ?1\n //                    \t//\u5728org.h2.index.IndexCondition.getMask(ArrayList<IndexCondition>)\u90a3\u91cc\u628a\n //                    \t//BIGGER_EQUAL\u3001BIGGER\u90fd\u5f53\u6210\u4e86START\uff0c\u800c\u8fd9\u91cc\u7edf\u4e00\u8f6c\u6210BIGGER_EQUAL\uff0c\u5f53view\u8981\u8fc7\u6ee4\u8bb0\u5f55\u65f6\u518d\u6309\u5927\u4e8e\u8fc7\u6ee4\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "codebuff"
    ],
    "not_repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "styler_random",
        "styler_three_grams"
    ]
}