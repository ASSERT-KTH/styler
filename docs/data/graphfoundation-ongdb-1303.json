{
    "project_name": "graphfoundation-ongdb",
    "error_id": "1303",
    "information": {
        "errors": [
            {
                "line": "1",
                "severity": "error",
                "message": "Missing, wrong or duplicated license header",
                "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
            }
        ]
    },
    "source_code": "/*\n * Copyright (c) 2002-2020 \"Neo4j,\"\n * Neo4j Sweden AB [http://neo4j.com]\n *",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "1",
                    "severity": "error",
                    "message": "Missing, wrong or duplicated license header",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "1",
                    "severity": "error",
                    "message": "Missing, wrong or duplicated license header",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                },
                {
                    "line": "108",
                    "column": "20",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "108",
                    "column": "32",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "135",
                    "column": "10",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "135",
                    "column": "32",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "148",
                    "column": "19",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "148",
                    "column": "27",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "156",
                    "column": "20",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "156",
                    "column": "101",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "169",
                    "column": "35",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "169",
                    "column": "45",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "171",
                    "column": "8",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "171",
                    "column": "30",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "175",
                    "column": "11",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "175",
                    "column": "50",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "177",
                    "column": "32",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "177",
                    "column": "39",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "182",
                    "column": "28",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "182",
                    "column": "52",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "191",
                    "column": "27",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "191",
                    "column": "45",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "194",
                    "column": "8",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "194",
                    "column": "26",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "247",
                    "column": "33",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "247",
                    "column": "108",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "251",
                    "column": "11",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "251",
                    "column": "45",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "255",
                    "column": "8",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "255",
                    "column": "38",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "260",
                    "column": "11",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "260",
                    "column": "39",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "266",
                    "column": "10",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "266",
                    "column": "30",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "280",
                    "column": "10",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "280",
                    "column": "34",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "282",
                    "column": "12",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "282",
                    "column": "26",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "286",
                    "column": "9",
                    "severity": "error",
                    "message": "'}' at column 9 should be alone on a line.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.blocks.RightCurlyCheck"
                },
                {
                    "line": "293",
                    "column": "10",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "293",
                    "column": "34",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "295",
                    "column": "12",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "295",
                    "column": "33",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "299",
                    "column": "9",
                    "severity": "error",
                    "message": "'}' at column 9 should be alone on a line.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.blocks.RightCurlyCheck"
                },
                {
                    "line": "348",
                    "column": "14",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "349",
                    "column": "98",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "360",
                    "column": "21",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "360",
                    "column": "95",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "373",
                    "column": "45",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "373",
                    "column": "63",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "397",
                    "column": "32",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "398",
                    "column": "109",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "407",
                    "column": "34",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "408",
                    "column": "98",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "411",
                    "column": "8",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "411",
                    "column": "24",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "421",
                    "column": "8",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "421",
                    "column": "35",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "445",
                    "column": "29",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "446",
                    "column": "110",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "461",
                    "column": "9",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "461",
                    "column": "68",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "475",
                    "column": "8",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "475",
                    "column": "34",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "477",
                    "column": "11",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "477",
                    "column": "73",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "500",
                    "column": "28",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "501",
                    "column": "112",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "506",
                    "column": "8",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "506",
                    "column": "22",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "517",
                    "column": "30",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "518",
                    "column": "137",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "523",
                    "column": "8",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "523",
                    "column": "28",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "529",
                    "column": "10",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "529",
                    "column": "26",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "537",
                    "column": "12",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "537",
                    "column": "67",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "545",
                    "column": "33",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "546",
                    "column": "94",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "549",
                    "column": "8",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "549",
                    "column": "24",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "556",
                    "column": "8",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "556",
                    "column": "35",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "578",
                    "column": "25",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "579",
                    "column": "114",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "647",
                    "column": "9",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "647",
                    "column": "68",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "660",
                    "column": "8",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "660",
                    "column": "34",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "662",
                    "column": "11",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "662",
                    "column": "73",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "697",
                    "column": "15",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "698",
                    "column": "62",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "703",
                    "column": "8",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "703",
                    "column": "103",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "710",
                    "column": "8",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "710",
                    "column": "26",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "718",
                    "column": "38",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "719",
                    "column": "85",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "721",
                    "column": "11",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "726",
                    "column": "47",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "729",
                    "column": "10",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "729",
                    "column": "28",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "735",
                    "column": "10",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "735",
                    "column": "50",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "738",
                    "column": "12",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "738",
                    "column": "21",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "742",
                    "column": "9",
                    "severity": "error",
                    "message": "'}' at column 9 should be alone on a line.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.blocks.RightCurlyCheck"
                },
                {
                    "line": "749",
                    "column": "10",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "749",
                    "column": "49",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "754",
                    "column": "10",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "754",
                    "column": "51",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "758",
                    "column": "12",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "758",
                    "column": "28",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "762",
                    "column": "9",
                    "severity": "error",
                    "message": "'}' at column 9 should be alone on a line.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.blocks.RightCurlyCheck"
                },
                {
                    "line": "772",
                    "column": "10",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "772",
                    "column": "49",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "780",
                    "column": "10",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "781",
                    "column": "68",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "784",
                    "column": "16",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "784",
                    "column": "56",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "795",
                    "column": "47",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "796",
                    "column": "56",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "800",
                    "column": "10",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "801",
                    "column": "69",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "804",
                    "column": "16",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "804",
                    "column": "56",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "815",
                    "column": "47",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "816",
                    "column": "56",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "822",
                    "column": "36",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "823",
                    "column": "83",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "829",
                    "column": "8",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "829",
                    "column": "24",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "840",
                    "column": "29",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "841",
                    "column": "76",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "846",
                    "column": "11",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "846",
                    "column": "60",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "862",
                    "column": "30",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "863",
                    "column": "77",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "870",
                    "column": "54",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "872",
                    "column": "101",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "883",
                    "column": "8",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "883",
                    "column": "47",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "888",
                    "column": "8",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "888",
                    "column": "22",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "894",
                    "column": "5",
                    "severity": "error",
                    "message": "'}' at column 5 should be alone on a line.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.blocks.RightCurlyCheck"
                },
                {
                    "line": "906",
                    "column": "46",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "907",
                    "column": "112",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "911",
                    "column": "10",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "911",
                    "column": "34",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "928",
                    "column": "10",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "928",
                    "column": "49",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "933",
                    "column": "10",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "933",
                    "column": "24",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "938",
                    "column": "10",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "938",
                    "column": "24",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "953",
                    "column": "5",
                    "severity": "error",
                    "message": "'}' at column 5 should be alone on a line.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.blocks.RightCurlyCheck"
                },
                {
                    "line": "959",
                    "column": "39",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "959",
                    "column": "102",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "962",
                    "column": "8",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "962",
                    "column": "18",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "965",
                    "column": "5",
                    "severity": "error",
                    "message": "'}' at column 5 should be alone on a line.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.blocks.RightCurlyCheck"
                },
                {
                    "line": "976",
                    "column": "49",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "977",
                    "column": "73",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "983",
                    "column": "9",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "983",
                    "column": "77",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "991",
                    "column": "49",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "992",
                    "column": "73",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "998",
                    "column": "9",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "998",
                    "column": "79",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "1022",
                    "column": "33",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "1023",
                    "column": "101",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "1030",
                    "column": "8",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "1030",
                    "column": "13",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "1039",
                    "column": "8",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "1039",
                    "column": "50",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "1048",
                    "column": "31",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "1049",
                    "column": "78",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "1056",
                    "column": "8",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "1056",
                    "column": "37",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "1059",
                    "column": "11",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "1059",
                    "column": "114",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "1065",
                    "column": "12",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "1065",
                    "column": "32",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "1070",
                    "column": "9",
                    "severity": "error",
                    "message": "'}' at column 9 should be alone on a line.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.blocks.RightCurlyCheck"
                },
                {
                    "line": "1070",
                    "column": "19",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "1070",
                    "column": "41",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "1078",
                    "column": "5",
                    "severity": "error",
                    "message": "'}' at column 5 should be alone on a line.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.blocks.RightCurlyCheck"
                },
                {
                    "line": "1078",
                    "column": "15",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "1078",
                    "column": "45",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "1080",
                    "column": "11",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "1081",
                    "column": "59",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "1086",
                    "column": "12",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "1086",
                    "column": "97",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "1097",
                    "column": "42",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "1097",
                    "column": "108",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "1105",
                    "column": "8",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "1105",
                    "column": "37",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "1110",
                    "column": "8",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "1110",
                    "column": "38",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "1119",
                    "column": "39",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "1121",
                    "column": "86",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "1137",
                    "column": "40",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "1139",
                    "column": "87",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "1155",
                    "column": "21",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "1156",
                    "column": "94",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "1169",
                    "column": "29",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "1170",
                    "column": "100",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "1190",
                    "column": "35",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "1190",
                    "column": "88",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "1222",
                    "column": "39",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "1223",
                    "column": "140",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "1228",
                    "column": "8",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "1228",
                    "column": "45",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "1236",
                    "column": "9",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "1236",
                    "column": "75",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "1264",
                    "column": "8",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "1264",
                    "column": "37",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "1269",
                    "column": "8",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "1269",
                    "column": "38",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/errored/1/1303/InternalTreeLogic.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/intellij/1303/InternalTreeLogic.java\nindex 319a4d63a1c..5105a341ff6 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/errored/1/1303/InternalTreeLogic.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/intellij/1303/InternalTreeLogic.java\n@@ -17,6 +17,7 @@\n  * You should have received a copy of the GNU General Public License\n  * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n  */\n+\n package org.neo4j.index.internal.gbptree;\n \n import java.io.IOException;\n@@ -79,1213 +80,1204 @@ import static org.neo4j.index.internal.gbptree.TreeNode.Type.LEAF;\n  *   There's no bad intermediate state\n  * </pre>\n  *\n- * @param <KEY> type of internal/leaf keys\n+ * @param <KEY>   type of internal/leaf keys\n  * @param <VALUE> type of leaf values\n  */\n-class InternalTreeLogic<KEY,VALUE>\n+class InternalTreeLogic<KEY, VALUE>\n {\n-    private final IdProvider idProvider;\n-    private final TreeNode<KEY,VALUE> bTreeNode;\n-    private final Layout<KEY,VALUE> layout;\n-    private final KEY newKeyPlaceHolder;\n-    private final KEY readKey;\n-    private final VALUE readValue;\n-\n-    /**\n-     * Current path down the tree\n-     * - level:-1 is uninitialized (so that a call to {@link #initialize(PageCursor)} is required)\n-     * - level: 0 is at root\n-     * - level: 1 is at first level below root\n-     * ... a.s.o\n-     *\n-     * Calling {@link #insert(PageCursor, StructurePropagation, Object, Object, ValueMerger, long, long)}\n-     * or {@link #remove(PageCursor, StructurePropagation, Object, Object, long, long)} leaves the cursor\n-     * at the last updated page (tree node id) and remembers the path down the tree to where it is.\n-     * Further inserts/removals will move the cursor from its current position to where the next change will\n-     * take place using as few page pins as possible.\n-     */\n-    @SuppressWarnings( \"unchecked\" )\n-    private Level<KEY>[] levels = new Level[0]; // grows on demand\n-    private int currentLevel = -1;\n+  private final IdProvider idProvider;\n+  private final TreeNode<KEY, VALUE> bTreeNode;\n+  private final Layout<KEY, VALUE> layout;\n+  private final KEY newKeyPlaceHolder;\n+  private final KEY readKey;\n+  private final VALUE readValue;\n+\n+  /**\n+   * Current path down the tree\n+   * - level:-1 is uninitialized (so that a call to {@link #initialize(PageCursor)} is required)\n+   * - level: 0 is at root\n+   * - level: 1 is at first level below root\n+   * ... a.s.o\n+   * <p>\n+   * Calling {@link #insert(PageCursor, StructurePropagation, Object, Object, ValueMerger, long, long)}\n+   * or {@link #remove(PageCursor, StructurePropagation, Object, Object, long, long)} leaves the cursor\n+   * at the last updated page (tree node id) and remembers the path down the tree to where it is.\n+   * Further inserts/removals will move the cursor from its current position to where the next change will\n+   * take place using as few page pins as possible.\n+   */\n+  @SuppressWarnings(\"unchecked\")\n+  private Level<KEY>[] levels = new Level[0]; // grows on demand\n+  private int currentLevel = -1;\n+\n+  /**\n+   * Keeps information about one level in a path down the tree where the {@link PageCursor} is currently at.\n+   *\n+   * @param <KEY> type of keys in the tree.\n+   */\n+  private static class Level<KEY>\n+  {\n+    // For comparing keys\n+    private final Comparator<KEY> layout;\n+    // Id of the tree node id this level of the path\n+    private long treeNodeId;\n+\n+    // Child position which was selected from parent to get to this level\n+    private int childPos;\n+    // Lower bound of key range this level covers\n+    private final KEY lower;\n+    // Whether or not the lower bound is fixed or open-ended (far left in the tree)\n+    private boolean lowerIsOpenEnded;\n+    // Upper bound of key range this level covers\n+    private final KEY upper;\n+    // Whether or not the upper bound is fixed or open-ended (far right in the tree)\n+    private boolean upperIsOpenEnded;\n+\n+    Level(Layout<KEY, ?> layout)\n+    {\n+      this.layout = layout;\n+      this.lower = layout.newKey();\n+      this.upper = layout.newKey();\n+    }\n \n     /**\n-     * Keeps information about one level in a path down the tree where the {@link PageCursor} is currently at.\n+     * Returns whether or not the key range of this level of the path covers the given {@code key}.\n      *\n-     * @param <KEY> type of keys in the tree.\n+     * @param key KEY to check.\n+     * @return {@code true} if key is within the key range if this level, otherwise {@code false}.\n      */\n-    private static class Level<KEY>\n+    boolean covers(KEY key)\n     {\n-        // For comparing keys\n-        private final Comparator<KEY> layout;\n-        // Id of the tree node id this level of the path\n-        private long treeNodeId;\n-\n-        // Child position which was selected from parent to get to this level\n-        private int childPos;\n-        // Lower bound of key range this level covers\n-        private final KEY lower;\n-        // Whether or not the lower bound is fixed or open-ended (far left in the tree)\n-        private boolean lowerIsOpenEnded;\n-        // Upper bound of key range this level covers\n-        private final KEY upper;\n-        // Whether or not the upper bound is fixed or open-ended (far right in the tree)\n-        private boolean upperIsOpenEnded;\n-\n-        Level( Layout<KEY,?> layout )\n-        {\n-            this.layout = layout;\n-            this.lower = layout.newKey();\n-            this.upper = layout.newKey();\n-        }\n-\n-        /**\n-         * Returns whether or not the key range of this level of the path covers the given {@code key}.\n-         *\n-         * @param key KEY to check.\n-         * @return {@code true} if key is within the key range if this level, otherwise {@code false}.\n-         */\n-        boolean covers( KEY key )\n-        {\n-            boolean insideLower = lowerIsOpenEnded || layout.compare( key, lower ) >= 0;\n-            boolean insideHigher = upperIsOpenEnded || layout.compare( key, upper ) < 0;\n-            return insideLower && insideHigher;\n-        }\n+      boolean insideLower = lowerIsOpenEnded || layout.compare(key, lower) >= 0;\n+      boolean insideHigher = upperIsOpenEnded || layout.compare(key, upper) < 0;\n+      return insideLower && insideHigher;\n     }\n-\n-    InternalTreeLogic( IdProvider idProvider, TreeNode<KEY,VALUE> bTreeNode, Layout<KEY,VALUE> layout )\n+  }\n+\n+  InternalTreeLogic(IdProvider idProvider, TreeNode<KEY, VALUE> bTreeNode, Layout<KEY, VALUE> layout)\n+  {\n+    this.idProvider = idProvider;\n+    this.bTreeNode = bTreeNode;\n+    this.layout = layout;\n+    this.newKeyPlaceHolder = layout.newKey();\n+    this.readKey = layout.newKey();\n+    this.readValue = layout.newValue();\n+\n+    // an arbitrary depth slightly bigger than an unimaginably big tree\n+    ensureStackCapacity(10);\n+  }\n+\n+  private void ensureStackCapacity(int depth)\n+  {\n+    if (depth > levels.length)\n     {\n-        this.idProvider = idProvider;\n-        this.bTreeNode = bTreeNode;\n-        this.layout = layout;\n-        this.newKeyPlaceHolder = layout.newKey();\n-        this.readKey = layout.newKey();\n-        this.readValue = layout.newValue();\n-\n-        // an arbitrary depth slightly bigger than an unimaginably big tree\n-        ensureStackCapacity( 10 );\n+      int oldStackLength = levels.length;\n+      levels = Arrays.copyOf(levels, depth);\n+      for (int i = oldStackLength; i < depth; i++)\n+      {\n+        levels[i] = new Level<>(layout);\n+      }\n     }\n-\n-    private void ensureStackCapacity( int depth )\n+  }\n+\n+  protected void initialize(PageCursor cursorAtRoot)\n+  {\n+    currentLevel = 0;\n+    Level<KEY> level = levels[currentLevel];\n+    level.treeNodeId = cursorAtRoot.getCurrentPageId();\n+    level.lowerIsOpenEnded = true;\n+    level.upperIsOpenEnded = true;\n+  }\n+\n+  private boolean popLevel(PageCursor cursor) throws IOException\n+  {\n+    currentLevel--;\n+    if (currentLevel >= 0)\n     {\n-        if ( depth > levels.length )\n-        {\n-            int oldStackLength = levels.length;\n-            levels = Arrays.copyOf( levels, depth );\n-            for ( int i = oldStackLength; i < depth; i++ )\n-            {\n-                levels[i] = new Level<>( layout );\n-            }\n-        }\n+      Level<KEY> level = levels[currentLevel];\n+      TreeNode.goTo(cursor, \"parent\", level.treeNodeId);\n+      return true;\n     }\n-\n-    protected void initialize( PageCursor cursorAtRoot )\n+    return false;\n+  }\n+\n+  /**\n+   * Moves the cursor to the correct leaf for {@code key}, taking the current path into consideration\n+   * and moving the cursor as few hops as possible to get from the current position to the target position,\n+   * e.g given tree:\n+   *\n+   * <pre>\n+   *              [A]\n+   *       ------/ | \\------\n+   *      /        |        \\\n+   *    [B]       [C]       [D]\n+   *   / | \\     / | \\     / | \\\n+   * [E][F][G] [H][I][J] [K][L][M]\n+   * </pre>\n+   * <p>\n+   * Examples:\n+   * <p>\n+   * <p>\n+   * inserting a key into J (path A,C,J) after previously have inserted a key into F (path A,B,F):\n+   * <p>\n+   * <ol>\n+   * <li>Seeing that F doesn't cover new key</li>\n+   * <li>Popping stack, seeing that B doesn't cover new key (only by asking existing information in path)</li>\n+   * <li>Popping stack, seeing that A covers new key (only by asking existing information in path)</li>\n+   * <li>Binary search A to select C to go down to</li>\n+   * <li>Binary search C to select J to go down to</li>\n+   * </ol>\n+   * <p>\n+   * inserting a key into G (path A,B,G) after previously have inserted a key into F (path A,B,F):\n+   * <p>\n+   * <ol>\n+   * <li>Seeing that F doesn't cover new key</li>\n+   * <li>Popping stack, seeing that B covers new key (only by asking existing information in path)</li>\n+   * <li>Binary search B to select G to go down to</li>\n+   * </ol>\n+   * <p>\n+   * The closer keys are together from one change to the next, the fewer page pins and searches needs\n+   * to be performed to get there.\n+   *\n+   * @param cursor             {@link PageCursor} to move to the correct location.\n+   * @param key                KEY to make change for.\n+   * @param stableGeneration   stable generation.\n+   * @param unstableGeneration unstable generation.\n+   * @throws IOException on {@link PageCursor} error.\n+   */\n+  private void moveToCorrectLeaf(PageCursor cursor, KEY key, long stableGeneration, long unstableGeneration)\n+      throws IOException\n+  {\n+    int previousLevel = currentLevel;\n+    while (!levels[currentLevel].covers(key))\n     {\n-        currentLevel = 0;\n-        Level<KEY> level = levels[currentLevel];\n-        level.treeNodeId = cursorAtRoot.getCurrentPageId();\n-        level.lowerIsOpenEnded = true;\n-        level.upperIsOpenEnded = true;\n+      currentLevel--;\n     }\n-\n-    private boolean popLevel( PageCursor cursor ) throws IOException\n+    if (currentLevel != previousLevel)\n     {\n-        currentLevel--;\n-        if ( currentLevel >= 0 )\n-        {\n-            Level<KEY> level = levels[currentLevel];\n-            TreeNode.goTo( cursor, \"parent\", level.treeNodeId );\n-            return true;\n-        }\n-        return false;\n+      TreeNode.goTo(cursor, \"parent\", levels[currentLevel].treeNodeId);\n     }\n \n-    /**\n-     * Moves the cursor to the correct leaf for {@code key}, taking the current path into consideration\n-     * and moving the cursor as few hops as possible to get from the current position to the target position,\n-     * e.g given tree:\n-     *\n-     * <pre>\n-     *              [A]\n-     *       ------/ | \\------\n-     *      /        |        \\\n-     *    [B]       [C]       [D]\n-     *   / | \\     / | \\     / | \\\n-     * [E][F][G] [H][I][J] [K][L][M]\n-     * </pre>\n-     *\n-     * Examples:\n-     * <p>\n-     *\n-     * inserting a key into J (path A,C,J) after previously have inserted a key into F (path A,B,F):\n-     * <p>\n-     * <ol>\n-     * <li>Seeing that F doesn't cover new key</li>\n-     * <li>Popping stack, seeing that B doesn't cover new key (only by asking existing information in path)</li>\n-     * <li>Popping stack, seeing that A covers new key (only by asking existing information in path)</li>\n-     * <li>Binary search A to select C to go down to</li>\n-     * <li>Binary search C to select J to go down to</li>\n-     * </ol>\n-     * <p>\n-     * inserting a key into G (path A,B,G) after previously have inserted a key into F (path A,B,F):\n-     * <p>\n-     * <ol>\n-     * <li>Seeing that F doesn't cover new key</li>\n-     * <li>Popping stack, seeing that B covers new key (only by asking existing information in path)</li>\n-     * <li>Binary search B to select G to go down to</li>\n-     * </ol>\n-     *\n-     * The closer keys are together from one change to the next, the fewer page pins and searches needs\n-     * to be performed to get there.\n-     *\n-     * @param cursor {@link PageCursor} to move to the correct location.\n-     * @param key KEY to make change for.\n-     * @param stableGeneration stable generation.\n-     * @param unstableGeneration unstable generation.\n-     * @throws IOException on {@link PageCursor} error.\n-     */\n-    private void moveToCorrectLeaf( PageCursor cursor, KEY key, long stableGeneration, long unstableGeneration )\n-            throws IOException\n+    while (TreeNode.isInternal(cursor))\n     {\n-        int previousLevel = currentLevel;\n-        while ( !levels[currentLevel].covers( key ) )\n+      // We still need to go down further, but we're on the right path\n+      int keyCount = TreeNode.keyCount(cursor);\n+      int searchResult = search(cursor, INTERNAL, key, readKey, keyCount);\n+      int childPos = positionOf(searchResult);\n+      if (isHit(searchResult))\n+      {\n+        childPos++;\n+      }\n+\n+      Level<KEY> parentLevel = levels[currentLevel];\n+      currentLevel++;\n+      ensureStackCapacity(currentLevel + 1);\n+      Level<KEY> level = levels[currentLevel];\n+\n+      // Restrict the key range as the cursor moves down to the next level\n+      level.childPos = childPos;\n+      level.lowerIsOpenEnded = childPos == 0 &&\n+          !TreeNode.isNode(TreeNode.leftSibling(cursor, stableGeneration, unstableGeneration));\n+      if (!level.lowerIsOpenEnded)\n+      {\n+        if (childPos == 0)\n         {\n-            currentLevel--;\n-        }\n-        if ( currentLevel != previousLevel )\n+          layout.copyKey(parentLevel.lower, level.lower);\n+          level.lowerIsOpenEnded = parentLevel.lowerIsOpenEnded;\n+        } else\n         {\n-            TreeNode.goTo( cursor, \"parent\", levels[currentLevel].treeNodeId );\n+          bTreeNode.keyAt(cursor, level.lower, childPos - 1, INTERNAL);\n         }\n-\n-        while ( TreeNode.isInternal( cursor ) )\n+      }\n+      level.upperIsOpenEnded = childPos >= keyCount &&\n+          !TreeNode.isNode(TreeNode.rightSibling(cursor, stableGeneration, unstableGeneration));\n+      if (!level.upperIsOpenEnded)\n+      {\n+        if (childPos == keyCount)\n+        {\n+          layout.copyKey(parentLevel.upper, level.upper);\n+          level.upperIsOpenEnded = parentLevel.upperIsOpenEnded;\n+        } else\n         {\n-            // We still need to go down further, but we're on the right path\n-            int keyCount = TreeNode.keyCount( cursor );\n-            int searchResult = search( cursor, INTERNAL, key, readKey, keyCount );\n-            int childPos = positionOf( searchResult );\n-            if ( isHit( searchResult ) )\n-            {\n-                childPos++;\n-            }\n-\n-            Level<KEY> parentLevel = levels[currentLevel];\n-            currentLevel++;\n-            ensureStackCapacity( currentLevel + 1 );\n-            Level<KEY> level = levels[currentLevel];\n-\n-            // Restrict the key range as the cursor moves down to the next level\n-            level.childPos = childPos;\n-            level.lowerIsOpenEnded = childPos == 0 &&\n-                    !TreeNode.isNode( TreeNode.leftSibling( cursor, stableGeneration, unstableGeneration ) );\n-            if ( !level.lowerIsOpenEnded )\n-            {\n-                if ( childPos == 0 )\n-                {\n-                    layout.copyKey( parentLevel.lower, level.lower );\n-                    level.lowerIsOpenEnded = parentLevel.lowerIsOpenEnded;\n-                }\n-                else\n-                {\n-                    bTreeNode.keyAt( cursor, level.lower, childPos - 1, INTERNAL );\n-                }\n-            }\n-            level.upperIsOpenEnded = childPos >= keyCount &&\n-                    !TreeNode.isNode( TreeNode.rightSibling( cursor, stableGeneration, unstableGeneration ) );\n-            if ( !level.upperIsOpenEnded )\n-            {\n-                if ( childPos == keyCount )\n-                {\n-                    layout.copyKey( parentLevel.upper, level.upper );\n-                    level.upperIsOpenEnded = parentLevel.upperIsOpenEnded;\n-                }\n-                else\n-                {\n-                    bTreeNode.keyAt( cursor, level.upper, childPos, INTERNAL );\n-                }\n-            }\n-\n-            long childId = bTreeNode.childAt( cursor, childPos, stableGeneration, unstableGeneration );\n-            PointerChecking.checkPointer( childId, false );\n-\n-            TreeNode.goTo( cursor, \"child\", childId );\n-            level.treeNodeId = cursor.getCurrentPageId();\n-\n-            assert assertNoSuccessor( cursor, stableGeneration, unstableGeneration );\n+          bTreeNode.keyAt(cursor, level.upper, childPos, INTERNAL);\n         }\n+      }\n \n-        assert TreeNode.isLeaf( cursor ) : \"Ended up on a tree node which isn't a leaf after moving cursor towards \" +\n-                key + \", cursor is at \" + cursor.getCurrentPageId();\n-    }\n+      long childId = bTreeNode.childAt(cursor, childPos, stableGeneration, unstableGeneration);\n+      PointerChecking.checkPointer(childId, false);\n \n-    /**\n-     * Insert {@code key} and associate it with {@code value} if {@code key} does not already exist in\n-     * tree.\n-     * <p>\n-     * If {@code key} already exists in tree, {@code valueMerger} will be used to decide how to merge existing value\n-     * with {@code value}.\n-     * <p>\n-     * Insert may cause structural changes in the tree in form of splits and or new generation of nodes being created.\n-     * Note that a split in a leaf can propagate all the way up to root node.\n-     * <p>\n-     * Structural changes in tree that need to propagate to the level above will be reported through the provided\n-     * {@link StructurePropagation} by overwriting state. This is safe because structure changes happens one level\n-     * at the time.\n-     * {@link StructurePropagation} is provided from outside to minimize garbage.\n-     * <p>\n-     * When this method returns, {@code structurePropagation} will be populated with information about split or new\n-     * generation version of root. This needs to be handled by caller.\n-     * <p>\n-     * Leaves cursor at the page which was last updated. No guarantees on offset.\n-     *\n-     * @param cursor {@link PageCursor} pinned to root of tree (if first insert/remove since\n-     * {@link #initialize(PageCursor)}) or at where last insert/remove left it.\n-     * @param structurePropagation {@link StructurePropagation} used to report structure changes between tree levels.\n-     * @param key key to be inserted\n-     * @param value value to be associated with key\n-     * @param valueMerger {@link ValueMerger} for deciding what to do with existing keys\n-     * @param stableGeneration stable generation, i.e. generations <= this generation are considered stable.\n-     * @param unstableGeneration unstable generation, i.e. generation which is under development right now.\n-     * @throws IOException on cursor failure\n-     */\n-    void insert( PageCursor cursor, StructurePropagation<KEY> structurePropagation, KEY key, VALUE value,\n-            ValueMerger<KEY,VALUE> valueMerger, long stableGeneration, long unstableGeneration ) throws IOException\n-    {\n-        assert cursorIsAtExpectedLocation( cursor );\n-        bTreeNode.validateKeyValueSize( key, value );\n-        moveToCorrectLeaf( cursor, key, stableGeneration, unstableGeneration );\n-\n-        insertInLeaf( cursor, structurePropagation, key, value, valueMerger, stableGeneration, unstableGeneration );\n+      TreeNode.goTo(cursor, \"child\", childId);\n+      level.treeNodeId = cursor.getCurrentPageId();\n \n-        handleStructureChanges( cursor, structurePropagation, stableGeneration, unstableGeneration );\n+      assert assertNoSuccessor(cursor, stableGeneration, unstableGeneration);\n     }\n \n-    private int search( PageCursor cursor, TreeNode.Type type, KEY key, KEY readKey, int keyCount )\n+    assert TreeNode.isLeaf(cursor) : \"Ended up on a tree node which isn't a leaf after moving cursor towards \" +\n+        key + \", cursor is at \" + cursor.getCurrentPageId();\n+  }\n+\n+  /**\n+   * Insert {@code key} and associate it with {@code value} if {@code key} does not already exist in\n+   * tree.\n+   * <p>\n+   * If {@code key} already exists in tree, {@code valueMerger} will be used to decide how to merge existing value\n+   * with {@code value}.\n+   * <p>\n+   * Insert may cause structural changes in the tree in form of splits and or new generation of nodes being created.\n+   * Note that a split in a leaf can propagate all the way up to root node.\n+   * <p>\n+   * Structural changes in tree that need to propagate to the level above will be reported through the provided\n+   * {@link StructurePropagation} by overwriting state. This is safe because structure changes happens one level\n+   * at the time.\n+   * {@link StructurePropagation} is provided from outside to minimize garbage.\n+   * <p>\n+   * When this method returns, {@code structurePropagation} will be populated with information about split or new\n+   * generation version of root. This needs to be handled by caller.\n+   * <p>\n+   * Leaves cursor at the page which was last updated. No guarantees on offset.\n+   *\n+   * @param cursor               {@link PageCursor} pinned to root of tree (if first insert/remove since\n+   *                             {@link #initialize(PageCursor)}) or at where last insert/remove left it.\n+   * @param structurePropagation {@link StructurePropagation} used to report structure changes between tree levels.\n+   * @param key                  key to be inserted\n+   * @param value                value to be associated with key\n+   * @param valueMerger          {@link ValueMerger} for deciding what to do with existing keys\n+   * @param stableGeneration     stable generation, i.e. generations <= this generation are considered stable.\n+   * @param unstableGeneration   unstable generation, i.e. generation which is under development right now.\n+   * @throws IOException on cursor failure\n+   */\n+  void insert(PageCursor cursor, StructurePropagation<KEY> structurePropagation, KEY key, VALUE value,\n+              ValueMerger<KEY, VALUE> valueMerger, long stableGeneration, long unstableGeneration) throws IOException\n+  {\n+    assert cursorIsAtExpectedLocation(cursor);\n+    bTreeNode.validateKeyValueSize(key, value);\n+    moveToCorrectLeaf(cursor, key, stableGeneration, unstableGeneration);\n+\n+    insertInLeaf(cursor, structurePropagation, key, value, valueMerger, stableGeneration, unstableGeneration);\n+\n+    handleStructureChanges(cursor, structurePropagation, stableGeneration, unstableGeneration);\n+  }\n+\n+  private int search(PageCursor cursor, TreeNode.Type type, KEY key, KEY readKey, int keyCount)\n+  {\n+    int searchResult = KeySearch.search(cursor, bTreeNode, type, key, readKey, keyCount);\n+    KeySearch.assertSuccess(searchResult);\n+    return searchResult;\n+  }\n+\n+  /**\n+   * Asserts that cursor is where it's expected to be at, compared to current level.\n+   *\n+   * @param cursor {@link PageCursor} to check.\n+   * @return {@code true} so that it can be called in an {@code assert} statement.\n+   */\n+  private boolean cursorIsAtExpectedLocation(PageCursor cursor)\n+  {\n+    assert currentLevel >= 0 : \"Uninitialized tree logic, currentLevel:\" + currentLevel;\n+    long currentPageId = cursor.getCurrentPageId();\n+    long expectedPageId = levels[currentLevel].treeNodeId;\n+    assert currentPageId == expectedPageId : \"Expected cursor to be at page:\" +\n+        expectedPageId + \" at level:\" + currentLevel + \", but was at page:\" +\n+        currentPageId;\n+    return true;\n+  }\n+\n+  /**\n+   * Leaves cursor at same page as when called. No guarantees on offset.\n+   * <p>\n+   * Insertion in internal is always triggered by a split in child.\n+   * The result of a split is a primary key that is sent upwards in the b+tree and the newly created right child.\n+   *\n+   * @param cursor               {@link PageCursor} pinned to page containing internal node, current node\n+   * @param structurePropagation {@link StructurePropagation} used to report structure changes between tree levels.\n+   * @param keyCount             the key count of current node\n+   * @param primKey              the primary key to be inserted\n+   * @param rightChild           the right child of primKey\n+   * @throws IOException on cursor failure\n+   */\n+  private void insertInInternal(PageCursor cursor, StructurePropagation<KEY> structurePropagation, int keyCount,\n+                                KEY primKey, long rightChild, long stableGeneration, long unstableGeneration)\n+      throws IOException\n+  {\n+    createSuccessorIfNeeded(cursor, structurePropagation, UPDATE_MID_CHILD,\n+        stableGeneration, unstableGeneration);\n+\n+    doInsertInInternal(cursor, structurePropagation, keyCount, primKey, rightChild, stableGeneration, unstableGeneration);\n+  }\n+\n+  private void doInsertInInternal(PageCursor cursor, StructurePropagation<KEY> structurePropagation, int keyCount, KEY primKey,\n+                                  long rightChild, long stableGeneration, long unstableGeneration) throws IOException\n+  {\n+    Overflow overflow = bTreeNode.internalOverflow(cursor, keyCount, primKey);\n+    if (overflow == YES)\n     {\n-        int searchResult = KeySearch.search( cursor, bTreeNode, type, key, readKey, keyCount );\n-        KeySearch.assertSuccess( searchResult );\n-        return searchResult;\n+      // Overflow\n+      // We will overwrite rightKey in structurePropagation, so copy it over to a place holder\n+      layout.copyKey(primKey, newKeyPlaceHolder);\n+      splitInternal(cursor, structurePropagation, newKeyPlaceHolder, rightChild, keyCount,\n+          stableGeneration, unstableGeneration);\n+      return;\n     }\n \n-    /**\n-     * Asserts that cursor is where it's expected to be at, compared to current level.\n-     *\n-     * @param cursor {@link PageCursor} to check.\n-     * @return {@code true} so that it can be called in an {@code assert} statement.\n-     */\n-    private boolean cursorIsAtExpectedLocation( PageCursor cursor )\n+    if (overflow == NO_NEED_DEFRAG)\n     {\n-        assert currentLevel >= 0 : \"Uninitialized tree logic, currentLevel:\" + currentLevel;\n-        long currentPageId = cursor.getCurrentPageId();\n-        long expectedPageId = levels[currentLevel].treeNodeId;\n-        assert currentPageId == expectedPageId : \"Expected cursor to be at page:\" +\n-                expectedPageId + \" at level:\" + currentLevel + \", but was at page:\" +\n-                currentPageId;\n-        return true;\n+      bTreeNode.defragmentInternal(cursor);\n     }\n \n-    /**\n-     * Leaves cursor at same page as when called. No guarantees on offset.\n-     * <p>\n-     * Insertion in internal is always triggered by a split in child.\n-     * The result of a split is a primary key that is sent upwards in the b+tree and the newly created right child.\n-     *\n-     * @param cursor {@link PageCursor} pinned to page containing internal node, current node\n-     * @param structurePropagation {@link StructurePropagation} used to report structure changes between tree levels.\n-     * @param keyCount the key count of current node\n-     * @param primKey the primary key to be inserted\n-     * @param rightChild the right child of primKey\n-     * @throws IOException on cursor failure\n-     */\n-    private void insertInInternal( PageCursor cursor, StructurePropagation<KEY> structurePropagation, int keyCount,\n-            KEY primKey, long rightChild, long stableGeneration, long unstableGeneration )\n-            throws IOException\n+    // No overflow\n+    int pos = positionOf(search(cursor, INTERNAL, primKey, readKey, keyCount));\n+    bTreeNode.insertKeyAndRightChildAt(cursor, primKey, rightChild, pos, keyCount, stableGeneration, unstableGeneration);\n+    // Increase key count\n+    TreeNode.setKeyCount(cursor, keyCount + 1);\n+  }\n+\n+  /**\n+   * Leaves cursor at same page as when called. No guarantees on offset.\n+   * <p>\n+   * Split in internal node caused by an insertion of rightKey and newRightChild\n+   *\n+   * @param cursor               {@link PageCursor} pinned to page containing internal node, full node.\n+   * @param structurePropagation {@link StructurePropagation} used to report structure changes between tree levels.\n+   * @param newKey               new key to be inserted together with newRightChild, causing the split\n+   * @param newRightChild        new child to be inserted to the right of newKey\n+   * @param keyCount             key count for fullNode\n+   * @throws IOException on cursor failure\n+   */\n+  private void splitInternal(PageCursor cursor, StructurePropagation<KEY> structurePropagation, KEY newKey,\n+                             long newRightChild, int keyCount, long stableGeneration, long unstableGeneration) throws IOException\n+  {\n+    long current = cursor.getCurrentPageId();\n+    long oldRight = TreeNode.rightSibling(cursor, stableGeneration, unstableGeneration);\n+    PointerChecking.checkPointer(oldRight, true);\n+    long newRight = idProvider.acquireNewId(stableGeneration, unstableGeneration);\n+\n+    // Find position to insert new key\n+    int pos = positionOf(search(cursor, INTERNAL, newKey, readKey, keyCount));\n+\n+    // Update structurePropagation\n+    structurePropagation.hasRightKeyInsert = true;\n+    structurePropagation.midChild = current;\n+    structurePropagation.rightChild = newRight;\n+\n+    try (PageCursor rightCursor = cursor.openLinkedCursor(newRight))\n     {\n-        createSuccessorIfNeeded( cursor, structurePropagation, UPDATE_MID_CHILD,\n-                stableGeneration, unstableGeneration );\n-\n-        doInsertInInternal( cursor, structurePropagation, keyCount, primKey, rightChild, stableGeneration, unstableGeneration );\n+      // Initialize new right\n+      TreeNode.goTo(rightCursor, \"new right sibling in split\", newRight);\n+      bTreeNode.initializeInternal(rightCursor, stableGeneration, unstableGeneration);\n+      TreeNode.setRightSibling(rightCursor, oldRight, stableGeneration, unstableGeneration);\n+      TreeNode.setLeftSibling(rightCursor, current, stableGeneration, unstableGeneration);\n+\n+      // Do split\n+      bTreeNode.doSplitInternal(cursor, keyCount, rightCursor, pos, newKey, newRightChild, stableGeneration, unstableGeneration,\n+          structurePropagation.rightKey);\n     }\n \n-    private void doInsertInInternal( PageCursor cursor, StructurePropagation<KEY> structurePropagation, int keyCount, KEY primKey,\n-            long rightChild, long stableGeneration, long unstableGeneration ) throws IOException\n+    // Update old right with new left sibling (newRight)\n+    if (TreeNode.isNode(oldRight))\n     {\n-        Overflow overflow = bTreeNode.internalOverflow( cursor, keyCount, primKey );\n-        if ( overflow == YES )\n-        {\n-            // Overflow\n-            // We will overwrite rightKey in structurePropagation, so copy it over to a place holder\n-            layout.copyKey( primKey, newKeyPlaceHolder );\n-            splitInternal( cursor, structurePropagation, newKeyPlaceHolder, rightChild, keyCount,\n-                    stableGeneration, unstableGeneration );\n-            return;\n-        }\n-\n-        if ( overflow == NO_NEED_DEFRAG )\n-        {\n-            bTreeNode.defragmentInternal( cursor );\n-        }\n-\n-        // No overflow\n-        int pos = positionOf( search( cursor, INTERNAL, primKey, readKey, keyCount ) );\n-        bTreeNode.insertKeyAndRightChildAt( cursor, primKey, rightChild, pos, keyCount, stableGeneration, unstableGeneration );\n-        // Increase key count\n-        TreeNode.setKeyCount( cursor, keyCount + 1 );\n+      try (PageCursor oldRightCursor = cursor.openLinkedCursor(oldRight))\n+      {\n+        TreeNode.goTo(oldRightCursor, \"old right sibling\", oldRight);\n+        TreeNode.setLeftSibling(oldRightCursor, newRight, stableGeneration, unstableGeneration);\n+      }\n     }\n \n-    /**\n-     * Leaves cursor at same page as when called. No guarantees on offset.\n-     * <p>\n-     * Split in internal node caused by an insertion of rightKey and newRightChild\n-     *\n-     * @param cursor {@link PageCursor} pinned to page containing internal node, full node.\n-     * @param structurePropagation {@link StructurePropagation} used to report structure changes between tree levels.\n-     * @param newKey new key to be inserted together with newRightChild, causing the split\n-     * @param newRightChild new child to be inserted to the right of newKey\n-     * @param keyCount key count for fullNode\n-     * @throws IOException on cursor failure\n-     */\n-    private void splitInternal( PageCursor cursor, StructurePropagation<KEY> structurePropagation, KEY newKey,\n-            long newRightChild, int keyCount, long stableGeneration, long unstableGeneration ) throws IOException\n+    // Update left node with new right sibling\n+    TreeNode.setRightSibling(cursor, newRight, stableGeneration, unstableGeneration);\n+  }\n+\n+  /**\n+   * Leaves cursor at same page as when called. No guarantees on offset.\n+   * <p>\n+   * Split in leaf node caused by an insertion of key and value\n+   *\n+   * @param cursor               {@link PageCursor} pinned to page containing leaf node targeted for insertion.\n+   * @param structurePropagation {@link StructurePropagation} used to report structure changes between tree levels.\n+   * @param key                  key to be inserted\n+   * @param value                value to be associated with key\n+   * @param valueMerger          {@link ValueMerger} for deciding what to do with existing keys\n+   * @throws IOException on cursor failure\n+   */\n+  private void insertInLeaf(PageCursor cursor, StructurePropagation<KEY> structurePropagation, KEY key, VALUE value,\n+                            ValueMerger<KEY, VALUE> valueMerger, long stableGeneration, long unstableGeneration) throws IOException\n+  {\n+    int keyCount = TreeNode.keyCount(cursor);\n+    int search = search(cursor, LEAF, key, readKey, keyCount);\n+    int pos = positionOf(search);\n+    if (isHit(search))\n     {\n-        long current = cursor.getCurrentPageId();\n-        long oldRight = TreeNode.rightSibling( cursor, stableGeneration, unstableGeneration );\n-        PointerChecking.checkPointer( oldRight, true );\n-        long newRight = idProvider.acquireNewId( stableGeneration, unstableGeneration );\n-\n-        // Find position to insert new key\n-        int pos = positionOf( search( cursor, INTERNAL, newKey, readKey, keyCount ) );\n+      overwriteValue(cursor, structurePropagation, key, value, valueMerger, pos, keyCount, stableGeneration, unstableGeneration);\n+      return;\n+    }\n \n-        // Update structurePropagation\n-        structurePropagation.hasRightKeyInsert = true;\n-        structurePropagation.midChild = current;\n-        structurePropagation.rightChild = newRight;\n+    createSuccessorIfNeeded(cursor, structurePropagation, UPDATE_MID_CHILD, stableGeneration, unstableGeneration);\n \n-        try ( PageCursor rightCursor = cursor.openLinkedCursor( newRight ) )\n-        {\n-            // Initialize new right\n-            TreeNode.goTo( rightCursor, \"new right sibling in split\", newRight );\n-            bTreeNode.initializeInternal( rightCursor, stableGeneration, unstableGeneration );\n-            TreeNode.setRightSibling( rightCursor, oldRight, stableGeneration, unstableGeneration );\n-            TreeNode.setLeftSibling( rightCursor, current, stableGeneration, unstableGeneration );\n-\n-            // Do split\n-            bTreeNode.doSplitInternal( cursor, keyCount, rightCursor, pos, newKey, newRightChild, stableGeneration, unstableGeneration,\n-                    structurePropagation.rightKey );\n-        }\n+    doInsertInLeaf(cursor, structurePropagation, key, value, pos, keyCount, stableGeneration, unstableGeneration);\n+  }\n \n-        // Update old right with new left sibling (newRight)\n-        if ( TreeNode.isNode( oldRight ) )\n+  private void overwriteValue(PageCursor cursor, StructurePropagation<KEY> structurePropagation, KEY key, VALUE value,\n+                              ValueMerger<KEY, VALUE> valueMerger, int pos, int keyCount, long stableGeneration, long unstableGeneration) throws IOException\n+  {\n+    // this key already exists, what shall we do? ask the valueMerger\n+    bTreeNode.valueAt(cursor, readValue, pos);\n+    VALUE mergedValue = valueMerger.merge(readKey, key, readValue, value);\n+    if (mergedValue != null)\n+    {\n+      createSuccessorIfNeeded(cursor, structurePropagation, UPDATE_MID_CHILD, stableGeneration, unstableGeneration);\n+      // simple, just write the merged value right in there\n+      boolean couldOverwrite = bTreeNode.setValueAt(cursor, mergedValue, pos);\n+      //noinspection StatementWithEmptyBody\n+      if (!couldOverwrite)\n+      {\n+        // Value could not be overwritten in a simple way because they differ in size.\n+        // Delete old value\n+        bTreeNode.removeKeyValueAt(cursor, pos, keyCount);\n+        TreeNode.setKeyCount(cursor, keyCount - 1);\n+        boolean didSplit =\n+            doInsertInLeaf(cursor, structurePropagation, key, mergedValue, pos, keyCount - 1, stableGeneration, unstableGeneration);\n+        if (!didSplit && bTreeNode.leafUnderflow(cursor, keyCount))\n         {\n-            try ( PageCursor oldRightCursor = cursor.openLinkedCursor( oldRight ) )\n-            {\n-                TreeNode.goTo( oldRightCursor, \"old right sibling\", oldRight );\n-                TreeNode.setLeftSibling( oldRightCursor, newRight, stableGeneration, unstableGeneration );\n-            }\n+          underflowInLeaf(cursor, structurePropagation, keyCount, stableGeneration, unstableGeneration);\n         }\n-\n-        // Update left node with new right sibling\n-        TreeNode.setRightSibling( cursor, newRight, stableGeneration, unstableGeneration );\n+      }\n     }\n+  }\n \n-    /**\n-     * Leaves cursor at same page as when called. No guarantees on offset.\n-     * <p>\n-     * Split in leaf node caused by an insertion of key and value\n-     *\n-     * @param cursor {@link PageCursor} pinned to page containing leaf node targeted for insertion.\n-     * @param structurePropagation {@link StructurePropagation} used to report structure changes between tree levels.\n-     * @param key key to be inserted\n-     * @param value value to be associated with key\n-     * @param valueMerger {@link ValueMerger} for deciding what to do with existing keys\n-     * @throws IOException on cursor failure\n-     */\n-    private void insertInLeaf( PageCursor cursor, StructurePropagation<KEY> structurePropagation, KEY key, VALUE value,\n-            ValueMerger<KEY,VALUE> valueMerger, long stableGeneration, long unstableGeneration ) throws IOException\n+  private boolean doInsertInLeaf(PageCursor cursor, StructurePropagation<KEY> structurePropagation, KEY key, VALUE value, int pos,\n+                                 int keyCount, long stableGeneration, long unstableGeneration) throws IOException\n+  {\n+    Overflow overflow = bTreeNode.leafOverflow(cursor, keyCount, key, value);\n+    if (overflow == YES)\n     {\n-        int keyCount = TreeNode.keyCount( cursor );\n-        int search = search( cursor, LEAF, key, readKey, keyCount );\n-        int pos = positionOf( search );\n-        if ( isHit( search ) )\n-        {\n-            overwriteValue( cursor, structurePropagation, key, value, valueMerger, pos, keyCount, stableGeneration, unstableGeneration );\n-            return;\n-        }\n+      // Overflow, split leaf\n+      splitLeaf(cursor, structurePropagation, key, value, keyCount, stableGeneration, unstableGeneration);\n+      return true;\n+    }\n \n-        createSuccessorIfNeeded( cursor, structurePropagation, UPDATE_MID_CHILD, stableGeneration, unstableGeneration );\n+    if (overflow == NO_NEED_DEFRAG)\n+    {\n+      bTreeNode.defragmentLeaf(cursor);\n+    }\n \n-        doInsertInLeaf( cursor, structurePropagation, key, value, pos, keyCount, stableGeneration, unstableGeneration );\n+    // No overflow, insert key and value\n+    bTreeNode.insertKeyValueAt(cursor, key, value, pos, keyCount);\n+    TreeNode.setKeyCount(cursor, keyCount + 1);\n+    return false;\n+  }\n+\n+  /**\n+   * Leaves cursor at same page as when called. No guarantees on offset.\n+   * Cursor is expected to be pointing to full leaf.\n+   *\n+   * @param cursor               cursor pointing into full (left) leaf that should be split in two.\n+   * @param structurePropagation {@link StructurePropagation} used to report structure changes between tree levels.\n+   * @param newKey               key to be inserted\n+   * @param newValue             value to be inserted (in association with key)\n+   * @param keyCount             number of keys in this leaf (it was already read anyway)\n+   * @throws IOException on cursor failure\n+   */\n+  private void splitLeaf(PageCursor cursor, StructurePropagation<KEY> structurePropagation,\n+                         KEY newKey, VALUE newValue, int keyCount, long stableGeneration, long unstableGeneration)\n+      throws IOException\n+  {\n+    // To avoid moving cursor between pages we do all operations on left node first.\n+\n+    // UPDATE SIBLINGS\n+    //\n+    // Before split\n+    // newRight is leaf node to be inserted between left and oldRight\n+    // [left] -> [oldRight]\n+    //\n+    //     [newRight]\n+    //\n+    // After split\n+    // [left] -> [newRight] -> [oldRight]\n+    //\n+\n+    long current = cursor.getCurrentPageId();\n+    long oldRight = TreeNode.rightSibling(cursor, stableGeneration, unstableGeneration);\n+    PointerChecking.checkPointer(oldRight, true);\n+    long newRight = idProvider.acquireNewId(stableGeneration, unstableGeneration);\n+\n+    // BALANCE KEYS AND VALUES\n+    // Two different scenarios\n+    // Before split\n+    // [key1]<=[key2]<=[key3]<=[key4]<=[key5]   (<= greater than or equal to)\n+    //                           ^\n+    //                           |\n+    //                      pos  |\n+    // [newKey] -----------------\n+    //\n+    // After split\n+    // Left\n+    // [key1]<=[key2]<=[key3]\n+    //\n+    // Right\n+    // [newKey][key4][key5]\n+    //\n+    // Before split\n+    // [key1]<=[key2]<=[key3]<=[key4]<=[key5]   (<= greater than or equal to)\n+    //   ^\n+    //   | pos\n+    //   |\n+    // [newKey]\n+    //\n+    // After split\n+    // Left\n+    // [newKey]<=[key1]<=[key2]\n+    //\n+    // Right\n+    // [key3][key4][key5]\n+    //\n+\n+    // CONCURRENCY\n+    // To have readers see correct state at all times, the order of updates must be:\n+    // 1. Acquire new page id R\n+    // 2. Copy \"right-hand\" keys/values to R and set key count\n+    // 3. Set L's right sibling to R\n+    // 4. Set key count of L to new \"left-hand\" key count\n+    // 5. Write new key/values into L\n+\n+    // Position where newKey / newValue is to be inserted\n+    int pos = positionOf(search(cursor, LEAF, newKey, readKey, keyCount));\n+\n+    structurePropagation.hasRightKeyInsert = true;\n+    structurePropagation.midChild = current;\n+    structurePropagation.rightChild = newRight;\n+\n+    try (PageCursor rightCursor = cursor.openLinkedCursor(newRight))\n+    {\n+      // Initialize new right\n+      TreeNode.goTo(rightCursor, \"new right sibling in split\", newRight);\n+      bTreeNode.initializeLeaf(rightCursor, stableGeneration, unstableGeneration);\n+      TreeNode.setRightSibling(rightCursor, oldRight, stableGeneration, unstableGeneration);\n+      TreeNode.setLeftSibling(rightCursor, current, stableGeneration, unstableGeneration);\n+\n+      // Do split\n+      bTreeNode.doSplitLeaf(cursor, keyCount, rightCursor, pos, newKey, newValue, structurePropagation.rightKey);\n     }\n \n-    private void overwriteValue( PageCursor cursor, StructurePropagation<KEY> structurePropagation, KEY key, VALUE value,\n-            ValueMerger<KEY,VALUE> valueMerger, int pos, int keyCount, long stableGeneration, long unstableGeneration ) throws IOException\n+    // Update old right with new left sibling (newRight)\n+    if (TreeNode.isNode(oldRight))\n     {\n-        // this key already exists, what shall we do? ask the valueMerger\n-        bTreeNode.valueAt( cursor, readValue, pos );\n-        VALUE mergedValue = valueMerger.merge( readKey, key, readValue, value );\n-        if ( mergedValue != null )\n-        {\n-            createSuccessorIfNeeded( cursor, structurePropagation, UPDATE_MID_CHILD, stableGeneration, unstableGeneration );\n-            // simple, just write the merged value right in there\n-            boolean couldOverwrite = bTreeNode.setValueAt( cursor, mergedValue, pos );\n-            //noinspection StatementWithEmptyBody\n-            if ( !couldOverwrite )\n-            {\n-                // Value could not be overwritten in a simple way because they differ in size.\n-                // Delete old value\n-                bTreeNode.removeKeyValueAt( cursor, pos, keyCount );\n-                TreeNode.setKeyCount( cursor, keyCount - 1 );\n-                boolean didSplit =\n-                        doInsertInLeaf( cursor, structurePropagation, key, mergedValue, pos, keyCount - 1, stableGeneration, unstableGeneration );\n-                if ( !didSplit && bTreeNode.leafUnderflow( cursor, keyCount ) )\n-                {\n-                    underflowInLeaf( cursor, structurePropagation, keyCount, stableGeneration, unstableGeneration );\n-                }\n-            }\n-        }\n+      try (PageCursor oldRightCursor = cursor.openLinkedCursor(oldRight))\n+      {\n+        TreeNode.goTo(oldRightCursor, \"old right sibling\", oldRight);\n+        TreeNode.setLeftSibling(oldRightCursor, newRight, stableGeneration, unstableGeneration);\n+      }\n     }\n \n-    private boolean doInsertInLeaf( PageCursor cursor, StructurePropagation<KEY> structurePropagation, KEY key, VALUE value, int pos,\n-            int keyCount, long stableGeneration, long unstableGeneration ) throws IOException\n+    // Update left child\n+    TreeNode.setRightSibling(cursor, newRight, stableGeneration, unstableGeneration);\n+  }\n+\n+  /**\n+   * Remove given {@code key} and associated value from tree if it exists. The removed value will be stored in\n+   * provided {@code into} which will be returned for convenience.\n+   * <p>\n+   * If the given {@code key} does not exist in tree, return {@code null}.\n+   * <p>\n+   * Structural changes in tree that need to propagate to the level above will be reported through the provided\n+   * {@link StructurePropagation} by overwriting state. This is safe because structure changes happens one level\n+   * at the time.\n+   * {@link StructurePropagation} is provided from outside to minimize garbage.\n+   * <p>\n+   * Leaves cursor at the page which was last updated. No guarantees on offset.\n+   *\n+   * @param cursor               {@link PageCursor} pinned to root of tree (if first insert/remove since\n+   *                             {@link #initialize(PageCursor)}) or at where last insert/remove left it.\n+   * @param structurePropagation {@link StructurePropagation} used to report structure changes between tree levels.\n+   * @param key                  key to be removed\n+   * @param into                 {@code VALUE} instance to write removed value to\n+   * @param stableGeneration     stable generation, i.e. generations <= this generation are considered stable.\n+   * @param unstableGeneration   unstable generation, i.e. generation which is under development right now.\n+   * @return Provided {@code into}, populated with removed value for convenience if {@code key} was removed.\n+   * Otherwise {@code null}.\n+   * @throws IOException on cursor failure\n+   */\n+  VALUE remove(PageCursor cursor, StructurePropagation<KEY> structurePropagation, KEY key, VALUE into,\n+               long stableGeneration, long unstableGeneration) throws IOException\n+  {\n+    assert cursorIsAtExpectedLocation(cursor);\n+    moveToCorrectLeaf(cursor, key, stableGeneration, unstableGeneration);\n+\n+    if (!removeFromLeaf(cursor, structurePropagation, key, into, stableGeneration, unstableGeneration))\n     {\n-        Overflow overflow = bTreeNode.leafOverflow( cursor, keyCount, key, value );\n-        if ( overflow == YES )\n-        {\n-            // Overflow, split leaf\n-            splitLeaf( cursor, structurePropagation, key, value, keyCount, stableGeneration, unstableGeneration );\n-            return true;\n-        }\n+      return null;\n+    }\n \n-        if ( overflow == NO_NEED_DEFRAG )\n-        {\n-            bTreeNode.defragmentLeaf( cursor );\n-        }\n+    handleStructureChanges(cursor, structurePropagation, stableGeneration, unstableGeneration);\n \n-        // No overflow, insert key and value\n-        bTreeNode.insertKeyValueAt( cursor, key, value, pos, keyCount );\n-        TreeNode.setKeyCount( cursor, keyCount + 1 );\n-        return false;\n+    if (currentLevel <= 0)\n+    {\n+      tryShrinkTree(cursor, structurePropagation, stableGeneration, unstableGeneration);\n     }\n \n-    /**\n-     * Leaves cursor at same page as when called. No guarantees on offset.\n-     * Cursor is expected to be pointing to full leaf.\n-     *\n-     * @param cursor cursor pointing into full (left) leaf that should be split in two.\n-     * @param structurePropagation {@link StructurePropagation} used to report structure changes between tree levels.\n-     * @param newKey key to be inserted\n-     * @param newValue value to be inserted (in association with key)\n-     * @param keyCount number of keys in this leaf (it was already read anyway)\n-     * @throws IOException on cursor failure\n-     */\n-    private void splitLeaf( PageCursor cursor, StructurePropagation<KEY> structurePropagation,\n-            KEY newKey, VALUE newValue, int keyCount, long stableGeneration, long unstableGeneration )\n-                    throws IOException\n+    return into;\n+  }\n+\n+  private void handleStructureChanges(PageCursor cursor, StructurePropagation<KEY> structurePropagation,\n+                                      long stableGeneration, long unstableGeneration) throws IOException\n+  {\n+    while (structurePropagation.hasLeftChildUpdate ||\n+        structurePropagation.hasMidChildUpdate ||\n+        structurePropagation.hasRightChildUpdate ||\n+        structurePropagation.hasLeftKeyReplace ||\n+        structurePropagation.hasRightKeyReplace ||\n+        structurePropagation.hasRightKeyInsert)\n     {\n-        // To avoid moving cursor between pages we do all operations on left node first.\n-\n-        // UPDATE SIBLINGS\n-        //\n-        // Before split\n-        // newRight is leaf node to be inserted between left and oldRight\n-        // [left] -> [oldRight]\n-        //\n-        //     [newRight]\n-        //\n-        // After split\n-        // [left] -> [newRight] -> [oldRight]\n-        //\n-\n-        long current = cursor.getCurrentPageId();\n-        long oldRight = TreeNode.rightSibling( cursor, stableGeneration, unstableGeneration );\n-        PointerChecking.checkPointer( oldRight, true );\n-        long newRight = idProvider.acquireNewId( stableGeneration, unstableGeneration );\n-\n-        // BALANCE KEYS AND VALUES\n-        // Two different scenarios\n-        // Before split\n-        // [key1]<=[key2]<=[key3]<=[key4]<=[key5]   (<= greater than or equal to)\n-        //                           ^\n-        //                           |\n-        //                      pos  |\n-        // [newKey] -----------------\n-        //\n-        // After split\n-        // Left\n-        // [key1]<=[key2]<=[key3]\n-        //\n-        // Right\n-        // [newKey][key4][key5]\n-        //\n-        // Before split\n-        // [key1]<=[key2]<=[key3]<=[key4]<=[key5]   (<= greater than or equal to)\n-        //   ^\n-        //   | pos\n-        //   |\n-        // [newKey]\n-        //\n-        // After split\n-        // Left\n-        // [newKey]<=[key1]<=[key2]\n-        //\n-        // Right\n-        // [key3][key4][key5]\n-        //\n-\n-        // CONCURRENCY\n-        // To have readers see correct state at all times, the order of updates must be:\n-        // 1. Acquire new page id R\n-        // 2. Copy \"right-hand\" keys/values to R and set key count\n-        // 3. Set L's right sibling to R\n-        // 4. Set key count of L to new \"left-hand\" key count\n-        // 5. Write new key/values into L\n-\n-        // Position where newKey / newValue is to be inserted\n-        int pos = positionOf( search( cursor, LEAF, newKey, readKey, keyCount ) );\n-\n-        structurePropagation.hasRightKeyInsert = true;\n-        structurePropagation.midChild = current;\n-        structurePropagation.rightChild = newRight;\n-\n-        try ( PageCursor rightCursor = cursor.openLinkedCursor( newRight ) )\n+      int pos = levels[currentLevel].childPos;\n+      if (!popLevel(cursor))\n+      {\n+        // Root split, let that be handled outside\n+        break;\n+      }\n+\n+      if (structurePropagation.hasLeftChildUpdate)\n+      {\n+        structurePropagation.hasLeftChildUpdate = false;\n+        if (pos == 0)\n         {\n-            // Initialize new right\n-            TreeNode.goTo( rightCursor, \"new right sibling in split\", newRight );\n-            bTreeNode.initializeLeaf( rightCursor, stableGeneration, unstableGeneration );\n-            TreeNode.setRightSibling( rightCursor, oldRight, stableGeneration, unstableGeneration );\n-            TreeNode.setLeftSibling( rightCursor, current, stableGeneration, unstableGeneration );\n-\n-            // Do split\n-            bTreeNode.doSplitLeaf( cursor, keyCount, rightCursor, pos, newKey, newValue, structurePropagation.rightKey );\n-        }\n-\n-        // Update old right with new left sibling (newRight)\n-        if ( TreeNode.isNode( oldRight ) )\n+          updateRightmostChildInLeftSibling(cursor, structurePropagation.leftChild,\n+              stableGeneration, unstableGeneration);\n+        } else\n         {\n-            try ( PageCursor oldRightCursor = cursor.openLinkedCursor( oldRight ) )\n-            {\n-                TreeNode.goTo( oldRightCursor, \"old right sibling\", oldRight );\n-                TreeNode.setLeftSibling( oldRightCursor, newRight, stableGeneration, unstableGeneration );\n-            }\n+          bTreeNode.setChildAt(cursor, structurePropagation.leftChild, pos - 1,\n+              stableGeneration, unstableGeneration);\n         }\n-\n-        // Update left child\n-        TreeNode.setRightSibling( cursor, newRight, stableGeneration, unstableGeneration );\n-    }\n-\n-    /**\n-     * Remove given {@code key} and associated value from tree if it exists. The removed value will be stored in\n-     * provided {@code into} which will be returned for convenience.\n-     * <p>\n-     * If the given {@code key} does not exist in tree, return {@code null}.\n-     * <p>\n-     * Structural changes in tree that need to propagate to the level above will be reported through the provided\n-     * {@link StructurePropagation} by overwriting state. This is safe because structure changes happens one level\n-     * at the time.\n-     * {@link StructurePropagation} is provided from outside to minimize garbage.\n-     * <p>\n-     * Leaves cursor at the page which was last updated. No guarantees on offset.\n-     *\n-     * @param cursor {@link PageCursor} pinned to root of tree (if first insert/remove since\n-     * {@link #initialize(PageCursor)}) or at where last insert/remove left it.\n-     * @param structurePropagation {@link StructurePropagation} used to report structure changes between tree levels.\n-     * @param key key to be removed\n-     * @param into {@code VALUE} instance to write removed value to\n-     * @param stableGeneration stable generation, i.e. generations <= this generation are considered stable.\n-     * @param unstableGeneration unstable generation, i.e. generation which is under development right now.\n-     * @return Provided {@code into}, populated with removed value for convenience if {@code key} was removed.\n-     * Otherwise {@code null}.\n-     * @throws IOException on cursor failure\n-     */\n-    VALUE remove( PageCursor cursor, StructurePropagation<KEY> structurePropagation, KEY key, VALUE into,\n-            long stableGeneration, long unstableGeneration ) throws IOException\n-    {\n-        assert cursorIsAtExpectedLocation( cursor );\n-        moveToCorrectLeaf( cursor, key, stableGeneration, unstableGeneration );\n-\n-        if ( !removeFromLeaf( cursor, structurePropagation, key, into, stableGeneration, unstableGeneration ) )\n+      }\n+\n+      if (structurePropagation.hasMidChildUpdate)\n+      {\n+        updateMidChild(cursor, structurePropagation, pos, stableGeneration, unstableGeneration);\n+      }\n+\n+      if (structurePropagation.hasRightChildUpdate)\n+      {\n+        structurePropagation.hasRightChildUpdate = false;\n+        int keyCount = TreeNode.keyCount(cursor);\n+        if (pos == keyCount)\n         {\n-            return null;\n+          updateLeftmostChildInRightSibling(cursor, structurePropagation.rightChild,\n+              stableGeneration, unstableGeneration);\n+        } else\n+        {\n+          bTreeNode.setChildAt(cursor, structurePropagation.rightChild, pos + 1,\n+              stableGeneration, unstableGeneration);\n         }\n-\n-        handleStructureChanges( cursor, structurePropagation, stableGeneration, unstableGeneration );\n-\n-        if ( currentLevel <= 0 )\n+      }\n+\n+      // Insert before replace because replace can lead to split and another insert in next level.\n+      // Replace can only come from rebalance on lower levels and because we do no rebalance among\n+      // internal nodes we will only ever have one replace on our way up.\n+      if (structurePropagation.hasRightKeyInsert)\n+      {\n+        structurePropagation.hasRightKeyInsert = false;\n+        insertInInternal(cursor, structurePropagation, TreeNode.keyCount(cursor),\n+            structurePropagation.rightKey, structurePropagation.rightChild,\n+            stableGeneration, unstableGeneration);\n+      }\n+\n+      if (structurePropagation.hasLeftKeyReplace &&\n+          levels[currentLevel].covers(structurePropagation.leftKey))\n+      {\n+        structurePropagation.hasLeftKeyReplace = false;\n+        switch (structurePropagation.keyReplaceStrategy)\n         {\n-            tryShrinkTree( cursor, structurePropagation, stableGeneration, unstableGeneration );\n+          case REPLACE:\n+            overwriteKeyInternal(cursor, structurePropagation, structurePropagation.leftKey, pos - 1,\n+                stableGeneration, unstableGeneration);\n+            break;\n+          case BUBBLE:\n+            replaceKeyByBubbleRightmostFromSubtree(cursor, structurePropagation, pos - 1,\n+                stableGeneration, unstableGeneration);\n+            break;\n+          default:\n+            throw new IllegalArgumentException(\"Unknown KeyReplaceStrategy \" +\n+                structurePropagation.keyReplaceStrategy);\n         }\n+      }\n \n-        return into;\n-    }\n-\n-    private void handleStructureChanges( PageCursor cursor, StructurePropagation<KEY> structurePropagation,\n-            long stableGeneration, long unstableGeneration ) throws IOException\n-    {\n-        while ( structurePropagation.hasLeftChildUpdate  ||\n-                structurePropagation.hasMidChildUpdate ||\n-                structurePropagation.hasRightChildUpdate ||\n-                structurePropagation.hasLeftKeyReplace ||\n-                structurePropagation.hasRightKeyReplace ||\n-                structurePropagation.hasRightKeyInsert )\n+      if (structurePropagation.hasRightKeyReplace &&\n+          levels[currentLevel].covers(structurePropagation.rightKey))\n+      {\n+        structurePropagation.hasRightKeyReplace = false;\n+        switch (structurePropagation.keyReplaceStrategy)\n         {\n-            int pos = levels[currentLevel].childPos;\n-            if ( !popLevel( cursor ) )\n-            {\n-                // Root split, let that be handled outside\n-                break;\n-            }\n-\n-            if ( structurePropagation.hasLeftChildUpdate )\n-            {\n-                structurePropagation.hasLeftChildUpdate = false;\n-                if ( pos == 0 )\n-                {\n-                    updateRightmostChildInLeftSibling( cursor, structurePropagation.leftChild,\n-                            stableGeneration, unstableGeneration );\n-                }\n-                else\n-                {\n-                    bTreeNode.setChildAt( cursor, structurePropagation.leftChild, pos - 1,\n-                            stableGeneration, unstableGeneration );\n-                }\n-            }\n-\n-            if ( structurePropagation.hasMidChildUpdate )\n-            {\n-                updateMidChild( cursor, structurePropagation, pos, stableGeneration, unstableGeneration );\n-            }\n-\n-            if ( structurePropagation.hasRightChildUpdate )\n-            {\n-                structurePropagation.hasRightChildUpdate = false;\n-                int keyCount = TreeNode.keyCount( cursor );\n-                if ( pos == keyCount )\n-                {\n-                    updateLeftmostChildInRightSibling( cursor, structurePropagation.rightChild,\n-                            stableGeneration, unstableGeneration );\n-                }\n-                else\n-                {\n-                    bTreeNode.setChildAt( cursor, structurePropagation.rightChild, pos + 1,\n-                            stableGeneration, unstableGeneration );\n-                }\n-            }\n-\n-            // Insert before replace because replace can lead to split and another insert in next level.\n-            // Replace can only come from rebalance on lower levels and because we do no rebalance among\n-            // internal nodes we will only ever have one replace on our way up.\n-            if ( structurePropagation.hasRightKeyInsert )\n-            {\n-                structurePropagation.hasRightKeyInsert = false;\n-                insertInInternal( cursor, structurePropagation, TreeNode.keyCount( cursor ),\n-                        structurePropagation.rightKey, structurePropagation.rightChild,\n-                        stableGeneration, unstableGeneration );\n-            }\n-\n-            if ( structurePropagation.hasLeftKeyReplace &&\n-                    levels[currentLevel].covers( structurePropagation.leftKey ) )\n-            {\n-                structurePropagation.hasLeftKeyReplace = false;\n-                switch ( structurePropagation.keyReplaceStrategy )\n-                {\n-                case REPLACE:\n-                    overwriteKeyInternal( cursor, structurePropagation, structurePropagation.leftKey, pos - 1,\n-                            stableGeneration, unstableGeneration );\n-                    break;\n-                case BUBBLE:\n-                    replaceKeyByBubbleRightmostFromSubtree( cursor, structurePropagation, pos - 1,\n-                            stableGeneration, unstableGeneration );\n-                    break;\n-                default:\n-                    throw new IllegalArgumentException( \"Unknown KeyReplaceStrategy \" +\n-                            structurePropagation.keyReplaceStrategy );\n-                }\n-            }\n-\n-            if ( structurePropagation.hasRightKeyReplace &&\n-                    levels[currentLevel].covers( structurePropagation.rightKey ) )\n-            {\n-                structurePropagation.hasRightKeyReplace = false;\n-                switch ( structurePropagation.keyReplaceStrategy )\n-                {\n-                case REPLACE:\n-                    overwriteKeyInternal( cursor, structurePropagation, structurePropagation.rightKey, pos,\n-                            stableGeneration, unstableGeneration );\n-                    break;\n-                case BUBBLE:\n-                    replaceKeyByBubbleRightmostFromSubtree( cursor, structurePropagation, pos,\n-                            stableGeneration, unstableGeneration );\n-                    break;\n-                default:\n-                    throw new IllegalArgumentException( \"Unknown KeyReplaceStrategy \" +\n-                            structurePropagation.keyReplaceStrategy );\n-                }\n-            }\n+          case REPLACE:\n+            overwriteKeyInternal(cursor, structurePropagation, structurePropagation.rightKey, pos,\n+                stableGeneration, unstableGeneration);\n+            break;\n+          case BUBBLE:\n+            replaceKeyByBubbleRightmostFromSubtree(cursor, structurePropagation, pos,\n+                stableGeneration, unstableGeneration);\n+            break;\n+          default:\n+            throw new IllegalArgumentException(\"Unknown KeyReplaceStrategy \" +\n+                structurePropagation.keyReplaceStrategy);\n         }\n+      }\n     }\n-\n-    private void overwriteKeyInternal( PageCursor cursor, StructurePropagation<KEY> structurePropagation, KEY newKey, int pos,\n-            long stableGeneration, long unstableGeneration ) throws IOException\n+  }\n+\n+  private void overwriteKeyInternal(PageCursor cursor, StructurePropagation<KEY> structurePropagation, KEY newKey, int pos,\n+                                    long stableGeneration, long unstableGeneration) throws IOException\n+  {\n+    createSuccessorIfNeeded(cursor, structurePropagation, UPDATE_MID_CHILD,\n+        stableGeneration, unstableGeneration);\n+    int keyCount = TreeNode.keyCount(cursor);\n+    boolean couldOverwrite = bTreeNode.setKeyAtInternal(cursor, newKey, pos);\n+    if (!couldOverwrite)\n     {\n-        createSuccessorIfNeeded( cursor, structurePropagation, UPDATE_MID_CHILD,\n-                stableGeneration, unstableGeneration );\n-        int keyCount = TreeNode.keyCount( cursor );\n-        boolean couldOverwrite = bTreeNode.setKeyAtInternal( cursor, newKey, pos );\n-        if ( !couldOverwrite )\n-        {\n-            // Remove key and right child\n-            long rightChild = bTreeNode.childAt( cursor, pos + 1, stableGeneration, unstableGeneration );\n-            bTreeNode.removeKeyAndRightChildAt( cursor, pos, keyCount );\n-            TreeNode.setKeyCount( cursor, keyCount - 1 );\n+      // Remove key and right child\n+      long rightChild = bTreeNode.childAt(cursor, pos + 1, stableGeneration, unstableGeneration);\n+      bTreeNode.removeKeyAndRightChildAt(cursor, pos, keyCount);\n+      TreeNode.setKeyCount(cursor, keyCount - 1);\n \n-            doInsertInInternal( cursor, structurePropagation, keyCount - 1, newKey, rightChild, stableGeneration, unstableGeneration );\n-        }\n+      doInsertInInternal(cursor, structurePropagation, keyCount - 1, newKey, rightChild, stableGeneration, unstableGeneration);\n     }\n+  }\n \n-    private void tryShrinkTree( PageCursor cursor, StructurePropagation<KEY> structurePropagation,\n-            long stableGeneration, long unstableGeneration ) throws IOException\n-    {\n-        // New root will be propagated out. If rootKeyCount is 0 we can shrink the tree.\n-        int rootKeyCount = TreeNode.keyCount( cursor );\n+  private void tryShrinkTree(PageCursor cursor, StructurePropagation<KEY> structurePropagation,\n+                             long stableGeneration, long unstableGeneration) throws IOException\n+  {\n+    // New root will be propagated out. If rootKeyCount is 0 we can shrink the tree.\n+    int rootKeyCount = TreeNode.keyCount(cursor);\n \n-        while ( rootKeyCount == 0 && TreeNode.isInternal( cursor ) )\n-        {\n-            long oldRoot = cursor.getCurrentPageId();\n-            long onlyChildOfRoot = bTreeNode.childAt( cursor, 0, stableGeneration, unstableGeneration );\n-            PointerChecking.checkPointer( onlyChildOfRoot, false );\n+    while (rootKeyCount == 0 && TreeNode.isInternal(cursor))\n+    {\n+      long oldRoot = cursor.getCurrentPageId();\n+      long onlyChildOfRoot = bTreeNode.childAt(cursor, 0, stableGeneration, unstableGeneration);\n+      PointerChecking.checkPointer(onlyChildOfRoot, false);\n \n-            structurePropagation.hasMidChildUpdate = true;\n-            structurePropagation.midChild = onlyChildOfRoot;\n+      structurePropagation.hasMidChildUpdate = true;\n+      structurePropagation.midChild = onlyChildOfRoot;\n \n-            idProvider.releaseId( stableGeneration, unstableGeneration, oldRoot );\n-            TreeNode.goTo( cursor, \"child\", onlyChildOfRoot );\n+      idProvider.releaseId(stableGeneration, unstableGeneration, oldRoot);\n+      TreeNode.goTo(cursor, \"child\", onlyChildOfRoot);\n \n-            rootKeyCount = TreeNode.keyCount( cursor );\n-        }\n+      rootKeyCount = TreeNode.keyCount(cursor);\n     }\n-\n-    private void updateMidChild( PageCursor cursor, StructurePropagation<KEY> structurePropagation, int childPos,\n-            long stableGeneration, long unstableGeneration )\n+  }\n+\n+  private void updateMidChild(PageCursor cursor, StructurePropagation<KEY> structurePropagation, int childPos,\n+                              long stableGeneration, long unstableGeneration)\n+  {\n+    structurePropagation.hasMidChildUpdate = false;\n+    bTreeNode.setChildAt(cursor, structurePropagation.midChild, childPos,\n+        stableGeneration, unstableGeneration);\n+  }\n+\n+  private void replaceKeyByBubbleRightmostFromSubtree(PageCursor cursor,\n+                                                      StructurePropagation<KEY> structurePropagation, int subtreePosition,\n+                                                      long stableGeneration, long unstableGeneration) throws IOException\n+  {\n+    long currentPageId = cursor.getCurrentPageId();\n+    long subtree = bTreeNode.childAt(cursor, subtreePosition, stableGeneration, unstableGeneration);\n+    PointerChecking.checkPointer(subtree, false);\n+\n+    TreeNode.goTo(cursor, \"child\", subtree);\n+    boolean foundKeyBelow = bubbleRightmostKeyRecursive(cursor, structurePropagation, currentPageId,\n+        stableGeneration, unstableGeneration);\n+\n+    // Propagate structurePropagation from below\n+    if (structurePropagation.hasMidChildUpdate)\n     {\n-        structurePropagation.hasMidChildUpdate = false;\n-        bTreeNode.setChildAt( cursor, structurePropagation.midChild, childPos,\n-                stableGeneration, unstableGeneration );\n+      updateMidChild(cursor, structurePropagation, subtreePosition, stableGeneration, unstableGeneration);\n     }\n \n-    private void replaceKeyByBubbleRightmostFromSubtree( PageCursor cursor,\n-            StructurePropagation<KEY> structurePropagation, int subtreePosition,\n-            long stableGeneration, long unstableGeneration ) throws IOException\n+    if (foundKeyBelow)\n+    {\n+      // A key has been bubble up to us.\n+      // It's in structurePropagation.bubbleKey and should be inserted in subtreePosition.\n+      overwriteKeyInternal(cursor, structurePropagation, structurePropagation.bubbleKey, subtreePosition,\n+          stableGeneration, unstableGeneration);\n+    } else\n     {\n-        long currentPageId = cursor.getCurrentPageId();\n-        long subtree = bTreeNode.childAt( cursor, subtreePosition, stableGeneration, unstableGeneration );\n-        PointerChecking.checkPointer( subtree, false );\n+      // No key could be found in subtree, it's completely empty and can be removed.\n+      // We shift keys and children in this internal node to the left (potentially creating new version of this\n+      // node).\n+      createSuccessorIfNeeded(cursor, structurePropagation, UPDATE_MID_CHILD,\n+          stableGeneration, unstableGeneration);\n+      int keyCount = TreeNode.keyCount(cursor);\n+      simplyRemoveFromInternal(cursor, keyCount, subtreePosition, true);\n+    }\n+  }\n \n-        TreeNode.goTo( cursor, \"child\", subtree );\n-        boolean foundKeyBelow = bubbleRightmostKeyRecursive( cursor, structurePropagation, currentPageId,\n-                stableGeneration, unstableGeneration );\n+  private boolean bubbleRightmostKeyRecursive(PageCursor cursor, StructurePropagation<KEY> structurePropagation,\n+                                              long previousNode, long stableGeneration, long unstableGeneration) throws IOException\n+  {\n+    try\n+    {\n+      if (TreeNode.isLeaf(cursor))\n+      {\n+        // Base case\n+        return false;\n+      }\n+      // Recursive case\n+      long currentPageId = cursor.getCurrentPageId();\n+      int keyCount = TreeNode.keyCount(cursor);\n+      long rightmostSubtree = bTreeNode.childAt(cursor, keyCount, stableGeneration, unstableGeneration);\n+      PointerChecking.checkPointer(rightmostSubtree, false);\n+\n+      TreeNode.goTo(cursor, \"child\", rightmostSubtree);\n+\n+      boolean foundKeyBelow = bubbleRightmostKeyRecursive(cursor, structurePropagation, currentPageId,\n+          stableGeneration, unstableGeneration);\n+\n+      // Propagate structurePropagation from below\n+      if (structurePropagation.hasMidChildUpdate)\n+      {\n+        updateMidChild(cursor, structurePropagation, keyCount, stableGeneration, unstableGeneration);\n+      }\n+\n+      if (foundKeyBelow)\n+      {\n+        return true;\n+      }\n+\n+      if (keyCount == 0)\n+      {\n+        // This subtree does not contain anything any more\n+        // Repoint sibling and add to freelist and return false\n+        connectLeftAndRightSibling(cursor, stableGeneration, unstableGeneration);\n+        idProvider.releaseId(stableGeneration, unstableGeneration, currentPageId);\n+        return false;\n+      }\n \n-        // Propagate structurePropagation from below\n-        if ( structurePropagation.hasMidChildUpdate )\n-        {\n-            updateMidChild( cursor, structurePropagation, subtreePosition, stableGeneration, unstableGeneration );\n-        }\n+      // Create new version of node, save rightmost key in structurePropagation, remove rightmost key and child\n+      createSuccessorIfNeeded(cursor, structurePropagation, UPDATE_MID_CHILD, stableGeneration, unstableGeneration);\n+      bTreeNode.keyAt(cursor, structurePropagation.bubbleKey, keyCount - 1, INTERNAL);\n+      simplyRemoveFromInternal(cursor, keyCount, keyCount - 1, false);\n \n-        if ( foundKeyBelow )\n-        {\n-            // A key has been bubble up to us.\n-            // It's in structurePropagation.bubbleKey and should be inserted in subtreePosition.\n-            overwriteKeyInternal( cursor, structurePropagation, structurePropagation.bubbleKey, subtreePosition,\n-                    stableGeneration, unstableGeneration );\n-        }\n-        else\n-        {\n-            // No key could be found in subtree, it's completely empty and can be removed.\n-            // We shift keys and children in this internal node to the left (potentially creating new version of this\n-            // node).\n-            createSuccessorIfNeeded( cursor, structurePropagation, UPDATE_MID_CHILD,\n-                    stableGeneration, unstableGeneration);\n-            int keyCount = TreeNode.keyCount( cursor );\n-            simplyRemoveFromInternal( cursor, keyCount, subtreePosition, true );\n-        }\n+      return true;\n+    } finally\n+    {\n+      TreeNode.goTo(cursor, \"back to previous node\", previousNode);\n     }\n+  }\n \n-    private boolean bubbleRightmostKeyRecursive( PageCursor cursor, StructurePropagation<KEY> structurePropagation,\n-            long previousNode, long stableGeneration, long unstableGeneration ) throws IOException\n+  private int simplyRemoveFromInternal(PageCursor cursor, int keyCount, int keyPos, boolean leftChild)\n+  {\n+    // Remove key and child\n+    if (leftChild)\n     {\n-        try\n-        {\n-            if ( TreeNode.isLeaf( cursor ) )\n-            {\n-                // Base case\n-                return false;\n-            }\n-            // Recursive case\n-            long currentPageId = cursor.getCurrentPageId();\n-            int keyCount = TreeNode.keyCount( cursor );\n-            long rightmostSubtree = bTreeNode.childAt( cursor, keyCount, stableGeneration, unstableGeneration );\n-            PointerChecking.checkPointer( rightmostSubtree, false );\n-\n-            TreeNode.goTo( cursor, \"child\", rightmostSubtree );\n-\n-            boolean foundKeyBelow = bubbleRightmostKeyRecursive( cursor, structurePropagation, currentPageId,\n-                    stableGeneration, unstableGeneration );\n-\n-            // Propagate structurePropagation from below\n-            if ( structurePropagation.hasMidChildUpdate )\n-            {\n-                updateMidChild( cursor, structurePropagation, keyCount, stableGeneration, unstableGeneration );\n-            }\n-\n-            if ( foundKeyBelow )\n-            {\n-                return true;\n-            }\n-\n-            if ( keyCount == 0 )\n-            {\n-                // This subtree does not contain anything any more\n-                // Repoint sibling and add to freelist and return false\n-                connectLeftAndRightSibling( cursor, stableGeneration, unstableGeneration );\n-                idProvider.releaseId( stableGeneration, unstableGeneration, currentPageId );\n-                return false;\n-            }\n-\n-            // Create new version of node, save rightmost key in structurePropagation, remove rightmost key and child\n-            createSuccessorIfNeeded( cursor, structurePropagation, UPDATE_MID_CHILD, stableGeneration, unstableGeneration );\n-            bTreeNode.keyAt( cursor, structurePropagation.bubbleKey, keyCount - 1, INTERNAL );\n-            simplyRemoveFromInternal( cursor, keyCount, keyCount - 1, false );\n-\n-            return true;\n-        }\n-        finally\n-        {\n-            TreeNode.goTo( cursor, \"back to previous node\", previousNode );\n-        }\n+      bTreeNode.removeKeyAndLeftChildAt(cursor, keyPos, keyCount);\n+    } else\n+    {\n+      bTreeNode.removeKeyAndRightChildAt(cursor, keyPos, keyCount);\n     }\n \n-    private int simplyRemoveFromInternal( PageCursor cursor, int keyCount, int keyPos, boolean leftChild )\n-    {\n-        // Remove key and child\n-        if ( leftChild )\n-        {\n-            bTreeNode.removeKeyAndLeftChildAt(  cursor, keyPos, keyCount );\n-        }\n-        else\n-        {\n-            bTreeNode.removeKeyAndRightChildAt( cursor, keyPos, keyCount );\n-        }\n+    // Decrease key count\n+    int newKeyCount = keyCount - 1;\n+    TreeNode.setKeyCount(cursor, newKeyCount);\n+    return newKeyCount;\n+  }\n \n-        // Decrease key count\n-        int newKeyCount = keyCount - 1;\n-        TreeNode.setKeyCount( cursor, newKeyCount );\n-        return newKeyCount;\n-    }\n+  private void updateRightmostChildInLeftSibling(PageCursor cursor, long childPointer, long stableGeneration,\n+                                                 long unstableGeneration) throws IOException\n+  {\n+    long leftSibling = TreeNode.leftSibling(cursor, stableGeneration, unstableGeneration);\n+    // Left sibling is not allowed to be NO_NODE here because that means there is a child node with no parent\n+    PointerChecking.checkPointer(leftSibling, false);\n \n-    private void updateRightmostChildInLeftSibling( PageCursor cursor, long childPointer, long stableGeneration,\n-            long unstableGeneration ) throws IOException\n+    try (PageCursor leftSiblingCursor = cursor.openLinkedCursor(leftSibling))\n     {\n-        long leftSibling = TreeNode.leftSibling( cursor, stableGeneration, unstableGeneration );\n-        // Left sibling is not allowed to be NO_NODE here because that means there is a child node with no parent\n-        PointerChecking.checkPointer( leftSibling, false );\n-\n-        try ( PageCursor leftSiblingCursor = cursor.openLinkedCursor( leftSibling ) )\n-        {\n-            TreeNode.goTo( leftSiblingCursor, \"left sibling\", leftSibling );\n-            int keyCount = TreeNode.keyCount( leftSiblingCursor );\n-            bTreeNode.setChildAt( leftSiblingCursor, childPointer, keyCount, stableGeneration, unstableGeneration );\n-        }\n+      TreeNode.goTo(leftSiblingCursor, \"left sibling\", leftSibling);\n+      int keyCount = TreeNode.keyCount(leftSiblingCursor);\n+      bTreeNode.setChildAt(leftSiblingCursor, childPointer, keyCount, stableGeneration, unstableGeneration);\n     }\n+  }\n \n-    private void updateLeftmostChildInRightSibling( PageCursor cursor, long childPointer, long stableGeneration,\n-            long unstableGeneration ) throws IOException\n-    {\n-        long rightSibling = TreeNode.rightSibling( cursor, stableGeneration, unstableGeneration );\n-        // Left sibling is not allowed to be NO_NODE here because that means there is a child node with no parent\n-        PointerChecking.checkPointer( rightSibling, false );\n+  private void updateLeftmostChildInRightSibling(PageCursor cursor, long childPointer, long stableGeneration,\n+                                                 long unstableGeneration) throws IOException\n+  {\n+    long rightSibling = TreeNode.rightSibling(cursor, stableGeneration, unstableGeneration);\n+    // Left sibling is not allowed to be NO_NODE here because that means there is a child node with no parent\n+    PointerChecking.checkPointer(rightSibling, false);\n \n-        try ( PageCursor rightSiblingCursor = cursor.openLinkedCursor( rightSibling ) )\n-        {\n-            TreeNode.goTo( rightSiblingCursor, \"right sibling\", rightSibling );\n-            bTreeNode.setChildAt( rightSiblingCursor, childPointer, 0, stableGeneration, unstableGeneration );\n-        }\n+    try (PageCursor rightSiblingCursor = cursor.openLinkedCursor(rightSibling))\n+    {\n+      TreeNode.goTo(rightSiblingCursor, \"right sibling\", rightSibling);\n+      bTreeNode.setChildAt(rightSiblingCursor, childPointer, 0, stableGeneration, unstableGeneration);\n     }\n-\n-    /**\n-     * Remove given {@code key} and associated value from tree if it exists. The removed value will be stored in\n-     * provided {@code into} which will be returned for convenience.\n-     * <p>\n-     * If the given {@code key} does not exist in tree, return {@code null}.\n-     * <p>\n-     * Leaves cursor at same page as when called. No guarantees on offset.\n-     *\n-     * @param cursor {@link PageCursor} pinned to page where remove is to be done.\n-     * @param structurePropagation {@link StructurePropagation} used to report structure changes between tree levels.\n-     * @param key key to be removed\n-     * @param into {@code VALUE} instance to write removed value to\n-     * @param stableGeneration stable generation, i.e. generations <= this generation are considered stable.\n-     * @param unstableGeneration unstable generation, i.e. generation which is under development right now.\n-     * @return {@code true} if key was removed, otherwise {@code false}.\n-     * @throws IOException on cursor failure\n-     */\n-    private boolean removeFromLeaf( PageCursor cursor, StructurePropagation<KEY> structurePropagation,\n-            KEY key, VALUE into, long stableGeneration, long unstableGeneration ) throws IOException\n+  }\n+\n+  /**\n+   * Remove given {@code key} and associated value from tree if it exists. The removed value will be stored in\n+   * provided {@code into} which will be returned for convenience.\n+   * <p>\n+   * If the given {@code key} does not exist in tree, return {@code null}.\n+   * <p>\n+   * Leaves cursor at same page as when called. No guarantees on offset.\n+   *\n+   * @param cursor               {@link PageCursor} pinned to page where remove is to be done.\n+   * @param structurePropagation {@link StructurePropagation} used to report structure changes between tree levels.\n+   * @param key                  key to be removed\n+   * @param into                 {@code VALUE} instance to write removed value to\n+   * @param stableGeneration     stable generation, i.e. generations <= this generation are considered stable.\n+   * @param unstableGeneration   unstable generation, i.e. generation which is under development right now.\n+   * @return {@code true} if key was removed, otherwise {@code false}.\n+   * @throws IOException on cursor failure\n+   */\n+  private boolean removeFromLeaf(PageCursor cursor, StructurePropagation<KEY> structurePropagation,\n+                                 KEY key, VALUE into, long stableGeneration, long unstableGeneration) throws IOException\n+  {\n+    int keyCount = TreeNode.keyCount(cursor);\n+\n+    int search = search(cursor, LEAF, key, readKey, keyCount);\n+    int pos = positionOf(search);\n+    boolean hit = isHit(search);\n+    if (!hit)\n     {\n-        int keyCount = TreeNode.keyCount( cursor );\n+      return false;\n+    }\n \n-        int search = search( cursor, LEAF, key, readKey, keyCount );\n-        int pos = positionOf( search );\n-        boolean hit = isHit( search );\n-        if ( !hit )\n-        {\n-            return false;\n-        }\n+    createSuccessorIfNeeded(cursor, structurePropagation, UPDATE_MID_CHILD,\n+        stableGeneration, unstableGeneration);\n+    keyCount = simplyRemoveFromLeaf(cursor, into, keyCount, pos);\n \n-        createSuccessorIfNeeded( cursor, structurePropagation, UPDATE_MID_CHILD,\n-                stableGeneration, unstableGeneration );\n-        keyCount = simplyRemoveFromLeaf( cursor, into, keyCount, pos );\n+    if (bTreeNode.leafUnderflow(cursor, keyCount))\n+    {\n+      // Underflow\n+      underflowInLeaf(cursor, structurePropagation, keyCount, stableGeneration, unstableGeneration);\n+    }\n \n-        if ( bTreeNode.leafUnderflow( cursor, keyCount ) )\n-        {\n-            // Underflow\n-            underflowInLeaf( cursor, structurePropagation, keyCount, stableGeneration, unstableGeneration );\n-        }\n+    return true;\n+  }\n \n-        return true;\n-    }\n+  private void underflowInLeaf(PageCursor cursor, StructurePropagation<KEY> structurePropagation, int keyCount,\n+                               long stableGeneration, long unstableGeneration) throws IOException\n+  {\n+    long leftSibling = TreeNode.leftSibling(cursor, stableGeneration, unstableGeneration);\n+    PointerChecking.checkPointer(leftSibling, true);\n+    long rightSibling = TreeNode.rightSibling(cursor, stableGeneration, unstableGeneration);\n+    PointerChecking.checkPointer(rightSibling, true);\n \n-    private void underflowInLeaf( PageCursor cursor, StructurePropagation<KEY> structurePropagation, int keyCount,\n-            long stableGeneration, long unstableGeneration ) throws IOException\n+    if (TreeNode.isNode(leftSibling))\n     {\n-        long leftSibling = TreeNode.leftSibling( cursor, stableGeneration, unstableGeneration );\n-        PointerChecking.checkPointer( leftSibling, true );\n-        long rightSibling = TreeNode.rightSibling( cursor, stableGeneration, unstableGeneration );\n-        PointerChecking.checkPointer( rightSibling, true );\n-\n-        if ( TreeNode.isNode( leftSibling ) )\n+      // Go to left sibling and read stuff\n+      try (PageCursor leftSiblingCursor = cursor.openLinkedCursor(GenerationSafePointerPair.pointer(leftSibling)))\n+      {\n+        leftSiblingCursor.next();\n+        int leftSiblingKeyCount = TreeNode.keyCount(leftSiblingCursor);\n+\n+        int keysToRebalance = bTreeNode.canRebalanceLeaves(leftSiblingCursor, leftSiblingKeyCount, cursor, keyCount);\n+        if (keysToRebalance > 0)\n         {\n-            // Go to left sibling and read stuff\n-            try ( PageCursor leftSiblingCursor = cursor.openLinkedCursor( GenerationSafePointerPair.pointer( leftSibling ) ) )\n-            {\n-                leftSiblingCursor.next();\n-                int leftSiblingKeyCount = TreeNode.keyCount( leftSiblingCursor );\n-\n-                int keysToRebalance = bTreeNode.canRebalanceLeaves( leftSiblingCursor, leftSiblingKeyCount, cursor, keyCount );\n-                if ( keysToRebalance > 0 )\n-                {\n-                    createSuccessorIfNeeded( leftSiblingCursor, structurePropagation, UPDATE_LEFT_CHILD,\n-                            stableGeneration, unstableGeneration );\n-                    rebalanceLeaf( leftSiblingCursor, leftSiblingKeyCount, cursor, keyCount, keysToRebalance , structurePropagation );\n-                }\n-                else if ( keysToRebalance == -1 )\n-                {\n-                    // No need to create new unstable version of left sibling.\n-                    // Parent pointer will be updated later.\n-                    mergeFromLeftSiblingLeaf( cursor, leftSiblingCursor, structurePropagation, keyCount,\n-                            leftSiblingKeyCount, stableGeneration, unstableGeneration );\n-                }\n-            }\n-        }\n-        else if ( TreeNode.isNode( rightSibling ) )\n+          createSuccessorIfNeeded(leftSiblingCursor, structurePropagation, UPDATE_LEFT_CHILD,\n+              stableGeneration, unstableGeneration);\n+          rebalanceLeaf(leftSiblingCursor, leftSiblingKeyCount, cursor, keyCount, keysToRebalance, structurePropagation);\n+        } else if (keysToRebalance == -1)\n         {\n-            try ( PageCursor rightSiblingCursor = cursor.openLinkedCursor(\n-                    GenerationSafePointerPair.pointer( rightSibling ) ) )\n-            {\n-                rightSiblingCursor.next();\n-                int rightSiblingKeyCount = TreeNode.keyCount( rightSiblingCursor );\n-\n-                if ( bTreeNode.canMergeLeaves( cursor, keyCount, rightSiblingCursor, rightSiblingKeyCount ) )\n-                {\n-                    createSuccessorIfNeeded( rightSiblingCursor, structurePropagation, UPDATE_RIGHT_CHILD,\n-                            stableGeneration, unstableGeneration );\n-                    mergeToRightSiblingLeaf( cursor, rightSiblingCursor, structurePropagation, keyCount,\n-                            rightSiblingKeyCount, stableGeneration, unstableGeneration);\n-                }\n-            }\n+          // No need to create new unstable version of left sibling.\n+          // Parent pointer will be updated later.\n+          mergeFromLeftSiblingLeaf(cursor, leftSiblingCursor, structurePropagation, keyCount,\n+              leftSiblingKeyCount, stableGeneration, unstableGeneration);\n         }\n-    }\n-\n-    private void connectLeftAndRightSibling( PageCursor cursor, long stableGeneration, long unstableGeneration )\n-            throws IOException\n+      }\n+    } else if (TreeNode.isNode(rightSibling))\n     {\n-        long currentId = cursor.getCurrentPageId();\n-        long leftSibling = TreeNode.leftSibling( cursor, stableGeneration, unstableGeneration );\n-        PointerChecking.checkPointer( leftSibling, true );\n-        long rightSibling = TreeNode. rightSibling( cursor, stableGeneration, unstableGeneration );\n-        PointerChecking.checkPointer( rightSibling, true );\n-        if ( TreeNode.isNode( leftSibling ) )\n-        {\n-            TreeNode.goTo( cursor, \"left sibling\", leftSibling );\n-            TreeNode.setRightSibling( cursor, rightSibling, stableGeneration, unstableGeneration );\n-        }\n-        if ( TreeNode.isNode( rightSibling ) )\n+      try (PageCursor rightSiblingCursor = cursor.openLinkedCursor(\n+          GenerationSafePointerPair.pointer(rightSibling)))\n+      {\n+        rightSiblingCursor.next();\n+        int rightSiblingKeyCount = TreeNode.keyCount(rightSiblingCursor);\n+\n+        if (bTreeNode.canMergeLeaves(cursor, keyCount, rightSiblingCursor, rightSiblingKeyCount))\n         {\n-            TreeNode.goTo( cursor, \"right sibling\", rightSibling );\n-            TreeNode.setLeftSibling( cursor, leftSibling, stableGeneration, unstableGeneration );\n+          createSuccessorIfNeeded(rightSiblingCursor, structurePropagation, UPDATE_RIGHT_CHILD,\n+              stableGeneration, unstableGeneration);\n+          mergeToRightSiblingLeaf(cursor, rightSiblingCursor, structurePropagation, keyCount,\n+              rightSiblingKeyCount, stableGeneration, unstableGeneration);\n         }\n-\n-        TreeNode.goTo( cursor, \"back to origin after repointing siblings\", currentId );\n+      }\n     }\n-\n-    private void mergeToRightSiblingLeaf( PageCursor cursor, PageCursor rightSiblingCursor,\n-            StructurePropagation<KEY> structurePropagation, int keyCount, int rightSiblingKeyCount,\n-            long stableGeneration, long unstableGeneration ) throws IOException\n+  }\n+\n+  private void connectLeftAndRightSibling(PageCursor cursor, long stableGeneration, long unstableGeneration)\n+      throws IOException\n+  {\n+    long currentId = cursor.getCurrentPageId();\n+    long leftSibling = TreeNode.leftSibling(cursor, stableGeneration, unstableGeneration);\n+    PointerChecking.checkPointer(leftSibling, true);\n+    long rightSibling = TreeNode.rightSibling(cursor, stableGeneration, unstableGeneration);\n+    PointerChecking.checkPointer(rightSibling, true);\n+    if (TreeNode.isNode(leftSibling))\n     {\n-        // Read the right-most key from the right sibling to use when comparing whether or not\n-        // a common parent covers the keys in right sibling too\n-        bTreeNode.keyAt( rightSiblingCursor, structurePropagation.rightKey, rightSiblingKeyCount - 1, LEAF );\n-        merge( cursor, keyCount, rightSiblingCursor, rightSiblingKeyCount, stableGeneration, unstableGeneration );\n-\n-        // Propagate change\n-        // mid child has been merged into right child\n-        // right key was separator key\n-        structurePropagation.hasMidChildUpdate = true;\n-        structurePropagation.midChild = rightSiblingCursor.getCurrentPageId();\n-        structurePropagation.hasRightKeyReplace = true;\n-        structurePropagation.keyReplaceStrategy = BUBBLE;\n+      TreeNode.goTo(cursor, \"left sibling\", leftSibling);\n+      TreeNode.setRightSibling(cursor, rightSibling, stableGeneration, unstableGeneration);\n     }\n-\n-    private void mergeFromLeftSiblingLeaf( PageCursor cursor, PageCursor leftSiblingCursor,\n-            StructurePropagation<KEY> structurePropagation, int keyCount, int leftSiblingKeyCount,\n-            long stableGeneration, long unstableGeneration ) throws IOException\n+    if (TreeNode.isNode(rightSibling))\n     {\n-        // Read the left-most key from the left sibling to use when comparing whether or not\n-        // a common parent covers the keys in left sibling too\n-        bTreeNode.keyAt( leftSiblingCursor, structurePropagation.leftKey, 0, LEAF );\n-        merge( leftSiblingCursor, leftSiblingKeyCount, cursor, keyCount, stableGeneration, unstableGeneration );\n-\n-        // Propagate change\n-        // left child has been merged into mid child\n-        // left key was separator key\n-        structurePropagation.hasLeftChildUpdate = true;\n-        structurePropagation.leftChild = cursor.getCurrentPageId();\n-        structurePropagation.hasLeftKeyReplace = true;\n-        structurePropagation.keyReplaceStrategy = BUBBLE;\n+      TreeNode.goTo(cursor, \"right sibling\", rightSibling);\n+      TreeNode.setLeftSibling(cursor, leftSibling, stableGeneration, unstableGeneration);\n     }\n \n-    private void merge( PageCursor leftSiblingCursor, int leftSiblingKeyCount, PageCursor rightSiblingCursor,\n-            int rightSiblingKeyCount, long stableGeneration, long unstableGeneration ) throws IOException\n+    TreeNode.goTo(cursor, \"back to origin after repointing siblings\", currentId);\n+  }\n+\n+  private void mergeToRightSiblingLeaf(PageCursor cursor, PageCursor rightSiblingCursor,\n+                                       StructurePropagation<KEY> structurePropagation, int keyCount, int rightSiblingKeyCount,\n+                                       long stableGeneration, long unstableGeneration) throws IOException\n+  {\n+    // Read the right-most key from the right sibling to use when comparing whether or not\n+    // a common parent covers the keys in right sibling too\n+    bTreeNode.keyAt(rightSiblingCursor, structurePropagation.rightKey, rightSiblingKeyCount - 1, LEAF);\n+    merge(cursor, keyCount, rightSiblingCursor, rightSiblingKeyCount, stableGeneration, unstableGeneration);\n+\n+    // Propagate change\n+    // mid child has been merged into right child\n+    // right key was separator key\n+    structurePropagation.hasMidChildUpdate = true;\n+    structurePropagation.midChild = rightSiblingCursor.getCurrentPageId();\n+    structurePropagation.hasRightKeyReplace = true;\n+    structurePropagation.keyReplaceStrategy = BUBBLE;\n+  }\n+\n+  private void mergeFromLeftSiblingLeaf(PageCursor cursor, PageCursor leftSiblingCursor,\n+                                        StructurePropagation<KEY> structurePropagation, int keyCount, int leftSiblingKeyCount,\n+                                        long stableGeneration, long unstableGeneration) throws IOException\n+  {\n+    // Read the left-most key from the left sibling to use when comparing whether or not\n+    // a common parent covers the keys in left sibling too\n+    bTreeNode.keyAt(leftSiblingCursor, structurePropagation.leftKey, 0, LEAF);\n+    merge(leftSiblingCursor, leftSiblingKeyCount, cursor, keyCount, stableGeneration, unstableGeneration);\n+\n+    // Propagate change\n+    // left child has been merged into mid child\n+    // left key was separator key\n+    structurePropagation.hasLeftChildUpdate = true;\n+    structurePropagation.leftChild = cursor.getCurrentPageId();\n+    structurePropagation.hasLeftKeyReplace = true;\n+    structurePropagation.keyReplaceStrategy = BUBBLE;\n+  }\n+\n+  private void merge(PageCursor leftSiblingCursor, int leftSiblingKeyCount, PageCursor rightSiblingCursor,\n+                     int rightSiblingKeyCount, long stableGeneration, long unstableGeneration) throws IOException\n+  {\n+    bTreeNode.copyKeyValuesFromLeftToRight(leftSiblingCursor, leftSiblingKeyCount, rightSiblingCursor, rightSiblingKeyCount);\n+\n+    // Update successor of left sibling to be right sibling\n+    TreeNode.setSuccessor(leftSiblingCursor, rightSiblingCursor.getCurrentPageId(),\n+        stableGeneration, unstableGeneration);\n+\n+    // Add left sibling to free list\n+    connectLeftAndRightSibling(leftSiblingCursor, stableGeneration, unstableGeneration);\n+    idProvider.releaseId(stableGeneration, unstableGeneration, leftSiblingCursor.getCurrentPageId());\n+  }\n+\n+  private void rebalanceLeaf(PageCursor leftCursor, int leftKeyCount, PageCursor rightCursor, int rightKeyCount,\n+                             int numberOfKeysToMove, StructurePropagation<KEY> structurePropagation)\n+  {\n+    bTreeNode.moveKeyValuesFromLeftToRight(leftCursor, leftKeyCount, rightCursor, rightKeyCount, leftKeyCount - numberOfKeysToMove);\n+\n+    // Propagate change\n+    structurePropagation.hasLeftKeyReplace = true;\n+    structurePropagation.keyReplaceStrategy = REPLACE;\n+    bTreeNode.keyAt(rightCursor, structurePropagation.leftKey, 0, LEAF);\n+  }\n+\n+  /**\n+   * Remove key and value on given position and decrement key count. Deleted value is stored in {@code into}.\n+   * Key count after remove is returned.\n+   *\n+   * @param cursor   Cursor pinned to node in which to remove from,\n+   * @param into     VALUE in which to store removed value\n+   * @param keyCount Key count of node before remove\n+   * @param pos      Position to remove from\n+   * @return keyCount after remove\n+   */\n+  private int simplyRemoveFromLeaf(PageCursor cursor, VALUE into, int keyCount, int pos)\n+  {\n+    // Save value to remove\n+    bTreeNode.valueAt(cursor, into, pos);\n+    // Remove key/value\n+    bTreeNode.removeKeyValueAt(cursor, pos, keyCount);\n+\n+    // Decrease key count\n+    int newKeyCount = keyCount - 1;\n+    TreeNode.setKeyCount(cursor, newKeyCount);\n+    return newKeyCount;\n+  }\n+\n+  /**\n+   * Create a new node and copy content from current node (where {@code cursor} sits) if current node is not already\n+   * of {@code unstableGeneration}.\n+   * <p>\n+   * Neighboring nodes' sibling pointers will be updated to point to new node.\n+   * <p>\n+   * Current node will be updated with successor pointer to new node.\n+   * <p>\n+   * {@code structurePropagation} will be updated with information about this new node so that it can report to\n+   * level above.\n+   *\n+   * @param cursor               {@link PageCursor} pinned to page containing node to potentially create a new version of\n+   * @param structurePropagation {@link StructurePropagation} used to report structure changes between tree levels.\n+   * @param structureUpdate      {@link StructurePropagation.StructureUpdate} define how to update structurePropagation\n+   *                             if new unstable version is created\n+   * @param stableGeneration     stable generation, i.e. generations <= this generation are considered stable.\n+   * @param unstableGeneration   unstable generation, i.e. generation which is under development right now.\n+   * @throws IOException on cursor failure\n+   */\n+  private void createSuccessorIfNeeded(PageCursor cursor, StructurePropagation<KEY> structurePropagation,\n+                                       StructurePropagation.StructureUpdate structureUpdate, long stableGeneration, long unstableGeneration)\n+      throws IOException\n+  {\n+    long oldId = cursor.getCurrentPageId();\n+    long nodeGeneration = TreeNode.generation(cursor);\n+    if (nodeGeneration == unstableGeneration)\n     {\n-        bTreeNode.copyKeyValuesFromLeftToRight( leftSiblingCursor, leftSiblingKeyCount, rightSiblingCursor, rightSiblingKeyCount );\n-\n-        // Update successor of left sibling to be right sibling\n-        TreeNode.setSuccessor( leftSiblingCursor, rightSiblingCursor.getCurrentPageId(),\n-                stableGeneration, unstableGeneration );\n-\n-        // Add left sibling to free list\n-        connectLeftAndRightSibling( leftSiblingCursor, stableGeneration, unstableGeneration );\n-        idProvider.releaseId( stableGeneration, unstableGeneration, leftSiblingCursor.getCurrentPageId() );\n+      // Don't copy\n+      return;\n     }\n \n-    private void rebalanceLeaf( PageCursor leftCursor, int leftKeyCount, PageCursor rightCursor, int rightKeyCount,\n-            int numberOfKeysToMove, StructurePropagation<KEY> structurePropagation )\n+    // Do copy\n+    long successorId = idProvider.acquireNewId(stableGeneration, unstableGeneration);\n+    try (PageCursor successorCursor = cursor.openLinkedCursor(successorId))\n     {\n-        bTreeNode.moveKeyValuesFromLeftToRight( leftCursor, leftKeyCount, rightCursor, rightKeyCount, leftKeyCount - numberOfKeysToMove );\n-\n-        // Propagate change\n-        structurePropagation.hasLeftKeyReplace = true;\n-        structurePropagation.keyReplaceStrategy = REPLACE;\n-        bTreeNode.keyAt( rightCursor, structurePropagation.leftKey, 0, LEAF );\n+      TreeNode.goTo(successorCursor, \"successor\", successorId);\n+      cursor.copyTo(0, successorCursor, 0, cursor.getCurrentPageSize());\n+      TreeNode.setGeneration(successorCursor, unstableGeneration);\n+      TreeNode.setSuccessor(successorCursor, TreeNode.NO_NODE_FLAG, stableGeneration, unstableGeneration);\n     }\n \n-    /**\n-     * Remove key and value on given position and decrement key count. Deleted value is stored in {@code into}.\n-     * Key count after remove is returned.\n-     *\n-     * @param cursor Cursor pinned to node in which to remove from,\n-     * @param into VALUE in which to store removed value\n-     * @param keyCount Key count of node before remove\n-     * @param pos Position to remove from\n-     * @return keyCount after remove\n-     */\n-    private int simplyRemoveFromLeaf( PageCursor cursor, VALUE into, int keyCount, int pos )\n+    // Insert successor pointer in old stable version\n+    //   (stableNode)\n+    //        |\n+    //     [successor]\n+    //        |\n+    //        v\n+    // (newUnstableNode)\n+    TreeNode.setSuccessor(cursor, successorId, stableGeneration, unstableGeneration);\n+\n+    // Redirect sibling pointers\n+    //               ---------[leftSibling]---------(stableNode)----------[rightSibling]---------\n+    //              |                                     |                                      |\n+    //              |                                  [successor]                                    |\n+    //              |                                     |                                      |\n+    //              v                                     v                                      v\n+    // (leftSiblingOfStableNode) -[rightSibling]-> (newUnstableNode) <-[leftSibling]- (rightSiblingOfStableNode)\n+    long leftSibling = TreeNode.leftSibling(cursor, stableGeneration, unstableGeneration);\n+    PointerChecking.checkPointer(leftSibling, true);\n+    long rightSibling = TreeNode.rightSibling(cursor, stableGeneration, unstableGeneration);\n+    PointerChecking.checkPointer(rightSibling, true);\n+    if (TreeNode.isNode(leftSibling))\n     {\n-        // Save value to remove\n-        bTreeNode.valueAt( cursor, into, pos );\n-        // Remove key/value\n-        bTreeNode.removeKeyValueAt( cursor, pos, keyCount );\n-\n-        // Decrease key count\n-        int newKeyCount = keyCount - 1;\n-        TreeNode.setKeyCount( cursor, newKeyCount );\n-        return newKeyCount;\n+      TreeNode.goTo(cursor, \"left sibling in split\", leftSibling);\n+      TreeNode.setRightSibling(cursor, successorId, stableGeneration, unstableGeneration);\n     }\n-\n-    /**\n-     * Create a new node and copy content from current node (where {@code cursor} sits) if current node is not already\n-     * of {@code unstableGeneration}.\n-     * <p>\n-     * Neighboring nodes' sibling pointers will be updated to point to new node.\n-     * <p>\n-     * Current node will be updated with successor pointer to new node.\n-     * <p>\n-     * {@code structurePropagation} will be updated with information about this new node so that it can report to\n-     * level above.\n-     *\n-     * @param cursor {@link PageCursor} pinned to page containing node to potentially create a new version of\n-     * @param structurePropagation {@link StructurePropagation} used to report structure changes between tree levels.\n-     * @param structureUpdate {@link StructurePropagation.StructureUpdate} define how to update structurePropagation\n-     * if new unstable version is created\n-     * @param stableGeneration stable generation, i.e. generations <= this generation are considered stable.\n-     * @param unstableGeneration unstable generation, i.e. generation which is under development right now.\n-     * @throws IOException on cursor failure\n-     */\n-    private void createSuccessorIfNeeded( PageCursor cursor, StructurePropagation<KEY> structurePropagation,\n-            StructurePropagation.StructureUpdate structureUpdate, long stableGeneration, long unstableGeneration )\n-            throws IOException\n+    if (TreeNode.isNode(rightSibling))\n     {\n-        long oldId = cursor.getCurrentPageId();\n-        long nodeGeneration = TreeNode.generation( cursor );\n-        if ( nodeGeneration == unstableGeneration )\n-        {\n-            // Don't copy\n-            return;\n-        }\n-\n-        // Do copy\n-        long successorId = idProvider.acquireNewId( stableGeneration, unstableGeneration );\n-        try ( PageCursor successorCursor = cursor.openLinkedCursor( successorId ) )\n-        {\n-            TreeNode.goTo( successorCursor, \"successor\", successorId );\n-            cursor.copyTo( 0, successorCursor, 0, cursor.getCurrentPageSize() );\n-            TreeNode.setGeneration( successorCursor, unstableGeneration );\n-            TreeNode.setSuccessor( successorCursor, TreeNode.NO_NODE_FLAG, stableGeneration, unstableGeneration );\n-        }\n-\n-        // Insert successor pointer in old stable version\n-        //   (stableNode)\n-        //        |\n-        //     [successor]\n-        //        |\n-        //        v\n-        // (newUnstableNode)\n-        TreeNode.setSuccessor( cursor, successorId, stableGeneration, unstableGeneration );\n-\n-        // Redirect sibling pointers\n-        //               ---------[leftSibling]---------(stableNode)----------[rightSibling]---------\n-        //              |                                     |                                      |\n-        //              |                                  [successor]                                    |\n-        //              |                                     |                                      |\n-        //              v                                     v                                      v\n-        // (leftSiblingOfStableNode) -[rightSibling]-> (newUnstableNode) <-[leftSibling]- (rightSiblingOfStableNode)\n-        long leftSibling = TreeNode.leftSibling( cursor, stableGeneration, unstableGeneration );\n-        PointerChecking.checkPointer( leftSibling, true );\n-        long rightSibling = TreeNode.rightSibling( cursor, stableGeneration, unstableGeneration );\n-        PointerChecking.checkPointer( rightSibling, true );\n-        if ( TreeNode.isNode( leftSibling ) )\n-        {\n-            TreeNode.goTo( cursor, \"left sibling in split\", leftSibling );\n-            TreeNode.setRightSibling( cursor, successorId, stableGeneration, unstableGeneration );\n-        }\n-        if ( TreeNode.isNode( rightSibling ) )\n-        {\n-            TreeNode.goTo( cursor, \"right sibling in split\", rightSibling );\n-            TreeNode.setLeftSibling( cursor, successorId, stableGeneration, unstableGeneration );\n-        }\n+      TreeNode.goTo(cursor, \"right sibling in split\", rightSibling);\n+      TreeNode.setLeftSibling(cursor, successorId, stableGeneration, unstableGeneration);\n+    }\n \n-        // Leave cursor at new tree node\n-        TreeNode.goTo( cursor, \"successor\", successorId );\n+    // Leave cursor at new tree node\n+    TreeNode.goTo(cursor, \"successor\", successorId);\n \n-        // Propagate structure change\n-        structureUpdate.update( structurePropagation, successorId );\n+    // Propagate structure change\n+    structureUpdate.update(structurePropagation, successorId);\n \n-        idProvider.releaseId( stableGeneration, unstableGeneration, oldId );\n-    }\n+    idProvider.releaseId(stableGeneration, unstableGeneration, oldId);\n+  }\n }\n",
            "diff_size": 1761
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "1",
                    "severity": "error",
                    "message": "Missing, wrong or duplicated license header",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                },
                {
                    "line": "170",
                    "column": "19",
                    "severity": "error",
                    "message": "'>' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                },
                {
                    "line": "314",
                    "severity": "error",
                    "message": "Line is longer than 160 characters (found 171).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "347",
                    "severity": "error",
                    "message": "Line is longer than 160 characters (found 209).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "376",
                    "severity": "error",
                    "message": "Line is longer than 160 characters (found 168).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "494",
                    "severity": "error",
                    "message": "Line is longer than 160 characters (found 223).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "510",
                    "severity": "error",
                    "message": "Line is longer than 160 characters (found 248).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "536",
                    "severity": "error",
                    "message": "Line is longer than 160 characters (found 215).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "707",
                    "column": "56",
                    "severity": "error",
                    "message": "'||' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                },
                {
                    "line": "707",
                    "column": "56",
                    "severity": "error",
                    "message": "'||' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                },
                {
                    "line": "762",
                    "severity": "error",
                    "message": "Line is longer than 160 characters (found 196).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1093",
                    "severity": "error",
                    "message": "Line is longer than 160 characters (found 179).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1110",
                    "severity": "error",
                    "message": "Line is longer than 160 characters (found 178).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1127",
                    "severity": "error",
                    "message": "Line is longer than 160 characters (found 203).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1139",
                    "severity": "error",
                    "message": "Line is longer than 160 characters (found 188).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/errored/1/1303/InternalTreeLogic.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/naturalize/1303/InternalTreeLogic.java\nindex 319a4d63a1c..8565f28dbff 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/errored/1/1303/InternalTreeLogic.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/naturalize/1303/InternalTreeLogic.java\n@@ -167,7 +167,7 @@ class InternalTreeLogic<KEY,VALUE>\n \n     private void ensureStackCapacity( int depth )\n     {\n-        if ( depth > levels.length )\n+        if ( depth> levels.length )\n         {\n             int oldStackLength = levels.length;\n             levels = Arrays.copyOf( levels, depth );\n@@ -243,15 +243,15 @@ class InternalTreeLogic<KEY,VALUE>\n      * @param unstableGeneration unstable generation.\n      * @throws IOException on {@link PageCursor} error.\n      */\n-    private void moveToCorrectLeaf( PageCursor cursor, KEY key, long stableGeneration, long unstableGeneration )\n-            throws IOException\n-    {\n+    private void moveToCorrectLeaf( PageCursor cursor, KEY key, long stableGeneration, long unstableGeneration ) throws IOException\n+{\n         int previousLevel = currentLevel;\n         while ( !levels[currentLevel].covers( key ) )\n         {\n             currentLevel--;\n         }\n-        if ( currentLevel != previousLevel )\n+\n+if ( currentLevel != previousLevel )\n         {\n             TreeNode.goTo( cursor, \"parent\", levels[currentLevel].treeNodeId );\n         }\n@@ -276,7 +276,7 @@ class InternalTreeLogic<KEY,VALUE>\n             level.childPos = childPos;\n             level.lowerIsOpenEnded = childPos == 0 &&\n                     !TreeNode.isNode( TreeNode.leftSibling( cursor, stableGeneration, unstableGeneration ) );\n-            if ( !level.lowerIsOpenEnded )\n+if ( !level.lowerIsOpenEnded )\n             {\n                 if ( childPos == 0 )\n                 {\n@@ -290,7 +290,7 @@ class InternalTreeLogic<KEY,VALUE>\n             }\n             level.upperIsOpenEnded = childPos >= keyCount &&\n                     !TreeNode.isNode( TreeNode.rightSibling( cursor, stableGeneration, unstableGeneration ) );\n-            if ( !level.upperIsOpenEnded )\n+if ( !level.upperIsOpenEnded )\n             {\n                 if ( childPos == keyCount )\n                 {\n@@ -305,15 +305,13 @@ class InternalTreeLogic<KEY,VALUE>\n \n             long childId = bTreeNode.childAt( cursor, childPos, stableGeneration, unstableGeneration );\n             PointerChecking.checkPointer( childId, false );\n-\n-            TreeNode.goTo( cursor, \"child\", childId );\n+TreeNode.goTo( cursor, \"child\", childId );\n             level.treeNodeId = cursor.getCurrentPageId();\n \n             assert assertNoSuccessor( cursor, stableGeneration, unstableGeneration );\n         }\n \n-        assert TreeNode.isLeaf( cursor ) : \"Ended up on a tree node which isn't a leaf after moving cursor towards \" +\n-                key + \", cursor is at \" + cursor.getCurrentPageId();\n+        assert TreeNode.isLeaf( cursor ) : \"Ended up on a tree node which isn't a leaf after moving cursor towards \" + key + \", cursor is at \" + cursor.getCurrentPageId();\n     }\n \n     /**\n@@ -346,9 +344,8 @@ class InternalTreeLogic<KEY,VALUE>\n      * @param unstableGeneration unstable generation, i.e. generation which is under development right now.\n      * @throws IOException on cursor failure\n      */\n-    void insert( PageCursor cursor, StructurePropagation<KEY> structurePropagation, KEY key, VALUE value,\n-            ValueMerger<KEY,VALUE> valueMerger, long stableGeneration, long unstableGeneration ) throws IOException\n-    {\n+    void insert( PageCursor cursor, StructurePropagation<KEY> structurePropagation, KEY key, VALUE value, ValueMerger<KEY,VALUE> valueMerger, long stableGeneration, long unstableGeneration ) throws IOException\n+{\n         assert cursorIsAtExpectedLocation( cursor );\n         bTreeNode.validateKeyValueSize( key, value );\n         moveToCorrectLeaf( cursor, key, stableGeneration, unstableGeneration );\n@@ -376,10 +373,8 @@ class InternalTreeLogic<KEY,VALUE>\n         assert currentLevel >= 0 : \"Uninitialized tree logic, currentLevel:\" + currentLevel;\n         long currentPageId = cursor.getCurrentPageId();\n         long expectedPageId = levels[currentLevel].treeNodeId;\n-        assert currentPageId == expectedPageId : \"Expected cursor to be at page:\" +\n-                expectedPageId + \" at level:\" + currentLevel + \", but was at page:\" +\n-                currentPageId;\n-        return true;\n+        assert currentPageId == expectedPageId : \"Expected cursor to be at page:\" + expectedPageId + \" at level:\" + currentLevel + \", but was at page:\" + currentPageId;\n+return true;\n     }\n \n     /**\n@@ -396,18 +391,16 @@ class InternalTreeLogic<KEY,VALUE>\n      * @throws IOException on cursor failure\n      */\n     private void insertInInternal( PageCursor cursor, StructurePropagation<KEY> structurePropagation, int keyCount,\n-            KEY primKey, long rightChild, long stableGeneration, long unstableGeneration )\n-            throws IOException\n-    {\n+            KEY primKey, long rightChild, long stableGeneration, long unstableGeneration ) throws IOException\n+{\n         createSuccessorIfNeeded( cursor, structurePropagation, UPDATE_MID_CHILD,\n                 stableGeneration, unstableGeneration );\n-\n-        doInsertInInternal( cursor, structurePropagation, keyCount, primKey, rightChild, stableGeneration, unstableGeneration );\n+doInsertInInternal( cursor, structurePropagation, keyCount, primKey, rightChild, stableGeneration, unstableGeneration );\n     }\n \n     private void doInsertInInternal( PageCursor cursor, StructurePropagation<KEY> structurePropagation, int keyCount, KEY primKey,\n             long rightChild, long stableGeneration, long unstableGeneration ) throws IOException\n-    {\n+{\n         Overflow overflow = bTreeNode.internalOverflow( cursor, keyCount, primKey );\n         if ( overflow == YES )\n         {\n@@ -416,7 +409,7 @@ class InternalTreeLogic<KEY,VALUE>\n             layout.copyKey( primKey, newKeyPlaceHolder );\n             splitInternal( cursor, structurePropagation, newKeyPlaceHolder, rightChild, keyCount,\n                     stableGeneration, unstableGeneration );\n-            return;\n+return;\n         }\n \n         if ( overflow == NO_NEED_DEFRAG )\n@@ -445,7 +438,7 @@ class InternalTreeLogic<KEY,VALUE>\n      */\n     private void splitInternal( PageCursor cursor, StructurePropagation<KEY> structurePropagation, KEY newKey,\n             long newRightChild, int keyCount, long stableGeneration, long unstableGeneration ) throws IOException\n-    {\n+{\n         long current = cursor.getCurrentPageId();\n         long oldRight = TreeNode.rightSibling( cursor, stableGeneration, unstableGeneration );\n         PointerChecking.checkPointer( oldRight, true );\n@@ -498,9 +491,8 @@ class InternalTreeLogic<KEY,VALUE>\n      * @param valueMerger {@link ValueMerger} for deciding what to do with existing keys\n      * @throws IOException on cursor failure\n      */\n-    private void insertInLeaf( PageCursor cursor, StructurePropagation<KEY> structurePropagation, KEY key, VALUE value,\n-            ValueMerger<KEY,VALUE> valueMerger, long stableGeneration, long unstableGeneration ) throws IOException\n-    {\n+    private void insertInLeaf( PageCursor cursor, StructurePropagation<KEY> structurePropagation, KEY key, VALUE value, ValueMerger<KEY,VALUE> valueMerger, long stableGeneration, long unstableGeneration ) throws IOException\n+{\n         int keyCount = TreeNode.keyCount( cursor );\n         int search = search( cursor, LEAF, key, readKey, keyCount );\n         int pos = positionOf( search );\n@@ -515,9 +507,8 @@ class InternalTreeLogic<KEY,VALUE>\n         doInsertInLeaf( cursor, structurePropagation, key, value, pos, keyCount, stableGeneration, unstableGeneration );\n     }\n \n-    private void overwriteValue( PageCursor cursor, StructurePropagation<KEY> structurePropagation, KEY key, VALUE value,\n-            ValueMerger<KEY,VALUE> valueMerger, int pos, int keyCount, long stableGeneration, long unstableGeneration ) throws IOException\n-    {\n+    private void overwriteValue( PageCursor cursor, StructurePropagation<KEY> structurePropagation, KEY key, VALUE value, ValueMerger<KEY,VALUE> valueMerger, int pos, int keyCount, long stableGeneration, long unstableGeneration ) throws IOException\n+{\n         // this key already exists, what shall we do? ask the valueMerger\n         bTreeNode.valueAt( cursor, readValue, pos );\n         VALUE mergedValue = valueMerger.merge( readKey, key, readValue, value );\n@@ -533,9 +524,8 @@ class InternalTreeLogic<KEY,VALUE>\n                 // Delete old value\n                 bTreeNode.removeKeyValueAt( cursor, pos, keyCount );\n                 TreeNode.setKeyCount( cursor, keyCount - 1 );\n-                boolean didSplit =\n-                        doInsertInLeaf( cursor, structurePropagation, key, mergedValue, pos, keyCount - 1, stableGeneration, unstableGeneration );\n-                if ( !didSplit && bTreeNode.leafUnderflow( cursor, keyCount ) )\n+                boolean didSplit = doInsertInLeaf( cursor, structurePropagation, key, mergedValue, pos, keyCount - 1, stableGeneration, unstableGeneration );\n+if ( !didSplit && bTreeNode.leafUnderflow( cursor, keyCount ) )\n                 {\n                     underflowInLeaf( cursor, structurePropagation, keyCount, stableGeneration, unstableGeneration );\n                 }\n@@ -543,9 +533,8 @@ class InternalTreeLogic<KEY,VALUE>\n         }\n     }\n \n-    private boolean doInsertInLeaf( PageCursor cursor, StructurePropagation<KEY> structurePropagation, KEY key, VALUE value, int pos,\n-            int keyCount, long stableGeneration, long unstableGeneration ) throws IOException\n-    {\n+    private boolean doInsertInLeaf( PageCursor cursor, StructurePropagation<KEY> structurePropagation, KEY key, VALUE value, int pos, int keyCount, long stableGeneration, long unstableGeneration ) throws IOException\n+{\n         Overflow overflow = bTreeNode.leafOverflow( cursor, keyCount, key, value );\n         if ( overflow == YES )\n         {\n@@ -577,9 +566,8 @@ class InternalTreeLogic<KEY,VALUE>\n      * @throws IOException on cursor failure\n      */\n     private void splitLeaf( PageCursor cursor, StructurePropagation<KEY> structurePropagation,\n-            KEY newKey, VALUE newValue, int keyCount, long stableGeneration, long unstableGeneration )\n-                    throws IOException\n-    {\n+            KEY newKey, VALUE newValue, int keyCount, long stableGeneration, long unstableGeneration ) throws IOException\n+{\n         // To avoid moving cursor between pages we do all operations on left node first.\n \n         // UPDATE SIBLINGS\n@@ -640,8 +628,7 @@ class InternalTreeLogic<KEY,VALUE>\n \n         // Position where newKey / newValue is to be inserted\n         int pos = positionOf( search( cursor, LEAF, newKey, readKey, keyCount ) );\n-\n-        structurePropagation.hasRightKeyInsert = true;\n+structurePropagation.hasRightKeyInsert = true;\n         structurePropagation.midChild = current;\n         structurePropagation.rightChild = newRight;\n \n@@ -697,18 +684,16 @@ class InternalTreeLogic<KEY,VALUE>\n      */\n     VALUE remove( PageCursor cursor, StructurePropagation<KEY> structurePropagation, KEY key, VALUE into,\n             long stableGeneration, long unstableGeneration ) throws IOException\n-    {\n+{\n         assert cursorIsAtExpectedLocation( cursor );\n         moveToCorrectLeaf( cursor, key, stableGeneration, unstableGeneration );\n-\n-        if ( !removeFromLeaf( cursor, structurePropagation, key, into, stableGeneration, unstableGeneration ) )\n+if ( !removeFromLeaf( cursor, structurePropagation, key, into, stableGeneration, unstableGeneration ) )\n         {\n             return null;\n         }\n \n         handleStructureChanges( cursor, structurePropagation, stableGeneration, unstableGeneration );\n-\n-        if ( currentLevel <= 0 )\n+if ( currentLevel <= 0 )\n         {\n             tryShrinkTree( cursor, structurePropagation, stableGeneration, unstableGeneration );\n         }\n@@ -718,9 +703,8 @@ class InternalTreeLogic<KEY,VALUE>\n \n     private void handleStructureChanges( PageCursor cursor, StructurePropagation<KEY> structurePropagation,\n             long stableGeneration, long unstableGeneration ) throws IOException\n-    {\n-        while ( structurePropagation.hasLeftChildUpdate  ||\n-                structurePropagation.hasMidChildUpdate ||\n+{\n+        while ( structurePropagation.hasLeftChildUpdate||structurePropagation.hasMidChildUpdate ||\n                 structurePropagation.hasRightChildUpdate ||\n                 structurePropagation.hasLeftKeyReplace ||\n                 structurePropagation.hasRightKeyReplace ||\n@@ -745,7 +729,7 @@ class InternalTreeLogic<KEY,VALUE>\n                 {\n                     bTreeNode.setChildAt( cursor, structurePropagation.leftChild, pos - 1,\n                             stableGeneration, unstableGeneration );\n-                }\n+    }\n             }\n \n             if ( structurePropagation.hasMidChildUpdate )\n@@ -766,7 +750,7 @@ class InternalTreeLogic<KEY,VALUE>\n                 {\n                     bTreeNode.setChildAt( cursor, structurePropagation.rightChild, pos + 1,\n                             stableGeneration, unstableGeneration );\n-                }\n+    }\n             }\n \n             // Insert before replace because replace can lead to split and another insert in next level.\n@@ -775,13 +759,10 @@ class InternalTreeLogic<KEY,VALUE>\n             if ( structurePropagation.hasRightKeyInsert )\n             {\n                 structurePropagation.hasRightKeyInsert = false;\n-                insertInInternal( cursor, structurePropagation, TreeNode.keyCount( cursor ),\n-                        structurePropagation.rightKey, structurePropagation.rightChild,\n-                        stableGeneration, unstableGeneration );\n+                insertInInternal( cursor, structurePropagation, TreeNode.keyCount( cursor ), structurePropagation.rightKey, structurePropagation.rightChild, stableGeneration, unstableGeneration );\n             }\n \n-            if ( structurePropagation.hasLeftKeyReplace &&\n-                    levels[currentLevel].covers( structurePropagation.leftKey ) )\n+            if ( structurePropagation.hasLeftKeyReplace && levels[currentLevel].covers( structurePropagation.leftKey ) )\n             {\n                 structurePropagation.hasLeftKeyReplace = false;\n                 switch ( structurePropagation.keyReplaceStrategy )\n@@ -789,19 +770,17 @@ class InternalTreeLogic<KEY,VALUE>\n                 case REPLACE:\n                     overwriteKeyInternal( cursor, structurePropagation, structurePropagation.leftKey, pos - 1,\n                             stableGeneration, unstableGeneration );\n-                    break;\n+break;\n                 case BUBBLE:\n                     replaceKeyByBubbleRightmostFromSubtree( cursor, structurePropagation, pos - 1,\n                             stableGeneration, unstableGeneration );\n-                    break;\n+break;\n                 default:\n-                    throw new IllegalArgumentException( \"Unknown KeyReplaceStrategy \" +\n-                            structurePropagation.keyReplaceStrategy );\n-                }\n+                    throw new IllegalArgumentException( \"Unknown KeyReplaceStrategy \" + structurePropagation.keyReplaceStrategy );\n+    }\n             }\n \n-            if ( structurePropagation.hasRightKeyReplace &&\n-                    levels[currentLevel].covers( structurePropagation.rightKey ) )\n+            if ( structurePropagation.hasRightKeyReplace && levels[currentLevel].covers( structurePropagation.rightKey ) )\n             {\n                 structurePropagation.hasRightKeyReplace = false;\n                 switch ( structurePropagation.keyReplaceStrategy )\n@@ -809,25 +788,24 @@ class InternalTreeLogic<KEY,VALUE>\n                 case REPLACE:\n                     overwriteKeyInternal( cursor, structurePropagation, structurePropagation.rightKey, pos,\n                             stableGeneration, unstableGeneration );\n-                    break;\n+break;\n                 case BUBBLE:\n                     replaceKeyByBubbleRightmostFromSubtree( cursor, structurePropagation, pos,\n                             stableGeneration, unstableGeneration );\n-                    break;\n+break;\n                 default:\n-                    throw new IllegalArgumentException( \"Unknown KeyReplaceStrategy \" +\n-                            structurePropagation.keyReplaceStrategy );\n-                }\n+                    throw new IllegalArgumentException( \"Unknown KeyReplaceStrategy \" + structurePropagation.keyReplaceStrategy );\n+    }\n             }\n         }\n     }\n \n     private void overwriteKeyInternal( PageCursor cursor, StructurePropagation<KEY> structurePropagation, KEY newKey, int pos,\n             long stableGeneration, long unstableGeneration ) throws IOException\n-    {\n+{\n         createSuccessorIfNeeded( cursor, structurePropagation, UPDATE_MID_CHILD,\n                 stableGeneration, unstableGeneration );\n-        int keyCount = TreeNode.keyCount( cursor );\n+    int keyCount = TreeNode.keyCount( cursor );\n         boolean couldOverwrite = bTreeNode.setKeyAtInternal( cursor, newKey, pos );\n         if ( !couldOverwrite )\n         {\n@@ -842,7 +820,7 @@ class InternalTreeLogic<KEY,VALUE>\n \n     private void tryShrinkTree( PageCursor cursor, StructurePropagation<KEY> structurePropagation,\n             long stableGeneration, long unstableGeneration ) throws IOException\n-    {\n+{\n         // New root will be propagated out. If rootKeyCount is 0 we can shrink the tree.\n         int rootKeyCount = TreeNode.keyCount( cursor );\n \n@@ -851,14 +829,12 @@ class InternalTreeLogic<KEY,VALUE>\n             long oldRoot = cursor.getCurrentPageId();\n             long onlyChildOfRoot = bTreeNode.childAt( cursor, 0, stableGeneration, unstableGeneration );\n             PointerChecking.checkPointer( onlyChildOfRoot, false );\n-\n-            structurePropagation.hasMidChildUpdate = true;\n+structurePropagation.hasMidChildUpdate = true;\n             structurePropagation.midChild = onlyChildOfRoot;\n \n             idProvider.releaseId( stableGeneration, unstableGeneration, oldRoot );\n             TreeNode.goTo( cursor, \"child\", onlyChildOfRoot );\n-\n-            rootKeyCount = TreeNode.keyCount( cursor );\n+rootKeyCount = TreeNode.keyCount( cursor );\n         }\n     }\n \n@@ -870,19 +846,16 @@ class InternalTreeLogic<KEY,VALUE>\n                 stableGeneration, unstableGeneration );\n     }\n \n-    private void replaceKeyByBubbleRightmostFromSubtree( PageCursor cursor,\n-            StructurePropagation<KEY> structurePropagation, int subtreePosition,\n+    private void replaceKeyByBubbleRightmostFromSubtree( PageCursor cursor, StructurePropagation<KEY> structurePropagation, int subtreePosition,\n             long stableGeneration, long unstableGeneration ) throws IOException\n-    {\n+{\n         long currentPageId = cursor.getCurrentPageId();\n         long subtree = bTreeNode.childAt( cursor, subtreePosition, stableGeneration, unstableGeneration );\n         PointerChecking.checkPointer( subtree, false );\n-\n-        TreeNode.goTo( cursor, \"child\", subtree );\n+TreeNode.goTo( cursor, \"child\", subtree );\n         boolean foundKeyBelow = bubbleRightmostKeyRecursive( cursor, structurePropagation, currentPageId,\n                 stableGeneration, unstableGeneration );\n-\n-        // Propagate structurePropagation from below\n+    // Propagate structurePropagation from below\n         if ( structurePropagation.hasMidChildUpdate )\n         {\n             updateMidChild( cursor, structurePropagation, subtreePosition, stableGeneration, unstableGeneration );\n@@ -901,15 +874,15 @@ class InternalTreeLogic<KEY,VALUE>\n             // We shift keys and children in this internal node to the left (potentially creating new version of this\n             // node).\n             createSuccessorIfNeeded( cursor, structurePropagation, UPDATE_MID_CHILD,\n-                    stableGeneration, unstableGeneration);\n-            int keyCount = TreeNode.keyCount( cursor );\n+                    stableGeneration, unstableGeneration );\n+    int keyCount = TreeNode.keyCount( cursor );\n             simplyRemoveFromInternal( cursor, keyCount, subtreePosition, true );\n         }\n     }\n \n     private boolean bubbleRightmostKeyRecursive( PageCursor cursor, StructurePropagation<KEY> structurePropagation,\n             long previousNode, long stableGeneration, long unstableGeneration ) throws IOException\n-    {\n+{\n         try\n         {\n             if ( TreeNode.isLeaf( cursor ) )\n@@ -922,13 +895,11 @@ class InternalTreeLogic<KEY,VALUE>\n             int keyCount = TreeNode.keyCount( cursor );\n             long rightmostSubtree = bTreeNode.childAt( cursor, keyCount, stableGeneration, unstableGeneration );\n             PointerChecking.checkPointer( rightmostSubtree, false );\n-\n-            TreeNode.goTo( cursor, \"child\", rightmostSubtree );\n+TreeNode.goTo( cursor, \"child\", rightmostSubtree );\n \n             boolean foundKeyBelow = bubbleRightmostKeyRecursive( cursor, structurePropagation, currentPageId,\n                     stableGeneration, unstableGeneration );\n-\n-            // Propagate structurePropagation from below\n+    // Propagate structurePropagation from below\n             if ( structurePropagation.hasMidChildUpdate )\n             {\n                 updateMidChild( cursor, structurePropagation, keyCount, stableGeneration, unstableGeneration );\n@@ -952,8 +923,7 @@ class InternalTreeLogic<KEY,VALUE>\n             createSuccessorIfNeeded( cursor, structurePropagation, UPDATE_MID_CHILD, stableGeneration, unstableGeneration );\n             bTreeNode.keyAt( cursor, structurePropagation.bubbleKey, keyCount - 1, INTERNAL );\n             simplyRemoveFromInternal( cursor, keyCount, keyCount - 1, false );\n-\n-            return true;\n+return true;\n         }\n         finally\n         {\n@@ -966,7 +936,7 @@ class InternalTreeLogic<KEY,VALUE>\n         // Remove key and child\n         if ( leftChild )\n         {\n-            bTreeNode.removeKeyAndLeftChildAt(  cursor, keyPos, keyCount );\n+            bTreeNode.removeKeyAndLeftChildAt( cursor, keyPos, keyCount );\n         }\n         else\n         {\n@@ -981,7 +951,7 @@ class InternalTreeLogic<KEY,VALUE>\n \n     private void updateRightmostChildInLeftSibling( PageCursor cursor, long childPointer, long stableGeneration,\n             long unstableGeneration ) throws IOException\n-    {\n+{\n         long leftSibling = TreeNode.leftSibling( cursor, stableGeneration, unstableGeneration );\n         // Left sibling is not allowed to be NO_NODE here because that means there is a child node with no parent\n         PointerChecking.checkPointer( leftSibling, false );\n@@ -996,7 +966,7 @@ class InternalTreeLogic<KEY,VALUE>\n \n     private void updateLeftmostChildInRightSibling( PageCursor cursor, long childPointer, long stableGeneration,\n             long unstableGeneration ) throws IOException\n-    {\n+{\n         long rightSibling = TreeNode.rightSibling( cursor, stableGeneration, unstableGeneration );\n         // Left sibling is not allowed to be NO_NODE here because that means there is a child node with no parent\n         PointerChecking.checkPointer( rightSibling, false );\n@@ -1027,7 +997,7 @@ class InternalTreeLogic<KEY,VALUE>\n      */\n     private boolean removeFromLeaf( PageCursor cursor, StructurePropagation<KEY> structurePropagation,\n             KEY key, VALUE into, long stableGeneration, long unstableGeneration ) throws IOException\n-    {\n+{\n         int keyCount = TreeNode.keyCount( cursor );\n \n         int search = search( cursor, LEAF, key, readKey, keyCount );\n@@ -1040,9 +1010,8 @@ class InternalTreeLogic<KEY,VALUE>\n \n         createSuccessorIfNeeded( cursor, structurePropagation, UPDATE_MID_CHILD,\n                 stableGeneration, unstableGeneration );\n-        keyCount = simplyRemoveFromLeaf( cursor, into, keyCount, pos );\n-\n-        if ( bTreeNode.leafUnderflow( cursor, keyCount ) )\n+keyCount = simplyRemoveFromLeaf( cursor, into, keyCount, pos );\n+if ( bTreeNode.leafUnderflow( cursor, keyCount ) )\n         {\n             // Underflow\n             underflowInLeaf( cursor, structurePropagation, keyCount, stableGeneration, unstableGeneration );\n@@ -1053,13 +1022,12 @@ class InternalTreeLogic<KEY,VALUE>\n \n     private void underflowInLeaf( PageCursor cursor, StructurePropagation<KEY> structurePropagation, int keyCount,\n             long stableGeneration, long unstableGeneration ) throws IOException\n-    {\n+{\n         long leftSibling = TreeNode.leftSibling( cursor, stableGeneration, unstableGeneration );\n         PointerChecking.checkPointer( leftSibling, true );\n         long rightSibling = TreeNode.rightSibling( cursor, stableGeneration, unstableGeneration );\n         PointerChecking.checkPointer( rightSibling, true );\n-\n-        if ( TreeNode.isNode( leftSibling ) )\n+if ( TreeNode.isNode( leftSibling ) )\n         {\n             // Go to left sibling and read stuff\n             try ( PageCursor leftSiblingCursor = cursor.openLinkedCursor( GenerationSafePointerPair.pointer( leftSibling ) ) )\n@@ -1072,7 +1040,7 @@ class InternalTreeLogic<KEY,VALUE>\n                 {\n                     createSuccessorIfNeeded( leftSiblingCursor, structurePropagation, UPDATE_LEFT_CHILD,\n                             stableGeneration, unstableGeneration );\n-                    rebalanceLeaf( leftSiblingCursor, leftSiblingKeyCount, cursor, keyCount, keysToRebalance , structurePropagation );\n+rebalanceLeaf( leftSiblingCursor, leftSiblingKeyCount, cursor, keyCount, keysToRebalance, structurePropagation );\n                 }\n                 else if ( keysToRebalance == -1 )\n                 {\n@@ -1080,42 +1048,40 @@ class InternalTreeLogic<KEY,VALUE>\n                     // Parent pointer will be updated later.\n                     mergeFromLeftSiblingLeaf( cursor, leftSiblingCursor, structurePropagation, keyCount,\n                             leftSiblingKeyCount, stableGeneration, unstableGeneration );\n-                }\n+    }\n             }\n         }\n         else if ( TreeNode.isNode( rightSibling ) )\n         {\n-            try ( PageCursor rightSiblingCursor = cursor.openLinkedCursor(\n-                    GenerationSafePointerPair.pointer( rightSibling ) ) )\n+            try ( PageCursor rightSiblingCursor = cursor.openLinkedCursor( GenerationSafePointerPair.pointer( rightSibling ) ) )\n             {\n                 rightSiblingCursor.next();\n                 int rightSiblingKeyCount = TreeNode.keyCount( rightSiblingCursor );\n-\n-                if ( bTreeNode.canMergeLeaves( cursor, keyCount, rightSiblingCursor, rightSiblingKeyCount ) )\n+if ( bTreeNode.canMergeLeaves( cursor, keyCount, rightSiblingCursor, rightSiblingKeyCount ) )\n                 {\n                     createSuccessorIfNeeded( rightSiblingCursor, structurePropagation, UPDATE_RIGHT_CHILD,\n                             stableGeneration, unstableGeneration );\n-                    mergeToRightSiblingLeaf( cursor, rightSiblingCursor, structurePropagation, keyCount,\n-                            rightSiblingKeyCount, stableGeneration, unstableGeneration);\n-                }\n+mergeToRightSiblingLeaf( cursor, rightSiblingCursor, structurePropagation, keyCount,\n+                            rightSiblingKeyCount, stableGeneration, unstableGeneration );\n+    }\n             }\n         }\n     }\n \n-    private void connectLeftAndRightSibling( PageCursor cursor, long stableGeneration, long unstableGeneration )\n-            throws IOException\n-    {\n+    private void connectLeftAndRightSibling( PageCursor cursor, long stableGeneration, long unstableGeneration ) throws IOException\n+{\n         long currentId = cursor.getCurrentPageId();\n         long leftSibling = TreeNode.leftSibling( cursor, stableGeneration, unstableGeneration );\n         PointerChecking.checkPointer( leftSibling, true );\n-        long rightSibling = TreeNode. rightSibling( cursor, stableGeneration, unstableGeneration );\n+        long rightSibling = TreeNode.rightSibling( cursor, stableGeneration, unstableGeneration );\n         PointerChecking.checkPointer( rightSibling, true );\n         if ( TreeNode.isNode( leftSibling ) )\n         {\n             TreeNode.goTo( cursor, \"left sibling\", leftSibling );\n             TreeNode.setRightSibling( cursor, rightSibling, stableGeneration, unstableGeneration );\n         }\n-        if ( TreeNode.isNode( rightSibling ) )\n+\n+if ( TreeNode.isNode( rightSibling ) )\n         {\n             TreeNode.goTo( cursor, \"right sibling\", rightSibling );\n             TreeNode.setLeftSibling( cursor, leftSibling, stableGeneration, unstableGeneration );\n@@ -1124,10 +1090,9 @@ class InternalTreeLogic<KEY,VALUE>\n         TreeNode.goTo( cursor, \"back to origin after repointing siblings\", currentId );\n     }\n \n-    private void mergeToRightSiblingLeaf( PageCursor cursor, PageCursor rightSiblingCursor,\n-            StructurePropagation<KEY> structurePropagation, int keyCount, int rightSiblingKeyCount,\n+    private void mergeToRightSiblingLeaf( PageCursor cursor, PageCursor rightSiblingCursor, StructurePropagation<KEY> structurePropagation, int keyCount, int rightSiblingKeyCount,\n             long stableGeneration, long unstableGeneration ) throws IOException\n-    {\n+{\n         // Read the right-most key from the right sibling to use when comparing whether or not\n         // a common parent covers the keys in right sibling too\n         bTreeNode.keyAt( rightSiblingCursor, structurePropagation.rightKey, rightSiblingKeyCount - 1, LEAF );\n@@ -1142,10 +1107,9 @@ class InternalTreeLogic<KEY,VALUE>\n         structurePropagation.keyReplaceStrategy = BUBBLE;\n     }\n \n-    private void mergeFromLeftSiblingLeaf( PageCursor cursor, PageCursor leftSiblingCursor,\n-            StructurePropagation<KEY> structurePropagation, int keyCount, int leftSiblingKeyCount,\n+    private void mergeFromLeftSiblingLeaf( PageCursor cursor, PageCursor leftSiblingCursor, StructurePropagation<KEY> structurePropagation, int keyCount, int leftSiblingKeyCount,\n             long stableGeneration, long unstableGeneration ) throws IOException\n-    {\n+{\n         // Read the left-most key from the left sibling to use when comparing whether or not\n         // a common parent covers the keys in left sibling too\n         bTreeNode.keyAt( leftSiblingCursor, structurePropagation.leftKey, 0, LEAF );\n@@ -1160,22 +1124,19 @@ class InternalTreeLogic<KEY,VALUE>\n         structurePropagation.keyReplaceStrategy = BUBBLE;\n     }\n \n-    private void merge( PageCursor leftSiblingCursor, int leftSiblingKeyCount, PageCursor rightSiblingCursor,\n-            int rightSiblingKeyCount, long stableGeneration, long unstableGeneration ) throws IOException\n-    {\n+    private void merge( PageCursor leftSiblingCursor, int leftSiblingKeyCount, PageCursor rightSiblingCursor, int rightSiblingKeyCount, long stableGeneration, long unstableGeneration ) throws IOException\n+{\n         bTreeNode.copyKeyValuesFromLeftToRight( leftSiblingCursor, leftSiblingKeyCount, rightSiblingCursor, rightSiblingKeyCount );\n \n         // Update successor of left sibling to be right sibling\n         TreeNode.setSuccessor( leftSiblingCursor, rightSiblingCursor.getCurrentPageId(),\n                 stableGeneration, unstableGeneration );\n-\n-        // Add left sibling to free list\n+    // Add left sibling to free list\n         connectLeftAndRightSibling( leftSiblingCursor, stableGeneration, unstableGeneration );\n         idProvider.releaseId( stableGeneration, unstableGeneration, leftSiblingCursor.getCurrentPageId() );\n     }\n \n-    private void rebalanceLeaf( PageCursor leftCursor, int leftKeyCount, PageCursor rightCursor, int rightKeyCount,\n-            int numberOfKeysToMove, StructurePropagation<KEY> structurePropagation )\n+    private void rebalanceLeaf( PageCursor leftCursor, int leftKeyCount, PageCursor rightCursor, int rightKeyCount, int numberOfKeysToMove, StructurePropagation<KEY> structurePropagation )\n     {\n         bTreeNode.moveKeyValuesFromLeftToRight( leftCursor, leftKeyCount, rightCursor, rightKeyCount, leftKeyCount - numberOfKeysToMove );\n \n@@ -1228,9 +1189,8 @@ class InternalTreeLogic<KEY,VALUE>\n      * @throws IOException on cursor failure\n      */\n     private void createSuccessorIfNeeded( PageCursor cursor, StructurePropagation<KEY> structurePropagation,\n-            StructurePropagation.StructureUpdate structureUpdate, long stableGeneration, long unstableGeneration )\n-            throws IOException\n-    {\n+            StructurePropagation.StructureUpdate structureUpdate, long stableGeneration, long unstableGeneration ) throws IOException\n+{\n         long oldId = cursor.getCurrentPageId();\n         long nodeGeneration = TreeNode.generation( cursor );\n         if ( nodeGeneration == unstableGeneration )\n@@ -1274,7 +1234,8 @@ class InternalTreeLogic<KEY,VALUE>\n             TreeNode.goTo( cursor, \"left sibling in split\", leftSibling );\n             TreeNode.setRightSibling( cursor, successorId, stableGeneration, unstableGeneration );\n         }\n-        if ( TreeNode.isNode( rightSibling ) )\n+\n+if ( TreeNode.isNode( rightSibling ) )\n         {\n             TreeNode.goTo( cursor, \"right sibling in split\", rightSibling );\n             TreeNode.setLeftSibling( cursor, successorId, stableGeneration, unstableGeneration );\n@@ -1285,7 +1246,6 @@ class InternalTreeLogic<KEY,VALUE>\n \n         // Propagate structure change\n         structureUpdate.update( structurePropagation, successorId );\n-\n-        idProvider.releaseId( stableGeneration, unstableGeneration, oldId );\n+idProvider.releaseId( stableGeneration, unstableGeneration, oldId );\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 140
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "1",
                    "severity": "error",
                    "message": "Missing, wrong or duplicated license header",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "1",
                    "severity": "error",
                    "message": "Missing, wrong or duplicated license header",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ],
    "repaired_by": [],
    "not_repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}