{
    "project_name": "Gurux-gurux.dlms.java",
    "error_id": "28",
    "information": {
        "errors": [
            {
                "line": "532",
                "severity": "warning",
                "message": "Line is longer than 80 characters (found 103).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": "                throw new GXDLMSException(\"Invalid Exception.\");\n            }\n            switch (id) { // RX / TX are delivered from the partner's point of view => reversed to ours\n            case HDLCInfo.MAX_INFO_RX:\n                getLimits().setMaxInfoTX(val);\n                break;",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "532",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 103).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "509",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 103).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "710",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 83).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "811",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 86).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "833",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 83).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1589",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 83).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Gurux-gurux.dlms.java/errored/1/28/GXDLMSClient.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Gurux-gurux.dlms.java/intellij/28/GXDLMSClient.java\nindex b9d36272ac6..879d256ee6c 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Gurux-gurux.dlms.java/errored/1/28/GXDLMSClient.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Gurux-gurux.dlms.java/intellij/28/GXDLMSClient.java\n@@ -85,24 +85,19 @@ public class GXDLMSClient {\n \n     /**\n      * Constructor.\n-     * \n-     * @param useLogicalNameReferencing\n-     *            Is Logical Name referencing used.\n-     * @param clientAddress\n-     *            Server address.\n-     * @param serverAddress\n-     *            Client address.\n-     * @param forAuthentication\n-     *            Authentication type.\n-     * @param password\n-     *            Password if authentication is used.\n-     * @param interfaceType\n-     *            Object type.\n+     *\n+     * @param useLogicalNameReferencing Is Logical Name referencing used.\n+     * @param clientAddress             Server address.\n+     * @param serverAddress             Client address.\n+     * @param forAuthentication         Authentication type.\n+     * @param password                  Password if authentication is used.\n+     * @param interfaceType             Object type.\n      */\n     public GXDLMSClient(final boolean useLogicalNameReferencing,\n-            final int clientAddress, final int serverAddress,\n-            final Authentication forAuthentication, final String password,\n-            final InterfaceType interfaceType) {\n+                        final int clientAddress, final int serverAddress,\n+                        final Authentication forAuthentication,\n+                        final String password,\n+                        final InterfaceType interfaceType) {\n         this.setUseLogicalNameReferencing(useLogicalNameReferencing);\n         this.setClientAddress(clientAddress);\n         this.setServerAddress(serverAddress);\n@@ -112,8 +107,7 @@ public class GXDLMSClient {\n     }\n \n     /**\n-     * @param value\n-     *            Cipher interface that is used to cipher PDU.\n+     * @param value Cipher interface that is used to cipher PDU.\n      */\n     protected final void setCipher(final GXICipher value) {\n         settings.setCipher(value);\n@@ -137,7 +131,7 @@ public class GXDLMSClient {\n      * This list is used when Association view is read from the meter and\n      * description of the object is needed. If collection is not set description\n      * of object is empty.\n-     * \n+     *\n      * @return List of available OBIS codes.\n      */\n     public final GXObisCodeCollection getObisCodes() {\n@@ -151,9 +145,8 @@ public class GXDLMSClient {\n     /**\n      * Set starting packet index. Default is One based, but some meters use Zero\n      * based value. Usually this is not used.\n-     * \n-     * @param value\n-     *            Zero based starting index.\n+     *\n+     * @param value Zero based starting index.\n      */\n     public final void setStartingPacketIndex(final int value) {\n         settings.setStartingPacketIndex(value);\n@@ -167,8 +160,7 @@ public class GXDLMSClient {\n     }\n \n     /**\n-     * @param value\n-     *            Client address\n+     * @param value Client address\n      */\n     public final void setClientAddress(final int value) {\n         settings.setClientAddress(value);\n@@ -182,8 +174,7 @@ public class GXDLMSClient {\n     }\n \n     /**\n-     * @param value\n-     *            Server address.\n+     * @param value Server address.\n      */\n     public final void setServerAddress(final int value) {\n         settings.setServerAddress(value);\n@@ -191,16 +182,15 @@ public class GXDLMSClient {\n \n     /**\n      * @return Server address size in bytes. If it is Zero it is counted\n-     *         automatically.\n+     * automatically.\n      */\n     public final int getServerAddressSize() {\n         return settings.getServerAddressSize();\n     }\n \n     /**\n-     * @param value\n-     *            Server address size in bytes. If it is Zero it is counted\n-     *            automatically.\n+     * @param value Server address size in bytes. If it is Zero it is counted\n+     *              automatically.\n      */\n     public final void setServerAddressSize(final int value) {\n         settings.setServerAddressSize(value);\n@@ -208,7 +198,7 @@ public class GXDLMSClient {\n \n     /**\n      * DLMS version number. Gurux DLMS component supports DLMS version number 6.\n-     * \n+     *\n      * @return DLMS version number.\n      */\n     public final byte getDLMSVersion() {\n@@ -216,8 +206,7 @@ public class GXDLMSClient {\n     }\n \n     /**\n-     * @param value\n-     *            DLMS version number.\n+     * @param value DLMS version number.\n      */\n     public final void setDLMSVersion(final byte value) {\n         settings.setDLMSVersion(value);\n@@ -227,20 +216,19 @@ public class GXDLMSClient {\n      * Retrieves the maximum size of received PDU. PDU size tells maximum size\n      * of PDU packet. Value can be from 0 to 0xFFFF. By default the value is\n      * 0xFFFF.\n-     * \n+     *\n+     * @return Maximum size of received PDU.\n      * @see GXDLMSClient#getClientAddress\n      * @see GXDLMSClient#getServerAddress\n      * @see GXDLMSClient#getDLMSVersion\n      * @see GXDLMSClient#getUseLogicalNameReferencing\n-     * @return Maximum size of received PDU.\n      */\n     public final int getMaxReceivePDUSize() {\n         return settings.getMaxReceivePDUSize();\n     }\n \n     /**\n-     * @param value\n-     *            Maximum size of received PDU.\n+     * @param value Maximum size of received PDU.\n      */\n     public final void setMaxReceivePDUSize(final int value) {\n         settings.setMaxReceivePDUSize(value);\n@@ -252,7 +240,7 @@ public class GXDLMSClient {\n      * supports only either Logical or Short name referencing. The referencing\n      * is defined by the device manufacturer. If the referencing is wrong, the\n      * SNMR message will fail.\n-     * \n+     *\n      * @return Is Logical Name referencing used.\n      */\n     public final boolean getUseLogicalNameReferencing() {\n@@ -260,8 +248,7 @@ public class GXDLMSClient {\n     }\n \n     /**\n-     * @param value\n-     *            Is Logical Name referencing used.\n+     * @param value Is Logical Name referencing used.\n      */\n     public final void setUseLogicalNameReferencing(final boolean value) {\n         settings.setUseLogicalNameReferencing(value);\n@@ -277,7 +264,7 @@ public class GXDLMSClient {\n \n     /**\n      * Client to Server custom challenge.\n-     * \n+     *\n      * @return Client to Server custom challenge.\n      */\n     public final byte[] getCtoSChallenge() {\n@@ -287,9 +274,8 @@ public class GXDLMSClient {\n     /**\n      * Client to Server custom challenge. This is for debugging purposes. Reset\n      * custom challenge settings CtoSChallenge to null.\n-     * \n-     * @param value\n-     *            Client to Server challenge.\n+     *\n+     * @param value Client to Server challenge.\n      */\n     public final void setCtoSChallenge(final byte[] value) {\n         settings.setUseCustomChallenge(value != null);\n@@ -299,25 +285,23 @@ public class GXDLMSClient {\n     /**\n      * Retrieves the password that is used in communication. If authentication\n      * is set to none, password is not used.\n-     * \n-     * @see GXDLMSClient#getAuthentication\n+     *\n      * @return Used password.\n+     * @see GXDLMSClient#getAuthentication\n      */\n     public final byte[] getPassword() {\n         return settings.getPassword();\n     }\n \n     /**\n-     * @param value\n-     *            Used password as byte array.\n+     * @param value Used password as byte array.\n      */\n     public final void setPassword(final byte[] value) {\n         settings.setPassword(value);\n     }\n \n     /**\n-     * @param value\n-     *            Used password as string value.\n+     * @param value Used password as string value.\n      */\n     public final void setPassword(final String value) {\n         settings.setPassword(value.getBytes());\n@@ -341,18 +325,17 @@ public class GXDLMSClient {\n      * Retrieves the authentication used in communicating with the device. By\n      * default authentication is not used. If authentication is used, set the\n      * password with the Password property.\n-     * \n+     *\n+     * @return Used authentication.\n      * @see GXDLMSClient#getPassword\n      * @see GXDLMSClient#getClientAddress\n-     * @return Used authentication.\n      */\n     public final Authentication getAuthentication() {\n         return settings.getAuthentication();\n     }\n \n     /**\n-     * @param value\n-     *            Used authentication.\n+     * @param value Used authentication.\n      */\n     public final void setAuthentication(final Authentication value) {\n         settings.setAuthentication(value);\n@@ -366,8 +349,7 @@ public class GXDLMSClient {\n     }\n \n     /**\n-     * @param value\n-     *            Used Priority.\n+     * @param value Used Priority.\n      */\n     public final void setPriority(final Priority value) {\n         settings.setPriority(value);\n@@ -381,8 +363,7 @@ public class GXDLMSClient {\n     }\n \n     /**\n-     * @param value\n-     *            Used service class.\n+     * @param value Used service class.\n      */\n     public final void setServiceClass(final ServiceClass value) {\n         settings.setServiceClass(value);\n@@ -396,8 +377,7 @@ public class GXDLMSClient {\n     }\n \n     /**\n-     * @param value\n-     *            Invoke ID.\n+     * @param value Invoke ID.\n      */\n     public final void setInvokeID(final int value) {\n         settings.setInvokeID(value);\n@@ -411,8 +391,7 @@ public class GXDLMSClient {\n     }\n \n     /**\n-     * @param value\n-     *            Interface type.\n+     * @param value Interface type.\n      */\n     public final void setInterfaceType(final InterfaceType value) {\n         settings.setInterfaceType(value);\n@@ -435,11 +414,11 @@ public class GXDLMSClient {\n      * </ul>\n      * <b>Note! </b>According to IEC 62056-47: when communicating using TCP/IP,\n      * the SNRM request is not send.\n-     * \n+     *\n+     * @return SNRM request as byte array.\n      * @see GXDLMSClient#getClientAddress\n      * @see GXDLMSClient#getServerAddress\n      * @see GXDLMSClient#parseUAResponse\n-     * @return SNRM request as byte array.\n      */\n     public final byte[] snrmRequest() {\n         settings.setConnected(false);\n@@ -492,9 +471,8 @@ public class GXDLMSClient {\n \n     /**\n      * Parses UAResponse from byte array.\n-     * \n-     * @param data\n-     *            Received message from the server.\n+     *\n+     * @param data Received message from the server.\n      * @see GXDLMSClient#snrmRequest\n      */\n     public final void parseUAResponse(final byte[] data) {\n@@ -503,9 +481,8 @@ public class GXDLMSClient {\n \n     /**\n      * Parses UAResponse from byte array.\n-     * \n-     * @param data\n-     *            Received message from the server.\n+     *\n+     * @param data Received message from the server.\n      * @see GXDLMSClient#snrmRequest\n      */\n     public final void parseUAResponse(final GXByteBuffer data) {\n@@ -517,33 +494,33 @@ public class GXDLMSClient {\n             int id = data.getUInt8();\n             short len = data.getUInt8();\n             switch (len) {\n-            case 1:\n-                val = data.getUInt8();\n-                break;\n-            case 2:\n-                val = data.getUInt16();\n-                break;\n-            case 4:\n-                val = data.getUInt32();\n-                break;\n-            default:\n-                throw new GXDLMSException(\"Invalid Exception.\");\n+                case 1:\n+                    val = data.getUInt8();\n+                    break;\n+                case 2:\n+                    val = data.getUInt16();\n+                    break;\n+                case 4:\n+                    val = data.getUInt32();\n+                    break;\n+                default:\n+                    throw new GXDLMSException(\"Invalid Exception.\");\n             }\n             switch (id) { // RX / TX are delivered from the partner's point of view => reversed to ours\n-            case HDLCInfo.MAX_INFO_RX:\n-                getLimits().setMaxInfoTX(val);\n-                break;\n-            case HDLCInfo.MAX_INFO_TX:\n-                getLimits().setMaxInfoRX(val);\n-                break;\n-            case HDLCInfo.WINDOW_SIZE_RX:\n-                getLimits().setWindowSizeTX(val);\n-                break;\n-            case HDLCInfo.WINDOW_SIZE_TX:\n-                getLimits().setWindowSizeRX(val);\n-                break;\n-            default:\n-                throw new GXDLMSException(\"Invalid UA response.\");\n+                case HDLCInfo.MAX_INFO_RX:\n+                    getLimits().setMaxInfoTX(val);\n+                    break;\n+                case HDLCInfo.MAX_INFO_TX:\n+                    getLimits().setMaxInfoRX(val);\n+                    break;\n+                case HDLCInfo.WINDOW_SIZE_RX:\n+                    getLimits().setWindowSizeTX(val);\n+                    break;\n+                case HDLCInfo.WINDOW_SIZE_TX:\n+                    getLimits().setWindowSizeRX(val);\n+                    break;\n+                default:\n+                    throw new GXDLMSException(\"Invalid UA response.\");\n             }\n         }\n     }\n@@ -552,7 +529,7 @@ public class GXDLMSClient {\n      * Generate AARQ request. Because all meters can't read all data in one\n      * packet, the packet must be split first, by using SplitDataToPackets\n      * method.\n-     * \n+     *\n      * @return AARQ request as byte array.\n      * @see GXDLMSClient#parseAareResponse\n      */\n@@ -582,9 +559,8 @@ public class GXDLMSClient {\n      * </ul>\n      * LNSettings or SNSettings will be updated, depending on the referencing,\n      * Logical name or Short name.\n-     * \n-     * @param reply\n-     *            Received data.\n+     *\n+     * @param reply Received data.\n      * @see GXDLMSClient#aarqRequest\n      * @see GXDLMSClient#getUseLogicalNameReferencing\n      * @see GXDLMSClient#getLNSettings\n@@ -642,12 +618,11 @@ public class GXDLMSClient {\n \n     /**\n      * Parse server's challenge if HLS authentication is used.\n-     * \n-     * @param reply\n-     *            Received reply from the server.\n+     *\n+     * @param reply Received reply from the server.\n      */\n     public final void\n-            parseApplicationAssociationResponse(final GXByteBuffer reply) {\n+    parseApplicationAssociationResponse(final GXByteBuffer reply) {\n         GXDataInfo info = new GXDataInfo();\n         boolean equals = false;\n         byte[] secret;\n@@ -683,7 +658,7 @@ public class GXDLMSClient {\n \n     /**\n      * Generates a disconnect request.\n-     * \n+     *\n      * @return Disconnected request, as byte array.\n      */\n     public final byte[] disconnectRequest() {\n@@ -705,22 +680,18 @@ public class GXDLMSClient {\n \n     /**\n      * Reserved for internal use.\n-     * \n-     * @param classID\n-     *            Class ID.\n-     * @param version\n-     *            Version number.\n-     * @param baseName\n-     *            Short name.\n-     * @param ln\n-     *            Logical name.\n-     * @param accessRights\n-     *            Array of access rights.\n+     *\n+     * @param classID      Class ID.\n+     * @param version      Version number.\n+     * @param baseName     Short name.\n+     * @param ln           Logical name.\n+     * @param accessRights Array of access rights.\n      * @return Created COSEM object.\n      */\n     static GXDLMSObject createDLMSObject(final int classID,\n-            final Object version, final int baseName, final Object ln,\n-            final Object accessRights) {\n+                                         final Object version,\n+                                         final int baseName, final Object ln,\n+                                         final Object accessRights) {\n         ObjectType type = ObjectType.forValue(classID);\n         GXDLMSObject obj = createObject(type);\n         updateObjectData(obj, type, version, baseName, (byte[]) ln,\n@@ -730,15 +701,13 @@ public class GXDLMSClient {\n \n     /**\n      * Parse SN objects.\n-     * \n-     * @param buff\n-     *            Byte stream where objects are parsed.\n-     * @param onlyKnownObjects\n-     *            Only known objects are parsed.\n+     *\n+     * @param buff             Byte stream where objects are parsed.\n+     * @param onlyKnownObjects Only known objects are parsed.\n      * @return Collection of COSEM objects.\n      */\n     private GXDLMSObjectCollection parseSNObjects(final GXByteBuffer buff,\n-            final boolean onlyKnownObjects) {\n+                                                  final boolean onlyKnownObjects) {\n         // Get array tag.\n         short size = buff.getUInt8();\n         // Check that data is in the array\n@@ -779,7 +748,7 @@ public class GXDLMSClient {\n \n     /**\n      * Reserved for internal use.\n-     * \n+     *\n      * @param objectType\n      * @param version\n      * @param baseName\n@@ -787,9 +756,11 @@ public class GXDLMSClient {\n      * @param accessRights\n      */\n     static void updateObjectData(final GXDLMSObject obj,\n-            final ObjectType objectType, final Object version,\n-            final Object baseName, final byte[] logicalName,\n-            final Object accessRights) {\n+                                 final ObjectType objectType,\n+                                 final Object version,\n+                                 final Object baseName,\n+                                 final byte[] logicalName,\n+                                 final Object accessRights) {\n         obj.setObjectType(objectType);\n         // Check access rights.\n         if (accessRights instanceof Object[]\n@@ -831,15 +802,13 @@ public class GXDLMSClient {\n \n     /**\n      * Parses the COSEM objects of the received data.\n-     * \n-     * @param data\n-     *            Received data, from the device, as byte array.\n-     * @param onlyKnownObjects\n-     *            Only known objects are parsed.\n+     *\n+     * @param data             Received data, from the device, as byte array.\n+     * @param onlyKnownObjects Only known objects are parsed.\n      * @return Collection of COSEM objects.\n      */\n     public final GXDLMSObjectCollection parseObjects(final GXByteBuffer data,\n-            final boolean onlyKnownObjects) {\n+                                                     final boolean onlyKnownObjects) {\n         if (data == null) {\n             throw new GXDLMSException(\"Invalid parameter.\");\n         }\n@@ -855,15 +824,13 @@ public class GXDLMSClient {\n \n     /**\n      * Parse LN objects.\n-     * \n-     * @param buff\n-     *            Byte stream where objects are parsed.\n-     * @param onlyKnownObjects\n-     *            Only known objects are parsed.\n+     *\n+     * @param buff             Byte stream where objects are parsed.\n+     * @param onlyKnownObjects Only known objects are parsed.\n      * @return Collection of COSEM objects.\n      */\n     private GXDLMSObjectCollection parseLNObjects(final GXByteBuffer buff,\n-            final boolean onlyKnownObjects) {\n+                                                  final boolean onlyKnownObjects) {\n         // Get array tag.\n         byte size = buff.getInt8();\n         // Check that data is in the array\n@@ -907,7 +874,8 @@ public class GXDLMSClient {\n      * Get Value from byte array received from the meter.\n      */\n     public final Object updateValue(final GXDLMSObject target,\n-            final int attributeIndex, final Object value) {\n+                                    final int attributeIndex,\n+                                    final Object value) {\n         Object val = value;\n         if (val instanceof byte[]) {\n             DataType type = target.getUIDataType(attributeIndex);\n@@ -928,9 +896,8 @@ public class GXDLMSClient {\n \n     /**\n      * Get Value from byte array received from the meter.\n-     * \n-     * @param data\n-     *            Byte array received from the meter.\n+     *\n+     * @param data Byte array received from the meter.\n      * @return Received data.\n      */\n     public final Object getValue(final GXByteBuffer data) {\n@@ -940,11 +907,9 @@ public class GXDLMSClient {\n \n     /**\n      * Update list of values.\n-     * \n-     * @param list\n-     *            read objects.\n-     * @param data\n-     *            Received reply from the meter.\n+     *\n+     * @param list read objects.\n+     * @param data Received reply from the meter.\n      */\n     public final void updateValues(\n             final List<Entry<GXDLMSObject, Integer>> list,\n@@ -968,11 +933,9 @@ public class GXDLMSClient {\n \n     /**\n      * Update list of values.\n-     * \n-     * @param list\n-     *            read objects.\n-     * @param reply\n-     *            Received reply from the meter.\n+     *\n+     * @param list  read objects.\n+     * @param reply Received reply from the meter.\n      */\n     public final void updateValues(\n             final List<Entry<GXDLMSObject, Integer>> list, final byte[] reply) {\n@@ -981,11 +944,9 @@ public class GXDLMSClient {\n \n     /**\n      * Changes byte array received from the meter to given type.\n-     * \n-     * @param value\n-     *            Byte array received from the meter.\n-     * @param type\n-     *            Wanted type.\n+     *\n+     * @param value Byte array received from the meter.\n+     * @param type  Wanted type.\n      * @return Value changed by type.\n      */\n     public static Object changeType(final byte[] value, final DataType type) {\n@@ -1028,7 +989,7 @@ public class GXDLMSClient {\n     /**\n      * Reads the Association view from the device. This method is used to get\n      * all objects in the device.\n-     * \n+     *\n      * @return Read request, as byte array.\n      */\n     public final byte[] getObjectsRequest() {\n@@ -1044,40 +1005,31 @@ public class GXDLMSClient {\n \n     /**\n      * Generate Method (Action) request.\n-     * \n-     * @param item\n-     *            Method object short name or Logical Name.\n-     * @param index\n-     *            Method index.\n-     * @param data\n-     *            Method data.\n-     * @param type\n-     *            Data type.\n+     *\n+     * @param item  Method object short name or Logical Name.\n+     * @param index Method index.\n+     * @param data  Method data.\n+     * @param type  Data type.\n      * @return DLMS action message.\n      */\n     public final byte[][] method(final GXDLMSObject item, final int index,\n-            final Object data, final DataType type) {\n+                                 final Object data, final DataType type) {\n         return method(item.getName(), item.getObjectType(), index, data, type);\n     }\n \n     /**\n      * Generate Method (Action) request..\n-     * \n-     * @param name\n-     *            Method object short name or Logical Name.\n-     * @param objectType\n-     *            Object type.\n-     * @param methodIndex\n-     *            Method index.\n-     * @param value\n-     *            Method data.\n-     * @param dataType\n-     *            Data type.\n+     *\n+     * @param name        Method object short name or Logical Name.\n+     * @param objectType  Object type.\n+     * @param methodIndex Method index.\n+     * @param value       Method data.\n+     * @param dataType    Data type.\n      * @return DLMS action message.\n      */\n     public final byte[][] method(final Object name, final ObjectType objectType,\n-            final int methodIndex, final Object value,\n-            final DataType dataType) {\n+                                 final int methodIndex, final Object value,\n+                                 final DataType dataType) {\n         if (name == null || methodIndex < 1) {\n             throw new IllegalArgumentException(\"Invalid parameter\");\n         }\n@@ -1146,11 +1098,9 @@ public class GXDLMSClient {\n \n     /**\n      * Generates a write message.\n-     * \n-     * @param item\n-     *            COSEM object to read.\n-     * @param index\n-     *            Attribute index.\n+     *\n+     * @param item  COSEM object to read.\n+     * @param index Attribute index.\n      * @return Generated write message(s).\n      */\n     public final byte[][] write(final GXDLMSObject item, final int index) {\n@@ -1162,22 +1112,18 @@ public class GXDLMSClient {\n \n     /**\n      * Generates a write message.\n-     * \n-     * @param name\n-     *            Short or Logical Name.\n-     * @param value\n-     *            Data to Write.\n-     * @param dataType\n-     *            Data type of write object.\n-     * @param objectType\n-     *            Object type.\n-     * @param index\n-     *            Attribute index where data is write.\n+     *\n+     * @param name       Short or Logical Name.\n+     * @param value      Data to Write.\n+     * @param dataType   Data type of write object.\n+     * @param objectType Object type.\n+     * @param index      Attribute index where data is write.\n      * @return Generated write message(s).\n      */\n     public final byte[][] write(final Object name, final Object value,\n-            final DataType dataType, final ObjectType objectType,\n-            final int index) {\n+                                final DataType dataType,\n+                                final ObjectType objectType,\n+                                final int index) {\n         if (index < 1) {\n             throw new GXDLMSException(\"Invalid parameter\");\n         }\n@@ -1227,9 +1173,8 @@ public class GXDLMSClient {\n \n     /**\n      * Write list of COSEM objects.\n-     * \n-     * @param list\n-     *            DLMS objects to write.\n+     *\n+     * @param list DLMS objects to write.\n      * @return Write request as byte array.\n      */\n     public final byte[][] writeList(final List<GXWriteItem> list) {\n@@ -1297,35 +1242,28 @@ public class GXDLMSClient {\n \n     /**\n      * Generates a read message.\n-     * \n-     * @param name\n-     *            Short or Logical Name.\n-     * @param objectType\n-     *            COSEM object type.\n-     * @param attributeOrdinal\n-     *            Attribute index of the object.\n+     *\n+     * @param name             Short or Logical Name.\n+     * @param objectType       COSEM object type.\n+     * @param attributeOrdinal Attribute index of the object.\n      * @return Generated read message(s).\n      */\n     public final byte[][] read(final Object name, final ObjectType objectType,\n-            final int attributeOrdinal) {\n+                               final int attributeOrdinal) {\n         return read(name, objectType, attributeOrdinal, null);\n     }\n \n     /**\n      * Generates a read message.\n-     * \n-     * @param name\n-     *            Short or Logical Name.\n-     * @param objectType\n-     *            COSEM object type.\n-     * @param attributeOrdinal\n-     *            Attribute index of the object.\n-     * @param data\n-     *            Read data parameter.\n+     *\n+     * @param name             Short or Logical Name.\n+     * @param objectType       COSEM object type.\n+     * @param attributeOrdinal Attribute index of the object.\n+     * @param data             Read data parameter.\n      * @return Generated read message(s).\n      */\n     private byte[][] read(final Object name, final ObjectType objectType,\n-            final int attributeOrdinal, final GXByteBuffer data) {\n+                          final int attributeOrdinal, final GXByteBuffer data) {\n         if ((attributeOrdinal < 1)) {\n             throw new IllegalArgumentException(\"Invalid parameter\");\n         }\n@@ -1378,27 +1316,24 @@ public class GXDLMSClient {\n \n     /**\n      * Generates a read message.\n-     * \n-     * @param item\n-     *            DLMS object to read.\n-     * @param attributeOrdinal\n-     *            Read attribute index.\n+     *\n+     * @param item             DLMS object to read.\n+     * @param attributeOrdinal Read attribute index.\n      * @return Read request as byte array.\n      */\n     public final byte[][] read(final GXDLMSObject item,\n-            final int attributeOrdinal) {\n+                               final int attributeOrdinal) {\n         return read(item.getName(), item.getObjectType(), attributeOrdinal);\n     }\n \n     /**\n      * Read list of COSEM objects.\n-     * \n-     * @param list\n-     *            DLMS objects to read.\n+     *\n+     * @param list DLMS objects to read.\n      * @return Read request as byte array.\n      */\n     public final byte[][]\n-            readList(final List<Entry<GXDLMSObject, Integer>> list) {\n+    readList(final List<Entry<GXDLMSObject, Integer>> list) {\n         if (list == null || list.isEmpty()) {\n             throw new IllegalArgumentException(\"Invalid parameter.\");\n         }\n@@ -1469,7 +1404,7 @@ public class GXDLMSClient {\n     /**\n      * Generates the keep alive message. Keep alive message is sent to keep the\n      * connection to the device alive.\n-     * \n+     *\n      * @return Returns Keep alive message, as byte array.\n      */\n     public final byte[] keepAlive() {\n@@ -1482,17 +1417,14 @@ public class GXDLMSClient {\n \n     /**\n      * Read rows by entry.\n-     * \n-     * @param pg\n-     *            Profile generic object to read.\n-     * @param index\n-     *            Zero bases start index.\n-     * @param count\n-     *            Rows count to read.\n+     *\n+     * @param pg    Profile generic object to read.\n+     * @param index Zero bases start index.\n+     * @param count Rows count to read.\n      * @return Read message as byte array.\n      */\n     public final byte[][] readRowsByEntry(final GXDLMSProfileGeneric pg,\n-            final int index, final int count) {\n+                                          final int index, final int count) {\n         GXByteBuffer buff = new GXByteBuffer(19);\n         // Add AccessSelector value\n         buff.setUInt8(0x02);\n@@ -1517,51 +1449,44 @@ public class GXDLMSClient {\n     /**\n      * Read rows by range. Use this method to read Profile Generic table between\n      * dates.\n-     * \n-     * @param pg\n-     *            Profile generic object to read.\n-     * @param start\n-     *            Start time.\n-     * @param end\n-     *            End time.\n+     *\n+     * @param pg    Profile generic object to read.\n+     * @param start Start time.\n+     * @param end   End time.\n      * @return Generated read message.\n      */\n     public final byte[][] readRowsByRange(final GXDLMSProfileGeneric pg,\n-            final java.util.Date start, final java.util.Date end) {\n+                                          final java.util.Date start,\n+                                          final java.util.Date end) {\n         return readByRange(pg, start, end);\n     }\n \n     /**\n      * Read rows by range. Use this method to read Profile Generic table between\n      * dates.\n-     * \n-     * @param pg\n-     *            Profile generic object to read.\n-     * @param start\n-     *            Start time.\n-     * @param end\n-     *            End time.\n+     *\n+     * @param pg    Profile generic object to read.\n+     * @param start Start time.\n+     * @param end   End time.\n      * @return Generated read message.\n      */\n     public final byte[][] readRowsByRange(final GXDLMSProfileGeneric pg,\n-            final Calendar start, final Calendar end) {\n+                                          final Calendar start,\n+                                          final Calendar end) {\n         return readByRange(pg, start, end);\n     }\n \n     /**\n      * Read rows by range. Use this method to read Profile Generic table between\n      * dates.\n-     * \n-     * @param pg\n-     *            Profile generic object to read.\n-     * @param start\n-     *            Start time.\n-     * @param end\n-     *            End time.\n+     *\n+     * @param pg    Profile generic object to read.\n+     * @param start Start time.\n+     * @param end   End time.\n      * @return Generated read message.\n      */\n     private byte[][] readByRange(final GXDLMSProfileGeneric pg,\n-            final Object start, final Object end) {\n+                                 final Object start, final Object end) {\n         settings.resetBlockIndex();\n         GXDLMSObject sort = pg.getSortObject();\n         if (sort == null && pg.getCaptureObjects().size() != 0) {\n@@ -1602,9 +1527,8 @@ public class GXDLMSClient {\n \n     /**\n      * Create object by object type.\n-     * \n-     * @param type\n-     *            Object type.\n+     *\n+     * @param type Object type.\n      * @return Created object.\n      */\n     public static GXDLMSObject createObject(final ObjectType type) {\n@@ -1614,9 +1538,8 @@ public class GXDLMSClient {\n     /**\n      * Generates an acknowledgment message, with which the server is informed to\n      * send next packets.\n-     * \n-     * @param type\n-     *            Frame type\n+     *\n+     * @param type Frame type\n      * @return Acknowledgment message as byte array.\n      */\n     public final byte[] receiverReady(final RequestTypes type) {\n@@ -1625,11 +1548,9 @@ public class GXDLMSClient {\n \n     /**\n      * Removes the HDLC frame from the packet, and returns COSEM data only.\n-     * \n-     * @param reply\n-     *            The received data from the device.\n-     * @param data\n-     *            Information from the received data.\n+     *\n+     * @param reply The received data from the device.\n+     * @param data  Information from the received data.\n      * @return Is frame complete.\n      */\n     public final boolean getData(final byte[] reply, final GXReplyData data) {\n@@ -1638,14 +1559,12 @@ public class GXDLMSClient {\n \n     /**\n      * Removes the HDLC frame from the packet, and returns COSEM data only.\n-     * \n-     * @param reply\n-     *            The received data from the device.\n-     * @param data\n-     *            The exported reply information.\n+     *\n+     * @param reply The received data from the device.\n+     * @param data  The exported reply information.\n      */\n     public final void getData(final GXByteBuffer reply,\n-            final GXReplyData data) {\n+                              final GXReplyData data) {\n         GXDLMS.getData(settings, reply, data);\n     }\n \n@@ -1653,9 +1572,8 @@ public class GXDLMSClient {\n      * Converts meter serial number to server address. Default formula is used.\n      * All meters do not use standard formula or support serial number\n      * addressing at all.\n-     * \n-     * @param serialNumber\n-     *            Meter serial number\n+     *\n+     * @param serialNumber Meter serial number\n      * @return Server address.\n      */\n     public static int getServerAddress(final int serialNumber) {\n@@ -1666,16 +1584,14 @@ public class GXDLMSClient {\n      * Converts meter serial number to server address. Default formula is used.\n      * All meters do not use standard formula or support serial number\n      * addressing at all.\n-     * \n-     * @param serialNumber\n-     *            Meter serial number\n-     * @param formula\n-     *            Formula used to convert serial number to server address.\n+     *\n+     * @param serialNumber Meter serial number\n+     * @param formula      Formula used to convert serial number to server address.\n      * @return Server address.\n      */\n \n     public static int getServerAddress(final int serialNumber,\n-            final String formula) {\n+                                       final String formula) {\n         // If formula is not given use default formula.\n         // This formula is defined in DLMS specification.\n         if (formula == null || formula.length() == 0) {\n@@ -1687,31 +1603,27 @@ public class GXDLMSClient {\n \n     /**\n      * Convert physical address and logical address to server address.\n-     * \n-     * @param logicalAddress\n-     *            Server logical address.\n-     * @param physicalAddress\n-     *            Server physical address.\n+     *\n+     * @param logicalAddress  Server logical address.\n+     * @param physicalAddress Server physical address.\n      * @return Server address.\n      */\n     public static int getServerAddress(final int logicalAddress,\n-            final int physicalAddress) {\n+                                       final int physicalAddress) {\n         return getServerAddress(logicalAddress, physicalAddress, 0);\n     }\n \n     /**\n      * Convert physical address and logical address to server address.\n-     * \n-     * @param logicalAddress\n-     *            Server logical address.\n-     * @param physicalAddress\n-     *            Server physical address.\n-     * @param addressSize\n-     *            Address size in bytes.\n+     *\n+     * @param logicalAddress  Server logical address.\n+     * @param physicalAddress Server physical address.\n+     * @param addressSize     Address size in bytes.\n      * @return Server address.\n      */\n     public static int getServerAddress(final int logicalAddress,\n-            final int physicalAddress, final int addressSize) {\n+                                       final int physicalAddress,\n+                                       final int addressSize) {\n         if (addressSize < 4 && physicalAddress < 0x80\n                 && logicalAddress < 0x80) {\n             return logicalAddress << 7 | physicalAddress;\n",
            "diff_size": 317
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "72",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 88).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "106",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 214).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "532",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 88).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "537",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 88).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "542",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 95).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "547",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 95).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "606",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 103).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "643",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 96).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "673",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 134).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "695",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 83).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "710",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 112).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "716",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 119).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "718",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 103).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "729",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 85).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "744",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 114).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "748",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 97).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "770",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 83).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "800",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 147).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "823",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 108).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "854",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 81).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "877",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 185).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "880",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 88).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "927",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 111).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "953",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 108).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "980",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 101).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "981",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 81).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "984",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 138).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "996",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 110).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1008",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 89).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1038",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 108).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1045",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 101).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1065",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 103).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1087",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 94).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1178",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 150).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1287",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 143).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1362",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 90).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1390",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 129).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1423",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 108).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1442",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 128).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1506",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 85).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1521",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 83).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1547",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 87).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1561",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 99).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1582",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 87).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1616",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 108).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1673",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 116).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1691",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 103).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1787",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 81).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1819",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 86).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1823",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 89).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1839",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 93).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1856",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 116).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Gurux-gurux.dlms.java/errored/1/28/GXDLMSClient.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Gurux-gurux.dlms.java/codebuff/28/GXDLMSClient.java\nindex b9d36272ac6..110b07abb1e 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Gurux-gurux.dlms.java/errored/1/28/GXDLMSClient.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Gurux-gurux.dlms.java/codebuff/28/GXDLMSClient.java\n@@ -40,7 +40,6 @@ import java.util.Calendar;\n import java.util.List;\n import java.util.Map.Entry;\n import java.util.logging.Logger;\n-\n import gurux.dlms.enums.AccessMode;\n import gurux.dlms.enums.Authentication;\n import gurux.dlms.enums.Command;\n@@ -63,14 +62,14 @@ import gurux.dlms.secure.GXSecure;\n /**\n  * GXDLMS implements methods to communicate with DLMS/COSEM metering devices.\n  */\n+\n public class GXDLMSClient {\n     /**\n      * DLMS settings.\n      */\n     private final GXDLMSSettings settings = new GXDLMSSettings(false);\n     private GXObisCodeCollection obisCodes;\n-    private static final Logger LOGGER =\n-            Logger.getLogger(GXDLMSClient.class.getName());\n+    private static final Logger LOGGER = Logger.getLogger(GXDLMSClient.class.getName());\n \n     /**\n      * Is authentication required.\n@@ -80,7 +79,10 @@ public class GXDLMSClient {\n     /**\n      * Constructor.\n      */\n+\n+\n     public GXDLMSClient() {\n+\n     }\n \n     /**\n@@ -99,10 +101,9 @@ public class GXDLMSClient {\n      * @param interfaceType\n      *            Object type.\n      */\n-    public GXDLMSClient(final boolean useLogicalNameReferencing,\n-            final int clientAddress, final int serverAddress,\n-            final Authentication forAuthentication, final String password,\n-            final InterfaceType interfaceType) {\n+\n+\n+    public GXDLMSClient(final boolean useLogicalNameReferencing, final int clientAddress, final int serverAddress, final Authentication forAuthentication, final String password, final InterfaceType interfaceType) {\n         this.setUseLogicalNameReferencing(useLogicalNameReferencing);\n         this.setClientAddress(clientAddress);\n         this.setServerAddress(serverAddress);\n@@ -115,6 +116,8 @@ public class GXDLMSClient {\n      * @param value\n      *            Cipher interface that is used to cipher PDU.\n      */\n+\n+\n     protected final void setCipher(final GXICipher value) {\n         settings.setCipher(value);\n     }\n@@ -122,6 +125,8 @@ public class GXDLMSClient {\n     /**\n      * @return Get settings.\n      */\n+\n+\n     protected final GXDLMSSettings getSettings() {\n         return settings;\n     }\n@@ -129,6 +134,8 @@ public class GXDLMSClient {\n     /**\n      * @return Get list of meter's objects.\n      */\n+\n+\n     public final GXDLMSObjectCollection getObjects() {\n         return settings.getObjects();\n     }\n@@ -140,10 +147,13 @@ public class GXDLMSClient {\n      * \n      * @return List of available OBIS codes.\n      */\n+\n+\n     public final GXObisCodeCollection getObisCodes() {\n         return obisCodes;\n     }\n \n+\n     public final void setObisCodes(final GXObisCodeCollection value) {\n         obisCodes = value;\n     }\n@@ -155,6 +165,8 @@ public class GXDLMSClient {\n      * @param value\n      *            Zero based starting index.\n      */\n+\n+\n     public final void setStartingPacketIndex(final int value) {\n         settings.setStartingPacketIndex(value);\n     }\n@@ -162,6 +174,8 @@ public class GXDLMSClient {\n     /**\n      * @return Client address.\n      */\n+\n+\n     public final int getClientAddress() {\n         return settings.getClientAddress();\n     }\n@@ -170,6 +184,8 @@ public class GXDLMSClient {\n      * @param value\n      *            Client address\n      */\n+\n+\n     public final void setClientAddress(final int value) {\n         settings.setClientAddress(value);\n     }\n@@ -177,6 +193,8 @@ public class GXDLMSClient {\n     /**\n      * @return Server Address.\n      */\n+\n+\n     public final int getServerAddress() {\n         return settings.getServerAddress();\n     }\n@@ -185,6 +203,8 @@ public class GXDLMSClient {\n      * @param value\n      *            Server address.\n      */\n+\n+\n     public final void setServerAddress(final int value) {\n         settings.setServerAddress(value);\n     }\n@@ -193,6 +213,8 @@ public class GXDLMSClient {\n      * @return Server address size in bytes. If it is Zero it is counted\n      *         automatically.\n      */\n+\n+\n     public final int getServerAddressSize() {\n         return settings.getServerAddressSize();\n     }\n@@ -202,6 +224,8 @@ public class GXDLMSClient {\n      *            Server address size in bytes. If it is Zero it is counted\n      *            automatically.\n      */\n+\n+\n     public final void setServerAddressSize(final int value) {\n         settings.setServerAddressSize(value);\n     }\n@@ -211,6 +235,8 @@ public class GXDLMSClient {\n      * \n      * @return DLMS version number.\n      */\n+\n+\n     public final byte getDLMSVersion() {\n         return settings.getDLMSVersion();\n     }\n@@ -219,6 +245,8 @@ public class GXDLMSClient {\n      * @param value\n      *            DLMS version number.\n      */\n+\n+\n     public final void setDLMSVersion(final byte value) {\n         settings.setDLMSVersion(value);\n     }\n@@ -234,6 +262,8 @@ public class GXDLMSClient {\n      * @see GXDLMSClient#getUseLogicalNameReferencing\n      * @return Maximum size of received PDU.\n      */\n+\n+\n     public final int getMaxReceivePDUSize() {\n         return settings.getMaxReceivePDUSize();\n     }\n@@ -242,6 +272,8 @@ public class GXDLMSClient {\n      * @param value\n      *            Maximum size of received PDU.\n      */\n+\n+\n     public final void setMaxReceivePDUSize(final int value) {\n         settings.setMaxReceivePDUSize(value);\n     }\n@@ -255,6 +287,8 @@ public class GXDLMSClient {\n      * \n      * @return Is Logical Name referencing used.\n      */\n+\n+\n     public final boolean getUseLogicalNameReferencing() {\n         return settings.getUseLogicalNameReferencing();\n     }\n@@ -263,6 +297,8 @@ public class GXDLMSClient {\n      * @param value\n      *            Is Logical Name referencing used.\n      */\n+\n+\n     public final void setUseLogicalNameReferencing(final boolean value) {\n         settings.setUseLogicalNameReferencing(value);\n     }\n@@ -280,6 +316,8 @@ public class GXDLMSClient {\n      * \n      * @return Client to Server custom challenge.\n      */\n+\n+\n     public final byte[] getCtoSChallenge() {\n         return settings.getCtoSChallenge();\n     }\n@@ -291,6 +329,8 @@ public class GXDLMSClient {\n      * @param value\n      *            Client to Server challenge.\n      */\n+\n+\n     public final void setCtoSChallenge(final byte[] value) {\n         settings.setUseCustomChallenge(value != null);\n         settings.setCtoSChallenge(value);\n@@ -303,6 +343,8 @@ public class GXDLMSClient {\n      * @see GXDLMSClient#getAuthentication\n      * @return Used password.\n      */\n+\n+\n     public final byte[] getPassword() {\n         return settings.getPassword();\n     }\n@@ -311,6 +353,8 @@ public class GXDLMSClient {\n      * @param value\n      *            Used password as byte array.\n      */\n+\n+\n     public final void setPassword(final byte[] value) {\n         settings.setPassword(value);\n     }\n@@ -319,6 +363,8 @@ public class GXDLMSClient {\n      * @param value\n      *            Used password as string value.\n      */\n+\n+\n     public final void setPassword(final String value) {\n         settings.setPassword(value.getBytes());\n     }\n@@ -326,6 +372,8 @@ public class GXDLMSClient {\n     /**\n      * @return Logical Name settings.\n      */\n+\n+\n     public final GXDLMSLNSettings getLNSettings() {\n         return settings.getLnSettings();\n     }\n@@ -333,6 +381,8 @@ public class GXDLMSClient {\n     /**\n      * @return Short Name settings.\n      */\n+\n+\n     public final GXDLMSSNSettings getSNSettings() {\n         return settings.getSnSettings();\n     }\n@@ -346,6 +396,8 @@ public class GXDLMSClient {\n      * @see GXDLMSClient#getClientAddress\n      * @return Used authentication.\n      */\n+\n+\n     public final Authentication getAuthentication() {\n         return settings.getAuthentication();\n     }\n@@ -354,6 +406,8 @@ public class GXDLMSClient {\n      * @param value\n      *            Used authentication.\n      */\n+\n+\n     public final void setAuthentication(final Authentication value) {\n         settings.setAuthentication(value);\n     }\n@@ -361,6 +415,8 @@ public class GXDLMSClient {\n     /**\n      * @return Used Priority.\n      */\n+\n+\n     public final Priority getPriority() {\n         return settings.getPriority();\n     }\n@@ -369,6 +425,8 @@ public class GXDLMSClient {\n      * @param value\n      *            Used Priority.\n      */\n+\n+\n     public final void setPriority(final Priority value) {\n         settings.setPriority(value);\n     }\n@@ -376,6 +434,8 @@ public class GXDLMSClient {\n     /**\n      * @return Used service class.\n      */\n+\n+\n     public final ServiceClass getServiceClass() {\n         return settings.getServiceClass();\n     }\n@@ -384,6 +444,8 @@ public class GXDLMSClient {\n      * @param value\n      *            Used service class.\n      */\n+\n+\n     public final void setServiceClass(final ServiceClass value) {\n         settings.setServiceClass(value);\n     }\n@@ -391,6 +453,8 @@ public class GXDLMSClient {\n     /**\n      * @return Invoke ID.\n      */\n+\n+\n     public final int getInvokeID() {\n         return settings.getInvokeID();\n     }\n@@ -399,6 +463,8 @@ public class GXDLMSClient {\n      * @param value\n      *            Invoke ID.\n      */\n+\n+\n     public final void setInvokeID(final int value) {\n         settings.setInvokeID(value);\n     }\n@@ -406,6 +472,8 @@ public class GXDLMSClient {\n     /**\n      * @return Interface type.\n      */\n+\n+\n     public final InterfaceType getInterfaceType() {\n         return settings.getInterfaceType();\n     }\n@@ -414,6 +482,8 @@ public class GXDLMSClient {\n      * @param value\n      *            Interface type.\n      */\n+\n+\n     public final void setInterfaceType(final InterfaceType value) {\n         settings.setInterfaceType(value);\n     }\n@@ -421,6 +491,8 @@ public class GXDLMSClient {\n     /**\n      * @return Information from the connection size that server can handle.\n      */\n+\n+\n     public final GXDLMSLimits getLimits() {\n         return settings.getLimits();\n     }\n@@ -441,9 +513,10 @@ public class GXDLMSClient {\n      * @see GXDLMSClient#parseUAResponse\n      * @return SNRM request as byte array.\n      */\n+\n+\n     public final byte[] snrmRequest() {\n         settings.setConnected(false);\n-\n         isAuthenticationRequired = false;\n         settings.setMaxReceivePDUSize(0xFFFF);\n         // SNRM request is not used in network connections.\n@@ -456,26 +529,22 @@ public class GXDLMSClient {\n         data.setUInt8(0); // Length.\n \n         // If custom HDLC parameters are used.\n-        if (!GXDLMSLimits.DEFAULT_MAX_INFO_TX\n-                .equals(this.getLimits().getMaxInfoTX())) {\n+        if (!GXDLMSLimits.DEFAULT_MAX_INFO_TX.equals(this.getLimits().getMaxInfoTX())) {\n             data.setUInt8(HDLCInfo.MAX_INFO_TX);\n             data.setUInt8(GXCommon.getSize(getLimits().getMaxInfoTX()));\n             data.add(getLimits().getMaxInfoTX());\n         }\n-        if (!GXDLMSLimits.DEFAULT_MAX_INFO_RX\n-                .equals(this.getLimits().getMaxInfoRX())) {\n+        if (!GXDLMSLimits.DEFAULT_MAX_INFO_RX.equals(this.getLimits().getMaxInfoRX())) {\n             data.setUInt8(HDLCInfo.MAX_INFO_RX);\n             data.setUInt8(GXCommon.getSize(getLimits().getMaxInfoRX()));\n             data.add(getLimits().getMaxInfoRX());\n         }\n-        if (!GXDLMSLimits.DEFAULT_WINDOWS_SIZE_TX\n-                .equals(this.getLimits().getWindowSizeTX())) {\n+        if (!GXDLMSLimits.DEFAULT_WINDOWS_SIZE_TX.equals(this.getLimits().getWindowSizeTX())) {\n             data.setUInt8(HDLCInfo.WINDOW_SIZE_TX);\n             data.setUInt8(GXCommon.getSize(getLimits().getWindowSizeTX()));\n             data.add(getLimits().getWindowSizeTX());\n         }\n-        if (!GXDLMSLimits.DEFAULT_WINDOWS_SIZE_TX\n-                .equals(this.getLimits().getWindowSizeRX())) {\n+        if (!GXDLMSLimits.DEFAULT_WINDOWS_SIZE_TX.equals(this.getLimits().getWindowSizeRX())) {\n             data.setUInt8(HDLCInfo.WINDOW_SIZE_RX);\n             data.setUInt8(GXCommon.getSize(getLimits().getWindowSizeRX()));\n             data.add(getLimits().getWindowSizeRX());\n@@ -486,8 +555,8 @@ public class GXDLMSClient {\n         } else {\n             data = null;\n         }\n-        return GXDLMS.getHdlcFrame(settings, (byte) Command.SNRM.getValue(),\n-                null);\n+        return GXDLMS.getHdlcFrame(settings,\n+(byte) Command.SNRM.getValue(), null);\n     }\n \n     /**\n@@ -497,6 +566,8 @@ public class GXDLMSClient {\n      *            Received message from the server.\n      * @see GXDLMSClient#snrmRequest\n      */\n+\n+\n     public final void parseUAResponse(final byte[] data) {\n         parseUAResponse(new GXByteBuffer(data));\n     }\n@@ -508,6 +579,8 @@ public class GXDLMSClient {\n      *            Received message from the server.\n      * @see GXDLMSClient#snrmRequest\n      */\n+\n+\n     public final void parseUAResponse(final GXByteBuffer data) {\n         data.getUInt8(); // Skip FromatID\n         data.getUInt8(); // Skip Group ID.\n@@ -527,7 +600,8 @@ public class GXDLMSClient {\n                 val = data.getUInt32();\n                 break;\n             default:\n-                throw new GXDLMSException(\"Invalid Exception.\");\n+                throw new GXDLMSException(\n+                    \"Invalid Exception.\");\n             }\n             switch (id) { // RX / TX are delivered from the partner's point of view => reversed to ours\n             case HDLCInfo.MAX_INFO_RX:\n@@ -543,7 +617,8 @@ public class GXDLMSClient {\n                 getLimits().setWindowSizeRX(val);\n                 break;\n             default:\n-                throw new GXDLMSException(\"Invalid UA response.\");\n+                throw new GXDLMSException(\n+                    \"Invalid UA response.\");\n             }\n         }\n     }\n@@ -556,6 +631,8 @@ public class GXDLMSClient {\n      * @return AARQ request as byte array.\n      * @see GXDLMSClient#parseAareResponse\n      */\n+\n+\n     public final byte[][] aarqRequest() {\n         GXByteBuffer buff = new GXByteBuffer(20);\n         settings.resetBlockIndex();\n@@ -563,8 +640,7 @@ public class GXDLMSClient {\n         settings.setStoCChallenge(null);\n         // If authentication or ciphering is used.\n         if (getAuthentication().ordinal() > Authentication.LOW.ordinal()) {\n-            settings.setCtoSChallenge(\n-                    GXSecure.generateChallenge(settings.getAuthentication()));\n+            settings.setCtoSChallenge(GXSecure.generateChallenge(settings.getAuthentication()));\n         } else {\n             settings.setCtoSChallenge(null);\n         }\n@@ -590,19 +666,22 @@ public class GXDLMSClient {\n      * @see GXDLMSClient#getLNSettings\n      * @see GXDLMSClient#getSNSettings\n      */\n+\n+\n     public final void parseAareResponse(final GXByteBuffer reply) {\n         settings.setConnected(true);\n-        isAuthenticationRequired =\n-                GXAPDU.parsePDU(settings, settings.getCipher(),\n-                        reply) == SourceDiagnostic.AUTHENTICATION_REQUIRED;\n+        isAuthenticationRequired = GXAPDU.parsePDU(settings, settings.getCipher(), reply) == SourceDiagnostic.AUTHENTICATION_REQUIRED;\n         if (getDLMSVersion() != 6) {\n-            throw new GXDLMSException(\"Invalid DLMS version number.\");\n+            throw new GXDLMSException(\n+                \"Invalid DLMS version number.\");\n         }\n     }\n \n     /**\n      * @return Is authentication Required.\n      */\n+\n+\n     public final boolean getIsAuthenticationRequired() {\n         return isAuthenticationRequired;\n     }\n@@ -610,10 +689,12 @@ public class GXDLMSClient {\n     /**\n      * @return Get challenge request if HLS authentication is used.\n      */\n+\n+\n     public final byte[][] getApplicationAssociationRequest() {\n-        if (settings.getPassword() == null\n-                || settings.getPassword().length == 0) {\n-            throw new IllegalArgumentException(\"Password is invalid.\");\n+        if (settings.getPassword() == null || settings.getPassword().length == 0) {\n+            throw new IllegalArgumentException(\n+                \"Password is invalid.\");\n         }\n         settings.resetBlockIndex();\n         byte[] pw;\n@@ -626,18 +707,15 @@ public class GXDLMSClient {\n         if (settings.getCipher() != null) {\n             ic = settings.getCipher().getFrameCounter();\n         }\n-        byte[] challenge = GXSecure.secure(settings, settings.getCipher(), ic,\n-                settings.getStoCChallenge(), pw);\n+        byte[] challenge = GXSecure.secure(settings, settings.getCipher(), ic, settings.getStoCChallenge(), pw);\n         GXByteBuffer bb = new GXByteBuffer();\n         bb.setUInt8(DataType.OCTET_STRING.getValue());\n         GXCommon.setObjectCount(challenge.length, bb);\n         bb.set(challenge);\n         if (getUseLogicalNameReferencing()) {\n-            return method(\"0.0.40.0.0.255\", ObjectType.ASSOCIATION_LOGICAL_NAME,\n-                    1, bb.array(), DataType.OCTET_STRING);\n+            return method(\"0.0.40.0.0.255\", ObjectType.ASSOCIATION_LOGICAL_NAME, 1, bb.array(), DataType.OCTET_STRING);\n         }\n-        return method(0xFA00, ObjectType.ASSOCIATION_SHORT_NAME, 8, bb.array(),\n-                DataType.OCTET_STRING);\n+        return method(0xFA00, ObjectType.ASSOCIATION_SHORT_NAME, 8, bb.array(), DataType.OCTET_STRING);\n     }\n \n     /**\n@@ -646,8 +724,9 @@ public class GXDLMSClient {\n      * @param reply\n      *            Received reply from the server.\n      */\n-    public final void\n-            parseApplicationAssociationResponse(final GXByteBuffer reply) {\n+\n+\n+    public final void parseApplicationAssociationResponse(final GXByteBuffer reply) {\n         GXDataInfo info = new GXDataInfo();\n         boolean equals = false;\n         byte[] secret;\n@@ -662,22 +741,19 @@ public class GXDLMSClient {\n             } else {\n                 secret = settings.getPassword();\n             }\n-            byte[] tmp = GXSecure.secure(settings, settings.getCipher(), ic,\n-                    settings.getCtoSChallenge(), secret);\n+            byte[] tmp = GXSecure.secure(settings, settings.getCipher(), ic, settings.getCtoSChallenge(), secret);\n             GXByteBuffer challenge = new GXByteBuffer(tmp);\n             equals = challenge.compare(value);\n             if (!equals) {\n-                LOGGER.info(\"Invalid StoC:\" + GXCommon.toHex(value) + \"-\"\n-                        + GXCommon.toHex(tmp));\n+                LOGGER.info(\"Invalid StoC:\" + GXCommon.toHex(value) + \"-\" + GXCommon.toHex(tmp));\n             }\n         } else {\n             LOGGER.info(\"Server did not accept CtoS.\");\n         }\n-\n         if (!equals) {\n             throw new GXDLMSException(\n-                    \"parseApplicationAssociationResponse failed. \"\n-                            + \" Server to Client do not match.\");\n+                \"parseApplicationAssociationResponse failed. \"\n+                    + \" Server to Client do not match.\");\n         }\n     }\n \n@@ -686,16 +762,17 @@ public class GXDLMSClient {\n      * \n      * @return Disconnected request, as byte array.\n      */\n+\n+\n     public final byte[] disconnectRequest() {\n         // If connection is not established, there is no need to send\n         // DisconnectRequest.\n-        if (settings.getSnSettings() == null\n-                && settings.getLnSettings() == null) {\n+        if (settings.getSnSettings() == null && settings.getLnSettings() == null) {\n             return new byte[0];\n         }\n         if (this.getInterfaceType() == InterfaceType.HDLC) {\n-            return GXDLMS.getHdlcFrame(settings, (byte) Command.DISC.getValue(),\n-                    null);\n+            return GXDLMS.getHdlcFrame(settings,\n+(byte) Command.DISC.getValue(), null);\n         }\n         GXByteBuffer bb = new GXByteBuffer(2);\n         bb.setUInt8(Command.DISCONNECT_REQUEST.getValue());\n@@ -718,13 +795,17 @@ public class GXDLMSClient {\n      *            Array of access rights.\n      * @return Created COSEM object.\n      */\n-    static GXDLMSObject createDLMSObject(final int classID,\n-            final Object version, final int baseName, final Object ln,\n-            final Object accessRights) {\n+\n+\n+    static GXDLMSObject createDLMSObject(final int classID, final Object version, final int baseName, final Object ln, final Object accessRights) {\n         ObjectType type = ObjectType.forValue(classID);\n         GXDLMSObject obj = createObject(type);\n-        updateObjectData(obj, type, version, baseName, (byte[]) ln,\n-                accessRights);\n+        updateObjectData(obj,\n+type,\n+version,\n+baseName,\n+(byte[]) ln,\n+accessRights);\n         return obj;\n     }\n \n@@ -737,13 +818,15 @@ public class GXDLMSClient {\n      *            Only known objects are parsed.\n      * @return Collection of COSEM objects.\n      */\n-    private GXDLMSObjectCollection parseSNObjects(final GXByteBuffer buff,\n-            final boolean onlyKnownObjects) {\n+\n+\n+    private GXDLMSObjectCollection parseSNObjects(final GXByteBuffer buff, final boolean onlyKnownObjects) {\n         // Get array tag.\n         short size = buff.getUInt8();\n         // Check that data is in the array\n         if (size != 0x01) {\n-            throw new GXDLMSException(\"Invalid response.\");\n+            throw new GXDLMSException(\n+                \"Invalid response.\");\n         }\n         GXDLMSObjectCollection items = new GXDLMSObjectCollection(this);\n         long cnt = GXCommon.getObjectCount(buff);\n@@ -758,19 +841,22 @@ public class GXDLMSClient {\n             info.setType(DataType.NONE);\n             Object[] objects = (Object[]) GXCommon.getData(buff, info);\n             if (objects.length != 4) {\n-                throw new GXDLMSException(\"Invalid structure format.\");\n+                throw new GXDLMSException(\n+                    \"Invalid structure format.\");\n             }\n             int classID = ((Number) (objects[1])).intValue() & 0xFFFF;\n             int baseName = ((Number) (objects[0])).intValue() & 0xFFFF;\n             if (baseName > 0) {\n-                GXDLMSObject comp = createDLMSObject(classID, objects[2],\n-                        baseName, objects[3], null);\n-                if (!onlyKnownObjects\n-                        || comp.getClass() != GXDLMSObject.class) {\n+                GXDLMSObject comp = createDLMSObject(classID,\n+                    objects[2],\n+                        baseName,\n+                            objects[3], null);\n+                if (!onlyKnownObjects || comp.getClass() != GXDLMSObject.class) {\n                     items.add(comp);\n                 } else {\n                     System.out.println(String.format(\"Unknown object : %d %d\",\n-                            classID, baseName));\n+classID,\n+baseName));\n                 }\n             }\n         }\n@@ -786,14 +872,12 @@ public class GXDLMSClient {\n      * @param logicalName\n      * @param accessRights\n      */\n-    static void updateObjectData(final GXDLMSObject obj,\n-            final ObjectType objectType, final Object version,\n-            final Object baseName, final byte[] logicalName,\n-            final Object accessRights) {\n+\n+\n+    static void updateObjectData(final GXDLMSObject obj, final ObjectType objectType, final Object version, final Object baseName, final byte[] logicalName, final Object accessRights) {\n         obj.setObjectType(objectType);\n         // Check access rights.\n-        if (accessRights instanceof Object[]\n-                && ((Object[]) accessRights).length == 2) {\n+        if (accessRights instanceof Object[] && ((Object[]) accessRights).length == 2) {\n             // access_rights: access_right\n             Object[] access = (Object[]) accessRights;\n             for (Object attributeAccess : (Object[]) access[0]) {\n@@ -838,10 +922,12 @@ public class GXDLMSClient {\n      *            Only known objects are parsed.\n      * @return Collection of COSEM objects.\n      */\n-    public final GXDLMSObjectCollection parseObjects(final GXByteBuffer data,\n-            final boolean onlyKnownObjects) {\n+\n+\n+    public final GXDLMSObjectCollection parseObjects(final GXByteBuffer data, final boolean onlyKnownObjects) {\n         if (data == null) {\n-            throw new GXDLMSException(\"Invalid parameter.\");\n+            throw new GXDLMSException(\n+                \"Invalid parameter.\");\n         }\n         GXDLMSObjectCollection objects;\n         if (getUseLogicalNameReferencing()) {\n@@ -862,13 +948,15 @@ public class GXDLMSClient {\n      *            Only known objects are parsed.\n      * @return Collection of COSEM objects.\n      */\n-    private GXDLMSObjectCollection parseLNObjects(final GXByteBuffer buff,\n-            final boolean onlyKnownObjects) {\n+\n+\n+    private GXDLMSObjectCollection parseLNObjects(final GXByteBuffer buff, final boolean onlyKnownObjects) {\n         // Get array tag.\n         byte size = buff.getInt8();\n         // Check that data is in the array\n         if (size != 0x01) {\n-            throw new GXDLMSException(\"Invalid response.\");\n+            throw new GXDLMSException(\n+                \"Invalid response.\");\n         }\n         GXDLMSObjectCollection items = new GXDLMSObjectCollection(this);\n         GXDataInfo info = new GXDataInfo();\n@@ -884,19 +972,16 @@ public class GXDLMSClient {\n             info.setCount(0);\n             Object[] objects = (Object[]) GXCommon.getData(buff, info);\n             if (objects.length != 4) {\n-                throw new GXDLMSException(\"Invalid structure format.\");\n+                throw new GXDLMSException(\n+                    \"Invalid structure format.\");\n             }\n             int classID = ((Number) (objects[0])).intValue() & 0xFFFF;\n             if (classID > 0) {\n-                GXDLMSObject comp = createDLMSObject(classID, objects[1], 0,\n-                        objects[2], objects[3]);\n-                if (!onlyKnownObjects\n-                        || comp.getClass() != GXDLMSObject.class) {\n+                GXDLMSObject comp = createDLMSObject(classID, objects[1], 0, objects[2], objects[3]);\n+                if (!onlyKnownObjects || comp.getClass() != GXDLMSObject.class) {\n                     items.add(comp);\n                 } else {\n-                    System.out.println(String.format(\"Unknown object : %d %s\",\n-                            classID,\n-                            GXDLMSObject.toLogicalName((byte[]) objects[2])));\n+                    System.out.println(String.format(\"Unknown object : %d %s\", classID, GXDLMSObject.toLogicalName((byte[]) objects[2])));\n                 }\n             }\n         }\n@@ -906,8 +991,9 @@ public class GXDLMSClient {\n     /*\n      * Get Value from byte array received from the meter.\n      */\n-    public final Object updateValue(final GXDLMSObject target,\n-            final int attributeIndex, final Object value) {\n+\n+\n+    public final Object updateValue(final GXDLMSObject target, final int attributeIndex, final Object value) {\n         Object val = value;\n         if (val instanceof byte[]) {\n             DataType type = target.getUIDataType(attributeIndex);\n@@ -919,8 +1005,7 @@ public class GXDLMSClient {\n                 val = changeType((byte[]) value, type);\n             }\n         }\n-        ValueEventArgs e =\n-                new ValueEventArgs(settings, target, attributeIndex, 0, null);\n+        ValueEventArgs e = new ValueEventArgs(settings, target, attributeIndex, 0, null);\n         e.setValue(val);\n         target.setValue(settings, e);\n         return target.getValues()[attributeIndex - 1];\n@@ -933,6 +1018,8 @@ public class GXDLMSClient {\n      *            Byte array received from the meter.\n      * @return Received data.\n      */\n+\n+\n     public final Object getValue(final GXByteBuffer data) {\n         GXDataInfo info = new GXDataInfo();\n         return GXCommon.getData(data, info);\n@@ -946,17 +1033,16 @@ public class GXDLMSClient {\n      * @param data\n      *            Received reply from the meter.\n      */\n-    public final void updateValues(\n-            final List<Entry<GXDLMSObject, Integer>> list,\n-            final GXByteBuffer data) {\n+\n+\n+    public final void updateValues(final List<Entry<GXDLMSObject, Integer>> list, final GXByteBuffer data) {\n         Object value;\n         GXDataInfo info = new GXDataInfo();\n         for (Entry<GXDLMSObject, Integer> it : list) {\n             int ret = data.getUInt8();\n             if (ret == 0) {\n                 value = GXCommon.getData(data, info);\n-                ValueEventArgs e = new ValueEventArgs(settings, it.getKey(),\n-                        it.getValue(), 0, null);\n+                ValueEventArgs e = new ValueEventArgs(settings, it.getKey(), it.getValue(), 0, null);\n                 e.setValue(value);\n                 it.getKey().setValue(settings, e);\n                 info.clear();\n@@ -974,8 +1060,9 @@ public class GXDLMSClient {\n      * @param reply\n      *            Received reply from the meter.\n      */\n-    public final void updateValues(\n-            final List<Entry<GXDLMSObject, Integer>> list, final byte[] reply) {\n+\n+\n+    public final void updateValues(final List<Entry<GXDLMSObject, Integer>> list, final byte[] reply) {\n         updateValues(list, new GXByteBuffer(reply));\n     }\n \n@@ -988,6 +1075,8 @@ public class GXDLMSClient {\n      *            Wanted type.\n      * @return Value changed by type.\n      */\n+\n+\n     public static Object changeType(final byte[] value, final DataType type) {\n         if (value == null) {\n             return null;\n@@ -995,8 +1084,7 @@ public class GXDLMSClient {\n         if (type == DataType.NONE) {\n             return GXCommon.toHex(value);\n         }\n-        if (value.length == 0\n-                && (type == DataType.STRING || type == DataType.OCTET_STRING)) {\n+        if (value.length == 0 && (type == DataType.STRING || type == DataType.OCTET_STRING)) {\n             return \"\";\n         }\n         GXDataInfo info = new GXDataInfo();\n@@ -1031,6 +1119,8 @@ public class GXDLMSClient {\n      * \n      * @return Read request, as byte array.\n      */\n+\n+\n     public final byte[] getObjectsRequest() {\n         Object name;\n         settings.resetBlockIndex();\n@@ -1039,7 +1129,8 @@ public class GXDLMSClient {\n         } else {\n             name = (short) 0xFA00;\n         }\n-        return read(name, ObjectType.ASSOCIATION_LOGICAL_NAME, 2)[0];\n+        return read(name,\n+            ObjectType.ASSOCIATION_LOGICAL_NAME, 2)[0];\n     }\n \n     /**\n@@ -1055,9 +1146,16 @@ public class GXDLMSClient {\n      *            Data type.\n      * @return DLMS action message.\n      */\n-    public final byte[][] method(final GXDLMSObject item, final int index,\n-            final Object data, final DataType type) {\n-        return method(item.getName(), item.getObjectType(), index, data, type);\n+\n+\n+    public final byte[][] method(final GXDLMSObject item,\n+           final int index,\n+           final Object data, final DataType type) {\n+        return method(item.getName(),\n+            item.getObjectType(),\n+                index,\n+                    data,\n+                        type);\n     }\n \n     /**\n@@ -1075,11 +1173,12 @@ public class GXDLMSClient {\n      *            Data type.\n      * @return DLMS action message.\n      */\n-    public final byte[][] method(final Object name, final ObjectType objectType,\n-            final int methodIndex, final Object value,\n-            final DataType dataType) {\n+\n+\n+    public final byte[][] method(final Object name, final ObjectType objectType, final int methodIndex, final Object value, final DataType dataType) {\n         if (name == null || methodIndex < 1) {\n-            throw new IllegalArgumentException(\"Invalid parameter\");\n+            throw new IllegalArgumentException(\n+                \"Invalid parameter\");\n         }\n         settings.resetBlockIndex();\n         int index = methodIndex;\n@@ -1088,7 +1187,7 @@ public class GXDLMSClient {\n             type = GXCommon.getValueType(value);\n             if (type == DataType.NONE) {\n                 throw new GXDLMSException(\n-                        \"Invalid parameter. In java value type must give.\");\n+                    \"Invalid parameter. In java value type must give.\");\n             }\n         }\n         GXByteBuffer bb = new GXByteBuffer();\n@@ -1100,7 +1199,8 @@ public class GXDLMSClient {\n             // Add LN\n             List<String> items = GXCommon.split((String) name, '.');\n             if (items.size() != 6) {\n-                throw new IllegalArgumentException(\"Invalid Logical Name.\");\n+                throw new IllegalArgumentException(\n+                    \"Invalid Logical Name.\");\n             }\n             for (String it2 : items) {\n                 bb.setUInt8(Integer.valueOf(it2).byteValue());\n@@ -1117,7 +1217,8 @@ public class GXDLMSClient {\n             int[] data = new int[1], count = new int[1];\n             GXDLMS.getActionInfo(objectType, data, count);\n             if (index > count[0]) {\n-                throw new IllegalArgumentException(\"methodIndex\");\n+                throw new IllegalArgumentException(\n+                    \"methodIndex\");\n             }\n             int sn = GXCommon.intValue(name);\n             index = (data[0] + (index - 1) * 0x8);\n@@ -1153,11 +1254,17 @@ public class GXDLMSClient {\n      *            Attribute index.\n      * @return Generated write message(s).\n      */\n+\n+\n     public final byte[][] write(final GXDLMSObject item, final int index) {\n         ValueEventArgs e = new ValueEventArgs(settings, item, index, 0, null);\n         Object value = item.getValue(settings, e);\n         DataType type = item.getDataType(index);\n-        return write(item.getName(), value, type, item.getObjectType(), index);\n+        return write(item.getName(),\n+            value,\n+                type,\n+                    item.getObjectType(),\n+                        index);\n     }\n \n     /**\n@@ -1175,11 +1282,12 @@ public class GXDLMSClient {\n      *            Attribute index where data is write.\n      * @return Generated write message(s).\n      */\n-    public final byte[][] write(final Object name, final Object value,\n-            final DataType dataType, final ObjectType objectType,\n-            final int index) {\n+\n+\n+    public final byte[][] write(final Object name, final Object value, final DataType dataType, final ObjectType objectType, final int index) {\n         if (index < 1) {\n-            throw new GXDLMSException(\"Invalid parameter\");\n+            throw new GXDLMSException(\n+                \"Invalid parameter\");\n         }\n         settings.resetBlockIndex();\n         DataType type = dataType;\n@@ -1187,7 +1295,7 @@ public class GXDLMSClient {\n             type = GXCommon.getValueType(value);\n             if (type == DataType.NONE) {\n                 throw new GXDLMSException(\n-                        \"Invalid parameter. In java value type must give.\");\n+                    \"Invalid parameter. In java value type must give.\");\n             }\n         }\n         GXByteBuffer bb = new GXByteBuffer();\n@@ -1199,7 +1307,8 @@ public class GXDLMSClient {\n             // Add LN.\n             List<String> items = GXCommon.split((String) name, '.');\n             if (items.size() != 6) {\n-                throw new IllegalArgumentException(\"Invalid Logical Name.\");\n+                throw new IllegalArgumentException(\n+                    \"Invalid Logical Name.\");\n             }\n             for (String it2 : items) {\n                 bb.setUInt8(Integer.valueOf(it2).byteValue());\n@@ -1232,9 +1341,12 @@ public class GXDLMSClient {\n      *            DLMS objects to write.\n      * @return Write request as byte array.\n      */\n+\n+\n     public final byte[][] writeList(final List<GXWriteItem> list) {\n         if (list == null || list.isEmpty()) {\n-            throw new IllegalArgumentException(\"Invalid parameter.\");\n+            throw new IllegalArgumentException(\n+                \"Invalid parameter.\");\n         }\n         Object value;\n         Command cmd;\n@@ -1247,10 +1359,10 @@ public class GXDLMSClient {\n             for (GXWriteItem it : list) {\n                 // CI.\n                 bb.setUInt16(it.getTarget().getObjectType().getValue());\n-                List<String> items =\n-                        GXCommon.split(it.getTarget().getLogicalName(), '.');\n+                List<String> items = GXCommon.split(it.getTarget().getLogicalName(), '.');\n                 if (items.size() != 6) {\n-                    throw new IllegalArgumentException(\"Invalid Logical Name.\");\n+                    throw new IllegalArgumentException(\n+                        \"Invalid Logical Name.\");\n                 }\n                 for (String it2 : items) {\n                     bb.setUInt8(Integer.valueOf(it2).byteValue());\n@@ -1275,8 +1387,7 @@ public class GXDLMSClient {\n         // Write values.\n         bb.setUInt8(list.size());\n         for (GXWriteItem it : list) {\n-            ValueEventArgs e = new ValueEventArgs(settings, it.getTarget(),\n-                    it.getIndex(), it.getSelector(), it.getParameters());\n+            ValueEventArgs e = new ValueEventArgs(settings, it.getTarget(), it.getIndex(), it.getSelector(), it.getParameters());\n             value = it.getTarget().getValue(settings, e);\n             if ((value instanceof byte[])) {\n                 bb.set((byte[]) value);\n@@ -1285,7 +1396,8 @@ public class GXDLMSClient {\n                 if (type == DataType.NONE && value != null) {\n                     type = GXCommon.getValueType(value);\n                     if (type == DataType.NONE) {\n-                        throw new GXDLMSException(\"Invalid parameter. \"\n+                        throw new GXDLMSException(\n+                            \"Invalid parameter. \"\n                                 + \" In java value type must give.\");\n                     }\n                 }\n@@ -1306,8 +1418,9 @@ public class GXDLMSClient {\n      *            Attribute index of the object.\n      * @return Generated read message(s).\n      */\n-    public final byte[][] read(final Object name, final ObjectType objectType,\n-            final int attributeOrdinal) {\n+\n+\n+    public final byte[][] read(final Object name, final ObjectType objectType, final int attributeOrdinal) {\n         return read(name, objectType, attributeOrdinal, null);\n     }\n \n@@ -1324,10 +1437,12 @@ public class GXDLMSClient {\n      *            Read data parameter.\n      * @return Generated read message(s).\n      */\n-    private byte[][] read(final Object name, final ObjectType objectType,\n-            final int attributeOrdinal, final GXByteBuffer data) {\n+\n+\n+    private byte[][] read(final Object name, final ObjectType objectType, final int attributeOrdinal, final GXByteBuffer data) {\n         if ((attributeOrdinal < 1)) {\n-            throw new IllegalArgumentException(\"Invalid parameter\");\n+            throw new IllegalArgumentException(\n+                \"Invalid parameter\");\n         }\n         Command cmd;\n         GXByteBuffer bb = new GXByteBuffer();\n@@ -1339,7 +1454,8 @@ public class GXDLMSClient {\n             // Add LN\n             List<String> items = GXCommon.split((String) name, '.');\n             if (items.size() != 6) {\n-                throw new IllegalArgumentException(\"Invalid Logical Name.\");\n+                throw new IllegalArgumentException(\n+                    \"Invalid Logical Name.\");\n             }\n             for (String it2 : items) {\n                 bb.setUInt8(Integer.valueOf(it2).byteValue());\n@@ -1385,9 +1501,12 @@ public class GXDLMSClient {\n      *            Read attribute index.\n      * @return Read request as byte array.\n      */\n-    public final byte[][] read(final GXDLMSObject item,\n-            final int attributeOrdinal) {\n-        return read(item.getName(), item.getObjectType(), attributeOrdinal);\n+\n+\n+    public final byte[][] read(final GXDLMSObject item, final int attributeOrdinal) {\n+        return read(item.getName(),\n+            item.getObjectType(),\n+                attributeOrdinal);\n     }\n \n     /**\n@@ -1397,10 +1516,12 @@ public class GXDLMSClient {\n      *            DLMS objects to read.\n      * @return Read request as byte array.\n      */\n-    public final byte[][]\n-            readList(final List<Entry<GXDLMSObject, Integer>> list) {\n+\n+\n+    public final byte[][] readList(final List<Entry<GXDLMSObject, Integer>> list) {\n         if (list == null || list.isEmpty()) {\n-            throw new IllegalArgumentException(\"Invalid parameter.\");\n+            throw new IllegalArgumentException(\n+                \"Invalid parameter.\");\n         }\n         Command cmd;\n         List<byte[]> messages = new ArrayList<byte[]>();\n@@ -1423,10 +1544,10 @@ public class GXDLMSClient {\n             for (Entry<GXDLMSObject, Integer> it : list) {\n                 // CI.\n                 bb.setUInt16(it.getKey().getObjectType().getValue());\n-                List<String> items =\n-                        GXCommon.split(it.getKey().getLogicalName(), '.');\n+                List<String> items = GXCommon.split(it.getKey().getLogicalName(), '.');\n                 if (items.size() != 6) {\n-                    throw new IllegalArgumentException(\"Invalid Logical Name.\");\n+                    throw new IllegalArgumentException(\n+                        \"Invalid Logical Name.\");\n                 }\n                 for (String it2 : items) {\n                     bb.setUInt8(Integer.valueOf(it2).byteValue());\n@@ -1435,11 +1556,9 @@ public class GXDLMSClient {\n                 bb.setUInt8(it.getValue());\n                 // Attribute selector is not used.\n                 bb.setUInt8(0);\n-\n                 ++pos;\n                 if (pos % count == 0 && list.size() != pos) {\n-                    messages.addAll(Arrays.asList(\n-                            GXDLMS.getMessages(settings, cmd, 3, bb, null)));\n+                    messages.addAll(Arrays.asList(GXDLMS.getMessages(settings, cmd, 3, bb, null)));\n                     bb.clear();\n                     if (list.size() - pos < count) {\n                         GXCommon.setObjectCount(list.size() - pos, bb);\n@@ -1460,9 +1579,7 @@ public class GXDLMSClient {\n                 bb.setUInt16(sn);\n             }\n         }\n-\n-        messages.addAll(\n-                Arrays.asList(GXDLMS.getMessages(settings, cmd, 3, bb, null)));\n+        messages.addAll(Arrays.asList(GXDLMS.getMessages(settings, cmd, 3, bb, null)));\n         return messages.toArray(new byte[0][0]);\n     }\n \n@@ -1472,12 +1589,15 @@ public class GXDLMSClient {\n      * \n      * @return Returns Keep alive message, as byte array.\n      */\n+\n+\n     public final byte[] keepAlive() {\n         // There is no need for keep alive in IEC 62056-47.\n         if (this.getInterfaceType() == InterfaceType.WRAPPER) {\n             return new byte[0];\n         }\n-        return GXDLMS.getHdlcFrame(settings, settings.getReceiverReady(), null);\n+        return GXDLMS.getHdlcFrame(settings,\n+settings.getReceiverReady(), null);\n     }\n \n     /**\n@@ -1491,8 +1611,9 @@ public class GXDLMSClient {\n      *            Rows count to read.\n      * @return Read message as byte array.\n      */\n-    public final byte[][] readRowsByEntry(final GXDLMSProfileGeneric pg,\n-            final int index, final int count) {\n+\n+\n+    public final byte[][] readRowsByEntry(final GXDLMSProfileGeneric pg, final int index, final int count) {\n         GXByteBuffer buff = new GXByteBuffer(19);\n         // Add AccessSelector value\n         buff.setUInt8(0x02);\n@@ -1511,7 +1632,9 @@ public class GXDLMSClient {\n             GXCommon.setData(buff, DataType.UINT16, 0);\n         }\n         GXCommon.setData(buff, DataType.UINT16, 0);\n-        return read(pg.getName(), ObjectType.PROFILE_GENERIC, 2, buff);\n+        return read(pg.getName(),\n+            ObjectType.PROFILE_GENERIC, 2,\n+                buff);\n     }\n \n     /**\n@@ -1526,8 +1649,10 @@ public class GXDLMSClient {\n      *            End time.\n      * @return Generated read message.\n      */\n+\n+\n     public final byte[][] readRowsByRange(final GXDLMSProfileGeneric pg,\n-            final java.util.Date start, final java.util.Date end) {\n+           final java.util.Date start, final java.util.Date end) {\n         return readByRange(pg, start, end);\n     }\n \n@@ -1543,8 +1668,9 @@ public class GXDLMSClient {\n      *            End time.\n      * @return Generated read message.\n      */\n-    public final byte[][] readRowsByRange(final GXDLMSProfileGeneric pg,\n-            final Calendar start, final Calendar end) {\n+\n+\n+    public final byte[][] readRowsByRange(final GXDLMSProfileGeneric pg, final Calendar start, final Calendar end) {\n         return readByRange(pg, start, end);\n     }\n \n@@ -1560,8 +1686,9 @@ public class GXDLMSClient {\n      *            End time.\n      * @return Generated read message.\n      */\n-    private byte[][] readByRange(final GXDLMSProfileGeneric pg,\n-            final Object start, final Object end) {\n+\n+\n+    private byte[][] readByRange(final GXDLMSProfileGeneric pg, final Object start, final Object end) {\n         settings.resetBlockIndex();\n         GXDLMSObject sort = pg.getSortObject();\n         if (sort == null && pg.getCaptureObjects().size() != 0) {\n@@ -1583,10 +1710,13 @@ public class GXDLMSClient {\n         // Add item count\n         buff.setUInt8(0x04);\n         // CI\n-        GXCommon.setData(buff, DataType.UINT16,\n+        GXCommon.setData(buff,\n+                DataType.UINT16,\n                 sort.getObjectType().getValue());\n         // LN\n-        GXCommon.setData(buff, DataType.OCTET_STRING, sort.getLogicalName());\n+        GXCommon.setData(buff,\n+                DataType.OCTET_STRING,\n+                sort.getLogicalName());\n         // Add attribute index.\n         GXCommon.setData(buff, DataType.INT8, 2);\n         // Add version\n@@ -1597,7 +1727,9 @@ public class GXDLMSClient {\n         buff.setUInt8(0x01);\n         // Add item count\n         buff.setUInt8(0x00);\n-        return read(pg.getName(), ObjectType.PROFILE_GENERIC, 2, buff);\n+        return read(pg.getName(),\n+            ObjectType.PROFILE_GENERIC, 2,\n+                buff);\n     }\n \n     /**\n@@ -1607,6 +1739,8 @@ public class GXDLMSClient {\n      *            Object type.\n      * @return Created object.\n      */\n+\n+\n     public static GXDLMSObject createObject(final ObjectType type) {\n         return GXDLMS.createObject(type);\n     }\n@@ -1619,6 +1753,8 @@ public class GXDLMSClient {\n      *            Frame type\n      * @return Acknowledgment message as byte array.\n      */\n+\n+\n     public final byte[] receiverReady(final RequestTypes type) {\n         return GXDLMS.receiverReady(settings, type);\n     }\n@@ -1632,6 +1768,8 @@ public class GXDLMSClient {\n      *            Information from the received data.\n      * @return Is frame complete.\n      */\n+\n+\n     public final boolean getData(final byte[] reply, final GXReplyData data) {\n         return GXDLMS.getData(settings, new GXByteBuffer(reply), data);\n     }\n@@ -1644,8 +1782,9 @@ public class GXDLMSClient {\n      * @param data\n      *            The exported reply information.\n      */\n-    public final void getData(final GXByteBuffer reply,\n-            final GXReplyData data) {\n+\n+\n+    public final void getData(final GXByteBuffer reply, final GXReplyData data) {\n         GXDLMS.getData(settings, reply, data);\n     }\n \n@@ -1658,6 +1797,8 @@ public class GXDLMSClient {\n      *            Meter serial number\n      * @return Server address.\n      */\n+\n+\n     public static int getServerAddress(final int serialNumber) {\n         return getServerAddress(serialNumber, null);\n     }\n@@ -1674,13 +1815,12 @@ public class GXDLMSClient {\n      * @return Server address.\n      */\n \n-    public static int getServerAddress(final int serialNumber,\n-            final String formula) {\n+\n+    public static int getServerAddress(final int serialNumber, final String formula) {\n         // If formula is not given use default formula.\n         // This formula is defined in DLMS specification.\n         if (formula == null || formula.length() == 0) {\n-            return 0x4000 | SerialNumberCounter.count(serialNumber,\n-                    \"SN % 10000 + 1000\");\n+            return 0x4000 | SerialNumberCounter.count(serialNumber, \"SN % 10000 + 1000\");\n         }\n         return 0x4000 | SerialNumberCounter.count(serialNumber, formula);\n     }\n@@ -1694,8 +1834,9 @@ public class GXDLMSClient {\n      *            Server physical address.\n      * @return Server address.\n      */\n-    public static int getServerAddress(final int logicalAddress,\n-            final int physicalAddress) {\n+\n+\n+    public static int getServerAddress(final int logicalAddress, final int physicalAddress) {\n         return getServerAddress(logicalAddress, physicalAddress, 0);\n     }\n \n@@ -1710,8 +1851,9 @@ public class GXDLMSClient {\n      *            Address size in bytes.\n      * @return Server address.\n      */\n-    public static int getServerAddress(final int logicalAddress,\n-            final int physicalAddress, final int addressSize) {\n+\n+\n+    public static int getServerAddress(final int logicalAddress, final int physicalAddress, final int addressSize) {\n         if (addressSize < 4 && physicalAddress < 0x80\n                 && logicalAddress < 0x80) {\n             return logicalAddress << 7 | physicalAddress;\n@@ -1720,6 +1862,6 @@ public class GXDLMSClient {\n             return logicalAddress << 14 | physicalAddress;\n         }\n         throw new IllegalArgumentException(\n-                \"Invalid logical or physical address.\");\n+            \"Invalid logical or physical address.\");\n     }\n }\n\\ No newline at end of file\n",
            "diff_size": 341
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "532",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 103).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "532",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 103).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ],
    "repaired_by": [],
    "not_repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}