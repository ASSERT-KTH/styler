{
    "project_name": "wso2-attic-commons",
    "error_id": "573",
    "information": {
        "errors": [
            {
                "line": "367",
                "severity": "error",
                "message": "Line is longer than 120 characters (found 123).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": "                                     bulkData.getSchemas().toArray(), rootObject);\n            //encode [failOnErrors]\n            SimpleAttribute failOnErrorsAttribute = new SimpleAttribute(SCIMConstants.CommonSchemaConstants.FAIL_ON_ERRORS,\n                                                                        bulkData.getFailOnErrors());\n            this.encodeSimpleAttribute(failOnErrorsAttribute, rootObject);\n",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "367",
                    "severity": "error",
                    "message": "Line is longer than 120 characters (found 123).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/573/JSONEncoder.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler/573/JSONEncoder.java\nindex addf627994e..d539934ae07 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/573/JSONEncoder.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler/573/JSONEncoder.java\n@@ -365,7 +365,7 @@ public class JSONEncoder implements Encoder {\n                                      bulkData.getSchemas().toArray(), rootObject);\n             //encode [failOnErrors]\n             SimpleAttribute failOnErrorsAttribute = new SimpleAttribute(SCIMConstants.CommonSchemaConstants.FAIL_ON_ERRORS,\n-                                                                        bulkData.getFailOnErrors());\n+                    bulkData.getFailOnErrors());\n             this.encodeSimpleAttribute(failOnErrorsAttribute, rootObject);\n \n             //encode user requests\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/573/JSONEncoder.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/intellij/573/JSONEncoder.java\nindex addf627994e..1cff26b50b4 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/573/JSONEncoder.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/intellij/573/JSONEncoder.java\n@@ -1,20 +1,21 @@\n /*\n-*  Copyright (c) 2005-2010, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n-*\n-*  WSO2 Inc. licenses this file to you under the Apache License,\n-*  Version 2.0 (the \"License\"); you may not use this file except\n-*  in compliance with the License.\n-*  You may obtain a copy of the License at\n-*\n-*    http://www.apache.org/licenses/LICENSE-2.0\n-*\n-* Unless required by applicable law or agreed to in writing,\n-* software distributed under the License is distributed on an\n-* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n-* KIND, either express or implied.  See the License for the\n-* specific language governing permissions and limitations\n-* under the License.\n-*/\n+ *  Copyright (c) 2005-2010, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n package org.wso2.charon.core.encoder.json;\n \n import org.json.JSONArray;\n@@ -48,365 +49,365 @@ import java.util.Map;\n  */\n public class JSONEncoder implements Encoder {\n \n-    private String format;\n+  private String format;\n+\n+  public JSONEncoder() {\n+    format = SCIMConstants.JSON;\n+  }\n+\n+  /**\n+   * Encode the given SCIM object.\n+   *\n+   * @param scimObject\n+   * @return the resulting string after encoding.\n+   */\n+  public String encodeSCIMObject(SCIMObject scimObject) throws CharonException {\n+    //root json object containing the encoded SCIM Object.\n+    JSONObject rootObject = new JSONObject();\n+    rootObject = this.getSCIMObjectAsJSONObject(scimObject);\n+    return rootObject.toString();\n+  }\n+\n+  /**\n+   * Make JSON object from given SCIM object.\n+   *\n+   * @param scimObject\n+   * @return the resulting string after encoding.\n+   */\n+  public JSONObject getSCIMObjectAsJSONObject(SCIMObject scimObject) throws CharonException {\n+    //root json object containing the encoded SCIM Object.\n+    JSONObject rootObject = new JSONObject();\n+    try {\n+      //encode schemas\n+      this.encodeArrayOfValues(SCIMConstants.CommonSchemaConstants.SCHEMAS,\n+        (scimObject.getSchemaList()).toArray(), rootObject);\n+      //encode attribute list\n+      Map<String, Attribute> attributes = scimObject.getAttributeList();\n+      if (attributes != null && !attributes.isEmpty()) {\n+        for (Attribute attribute : attributes.values()) {\n+          //using instanceof instead of polymorphic way, in order to make encoder pluggable.\n+          if (attribute instanceof SimpleAttribute) {\n+            encodeSimpleAttribute((SimpleAttribute) attribute, rootObject);\n+\n+          } else if (attribute instanceof ComplexAttribute) {\n+            encodeComplexAttribute((ComplexAttribute) attribute, rootObject);\n+\n+          } else if (attribute instanceof MultiValuedAttribute) {\n+            encodeMultiValuedAttribute((MultiValuedAttribute) attribute, rootObject);\n+          }\n+        }\n+      }\n \n-    public JSONEncoder() {\n-        format = SCIMConstants.JSON;\n+    } catch (JSONException e) {\n+      String errorMessage = \"Error in encoding resource..\";\n+      //TODO:log the error\n+      throw new CharonException(errorMessage);\n     }\n-\n-    /**\n-     * Encode the given SCIM object.\n-     *\n-     * @param scimObject\n-     * @return the resulting string after encoding.\n-     */\n-    public String encodeSCIMObject(SCIMObject scimObject) throws CharonException {\n-        //root json object containing the encoded SCIM Object.\n-        JSONObject rootObject = new JSONObject();\n-        rootObject = this.getSCIMObjectAsJSONObject(scimObject);\n-        return rootObject.toString();\n+    return rootObject;\n+  }\n+\n+  /**\n+   * Encode the Exception to be sent in the SCIM - response payload.\n+   *\n+   * @param exception\n+   * @return the resulting string after encoding\n+   */\n+  public String encodeSCIMException(AbstractCharonException exception) {\n+    //outer most json object\n+    JSONObject rootErrorObject = new JSONObject();\n+    //if multiple errors present, we send them in an array.\n+    JSONArray arrayOfErrors = new JSONArray();\n+\n+    //JSON Object containing the error code and error message\n+    JSONObject errorObject = new JSONObject();\n+    try {\n+      //construct error object with details in the exception\n+      errorObject.put(ResponseCodeConstants.DESCRIPTION, exception.getDescription());\n+      errorObject.put(ResponseCodeConstants.CODE, String.valueOf(exception.getCode()));\n+      //TODO:for the moment it is expected that an exception only contains one error.\n+      arrayOfErrors.put(errorObject);\n+      //construct the full json obj.\n+      rootErrorObject.put(ResponseCodeConstants.ERRORS, arrayOfErrors);\n+\n+    } catch (JSONException e) {\n+      //usually errors occur rarely when encoding exceptions. and no need to pass them to clients.\n+      //sufficient to log them in server side back end.\n+      //TODO:log the error\n     }\n-\n-    /**\n-     * Make JSON object from given SCIM object.\n-     *\n-     * @param scimObject\n-     * @return the resulting string after encoding.\n-     */\n-    public JSONObject getSCIMObjectAsJSONObject(SCIMObject scimObject) throws CharonException {\n-        //root json object containing the encoded SCIM Object.\n-        JSONObject rootObject = new JSONObject();\n-        try {\n-            //encode schemas\n-            this.encodeArrayOfValues(SCIMConstants.CommonSchemaConstants.SCHEMAS,\n-                                     (scimObject.getSchemaList()).toArray(), rootObject);\n-            //encode attribute list\n-            Map<String, Attribute> attributes = scimObject.getAttributeList();\n-            if (attributes != null && !attributes.isEmpty()) {\n-                for (Attribute attribute : attributes.values()) {\n-                    //using instanceof instead of polymorphic way, in order to make encoder pluggable.\n-                    if (attribute instanceof SimpleAttribute) {\n-                        encodeSimpleAttribute((SimpleAttribute) attribute, rootObject);\n-\n-                    } else if (attribute instanceof ComplexAttribute) {\n-                        encodeComplexAttribute((ComplexAttribute) attribute, rootObject);\n-\n-                    } else if (attribute instanceof MultiValuedAttribute) {\n-                        encodeMultiValuedAttribute((MultiValuedAttribute) attribute, rootObject);\n-                    }\n-                }\n-            }\n-\n-        } catch (JSONException e) {\n-            String errorMessage = \"Error in encoding resource..\";\n-            //TODO:log the error\n-            throw new CharonException(errorMessage);\n-        }\n-        return rootObject;\n+    return rootErrorObject.toString();\n+\n+  }\n+\n+  /**\n+   * Obtain the format that the particular encoder supports. This can be initialized in the constructor.\n+   *\n+   * @return\n+   */\n+  @Override\n+  public String getFormat() {\n+    return format;\n+  }\n+\n+  public void encodeArrayOfValues(String arrayName, Object[] arrayValues,\n+                                  JSONObject rootObject) throws JSONException {\n+    JSONArray jsonArray = new JSONArray();\n+    for (Object arrayValue : arrayValues) {\n+      jsonArray.put(arrayValue);\n     }\n-\n-    /**\n-     * Encode the Exception to be sent in the SCIM - response payload.\n-     *\n-     * @param exception\n-     * @return the resulting string after encoding\n-     */\n-    public String encodeSCIMException(AbstractCharonException exception) {\n-        //outer most json object\n-        JSONObject rootErrorObject = new JSONObject();\n-        //if multiple errors present, we send them in an array.\n-        JSONArray arrayOfErrors = new JSONArray();\n-\n-        //JSON Object containing the error code and error message\n-        JSONObject errorObject = new JSONObject();\n-        try {\n-            //construct error object with details in the exception\n-            errorObject.put(ResponseCodeConstants.DESCRIPTION, exception.getDescription());\n-            errorObject.put(ResponseCodeConstants.CODE, String.valueOf(exception.getCode()));\n-            //TODO:for the moment it is expected that an exception only contains one error.\n-            arrayOfErrors.put(errorObject);\n-            //construct the full json obj.\n-            rootErrorObject.put(ResponseCodeConstants.ERRORS, arrayOfErrors);\n-\n-        } catch (JSONException e) {\n-            //usually errors occur rarely when encoding exceptions. and no need to pass them to clients.\n-            //sufficient to log them in server side back end.\n-            //TODO:log the error\n-        }\n-        return rootErrorObject.toString();\n-\n+    rootObject.put(arrayName, jsonArray);\n+  }\n+\n+  /**\n+   * Encode the simple attribute and include it in root json object to be returned.\n+   *\n+   * @param attribute\n+   * @param rootObject\n+   */\n+  public void encodeSimpleAttribute(SimpleAttribute attribute, JSONObject rootObject)\n+    throws JSONException {\n+    if (attribute.getValue() != null) {\n+      //if type is DateTime, convert before encoding.\n+      if (attribute.getDataType() != null &&\n+        attribute.getDataType() == SCIMSchemaDefinitions.DataType.DATE_TIME) {\n+        rootObject.put(attribute.getName(),\n+          AttributeUtil.formatDateTime((Date) attribute.getValue()));\n+        return;\n+      }\n+      rootObject.put(attribute.getName(), attribute.getValue());\n     }\n-\n-    /**\n-     * Obtain the format that the particular encoder supports. This can be initialized in the constructor.\n-     *\n-     * @return\n-     */\n-    @Override\n-    public String getFormat() {\n-        return format;\n+  }\n+\n+  /**\n+   * When an attribute value (of a complex or multivalued attribute) becomes a simple attribute itself,\n+   * encode it and put it in json array.\n+   *\n+   * @param attributeValue\n+   * @param jsonArray\n+   * @throws JSONException\n+   */\n+  protected void encodeSimpleAttributeValue(SimpleAttribute attributeValue, JSONArray jsonArray)\n+    throws JSONException {\n+    if (attributeValue.getValue() != null) {\n+      JSONObject attributeValueObject = new JSONObject();\n+      //if type is DateTime, convert before encoding.\n+      if (attributeValue.getDataType() != null &&\n+        attributeValue.getDataType() == SCIMSchemaDefinitions.DataType.DATE_TIME) {\n+        attributeValueObject.put(attributeValue.getName(),\n+          AttributeUtil.formatDateTime((Date) attributeValue.getValue()));\n+        return;\n+      }\n+      attributeValueObject.put(attributeValue.getName(), attributeValue.getValue());\n+      jsonArray.put(attributeValueObject);\n     }\n-\n-    public void encodeArrayOfValues(String arrayName, Object[] arrayValues,\n-                                    JSONObject rootObject) throws JSONException {\n-        JSONArray jsonArray = new JSONArray();\n-        for (Object arrayValue : arrayValues) {\n-            jsonArray.put(arrayValue);\n-        }\n-        rootObject.put(arrayName, jsonArray);\n+  }\n+\n+\n+  /**\n+   * Encode the complex attribute and include it in root json object to be returned.\n+   *\n+   * @param attribute\n+   * @param rootObject\n+   */\n+  public void encodeComplexAttribute(ComplexAttribute attribute, JSONObject rootObject)\n+    throws JSONException {\n+    JSONObject subObject = new JSONObject();\n+    Map<String, Attribute> subAttributes = attribute.getSubAttributes();\n+    for (Attribute attributeValue : subAttributes.values()) {\n+      //using instanceof instead of polymorphic way, in order to make encoder pluggable.\n+      if (attributeValue instanceof SimpleAttribute) {\n+        //most of the time, this if condition is hit according to current SCIM spec.\n+        encodeSimpleAttribute((SimpleAttribute) attributeValue, subObject);\n+\n+      } else if (attributeValue instanceof ComplexAttribute) {\n+        encodeComplexAttribute((ComplexAttribute) attributeValue, subObject);\n+\n+      } else if (attributeValue instanceof MultiValuedAttribute) {\n+        encodeMultiValuedAttribute((MultiValuedAttribute) attributeValue, subObject);\n+      }\n+      rootObject.put(attribute.getName(), subObject);\n     }\n \n-    /**\n-     * Encode the simple attribute and include it in root json object to be returned.\n-     *\n-     * @param attribute\n-     * @param rootObject\n-     */\n-    public void encodeSimpleAttribute(SimpleAttribute attribute, JSONObject rootObject)\n-            throws JSONException {\n-        if (attribute.getValue() != null) {\n-            //if type is DateTime, convert before encoding.\n-            if (attribute.getDataType() != null &&\n-                attribute.getDataType() == SCIMSchemaDefinitions.DataType.DATE_TIME) {\n-                rootObject.put(attribute.getName(),\n-                               AttributeUtil.formatDateTime((Date) attribute.getValue()));\n-                return;\n-            }\n-            rootObject.put(attribute.getName(), attribute.getValue());\n-        }\n+  }\n+\n+  /**\n+   * When an attribute value (of a multivalued attribute) becomes a complex attribute,\n+   * use this method to encode it.\n+   *\n+   * @param attributeValue\n+   * @param jsonArray\n+   */\n+  protected void encodeComplexAttributeValue(ComplexAttribute attributeValue,\n+                                             JSONArray jsonArray) throws JSONException {\n+    JSONObject subObject = new JSONObject();\n+    Map<String, Attribute> subAttributes = attributeValue.getSubAttributes();\n+    for (Attribute value : subAttributes.values()) {\n+      //using instanceof instead of polymorphic way, in order to make encoder pluggable.\n+      if (value instanceof SimpleAttribute) {\n+        encodeSimpleAttribute((SimpleAttribute) value, subObject);\n+\n+      } else if (value instanceof ComplexAttribute) {\n+        encodeComplexAttribute((ComplexAttribute) value, subObject);\n+\n+      } else if (value instanceof MultiValuedAttribute) {\n+        encodeMultiValuedAttribute((MultiValuedAttribute) value, subObject);\n+      }\n     }\n-\n-    /**\n-     * When an attribute value (of a complex or multivalued attribute) becomes a simple attribute itself,\n-     * encode it and put it in json array.\n-     *\n-     * @param attributeValue\n-     * @param jsonArray\n-     * @throws JSONException\n-     */\n-    protected void encodeSimpleAttributeValue(SimpleAttribute attributeValue, JSONArray jsonArray)\n-            throws JSONException {\n-        if (attributeValue.getValue() != null) {\n-            JSONObject attributeValueObject = new JSONObject();\n-            //if type is DateTime, convert before encoding.\n-            if (attributeValue.getDataType() != null &&\n-                attributeValue.getDataType() == SCIMSchemaDefinitions.DataType.DATE_TIME) {\n-                attributeValueObject.put(attributeValue.getName(),\n-                                         AttributeUtil.formatDateTime((Date) attributeValue.getValue()));\n-                return;\n-            }\n-            attributeValueObject.put(attributeValue.getName(), attributeValue.getValue());\n-            jsonArray.put(attributeValueObject);\n-        }\n+    jsonArray.put(subObject);\n+  }\n+\n+  /**\n+   * Encode the simple attribute and include it in root json object to be returned.\n+   *\n+   * @param multiValuedAttribute\n+   * @param jsonObject\n+   */\n+  public void encodeMultiValuedAttribute(MultiValuedAttribute multiValuedAttribute,\n+                                         JSONObject jsonObject) throws JSONException {\n+    JSONArray jsonArray = new JSONArray();\n+    //TODO:what if values are set as list of string values.For the moment it is ok, since only schemas\n+    //attribute has such values and we handle it separately in encoding.\n+    List<String> stringAttributeValues = multiValuedAttribute.getValuesAsStrings();\n+    List<Attribute> attributeValues = multiValuedAttribute.getValuesAsSubAttributes();\n+    //if values are strings,\n+    if (stringAttributeValues != null && !stringAttributeValues.isEmpty()) {\n+      for (String stringAttributeValue : stringAttributeValues) {\n+        jsonArray.put(stringAttributeValue);\n+      }\n     }\n+    if (attributeValues != null && !attributeValues.isEmpty()) {\n+      for (Attribute attributeValue : attributeValues) {\n+        if (attributeValue instanceof SimpleAttribute) {\n+          encodeSimpleAttributeValue((SimpleAttribute) attributeValue, jsonArray);\n \n+        } else if (attributeValue instanceof ComplexAttribute) {\n \n-    /**\n-     * Encode the complex attribute and include it in root json object to be returned.\n-     *\n-     * @param attribute\n-     * @param rootObject\n-     */\n-    public void encodeComplexAttribute(ComplexAttribute attribute, JSONObject rootObject)\n-            throws JSONException {\n-        JSONObject subObject = new JSONObject();\n-        Map<String, Attribute> subAttributes = attribute.getSubAttributes();\n-        for (Attribute attributeValue : subAttributes.values()) {\n-            //using instanceof instead of polymorphic way, in order to make encoder pluggable.\n-            if (attributeValue instanceof SimpleAttribute) {\n-                //most of the time, this if condition is hit according to current SCIM spec.\n-                encodeSimpleAttribute((SimpleAttribute) attributeValue, subObject);\n-\n-            } else if (attributeValue instanceof ComplexAttribute) {\n-                encodeComplexAttribute((ComplexAttribute) attributeValue, subObject);\n-\n-            } else if (attributeValue instanceof MultiValuedAttribute) {\n-                encodeMultiValuedAttribute((MultiValuedAttribute) attributeValue, subObject);\n-            }\n-            rootObject.put(attribute.getName(), subObject);\n+          encodeComplexAttributeValue((ComplexAttribute) attributeValue, jsonArray);\n         }\n-\n-    }\n-\n-    /**\n-     * When an attribute value (of a multivalued attribute) becomes a complex attribute,\n-     * use this method to encode it.\n-     *\n-     * @param attributeValue\n-     * @param jsonArray\n-     */\n-    protected void encodeComplexAttributeValue(ComplexAttribute attributeValue,\n-                                               JSONArray jsonArray) throws JSONException {\n-        JSONObject subObject = new JSONObject();\n-        Map<String, Attribute> subAttributes = attributeValue.getSubAttributes();\n-        for (Attribute value : subAttributes.values()) {\n-            //using instanceof instead of polymorphic way, in order to make encoder pluggable.\n-            if (value instanceof SimpleAttribute) {\n-                encodeSimpleAttribute((SimpleAttribute) value, subObject);\n-\n-            } else if (value instanceof ComplexAttribute) {\n-                encodeComplexAttribute((ComplexAttribute) value, subObject);\n-\n-            } else if (value instanceof MultiValuedAttribute) {\n-                encodeMultiValuedAttribute((MultiValuedAttribute) value, subObject);\n-            }\n-        }\n-        jsonArray.put(subObject);\n+      }\n     }\n-\n-    /**\n-     * Encode the simple attribute and include it in root json object to be returned.\n-     *\n-     * @param multiValuedAttribute\n-     * @param jsonObject\n-     */\n-    public void encodeMultiValuedAttribute(MultiValuedAttribute multiValuedAttribute,\n-                                           JSONObject jsonObject) throws JSONException {\n-        JSONArray jsonArray = new JSONArray();\n-        //TODO:what if values are set as list of string values.For the moment it is ok, since only schemas\n-        //attribute has such values and we handle it separately in encoding.\n-        List<String> stringAttributeValues = multiValuedAttribute.getValuesAsStrings();\n-        List<Attribute> attributeValues = multiValuedAttribute.getValuesAsSubAttributes();\n-        //if values are strings,\n-        if (stringAttributeValues != null && !stringAttributeValues.isEmpty()) {\n-            for (String stringAttributeValue : stringAttributeValues) {\n-                jsonArray.put(stringAttributeValue);\n-            }\n-        }\n-        if (attributeValues != null && !attributeValues.isEmpty()) {\n-            for (Attribute attributeValue : attributeValues) {\n-                if (attributeValue instanceof SimpleAttribute) {\n-                    encodeSimpleAttributeValue((SimpleAttribute) attributeValue, jsonArray);\n-\n-                } else if (attributeValue instanceof ComplexAttribute) {\n-\n-                    encodeComplexAttributeValue((ComplexAttribute) attributeValue, jsonArray);\n-                }\n-            }\n-        }\n-        jsonObject.put(multiValuedAttribute.getName(), jsonArray);\n+    jsonObject.put(multiValuedAttribute.getName(), jsonArray);\n+  }\n+\n+  /**\n+   * Encode given bulkResponseData object and return the encoded string\n+   *\n+   * @param bulkResponseData\n+   * @return\n+   */\n+  public String encodeBulkResponseData(BulkResponseData bulkResponseData) {\n+    String encodedString = \"\";\n+    List<BulkResponseContent> userResponseDataList = bulkResponseData.getUserCreatingResponse();\n+\n+    JSONObject rootObject = new JSONObject();\n+\n+    //encode schemas\n+    try {\n+      //set the [schemas]\n+      this.encodeArrayOfValues(SCIMConstants.CommonSchemaConstants.SCHEMAS,\n+        bulkResponseData.getSchemas().toArray(), rootObject);\n+\n+      //[Operations] - multi value attribute\n+      JSONObject[] operationResponseList = new JSONObject[userResponseDataList.size()];\n+      JSONObject operationObject = new JSONObject();\n+      //user creating response\n+      int i = 0;\n+      for (BulkResponseContent userCreatingResponse : userResponseDataList) {\n+\n+        SCIMResponse scimResponse = userCreatingResponse.getScimResponse();\n+        JSONObject decodedObject = new JSONObject(new JSONTokener(scimResponse.getResponseMessage()));\n+\n+        //*****Split SCIM response******\n+        //get location from meta section\n+        JSONObject meta = decodedObject.optJSONObject(SCIMConstants.CommonSchemaConstants.META);\n+        String location = meta.optString(SCIMConstants.CommonSchemaConstants.LOCATION);\n+        //get method from response\n+        String method = userCreatingResponse.getMethod();\n+        //get bulkID from response\n+        String bulkId = userCreatingResponse.getBulkID();\n+\n+        //create status object\n+        String code = userCreatingResponse.getResponseCode();\n+        JSONObject status = new JSONObject();\n+        status.put(SCIMConstants.CommonSchemaConstants.CODE, code);\n+\n+\n+        operationObject.put(SCIMConstants.CommonSchemaConstants.LOCATION, location);\n+        operationObject.put(SCIMConstants.CommonSchemaConstants.METHOD, location);\n+        operationObject.put(SCIMConstants.CommonSchemaConstants.BULK_ID, bulkId);\n+        operationObject.put(SCIMConstants.CommonSchemaConstants.STATUS, status);\n+\n+        operationResponseList[i] = operationObject;\n+\n+        i++;\n+      }\n+      //TODO: Have to encode the groups response data\n+\n+      //set operations\n+      this.encodeArrayOfValues(SCIMConstants.CommonSchemaConstants.OPERATIONS, operationResponseList, rootObject);\n+\n+      encodedString = rootObject.toString();\n+\n+    } catch (JSONException e) {\n+      e.printStackTrace();\n+      return e.getMessage();\n     }\n \n-    /**\n-     * Encode given bulkResponseData object and return the encoded string\n-     *\n-     * @param bulkResponseData\n-     * @return\n-     */\n-    public String encodeBulkResponseData(BulkResponseData bulkResponseData) {\n-        String encodedString = \"\";\n-        List<BulkResponseContent> userResponseDataList = bulkResponseData.getUserCreatingResponse();\n-\n-        JSONObject rootObject = new JSONObject();\n-\n-        //encode schemas\n-        try {\n-            //set the [schemas]\n-            this.encodeArrayOfValues(SCIMConstants.CommonSchemaConstants.SCHEMAS,\n-                                     bulkResponseData.getSchemas().toArray(), rootObject);\n-\n-            //[Operations] - multi value attribute\n-            JSONObject[] operationResponseList = new JSONObject[userResponseDataList.size()];\n-            JSONObject operationObject = new JSONObject();\n-            //user creating response\n-            int i = 0;\n-            for (BulkResponseContent userCreatingResponse : userResponseDataList) {\n-\n-                SCIMResponse scimResponse = userCreatingResponse.getScimResponse();\n-                JSONObject decodedObject = new JSONObject(new JSONTokener(scimResponse.getResponseMessage()));\n-\n-                //*****Split SCIM response******\n-                //get location from meta section\n-                JSONObject meta = decodedObject.optJSONObject(SCIMConstants.CommonSchemaConstants.META);\n-                String location = meta.optString(SCIMConstants.CommonSchemaConstants.LOCATION);\n-                //get method from response\n-                String method = userCreatingResponse.getMethod();\n-                //get bulkID from response\n-                String bulkId = userCreatingResponse.getBulkID();\n-\n-                //create status object\n-                String code = userCreatingResponse.getResponseCode();\n-                JSONObject status = new JSONObject();\n-                status.put(SCIMConstants.CommonSchemaConstants.CODE, code);\n-\n-\n-                operationObject.put(SCIMConstants.CommonSchemaConstants.LOCATION, location);\n-                operationObject.put(SCIMConstants.CommonSchemaConstants.METHOD, location);\n-                operationObject.put(SCIMConstants.CommonSchemaConstants.BULK_ID, bulkId);\n-                operationObject.put(SCIMConstants.CommonSchemaConstants.STATUS, status);\n-\n-                operationResponseList[i] = operationObject;\n-\n-                i++;\n-            }\n-            //TODO: Have to encode the groups response data\n-\n-            //set operations\n-            this.encodeArrayOfValues(SCIMConstants.CommonSchemaConstants.OPERATIONS, operationResponseList, rootObject);\n-\n-            encodedString = rootObject.toString();\n-\n-        } catch (JSONException e) {\n-            e.printStackTrace();\n-            return e.getMessage();\n-        }\n-\n \n-        return encodedString;\n+    return encodedString;\n+  }\n+\n+  public String encodeBulkData(BulkData bulkData) {\n+    String encodedString = \"\";\n+    //root object\n+    JSONObject rootObject = new JSONObject();\n+    try {\n+      //encode [schema]\n+      this.encodeArrayOfValues(SCIMConstants.CommonSchemaConstants.SCHEMAS,\n+        bulkData.getSchemas().toArray(), rootObject);\n+      //encode [failOnErrors]\n+      SimpleAttribute failOnErrorsAttribute = new SimpleAttribute(SCIMConstants.CommonSchemaConstants.FAIL_ON_ERRORS,\n+        bulkData.getFailOnErrors());\n+      this.encodeSimpleAttribute(failOnErrorsAttribute, rootObject);\n+\n+      //encode user requests\n+      JSONObject[] userRequestList = new JSONObject[bulkData.getUserList().size()];\n+      JSONObject encodedUserRequest;\n+      int i = 0;\n+      for (User user : bulkData.getUserList()) {\n+        encodedUserRequest = this.getSCIMObjectAsJSONObject(user);\n+        JSONObject userOperation = new JSONObject();\n+\n+        //set [bulkId]\n+        userOperation.put(SCIMConstants.CommonSchemaConstants.BULK_ID, user.getBulkID());\n+        //set [path]\n+        userOperation.put(SCIMConstants.CommonSchemaConstants.PATH, user.getPath());\n+        //set [method]\n+        userOperation.put(SCIMConstants.CommonSchemaConstants.METHOD, user.getMethod());\n+        //set [data]\n+        SimpleAttribute dataAttribute = new SimpleAttribute(SCIMConstants.CommonSchemaConstants.DATA,\n+          encodedUserRequest);\n+        this.encodeSimpleAttribute(dataAttribute, userOperation);\n+\n+\n+        userRequestList[i] = userOperation;\n+\n+        i = i + 1;\n+      }\n+\n+      //set to [Operations]\n+      this.encodeArrayOfValues(SCIMConstants.CommonSchemaConstants.OPERATIONS, userRequestList, rootObject);\n+\n+      encodedString = rootObject.toString();\n+\n+\n+    } catch (JSONException e) {\n+      e.printStackTrace();\n+      return e.getMessage();\n+    } catch (CharonException e) {\n+      e.printStackTrace();\n+      return e.getMessage();\n     }\n \n-    public String encodeBulkData(BulkData bulkData) {\n-        String encodedString = \"\";\n-        //root object\n-        JSONObject rootObject = new JSONObject();\n-        try {\n-            //encode [schema]\n-            this.encodeArrayOfValues(SCIMConstants.CommonSchemaConstants.SCHEMAS,\n-                                     bulkData.getSchemas().toArray(), rootObject);\n-            //encode [failOnErrors]\n-            SimpleAttribute failOnErrorsAttribute = new SimpleAttribute(SCIMConstants.CommonSchemaConstants.FAIL_ON_ERRORS,\n-                                                                        bulkData.getFailOnErrors());\n-            this.encodeSimpleAttribute(failOnErrorsAttribute, rootObject);\n-\n-            //encode user requests\n-            JSONObject[] userRequestList = new JSONObject[bulkData.getUserList().size()];\n-            JSONObject encodedUserRequest;\n-            int i = 0;\n-            for (User user : bulkData.getUserList()) {\n-                encodedUserRequest = this.getSCIMObjectAsJSONObject(user);\n-                JSONObject userOperation = new JSONObject();\n-\n-                //set [bulkId]\n-                userOperation.put(SCIMConstants.CommonSchemaConstants.BULK_ID, user.getBulkID());\n-                //set [path]\n-                userOperation.put(SCIMConstants.CommonSchemaConstants.PATH, user.getPath());\n-                //set [method]\n-                userOperation.put(SCIMConstants.CommonSchemaConstants.METHOD, user.getMethod());\n-                //set [data]\n-                SimpleAttribute dataAttribute = new SimpleAttribute(SCIMConstants.CommonSchemaConstants.DATA,\n-                                                                    encodedUserRequest);\n-                this.encodeSimpleAttribute(dataAttribute, userOperation);\n-\n-\n-                userRequestList[i] = userOperation;\n-\n-                i = i + 1;\n-            }\n-\n-            //set to [Operations]\n-            this.encodeArrayOfValues(SCIMConstants.CommonSchemaConstants.OPERATIONS, userRequestList, rootObject);\n-\n-            encodedString = rootObject.toString();\n-\n-\n-        } catch (JSONException e) {\n-            e.printStackTrace();\n-            return e.getMessage();\n-        } catch (CharonException e) {\n-            e.printStackTrace();\n-            return e.getMessage();\n-        }\n-\n-        return encodedString;\n-    }\n+    return encodedString;\n+  }\n }\n",
            "diff_size": 554
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "150",
                    "severity": "error",
                    "message": "Line is longer than 120 characters (found 121).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "236",
                    "severity": "error",
                    "message": "Line is longer than 120 characters (found 123).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "301",
                    "severity": "error",
                    "message": "Line is longer than 120 characters (found 135).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "353",
                    "severity": "error",
                    "message": "Line is longer than 120 characters (found 127).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "356",
                    "severity": "error",
                    "message": "Line is longer than 120 characters (found 152).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "374",
                    "severity": "error",
                    "message": "Line is longer than 120 characters (found 130).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/573/JSONEncoder.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/naturalize/573/JSONEncoder.java\nindex addf627994e..61fa319443c 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/573/JSONEncoder.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/naturalize/573/JSONEncoder.java\n@@ -147,9 +147,8 @@ public class JSONEncoder implements Encoder {\n         return format;\n     }\n \n-    public void encodeArrayOfValues(String arrayName, Object[] arrayValues,\n-                                    JSONObject rootObject) throws JSONException {\n-        JSONArray jsonArray = new JSONArray();\n+    public void encodeArrayOfValues(String arrayName, Object[] arrayValues, JSONObject rootObject) throws JSONException {\n+JSONArray jsonArray = new JSONArray();\n         for (Object arrayValue : arrayValues) {\n             jsonArray.put(arrayValue);\n         }\n@@ -168,9 +167,8 @@ public class JSONEncoder implements Encoder {\n             //if type is DateTime, convert before encoding.\n             if (attribute.getDataType() != null &&\n                 attribute.getDataType() == SCIMSchemaDefinitions.DataType.DATE_TIME) {\n-                rootObject.put(attribute.getName(),\n-                               AttributeUtil.formatDateTime((Date) attribute.getValue()));\n-                return;\n+                rootObject.put(attribute.getName(), AttributeUtil.formatDateTime((Date) attribute.getValue()));\n+return;\n             }\n             rootObject.put(attribute.getName(), attribute.getValue());\n         }\n@@ -235,8 +233,7 @@ public class JSONEncoder implements Encoder {\n      * @param attributeValue\n      * @param jsonArray\n      */\n-    protected void encodeComplexAttributeValue(ComplexAttribute attributeValue,\n-                                               JSONArray jsonArray) throws JSONException {\n+    protected void encodeComplexAttributeValue(ComplexAttribute attributeValue, JSONArray jsonArray) throws JSONException {\n         JSONObject subObject = new JSONObject();\n         Map<String, Attribute> subAttributes = attributeValue.getSubAttributes();\n         for (Attribute value : subAttributes.values()) {\n@@ -279,8 +276,7 @@ public class JSONEncoder implements Encoder {\n                     encodeSimpleAttributeValue((SimpleAttribute) attributeValue, jsonArray);\n \n                 } else if (attributeValue instanceof ComplexAttribute) {\n-\n-                    encodeComplexAttributeValue((ComplexAttribute) attributeValue, jsonArray);\n+    encodeComplexAttributeValue((ComplexAttribute) attributeValue, jsonArray);\n                 }\n             }\n         }\n@@ -302,10 +298,9 @@ public class JSONEncoder implements Encoder {\n         //encode schemas\n         try {\n             //set the [schemas]\n-            this.encodeArrayOfValues(SCIMConstants.CommonSchemaConstants.SCHEMAS,\n-                                     bulkResponseData.getSchemas().toArray(), rootObject);\n+            this.encodeArrayOfValues(SCIMConstants.CommonSchemaConstants.SCHEMAS, bulkResponseData.getSchemas().toArray(), rootObject);\n \n-            //[Operations] - multi value attribute\n+//[Operations] - multi value attribute\n             JSONObject[] operationResponseList = new JSONObject[userResponseDataList.size()];\n             JSONObject operationObject = new JSONObject();\n             //user creating response\n@@ -328,16 +323,12 @@ public class JSONEncoder implements Encoder {\n                 String code = userCreatingResponse.getResponseCode();\n                 JSONObject status = new JSONObject();\n                 status.put(SCIMConstants.CommonSchemaConstants.CODE, code);\n-\n-\n-                operationObject.put(SCIMConstants.CommonSchemaConstants.LOCATION, location);\n+operationObject.put(SCIMConstants.CommonSchemaConstants.LOCATION, location);\n                 operationObject.put(SCIMConstants.CommonSchemaConstants.METHOD, location);\n                 operationObject.put(SCIMConstants.CommonSchemaConstants.BULK_ID, bulkId);\n                 operationObject.put(SCIMConstants.CommonSchemaConstants.STATUS, status);\n \n-                operationResponseList[i] = operationObject;\n-\n-                i++;\n+                operationResponseList[i] = operationObject; i++;\n             }\n             //TODO: Have to encode the groups response data\n \n@@ -350,9 +341,7 @@ public class JSONEncoder implements Encoder {\n             e.printStackTrace();\n             return e.getMessage();\n         }\n-\n-\n-        return encodedString;\n+return encodedString;\n     }\n \n     public String encodeBulkData(BulkData bulkData) {\n@@ -361,12 +350,11 @@ public class JSONEncoder implements Encoder {\n         JSONObject rootObject = new JSONObject();\n         try {\n             //encode [schema]\n-            this.encodeArrayOfValues(SCIMConstants.CommonSchemaConstants.SCHEMAS,\n-                                     bulkData.getSchemas().toArray(), rootObject);\n-            //encode [failOnErrors]\n-            SimpleAttribute failOnErrorsAttribute = new SimpleAttribute(SCIMConstants.CommonSchemaConstants.FAIL_ON_ERRORS,\n-                                                                        bulkData.getFailOnErrors());\n-            this.encodeSimpleAttribute(failOnErrorsAttribute, rootObject);\n+            this.encodeArrayOfValues(SCIMConstants.CommonSchemaConstants.SCHEMAS, bulkData.getSchemas().toArray(), rootObject);\n+\n+//encode [failOnErrors]\n+            SimpleAttribute failOnErrorsAttribute = new SimpleAttribute(SCIMConstants.CommonSchemaConstants.FAIL_ON_ERRORS, bulkData.getFailOnErrors());\n+this.encodeSimpleAttribute(failOnErrorsAttribute, rootObject);\n \n             //encode user requests\n             JSONObject[] userRequestList = new JSONObject[bulkData.getUserList().size()];\n@@ -383,12 +371,9 @@ public class JSONEncoder implements Encoder {\n                 //set [method]\n                 userOperation.put(SCIMConstants.CommonSchemaConstants.METHOD, user.getMethod());\n                 //set [data]\n-                SimpleAttribute dataAttribute = new SimpleAttribute(SCIMConstants.CommonSchemaConstants.DATA,\n-                                                                    encodedUserRequest);\n-                this.encodeSimpleAttribute(dataAttribute, userOperation);\n-\n-\n-                userRequestList[i] = userOperation;\n+                SimpleAttribute dataAttribute = new SimpleAttribute(SCIMConstants.CommonSchemaConstants.DATA, encodedUserRequest);\n+this.encodeSimpleAttribute(dataAttribute, userOperation);\n+userRequestList[i] = userOperation;\n \n                 i = i + 1;\n             }\n@@ -397,9 +382,7 @@ public class JSONEncoder implements Encoder {\n             this.encodeArrayOfValues(SCIMConstants.CommonSchemaConstants.OPERATIONS, userRequestList, rootObject);\n \n             encodedString = rootObject.toString();\n-\n-\n-        } catch (JSONException e) {\n+    } catch (JSONException e) {\n             e.printStackTrace();\n             return e.getMessage();\n         } catch (CharonException e) {\n@@ -409,4 +392,4 @@ public class JSONEncoder implements Encoder {\n \n         return encodedString;\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 38
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "367",
                    "severity": "error",
                    "message": "Line is longer than 120 characters (found 123).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/573/JSONEncoder.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler_random/573/JSONEncoder.java\nindex addf627994e..d539934ae07 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/573/JSONEncoder.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler_random/573/JSONEncoder.java\n@@ -365,7 +365,7 @@ public class JSONEncoder implements Encoder {\n                                      bulkData.getSchemas().toArray(), rootObject);\n             //encode [failOnErrors]\n             SimpleAttribute failOnErrorsAttribute = new SimpleAttribute(SCIMConstants.CommonSchemaConstants.FAIL_ON_ERRORS,\n-                                                                        bulkData.getFailOnErrors());\n+                    bulkData.getFailOnErrors());\n             this.encodeSimpleAttribute(failOnErrorsAttribute, rootObject);\n \n             //encode user requests\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "367",
                    "severity": "error",
                    "message": "Line is longer than 120 characters (found 123).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/573/JSONEncoder.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler_three_grams/573/JSONEncoder.java\nindex addf627994e..884cdb7913f 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/573/JSONEncoder.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler_three_grams/573/JSONEncoder.java\n@@ -365,7 +365,7 @@ public class JSONEncoder implements Encoder {\n                                      bulkData.getSchemas().toArray(), rootObject);\n             //encode [failOnErrors]\n             SimpleAttribute failOnErrorsAttribute = new SimpleAttribute(SCIMConstants.CommonSchemaConstants.FAIL_ON_ERRORS,\n-                                                                        bulkData.getFailOnErrors());\n+                bulkData.getFailOnErrors());\n             this.encodeSimpleAttribute(failOnErrorsAttribute, rootObject);\n \n             //encode user requests\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "intellij"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}