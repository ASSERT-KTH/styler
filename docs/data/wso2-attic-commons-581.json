{
    "project_name": "wso2-attic-commons",
    "error_id": "581",
    "information": {
        "errors": [
            {
                "line": "150",
                "severity": "error",
                "message": "Line is longer than 120 characters (found 172).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": "        Node node = source.getExpression();\n        if (node == null) {\n            throw new CompilationException(__msgs.errEmptyExpression(source.getURI(), new QName(source.getElement().getNamespaceURI(), source.getElement().getNodeName())));\n        }\n        if (node.getNodeType() != Node.TEXT_NODE &&\n                node.getNodeType() != Node.ELEMENT_NODE &&",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/581/XQuery10ExpressionCompilerImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler/581/XQuery10ExpressionCompilerImpl.java\nindex 13edbe65754..2bd3b7fb9f0 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/581/XQuery10ExpressionCompilerImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler/581/XQuery10ExpressionCompilerImpl.java\n@@ -147,9 +147,10 @@ public class XQuery10ExpressionCompilerImpl implements ExpressionCompiler {\n         String xqueryStr;\n         Node node = source.getExpression();\n         if (node == null) {\n-            throw new CompilationException(__msgs.errEmptyExpression(source.getURI(), new QName(source.getElement().getNamespaceURI(), source.getElement().getNodeName())));\n-        }\n-        if (node.getNodeType() != Node.TEXT_NODE &&\n+            throw new CompilationException(__msgs.errEmptyExpression(source.getURI(),\n+                                new QName(source.getElement().getNamespaceURI(), source.getElement().getNodeName())));\n+         }\n+         if (node.getNodeType() != Node.TEXT_NODE &&\n                 node.getNodeType() != Node.ELEMENT_NODE &&\n                 node.getNodeType() != Node.CDATA_SECTION_NODE) {\n             throw new CompilationException(__msgs.errUnexpectedNodeTypeForXPath(DOMUtils.domToString(node)));\n",
            "diff_size": 4
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/581/XQuery10ExpressionCompilerImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/intellij/581/XQuery10ExpressionCompilerImpl.java\nindex 13edbe65754..3f632ea6d17 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/581/XQuery10ExpressionCompilerImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/intellij/581/XQuery10ExpressionCompilerImpl.java\n@@ -80,333 +80,338 @@ import org.w3c.dom.NodeList;\n  */\n public class XQuery10ExpressionCompilerImpl implements ExpressionCompiler {\n \n-    protected static final Log __log = LogFactory.getLog(XQuery10ExpressionCompilerImpl.class);\n-\n-    protected String _bpelNS;\n-    protected QName _qnLinkStatus;\n-    protected QName _qnVarProp;\n-    protected QName _qnVarData;\n-    protected QName _qnXslTransform;\n-\n-    protected final XPathMessages __msgs = MessageBundle.getMessages(XPathMessages.class);\n-    protected Map<String, String> _properties = new HashMap<String, String>();\n-    protected CompilerContext _compilerContext;\n-\n-    public XQuery10ExpressionCompilerImpl(String bpelNS) {\n-        _bpelNS = bpelNS;\n-        _qnLinkStatus = new QName(_bpelNS, Constants.EXT_FUNCTION_GETLINKSTATUS);\n-        _qnVarProp = new QName(_bpelNS, Constants.EXT_FUNCTION_GETVARIABLEPROPERTY);\n-        _qnVarData = new QName(_bpelNS, Constants.EXT_FUNCTION_GETVARIABLEDATA);\n-        _qnXslTransform = new QName(_bpelNS, Constants.EXT_FUNCTION_DOXSLTRANSFORM);\n-\n-        _properties.put(\"runtime-class\", \"org.apache.ode.bpel.elang.xquery10.runtime.XQuery10ExpressionRuntime\");\n-        TransformerFactory trsf = new net.sf.saxon.TransformerFactoryImpl();\n-        XslTransformHandler.getInstance().setTransformerFactory(trsf);\n+  protected static final Log __log = LogFactory.getLog(XQuery10ExpressionCompilerImpl.class);\n+\n+  protected String _bpelNS;\n+  protected QName _qnLinkStatus;\n+  protected QName _qnVarProp;\n+  protected QName _qnVarData;\n+  protected QName _qnXslTransform;\n+\n+  protected final XPathMessages __msgs = MessageBundle.getMessages(XPathMessages.class);\n+  protected Map<String, String> _properties = new HashMap<String, String>();\n+  protected CompilerContext _compilerContext;\n+\n+  public XQuery10ExpressionCompilerImpl(String bpelNS) {\n+    _bpelNS = bpelNS;\n+    _qnLinkStatus = new QName(_bpelNS, Constants.EXT_FUNCTION_GETLINKSTATUS);\n+    _qnVarProp = new QName(_bpelNS, Constants.EXT_FUNCTION_GETVARIABLEPROPERTY);\n+    _qnVarData = new QName(_bpelNS, Constants.EXT_FUNCTION_GETVARIABLEDATA);\n+    _qnXslTransform = new QName(_bpelNS, Constants.EXT_FUNCTION_DOXSLTRANSFORM);\n+\n+    _properties.put(\"runtime-class\", \"org.apache.ode.bpel.elang.xquery10.runtime.XQuery10ExpressionRuntime\");\n+    TransformerFactory trsf = new net.sf.saxon.TransformerFactoryImpl();\n+    XslTransformHandler.getInstance().setTransformerFactory(trsf);\n+  }\n+\n+  public void setCompilerContext(CompilerContext compilerContext) {\n+    _compilerContext = compilerContext;\n+    XslCompilationErrorListener xe = new XslCompilationErrorListener(compilerContext);\n+    XslTransformHandler.getInstance().setErrorListener(xe);\n+  }\n+\n+  /**\n+   * @see org.apache.ode.bpel.compiler.api.ExpressionCompiler#compileJoinCondition(java.lang.Object)\n+   */\n+  public OExpression compileJoinCondition(Object source) throws CompilationException {\n+    return _compile((Expression) source, true);\n+  }\n+\n+  /**\n+   * @see org.apache.ode.bpel.compiler.api.ExpressionCompiler#compile(java.lang.Object)\n+   */\n+  public OExpression compile(Object source) throws CompilationException {\n+    return _compile((Expression) source, false);\n+  }\n+\n+  /**\n+   * @see org.apache.ode.bpel.compiler.api.ExpressionCompiler#compileLValue(java.lang.Object)\n+   */\n+  public OLValueExpression compileLValue(Object source) throws CompilationException {\n+    return (OLValueExpression) _compile((Expression) source, false);\n+  }\n+\n+  /**\n+   * @see org.apache.ode.bpel.compiler.api.ExpressionCompiler#compile(java.lang.Object)\n+   */\n+  private OExpression _compile(org.apache.ode.bpel.compiler.bom.Expression xquery, boolean isJoinCondition)\n+    throws CompilationException {\n+    OXQuery10ExpressionBPEL20 oexp = new OXQuery10ExpressionBPEL20(_compilerContext.getOProcess(), _qnVarData,\n+      _qnVarProp, _qnLinkStatus, _qnXslTransform, isJoinCondition);\n+    oexp.namespaceCtx = xquery.getNamespaceContext();\n+    doJaxpCompile(oexp, xquery);\n+    return oexp;\n+  }\n+\n+  private void doJaxpCompile(OXQuery10ExpressionBPEL20 out, Expression source) throws CompilationException {\n+    String xqueryStr;\n+    Node node = source.getExpression();\n+    if (node == null) {\n+      throw new CompilationException(__msgs.errEmptyExpression(source.getURI(),\n+        new QName(source.getElement().getNamespaceURI(), source.getElement().getNodeName())));\n     }\n-\n-    public void setCompilerContext(CompilerContext compilerContext) {\n-        _compilerContext = compilerContext;\n-        XslCompilationErrorListener xe = new XslCompilationErrorListener(compilerContext);\n-        XslTransformHandler.getInstance().setErrorListener(xe);\n-    }\n-\n-    /**\n-     * @see org.apache.ode.bpel.compiler.api.ExpressionCompiler#compileJoinCondition(java.lang.Object)\n-     */\n-    public OExpression compileJoinCondition(Object source) throws CompilationException {\n-        return _compile((Expression) source, true);\n+    if (node.getNodeType() != Node.TEXT_NODE &&\n+      node.getNodeType() != Node.ELEMENT_NODE &&\n+      node.getNodeType() != Node.CDATA_SECTION_NODE) {\n+      throw new CompilationException(__msgs.errUnexpectedNodeTypeForXPath(DOMUtils.domToString(node)));\n     }\n-\n-    /**\n-     * @see org.apache.ode.bpel.compiler.api.ExpressionCompiler#compile(java.lang.Object)\n-     */\n-    public OExpression compile(Object source) throws CompilationException {\n-        return _compile((Expression) source, false);\n+    xqueryStr = DOMUtils.domToString(node);\n+    xqueryStr = xqueryStr.trim();\n+    if (xqueryStr.length() == 0) {\n+      throw new CompilationException(__msgs.warnXPath20Syntax(DOMUtils.domToString(node), \"empty string\"));\n     }\n \n-    /**\n-     * @see org.apache.ode.bpel.compiler.api.ExpressionCompiler#compileLValue(java.lang.Object)\n-     */\n-    public OLValueExpression compileLValue(Object source) throws CompilationException {\n-        return (OLValueExpression) _compile((Expression) source, false);\n-    }\n-\n-    /**\n-     * @see org.apache.ode.bpel.compiler.api.ExpressionCompiler#compile(java.lang.Object)\n-     */\n-    private OExpression _compile(org.apache.ode.bpel.compiler.bom.Expression xquery, boolean isJoinCondition)\n-            throws CompilationException {\n-        OXQuery10ExpressionBPEL20 oexp = new OXQuery10ExpressionBPEL20(_compilerContext.getOProcess(), _qnVarData,\n-                _qnVarProp, _qnLinkStatus, _qnXslTransform, isJoinCondition);\n-        oexp.namespaceCtx = xquery.getNamespaceContext();\n-        doJaxpCompile(oexp, xquery);\n-        return oexp;\n-    }\n-\n-    private void doJaxpCompile(OXQuery10ExpressionBPEL20 out, Expression source) throws CompilationException {\n-        String xqueryStr;\n-        Node node = source.getExpression();\n-        if (node == null) {\n-            throw new CompilationException(__msgs.errEmptyExpression(source.getURI(), new QName(source.getElement().getNamespaceURI(), source.getElement().getNodeName())));\n-        }\n-        if (node.getNodeType() != Node.TEXT_NODE &&\n-                node.getNodeType() != Node.ELEMENT_NODE &&\n-                node.getNodeType() != Node.CDATA_SECTION_NODE) {\n-            throw new CompilationException(__msgs.errUnexpectedNodeTypeForXPath(DOMUtils.domToString(node)));\n-        }\n-        xqueryStr = DOMUtils.domToString(node);\n-        xqueryStr = xqueryStr.trim();\n-        if (xqueryStr.length() == 0) {\n-            throw new CompilationException(__msgs.warnXPath20Syntax(DOMUtils.domToString(node), \"empty string\"));\n+    try {\n+      XQDataSource xqds = new SaxonXQDataSource(new Configuration());\n+      XQConnection xqconn = xqds.getConnection();\n+\n+      __log.debug(\"Compiling expression \" + xqueryStr);\n+      Configuration configuration = ((SaxonXQConnection) xqconn).getConfiguration();\n+      //configuration.setAllNodesUntyped(true);\n+      configuration.setHostLanguage(Configuration.XQUERY);\n+\n+      XQStaticContext staticContext = xqconn.getStaticContext();\n+      JaxpFunctionResolver funcResolver = new JaxpFunctionResolver(\n+        _compilerContext, out, source.getNamespaceContext(), _bpelNS);\n+      JaxpVariableResolver variableResolver = new JaxpVariableResolver(\n+        _compilerContext, out);\n+\n+      XQueryDeclarations declarations = new XQueryDeclarations();\n+      NSContext nsContext = source.getNamespaceContext();\n+      Set<String> prefixes = nsContext.getPrefixes();\n+      if (!nsContext.getUriSet().contains(Namespaces.ODE_EXTENSION_NS)) {\n+        nsContext.register(\"ode\", Namespaces.ODE_EXTENSION_NS);\n+      }\n+      for (String prefix : prefixes) {\n+        String uri = nsContext.getNamespaceURI(prefix);\n+        staticContext.declareNamespace(prefix, uri);\n+        if (\"\".equals(prefix)) {\n+          declarations.declareDefaultElementNamespace(uri);\n+        } else if (\"bpws\".equals(prefix)) {\n+          declarations.declareNamespace(\"bpws\", \"java:\" + Constants.XQUERY_FUNCTION_HANDLER_COMPILER);\n+        } else {\n+          declarations.declareNamespace(prefix, uri);\n         }\n-\n-        try {\n-            XQDataSource xqds = new SaxonXQDataSource(new Configuration());\n-            XQConnection xqconn = xqds.getConnection();\n-\n-            __log.debug(\"Compiling expression \" + xqueryStr);\n-            Configuration configuration = ((SaxonXQConnection) xqconn).getConfiguration();\n-            //configuration.setAllNodesUntyped(true);\n-            configuration.setHostLanguage(Configuration.XQUERY);\n-\n-            XQStaticContext staticContext = xqconn.getStaticContext();\n-            JaxpFunctionResolver funcResolver = new JaxpFunctionResolver(\n-                    _compilerContext, out, source.getNamespaceContext(), _bpelNS);\n-            JaxpVariableResolver variableResolver = new JaxpVariableResolver(\n-                    _compilerContext, out);\n-\n-            XQueryDeclarations declarations = new XQueryDeclarations();\n-            NSContext nsContext = source.getNamespaceContext();\n-            Set<String> prefixes = nsContext.getPrefixes();\n-            if (!nsContext.getUriSet().contains(Namespaces.ODE_EXTENSION_NS)) {\n-                nsContext.register(\"ode\", Namespaces.ODE_EXTENSION_NS);\n-            }\n-            for (String prefix : prefixes) {\n-                String uri = nsContext.getNamespaceURI(prefix);\n-                staticContext.declareNamespace(prefix, uri);\n-                if (\"\".equals(prefix)) {\n-                    declarations.declareDefaultElementNamespace(uri);\n-                } else if (\"bpws\".equals(prefix)) {\n-                    declarations.declareNamespace(\"bpws\", \"java:\" + Constants.XQUERY_FUNCTION_HANDLER_COMPILER);\n-                } else {\n-                    declarations.declareNamespace(prefix, uri);\n-                }\n-            }\n-            declarations.declareVariable(\n-                    getQName(nsContext, Namespaces.ODE_EXTENSION_NS, \"pid\"),\n-                    getQName(nsContext, Namespaces.XML_SCHEMA, \"integer\"));\n+      }\n+      declarations.declareVariable(\n+        getQName(nsContext, Namespaces.ODE_EXTENSION_NS, \"pid\"),\n+        getQName(nsContext, Namespaces.XML_SCHEMA, \"integer\"));\n //            Map<URI, Source> schemaDocuments = _compilerContext.getSchemaSources();\n //            for (URI schemaUri : schemaDocuments.keySet()) {\n //            \tSource schemaSource = schemaDocuments.get(schemaUri);\n //            \t// Don't add schema sources, since our Saxon library is not schema-aware.\n //            \t// configuration.addSchemaSource(schemaSource);\n //            }\n-            //configuration.setSchemaValidationMode(Validation.SKIP);\n-            List<OScope.Variable> variables = _compilerContext.getAccessibleVariables();\n-            Map<QName, QName> variableTypes = new HashMap<QName, QName>();\n-            for (String variableName : getVariableNames(xqueryStr)) {\n-                OScope.Variable variable = getVariable(variables, variableName);\n-                if (variable == null) {\n-                    continue;\n-                }\n-                OVarType type = variable.type;\n-                QName nameQName = getNameQName(variableName);\n-                QName typeQName = getTypeQName(variableName, type);\n-                variableTypes.put(nameQName, typeQName);\n-                String prefix = typeQName.getPrefix();\n-                if (prefix == null || \"\".equals(prefix.trim())) {\n-                    prefix = getPrefixForUri(nsContext, typeQName.getNamespaceURI());\n-                }\n-                // don't declare typed variables, as our engine is not schema-aware\n-                // declarations.declareVariable(variable.name, typeQName);\n-                declarations.declareVariable(variableName);\n-            }\n-\n-            // Add implicit declarations as prolog to the user-defined XQuery\n-            out.xquery = declarations.toString() + xqueryStr;\n-\n-            // Check the XQuery for compilation errors\n-            xqconn.setStaticContext(staticContext);\n-            XQPreparedExpression exp = xqconn.prepareExpression(out.xquery);\n-\n-            // Pre-evaluate variables and functions by executing query\n-            node.setUserData(XQuery10BpelFunctions.USER_DATA_KEY_FUNCTION_RESOLVER,\n-                    funcResolver, null);\n-            exp.bindItem(XQConstants.CONTEXT_ITEM,\n-                    xqconn.createItemFromNode(node, xqconn.createNodeType()));\n-            // Bind external variables to dummy runtime values\n-            for (QName variable : exp.getAllUnboundExternalVariables()) {\n-                QName typeQName = variableTypes.get(variable);\n-                Object value = variableResolver.resolveVariable(variable);\n-                if (typeQName != null) {\n-                    if (value.getClass().getName().startsWith(\"java.lang\")) {\n-                        exp.bindAtomicValue(variable, value.toString(),\n-                                xqconn.createAtomicType(XQItemType.XQBASETYPE_ANYATOMICTYPE));\n-                    } else if (value instanceof Node) {\n-                        exp.bindNode(variable, (Node) value, xqconn.createNodeType());\n-                    } else if (value instanceof NodeList) {\n-                        NodeList nodeList = (NodeList) value;\n-                        ArrayList nodeArray = new ArrayList();\n-                        for (int i = 0; i < nodeList.getLength(); i++) {\n-                            nodeArray.add(nodeList.item(i));\n-                        }\n-                        XQSequence sequence = xqconn.createSequence(nodeArray.iterator());\n-                        exp.bindSequence(variable, sequence);\n-                    }\n-                }\n-            }\n-            // evaluate the expression so as to initialize the variables\n-            try {\n-                exp.executeQuery();\n-            } catch (XQException xpee) {\n-                // swallow errors caused by uninitialized variables\n-            } finally {\n-                // reset the expression's user data, in order to avoid\n-                // serializing the function resolver in the compiled bpel file.\n-                if (node != null) {\n-                    node.setUserData(XQuery10BpelFunctions.USER_DATA_KEY_FUNCTION_RESOLVER, null, null);\n-                }\n+      //configuration.setSchemaValidationMode(Validation.SKIP);\n+      List<OScope.Variable> variables = _compilerContext.getAccessibleVariables();\n+      Map<QName, QName> variableTypes = new HashMap<QName, QName>();\n+      for (String variableName : getVariableNames(xqueryStr)) {\n+        OScope.Variable variable = getVariable(variables, variableName);\n+        if (variable == null) {\n+          continue;\n+        }\n+        OVarType type = variable.type;\n+        QName nameQName = getNameQName(variableName);\n+        QName typeQName = getTypeQName(variableName, type);\n+        variableTypes.put(nameQName, typeQName);\n+        String prefix = typeQName.getPrefix();\n+        if (prefix == null || \"\".equals(prefix.trim())) {\n+          prefix = getPrefixForUri(nsContext, typeQName.getNamespaceURI());\n+        }\n+        // don't declare typed variables, as our engine is not schema-aware\n+        // declarations.declareVariable(variable.name, typeQName);\n+        declarations.declareVariable(variableName);\n+      }\n+\n+      // Add implicit declarations as prolog to the user-defined XQuery\n+      out.xquery = declarations.toString() + xqueryStr;\n+\n+      // Check the XQuery for compilation errors\n+      xqconn.setStaticContext(staticContext);\n+      XQPreparedExpression exp = xqconn.prepareExpression(out.xquery);\n+\n+      // Pre-evaluate variables and functions by executing query\n+      node.setUserData(XQuery10BpelFunctions.USER_DATA_KEY_FUNCTION_RESOLVER,\n+        funcResolver, null);\n+      exp.bindItem(XQConstants.CONTEXT_ITEM,\n+        xqconn.createItemFromNode(node, xqconn.createNodeType()));\n+      // Bind external variables to dummy runtime values\n+      for (QName variable : exp.getAllUnboundExternalVariables()) {\n+        QName typeQName = variableTypes.get(variable);\n+        Object value = variableResolver.resolveVariable(variable);\n+        if (typeQName != null) {\n+          if (value.getClass().getName().startsWith(\"java.lang\")) {\n+            exp.bindAtomicValue(variable, value.toString(),\n+              xqconn.createAtomicType(XQItemType.XQBASETYPE_ANYATOMICTYPE));\n+          } else if (value instanceof Node) {\n+            exp.bindNode(variable, (Node) value, xqconn.createNodeType());\n+          } else if (value instanceof NodeList) {\n+            NodeList nodeList = (NodeList) value;\n+            ArrayList nodeArray = new ArrayList();\n+            for (int i = 0; i < nodeList.getLength(); i++) {\n+              nodeArray.add(nodeList.item(i));\n             }\n-        } catch (XQException xqe) {\n-            __log.debug(xqe);\n-            __log.info(\"Couldn't validate properly expression \" + xqueryStr);\n-            throw new CompilationException(__msgs.errXQuery10Syntax(xqueryStr, \"Couldn't validate XQuery expression\"));\n-        } catch (WrappedResolverException wre) {\n-            if (wre._compilationMsg != null)\n-                throw new CompilationException(wre._compilationMsg, wre);\n-            if (wre.getCause() instanceof CompilationException)\n-                throw (CompilationException) wre.getCause();\n-            throw wre;\n+            XQSequence sequence = xqconn.createSequence(nodeArray.iterator());\n+            exp.bindSequence(variable, sequence);\n+          }\n         }\n+      }\n+      // evaluate the expression so as to initialize the variables\n+      try {\n+        exp.executeQuery();\n+      } catch (XQException xpee) {\n+        // swallow errors caused by uninitialized variables\n+      } finally {\n+        // reset the expression's user data, in order to avoid\n+        // serializing the function resolver in the compiled bpel file.\n+        if (node != null) {\n+          node.setUserData(XQuery10BpelFunctions.USER_DATA_KEY_FUNCTION_RESOLVER, null, null);\n+        }\n+      }\n+    } catch (XQException xqe) {\n+      __log.debug(xqe);\n+      __log.info(\"Couldn't validate properly expression \" + xqueryStr);\n+      throw new CompilationException(__msgs.errXQuery10Syntax(xqueryStr, \"Couldn't validate XQuery expression\"));\n+    } catch (WrappedResolverException wre) {\n+      if (wre._compilationMsg != null) {\n+        throw new CompilationException(wre._compilationMsg, wre);\n+      }\n+      if (wre.getCause() instanceof CompilationException) {\n+        throw (CompilationException) wre.getCause();\n+      }\n+      throw wre;\n     }\n-\n-    public Map<String, String> getProperties() {\n-        return _properties;\n+  }\n+\n+  public Map<String, String> getProperties() {\n+    return _properties;\n+  }\n+\n+  private String getQName(NSContext nsContext, String uri, String localPart) {\n+    String prefix = getPrefixForUri(nsContext, uri);\n+    return (prefix == null ? localPart : (prefix + \":\" + localPart));\n+  }\n+\n+  private String getPrefixForUri(NSContext nsContext, String uri) {\n+    Set<String> prefixes = nsContext.getPrefixes();\n+    for (String prefix : prefixes) {\n+      String anUri = (nsContext.getNamespaceURI(prefix));\n+      if (anUri != null && anUri.equals(uri)) {\n+        return prefix;\n+      }\n     }\n-\n-    private String getQName(NSContext nsContext, String uri, String localPart) {\n-        String prefix = getPrefixForUri(nsContext, uri);\n-        return (prefix == null ? localPart : (prefix + \":\" + localPart));\n+    return null;\n+  }\n+\n+  protected static Collection<String> getVariableNames(String xquery) {\n+    Collection<String> variableNames = new LinkedHashSet<String>();\n+    for (int index = xquery.indexOf(\"$\"); index != -1; index = xquery.indexOf(\"$\")) {\n+      StringBuilder variableName = new StringBuilder();\n+      index++;\n+      while (index < xquery.length() && XMLChar.isNCName(xquery.charAt(index))) {\n+        variableName.append(xquery.charAt(index++));\n+      }\n+      variableNames.add(variableName.toString());\n+      xquery = xquery.substring(index);\n     }\n-\n-    private String getPrefixForUri(NSContext nsContext, String uri) {\n-        Set<String> prefixes = nsContext.getPrefixes();\n-        for (String prefix : prefixes) {\n-            String anUri = (nsContext.getNamespaceURI(prefix));\n-            if (anUri != null && anUri.equals(uri)) {\n-                return prefix;\n-            }\n-        }\n-        return null;\n+    return variableNames;\n+  }\n+\n+  private OScope.Variable getVariable(List<OScope.Variable> variables, String variableName) {\n+    String declaredVariable = getVariableDeclaredName(variableName);\n+    for (OScope.Variable variable : variables) {\n+      if (variable.name.equals(declaredVariable)) {\n+        return variable;\n+      }\n     }\n-\n-    protected static Collection<String> getVariableNames(String xquery) {\n-        Collection<String> variableNames = new LinkedHashSet<String>();\n-        for (int index = xquery.indexOf(\"$\"); index != -1; index = xquery.indexOf(\"$\")) {\n-            StringBuilder variableName = new StringBuilder();\n-            index++;\n-            while(index < xquery.length() && XMLChar.isNCName(xquery.charAt(index))) {\n-                variableName.append(xquery.charAt(index++));\n-            }\n-            variableNames.add(variableName.toString());\n-            xquery = xquery.substring(index);\n-        }\n-        return variableNames;\n+    return null;\n+  }\n+\n+  private String getVariableDeclaredName(String variableReference) {\n+    int dotIndex = variableReference.indexOf(\".\");\n+    return dotIndex >= 0 ? variableReference.substring(0, dotIndex) : variableReference;\n+  }\n+\n+  private String getVariablePartName(String variableReference) {\n+    int dotIndex = variableReference.indexOf(\".\");\n+    return dotIndex >= 0 ? variableReference.substring(dotIndex + 1) : \"\";\n+  }\n+\n+  private QName getNameQName(String variableName) {\n+    String prefix = null, localName = null;\n+    ;\n+    int colonIndex = variableName.indexOf(\":\");\n+    if (colonIndex >= 0) {\n+      prefix = variableName.substring(0, colonIndex);\n+      localName = variableName.substring(colonIndex + 1);\n+    } else {\n+      prefix = \"\";\n+      localName = variableName;\n     }\n-\n-    private OScope.Variable getVariable(List<OScope.Variable> variables, String variableName) {\n-        String declaredVariable = getVariableDeclaredName(variableName);\n-        for (OScope.Variable variable : variables) {\n-            if (variable.name.equals(declaredVariable)) {\n-                return variable;\n-            }\n-        }\n-        return null;\n+    return new QName(prefix, localName);\n+  }\n+\n+  private QName getTypeQName(String variableName, OVarType type) {\n+    QName typeQName = null;\n+    if (type instanceof OConstantVarType) {\n+      typeQName = new QName(Namespaces.XML_SCHEMA, \"string\", \"xs\");\n+    } else if (type instanceof OElementVarType) {\n+      typeQName = ((OElementVarType) type).elementType;\n+    } else if (type instanceof OMessageVarType) {\n+      Part part = ((OMessageVarType) type).parts.get(getVariablePartName(variableName));\n+      if (part != null) {\n+        typeQName = getTypeQName(variableName, part.type);\n+      }\n+    } else if (type instanceof OXsdTypeVarType) {\n+      typeQName = ((OXsdTypeVarType) type).xsdType;\n     }\n+    return typeQName;\n+  }\n \n-    private String getVariableDeclaredName(String variableReference) {\n-        int dotIndex = variableReference.indexOf(\".\");\n-        return dotIndex >= 0 ? variableReference.substring(0, dotIndex) : variableReference;\n-    }\n+  private static class XQueryDeclarations {\n+    StringBuffer declarations = new StringBuffer();\n \n-    private String getVariablePartName(String variableReference) {\n-        int dotIndex = variableReference.indexOf(\".\");\n-        return dotIndex >= 0 ? variableReference.substring(dotIndex + 1) : \"\";\n+    public XQueryDeclarations() {\n     }\n \n-    private QName getNameQName(String variableName) {\n-        String prefix = null, localName = null;;\n-        int colonIndex = variableName.indexOf(\":\");\n-        if (colonIndex >= 0) {\n-            prefix = variableName.substring(0, colonIndex);\n-            localName = variableName.substring(colonIndex + 1);\n-        } else {\n-            prefix = \"\";\n-            localName = variableName;\n-        }\n-        return new QName(prefix, localName);\n+    public void declareVariable(String name, QName type) {\n+      declareVariable(name, type.getPrefix() + \":\" + type.getLocalPart());\n     }\n \n-    private QName getTypeQName(String variableName, OVarType type) {\n-        QName typeQName = null;\n-        if (type instanceof OConstantVarType) {\n-            typeQName = new QName(Namespaces.XML_SCHEMA, \"string\", \"xs\");\n-        } else if (type instanceof OElementVarType) {\n-            typeQName = ((OElementVarType) type).elementType;\n-        } else if (type instanceof OMessageVarType) {\n-            Part part = ((OMessageVarType) type).parts.get(getVariablePartName(variableName));\n-            if (part != null) {\n-                typeQName = getTypeQName(variableName, part.type);\n-            }\n-        } else if (type instanceof OXsdTypeVarType) {\n-            typeQName = ((OXsdTypeVarType) type).xsdType;\n-        }\n-        return typeQName;\n+    public void declareVariable(String name, String type) {\n+      declarations.append(\"declare variable \")\n+        .append(\"$\")\n+        .append(name)\n+        .append(\" as \")\n+        .append(type)\n+        .append(\" external \")\n+        .append(\";\\n\");\n     }\n \n-    private static class XQueryDeclarations {\n-        StringBuffer declarations = new StringBuffer();\n-\n-        public XQueryDeclarations() {}\n-\n-        public void declareVariable(String name, QName type) {\n-            declareVariable(name, type.getPrefix() + \":\" + type.getLocalPart());\n-        }\n-\n-        public void declareVariable(String name, String type) {\n-            declarations.append(\"declare variable \")\n-                .append(\"$\")\n-                .append(name)\n-                .append(\" as \")\n-                .append(type)\n-                .append(\" external \")\n-                .append(\";\\n\");\n-        }\n-\n-        public void declareVariable(String name) {\n-            declarations.append(\"declare variable \")\n-                .append(\"$\")\n-                .append(name)\n-                .append(\" external \")\n-                .append(\";\\n\");\n-        }\n+    public void declareVariable(String name) {\n+      declarations.append(\"declare variable \")\n+        .append(\"$\")\n+        .append(name)\n+        .append(\" external \")\n+        .append(\";\\n\");\n+    }\n \n-        public void declareNamespace(String prefix, String uri) {\n-            declarations.append(\"declare namespace \")\n-                .append(prefix)\n-                .append(\"=\")\n-                .append(\"\\\"\" + uri + \"\\\"\")\n-                .append(\";\\n\");\n-        }\n+    public void declareNamespace(String prefix, String uri) {\n+      declarations.append(\"declare namespace \")\n+        .append(prefix)\n+        .append(\"=\")\n+        .append(\"\\\"\" + uri + \"\\\"\")\n+        .append(\";\\n\");\n+    }\n \n-        public void declareDefaultElementNamespace(String uri) {\n-            declarations.append(\"declare default element namespace \")\n-                .append(\"\\\"\" + uri + \"\\\"\")\n-                .append(\";\\n\");\n-        }\n+    public void declareDefaultElementNamespace(String uri) {\n+      declarations.append(\"declare default element namespace \")\n+        .append(\"\\\"\" + uri + \"\\\"\")\n+        .append(\";\\n\");\n+    }\n \n-        public String toString() {\n-            return declarations.toString();\n-        }\n+    public String toString() {\n+      return declarations.toString();\n     }\n+  }\n }\n",
            "diff_size": 414
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "150",
                    "severity": "error",
                    "message": "Line is longer than 120 characters (found 172).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/581/XQuery10ExpressionCompilerImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/naturalize/581/XQuery10ExpressionCompilerImpl.java\nindex 13edbe65754..3c2903ea41b 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/581/XQuery10ExpressionCompilerImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/naturalize/581/XQuery10ExpressionCompilerImpl.java\n@@ -195,13 +195,9 @@ public class XQuery10ExpressionCompilerImpl implements ExpressionCompiler {\n             declarations.declareVariable(\n                     getQName(nsContext, Namespaces.ODE_EXTENSION_NS, \"pid\"),\n                     getQName(nsContext, Namespaces.XML_SCHEMA, \"integer\"));\n-//            Map<URI, Source> schemaDocuments = _compilerContext.getSchemaSources();\n-//            for (URI schemaUri : schemaDocuments.keySet()) {\n-//            \tSource schemaSource = schemaDocuments.get(schemaUri);\n-//            \t// Don't add schema sources, since our Saxon library is not schema-aware.\n-//            \t// configuration.addSchemaSource(schemaSource);\n-//            }\n-            //configuration.setSchemaValidationMode(Validation.SKIP);\n+\n+//         \n+//configuration.setSchemaValidationMode(Validation.SKIP);\n             List<OScope.Variable> variables = _compilerContext.getAccessibleVariables();\n             Map<QName, QName> variableTypes = new HashMap<QName, QName>();\n             for (String variableName : getVariableNames(xqueryStr)) {\n@@ -409,4 +405,4 @@ public class XQuery10ExpressionCompilerImpl implements ExpressionCompiler {\n             return declarations.toString();\n         }\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 8
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "150",
                    "severity": "error",
                    "message": "Line is longer than 120 characters (found 172).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/581/XQuery10ExpressionCompilerImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler_three_grams/581/XQuery10ExpressionCompilerImpl.java\nindex 13edbe65754..2bd3b7fb9f0 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/581/XQuery10ExpressionCompilerImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler_three_grams/581/XQuery10ExpressionCompilerImpl.java\n@@ -147,9 +147,10 @@ public class XQuery10ExpressionCompilerImpl implements ExpressionCompiler {\n         String xqueryStr;\n         Node node = source.getExpression();\n         if (node == null) {\n-            throw new CompilationException(__msgs.errEmptyExpression(source.getURI(), new QName(source.getElement().getNamespaceURI(), source.getElement().getNodeName())));\n-        }\n-        if (node.getNodeType() != Node.TEXT_NODE &&\n+            throw new CompilationException(__msgs.errEmptyExpression(source.getURI(),\n+                                new QName(source.getElement().getNamespaceURI(), source.getElement().getNodeName())));\n+         }\n+         if (node.getNodeType() != Node.TEXT_NODE &&\n                 node.getNodeType() != Node.ELEMENT_NODE &&\n                 node.getNodeType() != Node.CDATA_SECTION_NODE) {\n             throw new CompilationException(__msgs.errUnexpectedNodeTypeForXPath(DOMUtils.domToString(node)));\n",
            "diff_size": 4
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "naturalize",
        "codebuff",
        "styler_random"
    ]
}