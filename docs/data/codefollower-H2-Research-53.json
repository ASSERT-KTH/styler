{
    "project_name": "codefollower-H2-Research",
    "error_id": "53",
    "information": {
        "errors": [
            {
                "line": "410",
                "column": "67",
                "severity": "warning",
                "message": "',' is not followed by whitespace.",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAfterCheck"
            }
        ]
    },
    "source_code": "    }\n\n    private void rebuildIndexBlockMerge(Session session, MVIndex<?,?> index) {\n        if (index instanceof MVSpatialIndex) {\n            // the spatial index doesn't support multi-way merge sort\n            rebuildIndexBuffered(session, index);",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/53/MVTable.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler/53/MVTable.java\nindex 9aaf01bb0c0..40599b2e266 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/53/MVTable.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler/53/MVTable.java\n@@ -407,7 +407,7 @@ public class MVTable extends RegularTable {\n         }\n     }\n \n-    private void rebuildIndexBlockMerge(Session session, MVIndex<?,?> index) {\n+    private void rebuildIndexBlockMerge(Session session, MVIndex<?, ?> index) {\n         if (index instanceof MVSpatialIndex) {\n             // the spatial index doesn't support multi-way merge sort\n             rebuildIndexBuffered(session, index);\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/53/MVTable.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/53/MVTable.java\nindex 9aaf01bb0c0..89af066dda3 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/53/MVTable.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/53/MVTable.java\n@@ -3,6 +3,7 @@\n  * and the EPL 1.0 (https://h2database.com/html/license.html).\n  * Initial Developer: H2 Group\n  */\n+\n package org.h2.mvstore.db;\n \n import java.util.ArrayDeque;\n@@ -41,676 +42,677 @@ import org.h2.util.Utils;\n  * A table stored in a MVStore.\n  */\n public class MVTable extends RegularTable {\n-    /**\n-     * The table name this thread is waiting to lock.\n-     */\n-    public static final DebuggingThreadLocal<String> WAITING_FOR_LOCK;\n-\n-    /**\n-     * The table names this thread has exclusively locked.\n-     */\n-    public static final DebuggingThreadLocal<ArrayList<String>> EXCLUSIVE_LOCKS;\n-\n-    /**\n-     * The tables names this thread has a shared lock on.\n-     */\n-    public static final DebuggingThreadLocal<ArrayList<String>> SHARED_LOCKS;\n-\n-    /**\n-     * The type of trace lock events\n-     */\n-    private enum TraceLockEvent{\n-\n-        TRACE_LOCK_OK(\"ok\"),\n-        TRACE_LOCK_WAITING_FOR(\"waiting for\"),\n-        TRACE_LOCK_REQUESTING_FOR(\"requesting for\"),\n-        TRACE_LOCK_TIMEOUT_AFTER(\"timeout after \"),\n-        TRACE_LOCK_UNLOCK(\"unlock\"),\n-        TRACE_LOCK_ADDED_FOR(\"added for\"),\n-        TRACE_LOCK_ADD_UPGRADED_FOR(\"add (upgraded) for \");\n-\n-        private final String eventText;\n-\n-        TraceLockEvent(String eventText) {\n-            this.eventText = eventText;\n-        }\n-\n-        public String getEventText() {\n-            return eventText;\n-        }\n-    }\n-    private static final String NO_EXTRA_INFO = \"\";\n-\n-    static {\n-        if (SysProperties.THREAD_DEADLOCK_DETECTOR) {\n-            WAITING_FOR_LOCK = new DebuggingThreadLocal<>();\n-            EXCLUSIVE_LOCKS = new DebuggingThreadLocal<>();\n-            SHARED_LOCKS = new DebuggingThreadLocal<>();\n-        } else {\n-            WAITING_FOR_LOCK = null;\n-            EXCLUSIVE_LOCKS = null;\n-            SHARED_LOCKS = null;\n-        }\n-    }\n-\n-    private MVPrimaryIndex primaryIndex;\n-    private final ArrayList<Index> indexes = Utils.newSmallArrayList();\n-    private final AtomicLong lastModificationId = new AtomicLong();\n-\n-    /**\n-     * The queue of sessions waiting to lock the table. It is a FIFO queue to\n-     * prevent starvation, since Java's synchronized locking is biased.\n-     */\n-    private final ArrayDeque<Session> waitingSessions = new ArrayDeque<>();\n-    private final Trace traceLock;\n-    private final AtomicInteger changesUntilAnalyze;\n-    private int nextAnalyze;\n-\n-    private final MVTableEngine.Store store;\n-    private final TransactionStore transactionStore;\n-\n-    public MVTable(CreateTableData data, MVTableEngine.Store store) {\n-        super(data);\n-        nextAnalyze = database.getSettings().analyzeAuto;\n-        changesUntilAnalyze = nextAnalyze <= 0 ? null : new AtomicInteger(nextAnalyze);\n-        this.store = store;\n-        this.transactionStore = store.getTransactionStore();\n-        traceLock = database.getTrace(Trace.LOCK);\n-\n-        primaryIndex = new MVPrimaryIndex(database, this, getId(),\n-                IndexColumn.wrap(getColumns()), IndexType.createScan(true));\n-        indexes.add(primaryIndex);\n-    }\n-\n-    public String getMapName() {\n-        return primaryIndex.getMapName();\n-    }\n-\n-    @Override\n-    public boolean lock(Session session, boolean exclusive,\n-            boolean forceLockEvenInMvcc) {\n-        int lockMode = database.getLockMode();\n-        if (lockMode == Constants.LOCK_MODE_OFF) {\n-            session.registerTableAsUpdated(this);\n-            return false;\n-        }\n-        if (!forceLockEvenInMvcc) {\n-            // MVCC: update, delete, and insert use a shared lock.\n-            // Select doesn't lock except when using FOR UPDATE and\n-            // the system property h2.selectForUpdateMvcc\n-            // is not enabled\n-            if (exclusive) {\n-                exclusive = false;\n-            } else {\n-                if (lockExclusiveSession == null) {\n-                    return false;\n-                }\n-            }\n-        }\n-        if (lockExclusiveSession == session) {\n-            return true;\n-        }\n-        if (!exclusive && lockSharedSessions.containsKey(session)) {\n-            return true;\n-        }\n-        synchronized (this) {\n-            if (!exclusive && lockSharedSessions.containsKey(session)) {\n-                return true;\n-            }\n-            session.setWaitForLock(this, Thread.currentThread());\n-            if (SysProperties.THREAD_DEADLOCK_DETECTOR) {\n-                WAITING_FOR_LOCK.set(getName());\n-            }\n-            waitingSessions.addLast(session);\n-            try {\n-                doLock1(session, lockMode, exclusive);\n-            } finally {\n-                session.setWaitForLock(null, null);\n-                if (SysProperties.THREAD_DEADLOCK_DETECTOR) {\n-                    WAITING_FOR_LOCK.remove();\n-                }\n-                waitingSessions.remove(session);\n-            }\n-        }\n-        return false;\n-    }\n-\n-    private void doLock1(Session session, int lockMode, boolean exclusive) {\n-        traceLock(session, exclusive, TraceLockEvent.TRACE_LOCK_REQUESTING_FOR, NO_EXTRA_INFO);\n-        // don't get the current time unless necessary\n-        long max = 0;\n-        boolean checkDeadlock = false;\n-        while (true) {\n-            // if I'm the next one in the queue\n-            if (waitingSessions.getFirst() == session) {\n-                if (doLock2(session, lockMode, exclusive)) {\n-                    return;\n-                }\n-            }\n-            if (checkDeadlock) {\n-                ArrayList<Session> sessions = checkDeadlock(session, null, null);\n-                if (sessions != null) {\n-                    throw DbException.get(ErrorCode.DEADLOCK_1,\n-                            getDeadlockDetails(sessions, exclusive));\n-                }\n-            } else {\n-                // check for deadlocks from now on\n-                checkDeadlock = true;\n-            }\n-            long now = System.nanoTime();\n-            if (max == 0) {\n-                // try at least one more time\n-                max = now + TimeUnit.MILLISECONDS.toNanos(session.getLockTimeout());\n-            } else if (now >= max) {\n-                traceLock(session, exclusive,\n-                        TraceLockEvent.TRACE_LOCK_TIMEOUT_AFTER, NO_EXTRA_INFO+session.getLockTimeout());\n-                throw DbException.get(ErrorCode.LOCK_TIMEOUT_1, getName());\n-            }\n-            try {\n-                traceLock(session, exclusive, TraceLockEvent.TRACE_LOCK_WAITING_FOR, NO_EXTRA_INFO);\n-                if (database.getLockMode() == Constants.LOCK_MODE_TABLE_GC) {\n-                    for (int i = 0; i < 20; i++) {\n-                        long free = Runtime.getRuntime().freeMemory();\n-                        System.gc();\n-                        long free2 = Runtime.getRuntime().freeMemory();\n-                        if (free == free2) {\n-                            break;\n-                        }\n-                    }\n-                }\n-                // don't wait too long so that deadlocks are detected early\n-                long sleep = Math.min(Constants.DEADLOCK_CHECK,\n-                        TimeUnit.NANOSECONDS.toMillis(max - now));\n-                if (sleep == 0) {\n-                    sleep = 1;\n-                }\n-                wait(sleep);\n-            } catch (InterruptedException e) {\n-                // ignore\n-            }\n-        }\n-    }\n-\n-    private boolean doLock2(Session session, int lockMode, boolean exclusive) {\n+  /**\n+   * The table name this thread is waiting to lock.\n+   */\n+  public static final DebuggingThreadLocal<String> WAITING_FOR_LOCK;\n+\n+  /**\n+   * The table names this thread has exclusively locked.\n+   */\n+  public static final DebuggingThreadLocal<ArrayList<String>> EXCLUSIVE_LOCKS;\n+\n+  /**\n+   * The tables names this thread has a shared lock on.\n+   */\n+  public static final DebuggingThreadLocal<ArrayList<String>> SHARED_LOCKS;\n+\n+  /**\n+   * The type of trace lock events\n+   */\n+  private enum TraceLockEvent {\n+\n+    TRACE_LOCK_OK(\"ok\"),\n+    TRACE_LOCK_WAITING_FOR(\"waiting for\"),\n+    TRACE_LOCK_REQUESTING_FOR(\"requesting for\"),\n+    TRACE_LOCK_TIMEOUT_AFTER(\"timeout after \"),\n+    TRACE_LOCK_UNLOCK(\"unlock\"),\n+    TRACE_LOCK_ADDED_FOR(\"added for\"),\n+    TRACE_LOCK_ADD_UPGRADED_FOR(\"add (upgraded) for \");\n+\n+    private final String eventText;\n+\n+    TraceLockEvent(String eventText) {\n+      this.eventText = eventText;\n+    }\n+\n+    public String getEventText() {\n+      return eventText;\n+    }\n+  }\n+\n+  private static final String NO_EXTRA_INFO = \"\";\n+\n+  static {\n+    if (SysProperties.THREAD_DEADLOCK_DETECTOR) {\n+      WAITING_FOR_LOCK = new DebuggingThreadLocal<>();\n+      EXCLUSIVE_LOCKS = new DebuggingThreadLocal<>();\n+      SHARED_LOCKS = new DebuggingThreadLocal<>();\n+    } else {\n+      WAITING_FOR_LOCK = null;\n+      EXCLUSIVE_LOCKS = null;\n+      SHARED_LOCKS = null;\n+    }\n+  }\n+\n+  private MVPrimaryIndex primaryIndex;\n+  private final ArrayList<Index> indexes = Utils.newSmallArrayList();\n+  private final AtomicLong lastModificationId = new AtomicLong();\n+\n+  /**\n+   * The queue of sessions waiting to lock the table. It is a FIFO queue to\n+   * prevent starvation, since Java's synchronized locking is biased.\n+   */\n+  private final ArrayDeque<Session> waitingSessions = new ArrayDeque<>();\n+  private final Trace traceLock;\n+  private final AtomicInteger changesUntilAnalyze;\n+  private int nextAnalyze;\n+\n+  private final MVTableEngine.Store store;\n+  private final TransactionStore transactionStore;\n+\n+  public MVTable(CreateTableData data, MVTableEngine.Store store) {\n+    super(data);\n+    nextAnalyze = database.getSettings().analyzeAuto;\n+    changesUntilAnalyze = nextAnalyze <= 0 ? null : new AtomicInteger(nextAnalyze);\n+    this.store = store;\n+    this.transactionStore = store.getTransactionStore();\n+    traceLock = database.getTrace(Trace.LOCK);\n+\n+    primaryIndex = new MVPrimaryIndex(database, this, getId(),\n+        IndexColumn.wrap(getColumns()), IndexType.createScan(true));\n+    indexes.add(primaryIndex);\n+  }\n+\n+  public String getMapName() {\n+    return primaryIndex.getMapName();\n+  }\n+\n+  @Override\n+  public boolean lock(Session session, boolean exclusive,\n+                      boolean forceLockEvenInMvcc) {\n+    int lockMode = database.getLockMode();\n+    if (lockMode == Constants.LOCK_MODE_OFF) {\n+      session.registerTableAsUpdated(this);\n+      return false;\n+    }\n+    if (!forceLockEvenInMvcc) {\n+      // MVCC: update, delete, and insert use a shared lock.\n+      // Select doesn't lock except when using FOR UPDATE and\n+      // the system property h2.selectForUpdateMvcc\n+      // is not enabled\n+      if (exclusive) {\n+        exclusive = false;\n+      } else {\n         if (lockExclusiveSession == null) {\n-            if (exclusive) {\n-                if (lockSharedSessions.isEmpty()) {\n-                    traceLock(session, exclusive, TraceLockEvent.TRACE_LOCK_ADDED_FOR, NO_EXTRA_INFO);\n-                    session.registerTableAsLocked(this);\n-                    lockExclusiveSession = session;\n-                    if (SysProperties.THREAD_DEADLOCK_DETECTOR) {\n-                        if (EXCLUSIVE_LOCKS.get() == null) {\n-                            EXCLUSIVE_LOCKS.set(new ArrayList<String>());\n-                        }\n-                        EXCLUSIVE_LOCKS.get().add(getName());\n-                    }\n-                    return true;\n-                } else if (lockSharedSessions.size() == 1 &&\n-                        lockSharedSessions.containsKey(session)) {\n-                    traceLock(session, exclusive, TraceLockEvent.TRACE_LOCK_ADD_UPGRADED_FOR, NO_EXTRA_INFO);\n-                    lockExclusiveSession = session;\n-                    if (SysProperties.THREAD_DEADLOCK_DETECTOR) {\n-                        if (EXCLUSIVE_LOCKS.get() == null) {\n-                            EXCLUSIVE_LOCKS.set(new ArrayList<String>());\n-                        }\n-                        EXCLUSIVE_LOCKS.get().add(getName());\n-                    }\n-                    return true;\n-                }\n-            } else {\n-                if (lockSharedSessions.putIfAbsent(session, session) == null) {\n-                    traceLock(session, exclusive, TraceLockEvent.TRACE_LOCK_OK, NO_EXTRA_INFO);\n-                    session.registerTableAsLocked(this);\n-                    if (SysProperties.THREAD_DEADLOCK_DETECTOR) {\n-                        ArrayList<String> list = SHARED_LOCKS.get();\n-                        if (list == null) {\n-                            list = new ArrayList<>();\n-                            SHARED_LOCKS.set(list);\n-                        }\n-                        list.add(getName());\n-                    }\n-                }\n-                return true;\n-            }\n+          return false;\n         }\n-        return false;\n+      }\n     }\n-\n-    private void traceLock(Session session, boolean exclusive, TraceLockEvent eventEnum, String extraInfo) {\n-        if (traceLock.isDebugEnabled()) {\n-            traceLock.debug(\"{0} {1} {2} {3} {4}\", session.getId(),\n-                    exclusive ? \"exclusive write lock\" : \"shared read lock\", eventEnum.getEventText(),\n-                    getName(), extraInfo);\n-        }\n-    }\n-\n-    @Override\n-    public void unlock(Session s) {\n-        if (database != null) {\n-            boolean wasLocked = lockExclusiveSession == s;\n-            traceLock(s, wasLocked, TraceLockEvent.TRACE_LOCK_UNLOCK, NO_EXTRA_INFO);\n-            if (wasLocked) {\n-                lockSharedSessions.remove(s);\n-                lockExclusiveSession = null;\n-                if (SysProperties.THREAD_DEADLOCK_DETECTOR) {\n-                    if (EXCLUSIVE_LOCKS.get() != null) {\n-                        EXCLUSIVE_LOCKS.get().remove(getName());\n-                    }\n-                }\n-            } else {\n-                wasLocked = lockSharedSessions.remove(s) != null;\n-                if (SysProperties.THREAD_DEADLOCK_DETECTOR) {\n-                    if (SHARED_LOCKS.get() != null) {\n-                        SHARED_LOCKS.get().remove(getName());\n-                    }\n-                }\n-            }\n-            if (wasLocked && !waitingSessions.isEmpty()) {\n-                synchronized (this) {\n-                    notifyAll();\n-                }\n-            }\n-        }\n+    if (lockExclusiveSession == session) {\n+      return true;\n     }\n-\n-    @Override\n-    public void close(Session session) {\n-        // ignore\n+    if (!exclusive && lockSharedSessions.containsKey(session)) {\n+      return true;\n     }\n-\n-    @Override\n-    public Row getRow(Session session, long key) {\n-        return primaryIndex.getRow(session, key);\n-    }\n-\n-    @Override\n-    public Index addIndex(Session session, String indexName, int indexId,\n-            IndexColumn[] cols, IndexType indexType, boolean create,\n-            String indexComment) {\n-        if (indexType.isPrimaryKey()) {\n-            for (IndexColumn c : cols) {\n-                Column column = c.column;\n-                if (column.isNullable()) {\n-                    throw DbException.get(\n-                            ErrorCode.COLUMN_MUST_NOT_BE_NULLABLE_1,\n-                            column.getName());\n-                }\n-                column.setPrimaryKey(true);\n-            }\n-        }\n-        boolean isSessionTemporary = isTemporary() && !isGlobalTemporary();\n-        if (!isSessionTemporary) {\n-            database.lockMeta(session);\n-        }\n-        MVIndex index;\n-        int mainIndexColumn = primaryIndex.getMainIndexColumn() != SearchRow.ROWID_INDEX\n-                ? SearchRow.ROWID_INDEX : getMainIndexColumn(indexType, cols);\n-        if (database.isStarting()) {\n-            // if index does exists as a separate map it can't be a delegate\n-            if (transactionStore.hasMap(\"index.\" + indexId)) {\n-                // we can not reuse primary index\n-                mainIndexColumn = SearchRow.ROWID_INDEX;\n+    synchronized (this) {\n+      if (!exclusive && lockSharedSessions.containsKey(session)) {\n+        return true;\n+      }\n+      session.setWaitForLock(this, Thread.currentThread());\n+      if (SysProperties.THREAD_DEADLOCK_DETECTOR) {\n+        WAITING_FOR_LOCK.set(getName());\n+      }\n+      waitingSessions.addLast(session);\n+      try {\n+        doLock1(session, lockMode, exclusive);\n+      } finally {\n+        session.setWaitForLock(null, null);\n+        if (SysProperties.THREAD_DEADLOCK_DETECTOR) {\n+          WAITING_FOR_LOCK.remove();\n+        }\n+        waitingSessions.remove(session);\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private void doLock1(Session session, int lockMode, boolean exclusive) {\n+    traceLock(session, exclusive, TraceLockEvent.TRACE_LOCK_REQUESTING_FOR, NO_EXTRA_INFO);\n+    // don't get the current time unless necessary\n+    long max = 0;\n+    boolean checkDeadlock = false;\n+    while (true) {\n+      // if I'm the next one in the queue\n+      if (waitingSessions.getFirst() == session) {\n+        if (doLock2(session, lockMode, exclusive)) {\n+          return;\n+        }\n+      }\n+      if (checkDeadlock) {\n+        ArrayList<Session> sessions = checkDeadlock(session, null, null);\n+        if (sessions != null) {\n+          throw DbException.get(ErrorCode.DEADLOCK_1,\n+              getDeadlockDetails(sessions, exclusive));\n+        }\n+      } else {\n+        // check for deadlocks from now on\n+        checkDeadlock = true;\n+      }\n+      long now = System.nanoTime();\n+      if (max == 0) {\n+        // try at least one more time\n+        max = now + TimeUnit.MILLISECONDS.toNanos(session.getLockTimeout());\n+      } else if (now >= max) {\n+        traceLock(session, exclusive,\n+            TraceLockEvent.TRACE_LOCK_TIMEOUT_AFTER, NO_EXTRA_INFO + session.getLockTimeout());\n+        throw DbException.get(ErrorCode.LOCK_TIMEOUT_1, getName());\n+      }\n+      try {\n+        traceLock(session, exclusive, TraceLockEvent.TRACE_LOCK_WAITING_FOR, NO_EXTRA_INFO);\n+        if (database.getLockMode() == Constants.LOCK_MODE_TABLE_GC) {\n+          for (int i = 0; i < 20; i++) {\n+            long free = Runtime.getRuntime().freeMemory();\n+            System.gc();\n+            long free2 = Runtime.getRuntime().freeMemory();\n+            if (free == free2) {\n+              break;\n             }\n-        } else if (primaryIndex.getRowCountMax() != 0) {\n-            mainIndexColumn = SearchRow.ROWID_INDEX;\n-        }\n-\n-        if (mainIndexColumn != SearchRow.ROWID_INDEX) {\n-            primaryIndex.setMainIndexColumn(mainIndexColumn);\n-            index = new MVDelegateIndex(this, indexId, indexName, primaryIndex,\n-                    indexType);\n-        } else if (indexType.isSpatial()) {\n-            index = new MVSpatialIndex(session.getDatabase(), this, indexId,\n-                    indexName, cols, indexType);\n-        } else {\n-            index = new MVSecondaryIndex(session.getDatabase(), this, indexId,\n-                    indexName, cols, indexType);\n+          }\n         }\n-        if (index.needRebuild()) {\n-            rebuildIndex(session, index, indexName);\n+        // don't wait too long so that deadlocks are detected early\n+        long sleep = Math.min(Constants.DEADLOCK_CHECK,\n+            TimeUnit.NANOSECONDS.toMillis(max - now));\n+        if (sleep == 0) {\n+          sleep = 1;\n         }\n-        index.setTemporary(isTemporary());\n-        if (index.getCreateSQL() != null) {\n-            index.setComment(indexComment);\n-            if (isSessionTemporary) {\n-                session.addLocalTempTableIndex(index);\n-            } else {\n-                database.addSchemaObject(session, index);\n+        wait(sleep);\n+      } catch (InterruptedException e) {\n+        // ignore\n+      }\n+    }\n+  }\n+\n+  private boolean doLock2(Session session, int lockMode, boolean exclusive) {\n+    if (lockExclusiveSession == null) {\n+      if (exclusive) {\n+        if (lockSharedSessions.isEmpty()) {\n+          traceLock(session, exclusive, TraceLockEvent.TRACE_LOCK_ADDED_FOR, NO_EXTRA_INFO);\n+          session.registerTableAsLocked(this);\n+          lockExclusiveSession = session;\n+          if (SysProperties.THREAD_DEADLOCK_DETECTOR) {\n+            if (EXCLUSIVE_LOCKS.get() == null) {\n+              EXCLUSIVE_LOCKS.set(new ArrayList<String>());\n             }\n-        }\n-        indexes.add(index);\n-        setModified();\n-        return index;\n-    }\n-\n-    private void rebuildIndex(Session session, MVIndex index, String indexName) {\n-        try {\n-            if (session.getDatabase().getStore() == null ||\n-                    index instanceof MVSpatialIndex) {\n-                // in-memory\n-                rebuildIndexBuffered(session, index);\n-            } else {\n-                rebuildIndexBlockMerge(session, index);\n+            EXCLUSIVE_LOCKS.get().add(getName());\n+          }\n+          return true;\n+        } else if (lockSharedSessions.size() == 1 &&\n+            lockSharedSessions.containsKey(session)) {\n+          traceLock(session, exclusive, TraceLockEvent.TRACE_LOCK_ADD_UPGRADED_FOR, NO_EXTRA_INFO);\n+          lockExclusiveSession = session;\n+          if (SysProperties.THREAD_DEADLOCK_DETECTOR) {\n+            if (EXCLUSIVE_LOCKS.get() == null) {\n+              EXCLUSIVE_LOCKS.set(new ArrayList<String>());\n             }\n-        } catch (DbException e) {\n-            getSchema().freeUniqueName(indexName);\n-            try {\n-                index.remove(session);\n-            } catch (DbException e2) {\n-                // this could happen, for example on failure in the storage\n-                // but if that is not the case it means\n-                // there is something wrong with the database\n-                trace.error(e2, \"could not remove index\");\n-                throw e2;\n+            EXCLUSIVE_LOCKS.get().add(getName());\n+          }\n+          return true;\n+        }\n+      } else {\n+        if (lockSharedSessions.putIfAbsent(session, session) == null) {\n+          traceLock(session, exclusive, TraceLockEvent.TRACE_LOCK_OK, NO_EXTRA_INFO);\n+          session.registerTableAsLocked(this);\n+          if (SysProperties.THREAD_DEADLOCK_DETECTOR) {\n+            ArrayList<String> list = SHARED_LOCKS.get();\n+            if (list == null) {\n+              list = new ArrayList<>();\n+              SHARED_LOCKS.set(list);\n             }\n-            throw e;\n+            list.add(getName());\n+          }\n         }\n-    }\n-\n-    private void rebuildIndexBlockMerge(Session session, MVIndex<?,?> index) {\n-        if (index instanceof MVSpatialIndex) {\n-            // the spatial index doesn't support multi-way merge sort\n-            rebuildIndexBuffered(session, index);\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private void traceLock(Session session, boolean exclusive, TraceLockEvent eventEnum, String extraInfo) {\n+    if (traceLock.isDebugEnabled()) {\n+      traceLock.debug(\"{0} {1} {2} {3} {4}\", session.getId(),\n+          exclusive ? \"exclusive write lock\" : \"shared read lock\", eventEnum.getEventText(),\n+          getName(), extraInfo);\n+    }\n+  }\n+\n+  @Override\n+  public void unlock(Session s) {\n+    if (database != null) {\n+      boolean wasLocked = lockExclusiveSession == s;\n+      traceLock(s, wasLocked, TraceLockEvent.TRACE_LOCK_UNLOCK, NO_EXTRA_INFO);\n+      if (wasLocked) {\n+        lockSharedSessions.remove(s);\n+        lockExclusiveSession = null;\n+        if (SysProperties.THREAD_DEADLOCK_DETECTOR) {\n+          if (EXCLUSIVE_LOCKS.get() != null) {\n+            EXCLUSIVE_LOCKS.get().remove(getName());\n+          }\n         }\n-        // Read entries in memory, sort them, write to a new map (in sorted\n-        // order); repeat (using a new map for every block of 1 MB) until all\n-        // record are read. Merge all maps to the target (using merge sort;\n-        // duplicates are detected in the target). For randomly ordered data,\n-        // this should use relatively few write operations.\n-        // A possible optimization is: change the buffer size from \"row count\"\n-        // to \"amount of memory\", and buffer index keys instead of rows.\n-        Index scan = getScanIndex(session);\n-        long remaining = scan.getRowCount(session);\n-        long total = remaining;\n-        Cursor cursor = scan.find(session, null, null);\n-        long i = 0;\n-        Store store = session.getDatabase().getStore();\n-\n-        int bufferSize = database.getMaxMemoryRows() / 2;\n-        ArrayList<Row> buffer = new ArrayList<>(bufferSize);\n-        String n = getName() + \":\" + index.getName();\n-        int t = MathUtils.convertLongToInt(total);\n-        ArrayList<String> bufferNames = Utils.newSmallArrayList();\n-        while (cursor.next()) {\n-            Row row = cursor.get();\n-            buffer.add(row);\n-            database.setProgress(DatabaseEventListener.STATE_CREATE_INDEX, n,\n-                    MathUtils.convertLongToInt(i++), t);\n-            if (buffer.size() >= bufferSize) {\n-                sortRows(buffer, index);\n-                String mapName = store.nextTemporaryMapName();\n-                index.addRowsToBuffer(buffer, mapName);\n-                bufferNames.add(mapName);\n-                buffer.clear();\n-            }\n-            remaining--;\n+      } else {\n+        wasLocked = lockSharedSessions.remove(s) != null;\n+        if (SysProperties.THREAD_DEADLOCK_DETECTOR) {\n+          if (SHARED_LOCKS.get() != null) {\n+            SHARED_LOCKS.get().remove(getName());\n+          }\n         }\n+      }\n+      if (wasLocked && !waitingSessions.isEmpty()) {\n+        synchronized (this) {\n+          notifyAll();\n+        }\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void close(Session session) {\n+    // ignore\n+  }\n+\n+  @Override\n+  public Row getRow(Session session, long key) {\n+    return primaryIndex.getRow(session, key);\n+  }\n+\n+  @Override\n+  public Index addIndex(Session session, String indexName, int indexId,\n+                        IndexColumn[] cols, IndexType indexType, boolean create,\n+                        String indexComment) {\n+    if (indexType.isPrimaryKey()) {\n+      for (IndexColumn c : cols) {\n+        Column column = c.column;\n+        if (column.isNullable()) {\n+          throw DbException.get(\n+              ErrorCode.COLUMN_MUST_NOT_BE_NULLABLE_1,\n+              column.getName());\n+        }\n+        column.setPrimaryKey(true);\n+      }\n+    }\n+    boolean isSessionTemporary = isTemporary() && !isGlobalTemporary();\n+    if (!isSessionTemporary) {\n+      database.lockMeta(session);\n+    }\n+    MVIndex index;\n+    int mainIndexColumn = primaryIndex.getMainIndexColumn() != SearchRow.ROWID_INDEX\n+        ? SearchRow.ROWID_INDEX : getMainIndexColumn(indexType, cols);\n+    if (database.isStarting()) {\n+      // if index does exists as a separate map it can't be a delegate\n+      if (transactionStore.hasMap(\"index.\" + indexId)) {\n+        // we can not reuse primary index\n+        mainIndexColumn = SearchRow.ROWID_INDEX;\n+      }\n+    } else if (primaryIndex.getRowCountMax() != 0) {\n+      mainIndexColumn = SearchRow.ROWID_INDEX;\n+    }\n+\n+    if (mainIndexColumn != SearchRow.ROWID_INDEX) {\n+      primaryIndex.setMainIndexColumn(mainIndexColumn);\n+      index = new MVDelegateIndex(this, indexId, indexName, primaryIndex,\n+          indexType);\n+    } else if (indexType.isSpatial()) {\n+      index = new MVSpatialIndex(session.getDatabase(), this, indexId,\n+          indexName, cols, indexType);\n+    } else {\n+      index = new MVSecondaryIndex(session.getDatabase(), this, indexId,\n+          indexName, cols, indexType);\n+    }\n+    if (index.needRebuild()) {\n+      rebuildIndex(session, index, indexName);\n+    }\n+    index.setTemporary(isTemporary());\n+    if (index.getCreateSQL() != null) {\n+      index.setComment(indexComment);\n+      if (isSessionTemporary) {\n+        session.addLocalTempTableIndex(index);\n+      } else {\n+        database.addSchemaObject(session, index);\n+      }\n+    }\n+    indexes.add(index);\n+    setModified();\n+    return index;\n+  }\n+\n+  private void rebuildIndex(Session session, MVIndex index, String indexName) {\n+    try {\n+      if (session.getDatabase().getStore() == null ||\n+          index instanceof MVSpatialIndex) {\n+        // in-memory\n+        rebuildIndexBuffered(session, index);\n+      } else {\n+        rebuildIndexBlockMerge(session, index);\n+      }\n+    } catch (DbException e) {\n+      getSchema().freeUniqueName(indexName);\n+      try {\n+        index.remove(session);\n+      } catch (DbException e2) {\n+        // this could happen, for example on failure in the storage\n+        // but if that is not the case it means\n+        // there is something wrong with the database\n+        trace.error(e2, \"could not remove index\");\n+        throw e2;\n+      }\n+      throw e;\n+    }\n+  }\n+\n+  private void rebuildIndexBlockMerge(Session session, MVIndex<?, ?> index) {\n+    if (index instanceof MVSpatialIndex) {\n+      // the spatial index doesn't support multi-way merge sort\n+      rebuildIndexBuffered(session, index);\n+    }\n+    // Read entries in memory, sort them, write to a new map (in sorted\n+    // order); repeat (using a new map for every block of 1 MB) until all\n+    // record are read. Merge all maps to the target (using merge sort;\n+    // duplicates are detected in the target). For randomly ordered data,\n+    // this should use relatively few write operations.\n+    // A possible optimization is: change the buffer size from \"row count\"\n+    // to \"amount of memory\", and buffer index keys instead of rows.\n+    Index scan = getScanIndex(session);\n+    long remaining = scan.getRowCount(session);\n+    long total = remaining;\n+    Cursor cursor = scan.find(session, null, null);\n+    long i = 0;\n+    Store store = session.getDatabase().getStore();\n+\n+    int bufferSize = database.getMaxMemoryRows() / 2;\n+    ArrayList<Row> buffer = new ArrayList<>(bufferSize);\n+    String n = getName() + \":\" + index.getName();\n+    int t = MathUtils.convertLongToInt(total);\n+    ArrayList<String> bufferNames = Utils.newSmallArrayList();\n+    while (cursor.next()) {\n+      Row row = cursor.get();\n+      buffer.add(row);\n+      database.setProgress(DatabaseEventListener.STATE_CREATE_INDEX, n,\n+          MathUtils.convertLongToInt(i++), t);\n+      if (buffer.size() >= bufferSize) {\n         sortRows(buffer, index);\n-        if (!bufferNames.isEmpty()) {\n-            String mapName = store.nextTemporaryMapName();\n-            index.addRowsToBuffer(buffer, mapName);\n-            bufferNames.add(mapName);\n-            buffer.clear();\n-            index.addBufferedRows(bufferNames);\n-        } else {\n-            addRowsToIndex(session, buffer, index);\n-        }\n-        if (remaining != 0) {\n-            throw DbException.throwInternalError(\"rowcount remaining=\" + remaining +\n-                    \" \" + getName());\n-        }\n-    }\n-\n-    private void rebuildIndexBuffered(Session session, Index index) {\n-        Index scan = getScanIndex(session);\n-        long remaining = scan.getRowCount(session);\n-        long total = remaining;\n-        Cursor cursor = scan.find(session, null, null);\n-        long i = 0;\n-        int bufferSize = (int) Math.min(total, database.getMaxMemoryRows());\n-        ArrayList<Row> buffer = new ArrayList<>(bufferSize);\n-        String n = getName() + \":\" + index.getName();\n-        int t = MathUtils.convertLongToInt(total);\n-        while (cursor.next()) {\n-            Row row = cursor.get();\n-            buffer.add(row);\n-            database.setProgress(DatabaseEventListener.STATE_CREATE_INDEX, n,\n-                    MathUtils.convertLongToInt(i++), t);\n-            if (buffer.size() >= bufferSize) {\n-                addRowsToIndex(session, buffer, index);\n-            }\n-            remaining--;\n-        }\n+        String mapName = store.nextTemporaryMapName();\n+        index.addRowsToBuffer(buffer, mapName);\n+        bufferNames.add(mapName);\n+        buffer.clear();\n+      }\n+      remaining--;\n+    }\n+    sortRows(buffer, index);\n+    if (!bufferNames.isEmpty()) {\n+      String mapName = store.nextTemporaryMapName();\n+      index.addRowsToBuffer(buffer, mapName);\n+      bufferNames.add(mapName);\n+      buffer.clear();\n+      index.addBufferedRows(bufferNames);\n+    } else {\n+      addRowsToIndex(session, buffer, index);\n+    }\n+    if (remaining != 0) {\n+      throw DbException.throwInternalError(\"rowcount remaining=\" + remaining +\n+          \" \" + getName());\n+    }\n+  }\n+\n+  private void rebuildIndexBuffered(Session session, Index index) {\n+    Index scan = getScanIndex(session);\n+    long remaining = scan.getRowCount(session);\n+    long total = remaining;\n+    Cursor cursor = scan.find(session, null, null);\n+    long i = 0;\n+    int bufferSize = (int) Math.min(total, database.getMaxMemoryRows());\n+    ArrayList<Row> buffer = new ArrayList<>(bufferSize);\n+    String n = getName() + \":\" + index.getName();\n+    int t = MathUtils.convertLongToInt(total);\n+    while (cursor.next()) {\n+      Row row = cursor.get();\n+      buffer.add(row);\n+      database.setProgress(DatabaseEventListener.STATE_CREATE_INDEX, n,\n+          MathUtils.convertLongToInt(i++), t);\n+      if (buffer.size() >= bufferSize) {\n         addRowsToIndex(session, buffer, index);\n-        if (remaining != 0) {\n-            DbException.throwInternalError(\"rowcount remaining=\" + remaining +\n-                    \" \" + getName());\n-        }\n-    }\n-\n-    @Override\n-    public void removeRow(Session session, Row row) {\n-        syncLastModificationIdWithDatabase();\n-        Transaction t = session.getTransaction();\n-        long savepoint = t.setSavepoint();\n-        try {\n-            for (int i = indexes.size() - 1; i >= 0; i--) {\n-                Index index = indexes.get(i);\n-                index.remove(session, row);\n-            }\n-        } catch (Throwable e) {\n-            try {\n-                t.rollbackToSavepoint(savepoint);\n-            } catch (Throwable nested) {\n-                e.addSuppressed(nested);\n-            }\n-            throw DbException.convert(e);\n-        }\n-        analyzeIfRequired(session);\n-    }\n-\n-    @Override\n-    public void truncate(Session session) {\n-        syncLastModificationIdWithDatabase();\n-        for (int i = indexes.size() - 1; i >= 0; i--) {\n-            Index index = indexes.get(i);\n-            index.truncate(session);\n-        }\n-        if (changesUntilAnalyze != null) {\n-            changesUntilAnalyze.set(nextAnalyze);\n-        }\n-    }\n-\n-    @Override\n-    public void addRow(Session session, Row row) {\n-        syncLastModificationIdWithDatabase();\n-        Transaction t = session.getTransaction();\n-        long savepoint = t.setSavepoint();\n-        try {\n-            for (Index index : indexes) {\n-                index.add(session, row);\n-            }\n-        } catch (Throwable e) {\n-            try {\n-                t.rollbackToSavepoint(savepoint);\n-            } catch (Throwable nested) {\n-                e.addSuppressed(nested);\n-            }\n-            throw DbException.convert(e);\n-        }\n-        analyzeIfRequired(session);\n-    }\n-\n-    @Override\n-    public void updateRow(Session session, Row oldRow, Row newRow) {\n-        newRow.setKey(oldRow.getKey());\n-        syncLastModificationIdWithDatabase();\n-        Transaction t = session.getTransaction();\n-        long savepoint = t.setSavepoint();\n-        try {\n-            for (Index index : indexes) {\n-                index.update(session, oldRow, newRow);\n-            }\n-        } catch (Throwable e) {\n-            try {\n-                t.rollbackToSavepoint(savepoint);\n-            } catch (Throwable nested) {\n-                e.addSuppressed(nested);\n-            }\n-            throw DbException.convert(e);\n-        }\n-        analyzeIfRequired(session);\n-    }\n-\n-    @Override\n-    public Row lockRow(Session session, Row row) {\n-        Row lockedRow = primaryIndex.lockRow(session, row);\n-        if (lockedRow == null || !row.hasSharedData(lockedRow)) {\n-            syncLastModificationIdWithDatabase();\n-        }\n-        return lockedRow;\n-    }\n-\n-    private void analyzeIfRequired(Session session) {\n-        if (changesUntilAnalyze != null) {\n-            if (changesUntilAnalyze.decrementAndGet() == 0) {\n-                if (nextAnalyze <= Integer.MAX_VALUE / 2) {\n-                    nextAnalyze *= 2;\n-                }\n-                changesUntilAnalyze.set(nextAnalyze);\n-                session.markTableForAnalyze(this);\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public Index getScanIndex(Session session) {\n-        return primaryIndex;\n-    }\n-\n-    @Override\n-    public Index getUniqueIndex() {\n-        return primaryIndex;\n-    }\n-\n-    @Override\n-    public ArrayList<Index> getIndexes() {\n-        return indexes;\n-    }\n-\n-    @Override\n-    public long getMaxDataModificationId() {\n-        return lastModificationId.get();\n-    }\n-\n-    @Override\n-    public void removeChildrenAndResources(Session session) {\n-        if (containsLargeObject) {\n-            // unfortunately, the data is gone on rollback\n-            truncate(session);\n-            database.getLobStorage().removeAllForTable(getId());\n-            database.lockMeta(session);\n-        }\n-        database.getStore().removeTable(this);\n-        super.removeChildrenAndResources(session);\n-        // remove scan index (at position 0 on the list) last\n-        while (indexes.size() > 1) {\n-            Index index = indexes.get(1);\n-            index.remove(session);\n-            if (index.getName() != null) {\n-                database.removeSchemaObject(session, index);\n-            }\n-            // needed for session temporary indexes\n-            indexes.remove(index);\n-        }\n-        primaryIndex.remove(session);\n-        indexes.clear();\n-        if (SysProperties.CHECK) {\n-            for (SchemaObject obj : database\n-                    .getAllSchemaObjects(DbObject.INDEX)) {\n-                Index index = (Index) obj;\n-                if (index.getTable() == this) {\n-                    DbException.throwInternalError(\"index not dropped: \" +\n-                            index.getName());\n-                }\n-            }\n-        }\n-        close(session);\n-        invalidate();\n-    }\n-\n-    @Override\n-    public long getRowCount(Session session) {\n-        return primaryIndex.getRowCount(session);\n-    }\n-\n-    @Override\n-    public long getRowCountApproximation() {\n-        return primaryIndex.getRowCountApproximation();\n-    }\n-\n-    @Override\n-    public long getDiskSpaceUsed() {\n-        return primaryIndex.getDiskSpaceUsed();\n-    }\n-\n-    /**\n-     * Get a new transaction.\n-     *\n-     * @return the transaction\n-     */\n-    Transaction getTransactionBegin() {\n-        // TODO need to commit/rollback the transaction\n-        return transactionStore.begin();\n-    }\n-\n-    @Override\n-    public boolean isMVStore() {\n-        return true;\n-    }\n-\n-    /**\n-     * Mark the transaction as committed, so that the modification counter of\n-     * the database is incremented.\n-     */\n-    public void commit() {\n-        if (database != null) {\n-            syncLastModificationIdWithDatabase();\n-        }\n-    }\n-\n-    // Field lastModificationId can not be just a volatile, because window of opportunity\n-    // between reading database's modification id and storing this value in the field\n-    // could be exploited by another thread.\n-    // Second thread may do the same with possibly bigger (already advanced)\n-    // modification id, and when first thread finally updates the field, it will\n-    // result in lastModificationId jumping back.\n-    // This is, of course, unacceptable.\n-    private void syncLastModificationIdWithDatabase() {\n-        long nextModificationDataId = database.getNextModificationDataId();\n-        long currentId;\n-        do {\n-            currentId = lastModificationId.get();\n-        } while (nextModificationDataId > currentId &&\n-                !lastModificationId.compareAndSet(currentId, nextModificationDataId));\n-    }\n-\n-    /**\n-     * Convert the illegal state exception to a database exception.\n-     *\n-     * @param e the illegal state exception\n-     * @return the database exception\n-     */\n-    DbException convertException(IllegalStateException e) {\n-        int errorCode = DataUtils.getErrorCode(e.getMessage());\n-        if (errorCode == DataUtils.ERROR_TRANSACTION_LOCKED) {\n-            throw DbException.get(ErrorCode.CONCURRENT_UPDATE_1,\n-                    e, getName());\n-        }\n-        if (errorCode == DataUtils.ERROR_TRANSACTIONS_DEADLOCK) {\n-            throw DbException.get(ErrorCode.DEADLOCK_1,\n-                    e, getName());\n-        }\n-        return store.convertIllegalStateException(e);\n-    }\n+      }\n+      remaining--;\n+    }\n+    addRowsToIndex(session, buffer, index);\n+    if (remaining != 0) {\n+      DbException.throwInternalError(\"rowcount remaining=\" + remaining +\n+          \" \" + getName());\n+    }\n+  }\n+\n+  @Override\n+  public void removeRow(Session session, Row row) {\n+    syncLastModificationIdWithDatabase();\n+    Transaction t = session.getTransaction();\n+    long savepoint = t.setSavepoint();\n+    try {\n+      for (int i = indexes.size() - 1; i >= 0; i--) {\n+        Index index = indexes.get(i);\n+        index.remove(session, row);\n+      }\n+    } catch (Throwable e) {\n+      try {\n+        t.rollbackToSavepoint(savepoint);\n+      } catch (Throwable nested) {\n+        e.addSuppressed(nested);\n+      }\n+      throw DbException.convert(e);\n+    }\n+    analyzeIfRequired(session);\n+  }\n+\n+  @Override\n+  public void truncate(Session session) {\n+    syncLastModificationIdWithDatabase();\n+    for (int i = indexes.size() - 1; i >= 0; i--) {\n+      Index index = indexes.get(i);\n+      index.truncate(session);\n+    }\n+    if (changesUntilAnalyze != null) {\n+      changesUntilAnalyze.set(nextAnalyze);\n+    }\n+  }\n+\n+  @Override\n+  public void addRow(Session session, Row row) {\n+    syncLastModificationIdWithDatabase();\n+    Transaction t = session.getTransaction();\n+    long savepoint = t.setSavepoint();\n+    try {\n+      for (Index index : indexes) {\n+        index.add(session, row);\n+      }\n+    } catch (Throwable e) {\n+      try {\n+        t.rollbackToSavepoint(savepoint);\n+      } catch (Throwable nested) {\n+        e.addSuppressed(nested);\n+      }\n+      throw DbException.convert(e);\n+    }\n+    analyzeIfRequired(session);\n+  }\n+\n+  @Override\n+  public void updateRow(Session session, Row oldRow, Row newRow) {\n+    newRow.setKey(oldRow.getKey());\n+    syncLastModificationIdWithDatabase();\n+    Transaction t = session.getTransaction();\n+    long savepoint = t.setSavepoint();\n+    try {\n+      for (Index index : indexes) {\n+        index.update(session, oldRow, newRow);\n+      }\n+    } catch (Throwable e) {\n+      try {\n+        t.rollbackToSavepoint(savepoint);\n+      } catch (Throwable nested) {\n+        e.addSuppressed(nested);\n+      }\n+      throw DbException.convert(e);\n+    }\n+    analyzeIfRequired(session);\n+  }\n+\n+  @Override\n+  public Row lockRow(Session session, Row row) {\n+    Row lockedRow = primaryIndex.lockRow(session, row);\n+    if (lockedRow == null || !row.hasSharedData(lockedRow)) {\n+      syncLastModificationIdWithDatabase();\n+    }\n+    return lockedRow;\n+  }\n+\n+  private void analyzeIfRequired(Session session) {\n+    if (changesUntilAnalyze != null) {\n+      if (changesUntilAnalyze.decrementAndGet() == 0) {\n+        if (nextAnalyze <= Integer.MAX_VALUE / 2) {\n+          nextAnalyze *= 2;\n+        }\n+        changesUntilAnalyze.set(nextAnalyze);\n+        session.markTableForAnalyze(this);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public Index getScanIndex(Session session) {\n+    return primaryIndex;\n+  }\n+\n+  @Override\n+  public Index getUniqueIndex() {\n+    return primaryIndex;\n+  }\n+\n+  @Override\n+  public ArrayList<Index> getIndexes() {\n+    return indexes;\n+  }\n+\n+  @Override\n+  public long getMaxDataModificationId() {\n+    return lastModificationId.get();\n+  }\n+\n+  @Override\n+  public void removeChildrenAndResources(Session session) {\n+    if (containsLargeObject) {\n+      // unfortunately, the data is gone on rollback\n+      truncate(session);\n+      database.getLobStorage().removeAllForTable(getId());\n+      database.lockMeta(session);\n+    }\n+    database.getStore().removeTable(this);\n+    super.removeChildrenAndResources(session);\n+    // remove scan index (at position 0 on the list) last\n+    while (indexes.size() > 1) {\n+      Index index = indexes.get(1);\n+      index.remove(session);\n+      if (index.getName() != null) {\n+        database.removeSchemaObject(session, index);\n+      }\n+      // needed for session temporary indexes\n+      indexes.remove(index);\n+    }\n+    primaryIndex.remove(session);\n+    indexes.clear();\n+    if (SysProperties.CHECK) {\n+      for (SchemaObject obj : database\n+          .getAllSchemaObjects(DbObject.INDEX)) {\n+        Index index = (Index) obj;\n+        if (index.getTable() == this) {\n+          DbException.throwInternalError(\"index not dropped: \" +\n+              index.getName());\n+        }\n+      }\n+    }\n+    close(session);\n+    invalidate();\n+  }\n+\n+  @Override\n+  public long getRowCount(Session session) {\n+    return primaryIndex.getRowCount(session);\n+  }\n+\n+  @Override\n+  public long getRowCountApproximation() {\n+    return primaryIndex.getRowCountApproximation();\n+  }\n+\n+  @Override\n+  public long getDiskSpaceUsed() {\n+    return primaryIndex.getDiskSpaceUsed();\n+  }\n+\n+  /**\n+   * Get a new transaction.\n+   *\n+   * @return the transaction\n+   */\n+  Transaction getTransactionBegin() {\n+    // TODO need to commit/rollback the transaction\n+    return transactionStore.begin();\n+  }\n+\n+  @Override\n+  public boolean isMVStore() {\n+    return true;\n+  }\n+\n+  /**\n+   * Mark the transaction as committed, so that the modification counter of\n+   * the database is incremented.\n+   */\n+  public void commit() {\n+    if (database != null) {\n+      syncLastModificationIdWithDatabase();\n+    }\n+  }\n+\n+  // Field lastModificationId can not be just a volatile, because window of opportunity\n+  // between reading database's modification id and storing this value in the field\n+  // could be exploited by another thread.\n+  // Second thread may do the same with possibly bigger (already advanced)\n+  // modification id, and when first thread finally updates the field, it will\n+  // result in lastModificationId jumping back.\n+  // This is, of course, unacceptable.\n+  private void syncLastModificationIdWithDatabase() {\n+    long nextModificationDataId = database.getNextModificationDataId();\n+    long currentId;\n+    do {\n+      currentId = lastModificationId.get();\n+    } while (nextModificationDataId > currentId &&\n+        !lastModificationId.compareAndSet(currentId, nextModificationDataId));\n+  }\n+\n+  /**\n+   * Convert the illegal state exception to a database exception.\n+   *\n+   * @param e the illegal state exception\n+   * @return the database exception\n+   */\n+  DbException convertException(IllegalStateException e) {\n+    int errorCode = DataUtils.getErrorCode(e.getMessage());\n+    if (errorCode == DataUtils.ERROR_TRANSACTION_LOCKED) {\n+      throw DbException.get(ErrorCode.CONCURRENT_UPDATE_1,\n+          e, getName());\n+    }\n+    if (errorCode == DataUtils.ERROR_TRANSACTIONS_DEADLOCK) {\n+      throw DbException.get(ErrorCode.DEADLOCK_1,\n+          e, getName());\n+    }\n+    return store.convertIllegalStateException(e);\n+  }\n }\n",
            "diff_size": 864
        },
        {
            "tool": "naturalize",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/53/MVTable.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/naturalize/53/MVTable.java\nindex 9aaf01bb0c0..52447a14591 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/53/MVTable.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/naturalize/53/MVTable.java\n@@ -59,7 +59,7 @@ public class MVTable extends RegularTable {\n     /**\n      * The type of trace lock events\n      */\n-    private enum TraceLockEvent{\n+    private enum TraceLockEvent {\n \n         TRACE_LOCK_OK(\"ok\"),\n         TRACE_LOCK_WAITING_FOR(\"waiting for\"),\n@@ -79,7 +79,8 @@ public class MVTable extends RegularTable {\n             return eventText;\n         }\n     }\n-    private static final String NO_EXTRA_INFO = \"\";\n+\n+private static final String NO_EXTRA_INFO = \"\";\n \n     static {\n         if (SysProperties.THREAD_DEADLOCK_DETECTOR) {\n@@ -343,8 +344,7 @@ public class MVTable extends RegularTable {\n             database.lockMeta(session);\n         }\n         MVIndex index;\n-        int mainIndexColumn = primaryIndex.getMainIndexColumn() != SearchRow.ROWID_INDEX\n-                ? SearchRow.ROWID_INDEX : getMainIndexColumn(indexType, cols);\n+        int mainIndexColumn = primaryIndex.getMainIndexColumn() != SearchRow.ROWID_INDEX ? SearchRow.ROWID_INDEX : getMainIndexColumn(indexType, cols);\n         if (database.isStarting()) {\n             // if index does exists as a separate map it can't be a delegate\n             if (transactionStore.hasMap(\"index.\" + indexId)) {\n@@ -407,7 +407,7 @@ public class MVTable extends RegularTable {\n         }\n     }\n \n-    private void rebuildIndexBlockMerge(Session session, MVIndex<?,?> index) {\n+    private void rebuildIndexBlockMerge(Session session, MVIndex<?, ?> index) {\n         if (index instanceof MVSpatialIndex) {\n             // the spatial index doesn't support multi-way merge sort\n             rebuildIndexBuffered(session, index);\n@@ -713,4 +713,4 @@ public class MVTable extends RegularTable {\n         }\n         return store.convertIllegalStateException(e);\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 7
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/53/MVTable.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/codebuff/53/MVTable.java\nindex 9aaf01bb0c0..0470cfe3ac1 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/53/MVTable.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/codebuff/53/MVTable.java\n@@ -10,7 +10,6 @@ import java.util.ArrayList;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicInteger;\n import java.util.concurrent.atomic.AtomicLong;\n-\n import org.h2.api.DatabaseEventListener;\n import org.h2.api.ErrorCode;\n import org.h2.command.ddl.CreateTableData;\n@@ -40,33 +39,46 @@ import org.h2.util.Utils;\n /**\n  * A table stored in a MVStore.\n  */\n+\n+\n public class MVTable extends RegularTable {\n     /**\n      * The table name this thread is waiting to lock.\n      */\n+\n+\n     public static final DebuggingThreadLocal<String> WAITING_FOR_LOCK;\n \n     /**\n      * The table names this thread has exclusively locked.\n      */\n+\n+\n     public static final DebuggingThreadLocal<ArrayList<String>> EXCLUSIVE_LOCKS;\n \n     /**\n      * The tables names this thread has a shared lock on.\n      */\n+\n+\n     public static final DebuggingThreadLocal<ArrayList<String>> SHARED_LOCKS;\n \n     /**\n      * The type of trace lock events\n      */\n-    private enum TraceLockEvent{\n-\n+    private enum TraceLockEvent {\n         TRACE_LOCK_OK(\"ok\"),\n+\n         TRACE_LOCK_WAITING_FOR(\"waiting for\"),\n+\n         TRACE_LOCK_REQUESTING_FOR(\"requesting for\"),\n+\n         TRACE_LOCK_TIMEOUT_AFTER(\"timeout after \"),\n+\n         TRACE_LOCK_UNLOCK(\"unlock\"),\n+\n         TRACE_LOCK_ADDED_FOR(\"added for\"),\n+\n         TRACE_LOCK_ADD_UPGRADED_FOR(\"add (upgraded) for \");\n \n         private final String eventText;\n@@ -75,17 +87,20 @@ public class MVTable extends RegularTable {\n             this.eventText = eventText;\n         }\n \n+\n         public String getEventText() {\n             return eventText;\n         }\n+\n     }\n+\n     private static final String NO_EXTRA_INFO = \"\";\n \n     static {\n         if (SysProperties.THREAD_DEADLOCK_DETECTOR) {\n-            WAITING_FOR_LOCK = new DebuggingThreadLocal<>();\n-            EXCLUSIVE_LOCKS = new DebuggingThreadLocal<>();\n-            SHARED_LOCKS = new DebuggingThreadLocal<>();\n+            WAITING_FOR_LOCK = new DebuggingThreadLocal< >();\n+            EXCLUSIVE_LOCKS = new DebuggingThreadLocal< >();\n+            SHARED_LOCKS = new DebuggingThreadLocal< >();\n         } else {\n             WAITING_FOR_LOCK = null;\n             EXCLUSIVE_LOCKS = null;\n@@ -101,11 +116,10 @@ public class MVTable extends RegularTable {\n      * The queue of sessions waiting to lock the table. It is a FIFO queue to\n      * prevent starvation, since Java's synchronized locking is biased.\n      */\n-    private final ArrayDeque<Session> waitingSessions = new ArrayDeque<>();\n+    private final ArrayDeque<Session> waitingSessions = new ArrayDeque< >();\n     private final Trace traceLock;\n     private final AtomicInteger changesUntilAnalyze;\n     private int nextAnalyze;\n-\n     private final MVTableEngine.Store store;\n     private final TransactionStore transactionStore;\n \n@@ -116,19 +130,17 @@ public class MVTable extends RegularTable {\n         this.store = store;\n         this.transactionStore = store.getTransactionStore();\n         traceLock = database.getTrace(Trace.LOCK);\n-\n-        primaryIndex = new MVPrimaryIndex(database, this, getId(),\n-                IndexColumn.wrap(getColumns()), IndexType.createScan(true));\n+        primaryIndex = new MVPrimaryIndex(database, this, getId(), IndexColumn.wrap(getColumns()), IndexType.createScan(true));\n         indexes.add(primaryIndex);\n     }\n \n+\n     public String getMapName() {\n         return primaryIndex.getMapName();\n     }\n \n     @Override\n-    public boolean lock(Session session, boolean exclusive,\n-            boolean forceLockEvenInMvcc) {\n+    public boolean lock(Session session, boolean exclusive, boolean forceLockEvenInMvcc) {\n         int lockMode = database.getLockMode();\n         if (lockMode == Constants.LOCK_MODE_OFF) {\n             session.registerTableAsUpdated(this);\n@@ -190,8 +202,7 @@ public class MVTable extends RegularTable {\n             if (checkDeadlock) {\n                 ArrayList<Session> sessions = checkDeadlock(session, null, null);\n                 if (sessions != null) {\n-                    throw DbException.get(ErrorCode.DEADLOCK_1,\n-                            getDeadlockDetails(sessions, exclusive));\n+                    throw DbException.get(ErrorCode.DEADLOCK_1, getDeadlockDetails(sessions, exclusive));\n                 }\n             } else {\n                 // check for deadlocks from now on\n@@ -202,8 +213,7 @@ public class MVTable extends RegularTable {\n                 // try at least one more time\n                 max = now + TimeUnit.MILLISECONDS.toNanos(session.getLockTimeout());\n             } else if (now >= max) {\n-                traceLock(session, exclusive,\n-                        TraceLockEvent.TRACE_LOCK_TIMEOUT_AFTER, NO_EXTRA_INFO+session.getLockTimeout());\n+                traceLock(session, exclusive, TraceLockEvent.TRACE_LOCK_TIMEOUT_AFTER, NO_EXTRA_INFO + session.getLockTimeout());\n                 throw DbException.get(ErrorCode.LOCK_TIMEOUT_1, getName());\n             }\n             try {\n@@ -219,14 +229,14 @@ public class MVTable extends RegularTable {\n                     }\n                 }\n                 // don't wait too long so that deadlocks are detected early\n-                long sleep = Math.min(Constants.DEADLOCK_CHECK,\n-                        TimeUnit.NANOSECONDS.toMillis(max - now));\n+                long sleep = Math.min(Constants.DEADLOCK_CHECK, TimeUnit.NANOSECONDS.toMillis(max - now));\n                 if (sleep == 0) {\n                     sleep = 1;\n                 }\n                 wait(sleep);\n             } catch (InterruptedException e) {\n                 // ignore\n+\n             }\n         }\n     }\n@@ -245,8 +255,7 @@ public class MVTable extends RegularTable {\n                         EXCLUSIVE_LOCKS.get().add(getName());\n                     }\n                     return true;\n-                } else if (lockSharedSessions.size() == 1 &&\n-                        lockSharedSessions.containsKey(session)) {\n+                } else if (lockSharedSessions.size() == 1 && lockSharedSessions.containsKey(session)) {\n                     traceLock(session, exclusive, TraceLockEvent.TRACE_LOCK_ADD_UPGRADED_FOR, NO_EXTRA_INFO);\n                     lockExclusiveSession = session;\n                     if (SysProperties.THREAD_DEADLOCK_DETECTOR) {\n@@ -264,7 +273,7 @@ public class MVTable extends RegularTable {\n                     if (SysProperties.THREAD_DEADLOCK_DETECTOR) {\n                         ArrayList<String> list = SHARED_LOCKS.get();\n                         if (list == null) {\n-                            list = new ArrayList<>();\n+                            list = new ArrayList< >();\n                             SHARED_LOCKS.set(list);\n                         }\n                         list.add(getName());\n@@ -278,9 +287,7 @@ public class MVTable extends RegularTable {\n \n     private void traceLock(Session session, boolean exclusive, TraceLockEvent eventEnum, String extraInfo) {\n         if (traceLock.isDebugEnabled()) {\n-            traceLock.debug(\"{0} {1} {2} {3} {4}\", session.getId(),\n-                    exclusive ? \"exclusive write lock\" : \"shared read lock\", eventEnum.getEventText(),\n-                    getName(), extraInfo);\n+            traceLock.debug(\"{0} {1} {2} {3} {4}\", session.getId(), exclusive ? \"exclusive write lock\" : \"shared read lock\", eventEnum.getEventText(), getName(), extraInfo);\n         }\n     }\n \n@@ -316,6 +323,7 @@ public class MVTable extends RegularTable {\n     @Override\n     public void close(Session session) {\n         // ignore\n+\n     }\n \n     @Override\n@@ -324,16 +332,12 @@ public class MVTable extends RegularTable {\n     }\n \n     @Override\n-    public Index addIndex(Session session, String indexName, int indexId,\n-            IndexColumn[] cols, IndexType indexType, boolean create,\n-            String indexComment) {\n+    public Index addIndex(Session session, String indexName, int indexId, IndexColumn[] cols, IndexType indexType, boolean create, String indexComment) {\n         if (indexType.isPrimaryKey()) {\n             for (IndexColumn c : cols) {\n                 Column column = c.column;\n                 if (column.isNullable()) {\n-                    throw DbException.get(\n-                            ErrorCode.COLUMN_MUST_NOT_BE_NULLABLE_1,\n-                            column.getName());\n+                    throw DbException.get(ErrorCode.COLUMN_MUST_NOT_BE_NULLABLE_1, column.getName());\n                 }\n                 column.setPrimaryKey(true);\n             }\n@@ -343,8 +347,7 @@ public class MVTable extends RegularTable {\n             database.lockMeta(session);\n         }\n         MVIndex index;\n-        int mainIndexColumn = primaryIndex.getMainIndexColumn() != SearchRow.ROWID_INDEX\n-                ? SearchRow.ROWID_INDEX : getMainIndexColumn(indexType, cols);\n+        int mainIndexColumn = primaryIndex.getMainIndexColumn() != SearchRow.ROWID_INDEX ? SearchRow.ROWID_INDEX : getMainIndexColumn(indexType, cols);\n         if (database.isStarting()) {\n             // if index does exists as a separate map it can't be a delegate\n             if (transactionStore.hasMap(\"index.\" + indexId)) {\n@@ -354,17 +357,13 @@ public class MVTable extends RegularTable {\n         } else if (primaryIndex.getRowCountMax() != 0) {\n             mainIndexColumn = SearchRow.ROWID_INDEX;\n         }\n-\n         if (mainIndexColumn != SearchRow.ROWID_INDEX) {\n             primaryIndex.setMainIndexColumn(mainIndexColumn);\n-            index = new MVDelegateIndex(this, indexId, indexName, primaryIndex,\n-                    indexType);\n+            index = new MVDelegateIndex(this, indexId, indexName, primaryIndex, indexType);\n         } else if (indexType.isSpatial()) {\n-            index = new MVSpatialIndex(session.getDatabase(), this, indexId,\n-                    indexName, cols, indexType);\n-        } else {\n-            index = new MVSecondaryIndex(session.getDatabase(), this, indexId,\n-                    indexName, cols, indexType);\n+            index = new MVSpatialIndex(session.getDatabase(), this, indexId, indexName, cols, indexType);\n+                                                                                                                                                        } else {\n+            index = new MVSecondaryIndex(session.getDatabase(), this, indexId, indexName, cols, indexType);\n         }\n         if (index.needRebuild()) {\n             rebuildIndex(session, index, indexName);\n@@ -385,8 +384,7 @@ public class MVTable extends RegularTable {\n \n     private void rebuildIndex(Session session, MVIndex index, String indexName) {\n         try {\n-            if (session.getDatabase().getStore() == null ||\n-                    index instanceof MVSpatialIndex) {\n+            if (session.getDatabase().getStore() == null || index instanceof MVSpatialIndex) {\n                 // in-memory\n                 rebuildIndexBuffered(session, index);\n             } else {\n@@ -407,7 +405,7 @@ public class MVTable extends RegularTable {\n         }\n     }\n \n-    private void rebuildIndexBlockMerge(Session session, MVIndex<?,?> index) {\n+    private void rebuildIndexBlockMerge(Session session, MVIndex<?, ?> index) {\n         if (index instanceof MVSpatialIndex) {\n             // the spatial index doesn't support multi-way merge sort\n             rebuildIndexBuffered(session, index);\n@@ -425,17 +423,15 @@ public class MVTable extends RegularTable {\n         Cursor cursor = scan.find(session, null, null);\n         long i = 0;\n         Store store = session.getDatabase().getStore();\n-\n         int bufferSize = database.getMaxMemoryRows() / 2;\n-        ArrayList<Row> buffer = new ArrayList<>(bufferSize);\n+        ArrayList<Row> buffer = new ArrayList< >(bufferSize);\n         String n = getName() + \":\" + index.getName();\n         int t = MathUtils.convertLongToInt(total);\n         ArrayList<String> bufferNames = Utils.newSmallArrayList();\n         while (cursor.next()) {\n             Row row = cursor.get();\n             buffer.add(row);\n-            database.setProgress(DatabaseEventListener.STATE_CREATE_INDEX, n,\n-                    MathUtils.convertLongToInt(i++), t);\n+            database.setProgress(DatabaseEventListener.STATE_CREATE_INDEX, n, MathUtils.convertLongToInt(i++), t);\n             if (buffer.size() >= bufferSize) {\n                 sortRows(buffer, index);\n                 String mapName = store.nextTemporaryMapName();\n@@ -456,8 +452,7 @@ public class MVTable extends RegularTable {\n             addRowsToIndex(session, buffer, index);\n         }\n         if (remaining != 0) {\n-            throw DbException.throwInternalError(\"rowcount remaining=\" + remaining +\n-                    \" \" + getName());\n+            throw DbException.throwInternalError(\"rowcount remaining=\" + remaining + \" \" + getName());\n         }\n     }\n \n@@ -468,14 +463,13 @@ public class MVTable extends RegularTable {\n         Cursor cursor = scan.find(session, null, null);\n         long i = 0;\n         int bufferSize = (int) Math.min(total, database.getMaxMemoryRows());\n-        ArrayList<Row> buffer = new ArrayList<>(bufferSize);\n+        ArrayList<Row> buffer = new ArrayList< >(bufferSize);\n         String n = getName() + \":\" + index.getName();\n         int t = MathUtils.convertLongToInt(total);\n         while (cursor.next()) {\n             Row row = cursor.get();\n             buffer.add(row);\n-            database.setProgress(DatabaseEventListener.STATE_CREATE_INDEX, n,\n-                    MathUtils.convertLongToInt(i++), t);\n+            database.setProgress(DatabaseEventListener.STATE_CREATE_INDEX, n, MathUtils.convertLongToInt(i++), t);\n             if (buffer.size() >= bufferSize) {\n                 addRowsToIndex(session, buffer, index);\n             }\n@@ -483,8 +477,7 @@ public class MVTable extends RegularTable {\n         }\n         addRowsToIndex(session, buffer, index);\n         if (remaining != 0) {\n-            DbException.throwInternalError(\"rowcount remaining=\" + remaining +\n-                    \" \" + getName());\n+            DbException.throwInternalError(\"rowcount remaining=\" + remaining + \" \" + getName());\n         }\n     }\n \n@@ -626,12 +619,10 @@ public class MVTable extends RegularTable {\n         primaryIndex.remove(session);\n         indexes.clear();\n         if (SysProperties.CHECK) {\n-            for (SchemaObject obj : database\n-                    .getAllSchemaObjects(DbObject.INDEX)) {\n+            for (SchemaObject obj : database.getAllSchemaObjects(DbObject.INDEX)) {\n                 Index index = (Index) obj;\n                 if (index.getTable() == this) {\n-                    DbException.throwInternalError(\"index not dropped: \" +\n-                            index.getName());\n+                    DbException.throwInternalError(\"index not dropped: \" + index.getName());\n                 }\n             }\n         }\n@@ -659,6 +650,8 @@ public class MVTable extends RegularTable {\n      *\n      * @return the transaction\n      */\n+\n+\n     Transaction getTransactionBegin() {\n         // TODO need to commit/rollback the transaction\n         return transactionStore.begin();\n@@ -673,6 +666,8 @@ public class MVTable extends RegularTable {\n      * Mark the transaction as committed, so that the modification counter of\n      * the database is incremented.\n      */\n+\n+\n     public void commit() {\n         if (database != null) {\n             syncLastModificationIdWithDatabase();\n@@ -686,13 +681,13 @@ public class MVTable extends RegularTable {\n     // modification id, and when first thread finally updates the field, it will\n     // result in lastModificationId jumping back.\n     // This is, of course, unacceptable.\n+\n     private void syncLastModificationIdWithDatabase() {\n         long nextModificationDataId = database.getNextModificationDataId();\n         long currentId;\n         do {\n             currentId = lastModificationId.get();\n-        } while (nextModificationDataId > currentId &&\n-                !lastModificationId.compareAndSet(currentId, nextModificationDataId));\n+        } while (nextModificationDataId > currentId && !lastModificationId.compareAndSet(currentId, nextModificationDataId));\n     }\n \n     /**\n@@ -701,16 +696,17 @@ public class MVTable extends RegularTable {\n      * @param e the illegal state exception\n      * @return the database exception\n      */\n+\n+\n     DbException convertException(IllegalStateException e) {\n         int errorCode = DataUtils.getErrorCode(e.getMessage());\n         if (errorCode == DataUtils.ERROR_TRANSACTION_LOCKED) {\n-            throw DbException.get(ErrorCode.CONCURRENT_UPDATE_1,\n-                    e, getName());\n+            throw DbException.get(ErrorCode.CONCURRENT_UPDATE_1, e, getName());\n         }\n         if (errorCode == DataUtils.ERROR_TRANSACTIONS_DEADLOCK) {\n-            throw DbException.get(ErrorCode.DEADLOCK_1,\n-                    e, getName());\n+            throw DbException.get(ErrorCode.DEADLOCK_1, e, getName());\n         }\n         return store.convertIllegalStateException(e);\n     }\n-}\n+\n+}\n\\ No newline at end of file\n",
            "diff_size": 94
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/53/MVTable.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_random/53/MVTable.java\nindex 9aaf01bb0c0..40599b2e266 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/53/MVTable.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_random/53/MVTable.java\n@@ -407,7 +407,7 @@ public class MVTable extends RegularTable {\n         }\n     }\n \n-    private void rebuildIndexBlockMerge(Session session, MVIndex<?,?> index) {\n+    private void rebuildIndexBlockMerge(Session session, MVIndex<?, ?> index) {\n         if (index instanceof MVSpatialIndex) {\n             // the spatial index doesn't support multi-way merge sort\n             rebuildIndexBuffered(session, index);\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/53/MVTable.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/53/MVTable.java\nindex 9aaf01bb0c0..40599b2e266 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/53/MVTable.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/53/MVTable.java\n@@ -407,7 +407,7 @@ public class MVTable extends RegularTable {\n         }\n     }\n \n-    private void rebuildIndexBlockMerge(Session session, MVIndex<?,?> index) {\n+    private void rebuildIndexBlockMerge(Session session, MVIndex<?, ?> index) {\n         if (index instanceof MVSpatialIndex) {\n             // the spatial index doesn't support multi-way merge sort\n             rebuildIndexBuffered(session, index);\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": []
}