{
    "project_name": "intuit-Tank",
    "error_id": "189",
    "information": {
        "errors": [
            {
                "line": "39",
                "column": "1",
                "severity": "warning",
                "message": "File contains tab characters (this is the first instance).",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
            }
        ]
    },
    "source_code": "public interface Token extends TokenTypes {\n\n\t/**\n\t * Appends HTML code for painting this token, using the given text area's\n\t * color scheme.\n\t *",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "40",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/intuit-Tank/errored/1/189/Token.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/intuit-Tank/styler/189/Token.java\nindex 8ac6429eaf8..d592d80ba73 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/intuit-Tank/errored/1/189/Token.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/intuit-Tank/styler/189/Token.java\n@@ -36,7 +36,7 @@ import javax.swing.text.TabExpander;\n  */\n public interface Token extends TokenTypes {\n \n-\t/**\n+    /**\n \t * Appends HTML code for painting this token, using the given text area's\n \t * color scheme.\n \t *\n@@ -50,7 +50,7 @@ public interface Token extends TokenTypes {\n \t * @return The buffer appended to.\n \t * @see #getHTMLRepresentation(RSyntaxTextArea)\n \t */\n-\tStringBuilder appendHTMLRepresentation(StringBuilder sb,\n+ StringBuilder appendHTMLRepresentation(StringBuilder sb,\n \t\t\t\t\t\t\t\t\t\t\tRSyntaxTextArea textArea,\n \t\t\t\t\t\t\t\t\t\t\tboolean fontFamily);\n \n",
            "diff_size": 2
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/intuit-Tank/errored/1/189/Token.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/intuit-Tank/intellij/189/Token.java\nindex 8ac6429eaf8..baffb56d039 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/intuit-Tank/errored/1/189/Token.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/intuit-Tank/intellij/189/Token.java\n@@ -6,6 +6,7 @@\n  * This library is distributed under a modified BSD license.  See the included\n  * LICENSE file for details.\n  */\n+\n package org.fife.ui.rsyntaxtextarea;\n \n import java.awt.Rectangle;\n@@ -16,7 +17,7 @@ import javax.swing.text.TabExpander;\n /**\n  * A generic token that functions as a node in a linked list of syntax\n  * highlighted tokens for some language.<p>\n- *\n+ * <p>\n  * A <code>Token</code> is a piece of text representing some logical token in\n  * source code for a programming language.  For example, the line of C code:<p>\n  * <pre>\n@@ -36,532 +37,532 @@ import javax.swing.text.TabExpander;\n  */\n public interface Token extends TokenTypes {\n \n-\t/**\n-\t * Appends HTML code for painting this token, using the given text area's\n-\t * color scheme.\n-\t *\n-\t * @param sb The buffer to append to.\n-\t * @param textArea The text area whose color scheme to use.\n-\t * @param fontFamily Whether to include the font family in the HTML for\n-\t *        this token.  You can pass <code>false</code> for this parameter\n-\t *        if, for example, you are making all your HTML be monospaced,\n-\t *        and don't want any crazy fonts being used in the editor to be\n-\t *        reflected in your HTML.\n-\t * @return The buffer appended to.\n-\t * @see #getHTMLRepresentation(RSyntaxTextArea)\n-\t */\n-\tStringBuilder appendHTMLRepresentation(StringBuilder sb,\n-\t\t\t\t\t\t\t\t\t\t\tRSyntaxTextArea textArea,\n-\t\t\t\t\t\t\t\t\t\t\tboolean fontFamily);\n-\n-\n-\t/**\n-\t * Appends HTML code for painting this token, using the given text area's\n-\t * color scheme.\n-\t *\n-\t * @param sb The buffer to append to.\n-\t * @param textArea The text area whose color scheme to use.\n-\t * @param fontFamily Whether to include the font family in the HTML for\n-\t *        this token.  You can pass <code>false</code> for this parameter\n-\t *        if, for example, you are making all your HTML be monospaced,\n-\t *        and don't want any crazy fonts being used in the editor to be\n-\t *        reflected in your HTML.\n-\t * @param tabsToSpaces Whether to convert tabs into spaces.\n-\t * @return The buffer appended to.\n-\t * @see #getHTMLRepresentation(RSyntaxTextArea)\n-\t */\n-\tStringBuilder appendHTMLRepresentation(StringBuilder sb,\n-\t\t\t\t\t\t\t\tRSyntaxTextArea textArea, boolean fontFamily,\n-\t\t\t\t\t\t\t\tboolean tabsToSpaces);\n-\n-\n-\t/**\n-\t * Returns the character at the specified offset in the token.\n-\t *\n-\t * @param index The index.  This should be in the range\n-\t *        <code>0-({@link #length()}-1)</code>.\n-\t * @return The character.\n-\t * @see #length()\n-\t */\n-\tchar charAt(int index);\n-\n-\n-\t/**\n-\t * Returns whether the token straddles the specified position in the\n-\t * document.\n-\t *\n-\t * @param pos The position in the document to check.\n-\t * @return Whether the specified position is straddled by this token.\n-\t */\n-\tboolean containsPosition(int pos);\n-\n-\n-\t/**\n-\t * Returns the position in the token's internal char array corresponding\n-\t * to the specified document position.<p>\n-\t * Note that this method does NOT do any bounds checking; you can pass in\n-\t * a document position that does not correspond to a position in this\n-\t * token, and you will not receive an Exception or any other notification;\n-\t * it is up to the caller to ensure valid input.\n-\t *\n-\t * @param pos A position in the document that is represented by this token.\n-\t * @return The corresponding token position &gt;= <code>textOffset</code>\n-\t *         and &lt; <code>textOffset+textCount</code>.\n-\t * @see #tokenToDocument\n-\t */\n-\tint documentToToken(int pos);\n-\n-\n-\t/**\n-\t * Returns whether this token's lexeme ends with the specified characters.\n-\t *\n-\t * @param ch The characters.\n-\t * @return Whether this token's lexeme ends with the specified characters.\n-\t * @see #startsWith(char[])\n-\t */\n-\tboolean endsWith(char[] ch);\n-\n-\n-\t/**\n-\t * Returns the end offset of this token in the document (exclusive).  In\n-\t * other words, the token ranges from\n-\t * <code>[getOffset(), getEndOffset())</code>.\n-\t *\n-\t * @return The end offset of this token.\n-\t * @see #getOffset()\n-\t */\n-\tint getEndOffset();\n-\n-\n-\t/**\n-\t * Returns a <code>String</code> containing HTML code for painting this\n-\t * token, using the given text area's color scheme.\n-\t *\n-\t * @param textArea The text area whose color scheme to use.\n-\t * @return The HTML representation of the token.\n-\t * @see #appendHTMLRepresentation(StringBuilder, RSyntaxTextArea, boolean)\n-\t */\n-\tString getHTMLRepresentation(RSyntaxTextArea textArea);\n-\n-\n-\t/**\n-\t * Returns the language index of this token.\n-\t *\n-\t * @return The language index.  A value of <code>0</code> denotes the\n-\t *        \"main\" language, any positive value denotes a specific secondary\n-\t *        language.\n-\t * @see #setLanguageIndex(int)\n-\t */\n-\tint getLanguageIndex();\n-\n-\n-\t/**\n-\t * Returns the last token in this list that is not whitespace or a\n-\t * comment.\n-\t *\n-\t * @return The last non-comment, non-whitespace token, or <code>null</code>\n-\t *         if there isn't one.\n-\t */\n-\tToken getLastNonCommentNonWhitespaceToken();\n-\n-\n-\t/**\n-\t * Returns the last paintable token in this token list, or <code>null</code>\n-\t * if there is no paintable token.\n-\t *\n-\t * @return The last paintable token in this token list.\n-\t */\n-\tToken getLastPaintableToken();\n-\n-\n-\t/**\n-\t * Returns the text of this token, as a string.<p>\n-\t *\n-\t * Note that this method isn't used much by the\n-\t * <code>ryntaxtextarea</code> package internally, as it tries to limit\n-\t * memory allocation.\n-\t *\n-\t * @return The text of this token.\n-\t */\n-\tString getLexeme();\n-\n-\n-\t/**\n-\t * Determines the offset into this token list (i.e., into the\n-\t * document) that covers pixel location <code>x</code> if the token list\n-\t * starts at pixel location <code>x0</code><p>.\n-\t * This method will return the document position \"closest\" to the\n-\t * x-coordinate (i.e., if they click on the \"right-half\" of the\n-\t * <code>w</code> in <code>awe</code>, the caret will be placed in\n-\t * between the <code>w</code> and <code>e</code>; similarly, clicking on\n-\t * the left-half places the caret between the <code>a</code> and\n-\t * <code>w</code>).  This makes it useful for methods such as\n-\t * <code>viewToModel</code> found in <code>javax.swing.text.View</code>\n-\t * subclasses.\n-\t *\n-\t * @param textArea The text area from which the token list was derived.\n-\t * @param e How to expand tabs.\n-\t * @param x0 The pixel x-location that is the beginning of\n-\t *        <code>tokenList</code>.\n-\t * @param x The pixel-position for which you want to get the corresponding\n-\t *        offset.\n-\t * @return The position (in the document, NOT into the token list!) that\n-\t *         covers the pixel location.  If <code>tokenList</code> is\n-\t *         <code>null</code> or has type <code>Token.NULL</code>, then\n-\t *         <code>-1</code> is returned; the caller should recognize this and\n-\t *         return the actual end position of the (empty) line.\n-\t */\n-\tint getListOffset(RSyntaxTextArea textArea, TabExpander e,\n-\t\t\tfloat x0, float x);\n-\n-\n-\t/**\n-\t * Returns the token after this one in the linked list.\n-\t *\n-\t * @return The next token.\n-\t */\n-\tToken getNextToken();\n-\n-\n-\t/**\n-\t * Returns the offset into the document at which this token resides.\n-\t *\n-\t * @return The offset into the document.\n-\t * @see #getEndOffset()\n-\t */\n-\tint getOffset();\n-\n-\n-\t/**\n-\t * Returns the position in the document that represents the last character\n-\t * in the token that will fit into <code>endBeforeX-startX</code> pixels.\n-\t * For example, if you're using a monospaced 8-pixel-per-character font,\n-\t * have the token \"while\" and <code>startX</code> is <code>0</code> and\n-\t * <code>endBeforeX</code> is <code>30</code>, this method will return the\n-\t * document position of the \"i\" in \"while\", because the \"i\" ends at pixel\n-\t * <code>24</code>, while the \"l\" ends at <code>32</code>.  If not even the\n-\t * first character fits in <code>endBeforeX-startX</code>, the first\n-\t * character's position is still returned so calling methods don't go into\n-\t * infinite loops.\n-\t *\n-\t * @param textArea The text area in which this token is being painted.\n-\t * @param e How to expand tabs.\n-\t * @param startX The x-coordinate at which the token will be painted.  This\n-\t *        is needed because of tabs.\n-\t * @param endBeforeX The x-coordinate for which you want to find the last\n-\t *        character of <code>t</code> which comes before it.\n-\t * @return The last document position that will fit in the specified amount\n-\t *         of pixels.\n-\t */\n-\t/*\n-\t * @see #getTokenListOffsetBeforeX\n-\t * FIXME:  This method does not compute correctly!  It needs to be abstract\n-\t * and implemented by subclasses.\n-\t */\n-\tint getOffsetBeforeX(RSyntaxTextArea textArea, TabExpander e,\n-\t\t\t\t\t\t\tfloat startX, float endBeforeX);\n-\n-\n-\t/**\n-\t * Returns the character array backing the lexeme of this token.  This\n-\t * value should be treated as read-only.\n-\t *\n-\t * @return A character array containing the lexeme of this token.\n-\t * @see #getTextOffset()\n-\t * @see #length()\n-\t */\n-\tchar[] getTextArray();\n-\n-\n-\t/**\n-\t * Returns the offset into the character array of the lexeme in\n-\t * {@link #getTextArray()}.\n-\t *\n-\t * @return The offset of the lexeme in the character array.\n-\t * @see #getTextArray()\n-\t */\n-\tint getTextOffset();\n-\n-\n-\t/**\n-\t * Returns the type of this token.\n-\t *\n-\t * @return The type of this token.\n-\t * @see TokenTypes\n-\t * @see #setType(int)\n-\t */\n-\tint getType();\n-\n-\n-\t/**\n-\t * Returns the width of this token given the specified parameters.\n-\t *\n-\t * @param textArea The text area in which the token is being painted.\n-\t * @param e Describes how to expand tabs.  This parameter cannot be\n-\t *        <code>null</code>.\n-\t * @param x0 The pixel-location at which the token begins.  This is needed\n-\t *        because of tabs.\n-\t * @return The width of the token, in pixels.\n-\t * @see #getWidthUpTo\n-\t */\n-\tfloat getWidth(RSyntaxTextArea textArea, TabExpander e, float x0);\n-\n-\n-\t/**\n-\t * Returns the width of a specified number of characters in this token.\n-\t * For example, for the token \"while\", specifying a value of <code>3</code>\n-\t * here returns the width of the \"whi\" portion of the token.\n-\t *\n-\t * @param numChars The number of characters for which to get the width.\n-\t * @param textArea The text area in which the token is being painted.\n-\t * @param e How to expand tabs.  This value cannot be <code>null</code>.\n-\t * @param x0 The pixel-location at which this token begins.  This is needed\n-\t *        because of tabs.\n-\t * @return The width of the specified number of characters in this token.\n-\t * @see #getWidth\n-\t */\n-\tfloat getWidthUpTo(int numChars, RSyntaxTextArea textArea,\n-\t\t\tTabExpander e, float x0);\n-\n-\n-\t/**\n-\t * Returns whether this token's lexeme matches a specific character array.\n-\t *\n-\t * @param lexeme The lexeme to check for.\n-\t * @return Whether this token has that lexeme.\n-\t * @see #is(int, char[])\n-\t * @see #is(int, String)\n-\t * @see #isSingleChar(int, char)\n-\t * @see #startsWith(char[])\n-\t */\n-\tboolean is(char[] lexeme);\n-\n-\n-\t/**\n-\t * Returns whether this token is of the specified type, with the specified\n-\t * lexeme.<p>\n-\t * This method is preferred over the other overload in performance-critical\n-\t * code where this operation may be called frequently, since it does not\n-\t * involve any String allocations.\n-\t *\n-\t * @param type The type to check for.\n-\t * @param lexeme The lexeme to check for.\n-\t * @return Whether this token has that type and lexeme.\n-\t * @see #is(int, String)\n-\t * @see #is(char[])\n-\t * @see #isSingleChar(int, char)\n-\t * @see #startsWith(char[])\n-\t */\n-\tboolean is(int type, char[] lexeme);\n-\n-\n-\t/**\n-\t * Returns whether this token is of the specified type, with the specified\n-\t * lexeme.<p>\n-\t * The other overload of this method is preferred over this one in\n-\t * performance-critical code, as this one involves a String allocation\n-\t * while the other does not.\n-\t *\n-\t * @param type The type to check for.\n-\t * @param lexeme The lexeme to check for.\n-\t * @return Whether this token has that type and lexeme.\n-\t * @see #is(int, char[])\n-\t * @see #isSingleChar(int, char)\n-\t * @see #startsWith(char[])\n-\t */\n-\tboolean is(int type, String lexeme);\n-\n-\n-\t/**\n-\t * Returns whether this token is a comment.\n-\t *\n-\t * @return Whether this token is a comment.\n-\t * @see #isWhitespace()\n-\t * @see #isCommentOrWhitespace()\n-\t */\n-\tboolean isComment();\n-\n-\n-\t/**\n-\t * Returns whether this token is a comment or whitespace.\n-\t *\n-\t * @return Whether this token is a comment or whitespace.\n-\t * @see #isComment()\n-\t * @see #isWhitespace()\n-\t */\n-\tboolean isCommentOrWhitespace();\n-\n-\n-\t/**\n-\t * Returns whether this token is a hyperlink.\n-\t *\n-\t * @return Whether this token is a hyperlink.\n-\t * @see #setHyperlink(boolean)\n-\t */\n-\tboolean isHyperlink();\n-\n-\n-\t/**\n-\t * Returns whether this token is an identifier.\n-\t *\n-\t * @return Whether this token is an identifier.\n-\t */\n-\tboolean isIdentifier();\n-\n-\n-\t/**\n-\t * Returns whether this token is a {@link #SEPARATOR} representing a single\n-\t * left curly brace.\n-\t *\n-\t * @return Whether this token is a left curly brace.\n-\t * @see #isRightCurly()\n-\t */\n-\tboolean isLeftCurly();\n-\n-\n-\t/**\n-\t * Returns whether this token is a {@link #SEPARATOR} representing a single\n-\t * right curly brace.\n-\t *\n-\t * @return Whether this token is a right curly brace.\n-\t * @see #isLeftCurly()\n-\t */\n-\tboolean isRightCurly();\n-\n-\n-\t/**\n-\t * Returns whether or not this token is \"paintable;\" i.e., whether or not\n-\t * the type of this token is one such that it has an associated syntax\n-\t * style.  What this boils down to is whether the token type is greater\n-\t * than <code>Token.NULL</code>.\n-\t *\n-\t * @return Whether or not this token is paintable.\n-\t */\n-\tboolean isPaintable();\n-\n-\n-\t/**\n-\t * Returns whether this token is the specified single character.\n-\t *\n-\t * @param ch The character to check for.\n-\t * @return Whether this token's lexeme is the single character specified.\n-\t * @see #isSingleChar(int, char)\n-\t */\n-\tboolean isSingleChar(char ch);\n-\n-\n-\t/**\n-\t * Returns whether this token is the specified single character, and of a\n-\t * specific type.\n-\t *\n-\t * @param type The token type.\n-\t * @param ch The character to check for.\n-\t * @return Whether this token is of the specified type, and with a lexeme\n-\t *         Equaling the single character specified.\n-\t * @see #isSingleChar(char)\n-\t */\n-\tboolean isSingleChar(int type, char ch);\n-\n-\n-\t/**\n-\t * Returns whether or not this token is whitespace.\n-\t *\n-\t * @return <code>true</code> iff this token is whitespace.\n-\t * @see #isComment()\n-\t * @see #isCommentOrWhitespace()\n-\t */\n-\tboolean isWhitespace();\n-\n-\n-\t/**\n-\t * Returns the length of this token.\n-\t *\n-\t * @return The length of this token.\n-\t * @see #getOffset()\n-\t */\n-\tint length();\n-\n-\n-\t/**\n-\t * Returns the bounding box for the specified document location.  The\n-\t * location must be in the specified token list; if it isn't,\n-\t * <code>null</code> is returned.\n-\t *\n-\t * @param textArea The text area from which the token list was derived.\n-\t * @param e How to expand tabs.\n-\t * @param pos The position in the document for which to get the bounding\n-\t *        box in the view.\n-\t * @param x0 The pixel x-location that is the beginning of\n-\t *        <code>tokenList</code>.\n-\t * @param rect The rectangle in which we'll be returning the results.  This\n-\t *        object is reused to keep from frequent memory allocations.\n-\t * @return The bounding box for the specified position in the model.\n-\t */\n-\tRectangle listOffsetToView(RSyntaxTextArea textArea, TabExpander e,\n-\t\t\tint pos, int x0, Rectangle rect);\n-\n-\n-\t/**\n-\t * Sets whether this token is a hyperlink.\n-\t *\n-\t * @param hyperlink Whether this token is a hyperlink.\n-\t * @see #isHyperlink()\n-\t */\n-\tvoid setHyperlink(boolean hyperlink);\n-\n-\n-\t/**\n-\t * Sets the language index for this token.  If this value is positive, it\n-\t * denotes a specific \"secondary\" language this token represents (such as\n-\t * JavaScript code or CSS embedded in an HTML file).  If this value is\n-\t * <code>0</code>, this token is in the \"main\" language being edited.\n-\t * Negative values are invalid and treated as <code>0</code>.\n-\t *\n-\t * @param languageIndex The new language index.  A value of\n-\t *        <code>0</code> denotes the \"main\" language, any positive value\n-\t *        denotes a specific secondary language.  Negative values will\n-\t *        be treated as <code>0</code>.\n-\t * @see #getLanguageIndex()\n-\t */\n-\tvoid setLanguageIndex(int languageIndex);\n-\n-\n-\t/**\n-\t * Sets the type of this token.\n-\t *\n-\t * @param type The new token type.\n-\t * @see TokenTypes\n-\t * @see #getType()\n-\t */\n-\tvoid setType(int type);\n-\n-\n-\t/**\n-\t * Returns whether this token starts with the specified characters.\n-\t *\n-\t * @param chars The characters.\n-\t * @return Whether this token starts with those characters.\n-\t * @see #endsWith(char[])\n-\t * @see #is(int, char[])\n-\t */\n-\tboolean startsWith(char[] chars);\n-\n-\n-\t/**\n-\t * Returns the position in the document corresponding to the specified\n-\t * position in this token's internal char array (<code>textOffset</code> -\n-\t * <code>textOffset+textCount-1</code>).<p>\n-\t * Note that this method does NOT do any bounds checking; you can pass in\n-\t * an invalid token position, and you will not receive an Exception or any\n-\t * other indication that the returned document position is invalid.  It is\n-\t * up to the user to ensure valid input.\n-\t *\n-\t * @param pos A position in the token's internal char array\n-\t *        (<code>textOffset</code> - <code>textOffset+textCount</code>).\n-\t * @return The corresponding position in the document.\n-\t * @see #documentToToken(int)\n-\t */\n-\tint tokenToDocument(int pos);\n+  /**\n+   * Appends HTML code for painting this token, using the given text area's\n+   * color scheme.\n+   *\n+   * @param sb         The buffer to append to.\n+   * @param textArea   The text area whose color scheme to use.\n+   * @param fontFamily Whether to include the font family in the HTML for\n+   *                   this token.  You can pass <code>false</code> for this parameter\n+   *                   if, for example, you are making all your HTML be monospaced,\n+   *                   and don't want any crazy fonts being used in the editor to be\n+   *                   reflected in your HTML.\n+   * @return The buffer appended to.\n+   * @see #getHTMLRepresentation(RSyntaxTextArea)\n+   */\n+  StringBuilder appendHTMLRepresentation(StringBuilder sb,\n+                                         RSyntaxTextArea textArea,\n+                                         boolean fontFamily);\n+\n+\n+  /**\n+   * Appends HTML code for painting this token, using the given text area's\n+   * color scheme.\n+   *\n+   * @param sb           The buffer to append to.\n+   * @param textArea     The text area whose color scheme to use.\n+   * @param fontFamily   Whether to include the font family in the HTML for\n+   *                     this token.  You can pass <code>false</code> for this parameter\n+   *                     if, for example, you are making all your HTML be monospaced,\n+   *                     and don't want any crazy fonts being used in the editor to be\n+   *                     reflected in your HTML.\n+   * @param tabsToSpaces Whether to convert tabs into spaces.\n+   * @return The buffer appended to.\n+   * @see #getHTMLRepresentation(RSyntaxTextArea)\n+   */\n+  StringBuilder appendHTMLRepresentation(StringBuilder sb,\n+                                         RSyntaxTextArea textArea, boolean fontFamily,\n+                                         boolean tabsToSpaces);\n+\n+\n+  /**\n+   * Returns the character at the specified offset in the token.\n+   *\n+   * @param index The index.  This should be in the range\n+   *              <code>0-({@link #length()}-1)</code>.\n+   * @return The character.\n+   * @see #length()\n+   */\n+  char charAt(int index);\n+\n+\n+  /**\n+   * Returns whether the token straddles the specified position in the\n+   * document.\n+   *\n+   * @param pos The position in the document to check.\n+   * @return Whether the specified position is straddled by this token.\n+   */\n+  boolean containsPosition(int pos);\n+\n+\n+  /**\n+   * Returns the position in the token's internal char array corresponding\n+   * to the specified document position.<p>\n+   * Note that this method does NOT do any bounds checking; you can pass in\n+   * a document position that does not correspond to a position in this\n+   * token, and you will not receive an Exception or any other notification;\n+   * it is up to the caller to ensure valid input.\n+   *\n+   * @param pos A position in the document that is represented by this token.\n+   * @return The corresponding token position &gt;= <code>textOffset</code>\n+   * and &lt; <code>textOffset+textCount</code>.\n+   * @see #tokenToDocument\n+   */\n+  int documentToToken(int pos);\n+\n+\n+  /**\n+   * Returns whether this token's lexeme ends with the specified characters.\n+   *\n+   * @param ch The characters.\n+   * @return Whether this token's lexeme ends with the specified characters.\n+   * @see #startsWith(char[])\n+   */\n+  boolean endsWith(char[] ch);\n+\n+\n+  /**\n+   * Returns the end offset of this token in the document (exclusive).  In\n+   * other words, the token ranges from\n+   * <code>[getOffset(), getEndOffset())</code>.\n+   *\n+   * @return The end offset of this token.\n+   * @see #getOffset()\n+   */\n+  int getEndOffset();\n+\n+\n+  /**\n+   * Returns a <code>String</code> containing HTML code for painting this\n+   * token, using the given text area's color scheme.\n+   *\n+   * @param textArea The text area whose color scheme to use.\n+   * @return The HTML representation of the token.\n+   * @see #appendHTMLRepresentation(StringBuilder, RSyntaxTextArea, boolean)\n+   */\n+  String getHTMLRepresentation(RSyntaxTextArea textArea);\n+\n+\n+  /**\n+   * Returns the language index of this token.\n+   *\n+   * @return The language index.  A value of <code>0</code> denotes the\n+   * \"main\" language, any positive value denotes a specific secondary\n+   * language.\n+   * @see #setLanguageIndex(int)\n+   */\n+  int getLanguageIndex();\n+\n+\n+  /**\n+   * Returns the last token in this list that is not whitespace or a\n+   * comment.\n+   *\n+   * @return The last non-comment, non-whitespace token, or <code>null</code>\n+   * if there isn't one.\n+   */\n+  Token getLastNonCommentNonWhitespaceToken();\n+\n+\n+  /**\n+   * Returns the last paintable token in this token list, or <code>null</code>\n+   * if there is no paintable token.\n+   *\n+   * @return The last paintable token in this token list.\n+   */\n+  Token getLastPaintableToken();\n+\n+\n+  /**\n+   * Returns the text of this token, as a string.<p>\n+   * <p>\n+   * Note that this method isn't used much by the\n+   * <code>ryntaxtextarea</code> package internally, as it tries to limit\n+   * memory allocation.\n+   *\n+   * @return The text of this token.\n+   */\n+  String getLexeme();\n+\n+\n+  /**\n+   * Determines the offset into this token list (i.e., into the\n+   * document) that covers pixel location <code>x</code> if the token list\n+   * starts at pixel location <code>x0</code><p>.\n+   * This method will return the document position \"closest\" to the\n+   * x-coordinate (i.e., if they click on the \"right-half\" of the\n+   * <code>w</code> in <code>awe</code>, the caret will be placed in\n+   * between the <code>w</code> and <code>e</code>; similarly, clicking on\n+   * the left-half places the caret between the <code>a</code> and\n+   * <code>w</code>).  This makes it useful for methods such as\n+   * <code>viewToModel</code> found in <code>javax.swing.text.View</code>\n+   * subclasses.\n+   *\n+   * @param textArea The text area from which the token list was derived.\n+   * @param e        How to expand tabs.\n+   * @param x0       The pixel x-location that is the beginning of\n+   *                 <code>tokenList</code>.\n+   * @param x        The pixel-position for which you want to get the corresponding\n+   *                 offset.\n+   * @return The position (in the document, NOT into the token list!) that\n+   * covers the pixel location.  If <code>tokenList</code> is\n+   * <code>null</code> or has type <code>Token.NULL</code>, then\n+   * <code>-1</code> is returned; the caller should recognize this and\n+   * return the actual end position of the (empty) line.\n+   */\n+  int getListOffset(RSyntaxTextArea textArea, TabExpander e,\n+                    float x0, float x);\n+\n+\n+  /**\n+   * Returns the token after this one in the linked list.\n+   *\n+   * @return The next token.\n+   */\n+  Token getNextToken();\n+\n+\n+  /**\n+   * Returns the offset into the document at which this token resides.\n+   *\n+   * @return The offset into the document.\n+   * @see #getEndOffset()\n+   */\n+  int getOffset();\n+\n+\n+  /**\n+   * Returns the position in the document that represents the last character\n+   * in the token that will fit into <code>endBeforeX-startX</code> pixels.\n+   * For example, if you're using a monospaced 8-pixel-per-character font,\n+   * have the token \"while\" and <code>startX</code> is <code>0</code> and\n+   * <code>endBeforeX</code> is <code>30</code>, this method will return the\n+   * document position of the \"i\" in \"while\", because the \"i\" ends at pixel\n+   * <code>24</code>, while the \"l\" ends at <code>32</code>.  If not even the\n+   * first character fits in <code>endBeforeX-startX</code>, the first\n+   * character's position is still returned so calling methods don't go into\n+   * infinite loops.\n+   *\n+   * @param textArea   The text area in which this token is being painted.\n+   * @param e          How to expand tabs.\n+   * @param startX     The x-coordinate at which the token will be painted.  This\n+   *                   is needed because of tabs.\n+   * @param endBeforeX The x-coordinate for which you want to find the last\n+   *                   character of <code>t</code> which comes before it.\n+   * @return The last document position that will fit in the specified amount\n+   * of pixels.\n+   */\n+  /*\n+   * @see #getTokenListOffsetBeforeX\n+   * FIXME:  This method does not compute correctly!  It needs to be abstract\n+   * and implemented by subclasses.\n+   */\n+  int getOffsetBeforeX(RSyntaxTextArea textArea, TabExpander e,\n+                       float startX, float endBeforeX);\n+\n+\n+  /**\n+   * Returns the character array backing the lexeme of this token.  This\n+   * value should be treated as read-only.\n+   *\n+   * @return A character array containing the lexeme of this token.\n+   * @see #getTextOffset()\n+   * @see #length()\n+   */\n+  char[] getTextArray();\n+\n+\n+  /**\n+   * Returns the offset into the character array of the lexeme in\n+   * {@link #getTextArray()}.\n+   *\n+   * @return The offset of the lexeme in the character array.\n+   * @see #getTextArray()\n+   */\n+  int getTextOffset();\n+\n+\n+  /**\n+   * Returns the type of this token.\n+   *\n+   * @return The type of this token.\n+   * @see TokenTypes\n+   * @see #setType(int)\n+   */\n+  int getType();\n+\n+\n+  /**\n+   * Returns the width of this token given the specified parameters.\n+   *\n+   * @param textArea The text area in which the token is being painted.\n+   * @param e        Describes how to expand tabs.  This parameter cannot be\n+   *                 <code>null</code>.\n+   * @param x0       The pixel-location at which the token begins.  This is needed\n+   *                 because of tabs.\n+   * @return The width of the token, in pixels.\n+   * @see #getWidthUpTo\n+   */\n+  float getWidth(RSyntaxTextArea textArea, TabExpander e, float x0);\n+\n+\n+  /**\n+   * Returns the width of a specified number of characters in this token.\n+   * For example, for the token \"while\", specifying a value of <code>3</code>\n+   * here returns the width of the \"whi\" portion of the token.\n+   *\n+   * @param numChars The number of characters for which to get the width.\n+   * @param textArea The text area in which the token is being painted.\n+   * @param e        How to expand tabs.  This value cannot be <code>null</code>.\n+   * @param x0       The pixel-location at which this token begins.  This is needed\n+   *                 because of tabs.\n+   * @return The width of the specified number of characters in this token.\n+   * @see #getWidth\n+   */\n+  float getWidthUpTo(int numChars, RSyntaxTextArea textArea,\n+                     TabExpander e, float x0);\n+\n+\n+  /**\n+   * Returns whether this token's lexeme matches a specific character array.\n+   *\n+   * @param lexeme The lexeme to check for.\n+   * @return Whether this token has that lexeme.\n+   * @see #is(int, char[])\n+   * @see #is(int, String)\n+   * @see #isSingleChar(int, char)\n+   * @see #startsWith(char[])\n+   */\n+  boolean is(char[] lexeme);\n+\n+\n+  /**\n+   * Returns whether this token is of the specified type, with the specified\n+   * lexeme.<p>\n+   * This method is preferred over the other overload in performance-critical\n+   * code where this operation may be called frequently, since it does not\n+   * involve any String allocations.\n+   *\n+   * @param type   The type to check for.\n+   * @param lexeme The lexeme to check for.\n+   * @return Whether this token has that type and lexeme.\n+   * @see #is(int, String)\n+   * @see #is(char[])\n+   * @see #isSingleChar(int, char)\n+   * @see #startsWith(char[])\n+   */\n+  boolean is(int type, char[] lexeme);\n+\n+\n+  /**\n+   * Returns whether this token is of the specified type, with the specified\n+   * lexeme.<p>\n+   * The other overload of this method is preferred over this one in\n+   * performance-critical code, as this one involves a String allocation\n+   * while the other does not.\n+   *\n+   * @param type   The type to check for.\n+   * @param lexeme The lexeme to check for.\n+   * @return Whether this token has that type and lexeme.\n+   * @see #is(int, char[])\n+   * @see #isSingleChar(int, char)\n+   * @see #startsWith(char[])\n+   */\n+  boolean is(int type, String lexeme);\n+\n+\n+  /**\n+   * Returns whether this token is a comment.\n+   *\n+   * @return Whether this token is a comment.\n+   * @see #isWhitespace()\n+   * @see #isCommentOrWhitespace()\n+   */\n+  boolean isComment();\n+\n+\n+  /**\n+   * Returns whether this token is a comment or whitespace.\n+   *\n+   * @return Whether this token is a comment or whitespace.\n+   * @see #isComment()\n+   * @see #isWhitespace()\n+   */\n+  boolean isCommentOrWhitespace();\n+\n+\n+  /**\n+   * Returns whether this token is a hyperlink.\n+   *\n+   * @return Whether this token is a hyperlink.\n+   * @see #setHyperlink(boolean)\n+   */\n+  boolean isHyperlink();\n+\n+\n+  /**\n+   * Returns whether this token is an identifier.\n+   *\n+   * @return Whether this token is an identifier.\n+   */\n+  boolean isIdentifier();\n+\n+\n+  /**\n+   * Returns whether this token is a {@link #SEPARATOR} representing a single\n+   * left curly brace.\n+   *\n+   * @return Whether this token is a left curly brace.\n+   * @see #isRightCurly()\n+   */\n+  boolean isLeftCurly();\n+\n+\n+  /**\n+   * Returns whether this token is a {@link #SEPARATOR} representing a single\n+   * right curly brace.\n+   *\n+   * @return Whether this token is a right curly brace.\n+   * @see #isLeftCurly()\n+   */\n+  boolean isRightCurly();\n+\n+\n+  /**\n+   * Returns whether or not this token is \"paintable;\" i.e., whether or not\n+   * the type of this token is one such that it has an associated syntax\n+   * style.  What this boils down to is whether the token type is greater\n+   * than <code>Token.NULL</code>.\n+   *\n+   * @return Whether or not this token is paintable.\n+   */\n+  boolean isPaintable();\n+\n+\n+  /**\n+   * Returns whether this token is the specified single character.\n+   *\n+   * @param ch The character to check for.\n+   * @return Whether this token's lexeme is the single character specified.\n+   * @see #isSingleChar(int, char)\n+   */\n+  boolean isSingleChar(char ch);\n+\n+\n+  /**\n+   * Returns whether this token is the specified single character, and of a\n+   * specific type.\n+   *\n+   * @param type The token type.\n+   * @param ch   The character to check for.\n+   * @return Whether this token is of the specified type, and with a lexeme\n+   * Equaling the single character specified.\n+   * @see #isSingleChar(char)\n+   */\n+  boolean isSingleChar(int type, char ch);\n+\n+\n+  /**\n+   * Returns whether or not this token is whitespace.\n+   *\n+   * @return <code>true</code> iff this token is whitespace.\n+   * @see #isComment()\n+   * @see #isCommentOrWhitespace()\n+   */\n+  boolean isWhitespace();\n+\n+\n+  /**\n+   * Returns the length of this token.\n+   *\n+   * @return The length of this token.\n+   * @see #getOffset()\n+   */\n+  int length();\n+\n+\n+  /**\n+   * Returns the bounding box for the specified document location.  The\n+   * location must be in the specified token list; if it isn't,\n+   * <code>null</code> is returned.\n+   *\n+   * @param textArea The text area from which the token list was derived.\n+   * @param e        How to expand tabs.\n+   * @param pos      The position in the document for which to get the bounding\n+   *                 box in the view.\n+   * @param x0       The pixel x-location that is the beginning of\n+   *                 <code>tokenList</code>.\n+   * @param rect     The rectangle in which we'll be returning the results.  This\n+   *                 object is reused to keep from frequent memory allocations.\n+   * @return The bounding box for the specified position in the model.\n+   */\n+  Rectangle listOffsetToView(RSyntaxTextArea textArea, TabExpander e,\n+                             int pos, int x0, Rectangle rect);\n+\n+\n+  /**\n+   * Sets whether this token is a hyperlink.\n+   *\n+   * @param hyperlink Whether this token is a hyperlink.\n+   * @see #isHyperlink()\n+   */\n+  void setHyperlink(boolean hyperlink);\n+\n+\n+  /**\n+   * Sets the language index for this token.  If this value is positive, it\n+   * denotes a specific \"secondary\" language this token represents (such as\n+   * JavaScript code or CSS embedded in an HTML file).  If this value is\n+   * <code>0</code>, this token is in the \"main\" language being edited.\n+   * Negative values are invalid and treated as <code>0</code>.\n+   *\n+   * @param languageIndex The new language index.  A value of\n+   *                      <code>0</code> denotes the \"main\" language, any positive value\n+   *                      denotes a specific secondary language.  Negative values will\n+   *                      be treated as <code>0</code>.\n+   * @see #getLanguageIndex()\n+   */\n+  void setLanguageIndex(int languageIndex);\n+\n+\n+  /**\n+   * Sets the type of this token.\n+   *\n+   * @param type The new token type.\n+   * @see TokenTypes\n+   * @see #getType()\n+   */\n+  void setType(int type);\n+\n+\n+  /**\n+   * Returns whether this token starts with the specified characters.\n+   *\n+   * @param chars The characters.\n+   * @return Whether this token starts with those characters.\n+   * @see #endsWith(char[])\n+   * @see #is(int, char[])\n+   */\n+  boolean startsWith(char[] chars);\n+\n+\n+  /**\n+   * Returns the position in the document corresponding to the specified\n+   * position in this token's internal char array (<code>textOffset</code> -\n+   * <code>textOffset+textCount-1</code>).<p>\n+   * Note that this method does NOT do any bounds checking; you can pass in\n+   * an invalid token position, and you will not receive an Exception or any\n+   * other indication that the returned document position is invalid.  It is\n+   * up to the user to ensure valid input.\n+   *\n+   * @param pos A position in the token's internal char array\n+   *            (<code>textOffset</code> - <code>textOffset+textCount</code>).\n+   * @return The corresponding position in the document.\n+   * @see #documentToToken(int)\n+   */\n+  int tokenToDocument(int pos);\n \n \n }\n",
            "diff_size": 528
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "39",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/intuit-Tank/errored/1/189/Token.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/intuit-Tank/naturalize/189/Token.java\nindex 8ac6429eaf8..ff0da89ecdb 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/intuit-Tank/errored/1/189/Token.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/intuit-Tank/naturalize/189/Token.java\n@@ -12,7 +12,6 @@ import java.awt.Rectangle;\n \n import javax.swing.text.TabExpander;\n \n-\n /**\n  * A generic token that functions as a node in a linked list of syntax\n  * highlighted tokens for some language.<p>\n@@ -36,7 +35,7 @@ import javax.swing.text.TabExpander;\n  */\n public interface Token extends TokenTypes {\n \n-\t/**\n+    /**\n \t * Appends HTML code for painting this token, using the given text area's\n \t * color scheme.\n \t *\n@@ -50,12 +49,10 @@ public interface Token extends TokenTypes {\n \t * @return The buffer appended to.\n \t * @see #getHTMLRepresentation(RSyntaxTextArea)\n \t */\n-\tStringBuilder appendHTMLRepresentation(StringBuilder sb,\n-\t\t\t\t\t\t\t\t\t\t\tRSyntaxTextArea textArea,\n+\tStringBuilder appendHTMLRepresentation(StringBuilder sb, RSyntaxTextArea textArea,\n \t\t\t\t\t\t\t\t\t\t\tboolean fontFamily);\n \n-\n-\t/**\n+/**\n \t * Appends HTML code for painting this token, using the given text area's\n \t * color scheme.\n \t *\n@@ -70,12 +67,10 @@ public interface Token extends TokenTypes {\n \t * @return The buffer appended to.\n \t * @see #getHTMLRepresentation(RSyntaxTextArea)\n \t */\n-\tStringBuilder appendHTMLRepresentation(StringBuilder sb,\n-\t\t\t\t\t\t\t\tRSyntaxTextArea textArea, boolean fontFamily,\n+\tStringBuilder appendHTMLRepresentation(StringBuilder sb, RSyntaxTextArea textArea, boolean fontFamily,\n \t\t\t\t\t\t\t\tboolean tabsToSpaces);\n \n-\n-\t/**\n+/**\n \t * Returns the character at the specified offset in the token.\n \t *\n \t * @param index The index.  This should be in the range\n@@ -85,8 +80,7 @@ public interface Token extends TokenTypes {\n \t */\n \tchar charAt(int index);\n \n-\n-\t/**\n+/**\n \t * Returns whether the token straddles the specified position in the\n \t * document.\n \t *\n@@ -95,8 +89,7 @@ public interface Token extends TokenTypes {\n \t */\n \tboolean containsPosition(int pos);\n \n-\n-\t/**\n+/**\n \t * Returns the position in the token's internal char array corresponding\n \t * to the specified document position.<p>\n \t * Note that this method does NOT do any bounds checking; you can pass in\n@@ -111,8 +104,7 @@ public interface Token extends TokenTypes {\n \t */\n \tint documentToToken(int pos);\n \n-\n-\t/**\n+/**\n \t * Returns whether this token's lexeme ends with the specified characters.\n \t *\n \t * @param ch The characters.\n@@ -121,8 +113,7 @@ public interface Token extends TokenTypes {\n \t */\n \tboolean endsWith(char[] ch);\n \n-\n-\t/**\n+/**\n \t * Returns the end offset of this token in the document (exclusive).  In\n \t * other words, the token ranges from\n \t * <code>[getOffset(), getEndOffset())</code>.\n@@ -132,8 +123,7 @@ public interface Token extends TokenTypes {\n \t */\n \tint getEndOffset();\n \n-\n-\t/**\n+/**\n \t * Returns a <code>String</code> containing HTML code for painting this\n \t * token, using the given text area's color scheme.\n \t *\n@@ -143,8 +133,7 @@ public interface Token extends TokenTypes {\n \t */\n \tString getHTMLRepresentation(RSyntaxTextArea textArea);\n \n-\n-\t/**\n+/**\n \t * Returns the language index of this token.\n \t *\n \t * @return The language index.  A value of <code>0</code> denotes the\n@@ -154,8 +143,7 @@ public interface Token extends TokenTypes {\n \t */\n \tint getLanguageIndex();\n \n-\n-\t/**\n+/**\n \t * Returns the last token in this list that is not whitespace or a\n \t * comment.\n \t *\n@@ -164,8 +152,7 @@ public interface Token extends TokenTypes {\n \t */\n \tToken getLastNonCommentNonWhitespaceToken();\n \n-\n-\t/**\n+/**\n \t * Returns the last paintable token in this token list, or <code>null</code>\n \t * if there is no paintable token.\n \t *\n@@ -173,8 +160,7 @@ public interface Token extends TokenTypes {\n \t */\n \tToken getLastPaintableToken();\n \n-\n-\t/**\n+/**\n \t * Returns the text of this token, as a string.<p>\n \t *\n \t * Note that this method isn't used much by the\n@@ -185,8 +171,7 @@ public interface Token extends TokenTypes {\n \t */\n \tString getLexeme();\n \n-\n-\t/**\n+/**\n \t * Determines the offset into this token list (i.e., into the\n \t * document) that covers pixel location <code>x</code> if the token list\n \t * starts at pixel location <code>x0</code><p>.\n@@ -211,19 +196,16 @@ public interface Token extends TokenTypes {\n \t *         <code>-1</code> is returned; the caller should recognize this and\n \t *         return the actual end position of the (empty) line.\n \t */\n-\tint getListOffset(RSyntaxTextArea textArea, TabExpander e,\n-\t\t\tfloat x0, float x);\n-\n+\tint getListOffset(RSyntaxTextArea textArea, TabExpander e, float x0, float x);\n \n-\t/**\n+/**\n \t * Returns the token after this one in the linked list.\n \t *\n \t * @return The next token.\n \t */\n \tToken getNextToken();\n \n-\n-\t/**\n+/**\n \t * Returns the offset into the document at which this token resides.\n \t *\n \t * @return The offset into the document.\n@@ -231,8 +213,7 @@ public interface Token extends TokenTypes {\n \t */\n \tint getOffset();\n \n-\n-\t/**\n+/**\n \t * Returns the position in the document that represents the last character\n \t * in the token that will fit into <code>endBeforeX-startX</code> pixels.\n \t * For example, if you're using a monospaced 8-pixel-per-character font,\n@@ -258,11 +239,9 @@ public interface Token extends TokenTypes {\n \t * FIXME:  This method does not compute correctly!  It needs to be abstract\n \t * and implemented by subclasses.\n \t */\n-\tint getOffsetBeforeX(RSyntaxTextArea textArea, TabExpander e,\n-\t\t\t\t\t\t\tfloat startX, float endBeforeX);\n+\tint getOffsetBeforeX(RSyntaxTextArea textArea, TabExpander e, float startX, float endBeforeX);\n \n-\n-\t/**\n+/**\n \t * Returns the character array backing the lexeme of this token.  This\n \t * value should be treated as read-only.\n \t *\n@@ -272,8 +251,7 @@ public interface Token extends TokenTypes {\n \t */\n \tchar[] getTextArray();\n \n-\n-\t/**\n+/**\n \t * Returns the offset into the character array of the lexeme in\n \t * {@link #getTextArray()}.\n \t *\n@@ -282,8 +260,7 @@ public interface Token extends TokenTypes {\n \t */\n \tint getTextOffset();\n \n-\n-\t/**\n+/**\n \t * Returns the type of this token.\n \t *\n \t * @return The type of this token.\n@@ -292,8 +269,7 @@ public interface Token extends TokenTypes {\n \t */\n \tint getType();\n \n-\n-\t/**\n+/**\n \t * Returns the width of this token given the specified parameters.\n \t *\n \t * @param textArea The text area in which the token is being painted.\n@@ -306,8 +282,7 @@ public interface Token extends TokenTypes {\n \t */\n \tfloat getWidth(RSyntaxTextArea textArea, TabExpander e, float x0);\n \n-\n-\t/**\n+/**\n \t * Returns the width of a specified number of characters in this token.\n \t * For example, for the token \"while\", specifying a value of <code>3</code>\n \t * here returns the width of the \"whi\" portion of the token.\n@@ -320,11 +295,9 @@ public interface Token extends TokenTypes {\n \t * @return The width of the specified number of characters in this token.\n \t * @see #getWidth\n \t */\n-\tfloat getWidthUpTo(int numChars, RSyntaxTextArea textArea,\n-\t\t\tTabExpander e, float x0);\n+\tfloat getWidthUpTo(int numChars, RSyntaxTextArea textArea, TabExpander e, float x0);\n \n-\n-\t/**\n+/**\n \t * Returns whether this token's lexeme matches a specific character array.\n \t *\n \t * @param lexeme The lexeme to check for.\n@@ -336,8 +309,7 @@ public interface Token extends TokenTypes {\n \t */\n \tboolean is(char[] lexeme);\n \n-\n-\t/**\n+/**\n \t * Returns whether this token is of the specified type, with the specified\n \t * lexeme.<p>\n \t * This method is preferred over the other overload in performance-critical\n@@ -354,8 +326,7 @@ public interface Token extends TokenTypes {\n \t */\n \tboolean is(int type, char[] lexeme);\n \n-\n-\t/**\n+/**\n \t * Returns whether this token is of the specified type, with the specified\n \t * lexeme.<p>\n \t * The other overload of this method is preferred over this one in\n@@ -371,8 +342,7 @@ public interface Token extends TokenTypes {\n \t */\n \tboolean is(int type, String lexeme);\n \n-\n-\t/**\n+/**\n \t * Returns whether this token is a comment.\n \t *\n \t * @return Whether this token is a comment.\n@@ -381,8 +351,7 @@ public interface Token extends TokenTypes {\n \t */\n \tboolean isComment();\n \n-\n-\t/**\n+/**\n \t * Returns whether this token is a comment or whitespace.\n \t *\n \t * @return Whether this token is a comment or whitespace.\n@@ -391,8 +360,7 @@ public interface Token extends TokenTypes {\n \t */\n \tboolean isCommentOrWhitespace();\n \n-\n-\t/**\n+/**\n \t * Returns whether this token is a hyperlink.\n \t *\n \t * @return Whether this token is a hyperlink.\n@@ -400,16 +368,14 @@ public interface Token extends TokenTypes {\n \t */\n \tboolean isHyperlink();\n \n-\n-\t/**\n+/**\n \t * Returns whether this token is an identifier.\n \t *\n \t * @return Whether this token is an identifier.\n \t */\n \tboolean isIdentifier();\n \n-\n-\t/**\n+/**\n \t * Returns whether this token is a {@link #SEPARATOR} representing a single\n \t * left curly brace.\n \t *\n@@ -418,8 +384,7 @@ public interface Token extends TokenTypes {\n \t */\n \tboolean isLeftCurly();\n \n-\n-\t/**\n+/**\n \t * Returns whether this token is a {@link #SEPARATOR} representing a single\n \t * right curly brace.\n \t *\n@@ -428,8 +393,7 @@ public interface Token extends TokenTypes {\n \t */\n \tboolean isRightCurly();\n \n-\n-\t/**\n+/**\n \t * Returns whether or not this token is \"paintable;\" i.e., whether or not\n \t * the type of this token is one such that it has an associated syntax\n \t * style.  What this boils down to is whether the token type is greater\n@@ -439,8 +403,7 @@ public interface Token extends TokenTypes {\n \t */\n \tboolean isPaintable();\n \n-\n-\t/**\n+/**\n \t * Returns whether this token is the specified single character.\n \t *\n \t * @param ch The character to check for.\n@@ -449,8 +412,7 @@ public interface Token extends TokenTypes {\n \t */\n \tboolean isSingleChar(char ch);\n \n-\n-\t/**\n+/**\n \t * Returns whether this token is the specified single character, and of a\n \t * specific type.\n \t *\n@@ -462,8 +424,7 @@ public interface Token extends TokenTypes {\n \t */\n \tboolean isSingleChar(int type, char ch);\n \n-\n-\t/**\n+/**\n \t * Returns whether or not this token is whitespace.\n \t *\n \t * @return <code>true</code> iff this token is whitespace.\n@@ -472,8 +433,7 @@ public interface Token extends TokenTypes {\n \t */\n \tboolean isWhitespace();\n \n-\n-\t/**\n+/**\n \t * Returns the length of this token.\n \t *\n \t * @return The length of this token.\n@@ -481,8 +441,7 @@ public interface Token extends TokenTypes {\n \t */\n \tint length();\n \n-\n-\t/**\n+/**\n \t * Returns the bounding box for the specified document location.  The\n \t * location must be in the specified token list; if it isn't,\n \t * <code>null</code> is returned.\n@@ -497,11 +456,9 @@ public interface Token extends TokenTypes {\n \t *        object is reused to keep from frequent memory allocations.\n \t * @return The bounding box for the specified position in the model.\n \t */\n-\tRectangle listOffsetToView(RSyntaxTextArea textArea, TabExpander e,\n-\t\t\tint pos, int x0, Rectangle rect);\n-\n+\tRectangle listOffsetToView(RSyntaxTextArea textArea, TabExpander e, int pos, int x0, Rectangle rect);\n \n-\t/**\n+/**\n \t * Sets whether this token is a hyperlink.\n \t *\n \t * @param hyperlink Whether this token is a hyperlink.\n@@ -509,8 +466,7 @@ public interface Token extends TokenTypes {\n \t */\n \tvoid setHyperlink(boolean hyperlink);\n \n-\n-\t/**\n+/**\n \t * Sets the language index for this token.  If this value is positive, it\n \t * denotes a specific \"secondary\" language this token represents (such as\n \t * JavaScript code or CSS embedded in an HTML file).  If this value is\n@@ -525,8 +481,7 @@ public interface Token extends TokenTypes {\n \t */\n \tvoid setLanguageIndex(int languageIndex);\n \n-\n-\t/**\n+/**\n \t * Sets the type of this token.\n \t *\n \t * @param type The new token type.\n@@ -535,8 +490,7 @@ public interface Token extends TokenTypes {\n \t */\n \tvoid setType(int type);\n \n-\n-\t/**\n+/**\n \t * Returns whether this token starts with the specified characters.\n \t *\n \t * @param chars The characters.\n@@ -546,8 +500,7 @@ public interface Token extends TokenTypes {\n \t */\n \tboolean startsWith(char[] chars);\n \n-\n-\t/**\n+/**\n \t * Returns the position in the document corresponding to the specified\n \t * position in this token's internal char array (<code>textOffset</code> -\n \t * <code>textOffset+textCount-1</code>).<p>\n@@ -563,5 +516,4 @@ public interface Token extends TokenTypes {\n \t */\n \tint tokenToDocument(int pos);\n \n-\n-}\n+    }\n\\ No newline at end of file\n",
            "diff_size": 96
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "76",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 129).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/intuit-Tank/errored/1/189/Token.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/intuit-Tank/codebuff/189/Token.java\nindex 8ac6429eaf8..2b6c6837a42 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/intuit-Tank/errored/1/189/Token.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/intuit-Tank/codebuff/189/Token.java\n@@ -8,8 +8,9 @@\n  */\n package org.fife.ui.rsyntaxtextarea;\n \n-import java.awt.Rectangle;\n \n+\n+import java.awt.Rectangle;\n import javax.swing.text.TabExpander;\n \n \n@@ -34,534 +35,572 @@ import javax.swing.text.TabExpander;\n  * @author Robert Futrell\n  * @version 0.3\n  */\n+\n+\n public interface Token extends TokenTypes {\n \n-\t/**\n-\t * Appends HTML code for painting this token, using the given text area's\n-\t * color scheme.\n-\t *\n-\t * @param sb The buffer to append to.\n-\t * @param textArea The text area whose color scheme to use.\n-\t * @param fontFamily Whether to include the font family in the HTML for\n-\t *        this token.  You can pass <code>false</code> for this parameter\n-\t *        if, for example, you are making all your HTML be monospaced,\n-\t *        and don't want any crazy fonts being used in the editor to be\n-\t *        reflected in your HTML.\n-\t * @return The buffer appended to.\n-\t * @see #getHTMLRepresentation(RSyntaxTextArea)\n-\t */\n-\tStringBuilder appendHTMLRepresentation(StringBuilder sb,\n-\t\t\t\t\t\t\t\t\t\t\tRSyntaxTextArea textArea,\n-\t\t\t\t\t\t\t\t\t\t\tboolean fontFamily);\n-\n-\n-\t/**\n-\t * Appends HTML code for painting this token, using the given text area's\n-\t * color scheme.\n-\t *\n-\t * @param sb The buffer to append to.\n-\t * @param textArea The text area whose color scheme to use.\n-\t * @param fontFamily Whether to include the font family in the HTML for\n-\t *        this token.  You can pass <code>false</code> for this parameter\n-\t *        if, for example, you are making all your HTML be monospaced,\n-\t *        and don't want any crazy fonts being used in the editor to be\n-\t *        reflected in your HTML.\n-\t * @param tabsToSpaces Whether to convert tabs into spaces.\n-\t * @return The buffer appended to.\n-\t * @see #getHTMLRepresentation(RSyntaxTextArea)\n-\t */\n-\tStringBuilder appendHTMLRepresentation(StringBuilder sb,\n-\t\t\t\t\t\t\t\tRSyntaxTextArea textArea, boolean fontFamily,\n-\t\t\t\t\t\t\t\tboolean tabsToSpaces);\n-\n-\n-\t/**\n-\t * Returns the character at the specified offset in the token.\n-\t *\n-\t * @param index The index.  This should be in the range\n-\t *        <code>0-({@link #length()}-1)</code>.\n-\t * @return The character.\n-\t * @see #length()\n-\t */\n-\tchar charAt(int index);\n-\n-\n-\t/**\n-\t * Returns whether the token straddles the specified position in the\n-\t * document.\n-\t *\n-\t * @param pos The position in the document to check.\n-\t * @return Whether the specified position is straddled by this token.\n-\t */\n-\tboolean containsPosition(int pos);\n-\n-\n-\t/**\n-\t * Returns the position in the token's internal char array corresponding\n-\t * to the specified document position.<p>\n-\t * Note that this method does NOT do any bounds checking; you can pass in\n-\t * a document position that does not correspond to a position in this\n-\t * token, and you will not receive an Exception or any other notification;\n-\t * it is up to the caller to ensure valid input.\n-\t *\n-\t * @param pos A position in the document that is represented by this token.\n-\t * @return The corresponding token position &gt;= <code>textOffset</code>\n-\t *         and &lt; <code>textOffset+textCount</code>.\n-\t * @see #tokenToDocument\n-\t */\n-\tint documentToToken(int pos);\n-\n-\n-\t/**\n-\t * Returns whether this token's lexeme ends with the specified characters.\n-\t *\n-\t * @param ch The characters.\n-\t * @return Whether this token's lexeme ends with the specified characters.\n-\t * @see #startsWith(char[])\n-\t */\n-\tboolean endsWith(char[] ch);\n-\n-\n-\t/**\n-\t * Returns the end offset of this token in the document (exclusive).  In\n-\t * other words, the token ranges from\n-\t * <code>[getOffset(), getEndOffset())</code>.\n-\t *\n-\t * @return The end offset of this token.\n-\t * @see #getOffset()\n-\t */\n-\tint getEndOffset();\n-\n-\n-\t/**\n-\t * Returns a <code>String</code> containing HTML code for painting this\n-\t * token, using the given text area's color scheme.\n-\t *\n-\t * @param textArea The text area whose color scheme to use.\n-\t * @return The HTML representation of the token.\n-\t * @see #appendHTMLRepresentation(StringBuilder, RSyntaxTextArea, boolean)\n-\t */\n-\tString getHTMLRepresentation(RSyntaxTextArea textArea);\n-\n-\n-\t/**\n-\t * Returns the language index of this token.\n-\t *\n-\t * @return The language index.  A value of <code>0</code> denotes the\n-\t *        \"main\" language, any positive value denotes a specific secondary\n-\t *        language.\n-\t * @see #setLanguageIndex(int)\n-\t */\n-\tint getLanguageIndex();\n-\n-\n-\t/**\n-\t * Returns the last token in this list that is not whitespace or a\n-\t * comment.\n-\t *\n-\t * @return The last non-comment, non-whitespace token, or <code>null</code>\n-\t *         if there isn't one.\n-\t */\n-\tToken getLastNonCommentNonWhitespaceToken();\n-\n-\n-\t/**\n-\t * Returns the last paintable token in this token list, or <code>null</code>\n-\t * if there is no paintable token.\n-\t *\n-\t * @return The last paintable token in this token list.\n-\t */\n-\tToken getLastPaintableToken();\n-\n-\n-\t/**\n-\t * Returns the text of this token, as a string.<p>\n-\t *\n-\t * Note that this method isn't used much by the\n-\t * <code>ryntaxtextarea</code> package internally, as it tries to limit\n-\t * memory allocation.\n-\t *\n-\t * @return The text of this token.\n-\t */\n-\tString getLexeme();\n-\n-\n-\t/**\n-\t * Determines the offset into this token list (i.e., into the\n-\t * document) that covers pixel location <code>x</code> if the token list\n-\t * starts at pixel location <code>x0</code><p>.\n-\t * This method will return the document position \"closest\" to the\n-\t * x-coordinate (i.e., if they click on the \"right-half\" of the\n-\t * <code>w</code> in <code>awe</code>, the caret will be placed in\n-\t * between the <code>w</code> and <code>e</code>; similarly, clicking on\n-\t * the left-half places the caret between the <code>a</code> and\n-\t * <code>w</code>).  This makes it useful for methods such as\n-\t * <code>viewToModel</code> found in <code>javax.swing.text.View</code>\n-\t * subclasses.\n-\t *\n-\t * @param textArea The text area from which the token list was derived.\n-\t * @param e How to expand tabs.\n-\t * @param x0 The pixel x-location that is the beginning of\n-\t *        <code>tokenList</code>.\n-\t * @param x The pixel-position for which you want to get the corresponding\n-\t *        offset.\n-\t * @return The position (in the document, NOT into the token list!) that\n-\t *         covers the pixel location.  If <code>tokenList</code> is\n-\t *         <code>null</code> or has type <code>Token.NULL</code>, then\n-\t *         <code>-1</code> is returned; the caller should recognize this and\n-\t *         return the actual end position of the (empty) line.\n-\t */\n-\tint getListOffset(RSyntaxTextArea textArea, TabExpander e,\n-\t\t\tfloat x0, float x);\n-\n-\n-\t/**\n-\t * Returns the token after this one in the linked list.\n-\t *\n-\t * @return The next token.\n-\t */\n-\tToken getNextToken();\n-\n-\n-\t/**\n-\t * Returns the offset into the document at which this token resides.\n-\t *\n-\t * @return The offset into the document.\n-\t * @see #getEndOffset()\n-\t */\n-\tint getOffset();\n-\n-\n-\t/**\n-\t * Returns the position in the document that represents the last character\n-\t * in the token that will fit into <code>endBeforeX-startX</code> pixels.\n-\t * For example, if you're using a monospaced 8-pixel-per-character font,\n-\t * have the token \"while\" and <code>startX</code> is <code>0</code> and\n-\t * <code>endBeforeX</code> is <code>30</code>, this method will return the\n-\t * document position of the \"i\" in \"while\", because the \"i\" ends at pixel\n-\t * <code>24</code>, while the \"l\" ends at <code>32</code>.  If not even the\n-\t * first character fits in <code>endBeforeX-startX</code>, the first\n-\t * character's position is still returned so calling methods don't go into\n-\t * infinite loops.\n-\t *\n-\t * @param textArea The text area in which this token is being painted.\n-\t * @param e How to expand tabs.\n-\t * @param startX The x-coordinate at which the token will be painted.  This\n-\t *        is needed because of tabs.\n-\t * @param endBeforeX The x-coordinate for which you want to find the last\n-\t *        character of <code>t</code> which comes before it.\n-\t * @return The last document position that will fit in the specified amount\n-\t *         of pixels.\n-\t */\n-\t/*\n-\t * @see #getTokenListOffsetBeforeX\n-\t * FIXME:  This method does not compute correctly!  It needs to be abstract\n-\t * and implemented by subclasses.\n-\t */\n-\tint getOffsetBeforeX(RSyntaxTextArea textArea, TabExpander e,\n-\t\t\t\t\t\t\tfloat startX, float endBeforeX);\n-\n-\n-\t/**\n-\t * Returns the character array backing the lexeme of this token.  This\n-\t * value should be treated as read-only.\n-\t *\n-\t * @return A character array containing the lexeme of this token.\n-\t * @see #getTextOffset()\n-\t * @see #length()\n-\t */\n-\tchar[] getTextArray();\n-\n-\n-\t/**\n-\t * Returns the offset into the character array of the lexeme in\n-\t * {@link #getTextArray()}.\n-\t *\n-\t * @return The offset of the lexeme in the character array.\n-\t * @see #getTextArray()\n-\t */\n-\tint getTextOffset();\n-\n-\n-\t/**\n-\t * Returns the type of this token.\n-\t *\n-\t * @return The type of this token.\n-\t * @see TokenTypes\n-\t * @see #setType(int)\n-\t */\n-\tint getType();\n-\n-\n-\t/**\n-\t * Returns the width of this token given the specified parameters.\n-\t *\n-\t * @param textArea The text area in which the token is being painted.\n-\t * @param e Describes how to expand tabs.  This parameter cannot be\n-\t *        <code>null</code>.\n-\t * @param x0 The pixel-location at which the token begins.  This is needed\n-\t *        because of tabs.\n-\t * @return The width of the token, in pixels.\n-\t * @see #getWidthUpTo\n-\t */\n-\tfloat getWidth(RSyntaxTextArea textArea, TabExpander e, float x0);\n-\n-\n-\t/**\n-\t * Returns the width of a specified number of characters in this token.\n-\t * For example, for the token \"while\", specifying a value of <code>3</code>\n-\t * here returns the width of the \"whi\" portion of the token.\n-\t *\n-\t * @param numChars The number of characters for which to get the width.\n-\t * @param textArea The text area in which the token is being painted.\n-\t * @param e How to expand tabs.  This value cannot be <code>null</code>.\n-\t * @param x0 The pixel-location at which this token begins.  This is needed\n-\t *        because of tabs.\n-\t * @return The width of the specified number of characters in this token.\n-\t * @see #getWidth\n-\t */\n-\tfloat getWidthUpTo(int numChars, RSyntaxTextArea textArea,\n-\t\t\tTabExpander e, float x0);\n-\n-\n-\t/**\n-\t * Returns whether this token's lexeme matches a specific character array.\n-\t *\n-\t * @param lexeme The lexeme to check for.\n-\t * @return Whether this token has that lexeme.\n-\t * @see #is(int, char[])\n-\t * @see #is(int, String)\n-\t * @see #isSingleChar(int, char)\n-\t * @see #startsWith(char[])\n-\t */\n-\tboolean is(char[] lexeme);\n-\n-\n-\t/**\n-\t * Returns whether this token is of the specified type, with the specified\n-\t * lexeme.<p>\n-\t * This method is preferred over the other overload in performance-critical\n-\t * code where this operation may be called frequently, since it does not\n-\t * involve any String allocations.\n-\t *\n-\t * @param type The type to check for.\n-\t * @param lexeme The lexeme to check for.\n-\t * @return Whether this token has that type and lexeme.\n-\t * @see #is(int, String)\n-\t * @see #is(char[])\n-\t * @see #isSingleChar(int, char)\n-\t * @see #startsWith(char[])\n-\t */\n-\tboolean is(int type, char[] lexeme);\n-\n-\n-\t/**\n-\t * Returns whether this token is of the specified type, with the specified\n-\t * lexeme.<p>\n-\t * The other overload of this method is preferred over this one in\n-\t * performance-critical code, as this one involves a String allocation\n-\t * while the other does not.\n-\t *\n-\t * @param type The type to check for.\n-\t * @param lexeme The lexeme to check for.\n-\t * @return Whether this token has that type and lexeme.\n-\t * @see #is(int, char[])\n-\t * @see #isSingleChar(int, char)\n-\t * @see #startsWith(char[])\n-\t */\n-\tboolean is(int type, String lexeme);\n-\n-\n-\t/**\n-\t * Returns whether this token is a comment.\n-\t *\n-\t * @return Whether this token is a comment.\n-\t * @see #isWhitespace()\n-\t * @see #isCommentOrWhitespace()\n-\t */\n-\tboolean isComment();\n-\n-\n-\t/**\n-\t * Returns whether this token is a comment or whitespace.\n-\t *\n-\t * @return Whether this token is a comment or whitespace.\n-\t * @see #isComment()\n-\t * @see #isWhitespace()\n-\t */\n-\tboolean isCommentOrWhitespace();\n-\n-\n-\t/**\n-\t * Returns whether this token is a hyperlink.\n-\t *\n-\t * @return Whether this token is a hyperlink.\n-\t * @see #setHyperlink(boolean)\n-\t */\n-\tboolean isHyperlink();\n-\n-\n-\t/**\n-\t * Returns whether this token is an identifier.\n-\t *\n-\t * @return Whether this token is an identifier.\n-\t */\n-\tboolean isIdentifier();\n-\n-\n-\t/**\n-\t * Returns whether this token is a {@link #SEPARATOR} representing a single\n-\t * left curly brace.\n-\t *\n-\t * @return Whether this token is a left curly brace.\n-\t * @see #isRightCurly()\n-\t */\n-\tboolean isLeftCurly();\n-\n-\n-\t/**\n-\t * Returns whether this token is a {@link #SEPARATOR} representing a single\n-\t * right curly brace.\n-\t *\n-\t * @return Whether this token is a right curly brace.\n-\t * @see #isLeftCurly()\n-\t */\n-\tboolean isRightCurly();\n-\n-\n-\t/**\n-\t * Returns whether or not this token is \"paintable;\" i.e., whether or not\n-\t * the type of this token is one such that it has an associated syntax\n-\t * style.  What this boils down to is whether the token type is greater\n-\t * than <code>Token.NULL</code>.\n-\t *\n-\t * @return Whether or not this token is paintable.\n-\t */\n-\tboolean isPaintable();\n-\n-\n-\t/**\n-\t * Returns whether this token is the specified single character.\n-\t *\n-\t * @param ch The character to check for.\n-\t * @return Whether this token's lexeme is the single character specified.\n-\t * @see #isSingleChar(int, char)\n-\t */\n-\tboolean isSingleChar(char ch);\n-\n-\n-\t/**\n-\t * Returns whether this token is the specified single character, and of a\n-\t * specific type.\n-\t *\n-\t * @param type The token type.\n-\t * @param ch The character to check for.\n-\t * @return Whether this token is of the specified type, and with a lexeme\n-\t *         Equaling the single character specified.\n-\t * @see #isSingleChar(char)\n-\t */\n-\tboolean isSingleChar(int type, char ch);\n-\n-\n-\t/**\n-\t * Returns whether or not this token is whitespace.\n-\t *\n-\t * @return <code>true</code> iff this token is whitespace.\n-\t * @see #isComment()\n-\t * @see #isCommentOrWhitespace()\n-\t */\n-\tboolean isWhitespace();\n-\n-\n-\t/**\n-\t * Returns the length of this token.\n-\t *\n-\t * @return The length of this token.\n-\t * @see #getOffset()\n-\t */\n-\tint length();\n-\n-\n-\t/**\n-\t * Returns the bounding box for the specified document location.  The\n-\t * location must be in the specified token list; if it isn't,\n-\t * <code>null</code> is returned.\n-\t *\n-\t * @param textArea The text area from which the token list was derived.\n-\t * @param e How to expand tabs.\n-\t * @param pos The position in the document for which to get the bounding\n-\t *        box in the view.\n-\t * @param x0 The pixel x-location that is the beginning of\n-\t *        <code>tokenList</code>.\n-\t * @param rect The rectangle in which we'll be returning the results.  This\n-\t *        object is reused to keep from frequent memory allocations.\n-\t * @return The bounding box for the specified position in the model.\n-\t */\n-\tRectangle listOffsetToView(RSyntaxTextArea textArea, TabExpander e,\n-\t\t\tint pos, int x0, Rectangle rect);\n-\n-\n-\t/**\n-\t * Sets whether this token is a hyperlink.\n-\t *\n-\t * @param hyperlink Whether this token is a hyperlink.\n-\t * @see #isHyperlink()\n-\t */\n-\tvoid setHyperlink(boolean hyperlink);\n-\n-\n-\t/**\n-\t * Sets the language index for this token.  If this value is positive, it\n-\t * denotes a specific \"secondary\" language this token represents (such as\n-\t * JavaScript code or CSS embedded in an HTML file).  If this value is\n-\t * <code>0</code>, this token is in the \"main\" language being edited.\n-\t * Negative values are invalid and treated as <code>0</code>.\n-\t *\n-\t * @param languageIndex The new language index.  A value of\n-\t *        <code>0</code> denotes the \"main\" language, any positive value\n-\t *        denotes a specific secondary language.  Negative values will\n-\t *        be treated as <code>0</code>.\n-\t * @see #getLanguageIndex()\n-\t */\n-\tvoid setLanguageIndex(int languageIndex);\n-\n-\n-\t/**\n-\t * Sets the type of this token.\n-\t *\n-\t * @param type The new token type.\n-\t * @see TokenTypes\n-\t * @see #getType()\n-\t */\n-\tvoid setType(int type);\n-\n-\n-\t/**\n-\t * Returns whether this token starts with the specified characters.\n-\t *\n-\t * @param chars The characters.\n-\t * @return Whether this token starts with those characters.\n-\t * @see #endsWith(char[])\n-\t * @see #is(int, char[])\n-\t */\n-\tboolean startsWith(char[] chars);\n-\n-\n-\t/**\n-\t * Returns the position in the document corresponding to the specified\n-\t * position in this token's internal char array (<code>textOffset</code> -\n-\t * <code>textOffset+textCount-1</code>).<p>\n-\t * Note that this method does NOT do any bounds checking; you can pass in\n-\t * an invalid token position, and you will not receive an Exception or any\n-\t * other indication that the returned document position is invalid.  It is\n-\t * up to the user to ensure valid input.\n-\t *\n-\t * @param pos A position in the token's internal char array\n-\t *        (<code>textOffset</code> - <code>textOffset+textCount</code>).\n-\t * @return The corresponding position in the document.\n-\t * @see #documentToToken(int)\n-\t */\n-\tint tokenToDocument(int pos);\n-\n-\n-}\n+    /**\n+     * Appends HTML code for painting this token, using the given text area's\n+     * color scheme.\n+     *\n+     * @param sb The buffer to append to.\n+     * @param textArea The text area whose color scheme to use.\n+     * @param fontFamily Whether to include the font family in the HTML for\n+     *        this token.  You can pass <code>false</code> for this parameter\n+     *        if, for example, you are making all your HTML be monospaced,\n+     *        and don't want any crazy fonts being used in the editor to be\n+     *        reflected in your HTML.\n+     * @return The buffer appended to.\n+     * @see #getHTMLRepresentation(RSyntaxTextArea)\n+     */\n+\n+    StringBuilder appendHTMLRepresentation(StringBuilder sb, RSyntaxTextArea textArea, boolean fontFamily);\n+\n+\n+    /**\n+     * Appends HTML code for painting this token, using the given text area's\n+     * color scheme.\n+     *\n+     * @param sb The buffer to append to.\n+     * @param textArea The text area whose color scheme to use.\n+     * @param fontFamily Whether to include the font family in the HTML for\n+     *        this token.  You can pass <code>false</code> for this parameter\n+     *        if, for example, you are making all your HTML be monospaced,\n+     *        and don't want any crazy fonts being used in the editor to be\n+     *        reflected in your HTML.\n+     * @param tabsToSpaces Whether to convert tabs into spaces.\n+     * @return The buffer appended to.\n+     * @see #getHTMLRepresentation(RSyntaxTextArea)\n+     */\n+\n+    StringBuilder appendHTMLRepresentation(StringBuilder sb, RSyntaxTextArea textArea, boolean fontFamily, boolean tabsToSpaces);\n+\n+\n+    /**\n+     * Returns the character at the specified offset in the token.\n+     *\n+     * @param index The index.  This should be in the range\n+     *        <code>0-({@link #length()}-1)</code>.\n+     * @return The character.\n+     * @see #length()\n+     */\n+\n+\n+    char charAt(int index);\n+\n+\n+    /**\n+     * Returns whether the token straddles the specified position in the\n+     * document.\n+     *\n+     * @param pos The position in the document to check.\n+     * @return Whether the specified position is straddled by this token.\n+     */\n+\n+    boolean containsPosition(int pos);\n+\n+\n+    /**\n+     * Returns the position in the token's internal char array corresponding\n+     * to the specified document position.<p>\n+     * Note that this method does NOT do any bounds checking; you can pass in\n+     * a document position that does not correspond to a position in this\n+     * token, and you will not receive an Exception or any other notification;\n+     * it is up to the caller to ensure valid input.\n+     *\n+     * @param pos A position in the document that is represented by this token.\n+     * @return The corresponding token position &gt;= <code>textOffset</code>\n+     *         and &lt; <code>textOffset+textCount</code>.\n+     * @see #tokenToDocument\n+     */\n+\n+    int documentToToken(int pos);\n+\n+\n+    /**\n+     * Returns whether this token's lexeme ends with the specified characters.\n+     *\n+     * @param ch The characters.\n+     * @return Whether this token's lexeme ends with the specified characters.\n+     * @see #startsWith(char[])\n+     */\n+\n+    boolean endsWith(char[] ch);\n+\n+\n+    /**\n+     * Returns the end offset of this token in the document (exclusive).  In\n+     * other words, the token ranges from\n+     * <code>[getOffset(), getEndOffset())</code>.\n+     *\n+     * @return The end offset of this token.\n+     * @see #getOffset()\n+     */\n+\n+    int getEndOffset();\n+\n+\n+    /**\n+     * Returns a <code>String</code> containing HTML code for painting this\n+     * token, using the given text area's color scheme.\n+     *\n+     * @param textArea The text area whose color scheme to use.\n+     * @return The HTML representation of the token.\n+     * @see #appendHTMLRepresentation(StringBuilder, RSyntaxTextArea, boolean)\n+     */\n+\n+    String getHTMLRepresentation(RSyntaxTextArea textArea);\n+\n+\n+    /**\n+     * Returns the language index of this token.\n+     *\n+     * @return The language index.  A value of <code>0</code> denotes the\n+     *        \"main\" language, any positive value denotes a specific secondary\n+     *        language.\n+     * @see #setLanguageIndex(int)\n+     */\n+\n+    int getLanguageIndex();\n+\n+\n+    /**\n+     * Returns the last token in this list that is not whitespace or a\n+     * comment.\n+     *\n+     * @return The last non-comment, non-whitespace token, or <code>null</code>\n+     *         if there isn't one.\n+     */\n+\n+    Token getLastNonCommentNonWhitespaceToken();\n+\n+\n+    /**\n+     * Returns the last paintable token in this token list, or <code>null</code>\n+     * if there is no paintable token.\n+     *\n+     * @return The last paintable token in this token list.\n+     */\n+\n+    Token getLastPaintableToken();\n+\n+\n+    /**\n+     * Returns the text of this token, as a string.<p>\n+     *\n+     * Note that this method isn't used much by the\n+     * <code>ryntaxtextarea</code> package internally, as it tries to limit\n+     * memory allocation.\n+     *\n+     * @return The text of this token.\n+     */\n+\n+    String getLexeme();\n+\n+\n+    /**\n+     * Determines the offset into this token list (i.e., into the\n+     * document) that covers pixel location <code>x</code> if the token list\n+     * starts at pixel location <code>x0</code><p>.\n+     * This method will return the document position \"closest\" to the\n+     * x-coordinate (i.e., if they click on the \"right-half\" of the\n+     * <code>w</code> in <code>awe</code>, the caret will be placed in\n+     * between the <code>w</code> and <code>e</code>; similarly, clicking on\n+     * the left-half places the caret between the <code>a</code> and\n+     * <code>w</code>).  This makes it useful for methods such as\n+     * <code>viewToModel</code> found in <code>javax.swing.text.View</code>\n+     * subclasses.\n+     *\n+     * @param textArea The text area from which the token list was derived.\n+     * @param e How to expand tabs.\n+     * @param x0 The pixel x-location that is the beginning of\n+     *        <code>tokenList</code>.\n+     * @param x The pixel-position for which you want to get the corresponding\n+     *        offset.\n+     * @return The position (in the document, NOT into the token list!) that\n+     *         covers the pixel location.  If <code>tokenList</code> is\n+     *         <code>null</code> or has type <code>Token.NULL</code>, then\n+     *         <code>-1</code> is returned; the caller should recognize this and\n+     *         return the actual end position of the (empty) line.\n+     */\n+\n+    int getListOffset(RSyntaxTextArea textArea, TabExpander e, float x0, float x);\n+\n+\n+    /**\n+     * Returns the token after this one in the linked list.\n+     *\n+     * @return The next token.\n+     */\n+\n+    Token getNextToken();\n+\n+\n+    /**\n+     * Returns the offset into the document at which this token resides.\n+     *\n+     * @return The offset into the document.\n+     * @see #getEndOffset()\n+     */\n+\n+    int getOffset();\n+\n+\n+    /**\n+     * Returns the position in the document that represents the last character\n+     * in the token that will fit into <code>endBeforeX-startX</code> pixels.\n+     * For example, if you're using a monospaced 8-pixel-per-character font,\n+     * have the token \"while\" and <code>startX</code> is <code>0</code> and\n+     * <code>endBeforeX</code> is <code>30</code>, this method will return the\n+     * document position of the \"i\" in \"while\", because the \"i\" ends at pixel\n+     * <code>24</code>, while the \"l\" ends at <code>32</code>.  If not even the\n+     * first character fits in <code>endBeforeX-startX</code>, the first\n+     * character's position is still returned so calling methods don't go into\n+     * infinite loops.\n+     *\n+     * @param textArea The text area in which this token is being painted.\n+     * @param e How to expand tabs.\n+     * @param startX The x-coordinate at which the token will be painted.  This\n+     *        is needed because of tabs.\n+     * @param endBeforeX The x-coordinate for which you want to find the last\n+     *        character of <code>t</code> which comes before it.\n+     * @return The last document position that will fit in the specified amount\n+     *         of pixels.\n+     */\n+    /*\n+     * @see #getTokenListOffsetBeforeX\n+     * FIXME:  This method does not compute correctly!  It needs to be abstract\n+     * and implemented by subclasses.\n+     */\n+\n+    int getOffsetBeforeX(RSyntaxTextArea textArea, TabExpander e, float startX, float endBeforeX);\n+\n+\n+    /**\n+     * Returns the character array backing the lexeme of this token.  This\n+     * value should be treated as read-only.\n+     *\n+     * @return A character array containing the lexeme of this token.\n+     * @see #getTextOffset()\n+     * @see #length()\n+     */\n+\n+\n+    char[] getTextArray();\n+\n+\n+    /**\n+     * Returns the offset into the character array of the lexeme in\n+     * {@link #getTextArray()}.\n+     *\n+     * @return The offset of the lexeme in the character array.\n+     * @see #getTextArray()\n+     */\n+\n+    int getTextOffset();\n+\n+\n+    /**\n+     * Returns the type of this token.\n+     *\n+     * @return The type of this token.\n+     * @see TokenTypes\n+     * @see #setType(int)\n+     */\n+\n+    int getType();\n+\n+\n+    /**\n+     * Returns the width of this token given the specified parameters.\n+     *\n+     * @param textArea The text area in which the token is being painted.\n+     * @param e Describes how to expand tabs.  This parameter cannot be\n+     *        <code>null</code>.\n+     * @param x0 The pixel-location at which the token begins.  This is needed\n+     *        because of tabs.\n+     * @return The width of the token, in pixels.\n+     * @see #getWidthUpTo\n+     */\n+\n+\n+    float getWidth(RSyntaxTextArea textArea, TabExpander e, float x0);\n+\n+\n+    /**\n+     * Returns the width of a specified number of characters in this token.\n+     * For example, for the token \"while\", specifying a value of <code>3</code>\n+     * here returns the width of the \"whi\" portion of the token.\n+     *\n+     * @param numChars The number of characters for which to get the width.\n+     * @param textArea The text area in which the token is being painted.\n+     * @param e How to expand tabs.  This value cannot be <code>null</code>.\n+     * @param x0 The pixel-location at which this token begins.  This is needed\n+     *        because of tabs.\n+     * @return The width of the specified number of characters in this token.\n+     * @see #getWidth\n+     */\n+\n+\n+    float getWidthUpTo(int numChars, RSyntaxTextArea textArea, TabExpander e, float x0);\n+\n+\n+    /**\n+     * Returns whether this token's lexeme matches a specific character array.\n+     *\n+     * @param lexeme The lexeme to check for.\n+     * @return Whether this token has that lexeme.\n+     * @see #is(int, char[])\n+     * @see #is(int, String)\n+     * @see #isSingleChar(int, char)\n+     * @see #startsWith(char[])\n+     */\n+\n+    boolean is(char[] lexeme);\n+\n+\n+    /**\n+     * Returns whether this token is of the specified type, with the specified\n+     * lexeme.<p>\n+     * This method is preferred over the other overload in performance-critical\n+     * code where this operation may be called frequently, since it does not\n+     * involve any String allocations.\n+     *\n+     * @param type The type to check for.\n+     * @param lexeme The lexeme to check for.\n+     * @return Whether this token has that type and lexeme.\n+     * @see #is(int, String)\n+     * @see #is(char[])\n+     * @see #isSingleChar(int, char)\n+     * @see #startsWith(char[])\n+     */\n+\n+    boolean is(int type, char[] lexeme);\n+\n+\n+    /**\n+     * Returns whether this token is of the specified type, with the specified\n+     * lexeme.<p>\n+     * The other overload of this method is preferred over this one in\n+     * performance-critical code, as this one involves a String allocation\n+     * while the other does not.\n+     *\n+     * @param type The type to check for.\n+     * @param lexeme The lexeme to check for.\n+     * @return Whether this token has that type and lexeme.\n+     * @see #is(int, char[])\n+     * @see #isSingleChar(int, char)\n+     * @see #startsWith(char[])\n+     */\n+\n+    boolean is(int type, String lexeme);\n+\n+\n+    /**\n+     * Returns whether this token is a comment.\n+     *\n+     * @return Whether this token is a comment.\n+     * @see #isWhitespace()\n+     * @see #isCommentOrWhitespace()\n+     */\n+\n+    boolean isComment();\n+\n+\n+    /**\n+     * Returns whether this token is a comment or whitespace.\n+     *\n+     * @return Whether this token is a comment or whitespace.\n+     * @see #isComment()\n+     * @see #isWhitespace()\n+     */\n+\n+    boolean isCommentOrWhitespace();\n+\n+\n+    /**\n+     * Returns whether this token is a hyperlink.\n+     *\n+     * @return Whether this token is a hyperlink.\n+     * @see #setHyperlink(boolean)\n+     */\n+\n+    boolean isHyperlink();\n+\n+\n+    /**\n+     * Returns whether this token is an identifier.\n+     *\n+     * @return Whether this token is an identifier.\n+     */\n+\n+    boolean isIdentifier();\n+\n+\n+    /**\n+     * Returns whether this token is a {@link #SEPARATOR} representing a single\n+     * left curly brace.\n+     *\n+     * @return Whether this token is a left curly brace.\n+     * @see #isRightCurly()\n+     */\n+\n+    boolean isLeftCurly();\n+\n+\n+    /**\n+     * Returns whether this token is a {@link #SEPARATOR} representing a single\n+     * right curly brace.\n+     *\n+     * @return Whether this token is a right curly brace.\n+     * @see #isLeftCurly()\n+     */\n+\n+    boolean isRightCurly();\n+\n+\n+    /**\n+     * Returns whether or not this token is \"paintable;\" i.e., whether or not\n+     * the type of this token is one such that it has an associated syntax\n+     * style.  What this boils down to is whether the token type is greater\n+     * than <code>Token.NULL</code>.\n+     *\n+     * @return Whether or not this token is paintable.\n+     */\n+\n+    boolean isPaintable();\n+\n+\n+    /**\n+     * Returns whether this token is the specified single character.\n+     *\n+     * @param ch The character to check for.\n+     * @return Whether this token's lexeme is the single character specified.\n+     * @see #isSingleChar(int, char)\n+     */\n+\n+    boolean isSingleChar(char ch);\n+\n+\n+    /**\n+     * Returns whether this token is the specified single character, and of a\n+     * specific type.\n+     *\n+     * @param type The token type.\n+     * @param ch The character to check for.\n+     * @return Whether this token is of the specified type, and with a lexeme\n+     *         Equaling the single character specified.\n+     * @see #isSingleChar(char)\n+     */\n+\n+    boolean isSingleChar(int type, char ch);\n+\n+\n+    /**\n+     * Returns whether or not this token is whitespace.\n+     *\n+     * @return <code>true</code> iff this token is whitespace.\n+     * @see #isComment()\n+     * @see #isCommentOrWhitespace()\n+     */\n+\n+    boolean isWhitespace();\n+\n+\n+    /**\n+     * Returns the length of this token.\n+     *\n+     * @return The length of this token.\n+     * @see #getOffset()\n+     */\n+\n+    int length();\n+\n+\n+    /**\n+     * Returns the bounding box for the specified document location.  The\n+     * location must be in the specified token list; if it isn't,\n+     * <code>null</code> is returned.\n+     *\n+     * @param textArea The text area from which the token list was derived.\n+     * @param e How to expand tabs.\n+     * @param pos The position in the document for which to get the bounding\n+     *        box in the view.\n+     * @param x0 The pixel x-location that is the beginning of\n+     *        <code>tokenList</code>.\n+     * @param rect The rectangle in which we'll be returning the results.  This\n+     *        object is reused to keep from frequent memory allocations.\n+     * @return The bounding box for the specified position in the model.\n+     */\n+\n+    Rectangle listOffsetToView(RSyntaxTextArea textArea, TabExpander e, int pos, int x0, Rectangle rect);\n+\n+\n+    /**\n+     * Sets whether this token is a hyperlink.\n+     *\n+     * @param hyperlink Whether this token is a hyperlink.\n+     * @see #isHyperlink()\n+     */\n+\n+    void setHyperlink(boolean hyperlink);\n+\n+\n+    /**\n+     * Sets the language index for this token.  If this value is positive, it\n+     * denotes a specific \"secondary\" language this token represents (such as\n+     * JavaScript code or CSS embedded in an HTML file).  If this value is\n+     * <code>0</code>, this token is in the \"main\" language being edited.\n+     * Negative values are invalid and treated as <code>0</code>.\n+     *\n+     * @param languageIndex The new language index.  A value of\n+     *        <code>0</code> denotes the \"main\" language, any positive value\n+     *        denotes a specific secondary language.  Negative values will\n+     *        be treated as <code>0</code>.\n+     * @see #getLanguageIndex()\n+     */\n+\n+    void setLanguageIndex(int languageIndex);\n+\n+\n+    /**\n+     * Sets the type of this token.\n+     *\n+     * @param type The new token type.\n+     * @see TokenTypes\n+     * @see #getType()\n+     */\n+\n+    void setType(int type);\n+\n+\n+    /**\n+     * Returns whether this token starts with the specified characters.\n+     *\n+     * @param chars The characters.\n+     * @return Whether this token starts with those characters.\n+     * @see #endsWith(char[])\n+     * @see #is(int, char[])\n+     */\n+\n+    boolean startsWith(char[] chars);\n+\n+\n+    /**\n+     * Returns the position in the document corresponding to the specified\n+     * position in this token's internal char array (<code>textOffset</code> -\n+     * <code>textOffset+textCount-1</code>).<p>\n+     * Note that this method does NOT do any bounds checking; you can pass in\n+     * an invalid token position, and you will not receive an Exception or any\n+     * other indication that the returned document position is invalid.  It is\n+     * up to the user to ensure valid input.\n+     *\n+     * @param pos A position in the token's internal char array\n+     *        (<code>textOffset</code> - <code>textOffset+textCount</code>).\n+     * @return The corresponding position in the document.\n+     * @see #documentToToken(int)\n+     */\n+\n+    int tokenToDocument(int pos);\n+\n+}\n\\ No newline at end of file\n",
            "diff_size": 570
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "40",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/intuit-Tank/errored/1/189/Token.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/intuit-Tank/styler_random/189/Token.java\nindex 8ac6429eaf8..d592d80ba73 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/intuit-Tank/errored/1/189/Token.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/intuit-Tank/styler_random/189/Token.java\n@@ -36,7 +36,7 @@ import javax.swing.text.TabExpander;\n  */\n public interface Token extends TokenTypes {\n \n-\t/**\n+    /**\n \t * Appends HTML code for painting this token, using the given text area's\n \t * color scheme.\n \t *\n@@ -50,7 +50,7 @@ public interface Token extends TokenTypes {\n \t * @return The buffer appended to.\n \t * @see #getHTMLRepresentation(RSyntaxTextArea)\n \t */\n-\tStringBuilder appendHTMLRepresentation(StringBuilder sb,\n+ StringBuilder appendHTMLRepresentation(StringBuilder sb,\n \t\t\t\t\t\t\t\t\t\t\tRSyntaxTextArea textArea,\n \t\t\t\t\t\t\t\t\t\t\tboolean fontFamily);\n \n",
            "diff_size": 2
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "40",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/intuit-Tank/errored/1/189/Token.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/intuit-Tank/styler_three_grams/189/Token.java\nindex 8ac6429eaf8..d592d80ba73 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/intuit-Tank/errored/1/189/Token.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/intuit-Tank/styler_three_grams/189/Token.java\n@@ -36,7 +36,7 @@ import javax.swing.text.TabExpander;\n  */\n public interface Token extends TokenTypes {\n \n-\t/**\n+    /**\n \t * Appends HTML code for painting this token, using the given text area's\n \t * color scheme.\n \t *\n@@ -50,7 +50,7 @@ public interface Token extends TokenTypes {\n \t * @return The buffer appended to.\n \t * @see #getHTMLRepresentation(RSyntaxTextArea)\n \t */\n-\tStringBuilder appendHTMLRepresentation(StringBuilder sb,\n+ StringBuilder appendHTMLRepresentation(StringBuilder sb,\n \t\t\t\t\t\t\t\t\t\t\tRSyntaxTextArea textArea,\n \t\t\t\t\t\t\t\t\t\t\tboolean fontFamily);\n \n",
            "diff_size": 2
        }
    ],
    "repaired_by": [
        "intellij"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}