{
    "project_name": "codefollower-H2-Research",
    "error_id": "479",
    "information": {
        "errors": [
            {
                "line": "68",
                "column": "9",
                "severity": "warning",
                "message": "File contains tab characters (this is the first instance).",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
            }
        ]
    },
    "source_code": "            store.update(root);\n        } else {\n        \t//\u7b2c\u4e00\u6b21\u4eceorg.h2.store.PageStore.openMetaIndex()\u90a3\u8f6c\u8fc7\u6765\u65f6\uff0cid\u662f-1\uff0c\u6b64\u65f6\u53d6\u51fa\u6765\u7684rootPageId\u662f4\n        \t//\u662f\u5728org.h2.store.PageStore.open()\u90a3\u4e8b\u5148\u653e\u5165\u7684\uff0cpageId=4\u7684\u9875\u56fa\u5b9a\u662fmetaIndex\u7684rootPageId\n            rootPageId = store.getRootPageId(id);\n            PageData root = getPage(rootPageId, 0);",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/479/PageDataIndex.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler/479/PageDataIndex.java\nindex 005fce07b2e..cf6d914081d 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/479/PageDataIndex.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler/479/PageDataIndex.java\n@@ -65,8 +65,8 @@ public class PageDataIndex extends PageIndex {\n             PageDataLeaf root = PageDataLeaf.create(this, rootPageId, PageData.ROOT);\n             store.update(root);\n         } else {\n-        \t//\u7b2c\u4e00\u6b21\u4eceorg.h2.store.PageStore.openMetaIndex()\u90a3\u8f6c\u8fc7\u6765\u65f6\uff0cid\u662f-1\uff0c\u6b64\u65f6\u53d6\u51fa\u6765\u7684rootPageId\u662f4\n-        \t//\u662f\u5728org.h2.store.PageStore.open()\u90a3\u4e8b\u5148\u653e\u5165\u7684\uff0cpageId=4\u7684\u9875\u56fa\u5b9a\u662fmetaIndex\u7684rootPageId\n+        //\u7b2c\u4e00\u6b21\u4eceorg.h2.store.PageStore.openMetaIndex()\u90a3\u8f6c\u8fc7\u6765\u65f6\uff0cid\u662f-1\uff0c\u6b64\u65f6\u53d6\u51fa\u6765\u7684rootPageId\u662f4\n+         //\u662f\u5728org.h2.store.PageStore.open()\u90a3\u4e8b\u5148\u653e\u5165\u7684\uff0cpageId=4\u7684\u9875\u56fa\u5b9a\u662fmetaIndex\u7684rootPageId\n             rootPageId = store.getRootPageId(id);\n             PageData root = getPage(rootPageId, 0);\n             lastKey = root.getLastKey();\n",
            "diff_size": 2
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/479/PageDataIndex.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/479/PageDataIndex.java\nindex 005fce07b2e..e3a012b5d2b 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/479/PageDataIndex.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/479/PageDataIndex.java\n@@ -3,6 +3,7 @@\n  * and the EPL 1.0 (https://h2database.com/html/license.html).\n  * Initial Developer: H2 Group\n  */\n+\n package org.h2.pagestore.db;\n \n import org.h2.api.ErrorCode;\n@@ -32,476 +33,476 @@ import org.h2.value.ValueNull;\n  */\n public class PageDataIndex extends PageIndex {\n \n-    private final PageStore store;\n-    private final PageStoreTable tableData;\n-    private long lastKey;\n-    private long rowCount;\n-    private int mainIndexColumn = -1;\n-    private DbException fastDuplicateKeyException;\n-\n-    /**\n-     * The estimated heap memory per page, in number of double words (4 bytes\n-     * each).\n-     */\n-    private int memoryPerPage;\n-    private int memoryCount;\n-\n-    //PageDataIndex\u7684id\u5c31\u662f\u8868\u7684id\uff0c\u5176\u4ed6\u7d22\u5f15\u5982PageBtreeIndex\u7684id\u662f\u81ea\u52a8\u5206\u914d\u7684\u5e76\u4e0d\u662f\u8868\u7684id\n-    public PageDataIndex(PageStoreTable table, int id, IndexColumn[] columns,\n-            IndexType indexType, boolean create, Session session) {\n-        super(table, id, table.getName() + \"_DATA\", columns, indexType);\n-\n-        // trace = database.getTrace(Trace.PAGE_STORE + \"_di\");\n-        // trace.setLevel(TraceSystem.DEBUG);\n-        tableData = table;\n-        this.store = database.getPageStore();\n-        store.addIndex(this);\n-        if (!database.isPersistent()) {\n-            throw DbException.throwInternalError(table.getName());\n+  private final PageStore store;\n+  private final PageStoreTable tableData;\n+  private long lastKey;\n+  private long rowCount;\n+  private int mainIndexColumn = -1;\n+  private DbException fastDuplicateKeyException;\n+\n+  /**\n+   * The estimated heap memory per page, in number of double words (4 bytes\n+   * each).\n+   */\n+  private int memoryPerPage;\n+  private int memoryCount;\n+\n+  //PageDataIndex\u7684id\u5c31\u662f\u8868\u7684id\uff0c\u5176\u4ed6\u7d22\u5f15\u5982PageBtreeIndex\u7684id\u662f\u81ea\u52a8\u5206\u914d\u7684\u5e76\u4e0d\u662f\u8868\u7684id\n+  public PageDataIndex(PageStoreTable table, int id, IndexColumn[] columns,\n+                       IndexType indexType, boolean create, Session session) {\n+    super(table, id, table.getName() + \"_DATA\", columns, indexType);\n+\n+    // trace = database.getTrace(Trace.PAGE_STORE + \"_di\");\n+    // trace.setLevel(TraceSystem.DEBUG);\n+    tableData = table;\n+    this.store = database.getPageStore();\n+    store.addIndex(this);\n+    if (!database.isPersistent()) {\n+      throw DbException.throwInternalError(table.getName());\n+    }\n+    if (create) {\n+      rootPageId = store.allocatePage();\n+      store.addMeta(this, session);\n+      PageDataLeaf root = PageDataLeaf.create(this, rootPageId, PageData.ROOT);\n+      store.update(root);\n+    } else {\n+      //\u7b2c\u4e00\u6b21\u4eceorg.h2.store.PageStore.openMetaIndex()\u90a3\u8f6c\u8fc7\u6765\u65f6\uff0cid\u662f-1\uff0c\u6b64\u65f6\u53d6\u51fa\u6765\u7684rootPageId\u662f4\n+      //\u662f\u5728org.h2.store.PageStore.open()\u90a3\u4e8b\u5148\u653e\u5165\u7684\uff0cpageId=4\u7684\u9875\u56fa\u5b9a\u662fmetaIndex\u7684rootPageId\n+      rootPageId = store.getRootPageId(id);\n+      PageData root = getPage(rootPageId, 0);\n+      lastKey = root.getLastKey();\n+      rowCount = root.getRowCount();\n+    }\n+    if (trace.isDebugEnabled()) {\n+      trace.debug(\"{0} opened rows: {1}\", this, rowCount);\n+    }\n+    table.setRowCount(rowCount);\n+    memoryPerPage = (Constants.MEMORY_PAGE_DATA + store.getPageSize()) >> 2;\n+  }\n+\n+  @Override\n+  public DbException getDuplicateKeyException(String key) {\n+    if (fastDuplicateKeyException == null) {\n+      fastDuplicateKeyException = super.getDuplicateKeyException(null);\n+    }\n+    return fastDuplicateKeyException;\n+  }\n+\n+  @Override\n+  public void add(Session session, Row row) {\n+    boolean retry = false;\n+    if (mainIndexColumn != -1) {\n+      row.setKey(row.getValue(mainIndexColumn).getLong());\n+    } else {\n+      if (row.getKey() == 0) {\n+        row.setKey((int) ++lastKey);\n+        retry = true;\n+      }\n+    }\n+    if (tableData.getContainsLargeObject()) {\n+      for (int i = 0, len = row.getColumnCount(); i < len; i++) {\n+        Value v = row.getValue(i);\n+        Value v2 = v.copy(database, getId());\n+        if (v2.isLinkedToTable()) {\n+          session.removeAtCommitStop(v2);\n         }\n-        if (create) {\n-            rootPageId = store.allocatePage();\n-            store.addMeta(this, session);\n-            PageDataLeaf root = PageDataLeaf.create(this, rootPageId, PageData.ROOT);\n-            store.update(root);\n-        } else {\n-        \t//\u7b2c\u4e00\u6b21\u4eceorg.h2.store.PageStore.openMetaIndex()\u90a3\u8f6c\u8fc7\u6765\u65f6\uff0cid\u662f-1\uff0c\u6b64\u65f6\u53d6\u51fa\u6765\u7684rootPageId\u662f4\n-        \t//\u662f\u5728org.h2.store.PageStore.open()\u90a3\u4e8b\u5148\u653e\u5165\u7684\uff0cpageId=4\u7684\u9875\u56fa\u5b9a\u662fmetaIndex\u7684rootPageId\n-            rootPageId = store.getRootPageId(id);\n-            PageData root = getPage(rootPageId, 0);\n-            lastKey = root.getLastKey();\n-            rowCount = root.getRowCount();\n+        if (v != v2) {\n+          row.setValue(i, v2);\n         }\n-        if (trace.isDebugEnabled()) {\n-            trace.debug(\"{0} opened rows: {1}\", this, rowCount);\n+      }\n+    }\n+    // when using auto-generated values, it's possible that multiple\n+    // tries are required (specially if there was originally a primary key)\n+    if (trace.isDebugEnabled()) {\n+      trace.debug(\"{0} add {1}\", getName(), row);\n+    }\n+    long add = 0;\n+    while (true) {\n+      try {\n+        addTry(session, row);\n+        break;\n+      } catch (DbException e) {\n+        if (e != fastDuplicateKeyException) {\n+          throw e;\n         }\n-        table.setRowCount(rowCount);\n-        memoryPerPage = (Constants.MEMORY_PAGE_DATA + store.getPageSize()) >> 2;\n-    }\n-\n-    @Override\n-    public DbException getDuplicateKeyException(String key) {\n-        if (fastDuplicateKeyException == null) {\n-            fastDuplicateKeyException = super.getDuplicateKeyException(null);\n+        if (!retry) {\n+          e = DbException.get(ErrorCode.DUPLICATE_KEY_1,\n+              getDuplicatePrimaryKeyMessage(mainIndexColumn).toString());\n+          e.setSource(this);\n+          throw e;\n         }\n-        return fastDuplicateKeyException;\n-    }\n-\n-    @Override\n-    public void add(Session session, Row row) {\n-        boolean retry = false;\n-        if (mainIndexColumn != -1) {\n-            row.setKey(row.getValue(mainIndexColumn).getLong());\n+        if (add == 0) {\n+          // in the first re-try add a small random number,\n+          // to avoid collisions after a re-start\n+          row.setKey((long) (row.getKey() + Math.random() * 10_000));\n         } else {\n-            if (row.getKey() == 0) {\n-                row.setKey((int) ++lastKey);\n-                retry = true;\n-            }\n-        }\n-        if (tableData.getContainsLargeObject()) {\n-            for (int i = 0, len = row.getColumnCount(); i < len; i++) {\n-                Value v = row.getValue(i);\n-                Value v2 = v.copy(database, getId());\n-                if (v2.isLinkedToTable()) {\n-                    session.removeAtCommitStop(v2);\n-                }\n-                if (v != v2) {\n-                    row.setValue(i, v2);\n-                }\n-            }\n-        }\n-        // when using auto-generated values, it's possible that multiple\n-        // tries are required (specially if there was originally a primary key)\n-        if (trace.isDebugEnabled()) {\n-            trace.debug(\"{0} add {1}\", getName(), row);\n-        }\n-        long add = 0;\n-        while (true) {\n-            try {\n-                addTry(session, row);\n-                break;\n-            } catch (DbException e) {\n-                if (e != fastDuplicateKeyException) {\n-                    throw e;\n-                }\n-                if (!retry) {\n-                    e = DbException.get(ErrorCode.DUPLICATE_KEY_1,\n-                            getDuplicatePrimaryKeyMessage(mainIndexColumn).toString());\n-                    e.setSource(this);\n-                    throw e;\n-                }\n-                if (add == 0) {\n-                    // in the first re-try add a small random number,\n-                    // to avoid collisions after a re-start\n-                    row.setKey((long) (row.getKey() + Math.random() * 10_000));\n-                } else {\n-                    row.setKey(row.getKey() + add);\n-                }\n-                add++;\n-            } finally {\n-                store.incrementChangeCount();\n-            }\n-        }\n-        lastKey = Math.max(lastKey, row.getKey());\n-    }\n-\n-    private void addTry(Session session, Row row) {\n-        while (true) {\n-            PageData root = getPage(rootPageId, 0);\n-            int splitPoint = root.addRowTry(row);\n-            if (splitPoint == -1) {\n-                break;\n-            }\n-            if (trace.isDebugEnabled()) {\n-                trace.debug(\"{0} split\", this);\n-            }\n-            long pivot = splitPoint == 0 ? row.getKey() : root.getKey(splitPoint - 1);\n-            PageData page1 = root;\n-            PageData page2 = root.split(splitPoint);\n-            int id = store.allocatePage();\n-            page1.setPageId(id);\n-            page1.setParentPageId(rootPageId);\n-            page2.setParentPageId(rootPageId);\n-            PageDataNode newRoot = PageDataNode.create(this, rootPageId, PageData.ROOT);\n-            newRoot.init(page1, pivot, page2);\n-            store.update(page1);\n-            store.update(page2);\n-            store.update(newRoot);\n-            root = newRoot;\n-        }\n-        row.setDeleted(false);\n-        invalidateRowCount();\n-        rowCount++;\n-        store.logAddOrRemoveRow(session, tableData.getId(), row, true);\n-    }\n-\n-    /**\n-     * Read an overflow page.\n-     *\n-     * @param id the page id\n-     * @return the page\n-     */\n-    PageDataOverflow getPageOverflow(int id) {\n-        Page p = store.getPage(id);\n-        if (p instanceof PageDataOverflow) {\n-            return (PageDataOverflow) p;\n-        }\n-        throw DbException.get(ErrorCode.FILE_CORRUPTED_1,\n-                p == null ? \"null\" : p.toString());\n-    }\n-\n-    /**\n-     * Read the given page.\n-     *\n-     * @param id the page id\n-     * @param parent the parent, or -1 if unknown\n-     * @return the page\n-     */\n-    PageData getPage(int id, int parent) {\n-        Page pd = store.getPage(id);\n-        if (pd == null) {\n-            PageDataLeaf empty = PageDataLeaf.create(this, id, parent);\n-            // could have been created before, but never committed\n-            //\u4eceorg.h2.store.PageStore.openNew()\u8f6c\u5230\u8fd9\u65f6\uff0c\u56e0\u4e3arecoveryRunning\u662ftrue\uff0c\u6240\u4ee5logUndo\u4ec0\u4e48\u90fd\u6ca1\u505a\n-            //\u5728store.update\u4e2d\u624d\u771f\u6b63\u5206\u914did\n-            store.logUndo(empty, null);\n-            store.update(empty);\n-            return empty;\n-        } else if (!(pd instanceof PageData)) {\n-            throw DbException.get(ErrorCode.FILE_CORRUPTED_1, String.valueOf(pd));\n-        }\n-        PageData p = (PageData) pd;\n-        if (parent != -1) {\n-            if (p.getParentPageId() != parent) {\n-                throw DbException.throwInternalError(p +\n-                        \" parent \" + p.getParentPageId() + \" expected \" + parent);\n-            }\n-        }\n-        return p;\n-    }\n-\n-    @Override\n-    public boolean canGetFirstOrLast() {\n-        return false;\n-    }\n-\n-    /**\n-     * Get the key from the row.\n-     *\n-     * @param row the row\n-     * @param ifEmpty the value to use if the row is empty\n-     * @param ifNull the value to use if the column is NULL\n-     * @return the key\n-     */\n-    long getKey(SearchRow row, long ifEmpty, long ifNull) {\n-        if (row == null) {\n-            return ifEmpty;\n-        }\n-        Value v = row.getValue(mainIndexColumn);\n-        if (v == null) {\n-            return row.getKey();\n-        } else if (v == ValueNull.INSTANCE) {\n-            return ifNull;\n-        }\n-        return v.getLong();\n-    }\n-\n-    @Override\n-    public Cursor find(Session session, SearchRow first, SearchRow last) {\n-        long from = first == null ? Long.MIN_VALUE : first.getKey();\n-        long to = last == null ? Long.MAX_VALUE : last.getKey();\n-        PageData root = getPage(rootPageId, 0);\n-        return root.find(session, from, to);\n-\n-    }\n-\n-    /**\n-     * Search for a specific row or a set of rows.\n-     *\n-     * @param session the session\n-     * @param first the key of the first row\n-     * @param last the key of the last row\n-     * @return the cursor\n-     */\n-    Cursor find(Session session, long first, long last) {\n-        PageData root = getPage(rootPageId, 0);\n-        return root.find(session, first, last);\n-    }\n-\n-    @Override\n-    public Cursor findFirstOrLast(Session session, boolean first) {\n-        throw DbException.throwInternalError(toString());\n-    }\n-\n-    long getLastKey() {\n-        PageData root = getPage(rootPageId, 0);\n-        return root.getLastKey();\n-    }\n-\n-    @Override\n-    public double getCost(Session session, int[] masks,\n-            TableFilter[] filters, int filter, SortOrder sortOrder,\n-            AllColumnsForPlan allColumnsSet) {\n-        // The +200 is so that indexes that can return the same data, but have less\n-        // columns, will take precedence. This all works out easier in the MVStore case,\n-        // because MVStore uses the same cost calculation code for the ScanIndex (i.e.\n-        // the MVPrimaryIndex) and all other indices.\n-        return 10 * (tableData.getRowCountApproximation() +\n-                Constants.COST_ROW_OFFSET) + 200;\n-    }\n-\n-    @Override\n-    public boolean needRebuild() {\n-        return false;\n-    }\n-\n-    @Override\n-    public void remove(Session session, Row row) {\n-        if (tableData.getContainsLargeObject()) {\n-            for (int i = 0, len = row.getColumnCount(); i < len; i++) {\n-                Value v = row.getValue(i);\n-                if (v.isLinkedToTable()) {\n-                    session.removeAtCommit(v);\n-                }\n-            }\n-        }\n-        if (trace.isDebugEnabled()) {\n-            trace.debug(\"{0} remove {1}\", getName(), row);\n-        }\n-        if (rowCount == 1) {\n-            removeAllRows();\n-        } else {\n-            try {\n-                long key = row.getKey();\n-                PageData root = getPage(rootPageId, 0);\n-                root.remove(key);\n-                invalidateRowCount();\n-                rowCount--;\n-            } finally {\n-                store.incrementChangeCount();\n-            }\n-        }\n-        store.logAddOrRemoveRow(session, tableData.getId(), row, false);\n-    }\n-\n-    @Override\n-    public void remove(Session session) {\n-        if (trace.isDebugEnabled()) {\n-            trace.debug(\"{0} remove\", this);\n-        }\n-        removeAllRows();\n-        store.free(rootPageId);\n-        store.removeMeta(this, session);\n-    }\n-\n-    @Override\n-    public void truncate(Session session) {\n-        if (trace.isDebugEnabled()) {\n-            trace.debug(\"{0} truncate\", this);\n-        }\n-        store.logTruncate(session, tableData.getId());\n-        removeAllRows();\n-        if (tableData.getContainsLargeObject() && tableData.isPersistData()) {\n-            // unfortunately, the data is gone on rollback\n-            session.commit(false);\n-            database.getLobStorage().removeAllForTable(table.getId());\n+          row.setKey(row.getKey() + add);\n         }\n-        tableData.setRowCount(0);\n-    }\n-\n-    private void removeAllRows() {\n-        try {\n-            PageData root = getPage(rootPageId, 0);\n-            root.freeRecursive();\n-            root = PageDataLeaf.create(this, rootPageId, PageData.ROOT);\n-            store.removeFromCache(rootPageId);\n-            store.update(root);\n-            rowCount = 0;\n-            lastKey = 0;\n-        } finally {\n-            store.incrementChangeCount();\n+        add++;\n+      } finally {\n+        store.incrementChangeCount();\n+      }\n+    }\n+    lastKey = Math.max(lastKey, row.getKey());\n+  }\n+\n+  private void addTry(Session session, Row row) {\n+    while (true) {\n+      PageData root = getPage(rootPageId, 0);\n+      int splitPoint = root.addRowTry(row);\n+      if (splitPoint == -1) {\n+        break;\n+      }\n+      if (trace.isDebugEnabled()) {\n+        trace.debug(\"{0} split\", this);\n+      }\n+      long pivot = splitPoint == 0 ? row.getKey() : root.getKey(splitPoint - 1);\n+      PageData page1 = root;\n+      PageData page2 = root.split(splitPoint);\n+      int id = store.allocatePage();\n+      page1.setPageId(id);\n+      page1.setParentPageId(rootPageId);\n+      page2.setParentPageId(rootPageId);\n+      PageDataNode newRoot = PageDataNode.create(this, rootPageId, PageData.ROOT);\n+      newRoot.init(page1, pivot, page2);\n+      store.update(page1);\n+      store.update(page2);\n+      store.update(newRoot);\n+      root = newRoot;\n+    }\n+    row.setDeleted(false);\n+    invalidateRowCount();\n+    rowCount++;\n+    store.logAddOrRemoveRow(session, tableData.getId(), row, true);\n+  }\n+\n+  /**\n+   * Read an overflow page.\n+   *\n+   * @param id the page id\n+   * @return the page\n+   */\n+  PageDataOverflow getPageOverflow(int id) {\n+    Page p = store.getPage(id);\n+    if (p instanceof PageDataOverflow) {\n+      return (PageDataOverflow) p;\n+    }\n+    throw DbException.get(ErrorCode.FILE_CORRUPTED_1,\n+        p == null ? \"null\" : p.toString());\n+  }\n+\n+  /**\n+   * Read the given page.\n+   *\n+   * @param id     the page id\n+   * @param parent the parent, or -1 if unknown\n+   * @return the page\n+   */\n+  PageData getPage(int id, int parent) {\n+    Page pd = store.getPage(id);\n+    if (pd == null) {\n+      PageDataLeaf empty = PageDataLeaf.create(this, id, parent);\n+      // could have been created before, but never committed\n+      //\u4eceorg.h2.store.PageStore.openNew()\u8f6c\u5230\u8fd9\u65f6\uff0c\u56e0\u4e3arecoveryRunning\u662ftrue\uff0c\u6240\u4ee5logUndo\u4ec0\u4e48\u90fd\u6ca1\u505a\n+      //\u5728store.update\u4e2d\u624d\u771f\u6b63\u5206\u914did\n+      store.logUndo(empty, null);\n+      store.update(empty);\n+      return empty;\n+    } else if (!(pd instanceof PageData)) {\n+      throw DbException.get(ErrorCode.FILE_CORRUPTED_1, String.valueOf(pd));\n+    }\n+    PageData p = (PageData) pd;\n+    if (parent != -1) {\n+      if (p.getParentPageId() != parent) {\n+        throw DbException.throwInternalError(p +\n+            \" parent \" + p.getParentPageId() + \" expected \" + parent);\n+      }\n+    }\n+    return p;\n+  }\n+\n+  @Override\n+  public boolean canGetFirstOrLast() {\n+    return false;\n+  }\n+\n+  /**\n+   * Get the key from the row.\n+   *\n+   * @param row     the row\n+   * @param ifEmpty the value to use if the row is empty\n+   * @param ifNull  the value to use if the column is NULL\n+   * @return the key\n+   */\n+  long getKey(SearchRow row, long ifEmpty, long ifNull) {\n+    if (row == null) {\n+      return ifEmpty;\n+    }\n+    Value v = row.getValue(mainIndexColumn);\n+    if (v == null) {\n+      return row.getKey();\n+    } else if (v == ValueNull.INSTANCE) {\n+      return ifNull;\n+    }\n+    return v.getLong();\n+  }\n+\n+  @Override\n+  public Cursor find(Session session, SearchRow first, SearchRow last) {\n+    long from = first == null ? Long.MIN_VALUE : first.getKey();\n+    long to = last == null ? Long.MAX_VALUE : last.getKey();\n+    PageData root = getPage(rootPageId, 0);\n+    return root.find(session, from, to);\n+\n+  }\n+\n+  /**\n+   * Search for a specific row or a set of rows.\n+   *\n+   * @param session the session\n+   * @param first   the key of the first row\n+   * @param last    the key of the last row\n+   * @return the cursor\n+   */\n+  Cursor find(Session session, long first, long last) {\n+    PageData root = getPage(rootPageId, 0);\n+    return root.find(session, first, last);\n+  }\n+\n+  @Override\n+  public Cursor findFirstOrLast(Session session, boolean first) {\n+    throw DbException.throwInternalError(toString());\n+  }\n+\n+  long getLastKey() {\n+    PageData root = getPage(rootPageId, 0);\n+    return root.getLastKey();\n+  }\n+\n+  @Override\n+  public double getCost(Session session, int[] masks,\n+                        TableFilter[] filters, int filter, SortOrder sortOrder,\n+                        AllColumnsForPlan allColumnsSet) {\n+    // The +200 is so that indexes that can return the same data, but have less\n+    // columns, will take precedence. This all works out easier in the MVStore case,\n+    // because MVStore uses the same cost calculation code for the ScanIndex (i.e.\n+    // the MVPrimaryIndex) and all other indices.\n+    return 10 * (tableData.getRowCountApproximation() +\n+        Constants.COST_ROW_OFFSET) + 200;\n+  }\n+\n+  @Override\n+  public boolean needRebuild() {\n+    return false;\n+  }\n+\n+  @Override\n+  public void remove(Session session, Row row) {\n+    if (tableData.getContainsLargeObject()) {\n+      for (int i = 0, len = row.getColumnCount(); i < len; i++) {\n+        Value v = row.getValue(i);\n+        if (v.isLinkedToTable()) {\n+          session.removeAtCommit(v);\n         }\n+      }\n     }\n-\n-    @Override\n-    public void checkRename() {\n-        throw DbException.getUnsupportedException(\"PAGE\");\n-    }\n-\n-    @Override\n-    public Row getRow(Session session, long key) {\n-        return getRowWithKey(key);\n+    if (trace.isDebugEnabled()) {\n+      trace.debug(\"{0} remove {1}\", getName(), row);\n     }\n-\n-    /**\n-     * Get the row with the given key.\n-     *\n-     * @param key the key\n-     * @return the row\n-     */\n-    public Row getRowWithKey(long key) {\n+    if (rowCount == 1) {\n+      removeAllRows();\n+    } else {\n+      try {\n+        long key = row.getKey();\n         PageData root = getPage(rootPageId, 0);\n-        return root.getRowWithKey(key);\n-    }\n-\n-    PageStore getPageStore() {\n-        return store;\n-    }\n-\n-    @Override\n-    public long getRowCountApproximation() {\n-        return rowCount;\n-    }\n-\n-    @Override\n-    public long getRowCount(Session session) {\n-        return rowCount;\n-    }\n-\n-    @Override\n-    public long getDiskSpaceUsed() {\n-        PageData root = getPage(rootPageId, 0);\n-        return root.getDiskSpaceUsed();\n-    }\n-\n-    @Override\n-    public String getCreateSQL() {\n-        return null;\n-    }\n-\n-    @Override\n-    public int getColumnIndex(Column col) {\n-        // can not use this index - use the PageDelegateIndex instead\n-        return -1;\n-    }\n-\n-    @Override\n-    public boolean isFirstColumn(Column column) {\n-        return false;\n-    }\n-\n-    @Override\n-    public void close(Session session) {\n-        if (trace.isDebugEnabled()) {\n-            trace.debug(\"{0} close\", this);\n-        }\n-        // can not close the index because it might get used afterwards,\n-        // for example after running recovery\n-        writeRowCount();\n-    }\n-\n-    /**\n-     * The root page has changed.\n-     *\n-     * @param session the session\n-     * @param newPos the new position\n-     */\n-    void setRootPageId(Session session, int newPos) {\n-        store.removeMeta(this, session);\n-        this.rootPageId = newPos;\n-        store.addMeta(this, session);\n-        store.addIndex(this);\n-    }\n-\n-    public void setMainIndexColumn(int mainIndexColumn) {\n-        this.mainIndexColumn = mainIndexColumn;\n-    }\n-\n-    public int getMainIndexColumn() {\n-        return mainIndexColumn;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return getName();\n-    }\n-\n-    private void invalidateRowCount() {\n-        PageData root = getPage(rootPageId, 0);\n-        root.setRowCountStored(PageData.UNKNOWN_ROWCOUNT);\n-    }\n-\n-    @Override\n-    public void writeRowCount() {\n-        if (SysProperties.MODIFY_ON_WRITE && rootPageId == 0) {\n-            // currently creating the index\n-            return;\n-        }\n-        try {\n-            PageData root = getPage(rootPageId, 0);\n-            root.setRowCountStored(MathUtils.convertLongToInt(rowCount));\n-        } finally {\n-            store.incrementChangeCount();\n-        }\n-    }\n-\n-    @Override\n-    public String getPlanSQL() {\n-        return table.getSQL(new StringBuilder(), false).append(\".tableScan\").toString();\n-    }\n-\n-    int getMemoryPerPage() {\n-        return memoryPerPage;\n-    }\n-\n-    /**\n-     * The memory usage of a page was changed. The new value is used to adopt\n-     * the average estimated memory size of a page.\n-     *\n-     * @param x the new memory size\n-     */\n-    void memoryChange(int x) {\n-        if (memoryCount < Constants.MEMORY_FACTOR) {\n-            memoryPerPage += (x - memoryPerPage) / ++memoryCount;\n-        } else {\n-            memoryPerPage += (x > memoryPerPage ? 1 : -1) +\n-                    ((x - memoryPerPage) / Constants.MEMORY_FACTOR);\n-        }\n-    }\n-\n-    @Override\n-    public boolean isRowIdIndex() {\n-        return true;\n-    }\n+        root.remove(key);\n+        invalidateRowCount();\n+        rowCount--;\n+      } finally {\n+        store.incrementChangeCount();\n+      }\n+    }\n+    store.logAddOrRemoveRow(session, tableData.getId(), row, false);\n+  }\n+\n+  @Override\n+  public void remove(Session session) {\n+    if (trace.isDebugEnabled()) {\n+      trace.debug(\"{0} remove\", this);\n+    }\n+    removeAllRows();\n+    store.free(rootPageId);\n+    store.removeMeta(this, session);\n+  }\n+\n+  @Override\n+  public void truncate(Session session) {\n+    if (trace.isDebugEnabled()) {\n+      trace.debug(\"{0} truncate\", this);\n+    }\n+    store.logTruncate(session, tableData.getId());\n+    removeAllRows();\n+    if (tableData.getContainsLargeObject() && tableData.isPersistData()) {\n+      // unfortunately, the data is gone on rollback\n+      session.commit(false);\n+      database.getLobStorage().removeAllForTable(table.getId());\n+    }\n+    tableData.setRowCount(0);\n+  }\n+\n+  private void removeAllRows() {\n+    try {\n+      PageData root = getPage(rootPageId, 0);\n+      root.freeRecursive();\n+      root = PageDataLeaf.create(this, rootPageId, PageData.ROOT);\n+      store.removeFromCache(rootPageId);\n+      store.update(root);\n+      rowCount = 0;\n+      lastKey = 0;\n+    } finally {\n+      store.incrementChangeCount();\n+    }\n+  }\n+\n+  @Override\n+  public void checkRename() {\n+    throw DbException.getUnsupportedException(\"PAGE\");\n+  }\n+\n+  @Override\n+  public Row getRow(Session session, long key) {\n+    return getRowWithKey(key);\n+  }\n+\n+  /**\n+   * Get the row with the given key.\n+   *\n+   * @param key the key\n+   * @return the row\n+   */\n+  public Row getRowWithKey(long key) {\n+    PageData root = getPage(rootPageId, 0);\n+    return root.getRowWithKey(key);\n+  }\n+\n+  PageStore getPageStore() {\n+    return store;\n+  }\n+\n+  @Override\n+  public long getRowCountApproximation() {\n+    return rowCount;\n+  }\n+\n+  @Override\n+  public long getRowCount(Session session) {\n+    return rowCount;\n+  }\n+\n+  @Override\n+  public long getDiskSpaceUsed() {\n+    PageData root = getPage(rootPageId, 0);\n+    return root.getDiskSpaceUsed();\n+  }\n+\n+  @Override\n+  public String getCreateSQL() {\n+    return null;\n+  }\n+\n+  @Override\n+  public int getColumnIndex(Column col) {\n+    // can not use this index - use the PageDelegateIndex instead\n+    return -1;\n+  }\n+\n+  @Override\n+  public boolean isFirstColumn(Column column) {\n+    return false;\n+  }\n+\n+  @Override\n+  public void close(Session session) {\n+    if (trace.isDebugEnabled()) {\n+      trace.debug(\"{0} close\", this);\n+    }\n+    // can not close the index because it might get used afterwards,\n+    // for example after running recovery\n+    writeRowCount();\n+  }\n+\n+  /**\n+   * The root page has changed.\n+   *\n+   * @param session the session\n+   * @param newPos  the new position\n+   */\n+  void setRootPageId(Session session, int newPos) {\n+    store.removeMeta(this, session);\n+    this.rootPageId = newPos;\n+    store.addMeta(this, session);\n+    store.addIndex(this);\n+  }\n+\n+  public void setMainIndexColumn(int mainIndexColumn) {\n+    this.mainIndexColumn = mainIndexColumn;\n+  }\n+\n+  public int getMainIndexColumn() {\n+    return mainIndexColumn;\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return getName();\n+  }\n+\n+  private void invalidateRowCount() {\n+    PageData root = getPage(rootPageId, 0);\n+    root.setRowCountStored(PageData.UNKNOWN_ROWCOUNT);\n+  }\n+\n+  @Override\n+  public void writeRowCount() {\n+    if (SysProperties.MODIFY_ON_WRITE && rootPageId == 0) {\n+      // currently creating the index\n+      return;\n+    }\n+    try {\n+      PageData root = getPage(rootPageId, 0);\n+      root.setRowCountStored(MathUtils.convertLongToInt(rowCount));\n+    } finally {\n+      store.incrementChangeCount();\n+    }\n+  }\n+\n+  @Override\n+  public String getPlanSQL() {\n+    return table.getSQL(new StringBuilder(), false).append(\".tableScan\").toString();\n+  }\n+\n+  int getMemoryPerPage() {\n+    return memoryPerPage;\n+  }\n+\n+  /**\n+   * The memory usage of a page was changed. The new value is used to adopt\n+   * the average estimated memory size of a page.\n+   *\n+   * @param x the new memory size\n+   */\n+  void memoryChange(int x) {\n+    if (memoryCount < Constants.MEMORY_FACTOR) {\n+      memoryPerPage += (x - memoryPerPage) / ++memoryCount;\n+    } else {\n+      memoryPerPage += (x > memoryPerPage ? 1 : -1) +\n+          ((x - memoryPerPage) / Constants.MEMORY_FACTOR);\n+    }\n+  }\n+\n+  @Override\n+  public boolean isRowIdIndex() {\n+    return true;\n+  }\n \n }\n",
            "diff_size": 740
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/479/PageDataIndex.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/codebuff/479/PageDataIndex.java\nindex 005fce07b2e..f78e85dfd24 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/479/PageDataIndex.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/codebuff/479/PageDataIndex.java\n@@ -30,6 +30,8 @@ import org.h2.value.ValueNull;\n  * all rows of a table. Each regular table has one such object, even if no\n  * primary key or indexes are defined.\n  */\n+\n+\n public class PageDataIndex extends PageIndex {\n \n     private final PageStore store;\n@@ -47,8 +49,8 @@ public class PageDataIndex extends PageIndex {\n     private int memoryCount;\n \n     //PageDataIndex\u7684id\u5c31\u662f\u8868\u7684id\uff0c\u5176\u4ed6\u7d22\u5f15\u5982PageBtreeIndex\u7684id\u662f\u81ea\u52a8\u5206\u914d\u7684\u5e76\u4e0d\u662f\u8868\u7684id\n-    public PageDataIndex(PageStoreTable table, int id, IndexColumn[] columns,\n-            IndexType indexType, boolean create, Session session) {\n+\n+    public PageDataIndex(PageStoreTable table, int id, IndexColumn[] columns, IndexType indexType, boolean create, Session session) {\n         super(table, id, table.getName() + \"_DATA\", columns, indexType);\n \n         // trace = database.getTrace(Trace.PAGE_STORE + \"_di\");\n@@ -65,8 +67,8 @@ public class PageDataIndex extends PageIndex {\n             PageDataLeaf root = PageDataLeaf.create(this, rootPageId, PageData.ROOT);\n             store.update(root);\n         } else {\n-        \t//\u7b2c\u4e00\u6b21\u4eceorg.h2.store.PageStore.openMetaIndex()\u90a3\u8f6c\u8fc7\u6765\u65f6\uff0cid\u662f-1\uff0c\u6b64\u65f6\u53d6\u51fa\u6765\u7684rootPageId\u662f4\n-        \t//\u662f\u5728org.h2.store.PageStore.open()\u90a3\u4e8b\u5148\u653e\u5165\u7684\uff0cpageId=4\u7684\u9875\u56fa\u5b9a\u662fmetaIndex\u7684rootPageId\n+            //\u7b2c\u4e00\u6b21\u4eceorg.h2.store.PageStore.openMetaIndex()\u90a3\u8f6c\u8fc7\u6765\u65f6\uff0cid\u662f-1\uff0c\u6b64\u65f6\u53d6\u51fa\u6765\u7684rootPageId\u662f4\n+            //\u662f\u5728org.h2.store.PageStore.open()\u90a3\u4e8b\u5148\u653e\u5165\u7684\uff0cpageId=4\u7684\u9875\u56fa\u5b9a\u662fmetaIndex\u7684rootPageId\n             rootPageId = store.getRootPageId(id);\n             PageData root = getPage(rootPageId, 0);\n             lastKey = root.getLastKey();\n@@ -125,8 +127,7 @@ public class PageDataIndex extends PageIndex {\n                     throw e;\n                 }\n                 if (!retry) {\n-                    e = DbException.get(ErrorCode.DUPLICATE_KEY_1,\n-                            getDuplicatePrimaryKeyMessage(mainIndexColumn).toString());\n+                    e = DbException.get(ErrorCode.DUPLICATE_KEY_1, getDuplicatePrimaryKeyMessage(mainIndexColumn).toString());\n                     e.setSource(this);\n                     throw e;\n                 }\n@@ -181,13 +182,14 @@ public class PageDataIndex extends PageIndex {\n      * @param id the page id\n      * @return the page\n      */\n+\n+\n     PageDataOverflow getPageOverflow(int id) {\n         Page p = store.getPage(id);\n         if (p instanceof PageDataOverflow) {\n             return (PageDataOverflow) p;\n         }\n-        throw DbException.get(ErrorCode.FILE_CORRUPTED_1,\n-                p == null ? \"null\" : p.toString());\n+        throw DbException.get(ErrorCode.FILE_CORRUPTED_1, p == null ? \"null\" : p.toString());\n     }\n \n     /**\n@@ -197,6 +199,8 @@ public class PageDataIndex extends PageIndex {\n      * @param parent the parent, or -1 if unknown\n      * @return the page\n      */\n+\n+\n     PageData getPage(int id, int parent) {\n         Page pd = store.getPage(id);\n         if (pd == null) {\n@@ -213,8 +217,8 @@ public class PageDataIndex extends PageIndex {\n         PageData p = (PageData) pd;\n         if (parent != -1) {\n             if (p.getParentPageId() != parent) {\n-                throw DbException.throwInternalError(p +\n-                        \" parent \" + p.getParentPageId() + \" expected \" + parent);\n+                throw DbException.throwInternalError(p + \" parent \"\n+                + p.getParentPageId() + \" expected \" + parent);\n             }\n         }\n         return p;\n@@ -233,6 +237,8 @@ public class PageDataIndex extends PageIndex {\n      * @param ifNull the value to use if the column is NULL\n      * @return the key\n      */\n+\n+\n     long getKey(SearchRow row, long ifEmpty, long ifNull) {\n         if (row == null) {\n             return ifEmpty;\n@@ -252,7 +258,6 @@ public class PageDataIndex extends PageIndex {\n         long to = last == null ? Long.MAX_VALUE : last.getKey();\n         PageData root = getPage(rootPageId, 0);\n         return root.find(session, from, to);\n-\n     }\n \n     /**\n@@ -263,6 +268,8 @@ public class PageDataIndex extends PageIndex {\n      * @param last the key of the last row\n      * @return the cursor\n      */\n+\n+\n     Cursor find(Session session, long first, long last) {\n         PageData root = getPage(rootPageId, 0);\n         return root.find(session, first, last);\n@@ -273,21 +280,19 @@ public class PageDataIndex extends PageIndex {\n         throw DbException.throwInternalError(toString());\n     }\n \n+\n     long getLastKey() {\n         PageData root = getPage(rootPageId, 0);\n         return root.getLastKey();\n     }\n \n     @Override\n-    public double getCost(Session session, int[] masks,\n-            TableFilter[] filters, int filter, SortOrder sortOrder,\n-            AllColumnsForPlan allColumnsSet) {\n+    public double getCost(Session session, int[] masks, TableFilter[] filters, int filter, SortOrder sortOrder, AllColumnsForPlan allColumnsSet) {\n         // The +200 is so that indexes that can return the same data, but have less\n         // columns, will take precedence. This all works out easier in the MVStore case,\n         // because MVStore uses the same cost calculation code for the ScanIndex (i.e.\n         // the MVPrimaryIndex) and all other indices.\n-        return 10 * (tableData.getRowCountApproximation() +\n-                Constants.COST_ROW_OFFSET) + 200;\n+        return 10 * (tableData.getRowCountApproximation() + Constants.COST_ROW_OFFSET) + 200;\n     }\n \n     @Override\n@@ -379,11 +384,14 @@ public class PageDataIndex extends PageIndex {\n      * @param key the key\n      * @return the row\n      */\n+\n+\n     public Row getRowWithKey(long key) {\n         PageData root = getPage(rootPageId, 0);\n         return root.getRowWithKey(key);\n     }\n \n+\n     PageStore getPageStore() {\n         return store;\n     }\n@@ -436,6 +444,8 @@ public class PageDataIndex extends PageIndex {\n      * @param session the session\n      * @param newPos the new position\n      */\n+\n+\n     void setRootPageId(Session session, int newPos) {\n         store.removeMeta(this, session);\n         this.rootPageId = newPos;\n@@ -443,10 +453,12 @@ public class PageDataIndex extends PageIndex {\n         store.addIndex(this);\n     }\n \n+\n     public void setMainIndexColumn(int mainIndexColumn) {\n         this.mainIndexColumn = mainIndexColumn;\n     }\n \n+\n     public int getMainIndexColumn() {\n         return mainIndexColumn;\n     }\n@@ -480,6 +492,7 @@ public class PageDataIndex extends PageIndex {\n         return table.getSQL(new StringBuilder(), false).append(\".tableScan\").toString();\n     }\n \n+\n     int getMemoryPerPage() {\n         return memoryPerPage;\n     }\n@@ -490,12 +503,13 @@ public class PageDataIndex extends PageIndex {\n      *\n      * @param x the new memory size\n      */\n+\n+\n     void memoryChange(int x) {\n         if (memoryCount < Constants.MEMORY_FACTOR) {\n             memoryPerPage += (x - memoryPerPage) / ++memoryCount;\n         } else {\n-            memoryPerPage += (x > memoryPerPage ? 1 : -1) +\n-                    ((x - memoryPerPage) / Constants.MEMORY_FACTOR);\n+            memoryPerPage += (x > memoryPerPage ? 1 : -1) + ((x - memoryPerPage) / Constants.MEMORY_FACTOR);\n         }\n     }\n \n@@ -504,4 +518,4 @@ public class PageDataIndex extends PageIndex {\n         return true;\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 40
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/479/PageDataIndex.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_random/479/PageDataIndex.java\nindex 005fce07b2e..cf6d914081d 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/479/PageDataIndex.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_random/479/PageDataIndex.java\n@@ -65,8 +65,8 @@ public class PageDataIndex extends PageIndex {\n             PageDataLeaf root = PageDataLeaf.create(this, rootPageId, PageData.ROOT);\n             store.update(root);\n         } else {\n-        \t//\u7b2c\u4e00\u6b21\u4eceorg.h2.store.PageStore.openMetaIndex()\u90a3\u8f6c\u8fc7\u6765\u65f6\uff0cid\u662f-1\uff0c\u6b64\u65f6\u53d6\u51fa\u6765\u7684rootPageId\u662f4\n-        \t//\u662f\u5728org.h2.store.PageStore.open()\u90a3\u4e8b\u5148\u653e\u5165\u7684\uff0cpageId=4\u7684\u9875\u56fa\u5b9a\u662fmetaIndex\u7684rootPageId\n+        //\u7b2c\u4e00\u6b21\u4eceorg.h2.store.PageStore.openMetaIndex()\u90a3\u8f6c\u8fc7\u6765\u65f6\uff0cid\u662f-1\uff0c\u6b64\u65f6\u53d6\u51fa\u6765\u7684rootPageId\u662f4\n+         //\u662f\u5728org.h2.store.PageStore.open()\u90a3\u4e8b\u5148\u653e\u5165\u7684\uff0cpageId=4\u7684\u9875\u56fa\u5b9a\u662fmetaIndex\u7684rootPageId\n             rootPageId = store.getRootPageId(id);\n             PageData root = getPage(rootPageId, 0);\n             lastKey = root.getLastKey();\n",
            "diff_size": 2
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/479/PageDataIndex.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/479/PageDataIndex.java\nindex 005fce07b2e..af01e399c36 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/479/PageDataIndex.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/479/PageDataIndex.java\n@@ -65,8 +65,8 @@ public class PageDataIndex extends PageIndex {\n             PageDataLeaf root = PageDataLeaf.create(this, rootPageId, PageData.ROOT);\n             store.update(root);\n         } else {\n-        \t//\u7b2c\u4e00\u6b21\u4eceorg.h2.store.PageStore.openMetaIndex()\u90a3\u8f6c\u8fc7\u6765\u65f6\uff0cid\u662f-1\uff0c\u6b64\u65f6\u53d6\u51fa\u6765\u7684rootPageId\u662f4\n-        \t//\u662f\u5728org.h2.store.PageStore.open()\u90a3\u4e8b\u5148\u653e\u5165\u7684\uff0cpageId=4\u7684\u9875\u56fa\u5b9a\u662fmetaIndex\u7684rootPageId\n+        //\u7b2c\u4e00\u6b21\u4eceorg.h2.store.PageStore.openMetaIndex()\u90a3\u8f6c\u8fc7\u6765\u65f6\uff0cid\u662f-1\uff0c\u6b64\u65f6\u53d6\u51fa\u6765\u7684rootPageId\u662f4\n+//\u662f\u5728org.h2.store.PageStore.open()\u90a3\u4e8b\u5148\u653e\u5165\u7684\uff0cpageId=4\u7684\u9875\u56fa\u5b9a\u662fmetaIndex\u7684rootPageId\n             rootPageId = store.getRootPageId(id);\n             PageData root = getPage(rootPageId, 0);\n             lastKey = root.getLastKey();\n",
            "diff_size": 2
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "naturalize"
    ]
}