{
    "project_name": "fangjinuo-easyjson",
    "error_id": "4",
    "information": {
        "errors": [
            {
                "line": "515",
                "column": "25",
                "severity": "warning",
                "message": "'.' is preceded with whitespace.",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.NoWhitespaceBeforeCheck"
            }
        ]
    },
    "source_code": "                constructor.setAccessible(true);\n                return constructor.newInstance(moshi, ((ParameterizedType) type).getActualTypeArguments())\n                        .nullSafe();\n            } else {\n                Constructor<? extends JsonAdapter<?>> constructor\n                        = adapterClass.getDeclaredConstructor(Moshi.class);",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/errored/1/4/Util.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/styler/4/Util.java\nindex 00737dd825f..1d636fb7b70 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/errored/1/4/Util.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/styler/4/Util.java\n@@ -511,8 +511,7 @@ public final class Util {\n                 Constructor<? extends JsonAdapter<?>> constructor\n                         = adapterClass.getDeclaredConstructor(Moshi.class, Type[].class);\n                 constructor.setAccessible(true);\n-                return constructor.newInstance(moshi, ((ParameterizedType) type).getActualTypeArguments())\n-                        .nullSafe();\n+                return constructor.newInstance(moshi, ((ParameterizedType) type).getActualTypeArguments()).nullSafe();\n             } else {\n                 Constructor<? extends JsonAdapter<?>> constructor\n                         = adapterClass.getDeclaredConstructor(Moshi.class);\n",
            "diff_size": 2
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "516",
                    "column": "21",
                    "severity": "warning",
                    "message": "'.' is preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.NoWhitespaceBeforeCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/errored/1/4/Util.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/intellij/4/Util.java\nindex 00737dd825f..30b66566278 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/errored/1/4/Util.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/intellij/4/Util.java\n@@ -13,6 +13,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+\n package com.squareup.moshi.internal;\n \n import com.squareup.moshi.*;\n@@ -26,7 +27,7 @@ import static com.squareup.moshi.Types.*;\n \n public final class Util {\n     public static final Set<Annotation> NO_ANNOTATIONS = Collections.emptySet();\n-    public static final Type[] EMPTY_TYPE_ARRAY = new Type[]{};\n+    public static final Type[] EMPTY_TYPE_ARRAY = new Type[] {};\n \n     private Util() {\n     }\n@@ -54,7 +55,7 @@ public final class Util {\n     }\n \n     public static boolean isAnnotationPresent(\n-            Set<? extends Annotation> annotations, Class<? extends Annotation> annotationClass) {\n+        Set<? extends Annotation> annotations, Class<? extends Annotation> annotationClass) {\n         if (annotations.isEmpty()) {\n             // Save an iterator in the common case.\n             return false;\n@@ -86,11 +87,11 @@ public final class Util {\n     public static boolean isPlatformType(Class<?> rawType) {\n         String name = rawType.getName();\n         return name.startsWith(\"android.\")\n-                || name.startsWith(\"androidx.\")\n-                || name.startsWith(\"java.\")\n-                || name.startsWith(\"javax.\")\n-                || name.startsWith(\"kotlin.\")\n-                || name.startsWith(\"scala.\");\n+            || name.startsWith(\"androidx.\")\n+            || name.startsWith(\"java.\")\n+            || name.startsWith(\"javax.\")\n+            || name.startsWith(\"kotlin.\")\n+            || name.startsWith(\"scala.\");\n     }\n \n     /**\n@@ -122,7 +123,7 @@ public final class Util {\n             }\n             ParameterizedType p = (ParameterizedType) type;\n             return new ParameterizedTypeImpl(p.getOwnerType(),\n-                    p.getRawType(), p.getActualTypeArguments());\n+                p.getRawType(), p.getActualTypeArguments());\n \n         } else if (type instanceof GenericArrayType) {\n             if (type instanceof GenericArrayTypeImpl) {\n@@ -158,16 +159,16 @@ public final class Util {\n                 Type componentType = original.getComponentType();\n                 Type newComponentType = resolve(context, contextRawType, componentType);\n                 return componentType == newComponentType\n-                        ? original\n-                        : arrayOf(newComponentType);\n+                    ? original\n+                    : arrayOf(newComponentType);\n \n             } else if (toResolve instanceof GenericArrayType) {\n                 GenericArrayType original = (GenericArrayType) toResolve;\n                 Type componentType = original.getGenericComponentType();\n                 Type newComponentType = resolve(context, contextRawType, componentType);\n                 return componentType == newComponentType\n-                        ? original\n-                        : arrayOf(newComponentType);\n+                    ? original\n+                    : arrayOf(newComponentType);\n \n             } else if (toResolve instanceof ParameterizedType) {\n                 ParameterizedType original = (ParameterizedType) toResolve;\n@@ -188,8 +189,8 @@ public final class Util {\n                 }\n \n                 return changed\n-                        ? new ParameterizedTypeImpl(newOwnerType, original.getRawType(), args)\n-                        : original;\n+                    ? new ParameterizedTypeImpl(newOwnerType, original.getRawType(), args)\n+                    : original;\n \n             } else if (toResolve instanceof WildcardType) {\n                 WildcardType original = (WildcardType) toResolve;\n@@ -317,11 +318,11 @@ public final class Util {\n                 if (ownerType != null) {\n                     if (enclosingClass == null || Types.getRawType(ownerType) != enclosingClass) {\n                         throw new IllegalArgumentException(\n-                                \"unexpected owner type for \" + rawType + \": \" + ownerType);\n+                            \"unexpected owner type for \" + rawType + \": \" + ownerType);\n                     }\n                 } else if (enclosingClass != null) {\n                     throw new IllegalArgumentException(\n-                            \"unexpected owner type for \" + rawType + \": null\");\n+                        \"unexpected owner type for \" + rawType + \": null\");\n                 }\n             }\n \n@@ -356,14 +357,14 @@ public final class Util {\n         @Override\n         public boolean equals(Object other) {\n             return other instanceof ParameterizedType\n-                    && Types.equals(this, (ParameterizedType) other);\n+                && Types.equals(this, (ParameterizedType) other);\n         }\n \n         @Override\n         public int hashCode() {\n             return Arrays.hashCode(typeArguments)\n-                    ^ rawType.hashCode()\n-                    ^ hashCodeOrZero(ownerType);\n+                ^ rawType.hashCode()\n+                ^ hashCodeOrZero(ownerType);\n         }\n \n         @Override\n@@ -398,7 +399,7 @@ public final class Util {\n         @Override\n         public boolean equals(Object o) {\n             return o instanceof GenericArrayType\n-                    && Types.equals(this, (GenericArrayType) o);\n+                && Types.equals(this, (GenericArrayType) o);\n         }\n \n         @Override\n@@ -453,25 +454,25 @@ public final class Util {\n \n         @Override\n         public Type[] getUpperBounds() {\n-            return new Type[]{upperBound};\n+            return new Type[] {upperBound};\n         }\n \n         @Override\n         public Type[] getLowerBounds() {\n-            return lowerBound != null ? new Type[]{lowerBound} : EMPTY_TYPE_ARRAY;\n+            return lowerBound != null ? new Type[] {lowerBound} : EMPTY_TYPE_ARRAY;\n         }\n \n         @Override\n         public boolean equals(Object other) {\n             return other instanceof WildcardType\n-                    && Types.equals(this, (WildcardType) other);\n+                && Types.equals(this, (WildcardType) other);\n         }\n \n         @Override\n         public int hashCode() {\n             // This equals Arrays.hashCode(getLowerBounds()) ^ Arrays.hashCode(getUpperBounds()).\n             return (lowerBound != null ? 31 + lowerBound.hashCode() : 1)\n-                    ^ (31 + upperBound.hashCode());\n+                ^ (31 + upperBound.hashCode());\n         }\n \n         @Override\n@@ -505,32 +506,32 @@ public final class Util {\n         String adapterClassName = rawType.getName().replace(\"$\", \"_\") + \"JsonAdapter\";\n         try {\n             @SuppressWarnings(\"unchecked\") // We generate types to match.\n-                    Class<? extends JsonAdapter<?>> adapterClass = (Class<? extends JsonAdapter<?>>)\n-                    Class.forName(adapterClassName, true, rawType.getClassLoader());\n+            Class<? extends JsonAdapter<?>> adapterClass = (Class<? extends JsonAdapter<?>>)\n+                Class.forName(adapterClassName, true, rawType.getClassLoader());\n             if (type instanceof ParameterizedType) {\n                 Constructor<? extends JsonAdapter<?>> constructor\n-                        = adapterClass.getDeclaredConstructor(Moshi.class, Type[].class);\n+                    = adapterClass.getDeclaredConstructor(Moshi.class, Type[].class);\n                 constructor.setAccessible(true);\n                 return constructor.newInstance(moshi, ((ParameterizedType) type).getActualTypeArguments())\n-                        .nullSafe();\n+                    .nullSafe();\n             } else {\n                 Constructor<? extends JsonAdapter<?>> constructor\n-                        = adapterClass.getDeclaredConstructor(Moshi.class);\n+                    = adapterClass.getDeclaredConstructor(Moshi.class);\n                 constructor.setAccessible(true);\n                 return constructor.newInstance(moshi).nullSafe();\n             }\n         } catch (ClassNotFoundException e) {\n             throw new RuntimeException(\n-                    \"Failed to find the generated JsonAdapter class for \" + rawType, e);\n+                \"Failed to find the generated JsonAdapter class for \" + rawType, e);\n         } catch (NoSuchMethodException e) {\n             throw new RuntimeException(\n-                    \"Failed to find the generated JsonAdapter constructor for \" + rawType, e);\n+                \"Failed to find the generated JsonAdapter constructor for \" + rawType, e);\n         } catch (IllegalAccessException e) {\n             throw new RuntimeException(\n-                    \"Failed to access the generated JsonAdapter for \" + rawType, e);\n+                \"Failed to access the generated JsonAdapter for \" + rawType, e);\n         } catch (InstantiationException e) {\n             throw new RuntimeException(\n-                    \"Failed to instantiate the generated JsonAdapter for \" + rawType, e);\n+                \"Failed to instantiate the generated JsonAdapter for \" + rawType, e);\n         } catch (InvocationTargetException e) {\n             throw rethrowCause(e);\n         }\n",
            "diff_size": 34
        },
        {
            "tool": "naturalize",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/errored/1/4/Util.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/naturalize/4/Util.java\nindex 00737dd825f..0e22823e7b1 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/errored/1/4/Util.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/naturalize/4/Util.java\n@@ -13,6 +13,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+\n package com.squareup.moshi.internal;\n \n import com.squareup.moshi.*;\n@@ -55,7 +56,7 @@ public final class Util {\n \n     public static boolean isAnnotationPresent(\n             Set<? extends Annotation> annotations, Class<? extends Annotation> annotationClass) {\n-        if (annotations.isEmpty()) {\n+    if (annotations.isEmpty()) {\n             // Save an iterator in the common case.\n             return false;\n         }\n@@ -86,11 +87,7 @@ public final class Util {\n     public static boolean isPlatformType(Class<?> rawType) {\n         String name = rawType.getName();\n         return name.startsWith(\"android.\")\n-                || name.startsWith(\"androidx.\")\n-                || name.startsWith(\"java.\")\n-                || name.startsWith(\"javax.\")\n-                || name.startsWith(\"kotlin.\")\n-                || name.startsWith(\"scala.\");\n+                || name.startsWith(\"androidx.\") || name.startsWith(\"java.\") || name.startsWith(\"javax.\") || name.startsWith(\"kotlin.\") || name.startsWith(\"scala.\");\n     }\n \n     /**\n@@ -123,8 +120,7 @@ public final class Util {\n             ParameterizedType p = (ParameterizedType) type;\n             return new ParameterizedTypeImpl(p.getOwnerType(),\n                     p.getRawType(), p.getActualTypeArguments());\n-\n-        } else if (type instanceof GenericArrayType) {\n+    } else if (type instanceof GenericArrayType) {\n             if (type instanceof GenericArrayTypeImpl) {\n                 return type;\n             }\n@@ -160,16 +156,14 @@ public final class Util {\n                 return componentType == newComponentType\n                         ? original\n                         : arrayOf(newComponentType);\n-\n-            } else if (toResolve instanceof GenericArrayType) {\n+    } else if (toResolve instanceof GenericArrayType) {\n                 GenericArrayType original = (GenericArrayType) toResolve;\n                 Type componentType = original.getGenericComponentType();\n                 Type newComponentType = resolve(context, contextRawType, componentType);\n                 return componentType == newComponentType\n                         ? original\n                         : arrayOf(newComponentType);\n-\n-            } else if (toResolve instanceof ParameterizedType) {\n+    } else if (toResolve instanceof ParameterizedType) {\n                 ParameterizedType original = (ParameterizedType) toResolve;\n                 Type ownerType = original.getOwnerType();\n                 Type newOwnerType = resolve(context, contextRawType, ownerType);\n@@ -187,11 +181,9 @@ public final class Util {\n                     }\n                 }\n \n-                return changed\n-                        ? new ParameterizedTypeImpl(newOwnerType, original.getRawType(), args)\n+                return changed ? new ParameterizedTypeImpl(newOwnerType, original.getRawType(), args)\n                         : original;\n-\n-            } else if (toResolve instanceof WildcardType) {\n+    } else if (toResolve instanceof WildcardType) {\n                 WildcardType original = (WildcardType) toResolve;\n                 Type[] originalLowerBound = original.getLowerBounds();\n                 Type[] originalUpperBound = original.getUpperBounds();\n@@ -486,9 +478,8 @@ public final class Util {\n         }\n     }\n \n-    public static String typeAnnotatedWithAnnotations(Type type,\n-                                                      Set<? extends Annotation> annotations) {\n-        return type + (annotations.isEmpty() ? \" (with no annotations)\" : \" annotated \" + annotations);\n+    public static String typeAnnotatedWithAnnotations(Type type, Set<? extends Annotation> annotations) {\n+    return type + (annotations.isEmpty() ? \" (with no annotations)\" : \" annotated \" + annotations);\n     }\n \n     /**\n@@ -496,9 +487,8 @@ public final class Util {\n      * uses the same naming conventions as {@code JsonClassCodeGenProcessor}.\n      */\n     public static @Nullable\n-    JsonAdapter<?> generatedAdapter(Moshi moshi, Type type,\n-                                    Class<?> rawType) {\n-        JsonClass jsonClass = rawType.getAnnotation(JsonClass.class);\n+    JsonAdapter<?> generatedAdapter(Moshi moshi, Type type, Class<?> rawType) {\n+    JsonClass jsonClass = rawType.getAnnotation(JsonClass.class);\n         if (jsonClass == null || !jsonClass.generateAdapter()) {\n             return null;\n         }\n@@ -507,32 +497,29 @@ public final class Util {\n             @SuppressWarnings(\"unchecked\") // We generate types to match.\n                     Class<? extends JsonAdapter<?>> adapterClass = (Class<? extends JsonAdapter<?>>)\n                     Class.forName(adapterClassName, true, rawType.getClassLoader());\n-            if (type instanceof ParameterizedType) {\n-                Constructor<? extends JsonAdapter<?>> constructor\n-                        = adapterClass.getDeclaredConstructor(Moshi.class, Type[].class);\n+if (type instanceof ParameterizedType) {\n+                Constructor<? extends JsonAdapter<?>> constructor = adapterClass.getDeclaredConstructor(Moshi.class, Type[].class);\n                 constructor.setAccessible(true);\n-                return constructor.newInstance(moshi, ((ParameterizedType) type).getActualTypeArguments())\n-                        .nullSafe();\n-            } else {\n-                Constructor<? extends JsonAdapter<?>> constructor\n-                        = adapterClass.getDeclaredConstructor(Moshi.class);\n+                return constructor.newInstance(moshi, ((ParameterizedType) type).getActualTypeArguments()).nullSafe();\n+    } else {\n+                Constructor<? extends JsonAdapter<?>> constructor = adapterClass.getDeclaredConstructor(Moshi.class);\n                 constructor.setAccessible(true);\n                 return constructor.newInstance(moshi).nullSafe();\n             }\n         } catch (ClassNotFoundException e) {\n             throw new RuntimeException(\n                     \"Failed to find the generated JsonAdapter class for \" + rawType, e);\n-        } catch (NoSuchMethodException e) {\n+    } catch (NoSuchMethodException e) {\n             throw new RuntimeException(\n                     \"Failed to find the generated JsonAdapter constructor for \" + rawType, e);\n-        } catch (IllegalAccessException e) {\n+    } catch (IllegalAccessException e) {\n             throw new RuntimeException(\n                     \"Failed to access the generated JsonAdapter for \" + rawType, e);\n-        } catch (InstantiationException e) {\n+    } catch (InstantiationException e) {\n             throw new RuntimeException(\n                     \"Failed to instantiate the generated JsonAdapter for \" + rawType, e);\n-        } catch (InvocationTargetException e) {\n+    } catch (InvocationTargetException e) {\n             throw rethrowCause(e);\n         }\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 36
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/errored/1/4/Util.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/codebuff/4/Util.java\nindex 00737dd825f..378a517c390 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/errored/1/4/Util.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/codebuff/4/Util.java\n@@ -16,18 +16,17 @@\n package com.squareup.moshi.internal;\n \n import com.squareup.moshi.*;\n-\n import javax.annotation.Nullable;\n import java.lang.annotation.Annotation;\n import java.lang.reflect.*;\n import java.util.*;\n-\n import static com.squareup.moshi.Types.*;\n \n public final class Util {\n     public static final Set<Annotation> NO_ANNOTATIONS = Collections.emptySet();\n-    public static final Type[] EMPTY_TYPE_ARRAY = new Type[]{};\n \n+\n+    public static final Type[] EMPTY_TYPE_ARRAY = new Type[]{};\n     private Util() {\n     }\n \n@@ -53,8 +52,7 @@ public final class Util {\n         return result != null ? Collections.unmodifiableSet(result) : Util.NO_ANNOTATIONS;\n     }\n \n-    public static boolean isAnnotationPresent(\n-            Set<? extends Annotation> annotations, Class<? extends Annotation> annotationClass) {\n+    public static boolean isAnnotationPresent(Set<? extends Annotation> annotations, Class<? extends Annotation> annotationClass) {\n         if (annotations.isEmpty()) {\n             // Save an iterator in the common case.\n             return false;\n@@ -70,6 +68,7 @@ public final class Util {\n     /**\n      * Returns true if {@code annotations} has any annotation whose simple name is Nullable.\n      */\n+\n     public static boolean hasNullable(Annotation[] annotations) {\n         for (Annotation annotation : annotations) {\n             if (annotation.annotationType().getSimpleName().equals(\"Nullable\")) {\n@@ -83,19 +82,16 @@ public final class Util {\n      * Returns true if {@code rawType} is built in. We don't reflect on private fields of platform\n      * types because they're unspecified and likely to be different on Java vs. Android.\n      */\n+\n     public static boolean isPlatformType(Class<?> rawType) {\n         String name = rawType.getName();\n-        return name.startsWith(\"android.\")\n-                || name.startsWith(\"androidx.\")\n-                || name.startsWith(\"java.\")\n-                || name.startsWith(\"javax.\")\n-                || name.startsWith(\"kotlin.\")\n-                || name.startsWith(\"scala.\");\n+        return name.startsWith(\"android.\") || name.startsWith(\"androidx.\") || name.startsWith(\"java.\") || name.startsWith(\"javax.\") || name.startsWith(\"kotlin.\") || name.startsWith(\"scala.\");\n     }\n \n     /**\n      * Throws the cause of {@code e}, wrapping it if it is checked.\n      */\n+\n     public static RuntimeException rethrowCause(InvocationTargetException e) {\n         Throwable cause = e.getTargetException();\n         if (cause instanceof RuntimeException) {\n@@ -111,36 +107,32 @@ public final class Util {\n      * Returns a type that is functionally equal but not necessarily equal according to {@link\n      * Object#equals(Object) Object.equals()}.\n      */\n+\n     public static Type canonicalize(Type type) {\n         if (type instanceof Class) {\n             Class<?> c = (Class<?>) type;\n             return c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c;\n-\n         } else if (type instanceof ParameterizedType) {\n             if (type instanceof ParameterizedTypeImpl) {\n                 return type;\n             }\n             ParameterizedType p = (ParameterizedType) type;\n-            return new ParameterizedTypeImpl(p.getOwnerType(),\n-                    p.getRawType(), p.getActualTypeArguments());\n-\n+            return new ParameterizedTypeImpl(p.getOwnerType(), p.getRawType(), p.getActualTypeArguments());\n         } else if (type instanceof GenericArrayType) {\n-            if (type instanceof GenericArrayTypeImpl) {\n-                return type;\n-            }\n-            GenericArrayType g = (GenericArrayType) type;\n-            return new GenericArrayTypeImpl(g.getGenericComponentType());\n-\n-        } else if (type instanceof WildcardType) {\n-            if (type instanceof WildcardTypeImpl) {\n-                return type;\n-            }\n-            WildcardType w = (WildcardType) type;\n-            return new WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds());\n-\n-        } else {\n-            return type; // This type is unsupported!\n-        }\n+                   if (type instanceof GenericArrayTypeImpl) {\n+                       return type;\n+                   }\n+                   GenericArrayType g = (GenericArrayType) type;\n+                   return new GenericArrayTypeImpl(g.getGenericComponentType());\n+               } else if (type instanceof WildcardType) {\n+                   if (type instanceof WildcardTypeImpl) {\n+                       return type;\n+                   }\n+                   WildcardType w = (WildcardType) type;\n+                   return new WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds());\n+               } else {\n+                   return type; // This type is unsupported!\n+               }\n     }\n \n     public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {\n@@ -152,66 +144,52 @@ public final class Util {\n                 if (toResolve == typeVariable) {\n                     return toResolve;\n                 }\n-\n             } else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {\n                 Class<?> original = (Class<?>) toResolve;\n                 Type componentType = original.getComponentType();\n                 Type newComponentType = resolve(context, contextRawType, componentType);\n-                return componentType == newComponentType\n-                        ? original\n-                        : arrayOf(newComponentType);\n-\n+                return componentType == newComponentType ? original : arrayOf(newComponentType);\n             } else if (toResolve instanceof GenericArrayType) {\n-                GenericArrayType original = (GenericArrayType) toResolve;\n-                Type componentType = original.getGenericComponentType();\n-                Type newComponentType = resolve(context, contextRawType, componentType);\n-                return componentType == newComponentType\n-                        ? original\n-                        : arrayOf(newComponentType);\n-\n-            } else if (toResolve instanceof ParameterizedType) {\n-                ParameterizedType original = (ParameterizedType) toResolve;\n-                Type ownerType = original.getOwnerType();\n-                Type newOwnerType = resolve(context, contextRawType, ownerType);\n-                boolean changed = newOwnerType != ownerType;\n-\n-                Type[] args = original.getActualTypeArguments();\n-                for (int t = 0, length = args.length; t < length; t++) {\n-                    Type resolvedTypeArgument = resolve(context, contextRawType, args[t]);\n-                    if (resolvedTypeArgument != args[t]) {\n-                        if (!changed) {\n-                            args = args.clone();\n-                            changed = true;\n-                        }\n-                        args[t] = resolvedTypeArgument;\n-                    }\n-                }\n-\n-                return changed\n-                        ? new ParameterizedTypeImpl(newOwnerType, original.getRawType(), args)\n-                        : original;\n-\n-            } else if (toResolve instanceof WildcardType) {\n-                WildcardType original = (WildcardType) toResolve;\n-                Type[] originalLowerBound = original.getLowerBounds();\n-                Type[] originalUpperBound = original.getUpperBounds();\n-\n-                if (originalLowerBound.length == 1) {\n-                    Type lowerBound = resolve(context, contextRawType, originalLowerBound[0]);\n-                    if (lowerBound != originalLowerBound[0]) {\n-                        return supertypeOf(lowerBound);\n-                    }\n-                } else if (originalUpperBound.length == 1) {\n-                    Type upperBound = resolve(context, contextRawType, originalUpperBound[0]);\n-                    if (upperBound != originalUpperBound[0]) {\n-                        return subtypeOf(upperBound);\n-                    }\n-                }\n-                return original;\n-\n-            } else {\n-                return toResolve;\n-            }\n+                       GenericArrayType original = (GenericArrayType) toResolve;\n+                       Type componentType = original.getGenericComponentType();\n+                       Type newComponentType = resolve(context, contextRawType, componentType);\n+                       return componentType == newComponentType ? original : arrayOf(newComponentType);\n+                   } else if (toResolve instanceof ParameterizedType) {\n+                       ParameterizedType original = (ParameterizedType) toResolve;\n+                       Type ownerType = original.getOwnerType();\n+                       Type newOwnerType = resolve(context, contextRawType, ownerType);\n+                       boolean changed = newOwnerType != ownerType;\n+                       Type[] args = original.getActualTypeArguments();\n+                       for (int t = 0, length = args.length; t < length; t++) {\n+                           Type resolvedTypeArgument = resolve(context, contextRawType, args[t]);\n+                           if (resolvedTypeArgument != args[t]) {\n+                               if (!changed) {\n+                                   args = args.clone();\n+                                   changed = true;\n+                               }\n+                               args[t] = resolvedTypeArgument;\n+                           }\n+                       }\n+                       return changed ? new ParameterizedTypeImpl(newOwnerType, original.getRawType(), args) : original;\n+                   } else if (toResolve instanceof WildcardType) {\n+                              WildcardType original = (WildcardType) toResolve;\n+                              Type[] originalLowerBound = original.getLowerBounds();\n+                              Type[] originalUpperBound = original.getUpperBounds();\n+                              if (originalLowerBound.length == 1) {\n+                                  Type lowerBound = resolve(context, contextRawType, originalLowerBound[0]);\n+                                  if (lowerBound != originalLowerBound[0]) {\n+                                      return supertypeOf(lowerBound);\n+                                  }\n+                              } else if (originalUpperBound.length == 1) {\n+                                  Type upperBound = resolve(context, contextRawType, originalUpperBound[0]);\n+                                  if (upperBound != originalUpperBound[0]) {\n+                                      return subtypeOf(upperBound);\n+                                  }\n+                              }\n+                              return original;\n+                          } else {\n+                              return toResolve;\n+                   }\n         }\n     }\n \n@@ -222,13 +200,11 @@ public final class Util {\n         if (declaredByRaw == null) {\n             return unknown;\n         }\n-\n         Type declaredBy = getGenericSupertype(context, contextRawType, declaredByRaw);\n         if (declaredBy instanceof ParameterizedType) {\n             int index = indexOf(declaredByRaw.getTypeParameters(), unknown);\n             return ((ParameterizedType) declaredBy).getActualTypeArguments()[index];\n         }\n-\n         return unknown;\n     }\n \n@@ -237,6 +213,7 @@ public final class Util {\n      * IntegerSet}, the result for when supertype is {@code Set.class} is {@code Set<Integer>} and the\n      * result when the supertype is {@code Collection.class} is {@code Collection<Integer>}.\n      */\n+\n     public static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResolve) {\n         if (toResolve == rawType) {\n             return context;\n@@ -249,7 +226,7 @@ public final class Util {\n                 if (interfaces[i] == toResolve) {\n                     return rawType.getGenericInterfaces()[i];\n                 } else if (toResolve.isAssignableFrom(interfaces[i])) {\n-                    return getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], toResolve);\n+                           return getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], toResolve);\n                 }\n             }\n         }\n@@ -261,7 +238,7 @@ public final class Util {\n                 if (rawSupertype == toResolve) {\n                     return rawType.getGenericSuperclass();\n                 } else if (toResolve.isAssignableFrom(rawSupertype)) {\n-                    return getGenericSupertype(rawType.getGenericSuperclass(), rawSupertype, toResolve);\n+                           return getGenericSupertype(rawType.getGenericSuperclass(), rawSupertype, toResolve);\n                 }\n                 rawType = rawSupertype;\n             }\n@@ -292,6 +269,7 @@ public final class Util {\n      * Returns the declaring class of {@code typeVariable}, or {@code null} if it was not declared by\n      * a class.\n      */\n+\n     static @Nullable\n     Class<?> declaringClassOf(TypeVariable<?> typeVariable) {\n         GenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration();\n@@ -305,9 +283,10 @@ public final class Util {\n     }\n \n     public static final class ParameterizedTypeImpl implements ParameterizedType {\n-        private final @Nullable\n-        Type ownerType;\n+        private final @Nullable Type ownerType;\n         private final Type rawType;\n+\n+\n         public final Type[] typeArguments;\n \n         public ParameterizedTypeImpl(@Nullable Type ownerType, Type rawType, Type... typeArguments) {\n@@ -316,15 +295,12 @@ public final class Util {\n                 Class<?> enclosingClass = ((Class<?>) rawType).getEnclosingClass();\n                 if (ownerType != null) {\n                     if (enclosingClass == null || Types.getRawType(ownerType) != enclosingClass) {\n-                        throw new IllegalArgumentException(\n-                                \"unexpected owner type for \" + rawType + \": \" + ownerType);\n+                        throw new IllegalArgumentException(\"unexpected owner type for \" + rawType + \": \" + ownerType);\n                     }\n                 } else if (enclosingClass != null) {\n-                    throw new IllegalArgumentException(\n-                            \"unexpected owner type for \" + rawType + \": null\");\n+                           throw new IllegalArgumentException(\"unexpected owner type for \" + rawType + \": null\");\n                 }\n             }\n-\n             this.ownerType = ownerType == null ? null : canonicalize(ownerType);\n             this.rawType = canonicalize(rawType);\n             this.typeArguments = typeArguments.clone();\n@@ -355,14 +331,13 @@ public final class Util {\n \n         @Override\n         public boolean equals(Object other) {\n-            return other instanceof ParameterizedType\n-                    && Types.equals(this, (ParameterizedType) other);\n+            return other instanceof ParameterizedType && Types.equals(this, (ParameterizedType) other);\n         }\n \n         @Override\n         public int hashCode() {\n             return Arrays.hashCode(typeArguments)\n-                    ^ rawType.hashCode()\n+                ^ rawType.hashCode()\n                     ^ hashCodeOrZero(ownerType);\n         }\n \n@@ -370,11 +345,9 @@ public final class Util {\n         public String toString() {\n             StringBuilder result = new StringBuilder(30 * (typeArguments.length + 1));\n             result.append(typeToString(rawType));\n-\n             if (typeArguments.length == 0) {\n                 return result.toString();\n             }\n-\n             result.append(\"<\").append(typeToString(typeArguments[0]));\n             for (int i = 1; i < typeArguments.length; i++) {\n                 result.append(\", \").append(typeToString(typeArguments[i]));\n@@ -397,8 +370,7 @@ public final class Util {\n \n         @Override\n         public boolean equals(Object o) {\n-            return o instanceof GenericArrayType\n-                    && Types.equals(this, (GenericArrayType) o);\n+            return o instanceof GenericArrayType && Types.equals(this, (GenericArrayType) o);\n         }\n \n         @Override\n@@ -417,10 +389,10 @@ public final class Util {\n      * support what the Java 6 language needs - at most one bound. If a lower bound is set, the upper\n      * bound must be Object.class.\n      */\n+\n     public static final class WildcardTypeImpl implements WildcardType {\n         private final Type upperBound;\n-        private final @Nullable\n-        Type lowerBound;\n+        private final @Nullable Type lowerBound;\n \n         public WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {\n             if (lowerBounds.length > 1) {\n@@ -429,7 +401,6 @@ public final class Util {\n             if (upperBounds.length != 1) {\n                 throw new IllegalArgumentException();\n             }\n-\n             if (lowerBounds.length == 1) {\n                 if (lowerBounds[0] == null) {\n                     throw new NullPointerException();\n@@ -440,7 +411,6 @@ public final class Util {\n                 }\n                 this.lowerBound = canonicalize(lowerBounds[0]);\n                 this.upperBound = Object.class;\n-\n             } else {\n                 if (upperBounds[0] == null) {\n                     throw new NullPointerException();\n@@ -463,15 +433,14 @@ public final class Util {\n \n         @Override\n         public boolean equals(Object other) {\n-            return other instanceof WildcardType\n-                    && Types.equals(this, (WildcardType) other);\n+            return other instanceof WildcardType && Types.equals(this, (WildcardType) other);\n         }\n \n         @Override\n         public int hashCode() {\n             // This equals Arrays.hashCode(getLowerBounds()) ^ Arrays.hashCode(getUpperBounds()).\n             return (lowerBound != null ? 31 + lowerBound.hashCode() : 1)\n-                    ^ (31 + upperBound.hashCode());\n+                ^ (31 + upperBound.hashCode());\n         }\n \n         @Override\n@@ -486,8 +455,7 @@ public final class Util {\n         }\n     }\n \n-    public static String typeAnnotatedWithAnnotations(Type type,\n-                                                      Set<? extends Annotation> annotations) {\n+    public static String typeAnnotatedWithAnnotations(Type type, Set<? extends Annotation> annotations) {\n         return type + (annotations.isEmpty() ? \" (with no annotations)\" : \" annotated \" + annotations);\n     }\n \n@@ -495,9 +463,9 @@ public final class Util {\n      * Loads the generated JsonAdapter for classes annotated {@link JsonClass}. This works because it\n      * uses the same naming conventions as {@code JsonClassCodeGenProcessor}.\n      */\n+\n     public static @Nullable\n-    JsonAdapter<?> generatedAdapter(Moshi moshi, Type type,\n-                                    Class<?> rawType) {\n+    JsonAdapter<?> generatedAdapter(Moshi moshi, Type type, Class<?> rawType) {\n         JsonClass jsonClass = rawType.getAnnotation(JsonClass.class);\n         if (jsonClass == null || !jsonClass.generateAdapter()) {\n             return null;\n@@ -505,34 +473,26 @@ public final class Util {\n         String adapterClassName = rawType.getName().replace(\"$\", \"_\") + \"JsonAdapter\";\n         try {\n             @SuppressWarnings(\"unchecked\") // We generate types to match.\n-                    Class<? extends JsonAdapter<?>> adapterClass = (Class<? extends JsonAdapter<?>>)\n-                    Class.forName(adapterClassName, true, rawType.getClassLoader());\n+            Class<? extends JsonAdapter<?>> adapterClass = (Class<? extends JsonAdapter<?>>) Class.forName(adapterClassName, true, rawType.getClassLoader());\n             if (type instanceof ParameterizedType) {\n-                Constructor<? extends JsonAdapter<?>> constructor\n-                        = adapterClass.getDeclaredConstructor(Moshi.class, Type[].class);\n+                Constructor<? extends JsonAdapter<?>> constructor = adapterClass.getDeclaredConstructor(Moshi.class, Type[].class);\n                 constructor.setAccessible(true);\n-                return constructor.newInstance(moshi, ((ParameterizedType) type).getActualTypeArguments())\n-                        .nullSafe();\n+                return constructor.newInstance(moshi, ((ParameterizedType) type).getActualTypeArguments()).nullSafe();\n             } else {\n-                Constructor<? extends JsonAdapter<?>> constructor\n-                        = adapterClass.getDeclaredConstructor(Moshi.class);\n+                Constructor<? extends JsonAdapter<?>> constructor = adapterClass.getDeclaredConstructor(Moshi.class);\n                 constructor.setAccessible(true);\n                 return constructor.newInstance(moshi).nullSafe();\n             }\n         } catch (ClassNotFoundException e) {\n-            throw new RuntimeException(\n-                    \"Failed to find the generated JsonAdapter class for \" + rawType, e);\n+            throw new RuntimeException(\"Failed to find the generated JsonAdapter class for \" + rawType, e);\n         } catch (NoSuchMethodException e) {\n-            throw new RuntimeException(\n-                    \"Failed to find the generated JsonAdapter constructor for \" + rawType, e);\n+            throw new RuntimeException(\"Failed to find the generated JsonAdapter constructor for \" + rawType, e);\n         } catch (IllegalAccessException e) {\n-            throw new RuntimeException(\n-                    \"Failed to access the generated JsonAdapter for \" + rawType, e);\n+            throw new RuntimeException(\"Failed to access the generated JsonAdapter for \" + rawType, e);\n         } catch (InstantiationException e) {\n-            throw new RuntimeException(\n-                    \"Failed to instantiate the generated JsonAdapter for \" + rawType, e);\n+            throw new RuntimeException(\"Failed to instantiate the generated JsonAdapter for \" + rawType, e);\n         } catch (InvocationTargetException e) {\n             throw rethrowCause(e);\n         }\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 144
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/errored/1/4/Util.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/styler_random/4/Util.java\nindex 00737dd825f..1d636fb7b70 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/errored/1/4/Util.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/styler_random/4/Util.java\n@@ -511,8 +511,7 @@ public final class Util {\n                 Constructor<? extends JsonAdapter<?>> constructor\n                         = adapterClass.getDeclaredConstructor(Moshi.class, Type[].class);\n                 constructor.setAccessible(true);\n-                return constructor.newInstance(moshi, ((ParameterizedType) type).getActualTypeArguments())\n-                        .nullSafe();\n+                return constructor.newInstance(moshi, ((ParameterizedType) type).getActualTypeArguments()).nullSafe();\n             } else {\n                 Constructor<? extends JsonAdapter<?>> constructor\n                         = adapterClass.getDeclaredConstructor(Moshi.class);\n",
            "diff_size": 2
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/errored/1/4/Util.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/styler_three_grams/4/Util.java\nindex 00737dd825f..1d636fb7b70 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/errored/1/4/Util.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/fangjinuo-easyjson/styler_three_grams/4/Util.java\n@@ -511,8 +511,7 @@ public final class Util {\n                 Constructor<? extends JsonAdapter<?>> constructor\n                         = adapterClass.getDeclaredConstructor(Moshi.class, Type[].class);\n                 constructor.setAccessible(true);\n-                return constructor.newInstance(moshi, ((ParameterizedType) type).getActualTypeArguments())\n-                        .nullSafe();\n+                return constructor.newInstance(moshi, ((ParameterizedType) type).getActualTypeArguments()).nullSafe();\n             } else {\n                 Constructor<? extends JsonAdapter<?>> constructor\n                         = adapterClass.getDeclaredConstructor(Moshi.class);\n",
            "diff_size": 2
        }
    ],
    "repaired_by": [
        "styler",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "intellij"
    ]
}