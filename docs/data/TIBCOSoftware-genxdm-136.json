{
    "project_name": "TIBCOSoftware-genxdm",
    "error_id": "136",
    "information": {
        "errors": [
            {
                "line": "62",
                "column": "1",
                "severity": "warning",
                "message": "File contains tab characters (this is the first instance).",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
            }
        ]
    },
    "source_code": "final class ValidationKernel<A> implements VxValidator<A>, SmExceptionSupplier\n{\n\t// Set by reset method. Preconditions guarantee that it is never null.\n\t// private final ParticleTerm STRICT_WILDCARD = new StrictWildcard<A>();\n\n\tprivate static boolean isWhiteSpace(final String strval)",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "65",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/136/ValidationKernel.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler/136/ValidationKernel.java\nindex 40a7804c48e..228a67b9021 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/136/ValidationKernel.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler/136/ValidationKernel.java\n@@ -59,8 +59,8 @@ import org.genxdm.xs.types.Type;\n  */\n final class ValidationKernel<A> implements VxValidator<A>, SmExceptionSupplier\n {\n-\t// Set by reset method. Preconditions guarantee that it is never null.\n-\t// private final ParticleTerm STRICT_WILDCARD = new StrictWildcard<A>();\n+// Set by reset method. Preconditions guarantee that it is never null.\n+ // private final ParticleTerm STRICT_WILDCARD = new StrictWildcard<A>();\n \n \tprivate static boolean isWhiteSpace(final String strval)\n \t{\n",
            "diff_size": 2
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/136/ValidationKernel.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/intellij/136/ValidationKernel.java\nindex 40a7804c48e..8334b474d66 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/136/ValidationKernel.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/intellij/136/ValidationKernel.java\n@@ -1,18 +1,19 @@\n /**\n  * Copyright (c) 2009-2010 TIBCO Software Inc.\n- *\n+ * <p>\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+\n package org.genxdm.processor.w3c.xs.validation.impl;\n \n import java.io.IOException;\n@@ -57,757 +58,687 @@ import org.genxdm.xs.types.Type;\n  * this class is package protected so overall, the validation API is schema model independent. In future, we may try to\n  * create a more abstract kernel.\n  */\n-final class ValidationKernel<A> implements VxValidator<A>, SmExceptionSupplier\n-{\n-\t// Set by reset method. Preconditions guarantee that it is never null.\n-\t// private final ParticleTerm STRICT_WILDCARD = new StrictWildcard<A>();\n-\n-\tprivate static boolean isWhiteSpace(final String strval)\n-\t{\n-\t\tif (null != strval)\n-\t\t{\n-\t\t\tfinal int n = strval.length();\n-\n-\t\t\tfor (int i = 0; i < n; i++)\n-\t\t\t{\n-\t\t\t\tfinal char ch = strval.charAt(i);\n-\n-\t\t\t\t// The follwing pattern is denormalized for speed.\n-\t\t\t\tif ((ch == 0x20) || (ch == 0x09) || (ch == 0xD) || (ch == 0xA))\n-\t\t\t\t{\n-\t\t\t\t\t// Try the next one, all must be whiteSpace.\n-\t\t\t\t}\n-\t\t\t\telse\n-\t\t\t\t{\n-\t\t\t\t\treturn false;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn true;\n-\t}\n-\n-\tpublic ValidationKernel(final AtomBridge<A> atomBridge, final VxSchemaDocumentLocationStrategy sdl)\n-\t{\n-\t\tm_atomBridge = PreCondition.assertNotNull(atomBridge);\n-\t\tNameSource names = NameSource.SINGLETON;\n-\t\tm_namespaces = new ValidationPrefixResolver(names);\n-\t\tm_currentItem = m_documentItem = new ValidationItem();\n-\t\t// A strict start is necessary to ensure that the root element has a declaration.\n-\t\t// However, the specification does not seem very clear on what should be the starting mode.\n-\t\tthis.sdl = sdl;\n-\t}\n-\n-\t@Override\n-\tpublic void characters(final char[] ch, final int start, final int length)\n-\t{\n-\t\tm_text.append(ch, start, length);\n-\t}\n-\n-\tprivate void checkValueConstraintForElement(final ElementDefinition elementDeclaration, final SimpleType simpleType, final List<? extends A> actualValue) throws AbortException\n-\t{\n-\t\tfinal ValueConstraint valueConstraint = elementDeclaration.getValueConstraint();\n-\t\tif (null != valueConstraint)\n-\t\t{\n-\t\t\tswitch (valueConstraint.getVariety())\n-\t\t\t{\n-\t\t\t\tcase Fixed:\n-\t\t\t\t{\n-\t\t\t\t\tfinal List<A> initialFixed = valueConstraint.getValue(m_atomBridge);\n-\n-\t\t\t\t\ttry\n-\t\t\t\t\t{\n-\t\t\t\t\t\tfinal List<A> actualFixed = simpleType.validate(initialFixed, m_atomBridge);\n-\t\t\t\t\t\tif (!ValidationSupport.equalValues(actualFixed, actualValue))\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tfinal String fixedC14N = m_atomBridge.getC14NString(actualFixed);\n-\t\t\t\t\t\t\tfinal String actualC14N = m_atomBridge.getC14NString(actualValue);\n-\t\t\t\t\t\t\tm_errors.error(new CvcElementFixedValueOverriddenSimpleException(elementDeclaration, fixedC14N, actualC14N, m_currentItem.getLocation()));\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\tcatch (final DatatypeException e)\n-\t\t\t\t\t{\n-\t\t\t\t\t\tfinal String lexicalValue = m_atomBridge.getC14NString(initialFixed);\n-\t\t\t\t\t\tm_errors.error(new SimpleTypeException(lexicalValue, simpleType, e));\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tbreak;\n-\t\t\t\tcase Default:\n-\t\t\t\t{\n-\t\t\t\t\t// No problem.\n-\t\t\t\t}\n-\t\t\t\tbreak;\n-\t\t\t\tdefault:\n-\t\t\t\t{\n-\t\t\t\t\tthrow new AssertionError(valueConstraint.getVariety());\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void endDocument() throws IOException, AbortException\n-\t{\n-\t\tm_mac.endDocument();\n-\n-\t\t// Check for dangling IDREFs here.\n-\t\tm_idm.reportDanglingIdRefs(m_errors);\n-\n-\t\tif (null != m_downstream)\n-\t\t{\n-\t\t\tm_downstream.endDocument();\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic VxPSVI endElement() throws IOException, AbortException\n-\t{\n-\t\tif (m_text.length() > 0)\n-\t\t{\n-\t\t\ttry\n-\t\t\t{\n-\t\t\t\thandleText(m_text.toString());\n-\t\t\t}\n-\t\t\tfinally\n-\t\t\t{\n-\t\t\t\tm_text.setLength(0);\n-\t\t\t}\n-\t\t}\n-\n-\t\ttry\n-\t\t{\n-\t\t\tif (!m_currentItem.m_detectedText)\n-\t\t\t{\n-\t\t\t\thandleNoTextCalls();\n-\t\t\t}\n-\n-\t\t\tfinal VxPSVI psvi = m_mac.endElement();\n-\n-\t\t\tm_icm.endElement(m_currentPSVI, m_currentItem);\n-\n-\t\t\treturn psvi;\n-\t\t}\n-\t\tfinally\n-\t\t{\n-\t\t\tm_currentItem = m_currentItem.pop();\n-\t\t\tm_currentPSVI = m_currentPSVI.getParent();\n-\n-\t\t\t// Maintain prefix mapping information.\n-\t\t\tm_namespaces.popContext();\n-\n-\t\t\tif (null != m_downstream)\n-\t\t\t{\n-\t\t\t\tm_downstream.endElement();\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate void handleNoTextCalls() throws IOException, AbortException\n-\t{\n-\t\tfinal Type elementType = m_currentPSVI.getType();\n-\t\tif (null != elementType)\n-\t\t{\n-\t\t\tif (elementType instanceof SimpleType)\n-\t\t\t{\n-\t\t\t\thandleNoTextCallsForSimpleContentModel((SimpleType)elementType);\n-\t\t\t}\n-\t\t\telse\n-\t\t\t{\n-\t\t\t\tfinal ComplexType complexType = (ComplexType)elementType;\n-\t\t\t\tfinal ContentType contentType = complexType.getContentType();\n-\t\t\t\tswitch (contentType.getKind())\n-\t\t\t\t{\n-\t\t\t\t\tcase Simple:\n-\t\t\t\t\t{\n-\t\t\t\t\t\thandleNoTextCallsForSimpleContentModel(contentType.getSimpleType());\n-\t\t\t\t\t}\n-\t\t\t\t\tbreak;\n-\t\t\t\t\tcase Empty:\n-\t\t\t\t\tcase ElementOnly:\n-\t\t\t\t\tcase Mixed:\n-\t\t\t\t\t{\n-\t\t\t\t\t\t// Do nothing\n-\t\t\t\t\t}\n-\t\t\t\t\tbreak;\n-\t\t\t\t\tdefault:\n-\t\t\t\t\t{\n-\t\t\t\t\t\tthrow new AssertionError(contentType.getKind());\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate void handleNoTextCallsForSimpleContentModel(final SimpleType simpleType) throws IOException, AbortException\n-\t{\n-\t\tif (m_currentPSVI.isNilled())\n-\t\t{\n-\t\t\t// OK\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\t// any default or fixed values.\n-\t\t\tfinal ElementDefinition declaration = m_currentPSVI.getDeclaration();\n-\t\t\tfinal ValueConstraint valueConstraint = (null != declaration) ? declaration.getValueConstraint() : null;\n-\t\t\tif (null != valueConstraint)\n-\t\t\t{\n-\t\t\t\tswitch (valueConstraint.getVariety())\n-\t\t\t\t{\n-\t\t\t\t\tcase Fixed:\n-\t\t\t\t\tcase Default:\n-\t\t\t\t\t{\n-\t\t\t\t\t\tfinal List<A> initialValue = valueConstraint.getValue(m_atomBridge);\n-\t\t\t\t\t\ttry\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tfinal List<A> actualValue = simpleType.validate(initialValue, m_atomBridge);\n-\n-\t\t\t\t\t\t\tm_idm.text(actualValue, simpleType, m_currentItem, m_errors, m_atomBridge);\n-\t\t\t\t\t\t\tm_icm.text(actualValue, simpleType, m_currentItem, m_nodeIndex, m_atomBridge);\n-\n-\t\t\t\t\t\t\tif (null != m_downstream)\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tm_downstream.text(actualValue);\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tcatch (final DatatypeException e)\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tfinal String lexicalValue = m_atomBridge.getC14NString(initialValue);\n-\t\t\t\t\t\t\tm_errors.error(new SimpleTypeException(lexicalValue, simpleType, e));\n-\n-\t\t\t\t\t\t\tm_idm.text(initialValue, simpleType, m_currentItem, m_errors, m_atomBridge);\n-\t\t\t\t\t\t\tm_icm.text(initialValue, simpleType, m_currentItem, m_nodeIndex, m_atomBridge);\n-\n-\t\t\t\t\t\t\tif (null != m_downstream)\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tm_downstream.text(initialValue);\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\tbreak;\n-\t\t\t\t\tdefault:\n-\t\t\t\t\t{\n-\t\t\t\t\t\tthrow new AssertionError(valueConstraint.getVariety());\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\telse\n-\t\t\t{\n-\t\t\t\t// If no value given above then call the validator with an empty string\n-\t\t\t\t// which will throw an exception if having no text is a problem.\n-\t\t\t\ttry\n-\t\t\t\t{\n-\t\t\t\t\tfinal List<A> actualValue = simpleType.validate(\"\", m_atomBridge);\n-\n-\t\t\t\t\tm_idm.text(actualValue, simpleType, m_currentItem, m_errors, m_atomBridge);\n-\t\t\t\t\tm_icm.text(actualValue, simpleType, m_currentItem, m_nodeIndex, m_atomBridge);\n-\n-\t\t\t\t\tif (null != m_downstream)\n-\t\t\t\t\t{\n-\t\t\t\t\t\tm_downstream.text(actualValue);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tcatch (final DatatypeException e)\n-\t\t\t\t{\n-\t\t\t\t\tm_errors.error(new SimpleTypeException(\"\", simpleType, e));\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate void handleText(final String initialValue) throws IOException, AbortException\n-\t{\n-\t\tm_nodeIndex++;\n-\n-\t\t// Remember that we got a text node.\n-\t\tm_currentItem.m_detectedText = true;\n-\n-\t\tif (m_currentItem.getSuspendChecking())\n-\t\t{\n-\t\t\tif (null != m_downstream)\n-\t\t\t{\n-\t\t\t\tm_downstream.text(initialValue);\n-\t\t\t}\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tswitch (m_currentPSVI.getProcessContents())\n-\t\t{\n-\t\t\tcase Strict:\n-\t\t\tcase Lax:\n-\t\t\t{\n-\t\t\t\tfinal ElementDefinition declaration = m_currentPSVI.getDeclaration();\n-\t\t\t\tif (m_currentPSVI.isNilled() && (null != declaration))\n-\t\t\t\t{\n-\t\t\t\t\tm_errors.error(new CvcElementUnexpectedChildInNilledElementException(declaration, m_currentItem.getLocation()));\n-\t\t\t\t}\n-\n-\t\t\t\tfinal Type elementType = m_currentPSVI.getType();\n-\t\t\t\tif (null != elementType)\n-\t\t\t\t{\n-\t\t\t\t\tif (elementType instanceof SimpleType)\n-\t\t\t\t\t{\n-\t\t\t\t\t    if (elementType instanceof SimpleUrType)\n-                        {\n-                            if (null != m_downstream)\n-                            {\n+final class ValidationKernel<A> implements VxValidator<A>, SmExceptionSupplier {\n+    // Set by reset method. Preconditions guarantee that it is never null.\n+    // private final ParticleTerm STRICT_WILDCARD = new StrictWildcard<A>();\n+\n+    private static boolean isWhiteSpace(final String strval) {\n+        if (null != strval) {\n+            final int n = strval.length();\n+\n+            for (int i = 0; i < n; i++) {\n+                final char ch = strval.charAt(i);\n+\n+                // The follwing pattern is denormalized for speed.\n+                if ((ch == 0x20) || (ch == 0x09) || (ch == 0xD) || (ch == 0xA)) {\n+                    // Try the next one, all must be whiteSpace.\n+                } else {\n+                    return false;\n+                }\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n+    public ValidationKernel(final AtomBridge<A> atomBridge,\n+                            final VxSchemaDocumentLocationStrategy sdl) {\n+        m_atomBridge = PreCondition.assertNotNull(atomBridge);\n+        NameSource names = NameSource.SINGLETON;\n+        m_namespaces = new ValidationPrefixResolver(names);\n+        m_currentItem = m_documentItem = new ValidationItem();\n+        // A strict start is necessary to ensure that the root element has a declaration.\n+        // However, the specification does not seem very clear on what should be the starting mode.\n+        this.sdl = sdl;\n+    }\n+\n+    @Override\n+    public void characters(final char[] ch, final int start, final int length) {\n+        m_text.append(ch, start, length);\n+    }\n+\n+    private void checkValueConstraintForElement(final ElementDefinition elementDeclaration,\n+                                                final SimpleType simpleType,\n+                                                final List<? extends A> actualValue)\n+        throws AbortException {\n+        final ValueConstraint valueConstraint = elementDeclaration.getValueConstraint();\n+        if (null != valueConstraint) {\n+            switch (valueConstraint.getVariety()) {\n+                case Fixed: {\n+                    final List<A> initialFixed = valueConstraint.getValue(m_atomBridge);\n+\n+                    try {\n+                        final List<A> actualFixed = simpleType.validate(initialFixed, m_atomBridge);\n+                        if (!ValidationSupport.equalValues(actualFixed, actualValue)) {\n+                            final String fixedC14N = m_atomBridge.getC14NString(actualFixed);\n+                            final String actualC14N = m_atomBridge.getC14NString(actualValue);\n+                            m_errors.error(new CvcElementFixedValueOverriddenSimpleException(\n+                                elementDeclaration, fixedC14N, actualC14N,\n+                                m_currentItem.getLocation()));\n+                        }\n+                    } catch (final DatatypeException e) {\n+                        final String lexicalValue = m_atomBridge.getC14NString(initialFixed);\n+                        m_errors.error(new SimpleTypeException(lexicalValue, simpleType, e));\n+                    }\n+                }\n+                break;\n+                case Default: {\n+                    // No problem.\n+                }\n+                break;\n+                default: {\n+                    throw new AssertionError(valueConstraint.getVariety());\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void endDocument() throws IOException, AbortException {\n+        m_mac.endDocument();\n+\n+        // Check for dangling IDREFs here.\n+        m_idm.reportDanglingIdRefs(m_errors);\n+\n+        if (null != m_downstream) {\n+            m_downstream.endDocument();\n+        }\n+    }\n+\n+    @Override\n+    public VxPSVI endElement() throws IOException, AbortException {\n+        if (m_text.length() > 0) {\n+            try {\n+                handleText(m_text.toString());\n+            } finally {\n+                m_text.setLength(0);\n+            }\n+        }\n+\n+        try {\n+            if (!m_currentItem.m_detectedText) {\n+                handleNoTextCalls();\n+            }\n+\n+            final VxPSVI psvi = m_mac.endElement();\n+\n+            m_icm.endElement(m_currentPSVI, m_currentItem);\n+\n+            return psvi;\n+        } finally {\n+            m_currentItem = m_currentItem.pop();\n+            m_currentPSVI = m_currentPSVI.getParent();\n+\n+            // Maintain prefix mapping information.\n+            m_namespaces.popContext();\n+\n+            if (null != m_downstream) {\n+                m_downstream.endElement();\n+            }\n+        }\n+    }\n+\n+    private void handleNoTextCalls() throws IOException, AbortException {\n+        final Type elementType = m_currentPSVI.getType();\n+        if (null != elementType) {\n+            if (elementType instanceof SimpleType) {\n+                handleNoTextCallsForSimpleContentModel((SimpleType) elementType);\n+            } else {\n+                final ComplexType complexType = (ComplexType) elementType;\n+                final ContentType contentType = complexType.getContentType();\n+                switch (contentType.getKind()) {\n+                    case Simple: {\n+                        handleNoTextCallsForSimpleContentModel(contentType.getSimpleType());\n+                    }\n+                    break;\n+                    case Empty:\n+                    case ElementOnly:\n+                    case Mixed: {\n+                        // Do nothing\n+                    }\n+                    break;\n+                    default: {\n+                        throw new AssertionError(contentType.getKind());\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void handleNoTextCallsForSimpleContentModel(final SimpleType simpleType)\n+        throws IOException, AbortException {\n+        if (m_currentPSVI.isNilled()) {\n+            // OK\n+        } else {\n+            // any default or fixed values.\n+            final ElementDefinition declaration = m_currentPSVI.getDeclaration();\n+            final ValueConstraint valueConstraint =\n+                (null != declaration) ? declaration.getValueConstraint() : null;\n+            if (null != valueConstraint) {\n+                switch (valueConstraint.getVariety()) {\n+                    case Fixed:\n+                    case Default: {\n+                        final List<A> initialValue = valueConstraint.getValue(m_atomBridge);\n+                        try {\n+                            final List<A> actualValue =\n+                                simpleType.validate(initialValue, m_atomBridge);\n+\n+                            m_idm.text(actualValue, simpleType, m_currentItem, m_errors,\n+                                m_atomBridge);\n+                            m_icm.text(actualValue, simpleType, m_currentItem, m_nodeIndex,\n+                                m_atomBridge);\n+\n+                            if (null != m_downstream) {\n+                                m_downstream.text(actualValue);\n+                            }\n+                        } catch (final DatatypeException e) {\n+                            final String lexicalValue = m_atomBridge.getC14NString(initialValue);\n+                            m_errors.error(new SimpleTypeException(lexicalValue, simpleType, e));\n+\n+                            m_idm.text(initialValue, simpleType, m_currentItem, m_errors,\n+                                m_atomBridge);\n+                            m_icm.text(initialValue, simpleType, m_currentItem, m_nodeIndex,\n+                                m_atomBridge);\n+\n+                            if (null != m_downstream) {\n                                 m_downstream.text(initialValue);\n                             }\n                         }\n-\t\t\t\t\t    else if (elementType instanceof SimpleType)\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tfinal SimpleType simpleType = (SimpleType)elementType;\n-\t\t\t\t\t\t\ttry\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tfinal List<A> actualValue = simpleType.validate(initialValue, m_atomBridge);\n-\n-\t\t\t\t\t\t\t\tif (null != declaration)\n-\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\tcheckValueConstraintForElement(declaration, simpleType, actualValue);\n-\t\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\t\tm_idm.text(actualValue, simpleType, m_currentItem, m_errors, m_atomBridge);\n-\t\t\t\t\t\t\t\tm_icm.text(actualValue, simpleType, m_currentItem, m_nodeIndex, m_atomBridge);\n-\n-\t\t\t\t\t\t\t\tif (null != m_downstream)\n-\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\tm_downstream.text(actualValue);\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tcatch (final DatatypeException e)\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tm_errors.error(new SimpleTypeException(initialValue, simpleType, e));\n-\t\t\t\t\t\t\t\tif (null != m_downstream)\n-\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\tm_downstream.text(initialValue);\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\telse\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tthrow new AssertionError(elementType);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\telse if (elementType instanceof ComplexType)\n-\t\t\t\t\t{\n-\t\t\t\t\t\tfinal ComplexType complexType = (ComplexType)elementType;\n-\t\t\t\t\t\tfinal ContentType contentType = complexType.getContentType();\n-\t\t\t\t\t\tswitch (contentType.getKind())\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tcase Simple:\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tfinal SimpleType simpleType = contentType.getSimpleType();\n-\t\t\t\t\t\t\t\ttry\n-\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\tfinal List<A> actualValue = simpleType.validate(initialValue, m_atomBridge);\n-\n-\t\t\t\t\t\t\t\t\tif (null != declaration)\n-\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\tcheckValueConstraintForElement(declaration, simpleType, actualValue);\n-\t\t\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\t\t\tm_idm.text(actualValue, simpleType, m_currentItem, m_errors, m_atomBridge);\n-\t\t\t\t\t\t\t\t\tm_icm.text(actualValue, simpleType, m_currentItem, m_nodeIndex, m_atomBridge);\n-\n-\t\t\t\t\t\t\t\t\tif (null != m_downstream)\n-\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\tm_downstream.text(actualValue);\n-\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\tcatch (final DatatypeException e)\n-\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\tm_errors.error(new SimpleTypeException(initialValue, simpleType, e));\n-\t\t\t\t\t\t\t\t\tif (null != m_downstream)\n-\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\tm_downstream.text(initialValue);\n-\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t\tcase ElementOnly:\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tif (!isWhiteSpace(initialValue))\n-\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\tm_errors.error(new CvcUnexpectedNonWhiteSpaceTextInElementOnlyContentException(m_currentPSVI.getName(), initialValue, m_currentItem.getLocation()));\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t\tcase Mixed:\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tif (null != declaration)\n-\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\tValidationRules.checkValueConstraintForMixedContent(declaration, initialValue, m_currentItem, m_errors, m_atomBridge);\n-\t\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\t\tif (null != m_downstream)\n-\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\tm_downstream.text(initialValue);\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t\tcase Empty:\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tm_errors.error(new CvcUnexpectedTextInEmptyContentException(m_currentPSVI.getName(), initialValue, m_currentItem.getLocation()));\n-\t\t\t\t\t\t\t\tif (null != m_downstream)\n-\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\tm_downstream.text(initialValue);\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t\tdefault:\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tthrow new AssertionError(contentType.getKind());\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\telse\n-\t\t\t\t\t{\n-\t\t\t\t\t\tthrow new AssertionError(elementType);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\telse\n-\t\t\t\t{\n-\t\t\t\t\tif (null != m_downstream)\n-\t\t\t\t\t{\n-\t\t\t\t\t\tm_downstream.text(initialValue);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tbreak;\n-\t\t\tcase Skip:\n-\t\t\t{\n-\t\t\t\tif (null != m_downstream)\n-\t\t\t\t{\n-\t\t\t\t\tm_downstream.text(initialValue);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t{\n-\t\t\t\tthrow new AssertionError(m_currentPSVI.getProcessContents());\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void reset()\n-\t{\n-\t    if (m_namespaces != null)\n-\t        m_namespaces.reset();\n-\t    if (m_attributes != null)\n-\t        m_attributes.reset();\n-\t\tm_nodeIndex = -1;\n-\t\tif (m_icm != null)\n-\t\t    m_icm.reset();\n-\t\tskipContents = null; // null is a better sentinel than empty\n-\t}\n-\t\n-\t@Override\n-\tpublic void setComponentProvider(ComponentProvider provider)\n-\t{\n-\t    m_provider = provider;\n-\t    ValidationCache cache = new ValidationCache();\n+                    }\n+                    break;\n+                    default: {\n+                        throw new AssertionError(valueConstraint.getVariety());\n+                    }\n+                }\n+            } else {\n+                // If no value given above then call the validator with an empty string\n+                // which will throw an exception if having no text is a problem.\n+                try {\n+                    final List<A> actualValue = simpleType.validate(\"\", m_atomBridge);\n+\n+                    m_idm.text(actualValue, simpleType, m_currentItem, m_errors, m_atomBridge);\n+                    m_icm.text(actualValue, simpleType, m_currentItem, m_nodeIndex, m_atomBridge);\n+\n+                    if (null != m_downstream) {\n+                        m_downstream.text(actualValue);\n+                    }\n+                } catch (final DatatypeException e) {\n+                    m_errors.error(new SimpleTypeException(\"\", simpleType, e));\n+                }\n+            }\n+        }\n+    }\n+\n+    private void handleText(final String initialValue) throws IOException, AbortException {\n+        m_nodeIndex++;\n+\n+        // Remember that we got a text node.\n+        m_currentItem.m_detectedText = true;\n+\n+        if (m_currentItem.getSuspendChecking()) {\n+            if (null != m_downstream) {\n+                m_downstream.text(initialValue);\n+            }\n+            return;\n+        }\n+\n+        switch (m_currentPSVI.getProcessContents()) {\n+            case Strict:\n+            case Lax: {\n+                final ElementDefinition declaration = m_currentPSVI.getDeclaration();\n+                if (m_currentPSVI.isNilled() && (null != declaration)) {\n+                    m_errors.error(\n+                        new CvcElementUnexpectedChildInNilledElementException(declaration,\n+                            m_currentItem.getLocation()));\n+                }\n+\n+                final Type elementType = m_currentPSVI.getType();\n+                if (null != elementType) {\n+                    if (elementType instanceof SimpleType) {\n+                        if (elementType instanceof SimpleUrType) {\n+                            if (null != m_downstream) {\n+                                m_downstream.text(initialValue);\n+                            }\n+                        } else if (elementType instanceof SimpleType) {\n+                            final SimpleType simpleType = (SimpleType) elementType;\n+                            try {\n+                                final List<A> actualValue =\n+                                    simpleType.validate(initialValue, m_atomBridge);\n+\n+                                if (null != declaration) {\n+                                    checkValueConstraintForElement(declaration, simpleType,\n+                                        actualValue);\n+                                }\n+\n+                                m_idm.text(actualValue, simpleType, m_currentItem, m_errors,\n+                                    m_atomBridge);\n+                                m_icm.text(actualValue, simpleType, m_currentItem, m_nodeIndex,\n+                                    m_atomBridge);\n+\n+                                if (null != m_downstream) {\n+                                    m_downstream.text(actualValue);\n+                                }\n+                            } catch (final DatatypeException e) {\n+                                m_errors\n+                                    .error(new SimpleTypeException(initialValue, simpleType, e));\n+                                if (null != m_downstream) {\n+                                    m_downstream.text(initialValue);\n+                                }\n+                            }\n+                        } else {\n+                            throw new AssertionError(elementType);\n+                        }\n+                    } else if (elementType instanceof ComplexType) {\n+                        final ComplexType complexType = (ComplexType) elementType;\n+                        final ContentType contentType = complexType.getContentType();\n+                        switch (contentType.getKind()) {\n+                            case Simple: {\n+                                final SimpleType simpleType = contentType.getSimpleType();\n+                                try {\n+                                    final List<A> actualValue =\n+                                        simpleType.validate(initialValue, m_atomBridge);\n+\n+                                    if (null != declaration) {\n+                                        checkValueConstraintForElement(declaration, simpleType,\n+                                            actualValue);\n+                                    }\n+\n+                                    m_idm.text(actualValue, simpleType, m_currentItem, m_errors,\n+                                        m_atomBridge);\n+                                    m_icm.text(actualValue, simpleType, m_currentItem, m_nodeIndex,\n+                                        m_atomBridge);\n+\n+                                    if (null != m_downstream) {\n+                                        m_downstream.text(actualValue);\n+                                    }\n+                                } catch (final DatatypeException e) {\n+                                    m_errors.error(\n+                                        new SimpleTypeException(initialValue, simpleType, e));\n+                                    if (null != m_downstream) {\n+                                        m_downstream.text(initialValue);\n+                                    }\n+                                }\n+                            }\n+                            break;\n+                            case ElementOnly: {\n+                                if (!isWhiteSpace(initialValue)) {\n+                                    m_errors.error(\n+                                        new CvcUnexpectedNonWhiteSpaceTextInElementOnlyContentException(\n+                                            m_currentPSVI.getName(), initialValue,\n+                                            m_currentItem.getLocation()));\n+                                }\n+                            }\n+                            break;\n+                            case Mixed: {\n+                                if (null != declaration) {\n+                                    ValidationRules.checkValueConstraintForMixedContent(declaration,\n+                                        initialValue, m_currentItem, m_errors, m_atomBridge);\n+                                }\n+\n+                                if (null != m_downstream) {\n+                                    m_downstream.text(initialValue);\n+                                }\n+                            }\n+                            break;\n+                            case Empty: {\n+                                m_errors.error(new CvcUnexpectedTextInEmptyContentException(\n+                                    m_currentPSVI.getName(), initialValue,\n+                                    m_currentItem.getLocation()));\n+                                if (null != m_downstream) {\n+                                    m_downstream.text(initialValue);\n+                                }\n+                            }\n+                            break;\n+                            default: {\n+                                throw new AssertionError(contentType.getKind());\n+                            }\n+                        }\n+                    } else {\n+                        throw new AssertionError(elementType);\n+                    }\n+                } else {\n+                    if (null != m_downstream) {\n+                        m_downstream.text(initialValue);\n+                    }\n+                }\n+            }\n+            break;\n+            case Skip: {\n+                if (null != m_downstream) {\n+                    m_downstream.text(initialValue);\n+                }\n+            }\n+            break;\n+            default: {\n+                throw new AssertionError(m_currentPSVI.getProcessContents());\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void reset() {\n+        if (m_namespaces != null) {\n+            m_namespaces.reset();\n+        }\n+        if (m_attributes != null) {\n+            m_attributes.reset();\n+        }\n+        m_nodeIndex = -1;\n+        if (m_icm != null) {\n+            m_icm.reset();\n+        }\n+        skipContents = null; // null is a better sentinel than empty\n+    }\n+\n+    @Override\n+    public void setComponentProvider(ComponentProvider provider) {\n+        m_provider = provider;\n+        ValidationCache cache = new ValidationCache();\n         m_attributes = new AttributeManager<A>(m_provider, m_atomBridge);\n-        m_currentPSVI = m_documentPSVI = new ModelPSVI(ProcessContentsMode.Strict, m_provider, cache);\n+        m_currentPSVI =\n+            m_documentPSVI = new ModelPSVI(ProcessContentsMode.Strict, m_provider, cache);\n \n         m_mac = new ModelAnalyzerImpl(m_provider, cache);\n-        if (m_errors != null)\n+        if (m_errors != null) {\n             m_mac.setExceptionHandler(m_errors);\n-\t}\n-\t\n-\t@Override\n-\tpublic void setExceptionHandler(final SchemaExceptionHandler handler)\n-\t{\n-\t\tm_errors = PreCondition.assertArgumentNotNull(handler, \"handler\");\n-\t\tif (m_mac != null)\n-\t\t    m_mac.setExceptionHandler(handler);\n-\t}\n-\t\n-\t@Override\n-\tpublic void setIgnoredElements(Iterable<QName> toSkip)\n-\t{\n-\t    if (skipContents == null)\n-\t        skipContents = new HashSet<QName>();\n-\t    skipContents.clear();\n-\t    for (QName name : toSkip)\n-\t        skipContents.add(name);\n-\t}\n-\n-\t@Override\n-\tpublic void setOutputHandler(final VxOutputHandler<A> handler)\n-\t{\n-\t\tm_downstream = PreCondition.assertArgumentNotNull(handler, \"handler\");\n-\t}\n-\n-\t@Override\n-\tpublic void startDocument(final URI documentURI) throws IOException\n-\t{\n-\t\tthis.documentURI = documentURI;\n-\n-\t\tm_currentPSVI = m_documentPSVI;\n-\t\tm_currentItem = m_documentItem;\n-\t\tm_mac.startDocument();\n-\n-\t\tm_nodeIndex = 0; // The document node gets to be the zeroth index.\n-\n-\t\tm_idm.reset();\n-\n-\t\tif (null != m_downstream)\n-\t\t{\n-\t\t\tm_downstream.startDocument();\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void startElement(final QName elementName, final LinkedList<VxMapping<String, String>> namespaces, final LinkedList<VxMapping<QName, String>> attributes, QName elementType) \n-\t    throws IOException, AbortException\n-\t{\n-\t    Type localType = null;\n-\t    if (elementType != null)\n-\t    {\n-\t        localType = m_provider.getTypeDefinition(elementType);\n-\t        // if a specified type has been provided by the caller, but the provider cannot resolve\n-\t        // the type, we need to simply stop, because things are not going to work predictably.\n-\t        // a non-null elementType *requires* that we end up with non-null localType right here.\n-\t        if (localType == null)\n-\t            throw new AbortException(new SmUndeclaredReferenceException(elementType, null));\n-\t    }\n-\t\tm_text.setLength(0);\n-\n-\t\tfinal ValidationItem parentItem = m_currentItem;\n-\t\tm_currentItem = parentItem.push(++m_nodeIndex);\n-\n-\t\t// Maintain prefix mapping information.\n-\t\tm_namespaces.pushContext();\n-\t\tif (namespaces.size() > 0) // Optimization.\n-\t\t{\n-\t\t\tfor (final VxMapping<String, String> mapping : namespaces)\n-\t\t\t{\n-\t\t\t\tm_namespaces.declarePrefix(mapping.getKey(), mapping.getValue());\n-\t\t\t}\n-\t\t}\n-\n-\t\t// before dealing with attributes, which may make the localType non-null,\n-\t\t// tweak processContents in the 'parent' (which may be a phantom) of the\n-\t\t// current element's PSVI to lax. use null in savedPC as a sentinel when\n-\t\t// restoring, later.\n-\t\tProcessContentsMode savedPC = null;\n-\t\tif (localType != null)\n-\t\t{\n-\t\t    savedPC = m_currentPSVI.getProcessContents();\n-\t\t    // set m_currentPSVI process contents to lax, because we have an element type override\n-\t\t    // which means that there probably is no element declaration for this element's name.\n-\t\t    // unless it's lax, this will cause an error.\n-\t\t    m_currentPSVI.setProcessContents(ProcessContentsMode.Lax);\n-\t\t}\n-\t\t\n-\t\t// Digest the attributes from the XMLSchema-instance namespace.\n-\t\tm_attributes.initialize(elementName, m_currentItem, attributes, m_namespaces, documentURI, m_errors, sdl);\n-\t\t// if we're not operating in caller-overrides-type mode, get the xsi:type override\n-\t\tif (m_attributes.getLocalType() != null)\n-\t\t    localType = m_attributes.getLocalType();\n-\t\tfinal Boolean explicitNil = m_attributes.getLocalNil();\n-\n-\t\tm_currentPSVI = m_mac.startElement(elementName, localType, explicitNil);\n-\t\t// reset processContents in the child, if we relaxed it above, signalled by non-null savedPC\n-\t\tif (savedPC != null)\n-\t\t    m_currentPSVI.setProcessContents(savedPC); // actually a different ModelPSVI than the one we set lax above\n-\n-\t\tm_icm.startElement(m_currentPSVI, m_currentItem, m_errors);\n-\n-\t\tif (m_downstream != null)\n-\t\t{\n-\t\t\tm_downstream.startElement(elementName, m_currentPSVI.getType());\n-\n-\t\t\tfor (final VxMapping<String, String> mapping : namespaces)\n-\t\t\t{\n-\t\t\t\tm_downstream.namespace(mapping.getKey(), mapping.getValue());\n-\t\t\t}\n-\t\t}\n+        }\n+    }\n+\n+    @Override\n+    public void setExceptionHandler(final SchemaExceptionHandler handler) {\n+        m_errors = PreCondition.assertArgumentNotNull(handler, \"handler\");\n+        if (m_mac != null) {\n+            m_mac.setExceptionHandler(handler);\n+        }\n+    }\n+\n+    @Override\n+    public void setIgnoredElements(Iterable<QName> toSkip) {\n+        if (skipContents == null) {\n+            skipContents = new HashSet<QName>();\n+        }\n+        skipContents.clear();\n+        for (QName name : toSkip) {\n+            skipContents.add(name);\n+        }\n+    }\n+\n+    @Override\n+    public void setOutputHandler(final VxOutputHandler<A> handler) {\n+        m_downstream = PreCondition.assertArgumentNotNull(handler, \"handler\");\n+    }\n+\n+    @Override\n+    public void startDocument(final URI documentURI) throws IOException {\n+        this.documentURI = documentURI;\n+\n+        m_currentPSVI = m_documentPSVI;\n+        m_currentItem = m_documentItem;\n+        m_mac.startDocument();\n+\n+        m_nodeIndex = 0; // The document node gets to be the zeroth index.\n+\n+        m_idm.reset();\n+\n+        if (null != m_downstream) {\n+            m_downstream.startDocument();\n+        }\n+    }\n+\n+    @Override\n+    public void startElement(final QName elementName,\n+                             final LinkedList<VxMapping<String, String>> namespaces,\n+                             final LinkedList<VxMapping<QName, String>> attributes,\n+                             QName elementType)\n+        throws IOException, AbortException {\n+        Type localType = null;\n+        if (elementType != null) {\n+            localType = m_provider.getTypeDefinition(elementType);\n+            // if a specified type has been provided by the caller, but the provider cannot resolve\n+            // the type, we need to simply stop, because things are not going to work predictably.\n+            // a non-null elementType *requires* that we end up with non-null localType right here.\n+            if (localType == null) {\n+                throw new AbortException(new SmUndeclaredReferenceException(elementType, null));\n+            }\n+        }\n+        m_text.setLength(0);\n+\n+        final ValidationItem parentItem = m_currentItem;\n+        m_currentItem = parentItem.push(++m_nodeIndex);\n+\n+        // Maintain prefix mapping information.\n+        m_namespaces.pushContext();\n+        if (namespaces.size() > 0) // Optimization.\n+        {\n+            for (final VxMapping<String, String> mapping : namespaces) {\n+                m_namespaces.declarePrefix(mapping.getKey(), mapping.getValue());\n+            }\n+        }\n+\n+        // before dealing with attributes, which may make the localType non-null,\n+        // tweak processContents in the 'parent' (which may be a phantom) of the\n+        // current element's PSVI to lax. use null in savedPC as a sentinel when\n+        // restoring, later.\n+        ProcessContentsMode savedPC = null;\n+        if (localType != null) {\n+            savedPC = m_currentPSVI.getProcessContents();\n+            // set m_currentPSVI process contents to lax, because we have an element type override\n+            // which means that there probably is no element declaration for this element's name.\n+            // unless it's lax, this will cause an error.\n+            m_currentPSVI.setProcessContents(ProcessContentsMode.Lax);\n+        }\n+\n+        // Digest the attributes from the XMLSchema-instance namespace.\n+        m_attributes\n+            .initialize(elementName, m_currentItem, attributes, m_namespaces, documentURI, m_errors,\n+                sdl);\n+        // if we're not operating in caller-overrides-type mode, get the xsi:type override\n+        if (m_attributes.getLocalType() != null) {\n+            localType = m_attributes.getLocalType();\n+        }\n+        final Boolean explicitNil = m_attributes.getLocalNil();\n+\n+        m_currentPSVI = m_mac.startElement(elementName, localType, explicitNil);\n+        // reset processContents in the child, if we relaxed it above, signalled by non-null savedPC\n+        if (savedPC != null) {\n+            m_currentPSVI.setProcessContents(\n+                savedPC); // actually a different ModelPSVI than the one we set lax above\n+        }\n+\n+        m_icm.startElement(m_currentPSVI, m_currentItem, m_errors);\n+\n+        if (m_downstream != null) {\n+            m_downstream.startElement(elementName, m_currentPSVI.getType());\n+\n+            for (final VxMapping<String, String> mapping : namespaces) {\n+                m_downstream.namespace(mapping.getKey(), mapping.getValue());\n+            }\n+        }\n         // The attribute manager validates the attributes and sends them downstream, returning the index of the last\n         // attribute.\n-\t\tif ( (skipContents != null) && (skipContents.size() > 0) && skipContents.contains(elementName) ) // non-null, non-empty\n-\t\t{\n-\t\t    // set skip so that the children will be ignored.\n-\t\t    m_currentPSVI.setProcessContents(ProcessContentsMode.Skip);\n-\t\t    // this little bit is how we convince the attribute manager to ignore the attributes\n-\t\t    // in this type. they'll be passed through as untypedAtomic (potentially a problem if\n-\t\t    // there are attributes that shouldn't be ignored, but we have to do it this way or rewrite\n-\t\t    // attribute manager, which is currently out of scope).\n-\t\t    Type savedType = m_currentPSVI.getType();\n-\t\t    m_currentPSVI.m_type = null;\n-\t\t    m_nodeIndex = m_attributes.attributes(m_currentPSVI, m_currentItem, attributes, m_downstream, m_errors, m_idm, m_icm);\n-\t\t    // the reset may be unnecessary, since we've set skip contents. do it anyway.\n-\t\t    m_currentPSVI.m_type = savedType;\n-\t\t}\n-\t\telse // the common case:\n-\t\t    m_nodeIndex = m_attributes.attributes(m_currentPSVI, m_currentItem, attributes, m_downstream, m_errors, m_idm, m_icm);\n-\t}\n-\n-\t@Override\n-\tpublic void text(final List<? extends A> initialValue) throws IOException, AbortException\n-\t{\n-\t\tm_nodeIndex++;\n-\n-\t\t// Remember that we got a text node.\n-\t\tm_currentItem.m_detectedText = true;\n-\n-\t\tif (m_currentItem.getSuspendChecking())\n-\t\t{\n-\t\t\tif (null != m_downstream)\n-\t\t\t{\n-\t\t\t\tm_downstream.text(initialValue);\n-\t\t\t}\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tswitch (m_currentPSVI.getProcessContents())\n-\t\t{\n-\t\t\tcase Strict:\n-\t\t\tcase Lax:\n-\t\t\t{\n-\t\t\t\tfinal ElementDefinition declaration = m_currentPSVI.getDeclaration();\n-\t\t\t\tif (m_currentPSVI.isNilled())\n-\t\t\t\t{\n-\t\t\t\t\tm_errors.error(new CvcElementUnexpectedChildInNilledElementException(declaration, m_currentItem.getLocation()));\n-\t\t\t\t}\n-\n-\t\t\t\tfinal Type elementType = m_currentPSVI.getType();\n-\t\t\t\tif (null != elementType)\n-\t\t\t\t{\n-\t\t\t\t\tif (elementType instanceof SimpleType)\n-\t\t\t\t\t{\n-\t\t\t\t\t\tfinal SimpleType simpleType = (SimpleType)elementType;\n-\t\t\t\t\t\ttry\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tfinal List<A> actualValue = simpleType.validate(initialValue, m_atomBridge);\n-\n-\t\t\t\t\t\t\tif (null != declaration)\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tcheckValueConstraintForElement(declaration, simpleType, actualValue);\n-\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\tm_idm.text(actualValue, simpleType, m_currentItem, m_errors, m_atomBridge);\n-\t\t\t\t\t\t\tm_icm.text(actualValue, simpleType, m_currentItem, m_nodeIndex, m_atomBridge);\n-\n-\t\t\t\t\t\t\tif (null != m_downstream)\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tm_downstream.text(actualValue);\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tcatch (final DatatypeException e)\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tm_errors.error(new SimpleTypeException(m_atomBridge.getC14NString(initialValue), simpleType, e));\n-\t\t\t\t\t\t\tif (null != m_downstream)\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tm_downstream.text(initialValue);\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\telse\n-\t\t\t\t\t{\n-\t\t\t\t\t\tfinal ComplexType complexType = (ComplexType)elementType;\n-\t\t\t\t\t\tfinal ContentType contentType = complexType.getContentType();\n-\t\t\t\t\t\tswitch (contentType.getKind())\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tcase Simple:\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tfinal SimpleType simpleType = contentType.getSimpleType();\n-\t\t\t\t\t\t\t\ttry\n-\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\tfinal List<A> actualValue = simpleType.validate(initialValue, m_atomBridge);\n-\n-\t\t\t\t\t\t\t\t\tcheckValueConstraintForElement(declaration, simpleType, actualValue);\n-\n-\t\t\t\t\t\t\t\t\tm_idm.text(actualValue, simpleType, m_currentItem, m_errors, m_atomBridge);\n-\t\t\t\t\t\t\t\t\tm_icm.text(actualValue, simpleType, m_currentItem, m_nodeIndex, m_atomBridge);\n-\n-\t\t\t\t\t\t\t\t\tif (null != m_downstream)\n-\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\tm_downstream.text(actualValue);\n-\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\tcatch (final DatatypeException e)\n-\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\tm_errors.error(new SimpleTypeException(m_atomBridge.getC14NString(initialValue), simpleType, e));\n-\t\t\t\t\t\t\t\t\tif (null != m_downstream)\n-\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\tm_downstream.text(initialValue);\n-\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t\tcase ElementOnly:\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tfinal String strval = m_atomBridge.getC14NString(initialValue);\n-\t\t\t\t\t\t\t\tif (!isWhiteSpace(strval))\n-\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\tm_errors.error(new CvcUnexpectedNonWhiteSpaceTextInElementOnlyContentException(m_currentPSVI.getName(), strval, m_currentItem.getLocation()));\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t\tcase Mixed:\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tValidationRules.checkValueConstraintForMixedContent(declaration, m_atomBridge.getC14NString(initialValue), m_currentItem, m_errors, m_atomBridge);\n-\n-\t\t\t\t\t\t\t\tif (null != m_downstream)\n-\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\tm_downstream.text(initialValue);\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t\tcase Empty:\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tm_errors.error(new CvcUnexpectedTextInEmptyContentException(m_currentPSVI.getName(), m_atomBridge.getC14NString(initialValue), m_currentItem.getLocation()));\n-\t\t\t\t\t\t\t\tif (null != m_downstream)\n-\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\tm_downstream.text(initialValue);\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t\tdefault:\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tthrow new AssertionError(contentType.getKind());\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\telse\n-\t\t\t\t{\n-\t\t\t\t\tif (null != m_downstream)\n-\t\t\t\t\t{\n-\t\t\t\t\t\tm_downstream.text(initialValue);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tbreak;\n-\t\t\tcase Skip:\n-\t\t\t{\n-\t\t\t\tif (null != m_downstream)\n-\t\t\t\t{\n-\t\t\t\t\tm_downstream.text(initialValue);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t{\n-\t\t\t\tthrow new AssertionError(m_currentPSVI.getProcessContents());\n-\t\t\t}\n-\t\t}\n-\t}\n-\t\n+        if ((skipContents != null) && (skipContents.size() > 0) &&\n+            skipContents.contains(elementName)) // non-null, non-empty\n+        {\n+            // set skip so that the children will be ignored.\n+            m_currentPSVI.setProcessContents(ProcessContentsMode.Skip);\n+            // this little bit is how we convince the attribute manager to ignore the attributes\n+            // in this type. they'll be passed through as untypedAtomic (potentially a problem if\n+            // there are attributes that shouldn't be ignored, but we have to do it this way or rewrite\n+            // attribute manager, which is currently out of scope).\n+            Type savedType = m_currentPSVI.getType();\n+            m_currentPSVI.m_type = null;\n+            m_nodeIndex = m_attributes\n+                .attributes(m_currentPSVI, m_currentItem, attributes, m_downstream, m_errors, m_idm,\n+                    m_icm);\n+            // the reset may be unnecessary, since we've set skip contents. do it anyway.\n+            m_currentPSVI.m_type = savedType;\n+        } else // the common case:\n+        {\n+            m_nodeIndex = m_attributes\n+                .attributes(m_currentPSVI, m_currentItem, attributes, m_downstream, m_errors, m_idm,\n+                    m_icm);\n+        }\n+    }\n+\n+    @Override\n+    public void text(final List<? extends A> initialValue) throws IOException, AbortException {\n+        m_nodeIndex++;\n+\n+        // Remember that we got a text node.\n+        m_currentItem.m_detectedText = true;\n+\n+        if (m_currentItem.getSuspendChecking()) {\n+            if (null != m_downstream) {\n+                m_downstream.text(initialValue);\n+            }\n+            return;\n+        }\n+\n+        switch (m_currentPSVI.getProcessContents()) {\n+            case Strict:\n+            case Lax: {\n+                final ElementDefinition declaration = m_currentPSVI.getDeclaration();\n+                if (m_currentPSVI.isNilled()) {\n+                    m_errors.error(\n+                        new CvcElementUnexpectedChildInNilledElementException(declaration,\n+                            m_currentItem.getLocation()));\n+                }\n+\n+                final Type elementType = m_currentPSVI.getType();\n+                if (null != elementType) {\n+                    if (elementType instanceof SimpleType) {\n+                        final SimpleType simpleType = (SimpleType) elementType;\n+                        try {\n+                            final List<A> actualValue =\n+                                simpleType.validate(initialValue, m_atomBridge);\n+\n+                            if (null != declaration) {\n+                                checkValueConstraintForElement(declaration, simpleType,\n+                                    actualValue);\n+                            }\n+\n+                            m_idm.text(actualValue, simpleType, m_currentItem, m_errors,\n+                                m_atomBridge);\n+                            m_icm.text(actualValue, simpleType, m_currentItem, m_nodeIndex,\n+                                m_atomBridge);\n+\n+                            if (null != m_downstream) {\n+                                m_downstream.text(actualValue);\n+                            }\n+                        } catch (final DatatypeException e) {\n+                            m_errors.error(\n+                                new SimpleTypeException(m_atomBridge.getC14NString(initialValue),\n+                                    simpleType, e));\n+                            if (null != m_downstream) {\n+                                m_downstream.text(initialValue);\n+                            }\n+                        }\n+                    } else {\n+                        final ComplexType complexType = (ComplexType) elementType;\n+                        final ContentType contentType = complexType.getContentType();\n+                        switch (contentType.getKind()) {\n+                            case Simple: {\n+                                final SimpleType simpleType = contentType.getSimpleType();\n+                                try {\n+                                    final List<A> actualValue =\n+                                        simpleType.validate(initialValue, m_atomBridge);\n+\n+                                    checkValueConstraintForElement(declaration, simpleType,\n+                                        actualValue);\n+\n+                                    m_idm.text(actualValue, simpleType, m_currentItem, m_errors,\n+                                        m_atomBridge);\n+                                    m_icm.text(actualValue, simpleType, m_currentItem, m_nodeIndex,\n+                                        m_atomBridge);\n+\n+                                    if (null != m_downstream) {\n+                                        m_downstream.text(actualValue);\n+                                    }\n+                                } catch (final DatatypeException e) {\n+                                    m_errors.error(new SimpleTypeException(\n+                                        m_atomBridge.getC14NString(initialValue), simpleType, e));\n+                                    if (null != m_downstream) {\n+                                        m_downstream.text(initialValue);\n+                                    }\n+                                }\n+                            }\n+                            break;\n+                            case ElementOnly: {\n+                                final String strval = m_atomBridge.getC14NString(initialValue);\n+                                if (!isWhiteSpace(strval)) {\n+                                    m_errors.error(\n+                                        new CvcUnexpectedNonWhiteSpaceTextInElementOnlyContentException(\n+                                            m_currentPSVI.getName(), strval,\n+                                            m_currentItem.getLocation()));\n+                                }\n+                            }\n+                            break;\n+                            case Mixed: {\n+                                ValidationRules.checkValueConstraintForMixedContent(declaration,\n+                                    m_atomBridge.getC14NString(initialValue), m_currentItem,\n+                                    m_errors, m_atomBridge);\n+\n+                                if (null != m_downstream) {\n+                                    m_downstream.text(initialValue);\n+                                }\n+                            }\n+                            break;\n+                            case Empty: {\n+                                m_errors.error(new CvcUnexpectedTextInEmptyContentException(\n+                                    m_currentPSVI.getName(),\n+                                    m_atomBridge.getC14NString(initialValue),\n+                                    m_currentItem.getLocation()));\n+                                if (null != m_downstream) {\n+                                    m_downstream.text(initialValue);\n+                                }\n+                            }\n+                            break;\n+                            default: {\n+                                throw new AssertionError(contentType.getKind());\n+                            }\n+                        }\n+                    }\n+                } else {\n+                    if (null != m_downstream) {\n+                        m_downstream.text(initialValue);\n+                    }\n+                }\n+            }\n+            break;\n+            case Skip: {\n+                if (null != m_downstream) {\n+                    m_downstream.text(initialValue);\n+                }\n+            }\n+            break;\n+            default: {\n+                throw new AssertionError(m_currentPSVI.getProcessContents());\n+            }\n+        }\n+    }\n+\n     private final AtomBridge<A> m_atomBridge;\n+\n     private AttributeManager<A> m_attributes;\n+\n     private ValidationItem m_currentItem;\n+\n     private ModelPSVI m_currentPSVI;\n+\n     private ComponentProvider m_provider;\n+\n     private Set<QName> skipContents;\n \n     private final ValidationItem m_documentItem;\n+\n     private ModelPSVI m_documentPSVI;\n+\n     // Set by reset method. Preconditions guarantee that it is never null.\n     private VxOutputHandler<A> m_downstream;\n+\n     // private Location m_location;\n     private SchemaExceptionHandler m_errors = SmExceptionThrower.SINGLETON;\n+\n     private final VxSchemaDocumentLocationStrategy sdl;\n \n     private final IdentityConstraintManager m_icm = new IdentityConstraintManager();\n@@ -817,6 +748,7 @@ final class ValidationKernel<A> implements VxValidator<A>, SmExceptionSupplier\n     // Maintain state for each element.\n     // private URI m_baseURI;\n     private ModelAnalyzerImpl m_mac; // Model Analyzer Component\n+\n     private final ValidationPrefixResolver m_namespaces;\n \n     // Index of node within document is used to determine node identity.\n@@ -824,6 +756,7 @@ final class ValidationKernel<A> implements VxValidator<A>, SmExceptionSupplier\n \n     // We must normalize character events into a single text node.\n     private final StringBuilder m_text = new StringBuilder();\n+\n     private URI documentURI;\n \n }\n",
            "diff_size": 785
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/136/ValidationKernel.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/codebuff/136/ValidationKernel.java\nindex 40a7804c48e..e351c915c1b 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/136/ValidationKernel.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/codebuff/136/ValidationKernel.java\n@@ -21,9 +21,7 @@ import java.util.HashSet;\n import java.util.LinkedList;\n import java.util.List;\n import java.util.Set;\n-\n import javax.xml.namespace.QName;\n-\n import org.genxdm.exceptions.PreCondition;\n import org.genxdm.names.NameSource;\n import org.genxdm.processor.w3c.xs.exception.cvc.CvcElementFixedValueOverriddenSimpleException;\n@@ -57,751 +55,729 @@ import org.genxdm.xs.types.Type;\n  * this class is package protected so overall, the validation API is schema model independent. In future, we may try to\n  * create a more abstract kernel.\n  */\n+\n final class ValidationKernel<A> implements VxValidator<A>, SmExceptionSupplier\n {\n-\t// Set by reset method. Preconditions guarantee that it is never null.\n-\t// private final ParticleTerm STRICT_WILDCARD = new StrictWildcard<A>();\n-\n-\tprivate static boolean isWhiteSpace(final String strval)\n-\t{\n-\t\tif (null != strval)\n-\t\t{\n-\t\t\tfinal int n = strval.length();\n-\n-\t\t\tfor (int i = 0; i < n; i++)\n-\t\t\t{\n-\t\t\t\tfinal char ch = strval.charAt(i);\n-\n-\t\t\t\t// The follwing pattern is denormalized for speed.\n-\t\t\t\tif ((ch == 0x20) || (ch == 0x09) || (ch == 0xD) || (ch == 0xA))\n-\t\t\t\t{\n-\t\t\t\t\t// Try the next one, all must be whiteSpace.\n-\t\t\t\t}\n-\t\t\t\telse\n-\t\t\t\t{\n-\t\t\t\t\treturn false;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn true;\n-\t}\n-\n-\tpublic ValidationKernel(final AtomBridge<A> atomBridge, final VxSchemaDocumentLocationStrategy sdl)\n-\t{\n-\t\tm_atomBridge = PreCondition.assertNotNull(atomBridge);\n-\t\tNameSource names = NameSource.SINGLETON;\n-\t\tm_namespaces = new ValidationPrefixResolver(names);\n-\t\tm_currentItem = m_documentItem = new ValidationItem();\n-\t\t// A strict start is necessary to ensure that the root element has a declaration.\n-\t\t// However, the specification does not seem very clear on what should be the starting mode.\n-\t\tthis.sdl = sdl;\n-\t}\n-\n-\t@Override\n-\tpublic void characters(final char[] ch, final int start, final int length)\n-\t{\n-\t\tm_text.append(ch, start, length);\n-\t}\n-\n-\tprivate void checkValueConstraintForElement(final ElementDefinition elementDeclaration, final SimpleType simpleType, final List<? extends A> actualValue) throws AbortException\n-\t{\n-\t\tfinal ValueConstraint valueConstraint = elementDeclaration.getValueConstraint();\n-\t\tif (null != valueConstraint)\n-\t\t{\n-\t\t\tswitch (valueConstraint.getVariety())\n-\t\t\t{\n-\t\t\t\tcase Fixed:\n-\t\t\t\t{\n-\t\t\t\t\tfinal List<A> initialFixed = valueConstraint.getValue(m_atomBridge);\n-\n-\t\t\t\t\ttry\n-\t\t\t\t\t{\n-\t\t\t\t\t\tfinal List<A> actualFixed = simpleType.validate(initialFixed, m_atomBridge);\n-\t\t\t\t\t\tif (!ValidationSupport.equalValues(actualFixed, actualValue))\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tfinal String fixedC14N = m_atomBridge.getC14NString(actualFixed);\n-\t\t\t\t\t\t\tfinal String actualC14N = m_atomBridge.getC14NString(actualValue);\n-\t\t\t\t\t\t\tm_errors.error(new CvcElementFixedValueOverriddenSimpleException(elementDeclaration, fixedC14N, actualC14N, m_currentItem.getLocation()));\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\tcatch (final DatatypeException e)\n-\t\t\t\t\t{\n-\t\t\t\t\t\tfinal String lexicalValue = m_atomBridge.getC14NString(initialFixed);\n-\t\t\t\t\t\tm_errors.error(new SimpleTypeException(lexicalValue, simpleType, e));\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tbreak;\n-\t\t\t\tcase Default:\n-\t\t\t\t{\n-\t\t\t\t\t// No problem.\n-\t\t\t\t}\n-\t\t\t\tbreak;\n-\t\t\t\tdefault:\n-\t\t\t\t{\n-\t\t\t\t\tthrow new AssertionError(valueConstraint.getVariety());\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void endDocument() throws IOException, AbortException\n-\t{\n-\t\tm_mac.endDocument();\n-\n-\t\t// Check for dangling IDREFs here.\n-\t\tm_idm.reportDanglingIdRefs(m_errors);\n-\n-\t\tif (null != m_downstream)\n-\t\t{\n-\t\t\tm_downstream.endDocument();\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic VxPSVI endElement() throws IOException, AbortException\n-\t{\n-\t\tif (m_text.length() > 0)\n-\t\t{\n-\t\t\ttry\n-\t\t\t{\n-\t\t\t\thandleText(m_text.toString());\n-\t\t\t}\n-\t\t\tfinally\n-\t\t\t{\n-\t\t\t\tm_text.setLength(0);\n-\t\t\t}\n-\t\t}\n-\n-\t\ttry\n-\t\t{\n-\t\t\tif (!m_currentItem.m_detectedText)\n-\t\t\t{\n-\t\t\t\thandleNoTextCalls();\n-\t\t\t}\n-\n-\t\t\tfinal VxPSVI psvi = m_mac.endElement();\n-\n-\t\t\tm_icm.endElement(m_currentPSVI, m_currentItem);\n-\n-\t\t\treturn psvi;\n-\t\t}\n-\t\tfinally\n-\t\t{\n-\t\t\tm_currentItem = m_currentItem.pop();\n-\t\t\tm_currentPSVI = m_currentPSVI.getParent();\n-\n-\t\t\t// Maintain prefix mapping information.\n-\t\t\tm_namespaces.popContext();\n-\n-\t\t\tif (null != m_downstream)\n-\t\t\t{\n-\t\t\t\tm_downstream.endElement();\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate void handleNoTextCalls() throws IOException, AbortException\n-\t{\n-\t\tfinal Type elementType = m_currentPSVI.getType();\n-\t\tif (null != elementType)\n-\t\t{\n-\t\t\tif (elementType instanceof SimpleType)\n-\t\t\t{\n-\t\t\t\thandleNoTextCallsForSimpleContentModel((SimpleType)elementType);\n-\t\t\t}\n-\t\t\telse\n-\t\t\t{\n-\t\t\t\tfinal ComplexType complexType = (ComplexType)elementType;\n-\t\t\t\tfinal ContentType contentType = complexType.getContentType();\n-\t\t\t\tswitch (contentType.getKind())\n-\t\t\t\t{\n-\t\t\t\t\tcase Simple:\n-\t\t\t\t\t{\n-\t\t\t\t\t\thandleNoTextCallsForSimpleContentModel(contentType.getSimpleType());\n-\t\t\t\t\t}\n-\t\t\t\t\tbreak;\n-\t\t\t\t\tcase Empty:\n-\t\t\t\t\tcase ElementOnly:\n-\t\t\t\t\tcase Mixed:\n-\t\t\t\t\t{\n-\t\t\t\t\t\t// Do nothing\n-\t\t\t\t\t}\n-\t\t\t\t\tbreak;\n-\t\t\t\t\tdefault:\n-\t\t\t\t\t{\n-\t\t\t\t\t\tthrow new AssertionError(contentType.getKind());\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate void handleNoTextCallsForSimpleContentModel(final SimpleType simpleType) throws IOException, AbortException\n-\t{\n-\t\tif (m_currentPSVI.isNilled())\n-\t\t{\n-\t\t\t// OK\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\t// any default or fixed values.\n-\t\t\tfinal ElementDefinition declaration = m_currentPSVI.getDeclaration();\n-\t\t\tfinal ValueConstraint valueConstraint = (null != declaration) ? declaration.getValueConstraint() : null;\n-\t\t\tif (null != valueConstraint)\n-\t\t\t{\n-\t\t\t\tswitch (valueConstraint.getVariety())\n-\t\t\t\t{\n-\t\t\t\t\tcase Fixed:\n-\t\t\t\t\tcase Default:\n-\t\t\t\t\t{\n-\t\t\t\t\t\tfinal List<A> initialValue = valueConstraint.getValue(m_atomBridge);\n-\t\t\t\t\t\ttry\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tfinal List<A> actualValue = simpleType.validate(initialValue, m_atomBridge);\n-\n-\t\t\t\t\t\t\tm_idm.text(actualValue, simpleType, m_currentItem, m_errors, m_atomBridge);\n-\t\t\t\t\t\t\tm_icm.text(actualValue, simpleType, m_currentItem, m_nodeIndex, m_atomBridge);\n-\n-\t\t\t\t\t\t\tif (null != m_downstream)\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tm_downstream.text(actualValue);\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tcatch (final DatatypeException e)\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tfinal String lexicalValue = m_atomBridge.getC14NString(initialValue);\n-\t\t\t\t\t\t\tm_errors.error(new SimpleTypeException(lexicalValue, simpleType, e));\n-\n-\t\t\t\t\t\t\tm_idm.text(initialValue, simpleType, m_currentItem, m_errors, m_atomBridge);\n-\t\t\t\t\t\t\tm_icm.text(initialValue, simpleType, m_currentItem, m_nodeIndex, m_atomBridge);\n-\n-\t\t\t\t\t\t\tif (null != m_downstream)\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tm_downstream.text(initialValue);\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\tbreak;\n-\t\t\t\t\tdefault:\n-\t\t\t\t\t{\n-\t\t\t\t\t\tthrow new AssertionError(valueConstraint.getVariety());\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\telse\n-\t\t\t{\n-\t\t\t\t// If no value given above then call the validator with an empty string\n-\t\t\t\t// which will throw an exception if having no text is a problem.\n-\t\t\t\ttry\n-\t\t\t\t{\n-\t\t\t\t\tfinal List<A> actualValue = simpleType.validate(\"\", m_atomBridge);\n-\n-\t\t\t\t\tm_idm.text(actualValue, simpleType, m_currentItem, m_errors, m_atomBridge);\n-\t\t\t\t\tm_icm.text(actualValue, simpleType, m_currentItem, m_nodeIndex, m_atomBridge);\n-\n-\t\t\t\t\tif (null != m_downstream)\n-\t\t\t\t\t{\n-\t\t\t\t\t\tm_downstream.text(actualValue);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tcatch (final DatatypeException e)\n-\t\t\t\t{\n-\t\t\t\t\tm_errors.error(new SimpleTypeException(\"\", simpleType, e));\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate void handleText(final String initialValue) throws IOException, AbortException\n-\t{\n-\t\tm_nodeIndex++;\n-\n-\t\t// Remember that we got a text node.\n-\t\tm_currentItem.m_detectedText = true;\n-\n-\t\tif (m_currentItem.getSuspendChecking())\n-\t\t{\n-\t\t\tif (null != m_downstream)\n-\t\t\t{\n-\t\t\t\tm_downstream.text(initialValue);\n-\t\t\t}\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tswitch (m_currentPSVI.getProcessContents())\n-\t\t{\n-\t\t\tcase Strict:\n-\t\t\tcase Lax:\n-\t\t\t{\n-\t\t\t\tfinal ElementDefinition declaration = m_currentPSVI.getDeclaration();\n-\t\t\t\tif (m_currentPSVI.isNilled() && (null != declaration))\n-\t\t\t\t{\n-\t\t\t\t\tm_errors.error(new CvcElementUnexpectedChildInNilledElementException(declaration, m_currentItem.getLocation()));\n-\t\t\t\t}\n-\n-\t\t\t\tfinal Type elementType = m_currentPSVI.getType();\n-\t\t\t\tif (null != elementType)\n-\t\t\t\t{\n-\t\t\t\t\tif (elementType instanceof SimpleType)\n-\t\t\t\t\t{\n-\t\t\t\t\t    if (elementType instanceof SimpleUrType)\n+    // Set by reset method. Preconditions guarantee that it is never null.\n+    // private final ParticleTerm STRICT_WILDCARD = new StrictWildcard<A>();\n+    private static boolean isWhiteSpace(final String strval)\n+    {\n+        if (null != strval)\n+        {\n+            final int n = strval.length();\n+            for (int i = 0; i < n; i++)\n+            {\n+                final char ch = strval.charAt(i);\n+\n+                // The follwing pattern is denormalized for speed.\n+                if ((ch == 0x20) || (ch == 0x09) || (ch == 0xD) || (ch == 0xA))\n+                {\n+                    // Try the next one, all must be whiteSpace.\n+\n+                }\n+                else\n+                {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    public ValidationKernel(final AtomBridge<A> atomBridge, final VxSchemaDocumentLocationStrategy sdl)\n+    {\n+        m_atomBridge = PreCondition.assertNotNull(atomBridge);\n+        NameSource names = NameSource.SINGLETON;\n+        m_namespaces = new ValidationPrefixResolver(names);\n+        m_currentItem = m_documentItem = new ValidationItem();\n+        // A strict start is necessary to ensure that the root element has a declaration.\n+        // However, the specification does not seem very clear on what should be the starting mode.\n+        this.sdl = sdl;\n+    }\n+\n+    @Override\n+    public void characters(final char[] ch, final int start, final int length)\n+    {\n+        m_text.append(ch, start, length);\n+    }\n+\n+    private void checkValueConstraintForElement(final ElementDefinition elementDeclaration, final SimpleType simpleType, final List<? extends A> actualValue)\n+        throws AbortException\n+    {\n+        final ValueConstraint valueConstraint = elementDeclaration.getValueConstraint();\n+        if (null != valueConstraint)\n+        {\n+            switch (valueConstraint.getVariety())\n+            {\n+                case Fixed:\n+                {\n+                    final List<A> initialFixed = valueConstraint.getValue(m_atomBridge);\n+                    try\n+                    {\n+                        final List<A> actualFixed = simpleType.validate(initialFixed, m_atomBridge);\n+                        if (!ValidationSupport.equalValues(actualFixed, actualValue))\n+                        {\n+                            final String fixedC14N = m_atomBridge.getC14NString(actualFixed);\n+                            final String actualC14N = m_atomBridge.getC14NString(actualValue);\n+                            m_errors.error(new CvcElementFixedValueOverriddenSimpleException(elementDeclaration, fixedC14N, actualC14N, m_currentItem.getLocation()));\n+                        }\n+                    }\n+                    catch (final DatatypeException e)\n+                    {\n+                        final String lexicalValue = m_atomBridge.getC14NString(initialFixed);\n+                        m_errors.error(new SimpleTypeException(lexicalValue, simpleType, e));\n+                    }\n+                }\n+                break;\n+                case Default:\n+                {\n+                    // No problem.\n+\n+                }\n+                break;\n+                default:\n+                {\n+                    throw new AssertionError(valueConstraint.getVariety());\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void endDocument()\n+        throws IOException, AbortException\n+    {\n+        m_mac.endDocument();\n+\n+        // Check for dangling IDREFs here.\n+        m_idm.reportDanglingIdRefs(m_errors);\n+        if (null != m_downstream)\n+        {\n+            m_downstream.endDocument();\n+        }\n+    }\n+\n+    @Override\n+    public VxPSVI endElement()\n+        throws IOException, AbortException\n+    {\n+        if (m_text.length() > 0)\n+        {\n+            try\n+            {\n+                handleText(m_text.toString());\n+            }\n+            finally\n+            {\n+                m_text.setLength(0);\n+            }\n+        }\n+        try\n+        {\n+            if (!m_currentItem.m_detectedText)\n+            {\n+                handleNoTextCalls();\n+            }\n+\n+            final VxPSVI psvi = m_mac.endElement();\n+            m_icm.endElement(m_currentPSVI, m_currentItem);\n+            return psvi;\n+        }\n+        finally\n+        {\n+            m_currentItem = m_currentItem.pop();\n+            m_currentPSVI = m_currentPSVI.getParent();\n+\n+            // Maintain prefix mapping information.\n+            m_namespaces.popContext();\n+            if (null != m_downstream)\n+            {\n+                m_downstream.endElement();\n+            }\n+        }\n+    }\n+\n+    private void handleNoTextCalls()\n+        throws IOException, AbortException\n+    {\n+        final Type elementType = m_currentPSVI.getType();\n+        if (null != elementType)\n+        {\n+            if (elementType instanceof SimpleType)\n+            {\n+                handleNoTextCallsForSimpleContentModel((SimpleType)elementType);\n+            }\n+            else\n+            {\n+                final ComplexType complexType = (ComplexType)elementType;\n+                final ContentType contentType = complexType.getContentType();\n+\n+                switch (contentType.getKind())\n+                {\n+                    case Simple:\n+                    {\n+                        handleNoTextCallsForSimpleContentModel(contentType.getSimpleType());\n+                    }\n+                    break;\n+                    case Empty:\n+                    case ElementOnly:\n+                    case Mixed:\n+                    {\n+                        // Do nothing\n+\n+                    }\n+                    break;\n+                    default:\n+                    {\n+                        throw new AssertionError(contentType.getKind());\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void handleNoTextCallsForSimpleContentModel(final SimpleType simpleType)\n+        throws IOException, AbortException\n+    {\n+        if (m_currentPSVI.isNilled())\n+        {\n+            // OK\n+\n+        }\n+        else\n+        {\n+            // any default or fixed values.\n+            final ElementDefinition declaration = m_currentPSVI.getDeclaration();\n+            final ValueConstraint valueConstraint = (null != declaration) ? declaration.getValueConstraint() : null;\n+            if (null != valueConstraint)\n+            {\n+                switch (valueConstraint.getVariety())\n+                {\n+                    case Fixed:\n+                    case Default:\n+                    {\n+                        final List<A> initialValue = valueConstraint.getValue(m_atomBridge);\n+                        try\n+                        {\n+                            final List<A> actualValue = simpleType.validate(initialValue, m_atomBridge);\n+                            m_idm.text(actualValue, simpleType, m_currentItem, m_errors, m_atomBridge);\n+                            m_icm.text(actualValue, simpleType, m_currentItem, m_nodeIndex, m_atomBridge);\n+                            if (null != m_downstream)\n+                            {\n+                                m_downstream.text(actualValue);\n+                            }\n+                        }\n+                        catch (final DatatypeException e)\n                         {\n+                            final String lexicalValue = m_atomBridge.getC14NString(initialValue);\n+                            m_errors.error(new SimpleTypeException(lexicalValue, simpleType, e));\n+                            m_idm.text(initialValue, simpleType, m_currentItem, m_errors, m_atomBridge);\n+                            m_icm.text(initialValue, simpleType, m_currentItem, m_nodeIndex, m_atomBridge);\n                             if (null != m_downstream)\n                             {\n                                 m_downstream.text(initialValue);\n                             }\n                         }\n-\t\t\t\t\t    else if (elementType instanceof SimpleType)\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tfinal SimpleType simpleType = (SimpleType)elementType;\n-\t\t\t\t\t\t\ttry\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tfinal List<A> actualValue = simpleType.validate(initialValue, m_atomBridge);\n-\n-\t\t\t\t\t\t\t\tif (null != declaration)\n-\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\tcheckValueConstraintForElement(declaration, simpleType, actualValue);\n-\t\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\t\tm_idm.text(actualValue, simpleType, m_currentItem, m_errors, m_atomBridge);\n-\t\t\t\t\t\t\t\tm_icm.text(actualValue, simpleType, m_currentItem, m_nodeIndex, m_atomBridge);\n-\n-\t\t\t\t\t\t\t\tif (null != m_downstream)\n-\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\tm_downstream.text(actualValue);\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tcatch (final DatatypeException e)\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tm_errors.error(new SimpleTypeException(initialValue, simpleType, e));\n-\t\t\t\t\t\t\t\tif (null != m_downstream)\n-\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\tm_downstream.text(initialValue);\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\telse\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tthrow new AssertionError(elementType);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\telse if (elementType instanceof ComplexType)\n-\t\t\t\t\t{\n-\t\t\t\t\t\tfinal ComplexType complexType = (ComplexType)elementType;\n-\t\t\t\t\t\tfinal ContentType contentType = complexType.getContentType();\n-\t\t\t\t\t\tswitch (contentType.getKind())\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tcase Simple:\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tfinal SimpleType simpleType = contentType.getSimpleType();\n-\t\t\t\t\t\t\t\ttry\n-\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\tfinal List<A> actualValue = simpleType.validate(initialValue, m_atomBridge);\n-\n-\t\t\t\t\t\t\t\t\tif (null != declaration)\n-\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\tcheckValueConstraintForElement(declaration, simpleType, actualValue);\n-\t\t\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\t\t\tm_idm.text(actualValue, simpleType, m_currentItem, m_errors, m_atomBridge);\n-\t\t\t\t\t\t\t\t\tm_icm.text(actualValue, simpleType, m_currentItem, m_nodeIndex, m_atomBridge);\n-\n-\t\t\t\t\t\t\t\t\tif (null != m_downstream)\n-\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\tm_downstream.text(actualValue);\n-\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\tcatch (final DatatypeException e)\n-\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\tm_errors.error(new SimpleTypeException(initialValue, simpleType, e));\n-\t\t\t\t\t\t\t\t\tif (null != m_downstream)\n-\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\tm_downstream.text(initialValue);\n-\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t\tcase ElementOnly:\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tif (!isWhiteSpace(initialValue))\n-\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\tm_errors.error(new CvcUnexpectedNonWhiteSpaceTextInElementOnlyContentException(m_currentPSVI.getName(), initialValue, m_currentItem.getLocation()));\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t\tcase Mixed:\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tif (null != declaration)\n-\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\tValidationRules.checkValueConstraintForMixedContent(declaration, initialValue, m_currentItem, m_errors, m_atomBridge);\n-\t\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\t\tif (null != m_downstream)\n-\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\tm_downstream.text(initialValue);\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t\tcase Empty:\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tm_errors.error(new CvcUnexpectedTextInEmptyContentException(m_currentPSVI.getName(), initialValue, m_currentItem.getLocation()));\n-\t\t\t\t\t\t\t\tif (null != m_downstream)\n-\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\tm_downstream.text(initialValue);\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t\tdefault:\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tthrow new AssertionError(contentType.getKind());\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\telse\n-\t\t\t\t\t{\n-\t\t\t\t\t\tthrow new AssertionError(elementType);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\telse\n-\t\t\t\t{\n-\t\t\t\t\tif (null != m_downstream)\n-\t\t\t\t\t{\n-\t\t\t\t\t\tm_downstream.text(initialValue);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tbreak;\n-\t\t\tcase Skip:\n-\t\t\t{\n-\t\t\t\tif (null != m_downstream)\n-\t\t\t\t{\n-\t\t\t\t\tm_downstream.text(initialValue);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t{\n-\t\t\t\tthrow new AssertionError(m_currentPSVI.getProcessContents());\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void reset()\n-\t{\n-\t    if (m_namespaces != null)\n-\t        m_namespaces.reset();\n-\t    if (m_attributes != null)\n-\t        m_attributes.reset();\n-\t\tm_nodeIndex = -1;\n-\t\tif (m_icm != null)\n-\t\t    m_icm.reset();\n-\t\tskipContents = null; // null is a better sentinel than empty\n-\t}\n-\t\n-\t@Override\n-\tpublic void setComponentProvider(ComponentProvider provider)\n-\t{\n-\t    m_provider = provider;\n-\t    ValidationCache cache = new ValidationCache();\n+                    }\n+                    break;\n+                    default:\n+                    {\n+                        throw new AssertionError(valueConstraint.getVariety());\n+                    }\n+                }\n+            }\n+            else\n+            {\n+                // If no value given above then call the validator with an empty string\n+                // which will throw an exception if having no text is a problem.\n+                try\n+                {\n+                    final List<A> actualValue = simpleType.validate(\"\", m_atomBridge);\n+                    m_idm.text(actualValue, simpleType, m_currentItem, m_errors, m_atomBridge);\n+                    m_icm.text(actualValue, simpleType, m_currentItem, m_nodeIndex, m_atomBridge);\n+                    if (null != m_downstream)\n+                    {\n+                        m_downstream.text(actualValue);\n+                    }\n+                }\n+                catch (final DatatypeException e)\n+                {\n+                    m_errors.error(new SimpleTypeException(\"\", simpleType, e));\n+                }\n+            }\n+        }\n+    }\n+\n+    private void handleText(final String initialValue)\n+        throws IOException, AbortException\n+    {\n+        m_nodeIndex++;\n+\n+        // Remember that we got a text node.\n+        m_currentItem.m_detectedText = true;\n+        if (m_currentItem.getSuspendChecking())\n+        {\n+            if (null != m_downstream)\n+            {\n+                m_downstream.text(initialValue);\n+            }\n+            return;\n+        }\n+        switch (m_currentPSVI.getProcessContents())\n+        {\n+            case Strict:\n+            case Lax:\n+            {\n+                final ElementDefinition declaration = m_currentPSVI.getDeclaration();\n+                if (m_currentPSVI.isNilled() && (null != declaration))\n+                {\n+                    m_errors.error(new CvcElementUnexpectedChildInNilledElementException(declaration, m_currentItem.getLocation()));\n+                }\n+\n+                final Type elementType = m_currentPSVI.getType();\n+                if (null != elementType)\n+                {\n+                    if (elementType instanceof SimpleType)\n+                    {\n+                        if (elementType instanceof SimpleUrType)\n+                        {\n+                            if (null != m_downstream)\n+                            {\n+                                m_downstream.text(initialValue);\n+                            }\n+                        }\n+                        else if (elementType instanceof SimpleType)\n+                        {\n+                            final SimpleType simpleType = (SimpleType)elementType;\n+                            try\n+                            {\n+                                final List<A> actualValue = simpleType.validate(initialValue, m_atomBridge);\n+                                if (null != declaration)\n+                                {\n+                                    checkValueConstraintForElement(declaration, simpleType, actualValue);\n+                                }\n+                                m_idm.text(actualValue, simpleType, m_currentItem, m_errors, m_atomBridge);\n+                                m_icm.text(actualValue, simpleType, m_currentItem, m_nodeIndex, m_atomBridge);\n+                                if (null != m_downstream)\n+                                {\n+                                    m_downstream.text(actualValue);\n+                                }\n+                            }\n+                            catch (final DatatypeException e)\n+                            {\n+                                m_errors.error(new SimpleTypeException(initialValue, simpleType, e));\n+                                if (null != m_downstream)\n+                                {\n+                                    m_downstream.text(initialValue);\n+                                }\n+                            }\n+                        }\n+                        else\n+                        {\n+                            throw new AssertionError(elementType);\n+                        }\n+                    }\n+                    else if (elementType instanceof ComplexType)\n+                    {\n+                        final ComplexType complexType = (ComplexType)elementType;\n+                        final ContentType contentType = complexType.getContentType();\n+\n+                        switch (contentType.getKind())\n+                        {\n+                            case Simple:\n+                            {\n+                                final SimpleType simpleType = contentType.getSimpleType();\n+                                try\n+                                {\n+                                    final List<A> actualValue = simpleType.validate(initialValue, m_atomBridge);\n+                                    if (null != declaration)\n+                                    {\n+                                        checkValueConstraintForElement(declaration, simpleType, actualValue);\n+                                    }\n+                                    m_idm.text(actualValue, simpleType, m_currentItem, m_errors, m_atomBridge);\n+                                    m_icm.text(actualValue, simpleType, m_currentItem, m_nodeIndex, m_atomBridge);\n+                                    if (null != m_downstream)\n+                                    {\n+                                        m_downstream.text(actualValue);\n+                                    }\n+                                }\n+                                catch (final DatatypeException e)\n+                                {\n+                                    m_errors.error(new SimpleTypeException(initialValue, simpleType, e));\n+                                    if (null != m_downstream)\n+                                    {\n+                                        m_downstream.text(initialValue);\n+                                    }\n+                                }\n+                            }\n+                            break;\n+                            case ElementOnly:\n+                            {\n+                                if (!isWhiteSpace(initialValue))\n+                                {\n+                                    m_errors.error(new CvcUnexpectedNonWhiteSpaceTextInElementOnlyContentException(m_currentPSVI.getName(),\n+                                        initialValue,\n+                                            m_currentItem.getLocation()));\n+                                }\n+                            }\n+                            break;\n+                            case Mixed:\n+                            {\n+                                if (null != declaration)\n+                                {\n+                                    ValidationRules.checkValueConstraintForMixedContent(declaration, initialValue, m_currentItem, m_errors, m_atomBridge);\n+                                }\n+                                if (null != m_downstream)\n+                                {\n+                                    m_downstream.text(initialValue);\n+                                }\n+                            }\n+                            break;\n+                            case Empty:\n+                            {\n+                                m_errors.error(new CvcUnexpectedTextInEmptyContentException(m_currentPSVI.getName(),\n+                                    initialValue,\n+                                        m_currentItem.getLocation()));\n+                                if (null != m_downstream)\n+                                {\n+                                    m_downstream.text(initialValue);\n+                                }\n+                            }\n+                            break;\n+                            default:\n+                            {\n+                                throw new AssertionError(contentType.getKind());\n+                            }\n+                        }\n+                    }\n+                    else\n+                    {\n+                        throw new AssertionError(elementType);\n+                    }\n+                }\n+                else\n+                {\n+                    if (null != m_downstream)\n+                    {\n+                        m_downstream.text(initialValue);\n+                    }\n+                }\n+            }\n+            break;\n+            case Skip:\n+            {\n+                if (null != m_downstream)\n+                {\n+                    m_downstream.text(initialValue);\n+                }\n+            }\n+            break;\n+            default:\n+            {\n+                throw new AssertionError(m_currentPSVI.getProcessContents());\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void reset()\n+    {\n+        if (m_namespaces != null)\n+            m_namespaces.reset();\n+        if (m_attributes != null)\n+            m_attributes.reset();\n+        m_nodeIndex = -1;\n+        if (m_icm != null)\n+            m_icm.reset();\n+        skipContents = null; // null is a better sentinel than empty\n+    }\n+\n+    @Override\n+    public void setComponentProvider(ComponentProvider provider)\n+    {\n+        m_provider = provider;\n+        ValidationCache cache = new ValidationCache();\n         m_attributes = new AttributeManager<A>(m_provider, m_atomBridge);\n         m_currentPSVI = m_documentPSVI = new ModelPSVI(ProcessContentsMode.Strict, m_provider, cache);\n-\n         m_mac = new ModelAnalyzerImpl(m_provider, cache);\n         if (m_errors != null)\n             m_mac.setExceptionHandler(m_errors);\n-\t}\n-\t\n-\t@Override\n-\tpublic void setExceptionHandler(final SchemaExceptionHandler handler)\n-\t{\n-\t\tm_errors = PreCondition.assertArgumentNotNull(handler, \"handler\");\n-\t\tif (m_mac != null)\n-\t\t    m_mac.setExceptionHandler(handler);\n-\t}\n-\t\n-\t@Override\n-\tpublic void setIgnoredElements(Iterable<QName> toSkip)\n-\t{\n-\t    if (skipContents == null)\n-\t        skipContents = new HashSet<QName>();\n-\t    skipContents.clear();\n-\t    for (QName name : toSkip)\n-\t        skipContents.add(name);\n-\t}\n-\n-\t@Override\n-\tpublic void setOutputHandler(final VxOutputHandler<A> handler)\n-\t{\n-\t\tm_downstream = PreCondition.assertArgumentNotNull(handler, \"handler\");\n-\t}\n-\n-\t@Override\n-\tpublic void startDocument(final URI documentURI) throws IOException\n-\t{\n-\t\tthis.documentURI = documentURI;\n-\n-\t\tm_currentPSVI = m_documentPSVI;\n-\t\tm_currentItem = m_documentItem;\n-\t\tm_mac.startDocument();\n-\n-\t\tm_nodeIndex = 0; // The document node gets to be the zeroth index.\n-\n-\t\tm_idm.reset();\n-\n-\t\tif (null != m_downstream)\n-\t\t{\n-\t\t\tm_downstream.startDocument();\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void startElement(final QName elementName, final LinkedList<VxMapping<String, String>> namespaces, final LinkedList<VxMapping<QName, String>> attributes, QName elementType) \n-\t    throws IOException, AbortException\n-\t{\n-\t    Type localType = null;\n-\t    if (elementType != null)\n-\t    {\n-\t        localType = m_provider.getTypeDefinition(elementType);\n-\t        // if a specified type has been provided by the caller, but the provider cannot resolve\n-\t        // the type, we need to simply stop, because things are not going to work predictably.\n-\t        // a non-null elementType *requires* that we end up with non-null localType right here.\n-\t        if (localType == null)\n-\t            throw new AbortException(new SmUndeclaredReferenceException(elementType, null));\n-\t    }\n-\t\tm_text.setLength(0);\n-\n-\t\tfinal ValidationItem parentItem = m_currentItem;\n-\t\tm_currentItem = parentItem.push(++m_nodeIndex);\n-\n-\t\t// Maintain prefix mapping information.\n-\t\tm_namespaces.pushContext();\n-\t\tif (namespaces.size() > 0) // Optimization.\n-\t\t{\n-\t\t\tfor (final VxMapping<String, String> mapping : namespaces)\n-\t\t\t{\n-\t\t\t\tm_namespaces.declarePrefix(mapping.getKey(), mapping.getValue());\n-\t\t\t}\n-\t\t}\n-\n-\t\t// before dealing with attributes, which may make the localType non-null,\n-\t\t// tweak processContents in the 'parent' (which may be a phantom) of the\n-\t\t// current element's PSVI to lax. use null in savedPC as a sentinel when\n-\t\t// restoring, later.\n-\t\tProcessContentsMode savedPC = null;\n-\t\tif (localType != null)\n-\t\t{\n-\t\t    savedPC = m_currentPSVI.getProcessContents();\n-\t\t    // set m_currentPSVI process contents to lax, because we have an element type override\n-\t\t    // which means that there probably is no element declaration for this element's name.\n-\t\t    // unless it's lax, this will cause an error.\n-\t\t    m_currentPSVI.setProcessContents(ProcessContentsMode.Lax);\n-\t\t}\n-\t\t\n-\t\t// Digest the attributes from the XMLSchema-instance namespace.\n-\t\tm_attributes.initialize(elementName, m_currentItem, attributes, m_namespaces, documentURI, m_errors, sdl);\n-\t\t// if we're not operating in caller-overrides-type mode, get the xsi:type override\n-\t\tif (m_attributes.getLocalType() != null)\n-\t\t    localType = m_attributes.getLocalType();\n-\t\tfinal Boolean explicitNil = m_attributes.getLocalNil();\n-\n-\t\tm_currentPSVI = m_mac.startElement(elementName, localType, explicitNil);\n-\t\t// reset processContents in the child, if we relaxed it above, signalled by non-null savedPC\n-\t\tif (savedPC != null)\n-\t\t    m_currentPSVI.setProcessContents(savedPC); // actually a different ModelPSVI than the one we set lax above\n-\n-\t\tm_icm.startElement(m_currentPSVI, m_currentItem, m_errors);\n-\n-\t\tif (m_downstream != null)\n-\t\t{\n-\t\t\tm_downstream.startElement(elementName, m_currentPSVI.getType());\n-\n-\t\t\tfor (final VxMapping<String, String> mapping : namespaces)\n-\t\t\t{\n-\t\t\t\tm_downstream.namespace(mapping.getKey(), mapping.getValue());\n-\t\t\t}\n-\t\t}\n+    }\n+\n+    @Override\n+    public void setExceptionHandler(final SchemaExceptionHandler handler)\n+    {\n+        m_errors = PreCondition.assertArgumentNotNull(handler, \"handler\");\n+        if (m_mac != null)\n+            m_mac.setExceptionHandler(handler);\n+    }\n+\n+    @Override\n+    public void setIgnoredElements(Iterable<QName> toSkip)\n+    {\n+        if (skipContents == null)\n+            skipContents = new HashSet<QName>();\n+        skipContents.clear();\n+        for (QName name : toSkip)\n+            skipContents.add(name);\n+    }\n+\n+    @Override\n+    public void setOutputHandler(final VxOutputHandler<A> handler)\n+    {\n+        m_downstream = PreCondition.assertArgumentNotNull(handler, \"handler\");\n+    }\n+\n+    @Override\n+    public void startDocument(final URI documentURI)\n+        throws IOException\n+    {\n+        this.documentURI = documentURI;\n+        m_currentPSVI = m_documentPSVI;\n+        m_currentItem = m_documentItem;\n+        m_mac.startDocument();\n+        m_nodeIndex = 0; // The document node gets to be the zeroth index.\n+        m_idm.reset();\n+        if (null != m_downstream)\n+        {\n+            m_downstream.startDocument();\n+        }\n+    }\n+\n+    @Override\n+    public void startElement(final QName elementName, final LinkedList<VxMapping<String, String>> namespaces, final LinkedList<VxMapping<QName, String>> attributes, QName elementType)\n+        throws IOException, AbortException\n+    {\n+        Type localType = null;\n+        if (elementType != null)\n+        {\n+            localType = m_provider.getTypeDefinition(elementType);\n+            // if a specified type has been provided by the caller, but the provider cannot resolve\n+            // the type, we need to simply stop, because things are not going to work predictably.\n+            // a non-null elementType *requires* that we end up with non-null localType right here.\n+            if (localType == null)\n+                throw new AbortException(new SmUndeclaredReferenceException(elementType, null));\n+        }\n+        m_text.setLength(0);\n+\n+        final ValidationItem parentItem = m_currentItem;\n+        m_currentItem = parentItem.push(++m_nodeIndex);\n+\n+        // Maintain prefix mapping information.\n+        m_namespaces.pushContext();\n+        if (namespaces.size() > 0) // Optimization.\n+        {\n+            for (final VxMapping<String, String> mapping : namespaces)\n+            {\n+                m_namespaces.declarePrefix(mapping.getKey(), mapping.getValue());\n+            }\n+        }\n+\n+        // before dealing with attributes, which may make the localType non-null,\n+        // tweak processContents in the 'parent' (which may be a phantom) of the\n+        // current element's PSVI to lax. use null in savedPC as a sentinel when\n+        // restoring, later.\n+        ProcessContentsMode savedPC = null;\n+        if (localType != null)\n+        {\n+            savedPC = m_currentPSVI.getProcessContents();\n+            // set m_currentPSVI process contents to lax, because we have an element type override\n+            // which means that there probably is no element declaration for this element's name.\n+            // unless it's lax, this will cause an error.\n+            m_currentPSVI.setProcessContents(ProcessContentsMode.Lax);\n+        }\n+        \n+        // Digest the attributes from the XMLSchema-instance namespace.\n+        m_attributes.initialize(elementName, m_currentItem, attributes, m_namespaces, documentURI, m_errors, sdl);\n+        // if we're not operating in caller-overrides-type mode, get the xsi:type override\n+        if (m_attributes.getLocalType() != null)\n+            localType = m_attributes.getLocalType();\n+\n+        final Boolean explicitNil = m_attributes.getLocalNil();\n+        m_currentPSVI = m_mac.startElement(elementName, localType, explicitNil);\n+        // reset processContents in the child, if we relaxed it above, signalled by non-null savedPC\n+        if (savedPC != null)\n+            m_currentPSVI.setProcessContents(savedPC); // actually a different ModelPSVI than the one we set lax above\n+        m_icm.startElement(m_currentPSVI, m_currentItem, m_errors);\n+        if (m_downstream != null)\n+        {\n+            m_downstream.startElement(elementName, m_currentPSVI.getType());\n+            for (final VxMapping<String, String> mapping : namespaces)\n+            {\n+                m_downstream.namespace(mapping.getKey(), mapping.getValue());\n+            }\n+        }\n         // The attribute manager validates the attributes and sends them downstream, returning the index of the last\n         // attribute.\n-\t\tif ( (skipContents != null) && (skipContents.size() > 0) && skipContents.contains(elementName) ) // non-null, non-empty\n-\t\t{\n-\t\t    // set skip so that the children will be ignored.\n-\t\t    m_currentPSVI.setProcessContents(ProcessContentsMode.Skip);\n-\t\t    // this little bit is how we convince the attribute manager to ignore the attributes\n-\t\t    // in this type. they'll be passed through as untypedAtomic (potentially a problem if\n-\t\t    // there are attributes that shouldn't be ignored, but we have to do it this way or rewrite\n-\t\t    // attribute manager, which is currently out of scope).\n-\t\t    Type savedType = m_currentPSVI.getType();\n-\t\t    m_currentPSVI.m_type = null;\n-\t\t    m_nodeIndex = m_attributes.attributes(m_currentPSVI, m_currentItem, attributes, m_downstream, m_errors, m_idm, m_icm);\n-\t\t    // the reset may be unnecessary, since we've set skip contents. do it anyway.\n-\t\t    m_currentPSVI.m_type = savedType;\n-\t\t}\n-\t\telse // the common case:\n-\t\t    m_nodeIndex = m_attributes.attributes(m_currentPSVI, m_currentItem, attributes, m_downstream, m_errors, m_idm, m_icm);\n-\t}\n-\n-\t@Override\n-\tpublic void text(final List<? extends A> initialValue) throws IOException, AbortException\n-\t{\n-\t\tm_nodeIndex++;\n-\n-\t\t// Remember that we got a text node.\n-\t\tm_currentItem.m_detectedText = true;\n-\n-\t\tif (m_currentItem.getSuspendChecking())\n-\t\t{\n-\t\t\tif (null != m_downstream)\n-\t\t\t{\n-\t\t\t\tm_downstream.text(initialValue);\n-\t\t\t}\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tswitch (m_currentPSVI.getProcessContents())\n-\t\t{\n-\t\t\tcase Strict:\n-\t\t\tcase Lax:\n-\t\t\t{\n-\t\t\t\tfinal ElementDefinition declaration = m_currentPSVI.getDeclaration();\n-\t\t\t\tif (m_currentPSVI.isNilled())\n-\t\t\t\t{\n-\t\t\t\t\tm_errors.error(new CvcElementUnexpectedChildInNilledElementException(declaration, m_currentItem.getLocation()));\n-\t\t\t\t}\n-\n-\t\t\t\tfinal Type elementType = m_currentPSVI.getType();\n-\t\t\t\tif (null != elementType)\n-\t\t\t\t{\n-\t\t\t\t\tif (elementType instanceof SimpleType)\n-\t\t\t\t\t{\n-\t\t\t\t\t\tfinal SimpleType simpleType = (SimpleType)elementType;\n-\t\t\t\t\t\ttry\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tfinal List<A> actualValue = simpleType.validate(initialValue, m_atomBridge);\n-\n-\t\t\t\t\t\t\tif (null != declaration)\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tcheckValueConstraintForElement(declaration, simpleType, actualValue);\n-\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\tm_idm.text(actualValue, simpleType, m_currentItem, m_errors, m_atomBridge);\n-\t\t\t\t\t\t\tm_icm.text(actualValue, simpleType, m_currentItem, m_nodeIndex, m_atomBridge);\n-\n-\t\t\t\t\t\t\tif (null != m_downstream)\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tm_downstream.text(actualValue);\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tcatch (final DatatypeException e)\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tm_errors.error(new SimpleTypeException(m_atomBridge.getC14NString(initialValue), simpleType, e));\n-\t\t\t\t\t\t\tif (null != m_downstream)\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tm_downstream.text(initialValue);\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\telse\n-\t\t\t\t\t{\n-\t\t\t\t\t\tfinal ComplexType complexType = (ComplexType)elementType;\n-\t\t\t\t\t\tfinal ContentType contentType = complexType.getContentType();\n-\t\t\t\t\t\tswitch (contentType.getKind())\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tcase Simple:\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tfinal SimpleType simpleType = contentType.getSimpleType();\n-\t\t\t\t\t\t\t\ttry\n-\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\tfinal List<A> actualValue = simpleType.validate(initialValue, m_atomBridge);\n-\n-\t\t\t\t\t\t\t\t\tcheckValueConstraintForElement(declaration, simpleType, actualValue);\n-\n-\t\t\t\t\t\t\t\t\tm_idm.text(actualValue, simpleType, m_currentItem, m_errors, m_atomBridge);\n-\t\t\t\t\t\t\t\t\tm_icm.text(actualValue, simpleType, m_currentItem, m_nodeIndex, m_atomBridge);\n-\n-\t\t\t\t\t\t\t\t\tif (null != m_downstream)\n-\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\tm_downstream.text(actualValue);\n-\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\tcatch (final DatatypeException e)\n-\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\tm_errors.error(new SimpleTypeException(m_atomBridge.getC14NString(initialValue), simpleType, e));\n-\t\t\t\t\t\t\t\t\tif (null != m_downstream)\n-\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\tm_downstream.text(initialValue);\n-\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t\tcase ElementOnly:\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tfinal String strval = m_atomBridge.getC14NString(initialValue);\n-\t\t\t\t\t\t\t\tif (!isWhiteSpace(strval))\n-\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\tm_errors.error(new CvcUnexpectedNonWhiteSpaceTextInElementOnlyContentException(m_currentPSVI.getName(), strval, m_currentItem.getLocation()));\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t\tcase Mixed:\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tValidationRules.checkValueConstraintForMixedContent(declaration, m_atomBridge.getC14NString(initialValue), m_currentItem, m_errors, m_atomBridge);\n-\n-\t\t\t\t\t\t\t\tif (null != m_downstream)\n-\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\tm_downstream.text(initialValue);\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t\tcase Empty:\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tm_errors.error(new CvcUnexpectedTextInEmptyContentException(m_currentPSVI.getName(), m_atomBridge.getC14NString(initialValue), m_currentItem.getLocation()));\n-\t\t\t\t\t\t\t\tif (null != m_downstream)\n-\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\tm_downstream.text(initialValue);\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t\tdefault:\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tthrow new AssertionError(contentType.getKind());\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\telse\n-\t\t\t\t{\n-\t\t\t\t\tif (null != m_downstream)\n-\t\t\t\t\t{\n-\t\t\t\t\t\tm_downstream.text(initialValue);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tbreak;\n-\t\t\tcase Skip:\n-\t\t\t{\n-\t\t\t\tif (null != m_downstream)\n-\t\t\t\t{\n-\t\t\t\t\tm_downstream.text(initialValue);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t{\n-\t\t\t\tthrow new AssertionError(m_currentPSVI.getProcessContents());\n-\t\t\t}\n-\t\t}\n-\t}\n-\t\n+        if ((skipContents != null) && (skipContents.size() > 0) && skipContents.contains(elementName)) // non-null, non-empty\n+        {\n+            // set skip so that the children will be ignored.\n+            m_currentPSVI.setProcessContents(ProcessContentsMode.Skip);\n+            // this little bit is how we convince the attribute manager to ignore the attributes\n+            // in this type. they'll be passed through as untypedAtomic (potentially a problem if\n+            // there are attributes that shouldn't be ignored, but we have to do it this way or rewrite\n+            // attribute manager, which is currently out of scope).\n+            Type savedType = m_currentPSVI.getType();\n+            m_currentPSVI.m_type = null;\n+            m_nodeIndex = m_attributes.attributes(m_currentPSVI, m_currentItem, attributes, m_downstream, m_errors, m_idm, m_icm);\n+            // the reset may be unnecessary, since we've set skip contents. do it anyway.\n+            m_currentPSVI.m_type = savedType;\n+        }\n+        else // the common case:\n+            m_nodeIndex = m_attributes.attributes(m_currentPSVI, m_currentItem, attributes, m_downstream, m_errors, m_idm, m_icm);\n+    }\n+\n+    @Override\n+    public void text(final List<? extends A> initialValue)\n+        throws IOException, AbortException\n+    {\n+        m_nodeIndex++;\n+\n+        // Remember that we got a text node.\n+        m_currentItem.m_detectedText = true;\n+        if (m_currentItem.getSuspendChecking())\n+        {\n+            if (null != m_downstream)\n+            {\n+                m_downstream.text(initialValue);\n+            }\n+            return;\n+        }\n+        switch (m_currentPSVI.getProcessContents())\n+        {\n+            case Strict:\n+            case Lax:\n+            {\n+                final ElementDefinition declaration = m_currentPSVI.getDeclaration();\n+                if (m_currentPSVI.isNilled())\n+                {\n+                    m_errors.error(new CvcElementUnexpectedChildInNilledElementException(declaration, m_currentItem.getLocation()));\n+                }\n+\n+                final Type elementType = m_currentPSVI.getType();\n+                if (null != elementType)\n+                {\n+                    if (elementType instanceof SimpleType)\n+                    {\n+                        final SimpleType simpleType = (SimpleType)elementType;\n+                        try\n+                        {\n+                            final List<A> actualValue = simpleType.validate(initialValue, m_atomBridge);\n+                            if (null != declaration)\n+                            {\n+                                checkValueConstraintForElement(declaration, simpleType, actualValue);\n+                            }\n+                            m_idm.text(actualValue, simpleType, m_currentItem, m_errors, m_atomBridge);\n+                            m_icm.text(actualValue, simpleType, m_currentItem, m_nodeIndex, m_atomBridge);\n+                            if (null != m_downstream)\n+                            {\n+                                m_downstream.text(actualValue);\n+                            }\n+                        }\n+                        catch (final DatatypeException e)\n+                        {\n+                            m_errors.error(new SimpleTypeException(m_atomBridge.getC14NString(initialValue), simpleType, e));\n+                            if (null != m_downstream)\n+                            {\n+                                m_downstream.text(initialValue);\n+                            }\n+                        }\n+                    }\n+                    else\n+                    {\n+                        final ComplexType complexType = (ComplexType)elementType;\n+                        final ContentType contentType = complexType.getContentType();\n+\n+                        switch (contentType.getKind())\n+                        {\n+                            case Simple:\n+                            {\n+                                final SimpleType simpleType = contentType.getSimpleType();\n+                                try\n+                                {\n+                                    final List<A> actualValue = simpleType.validate(initialValue, m_atomBridge);\n+                                    checkValueConstraintForElement(declaration, simpleType, actualValue);\n+                                    m_idm.text(actualValue, simpleType, m_currentItem, m_errors, m_atomBridge);\n+                                    m_icm.text(actualValue, simpleType, m_currentItem, m_nodeIndex, m_atomBridge);\n+                                    if (null != m_downstream)\n+                                    {\n+                                        m_downstream.text(actualValue);\n+                                    }\n+                                }\n+                                catch (final DatatypeException e)\n+                                {\n+                                    m_errors.error(new SimpleTypeException(m_atomBridge.getC14NString(initialValue), simpleType, e));\n+                                    if (null != m_downstream)\n+                                    {\n+                                        m_downstream.text(initialValue);\n+                                    }\n+                                }\n+                            }\n+                            break;\n+                            case ElementOnly:\n+                            {\n+                                final String strval = m_atomBridge.getC14NString(initialValue);\n+                                if (!isWhiteSpace(strval))\n+                                {\n+                                    m_errors.error(new CvcUnexpectedNonWhiteSpaceTextInElementOnlyContentException(m_currentPSVI.getName(), strval, m_currentItem.getLocation()));\n+                                }\n+                            }\n+                            break;\n+                            case Mixed:\n+                            {\n+                                ValidationRules.checkValueConstraintForMixedContent(declaration, m_atomBridge.getC14NString(initialValue), m_currentItem, m_errors, m_atomBridge);\n+                                if (null != m_downstream)\n+                                {\n+                                    m_downstream.text(initialValue);\n+                                }\n+                            }\n+                            break;\n+                            case Empty:\n+                            {\n+                                m_errors.error(new CvcUnexpectedTextInEmptyContentException(m_currentPSVI.getName(), m_atomBridge.getC14NString(initialValue), m_currentItem.getLocation()));\n+                                if (null != m_downstream)\n+                                {\n+                                    m_downstream.text(initialValue);\n+                                }\n+                            }\n+                            break;\n+                            default:\n+                            {\n+                                throw new AssertionError(contentType.getKind());\n+                            }\n+                        }\n+                    }\n+                }\n+                else\n+                {\n+                    if (null != m_downstream)\n+                    {\n+                        m_downstream.text(initialValue);\n+                    }\n+                }\n+            }\n+            break;\n+            case Skip:\n+            {\n+                if (null != m_downstream)\n+                {\n+                    m_downstream.text(initialValue);\n+                }\n+            }\n+            break;\n+            default:\n+            {\n+                throw new AssertionError(m_currentPSVI.getProcessContents());\n+            }\n+        }\n+    }\n+\n     private final AtomBridge<A> m_atomBridge;\n     private AttributeManager<A> m_attributes;\n     private ValidationItem m_currentItem;\n     private ModelPSVI m_currentPSVI;\n     private ComponentProvider m_provider;\n     private Set<QName> skipContents;\n-\n     private final ValidationItem m_documentItem;\n     private ModelPSVI m_documentPSVI;\n     // Set by reset method. Preconditions guarantee that it is never null.\n@@ -809,9 +785,7 @@ final class ValidationKernel<A> implements VxValidator<A>, SmExceptionSupplier\n     // private Location m_location;\n     private SchemaExceptionHandler m_errors = SmExceptionThrower.SINGLETON;\n     private final VxSchemaDocumentLocationStrategy sdl;\n-\n     private final IdentityConstraintManager m_icm = new IdentityConstraintManager();\n-\n     private final IdManager m_idm = new IdManager();\n \n     // Maintain state for each element.\n@@ -825,5 +799,4 @@ final class ValidationKernel<A> implements VxValidator<A>, SmExceptionSupplier\n     // We must normalize character events into a single text node.\n     private final StringBuilder m_text = new StringBuilder();\n     private URI documentURI;\n-\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 801
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "65",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/136/ValidationKernel.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_random/136/ValidationKernel.java\nindex 40a7804c48e..228a67b9021 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/136/ValidationKernel.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_random/136/ValidationKernel.java\n@@ -59,8 +59,8 @@ import org.genxdm.xs.types.Type;\n  */\n final class ValidationKernel<A> implements VxValidator<A>, SmExceptionSupplier\n {\n-\t// Set by reset method. Preconditions guarantee that it is never null.\n-\t// private final ParticleTerm STRICT_WILDCARD = new StrictWildcard<A>();\n+// Set by reset method. Preconditions guarantee that it is never null.\n+ // private final ParticleTerm STRICT_WILDCARD = new StrictWildcard<A>();\n \n \tprivate static boolean isWhiteSpace(final String strval)\n \t{\n",
            "diff_size": 2
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "65",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/136/ValidationKernel.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_three_grams/136/ValidationKernel.java\nindex 40a7804c48e..bb5f674a8f2 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/136/ValidationKernel.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_three_grams/136/ValidationKernel.java\n@@ -59,8 +59,8 @@ import org.genxdm.xs.types.Type;\n  */\n final class ValidationKernel<A> implements VxValidator<A>, SmExceptionSupplier\n {\n-\t// Set by reset method. Preconditions guarantee that it is never null.\n-\t// private final ParticleTerm STRICT_WILDCARD = new StrictWildcard<A>();\n+    // Set by reset method. Preconditions guarantee that it is never null.\n+ // private final ParticleTerm STRICT_WILDCARD = new StrictWildcard<A>();\n \n \tprivate static boolean isWhiteSpace(final String strval)\n \t{\n",
            "diff_size": 2
        }
    ],
    "repaired_by": [
        "intellij",
        "codebuff"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "styler_random",
        "styler_three_grams"
    ]
}