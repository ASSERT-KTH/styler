{
    "project_name": "CESNET-perun",
    "error_id": "411",
    "information": {
        "errors": [
            {
                "line": "405",
                "severity": "error",
                "message": "Line has trailing spaces.",
                "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
            }
        ]
    },
    "source_code": "\t\t\t\t\"  SENDEEROR:  \" + senderror +\n\t\t\t\t\"  DONE: \" + done +\n\t\t\t\t\"  WARNING: \" + warning + \n\t\t\t\t\"  ERROR: \" + error;\n\t}\n",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/411/SchedulingPoolImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/styler/411/SchedulingPoolImpl.java\nindex 584621dee32..75e8daeecc8 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/411/SchedulingPoolImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/styler/411/SchedulingPoolImpl.java\n@@ -402,7 +402,7 @@ public class SchedulingPoolImpl implements SchedulingPool {\n \t\t\t\t\"  SENDING:  \" + sending +\n \t\t\t\t\"  SENDEEROR:  \" + senderror +\n \t\t\t\t\"  DONE: \" + done +\n-\t\t\t\t\"  WARNING: \" + warning + \n+\t\t\t\t\"  WARNING: \" + warning +\n \t\t\t\t\"  ERROR: \" + error;\n \t}\n \n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/411/SchedulingPoolImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/intellij/411/SchedulingPoolImpl.java\nindex 584621dee32..a3a5a9e3b69 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/411/SchedulingPoolImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/intellij/411/SchedulingPoolImpl.java\n@@ -44,513 +44,518 @@ import javax.annotation.Resource;\n /**\n  * Implementation of SchedulingPool.\n  *\n- * @see cz.metacentrum.perun.dispatcher.scheduling.SchedulingPool\n- *\n  * @author Michal Voc\u016f\n  * @author Michal Babacek\n  * @author David \u0160arman\n  * @author Pavel Zl\u00e1mal <zlamal@cesnet.cz>\n+ * @see cz.metacentrum.perun.dispatcher.scheduling.SchedulingPool\n  */\n @org.springframework.stereotype.Service(\"schedulingPool\")\n public class SchedulingPoolImpl implements SchedulingPool {\n \n-\tprivate final static Logger log = LoggerFactory.getLogger(SchedulingPoolImpl.class);\n+    private final static Logger log = LoggerFactory.getLogger(SchedulingPoolImpl.class);\n \n-\tprivate PerunSession sess;\n+    private PerunSession sess;\n \n-\tprivate DelayQueue<TaskSchedule> waitingTasksQueue;\n-\tprivate DelayQueue<TaskSchedule> waitingForcedTasksQueue;\n-\tprivate Properties dispatcherProperties;\n-\tprivate TaskStore taskStore;\n-\tprivate TasksManagerBl tasksManagerBl;\n-\tprivate EngineMessageProducerFactory engineMessageProducerFactory;\n-\tprivate Perun perun;\n+    private DelayQueue<TaskSchedule> waitingTasksQueue;\n+    private DelayQueue<TaskSchedule> waitingForcedTasksQueue;\n+    private Properties dispatcherProperties;\n+    private TaskStore taskStore;\n+    private TasksManagerBl tasksManagerBl;\n+    private EngineMessageProducerFactory engineMessageProducerFactory;\n+    private Perun perun;\n \n-\tpublic SchedulingPoolImpl() {\n-\t}\n+    public SchedulingPoolImpl() {\n+    }\n \n-\tpublic SchedulingPoolImpl(Properties dispatcherPropertiesBean,\n-\t\t\t\tTaskStore taskStore,\n-\t\t\t\tTasksManagerBl tasksManagerBl,\n-\t\t\t\tEngineMessageProducerFactory engineMessageProducerFactory) {\n-\t\tthis.dispatcherProperties = dispatcherPropertiesBean;\n-\t\tthis.taskStore = taskStore;\n-\t\tthis.tasksManagerBl = tasksManagerBl;\n-\t\tthis.engineMessageProducerFactory = engineMessageProducerFactory;\n-\t}\n+    public SchedulingPoolImpl(Properties dispatcherPropertiesBean,\n+                              TaskStore taskStore,\n+                              TasksManagerBl tasksManagerBl,\n+                              EngineMessageProducerFactory engineMessageProducerFactory) {\n+        this.dispatcherProperties = dispatcherPropertiesBean;\n+        this.taskStore = taskStore;\n+        this.tasksManagerBl = tasksManagerBl;\n+        this.engineMessageProducerFactory = engineMessageProducerFactory;\n+    }\n \n \n-\t// ----- setters -------------------------------------\n+    // ----- setters -------------------------------------\n \n \n-\tpublic DelayQueue<TaskSchedule> getWaitingTasksQueue() {\n-\t\treturn waitingTasksQueue;\n-\t}\n+    public DelayQueue<TaskSchedule> getWaitingTasksQueue() {\n+        return waitingTasksQueue;\n+    }\n \n-\t@Autowired\n-\tpublic void setWaitingTasksQueue(DelayQueue<TaskSchedule> waitingTasksQueue) {\n-\t\tthis.waitingTasksQueue = waitingTasksQueue;\n-\t}\n+    @Autowired\n+    public void setWaitingTasksQueue(DelayQueue<TaskSchedule> waitingTasksQueue) {\n+        this.waitingTasksQueue = waitingTasksQueue;\n+    }\n \n-\tpublic DelayQueue<TaskSchedule> getWaitingForcedTasksQueue() {\n-\t\treturn waitingForcedTasksQueue;\n-\t}\n-\n-\t@Autowired\n-\tpublic void setWaitingForcedTasksQueue(DelayQueue<TaskSchedule> waitingForcedTasksQueue) {\n-\t\tthis.waitingForcedTasksQueue = waitingForcedTasksQueue;\n-\t}\n-\n-\tpublic Properties getDispatcherProperties() {\n-\t\treturn dispatcherProperties;\n-\t}\n-\n-\t@Resource(name=\"dispatcherPropertiesBean\")\n-\tpublic void setDispatcherProperties(Properties dispatcherProperties) {\n-\t\tthis.dispatcherProperties = dispatcherProperties;\n-\t}\n-\n-\tpublic TaskStore getTaskStore() {\n-\t\treturn taskStore;\n-\t}\n-\n-\t@Autowired\n-\tpublic void setTaskStore(TaskStore taskStore) {\n-\t\tthis.taskStore = taskStore;\n-\t}\n-\n-\tpublic TasksManagerBl getTasksManagerBl() {\n-\t\treturn tasksManagerBl;\n-\t}\n-\n-\t@Autowired\n-\tpublic void setTasksManagerBl(TasksManagerBl tasksManagerBl) {\n-\t\tthis.tasksManagerBl = tasksManagerBl;\n-\t}\n-\n-\tpublic EngineMessageProducerFactory getEngineMessageProducerPool() {\n-\t\treturn engineMessageProducerFactory;\n-\t}\n-\n-\t@Autowired\n-\tpublic void setEngineMessageProducerPool(EngineMessageProducerFactory engineMessageProducerPool) {\n-\t\tthis.engineMessageProducerFactory = engineMessageProducerPool;\n-\t}\n-\n-\tpublic Perun getPerun() {\n-\t\treturn perun;\n-\t}\n-\n-\t@Autowired\n-\tpublic void setPerun(Perun perun) {\n-\t\tthis.perun = perun;\n-\t}\n-\n-\n-\t// ----- methods -------------------------------------\n-\n-\n-\t@Override\n-\tpublic Task getTask(int id) {\n-\t\treturn taskStore.getTask(id);\n-\t}\n-\n-\t@Override\n-\tpublic Task getTask(Facility facility, Service service) {\n-\t\treturn taskStore.getTask(facility, service);\n-\t}\n-\n-\t@Override\n-\tpublic int getSize() {\n-\t\treturn taskStore.getSize();\n-\t}\n-\n-\t@Override\n-\tpublic Task addTask(Task task) throws TaskStoreException {\n-\t\treturn taskStore.addTask(task);\n-\t}\n-\n-\t@Override\n-\tpublic Collection<Task> getAllTasks() {\n-\t\treturn taskStore.getAllTasks();\n-\t}\n-\n-\t@Override\n-\tpublic List<Task> getTasksWithStatus(TaskStatus... status) {\n-\t\treturn taskStore.getTasksWithStatus(status);\n-\t}\n-\n-\t@Override\n-\tpublic Task removeTask(Task task) throws TaskStoreException {\n-\t\treturn taskStore.removeTask(task);\n-\t}\n-\n-\t@Override\n-\tpublic void scheduleTask(Task task, int delayCount) {\n-\n-\t\t// init session\n-\t\ttry {\n-\t\t\tif (sess == null) {\n-\t\t\t\tsess = perun.getPerunSession(new PerunPrincipal(\n-\t\t\t\t\t\t\t\tdispatcherProperties.getProperty(\"perun.principal.name\"),\n-\t\t\t\t\t\t\t\tdispatcherProperties.getProperty(\"perun.principal.extSourceName\"),\n-\t\t\t\t\t\t\t\tdispatcherProperties.getProperty(\"perun.principal.extSourceType\")),\n-\t\t\t\t\t\tnew PerunClient());\n-\t\t\t}\n-\t\t} catch (InternalErrorException e1) {\n-\t\t\tlog.error(\"Error establishing perun session to add task schedule: \", e1);\n-\t\t\treturn;\n-\t\t}\n-\n-\t\t// check if service/facility exists\n-\n-\t\tboolean removeTask = false;\n-\n-\t\ttry {\n-\t\t\tService service = perun.getServicesManager().getServiceById(sess, task.getServiceId());\n-\t\t\tFacility facility = perun.getFacilitiesManager().getFacilityById(sess, task.getFacilityId());\n-\t\t\ttask.setService(service);\n-\t\t\ttask.setFacility(facility);\n-\t\t} catch (ServiceNotExistsException e) {\n-\t\t\tlog.error(\"[{}] Task NOT added to waiting queue, service not exists: {}.\", task.getId(), task);\n-\t\t\tremoveTask = true;\n-\t\t} catch (FacilityNotExistsException e) {\n-\t\t\tlog.error(\"[{}] Task NOT added to waiting queue, facility not exists: {}.\", task.getId(), task);\n-\t\t\tremoveTask = true;\n-\t\t}  catch (InternalErrorException | PrivilegeException e) {\n-\t\t\tlog.error(\"[{}] {}\", task.getId(), e);\n-\t\t}\n-\n-\t\tif (!task.getService().isEnabled() || ((PerunBl) perun).getServicesManagerBl().isServiceBlockedOnFacility(task.getService(), task.getFacility())) {\n-\t\t\tlog.error(\"[{}] Task NOT added to waiting queue, service is blocked: {}.\", task.getId(), task);\n-\t\t\t// do not change Task status or any other data !\n-\t\t\tif (!removeTask) return;\n-\t\t}\n-\n-\t\ttry {\n-\t\t\tList<Destination> destinations = perun.getServicesManager().getDestinations(sess, task.getService(), task.getFacility());\n-\t\t\tif (destinations != null && !destinations.isEmpty()) {\n-\t\t\t\tIterator<Destination> iter = destinations.iterator();\n-\t\t\t\twhile (iter.hasNext()) {\n-\t\t\t\t\tDestination dest = iter.next();\n-\t\t\t\t\tif (((PerunBl) perun).getServicesManagerBl().isServiceBlockedOnDestination(task.getService(), dest.getId())) {\n-\t\t\t\t\t\titer.remove();\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tif (destinations.isEmpty()) {\n-\t\t\t\t\t// All service destinations were blocked -> Task is denied to be sent to engine just like\n-\t\t\t\t\t// when service is blocked globally in Perun or on facility as a whole.\n-\t\t\t\t\tlog.debug(\"[{}] Task NOT added to waiting queue, all its destinations are blocked.\", task.getId());\n-\t\t\t\t\tif (!removeTask) return;\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t} catch (ServiceNotExistsException e) {\n-\t\t\tlog.error(\"[{}] Task NOT added to waiting queue, service not exists: {}.\", task.getId(), task);\n-\t\t\tremoveTask = true;\n-\t\t} catch (FacilityNotExistsException e) {\n-\t\t\tlog.error(\"[{}] Task NOT added to waiting queue, facility not exists: {}.\", task.getId(), task);\n-\t\t\tremoveTask = true;\n-\t\t}  catch (InternalErrorException | PrivilegeException e) {\n-\t\t\tlog.error(\"[{}] {}\", task.getId(), e);\n-\t\t}\n-\n-\t\ttry {\n-\t\t\tList<Service> assignedServices = perun.getServicesManager().getAssignedServices(sess, task.getFacility());\n-\t\t\tif (!assignedServices.contains(task.getService())) {\n-\t\t\t\tlog.debug(\"[{}] Task NOT added to waiting queue, service is not assigned to facility any more: {}.\", task.getId(), task);\n-\t\t\t\tif (!removeTask) return;\n-\t\t\t}\n-\t\t} catch (FacilityNotExistsException e) {\n-\t\t\tremoveTask = true;\n-\t\t\tlog.error(\"[{}] Task removed from database, facility no longer exists: {}.\", task.getId(), task);\n-\t\t} catch (InternalErrorException | PrivilegeException e) {\n-\t\t\tlog.error(\"[{}] Unable to check Service assignment to Facility: {}\", task.getId(), e.getMessage());\n-\t\t}\n-\n-\t\tif (removeTask) {\n-\t\t\t// in memory task belongs to non existent facility/service - remove it and return\n-\t\t\ttry {\n-\t\t\t\tremoveTask(task);\n-\t\t\t\treturn;\n-\t\t\t} catch (TaskStoreException e) {\n-\t\t\t\tlog.error(\"[{}] Unable to remove Task from pool: {}.\", task.getId(), e);\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t}\n-\n-\t\t// Task is eligible for running - create new schedule\n-\n-\t\ttask.setSourceUpdated(false);\n-\n-\t\tlong newTaskDelay = 0;\n-\t\tif (!task.isPropagationForced()) {\n-\t\t\t// normal tasks are delayed\n-\t\t\ttry {\n-\t\t\t\tnewTaskDelay = Long.parseLong(dispatcherProperties.getProperty(\"dispatcher.task.delay.time\"));\n-\t\t\t} catch (NumberFormatException e) {\n-\t\t\t\tlog.warn(\"Could not parse value of dispatcher.task.delay.time property. Using default.\");\n-\t\t\t\tnewTaskDelay = 30000;\n-\t\t\t}\n-\t\t}\n-\t\tif (task.isPropagationForced()) {\n-\t\t\tdelayCount = 0;\n-\t\t}\n-\t\tif (delayCount < 0) {\n-\t\t\ttry {\n-\t\t\t\tdelayCount = Integer.parseInt(dispatcherProperties.getProperty(\"dispatcher.task.delay.count\"));\n-\t\t\t} catch (NumberFormatException e) {\n-\t\t\t\tlog.warn(\"Could not parse value of dispatcher.task.delay.count property. Using default.\");\n-\t\t\t\tdelayCount = 4;\n-\t\t\t}\n-\t\t}\n-\n-\t\tTaskSchedule schedule = new TaskSchedule(newTaskDelay, task);\n-\t\tschedule.setBase(System.currentTimeMillis());\n-\t\tschedule.setDelayCount(delayCount);\n-\n-\t\t// Task was newly planned for propagation, switch state.\n-\t\tif (!task.getStatus().equals(TaskStatus.WAITING)) {\n-\n-\t\t\ttask.setStatus(TaskStatus.WAITING);\n-\t\t\ttask.setSchedule(LocalDateTime.now());\n-\t\t\t// clear previous timestamps\n-\t\t\ttask.setSentToEngine((LocalDateTime) null);\n-\t\t\ttask.setStartTime((LocalDateTime) null);\n-\t\t\ttask.setGenStartTime((LocalDateTime) null);\n-\t\t\ttask.setSendStartTime((LocalDateTime) null);\n-\t\t\ttask.setEndTime((LocalDateTime) null);\n-\t\t\ttask.setGenEndTime((LocalDateTime) null);\n-\t\t\ttask.setSendEndTime((LocalDateTime) null);\n-\n-\t\t\ttasksManagerBl.updateTask(task);\n-\n-\t\t}\n-\n-\t\tboolean added = false;\n-\n-\t\tif (schedule.getTask().isPropagationForced()) {\n-\t\t\tadded = waitingForcedTasksQueue.add(schedule);\n-\t\t} else {\n-\t\t\tadded = waitingTasksQueue.add(schedule);\n-\t\t}\n-\n-\t\tif (!added) {\n-\t\t\tlog.error(\"[{}] Task could not be added to waiting queue. Shouldn't ever happen. Look to javadoc of DelayQueue. {}\", task.getId(), schedule);\n-\t\t} else {\n-\t\t\tlog.debug(\"[{}] Task was added to waiting queue: {}\", task.getId(), schedule);\n-\t\t}\n-\n-\t}\n-\n-\t/**\n-\t * Adds Task and associated dispatcherQueue into scheduling pools internal maps and also to the database.\n-\t *\n-\t * @param task            Task which will be added and persisted.\n-\t * @return Number of Tasks in the pool.\n-\t * @throws TaskStoreException\n-\t */\n-\t@Override\n-\tpublic int addToPool(Task task) throws TaskStoreException {\n-\n-\t\tif (task.getId() == 0) {\n-\t\t\tif (getTask(task.getFacility(), task.getService()) == null) {\n-\t\t\t\tint id = tasksManagerBl.insertTask(task);\n-\t\t\t\ttask.setId(id);\n-\t\t\t\tlog.debug(\"[{}] New Task stored in DB: {}\", task.getId(), task);\n-\t\t\t} else {\n-\t\t\t\tTask existingTask = tasksManagerBl.getTaskById(task.getId());\n-\t\t\t\tif (existingTask == null) {\n-\t\t\t\t\tint id = tasksManagerBl.insertTask(task);\n-\t\t\t\t\ttask.setId(id);\n-\t\t\t\t\tlog.debug(\"[{}] New Task stored in DB: {}\", task.getId(), task);\n-\t\t\t\t} else {\n-\t\t\t\t\ttasksManagerBl.updateTask(task);\n-\t\t\t\t\tlog.debug(\"[{}] Task updated in the pool: {}\", task.getId(), task);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\taddTask(task);\n-\t\tlog.debug(\"[{}] Task added to the pool: {}\", task.getId(), task);\n-\t\treturn getSize();\n-\t}\n-\n-\t@Override\n-\tpublic Task removeTask(int id) throws TaskStoreException {\n-\t\treturn taskStore.removeTask(id);\n-\t}\n-\n-\t@Override\n-\tpublic String getReport() {\n-\t\tint waiting = getTasksWithStatus(TaskStatus.WAITING).size();\n-\t\tint planned = getTasksWithStatus(TaskStatus.PLANNED).size();\n-\t\tint generating = getTasksWithStatus(TaskStatus.GENERATING).size();\n-\t\tint generated = getTasksWithStatus(TaskStatus.GENERATED).size();\n-\t\tint generror = getTasksWithStatus(TaskStatus.GENERROR).size();\n-\t\tint sending = getTasksWithStatus(TaskStatus.SENDING).size();\n-\t\tint senderror = getTasksWithStatus(TaskStatus.SENDERROR).size();\n-\t\tint done = getTasksWithStatus(TaskStatus.DONE).size();\n-\t\tint warning = getTasksWithStatus(TaskStatus.WARNING).size();\n-\t\tint error = getTasksWithStatus(TaskStatus.ERROR).size();\n-\n-\t\treturn \"Dispatcher SchedulingPool Task report:\\n\" +\n-\t\t\t\t\"  WAITING: \" + waiting +\n-\t\t\t\t\"  PLANNED: \" + planned +\n-\t\t\t\t\"  GENERATING: \" + generating +\n-\t\t\t\t\"  GENERATED: \" + generated +\n-\t\t\t\t\"  GENERROR: \" + generror +\n-\t\t\t\t\"  SENDING:  \" + sending +\n-\t\t\t\t\"  SENDEEROR:  \" + senderror +\n-\t\t\t\t\"  DONE: \" + done +\n-\t\t\t\t\"  WARNING: \" + warning + \n-\t\t\t\t\"  ERROR: \" + error;\n-\t}\n-\n-\t@Override\n-\tpublic void clear() {\n-\t\ttaskStore.clear();\n-\t\twaitingTasksQueue.clear();\n-\t\twaitingForcedTasksQueue.clear();\n-\t}\n-\n-\t@Override\n-\tpublic void reloadTasks() {\n-\n-\t\tlog.debug(\"Going to reload Tasks from database...\");\n-\n-\t\tthis.clear();\n-\n-\t\tEngineMessageProducer queue = engineMessageProducerFactory.getProducer();\n-\n-\t\tfor (Task task : tasksManagerBl.listAllTasks()) {\n-\t\t\ttry {\n-\t\t\t\t// just add DB Task to in-memory structure\n-\t\t\t\taddToPool(task);\n-\t\t\t} catch (TaskStoreException e) {\n-\t\t\t\tlog.error(\"Adding Task {} and Queue {} into SchedulingPool failed, so the Task will be lost.\", task, queue);\n-\t\t\t}\n-\n-\t\t\t// if service was not in DONE or any kind of ERROR - reschedule now\n-\t\t\t// error/done tasks will be rescheduled later by periodic jobs !!\n-\t\t\tif (!Arrays.asList(TaskStatus.DONE, TaskStatus.ERROR, TaskStatus.GENERROR, TaskStatus.SENDERROR, TaskStatus.WARNING).contains(task.getStatus())) {\n-\t\t\t\tif (task.getStatus().equals(TaskStatus.WAITING)) {\n-\t\t\t\t\t// if were in WAITING, reset timestamp to now\n-\t\t\t\t\ttask.setSchedule(LocalDateTime.now());\n-\t\t\t\t\ttasksManagerBl.updateTask(task);\n-\t\t\t\t}\n-\t\t\t\tscheduleTask(task, 0);\n-\t\t\t}\n-\n-\t\t}\n-\n-\t\tlog.debug(\"Reload of Tasks from database finished.\");\n-\n-\t}\n-\n-\t@Override\n-\tpublic void closeTasksForEngine() {\n-\n-\t\tList<Task> tasks = taskStore.getTasksWithStatus(\n-\t\t\t\tTaskStatus.PLANNED,\n-\t\t\t\tTaskStatus.GENERATING,\n-\t\t\t\tTaskStatus.GENERATED,\n-\t\t\t\tTaskStatus.SENDING,\n-\t\t\t\tTaskStatus.WARNING\n-\t\t\t\t);\n-\n-\t\t// switch all processing tasks to error, remove the engine queue association\n-\t\tlog.debug(\"Switching processing tasks on engine to ERROR, the engine went down...\");\n-\t\tfor (Task task : tasks) {\n-\t\t\tlog.info(\"[{}] Switching Task to ERROR, the engine it was running on went down.\", task.getId());\n-\t\t\ttask.setStatus(TaskStatus.ERROR);\n-\t\t}\n-\n-\t}\n-\n-\t@Override\n-\tpublic void onTaskStatusChange(int taskId, String status, String milliseconds) {\n-\n-\t\tTask task = getTask(taskId);\n-\t\tif (task == null) {\n-\t\t\tlog.error(\"[{}] Received status update about Task which is not in Dispatcher anymore, will ignore it.\", taskId);\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tTaskStatus oldStatus = task.getStatus();\n-\t\ttask.setStatus(TaskStatus.valueOf(status));\n-\t\tlong ms;\n-\t\ttry {\n-\t\t\tms = Long.valueOf(milliseconds);\n-\t\t} catch (NumberFormatException e) {\n-\t\t\tlog.warn(\"[{}] Timestamp of change '{}' could not be parsed, current time will be used instead.\", task.getId(), milliseconds);\n-\t\t\tms = System.currentTimeMillis();\n-\t\t}\n-\t\tLocalDateTime changeDate = LocalDateTime.ofInstant(Instant.ofEpochMilli(ms), ZoneId.systemDefault());\n-\n-\t\tswitch (task.getStatus()) {\n-\t\t\tcase WAITING:\n-\t\t\tcase PLANNED:\n-\t\t\t\tlog.error(\"[{}] Received status change to {} from Engine, this should not happen.\", task.getId(), task.getStatus());\n-\t\t\t\treturn;\n-\t\t\tcase GENERATING:\n-\t\t\t\ttask.setStartTime(changeDate);\n-\t\t\t\ttask.setGenStartTime(changeDate);\n-\t\t\t\tbreak;\n-\t\t\tcase GENERROR:\n-\t\t\t\ttask.setEndTime(changeDate);\n-\t\t\tcase GENERATED:\n-\t\t\t\ttask.setGenEndTime(changeDate);\n-\t\t\t\tbreak;\n-\t\t\tcase SENDING:\n-\t\t\t\ttask.setSendStartTime(changeDate);\n-\t\t\t\tbreak;\n-\t\t\tcase DONE:\n-\t\t\tcase WARNING:\n-\t\t\tcase SENDERROR:\n-\t\t\t\ttask.setSendEndTime(changeDate);\n-\t\t\t\ttask.setEndTime(changeDate);\n-\t\t\t\tbreak;\n-\t\t\tcase ERROR:\n-\t\t\t\ttask.setEndTime(changeDate);\n-\t\t\t\tbreak;\n-\t\t}\n-\n-\t\ttasksManagerBl.updateTask(task);\n-\n-\t\tlog.debug(\"[{}] Task status changed from {} to {} as reported by Engine: {}.\", task.getId(), oldStatus, task.getStatus(), task);\n-\n-\t}\n-\n-\t@Override\n-\tpublic void onTaskDestinationComplete(String string) {\n-\n-\t\tif (string == null || string.isEmpty()) {\n-\t\t\tlog.error(\"Could not parse TaskResult message from Engine.\");\n-\t\t\treturn;\n-\t\t}\n-\n-\t\ttry {\n-\t\t\tList<PerunBean> listOfBeans = AuditParser.parseLog(string);\n-\t\t\tif (!listOfBeans.isEmpty()) {\n-\t\t\t\tTaskResult taskResult = (TaskResult) listOfBeans.get(0);\n-\t\t\t\tlog.debug(\"[{}] Received TaskResult for Task from Engine.\", taskResult.getTaskId());\n-\t\t\t\tonTaskDestinationComplete(taskResult);\n-\t\t\t} else {\n-\t\t\t\tlog.error(\"No TaskResult found in message from Engine: {}.\", string);\n-\t\t\t}\n-\t\t} catch (Exception e) {\n-\t\t\tlog.error(\"Could not save TaskResult from Engine {}, {}\", string, e.getMessage());\n-\t\t}\n-\n-\t}\n-\n-\t@Override\n-\tpublic void onTaskDestinationComplete(TaskResult taskResult) {\n-\t\ttry {\n-\t\t\ttasksManagerBl.insertNewTaskResult(taskResult);\n-\t\t} catch (Exception e) {\n-\t\t\tlog.error(\"Could not save TaskResult from Engine, {}, {}\", taskResult, e.getMessage());\n-\t\t}\n-\t}\n+    public DelayQueue<TaskSchedule> getWaitingForcedTasksQueue() {\n+        return waitingForcedTasksQueue;\n+    }\n+\n+    @Autowired\n+    public void setWaitingForcedTasksQueue(DelayQueue<TaskSchedule> waitingForcedTasksQueue) {\n+        this.waitingForcedTasksQueue = waitingForcedTasksQueue;\n+    }\n+\n+    public Properties getDispatcherProperties() {\n+        return dispatcherProperties;\n+    }\n+\n+    @Resource(name = \"dispatcherPropertiesBean\")\n+    public void setDispatcherProperties(Properties dispatcherProperties) {\n+        this.dispatcherProperties = dispatcherProperties;\n+    }\n+\n+    public TaskStore getTaskStore() {\n+        return taskStore;\n+    }\n+\n+    @Autowired\n+    public void setTaskStore(TaskStore taskStore) {\n+        this.taskStore = taskStore;\n+    }\n+\n+    public TasksManagerBl getTasksManagerBl() {\n+        return tasksManagerBl;\n+    }\n+\n+    @Autowired\n+    public void setTasksManagerBl(TasksManagerBl tasksManagerBl) {\n+        this.tasksManagerBl = tasksManagerBl;\n+    }\n+\n+    public EngineMessageProducerFactory getEngineMessageProducerPool() {\n+        return engineMessageProducerFactory;\n+    }\n+\n+    @Autowired\n+    public void setEngineMessageProducerPool(EngineMessageProducerFactory engineMessageProducerPool) {\n+        this.engineMessageProducerFactory = engineMessageProducerPool;\n+    }\n+\n+    public Perun getPerun() {\n+        return perun;\n+    }\n+\n+    @Autowired\n+    public void setPerun(Perun perun) {\n+        this.perun = perun;\n+    }\n+\n+\n+    // ----- methods -------------------------------------\n+\n+\n+    @Override\n+    public Task getTask(int id) {\n+        return taskStore.getTask(id);\n+    }\n+\n+    @Override\n+    public Task getTask(Facility facility, Service service) {\n+        return taskStore.getTask(facility, service);\n+    }\n+\n+    @Override\n+    public int getSize() {\n+        return taskStore.getSize();\n+    }\n+\n+    @Override\n+    public Task addTask(Task task) throws TaskStoreException {\n+        return taskStore.addTask(task);\n+    }\n+\n+    @Override\n+    public Collection<Task> getAllTasks() {\n+        return taskStore.getAllTasks();\n+    }\n+\n+    @Override\n+    public List<Task> getTasksWithStatus(TaskStatus... status) {\n+        return taskStore.getTasksWithStatus(status);\n+    }\n+\n+    @Override\n+    public Task removeTask(Task task) throws TaskStoreException {\n+        return taskStore.removeTask(task);\n+    }\n+\n+    @Override\n+    public void scheduleTask(Task task, int delayCount) {\n+\n+        // init session\n+        try {\n+            if (sess == null) {\n+                sess = perun.getPerunSession(new PerunPrincipal(\n+                                dispatcherProperties.getProperty(\"perun.principal.name\"),\n+                                dispatcherProperties.getProperty(\"perun.principal.extSourceName\"),\n+                                dispatcherProperties.getProperty(\"perun.principal.extSourceType\")),\n+                        new PerunClient());\n+            }\n+        } catch (InternalErrorException e1) {\n+            log.error(\"Error establishing perun session to add task schedule: \", e1);\n+            return;\n+        }\n+\n+        // check if service/facility exists\n+\n+        boolean removeTask = false;\n+\n+        try {\n+            Service service = perun.getServicesManager().getServiceById(sess, task.getServiceId());\n+            Facility facility = perun.getFacilitiesManager().getFacilityById(sess, task.getFacilityId());\n+            task.setService(service);\n+            task.setFacility(facility);\n+        } catch (ServiceNotExistsException e) {\n+            log.error(\"[{}] Task NOT added to waiting queue, service not exists: {}.\", task.getId(), task);\n+            removeTask = true;\n+        } catch (FacilityNotExistsException e) {\n+            log.error(\"[{}] Task NOT added to waiting queue, facility not exists: {}.\", task.getId(), task);\n+            removeTask = true;\n+        } catch (InternalErrorException | PrivilegeException e) {\n+            log.error(\"[{}] {}\", task.getId(), e);\n+        }\n+\n+        if (!task.getService().isEnabled() || ((PerunBl) perun).getServicesManagerBl().isServiceBlockedOnFacility(task.getService(), task.getFacility())) {\n+            log.error(\"[{}] Task NOT added to waiting queue, service is blocked: {}.\", task.getId(), task);\n+            // do not change Task status or any other data !\n+            if (!removeTask) {\n+                return;\n+            }\n+        }\n+\n+        try {\n+            List<Destination> destinations = perun.getServicesManager().getDestinations(sess, task.getService(), task.getFacility());\n+            if (destinations != null && !destinations.isEmpty()) {\n+                Iterator<Destination> iter = destinations.iterator();\n+                while (iter.hasNext()) {\n+                    Destination dest = iter.next();\n+                    if (((PerunBl) perun).getServicesManagerBl().isServiceBlockedOnDestination(task.getService(), dest.getId())) {\n+                        iter.remove();\n+                    }\n+                }\n+                if (destinations.isEmpty()) {\n+                    // All service destinations were blocked -> Task is denied to be sent to engine just like\n+                    // when service is blocked globally in Perun or on facility as a whole.\n+                    log.debug(\"[{}] Task NOT added to waiting queue, all its destinations are blocked.\", task.getId());\n+                    if (!removeTask) {\n+                        return;\n+                    }\n+                }\n+            }\n+\n+        } catch (ServiceNotExistsException e) {\n+            log.error(\"[{}] Task NOT added to waiting queue, service not exists: {}.\", task.getId(), task);\n+            removeTask = true;\n+        } catch (FacilityNotExistsException e) {\n+            log.error(\"[{}] Task NOT added to waiting queue, facility not exists: {}.\", task.getId(), task);\n+            removeTask = true;\n+        } catch (InternalErrorException | PrivilegeException e) {\n+            log.error(\"[{}] {}\", task.getId(), e);\n+        }\n+\n+        try {\n+            List<Service> assignedServices = perun.getServicesManager().getAssignedServices(sess, task.getFacility());\n+            if (!assignedServices.contains(task.getService())) {\n+                log.debug(\"[{}] Task NOT added to waiting queue, service is not assigned to facility any more: {}.\", task.getId(), task);\n+                if (!removeTask) {\n+                    return;\n+                }\n+            }\n+        } catch (FacilityNotExistsException e) {\n+            removeTask = true;\n+            log.error(\"[{}] Task removed from database, facility no longer exists: {}.\", task.getId(), task);\n+        } catch (InternalErrorException | PrivilegeException e) {\n+            log.error(\"[{}] Unable to check Service assignment to Facility: {}\", task.getId(), e.getMessage());\n+        }\n+\n+        if (removeTask) {\n+            // in memory task belongs to non existent facility/service - remove it and return\n+            try {\n+                removeTask(task);\n+                return;\n+            } catch (TaskStoreException e) {\n+                log.error(\"[{}] Unable to remove Task from pool: {}.\", task.getId(), e);\n+                return;\n+            }\n+        }\n+\n+        // Task is eligible for running - create new schedule\n+\n+        task.setSourceUpdated(false);\n+\n+        long newTaskDelay = 0;\n+        if (!task.isPropagationForced()) {\n+            // normal tasks are delayed\n+            try {\n+                newTaskDelay = Long.parseLong(dispatcherProperties.getProperty(\"dispatcher.task.delay.time\"));\n+            } catch (NumberFormatException e) {\n+                log.warn(\"Could not parse value of dispatcher.task.delay.time property. Using default.\");\n+                newTaskDelay = 30000;\n+            }\n+        }\n+        if (task.isPropagationForced()) {\n+            delayCount = 0;\n+        }\n+        if (delayCount < 0) {\n+            try {\n+                delayCount = Integer.parseInt(dispatcherProperties.getProperty(\"dispatcher.task.delay.count\"));\n+            } catch (NumberFormatException e) {\n+                log.warn(\"Could not parse value of dispatcher.task.delay.count property. Using default.\");\n+                delayCount = 4;\n+            }\n+        }\n+\n+        TaskSchedule schedule = new TaskSchedule(newTaskDelay, task);\n+        schedule.setBase(System.currentTimeMillis());\n+        schedule.setDelayCount(delayCount);\n+\n+        // Task was newly planned for propagation, switch state.\n+        if (!task.getStatus().equals(TaskStatus.WAITING)) {\n+\n+            task.setStatus(TaskStatus.WAITING);\n+            task.setSchedule(LocalDateTime.now());\n+            // clear previous timestamps\n+            task.setSentToEngine((LocalDateTime) null);\n+            task.setStartTime((LocalDateTime) null);\n+            task.setGenStartTime((LocalDateTime) null);\n+            task.setSendStartTime((LocalDateTime) null);\n+            task.setEndTime((LocalDateTime) null);\n+            task.setGenEndTime((LocalDateTime) null);\n+            task.setSendEndTime((LocalDateTime) null);\n+\n+            tasksManagerBl.updateTask(task);\n+\n+        }\n+\n+        boolean added = false;\n+\n+        if (schedule.getTask().isPropagationForced()) {\n+            added = waitingForcedTasksQueue.add(schedule);\n+        } else {\n+            added = waitingTasksQueue.add(schedule);\n+        }\n+\n+        if (!added) {\n+            log.error(\"[{}] Task could not be added to waiting queue. Shouldn't ever happen. Look to javadoc of DelayQueue. {}\", task.getId(), schedule);\n+        } else {\n+            log.debug(\"[{}] Task was added to waiting queue: {}\", task.getId(), schedule);\n+        }\n+\n+    }\n+\n+    /**\n+     * Adds Task and associated dispatcherQueue into scheduling pools internal maps and also to the database.\n+     *\n+     * @param task Task which will be added and persisted.\n+     * @return Number of Tasks in the pool.\n+     * @throws TaskStoreException\n+     */\n+    @Override\n+    public int addToPool(Task task) throws TaskStoreException {\n+\n+        if (task.getId() == 0) {\n+            if (getTask(task.getFacility(), task.getService()) == null) {\n+                int id = tasksManagerBl.insertTask(task);\n+                task.setId(id);\n+                log.debug(\"[{}] New Task stored in DB: {}\", task.getId(), task);\n+            } else {\n+                Task existingTask = tasksManagerBl.getTaskById(task.getId());\n+                if (existingTask == null) {\n+                    int id = tasksManagerBl.insertTask(task);\n+                    task.setId(id);\n+                    log.debug(\"[{}] New Task stored in DB: {}\", task.getId(), task);\n+                } else {\n+                    tasksManagerBl.updateTask(task);\n+                    log.debug(\"[{}] Task updated in the pool: {}\", task.getId(), task);\n+                }\n+            }\n+        }\n+        addTask(task);\n+        log.debug(\"[{}] Task added to the pool: {}\", task.getId(), task);\n+        return getSize();\n+    }\n+\n+    @Override\n+    public Task removeTask(int id) throws TaskStoreException {\n+        return taskStore.removeTask(id);\n+    }\n+\n+    @Override\n+    public String getReport() {\n+        int waiting = getTasksWithStatus(TaskStatus.WAITING).size();\n+        int planned = getTasksWithStatus(TaskStatus.PLANNED).size();\n+        int generating = getTasksWithStatus(TaskStatus.GENERATING).size();\n+        int generated = getTasksWithStatus(TaskStatus.GENERATED).size();\n+        int generror = getTasksWithStatus(TaskStatus.GENERROR).size();\n+        int sending = getTasksWithStatus(TaskStatus.SENDING).size();\n+        int senderror = getTasksWithStatus(TaskStatus.SENDERROR).size();\n+        int done = getTasksWithStatus(TaskStatus.DONE).size();\n+        int warning = getTasksWithStatus(TaskStatus.WARNING).size();\n+        int error = getTasksWithStatus(TaskStatus.ERROR).size();\n+\n+        return \"Dispatcher SchedulingPool Task report:\\n\" +\n+                \"  WAITING: \" + waiting +\n+                \"  PLANNED: \" + planned +\n+                \"  GENERATING: \" + generating +\n+                \"  GENERATED: \" + generated +\n+                \"  GENERROR: \" + generror +\n+                \"  SENDING:  \" + sending +\n+                \"  SENDEEROR:  \" + senderror +\n+                \"  DONE: \" + done +\n+                \"  WARNING: \" + warning +\n+                \"  ERROR: \" + error;\n+    }\n+\n+    @Override\n+    public void clear() {\n+        taskStore.clear();\n+        waitingTasksQueue.clear();\n+        waitingForcedTasksQueue.clear();\n+    }\n+\n+    @Override\n+    public void reloadTasks() {\n+\n+        log.debug(\"Going to reload Tasks from database...\");\n+\n+        this.clear();\n+\n+        EngineMessageProducer queue = engineMessageProducerFactory.getProducer();\n+\n+        for (Task task : tasksManagerBl.listAllTasks()) {\n+            try {\n+                // just add DB Task to in-memory structure\n+                addToPool(task);\n+            } catch (TaskStoreException e) {\n+                log.error(\"Adding Task {} and Queue {} into SchedulingPool failed, so the Task will be lost.\", task, queue);\n+            }\n+\n+            // if service was not in DONE or any kind of ERROR - reschedule now\n+            // error/done tasks will be rescheduled later by periodic jobs !!\n+            if (!Arrays.asList(TaskStatus.DONE, TaskStatus.ERROR, TaskStatus.GENERROR, TaskStatus.SENDERROR, TaskStatus.WARNING).contains(task.getStatus())) {\n+                if (task.getStatus().equals(TaskStatus.WAITING)) {\n+                    // if were in WAITING, reset timestamp to now\n+                    task.setSchedule(LocalDateTime.now());\n+                    tasksManagerBl.updateTask(task);\n+                }\n+                scheduleTask(task, 0);\n+            }\n+\n+        }\n+\n+        log.debug(\"Reload of Tasks from database finished.\");\n+\n+    }\n+\n+    @Override\n+    public void closeTasksForEngine() {\n+\n+        List<Task> tasks = taskStore.getTasksWithStatus(\n+                TaskStatus.PLANNED,\n+                TaskStatus.GENERATING,\n+                TaskStatus.GENERATED,\n+                TaskStatus.SENDING,\n+                TaskStatus.WARNING\n+        );\n+\n+        // switch all processing tasks to error, remove the engine queue association\n+        log.debug(\"Switching processing tasks on engine to ERROR, the engine went down...\");\n+        for (Task task : tasks) {\n+            log.info(\"[{}] Switching Task to ERROR, the engine it was running on went down.\", task.getId());\n+            task.setStatus(TaskStatus.ERROR);\n+        }\n+\n+    }\n+\n+    @Override\n+    public void onTaskStatusChange(int taskId, String status, String milliseconds) {\n+\n+        Task task = getTask(taskId);\n+        if (task == null) {\n+            log.error(\"[{}] Received status update about Task which is not in Dispatcher anymore, will ignore it.\", taskId);\n+            return;\n+        }\n+\n+        TaskStatus oldStatus = task.getStatus();\n+        task.setStatus(TaskStatus.valueOf(status));\n+        long ms;\n+        try {\n+            ms = Long.valueOf(milliseconds);\n+        } catch (NumberFormatException e) {\n+            log.warn(\"[{}] Timestamp of change '{}' could not be parsed, current time will be used instead.\", task.getId(), milliseconds);\n+            ms = System.currentTimeMillis();\n+        }\n+        LocalDateTime changeDate = LocalDateTime.ofInstant(Instant.ofEpochMilli(ms), ZoneId.systemDefault());\n+\n+        switch (task.getStatus()) {\n+            case WAITING:\n+            case PLANNED:\n+                log.error(\"[{}] Received status change to {} from Engine, this should not happen.\", task.getId(), task.getStatus());\n+                return;\n+            case GENERATING:\n+                task.setStartTime(changeDate);\n+                task.setGenStartTime(changeDate);\n+                break;\n+            case GENERROR:\n+                task.setEndTime(changeDate);\n+            case GENERATED:\n+                task.setGenEndTime(changeDate);\n+                break;\n+            case SENDING:\n+                task.setSendStartTime(changeDate);\n+                break;\n+            case DONE:\n+            case WARNING:\n+            case SENDERROR:\n+                task.setSendEndTime(changeDate);\n+                task.setEndTime(changeDate);\n+                break;\n+            case ERROR:\n+                task.setEndTime(changeDate);\n+                break;\n+        }\n+\n+        tasksManagerBl.updateTask(task);\n+\n+        log.debug(\"[{}] Task status changed from {} to {} as reported by Engine: {}.\", task.getId(), oldStatus, task.getStatus(), task);\n+\n+    }\n+\n+    @Override\n+    public void onTaskDestinationComplete(String string) {\n+\n+        if (string == null || string.isEmpty()) {\n+            log.error(\"Could not parse TaskResult message from Engine.\");\n+            return;\n+        }\n+\n+        try {\n+            List<PerunBean> listOfBeans = AuditParser.parseLog(string);\n+            if (!listOfBeans.isEmpty()) {\n+                TaskResult taskResult = (TaskResult) listOfBeans.get(0);\n+                log.debug(\"[{}] Received TaskResult for Task from Engine.\", taskResult.getTaskId());\n+                onTaskDestinationComplete(taskResult);\n+            } else {\n+                log.error(\"No TaskResult found in message from Engine: {}.\", string);\n+            }\n+        } catch (Exception e) {\n+            log.error(\"Could not save TaskResult from Engine {}, {}\", string, e.getMessage());\n+        }\n+\n+    }\n+\n+    @Override\n+    public void onTaskDestinationComplete(TaskResult taskResult) {\n+        try {\n+            tasksManagerBl.insertNewTaskResult(taskResult);\n+        } catch (Exception e) {\n+            log.error(\"Could not save TaskResult from Engine, {}, {}\", taskResult, e.getMessage());\n+        }\n+    }\n \n }\n",
            "diff_size": 497
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/411/SchedulingPoolImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/codebuff/411/SchedulingPoolImpl.java\nindex 584621dee32..20d9fca428a 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/411/SchedulingPoolImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/codebuff/411/SchedulingPoolImpl.java\n@@ -24,11 +24,9 @@ import cz.metacentrum.perun.taskslib.model.Task.TaskStatus;\n import cz.metacentrum.perun.taskslib.model.TaskResult;\n import cz.metacentrum.perun.taskslib.model.TaskSchedule;\n import cz.metacentrum.perun.taskslib.service.TaskStore;\n-\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.springframework.beans.factory.annotation.Autowired;\n-\n import java.time.Instant;\n import java.time.LocalDateTime;\n import java.time.ZoneId;\n@@ -38,7 +36,6 @@ import java.util.Iterator;\n import java.util.List;\n import java.util.Properties;\n import java.util.concurrent.DelayQueue;\n-\n import javax.annotation.Resource;\n \n /**\n@@ -51,506 +48,467 @@ import javax.annotation.Resource;\n  * @author David \u0160arman\n  * @author Pavel Zl\u00e1mal <zlamal@cesnet.cz>\n  */\n+\n+\n @org.springframework.stereotype.Service(\"schedulingPool\")\n public class SchedulingPoolImpl implements SchedulingPool {\n \n-\tprivate final static Logger log = LoggerFactory.getLogger(SchedulingPoolImpl.class);\n \n-\tprivate PerunSession sess;\n+ private final static Logger log = LoggerFactory.getLogger(SchedulingPoolImpl.class);\n+ private PerunSession sess;\n+ private DelayQueue<TaskSchedule> waitingTasksQueue;\n+ private DelayQueue<TaskSchedule> waitingForcedTasksQueue;\n+ private Properties dispatcherProperties;\n+ private TaskStore taskStore;\n+ private TasksManagerBl tasksManagerBl;\n+ private EngineMessageProducerFactory engineMessageProducerFactory;\n+ private Perun perun;\n \n-\tprivate DelayQueue<TaskSchedule> waitingTasksQueue;\n-\tprivate DelayQueue<TaskSchedule> waitingForcedTasksQueue;\n-\tprivate Properties dispatcherProperties;\n-\tprivate TaskStore taskStore;\n-\tprivate TasksManagerBl tasksManagerBl;\n-\tprivate EngineMessageProducerFactory engineMessageProducerFactory;\n-\tprivate Perun perun;\n \n-\tpublic SchedulingPoolImpl() {\n-\t}\n+ public SchedulingPoolImpl() {}\n \n-\tpublic SchedulingPoolImpl(Properties dispatcherPropertiesBean,\n-\t\t\t\tTaskStore taskStore,\n-\t\t\t\tTasksManagerBl tasksManagerBl,\n-\t\t\t\tEngineMessageProducerFactory engineMessageProducerFactory) {\n-\t\tthis.dispatcherProperties = dispatcherPropertiesBean;\n-\t\tthis.taskStore = taskStore;\n-\t\tthis.tasksManagerBl = tasksManagerBl;\n-\t\tthis.engineMessageProducerFactory = engineMessageProducerFactory;\n-\t}\n \n+ public SchedulingPoolImpl(Properties dispatcherPropertiesBean, TaskStore taskStore, TasksManagerBl tasksManagerBl, EngineMessageProducerFactory engineMessageProducerFactory) {\n+  this.dispatcherProperties = dispatcherPropertiesBean;\n+  this.taskStore = taskStore;\n+  this.tasksManagerBl = tasksManagerBl;\n+  this.engineMessageProducerFactory = engineMessageProducerFactory;\n+ }\n \n-\t// ----- setters -------------------------------------\n \n+ // ----- setters -------------------------------------\n \n-\tpublic DelayQueue<TaskSchedule> getWaitingTasksQueue() {\n-\t\treturn waitingTasksQueue;\n-\t}\n+ public DelayQueue<TaskSchedule> getWaitingTasksQueue() {\n+  return waitingTasksQueue;\n+ }\n \n-\t@Autowired\n-\tpublic void setWaitingTasksQueue(DelayQueue<TaskSchedule> waitingTasksQueue) {\n-\t\tthis.waitingTasksQueue = waitingTasksQueue;\n-\t}\n+ @Autowired\n+ public void setWaitingTasksQueue(DelayQueue<TaskSchedule> waitingTasksQueue) {\n+  this.waitingTasksQueue = waitingTasksQueue;\n+ }\n \n-\tpublic DelayQueue<TaskSchedule> getWaitingForcedTasksQueue() {\n-\t\treturn waitingForcedTasksQueue;\n-\t}\n-\n-\t@Autowired\n-\tpublic void setWaitingForcedTasksQueue(DelayQueue<TaskSchedule> waitingForcedTasksQueue) {\n-\t\tthis.waitingForcedTasksQueue = waitingForcedTasksQueue;\n-\t}\n-\n-\tpublic Properties getDispatcherProperties() {\n-\t\treturn dispatcherProperties;\n-\t}\n-\n-\t@Resource(name=\"dispatcherPropertiesBean\")\n-\tpublic void setDispatcherProperties(Properties dispatcherProperties) {\n-\t\tthis.dispatcherProperties = dispatcherProperties;\n-\t}\n-\n-\tpublic TaskStore getTaskStore() {\n-\t\treturn taskStore;\n-\t}\n-\n-\t@Autowired\n-\tpublic void setTaskStore(TaskStore taskStore) {\n-\t\tthis.taskStore = taskStore;\n-\t}\n-\n-\tpublic TasksManagerBl getTasksManagerBl() {\n-\t\treturn tasksManagerBl;\n-\t}\n-\n-\t@Autowired\n-\tpublic void setTasksManagerBl(TasksManagerBl tasksManagerBl) {\n-\t\tthis.tasksManagerBl = tasksManagerBl;\n-\t}\n-\n-\tpublic EngineMessageProducerFactory getEngineMessageProducerPool() {\n-\t\treturn engineMessageProducerFactory;\n-\t}\n-\n-\t@Autowired\n-\tpublic void setEngineMessageProducerPool(EngineMessageProducerFactory engineMessageProducerPool) {\n-\t\tthis.engineMessageProducerFactory = engineMessageProducerPool;\n-\t}\n-\n-\tpublic Perun getPerun() {\n-\t\treturn perun;\n-\t}\n-\n-\t@Autowired\n-\tpublic void setPerun(Perun perun) {\n-\t\tthis.perun = perun;\n-\t}\n-\n-\n-\t// ----- methods -------------------------------------\n-\n-\n-\t@Override\n-\tpublic Task getTask(int id) {\n-\t\treturn taskStore.getTask(id);\n-\t}\n-\n-\t@Override\n-\tpublic Task getTask(Facility facility, Service service) {\n-\t\treturn taskStore.getTask(facility, service);\n-\t}\n-\n-\t@Override\n-\tpublic int getSize() {\n-\t\treturn taskStore.getSize();\n-\t}\n-\n-\t@Override\n-\tpublic Task addTask(Task task) throws TaskStoreException {\n-\t\treturn taskStore.addTask(task);\n-\t}\n-\n-\t@Override\n-\tpublic Collection<Task> getAllTasks() {\n-\t\treturn taskStore.getAllTasks();\n-\t}\n-\n-\t@Override\n-\tpublic List<Task> getTasksWithStatus(TaskStatus... status) {\n-\t\treturn taskStore.getTasksWithStatus(status);\n-\t}\n-\n-\t@Override\n-\tpublic Task removeTask(Task task) throws TaskStoreException {\n-\t\treturn taskStore.removeTask(task);\n-\t}\n-\n-\t@Override\n-\tpublic void scheduleTask(Task task, int delayCount) {\n-\n-\t\t// init session\n-\t\ttry {\n-\t\t\tif (sess == null) {\n-\t\t\t\tsess = perun.getPerunSession(new PerunPrincipal(\n-\t\t\t\t\t\t\t\tdispatcherProperties.getProperty(\"perun.principal.name\"),\n-\t\t\t\t\t\t\t\tdispatcherProperties.getProperty(\"perun.principal.extSourceName\"),\n-\t\t\t\t\t\t\t\tdispatcherProperties.getProperty(\"perun.principal.extSourceType\")),\n-\t\t\t\t\t\tnew PerunClient());\n-\t\t\t}\n-\t\t} catch (InternalErrorException e1) {\n-\t\t\tlog.error(\"Error establishing perun session to add task schedule: \", e1);\n-\t\t\treturn;\n-\t\t}\n-\n-\t\t// check if service/facility exists\n-\n-\t\tboolean removeTask = false;\n-\n-\t\ttry {\n-\t\t\tService service = perun.getServicesManager().getServiceById(sess, task.getServiceId());\n-\t\t\tFacility facility = perun.getFacilitiesManager().getFacilityById(sess, task.getFacilityId());\n-\t\t\ttask.setService(service);\n-\t\t\ttask.setFacility(facility);\n-\t\t} catch (ServiceNotExistsException e) {\n-\t\t\tlog.error(\"[{}] Task NOT added to waiting queue, service not exists: {}.\", task.getId(), task);\n-\t\t\tremoveTask = true;\n-\t\t} catch (FacilityNotExistsException e) {\n-\t\t\tlog.error(\"[{}] Task NOT added to waiting queue, facility not exists: {}.\", task.getId(), task);\n-\t\t\tremoveTask = true;\n-\t\t}  catch (InternalErrorException | PrivilegeException e) {\n-\t\t\tlog.error(\"[{}] {}\", task.getId(), e);\n-\t\t}\n-\n-\t\tif (!task.getService().isEnabled() || ((PerunBl) perun).getServicesManagerBl().isServiceBlockedOnFacility(task.getService(), task.getFacility())) {\n-\t\t\tlog.error(\"[{}] Task NOT added to waiting queue, service is blocked: {}.\", task.getId(), task);\n-\t\t\t// do not change Task status or any other data !\n-\t\t\tif (!removeTask) return;\n-\t\t}\n-\n-\t\ttry {\n-\t\t\tList<Destination> destinations = perun.getServicesManager().getDestinations(sess, task.getService(), task.getFacility());\n-\t\t\tif (destinations != null && !destinations.isEmpty()) {\n-\t\t\t\tIterator<Destination> iter = destinations.iterator();\n-\t\t\t\twhile (iter.hasNext()) {\n-\t\t\t\t\tDestination dest = iter.next();\n-\t\t\t\t\tif (((PerunBl) perun).getServicesManagerBl().isServiceBlockedOnDestination(task.getService(), dest.getId())) {\n-\t\t\t\t\t\titer.remove();\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tif (destinations.isEmpty()) {\n-\t\t\t\t\t// All service destinations were blocked -> Task is denied to be sent to engine just like\n-\t\t\t\t\t// when service is blocked globally in Perun or on facility as a whole.\n-\t\t\t\t\tlog.debug(\"[{}] Task NOT added to waiting queue, all its destinations are blocked.\", task.getId());\n-\t\t\t\t\tif (!removeTask) return;\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t} catch (ServiceNotExistsException e) {\n-\t\t\tlog.error(\"[{}] Task NOT added to waiting queue, service not exists: {}.\", task.getId(), task);\n-\t\t\tremoveTask = true;\n-\t\t} catch (FacilityNotExistsException e) {\n-\t\t\tlog.error(\"[{}] Task NOT added to waiting queue, facility not exists: {}.\", task.getId(), task);\n-\t\t\tremoveTask = true;\n-\t\t}  catch (InternalErrorException | PrivilegeException e) {\n-\t\t\tlog.error(\"[{}] {}\", task.getId(), e);\n-\t\t}\n-\n-\t\ttry {\n-\t\t\tList<Service> assignedServices = perun.getServicesManager().getAssignedServices(sess, task.getFacility());\n-\t\t\tif (!assignedServices.contains(task.getService())) {\n-\t\t\t\tlog.debug(\"[{}] Task NOT added to waiting queue, service is not assigned to facility any more: {}.\", task.getId(), task);\n-\t\t\t\tif (!removeTask) return;\n-\t\t\t}\n-\t\t} catch (FacilityNotExistsException e) {\n-\t\t\tremoveTask = true;\n-\t\t\tlog.error(\"[{}] Task removed from database, facility no longer exists: {}.\", task.getId(), task);\n-\t\t} catch (InternalErrorException | PrivilegeException e) {\n-\t\t\tlog.error(\"[{}] Unable to check Service assignment to Facility: {}\", task.getId(), e.getMessage());\n-\t\t}\n-\n-\t\tif (removeTask) {\n-\t\t\t// in memory task belongs to non existent facility/service - remove it and return\n-\t\t\ttry {\n-\t\t\t\tremoveTask(task);\n-\t\t\t\treturn;\n-\t\t\t} catch (TaskStoreException e) {\n-\t\t\t\tlog.error(\"[{}] Unable to remove Task from pool: {}.\", task.getId(), e);\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t}\n-\n-\t\t// Task is eligible for running - create new schedule\n-\n-\t\ttask.setSourceUpdated(false);\n-\n-\t\tlong newTaskDelay = 0;\n-\t\tif (!task.isPropagationForced()) {\n-\t\t\t// normal tasks are delayed\n-\t\t\ttry {\n-\t\t\t\tnewTaskDelay = Long.parseLong(dispatcherProperties.getProperty(\"dispatcher.task.delay.time\"));\n-\t\t\t} catch (NumberFormatException e) {\n-\t\t\t\tlog.warn(\"Could not parse value of dispatcher.task.delay.time property. Using default.\");\n-\t\t\t\tnewTaskDelay = 30000;\n-\t\t\t}\n-\t\t}\n-\t\tif (task.isPropagationForced()) {\n-\t\t\tdelayCount = 0;\n-\t\t}\n-\t\tif (delayCount < 0) {\n-\t\t\ttry {\n-\t\t\t\tdelayCount = Integer.parseInt(dispatcherProperties.getProperty(\"dispatcher.task.delay.count\"));\n-\t\t\t} catch (NumberFormatException e) {\n-\t\t\t\tlog.warn(\"Could not parse value of dispatcher.task.delay.count property. Using default.\");\n-\t\t\t\tdelayCount = 4;\n-\t\t\t}\n-\t\t}\n-\n-\t\tTaskSchedule schedule = new TaskSchedule(newTaskDelay, task);\n-\t\tschedule.setBase(System.currentTimeMillis());\n-\t\tschedule.setDelayCount(delayCount);\n-\n-\t\t// Task was newly planned for propagation, switch state.\n-\t\tif (!task.getStatus().equals(TaskStatus.WAITING)) {\n-\n-\t\t\ttask.setStatus(TaskStatus.WAITING);\n-\t\t\ttask.setSchedule(LocalDateTime.now());\n-\t\t\t// clear previous timestamps\n-\t\t\ttask.setSentToEngine((LocalDateTime) null);\n-\t\t\ttask.setStartTime((LocalDateTime) null);\n-\t\t\ttask.setGenStartTime((LocalDateTime) null);\n-\t\t\ttask.setSendStartTime((LocalDateTime) null);\n-\t\t\ttask.setEndTime((LocalDateTime) null);\n-\t\t\ttask.setGenEndTime((LocalDateTime) null);\n-\t\t\ttask.setSendEndTime((LocalDateTime) null);\n-\n-\t\t\ttasksManagerBl.updateTask(task);\n-\n-\t\t}\n-\n-\t\tboolean added = false;\n-\n-\t\tif (schedule.getTask().isPropagationForced()) {\n-\t\t\tadded = waitingForcedTasksQueue.add(schedule);\n-\t\t} else {\n-\t\t\tadded = waitingTasksQueue.add(schedule);\n-\t\t}\n-\n-\t\tif (!added) {\n-\t\t\tlog.error(\"[{}] Task could not be added to waiting queue. Shouldn't ever happen. Look to javadoc of DelayQueue. {}\", task.getId(), schedule);\n-\t\t} else {\n-\t\t\tlog.debug(\"[{}] Task was added to waiting queue: {}\", task.getId(), schedule);\n-\t\t}\n-\n-\t}\n-\n-\t/**\n-\t * Adds Task and associated dispatcherQueue into scheduling pools internal maps and also to the database.\n-\t *\n-\t * @param task            Task which will be added and persisted.\n-\t * @return Number of Tasks in the pool.\n-\t * @throws TaskStoreException\n-\t */\n-\t@Override\n-\tpublic int addToPool(Task task) throws TaskStoreException {\n-\n-\t\tif (task.getId() == 0) {\n-\t\t\tif (getTask(task.getFacility(), task.getService()) == null) {\n-\t\t\t\tint id = tasksManagerBl.insertTask(task);\n-\t\t\t\ttask.setId(id);\n-\t\t\t\tlog.debug(\"[{}] New Task stored in DB: {}\", task.getId(), task);\n-\t\t\t} else {\n-\t\t\t\tTask existingTask = tasksManagerBl.getTaskById(task.getId());\n-\t\t\t\tif (existingTask == null) {\n-\t\t\t\t\tint id = tasksManagerBl.insertTask(task);\n-\t\t\t\t\ttask.setId(id);\n-\t\t\t\t\tlog.debug(\"[{}] New Task stored in DB: {}\", task.getId(), task);\n-\t\t\t\t} else {\n-\t\t\t\t\ttasksManagerBl.updateTask(task);\n-\t\t\t\t\tlog.debug(\"[{}] Task updated in the pool: {}\", task.getId(), task);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\taddTask(task);\n-\t\tlog.debug(\"[{}] Task added to the pool: {}\", task.getId(), task);\n-\t\treturn getSize();\n-\t}\n-\n-\t@Override\n-\tpublic Task removeTask(int id) throws TaskStoreException {\n-\t\treturn taskStore.removeTask(id);\n-\t}\n-\n-\t@Override\n-\tpublic String getReport() {\n-\t\tint waiting = getTasksWithStatus(TaskStatus.WAITING).size();\n-\t\tint planned = getTasksWithStatus(TaskStatus.PLANNED).size();\n-\t\tint generating = getTasksWithStatus(TaskStatus.GENERATING).size();\n-\t\tint generated = getTasksWithStatus(TaskStatus.GENERATED).size();\n-\t\tint generror = getTasksWithStatus(TaskStatus.GENERROR).size();\n-\t\tint sending = getTasksWithStatus(TaskStatus.SENDING).size();\n-\t\tint senderror = getTasksWithStatus(TaskStatus.SENDERROR).size();\n-\t\tint done = getTasksWithStatus(TaskStatus.DONE).size();\n-\t\tint warning = getTasksWithStatus(TaskStatus.WARNING).size();\n-\t\tint error = getTasksWithStatus(TaskStatus.ERROR).size();\n-\n-\t\treturn \"Dispatcher SchedulingPool Task report:\\n\" +\n-\t\t\t\t\"  WAITING: \" + waiting +\n-\t\t\t\t\"  PLANNED: \" + planned +\n-\t\t\t\t\"  GENERATING: \" + generating +\n-\t\t\t\t\"  GENERATED: \" + generated +\n-\t\t\t\t\"  GENERROR: \" + generror +\n-\t\t\t\t\"  SENDING:  \" + sending +\n-\t\t\t\t\"  SENDEEROR:  \" + senderror +\n-\t\t\t\t\"  DONE: \" + done +\n-\t\t\t\t\"  WARNING: \" + warning + \n-\t\t\t\t\"  ERROR: \" + error;\n-\t}\n-\n-\t@Override\n-\tpublic void clear() {\n-\t\ttaskStore.clear();\n-\t\twaitingTasksQueue.clear();\n-\t\twaitingForcedTasksQueue.clear();\n-\t}\n-\n-\t@Override\n-\tpublic void reloadTasks() {\n-\n-\t\tlog.debug(\"Going to reload Tasks from database...\");\n-\n-\t\tthis.clear();\n-\n-\t\tEngineMessageProducer queue = engineMessageProducerFactory.getProducer();\n-\n-\t\tfor (Task task : tasksManagerBl.listAllTasks()) {\n-\t\t\ttry {\n-\t\t\t\t// just add DB Task to in-memory structure\n-\t\t\t\taddToPool(task);\n-\t\t\t} catch (TaskStoreException e) {\n-\t\t\t\tlog.error(\"Adding Task {} and Queue {} into SchedulingPool failed, so the Task will be lost.\", task, queue);\n-\t\t\t}\n-\n-\t\t\t// if service was not in DONE or any kind of ERROR - reschedule now\n-\t\t\t// error/done tasks will be rescheduled later by periodic jobs !!\n-\t\t\tif (!Arrays.asList(TaskStatus.DONE, TaskStatus.ERROR, TaskStatus.GENERROR, TaskStatus.SENDERROR, TaskStatus.WARNING).contains(task.getStatus())) {\n-\t\t\t\tif (task.getStatus().equals(TaskStatus.WAITING)) {\n-\t\t\t\t\t// if were in WAITING, reset timestamp to now\n-\t\t\t\t\ttask.setSchedule(LocalDateTime.now());\n-\t\t\t\t\ttasksManagerBl.updateTask(task);\n-\t\t\t\t}\n-\t\t\t\tscheduleTask(task, 0);\n-\t\t\t}\n-\n-\t\t}\n-\n-\t\tlog.debug(\"Reload of Tasks from database finished.\");\n-\n-\t}\n-\n-\t@Override\n-\tpublic void closeTasksForEngine() {\n-\n-\t\tList<Task> tasks = taskStore.getTasksWithStatus(\n-\t\t\t\tTaskStatus.PLANNED,\n-\t\t\t\tTaskStatus.GENERATING,\n-\t\t\t\tTaskStatus.GENERATED,\n-\t\t\t\tTaskStatus.SENDING,\n-\t\t\t\tTaskStatus.WARNING\n-\t\t\t\t);\n-\n-\t\t// switch all processing tasks to error, remove the engine queue association\n-\t\tlog.debug(\"Switching processing tasks on engine to ERROR, the engine went down...\");\n-\t\tfor (Task task : tasks) {\n-\t\t\tlog.info(\"[{}] Switching Task to ERROR, the engine it was running on went down.\", task.getId());\n-\t\t\ttask.setStatus(TaskStatus.ERROR);\n-\t\t}\n-\n-\t}\n-\n-\t@Override\n-\tpublic void onTaskStatusChange(int taskId, String status, String milliseconds) {\n-\n-\t\tTask task = getTask(taskId);\n-\t\tif (task == null) {\n-\t\t\tlog.error(\"[{}] Received status update about Task which is not in Dispatcher anymore, will ignore it.\", taskId);\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tTaskStatus oldStatus = task.getStatus();\n-\t\ttask.setStatus(TaskStatus.valueOf(status));\n-\t\tlong ms;\n-\t\ttry {\n-\t\t\tms = Long.valueOf(milliseconds);\n-\t\t} catch (NumberFormatException e) {\n-\t\t\tlog.warn(\"[{}] Timestamp of change '{}' could not be parsed, current time will be used instead.\", task.getId(), milliseconds);\n-\t\t\tms = System.currentTimeMillis();\n-\t\t}\n-\t\tLocalDateTime changeDate = LocalDateTime.ofInstant(Instant.ofEpochMilli(ms), ZoneId.systemDefault());\n-\n-\t\tswitch (task.getStatus()) {\n-\t\t\tcase WAITING:\n-\t\t\tcase PLANNED:\n-\t\t\t\tlog.error(\"[{}] Received status change to {} from Engine, this should not happen.\", task.getId(), task.getStatus());\n-\t\t\t\treturn;\n-\t\t\tcase GENERATING:\n-\t\t\t\ttask.setStartTime(changeDate);\n-\t\t\t\ttask.setGenStartTime(changeDate);\n-\t\t\t\tbreak;\n-\t\t\tcase GENERROR:\n-\t\t\t\ttask.setEndTime(changeDate);\n-\t\t\tcase GENERATED:\n-\t\t\t\ttask.setGenEndTime(changeDate);\n-\t\t\t\tbreak;\n-\t\t\tcase SENDING:\n-\t\t\t\ttask.setSendStartTime(changeDate);\n-\t\t\t\tbreak;\n-\t\t\tcase DONE:\n-\t\t\tcase WARNING:\n-\t\t\tcase SENDERROR:\n-\t\t\t\ttask.setSendEndTime(changeDate);\n-\t\t\t\ttask.setEndTime(changeDate);\n-\t\t\t\tbreak;\n-\t\t\tcase ERROR:\n-\t\t\t\ttask.setEndTime(changeDate);\n-\t\t\t\tbreak;\n-\t\t}\n-\n-\t\ttasksManagerBl.updateTask(task);\n-\n-\t\tlog.debug(\"[{}] Task status changed from {} to {} as reported by Engine: {}.\", task.getId(), oldStatus, task.getStatus(), task);\n-\n-\t}\n-\n-\t@Override\n-\tpublic void onTaskDestinationComplete(String string) {\n-\n-\t\tif (string == null || string.isEmpty()) {\n-\t\t\tlog.error(\"Could not parse TaskResult message from Engine.\");\n-\t\t\treturn;\n-\t\t}\n-\n-\t\ttry {\n-\t\t\tList<PerunBean> listOfBeans = AuditParser.parseLog(string);\n-\t\t\tif (!listOfBeans.isEmpty()) {\n-\t\t\t\tTaskResult taskResult = (TaskResult) listOfBeans.get(0);\n-\t\t\t\tlog.debug(\"[{}] Received TaskResult for Task from Engine.\", taskResult.getTaskId());\n-\t\t\t\tonTaskDestinationComplete(taskResult);\n-\t\t\t} else {\n-\t\t\t\tlog.error(\"No TaskResult found in message from Engine: {}.\", string);\n-\t\t\t}\n-\t\t} catch (Exception e) {\n-\t\t\tlog.error(\"Could not save TaskResult from Engine {}, {}\", string, e.getMessage());\n-\t\t}\n-\n-\t}\n-\n-\t@Override\n-\tpublic void onTaskDestinationComplete(TaskResult taskResult) {\n-\t\ttry {\n-\t\t\ttasksManagerBl.insertNewTaskResult(taskResult);\n-\t\t} catch (Exception e) {\n-\t\t\tlog.error(\"Could not save TaskResult from Engine, {}, {}\", taskResult, e.getMessage());\n-\t\t}\n-\t}\n-\n-}\n+ public DelayQueue<TaskSchedule> getWaitingForcedTasksQueue() {\n+  return waitingForcedTasksQueue;\n+ }\n+\n+ @Autowired\n+ public void setWaitingForcedTasksQueue(DelayQueue<TaskSchedule> waitingForcedTasksQueue) {\n+  this.waitingForcedTasksQueue = waitingForcedTasksQueue;\n+ }\n+\n+ public Properties getDispatcherProperties() {\n+  return dispatcherProperties;\n+ }\n+\n+ @Resource(name = \"dispatcherPropertiesBean\")\n+ public void setDispatcherProperties(Properties dispatcherProperties) {\n+  this.dispatcherProperties = dispatcherProperties;\n+ }\n+\n+ public TaskStore getTaskStore() {\n+  return taskStore;\n+ }\n+\n+ @Autowired\n+ public void setTaskStore(TaskStore taskStore) {\n+  this.taskStore = taskStore;\n+ }\n+\n+ public TasksManagerBl getTasksManagerBl() {\n+  return tasksManagerBl;\n+ }\n+\n+ @Autowired\n+ public void setTasksManagerBl(TasksManagerBl tasksManagerBl) {\n+  this.tasksManagerBl = tasksManagerBl;\n+ }\n+\n+ public EngineMessageProducerFactory getEngineMessageProducerPool() {\n+  return engineMessageProducerFactory;\n+ }\n+\n+ @Autowired\n+ public void setEngineMessageProducerPool(EngineMessageProducerFactory engineMessageProducerPool) {\n+  this.engineMessageProducerFactory = engineMessageProducerPool;\n+ }\n+\n+ public Perun getPerun() {\n+  return perun;\n+ }\n+\n+ @Autowired\n+ public void setPerun(Perun perun) {\n+  this.perun = perun;\n+ }\n+\n+\n+ // ----- methods -------------------------------------\n+\n+ @Override\n+ public Task getTask(int id) {\n+  return taskStore.getTask(id);\n+ }\n+\n+ @Override\n+ public Task getTask(Facility facility, Service service) {\n+  return taskStore.getTask(facility, service);\n+ }\n+\n+ @Override\n+ public int getSize() {\n+  return taskStore.getSize();\n+ }\n+\n+ @Override\n+ public Task addTask(Task task) throws TaskStoreException {\n+  return taskStore.addTask(task);\n+ }\n+\n+ @Override\n+ public Collection<Task> getAllTasks() {\n+  return taskStore.getAllTasks();\n+ }\n+\n+ @Override\n+ public List<Task> getTasksWithStatus(TaskStatus... status) {\n+  return taskStore.getTasksWithStatus(status);\n+ }\n+\n+ @Override\n+ public Task removeTask(Task task) throws TaskStoreException {\n+  return taskStore.removeTask(task);\n+ }\n+\n+ @Override\n+ public void scheduleTask(Task task, int delayCount) {\n+\n+  // init session\n+  try {\n+   if (sess == null) {\n+    sess = perun.getPerunSession(\n+     new PerunPrincipal(dispatcherProperties.getProperty(\"perun.principal.name\"), dispatcherProperties.getProperty(\"perun.principal.extSourceName\"), dispatcherProperties.getProperty(\"perun.principal.extSourceType\")), new PerunClient());\n+   }\n+  } catch (InternalErrorException e1) {\n+   log.error(\"Error establishing perun session to add task schedule: \", e1);\n+   return;\n+  }\n+\n+  // check if service/facility exists\n+\n+  boolean removeTask = false;\n+  try {\n+   Service service = perun.getServicesManager().getServiceById(sess, task.getServiceId());\n+   Facility facility = perun.getFacilitiesManager().getFacilityById(sess, task.getFacilityId());\n+   task.setService(service);\n+   task.setFacility(facility);\n+  } catch (ServiceNotExistsException e) {\n+   log.error(\"[{}] Task NOT added to waiting queue, service not exists: {}.\", task.getId(), task);\n+   removeTask = true;\n+  } catch (FacilityNotExistsException e) {\n+   log.error(\"[{}] Task NOT added to waiting queue, facility not exists: {}.\", task.getId(), task);\n+   removeTask = true;\n+  } catch (InternalErrorException | PrivilegeException e) {\n+   log.error(\"[{}] {}\", task.getId(), e);\n+  }\n+  if (!task.getService().isEnabled() || ((PerunBl) perun).getServicesManagerBl().isServiceBlockedOnFacility(task.getService(), task.getFacility())) {\n+   log.error(\"[{}] Task NOT added to waiting queue, service is blocked: {}.\", task.getId(), task);\n+   // do not change Task status or any other data !\n+   if (!removeTask)\n+    return;\n+  }\n+\n+  try {\n+   List<Destination> destinations = perun.getServicesManager().getDestinations(sess, task.getService(), task.getFacility());\n+   if (destinations != null && !destinations.isEmpty()) {\n+    Iterator<Destination> iter = destinations.iterator();\n+    while (iter.hasNext()) {\n+     Destination dest = iter.next();\n+     if (((PerunBl) perun).getServicesManagerBl().isServiceBlockedOnDestination(task.getService(), dest.getId())) {\n+      iter.remove();\n+     }\n+    }\n+    if (destinations.isEmpty()) {\n+     // All service destinations were blocked -> Task is denied to be sent to engine just like\n+     // when service is blocked globally in Perun or on facility as a whole.\n+     log.debug(\"[{}] Task NOT added to waiting queue, all its destinations are blocked.\", task.getId());\n+     if (!removeTask)\n+      return;\n+    }\n+   }\n+  } catch (ServiceNotExistsException e) {\n+   log.error(\"[{}] Task NOT added to waiting queue, service not exists: {}.\", task.getId(), task);\n+   removeTask = true;\n+  } catch (FacilityNotExistsException e) {\n+   log.error(\"[{}] Task NOT added to waiting queue, facility not exists: {}.\", task.getId(), task);\n+   removeTask = true;\n+  } catch (InternalErrorException | PrivilegeException e) {\n+   log.error(\"[{}] {}\", task.getId(), e);\n+  }\n+\n+  try {\n+   List<Service> assignedServices = perun.getServicesManager().getAssignedServices(sess, task.getFacility());\n+   if (!assignedServices.contains(task.getService())) {\n+    log.debug(\"[{}] Task NOT added to waiting queue, service is not assigned to facility any more: {}.\",\n+    task.getId(),\n+    task);\n+    if (!removeTask)\n+     return;\n+   }\n+  } catch (FacilityNotExistsException e) {\n+   removeTask = true;\n+   log.error(\"[{}] Task removed from database, facility no longer exists: {}.\", task.getId(), task);\n+  } catch (InternalErrorException | PrivilegeException e) {\n+   log.error(\"[{}] Unable to check Service assignment to Facility: {}\", task.getId(), e.getMessage());\n+  }\n+  if (removeTask) {\n+   // in memory task belongs to non existent facility/service - remove it and return\n+   try {\n+    removeTask(task);\n+    return;\n+   } catch (TaskStoreException e) {\n+    log.error(\"[{}] Unable to remove Task from pool: {}.\", task.getId(), e);\n+    return;\n+   }\n+  }\n+\n+  // Task is eligible for running - create new schedule\n+  task.setSourceUpdated(false);\n+  long newTaskDelay = 0;\n+  if (!task.isPropagationForced()) {\n+   // normal tasks are delayed\n+   try {\n+    newTaskDelay = Long.parseLong(dispatcherProperties.getProperty(\"dispatcher.task.delay.time\"));\n+   } catch (NumberFormatException e) {\n+    log.warn(\"Could not parse value of dispatcher.task.delay.time property. Using default.\");\n+    newTaskDelay = 30000;\n+   }\n+  }\n+  if (task.isPropagationForced()) {\n+   delayCount = 0;\n+  }\n+  if (delayCount< 0) {\n+   try {\n+    delayCount = Integer.parseInt(dispatcherProperties.getProperty(\"dispatcher.task.delay.count\"));\n+   } catch (NumberFormatException e) {\n+    log.warn(\"Could not parse value of dispatcher.task.delay.count property. Using default.\");\n+    delayCount = 4;\n+   }\n+  }\n+  TaskSchedule schedule = new TaskSchedule(newTaskDelay, task);\n+  schedule.setBase(System.currentTimeMillis());\n+  schedule.setDelayCount(delayCount);\n+\n+  // Task was newly planned for propagation, switch state.\n+  if (!task.getStatus().equals(TaskStatus.WAITING)) {\n+   task.setStatus(TaskStatus.WAITING);\n+   task.setSchedule(LocalDateTime.now());\n+   // clear previous timestamps\n+   task.setSentToEngine((LocalDateTime) null);\n+   task.setStartTime((LocalDateTime) null);\n+   task.setGenStartTime((LocalDateTime) null);\n+   task.setSendStartTime((LocalDateTime) null);\n+   task.setEndTime((LocalDateTime) null);\n+   task.setGenEndTime((LocalDateTime) null);\n+   task.setSendEndTime((LocalDateTime) null);\n+   tasksManagerBl.updateTask(task);\n+  }\n+\n+  boolean added = false;\n+  if (schedule.getTask().isPropagationForced()) {\n+   added = waitingForcedTasksQueue.add(schedule);\n+  } else {\n+   added = waitingTasksQueue.add(schedule);\n+  }\n+  if (!added) {\n+   log.error(\"[{}] Task could not be added to waiting queue. Shouldn't ever happen. Look to javadoc of DelayQueue. {}\", task.getId(), schedule);\n+  } else {\n+   log.debug(\"[{}] Task was added to waiting queue: {}\", task.getId(), schedule);\n+  }\n+ }\n+\n+ /**\n+  * Adds Task and associated dispatcherQueue into scheduling pools internal maps and also to the database.\n+  *\n+  * @param task            Task which will be added and persisted.\n+  * @return Number of Tasks in the pool.\n+  * @throws TaskStoreException\n+  */\n+\n+ @Override\n+ public int addToPool(Task task) throws TaskStoreException {\n+  if (task.getId() == 0) {\n+   if (getTask(task.getFacility(), task.getService()) == null) {\n+    int id = tasksManagerBl.insertTask(task);\n+    task.setId(id);\n+    log.debug(\"[{}] New Task stored in DB: {}\", task.getId(), task);\n+   } else {\n+    Task existingTask = tasksManagerBl.getTaskById(task.getId());\n+    if (existingTask == null) {\n+     int id = tasksManagerBl.insertTask(task);\n+     task.setId(id);\n+     log.debug(\"[{}] New Task stored in DB: {}\", task.getId(), task);\n+    } else {\n+     tasksManagerBl.updateTask(task);\n+     log.debug(\"[{}] Task updated in the pool: {}\", task.getId(), task);\n+    }\n+   }\n+  }\n+  addTask(task);\n+  log.debug(\"[{}] Task added to the pool: {}\", task.getId(), task);\n+  return getSize();\n+ }\n+\n+ @Override\n+ public Task removeTask(int id) throws TaskStoreException {\n+  return taskStore.removeTask(id);\n+ }\n+\n+ @Override\n+ public String getReport() {\n+  int waiting = getTasksWithStatus(TaskStatus.WAITING).size();\n+  int planned = getTasksWithStatus(TaskStatus.PLANNED).size();\n+  int generating = getTasksWithStatus(TaskStatus.GENERATING).size();\n+  int generated = getTasksWithStatus(TaskStatus.GENERATED).size();\n+  int generror = getTasksWithStatus(TaskStatus.GENERROR).size();\n+  int sending = getTasksWithStatus(TaskStatus.SENDING).size();\n+  int senderror = getTasksWithStatus(TaskStatus.SENDERROR).size();\n+  int done = getTasksWithStatus(TaskStatus.DONE).size();\n+  int warning = getTasksWithStatus(TaskStatus.WARNING).size();\n+  int error = getTasksWithStatus(TaskStatus.ERROR).size();\n+  return \"Dispatcher SchedulingPool Task report:\\n\" + \"  WAITING: \" + waiting + \"  PLANNED: \" + planned + \"  GENERATING: \" + generating + \"  GENERATED: \" + generated + \"  GENERROR: \" + generror + \"  SENDING:  \" + sending + \"  SENDEEROR:  \" + senderror + \"  DONE: \" + done + \"  WARNING: \" + warning + \"  ERROR: \" + error;\n+ }\n+\n+ @Override\n+ public void clear() {\n+  taskStore.clear();\n+  waitingTasksQueue.clear();\n+  waitingForcedTasksQueue.clear();\n+ }\n+\n+ @Override\n+ public void reloadTasks() {\n+  log.debug(\"Going to reload Tasks from database...\");\n+  this.clear();\n+  EngineMessageProducer queue = engineMessageProducerFactory.getProducer();\n+  for (Task task : tasksManagerBl.listAllTasks()) {\n+   try {\n+    // just add DB Task to in-memory structure\n+    addToPool(task);\n+   } catch (TaskStoreException e) {\n+    log.error(\"Adding Task {} and Queue {} into SchedulingPool failed, so the Task will be lost.\", task, queue);\n+   }\n+\n+   // if service was not in DONE or any kind of ERROR - reschedule now\n+   // error/done tasks will be rescheduled later by periodic jobs !!\n+   if (!Arrays.asList(TaskStatus.DONE, TaskStatus.ERROR, TaskStatus.GENERROR, TaskStatus.SENDERROR, TaskStatus.WARNING).contains(task.getStatus())) {\n+    if (task.getStatus().equals(TaskStatus.WAITING)) {\n+     // if were in WAITING, reset timestamp to now\n+     task.setSchedule(LocalDateTime.now());\n+     tasksManagerBl.updateTask(task);\n+    }\n+    scheduleTask(task, 0);\n+   }\n+  }\n+  log.debug(\"Reload of Tasks from database finished.\");\n+ }\n+\n+ @Override\n+ public void closeTasksForEngine() {\n+  List<Task> tasks = taskStore.getTasksWithStatus(TaskStatus.PLANNED, TaskStatus.GENERATING, TaskStatus.GENERATED, TaskStatus.SENDING, TaskStatus.WARNING);\n+\n+  // switch all processing tasks to error, remove the engine queue association\n+  log.debug(\"Switching processing tasks on engine to ERROR, the engine went down...\");\n+  for (Task task : tasks) {\n+   log.info(\"[{}] Switching Task to ERROR, the engine it was running on went down.\", task.getId());\n+   task.setStatus(TaskStatus.ERROR);\n+  }\n+ }\n+\n+ @Override\n+ public void onTaskStatusChange(int taskId, String status, String milliseconds) {\n+  Task task = getTask(taskId);\n+  if (task == null) {\n+   log.error(\"[{}] Received status update about Task which is not in Dispatcher anymore, will ignore it.\", taskId);\n+   return;\n+  }\n+  TaskStatus oldStatus = task.getStatus();\n+  task.setStatus(TaskStatus.valueOf(status));\n+  long ms;\n+  try {\n+   ms = Long.valueOf(milliseconds);\n+  } catch (NumberFormatException e) {\n+   log.warn(\"[{}] Timestamp of change '{}' could not be parsed, current time will be used instead.\",\n+   task.getId(),\n+   milliseconds);\n+   ms = System.currentTimeMillis();\n+  }\n+  LocalDateTime changeDate = LocalDateTime.ofInstant(Instant.ofEpochMilli(ms), ZoneId.systemDefault());\n+\n+  switch (task.getStatus()) {\n+   case WAITING:\n+   case PLANNED:\n+    log.error(\"[{}] Received status change to {} from Engine, this should not happen.\",\n+    task.getId(),\n+    task.getStatus());\n+    return;\n+   case GENERATING:\n+    task.setStartTime(changeDate);\n+    task.setGenStartTime(changeDate);\n+    break;\n+   case GENERROR:\n+    task.setEndTime(changeDate);\n+   case GENERATED:\n+    task.setGenEndTime(changeDate);\n+    break;\n+   case SENDING:\n+    task.setSendStartTime(changeDate);\n+    break;\n+   case DONE:\n+   case WARNING:\n+   case SENDERROR:\n+    task.setSendEndTime(changeDate);\n+    task.setEndTime(changeDate);\n+    break;\n+   case ERROR:\n+    task.setEndTime(changeDate);\n+    break;\n+  }\n+  tasksManagerBl.updateTask(task);\n+  log.debug(\"[{}] Task status changed from {} to {} as reported by Engine: {}.\",\n+  task.getId(),\n+  oldStatus,\n+  task.getStatus(),\n+  task);\n+ }\n+\n+ @Override\n+ public void onTaskDestinationComplete(String string) {\n+  if (string == null || string.isEmpty()) {\n+   log.error(\"Could not parse TaskResult message from Engine.\");\n+   return;\n+  }\n+\n+  try {\n+   List<PerunBean> listOfBeans = AuditParser.parseLog(string);\n+   if (!listOfBeans.isEmpty()) {\n+    TaskResult taskResult = (TaskResult) listOfBeans.get(0);\n+    log.debug(\"[{}] Received TaskResult for Task from Engine.\", taskResult.getTaskId());\n+    onTaskDestinationComplete(taskResult);\n+   } else {\n+    log.error(\"No TaskResult found in message from Engine: {}.\", string);\n+   }\n+  } catch (Exception e) {\n+   log.error(\"Could not save TaskResult from Engine {}, {}\", string, e.getMessage());\n+  }\n+ }\n+\n+ @Override\n+ public void onTaskDestinationComplete(TaskResult taskResult) {\n+  try {\n+   tasksManagerBl.insertNewTaskResult(taskResult);\n+  } catch (Exception e) {\n+   log.error(\"Could not save TaskResult from Engine, {}, {}\", taskResult, e.getMessage());\n+  }\n+ }\n+\n+}\n\\ No newline at end of file\n",
            "diff_size": 510
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/411/SchedulingPoolImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/styler_random/411/SchedulingPoolImpl.java\nindex 584621dee32..75e8daeecc8 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/411/SchedulingPoolImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/styler_random/411/SchedulingPoolImpl.java\n@@ -402,7 +402,7 @@ public class SchedulingPoolImpl implements SchedulingPool {\n \t\t\t\t\"  SENDING:  \" + sending +\n \t\t\t\t\"  SENDEEROR:  \" + senderror +\n \t\t\t\t\"  DONE: \" + done +\n-\t\t\t\t\"  WARNING: \" + warning + \n+\t\t\t\t\"  WARNING: \" + warning +\n \t\t\t\t\"  ERROR: \" + error;\n \t}\n \n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/411/SchedulingPoolImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/styler_three_grams/411/SchedulingPoolImpl.java\nindex 584621dee32..8c35668a682 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/411/SchedulingPoolImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/styler_three_grams/411/SchedulingPoolImpl.java\n@@ -402,8 +402,7 @@ public class SchedulingPoolImpl implements SchedulingPool {\n \t\t\t\t\"  SENDING:  \" + sending +\n \t\t\t\t\"  SENDEEROR:  \" + senderror +\n \t\t\t\t\"  DONE: \" + done +\n-\t\t\t\t\"  WARNING: \" + warning + \n-\t\t\t\t\"  ERROR: \" + error;\n+\t\t\t\t\t\"  WARNING: \"+warning+\"  ERROR: \"+ error;\n \t}\n \n \t@Override\n",
            "diff_size": 2
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "naturalize"
    ]
}