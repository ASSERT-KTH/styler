{
    "project_name": "vostok-hercules",
    "error_id": "10",
    "information": {
        "errors": [
            {
                "line": "381",
                "column": "52",
                "severity": "warning",
                "message": "'{' is not preceded with whitespace.",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
            }
        ]
    },
    "source_code": "\n            errorTypesMeter.computeIfAbsent(type, this::createMeter).mark();\n            if (redefinedExceptions.contains(type)){\n                LOGGER.warn(\"Retryable error which will be regarded as non-retryable: index={}, id={}, type={}, reason={}\", index, id, type,reason);\n                return new ErrorResponseWrapper(ErrorType.NON_RETRYABLE, id, index, reason);\n            } else if (RETRYABLE_ERRORS_CODES.contains(type)) {",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/10/ElasticResponseHandler.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/styler/10/ElasticResponseHandler.java\nindex fdbab46dd5d..01123fe3de7 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/10/ElasticResponseHandler.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/styler/10/ElasticResponseHandler.java\n@@ -378,7 +378,7 @@ public class ElasticResponseHandler {\n             //TODO: Build \"caused by\" trace\n \n             errorTypesMeter.computeIfAbsent(type, this::createMeter).mark();\n-            if (redefinedExceptions.contains(type)){\n+            if (redefinedExceptions.contains(type)) {\n                 LOGGER.warn(\"Retryable error which will be regarded as non-retryable: index={}, id={}, type={}, reason={}\", index, id, type,reason);\n                 return new ErrorResponseWrapper(ErrorType.NON_RETRYABLE, id, index, reason);\n             } else if (RETRYABLE_ERRORS_CODES.contains(type)) {\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/10/ElasticResponseHandler.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/intellij/10/ElasticResponseHandler.java\nindex fdbab46dd5d..89b935c6cc5 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/10/ElasticResponseHandler.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/intellij/10/ElasticResponseHandler.java\n@@ -26,379 +26,379 @@ import static ru.kontur.vostok.hercules.util.throwable.ThrowableUtil.toUnchecked\n \n public class ElasticResponseHandler {\n \n-    public static class Result {\n-\n-        public static final Result OK = new Result(\n-                0,\n-                0,\n-                0,\n-                Collections.emptySet(),\n-                Collections.emptySet()\n-        );\n-\n-        private final int retryableErrorCount;\n-        private final int nonRetryableErrorCount;\n-        private final int unknownErrorCount;\n-        private final Set<String> badIds;\n-        private final Set<ErrorResponseWrapper> nonRetryableErrors;\n-\n-        public Result(\n-                int retryableErrorCount,\n-                int nonRetryableErrorCount,\n-                int unknownErrorCount,\n-                Set<String> badIds,\n-                Set<ErrorResponseWrapper> nonRetryableErrors\n-        ) {\n-            this.retryableErrorCount = retryableErrorCount;\n-            this.nonRetryableErrorCount = nonRetryableErrorCount;\n-            this.unknownErrorCount = unknownErrorCount;\n-            this.badIds = badIds;\n-            this.nonRetryableErrors = nonRetryableErrors;\n-        }\n-\n-        public int getRetryableErrorCount() {\n-            return retryableErrorCount;\n-        }\n-\n-        public int getNonRetryableErrorCount() {\n-            return nonRetryableErrorCount;\n-        }\n-\n-        public int getUnknownErrorCount() {\n-            return unknownErrorCount;\n-        }\n-\n-        public boolean hasRetryableErrors() {\n-            return retryableErrorCount != 0;\n-        }\n-\n-        public boolean hasUnknownErrors() {\n-            return unknownErrorCount != 0;\n-        }\n-\n-        public int getTotalErrors() {\n-            return retryableErrorCount + nonRetryableErrorCount + unknownErrorCount;\n-        }\n+  public static class Result {\n+\n+    public static final Result OK = new Result(\n+      0,\n+      0,\n+      0,\n+      Collections.emptySet(),\n+      Collections.emptySet()\n+    );\n+\n+    private final int retryableErrorCount;\n+    private final int nonRetryableErrorCount;\n+    private final int unknownErrorCount;\n+    private final Set<String> badIds;\n+    private final Set<ErrorResponseWrapper> nonRetryableErrors;\n+\n+    public Result(\n+      int retryableErrorCount,\n+      int nonRetryableErrorCount,\n+      int unknownErrorCount,\n+      Set<String> badIds,\n+      Set<ErrorResponseWrapper> nonRetryableErrors\n+    ) {\n+      this.retryableErrorCount = retryableErrorCount;\n+      this.nonRetryableErrorCount = nonRetryableErrorCount;\n+      this.unknownErrorCount = unknownErrorCount;\n+      this.badIds = badIds;\n+      this.nonRetryableErrors = nonRetryableErrors;\n+    }\n \n-        public Set<String> getBadIds() {\n-            return badIds;\n-        }\n+    public int getRetryableErrorCount() {\n+      return retryableErrorCount;\n+    }\n \n-        public Set<ErrorResponseWrapper> getNonRetryableErrors() {\n-            return nonRetryableErrors;\n-        }\n+    public int getNonRetryableErrorCount() {\n+      return nonRetryableErrorCount;\n+    }\n \n-        public boolean hasNonRetryableErrors() {\n-            return !nonRetryableErrors.isEmpty();\n-        }\n+    public int getUnknownErrorCount() {\n+      return unknownErrorCount;\n     }\n \n-    public class ErrorResponseWrapper {\n-        private final ErrorType type;\n-        private final String eventId;\n-        private final String index;\n-        private final String reason;\n-\n-        public ErrorResponseWrapper(ErrorType type, String eventId, String index, String reason) {\n-            this.type = type;\n-            this.eventId = eventId;\n-            this.index = index;\n-            this.reason = reason;\n-        }\n+    public boolean hasRetryableErrors() {\n+      return retryableErrorCount != 0;\n+    }\n \n-        public ErrorType getType() {\n-            return type;\n-        }\n+    public boolean hasUnknownErrors() {\n+      return unknownErrorCount != 0;\n+    }\n \n-        public String getEventId() {\n-            return eventId;\n-        }\n+    public int getTotalErrors() {\n+      return retryableErrorCount + nonRetryableErrorCount + unknownErrorCount;\n+    }\n \n-        public String getIndex() {\n-            return index;\n-        }\n+    public Set<String> getBadIds() {\n+      return badIds;\n+    }\n \n-        public String getReason() {\n-            return reason;\n-        }\n+    public Set<ErrorResponseWrapper> getNonRetryableErrors() {\n+      return nonRetryableErrors;\n     }\n \n-    public enum ErrorType {\n-        RETRYABLE,\n-        NON_RETRYABLE,\n-        UNKNOWN\n+    public boolean hasNonRetryableErrors() {\n+      return !nonRetryableErrors.isEmpty();\n+    }\n+  }\n+\n+  public class ErrorResponseWrapper {\n+    private final ErrorType type;\n+    private final String eventId;\n+    private final String index;\n+    private final String reason;\n+\n+    public ErrorResponseWrapper(ErrorType type, String eventId, String index, String reason) {\n+      this.type = type;\n+      this.eventId = eventId;\n+      this.index = index;\n+      this.reason = reason;\n     }\n \n-    static final Set<String> RETRYABLE_ERRORS_CODES = new HashSet<>(Arrays.asList(\n-            \"process_cluster_event_timeout_exception\",\n-            \"es_rejected_execution_exception\",\n-            \"cluster_block_exception\",\n-            \"unavailable_shards_exception\",\n-            \"timeout_exception\",\n-            \"master_not_discovered_exception\",\n-            \"connect_transport_exception\",\n-            \"primary_missing_action_exception\",\n-            \"concurrent_snapshot_execution_exception\",\n-            \"receive_timeout_transport_exception\",\n-            \"elasticsearch_timeout_exception\",\n-            \"no_shard_available_action_exception\",\n-            \"node_not_connected_exception\",\n-            \"node_disconnected_exception\",\n-            \"not_master_exception\",\n-            \"delay_recovery_exception\"\n-    ));\n-\n-    static final Set<String> NON_RETRYABLE_ERRORS_CODES = new HashSet<>(Arrays.asList(\n-            \"illegal_argument_exception\",\n-            \"mapper_parsing_exception\",\n-            \"illegal_state_exception\",\n-            \"invalid_index_name_exception\",\n-            \"index_closed_exception\",\n-            \"invalid_alias_name_exception\",\n-            \"elasticsearch_parse_exception\",\n-            \"invalid_type_name_exception\",\n-            \"parsing_exception\",\n-            \"index_template_missing_exception\",\n-            \"search_parse_exception\",\n-            \"timestamp_parsing_exception\",\n-            \"invalid_index_template_exception\",\n-            \"invalid_snapshot_name_exception\",\n-            \"document_source_missing_exception\",\n-            \"resource_already_exists_exception\",\n-            \"type_missing_exception\",\n-            \"index_shard_snapshot_failed_exception\",\n-            \"dfs_phase_execution_exception\",\n-            \"execution_cancelled_exception\",\n-            \"elasticsearch_security_exception\",\n-            \"index_shard_restore_exception\",\n-            \"bind_http_exception\",\n-            \"reduce_search_phase_exception\",\n-            \"node_closed_exception\",\n-            \"snapshot_failed_engine_exception\",\n-            \"shard_not_found_exception\",\n-            \"not_serializable_transport_exception\",\n-            \"response_handler_failure_transport_exception\",\n-            \"index_creation_exception\",\n-            \"index_not_found_exception\",\n-            \"illegal_shard_routing_state_exception\",\n-            \"broadcast_shard_operation_failed_exception\",\n-            \"resource_not_found_exception\",\n-            \"action_transport_exception\",\n-            \"elasticsearch_generation_exception\",\n-            \"index_shard_started_exception\",\n-            \"search_context_missing_exception\",\n-            \"general_script_exception\",\n-            \"snapshot_creation_exception\",\n-            \"document_missing_exception\",\n-            \"snapshot_exception\",\n-            \"index_primary_shard_not_allocated_exception\",\n-            \"transport_exception\",\n-            \"search_exception\",\n-            \"mapper_exception\",\n-            \"snapshot_restore_exception\",\n-            \"index_shard_closed_exception\",\n-            \"recover_files_recovery_exception\",\n-            \"truncated_translog_exception\",\n-            \"recovery_failed_exception\",\n-            \"index_shard_relocated_exception\",\n-            \"node_should_not_connect_exception\",\n-            \"translog_corrupted_exception\",\n-            \"fetch_phase_execution_exception\",\n-            \"version_conflict_engine_exception\",\n-            \"engine_exception\",\n-            \"no_such_node_exception\",\n-            \"settings_exception\",\n-            \"send_request_transport_exception\",\n-            \"not_serializable_exception_wrapper\",\n-            \"alias_filter_parsing_exception\",\n-            \"gateway_exception\",\n-            \"index_shard_not_recovering_exception\",\n-            \"http_exception\",\n-            \"elasticsearch_exception\",\n-            \"snapshot_missing_exception\",\n-            \"failed_node_exception\",\n-            \"blob_store_exception\",\n-            \"incompatible_cluster_state_version_exception\",\n-            \"recovery_engine_exception\",\n-            \"uncategorized_execution_exception\",\n-            \"routing_missing_exception\",\n-            \"index_shard_restore_failed_exception\",\n-            \"repository_exception\",\n-            \"aggregation_execution_exception\",\n-            \"refresh_failed_engine_exception\",\n-            \"aggregation_initialization_exception\",\n-            \"no_node_available_exception\",\n-            \"illegal_index_shard_state_exception\",\n-            \"index_shard_snapshot_exception\",\n-            \"index_shard_not_started_exception\",\n-            \"search_phase_execution_exception\",\n-            \"action_not_found_transport_exception\",\n-            \"transport_serialization_exception\",\n-            \"remote_transport_exception\",\n-            \"engine_creation_failure_exception\",\n-            \"routing_exception\",\n-            \"index_shard_recovery_exception\",\n-            \"repository_missing_exception\",\n-            \"no_class_settings_exception\",\n-            \"bind_transport_exception\",\n-            \"aliases_not_found_exception\",\n-            \"index_shard_recovering_exception\",\n-            \"translog_exception\",\n-            \"retry_on_primary_exception\",\n-            \"query_phase_execution_exception\",\n-            \"repository_verification_exception\",\n-            \"invalid_aggregation_path_exception\",\n-            \"http_on_transport_exception\",\n-            \"search_context_exception\",\n-            \"search_source_builder_exception\",\n-            \"flush_failed_engine_exception\",\n-            \"circuit_breaking_exception\",\n-            \"strict_dynamic_mapping_exception\",\n-            \"retry_on_replica_exception\",\n-            \"failed_to_commit_cluster_state_exception\",\n-            \"query_shard_exception\",\n-            \"no_longer_primary_shard_exception\",\n-            \"script_exception\",\n-            \"status_exception\",\n-            \"task_cancelled_exception\",\n-            \"shard_lock_obtain_failed_exception\",\n-            \"unknown_named_object_exception\",\n-            \"too_many_buckets_exception\"\n-    ));\n-\n-    private static final Logger LOGGER = LoggerFactory.getLogger(ElasticResponseHandler.class);\n-\n-    private static final String METRIC_PREFIX = \"bulkResponseHandler\";\n-\n-    private static final JsonFactory FACTORY = new JsonFactory();\n-    private static final ObjectMapper MAPPER = new ObjectMapper(FACTORY);\n-\n-    private final MetricsCollector metricsCollector;\n-\n-    private final ConcurrentHashMap<String, Meter> errorTypesMeter = new ConcurrentHashMap<>();\n-\n-    private final Meter retryableErrorsMeter;\n-    private final Meter nonRetryableErrorsMeter;\n-    private final Meter unknownErrorsMeter;\n-\n-\n-    public ElasticResponseHandler(final MetricsCollector metricsCollector) {\n-        this.metricsCollector = metricsCollector;\n-\n-        this.retryableErrorsMeter = metricsCollector.meter(METRIC_PREFIX + \".retryableErrors\");\n-        this.nonRetryableErrorsMeter = metricsCollector.meter(METRIC_PREFIX + \".nonRetryableErrors\");\n-        this.unknownErrorsMeter = metricsCollector.meter(METRIC_PREFIX + \".unknownErrors\");\n+    public ErrorType getType() {\n+      return type;\n     }\n \n-    // TODO: Replace with a good parser\n-    public Result process(HttpEntity httpEntity, Set<String> redefinedExceptions) {\n-        return toUnchecked(() -> {\n-            int retryableErrorCount = 0;\n-            int nonRetryableErrorCount = 0;\n-            int unknownErrorCount = 0;\n-            Set<String> badIds = new HashSet<>();\n-            Set<ErrorResponseWrapper> nonRetryableErrors = new HashSet<>();\n-\n-            JsonParser parser = FACTORY.createParser(httpEntity.getContent());\n-\n-            String currentId = \"\";\n-            String currentIndex = \"\";\n-\n-            while (Objects.nonNull(parser.nextToken())) {\n-                /*\n-                 * No errors in response, so processing can be skipped\n-                 */\n-                if (\"errors\".equals(parser.getCurrentName())) {\n-                    if (Boolean.FALSE.equals(parser.nextBooleanValue())) {\n-                        return Result.OK;\n-                    }\n-                }\n-\n-                if (\"_id\".equals(parser.getCurrentName())) {\n-                    currentId = parser.getValueAsString(\"\");\n-                }\n-                if (\"_index\".equals(parser.getCurrentName())) {\n-                    currentIndex = parser.getValueAsString(\"\");\n-                }\n-                if (\"error\".equals(parser.getCurrentName())) {\n-                    parser.nextToken(); // Skip name\n-                    final ErrorResponseWrapper errorResponseWrapper = processError(MAPPER.readTree(parser), currentId, currentIndex, redefinedExceptions);\n-                    switch (errorResponseWrapper.getType()) {\n-                        case RETRYABLE:\n-                            retryableErrorCount++;\n-                            break;\n-                        case NON_RETRYABLE:\n-                            nonRetryableErrorCount++;\n-                            nonRetryableErrors.add(errorResponseWrapper);\n-                            break;\n-                        case UNKNOWN:\n-                            unknownErrorCount++;\n-                            if (!StringUtil.isNullOrEmpty(currentId)) {\n-                                badIds.add(currentId);\n-                            }\n-                            break;\n-                        default:\n-                            throw new RuntimeException(String.format(\"Unsupported error type '%s'\", errorResponseWrapper.getType()));\n-                    }\n-\n-                }\n-            }\n+    public String getEventId() {\n+      return eventId;\n+    }\n \n-            retryableErrorsMeter.mark(retryableErrorCount);\n-            nonRetryableErrorsMeter.mark(nonRetryableErrorCount);\n-            unknownErrorsMeter.mark(unknownErrorCount);\n+    public String getIndex() {\n+      return index;\n+    }\n \n-            return new Result(retryableErrorCount, nonRetryableErrorCount, unknownErrorCount, badIds, nonRetryableErrors);\n-        });\n+    public String getReason() {\n+      return reason;\n     }\n+  }\n+\n+  public enum ErrorType {\n+    RETRYABLE,\n+    NON_RETRYABLE,\n+    UNKNOWN\n+  }\n+\n+  static final Set<String> RETRYABLE_ERRORS_CODES = new HashSet<>(Arrays.asList(\n+    \"process_cluster_event_timeout_exception\",\n+    \"es_rejected_execution_exception\",\n+    \"cluster_block_exception\",\n+    \"unavailable_shards_exception\",\n+    \"timeout_exception\",\n+    \"master_not_discovered_exception\",\n+    \"connect_transport_exception\",\n+    \"primary_missing_action_exception\",\n+    \"concurrent_snapshot_execution_exception\",\n+    \"receive_timeout_transport_exception\",\n+    \"elasticsearch_timeout_exception\",\n+    \"no_shard_available_action_exception\",\n+    \"node_not_connected_exception\",\n+    \"node_disconnected_exception\",\n+    \"not_master_exception\",\n+    \"delay_recovery_exception\"\n+  ));\n+\n+  static final Set<String> NON_RETRYABLE_ERRORS_CODES = new HashSet<>(Arrays.asList(\n+    \"illegal_argument_exception\",\n+    \"mapper_parsing_exception\",\n+    \"illegal_state_exception\",\n+    \"invalid_index_name_exception\",\n+    \"index_closed_exception\",\n+    \"invalid_alias_name_exception\",\n+    \"elasticsearch_parse_exception\",\n+    \"invalid_type_name_exception\",\n+    \"parsing_exception\",\n+    \"index_template_missing_exception\",\n+    \"search_parse_exception\",\n+    \"timestamp_parsing_exception\",\n+    \"invalid_index_template_exception\",\n+    \"invalid_snapshot_name_exception\",\n+    \"document_source_missing_exception\",\n+    \"resource_already_exists_exception\",\n+    \"type_missing_exception\",\n+    \"index_shard_snapshot_failed_exception\",\n+    \"dfs_phase_execution_exception\",\n+    \"execution_cancelled_exception\",\n+    \"elasticsearch_security_exception\",\n+    \"index_shard_restore_exception\",\n+    \"bind_http_exception\",\n+    \"reduce_search_phase_exception\",\n+    \"node_closed_exception\",\n+    \"snapshot_failed_engine_exception\",\n+    \"shard_not_found_exception\",\n+    \"not_serializable_transport_exception\",\n+    \"response_handler_failure_transport_exception\",\n+    \"index_creation_exception\",\n+    \"index_not_found_exception\",\n+    \"illegal_shard_routing_state_exception\",\n+    \"broadcast_shard_operation_failed_exception\",\n+    \"resource_not_found_exception\",\n+    \"action_transport_exception\",\n+    \"elasticsearch_generation_exception\",\n+    \"index_shard_started_exception\",\n+    \"search_context_missing_exception\",\n+    \"general_script_exception\",\n+    \"snapshot_creation_exception\",\n+    \"document_missing_exception\",\n+    \"snapshot_exception\",\n+    \"index_primary_shard_not_allocated_exception\",\n+    \"transport_exception\",\n+    \"search_exception\",\n+    \"mapper_exception\",\n+    \"snapshot_restore_exception\",\n+    \"index_shard_closed_exception\",\n+    \"recover_files_recovery_exception\",\n+    \"truncated_translog_exception\",\n+    \"recovery_failed_exception\",\n+    \"index_shard_relocated_exception\",\n+    \"node_should_not_connect_exception\",\n+    \"translog_corrupted_exception\",\n+    \"fetch_phase_execution_exception\",\n+    \"version_conflict_engine_exception\",\n+    \"engine_exception\",\n+    \"no_such_node_exception\",\n+    \"settings_exception\",\n+    \"send_request_transport_exception\",\n+    \"not_serializable_exception_wrapper\",\n+    \"alias_filter_parsing_exception\",\n+    \"gateway_exception\",\n+    \"index_shard_not_recovering_exception\",\n+    \"http_exception\",\n+    \"elasticsearch_exception\",\n+    \"snapshot_missing_exception\",\n+    \"failed_node_exception\",\n+    \"blob_store_exception\",\n+    \"incompatible_cluster_state_version_exception\",\n+    \"recovery_engine_exception\",\n+    \"uncategorized_execution_exception\",\n+    \"routing_missing_exception\",\n+    \"index_shard_restore_failed_exception\",\n+    \"repository_exception\",\n+    \"aggregation_execution_exception\",\n+    \"refresh_failed_engine_exception\",\n+    \"aggregation_initialization_exception\",\n+    \"no_node_available_exception\",\n+    \"illegal_index_shard_state_exception\",\n+    \"index_shard_snapshot_exception\",\n+    \"index_shard_not_started_exception\",\n+    \"search_phase_execution_exception\",\n+    \"action_not_found_transport_exception\",\n+    \"transport_serialization_exception\",\n+    \"remote_transport_exception\",\n+    \"engine_creation_failure_exception\",\n+    \"routing_exception\",\n+    \"index_shard_recovery_exception\",\n+    \"repository_missing_exception\",\n+    \"no_class_settings_exception\",\n+    \"bind_transport_exception\",\n+    \"aliases_not_found_exception\",\n+    \"index_shard_recovering_exception\",\n+    \"translog_exception\",\n+    \"retry_on_primary_exception\",\n+    \"query_phase_execution_exception\",\n+    \"repository_verification_exception\",\n+    \"invalid_aggregation_path_exception\",\n+    \"http_on_transport_exception\",\n+    \"search_context_exception\",\n+    \"search_source_builder_exception\",\n+    \"flush_failed_engine_exception\",\n+    \"circuit_breaking_exception\",\n+    \"strict_dynamic_mapping_exception\",\n+    \"retry_on_replica_exception\",\n+    \"failed_to_commit_cluster_state_exception\",\n+    \"query_shard_exception\",\n+    \"no_longer_primary_shard_exception\",\n+    \"script_exception\",\n+    \"status_exception\",\n+    \"task_cancelled_exception\",\n+    \"shard_lock_obtain_failed_exception\",\n+    \"unknown_named_object_exception\",\n+    \"too_many_buckets_exception\"\n+  ));\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(ElasticResponseHandler.class);\n+\n+  private static final String METRIC_PREFIX = \"bulkResponseHandler\";\n+\n+  private static final JsonFactory FACTORY = new JsonFactory();\n+  private static final ObjectMapper MAPPER = new ObjectMapper(FACTORY);\n+\n+  private final MetricsCollector metricsCollector;\n+\n+  private final ConcurrentHashMap<String, Meter> errorTypesMeter = new ConcurrentHashMap<>();\n+\n+  private final Meter retryableErrorsMeter;\n+  private final Meter nonRetryableErrorsMeter;\n+  private final Meter unknownErrorsMeter;\n+\n+\n+  public ElasticResponseHandler(final MetricsCollector metricsCollector) {\n+    this.metricsCollector = metricsCollector;\n+\n+    this.retryableErrorsMeter = metricsCollector.meter(METRIC_PREFIX + \".retryableErrors\");\n+    this.nonRetryableErrorsMeter = metricsCollector.meter(METRIC_PREFIX + \".nonRetryableErrors\");\n+    this.unknownErrorsMeter = metricsCollector.meter(METRIC_PREFIX + \".unknownErrors\");\n+  }\n+\n+  // TODO: Replace with a good parser\n+  public Result process(HttpEntity httpEntity, Set<String> redefinedExceptions) {\n+    return toUnchecked(() -> {\n+      int retryableErrorCount = 0;\n+      int nonRetryableErrorCount = 0;\n+      int unknownErrorCount = 0;\n+      Set<String> badIds = new HashSet<>();\n+      Set<ErrorResponseWrapper> nonRetryableErrors = new HashSet<>();\n+\n+      JsonParser parser = FACTORY.createParser(httpEntity.getContent());\n+\n+      String currentId = \"\";\n+      String currentIndex = \"\";\n+\n+      while (Objects.nonNull(parser.nextToken())) {\n+        /*\n+         * No errors in response, so processing can be skipped\n+         */\n+        if (\"errors\".equals(parser.getCurrentName())) {\n+          if (Boolean.FALSE.equals(parser.nextBooleanValue())) {\n+            return Result.OK;\n+          }\n+        }\n \n-    /**\n-     * Process error JSON node\n-     *\n-     * @param errorNode           JSON node with error data\n-     * @param id                  event id\n-     * @param index               index\n-     * @param redefinedExceptions exceptions for overriding\n-     * @return error type, which determines retryability of the error\n-     */\n-    private ErrorResponseWrapper processError(TreeNode errorNode, String id, String index, Set<String> redefinedExceptions) {\n-        if (errorNode instanceof ObjectNode) {\n-            ObjectNode error = (ObjectNode) errorNode;\n-            LOGGER.warn(\"Original error: {}\", error);\n-\n-            final String type = Optional.ofNullable(error.get(\"type\"))\n-                    .map(JsonNode::asText)\n-                    .orElse(\"\");\n-\n-            final String reason = Optional.ofNullable(error.get(\"reason\"))\n-                    .map(JsonNode::asText)\n-                    .orElse(\"\")\n-                    .replaceAll(\"[\\\\r\\\\n]+\", \" \");\n-\n-            //TODO: Build \"caused by\" trace\n-\n-            errorTypesMeter.computeIfAbsent(type, this::createMeter).mark();\n-            if (redefinedExceptions.contains(type)){\n-                LOGGER.warn(\"Retryable error which will be regarded as non-retryable: index={}, id={}, type={}, reason={}\", index, id, type,reason);\n-                return new ErrorResponseWrapper(ErrorType.NON_RETRYABLE, id, index, reason);\n-            } else if (RETRYABLE_ERRORS_CODES.contains(type)) {\n-                LOGGER.warn(\"Retryable error: index={}, id={}, type={}, reason={}\", index, id, type,reason);\n-                return new ErrorResponseWrapper(ErrorType.RETRYABLE, id, index, reason);\n-            } else if (NON_RETRYABLE_ERRORS_CODES.contains(type)) {\n-                LOGGER.warn(\"Non retryable error: index={}, id={}, type={}, reason={}\", index, id, type,reason);\n-                return new ErrorResponseWrapper(ErrorType.NON_RETRYABLE, id, index, reason);\n-            } else {\n-                LOGGER.warn(\"Unknown error: index={}, id={}, type={}, reason={}\", index, id, type, reason);\n-                return new ErrorResponseWrapper(ErrorType.UNKNOWN, id, index, reason);\n+        if (\"_id\".equals(parser.getCurrentName())) {\n+          currentId = parser.getValueAsString(\"\");\n+        }\n+        if (\"_index\".equals(parser.getCurrentName())) {\n+          currentIndex = parser.getValueAsString(\"\");\n+        }\n+        if (\"error\".equals(parser.getCurrentName())) {\n+          parser.nextToken(); // Skip name\n+          final ErrorResponseWrapper errorResponseWrapper = processError(MAPPER.readTree(parser), currentId, currentIndex, redefinedExceptions);\n+          switch (errorResponseWrapper.getType()) {\n+          case RETRYABLE:\n+            retryableErrorCount++;\n+            break;\n+          case NON_RETRYABLE:\n+            nonRetryableErrorCount++;\n+            nonRetryableErrors.add(errorResponseWrapper);\n+            break;\n+          case UNKNOWN:\n+            unknownErrorCount++;\n+            if (!StringUtil.isNullOrEmpty(currentId)) {\n+              badIds.add(currentId);\n             }\n-        } else {\n-            String errorMessage = \"Error node is not object note, cannot parse\";\n-            LOGGER.warn(errorMessage);\n-            return new ErrorResponseWrapper(ErrorType.NON_RETRYABLE, id, index, errorMessage);\n+            break;\n+          default:\n+            throw new RuntimeException(String.format(\"Unsupported error type '%s'\", errorResponseWrapper.getType()));\n+          }\n+\n         }\n+      }\n+\n+      retryableErrorsMeter.mark(retryableErrorCount);\n+      nonRetryableErrorsMeter.mark(nonRetryableErrorCount);\n+      unknownErrorsMeter.mark(unknownErrorCount);\n+\n+      return new Result(retryableErrorCount, nonRetryableErrorCount, unknownErrorCount, badIds, nonRetryableErrors);\n+    });\n+  }\n+\n+  /**\n+   * Process error JSON node\n+   *\n+   * @param errorNode           JSON node with error data\n+   * @param id                  event id\n+   * @param index               index\n+   * @param redefinedExceptions exceptions for overriding\n+   * @return error type, which determines retryability of the error\n+   */\n+  private ErrorResponseWrapper processError(TreeNode errorNode, String id, String index, Set<String> redefinedExceptions) {\n+    if (errorNode instanceof ObjectNode) {\n+      ObjectNode error = (ObjectNode) errorNode;\n+      LOGGER.warn(\"Original error: {}\", error);\n+\n+      final String type = Optional.ofNullable(error.get(\"type\"))\n+        .map(JsonNode::asText)\n+        .orElse(\"\");\n+\n+      final String reason = Optional.ofNullable(error.get(\"reason\"))\n+        .map(JsonNode::asText)\n+        .orElse(\"\")\n+        .replaceAll(\"[\\\\r\\\\n]+\", \" \");\n+\n+      //TODO: Build \"caused by\" trace\n+\n+      errorTypesMeter.computeIfAbsent(type, this::createMeter).mark();\n+      if (redefinedExceptions.contains(type)) {\n+        LOGGER.warn(\"Retryable error which will be regarded as non-retryable: index={}, id={}, type={}, reason={}\", index, id, type, reason);\n+        return new ErrorResponseWrapper(ErrorType.NON_RETRYABLE, id, index, reason);\n+      } else if (RETRYABLE_ERRORS_CODES.contains(type)) {\n+        LOGGER.warn(\"Retryable error: index={}, id={}, type={}, reason={}\", index, id, type, reason);\n+        return new ErrorResponseWrapper(ErrorType.RETRYABLE, id, index, reason);\n+      } else if (NON_RETRYABLE_ERRORS_CODES.contains(type)) {\n+        LOGGER.warn(\"Non retryable error: index={}, id={}, type={}, reason={}\", index, id, type, reason);\n+        return new ErrorResponseWrapper(ErrorType.NON_RETRYABLE, id, index, reason);\n+      } else {\n+        LOGGER.warn(\"Unknown error: index={}, id={}, type={}, reason={}\", index, id, type, reason);\n+        return new ErrorResponseWrapper(ErrorType.UNKNOWN, id, index, reason);\n+      }\n+    } else {\n+      String errorMessage = \"Error node is not object note, cannot parse\";\n+      LOGGER.warn(errorMessage);\n+      return new ErrorResponseWrapper(ErrorType.NON_RETRYABLE, id, index, errorMessage);\n     }\n+  }\n \n-    private Meter createMeter(final String errorType) {\n-        return metricsCollector.meter(METRIC_PREFIX + \".errorTypes.\" + MetricsUtil.sanitizeMetricName(errorType));\n-    }\n+  private Meter createMeter(final String errorType) {\n+    return metricsCollector.meter(METRIC_PREFIX + \".errorTypes.\" + MetricsUtil.sanitizeMetricName(errorType));\n+  }\n }\n",
            "diff_size": 611
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "124",
                    "severity": "warning",
                    "message": "Line is longer than 160 characters (found 614).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "126",
                    "severity": "warning",
                    "message": "Line is longer than 160 characters (found 3,763).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "175",
                    "severity": "warning",
                    "message": "Line is longer than 160 characters (found 161).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/10/ElasticResponseHandler.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/codebuff/10/ElasticResponseHandler.java\nindex fdbab46dd5d..04117dc646e 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/10/ElasticResponseHandler.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/codebuff/10/ElasticResponseHandler.java\n@@ -13,7 +13,6 @@ import org.slf4j.LoggerFactory;\n import ru.kontur.vostok.hercules.health.MetricsCollector;\n import ru.kontur.vostok.hercules.health.MetricsUtil;\n import ru.kontur.vostok.hercules.util.text.StringUtil;\n-\n import java.util.Arrays;\n import java.util.Collections;\n import java.util.HashSet;\n@@ -28,14 +27,7 @@ public class ElasticResponseHandler {\n \n     public static class Result {\n \n-        public static final Result OK = new Result(\n-                0,\n-                0,\n-                0,\n-                Collections.emptySet(),\n-                Collections.emptySet()\n-        );\n-\n+        public static final Result OK = new Result(0, 0, 0, Collections.emptySet(), Collections.emptySet());\n         private final int retryableErrorCount;\n         private final int nonRetryableErrorCount;\n         private final int unknownErrorCount;\n@@ -43,11 +35,10 @@ public class ElasticResponseHandler {\n         private final Set<ErrorResponseWrapper> nonRetryableErrors;\n \n         public Result(\n-                int retryableErrorCount,\n-                int nonRetryableErrorCount,\n-                int unknownErrorCount,\n-                Set<String> badIds,\n-                Set<ErrorResponseWrapper> nonRetryableErrors\n+            int retryableErrorCount,\n+            int nonRetryableErrorCount,\n+            int unknownErrorCount,\n+            Set<String> badIds, Set<ErrorResponseWrapper> nonRetryableErrors\n         ) {\n             this.retryableErrorCount = retryableErrorCount;\n             this.nonRetryableErrorCount = nonRetryableErrorCount;\n@@ -94,6 +85,7 @@ public class ElasticResponseHandler {\n     }\n \n     public class ErrorResponseWrapper {\n+\n         private final ErrorType type;\n         private final String eventId;\n         private final String index;\n@@ -129,227 +121,90 @@ public class ElasticResponseHandler {\n         UNKNOWN\n     }\n \n-    static final Set<String> RETRYABLE_ERRORS_CODES = new HashSet<>(Arrays.asList(\n-            \"process_cluster_event_timeout_exception\",\n-            \"es_rejected_execution_exception\",\n-            \"cluster_block_exception\",\n-            \"unavailable_shards_exception\",\n-            \"timeout_exception\",\n-            \"master_not_discovered_exception\",\n-            \"connect_transport_exception\",\n-            \"primary_missing_action_exception\",\n-            \"concurrent_snapshot_execution_exception\",\n-            \"receive_timeout_transport_exception\",\n-            \"elasticsearch_timeout_exception\",\n-            \"no_shard_available_action_exception\",\n-            \"node_not_connected_exception\",\n-            \"node_disconnected_exception\",\n-            \"not_master_exception\",\n-            \"delay_recovery_exception\"\n-    ));\n-\n-    static final Set<String> NON_RETRYABLE_ERRORS_CODES = new HashSet<>(Arrays.asList(\n-            \"illegal_argument_exception\",\n-            \"mapper_parsing_exception\",\n-            \"illegal_state_exception\",\n-            \"invalid_index_name_exception\",\n-            \"index_closed_exception\",\n-            \"invalid_alias_name_exception\",\n-            \"elasticsearch_parse_exception\",\n-            \"invalid_type_name_exception\",\n-            \"parsing_exception\",\n-            \"index_template_missing_exception\",\n-            \"search_parse_exception\",\n-            \"timestamp_parsing_exception\",\n-            \"invalid_index_template_exception\",\n-            \"invalid_snapshot_name_exception\",\n-            \"document_source_missing_exception\",\n-            \"resource_already_exists_exception\",\n-            \"type_missing_exception\",\n-            \"index_shard_snapshot_failed_exception\",\n-            \"dfs_phase_execution_exception\",\n-            \"execution_cancelled_exception\",\n-            \"elasticsearch_security_exception\",\n-            \"index_shard_restore_exception\",\n-            \"bind_http_exception\",\n-            \"reduce_search_phase_exception\",\n-            \"node_closed_exception\",\n-            \"snapshot_failed_engine_exception\",\n-            \"shard_not_found_exception\",\n-            \"not_serializable_transport_exception\",\n-            \"response_handler_failure_transport_exception\",\n-            \"index_creation_exception\",\n-            \"index_not_found_exception\",\n-            \"illegal_shard_routing_state_exception\",\n-            \"broadcast_shard_operation_failed_exception\",\n-            \"resource_not_found_exception\",\n-            \"action_transport_exception\",\n-            \"elasticsearch_generation_exception\",\n-            \"index_shard_started_exception\",\n-            \"search_context_missing_exception\",\n-            \"general_script_exception\",\n-            \"snapshot_creation_exception\",\n-            \"document_missing_exception\",\n-            \"snapshot_exception\",\n-            \"index_primary_shard_not_allocated_exception\",\n-            \"transport_exception\",\n-            \"search_exception\",\n-            \"mapper_exception\",\n-            \"snapshot_restore_exception\",\n-            \"index_shard_closed_exception\",\n-            \"recover_files_recovery_exception\",\n-            \"truncated_translog_exception\",\n-            \"recovery_failed_exception\",\n-            \"index_shard_relocated_exception\",\n-            \"node_should_not_connect_exception\",\n-            \"translog_corrupted_exception\",\n-            \"fetch_phase_execution_exception\",\n-            \"version_conflict_engine_exception\",\n-            \"engine_exception\",\n-            \"no_such_node_exception\",\n-            \"settings_exception\",\n-            \"send_request_transport_exception\",\n-            \"not_serializable_exception_wrapper\",\n-            \"alias_filter_parsing_exception\",\n-            \"gateway_exception\",\n-            \"index_shard_not_recovering_exception\",\n-            \"http_exception\",\n-            \"elasticsearch_exception\",\n-            \"snapshot_missing_exception\",\n-            \"failed_node_exception\",\n-            \"blob_store_exception\",\n-            \"incompatible_cluster_state_version_exception\",\n-            \"recovery_engine_exception\",\n-            \"uncategorized_execution_exception\",\n-            \"routing_missing_exception\",\n-            \"index_shard_restore_failed_exception\",\n-            \"repository_exception\",\n-            \"aggregation_execution_exception\",\n-            \"refresh_failed_engine_exception\",\n-            \"aggregation_initialization_exception\",\n-            \"no_node_available_exception\",\n-            \"illegal_index_shard_state_exception\",\n-            \"index_shard_snapshot_exception\",\n-            \"index_shard_not_started_exception\",\n-            \"search_phase_execution_exception\",\n-            \"action_not_found_transport_exception\",\n-            \"transport_serialization_exception\",\n-            \"remote_transport_exception\",\n-            \"engine_creation_failure_exception\",\n-            \"routing_exception\",\n-            \"index_shard_recovery_exception\",\n-            \"repository_missing_exception\",\n-            \"no_class_settings_exception\",\n-            \"bind_transport_exception\",\n-            \"aliases_not_found_exception\",\n-            \"index_shard_recovering_exception\",\n-            \"translog_exception\",\n-            \"retry_on_primary_exception\",\n-            \"query_phase_execution_exception\",\n-            \"repository_verification_exception\",\n-            \"invalid_aggregation_path_exception\",\n-            \"http_on_transport_exception\",\n-            \"search_context_exception\",\n-            \"search_source_builder_exception\",\n-            \"flush_failed_engine_exception\",\n-            \"circuit_breaking_exception\",\n-            \"strict_dynamic_mapping_exception\",\n-            \"retry_on_replica_exception\",\n-            \"failed_to_commit_cluster_state_exception\",\n-            \"query_shard_exception\",\n-            \"no_longer_primary_shard_exception\",\n-            \"script_exception\",\n-            \"status_exception\",\n-            \"task_cancelled_exception\",\n-            \"shard_lock_obtain_failed_exception\",\n-            \"unknown_named_object_exception\",\n-            \"too_many_buckets_exception\"\n-    ));\n+    static final Set<String> RETRYABLE_ERRORS_CODES = new HashSet<>(Arrays.asList(\"process_cluster_event_timeout_exception\", \"es_rejected_execution_exception\", \"cluster_block_exception\", \"unavailable_shards_exception\", \"timeout_exception\", \"master_not_discovered_exception\", \"connect_transport_exception\", \"primary_missing_action_exception\", \"concurrent_snapshot_execution_exception\", \"receive_timeout_transport_exception\", \"elasticsearch_timeout_exception\", \"no_shard_available_action_exception\", \"node_not_connected_exception\", \"node_disconnected_exception\", \"not_master_exception\", \"delay_recovery_exception\"));\n \n+    static final Set<String> NON_RETRYABLE_ERRORS_CODES = new HashSet<>(Arrays.asList(\"illegal_argument_exception\", \"mapper_parsing_exception\", \"illegal_state_exception\", \"invalid_index_name_exception\", \"index_closed_exception\", \"invalid_alias_name_exception\", \"elasticsearch_parse_exception\", \"invalid_type_name_exception\", \"parsing_exception\", \"index_template_missing_exception\", \"search_parse_exception\", \"timestamp_parsing_exception\", \"invalid_index_template_exception\", \"invalid_snapshot_name_exception\", \"document_source_missing_exception\", \"resource_already_exists_exception\", \"type_missing_exception\", \"index_shard_snapshot_failed_exception\", \"dfs_phase_execution_exception\", \"execution_cancelled_exception\", \"elasticsearch_security_exception\", \"index_shard_restore_exception\", \"bind_http_exception\", \"reduce_search_phase_exception\", \"node_closed_exception\", \"snapshot_failed_engine_exception\", \"shard_not_found_exception\", \"not_serializable_transport_exception\", \"response_handler_failure_transport_exception\", \"index_creation_exception\", \"index_not_found_exception\", \"illegal_shard_routing_state_exception\", \"broadcast_shard_operation_failed_exception\", \"resource_not_found_exception\", \"action_transport_exception\", \"elasticsearch_generation_exception\", \"index_shard_started_exception\", \"search_context_missing_exception\", \"general_script_exception\", \"snapshot_creation_exception\", \"document_missing_exception\", \"snapshot_exception\", \"index_primary_shard_not_allocated_exception\", \"transport_exception\", \"search_exception\", \"mapper_exception\", \"snapshot_restore_exception\", \"index_shard_closed_exception\", \"recover_files_recovery_exception\", \"truncated_translog_exception\", \"recovery_failed_exception\", \"index_shard_relocated_exception\", \"node_should_not_connect_exception\", \"translog_corrupted_exception\", \"fetch_phase_execution_exception\", \"version_conflict_engine_exception\", \"engine_exception\", \"no_such_node_exception\", \"settings_exception\", \"send_request_transport_exception\", \"not_serializable_exception_wrapper\", \"alias_filter_parsing_exception\", \"gateway_exception\", \"index_shard_not_recovering_exception\", \"http_exception\", \"elasticsearch_exception\", \"snapshot_missing_exception\", \"failed_node_exception\", \"blob_store_exception\", \"incompatible_cluster_state_version_exception\", \"recovery_engine_exception\", \"uncategorized_execution_exception\", \"routing_missing_exception\", \"index_shard_restore_failed_exception\", \"repository_exception\", \"aggregation_execution_exception\", \"refresh_failed_engine_exception\", \"aggregation_initialization_exception\", \"no_node_available_exception\", \"illegal_index_shard_state_exception\", \"index_shard_snapshot_exception\", \"index_shard_not_started_exception\", \"search_phase_execution_exception\", \"action_not_found_transport_exception\", \"transport_serialization_exception\", \"remote_transport_exception\", \"engine_creation_failure_exception\", \"routing_exception\", \"index_shard_recovery_exception\", \"repository_missing_exception\", \"no_class_settings_exception\", \"bind_transport_exception\", \"aliases_not_found_exception\", \"index_shard_recovering_exception\", \"translog_exception\", \"retry_on_primary_exception\", \"query_phase_execution_exception\", \"repository_verification_exception\", \"invalid_aggregation_path_exception\", \"http_on_transport_exception\", \"search_context_exception\", \"search_source_builder_exception\", \"flush_failed_engine_exception\", \"circuit_breaking_exception\", \"strict_dynamic_mapping_exception\", \"retry_on_replica_exception\", \"failed_to_commit_cluster_state_exception\", \"query_shard_exception\", \"no_longer_primary_shard_exception\", \"script_exception\", \"status_exception\", \"task_cancelled_exception\", \"shard_lock_obtain_failed_exception\", \"unknown_named_object_exception\", \"too_many_buckets_exception\"));\n     private static final Logger LOGGER = LoggerFactory.getLogger(ElasticResponseHandler.class);\n-\n     private static final String METRIC_PREFIX = \"bulkResponseHandler\";\n-\n     private static final JsonFactory FACTORY = new JsonFactory();\n     private static final ObjectMapper MAPPER = new ObjectMapper(FACTORY);\n-\n     private final MetricsCollector metricsCollector;\n-\n     private final ConcurrentHashMap<String, Meter> errorTypesMeter = new ConcurrentHashMap<>();\n-\n     private final Meter retryableErrorsMeter;\n     private final Meter nonRetryableErrorsMeter;\n     private final Meter unknownErrorsMeter;\n \n-\n     public ElasticResponseHandler(final MetricsCollector metricsCollector) {\n         this.metricsCollector = metricsCollector;\n-\n         this.retryableErrorsMeter = metricsCollector.meter(METRIC_PREFIX + \".retryableErrors\");\n         this.nonRetryableErrorsMeter = metricsCollector.meter(METRIC_PREFIX + \".nonRetryableErrors\");\n         this.unknownErrorsMeter = metricsCollector.meter(METRIC_PREFIX + \".unknownErrors\");\n     }\n \n     // TODO: Replace with a good parser\n+\n     public Result process(HttpEntity httpEntity, Set<String> redefinedExceptions) {\n         return toUnchecked(() -> {\n-            int retryableErrorCount = 0;\n-            int nonRetryableErrorCount = 0;\n-            int unknownErrorCount = 0;\n-            Set<String> badIds = new HashSet<>();\n-            Set<ErrorResponseWrapper> nonRetryableErrors = new HashSet<>();\n-\n-            JsonParser parser = FACTORY.createParser(httpEntity.getContent());\n-\n-            String currentId = \"\";\n-            String currentIndex = \"\";\n-\n-            while (Objects.nonNull(parser.nextToken())) {\n+                   int retryableErrorCount = 0;\n+                   int nonRetryableErrorCount = 0;\n+                   int unknownErrorCount = 0;\n+                   Set<String> badIds = new HashSet<>();\n+                   Set<ErrorResponseWrapper> nonRetryableErrors = new HashSet<>();\n+                   JsonParser parser = FACTORY.createParser(httpEntity.getContent());\n+                   String currentId = \"\";\n+                   String currentIndex = \"\";\n+                   while (Objects.nonNull(parser.nextToken())) {\n                 /*\n                  * No errors in response, so processing can be skipped\n                  */\n-                if (\"errors\".equals(parser.getCurrentName())) {\n-                    if (Boolean.FALSE.equals(parser.nextBooleanValue())) {\n-                        return Result.OK;\n-                    }\n-                }\n-\n-                if (\"_id\".equals(parser.getCurrentName())) {\n-                    currentId = parser.getValueAsString(\"\");\n-                }\n-                if (\"_index\".equals(parser.getCurrentName())) {\n-                    currentIndex = parser.getValueAsString(\"\");\n-                }\n-                if (\"error\".equals(parser.getCurrentName())) {\n-                    parser.nextToken(); // Skip name\n-                    final ErrorResponseWrapper errorResponseWrapper = processError(MAPPER.readTree(parser), currentId, currentIndex, redefinedExceptions);\n-                    switch (errorResponseWrapper.getType()) {\n-                        case RETRYABLE:\n-                            retryableErrorCount++;\n-                            break;\n-                        case NON_RETRYABLE:\n-                            nonRetryableErrorCount++;\n-                            nonRetryableErrors.add(errorResponseWrapper);\n-                            break;\n-                        case UNKNOWN:\n-                            unknownErrorCount++;\n-                            if (!StringUtil.isNullOrEmpty(currentId)) {\n-                                badIds.add(currentId);\n-                            }\n-                            break;\n-                        default:\n-                            throw new RuntimeException(String.format(\"Unsupported error type '%s'\", errorResponseWrapper.getType()));\n-                    }\n-\n-                }\n-            }\n-\n-            retryableErrorsMeter.mark(retryableErrorCount);\n-            nonRetryableErrorsMeter.mark(nonRetryableErrorCount);\n-            unknownErrorsMeter.mark(unknownErrorCount);\n-\n-            return new Result(retryableErrorCount, nonRetryableErrorCount, unknownErrorCount, badIds, nonRetryableErrors);\n-        });\n+                       if (\"errors\".equals(parser.getCurrentName())) {\n+                           if (Boolean.FALSE.equals(parser.nextBooleanValue())) {\n+                               return Result.OK;\n+                           }\n+                       }\n+                       if (\"_id\".equals(parser.getCurrentName())) {\n+                           currentId = parser.getValueAsString(\"\");\n+                       }\n+                       if (\"_index\".equals(parser.getCurrentName())) {\n+                           currentIndex = parser.getValueAsString(\"\");\n+                       }\n+                       if (\"error\".equals(parser.getCurrentName())) {\n+                           parser.nextToken(); // Skip name\n+\n+\n+                           final ErrorResponseWrapper errorResponseWrapper = processError(MAPPER.readTree(parser), currentId, currentIndex, redefinedExceptions);\n+                           switch (errorResponseWrapper.getType()) {\n+                               case RETRYABLE:\n+                                   retryableErrorCount++;\n+                                   break;\n+                               case NON_RETRYABLE:\n+                                   nonRetryableErrorCount++;\n+                                   nonRetryableErrors.add(errorResponseWrapper);\n+                                   break;\n+                               case UNKNOWN:\n+                                   unknownErrorCount++;\n+                                   if (!StringUtil.isNullOrEmpty(currentId)) {\n+                                       badIds.add(currentId);\n+                                   }\n+\n+                                   break;\n+                               default:\n+                                   throw new RuntimeException(String.format(\"Unsupported error type '%s'\", errorResponseWrapper.getType()));\n+                           }\n+                       }\n+                   }\n+\n+                   retryableErrorsMeter.mark(retryableErrorCount);\n+                   nonRetryableErrorsMeter.mark(nonRetryableErrorCount);\n+                   unknownErrorsMeter.mark(unknownErrorCount);\n+                   return new Result(\n+                       retryableErrorCount,\n+                       nonRetryableErrorCount,\n+                       unknownErrorCount,\n+                       badIds,\n+                       nonRetryableErrors\n+                   );\n+               });\n     }\n \n     /**\n@@ -361,36 +216,42 @@ public class ElasticResponseHandler {\n      * @param redefinedExceptions exceptions for overriding\n      * @return error type, which determines retryability of the error\n      */\n+\n     private ErrorResponseWrapper processError(TreeNode errorNode, String id, String index, Set<String> redefinedExceptions) {\n         if (errorNode instanceof ObjectNode) {\n             ObjectNode error = (ObjectNode) errorNode;\n             LOGGER.warn(\"Original error: {}\", error);\n \n-            final String type = Optional.ofNullable(error.get(\"type\"))\n-                    .map(JsonNode::asText)\n-                    .orElse(\"\");\n \n+            final String type = Optional.ofNullable(error.get(\"type\"))\n+            .map(JsonNode::asText)\n+            .orElse(\"\");\n             final String reason = Optional.ofNullable(error.get(\"reason\"))\n-                    .map(JsonNode::asText)\n-                    .orElse(\"\")\n-                    .replaceAll(\"[\\\\r\\\\n]+\", \" \");\n+            .map(JsonNode::asText)\n+            .orElse(\"\")\n+            .replaceAll(\"[\\\\r\\\\n]+\", \" \");\n \n             //TODO: Build \"caused by\" trace\n-\n             errorTypesMeter.computeIfAbsent(type, this::createMeter).mark();\n-            if (redefinedExceptions.contains(type)){\n-                LOGGER.warn(\"Retryable error which will be regarded as non-retryable: index={}, id={}, type={}, reason={}\", index, id, type,reason);\n+            if (redefinedExceptions.contains(type)) {\n+                LOGGER.warn(\"Retryable error which will be regarded as non-retryable: index={}, id={}, type={}, reason={}\", index, id, type, reason);\n                 return new ErrorResponseWrapper(ErrorType.NON_RETRYABLE, id, index, reason);\n             } else if (RETRYABLE_ERRORS_CODES.contains(type)) {\n-                LOGGER.warn(\"Retryable error: index={}, id={}, type={}, reason={}\", index, id, type,reason);\n-                return new ErrorResponseWrapper(ErrorType.RETRYABLE, id, index, reason);\n+                       LOGGER.warn(\"Retryable error: index={}, id={}, type={}, reason={}\", index, id, type, reason);\n+                       return new ErrorResponseWrapper(ErrorType.RETRYABLE, id, index, reason);\n             } else if (NON_RETRYABLE_ERRORS_CODES.contains(type)) {\n-                LOGGER.warn(\"Non retryable error: index={}, id={}, type={}, reason={}\", index, id, type,reason);\n-                return new ErrorResponseWrapper(ErrorType.NON_RETRYABLE, id, index, reason);\n-            } else {\n-                LOGGER.warn(\"Unknown error: index={}, id={}, type={}, reason={}\", index, id, type, reason);\n-                return new ErrorResponseWrapper(ErrorType.UNKNOWN, id, index, reason);\n-            }\n+                       LOGGER.warn(\n+                           \"Non retryable error: index={}, id={}, type={}, reason={}\",\n+                           index,\n+                           id,\n+                           type,\n+                           reason\n+                       );\n+                       return new ErrorResponseWrapper(ErrorType.NON_RETRYABLE, id, index, reason);\n+                   } else {\n+                       LOGGER.warn(\"Unknown error: index={}, id={}, type={}, reason={}\", index, id, type, reason);\n+                       return new ErrorResponseWrapper(ErrorType.UNKNOWN, id, index, reason);\n+                   }\n         } else {\n             String errorMessage = \"Error node is not object note, cannot parse\";\n             LOGGER.warn(errorMessage);\n@@ -401,4 +262,4 @@ public class ElasticResponseHandler {\n     private Meter createMeter(final String errorType) {\n         return metricsCollector.meter(METRIC_PREFIX + \".errorTypes.\" + MetricsUtil.sanitizeMetricName(errorType));\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 248
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/10/ElasticResponseHandler.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/styler_random/10/ElasticResponseHandler.java\nindex fdbab46dd5d..01123fe3de7 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/10/ElasticResponseHandler.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/styler_random/10/ElasticResponseHandler.java\n@@ -378,7 +378,7 @@ public class ElasticResponseHandler {\n             //TODO: Build \"caused by\" trace\n \n             errorTypesMeter.computeIfAbsent(type, this::createMeter).mark();\n-            if (redefinedExceptions.contains(type)){\n+            if (redefinedExceptions.contains(type)) {\n                 LOGGER.warn(\"Retryable error which will be regarded as non-retryable: index={}, id={}, type={}, reason={}\", index, id, type,reason);\n                 return new ErrorResponseWrapper(ErrorType.NON_RETRYABLE, id, index, reason);\n             } else if (RETRYABLE_ERRORS_CODES.contains(type)) {\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/10/ElasticResponseHandler.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/styler_three_grams/10/ElasticResponseHandler.java\nindex fdbab46dd5d..01123fe3de7 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/10/ElasticResponseHandler.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/styler_three_grams/10/ElasticResponseHandler.java\n@@ -378,7 +378,7 @@ public class ElasticResponseHandler {\n             //TODO: Build \"caused by\" trace\n \n             errorTypesMeter.computeIfAbsent(type, this::createMeter).mark();\n-            if (redefinedExceptions.contains(type)){\n+            if (redefinedExceptions.contains(type)) {\n                 LOGGER.warn(\"Retryable error which will be regarded as non-retryable: index={}, id={}, type={}, reason={}\", index, id, type,reason);\n                 return new ErrorResponseWrapper(ErrorType.NON_RETRYABLE, id, index, reason);\n             } else if (RETRYABLE_ERRORS_CODES.contains(type)) {\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "naturalize",
        "codebuff"
    ]
}