{
    "project_name": "Angel-ML-angel",
    "error_id": "513",
    "information": {
        "errors": [
            {
                "line": "6",
                "severity": "error",
                "message": "Line is longer than 100 characters (found 102).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": " * Copyright (C) 2017-2018 THL A29 Limited, a Tencent company. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in\n * compliance with the License. You may obtain a copy of the License at\n *\n * https://opensource.org/licenses/Apache-2.0",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Angel-ML-angel/errored/1/513/LINENode.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Angel-ML-angel/intellij/513/LINENode.java\nindex 856d3c3c661..433269b68cf 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Angel-ML-angel/errored/1/513/LINENode.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Angel-ML-angel/intellij/513/LINENode.java\n@@ -30,183 +30,183 @@ import java.io.IOException;\n  */\n public class LINENode implements IElement {\n \n-    private float[] inputFeats;\n-    private float[] outputFeats;\n-\n-    // Use by line with weight\n-    private transient int[] neighbors;\n-    private transient float[] weights;\n-\n-    public LINENode(float[] inputFeats, float[] outputFeats) {\n-        this.inputFeats = inputFeats;\n-        this.outputFeats = outputFeats;\n-    }\n-\n-    public LINENode() {\n-        this(null, null);\n-    }\n-\n-    public float[] getInputFeats() {\n-        return inputFeats;\n-    }\n-\n-    public void setInputFeats(float[] inputFeats) {\n-        this.inputFeats = inputFeats;\n-    }\n-\n-    public float[] getOutputFeats() {\n-        return outputFeats;\n-    }\n-\n-    public void setOutputFeats(float[] outputFeats) {\n-        this.outputFeats = outputFeats;\n-    }\n-\n-    public int[] getNeighbors() {\n-        return neighbors;\n-    }\n-\n-    public void setNeighbors(int[] neighbors) {\n-        this.neighbors = neighbors;\n-    }\n-\n-    public float[] getWeights() {\n-        return weights;\n-    }\n-\n-    public void setWeights(float[] weights) {\n-        this.weights = weights;\n-    }\n-\n-    @Override\n-    public Object deepClone() {\n-        float[] cloneInputFeats = new float[inputFeats.length];\n-        System.arraycopy(inputFeats, 0, cloneInputFeats, 0, inputFeats.length);\n-\n-        float[] cloneOutputFeats;\n-        if (outputFeats != null) {\n-            cloneOutputFeats = new float[outputFeats.length];\n-            System.arraycopy(outputFeats, 0, cloneOutputFeats, 0, outputFeats.length);\n-        }\n-        return new LINENode(inputFeats, outputFeats);\n-    }\n-\n-    @Override\n-    public void serialize(ByteBuf output) {\n-        output.writeInt(inputFeats.length);\n-        for (int i = 0; i < inputFeats.length; i++) {\n-            output.writeFloat(inputFeats[i]);\n-        }\n-\n-        if (outputFeats != null) {\n-            output.writeInt(outputFeats.length);\n-            for (int i = 0; i < outputFeats.length; i++) {\n-                output.writeFloat(outputFeats[i]);\n-            }\n-        } else {\n-            output.writeInt(0);\n-        }\n-    }\n-\n-    @Override\n-    public void deserialize(ByteBuf input) {\n-        inputFeats = new float[input.readInt()];\n-        for (int i = 0; i < inputFeats.length; i++) {\n-            inputFeats[i] = input.readFloat();\n-        }\n-\n-        int size = input.readInt();\n-        if (size > 0) {\n-            outputFeats = new float[size];\n-            for (int i = 0; i < outputFeats.length; i++) {\n-                outputFeats[i] = input.readFloat();\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public int bufferLen() {\n-        return 4 + inputFeats.length * 4 + 4 + (outputFeats != null ? outputFeats.length * 4 : 0);\n-    }\n-\n-    @Override\n-    public void serialize(DataOutputStream output) throws IOException {\n-        byte[] data = new byte[bufferLen()];\n-        int index = 0;\n-        output.writeInt(data.length);\n-        index = writeInt(data, inputFeats.length, index);\n-        for (float inputFeat : inputFeats) {\n-            index = writeFloat(data, inputFeat, index);\n-        }\n-\n-        if (outputFeats != null) {\n-            index = writeInt(data, outputFeats.length, index);\n-\n-            for (float outputFeat : outputFeats) {\n-                index = writeFloat(data, outputFeat, index);\n-            }\n-        } else {\n-            writeInt(data, 0, index);\n-        }\n-        output.write(data);\n-    }\n-\n-    private int writeInt(byte[] data, int v, int index) {\n-        data[index] = (byte) ((v >>> 24) & 0xFF);\n-        data[index + 1] = (byte) ((v >>> 16) & 0xFF);\n-        data[index + 2] = (byte) ((v >>> 8) & 0xFF);\n-        data[index + 3] = (byte) ((v) & 0xFF);\n-        return index + 4;\n-    }\n-\n-    private int writeFloat(byte[] data, float v, int index) {\n-        int iv = Float.floatToIntBits(v);\n-        return writeInt(data, iv, index);\n-    }\n-\n-    private int readInt(byte[] data, int index) {\n-        int ch1 = data[index] & 255;\n-        int ch2 = data[index + 1] & 255;\n-        int ch3 = data[index + 2] & 255;\n-        int ch4 = data[index + 3] & 255;\n-        int c = (ch1 << 24) + (ch2 << 16) + (ch3 << 8) + (ch4);\n-        return c;\n-    }\n-\n-    private float readFloat(byte[] data, int index) {\n-        return Float.intBitsToFloat(readInt(data, index));\n-    }\n-\n-\n-    @Override\n-    public void deserialize(DataInputStream input) throws IOException {\n-        byte[] data = new byte[input.readInt()];\n-        input.readFully(data);\n-        int index = 0;\n-\n-        int inputFeatLen = readInt(data, index);\n-        inputFeats = new float[inputFeatLen];\n+  private float[] inputFeats;\n+  private float[] outputFeats;\n+\n+  // Use by line with weight\n+  private transient int[] neighbors;\n+  private transient float[] weights;\n+\n+  public LINENode(float[] inputFeats, float[] outputFeats) {\n+    this.inputFeats = inputFeats;\n+    this.outputFeats = outputFeats;\n+  }\n+\n+  public LINENode() {\n+    this(null, null);\n+  }\n+\n+  public float[] getInputFeats() {\n+    return inputFeats;\n+  }\n+\n+  public void setInputFeats(float[] inputFeats) {\n+    this.inputFeats = inputFeats;\n+  }\n+\n+  public float[] getOutputFeats() {\n+    return outputFeats;\n+  }\n+\n+  public void setOutputFeats(float[] outputFeats) {\n+    this.outputFeats = outputFeats;\n+  }\n+\n+  public int[] getNeighbors() {\n+    return neighbors;\n+  }\n+\n+  public void setNeighbors(int[] neighbors) {\n+    this.neighbors = neighbors;\n+  }\n+\n+  public float[] getWeights() {\n+    return weights;\n+  }\n+\n+  public void setWeights(float[] weights) {\n+    this.weights = weights;\n+  }\n+\n+  @Override\n+  public Object deepClone() {\n+    float[] cloneInputFeats = new float[inputFeats.length];\n+    System.arraycopy(inputFeats, 0, cloneInputFeats, 0, inputFeats.length);\n+\n+    float[] cloneOutputFeats;\n+    if (outputFeats != null) {\n+      cloneOutputFeats = new float[outputFeats.length];\n+      System.arraycopy(outputFeats, 0, cloneOutputFeats, 0, outputFeats.length);\n+    }\n+    return new LINENode(inputFeats, outputFeats);\n+  }\n+\n+  @Override\n+  public void serialize(ByteBuf output) {\n+    output.writeInt(inputFeats.length);\n+    for (int i = 0; i < inputFeats.length; i++) {\n+      output.writeFloat(inputFeats[i]);\n+    }\n+\n+    if (outputFeats != null) {\n+      output.writeInt(outputFeats.length);\n+      for (int i = 0; i < outputFeats.length; i++) {\n+        output.writeFloat(outputFeats[i]);\n+      }\n+    } else {\n+      output.writeInt(0);\n+    }\n+  }\n+\n+  @Override\n+  public void deserialize(ByteBuf input) {\n+    inputFeats = new float[input.readInt()];\n+    for (int i = 0; i < inputFeats.length; i++) {\n+      inputFeats[i] = input.readFloat();\n+    }\n+\n+    int size = input.readInt();\n+    if (size > 0) {\n+      outputFeats = new float[size];\n+      for (int i = 0; i < outputFeats.length; i++) {\n+        outputFeats[i] = input.readFloat();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public int bufferLen() {\n+    return 4 + inputFeats.length * 4 + 4 + (outputFeats != null ? outputFeats.length * 4 : 0);\n+  }\n+\n+  @Override\n+  public void serialize(DataOutputStream output) throws IOException {\n+    byte[] data = new byte[bufferLen()];\n+    int index = 0;\n+    output.writeInt(data.length);\n+    index = writeInt(data, inputFeats.length, index);\n+    for (float inputFeat : inputFeats) {\n+      index = writeFloat(data, inputFeat, index);\n+    }\n+\n+    if (outputFeats != null) {\n+      index = writeInt(data, outputFeats.length, index);\n+\n+      for (float outputFeat : outputFeats) {\n+        index = writeFloat(data, outputFeat, index);\n+      }\n+    } else {\n+      writeInt(data, 0, index);\n+    }\n+    output.write(data);\n+  }\n+\n+  private int writeInt(byte[] data, int v, int index) {\n+    data[index] = (byte) ((v >>> 24) & 0xFF);\n+    data[index + 1] = (byte) ((v >>> 16) & 0xFF);\n+    data[index + 2] = (byte) ((v >>> 8) & 0xFF);\n+    data[index + 3] = (byte) ((v) & 0xFF);\n+    return index + 4;\n+  }\n+\n+  private int writeFloat(byte[] data, float v, int index) {\n+    int iv = Float.floatToIntBits(v);\n+    return writeInt(data, iv, index);\n+  }\n+\n+  private int readInt(byte[] data, int index) {\n+    int ch1 = data[index] & 255;\n+    int ch2 = data[index + 1] & 255;\n+    int ch3 = data[index + 2] & 255;\n+    int ch4 = data[index + 3] & 255;\n+    int c = (ch1 << 24) + (ch2 << 16) + (ch3 << 8) + (ch4);\n+    return c;\n+  }\n+\n+  private float readFloat(byte[] data, int index) {\n+    return Float.intBitsToFloat(readInt(data, index));\n+  }\n+\n+\n+  @Override\n+  public void deserialize(DataInputStream input) throws IOException {\n+    byte[] data = new byte[input.readInt()];\n+    input.readFully(data);\n+    int index = 0;\n+\n+    int inputFeatLen = readInt(data, index);\n+    inputFeats = new float[inputFeatLen];\n+    index += 4;\n+\n+    for (int i = 0; i < inputFeatLen; i++) {\n+      inputFeats[i] = readFloat(data, index);\n+      index += 4;\n+    }\n+\n+    int outputFeatLen = readInt(data, index);\n+    index += 4;\n+\n+    if (outputFeatLen > 0) {\n+      outputFeats = new float[outputFeatLen];\n+      for (int i = 0; i < outputFeatLen; i++) {\n+        outputFeats[i] = readFloat(data, index);\n         index += 4;\n-\n-        for (int i = 0; i < inputFeatLen; i++) {\n-            inputFeats[i] = readFloat(data, index);\n-            index += 4;\n-        }\n-\n-        int outputFeatLen = readInt(data, index);\n-        index += 4;\n-\n-        if (outputFeatLen > 0) {\n-            outputFeats = new float[outputFeatLen];\n-            for (int i = 0; i < outputFeatLen; i++) {\n-                outputFeats[i] = readFloat(data, index);\n-                index += 4;\n-            }\n-        }\n+      }\n     }\n+  }\n \n-    @Override\n-    public int dataLen() {\n-        return bufferLen();\n-    }\n+  @Override\n+  public int dataLen() {\n+    return bufferLen();\n+  }\n }\n",
            "diff_size": 191
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Angel-ML-angel/errored/1/513/LINENode.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Angel-ML-angel/naturalize/513/LINENode.java\nindex 856d3c3c661..9de322a0c8e 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Angel-ML-angel/errored/1/513/LINENode.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Angel-ML-angel/naturalize/513/LINENode.java\n@@ -15,7 +15,6 @@\n  *\n  */\n \n-\n package com.tencent.angel.graph.embedding.line;\n \n import com.tencent.angel.ps.storage.vector.element.IElement;\n@@ -29,8 +28,7 @@ import java.io.IOException;\n  * A user-define data type that store node information on PS\n  */\n public class LINENode implements IElement {\n-\n-    private float[] inputFeats;\n+  private float[] inputFeats;\n     private float[] outputFeats;\n \n     // Use by line with weight\n@@ -38,54 +36,54 @@ public class LINENode implements IElement {\n     private transient float[] weights;\n \n     public LINENode(float[] inputFeats, float[] outputFeats) {\n-        this.inputFeats = inputFeats;\n+  this.inputFeats = inputFeats;\n         this.outputFeats = outputFeats;\n-    }\n+  }\n \n     public LINENode() {\n-        this(null, null);\n+  this(null, null);\n     }\n \n     public float[] getInputFeats() {\n-        return inputFeats;\n-    }\n+  return inputFeats;\n+  }\n \n     public void setInputFeats(float[] inputFeats) {\n-        this.inputFeats = inputFeats;\n-    }\n+  this.inputFeats = inputFeats;\n+  }\n \n     public float[] getOutputFeats() {\n-        return outputFeats;\n-    }\n+  return outputFeats;\n+  }\n \n     public void setOutputFeats(float[] outputFeats) {\n-        this.outputFeats = outputFeats;\n-    }\n+  this.outputFeats = outputFeats;\n+  }\n \n     public int[] getNeighbors() {\n-        return neighbors;\n-    }\n+  return neighbors;\n+  }\n \n     public void setNeighbors(int[] neighbors) {\n-        this.neighbors = neighbors;\n-    }\n+  this.neighbors = neighbors;\n+  }\n \n     public float[] getWeights() {\n-        return weights;\n-    }\n+  return weights;\n+  }\n \n     public void setWeights(float[] weights) {\n-        this.weights = weights;\n+  this.weights = weights;\n     }\n \n     @Override\n     public Object deepClone() {\n-        float[] cloneInputFeats = new float[inputFeats.length];\n+  float[] cloneInputFeats = new float[inputFeats.length];\n         System.arraycopy(inputFeats, 0, cloneInputFeats, 0, inputFeats.length);\n \n         float[] cloneOutputFeats;\n         if (outputFeats != null) {\n-            cloneOutputFeats = new float[outputFeats.length];\n+  cloneOutputFeats = new float[outputFeats.length];\n             System.arraycopy(outputFeats, 0, cloneOutputFeats, 0, outputFeats.length);\n         }\n         return new LINENode(inputFeats, outputFeats);\n@@ -93,94 +91,93 @@ public class LINENode implements IElement {\n \n     @Override\n     public void serialize(ByteBuf output) {\n-        output.writeInt(inputFeats.length);\n+  output.writeInt(inputFeats.length);\n         for (int i = 0; i < inputFeats.length; i++) {\n-            output.writeFloat(inputFeats[i]);\n-        }\n+  output.writeFloat(inputFeats[i]);\n+  }\n \n         if (outputFeats != null) {\n-            output.writeInt(outputFeats.length);\n+  output.writeInt(outputFeats.length);\n             for (int i = 0; i < outputFeats.length; i++) {\n-                output.writeFloat(outputFeats[i]);\n+  output.writeFloat(outputFeats[i]);\n             }\n-        } else {\n-            output.writeInt(0);\n+  } else {\n+  output.writeInt(0);\n         }\n-    }\n+  }\n \n     @Override\n     public void deserialize(ByteBuf input) {\n-        inputFeats = new float[input.readInt()];\n+  inputFeats = new float[input.readInt()];\n         for (int i = 0; i < inputFeats.length; i++) {\n-            inputFeats[i] = input.readFloat();\n+  inputFeats[i] = input.readFloat();\n         }\n \n         int size = input.readInt();\n         if (size > 0) {\n-            outputFeats = new float[size];\n+  outputFeats = new float[size];\n             for (int i = 0; i < outputFeats.length; i++) {\n-                outputFeats[i] = input.readFloat();\n+  outputFeats[i] = input.readFloat();\n             }\n-        }\n-    }\n+  }\n+  }\n \n     @Override\n     public int bufferLen() {\n-        return 4 + inputFeats.length * 4 + 4 + (outputFeats != null ? outputFeats.length * 4 : 0);\n+  return 4 + inputFeats.length * 4 + 4 + (outputFeats != null ? outputFeats.length * 4 : 0);\n     }\n \n     @Override\n     public void serialize(DataOutputStream output) throws IOException {\n-        byte[] data = new byte[bufferLen()];\n+byte[] data = new byte[bufferLen()];\n         int index = 0;\n         output.writeInt(data.length);\n         index = writeInt(data, inputFeats.length, index);\n         for (float inputFeat : inputFeats) {\n-            index = writeFloat(data, inputFeat, index);\n-        }\n+  index = writeFloat(data, inputFeat, index);\n+  }\n \n         if (outputFeats != null) {\n-            index = writeInt(data, outputFeats.length, index);\n+  index = writeInt(data, outputFeats.length, index);\n \n             for (float outputFeat : outputFeats) {\n-                index = writeFloat(data, outputFeat, index);\n+  index = writeFloat(data, outputFeat, index);\n             }\n-        } else {\n-            writeInt(data, 0, index);\n-        }\n+  } else {\n+  writeInt(data, 0, index);\n+  }\n         output.write(data);\n-    }\n+  }\n \n     private int writeInt(byte[] data, int v, int index) {\n-        data[index] = (byte) ((v >>> 24) & 0xFF);\n-        data[index + 1] = (byte) ((v >>> 16) & 0xFF);\n-        data[index + 2] = (byte) ((v >>> 8) & 0xFF);\n+  data[index] = (byte) ((v>>> 24) & 0xFF);\n+        data[index + 1] = (byte) ((v>>> 16) & 0xFF);\n+        data[index + 2] = (byte) ((v>>> 8) & 0xFF);\n         data[index + 3] = (byte) ((v) & 0xFF);\n         return index + 4;\n-    }\n+  }\n \n     private int writeFloat(byte[] data, float v, int index) {\n-        int iv = Float.floatToIntBits(v);\n+  int iv = Float.floatToIntBits(v);\n         return writeInt(data, iv, index);\n-    }\n+  }\n \n     private int readInt(byte[] data, int index) {\n-        int ch1 = data[index] & 255;\n+  int ch1 = data[index] & 255;\n         int ch2 = data[index + 1] & 255;\n         int ch3 = data[index + 2] & 255;\n         int ch4 = data[index + 3] & 255;\n         int c = (ch1 << 24) + (ch2 << 16) + (ch3 << 8) + (ch4);\n         return c;\n-    }\n+  }\n \n     private float readFloat(byte[] data, int index) {\n-        return Float.intBitsToFloat(readInt(data, index));\n+  return Float.intBitsToFloat(readInt(data, index));\n     }\n \n-\n-    @Override\n+@Override\n     public void deserialize(DataInputStream input) throws IOException {\n-        byte[] data = new byte[input.readInt()];\n+byte[] data = new byte[input.readInt()];\n         input.readFully(data);\n         int index = 0;\n \n@@ -189,7 +186,7 @@ public class LINENode implements IElement {\n         index += 4;\n \n         for (int i = 0; i < inputFeatLen; i++) {\n-            inputFeats[i] = readFloat(data, index);\n+  inputFeats[i] = readFloat(data, index);\n             index += 4;\n         }\n \n@@ -197,16 +194,16 @@ public class LINENode implements IElement {\n         index += 4;\n \n         if (outputFeatLen > 0) {\n-            outputFeats = new float[outputFeatLen];\n+  outputFeats = new float[outputFeatLen];\n             for (int i = 0; i < outputFeatLen; i++) {\n-                outputFeats[i] = readFloat(data, index);\n+  outputFeats[i] = readFloat(data, index);\n                 index += 4;\n             }\n-        }\n-    }\n+  }\n+  }\n \n     @Override\n     public int dataLen() {\n-        return bufferLen();\n+  return bufferLen();\n     }\n-}\n+  }\n\\ No newline at end of file\n",
            "diff_size": 66
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "36",
                    "severity": "error",
                    "message": "Comment has incorrect indentation level 4, expected is 2, indentation should be the same level as line 37.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Angel-ML-angel/errored/1/513/LINENode.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Angel-ML-angel/codebuff/513/LINENode.java\nindex 856d3c3c661..3e5e66048a1 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Angel-ML-angel/errored/1/513/LINENode.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Angel-ML-angel/codebuff/513/LINENode.java\n@@ -20,7 +20,6 @@ package com.tencent.angel.graph.embedding.line;\n \n import com.tencent.angel.ps.storage.vector.element.IElement;\n import io.netty.buffer.ByteBuf;\n-\n import java.io.DataInputStream;\n import java.io.DataOutputStream;\n import java.io.IOException;\n@@ -28,185 +27,182 @@ import java.io.IOException;\n /**\n  * A user-define data type that store node information on PS\n  */\n+\n public class LINENode implements IElement {\n \n-    private float[] inputFeats;\n-    private float[] outputFeats;\n+  private float[] inputFeats;\n+  private float[] outputFeats;\n \n     // Use by line with weight\n-    private transient int[] neighbors;\n-    private transient float[] weights;\n-\n-    public LINENode(float[] inputFeats, float[] outputFeats) {\n-        this.inputFeats = inputFeats;\n-        this.outputFeats = outputFeats;\n-    }\n-\n-    public LINENode() {\n-        this(null, null);\n-    }\n-\n-    public float[] getInputFeats() {\n-        return inputFeats;\n-    }\n-\n-    public void setInputFeats(float[] inputFeats) {\n-        this.inputFeats = inputFeats;\n-    }\n-\n-    public float[] getOutputFeats() {\n-        return outputFeats;\n-    }\n-\n-    public void setOutputFeats(float[] outputFeats) {\n-        this.outputFeats = outputFeats;\n-    }\n-\n-    public int[] getNeighbors() {\n-        return neighbors;\n-    }\n-\n-    public void setNeighbors(int[] neighbors) {\n-        this.neighbors = neighbors;\n-    }\n-\n-    public float[] getWeights() {\n-        return weights;\n-    }\n-\n-    public void setWeights(float[] weights) {\n-        this.weights = weights;\n-    }\n-\n-    @Override\n-    public Object deepClone() {\n-        float[] cloneInputFeats = new float[inputFeats.length];\n-        System.arraycopy(inputFeats, 0, cloneInputFeats, 0, inputFeats.length);\n-\n-        float[] cloneOutputFeats;\n-        if (outputFeats != null) {\n-            cloneOutputFeats = new float[outputFeats.length];\n-            System.arraycopy(outputFeats, 0, cloneOutputFeats, 0, outputFeats.length);\n-        }\n-        return new LINENode(inputFeats, outputFeats);\n-    }\n-\n-    @Override\n-    public void serialize(ByteBuf output) {\n-        output.writeInt(inputFeats.length);\n-        for (int i = 0; i < inputFeats.length; i++) {\n-            output.writeFloat(inputFeats[i]);\n-        }\n-\n-        if (outputFeats != null) {\n-            output.writeInt(outputFeats.length);\n-            for (int i = 0; i < outputFeats.length; i++) {\n-                output.writeFloat(outputFeats[i]);\n-            }\n-        } else {\n-            output.writeInt(0);\n-        }\n-    }\n-\n-    @Override\n-    public void deserialize(ByteBuf input) {\n-        inputFeats = new float[input.readInt()];\n-        for (int i = 0; i < inputFeats.length; i++) {\n-            inputFeats[i] = input.readFloat();\n-        }\n-\n-        int size = input.readInt();\n-        if (size > 0) {\n-            outputFeats = new float[size];\n-            for (int i = 0; i < outputFeats.length; i++) {\n-                outputFeats[i] = input.readFloat();\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public int bufferLen() {\n-        return 4 + inputFeats.length * 4 + 4 + (outputFeats != null ? outputFeats.length * 4 : 0);\n-    }\n-\n-    @Override\n-    public void serialize(DataOutputStream output) throws IOException {\n-        byte[] data = new byte[bufferLen()];\n-        int index = 0;\n-        output.writeInt(data.length);\n-        index = writeInt(data, inputFeats.length, index);\n-        for (float inputFeat : inputFeats) {\n-            index = writeFloat(data, inputFeat, index);\n-        }\n-\n-        if (outputFeats != null) {\n-            index = writeInt(data, outputFeats.length, index);\n-\n-            for (float outputFeat : outputFeats) {\n-                index = writeFloat(data, outputFeat, index);\n-            }\n-        } else {\n-            writeInt(data, 0, index);\n-        }\n-        output.write(data);\n-    }\n-\n-    private int writeInt(byte[] data, int v, int index) {\n-        data[index] = (byte) ((v >>> 24) & 0xFF);\n-        data[index + 1] = (byte) ((v >>> 16) & 0xFF);\n-        data[index + 2] = (byte) ((v >>> 8) & 0xFF);\n-        data[index + 3] = (byte) ((v) & 0xFF);\n-        return index + 4;\n-    }\n-\n-    private int writeFloat(byte[] data, float v, int index) {\n-        int iv = Float.floatToIntBits(v);\n-        return writeInt(data, iv, index);\n-    }\n-\n-    private int readInt(byte[] data, int index) {\n-        int ch1 = data[index] & 255;\n-        int ch2 = data[index + 1] & 255;\n-        int ch3 = data[index + 2] & 255;\n-        int ch4 = data[index + 3] & 255;\n-        int c = (ch1 << 24) + (ch2 << 16) + (ch3 << 8) + (ch4);\n-        return c;\n-    }\n-\n-    private float readFloat(byte[] data, int index) {\n-        return Float.intBitsToFloat(readInt(data, index));\n-    }\n-\n-\n-    @Override\n-    public void deserialize(DataInputStream input) throws IOException {\n-        byte[] data = new byte[input.readInt()];\n-        input.readFully(data);\n-        int index = 0;\n-\n-        int inputFeatLen = readInt(data, index);\n-        inputFeats = new float[inputFeatLen];\n+  private transient int[] neighbors;\n+  private transient float[] weights;\n+\n+  public LINENode(float[] inputFeats, float[] outputFeats) {\n+    this.inputFeats = inputFeats;\n+    this.outputFeats = outputFeats;\n+  }\n+\n+  public LINENode() {\n+    this(null, null);\n+  }\n+\n+  public float[] getInputFeats() {\n+    return inputFeats;\n+  }\n+\n+  public void setInputFeats(float[] inputFeats) {\n+    this.inputFeats = inputFeats;\n+  }\n+\n+  public float[] getOutputFeats() {\n+    return outputFeats;\n+  }\n+\n+  public void setOutputFeats(float[] outputFeats) {\n+    this.outputFeats = outputFeats;\n+  }\n+\n+  public int[] getNeighbors() {\n+    return neighbors;\n+  }\n+\n+  public void setNeighbors(int[] neighbors) {\n+    this.neighbors = neighbors;\n+  }\n+\n+  public float[] getWeights() {\n+    return weights;\n+  }\n+\n+  public void setWeights(float[] weights) {\n+    this.weights = weights;\n+  }\n+\n+  @Override\n+  public Object deepClone() {\n+    float[] cloneInputFeats = new float[inputFeats.length];\n+    System.arraycopy(inputFeats, 0, cloneInputFeats, 0, inputFeats.length);\n+    float[] cloneOutputFeats;\n+    if (outputFeats != null) {\n+      cloneOutputFeats = new float[outputFeats.length];\n+      System.arraycopy(outputFeats, 0, cloneOutputFeats, 0, outputFeats.length);\n+    }\n+    return new LINENode(inputFeats, outputFeats);\n+  }\n+\n+  @Override\n+  public void serialize(ByteBuf output) {\n+    output.writeInt(inputFeats.length);\n+    for (int i = 0; i < inputFeats.length; i++) {\n+      output.writeFloat(inputFeats[i]);\n+    }\n+\n+    if (outputFeats != null) {\n+      output.writeInt(outputFeats.length);\n+      for (int i = 0; i < outputFeats.length; i++) {\n+        output.writeFloat(outputFeats[i]);\n+      }\n+    } else {\n+      output.writeInt(0);\n+    }\n+  }\n+\n+  @Override\n+  public void deserialize(ByteBuf input) {\n+    inputFeats = new float[input.readInt()];\n+    for (int i = 0; i < inputFeats.length; i++) {\n+      inputFeats[i] = input.readFloat();\n+    }\n+\n+    int size = input.readInt();\n+    if (size > 0) {\n+      outputFeats = new float[size];\n+      for (int i = 0; i < outputFeats.length; i++) {\n+        outputFeats[i] = input.readFloat();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public int bufferLen() {\n+    return 4 + inputFeats.length * 4 + 4 + (outputFeats != null ? outputFeats.length * 4 : 0);\n+  }\n+\n+  @Override\n+  public void serialize(DataOutputStream output) throws IOException {\n+    byte[] data = new byte[bufferLen()];\n+    int index = 0;\n+    output.writeInt(data.length);\n+    index = writeInt(data, inputFeats.length, index);\n+    for (float inputFeat : inputFeats) {\n+      index = writeFloat(data, inputFeat, index);\n+    }\n+\n+    if (outputFeats != null) {\n+      index = writeInt(data, outputFeats.length, index);\n+      for (float outputFeat : outputFeats) {\n+        index = writeFloat(data, outputFeat, index);\n+      }\n+    } else {\n+      writeInt(data, 0, index);\n+    }\n+    output.write(data);\n+  }\n+\n+  private int writeInt(byte[] data, int v, int index) {\n+    data[index] = (byte) ((v >>> 24) & 0xFF);\n+    data[index + 1] = (byte) ((v >>> 16) & 0xFF);\n+    data[index + 2] = (byte) ((v >>> 8) & 0xFF);\n+    data[index + 3] = (byte) ((v) & 0xFF);\n+    return index + 4;\n+  }\n+\n+  private int writeFloat(byte[] data, float v, int index) {\n+    int iv = Float.floatToIntBits(v);\n+    return writeInt(data, iv, index);\n+  }\n+\n+  private int readInt(byte[] data, int index) {\n+    int ch1 = data[index] & 255;\n+    int ch2 = data[index + 1] & 255;\n+    int ch3 = data[index + 2] & 255;\n+    int ch4 = data[index + 3] & 255;\n+    int c = (ch1 << 24) + (ch2 << 16) + (ch3 << 8) + (ch4);\n+    return c;\n+  }\n+\n+  private float readFloat(byte[] data, int index) {\n+    return Float.intBitsToFloat(readInt(data, index));\n+  }\n+\n+  @Override\n+  public void deserialize(DataInputStream input) throws IOException {\n+    byte[] data = new byte[input.readInt()];\n+    input.readFully(data);\n+\n+    int index = 0;\n+    int inputFeatLen = readInt(data, index);\n+    inputFeats = new float[inputFeatLen];\n+    index += 4;\n+    for (int i = 0; i < inputFeatLen; i++) {\n+      inputFeats[i] = readFloat(data, index);\n+      index += 4;\n+    }\n+\n+    int outputFeatLen = readInt(data, index);\n+    index += 4;\n+    if (outputFeatLen > 0) {\n+      outputFeats = new float[outputFeatLen];\n+      for (int i = 0; i < outputFeatLen; i++) {\n+        outputFeats[i] = readFloat(data, index);\n         index += 4;\n-\n-        for (int i = 0; i < inputFeatLen; i++) {\n-            inputFeats[i] = readFloat(data, index);\n-            index += 4;\n-        }\n-\n-        int outputFeatLen = readInt(data, index);\n-        index += 4;\n-\n-        if (outputFeatLen > 0) {\n-            outputFeats = new float[outputFeatLen];\n-            for (int i = 0; i < outputFeatLen; i++) {\n-                outputFeats[i] = readFloat(data, index);\n-                index += 4;\n-            }\n-        }\n+      }\n     }\n+  }\n \n-    @Override\n-    public int dataLen() {\n-        return bufferLen();\n-    }\n-}\n+  @Override\n+  public int dataLen() {\n+    return bufferLen();\n+  }\n+\n+}\n\\ No newline at end of file\n",
            "diff_size": 188
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ],
    "repaired_by": [],
    "not_repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}