{
    "project_name": "wso2-attic-commons",
    "error_id": "576",
    "information": {
        "errors": [
            {
                "line": "123",
                "severity": "error",
                "message": "Line is longer than 120 characters (found 122).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": "\t\t\tcode.add(Status.STATUS_SYNTAX_ERROR);\n\t\t\tStatus status = new Status(code, pe.getMessage());\n\t\t\treturn new ResponseCtx(ResultFactory.getFactory().getResult(AbstractResult.DECISION_INDETERMINATE,\n                    status, evalContext));\n\n\t\t}",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/576/PDP.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler/576/PDP.java\nindex a01f96caaa0..39cc02a2f75 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/576/PDP.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler/576/PDP.java\n@@ -120,8 +120,8 @@ public class PDP {\n \t\t\tArrayList<String> code = new ArrayList<String>();\n \t\t\tcode.add(Status.STATUS_SYNTAX_ERROR);\n \t\t\tStatus status = new Status(code, pe.getMessage());\n-\t\t\treturn new ResponseCtx(ResultFactory.getFactory().getResult(AbstractResult.DECISION_INDETERMINATE,\n-                    status, evalContext));\n+\t\treturn new ResponseCtx(ResultFactory.getFactory().getResult(AbstractResult.DECISION_INDETERMINATE,\n+           status, evalContext));\n \n \t\t}\n     }\n",
            "diff_size": 2
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/576/PDP.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/intellij/576/PDP.java\nindex a01f96caaa0..3f8d538bd7e 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/576/PDP.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/intellij/576/PDP.java\n@@ -8,7 +8,7 @@\n  *\n  *   1. Redistribution of source code must retain the above copyright notice,\n  *      this list of conditions and the following disclaimer.\n- * \n+ *\n  *   2. Redistribution in binary form must reproduce the above copyright\n  *      notice, this list of conditions and the following disclaimer in the\n  *      documentation and/or other materials provided with the distribution.\n@@ -16,7 +16,7 @@\n  * Neither the name of Sun Microsystems, Inc. or the names of contributors may\n  * be used to endorse or promote products derived from this software without\n  * specific prior written permission.\n- * \n+ *\n  * This software is provided \"AS IS,\" without a warranty of any kind. ALL\n  * EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND WARRANTIES, INCLUDING\n  * ANY IMPLIED WARRANTY OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE\n@@ -54,218 +54,215 @@ import java.util.*;\n /**\n  * This is the core class for the XACML engine, providing the starting point for request evaluation.\n  * To build an XACML policy engine, you start by instantiating this object.\n- * \n- * @since 1.0\n+ *\n  * @author Seth Proctor\n+ * @since 1.0\n  */\n public class PDP {\n \n-    /**\n-     * the encapsulate the <code>PDP</code> related configurations\n-     */\n-    private PDPConfig pdpConfig;\n-\n-    /**\n-     * the single policy finder that will be used to resolve policies\n-     */\n-\tprivate PolicyFinder policyFinder;\n-\n-    /**\n-     * the logger we'll use for all messages\n-     */\n-\tprivate static Log logger = LogFactory.getLog(PDP.class);\n-\n-\t/**\n-\t * Constructs a new <code>PDP</code> object with the given configuration information.\n-\t * \n-\t * @param pdpConfig user configuration data defining how to find policies, resolve external\n-\t *            attributes, etc.\n-\t */\n-\tpublic PDP(PDPConfig pdpConfig) {\n-\n-\t\tif (logger.isDebugEnabled()) {\n-\t\t\tlogger.debug(\"creating a PDP\");\n-\t\t}\n-\n-        this.pdpConfig = pdpConfig;\n-        \n-\t\tpolicyFinder = pdpConfig.getPolicyFinder();\n-\t\tpolicyFinder.init();\n-\t}\n-\n-\t/**\n-\t * Attempts to evaluate the request against the policies known to this PDP. This is really the\n-\t * core method of the entire XACML specification, and for most people will provide what you\n-\t * want. If you need any special handling, you should look at the version of this method that\n-\t * takes an <code>EvaluationCtx</code>.\n-\t * <p>\n-\t * Note that if the request is somehow invalid (it was missing a required attribute, it was\n-\t * using an unsupported scope, etc), then the result will be a decision of INDETERMINATE.\n-\t * \n-\t * @param request the request to evaluate\n-\t * \n-\t * @return a response paired to the request\n-\t */\n-\tpublic ResponseCtx evaluate(AbstractRequestCtx request) {\n-\n-        EvaluationCtx evalContext = null;\n-\t\ttry {\n-            evalContext = EvaluationCtxFactory.getFactory().getEvaluationCtx(request, pdpConfig);\n-\t\t\treturn evaluate(evalContext);\n-\t\t} catch (ParsingException pe) {\n-\t\t\tlogger.error(\"the PDP received an invalid request\", pe);\n-\t\t\t// there was something wrong with the request, so we return\n-\t\t\t// Indeterminate with a status of syntax error...though this\n-\t\t\t// may change if a more appropriate status type exists\n-\t\t\tArrayList<String> code = new ArrayList<String>();\n-\t\t\tcode.add(Status.STATUS_SYNTAX_ERROR);\n-\t\t\tStatus status = new Status(code, pe.getMessage());\n-\t\t\treturn new ResponseCtx(ResultFactory.getFactory().getResult(AbstractResult.DECISION_INDETERMINATE,\n-                    status, evalContext));\n-\n-\t\t}\n+  /**\n+   * the encapsulate the <code>PDP</code> related configurations\n+   */\n+  private PDPConfig pdpConfig;\n+\n+  /**\n+   * the single policy finder that will be used to resolve policies\n+   */\n+  private PolicyFinder policyFinder;\n+\n+  /**\n+   * the logger we'll use for all messages\n+   */\n+  private static Log logger = LogFactory.getLog(PDP.class);\n+\n+  /**\n+   * Constructs a new <code>PDP</code> object with the given configuration information.\n+   *\n+   * @param pdpConfig user configuration data defining how to find policies, resolve external\n+   *                  attributes, etc.\n+   */\n+  public PDP(PDPConfig pdpConfig) {\n+\n+    if (logger.isDebugEnabled()) {\n+      logger.debug(\"creating a PDP\");\n     }\n \n-\t/**\n-\t * Uses the given <code>EvaluationCtx</code> against the available policies to determine a\n-\t * response. If you are starting with a standard XACML Request, then you should use the version\n-\t * of this method that takes a <code>RequestCtx</code>. This method should be used only if you\n-\t * have a real need to directly construct an evaluation context (or if you need to use an\n-\t * <code>EvaluationCtx</code> implementation other than <code>XACML3EvaluationCtx</code> and\n-     * <code>XACML2EvaluationCtx</code>).\n-\t * \n-\t * @param context representation of the request and the context used for evaluation\n-\t * \n-\t * @return a response based on the contents of the context\n-\t */\n-\tpublic ResponseCtx evaluate(EvaluationCtx context) {\n-\n-        // check whether this PDP configure to support multiple decision profile\n-        if(pdpConfig.isMultipleRequestHandle()){\n-\n-            Set<EvaluationCtx> evaluationCtxSet;\n-            MultipleCtxResult multipleCtxResult = context.getMultipleEvaluationCtx();\n-            if(multipleCtxResult.isIndeterminate()){\n-                return new ResponseCtx(ResultFactory.getFactory().\n-                        getResult(AbstractResult.DECISION_INDETERMINATE,multipleCtxResult.getStatus(), context));\n-            } else {\n-                evaluationCtxSet = multipleCtxResult.getEvaluationCtxSet();                \n-                HashSet<AbstractResult> results = new HashSet<AbstractResult>();\n-                for(EvaluationCtx ctx : evaluationCtxSet){\n-                    // do the evaluation, for all evaluate context\n-                    AbstractResult result = evaluateContext(ctx);\n-                    // add the result\n-                    results.add(result);\n-                }\n-                return new ResponseCtx(results);\n-            }\n-        } else {\n-            // this is special case that specific to XACML3 request\n-\n-            if(context instanceof XACML3EvaluationCtx && ((XACML3EvaluationCtx)context).\n-                                                                            isMultipleAttributes()){\n-                ArrayList<String> code = new ArrayList<String>();\n-                code.add(Status.STATUS_SYNTAX_ERROR);\n-                Status status = new Status(code, \"PDP does not supports multiple decision profile. \" +\n-                        \"Multiple <Attributes> elements with the same Category can be existed\");\n-                return new ResponseCtx(ResultFactory.getFactory().getResult(AbstractResult.DECISION_INDETERMINATE,\n-                        status, context));\n-            } else if(context instanceof XACML3EvaluationCtx && ((RequestCtx)context.\n-                    getRequestCtx()).isCombinedDecision()){\n-                List<String> code = new ArrayList<String>();\n-                code.add(Status.STATUS_PROCESSING_ERROR);\n-                Status status = new Status(code, \"PDP does not supports multiple decision profile. \" +\n-                        \"Multiple decision is not existed to combine them\");\n-                return new ResponseCtx(ResultFactory.getFactory().getResult(AbstractResult.DECISION_INDETERMINATE,\n-                        status, context));\n-            } else {\n-                return new ResponseCtx(evaluateContext(context));\n-            }\n-        }\n+    this.pdpConfig = pdpConfig;\n+\n+    policyFinder = pdpConfig.getPolicyFinder();\n+    policyFinder.init();\n+  }\n+\n+  /**\n+   * Attempts to evaluate the request against the policies known to this PDP. This is really the\n+   * core method of the entire XACML specification, and for most people will provide what you\n+   * want. If you need any special handling, you should look at the version of this method that\n+   * takes an <code>EvaluationCtx</code>.\n+   * <p>\n+   * Note that if the request is somehow invalid (it was missing a required attribute, it was\n+   * using an unsupported scope, etc), then the result will be a decision of INDETERMINATE.\n+   *\n+   * @param request the request to evaluate\n+   * @return a response paired to the request\n+   */\n+  public ResponseCtx evaluate(AbstractRequestCtx request) {\n+\n+    EvaluationCtx evalContext = null;\n+    try {\n+      evalContext = EvaluationCtxFactory.getFactory().getEvaluationCtx(request, pdpConfig);\n+      return evaluate(evalContext);\n+    } catch (ParsingException pe) {\n+      logger.error(\"the PDP received an invalid request\", pe);\n+      // there was something wrong with the request, so we return\n+      // Indeterminate with a status of syntax error...though this\n+      // may change if a more appropriate status type exists\n+      ArrayList<String> code = new ArrayList<String>();\n+      code.add(Status.STATUS_SYNTAX_ERROR);\n+      Status status = new Status(code, pe.getMessage());\n+      return new ResponseCtx(ResultFactory.getFactory().getResult(AbstractResult.DECISION_INDETERMINATE,\n+        status, evalContext));\n \n-\t}\n-\n-\t/**\n-\t * A private helper routine that resolves a policy for the given context, and then tries to\n-\t * evaluate based on the policy\n-     *\n-     * @param context  context\n-     * @return a response\n-     */\n-\tprivate AbstractResult evaluateContext(EvaluationCtx context) {\n-\t\t// first off, try to find a policy\n-\t\tPolicyFinderResult finderResult = policyFinder.findPolicy(context);\n-\n-\t\t// see if there weren't any applicable policies\n-\t\tif (finderResult.notApplicable()){\n-\t\t\t//return new Result(Result.DECISION_NOT_APPLICABLE, context.getResourceId().encode());\n-            return ResultFactory.getFactory().getResult(AbstractResult.DECISION_NOT_APPLICABLE, context);\n+    }\n+  }\n+\n+  /**\n+   * Uses the given <code>EvaluationCtx</code> against the available policies to determine a\n+   * response. If you are starting with a standard XACML Request, then you should use the version\n+   * of this method that takes a <code>RequestCtx</code>. This method should be used only if you\n+   * have a real need to directly construct an evaluation context (or if you need to use an\n+   * <code>EvaluationCtx</code> implementation other than <code>XACML3EvaluationCtx</code> and\n+   * <code>XACML2EvaluationCtx</code>).\n+   *\n+   * @param context representation of the request and the context used for evaluation\n+   * @return a response based on the contents of the context\n+   */\n+  public ResponseCtx evaluate(EvaluationCtx context) {\n+\n+    // check whether this PDP configure to support multiple decision profile\n+    if (pdpConfig.isMultipleRequestHandle()) {\n+\n+      Set<EvaluationCtx> evaluationCtxSet;\n+      MultipleCtxResult multipleCtxResult = context.getMultipleEvaluationCtx();\n+      if (multipleCtxResult.isIndeterminate()) {\n+        return new ResponseCtx(ResultFactory.getFactory().\n+          getResult(AbstractResult.DECISION_INDETERMINATE, multipleCtxResult.getStatus(), context));\n+      } else {\n+        evaluationCtxSet = multipleCtxResult.getEvaluationCtxSet();\n+        HashSet<AbstractResult> results = new HashSet<AbstractResult>();\n+        for (EvaluationCtx ctx : evaluationCtxSet) {\n+          // do the evaluation, for all evaluate context\n+          AbstractResult result = evaluateContext(ctx);\n+          // add the result\n+          results.add(result);\n         }\n-\t\t// see if there were any errors in trying to get a policy\n-\t\tif (finderResult.indeterminate()){\n+        return new ResponseCtx(results);\n+      }\n+    } else {\n+      // this is special case that specific to XACML3 request\n+\n+      if (context instanceof XACML3EvaluationCtx && ((XACML3EvaluationCtx) context).\n+        isMultipleAttributes()) {\n+        ArrayList<String> code = new ArrayList<String>();\n+        code.add(Status.STATUS_SYNTAX_ERROR);\n+        Status status = new Status(code, \"PDP does not supports multiple decision profile. \" +\n+          \"Multiple <Attributes> elements with the same Category can be existed\");\n+        return new ResponseCtx(ResultFactory.getFactory().getResult(AbstractResult.DECISION_INDETERMINATE,\n+          status, context));\n+      } else if (context instanceof XACML3EvaluationCtx && ((RequestCtx) context.\n+        getRequestCtx()).isCombinedDecision()) {\n+        List<String> code = new ArrayList<String>();\n+        code.add(Status.STATUS_PROCESSING_ERROR);\n+        Status status = new Status(code, \"PDP does not supports multiple decision profile. \" +\n+          \"Multiple decision is not existed to combine them\");\n+        return new ResponseCtx(ResultFactory.getFactory().getResult(AbstractResult.DECISION_INDETERMINATE,\n+          status, context));\n+      } else {\n+        return new ResponseCtx(evaluateContext(context));\n+      }\n+    }\n+\n+  }\n+\n+  /**\n+   * A private helper routine that resolves a policy for the given context, and then tries to\n+   * evaluate based on the policy\n+   *\n+   * @param context context\n+   * @return a response\n+   */\n+  private AbstractResult evaluateContext(EvaluationCtx context) {\n+    // first off, try to find a policy\n+    PolicyFinderResult finderResult = policyFinder.findPolicy(context);\n+\n+    // see if there weren't any applicable policies\n+    if (finderResult.notApplicable()) {\n+      //return new Result(Result.DECISION_NOT_APPLICABLE, context.getResourceId().encode());\n+      return ResultFactory.getFactory().getResult(AbstractResult.DECISION_NOT_APPLICABLE, context);\n+    }\n+    // see if there were any errors in trying to get a policy\n+    if (finderResult.indeterminate()) {\n //\t\t\treturn new Result(Result.DECISION_INDETERMINATE, finderResult.getStatus(), context\n //\t\t\t\t\t.getResourceId().encode());\n-            return ResultFactory.getFactory().getResult(AbstractResult.DECISION_INDETERMINATE,\n-                    finderResult.getStatus(),context);\n-        }\n+      return ResultFactory.getFactory().getResult(AbstractResult.DECISION_INDETERMINATE,\n+        finderResult.getStatus(), context);\n+    }\n \n-        Set<String> policyIds = new HashSet<String>();\n-\n-        AbstractPolicy policy = finderResult.getPolicy();\n-        if(policy instanceof Policy){\n-            policyIds.add(policy.getId().toString());\n-        } else if(policy instanceof PolicySet){\n-            Iterator iterator = policy.getChildElements().iterator();\n-            while(iterator.hasNext()){\n-                AbstractPolicy child = (AbstractPolicy) iterator.next();\n-                policyIds.add(child.getId().toString());\n-            }\n-        }\n+    Set<String> policyIds = new HashSet<String>();\n+\n+    AbstractPolicy policy = finderResult.getPolicy();\n+    if (policy instanceof Policy) {\n+      policyIds.add(policy.getId().toString());\n+    } else if (policy instanceof PolicySet) {\n+      Iterator iterator = policy.getChildElements().iterator();\n+      while (iterator.hasNext()) {\n+        AbstractPolicy child = (AbstractPolicy) iterator.next();\n+        policyIds.add(child.getId().toString());\n+      }\n+    }\n+\n+    // we found a valid policy, so we can do the evaluation\n+    return finderResult.getPolicy().evaluate(context);\n+  }\n+\n+  /**\n+   * A utility method that wraps the functionality of the other evaluate method with input and\n+   * output streams. This is useful if you've got a PDP that is taking inputs from some stream and\n+   * is returning responses through the same stream system. If the Request is invalid, then this\n+   * will always return a decision of INDETERMINATE.\n+   *\n+   * @param input a stream that contains an XML RequestType\n+   * @return a stream that contains an XML ResponseType\n+   * @deprecated As of 1.2 this method should not be used. Instead, you should do your own stream\n+   * handling, and then use one of the other <code>evaluate</code> methods. The\n+   * problem with this method is that it often doesn't handle stream termination\n+   * correctly (eg, with sockets).\n+   */\n+  public OutputStream evaluate(InputStream input) {\n+    AbstractRequestCtx request = null;\n+    ResponseCtx response = null;\n+\n+    try {\n+      request = RequestCtxFactory.getFactory().getRequestCtx(input);\n+    } catch (Exception pe) {\n+      // the request wasn't formed correctly\n+      ArrayList<String> code = new ArrayList<String>();\n+      code.add(Status.STATUS_SYNTAX_ERROR);\n+      Status status = new Status(code, \"invalid request: \" + pe.getMessage());\n+      // can not determine XACML version at here. therefore return assume as XACML 3\n+      response = new ResponseCtx(ResultFactory.getFactory().\n+        getResult(AbstractResult.DECISION_INDETERMINATE, status, XACMLConstants.XACML_VERSION_3_0));\n+    }\n+\n+    // if we didn't have a problem above, then we should go ahead\n+    // with the evaluation\n+    if (response == null) {\n+      response = evaluate(request);\n+    }\n+\n+    ByteArrayOutputStream out = new ByteArrayOutputStream();\n+    response.encode(out, new Indenter());\n \n-\t\t// we found a valid policy, so we can do the evaluation\n-\t\treturn finderResult.getPolicy().evaluate(context);\n-\t}\n-\n-\t/**\n-\t * A utility method that wraps the functionality of the other evaluate method with input and\n-\t * output streams. This is useful if you've got a PDP that is taking inputs from some stream and\n-\t * is returning responses through the same stream system. If the Request is invalid, then this\n-\t * will always return a decision of INDETERMINATE.\n-\t * \n-\t * @deprecated As of 1.2 this method should not be used. Instead, you should do your own stream\n-\t *             handling, and then use one of the other <code>evaluate</code> methods. The\n-\t *             problem with this method is that it often doesn't handle stream termination\n-\t *             correctly (eg, with sockets).\n-\t * \n-\t * @param input a stream that contains an XML RequestType\n-\t * \n-\t * @return a stream that contains an XML ResponseType\n-\t */\n-\tpublic OutputStream evaluate(InputStream input) {\n-\t\tAbstractRequestCtx request = null;\n-\t\tResponseCtx response = null;\n-\n-\t\ttry {\n-\t\t\trequest = RequestCtxFactory.getFactory().getRequestCtx(input);\n-\t\t} catch (Exception pe) {\n-\t\t\t// the request wasn't formed correctly\n-\t\t\tArrayList<String> code = new ArrayList<String>();\n-\t\t\tcode.add(Status.STATUS_SYNTAX_ERROR);\n-\t\t\tStatus status = new Status(code, \"invalid request: \" + pe.getMessage());\n-            // can not determine XACML version at here. therefore return assume as XACML 3\n-            response = new ResponseCtx(ResultFactory.getFactory().\n-                getResult(AbstractResult.DECISION_INDETERMINATE, status, XACMLConstants.XACML_VERSION_3_0));\n-\t\t}\n-\n-\t\t// if we didn't have a problem above, then we should go ahead\n-\t\t// with the evaluation\n-\t\tif (response == null)\n-\t\t\tresponse = evaluate(request);\n-\n-\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n-\t\tresponse.encode(out, new Indenter());\n-\n-\t\treturn out;\n-\t}\n+    return out;\n+  }\n \n }\n",
            "diff_size": 305
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/576/PDP.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler_random/576/PDP.java\nindex a01f96caaa0..39cc02a2f75 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/576/PDP.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler_random/576/PDP.java\n@@ -120,8 +120,8 @@ public class PDP {\n \t\t\tArrayList<String> code = new ArrayList<String>();\n \t\t\tcode.add(Status.STATUS_SYNTAX_ERROR);\n \t\t\tStatus status = new Status(code, pe.getMessage());\n-\t\t\treturn new ResponseCtx(ResultFactory.getFactory().getResult(AbstractResult.DECISION_INDETERMINATE,\n-                    status, evalContext));\n+\t\treturn new ResponseCtx(ResultFactory.getFactory().getResult(AbstractResult.DECISION_INDETERMINATE,\n+           status, evalContext));\n \n \t\t}\n     }\n",
            "diff_size": 2
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "123",
                    "severity": "error",
                    "message": "Line is longer than 120 characters (found 122).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/576/PDP.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler_three_grams/576/PDP.java\nindex a01f96caaa0..a38fc1665ab 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/576/PDP.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler_three_grams/576/PDP.java\n@@ -121,7 +121,7 @@ public class PDP {\n \t\t\tcode.add(Status.STATUS_SYNTAX_ERROR);\n \t\t\tStatus status = new Status(code, pe.getMessage());\n \t\t\treturn new ResponseCtx(ResultFactory.getFactory().getResult(AbstractResult.DECISION_INDETERMINATE,\n-                    status, evalContext));\n+                                          status, evalContext));\n \n \t\t}\n     }\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "styler_random"
    ],
    "not_repaired_by": [
        "naturalize",
        "codebuff",
        "styler_three_grams"
    ]
}