{
    "project_name": "TIBCOSoftware-genxdm",
    "error_id": "249",
    "information": {
        "errors": [
            {
                "line": "65",
                "column": "1",
                "severity": "warning",
                "message": "File contains tab characters (this is the first instance).",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
            }
        ]
    },
    "source_code": "final class AttributeManager<A>\n{\n\tprivate final AtomBridge<A> atomBridge;\n\t// Keep track of the attributes that we have seen in order to report missing attributes.\n\tprivate final Set<QName> m_attributes = new HashSet<QName>();\n\tprivate Boolean m_localNil = null;",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "66",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/249/AttributeManager.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler/249/AttributeManager.java\nindex bcf23250b47..c83ccb6180c 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/249/AttributeManager.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler/249/AttributeManager.java\n@@ -62,7 +62,7 @@ import org.genxdm.xs.types.Type;\n  */\n final class AttributeManager<A>\n {\n-\tprivate final AtomBridge<A> atomBridge;\n+private final AtomBridge<A> atomBridge;\n \t// Keep track of the attributes that we have seen in order to report missing attributes.\n \tprivate final Set<QName> m_attributes = new HashSet<QName>();\n \tprivate Boolean m_localNil = null;\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/249/AttributeManager.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/intellij/249/AttributeManager.java\nindex bcf23250b47..6147ba0f099 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/249/AttributeManager.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/intellij/249/AttributeManager.java\n@@ -1,18 +1,19 @@\n /**\n  * Copyright (c) 2009-2010 TIBCO Software Inc.\n- *\n+ * <p>\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+\n package org.genxdm.processor.w3c.xs.validation.impl;\n \n import java.io.IOException;\n@@ -60,585 +61,583 @@ import org.genxdm.xs.types.Type;\n /**\n  * Performs activities related to attribute validation.\n  */\n-final class AttributeManager<A>\n-{\n-\tprivate final AtomBridge<A> atomBridge;\n-\t// Keep track of the attributes that we have seen in order to report missing attributes.\n-\tprivate final Set<QName> m_attributes = new HashSet<QName>();\n-\tprivate Boolean m_localNil = null;\n-\tprivate Type m_localType = null;\n-\tprivate final HashMap<QName, Pair<A, SimpleType>> m_xsiAtoms = new HashMap<QName, Pair<A, SimpleType>>();\n-\tprivate final HashMap<QName, Pair<List<? extends A>, SimpleType>> m_xsiLists = new HashMap<QName, Pair<List<? extends A>, SimpleType>>();\n-\tprivate final ComponentProvider metaBridge;\n-\tprivate final String W3C_XML_SCHEMA_INSTANCE_NS_URI;\n-\tprivate final String XSI_NIL;\n-\tprivate final String XSI_NO_NAMESPACE_SCHEMA_LOCATION;\n-\tprivate final String XSI_SCHEMA_LOCATION;\n-\tprivate final String XSI_TYPE;\n-\n-\tAttributeManager(final ComponentProvider metaBridge, final AtomBridge<A> atomBridge)\n-\t{\n-\t\tthis.metaBridge = PreCondition.assertArgumentNotNull(metaBridge, \"metaBridge\");\n-\t\tthis.atomBridge = PreCondition.assertArgumentNotNull(atomBridge, \"atomBridge\");\n-\t\tthis.W3C_XML_SCHEMA_INSTANCE_NS_URI = XMLConstants.W3C_XML_SCHEMA_INSTANCE_NS_URI;\n-\t\tthis.XSI_NIL = \"nil\";\n-\t\tthis.XSI_NO_NAMESPACE_SCHEMA_LOCATION = \"noNamespaceSchemaLocation\";\n-\t\tthis.XSI_SCHEMA_LOCATION = \"schemaLocation\";\n-\t\tthis.XSI_TYPE = \"type\";\n-\t}\n-\n-\tprivate void attribute(final ModelPSVI elementPSVI, final ValidationItem elementItem, final QName attributeName, final int attributeIndex, final String initialValue, final VxOutputHandler<A> downstream, final SchemaExceptionHandler errors, final IdManager idm, final IdentityConstraintManager icm) throws IOException, AbortException\n-\t{\n-\t\tfinal Type elementType = elementPSVI.getType();\n-\t\tif (null == elementType)\n-\t\t{\n-\t\t\t// Short-circuit if we could not assign a type.\n-\t\t\tif (null != downstream)\n-\t\t\t{\n-\t\t\t\tdownstream.attribute(attributeName, initialValue);\n-\t\t\t}\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tif (elementType instanceof ComplexType)\n-\t\t\t{\n-\t\t\t\tfinal ComplexType complexType = (ComplexType)elementType;\n-\t\t\t\tfinal AttributeUse attributeUse = complexType.getAttributeUses().get(attributeName);\n-\t\t\t\tif (null != attributeUse)\n-\t\t\t\t{\n-\t\t\t\t\tfinal ValueConstraint valueConstraint = attributeUse.getEffectiveValueConstraint();\n-\t\t\t\t\tfinal AttributeDefinition attribute = attributeUse.getAttribute();\n-\n-\t\t\t\t\tfinal Type attributeType = attribute.getType();\n-\t\t\t\t\tif (attributeType instanceof SimpleType)\n-\t\t\t\t\t{\n-\t\t\t\t\t\tfinal SimpleType simpleType = (SimpleType)attributeType;\n-\t\t\t\t\t\tfinal List<A> actualValue = validateAttributeWrtAttributeUse(elementItem, valueConstraint, attributeName, simpleType, attributeIndex, initialValue, idm, icm, errors, atomBridge);\n-\t\t\t\t\t\tif (null != downstream)\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tdownstream.attribute(attributeName, actualValue, simpleType);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\telse\n-\t\t\t\t\t{\n-\t\t\t\t\t\tif (null != downstream)\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tdownstream.attribute(attributeName, initialValue);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\telse\n-\t\t\t\t{\n-\t\t\t\t\tfinal SchemaWildcard attributeWildcard = complexType.getAttributeWildcard();\n-\t\t\t\t\tif (null != attributeWildcard)\n-\t\t\t\t\t{\n-\t\t\t\t\t\t// If we end up here then the attribute was not recognized by {attribute uses}.\n-\t\t\t\t\t\tfinal NamespaceConstraint wildcardNs = attributeWildcard.getNamespaceConstraint();\n-\t\t\t\t\t\tif (wildcardNs == null)\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\terrors.error(new CvcUnexpectedAttributeException(elementPSVI.getName(), attributeName, elementItem.getLocation()));\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\telse\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tif (wildcardNs.allowsNamespaceName(attributeName.getNamespaceURI()))\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tfinal ProcessContentsMode processContents = attributeWildcard.getProcessContents();\n-\t\t\t\t\t\t\t\tswitch (processContents)\n-\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\tcase Skip:\n-\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t// Do nothing.\n-\t\t\t\t\t\t\t\t\t\tif (null != downstream)\n-\t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\tdownstream.attribute(attributeName, initialValue);\n-\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t\t\t\tcase Lax:\n-\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\tfinal AttributeDefinition attribute = metaBridge.getAttributeDeclaration(attributeName);\n-\t\t\t\t\t\t\t\t\t\tif (null != attribute)\n-\t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\tfinal Type attributeType = attribute.getType();\n-\t\t\t\t\t\t\t\t\t\t\tif (attributeType instanceof SimpleType)\n-\t\t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\t\tfinal SimpleType simpleType = (SimpleType)attributeType;\n-\t\t\t\t\t\t\t\t\t\t\t\tfinal ValueConstraint valueConstraint = attribute.getValueConstraint();\n-\t\t\t\t\t\t\t\t\t\t\t\tfinal List<A> actualValue = validateAttributeWrtDeclaration(elementItem, valueConstraint, attributeName, simpleType, initialValue, errors, atomBridge);\n-\n-\t\t\t\t\t\t\t\t\t\t\t\tidm.attribute(actualValue, simpleType, elementItem, errors, atomBridge);\n-\t\t\t\t\t\t\t\t\t\t\t\ticm.attribute(actualValue, simpleType, elementItem, attributeName, attributeIndex, atomBridge);\n-\n-\t\t\t\t\t\t\t\t\t\t\t\tif (null != downstream)\n-\t\t\t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\t\t\tdownstream.attribute(attributeName, actualValue, simpleType);\n-\t\t\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t\t\telse\n-\t\t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\t\tif (null != downstream)\n-\t\t\t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\t\t\tdownstream.attribute(attributeName, initialValue);\n-\t\t\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t\telse\n-\t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\t// In Lax mode it's not an error if a global attribute declaration cannot be\n-\t\t\t\t\t\t\t\t\t\t\t// resolved.\n-\t\t\t\t\t\t\t\t\t\t\tif (null != downstream)\n-\t\t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\t\tdownstream.attribute(attributeName, initialValue);\n-\t\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t\t\t\tcase Strict:\n-\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\tfinal AttributeDefinition attribute = metaBridge.getAttributeDeclaration(attributeName);\n-\t\t\t\t\t\t\t\t\t\tif (null != attribute)\n-\t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\tfinal Type attributeType = attribute.getType();\n-\t\t\t\t\t\t\t\t\t\t\tif (attributeType instanceof SimpleType)\n-\t\t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\t\tfinal SimpleType simpleType = (SimpleType)attributeType;\n-\t\t\t\t\t\t\t\t\t\t\t\tfinal ValueConstraint valueConstraint = attribute.getValueConstraint();\n-\n-\t\t\t\t\t\t\t\t\t\t\t\tfinal List<A> actualValue = validateAttributeWrtDeclaration(elementItem, valueConstraint, attributeName, simpleType, initialValue, errors, atomBridge);\n-\n-\t\t\t\t\t\t\t\t\t\t\t\tidm.attribute(actualValue, simpleType, elementItem, errors, atomBridge);\n-\t\t\t\t\t\t\t\t\t\t\t\ticm.attribute(actualValue, simpleType, elementItem, attributeName, attributeIndex, atomBridge);\n-\n-\t\t\t\t\t\t\t\t\t\t\t\tif (null != downstream)\n-\t\t\t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\t\t\tdownstream.attribute(attributeName, actualValue, simpleType);\n-\t\t\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t\t\telse\n-\t\t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\t\tif (null != downstream)\n-\t\t\t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\t\t\tdownstream.attribute(attributeName, initialValue);\n-\t\t\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t\telse\n-\t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\t// In Strict mode it's an error if a global attribute declaration cannot be\n-\t\t\t\t\t\t\t\t\t\t\t// resolved.\n-\t\t\t\t\t\t\t\t\t\t\terrors.error(new CvcMissingAttributeDeclarationException(elementPSVI.getName(), attributeName, elementItem.getLocation()));\n-\t\t\t\t\t\t\t\t\t\t\tif (null != downstream)\n-\t\t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\t\tdownstream.attribute(attributeName, initialValue);\n-\t\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t\t\t\tdefault:\n-\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\tthrow new AssertionError(processContents);\n-\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\telse\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\terrors.error(new CvcUnexpectedAttributeException(elementPSVI.getName(), attributeName, elementItem.getLocation()));\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\telse\n-\t\t\t\t\t{\n-\t\t\t\t\t\terrors.error(new CvcUnexpectedAttributeException(elementPSVI.getName(), attributeName, elementItem.getLocation()));\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\telse if (elementType instanceof SimpleType)\n-\t\t\t{\n-\t\t\t\tfinal SimpleType simpleType = (SimpleType)elementType;\n-\t\t\t\terrors.error(new CvcAttributeOnSimpleTypeException(elementPSVI.getName(), attributeName, simpleType, elementItem.getLocation()));\n-\t\t\t}\n-\t\t\telse\n-\t\t\t{\n-\t\t\t\tthrow new AssertionError(\"Are we handling all cases?\");\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Check that all expected attributes are present and generate any that are specified as defaults.\n-\t * \n-\t * @param errors\n-\t *            The exception handler for reporting a missing attribute or a datatype error.\n-\t * @param downstream\n-\t *            The handler for downstream events.\n-\t */\n-\tprivate int checkForMissingAttributes(final ModelPSVI elementPSVI, final ValidationItem elementItem, final int lastIndex, final SchemaExceptionHandler errors, final VxOutputHandler<A> downstream, final IdManager idm, final IdentityConstraintManager icm) throws IOException, AbortException\n-\t{\n-\t\tint attributeIndex = lastIndex;\n-\t\tfinal Type elementType = elementPSVI.getType();\n-\t\tif (elementType instanceof ComplexType)\n-\t\t{\n-\t\t\tfinal ComplexType complexType = (ComplexType)elementType;\n-\t\t\tfor (final AttributeUse attributeUse : complexType.getAttributeUses().values())\n-\t\t\t{\n-\t\t\t\tfinal AttributeDefinition attribute = attributeUse.getAttribute();\n-\t\t\t\tfinal QName attributeName = attribute.getName();\n-\t\t\t\tif (!m_attributes.contains(attributeName))\n-\t\t\t\t{\n-\n-\t\t\t\t\tfinal ValueConstraint valueConstraint = attributeUse.getEffectiveValueConstraint();\n-\t\t\t\t\tif (null != valueConstraint)\n-\t\t\t\t\t{\n-\t\t\t\t\t\tswitch (valueConstraint.getVariety())\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tcase Default:\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tattributeIndex++;\n-\t\t\t\t\t\t\t\t// Create attribute with the value - a nasty W3C XML Schema side effect!\n-\t\t\t\t\t\t\t\t// TODO: I think we need to re-validate here to get the actual type?\n-\t\t\t\t\t\t\t\t// TODO: This would then apply to the managers and the downstream.\n-\t\t\t\t\t\t\t\tfinal Type attributeType = attribute.getType();\n-\t\t\t\t\t\t\t\tfinal List<A> actualValue = valueConstraint.getValue(atomBridge);\n-\n-\t\t\t\t\t\t\t\tif (attributeType instanceof SimpleType)\n-\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\tfinal SimpleType simpleType = (SimpleType)attributeType;\n-\t\t\t\t\t\t\t\t\tidm.attribute(actualValue, simpleType, elementItem, errors, atomBridge);\n-\t\t\t\t\t\t\t\t\ticm.attribute(actualValue, simpleType, elementItem, attributeName, attributeIndex, atomBridge);\n-\n-\t\t\t\t\t\t\t\t\tif (null != downstream)\n-\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\tdownstream.attribute(attributeName, actualValue, simpleType);\n-\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\telse\n-\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\tif (null != downstream)\n-\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\tdownstream.attribute(attributeName, atomBridge.getC14NString(actualValue));\n-\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t\tcase Fixed:\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tif (attributeUse.isRequired())\n-\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\terrors.error(new SmMissingAttributeException(elementPSVI.getName(), attributeName, elementItem.getLocation()));\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t\tdefault:\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tthrow new AssertionError(valueConstraint.getVariety());\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\telse\n-\t\t\t\t\t{\n-\t\t\t\t\t\tif (attributeUse.isRequired())\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\terrors.error(new SmMissingAttributeException(elementPSVI.getName(), attributeName, elementItem.getLocation()));\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn attributeIndex;\n-\t}\n-\n-\tprivate void checkValueAgainstValueConstraint(final ValueConstraint valueConstraint, final QName attributeName, final List<? extends A> actualValue, final Locatable locatable, final SchemaExceptionHandler errors, final AtomBridge<A> atomBridge) throws AbortException\n-\t{\n-\t\tif (null != valueConstraint)\n-\t\t{\n-\t\t\tswitch (valueConstraint.getVariety())\n-\t\t\t{\n-\t\t\t\tcase Fixed:\n-\t\t\t\t{\n-\t\t\t\t\tfinal List<A> fixed = valueConstraint.getValue(atomBridge);\n-\n-\t\t\t\t\tif (!ValidationSupport.equalValues(fixed, actualValue))\n-\t\t\t\t\t{\n-\t\t\t\t\t\tfinal String fixedC14N = atomBridge.getC14NString(fixed);\n-\t\t\t\t\t\tfinal String actualC14N = atomBridge.getC14NString(actualValue);\n-\t\t\t\t\t\terrors.error(new CvcAttributeFixedValueOverriddenException(attributeName, fixedC14N, actualC14N, locatable.getLocation()));\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tbreak;\n-\t\t\t\tcase Default:\n-\t\t\t\t{\n-\t\t\t\t\t// No problem.\n-\t\t\t\t}\n-\t\t\t\tbreak;\n-\t\t\t\tdefault:\n-\t\t\t\t{\n-\t\t\t\t\tthrow new RuntimeException(valueConstraint.getVariety().name());\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic Boolean getLocalNil()\n-\t{\n-\t\treturn m_localNil;\n-\t}\n-\n-\tpublic Type getLocalType()\n-\t{\n-\t\treturn m_localType;\n-\t}\n-\n-\t/**\n-\t * Initialize this manager by examining those attributes in the W3C XML Schema-instance namespace.\n-\t * \n-\t * @param elementName\n-\t *            The element information item name.\n-\t * @param attributes\n-\t *            The list of attributes.\n-\t * @param errors\n-\t *            The handler for exceptions.\n-\t * @param p2n\n-\t *            A prefix resolver.\n-\t */\n-\tpublic void initialize(final QName elementName, final Locatable locatable, final LinkedList<VxMapping<QName, String>> attributes, final PrefixResolver p2n, final URI baseURI, final SchemaExceptionHandler errors, final VxSchemaDocumentLocationStrategy schemaDocumentLocationStrategy) throws IOException, AbortException\n-\t{\n-\t\treset();\n-\n-\t\tif (attributes.size() > 0) // Optimization.\n-\t\t{\n-\t\t\tfor (final VxMapping<QName, String> mapping : attributes)\n-\t\t\t{\n-\t\t\t\tfinal QName attributeName = mapping.getKey();\n-\t\t\t\tfinal String data = mapping.getValue();\n-\n-\t\t\t\tif (W3C_XML_SCHEMA_INSTANCE_NS_URI == attributeName.getNamespaceURI())\n-\t\t\t\t{\n-\t\t\t\t\tfinal String localName = attributeName.getLocalPart();\n-\t\t\t\t\tif (XSI_TYPE == localName)\n-\t\t\t\t\t{\n-\t\t\t\t\t\tfinal AttributeDefinition attribute = metaBridge.getAttributeDeclaration(attributeName);\n-\t\t\t\t\t\tfinal SimpleType attributeType = (SimpleType)attribute.getType();\n-\t\t\t\t\t\ttry\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tfinal A actualValue = attributeType.validate(data, atomBridge).get(0);\n-\t\t\t\t\t\t\tfinal QName typeName = resolveXsiType(atomBridge.getLocalNameFromQName(actualValue), atomBridge.getPrefixFromQName(actualValue), p2n);\n-\t\t\t\t\t\t\tm_localType = metaBridge.getTypeDefinition(typeName);\n-\t\t\t\t\t\t\tif (null != m_localType)\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tm_xsiAtoms.put(attributeName, new Pair<A, SimpleType>(actualValue, attributeType));\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\telse\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\terrors.error(new CvcElementUnresolvedLocalTypeException(typeName, elementName, locatable.getLocation()));\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tcatch (final DatatypeException dte)\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tfinal SimpleTypeException ste = new SimpleTypeException(data, attributeType, dte);\n-\t\t\t\t\t\t\terrors.error(new SmAttributeUseException(elementName, attributeName, locatable.getLocation(), ste));\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\telse if (XSI_NIL == localName)\n-\t\t\t\t\t{\n-\t\t\t\t\t\tfinal AttributeDefinition attribute = metaBridge.getAttributeDeclaration(attributeName);\n-\t\t\t\t\t\tfinal SimpleType attributeType = (SimpleType)attribute.getType();\n-\t\t\t\t\t\ttry\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tfinal A actualValue = attributeType.validate(data, atomBridge).get(0);\n-\t\t\t\t\t\t\tm_localNil = atomBridge.getBoolean(actualValue);\n-\t\t\t\t\t\t\tm_xsiAtoms.put(attributeName, new Pair<A, SimpleType>(actualValue, attributeType));\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tcatch (final DatatypeException dte)\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tfinal SimpleTypeException ste = new SimpleTypeException(data, attributeType, dte);\n-\t\t\t\t\t\t\terrors.error(new SmAttributeUseException(elementName, attributeName, locatable.getLocation(), ste));\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\telse if (XSI_SCHEMA_LOCATION == localName)\n-\t\t\t\t\t{\n-\t\t\t\t\t\tfinal AttributeDefinition attribute = metaBridge.getAttributeDeclaration(attributeName);\n-\t\t\t\t\t\tfinal SimpleType attributeType = (SimpleType)attribute.getType();\n-\t\t\t\t\t\ttry\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tfinal List<A> actualValue = attributeType.validate(data, atomBridge);\n-\t\t\t\t\t\t\tif (null != schemaDocumentLocationStrategy)\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tfinal Iterator<A> atoms = actualValue.iterator();\n-\t\t\t\t\t\t\t\twhile (atoms.hasNext())\n-\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\tfinal URI namespace = atomBridge.getURI(atoms.next());\n-\t\t\t\t\t\t\t\t\tif (atoms.hasNext())\n-\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\tfinal URI schemaLocation = atomBridge.getURI(atoms.next());\n-\t\t\t\t\t\t\t\t\t\ttry\n-\t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\tschemaDocumentLocationStrategy.schemaLocation(baseURI, namespace, schemaLocation);\n-\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t\tcatch (final Exception e)\n-\t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\t// Ignore\n-\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tm_xsiLists.put(attributeName, new Pair<List<? extends A>, SimpleType>(actualValue, attributeType));\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tcatch (final DatatypeException dte)\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tfinal SimpleTypeException ste = new SimpleTypeException(data, attributeType, dte);\n-\t\t\t\t\t\t\terrors.error(new SmAttributeUseException(elementName, attributeName, locatable.getLocation(), ste));\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\telse if (XSI_NO_NAMESPACE_SCHEMA_LOCATION == localName)\n-\t\t\t\t\t{\n-\t\t\t\t\t\tfinal AttributeDefinition attribute = metaBridge.getAttributeDeclaration(attributeName);\n-\t\t\t\t\t\tfinal SimpleType attributeType = (SimpleType)attribute.getType();\n-\t\t\t\t\t\ttry\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tfinal A actualValue = attributeType.validate(data, atomBridge).get(0);\n-\t\t\t\t\t\t\tif (null != schemaDocumentLocationStrategy)\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tfinal URI schemaLocation = atomBridge.getURI(actualValue);\n-\t\t\t\t\t\t\t\tschemaDocumentLocationStrategy.noNamespaceSchemaLocation(baseURI, schemaLocation);\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tm_xsiAtoms.put(attributeName, new Pair<A, SimpleType>(actualValue, attributeType));\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tcatch (final DatatypeException dte)\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tfinal SimpleTypeException ste = new SimpleTypeException(data, attributeType, dte);\n-\t\t\t\t\t\t\terrors.error(new SmAttributeUseException(elementName, attributeName, locatable.getLocation(), ste));\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\telse\n-\t\t\t\t\t{\n-\t\t\t\t\t\t// Ignore the attribute, it gets handled along with all the others\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic void reset()\n-\t{\n-\t\tm_attributes.clear();\n-\t\tm_xsiAtoms.clear();\n-\t\tm_xsiLists.clear();\n-\t\tm_localType = null;\n-\t\tm_localNil = null;\n-\t}\n-\n-\tprivate QName resolveXsiType(final String localName, final String prefix, final PrefixResolver p2n)\n-\t{\n-\t\tif (prefix.length() > 0)\n-\t\t{\n-\t\t\tfinal String namespaceURI = p2n.getNamespace(prefix);\n-\t\t\tif (null != namespaceURI)\n-\t\t\t{\n-\t\t\t\treturn new QName(namespaceURI, localName, prefix);\n-\t\t\t}\n-\t\t\telse\n-\t\t\t{\n-\t\t\t\tthrow new AssertionError(\"Unable to resolve prefix: '\" + prefix + \"'\");\n-\t\t\t}\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tfinal String namespaceURI = p2n.getNamespace(prefix);\n-\t\t\tif (null != namespaceURI)\n-\t\t\t{\n-\t\t\t\treturn new QName(namespaceURI, localName, prefix);\n-\t\t\t}\n-\t\t\telse\n-\t\t\t{\n-\t\t\t\treturn new QName(\"\", localName, prefix);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Validates the collection of attributes for the element information item, augmented using defaults, and sent\n-\t * downstream.\n-\t * \n-\t * @param elementItem\n-\t *            The element information item.\n-\t * @param attributes\n-\t *            The list of attributes.\n-\t * @param downstream\n-\t *            The handler for downstream events.\n-\t * @param errors\n-\t *            The handler for exceptions.\n-\t * @param icm\n-\t *            The identity constraint manager.\n-\t * @param p2n\n-\t *            A prefix resolver.\n-\t * \n-\t * @return The index of the last attribute.\n-\t */\n-\tpublic int attributes(final ModelPSVI elementPSVI, final ValidationItem elementItem, final List<VxMapping<QName, String>> attributes, final VxOutputHandler<A> downstream, final SchemaExceptionHandler errors, final IdManager idm, final IdentityConstraintManager icm) throws IOException, AbortException\n-\t{\n-\t\tint attributeIndex = elementItem.getElementIndex();\n-\t\tfor (final VxMapping<QName, String> mapping : attributes)\n-\t\t{\n-\t\t\tattributeIndex++;\n-\t\t\tfinal QName attributeName = mapping.getKey();\n-\t\t\tif (m_xsiAtoms.containsKey(attributeName))\n-\t\t\t{\n-\t\t\t\tif (null != downstream)\n-\t\t\t\t{\n-\t\t\t\t\tdownstream.attribute(attributeName, atomBridge.wrapAtom(m_xsiAtoms.get(attributeName).getFirst()), m_xsiAtoms.get(attributeName).getSecond());\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\telse if (m_xsiLists.containsKey(attributeName))\n-\t\t\t{\n-\t\t\t\tif (null != downstream)\n-\t\t\t\t{\n-\t\t\t\t\tdownstream.attribute(attributeName, m_xsiLists.get(attributeName).getFirst(), m_xsiLists.get(attributeName).getSecond());\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\telse\n-\t\t\t{\n-\t\t\t\t// Make a note that we have seen this attribute.\n-\t\t\t\tm_attributes.add(attributeName);\n-\t\t\t\tattribute(elementPSVI, elementItem, attributeName, attributeIndex, mapping.getValue(), downstream, errors, idm, icm);\n-\t\t\t}\n-\t\t}\n-\t\treturn checkForMissingAttributes(elementPSVI, elementItem, attributeIndex, errors, downstream, idm, icm);\n-\t}\n-\n-\tprivate List<A> validateAttributeWrtAttributeUse(final ValidationItem elementItem, final ValueConstraint valueConstraint, final QName attributeName, final SimpleType attributeType, final int attributeIndex, final String initialValue, final IdManager idm, final IdentityConstraintManager icm, final SchemaExceptionHandler errors, final AtomBridge<A> atomBridge) throws AbortException\n-\t{\n-\t\tfinal List<A> actualValue = validateAttributeWrtDeclaration(elementItem, valueConstraint, attributeName, attributeType, initialValue, errors, atomBridge);\n-\n-\t\tidm.attribute(actualValue, attributeType, elementItem, errors, atomBridge);\n-\t\ticm.attribute(actualValue, attributeType, elementItem, attributeName, attributeIndex, atomBridge);\n-\n-\t\tcheckValueAgainstValueConstraint(valueConstraint, attributeName, actualValue, elementItem, errors, atomBridge);\n-\n-\t\treturn actualValue;\n-\t}\n-\n-\tprivate List<A> validateAttributeWrtDeclaration(final Locatable location, final ValueConstraint valueConstraint, final QName attributeName, final SimpleType attributeType, final String initialValue, final SchemaExceptionHandler errors, final AtomBridge<A> atomBridge) throws AbortException\n-\t{\n-\t\tfinal List<A> actualValue = validateWrtType(attributeName, attributeType, initialValue, location, errors, atomBridge);\n-\n-\t\tcheckValueAgainstValueConstraint(valueConstraint, attributeName, actualValue, location, errors, atomBridge);\n-\n-\t\treturn actualValue;\n-\t}\n-\n-\tprivate List<A> validateWrtType(final QName attributeName, final SimpleType attributeType, final String initialValue, final Locatable locatable, final SchemaExceptionHandler errors, final AtomBridge<A> atomBridge) throws AbortException\n-\t{\n-\t\tPreCondition.assertArgumentNotNull(attributeName, \"attributeName\");\n-\t\tPreCondition.assertArgumentNotNull(attributeType);\n-\t\ttry\n-\t\t{\n-\t\t\treturn attributeType.validate(initialValue, atomBridge);\n-\t\t}\n-\t\tcatch (final DatatypeException dte)\n-\t\t{\n-\t\t\tfinal SimpleTypeException ste = new SimpleTypeException(initialValue, attributeType, dte);\n-\t\t\terrors.error(new CvcAttributeNormalizedValueException(attributeName, initialValue, locatable.getLocation(), ste));\n-\t\t\treturn atomBridge.wrapAtom(atomBridge.createUntypedAtomic(initialValue));\n-\t\t}\n-\t}\n+final class AttributeManager<A> {\n+    private final AtomBridge<A> atomBridge;\n+\n+    // Keep track of the attributes that we have seen in order to report missing attributes.\n+    private final Set<QName> m_attributes = new HashSet<QName>();\n+\n+    private Boolean m_localNil = null;\n+\n+    private Type m_localType = null;\n+\n+    private final HashMap<QName, Pair<A, SimpleType>> m_xsiAtoms =\n+        new HashMap<QName, Pair<A, SimpleType>>();\n+\n+    private final HashMap<QName, Pair<List<? extends A>, SimpleType>> m_xsiLists =\n+        new HashMap<QName, Pair<List<? extends A>, SimpleType>>();\n+\n+    private final ComponentProvider metaBridge;\n+\n+    private final String W3C_XML_SCHEMA_INSTANCE_NS_URI;\n+\n+    private final String XSI_NIL;\n+\n+    private final String XSI_NO_NAMESPACE_SCHEMA_LOCATION;\n+\n+    private final String XSI_SCHEMA_LOCATION;\n+\n+    private final String XSI_TYPE;\n+\n+    AttributeManager(final ComponentProvider metaBridge, final AtomBridge<A> atomBridge) {\n+        this.metaBridge = PreCondition.assertArgumentNotNull(metaBridge, \"metaBridge\");\n+        this.atomBridge = PreCondition.assertArgumentNotNull(atomBridge, \"atomBridge\");\n+        this.W3C_XML_SCHEMA_INSTANCE_NS_URI = XMLConstants.W3C_XML_SCHEMA_INSTANCE_NS_URI;\n+        this.XSI_NIL = \"nil\";\n+        this.XSI_NO_NAMESPACE_SCHEMA_LOCATION = \"noNamespaceSchemaLocation\";\n+        this.XSI_SCHEMA_LOCATION = \"schemaLocation\";\n+        this.XSI_TYPE = \"type\";\n+    }\n+\n+    private void attribute(final ModelPSVI elementPSVI, final ValidationItem elementItem,\n+                           final QName attributeName, final int attributeIndex,\n+                           final String initialValue, final VxOutputHandler<A> downstream,\n+                           final SchemaExceptionHandler errors, final IdManager idm,\n+                           final IdentityConstraintManager icm) throws IOException, AbortException {\n+        final Type elementType = elementPSVI.getType();\n+        if (null == elementType) {\n+            // Short-circuit if we could not assign a type.\n+            if (null != downstream) {\n+                downstream.attribute(attributeName, initialValue);\n+            }\n+        } else {\n+            if (elementType instanceof ComplexType) {\n+                final ComplexType complexType = (ComplexType) elementType;\n+                final AttributeUse attributeUse = complexType.getAttributeUses().get(attributeName);\n+                if (null != attributeUse) {\n+                    final ValueConstraint valueConstraint =\n+                        attributeUse.getEffectiveValueConstraint();\n+                    final AttributeDefinition attribute = attributeUse.getAttribute();\n+\n+                    final Type attributeType = attribute.getType();\n+                    if (attributeType instanceof SimpleType) {\n+                        final SimpleType simpleType = (SimpleType) attributeType;\n+                        final List<A> actualValue =\n+                            validateAttributeWrtAttributeUse(elementItem, valueConstraint,\n+                                attributeName, simpleType, attributeIndex, initialValue, idm, icm,\n+                                errors, atomBridge);\n+                        if (null != downstream) {\n+                            downstream.attribute(attributeName, actualValue, simpleType);\n+                        }\n+                    } else {\n+                        if (null != downstream) {\n+                            downstream.attribute(attributeName, initialValue);\n+                        }\n+                    }\n+                } else {\n+                    final SchemaWildcard attributeWildcard = complexType.getAttributeWildcard();\n+                    if (null != attributeWildcard) {\n+                        // If we end up here then the attribute was not recognized by {attribute uses}.\n+                        final NamespaceConstraint wildcardNs =\n+                            attributeWildcard.getNamespaceConstraint();\n+                        if (wildcardNs == null) {\n+                            errors.error(new CvcUnexpectedAttributeException(elementPSVI.getName(),\n+                                attributeName, elementItem.getLocation()));\n+                        } else {\n+                            if (wildcardNs.allowsNamespaceName(attributeName.getNamespaceURI())) {\n+                                final ProcessContentsMode processContents =\n+                                    attributeWildcard.getProcessContents();\n+                                switch (processContents) {\n+                                    case Skip: {\n+                                        // Do nothing.\n+                                        if (null != downstream) {\n+                                            downstream.attribute(attributeName, initialValue);\n+                                        }\n+                                    }\n+                                    break;\n+                                    case Lax: {\n+                                        final AttributeDefinition attribute =\n+                                            metaBridge.getAttributeDeclaration(attributeName);\n+                                        if (null != attribute) {\n+                                            final Type attributeType = attribute.getType();\n+                                            if (attributeType instanceof SimpleType) {\n+                                                final SimpleType simpleType =\n+                                                    (SimpleType) attributeType;\n+                                                final ValueConstraint valueConstraint =\n+                                                    attribute.getValueConstraint();\n+                                                final List<A> actualValue =\n+                                                    validateAttributeWrtDeclaration(elementItem,\n+                                                        valueConstraint, attributeName, simpleType,\n+                                                        initialValue, errors, atomBridge);\n+\n+                                                idm.attribute(actualValue, simpleType, elementItem,\n+                                                    errors, atomBridge);\n+                                                icm.attribute(actualValue, simpleType, elementItem,\n+                                                    attributeName, attributeIndex, atomBridge);\n+\n+                                                if (null != downstream) {\n+                                                    downstream.attribute(attributeName, actualValue,\n+                                                        simpleType);\n+                                                }\n+                                            } else {\n+                                                if (null != downstream) {\n+                                                    downstream\n+                                                        .attribute(attributeName, initialValue);\n+                                                }\n+                                            }\n+                                        } else {\n+                                            // In Lax mode it's not an error if a global attribute declaration cannot be\n+                                            // resolved.\n+                                            if (null != downstream) {\n+                                                downstream.attribute(attributeName, initialValue);\n+                                            }\n+                                        }\n+                                    }\n+                                    break;\n+                                    case Strict: {\n+                                        final AttributeDefinition attribute =\n+                                            metaBridge.getAttributeDeclaration(attributeName);\n+                                        if (null != attribute) {\n+                                            final Type attributeType = attribute.getType();\n+                                            if (attributeType instanceof SimpleType) {\n+                                                final SimpleType simpleType =\n+                                                    (SimpleType) attributeType;\n+                                                final ValueConstraint valueConstraint =\n+                                                    attribute.getValueConstraint();\n+\n+                                                final List<A> actualValue =\n+                                                    validateAttributeWrtDeclaration(elementItem,\n+                                                        valueConstraint, attributeName, simpleType,\n+                                                        initialValue, errors, atomBridge);\n+\n+                                                idm.attribute(actualValue, simpleType, elementItem,\n+                                                    errors, atomBridge);\n+                                                icm.attribute(actualValue, simpleType, elementItem,\n+                                                    attributeName, attributeIndex, atomBridge);\n+\n+                                                if (null != downstream) {\n+                                                    downstream.attribute(attributeName, actualValue,\n+                                                        simpleType);\n+                                                }\n+                                            } else {\n+                                                if (null != downstream) {\n+                                                    downstream\n+                                                        .attribute(attributeName, initialValue);\n+                                                }\n+                                            }\n+                                        } else {\n+                                            // In Strict mode it's an error if a global attribute declaration cannot be\n+                                            // resolved.\n+                                            errors.error(\n+                                                new CvcMissingAttributeDeclarationException(\n+                                                    elementPSVI.getName(), attributeName,\n+                                                    elementItem.getLocation()));\n+                                            if (null != downstream) {\n+                                                downstream.attribute(attributeName, initialValue);\n+                                            }\n+                                        }\n+                                    }\n+                                    break;\n+                                    default: {\n+                                        throw new AssertionError(processContents);\n+                                    }\n+                                }\n+                            } else {\n+                                errors.error(\n+                                    new CvcUnexpectedAttributeException(elementPSVI.getName(),\n+                                        attributeName, elementItem.getLocation()));\n+                            }\n+                        }\n+                    } else {\n+                        errors.error(new CvcUnexpectedAttributeException(elementPSVI.getName(),\n+                            attributeName, elementItem.getLocation()));\n+                    }\n+                }\n+            } else if (elementType instanceof SimpleType) {\n+                final SimpleType simpleType = (SimpleType) elementType;\n+                errors.error(\n+                    new CvcAttributeOnSimpleTypeException(elementPSVI.getName(), attributeName,\n+                        simpleType, elementItem.getLocation()));\n+            } else {\n+                throw new AssertionError(\"Are we handling all cases?\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Check that all expected attributes are present and generate any that are specified as defaults.\n+     *\n+     * @param errors\n+     *            The exception handler for reporting a missing attribute or a datatype error.\n+     * @param downstream\n+     *            The handler for downstream events.\n+     */\n+    private int checkForMissingAttributes(final ModelPSVI elementPSVI,\n+                                          final ValidationItem elementItem, final int lastIndex,\n+                                          final SchemaExceptionHandler errors,\n+                                          final VxOutputHandler<A> downstream, final IdManager idm,\n+                                          final IdentityConstraintManager icm)\n+        throws IOException, AbortException {\n+        int attributeIndex = lastIndex;\n+        final Type elementType = elementPSVI.getType();\n+        if (elementType instanceof ComplexType) {\n+            final ComplexType complexType = (ComplexType) elementType;\n+            for (final AttributeUse attributeUse : complexType.getAttributeUses().values()) {\n+                final AttributeDefinition attribute = attributeUse.getAttribute();\n+                final QName attributeName = attribute.getName();\n+                if (!m_attributes.contains(attributeName)) {\n+\n+                    final ValueConstraint valueConstraint =\n+                        attributeUse.getEffectiveValueConstraint();\n+                    if (null != valueConstraint) {\n+                        switch (valueConstraint.getVariety()) {\n+                            case Default: {\n+                                attributeIndex++;\n+                                // Create attribute with the value - a nasty W3C XML Schema side effect!\n+                                // TODO: I think we need to re-validate here to get the actual type?\n+                                // TODO: This would then apply to the managers and the downstream.\n+                                final Type attributeType = attribute.getType();\n+                                final List<A> actualValue = valueConstraint.getValue(atomBridge);\n+\n+                                if (attributeType instanceof SimpleType) {\n+                                    final SimpleType simpleType = (SimpleType) attributeType;\n+                                    idm.attribute(actualValue, simpleType, elementItem, errors,\n+                                        atomBridge);\n+                                    icm.attribute(actualValue, simpleType, elementItem,\n+                                        attributeName, attributeIndex, atomBridge);\n+\n+                                    if (null != downstream) {\n+                                        downstream\n+                                            .attribute(attributeName, actualValue, simpleType);\n+                                    }\n+                                } else {\n+                                    if (null != downstream) {\n+                                        downstream.attribute(attributeName,\n+                                            atomBridge.getC14NString(actualValue));\n+                                    }\n+                                }\n+                            }\n+                            break;\n+                            case Fixed: {\n+                                if (attributeUse.isRequired()) {\n+                                    errors.error(\n+                                        new SmMissingAttributeException(elementPSVI.getName(),\n+                                            attributeName, elementItem.getLocation()));\n+                                }\n+                            }\n+                            break;\n+                            default: {\n+                                throw new AssertionError(valueConstraint.getVariety());\n+                            }\n+                        }\n+                    } else {\n+                        if (attributeUse.isRequired()) {\n+                            errors.error(new SmMissingAttributeException(elementPSVI.getName(),\n+                                attributeName, elementItem.getLocation()));\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        return attributeIndex;\n+    }\n+\n+    private void checkValueAgainstValueConstraint(final ValueConstraint valueConstraint,\n+                                                  final QName attributeName,\n+                                                  final List<? extends A> actualValue,\n+                                                  final Locatable locatable,\n+                                                  final SchemaExceptionHandler errors,\n+                                                  final AtomBridge<A> atomBridge)\n+        throws AbortException {\n+        if (null != valueConstraint) {\n+            switch (valueConstraint.getVariety()) {\n+                case Fixed: {\n+                    final List<A> fixed = valueConstraint.getValue(atomBridge);\n+\n+                    if (!ValidationSupport.equalValues(fixed, actualValue)) {\n+                        final String fixedC14N = atomBridge.getC14NString(fixed);\n+                        final String actualC14N = atomBridge.getC14NString(actualValue);\n+                        errors.error(\n+                            new CvcAttributeFixedValueOverriddenException(attributeName, fixedC14N,\n+                                actualC14N, locatable.getLocation()));\n+                    }\n+                }\n+                break;\n+                case Default: {\n+                    // No problem.\n+                }\n+                break;\n+                default: {\n+                    throw new RuntimeException(valueConstraint.getVariety().name());\n+                }\n+            }\n+        }\n+    }\n+\n+    public Boolean getLocalNil() {\n+        return m_localNil;\n+    }\n+\n+    public Type getLocalType() {\n+        return m_localType;\n+    }\n+\n+    /**\n+     * Initialize this manager by examining those attributes in the W3C XML Schema-instance namespace.\n+     *\n+     * @param elementName\n+     *            The element information item name.\n+     * @param attributes\n+     *            The list of attributes.\n+     * @param errors\n+     *            The handler for exceptions.\n+     * @param p2n\n+     *            A prefix resolver.\n+     */\n+    public void initialize(final QName elementName, final Locatable locatable,\n+                           final LinkedList<VxMapping<QName, String>> attributes,\n+                           final PrefixResolver p2n, final URI baseURI,\n+                           final SchemaExceptionHandler errors,\n+                           final VxSchemaDocumentLocationStrategy schemaDocumentLocationStrategy)\n+        throws IOException, AbortException {\n+        reset();\n+\n+        if (attributes.size() > 0) // Optimization.\n+        {\n+            for (final VxMapping<QName, String> mapping : attributes) {\n+                final QName attributeName = mapping.getKey();\n+                final String data = mapping.getValue();\n+\n+                if (W3C_XML_SCHEMA_INSTANCE_NS_URI == attributeName.getNamespaceURI()) {\n+                    final String localName = attributeName.getLocalPart();\n+                    if (XSI_TYPE == localName) {\n+                        final AttributeDefinition attribute =\n+                            metaBridge.getAttributeDeclaration(attributeName);\n+                        final SimpleType attributeType = (SimpleType) attribute.getType();\n+                        try {\n+                            final A actualValue = attributeType.validate(data, atomBridge).get(0);\n+                            final QName typeName =\n+                                resolveXsiType(atomBridge.getLocalNameFromQName(actualValue),\n+                                    atomBridge.getPrefixFromQName(actualValue), p2n);\n+                            m_localType = metaBridge.getTypeDefinition(typeName);\n+                            if (null != m_localType) {\n+                                m_xsiAtoms.put(attributeName,\n+                                    new Pair<A, SimpleType>(actualValue, attributeType));\n+                            } else {\n+                                errors.error(new CvcElementUnresolvedLocalTypeException(typeName,\n+                                    elementName, locatable.getLocation()));\n+                            }\n+                        } catch (final DatatypeException dte) {\n+                            final SimpleTypeException ste =\n+                                new SimpleTypeException(data, attributeType, dte);\n+                            errors.error(new SmAttributeUseException(elementName, attributeName,\n+                                locatable.getLocation(), ste));\n+                        }\n+                    } else if (XSI_NIL == localName) {\n+                        final AttributeDefinition attribute =\n+                            metaBridge.getAttributeDeclaration(attributeName);\n+                        final SimpleType attributeType = (SimpleType) attribute.getType();\n+                        try {\n+                            final A actualValue = attributeType.validate(data, atomBridge).get(0);\n+                            m_localNil = atomBridge.getBoolean(actualValue);\n+                            m_xsiAtoms.put(attributeName,\n+                                new Pair<A, SimpleType>(actualValue, attributeType));\n+                        } catch (final DatatypeException dte) {\n+                            final SimpleTypeException ste =\n+                                new SimpleTypeException(data, attributeType, dte);\n+                            errors.error(new SmAttributeUseException(elementName, attributeName,\n+                                locatable.getLocation(), ste));\n+                        }\n+                    } else if (XSI_SCHEMA_LOCATION == localName) {\n+                        final AttributeDefinition attribute =\n+                            metaBridge.getAttributeDeclaration(attributeName);\n+                        final SimpleType attributeType = (SimpleType) attribute.getType();\n+                        try {\n+                            final List<A> actualValue = attributeType.validate(data, atomBridge);\n+                            if (null != schemaDocumentLocationStrategy) {\n+                                final Iterator<A> atoms = actualValue.iterator();\n+                                while (atoms.hasNext()) {\n+                                    final URI namespace = atomBridge.getURI(atoms.next());\n+                                    if (atoms.hasNext()) {\n+                                        final URI schemaLocation = atomBridge.getURI(atoms.next());\n+                                        try {\n+                                            schemaDocumentLocationStrategy\n+                                                .schemaLocation(baseURI, namespace, schemaLocation);\n+                                        } catch (final Exception e) {\n+                                            // Ignore\n+                                        }\n+                                    }\n+                                }\n+                            }\n+                            m_xsiLists.put(attributeName,\n+                                new Pair<List<? extends A>, SimpleType>(actualValue,\n+                                    attributeType));\n+                        } catch (final DatatypeException dte) {\n+                            final SimpleTypeException ste =\n+                                new SimpleTypeException(data, attributeType, dte);\n+                            errors.error(new SmAttributeUseException(elementName, attributeName,\n+                                locatable.getLocation(), ste));\n+                        }\n+                    } else if (XSI_NO_NAMESPACE_SCHEMA_LOCATION == localName) {\n+                        final AttributeDefinition attribute =\n+                            metaBridge.getAttributeDeclaration(attributeName);\n+                        final SimpleType attributeType = (SimpleType) attribute.getType();\n+                        try {\n+                            final A actualValue = attributeType.validate(data, atomBridge).get(0);\n+                            if (null != schemaDocumentLocationStrategy) {\n+                                final URI schemaLocation = atomBridge.getURI(actualValue);\n+                                schemaDocumentLocationStrategy\n+                                    .noNamespaceSchemaLocation(baseURI, schemaLocation);\n+                            }\n+                            m_xsiAtoms.put(attributeName,\n+                                new Pair<A, SimpleType>(actualValue, attributeType));\n+                        } catch (final DatatypeException dte) {\n+                            final SimpleTypeException ste =\n+                                new SimpleTypeException(data, attributeType, dte);\n+                            errors.error(new SmAttributeUseException(elementName, attributeName,\n+                                locatable.getLocation(), ste));\n+                        }\n+                    } else {\n+                        // Ignore the attribute, it gets handled along with all the others\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    public void reset() {\n+        m_attributes.clear();\n+        m_xsiAtoms.clear();\n+        m_xsiLists.clear();\n+        m_localType = null;\n+        m_localNil = null;\n+    }\n+\n+    private QName resolveXsiType(final String localName, final String prefix,\n+                                 final PrefixResolver p2n) {\n+        if (prefix.length() > 0) {\n+            final String namespaceURI = p2n.getNamespace(prefix);\n+            if (null != namespaceURI) {\n+                return new QName(namespaceURI, localName, prefix);\n+            } else {\n+                throw new AssertionError(\"Unable to resolve prefix: '\" + prefix + \"'\");\n+            }\n+        } else {\n+            final String namespaceURI = p2n.getNamespace(prefix);\n+            if (null != namespaceURI) {\n+                return new QName(namespaceURI, localName, prefix);\n+            } else {\n+                return new QName(\"\", localName, prefix);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Validates the collection of attributes for the element information item, augmented using defaults, and sent\n+     * downstream.\n+     *\n+     * @param elementItem\n+     *            The element information item.\n+     * @param attributes\n+     *            The list of attributes.\n+     * @param downstream\n+     *            The handler for downstream events.\n+     * @param errors\n+     *            The handler for exceptions.\n+     * @param icm\n+     *            The identity constraint manager.\n+     * @param p2n\n+     *            A prefix resolver.\n+     *\n+     * @return The index of the last attribute.\n+     */\n+    public int attributes(final ModelPSVI elementPSVI, final ValidationItem elementItem,\n+                          final List<VxMapping<QName, String>> attributes,\n+                          final VxOutputHandler<A> downstream, final SchemaExceptionHandler errors,\n+                          final IdManager idm, final IdentityConstraintManager icm)\n+        throws IOException, AbortException {\n+        int attributeIndex = elementItem.getElementIndex();\n+        for (final VxMapping<QName, String> mapping : attributes) {\n+            attributeIndex++;\n+            final QName attributeName = mapping.getKey();\n+            if (m_xsiAtoms.containsKey(attributeName)) {\n+                if (null != downstream) {\n+                    downstream.attribute(attributeName,\n+                        atomBridge.wrapAtom(m_xsiAtoms.get(attributeName).getFirst()),\n+                        m_xsiAtoms.get(attributeName).getSecond());\n+                }\n+            } else if (m_xsiLists.containsKey(attributeName)) {\n+                if (null != downstream) {\n+                    downstream.attribute(attributeName, m_xsiLists.get(attributeName).getFirst(),\n+                        m_xsiLists.get(attributeName).getSecond());\n+                }\n+            } else {\n+                // Make a note that we have seen this attribute.\n+                m_attributes.add(attributeName);\n+                attribute(elementPSVI, elementItem, attributeName, attributeIndex,\n+                    mapping.getValue(), downstream, errors, idm, icm);\n+            }\n+        }\n+        return checkForMissingAttributes(elementPSVI, elementItem, attributeIndex, errors,\n+            downstream, idm, icm);\n+    }\n+\n+    private List<A> validateAttributeWrtAttributeUse(final ValidationItem elementItem,\n+                                                     final ValueConstraint valueConstraint,\n+                                                     final QName attributeName,\n+                                                     final SimpleType attributeType,\n+                                                     final int attributeIndex,\n+                                                     final String initialValue, final IdManager idm,\n+                                                     final IdentityConstraintManager icm,\n+                                                     final SchemaExceptionHandler errors,\n+                                                     final AtomBridge<A> atomBridge)\n+        throws AbortException {\n+        final List<A> actualValue =\n+            validateAttributeWrtDeclaration(elementItem, valueConstraint, attributeName,\n+                attributeType, initialValue, errors, atomBridge);\n+\n+        idm.attribute(actualValue, attributeType, elementItem, errors, atomBridge);\n+        icm.attribute(actualValue, attributeType, elementItem, attributeName, attributeIndex,\n+            atomBridge);\n+\n+        checkValueAgainstValueConstraint(valueConstraint, attributeName, actualValue, elementItem,\n+            errors, atomBridge);\n+\n+        return actualValue;\n+    }\n+\n+    private List<A> validateAttributeWrtDeclaration(final Locatable location,\n+                                                    final ValueConstraint valueConstraint,\n+                                                    final QName attributeName,\n+                                                    final SimpleType attributeType,\n+                                                    final String initialValue,\n+                                                    final SchemaExceptionHandler errors,\n+                                                    final AtomBridge<A> atomBridge)\n+        throws AbortException {\n+        final List<A> actualValue =\n+            validateWrtType(attributeName, attributeType, initialValue, location, errors,\n+                atomBridge);\n+\n+        checkValueAgainstValueConstraint(valueConstraint, attributeName, actualValue, location,\n+            errors, atomBridge);\n+\n+        return actualValue;\n+    }\n+\n+    private List<A> validateWrtType(final QName attributeName, final SimpleType attributeType,\n+                                    final String initialValue, final Locatable locatable,\n+                                    final SchemaExceptionHandler errors,\n+                                    final AtomBridge<A> atomBridge) throws AbortException {\n+        PreCondition.assertArgumentNotNull(attributeName, \"attributeName\");\n+        PreCondition.assertArgumentNotNull(attributeType);\n+        try {\n+            return attributeType.validate(initialValue, atomBridge);\n+        } catch (final DatatypeException dte) {\n+            final SimpleTypeException ste =\n+                new SimpleTypeException(initialValue, attributeType, dte);\n+            errors.error(new CvcAttributeNormalizedValueException(attributeName, initialValue,\n+                locatable.getLocation(), ste));\n+            return atomBridge.wrapAtom(atomBridge.createUntypedAtomic(initialValue));\n+        }\n+    }\n }\n",
            "diff_size": 586
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/249/AttributeManager.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/codebuff/249/AttributeManager.java\nindex bcf23250b47..fe8d82fc230 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/249/AttributeManager.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/codebuff/249/AttributeManager.java\n@@ -23,10 +23,8 @@ import java.util.Iterator;\n import java.util.LinkedList;\n import java.util.List;\n import java.util.Set;\n-\n import javax.xml.XMLConstants;\n import javax.xml.namespace.QName;\n-\n import org.genxdm.exceptions.PreCondition;\n import org.genxdm.names.PrefixResolver;\n import org.genxdm.processor.w3c.xs.exception.cvc.CvcAttributeFixedValueOverriddenException;\n@@ -60,585 +58,594 @@ import org.genxdm.xs.types.Type;\n /**\n  * Performs activities related to attribute validation.\n  */\n+\n final class AttributeManager<A>\n {\n-\tprivate final AtomBridge<A> atomBridge;\n-\t// Keep track of the attributes that we have seen in order to report missing attributes.\n-\tprivate final Set<QName> m_attributes = new HashSet<QName>();\n-\tprivate Boolean m_localNil = null;\n-\tprivate Type m_localType = null;\n-\tprivate final HashMap<QName, Pair<A, SimpleType>> m_xsiAtoms = new HashMap<QName, Pair<A, SimpleType>>();\n-\tprivate final HashMap<QName, Pair<List<? extends A>, SimpleType>> m_xsiLists = new HashMap<QName, Pair<List<? extends A>, SimpleType>>();\n-\tprivate final ComponentProvider metaBridge;\n-\tprivate final String W3C_XML_SCHEMA_INSTANCE_NS_URI;\n-\tprivate final String XSI_NIL;\n-\tprivate final String XSI_NO_NAMESPACE_SCHEMA_LOCATION;\n-\tprivate final String XSI_SCHEMA_LOCATION;\n-\tprivate final String XSI_TYPE;\n-\n-\tAttributeManager(final ComponentProvider metaBridge, final AtomBridge<A> atomBridge)\n-\t{\n-\t\tthis.metaBridge = PreCondition.assertArgumentNotNull(metaBridge, \"metaBridge\");\n-\t\tthis.atomBridge = PreCondition.assertArgumentNotNull(atomBridge, \"atomBridge\");\n-\t\tthis.W3C_XML_SCHEMA_INSTANCE_NS_URI = XMLConstants.W3C_XML_SCHEMA_INSTANCE_NS_URI;\n-\t\tthis.XSI_NIL = \"nil\";\n-\t\tthis.XSI_NO_NAMESPACE_SCHEMA_LOCATION = \"noNamespaceSchemaLocation\";\n-\t\tthis.XSI_SCHEMA_LOCATION = \"schemaLocation\";\n-\t\tthis.XSI_TYPE = \"type\";\n-\t}\n-\n-\tprivate void attribute(final ModelPSVI elementPSVI, final ValidationItem elementItem, final QName attributeName, final int attributeIndex, final String initialValue, final VxOutputHandler<A> downstream, final SchemaExceptionHandler errors, final IdManager idm, final IdentityConstraintManager icm) throws IOException, AbortException\n-\t{\n-\t\tfinal Type elementType = elementPSVI.getType();\n-\t\tif (null == elementType)\n-\t\t{\n-\t\t\t// Short-circuit if we could not assign a type.\n-\t\t\tif (null != downstream)\n-\t\t\t{\n-\t\t\t\tdownstream.attribute(attributeName, initialValue);\n-\t\t\t}\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tif (elementType instanceof ComplexType)\n-\t\t\t{\n-\t\t\t\tfinal ComplexType complexType = (ComplexType)elementType;\n-\t\t\t\tfinal AttributeUse attributeUse = complexType.getAttributeUses().get(attributeName);\n-\t\t\t\tif (null != attributeUse)\n-\t\t\t\t{\n-\t\t\t\t\tfinal ValueConstraint valueConstraint = attributeUse.getEffectiveValueConstraint();\n-\t\t\t\t\tfinal AttributeDefinition attribute = attributeUse.getAttribute();\n-\n-\t\t\t\t\tfinal Type attributeType = attribute.getType();\n-\t\t\t\t\tif (attributeType instanceof SimpleType)\n-\t\t\t\t\t{\n-\t\t\t\t\t\tfinal SimpleType simpleType = (SimpleType)attributeType;\n-\t\t\t\t\t\tfinal List<A> actualValue = validateAttributeWrtAttributeUse(elementItem, valueConstraint, attributeName, simpleType, attributeIndex, initialValue, idm, icm, errors, atomBridge);\n-\t\t\t\t\t\tif (null != downstream)\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tdownstream.attribute(attributeName, actualValue, simpleType);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\telse\n-\t\t\t\t\t{\n-\t\t\t\t\t\tif (null != downstream)\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tdownstream.attribute(attributeName, initialValue);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\telse\n-\t\t\t\t{\n-\t\t\t\t\tfinal SchemaWildcard attributeWildcard = complexType.getAttributeWildcard();\n-\t\t\t\t\tif (null != attributeWildcard)\n-\t\t\t\t\t{\n-\t\t\t\t\t\t// If we end up here then the attribute was not recognized by {attribute uses}.\n-\t\t\t\t\t\tfinal NamespaceConstraint wildcardNs = attributeWildcard.getNamespaceConstraint();\n-\t\t\t\t\t\tif (wildcardNs == null)\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\terrors.error(new CvcUnexpectedAttributeException(elementPSVI.getName(), attributeName, elementItem.getLocation()));\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\telse\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tif (wildcardNs.allowsNamespaceName(attributeName.getNamespaceURI()))\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tfinal ProcessContentsMode processContents = attributeWildcard.getProcessContents();\n-\t\t\t\t\t\t\t\tswitch (processContents)\n-\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\tcase Skip:\n-\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t// Do nothing.\n-\t\t\t\t\t\t\t\t\t\tif (null != downstream)\n-\t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\tdownstream.attribute(attributeName, initialValue);\n-\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t\t\t\tcase Lax:\n-\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\tfinal AttributeDefinition attribute = metaBridge.getAttributeDeclaration(attributeName);\n-\t\t\t\t\t\t\t\t\t\tif (null != attribute)\n-\t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\tfinal Type attributeType = attribute.getType();\n-\t\t\t\t\t\t\t\t\t\t\tif (attributeType instanceof SimpleType)\n-\t\t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\t\tfinal SimpleType simpleType = (SimpleType)attributeType;\n-\t\t\t\t\t\t\t\t\t\t\t\tfinal ValueConstraint valueConstraint = attribute.getValueConstraint();\n-\t\t\t\t\t\t\t\t\t\t\t\tfinal List<A> actualValue = validateAttributeWrtDeclaration(elementItem, valueConstraint, attributeName, simpleType, initialValue, errors, atomBridge);\n-\n-\t\t\t\t\t\t\t\t\t\t\t\tidm.attribute(actualValue, simpleType, elementItem, errors, atomBridge);\n-\t\t\t\t\t\t\t\t\t\t\t\ticm.attribute(actualValue, simpleType, elementItem, attributeName, attributeIndex, atomBridge);\n-\n-\t\t\t\t\t\t\t\t\t\t\t\tif (null != downstream)\n-\t\t\t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\t\t\tdownstream.attribute(attributeName, actualValue, simpleType);\n-\t\t\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t\t\telse\n-\t\t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\t\tif (null != downstream)\n-\t\t\t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\t\t\tdownstream.attribute(attributeName, initialValue);\n-\t\t\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t\telse\n-\t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\t// In Lax mode it's not an error if a global attribute declaration cannot be\n-\t\t\t\t\t\t\t\t\t\t\t// resolved.\n-\t\t\t\t\t\t\t\t\t\t\tif (null != downstream)\n-\t\t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\t\tdownstream.attribute(attributeName, initialValue);\n-\t\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t\t\t\tcase Strict:\n-\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\tfinal AttributeDefinition attribute = metaBridge.getAttributeDeclaration(attributeName);\n-\t\t\t\t\t\t\t\t\t\tif (null != attribute)\n-\t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\tfinal Type attributeType = attribute.getType();\n-\t\t\t\t\t\t\t\t\t\t\tif (attributeType instanceof SimpleType)\n-\t\t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\t\tfinal SimpleType simpleType = (SimpleType)attributeType;\n-\t\t\t\t\t\t\t\t\t\t\t\tfinal ValueConstraint valueConstraint = attribute.getValueConstraint();\n-\n-\t\t\t\t\t\t\t\t\t\t\t\tfinal List<A> actualValue = validateAttributeWrtDeclaration(elementItem, valueConstraint, attributeName, simpleType, initialValue, errors, atomBridge);\n-\n-\t\t\t\t\t\t\t\t\t\t\t\tidm.attribute(actualValue, simpleType, elementItem, errors, atomBridge);\n-\t\t\t\t\t\t\t\t\t\t\t\ticm.attribute(actualValue, simpleType, elementItem, attributeName, attributeIndex, atomBridge);\n-\n-\t\t\t\t\t\t\t\t\t\t\t\tif (null != downstream)\n-\t\t\t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\t\t\tdownstream.attribute(attributeName, actualValue, simpleType);\n-\t\t\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t\t\telse\n-\t\t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\t\tif (null != downstream)\n-\t\t\t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\t\t\tdownstream.attribute(attributeName, initialValue);\n-\t\t\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t\telse\n-\t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\t// In Strict mode it's an error if a global attribute declaration cannot be\n-\t\t\t\t\t\t\t\t\t\t\t// resolved.\n-\t\t\t\t\t\t\t\t\t\t\terrors.error(new CvcMissingAttributeDeclarationException(elementPSVI.getName(), attributeName, elementItem.getLocation()));\n-\t\t\t\t\t\t\t\t\t\t\tif (null != downstream)\n-\t\t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\t\tdownstream.attribute(attributeName, initialValue);\n-\t\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t\t\t\tdefault:\n-\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\tthrow new AssertionError(processContents);\n-\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\telse\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\terrors.error(new CvcUnexpectedAttributeException(elementPSVI.getName(), attributeName, elementItem.getLocation()));\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\telse\n-\t\t\t\t\t{\n-\t\t\t\t\t\terrors.error(new CvcUnexpectedAttributeException(elementPSVI.getName(), attributeName, elementItem.getLocation()));\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\telse if (elementType instanceof SimpleType)\n-\t\t\t{\n-\t\t\t\tfinal SimpleType simpleType = (SimpleType)elementType;\n-\t\t\t\terrors.error(new CvcAttributeOnSimpleTypeException(elementPSVI.getName(), attributeName, simpleType, elementItem.getLocation()));\n-\t\t\t}\n-\t\t\telse\n-\t\t\t{\n-\t\t\t\tthrow new AssertionError(\"Are we handling all cases?\");\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Check that all expected attributes are present and generate any that are specified as defaults.\n-\t * \n-\t * @param errors\n-\t *            The exception handler for reporting a missing attribute or a datatype error.\n-\t * @param downstream\n-\t *            The handler for downstream events.\n-\t */\n-\tprivate int checkForMissingAttributes(final ModelPSVI elementPSVI, final ValidationItem elementItem, final int lastIndex, final SchemaExceptionHandler errors, final VxOutputHandler<A> downstream, final IdManager idm, final IdentityConstraintManager icm) throws IOException, AbortException\n-\t{\n-\t\tint attributeIndex = lastIndex;\n-\t\tfinal Type elementType = elementPSVI.getType();\n-\t\tif (elementType instanceof ComplexType)\n-\t\t{\n-\t\t\tfinal ComplexType complexType = (ComplexType)elementType;\n-\t\t\tfor (final AttributeUse attributeUse : complexType.getAttributeUses().values())\n-\t\t\t{\n-\t\t\t\tfinal AttributeDefinition attribute = attributeUse.getAttribute();\n-\t\t\t\tfinal QName attributeName = attribute.getName();\n-\t\t\t\tif (!m_attributes.contains(attributeName))\n-\t\t\t\t{\n-\n-\t\t\t\t\tfinal ValueConstraint valueConstraint = attributeUse.getEffectiveValueConstraint();\n-\t\t\t\t\tif (null != valueConstraint)\n-\t\t\t\t\t{\n-\t\t\t\t\t\tswitch (valueConstraint.getVariety())\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tcase Default:\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tattributeIndex++;\n-\t\t\t\t\t\t\t\t// Create attribute with the value - a nasty W3C XML Schema side effect!\n-\t\t\t\t\t\t\t\t// TODO: I think we need to re-validate here to get the actual type?\n-\t\t\t\t\t\t\t\t// TODO: This would then apply to the managers and the downstream.\n-\t\t\t\t\t\t\t\tfinal Type attributeType = attribute.getType();\n-\t\t\t\t\t\t\t\tfinal List<A> actualValue = valueConstraint.getValue(atomBridge);\n-\n-\t\t\t\t\t\t\t\tif (attributeType instanceof SimpleType)\n-\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\tfinal SimpleType simpleType = (SimpleType)attributeType;\n-\t\t\t\t\t\t\t\t\tidm.attribute(actualValue, simpleType, elementItem, errors, atomBridge);\n-\t\t\t\t\t\t\t\t\ticm.attribute(actualValue, simpleType, elementItem, attributeName, attributeIndex, atomBridge);\n-\n-\t\t\t\t\t\t\t\t\tif (null != downstream)\n-\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\tdownstream.attribute(attributeName, actualValue, simpleType);\n-\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\telse\n-\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\tif (null != downstream)\n-\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\tdownstream.attribute(attributeName, atomBridge.getC14NString(actualValue));\n-\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t\tcase Fixed:\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tif (attributeUse.isRequired())\n-\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\terrors.error(new SmMissingAttributeException(elementPSVI.getName(), attributeName, elementItem.getLocation()));\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t\tdefault:\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tthrow new AssertionError(valueConstraint.getVariety());\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\telse\n-\t\t\t\t\t{\n-\t\t\t\t\t\tif (attributeUse.isRequired())\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\terrors.error(new SmMissingAttributeException(elementPSVI.getName(), attributeName, elementItem.getLocation()));\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn attributeIndex;\n-\t}\n-\n-\tprivate void checkValueAgainstValueConstraint(final ValueConstraint valueConstraint, final QName attributeName, final List<? extends A> actualValue, final Locatable locatable, final SchemaExceptionHandler errors, final AtomBridge<A> atomBridge) throws AbortException\n-\t{\n-\t\tif (null != valueConstraint)\n-\t\t{\n-\t\t\tswitch (valueConstraint.getVariety())\n-\t\t\t{\n-\t\t\t\tcase Fixed:\n-\t\t\t\t{\n-\t\t\t\t\tfinal List<A> fixed = valueConstraint.getValue(atomBridge);\n-\n-\t\t\t\t\tif (!ValidationSupport.equalValues(fixed, actualValue))\n-\t\t\t\t\t{\n-\t\t\t\t\t\tfinal String fixedC14N = atomBridge.getC14NString(fixed);\n-\t\t\t\t\t\tfinal String actualC14N = atomBridge.getC14NString(actualValue);\n-\t\t\t\t\t\terrors.error(new CvcAttributeFixedValueOverriddenException(attributeName, fixedC14N, actualC14N, locatable.getLocation()));\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tbreak;\n-\t\t\t\tcase Default:\n-\t\t\t\t{\n-\t\t\t\t\t// No problem.\n-\t\t\t\t}\n-\t\t\t\tbreak;\n-\t\t\t\tdefault:\n-\t\t\t\t{\n-\t\t\t\t\tthrow new RuntimeException(valueConstraint.getVariety().name());\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic Boolean getLocalNil()\n-\t{\n-\t\treturn m_localNil;\n-\t}\n-\n-\tpublic Type getLocalType()\n-\t{\n-\t\treturn m_localType;\n-\t}\n-\n-\t/**\n-\t * Initialize this manager by examining those attributes in the W3C XML Schema-instance namespace.\n-\t * \n-\t * @param elementName\n-\t *            The element information item name.\n-\t * @param attributes\n-\t *            The list of attributes.\n-\t * @param errors\n-\t *            The handler for exceptions.\n-\t * @param p2n\n-\t *            A prefix resolver.\n-\t */\n-\tpublic void initialize(final QName elementName, final Locatable locatable, final LinkedList<VxMapping<QName, String>> attributes, final PrefixResolver p2n, final URI baseURI, final SchemaExceptionHandler errors, final VxSchemaDocumentLocationStrategy schemaDocumentLocationStrategy) throws IOException, AbortException\n-\t{\n-\t\treset();\n-\n-\t\tif (attributes.size() > 0) // Optimization.\n-\t\t{\n-\t\t\tfor (final VxMapping<QName, String> mapping : attributes)\n-\t\t\t{\n-\t\t\t\tfinal QName attributeName = mapping.getKey();\n-\t\t\t\tfinal String data = mapping.getValue();\n-\n-\t\t\t\tif (W3C_XML_SCHEMA_INSTANCE_NS_URI == attributeName.getNamespaceURI())\n-\t\t\t\t{\n-\t\t\t\t\tfinal String localName = attributeName.getLocalPart();\n-\t\t\t\t\tif (XSI_TYPE == localName)\n-\t\t\t\t\t{\n-\t\t\t\t\t\tfinal AttributeDefinition attribute = metaBridge.getAttributeDeclaration(attributeName);\n-\t\t\t\t\t\tfinal SimpleType attributeType = (SimpleType)attribute.getType();\n-\t\t\t\t\t\ttry\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tfinal A actualValue = attributeType.validate(data, atomBridge).get(0);\n-\t\t\t\t\t\t\tfinal QName typeName = resolveXsiType(atomBridge.getLocalNameFromQName(actualValue), atomBridge.getPrefixFromQName(actualValue), p2n);\n-\t\t\t\t\t\t\tm_localType = metaBridge.getTypeDefinition(typeName);\n-\t\t\t\t\t\t\tif (null != m_localType)\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tm_xsiAtoms.put(attributeName, new Pair<A, SimpleType>(actualValue, attributeType));\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\telse\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\terrors.error(new CvcElementUnresolvedLocalTypeException(typeName, elementName, locatable.getLocation()));\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tcatch (final DatatypeException dte)\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tfinal SimpleTypeException ste = new SimpleTypeException(data, attributeType, dte);\n-\t\t\t\t\t\t\terrors.error(new SmAttributeUseException(elementName, attributeName, locatable.getLocation(), ste));\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\telse if (XSI_NIL == localName)\n-\t\t\t\t\t{\n-\t\t\t\t\t\tfinal AttributeDefinition attribute = metaBridge.getAttributeDeclaration(attributeName);\n-\t\t\t\t\t\tfinal SimpleType attributeType = (SimpleType)attribute.getType();\n-\t\t\t\t\t\ttry\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tfinal A actualValue = attributeType.validate(data, atomBridge).get(0);\n-\t\t\t\t\t\t\tm_localNil = atomBridge.getBoolean(actualValue);\n-\t\t\t\t\t\t\tm_xsiAtoms.put(attributeName, new Pair<A, SimpleType>(actualValue, attributeType));\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tcatch (final DatatypeException dte)\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tfinal SimpleTypeException ste = new SimpleTypeException(data, attributeType, dte);\n-\t\t\t\t\t\t\terrors.error(new SmAttributeUseException(elementName, attributeName, locatable.getLocation(), ste));\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\telse if (XSI_SCHEMA_LOCATION == localName)\n-\t\t\t\t\t{\n-\t\t\t\t\t\tfinal AttributeDefinition attribute = metaBridge.getAttributeDeclaration(attributeName);\n-\t\t\t\t\t\tfinal SimpleType attributeType = (SimpleType)attribute.getType();\n-\t\t\t\t\t\ttry\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tfinal List<A> actualValue = attributeType.validate(data, atomBridge);\n-\t\t\t\t\t\t\tif (null != schemaDocumentLocationStrategy)\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tfinal Iterator<A> atoms = actualValue.iterator();\n-\t\t\t\t\t\t\t\twhile (atoms.hasNext())\n-\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\tfinal URI namespace = atomBridge.getURI(atoms.next());\n-\t\t\t\t\t\t\t\t\tif (atoms.hasNext())\n-\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\tfinal URI schemaLocation = atomBridge.getURI(atoms.next());\n-\t\t\t\t\t\t\t\t\t\ttry\n-\t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\tschemaDocumentLocationStrategy.schemaLocation(baseURI, namespace, schemaLocation);\n-\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t\tcatch (final Exception e)\n-\t\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\t\t// Ignore\n-\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tm_xsiLists.put(attributeName, new Pair<List<? extends A>, SimpleType>(actualValue, attributeType));\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tcatch (final DatatypeException dte)\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tfinal SimpleTypeException ste = new SimpleTypeException(data, attributeType, dte);\n-\t\t\t\t\t\t\terrors.error(new SmAttributeUseException(elementName, attributeName, locatable.getLocation(), ste));\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\telse if (XSI_NO_NAMESPACE_SCHEMA_LOCATION == localName)\n-\t\t\t\t\t{\n-\t\t\t\t\t\tfinal AttributeDefinition attribute = metaBridge.getAttributeDeclaration(attributeName);\n-\t\t\t\t\t\tfinal SimpleType attributeType = (SimpleType)attribute.getType();\n-\t\t\t\t\t\ttry\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tfinal A actualValue = attributeType.validate(data, atomBridge).get(0);\n-\t\t\t\t\t\t\tif (null != schemaDocumentLocationStrategy)\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tfinal URI schemaLocation = atomBridge.getURI(actualValue);\n-\t\t\t\t\t\t\t\tschemaDocumentLocationStrategy.noNamespaceSchemaLocation(baseURI, schemaLocation);\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tm_xsiAtoms.put(attributeName, new Pair<A, SimpleType>(actualValue, attributeType));\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tcatch (final DatatypeException dte)\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tfinal SimpleTypeException ste = new SimpleTypeException(data, attributeType, dte);\n-\t\t\t\t\t\t\terrors.error(new SmAttributeUseException(elementName, attributeName, locatable.getLocation(), ste));\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\telse\n-\t\t\t\t\t{\n-\t\t\t\t\t\t// Ignore the attribute, it gets handled along with all the others\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic void reset()\n-\t{\n-\t\tm_attributes.clear();\n-\t\tm_xsiAtoms.clear();\n-\t\tm_xsiLists.clear();\n-\t\tm_localType = null;\n-\t\tm_localNil = null;\n-\t}\n-\n-\tprivate QName resolveXsiType(final String localName, final String prefix, final PrefixResolver p2n)\n-\t{\n-\t\tif (prefix.length() > 0)\n-\t\t{\n-\t\t\tfinal String namespaceURI = p2n.getNamespace(prefix);\n-\t\t\tif (null != namespaceURI)\n-\t\t\t{\n-\t\t\t\treturn new QName(namespaceURI, localName, prefix);\n-\t\t\t}\n-\t\t\telse\n-\t\t\t{\n-\t\t\t\tthrow new AssertionError(\"Unable to resolve prefix: '\" + prefix + \"'\");\n-\t\t\t}\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tfinal String namespaceURI = p2n.getNamespace(prefix);\n-\t\t\tif (null != namespaceURI)\n-\t\t\t{\n-\t\t\t\treturn new QName(namespaceURI, localName, prefix);\n-\t\t\t}\n-\t\t\telse\n-\t\t\t{\n-\t\t\t\treturn new QName(\"\", localName, prefix);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Validates the collection of attributes for the element information item, augmented using defaults, and sent\n-\t * downstream.\n-\t * \n-\t * @param elementItem\n-\t *            The element information item.\n-\t * @param attributes\n-\t *            The list of attributes.\n-\t * @param downstream\n-\t *            The handler for downstream events.\n-\t * @param errors\n-\t *            The handler for exceptions.\n-\t * @param icm\n-\t *            The identity constraint manager.\n-\t * @param p2n\n-\t *            A prefix resolver.\n-\t * \n-\t * @return The index of the last attribute.\n-\t */\n-\tpublic int attributes(final ModelPSVI elementPSVI, final ValidationItem elementItem, final List<VxMapping<QName, String>> attributes, final VxOutputHandler<A> downstream, final SchemaExceptionHandler errors, final IdManager idm, final IdentityConstraintManager icm) throws IOException, AbortException\n-\t{\n-\t\tint attributeIndex = elementItem.getElementIndex();\n-\t\tfor (final VxMapping<QName, String> mapping : attributes)\n-\t\t{\n-\t\t\tattributeIndex++;\n-\t\t\tfinal QName attributeName = mapping.getKey();\n-\t\t\tif (m_xsiAtoms.containsKey(attributeName))\n-\t\t\t{\n-\t\t\t\tif (null != downstream)\n-\t\t\t\t{\n-\t\t\t\t\tdownstream.attribute(attributeName, atomBridge.wrapAtom(m_xsiAtoms.get(attributeName).getFirst()), m_xsiAtoms.get(attributeName).getSecond());\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\telse if (m_xsiLists.containsKey(attributeName))\n-\t\t\t{\n-\t\t\t\tif (null != downstream)\n-\t\t\t\t{\n-\t\t\t\t\tdownstream.attribute(attributeName, m_xsiLists.get(attributeName).getFirst(), m_xsiLists.get(attributeName).getSecond());\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\telse\n-\t\t\t{\n-\t\t\t\t// Make a note that we have seen this attribute.\n-\t\t\t\tm_attributes.add(attributeName);\n-\t\t\t\tattribute(elementPSVI, elementItem, attributeName, attributeIndex, mapping.getValue(), downstream, errors, idm, icm);\n-\t\t\t}\n-\t\t}\n-\t\treturn checkForMissingAttributes(elementPSVI, elementItem, attributeIndex, errors, downstream, idm, icm);\n-\t}\n-\n-\tprivate List<A> validateAttributeWrtAttributeUse(final ValidationItem elementItem, final ValueConstraint valueConstraint, final QName attributeName, final SimpleType attributeType, final int attributeIndex, final String initialValue, final IdManager idm, final IdentityConstraintManager icm, final SchemaExceptionHandler errors, final AtomBridge<A> atomBridge) throws AbortException\n-\t{\n-\t\tfinal List<A> actualValue = validateAttributeWrtDeclaration(elementItem, valueConstraint, attributeName, attributeType, initialValue, errors, atomBridge);\n-\n-\t\tidm.attribute(actualValue, attributeType, elementItem, errors, atomBridge);\n-\t\ticm.attribute(actualValue, attributeType, elementItem, attributeName, attributeIndex, atomBridge);\n-\n-\t\tcheckValueAgainstValueConstraint(valueConstraint, attributeName, actualValue, elementItem, errors, atomBridge);\n-\n-\t\treturn actualValue;\n-\t}\n-\n-\tprivate List<A> validateAttributeWrtDeclaration(final Locatable location, final ValueConstraint valueConstraint, final QName attributeName, final SimpleType attributeType, final String initialValue, final SchemaExceptionHandler errors, final AtomBridge<A> atomBridge) throws AbortException\n-\t{\n-\t\tfinal List<A> actualValue = validateWrtType(attributeName, attributeType, initialValue, location, errors, atomBridge);\n-\n-\t\tcheckValueAgainstValueConstraint(valueConstraint, attributeName, actualValue, location, errors, atomBridge);\n-\n-\t\treturn actualValue;\n-\t}\n-\n-\tprivate List<A> validateWrtType(final QName attributeName, final SimpleType attributeType, final String initialValue, final Locatable locatable, final SchemaExceptionHandler errors, final AtomBridge<A> atomBridge) throws AbortException\n-\t{\n-\t\tPreCondition.assertArgumentNotNull(attributeName, \"attributeName\");\n-\t\tPreCondition.assertArgumentNotNull(attributeType);\n-\t\ttry\n-\t\t{\n-\t\t\treturn attributeType.validate(initialValue, atomBridge);\n-\t\t}\n-\t\tcatch (final DatatypeException dte)\n-\t\t{\n-\t\t\tfinal SimpleTypeException ste = new SimpleTypeException(initialValue, attributeType, dte);\n-\t\t\terrors.error(new CvcAttributeNormalizedValueException(attributeName, initialValue, locatable.getLocation(), ste));\n-\t\t\treturn atomBridge.wrapAtom(atomBridge.createUntypedAtomic(initialValue));\n-\t\t}\n-\t}\n-}\n+    private final AtomBridge<A> atomBridge;\n+    // Keep track of the attributes that we have seen in order to report missing attributes.\n+    private final Set<QName> m_attributes = new HashSet<QName>();\n+    private Boolean m_localNil = null;\n+    private Type m_localType = null;\n+    private final HashMap<QName, Pair<A, SimpleType>> m_xsiAtoms = new HashMap<QName, Pair<A, SimpleType>>();\n+    private final HashMap<QName, Pair<List<? extends A>, SimpleType>> m_xsiLists = new HashMap<QName, Pair<List<? extends A>, SimpleType>>();\n+    private final ComponentProvider metaBridge;\n+    private final String W3C_XML_SCHEMA_INSTANCE_NS_URI;\n+    private final String XSI_NIL;\n+    private final String XSI_NO_NAMESPACE_SCHEMA_LOCATION;\n+    private final String XSI_SCHEMA_LOCATION;\n+    private final String XSI_TYPE;\n+\n+    AttributeManager(final ComponentProvider metaBridge, final AtomBridge<A> atomBridge)\n+    {\n+        this.metaBridge = PreCondition.assertArgumentNotNull(metaBridge, \"metaBridge\");\n+        this.atomBridge = PreCondition.assertArgumentNotNull(atomBridge, \"atomBridge\");\n+        this.W3C_XML_SCHEMA_INSTANCE_NS_URI = XMLConstants.W3C_XML_SCHEMA_INSTANCE_NS_URI;\n+        this.XSI_NIL = \"nil\";\n+        this.XSI_NO_NAMESPACE_SCHEMA_LOCATION = \"noNamespaceSchemaLocation\";\n+        this.XSI_SCHEMA_LOCATION = \"schemaLocation\";\n+        this.XSI_TYPE = \"type\";\n+    }\n+\n+    private void attribute(final ModelPSVI elementPSVI, final ValidationItem elementItem, final QName attributeName, final int attributeIndex, final String initialValue, final VxOutputHandler<A> downstream, final SchemaExceptionHandler errors, final IdManager idm, final IdentityConstraintManager icm)\n+        throws IOException, AbortException\n+    {\n+        final Type elementType = elementPSVI.getType();\n+        if (null == elementType)\n+        {\n+            // Short-circuit if we could not assign a type.\n+            if (null != downstream)\n+            {\n+                downstream.attribute(attributeName, initialValue);\n+            }\n+        }\n+        else\n+        {\n+            if (elementType instanceof ComplexType)\n+            {\n+                final ComplexType complexType = (ComplexType)elementType;\n+                final AttributeUse attributeUse = complexType.getAttributeUses().get(attributeName);\n+                if (null != attributeUse)\n+                {\n+                    final ValueConstraint valueConstraint = attributeUse.getEffectiveValueConstraint();\n+                    final AttributeDefinition attribute = attributeUse.getAttribute();\n+                    final Type attributeType = attribute.getType();\n+                    if (attributeType instanceof SimpleType)\n+                    {\n+                        final SimpleType simpleType = (SimpleType)attributeType;\n+                        final List<A> actualValue = validateAttributeWrtAttributeUse(elementItem, valueConstraint, attributeName, simpleType, attributeIndex, initialValue, idm, icm, errors, atomBridge);\n+                        if (null != downstream)\n+                        {\n+                            downstream.attribute(attributeName, actualValue, simpleType);\n+                        }\n+                    }\n+                    else\n+                    {\n+                        if (null != downstream)\n+                        {\n+                            downstream.attribute(attributeName, initialValue);\n+                        }\n+                    }\n+                }\n+                else\n+                {\n+                    final SchemaWildcard attributeWildcard = complexType.getAttributeWildcard();\n+                    if (null != attributeWildcard)\n+                    {\n+                        // If we end up here then the attribute was not recognized by {attribute uses}.\n+                        final NamespaceConstraint wildcardNs = attributeWildcard.getNamespaceConstraint();\n+                        if (wildcardNs == null)\n+                        {\n+                            errors.error(new CvcUnexpectedAttributeException(elementPSVI.getName(), attributeName, elementItem.getLocation()));\n+                        }\n+                        else\n+                        {\n+                            if (wildcardNs.allowsNamespaceName(attributeName.getNamespaceURI()))\n+                            {\n+                                final ProcessContentsMode processContents = attributeWildcard.getProcessContents();\n+\n+                                switch (processContents)\n+                                {\n+                                    case Skip:\n+                                    {\n+                                        // Do nothing.\n+                                        if (null != downstream)\n+                                        {\n+                                            downstream.attribute(attributeName, initialValue);\n+                                        }\n+                                    }\n+                                    break;\n+                                    case Lax:\n+                                    {\n+                                        final AttributeDefinition attribute = metaBridge.getAttributeDeclaration(attributeName);\n+                                        if (null != attribute)\n+                                        {\n+                                            final Type attributeType = attribute.getType();\n+                                            if (attributeType instanceof SimpleType)\n+                                            {\n+                                                final SimpleType simpleType = (SimpleType)attributeType;\n+                                                final ValueConstraint valueConstraint = attribute.getValueConstraint();\n+                                                final List<A> actualValue = validateAttributeWrtDeclaration(elementItem, valueConstraint, attributeName, simpleType, initialValue, errors, atomBridge);\n+                                                idm.attribute(actualValue, simpleType, elementItem, errors, atomBridge);\n+                                                icm.attribute(actualValue, simpleType, elementItem, attributeName, attributeIndex, atomBridge);\n+                                                if (null != downstream)\n+                                                {\n+                                                    downstream.attribute(attributeName, actualValue, simpleType);\n+                                                }\n+                                            }\n+                                            else\n+                                            {\n+                                                if (null != downstream)\n+                                                {\n+                                                    downstream.attribute(attributeName, initialValue);\n+                                                }\n+                                            }\n+                                        }\n+                                        else\n+                                        {\n+                                            // In Lax mode it's not an error if a global attribute declaration cannot be\n+                                            // resolved.\n+                                            if (null != downstream)\n+                                            {\n+                                                downstream.attribute(attributeName, initialValue);\n+                                            }\n+                                        }\n+                                    }\n+                                    break;\n+                                    case Strict:\n+                                    {\n+                                        final AttributeDefinition attribute = metaBridge.getAttributeDeclaration(attributeName);\n+                                        if (null != attribute)\n+                                        {\n+                                            final Type attributeType = attribute.getType();\n+                                            if (attributeType instanceof SimpleType)\n+                                            {\n+                                                final SimpleType simpleType = (SimpleType)attributeType;\n+                                                final ValueConstraint valueConstraint = attribute.getValueConstraint();\n+                                                final List<A> actualValue = validateAttributeWrtDeclaration(elementItem, valueConstraint, attributeName, simpleType, initialValue, errors, atomBridge);\n+                                                idm.attribute(actualValue, simpleType, elementItem, errors, atomBridge);\n+                                                icm.attribute(actualValue, simpleType, elementItem, attributeName, attributeIndex, atomBridge);\n+                                                if (null != downstream)\n+                                                {\n+                                                    downstream.attribute(attributeName, actualValue, simpleType);\n+                                                }\n+                                            }\n+                                            else\n+                                            {\n+                                                if (null != downstream)\n+                                                {\n+                                                    downstream.attribute(attributeName, initialValue);\n+                                                }\n+                                            }\n+                                        }\n+                                        else\n+                                        {\n+                                            // In Strict mode it's an error if a global attribute declaration cannot be\n+                                            // resolved.\n+                                            errors.error(new CvcMissingAttributeDeclarationException(elementPSVI.getName(), attributeName, elementItem.getLocation()));\n+                                            if (null != downstream)\n+                                            {\n+                                                downstream.attribute(attributeName, initialValue);\n+                                            }\n+                                        }\n+                                    }\n+                                    break;\n+                                    default:\n+                                    {\n+                                        throw new AssertionError(processContents);\n+                                    }\n+                                }\n+                            }\n+                            else\n+                            {\n+                                errors.error(new CvcUnexpectedAttributeException(elementPSVI.getName(), attributeName, elementItem.getLocation()));\n+                            }\n+                        }\n+                    }\n+                    else\n+                    {\n+                        errors.error(new CvcUnexpectedAttributeException(elementPSVI.getName(), attributeName, elementItem.getLocation()));\n+                    }\n+                }\n+            }\n+            else if (elementType instanceof SimpleType)\n+            {\n+                final SimpleType simpleType = (SimpleType)elementType;\n+                errors.error(new CvcAttributeOnSimpleTypeException(elementPSVI.getName(), attributeName, simpleType, elementItem.getLocation()));\n+            }\n+            else\n+            {\n+                throw new AssertionError(\"Are we handling all cases?\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Check that all expected attributes are present and generate any that are specified as defaults.\n+     * \n+     * @param errors\n+     *            The exception handler for reporting a missing attribute or a datatype error.\n+     * @param downstream\n+     *            The handler for downstream events.\n+     */\n+\n+    private int checkForMissingAttributes(final ModelPSVI elementPSVI, final ValidationItem elementItem, final int lastIndex, final SchemaExceptionHandler errors, final VxOutputHandler<A> downstream, final IdManager idm, final IdentityConstraintManager icm)\n+        throws IOException, AbortException\n+    {\n+        int attributeIndex = lastIndex;\n+        final Type elementType = elementPSVI.getType();\n+        if (elementType instanceof ComplexType)\n+        {\n+            final ComplexType complexType = (ComplexType)elementType;\n+            for (final AttributeUse attributeUse : complexType.getAttributeUses().values())\n+            {\n+                final AttributeDefinition attribute = attributeUse.getAttribute();\n+                final QName attributeName = attribute.getName();\n+                if (!m_attributes.contains(attributeName))\n+                {\n+                    final ValueConstraint valueConstraint = attributeUse.getEffectiveValueConstraint();\n+                    if (null != valueConstraint)\n+                    {\n+                        switch (valueConstraint.getVariety())\n+                        {\n+                            case Default:\n+                            {\n+                                attributeIndex++;\n+                                // Create attribute with the value - a nasty W3C XML Schema side effect!\n+                                // TODO: I think we need to re-validate here to get the actual type?\n+                                // TODO: This would then apply to the managers and the downstream.\n+\n+                                final Type attributeType = attribute.getType();\n+                                final List<A> actualValue = valueConstraint.getValue(atomBridge);\n+                                if (attributeType instanceof SimpleType)\n+                                {\n+                                    final SimpleType simpleType = (SimpleType)attributeType;\n+                                    idm.attribute(actualValue, simpleType, elementItem, errors, atomBridge);\n+                                    icm.attribute(actualValue, simpleType, elementItem, attributeName, attributeIndex, atomBridge);\n+                                    if (null != downstream)\n+                                    {\n+                                        downstream.attribute(attributeName, actualValue, simpleType);\n+                                    }\n+                                }\n+                                else\n+                                {\n+                                    if (null != downstream)\n+                                    {\n+                                        downstream.attribute(attributeName, atomBridge.getC14NString(actualValue));\n+                                    }\n+                                }\n+                            }\n+                            break;\n+                            case Fixed:\n+                            {\n+                                if (attributeUse.isRequired())\n+                                {\n+                                    errors.error(new SmMissingAttributeException(elementPSVI.getName(), attributeName, elementItem.getLocation()));\n+                                }\n+                            }\n+                            break;\n+                            default:\n+                            {\n+                                throw new AssertionError(valueConstraint.getVariety());\n+                            }\n+                        }\n+                    }\n+                    else\n+                    {\n+                        if (attributeUse.isRequired())\n+                        {\n+                            errors.error(new SmMissingAttributeException(elementPSVI.getName(), attributeName, elementItem.getLocation()));\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        return attributeIndex;\n+    }\n+\n+    private void checkValueAgainstValueConstraint(final ValueConstraint valueConstraint, final QName attributeName, final List<? extends A> actualValue, final Locatable locatable, final SchemaExceptionHandler errors, final AtomBridge<A> atomBridge)\n+        throws AbortException\n+    {\n+        if (null != valueConstraint)\n+        {\n+            switch (valueConstraint.getVariety())\n+            {\n+                case Fixed:\n+                {\n+                    final List<A> fixed = valueConstraint.getValue(atomBridge);\n+                    if (!ValidationSupport.equalValues(fixed, actualValue))\n+                    {\n+                        final String fixedC14N = atomBridge.getC14NString(fixed);\n+                        final String actualC14N = atomBridge.getC14NString(actualValue);\n+                        errors.error(new CvcAttributeFixedValueOverriddenException(attributeName, fixedC14N, actualC14N, locatable.getLocation()));\n+                    }\n+                }\n+                break;\n+                case Default:\n+                {\n+                    // No problem.\n+\n+                }\n+                break;\n+                default:\n+                {\n+                    throw new RuntimeException(valueConstraint.getVariety().name());\n+                }\n+            }\n+        }\n+    }\n+\n+    public Boolean getLocalNil()\n+    {\n+        return m_localNil;\n+    }\n+\n+    public Type getLocalType()\n+    {\n+        return m_localType;\n+    }\n+\n+    /**\n+     * Initialize this manager by examining those attributes in the W3C XML Schema-instance namespace.\n+     * \n+     * @param elementName\n+     *            The element information item name.\n+     * @param attributes\n+     *            The list of attributes.\n+     * @param errors\n+     *            The handler for exceptions.\n+     * @param p2n\n+     *            A prefix resolver.\n+     */\n+\n+    public void initialize(final QName elementName, final Locatable locatable, final LinkedList<VxMapping<QName, String>> attributes, final PrefixResolver p2n, final URI baseURI, final SchemaExceptionHandler errors, final VxSchemaDocumentLocationStrategy schemaDocumentLocationStrategy)\n+        throws IOException, AbortException\n+    {\n+        reset();\n+        if (attributes.size() > 0) // Optimization.\n+        {\n+            for (final VxMapping<QName, String> mapping : attributes)\n+            {\n+                final QName attributeName = mapping.getKey();\n+                final String data = mapping.getValue();\n+                if (W3C_XML_SCHEMA_INSTANCE_NS_URI == attributeName.getNamespaceURI())\n+                {\n+                    final String localName = attributeName.getLocalPart();\n+                    if (XSI_TYPE == localName)\n+                    {\n+                        final AttributeDefinition attribute = metaBridge.getAttributeDeclaration(attributeName);\n+                        final SimpleType attributeType = (SimpleType)attribute.getType();\n+                        try\n+                        {\n+                            final A actualValue = attributeType.validate(data, atomBridge).get(0);\n+                            final QName typeName = resolveXsiType(atomBridge.getLocalNameFromQName(actualValue), atomBridge.getPrefixFromQName(actualValue), p2n);\n+                            m_localType = metaBridge.getTypeDefinition(typeName);\n+                            if (null != m_localType)\n+                            {\n+                                m_xsiAtoms.put(attributeName,\n+                            new Pair<A, SimpleType>(actualValue, attributeType));\n+                            }\n+                            else\n+                            {\n+                                errors.error(new CvcElementUnresolvedLocalTypeException(typeName, elementName, locatable.getLocation()));\n+                            }\n+                        }\n+                        catch (final DatatypeException dte)\n+                        {\n+                            final SimpleTypeException ste = new SimpleTypeException(data, attributeType, dte);\n+                            errors.error(new SmAttributeUseException(elementName, attributeName, locatable.getLocation(), ste));\n+                        }\n+                    }\n+                    else if (XSI_NIL == localName)\n+                    {\n+                        final AttributeDefinition attribute = metaBridge.getAttributeDeclaration(attributeName);\n+                        final SimpleType attributeType = (SimpleType)attribute.getType();\n+                        try\n+                        {\n+                            final A actualValue = attributeType.validate(data, atomBridge).get(0);\n+                            m_localNil = atomBridge.getBoolean(actualValue);\n+                            m_xsiAtoms.put(attributeName,\n+new Pair<A, SimpleType>(actualValue, attributeType));\n+                        }\n+                        catch (final DatatypeException dte)\n+                        {\n+                            final SimpleTypeException ste = new SimpleTypeException(data, attributeType, dte);\n+                            errors.error(new SmAttributeUseException(elementName, attributeName, locatable.getLocation(), ste));\n+                        }\n+                    }\n+                    else if (XSI_SCHEMA_LOCATION == localName)\n+                    {\n+                        final AttributeDefinition attribute = metaBridge.getAttributeDeclaration(attributeName);\n+                        final SimpleType attributeType = (SimpleType)attribute.getType();\n+                        try\n+                        {\n+                            final List<A> actualValue = attributeType.validate(data, atomBridge);\n+                            if (null != schemaDocumentLocationStrategy)\n+                            {\n+                                final Iterator<A> atoms = actualValue.iterator();\n+                                while (atoms.hasNext())\n+                                {\n+                                    final URI namespace = atomBridge.getURI(atoms.next());\n+                                    if (atoms.hasNext())\n+                                    {\n+                                        final URI schemaLocation = atomBridge.getURI(atoms.next());\n+                                        try\n+                                        {\n+                                            schemaDocumentLocationStrategy.schemaLocation(baseURI, namespace, schemaLocation);\n+                                        }\n+                                        catch (final Exception e)\n+                                        {\n+                                            // Ignore\n+\n+                                        }\n+                                    }\n+                                }\n+                            }\n+                            m_xsiLists.put(attributeName, new Pair<List<? extends A>, SimpleType>(actualValue, attributeType));\n+                        }\n+                        catch (final DatatypeException dte)\n+                        {\n+                            final SimpleTypeException ste = new SimpleTypeException(data, attributeType, dte);\n+                            errors.error(new SmAttributeUseException(elementName, attributeName, locatable.getLocation(), ste));\n+                        }\n+                    }\n+                    else if (XSI_NO_NAMESPACE_SCHEMA_LOCATION == localName)\n+                    {\n+                        final AttributeDefinition attribute = metaBridge.getAttributeDeclaration(attributeName);\n+                        final SimpleType attributeType = (SimpleType)attribute.getType();\n+                        try\n+                        {\n+                            final A actualValue = attributeType.validate(data, atomBridge).get(0);\n+                            if (null != schemaDocumentLocationStrategy)\n+                            {\n+                                final URI schemaLocation = atomBridge.getURI(actualValue);\n+                                schemaDocumentLocationStrategy.noNamespaceSchemaLocation(baseURI, schemaLocation);\n+                            }\n+                            m_xsiAtoms.put(attributeName,\n+new Pair<A, SimpleType>(actualValue, attributeType));\n+                        }\n+                        catch (final DatatypeException dte)\n+                        {\n+                            final SimpleTypeException ste = new SimpleTypeException(data, attributeType, dte);\n+                            errors.error(new SmAttributeUseException(elementName, attributeName, locatable.getLocation(), ste));\n+                        }\n+                    }\n+                    else\n+                    {\n+                        // Ignore the attribute, it gets handled along with all the others\n+\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    public void reset()\n+    {\n+        m_attributes.clear();\n+        m_xsiAtoms.clear();\n+        m_xsiLists.clear();\n+        m_localType = null;\n+        m_localNil = null;\n+    }\n+\n+    private QName resolveXsiType(final String localName, final String prefix, final PrefixResolver p2n)\n+    {\n+        if (prefix.length() > 0)\n+        {\n+            final String namespaceURI = p2n.getNamespace(prefix);\n+            if (null != namespaceURI)\n+            {\n+                return new QName(namespaceURI, localName, prefix);\n+            }\n+            else\n+            {\n+                throw new AssertionError(\"Unable to resolve prefix: '\" + prefix + \"'\");\n+            }\n+        }\n+        else\n+        {\n+            final String namespaceURI = p2n.getNamespace(prefix);\n+            if (null != namespaceURI)\n+            {\n+                return new QName(namespaceURI, localName, prefix);\n+            }\n+            else\n+            {\n+                return new QName(\"\", localName, prefix);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Validates the collection of attributes for the element information item, augmented using defaults, and sent\n+     * downstream.\n+     * \n+     * @param elementItem\n+     *            The element information item.\n+     * @param attributes\n+     *            The list of attributes.\n+     * @param downstream\n+     *            The handler for downstream events.\n+     * @param errors\n+     *            The handler for exceptions.\n+     * @param icm\n+     *            The identity constraint manager.\n+     * @param p2n\n+     *            A prefix resolver.\n+     * \n+     * @return The index of the last attribute.\n+     */\n+\n+    public int attributes(final ModelPSVI elementPSVI, final ValidationItem elementItem, final List<VxMapping<QName, String>> attributes, final VxOutputHandler<A> downstream, final SchemaExceptionHandler errors, final IdManager idm, final IdentityConstraintManager icm)\n+        throws IOException, AbortException\n+    {\n+        int attributeIndex = elementItem.getElementIndex();\n+        for (final VxMapping<QName, String> mapping : attributes)\n+        {\n+            attributeIndex++;\n+\n+            final QName attributeName = mapping.getKey();\n+            if (m_xsiAtoms.containsKey(attributeName))\n+            {\n+                if (null != downstream)\n+                {\n+                    downstream.attribute(attributeName, atomBridge.wrapAtom(m_xsiAtoms.get(attributeName).getFirst()), m_xsiAtoms.get(attributeName).getSecond());\n+                }\n+            }\n+            else if (m_xsiLists.containsKey(attributeName))\n+            {\n+                if (null != downstream)\n+                {\n+                    downstream.attribute(attributeName, m_xsiLists.get(attributeName).getFirst(), m_xsiLists.get(attributeName).getSecond());\n+                }\n+            }\n+            else\n+            {\n+                // Make a note that we have seen this attribute.\n+                m_attributes.add(attributeName);\n+                attribute(elementPSVI, elementItem, attributeName, attributeIndex, mapping.getValue(), downstream, errors, idm, icm);\n+            }\n+        }\n+        return checkForMissingAttributes(elementPSVI, elementItem, attributeIndex, errors, downstream, idm, icm);\n+    }\n+\n+    private List<A> validateAttributeWrtAttributeUse(final ValidationItem elementItem, final ValueConstraint valueConstraint, final QName attributeName, final SimpleType attributeType, final int attributeIndex, final String initialValue, final IdManager idm, final IdentityConstraintManager icm, final SchemaExceptionHandler errors, final AtomBridge<A> atomBridge)\n+        throws AbortException\n+    {\n+        final List<A> actualValue = validateAttributeWrtDeclaration(elementItem, valueConstraint, attributeName, attributeType, initialValue, errors, atomBridge);\n+        idm.attribute(actualValue, attributeType, elementItem, errors, atomBridge);\n+        icm.attribute(actualValue, attributeType, elementItem, attributeName, attributeIndex, atomBridge);\n+        checkValueAgainstValueConstraint(valueConstraint, attributeName, actualValue, elementItem, errors, atomBridge);\n+        return actualValue;\n+    }\n+\n+    private List<A> validateAttributeWrtDeclaration(final Locatable location, final ValueConstraint valueConstraint, final QName attributeName, final SimpleType attributeType, final String initialValue, final SchemaExceptionHandler errors, final AtomBridge<A> atomBridge)\n+        throws AbortException\n+    {\n+        final List<A> actualValue = validateWrtType(attributeName,\n+            attributeType,\n+                initialValue,\n+                    location,\n+                        errors,\n+                            atomBridge);\n+        checkValueAgainstValueConstraint(valueConstraint, attributeName, actualValue, location, errors, atomBridge);\n+        return actualValue;\n+    }\n+\n+    private List<A> validateWrtType(final QName attributeName, final SimpleType attributeType, final String initialValue, final Locatable locatable, final SchemaExceptionHandler errors, final AtomBridge<A> atomBridge)\n+        throws AbortException\n+    {\n+        PreCondition.assertArgumentNotNull(attributeName, \"attributeName\");\n+        PreCondition.assertArgumentNotNull(attributeType);\n+        try\n+        {\n+            return attributeType.validate(initialValue, atomBridge);\n+        }\n+        catch (final DatatypeException dte)\n+        {\n+            final SimpleTypeException ste = new SimpleTypeException(initialValue, attributeType, dte);\n+            errors.error(new CvcAttributeNormalizedValueException(attributeName, initialValue, locatable.getLocation(), ste));\n+            return atomBridge.wrapAtom(atomBridge.createUntypedAtomic(initialValue));\n+        }\n+    }\n+}\n\\ No newline at end of file\n",
            "diff_size": 591
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "66",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/249/AttributeManager.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_random/249/AttributeManager.java\nindex bcf23250b47..c83ccb6180c 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/249/AttributeManager.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_random/249/AttributeManager.java\n@@ -62,7 +62,7 @@ import org.genxdm.xs.types.Type;\n  */\n final class AttributeManager<A>\n {\n-\tprivate final AtomBridge<A> atomBridge;\n+private final AtomBridge<A> atomBridge;\n \t// Keep track of the attributes that we have seen in order to report missing attributes.\n \tprivate final Set<QName> m_attributes = new HashSet<QName>();\n \tprivate Boolean m_localNil = null;\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "66",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/249/AttributeManager.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_three_grams/249/AttributeManager.java\nindex bcf23250b47..2d2d5f0bb4a 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/249/AttributeManager.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_three_grams/249/AttributeManager.java\n@@ -62,7 +62,7 @@ import org.genxdm.xs.types.Type;\n  */\n final class AttributeManager<A>\n {\n-\tprivate final AtomBridge<A> atomBridge;\n+    private final AtomBridge<A> atomBridge;\n \t// Keep track of the attributes that we have seen in order to report missing attributes.\n \tprivate final Set<QName> m_attributes = new HashSet<QName>();\n \tprivate Boolean m_localNil = null;\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "intellij",
        "codebuff"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "styler_random",
        "styler_three_grams"
    ]
}