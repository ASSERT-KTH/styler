{
    "project_name": "graphfoundation-ongdb",
    "error_id": "2958",
    "information": {
        "errors": [
            {
                "line": "1",
                "severity": "error",
                "message": "Missing, wrong or duplicated license header",
                "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
            }
        ]
    },
    "source_code": "/*\n * Copyright (c) 2002-2020 \"Neo4j,\"\n * Neo4j Sweden AB [http://neo4j.com]\n *",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "1",
                    "severity": "error",
                    "message": "Missing, wrong or duplicated license header",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "1",
                    "severity": "error",
                    "message": "Missing, wrong or duplicated license header",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                },
                {
                    "line": "141",
                    "column": "16",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "141",
                    "column": "42",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "170",
                    "column": "21",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "170",
                    "column": "39",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/errored/1/2958/PagedFile.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/intellij/2958/PagedFile.java\nindex 1cce5a11f87..bf51e7dfad0 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/errored/1/2958/PagedFile.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/intellij/2958/PagedFile.java\n@@ -17,6 +17,7 @@\n  * You should have received a copy of the GNU General Public License\n  * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n  */\n+\n package org.neo4j.io.pagecache;\n \n import java.io.File;\n@@ -30,194 +31,194 @@ import java.nio.file.OpenOption;\n  */\n public interface PagedFile extends AutoCloseable\n {\n-    /**\n-     * Pin the pages with a shared lock.\n-     * <p>\n-     * This implies {@link org.neo4j.io.pagecache.PagedFile#PF_NO_GROW}, since\n-     * pages under read locks cannot be safely written to anyway, so there's\n-     * no point in trying to go beyond the end of the file.\n-     * <p>\n-     * This cannot be combined with {@link #PF_SHARED_WRITE_LOCK}.\n-     */\n-    int PF_SHARED_READ_LOCK = 1;\n-    /**\n-     * Pin the pages with a shared write lock.\n-     * <p>\n-     * This will mark the pages as dirty, and caused them to be flushed, if they are evicted.\n-     * <p>\n-     * Note that write locks are <em>not</em> exclusive. You must use other means to coordinate access to the data on\n-     * the pages. The write lock only means that the page will not be concurrently evicted.\n-     * <p>\n-     * Note also that write locks exclude eviction. So since we can assume that write locks never make conflicting\n-     * modifications (higher level locks should ensure this), it is safe to perform page writes without a\n-     * {@link PageCursor#shouldRetry() shouldRetry} loop. The {@code shouldRetry} method on write locking cursors\n-     * always returns {@code false}.\n-     * <p>\n-     * This cannot be combined with {@link #PF_SHARED_READ_LOCK}.\n-     */\n-    int PF_SHARED_WRITE_LOCK = 1 << 1;\n-    /**\n-     * Disallow pinning and navigating to pages outside the range of the\n-     * underlying file.\n-     */\n-    int PF_NO_GROW = 1 << 2;\n-    /**\n-     * Read-ahead hint for sequential forward scanning.\n-     */\n-    int PF_READ_AHEAD = 1 << 3; // TBD\n-    /**\n-     * Do not load in the page if it is not loaded already. The methods {@link PageCursor#next()} and\n-     * {@link PageCursor#next(long)} will always return {@code true} for pages that are within the range of the file,\n-     * but the {@link PageCursor#getCurrentPageId()} will return {@link PageCursor#UNBOUND_PAGE_ID} for pages that are\n-     * not in-memory. The current page id <em>must</em> be checked on every {@link PageCursor#shouldRetry()} loop\n-     * iteration, in case it (for a read cursor) was evicted concurrently with the page access.\n-     * <p>\n-     * {@link #PF_NO_FAULT} implies {@link #PF_NO_GROW}, since a page fault is necessary to be able to extend a file.\n-     */\n-    int PF_NO_FAULT = 1 << 4;\n-    /**\n-     * Do not update page access statistics.\n-     */\n-    int PF_TRANSIENT = 1 << 5; // TBD\n-    /**\n-     * Flush pages more aggressively, after they have been dirtied by a write cursor.\n-     */\n-    int PF_EAGER_FLUSH = 1 << 6;\n+  /**\n+   * Pin the pages with a shared lock.\n+   * <p>\n+   * This implies {@link org.neo4j.io.pagecache.PagedFile#PF_NO_GROW}, since\n+   * pages under read locks cannot be safely written to anyway, so there's\n+   * no point in trying to go beyond the end of the file.\n+   * <p>\n+   * This cannot be combined with {@link #PF_SHARED_WRITE_LOCK}.\n+   */\n+  int PF_SHARED_READ_LOCK = 1;\n+  /**\n+   * Pin the pages with a shared write lock.\n+   * <p>\n+   * This will mark the pages as dirty, and caused them to be flushed, if they are evicted.\n+   * <p>\n+   * Note that write locks are <em>not</em> exclusive. You must use other means to coordinate access to the data on\n+   * the pages. The write lock only means that the page will not be concurrently evicted.\n+   * <p>\n+   * Note also that write locks exclude eviction. So since we can assume that write locks never make conflicting\n+   * modifications (higher level locks should ensure this), it is safe to perform page writes without a\n+   * {@link PageCursor#shouldRetry() shouldRetry} loop. The {@code shouldRetry} method on write locking cursors\n+   * always returns {@code false}.\n+   * <p>\n+   * This cannot be combined with {@link #PF_SHARED_READ_LOCK}.\n+   */\n+  int PF_SHARED_WRITE_LOCK = 1 << 1;\n+  /**\n+   * Disallow pinning and navigating to pages outside the range of the\n+   * underlying file.\n+   */\n+  int PF_NO_GROW = 1 << 2;\n+  /**\n+   * Read-ahead hint for sequential forward scanning.\n+   */\n+  int PF_READ_AHEAD = 1 << 3; // TBD\n+  /**\n+   * Do not load in the page if it is not loaded already. The methods {@link PageCursor#next()} and\n+   * {@link PageCursor#next(long)} will always return {@code true} for pages that are within the range of the file,\n+   * but the {@link PageCursor#getCurrentPageId()} will return {@link PageCursor#UNBOUND_PAGE_ID} for pages that are\n+   * not in-memory. The current page id <em>must</em> be checked on every {@link PageCursor#shouldRetry()} loop\n+   * iteration, in case it (for a read cursor) was evicted concurrently with the page access.\n+   * <p>\n+   * {@link #PF_NO_FAULT} implies {@link #PF_NO_GROW}, since a page fault is necessary to be able to extend a file.\n+   */\n+  int PF_NO_FAULT = 1 << 4;\n+  /**\n+   * Do not update page access statistics.\n+   */\n+  int PF_TRANSIENT = 1 << 5; // TBD\n+  /**\n+   * Flush pages more aggressively, after they have been dirtied by a write cursor.\n+   */\n+  int PF_EAGER_FLUSH = 1 << 6;\n \n-    /**\n-     * Initiate an IO interaction with the contents of the paged file.\n-     * <p>\n-     * The basic structure of an interaction looks like this:\n-     * <pre><code>\n-     *     try ( PageCursor cursor = pagedFile.io( startingPageId, intentFlags ) )\n-     *     {\n-     *         if ( cursor.next() )\n-     *         {\n-     *             do\n-     *             {\n-     *                 // perform read or write operations on the page\n-     *             }\n-     *             while ( cursor.shouldRetry() );\n-     *         }\n-     *     }\n-     * </code></pre>\n-     * {@link org.neo4j.io.pagecache.PageCursor PageCursors} are {@link AutoCloseable}, so interacting with them\n-     * using <em>try-with-resources</em> is recommended.\n-     * <p>\n-     * The returned PageCursor is initially not bound, so {@link PageCursor#next() next} must be called on it before it\n-     * can be used.\n-     * <p>\n-     * The first {@code next} call will advance the cursor to the initial page, as given by the {@code pageId}\n-     * parameter. Until then, the cursor won't be bound to any page, the {@link PageCursor#getCurrentPageId()} method\n-     * will return the {@link org.neo4j.io.pagecache.PageCursor#UNBOUND_PAGE_ID} constant, and attempts at reading from\n-     * or writing to the cursor will throw a {@link NullPointerException}.\n-     * <p>\n-     * After the {@code next} call, if it returns {@code true}, the cursor will be bound to a page, and the get and put\n-     * methods will access that page.\n-     * <p>\n-     * After a call to {@link PageCursor#rewind()}, the cursor will return to its initial state.\n-     * <p>\n-     * The {@code pf_flags} argument expresses the intent of the IO operation. It is a bitmap that combines various\n-     * {@code PF_*} constants. You must always specify your desired locking behaviour, with either\n-     * {@link org.neo4j.io.pagecache.PagedFile#PF_SHARED_WRITE_LOCK} or\n-     * {@link org.neo4j.io.pagecache.PagedFile#PF_SHARED_READ_LOCK}.\n-     * <p>\n-     * The two locking modes cannot be combined, but other intents can be combined with them. For instance, if you want\n-     * to write to a page, but also make sure that you don't write beyond the end of the file, then you can express\n-     * your intent with {@code PF_SHARED_WRITE_LOCK | PF_NO_GROW} \u2013 note how the flags are combined with a bitwise-OR\n-     * operator.\n-     * Arithmetic addition can also be used, but might not make it as clear that we are dealing with a bit-set.\n-     *\n-     * @param pageId The initial file-page-id, that the cursor will be bound to\n-     * after the first call to <code>next</code>.\n-     * @param pf_flags A bitmap of <code>PF_*</code> constants composed with\n-     * the bitwise-OR operator, that expresses the desired\n-     * locking behaviour, and other hints.\n-     * @return A PageCursor in its initial unbound state.\n-     * Never <code>null</code>.\n-     * @throws IOException if there was an error accessing the underlying file.\n-     */\n-    PageCursor io( long pageId, int pf_flags ) throws IOException;\n+  /**\n+   * Initiate an IO interaction with the contents of the paged file.\n+   * <p>\n+   * The basic structure of an interaction looks like this:\n+   * <pre><code>\n+   *     try ( PageCursor cursor = pagedFile.io( startingPageId, intentFlags ) )\n+   *     {\n+   *         if ( cursor.next() )\n+   *         {\n+   *             do\n+   *             {\n+   *                 // perform read or write operations on the page\n+   *             }\n+   *             while ( cursor.shouldRetry() );\n+   *         }\n+   *     }\n+   * </code></pre>\n+   * {@link org.neo4j.io.pagecache.PageCursor PageCursors} are {@link AutoCloseable}, so interacting with them\n+   * using <em>try-with-resources</em> is recommended.\n+   * <p>\n+   * The returned PageCursor is initially not bound, so {@link PageCursor#next() next} must be called on it before it\n+   * can be used.\n+   * <p>\n+   * The first {@code next} call will advance the cursor to the initial page, as given by the {@code pageId}\n+   * parameter. Until then, the cursor won't be bound to any page, the {@link PageCursor#getCurrentPageId()} method\n+   * will return the {@link org.neo4j.io.pagecache.PageCursor#UNBOUND_PAGE_ID} constant, and attempts at reading from\n+   * or writing to the cursor will throw a {@link NullPointerException}.\n+   * <p>\n+   * After the {@code next} call, if it returns {@code true}, the cursor will be bound to a page, and the get and put\n+   * methods will access that page.\n+   * <p>\n+   * After a call to {@link PageCursor#rewind()}, the cursor will return to its initial state.\n+   * <p>\n+   * The {@code pf_flags} argument expresses the intent of the IO operation. It is a bitmap that combines various\n+   * {@code PF_*} constants. You must always specify your desired locking behaviour, with either\n+   * {@link org.neo4j.io.pagecache.PagedFile#PF_SHARED_WRITE_LOCK} or\n+   * {@link org.neo4j.io.pagecache.PagedFile#PF_SHARED_READ_LOCK}.\n+   * <p>\n+   * The two locking modes cannot be combined, but other intents can be combined with them. For instance, if you want\n+   * to write to a page, but also make sure that you don't write beyond the end of the file, then you can express\n+   * your intent with {@code PF_SHARED_WRITE_LOCK | PF_NO_GROW} \u2013 note how the flags are combined with a bitwise-OR\n+   * operator.\n+   * Arithmetic addition can also be used, but might not make it as clear that we are dealing with a bit-set.\n+   *\n+   * @param pageId   The initial file-page-id, that the cursor will be bound to\n+   *                 after the first call to <code>next</code>.\n+   * @param pf_flags A bitmap of <code>PF_*</code> constants composed with\n+   *                 the bitwise-OR operator, that expresses the desired\n+   *                 locking behaviour, and other hints.\n+   * @return A PageCursor in its initial unbound state.\n+   * Never <code>null</code>.\n+   * @throws IOException if there was an error accessing the underlying file.\n+   */\n+  PageCursor io(long pageId, int pf_flags) throws IOException;\n \n-    /**\n-     * Get the size of the file-pages, in bytes.\n-     */\n-    int pageSize();\n+  /**\n+   * Get the size of the file-pages, in bytes.\n+   */\n+  int pageSize();\n \n-    /**\n-     * Size of file, in bytes.\n-     */\n-    long fileSize() throws IOException;\n+  /**\n+   * Size of file, in bytes.\n+   */\n+  long fileSize() throws IOException;\n \n-    /**\n-     * Get the filename that is mapped by this {@code PagedFile}.\n-     */\n-    File file();\n+  /**\n+   * Get the filename that is mapped by this {@code PagedFile}.\n+   */\n+  File file();\n \n-    /**\n-     * Flush all dirty pages into the file channel, and force the file channel to disk.\n-     */\n-    void flushAndForce() throws IOException;\n+  /**\n+   * Flush all dirty pages into the file channel, and force the file channel to disk.\n+   */\n+  void flushAndForce() throws IOException;\n \n-    /**\n-     * Flush all dirty pages into the file channel, and force the file channel to disk, but limit the rate of IO as\n-     * advised by the given IOPSLimiter.\n-     *\n-     * @param limiter The {@link IOLimiter} that determines if pauses or sleeps should be injected into the flushing\n-     * process to keep the IO rate down.\n-     */\n-    void flushAndForce( IOLimiter limiter ) throws IOException;\n+  /**\n+   * Flush all dirty pages into the file channel, and force the file channel to disk, but limit the rate of IO as\n+   * advised by the given IOPSLimiter.\n+   *\n+   * @param limiter The {@link IOLimiter} that determines if pauses or sleeps should be injected into the flushing\n+   *                process to keep the IO rate down.\n+   */\n+  void flushAndForce(IOLimiter limiter) throws IOException;\n \n-    /**\n-     * Get the file-page-id of the last page in the file.\n-     * <p>\n-     * This will return <em>a negative number</em> (not necessarily -1) if the file is completely empty.\n-     *\n-     * @throws IllegalStateException if this file has been unmapped\n-     */\n-    long getLastPageId() throws IOException;\n+  /**\n+   * Get the file-page-id of the last page in the file.\n+   * <p>\n+   * This will return <em>a negative number</em> (not necessarily -1) if the file is completely empty.\n+   *\n+   * @throws IllegalStateException if this file has been unmapped\n+   */\n+  long getLastPageId() throws IOException;\n \n-    /**\n-     * Release a handle to a paged file.\n-     * <p>\n-     * If this is the last handle to the file, it will be flushed and closed.\n-     * <p>\n-     * Note that this operation assumes that there are no write page cursors open on the paged file. If there are, then\n-     * their writes may be lost, as they might miss the last flush that can happen on their data.\n-     *\n-     * @throws IOException instead of the Exception superclass as defined in AutoCloseable, if .\n-     * @see AutoCloseable#close()\n-     */\n-    @Override\n-    void close() throws IOException;\n+  /**\n+   * Release a handle to a paged file.\n+   * <p>\n+   * If this is the last handle to the file, it will be flushed and closed.\n+   * <p>\n+   * Note that this operation assumes that there are no write page cursors open on the paged file. If there are, then\n+   * their writes may be lost, as they might miss the last flush that can happen on their data.\n+   *\n+   * @throws IOException instead of the Exception superclass as defined in AutoCloseable, if .\n+   * @see AutoCloseable#close()\n+   */\n+  @Override\n+  void close() throws IOException;\n \n-    /**\n-     * Open a {@link ReadableByteChannel} view of this PagedFile.\n-     * <p>\n-     * The channel will read the file sequentially from the beginning till the end.\n-     * Seeking is not supported.\n-     * <p>\n-     * The channel is not thread-safe.\n-     *\n-     * @return A channel for reading the paged file.\n-     */\n-    ReadableByteChannel openReadableByteChannel() throws IOException;\n+  /**\n+   * Open a {@link ReadableByteChannel} view of this PagedFile.\n+   * <p>\n+   * The channel will read the file sequentially from the beginning till the end.\n+   * Seeking is not supported.\n+   * <p>\n+   * The channel is not thread-safe.\n+   *\n+   * @return A channel for reading the paged file.\n+   */\n+  ReadableByteChannel openReadableByteChannel() throws IOException;\n \n-    /**\n-     * Open a {@link WritableByteChannel} view of this PagedFile.\n-     * <p>\n-     * The channel will write to the file sequentially from the beginning of the file, overwriting whatever is there\n-     * already. If the amount of new data is less than the amount of existing data, then the old data will still be\n-     * present at the far end of the file. Thus, this function works neither like opening a file for writing, nor like\n-     * appending to a file.\n-     * <p>\n-     * If this is undesired, then the file can be mapped with {@link java.nio.file.StandardOpenOption#TRUNCATE_EXISTING}\n-     * to remove the existing data before writing to the file.\n-     * <p>\n-     * The channel is not thread-safe.\n-     *\n-     * @return A channel for writing to the paged file.\n-     * @see PageCache#map(File, int, OpenOption...)\n-     */\n-    WritableByteChannel openWritableByteChannel() throws IOException;\n+  /**\n+   * Open a {@link WritableByteChannel} view of this PagedFile.\n+   * <p>\n+   * The channel will write to the file sequentially from the beginning of the file, overwriting whatever is there\n+   * already. If the amount of new data is less than the amount of existing data, then the old data will still be\n+   * present at the far end of the file. Thus, this function works neither like opening a file for writing, nor like\n+   * appending to a file.\n+   * <p>\n+   * If this is undesired, then the file can be mapped with {@link java.nio.file.StandardOpenOption#TRUNCATE_EXISTING}\n+   * to remove the existing data before writing to the file.\n+   * <p>\n+   * The channel is not thread-safe.\n+   *\n+   * @return A channel for writing to the paged file.\n+   * @see PageCache#map(File, int, OpenOption...)\n+   */\n+  WritableByteChannel openWritableByteChannel() throws IOException;\n }\n",
            "diff_size": 181
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "1",
                    "severity": "error",
                    "message": "Missing, wrong or duplicated license header",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/errored/1/2958/PagedFile.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/naturalize/2958/PagedFile.java\nindex 1cce5a11f87..c437944245d 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/errored/1/2958/PagedFile.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/naturalize/2958/PagedFile.java\n@@ -40,7 +40,8 @@ public interface PagedFile extends AutoCloseable\n      * This cannot be combined with {@link #PF_SHARED_WRITE_LOCK}.\n      */\n     int PF_SHARED_READ_LOCK = 1;\n-    /**\n+\n+/**\n      * Pin the pages with a shared write lock.\n      * <p>\n      * This will mark the pages as dirty, and caused them to be flushed, if they are evicted.\n@@ -56,12 +57,14 @@ public interface PagedFile extends AutoCloseable\n      * This cannot be combined with {@link #PF_SHARED_READ_LOCK}.\n      */\n     int PF_SHARED_WRITE_LOCK = 1 << 1;\n-    /**\n+\n+/**\n      * Disallow pinning and navigating to pages outside the range of the\n      * underlying file.\n      */\n     int PF_NO_GROW = 1 << 2;\n-    /**\n+\n+/**\n      * Read-ahead hint for sequential forward scanning.\n      */\n     int PF_READ_AHEAD = 1 << 3; // TBD\n@@ -75,7 +78,8 @@ public interface PagedFile extends AutoCloseable\n      * {@link #PF_NO_FAULT} implies {@link #PF_NO_GROW}, since a page fault is necessary to be able to extend a file.\n      */\n     int PF_NO_FAULT = 1 << 4;\n-    /**\n+\n+/**\n      * Do not update page access statistics.\n      */\n     int PF_TRANSIENT = 1 << 5; // TBD\n@@ -220,4 +224,4 @@ public interface PagedFile extends AutoCloseable\n      * @see PageCache#map(File, int, OpenOption...)\n      */\n     WritableByteChannel openWritableByteChannel() throws IOException;\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 9
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "1",
                    "severity": "error",
                    "message": "Missing, wrong or duplicated license header",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                },
                {
                    "line": "59",
                    "column": "33",
                    "severity": "error",
                    "message": "'<<' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                },
                {
                    "line": "59",
                    "column": "33",
                    "severity": "error",
                    "message": "'<<' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                },
                {
                    "line": "64",
                    "column": "23",
                    "severity": "error",
                    "message": "'<<' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                },
                {
                    "line": "64",
                    "column": "23",
                    "severity": "error",
                    "message": "'<<' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                },
                {
                    "line": "68",
                    "column": "26",
                    "severity": "error",
                    "message": "'<<' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                },
                {
                    "line": "68",
                    "column": "26",
                    "severity": "error",
                    "message": "'<<' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                },
                {
                    "line": "78",
                    "column": "24",
                    "severity": "error",
                    "message": "'<<' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                },
                {
                    "line": "78",
                    "column": "24",
                    "severity": "error",
                    "message": "'<<' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                },
                {
                    "line": "82",
                    "column": "25",
                    "severity": "error",
                    "message": "'<<' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                },
                {
                    "line": "82",
                    "column": "25",
                    "severity": "error",
                    "message": "'<<' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                },
                {
                    "line": "86",
                    "column": "27",
                    "severity": "error",
                    "message": "'<<' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                },
                {
                    "line": "86",
                    "column": "27",
                    "severity": "error",
                    "message": "'<<' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                },
                {
                    "line": "192",
                    "severity": "error",
                    "message": "Annotation 'Override' should be alone on line.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.annotation.AnnotationLocationCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/errored/1/2958/PagedFile.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/codebuff/2958/PagedFile.java\nindex 1cce5a11f87..e0d0c32f200 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/errored/1/2958/PagedFile.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/codebuff/2958/PagedFile.java\n@@ -28,6 +28,7 @@ import java.nio.file.OpenOption;\n /**\n  * The representation of a file that has been mapped into the associated page cache.\n  */\n+\n public interface PagedFile extends AutoCloseable\n {\n     /**\n@@ -55,16 +56,16 @@ public interface PagedFile extends AutoCloseable\n      * <p>\n      * This cannot be combined with {@link #PF_SHARED_READ_LOCK}.\n      */\n-    int PF_SHARED_WRITE_LOCK = 1 << 1;\n+    int PF_SHARED_WRITE_LOCK = 1<<1;\n     /**\n      * Disallow pinning and navigating to pages outside the range of the\n      * underlying file.\n      */\n-    int PF_NO_GROW = 1 << 2;\n+    int PF_NO_GROW = 1<<2;\n     /**\n      * Read-ahead hint for sequential forward scanning.\n      */\n-    int PF_READ_AHEAD = 1 << 3; // TBD\n+    int PF_READ_AHEAD = 1<<3; // TBD\n     /**\n      * Do not load in the page if it is not loaded already. The methods {@link PageCursor#next()} and\n      * {@link PageCursor#next(long)} will always return {@code true} for pages that are within the range of the file,\n@@ -74,15 +75,15 @@ public interface PagedFile extends AutoCloseable\n      * <p>\n      * {@link #PF_NO_FAULT} implies {@link #PF_NO_GROW}, since a page fault is necessary to be able to extend a file.\n      */\n-    int PF_NO_FAULT = 1 << 4;\n+    int PF_NO_FAULT = 1<<4;\n     /**\n      * Do not update page access statistics.\n      */\n-    int PF_TRANSIENT = 1 << 5; // TBD\n+    int PF_TRANSIENT = 1<<5; // TBD\n     /**\n      * Flush pages more aggressively, after they have been dirtied by a write cursor.\n      */\n-    int PF_EAGER_FLUSH = 1 << 6;\n+    int PF_EAGER_FLUSH = 1<<6;\n \n     /**\n      * Initiate an IO interaction with the contents of the paged file.\n@@ -137,27 +138,27 @@ public interface PagedFile extends AutoCloseable\n      * Never <code>null</code>.\n      * @throws IOException if there was an error accessing the underlying file.\n      */\n-    PageCursor io( long pageId, int pf_flags ) throws IOException;\n+    PageCursor io( long pageId, int pf_flags ) throws IOException ;\n \n     /**\n      * Get the size of the file-pages, in bytes.\n      */\n-    int pageSize();\n+    int pageSize()\n+    ;\n \n     /**\n      * Size of file, in bytes.\n-     */\n-    long fileSize() throws IOException;\n+     */ long fileSize() throws IOException ;\n \n     /**\n      * Get the filename that is mapped by this {@code PagedFile}.\n      */\n-    File file();\n+    File file()\n+    ;\n \n     /**\n      * Flush all dirty pages into the file channel, and force the file channel to disk.\n-     */\n-    void flushAndForce() throws IOException;\n+     */ void flushAndForce() throws IOException ;\n \n     /**\n      * Flush all dirty pages into the file channel, and force the file channel to disk, but limit the rate of IO as\n@@ -166,7 +167,7 @@ public interface PagedFile extends AutoCloseable\n      * @param limiter The {@link IOLimiter} that determines if pauses or sleeps should be injected into the flushing\n      * process to keep the IO rate down.\n      */\n-    void flushAndForce( IOLimiter limiter ) throws IOException;\n+    void flushAndForce( IOLimiter limiter ) throws IOException ;\n \n     /**\n      * Get the file-page-id of the last page in the file.\n@@ -175,7 +176,7 @@ public interface PagedFile extends AutoCloseable\n      *\n      * @throws IllegalStateException if this file has been unmapped\n      */\n-    long getLastPageId() throws IOException;\n+    long getLastPageId() throws IOException ;\n \n     /**\n      * Release a handle to a paged file.\n@@ -188,8 +189,7 @@ public interface PagedFile extends AutoCloseable\n      * @throws IOException instead of the Exception superclass as defined in AutoCloseable, if .\n      * @see AutoCloseable#close()\n      */\n-    @Override\n-    void close() throws IOException;\n+    @Override void close() throws IOException ;\n \n     /**\n      * Open a {@link ReadableByteChannel} view of this PagedFile.\n@@ -201,7 +201,7 @@ public interface PagedFile extends AutoCloseable\n      *\n      * @return A channel for reading the paged file.\n      */\n-    ReadableByteChannel openReadableByteChannel() throws IOException;\n+    ReadableByteChannel openReadableByteChannel() throws IOException ;\n \n     /**\n      * Open a {@link WritableByteChannel} view of this PagedFile.\n@@ -219,5 +219,5 @@ public interface PagedFile extends AutoCloseable\n      * @return A channel for writing to the paged file.\n      * @see PageCache#map(File, int, OpenOption...)\n      */\n-    WritableByteChannel openWritableByteChannel() throws IOException;\n-}\n+    WritableByteChannel openWritableByteChannel() throws IOException ;\n+}\n\\ No newline at end of file\n",
            "diff_size": 23
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "1",
                    "severity": "error",
                    "message": "Missing, wrong or duplicated license header",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "1",
                    "severity": "error",
                    "message": "Missing, wrong or duplicated license header",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ],
    "repaired_by": [],
    "not_repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}