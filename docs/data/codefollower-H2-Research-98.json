{
    "project_name": "codefollower-H2-Research",
    "error_id": "98",
    "information": {
        "errors": [
            {
                "line": "299",
                "column": "13",
                "severity": "warning",
                "message": "'{' at column 13 should be on the previous line.",
                "source": "com.puppycrawl.tools.checkstyle.checks.blocks.LeftCurlyCheck"
            }
        ]
    },
    "source_code": "            ArrayList<Column> foundCols = allColumnsSet.get(getTable());\n            if (foundCols != null)\n            {\n                for (Column c : foundCols) {\n                    boolean found = false;\n                    for (Column c2 : columns) {",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/98/BaseIndex.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler/98/BaseIndex.java\nindex 5e504924609..88511007d10 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/98/BaseIndex.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler/98/BaseIndex.java\n@@ -295,8 +295,7 @@ public abstract class BaseIndex extends SchemaObjectBase implements Index {\n         if (!isScanIndex && allColumnsSet != null) {\n             boolean foundAllColumnsWeNeed = true;\n             ArrayList<Column> foundCols = allColumnsSet.get(getTable());\n-            if (foundCols != null)\n-            {\n+            if (foundCols != null) {\n                 for (Column c : foundCols) {\n                     boolean found = false;\n                     for (Column c2 : columns) {\n",
            "diff_size": 2
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/98/BaseIndex.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/98/BaseIndex.java\nindex 5e504924609..508d5445530 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/98/BaseIndex.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/98/BaseIndex.java\n@@ -3,9 +3,11 @@\n  * and the EPL 1.0 (https://h2database.com/html/license.html).\n  * Initial Developer: H2 Group\n  */\n+\n package org.h2.index;\n \n import java.util.ArrayList;\n+\n import org.h2.api.ErrorCode;\n import org.h2.command.dml.AllColumnsForPlan;\n import org.h2.engine.Constants;\n@@ -31,499 +33,497 @@ import org.h2.value.ValueNull;\n  */\n public abstract class BaseIndex extends SchemaObjectBase implements Index {\n \n-    protected IndexColumn[] indexColumns;\n-    protected Column[] columns;\n-    protected int[] columnIds;\n-    protected final Table table;\n-    protected final IndexType indexType;\n-\n-    /**\n-     * Initialize the base index.\n-     *\n-     * @param newTable the table\n-     * @param id the object id\n-     * @param name the index name\n-     * @param newIndexColumns the columns that are indexed or null if this is\n-     *            not yet known\n-     * @param newIndexType the index type\n-     */\n-    protected BaseIndex(Table newTable, int id, String name,\n-            IndexColumn[] newIndexColumns, IndexType newIndexType) {\n-        super(newTable.getSchema(), id, name, Trace.INDEX);\n-        this.indexType = newIndexType;\n-        this.table = newTable;\n-        if (newIndexColumns != null) {\n-            this.indexColumns = newIndexColumns;\n-            columns = new Column[newIndexColumns.length];\n-            int len = columns.length;\n-            columnIds = new int[len];\n-            for (int i = 0; i < len; i++) {\n-                Column col = newIndexColumns[i].column;\n-                columns[i] = col;\n-                columnIds[i] = col.getColumnId();\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Check that the index columns are not CLOB or BLOB.\n-     *\n-     * @param columns the columns\n-     */\n-    protected static void checkIndexColumnTypes(IndexColumn[] columns) {\n-        for (IndexColumn c : columns) {\n-            if (DataType.isLargeObject(c.column.getType().getValueType())) {\n-                throw DbException.getUnsupportedException(\n-                        \"Index on BLOB or CLOB column: \" + c.column.getCreateSQL());\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public String getDropSQL() {\n-        return null;\n-    }\n-\n-    /**\n-     * Create a duplicate key exception with a message that contains the index\n-     * name.\n-     *\n-     * @param key the key values\n-     * @return the exception\n-     */\n-    public DbException getDuplicateKeyException(String key) {\n-        StringBuilder builder = new StringBuilder();\n-        getSQL(builder, false).append(\" ON \");\n-        table.getSQL(builder, false).append('(');\n-        builder.append(getColumnListSQL(false));\n-        builder.append(')');\n-        if (key != null) {\n-            builder.append(\" VALUES \").append(key);\n-        }\n-        DbException e = DbException.get(ErrorCode.DUPLICATE_KEY_1, builder.toString());\n-        e.setSource(this);\n-        return e;\n-    }\n-\n-    /**\n-     * Get \"PRIMARY KEY ON <table> [(column)]\".\n-     *\n-     * @param mainIndexColumn the column index\n-     * @return the message\n-     */\n-    protected StringBuilder getDuplicatePrimaryKeyMessage(int mainIndexColumn) {\n-        StringBuilder builder = new StringBuilder(\"PRIMARY KEY ON \");\n-        table.getSQL(builder, false);\n-        if (mainIndexColumn >= 0 && mainIndexColumn < indexColumns.length) {\n-            builder.append('(');\n-            indexColumns[mainIndexColumn].getSQL(builder, false).append(')');\n-        }\n-        return builder;\n-    }\n-\n-    @Override\n-    public String getPlanSQL() {\n-        return getSQL(false);\n-    }\n-\n-    @Override\n-    public void removeChildrenAndResources(Session session) {\n-        table.removeIndex(this);\n-        remove(session);\n-        database.removeMeta(session, getId());\n-    }\n-\n-    @Override\n-    public boolean canFindNext() {\n-        return false;\n-    }\n-\n-    @Override\n-    public boolean isFindUsingFullTableScan() {\n-        return false;\n-    }\n-\n-    @Override\n-    public Cursor find(TableFilter filter, SearchRow first, SearchRow last) {\n-        return find(filter.getSession(), first, last);\n-    }\n-\n-    /**\n-     * Find a row or a list of rows that is larger and create a cursor to\n-     * iterate over the result. The base implementation doesn't support this\n-     * feature.\n-     *\n-     * @param session the session\n-     * @param higherThan the lower limit (excluding)\n-     * @param last the last row, or null for no limit\n-     * @return the cursor\n-     * @throws DbException always\n-     */\n-    @Override\n-    public Cursor findNext(Session session, SearchRow higherThan, SearchRow last) {\n-        throw DbException.throwInternalError(toString());\n-    }\n-\n-    @Override\n-    public boolean canGetFirstOrLast() {\n-        return false;\n-    }\n-\n-    @Override\n-    public Cursor findFirstOrLast(Session session, boolean first) {\n-        throw DbException.throwInternalError(toString());\n-    }\n-\n-    /**\n-     * Calculate the cost for the given mask as if this index was a typical\n-     * b-tree range index. This is the estimated cost required to search one\n-     * row, and then iterate over the given number of rows.\n-     *\n-     * @param masks the IndexCondition search masks, one for each column in the\n-     *            table\n-     * @param rowCount the number of rows in the index\n-     * @param filters all joined table filters\n-     * @param filter the current table filter index\n-     * @param sortOrder the sort order\n-     * @param isScanIndex whether this is a \"table scan\" index\n-     * @param allColumnsSet the set of all columns\n-     * @return the estimated cost\n-     */\n-    protected final long getCostRangeIndex(int[] masks, long rowCount,\n-            TableFilter[] filters, int filter, SortOrder sortOrder,\n-            boolean isScanIndex, AllColumnsForPlan allColumnsSet) {\n-        rowCount += Constants.COST_ROW_OFFSET;\n-        int totalSelectivity = 0;\n-        long rowsCost = rowCount;\n-        if (masks != null) {\n-            int i = 0, len = columns.length;\n-            boolean tryAdditional = false;\n-            while (i < len) {\n-                Column column = columns[i++];\n-                int index = column.getColumnId();\n-                int mask = masks[index];\n-                if ((mask & IndexCondition.EQUALITY) == IndexCondition.EQUALITY) {\n-                    if (i == len && getIndexType().isUnique()) {\n-                        rowsCost = 3;\n-                        break;\n-                    }\n-                    totalSelectivity = 100 - ((100 - totalSelectivity) *\n-                            (100 - column.getSelectivity()) / 100);\n-                    long distinctRows = rowCount * totalSelectivity / 100;\n-                    if (distinctRows <= 0) {\n-                        distinctRows = 1;\n-                    }\n-                    rowsCost = 2 + Math.max(rowCount / distinctRows, 1);\n-                } else if ((mask & IndexCondition.RANGE) == IndexCondition.RANGE) {\n-                    rowsCost = 2 + rowsCost / 4;\n-                    tryAdditional = true;\n-                    break;\n-                } else if ((mask & IndexCondition.START) == IndexCondition.START) {\n-                    rowsCost = 2 + rowsCost / 3;\n-                    tryAdditional = true;\n-                    break;\n-                } else if ((mask & IndexCondition.END) == IndexCondition.END) {\n-                    rowsCost = rowsCost / 3;\n-                    tryAdditional = true;\n-                    break;\n-                } else {\n-                    if (mask == 0) {\n-                        // Adjust counter of used columns (i)\n-                        i--;\n-                    }\n-                    break;\n-                }\n-            }\n-            // Some additional columns can still be used\n-            if (tryAdditional) {\n-                while (i < len && masks[columns[i].getColumnId()] != 0) {\n-                    i++;\n-                    rowsCost--;\n-                }\n-            }\n-            // Increase cost of indexes with additional unused columns\n-            rowsCost += len - i;\n+  protected IndexColumn[] indexColumns;\n+  protected Column[] columns;\n+  protected int[] columnIds;\n+  protected final Table table;\n+  protected final IndexType indexType;\n+\n+  /**\n+   * Initialize the base index.\n+   *\n+   * @param newTable        the table\n+   * @param id              the object id\n+   * @param name            the index name\n+   * @param newIndexColumns the columns that are indexed or null if this is\n+   *                        not yet known\n+   * @param newIndexType    the index type\n+   */\n+  protected BaseIndex(Table newTable, int id, String name,\n+                      IndexColumn[] newIndexColumns, IndexType newIndexType) {\n+    super(newTable.getSchema(), id, name, Trace.INDEX);\n+    this.indexType = newIndexType;\n+    this.table = newTable;\n+    if (newIndexColumns != null) {\n+      this.indexColumns = newIndexColumns;\n+      columns = new Column[newIndexColumns.length];\n+      int len = columns.length;\n+      columnIds = new int[len];\n+      for (int i = 0; i < len; i++) {\n+        Column col = newIndexColumns[i].column;\n+        columns[i] = col;\n+        columnIds[i] = col.getColumnId();\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Check that the index columns are not CLOB or BLOB.\n+   *\n+   * @param columns the columns\n+   */\n+  protected static void checkIndexColumnTypes(IndexColumn[] columns) {\n+    for (IndexColumn c : columns) {\n+      if (DataType.isLargeObject(c.column.getType().getValueType())) {\n+        throw DbException.getUnsupportedException(\n+            \"Index on BLOB or CLOB column: \" + c.column.getCreateSQL());\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public String getDropSQL() {\n+    return null;\n+  }\n+\n+  /**\n+   * Create a duplicate key exception with a message that contains the index\n+   * name.\n+   *\n+   * @param key the key values\n+   * @return the exception\n+   */\n+  public DbException getDuplicateKeyException(String key) {\n+    StringBuilder builder = new StringBuilder();\n+    getSQL(builder, false).append(\" ON \");\n+    table.getSQL(builder, false).append('(');\n+    builder.append(getColumnListSQL(false));\n+    builder.append(')');\n+    if (key != null) {\n+      builder.append(\" VALUES \").append(key);\n+    }\n+    DbException e = DbException.get(ErrorCode.DUPLICATE_KEY_1, builder.toString());\n+    e.setSource(this);\n+    return e;\n+  }\n+\n+  /**\n+   * Get \"PRIMARY KEY ON <table> [(column)]\".\n+   *\n+   * @param mainIndexColumn the column index\n+   * @return the message\n+   */\n+  protected StringBuilder getDuplicatePrimaryKeyMessage(int mainIndexColumn) {\n+    StringBuilder builder = new StringBuilder(\"PRIMARY KEY ON \");\n+    table.getSQL(builder, false);\n+    if (mainIndexColumn >= 0 && mainIndexColumn < indexColumns.length) {\n+      builder.append('(');\n+      indexColumns[mainIndexColumn].getSQL(builder, false).append(')');\n+    }\n+    return builder;\n+  }\n+\n+  @Override\n+  public String getPlanSQL() {\n+    return getSQL(false);\n+  }\n+\n+  @Override\n+  public void removeChildrenAndResources(Session session) {\n+    table.removeIndex(this);\n+    remove(session);\n+    database.removeMeta(session, getId());\n+  }\n+\n+  @Override\n+  public boolean canFindNext() {\n+    return false;\n+  }\n+\n+  @Override\n+  public boolean isFindUsingFullTableScan() {\n+    return false;\n+  }\n+\n+  @Override\n+  public Cursor find(TableFilter filter, SearchRow first, SearchRow last) {\n+    return find(filter.getSession(), first, last);\n+  }\n+\n+  /**\n+   * Find a row or a list of rows that is larger and create a cursor to\n+   * iterate over the result. The base implementation doesn't support this\n+   * feature.\n+   *\n+   * @param session    the session\n+   * @param higherThan the lower limit (excluding)\n+   * @param last       the last row, or null for no limit\n+   * @return the cursor\n+   * @throws DbException always\n+   */\n+  @Override\n+  public Cursor findNext(Session session, SearchRow higherThan, SearchRow last) {\n+    throw DbException.throwInternalError(toString());\n+  }\n+\n+  @Override\n+  public boolean canGetFirstOrLast() {\n+    return false;\n+  }\n+\n+  @Override\n+  public Cursor findFirstOrLast(Session session, boolean first) {\n+    throw DbException.throwInternalError(toString());\n+  }\n+\n+  /**\n+   * Calculate the cost for the given mask as if this index was a typical\n+   * b-tree range index. This is the estimated cost required to search one\n+   * row, and then iterate over the given number of rows.\n+   *\n+   * @param masks         the IndexCondition search masks, one for each column in the\n+   *                      table\n+   * @param rowCount      the number of rows in the index\n+   * @param filters       all joined table filters\n+   * @param filter        the current table filter index\n+   * @param sortOrder     the sort order\n+   * @param isScanIndex   whether this is a \"table scan\" index\n+   * @param allColumnsSet the set of all columns\n+   * @return the estimated cost\n+   */\n+  protected final long getCostRangeIndex(int[] masks, long rowCount,\n+                                         TableFilter[] filters, int filter, SortOrder sortOrder,\n+                                         boolean isScanIndex, AllColumnsForPlan allColumnsSet) {\n+    rowCount += Constants.COST_ROW_OFFSET;\n+    int totalSelectivity = 0;\n+    long rowsCost = rowCount;\n+    if (masks != null) {\n+      int i = 0, len = columns.length;\n+      boolean tryAdditional = false;\n+      while (i < len) {\n+        Column column = columns[i++];\n+        int index = column.getColumnId();\n+        int mask = masks[index];\n+        if ((mask & IndexCondition.EQUALITY) == IndexCondition.EQUALITY) {\n+          if (i == len && getIndexType().isUnique()) {\n+            rowsCost = 3;\n+            break;\n+          }\n+          totalSelectivity = 100 - ((100 - totalSelectivity) *\n+              (100 - column.getSelectivity()) / 100);\n+          long distinctRows = rowCount * totalSelectivity / 100;\n+          if (distinctRows <= 0) {\n+            distinctRows = 1;\n+          }\n+          rowsCost = 2 + Math.max(rowCount / distinctRows, 1);\n+        } else if ((mask & IndexCondition.RANGE) == IndexCondition.RANGE) {\n+          rowsCost = 2 + rowsCost / 4;\n+          tryAdditional = true;\n+          break;\n+        } else if ((mask & IndexCondition.START) == IndexCondition.START) {\n+          rowsCost = 2 + rowsCost / 3;\n+          tryAdditional = true;\n+          break;\n+        } else if ((mask & IndexCondition.END) == IndexCondition.END) {\n+          rowsCost = rowsCost / 3;\n+          tryAdditional = true;\n+          break;\n+        } else {\n+          if (mask == 0) {\n+            // Adjust counter of used columns (i)\n+            i--;\n+          }\n+          break;\n         }\n-        // If the ORDER BY clause matches the ordering of this index,\n-        // it will be cheaper than another index, so adjust the cost\n-        // accordingly.\n-        long sortingCost = 0;\n-        if (sortOrder != null) {\n-            sortingCost = 100 + rowCount / 10;\n+      }\n+      // Some additional columns can still be used\n+      if (tryAdditional) {\n+        while (i < len && masks[columns[i].getColumnId()] != 0) {\n+          i++;\n+          rowsCost--;\n         }\n-        if (sortOrder != null && !isScanIndex) {\n-            boolean sortOrderMatches = true;\n-            int coveringCount = 0;\n-            int[] sortTypes = sortOrder.getSortTypes();\n-            TableFilter tableFilter = filters == null ? null : filters[filter];\n-            for (int i = 0, len = sortTypes.length; i < len; i++) {\n-                if (i >= indexColumns.length) {\n-                    // We can still use this index if we are sorting by more\n-                    // than it's columns, it's just that the coveringCount\n-                    // is lower than with an index that contains\n-                    // more of the order by columns.\n-                    break;\n-                }\n-                Column col = sortOrder.getColumn(i, tableFilter);\n-                if (col == null) {\n-                    sortOrderMatches = false;\n-                    break;\n-                }\n-                IndexColumn indexCol = indexColumns[i];\n-                if (!col.equals(indexCol.column)) {\n-                    sortOrderMatches = false;\n-                    break;\n-                }\n-                int sortType = sortTypes[i];\n-                if (sortType != indexCol.sortType) {\n-                    sortOrderMatches = false;\n-                    break;\n-                }\n-                coveringCount++;\n-            }\n-            if (sortOrderMatches) {\n-                // \"coveringCount\" makes sure that when we have two\n-                // or more covering indexes, we choose the one\n-                // that covers more.\n-                sortingCost = 100 - coveringCount;\n-            }\n+      }\n+      // Increase cost of indexes with additional unused columns\n+      rowsCost += len - i;\n+    }\n+    // If the ORDER BY clause matches the ordering of this index,\n+    // it will be cheaper than another index, so adjust the cost\n+    // accordingly.\n+    long sortingCost = 0;\n+    if (sortOrder != null) {\n+      sortingCost = 100 + rowCount / 10;\n+    }\n+    if (sortOrder != null && !isScanIndex) {\n+      boolean sortOrderMatches = true;\n+      int coveringCount = 0;\n+      int[] sortTypes = sortOrder.getSortTypes();\n+      TableFilter tableFilter = filters == null ? null : filters[filter];\n+      for (int i = 0, len = sortTypes.length; i < len; i++) {\n+        if (i >= indexColumns.length) {\n+          // We can still use this index if we are sorting by more\n+          // than it's columns, it's just that the coveringCount\n+          // is lower than with an index that contains\n+          // more of the order by columns.\n+          break;\n         }\n-        // If we have two indexes with the same cost, and one of the indexes can\n-        // satisfy the query without needing to read from the primary table\n-        // (scan index), make that one slightly lower cost.\n-        boolean needsToReadFromScanIndex = true;\n-        if (!isScanIndex && allColumnsSet != null) {\n-            boolean foundAllColumnsWeNeed = true;\n-            ArrayList<Column> foundCols = allColumnsSet.get(getTable());\n-            if (foundCols != null)\n-            {\n-                for (Column c : foundCols) {\n-                    boolean found = false;\n-                    for (Column c2 : columns) {\n-                        if (c == c2) {\n-                            found = true;\n-                            break;\n-                        }\n-                    }\n-                    if (!found) {\n-                        foundAllColumnsWeNeed = false;\n-                        break;\n-                    }\n-                }\n-            }\n-            if (foundAllColumnsWeNeed) {\n-                needsToReadFromScanIndex = false;\n-            }\n+        Column col = sortOrder.getColumn(i, tableFilter);\n+        if (col == null) {\n+          sortOrderMatches = false;\n+          break;\n         }\n-        long rc;\n-        if (isScanIndex) {\n-            rc = rowsCost + sortingCost + 20;\n-        } else if (needsToReadFromScanIndex) {\n-            rc = rowsCost + rowsCost + sortingCost + 20;\n-        } else {\n-            // The (20-x) calculation makes sure that when we pick a covering\n-            // index, we pick the covering index that has the smallest number of\n-            // columns (the more columns we have in index - the higher cost).\n-            // This is faster because a smaller index will fit into fewer data\n-            // blocks.\n-            rc = rowsCost + sortingCost + columns.length;\n+        IndexColumn indexCol = indexColumns[i];\n+        if (!col.equals(indexCol.column)) {\n+          sortOrderMatches = false;\n+          break;\n         }\n-        return rc;\n-    }\n-\n-    @Override\n-    public int compareRows(SearchRow rowData, SearchRow compare) {\n-        if (rowData == compare) {\n-            return 0;\n+        int sortType = sortTypes[i];\n+        if (sortType != indexCol.sortType) {\n+          sortOrderMatches = false;\n+          break;\n         }\n-        for (int i = 0, len = indexColumns.length; i < len; i++) {\n-            int index = columnIds[i];\n-            Value v1 = rowData.getValue(index);\n-            Value v2 = compare.getValue(index);\n-            if (v1 == null || v2 == null) {\n-                // can't compare further\n-                return 0;\n-            }\n-            int c = compareValues(v1, v2, indexColumns[i].sortType);\n-            if (c != 0) {\n-                return c;\n+        coveringCount++;\n+      }\n+      if (sortOrderMatches) {\n+        // \"coveringCount\" makes sure that when we have two\n+        // or more covering indexes, we choose the one\n+        // that covers more.\n+        sortingCost = 100 - coveringCount;\n+      }\n+    }\n+    // If we have two indexes with the same cost, and one of the indexes can\n+    // satisfy the query without needing to read from the primary table\n+    // (scan index), make that one slightly lower cost.\n+    boolean needsToReadFromScanIndex = true;\n+    if (!isScanIndex && allColumnsSet != null) {\n+      boolean foundAllColumnsWeNeed = true;\n+      ArrayList<Column> foundCols = allColumnsSet.get(getTable());\n+      if (foundCols != null) {\n+        for (Column c : foundCols) {\n+          boolean found = false;\n+          for (Column c2 : columns) {\n+            if (c == c2) {\n+              found = true;\n+              break;\n             }\n+          }\n+          if (!found) {\n+            foundAllColumnsWeNeed = false;\n+            break;\n+          }\n         }\n+      }\n+      if (foundAllColumnsWeNeed) {\n+        needsToReadFromScanIndex = false;\n+      }\n+    }\n+    long rc;\n+    if (isScanIndex) {\n+      rc = rowsCost + sortingCost + 20;\n+    } else if (needsToReadFromScanIndex) {\n+      rc = rowsCost + rowsCost + sortingCost + 20;\n+    } else {\n+      // The (20-x) calculation makes sure that when we pick a covering\n+      // index, we pick the covering index that has the smallest number of\n+      // columns (the more columns we have in index - the higher cost).\n+      // This is faster because a smaller index will fit into fewer data\n+      // blocks.\n+      rc = rowsCost + sortingCost + columns.length;\n+    }\n+    return rc;\n+  }\n+\n+  @Override\n+  public int compareRows(SearchRow rowData, SearchRow compare) {\n+    if (rowData == compare) {\n+      return 0;\n+    }\n+    for (int i = 0, len = indexColumns.length; i < len; i++) {\n+      int index = columnIds[i];\n+      Value v1 = rowData.getValue(index);\n+      Value v2 = compare.getValue(index);\n+      if (v1 == null || v2 == null) {\n+        // can't compare further\n         return 0;\n-    }\n-\n-    /**\n-     * Check if this row may have duplicates with the same indexed values in the\n-     * current compatibility mode. Duplicates with {@code NULL} values are\n-     * allowed in some modes.\n-     *\n-     * @param searchRow\n-     *            the row to check\n-     * @return {@code true} if specified row may have duplicates,\n-     *         {@code false otherwise}\n-     */\n-    public boolean mayHaveNullDuplicates(SearchRow searchRow) {\n-        switch (database.getMode().uniqueIndexNullsHandling) {\n-        case ALLOW_DUPLICATES_WITH_ANY_NULL:\n-            for (int index : columnIds) {\n-                if (searchRow.getValue(index) == ValueNull.INSTANCE) {\n-                    return true;\n-                }\n-            }\n-            return false;\n-        case ALLOW_DUPLICATES_WITH_ALL_NULLS:\n-            for (int index : columnIds) {\n-                if (searchRow.getValue(index) != ValueNull.INSTANCE) {\n-                    return false;\n-                }\n-            }\n+      }\n+      int c = compareValues(v1, v2, indexColumns[i].sortType);\n+      if (c != 0) {\n+        return c;\n+      }\n+    }\n+    return 0;\n+  }\n+\n+  /**\n+   * Check if this row may have duplicates with the same indexed values in the\n+   * current compatibility mode. Duplicates with {@code NULL} values are\n+   * allowed in some modes.\n+   *\n+   * @param searchRow the row to check\n+   * @return {@code true} if specified row may have duplicates,\n+   * {@code false otherwise}\n+   */\n+  public boolean mayHaveNullDuplicates(SearchRow searchRow) {\n+    switch (database.getMode().uniqueIndexNullsHandling) {\n+      case ALLOW_DUPLICATES_WITH_ANY_NULL:\n+        for (int index : columnIds) {\n+          if (searchRow.getValue(index) == ValueNull.INSTANCE) {\n             return true;\n-        default:\n-            return false;\n-        }\n-    }\n-\n-    /**\n-     * Compare the positions of two rows.\n-     *\n-     * @param rowData the first row\n-     * @param compare the second row\n-     * @return 0 if both rows are equal, -1 if the first row is smaller,\n-     *         otherwise 1\n-     */\n-    public int compareKeys(SearchRow rowData, SearchRow compare) {\n-        long k1 = rowData.getKey();\n-        long k2 = compare.getKey();\n-        if (k1 == k2) {\n-            return 0;\n-        }\n-        return k1 > k2 ? 1 : -1;\n-    }\n-\n-    private int compareValues(Value a, Value b, int sortType) {\n-        if (a == b) {\n-            return 0;\n-        }\n-        boolean aNull = a == ValueNull.INSTANCE;\n-        boolean bNull = b == ValueNull.INSTANCE;\n-        if (aNull || bNull) {\n-            return SortOrder.compareNull(aNull, sortType);\n-        }\n-        int comp = table.compareValues(a, b);\n-        if ((sortType & SortOrder.DESCENDING) != 0) {\n-            comp = -comp;\n-        }\n-        return comp;\n-    }\n-\n-    @Override\n-    public int getColumnIndex(Column col) {\n-        for (int i = 0, len = columns.length; i < len; i++) {\n-            if (columns[i].equals(col)) {\n-                return i;\n-            }\n+          }\n         }\n-        return -1;\n-    }\n-\n-    @Override\n-    public boolean isFirstColumn(Column column) {\n-        return column.equals(columns[0]);\n-    }\n-\n-    /**\n-     * Get the list of columns as a string.\n-     *\n-     * @param alwaysQuote quote all identifiers\n-     * @return the list of columns\n-     */\n-    private String getColumnListSQL(boolean alwaysQuote) {\n-        return IndexColumn.writeColumns(new StringBuilder(), indexColumns, alwaysQuote).toString();\n-    }\n-\n-    @Override\n-    public String getCreateSQLForCopy(Table targetTable, String quotedName) {\n-        StringBuilder buff = new StringBuilder(\"CREATE \");\n-        buff.append(indexType.getSQL());\n-        buff.append(' ');\n-        if (table.isHidden()) {\n-            buff.append(\"IF NOT EXISTS \");\n-        }\n-        buff.append(quotedName);\n-        buff.append(\" ON \");\n-        targetTable.getSQL(buff, true);\n-        if (comment != null) {\n-            buff.append(\" COMMENT \");\n-            StringUtils.quoteStringSQL(buff, comment);\n-        }\n-        buff.append('(').append(getColumnListSQL(true)).append(')');\n-        return buff.toString();\n-    }\n-\n-    @Override\n-    public String getCreateSQL() {\n-        return getCreateSQLForCopy(table, getSQL(true));\n-    }\n-\n-    @Override\n-    public IndexColumn[] getIndexColumns() {\n-        return indexColumns;\n-    }\n-\n-    @Override\n-    public Column[] getColumns() {\n-        return columns;\n-    }\n-\n-    @Override\n-    public IndexType getIndexType() {\n-        return indexType;\n-    }\n-\n-    @Override\n-    public int getType() {\n-        return DbObject.INDEX;\n-    }\n-\n-    @Override\n-    public Table getTable() {\n-        return table;\n-    }\n-\n-    @Override\n-    public Row getRow(Session session, long key) {\n-        throw DbException.getUnsupportedException(toString());\n-    }\n-\n-    @Override\n-    public boolean isHidden() {\n-        return table.isHidden();\n-    }\n-\n-    @Override\n-    public boolean isRowIdIndex() {\n         return false;\n-    }\n-\n-    @Override\n-    public boolean canScan() {\n+      case ALLOW_DUPLICATES_WITH_ALL_NULLS:\n+        for (int index : columnIds) {\n+          if (searchRow.getValue(index) != ValueNull.INSTANCE) {\n+            return false;\n+          }\n+        }\n         return true;\n+      default:\n+        return false;\n     }\n-\n-    @Override\n-    public void setSortedInsertMode(boolean sortedInsertMode) {\n-        // ignore\n-    }\n-\n-    @Override\n-    public IndexLookupBatch createLookupBatch(TableFilter[] filters, int filter) {\n-        // Lookup batching is not supported.\n-        return null;\n-    }\n-\n-    @Override\n-    public void update(Session session, Row oldRow, Row newRow) {\n-        remove(session, oldRow);\n-        add(session, newRow);\n-    }\n+  }\n+\n+  /**\n+   * Compare the positions of two rows.\n+   *\n+   * @param rowData the first row\n+   * @param compare the second row\n+   * @return 0 if both rows are equal, -1 if the first row is smaller,\n+   * otherwise 1\n+   */\n+  public int compareKeys(SearchRow rowData, SearchRow compare) {\n+    long k1 = rowData.getKey();\n+    long k2 = compare.getKey();\n+    if (k1 == k2) {\n+      return 0;\n+    }\n+    return k1 > k2 ? 1 : -1;\n+  }\n+\n+  private int compareValues(Value a, Value b, int sortType) {\n+    if (a == b) {\n+      return 0;\n+    }\n+    boolean aNull = a == ValueNull.INSTANCE;\n+    boolean bNull = b == ValueNull.INSTANCE;\n+    if (aNull || bNull) {\n+      return SortOrder.compareNull(aNull, sortType);\n+    }\n+    int comp = table.compareValues(a, b);\n+    if ((sortType & SortOrder.DESCENDING) != 0) {\n+      comp = -comp;\n+    }\n+    return comp;\n+  }\n+\n+  @Override\n+  public int getColumnIndex(Column col) {\n+    for (int i = 0, len = columns.length; i < len; i++) {\n+      if (columns[i].equals(col)) {\n+        return i;\n+      }\n+    }\n+    return -1;\n+  }\n+\n+  @Override\n+  public boolean isFirstColumn(Column column) {\n+    return column.equals(columns[0]);\n+  }\n+\n+  /**\n+   * Get the list of columns as a string.\n+   *\n+   * @param alwaysQuote quote all identifiers\n+   * @return the list of columns\n+   */\n+  private String getColumnListSQL(boolean alwaysQuote) {\n+    return IndexColumn.writeColumns(new StringBuilder(), indexColumns, alwaysQuote).toString();\n+  }\n+\n+  @Override\n+  public String getCreateSQLForCopy(Table targetTable, String quotedName) {\n+    StringBuilder buff = new StringBuilder(\"CREATE \");\n+    buff.append(indexType.getSQL());\n+    buff.append(' ');\n+    if (table.isHidden()) {\n+      buff.append(\"IF NOT EXISTS \");\n+    }\n+    buff.append(quotedName);\n+    buff.append(\" ON \");\n+    targetTable.getSQL(buff, true);\n+    if (comment != null) {\n+      buff.append(\" COMMENT \");\n+      StringUtils.quoteStringSQL(buff, comment);\n+    }\n+    buff.append('(').append(getColumnListSQL(true)).append(')');\n+    return buff.toString();\n+  }\n+\n+  @Override\n+  public String getCreateSQL() {\n+    return getCreateSQLForCopy(table, getSQL(true));\n+  }\n+\n+  @Override\n+  public IndexColumn[] getIndexColumns() {\n+    return indexColumns;\n+  }\n+\n+  @Override\n+  public Column[] getColumns() {\n+    return columns;\n+  }\n+\n+  @Override\n+  public IndexType getIndexType() {\n+    return indexType;\n+  }\n+\n+  @Override\n+  public int getType() {\n+    return DbObject.INDEX;\n+  }\n+\n+  @Override\n+  public Table getTable() {\n+    return table;\n+  }\n+\n+  @Override\n+  public Row getRow(Session session, long key) {\n+    throw DbException.getUnsupportedException(toString());\n+  }\n+\n+  @Override\n+  public boolean isHidden() {\n+    return table.isHidden();\n+  }\n+\n+  @Override\n+  public boolean isRowIdIndex() {\n+    return false;\n+  }\n+\n+  @Override\n+  public boolean canScan() {\n+    return true;\n+  }\n+\n+  @Override\n+  public void setSortedInsertMode(boolean sortedInsertMode) {\n+    // ignore\n+  }\n+\n+  @Override\n+  public IndexLookupBatch createLookupBatch(TableFilter[] filters, int filter) {\n+    // Lookup batching is not supported.\n+    return null;\n+  }\n+\n+  @Override\n+  public void update(Session session, Row oldRow, Row newRow) {\n+    remove(session, oldRow);\n+    add(session, newRow);\n+  }\n }\n",
            "diff_size": 664
        },
        {
            "tool": "naturalize",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/98/BaseIndex.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/naturalize/98/BaseIndex.java\nindex 5e504924609..774e8e6897d 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/98/BaseIndex.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/naturalize/98/BaseIndex.java\n@@ -295,8 +295,7 @@ public abstract class BaseIndex extends SchemaObjectBase implements Index {\n         if (!isScanIndex && allColumnsSet != null) {\n             boolean foundAllColumnsWeNeed = true;\n             ArrayList<Column> foundCols = allColumnsSet.get(getTable());\n-            if (foundCols != null)\n-            {\n+            if (foundCols != null) {\n                 for (Column c : foundCols) {\n                     boolean found = false;\n                     for (Column c2 : columns) {\n@@ -526,4 +525,4 @@ public abstract class BaseIndex extends SchemaObjectBase implements Index {\n         remove(session, oldRow);\n         add(session, newRow);\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 3
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/98/BaseIndex.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/codebuff/98/BaseIndex.java\nindex 5e504924609..c9a92890548 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/98/BaseIndex.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/codebuff/98/BaseIndex.java\n@@ -29,12 +29,23 @@ import org.h2.value.ValueNull;\n /**\n  * Most index implementations extend the base index.\n  */\n+\n+\n public abstract class BaseIndex extends SchemaObjectBase implements Index {\n \n+\n     protected IndexColumn[] indexColumns;\n+\n+\n     protected Column[] columns;\n+\n+\n     protected int[] columnIds;\n+\n+\n     protected final Table table;\n+\n+\n     protected final IndexType indexType;\n \n     /**\n@@ -47,8 +58,8 @@ public abstract class BaseIndex extends SchemaObjectBase implements Index {\n      *            not yet known\n      * @param newIndexType the index type\n      */\n-    protected BaseIndex(Table newTable, int id, String name,\n-            IndexColumn[] newIndexColumns, IndexType newIndexType) {\n+\n+    protected BaseIndex(Table newTable, int id, String name, IndexColumn[] newIndexColumns, IndexType newIndexType) {\n         super(newTable.getSchema(), id, name, Trace.INDEX);\n         this.indexType = newIndexType;\n         this.table = newTable;\n@@ -70,11 +81,12 @@ public abstract class BaseIndex extends SchemaObjectBase implements Index {\n      *\n      * @param columns the columns\n      */\n+\n+\n     protected static void checkIndexColumnTypes(IndexColumn[] columns) {\n         for (IndexColumn c : columns) {\n             if (DataType.isLargeObject(c.column.getType().getValueType())) {\n-                throw DbException.getUnsupportedException(\n-                        \"Index on BLOB or CLOB column: \" + c.column.getCreateSQL());\n+                throw DbException.getUnsupportedException(\"Index on BLOB or CLOB column: \" + c.column.getCreateSQL());\n             }\n         }\n     }\n@@ -91,6 +103,8 @@ public abstract class BaseIndex extends SchemaObjectBase implements Index {\n      * @param key the key values\n      * @return the exception\n      */\n+\n+\n     public DbException getDuplicateKeyException(String key) {\n         StringBuilder builder = new StringBuilder();\n         getSQL(builder, false).append(\" ON \");\n@@ -111,6 +125,8 @@ public abstract class BaseIndex extends SchemaObjectBase implements Index {\n      * @param mainIndexColumn the column index\n      * @return the message\n      */\n+\n+\n     protected StringBuilder getDuplicatePrimaryKeyMessage(int mainIndexColumn) {\n         StringBuilder builder = new StringBuilder(\"PRIMARY KEY ON \");\n         table.getSQL(builder, false);\n@@ -159,6 +175,7 @@ public abstract class BaseIndex extends SchemaObjectBase implements Index {\n      * @return the cursor\n      * @throws DbException always\n      */\n+\n     @Override\n     public Cursor findNext(Session session, SearchRow higherThan, SearchRow last) {\n         throw DbException.throwInternalError(toString());\n@@ -189,9 +206,9 @@ public abstract class BaseIndex extends SchemaObjectBase implements Index {\n      * @param allColumnsSet the set of all columns\n      * @return the estimated cost\n      */\n-    protected final long getCostRangeIndex(int[] masks, long rowCount,\n-            TableFilter[] filters, int filter, SortOrder sortOrder,\n-            boolean isScanIndex, AllColumnsForPlan allColumnsSet) {\n+\n+\n+    protected final long getCostRangeIndex(int[] masks, long rowCount, TableFilter[] filters, int filter, SortOrder sortOrder, boolean isScanIndex, AllColumnsForPlan allColumnsSet) {\n         rowCount += Constants.COST_ROW_OFFSET;\n         int totalSelectivity = 0;\n         long rowsCost = rowCount;\n@@ -207,8 +224,7 @@ public abstract class BaseIndex extends SchemaObjectBase implements Index {\n                         rowsCost = 3;\n                         break;\n                     }\n-                    totalSelectivity = 100 - ((100 - totalSelectivity) *\n-                            (100 - column.getSelectivity()) / 100);\n+                    totalSelectivity = 100 - ((100 - totalSelectivity) * (100 - column.getSelectivity()) / 100);\n                     long distinctRows = rowCount * totalSelectivity / 100;\n                     if (distinctRows <= 0) {\n                         distinctRows = 1;\n@@ -218,21 +234,21 @@ public abstract class BaseIndex extends SchemaObjectBase implements Index {\n                     rowsCost = 2 + rowsCost / 4;\n                     tryAdditional = true;\n                     break;\n-                } else if ((mask & IndexCondition.START) == IndexCondition.START) {\n-                    rowsCost = 2 + rowsCost / 3;\n-                    tryAdditional = true;\n-                    break;\n+                            } else if ((mask & IndexCondition.START) == IndexCondition.START) {\n+                           rowsCost = 2 + rowsCost / 3;\n+                           tryAdditional = true;\n+                           break;\n                 } else if ((mask & IndexCondition.END) == IndexCondition.END) {\n-                    rowsCost = rowsCost / 3;\n-                    tryAdditional = true;\n-                    break;\n+                                       rowsCost = rowsCost / 3;\n+                                       tryAdditional = true;\n+                                       break;\n                 } else {\n-                    if (mask == 0) {\n+                                       if (mask == 0) {\n                         // Adjust counter of used columns (i)\n-                        i--;\n-                    }\n-                    break;\n-                }\n+                                           i--;\n+                                       }\n+                                       break;\n+                                   }\n             }\n             // Some additional columns can still be used\n             if (tryAdditional) {\n@@ -295,8 +311,7 @@ public abstract class BaseIndex extends SchemaObjectBase implements Index {\n         if (!isScanIndex && allColumnsSet != null) {\n             boolean foundAllColumnsWeNeed = true;\n             ArrayList<Column> foundCols = allColumnsSet.get(getTable());\n-            if (foundCols != null)\n-            {\n+            if (foundCols != null) {\n                 for (Column c : foundCols) {\n                     boolean found = false;\n                     for (Column c2 : columns) {\n@@ -320,7 +335,7 @@ public abstract class BaseIndex extends SchemaObjectBase implements Index {\n             rc = rowsCost + sortingCost + 20;\n         } else if (needsToReadFromScanIndex) {\n             rc = rowsCost + rowsCost + sortingCost + 20;\n-        } else {\n+                                                                                                                                                                                     } else {\n             // The (20-x) calculation makes sure that when we pick a covering\n             // index, we pick the covering index that has the smallest number of\n             // columns (the more columns we have in index - the higher cost).\n@@ -362,6 +377,8 @@ public abstract class BaseIndex extends SchemaObjectBase implements Index {\n      * @return {@code true} if specified row may have duplicates,\n      *         {@code false otherwise}\n      */\n+\n+\n     public boolean mayHaveNullDuplicates(SearchRow searchRow) {\n         switch (database.getMode().uniqueIndexNullsHandling) {\n         case ALLOW_DUPLICATES_WITH_ANY_NULL:\n@@ -391,6 +408,8 @@ public abstract class BaseIndex extends SchemaObjectBase implements Index {\n      * @return 0 if both rows are equal, -1 if the first row is smaller,\n      *         otherwise 1\n      */\n+\n+\n     public int compareKeys(SearchRow rowData, SearchRow compare) {\n         long k1 = rowData.getKey();\n         long k2 = compare.getKey();\n@@ -437,6 +456,7 @@ public abstract class BaseIndex extends SchemaObjectBase implements Index {\n      * @param alwaysQuote quote all identifiers\n      * @return the list of columns\n      */\n+\n     private String getColumnListSQL(boolean alwaysQuote) {\n         return IndexColumn.writeColumns(new StringBuilder(), indexColumns, alwaysQuote).toString();\n     }\n@@ -513,6 +533,7 @@ public abstract class BaseIndex extends SchemaObjectBase implements Index {\n     @Override\n     public void setSortedInsertMode(boolean sortedInsertMode) {\n         // ignore\n+\n     }\n \n     @Override\n@@ -526,4 +547,5 @@ public abstract class BaseIndex extends SchemaObjectBase implements Index {\n         remove(session, oldRow);\n         add(session, newRow);\n     }\n-}\n+\n+}\n\\ No newline at end of file\n",
            "diff_size": 50
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/98/BaseIndex.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_random/98/BaseIndex.java\nindex 5e504924609..88511007d10 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/98/BaseIndex.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_random/98/BaseIndex.java\n@@ -295,8 +295,7 @@ public abstract class BaseIndex extends SchemaObjectBase implements Index {\n         if (!isScanIndex && allColumnsSet != null) {\n             boolean foundAllColumnsWeNeed = true;\n             ArrayList<Column> foundCols = allColumnsSet.get(getTable());\n-            if (foundCols != null)\n-            {\n+            if (foundCols != null) {\n                 for (Column c : foundCols) {\n                     boolean found = false;\n                     for (Column c2 : columns) {\n",
            "diff_size": 2
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/98/BaseIndex.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/98/BaseIndex.java\nindex 5e504924609..88511007d10 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/98/BaseIndex.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/98/BaseIndex.java\n@@ -295,8 +295,7 @@ public abstract class BaseIndex extends SchemaObjectBase implements Index {\n         if (!isScanIndex && allColumnsSet != null) {\n             boolean foundAllColumnsWeNeed = true;\n             ArrayList<Column> foundCols = allColumnsSet.get(getTable());\n-            if (foundCols != null)\n-            {\n+            if (foundCols != null) {\n                 for (Column c : foundCols) {\n                     boolean found = false;\n                     for (Column c2 : columns) {\n",
            "diff_size": 2
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": []
}