{
    "project_name": "codefollower-H2-Research",
    "error_id": "397",
    "information": {
        "errors": [
            {
                "line": "420",
                "column": "67",
                "severity": "warning",
                "message": "Don't use trailing comments.",
                "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
            }
        ]
    },
    "source_code": "            writeLong(ts.getTimeNanos());\n            int timeZoneOffset = ts.getTimeZoneOffsetSeconds();\n            writeInt(version >= Constants.TCP_PROTOCOL_VERSION_19 //\n                    ? timeZoneOffset : timeZoneOffset / 60);\n            break;\n        }",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/397/Transfer.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler/397/Transfer.java\nindex e39a7d9092e..35d2922ccdd 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/397/Transfer.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler/397/Transfer.java\n@@ -417,8 +417,9 @@ public class Transfer {\n             writeLong(ts.getDateValue());\n             writeLong(ts.getTimeNanos());\n             int timeZoneOffset = ts.getTimeZoneOffsetSeconds();\n-            writeInt(version >= Constants.TCP_PROTOCOL_VERSION_19 //\n-                    ? timeZoneOffset : timeZoneOffset / 60);\n+            writeInt(version >= Constants.TCP_PROTOCOL_VERSION_19\n+                    //\n+                     ? timeZoneOffset : timeZoneOffset / 60);\n             break;\n         }\n         case Value.DECIMAL:\n",
            "diff_size": 3
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "422",
                    "column": "63",
                    "severity": "warning",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/397/Transfer.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/397/Transfer.java\nindex e39a7d9092e..3f8ca353a6e 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/397/Transfer.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/397/Transfer.java\n@@ -3,6 +3,7 @@\n  * and the EPL 1.0 (https://h2database.com/html/license.html).\n  * Initial Developer: H2 Group\n  */\n+\n package org.h2.value;\n \n import java.io.BufferedInputStream;\n@@ -14,6 +15,7 @@ import java.io.Reader;\n import java.math.BigDecimal;\n import java.net.InetAddress;\n import java.net.Socket;\n+\n import org.h2.api.ErrorCode;\n import org.h2.api.IntervalQualifier;\n import org.h2.engine.CastDataProvider;\n@@ -41,859 +43,859 @@ import org.h2.util.Utils;\n  */\n public class Transfer {\n \n-    private static final int BUFFER_SIZE = 64 * 1024;\n-    private static final int LOB_MAGIC = 0x1234;\n-    private static final int LOB_MAC_SALT_LENGTH = 16;\n-\n-    private static final int NULL = 0;\n-    private static final int BOOLEAN = 1;\n-    private static final int BYTE = 2;\n-    private static final int SHORT = 3;\n-    private static final int INT = 4;\n-    private static final int LONG = 5;\n-    private static final int DECIMAL = 6;\n-    private static final int DOUBLE = 7;\n-    private static final int FLOAT = 8;\n-    private static final int TIME = 9;\n-    private static final int DATE = 10;\n-    private static final int TIMESTAMP = 11;\n-    private static final int BYTES = 12;\n-    private static final int STRING = 13;\n-    private static final int STRING_IGNORECASE = 14;\n-    private static final int BLOB = 15;\n-    private static final int CLOB = 16;\n-    private static final int ARRAY = 17;\n-    private static final int RESULT_SET = 18;\n-    private static final int JAVA_OBJECT = 19;\n-    private static final int UUID = 20;\n-    private static final int STRING_FIXED = 21;\n-    private static final int GEOMETRY = 22;\n-    private static final int TIMESTAMP_TZ = 24;\n-    private static final int ENUM = 25;\n-    private static final int INTERVAL = 26;\n-    private static final int ROW = 27;\n-    private static final int JSON = 28;\n-    private static final int TIME_TZ = 29;\n-\n-    private Socket socket;\n-    private DataInputStream in;\n-    private DataOutputStream out;\n-    private SessionInterface session;\n-    private boolean ssl;\n-    private int version;\n-    private byte[] lobMacSalt;\n-\n-    /**\n-     * Create a new transfer object for the specified session.\n-     *\n-     * @param session the session\n-     * @param s the socket\n-     */\n-    public Transfer(SessionInterface session, Socket s) {\n-        this.session = session;\n-        this.socket = s;\n-    }\n-\n-    /**\n-     * Initialize the transfer object. This method will try to open an input and\n-     * output stream.\n-     */\n-    public synchronized void init() throws IOException {\n+  private static final int BUFFER_SIZE = 64 * 1024;\n+  private static final int LOB_MAGIC = 0x1234;\n+  private static final int LOB_MAC_SALT_LENGTH = 16;\n+\n+  private static final int NULL = 0;\n+  private static final int BOOLEAN = 1;\n+  private static final int BYTE = 2;\n+  private static final int SHORT = 3;\n+  private static final int INT = 4;\n+  private static final int LONG = 5;\n+  private static final int DECIMAL = 6;\n+  private static final int DOUBLE = 7;\n+  private static final int FLOAT = 8;\n+  private static final int TIME = 9;\n+  private static final int DATE = 10;\n+  private static final int TIMESTAMP = 11;\n+  private static final int BYTES = 12;\n+  private static final int STRING = 13;\n+  private static final int STRING_IGNORECASE = 14;\n+  private static final int BLOB = 15;\n+  private static final int CLOB = 16;\n+  private static final int ARRAY = 17;\n+  private static final int RESULT_SET = 18;\n+  private static final int JAVA_OBJECT = 19;\n+  private static final int UUID = 20;\n+  private static final int STRING_FIXED = 21;\n+  private static final int GEOMETRY = 22;\n+  private static final int TIMESTAMP_TZ = 24;\n+  private static final int ENUM = 25;\n+  private static final int INTERVAL = 26;\n+  private static final int ROW = 27;\n+  private static final int JSON = 28;\n+  private static final int TIME_TZ = 29;\n+\n+  private Socket socket;\n+  private DataInputStream in;\n+  private DataOutputStream out;\n+  private SessionInterface session;\n+  private boolean ssl;\n+  private int version;\n+  private byte[] lobMacSalt;\n+\n+  /**\n+   * Create a new transfer object for the specified session.\n+   *\n+   * @param session the session\n+   * @param s       the socket\n+   */\n+  public Transfer(SessionInterface session, Socket s) {\n+    this.session = session;\n+    this.socket = s;\n+  }\n+\n+  /**\n+   * Initialize the transfer object. This method will try to open an input and\n+   * output stream.\n+   */\n+  public synchronized void init() throws IOException {\n+    if (socket != null) {\n+      in = new DataInputStream(\n+          new BufferedInputStream(\n+              socket.getInputStream(), Transfer.BUFFER_SIZE));\n+      out = new DataOutputStream(\n+          new BufferedOutputStream(\n+              socket.getOutputStream(), Transfer.BUFFER_SIZE));\n+    }\n+  }\n+\n+  /**\n+   * Write pending changes.\n+   */\n+  public void flush() throws IOException {\n+    out.flush();\n+  }\n+\n+  /**\n+   * Write a boolean.\n+   *\n+   * @param x the value\n+   * @return itself\n+   */\n+  public Transfer writeBoolean(boolean x) throws IOException {\n+    out.writeByte((byte) (x ? 1 : 0));\n+    return this;\n+  }\n+\n+  /**\n+   * Read a boolean.\n+   *\n+   * @return the value\n+   */\n+  public boolean readBoolean() throws IOException {\n+    return in.readByte() != 0;\n+  }\n+\n+  /**\n+   * Write a byte.\n+   *\n+   * @param x the value\n+   * @return itself\n+   */\n+  private Transfer writeByte(byte x) throws IOException {\n+    out.writeByte(x);\n+    return this;\n+  }\n+\n+  /**\n+   * Read a byte.\n+   *\n+   * @return the value\n+   */\n+  private byte readByte() throws IOException {\n+    return in.readByte();\n+  }\n+\n+  /**\n+   * Write an int.\n+   *\n+   * @param x the value\n+   * @return itself\n+   */\n+  public Transfer writeInt(int x) throws IOException {\n+    out.writeInt(x);\n+    return this;\n+  }\n+\n+  /**\n+   * Read an int.\n+   *\n+   * @return the value\n+   */\n+  public int readInt() throws IOException {\n+    return in.readInt();\n+  }\n+\n+  /**\n+   * Write a long.\n+   *\n+   * @param x the value\n+   * @return itself\n+   */\n+  public Transfer writeLong(long x) throws IOException {\n+    out.writeLong(x);\n+    return this;\n+  }\n+\n+  /**\n+   * Read a long.\n+   *\n+   * @return the value\n+   */\n+  public long readLong() throws IOException {\n+    return in.readLong();\n+  }\n+\n+  /**\n+   * Write a double.\n+   *\n+   * @param i the value\n+   * @return itself\n+   */\n+  private Transfer writeDouble(double i) throws IOException {\n+    out.writeDouble(i);\n+    return this;\n+  }\n+\n+  /**\n+   * Write a float.\n+   *\n+   * @param i the value\n+   * @return itself\n+   */\n+  private Transfer writeFloat(float i) throws IOException {\n+    out.writeFloat(i);\n+    return this;\n+  }\n+\n+  /**\n+   * Read a double.\n+   *\n+   * @return the value\n+   */\n+  private double readDouble() throws IOException {\n+    return in.readDouble();\n+  }\n+\n+  /**\n+   * Read a float.\n+   *\n+   * @return the value\n+   */\n+  private float readFloat() throws IOException {\n+    return in.readFloat();\n+  }\n+\n+  /**\n+   * Write a string. The maximum string length is Integer.MAX_VALUE.\n+   *\n+   * @param s the value\n+   * @return itself\n+   */\n+  public Transfer writeString(String s) throws IOException {\n+    if (s == null) {\n+      out.writeInt(-1);\n+    } else {\n+      out.writeInt(s.length());\n+      out.writeChars(s);\n+    }\n+    return this;\n+  }\n+\n+  /**\n+   * Read a string.\n+   *\n+   * @return the value\n+   */\n+  public String readString() throws IOException {\n+    int len = in.readInt();\n+    if (len == -1) {\n+      return null;\n+    }\n+    StringBuilder buff = new StringBuilder(len);\n+    for (int i = 0; i < len; i++) {\n+      buff.append(in.readChar());\n+    }\n+    String s = buff.toString();\n+    s = StringUtils.cache(s);\n+    return s;\n+  }\n+\n+  /**\n+   * Write a byte array.\n+   *\n+   * @param data the value\n+   * @return itself\n+   */\n+  public Transfer writeBytes(byte[] data) throws IOException {\n+    if (data == null) {\n+      writeInt(-1);\n+    } else {\n+      writeInt(data.length);\n+      out.write(data);\n+    }\n+    return this;\n+  }\n+\n+  /**\n+   * Write a number of bytes.\n+   *\n+   * @param buff the value\n+   * @param off  the offset\n+   * @param len  the length\n+   * @return itself\n+   */\n+  public Transfer writeBytes(byte[] buff, int off, int len) throws IOException {\n+    out.write(buff, off, len);\n+    return this;\n+  }\n+\n+  /**\n+   * Read a byte array.\n+   *\n+   * @return the value\n+   */\n+  public byte[] readBytes() throws IOException {\n+    int len = readInt();\n+    if (len == -1) {\n+      return null;\n+    }\n+    byte[] b = Utils.newBytes(len);\n+    in.readFully(b);\n+    return b;\n+  }\n+\n+  /**\n+   * Read a number of bytes.\n+   *\n+   * @param buff the target buffer\n+   * @param off  the offset\n+   * @param len  the number of bytes to read\n+   */\n+  public void readBytes(byte[] buff, int off, int len) throws IOException {\n+    in.readFully(buff, off, len);\n+  }\n+\n+  /**\n+   * Close the transfer object and the socket.\n+   */\n+  public synchronized void close() {\n+    if (socket != null) {\n+      try {\n+        if (out != null) {\n+          out.flush();\n+        }\n         if (socket != null) {\n-            in = new DataInputStream(\n-                    new BufferedInputStream(\n-                            socket.getInputStream(), Transfer.BUFFER_SIZE));\n-            out = new DataOutputStream(\n-                    new BufferedOutputStream(\n-                            socket.getOutputStream(), Transfer.BUFFER_SIZE));\n+          socket.close();\n         }\n-    }\n-\n-    /**\n-     * Write pending changes.\n-     */\n-    public void flush() throws IOException {\n-        out.flush();\n-    }\n-\n-    /**\n-     * Write a boolean.\n-     *\n-     * @param x the value\n-     * @return itself\n-     */\n-    public Transfer writeBoolean(boolean x) throws IOException {\n-        out.writeByte((byte) (x ? 1 : 0));\n-        return this;\n-    }\n-\n-    /**\n-     * Read a boolean.\n-     *\n-     * @return the value\n-     */\n-    public boolean readBoolean() throws IOException {\n-        return in.readByte() != 0;\n-    }\n-\n-    /**\n-     * Write a byte.\n-     *\n-     * @param x the value\n-     * @return itself\n-     */\n-    private Transfer writeByte(byte x) throws IOException {\n-        out.writeByte(x);\n-        return this;\n-    }\n-\n-    /**\n-     * Read a byte.\n-     *\n-     * @return the value\n-     */\n-    private byte readByte() throws IOException {\n-        return in.readByte();\n-    }\n-\n-    /**\n-     * Write an int.\n-     *\n-     * @param x the value\n-     * @return itself\n-     */\n-    public Transfer writeInt(int x) throws IOException {\n-        out.writeInt(x);\n-        return this;\n-    }\n-\n-    /**\n-     * Read an int.\n-     *\n-     * @return the value\n-     */\n-    public int readInt() throws IOException {\n-        return in.readInt();\n-    }\n-\n-    /**\n-     * Write a long.\n-     *\n-     * @param x the value\n-     * @return itself\n-     */\n-    public Transfer writeLong(long x) throws IOException {\n-        out.writeLong(x);\n-        return this;\n-    }\n-\n-    /**\n-     * Read a long.\n-     *\n-     * @return the value\n-     */\n-    public long readLong() throws IOException {\n-        return in.readLong();\n-    }\n-\n-    /**\n-     * Write a double.\n-     *\n-     * @param i the value\n-     * @return itself\n-     */\n-    private Transfer writeDouble(double i) throws IOException {\n-        out.writeDouble(i);\n-        return this;\n-    }\n-\n-    /**\n-     * Write a float.\n-     *\n-     * @param i the value\n-     * @return itself\n-     */\n-    private Transfer writeFloat(float i) throws IOException {\n-        out.writeFloat(i);\n-        return this;\n-    }\n-\n-    /**\n-     * Read a double.\n-     *\n-     * @return the value\n-     */\n-    private double readDouble() throws IOException {\n-        return in.readDouble();\n-    }\n-\n-    /**\n-     * Read a float.\n-     *\n-     * @return the value\n-     */\n-    private float readFloat() throws IOException {\n-        return in.readFloat();\n-    }\n-\n-    /**\n-     * Write a string. The maximum string length is Integer.MAX_VALUE.\n-     *\n-     * @param s the value\n-     * @return itself\n-     */\n-    public Transfer writeString(String s) throws IOException {\n-        if (s == null) {\n-            out.writeInt(-1);\n+      } catch (IOException e) {\n+        DbException.traceThrowable(e);\n+      } finally {\n+        socket = null;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Write a value.\n+   *\n+   * @param v the value\n+   */\n+  public void writeValue(Value v) throws IOException {\n+    int type = v.getValueType();\n+    switch (type) {\n+      case Value.NULL:\n+        writeInt(NULL);\n+        break;\n+      case Value.BYTES:\n+        writeInt(BYTES);\n+        writeBytes(v.getBytesNoCopy());\n+        break;\n+      case Value.JAVA_OBJECT:\n+        writeInt(JAVA_OBJECT);\n+        writeBytes(v.getBytesNoCopy());\n+        break;\n+      case Value.UUID: {\n+        writeInt(UUID);\n+        ValueUuid uuid = (ValueUuid) v;\n+        writeLong(uuid.getHigh());\n+        writeLong(uuid.getLow());\n+        break;\n+      }\n+      case Value.BOOLEAN:\n+        writeInt(BOOLEAN);\n+        writeBoolean(v.getBoolean());\n+        break;\n+      case Value.BYTE:\n+        writeInt(BYTE);\n+        writeByte(v.getByte());\n+        break;\n+      case Value.TIME:\n+        writeInt(TIME);\n+        writeLong(((ValueTime) v).getNanos());\n+        break;\n+      case Value.TIME_TZ: {\n+        ValueTimeTimeZone t = (ValueTimeTimeZone) v;\n+        if (version >= Constants.TCP_PROTOCOL_VERSION_19) {\n+          writeInt(TIME_TZ);\n+          writeLong(t.getNanos());\n+          writeInt(t.getTimeZoneOffsetSeconds());\n         } else {\n-            out.writeInt(s.length());\n-            out.writeChars(s);\n-        }\n-        return this;\n-    }\n-\n-    /**\n-     * Read a string.\n-     *\n-     * @return the value\n-     */\n-    public String readString() throws IOException {\n-        int len = in.readInt();\n-        if (len == -1) {\n-            return null;\n+          writeInt(TIME);\n+          ValueTimestampTimeZone current = session instanceof CastDataProvider\n+              ? ((CastDataProvider) session).currentTimestamp() : CurrentTimestamp.get();\n+          writeLong(DateTimeUtils.normalizeNanosOfDay(t.getNanos() +\n+              (t.getTimeZoneOffsetSeconds() - current.getTimeZoneOffsetSeconds())\n+                  * DateTimeUtils.NANOS_PER_DAY));\n         }\n-        StringBuilder buff = new StringBuilder(len);\n-        for (int i = 0; i < len; i++) {\n-            buff.append(in.readChar());\n+        break;\n+      }\n+      case Value.DATE:\n+        writeInt(DATE);\n+        writeLong(((ValueDate) v).getDateValue());\n+        break;\n+      case Value.TIMESTAMP: {\n+        writeInt(TIMESTAMP);\n+        ValueTimestamp ts = (ValueTimestamp) v;\n+        writeLong(ts.getDateValue());\n+        writeLong(ts.getTimeNanos());\n+        break;\n+      }\n+      case Value.TIMESTAMP_TZ: {\n+        writeInt(TIMESTAMP_TZ);\n+        ValueTimestampTimeZone ts = (ValueTimestampTimeZone) v;\n+        writeLong(ts.getDateValue());\n+        writeLong(ts.getTimeNanos());\n+        int timeZoneOffset = ts.getTimeZoneOffsetSeconds();\n+        writeInt(version >= Constants.TCP_PROTOCOL_VERSION_19 //\n+            ? timeZoneOffset : timeZoneOffset / 60);\n+        break;\n+      }\n+      case Value.DECIMAL:\n+        writeInt(DECIMAL);\n+        writeString(v.getString());\n+        break;\n+      case Value.DOUBLE:\n+        writeInt(DOUBLE);\n+        writeDouble(v.getDouble());\n+        break;\n+      case Value.FLOAT:\n+        writeInt(FLOAT);\n+        writeFloat(v.getFloat());\n+        break;\n+      case Value.INT:\n+        writeInt(INT);\n+        writeInt(v.getInt());\n+        break;\n+      case Value.LONG:\n+        writeInt(LONG);\n+        writeLong(v.getLong());\n+        break;\n+      case Value.SHORT:\n+        writeInt(SHORT);\n+        writeInt(v.getShort());\n+        break;\n+      case Value.STRING:\n+        writeInt(STRING);\n+        writeString(v.getString());\n+        break;\n+      case Value.STRING_IGNORECASE:\n+        writeInt(STRING_IGNORECASE);\n+        writeString(v.getString());\n+        break;\n+      case Value.STRING_FIXED:\n+        writeInt(STRING_FIXED);\n+        writeString(v.getString());\n+        break;\n+      case Value.BLOB: {\n+        writeInt(BLOB);\n+        if (version >= Constants.TCP_PROTOCOL_VERSION_11) {\n+          if (v instanceof ValueLobDb) {\n+            ValueLobDb lob = (ValueLobDb) v;\n+            if (lob.isStored()) {\n+              writeLong(-1);\n+              writeInt(lob.getTableId());\n+              writeLong(lob.getLobId());\n+              if (version >= Constants.TCP_PROTOCOL_VERSION_12) {\n+                writeBytes(calculateLobMac(lob.getLobId()));\n+              }\n+              writeLong(lob.getType().getPrecision());\n+              break;\n+            }\n+          }\n         }\n-        String s = buff.toString();\n-        s = StringUtils.cache(s);\n-        return s;\n-    }\n-\n-    /**\n-     * Write a byte array.\n-     *\n-     * @param data the value\n-     * @return itself\n-     */\n-    public Transfer writeBytes(byte[] data) throws IOException {\n-        if (data == null) {\n-            writeInt(-1);\n-        } else {\n-            writeInt(data.length);\n-            out.write(data);\n+        long length = v.getType().getPrecision();\n+        if (length < 0) {\n+          throw DbException.get(\n+              ErrorCode.CONNECTION_BROKEN_1, \"length=\" + length);\n         }\n-        return this;\n-    }\n-\n-    /**\n-     * Write a number of bytes.\n-     *\n-     * @param buff the value\n-     * @param off the offset\n-     * @param len the length\n-     * @return itself\n-     */\n-    public Transfer writeBytes(byte[] buff, int off, int len) throws IOException {\n-        out.write(buff, off, len);\n-        return this;\n-    }\n-\n-    /**\n-     * Read a byte array.\n-     *\n-     * @return the value\n-     */\n-    public byte[] readBytes() throws IOException {\n-        int len = readInt();\n-        if (len == -1) {\n-            return null;\n+        writeLong(length);\n+        long written = IOUtils.copyAndCloseInput(v.getInputStream(), out);\n+        if (written != length) {\n+          throw DbException.get(\n+              ErrorCode.CONNECTION_BROKEN_1, \"length:\" + length + \" written:\" + written);\n         }\n-        byte[] b = Utils.newBytes(len);\n-        in.readFully(b);\n-        return b;\n-    }\n-\n-    /**\n-     * Read a number of bytes.\n-     *\n-     * @param buff the target buffer\n-     * @param off the offset\n-     * @param len the number of bytes to read\n-     */\n-    public void readBytes(byte[] buff, int off, int len) throws IOException {\n-        in.readFully(buff, off, len);\n-    }\n-\n-    /**\n-     * Close the transfer object and the socket.\n-     */\n-    public synchronized void close() {\n-        if (socket != null) {\n-            try {\n-                if (out != null) {\n-                    out.flush();\n-                }\n-                if (socket != null) {\n-                    socket.close();\n-                }\n-            } catch (IOException e) {\n-                DbException.traceThrowable(e);\n-            } finally {\n-                socket = null;\n+        writeInt(LOB_MAGIC);\n+        break;\n+      }\n+      case Value.CLOB: {\n+        writeInt(CLOB);\n+        if (version >= Constants.TCP_PROTOCOL_VERSION_11) {\n+          if (v instanceof ValueLobDb) {\n+            ValueLobDb lob = (ValueLobDb) v;\n+            if (lob.isStored()) {\n+              writeLong(-1);\n+              writeInt(lob.getTableId());\n+              writeLong(lob.getLobId());\n+              if (version >= Constants.TCP_PROTOCOL_VERSION_12) {\n+                writeBytes(calculateLobMac(lob.getLobId()));\n+              }\n+              writeLong(lob.getType().getPrecision());\n+              break;\n             }\n+          }\n         }\n-    }\n-\n-    /**\n-     * Write a value.\n-     *\n-     * @param v the value\n-     */\n-    public void writeValue(Value v) throws IOException {\n-        int type = v.getValueType();\n-        switch (type) {\n-        case Value.NULL:\n-            writeInt(NULL);\n-            break;\n-        case Value.BYTES:\n-            writeInt(BYTES);\n-            writeBytes(v.getBytesNoCopy());\n-            break;\n-        case Value.JAVA_OBJECT:\n-            writeInt(JAVA_OBJECT);\n-            writeBytes(v.getBytesNoCopy());\n-            break;\n-        case Value.UUID: {\n-            writeInt(UUID);\n-            ValueUuid uuid = (ValueUuid) v;\n-            writeLong(uuid.getHigh());\n-            writeLong(uuid.getLow());\n-            break;\n+        long length = v.getType().getPrecision();\n+        if (length < 0) {\n+          throw DbException.get(\n+              ErrorCode.CONNECTION_BROKEN_1, \"length=\" + length);\n         }\n-        case Value.BOOLEAN:\n-            writeInt(BOOLEAN);\n-            writeBoolean(v.getBoolean());\n-            break;\n-        case Value.BYTE:\n-            writeInt(BYTE);\n-            writeByte(v.getByte());\n-            break;\n-        case Value.TIME:\n-            writeInt(TIME);\n-            writeLong(((ValueTime) v).getNanos());\n-            break;\n-        case Value.TIME_TZ: {\n-            ValueTimeTimeZone t = (ValueTimeTimeZone) v;\n-            if (version >= Constants.TCP_PROTOCOL_VERSION_19) {\n-                writeInt(TIME_TZ);\n-                writeLong(t.getNanos());\n-                writeInt(t.getTimeZoneOffsetSeconds());\n-            } else {\n-                writeInt(TIME);\n-                ValueTimestampTimeZone current = session instanceof CastDataProvider\n-                        ? ((CastDataProvider) session).currentTimestamp() : CurrentTimestamp.get();\n-                writeLong(DateTimeUtils.normalizeNanosOfDay(t.getNanos() +\n-                        (t.getTimeZoneOffsetSeconds() - current.getTimeZoneOffsetSeconds())\n-                        * DateTimeUtils.NANOS_PER_DAY));\n-            }\n-            break;\n+        writeLong(length);\n+        Reader reader = v.getReader();\n+        Data.copyString(reader, out);\n+        writeInt(LOB_MAGIC);\n+        break;\n+      }\n+      case Value.ARRAY: {\n+        writeInt(ARRAY);\n+        ValueArray va = (ValueArray) v;\n+        Value[] list = va.getList();\n+        int len = list.length;\n+        Class<?> componentType = va.getComponentType();\n+        if (componentType == Object.class) {\n+          writeInt(len);\n+        } else {\n+          writeInt(-(len + 1));\n+          writeString(componentType.getName());\n         }\n-        case Value.DATE:\n-            writeInt(DATE);\n-            writeLong(((ValueDate) v).getDateValue());\n-            break;\n-        case Value.TIMESTAMP: {\n-            writeInt(TIMESTAMP);\n-            ValueTimestamp ts = (ValueTimestamp) v;\n-            writeLong(ts.getDateValue());\n-            writeLong(ts.getTimeNanos());\n-            break;\n+        for (Value value : list) {\n+          writeValue(value);\n         }\n-        case Value.TIMESTAMP_TZ: {\n-            writeInt(TIMESTAMP_TZ);\n-            ValueTimestampTimeZone ts = (ValueTimestampTimeZone) v;\n-            writeLong(ts.getDateValue());\n-            writeLong(ts.getTimeNanos());\n-            int timeZoneOffset = ts.getTimeZoneOffsetSeconds();\n-            writeInt(version >= Constants.TCP_PROTOCOL_VERSION_19 //\n-                    ? timeZoneOffset : timeZoneOffset / 60);\n-            break;\n+        break;\n+      }\n+      case Value.ROW: {\n+        writeInt(version >= Constants.TCP_PROTOCOL_VERSION_18 ? ROW : ARRAY);\n+        ValueRow va = (ValueRow) v;\n+        Value[] list = va.getList();\n+        int len = list.length;\n+        writeInt(len);\n+        for (Value value : list) {\n+          writeValue(value);\n         }\n-        case Value.DECIMAL:\n-            writeInt(DECIMAL);\n-            writeString(v.getString());\n-            break;\n-        case Value.DOUBLE:\n-            writeInt(DOUBLE);\n-            writeDouble(v.getDouble());\n-            break;\n-        case Value.FLOAT:\n-            writeInt(FLOAT);\n-            writeFloat(v.getFloat());\n-            break;\n-        case Value.INT:\n-            writeInt(INT);\n-            writeInt(v.getInt());\n-            break;\n-        case Value.LONG:\n-            writeInt(LONG);\n-            writeLong(v.getLong());\n-            break;\n-        case Value.SHORT:\n-            writeInt(SHORT);\n-            writeInt(v.getShort());\n-            break;\n-        case Value.STRING:\n-            writeInt(STRING);\n-            writeString(v.getString());\n-            break;\n-        case Value.STRING_IGNORECASE:\n-            writeInt(STRING_IGNORECASE);\n-            writeString(v.getString());\n-            break;\n-        case Value.STRING_FIXED:\n-            writeInt(STRING_FIXED);\n-            writeString(v.getString());\n-            break;\n-        case Value.BLOB: {\n-            writeInt(BLOB);\n-            if (version >= Constants.TCP_PROTOCOL_VERSION_11) {\n-                if (v instanceof ValueLobDb) {\n-                    ValueLobDb lob = (ValueLobDb) v;\n-                    if (lob.isStored()) {\n-                        writeLong(-1);\n-                        writeInt(lob.getTableId());\n-                        writeLong(lob.getLobId());\n-                        if (version >= Constants.TCP_PROTOCOL_VERSION_12) {\n-                            writeBytes(calculateLobMac(lob.getLobId()));\n-                        }\n-                        writeLong(lob.getType().getPrecision());\n-                        break;\n-                    }\n-                }\n-            }\n-            long length = v.getType().getPrecision();\n-            if (length < 0) {\n-                throw DbException.get(\n-                        ErrorCode.CONNECTION_BROKEN_1, \"length=\" + length);\n-            }\n-            writeLong(length);\n-            long written = IOUtils.copyAndCloseInput(v.getInputStream(), out);\n-            if (written != length) {\n-                throw DbException.get(\n-                        ErrorCode.CONNECTION_BROKEN_1, \"length:\" + length + \" written:\" + written);\n-            }\n-            writeInt(LOB_MAGIC);\n-            break;\n+        break;\n+      }\n+      case Value.ENUM: {\n+        writeInt(ENUM);\n+        writeInt(v.getInt());\n+        writeString(v.getString());\n+        break;\n+      }\n+      case Value.RESULT_SET: {\n+        writeInt(RESULT_SET);\n+        ResultInterface result = ((ValueResultSet) v).getResult();\n+        int columnCount = result.getVisibleColumnCount();\n+        writeInt(columnCount);\n+        for (int i = 0; i < columnCount; i++) {\n+          TypeInfo columnType = result.getColumnType(i);\n+          if (version >= Constants.TCP_PROTOCOL_VERSION_18) {\n+            writeString(result.getAlias(i));\n+            writeString(result.getColumnName(i));\n+            writeInt(columnType.getValueType());\n+            writeLong(columnType.getPrecision());\n+          } else {\n+            writeString(result.getColumnName(i));\n+            writeInt(DataType.getDataType(columnType.getValueType()).sqlType);\n+            writeInt(MathUtils.convertLongToInt(columnType.getPrecision()));\n+          }\n+          writeInt(columnType.getScale());\n         }\n-        case Value.CLOB: {\n-            writeInt(CLOB);\n-            if (version >= Constants.TCP_PROTOCOL_VERSION_11) {\n-                if (v instanceof ValueLobDb) {\n-                    ValueLobDb lob = (ValueLobDb) v;\n-                    if (lob.isStored()) {\n-                        writeLong(-1);\n-                        writeInt(lob.getTableId());\n-                        writeLong(lob.getLobId());\n-                        if (version >= Constants.TCP_PROTOCOL_VERSION_12) {\n-                            writeBytes(calculateLobMac(lob.getLobId()));\n-                        }\n-                        writeLong(lob.getType().getPrecision());\n-                        break;\n-                    }\n-                }\n-            }\n-            long length = v.getType().getPrecision();\n-            if (length < 0) {\n-                throw DbException.get(\n-                        ErrorCode.CONNECTION_BROKEN_1, \"length=\" + length);\n-            }\n-            writeLong(length);\n-            Reader reader = v.getReader();\n-            Data.copyString(reader, out);\n-            writeInt(LOB_MAGIC);\n-            break;\n+        while (result.next()) {\n+          writeBoolean(true);\n+          Value[] row = result.currentRow();\n+          for (int i = 0; i < columnCount; i++) {\n+            writeValue(row[i]);\n+          }\n         }\n-        case Value.ARRAY: {\n-            writeInt(ARRAY);\n-            ValueArray va = (ValueArray) v;\n-            Value[] list = va.getList();\n-            int len = list.length;\n-            Class<?> componentType = va.getComponentType();\n-            if (componentType == Object.class) {\n-                writeInt(len);\n-            } else {\n-                writeInt(-(len + 1));\n-                writeString(componentType.getName());\n-            }\n-            for (Value value : list) {\n-                writeValue(value);\n-            }\n-            break;\n+        writeBoolean(false);\n+        break;\n+      }\n+      case Value.GEOMETRY:\n+        writeInt(GEOMETRY);\n+        if (version >= Constants.TCP_PROTOCOL_VERSION_14) {\n+          writeBytes(v.getBytesNoCopy());\n+        } else {\n+          writeString(v.getString());\n         }\n-        case Value.ROW: {\n-            writeInt(version >= Constants.TCP_PROTOCOL_VERSION_18 ? ROW : ARRAY);\n-            ValueRow va = (ValueRow) v;\n-            Value[] list = va.getList();\n-            int len = list.length;\n-            writeInt(len);\n-            for (Value value : list) {\n-                writeValue(value);\n-            }\n-            break;\n+        break;\n+      case Value.INTERVAL_YEAR:\n+      case Value.INTERVAL_MONTH:\n+      case Value.INTERVAL_DAY:\n+      case Value.INTERVAL_HOUR:\n+      case Value.INTERVAL_MINUTE:\n+        if (version >= Constants.TCP_PROTOCOL_VERSION_18) {\n+          ValueInterval interval = (ValueInterval) v;\n+          int ordinal = type - Value.INTERVAL_YEAR;\n+          if (interval.isNegative()) {\n+            ordinal = ~ordinal;\n+          }\n+          writeInt(INTERVAL);\n+          writeByte((byte) ordinal);\n+          writeLong(interval.getLeading());\n+        } else {\n+          writeInt(STRING);\n+          writeString(v.getString());\n         }\n-        case Value.ENUM: {\n-            writeInt(ENUM);\n-            writeInt(v.getInt());\n-            writeString(v.getString());\n-            break;\n+        break;\n+      case Value.INTERVAL_SECOND:\n+      case Value.INTERVAL_YEAR_TO_MONTH:\n+      case Value.INTERVAL_DAY_TO_HOUR:\n+      case Value.INTERVAL_DAY_TO_MINUTE:\n+      case Value.INTERVAL_DAY_TO_SECOND:\n+      case Value.INTERVAL_HOUR_TO_MINUTE:\n+      case Value.INTERVAL_HOUR_TO_SECOND:\n+      case Value.INTERVAL_MINUTE_TO_SECOND:\n+        if (version >= Constants.TCP_PROTOCOL_VERSION_18) {\n+          ValueInterval interval = (ValueInterval) v;\n+          int ordinal = type - Value.INTERVAL_YEAR;\n+          if (interval.isNegative()) {\n+            ordinal = ~ordinal;\n+          }\n+          writeInt(INTERVAL);\n+          writeByte((byte) ordinal);\n+          writeLong(interval.getLeading());\n+          writeLong(interval.getRemaining());\n+        } else {\n+          writeInt(STRING);\n+          writeString(v.getString());\n         }\n-        case Value.RESULT_SET: {\n-            writeInt(RESULT_SET);\n-            ResultInterface result = ((ValueResultSet) v).getResult();\n-            int columnCount = result.getVisibleColumnCount();\n-            writeInt(columnCount);\n-            for (int i = 0; i < columnCount; i++) {\n-                TypeInfo columnType = result.getColumnType(i);\n-                if (version >= Constants.TCP_PROTOCOL_VERSION_18) {\n-                    writeString(result.getAlias(i));\n-                    writeString(result.getColumnName(i));\n-                    writeInt(columnType.getValueType());\n-                    writeLong(columnType.getPrecision());\n-                } else {\n-                    writeString(result.getColumnName(i));\n-                    writeInt(DataType.getDataType(columnType.getValueType()).sqlType);\n-                    writeInt(MathUtils.convertLongToInt(columnType.getPrecision()));\n-                }\n-                writeInt(columnType.getScale());\n-            }\n-            while (result.next()) {\n-                writeBoolean(true);\n-                Value[] row = result.currentRow();\n-                for (int i = 0; i < columnCount; i++) {\n-                    writeValue(row[i]);\n-                }\n-            }\n-            writeBoolean(false);\n-            break;\n+        break;\n+      case Value.JSON: {\n+        writeInt(JSON);\n+        writeBytes(v.getBytesNoCopy());\n+        break;\n+      }\n+      default:\n+        if (JdbcUtils.customDataTypesHandler != null) {\n+          writeInt(type);\n+          writeBytes(v.getBytesNoCopy());\n+          break;\n         }\n-        case Value.GEOMETRY:\n-            writeInt(GEOMETRY);\n-            if (version >= Constants.TCP_PROTOCOL_VERSION_14) {\n-                writeBytes(v.getBytesNoCopy());\n-            } else {\n-                writeString(v.getString());\n-            }\n-            break;\n-        case Value.INTERVAL_YEAR:\n-        case Value.INTERVAL_MONTH:\n-        case Value.INTERVAL_DAY:\n-        case Value.INTERVAL_HOUR:\n-        case Value.INTERVAL_MINUTE:\n-            if (version >= Constants.TCP_PROTOCOL_VERSION_18) {\n-                ValueInterval interval = (ValueInterval) v;\n-                int ordinal = type - Value.INTERVAL_YEAR;\n-                if (interval.isNegative()) {\n-                    ordinal = ~ordinal;\n-                }\n-                writeInt(INTERVAL);\n-                writeByte((byte) ordinal);\n-                writeLong(interval.getLeading());\n-            } else {\n-                writeInt(STRING);\n-                writeString(v.getString());\n-            }\n-            break;\n-        case Value.INTERVAL_SECOND:\n-        case Value.INTERVAL_YEAR_TO_MONTH:\n-        case Value.INTERVAL_DAY_TO_HOUR:\n-        case Value.INTERVAL_DAY_TO_MINUTE:\n-        case Value.INTERVAL_DAY_TO_SECOND:\n-        case Value.INTERVAL_HOUR_TO_MINUTE:\n-        case Value.INTERVAL_HOUR_TO_SECOND:\n-        case Value.INTERVAL_MINUTE_TO_SECOND:\n-            if (version >= Constants.TCP_PROTOCOL_VERSION_18) {\n-                ValueInterval interval = (ValueInterval) v;\n-                int ordinal = type - Value.INTERVAL_YEAR;\n-                if (interval.isNegative()) {\n-                    ordinal = ~ordinal;\n-                }\n-                writeInt(INTERVAL);\n-                writeByte((byte) ordinal);\n-                writeLong(interval.getLeading());\n-                writeLong(interval.getRemaining());\n+        throw DbException.get(ErrorCode.CONNECTION_BROKEN_1, \"type=\" + type);\n+    }\n+  }\n+\n+  /**\n+   * Read a value.\n+   *\n+   * @return the value\n+   */\n+  public Value readValue() throws IOException {\n+    int type = readInt();\n+    switch (type) {\n+      case NULL:\n+        return ValueNull.INSTANCE;\n+      case BYTES:\n+        return ValueBytes.getNoCopy(readBytes());\n+      case UUID:\n+        return ValueUuid.get(readLong(), readLong());\n+      case JAVA_OBJECT:\n+        return ValueJavaObject.getNoCopy(null, readBytes(), session.getDataHandler());\n+      case BOOLEAN:\n+        return ValueBoolean.get(readBoolean());\n+      case BYTE:\n+        return ValueByte.get(readByte());\n+      case DATE:\n+        return ValueDate.fromDateValue(readLong());\n+      case TIME:\n+        return ValueTime.fromNanos(readLong());\n+      case TIME_TZ:\n+        return ValueTimeTimeZone.fromNanos(readLong(), readInt());\n+      case TIMESTAMP:\n+        return ValueTimestamp.fromDateValueAndNanos(readLong(), readLong());\n+      case TIMESTAMP_TZ: {\n+        long dateValue = readLong(), timeNanos = readLong();\n+        int timeZoneOffset = readInt();\n+        return ValueTimestampTimeZone.fromDateValueAndNanos(dateValue, timeNanos,\n+            version >= Constants.TCP_PROTOCOL_VERSION_19 ? timeZoneOffset : timeZoneOffset * 60);\n+      }\n+      case DECIMAL:\n+        return ValueDecimal.get(new BigDecimal(readString()));\n+      case DOUBLE:\n+        return ValueDouble.get(readDouble());\n+      case FLOAT:\n+        return ValueFloat.get(readFloat());\n+      case ENUM: {\n+        final int ordinal = readInt();\n+        final String label = readString();\n+        return ValueEnumBase.get(label, ordinal);\n+      }\n+      case INT:\n+        return ValueInt.get(readInt());\n+      case LONG:\n+        return ValueLong.get(readLong());\n+      case SHORT:\n+        return ValueShort.get((short) readInt());\n+      case STRING:\n+        return ValueString.get(readString());\n+      case STRING_IGNORECASE:\n+        return ValueStringIgnoreCase.get(readString());\n+      case STRING_FIXED:\n+        return ValueStringFixed.get(readString());\n+      case BLOB: {\n+        long length = readLong();\n+        if (version >= Constants.TCP_PROTOCOL_VERSION_11) {\n+          if (length == -1) {\n+            int tableId = readInt();\n+            long id = readLong();\n+            byte[] hmac;\n+            if (version >= Constants.TCP_PROTOCOL_VERSION_12) {\n+              hmac = readBytes();\n             } else {\n-                writeInt(STRING);\n-                writeString(v.getString());\n+              hmac = null;\n             }\n-            break;\n-        case Value.JSON: {\n-            writeInt(JSON);\n-            writeBytes(v.getBytesNoCopy());\n-            break;\n-        }\n-        default:\n-            if (JdbcUtils.customDataTypesHandler != null) {\n-                writeInt(type);\n-                writeBytes(v.getBytesNoCopy());\n-                break;\n-            }\n-            throw DbException.get(ErrorCode.CONNECTION_BROKEN_1, \"type=\" + type);\n-        }\n-    }\n-\n-    /**\n-     * Read a value.\n-     *\n-     * @return the value\n-     */\n-    public Value readValue() throws IOException {\n-        int type = readInt();\n-        switch (type) {\n-        case NULL:\n-            return ValueNull.INSTANCE;\n-        case BYTES:\n-            return ValueBytes.getNoCopy(readBytes());\n-        case UUID:\n-            return ValueUuid.get(readLong(), readLong());\n-        case JAVA_OBJECT:\n-            return ValueJavaObject.getNoCopy(null, readBytes(), session.getDataHandler());\n-        case BOOLEAN:\n-            return ValueBoolean.get(readBoolean());\n-        case BYTE:\n-            return ValueByte.get(readByte());\n-        case DATE:\n-            return ValueDate.fromDateValue(readLong());\n-        case TIME:\n-            return ValueTime.fromNanos(readLong());\n-        case TIME_TZ:\n-            return ValueTimeTimeZone.fromNanos(readLong(), readInt());\n-        case TIMESTAMP:\n-            return ValueTimestamp.fromDateValueAndNanos(readLong(), readLong());\n-        case TIMESTAMP_TZ: {\n-            long dateValue = readLong(), timeNanos = readLong();\n-            int timeZoneOffset = readInt();\n-            return ValueTimestampTimeZone.fromDateValueAndNanos(dateValue, timeNanos,\n-                    version >= Constants.TCP_PROTOCOL_VERSION_19 ? timeZoneOffset : timeZoneOffset * 60);\n+            long precision = readLong();\n+            return ValueLobDb.create(\n+                Value.BLOB, session.getDataHandler(), tableId, id, hmac, precision);\n+          }\n         }\n-        case DECIMAL:\n-            return ValueDecimal.get(new BigDecimal(readString()));\n-        case DOUBLE:\n-            return ValueDouble.get(readDouble());\n-        case FLOAT:\n-            return ValueFloat.get(readFloat());\n-        case ENUM: {\n-            final int ordinal = readInt();\n-            final String label = readString();\n-            return ValueEnumBase.get(label, ordinal);\n+        Value v = session.getDataHandler().getLobStorage().createBlob(in, length);\n+        int magic = readInt();\n+        if (magic != LOB_MAGIC) {\n+          throw DbException.get(\n+              ErrorCode.CONNECTION_BROKEN_1, \"magic=\" + magic);\n         }\n-        case INT:\n-            return ValueInt.get(readInt());\n-        case LONG:\n-            return ValueLong.get(readLong());\n-        case SHORT:\n-            return ValueShort.get((short) readInt());\n-        case STRING:\n-            return ValueString.get(readString());\n-        case STRING_IGNORECASE:\n-            return ValueStringIgnoreCase.get(readString());\n-        case STRING_FIXED:\n-            return ValueStringFixed.get(readString());\n-        case BLOB: {\n-            long length = readLong();\n-            if (version >= Constants.TCP_PROTOCOL_VERSION_11) {\n-                if (length == -1) {\n-                    int tableId = readInt();\n-                    long id = readLong();\n-                    byte[] hmac;\n-                    if (version >= Constants.TCP_PROTOCOL_VERSION_12) {\n-                        hmac = readBytes();\n-                    } else {\n-                        hmac = null;\n-                    }\n-                    long precision = readLong();\n-                    return ValueLobDb.create(\n-                            Value.BLOB, session.getDataHandler(), tableId, id, hmac, precision);\n-                }\n-            }\n-            Value v = session.getDataHandler().getLobStorage().createBlob(in, length);\n-            int magic = readInt();\n-            if (magic != LOB_MAGIC) {\n-                throw DbException.get(\n-                        ErrorCode.CONNECTION_BROKEN_1, \"magic=\" + magic);\n+        return v;\n+      }\n+      case CLOB: {\n+        long length = readLong();\n+        if (version >= Constants.TCP_PROTOCOL_VERSION_11) {\n+          if (length == -1) {\n+            int tableId = readInt();\n+            long id = readLong();\n+            byte[] hmac;\n+            if (version >= Constants.TCP_PROTOCOL_VERSION_12) {\n+              hmac = readBytes();\n+            } else {\n+              hmac = null;\n             }\n-            return v;\n+            long precision = readLong();\n+            return ValueLobDb.create(\n+                Value.CLOB, session.getDataHandler(), tableId, id, hmac, precision);\n+          }\n+          if (length < 0) {\n+            throw DbException.get(\n+                ErrorCode.CONNECTION_BROKEN_1, \"length=\" + length);\n+          }\n         }\n-        case CLOB: {\n-            long length = readLong();\n-            if (version >= Constants.TCP_PROTOCOL_VERSION_11) {\n-                if (length == -1) {\n-                    int tableId = readInt();\n-                    long id = readLong();\n-                    byte[] hmac;\n-                    if (version >= Constants.TCP_PROTOCOL_VERSION_12) {\n-                        hmac = readBytes();\n-                    } else {\n-                        hmac = null;\n-                    }\n-                    long precision = readLong();\n-                    return ValueLobDb.create(\n-                            Value.CLOB, session.getDataHandler(), tableId, id, hmac, precision);\n-                }\n-                if (length < 0) {\n-                    throw DbException.get(\n-                            ErrorCode.CONNECTION_BROKEN_1, \"length=\"+ length);\n-                }\n-            }\n-            Value v = session.getDataHandler().getLobStorage().\n-                    createClob(new DataReader(in), length);\n-            int magic = readInt();\n-            if (magic != LOB_MAGIC) {\n-                throw DbException.get(\n-                        ErrorCode.CONNECTION_BROKEN_1, \"magic=\" + magic);\n-            }\n-            return v;\n+        Value v = session.getDataHandler().getLobStorage().\n+            createClob(new DataReader(in), length);\n+        int magic = readInt();\n+        if (magic != LOB_MAGIC) {\n+          throw DbException.get(\n+              ErrorCode.CONNECTION_BROKEN_1, \"magic=\" + magic);\n         }\n-        case ARRAY: {\n-            int len = readInt();\n-            Class<?> componentType = Object.class;\n-            if (len < 0) {\n-                len = -(len + 1);\n-                componentType = JdbcUtils.loadUserClass(readString());\n-            }\n-            Value[] list = new Value[len];\n-            for (int i = 0; i < len; i++) {\n-                list[i] = readValue();\n-            }\n-            return ValueArray.get(componentType, list);\n+        return v;\n+      }\n+      case ARRAY: {\n+        int len = readInt();\n+        Class<?> componentType = Object.class;\n+        if (len < 0) {\n+          len = -(len + 1);\n+          componentType = JdbcUtils.loadUserClass(readString());\n         }\n-        case ROW: {\n-            int len = readInt();\n-            Value[] list = new Value[len];\n-            for (int i = 0; i < len; i++) {\n-                list[i] = readValue();\n-            }\n-            return ValueRow.get(list);\n+        Value[] list = new Value[len];\n+        for (int i = 0; i < len; i++) {\n+          list[i] = readValue();\n         }\n-        case RESULT_SET: {\n-            SimpleResult rs = new SimpleResult();\n-            int columns = readInt();\n-            for (int i = 0; i < columns; i++) {\n-                if (version >= Constants.TCP_PROTOCOL_VERSION_18) {\n-                    rs.addColumn(readString(), readString(), readInt(), readLong(), readInt());\n-                } else {\n-                    String name = readString();\n-                    rs.addColumn(name, name, DataType.convertSQLTypeToValueType(readInt()), readInt(), readInt());\n-                }\n-            }\n-            while (readBoolean()) {\n-                Value[] o = new Value[columns];\n-                for (int i = 0; i < columns; i++) {\n-                    o[i] = readValue();\n-                }\n-                rs.addRow(o);\n-            }\n-            return ValueResultSet.get(rs);\n+        return ValueArray.get(componentType, list);\n+      }\n+      case ROW: {\n+        int len = readInt();\n+        Value[] list = new Value[len];\n+        for (int i = 0; i < len; i++) {\n+          list[i] = readValue();\n         }\n-        case GEOMETRY:\n-            if (version >= Constants.TCP_PROTOCOL_VERSION_14) {\n-                return ValueGeometry.get(readBytes());\n-            }\n-            return ValueGeometry.get(readString());\n-        case INTERVAL: {\n-            int ordinal = readByte();\n-            boolean negative = ordinal < 0;\n-            if (negative) {\n-                ordinal = ~ordinal;\n-            }\n-            return ValueInterval.from(IntervalQualifier.valueOf(ordinal), negative, readLong(),\n-                    ordinal < 5 ? 0 : readLong());\n+        return ValueRow.get(list);\n+      }\n+      case RESULT_SET: {\n+        SimpleResult rs = new SimpleResult();\n+        int columns = readInt();\n+        for (int i = 0; i < columns; i++) {\n+          if (version >= Constants.TCP_PROTOCOL_VERSION_18) {\n+            rs.addColumn(readString(), readString(), readInt(), readLong(), readInt());\n+          } else {\n+            String name = readString();\n+            rs.addColumn(name, name, DataType.convertSQLTypeToValueType(readInt()), readInt(), readInt());\n+          }\n         }\n-        case JSON:\n-            // Do not trust the value\n-            return ValueJson.fromJson(readBytes());\n-        default:\n-            if (JdbcUtils.customDataTypesHandler != null) {\n-                return JdbcUtils.customDataTypesHandler.convert(\n-                        ValueBytes.getNoCopy(readBytes()), type);\n-            }\n-            throw DbException.get(ErrorCode.CONNECTION_BROKEN_1, \"type=\" + type);\n+        while (readBoolean()) {\n+          Value[] o = new Value[columns];\n+          for (int i = 0; i < columns; i++) {\n+            o[i] = readValue();\n+          }\n+          rs.addRow(o);\n         }\n-    }\n-\n-    /**\n-     * Get the socket.\n-     *\n-     * @return the socket\n-     */\n-    public Socket getSocket() {\n-        return socket;\n-    }\n-\n-    /**\n-     * Set the session.\n-     *\n-     * @param session the session\n-     */\n-    public void setSession(SessionInterface session) {\n-        this.session = session;\n-    }\n-\n-    /**\n-     * Enable or disable SSL.\n-     *\n-     * @param ssl the new value\n-     */\n-    public void setSSL(boolean ssl) {\n-        this.ssl = ssl;\n-    }\n-\n-    /**\n-     * Open a new connection to the same address and port as this one.\n-     *\n-     * @return the new transfer object\n-     */\n-    public Transfer openNewConnection() throws IOException {\n-        InetAddress address = socket.getInetAddress();\n-        int port = socket.getPort();\n-        Socket s2 = NetUtils.createSocket(address, port, ssl);\n-        Transfer trans = new Transfer(null, s2);\n-        trans.setSSL(ssl);\n-        return trans;\n-    }\n-\n-    public void setVersion(int version) {\n-        this.version = version;\n-    }\n-\n-    public synchronized boolean isClosed() {\n-        return socket == null || socket.isClosed();\n-    }\n-\n-    /**\n-     * Verify the HMAC.\n-     *\n-     * @param hmac the message authentication code\n-     * @param lobId the lobId\n-     * @throws DbException if the HMAC does not match\n-     */\n-    public void verifyLobMac(byte[] hmac, long lobId) {\n-        byte[] result = calculateLobMac(lobId);\n-        if (!Utils.compareSecure(hmac,  result)) {\n-            throw DbException.get(ErrorCode.CONNECTION_BROKEN_1,\n-                    \"Invalid lob hmac; possibly the connection was re-opened internally\");\n+        return ValueResultSet.get(rs);\n+      }\n+      case GEOMETRY:\n+        if (version >= Constants.TCP_PROTOCOL_VERSION_14) {\n+          return ValueGeometry.get(readBytes());\n         }\n-    }\n-\n-    private byte[] calculateLobMac(long lobId) {\n-        if (lobMacSalt == null) {\n-            lobMacSalt = MathUtils.secureRandomBytes(LOB_MAC_SALT_LENGTH);\n+        return ValueGeometry.get(readString());\n+      case INTERVAL: {\n+        int ordinal = readByte();\n+        boolean negative = ordinal < 0;\n+        if (negative) {\n+          ordinal = ~ordinal;\n         }\n-        byte[] data = new byte[8];\n-        Bits.writeLong(data, 0, lobId);\n-        return SHA256.getHashWithSalt(data, lobMacSalt);\n-    }\n+        return ValueInterval.from(IntervalQualifier.valueOf(ordinal), negative, readLong(),\n+            ordinal < 5 ? 0 : readLong());\n+      }\n+      case JSON:\n+        // Do not trust the value\n+        return ValueJson.fromJson(readBytes());\n+      default:\n+        if (JdbcUtils.customDataTypesHandler != null) {\n+          return JdbcUtils.customDataTypesHandler.convert(\n+              ValueBytes.getNoCopy(readBytes()), type);\n+        }\n+        throw DbException.get(ErrorCode.CONNECTION_BROKEN_1, \"type=\" + type);\n+    }\n+  }\n+\n+  /**\n+   * Get the socket.\n+   *\n+   * @return the socket\n+   */\n+  public Socket getSocket() {\n+    return socket;\n+  }\n+\n+  /**\n+   * Set the session.\n+   *\n+   * @param session the session\n+   */\n+  public void setSession(SessionInterface session) {\n+    this.session = session;\n+  }\n+\n+  /**\n+   * Enable or disable SSL.\n+   *\n+   * @param ssl the new value\n+   */\n+  public void setSSL(boolean ssl) {\n+    this.ssl = ssl;\n+  }\n+\n+  /**\n+   * Open a new connection to the same address and port as this one.\n+   *\n+   * @return the new transfer object\n+   */\n+  public Transfer openNewConnection() throws IOException {\n+    InetAddress address = socket.getInetAddress();\n+    int port = socket.getPort();\n+    Socket s2 = NetUtils.createSocket(address, port, ssl);\n+    Transfer trans = new Transfer(null, s2);\n+    trans.setSSL(ssl);\n+    return trans;\n+  }\n+\n+  public void setVersion(int version) {\n+    this.version = version;\n+  }\n+\n+  public synchronized boolean isClosed() {\n+    return socket == null || socket.isClosed();\n+  }\n+\n+  /**\n+   * Verify the HMAC.\n+   *\n+   * @param hmac  the message authentication code\n+   * @param lobId the lobId\n+   * @throws DbException if the HMAC does not match\n+   */\n+  public void verifyLobMac(byte[] hmac, long lobId) {\n+    byte[] result = calculateLobMac(lobId);\n+    if (!Utils.compareSecure(hmac, result)) {\n+      throw DbException.get(ErrorCode.CONNECTION_BROKEN_1,\n+          \"Invalid lob hmac; possibly the connection was re-opened internally\");\n+    }\n+  }\n+\n+  private byte[] calculateLobMac(long lobId) {\n+    if (lobMacSalt == null) {\n+      lobMacSalt = MathUtils.secureRandomBytes(LOB_MAC_SALT_LENGTH);\n+    }\n+    byte[] data = new byte[8];\n+    Bits.writeLong(data, 0, lobId);\n+    return SHA256.getHashWithSalt(data, lobMacSalt);\n+  }\n \n }\n",
            "diff_size": 1274
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "420",
                    "column": "66",
                    "severity": "warning",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/397/Transfer.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_random/397/Transfer.java\nindex e39a7d9092e..9b9d6b0804c 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/397/Transfer.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_random/397/Transfer.java\n@@ -417,7 +417,7 @@ public class Transfer {\n             writeLong(ts.getDateValue());\n             writeLong(ts.getTimeNanos());\n             int timeZoneOffset = ts.getTimeZoneOffsetSeconds();\n-            writeInt(version >= Constants.TCP_PROTOCOL_VERSION_19 //\n+            writeInt(version >= Constants.TCP_PROTOCOL_VERSION_19//\n                     ? timeZoneOffset : timeZoneOffset / 60);\n             break;\n         }\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/397/Transfer.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/397/Transfer.java\nindex e39a7d9092e..35d2922ccdd 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/397/Transfer.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/397/Transfer.java\n@@ -417,8 +417,9 @@ public class Transfer {\n             writeLong(ts.getDateValue());\n             writeLong(ts.getTimeNanos());\n             int timeZoneOffset = ts.getTimeZoneOffsetSeconds();\n-            writeInt(version >= Constants.TCP_PROTOCOL_VERSION_19 //\n-                    ? timeZoneOffset : timeZoneOffset / 60);\n+            writeInt(version >= Constants.TCP_PROTOCOL_VERSION_19\n+                    //\n+                     ? timeZoneOffset : timeZoneOffset / 60);\n             break;\n         }\n         case Value.DECIMAL:\n",
            "diff_size": 3
        }
    ],
    "repaired_by": [
        "styler",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random"
    ]
}