{
    "project_name": "IQSS-dataverse",
    "error_id": "46",
    "information": {
        "errors": [
            {
                "line": "192",
                "column": "1",
                "severity": "error",
                "message": "File contains tab characters (this is the first instance).",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
            }
        ]
    },
    "source_code": "     */\n    private String getPrimaryEmail(Document doc) {\n\t    // `xmlstarlet sel -t -c \"/record:record/person:person/email:emails/email:email[@primary='true']/email:email\"`, if you're curious\n\t    String p = \"/person/emails/email[@primary='true']/email/text()\";\n\t    NodeList emails = xpathMatches( doc, p );\n\t    String primaryEmail  = \"\";",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "194",
                    "column": "1",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/46/OrcidOAuth2AP.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler/46/OrcidOAuth2AP.java\nindex 02177ee0032..5e51860d6f0 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/46/OrcidOAuth2AP.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler/46/OrcidOAuth2AP.java\n@@ -189,8 +189,8 @@ public class OrcidOAuth2AP extends AbstractOAuth2AuthenticationProvider {\n      * retrieve email from ORCID 2.0 response document, or empty string if no primary email is present\n      */\n     private String getPrimaryEmail(Document doc) {\n-\t    // `xmlstarlet sel -t -c \"/record:record/person:person/email:emails/email:email[@primary='true']/email:email\"`, if you're curious\n-\t    String p = \"/person/emails/email[@primary='true']/email/text()\";\n+       // `xmlstarlet sel -t -c \"/record:record/person:person/email:emails/email:email[@primary='true']/email:email\"`, if you're curious\n+     String p = \"/person/emails/email[@primary='true']/email/text()\";\n \t    NodeList emails = xpathMatches( doc, p );\n \t    String primaryEmail  = \"\";\n \t    if ( 1 == emails.getLength() ) {\n",
            "diff_size": 2
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/46/OrcidOAuth2AP.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/intellij/46/OrcidOAuth2AP.java\nindex 02177ee0032..d3813fef6e9 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/46/OrcidOAuth2AP.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/intellij/46/OrcidOAuth2AP.java\n@@ -43,290 +43,296 @@ import javax.xml.xpath.XPathExpression;\n /**\n  * OAuth2 identity provider for ORCiD. Note that ORCiD has two systems: sandbox\n  * and production. Hence having the user endpoint as a parameter.\n- * \n+ *\n  * @author michael\n  * @author pameyer\n  */\n public class OrcidOAuth2AP extends AbstractOAuth2AuthenticationProvider {\n-    \n-    final static Logger logger = Logger.getLogger(OrcidOAuth2AP.class.getName());\n-\n-    public static final String PROVIDER_ID_PRODUCTION = \"orcid\";\n-    public static final String PROVIDER_ID_SANDBOX = \"orcid-sandbox\";\n-    \n-    public OrcidOAuth2AP(String clientId, String clientSecret, String userEndpoint) {\n-    \n-        if(userEndpoint != null && userEndpoint.startsWith(\"https://pub\")) {\n-            this.scope = Arrays.asList(\"/authenticate\");\n-        } else {\n-            this.scope = Arrays.asList(\"/read-limited\");\n-        }\n-        \n-        this.clientId = clientId;\n-        this.clientSecret = clientSecret;\n-        this.baseUserEndpoint = userEndpoint;\n-    }\n-    \n-    @Override\n-    public String getUserEndpoint( OAuth2AccessToken token )  {\n-        try ( StringReader sRdr = new StringReader(token.getRawResponse());\n-                JsonReader jRdr = Json.createReader(sRdr) ) {\n-            String orcid = jRdr.readObject().getString(\"orcid\");\n-            return baseUserEndpoint.replace(\"{ORCID}\", orcid);\n-        }\n-    }\n-    \n-    @Override\n-    public DefaultApi20 getApiInstance() {\n-        return OrcidApi.instance( ! baseUserEndpoint.contains(\"sandbox\") );\n-    }\n-    \n-    @Override\n-    final protected OAuth2UserRecord getUserRecord(@NotNull String responseBody, @NotNull OAuth2AccessToken accessToken, @NotNull OAuth20Service service)\n-        throws OAuth2Exception {\n-        \n-        // parse the main response\n-        final ParsedUserResponse parsed = parseUserResponse(responseBody);\n-        \n-        // mixin org data, but optional\n-        try {\n-            Optional<AuthenticatedUserDisplayInfo> orgData = getOrganizationalData(accessToken, service);\n-            if (orgData.isPresent()) {\n-                parsed.displayInfo.setAffiliation(orgData.get().getAffiliation());\n-                parsed.displayInfo.setPosition(orgData.get().getPosition());\n-            }\n-        } catch (IOException ex) {\n-            logger.log(Level.WARNING, \"Could not get affiliation data from ORCiD due to an IO problem: {0}\", ex.getLocalizedMessage());\n-        }\n-        \n-        // mixin ORCiD not present in main response\n-        String orcidNumber = extractOrcidNumber(accessToken.getRawResponse());\n-    \n-        return new OAuth2UserRecord(getId(), orcidNumber,\n-            parsed.username,\n-            OAuth2TokenData.from(accessToken),\n-            parsed.displayInfo,\n-            parsed.emails);\n-    }\n-    \n-    @Override\n-    protected ParsedUserResponse parseUserResponse(String responseBody) {\n-        DocumentBuilderFactory dbFact = DocumentBuilderFactory.newInstance();\n-        try ( StringReader reader = new StringReader(responseBody)) {\n-            DocumentBuilder db = dbFact.newDocumentBuilder();\n-            Document doc = db.parse( new InputSource(reader) );\n-            \n-            String firstName = getNodes(doc, \"person:person\", \"person:name\", \"personal-details:given-names\" )\n-                                .stream().findFirst().map( Node::getTextContent )\n-                                    .map( String::trim ).orElse(\"\");\n-            String familyName = getNodes(doc, \"person:person\", \"person:name\", \"personal-details:family-name\")\n-                                .stream().findFirst().map( Node::getTextContent )\n-                                    .map( String::trim ).orElse(\"\");\n-            \n-            // fallback - try to use the credit-name\n-            if ( (firstName + familyName).equals(\"\") ) {\n-                firstName = getNodes(doc, \"person:person\", \"person:name\", \"personal-details:credit-name\" )\n-                                .stream().findFirst().map( Node::getTextContent )\n-                                    .map( String::trim ).orElse(\"\");\n-            }\n-            \n-            String primaryEmail = getPrimaryEmail(doc);\n-            List<String> emails = getAllEmails(doc);\n-            \n-            // make the username up\n-            String username;\n-            if ( primaryEmail.length() > 0 ) {\n-                username = primaryEmail.split(\"@\")[0];\n-            } else {\n-                username = firstName.split(\" \")[0] + \".\" + familyName;\n-            }\n-            username = username.replaceAll(\"[^a-zA-Z0-9.]\",\"\");\n-            \n-            // returning the parsed user. The user-id-in-provider will be added by the caller, since ORCiD passes it\n-            // on the access token response.\n-            // Affilifation added after a later call.\n-            final ParsedUserResponse userResponse = new ParsedUserResponse(\n-                    new AuthenticatedUserDisplayInfo(firstName, familyName, primaryEmail, \"\", \"\"), null, username);\n-            userResponse.emails.addAll(emails);\n-            \n-            return userResponse;\n-            \n-        } catch (SAXException ex) {\n-            logger.log(Level.SEVERE, \"XML error parsing response body from ORCiD: \" + ex.getMessage(), ex);\n-        } catch (IOException ex) {\n-            logger.log(Level.SEVERE, \"I/O error parsing response body from ORCiD: \" + ex.getMessage(), ex);\n-        } catch (ParserConfigurationException ex) {\n-            logger.log(Level.SEVERE, \"While parsing the ORCiD response: Bad parse configuration. \" + ex.getMessage(), ex);\n-        }\n-        \n-        return null;\n-    }\n-    \n-    private List<Node> getNodes( Node node, String... path ) {\n-        return getNodes( node, Arrays.asList(path) );\n-    }\n-    \n-    private List<Node> getNodes( Node node, List<String> path ) {\n-        NodeList childs = node.getChildNodes();\n-        final Stream<Node> nodeStream = IntStream.range(0, childs.getLength())\n-                .mapToObj( childs::item )\n-                .filter( n -> n.getNodeName().equals(path.get(0)) );\n-        \n-        if ( path.size() == 1 ) {\n-            // accumulate and return mode\n-            return nodeStream.collect( Collectors.toList() );\n-            \n-        } else {\n-            // dig-in mode.\n-            return nodeStream.findFirst()\n-                             .map( n -> getNodes(n, path.subList(1, path.size())))\n-                             .orElse( Collections.<Node>emptyList() );\n-        }\n-        \n-    }\n-    \n-    /**\n-     * retrieve email from ORCID 2.0 response document, or empty string if no primary email is present\n-     */\n-    private String getPrimaryEmail(Document doc) {\n-\t    // `xmlstarlet sel -t -c \"/record:record/person:person/email:emails/email:email[@primary='true']/email:email\"`, if you're curious\n-\t    String p = \"/person/emails/email[@primary='true']/email/text()\";\n-\t    NodeList emails = xpathMatches( doc, p );\n-\t    String primaryEmail  = \"\";\n-\t    if ( 1 == emails.getLength() ) {\n-\t\t    primaryEmail = emails.item(0).getTextContent();\n-\t    }\n-\t    // if there are no (or somehow more than 1) primary email(s), then we've already at failure value\n-\t    return primaryEmail;\n+\n+  final static Logger logger = Logger.getLogger(OrcidOAuth2AP.class.getName());\n+\n+  public static final String PROVIDER_ID_PRODUCTION = \"orcid\";\n+  public static final String PROVIDER_ID_SANDBOX = \"orcid-sandbox\";\n+\n+  public OrcidOAuth2AP(String clientId, String clientSecret, String userEndpoint) {\n+\n+    if (userEndpoint != null && userEndpoint.startsWith(\"https://pub\")) {\n+      this.scope = Arrays.asList(\"/authenticate\");\n+    } else {\n+      this.scope = Arrays.asList(\"/read-limited\");\n     }\n-    \n-    /**\n-     * retrieve all emails (including primary) from ORCID 2.0 response document\n-     */\n-    private List<String> getAllEmails(Document doc) {\n-\t    String p = \"/person/emails/email/email/text()\";\n-\t    NodeList emails = xpathMatches( doc, p );\n-\t    List<String> rs = new ArrayList<>();\n-\t    for(int i=0;i<emails.getLength(); ++i) { // no iterator in NodeList\n-\t\t    rs.add( emails.item(i).getTextContent() );\n-\t    }\n-\t    return rs;\n+\n+    this.clientId = clientId;\n+    this.clientSecret = clientSecret;\n+    this.baseUserEndpoint = userEndpoint;\n+  }\n+\n+  @Override\n+  public String getUserEndpoint(OAuth2AccessToken token) {\n+    try (StringReader sRdr = new StringReader(token.getRawResponse());\n+         JsonReader jRdr = Json.createReader(sRdr)) {\n+      String orcid = jRdr.readObject().getString(\"orcid\");\n+      return baseUserEndpoint.replace(\"{ORCID}\", orcid);\n     }\n-    \n-    /**\n-     * xpath search wrapper; return list of nodes matching an xpath expression (or null, \n-     * if there are no matches)\n-     */\n-    private NodeList xpathMatches(Document doc, String pattern) {\n-\t    XPathFactory xpf = XPathFactory.newInstance();\n-\t    XPath xp = xpf.newXPath();\n-\t    NodeList matches = null;\n-\t    try {\n-\t\t    XPathExpression srch = xp.compile( pattern );\n-\t\t    matches = (NodeList) srch.evaluate(doc, XPathConstants.NODESET);\n-            \n-\t    } catch( javax.xml.xpath.XPathExpressionException xpe ) {\n-\t\t    //no-op; intended for hard-coded xpath expressions that won't change at runtime\n-\t    }\n-\t    return matches;\n+  }\n+\n+  @Override\n+  public DefaultApi20 getApiInstance() {\n+    return OrcidApi.instance(!baseUserEndpoint.contains(\"sandbox\"));\n+  }\n+\n+  @Override\n+  final protected OAuth2UserRecord getUserRecord(@NotNull String responseBody, @NotNull OAuth2AccessToken accessToken,\n+                                                 @NotNull OAuth20Service service)\n+    throws OAuth2Exception {\n+\n+    // parse the main response\n+    final ParsedUserResponse parsed = parseUserResponse(responseBody);\n+\n+    // mixin org data, but optional\n+    try {\n+      Optional<AuthenticatedUserDisplayInfo> orgData = getOrganizationalData(accessToken, service);\n+      if (orgData.isPresent()) {\n+        parsed.displayInfo.setAffiliation(orgData.get().getAffiliation());\n+        parsed.displayInfo.setPosition(orgData.get().getPosition());\n+      }\n+    } catch (IOException ex) {\n+      logger.log(Level.WARNING, \"Could not get affiliation data from ORCiD due to an IO problem: {0}\",\n+        ex.getLocalizedMessage());\n     }\n \n-    @Override\n-    public AuthenticationProviderDisplayInfo getInfo() {\n-        if (PROVIDER_ID_PRODUCTION.equals(getId())) {\n-            return new AuthenticationProviderDisplayInfo(getId(), BundleUtil.getStringFromBundle(\"auth.providers.title.orcid\"), \"ORCID user repository\");\n-        }\n-        return new AuthenticationProviderDisplayInfo(getId(), \"ORCID Sandbox\", \"ORCID dev sandbox \");\n+    // mixin ORCiD not present in main response\n+    String orcidNumber = extractOrcidNumber(accessToken.getRawResponse());\n+\n+    return new OAuth2UserRecord(getId(), orcidNumber,\n+      parsed.username,\n+      OAuth2TokenData.from(accessToken),\n+      parsed.displayInfo,\n+      parsed.emails);\n+  }\n+\n+  @Override\n+  protected ParsedUserResponse parseUserResponse(String responseBody) {\n+    DocumentBuilderFactory dbFact = DocumentBuilderFactory.newInstance();\n+    try (StringReader reader = new StringReader(responseBody)) {\n+      DocumentBuilder db = dbFact.newDocumentBuilder();\n+      Document doc = db.parse(new InputSource(reader));\n+\n+      String firstName = getNodes(doc, \"person:person\", \"person:name\", \"personal-details:given-names\")\n+        .stream().findFirst().map(Node::getTextContent)\n+        .map(String::trim).orElse(\"\");\n+      String familyName = getNodes(doc, \"person:person\", \"person:name\", \"personal-details:family-name\")\n+        .stream().findFirst().map(Node::getTextContent)\n+        .map(String::trim).orElse(\"\");\n+\n+      // fallback - try to use the credit-name\n+      if ((firstName + familyName).equals(\"\")) {\n+        firstName = getNodes(doc, \"person:person\", \"person:name\", \"personal-details:credit-name\")\n+          .stream().findFirst().map(Node::getTextContent)\n+          .map(String::trim).orElse(\"\");\n+      }\n+\n+      String primaryEmail = getPrimaryEmail(doc);\n+      List<String> emails = getAllEmails(doc);\n+\n+      // make the username up\n+      String username;\n+      if (primaryEmail.length() > 0) {\n+        username = primaryEmail.split(\"@\")[0];\n+      } else {\n+        username = firstName.split(\" \")[0] + \".\" + familyName;\n+      }\n+      username = username.replaceAll(\"[^a-zA-Z0-9.]\", \"\");\n+\n+      // returning the parsed user. The user-id-in-provider will be added by the caller, since ORCiD passes it\n+      // on the access token response.\n+      // Affilifation added after a later call.\n+      final ParsedUserResponse userResponse = new ParsedUserResponse(\n+        new AuthenticatedUserDisplayInfo(firstName, familyName, primaryEmail, \"\", \"\"), null, username);\n+      userResponse.emails.addAll(emails);\n+\n+      return userResponse;\n+\n+    } catch (SAXException ex) {\n+      logger.log(Level.SEVERE, \"XML error parsing response body from ORCiD: \" + ex.getMessage(), ex);\n+    } catch (IOException ex) {\n+      logger.log(Level.SEVERE, \"I/O error parsing response body from ORCiD: \" + ex.getMessage(), ex);\n+    } catch (ParserConfigurationException ex) {\n+      logger.log(Level.SEVERE, \"While parsing the ORCiD response: Bad parse configuration. \" + ex.getMessage(), ex);\n     }\n \n-    @Override\n-    public boolean isDisplayIdentifier() {\n-        return true;\n+    return null;\n+  }\n+\n+  private List<Node> getNodes(Node node, String... path) {\n+    return getNodes(node, Arrays.asList(path));\n+  }\n+\n+  private List<Node> getNodes(Node node, List<String> path) {\n+    NodeList childs = node.getChildNodes();\n+    final Stream<Node> nodeStream = IntStream.range(0, childs.getLength())\n+      .mapToObj(childs::item)\n+      .filter(n -> n.getNodeName().equals(path.get(0)));\n+\n+    if (path.size() == 1) {\n+      // accumulate and return mode\n+      return nodeStream.collect(Collectors.toList());\n+\n+    } else {\n+      // dig-in mode.\n+      return nodeStream.findFirst()\n+        .map(n -> getNodes(n, path.subList(1, path.size())))\n+        .orElse(Collections.<Node>emptyList());\n     }\n \n-    @Override\n-    public String getPersistentIdName() {\n-        return BundleUtil.getStringFromBundle(\"auth.providers.persistentUserIdName.orcid\");\n+  }\n+\n+  /**\n+   * retrieve email from ORCID 2.0 response document, or empty string if no primary email is present\n+   */\n+  private String getPrimaryEmail(Document doc) {\n+    // `xmlstarlet sel -t -c \"/record:record/person:person/email:emails/email:email[@primary='true']/email:email\"`, if you're curious\n+    String p = \"/person/emails/email[@primary='true']/email/text()\";\n+    NodeList emails = xpathMatches(doc, p);\n+    String primaryEmail = \"\";\n+    if (1 == emails.getLength()) {\n+      primaryEmail = emails.item(0).getTextContent();\n     }\n+    // if there are no (or somehow more than 1) primary email(s), then we've already at failure value\n+    return primaryEmail;\n+  }\n \n-    @Override\n-    public String getPersistentIdDescription() {\n-        return BundleUtil.getStringFromBundle(\"auth.providers.persistentUserIdTooltip.orcid\");\n+  /**\n+   * retrieve all emails (including primary) from ORCID 2.0 response document\n+   */\n+  private List<String> getAllEmails(Document doc) {\n+    String p = \"/person/emails/email/email/text()\";\n+    NodeList emails = xpathMatches(doc, p);\n+    List<String> rs = new ArrayList<>();\n+    for (int i = 0; i < emails.getLength(); ++i) { // no iterator in NodeList\n+      rs.add(emails.item(i).getTextContent());\n     }\n+    return rs;\n+  }\n \n-    @Override\n-    public String getPersistentIdUrlPrefix() {\n-        return \"https://orcid.org/\";\n+  /**\n+   * xpath search wrapper; return list of nodes matching an xpath expression (or null,\n+   * if there are no matches)\n+   */\n+  private NodeList xpathMatches(Document doc, String pattern) {\n+    XPathFactory xpf = XPathFactory.newInstance();\n+    XPath xp = xpf.newXPath();\n+    NodeList matches = null;\n+    try {\n+      XPathExpression srch = xp.compile(pattern);\n+      matches = (NodeList) srch.evaluate(doc, XPathConstants.NODESET);\n+\n+    } catch (javax.xml.xpath.XPathExpressionException xpe) {\n+      //no-op; intended for hard-coded xpath expressions that won't change at runtime\n     }\n+    return matches;\n+  }\n \n-    @Override\n-    public String getLogo() {\n-        return \"/resources/images/orcid_16x16.png\";\n+  @Override\n+  public AuthenticationProviderDisplayInfo getInfo() {\n+    if (PROVIDER_ID_PRODUCTION.equals(getId())) {\n+      return new AuthenticationProviderDisplayInfo(getId(),\n+        BundleUtil.getStringFromBundle(\"auth.providers.title.orcid\"), \"ORCID user repository\");\n     }\n-    \n-    protected String extractOrcidNumber( String rawResponse ) throws OAuth2Exception {\n-        try ( JsonReader rdr = Json.createReader( new StringReader(rawResponse)) ) {\n-            JsonObject tokenData = rdr.readObject();\n-            return tokenData.getString(\"orcid\");\n-        } catch ( Exception e ) {\n-            throw new OAuth2Exception(0, rawResponse, \"Cannot find ORCiD id in access token response.\");\n-        }\n+    return new AuthenticationProviderDisplayInfo(getId(), \"ORCID Sandbox\", \"ORCID dev sandbox \");\n+  }\n+\n+  @Override\n+  public boolean isDisplayIdentifier() {\n+    return true;\n+  }\n+\n+  @Override\n+  public String getPersistentIdName() {\n+    return BundleUtil.getStringFromBundle(\"auth.providers.persistentUserIdName.orcid\");\n+  }\n+\n+  @Override\n+  public String getPersistentIdDescription() {\n+    return BundleUtil.getStringFromBundle(\"auth.providers.persistentUserIdTooltip.orcid\");\n+  }\n+\n+  @Override\n+  public String getPersistentIdUrlPrefix() {\n+    return \"https://orcid.org/\";\n+  }\n+\n+  @Override\n+  public String getLogo() {\n+    return \"/resources/images/orcid_16x16.png\";\n+  }\n+\n+  protected String extractOrcidNumber(String rawResponse) throws OAuth2Exception {\n+    try (JsonReader rdr = Json.createReader(new StringReader(rawResponse))) {\n+      JsonObject tokenData = rdr.readObject();\n+      return tokenData.getString(\"orcid\");\n+    } catch (Exception e) {\n+      throw new OAuth2Exception(0, rawResponse, \"Cannot find ORCiD id in access token response.\");\n     }\n+  }\n+\n+  protected Optional<AuthenticatedUserDisplayInfo> getOrganizationalData(OAuth2AccessToken accessToken,\n+                                                                         OAuth20Service service) throws IOException {\n+\n+    OAuthRequest request = new OAuthRequest(Verb.GET, getUserEndpoint(accessToken).replace(\"/person\", \"/employments\"));\n+    request.setCharset(\"UTF-8\");\n+    service.signRequest(accessToken, request);\n \n-    protected Optional<AuthenticatedUserDisplayInfo> getOrganizationalData(OAuth2AccessToken accessToken, OAuth20Service service) throws IOException {\n-        \n-        OAuthRequest request = new OAuthRequest(Verb.GET, getUserEndpoint(accessToken).replace(\"/person\", \"/employments\"));\n-        request.setCharset(\"UTF-8\");\n-        service.signRequest(accessToken, request);\n-        \n-        try {\n-            Response response = service.execute(request);\n-            int responseCode = response.getCode();\n-            String responseBody = response.getBody();\n-    \n-            if (responseCode != 200 && responseBody != null) {\n-                // This is bad, but not bad enough to stop a signup/in process.\n-                logger.log(Level.WARNING, \"Cannot get affiliation data from ORCiD. Response code: {0} body:\\n{1}\\n/body\",\n-                    new Object[]{responseCode, responseBody});\n-                return Optional.empty();\n-                \n-            } else {\n-                return Optional.of(parseActivitiesResponse(responseBody));\n-            }\n-        } catch (InterruptedException | ExecutionException ex) {\n-            logger.log(Level.WARNING, \"Could not get affiliation data from ORCiD due to threading problems.\");\n-            return Optional.empty();\n-        }\n+    try {\n+      Response response = service.execute(request);\n+      int responseCode = response.getCode();\n+      String responseBody = response.getBody();\n+\n+      if (responseCode != 200 && responseBody != null) {\n+        // This is bad, but not bad enough to stop a signup/in process.\n+        logger.log(Level.WARNING, \"Cannot get affiliation data from ORCiD. Response code: {0} body:\\n{1}\\n/body\",\n+          new Object[] {responseCode, responseBody});\n+        return Optional.empty();\n+\n+      } else {\n+        return Optional.of(parseActivitiesResponse(responseBody));\n+      }\n+    } catch (InterruptedException | ExecutionException ex) {\n+      logger.log(Level.WARNING, \"Could not get affiliation data from ORCiD due to threading problems.\");\n+      return Optional.empty();\n     }\n-    \n-    protected AuthenticatedUserDisplayInfo parseActivitiesResponse( String responseBody ) {\n-        DocumentBuilderFactory dbFact = DocumentBuilderFactory.newInstance();\n-        \n-        try ( StringReader reader = new StringReader(responseBody)) {\n-            DocumentBuilder db = dbFact.newDocumentBuilder();\n-            Document doc = db.parse( new InputSource(reader) );\n-            String organization = getNodes(doc, \"activities:employments\", \n-                                  \"employment:employment-summary\", \"employment:organization\", \"common:name\")\n-                    .stream().findFirst().map( Node::getTextContent )\n-                    .map( String::trim ).orElse(null);\n-            \n-            String department = getNodes(doc, \"activities:employments\", \"employment:employment-summary\", \"employment:department-name\").stream()\n-                                    .findFirst().map( Node::getTextContent ).map( String::trim ).orElse(null);\n-            String role = getNodes(doc, \"activities:employments\", \"employment:employment-summary\", \"employment:role-title\").stream()\n-                                    .findFirst().map( Node::getTextContent ).map( String::trim ).orElse(null);\n-            \n-            String position = Stream.of(role, department).filter(Objects::nonNull).collect( joining(\", \"));\n-            \n-            return new AuthenticatedUserDisplayInfo(null, null, null, organization, position);\n-            \n-        } catch (SAXException ex) {\n-            logger.log(Level.SEVERE, \"XML error parsing response body from ORCiD: \" + ex.getMessage(), ex);\n-        } catch (IOException ex) {\n-            logger.log(Level.SEVERE, \"I/O error parsing response body from ORCiD: \" + ex.getMessage(), ex);\n-        } catch (ParserConfigurationException ex) {\n-            logger.log(Level.SEVERE, \"While parsing the ORCiD response: Bad parse configuration. \" + ex.getMessage(), ex);\n-        }\n-        \n-        return null;   \n+  }\n+\n+  protected AuthenticatedUserDisplayInfo parseActivitiesResponse(String responseBody) {\n+    DocumentBuilderFactory dbFact = DocumentBuilderFactory.newInstance();\n+\n+    try (StringReader reader = new StringReader(responseBody)) {\n+      DocumentBuilder db = dbFact.newDocumentBuilder();\n+      Document doc = db.parse(new InputSource(reader));\n+      String organization = getNodes(doc, \"activities:employments\",\n+        \"employment:employment-summary\", \"employment:organization\", \"common:name\")\n+        .stream().findFirst().map(Node::getTextContent)\n+        .map(String::trim).orElse(null);\n+\n+      String department =\n+        getNodes(doc, \"activities:employments\", \"employment:employment-summary\", \"employment:department-name\").stream()\n+          .findFirst().map(Node::getTextContent).map(String::trim).orElse(null);\n+      String role =\n+        getNodes(doc, \"activities:employments\", \"employment:employment-summary\", \"employment:role-title\").stream()\n+          .findFirst().map(Node::getTextContent).map(String::trim).orElse(null);\n+\n+      String position = Stream.of(role, department).filter(Objects::nonNull).collect(joining(\", \"));\n+\n+      return new AuthenticatedUserDisplayInfo(null, null, null, organization, position);\n+\n+    } catch (SAXException ex) {\n+      logger.log(Level.SEVERE, \"XML error parsing response body from ORCiD: \" + ex.getMessage(), ex);\n+    } catch (IOException ex) {\n+      logger.log(Level.SEVERE, \"I/O error parsing response body from ORCiD: \" + ex.getMessage(), ex);\n+    } catch (ParserConfigurationException ex) {\n+      logger.log(Level.SEVERE, \"While parsing the ORCiD response: Bad parse configuration. \" + ex.getMessage(), ex);\n     }\n+\n+    return null;\n+  }\n }\n",
            "diff_size": 414
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "194",
                    "column": "1",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/46/OrcidOAuth2AP.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_random/46/OrcidOAuth2AP.java\nindex 02177ee0032..5e51860d6f0 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/46/OrcidOAuth2AP.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_random/46/OrcidOAuth2AP.java\n@@ -189,8 +189,8 @@ public class OrcidOAuth2AP extends AbstractOAuth2AuthenticationProvider {\n      * retrieve email from ORCID 2.0 response document, or empty string if no primary email is present\n      */\n     private String getPrimaryEmail(Document doc) {\n-\t    // `xmlstarlet sel -t -c \"/record:record/person:person/email:emails/email:email[@primary='true']/email:email\"`, if you're curious\n-\t    String p = \"/person/emails/email[@primary='true']/email/text()\";\n+       // `xmlstarlet sel -t -c \"/record:record/person:person/email:emails/email:email[@primary='true']/email:email\"`, if you're curious\n+     String p = \"/person/emails/email[@primary='true']/email/text()\";\n \t    NodeList emails = xpathMatches( doc, p );\n \t    String primaryEmail  = \"\";\n \t    if ( 1 == emails.getLength() ) {\n",
            "diff_size": 2
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "194",
                    "column": "1",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/46/OrcidOAuth2AP.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_three_grams/46/OrcidOAuth2AP.java\nindex 02177ee0032..bed1d837ca5 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/46/OrcidOAuth2AP.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_three_grams/46/OrcidOAuth2AP.java\n@@ -189,8 +189,8 @@ public class OrcidOAuth2AP extends AbstractOAuth2AuthenticationProvider {\n      * retrieve email from ORCID 2.0 response document, or empty string if no primary email is present\n      */\n     private String getPrimaryEmail(Document doc) {\n-\t    // `xmlstarlet sel -t -c \"/record:record/person:person/email:emails/email:email[@primary='true']/email:email\"`, if you're curious\n-\t    String p = \"/person/emails/email[@primary='true']/email/text()\";\n+        // `xmlstarlet sel -t -c \"/record:record/person:person/email:emails/email:email[@primary='true']/email:email\"`, if you're curious\n+     String p = \"/person/emails/email[@primary='true']/email/text()\";\n \t    NodeList emails = xpathMatches( doc, p );\n \t    String primaryEmail  = \"\";\n \t    if ( 1 == emails.getLength() ) {\n",
            "diff_size": 2
        }
    ],
    "repaired_by": [
        "intellij"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}