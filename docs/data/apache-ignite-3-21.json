{
    "project_name": "apache-ignite-3",
    "error_id": "21",
    "information": {
        "errors": [
            {
                "line": "24",
                "column": "5",
                "severity": "error",
                "message": "'VARIABLE_DEF' should be separated from previous line.",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.EmptyLineSeparatorCheck"
            }
        ]
    },
    "source_code": "public class StringUtils {\n    public static final String EMPTY = \"\";\n    public static final String[] EMPTY_STRING_ARRAY = new String[0];\n\n    public StringUtils() {\n    }",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/errored/1/21/StringUtils.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/styler/21/StringUtils.java\nindex e6834fa510f..9aa45492689 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/errored/1/21/StringUtils.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/styler/21/StringUtils.java\n@@ -21,6 +21,7 @@ import java.util.List;\n \n public class StringUtils {\n     public static final String EMPTY = \"\";\n+\n     public static final String[] EMPTY_STRING_ARRAY = new String[0];\n \n     public StringUtils() {\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/errored/1/21/StringUtils.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/intellij/21/StringUtils.java\nindex e6834fa510f..4324a673a05 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/errored/1/21/StringUtils.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/intellij/21/StringUtils.java\n@@ -14,348 +14,343 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+\n package org.apache.ignite.raft.jraft.util;\n \n import java.util.ArrayList;\n import java.util.List;\n \n public class StringUtils {\n-    public static final String EMPTY = \"\";\n-    public static final String[] EMPTY_STRING_ARRAY = new String[0];\n+  public static final String EMPTY = \"\";\n \n-    public StringUtils() {\n-    }\n+  public static final String[] EMPTY_STRING_ARRAY = new String[0];\n \n-    public static boolean isEmpty(CharSequence cs) {\n-        return cs == null || cs.length() == 0;\n-    }\n+  public StringUtils() {\n+  }\n \n-    public static boolean isNotEmpty(CharSequence cs) {\n-        return !isEmpty(cs);\n-    }\n+  public static boolean isEmpty(CharSequence cs) {\n+    return cs == null || cs.length() == 0;\n+  }\n \n-    public static boolean isBlank(CharSequence cs) {\n-        int strLen;\n-        if (cs != null && (strLen = cs.length()) != 0) {\n-            for (int i = 0; i < strLen; ++i) {\n-                if (!Character.isWhitespace(cs.charAt(i))) {\n-                    return false;\n-                }\n-            }\n+  public static boolean isNotEmpty(CharSequence cs) {\n+    return !isEmpty(cs);\n+  }\n \n-            return true;\n+  public static boolean isBlank(CharSequence cs) {\n+    int strLen;\n+    if (cs != null && (strLen = cs.length()) != 0) {\n+      for (int i = 0; i < strLen; ++i) {\n+        if (!Character.isWhitespace(cs.charAt(i))) {\n+          return false;\n         }\n-        else {\n-            return true;\n-        }\n-    }\n+      }\n \n-    public static boolean isNotBlank(CharSequence cs) {\n-        return !isBlank(cs);\n+      return true;\n+    } else {\n+      return true;\n     }\n+  }\n \n-    public static String[] split(String str, char separatorChar) {\n-        return splitWorker(str, separatorChar, false);\n-    }\n+  public static boolean isNotBlank(CharSequence cs) {\n+    return !isBlank(cs);\n+  }\n \n-    private static String[] splitWorker(String str, char separatorChar, boolean preserveAllTokens) {\n-        if (str == null) {\n-            return null;\n-        }\n-        else {\n-            int len = str.length();\n-            if (len == 0) {\n-                return EMPTY_STRING_ARRAY;\n-            }\n-            else {\n-                List<String> list = new ArrayList();\n-                int i = 0;\n-                int start = 0;\n-                boolean match = false;\n-                boolean lastMatch = false;\n+  public static String[] split(String str, char separatorChar) {\n+    return splitWorker(str, separatorChar, false);\n+  }\n \n-                while (true) {\n-                    while (i < len) {\n-                        if (str.charAt(i) == separatorChar) {\n-                            if (match || preserveAllTokens) {\n-                                list.add(str.substring(start, i));\n-                                match = false;\n-                                lastMatch = true;\n-                            }\n-\n-                            ++i;\n-                            start = i;\n-                        }\n-                        else {\n-                            lastMatch = false;\n-                            match = true;\n-                            ++i;\n-                        }\n-                    }\n+  private static String[] splitWorker(String str, char separatorChar, boolean preserveAllTokens) {\n+    if (str == null) {\n+      return null;\n+    } else {\n+      int len = str.length();\n+      if (len == 0) {\n+        return EMPTY_STRING_ARRAY;\n+      } else {\n+        List<String> list = new ArrayList();\n+        int i = 0;\n+        int start = 0;\n+        boolean match = false;\n+        boolean lastMatch = false;\n \n-                    if (match || preserveAllTokens && lastMatch) {\n-                        list.add(str.substring(start, i));\n-                    }\n+        while (true) {\n+          while (i < len) {\n+            if (str.charAt(i) == separatorChar) {\n+              if (match || preserveAllTokens) {\n+                list.add(str.substring(start, i));\n+                match = false;\n+                lastMatch = true;\n+              }\n \n-                    return (String[]) list.toArray(new String[list.size()]);\n-                }\n+              ++i;\n+              start = i;\n+            } else {\n+              lastMatch = false;\n+              match = true;\n+              ++i;\n             }\n-        }\n-    }\n+          }\n \n-    public static boolean isNumeric(String str) {\n-        if (str == null) {\n-            return false;\n+          if (match || preserveAllTokens && lastMatch) {\n+            list.add(str.substring(start, i));\n+          }\n+\n+          return (String[]) list.toArray(new String[list.size()]);\n         }\n-        else {\n-            int sz = str.length();\n+      }\n+    }\n+  }\n \n-            for (int i = 0; i < sz; ++i) {\n-                if (!Character.isDigit(str.charAt(i))) {\n-                    return false;\n-                }\n-            }\n+  public static boolean isNumeric(String str) {\n+    if (str == null) {\n+      return false;\n+    } else {\n+      int sz = str.length();\n \n-            return true;\n+      for (int i = 0; i < sz; ++i) {\n+        if (!Character.isDigit(str.charAt(i))) {\n+          return false;\n         }\n-    }\n+      }\n \n-    public static boolean equals(String str1, String str2) {\n-        return str1 == null ? str2 == null : str1.equals(str2);\n+      return true;\n     }\n+  }\n \n-    /**\n-     * <p>Splits the provided text into an array with a maximum length,\n-     * separators specified, preserving all tokens, including empty tokens created by adjacent separators.</p>\n-     *\n-     * <p>The separator is not included in the returned String array.\n-     * Adjacent separators are treated as separators for empty tokens. Adjacent separators are treated as one\n-     * separator.</p>\n-     *\n-     * <p>A <code>null</code> input String returns <code>null</code>.\n-     * A <code>null</code> separatorChars splits on whitespace.</p>\n-     *\n-     * <p>If more than <code>max</code> delimited substrings are found, the last\n-     * returned string includes all characters after the first <code>max - 1</code> returned strings (including\n-     * separator characters).</p>\n-     *\n-     * <pre>\n-     * StringUtils.splitPreserveAllTokens(null, *, *)            = null\n-     * StringUtils.splitPreserveAllTokens(\"\", *, *)              = []\n-     * StringUtils.splitPreserveAllTokens(\"ab de fg\", null, 0)   = [\"ab\", \"cd\", \"ef\"]\n-     * StringUtils.splitPreserveAllTokens(\"ab   de fg\", null, 0) = [\"ab\", \"cd\", \"ef\"]\n-     * StringUtils.splitPreserveAllTokens(\"ab:cd:ef\", \":\", 0)    = [\"ab\", \"cd\", \"ef\"]\n-     * StringUtils.splitPreserveAllTokens(\"ab:cd:ef\", \":\", 2)    = [\"ab\", \"cd:ef\"]\n-     * StringUtils.splitPreserveAllTokens(\"ab   de fg\", null, 2) = [\"ab\", \"  de fg\"]\n-     * StringUtils.splitPreserveAllTokens(\"ab   de fg\", null, 3) = [\"ab\", \"\", \" de fg\"]\n-     * StringUtils.splitPreserveAllTokens(\"ab   de fg\", null, 4) = [\"ab\", \"\", \"\", \"de fg\"]\n-     * </pre>\n-     *\n-     * @param str the String to parse, may be <code>null</code>\n-     * @param separatorChars the characters used as the delimiters,\n-     * <code>null</code> splits on whitespace\n-     * @param max the maximum number of elements to include in the array. A zero or negative value implies no limit\n-     * @return an array of parsed Strings, <code>null</code> if null String input\n-     */\n-    public static String[] splitPreserveAllTokens(String str, String separatorChars, int max) {\n-        return splitWorker(str, separatorChars, max, true);\n-    }\n+  public static boolean equals(String str1, String str2) {\n+    return str1 == null ? str2 == null : str1.equals(str2);\n+  }\n \n-    /**\n-     * Performs the logic for the <code>split</code> and\n-     * <code>splitPreserveAllTokens</code> methods that return a maximum array\n-     * length.\n-     *\n-     * @param str the String to parse, may be <code>null</code>\n-     * @param separatorChars the separate character\n-     * @param max the maximum number of elements to include in the array. A zero or negative value implies no limit.\n-     * @param preserveAllTokens if <code>true</code>, adjacent separators are treated as empty token separators; if\n-     * <code>false</code>, adjacent separators are treated as one separator.\n-     * @return an array of parsed Strings, <code>null</code> if null String input\n-     */\n-    private static String[] splitWorker(String str, String separatorChars, int max, boolean preserveAllTokens) {\n-        // Performance tuned for 2.0 (JDK1.4)\n-        // Direct code is quicker than StringTokenizer.\n-        // Also, StringTokenizer uses isSpace() not isWhitespace()\n+  /**\n+   * <p>Splits the provided text into an array with a maximum length,\n+   * separators specified, preserving all tokens, including empty tokens created by adjacent separators.</p>\n+   *\n+   * <p>The separator is not included in the returned String array.\n+   * Adjacent separators are treated as separators for empty tokens. Adjacent separators are treated as one\n+   * separator.</p>\n+   *\n+   * <p>A <code>null</code> input String returns <code>null</code>.\n+   * A <code>null</code> separatorChars splits on whitespace.</p>\n+   *\n+   * <p>If more than <code>max</code> delimited substrings are found, the last\n+   * returned string includes all characters after the first <code>max - 1</code> returned strings (including\n+   * separator characters).</p>\n+   *\n+   * <pre>\n+   * StringUtils.splitPreserveAllTokens(null, *, *)            = null\n+   * StringUtils.splitPreserveAllTokens(\"\", *, *)              = []\n+   * StringUtils.splitPreserveAllTokens(\"ab de fg\", null, 0)   = [\"ab\", \"cd\", \"ef\"]\n+   * StringUtils.splitPreserveAllTokens(\"ab   de fg\", null, 0) = [\"ab\", \"cd\", \"ef\"]\n+   * StringUtils.splitPreserveAllTokens(\"ab:cd:ef\", \":\", 0)    = [\"ab\", \"cd\", \"ef\"]\n+   * StringUtils.splitPreserveAllTokens(\"ab:cd:ef\", \":\", 2)    = [\"ab\", \"cd:ef\"]\n+   * StringUtils.splitPreserveAllTokens(\"ab   de fg\", null, 2) = [\"ab\", \"  de fg\"]\n+   * StringUtils.splitPreserveAllTokens(\"ab   de fg\", null, 3) = [\"ab\", \"\", \" de fg\"]\n+   * StringUtils.splitPreserveAllTokens(\"ab   de fg\", null, 4) = [\"ab\", \"\", \"\", \"de fg\"]\n+   * </pre>\n+   *\n+   * @param str            the String to parse, may be <code>null</code>\n+   * @param separatorChars the characters used as the delimiters,\n+   *                       <code>null</code> splits on whitespace\n+   * @param max            the maximum number of elements to include in the array. A zero or negative value implies no limit\n+   * @return an array of parsed Strings, <code>null</code> if null String input\n+   */\n+  public static String[] splitPreserveAllTokens(String str, String separatorChars, int max) {\n+    return splitWorker(str, separatorChars, max, true);\n+  }\n \n-        if (str == null) {\n-            return null;\n-        }\n-        int len = str.length();\n-        if (len == 0) {\n-            return EMPTY_STRING_ARRAY;\n-        }\n-        List list = new ArrayList();\n-        int sizePlus1 = 1;\n-        int i = 0, start = 0;\n-        boolean match = false;\n-        boolean lastMatch = false;\n-        if (separatorChars == null) {\n-            // Null separator means use whitespace\n-            while (i < len) {\n-                if (Character.isWhitespace(str.charAt(i))) {\n-                    if (match || preserveAllTokens) {\n-                        lastMatch = true;\n-                        if (sizePlus1++ == max) {\n-                            i = len;\n-                            lastMatch = false;\n-                        }\n-                        list.add(str.substring(start, i));\n-                        match = false;\n-                    }\n-                    start = ++i;\n-                    continue;\n-                }\n-                lastMatch = false;\n-                match = true;\n-                i++;\n+  /**\n+   * Performs the logic for the <code>split</code> and\n+   * <code>splitPreserveAllTokens</code> methods that return a maximum array\n+   * length.\n+   *\n+   * @param str               the String to parse, may be <code>null</code>\n+   * @param separatorChars    the separate character\n+   * @param max               the maximum number of elements to include in the array. A zero or negative value implies no limit.\n+   * @param preserveAllTokens if <code>true</code>, adjacent separators are treated as empty token separators; if\n+   *                          <code>false</code>, adjacent separators are treated as one separator.\n+   * @return an array of parsed Strings, <code>null</code> if null String input\n+   */\n+  private static String[] splitWorker(String str, String separatorChars, int max, boolean preserveAllTokens) {\n+    // Performance tuned for 2.0 (JDK1.4)\n+    // Direct code is quicker than StringTokenizer.\n+    // Also, StringTokenizer uses isSpace() not isWhitespace()\n+\n+    if (str == null) {\n+      return null;\n+    }\n+    int len = str.length();\n+    if (len == 0) {\n+      return EMPTY_STRING_ARRAY;\n+    }\n+    List list = new ArrayList();\n+    int sizePlus1 = 1;\n+    int i = 0, start = 0;\n+    boolean match = false;\n+    boolean lastMatch = false;\n+    if (separatorChars == null) {\n+      // Null separator means use whitespace\n+      while (i < len) {\n+        if (Character.isWhitespace(str.charAt(i))) {\n+          if (match || preserveAllTokens) {\n+            lastMatch = true;\n+            if (sizePlus1++ == max) {\n+              i = len;\n+              lastMatch = false;\n             }\n+            list.add(str.substring(start, i));\n+            match = false;\n+          }\n+          start = ++i;\n+          continue;\n         }\n-        else if (separatorChars.length() == 1) {\n-            // Optimise 1 character case\n-            char sep = separatorChars.charAt(0);\n-            while (i < len) {\n-                if (str.charAt(i) == sep) {\n-                    if (match || preserveAllTokens) {\n-                        lastMatch = true;\n-                        if (sizePlus1++ == max) {\n-                            i = len;\n-                            lastMatch = false;\n-                        }\n-                        list.add(str.substring(start, i));\n-                        match = false;\n-                    }\n-                    start = ++i;\n-                    continue;\n-                }\n-                lastMatch = false;\n-                match = true;\n-                i++;\n+        lastMatch = false;\n+        match = true;\n+        i++;\n+      }\n+    } else if (separatorChars.length() == 1) {\n+      // Optimise 1 character case\n+      char sep = separatorChars.charAt(0);\n+      while (i < len) {\n+        if (str.charAt(i) == sep) {\n+          if (match || preserveAllTokens) {\n+            lastMatch = true;\n+            if (sizePlus1++ == max) {\n+              i = len;\n+              lastMatch = false;\n             }\n+            list.add(str.substring(start, i));\n+            match = false;\n+          }\n+          start = ++i;\n+          continue;\n         }\n-        else {\n-            // standard case\n-            while (i < len) {\n-                if (separatorChars.indexOf(str.charAt(i)) >= 0) {\n-                    if (match || preserveAllTokens) {\n-                        lastMatch = true;\n-                        if (sizePlus1++ == max) {\n-                            i = len;\n-                            lastMatch = false;\n-                        }\n-                        list.add(str.substring(start, i));\n-                        match = false;\n-                    }\n-                    start = ++i;\n-                    continue;\n-                }\n-                lastMatch = false;\n-                match = true;\n-                i++;\n+        lastMatch = false;\n+        match = true;\n+        i++;\n+      }\n+    } else {\n+      // standard case\n+      while (i < len) {\n+        if (separatorChars.indexOf(str.charAt(i)) >= 0) {\n+          if (match || preserveAllTokens) {\n+            lastMatch = true;\n+            if (sizePlus1++ == max) {\n+              i = len;\n+              lastMatch = false;\n             }\n-        }\n-        if (match || (preserveAllTokens && lastMatch)) {\n             list.add(str.substring(start, i));\n+            match = false;\n+          }\n+          start = ++i;\n+          continue;\n         }\n-        return (String[]) list.toArray(new String[list.size()]);\n+        lastMatch = false;\n+        match = true;\n+        i++;\n+      }\n+    }\n+    if (match || (preserveAllTokens && lastMatch)) {\n+      list.add(str.substring(start, i));\n     }\n+    return (String[]) list.toArray(new String[list.size()]);\n+  }\n \n-    /**\n-     * <p>Checks if String contains a search String irrespective of case,\n-     * handling <code>null</code>. Case-insensitivity is defined as by {@link String#equalsIgnoreCase(String)}.\n-     *\n-     * <p>A <code>null</code> String will return <code>false</code>.</p>\n-     *\n-     * <pre>\n-     * StringUtils.contains(null, *) = false\n-     * StringUtils.contains(*, null) = false\n-     * StringUtils.contains(\"\", \"\") = true\n-     * StringUtils.contains(\"abc\", \"\") = true\n-     * StringUtils.contains(\"abc\", \"a\") = true\n-     * StringUtils.contains(\"abc\", \"z\") = false\n-     * StringUtils.contains(\"abc\", \"A\") = true\n-     * StringUtils.contains(\"abc\", \"Z\") = false\n-     * </pre>\n-     *\n-     * @param str the String to check, may be null\n-     * @param searchStr the String to find, may be null\n-     * @return true if the String contains the search String irrespective of case or false if not or <code>null</code>\n-     * string input\n-     */\n-    public static boolean containsIgnoreCase(String str, String searchStr) {\n-        if (str == null || searchStr == null) {\n-            return false;\n-        }\n-        int len = searchStr.length();\n-        int max = str.length() - len;\n-        for (int i = 0; i <= max; i++) {\n-            if (str.regionMatches(true, i, searchStr, 0, len)) {\n-                return true;\n-            }\n-        }\n-        return false;\n+  /**\n+   * <p>Checks if String contains a search String irrespective of case,\n+   * handling <code>null</code>. Case-insensitivity is defined as by {@link String#equalsIgnoreCase(String)}.\n+   *\n+   * <p>A <code>null</code> String will return <code>false</code>.</p>\n+   *\n+   * <pre>\n+   * StringUtils.contains(null, *) = false\n+   * StringUtils.contains(*, null) = false\n+   * StringUtils.contains(\"\", \"\") = true\n+   * StringUtils.contains(\"abc\", \"\") = true\n+   * StringUtils.contains(\"abc\", \"a\") = true\n+   * StringUtils.contains(\"abc\", \"z\") = false\n+   * StringUtils.contains(\"abc\", \"A\") = true\n+   * StringUtils.contains(\"abc\", \"Z\") = false\n+   * </pre>\n+   *\n+   * @param str       the String to check, may be null\n+   * @param searchStr the String to find, may be null\n+   * @return true if the String contains the search String irrespective of case or false if not or <code>null</code>\n+   * string input\n+   */\n+  public static boolean containsIgnoreCase(String str, String searchStr) {\n+    if (str == null || searchStr == null) {\n+      return false;\n+    }\n+    int len = searchStr.length();\n+    int max = str.length() - len;\n+    for (int i = 0; i <= max; i++) {\n+      if (str.regionMatches(true, i, searchStr, 0, len)) {\n+        return true;\n+      }\n     }\n+    return false;\n+  }\n \n-    // -----------------------------------------------------------------------\n+  // -----------------------------------------------------------------------\n \n-    /**\n-     * <p>Splits the provided text into an array, using whitespace as the\n-     * separator, preserving all tokens, including empty tokens created by adjacent separators. This is an alternative\n-     * to using StringTokenizer. Whitespace is defined by {@link Character#isWhitespace(char)}.</p>\n-     *\n-     * <p>The separator is not included in the returned String array.\n-     * Adjacent separators are treated as separators for empty tokens. For more control over the split use the\n-     * StrTokenizer class.</p>\n-     *\n-     * <p>A <code>null</code> input String returns <code>null</code>.</p>\n-     *\n-     * <pre>\n-     * StringUtils.splitPreserveAllTokens(null)       = null\n-     * StringUtils.splitPreserveAllTokens(\"\")         = []\n-     * StringUtils.splitPreserveAllTokens(\"abc def\")  = [\"abc\", \"def\"]\n-     * StringUtils.splitPreserveAllTokens(\"abc  def\") = [\"abc\", \"\", \"def\"]\n-     * StringUtils.splitPreserveAllTokens(\" abc \")    = [\"\", \"abc\", \"\"]\n-     * </pre>\n-     *\n-     * @param str the String to parse, may be <code>null</code>\n-     * @return an array of parsed Strings, <code>null</code> if null String input\n-     */\n-    public static String[] splitPreserveAllTokens(String str) {\n-        return splitWorker(str, null, -1, true);\n-    }\n+  /**\n+   * <p>Splits the provided text into an array, using whitespace as the\n+   * separator, preserving all tokens, including empty tokens created by adjacent separators. This is an alternative\n+   * to using StringTokenizer. Whitespace is defined by {@link Character#isWhitespace(char)}.</p>\n+   *\n+   * <p>The separator is not included in the returned String array.\n+   * Adjacent separators are treated as separators for empty tokens. For more control over the split use the\n+   * StrTokenizer class.</p>\n+   *\n+   * <p>A <code>null</code> input String returns <code>null</code>.</p>\n+   *\n+   * <pre>\n+   * StringUtils.splitPreserveAllTokens(null)       = null\n+   * StringUtils.splitPreserveAllTokens(\"\")         = []\n+   * StringUtils.splitPreserveAllTokens(\"abc def\")  = [\"abc\", \"def\"]\n+   * StringUtils.splitPreserveAllTokens(\"abc  def\") = [\"abc\", \"\", \"def\"]\n+   * StringUtils.splitPreserveAllTokens(\" abc \")    = [\"\", \"abc\", \"\"]\n+   * </pre>\n+   *\n+   * @param str the String to parse, may be <code>null</code>\n+   * @return an array of parsed Strings, <code>null</code> if null String input\n+   */\n+  public static String[] splitPreserveAllTokens(String str) {\n+    return splitWorker(str, null, -1, true);\n+  }\n \n-    /**\n-     * <p>Splits the provided text into an array, separator specified,\n-     * preserving all tokens, including empty tokens created by adjacent separators. This is an alternative to using\n-     * StringTokenizer.</p>\n-     *\n-     * <p>The separator is not included in the returned String array.\n-     * Adjacent separators are treated as separators for empty tokens. For more control over the split use the\n-     * StrTokenizer class.</p>\n-     *\n-     * <p>A <code>null</code> input String returns <code>null</code>.</p>\n-     *\n-     * <pre>\n-     * StringUtils.splitPreserveAllTokens(null, *)         = null\n-     * StringUtils.splitPreserveAllTokens(\"\", *)           = []\n-     * StringUtils.splitPreserveAllTokens(\"a.b.c\", '.')    = [\"a\", \"b\", \"c\"]\n-     * StringUtils.splitPreserveAllTokens(\"a..b.c\", '.')   = [\"a\", \"\", \"b\", \"c\"]\n-     * StringUtils.splitPreserveAllTokens(\"a:b:c\", '.')    = [\"a:b:c\"]\n-     * StringUtils.splitPreserveAllTokens(\"a\\tb\\nc\", null) = [\"a\", \"b\", \"c\"]\n-     * StringUtils.splitPreserveAllTokens(\"a b c\", ' ')    = [\"a\", \"b\", \"c\"]\n-     * StringUtils.splitPreserveAllTokens(\"a b c \", ' ')   = [\"a\", \"b\", \"c\", \"\"]\n-     * StringUtils.splitPreserveAllTokens(\"a b c  \", ' ')   = [\"a\", \"b\", \"c\", \"\", \"\"]\n-     * StringUtils.splitPreserveAllTokens(\" a b c\", ' ')   = [\"\", a\", \"b\", \"c\"]\n-     * StringUtils.splitPreserveAllTokens(\"  a b c\", ' ')  = [\"\", \"\", a\", \"b\", \"c\"]\n-     * StringUtils.splitPreserveAllTokens(\" a b c \", ' ')  = [\"\", a\", \"b\", \"c\", \"\"]\n-     * </pre>\n-     *\n-     * @param str the String to parse, may be <code>null</code>\n-     * @param separatorChar the character used as the delimiter,\n-     * <code>null</code> splits on whitespace\n-     * @return an array of parsed Strings, <code>null</code> if null String input\n-     */\n-    public static String[] splitPreserveAllTokens(String str, char separatorChar) {\n-        return splitWorker(str, separatorChar, true);\n-    }\n+  /**\n+   * <p>Splits the provided text into an array, separator specified,\n+   * preserving all tokens, including empty tokens created by adjacent separators. This is an alternative to using\n+   * StringTokenizer.</p>\n+   *\n+   * <p>The separator is not included in the returned String array.\n+   * Adjacent separators are treated as separators for empty tokens. For more control over the split use the\n+   * StrTokenizer class.</p>\n+   *\n+   * <p>A <code>null</code> input String returns <code>null</code>.</p>\n+   *\n+   * <pre>\n+   * StringUtils.splitPreserveAllTokens(null, *)         = null\n+   * StringUtils.splitPreserveAllTokens(\"\", *)           = []\n+   * StringUtils.splitPreserveAllTokens(\"a.b.c\", '.')    = [\"a\", \"b\", \"c\"]\n+   * StringUtils.splitPreserveAllTokens(\"a..b.c\", '.')   = [\"a\", \"\", \"b\", \"c\"]\n+   * StringUtils.splitPreserveAllTokens(\"a:b:c\", '.')    = [\"a:b:c\"]\n+   * StringUtils.splitPreserveAllTokens(\"a\\tb\\nc\", null) = [\"a\", \"b\", \"c\"]\n+   * StringUtils.splitPreserveAllTokens(\"a b c\", ' ')    = [\"a\", \"b\", \"c\"]\n+   * StringUtils.splitPreserveAllTokens(\"a b c \", ' ')   = [\"a\", \"b\", \"c\", \"\"]\n+   * StringUtils.splitPreserveAllTokens(\"a b c  \", ' ')   = [\"a\", \"b\", \"c\", \"\", \"\"]\n+   * StringUtils.splitPreserveAllTokens(\" a b c\", ' ')   = [\"\", a\", \"b\", \"c\"]\n+   * StringUtils.splitPreserveAllTokens(\"  a b c\", ' ')  = [\"\", \"\", a\", \"b\", \"c\"]\n+   * StringUtils.splitPreserveAllTokens(\" a b c \", ' ')  = [\"\", a\", \"b\", \"c\", \"\"]\n+   * </pre>\n+   *\n+   * @param str           the String to parse, may be <code>null</code>\n+   * @param separatorChar the character used as the delimiter,\n+   *                      <code>null</code> splits on whitespace\n+   * @return an array of parsed Strings, <code>null</code> if null String input\n+   */\n+  public static String[] splitPreserveAllTokens(String str, char separatorChar) {\n+    return splitWorker(str, separatorChar, true);\n+  }\n }\n",
            "diff_size": 375
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "24",
                    "column": "5",
                    "severity": "error",
                    "message": "'VARIABLE_DEF' should be separated from previous line.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.EmptyLineSeparatorCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/errored/1/21/StringUtils.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/naturalize/21/StringUtils.java\nindex e6834fa510f..c01c2118014 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/errored/1/21/StringUtils.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/naturalize/21/StringUtils.java\n@@ -37,7 +37,8 @@ public class StringUtils {\n     public static boolean isBlank(CharSequence cs) {\n         int strLen;\n         if (cs != null && (strLen = cs.length()) != 0) {\n-            for (int i = 0; i < strLen; ++i) {\n+            for (int i = 0; i < strLen;\n+++i) {\n                 if (!Character.isWhitespace(cs.charAt(i))) {\n                     return false;\n                 }\n@@ -97,7 +98,7 @@ public class StringUtils {\n                         list.add(str.substring(start, i));\n                     }\n \n-                    return (String[]) list.toArray(new String[list.size()]);\n+                    return (String[])list.toArray(new String[list.size()]);\n                 }\n             }\n         }\n@@ -110,7 +111,8 @@ public class StringUtils {\n         else {\n             int sz = str.length();\n \n-            for (int i = 0; i < sz; ++i) {\n+            for (int i = 0; i < sz;\n+++i) {\n                 if (!Character.isDigit(str.charAt(i))) {\n                     return false;\n                 }\n@@ -257,7 +259,7 @@ public class StringUtils {\n         if (match || (preserveAllTokens && lastMatch)) {\n             list.add(str.substring(start, i));\n         }\n-        return (String[]) list.toArray(new String[list.size()]);\n+        return (String[])list.toArray(new String[list.size()]);\n     }\n \n     /**\n@@ -358,4 +360,4 @@ public class StringUtils {\n     public static String[] splitPreserveAllTokens(String str, char separatorChar) {\n         return splitWorker(str, separatorChar, true);\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 7
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "23",
                    "column": "1",
                    "severity": "error",
                    "message": "'CLASS_DEF' has more than 1 empty lines before.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.EmptyLineSeparatorCheck"
                },
                {
                    "line": "28",
                    "column": "5",
                    "severity": "error",
                    "message": "'VARIABLE_DEF' has more than 1 empty lines before.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.EmptyLineSeparatorCheck"
                },
                {
                    "line": "31",
                    "column": "5",
                    "severity": "error",
                    "message": "'CTOR_DEF' has more than 1 empty lines before.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.EmptyLineSeparatorCheck"
                },
                {
                    "line": "35",
                    "column": "5",
                    "severity": "error",
                    "message": "'METHOD_DEF' has more than 1 empty lines before.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.EmptyLineSeparatorCheck"
                },
                {
                    "line": "69",
                    "column": "5",
                    "severity": "error",
                    "message": "'METHOD_DEF' has more than 1 empty lines before.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.EmptyLineSeparatorCheck"
                },
                {
                    "line": "196",
                    "column": "5",
                    "severity": "error",
                    "message": "'METHOD_DEF' has more than 1 empty lines before.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.EmptyLineSeparatorCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/errored/1/21/StringUtils.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/codebuff/21/StringUtils.java\nindex e6834fa510f..8adb9dfaf8a 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/errored/1/21/StringUtils.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/codebuff/21/StringUtils.java\n@@ -19,13 +19,19 @@ package org.apache.ignite.raft.jraft.util;\n import java.util.ArrayList;\n import java.util.List;\n \n+\n public class StringUtils {\n+\n     public static final String EMPTY = \"\";\n+\n+\n     public static final String[] EMPTY_STRING_ARRAY = new String[0];\n \n+\n     public StringUtils() {\n     }\n \n+\n     public static boolean isEmpty(CharSequence cs) {\n         return cs == null || cs.length() == 0;\n     }\n@@ -36,6 +42,7 @@ public class StringUtils {\n \n     public static boolean isBlank(CharSequence cs) {\n         int strLen;\n+\n         if (cs != null && (strLen = cs.length()) != 0) {\n             for (int i = 0; i < strLen; ++i) {\n                 if (!Character.isWhitespace(cs.charAt(i))) {\n@@ -58,20 +65,26 @@ public class StringUtils {\n         return splitWorker(str, separatorChar, false);\n     }\n \n+\n     private static String[] splitWorker(String str, char separatorChar, boolean preserveAllTokens) {\n         if (str == null) {\n             return null;\n         }\n         else {\n             int len = str.length();\n+\n             if (len == 0) {\n                 return EMPTY_STRING_ARRAY;\n             }\n             else {\n                 List<String> list = new ArrayList();\n+\n                 int i = 0;\n+\n                 int start = 0;\n+\n                 boolean match = false;\n+\n                 boolean lastMatch = false;\n \n                 while (true) {\n@@ -79,25 +92,29 @@ public class StringUtils {\n                         if (str.charAt(i) == separatorChar) {\n                             if (match || preserveAllTokens) {\n                                 list.add(str.substring(start, i));\n+\n                                 match = false;\n+\n                                 lastMatch = true;\n                             }\n \n                             ++i;\n+\n                             start = i;\n                         }\n                         else {\n                             lastMatch = false;\n+\n                             match = true;\n+\n                             ++i;\n                         }\n                     }\n-\n                     if (match || preserveAllTokens && lastMatch) {\n                         list.add(str.substring(start, i));\n                     }\n \n-                    return (String[]) list.toArray(new String[list.size()]);\n+                    return (String[])list.toArray(new String[list.size()]);\n                 }\n             }\n         }\n@@ -157,6 +174,7 @@ public class StringUtils {\n      * @param max the maximum number of elements to include in the array. A zero or negative value implies no limit\n      * @return an array of parsed Strings, <code>null</code> if null String input\n      */\n+\n     public static String[] splitPreserveAllTokens(String str, String separatorChars, int max) {\n         return splitWorker(str, separatorChars, max, true);\n     }\n@@ -173,63 +191,91 @@ public class StringUtils {\n      * <code>false</code>, adjacent separators are treated as one separator.\n      * @return an array of parsed Strings, <code>null</code> if null String input\n      */\n+\n+\n     private static String[] splitWorker(String str, String separatorChars, int max, boolean preserveAllTokens) {\n         // Performance tuned for 2.0 (JDK1.4)\n         // Direct code is quicker than StringTokenizer.\n         // Also, StringTokenizer uses isSpace() not isWhitespace()\n-\n         if (str == null) {\n             return null;\n         }\n+\n         int len = str.length();\n+\n         if (len == 0) {\n             return EMPTY_STRING_ARRAY;\n         }\n+\n         List list = new ArrayList();\n+\n         int sizePlus1 = 1;\n+\n         int i = 0, start = 0;\n+\n         boolean match = false;\n+\n         boolean lastMatch = false;\n+\n         if (separatorChars == null) {\n             // Null separator means use whitespace\n             while (i < len) {\n                 if (Character.isWhitespace(str.charAt(i))) {\n                     if (match || preserveAllTokens) {\n                         lastMatch = true;\n+\n                         if (sizePlus1++ == max) {\n                             i = len;\n+\n                             lastMatch = false;\n                         }\n+\n                         list.add(str.substring(start, i));\n+\n                         match = false;\n                     }\n+\n                     start = ++i;\n+\n                     continue;\n                 }\n+\n                 lastMatch = false;\n+\n                 match = true;\n+\n                 i++;\n             }\n         }\n         else if (separatorChars.length() == 1) {\n             // Optimise 1 character case\n             char sep = separatorChars.charAt(0);\n+\n             while (i < len) {\n                 if (str.charAt(i) == sep) {\n                     if (match || preserveAllTokens) {\n                         lastMatch = true;\n+\n                         if (sizePlus1++ == max) {\n                             i = len;\n+\n                             lastMatch = false;\n                         }\n+\n                         list.add(str.substring(start, i));\n+\n                         match = false;\n                     }\n+\n                     start = ++i;\n+\n                     continue;\n                 }\n+\n                 lastMatch = false;\n+\n                 match = true;\n+\n                 i++;\n             }\n         }\n@@ -239,25 +285,36 @@ public class StringUtils {\n                 if (separatorChars.indexOf(str.charAt(i)) >= 0) {\n                     if (match || preserveAllTokens) {\n                         lastMatch = true;\n+\n                         if (sizePlus1++ == max) {\n                             i = len;\n+\n                             lastMatch = false;\n                         }\n+\n                         list.add(str.substring(start, i));\n+\n                         match = false;\n                     }\n+\n                     start = ++i;\n+\n                     continue;\n                 }\n+\n                 lastMatch = false;\n+\n                 match = true;\n+\n                 i++;\n             }\n         }\n-        if (match || (preserveAllTokens && lastMatch)) {\n+        if (match ||\n+            (preserveAllTokens && lastMatch)) {\n             list.add(str.substring(start, i));\n         }\n-        return (String[]) list.toArray(new String[list.size()]);\n+\n+        return (String[])list.toArray(new String[list.size()]);\n     }\n \n     /**\n@@ -282,17 +339,22 @@ public class StringUtils {\n      * @return true if the String contains the search String irrespective of case or false if not or <code>null</code>\n      * string input\n      */\n+\n     public static boolean containsIgnoreCase(String str, String searchStr) {\n         if (str == null || searchStr == null) {\n             return false;\n         }\n+\n         int len = searchStr.length();\n+\n         int max = str.length() - len;\n+\n         for (int i = 0; i <= max; i++) {\n             if (str.regionMatches(true, i, searchStr, 0, len)) {\n                 return true;\n             }\n         }\n+\n         return false;\n     }\n \n@@ -320,6 +382,7 @@ public class StringUtils {\n      * @param str the String to parse, may be <code>null</code>\n      * @return an array of parsed Strings, <code>null</code> if null String input\n      */\n+\n     public static String[] splitPreserveAllTokens(String str) {\n         return splitWorker(str, null, -1, true);\n     }\n@@ -355,7 +418,8 @@ public class StringUtils {\n      * <code>null</code> splits on whitespace\n      * @return an array of parsed Strings, <code>null</code> if null String input\n      */\n+\n     public static String[] splitPreserveAllTokens(String str, char separatorChar) {\n         return splitWorker(str, separatorChar, true);\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 72
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/errored/1/21/StringUtils.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/styler_random/21/StringUtils.java\nindex e6834fa510f..9aa45492689 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/errored/1/21/StringUtils.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/styler_random/21/StringUtils.java\n@@ -21,6 +21,7 @@ import java.util.List;\n \n public class StringUtils {\n     public static final String EMPTY = \"\";\n+\n     public static final String[] EMPTY_STRING_ARRAY = new String[0];\n \n     public StringUtils() {\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/errored/1/21/StringUtils.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/styler_three_grams/21/StringUtils.java\nindex e6834fa510f..9aa45492689 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/errored/1/21/StringUtils.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/styler_three_grams/21/StringUtils.java\n@@ -21,6 +21,7 @@ import java.util.List;\n \n public class StringUtils {\n     public static final String EMPTY = \"\";\n+\n     public static final String[] EMPTY_STRING_ARRAY = new String[0];\n \n     public StringUtils() {\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "naturalize",
        "codebuff"
    ]
}