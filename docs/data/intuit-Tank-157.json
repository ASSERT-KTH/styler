{
    "project_name": "intuit-Tank",
    "error_id": "157",
    "information": {
        "errors": [
            {
                "line": "81",
                "severity": "warning",
                "message": "Line is longer than 120 characters (found 121).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": "            return Integer.toString(stack.pop());\n        }\n        throw new IllegalArgumentException(\"Exhausted random User Ids. Range not large enough for the number of calls.\");\n    }\n\n    /**",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "81",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 121).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/intuit-Tank/errored/1/157/CloudServiceV1.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/intuit-Tank/intellij/157/CloudServiceV1.java\nindex 9e2e64bf954..36dfb804888 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/intuit-Tank/errored/1/157/CloudServiceV1.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/intuit-Tank/intellij/157/CloudServiceV1.java\n@@ -1,6 +1,7 @@\n /**\n  * Copyright 2011 Intuit Inc. All Rights Reserved\n  */\n+\n package com.intuit.tank.service.impl.v1.cloud;\n \n /*\n@@ -44,376 +45,375 @@ import com.intuit.tank.service.util.ServletInjector;\n \n /**\n  * CloudServiceV1\n- * \n+ *\n  * @author dangleton\n- * \n  */\n @Path(CloudService.SERVICE_RELATIVE_PATH)\n public class CloudServiceV1 implements CloudService {\n \n-    private static final Logger LOG = LogManager.getLogger(CloudServiceV1.class);\n-\n-    @Context\n-    private ServletContext servletContext;\n-\n-    private DateFormat dateFormatFull = new SimpleDateFormat(\"MM-dd-yyyy'T'hh:mm:ss z\");\n-    private DateFormat dateFormatShort = new SimpleDateFormat(\"MM-dd-yyyy\");\n-\n-    private static Hashtable<String, Stack<Integer>> stackMap = new Hashtable<String, Stack<Integer>>();\n-\n-    /**\n-     * @inheritDoc\n-     */\n-    @Override\n-    public String ping() {\n-        return \"PONG \" + getClass().getSimpleName();\n-    }\n-\n-    /**\n-     * @inheritDoc\n-     */\n-    @Override\n-    public String userIdFromRange(String jobId, int minValue, int maxValue) {\n-        Stack<Integer> stack = getStack(minValue, maxValue);\n-        if (stack.size() > 0) {\n-            return Integer.toString(stack.pop());\n-        }\n-        throw new IllegalArgumentException(\"Exhausted random User Ids. Range not large enough for the number of calls.\");\n-    }\n-\n-    /**\n-     * @param minId\n-     * @param maxId\n-     * @return\n-     */\n-    private synchronized Stack<Integer> getStack(Integer minId, Integer maxId) {\n-        Stack<Integer> stack = stackMap.get(minId.toString() + \"-\" + maxId.toString());\n-        if (stack == null) {\n-            List<Integer> list = new ArrayList<Integer>();\n-            for (int i = minId; i <= maxId; i++) {\n-                list.add(i);\n-            }\n-            Collections.shuffle(list);\n-            stack = new Stack<Integer>();\n-            stack.addAll(list);\n-        }\n-        return stack;\n-    }\n-\n-    /**\n-     * @inheritDoc\n-     */\n-    @Override\n-    public Response getSummaryStatus(String jobId) {\n-        ResponseBuilder responseBuilder = null;\n-        try {\n-            responseBuilder = Response.ok();\n-            boolean hasTable = ReportingFactory.getResultsReader().hasTimingData(jobId);\n-            boolean hasEntries = new SummaryDataDao().findByJobId(Integer.parseInt(jobId)).size() != 0;\n-            String status = \"Gathering\";\n-            if (hasEntries && !hasTable) {\n-                status = \"Complete\";\n-            } else if (!hasTable && !hasEntries) {\n-                status = \"NoData\";\n-            }\n-            responseBuilder.entity(status);\n-        } catch (Exception e) {\n-            LOG.error(\"Error determining status: \" + e.getMessage(), e);\n-            throw new WebApplicationException(e, Response.Status.INTERNAL_SERVER_ERROR);\n-        }\n-        responseBuilder.cacheControl(ResponseUtil.getNoStoreCacheControl());\n-        return responseBuilder.build();\n-    }\n-\n-    /**\n-     * @inheritDoc\n-     */\n-    @Override\n-    public Response getVmStatus(String instanceId) {\n-        ResponseBuilder responseBuilder = null;\n-        try {\n-            responseBuilder = Response.ok();\n-            CloudController controller = new ServletInjector<CloudController>().getManagedBean(\n-                    servletContext, CloudController.class);\n-            CloudVmStatus status = controller.getVmStatus(instanceId);\n-            responseBuilder.entity(status);\n-        } catch (Exception e) {\n-            LOG.error(\"Error Applying Filters: \" + e.getMessage(), e);\n-            throw new WebApplicationException(e, Response.Status.INTERNAL_SERVER_ERROR);\n-        }\n-        responseBuilder.cacheControl(ResponseUtil.getNoStoreCacheControl());\n-        return responseBuilder.build();\n-    }\n-\n-    /**\n-     * @inheritDoc\n-     */\n-    @Override\n-    public void setVmStatus(final String instanceId, final CloudVmStatus status) {\n-        CloudController controller = new ServletInjector<CloudController>().getManagedBean(\n-                servletContext, CloudController.class);\n-        controller.setVmStatus(instanceId, status);\n-    }\n-\n-    /**\n-     * @inheritDoc\n-     */\n-    @Override\n-    public Response getVmStatusForJob(String jobId) {\n-        ResponseBuilder responseBuilder = null;\n-        try {\n-            responseBuilder = Response.ok();\n-            CloudController controller = new ServletInjector<CloudController>().getManagedBean(\n-                    servletContext, CloudController.class);\n-            CloudVmStatusContainer container = controller.getVmStatusForJob(jobId);\n-            responseBuilder.entity(container);\n-        } catch (Exception e) {\n-            LOG.error(\"Error Applying Filters: \" + e.getMessage(), e);\n-            throw new WebApplicationException(e, Response.Status.INTERNAL_SERVER_ERROR);\n-        }\n-        responseBuilder.cacheControl(ResponseUtil.getNoStoreCacheControl());\n-        return responseBuilder.build();\n-\n-    }\n-\n-    /**\n-     * @inheritDoc\n-     */\n-    @Override\n-    public String startJob(String jobId) {\n-        JobController controller = new ServletInjector<JobController>().getManagedBean(\n-                servletContext, JobController.class);\n-        return controller.startJob(jobId);\n-    }\n-\n-    /**\n-     * @inheritDoc\n-     */\n-    @Override\n-    public void killJob(String jobId) {\n-        JobController controller = new ServletInjector<JobController>().getManagedBean(\n-                servletContext, JobController.class);\n-        controller.killJob(jobId);\n-    }\n-    \n-\n-    /**\n-     * @inheritDoc\n-     */\n-    @Override\n-    public Set<CloudVmStatusContainer> killAllJobs() {\n-        JobController controller = new ServletInjector<JobController>().getManagedBean(\n-                servletContext, JobController.class);\n-        return controller.killAllJobs();\n-    }\n-\n-    /**\n-     * @inheritDoc\n-     */\n-    @Override\n-    public void killInstance(String instanceId) {\n-        JobController controller = new ServletInjector<JobController>().getManagedBean(\n-                servletContext, JobController.class);\n-        controller.killInstance(instanceId);\n-    }\n-\n-    /**\n-     * @inheritDoc\n-     */\n-    @Override\n-    public void killInstances(List<String> instanceIds) {\n-        JobController controller = new ServletInjector<JobController>().getManagedBean(\n-                servletContext, JobController.class);\n-        controller.killInstances(instanceIds);\n-    }\n-\n-    /**\n-     * @inheritDoc\n-     */\n-    @Override\n-    public Set<CloudVmStatusContainer> stopAllJobs() {\n-        JobController controller = new ServletInjector<JobController>().getManagedBean(\n-                servletContext, JobController.class);\n-        return controller.stopAllJobs();\n-    }\n-    \n-    /**\n-     * @inheritDoc\n-     */\n-    @Override\n-    public void stopJob(String jobId) {\n-        JobController controller = new ServletInjector<JobController>().getManagedBean(\n-                servletContext, JobController.class);\n-        controller.stopJob(jobId);\n-    }\n-\n-    /**\n-     * @inheritDoc\n-     */\n-    @Override\n-    public void stopAgent(String instanceId) {\n-        JobController controller = new ServletInjector<JobController>().getManagedBean(\n-                servletContext, JobController.class);\n-        controller.stopAgent(instanceId);\n-\n-    }\n+  private static final Logger LOG = LogManager.getLogger(CloudServiceV1.class);\n \n-    /**\n-     * @inheritDoc\n-     */\n-    @Override\n-    public void stopAgents(List<String> instanceIds) {\n-        JobController controller = new ServletInjector<JobController>().getManagedBean(\n-                servletContext, JobController.class);\n-        controller.stopAgents(instanceIds);\n-    }\n+  @Context\n+  private ServletContext servletContext;\n \n-    /**\n-     * @inheritDoc\n-     */\n-    @Override\n-    public void pauseJob(String jobId) {\n-        JobController controller = new ServletInjector<JobController>().getManagedBean(\n-                servletContext, JobController.class);\n-        controller.pauseJob(jobId);\n-    }\n+  private DateFormat dateFormatFull = new SimpleDateFormat(\"MM-dd-yyyy'T'hh:mm:ss z\");\n+  private DateFormat dateFormatShort = new SimpleDateFormat(\"MM-dd-yyyy\");\n \n-    /**\n-     * @inheritDoc\n-     */\n-    @Override\n-    public void pauseAgent(String instanceId) {\n-        JobController controller = new ServletInjector<JobController>().getManagedBean(\n-                servletContext, JobController.class);\n-        controller.pauseAgent(instanceId);\n-    }\n+  private static Hashtable<String, Stack<Integer>> stackMap = new Hashtable<String, Stack<Integer>>();\n \n-    /**\n-     * @inheritDoc\n-     */\n-    @Override\n-    public void pauseAgents(List<String> instanceIds) {\n-        JobController controller = new ServletInjector<JobController>().getManagedBean(\n-                servletContext, JobController.class);\n-        controller.pauseAgents(instanceIds);\n-    }\n+  /**\n+   * @inheritDoc\n+   */\n+  @Override\n+  public String ping() {\n+    return \"PONG \" + getClass().getSimpleName();\n+  }\n \n-    /**\n-     * @inheritDoc\n-     */\n-    @Override\n-    public void restartJob(String jobId) {\n-        JobController controller = new ServletInjector<JobController>().getManagedBean(\n-                servletContext, JobController.class);\n-        controller.restartJob(jobId);\n+  /**\n+   * @inheritDoc\n+   */\n+  @Override\n+  public String userIdFromRange(String jobId, int minValue, int maxValue) {\n+    Stack<Integer> stack = getStack(minValue, maxValue);\n+    if (stack.size() > 0) {\n+      return Integer.toString(stack.pop());\n     }\n-\n-    /**\n-     * @inheritDoc\n-     */\n-    @Override\n-    public void restartAgent(String instanceId) {\n-        JobController controller = new ServletInjector<JobController>().getManagedBean(\n-                servletContext, JobController.class);\n-        controller.restartAgent(instanceId);\n+    throw new IllegalArgumentException(\"Exhausted random User Ids. Range not large enough for the number of calls.\");\n+  }\n+\n+  /**\n+   * @param minId\n+   * @param maxId\n+   * @return\n+   */\n+  private synchronized Stack<Integer> getStack(Integer minId, Integer maxId) {\n+    Stack<Integer> stack = stackMap.get(minId.toString() + \"-\" + maxId.toString());\n+    if (stack == null) {\n+      List<Integer> list = new ArrayList<Integer>();\n+      for (int i = minId; i <= maxId; i++) {\n+        list.add(i);\n+      }\n+      Collections.shuffle(list);\n+      stack = new Stack<Integer>();\n+      stack.addAll(list);\n     }\n-\n-    /**\n-     * @inheritDoc\n-     */\n-    @Override\n-    public void restartAgents(List<String> instanceIds) {\n-        JobController controller = new ServletInjector<JobController>().getManagedBean(\n-                servletContext, JobController.class);\n-        controller.restartAgents(instanceIds);\n+    return stack;\n+  }\n+\n+  /**\n+   * @inheritDoc\n+   */\n+  @Override\n+  public Response getSummaryStatus(String jobId) {\n+    ResponseBuilder responseBuilder = null;\n+    try {\n+      responseBuilder = Response.ok();\n+      boolean hasTable = ReportingFactory.getResultsReader().hasTimingData(jobId);\n+      boolean hasEntries = new SummaryDataDao().findByJobId(Integer.parseInt(jobId)).size() != 0;\n+      String status = \"Gathering\";\n+      if (hasEntries && !hasTable) {\n+        status = \"Complete\";\n+      } else if (!hasTable && !hasEntries) {\n+        status = \"NoData\";\n+      }\n+      responseBuilder.entity(status);\n+    } catch (Exception e) {\n+      LOG.error(\"Error determining status: \" + e.getMessage(), e);\n+      throw new WebApplicationException(e, Response.Status.INTERNAL_SERVER_ERROR);\n     }\n-\n-    /**\n-     * @inheritDoc\n-     */\n-    @Override\n-    public void pauseRampInstance(String instanceId) {\n-        JobController controller = new ServletInjector<JobController>().getManagedBean(\n-                servletContext, JobController.class);\n-        controller.pauseRampInstance(instanceId);\n+    responseBuilder.cacheControl(ResponseUtil.getNoStoreCacheControl());\n+    return responseBuilder.build();\n+  }\n+\n+  /**\n+   * @inheritDoc\n+   */\n+  @Override\n+  public Response getVmStatus(String instanceId) {\n+    ResponseBuilder responseBuilder = null;\n+    try {\n+      responseBuilder = Response.ok();\n+      CloudController controller = new ServletInjector<CloudController>().getManagedBean(\n+        servletContext, CloudController.class);\n+      CloudVmStatus status = controller.getVmStatus(instanceId);\n+      responseBuilder.entity(status);\n+    } catch (Exception e) {\n+      LOG.error(\"Error Applying Filters: \" + e.getMessage(), e);\n+      throw new WebApplicationException(e, Response.Status.INTERNAL_SERVER_ERROR);\n     }\n-\n-    /**\n-     * @inheritDoc\n-     */\n-    @Override\n-    public void pauseRampJob(String jobId) {\n-        JobController controller = new ServletInjector<JobController>().getManagedBean(\n-                servletContext, JobController.class);\n-        controller.pauseRampJob(jobId);\n-    }\n-\n-    /**\n-     * @inheritDoc\n-     */\n-    @Override\n-    public void pauseRampInstances(List<String> instanceIds) {\n-        JobController controller = new ServletInjector<JobController>().getManagedBean(\n-                servletContext, JobController.class);\n-        controller.pauseRampInstances(instanceIds);\n-    }\n-\n-    /**\n-     * @inheritDoc\n-     */\n-    @Override\n-    public void resumeRampInstance(String instanceId) {\n-        JobController controller = new ServletInjector<JobController>().getManagedBean(\n-                servletContext, JobController.class);\n-        controller.resumeRampInstance(instanceId);\n-    }\n-\n-    /**\n-     * @inheritDoc\n-     */\n-    @Override\n-    public void resumeRampJob(String jobId) {\n-        JobController controller = new ServletInjector<JobController>().getManagedBean(\n-                servletContext, JobController.class);\n-        controller.resumeRampJob(jobId);\n-    }\n-\n-    /**\n-     * @inheritDoc\n-     */\n-    @Override\n-    public void resumeRampInstances(List<String> instanceIds) {\n-        JobController controller = new ServletInjector<JobController>().getManagedBean(\n-                servletContext, JobController.class);\n-        controller.resumeRampInstances(instanceIds);\n-    }\n-\n-    /**\n-     * @inheritDoc\n-     */\n-    @Override\n-    public String getCostingForDates(String startDate, String endDate) {\n-        // AWSCostRetriever retriever = new AWSCostRetriever();\n-        // Calendar start = Calendar.getInstance(TimeZone.getTimeZone(\"GMT\"));\n-        // Calendar end = Calendar.getInstance(TimeZone.getTimeZone(\"GMT\"));\n-        // start.setTime(parseDateString(startDate));\n-        // end.setTime(parseDateString(endDate));\n-        // ServiceUsage usage = retriever.getCustomReport(start, end);\n-        // UsageCalculator calc = new UsageCalculator(usage);\n-        // return AwsUtil.generateReport(calc);\n-        throw new RuntimeException(\"Not implemented\");\n-    }\n-\n-    /**\n-     * @inheritDoc\n-     */\n-    @Override\n-    public String getCostingForDates(String timePeriod) {\n-        throw new RuntimeException(\"Not implemented\");\n-        // AWSCostRetriever retriever = new AWSCostRetriever();\n-        // ServiceUsage usage = retriever.getPreDefinedReport(TimePeriodSelectChoice.valueOf(timePeriod));\n-        // UsageCalculator calc = new UsageCalculator(usage);\n-        // return AwsUtil.generateReport(calc);\n+    responseBuilder.cacheControl(ResponseUtil.getNoStoreCacheControl());\n+    return responseBuilder.build();\n+  }\n+\n+  /**\n+   * @inheritDoc\n+   */\n+  @Override\n+  public void setVmStatus(final String instanceId, final CloudVmStatus status) {\n+    CloudController controller = new ServletInjector<CloudController>().getManagedBean(\n+      servletContext, CloudController.class);\n+    controller.setVmStatus(instanceId, status);\n+  }\n+\n+  /**\n+   * @inheritDoc\n+   */\n+  @Override\n+  public Response getVmStatusForJob(String jobId) {\n+    ResponseBuilder responseBuilder = null;\n+    try {\n+      responseBuilder = Response.ok();\n+      CloudController controller = new ServletInjector<CloudController>().getManagedBean(\n+        servletContext, CloudController.class);\n+      CloudVmStatusContainer container = controller.getVmStatusForJob(jobId);\n+      responseBuilder.entity(container);\n+    } catch (Exception e) {\n+      LOG.error(\"Error Applying Filters: \" + e.getMessage(), e);\n+      throw new WebApplicationException(e, Response.Status.INTERNAL_SERVER_ERROR);\n     }\n+    responseBuilder.cacheControl(ResponseUtil.getNoStoreCacheControl());\n+    return responseBuilder.build();\n+\n+  }\n+\n+  /**\n+   * @inheritDoc\n+   */\n+  @Override\n+  public String startJob(String jobId) {\n+    JobController controller = new ServletInjector<JobController>().getManagedBean(\n+      servletContext, JobController.class);\n+    return controller.startJob(jobId);\n+  }\n+\n+  /**\n+   * @inheritDoc\n+   */\n+  @Override\n+  public void killJob(String jobId) {\n+    JobController controller = new ServletInjector<JobController>().getManagedBean(\n+      servletContext, JobController.class);\n+    controller.killJob(jobId);\n+  }\n+\n+\n+  /**\n+   * @inheritDoc\n+   */\n+  @Override\n+  public Set<CloudVmStatusContainer> killAllJobs() {\n+    JobController controller = new ServletInjector<JobController>().getManagedBean(\n+      servletContext, JobController.class);\n+    return controller.killAllJobs();\n+  }\n+\n+  /**\n+   * @inheritDoc\n+   */\n+  @Override\n+  public void killInstance(String instanceId) {\n+    JobController controller = new ServletInjector<JobController>().getManagedBean(\n+      servletContext, JobController.class);\n+    controller.killInstance(instanceId);\n+  }\n+\n+  /**\n+   * @inheritDoc\n+   */\n+  @Override\n+  public void killInstances(List<String> instanceIds) {\n+    JobController controller = new ServletInjector<JobController>().getManagedBean(\n+      servletContext, JobController.class);\n+    controller.killInstances(instanceIds);\n+  }\n+\n+  /**\n+   * @inheritDoc\n+   */\n+  @Override\n+  public Set<CloudVmStatusContainer> stopAllJobs() {\n+    JobController controller = new ServletInjector<JobController>().getManagedBean(\n+      servletContext, JobController.class);\n+    return controller.stopAllJobs();\n+  }\n+\n+  /**\n+   * @inheritDoc\n+   */\n+  @Override\n+  public void stopJob(String jobId) {\n+    JobController controller = new ServletInjector<JobController>().getManagedBean(\n+      servletContext, JobController.class);\n+    controller.stopJob(jobId);\n+  }\n+\n+  /**\n+   * @inheritDoc\n+   */\n+  @Override\n+  public void stopAgent(String instanceId) {\n+    JobController controller = new ServletInjector<JobController>().getManagedBean(\n+      servletContext, JobController.class);\n+    controller.stopAgent(instanceId);\n+\n+  }\n+\n+  /**\n+   * @inheritDoc\n+   */\n+  @Override\n+  public void stopAgents(List<String> instanceIds) {\n+    JobController controller = new ServletInjector<JobController>().getManagedBean(\n+      servletContext, JobController.class);\n+    controller.stopAgents(instanceIds);\n+  }\n+\n+  /**\n+   * @inheritDoc\n+   */\n+  @Override\n+  public void pauseJob(String jobId) {\n+    JobController controller = new ServletInjector<JobController>().getManagedBean(\n+      servletContext, JobController.class);\n+    controller.pauseJob(jobId);\n+  }\n+\n+  /**\n+   * @inheritDoc\n+   */\n+  @Override\n+  public void pauseAgent(String instanceId) {\n+    JobController controller = new ServletInjector<JobController>().getManagedBean(\n+      servletContext, JobController.class);\n+    controller.pauseAgent(instanceId);\n+  }\n+\n+  /**\n+   * @inheritDoc\n+   */\n+  @Override\n+  public void pauseAgents(List<String> instanceIds) {\n+    JobController controller = new ServletInjector<JobController>().getManagedBean(\n+      servletContext, JobController.class);\n+    controller.pauseAgents(instanceIds);\n+  }\n+\n+  /**\n+   * @inheritDoc\n+   */\n+  @Override\n+  public void restartJob(String jobId) {\n+    JobController controller = new ServletInjector<JobController>().getManagedBean(\n+      servletContext, JobController.class);\n+    controller.restartJob(jobId);\n+  }\n+\n+  /**\n+   * @inheritDoc\n+   */\n+  @Override\n+  public void restartAgent(String instanceId) {\n+    JobController controller = new ServletInjector<JobController>().getManagedBean(\n+      servletContext, JobController.class);\n+    controller.restartAgent(instanceId);\n+  }\n+\n+  /**\n+   * @inheritDoc\n+   */\n+  @Override\n+  public void restartAgents(List<String> instanceIds) {\n+    JobController controller = new ServletInjector<JobController>().getManagedBean(\n+      servletContext, JobController.class);\n+    controller.restartAgents(instanceIds);\n+  }\n+\n+  /**\n+   * @inheritDoc\n+   */\n+  @Override\n+  public void pauseRampInstance(String instanceId) {\n+    JobController controller = new ServletInjector<JobController>().getManagedBean(\n+      servletContext, JobController.class);\n+    controller.pauseRampInstance(instanceId);\n+  }\n+\n+  /**\n+   * @inheritDoc\n+   */\n+  @Override\n+  public void pauseRampJob(String jobId) {\n+    JobController controller = new ServletInjector<JobController>().getManagedBean(\n+      servletContext, JobController.class);\n+    controller.pauseRampJob(jobId);\n+  }\n+\n+  /**\n+   * @inheritDoc\n+   */\n+  @Override\n+  public void pauseRampInstances(List<String> instanceIds) {\n+    JobController controller = new ServletInjector<JobController>().getManagedBean(\n+      servletContext, JobController.class);\n+    controller.pauseRampInstances(instanceIds);\n+  }\n+\n+  /**\n+   * @inheritDoc\n+   */\n+  @Override\n+  public void resumeRampInstance(String instanceId) {\n+    JobController controller = new ServletInjector<JobController>().getManagedBean(\n+      servletContext, JobController.class);\n+    controller.resumeRampInstance(instanceId);\n+  }\n+\n+  /**\n+   * @inheritDoc\n+   */\n+  @Override\n+  public void resumeRampJob(String jobId) {\n+    JobController controller = new ServletInjector<JobController>().getManagedBean(\n+      servletContext, JobController.class);\n+    controller.resumeRampJob(jobId);\n+  }\n+\n+  /**\n+   * @inheritDoc\n+   */\n+  @Override\n+  public void resumeRampInstances(List<String> instanceIds) {\n+    JobController controller = new ServletInjector<JobController>().getManagedBean(\n+      servletContext, JobController.class);\n+    controller.resumeRampInstances(instanceIds);\n+  }\n+\n+  /**\n+   * @inheritDoc\n+   */\n+  @Override\n+  public String getCostingForDates(String startDate, String endDate) {\n+    // AWSCostRetriever retriever = new AWSCostRetriever();\n+    // Calendar start = Calendar.getInstance(TimeZone.getTimeZone(\"GMT\"));\n+    // Calendar end = Calendar.getInstance(TimeZone.getTimeZone(\"GMT\"));\n+    // start.setTime(parseDateString(startDate));\n+    // end.setTime(parseDateString(endDate));\n+    // ServiceUsage usage = retriever.getCustomReport(start, end);\n+    // UsageCalculator calc = new UsageCalculator(usage);\n+    // return AwsUtil.generateReport(calc);\n+    throw new RuntimeException(\"Not implemented\");\n+  }\n+\n+  /**\n+   * @inheritDoc\n+   */\n+  @Override\n+  public String getCostingForDates(String timePeriod) {\n+    throw new RuntimeException(\"Not implemented\");\n+    // AWSCostRetriever retriever = new AWSCostRetriever();\n+    // ServiceUsage usage = retriever.getPreDefinedReport(TimePeriodSelectChoice.valueOf(timePeriod));\n+    // UsageCalculator calc = new UsageCalculator(usage);\n+    // return AwsUtil.generateReport(calc);\n+  }\n \n }\n",
            "diff_size": 634
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "81",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 121).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/intuit-Tank/errored/1/157/CloudServiceV1.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/intuit-Tank/naturalize/157/CloudServiceV1.java\nindex 9e2e64bf954..1d9a9f3e1fb 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/intuit-Tank/errored/1/157/CloudServiceV1.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/intuit-Tank/naturalize/157/CloudServiceV1.java\n@@ -195,12 +195,11 @@ public class CloudServiceV1 implements CloudService {\n                 servletContext, JobController.class);\n         controller.killJob(jobId);\n     }\n-    \n \n     /**\n      * @inheritDoc\n      */\n-    @Override\n+@Override\n     public Set<CloudVmStatusContainer> killAllJobs() {\n         JobController controller = new ServletInjector<JobController>().getManagedBean(\n                 servletContext, JobController.class);\n@@ -240,7 +239,7 @@ public class CloudServiceV1 implements CloudService {\n     /**\n      * @inheritDoc\n      */\n-    @Override\n+@Override\n     public void stopJob(String jobId) {\n         JobController controller = new ServletInjector<JobController>().getManagedBean(\n                 servletContext, JobController.class);\n@@ -416,4 +415,4 @@ public class CloudServiceV1 implements CloudService {\n         // return AwsUtil.generateReport(calc);\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 4
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "81",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 121).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "81",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 126).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "81",
                    "column": "44",
                    "severity": "warning",
                    "message": "'(' is preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.MethodParamPadCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/intuit-Tank/errored/1/157/CloudServiceV1.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/intuit-Tank/styler_three_grams/157/CloudServiceV1.java\nindex 9e2e64bf954..1ce0b19f9ce 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/intuit-Tank/errored/1/157/CloudServiceV1.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/intuit-Tank/styler_three_grams/157/CloudServiceV1.java\n@@ -78,10 +78,7 @@ public class CloudServiceV1 implements CloudService {\n         if (stack.size() > 0) {\n             return Integer.toString(stack.pop());\n         }\n-        throw new IllegalArgumentException(\"Exhausted random User Ids. Range not large enough for the number of calls.\");\n-    }\n-\n-    /**\n+        throw new IllegalArgumentException (\"Exhausted random User Ids. Range not large enough for the number of calls.\");}/**\n      * @param minId\n      * @param maxId\n      * @return\n",
            "diff_size": 4
        }
    ],
    "repaired_by": [
        "intellij"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}