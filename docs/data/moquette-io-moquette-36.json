{
    "project_name": "moquette-io-moquette",
    "error_id": "36",
    "information": {
        "errors": [
            {
                "line": "258",
                "column": "1",
                "severity": "warning",
                "message": "File contains tab characters (this is the first instance).",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
            }
        ]
    },
    "source_code": "        }\n\n\t\t// calling shutdown() does not actually stop tasks that are not cancelled,\n\t\t// and SessionsRepository does not stop its tasks. Thus shutdownNow().\n        scheduler.shutdownNow();\n",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/errored/1/36/Server.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/styler/36/Server.java\nindex 55b794cb771..879013b0e79 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/errored/1/36/Server.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/styler/36/Server.java\n@@ -255,8 +255,8 @@ public class Server {\n             }\n         }\n \n-\t\t// calling shutdown() does not actually stop tasks that are not cancelled,\n-\t\t// and SessionsRepository does not stop its tasks. Thus shutdownNow().\n+        // calling shutdown() does not actually stop tasks that are not cancelled,\n+         // and SessionsRepository does not stop its tasks. Thus shutdownNow().\n         scheduler.shutdownNow();\n \n         LOG.info(\"Moquette server has been stopped.\");\n",
            "diff_size": 2
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/errored/1/36/Server.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/intellij/36/Server.java\nindex 55b794cb771..9fb74f6178a 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/errored/1/36/Server.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/intellij/36/Server.java\n@@ -56,269 +56,269 @@ import static io.moquette.logging.LoggingUtils.getInterceptorIds;\n  */\n public class Server {\n \n-    private static final Logger LOG = LoggerFactory.getLogger(Server.class);\n-\n-    private static final String HZ_INTERCEPT_HANDLER = HazelcastInterceptHandler.class.getCanonicalName();\n-\n-    private ServerAcceptor m_acceptor;\n-\n-    private volatile boolean m_initialized;\n-\n-    private ProtocolProcessor m_processor;\n-\n-    private HazelcastInstance hazelcastInstance;\n-\n-    private ProtocolProcessorBootstrapper m_processorBootstrapper;\n-\n-    private ScheduledExecutorService scheduler;\n-\n-    public static void main(String[] args) throws IOException {\n-        final Server server = new Server();\n-        server.startServer();\n-        System.out.println(\"Server started, version 0.12-SNAPSHOT\");\n-        //Bind  a shutdown hook\n-        Runtime.getRuntime().addShutdownHook(new Thread(server::stopServer));\n+  private static final Logger LOG = LoggerFactory.getLogger(Server.class);\n+\n+  private static final String HZ_INTERCEPT_HANDLER = HazelcastInterceptHandler.class.getCanonicalName();\n+\n+  private ServerAcceptor m_acceptor;\n+\n+  private volatile boolean m_initialized;\n+\n+  private ProtocolProcessor m_processor;\n+\n+  private HazelcastInstance hazelcastInstance;\n+\n+  private ProtocolProcessorBootstrapper m_processorBootstrapper;\n+\n+  private ScheduledExecutorService scheduler;\n+\n+  public static void main(String[] args) throws IOException {\n+    final Server server = new Server();\n+    server.startServer();\n+    System.out.println(\"Server started, version 0.12-SNAPSHOT\");\n+    //Bind  a shutdown hook\n+    Runtime.getRuntime().addShutdownHook(new Thread(server::stopServer));\n+  }\n+\n+  /**\n+   * Starts Moquette bringing the configuration from the file located at m_config/moquette.conf\n+   *\n+   * @throws IOException in case of any IO error.\n+   */\n+  public void startServer() throws IOException {\n+    File defaultConfigurationFile = defaultConfigFile();\n+    LOG.info(\"Starting Moquette server. Configuration file path={}\", defaultConfigurationFile.getAbsolutePath());\n+    IResourceLoader filesystemLoader = new FileResourceLoader(defaultConfigurationFile);\n+    final IConfig config = new ResourceLoaderConfig(filesystemLoader);\n+    startServer(config);\n+  }\n+\n+  private static File defaultConfigFile() {\n+    String configPath = System.getProperty(\"moquette.path\", null);\n+    return new File(configPath, IConfig.DEFAULT_CONFIG);\n+  }\n+\n+  /**\n+   * Starts Moquette bringing the configuration from the given file\n+   *\n+   * @param configFile text file that contains the configuration.\n+   * @throws IOException in case of any IO Error.\n+   */\n+  public void startServer(File configFile) throws IOException {\n+    LOG.info(\"Starting Moquette server. Configuration file path={}\", configFile.getAbsolutePath());\n+    IResourceLoader filesystemLoader = new FileResourceLoader(configFile);\n+    final IConfig config = new ResourceLoaderConfig(filesystemLoader);\n+    startServer(config);\n+  }\n+\n+  /**\n+   * Starts the server with the given properties.\n+   * <p>\n+   * Its suggested to at least have the following properties:\n+   * <ul>\n+   * <li>port</li>\n+   * <li>password_file</li>\n+   * </ul>\n+   *\n+   * @param configProps the properties map to use as configuration.\n+   * @throws IOException in case of any IO Error.\n+   */\n+  public void startServer(Properties configProps) throws IOException {\n+    LOG.debug(\"Starting Moquette server using properties object\");\n+    final IConfig config = new MemoryConfig(configProps);\n+    startServer(config);\n+  }\n+\n+  /**\n+   * Starts Moquette bringing the configuration files from the given Config implementation.\n+   *\n+   * @param config the configuration to use to start the broker.\n+   * @throws IOException in case of any IO Error.\n+   */\n+  public void startServer(IConfig config) throws IOException {\n+    LOG.debug(\"Starting Moquette server using IConfig instance\");\n+    startServer(config, null);\n+  }\n+\n+  /**\n+   * Starts Moquette with config provided by an implementation of IConfig class and with the set\n+   * of InterceptHandler.\n+   *\n+   * @param config   the configuration to use to start the broker.\n+   * @param handlers the handlers to install in the broker.\n+   * @throws IOException in case of any IO Error.\n+   */\n+  public void startServer(IConfig config, List<? extends InterceptHandler> handlers) throws IOException {\n+    LOG.debug(\"Starting moquette server using IConfig instance and intercept handlers\");\n+    startServer(config, handlers, null, null, null);\n+  }\n+\n+  public void startServer(IConfig config, List<? extends InterceptHandler> handlers, ISslContextCreator sslCtxCreator,\n+                          IAuthenticator authenticator, IAuthorizator authorizator) throws IOException {\n+    final long start = System.currentTimeMillis();\n+    if (handlers == null) {\n+      handlers = Collections.emptyList();\n     }\n+    LOG.trace(\"Starting Moquette Server. MQTT message interceptors={}\", getInterceptorIds(handlers));\n \n-    /**\n-     * Starts Moquette bringing the configuration from the file located at m_config/moquette.conf\n-     *\n-     * @throws IOException in case of any IO error.\n-     */\n-    public void startServer() throws IOException {\n-        File defaultConfigurationFile = defaultConfigFile();\n-        LOG.info(\"Starting Moquette server. Configuration file path={}\", defaultConfigurationFile.getAbsolutePath());\n-        IResourceLoader filesystemLoader = new FileResourceLoader(defaultConfigurationFile);\n-        final IConfig config = new ResourceLoaderConfig(filesystemLoader);\n-        startServer(config);\n-    }\n-\n-    private static File defaultConfigFile() {\n-        String configPath = System.getProperty(\"moquette.path\", null);\n-        return new File(configPath, IConfig.DEFAULT_CONFIG);\n-    }\n+    scheduler = Executors.newScheduledThreadPool(1);\n \n-    /**\n-     * Starts Moquette bringing the configuration from the given file\n-     *\n-     * @param configFile text file that contains the configuration.\n-     * @throws IOException in case of any IO Error.\n-     */\n-    public void startServer(File configFile) throws IOException {\n-        LOG.info(\"Starting Moquette server. Configuration file path={}\", configFile.getAbsolutePath());\n-        IResourceLoader filesystemLoader = new FileResourceLoader(configFile);\n-        final IConfig config = new ResourceLoaderConfig(filesystemLoader);\n-        startServer(config);\n+    final String handlerProp = System.getProperty(BrokerConstants.INTERCEPT_HANDLER_PROPERTY_NAME);\n+    if (handlerProp != null) {\n+      config.setProperty(BrokerConstants.INTERCEPT_HANDLER_PROPERTY_NAME, handlerProp);\n     }\n-\n-    /**\n-     * Starts the server with the given properties.\n-     * <p>\n-     * Its suggested to at least have the following properties:\n-     * <ul>\n-     * <li>port</li>\n-     * <li>password_file</li>\n-     * </ul>\n-     *\n-     * @param configProps the properties map to use as configuration.\n-     * @throws IOException in case of any IO Error.\n-     */\n-    public void startServer(Properties configProps) throws IOException {\n-        LOG.debug(\"Starting Moquette server using properties object\");\n-        final IConfig config = new MemoryConfig(configProps);\n-        startServer(config);\n+    configureCluster(config);\n+    final String persistencePath = config.getProperty(BrokerConstants.PERSISTENT_STORE_PROPERTY_NAME);\n+    LOG.debug(\"Configuring Using persistent store file, path={}\", persistencePath);\n+    m_processorBootstrapper = new ProtocolProcessorBootstrapper();\n+    final ProtocolProcessor processor = m_processorBootstrapper.init(config, handlers, authenticator, authorizator,\n+        this);\n+    LOG.debug(\"Initialized MQTT protocol processor\");\n+    if (sslCtxCreator == null) {\n+      LOG.info(\"Using default SSL context creator\");\n+      sslCtxCreator = new DefaultMoquetteSslContextCreator(config);\n     }\n \n-    /**\n-     * Starts Moquette bringing the configuration files from the given Config implementation.\n-     *\n-     * @param config the configuration to use to start the broker.\n-     * @throws IOException in case of any IO Error.\n-     */\n-    public void startServer(IConfig config) throws IOException {\n-        LOG.debug(\"Starting Moquette server using IConfig instance\");\n-        startServer(config, null);\n+    m_acceptor = new NettyAcceptor();\n+    m_acceptor.initialize(processor, config, sslCtxCreator);\n+    m_processor = processor;\n+\n+    final long startTime = System.currentTimeMillis() - start;\n+    LOG.info(\"Moquette server has been started successfully in {} ms\", startTime);\n+    m_initialized = true;\n+  }\n+\n+  private void configureCluster(IConfig config) throws FileNotFoundException {\n+    LOG.info(\"Configuring embedded Hazelcast instance\");\n+    String interceptHandlerClassname = config.getProperty(BrokerConstants.INTERCEPT_HANDLER_PROPERTY_NAME);\n+    if (interceptHandlerClassname == null || !HZ_INTERCEPT_HANDLER.equals(interceptHandlerClassname)) {\n+      LOG.info(\"There are no Hazelcast intercept handlers. The server won't start a Hazelcast instance.\");\n+      return;\n     }\n-\n-    /**\n-     * Starts Moquette with config provided by an implementation of IConfig class and with the set\n-     * of InterceptHandler.\n-     *\n-     * @param config   the configuration to use to start the broker.\n-     * @param handlers the handlers to install in the broker.\n-     * @throws IOException in case of any IO Error.\n-     */\n-    public void startServer(IConfig config, List<? extends InterceptHandler> handlers) throws IOException {\n-        LOG.debug(\"Starting moquette server using IConfig instance and intercept handlers\");\n-        startServer(config, handlers, null, null, null);\n+    String hzConfigPath = config.getProperty(BrokerConstants.HAZELCAST_CONFIGURATION);\n+    if (hzConfigPath != null) {\n+      boolean isHzConfigOnClasspath = this.getClass().getClassLoader().getResource(hzConfigPath) != null;\n+      Config hzconfig = isHzConfigOnClasspath\n+          ? new ClasspathXmlConfig(hzConfigPath)\n+          : new FileSystemXmlConfig(hzConfigPath);\n+      LOG.info(\"Starting Hazelcast instance. ConfigurationFile={}\", hzconfig);\n+      hazelcastInstance = Hazelcast.newHazelcastInstance(hzconfig);\n+    } else {\n+      LOG.info(\"Starting Hazelcast instance with default configuration\");\n+      hazelcastInstance = Hazelcast.newHazelcastInstance();\n     }\n-\n-    public void startServer(IConfig config, List<? extends InterceptHandler> handlers, ISslContextCreator sslCtxCreator,\n-                            IAuthenticator authenticator, IAuthorizator authorizator) throws IOException {\n-        final long start = System.currentTimeMillis();\n-        if (handlers == null) {\n-            handlers = Collections.emptyList();\n-        }\n-        LOG.trace(\"Starting Moquette Server. MQTT message interceptors={}\", getInterceptorIds(handlers));\n-\n-        scheduler = Executors.newScheduledThreadPool(1);\n-\n-        final String handlerProp = System.getProperty(BrokerConstants.INTERCEPT_HANDLER_PROPERTY_NAME);\n-        if (handlerProp != null) {\n-            config.setProperty(BrokerConstants.INTERCEPT_HANDLER_PROPERTY_NAME, handlerProp);\n-        }\n-        configureCluster(config);\n-        final String persistencePath = config.getProperty(BrokerConstants.PERSISTENT_STORE_PROPERTY_NAME);\n-        LOG.debug(\"Configuring Using persistent store file, path={}\", persistencePath);\n-        m_processorBootstrapper = new ProtocolProcessorBootstrapper();\n-        final ProtocolProcessor processor = m_processorBootstrapper.init(config, handlers, authenticator, authorizator,\n-            this);\n-        LOG.debug(\"Initialized MQTT protocol processor\");\n-        if (sslCtxCreator == null) {\n-            LOG.info(\"Using default SSL context creator\");\n-            sslCtxCreator = new DefaultMoquetteSslContextCreator(config);\n-        }\n-\n-        m_acceptor = new NettyAcceptor();\n-        m_acceptor.initialize(processor, config, sslCtxCreator);\n-        m_processor = processor;\n-\n-        final long startTime = System.currentTimeMillis() - start;\n-        LOG.info(\"Moquette server has been started successfully in {} ms\", startTime);\n-        m_initialized = true;\n+    listenOnHazelCastMsg();\n+  }\n+\n+  private void listenOnHazelCastMsg() {\n+    LOG.info(\"Subscribing to Hazelcast topic. TopicName={}\", \"moquette\");\n+    HazelcastInstance hz = getHazelcastInstance();\n+    ITopic<HazelcastMsg> topic = hz.getTopic(\"moquette\");\n+    topic.addMessageListener(new HazelcastListener(this));\n+  }\n+\n+  public HazelcastInstance getHazelcastInstance() {\n+    return hazelcastInstance;\n+  }\n+\n+  /**\n+   * Use the broker to publish a message. It's intended for embedding applications. It can be used\n+   * only after the server is correctly started with startServer.\n+   *\n+   * @param msg      the message to forward.\n+   * @param clientId the id of the sending server.\n+   * @throws IllegalStateException if the server is not yet started\n+   */\n+  public void internalPublish(MqttPublishMessage msg, final String clientId) {\n+    final int messageID = msg.variableHeader().messageId();\n+    if (!m_initialized) {\n+      LOG.error(\"Moquette is not started, internal message cannot be published. CId={}, messageId={}\", clientId,\n+          messageID);\n+      throw new IllegalStateException(\"Can't publish on a server is not yet started\");\n     }\n-\n-    private void configureCluster(IConfig config) throws FileNotFoundException {\n-        LOG.info(\"Configuring embedded Hazelcast instance\");\n-        String interceptHandlerClassname = config.getProperty(BrokerConstants.INTERCEPT_HANDLER_PROPERTY_NAME);\n-        if (interceptHandlerClassname == null || !HZ_INTERCEPT_HANDLER.equals(interceptHandlerClassname)) {\n-            LOG.info(\"There are no Hazelcast intercept handlers. The server won't start a Hazelcast instance.\");\n-            return;\n-        }\n-        String hzConfigPath = config.getProperty(BrokerConstants.HAZELCAST_CONFIGURATION);\n-        if (hzConfigPath != null) {\n-            boolean isHzConfigOnClasspath = this.getClass().getClassLoader().getResource(hzConfigPath) != null;\n-            Config hzconfig = isHzConfigOnClasspath\n-                ? new ClasspathXmlConfig(hzConfigPath)\n-                : new FileSystemXmlConfig(hzConfigPath);\n-            LOG.info(\"Starting Hazelcast instance. ConfigurationFile={}\", hzconfig);\n-            hazelcastInstance = Hazelcast.newHazelcastInstance(hzconfig);\n-        } else {\n-            LOG.info(\"Starting Hazelcast instance with default configuration\");\n-            hazelcastInstance = Hazelcast.newHazelcastInstance();\n-        }\n-        listenOnHazelCastMsg();\n+    LOG.debug(\"Publishing message. CId={}, messageId={}\", clientId, messageID);\n+    m_processor.internalPublish(msg, clientId);\n+  }\n+\n+  public void stopServer() {\n+    LOG.info(\"Unbinding server from the configured ports\");\n+    m_acceptor.close();\n+    LOG.trace(\"Stopping MQTT protocol processor\");\n+    m_processorBootstrapper.shutdown();\n+    m_initialized = false;\n+    if (hazelcastInstance != null) {\n+      LOG.trace(\"Stopping embedded Hazelcast instance\");\n+      try {\n+        hazelcastInstance.shutdown();\n+      } catch (HazelcastInstanceNotActiveException e) {\n+        LOG.warn(\"embedded Hazelcast instance is already shut down.\");\n+      }\n     }\n \n-    private void listenOnHazelCastMsg() {\n-        LOG.info(\"Subscribing to Hazelcast topic. TopicName={}\", \"moquette\");\n-        HazelcastInstance hz = getHazelcastInstance();\n-        ITopic<HazelcastMsg> topic = hz.getTopic(\"moquette\");\n-        topic.addMessageListener(new HazelcastListener(this));\n+    // calling shutdown() does not actually stop tasks that are not cancelled,\n+    // and SessionsRepository does not stop its tasks. Thus shutdownNow().\n+    scheduler.shutdownNow();\n+\n+    LOG.info(\"Moquette server has been stopped.\");\n+  }\n+\n+  /**\n+   * SPI method used by Broker embedded applications to get list of subscribers. Returns null if\n+   * the broker is not started.\n+   *\n+   * @return list of subscriptions.\n+   */\n+  public List<Subscription> getSubscriptions() {\n+    if (m_processorBootstrapper == null) {\n+      return null;\n     }\n-\n-    public HazelcastInstance getHazelcastInstance() {\n-        return hazelcastInstance;\n+    return m_processorBootstrapper.getSubscriptions();\n+  }\n+\n+  /**\n+   * SPI method used by Broker embedded applications to add intercept handlers.\n+   *\n+   * @param interceptHandler the handler to add.\n+   */\n+  public void addInterceptHandler(InterceptHandler interceptHandler) {\n+    if (!m_initialized) {\n+      LOG.error(\"Moquette is not started, MQTT message interceptor cannot be added. InterceptorId={}\",\n+          interceptHandler.getID());\n+      throw new IllegalStateException(\"Can't register interceptors on a server that is not yet started\");\n     }\n-\n-    /**\n-     * Use the broker to publish a message. It's intended for embedding applications. It can be used\n-     * only after the server is correctly started with startServer.\n-     *\n-     * @param msg      the message to forward.\n-     * @param clientId the id of the sending server.\n-     * @throws IllegalStateException if the server is not yet started\n-     */\n-    public void internalPublish(MqttPublishMessage msg, final String clientId) {\n-        final int messageID = msg.variableHeader().messageId();\n-        if (!m_initialized) {\n-            LOG.error(\"Moquette is not started, internal message cannot be published. CId={}, messageId={}\", clientId,\n-                messageID);\n-            throw new IllegalStateException(\"Can't publish on a server is not yet started\");\n-        }\n-        LOG.debug(\"Publishing message. CId={}, messageId={}\", clientId, messageID);\n-        m_processor.internalPublish(msg, clientId);\n-    }\n-\n-    public void stopServer() {\n-        LOG.info(\"Unbinding server from the configured ports\");\n-        m_acceptor.close();\n-        LOG.trace(\"Stopping MQTT protocol processor\");\n-        m_processorBootstrapper.shutdown();\n-        m_initialized = false;\n-        if (hazelcastInstance != null) {\n-            LOG.trace(\"Stopping embedded Hazelcast instance\");\n-            try {\n-                hazelcastInstance.shutdown();\n-            } catch (HazelcastInstanceNotActiveException e) {\n-                LOG.warn(\"embedded Hazelcast instance is already shut down.\");\n-            }\n-        }\n-\n-\t\t// calling shutdown() does not actually stop tasks that are not cancelled,\n-\t\t// and SessionsRepository does not stop its tasks. Thus shutdownNow().\n-        scheduler.shutdownNow();\n-\n-        LOG.info(\"Moquette server has been stopped.\");\n-    }\n-\n-    /**\n-     * SPI method used by Broker embedded applications to get list of subscribers. Returns null if\n-     * the broker is not started.\n-     *\n-     * @return list of subscriptions.\n-     */\n-    public List<Subscription> getSubscriptions() {\n-        if (m_processorBootstrapper == null) {\n-            return null;\n-        }\n-        return m_processorBootstrapper.getSubscriptions();\n-    }\n-\n-    /**\n-     * SPI method used by Broker embedded applications to add intercept handlers.\n-     *\n-     * @param interceptHandler the handler to add.\n-     */\n-    public void addInterceptHandler(InterceptHandler interceptHandler) {\n-        if (!m_initialized) {\n-            LOG.error(\"Moquette is not started, MQTT message interceptor cannot be added. InterceptorId={}\",\n-                interceptHandler.getID());\n-            throw new IllegalStateException(\"Can't register interceptors on a server that is not yet started\");\n-        }\n-        LOG.info(\"Adding MQTT message interceptor. InterceptorId={}\", interceptHandler.getID());\n-        m_processor.addInterceptHandler(interceptHandler);\n-    }\n-\n-    /**\n-     * SPI method used by Broker embedded applications to remove intercept handlers.\n-     *\n-     * @param interceptHandler the handler to remove.\n-     */\n-    public void removeInterceptHandler(InterceptHandler interceptHandler) {\n-        if (!m_initialized) {\n-            LOG.error(\"Moquette is not started, MQTT message interceptor cannot be removed. InterceptorId={}\",\n-                interceptHandler.getID());\n-            throw new IllegalStateException(\"Can't deregister interceptors from a server that is not yet started\");\n-        }\n-        LOG.info(\"Removing MQTT message interceptor. InterceptorId={}\", interceptHandler.getID());\n-        m_processor.removeInterceptHandler(interceptHandler);\n-    }\n-\n-    /**\n-     * Returns the connections manager of this broker.\n-     *\n-     * @return IConnectionsManager the instance used bt the broker.\n-     */\n-    public IConnectionsManager getConnectionsManager() {\n-        return m_processorBootstrapper.getConnectionDescriptors();\n-    }\n-\n-    public ProtocolProcessor getProcessor() {\n-        return m_processor;\n-    }\n-\n-    public ScheduledExecutorService getScheduler() {\n-        return scheduler;\n+    LOG.info(\"Adding MQTT message interceptor. InterceptorId={}\", interceptHandler.getID());\n+    m_processor.addInterceptHandler(interceptHandler);\n+  }\n+\n+  /**\n+   * SPI method used by Broker embedded applications to remove intercept handlers.\n+   *\n+   * @param interceptHandler the handler to remove.\n+   */\n+  public void removeInterceptHandler(InterceptHandler interceptHandler) {\n+    if (!m_initialized) {\n+      LOG.error(\"Moquette is not started, MQTT message interceptor cannot be removed. InterceptorId={}\",\n+          interceptHandler.getID());\n+      throw new IllegalStateException(\"Can't deregister interceptors from a server that is not yet started\");\n     }\n+    LOG.info(\"Removing MQTT message interceptor. InterceptorId={}\", interceptHandler.getID());\n+    m_processor.removeInterceptHandler(interceptHandler);\n+  }\n+\n+  /**\n+   * Returns the connections manager of this broker.\n+   *\n+   * @return IConnectionsManager the instance used bt the broker.\n+   */\n+  public IConnectionsManager getConnectionsManager() {\n+    return m_processorBootstrapper.getConnectionDescriptors();\n+  }\n+\n+  public ProtocolProcessor getProcessor() {\n+    return m_processor;\n+  }\n+\n+  public ScheduledExecutorService getScheduler() {\n+    return scheduler;\n+  }\n }\n",
            "diff_size": 379
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "154",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 199).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "169",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 126).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "196",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 131).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/errored/1/36/Server.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/codebuff/36/Server.java\nindex 55b794cb771..6fc81907199 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/errored/1/36/Server.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/codebuff/36/Server.java\n@@ -39,7 +39,6 @@ import io.moquette.spi.security.ISslContextCreator;\n import io.netty.handler.codec.mqtt.MqttPublishMessage;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-\n import java.io.File;\n import java.io.FileNotFoundException;\n import java.io.IOException;\n@@ -54,22 +53,16 @@ import static io.moquette.logging.LoggingUtils.getInterceptorIds;\n /**\n  * Launch a configured version of the server.\n  */\n+\n public class Server {\n \n     private static final Logger LOG = LoggerFactory.getLogger(Server.class);\n-\n     private static final String HZ_INTERCEPT_HANDLER = HazelcastInterceptHandler.class.getCanonicalName();\n-\n     private ServerAcceptor m_acceptor;\n-\n     private volatile boolean m_initialized;\n-\n     private ProtocolProcessor m_processor;\n-\n     private HazelcastInstance hazelcastInstance;\n-\n     private ProtocolProcessorBootstrapper m_processorBootstrapper;\n-\n     private ScheduledExecutorService scheduler;\n \n     public static void main(String[] args) throws IOException {\n@@ -85,6 +78,7 @@ public class Server {\n      *\n      * @throws IOException in case of any IO error.\n      */\n+\n     public void startServer() throws IOException {\n         File defaultConfigurationFile = defaultConfigFile();\n         LOG.info(\"Starting Moquette server. Configuration file path={}\", defaultConfigurationFile.getAbsolutePath());\n@@ -104,6 +98,7 @@ public class Server {\n      * @param configFile text file that contains the configuration.\n      * @throws IOException in case of any IO Error.\n      */\n+\n     public void startServer(File configFile) throws IOException {\n         LOG.info(\"Starting Moquette server. Configuration file path={}\", configFile.getAbsolutePath());\n         IResourceLoader filesystemLoader = new FileResourceLoader(configFile);\n@@ -123,6 +118,7 @@ public class Server {\n      * @param configProps the properties map to use as configuration.\n      * @throws IOException in case of any IO Error.\n      */\n+\n     public void startServer(Properties configProps) throws IOException {\n         LOG.debug(\"Starting Moquette server using properties object\");\n         final IConfig config = new MemoryConfig(configProps);\n@@ -135,6 +131,7 @@ public class Server {\n      * @param config the configuration to use to start the broker.\n      * @throws IOException in case of any IO Error.\n      */\n+\n     public void startServer(IConfig config) throws IOException {\n         LOG.debug(\"Starting Moquette server using IConfig instance\");\n         startServer(config, null);\n@@ -148,21 +145,19 @@ public class Server {\n      * @param handlers the handlers to install in the broker.\n      * @throws IOException in case of any IO Error.\n      */\n+\n     public void startServer(IConfig config, List<? extends InterceptHandler> handlers) throws IOException {\n         LOG.debug(\"Starting moquette server using IConfig instance and intercept handlers\");\n         startServer(config, handlers, null, null, null);\n     }\n \n-    public void startServer(IConfig config, List<? extends InterceptHandler> handlers, ISslContextCreator sslCtxCreator,\n-                            IAuthenticator authenticator, IAuthorizator authorizator) throws IOException {\n+    public void startServer(IConfig config, List<? extends InterceptHandler> handlers, ISslContextCreator sslCtxCreator, IAuthenticator authenticator, IAuthorizator authorizator) throws IOException {\n         final long start = System.currentTimeMillis();\n         if (handlers == null) {\n             handlers = Collections.emptyList();\n         }\n         LOG.trace(\"Starting Moquette Server. MQTT message interceptors={}\", getInterceptorIds(handlers));\n-\n         scheduler = Executors.newScheduledThreadPool(1);\n-\n         final String handlerProp = System.getProperty(BrokerConstants.INTERCEPT_HANDLER_PROPERTY_NAME);\n         if (handlerProp != null) {\n             config.setProperty(BrokerConstants.INTERCEPT_HANDLER_PROPERTY_NAME, handlerProp);\n@@ -171,18 +166,15 @@ public class Server {\n         final String persistencePath = config.getProperty(BrokerConstants.PERSISTENT_STORE_PROPERTY_NAME);\n         LOG.debug(\"Configuring Using persistent store file, path={}\", persistencePath);\n         m_processorBootstrapper = new ProtocolProcessorBootstrapper();\n-        final ProtocolProcessor processor = m_processorBootstrapper.init(config, handlers, authenticator, authorizator,\n-            this);\n+        final ProtocolProcessor processor = m_processorBootstrapper.init(config, handlers, authenticator, authorizator, this);\n         LOG.debug(\"Initialized MQTT protocol processor\");\n         if (sslCtxCreator == null) {\n             LOG.info(\"Using default SSL context creator\");\n             sslCtxCreator = new DefaultMoquetteSslContextCreator(config);\n         }\n-\n         m_acceptor = new NettyAcceptor();\n         m_acceptor.initialize(processor, config, sslCtxCreator);\n         m_processor = processor;\n-\n         final long startTime = System.currentTimeMillis() - start;\n         LOG.info(\"Moquette server has been started successfully in {} ms\", startTime);\n         m_initialized = true;\n@@ -195,12 +187,13 @@ public class Server {\n             LOG.info(\"There are no Hazelcast intercept handlers. The server won't start a Hazelcast instance.\");\n             return;\n         }\n+\n         String hzConfigPath = config.getProperty(BrokerConstants.HAZELCAST_CONFIGURATION);\n         if (hzConfigPath != null) {\n-            boolean isHzConfigOnClasspath = this.getClass().getClassLoader().getResource(hzConfigPath) != null;\n-            Config hzconfig = isHzConfigOnClasspath\n-                ? new ClasspathXmlConfig(hzConfigPath)\n-                : new FileSystemXmlConfig(hzConfigPath);\n+            boolean isHzConfigOnClasspath = this.getClass()\n+.getClassLoader()\n+.getResource(hzConfigPath) != null;\n+            Config hzconfig = isHzConfigOnClasspath ? new ClasspathXmlConfig(hzConfigPath) : new FileSystemXmlConfig(hzConfigPath);\n             LOG.info(\"Starting Hazelcast instance. ConfigurationFile={}\", hzconfig);\n             hazelcastInstance = Hazelcast.newHazelcastInstance(hzconfig);\n         } else {\n@@ -229,10 +222,12 @@ public class Server {\n      * @param clientId the id of the sending server.\n      * @throws IllegalStateException if the server is not yet started\n      */\n+\n     public void internalPublish(MqttPublishMessage msg, final String clientId) {\n         final int messageID = msg.variableHeader().messageId();\n         if (!m_initialized) {\n-            LOG.error(\"Moquette is not started, internal message cannot be published. CId={}, messageId={}\", clientId,\n+            LOG.error(\"Moquette is not started, internal message cannot be published. CId={}, messageId={}\",\n+                clientId,\n                 messageID);\n             throw new IllegalStateException(\"Can't publish on a server is not yet started\");\n         }\n@@ -255,10 +250,9 @@ public class Server {\n             }\n         }\n \n-\t\t// calling shutdown() does not actually stop tasks that are not cancelled,\n-\t\t// and SessionsRepository does not stop its tasks. Thus shutdownNow().\n+        // calling shutdown() does not actually stop tasks that are not cancelled,\n+        // and SessionsRepository does not stop its tasks. Thus shutdownNow().\n         scheduler.shutdownNow();\n-\n         LOG.info(\"Moquette server has been stopped.\");\n     }\n \n@@ -268,6 +262,7 @@ public class Server {\n      *\n      * @return list of subscriptions.\n      */\n+\n     public List<Subscription> getSubscriptions() {\n         if (m_processorBootstrapper == null) {\n             return null;\n@@ -280,6 +275,7 @@ public class Server {\n      *\n      * @param interceptHandler the handler to add.\n      */\n+\n     public void addInterceptHandler(InterceptHandler interceptHandler) {\n         if (!m_initialized) {\n             LOG.error(\"Moquette is not started, MQTT message interceptor cannot be added. InterceptorId={}\",\n@@ -295,6 +291,7 @@ public class Server {\n      *\n      * @param interceptHandler the handler to remove.\n      */\n+\n     public void removeInterceptHandler(InterceptHandler interceptHandler) {\n         if (!m_initialized) {\n             LOG.error(\"Moquette is not started, MQTT message interceptor cannot be removed. InterceptorId={}\",\n@@ -310,6 +307,7 @@ public class Server {\n      *\n      * @return IConnectionsManager the instance used bt the broker.\n      */\n+\n     public IConnectionsManager getConnectionsManager() {\n         return m_processorBootstrapper.getConnectionDescriptors();\n     }\n@@ -321,4 +319,4 @@ public class Server {\n     public ScheduledExecutorService getScheduler() {\n         return scheduler;\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 38
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/errored/1/36/Server.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/styler_random/36/Server.java\nindex 55b794cb771..879013b0e79 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/errored/1/36/Server.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/styler_random/36/Server.java\n@@ -255,8 +255,8 @@ public class Server {\n             }\n         }\n \n-\t\t// calling shutdown() does not actually stop tasks that are not cancelled,\n-\t\t// and SessionsRepository does not stop its tasks. Thus shutdownNow().\n+        // calling shutdown() does not actually stop tasks that are not cancelled,\n+         // and SessionsRepository does not stop its tasks. Thus shutdownNow().\n         scheduler.shutdownNow();\n \n         LOG.info(\"Moquette server has been stopped.\");\n",
            "diff_size": 2
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/errored/1/36/Server.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/styler_three_grams/36/Server.java\nindex 55b794cb771..cb6d61c746f 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/errored/1/36/Server.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/styler_three_grams/36/Server.java\n@@ -255,8 +255,8 @@ public class Server {\n             }\n         }\n \n-\t\t// calling shutdown() does not actually stop tasks that are not cancelled,\n-\t\t// and SessionsRepository does not stop its tasks. Thus shutdownNow().\n+        // calling shutdown() does not actually stop tasks that are not cancelled,\n+  // and SessionsRepository does not stop its tasks. Thus shutdownNow().\n         scheduler.shutdownNow();\n \n         LOG.info(\"Moquette server has been stopped.\");\n",
            "diff_size": 2
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "naturalize",
        "codebuff"
    ]
}