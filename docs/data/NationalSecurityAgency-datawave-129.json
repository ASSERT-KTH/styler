{
    "project_name": "NationalSecurityAgency-datawave",
    "error_id": "129",
    "information": {
        "errors": [
            {
                "line": "131",
                "severity": "error",
                "message": "Accumulo non-public classes imported",
                "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
            }
        ]
    },
    "source_code": "import datawave.webservice.query.runner.Span;\nimport datawave.webservice.query.runner.Trace;\nimport org.apache.accumulo.core.trace.thrift.TInfo;\nimport org.apache.commons.collections4.Transformer;\nimport org.apache.commons.dbutils.DbUtils;\nimport org.apache.commons.jexl2.parser.TokenMgrError;",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "131",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "131",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/129/CachedResultsBean.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/intellij/129/CachedResultsBean.java\nindex fe7d6c9599f..2128d66680c 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/129/CachedResultsBean.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/intellij/129/CachedResultsBean.java\n@@ -143,25 +143,24 @@ import org.jboss.resteasy.specimpl.MultivaluedMapImpl;\n /**\n  * CachedResultsBean loads the results of a predefined query into a relational database (MySQL) so that the user can run SQL queries against the data, which\n  * allows sorting, grouping, etc. When a user calls load(), this bean creates a table in the database that has the following columns:\n- * \n+ * <p>\n  * user, queryId, eventId, datatype, row, colf, visibility, markings, and columns 1 .. N.\n- * \n+ * <p>\n  * Since we are paging through the results from ACCUMULO we don't know all of the possible field names when creating the table. For right now, this bean will\n  * only work with results from the event query logic (ShardQueryTable). After the results have been loaded, a view will be created on the table that user\n  * queries will run against. This view will look like:\n- * \n+ * <p>\n  * user, queryId, eventId, datatype, row, colf, visibility, markings, field1, field2, field3, ...\n- * \n+ * <p>\n  * Currently event attributes that have multiple values will be stored as a comma-separated string in MySQL. We could break these out into different rows in the\n  * database and use the group_concat() SQL function to concatentate them at query time. Also, since the data is coming from a schema-less source, all columns in\n  * the table will be of type Text.\n- * \n+ * <p>\n  * Object that loads a predefined query into a relational database so that SQL queries can be run against it. Typical use case for this object is:\n- *\n+ * <p>\n  * load() create() repeated calls to next() or previous() close()\n- *\n+ * <p>\n  * The object is reusable, so the user could call setQuery again and run a different query against the result set.\n- *\n  */\n @javax.ws.rs.Path(\"/CachedResults\")\n @RolesAllowed({\"AuthorizedUser\", \"AuthorizedQueryServer\", \"InternalUser\", \"Administrator\", \"JBossAdministrator\"})\n@@ -171,2368 +170,2381 @@ import org.jboss.resteasy.specimpl.MultivaluedMapImpl;\n @TransactionAttribute(TransactionAttributeType.NOT_SUPPORTED)\n @TransactionManagement(TransactionManagementType.BEAN)\n public class CachedResultsBean {\n-    \n-    private static Logger log = Logger.getLogger(CachedResultsBean.class);\n-    \n-    @Resource\n-    private EJBContext ctx;\n-    \n-    @Inject\n-    private Persister persister;\n-    \n-    @Inject\n-    private AccumuloConnectionFactory connectionFactory;\n-    \n-    @Inject\n-    private QueryLogicFactory queryFactory;\n-    \n-    @Inject\n-    private QueryMetricsBean metrics;\n-    \n-    @Resource(lookup = \"java:jboss/datasources/CachedResultsDS\")\n-    protected DataSource ds;\n-    \n-    @Inject\n-    private QueryCache runningQueryCache;\n-    \n-    @Inject\n-    private AuditBean auditor;\n-    \n-    @Inject\n-    private CreatedQueryLogicCacheBean qlCache;\n-    \n-    @Resource\n-    private ManagedExecutorService executor;\n-    \n-    @Inject\n-    private QueryPredictor predictor;\n-    \n-    protected static String BASE_COLUMNS = null;\n-    \n-    @Inject\n-    private ResponseObjectFactory responseObjectFactory;\n-    \n-    // reference \"datawave/query/CachedResults.xml\"\n-    @Inject\n-    @SpringBean(required = false, refreshable = true)\n-    private CachedResultsConfiguration cachedResultsConfiguration;\n-    \n-    @Inject\n-    private CachedResultsQueryCache cachedRunningQueryCache;\n-    \n-    @Inject\n-    private SecurityMarking marking;\n-    \n-    @Inject\n-    @SpringBean(refreshable = true)\n-    private QueryExpirationConfiguration queryExpirationConf;\n-    \n-    @Inject\n-    private QueryMetricFactory metricFactory;\n-    \n-    @Inject\n-    private AccumuloConnectionRequestBean accumuloConnectionRequestBean;\n-    \n-    static {\n-        BASE_COLUMNS = StringUtils.join(CacheableQueryRow.getFixedColumnSet(), \",\");\n+\n+  private static Logger log = Logger.getLogger(CachedResultsBean.class);\n+\n+  @Resource\n+  private EJBContext ctx;\n+\n+  @Inject\n+  private Persister persister;\n+\n+  @Inject\n+  private AccumuloConnectionFactory connectionFactory;\n+\n+  @Inject\n+  private QueryLogicFactory queryFactory;\n+\n+  @Inject\n+  private QueryMetricsBean metrics;\n+\n+  @Resource(lookup = \"java:jboss/datasources/CachedResultsDS\")\n+  protected DataSource ds;\n+\n+  @Inject\n+  private QueryCache runningQueryCache;\n+\n+  @Inject\n+  private AuditBean auditor;\n+\n+  @Inject\n+  private CreatedQueryLogicCacheBean qlCache;\n+\n+  @Resource\n+  private ManagedExecutorService executor;\n+\n+  @Inject\n+  private QueryPredictor predictor;\n+\n+  protected static String BASE_COLUMNS = null;\n+\n+  @Inject\n+  private ResponseObjectFactory responseObjectFactory;\n+\n+  // reference \"datawave/query/CachedResults.xml\"\n+  @Inject\n+  @SpringBean(required = false, refreshable = true)\n+  private CachedResultsConfiguration cachedResultsConfiguration;\n+\n+  @Inject\n+  private CachedResultsQueryCache cachedRunningQueryCache;\n+\n+  @Inject\n+  private SecurityMarking marking;\n+\n+  @Inject\n+  @SpringBean(refreshable = true)\n+  private QueryExpirationConfiguration queryExpirationConf;\n+\n+  @Inject\n+  private QueryMetricFactory metricFactory;\n+\n+  @Inject\n+  private AccumuloConnectionRequestBean accumuloConnectionRequestBean;\n+\n+  static {\n+    BASE_COLUMNS = StringUtils.join(CacheableQueryRow.getFixedColumnSet(), \",\");\n+  }\n+\n+  protected static final String COMMA = \",\";\n+  protected static final String TABLE = \"$table\";\n+  protected static final String FIELD = \"field\";\n+\n+  private static final String IMPORT_FILE = \"replication_scripts/import.sh\";\n+\n+  private static Map<String, RunningQuery> loadingQueryMap = Collections.synchronizedMap(new HashMap<>());\n+  private static Set<String> loadingQueries = Collections.synchronizedSet(new HashSet<>());\n+  private URL importFileUrl = null;\n+  private CachedResultsParameters cp = new CachedResultsParameters();\n+\n+  @PostConstruct\n+  public void init() {\n+    // create the template table in the database if it does not exist.\n+\n+    if (cachedResultsConfiguration.getDefaultPageSize() > cachedResultsConfiguration.getMaxPageSize()) {\n+      throw new EJBException(\"The default page size \" + cachedResultsConfiguration.getDefaultPageSize() +\n+          \" has been set larger than the max page size \"\n+          + cachedResultsConfiguration.getMaxPageSize());\n+    }\n+\n+    try {\n+      importFileUrl = new File(System.getProperty(\"jboss.home.dir\"), IMPORT_FILE).toURI().toURL();\n+      log.info(\"import.sh: \" + importFileUrl);\n+    } catch (MalformedURLException e) {\n+      log.error(\"Error getting import.sh\", e);\n+      importFileUrl = null;\n+    }\n+\n+    CachedRunningQuery.setDatasource(ds);\n+    CachedRunningQuery.setQueryFactory(queryFactory);\n+    CachedRunningQuery.setResponseObjectFactory(responseObjectFactory);\n+\n+    String template = null;\n+    try (Connection con = ds.getConnection()) {\n+      Statement s = con.createStatement();\n+      template = cachedResultsConfiguration.getParameters().get(\"TEMPLATE_TABLE\");\n+      s.execute(template);\n+    } catch (SQLException sqle) {\n+      log.error(sqle.getMessage(), sqle);\n+      throw new EJBException(\"Unable to create template table with statement: \" + template, sqle);\n+    }\n+  }\n+\n+  protected void loadBatch(PreparedStatement ps, String owner, String queryId, String logicName,\n+                           Map<String, Integer> fieldMap, CacheableQueryRow cqo,\n+                           int maxFieldSize) throws SQLException {\n+\n+    // Maintain a list of the columns that are populated so\n+    // that we can\n+    // set the others to null.\n+    HashSet<Integer> populatedColumns = new HashSet<>();\n+    // Done capturing all the fields in the event, insert\n+    // into database.\n+    ps.clearParameters(); // not sure we need this\n+\n+    // Each entry is a different visibility.\n+    ps.setString(1, owner);\n+    ps.setString(2, queryId);\n+    ps.setString(3, logicName);\n+    ps.setString(4, cqo.getDataType());\n+    ps.setString(5, cqo.getEventId());\n+    ps.setString(6, cqo.getRow());\n+    ps.setString(7, cqo.getColFam());\n+    ps.setString(8, MarkingFunctions.Encoding.toString(new TreeMap<>(cqo.getMarkings())));\n+    for (Entry<String, String> e : cqo.getColumnValues().entrySet()) {\n+\n+      String columnName = e.getKey();\n+      String columnValue = e.getValue();\n+      // Get the field number from the fieldMap.\n+      Integer columnNumber = fieldMap.get(columnName);\n+      if (columnNumber == null) {\n+        columnNumber = CacheableQueryRow.getFixedColumnSet().size() + fieldMap.size() + 1;\n+        fieldMap.put(columnName, columnNumber);\n+      }\n+\n+      if (columnValue.length() > maxFieldSize) {\n+        columnValue = columnValue.substring(0, maxFieldSize) + \"<truncated>\";\n+        ps.setString(columnNumber, columnValue);\n+      } else {\n+        ps.setString(columnNumber, columnValue);\n+      }\n+      populatedColumns.add(columnNumber);\n+      if (log.isTraceEnabled()) {\n+        log.trace(\"Set parameter: \" + columnNumber + \" with field name: \" + columnName + \" to value: \" + columnValue);\n+      }\n     }\n-    \n-    protected static final String COMMA = \",\";\n-    protected static final String TABLE = \"$table\";\n-    protected static final String FIELD = \"field\";\n-    \n-    private static final String IMPORT_FILE = \"replication_scripts/import.sh\";\n-    \n-    private static Map<String,RunningQuery> loadingQueryMap = Collections.synchronizedMap(new HashMap<>());\n-    private static Set<String> loadingQueries = Collections.synchronizedSet(new HashSet<>());\n-    private URL importFileUrl = null;\n-    private CachedResultsParameters cp = new CachedResultsParameters();\n-    \n-    @PostConstruct\n-    public void init() {\n-        // create the template table in the database if it does not exist.\n-        \n-        if (cachedResultsConfiguration.getDefaultPageSize() > cachedResultsConfiguration.getMaxPageSize()) {\n-            throw new EJBException(\"The default page size \" + cachedResultsConfiguration.getDefaultPageSize() + \" has been set larger than the max page size \"\n-                            + cachedResultsConfiguration.getMaxPageSize());\n+\n+    ps.setString(9, cqo.getColumnSecurityMarkingString(fieldMap));\n+    ps.setString(10, cqo.getColumnTimestampString(fieldMap));\n+\n+    // Need to set all of the remaining parameters to\n+    // NULL\n+    int startCol = CacheableQueryRow.getFixedColumnSet().size() + 1;\n+    int maxCol = CacheableQueryRow.getFixedColumnSet().size() + 901;\n+    for (int i = startCol; i < maxCol; i++) {\n+      if (!populatedColumns.contains(i)) {\n+        ps.setNull(i, Types.VARCHAR);\n+      }\n+    }\n+    ps.addBatch();\n+\n+  }\n+\n+  protected GenericResponse<String> load(@Required(\"queryId\") String queryId, String alias, String nameBase) {\n+\n+    GenericResponse<String> response = new GenericResponse<>();\n+\n+    // Find out who/what called this method\n+    Principal p = ctx.getCallerPrincipal();\n+    String owner = getOwnerFromPrincipal(p);\n+    String userDn = getDNFromPrincipal(p);\n+    Collection<Collection<String>> cbAuths = new HashSet<>();\n+    if (p instanceof DatawavePrincipal) {\n+      DatawavePrincipal dp = (DatawavePrincipal) p;\n+      cbAuths.addAll(dp.getAuthorizations());\n+    } else {\n+      QueryException qe = new QueryException(DatawaveErrorCode.UNEXPECTED_PRINCIPAL_ERROR,\n+          MessageFormat.format(\"Class: {0}\", p.getClass().getName()));\n+      response.addException(qe);\n+      throw new DatawaveWebApplicationException(qe, response);\n+    }\n+\n+    AccumuloConnectionFactory.Priority priority;\n+    Connector connector = null;\n+    RunningQuery query = null;\n+    String tableName = \"t\" + nameBase;\n+    String viewName = \"v\" + nameBase;\n+    Connection con = null;\n+    PreparedStatement ps = null;\n+    boolean tableCreated = false;\n+    boolean viewCreated = false;\n+    CachedRunningQuery crq = null;\n+    Span span = null;\n+    boolean queryLockedException = false;\n+    int rowsPerBatch = cachedResultsConfiguration.getRowsPerBatch();\n+    try {\n+\n+      // This RunningQuery may be in use. Make a copy using the defined Query.\n+\n+      RunningQuery rq = null;\n+      QueryLogic<?> logic = null;\n+      Query q = null;\n+      BaseQueryMetric queryMetric = null;\n+      TInfo traceInfo = null;\n+      try {\n+        rq = getQueryById(queryId);\n+\n+        // prevent duplicate calls to load with the same queryId\n+        if (CachedResultsBean.loadingQueries.contains(queryId)) {\n+          // if a different thread is using rq, we don't want to modify it in the finally block\n+          rq = null;\n+          // this is used in the inside & outside finally block to bypass cleanup that would adversely affect the loading query\n+          queryLockedException = true;\n+          throw new QueryException(DatawaveErrorCode.QUERY_LOCKED_ERROR);\n+        } else {\n+          CachedResultsBean.loadingQueries.add(queryId);\n         }\n-        \n-        try {\n-            importFileUrl = new File(System.getProperty(\"jboss.home.dir\"), IMPORT_FILE).toURI().toURL();\n-            log.info(\"import.sh: \" + importFileUrl);\n-        } catch (MalformedURLException e) {\n-            log.error(\"Error getting import.sh\", e);\n-            importFileUrl = null;\n+\n+        rq.setActiveCall(true);\n+        Query originalQuery = rq.getSettings();\n+        q = originalQuery.duplicate(originalQuery.getQueryName());\n+        q.setId(originalQuery.getId());\n+        q.setUncaughtExceptionHandler(new QueryUncaughtExceptionHandler());\n+        Thread.currentThread().setUncaughtExceptionHandler(q.getUncaughtExceptionHandler());\n+\n+        queryMetric = rq.getMetric().duplicate();\n+        // clear page times\n+        queryMetric.setPageTimes(new ArrayList<>());\n+        // will throw IllegalArgumentException if not defined\n+        logic = rq.getLogic();\n+        // need to clone the logic here because the QueryExpirationBean will call close on\n+        // rq and RunningQuery.close will call close on the logic. This is causing the batch scanner to\n+        // be closed after 15 minutes\n+        logic = (QueryLogic<?>) logic.clone();\n+        if (rq.getTraceInfo() != null) {\n+          traceInfo = rq.getTraceInfo().deepCopy();\n         }\n-        \n-        CachedRunningQuery.setDatasource(ds);\n-        CachedRunningQuery.setQueryFactory(queryFactory);\n-        CachedRunningQuery.setResponseObjectFactory(responseObjectFactory);\n-        \n-        String template = null;\n-        try (Connection con = ds.getConnection()) {\n-            Statement s = con.createStatement();\n-            template = cachedResultsConfiguration.getParameters().get(\"TEMPLATE_TABLE\");\n-            s.execute(template);\n-        } catch (SQLException sqle) {\n-            log.error(sqle.getMessage(), sqle);\n-            throw new EJBException(\"Unable to create template table with statement: \" + template, sqle);\n+      } finally {\n+        if (rq != null) {\n+          // the original query was cloned including the queryId\n+          // remove original query from the cache to avoid duplicate metrics\n+          // when it is expired by the QueryExpirationBean\n+          rq.setActiveCall(false);\n+          if (rq.getConnection() != null) {\n+            connectionFactory.returnConnection(rq.getConnection());\n+          }\n+          runningQueryCache.remove(queryId);\n         }\n-    }\n-    \n-    protected void loadBatch(PreparedStatement ps, String owner, String queryId, String logicName, Map<String,Integer> fieldMap, CacheableQueryRow cqo,\n-                    int maxFieldSize) throws SQLException {\n-        \n-        // Maintain a list of the columns that are populated so\n-        // that we can\n-        // set the others to null.\n-        HashSet<Integer> populatedColumns = new HashSet<>();\n-        // Done capturing all the fields in the event, insert\n-        // into database.\n-        ps.clearParameters(); // not sure we need this\n-        \n-        // Each entry is a different visibility.\n-        ps.setString(1, owner);\n-        ps.setString(2, queryId);\n-        ps.setString(3, logicName);\n-        ps.setString(4, cqo.getDataType());\n-        ps.setString(5, cqo.getEventId());\n-        ps.setString(6, cqo.getRow());\n-        ps.setString(7, cqo.getColFam());\n-        ps.setString(8, MarkingFunctions.Encoding.toString(new TreeMap<>(cqo.getMarkings())));\n-        for (Entry<String,String> e : cqo.getColumnValues().entrySet()) {\n-            \n-            String columnName = e.getKey();\n-            String columnValue = e.getValue();\n-            // Get the field number from the fieldMap.\n-            Integer columnNumber = fieldMap.get(columnName);\n-            if (columnNumber == null) {\n-                columnNumber = CacheableQueryRow.getFixedColumnSet().size() + fieldMap.size() + 1;\n-                fieldMap.put(columnName, columnNumber);\n-            }\n-            \n-            if (columnValue.length() > maxFieldSize) {\n-                columnValue = columnValue.substring(0, maxFieldSize) + \"<truncated>\";\n-                ps.setString(columnNumber, columnValue);\n-            } else {\n-                ps.setString(columnNumber, columnValue);\n-            }\n-            populatedColumns.add(columnNumber);\n-            if (log.isTraceEnabled()) {\n-                log.trace(\"Set parameter: \" + columnNumber + \" with field name: \" + columnName + \" to value: \" + columnValue);\n-            }\n+      }\n+\n+      try {\n+        persistByQueryId(viewName, alias, owner, CachedRunningQuery.Status.LOADING, \"\", false);\n+      } catch (IOException e2) {\n+        PreConditionFailedQueryException e =\n+            new PreConditionFailedQueryException(DatawaveErrorCode.CACHED_RESULTS_IMPORT_ERROR, e2);\n+        response.addException(e);\n+        response.setResult(\"Error loading results into cache\");\n+        throw new PreConditionFailedException(e, response);\n+      }\n+\n+      // Get a accumulo connection\n+      priority = logic.getConnectionPriority();\n+      Map<String, String> trackingMap = connectionFactory.getTrackingMap(Thread.currentThread().getStackTrace());\n+      addQueryToTrackingMap(trackingMap, q);\n+      accumuloConnectionRequestBean.requestBegin(queryId);\n+      try {\n+        connector = connectionFactory.getConnection(priority, trackingMap);\n+      } finally {\n+        accumuloConnectionRequestBean.requestEnd(queryId);\n+      }\n+\n+      CacheableLogic cacheableLogic;\n+      Transformer t = logic.getTransformer(q);\n+\n+      // Audit the query. This may be duplicative if the caller called\n+      // QueryExecutorBean.create() or QueryExecutorBean.reset() first.\n+      AuditType auditType = logic.getAuditType(q);\n+      if (!auditType.equals(AuditType.NONE)) {\n+        try {\n+          MultivaluedMap<String, String> queryMap = q.toMap();\n+          marking.validate(queryMap);\n+          queryMap.putSingle(PrivateAuditConstants.COLUMN_VISIBILITY, marking.toColumnVisibilityString());\n+          queryMap.putSingle(PrivateAuditConstants.AUDIT_TYPE, auditType.name());\n+          queryMap.putSingle(PrivateAuditConstants.USER_DN, q.getUserDN());\n+          queryMap.putSingle(PrivateAuditConstants.LOGIC_CLASS, logic.getLogicName());\n+          try {\n+            List<String> selectors = logic.getSelectors(q);\n+            if (selectors != null && !selectors.isEmpty()) {\n+              queryMap.put(PrivateAuditConstants.SELECTORS, selectors);\n+            }\n+          } catch (Exception e) {\n+            log.error(e.getMessage());\n+          }\n+          auditor.audit(queryMap);\n+        } catch (Exception e) {\n+          QueryException qe = new QueryException(DatawaveErrorCode.QUERY_AUDITING_ERROR, e);\n+          log.error(qe);\n+          response.addException(qe.getBottomQueryException());\n+          throw new DatawaveWebApplicationException(qe, response);\n         }\n-        \n-        ps.setString(9, cqo.getColumnSecurityMarkingString(fieldMap));\n-        ps.setString(10, cqo.getColumnTimestampString(fieldMap));\n-        \n-        // Need to set all of the remaining parameters to\n-        // NULL\n-        int startCol = CacheableQueryRow.getFixedColumnSet().size() + 1;\n-        int maxCol = CacheableQueryRow.getFixedColumnSet().size() + 901;\n-        for (int i = startCol; i < maxCol; i++) {\n-            if (!populatedColumns.contains(i)) {\n-                ps.setNull(i, Types.VARCHAR);\n-            }\n+      }\n+\n+      if (t instanceof CacheableLogic) {\n+        // hold on to a reference of the query logic so we cancel it if need be.\n+        qlCache.add(q.getId().toString(), owner, logic, connector);\n+\n+        try {\n+          query = new RunningQuery(null, null, logic.getConnectionPriority(), logic, q, q.getQueryAuthorizations(), p,\n+              new RunningQueryTimingImpl(\n+                  queryExpirationConf, q.getPageTimeout()), executor, predictor, metricFactory);\n+          query.setActiveCall(true);\n+          // queryMetric was duplicated from the original earlier\n+          query.setMetric(queryMetric);\n+          query.setQueryMetrics(metrics);\n+          query.setConnection(connector);\n+          // Copy trace info from a clone of the original query\n+          query.setTraceInfo(traceInfo);\n+        } finally {\n+          qlCache.poll(q.getId().toString());\n         }\n-        ps.addBatch();\n-        \n-    }\n-    \n-    protected GenericResponse<String> load(@Required(\"queryId\") String queryId, String alias, String nameBase) {\n-        \n-        GenericResponse<String> response = new GenericResponse<>();\n-        \n-        // Find out who/what called this method\n-        Principal p = ctx.getCallerPrincipal();\n-        String owner = getOwnerFromPrincipal(p);\n-        String userDn = getDNFromPrincipal(p);\n-        Collection<Collection<String>> cbAuths = new HashSet<>();\n-        if (p instanceof DatawavePrincipal) {\n-            DatawavePrincipal dp = (DatawavePrincipal) p;\n-            cbAuths.addAll(dp.getAuthorizations());\n-        } else {\n-            QueryException qe = new QueryException(DatawaveErrorCode.UNEXPECTED_PRINCIPAL_ERROR, MessageFormat.format(\"Class: {0}\", p.getClass().getName()));\n-            response.addException(qe);\n-            throw new DatawaveWebApplicationException(qe, response);\n+\n+        cacheableLogic = (CacheableLogic) t;\n+        CachedResultsBean.loadingQueryMap.put(queryId, query);\n+      } else {\n+        throw new IllegalArgumentException(logic.getLogicName() + \" does not support CachedResults calls\");\n+      }\n+\n+      try {\n+        con = ds.getConnection();\n+        // Create the result table for this query\n+        Statement s = con.createStatement();\n+        String createTable = cachedResultsConfiguration.getParameters().get(\"CREATE_TABLE\");\n+        createTable = createTable.replace(TABLE, tableName);\n+        s.execute(createTable);\n+        s.close();\n+        tableCreated = true;\n+        // Parse the PreparedStatement\n+        String insert = cachedResultsConfiguration.getParameters().get(\"INSERT\");\n+        insert = insert.replace(TABLE, tableName);\n+        ps = con.prepareStatement(insert);\n+      } catch (SQLException sqle) {\n+        throw new QueryException(DatawaveErrorCode.CACHED_RESULTS_TABLE_CREATE_ERROR, sqle);\n+      }\n+\n+      // Object for keeping track of which fields are placed in which\n+      // table columns\n+      // Key is fieldName, value is column number\n+      Map<String, Integer> fieldMap = new HashMap<>();\n+\n+      // Loop over the results and put them into the database.\n+      ResultsPage results = null;\n+\n+      // If we're tracing this query, then continue the trace for the next call.\n+      if (traceInfo != null) {\n+        span = Trace.trace(traceInfo, \"cachedresults:load\");\n+      }\n+\n+      int rowsWritten = 0;\n+      boolean go = true;\n+      while (go) {\n+\n+        if (query.isCanceled()) {\n+          throw new QueryCanceledQueryException(DatawaveErrorCode.QUERY_CANCELED);\n         }\n-        \n-        AccumuloConnectionFactory.Priority priority;\n-        Connector connector = null;\n-        RunningQuery query = null;\n-        String tableName = \"t\" + nameBase;\n-        String viewName = \"v\" + nameBase;\n-        Connection con = null;\n-        PreparedStatement ps = null;\n-        boolean tableCreated = false;\n-        boolean viewCreated = false;\n-        CachedRunningQuery crq = null;\n-        Span span = null;\n-        boolean queryLockedException = false;\n-        int rowsPerBatch = cachedResultsConfiguration.getRowsPerBatch();\n+\n+        Span nextSpan = (span == null) ? null : Trace.start(\"cachedresults:next\");\n         try {\n-            \n-            // This RunningQuery may be in use. Make a copy using the defined Query.\n-            \n-            RunningQuery rq = null;\n-            QueryLogic<?> logic = null;\n-            Query q = null;\n-            BaseQueryMetric queryMetric = null;\n-            TInfo traceInfo = null;\n-            try {\n-                rq = getQueryById(queryId);\n-                \n-                // prevent duplicate calls to load with the same queryId\n-                if (CachedResultsBean.loadingQueries.contains(queryId)) {\n-                    // if a different thread is using rq, we don't want to modify it in the finally block\n-                    rq = null;\n-                    // this is used in the inside & outside finally block to bypass cleanup that would adversely affect the loading query\n-                    queryLockedException = true;\n-                    throw new QueryException(DatawaveErrorCode.QUERY_LOCKED_ERROR);\n-                } else {\n-                    CachedResultsBean.loadingQueries.add(queryId);\n-                }\n-                \n-                rq.setActiveCall(true);\n-                Query originalQuery = rq.getSettings();\n-                q = originalQuery.duplicate(originalQuery.getQueryName());\n-                q.setId(originalQuery.getId());\n-                q.setUncaughtExceptionHandler(new QueryUncaughtExceptionHandler());\n-                Thread.currentThread().setUncaughtExceptionHandler(q.getUncaughtExceptionHandler());\n-                \n-                queryMetric = rq.getMetric().duplicate();\n-                // clear page times\n-                queryMetric.setPageTimes(new ArrayList<>());\n-                // will throw IllegalArgumentException if not defined\n-                logic = rq.getLogic();\n-                // need to clone the logic here because the QueryExpirationBean will call close on\n-                // rq and RunningQuery.close will call close on the logic. This is causing the batch scanner to\n-                // be closed after 15 minutes\n-                logic = (QueryLogic<?>) logic.clone();\n-                if (rq.getTraceInfo() != null) {\n-                    traceInfo = rq.getTraceInfo().deepCopy();\n-                }\n-            } finally {\n-                if (rq != null) {\n-                    // the original query was cloned including the queryId\n-                    // remove original query from the cache to avoid duplicate metrics\n-                    // when it is expired by the QueryExpirationBean\n-                    rq.setActiveCall(false);\n-                    if (rq.getConnection() != null) {\n-                        connectionFactory.returnConnection(rq.getConnection());\n-                    }\n-                    runningQueryCache.remove(queryId);\n-                }\n-            }\n-            \n-            try {\n-                persistByQueryId(viewName, alias, owner, CachedRunningQuery.Status.LOADING, \"\", false);\n-            } catch (IOException e2) {\n-                PreConditionFailedQueryException e = new PreConditionFailedQueryException(DatawaveErrorCode.CACHED_RESULTS_IMPORT_ERROR, e2);\n-                response.addException(e);\n-                response.setResult(\"Error loading results into cache\");\n-                throw new PreConditionFailedException(e, response);\n-            }\n-            \n-            // Get a accumulo connection\n-            priority = logic.getConnectionPriority();\n-            Map<String,String> trackingMap = connectionFactory.getTrackingMap(Thread.currentThread().getStackTrace());\n-            addQueryToTrackingMap(trackingMap, q);\n-            accumuloConnectionRequestBean.requestBegin(queryId);\n-            try {\n-                connector = connectionFactory.getConnection(priority, trackingMap);\n-            } finally {\n-                accumuloConnectionRequestBean.requestEnd(queryId);\n-            }\n-            \n-            CacheableLogic cacheableLogic;\n-            Transformer t = logic.getTransformer(q);\n-            \n-            // Audit the query. This may be duplicative if the caller called\n-            // QueryExecutorBean.create() or QueryExecutorBean.reset() first.\n-            AuditType auditType = logic.getAuditType(q);\n-            if (!auditType.equals(AuditType.NONE)) {\n-                try {\n-                    MultivaluedMap<String,String> queryMap = q.toMap();\n-                    marking.validate(queryMap);\n-                    queryMap.putSingle(PrivateAuditConstants.COLUMN_VISIBILITY, marking.toColumnVisibilityString());\n-                    queryMap.putSingle(PrivateAuditConstants.AUDIT_TYPE, auditType.name());\n-                    queryMap.putSingle(PrivateAuditConstants.USER_DN, q.getUserDN());\n-                    queryMap.putSingle(PrivateAuditConstants.LOGIC_CLASS, logic.getLogicName());\n-                    try {\n-                        List<String> selectors = logic.getSelectors(q);\n-                        if (selectors != null && !selectors.isEmpty()) {\n-                            queryMap.put(PrivateAuditConstants.SELECTORS, selectors);\n-                        }\n-                    } catch (Exception e) {\n-                        log.error(e.getMessage());\n-                    }\n-                    auditor.audit(queryMap);\n-                } catch (Exception e) {\n-                    QueryException qe = new QueryException(DatawaveErrorCode.QUERY_AUDITING_ERROR, e);\n-                    log.error(qe);\n-                    response.addException(qe.getBottomQueryException());\n-                    throw new DatawaveWebApplicationException(qe, response);\n-                }\n-            }\n-            \n-            if (t instanceof CacheableLogic) {\n-                // hold on to a reference of the query logic so we cancel it if need be.\n-                qlCache.add(q.getId().toString(), owner, logic, connector);\n-                \n-                try {\n-                    query = new RunningQuery(null, null, logic.getConnectionPriority(), logic, q, q.getQueryAuthorizations(), p, new RunningQueryTimingImpl(\n-                                    queryExpirationConf, q.getPageTimeout()), executor, predictor, metricFactory);\n-                    query.setActiveCall(true);\n-                    // queryMetric was duplicated from the original earlier\n-                    query.setMetric(queryMetric);\n-                    query.setQueryMetrics(metrics);\n-                    query.setConnection(connector);\n-                    // Copy trace info from a clone of the original query\n-                    query.setTraceInfo(traceInfo);\n-                } finally {\n-                    qlCache.poll(q.getId().toString());\n-                }\n-                \n-                cacheableLogic = (CacheableLogic) t;\n-                CachedResultsBean.loadingQueryMap.put(queryId, query);\n-            } else {\n-                throw new IllegalArgumentException(logic.getLogicName() + \" does not support CachedResults calls\");\n-            }\n-            \n-            try {\n-                con = ds.getConnection();\n-                // Create the result table for this query\n-                Statement s = con.createStatement();\n-                String createTable = cachedResultsConfiguration.getParameters().get(\"CREATE_TABLE\");\n-                createTable = createTable.replace(TABLE, tableName);\n-                s.execute(createTable);\n-                s.close();\n-                tableCreated = true;\n-                // Parse the PreparedStatement\n-                String insert = cachedResultsConfiguration.getParameters().get(\"INSERT\");\n-                insert = insert.replace(TABLE, tableName);\n-                ps = con.prepareStatement(insert);\n-            } catch (SQLException sqle) {\n-                throw new QueryException(DatawaveErrorCode.CACHED_RESULTS_TABLE_CREATE_ERROR, sqle);\n-            }\n-            \n-            // Object for keeping track of which fields are placed in which\n-            // table columns\n-            // Key is fieldName, value is column number\n-            Map<String,Integer> fieldMap = new HashMap<>();\n-            \n-            // Loop over the results and put them into the database.\n-            ResultsPage results = null;\n-            \n-            // If we're tracing this query, then continue the trace for the next call.\n-            if (traceInfo != null) {\n-                span = Trace.trace(traceInfo, \"cachedresults:load\");\n-            }\n-            \n-            int rowsWritten = 0;\n-            boolean go = true;\n-            while (go) {\n-                \n-                if (query.isCanceled()) {\n-                    throw new QueryCanceledQueryException(DatawaveErrorCode.QUERY_CANCELED);\n-                }\n-                \n-                Span nextSpan = (span == null) ? null : Trace.start(\"cachedresults:next\");\n-                try {\n-                    if (nextSpan != null)\n-                        nextSpan.data(\"pageNumber\", Long.toString(query.getLastPageNumber() + 1));\n-                    \n-                    results = query.next();\n-                } finally {\n-                    if (nextSpan != null)\n-                        nextSpan.stop();\n-                }\n-                if (results.getResults().isEmpty()) {\n-                    go = false;\n-                    break;\n-                }\n-                \n-                int maxLength = 0;\n-                for (Object o : results.getResults()) {\n-                    \n-                    List<CacheableQueryRow> cacheableQueryRowList = cacheableLogic.writeToCache(o);\n-                    \n-                    for (CacheableQueryRow cacheableQueryObject : cacheableQueryRowList) {\n-                        \n-                        Collection<String> values = ((CacheableQueryRow) cacheableQueryObject).getColumnValues().values();\n-                        int maxValueLength = 0;\n-                        for (String s : values) {\n-                            if (s.length() > maxValueLength) {\n-                                maxValueLength = s.length();\n-                            }\n-                        }\n-                        \n-                        boolean dataWritten = false;\n-                        // If a successful maxLength has been determined, then don't change it.\n-                        if (maxLength == 0)\n-                            maxLength = maxValueLength + 1;\n-                        else if (maxValueLength > maxLength) {\n-                            maxLength = maxValueLength;\n-                        }\n-                        \n-                        int attempt = 0;\n-                        SQLException loadBatchException = null; // exception;\n-                        while (dataWritten == false && attempt < 10) {\n-                            try {\n-                                loadBatch(ps, owner, queryId, logic.getLogicName(), fieldMap, cacheableQueryObject, maxLength);\n-                                dataWritten = true;\n-                                rowsWritten++;\n-                            } catch (SQLException e) {\n-                                loadBatchException = e;\n-                                String msg = e.getMessage();\n-                                if (msg.startsWith(\"Table\") && msg.endsWith(\"doesn't exist\")) {\n-                                    throw new QueryException(DatawaveErrorCode.CACHE_TABLE_MISSING, MessageFormat.format(\"message: {0}\", msg));\n-                                } else {\n-                                    log.info(\"Caught other SQLException:\" + msg + \" writing batch with maxLength:\" + maxLength);\n-                                    maxLength = maxLength / 2;\n-                                }\n-                            }\n-                            attempt++;\n-                        }\n-                        \n-                        if (dataWritten == false) {\n-                            String message = (loadBatchException == null) ? \"unknown\" : loadBatchException.getMessage();\n-                            \n-                            log.error(\"Batch write FAILED - last exception = \" + message + \"record = \" + cacheableQueryObject.getColumnValues().entrySet(),\n-                                            loadBatchException);\n-                        } else if (rowsWritten >= rowsPerBatch) {\n-                            persistBatch(ps);\n-                            ps.clearBatch();\n-                            rowsWritten = 0;\n-                        }\n-                    }\n-                }\n-            } // End of inserts into table\n-            \n-            // commit the last batch\n-            if (rowsWritten > 0) {\n-                persistBatch(ps);\n-                ps.clearBatch();\n-                rowsWritten = 0;\n-            }\n-            \n-            // Dump the fieldMap for debugging\n-            if (log.isTraceEnabled()) {\n-                for (Entry<String,Integer> e : fieldMap.entrySet()) {\n-                    log.trace(\"Field mapping: \" + e.getKey() + \" -> \" + e.getValue());\n-                }\n-            }\n-            \n-            // Create the view of the table\n-            viewCreated = createView(tableName, viewName, con, viewCreated, fieldMap);\n-            \n-            // create the CachedRunningQuery and store it under the originalQueryName, but do not activate it\n-            crq = new CachedRunningQuery(q, logic, viewName, alias, owner, viewName, cachedResultsConfiguration.getDefaultPageSize(), queryId,\n-                            fieldMap.keySet(), null, metricFactory);\n-            crq.setOriginalQueryId(queryId);\n-            crq.setTableName(tableName);\n-            crq.setStatus(CachedRunningQuery.Status.LOADED);\n-            crq.setPrincipal(ctx.getCallerPrincipal());\n-            persist(crq, owner);\n-            \n-            crq.getMetric().setLifecycle(QueryMetric.Lifecycle.INITIALIZED);\n-            \n-            response.setResult(viewName);\n-            if (fieldMap.isEmpty()) {\n-                throw new NoResultsQueryException(\"Field map is empty.\", \"204-4\");\n-            } else {\n-                return response;\n-            }\n-        } catch (NoResultsQueryException e) {\n-            crq.getMetric().setLifecycle(QueryMetric.Lifecycle.DEFINED);\n-            try {\n-                persistByQueryId(viewName, alias, owner, CachedRunningQuery.Status.LOADED, \"\", false);\n-            } catch (IOException e1) {\n-                response.addException(new PreConditionFailedQueryException(DatawaveErrorCode.CACHED_RESULTS_IMPORT_ERROR, e1));\n-            }\n-            response.addException(e.getBottomQueryException());\n-            throw new NoResultsException(e, response.getResult());\n-        } catch (QueryCanceledQueryException | InterruptedException e) {\n-            log.info(\"Query \" + queryId + \" canceled on request\");\n-            if (crq != null) {\n-                crq.getMetric().setLifecycle(QueryMetric.Lifecycle.CANCELLED);\n-            }\n-            try {\n-                persistByQueryId(viewName, alias, owner, CachedRunningQuery.Status.CANCELED, \"query canceled\", false);\n-            } catch (IOException e1) {\n-                response.addException(new PreConditionFailedQueryException(DatawaveErrorCode.CACHED_RESULTS_IMPORT_ERROR, e1));\n-            }\n-            QueryException qe = new QueryException(DatawaveErrorCode.QUERY_CANCELED, e);\n-            response.addException(qe.getBottomQueryException());\n-            throw new QueryCanceledException(qe, response);\n-        } catch (Throwable t) {\n-            if (crq != null && crq.getQueryLogic().getCollectQueryMetrics() == true) {\n-                try {\n-                    crq.getMetric().setError(t);\n-                    crq.getMetric().setLifecycle(QueryMetric.Lifecycle.DEFINED);\n-                    metrics.updateMetric(crq.getMetric());\n-                } catch (Exception e1) {\n-                    log.error(e1.getMessage(), e1);\n-                }\n-            }\n-            String statusMessage = t.getMessage();\n-            if (null == statusMessage) {\n-                statusMessage = t.getClass().getName();\n-            }\n-            \n-            try {\n-                persistByQueryId(viewName, alias, owner, CachedRunningQuery.Status.ERROR, statusMessage, false);\n-            } catch (IOException e2) {\n-                response.addException(new PreConditionFailedQueryException(DatawaveErrorCode.CACHED_RESULTS_IMPORT_ERROR, e2));\n-            }\n-            // don't log stack trace of parse errors and other IllegalArgumentExceptions\n-            if (t instanceof IllegalArgumentException || t instanceof TokenMgrError) {\n-                log.info(t.getMessage());\n-            } else {\n-                log.error(t.getMessage(), t);\n-            }\n-            if (con != null) {\n-                Statement s = null;\n-                try {\n-                    s = con.createStatement();\n-                    if (tableCreated) {\n-                        // Drop the result table and view for this query\n-                        String dropTable = cachedResultsConfiguration.getParameters().get(\"DROP_TABLE\");\n-                        dropTable = dropTable.replace(TABLE, tableName);\n-                        s.execute(dropTable);\n-                    }\n-                    if (viewCreated) {\n-                        String dropView = cachedResultsConfiguration.getParameters().get(\"DROP_VIEW\");\n-                        dropView = dropView.replace(TABLE, viewName);\n-                        s.execute(dropView);\n-                    }\n-                    s.close();\n-                } catch (Exception e1) {\n-                    log.error(e1.getMessage(), e1);\n-                    response.addException(new QueryException(DatawaveErrorCode.FAILURE_CLEANUP_ERROR, e1).getBottomQueryException());\n-                } finally {\n-                    DbUtils.closeQuietly(s);\n-                }\n-            }\n-            if (t instanceof Error && (t instanceof TokenMgrError) == false) {\n-                throw (Error) t;\n-            }\n-            \n-            // default status code\n-            int statusCode = Response.Status.INTERNAL_SERVER_ERROR.getStatusCode();\n-            if (t instanceof QueryException) {\n-                response.addException(((QueryException) t).getBottomQueryException());\n-                statusCode = ((QueryException) t).getBottomQueryException().getStatusCode();\n-            } else {\n-                QueryException qe = new QueryException(statusMessage, t);\n-                response.addException(qe);\n-            }\n-            throw new DatawaveWebApplicationException(t, response, statusCode);\n+          if (nextSpan != null) {\n+            nextSpan.data(\"pageNumber\", Long.toString(query.getLastPageNumber() + 1));\n+          }\n+\n+          results = query.next();\n         } finally {\n-            DbUtils.closeQuietly(con, ps, null);\n-            if (queryLockedException == false) {\n-                CachedResultsBean.loadingQueryMap.remove(queryId);\n-                CachedResultsBean.loadingQueries.remove(queryId);\n+          if (nextSpan != null) {\n+            nextSpan.stop();\n+          }\n+        }\n+        if (results.getResults().isEmpty()) {\n+          go = false;\n+          break;\n+        }\n+\n+        int maxLength = 0;\n+        for (Object o : results.getResults()) {\n+\n+          List<CacheableQueryRow> cacheableQueryRowList = cacheableLogic.writeToCache(o);\n+\n+          for (CacheableQueryRow cacheableQueryObject : cacheableQueryRowList) {\n+\n+            Collection<String> values = ((CacheableQueryRow) cacheableQueryObject).getColumnValues().values();\n+            int maxValueLength = 0;\n+            for (String s : values) {\n+              if (s.length() > maxValueLength) {\n+                maxValueLength = s.length();\n+              }\n             }\n-            \n-            if (span != null) {\n-                span.stop();\n-                \n-                span = Trace.trace(query.getTraceInfo(), \"query:close\");\n-                span.data(\"closedAt\", new Date().toString());\n-                // Spans aren't recorded if they take no time, so sleep for a\n-                // couple milliseconds just to ensure we get something saved.\n-                try {\n-                    Thread.sleep(2);\n-                } catch (InterruptedException e) {\n-                    // ignore\n-                }\n-                span.stop();\n-                // TODO: 1.8.1: no longer done?\n-                // Tracer.getInstance().flush();\n+\n+            boolean dataWritten = false;\n+            // If a successful maxLength has been determined, then don't change it.\n+            if (maxLength == 0) {\n+              maxLength = maxValueLength + 1;\n+            } else if (maxValueLength > maxLength) {\n+              maxLength = maxValueLength;\n             }\n-            \n-            if (null != query) {\n-                query.setActiveCall(false);\n-                try {\n-                    query.closeConnection(connectionFactory);\n-                } catch (Exception e) {\n-                    response.addException(new QueryException(DatawaveErrorCode.QUERY_CLOSE_ERROR, e).getBottomQueryException());\n-                }\n-            } else if (connector != null) {\n-                try {\n-                    connectionFactory.returnConnection(connector);\n-                } catch (Exception e) {\n-                    log.error(new QueryException(DatawaveErrorCode.CONNECTOR_RETURN_ERROR, e));\n+\n+            int attempt = 0;\n+            SQLException loadBatchException = null; // exception;\n+            while (dataWritten == false && attempt < 10) {\n+              try {\n+                loadBatch(ps, owner, queryId, logic.getLogicName(), fieldMap, cacheableQueryObject, maxLength);\n+                dataWritten = true;\n+                rowsWritten++;\n+              } catch (SQLException e) {\n+                loadBatchException = e;\n+                String msg = e.getMessage();\n+                if (msg.startsWith(\"Table\") && msg.endsWith(\"doesn't exist\")) {\n+                  throw new QueryException(DatawaveErrorCode.CACHE_TABLE_MISSING,\n+                      MessageFormat.format(\"message: {0}\", msg));\n+                } else {\n+                  log.info(\"Caught other SQLException:\" + msg + \" writing batch with maxLength:\" + maxLength);\n+                  maxLength = maxLength / 2;\n                 }\n+              }\n+              attempt++;\n             }\n+\n+            if (dataWritten == false) {\n+              String message = (loadBatchException == null) ? \"unknown\" : loadBatchException.getMessage();\n+\n+              log.error(\"Batch write FAILED - last exception = \" + message + \"record = \" +\n+                      cacheableQueryObject.getColumnValues().entrySet(),\n+                  loadBatchException);\n+            } else if (rowsWritten >= rowsPerBatch) {\n+              persistBatch(ps);\n+              ps.clearBatch();\n+              rowsWritten = 0;\n+            }\n+          }\n         }\n-    }\n-    \n-    /**\n-     * Returns status of the requested cached result\n-     *\n-     * @param queryId\n-     * @return List of attribute names that can be used in subsequent queries\n-     *\n-     * @return {@code datawave.webservice.result.GenericResponse<String>}\n-     * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user by specifying a chain of DNs of the identities to proxy\n-     * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n-     * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n-     *\n-     * @HTTP 200 success\n-     * @HTTP 404 not found\n-     * @HTTP 412 not yet loaded\n-     * @HTTP 500 internal server error\n-     *\n-     */\n-    @GET\n-    @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\", \"application/x-protobuf\"})\n-    @javax.ws.rs.Path(\"/{queryId}/status\")\n-    @GZIP\n-    @Interceptors({RequiredInterceptor.class, ResponseInterceptor.class})\n-    @Timed(name = \"dw.cachedr.status\", absolute = true)\n-    public GenericResponse<String> status(@PathParam(\"queryId\") @Required(\"queryId\") String queryId) {\n-        \n-        GenericResponse<String> response = new GenericResponse<>();\n-        \n-        // Find out who/what called this method\n-        Principal p = ctx.getCallerPrincipal();\n-        \n-        String owner = getOwnerFromPrincipal(p);\n-        CachedRunningQuery crq;\n+      } // End of inserts into table\n+\n+      // commit the last batch\n+      if (rowsWritten > 0) {\n+        persistBatch(ps);\n+        ps.clearBatch();\n+        rowsWritten = 0;\n+      }\n+\n+      // Dump the fieldMap for debugging\n+      if (log.isTraceEnabled()) {\n+        for (Entry<String, Integer> e : fieldMap.entrySet()) {\n+          log.trace(\"Field mapping: \" + e.getKey() + \" -> \" + e.getValue());\n+        }\n+      }\n+\n+      // Create the view of the table\n+      viewCreated = createView(tableName, viewName, con, viewCreated, fieldMap);\n+\n+      // create the CachedRunningQuery and store it under the originalQueryName, but do not activate it\n+      crq = new CachedRunningQuery(q, logic, viewName, alias, owner, viewName,\n+          cachedResultsConfiguration.getDefaultPageSize(), queryId,\n+          fieldMap.keySet(), null, metricFactory);\n+      crq.setOriginalQueryId(queryId);\n+      crq.setTableName(tableName);\n+      crq.setStatus(CachedRunningQuery.Status.LOADED);\n+      crq.setPrincipal(ctx.getCallerPrincipal());\n+      persist(crq, owner);\n+\n+      crq.getMetric().setLifecycle(QueryMetric.Lifecycle.INITIALIZED);\n+\n+      response.setResult(viewName);\n+      if (fieldMap.isEmpty()) {\n+        throw new NoResultsQueryException(\"Field map is empty.\", \"204-4\");\n+      } else {\n+        return response;\n+      }\n+    } catch (NoResultsQueryException e) {\n+      crq.getMetric().setLifecycle(QueryMetric.Lifecycle.DEFINED);\n+      try {\n+        persistByQueryId(viewName, alias, owner, CachedRunningQuery.Status.LOADED, \"\", false);\n+      } catch (IOException e1) {\n+        response.addException(new PreConditionFailedQueryException(DatawaveErrorCode.CACHED_RESULTS_IMPORT_ERROR, e1));\n+      }\n+      response.addException(e.getBottomQueryException());\n+      throw new NoResultsException(e, response.getResult());\n+    } catch (QueryCanceledQueryException | InterruptedException e) {\n+      log.info(\"Query \" + queryId + \" canceled on request\");\n+      if (crq != null) {\n+        crq.getMetric().setLifecycle(QueryMetric.Lifecycle.CANCELLED);\n+      }\n+      try {\n+        persistByQueryId(viewName, alias, owner, CachedRunningQuery.Status.CANCELED, \"query canceled\", false);\n+      } catch (IOException e1) {\n+        response.addException(new PreConditionFailedQueryException(DatawaveErrorCode.CACHED_RESULTS_IMPORT_ERROR, e1));\n+      }\n+      QueryException qe = new QueryException(DatawaveErrorCode.QUERY_CANCELED, e);\n+      response.addException(qe.getBottomQueryException());\n+      throw new QueryCanceledException(qe, response);\n+    } catch (Throwable t) {\n+      if (crq != null && crq.getQueryLogic().getCollectQueryMetrics() == true) {\n         try {\n-            crq = retrieve(queryId, owner);\n-        } catch (IOException e1) {\n-            PreConditionFailedQueryException e = new PreConditionFailedQueryException(DatawaveErrorCode.CACHED_RESULTS_IMPORT_ERROR, e1);\n-            response.addException(e);\n-            response.setResult(\"CachedResult not found\");\n-            throw new PreConditionFailedException(e, response);\n+          crq.getMetric().setError(t);\n+          crq.getMetric().setLifecycle(QueryMetric.Lifecycle.DEFINED);\n+          metrics.updateMetric(crq.getMetric());\n+        } catch (Exception e1) {\n+          log.error(e1.getMessage(), e1);\n         }\n-        \n-        if (null == crq) {\n-            NotFoundQueryException e = new NotFoundQueryException(DatawaveErrorCode.CACHED_RESULT_NOT_FOUND);\n-            response.addException(e);\n-            response.setResult(\"CachedResult not found\");\n-            throw new NotFoundException(e, response);\n+      }\n+      String statusMessage = t.getMessage();\n+      if (null == statusMessage) {\n+        statusMessage = t.getClass().getName();\n+      }\n+\n+      try {\n+        persistByQueryId(viewName, alias, owner, CachedRunningQuery.Status.ERROR, statusMessage, false);\n+      } catch (IOException e2) {\n+        response.addException(new PreConditionFailedQueryException(DatawaveErrorCode.CACHED_RESULTS_IMPORT_ERROR, e2));\n+      }\n+      // don't log stack trace of parse errors and other IllegalArgumentExceptions\n+      if (t instanceof IllegalArgumentException || t instanceof TokenMgrError) {\n+        log.info(t.getMessage());\n+      } else {\n+        log.error(t.getMessage(), t);\n+      }\n+      if (con != null) {\n+        Statement s = null;\n+        try {\n+          s = con.createStatement();\n+          if (tableCreated) {\n+            // Drop the result table and view for this query\n+            String dropTable = cachedResultsConfiguration.getParameters().get(\"DROP_TABLE\");\n+            dropTable = dropTable.replace(TABLE, tableName);\n+            s.execute(dropTable);\n+          }\n+          if (viewCreated) {\n+            String dropView = cachedResultsConfiguration.getParameters().get(\"DROP_VIEW\");\n+            dropView = dropView.replace(TABLE, viewName);\n+            s.execute(dropView);\n+          }\n+          s.close();\n+        } catch (Exception e1) {\n+          log.error(e1.getMessage(), e1);\n+          response\n+              .addException(new QueryException(DatawaveErrorCode.FAILURE_CLEANUP_ERROR, e1).getBottomQueryException());\n+        } finally {\n+          DbUtils.closeQuietly(s);\n         }\n-        \n-        if (!crq.getUser().equals(owner)) {\n-            UnauthorizedQueryException e = new UnauthorizedQueryException(DatawaveErrorCode.QUERY_OWNER_MISMATCH, MessageFormat.format(\"{0} != {1}\",\n-                            crq.getUser(), owner));\n-            response.addException(e);\n-            response.setResult(\"Current user does not match user that defined query.\");\n-            throw new UnauthorizedException(e, response);\n+      }\n+      if (t instanceof Error && (t instanceof TokenMgrError) == false) {\n+        throw (Error) t;\n+      }\n+\n+      // default status code\n+      int statusCode = Response.Status.INTERNAL_SERVER_ERROR.getStatusCode();\n+      if (t instanceof QueryException) {\n+        response.addException(((QueryException) t).getBottomQueryException());\n+        statusCode = ((QueryException) t).getBottomQueryException().getStatusCode();\n+      } else {\n+        QueryException qe = new QueryException(statusMessage, t);\n+        response.addException(qe);\n+      }\n+      throw new DatawaveWebApplicationException(t, response, statusCode);\n+    } finally {\n+      DbUtils.closeQuietly(con, ps, null);\n+      if (queryLockedException == false) {\n+        CachedResultsBean.loadingQueryMap.remove(queryId);\n+        CachedResultsBean.loadingQueries.remove(queryId);\n+      }\n+\n+      if (span != null) {\n+        span.stop();\n+\n+        span = Trace.trace(query.getTraceInfo(), \"query:close\");\n+        span.data(\"closedAt\", new Date().toString());\n+        // Spans aren't recorded if they take no time, so sleep for a\n+        // couple milliseconds just to ensure we get something saved.\n+        try {\n+          Thread.sleep(2);\n+        } catch (InterruptedException e) {\n+          // ignore\n         }\n-        \n-        CachedRunningQuery.Status status = crq.getStatus();\n-        \n-        if (status == null) {\n-            response.setResult(CachedRunningQuery.Status.NONE.toString());\n-        } else {\n-            response.setResult(status.toString());\n+        span.stop();\n+        // TODO: 1.8.1: no longer done?\n+        // Tracer.getInstance().flush();\n+      }\n+\n+      if (null != query) {\n+        query.setActiveCall(false);\n+        try {\n+          query.closeConnection(connectionFactory);\n+        } catch (Exception e) {\n+          response.addException(new QueryException(DatawaveErrorCode.QUERY_CLOSE_ERROR, e).getBottomQueryException());\n         }\n-        \n-        if (crq.getStatusMessage() != null && crq.getStatusMessage().isEmpty() == false) {\n-            response.addMessage(crq.getStatusMessage());\n+      } else if (connector != null) {\n+        try {\n+          connectionFactory.returnConnection(connector);\n+        } catch (Exception e) {\n+          log.error(new QueryException(DatawaveErrorCode.CONNECTOR_RETURN_ERROR, e));\n         }\n-        \n-        return response;\n+      }\n     }\n-    \n-    private String getOwnerFromPrincipal(Principal p) {\n-        String owner = p.getName();\n-        if (p instanceof DatawavePrincipal) {\n-            DatawavePrincipal cp = (DatawavePrincipal) p;\n-            owner = cp.getShortName();\n-        }\n-        return owner;\n+  }\n+\n+  /**\n+   * Returns status of the requested cached result\n+   *\n+   * @param queryId\n+   * @return List of attribute names that can be used in subsequent queries\n+   * @return {@code datawave.webservice.result.GenericResponse<String>}\n+   * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user by specifying a chain of DNs of the identities to proxy\n+   * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n+   * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n+   * @HTTP 200 success\n+   * @HTTP 404 not found\n+   * @HTTP 412 not yet loaded\n+   * @HTTP 500 internal server error\n+   */\n+  @GET\n+  @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\",\n+      \"application/x-protobuf\"})\n+  @javax.ws.rs.Path(\"/{queryId}/status\")\n+  @GZIP\n+  @Interceptors({RequiredInterceptor.class, ResponseInterceptor.class})\n+  @Timed(name = \"dw.cachedr.status\", absolute = true)\n+  public GenericResponse<String> status(@PathParam(\"queryId\") @Required(\"queryId\") String queryId) {\n+\n+    GenericResponse<String> response = new GenericResponse<>();\n+\n+    // Find out who/what called this method\n+    Principal p = ctx.getCallerPrincipal();\n+\n+    String owner = getOwnerFromPrincipal(p);\n+    CachedRunningQuery crq;\n+    try {\n+      crq = retrieve(queryId, owner);\n+    } catch (IOException e1) {\n+      PreConditionFailedQueryException e =\n+          new PreConditionFailedQueryException(DatawaveErrorCode.CACHED_RESULTS_IMPORT_ERROR, e1);\n+      response.addException(e);\n+      response.setResult(\"CachedResult not found\");\n+      throw new PreConditionFailedException(e, response);\n     }\n-    \n-    private String getDNFromPrincipal(Principal p) {\n-        String dn = p.getName();\n-        if (p instanceof DatawavePrincipal) {\n-            DatawavePrincipal cp = (DatawavePrincipal) p;\n-            dn = cp.getUserDN().subjectDN();\n-        }\n-        return dn;\n+\n+    if (null == crq) {\n+      NotFoundQueryException e = new NotFoundQueryException(DatawaveErrorCode.CACHED_RESULT_NOT_FOUND);\n+      response.addException(e);\n+      response.setResult(\"CachedResult not found\");\n+      throw new NotFoundException(e, response);\n     }\n-    \n-    protected void persistBatch(PreparedStatement ps) throws SQLException {\n-        int[] batchResults = null;\n-        try {\n-            batchResults = ps.executeBatch();\n-            int failCount = 0;\n-            for (int i = 0; i < batchResults.length; i++) {\n-                if (batchResults[i] == Statement.EXECUTE_FAILED) {\n-                    failCount++;\n-                }\n-            }\n-            \n-            if (failCount > 0) {\n-                StringBuilder b = new StringBuilder();\n-                for (int i = 0; i < batchResults.length; i++) {\n-                    if (batchResults[i] == Statement.EXECUTE_FAILED) {\n-                        b.append(i).append(\" \");\n-                    }\n-                }\n-                log.warn(\"Batch failed to perform \" + failCount + \" updates, indexes: \" + b);\n-            } else if (log.isDebugEnabled()) {\n-                log.debug(\"Successfully persisted batch of size: \" + batchResults.length + \" total \" + failCount + \" failures\");\n-            }\n-        } catch (BatchUpdateException be) {\n-            log.warn(\"Caught BatchUpdateException, one or more batch update have failed: \" + be.getMessage(), be);\n-            throw be;\n-        } catch (SQLException sqle) {\n-            log.error(\"Error committing last batch\", sqle);\n-            throw sqle;\n-        }\n+\n+    if (!crq.getUser().equals(owner)) {\n+      UnauthorizedQueryException e =\n+          new UnauthorizedQueryException(DatawaveErrorCode.QUERY_OWNER_MISMATCH, MessageFormat.format(\"{0} != {1}\",\n+              crq.getUser(), owner));\n+      response.addException(e);\n+      response.setResult(\"Current user does not match user that defined query.\");\n+      throw new UnauthorizedException(e, response);\n     }\n-    \n-    /**\n-     * Loads the results of the defined query, specified by query id, into a store that allows SQL queries to be run against it. This allows caller to sort and\n-     * group by attributes\n-     *\n-     * @param queryId\n-     *            - queryId that identifies the original query that the user wants cached (required)\n-     * @param alias\n-     *            additional name that this query can be retrieved by\n-     * @return name of the view for this query, use it as the table name in the SQL query\n-     *\n-     * @return {@code datawave.webservice.result.GenericResponse<String>}\n-     * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user by specifying a chain of DNs of the identities to proxy\n-     * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n-     * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n-     * @ResponseHeader query-session-id this header and value will be in the Set-Cookie header, subsequent calls for this session will need to supply the\n-     *                 query-session-id header in the request in a Cookie header or as a query parameter\n-     *\n-     * @HTTP 200 success\n-     * @HTTP 500 internal server error\n-     */\n-    @GET\n-    @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\"})\n-    @javax.ws.rs.Path(\"/load\")\n-    @GenerateQuerySessionId(cookieBasePath = \"/DataWave/CachedResults/\")\n-    @Interceptors({RequiredInterceptor.class, ResponseInterceptor.class})\n-    public GenericResponse<String> load(@QueryParam(\"queryId\") @Required(\"queryId\") String queryId, @QueryParam(\"alias\") String alias) {\n-        \n-        String nameBase = UUID.randomUUID().toString().replaceAll(\"-\", \"\");\n-        CreateQuerySessionIDFilter.QUERY_ID.set(queryId);\n-        return load(queryId, alias, nameBase);\n+\n+    CachedRunningQuery.Status status = crq.getStatus();\n+\n+    if (status == null) {\n+      response.setResult(CachedRunningQuery.Status.NONE.toString());\n+    } else {\n+      response.setResult(status.toString());\n     }\n-    \n-    @GET\n-    @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\"})\n-    @javax.ws.rs.Path(\"/async/load\")\n-    @GenerateQuerySessionId(cookieBasePath = \"/DataWave/CachedResults/\")\n-    @Interceptors({RequiredInterceptor.class, ResponseInterceptor.class})\n-    @Asynchronous\n-    public void loadAsync(@QueryParam(\"queryId\") @Required(\"queryId\") String queryId, @QueryParam(\"alias\") String alias, @Suspended AsyncResponse asyncResponse) {\n-        \n-        String nameBase = UUID.randomUUID().toString().replaceAll(\"-\", \"\");\n-        CreateQuerySessionIDFilter.QUERY_ID.set(queryId);\n-        try {\n-            GenericResponse<String> response = load(queryId, alias, nameBase);\n-            asyncResponse.resume(response);\n-        } catch (Throwable t) {\n-            asyncResponse.resume(t);\n-        }\n+\n+    if (crq.getStatusMessage() != null && crq.getStatusMessage().isEmpty() == false) {\n+      response.addMessage(crq.getStatusMessage());\n     }\n-    \n-    /**\n-     *\n-     * @param queryParameters\n-     *\n-     * @return datawave.webservice.result.CachedResultsResponse\n-     * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user by specifying a chain of DNs of the identities to proxy\n-     * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n-     * @ResponseHeader query-session-id this header and value will be in the Set-Cookie header, subsequent calls for this session will need to supply the\n-     *                 query-session-id header in the request in a Cookie header or as a query parameter\n-     * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n-     *\n-     * @HTTP 200 success\n-     * @HTTP 500 internal server error\n-     *\n-     */\n-    @POST\n-    @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\"})\n-    @javax.ws.rs.Path(\"/{queryId}/loadAndCreate\")\n-    @Interceptors(RequiredInterceptor.class)\n-    @GenerateQuerySessionId(cookieBasePath = \"/DataWave/CachedResults/\")\n-    @Timed(name = \"dw.cachedr.loadAndCreate\", absolute = true)\n-    public CachedResultsResponse loadAndCreate(@Required(\"queryId\") @PathParam(\"queryId\") String queryId, MultivaluedMap<String,String> queryParameters) {\n-        CreateQuerySessionIDFilter.QUERY_ID.set(null);\n-        \n-        String newQueryId = queryParameters.getFirst(\"newQueryId\");\n-        Preconditions.checkNotNull(newQueryId, \"newQueryId cannot be null\");\n-        \n-        Preconditions.checkNotNull(queryId, \"queryId cannot be null\");\n-        queryParameters.putSingle(CachedResultsParameters.QUERY_ID, queryId);\n-        \n-        String alias = queryParameters.getFirst(CachedResultsParameters.ALIAS);\n-        \n-        // Find out who/what called this method\n-        Principal p = ctx.getCallerPrincipal();\n-        String owner = getOwnerFromPrincipal(p);\n-        \n-        GenericResponse<String> r = null;\n-        try {\n-            r = load(queryId, alias);\n-        } catch (DatawaveWebApplicationException e) {\n-            if (e instanceof NoResultsException == false) {\n-                \n-                if (e.getCause() instanceof QueryCanceledException) {\n-                    try {\n-                        persistByQueryId(newQueryId, alias, owner, CachedRunningQuery.Status.CANCELED, \"query canceled\", true);\n-                    } catch (IOException e1) {\n-                        log.error(\"Error persisting state to CachedResults store\", e1);\n-                    }\n-                    throw e;\n-                } else {\n-                    String statusMessage = e.getCause().getMessage();\n-                    if (null == statusMessage) {\n-                        statusMessage = e.getClass().getName();\n-                    }\n-                    try {\n-                        persistByQueryId(newQueryId, alias, owner, CachedRunningQuery.Status.ERROR, statusMessage, true);\n-                    } catch (IOException e1) {\n-                        log.error(\"Error persisting state to CachedResults store\", e1);\n-                    }\n-                    throw e;\n-                }\n-            } else if (e.getResponse().getEntity() == null) {\n-                // NoResultsException can't contain the response object, otherwise we'll return invalid HTML. So, instead, pull the ID from the\n-                // NoResultsException and make a new GenericResponse here.\n-                r = new GenericResponse<>();\n-                r.setResult(((NoResultsException) e).getId());\n-            }\n-            if (e.getResponse().getEntity() instanceof GenericResponse<?>) {\n-                @SuppressWarnings(\"unchecked\")\n-                GenericResponse<String> gr = (GenericResponse<String>) e.getResponse().getEntity();\n-                r = gr;\n-            } else if (r == null) {\n-                throw e;\n-            }\n-        } catch (RuntimeException e) {\n-            log.error(e.getMessage(), e);\n-            throw e;\n-        }\n-        String view = r.getResult();\n-        \n-        // pagesize validated in create\n-        CreateQuerySessionIDFilter.QUERY_ID.set(newQueryId);\n-        queryParameters.remove(CachedResultsParameters.QUERY_ID);\n-        queryParameters.remove(CachedResultsParameters.VIEW);\n-        queryParameters.putSingle(CachedResultsParameters.VIEW, view);\n-        CachedResultsResponse response = create(newQueryId, queryParameters);\n-        try {\n-            persistByQueryId(newQueryId, alias, owner, CachedRunningQuery.Status.AVAILABLE, \"\", true);\n-        } catch (IOException e) {\n-            QueryException qe = new QueryException(DatawaveErrorCode.CACHE_PERSISTANCE_ERROR, e);\n-            response.addException(qe);\n-            throw new DatawaveWebApplicationException(e, response);\n-        }\n-        return response;\n+\n+    return response;\n+  }\n+\n+  private String getOwnerFromPrincipal(Principal p) {\n+    String owner = p.getName();\n+    if (p instanceof DatawavePrincipal) {\n+      DatawavePrincipal cp = (DatawavePrincipal) p;\n+      owner = cp.getShortName();\n     }\n-    \n-    // Do not use the @Asynchronous annotation here. This method runs (calling the other version), setting\n-    // status and then executes loadAndCreate asynchronously. It does not itself get run asynchronously.\n-    @Interceptors({RequiredInterceptor.class, ResponseInterceptor.class})\n-    public Future<CachedResultsResponse> loadAndCreateAsync(@Required(\"newQueryId\") String newQueryId, String alias, @Required(\"queryId\") String queryId,\n-                    @Required(\"fields\") String fields, String conditions, String grouping, String order, @Required(\"columnVisibility\") String columnVisibility,\n-                    @DefaultValue(\"-1\") Integer pagesize, String fixedFieldsInEvent) {\n-        \n-        MultivaluedMap<String,String> queryParameters = new MultivaluedMapImpl<>();\n-        queryParameters.putSingle(CachedResultsParameters.QUERY_ID, queryId);\n-        queryParameters.putSingle(\"newQueryId\", newQueryId);\n-        queryParameters.putSingle(CachedResultsParameters.ALIAS, alias);\n-        queryParameters.putSingle(CachedResultsParameters.FIELDS, fields);\n-        queryParameters.putSingle(CachedResultsParameters.CONDITIONS, conditions);\n-        queryParameters.putSingle(CachedResultsParameters.GROUPING, grouping);\n-        queryParameters.putSingle(CachedResultsParameters.ORDER, order);\n-        queryParameters.putSingle(\"columnVisibility\", columnVisibility);\n-        queryParameters.putSingle(QueryParameters.QUERY_PAGESIZE, Integer.toString(pagesize));\n-        queryParameters.putSingle(CachedResultsParameters.FIXED_FIELDS_IN_EVENT, fixedFieldsInEvent);\n-        \n-        return loadAndCreateAsync(queryParameters);\n+    return owner;\n+  }\n+\n+  private String getDNFromPrincipal(Principal p) {\n+    String dn = p.getName();\n+    if (p instanceof DatawavePrincipal) {\n+      DatawavePrincipal cp = (DatawavePrincipal) p;\n+      dn = cp.getUserDN().subjectDN();\n     }\n-    \n-    // Do not use the @Asynchronous annotation here. This method runs, setting status and\n-    // then executes loadAndCreate asynchronously. It does not itself get run asynchronously.\n-    @Interceptors({RequiredInterceptor.class, ResponseInterceptor.class})\n-    public Future<CachedResultsResponse> loadAndCreateAsync(MultivaluedMap<String,String> queryParameters) {\n-        \n-        String newQueryId = queryParameters.getFirst(\"newQueryId\");\n-        Preconditions.checkNotNull(newQueryId, \"newQueryId cannot be null\");\n-        \n-        String queryId = queryParameters.getFirst(CachedResultsParameters.QUERY_ID);\n-        Preconditions.checkNotNull(queryId, \"queryId cannot be null\");\n-        \n-        String alias = queryParameters.getFirst(\"alias\");\n-        if (alias == null) {\n-            alias = newQueryId;\n-        }\n-        \n-        // Find out who/what called this method\n-        Principal p = ctx.getCallerPrincipal();\n-        String owner = getOwnerFromPrincipal(p);\n-        \n-        CachedRunningQuery crq = null;\n-        try {\n-            persistByQueryId(newQueryId, alias, owner, CachedRunningQuery.Status.LOADING, \"\", true);\n-            crq = retrieve(newQueryId, owner);\n-        } catch (IOException e1) {\n-            log.error(\"Error trying to persist/retrieve cached results\", e1);\n-            try {\n-                persistByQueryId(newQueryId, alias, owner, CachedRunningQuery.Status.ERROR, e1.getMessage(), false);\n-            } catch (IOException e2) {\n-                log.error(e2.getMessage(), e2);\n-            }\n-            PreConditionFailedQueryException e = new PreConditionFailedQueryException(DatawaveErrorCode.CACHED_RESULTS_PERSIST_ERROR, e1);\n-            throw new PreConditionFailedException(e, null);\n+    return dn;\n+  }\n+\n+  protected void persistBatch(PreparedStatement ps) throws SQLException {\n+    int[] batchResults = null;\n+    try {\n+      batchResults = ps.executeBatch();\n+      int failCount = 0;\n+      for (int i = 0; i < batchResults.length; i++) {\n+        if (batchResults[i] == Statement.EXECUTE_FAILED) {\n+          failCount++;\n         }\n-        \n-        RunningQuery rq = null;\n-        try {\n-            rq = getQueryById(queryId);\n-            if (rq != null) {\n-                String nameBase = UUID.randomUUID().toString().replaceAll(\"-\", \"\");\n-                Query q = rq.getSettings();\n-                crq.setOriginalQueryId(q.getId().toString());\n-                crq.setView(nameBase);\n-                crq.setAlias(alias);\n-                crq.setQuery(rq.getSettings());\n-                persist(crq, owner);\n-            }\n-            \n-        } catch (Exception e) {\n-            String statusMessage = e.getMessage();\n-            if (null == statusMessage) {\n-                statusMessage = e.getClass().getName();\n-            }\n-            \n-            try {\n-                persistByQueryId(newQueryId, alias, owner, CachedRunningQuery.Status.ERROR, statusMessage, true);\n-            } catch (IOException e1) {\n-                log.error(\"Error persisting status to CachedResult store\", e1);\n-            }\n-            log.error(e.getMessage(), e);\n+      }\n+\n+      if (failCount > 0) {\n+        StringBuilder b = new StringBuilder();\n+        for (int i = 0; i < batchResults.length; i++) {\n+          if (batchResults[i] == Statement.EXECUTE_FAILED) {\n+            b.append(i).append(\" \");\n+          }\n         }\n-        \n-        // pagesize validated in loadAndCreate\n-        return new AsyncResult<>(loadAndCreate(queryId, queryParameters));\n+        log.warn(\"Batch failed to perform \" + failCount + \" updates, indexes: \" + b);\n+      } else if (log.isDebugEnabled()) {\n+        log.debug(\"Successfully persisted batch of size: \" + batchResults.length + \" total \" + failCount + \" failures\");\n+      }\n+    } catch (BatchUpdateException be) {\n+      log.warn(\"Caught BatchUpdateException, one or more batch update have failed: \" + be.getMessage(), be);\n+      throw be;\n+    } catch (SQLException sqle) {\n+      log.error(\"Error committing last batch\", sqle);\n+      throw sqle;\n     }\n-    \n-    /**\n-     * Returns a list of attribute names that can be used in subsequent queries\n-     *\n-     * @param id\n-     *            view, queryId, or alias\n-     * @return number of results, columns contained in the results\n-     *\n-     * @return {@code datawave.webservice.result.CachedResultsDescribeResponse<Description>}\n-     * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user by specifying a chain of DNs of the identities to proxy\n-     * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n-     * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n-     *\n-     * @HTTP 200 success\n-     * @HTTP 500 internal server error\n-     *\n-     */\n-    @GET\n-    @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\", \"application/x-protobuf\"})\n-    @javax.ws.rs.Path(\"/{id}/describe\")\n-    @GZIP\n-    @Interceptors({RequiredInterceptor.class, ResponseInterceptor.class})\n-    public CachedResultsDescribeResponse describe(@PathParam(\"id\") @Required(\"id\") String id) {\n-        // Find out who/what called this method\n-        Principal p = ctx.getCallerPrincipal();\n-        String owner = getOwnerFromPrincipal(p);\n-        \n-        CachedResultsDescribeResponse response = null;\n-        \n-        try {\n-            response = new CachedResultsDescribeResponse();\n-            CachedRunningQuery crq;\n-            try {\n-                crq = retrieve(id, owner);\n-            } catch (IOException e1) {\n-                throw new PreConditionFailedQueryException(DatawaveErrorCode.CACHED_RESULTS_IMPORT_ERROR, e1);\n-            }\n-            \n-            if (null == crq) {\n-                throw new NotFoundQueryException(DatawaveErrorCode.QUERY_OR_VIEW_NOT_FOUND);\n-            }\n-            \n-            if (!crq.getUser().equals(owner)) {\n-                throw new UnauthorizedQueryException(DatawaveErrorCode.QUERY_OWNER_MISMATCH, MessageFormat.format(\"{0} != {1}\", crq.getUser(), owner));\n-            }\n-            \n-            String view = crq.getView();\n-            response.setView(view);\n-            \n-            List<String> columns = new ArrayList<>();\n-            Integer numRows = null;\n-            try (Connection con = ds.getConnection(); Statement s = con.createStatement()) {\n-                try (ResultSet rs = s.executeQuery(\"select count(*) from \" + view)) {\n-                    if (rs.next()) {\n-                        numRows = rs.getInt(1);\n-                    }\n-                }\n-                \n-                try (ResultSet rs = s.executeQuery(\"show columns from \" + view)) {\n-                    Set<String> fixedColumns = CacheableQueryRow.getFixedColumnSet();\n-                    while (rs.next()) {\n-                        String column = rs.getString(1);\n-                        if (!fixedColumns.contains(column)) {\n-                            columns.add(column);\n-                        }\n-                    }\n-                }\n-                \n-            } catch (SQLSyntaxErrorException e) {\n-                throw new NotFoundQueryException(DatawaveErrorCode.VIEW_NOT_FOUND);\n-            } catch (SQLException e) {\n-                throw new QueryException(DatawaveErrorCode.CACHED_QUERY_SQL_ERROR);\n-            }\n-            \n-            response.setColumns(columns);\n-            response.setNumRows(numRows);\n-        } catch (QueryException e) {\n-            QueryException qe = new QueryException(DatawaveErrorCode.CACHED_QUERY_DESCRIPTION_ERROR, e);\n-            response.addException(qe.getBottomQueryException());\n-            throw new DatawaveWebApplicationException(qe, response, e.getBottomQueryException().getStatusCode());\n-        }\n-        return response;\n+  }\n+\n+  /**\n+   * Loads the results of the defined query, specified by query id, into a store that allows SQL queries to be run against it. This allows caller to sort and\n+   * group by attributes\n+   *\n+   * @param queryId - queryId that identifies the original query that the user wants cached (required)\n+   * @param alias   additional name that this query can be retrieved by\n+   * @return name of the view for this query, use it as the table name in the SQL query\n+   * @return {@code datawave.webservice.result.GenericResponse<String>}\n+   * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user by specifying a chain of DNs of the identities to proxy\n+   * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n+   * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n+   * @ResponseHeader query-session-id this header and value will be in the Set-Cookie header, subsequent calls for this session will need to supply the\n+   * query-session-id header in the request in a Cookie header or as a query parameter\n+   * @HTTP 200 success\n+   * @HTTP 500 internal server error\n+   */\n+  @GET\n+  @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\"})\n+  @javax.ws.rs.Path(\"/load\")\n+  @GenerateQuerySessionId(cookieBasePath = \"/DataWave/CachedResults/\")\n+  @Interceptors({RequiredInterceptor.class, ResponseInterceptor.class})\n+  public GenericResponse<String> load(@QueryParam(\"queryId\") @Required(\"queryId\") String queryId,\n+                                      @QueryParam(\"alias\") String alias) {\n+\n+    String nameBase = UUID.randomUUID().toString().replaceAll(\"-\", \"\");\n+    CreateQuerySessionIDFilter.QUERY_ID.set(queryId);\n+    return load(queryId, alias, nameBase);\n+  }\n+\n+  @GET\n+  @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\"})\n+  @javax.ws.rs.Path(\"/async/load\")\n+  @GenerateQuerySessionId(cookieBasePath = \"/DataWave/CachedResults/\")\n+  @Interceptors({RequiredInterceptor.class, ResponseInterceptor.class})\n+  @Asynchronous\n+  public void loadAsync(@QueryParam(\"queryId\") @Required(\"queryId\") String queryId, @QueryParam(\"alias\") String alias,\n+                        @Suspended AsyncResponse asyncResponse) {\n+\n+    String nameBase = UUID.randomUUID().toString().replaceAll(\"-\", \"\");\n+    CreateQuerySessionIDFilter.QUERY_ID.set(queryId);\n+    try {\n+      GenericResponse<String> response = load(queryId, alias, nameBase);\n+      asyncResponse.resume(response);\n+    } catch (Throwable t) {\n+      asyncResponse.resume(t);\n     }\n-    \n-    /**\n-     *\n-     * @param queryParameters\n-     *\n-     * @return datawave.webservice.result.CachedResultsResponse\n-     * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user by specifying a chain of DNs of the identities to proxy\n-     * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n-     * @ResponseHeader query-session-id this header and value will be in the Set-Cookie header, subsequent calls for this session will need to supply the\n-     *                 query-session-id header in the request in a Cookie header or as a query parameter\n-     * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n-     *\n-     *                 'view' is a required parameter, however the caller may not know the view name. In this case, the caller may substitute the alias name\n-     *                 they created for the view. the retrieve call may retrieve using the alias, however other calls that operate on the actual view may not\n-     *                 substitute the alias (it is not the name of the table/view!) see comments inline below\n-     *\n-     * @HTTP 200 success\n-     * @HTTP 500 internal server error\n-     */\n-    @POST\n-    @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\"})\n-    @javax.ws.rs.Path(\"/{queryId}/create\")\n-    @Interceptors(RequiredInterceptor.class)\n-    @GenerateQuerySessionId(cookieBasePath = \"/DataWave/CachedResults/\")\n-    @Timed(name = \"dw.cachedr.create\", absolute = true)\n-    public CachedResultsResponse create(@Required(\"queryId\") @PathParam(\"queryId\") String queryId, MultivaluedMap<String,String> queryParameters) {\n-        CreateQuerySessionIDFilter.QUERY_ID.set(null);\n-        \n-        queryParameters.putSingle(CachedResultsParameters.QUERY_ID, queryId);\n-        cp.clear();\n-        cp.validate(queryParameters);\n-        \n-        CachedResultsResponse response = new CachedResultsResponse();\n-        \n-        // Find out who/what called this method\n-        Principal p = ctx.getCallerPrincipal();\n-        String owner = getOwnerFromPrincipal(p);\n-        \n-        CachedRunningQuery crq = null;\n-        Connection con = null;\n-        try {\n-            con = ds.getConnection();\n-            CachedRunningQuery loadCrq = retrieve(cp.getView(), owner); // the caller may have used the alias name for the view.\n-            \n-            if (loadCrq == null) {\n-                throw new PreConditionFailedQueryException(DatawaveErrorCode.QUERY_NOT_CACHED);\n-            }\n-            if (!loadCrq.getUser().equals(owner)) {\n-                throw new UnauthorizedQueryException(DatawaveErrorCode.QUERY_OWNER_MISMATCH, MessageFormat.format(\"{0} != {1}\", loadCrq.getUser(), owner));\n-            }\n-            \n-            if (cp.getPagesize() <= 0) {\n-                cp.setPagesize(cachedResultsConfiguration.getDefaultPageSize());\n-            }\n-            \n-            int maxPageSize = cachedResultsConfiguration.getMaxPageSize();\n-            if (maxPageSize > 0 && cp.getPagesize() > maxPageSize) {\n-                throw new PreConditionFailedQueryException(DatawaveErrorCode.REQUESTED_PAGE_SIZE_TOO_LARGE, MessageFormat.format(\"{0} > {1}.\",\n-                                cp.getPagesize(), maxPageSize));\n-            }\n-            \n-            QueryLogic<?> queryLogic = loadCrq.getQueryLogic();\n-            String originalQueryId = loadCrq.getOriginalQueryId();\n-            Query query = loadCrq.getQuery();\n-            String table = loadCrq.getTableName();\n-            \n-            Set<String> fixedFields = null;\n-            if (!StringUtils.isEmpty(cp.getFixedFields())) {\n-                fixedFields = new HashSet<>();\n-                for (String field : cp.getFixedFields().split(\",\")) {\n-                    fixedFields.add(field.trim());\n-                }\n-            }\n-            // this needs the real view name, so use the value from loadCrq instead of cp.getView() (because cp.getView may return the alias instead)\n-            crq = new CachedRunningQuery(con, query, queryLogic, cp.getQueryId(), cp.getAlias(), owner, loadCrq.getView(), cp.getFields(), cp.getConditions(),\n-                            cp.getGrouping(), cp.getOrder(), cp.getPagesize(), loadCrq.getVariableFields(), fixedFields, metricFactory);\n-            crq.setStatus(CachedRunningQuery.Status.CREATING);\n-            crq.setOriginalQueryId(originalQueryId);\n-            crq.setTableName(table);\n-            persist(crq, owner);\n-            // see above comment about using loadCrq.getView() instead of cp.getView()\n-            CachedRunningQuery.removeFromDatabase(loadCrq.getView());\n-            \n-            crq.getMetric().setLifecycle(QueryMetric.Lifecycle.DEFINED);\n-            // see above comment about using loadCrq.getView() instead of cp.getView()\n-            String sqlQuery = crq.generateSql(loadCrq.getView(), cp.getFields(), cp.getConditions(), cp.getGrouping(), cp.getOrder(), owner, con);\n-            \n-            // Store the CachedRunningQuery in the cache under the user-supplied alias\n-            if (cp.getAlias() != null) {\n-                response.setAlias(cp.getAlias());\n-            }\n-            \n-            AuditType auditType = queryLogic.getAuditType(query);\n-            if (!auditType.equals(AuditType.NONE)) {\n-                // if auditType > AuditType.NONE, audit passively\n-                auditType = AuditType.PASSIVE;\n-                StringBuilder auditMessage = new StringBuilder();\n-                auditMessage.append(\"User running secondary query on cached results of original query,\");\n-                auditMessage.append(\" original query: \").append(query.getQuery());\n-                auditMessage.append(\", secondary query: \").append(sqlQuery);\n-                MultivaluedMap<String,String> params = query.toMap();\n-                marking.validate(params);\n-                PrivateAuditConstants.stripPrivateParameters(queryParameters);\n-                params.putSingle(PrivateAuditConstants.COLUMN_VISIBILITY, marking.toColumnVisibilityString());\n-                params.putSingle(PrivateAuditConstants.AUDIT_TYPE, auditType.name());\n-                params.putSingle(PrivateAuditConstants.USER_DN, query.getUserDN());\n-                params.putSingle(PrivateAuditConstants.LOGIC_CLASS, crq.getQueryLogic().getLogicName());\n-                params.remove(QueryParameters.QUERY_STRING);\n-                params.putSingle(QueryParameters.QUERY_STRING, auditMessage.toString());\n-                params.putAll(queryParameters);\n-                auditor.audit(params);\n-            }\n-            \n-            response.setOriginalQueryId(originalQueryId);\n-            response.setQueryId(cp.getQueryId());\n-            \n-            response.setViewName(loadCrq.getView());\n-            response.setTotalRows(crq.getTotalRows());\n-            \n-            crq.setStatus(CachedRunningQuery.Status.AVAILABLE);\n-            persist(crq, owner);\n-            CreateQuerySessionIDFilter.QUERY_ID.set(cp.getQueryId());\n-            return response;\n-            \n-        } catch (Exception e) {\n-            \n-            if (crq != null) {\n-                crq.getMetric().setError(e);\n-            }\n-            \n-            String statusMessage = e.getMessage();\n-            if (null == statusMessage) {\n-                statusMessage = e.getClass().getName();\n-            }\n-            \n-            try {\n-                persistByQueryId(cp.getQueryId(), cp.getAlias(), owner, CachedRunningQuery.Status.ERROR, statusMessage, true);\n-            } catch (IOException e1) {\n-                response.addException(new QueryException(DatawaveErrorCode.CACHED_QUERY_PERSISTANCE_ERROR, e1));\n-            }\n-            QueryException qe = new QueryException(DatawaveErrorCode.CACHED_QUERY_SET_ERROR, e);\n-            log.error(qe);\n-            response.addException(qe.getBottomQueryException());\n-            throw new DatawaveWebApplicationException(qe, response);\n-        } finally {\n-            crq.closeConnection(log);\n-            // Push metrics\n-            if (crq != null && crq.getQueryLogic().getCollectQueryMetrics() == true) {\n-                try {\n-                    metrics.updateMetric(crq.getMetric());\n-                } catch (Exception e1) {\n-                    log.error(e1.getMessage(), e1);\n-                }\n-            }\n-            \n+  }\n+\n+  /**\n+   * @param queryParameters\n+   * @return datawave.webservice.result.CachedResultsResponse\n+   * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user by specifying a chain of DNs of the identities to proxy\n+   * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n+   * @ResponseHeader query-session-id this header and value will be in the Set-Cookie header, subsequent calls for this session will need to supply the\n+   * query-session-id header in the request in a Cookie header or as a query parameter\n+   * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n+   * @HTTP 200 success\n+   * @HTTP 500 internal server error\n+   */\n+  @POST\n+  @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\"})\n+  @javax.ws.rs.Path(\"/{queryId}/loadAndCreate\")\n+  @Interceptors(RequiredInterceptor.class)\n+  @GenerateQuerySessionId(cookieBasePath = \"/DataWave/CachedResults/\")\n+  @Timed(name = \"dw.cachedr.loadAndCreate\", absolute = true)\n+  public CachedResultsResponse loadAndCreate(@Required(\"queryId\") @PathParam(\"queryId\") String queryId,\n+                                             MultivaluedMap<String, String> queryParameters) {\n+    CreateQuerySessionIDFilter.QUERY_ID.set(null);\n+\n+    String newQueryId = queryParameters.getFirst(\"newQueryId\");\n+    Preconditions.checkNotNull(newQueryId, \"newQueryId cannot be null\");\n+\n+    Preconditions.checkNotNull(queryId, \"queryId cannot be null\");\n+    queryParameters.putSingle(CachedResultsParameters.QUERY_ID, queryId);\n+\n+    String alias = queryParameters.getFirst(CachedResultsParameters.ALIAS);\n+\n+    // Find out who/what called this method\n+    Principal p = ctx.getCallerPrincipal();\n+    String owner = getOwnerFromPrincipal(p);\n+\n+    GenericResponse<String> r = null;\n+    try {\n+      r = load(queryId, alias);\n+    } catch (DatawaveWebApplicationException e) {\n+      if (e instanceof NoResultsException == false) {\n+\n+        if (e.getCause() instanceof QueryCanceledException) {\n+          try {\n+            persistByQueryId(newQueryId, alias, owner, CachedRunningQuery.Status.CANCELED, \"query canceled\", true);\n+          } catch (IOException e1) {\n+            log.error(\"Error persisting state to CachedResults store\", e1);\n+          }\n+          throw e;\n+        } else {\n+          String statusMessage = e.getCause().getMessage();\n+          if (null == statusMessage) {\n+            statusMessage = e.getClass().getName();\n+          }\n+          try {\n+            persistByQueryId(newQueryId, alias, owner, CachedRunningQuery.Status.ERROR, statusMessage, true);\n+          } catch (IOException e1) {\n+            log.error(\"Error persisting state to CachedResults store\", e1);\n+          }\n+          throw e;\n         }\n-        \n+      } else if (e.getResponse().getEntity() == null) {\n+        // NoResultsException can't contain the response object, otherwise we'll return invalid HTML. So, instead, pull the ID from the\n+        // NoResultsException and make a new GenericResponse here.\n+        r = new GenericResponse<>();\n+        r.setResult(((NoResultsException) e).getId());\n+      }\n+      if (e.getResponse().getEntity() instanceof GenericResponse<?>) {\n+        @SuppressWarnings(\"unchecked\")\n+        GenericResponse<String> gr = (GenericResponse<String>) e.getResponse().getEntity();\n+        r = gr;\n+      } else if (r == null) {\n+        throw e;\n+      }\n+    } catch (RuntimeException e) {\n+      log.error(e.getMessage(), e);\n+      throw e;\n     }\n-    \n-    /**\n-     * Update fields, conditions, grouping, or order for a CachedResults query. As a general rule, keep parens at least one space away from field names. Field\n-     * names also work with or without tick marks.\n-     *\n-     * @param queryId\n-     *            user defined id for this query\n-     * @param fields\n-     *            comma separated list of fields in the result set\n-     * @param conditions\n-     *            analogous to a SQL where clause\n-     * @param grouping\n-     *            comma separated list of fields to group by\n-     * @param order\n-     *            comma separated list of fields for ordering\n-     * @param pagesize\n-     *            size of returned pages\n-     *\n-     * @return datawave.webservice.result.CachedResultsResponse\n-     * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user by specifying a chain of DNs of the identities to proxy\n-     * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n-     * @RequestHeader query-session-id session id value used for load balancing purposes. query-session-id can be placed in the request in a Cookie header or as\n-     *                a query parameter\n-     * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n-     * @ResponseHeader query-session-id this header and value will be in the Set-Cookie header, subsequent calls for this session will need to supply the\n-     *                 query-session-id header in the request in a Cookie header or as a query parameter\n-     *\n-     * @HTTP 200 success\n-     * @HTTP 401 caller is not authorized to run the query\n-     * @HTTP 412 if the query is not active\n-     * @HTTP 500 internal server error\n-     */\n-    @POST\n-    @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\"})\n-    @javax.ws.rs.Path(\"/{queryId}/update\")\n-    @Interceptors({RequiredInterceptor.class, ResponseInterceptor.class})\n-    @GenerateQuerySessionId(cookieBasePath = \"/DataWave/CachedResults/\")\n-    @Timed(name = \"dw.cachedr.update\", absolute = true)\n-    public CachedResultsResponse update(@PathParam(\"queryId\") @Required(\"queryId\") String queryId, @FormParam(\"fields\") String fields,\n-                    @FormParam(\"conditions\") String conditions, @FormParam(\"grouping\") String grouping, @FormParam(\"order\") String order,\n-                    @FormParam(\"pagesize\") Integer pagesize) {\n-        CreateQuerySessionIDFilter.QUERY_ID.set(null);\n-        \n-        boolean updated = false;\n-        \n-        CachedResultsResponse response = new CachedResultsResponse();\n-        \n-        // Find out who/what called this method\n-        Principal p = ctx.getCallerPrincipal();\n-        String owner = getOwnerFromPrincipal(p);\n-        \n-        try {\n-            \n-            CachedRunningQuery crq = null;\n-            try {\n-                \n-                crq = retrieve(queryId, owner);\n-                if (null == crq) {\n-                    throw new PreConditionFailedQueryException(DatawaveErrorCode.QUERY_NOT_CACHED);\n-                }\n-                if (!crq.getUser().equals(owner)) {\n-                    throw new UnauthorizedQueryException(DatawaveErrorCode.QUERY_OWNER_MISMATCH, MessageFormat.format(\"{0} != {1}\", crq.getUser(), owner));\n-                }\n-                \n-                if (pagesize == null || pagesize <= 0) {\n-                    pagesize = cachedResultsConfiguration.getDefaultPageSize();\n-                }\n-                \n-                int maxPageSize = cachedResultsConfiguration.getMaxPageSize();\n-                if (maxPageSize > 0 && pagesize > maxPageSize) {\n-                    throw new PreConditionFailedQueryException(DatawaveErrorCode.REQUESTED_PAGE_SIZE_TOO_LARGE, MessageFormat.format(\"{0} > {1}.\", pagesize,\n-                                    cachedResultsConfiguration.getMaxPageSize()));\n-                }\n-                \n-                synchronized (crq) {\n-                    \n-                    if (crq.isActivated() == false) {\n-                        Connection connection = ds.getConnection();\n-                        String logicName = crq.getQueryLogicName();\n-                        if (logicName != null) {\n-                            QueryLogic<?> queryLogic = queryFactory.getQueryLogic(logicName, p);\n-                            crq.activate(connection, queryLogic);\n-                        } else {\n-                            DbUtils.closeQuietly(connection);\n-                        }\n-                    }\n-                    \n-                    try {\n-                        if (fields == null && conditions == null && grouping == null && order == null) {\n-                            // don't do update\n-                        } else {\n-                            updated = crq.update(fields, conditions, grouping, order, pagesize);\n-                            persist(crq, owner);\n-                        }\n-                        \n-                        response.setOriginalQueryId(crq.getOriginalQueryId());\n-                        response.setQueryId(crq.getQueryId());\n-                        response.setViewName(crq.getView());\n-                        response.setAlias(crq.getAlias());\n-                        response.setTotalRows(crq.getTotalRows());\n-                    } finally {\n-                        // only close connection if the crq changed, because we expect additional actions\n-                        if (updated) {\n-                            crq.closeConnection(log);\n-                        }\n-                    }\n-                }\n-                \n-            } finally {\n-                if (crq != null && crq.getQueryLogic() != null && crq.getQueryLogic().getCollectQueryMetrics() == true) {\n-                    try {\n-                        metrics.updateMetric(crq.getMetric());\n-                    } catch (Exception e1) {\n-                        log.error(\"Error updating metrics\", e1);\n-                    }\n-                }\n-            }\n-            CreateQuerySessionIDFilter.QUERY_ID.set(queryId);\n-            return response;\n-        } catch (Exception e) {\n-            QueryException qe = new QueryException(DatawaveErrorCode.CACHED_QUERY_UPDATE_ERROR, e);\n-            log.error(qe);\n-            response.addException(qe.getBottomQueryException());\n-            int statusCode = qe.getBottomQueryException().getStatusCode();\n-            throw new DatawaveWebApplicationException(qe, response, statusCode);\n-        }\n+    String view = r.getResult();\n+\n+    // pagesize validated in create\n+    CreateQuerySessionIDFilter.QUERY_ID.set(newQueryId);\n+    queryParameters.remove(CachedResultsParameters.QUERY_ID);\n+    queryParameters.remove(CachedResultsParameters.VIEW);\n+    queryParameters.putSingle(CachedResultsParameters.VIEW, view);\n+    CachedResultsResponse response = create(newQueryId, queryParameters);\n+    try {\n+      persistByQueryId(newQueryId, alias, owner, CachedRunningQuery.Status.AVAILABLE, \"\", true);\n+    } catch (IOException e) {\n+      QueryException qe = new QueryException(DatawaveErrorCode.CACHE_PERSISTANCE_ERROR, e);\n+      response.addException(qe);\n+      throw new DatawaveWebApplicationException(e, response);\n     }\n-    \n-    /**\n-     *\n-     * Returns the previous page of results to the caller. The response object type is dynamic, see the listQueryLogic operation to determine what the response\n-     * type object will be.\n-     *\n-     * @param queryId\n-     *            user defined id for this query\n-     * @return previous page of results\n-     *\n-     * @return datawave.webservice.result.BaseQueryResponse\n-     * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user by specifying a chain of DNs of the identities to proxy\n-     * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n-     * @RequestHeader query-session-id session id value used for load balancing purposes. query-session-id can be placed in the request in a Cookie header or as\n-     *                a query parameter\n-     * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n-     * @ResponseHeader X-query-page-number page number returned by this call\n-     * @ResponseHeader X-query-last-page if true then there are no more pages for this query, caller should call close()\n-     * @ResponseHeader X-Partial-Results true if the page contains less than the requested number of results\n-     *\n-     * @HTTP 200 success\n-     * @HTTP 401 caller is not authorized to run the query\n-     * @HTTP 412 if the query is not active\n-     * @HTTP 500 internal server error\n-     *\n-     */\n-    @GET\n-    @javax.ws.rs.Path(\"/{queryId}/previous\")\n-    @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\", \"application/x-protobuf\"})\n-    @GZIP\n-    @Interceptors({RequiredInterceptor.class, ResponseInterceptor.class})\n-    @Timed(name = \"dw.cachedr.previous\", absolute = true)\n-    public BaseQueryResponse previous(@PathParam(\"queryId\") @Required(\"queryId\") String queryId) {\n-        \n-        BaseQueryResponse response = responseObjectFactory.getEventQueryResponse();\n-        \n-        // Find out who/what called this method\n-        Principal p = ctx.getCallerPrincipal();\n-        String owner = getOwnerFromPrincipal(p);\n-        \n-        try {\n-            CachedRunningQuery crq = null;\n-            try {\n-                // Get the CachedRunningQuery object from the cache\n-                try {\n-                    crq = retrieve(queryId, owner);\n-                } catch (IOException e) {\n-                    throw new PreConditionFailedQueryException(DatawaveErrorCode.CACHED_RESULTS_IMPORT_ERROR, e);\n-                }\n-                if (null == crq)\n-                    throw new PreConditionFailedQueryException(DatawaveErrorCode.QUERY_NOT_CACHED);\n-                if (!crq.getUser().equals(owner)) {\n-                    throw new UnauthorizedQueryException(DatawaveErrorCode.QUERY_OWNER_MISMATCH, MessageFormat.format(\"{0} != {1}\", crq.getUser(), owner));\n-                }\n-                \n-                synchronized (crq) {\n-                    if (crq.isActivated() == false) {\n-                        if (crq.getShouldAutoActivate()) {\n-                            Connection connection = ds.getConnection();\n-                            String logicName = crq.getQueryLogicName();\n-                            QueryLogic<?> queryLogic = queryFactory.getQueryLogic(logicName, p);\n-                            crq.activate(connection, queryLogic);\n-                        } else {\n-                            throw new PreConditionFailedQueryException(DatawaveErrorCode.QUERY_TIMEOUT_FOR_RESOURCES);\n-                        }\n-                    }\n-                    \n-                    try {\n-                        ResultsPage resultList = crq.previous(cachedResultsConfiguration.getPageByteTrigger());\n-                        long pageNum = crq.getLastPageNumber();\n-                        response = crq.getTransformer().createResponse(resultList);\n-                        Status status = null;\n-                        if (!resultList.getResults().isEmpty()) {\n-                            response.setHasResults(true);\n-                            status = Status.OK;\n-                        } else {\n-                            response.setHasResults(false);\n-                            status = Status.NO_CONTENT;\n-                        }\n-                        response.setPageNumber(pageNum);\n-                        response.setLogicName(crq.getQueryLogic().getLogicName());\n-                        response.setQueryId(crq.getQueryId());\n-                        if (response instanceof TotalResultsAware) {\n-                            ((TotalResultsAware) response).setTotalResults(crq.getTotalRows());\n-                        }\n-                        if (status == Status.NO_CONTENT) {\n-                            throw new NoResultsException(null);\n-                        }\n-                        crq.getMetric().setLifecycle(QueryMetric.Lifecycle.RESULTS);\n-                        return response;\n-                    } catch (SQLException e) {\n-                        throw new QueryException(DatawaveErrorCode.CACHED_QUERY_SQL_ERROR, e);\n-                    }\n-                }\n-            } finally {\n-                // Push metrics\n-                if (null != crq && crq.getQueryLogic().getCollectQueryMetrics() == true) {\n-                    \n-                    try {\n-                        metrics.updateMetric(crq.getMetric());\n-                    } catch (Exception e1) {\n-                        log.error(\"Error updating metrics\", e1);\n-                    }\n-                }\n-            }\n-        } catch (Exception e) {\n-            QueryException qe = null;\n-            if (e instanceof NoResultsException) {\n-                qe = new QueryException(DatawaveErrorCode.NO_CONTENT_STATUS, e);\n-            } else {\n-                qe = new QueryException(\"Error calling previous.\", e, \"500-42\");\n-                log.error(qe);\n-            }\n-            response.addException(qe.getBottomQueryException());\n-            int statusCode = qe.getBottomQueryException().getStatusCode();\n-            throw new DatawaveWebApplicationException(qe, response, statusCode);\n+    return response;\n+  }\n+\n+  // Do not use the @Asynchronous annotation here. This method runs (calling the other version), setting\n+  // status and then executes loadAndCreate asynchronously. It does not itself get run asynchronously.\n+  @Interceptors({RequiredInterceptor.class, ResponseInterceptor.class})\n+  public Future<CachedResultsResponse> loadAndCreateAsync(@Required(\"newQueryId\") String newQueryId, String alias,\n+                                                          @Required(\"queryId\") String queryId,\n+                                                          @Required(\"fields\") String fields, String conditions,\n+                                                          String grouping, String order,\n+                                                          @Required(\"columnVisibility\") String columnVisibility,\n+                                                          @DefaultValue(\"-1\") Integer pagesize,\n+                                                          String fixedFieldsInEvent) {\n+\n+    MultivaluedMap<String, String> queryParameters = new MultivaluedMapImpl<>();\n+    queryParameters.putSingle(CachedResultsParameters.QUERY_ID, queryId);\n+    queryParameters.putSingle(\"newQueryId\", newQueryId);\n+    queryParameters.putSingle(CachedResultsParameters.ALIAS, alias);\n+    queryParameters.putSingle(CachedResultsParameters.FIELDS, fields);\n+    queryParameters.putSingle(CachedResultsParameters.CONDITIONS, conditions);\n+    queryParameters.putSingle(CachedResultsParameters.GROUPING, grouping);\n+    queryParameters.putSingle(CachedResultsParameters.ORDER, order);\n+    queryParameters.putSingle(\"columnVisibility\", columnVisibility);\n+    queryParameters.putSingle(QueryParameters.QUERY_PAGESIZE, Integer.toString(pagesize));\n+    queryParameters.putSingle(CachedResultsParameters.FIXED_FIELDS_IN_EVENT, fixedFieldsInEvent);\n+\n+    return loadAndCreateAsync(queryParameters);\n+  }\n+\n+  // Do not use the @Asynchronous annotation here. This method runs, setting status and\n+  // then executes loadAndCreate asynchronously. It does not itself get run asynchronously.\n+  @Interceptors({RequiredInterceptor.class, ResponseInterceptor.class})\n+  public Future<CachedResultsResponse> loadAndCreateAsync(MultivaluedMap<String, String> queryParameters) {\n+\n+    String newQueryId = queryParameters.getFirst(\"newQueryId\");\n+    Preconditions.checkNotNull(newQueryId, \"newQueryId cannot be null\");\n+\n+    String queryId = queryParameters.getFirst(CachedResultsParameters.QUERY_ID);\n+    Preconditions.checkNotNull(queryId, \"queryId cannot be null\");\n+\n+    String alias = queryParameters.getFirst(\"alias\");\n+    if (alias == null) {\n+      alias = newQueryId;\n+    }\n+\n+    // Find out who/what called this method\n+    Principal p = ctx.getCallerPrincipal();\n+    String owner = getOwnerFromPrincipal(p);\n+\n+    CachedRunningQuery crq = null;\n+    try {\n+      persistByQueryId(newQueryId, alias, owner, CachedRunningQuery.Status.LOADING, \"\", true);\n+      crq = retrieve(newQueryId, owner);\n+    } catch (IOException e1) {\n+      log.error(\"Error trying to persist/retrieve cached results\", e1);\n+      try {\n+        persistByQueryId(newQueryId, alias, owner, CachedRunningQuery.Status.ERROR, e1.getMessage(), false);\n+      } catch (IOException e2) {\n+        log.error(e2.getMessage(), e2);\n+      }\n+      PreConditionFailedQueryException e =\n+          new PreConditionFailedQueryException(DatawaveErrorCode.CACHED_RESULTS_PERSIST_ERROR, e1);\n+      throw new PreConditionFailedException(e, null);\n+    }\n+\n+    RunningQuery rq = null;\n+    try {\n+      rq = getQueryById(queryId);\n+      if (rq != null) {\n+        String nameBase = UUID.randomUUID().toString().replaceAll(\"-\", \"\");\n+        Query q = rq.getSettings();\n+        crq.setOriginalQueryId(q.getId().toString());\n+        crq.setView(nameBase);\n+        crq.setAlias(alias);\n+        crq.setQuery(rq.getSettings());\n+        persist(crq, owner);\n+      }\n+\n+    } catch (Exception e) {\n+      String statusMessage = e.getMessage();\n+      if (null == statusMessage) {\n+        statusMessage = e.getClass().getName();\n+      }\n+\n+      try {\n+        persistByQueryId(newQueryId, alias, owner, CachedRunningQuery.Status.ERROR, statusMessage, true);\n+      } catch (IOException e1) {\n+        log.error(\"Error persisting status to CachedResult store\", e1);\n+      }\n+      log.error(e.getMessage(), e);\n+    }\n+\n+    // pagesize validated in loadAndCreate\n+    return new AsyncResult<>(loadAndCreate(queryId, queryParameters));\n+  }\n+\n+  /**\n+   * Returns a list of attribute names that can be used in subsequent queries\n+   *\n+   * @param id view, queryId, or alias\n+   * @return number of results, columns contained in the results\n+   * @return {@code datawave.webservice.result.CachedResultsDescribeResponse<Description>}\n+   * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user by specifying a chain of DNs of the identities to proxy\n+   * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n+   * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n+   * @HTTP 200 success\n+   * @HTTP 500 internal server error\n+   */\n+  @GET\n+  @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\",\n+      \"application/x-protobuf\"})\n+  @javax.ws.rs.Path(\"/{id}/describe\")\n+  @GZIP\n+  @Interceptors({RequiredInterceptor.class, ResponseInterceptor.class})\n+  public CachedResultsDescribeResponse describe(@PathParam(\"id\") @Required(\"id\") String id) {\n+    // Find out who/what called this method\n+    Principal p = ctx.getCallerPrincipal();\n+    String owner = getOwnerFromPrincipal(p);\n+\n+    CachedResultsDescribeResponse response = null;\n+\n+    try {\n+      response = new CachedResultsDescribeResponse();\n+      CachedRunningQuery crq;\n+      try {\n+        crq = retrieve(id, owner);\n+      } catch (IOException e1) {\n+        throw new PreConditionFailedQueryException(DatawaveErrorCode.CACHED_RESULTS_IMPORT_ERROR, e1);\n+      }\n+\n+      if (null == crq) {\n+        throw new NotFoundQueryException(DatawaveErrorCode.QUERY_OR_VIEW_NOT_FOUND);\n+      }\n+\n+      if (!crq.getUser().equals(owner)) {\n+        throw new UnauthorizedQueryException(DatawaveErrorCode.QUERY_OWNER_MISMATCH,\n+            MessageFormat.format(\"{0} != {1}\", crq.getUser(), owner));\n+      }\n+\n+      String view = crq.getView();\n+      response.setView(view);\n+\n+      List<String> columns = new ArrayList<>();\n+      Integer numRows = null;\n+      try (Connection con = ds.getConnection(); Statement s = con.createStatement()) {\n+        try (ResultSet rs = s.executeQuery(\"select count(*) from \" + view)) {\n+          if (rs.next()) {\n+            numRows = rs.getInt(1);\n+          }\n+        }\n+\n+        try (ResultSet rs = s.executeQuery(\"show columns from \" + view)) {\n+          Set<String> fixedColumns = CacheableQueryRow.getFixedColumnSet();\n+          while (rs.next()) {\n+            String column = rs.getString(1);\n+            if (!fixedColumns.contains(column)) {\n+              columns.add(column);\n+            }\n+          }\n         }\n+\n+      } catch (SQLSyntaxErrorException e) {\n+        throw new NotFoundQueryException(DatawaveErrorCode.VIEW_NOT_FOUND);\n+      } catch (SQLException e) {\n+        throw new QueryException(DatawaveErrorCode.CACHED_QUERY_SQL_ERROR);\n+      }\n+\n+      response.setColumns(columns);\n+      response.setNumRows(numRows);\n+    } catch (QueryException e) {\n+      QueryException qe = new QueryException(DatawaveErrorCode.CACHED_QUERY_DESCRIPTION_ERROR, e);\n+      response.addException(qe.getBottomQueryException());\n+      throw new DatawaveWebApplicationException(qe, response, e.getBottomQueryException().getStatusCode());\n     }\n-    \n-    /**\n-     * Re-allocate resources for these cached results and reset paging to the beginning\n-     *\n-     * @param queryId\n-     *            user defined id for this query\n-     *\n-     * @return datawave.webservice.result.CachedResultsResponse\n-     * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user by specifying a chain of DNs of the identities to proxy\n-     * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n-     * @ResponseHeader query-session-id this header and value will be in the Set-Cookie header, subsequent calls for this session will need to supply the\n-     *                 query-session-id header in the request in a Cookie header or as a query parameter\n-     * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n-     *\n-     * @HTTP 200 success\n-     * @HTTP 500 internal server error\n-     *\n-     */\n-    @PUT\n-    @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\"})\n-    @javax.ws.rs.Path(\"/{queryId}/reset\")\n-    @Interceptors({RequiredInterceptor.class, ResponseInterceptor.class})\n-    @GenerateQuerySessionId(cookieBasePath = \"/DataWave/CachedResults/\")\n-    @Timed(name = \"dw.cachedr.close\", absolute = true)\n-    public CachedResultsResponse reset(@PathParam(\"queryId\") @Required(\"queryId\") String queryId) {\n-        CreateQuerySessionIDFilter.QUERY_ID.set(null);\n-        \n-        CachedResultsResponse response = new CachedResultsResponse();\n-        \n-        // Find out who/what called this method\n-        Principal p = ctx.getCallerPrincipal();\n-        String owner = getOwnerFromPrincipal(p);\n-        \n+    return response;\n+  }\n+\n+  /**\n+   * @param queryParameters\n+   * @return datawave.webservice.result.CachedResultsResponse\n+   * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user by specifying a chain of DNs of the identities to proxy\n+   * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n+   * @ResponseHeader query-session-id this header and value will be in the Set-Cookie header, subsequent calls for this session will need to supply the\n+   * query-session-id header in the request in a Cookie header or as a query parameter\n+   * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n+   * <p>\n+   * 'view' is a required parameter, however the caller may not know the view name. In this case, the caller may substitute the alias name\n+   * they created for the view. the retrieve call may retrieve using the alias, however other calls that operate on the actual view may not\n+   * substitute the alias (it is not the name of the table/view!) see comments inline below\n+   * @HTTP 200 success\n+   * @HTTP 500 internal server error\n+   */\n+  @POST\n+  @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\"})\n+  @javax.ws.rs.Path(\"/{queryId}/create\")\n+  @Interceptors(RequiredInterceptor.class)\n+  @GenerateQuerySessionId(cookieBasePath = \"/DataWave/CachedResults/\")\n+  @Timed(name = \"dw.cachedr.create\", absolute = true)\n+  public CachedResultsResponse create(@Required(\"queryId\") @PathParam(\"queryId\") String queryId,\n+                                      MultivaluedMap<String, String> queryParameters) {\n+    CreateQuerySessionIDFilter.QUERY_ID.set(null);\n+\n+    queryParameters.putSingle(CachedResultsParameters.QUERY_ID, queryId);\n+    cp.clear();\n+    cp.validate(queryParameters);\n+\n+    CachedResultsResponse response = new CachedResultsResponse();\n+\n+    // Find out who/what called this method\n+    Principal p = ctx.getCallerPrincipal();\n+    String owner = getOwnerFromPrincipal(p);\n+\n+    CachedRunningQuery crq = null;\n+    Connection con = null;\n+    try {\n+      con = ds.getConnection();\n+      CachedRunningQuery loadCrq =\n+          retrieve(cp.getView(), owner); // the caller may have used the alias name for the view.\n+\n+      if (loadCrq == null) {\n+        throw new PreConditionFailedQueryException(DatawaveErrorCode.QUERY_NOT_CACHED);\n+      }\n+      if (!loadCrq.getUser().equals(owner)) {\n+        throw new UnauthorizedQueryException(DatawaveErrorCode.QUERY_OWNER_MISMATCH,\n+            MessageFormat.format(\"{0} != {1}\", loadCrq.getUser(), owner));\n+      }\n+\n+      if (cp.getPagesize() <= 0) {\n+        cp.setPagesize(cachedResultsConfiguration.getDefaultPageSize());\n+      }\n+\n+      int maxPageSize = cachedResultsConfiguration.getMaxPageSize();\n+      if (maxPageSize > 0 && cp.getPagesize() > maxPageSize) {\n+        throw new PreConditionFailedQueryException(DatawaveErrorCode.REQUESTED_PAGE_SIZE_TOO_LARGE,\n+            MessageFormat.format(\"{0} > {1}.\",\n+                cp.getPagesize(), maxPageSize));\n+      }\n+\n+      QueryLogic<?> queryLogic = loadCrq.getQueryLogic();\n+      String originalQueryId = loadCrq.getOriginalQueryId();\n+      Query query = loadCrq.getQuery();\n+      String table = loadCrq.getTableName();\n+\n+      Set<String> fixedFields = null;\n+      if (!StringUtils.isEmpty(cp.getFixedFields())) {\n+        fixedFields = new HashSet<>();\n+        for (String field : cp.getFixedFields().split(\",\")) {\n+          fixedFields.add(field.trim());\n+        }\n+      }\n+      // this needs the real view name, so use the value from loadCrq instead of cp.getView() (because cp.getView may return the alias instead)\n+      crq = new CachedRunningQuery(con, query, queryLogic, cp.getQueryId(), cp.getAlias(), owner, loadCrq.getView(),\n+          cp.getFields(), cp.getConditions(),\n+          cp.getGrouping(), cp.getOrder(), cp.getPagesize(), loadCrq.getVariableFields(), fixedFields, metricFactory);\n+      crq.setStatus(CachedRunningQuery.Status.CREATING);\n+      crq.setOriginalQueryId(originalQueryId);\n+      crq.setTableName(table);\n+      persist(crq, owner);\n+      // see above comment about using loadCrq.getView() instead of cp.getView()\n+      CachedRunningQuery.removeFromDatabase(loadCrq.getView());\n+\n+      crq.getMetric().setLifecycle(QueryMetric.Lifecycle.DEFINED);\n+      // see above comment about using loadCrq.getView() instead of cp.getView()\n+      String sqlQuery =\n+          crq.generateSql(loadCrq.getView(), cp.getFields(), cp.getConditions(), cp.getGrouping(), cp.getOrder(), owner,\n+              con);\n+\n+      // Store the CachedRunningQuery in the cache under the user-supplied alias\n+      if (cp.getAlias() != null) {\n+        response.setAlias(cp.getAlias());\n+      }\n+\n+      AuditType auditType = queryLogic.getAuditType(query);\n+      if (!auditType.equals(AuditType.NONE)) {\n+        // if auditType > AuditType.NONE, audit passively\n+        auditType = AuditType.PASSIVE;\n+        StringBuilder auditMessage = new StringBuilder();\n+        auditMessage.append(\"User running secondary query on cached results of original query,\");\n+        auditMessage.append(\" original query: \").append(query.getQuery());\n+        auditMessage.append(\", secondary query: \").append(sqlQuery);\n+        MultivaluedMap<String, String> params = query.toMap();\n+        marking.validate(params);\n+        PrivateAuditConstants.stripPrivateParameters(queryParameters);\n+        params.putSingle(PrivateAuditConstants.COLUMN_VISIBILITY, marking.toColumnVisibilityString());\n+        params.putSingle(PrivateAuditConstants.AUDIT_TYPE, auditType.name());\n+        params.putSingle(PrivateAuditConstants.USER_DN, query.getUserDN());\n+        params.putSingle(PrivateAuditConstants.LOGIC_CLASS, crq.getQueryLogic().getLogicName());\n+        params.remove(QueryParameters.QUERY_STRING);\n+        params.putSingle(QueryParameters.QUERY_STRING, auditMessage.toString());\n+        params.putAll(queryParameters);\n+        auditor.audit(params);\n+      }\n+\n+      response.setOriginalQueryId(originalQueryId);\n+      response.setQueryId(cp.getQueryId());\n+\n+      response.setViewName(loadCrq.getView());\n+      response.setTotalRows(crq.getTotalRows());\n+\n+      crq.setStatus(CachedRunningQuery.Status.AVAILABLE);\n+      persist(crq, owner);\n+      CreateQuerySessionIDFilter.QUERY_ID.set(cp.getQueryId());\n+      return response;\n+\n+    } catch (Exception e) {\n+\n+      if (crq != null) {\n+        crq.getMetric().setError(e);\n+      }\n+\n+      String statusMessage = e.getMessage();\n+      if (null == statusMessage) {\n+        statusMessage = e.getClass().getName();\n+      }\n+\n+      try {\n+        persistByQueryId(cp.getQueryId(), cp.getAlias(), owner, CachedRunningQuery.Status.ERROR, statusMessage, true);\n+      } catch (IOException e1) {\n+        response.addException(new QueryException(DatawaveErrorCode.CACHED_QUERY_PERSISTANCE_ERROR, e1));\n+      }\n+      QueryException qe = new QueryException(DatawaveErrorCode.CACHED_QUERY_SET_ERROR, e);\n+      log.error(qe);\n+      response.addException(qe.getBottomQueryException());\n+      throw new DatawaveWebApplicationException(qe, response);\n+    } finally {\n+      crq.closeConnection(log);\n+      // Push metrics\n+      if (crq != null && crq.getQueryLogic().getCollectQueryMetrics() == true) {\n         try {\n-            CachedRunningQuery crq = null;\n-            try {\n-                // Get the CachedRunningQuery object from the cache\n-                try {\n-                    crq = retrieve(queryId, owner);\n-                } catch (IOException e) {\n-                    throw new PreConditionFailedQueryException(DatawaveErrorCode.CACHED_RESULTS_IMPORT_ERROR);\n-                }\n-                if (null == crq)\n-                    throw new PreConditionFailedQueryException(DatawaveErrorCode.QUERY_NOT_CACHED);\n-                if (!crq.getUser().equals(owner)) {\n-                    throw new UnauthorizedQueryException(DatawaveErrorCode.QUERY_OWNER_MISMATCH, MessageFormat.format(\"{0} != {1}\", crq.getUser(), owner));\n-                }\n-                \n-                synchronized (crq) {\n-                    \n-                    if (crq.isActivated() == true) {\n-                        crq.closeConnection(log);\n-                    }\n-                    \n-                    Connection connection = ds.getConnection();\n-                    String logicName = crq.getQueryLogicName();\n-                    QueryLogic<?> queryLogic = queryFactory.getQueryLogic(logicName, p);\n-                    crq.activate(connection, queryLogic);\n-                    \n-                    response.setQueryId(crq.getQueryId());\n-                    response.setOriginalQueryId(crq.getOriginalQueryId());\n-                    response.setViewName(crq.getView());\n-                    response.setAlias(crq.getAlias());\n-                    response.setTotalRows(crq.getTotalRows());\n-                    \n-                }\n-                \n-                CreateQuerySessionIDFilter.QUERY_ID.set(queryId);\n-                return response;\n-                \n-            } finally {\n-                // Push metrics\n-                if (null != crq && crq.getQueryLogic().getCollectQueryMetrics() == true) {\n-                    \n-                    try {\n-                        metrics.updateMetric(crq.getMetric());\n-                    } catch (Exception e1) {\n-                        log.error(\"Error updating metrics\", e1);\n-                    }\n-                }\n-            }\n-        } catch (Exception e) {\n-            response.addMessage(e.getMessage());\n-            QueryException qe = new QueryException(DatawaveErrorCode.RESET_CALL_ERROR, e);\n-            log.error(qe);\n-            response.addException(qe.getBottomQueryException());\n-            int statusCode = qe.getBottomQueryException().getStatusCode();\n-            throw new DatawaveWebApplicationException(qe, response, statusCode);\n+          metrics.updateMetric(crq.getMetric());\n+        } catch (Exception e1) {\n+          log.error(e1.getMessage(), e1);\n         }\n+      }\n+\n     }\n-    \n-    /**\n-     *\n-     * Returns the next page of results to the caller. The response object type is dynamic, see the listQueryLogic operation to determine what the response type\n-     * object will be.\n-     *\n-     * @param queryId\n-     *            user defined id for this query\n-     * @return a page of results\n-     *\n-     * @return datawave.webservice.result.BaseQueryResponse\n-     * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user by specifying a chain of DNs of the identities to proxy\n-     * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n-     * @RequestHeader query-session-id session id value used for load balancing purposes. query-session-id can be placed in the request in a Cookie header or as\n-     *                a query parameter\n-     * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n-     * @ResponseHeader X-query-page-number page number returned by this call\n-     * @ResponseHeader X-query-last-page if true then there are no more pages for this query, caller should call close()\n-     * @ResponseHeader X-Partial-Results true if the page contains less than the requested number of results\n-     *\n-     * @HTTP 200 success\n-     * @HTTP 401 caller is not authorized to run the query\n-     * @HTTP 412 if the query is not active\n-     * @HTTP 500 internal server error\n-     *\n-     */\n-    @GET\n-    @javax.ws.rs.Path(\"/{queryId}/next\")\n-    @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\", \"application/x-protobuf\"})\n-    @GZIP\n-    @Interceptors({RequiredInterceptor.class, ResponseInterceptor.class})\n-    @Timed(name = \"dw.cachedr.next\", absolute = true)\n-    public BaseQueryResponse next(@PathParam(\"queryId\") @Required(\"queryId\") String queryId) {\n-        \n-        BaseQueryResponse response = responseObjectFactory.getEventQueryResponse();\n-        \n-        // Find out who/what called this method\n-        Principal p = ctx.getCallerPrincipal();\n-        String owner = getOwnerFromPrincipal(p);\n-        \n-        try {\n-            CachedRunningQuery crq = null;\n-            try {\n-                // Get the CachedRunningQuery object from the cache\n-                try {\n-                    crq = retrieve(queryId, owner);\n-                } catch (IOException e) {\n-                    throw new PreConditionFailedQueryException(DatawaveErrorCode.CACHED_RESULTS_IMPORT_ERROR, e);\n-                }\n-                if (null == crq)\n-                    throw new PreConditionFailedQueryException(DatawaveErrorCode.QUERY_NOT_CACHED);\n-                \n-                response = crq.getQueryLogic().getResponseObjectFactory().getEventQueryResponse();\n-                \n-                if (!crq.getUser().equals(owner)) {\n-                    throw new UnauthorizedQueryException(DatawaveErrorCode.QUERY_OWNER_MISMATCH, MessageFormat.format(\"{0} != {1}\", crq.getUser(), owner));\n-                }\n-                \n-                synchronized (crq) {\n-                    if (crq.isActivated() == false) {\n-                        if (crq.getShouldAutoActivate()) {\n-                            Connection connection = ds.getConnection();\n-                            String logicName = crq.getQueryLogicName();\n-                            QueryLogic<?> queryLogic = queryFactory.getQueryLogic(logicName, p);\n-                            crq.activate(connection, queryLogic);\n-                        } else {\n-                            throw new PreConditionFailedQueryException(DatawaveErrorCode.QUERY_TIMEOUT_FOR_RESOURCES);\n-                        }\n-                    }\n-                    \n-                    try {\n-                        ResultsPage resultList = crq.next(cachedResultsConfiguration.getPageByteTrigger());\n-                        long pageNum = crq.getLastPageNumber();\n-                        response = crq.getTransformer().createResponse(resultList);\n-                        Status status = null;\n-                        if (!resultList.getResults().isEmpty()) {\n-                            response.setHasResults(true);\n-                            status = Status.OK;\n-                        } else {\n-                            response.setHasResults(false);\n-                            status = Status.NO_CONTENT;\n-                        }\n-                        response.setPageNumber(pageNum);\n-                        response.setLogicName(crq.getQueryLogic().getLogicName());\n-                        response.setQueryId(crq.getQueryId());\n-                        if (response instanceof TotalResultsAware) {\n-                            ((TotalResultsAware) response).setTotalResults(crq.getTotalRows());\n-                        }\n-                        if (status == Status.NO_CONTENT) {\n-                            throw new NoResultsException(null);\n-                        }\n-                        crq.getMetric().setLifecycle(QueryMetric.Lifecycle.RESULTS);\n-                        return response;\n-                    } catch (SQLException e) {\n-                        throw new QueryException(DatawaveErrorCode.NEXT_CALL_ERROR, e);\n-                    }\n-                }\n-            } finally {\n-                \n-                // Push metrics\n-                if (null != crq && crq.getQueryLogic().getCollectQueryMetrics() == true) {\n-                    try {\n-                        metrics.updateMetric(crq.getMetric());\n-                    } catch (Exception e1) {\n-                        log.error(\"Error updating metrics\", e1);\n-                    }\n-                }\n+\n+  }\n+\n+  /**\n+   * Update fields, conditions, grouping, or order for a CachedResults query. As a general rule, keep parens at least one space away from field names. Field\n+   * names also work with or without tick marks.\n+   *\n+   * @param queryId    user defined id for this query\n+   * @param fields     comma separated list of fields in the result set\n+   * @param conditions analogous to a SQL where clause\n+   * @param grouping   comma separated list of fields to group by\n+   * @param order      comma separated list of fields for ordering\n+   * @param pagesize   size of returned pages\n+   * @return datawave.webservice.result.CachedResultsResponse\n+   * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user by specifying a chain of DNs of the identities to proxy\n+   * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n+   * @RequestHeader query-session-id session id value used for load balancing purposes. query-session-id can be placed in the request in a Cookie header or as\n+   * a query parameter\n+   * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n+   * @ResponseHeader query-session-id this header and value will be in the Set-Cookie header, subsequent calls for this session will need to supply the\n+   * query-session-id header in the request in a Cookie header or as a query parameter\n+   * @HTTP 200 success\n+   * @HTTP 401 caller is not authorized to run the query\n+   * @HTTP 412 if the query is not active\n+   * @HTTP 500 internal server error\n+   */\n+  @POST\n+  @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\"})\n+  @javax.ws.rs.Path(\"/{queryId}/update\")\n+  @Interceptors({RequiredInterceptor.class, ResponseInterceptor.class})\n+  @GenerateQuerySessionId(cookieBasePath = \"/DataWave/CachedResults/\")\n+  @Timed(name = \"dw.cachedr.update\", absolute = true)\n+  public CachedResultsResponse update(@PathParam(\"queryId\") @Required(\"queryId\") String queryId,\n+                                      @FormParam(\"fields\") String fields,\n+                                      @FormParam(\"conditions\") String conditions,\n+                                      @FormParam(\"grouping\") String grouping, @FormParam(\"order\") String order,\n+                                      @FormParam(\"pagesize\") Integer pagesize) {\n+    CreateQuerySessionIDFilter.QUERY_ID.set(null);\n+\n+    boolean updated = false;\n+\n+    CachedResultsResponse response = new CachedResultsResponse();\n+\n+    // Find out who/what called this method\n+    Principal p = ctx.getCallerPrincipal();\n+    String owner = getOwnerFromPrincipal(p);\n+\n+    try {\n+\n+      CachedRunningQuery crq = null;\n+      try {\n+\n+        crq = retrieve(queryId, owner);\n+        if (null == crq) {\n+          throw new PreConditionFailedQueryException(DatawaveErrorCode.QUERY_NOT_CACHED);\n+        }\n+        if (!crq.getUser().equals(owner)) {\n+          throw new UnauthorizedQueryException(DatawaveErrorCode.QUERY_OWNER_MISMATCH,\n+              MessageFormat.format(\"{0} != {1}\", crq.getUser(), owner));\n+        }\n+\n+        if (pagesize == null || pagesize <= 0) {\n+          pagesize = cachedResultsConfiguration.getDefaultPageSize();\n+        }\n+\n+        int maxPageSize = cachedResultsConfiguration.getMaxPageSize();\n+        if (maxPageSize > 0 && pagesize > maxPageSize) {\n+          throw new PreConditionFailedQueryException(DatawaveErrorCode.REQUESTED_PAGE_SIZE_TOO_LARGE,\n+              MessageFormat.format(\"{0} > {1}.\", pagesize,\n+                  cachedResultsConfiguration.getMaxPageSize()));\n+        }\n+\n+        synchronized (crq) {\n+\n+          if (crq.isActivated() == false) {\n+            Connection connection = ds.getConnection();\n+            String logicName = crq.getQueryLogicName();\n+            if (logicName != null) {\n+              QueryLogic<?> queryLogic = queryFactory.getQueryLogic(logicName, p);\n+              crq.activate(connection, queryLogic);\n+            } else {\n+              DbUtils.closeQuietly(connection);\n             }\n-        } catch (Exception e) {\n-            QueryException qe = null;\n-            if (e instanceof NoResultsException) {\n-                qe = new QueryException(DatawaveErrorCode.NO_CONTENT_STATUS, e);\n+          }\n+\n+          try {\n+            if (fields == null && conditions == null && grouping == null && order == null) {\n+              // don't do update\n             } else {\n-                qe = new QueryException(DatawaveErrorCode.NEXT_CALL_ERROR, e);\n-                log.error(qe);\n+              updated = crq.update(fields, conditions, grouping, order, pagesize);\n+              persist(crq, owner);\n+            }\n+\n+            response.setOriginalQueryId(crq.getOriginalQueryId());\n+            response.setQueryId(crq.getQueryId());\n+            response.setViewName(crq.getView());\n+            response.setAlias(crq.getAlias());\n+            response.setTotalRows(crq.getTotalRows());\n+          } finally {\n+            // only close connection if the crq changed, because we expect additional actions\n+            if (updated) {\n+              crq.closeConnection(log);\n             }\n-            response.addException(qe.getBottomQueryException());\n-            int statusCode = qe.getBottomQueryException().getStatusCode();\n-            throw new DatawaveWebApplicationException(qe, response, statusCode);\n+          }\n+        }\n+\n+      } finally {\n+        if (crq != null && crq.getQueryLogic() != null && crq.getQueryLogic().getCollectQueryMetrics() == true) {\n+          try {\n+            metrics.updateMetric(crq.getMetric());\n+          } catch (Exception e1) {\n+            log.error(\"Error updating metrics\", e1);\n+          }\n         }\n+      }\n+      CreateQuerySessionIDFilter.QUERY_ID.set(queryId);\n+      return response;\n+    } catch (Exception e) {\n+      QueryException qe = new QueryException(DatawaveErrorCode.CACHED_QUERY_UPDATE_ERROR, e);\n+      log.error(qe);\n+      response.addException(qe.getBottomQueryException());\n+      int statusCode = qe.getBottomQueryException().getStatusCode();\n+      throw new DatawaveWebApplicationException(qe, response, statusCode);\n     }\n-    \n-    /**\n-     * Returns a set of rows based on the given starting and end positions. The response object type is dynamic, see the listQueryLogic operation to determine\n-     * what the response type object will be.\n-     *\n-     * @param queryId\n-     *            CachedResults queryId\n-     * @param rowBegin\n-     *            first row to be returned\n-     * @param rowEnd\n-     *            last row to be returned\n-     * @return datawave.webservice.result.BaseQueryResponse\n-     * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user by specifying a chain of DNs of the identities to proxy\n-     * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n-     * @RequestHeader query-session-id session id value used for load balancing purposes. query-session-id can be placed in the request in a Cookie header or as\n-     *                a query parameter\n-     * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n-     * @ResponseHeader X-Partial-Results true if the page contains less than the requested number of results\n-     *\n-     * @HTTP 200 success\n-     * @HTTP 401 caller is not authorized to run the query\n-     * @HTTP 412 if the query is not active\n-     * @HTTP 500 internal server error\n-     */\n-    @GET\n-    @javax.ws.rs.Path(\"/{queryId}/getRows\")\n-    @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\", \"application/x-protobuf\"})\n-    @GZIP\n-    @Interceptors({RequiredInterceptor.class, ResponseInterceptor.class})\n-    @Timed(name = \"dw.cachedr.getRows\", absolute = true)\n-    public BaseQueryResponse getRows(@PathParam(\"queryId\") @Required(\"queryId\") String queryId, @QueryParam(\"rowBegin\") @DefaultValue(\"1\") Integer rowBegin,\n-                    @QueryParam(\"rowEnd\") Integer rowEnd) {\n-        \n-        BaseQueryResponse response = responseObjectFactory.getEventQueryResponse();\n-        \n-        // Find out who/what called this method\n-        Principal p = ctx.getCallerPrincipal();\n-        String owner = getOwnerFromPrincipal(p);\n-        \n+  }\n+\n+  /**\n+   * Returns the previous page of results to the caller. The response object type is dynamic, see the listQueryLogic operation to determine what the response\n+   * type object will be.\n+   *\n+   * @param queryId user defined id for this query\n+   * @return previous page of results\n+   * @return datawave.webservice.result.BaseQueryResponse\n+   * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user by specifying a chain of DNs of the identities to proxy\n+   * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n+   * @RequestHeader query-session-id session id value used for load balancing purposes. query-session-id can be placed in the request in a Cookie header or as\n+   * a query parameter\n+   * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n+   * @ResponseHeader X-query-page-number page number returned by this call\n+   * @ResponseHeader X-query-last-page if true then there are no more pages for this query, caller should call close()\n+   * @ResponseHeader X-Partial-Results true if the page contains less than the requested number of results\n+   * @HTTP 200 success\n+   * @HTTP 401 caller is not authorized to run the query\n+   * @HTTP 412 if the query is not active\n+   * @HTTP 500 internal server error\n+   */\n+  @GET\n+  @javax.ws.rs.Path(\"/{queryId}/previous\")\n+  @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\",\n+      \"application/x-protobuf\"})\n+  @GZIP\n+  @Interceptors({RequiredInterceptor.class, ResponseInterceptor.class})\n+  @Timed(name = \"dw.cachedr.previous\", absolute = true)\n+  public BaseQueryResponse previous(@PathParam(\"queryId\") @Required(\"queryId\") String queryId) {\n+\n+    BaseQueryResponse response = responseObjectFactory.getEventQueryResponse();\n+\n+    // Find out who/what called this method\n+    Principal p = ctx.getCallerPrincipal();\n+    String owner = getOwnerFromPrincipal(p);\n+\n+    try {\n+      CachedRunningQuery crq = null;\n+      try {\n+        // Get the CachedRunningQuery object from the cache\n         try {\n-            if (rowBegin < 1) {\n-                throw new BadRequestQueryException(DatawaveErrorCode.ROW_BEGIN_LESS_THAN_1);\n-            }\n-            if (rowEnd != null && rowEnd < rowBegin) {\n-                throw new BadRequestQueryException(DatawaveErrorCode.ROW_END_LESS_THAN_ROW_BEGIN);\n-            }\n-            \n-            // If there is a this.maxPageSize set, then we should honor it here. Otherwise, we use Integer.MAX_VALUE\n-            int maxPageSize = cachedResultsConfiguration.getMaxPageSize();\n-            if (rowEnd == null) {\n-                if (maxPageSize > 0) {\n-                    rowEnd = (rowBegin + maxPageSize) - 1;\n-                } else {\n-                    rowEnd = Integer.MAX_VALUE;\n-                }\n+          crq = retrieve(queryId, owner);\n+        } catch (IOException e) {\n+          throw new PreConditionFailedQueryException(DatawaveErrorCode.CACHED_RESULTS_IMPORT_ERROR, e);\n+        }\n+        if (null == crq) {\n+          throw new PreConditionFailedQueryException(DatawaveErrorCode.QUERY_NOT_CACHED);\n+        }\n+        if (!crq.getUser().equals(owner)) {\n+          throw new UnauthorizedQueryException(DatawaveErrorCode.QUERY_OWNER_MISMATCH,\n+              MessageFormat.format(\"{0} != {1}\", crq.getUser(), owner));\n+        }\n+\n+        synchronized (crq) {\n+          if (crq.isActivated() == false) {\n+            if (crq.getShouldAutoActivate()) {\n+              Connection connection = ds.getConnection();\n+              String logicName = crq.getQueryLogicName();\n+              QueryLogic<?> queryLogic = queryFactory.getQueryLogic(logicName, p);\n+              crq.activate(connection, queryLogic);\n+            } else {\n+              throw new PreConditionFailedQueryException(DatawaveErrorCode.QUERY_TIMEOUT_FOR_RESOURCES);\n             }\n-            int pagesize = (rowEnd - rowBegin) + 1;\n-            if (maxPageSize > 0 && pagesize > maxPageSize) {\n-                throw new QueryException(DatawaveErrorCode.TOO_MANY_ROWS_REQUESTED,\n-                                MessageFormat.format(\"Size must be less than or equal to: {0}\", maxPageSize));\n+          }\n+\n+          try {\n+            ResultsPage resultList = crq.previous(cachedResultsConfiguration.getPageByteTrigger());\n+            long pageNum = crq.getLastPageNumber();\n+            response = crq.getTransformer().createResponse(resultList);\n+            Status status = null;\n+            if (!resultList.getResults().isEmpty()) {\n+              response.setHasResults(true);\n+              status = Status.OK;\n+            } else {\n+              response.setHasResults(false);\n+              status = Status.NO_CONTENT;\n             }\n-            \n-            CachedRunningQuery crq = null;\n-            try {\n-                // Get the CachedRunningQuery object from the cache\n-                try {\n-                    crq = retrieve(queryId, owner);\n-                } catch (IOException e) {\n-                    throw new PreConditionFailedQueryException(DatawaveErrorCode.CACHED_RESULTS_IMPORT_ERROR, e);\n-                }\n-                \n-                if (null == crq)\n-                    throw new PreConditionFailedQueryException(DatawaveErrorCode.QUERY_NOT_CACHED);\n-                \n-                response = crq.getQueryLogic().getResponseObjectFactory().getEventQueryResponse();\n-                \n-                if (!crq.getUser().equals(owner)) {\n-                    throw new UnauthorizedQueryException(DatawaveErrorCode.QUERY_OWNER_MISMATCH, MessageFormat.format(\"{0} != {1}\", crq.getUser(), owner));\n-                }\n-                \n-                synchronized (crq) {\n-                    \n-                    if (crq.isActivated() == false) {\n-                        Connection connection = ds.getConnection();\n-                        String logicName = crq.getQueryLogicName();\n-                        QueryLogic<?> queryLogic = queryFactory.getQueryLogic(logicName, p);\n-                        crq.activate(connection, queryLogic);\n-                    }\n-                    \n-                    try {\n-                        ResultsPage resultList = crq.getRows(rowBegin, rowEnd, cachedResultsConfiguration.getPageByteTrigger());\n-                        response = crq.getTransformer().createResponse(resultList);\n-                        Status status;\n-                        if (!resultList.getResults().isEmpty()) {\n-                            response.setHasResults(true);\n-                            status = Status.OK;\n-                        } else {\n-                            response.setHasResults(false);\n-                            status = Status.NO_CONTENT;\n-                        }\n-                        response.setLogicName(crq.getQueryLogic().getLogicName());\n-                        response.setQueryId(crq.getQueryId());\n-                        if (response instanceof TotalResultsAware) {\n-                            ((TotalResultsAware) response).setTotalResults(crq.getTotalRows());\n-                        }\n-                        if (status == Status.NO_CONTENT) {\n-                            throw new NoResultsQueryException(DatawaveErrorCode.NO_CONTENT_STATUS);\n-                        }\n-                        crq.getMetric().setLifecycle(QueryMetric.Lifecycle.RESULTS);\n-                        return response;\n-                        \n-                    } catch (SQLException e) {\n-                        throw new QueryException();\n-                    } catch (NoResultsQueryException e) {\n-                        throw e;\n-                    } catch (RuntimeException e) {\n-                        log.error(e.getMessage(), e);\n-                        throw e;\n-                    } finally {\n-                        crq.closeConnection(log);\n-                    }\n-                }\n-            } finally {\n-                // Push metrics\n-                try {\n-                    if (null != crq && crq.getQueryLogic().getCollectQueryMetrics() == true) {\n-                        metrics.updateMetric(crq.getMetric());\n-                    }\n-                } catch (Exception e1) {\n-                    log.error(\"Error updating metrics\", e1);\n-                }\n+            response.setPageNumber(pageNum);\n+            response.setLogicName(crq.getQueryLogic().getLogicName());\n+            response.setQueryId(crq.getQueryId());\n+            if (response instanceof TotalResultsAware) {\n+              ((TotalResultsAware) response).setTotalResults(crq.getTotalRows());\n             }\n-        } catch (Exception e) {\n-            DatawaveErrorCode dec;\n-            if (e instanceof NoResultsQueryException) {\n-                dec = DatawaveErrorCode.NO_CONTENT_STATUS;\n-            } else {\n-                dec = DatawaveErrorCode.CACHED_QUERY_TRANSACTION_ERROR;\n+            if (status == Status.NO_CONTENT) {\n+              throw new NoResultsException(null);\n             }\n-            QueryException qe = new QueryException(dec, e);\n-            log.error(qe);\n-            response.addException(qe.getBottomQueryException());\n-            int statusCode = qe.getBottomQueryException().getStatusCode();\n-            throw new DatawaveWebApplicationException(qe, response, statusCode);\n+            crq.getMetric().setLifecycle(QueryMetric.Lifecycle.RESULTS);\n+            return response;\n+          } catch (SQLException e) {\n+            throw new QueryException(DatawaveErrorCode.CACHED_QUERY_SQL_ERROR, e);\n+          }\n+        }\n+      } finally {\n+        // Push metrics\n+        if (null != crq && crq.getQueryLogic().getCollectQueryMetrics() == true) {\n+\n+          try {\n+            metrics.updateMetric(crq.getMetric());\n+          } catch (Exception e1) {\n+            log.error(\"Error updating metrics\", e1);\n+          }\n+        }\n+      }\n+    } catch (Exception e) {\n+      QueryException qe = null;\n+      if (e instanceof NoResultsException) {\n+        qe = new QueryException(DatawaveErrorCode.NO_CONTENT_STATUS, e);\n+      } else {\n+        qe = new QueryException(\"Error calling previous.\", e, \"500-42\");\n+        log.error(qe);\n+      }\n+      response.addException(qe.getBottomQueryException());\n+      int statusCode = qe.getBottomQueryException().getStatusCode();\n+      throw new DatawaveWebApplicationException(qe, response, statusCode);\n+    }\n+  }\n+\n+  /**\n+   * Re-allocate resources for these cached results and reset paging to the beginning\n+   *\n+   * @param queryId user defined id for this query\n+   * @return datawave.webservice.result.CachedResultsResponse\n+   * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user by specifying a chain of DNs of the identities to proxy\n+   * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n+   * @ResponseHeader query-session-id this header and value will be in the Set-Cookie header, subsequent calls for this session will need to supply the\n+   * query-session-id header in the request in a Cookie header or as a query parameter\n+   * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n+   * @HTTP 200 success\n+   * @HTTP 500 internal server error\n+   */\n+  @PUT\n+  @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\"})\n+  @javax.ws.rs.Path(\"/{queryId}/reset\")\n+  @Interceptors({RequiredInterceptor.class, ResponseInterceptor.class})\n+  @GenerateQuerySessionId(cookieBasePath = \"/DataWave/CachedResults/\")\n+  @Timed(name = \"dw.cachedr.close\", absolute = true)\n+  public CachedResultsResponse reset(@PathParam(\"queryId\") @Required(\"queryId\") String queryId) {\n+    CreateQuerySessionIDFilter.QUERY_ID.set(null);\n+\n+    CachedResultsResponse response = new CachedResultsResponse();\n+\n+    // Find out who/what called this method\n+    Principal p = ctx.getCallerPrincipal();\n+    String owner = getOwnerFromPrincipal(p);\n+\n+    try {\n+      CachedRunningQuery crq = null;\n+      try {\n+        // Get the CachedRunningQuery object from the cache\n+        try {\n+          crq = retrieve(queryId, owner);\n+        } catch (IOException e) {\n+          throw new PreConditionFailedQueryException(DatawaveErrorCode.CACHED_RESULTS_IMPORT_ERROR);\n+        }\n+        if (null == crq) {\n+          throw new PreConditionFailedQueryException(DatawaveErrorCode.QUERY_NOT_CACHED);\n+        }\n+        if (!crq.getUser().equals(owner)) {\n+          throw new UnauthorizedQueryException(DatawaveErrorCode.QUERY_OWNER_MISMATCH,\n+              MessageFormat.format(\"{0} != {1}\", crq.getUser(), owner));\n+        }\n+\n+        synchronized (crq) {\n+\n+          if (crq.isActivated() == true) {\n+            crq.closeConnection(log);\n+          }\n+\n+          Connection connection = ds.getConnection();\n+          String logicName = crq.getQueryLogicName();\n+          QueryLogic<?> queryLogic = queryFactory.getQueryLogic(logicName, p);\n+          crq.activate(connection, queryLogic);\n+\n+          response.setQueryId(crq.getQueryId());\n+          response.setOriginalQueryId(crq.getOriginalQueryId());\n+          response.setViewName(crq.getView());\n+          response.setAlias(crq.getAlias());\n+          response.setTotalRows(crq.getTotalRows());\n+\n+        }\n+\n+        CreateQuerySessionIDFilter.QUERY_ID.set(queryId);\n+        return response;\n+\n+      } finally {\n+        // Push metrics\n+        if (null != crq && crq.getQueryLogic().getCollectQueryMetrics() == true) {\n+\n+          try {\n+            metrics.updateMetric(crq.getMetric());\n+          } catch (Exception e1) {\n+            log.error(\"Error updating metrics\", e1);\n+          }\n         }\n+      }\n+    } catch (Exception e) {\n+      response.addMessage(e.getMessage());\n+      QueryException qe = new QueryException(DatawaveErrorCode.RESET_CALL_ERROR, e);\n+      log.error(qe);\n+      response.addException(qe.getBottomQueryException());\n+      int statusCode = qe.getBottomQueryException().getStatusCode();\n+      throw new DatawaveWebApplicationException(qe, response, statusCode);\n     }\n-    \n-    /**\n-     * Cancel the load process.\n-     *\n-     * @param originalQueryId\n-     *\n-     * @return datawave.webservice.result.VoidResponse\n-     * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user by specifying a chain of DNs of the identities to proxy\n-     * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n-     * @RequestHeader query-session-id session id value used for load balancing purposes. query-session-id can be placed in the request in a Cookie header or as\n-     *                a query parameter\n-     * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n-     *\n-     * @HTTP 200 success\n-     * @HTTP 401 caller is not authorized to cancel the query\n-     */\n-    @PUT\n-    @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\", \"application/x-protobuf\",\n-            \"application/x-protostuff\"})\n-    @javax.ws.rs.Path(\"/{queryId}/cancel\")\n-    @GZIP\n-    @ClearQuerySessionId\n-    @Interceptors({RequiredInterceptor.class, ResponseInterceptor.class})\n-    @Timed(name = \"dw.cachedr.cancel\", absolute = true)\n-    public VoidResponse cancelLoad(@PathParam(\"queryId\") @Required(\"queryId\") String originalQueryId) {\n-        // Find out who/what called this method\n-        Principal p = ctx.getCallerPrincipal();\n-        String owner = getOwnerFromPrincipal(p);\n-        \n-        VoidResponse response = new VoidResponse();\n-        \n+  }\n+\n+  /**\n+   * Returns the next page of results to the caller. The response object type is dynamic, see the listQueryLogic operation to determine what the response type\n+   * object will be.\n+   *\n+   * @param queryId user defined id for this query\n+   * @return a page of results\n+   * @return datawave.webservice.result.BaseQueryResponse\n+   * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user by specifying a chain of DNs of the identities to proxy\n+   * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n+   * @RequestHeader query-session-id session id value used for load balancing purposes. query-session-id can be placed in the request in a Cookie header or as\n+   * a query parameter\n+   * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n+   * @ResponseHeader X-query-page-number page number returned by this call\n+   * @ResponseHeader X-query-last-page if true then there are no more pages for this query, caller should call close()\n+   * @ResponseHeader X-Partial-Results true if the page contains less than the requested number of results\n+   * @HTTP 200 success\n+   * @HTTP 401 caller is not authorized to run the query\n+   * @HTTP 412 if the query is not active\n+   * @HTTP 500 internal server error\n+   */\n+  @GET\n+  @javax.ws.rs.Path(\"/{queryId}/next\")\n+  @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\",\n+      \"application/x-protobuf\"})\n+  @GZIP\n+  @Interceptors({RequiredInterceptor.class, ResponseInterceptor.class})\n+  @Timed(name = \"dw.cachedr.next\", absolute = true)\n+  public BaseQueryResponse next(@PathParam(\"queryId\") @Required(\"queryId\") String queryId) {\n+\n+    BaseQueryResponse response = responseObjectFactory.getEventQueryResponse();\n+\n+    // Find out who/what called this method\n+    Principal p = ctx.getCallerPrincipal();\n+    String owner = getOwnerFromPrincipal(p);\n+\n+    try {\n+      CachedRunningQuery crq = null;\n+      try {\n+        // Get the CachedRunningQuery object from the cache\n         try {\n-            // check if query is even loading\n-            RunningQuery query = CachedResultsBean.loadingQueryMap.get(originalQueryId);\n-            \n-            if (query == null) {\n-                NotFoundQueryException e = new NotFoundQueryException(DatawaveErrorCode.NO_QUERY_OBJECT_MATCH);\n-                throw new NotFoundException(e, response);\n+          crq = retrieve(queryId, owner);\n+        } catch (IOException e) {\n+          throw new PreConditionFailedQueryException(DatawaveErrorCode.CACHED_RESULTS_IMPORT_ERROR, e);\n+        }\n+        if (null == crq) {\n+          throw new PreConditionFailedQueryException(DatawaveErrorCode.QUERY_NOT_CACHED);\n+        }\n+\n+        response = crq.getQueryLogic().getResponseObjectFactory().getEventQueryResponse();\n+\n+        if (!crq.getUser().equals(owner)) {\n+          throw new UnauthorizedQueryException(DatawaveErrorCode.QUERY_OWNER_MISMATCH,\n+              MessageFormat.format(\"{0} != {1}\", crq.getUser(), owner));\n+        }\n+\n+        synchronized (crq) {\n+          if (crq.isActivated() == false) {\n+            if (crq.getShouldAutoActivate()) {\n+              Connection connection = ds.getConnection();\n+              String logicName = crq.getQueryLogicName();\n+              QueryLogic<?> queryLogic = queryFactory.getQueryLogic(logicName, p);\n+              crq.activate(connection, queryLogic);\n             } else {\n-                if (query.getSettings().getOwner().equals(owner)) {\n-                    accumuloConnectionRequestBean.cancelConnectionRequest(originalQueryId);\n-                    query.cancel();\n-                    response.addMessage(\"CachedResults load canceled.\");\n-                } else {\n-                    UnauthorizedQueryException e = new UnauthorizedQueryException(DatawaveErrorCode.QUERY_OWNER_MISMATCH, MessageFormat.format(\"{0} != {1}\",\n-                                    query.getSettings().getOwner(), owner));\n-                    throw new UnauthorizedException(e, response);\n-                }\n+              throw new PreConditionFailedQueryException(DatawaveErrorCode.QUERY_TIMEOUT_FOR_RESOURCES);\n             }\n+          }\n+\n+          try {\n+            ResultsPage resultList = crq.next(cachedResultsConfiguration.getPageByteTrigger());\n+            long pageNum = crq.getLastPageNumber();\n+            response = crq.getTransformer().createResponse(resultList);\n+            Status status = null;\n+            if (!resultList.getResults().isEmpty()) {\n+              response.setHasResults(true);\n+              status = Status.OK;\n+            } else {\n+              response.setHasResults(false);\n+              status = Status.NO_CONTENT;\n+            }\n+            response.setPageNumber(pageNum);\n+            response.setLogicName(crq.getQueryLogic().getLogicName());\n+            response.setQueryId(crq.getQueryId());\n+            if (response instanceof TotalResultsAware) {\n+              ((TotalResultsAware) response).setTotalResults(crq.getTotalRows());\n+            }\n+            if (status == Status.NO_CONTENT) {\n+              throw new NoResultsException(null);\n+            }\n+            crq.getMetric().setLifecycle(QueryMetric.Lifecycle.RESULTS);\n             return response;\n-        } catch (DatawaveWebApplicationException e) {\n-            throw e;\n-        } catch (Exception e) {\n-            QueryException qe = new QueryException(DatawaveErrorCode.CANCELLATION_ERROR, e, MessageFormat.format(\"query_id: {0}\", originalQueryId));\n-            log.error(qe);\n-            response.addException(qe.getBottomQueryException());\n-            int statusCode = qe.getBottomQueryException().getStatusCode();\n-            throw new DatawaveWebApplicationException(qe, response, statusCode);\n+          } catch (SQLException e) {\n+            throw new QueryException(DatawaveErrorCode.NEXT_CALL_ERROR, e);\n+          }\n+        }\n+      } finally {\n+\n+        // Push metrics\n+        if (null != crq && crq.getQueryLogic().getCollectQueryMetrics() == true) {\n+          try {\n+            metrics.updateMetric(crq.getMetric());\n+          } catch (Exception e1) {\n+            log.error(\"Error updating metrics\", e1);\n+          }\n         }\n+      }\n+    } catch (Exception e) {\n+      QueryException qe = null;\n+      if (e instanceof NoResultsException) {\n+        qe = new QueryException(DatawaveErrorCode.NO_CONTENT_STATUS, e);\n+      } else {\n+        qe = new QueryException(DatawaveErrorCode.NEXT_CALL_ERROR, e);\n+        log.error(qe);\n+      }\n+      response.addException(qe.getBottomQueryException());\n+      int statusCode = qe.getBottomQueryException().getStatusCode();\n+      throw new DatawaveWebApplicationException(qe, response, statusCode);\n     }\n-    \n-    /**\n-     * <strong>JBossAdministrator or Administrator credentials required.</strong> Cancel the load process\n-     *\n-     * @param originalQueryId\n-     *\n-     * @return datawave.webservice.result.VoidResponse\n-     * @RequestHeader X-ProxiedEntitiesChain use when proxying request for a user by specifying a chain of DNs of the identities to proxy\n-     * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n-     * @RequestHeader query-session-id session id value used for load balancing purposes. query-session-id can be placed in the request in a Cookie header or as\n-     *                a query parameter\n-     * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n-     *\n-     * @HTTP 200 success\n-     */\n-    @PUT\n-    @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\", \"application/x-protobuf\",\n-            \"application/x-protostuff\"})\n-    @javax.ws.rs.Path(\"/Admin/{queryId}/cancel\")\n-    @GZIP\n-    @RolesAllowed({\"InternalUser\", \"Administrator\", \"JBossAdministrator\"})\n-    @Interceptors({RequiredInterceptor.class, ResponseInterceptor.class})\n-    public VoidResponse cancelLoadByAdmin(@PathParam(\"queryId\") @Required(\"queryId\") String originalQueryId) {\n-        \n-        VoidResponse response = new VoidResponse();\n-        \n+  }\n+\n+  /**\n+   * Returns a set of rows based on the given starting and end positions. The response object type is dynamic, see the listQueryLogic operation to determine\n+   * what the response type object will be.\n+   *\n+   * @param queryId  CachedResults queryId\n+   * @param rowBegin first row to be returned\n+   * @param rowEnd   last row to be returned\n+   * @return datawave.webservice.result.BaseQueryResponse\n+   * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user by specifying a chain of DNs of the identities to proxy\n+   * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n+   * @RequestHeader query-session-id session id value used for load balancing purposes. query-session-id can be placed in the request in a Cookie header or as\n+   * a query parameter\n+   * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n+   * @ResponseHeader X-Partial-Results true if the page contains less than the requested number of results\n+   * @HTTP 200 success\n+   * @HTTP 401 caller is not authorized to run the query\n+   * @HTTP 412 if the query is not active\n+   * @HTTP 500 internal server error\n+   */\n+  @GET\n+  @javax.ws.rs.Path(\"/{queryId}/getRows\")\n+  @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\",\n+      \"application/x-protobuf\"})\n+  @GZIP\n+  @Interceptors({RequiredInterceptor.class, ResponseInterceptor.class})\n+  @Timed(name = \"dw.cachedr.getRows\", absolute = true)\n+  public BaseQueryResponse getRows(@PathParam(\"queryId\") @Required(\"queryId\") String queryId,\n+                                   @QueryParam(\"rowBegin\") @DefaultValue(\"1\") Integer rowBegin,\n+                                   @QueryParam(\"rowEnd\") Integer rowEnd) {\n+\n+    BaseQueryResponse response = responseObjectFactory.getEventQueryResponse();\n+\n+    // Find out who/what called this method\n+    Principal p = ctx.getCallerPrincipal();\n+    String owner = getOwnerFromPrincipal(p);\n+\n+    try {\n+      if (rowBegin < 1) {\n+        throw new BadRequestQueryException(DatawaveErrorCode.ROW_BEGIN_LESS_THAN_1);\n+      }\n+      if (rowEnd != null && rowEnd < rowBegin) {\n+        throw new BadRequestQueryException(DatawaveErrorCode.ROW_END_LESS_THAN_ROW_BEGIN);\n+      }\n+\n+      // If there is a this.maxPageSize set, then we should honor it here. Otherwise, we use Integer.MAX_VALUE\n+      int maxPageSize = cachedResultsConfiguration.getMaxPageSize();\n+      if (rowEnd == null) {\n+        if (maxPageSize > 0) {\n+          rowEnd = (rowBegin + maxPageSize) - 1;\n+        } else {\n+          rowEnd = Integer.MAX_VALUE;\n+        }\n+      }\n+      int pagesize = (rowEnd - rowBegin) + 1;\n+      if (maxPageSize > 0 && pagesize > maxPageSize) {\n+        throw new QueryException(DatawaveErrorCode.TOO_MANY_ROWS_REQUESTED,\n+            MessageFormat.format(\"Size must be less than or equal to: {0}\", maxPageSize));\n+      }\n+\n+      CachedRunningQuery crq = null;\n+      try {\n+        // Get the CachedRunningQuery object from the cache\n         try {\n-            // check if query is even loading\n-            RunningQuery query = CachedResultsBean.loadingQueryMap.get(originalQueryId);\n-            \n-            if (query == null) {\n-                NotFoundQueryException e = new NotFoundQueryException(DatawaveErrorCode.NO_QUERY_OBJECT_MATCH);\n-                throw new NotFoundException(e, response);\n+          crq = retrieve(queryId, owner);\n+        } catch (IOException e) {\n+          throw new PreConditionFailedQueryException(DatawaveErrorCode.CACHED_RESULTS_IMPORT_ERROR, e);\n+        }\n+\n+        if (null == crq) {\n+          throw new PreConditionFailedQueryException(DatawaveErrorCode.QUERY_NOT_CACHED);\n+        }\n+\n+        response = crq.getQueryLogic().getResponseObjectFactory().getEventQueryResponse();\n+\n+        if (!crq.getUser().equals(owner)) {\n+          throw new UnauthorizedQueryException(DatawaveErrorCode.QUERY_OWNER_MISMATCH,\n+              MessageFormat.format(\"{0} != {1}\", crq.getUser(), owner));\n+        }\n+\n+        synchronized (crq) {\n+\n+          if (crq.isActivated() == false) {\n+            Connection connection = ds.getConnection();\n+            String logicName = crq.getQueryLogicName();\n+            QueryLogic<?> queryLogic = queryFactory.getQueryLogic(logicName, p);\n+            crq.activate(connection, queryLogic);\n+          }\n+\n+          try {\n+            ResultsPage resultList = crq.getRows(rowBegin, rowEnd, cachedResultsConfiguration.getPageByteTrigger());\n+            response = crq.getTransformer().createResponse(resultList);\n+            Status status;\n+            if (!resultList.getResults().isEmpty()) {\n+              response.setHasResults(true);\n+              status = Status.OK;\n             } else {\n-                accumuloConnectionRequestBean.adminCancelConnectionRequest(originalQueryId);\n-                query.cancel();\n-                response.addMessage(\"CachedResults load canceled.\");\n+              response.setHasResults(false);\n+              status = Status.NO_CONTENT;\n+            }\n+            response.setLogicName(crq.getQueryLogic().getLogicName());\n+            response.setQueryId(crq.getQueryId());\n+            if (response instanceof TotalResultsAware) {\n+              ((TotalResultsAware) response).setTotalResults(crq.getTotalRows());\n             }\n+            if (status == Status.NO_CONTENT) {\n+              throw new NoResultsQueryException(DatawaveErrorCode.NO_CONTENT_STATUS);\n+            }\n+            crq.getMetric().setLifecycle(QueryMetric.Lifecycle.RESULTS);\n             return response;\n-        } catch (DatawaveWebApplicationException e) {\n+\n+          } catch (SQLException e) {\n+            throw new QueryException();\n+          } catch (NoResultsQueryException e) {\n             throw e;\n-        } catch (Exception e) {\n-            QueryException qe = new QueryException(DatawaveErrorCode.CANCELLATION_ERROR, e, MessageFormat.format(\"query_id: {0}\", originalQueryId));\n-            log.error(qe);\n-            response.addException(qe.getBottomQueryException());\n-            int statusCode = qe.getBottomQueryException().getStatusCode();\n-            throw new DatawaveWebApplicationException(qe, response, statusCode);\n+          } catch (RuntimeException e) {\n+            log.error(e.getMessage(), e);\n+            throw e;\n+          } finally {\n+            crq.closeConnection(log);\n+          }\n+        }\n+      } finally {\n+        // Push metrics\n+        try {\n+          if (null != crq && crq.getQueryLogic().getCollectQueryMetrics() == true) {\n+            metrics.updateMetric(crq.getMetric());\n+          }\n+        } catch (Exception e1) {\n+          log.error(\"Error updating metrics\", e1);\n+        }\n+      }\n+    } catch (Exception e) {\n+      DatawaveErrorCode dec;\n+      if (e instanceof NoResultsQueryException) {\n+        dec = DatawaveErrorCode.NO_CONTENT_STATUS;\n+      } else {\n+        dec = DatawaveErrorCode.CACHED_QUERY_TRANSACTION_ERROR;\n+      }\n+      QueryException qe = new QueryException(dec, e);\n+      log.error(qe);\n+      response.addException(qe.getBottomQueryException());\n+      int statusCode = qe.getBottomQueryException().getStatusCode();\n+      throw new DatawaveWebApplicationException(qe, response, statusCode);\n+    }\n+  }\n+\n+  /**\n+   * Cancel the load process.\n+   *\n+   * @param originalQueryId\n+   * @return datawave.webservice.result.VoidResponse\n+   * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user by specifying a chain of DNs of the identities to proxy\n+   * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n+   * @RequestHeader query-session-id session id value used for load balancing purposes. query-session-id can be placed in the request in a Cookie header or as\n+   * a query parameter\n+   * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n+   * @HTTP 200 success\n+   * @HTTP 401 caller is not authorized to cancel the query\n+   */\n+  @PUT\n+  @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\",\n+      \"application/x-protobuf\",\n+      \"application/x-protostuff\"})\n+  @javax.ws.rs.Path(\"/{queryId}/cancel\")\n+  @GZIP\n+  @ClearQuerySessionId\n+  @Interceptors({RequiredInterceptor.class, ResponseInterceptor.class})\n+  @Timed(name = \"dw.cachedr.cancel\", absolute = true)\n+  public VoidResponse cancelLoad(@PathParam(\"queryId\") @Required(\"queryId\") String originalQueryId) {\n+    // Find out who/what called this method\n+    Principal p = ctx.getCallerPrincipal();\n+    String owner = getOwnerFromPrincipal(p);\n+\n+    VoidResponse response = new VoidResponse();\n+\n+    try {\n+      // check if query is even loading\n+      RunningQuery query = CachedResultsBean.loadingQueryMap.get(originalQueryId);\n+\n+      if (query == null) {\n+        NotFoundQueryException e = new NotFoundQueryException(DatawaveErrorCode.NO_QUERY_OBJECT_MATCH);\n+        throw new NotFoundException(e, response);\n+      } else {\n+        if (query.getSettings().getOwner().equals(owner)) {\n+          accumuloConnectionRequestBean.cancelConnectionRequest(originalQueryId);\n+          query.cancel();\n+          response.addMessage(\"CachedResults load canceled.\");\n+        } else {\n+          UnauthorizedQueryException e =\n+              new UnauthorizedQueryException(DatawaveErrorCode.QUERY_OWNER_MISMATCH, MessageFormat.format(\"{0} != {1}\",\n+                  query.getSettings().getOwner(), owner));\n+          throw new UnauthorizedException(e, response);\n+        }\n+      }\n+      return response;\n+    } catch (DatawaveWebApplicationException e) {\n+      throw e;\n+    } catch (Exception e) {\n+      QueryException qe = new QueryException(DatawaveErrorCode.CANCELLATION_ERROR, e,\n+          MessageFormat.format(\"query_id: {0}\", originalQueryId));\n+      log.error(qe);\n+      response.addException(qe.getBottomQueryException());\n+      int statusCode = qe.getBottomQueryException().getStatusCode();\n+      throw new DatawaveWebApplicationException(qe, response, statusCode);\n+    }\n+  }\n+\n+  /**\n+   * <strong>JBossAdministrator or Administrator credentials required.</strong> Cancel the load process\n+   *\n+   * @param originalQueryId\n+   * @return datawave.webservice.result.VoidResponse\n+   * @RequestHeader X-ProxiedEntitiesChain use when proxying request for a user by specifying a chain of DNs of the identities to proxy\n+   * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n+   * @RequestHeader query-session-id session id value used for load balancing purposes. query-session-id can be placed in the request in a Cookie header or as\n+   * a query parameter\n+   * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n+   * @HTTP 200 success\n+   */\n+  @PUT\n+  @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\",\n+      \"application/x-protobuf\",\n+      \"application/x-protostuff\"})\n+  @javax.ws.rs.Path(\"/Admin/{queryId}/cancel\")\n+  @GZIP\n+  @RolesAllowed({\"InternalUser\", \"Administrator\", \"JBossAdministrator\"})\n+  @Interceptors({RequiredInterceptor.class, ResponseInterceptor.class})\n+  public VoidResponse cancelLoadByAdmin(@PathParam(\"queryId\") @Required(\"queryId\") String originalQueryId) {\n+\n+    VoidResponse response = new VoidResponse();\n+\n+    try {\n+      // check if query is even loading\n+      RunningQuery query = CachedResultsBean.loadingQueryMap.get(originalQueryId);\n+\n+      if (query == null) {\n+        NotFoundQueryException e = new NotFoundQueryException(DatawaveErrorCode.NO_QUERY_OBJECT_MATCH);\n+        throw new NotFoundException(e, response);\n+      } else {\n+        accumuloConnectionRequestBean.adminCancelConnectionRequest(originalQueryId);\n+        query.cancel();\n+        response.addMessage(\"CachedResults load canceled.\");\n+      }\n+      return response;\n+    } catch (DatawaveWebApplicationException e) {\n+      throw e;\n+    } catch (Exception e) {\n+      QueryException qe = new QueryException(DatawaveErrorCode.CANCELLATION_ERROR, e,\n+          MessageFormat.format(\"query_id: {0}\", originalQueryId));\n+      log.error(qe);\n+      response.addException(qe.getBottomQueryException());\n+      int statusCode = qe.getBottomQueryException().getStatusCode();\n+      throw new DatawaveWebApplicationException(qe, response, statusCode);\n+    }\n+  }\n+\n+  @RolesAllowed({\"InternalUser\"})\n+  public boolean isQueryLoading(String originalQueryId) {\n+    return CachedResultsBean.loadingQueryMap.containsKey(originalQueryId);\n+  }\n+\n+  /**\n+   * Releases resources associated with this query.\n+   *\n+   * @param queryId use defined id for this query\n+   * @return datawave.webservice.result.VoidResponse\n+   * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user by specifying a chain of DNs of the identities to proxy\n+   * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n+   * @RequestHeader query-session-id session id value used for load balancing purposes. query-session-id can be placed in the request in a Cookie header or as\n+   * a query parameter\n+   * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n+   * @HTTP 200 success\n+   * @HTTP 500 internal server error\n+   */\n+  @DELETE\n+  @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\"})\n+  @javax.ws.rs.Path(\"/{queryId}/close\")\n+  @Interceptors({RequiredInterceptor.class, ResponseInterceptor.class})\n+  @ClearQuerySessionId\n+  @Timed(name = \"dw.cachedr.close\", absolute = true)\n+  public VoidResponse close(@PathParam(\"queryId\") @Required(\"queryId\") String queryId) {\n+    // Find out who/what called this method\n+    Principal p = ctx.getCallerPrincipal();\n+    String owner = getOwnerFromPrincipal(p);\n+    VoidResponse response = new VoidResponse();\n+    CachedRunningQuery crq;\n+    try {\n+      crq = retrieve(queryId, owner);\n+    } catch (IOException e) {\n+      PreConditionFailedQueryException qe =\n+          new PreConditionFailedQueryException(DatawaveErrorCode.CACHED_RUNNING_QUERY_ERROR, e);\n+      log.error(qe);\n+      response.addException(qe.getBottomQueryException());\n+      throw new PreConditionFailedException(qe, response);\n+    }\n+\n+    if (null != crq) {\n+      // CachedRunningQueries may be stored under multiple keys\n+      if (crq.getQueryId() != null) {\n+        cachedRunningQueryCache.remove(owner + \"-\" + crq.getQueryId());\n+      }\n+      if (crq.getAlias() != null) {\n+        cachedRunningQueryCache.remove(owner + \"-\" + crq.getAlias());\n+      }\n+      if (crq.getView() != null) {\n+        cachedRunningQueryCache.remove(owner + \"-\" + crq.getView());\n+      }\n+      if (crq.isActivated()) {\n+        synchronized (crq) {\n+          crq.closeConnection(log);\n         }\n+        crq.getMetric().setLifecycle(QueryMetric.Lifecycle.CLOSED);\n+        if (crq.getQueryLogic().getCollectQueryMetrics() == true) {\n+          try {\n+            metrics.updateMetric(crq.getMetric());\n+          } catch (Exception e) {\n+            log.error(e.getMessage(), e);\n+          }\n+        }\n+      }\n+    }\n+    return response;\n+  }\n+\n+  private RunningQuery getQueryById(String id) throws Exception {\n+    // Find out who/what called this method\n+    Principal p = ctx.getCallerPrincipal();\n+    String owner = getOwnerFromPrincipal(p);\n+    Collection<Collection<String>> cbAuths = new HashSet<>();\n+    if (p instanceof DatawavePrincipal) {\n+      DatawavePrincipal cp = (DatawavePrincipal) p;\n+      cbAuths.addAll(cp.getAuthorizations());\n     }\n-    \n-    @RolesAllowed({\"InternalUser\"})\n-    public boolean isQueryLoading(String originalQueryId) {\n-        return CachedResultsBean.loadingQueryMap.containsKey(originalQueryId);\n+\n+    if (log.isTraceEnabled()) {\n+      log.trace(owner + \" has authorizations \" + cbAuths);\n+    }\n+\n+    RunningQuery query = runningQueryCache.get(id);\n+\n+    if (null == query) {\n+      List<Query> queries = persister.findById(id);\n+      if (null == queries || queries.isEmpty()) {\n+        throw new NotFoundQueryException(DatawaveErrorCode.NO_QUERY_OBJECT_MATCH);\n+      }\n+      if (queries.size() > 1) {\n+        throw new NotFoundQueryException(DatawaveErrorCode.TOO_MANY_QUERY_OBJECT_MATCHES);\n+      } else {\n+        Query q = queries.get(0);\n+\n+        // will throw IllegalArgumentException if not defined\n+        QueryLogic<?> logic = queryFactory.getQueryLogic(q.getQueryLogicName(), p);\n+        AccumuloConnectionFactory.Priority priority = logic.getConnectionPriority();\n+        query = new RunningQuery(metrics, null, priority, logic, q, q.getQueryAuthorizations(), p,\n+            new RunningQueryTimingImpl(queryExpirationConf,\n+                q.getPageTimeout()), executor, predictor, metricFactory);\n+        query.setActiveCall(true);\n+        // Put in the cache by id and name, we will have two copies that reference the same object\n+        runningQueryCache.put(q.getId().toString(), query);\n+      }\n+    } else {\n+      // Check to make sure that this query belongs to current user.\n+      if (!query.getSettings().getOwner().equals(owner)) {\n+        throw new UnauthorizedQueryException(DatawaveErrorCode.QUERY_OWNER_MISMATCH,\n+            MessageFormat.format(\"{0} != {1}\", owner, query.getSettings()\n+                .getOwner()));\n+      }\n     }\n-    \n-    /**\n-     * Releases resources associated with this query.\n-     *\n-     * @param queryId\n-     *            use defined id for this query\n-     *\n-     * @return datawave.webservice.result.VoidResponse\n-     * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user by specifying a chain of DNs of the identities to proxy\n-     * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n-     * @RequestHeader query-session-id session id value used for load balancing purposes. query-session-id can be placed in the request in a Cookie header or as\n-     *                a query parameter\n-     * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n-     *\n-     * @HTTP 200 success\n-     * @HTTP 500 internal server error\n-     *\n-     */\n-    @DELETE\n-    @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\"})\n-    @javax.ws.rs.Path(\"/{queryId}/close\")\n-    @Interceptors({RequiredInterceptor.class, ResponseInterceptor.class})\n-    @ClearQuerySessionId\n-    @Timed(name = \"dw.cachedr.close\", absolute = true)\n-    public VoidResponse close(@PathParam(\"queryId\") @Required(\"queryId\") String queryId) {\n-        // Find out who/what called this method\n-        Principal p = ctx.getCallerPrincipal();\n-        String owner = getOwnerFromPrincipal(p);\n-        VoidResponse response = new VoidResponse();\n-        CachedRunningQuery crq;\n+    query.setActiveCall(false);\n+    return query;\n+  }\n+\n+  /**\n+   * Set alias that this cached result can be retrieved by\n+   *\n+   * @param queryId user defined id for this query\n+   * @param alias   additional name that this query can be retrieved by\n+   * @return datawave.webservice.result.CachedResultsResponse\n+   * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user by specifying a chain of DNs of the identities to proxy\n+   * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n+   * @RequestHeader query-session-id session id value used for load balancing purposes. query-session-id can be placed in the request in a Cookie header or as\n+   * a query parameter\n+   * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n+   * @HTTP 200 success\n+   * @HTTP 401 caller is not authorized to run the query\n+   * @HTTP 412 if the query is not active\n+   * @HTTP 500 internal server error\n+   */\n+  @POST\n+  @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\"})\n+  @javax.ws.rs.Path(\"/{queryId}/setAlias\")\n+  @Interceptors({RequiredInterceptor.class, ResponseInterceptor.class})\n+  @Timed(name = \"dw.cachedr.setAlias\", absolute = true)\n+  public CachedResultsResponse setAlias(@PathParam(\"queryId\") @Required(\"queryId\") String queryId,\n+                                        @FormParam(\"alias\") @Required(\"alias\") String alias) {\n+\n+    CachedResultsResponse response = new CachedResultsResponse();\n+\n+    // Find out who/what called this method\n+    Principal p = ctx.getCallerPrincipal();\n+    String owner = getOwnerFromPrincipal(p);\n+\n+    try {\n+      CachedRunningQuery crq = null;\n+      try {\n+        // Get the CachedRunningQuery object from the cache\n         try {\n-            crq = retrieve(queryId, owner);\n+          crq = retrieve(queryId, owner);\n         } catch (IOException e) {\n-            PreConditionFailedQueryException qe = new PreConditionFailedQueryException(DatawaveErrorCode.CACHED_RUNNING_QUERY_ERROR, e);\n-            log.error(qe);\n-            response.addException(qe.getBottomQueryException());\n-            throw new PreConditionFailedException(qe, response);\n+          throw new PreConditionFailedQueryException(DatawaveErrorCode.CACHED_RESULTS_IMPORT_ERROR, e);\n         }\n-        \n-        if (null != crq) {\n-            // CachedRunningQueries may be stored under multiple keys\n-            if (crq.getQueryId() != null) {\n-                cachedRunningQueryCache.remove(owner + \"-\" + crq.getQueryId());\n-            }\n-            if (crq.getAlias() != null) {\n-                cachedRunningQueryCache.remove(owner + \"-\" + crq.getAlias());\n-            }\n-            if (crq.getView() != null) {\n-                cachedRunningQueryCache.remove(owner + \"-\" + crq.getView());\n-            }\n-            if (crq.isActivated()) {\n-                synchronized (crq) {\n-                    crq.closeConnection(log);\n-                }\n-                crq.getMetric().setLifecycle(QueryMetric.Lifecycle.CLOSED);\n-                if (crq.getQueryLogic().getCollectQueryMetrics() == true) {\n-                    try {\n-                        metrics.updateMetric(crq.getMetric());\n-                    } catch (Exception e) {\n-                        log.error(e.getMessage(), e);\n-                    }\n-                }\n-            }\n+        if (null == crq) {\n+          throw new PreConditionFailedQueryException(DatawaveErrorCode.QUERY_NOT_CACHED);\n         }\n-        return response;\n-    }\n-    \n-    private RunningQuery getQueryById(String id) throws Exception {\n-        // Find out who/what called this method\n-        Principal p = ctx.getCallerPrincipal();\n-        String owner = getOwnerFromPrincipal(p);\n-        Collection<Collection<String>> cbAuths = new HashSet<>();\n-        if (p instanceof DatawavePrincipal) {\n-            DatawavePrincipal cp = (DatawavePrincipal) p;\n-            cbAuths.addAll(cp.getAuthorizations());\n+        if (!crq.getUser().equals(owner)) {\n+          throw new UnauthorizedQueryException(DatawaveErrorCode.QUERY_OWNER_MISMATCH,\n+              MessageFormat.format(\"{0} != {1}\", crq.getUser(), owner));\n         }\n-        \n-        if (log.isTraceEnabled()) {\n-            log.trace(owner + \" has authorizations \" + cbAuths);\n+\n+        synchronized (crq) {\n+\n+          if (alias != null) {\n+\n+            crq.setAlias(alias);\n+            persist(crq, owner);\n+          }\n+\n+          response = new CachedResultsResponse();\n+          response.setOriginalQueryId(crq.getOriginalQueryId());\n+          response.setQueryId(crq.getQueryId());\n+          response.setViewName(crq.getView());\n+          response.setAlias(crq.getAlias());\n+          response.setTotalRows(crq.getTotalRows());\n+\n         }\n-        \n-        RunningQuery query = runningQueryCache.get(id);\n-        \n-        if (null == query) {\n-            List<Query> queries = persister.findById(id);\n-            if (null == queries || queries.isEmpty())\n-                throw new NotFoundQueryException(DatawaveErrorCode.NO_QUERY_OBJECT_MATCH);\n-            if (queries.size() > 1)\n-                throw new NotFoundQueryException(DatawaveErrorCode.TOO_MANY_QUERY_OBJECT_MATCHES);\n-            else {\n-                Query q = queries.get(0);\n-                \n-                // will throw IllegalArgumentException if not defined\n-                QueryLogic<?> logic = queryFactory.getQueryLogic(q.getQueryLogicName(), p);\n-                AccumuloConnectionFactory.Priority priority = logic.getConnectionPriority();\n-                query = new RunningQuery(metrics, null, priority, logic, q, q.getQueryAuthorizations(), p, new RunningQueryTimingImpl(queryExpirationConf,\n-                                q.getPageTimeout()), executor, predictor, metricFactory);\n-                query.setActiveCall(true);\n-                // Put in the cache by id and name, we will have two copies that reference the same object\n-                runningQueryCache.put(q.getId().toString(), query);\n-            }\n-        } else {\n-            // Check to make sure that this query belongs to current user.\n-            if (!query.getSettings().getOwner().equals(owner)) {\n-                throw new UnauthorizedQueryException(DatawaveErrorCode.QUERY_OWNER_MISMATCH, MessageFormat.format(\"{0} != {1}\", owner, query.getSettings()\n-                                .getOwner()));\n-            }\n+\n+        return response;\n+      } finally {\n+        // Push metrics\n+        if (null != crq && crq.getQueryLogic().getCollectQueryMetrics() == true) {\n+\n+          try {\n+            metrics.updateMetric(crq.getMetric());\n+          } catch (Exception e1) {\n+            log.error(\"Error updating metrics\", e1);\n+          }\n         }\n-        query.setActiveCall(false);\n-        return query;\n+      }\n+    } catch (Exception e) {\n+      QueryException qe = new QueryException(DatawaveErrorCode.CACHED_QUERY_TRANSACTION_ERROR, e);\n+      log.error(qe);\n+      response.addException(qe.getBottomQueryException());\n+      int statusCode = qe.getBottomQueryException().getStatusCode();\n+      throw new DatawaveWebApplicationException(qe, response, statusCode);\n+    }\n+  }\n+\n+  public void persist(CachedRunningQuery crq, String owner) {\n+\n+    synchronized (this) {\n+      log.debug(\"persisting cachedRunningQuery \" + crq.getQueryId() + \" to cache with status \" + crq.getStatus());\n+      this.cachedRunningQueryCache.remove(owner + \"-\" + crq.getQueryId());\n+      this.cachedRunningQueryCache.remove(owner + \"-\" + crq.getAlias());\n+      this.cachedRunningQueryCache.remove(owner + \"-\" + crq.getView());\n+\n+      this.cachedRunningQueryCache.put(owner + \"-\" + crq.getQueryId(), crq);\n+      this.cachedRunningQueryCache.put(owner + \"-\" + crq.getAlias(), crq);\n+      this.cachedRunningQueryCache.put(owner + \"-\" + crq.getView(), crq);\n+      log.debug(\"persisting cachedRunningQuery \" + crq.getQueryId() + \" to database with status \" + crq.getStatus());\n+      crq.saveToDatabase(ctx.getCallerPrincipal(), metricFactory);\n     }\n-    \n-    /**\n-     * Set alias that this cached result can be retrieved by\n-     *\n-     * @param queryId\n-     *            user defined id for this query\n-     * @param alias\n-     *            additional name that this query can be retrieved by\n-     * @return datawave.webservice.result.CachedResultsResponse\n-     * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user by specifying a chain of DNs of the identities to proxy\n-     * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n-     * @RequestHeader query-session-id session id value used for load balancing purposes. query-session-id can be placed in the request in a Cookie header or as\n-     *                a query parameter\n-     * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n-     *\n-     * @HTTP 200 success\n-     * @HTTP 401 caller is not authorized to run the query\n-     * @HTTP 412 if the query is not active\n-     * @HTTP 500 internal server error\n-     */\n-    @POST\n-    @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\"})\n-    @javax.ws.rs.Path(\"/{queryId}/setAlias\")\n-    @Interceptors({RequiredInterceptor.class, ResponseInterceptor.class})\n-    @Timed(name = \"dw.cachedr.setAlias\", absolute = true)\n-    public CachedResultsResponse setAlias(@PathParam(\"queryId\") @Required(\"queryId\") String queryId, @FormParam(\"alias\") @Required(\"alias\") String alias) {\n-        \n-        CachedResultsResponse response = new CachedResultsResponse();\n-        \n-        // Find out who/what called this method\n-        Principal p = ctx.getCallerPrincipal();\n-        String owner = getOwnerFromPrincipal(p);\n-        \n+\n+  }\n+\n+  public CachedRunningQuery retrieve(String id, String owner) throws IOException {\n+\n+    CachedRunningQuery crq;\n+\n+    synchronized (CachedResultsBean.class) {\n+      try {\n+        log.debug(\"retrieving cachedRunningQuery \" + id + \" from cache\");\n+        crq = this.cachedRunningQueryCache.get(owner + \"-\" + id);\n+        if (crq != null) {\n+          log.debug(\"retrieved cachedRunningQuery \" + id + \" from cache with status \" + crq.getStatus());\n+        }\n+      } catch (Exception e) {\n+        log.error(\"Caught attempting to retrieve cached results from infinispan cache: \" + e.getMessage(), e);\n+        throw new IOException(\n+            e.getClass().getName() + \" caught attempting to retrieve cached results from infinispan cache\", e);\n+      }\n+\n+      log.debug(\"Details not in cache, checking the database\");\n+      if (crq == null) {\n+\n         try {\n-            CachedRunningQuery crq = null;\n-            try {\n-                // Get the CachedRunningQuery object from the cache\n-                try {\n-                    crq = retrieve(queryId, owner);\n-                } catch (IOException e) {\n-                    throw new PreConditionFailedQueryException(DatawaveErrorCode.CACHED_RESULTS_IMPORT_ERROR, e);\n-                }\n-                if (null == crq)\n-                    throw new PreConditionFailedQueryException(DatawaveErrorCode.QUERY_NOT_CACHED);\n-                if (!crq.getUser().equals(owner)) {\n-                    throw new UnauthorizedQueryException(DatawaveErrorCode.QUERY_OWNER_MISMATCH, MessageFormat.format(\"{0} != {1}\", crq.getUser(), owner));\n-                }\n-                \n-                synchronized (crq) {\n-                    \n-                    if (alias != null) {\n-                        \n-                        crq.setAlias(alias);\n-                        persist(crq, owner);\n-                    }\n-                    \n-                    response = new CachedResultsResponse();\n-                    response.setOriginalQueryId(crq.getOriginalQueryId());\n-                    response.setQueryId(crq.getQueryId());\n-                    response.setViewName(crq.getView());\n-                    response.setAlias(crq.getAlias());\n-                    response.setTotalRows(crq.getTotalRows());\n-                    \n-                }\n-                \n-                return response;\n-            } finally {\n-                // Push metrics\n-                if (null != crq && crq.getQueryLogic().getCollectQueryMetrics() == true) {\n-                    \n-                    try {\n-                        metrics.updateMetric(crq.getMetric());\n-                    } catch (Exception e1) {\n-                        log.error(\"Error updating metrics\", e1);\n-                    }\n-                }\n-            }\n+          log.debug(\"retrieving cachedRunningQuery \" + id + \" from database\");\n+          crq = CachedRunningQuery.retrieveFromDatabase(id, ctx.getCallerPrincipal(), metricFactory);\n+          if (crq != null) {\n+            log.debug(\"retrieved cachedRunningQuery \" + id + \" from database with status \" + crq.getStatus());\n+            this.cachedRunningQueryCache.put(owner + \"-\" + id, crq);\n+          }\n         } catch (Exception e) {\n-            QueryException qe = new QueryException(DatawaveErrorCode.CACHED_QUERY_TRANSACTION_ERROR, e);\n-            log.error(qe);\n-            response.addException(qe.getBottomQueryException());\n-            int statusCode = qe.getBottomQueryException().getStatusCode();\n-            throw new DatawaveWebApplicationException(qe, response, statusCode);\n+          throw new IOException(\n+              e.getClass().getName() + \" caught attempting to retrieve cached results state from database\", e);\n         }\n+      }\n     }\n-    \n-    public void persist(CachedRunningQuery crq, String owner) {\n-        \n-        synchronized (this) {\n-            log.debug(\"persisting cachedRunningQuery \" + crq.getQueryId() + \" to cache with status \" + crq.getStatus());\n-            this.cachedRunningQueryCache.remove(owner + \"-\" + crq.getQueryId());\n-            this.cachedRunningQueryCache.remove(owner + \"-\" + crq.getAlias());\n-            this.cachedRunningQueryCache.remove(owner + \"-\" + crq.getView());\n-            \n-            this.cachedRunningQueryCache.put(owner + \"-\" + crq.getQueryId(), crq);\n-            this.cachedRunningQueryCache.put(owner + \"-\" + crq.getAlias(), crq);\n-            this.cachedRunningQueryCache.put(owner + \"-\" + crq.getView(), crq);\n-            log.debug(\"persisting cachedRunningQuery \" + crq.getQueryId() + \" to database with status \" + crq.getStatus());\n-            crq.saveToDatabase(ctx.getCallerPrincipal(), metricFactory);\n+\n+    if (null == crq) {\n+      try {\n+        log.debug(\"Details not in database, checking for exported table in HDFS\");\n+        String hdfsUri = cachedResultsConfiguration.getParameters().get(\"HDFS_URI\");\n+        String hdfsDir = cachedResultsConfiguration.getParameters().get(\"HDFS_DIR\");\n+        if (log.isDebugEnabled()) {\n+          log.debug(\"HDFS uri: \" + hdfsUri + \", dir: \" + hdfsDir);\n         }\n-        \n-    }\n-    \n-    public CachedRunningQuery retrieve(String id, String owner) throws IOException {\n-        \n-        CachedRunningQuery crq;\n-        \n-        synchronized (CachedResultsBean.class) {\n-            try {\n-                log.debug(\"retrieving cachedRunningQuery \" + id + \" from cache\");\n-                crq = this.cachedRunningQueryCache.get(owner + \"-\" + id);\n-                if (crq != null) {\n-                    log.debug(\"retrieved cachedRunningQuery \" + id + \" from cache with status \" + crq.getStatus());\n-                }\n-            } catch (Exception e) {\n-                log.error(\"Caught attempting to retrieve cached results from infinispan cache: \" + e.getMessage(), e);\n-                throw new IOException(e.getClass().getName() + \" caught attempting to retrieve cached results from infinispan cache\", e);\n-            }\n-            \n-            log.debug(\"Details not in cache, checking the database\");\n-            if (crq == null) {\n-                \n+        if (!StringUtils.isEmpty(hdfsUri) && !StringUtils.isEmpty(hdfsDir) && (null != importFileUrl)) {\n+          // Then we didn't find it in the database. Try looking in HDFS for an export of the data\n+          // from another instance.\n+          org.apache.hadoop.conf.Configuration conf = new org.apache.hadoop.conf.Configuration();\n+          conf.set(\"fs.defaultFS\", hdfsUri);\n+          final FileSystem fs = FileSystem.get(conf);\n+          Path crPath = new Path(hdfsDir);\n+          Path userPath = new Path(crPath, owner);\n+          if (log.isDebugEnabled()) {\n+            log.debug(\"Looking for exported cached for \" + id + \" results in: \" + userPath);\n+          }\n+          if (fs.exists(userPath)) {\n+            // Find any directory that contains the id as a .alias, .view, or .queryId file\n+            ArrayList<FileStatus> list = new ArrayList<>();\n+            recursiveList(fs, userPath, id, list);\n+            if (null != list && !list.isEmpty()) {\n+              for (FileStatus f : list) {\n+                // Get the parent of the matching file, this will be the directory that contains\n+                // the table dump\n+                Path tableDirectory = f.getPath().getParent();\n+                ProcessBuilder builder = new ProcessBuilder(this.importFileUrl.getPath(), tableDirectory.toString());\n+                builder.redirectErrorStream(false);\n+                Process process = builder.start();\n+                InputStream stdout = process.getInputStream();\n+                final BufferedReader outReader = new BufferedReader(new InputStreamReader(stdout));\n+                InputStream stderr = process.getErrorStream();\n+                final BufferedReader errReader = new BufferedReader(new InputStreamReader(stderr));\n                 try {\n-                    log.debug(\"retrieving cachedRunningQuery \" + id + \" from database\");\n-                    crq = CachedRunningQuery.retrieveFromDatabase(id, ctx.getCallerPrincipal(), metricFactory);\n-                    if (crq != null) {\n-                        log.debug(\"retrieved cachedRunningQuery \" + id + \" from database with status \" + crq.getStatus());\n-                        this.cachedRunningQueryCache.put(owner + \"-\" + id, crq);\n+                  Thread outReadThread = new Thread(() -> {\n+                    try {\n+                      String line = outReader.readLine();\n+                      while (line != null) {\n+                        log.info(line);\n+                        line = outReader.readLine();\n+                      }\n+                    } catch (IOException e) {\n+                      log.error(\"Error in readThread\", e);\n                     }\n-                } catch (Exception e) {\n-                    throw new IOException(e.getClass().getName() + \" caught attempting to retrieve cached results state from database\", e);\n-                }\n-            }\n-        }\n-        \n-        if (null == crq) {\n-            try {\n-                log.debug(\"Details not in database, checking for exported table in HDFS\");\n-                String hdfsUri = cachedResultsConfiguration.getParameters().get(\"HDFS_URI\");\n-                String hdfsDir = cachedResultsConfiguration.getParameters().get(\"HDFS_DIR\");\n-                if (log.isDebugEnabled())\n-                    log.debug(\"HDFS uri: \" + hdfsUri + \", dir: \" + hdfsDir);\n-                if (!StringUtils.isEmpty(hdfsUri) && !StringUtils.isEmpty(hdfsDir) && (null != importFileUrl)) {\n-                    // Then we didn't find it in the database. Try looking in HDFS for an export of the data\n-                    // from another instance.\n-                    org.apache.hadoop.conf.Configuration conf = new org.apache.hadoop.conf.Configuration();\n-                    conf.set(\"fs.defaultFS\", hdfsUri);\n-                    final FileSystem fs = FileSystem.get(conf);\n-                    Path crPath = new Path(hdfsDir);\n-                    Path userPath = new Path(crPath, owner);\n-                    if (log.isDebugEnabled())\n-                        log.debug(\"Looking for exported cached for \" + id + \" results in: \" + userPath);\n-                    if (fs.exists(userPath)) {\n-                        // Find any directory that contains the id as a .alias, .view, or .queryId file\n-                        ArrayList<FileStatus> list = new ArrayList<>();\n-                        recursiveList(fs, userPath, id, list);\n-                        if (null != list && !list.isEmpty()) {\n-                            for (FileStatus f : list) {\n-                                // Get the parent of the matching file, this will be the directory that contains\n-                                // the table dump\n-                                Path tableDirectory = f.getPath().getParent();\n-                                ProcessBuilder builder = new ProcessBuilder(this.importFileUrl.getPath(), tableDirectory.toString());\n-                                builder.redirectErrorStream(false);\n-                                Process process = builder.start();\n-                                InputStream stdout = process.getInputStream();\n-                                final BufferedReader outReader = new BufferedReader(new InputStreamReader(stdout));\n-                                InputStream stderr = process.getErrorStream();\n-                                final BufferedReader errReader = new BufferedReader(new InputStreamReader(stderr));\n-                                try {\n-                                    Thread outReadThread = new Thread(() -> {\n-                                        try {\n-                                            String line = outReader.readLine();\n-                                            while (line != null) {\n-                                                log.info(line);\n-                                                line = outReader.readLine();\n-                                            }\n-                                        } catch (IOException e) {\n-                                            log.error(\"Error in readThread\", e);\n-                                        }\n-                                    });\n-                                    Thread errReadThread = new Thread(() -> {\n-                                        try {\n-                                            String line = errReader.readLine();\n-                                            while (line != null) {\n-                                                log.error(line);\n-                                                line = errReader.readLine();\n-                                            }\n-                                        } catch (IOException e) {\n-                                            log.error(\"Error in readThread\", e);\n-                                        }\n-                                    });\n-                                    outReadThread.setName(id + \"-StdOutReadThread\");\n-                                    outReadThread.start();\n-                                    errReadThread.setName(id + \"-StdErrReadThread\");\n-                                    errReadThread.start();\n-                                    log.info(\"Importing cached results from: \" + tableDirectory);\n-                                    int exitVal = process.waitFor();\n-                                    if (0 != exitVal) {\n-                                        throw new IOException(\"Error importing cached results data from: \" + tableDirectory + \". Exit value: \" + exitVal);\n-                                    }\n-                                    outReadThread.join();\n-                                    errReadThread.join();\n-                                } catch (InterruptedException e) {\n-                                    log.error(\"Thread interrupted waiting for import to finish, killing import process\");\n-                                    process.destroy();\n-                                } finally {\n-                                    outReader.close();\n-                                    errReader.close();\n-                                }\n-                                crq = CachedRunningQuery.retrieveFromDatabase(id, ctx.getCallerPrincipal(), metricFactory);\n-                                if (crq != null) {\n-                                    break;\n-                                }\n-                            }\n-                        } else {\n-                            // No matching table dumps for this user\n-                        }\n-                    } else {\n-                        // Does not exist\n+                  });\n+                  Thread errReadThread = new Thread(() -> {\n+                    try {\n+                      String line = errReader.readLine();\n+                      while (line != null) {\n+                        log.error(line);\n+                        line = errReader.readLine();\n+                      }\n+                    } catch (IOException e) {\n+                      log.error(\"Error in readThread\", e);\n                     }\n-                } else {\n-                    log.warn(\"HDFS Parameters not set up, will not try to import data\");\n+                  });\n+                  outReadThread.setName(id + \"-StdOutReadThread\");\n+                  outReadThread.start();\n+                  errReadThread.setName(id + \"-StdErrReadThread\");\n+                  errReadThread.start();\n+                  log.info(\"Importing cached results from: \" + tableDirectory);\n+                  int exitVal = process.waitFor();\n+                  if (0 != exitVal) {\n+                    throw new IOException(\n+                        \"Error importing cached results data from: \" + tableDirectory + \". Exit value: \" + exitVal);\n+                  }\n+                  outReadThread.join();\n+                  errReadThread.join();\n+                } catch (InterruptedException e) {\n+                  log.error(\"Thread interrupted waiting for import to finish, killing import process\");\n+                  process.destroy();\n+                } finally {\n+                  outReader.close();\n+                  errReader.close();\n                 }\n+                crq = CachedRunningQuery.retrieveFromDatabase(id, ctx.getCallerPrincipal(), metricFactory);\n                 if (crq != null) {\n-                    synchronized (CachedResultsBean.class) {\n-                        this.cachedRunningQueryCache.put(owner + \"-\" + id, crq);\n-                    }\n+                  break;\n                 }\n-            } catch (Exception e) {\n-                throw new IOException(e.getClass().getName() + \" caught attempting to retrieve cached results state from hdfs\", e);\n+              }\n+            } else {\n+              // No matching table dumps for this user\n             }\n+          } else {\n+            // Does not exist\n+          }\n+        } else {\n+          log.warn(\"HDFS Parameters not set up, will not try to import data\");\n         }\n-        return crq;\n-    }\n-    \n-    private void recursiveList(FileSystem fs, Path p, String id, ArrayList<FileStatus> results) throws IOException {\n-        if (log.isDebugEnabled())\n-            log.debug(\"Checking path: \" + p.getName());\n-        FileStatus[] list = fs.listStatus(p);\n-        if (null != list && list.length > 0) {\n-            for (FileStatus stat : list) {\n-                if (stat.isDirectory()) {\n-                    log.debug(stat.getPath().getName() + \" is a directory\");\n-                    recursiveList(fs, stat.getPath(), id, results);\n-                } else {\n-                    log.debug(stat.getPath().getName() + \" is not a directory\");\n-                    if (stat.getPath().getName().equals(id + \".alias\") || stat.getPath().getName().equals(id + \".view\")\n-                                    || stat.getPath().getName().equals(id + \".queryId\")) {\n-                        results.add(stat);\n-                    } else {\n-                        log.debug(stat.getPath().getName() + \" does not match filter\");\n-                    }\n-                }\n-            }\n+        if (crq != null) {\n+          synchronized (CachedResultsBean.class) {\n+            this.cachedRunningQueryCache.put(owner + \"-\" + id, crq);\n+          }\n         }\n+      } catch (Exception e) {\n+        throw new IOException(e.getClass().getName() + \" caught attempting to retrieve cached results state from hdfs\",\n+            e);\n+      }\n     }\n-    \n-    public void persistByQueryId(String queryId, String alias, String owner, CachedRunningQuery.Status status, String statusMessage, boolean useCache)\n-                    throws IOException {\n-        \n-        CachedRunningQuery crq = null;\n-        \n-        synchronized (CachedResultsBean.class) {\n-            log.debug(\"persisting cachedRunningQuery \" + queryId + \" to cache with status \" + status);\n-            if (useCache) {\n-                crq = retrieve(queryId, owner);\n-            }\n-            \n-            if (crq != null) {\n-                crq.setStatus(status);\n-                crq.setStatusMessage(statusMessage);\n-                \n-                this.cachedRunningQueryCache.remove(owner + \"-\" + crq.getQueryId());\n-                this.cachedRunningQueryCache.remove(owner + \"-\" + crq.getAlias());\n-                this.cachedRunningQueryCache.remove(owner + \"-\" + crq.getView());\n-                \n-                this.cachedRunningQueryCache.put(owner + \"-\" + crq.getQueryId(), crq);\n-                this.cachedRunningQueryCache.put(owner + \"-\" + crq.getAlias(), crq);\n-                this.cachedRunningQueryCache.put(owner + \"-\" + crq.getView(), crq);\n-            }\n-            \n-            log.debug(\"persisting cachedRunningQuery \" + queryId + \" to database with status \" + status);\n-            CachedRunningQuery.saveToDatabaseByQueryId(queryId, alias, owner, status, statusMessage);\n-        }\n+    return crq;\n+  }\n+\n+  private void recursiveList(FileSystem fs, Path p, String id, ArrayList<FileStatus> results) throws IOException {\n+    if (log.isDebugEnabled()) {\n+      log.debug(\"Checking path: \" + p.getName());\n     }\n-    \n-    protected boolean createView(String tableName, String viewName, Connection con, boolean viewCreated, Map<String,Integer> fieldMap) throws SQLException {\n-        CachedResultsParameters.validate(tableName);\n-        CachedResultsParameters.validate(viewName);\n-        StringBuilder viewCols = new StringBuilder();\n-        StringBuilder tableCols = new StringBuilder();\n-        viewCols.append(BASE_COLUMNS);\n-        tableCols.append(BASE_COLUMNS);\n-        String sep = COMMA;\n-        for (Entry<String,Integer> e : fieldMap.entrySet()) {\n-            viewCols.append(sep).append(\"`\").append(e.getKey()).append(\"`\");\n-            tableCols.append(sep).append(FIELD).append(e.getValue() - CacheableQueryRow.getFixedColumnSet().size() - 1);\n-        }\n-        \n-        StringBuilder view = new StringBuilder();\n-        try {\n-            view.append(\"CREATE VIEW \").append(viewName).append(\"(\");\n-            view.append(viewCols);\n-            view.append(\") AS SELECT \").append(tableCols);\n-            view.append(\" FROM \").append(tableName);\n-            if (log.isTraceEnabled()) {\n-                log.trace(\"Creating view using sql: \" + view);\n-            }\n-            Statement viewStmt = con.createStatement();\n-            viewStmt.execute(view.toString());\n-            viewStmt.close();\n-            viewCreated = true;\n-        } catch (SQLException e) {\n-            log.error(\"Error creating view with sql: \" + view, e);\n-            throw e;\n+    FileStatus[] list = fs.listStatus(p);\n+    if (null != list && list.length > 0) {\n+      for (FileStatus stat : list) {\n+        if (stat.isDirectory()) {\n+          log.debug(stat.getPath().getName() + \" is a directory\");\n+          recursiveList(fs, stat.getPath(), id, results);\n+        } else {\n+          log.debug(stat.getPath().getName() + \" is not a directory\");\n+          if (stat.getPath().getName().equals(id + \".alias\") || stat.getPath().getName().equals(id + \".view\")\n+              || stat.getPath().getName().equals(id + \".queryId\")) {\n+            results.add(stat);\n+          } else {\n+            log.debug(stat.getPath().getName() + \" does not match filter\");\n+          }\n         }\n-        return viewCreated;\n+      }\n     }\n-    \n-    private void addQueryToTrackingMap(Map<String,String> trackingMap, Query q) {\n-        \n-        if (trackingMap == null || q == null) {\n-            return;\n-        }\n-        \n-        if (q.getOwner() != null) {\n-            trackingMap.put(\"query.user\", q.getOwner());\n-        }\n-        if (q.getId() != null) {\n-            trackingMap.put(\"query.id\", q.getId().toString());\n-        }\n-        if (q.getId() != null) {\n-            trackingMap.put(\"query.query\", q.getQuery());\n-        }\n+  }\n+\n+  public void persistByQueryId(String queryId, String alias, String owner, CachedRunningQuery.Status status,\n+                               String statusMessage, boolean useCache)\n+      throws IOException {\n+\n+    CachedRunningQuery crq = null;\n+\n+    synchronized (CachedResultsBean.class) {\n+      log.debug(\"persisting cachedRunningQuery \" + queryId + \" to cache with status \" + status);\n+      if (useCache) {\n+        crq = retrieve(queryId, owner);\n+      }\n+\n+      if (crq != null) {\n+        crq.setStatus(status);\n+        crq.setStatusMessage(statusMessage);\n+\n+        this.cachedRunningQueryCache.remove(owner + \"-\" + crq.getQueryId());\n+        this.cachedRunningQueryCache.remove(owner + \"-\" + crq.getAlias());\n+        this.cachedRunningQueryCache.remove(owner + \"-\" + crq.getView());\n+\n+        this.cachedRunningQueryCache.put(owner + \"-\" + crq.getQueryId(), crq);\n+        this.cachedRunningQueryCache.put(owner + \"-\" + crq.getAlias(), crq);\n+        this.cachedRunningQueryCache.put(owner + \"-\" + crq.getView(), crq);\n+      }\n+\n+      log.debug(\"persisting cachedRunningQuery \" + queryId + \" to database with status \" + status);\n+      CachedRunningQuery.saveToDatabaseByQueryId(queryId, alias, owner, status, statusMessage);\n+    }\n+  }\n+\n+  protected boolean createView(String tableName, String viewName, Connection con, boolean viewCreated,\n+                               Map<String, Integer> fieldMap) throws SQLException {\n+    CachedResultsParameters.validate(tableName);\n+    CachedResultsParameters.validate(viewName);\n+    StringBuilder viewCols = new StringBuilder();\n+    StringBuilder tableCols = new StringBuilder();\n+    viewCols.append(BASE_COLUMNS);\n+    tableCols.append(BASE_COLUMNS);\n+    String sep = COMMA;\n+    for (Entry<String, Integer> e : fieldMap.entrySet()) {\n+      viewCols.append(sep).append(\"`\").append(e.getKey()).append(\"`\");\n+      tableCols.append(sep).append(FIELD).append(e.getValue() - CacheableQueryRow.getFixedColumnSet().size() - 1);\n+    }\n+\n+    StringBuilder view = new StringBuilder();\n+    try {\n+      view.append(\"CREATE VIEW \").append(viewName).append(\"(\");\n+      view.append(viewCols);\n+      view.append(\") AS SELECT \").append(tableCols);\n+      view.append(\" FROM \").append(tableName);\n+      if (log.isTraceEnabled()) {\n+        log.trace(\"Creating view using sql: \" + view);\n+      }\n+      Statement viewStmt = con.createStatement();\n+      viewStmt.execute(view.toString());\n+      viewStmt.close();\n+      viewCreated = true;\n+    } catch (SQLException e) {\n+      log.error(\"Error creating view with sql: \" + view, e);\n+      throw e;\n     }\n-    \n-    public QueryPredictor getPredictor() {\n-        return predictor;\n+    return viewCreated;\n+  }\n+\n+  private void addQueryToTrackingMap(Map<String, String> trackingMap, Query q) {\n+\n+    if (trackingMap == null || q == null) {\n+      return;\n+    }\n+\n+    if (q.getOwner() != null) {\n+      trackingMap.put(\"query.user\", q.getOwner());\n     }\n-    \n-    public void setPredictor(QueryPredictor predictor) {\n-        this.predictor = predictor;\n+    if (q.getId() != null) {\n+      trackingMap.put(\"query.id\", q.getId().toString());\n     }\n-    \n+    if (q.getId() != null) {\n+      trackingMap.put(\"query.query\", q.getQuery());\n+    }\n+  }\n+\n+  public QueryPredictor getPredictor() {\n+    return predictor;\n+  }\n+\n+  public void setPredictor(QueryPredictor predictor) {\n+    this.predictor = predictor;\n+  }\n+\n }\n",
            "diff_size": 3512
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "131",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "131",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ],
    "repaired_by": [],
    "not_repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}