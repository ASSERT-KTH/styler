{
    "project_name": "wso2-attic-commons",
    "error_id": "189",
    "information": {
        "errors": [
            {
                "line": "114",
                "severity": "error",
                "message": "Line is longer than 120 characters (found 127).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": "\t * @param copy if true then the libraries are copied to the given project directory.\n\t */\n\tpublic IClasspathEntry[] getLibraryClasspaths(IProject project, List<String> libs, boolean copy) throws CoreException {\n        if (libs != null && libs.isEmpty())\n            return new IClasspathEntry[0];\n        Bundle bundle = Platform.getBundle(BUNDLE_ID);",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/189/PluginLibrary.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler/189/PluginLibrary.java\nindex df3e890e65d..9712ec0ddd1 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/189/PluginLibrary.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler/189/PluginLibrary.java\n@@ -111,8 +111,8 @@ public class PluginLibrary {\n \t * @param list of patterns that matches an actual library. null implies all runtime libraries.\n \t * @param copy if true then the libraries are copied to the given project directory.\n \t */\n-\tpublic IClasspathEntry[] getLibraryClasspaths(IProject project, List<String> libs, boolean copy) throws CoreException {\n-        if (libs != null && libs.isEmpty())\n+ public IClasspathEntry[] getLibraryClasspaths(IProject project, List<String> libs, boolean copy) throws CoreException {\n+     if (libs != null && libs.isEmpty())\n             return new IClasspathEntry[0];\n         Bundle bundle = Platform.getBundle(BUNDLE_ID);\n         List<String> libraries = getRuntimeLibraries(bundle);\n",
            "diff_size": 2
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/189/PluginLibrary.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/intellij/189/PluginLibrary.java\nindex df3e890e65d..c5210e1f759 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/189/PluginLibrary.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/intellij/189/PluginLibrary.java\n@@ -13,6 +13,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+\n package org.apache.openjpa.eclipse;\n \n import java.io.File;\n@@ -49,221 +50,234 @@ import org.osgi.framework.Constants;\n \n /**\n  * Locates the required runtime class libraries for OpenJPA by looking up the Bundle manifest.\n- * These libraries are embedded in the plugin jar and hence can not directly be used as \n+ * These libraries are embedded in the plugin jar and hence can not directly be used as\n  * classpath entry for a user project. Hence these runtime libaries are read from the\n  * plugin jar and copied into the user project.\n- *  \n- * @author Pinaki Poddar\n  *\n+ * @author Pinaki Poddar\n  */\n public class PluginLibrary {\n-\t/**\n-\t * This identifier must match the <code>Bundle.Symbolic-Name</code> of the root manifest.\n-\t */\n-\tpublic static final String BUNDLE_ID = \"org.apache.openjpa\"; \n-\t\n-\t/**\n-\t * Map of library key to marker class name. Used to determine if a specific library\n-\t * is visible to the user's project's classloader. \n-\t */\n-\tprivate static final Map<String,String> probes = new HashMap<String, String>();\n-\tstatic {\n-        probes.put(\"commons-collections\", \"org.apache.commons.collections.ArrayStack\");\n-        probes.put(\"commons-lang\",        \"org.apache.commons.lang.ObjectUtils\");\n-        probes.put(\"geronimo-jms\",        \"javax.jms.Connection\");\n-        probes.put(\"geronimo-jpa\",        \"javax.persistence.Entity\");\n-        probes.put(\"geronimo-jta\",        \"javax.transaction.Transaction\");\n-        probes.put(\"openjpa\",             \"org.apache.openjpa.conf.OpenJPAVersion\");\n-        probes.put(\"serp\",                \"serp.bytecode.BCClass\");\n-\t}\n-\t\n-\tpublic String getDescription() {\n-        Bundle bundle = Platform.getBundle(BUNDLE_ID);\n-        Object desc = bundle.getHeaders().get(Constants.BUNDLE_DESCRIPTION);\n-        return desc == null ? \"OpenJPA Eclipse Plugin Bundle\" : desc.toString();\n-\t}\n-\t\n-    /**\n-     * Reads the given bundle manifest for the names of libraries required for \n-     * OpenJPA runtime.\n-     */\n-    private List<String> getRuntimeLibraries(Bundle bundle) {\n-        List<String> result = new ArrayList<String>();\n-        try {\n-            String cpEntries = (String) bundle.getHeaders().get(Constants.BUNDLE_CLASSPATH);\n-            if (cpEntries == null)\n-                cpEntries = \".\";\n-            ManifestElement[] elements = ManifestElement.parseHeader(Constants.BUNDLE_CLASSPATH, cpEntries);\n-            for (int i = 0; i < elements.length; ++i) {\n-                ManifestElement element = elements[i];\n-                String value = element.getValue();\n-                result.add(value);\n-            }\n-        } catch (BundleException e) {\n-            e.printStackTrace();\n+  /**\n+   * This identifier must match the <code>Bundle.Symbolic-Name</code> of the root manifest.\n+   */\n+  public static final String BUNDLE_ID = \"org.apache.openjpa\";\n+\n+  /**\n+   * Map of library key to marker class name. Used to determine if a specific library\n+   * is visible to the user's project's classloader.\n+   */\n+  private static final Map<String, String> probes = new HashMap<String, String>();\n+\n+  static {\n+    probes.put(\"commons-collections\", \"org.apache.commons.collections.ArrayStack\");\n+    probes.put(\"commons-lang\", \"org.apache.commons.lang.ObjectUtils\");\n+    probes.put(\"geronimo-jms\", \"javax.jms.Connection\");\n+    probes.put(\"geronimo-jpa\", \"javax.persistence.Entity\");\n+    probes.put(\"geronimo-jta\", \"javax.transaction.Transaction\");\n+    probes.put(\"openjpa\", \"org.apache.openjpa.conf.OpenJPAVersion\");\n+    probes.put(\"serp\", \"serp.bytecode.BCClass\");\n+  }\n+\n+  public String getDescription() {\n+    Bundle bundle = Platform.getBundle(BUNDLE_ID);\n+    Object desc = bundle.getHeaders().get(Constants.BUNDLE_DESCRIPTION);\n+    return desc == null ? \"OpenJPA Eclipse Plugin Bundle\" : desc.toString();\n+  }\n+\n+  /**\n+   * Reads the given bundle manifest for the names of libraries required for\n+   * OpenJPA runtime.\n+   */\n+  private List<String> getRuntimeLibraries(Bundle bundle) {\n+    List<String> result = new ArrayList<String>();\n+    try {\n+      String cpEntries = (String) bundle.getHeaders().get(Constants.BUNDLE_CLASSPATH);\n+      if (cpEntries == null) {\n+        cpEntries = \".\";\n+      }\n+      ManifestElement[] elements = ManifestElement.parseHeader(Constants.BUNDLE_CLASSPATH, cpEntries);\n+      for (int i = 0; i < elements.length; ++i) {\n+        ManifestElement element = elements[i];\n+        String value = element.getValue();\n+        result.add(value);\n+      }\n+    } catch (BundleException e) {\n+      e.printStackTrace();\n+    }\n+    return result;\n+  }\n+\n+  /**\n+   * Gets the runtime libraries required for this bundle to the given project.\n+   *\n+   * @param list of patterns that matches an actual library. null implies all runtime libraries.\n+   * @param copy if true then the libraries are copied to the given project directory.\n+   */\n+  public IClasspathEntry[] getLibraryClasspaths(IProject project, List<String> libs, boolean copy)\n+    throws CoreException {\n+    if (libs != null && libs.isEmpty()) {\n+      return new IClasspathEntry[0];\n+    }\n+    Bundle bundle = Platform.getBundle(BUNDLE_ID);\n+    List<String> libraries = getRuntimeLibraries(bundle);\n+    List<IClasspathEntry> entries = new ArrayList<IClasspathEntry>();\n+    ProgressMonitorDialog progress = null;\n+    for (String lib : libraries) {\n+      try {\n+        if (\".\".equals(lib)) {\n+          continue;\n+        }\n+        URL url = bundle.getEntry(lib);\n+        url = FileLocator.resolve(url);\n+        String urlString = url.getFile();\n+        if (!urlString.endsWith(\".jar\") || !matchesPattern(urlString, libs)) {\n+          continue;\n+        }\n+        String libName = urlString.substring(urlString.indexOf('!') + 1);\n+        IFile iFile = project.getFile(libName);\n+        if (iFile == null) {\n+          continue;\n+        }\n+        IPath outPath = iFile.getRawLocation();\n+        File outFile = outPath.toFile();\n+        if (!outFile.getParentFile().exists() && copy) {\n+          outFile.getParentFile().mkdirs();\n+        }\n+        if (!outFile.exists() && copy) {\n+          outFile.createNewFile();\n+        }\n+        if (copy) {\n+          boolean firstTask = progress == null;\n+          if (progress == null) {\n+            progress = new ProgressMonitorDialog(Activator.getShell());\n+          }\n+          if (firstTask) {\n+            int nTask = libs == null ? libraries.size() : libs.size();\n+            progress.run(true, false, new JarCopier(url.openStream(), outFile, true, nTask));\n+          } else {\n+            progress.run(true, false, new JarCopier(url.openStream(), outFile));\n+          }\n+        }\n+        IClasspathEntry classpath = JavaCore.newLibraryEntry(outPath, null, null);\n+        entries.add(classpath);\n+      } catch (Exception e) {\n+        Activator.log(e);\n+      } finally {\n+        if (progress != null) {\n+          progress.getProgressMonitor().done();\n         }\n-        return result;\n+      }\n     }\n+    return entries.toArray(new IClasspathEntry[entries.size()]);\n+  }\n \n-\t/**\n-\t * Gets the runtime libraries required for this bundle to the given project.\n-\t * \n-\t * @param list of patterns that matches an actual library. null implies all runtime libraries.\n-\t * @param copy if true then the libraries are copied to the given project directory.\n-\t */\n-\tpublic IClasspathEntry[] getLibraryClasspaths(IProject project, List<String> libs, boolean copy) throws CoreException {\n-        if (libs != null && libs.isEmpty())\n-            return new IClasspathEntry[0];\n-        Bundle bundle = Platform.getBundle(BUNDLE_ID);\n-        List<String> libraries = getRuntimeLibraries(bundle);\n-        List<IClasspathEntry> entries = new ArrayList<IClasspathEntry>();\n-        ProgressMonitorDialog progress = null;\n-        for (String lib : libraries) {\n-            try {\n-                if (\".\".equals(lib))\n-                    continue;\n-                URL url = bundle.getEntry(lib);\n-                url = FileLocator.resolve(url);\n-                String urlString = url.getFile();\n-                if (!urlString.endsWith(\".jar\") || !matchesPattern(urlString, libs))\n-                    continue;\n-                String libName = urlString.substring(urlString.indexOf('!')+1);\n-                IFile iFile = project.getFile(libName);\n-                if (iFile == null) {\n-                    continue;\n-                }\n-                IPath outPath = iFile.getRawLocation();\n-                File outFile = outPath.toFile();\n-                if (!outFile.getParentFile().exists() && copy) {\n-                    outFile.getParentFile().mkdirs();\n-                }\n-                if (!outFile.exists() && copy) {\n-                    outFile.createNewFile();\n-                }\n-                if (copy) {\n-                    boolean firstTask = progress == null;\n-                    if (progress == null) {\n-                        progress = new ProgressMonitorDialog(Activator.getShell());\n-                    }\n-                    if (firstTask) {\n-                        int nTask = libs == null ? libraries.size() : libs.size();\n-                        progress.run(true, false, new JarCopier(url.openStream(),outFile, true, nTask));\n-                    } else {\n-                        progress.run(true, false, new JarCopier(url.openStream(),outFile));\n-                    }\n-                }\n-                IClasspathEntry classpath = JavaCore.newLibraryEntry(outPath, null, null);\n-                entries.add(classpath);\n-            } catch (Exception e) {\n-                Activator.log(e);\n-            } finally {\n-                if (progress != null) {\n-                    progress.getProgressMonitor().done();\n-                }\n-            }\n+  void copyJar(JarInputStream jar, JarOutputStream out) throws IOException {\n+    if (jar == null || out == null) {\n+      return;\n+    }\n+\n+    try {\n+      JarEntry entry = null;\n+      while ((entry = jar.getNextJarEntry()) != null) {\n+        out.putNextEntry(entry);\n+        int b = -1;\n+        while ((b = jar.read()) != -1) {\n+          out.write(b);\n         }\n-        return entries.toArray(new IClasspathEntry[entries.size()]);\n-\t}\n-\t\n-\tvoid copyJar(JarInputStream jar, JarOutputStream out) throws IOException {\n-\t    if (jar == null || out == null)\n-\t        return;\n-\t    \n-\t    try {\n-\t        JarEntry entry = null;\n-\t        while ((entry = jar.getNextJarEntry()) != null) {\n-\t            out.putNextEntry(entry);\n-\t            int b = -1;\n-\t            while ((b = jar.read()) != -1) {\n-\t                out.write(b);\n-\t            }\n-\t        }\n-\t        out.closeEntry();\n-\t    } finally {\n-\t        out.finish();\n-            out.flush();\n-\t        out.close();\n-\t        jar.close();\n-\t    }\n-\t}\n-\t\n-\t/**\n-\t * Finds the libraries that are required but missing from the given project's classpath.\n-\t * @param project\n-\t * @return empty list if no required libraries are missing.\n-\t */\n-\tpublic List<String> findMissingLibrary(IProject project) throws CoreException {\n-\t    List<String> missing = new ArrayList<String>();\n-\t    ClassLoader projectClassLoader = ClassLoaderFromIProjectHelper.createClassLoader(project);\n-\t    for (Map.Entry<String, String> e : probes.entrySet()) {\n-\t        try {\n-\t            Class.forName(e.getValue(), false, projectClassLoader);\n-\t        } catch (Exception cnf) {\n-\t            missing.add(e.getKey());\n-\t        }\n-\t    }\n-\t    return missing;\n-\t}\n-\t\n-\t/**\n-\t * Affirms if any of the given pattern is present in the given full name. \n-\t * @return\n-\t */\n-\tprivate boolean matchesPattern(String fullName, List<String> patterns) {\n-\t    if (patterns == null)\n-\t        return true;\n-\t    for (String pattern : patterns) {\n-\t        if (fullName.indexOf(pattern) != -1)\n-\t            return true;\n-\t    }\n-\t    return false;\n-\t}\n+      }\n+      out.closeEntry();\n+    } finally {\n+      out.finish();\n+      out.flush();\n+      out.close();\n+      jar.close();\n+    }\n+  }\n+\n+  /**\n+   * Finds the libraries that are required but missing from the given project's classpath.\n+   *\n+   * @param project\n+   * @return empty list if no required libraries are missing.\n+   */\n+  public List<String> findMissingLibrary(IProject project) throws CoreException {\n+    List<String> missing = new ArrayList<String>();\n+    ClassLoader projectClassLoader = ClassLoaderFromIProjectHelper.createClassLoader(project);\n+    for (Map.Entry<String, String> e : probes.entrySet()) {\n+      try {\n+        Class.forName(e.getValue(), false, projectClassLoader);\n+      } catch (Exception cnf) {\n+        missing.add(e.getKey());\n+      }\n+    }\n+    return missing;\n+  }\n+\n+  /**\n+   * Affirms if any of the given pattern is present in the given full name.\n+   *\n+   * @return\n+   */\n+  private boolean matchesPattern(String fullName, List<String> patterns) {\n+    if (patterns == null) {\n+      return true;\n+    }\n+    for (String pattern : patterns) {\n+      if (fullName.indexOf(pattern) != -1) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n \n-\tclass JarCopier implements IRunnableWithProgress {\n-\t    final JarInputStream in;\n-\t    final JarOutputStream out;\n-\t    final boolean beginTask;\n-\t    final int size;\n-\t    final String message;\n-\t    public JarCopier(InputStream jar, File outFile)  throws IOException {\n-\t        this(jar, outFile, false, 0);\n-\t    }\n-\t    \n-        public JarCopier(InputStream jar, File outFile, boolean begin, int size) throws IOException {\n-            super();\n-            this.in = new JarInputStream(jar);\n-            this.out = new JarOutputStream(new FileOutputStream(outFile));\n-            this.beginTask = begin;\n-            this.size = size;\n-            this.message = outFile.getAbsolutePath();\n+  class JarCopier implements IRunnableWithProgress {\n+    final JarInputStream in;\n+    final JarOutputStream out;\n+    final boolean beginTask;\n+    final int size;\n+    final String message;\n+\n+    public JarCopier(InputStream jar, File outFile) throws IOException {\n+      this(jar, outFile, false, 0);\n+    }\n+\n+    public JarCopier(InputStream jar, File outFile, boolean begin, int size) throws IOException {\n+      super();\n+      this.in = new JarInputStream(jar);\n+      this.out = new JarOutputStream(new FileOutputStream(outFile));\n+      this.beginTask = begin;\n+      this.size = size;\n+      this.message = outFile.getAbsolutePath();\n+    }\n+\n+    public void run(IProgressMonitor monitor) throws InvocationTargetException, InterruptedException {\n+      if (in == null || out == null) {\n+        return;\n+      }\n+      if (beginTask) {\n+        monitor.beginTask(\"Copying OpenJPA runtime libraries to user projects\", size);\n+      }\n+      monitor.subTask(message);\n+      try {\n+        try {\n+          JarEntry entry = null;\n+          while ((entry = in.getNextJarEntry()) != null) {\n+            out.putNextEntry(entry);\n+            int b = -1;\n+            while ((b = in.read()) != -1) {\n+              out.write(b);\n+            }\n+          }\n+          out.closeEntry();\n+        } finally {\n+          out.finish();\n+          out.flush();\n+          out.close();\n+          in.close();\n+          monitor.worked(1);\n         }\n-        \n-        public void run(IProgressMonitor monitor) throws InvocationTargetException, InterruptedException {\n-            if (in == null || out == null)\n-                return;\n-            if (beginTask)\n-                monitor.beginTask(\"Copying OpenJPA runtime libraries to user projects\", size);\n-            monitor.subTask(message);\n-            try {\n-                try {\n-                    JarEntry entry = null;\n-                    while ((entry = in.getNextJarEntry()) != null) {\n-                        out.putNextEntry(entry);\n-                        int b = -1;\n-                        while ((b = in.read()) != -1) {\n-                            out.write(b);\n-                        }\n-                    }\n-                    out.closeEntry();\n-                } finally {\n-                    out.finish();\n-                    out.flush();\n-                    out.close();\n-                    in.close();\n-                    monitor.worked(1);\n-                }\n-        } catch (IOException ex) {\n-        } \n-\t}\n-\t}\n+      } catch (IOException ex) {\n+      }\n+    }\n+  }\n }\n",
            "diff_size": 302
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "114",
                    "severity": "error",
                    "message": "Line is longer than 120 characters (found 127).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/189/PluginLibrary.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/naturalize/189/PluginLibrary.java\nindex df3e890e65d..75c6b42abcd 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/189/PluginLibrary.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/naturalize/189/PluginLibrary.java\n@@ -68,13 +68,13 @@ public class PluginLibrary {\n \t */\n \tprivate static final Map<String,String> probes = new HashMap<String, String>();\n \tstatic {\n-        probes.put(\"commons-collections\", \"org.apache.commons.collections.ArrayStack\");\n-        probes.put(\"commons-lang\",        \"org.apache.commons.lang.ObjectUtils\");\n-        probes.put(\"geronimo-jms\",        \"javax.jms.Connection\");\n-        probes.put(\"geronimo-jpa\",        \"javax.persistence.Entity\");\n-        probes.put(\"geronimo-jta\",        \"javax.transaction.Transaction\");\n-        probes.put(\"openjpa\",             \"org.apache.openjpa.conf.OpenJPAVersion\");\n-        probes.put(\"serp\",                \"serp.bytecode.BCClass\");\n+    probes.put(\"commons-collections\", \"org.apache.commons.collections.ArrayStack\");\n+        probes.put(\"commons-lang\", \"org.apache.commons.lang.ObjectUtils\");\n+        probes.put(\"geronimo-jms\", \"javax.jms.Connection\");\n+        probes.put(\"geronimo-jpa\", \"javax.persistence.Entity\");\n+        probes.put(\"geronimo-jta\", \"javax.transaction.Transaction\");\n+        probes.put(\"openjpa\", \"org.apache.openjpa.conf.OpenJPAVersion\");\n+        probes.put(\"serp\", \"serp.bytecode.BCClass\");\n \t}\n \t\n \tpublic String getDescription() {\n@@ -105,14 +105,14 @@ public class PluginLibrary {\n         return result;\n     }\n \n-\t/**\n+/**\n \t * Gets the runtime libraries required for this bundle to the given project.\n \t * \n \t * @param list of patterns that matches an actual library. null implies all runtime libraries.\n \t * @param copy if true then the libraries are copied to the given project directory.\n \t */\n \tpublic IClasspathEntry[] getLibraryClasspaths(IProject project, List<String> libs, boolean copy) throws CoreException {\n-        if (libs != null && libs.isEmpty())\n+if (libs != null && libs.isEmpty())\n             return new IClasspathEntry[0];\n         Bundle bundle = Platform.getBundle(BUNDLE_ID);\n         List<String> libraries = getRuntimeLibraries(bundle);\n@@ -166,11 +166,10 @@ public class PluginLibrary {\n \t}\n \t\n \tvoid copyJar(JarInputStream jar, JarOutputStream out) throws IOException {\n-\t    if (jar == null || out == null)\n+if (jar == null || out == null)\n \t        return;\n-\t    \n-\t    try {\n-\t        JarEntry entry = null;\n+    try {\n+JarEntry entry = null;\n \t        while ((entry = jar.getNextJarEntry()) != null) {\n \t            out.putNextEntry(entry);\n \t            int b = -1;\n@@ -181,8 +180,8 @@ public class PluginLibrary {\n \t        out.closeEntry();\n \t    } finally {\n \t        out.finish();\n-            out.flush();\n-\t        out.close();\n+out.flush();\n+out.close();\n \t        jar.close();\n \t    }\n \t}\n@@ -225,7 +224,7 @@ public class PluginLibrary {\n \t    final boolean beginTask;\n \t    final int size;\n \t    final String message;\n-\t    public JarCopier(InputStream jar, File outFile)  throws IOException {\n+\t    public JarCopier(InputStream jar, File outFile) throws IOException {\n \t        this(jar, outFile, false, 0);\n \t    }\n \t    \n@@ -263,7 +262,7 @@ public class PluginLibrary {\n                     monitor.worked(1);\n                 }\n         } catch (IOException ex) {\n-        } \n-\t}\n+        }\n+    }\n \t}\n-}\n+   }\n\\ No newline at end of file\n",
            "diff_size": 19
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/189/PluginLibrary.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler_random/189/PluginLibrary.java\nindex df3e890e65d..d1596774dfe 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/189/PluginLibrary.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler_random/189/PluginLibrary.java\n@@ -111,7 +111,9 @@ public class PluginLibrary {\n \t * @param list of patterns that matches an actual library. null implies all runtime libraries.\n \t * @param copy if true then the libraries are copied to the given project directory.\n \t */\n-\tpublic IClasspathEntry[] getLibraryClasspaths(IProject project, List<String> libs, boolean copy) throws CoreException {\n+\n+\n+ public IClasspathEntry[] getLibraryClasspaths(IProject project, List<String> libs, boolean copy) throws CoreException {\n         if (libs != null && libs.isEmpty())\n             return new IClasspathEntry[0];\n         Bundle bundle = Platform.getBundle(BUNDLE_ID);\n",
            "diff_size": 3
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/189/PluginLibrary.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler_three_grams/189/PluginLibrary.java\nindex df3e890e65d..9712ec0ddd1 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/189/PluginLibrary.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler_three_grams/189/PluginLibrary.java\n@@ -111,8 +111,8 @@ public class PluginLibrary {\n \t * @param list of patterns that matches an actual library. null implies all runtime libraries.\n \t * @param copy if true then the libraries are copied to the given project directory.\n \t */\n-\tpublic IClasspathEntry[] getLibraryClasspaths(IProject project, List<String> libs, boolean copy) throws CoreException {\n-        if (libs != null && libs.isEmpty())\n+ public IClasspathEntry[] getLibraryClasspaths(IProject project, List<String> libs, boolean copy) throws CoreException {\n+     if (libs != null && libs.isEmpty())\n             return new IClasspathEntry[0];\n         Bundle bundle = Platform.getBundle(BUNDLE_ID);\n         List<String> libraries = getRuntimeLibraries(bundle);\n",
            "diff_size": 2
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "naturalize",
        "codebuff"
    ]
}