{
    "project_name": "NationalSecurityAgency-datawave",
    "error_id": "61",
    "information": {
        "errors": [
            {
                "line": "14",
                "severity": "error",
                "message": "Accumulo non-public classes imported",
                "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
            }
        ]
    },
    "source_code": "\nimport org.apache.accumulo.core.client.IteratorSetting;\nimport org.apache.accumulo.core.client.impl.ThriftScanner.ScanTimedOutException;\nimport org.apache.accumulo.core.data.Key;\nimport org.apache.accumulo.core.data.PartialKey;\nimport org.apache.accumulo.core.data.Range;",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "14",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "14",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/61/Scan.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/intellij/61/Scan.java\nindex f7a0a024744..183424ec3c0 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/61/Scan.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/intellij/61/Scan.java\n@@ -31,342 +31,365 @@ import datawave.query.tables.stats.ScanSessionStats;\n import datawave.query.tables.stats.ScanSessionStats.TIMERS;\n \n public class Scan implements Callable<Scan> {\n-    \n-    private static final Logger log = Logger.getLogger(Scan.class);\n-    public static final String SCAN_ID = \"scan.id\";\n-    \n-    protected ScannerChunk myScan;\n-    \n-    /**\n-     * last seen key, used for moving across the sliding window of ranges.\n-     */\n-    protected Key lastSeenKey;\n-    \n-    /**\n-     * Current range that we are using.\n-     */\n-    protected Range currentRange;\n-    \n-    protected boolean continueMultiScan;\n-    \n-    private ResourceQueue delegatorReference;\n-    \n-    protected BlockingQueue<Entry<Key,Value>> results;\n-    \n-    private String localTableName;\n-    \n-    private Set<Authorizations> localAuths;\n-    \n-    private Class<? extends AccumuloResource> delegatedResourceInitializer;\n-    \n-    protected ExecutorService caller;\n-    \n-    protected ScanSessionStats myStats;\n-    \n-    protected boolean initialized = false;\n-    \n-    private List<Function<ScannerChunk,ScannerChunk>> visitorFunctions = null;\n-    \n-    protected SessionArbiter arbiter = null;\n-    \n-    protected long timeout = -1;\n-    \n-    private AccumuloResource delegatedResource = null;\n-    \n-    public Scan(String localTableName, Set<Authorizations> localAuths, ScannerChunk chunk, ResourceQueue delegatorReference,\n-                    Class<? extends AccumuloResource> delegatedResourceInitializer, BlockingQueue<Entry<Key,Value>> results, ExecutorService callingService) {\n-        myScan = chunk;\n-        if (log.isTraceEnabled())\n-            log.trace(\"Size of ranges:  \" + myScan.getRanges().size());\n-        continueMultiScan = true;\n-        this.delegatorReference = delegatorReference;\n-        this.results = results;\n-        this.localTableName = localTableName;\n-        this.localAuths = localAuths;\n-        this.delegatedResourceInitializer = delegatedResourceInitializer;\n-        this.caller = callingService;\n-        myStats = new ScanSessionStats();\n-        myStats.initializeTimers();\n-    }\n-    \n-    public void setTimeout(long timeout) {\n-        this.timeout = timeout;\n-    }\n-    \n-    public void setVisitors(List<Function<ScannerChunk,ScannerChunk>> visitorFunctions) {\n-        this.visitorFunctions = visitorFunctions;\n+\n+  private static final Logger log = Logger.getLogger(Scan.class);\n+  public static final String SCAN_ID = \"scan.id\";\n+\n+  protected ScannerChunk myScan;\n+\n+  /**\n+   * last seen key, used for moving across the sliding window of ranges.\n+   */\n+  protected Key lastSeenKey;\n+\n+  /**\n+   * Current range that we are using.\n+   */\n+  protected Range currentRange;\n+\n+  protected boolean continueMultiScan;\n+\n+  private ResourceQueue delegatorReference;\n+\n+  protected BlockingQueue<Entry<Key, Value>> results;\n+\n+  private String localTableName;\n+\n+  private Set<Authorizations> localAuths;\n+\n+  private Class<? extends AccumuloResource> delegatedResourceInitializer;\n+\n+  protected ExecutorService caller;\n+\n+  protected ScanSessionStats myStats;\n+\n+  protected boolean initialized = false;\n+\n+  private List<Function<ScannerChunk, ScannerChunk>> visitorFunctions = null;\n+\n+  protected SessionArbiter arbiter = null;\n+\n+  protected long timeout = -1;\n+\n+  private AccumuloResource delegatedResource = null;\n+\n+  public Scan(String localTableName, Set<Authorizations> localAuths, ScannerChunk chunk,\n+              ResourceQueue delegatorReference,\n+              Class<? extends AccumuloResource> delegatedResourceInitializer, BlockingQueue<Entry<Key, Value>> results,\n+              ExecutorService callingService) {\n+    myScan = chunk;\n+    if (log.isTraceEnabled()) {\n+      log.trace(\"Size of ranges:  \" + myScan.getRanges().size());\n     }\n-    \n-    public List<Function<ScannerChunk,ScannerChunk>> getVisitors() {\n-        return this.visitorFunctions;\n+    continueMultiScan = true;\n+    this.delegatorReference = delegatorReference;\n+    this.results = results;\n+    this.localTableName = localTableName;\n+    this.localAuths = localAuths;\n+    this.delegatedResourceInitializer = delegatedResourceInitializer;\n+    this.caller = callingService;\n+    myStats = new ScanSessionStats();\n+    myStats.initializeTimers();\n+  }\n+\n+  public void setTimeout(long timeout) {\n+    this.timeout = timeout;\n+  }\n+\n+  public void setVisitors(List<Function<ScannerChunk, ScannerChunk>> visitorFunctions) {\n+    this.visitorFunctions = visitorFunctions;\n+  }\n+\n+  public List<Function<ScannerChunk, ScannerChunk>> getVisitors() {\n+    return this.visitorFunctions;\n+  }\n+\n+  public boolean finished() {\n+    if (caller.isShutdown() && log.isTraceEnabled()) {\n+      log.trace(\"Prematurely shutting down because we were forced to stop\");\n     }\n-    \n-    public boolean finished() {\n-        if (caller.isShutdown() && log.isTraceEnabled()) {\n-            log.trace(\"Prematurely shutting down because we were forced to stop\");\n+    return caller.isShutdown() || (currentRange == null && lastSeenKey == null);\n+  }\n+\n+  @Subscribe\n+  public void registerShutdown(ShutdownEvent event) {\n+    continueMultiScan = false;\n+  }\n+\n+  /*\n+   * (non-Javadoc)\n+   *\n+   * @see java.util.concurrent.Callable#call()\n+   */\n+  @Override\n+  public Scan call() throws Exception {\n+    try {\n+\n+      /**\n+       * Even though we were delegated a resource, we have not actually been provided the plumbing to run it. Note, below, that we initialize the resource\n+       * through the resource factory from a running resource.\n+       */\n+\n+      if (!initialized) {\n+        if (null != visitorFunctions) {\n+          for (Function<ScannerChunk, ScannerChunk> fx : visitorFunctions) {\n+            myScan = fx.apply(myScan);\n+          }\n         }\n-        return caller.isShutdown() || (currentRange == null && lastSeenKey == null);\n-    }\n-    \n-    @Subscribe\n-    public void registerShutdown(ShutdownEvent event) {\n-        continueMultiScan = false;\n-    }\n-    \n-    /*\n-     * (non-Javadoc)\n-     * \n-     * @see java.util.concurrent.Callable#call()\n-     */\n-    @Override\n-    public Scan call() throws Exception {\n-        try {\n-            \n+        initialized = true;\n+      }\n+\n+      do {\n+        if (null != myStats) {\n+          myStats.getTimer(TIMERS.SCANNER_START).resume();\n+        }\n+        delegatedResource = delegatorReference.getScannerResource();\n+        if (log.isTraceEnabled()) {\n+          log.trace(\"last seen \" + lastSeenKey + \" \" + currentRange);\n+        }\n+        // if we have just started or we are at the end of the\n+        // current range. pop the next range\n+        if (lastSeenKey == null || (currentRange != null && currentRange.getEndKey() != null &&\n+            lastSeenKey.compareTo(currentRange.getEndKey()) >= 0)) {\n+          currentRange = myScan.getNextRange();\n+\n+          // short circuit and exit\n+          if (null == currentRange) {\n+            lastSeenKey = null;\n+            if (log.isTraceEnabled()) {\n+              log.trace(\"Leaving\");\n+            }\n+            if (null != myStats) {\n+              myStats.getTimer(TIMERS.SCANNER_START).suspend();\n+            }\n+            return this;\n+          }\n+\n+          if (log.isTraceEnabled()) {\n+            log.trace(\"current range is \" + currentRange);\n+          }\n+        } else {\n+          // adjust the end key range.\n+          if (log.isTraceEnabled()) {\n+            log.trace(\"Building new range from \" + lastSeenKey);\n+          }\n+          try {\n+            currentRange = buildNextRange(lastSeenKey, currentRange);\n+          } catch (IllegalArgumentException e) {\n+            // we are beyond the start range.\n+\n             /**\n-             * Even though we were delegated a resource, we have not actually been provided the plumbing to run it. Note, below, that we initialize the resource\n-             * through the resource factory from a running resource.\n+             * same net effect, but instead we get to follow the logging better if we pop here and trace\n              */\n-            \n-            if (!initialized) {\n-                if (null != visitorFunctions) {\n-                    for (Function<ScannerChunk,ScannerChunk> fx : visitorFunctions) {\n-                        myScan = fx.apply(myScan);\n-                    }\n-                }\n-                initialized = true;\n+            if (log.isTraceEnabled()) {\n+              log.trace(lastSeenKey + \" is lastseenKey, previous range is \" + currentRange);\n             }\n-            \n-            do {\n-                if (null != myStats)\n-                    myStats.getTimer(TIMERS.SCANNER_START).resume();\n-                delegatedResource = delegatorReference.getScannerResource();\n-                if (log.isTraceEnabled())\n-                    log.trace(\"last seen \" + lastSeenKey + \" \" + currentRange);\n-                // if we have just started or we are at the end of the\n-                // current range. pop the next range\n-                if (lastSeenKey == null || (currentRange != null && currentRange.getEndKey() != null && lastSeenKey.compareTo(currentRange.getEndKey()) >= 0)) {\n-                    currentRange = myScan.getNextRange();\n-                    \n-                    // short circuit and exit\n-                    if (null == currentRange) {\n-                        lastSeenKey = null;\n-                        if (log.isTraceEnabled())\n-                            log.trace(\"Leaving\");\n-                        if (null != myStats)\n-                            myStats.getTimer(TIMERS.SCANNER_START).suspend();\n-                        return this;\n-                    }\n-                    \n-                    if (log.isTraceEnabled())\n-                        log.trace(\"current range is \" + currentRange);\n-                } else {\n-                    // adjust the end key range.\n-                    if (log.isTraceEnabled())\n-                        log.trace(\"Building new range from \" + lastSeenKey);\n-                    try {\n-                        currentRange = buildNextRange(lastSeenKey, currentRange);\n-                    } catch (IllegalArgumentException e) {\n-                        // we are beyond the start range.\n-                        \n-                        /**\n-                         * same net effect, but instead we get to follow the logging better if we pop here and trace\n-                         */\n-                        if (log.isTraceEnabled())\n-                            log.trace(lastSeenKey + \" is lastseenKey, previous range is \" + currentRange);\n-                        // we are beyond the start range.\n-                        currentRange = myScan.getNextRange();\n-                        if (log.isTraceEnabled())\n-                            log.trace(lastSeenKey + \" is lastseenKey, new range that we have popped is \" + currentRange);\n-                        // short circuit and exit\n-                        if (null == currentRange) {\n-                            lastSeenKey = null;\n-                            log.trace(\"Leaving\");\n-                            return this;\n-                        }\n-                    }\n-                }\n-                \n-                boolean docSpecific = RangeDefinition.isDocSpecific(currentRange);\n-                \n-                if (log.isTraceEnabled()) {\n-                    log.trace(lastSeenKey + \", using current range of \" + myScan.getLastRange());\n-                    log.trace(lastSeenKey + \", using current range of \" + currentRange);\n-                }\n-                if (log.isTraceEnabled())\n-                    log.trace(\"initialize resource \" + currentRange + \"'s resource with \" + myScan.getOptions());\n-                for (IteratorSetting setting : myScan.getOptions().getIterators()) {\n-                    log.trace(setting.getName() + \" \" + setting.getOptions());\n-                }\n-                \n-                Class<? extends AccumuloResource> initializer = delegatedResourceInitializer;\n-                \n-                if (initializer != RfileResource.class) {\n-                    if (!docSpecific) {\n-                        initializer = BatchResource.class;\n-                    } else {\n-                        \n-                        if (null != arbiter && timeout > 0) {\n-                            \n-                            myScan.getOptions().setTimeout(timeout, TimeUnit.MILLISECONDS);\n-                            \n-                            if (!arbiter.canRun(myScan)) {\n-                                if (log.isInfoEnabled()) {\n-                                    log.info(\"Not running \" + currentRange);\n-                                }\n-                                if (log.isTraceEnabled()) {\n-                                    log.trace(\"Not running scan as we have other work to do, and this server is unresponsive\");\n-                                }\n-                                return this;\n-                            } else {\n-                                if (log.isTraceEnabled()) {\n-                                    log.trace(\"Running scan as server is not unresponsive\");\n-                                }\n-                            }\n-                        }\n-                        \n-                    }\n+            // we are beyond the start range.\n+            currentRange = myScan.getNextRange();\n+            if (log.isTraceEnabled()) {\n+              log.trace(lastSeenKey + \" is lastseenKey, new range that we have popped is \" + currentRange);\n+            }\n+            // short circuit and exit\n+            if (null == currentRange) {\n+              lastSeenKey = null;\n+              log.trace(\"Leaving\");\n+              return this;\n+            }\n+          }\n+        }\n+\n+        boolean docSpecific = RangeDefinition.isDocSpecific(currentRange);\n+\n+        if (log.isTraceEnabled()) {\n+          log.trace(lastSeenKey + \", using current range of \" + myScan.getLastRange());\n+          log.trace(lastSeenKey + \", using current range of \" + currentRange);\n+        }\n+        if (log.isTraceEnabled()) {\n+          log.trace(\"initialize resource \" + currentRange + \"'s resource with \" + myScan.getOptions());\n+        }\n+        for (IteratorSetting setting : myScan.getOptions().getIterators()) {\n+          log.trace(setting.getName() + \" \" + setting.getOptions());\n+        }\n+\n+        Class<? extends AccumuloResource> initializer = delegatedResourceInitializer;\n+\n+        if (initializer != RfileResource.class) {\n+          if (!docSpecific) {\n+            initializer = BatchResource.class;\n+          } else {\n+\n+            if (null != arbiter && timeout > 0) {\n+\n+              myScan.getOptions().setTimeout(timeout, TimeUnit.MILLISECONDS);\n+\n+              if (!arbiter.canRun(myScan)) {\n+                if (log.isInfoEnabled()) {\n+                  log.info(\"Not running \" + currentRange);\n                 }\n-                \n-                String scanId = getNewScanId();\n                 if (log.isTraceEnabled()) {\n-                    log.trace(\"Setting \" + SCAN_ID + \" = \" + scanId);\n-                }\n-                \n-                for (IteratorSetting setting : myScan.getOptions().getIterators()) {\n-                    myScan.getOptions().updateScanIteratorOption(setting.getName(), SCAN_ID, scanId);\n+                  log.trace(\"Not running scan as we have other work to do, and this server is unresponsive\");\n                 }\n-                \n+                return this;\n+              } else {\n                 if (log.isTraceEnabled()) {\n-                    for (IteratorSetting setting : myScan.getOptions().getIterators()) {\n-                        log.trace(setting.getName() + \" \" + setting.getOptions());\n-                    }\n-                    log.trace(\"Using \" + initializer);\n-                }\n-                \n-                delegatedResource = ResourceFactory.initializeResource(initializer, delegatedResource, localTableName, localAuths, currentRange).setOptions(\n-                                myScan.getOptions());\n-                \n-                Iterator<Entry<Key,Value>> iter = delegatedResource.iterator();\n-                \n-                if (null != myStats)\n-                    myStats.getTimer(TIMERS.SCANNER_START).suspend();\n-                // do not continue if we've reached the end of the corpus\n-                if (log.isTraceEnabled())\n-                    log.trace(\"has next? \" + iter.hasNext());\n-                if (!iter.hasNext()) {\n-                    if (log.isTraceEnabled())\n-                        log.trace(\"We've started, but we have nothing to do on \" + localTableName + \" \" + localAuths + \" \" + currentRange);\n-                    lastSeenKey = null;\n+                  log.trace(\"Running scan as server is not unresponsive\");\n                 }\n-                \n-                Entry<Key,Value> myEntry = null;\n-                if (null != myStats)\n-                    myStats.getTimer(TIMERS.SCANNER_ITERATE).resume();\n-                while (iter.hasNext()) {\n-                    if (!continueMultiScan)\n-                        throw new Exception(\"Stopped mid cycle\");\n-                    myEntry = iter.next();\n-                    \n-                    while (!caller.isShutdown() && !results.offer(myEntry, 25, TimeUnit.MILLISECONDS)) {\n-                        if (log.isTraceEnabled())\n-                            log.trace(\"offering\");\n-                    }\n-                    \n-                    if (log.isTraceEnabled())\n-                        log.trace(\"size of results \" + results.size() + \" is shutdown? \" + caller.isShutdown());\n-                    \n-                    if (caller.isShutdown())\n-                        break;\n-                    \n-                    lastSeenKey = myEntry.getKey();\n-                    if (log.isTraceEnabled())\n-                        log.trace(\"last seen key is \" + lastSeenKey);\n-                }\n-                if (!iter.hasNext())\n-                    lastSeenKey = null;\n-                \n-                // close early\n-                delegatorReference.close(delegatedResource);\n-                \n-                if (null != myStats)\n-                    myStats.getTimer(TIMERS.SCANNER_ITERATE).suspend();\n-                \n-                if (log.isTraceEnabled())\n-                    log.trace(\"not finished?\" + !finished());\n-            } while (!finished());\n-        } catch (\n-        \n-        ScanTimedOutException e)\n-        \n-        {\n-            // this is okay. This means that we are being timesliced.\n-            myScan.addRange(currentRange);\n-        } catch (\n-        \n-        Exception e)\n-        \n-        {\n-            log.error(\"exception \", e);\n-            throw e;\n-        } finally\n-        \n-        {\n-            if (null != delegatedResource) {\n-                delegatorReference.close(delegatedResource);\n+              }\n             }\n+\n+          }\n         }\n-        return this;\n-        \n-    }\n-    \n-    static final AtomicLong scanIdFactory = new AtomicLong(0);\n-    \n-    private String getNewScanId() {\n-        long scanId = scanIdFactory.incrementAndGet();\n-        return Long.toHexString(scanId);\n-    }\n-    \n-    /**\n-     * Override this for your specific implementation.\n-     * \n-     * @param lastKey\n-     * @param previousRange\n-     */\n-    public Range buildNextRange(final Key lastKey, final Range previousRange) {\n-        return new Range(lastKey.followingKey(PartialKey.ROW_COLFAM_COLQUAL_COLVIS_TIME), true, previousRange.getEndKey(), previousRange.isEndKeyInclusive());\n-    }\n-    \n-    public ScanSessionStats getStats() {\n-        return myStats;\n-    }\n-    \n-    public void setSessionArbiter(SessionArbiter arbiter) {\n-        this.arbiter = arbiter;\n-    }\n-    \n-    public String getScanLocation() {\n-        return myScan.getLastKnownLocation();\n-    }\n-    \n-    /**\n-     * Added because speculative scan could reach a condition by which we won't be closing the futures and therefore the batch scanner session won't close this\n-     * Scan\n-     */\n-    public void close() {\n-        if (null != delegatedResource) {\n-            try {\n-                delegatedResource.close();\n-            } catch (Exception e) {\n-                log.warn(\"Ignoring error on close\", e);\n+\n+        String scanId = getNewScanId();\n+        if (log.isTraceEnabled()) {\n+          log.trace(\"Setting \" + SCAN_ID + \" = \" + scanId);\n+        }\n+\n+        for (IteratorSetting setting : myScan.getOptions().getIterators()) {\n+          myScan.getOptions().updateScanIteratorOption(setting.getName(), SCAN_ID, scanId);\n+        }\n+\n+        if (log.isTraceEnabled()) {\n+          for (IteratorSetting setting : myScan.getOptions().getIterators()) {\n+            log.trace(setting.getName() + \" \" + setting.getOptions());\n+          }\n+          log.trace(\"Using \" + initializer);\n+        }\n+\n+        delegatedResource =\n+            ResourceFactory.initializeResource(initializer, delegatedResource, localTableName, localAuths, currentRange)\n+                .setOptions(\n+                    myScan.getOptions());\n+\n+        Iterator<Entry<Key, Value>> iter = delegatedResource.iterator();\n+\n+        if (null != myStats) {\n+          myStats.getTimer(TIMERS.SCANNER_START).suspend();\n+        }\n+        // do not continue if we've reached the end of the corpus\n+        if (log.isTraceEnabled()) {\n+          log.trace(\"has next? \" + iter.hasNext());\n+        }\n+        if (!iter.hasNext()) {\n+          if (log.isTraceEnabled()) {\n+            log.trace(\"We've started, but we have nothing to do on \" + localTableName + \" \" + localAuths + \" \" +\n+                currentRange);\n+          }\n+          lastSeenKey = null;\n+        }\n+\n+        Entry<Key, Value> myEntry = null;\n+        if (null != myStats) {\n+          myStats.getTimer(TIMERS.SCANNER_ITERATE).resume();\n+        }\n+        while (iter.hasNext()) {\n+          if (!continueMultiScan) {\n+            throw new Exception(\"Stopped mid cycle\");\n+          }\n+          myEntry = iter.next();\n+\n+          while (!caller.isShutdown() && !results.offer(myEntry, 25, TimeUnit.MILLISECONDS)) {\n+            if (log.isTraceEnabled()) {\n+              log.trace(\"offering\");\n             }\n+          }\n+\n+          if (log.isTraceEnabled()) {\n+            log.trace(\"size of results \" + results.size() + \" is shutdown? \" + caller.isShutdown());\n+          }\n+\n+          if (caller.isShutdown()) {\n+            break;\n+          }\n+\n+          lastSeenKey = myEntry.getKey();\n+          if (log.isTraceEnabled()) {\n+            log.trace(\"last seen key is \" + lastSeenKey);\n+          }\n+        }\n+        if (!iter.hasNext()) {\n+          lastSeenKey = null;\n+        }\n+\n+        // close early\n+        delegatorReference.close(delegatedResource);\n+\n+        if (null != myStats) {\n+          myStats.getTimer(TIMERS.SCANNER_ITERATE).suspend();\n+        }\n+\n+        if (log.isTraceEnabled()) {\n+          log.trace(\"not finished?\" + !finished());\n         }\n+      } while (!finished());\n+    } catch (\n+\n+        ScanTimedOutException e) {\n+      // this is okay. This means that we are being timesliced.\n+      myScan.addRange(currentRange);\n+    } catch (\n+\n+        Exception e) {\n+      log.error(\"exception \", e);\n+      throw e;\n+    } finally {\n+      if (null != delegatedResource) {\n+        delegatorReference.close(delegatedResource);\n+      }\n     }\n-    \n-    /**\n-     * Disables Statistics for this scan.\n-     */\n-    public void disableStats() {\n-        myStats = null;\n+    return this;\n+\n+  }\n+\n+  static final AtomicLong scanIdFactory = new AtomicLong(0);\n+\n+  private String getNewScanId() {\n+    long scanId = scanIdFactory.incrementAndGet();\n+    return Long.toHexString(scanId);\n+  }\n+\n+  /**\n+   * Override this for your specific implementation.\n+   *\n+   * @param lastKey\n+   * @param previousRange\n+   */\n+  public Range buildNextRange(final Key lastKey, final Range previousRange) {\n+    return new Range(lastKey.followingKey(PartialKey.ROW_COLFAM_COLQUAL_COLVIS_TIME), true, previousRange.getEndKey(),\n+        previousRange.isEndKeyInclusive());\n+  }\n+\n+  public ScanSessionStats getStats() {\n+    return myStats;\n+  }\n+\n+  public void setSessionArbiter(SessionArbiter arbiter) {\n+    this.arbiter = arbiter;\n+  }\n+\n+  public String getScanLocation() {\n+    return myScan.getLastKnownLocation();\n+  }\n+\n+  /**\n+   * Added because speculative scan could reach a condition by which we won't be closing the futures and therefore the batch scanner session won't close this\n+   * Scan\n+   */\n+  public void close() {\n+    if (null != delegatedResource) {\n+      try {\n+        delegatedResource.close();\n+      } catch (Exception e) {\n+        log.warn(\"Ignoring error on close\", e);\n+      }\n     }\n-    \n+  }\n+\n+  /**\n+   * Disables Statistics for this scan.\n+   */\n+  public void disableStats() {\n+    myStats = null;\n+  }\n+\n }\n",
            "diff_size": 494
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "13",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/61/Scan.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/codebuff/61/Scan.java\nindex f7a0a024744..4540dc2382b 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/61/Scan.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/codebuff/61/Scan.java\n@@ -9,7 +9,6 @@ import java.util.concurrent.Callable;\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicLong;\n-\n import org.apache.accumulo.core.client.IteratorSetting;\n import org.apache.accumulo.core.client.impl.ThriftScanner.ScanTimedOutException;\n import org.apache.accumulo.core.data.Key;\n@@ -18,10 +17,8 @@ import org.apache.accumulo.core.data.Range;\n import org.apache.accumulo.core.data.Value;\n import org.apache.accumulo.core.security.Authorizations;\n import org.apache.log4j.Logger;\n-\n import com.google.common.base.Function;\n import com.google.common.eventbus.Subscribe;\n-\n import datawave.mr.bulk.RfileResource;\n import datawave.query.tables.AccumuloResource;\n import datawave.query.tables.AccumuloResource.ResourceFactory;\n@@ -30,11 +27,11 @@ import datawave.query.tables.ResourceQueue;\n import datawave.query.tables.stats.ScanSessionStats;\n import datawave.query.tables.stats.ScanSessionStats.TIMERS;\n \n+\n public class Scan implements Callable<Scan> {\n-    \n     private static final Logger log = Logger.getLogger(Scan.class);\n+\n     public static final String SCAN_ID = \"scan.id\";\n-    \n     protected ScannerChunk myScan;\n     \n     /**\n@@ -46,35 +43,21 @@ public class Scan implements Callable<Scan> {\n      * Current range that we are using.\n      */\n     protected Range currentRange;\n-    \n     protected boolean continueMultiScan;\n-    \n     private ResourceQueue delegatorReference;\n-    \n     protected BlockingQueue<Entry<Key,Value>> results;\n-    \n     private String localTableName;\n-    \n     private Set<Authorizations> localAuths;\n-    \n     private Class<? extends AccumuloResource> delegatedResourceInitializer;\n-    \n     protected ExecutorService caller;\n-    \n     protected ScanSessionStats myStats;\n-    \n     protected boolean initialized = false;\n-    \n     private List<Function<ScannerChunk,ScannerChunk>> visitorFunctions = null;\n-    \n     protected SessionArbiter arbiter = null;\n-    \n     protected long timeout = -1;\n-    \n     private AccumuloResource delegatedResource = null;\n-    \n-    public Scan(String localTableName, Set<Authorizations> localAuths, ScannerChunk chunk, ResourceQueue delegatorReference,\n-                    Class<? extends AccumuloResource> delegatedResourceInitializer, BlockingQueue<Entry<Key,Value>> results, ExecutorService callingService) {\n+\n+    public Scan(String localTableName, Set<Authorizations> localAuths, ScannerChunk chunk, ResourceQueue delegatorReference, Class<? extends AccumuloResource> delegatedResourceInitializer, BlockingQueue<Entry<Key,Value>> results, ExecutorService callingService) {\n         myScan = chunk;\n         if (log.isTraceEnabled())\n             log.trace(\"Size of ranges:  \" + myScan.getRanges().size());\n@@ -88,26 +71,26 @@ public class Scan implements Callable<Scan> {\n         myStats = new ScanSessionStats();\n         myStats.initializeTimers();\n     }\n-    \n+\n     public void setTimeout(long timeout) {\n         this.timeout = timeout;\n     }\n-    \n+\n     public void setVisitors(List<Function<ScannerChunk,ScannerChunk>> visitorFunctions) {\n         this.visitorFunctions = visitorFunctions;\n     }\n-    \n+\n     public List<Function<ScannerChunk,ScannerChunk>> getVisitors() {\n         return this.visitorFunctions;\n     }\n-    \n+\n     public boolean finished() {\n         if (caller.isShutdown() && log.isTraceEnabled()) {\n             log.trace(\"Prematurely shutting down because we were forced to stop\");\n         }\n         return caller.isShutdown() || (currentRange == null && lastSeenKey == null);\n     }\n-    \n+\n     @Subscribe\n     public void registerShutdown(ShutdownEvent event) {\n         continueMultiScan = false;\n@@ -118,6 +101,7 @@ public class Scan implements Callable<Scan> {\n      * \n      * @see java.util.concurrent.Callable#call()\n      */\n+\n     @Override\n     public Scan call() throws Exception {\n         try {\n@@ -126,7 +110,6 @@ public class Scan implements Callable<Scan> {\n              * Even though we were delegated a resource, we have not actually been provided the plumbing to run it. Note, below, that we initialize the resource\n              * through the resource factory from a running resource.\n              */\n-            \n             if (!initialized) {\n                 if (null != visitorFunctions) {\n                     for (Function<ScannerChunk,ScannerChunk> fx : visitorFunctions) {\n@@ -135,7 +118,6 @@ public class Scan implements Callable<Scan> {\n                 }\n                 initialized = true;\n             }\n-            \n             do {\n                 if (null != myStats)\n                     myStats.getTimer(TIMERS.SCANNER_START).resume();\n@@ -156,7 +138,8 @@ public class Scan implements Callable<Scan> {\n                             myStats.getTimer(TIMERS.SCANNER_START).suspend();\n                         return this;\n                     }\n-                    \n+\n+\n                     if (log.isTraceEnabled())\n                         log.trace(\"current range is \" + currentRange);\n                 } else {\n@@ -185,34 +168,34 @@ public class Scan implements Callable<Scan> {\n                         }\n                     }\n                 }\n-                \n+\n                 boolean docSpecific = RangeDefinition.isDocSpecific(currentRange);\n-                \n                 if (log.isTraceEnabled()) {\n                     log.trace(lastSeenKey + \", using current range of \" + myScan.getLastRange());\n                     log.trace(lastSeenKey + \", using current range of \" + currentRange);\n                 }\n+\n+\n                 if (log.isTraceEnabled())\n                     log.trace(\"initialize resource \" + currentRange + \"'s resource with \" + myScan.getOptions());\n+\n                 for (IteratorSetting setting : myScan.getOptions().getIterators()) {\n                     log.trace(setting.getName() + \" \" + setting.getOptions());\n                 }\n-                \n+\n                 Class<? extends AccumuloResource> initializer = delegatedResourceInitializer;\n-                \n                 if (initializer != RfileResource.class) {\n                     if (!docSpecific) {\n                         initializer = BatchResource.class;\n                     } else {\n-                        \n                         if (null != arbiter && timeout > 0) {\n-                            \n                             myScan.getOptions().setTimeout(timeout, TimeUnit.MILLISECONDS);\n-                            \n                             if (!arbiter.canRun(myScan)) {\n                                 if (log.isInfoEnabled()) {\n                                     log.info(\"Not running \" + currentRange);\n                                 }\n+\n+\n                                 if (log.isTraceEnabled()) {\n                                     log.trace(\"Not running scan as we have other work to do, and this server is unresponsive\");\n                                 }\n@@ -223,31 +206,27 @@ public class Scan implements Callable<Scan> {\n                                 }\n                             }\n                         }\n-                        \n                     }\n                 }\n-                \n+\n                 String scanId = getNewScanId();\n                 if (log.isTraceEnabled()) {\n                     log.trace(\"Setting \" + SCAN_ID + \" = \" + scanId);\n                 }\n-                \n                 for (IteratorSetting setting : myScan.getOptions().getIterators()) {\n                     myScan.getOptions().updateScanIteratorOption(setting.getName(), SCAN_ID, scanId);\n                 }\n-                \n+\n+\n                 if (log.isTraceEnabled()) {\n                     for (IteratorSetting setting : myScan.getOptions().getIterators()) {\n                         log.trace(setting.getName() + \" \" + setting.getOptions());\n                     }\n                     log.trace(\"Using \" + initializer);\n                 }\n-                \n-                delegatedResource = ResourceFactory.initializeResource(initializer, delegatedResource, localTableName, localAuths, currentRange).setOptions(\n-                                myScan.getOptions());\n-                \n+                delegatedResource = ResourceFactory.initializeResource(initializer, delegatedResource, localTableName, localAuths, currentRange).setOptions(myScan.getOptions());\n+\n                 Iterator<Entry<Key,Value>> iter = delegatedResource.iterator();\n-                \n                 if (null != myStats)\n                     myStats.getTimer(TIMERS.SCANNER_START).suspend();\n                 // do not continue if we've reached the end of the corpus\n@@ -258,7 +237,7 @@ public class Scan implements Callable<Scan> {\n                         log.trace(\"We've started, but we have nothing to do on \" + localTableName + \" \" + localAuths + \" \" + currentRange);\n                     lastSeenKey = null;\n                 }\n-                \n+\n                 Entry<Key,Value> myEntry = null;\n                 if (null != myStats)\n                     myStats.getTimer(TIMERS.SCANNER_ITERATE).resume();\n@@ -266,61 +245,47 @@ public class Scan implements Callable<Scan> {\n                     if (!continueMultiScan)\n                         throw new Exception(\"Stopped mid cycle\");\n                     myEntry = iter.next();\n-                    \n                     while (!caller.isShutdown() && !results.offer(myEntry, 25, TimeUnit.MILLISECONDS)) {\n                         if (log.isTraceEnabled())\n                             log.trace(\"offering\");\n                     }\n-                    \n+\n+\n                     if (log.isTraceEnabled())\n                         log.trace(\"size of results \" + results.size() + \" is shutdown? \" + caller.isShutdown());\n-                    \n                     if (caller.isShutdown())\n                         break;\n-                    \n                     lastSeenKey = myEntry.getKey();\n                     if (log.isTraceEnabled())\n                         log.trace(\"last seen key is \" + lastSeenKey);\n                 }\n+\n+\n                 if (!iter.hasNext())\n                     lastSeenKey = null;\n                 \n                 // close early\n                 delegatorReference.close(delegatedResource);\n-                \n                 if (null != myStats)\n                     myStats.getTimer(TIMERS.SCANNER_ITERATE).suspend();\n-                \n                 if (log.isTraceEnabled())\n                     log.trace(\"not finished?\" + !finished());\n             } while (!finished());\n-        } catch (\n-        \n-        ScanTimedOutException e)\n-        \n-        {\n+        } catch (ScanTimedOutException e) {\n             // this is okay. This means that we are being timesliced.\n             myScan.addRange(currentRange);\n-        } catch (\n-        \n-        Exception e)\n-        \n-        {\n+        } catch (Exception e) {\n             log.error(\"exception \", e);\n             throw e;\n-        } finally\n-        \n-        {\n+        } finally {\n             if (null != delegatedResource) {\n                 delegatorReference.close(delegatedResource);\n             }\n         }\n         return this;\n-        \n     }\n-    \n+\n     static final AtomicLong scanIdFactory = new AtomicLong(0);\n-    \n     private String getNewScanId() {\n         long scanId = scanIdFactory.incrementAndGet();\n         return Long.toHexString(scanId);\n@@ -332,18 +297,22 @@ public class Scan implements Callable<Scan> {\n      * @param lastKey\n      * @param previousRange\n      */\n+\n     public Range buildNextRange(final Key lastKey, final Range previousRange) {\n-        return new Range(lastKey.followingKey(PartialKey.ROW_COLFAM_COLQUAL_COLVIS_TIME), true, previousRange.getEndKey(), previousRange.isEndKeyInclusive());\n+        return new Range(lastKey.followingKey(PartialKey.ROW_COLFAM_COLQUAL_COLVIS_TIME),\n+            true,\n+                previousRange.getEndKey(),\n+                    previousRange.isEndKeyInclusive());\n     }\n-    \n+\n     public ScanSessionStats getStats() {\n         return myStats;\n     }\n-    \n+\n     public void setSessionArbiter(SessionArbiter arbiter) {\n         this.arbiter = arbiter;\n     }\n-    \n+\n     public String getScanLocation() {\n         return myScan.getLastKnownLocation();\n     }\n@@ -352,6 +321,7 @@ public class Scan implements Callable<Scan> {\n      * Added because speculative scan could reach a condition by which we won't be closing the futures and therefore the batch scanner session won't close this\n      * Scan\n      */\n+\n     public void close() {\n         if (null != delegatedResource) {\n             try {\n@@ -365,8 +335,8 @@ public class Scan implements Callable<Scan> {\n     /**\n      * Disables Statistics for this scan.\n      */\n+\n     public void disableStats() {\n         myStats = null;\n     }\n-    \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 93
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "14",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "14",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ],
    "repaired_by": [],
    "not_repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}