{
    "project_name": "opencb-opencga",
    "error_id": "370",
    "information": {
        "errors": [
            {
                "line": "316",
                "column": "13",
                "severity": "error",
                "message": "'}' at column 13 should be alone on a line.",
                "source": "com.puppycrawl.tools.checkstyle.checks.blocks.RightCurlyCheck"
            }
        ]
    },
    "source_code": "                        .append(\" --\").append(CaseFormat.LOWER_CAMEL.to(CaseFormat.LOWER_HYPHEN, entry.getKey()))\n                        .append(\" \").append(file.getUri().getPath());\n            } if (entry.getKey().startsWith(\"-D\")) {\n                cliBuilder\n                        .append(\" \").append(entry.getKey())\n                        .append(\"=\").append(entry.getValue());",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "316",
                    "column": "13",
                    "severity": "error",
                    "message": "'}' at column 13 should be alone on a line.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.blocks.RightCurlyCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/370/ExecutionDaemon.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/intellij/370/ExecutionDaemon.java\nindex 6e734c900e0..0d23a3125af 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/370/ExecutionDaemon.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/intellij/370/ExecutionDaemon.java\n@@ -53,541 +53,542 @@ import java.util.*;\n  */\n public class ExecutionDaemon extends MonitorParentDaemon {\n \n-    private String internalCli;\n-    private JobManager jobManager;\n-    private FileManager fileManager;\n-    private CatalogIOManager catalogIOManager;\n-    private static final String ANALYSIS_RESULT_FILE = \"analysis-result.yml\";\n-\n-    // Maximum number of jobs of each type (Pending, queued, running) that will be handled on each iteration.\n-    // Example: If there are 100 pending jobs, 15 queued, 70 running.\n-    // On first iteration, it will queue 50 out of the 100 pending jobs. It will check up to 50 queue-running changes out of the 65\n-    // (15 + 50 from pending), and it will check up to 50 finished jobs from the running ones.\n-    // On second iteration, it will queue the remaining 50 pending jobs, and so on...\n-    private static final int NUM_JOBS_HANDLED = 50;\n-\n-    public ExecutionDaemon(int interval, String token, CatalogManager catalogManager, String appHome)\n-            throws CatalogDBException, CatalogIOException {\n-        super(interval, token, catalogManager);\n-        this.jobManager = catalogManager.getJobManager();\n-        this.fileManager = catalogManager.getFileManager();\n-        this.catalogIOManager = catalogManager.getCatalogIOManagerFactory().get(\"file\");\n-        this.internalCli = appHome + \"/bin/opencga-internal.sh\";\n-    }\n-\n-    @Override\n-    public void run() {\n-\n-        Query pendingJobsQuery = new Query(JobDBAdaptor.QueryParams.STATUS_NAME.key(), Job.JobStatus.PENDING);\n-        Query queuedJobsQuery = new Query(JobDBAdaptor.QueryParams.STATUS_NAME.key(), Job.JobStatus.QUEUED);\n-        Query runningJobsQuery = new Query(JobDBAdaptor.QueryParams.STATUS_NAME.key(), Job.JobStatus.RUNNING);\n-        // Sort jobs by priority and creation date\n-        QueryOptions queryOptions = new QueryOptions()\n-                .append(QueryOptions.SORT, Arrays.asList(JobDBAdaptor.QueryParams.PRIORITY.key(),\n-                        JobDBAdaptor.QueryParams.CREATION_DATE.key()))\n-                .append(QueryOptions.ORDER, QueryOptions.ASCENDING);\n-\n-        while (!exit) {\n-            try {\n-                Thread.sleep(interval);\n-            } catch (InterruptedException e) {\n-                if (!exit) {\n-                    e.printStackTrace();\n-                }\n-            }\n-            logger.info(\"----- EXECUTION DAEMON {} -----\", TimeUtils.getTimeMillis());\n+  private String internalCli;\n+  private JobManager jobManager;\n+  private FileManager fileManager;\n+  private CatalogIOManager catalogIOManager;\n+  private static final String ANALYSIS_RESULT_FILE = \"analysis-result.yml\";\n+\n+  // Maximum number of jobs of each type (Pending, queued, running) that will be handled on each iteration.\n+  // Example: If there are 100 pending jobs, 15 queued, 70 running.\n+  // On first iteration, it will queue 50 out of the 100 pending jobs. It will check up to 50 queue-running changes out of the 65\n+  // (15 + 50 from pending), and it will check up to 50 finished jobs from the running ones.\n+  // On second iteration, it will queue the remaining 50 pending jobs, and so on...\n+  private static final int NUM_JOBS_HANDLED = 50;\n+\n+  public ExecutionDaemon(int interval, String token, CatalogManager catalogManager, String appHome)\n+      throws CatalogDBException, CatalogIOException {\n+    super(interval, token, catalogManager);\n+    this.jobManager = catalogManager.getJobManager();\n+    this.fileManager = catalogManager.getFileManager();\n+    this.catalogIOManager = catalogManager.getCatalogIOManagerFactory().get(\"file\");\n+    this.internalCli = appHome + \"/bin/opencga-internal.sh\";\n+  }\n+\n+  @Override\n+  public void run() {\n+\n+    Query pendingJobsQuery = new Query(JobDBAdaptor.QueryParams.STATUS_NAME.key(), Job.JobStatus.PENDING);\n+    Query queuedJobsQuery = new Query(JobDBAdaptor.QueryParams.STATUS_NAME.key(), Job.JobStatus.QUEUED);\n+    Query runningJobsQuery = new Query(JobDBAdaptor.QueryParams.STATUS_NAME.key(), Job.JobStatus.RUNNING);\n+    // Sort jobs by priority and creation date\n+    QueryOptions queryOptions = new QueryOptions()\n+        .append(QueryOptions.SORT, Arrays.asList(JobDBAdaptor.QueryParams.PRIORITY.key(),\n+            JobDBAdaptor.QueryParams.CREATION_DATE.key()))\n+        .append(QueryOptions.ORDER, QueryOptions.ASCENDING);\n+\n+    while (!exit) {\n+      try {\n+        Thread.sleep(interval);\n+      } catch (InterruptedException e) {\n+        if (!exit) {\n+          e.printStackTrace();\n+        }\n+      }\n+      logger.info(\"----- EXECUTION DAEMON {} -----\", TimeUtils.getTimeMillis());\n \n             /*\n             PENDING JOBS\n              */\n-            try {\n-                long count = jobManager.count(pendingJobsQuery, token).getNumMatches();\n-                logger.debug(\"Checking pending jobs. {} jobs found\", count);\n-            } catch (CatalogException e) {\n-                logger.error(\"{}\", e.getMessage(), e);\n-            }\n-\n-            int handledPendingJobs = 0;\n-            try (DBIterator<Job> iterator = jobManager.iterator(pendingJobsQuery, queryOptions, token)) {\n-                while (handledPendingJobs < NUM_JOBS_HANDLED && iterator.hasNext()) {\n-                    handledPendingJobs += checkPendingJob(iterator.next());\n-                }\n-            } catch (CatalogException e) {\n-                logger.error(\"{}\", e.getMessage(), e);\n-            }\n+      try {\n+        long count = jobManager.count(pendingJobsQuery, token).getNumMatches();\n+        logger.debug(\"Checking pending jobs. {} jobs found\", count);\n+      } catch (CatalogException e) {\n+        logger.error(\"{}\", e.getMessage(), e);\n+      }\n+\n+      int handledPendingJobs = 0;\n+      try (DBIterator<Job> iterator = jobManager.iterator(pendingJobsQuery, queryOptions, token)) {\n+        while (handledPendingJobs < NUM_JOBS_HANDLED && iterator.hasNext()) {\n+          handledPendingJobs += checkPendingJob(iterator.next());\n+        }\n+      } catch (CatalogException e) {\n+        logger.error(\"{}\", e.getMessage(), e);\n+      }\n \n             /*\n             QUEUED JOBS\n              */\n-            try {\n-                long count = jobManager.count(queuedJobsQuery, token).getNumMatches();\n-                logger.debug(\"Checking queued jobs. {} jobs found\", count);\n-            } catch (CatalogException e) {\n-                logger.error(\"{}\", e.getMessage(), e);\n-            }\n-\n-            int handledQueuedJobs = 0;\n-            try (DBIterator<Job> iterator = jobManager.iterator(queuedJobsQuery, queryOptions, token)) {\n-                while (handledQueuedJobs < NUM_JOBS_HANDLED && iterator.hasNext()) {\n-                    handledQueuedJobs += checkQueuedJob(iterator.next());\n-                }\n-            } catch (CatalogException e) {\n-                logger.error(\"{}\", e.getMessage(), e);\n-            }\n+      try {\n+        long count = jobManager.count(queuedJobsQuery, token).getNumMatches();\n+        logger.debug(\"Checking queued jobs. {} jobs found\", count);\n+      } catch (CatalogException e) {\n+        logger.error(\"{}\", e.getMessage(), e);\n+      }\n+\n+      int handledQueuedJobs = 0;\n+      try (DBIterator<Job> iterator = jobManager.iterator(queuedJobsQuery, queryOptions, token)) {\n+        while (handledQueuedJobs < NUM_JOBS_HANDLED && iterator.hasNext()) {\n+          handledQueuedJobs += checkQueuedJob(iterator.next());\n+        }\n+      } catch (CatalogException e) {\n+        logger.error(\"{}\", e.getMessage(), e);\n+      }\n \n             /*\n             RUNNING JOBS\n              */\n-            try {\n-                long count = jobManager.count(runningJobsQuery, token).getNumMatches();\n-                logger.debug(\"Checking running jobs. {} running jobs found\", count);\n-            } catch (CatalogException e) {\n-                logger.error(\"{}\", e.getMessage(), e);\n-            }\n-\n-            int handledRunningJobs = 0;\n-            try (DBIterator<Job> iterator = jobManager.iterator(runningJobsQuery, queryOptions, token)) {\n-                while (handledRunningJobs < NUM_JOBS_HANDLED && iterator.hasNext()) {\n-                    handledRunningJobs += checkRunningJob(iterator.next());\n-                }\n-            } catch (CatalogException e) {\n-                logger.error(\"{}\", e.getMessage(), e);\n-            }\n-\n+      try {\n+        long count = jobManager.count(runningJobsQuery, token).getNumMatches();\n+        logger.debug(\"Checking running jobs. {} running jobs found\", count);\n+      } catch (CatalogException e) {\n+        logger.error(\"{}\", e.getMessage(), e);\n+      }\n+\n+      int handledRunningJobs = 0;\n+      try (DBIterator<Job> iterator = jobManager.iterator(runningJobsQuery, queryOptions, token)) {\n+        while (handledRunningJobs < NUM_JOBS_HANDLED && iterator.hasNext()) {\n+          handledRunningJobs += checkRunningJob(iterator.next());\n         }\n+      } catch (CatalogException e) {\n+        logger.error(\"{}\", e.getMessage(), e);\n+      }\n+\n     }\n+  }\n \n-    private int checkRunningJob(Job job) {\n-        Job.JobStatus jobStatus = getCurrentStatus(job);\n-\n-        if (Job.JobStatus.RUNNING.equals(jobStatus.getName())) {\n-            String analysisId = String.valueOf(job.getAttributes().get(Job.OPENCGA_COMMAND));\n-            AnalysisResult result = readAnalysisResult(analysisId, Paths.get(job.getTmpDir().getUri()));\n-            if (result != null) {\n-                // Update the result of the job\n-                JobUpdateParams updateParams = new JobUpdateParams().setResult(result);\n-                String study = String.valueOf(job.getAttributes().get(Job.OPENCGA_STUDY));\n-                try {\n-                    jobManager.update(study, job.getId(), updateParams, QueryOptions.empty(), token);\n-                } catch (CatalogException e) {\n-                    logger.error(\"{} - Could not update result information: {}\", job.getId(), e.getMessage(), e);\n-                    return 0;\n-                }\n-            }\n+  private int checkRunningJob(Job job) {\n+    Job.JobStatus jobStatus = getCurrentStatus(job);\n \n-            return 1;\n-        } else {\n-            // Register job results\n-            return processFinishedJob(job);\n+    if (Job.JobStatus.RUNNING.equals(jobStatus.getName())) {\n+      String analysisId = String.valueOf(job.getAttributes().get(Job.OPENCGA_COMMAND));\n+      AnalysisResult result = readAnalysisResult(analysisId, Paths.get(job.getTmpDir().getUri()));\n+      if (result != null) {\n+        // Update the result of the job\n+        JobUpdateParams updateParams = new JobUpdateParams().setResult(result);\n+        String study = String.valueOf(job.getAttributes().get(Job.OPENCGA_STUDY));\n+        try {\n+          jobManager.update(study, job.getId(), updateParams, QueryOptions.empty(), token);\n+        } catch (CatalogException e) {\n+          logger.error(\"{} - Could not update result information: {}\", job.getId(), e.getMessage(), e);\n+          return 0;\n         }\n+      }\n+\n+      return 1;\n+    } else {\n+      // Register job results\n+      return processFinishedJob(job);\n+    }\n+  }\n+\n+  /**\n+   * Check if the job is still queued or it has changed to running or error.\n+   *\n+   * @param job Job object.\n+   * @return 1 if the job has changed the status, 0 otherwise.\n+   */\n+  private int checkQueuedJob(Job job) {\n+    Job.JobStatus status = getCurrentStatus(job);\n+\n+    if (Job.JobStatus.QUEUED.equals(status.getName())) {\n+      // Job is still queued\n+      return 0;\n     }\n \n-    /**\n-     * Check if the job is still queued or it has changed to running or error.\n-     *\n-     * @param job Job object.\n-     * @return 1 if the job has changed the status, 0 otherwise.\n-     */\n-    private int checkQueuedJob(Job job) {\n-        Job.JobStatus status = getCurrentStatus(job);\n-\n-        if (Job.JobStatus.QUEUED.equals(status.getName())) {\n-            // Job is still queued\n-            return 0;\n-        }\n+    if (Job.JobStatus.RUNNING.equals(status.getName())) {\n+      logger.info(\"Updating job {} from {} to {}\", job.getId(), Job.JobStatus.QUEUED, Job.JobStatus.RUNNING);\n+      return setStatus(job, new Job.JobStatus(Job.JobStatus.RUNNING));\n+    }\n \n-        if (Job.JobStatus.RUNNING.equals(status.getName())) {\n-            logger.info(\"Updating job {} from {} to {}\", job.getId(), Job.JobStatus.QUEUED, Job.JobStatus.RUNNING);\n-            return setStatus(job, new Job.JobStatus(Job.JobStatus.RUNNING));\n-        }\n+    // Job has finished the execution, so we need to register the job results\n+    return processFinishedJob(job);\n+  }\n+\n+  /**\n+   * Check everything is correct and queues the job.\n+   *\n+   * @param job Job object.\n+   * @return 1 if the job has changed the status, 0 otherwise.\n+   */\n+  private int checkPendingJob(Job job) {\n+    String study = String.valueOf(job.getAttributes().get(Job.OPENCGA_STUDY));\n+    if (study.isEmpty()) {\n+      return abortJob(job, \"Missing mandatory '\" + Job.OPENCGA_STUDY + \"' field\");\n+    }\n \n-        // Job has finished the execution, so we need to register the job results\n-        return processFinishedJob(job);\n+    String command = String.valueOf(job.getAttributes().get(Job.OPENCGA_COMMAND));\n+    if (command.isEmpty()) {\n+      return abortJob(job, \"Missing mandatory '\" + Job.OPENCGA_COMMAND + \"' field\");\n     }\n \n-    /**\n-     * Check everything is correct and queues the job.\n-     *\n-     * @param job Job object.\n-     * @return 1 if the job has changed the status, 0 otherwise.\n-     */\n-    private int checkPendingJob(Job job) {\n-        String study = String.valueOf(job.getAttributes().get(Job.OPENCGA_STUDY));\n-        if (study.isEmpty()) {\n-            return abortJob(job, \"Missing mandatory '\" + Job.OPENCGA_STUDY + \"' field\");\n-        }\n+    String subcommand = String.valueOf(job.getAttributes().get(Job.OPENCGA_SUBCOMMAND));\n+    if (subcommand.isEmpty()) {\n+      return abortJob(job, \"Missing mandatory '\" + Job.OPENCGA_SUBCOMMAND + \"' field\");\n+    }\n \n-        String command = String.valueOf(job.getAttributes().get(Job.OPENCGA_COMMAND));\n-        if (command.isEmpty()) {\n-            return abortJob(job, \"Missing mandatory '\" + Job.OPENCGA_COMMAND + \"' field\");\n-        }\n+    String outDirPath = String.valueOf(job.getParams().get(\"outdir\"));\n+    if (outDirPath.isEmpty()) {\n+      return abortJob(job, \"Missing mandatory output directory\");\n+    }\n+    if (!outDirPath.endsWith(\"/\")) {\n+      return abortJob(job, \"Invalid output directory. Valid directories should end in /\");\n+    }\n \n-        String subcommand = String.valueOf(job.getAttributes().get(Job.OPENCGA_SUBCOMMAND));\n-        if (subcommand.isEmpty()) {\n-            return abortJob(job, \"Missing mandatory '\" + Job.OPENCGA_SUBCOMMAND + \"' field\");\n-        }\n+    if (!canBeQueued(job)) {\n+      return 0;\n+    }\n \n-        String outDirPath = String.valueOf(job.getParams().get(\"outdir\"));\n-        if (outDirPath.isEmpty()) {\n-            return abortJob(job, \"Missing mandatory output directory\");\n-        }\n-        if (!outDirPath.endsWith(\"/\")) {\n-            return abortJob(job, \"Invalid output directory. Valid directories should end in /\");\n-        }\n+    String userToken;\n+    try {\n+      userToken = catalogManager.getUserManager().getSystemTokenForUser(job.getUserId(), token);\n+    } catch (CatalogException e) {\n+      return abortJob(job, \"Internal error. Could not obtain token for user '\" + job.getUserId() + \"'\");\n+    }\n \n-        if (!canBeQueued(job)) {\n-            return 0;\n-        }\n+    JobUpdateParams updateParams = new JobUpdateParams();\n+\n+    // TODO: Remove this line when we stop passing the outdir as a query param in the URL\n+    outDirPath = outDirPath.replace(\":\", \"/\");\n+    try {\n+      OpenCGAResult<File> fileOpenCGAResult = fileManager.get(study, outDirPath,\n+          FileManager.INCLUDE_FILE_URI_PATH, token);\n+      // Directory exists\n+      updateParams.setOutDir(fileOpenCGAResult.first());\n+    } catch (CatalogException e) {\n+      // Directory not found. Will try to create using user's token\n+      boolean parents = (boolean) job.getAttributes().getOrDefault(Job.OPENCGA_PARENTS, false);\n+      try {\n+        File folder = fileManager.createFolder(study, outDirPath, new File.FileStatus(), parents, \"\",\n+            FileManager.INCLUDE_FILE_URI_PATH, userToken).first();\n+        updateParams.setOutDir(folder);\n+      } catch (CatalogException e1) {\n+        // Directory could not be created\n+        logger.error(\"Cannot create output directory. {}\", e1.getMessage(), e1);\n+        return abortJob(job, \"Cannot create output directory. \" + e1.getMessage());\n+      }\n+    }\n \n-        String userToken;\n-        try {\n-            userToken = catalogManager.getUserManager().getSystemTokenForUser(job.getUserId(), token);\n-        } catch (CatalogException e) {\n-            return abortJob(job, \"Internal error. Could not obtain token for user '\" + job.getUserId() + \"'\");\n-        }\n+    // Create temporal directory\n+    try {\n+      String tmpDir = updateParams.getOutDir().getPath() + \"job_\" + job.getId() + \"_temp/\";\n+      File folder = fileManager.createFolder(study, tmpDir, new File.FileStatus(), false, \"\",\n+          FileManager.INCLUDE_FILE_URI_PATH, userToken).first();\n+      updateParams.setTmpDir(folder);\n+    } catch (CatalogException e) {\n+      // Directory could not be created\n+      logger.error(\"Cannot create temporal directory. {}\", e.getMessage(), e);\n+      return abortJob(job, \"Cannot create temporal directory. \" + e.getMessage());\n+    }\n \n-        JobUpdateParams updateParams = new JobUpdateParams();\n+    Path temporalPath = Paths.get(updateParams.getTmpDir().getUri());\n \n-        // TODO: Remove this line when we stop passing the outdir as a query param in the URL\n-        outDirPath = outDirPath.replace(\":\", \"/\");\n-        try {\n-            OpenCGAResult<File> fileOpenCGAResult = fileManager.get(study, outDirPath,\n-                    FileManager.INCLUDE_FILE_URI_PATH, token);\n-            // Directory exists\n-            updateParams.setOutDir(fileOpenCGAResult.first());\n-        } catch (CatalogException e) {\n-            // Directory not found. Will try to create using user's token\n-            boolean parents = (boolean) job.getAttributes().getOrDefault(Job.OPENCGA_PARENTS, false);\n-            try {\n-                File folder = fileManager.createFolder(study, outDirPath, new File.FileStatus(), parents, \"\",\n-                        FileManager.INCLUDE_FILE_URI_PATH, userToken).first();\n-                updateParams.setOutDir(folder);\n-            } catch (CatalogException e1) {\n-                // Directory could not be created\n-                logger.error(\"Cannot create output directory. {}\", e1.getMessage(), e1);\n-                return abortJob(job, \"Cannot create output directory. \" + e1.getMessage());\n-            }\n-        }\n+    // Define where the stdout and stderr will be stored\n+    Path stderr = temporalPath.resolve(job.getId() + \".err\");\n+    Path stdout = temporalPath.resolve(job.getId() + \".log\");\n \n-        // Create temporal directory\n-        try {\n-            String tmpDir = updateParams.getOutDir().getPath() + \"job_\" + job.getId() + \"_temp/\";\n-            File folder = fileManager.createFolder(study, tmpDir, new File.FileStatus(), false, \"\",\n-                    FileManager.INCLUDE_FILE_URI_PATH, userToken).first();\n-            updateParams.setTmpDir(folder);\n-        } catch (CatalogException e) {\n-            // Directory could not be created\n-            logger.error(\"Cannot create temporal directory. {}\", e.getMessage(), e);\n-            return abortJob(job, \"Cannot create temporal directory. \" + e.getMessage());\n-        }\n+    List<File> inputFiles = new ArrayList<>();\n \n-        Path temporalPath = Paths.get(updateParams.getTmpDir().getUri());\n-\n-        // Define where the stdout and stderr will be stored\n-        Path stderr = temporalPath.resolve(job.getId() + \".err\");\n-        Path stdout = temporalPath.resolve(job.getId() + \".log\");\n-\n-        List<File> inputFiles = new ArrayList<>();\n-\n-        // Create cli\n-        StringBuilder cliBuilder = new StringBuilder(internalCli).append(\" \")\n-                .append(command).append(\" \")\n-                .append(subcommand);\n-        for (Map.Entry<String, String> entry : job.getParams().entrySet()) {\n-            if (entry.getKey().equals(\"outdir\")) {\n-                cliBuilder.append(\" --outdir \").append(temporalPath);\n-            } else if (entry.getKey().toLowerCase().endsWith(\"file\")) {\n-                // We assume that every variable ending in 'file' corresponds to input files that need to be accessible in catalog\n-                File file;\n-                try {\n-                    file = fileManager.get(study, entry.getValue(), FileManager.INCLUDE_FILE_URI_PATH, userToken)\n-                            .first();\n-                } catch (CatalogException e) {\n-                    logger.error(\"Cannot find file '{}' from variable '{}'. {}\", entry.getValue(), entry.getKey(), e.getMessage(), e);\n-                    return abortJob(job, \"Cannot find file '\" + entry.getValue() + \"' from variable '\" + entry.getKey() + \"'. \"\n-                            + e.getMessage());\n-                }\n-                inputFiles.add(file);\n-\n-                // And we change the reference for the actual uri\n-                cliBuilder\n-                        .append(\" --\").append(CaseFormat.LOWER_CAMEL.to(CaseFormat.LOWER_HYPHEN, entry.getKey()))\n-                        .append(\" \").append(file.getUri().getPath());\n-            } if (entry.getKey().startsWith(\"-D\")) {\n-                cliBuilder\n-                        .append(\" \").append(entry.getKey())\n-                        .append(\"=\").append(entry.getValue());\n-            } else {\n-                cliBuilder\n-                        .append(\" --\").append(CaseFormat.LOWER_CAMEL.to(CaseFormat.LOWER_HYPHEN, entry.getKey()))\n-                        .append(\" \").append(entry.getValue());\n-            }\n-        }\n-        updateParams.setCommandLine(cliBuilder.toString());\n-        updateParams.setInput(inputFiles);\n-\n-        logger.info(\"Updating job {} from {} to {}\", job.getId(), Job.JobStatus.PENDING, Job.JobStatus.QUEUED);\n-        updateParams.setStatus(new Job.JobStatus(Job.JobStatus.QUEUED));\n+    // Create cli\n+    StringBuilder cliBuilder = new StringBuilder(internalCli).append(\" \")\n+        .append(command).append(\" \")\n+        .append(subcommand);\n+    for (Map.Entry<String, String> entry : job.getParams().entrySet()) {\n+      if (entry.getKey().equals(\"outdir\")) {\n+        cliBuilder.append(\" --outdir \").append(temporalPath);\n+      } else if (entry.getKey().toLowerCase().endsWith(\"file\")) {\n+        // We assume that every variable ending in 'file' corresponds to input files that need to be accessible in catalog\n+        File file;\n         try {\n-            jobManager.update(study, job.getId(), updateParams, QueryOptions.empty(), token);\n-            executeJob(job.getId(), updateParams.getCommandLine(), stdout, stderr, userToken);\n+          file = fileManager.get(study, entry.getValue(), FileManager.INCLUDE_FILE_URI_PATH, userToken)\n+              .first();\n         } catch (CatalogException e) {\n-            logger.error(\"Could not update job {}. {}\", job.getId(), e.getMessage(), e);\n-            return 0;\n+          logger.error(\"Cannot find file '{}' from variable '{}'. {}\", entry.getValue(), entry.getKey(), e.getMessage(), e);\n+          return abortJob(job, \"Cannot find file '\" + entry.getValue() + \"' from variable '\" + entry.getKey() + \"'. \"\n+              + e.getMessage());\n         }\n-\n-        return 1;\n+        inputFiles.add(file);\n+\n+        // And we change the reference for the actual uri\n+        cliBuilder\n+            .append(\" --\").append(CaseFormat.LOWER_CAMEL.to(CaseFormat.LOWER_HYPHEN, entry.getKey()))\n+            .append(\" \").append(file.getUri().getPath());\n+      }\n+      if (entry.getKey().startsWith(\"-D\")) {\n+        cliBuilder\n+            .append(\" \").append(entry.getKey())\n+            .append(\"=\").append(entry.getValue());\n+      } else {\n+        cliBuilder\n+            .append(\" --\").append(CaseFormat.LOWER_CAMEL.to(CaseFormat.LOWER_HYPHEN, entry.getKey()))\n+            .append(\" \").append(entry.getValue());\n+      }\n+    }\n+    updateParams.setCommandLine(cliBuilder.toString());\n+    updateParams.setInput(inputFiles);\n+\n+    logger.info(\"Updating job {} from {} to {}\", job.getId(), Job.JobStatus.PENDING, Job.JobStatus.QUEUED);\n+    updateParams.setStatus(new Job.JobStatus(Job.JobStatus.QUEUED));\n+    try {\n+      jobManager.update(study, job.getId(), updateParams, QueryOptions.empty(), token);\n+      executeJob(job.getId(), updateParams.getCommandLine(), stdout, stderr, userToken);\n+    } catch (CatalogException e) {\n+      logger.error(\"Could not update job {}. {}\", job.getId(), e.getMessage(), e);\n+      return 0;\n     }\n \n-    private boolean canBeQueued(Job job) {\n-        String command = String.valueOf(job.getAttributes().get(Job.OPENCGA_COMMAND));\n-        String subcommand = String.valueOf(job.getAttributes().get(Job.OPENCGA_SUBCOMMAND));\n+    return 1;\n+  }\n \n-        if (\"variant\".equals(command) && \"index\".equals(subcommand)) {\n-            // TODO: Check maximum number of slots for variant index\n-            logger.info(\"{} index jobs running or in queue already. Skipping new index job '{}' temporary\", 10, job.getId());\n-            return false;\n-        }\n+  private boolean canBeQueued(Job job) {\n+    String command = String.valueOf(job.getAttributes().get(Job.OPENCGA_COMMAND));\n+    String subcommand = String.valueOf(job.getAttributes().get(Job.OPENCGA_SUBCOMMAND));\n \n-        return true;\n+    if (\"variant\".equals(command) && \"index\".equals(subcommand)) {\n+      // TODO: Check maximum number of slots for variant index\n+      logger.info(\"{} index jobs running or in queue already. Skipping new index job '{}' temporary\", 10, job.getId());\n+      return false;\n     }\n \n-    private int abortJob(Job job, String description) {\n-        logger.info(\"{} - Aborting job...\", job.getId());\n-        return setStatus(job, new Job.JobStatus(Job.JobStatus.ABORTED, description));\n+    return true;\n+  }\n+\n+  private int abortJob(Job job, String description) {\n+    logger.info(\"{} - Aborting job...\", job.getId());\n+    return setStatus(job, new Job.JobStatus(Job.JobStatus.ABORTED, description));\n+  }\n+\n+  private int setStatus(Job job, Job.JobStatus status) {\n+    JobUpdateParams updateParams = new JobUpdateParams().setStatus(status);\n+\n+    String study = String.valueOf(job.getAttributes().get(Job.OPENCGA_STUDY));\n+    if (StringUtils.isEmpty(study)) {\n+      try {\n+        study = jobManager.getStudy(job, token).getFqn();\n+      } catch (CatalogException e) {\n+        logger.error(\"Unexpected error. Unknown study of job '{}'. {}\", job.getId(), e.getMessage(), e);\n+        return 0;\n+      }\n     }\n \n-    private int setStatus(Job job, Job.JobStatus status) {\n-        JobUpdateParams updateParams = new JobUpdateParams().setStatus(status);\n+    try {\n+      jobManager.update(study, job.getId(), updateParams, QueryOptions.empty(), token);\n+    } catch (CatalogException e) {\n+      logger.error(\"Unexpected error. Cannot update job '{}' to status '{}'. {}\", job.getId(), updateParams.getStatus().getName(),\n+          e.getMessage(), e);\n+      return 0;\n+    }\n \n-        String study = String.valueOf(job.getAttributes().get(Job.OPENCGA_STUDY));\n-        if (StringUtils.isEmpty(study)) {\n-            try {\n-                study = jobManager.getStudy(job, token).getFqn();\n-            } catch (CatalogException e) {\n-                logger.error(\"Unexpected error. Unknown study of job '{}'. {}\", job.getId(), e.getMessage(), e);\n-                return 0;\n-            }\n-        }\n+    return 1;\n+  }\n+\n+  private Job.JobStatus getCurrentStatus(Job job) {\n+    Path tmpOutdirPath = Paths.get(job.getTmpDir().getUri());\n+\n+    // Check if analysis result file is there\n+    if (Files.exists(tmpOutdirPath.resolve(ANALYSIS_RESULT_FILE))) {\n+      String analysisId = String.valueOf(job.getAttributes().get(Job.OPENCGA_COMMAND));\n+      AnalysisResult analysisResult = readAnalysisResult(analysisId, tmpOutdirPath);\n+      if (analysisResult != null) {\n+        return new Job.JobStatus(analysisResult.getStatus().getName().name());\n+      } else {\n+        return new Job.JobStatus(Job.JobStatus.ERROR, \"File '\" + ANALYSIS_RESULT_FILE + \"' seems corrupted.\");\n+      }\n+    } else {\n+      // Check if the error file is present\n+      Path errorLog = tmpOutdirPath.resolve(job.getId() + \".err\");\n+\n+      if (Files.exists(errorLog)) {\n+        // There must be some command line error. The job started running but did not finish well, otherwise we would find the\n+        // analysis-result.yml file\n+        return new Job.JobStatus(Job.JobStatus.ERROR, \"Command line error\");\n+      } else {\n+        return new Job.JobStatus(Job.JobStatus.QUEUED);\n+      }\n+    }\n+  }\n+\n+  private AnalysisResult readAnalysisResult(String analysisId, Path directory) {\n+    AnalysisResultManager manager;\n+    int maxAttempts = 0;\n+    try {\n+      manager = new AnalysisResultManager(analysisId, directory);\n+    } catch (AnalysisException e) {\n+      logger.error(\"Could not initialise AnalysisResultManager {}\", e.getMessage(), e);\n+      return null;\n+    }\n+    while (maxAttempts < 2) {\n+      try {\n+        return manager.read();\n+      } catch (AnalysisException e) {\n+        logger.warn(\"Could not load AnalysisResult file. {}\", e.getMessage(), e);\n+        maxAttempts++;\n+      }\n+    }\n \n-        try {\n-            jobManager.update(study, job.getId(), updateParams, QueryOptions.empty(), token);\n-        } catch (CatalogException e) {\n-            logger.error(\"Unexpected error. Cannot update job '{}' to status '{}'. {}\", job.getId(), updateParams.getStatus().getName(),\n-                    e.getMessage(), e);\n-            return 0;\n-        }\n+    return null;\n+  }\n \n-        return 1;\n-    }\n+  private int processFinishedJob(Job job) {\n+    logger.info(\"{} - Processing finished job...\", job.getId());\n \n-    private Job.JobStatus getCurrentStatus(Job job) {\n-        Path tmpOutdirPath = Paths.get(job.getTmpDir().getUri());\n-\n-        // Check if analysis result file is there\n-        if (Files.exists(tmpOutdirPath.resolve(ANALYSIS_RESULT_FILE))) {\n-            String analysisId = String.valueOf(job.getAttributes().get(Job.OPENCGA_COMMAND));\n-            AnalysisResult analysisResult = readAnalysisResult(analysisId, tmpOutdirPath);\n-            if (analysisResult != null) {\n-                return new Job.JobStatus(analysisResult.getStatus().getName().name());\n-            } else {\n-                return new Job.JobStatus(Job.JobStatus.ERROR, \"File '\" + ANALYSIS_RESULT_FILE + \"' seems corrupted.\");\n-            }\n-        } else {\n-            // Check if the error file is present\n-            Path errorLog = tmpOutdirPath.resolve(job.getId() + \".err\");\n-\n-            if (Files.exists(errorLog)) {\n-                // There must be some command line error. The job started running but did not finish well, otherwise we would find the\n-                // analysis-result.yml file\n-                return new Job.JobStatus(Job.JobStatus.ERROR, \"Command line error\");\n-            } else {\n-                return new Job.JobStatus(Job.JobStatus.QUEUED);\n-            }\n-        }\n-    }\n+    Path outDirPath = Paths.get(job.getOutDir().getPath());\n+    Path outDirUri = Paths.get(job.getOutDir().getUri());\n+    URI tmpOutdirUri = job.getTmpDir().getUri();\n \n-    private AnalysisResult readAnalysisResult(String analysisId, Path directory) {\n-        AnalysisResultManager manager;\n-        int maxAttempts = 0;\n-        try {\n-            manager = new AnalysisResultManager(analysisId, directory);\n-        } catch (AnalysisException e) {\n-            logger.error(\"Could not initialise AnalysisResultManager {}\", e.getMessage(), e);\n-            return null;\n-        }\n-        while (maxAttempts < 2) {\n-            try {\n-                return manager.read();\n-            } catch (AnalysisException e) {\n-                logger.warn(\"Could not load AnalysisResult file. {}\", e.getMessage(), e);\n-                maxAttempts++;\n-            }\n-        }\n+    String study = String.valueOf(job.getAttributes().get(Job.OPENCGA_STUDY));\n \n-        return null;\n-    }\n+    logger.info(\"{} - Moving data from temporary folder {} to catalog folder {}\", job.getId(), tmpOutdirUri, outDirUri);\n \n-    private int processFinishedJob(Job job) {\n-        logger.info(\"{} - Processing finished job...\", job.getId());\n+    // Because we don't want to lose any data and an error could eventually happen while we are processing the files, we will first\n+    // read the list of output files from the Job information in case this ever happened and some files were already processed.\n+    Set<String> outputFileIdSet = new HashSet<>();\n+    List<File> outputFiles = new ArrayList<>();\n+    if (job.getOutput() != null && !job.getOutput().isEmpty()) {\n+      for (File file : job.getOutput()) {\n+        outputFileIdSet.add(file.getPath());\n+        outputFiles.add(file);\n+      }\n+    }\n \n-        Path outDirPath = Paths.get(job.getOutDir().getPath());\n-        Path outDirUri = Paths.get(job.getOutDir().getUri());\n-        URI tmpOutdirUri = job.getTmpDir().getUri();\n+    // For each file (apart from analysis-result.yml), try to register it in outDirPath\n+    Iterator<URI> uriIterator;\n+    try {\n+      uriIterator = catalogIOManager.listFilesStream(tmpOutdirUri).iterator();\n+    } catch (CatalogIOException e) {\n+      logger.error(\"{} - Could not list files from temporal directory {}: {}\", job.getId(), tmpOutdirUri, e.getMessage(), e);\n+      return 0;\n+    }\n \n-        String study = String.valueOf(job.getAttributes().get(Job.OPENCGA_STUDY));\n+    boolean allFilesMoved = true;\n \n-        logger.info(\"{} - Moving data from temporary folder {} to catalog folder {}\", job.getId(), tmpOutdirUri, outDirUri);\n+    while (uriIterator.hasNext()) {\n+      URI fileUri = uriIterator.next();\n+      java.io.File file = new java.io.File(fileUri);\n \n-        // Because we don't want to lose any data and an error could eventually happen while we are processing the files, we will first\n-        // read the list of output files from the Job information in case this ever happened and some files were already processed.\n-        Set<String> outputFileIdSet = new HashSet<>();\n-        List<File> outputFiles = new ArrayList<>();\n-        if (job.getOutput() != null && !job.getOutput().isEmpty()) {\n-            for (File file : job.getOutput()) {\n-                outputFileIdSet.add(file.getPath());\n-                outputFiles.add(file);\n-            }\n-        }\n+      if (ANALYSIS_RESULT_FILE.equals(file.getName())) {\n+        // We will handle this file when everything is moved.\n+        continue;\n+      }\n \n-        // For each file (apart from analysis-result.yml), try to register it in outDirPath\n-        Iterator<URI> uriIterator;\n-        try {\n-            uriIterator = catalogIOManager.listFilesStream(tmpOutdirUri).iterator();\n-        } catch (CatalogIOException e) {\n-            logger.error(\"{} - Could not list files from temporal directory {}: {}\", job.getId(), tmpOutdirUri, e.getMessage(), e);\n-            return 0;\n-        }\n+      Path finalFilePath = outDirPath.resolve(file.getName());\n+      Query query = new Query(FileDBAdaptor.QueryParams.PATH.key(), finalFilePath);\n+      File registeredFile = null;\n \n-        boolean allFilesMoved = true;\n+      URI finalFileUri = finalFilePath.toUri();\n+      // If there is not file registered under that name in the final path and there is no file with the same name in the file system\n+      // in the final uri\n \n-        while (uriIterator.hasNext()) {\n-            URI fileUri = uriIterator.next();\n-            java.io.File file = new java.io.File(fileUri);\n+      try {\n+        if (fileManager.count(study, query, token).getNumMatches() == 0 && !catalogIOManager.exists(finalFileUri)) {\n+          logger.info(\"{} - Moving and registering file to {}\", job.getId(), finalFilePath);\n \n-            if (ANALYSIS_RESULT_FILE.equals(file.getName())) {\n-                // We will handle this file when everything is moved.\n-                continue;\n-            }\n+          // We can directly move the file ...\n+          catalogIOManager.moveFile(fileUri, finalFileUri);\n \n-            Path finalFilePath = outDirPath.resolve(file.getName());\n-            Query query = new Query(FileDBAdaptor.QueryParams.PATH.key(), finalFilePath);\n-            File registeredFile = null;\n+          // Register the file in catalog\n+          registeredFile = fileManager.register(study, finalFilePath, FileManager.INCLUDE_FILE_URI_PATH, token).first();\n+        } else {\n+          logger.warn(\"{} - File '{}' already exists in the final path. Registering directly from the temporal directory\",\n+              job.getId(), file.getName());\n \n-            URI finalFileUri = finalFilePath.toUri();\n-            // If there is not file registered under that name in the final path and there is no file with the same name in the file system\n-            // in the final uri\n+          // The path is in use. Cannot move file to final path so we register it from the temporal directory\n+          registeredFile = fileManager.register(study, file.toPath(), FileManager.INCLUDE_FILE_URI_PATH, token).first();\n \n+          // We mark that there has been a problem and at least this file was not possible to be moved to the final directory\n+          allFilesMoved = false;\n+        }\n+      } catch (CatalogException e) {\n+        logger.error(\"{} - Unexpected error while processing the files: {}\", job.getId(), e.getMessage(), e);\n+\n+        if (registeredFile != null) {\n+          if (!outputFileIdSet.contains(registeredFile.getPath())) {\n+            outputFiles.add(registeredFile);\n+            outputFileIdSet.add(registeredFile.getPath());\n+          }\n+        }\n+        if (!outputFiles.isEmpty()) {\n+          // Because some of the files will probably have been moved and deleted, we will store the output files in job so this\n+          // information is not lost\n+          if (job.getOutput() == null || job.getOutput().size() < outputFiles.size()) {\n+            JobUpdateParams updateParams = new JobUpdateParams().setOutput(outputFiles);\n+            logger.error(\"{} - Registering processed output files in job\", job.getId());\n             try {\n-                if (fileManager.count(study, query, token).getNumMatches() == 0 && !catalogIOManager.exists(finalFileUri)) {\n-                    logger.info(\"{} - Moving and registering file to {}\", job.getId(), finalFilePath);\n-\n-                    // We can directly move the file ...\n-                    catalogIOManager.moveFile(fileUri, finalFileUri);\n-\n-                    // Register the file in catalog\n-                    registeredFile = fileManager.register(study, finalFilePath, FileManager.INCLUDE_FILE_URI_PATH, token).first();\n-                } else {\n-                    logger.warn(\"{} - File '{}' already exists in the final path. Registering directly from the temporal directory\",\n-                            job.getId(), file.getName());\n-\n-                    // The path is in use. Cannot move file to final path so we register it from the temporal directory\n-                    registeredFile = fileManager.register(study, file.toPath(), FileManager.INCLUDE_FILE_URI_PATH, token).first();\n-\n-                    // We mark that there has been a problem and at least this file was not possible to be moved to the final directory\n-                    allFilesMoved = false;\n-                }\n-            } catch (CatalogException e) {\n-                logger.error(\"{} - Unexpected error while processing the files: {}\", job.getId(), e.getMessage(), e);\n-\n-                if (registeredFile != null) {\n-                    if (!outputFileIdSet.contains(registeredFile.getPath())) {\n-                        outputFiles.add(registeredFile);\n-                        outputFileIdSet.add(registeredFile.getPath());\n-                    }\n-                }\n-                if (!outputFiles.isEmpty()) {\n-                    // Because some of the files will probably have been moved and deleted, we will store the output files in job so this\n-                    // information is not lost\n-                    if (job.getOutput() == null || job.getOutput().size() < outputFiles.size()) {\n-                        JobUpdateParams updateParams = new JobUpdateParams().setOutput(outputFiles);\n-                        logger.error(\"{} - Registering processed output files in job\", job.getId());\n-                        try {\n-                            jobManager.update(study, job.getId(), updateParams, QueryOptions.empty(), token);\n-                        } catch (CatalogException e1) {\n-                            logger.error(\"{} - Catastrophic error. Could not save processed output files in job: {}\", job.getId(),\n-                                    e1.getMessage(), e1);\n-                            logger.error(\"{} - List of job paths that could not be registered is: {}\", job.getId(), outputFileIdSet);\n-                        }\n-                    }\n-                }\n-\n-                return 0;\n-            }\n-\n-            // Add registered file to list of output files of Job\n-            if (!outputFileIdSet.contains(registeredFile.getPath())) {\n-                outputFiles.add(registeredFile);\n-                outputFileIdSet.add(registeredFile.getPath());\n+              jobManager.update(study, job.getId(), updateParams, QueryOptions.empty(), token);\n+            } catch (CatalogException e1) {\n+              logger.error(\"{} - Catastrophic error. Could not save processed output files in job: {}\", job.getId(),\n+                  e1.getMessage(), e1);\n+              logger.error(\"{} - List of job paths that could not be registered is: {}\", job.getId(), outputFileIdSet);\n             }\n+          }\n         }\n \n-        // Register the job information\n-        JobUpdateParams updateParams = new JobUpdateParams();\n-        String analysisId = String.valueOf(job.getAttributes().get(Job.OPENCGA_COMMAND));\n-        AnalysisResult analysisResult = readAnalysisResult(analysisId, Paths.get(tmpOutdirUri));\n+        return 0;\n+      }\n \n-        updateParams.setResult(analysisResult);\n-        updateParams.setOutput(outputFiles);\n+      // Add registered file to list of output files of Job\n+      if (!outputFileIdSet.contains(registeredFile.getPath())) {\n+        outputFiles.add(registeredFile);\n+        outputFileIdSet.add(registeredFile.getPath());\n+      }\n+    }\n \n-        // Check status of analysis result or if there are files that could not be moved to outdir to decide the final result\n-        if (analysisResult.getStatus().getName().equals(Status.Type.ERROR)) {\n-            updateParams.setStatus(new Job.JobStatus(Job.JobStatus.ERROR, \"Job could not finish successfully\"));\n-        } else if (allFilesMoved) {\n-            updateParams.setStatus(new Job.JobStatus(Job.JobStatus.DONE));\n-        } else {\n-            updateParams.setStatus(new Job.JobStatus(Job.JobStatus.UNREGISTERED, \"Some files could not be moved to the final path\"));\n-        }\n+    // Register the job information\n+    JobUpdateParams updateParams = new JobUpdateParams();\n+    String analysisId = String.valueOf(job.getAttributes().get(Job.OPENCGA_COMMAND));\n+    AnalysisResult analysisResult = readAnalysisResult(analysisId, Paths.get(tmpOutdirUri));\n+\n+    updateParams.setResult(analysisResult);\n+    updateParams.setOutput(outputFiles);\n+\n+    // Check status of analysis result or if there are files that could not be moved to outdir to decide the final result\n+    if (analysisResult.getStatus().getName().equals(Status.Type.ERROR)) {\n+      updateParams.setStatus(new Job.JobStatus(Job.JobStatus.ERROR, \"Job could not finish successfully\"));\n+    } else if (allFilesMoved) {\n+      updateParams.setStatus(new Job.JobStatus(Job.JobStatus.DONE));\n+    } else {\n+      updateParams.setStatus(new Job.JobStatus(Job.JobStatus.UNREGISTERED, \"Some files could not be moved to the final path\"));\n+    }\n \n-        if (allFilesMoved) {\n-            // We want to remove the reference to the temporal file directory\n-            updateParams.setTmpDir(new File());\n-        }\n+    if (allFilesMoved) {\n+      // We want to remove the reference to the temporal file directory\n+      updateParams.setTmpDir(new File());\n+    }\n \n-        logger.info(\"{} - Updating job information: {}\", job.getId(), updateParams.toString());\n-        // We update the job information\n-        try {\n-            jobManager.update(study, job.getId(), updateParams, QueryOptions.empty(), token);\n-        } catch (CatalogException e) {\n-            logger.error(\"{} - Catastrophic error. Could not update job information with final result {}: {}\", job.getId(),\n-                    updateParams.toString(), e.getMessage(), e);\n-            return 0;\n-        }\n+    logger.info(\"{} - Updating job information: {}\", job.getId(), updateParams.toString());\n+    // We update the job information\n+    try {\n+      jobManager.update(study, job.getId(), updateParams, QueryOptions.empty(), token);\n+    } catch (CatalogException e) {\n+      logger.error(\"{} - Catastrophic error. Could not update job information with final result {}: {}\", job.getId(),\n+          updateParams.toString(), e.getMessage(), e);\n+      return 0;\n+    }\n \n-        // This has to be almost the last thing to do\n-        try {\n-            if (allFilesMoved) {\n-                logger.info(\"{} - Emptying temporal directory and deleting it from catalog\", job.getId());\n-\n-                catalogIOManager.deleteFile(tmpOutdirUri.resolve(ANALYSIS_RESULT_FILE));\n-\n-                // Delete directory from catalog\n-                ObjectMap params = new ObjectMap(Constants.SKIP_TRASH, true);\n-                fileManager.delete(study, Collections.singletonList(job.getTmpDir().getPath()), params, token);\n-\n-                // If after the file deletion it still exists, that will be because it is an external folder. In such a case, because we\n-                // have created the directory, we will manually delete it from the file system\n-                if (catalogIOManager.exists(tmpOutdirUri)) {\n-                    catalogIOManager.deleteDirectory(tmpOutdirUri);\n-                }\n-            } else {\n-                // TODO: Change temporal folder status to READY (unblock)\n-            }\n-        } catch (CatalogException e) {\n-            logger.error(\"{} - Could not clean up temporal directory: {}\", job.getId(), e.getMessage(), e);\n-        }\n+    // This has to be almost the last thing to do\n+    try {\n+      if (allFilesMoved) {\n+        logger.info(\"{} - Emptying temporal directory and deleting it from catalog\", job.getId());\n+\n+        catalogIOManager.deleteFile(tmpOutdirUri.resolve(ANALYSIS_RESULT_FILE));\n \n-        return 1;\n+        // Delete directory from catalog\n+        ObjectMap params = new ObjectMap(Constants.SKIP_TRASH, true);\n+        fileManager.delete(study, Collections.singletonList(job.getTmpDir().getPath()), params, token);\n+\n+        // If after the file deletion it still exists, that will be because it is an external folder. In such a case, because we\n+        // have created the directory, we will manually delete it from the file system\n+        if (catalogIOManager.exists(tmpOutdirUri)) {\n+          catalogIOManager.deleteDirectory(tmpOutdirUri);\n+        }\n+      } else {\n+        // TODO: Change temporal folder status to READY (unblock)\n+      }\n+    } catch (CatalogException e) {\n+      logger.error(\"{} - Could not clean up temporal directory: {}\", job.getId(), e.getMessage(), e);\n     }\n \n+    return 1;\n+  }\n+\n }\n",
            "diff_size": 691
        },
        {
            "tool": "naturalize",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/370/ExecutionDaemon.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/naturalize/370/ExecutionDaemon.java\nindex 6e734c900e0..cc4bfcf3372 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/370/ExecutionDaemon.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/naturalize/370/ExecutionDaemon.java\n@@ -310,16 +310,14 @@ public class ExecutionDaemon extends MonitorParentDaemon {\n                 inputFiles.add(file);\n \n                 // And we change the reference for the actual uri\n-                cliBuilder\n-                        .append(\" --\").append(CaseFormat.LOWER_CAMEL.to(CaseFormat.LOWER_HYPHEN, entry.getKey()))\n+                cliBuilder.append(\" --\").append(CaseFormat.LOWER_CAMEL.to(CaseFormat.LOWER_HYPHEN, entry.getKey()))\n                         .append(\" \").append(file.getUri().getPath());\n-            } if (entry.getKey().startsWith(\"-D\")) {\n-                cliBuilder\n-                        .append(\" \").append(entry.getKey())\n+            }\n+if (entry.getKey().startsWith(\"-D\")) {\n+                cliBuilder.append(\" \").append(entry.getKey())\n                         .append(\"=\").append(entry.getValue());\n             } else {\n-                cliBuilder\n-                        .append(\" --\").append(CaseFormat.LOWER_CAMEL.to(CaseFormat.LOWER_HYPHEN, entry.getKey()))\n+                cliBuilder.append(\" --\").append(CaseFormat.LOWER_CAMEL.to(CaseFormat.LOWER_HYPHEN, entry.getKey()))\n                         .append(\" \").append(entry.getValue());\n             }\n         }\n@@ -590,4 +588,4 @@ public class ExecutionDaemon extends MonitorParentDaemon {\n         return 1;\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 8
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "316",
                    "column": "13",
                    "severity": "error",
                    "message": "'}' at column 13 should be alone on a line.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.blocks.RightCurlyCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "316",
                    "column": "21",
                    "severity": "error",
                    "message": "'}' at column 21 should be alone on a line.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.blocks.RightCurlyCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/370/ExecutionDaemon.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/styler_three_grams/370/ExecutionDaemon.java\nindex 6e734c900e0..eeda448115e 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/370/ExecutionDaemon.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/styler_three_grams/370/ExecutionDaemon.java\n@@ -313,7 +313,7 @@ public class ExecutionDaemon extends MonitorParentDaemon {\n                 cliBuilder\n                         .append(\" --\").append(CaseFormat.LOWER_CAMEL.to(CaseFormat.LOWER_HYPHEN, entry.getKey()))\n                         .append(\" \").append(file.getUri().getPath());\n-            } if (entry.getKey().startsWith(\"-D\")) {\n+                    } if (entry.getKey().startsWith(\"-D\")) {\n                 cliBuilder\n                         .append(\" \").append(entry.getKey())\n                         .append(\"=\").append(entry.getValue());\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "intellij",
        "naturalize"
    ],
    "not_repaired_by": [
        "styler",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}