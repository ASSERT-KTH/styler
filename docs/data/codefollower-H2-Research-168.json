{
    "project_name": "codefollower-H2-Research",
    "error_id": "168",
    "information": {
        "errors": [
            {
                "line": "373",
                "column": "41",
                "severity": "warning",
                "message": "';' is followed by whitespace.",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.EmptyForIteratorPadCheck"
            }
        ]
    },
    "source_code": "        int newPageId = index.getPageStore().allocatePage();\n        PageDataLeaf p2 = PageDataLeaf.create(index, newPageId, parentPageId);\n        for (; splitPoint < entryCount; ) {\n            int split = p2.addRowTry(getRowAt(splitPoint));\n            if (split != -1) {\n                DbException.throwInternalError(\"split \" + split);",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/168/PageDataLeaf.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler/168/PageDataLeaf.java\nindex 7a79f8a2f09..0c1ebf561b9 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/168/PageDataLeaf.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler/168/PageDataLeaf.java\n@@ -370,7 +370,7 @@ public class PageDataLeaf extends PageData {\n     PageData split(int splitPoint) {\n         int newPageId = index.getPageStore().allocatePage();\n         PageDataLeaf p2 = PageDataLeaf.create(index, newPageId, parentPageId);\n-        for (; splitPoint < entryCount; ) {\n+        for (; splitPoint < entryCount;) {\n             int split = p2.addRowTry(getRowAt(splitPoint));\n             if (split != -1) {\n                 DbException.throwInternalError(\"split \" + split);\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "375",
                    "column": "37",
                    "severity": "warning",
                    "message": "';' is followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.EmptyForIteratorPadCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/168/PageDataLeaf.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/168/PageDataLeaf.java\nindex 7a79f8a2f09..fbed69464a2 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/168/PageDataLeaf.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/168/PageDataLeaf.java\n@@ -3,10 +3,12 @@\n  * and the EPL 1.0 (http://h2database.com/html/license.html).\n  * Initial Developer: H2 Group\n  */\n+\n package org.h2.index;\n \n import java.lang.ref.SoftReference;\n import java.util.Arrays;\n+\n import org.h2.api.ErrorCode;\n import org.h2.engine.Constants;\n import org.h2.engine.Session;\n@@ -34,596 +36,596 @@ import org.h2.value.Value;\n  */\n public class PageDataLeaf extends PageData {\n \n-    private final boolean optimizeUpdate;\n-\n-    /**\n-     * The row offsets.\n-     */\n-    private int[] offsets;\n-\n-    /**\n-     * The rows.\n-     */\n-    private Row[] rows;\n-\n-    /**\n-     * For pages with overflow: the soft reference to the row\n-     */\n-    private SoftReference<Row> rowRef;\n-\n-    /**\n-     * The page id of the first overflow page (0 if no overflow).\n-     */\n-    private int firstOverflowPageId;\n-\n-    /**\n-     * The start of the data area.\n-     */\n-    private int start;\n-\n-    /**\n-     * The size of the row in bytes for large rows.\n-     */\n-    private int overflowRowSize;\n-\n-    private int columnCount;\n-\n-    private int memoryData;\n-\n-    private boolean writtenData;\n-\n-    private PageDataLeaf(PageDataIndex index, int pageId, Data data) {\n-        super(index, pageId, data);\n-        this.optimizeUpdate = index.getDatabase().getSettings().optimizeUpdate;\n-    }\n-\n-    /**\n-     * Create a new page.\n-     *\n-     * @param index the index\n-     * @param pageId the page id\n-     * @param parentPageId the parent\n-     * @return the page\n-     */\n-    static PageDataLeaf create(PageDataIndex index, int pageId, int parentPageId) {\n-        PageDataLeaf p = new PageDataLeaf(index, pageId, index.getPageStore()\n-                .createData());\n-        index.getPageStore().logUndo(p, null);\n-        p.rows = Row.EMPTY_ARRAY;\n-        p.parentPageId = parentPageId;\n-        p.columnCount = index.getTable().getColumns().length;\n-        p.writeHead();\n-        p.start = p.data.length();\n-        return p;\n-    }\n-\n-    /**\n-     * Read a data leaf page.\n-     *\n-     * @param index the index\n-     * @param data the data\n-     * @param pageId the page id\n-     * @return the page\n-     */\n-    public static Page read(PageDataIndex index, Data data, int pageId) {\n-        PageDataLeaf p = new PageDataLeaf(index, pageId, data);\n-        p.read();\n-        return p;\n-    }\n-\n-    private void read() {\n-        data.reset();\n-        int type = data.readByte();\n-        data.readShortInt();\n-        this.parentPageId = data.readInt();\n-        int tableId = data.readVarInt();\n-        if (tableId != index.getId()) {\n-            throw DbException.get(ErrorCode.FILE_CORRUPTED_1,\n-                    \"page:\" + getPos() + \" expected table:\" + index.getId() +\n-                    \" got:\" + tableId + \" type:\" + type);\n-        }\n-        columnCount = data.readVarInt();\n-        entryCount = data.readShortInt();\n-        offsets = new int[entryCount];\n-        keys = new long[entryCount];\n-        rows = new Row[entryCount];\n-        if (type == Page.TYPE_DATA_LEAF) {\n-            if (entryCount != 1) {\n-                DbException.throwInternalError(\"entries: \" + entryCount);\n-            }\n-            firstOverflowPageId = data.readInt();\n-        }\n-        for (int i = 0; i < entryCount; i++) {\n-            keys[i] = data.readVarLong();\n-            offsets[i] = data.readShortInt();\n-        }\n-        start = data.length();\n-        written = true;\n-        writtenData = true;\n-    }\n-\n-    private int getRowLength(Row row) {\n-        int size = 0;\n-        for (int i = 0; i < columnCount; i++) {\n-            size += data.getValueLen(row.getValue(i));\n-        }\n-        return size;\n-    }\n-\n-    private int findInsertionPoint(long key) {\n-        int x = find(key);\n-        if (x < entryCount && keys[x] == key) {\n-            throw index.getDuplicateKeyException(\"\"+key);\n-        }\n-        return x;\n-    }\n-\n-    @Override\n-    int addRowTry(Row row) {\n-        index.getPageStore().logUndo(this, data);\n-        int rowLength = getRowLength(row);\n-        int pageSize = index.getPageStore().getPageSize();\n-        int last = entryCount == 0 ? pageSize : offsets[entryCount - 1];\n-        int keyOffsetPairLen = 2 + Data.getVarLongLen(row.getKey());\n-        if (entryCount > 0 && last - rowLength < start + keyOffsetPairLen) {\n-            int x = findInsertionPoint(row.getKey());\n-            if (entryCount > 1) {\n-                if (entryCount < 5) {\n-                    // required, otherwise the index doesn't work correctly\n-                    return entryCount / 2;\n-                }\n-                if (index.isSortedInsertMode()) {\n-                    return x < 2 ? 1 : x > entryCount - 1 ? entryCount - 1 : x;\n-                }\n-                // split near the insertion point to better fill pages\n-                // split in half would be:\n-                // return entryCount / 2;\n-                int third = entryCount / 3;\n-                return x < third ? third : x >= 2 * third ? 2 * third : x;\n-            }\n-            return x;\n-        }\n-        index.getPageStore().logUndo(this, data);\n-        int x;\n-        if (entryCount == 0) {\n-            x = 0;\n-        } else {\n-            if (!optimizeUpdate) {\n-                readAllRows();\n-            }\n-            x = findInsertionPoint(row.getKey());\n-        }\n-        written = false;\n-        changeCount = index.getPageStore().getChangeCount();\n-        last = x == 0 ? pageSize : offsets[x - 1];\n-        int offset = last - rowLength;\n-        start += keyOffsetPairLen;\n-        offsets = insert(offsets, entryCount, x, offset);\n-        add(offsets, x + 1, entryCount + 1, -rowLength);\n-        keys = insert(keys, entryCount, x, row.getKey());\n-        rows = insert(rows, entryCount, x, row);\n-        entryCount++;\n-        index.getPageStore().update(this);\n-        if (optimizeUpdate) {\n-            if (writtenData && offset >= start) {\n-                byte[] d = data.getBytes();\n-                int dataStart = offsets[entryCount - 1] + rowLength;\n-                int dataEnd = offsets[x];\n-                System.arraycopy(d, dataStart, d, dataStart - rowLength,\n-                        dataEnd - dataStart + rowLength);\n-                data.setPos(dataEnd);\n-                for (int j = 0; j < columnCount; j++) {\n-                    data.writeValue(row.getValue(j));\n-                }\n-            }\n-        }\n-        if (offset < start) {\n-            writtenData = false;\n-            if (entryCount > 1) {\n-                DbException.throwInternalError(\"\" + entryCount);\n-            }\n-            // need to write the overflow page id\n-            start += 4;\n-            int remaining = rowLength - (pageSize - start);\n-            // fix offset\n-            offset = start;\n-            offsets[x] = offset;\n-            int previous = getPos();\n-            int dataOffset = pageSize;\n-            int page = index.getPageStore().allocatePage();\n-            firstOverflowPageId = page;\n-            this.overflowRowSize = pageSize + rowLength;\n-            writeData();\n-            // free up the space used by the row\n-            Row r = rows[0];\n-            rowRef = new SoftReference<>(r);\n-            rows[0] = null;\n-            Data all = index.getPageStore().createData();\n-            all.checkCapacity(data.length());\n-            all.write(data.getBytes(), 0, data.length());\n-            data.truncate(index.getPageStore().getPageSize());\n-            do {\n-                int type, size, next;\n-                if (remaining <= pageSize - PageDataOverflow.START_LAST) {\n-                    type = Page.TYPE_DATA_OVERFLOW | Page.FLAG_LAST;\n-                    size = remaining;\n-                    next = 0;\n-                } else {\n-                    type = Page.TYPE_DATA_OVERFLOW;\n-                    size = pageSize - PageDataOverflow.START_MORE;\n-                    next = index.getPageStore().allocatePage();\n-                }\n-                PageDataOverflow overflow = PageDataOverflow.create(index.getPageStore(),\n-                        page, type, previous, next, all, dataOffset, size);\n-                index.getPageStore().update(overflow);\n-                dataOffset += size;\n-                remaining -= size;\n-                previous = page;\n-                page = next;\n-            } while (remaining > 0);\n-        }\n-        if (rowRef == null) {\n-            memoryChange(true, row);\n-        } else {\n-            memoryChange(true, null);\n-        }\n-        return -1;\n-    }\n-\n-    private void removeRow(int i) {\n-        index.getPageStore().logUndo(this, data);\n-        written = false;\n-        changeCount = index.getPageStore().getChangeCount();\n-        if (!optimizeUpdate) {\n-            readAllRows();\n-        }\n-        Row r = getRowAt(i);\n-        if (r != null) {\n-            memoryChange(false, r);\n-        }\n-        entryCount--;\n-        if (entryCount < 0) {\n-            DbException.throwInternalError(\"\" + entryCount);\n-        }\n-        if (firstOverflowPageId != 0) {\n-            start -= 4;\n-            freeOverflow();\n-            firstOverflowPageId = 0;\n-            overflowRowSize = 0;\n-            rowRef = null;\n-        }\n-        int keyOffsetPairLen = 2 + Data.getVarLongLen(keys[i]);\n-        int startNext = i > 0 ? offsets[i - 1] : index.getPageStore().getPageSize();\n-        int rowLength = startNext - offsets[i];\n-        if (optimizeUpdate) {\n-            if (writtenData) {\n-                byte[] d = data.getBytes();\n-                int dataStart = offsets[entryCount];\n-                System.arraycopy(d, dataStart, d, dataStart + rowLength,\n-                        offsets[i] - dataStart);\n-                Arrays.fill(d, dataStart, dataStart + rowLength, (byte) 0);\n-            }\n+  private final boolean optimizeUpdate;\n+\n+  /**\n+   * The row offsets.\n+   */\n+  private int[] offsets;\n+\n+  /**\n+   * The rows.\n+   */\n+  private Row[] rows;\n+\n+  /**\n+   * For pages with overflow: the soft reference to the row\n+   */\n+  private SoftReference<Row> rowRef;\n+\n+  /**\n+   * The page id of the first overflow page (0 if no overflow).\n+   */\n+  private int firstOverflowPageId;\n+\n+  /**\n+   * The start of the data area.\n+   */\n+  private int start;\n+\n+  /**\n+   * The size of the row in bytes for large rows.\n+   */\n+  private int overflowRowSize;\n+\n+  private int columnCount;\n+\n+  private int memoryData;\n+\n+  private boolean writtenData;\n+\n+  private PageDataLeaf(PageDataIndex index, int pageId, Data data) {\n+    super(index, pageId, data);\n+    this.optimizeUpdate = index.getDatabase().getSettings().optimizeUpdate;\n+  }\n+\n+  /**\n+   * Create a new page.\n+   *\n+   * @param index        the index\n+   * @param pageId       the page id\n+   * @param parentPageId the parent\n+   * @return the page\n+   */\n+  static PageDataLeaf create(PageDataIndex index, int pageId, int parentPageId) {\n+    PageDataLeaf p = new PageDataLeaf(index, pageId, index.getPageStore()\n+        .createData());\n+    index.getPageStore().logUndo(p, null);\n+    p.rows = Row.EMPTY_ARRAY;\n+    p.parentPageId = parentPageId;\n+    p.columnCount = index.getTable().getColumns().length;\n+    p.writeHead();\n+    p.start = p.data.length();\n+    return p;\n+  }\n+\n+  /**\n+   * Read a data leaf page.\n+   *\n+   * @param index  the index\n+   * @param data   the data\n+   * @param pageId the page id\n+   * @return the page\n+   */\n+  public static Page read(PageDataIndex index, Data data, int pageId) {\n+    PageDataLeaf p = new PageDataLeaf(index, pageId, data);\n+    p.read();\n+    return p;\n+  }\n+\n+  private void read() {\n+    data.reset();\n+    int type = data.readByte();\n+    data.readShortInt();\n+    this.parentPageId = data.readInt();\n+    int tableId = data.readVarInt();\n+    if (tableId != index.getId()) {\n+      throw DbException.get(ErrorCode.FILE_CORRUPTED_1,\n+          \"page:\" + getPos() + \" expected table:\" + index.getId() +\n+              \" got:\" + tableId + \" type:\" + type);\n+    }\n+    columnCount = data.readVarInt();\n+    entryCount = data.readShortInt();\n+    offsets = new int[entryCount];\n+    keys = new long[entryCount];\n+    rows = new Row[entryCount];\n+    if (type == Page.TYPE_DATA_LEAF) {\n+      if (entryCount != 1) {\n+        DbException.throwInternalError(\"entries: \" + entryCount);\n+      }\n+      firstOverflowPageId = data.readInt();\n+    }\n+    for (int i = 0; i < entryCount; i++) {\n+      keys[i] = data.readVarLong();\n+      offsets[i] = data.readShortInt();\n+    }\n+    start = data.length();\n+    written = true;\n+    writtenData = true;\n+  }\n+\n+  private int getRowLength(Row row) {\n+    int size = 0;\n+    for (int i = 0; i < columnCount; i++) {\n+      size += data.getValueLen(row.getValue(i));\n+    }\n+    return size;\n+  }\n+\n+  private int findInsertionPoint(long key) {\n+    int x = find(key);\n+    if (x < entryCount && keys[x] == key) {\n+      throw index.getDuplicateKeyException(\"\" + key);\n+    }\n+    return x;\n+  }\n+\n+  @Override\n+  int addRowTry(Row row) {\n+    index.getPageStore().logUndo(this, data);\n+    int rowLength = getRowLength(row);\n+    int pageSize = index.getPageStore().getPageSize();\n+    int last = entryCount == 0 ? pageSize : offsets[entryCount - 1];\n+    int keyOffsetPairLen = 2 + Data.getVarLongLen(row.getKey());\n+    if (entryCount > 0 && last - rowLength < start + keyOffsetPairLen) {\n+      int x = findInsertionPoint(row.getKey());\n+      if (entryCount > 1) {\n+        if (entryCount < 5) {\n+          // required, otherwise the index doesn't work correctly\n+          return entryCount / 2;\n+        }\n+        if (index.isSortedInsertMode()) {\n+          return x < 2 ? 1 : x > entryCount - 1 ? entryCount - 1 : x;\n+        }\n+        // split near the insertion point to better fill pages\n+        // split in half would be:\n+        // return entryCount / 2;\n+        int third = entryCount / 3;\n+        return x < third ? third : x >= 2 * third ? 2 * third : x;\n+      }\n+      return x;\n+    }\n+    index.getPageStore().logUndo(this, data);\n+    int x;\n+    if (entryCount == 0) {\n+      x = 0;\n+    } else {\n+      if (!optimizeUpdate) {\n+        readAllRows();\n+      }\n+      x = findInsertionPoint(row.getKey());\n+    }\n+    written = false;\n+    changeCount = index.getPageStore().getChangeCount();\n+    last = x == 0 ? pageSize : offsets[x - 1];\n+    int offset = last - rowLength;\n+    start += keyOffsetPairLen;\n+    offsets = insert(offsets, entryCount, x, offset);\n+    add(offsets, x + 1, entryCount + 1, -rowLength);\n+    keys = insert(keys, entryCount, x, row.getKey());\n+    rows = insert(rows, entryCount, x, row);\n+    entryCount++;\n+    index.getPageStore().update(this);\n+    if (optimizeUpdate) {\n+      if (writtenData && offset >= start) {\n+        byte[] d = data.getBytes();\n+        int dataStart = offsets[entryCount - 1] + rowLength;\n+        int dataEnd = offsets[x];\n+        System.arraycopy(d, dataStart, d, dataStart - rowLength,\n+            dataEnd - dataStart + rowLength);\n+        data.setPos(dataEnd);\n+        for (int j = 0; j < columnCount; j++) {\n+          data.writeValue(row.getValue(j));\n+        }\n+      }\n+    }\n+    if (offset < start) {\n+      writtenData = false;\n+      if (entryCount > 1) {\n+        DbException.throwInternalError(\"\" + entryCount);\n+      }\n+      // need to write the overflow page id\n+      start += 4;\n+      int remaining = rowLength - (pageSize - start);\n+      // fix offset\n+      offset = start;\n+      offsets[x] = offset;\n+      int previous = getPos();\n+      int dataOffset = pageSize;\n+      int page = index.getPageStore().allocatePage();\n+      firstOverflowPageId = page;\n+      this.overflowRowSize = pageSize + rowLength;\n+      writeData();\n+      // free up the space used by the row\n+      Row r = rows[0];\n+      rowRef = new SoftReference<>(r);\n+      rows[0] = null;\n+      Data all = index.getPageStore().createData();\n+      all.checkCapacity(data.length());\n+      all.write(data.getBytes(), 0, data.length());\n+      data.truncate(index.getPageStore().getPageSize());\n+      do {\n+        int type, size, next;\n+        if (remaining <= pageSize - PageDataOverflow.START_LAST) {\n+          type = Page.TYPE_DATA_OVERFLOW | Page.FLAG_LAST;\n+          size = remaining;\n+          next = 0;\n         } else {\n-            int clearStart = offsets[entryCount];\n-            Arrays.fill(data.getBytes(), clearStart, clearStart + rowLength, (byte) 0);\n-        }\n-        start -= keyOffsetPairLen;\n-        offsets = remove(offsets, entryCount + 1, i);\n-        add(offsets, i, entryCount, rowLength);\n-        keys = remove(keys, entryCount + 1, i);\n-        rows = remove(rows, entryCount + 1, i);\n-    }\n-\n-    @Override\n-    Cursor find(Session session, long minKey, long maxKey, boolean multiVersion) {\n-        int x = find(minKey);\n-        return new PageDataCursor(session, this, x, maxKey, multiVersion);\n-    }\n-\n-    /**\n-     * Get the row at the given index.\n-     *\n-     * @param at the index\n-     * @return the row\n-     */\n-    Row getRowAt(int at) {\n-        Row r = rows[at];\n-        if (r == null) {\n-            if (firstOverflowPageId == 0) {\n-                r = readRow(data, offsets[at], columnCount);\n-            } else {\n-                if (rowRef != null) {\n-                    r = rowRef.get();\n-                    if (r != null) {\n-                        return r;\n-                    }\n-                }\n-                PageStore store = index.getPageStore();\n-                Data buff = store.createData();\n-                int pageSize = store.getPageSize();\n-                int offset = offsets[at];\n-                buff.write(data.getBytes(), offset, pageSize - offset);\n-                int next = firstOverflowPageId;\n-                do {\n-                    PageDataOverflow page = index.getPageOverflow(next);\n-                    next = page.readInto(buff);\n-                } while (next != 0);\n-                overflowRowSize = pageSize + buff.length();\n-                r = readRow(buff, 0, columnCount);\n-            }\n-            r.setKey(keys[at]);\n-            if (firstOverflowPageId != 0) {\n-                rowRef = new SoftReference<>(r);\n-            } else {\n-                rows[at] = r;\n-                memoryChange(true, r);\n-            }\n-        }\n-        return r;\n-    }\n-\n-    int getEntryCount() {\n-        return entryCount;\n-    }\n-\n-    @Override\n-    PageData split(int splitPoint) {\n-        int newPageId = index.getPageStore().allocatePage();\n-        PageDataLeaf p2 = PageDataLeaf.create(index, newPageId, parentPageId);\n-        for (; splitPoint < entryCount; ) {\n-            int split = p2.addRowTry(getRowAt(splitPoint));\n-            if (split != -1) {\n-                DbException.throwInternalError(\"split \" + split);\n-            }\n-            removeRow(splitPoint);\n-        }\n-        return p2;\n-    }\n-\n-    @Override\n-    long getLastKey() {\n-        // TODO re-use keys, but remove this mechanism\n-        if (entryCount == 0) {\n-            return 0;\n-        }\n-        return getRowAt(entryCount - 1).getKey();\n-    }\n-\n-    PageDataLeaf getNextPage() {\n-        if (parentPageId == PageData.ROOT) {\n-            return null;\n-        }\n-        PageDataNode next = (PageDataNode) index.getPage(parentPageId, -1);\n-        return next.getNextPage(keys[entryCount - 1]);\n-    }\n-\n-    @Override\n-    PageDataLeaf getFirstLeaf() {\n-        return this;\n-    }\n-\n-    @Override\n-    protected void remapChildren(int old) {\n-        if (firstOverflowPageId == 0) {\n-            return;\n+          type = Page.TYPE_DATA_OVERFLOW;\n+          size = pageSize - PageDataOverflow.START_MORE;\n+          next = index.getPageStore().allocatePage();\n         }\n-        PageDataOverflow overflow = index.getPageOverflow(firstOverflowPageId);\n-        overflow.setParentPageId(getPos());\n+        PageDataOverflow overflow = PageDataOverflow.create(index.getPageStore(),\n+            page, type, previous, next, all, dataOffset, size);\n         index.getPageStore().update(overflow);\n-    }\n-\n-    @Override\n-    boolean remove(long key) {\n-        int i = find(key);\n-        if (keys == null || keys[i] != key) {\n-            throw DbException.get(ErrorCode.ROW_NOT_FOUND_WHEN_DELETING_1,\n-                    index.getSQL() + \": \" + key + \" \" + (keys == null ? -1 : keys[i]));\n-        }\n-        index.getPageStore().logUndo(this, data);\n-        if (entryCount == 1) {\n-            freeRecursive();\n-            return true;\n-        }\n-        removeRow(i);\n-        index.getPageStore().update(this);\n-        return false;\n-    }\n-\n-    @Override\n-    void freeRecursive() {\n-        index.getPageStore().logUndo(this, data);\n-        index.getPageStore().free(getPos());\n-        freeOverflow();\n-    }\n-\n-    private void freeOverflow() {\n-        if (firstOverflowPageId != 0) {\n-            int next = firstOverflowPageId;\n-            do {\n-                PageDataOverflow page = index.getPageOverflow(next);\n-                page.free();\n-                next = page.getNextOverflow();\n-            } while (next != 0);\n-        }\n-    }\n-\n-    @Override\n-    Row getRowWithKey(long key) {\n-        int at = find(key);\n-        return getRowAt(at);\n-    }\n-\n-    @Override\n-    int getRowCount() {\n-        return entryCount;\n-    }\n-\n-    @Override\n-    void setRowCountStored(int rowCount) {\n-        // ignore\n-    }\n-\n-    @Override\n-    long getDiskSpaceUsed() {\n-        return index.getPageStore().getPageSize();\n-    }\n-\n-    @Override\n-    public void write() {\n-        writeData();\n-        index.getPageStore().writePage(getPos(), data);\n-        data.truncate(index.getPageStore().getPageSize());\n-    }\n-\n-    private void readAllRows() {\n-        for (int i = 0; i < entryCount; i++) {\n-            getRowAt(i);\n-        }\n-    }\n-\n-    private void writeHead() {\n-        data.reset();\n-        int type;\n-        if (firstOverflowPageId == 0) {\n-            type = Page.TYPE_DATA_LEAF | Page.FLAG_LAST;\n-        } else {\n-            type = Page.TYPE_DATA_LEAF;\n-        }\n-        data.writeByte((byte) type);\n-        data.writeShortInt(0);\n-        if (SysProperties.CHECK2) {\n-            if (data.length() != START_PARENT) {\n-                DbException.throwInternalError();\n-            }\n+        dataOffset += size;\n+        remaining -= size;\n+        previous = page;\n+        page = next;\n+      } while (remaining > 0);\n+    }\n+    if (rowRef == null) {\n+      memoryChange(true, row);\n+    } else {\n+      memoryChange(true, null);\n+    }\n+    return -1;\n+  }\n+\n+  private void removeRow(int i) {\n+    index.getPageStore().logUndo(this, data);\n+    written = false;\n+    changeCount = index.getPageStore().getChangeCount();\n+    if (!optimizeUpdate) {\n+      readAllRows();\n+    }\n+    Row r = getRowAt(i);\n+    if (r != null) {\n+      memoryChange(false, r);\n+    }\n+    entryCount--;\n+    if (entryCount < 0) {\n+      DbException.throwInternalError(\"\" + entryCount);\n+    }\n+    if (firstOverflowPageId != 0) {\n+      start -= 4;\n+      freeOverflow();\n+      firstOverflowPageId = 0;\n+      overflowRowSize = 0;\n+      rowRef = null;\n+    }\n+    int keyOffsetPairLen = 2 + Data.getVarLongLen(keys[i]);\n+    int startNext = i > 0 ? offsets[i - 1] : index.getPageStore().getPageSize();\n+    int rowLength = startNext - offsets[i];\n+    if (optimizeUpdate) {\n+      if (writtenData) {\n+        byte[] d = data.getBytes();\n+        int dataStart = offsets[entryCount];\n+        System.arraycopy(d, dataStart, d, dataStart + rowLength,\n+            offsets[i] - dataStart);\n+        Arrays.fill(d, dataStart, dataStart + rowLength, (byte) 0);\n+      }\n+    } else {\n+      int clearStart = offsets[entryCount];\n+      Arrays.fill(data.getBytes(), clearStart, clearStart + rowLength, (byte) 0);\n+    }\n+    start -= keyOffsetPairLen;\n+    offsets = remove(offsets, entryCount + 1, i);\n+    add(offsets, i, entryCount, rowLength);\n+    keys = remove(keys, entryCount + 1, i);\n+    rows = remove(rows, entryCount + 1, i);\n+  }\n+\n+  @Override\n+  Cursor find(Session session, long minKey, long maxKey, boolean multiVersion) {\n+    int x = find(minKey);\n+    return new PageDataCursor(session, this, x, maxKey, multiVersion);\n+  }\n+\n+  /**\n+   * Get the row at the given index.\n+   *\n+   * @param at the index\n+   * @return the row\n+   */\n+  Row getRowAt(int at) {\n+    Row r = rows[at];\n+    if (r == null) {\n+      if (firstOverflowPageId == 0) {\n+        r = readRow(data, offsets[at], columnCount);\n+      } else {\n+        if (rowRef != null) {\n+          r = rowRef.get();\n+          if (r != null) {\n+            return r;\n+          }\n         }\n-        data.writeInt(parentPageId);\n-        data.writeVarInt(index.getId());\n-        data.writeVarInt(columnCount);\n-        data.writeShortInt(entryCount);\n-    }\n-\n-    private void writeData() {\n-        if (written) {\n-            return;\n-        }\n-        if (!optimizeUpdate) {\n-            readAllRows();\n-        }\n-        writeHead();\n-        if (firstOverflowPageId != 0) {\n-            data.writeInt(firstOverflowPageId);\n-            data.checkCapacity(overflowRowSize);\n-        }\n-        for (int i = 0; i < entryCount; i++) {\n-            data.writeVarLong(keys[i]);\n-            data.writeShortInt(offsets[i]);\n-        }\n-        if (!writtenData || !optimizeUpdate) {\n-            for (int i = 0; i < entryCount; i++) {\n-                data.setPos(offsets[i]);\n-                Row r = getRowAt(i);\n-                for (int j = 0; j < columnCount; j++) {\n-                    data.writeValue(r.getValue(j));\n-                }\n-            }\n-            writtenData = true;\n-        }\n-        written = true;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return \"page[\" + getPos() + \"] data leaf table:\" +\n-            index.getId() + \" \" + index.getTable().getName() +\n-            \" entries:\" + entryCount + \" parent:\" + parentPageId +\n-            (firstOverflowPageId == 0 ? \"\" : \" overflow:\" + firstOverflowPageId) +\n-            \" keys:\" + Arrays.toString(keys) + \" offsets:\" + Arrays.toString(offsets);\n-    }\n-\n-    @Override\n-    public void moveTo(Session session, int newPos) {\n         PageStore store = index.getPageStore();\n-        // load the pages into the cache, to ensure old pages\n-        // are written\n-        if (parentPageId != ROOT) {\n-            store.getPage(parentPageId);\n-        }\n-        store.logUndo(this, data);\n-        PageDataLeaf p2 = PageDataLeaf.create(index, newPos, parentPageId);\n-        readAllRows();\n-        p2.keys = keys;\n-        p2.overflowRowSize = overflowRowSize;\n-        p2.firstOverflowPageId = firstOverflowPageId;\n-        p2.rowRef = rowRef;\n-        p2.rows = rows;\n-        if (firstOverflowPageId != 0) {\n-            p2.rows[0] = getRowAt(0);\n-        }\n-        p2.entryCount = entryCount;\n-        p2.offsets = offsets;\n-        p2.start = start;\n-        p2.remapChildren(getPos());\n-        p2.writeData();\n-        p2.data.truncate(index.getPageStore().getPageSize());\n-        store.update(p2);\n-        if (parentPageId == ROOT) {\n-            index.setRootPageId(session, newPos);\n-        } else {\n-            PageDataNode p = (PageDataNode) store.getPage(parentPageId);\n-            p.moveChild(getPos(), newPos);\n-        }\n-        store.free(getPos());\n-    }\n-\n-    /**\n-     * Set the overflow page id.\n-     *\n-     * @param old the old overflow page id\n-     * @param overflow the new overflow page id\n-     */\n-    void setOverflow(int old, int overflow) {\n-        if (SysProperties.CHECK && old != firstOverflowPageId) {\n-            DbException.throwInternalError(\"move \" + this + \" \" + firstOverflowPageId);\n-        }\n-        index.getPageStore().logUndo(this, data);\n-        firstOverflowPageId = overflow;\n-        if (written) {\n-            changeCount = index.getPageStore().getChangeCount();\n-            writeHead();\n-            data.writeInt(firstOverflowPageId);\n-        }\n-        index.getPageStore().update(this);\n-    }\n-\n-    private void memoryChange(boolean add, Row r) {\n-        int diff = r == null ? 0 : 4 + 8 + Constants.MEMORY_POINTER + r.getMemory();\n-        memoryData += add ? diff : -diff;\n-        index.memoryChange((Constants.MEMORY_PAGE_DATA +\n-                memoryData + index.getPageStore().getPageSize()) >> 2);\n-    }\n-\n-    @Override\n-    public boolean isStream() {\n-        return firstOverflowPageId > 0;\n-    }\n-\n-    /**\n-     * Read a row from the data page at the given position.\n-     *\n-     * @param data the data page\n-     * @param pos the position to read from\n-     * @param columnCount the number of columns\n-     * @return the row\n-     */\n-    private Row readRow(Data data, int pos, int columnCount) {\n-        Value[] values = new Value[columnCount];\n-        synchronized (data) {\n-            data.setPos(pos);\n-            for (int i = 0; i < columnCount; i++) {\n-                values[i] = data.readValue();\n-            }\n-        }\n-        return index.getDatabase().createRow(values, Row.MEMORY_CALCULATE);\n-    }\n+        Data buff = store.createData();\n+        int pageSize = store.getPageSize();\n+        int offset = offsets[at];\n+        buff.write(data.getBytes(), offset, pageSize - offset);\n+        int next = firstOverflowPageId;\n+        do {\n+          PageDataOverflow page = index.getPageOverflow(next);\n+          next = page.readInto(buff);\n+        } while (next != 0);\n+        overflowRowSize = pageSize + buff.length();\n+        r = readRow(buff, 0, columnCount);\n+      }\n+      r.setKey(keys[at]);\n+      if (firstOverflowPageId != 0) {\n+        rowRef = new SoftReference<>(r);\n+      } else {\n+        rows[at] = r;\n+        memoryChange(true, r);\n+      }\n+    }\n+    return r;\n+  }\n+\n+  int getEntryCount() {\n+    return entryCount;\n+  }\n+\n+  @Override\n+  PageData split(int splitPoint) {\n+    int newPageId = index.getPageStore().allocatePage();\n+    PageDataLeaf p2 = PageDataLeaf.create(index, newPageId, parentPageId);\n+    for (; splitPoint < entryCount; ) {\n+      int split = p2.addRowTry(getRowAt(splitPoint));\n+      if (split != -1) {\n+        DbException.throwInternalError(\"split \" + split);\n+      }\n+      removeRow(splitPoint);\n+    }\n+    return p2;\n+  }\n+\n+  @Override\n+  long getLastKey() {\n+    // TODO re-use keys, but remove this mechanism\n+    if (entryCount == 0) {\n+      return 0;\n+    }\n+    return getRowAt(entryCount - 1).getKey();\n+  }\n+\n+  PageDataLeaf getNextPage() {\n+    if (parentPageId == PageData.ROOT) {\n+      return null;\n+    }\n+    PageDataNode next = (PageDataNode) index.getPage(parentPageId, -1);\n+    return next.getNextPage(keys[entryCount - 1]);\n+  }\n+\n+  @Override\n+  PageDataLeaf getFirstLeaf() {\n+    return this;\n+  }\n+\n+  @Override\n+  protected void remapChildren(int old) {\n+    if (firstOverflowPageId == 0) {\n+      return;\n+    }\n+    PageDataOverflow overflow = index.getPageOverflow(firstOverflowPageId);\n+    overflow.setParentPageId(getPos());\n+    index.getPageStore().update(overflow);\n+  }\n+\n+  @Override\n+  boolean remove(long key) {\n+    int i = find(key);\n+    if (keys == null || keys[i] != key) {\n+      throw DbException.get(ErrorCode.ROW_NOT_FOUND_WHEN_DELETING_1,\n+          index.getSQL() + \": \" + key + \" \" + (keys == null ? -1 : keys[i]));\n+    }\n+    index.getPageStore().logUndo(this, data);\n+    if (entryCount == 1) {\n+      freeRecursive();\n+      return true;\n+    }\n+    removeRow(i);\n+    index.getPageStore().update(this);\n+    return false;\n+  }\n+\n+  @Override\n+  void freeRecursive() {\n+    index.getPageStore().logUndo(this, data);\n+    index.getPageStore().free(getPos());\n+    freeOverflow();\n+  }\n+\n+  private void freeOverflow() {\n+    if (firstOverflowPageId != 0) {\n+      int next = firstOverflowPageId;\n+      do {\n+        PageDataOverflow page = index.getPageOverflow(next);\n+        page.free();\n+        next = page.getNextOverflow();\n+      } while (next != 0);\n+    }\n+  }\n+\n+  @Override\n+  Row getRowWithKey(long key) {\n+    int at = find(key);\n+    return getRowAt(at);\n+  }\n+\n+  @Override\n+  int getRowCount() {\n+    return entryCount;\n+  }\n+\n+  @Override\n+  void setRowCountStored(int rowCount) {\n+    // ignore\n+  }\n+\n+  @Override\n+  long getDiskSpaceUsed() {\n+    return index.getPageStore().getPageSize();\n+  }\n+\n+  @Override\n+  public void write() {\n+    writeData();\n+    index.getPageStore().writePage(getPos(), data);\n+    data.truncate(index.getPageStore().getPageSize());\n+  }\n+\n+  private void readAllRows() {\n+    for (int i = 0; i < entryCount; i++) {\n+      getRowAt(i);\n+    }\n+  }\n+\n+  private void writeHead() {\n+    data.reset();\n+    int type;\n+    if (firstOverflowPageId == 0) {\n+      type = Page.TYPE_DATA_LEAF | Page.FLAG_LAST;\n+    } else {\n+      type = Page.TYPE_DATA_LEAF;\n+    }\n+    data.writeByte((byte) type);\n+    data.writeShortInt(0);\n+    if (SysProperties.CHECK2) {\n+      if (data.length() != START_PARENT) {\n+        DbException.throwInternalError();\n+      }\n+    }\n+    data.writeInt(parentPageId);\n+    data.writeVarInt(index.getId());\n+    data.writeVarInt(columnCount);\n+    data.writeShortInt(entryCount);\n+  }\n+\n+  private void writeData() {\n+    if (written) {\n+      return;\n+    }\n+    if (!optimizeUpdate) {\n+      readAllRows();\n+    }\n+    writeHead();\n+    if (firstOverflowPageId != 0) {\n+      data.writeInt(firstOverflowPageId);\n+      data.checkCapacity(overflowRowSize);\n+    }\n+    for (int i = 0; i < entryCount; i++) {\n+      data.writeVarLong(keys[i]);\n+      data.writeShortInt(offsets[i]);\n+    }\n+    if (!writtenData || !optimizeUpdate) {\n+      for (int i = 0; i < entryCount; i++) {\n+        data.setPos(offsets[i]);\n+        Row r = getRowAt(i);\n+        for (int j = 0; j < columnCount; j++) {\n+          data.writeValue(r.getValue(j));\n+        }\n+      }\n+      writtenData = true;\n+    }\n+    written = true;\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return \"page[\" + getPos() + \"] data leaf table:\" +\n+        index.getId() + \" \" + index.getTable().getName() +\n+        \" entries:\" + entryCount + \" parent:\" + parentPageId +\n+        (firstOverflowPageId == 0 ? \"\" : \" overflow:\" + firstOverflowPageId) +\n+        \" keys:\" + Arrays.toString(keys) + \" offsets:\" + Arrays.toString(offsets);\n+  }\n+\n+  @Override\n+  public void moveTo(Session session, int newPos) {\n+    PageStore store = index.getPageStore();\n+    // load the pages into the cache, to ensure old pages\n+    // are written\n+    if (parentPageId != ROOT) {\n+      store.getPage(parentPageId);\n+    }\n+    store.logUndo(this, data);\n+    PageDataLeaf p2 = PageDataLeaf.create(index, newPos, parentPageId);\n+    readAllRows();\n+    p2.keys = keys;\n+    p2.overflowRowSize = overflowRowSize;\n+    p2.firstOverflowPageId = firstOverflowPageId;\n+    p2.rowRef = rowRef;\n+    p2.rows = rows;\n+    if (firstOverflowPageId != 0) {\n+      p2.rows[0] = getRowAt(0);\n+    }\n+    p2.entryCount = entryCount;\n+    p2.offsets = offsets;\n+    p2.start = start;\n+    p2.remapChildren(getPos());\n+    p2.writeData();\n+    p2.data.truncate(index.getPageStore().getPageSize());\n+    store.update(p2);\n+    if (parentPageId == ROOT) {\n+      index.setRootPageId(session, newPos);\n+    } else {\n+      PageDataNode p = (PageDataNode) store.getPage(parentPageId);\n+      p.moveChild(getPos(), newPos);\n+    }\n+    store.free(getPos());\n+  }\n+\n+  /**\n+   * Set the overflow page id.\n+   *\n+   * @param old      the old overflow page id\n+   * @param overflow the new overflow page id\n+   */\n+  void setOverflow(int old, int overflow) {\n+    if (SysProperties.CHECK && old != firstOverflowPageId) {\n+      DbException.throwInternalError(\"move \" + this + \" \" + firstOverflowPageId);\n+    }\n+    index.getPageStore().logUndo(this, data);\n+    firstOverflowPageId = overflow;\n+    if (written) {\n+      changeCount = index.getPageStore().getChangeCount();\n+      writeHead();\n+      data.writeInt(firstOverflowPageId);\n+    }\n+    index.getPageStore().update(this);\n+  }\n+\n+  private void memoryChange(boolean add, Row r) {\n+    int diff = r == null ? 0 : 4 + 8 + Constants.MEMORY_POINTER + r.getMemory();\n+    memoryData += add ? diff : -diff;\n+    index.memoryChange((Constants.MEMORY_PAGE_DATA +\n+        memoryData + index.getPageStore().getPageSize()) >> 2);\n+  }\n+\n+  @Override\n+  public boolean isStream() {\n+    return firstOverflowPageId > 0;\n+  }\n+\n+  /**\n+   * Read a row from the data page at the given position.\n+   *\n+   * @param data        the data page\n+   * @param pos         the position to read from\n+   * @param columnCount the number of columns\n+   * @return the row\n+   */\n+  private Row readRow(Data data, int pos, int columnCount) {\n+    Value[] values = new Value[columnCount];\n+    synchronized (data) {\n+      data.setPos(pos);\n+      for (int i = 0; i < columnCount; i++) {\n+        values[i] = data.readValue();\n+      }\n+    }\n+    return index.getDatabase().createRow(values, Row.MEMORY_CALCULATE);\n+  }\n \n }\n",
            "diff_size": 792
        },
        {
            "tool": "naturalize",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/168/PageDataLeaf.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/naturalize/168/PageDataLeaf.java\nindex 7a79f8a2f09..36e012d2d8c 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/168/PageDataLeaf.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/naturalize/168/PageDataLeaf.java\n@@ -370,7 +370,7 @@ public class PageDataLeaf extends PageData {\n     PageData split(int splitPoint) {\n         int newPageId = index.getPageStore().allocatePage();\n         PageDataLeaf p2 = PageDataLeaf.create(index, newPageId, parentPageId);\n-        for (; splitPoint < entryCount; ) {\n+        for (; splitPoint < entryCount;) {\n             int split = p2.addRowTry(getRowAt(splitPoint));\n             if (split != -1) {\n                 DbException.throwInternalError(\"split \" + split);\n@@ -626,4 +626,4 @@ public class PageDataLeaf extends PageData {\n         return index.getDatabase().createRow(values, Row.MEMORY_CALCULATE);\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 2
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/168/PageDataLeaf.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/codebuff/168/PageDataLeaf.java\nindex 7a79f8a2f09..43d5a418731 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/168/PageDataLeaf.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/codebuff/168/PageDataLeaf.java\n@@ -32,6 +32,8 @@ import org.h2.value.Value;\n  * <li>data</li>\n  * </ul>\n  */\n+\n+\n public class PageDataLeaf extends PageData {\n \n     private final boolean optimizeUpdate;\n@@ -65,11 +67,8 @@ public class PageDataLeaf extends PageData {\n      * The size of the row in bytes for large rows.\n      */\n     private int overflowRowSize;\n-\n     private int columnCount;\n-\n     private int memoryData;\n-\n     private boolean writtenData;\n \n     private PageDataLeaf(PageDataIndex index, int pageId, Data data) {\n@@ -85,9 +84,10 @@ public class PageDataLeaf extends PageData {\n      * @param parentPageId the parent\n      * @return the page\n      */\n+\n+\n     static PageDataLeaf create(PageDataIndex index, int pageId, int parentPageId) {\n-        PageDataLeaf p = new PageDataLeaf(index, pageId, index.getPageStore()\n-                .createData());\n+        PageDataLeaf p = new PageDataLeaf(index, pageId, index.getPageStore().createData());\n         index.getPageStore().logUndo(p, null);\n         p.rows = Row.EMPTY_ARRAY;\n         p.parentPageId = parentPageId;\n@@ -105,6 +105,8 @@ public class PageDataLeaf extends PageData {\n      * @param pageId the page id\n      * @return the page\n      */\n+\n+\n     public static Page read(PageDataIndex index, Data data, int pageId) {\n         PageDataLeaf p = new PageDataLeaf(index, pageId, data);\n         p.read();\n@@ -118,9 +120,9 @@ public class PageDataLeaf extends PageData {\n         this.parentPageId = data.readInt();\n         int tableId = data.readVarInt();\n         if (tableId != index.getId()) {\n-            throw DbException.get(ErrorCode.FILE_CORRUPTED_1,\n-                    \"page:\" + getPos() + \" expected table:\" + index.getId() +\n-                    \" got:\" + tableId + \" type:\" + type);\n+            throw DbException.get(ErrorCode.FILE_CORRUPTED_1, \"page:\" + getPos() + \" expected table:\"\n+            + index.getId() + \" got:\"\n+            + tableId + \" type:\" + type);\n         }\n         columnCount = data.readVarInt();\n         entryCount = data.readShortInt();\n@@ -153,7 +155,7 @@ public class PageDataLeaf extends PageData {\n     private int findInsertionPoint(long key) {\n         int x = find(key);\n         if (x < entryCount && keys[x] == key) {\n-            throw index.getDuplicateKeyException(\"\"+key);\n+            throw index.getDuplicateKeyException(\"\" + key);\n         }\n         return x;\n     }\n@@ -209,8 +211,7 @@ public class PageDataLeaf extends PageData {\n                 byte[] d = data.getBytes();\n                 int dataStart = offsets[entryCount - 1] + rowLength;\n                 int dataEnd = offsets[x];\n-                System.arraycopy(d, dataStart, d, dataStart - rowLength,\n-                        dataEnd - dataStart + rowLength);\n+                System.arraycopy(d, dataStart, d, dataStart - rowLength, dataEnd - dataStart + rowLength);\n                 data.setPos(dataEnd);\n                 for (int j = 0; j < columnCount; j++) {\n                     data.writeValue(row.getValue(j));\n@@ -236,7 +237,7 @@ public class PageDataLeaf extends PageData {\n             writeData();\n             // free up the space used by the row\n             Row r = rows[0];\n-            rowRef = new SoftReference<>(r);\n+            rowRef = new SoftReference< >(r);\n             rows[0] = null;\n             Data all = index.getPageStore().createData();\n             all.checkCapacity(data.length());\n@@ -253,8 +254,7 @@ public class PageDataLeaf extends PageData {\n                     size = pageSize - PageDataOverflow.START_MORE;\n                     next = index.getPageStore().allocatePage();\n                 }\n-                PageDataOverflow overflow = PageDataOverflow.create(index.getPageStore(),\n-                        page, type, previous, next, all, dataOffset, size);\n+                PageDataOverflow overflow = PageDataOverflow.create(index.getPageStore(), page, type, previous, next, all, dataOffset, size);\n                 index.getPageStore().update(overflow);\n                 dataOffset += size;\n                 remaining -= size;\n@@ -299,8 +299,7 @@ public class PageDataLeaf extends PageData {\n             if (writtenData) {\n                 byte[] d = data.getBytes();\n                 int dataStart = offsets[entryCount];\n-                System.arraycopy(d, dataStart, d, dataStart + rowLength,\n-                        offsets[i] - dataStart);\n+                System.arraycopy(d, dataStart, d, dataStart + rowLength, offsets[i] - dataStart);\n                 Arrays.fill(d, dataStart, dataStart + rowLength, (byte) 0);\n             }\n         } else {\n@@ -326,6 +325,8 @@ public class PageDataLeaf extends PageData {\n      * @param at the index\n      * @return the row\n      */\n+\n+\n     Row getRowAt(int at) {\n         Row r = rows[at];\n         if (r == null) {\n@@ -353,7 +354,7 @@ public class PageDataLeaf extends PageData {\n             }\n             r.setKey(keys[at]);\n             if (firstOverflowPageId != 0) {\n-                rowRef = new SoftReference<>(r);\n+                rowRef = new SoftReference< >(r);\n             } else {\n                 rows[at] = r;\n                 memoryChange(true, r);\n@@ -362,6 +363,7 @@ public class PageDataLeaf extends PageData {\n         return r;\n     }\n \n+\n     int getEntryCount() {\n         return entryCount;\n     }\n@@ -370,7 +372,7 @@ public class PageDataLeaf extends PageData {\n     PageData split(int splitPoint) {\n         int newPageId = index.getPageStore().allocatePage();\n         PageDataLeaf p2 = PageDataLeaf.create(index, newPageId, parentPageId);\n-        for (; splitPoint < entryCount; ) {\n+        for (; splitPoint < entryCount;) {\n             int split = p2.addRowTry(getRowAt(splitPoint));\n             if (split != -1) {\n                 DbException.throwInternalError(\"split \" + split);\n@@ -389,6 +391,7 @@ public class PageDataLeaf extends PageData {\n         return getRowAt(entryCount - 1).getKey();\n     }\n \n+\n     PageDataLeaf getNextPage() {\n         if (parentPageId == PageData.ROOT) {\n             return null;\n@@ -416,8 +419,8 @@ public class PageDataLeaf extends PageData {\n     boolean remove(long key) {\n         int i = find(key);\n         if (keys == null || keys[i] != key) {\n-            throw DbException.get(ErrorCode.ROW_NOT_FOUND_WHEN_DELETING_1,\n-                    index.getSQL() + \": \" + key + \" \" + (keys == null ? -1 : keys[i]));\n+            throw DbException.get(ErrorCode.ROW_NOT_FOUND_WHEN_DELETING_1, index.getSQL() + \": \"\n+            + key + \" \" + (keys == null ? -1 : keys[i]));\n         }\n         index.getPageStore().logUndo(this, data);\n         if (entryCount == 1) {\n@@ -461,6 +464,7 @@ public class PageDataLeaf extends PageData {\n     @Override\n     void setRowCountStored(int rowCount) {\n         // ignore\n+\n     }\n \n     @Override\n@@ -533,11 +537,12 @@ public class PageDataLeaf extends PageData {\n \n     @Override\n     public String toString() {\n-        return \"page[\" + getPos() + \"] data leaf table:\" +\n-            index.getId() + \" \" + index.getTable().getName() +\n-            \" entries:\" + entryCount + \" parent:\" + parentPageId +\n-            (firstOverflowPageId == 0 ? \"\" : \" overflow:\" + firstOverflowPageId) +\n-            \" keys:\" + Arrays.toString(keys) + \" offsets:\" + Arrays.toString(offsets);\n+        return \"page[\" + getPos() + \"] data leaf table:\"\n+        + index.getId() + \" \"\n+        + index.getTable().getName() + \" entries:\"\n+        + entryCount + \" parent:\"\n+        + parentPageId + (firstOverflowPageId == 0 ? \"\" : \" overflow:\" + firstOverflowPageId) + \" keys:\"\n+        + Arrays.toString(keys) + \" offsets:\" + Arrays.toString(offsets);\n     }\n \n     @Override\n@@ -581,9 +586,12 @@ public class PageDataLeaf extends PageData {\n      * @param old the old overflow page id\n      * @param overflow the new overflow page id\n      */\n+\n+\n     void setOverflow(int old, int overflow) {\n         if (SysProperties.CHECK && old != firstOverflowPageId) {\n-            DbException.throwInternalError(\"move \" + this + \" \" + firstOverflowPageId);\n+            DbException.throwInternalError(\"move \" +\n+                                           this + \" \" + firstOverflowPageId);\n         }\n         index.getPageStore().logUndo(this, data);\n         firstOverflowPageId = overflow;\n@@ -598,8 +606,7 @@ public class PageDataLeaf extends PageData {\n     private void memoryChange(boolean add, Row r) {\n         int diff = r == null ? 0 : 4 + 8 + Constants.MEMORY_POINTER + r.getMemory();\n         memoryData += add ? diff : -diff;\n-        index.memoryChange((Constants.MEMORY_PAGE_DATA +\n-                memoryData + index.getPageStore().getPageSize()) >> 2);\n+        index.memoryChange((Constants.MEMORY_PAGE_DATA + memoryData + index.getPageStore().getPageSize()) >> 2);\n     }\n \n     @Override\n@@ -615,6 +622,7 @@ public class PageDataLeaf extends PageData {\n      * @param columnCount the number of columns\n      * @return the row\n      */\n+\n     private Row readRow(Data data, int pos, int columnCount) {\n         Value[] values = new Value[columnCount];\n         synchronized (data) {\n@@ -626,4 +634,4 @@ public class PageDataLeaf extends PageData {\n         return index.getDatabase().createRow(values, Row.MEMORY_CALCULATE);\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 45
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/168/PageDataLeaf.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_random/168/PageDataLeaf.java\nindex 7a79f8a2f09..0c1ebf561b9 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/168/PageDataLeaf.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_random/168/PageDataLeaf.java\n@@ -370,7 +370,7 @@ public class PageDataLeaf extends PageData {\n     PageData split(int splitPoint) {\n         int newPageId = index.getPageStore().allocatePage();\n         PageDataLeaf p2 = PageDataLeaf.create(index, newPageId, parentPageId);\n-        for (; splitPoint < entryCount; ) {\n+        for (; splitPoint < entryCount;) {\n             int split = p2.addRowTry(getRowAt(splitPoint));\n             if (split != -1) {\n                 DbException.throwInternalError(\"split \" + split);\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/168/PageDataLeaf.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/168/PageDataLeaf.java\nindex 7a79f8a2f09..0c1ebf561b9 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/168/PageDataLeaf.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/168/PageDataLeaf.java\n@@ -370,7 +370,7 @@ public class PageDataLeaf extends PageData {\n     PageData split(int splitPoint) {\n         int newPageId = index.getPageStore().allocatePage();\n         PageDataLeaf p2 = PageDataLeaf.create(index, newPageId, parentPageId);\n-        for (; splitPoint < entryCount; ) {\n+        for (; splitPoint < entryCount;) {\n             int split = p2.addRowTry(getRowAt(splitPoint));\n             if (split != -1) {\n                 DbException.throwInternalError(\"split \" + split);\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "styler",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "intellij"
    ]
}