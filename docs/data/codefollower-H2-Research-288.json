{
    "project_name": "codefollower-H2-Research",
    "error_id": "288",
    "information": {
        "errors": [
            {
                "line": "193",
                "column": "44",
                "severity": "warning",
                "message": "Don't use trailing comments.",
                "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
            }
        ]
    },
    "source_code": "                throw DbException.getInvalidValueException(\"length\", value.getPrecision());\n            }\n            final JdbcConnection c = conn; // local variable avoids generating synthetic accessor method\n            final PipedInputStream in = new PipedInputStream();\n            final Task task = new Task() {\n                @Override",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/288/JdbcBlob.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler/288/JdbcBlob.java\nindex bc58bbd1535..d148164d5ad 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/288/JdbcBlob.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler/288/JdbcBlob.java\n@@ -190,8 +190,9 @@ public class JdbcBlob extends TraceObject implements Blob {\n             if (value.getPrecision() != 0) {\n                 throw DbException.getInvalidValueException(\"length\", value.getPrecision());\n             }\n-            final JdbcConnection c = conn; // local variable avoids generating synthetic accessor method\n-            final PipedInputStream in = new PipedInputStream();\n+            final JdbcConnection c = conn;\n+            // local variable avoids generating synthetic accessor method\n+             final PipedInputStream in = new PipedInputStream();\n             final Task task = new Task() {\n                 @Override\n                 public void call() {\n",
            "diff_size": 3
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "195",
                    "column": "38",
                    "severity": "warning",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/288/JdbcBlob.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/288/JdbcBlob.java\nindex bc58bbd1535..c62e59f6ddc 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/288/JdbcBlob.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/288/JdbcBlob.java\n@@ -3,6 +3,7 @@\n  * and the EPL 1.0 (http://h2database.com/html/license.html).\n  * Initial Developer: H2 Group\n  */\n+\n package org.h2.jdbc;\n \n import java.io.BufferedInputStream;\n@@ -16,6 +17,7 @@ import java.io.PipedInputStream;\n import java.io.PipedOutputStream;\n import java.sql.Blob;\n import java.sql.SQLException;\n+\n import org.h2.api.ErrorCode;\n import org.h2.engine.Constants;\n import org.h2.message.DbException;\n@@ -29,324 +31,324 @@ import org.h2.value.Value;\n  */\n public class JdbcBlob extends TraceObject implements Blob {\n \n-    Value value;\n-    private final JdbcConnection conn;\n+  Value value;\n+  private final JdbcConnection conn;\n \n-    /**\n-     * INTERNAL\n-     */\n-    public JdbcBlob(JdbcConnection conn, Value value, int id) {\n-        setTrace(conn.getSession().getTrace(), TraceObject.BLOB, id);\n-        this.conn = conn;\n-        this.value = value;\n-    }\n+  /**\n+   * INTERNAL\n+   */\n+  public JdbcBlob(JdbcConnection conn, Value value, int id) {\n+    setTrace(conn.getSession().getTrace(), TraceObject.BLOB, id);\n+    this.conn = conn;\n+    this.value = value;\n+  }\n \n-    /**\n-     * Returns the length.\n-     *\n-     * @return the length\n-     */\n-    @Override\n-    public long length() throws SQLException {\n-        try {\n-            debugCodeCall(\"length\");\n-            checkClosed();\n-            if (value.getType() == Value.BLOB) {\n-                long precision = value.getPrecision();\n-                if (precision > 0) {\n-                    return precision;\n-                }\n-            }\n-            return IOUtils.copyAndCloseInput(value.getInputStream(), null);\n-        } catch (Exception e) {\n-            throw logAndConvert(e);\n+  /**\n+   * Returns the length.\n+   *\n+   * @return the length\n+   */\n+  @Override\n+  public long length() throws SQLException {\n+    try {\n+      debugCodeCall(\"length\");\n+      checkClosed();\n+      if (value.getType() == Value.BLOB) {\n+        long precision = value.getPrecision();\n+        if (precision > 0) {\n+          return precision;\n         }\n+      }\n+      return IOUtils.copyAndCloseInput(value.getInputStream(), null);\n+    } catch (Exception e) {\n+      throw logAndConvert(e);\n     }\n+  }\n \n-    /**\n-     * [Not supported] Truncates the object.\n-     *\n-     * @param len the new length\n-     */\n-    @Override\n-    public void truncate(long len) throws SQLException {\n-        throw unsupported(\"LOB update\");\n+  /**\n+   * [Not supported] Truncates the object.\n+   *\n+   * @param len the new length\n+   */\n+  @Override\n+  public void truncate(long len) throws SQLException {\n+    throw unsupported(\"LOB update\");\n+  }\n+\n+  /**\n+   * Returns some bytes of the object.\n+   *\n+   * @param pos    the index, the first byte is at position 1\n+   * @param length the number of bytes\n+   * @return the bytes, at most length bytes\n+   */\n+  @Override\n+  public byte[] getBytes(long pos, int length) throws SQLException {\n+    try {\n+      if (isDebugEnabled()) {\n+        debugCode(\"getBytes(\" + pos + \", \" + length + \");\");\n+      }\n+      checkClosed();\n+      ByteArrayOutputStream out = new ByteArrayOutputStream();\n+      try (InputStream in = value.getInputStream()) {\n+        IOUtils.skipFully(in, pos - 1);\n+        IOUtils.copy(in, out, length);\n+      }\n+      return out.toByteArray();\n+    } catch (Exception e) {\n+      throw logAndConvert(e);\n     }\n+  }\n \n-    /**\n-     * Returns some bytes of the object.\n-     *\n-     * @param pos the index, the first byte is at position 1\n-     * @param length the number of bytes\n-     * @return the bytes, at most length bytes\n-     */\n-    @Override\n-    public byte[] getBytes(long pos, int length) throws SQLException {\n-        try {\n-            if (isDebugEnabled()) {\n-                debugCode(\"getBytes(\"+pos+\", \"+length+\");\");\n-            }\n-            checkClosed();\n-            ByteArrayOutputStream out = new ByteArrayOutputStream();\n-            try (InputStream in = value.getInputStream()) {\n-                IOUtils.skipFully(in, pos - 1);\n-                IOUtils.copy(in, out, length);\n-            }\n-            return out.toByteArray();\n-        } catch (Exception e) {\n-            throw logAndConvert(e);\n-        }\n+  /**\n+   * Fills the Blob. This is only supported for new, empty Blob objects that\n+   * were created with Connection.createBlob(). The position\n+   * must be 1, meaning the whole Blob data is set.\n+   *\n+   * @param pos   where to start writing (the first byte is at position 1)\n+   * @param bytes the bytes to set\n+   * @return the length of the added data\n+   */\n+  @Override\n+  public int setBytes(long pos, byte[] bytes) throws SQLException {\n+    try {\n+      if (isDebugEnabled()) {\n+        debugCode(\"setBytes(\" + pos + \", \" + quoteBytes(bytes) + \");\");\n+      }\n+      checkClosed();\n+      if (pos != 1) {\n+        throw DbException.getInvalidValueException(\"pos\", pos);\n+      }\n+      value = conn.createBlob(new ByteArrayInputStream(bytes), -1);\n+      return bytes.length;\n+    } catch (Exception e) {\n+      throw logAndConvert(e);\n     }\n+  }\n \n-    /**\n-     * Fills the Blob. This is only supported for new, empty Blob objects that\n-     * were created with Connection.createBlob(). The position\n-     * must be 1, meaning the whole Blob data is set.\n-     *\n-     * @param pos where to start writing (the first byte is at position 1)\n-     * @param bytes the bytes to set\n-     * @return the length of the added data\n-     */\n-    @Override\n-    public int setBytes(long pos, byte[] bytes) throws SQLException {\n-        try {\n-            if (isDebugEnabled()) {\n-                debugCode(\"setBytes(\"+pos+\", \"+quoteBytes(bytes)+\");\");\n-            }\n-            checkClosed();\n-            if (pos != 1) {\n-                throw DbException.getInvalidValueException(\"pos\", pos);\n-            }\n-            value = conn.createBlob(new ByteArrayInputStream(bytes), -1);\n-            return bytes.length;\n-        } catch (Exception e) {\n-            throw logAndConvert(e);\n-        }\n+  /**\n+   * Sets some bytes of the object.\n+   *\n+   * @param pos    the write position\n+   * @param bytes  the bytes to set\n+   * @param offset the bytes offset\n+   * @param len    the number of bytes to write\n+   * @return how many bytes have been written\n+   */\n+  @Override\n+  public int setBytes(long pos, byte[] bytes, int offset, int len)\n+      throws SQLException {\n+    try {\n+      if (isDebugEnabled()) {\n+        debugCode(\"setBytes(\" + pos + \", \" + quoteBytes(bytes) + \", \" + offset + \", \" + len + \");\");\n+      }\n+      checkClosed();\n+      if (pos != 1) {\n+        throw DbException.getInvalidValueException(\"pos\", pos);\n+      }\n+      value = conn.createBlob(new ByteArrayInputStream(bytes, offset, len), -1);\n+      return (int) value.getPrecision();\n+    } catch (Exception e) {\n+      throw logAndConvert(e);\n     }\n+  }\n \n-    /**\n-     * Sets some bytes of the object.\n-     *\n-     * @param pos the write position\n-     * @param bytes the bytes to set\n-     * @param offset the bytes offset\n-     * @param len the number of bytes to write\n-     * @return how many bytes have been written\n-     */\n-    @Override\n-    public int setBytes(long pos, byte[] bytes, int offset, int len)\n-            throws SQLException {\n-        try {\n-            if (isDebugEnabled()) {\n-                debugCode(\"setBytes(\" + pos + \", \" + quoteBytes(bytes) + \", \" + offset + \", \" + len + \");\");\n-            }\n-            checkClosed();\n-            if (pos != 1) {\n-                throw DbException.getInvalidValueException(\"pos\", pos);\n-            }\n-            value = conn.createBlob(new ByteArrayInputStream(bytes, offset, len), -1);\n-            return (int) value.getPrecision();\n-        } catch (Exception e) {\n-            throw logAndConvert(e);\n-        }\n+  /**\n+   * Returns the input stream.\n+   *\n+   * @return the input stream\n+   */\n+  @Override\n+  public InputStream getBinaryStream() throws SQLException {\n+    try {\n+      debugCodeCall(\"getBinaryStream\");\n+      checkClosed();\n+      return value.getInputStream();\n+    } catch (Exception e) {\n+      throw logAndConvert(e);\n     }\n+  }\n \n-    /**\n-     * Returns the input stream.\n-     *\n-     * @return the input stream\n-     */\n-    @Override\n-    public InputStream getBinaryStream() throws SQLException {\n-        try {\n-            debugCodeCall(\"getBinaryStream\");\n-            checkClosed();\n-            return value.getInputStream();\n-        } catch (Exception e) {\n-            throw logAndConvert(e);\n+  /**\n+   * Get a writer to update the Blob. This is only supported for new, empty\n+   * Blob objects that were created with Connection.createBlob(). The Blob is\n+   * created in a separate thread, and the object is only updated when\n+   * OutputStream.close() is called. The position must be 1, meaning the whole\n+   * Blob data is set.\n+   *\n+   * @param pos where to start writing (the first byte is at position 1)\n+   * @return an output stream\n+   */\n+  @Override\n+  public OutputStream setBinaryStream(long pos) throws SQLException {\n+    try {\n+      if (isDebugEnabled()) {\n+        debugCode(\"setBinaryStream(\" + pos + \");\");\n+      }\n+      checkClosed();\n+      if (pos != 1) {\n+        throw DbException.getInvalidValueException(\"pos\", pos);\n+      }\n+      if (value.getPrecision() != 0) {\n+        throw DbException.getInvalidValueException(\"length\", value.getPrecision());\n+      }\n+      final JdbcConnection c = conn; // local variable avoids generating synthetic accessor method\n+      final PipedInputStream in = new PipedInputStream();\n+      final Task task = new Task() {\n+        @Override\n+        public void call() {\n+          value = c.createBlob(in, -1);\n         }\n+      };\n+      PipedOutputStream out = new PipedOutputStream(in) {\n+        @Override\n+        public void close() throws IOException {\n+          super.close();\n+          try {\n+            task.get();\n+          } catch (Exception e) {\n+            throw DbException.convertToIOException(e);\n+          }\n+        }\n+      };\n+      task.execute();\n+      return new BufferedOutputStream(out);\n+    } catch (Exception e) {\n+      throw logAndConvert(e);\n     }\n+  }\n \n-    /**\n-     * Get a writer to update the Blob. This is only supported for new, empty\n-     * Blob objects that were created with Connection.createBlob(). The Blob is\n-     * created in a separate thread, and the object is only updated when\n-     * OutputStream.close() is called. The position must be 1, meaning the whole\n-     * Blob data is set.\n-     *\n-     * @param pos where to start writing (the first byte is at position 1)\n-     * @return an output stream\n-     */\n-    @Override\n-    public OutputStream setBinaryStream(long pos) throws SQLException {\n-        try {\n-            if (isDebugEnabled()) {\n-                debugCode(\"setBinaryStream(\"+pos+\");\");\n+  /**\n+   * [Not supported] Searches a pattern and return the position.\n+   *\n+   * @param pattern the pattern to search\n+   * @param start   the index, the first byte is at position 1\n+   * @return the position (first byte is at position 1), or -1 for not found\n+   */\n+  @Override\n+  public long position(byte[] pattern, long start) throws SQLException {\n+    if (isDebugEnabled()) {\n+      debugCode(\"position(\" + quoteBytes(pattern) + \", \" + start + \");\");\n+    }\n+    if (Constants.BLOB_SEARCH) {\n+      try {\n+        checkClosed();\n+        if (pattern == null) {\n+          return -1;\n+        }\n+        if (pattern.length == 0) {\n+          return 1;\n+        }\n+        // TODO performance: blob pattern search is slow\n+        BufferedInputStream in = new BufferedInputStream(value.getInputStream());\n+        IOUtils.skipFully(in, start - 1);\n+        int pos = 0;\n+        int patternPos = 0;\n+        while (true) {\n+          int x = in.read();\n+          if (x < 0) {\n+            break;\n+          }\n+          if (x == (pattern[patternPos] & 0xff)) {\n+            if (patternPos == 0) {\n+              in.mark(pattern.length);\n             }\n-            checkClosed();\n-            if (pos != 1) {\n-                throw DbException.getInvalidValueException(\"pos\", pos);\n+            if (patternPos == pattern.length) {\n+              return pos - patternPos;\n             }\n-            if (value.getPrecision() != 0) {\n-                throw DbException.getInvalidValueException(\"length\", value.getPrecision());\n+            patternPos++;\n+          } else {\n+            if (patternPos > 0) {\n+              in.reset();\n+              pos -= patternPos;\n             }\n-            final JdbcConnection c = conn; // local variable avoids generating synthetic accessor method\n-            final PipedInputStream in = new PipedInputStream();\n-            final Task task = new Task() {\n-                @Override\n-                public void call() {\n-                    value = c.createBlob(in, -1);\n-                }\n-            };\n-            PipedOutputStream out = new PipedOutputStream(in) {\n-                @Override\n-                public void close() throws IOException {\n-                    super.close();\n-                    try {\n-                        task.get();\n-                    } catch (Exception e) {\n-                        throw DbException.convertToIOException(e);\n-                    }\n-                }\n-            };\n-            task.execute();\n-            return new BufferedOutputStream(out);\n-        } catch (Exception e) {\n-            throw logAndConvert(e);\n+          }\n+          pos++;\n         }\n+        return -1;\n+      } catch (Exception e) {\n+        throw logAndConvert(e);\n+      }\n     }\n+    throw unsupported(\"LOB search\");\n+  }\n \n-    /**\n-     * [Not supported] Searches a pattern and return the position.\n-     *\n-     * @param pattern the pattern to search\n-     * @param start the index, the first byte is at position 1\n-     * @return the position (first byte is at position 1), or -1 for not found\n-     */\n-    @Override\n-    public long position(byte[] pattern, long start) throws SQLException {\n-        if (isDebugEnabled()) {\n-            debugCode(\"position(\"+quoteBytes(pattern)+\", \"+start+\");\");\n-        }\n-        if (Constants.BLOB_SEARCH) {\n-            try {\n-                checkClosed();\n-                if (pattern == null) {\n-                    return -1;\n-                }\n-                if (pattern.length == 0) {\n-                    return 1;\n-                }\n-                // TODO performance: blob pattern search is slow\n-                BufferedInputStream in = new BufferedInputStream(value.getInputStream());\n-                IOUtils.skipFully(in, start - 1);\n-                int pos = 0;\n-                int patternPos = 0;\n-                while (true) {\n-                    int x = in.read();\n-                    if (x < 0) {\n-                        break;\n-                    }\n-                    if (x == (pattern[patternPos] & 0xff)) {\n-                        if (patternPos == 0) {\n-                            in.mark(pattern.length);\n-                        }\n-                        if (patternPos == pattern.length) {\n-                            return pos - patternPos;\n-                        }\n-                        patternPos++;\n-                    } else {\n-                        if (patternPos > 0) {\n-                            in.reset();\n-                            pos -= patternPos;\n-                        }\n-                    }\n-                    pos++;\n-                }\n-                return -1;\n-            } catch (Exception e) {\n-                throw logAndConvert(e);\n-            }\n-        }\n-        throw unsupported(\"LOB search\");\n+  /**\n+   * [Not supported] Searches a pattern and return the position.\n+   *\n+   * @param blobPattern the pattern to search\n+   * @param start       the index, the first byte is at position 1\n+   * @return the position (first byte is at position 1), or -1 for not found\n+   */\n+  @Override\n+  public long position(Blob blobPattern, long start) throws SQLException {\n+    if (isDebugEnabled()) {\n+      debugCode(\"position(blobPattern, \" + start + \");\");\n     }\n-\n-    /**\n-     * [Not supported] Searches a pattern and return the position.\n-     *\n-     * @param blobPattern the pattern to search\n-     * @param start the index, the first byte is at position 1\n-     * @return the position (first byte is at position 1), or -1 for not found\n-     */\n-    @Override\n-    public long position(Blob blobPattern, long start) throws SQLException {\n-        if (isDebugEnabled()) {\n-            debugCode(\"position(blobPattern, \"+start+\");\");\n+    if (Constants.BLOB_SEARCH) {\n+      try {\n+        checkClosed();\n+        if (blobPattern == null) {\n+          return -1;\n         }\n-        if (Constants.BLOB_SEARCH) {\n-            try {\n-                checkClosed();\n-                if (blobPattern == null) {\n-                    return -1;\n-                }\n-                ByteArrayOutputStream out = new ByteArrayOutputStream();\n-                InputStream in = blobPattern.getBinaryStream();\n-                while (true) {\n-                    int x = in.read();\n-                    if (x < 0) {\n-                        break;\n-                    }\n-                    out.write(x);\n-                }\n-                return position(out.toByteArray(), start);\n-            } catch (Exception e) {\n-                throw logAndConvert(e);\n-            }\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        InputStream in = blobPattern.getBinaryStream();\n+        while (true) {\n+          int x = in.read();\n+          if (x < 0) {\n+            break;\n+          }\n+          out.write(x);\n         }\n-        throw unsupported(\"LOB subset\");\n+        return position(out.toByteArray(), start);\n+      } catch (Exception e) {\n+        throw logAndConvert(e);\n+      }\n     }\n+    throw unsupported(\"LOB subset\");\n+  }\n \n-    /**\n-     * Release all resources of this object.\n-     */\n-    @Override\n-    public void free() {\n-        debugCodeCall(\"free\");\n-        value = null;\n-    }\n+  /**\n+   * Release all resources of this object.\n+   */\n+  @Override\n+  public void free() {\n+    debugCodeCall(\"free\");\n+    value = null;\n+  }\n \n-    /**\n-     * Returns the input stream, starting from an offset.\n-     *\n-     * @param pos where to start reading\n-     * @param length the number of bytes that will be read\n-     * @return the input stream to read\n-     */\n-    @Override\n-    public InputStream getBinaryStream(long pos, long length) throws SQLException {\n-        try {\n-            debugCodeCall(\"getBinaryStream(pos, length)\");\n-            checkClosed();\n-            return value.getInputStream(pos, length);\n-        } catch (Exception e) {\n-            throw logAndConvert(e);\n-        }\n+  /**\n+   * Returns the input stream, starting from an offset.\n+   *\n+   * @param pos    where to start reading\n+   * @param length the number of bytes that will be read\n+   * @return the input stream to read\n+   */\n+  @Override\n+  public InputStream getBinaryStream(long pos, long length) throws SQLException {\n+    try {\n+      debugCodeCall(\"getBinaryStream(pos, length)\");\n+      checkClosed();\n+      return value.getInputStream(pos, length);\n+    } catch (Exception e) {\n+      throw logAndConvert(e);\n     }\n+  }\n \n-    private void checkClosed() {\n-        conn.checkClosed();\n-        if (value == null) {\n-            throw DbException.get(ErrorCode.OBJECT_CLOSED);\n-        }\n+  private void checkClosed() {\n+    conn.checkClosed();\n+    if (value == null) {\n+      throw DbException.get(ErrorCode.OBJECT_CLOSED);\n     }\n+  }\n \n-    /**\n-     * INTERNAL\n-     */\n-    @Override\n-    public String toString() {\n-        return getTraceObjectName() + \": \" +\n-                (value == null ? \"null\" : value.getTraceSQL());\n-    }\n+  /**\n+   * INTERNAL\n+   */\n+  @Override\n+  public String toString() {\n+    return getTraceObjectName() + \": \" +\n+        (value == null ? \"null\" : value.getTraceSQL());\n+  }\n \n }\n",
            "diff_size": 390
        },
        {
            "tool": "naturalize",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/288/JdbcBlob.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/naturalize/288/JdbcBlob.java\nindex bc58bbd1535..e42c7630528 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/288/JdbcBlob.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/naturalize/288/JdbcBlob.java\n@@ -190,7 +190,8 @@ public class JdbcBlob extends TraceObject implements Blob {\n             if (value.getPrecision() != 0) {\n                 throw DbException.getInvalidValueException(\"length\", value.getPrecision());\n             }\n-            final JdbcConnection c = conn; // local variable avoids generating synthetic accessor method\n+            final JdbcConnection c = conn;\n+// local variable avoids generating synthetic accessor method\n             final PipedInputStream in = new PipedInputStream();\n             final Task task = new Task() {\n                 @Override\n@@ -349,4 +350,4 @@ public class JdbcBlob extends TraceObject implements Blob {\n                 (value == null ? \"null\" : value.getTraceSQL());\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 3
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "208",
                    "column": "44",
                    "severity": "warning",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/288/JdbcBlob.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/codebuff/288/JdbcBlob.java\nindex bc58bbd1535..56d484eb782 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/288/JdbcBlob.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/codebuff/288/JdbcBlob.java\n@@ -27,14 +27,18 @@ import org.h2.value.Value;\n /**\n  * Represents a BLOB value.\n  */\n+\n+\n public class JdbcBlob extends TraceObject implements Blob {\n \n+\n     Value value;\n     private final JdbcConnection conn;\n \n     /**\n      * INTERNAL\n      */\n+\n     public JdbcBlob(JdbcConnection conn, Value value, int id) {\n         setTrace(conn.getSession().getTrace(), TraceObject.BLOB, id);\n         this.conn = conn;\n@@ -46,6 +50,7 @@ public class JdbcBlob extends TraceObject implements Blob {\n      *\n      * @return the length\n      */\n+\n     @Override\n     public long length() throws SQLException {\n         try {\n@@ -68,6 +73,7 @@ public class JdbcBlob extends TraceObject implements Blob {\n      *\n      * @param len the new length\n      */\n+\n     @Override\n     public void truncate(long len) throws SQLException {\n         throw unsupported(\"LOB update\");\n@@ -80,11 +86,13 @@ public class JdbcBlob extends TraceObject implements Blob {\n      * @param length the number of bytes\n      * @return the bytes, at most length bytes\n      */\n+\n     @Override\n     public byte[] getBytes(long pos, int length) throws SQLException {\n         try {\n             if (isDebugEnabled()) {\n-                debugCode(\"getBytes(\"+pos+\", \"+length+\");\");\n+                debugCode(\"getBytes(\" + pos + \", \"\n+                + length + \");\");\n             }\n             checkClosed();\n             ByteArrayOutputStream out = new ByteArrayOutputStream();\n@@ -107,11 +115,13 @@ public class JdbcBlob extends TraceObject implements Blob {\n      * @param bytes the bytes to set\n      * @return the length of the added data\n      */\n+\n     @Override\n     public int setBytes(long pos, byte[] bytes) throws SQLException {\n         try {\n             if (isDebugEnabled()) {\n-                debugCode(\"setBytes(\"+pos+\", \"+quoteBytes(bytes)+\");\");\n+                debugCode(\"setBytes(\" + pos + \", \"\n+                + quoteBytes(bytes) + \");\");\n             }\n             checkClosed();\n             if (pos != 1) {\n@@ -133,12 +143,15 @@ public class JdbcBlob extends TraceObject implements Blob {\n      * @param len the number of bytes to write\n      * @return how many bytes have been written\n      */\n+\n     @Override\n-    public int setBytes(long pos, byte[] bytes, int offset, int len)\n-            throws SQLException {\n+    public int setBytes(long pos, byte[] bytes, int offset, int len) throws SQLException {\n         try {\n             if (isDebugEnabled()) {\n-                debugCode(\"setBytes(\" + pos + \", \" + quoteBytes(bytes) + \", \" + offset + \", \" + len + \");\");\n+                debugCode(\"setBytes(\" + pos + \", \"\n+                + quoteBytes(bytes) + \", \"\n+                + offset + \", \"\n+                + len + \");\");\n             }\n             checkClosed();\n             if (pos != 1) {\n@@ -156,6 +169,7 @@ public class JdbcBlob extends TraceObject implements Blob {\n      *\n      * @return the input stream\n      */\n+\n     @Override\n     public InputStream getBinaryStream() throws SQLException {\n         try {\n@@ -177,11 +191,12 @@ public class JdbcBlob extends TraceObject implements Blob {\n      * @param pos where to start writing (the first byte is at position 1)\n      * @return an output stream\n      */\n+\n     @Override\n     public OutputStream setBinaryStream(long pos) throws SQLException {\n         try {\n             if (isDebugEnabled()) {\n-                debugCode(\"setBinaryStream(\"+pos+\");\");\n+                debugCode(\"setBinaryStream(\" + pos + \");\");\n             }\n             checkClosed();\n             if (pos != 1) {\n@@ -193,22 +208,22 @@ public class JdbcBlob extends TraceObject implements Blob {\n             final JdbcConnection c = conn; // local variable avoids generating synthetic accessor method\n             final PipedInputStream in = new PipedInputStream();\n             final Task task = new Task() {\n-                @Override\n-                public void call() {\n-                    value = c.createBlob(in, -1);\n-                }\n-            };\n+                           @Override\n+                           public void call() {\n+                               value = c.createBlob(in, -1);\n+                           }\n+                       };\n             PipedOutputStream out = new PipedOutputStream(in) {\n-                @Override\n-                public void close() throws IOException {\n-                    super.close();\n-                    try {\n-                        task.get();\n-                    } catch (Exception e) {\n-                        throw DbException.convertToIOException(e);\n-                    }\n-                }\n-            };\n+    @Override\n+    public void close() throws IOException {\n+        super.close();\n+        try {\n+            task.get();\n+        } catch (Exception e) {\n+            throw DbException.convertToIOException(e);\n+        }\n+    }\n+                              };\n             task.execute();\n             return new BufferedOutputStream(out);\n         } catch (Exception e) {\n@@ -223,10 +238,12 @@ public class JdbcBlob extends TraceObject implements Blob {\n      * @param start the index, the first byte is at position 1\n      * @return the position (first byte is at position 1), or -1 for not found\n      */\n+\n     @Override\n     public long position(byte[] pattern, long start) throws SQLException {\n         if (isDebugEnabled()) {\n-            debugCode(\"position(\"+quoteBytes(pattern)+\", \"+start+\");\");\n+            debugCode(\"position(\" + quoteBytes(pattern) + \", \"\n+            + start + \");\");\n         }\n         if (Constants.BLOB_SEARCH) {\n             try {\n@@ -278,10 +295,11 @@ public class JdbcBlob extends TraceObject implements Blob {\n      * @param start the index, the first byte is at position 1\n      * @return the position (first byte is at position 1), or -1 for not found\n      */\n+\n     @Override\n     public long position(Blob blobPattern, long start) throws SQLException {\n         if (isDebugEnabled()) {\n-            debugCode(\"position(blobPattern, \"+start+\");\");\n+            debugCode(\"position(blobPattern, \" + start + \");\");\n         }\n         if (Constants.BLOB_SEARCH) {\n             try {\n@@ -309,6 +327,7 @@ public class JdbcBlob extends TraceObject implements Blob {\n     /**\n      * Release all resources of this object.\n      */\n+\n     @Override\n     public void free() {\n         debugCodeCall(\"free\");\n@@ -322,6 +341,7 @@ public class JdbcBlob extends TraceObject implements Blob {\n      * @param length the number of bytes that will be read\n      * @return the input stream to read\n      */\n+\n     @Override\n     public InputStream getBinaryStream(long pos, long length) throws SQLException {\n         try {\n@@ -343,10 +363,10 @@ public class JdbcBlob extends TraceObject implements Blob {\n     /**\n      * INTERNAL\n      */\n+\n     @Override\n     public String toString() {\n-        return getTraceObjectName() + \": \" +\n-                (value == null ? \"null\" : value.getTraceSQL());\n+        return getTraceObjectName() + \": \" + (value == null ? \"null\" : value.getTraceSQL());\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 48
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/288/JdbcBlob.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_random/288/JdbcBlob.java\nindex bc58bbd1535..d148164d5ad 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/288/JdbcBlob.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_random/288/JdbcBlob.java\n@@ -190,8 +190,9 @@ public class JdbcBlob extends TraceObject implements Blob {\n             if (value.getPrecision() != 0) {\n                 throw DbException.getInvalidValueException(\"length\", value.getPrecision());\n             }\n-            final JdbcConnection c = conn; // local variable avoids generating synthetic accessor method\n-            final PipedInputStream in = new PipedInputStream();\n+            final JdbcConnection c = conn;\n+            // local variable avoids generating synthetic accessor method\n+             final PipedInputStream in = new PipedInputStream();\n             final Task task = new Task() {\n                 @Override\n                 public void call() {\n",
            "diff_size": 3
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/288/JdbcBlob.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/288/JdbcBlob.java\nindex bc58bbd1535..d148164d5ad 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/288/JdbcBlob.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/288/JdbcBlob.java\n@@ -190,8 +190,9 @@ public class JdbcBlob extends TraceObject implements Blob {\n             if (value.getPrecision() != 0) {\n                 throw DbException.getInvalidValueException(\"length\", value.getPrecision());\n             }\n-            final JdbcConnection c = conn; // local variable avoids generating synthetic accessor method\n-            final PipedInputStream in = new PipedInputStream();\n+            final JdbcConnection c = conn;\n+            // local variable avoids generating synthetic accessor method\n+             final PipedInputStream in = new PipedInputStream();\n             final Task task = new Task() {\n                 @Override\n                 public void call() {\n",
            "diff_size": 3
        }
    ],
    "repaired_by": [
        "styler",
        "naturalize",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "intellij",
        "codebuff"
    ]
}