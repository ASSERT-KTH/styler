{
    "project_name": "wso2-attic-commons",
    "error_id": "212",
    "information": {
        "errors": [
            {
                "line": "226",
                "severity": "error",
                "message": "Line is longer than 120 characters (found 135).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": "\t\t\t\t\tif (variable) {\n\t\t\t\t\t\tvariableExpr.append(ch);\n\t\t\t\t\t\t// in the name is qualified, don't check if its a qname when we're at the \":\" character\n\t\t\t\t\t\tif (ch == ':') {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/212/XPath20ExpressionCompilerImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler/212/XPath20ExpressionCompilerImpl.java\nindex e64e663ceb8..dbb4cc2baa9 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/212/XPath20ExpressionCompilerImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler/212/XPath20ExpressionCompilerImpl.java\n@@ -223,7 +223,7 @@ public class XPath20ExpressionCompilerImpl implements ExpressionCompiler {\n \t\t\t\t} else {\n \t\t\t\t\tif (variable) {\n \t\t\t\t\t\tvariableExpr.append(ch);\n-\t\t\t\t\t\t// in the name is qualified, don't check if its a qname when we're at the \":\" character\n+// in the name is qualified, don't check if its a qname when we're at the \":\" character\n \t\t\t\t\t\tif (ch == ':') {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/212/XPath20ExpressionCompilerImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/intellij/212/XPath20ExpressionCompilerImpl.java\nindex e64e663ceb8..318056bb86d 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/212/XPath20ExpressionCompilerImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/intellij/212/XPath20ExpressionCompilerImpl.java\n@@ -55,189 +55,192 @@ import org.w3c.dom.Node;\n \n /**\n  * XPath compiler based on the SAXON implementation.\n+ *\n  * @author Matthieu Riou <mriou at apache dot org>\n  */\n public class XPath20ExpressionCompilerImpl implements ExpressionCompiler {\n \n-    protected static final Log __log = LogFactory.getLog(XPath20ExpressionCompilerBPEL20.class);\n-\n-    protected String _bpelNS;\n-    protected QName _qnLinkStatus;\n-    protected QName _qnVarProp;\n-    protected QName _qnVarData;\n-    protected QName _qnXslTransform;\n-\n-    protected final XPathMessages __msgs = MessageBundle.getMessages(XPathMessages.class);\n-    protected Map<String, String> _properties = new HashMap<String, String>();\n-    protected CompilerContext _compilerContext;\n-\n-    public XPath20ExpressionCompilerImpl(String bpelNS) {\n-        _bpelNS = bpelNS;\n-        _qnLinkStatus = new QName(_bpelNS, Constants.EXT_FUNCTION_GETLINKSTATUS);\n-        _qnVarProp = new QName(_bpelNS, Constants.EXT_FUNCTION_GETVARIABLEPROPERTY);\n-        _qnVarData = new QName(_bpelNS, Constants.EXT_FUNCTION_GETVARIABLEDATA);\n-        _qnXslTransform = new QName(_bpelNS, Constants.EXT_FUNCTION_DOXSLTRANSFORM);\n-\n-        _properties.put(\"runtime-class\", \"org.apache.ode.bpel.rtrep.v2.xpath20.XPath20ExpressionRuntime\");\n-        TransformerFactory trsf = new net.sf.saxon.TransformerFactoryImpl();\n-        XslTransformHandler.getInstance().setTransformerFactory(trsf);\n+  protected static final Log __log = LogFactory.getLog(XPath20ExpressionCompilerBPEL20.class);\n+\n+  protected String _bpelNS;\n+  protected QName _qnLinkStatus;\n+  protected QName _qnVarProp;\n+  protected QName _qnVarData;\n+  protected QName _qnXslTransform;\n+\n+  protected final XPathMessages __msgs = MessageBundle.getMessages(XPathMessages.class);\n+  protected Map<String, String> _properties = new HashMap<String, String>();\n+  protected CompilerContext _compilerContext;\n+\n+  public XPath20ExpressionCompilerImpl(String bpelNS) {\n+    _bpelNS = bpelNS;\n+    _qnLinkStatus = new QName(_bpelNS, Constants.EXT_FUNCTION_GETLINKSTATUS);\n+    _qnVarProp = new QName(_bpelNS, Constants.EXT_FUNCTION_GETVARIABLEPROPERTY);\n+    _qnVarData = new QName(_bpelNS, Constants.EXT_FUNCTION_GETVARIABLEDATA);\n+    _qnXslTransform = new QName(_bpelNS, Constants.EXT_FUNCTION_DOXSLTRANSFORM);\n+\n+    _properties.put(\"runtime-class\", \"org.apache.ode.bpel.rtrep.v2.xpath20.XPath20ExpressionRuntime\");\n+    TransformerFactory trsf = new net.sf.saxon.TransformerFactoryImpl();\n+    XslTransformHandler.getInstance().setTransformerFactory(trsf);\n+  }\n+\n+  public void setCompilerContext(CompilerContext compilerContext) {\n+    _compilerContext = compilerContext;\n+    XslCompilationErrorListener xe = new XslCompilationErrorListener(compilerContext);\n+    XslTransformHandler.getInstance().setErrorListener(xe);\n+  }\n+\n+  /**\n+   * @see org.apache.ode.bpel.compiler.v2.ExpressionCompiler#compileJoinCondition(java.lang.Object)\n+   */\n+  public OExpression compileJoinCondition(Object source) throws CompilationException {\n+    return _compile((Expression) source, true);\n+  }\n+\n+  /**\n+   * @see org.apache.ode.bpel.compiler.v2.ExpressionCompiler#compile(java.lang.Object)\n+   */\n+  public OExpression compile(Object source) throws CompilationException {\n+    return _compile((Expression) source, false);\n+  }\n+\n+  /**\n+   * @see org.apache.ode.bpel.compiler.v2.ExpressionCompiler#compileLValue(java.lang.Object)\n+   */\n+  public OLValueExpression compileLValue(Object source) throws CompilationException {\n+    return (OLValueExpression) _compile((Expression) source, false);\n+  }\n+\n+  /**\n+   * @see org.apache.ode.bpel.compiler.v2.ExpressionCompiler#compile(java.lang.Object)\n+   */\n+  private OExpression _compile(org.apache.ode.bpel.compiler.bom.Expression xpath, boolean isJoinCondition)\n+    throws CompilationException {\n+    OXPath20ExpressionBPEL20 oexp = new OXPath20ExpressionBPEL20(_compilerContext.getOProcess(), _qnVarData,\n+      _qnVarProp, _qnLinkStatus, _qnXslTransform, isJoinCondition);\n+    oexp.namespaceCtx = xpath.getNamespaceContext();\n+    doJaxpCompile(oexp, xpath);\n+    return oexp;\n+  }\n+\n+  private void doJaxpCompile(OXPath20ExpressionBPEL20 out, Expression source) throws CompilationException {\n+    String xpathStr;\n+    Node node = source.getExpression();\n+    if (node == null) {\n+      throw new IllegalStateException(\"XPath string and xpath node are both null\");\n     }\n-\n-    public void setCompilerContext(CompilerContext compilerContext) {\n-        _compilerContext = compilerContext;\n-        XslCompilationErrorListener xe = new XslCompilationErrorListener(compilerContext);\n-        XslTransformHandler.getInstance().setErrorListener(xe);\n-    }\n-\n-    /**\n-     * @see org.apache.ode.bpel.compiler.v2.ExpressionCompiler#compileJoinCondition(java.lang.Object)\n-     */\n-    public OExpression compileJoinCondition(Object source) throws CompilationException {\n-        return _compile((Expression) source, true);\n+    if (node.getNodeType() != Node.TEXT_NODE) {\n+      throw new CompilationException(__msgs.errUnexpectedNodeTypeForXPath(DOMUtils.domToString(node)));\n     }\n-\n-    /**\n-     * @see org.apache.ode.bpel.compiler.v2.ExpressionCompiler#compile(java.lang.Object)\n-     */\n-    public OExpression compile(Object source) throws CompilationException {\n-        return _compile((Expression) source, false);\n+    xpathStr = node.getNodeValue();\n+    xpathStr = xpathStr.trim();\n+    if (xpathStr.length() == 0) {\n+      throw new CompilationException(__msgs.warnXPath20Syntax(DOMUtils.domToString(node), \"empty string\"));\n     }\n \n-    /**\n-     * @see org.apache.ode.bpel.compiler.v2.ExpressionCompiler#compileLValue(java.lang.Object)\n-     */\n-    public OLValueExpression compileLValue(Object source) throws CompilationException {\n-        return (OLValueExpression) _compile((Expression) source, false);\n-    }\n-\n-    /**\n-     * @see org.apache.ode.bpel.compiler.v2.ExpressionCompiler#compile(java.lang.Object)\n-     */\n-    private OExpression _compile(org.apache.ode.bpel.compiler.bom.Expression xpath, boolean isJoinCondition)\n-            throws CompilationException {\n-        OXPath20ExpressionBPEL20 oexp = new OXPath20ExpressionBPEL20(_compilerContext.getOProcess(), _qnVarData,\n-                _qnVarProp, _qnLinkStatus, _qnXslTransform, isJoinCondition);\n-        oexp.namespaceCtx = xpath.getNamespaceContext();\n-        doJaxpCompile(oexp, xpath);\n-        return oexp;\n+    out.xpath = xpathStr;\n+    try {\n+      __log.debug(\"Compiling expression \" + xpathStr);\n+      System.setProperty(\n+        \"javax.xml.xpath.XPathFactory:\" + NamespaceConstant.OBJECT_MODEL_SAXON,\n+        \"net.sf.saxon.xpath.XPathFactoryImpl\");\n+      XPathFactory xpf = XPathFactory.newInstance(NamespaceConstant.OBJECT_MODEL_SAXON);\n+      JaxpFunctionResolver funcResolver = new JaxpFunctionResolver(\n+        _compilerContext, out, source.getNamespaceContext(), _bpelNS);\n+      JaxpVariableResolver varResolver = new JaxpVariableResolver(_compilerContext, out);\n+      XPath xpe = xpf.newXPath();\n+      xpe.setXPathFunctionResolver(funcResolver);\n+      xpe.setXPathVariableResolver(varResolver);\n+      xpe.setNamespaceContext(source.getNamespaceContext());\n+      XPathExpression expr = xpe.compile(xpathStr);\n+      // evaluate the expression so as to initialize the variables\n+      try {\n+        expr.evaluate(node);\n+      } catch (XPathExpressionException xpee) {\n+        // swallow errors caused by uninitialized variable\n+      }\n+      for (String varExpr : extractVariableExprs(xpathStr)) {\n+        expr = xpe.compile(varExpr);\n+        try {\n+          expr.evaluate(node);\n+        } catch (XPathExpressionException xpee) {\n+          // swallow errors caused by uninitialized variable\n+        }\n+      }\n+    } catch (XPathFactoryConfigurationException xpfce) {\n+      __log.debug(xpfce);\n+      __log.info(\"Couldn't validate properly expression \" + xpathStr);\n+    } catch (XPathExpressionException e) {\n+      __log.debug(e);\n+      __log.info(\"Couldn't validate properly expression \" + xpathStr);\n+    } catch (WrappedResolverException wre) {\n+      if (wre._compilationMsg != null) {\n+        throw new CompilationException(wre._compilationMsg, wre);\n+      }\n+      if (wre.getCause() instanceof CompilationException) {\n+        throw (CompilationException) wre.getCause();\n+      }\n+      throw wre;\n     }\n-\n-    private void doJaxpCompile(OXPath20ExpressionBPEL20 out, Expression source) throws CompilationException {\n-        String xpathStr;\n-        Node node = source.getExpression();\n-        if (node == null) {\n-            throw new IllegalStateException(\"XPath string and xpath node are both null\");\n+  }\n+\n+  public Map<String, String> getProperties() {\n+    return _properties;\n+  }\n+\n+  /**\n+   * Returns the list of variable references in the given XPath expression\n+   * that may not have been resolved properly, which is the case especially\n+   * if the expression contains a function, which short circuited the evaluation.\n+   *\n+   * @param xpathStr\n+   * @return list of variable expressions that may not have been resolved properly\n+   */\n+  private List<String> extractVariableExprs(String xpathStr) {\n+    ArrayList<String> variableExprs = new ArrayList<String>();\n+    int firstVariable = xpathStr.indexOf(\"$\"),\n+      lastVariable = xpathStr.lastIndexOf(\"$\"),\n+      firstFunction = xpathStr.indexOf(\"(\");\n+    if ((firstVariable > 0 && // the xpath references a variable\n+      firstFunction > 0) || // the xpath contains a function\n+      (firstVariable < lastVariable)) { // the xpath references multiple variables\n+      // most likely, the variable reference has not been resolved, so make that happen\n+      StringBuffer variableExpr = new StringBuffer();\n+      boolean quoted = false, doubleQuoted = false, variable = false;\n+      Name11Checker nameChecker = Name11Checker.getInstance();\n+      for (int index = 0; index < xpathStr.length(); index++) {\n+        char ch = xpathStr.charAt(index);\n+        if (ch == '\\'') {\n+          quoted = !quoted;\n         }\n-        if (node.getNodeType() != Node.TEXT_NODE) {\n-            throw new CompilationException(__msgs.errUnexpectedNodeTypeForXPath(DOMUtils.domToString(node)));\n+        if (ch == '\\\"') {\n+          doubleQuoted = !doubleQuoted;\n         }\n-        xpathStr = node.getNodeValue();\n-        xpathStr = xpathStr.trim();\n-        if (xpathStr.length() == 0) {\n-            throw new CompilationException(__msgs.warnXPath20Syntax(DOMUtils.domToString(node), \"empty string\"));\n+        if (quoted || doubleQuoted) {\n+          continue;\n         }\n-\n-        out.xpath = xpathStr;\n-        try {        \t\n-            __log.debug(\"Compiling expression \" + xpathStr);            \n-            System.setProperty(\n-            \t\t\"javax.xml.xpath.XPathFactory:\" + NamespaceConstant.OBJECT_MODEL_SAXON,\n-            \t\t\"net.sf.saxon.xpath.XPathFactoryImpl\");\n-            XPathFactory xpf = XPathFactory.newInstance(NamespaceConstant.OBJECT_MODEL_SAXON);\n-            JaxpFunctionResolver funcResolver = new JaxpFunctionResolver(\n-                    _compilerContext, out, source.getNamespaceContext(), _bpelNS);\n-            JaxpVariableResolver varResolver = new JaxpVariableResolver(_compilerContext, out);\n-            XPath xpe = xpf.newXPath();\n-            xpe.setXPathFunctionResolver(funcResolver);\n-            xpe.setXPathVariableResolver(varResolver);\n-            xpe.setNamespaceContext(source.getNamespaceContext());\n-            XPathExpression expr = xpe.compile(xpathStr);\n-            // evaluate the expression so as to initialize the variables\n-            try { \n-            \texpr.evaluate(node); \n-            } catch (XPathExpressionException xpee) { \n-            \t// swallow errors caused by uninitialized variable \n+        if (ch == '$') {\n+          variable = true;\n+          variableExpr.setLength(0);\n+          variableExpr.append(ch);\n+        } else {\n+          if (variable) {\n+            variableExpr.append(ch);\n+            // in the name is qualified, don't check if its a qname when we're at the \":\" character\n+            if (ch == ':') {\n+              continue;\n             }\n-            for (String varExpr : extractVariableExprs(xpathStr)) {\n-                expr = xpe.compile(varExpr);\n-            \ttry {\n-            \t\texpr.evaluate(node);\n-            \t} catch (XPathExpressionException xpee) {\n-                \t// swallow errors caused by uninitialized variable \n-            \t}\n+            if (index == xpathStr.length() ||\n+              !nameChecker.isQName(variableExpr.substring(1))) {\n+              variable = false;\n+              variableExpr.setLength(variableExpr.length() - 1);\n+              variableExprs.add(variableExpr.toString());\n             }\n-        } catch (XPathFactoryConfigurationException xpfce) {\n-            __log.debug(xpfce);\n-            __log.info(\"Couldn't validate properly expression \" + xpathStr);\n-        } catch (XPathExpressionException e) {\n-            __log.debug(e);\n-            __log.info(\"Couldn't validate properly expression \" + xpathStr);\n-        } catch (WrappedResolverException wre) {\n-            if (wre._compilationMsg != null)\n-                throw new CompilationException(wre._compilationMsg, wre);\n-            if (wre.getCause() instanceof CompilationException)\n-                throw (CompilationException) wre.getCause();\n-            throw wre;\n+          }\n         }\n+      }\n     }\n-\n-    public Map<String, String> getProperties() {\n-        return _properties;\n-    }\n-\n-    /**\n-     * Returns the list of variable references in the given XPath expression\n-     * that may not have been resolved properly, which is the case especially \n-     * if the expression contains a function, which short circuited the evaluation.\n-     *  \n-     * @param xpathStr\n-     * @return list of variable expressions that may not have been resolved properly\n-     */\n-    private List<String> extractVariableExprs(String xpathStr) {    \t\n-\t\tArrayList<String> variableExprs = new ArrayList<String>();\n-\t\tint firstVariable = xpathStr.indexOf(\"$\"), \n-\t\t\tlastVariable = xpathStr.lastIndexOf(\"$\"),\n-\t\t\tfirstFunction = xpathStr.indexOf(\"(\"); \n-\t\tif ((firstVariable > 0 && // the xpath references a variable\n-\t\t\t\tfirstFunction > 0) || // the xpath contains a function\n-\t\t\t(firstVariable < lastVariable)) { // the xpath references multiple variables  \n-\t\t\t// most likely, the variable reference has not been resolved, so make that happen\n-\t\t\tStringBuffer variableExpr = new StringBuffer();\n-\t\t\tboolean quoted = false, doubleQuoted = false, variable = false;\n-\t\t\tName11Checker nameChecker = Name11Checker.getInstance();\n-\t\t\tfor (int index = 0; index < xpathStr.length(); index++) {\n-\t\t\t\tchar ch = xpathStr.charAt(index);\n-\t\t\t\tif (ch == '\\''){\n-\t\t\t\t\tquoted = !quoted;\n-\t\t\t\t}\n-\t\t\t\tif (ch == '\\\"') {\n-\t\t\t\t\tdoubleQuoted = !doubleQuoted;\n-\t\t\t\t}\n-\t\t\t\tif (quoted || doubleQuoted){\n-\t\t\t\t\tcontinue;\n-\t\t\t\t}\n-\t\t\t\tif (ch == '$') {\n-\t\t\t\t\tvariable = true;\n-\t\t\t\t\tvariableExpr.setLength(0);\n-\t\t\t\t\tvariableExpr.append(ch);\n-\t\t\t\t} else {\n-\t\t\t\t\tif (variable) {\n-\t\t\t\t\t\tvariableExpr.append(ch);\n-\t\t\t\t\t\t// in the name is qualified, don't check if its a qname when we're at the \":\" character\n-\t\t\t\t\t\tif (ch == ':') {\n-\t\t\t\t\t\t\tcontinue;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tif (index == xpathStr.length() || \n-\t\t\t\t\t\t\t\t!nameChecker.isQName(variableExpr.substring(1))) {\n-\t\t\t\t\t\t\tvariable = false;\n-\t\t\t\t\t\t\tvariableExpr.setLength(variableExpr.length() - 1);\n-\t\t\t\t\t\t\tvariableExprs.add(variableExpr.toString());\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn variableExprs;\n-\t}\n+    return variableExprs;\n+  }\n \n }\n",
            "diff_size": 266
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "226",
                    "severity": "error",
                    "message": "Line is longer than 120 characters (found 135).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/212/XPath20ExpressionCompilerImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler_three_grams/212/XPath20ExpressionCompilerImpl.java\nindex e64e663ceb8..dbb4cc2baa9 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/212/XPath20ExpressionCompilerImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler_three_grams/212/XPath20ExpressionCompilerImpl.java\n@@ -223,7 +223,7 @@ public class XPath20ExpressionCompilerImpl implements ExpressionCompiler {\n \t\t\t\t} else {\n \t\t\t\t\tif (variable) {\n \t\t\t\t\t\tvariableExpr.append(ch);\n-\t\t\t\t\t\t// in the name is qualified, don't check if its a qname when we're at the \":\" character\n+// in the name is qualified, don't check if its a qname when we're at the \":\" character\n \t\t\t\t\t\tif (ch == ':') {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "naturalize",
        "codebuff",
        "styler_random"
    ]
}