{
    "project_name": "codefollower-H2-Research",
    "error_id": "270",
    "information": {
        "errors": [
            {
                "line": "104",
                "column": "29",
                "severity": "warning",
                "message": "'typecast' is not followed by whitespace.",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAfterCheck"
            }
        ]
    },
    "source_code": "        values = new CacheObject[len];\n        recordCount = 0;\n        memory = len * (long)Constants.MEMORY_POINTER;\n    }\n\n    @Override",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/270/CacheLRU.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler/270/CacheLRU.java\nindex edb4327b180..a786bba8740 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/270/CacheLRU.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler/270/CacheLRU.java\n@@ -101,7 +101,7 @@ public class CacheLRU implements Cache {\n         values = null;\n         values = new CacheObject[len];\n         recordCount = 0;\n-        memory = len * (long)Constants.MEMORY_POINTER;\n+        memory = len * (long) Constants.MEMORY_POINTER;\n     }\n \n     @Override\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/270/CacheLRU.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/270/CacheLRU.java\nindex edb4327b180..b69ee3ef848 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/270/CacheLRU.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/270/CacheLRU.java\n@@ -3,11 +3,13 @@\n  * and the EPL 1.0 (http://h2database.com/html/license.html).\n  * Initial Developer: H2 Group\n  */\n+\n package org.h2.util;\n \n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.Map;\n+\n import org.h2.engine.Constants;\n import org.h2.engine.SysProperties;\n import org.h2.message.DbException;\n@@ -17,371 +19,371 @@ import org.h2.message.DbException;\n  */\n public class CacheLRU implements Cache {\n \n-    static final String TYPE_NAME = \"LRU\";\n+  static final String TYPE_NAME = \"LRU\";\n \n-    private final CacheWriter writer;\n+  private final CacheWriter writer;\n \n-    /**\n-     * Use First-In-First-Out (don't move recently used items to the front of\n-     * the queue).\n-     */\n-    private final boolean fifo;\n+  /**\n+   * Use First-In-First-Out (don't move recently used items to the front of\n+   * the queue).\n+   */\n+  private final boolean fifo;\n \n-    private final CacheObject head = new CacheHead();\n-    private final int mask;\n-    private CacheObject[] values;\n-    private int recordCount;\n+  private final CacheObject head = new CacheHead();\n+  private final int mask;\n+  private CacheObject[] values;\n+  private int recordCount;\n \n-    /**\n-     * The number of cache buckets.\n-     */\n-    private final int len;\n+  /**\n+   * The number of cache buckets.\n+   */\n+  private final int len;\n \n-    /**\n-     * The maximum memory, in words (4 bytes each).\n-     */\n-    private long maxMemory;\n+  /**\n+   * The maximum memory, in words (4 bytes each).\n+   */\n+  private long maxMemory;\n \n-    /**\n-     * The current memory used in this cache, in words (4 bytes each).\n-     */\n-    private long memory;\n+  /**\n+   * The current memory used in this cache, in words (4 bytes each).\n+   */\n+  private long memory;\n \n-    CacheLRU(CacheWriter writer, int maxMemoryKb, boolean fifo) {\n-        this.writer = writer;\n-        this.fifo = fifo;\n-        this.setMaxMemory(maxMemoryKb);\n-        long tmpLen;\n-        try {\n-            tmpLen = MathUtils.nextPowerOf2(maxMemory / 64);\n-        } catch (IllegalArgumentException e) {\n-            throw new IllegalStateException(\"This much cache memory is not supported: \" + maxMemoryKb + \"kb\", e);\n-        }\n-        if (tmpLen > Integer.MAX_VALUE) {\n-            throw new IllegalStateException(\"do not support this much cache memory: \" + maxMemoryKb + \"kb\");\n-        }\n-        this.len = (int) tmpLen;\n-        this.mask = len - 1;\n-        clear();\n+  CacheLRU(CacheWriter writer, int maxMemoryKb, boolean fifo) {\n+    this.writer = writer;\n+    this.fifo = fifo;\n+    this.setMaxMemory(maxMemoryKb);\n+    long tmpLen;\n+    try {\n+      tmpLen = MathUtils.nextPowerOf2(maxMemory / 64);\n+    } catch (IllegalArgumentException e) {\n+      throw new IllegalStateException(\"This much cache memory is not supported: \" + maxMemoryKb + \"kb\", e);\n+    }\n+    if (tmpLen > Integer.MAX_VALUE) {\n+      throw new IllegalStateException(\"do not support this much cache memory: \" + maxMemoryKb + \"kb\");\n     }\n+    this.len = (int) tmpLen;\n+    this.mask = len - 1;\n+    clear();\n+  }\n \n-    /**\n-     * Create a cache of the given type and size.\n-     *\n-     * @param writer the cache writer\n-     * @param cacheType the cache type\n-     * @param cacheSize the size\n-     * @return the cache object\n-     */\n-    public static Cache getCache(CacheWriter writer, String cacheType,\n-            int cacheSize) {\n-        Map<Integer, CacheObject> secondLevel = null;\n-        if (cacheType.startsWith(\"SOFT_\")) {\n-            secondLevel = new SoftHashMap<>();\n-            cacheType = cacheType.substring(\"SOFT_\".length());\n-        }\n-        Cache cache;\n-        if (CacheLRU.TYPE_NAME.equals(cacheType)) {\n-            cache = new CacheLRU(writer, cacheSize, false);\n-        } else if (CacheTQ.TYPE_NAME.equals(cacheType)) {\n-            cache = new CacheTQ(writer, cacheSize);\n-        } else {\n-            throw DbException.getInvalidValueException(\"CACHE_TYPE\", cacheType);\n-        }\n-        if (secondLevel != null) {\n-            cache = new CacheSecondLevel(cache, secondLevel);\n-        }\n-        return cache;\n+  /**\n+   * Create a cache of the given type and size.\n+   *\n+   * @param writer    the cache writer\n+   * @param cacheType the cache type\n+   * @param cacheSize the size\n+   * @return the cache object\n+   */\n+  public static Cache getCache(CacheWriter writer, String cacheType,\n+                               int cacheSize) {\n+    Map<Integer, CacheObject> secondLevel = null;\n+    if (cacheType.startsWith(\"SOFT_\")) {\n+      secondLevel = new SoftHashMap<>();\n+      cacheType = cacheType.substring(\"SOFT_\".length());\n     }\n+    Cache cache;\n+    if (CacheLRU.TYPE_NAME.equals(cacheType)) {\n+      cache = new CacheLRU(writer, cacheSize, false);\n+    } else if (CacheTQ.TYPE_NAME.equals(cacheType)) {\n+      cache = new CacheTQ(writer, cacheSize);\n+    } else {\n+      throw DbException.getInvalidValueException(\"CACHE_TYPE\", cacheType);\n+    }\n+    if (secondLevel != null) {\n+      cache = new CacheSecondLevel(cache, secondLevel);\n+    }\n+    return cache;\n+  }\n+\n+  @Override\n+  public void clear() {\n+    head.cacheNext = head.cachePrevious = head;\n+    // first set to null - avoiding out of memory\n+    values = null;\n+    values = new CacheObject[len];\n+    recordCount = 0;\n+    memory = len * (long) Constants.MEMORY_POINTER;\n+  }\n \n-    @Override\n-    public void clear() {\n-        head.cacheNext = head.cachePrevious = head;\n-        // first set to null - avoiding out of memory\n-        values = null;\n-        values = new CacheObject[len];\n-        recordCount = 0;\n-        memory = len * (long)Constants.MEMORY_POINTER;\n+  @Override\n+  public void put(CacheObject rec) {\n+    if (SysProperties.CHECK) {\n+      int pos = rec.getPos();\n+      CacheObject old = find(pos);\n+      if (old != null) {\n+        DbException\n+            .throwInternalError(\"try to add a record twice at pos \" +\n+                pos);\n+      }\n     }\n+    int index = rec.getPos() & mask;\n+    rec.cacheChained = values[index];\n+    values[index] = rec;\n+    recordCount++;\n+    memory += rec.getMemory();\n+    addToFront(rec);\n+    removeOldIfRequired();\n+  }\n \n-    @Override\n-    public void put(CacheObject rec) {\n-        if (SysProperties.CHECK) {\n-            int pos = rec.getPos();\n-            CacheObject old = find(pos);\n-            if (old != null) {\n-                DbException\n-                        .throwInternalError(\"try to add a record twice at pos \" +\n-                                pos);\n-            }\n+  @Override\n+  public CacheObject update(int pos, CacheObject rec) {\n+    CacheObject old = find(pos);\n+    if (old == null) {\n+      put(rec);\n+    } else {\n+      if (SysProperties.CHECK) {\n+        if (old != rec) {\n+          DbException.throwInternalError(\"old!=record pos:\" + pos +\n+              \" old:\" + old + \" new:\" + rec);\n         }\n-        int index = rec.getPos() & mask;\n-        rec.cacheChained = values[index];\n-        values[index] = rec;\n-        recordCount++;\n-        memory += rec.getMemory();\n+      }\n+      if (!fifo) {\n+        removeFromLinkedList(rec);\n         addToFront(rec);\n-        removeOldIfRequired();\n+      }\n     }\n+    return old;\n+  }\n \n-    @Override\n-    public CacheObject update(int pos, CacheObject rec) {\n-        CacheObject old = find(pos);\n-        if (old == null) {\n-            put(rec);\n-        } else {\n-            if (SysProperties.CHECK) {\n-                if (old != rec) {\n-                    DbException.throwInternalError(\"old!=record pos:\" + pos +\n-                            \" old:\" + old + \" new:\" + rec);\n-                }\n-            }\n-            if (!fifo) {\n-                removeFromLinkedList(rec);\n-                addToFront(rec);\n-            }\n-        }\n-        return old;\n+  private void removeOldIfRequired() {\n+    // a small method, to allow inlining\n+    if (memory >= maxMemory) {\n+      removeOld();\n     }\n+  }\n \n-    private void removeOldIfRequired() {\n-        // a small method, to allow inlining\n-        if (memory >= maxMemory) {\n-            removeOld();\n+  private void removeOld() {\n+    int i = 0;\n+    ArrayList<CacheObject> changed = New.arrayList();\n+    long mem = memory;\n+    int rc = recordCount;\n+    boolean flushed = false;\n+    CacheObject next = head.cacheNext;\n+    while (true) {\n+      if (rc <= Constants.CACHE_MIN_RECORDS) {\n+        break;\n+      }\n+      if (changed.size() == 0) {\n+        if (mem <= maxMemory) {\n+          break;\n+        }\n+      } else {\n+        if (mem * 4 <= maxMemory * 3) {\n+          break;\n+        }\n+      }\n+      CacheObject check = next;\n+      next = check.cacheNext;\n+      i++;\n+      if (i >= recordCount) {\n+        if (!flushed) {\n+          writer.flushLog();\n+          flushed = true;\n+          i = 0;\n+        } else {\n+          // can't remove any record, because the records can not be\n+          // removed hopefully this does not happen frequently, but it\n+          // can happen\n+          writer.getTrace()\n+              .info(\"cannot remove records, cache size too small? records:\" +\n+                  recordCount + \" memory:\" + memory);\n+          break;\n         }\n+      }\n+      if (SysProperties.CHECK && check == head) {\n+        DbException.throwInternalError(\"try to remove head\");\n+      }\n+      // we are not allowed to remove it if the log is not yet written\n+      // (because we need to log before writing the data)\n+      // also, can't write it if the record is pinned\n+      if (!check.canRemove()) {\n+        removeFromLinkedList(check);\n+        addToFront(check);\n+        continue;\n+      }\n+      rc--;\n+      mem -= check.getMemory();\n+      if (check.isChanged()) {\n+        changed.add(check);\n+      } else {\n+        remove(check.getPos());\n+      }\n     }\n-\n-    private void removeOld() {\n-        int i = 0;\n-        ArrayList<CacheObject> changed = New.arrayList();\n-        long mem = memory;\n-        int rc = recordCount;\n-        boolean flushed = false;\n-        CacheObject next = head.cacheNext;\n-        while (true) {\n-            if (rc <= Constants.CACHE_MIN_RECORDS) {\n-                break;\n-            }\n-            if (changed.size() == 0) {\n-                if (mem <= maxMemory) {\n-                    break;\n-                }\n-            } else {\n-                if (mem * 4 <= maxMemory * 3) {\n-                    break;\n-                }\n-            }\n-            CacheObject check = next;\n-            next = check.cacheNext;\n-            i++;\n-            if (i >= recordCount) {\n-                if (!flushed) {\n-                    writer.flushLog();\n-                    flushed = true;\n-                    i = 0;\n-                } else {\n-                    // can't remove any record, because the records can not be\n-                    // removed hopefully this does not happen frequently, but it\n-                    // can happen\n-                    writer.getTrace()\n-                            .info(\"cannot remove records, cache size too small? records:\" +\n-                                    recordCount + \" memory:\" + memory);\n-                    break;\n-                }\n-            }\n-            if (SysProperties.CHECK && check == head) {\n-                DbException.throwInternalError(\"try to remove head\");\n-            }\n-            // we are not allowed to remove it if the log is not yet written\n-            // (because we need to log before writing the data)\n-            // also, can't write it if the record is pinned\n-            if (!check.canRemove()) {\n-                removeFromLinkedList(check);\n-                addToFront(check);\n-                continue;\n-            }\n-            rc--;\n-            mem -= check.getMemory();\n-            if (check.isChanged()) {\n-                changed.add(check);\n-            } else {\n-                remove(check.getPos());\n-            }\n+    if (changed.size() > 0) {\n+      if (!flushed) {\n+        writer.flushLog();\n+      }\n+      Collections.sort(changed);\n+      long max = maxMemory;\n+      int size = changed.size();\n+      try {\n+        // temporary disable size checking,\n+        // to avoid stack overflow\n+        maxMemory = Long.MAX_VALUE;\n+        for (i = 0; i < size; i++) {\n+          CacheObject rec = changed.get(i);\n+          writer.writeBack(rec);\n         }\n-        if (changed.size() > 0) {\n-            if (!flushed) {\n-                writer.flushLog();\n-            }\n-            Collections.sort(changed);\n-            long max = maxMemory;\n-            int size = changed.size();\n-            try {\n-                // temporary disable size checking,\n-                // to avoid stack overflow\n-                maxMemory = Long.MAX_VALUE;\n-                for (i = 0; i < size; i++) {\n-                    CacheObject rec = changed.get(i);\n-                    writer.writeBack(rec);\n-                }\n-            } finally {\n-                maxMemory = max;\n-            }\n-            for (i = 0; i < size; i++) {\n-                CacheObject rec = changed.get(i);\n-                remove(rec.getPos());\n-                if (SysProperties.CHECK) {\n-                    if (rec.cacheNext != null) {\n-                        throw DbException.throwInternalError();\n-                    }\n-                }\n-            }\n+      } finally {\n+        maxMemory = max;\n+      }\n+      for (i = 0; i < size; i++) {\n+        CacheObject rec = changed.get(i);\n+        remove(rec.getPos());\n+        if (SysProperties.CHECK) {\n+          if (rec.cacheNext != null) {\n+            throw DbException.throwInternalError();\n+          }\n         }\n+      }\n     }\n+  }\n \n-    private void addToFront(CacheObject rec) {\n-        if (SysProperties.CHECK && rec == head) {\n-            DbException.throwInternalError(\"try to move head\");\n-        }\n-        rec.cacheNext = head;\n-        rec.cachePrevious = head.cachePrevious;\n-        rec.cachePrevious.cacheNext = rec;\n-        head.cachePrevious = rec;\n+  private void addToFront(CacheObject rec) {\n+    if (SysProperties.CHECK && rec == head) {\n+      DbException.throwInternalError(\"try to move head\");\n     }\n+    rec.cacheNext = head;\n+    rec.cachePrevious = head.cachePrevious;\n+    rec.cachePrevious.cacheNext = rec;\n+    head.cachePrevious = rec;\n+  }\n \n-    private void removeFromLinkedList(CacheObject rec) {\n-        if (SysProperties.CHECK && rec == head) {\n-            DbException.throwInternalError(\"try to remove head\");\n-        }\n-        rec.cachePrevious.cacheNext = rec.cacheNext;\n-        rec.cacheNext.cachePrevious = rec.cachePrevious;\n-        // TODO cache: mystery: why is this required? needs more memory if we\n-        // don't do this\n-        rec.cacheNext = null;\n-        rec.cachePrevious = null;\n+  private void removeFromLinkedList(CacheObject rec) {\n+    if (SysProperties.CHECK && rec == head) {\n+      DbException.throwInternalError(\"try to remove head\");\n     }\n+    rec.cachePrevious.cacheNext = rec.cacheNext;\n+    rec.cacheNext.cachePrevious = rec.cachePrevious;\n+    // TODO cache: mystery: why is this required? needs more memory if we\n+    // don't do this\n+    rec.cacheNext = null;\n+    rec.cachePrevious = null;\n+  }\n \n-    @Override\n-    public boolean remove(int pos) {\n-        int index = pos & mask;\n-        CacheObject rec = values[index];\n+  @Override\n+  public boolean remove(int pos) {\n+    int index = pos & mask;\n+    CacheObject rec = values[index];\n+    if (rec == null) {\n+      return false;\n+    }\n+    if (rec.getPos() == pos) {\n+      values[index] = rec.cacheChained;\n+    } else {\n+      CacheObject last;\n+      do {\n+        last = rec;\n+        rec = rec.cacheChained;\n         if (rec == null) {\n-            return false;\n+          return false;\n         }\n-        if (rec.getPos() == pos) {\n-            values[index] = rec.cacheChained;\n-        } else {\n-            CacheObject last;\n-            do {\n-                last = rec;\n-                rec = rec.cacheChained;\n-                if (rec == null) {\n-                    return false;\n-                }\n-            } while (rec.getPos() != pos);\n-            last.cacheChained = rec.cacheChained;\n-        }\n-        recordCount--;\n-        memory -= rec.getMemory();\n-        removeFromLinkedList(rec);\n-        if (SysProperties.CHECK) {\n-            rec.cacheChained = null;\n-            CacheObject o = find(pos);\n-            if (o != null) {\n-                DbException.throwInternalError(\"not removed: \" + o);\n-            }\n-        }\n-        return true;\n+      } while (rec.getPos() != pos);\n+      last.cacheChained = rec.cacheChained;\n+    }\n+    recordCount--;\n+    memory -= rec.getMemory();\n+    removeFromLinkedList(rec);\n+    if (SysProperties.CHECK) {\n+      rec.cacheChained = null;\n+      CacheObject o = find(pos);\n+      if (o != null) {\n+        DbException.throwInternalError(\"not removed: \" + o);\n+      }\n     }\n+    return true;\n+  }\n \n-    @Override\n-    public CacheObject find(int pos) {\n-        CacheObject rec = values[pos & mask];\n-        while (rec != null && rec.getPos() != pos) {\n-            rec = rec.cacheChained;\n-        }\n-        return rec;\n+  @Override\n+  public CacheObject find(int pos) {\n+    CacheObject rec = values[pos & mask];\n+    while (rec != null && rec.getPos() != pos) {\n+      rec = rec.cacheChained;\n     }\n+    return rec;\n+  }\n \n-    @Override\n-    public CacheObject get(int pos) {\n-        CacheObject rec = find(pos);\n-        if (rec != null) {\n-            if (!fifo) {\n-                removeFromLinkedList(rec);\n-                addToFront(rec);\n-            }\n-        }\n-        return rec;\n+  @Override\n+  public CacheObject get(int pos) {\n+    CacheObject rec = find(pos);\n+    if (rec != null) {\n+      if (!fifo) {\n+        removeFromLinkedList(rec);\n+        addToFront(rec);\n+      }\n     }\n+    return rec;\n+  }\n \n-    // private void testConsistency() {\n-    // int s = size;\n-    // HashSet set = new HashSet();\n-    // for(int i=0; i<values.length; i++) {\n-    // Record rec = values[i];\n-    // if(rec == null) {\n-    // continue;\n-    // }\n-    // set.add(rec);\n-    // while(rec.chained != null) {\n-    // rec = rec.chained;\n-    // set.add(rec);\n-    // }\n-    // }\n-    // Record rec = head.next;\n-    // while(rec != head) {\n-    // set.add(rec);\n-    // rec = rec.next;\n-    // }\n-    // rec = head.previous;\n-    // while(rec != head) {\n-    // set.add(rec);\n-    // rec = rec.previous;\n-    // }\n-    // if(set.size() != size) {\n-    // System.out.println(\"size=\"+size+\" but el.size=\"+set.size());\n-    // }\n-    // }\n+  // private void testConsistency() {\n+  // int s = size;\n+  // HashSet set = new HashSet();\n+  // for(int i=0; i<values.length; i++) {\n+  // Record rec = values[i];\n+  // if(rec == null) {\n+  // continue;\n+  // }\n+  // set.add(rec);\n+  // while(rec.chained != null) {\n+  // rec = rec.chained;\n+  // set.add(rec);\n+  // }\n+  // }\n+  // Record rec = head.next;\n+  // while(rec != head) {\n+  // set.add(rec);\n+  // rec = rec.next;\n+  // }\n+  // rec = head.previous;\n+  // while(rec != head) {\n+  // set.add(rec);\n+  // rec = rec.previous;\n+  // }\n+  // if(set.size() != size) {\n+  // System.out.println(\"size=\"+size+\" but el.size=\"+set.size());\n+  // }\n+  // }\n \n-    @Override\n-    public ArrayList<CacheObject> getAllChanged() {\n-        // if(Database.CHECK) {\n-        // testConsistency();\n-        // }\n-        ArrayList<CacheObject> list = New.arrayList();\n-        CacheObject rec = head.cacheNext;\n-        while (rec != head) {\n-            if (rec.isChanged()) {\n-                list.add(rec);\n-            }\n-            rec = rec.cacheNext;\n-        }\n-        return list;\n+  @Override\n+  public ArrayList<CacheObject> getAllChanged() {\n+    // if(Database.CHECK) {\n+    // testConsistency();\n+    // }\n+    ArrayList<CacheObject> list = New.arrayList();\n+    CacheObject rec = head.cacheNext;\n+    while (rec != head) {\n+      if (rec.isChanged()) {\n+        list.add(rec);\n+      }\n+      rec = rec.cacheNext;\n     }\n+    return list;\n+  }\n \n-    @Override\n-    public void setMaxMemory(int maxKb) {\n-        long newSize = maxKb * 1024L / 4;\n-        maxMemory = newSize < 0 ? 0 : newSize;\n-        // can not resize, otherwise existing records are lost\n-        // resize(maxSize);\n-        removeOldIfRequired();\n-    }\n+  @Override\n+  public void setMaxMemory(int maxKb) {\n+    long newSize = maxKb * 1024L / 4;\n+    maxMemory = newSize < 0 ? 0 : newSize;\n+    // can not resize, otherwise existing records are lost\n+    // resize(maxSize);\n+    removeOldIfRequired();\n+  }\n \n-    @Override\n-    public int getMaxMemory() {\n-        return (int) (maxMemory * 4L / 1024);\n-    }\n+  @Override\n+  public int getMaxMemory() {\n+    return (int) (maxMemory * 4L / 1024);\n+  }\n \n-    @Override\n-    public int getMemory() {\n-        // CacheObject rec = head.cacheNext;\n-        // while (rec != head) {\n-        // System.out.println(rec.getMemory() + \" \" +\n-        // MemoryFootprint.getObjectSize(rec) + \" \" + rec);\n-        // rec = rec.cacheNext;\n-        // }\n-        return (int) (memory * 4L / 1024);\n-    }\n+  @Override\n+  public int getMemory() {\n+    // CacheObject rec = head.cacheNext;\n+    // while (rec != head) {\n+    // System.out.println(rec.getMemory() + \" \" +\n+    // MemoryFootprint.getObjectSize(rec) + \" \" + rec);\n+    // rec = rec.cacheNext;\n+    // }\n+    return (int) (memory * 4L / 1024);\n+  }\n \n }\n",
            "diff_size": 449
        },
        {
            "tool": "naturalize",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/270/CacheLRU.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/naturalize/270/CacheLRU.java\nindex edb4327b180..86f568793a9 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/270/CacheLRU.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/naturalize/270/CacheLRU.java\n@@ -101,7 +101,7 @@ public class CacheLRU implements Cache {\n         values = null;\n         values = new CacheObject[len];\n         recordCount = 0;\n-        memory = len * (long)Constants.MEMORY_POINTER;\n+        memory = len * (long) Constants.MEMORY_POINTER;\n     }\n \n     @Override\n@@ -110,8 +110,7 @@ public class CacheLRU implements Cache {\n             int pos = rec.getPos();\n             CacheObject old = find(pos);\n             if (old != null) {\n-                DbException\n-                        .throwInternalError(\"try to add a record twice at pos \" +\n+                DbException.throwInternalError(\"try to add a record twice at pos \" +\n                                 pos);\n             }\n         }\n@@ -384,4 +383,4 @@ public class CacheLRU implements Cache {\n         return (int) (memory * 4L / 1024);\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 4
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/270/CacheLRU.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/codebuff/270/CacheLRU.java\nindex edb4327b180..be915dcc035 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/270/CacheLRU.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/codebuff/270/CacheLRU.java\n@@ -15,10 +15,12 @@ import org.h2.message.DbException;\n /**\n  * A cache implementation based on the last recently used (LRU) algorithm.\n  */\n+\n+\n public class CacheLRU implements Cache {\n \n-    static final String TYPE_NAME = \"LRU\";\n \n+    static final String TYPE_NAME = \"LRU\";\n     private final CacheWriter writer;\n \n     /**\n@@ -26,7 +28,6 @@ public class CacheLRU implements Cache {\n      * the queue).\n      */\n     private final boolean fifo;\n-\n     private final CacheObject head = new CacheHead();\n     private final int mask;\n     private CacheObject[] values;\n@@ -73,11 +74,12 @@ public class CacheLRU implements Cache {\n      * @param cacheSize the size\n      * @return the cache object\n      */\n-    public static Cache getCache(CacheWriter writer, String cacheType,\n-            int cacheSize) {\n+\n+\n+    public static Cache getCache(CacheWriter writer, String cacheType, int cacheSize) {\n         Map<Integer, CacheObject> secondLevel = null;\n         if (cacheType.startsWith(\"SOFT_\")) {\n-            secondLevel = new SoftHashMap<>();\n+            secondLevel = new SoftHashMap< >();\n             cacheType = cacheType.substring(\"SOFT_\".length());\n         }\n         Cache cache;\n@@ -85,7 +87,7 @@ public class CacheLRU implements Cache {\n             cache = new CacheLRU(writer, cacheSize, false);\n         } else if (CacheTQ.TYPE_NAME.equals(cacheType)) {\n             cache = new CacheTQ(writer, cacheSize);\n-        } else {\n+                                                                                      } else {\n             throw DbException.getInvalidValueException(\"CACHE_TYPE\", cacheType);\n         }\n         if (secondLevel != null) {\n@@ -101,7 +103,7 @@ public class CacheLRU implements Cache {\n         values = null;\n         values = new CacheObject[len];\n         recordCount = 0;\n-        memory = len * (long)Constants.MEMORY_POINTER;\n+        memory = len * (long) Constants.MEMORY_POINTER;\n     }\n \n     @Override\n@@ -110,9 +112,7 @@ public class CacheLRU implements Cache {\n             int pos = rec.getPos();\n             CacheObject old = find(pos);\n             if (old != null) {\n-                DbException\n-                        .throwInternalError(\"try to add a record twice at pos \" +\n-                                pos);\n+                DbException.throwInternalError(\"try to add a record twice at pos \" + pos);\n             }\n         }\n         int index = rec.getPos() & mask;\n@@ -132,8 +132,8 @@ public class CacheLRU implements Cache {\n         } else {\n             if (SysProperties.CHECK) {\n                 if (old != rec) {\n-                    DbException.throwInternalError(\"old!=record pos:\" + pos +\n-                            \" old:\" + old + \" new:\" + rec);\n+                    DbException.throwInternalError(\"old!=record pos:\" + pos + \" old:\"\n+                    + old + \" new:\" + rec);\n                 }\n             }\n             if (!fifo) {\n@@ -183,9 +183,7 @@ public class CacheLRU implements Cache {\n                     // can't remove any record, because the records can not be\n                     // removed hopefully this does not happen frequently, but it\n                     // can happen\n-                    writer.getTrace()\n-                            .info(\"cannot remove records, cache size too small? records:\" +\n-                                    recordCount + \" memory:\" + memory);\n+                    writer.getTrace().info(\"cannot remove records, cache size too small? records:\" + recordCount + \" memory:\" + memory);\n                     break;\n                 }\n             }\n@@ -384,4 +382,4 @@ public class CacheLRU implements Cache {\n         return (int) (memory * 4L / 1024);\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 20
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/270/CacheLRU.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_random/270/CacheLRU.java\nindex edb4327b180..a786bba8740 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/270/CacheLRU.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_random/270/CacheLRU.java\n@@ -101,7 +101,7 @@ public class CacheLRU implements Cache {\n         values = null;\n         values = new CacheObject[len];\n         recordCount = 0;\n-        memory = len * (long)Constants.MEMORY_POINTER;\n+        memory = len * (long) Constants.MEMORY_POINTER;\n     }\n \n     @Override\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/270/CacheLRU.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/270/CacheLRU.java\nindex edb4327b180..a786bba8740 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/270/CacheLRU.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/270/CacheLRU.java\n@@ -101,7 +101,7 @@ public class CacheLRU implements Cache {\n         values = null;\n         values = new CacheObject[len];\n         recordCount = 0;\n-        memory = len * (long)Constants.MEMORY_POINTER;\n+        memory = len * (long) Constants.MEMORY_POINTER;\n     }\n \n     @Override\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": []
}