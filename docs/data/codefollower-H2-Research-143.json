{
    "project_name": "codefollower-H2-Research",
    "error_id": "143",
    "information": {
        "errors": [
            {
                "line": "276",
                "column": "54",
                "severity": "warning",
                "message": "Don't use trailing comments.",
                "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
            }
        ]
    },
    "source_code": "            throw DbException.throwInternalError(\"Prepared.getObjectId() was called before\");\n        }\n        persistedObjectId = -persistedObjectId - 1;  // while negative, it can be restored later\n        return id;\n    }\n",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/143/Prepared.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler/143/Prepared.java\nindex a5ac78c8f32..7a43210497a 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/143/Prepared.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler/143/Prepared.java\n@@ -273,8 +273,9 @@ public abstract class Prepared {\n         } else if (id < 0) {\n             throw DbException.throwInternalError(\"Prepared.getObjectId() was called before\");\n         }\n-        persistedObjectId = -persistedObjectId - 1;  // while negative, it can be restored later\n-        return id;\n+        persistedObjectId = -persistedObjectId - 1;\n+        // while negative, it can be restored later\n+          return id;\n     }\n \n     /**\n",
            "diff_size": 3
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "278",
                    "column": "50",
                    "severity": "warning",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/143/Prepared.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/143/Prepared.java\nindex a5ac78c8f32..2bd464200d4 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/143/Prepared.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/143/Prepared.java\n@@ -3,10 +3,12 @@\n  * and the EPL 1.0 (http://h2database.com/html/license.html).\n  * Initial Developer: H2 Group\n  */\n+\n package org.h2.command;\n \n import java.util.ArrayList;\n import java.util.List;\n+\n import org.h2.api.DatabaseEventListener;\n import org.h2.api.ErrorCode;\n import org.h2.engine.Database;\n@@ -25,451 +27,451 @@ import org.h2.value.Value;\n  */\n public abstract class Prepared {\n \n-    /**\n-     * The session.\n-     */\n-    protected Session session;\n-\n-    /**\n-     * The SQL string.\n-     */\n-    protected String sqlStatement;\n-\n-    /**\n-     * Whether to create a new object (for indexes).\n-     */\n-    protected boolean create = true;\n-\n-    /**\n-     * The list of parameters.\n-     */\n-    protected ArrayList<Parameter> parameters;\n-\n-    /**\n-     * If the query should be prepared before each execution. This is set for\n-     * queries with LIKE ?, because the query plan depends on the parameter\n-     * value.\n-     */\n-    protected boolean prepareAlways;\n-\n-    private long modificationMetaId;\n-    private Command command;\n-    /**\n-     * Used to preserve object identities on database startup. {@code 0} if\n-     * object is not stored, {@code -1} if object is stored and its ID is\n-     * already read, {@code >0} if object is stored and its id is not yet read.\n-     */\n-    private int persistedObjectId;\n-    private int currentRowNumber;\n-    private int rowScanCount;\n-    /**\n-     * Common table expressions (CTE) in queries require us to create temporary views,\n-     * which need to be cleaned up once a command is done executing.\n-     */\n-    private List<TableView> cteCleanups;\n-\n-    /**\n-     * Create a new object.\n-     *\n-     * @param session the session\n-     */\n-    public Prepared(Session session) {\n-        this.session = session;\n-        modificationMetaId = session.getDatabase().getModificationMetaId();\n-    }\n-\n-    /**\n-     * Check if this command is transactional.\n-     * If it is not, then it forces the current transaction to commit.\n-     *\n-     * @return true if it is\n-     */\n-    public abstract boolean isTransactional();\n-\n-    /**\n-     * Get an empty result set containing the meta data.\n-     *\n-     * @return the result set\n-     */\n-    public abstract ResultInterface queryMeta();\n-\n-\n-    /**\n-     * Get the command type as defined in CommandInterface\n-     *\n-     * @return the statement type\n-     */\n-    public abstract int getType();\n-\n-    /**\n-     * Check if this command is read only.\n-     *\n-     * @return true if it is\n-     */\n-    public boolean isReadOnly() {\n-        return false;\n-    }\n-\n-    /**\n-     * Check if the statement needs to be re-compiled.\n-     *\n-     * @return true if it must\n-     */\n-    public boolean needRecompile() {\n-        Database db = session.getDatabase();\n-        if (db == null) {\n-            throw DbException.get(ErrorCode.CONNECTION_BROKEN_1, \"database closed\");\n-        }\n-        // parser: currently, compiling every create/drop/... twice\n-        // because needRecompile return true even for the first execution\n-        return prepareAlways ||\n-                modificationMetaId < db.getModificationMetaId() ||\n-                db.getSettings().recompileAlways;\n-    }\n-\n-    /**\n-     * Get the meta data modification id of the database when this statement was\n-     * compiled.\n-     *\n-     * @return the meta data modification id\n-     */\n-    long getModificationMetaId() {\n-        return modificationMetaId;\n-    }\n-\n-    /**\n-     * Set the meta data modification id of this statement.\n-     *\n-     * @param id the new id\n-     */\n-    void setModificationMetaId(long id) {\n-        this.modificationMetaId = id;\n-    }\n-\n-    /**\n-     * Set the parameter list of this statement.\n-     *\n-     * @param parameters the parameter list\n-     */\n-    public void setParameterList(ArrayList<Parameter> parameters) {\n-        this.parameters = parameters;\n-    }\n-\n-    /**\n-     * Get the parameter list.\n-     *\n-     * @return the parameter list\n-     */\n-    public ArrayList<Parameter> getParameters() {\n-        return parameters;\n-    }\n-\n-    /**\n-     * Check if all parameters have been set.\n-     *\n-     * @throws DbException if any parameter has not been set\n-     */\n-    protected void checkParameters() {\n-        if (persistedObjectId < 0) {\n-            // restore original persistedObjectId on Command re-run\n-            // i.e. due to concurrent update\n-            persistedObjectId = -persistedObjectId - 1;\n-        }\n-        if (parameters != null) {\n-            for (Parameter param : parameters) {\n-                param.checkSet();\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Set the command.\n-     *\n-     * @param command the new command\n-     */\n-    public void setCommand(Command command) {\n-        this.command = command;\n-    }\n-\n-    /**\n-     * Check if this object is a query.\n-     *\n-     * @return true if it is\n-     */\n-    public boolean isQuery() {\n-        return false;\n-    }\n-\n-    /**\n-     * Prepare this statement.\n-     */\n-    public void prepare() {\n-        // nothing to do\n-    }\n-\n-    /**\n-     * Execute the statement.\n-     *\n-     * @return the update count\n-     * @throws DbException if it is a query\n-     */\n-    public int update() {\n-        throw DbException.get(ErrorCode.METHOD_NOT_ALLOWED_FOR_QUERY);\n-    }\n-\n-    /**\n-     * Execute the query.\n-     *\n-     * @param maxrows the maximum number of rows to return\n-     * @return the result set\n-     * @throws DbException if it is not a query\n-     */\n-    @SuppressWarnings(\"unused\")\n-    public ResultInterface query(int maxrows) {\n-        throw DbException.get(ErrorCode.METHOD_ONLY_ALLOWED_FOR_QUERY);\n-    }\n-\n-    /**\n-     * Set the SQL statement.\n-     *\n-     * @param sql the SQL statement\n-     */\n-    public void setSQL(String sql) {\n-        this.sqlStatement = sql;\n-    }\n-\n-    /**\n-     * Get the SQL statement.\n-     *\n-     * @return the SQL statement\n-     */\n-    public String getSQL() {\n-        return sqlStatement;\n-    }\n-\n-    /**\n-     * Get the object id to use for the database object that is created in this\n-     * statement. This id is only set when the object is already persisted.\n-     * If not set, this method returns 0.\n-     *\n-     * @return the object id or 0 if not set\n-     */\n-    protected int getPersistedObjectId() {\n-        int id = persistedObjectId;\n-        return id >= 0 ? id : 0;\n-    }\n-\n-    /**\n-     * Get the current object id, or get a new id from the database. The object\n-     * id is used when creating new database object (CREATE statement). This\n-     * method may be called only once.\n-     *\n-     * @return the object id\n-     */\n-    protected int getObjectId() {\n-        int id = persistedObjectId;\n-        if (id == 0) {\n-            id = session.getDatabase().allocateObjectId();\n-        } else if (id < 0) {\n-            throw DbException.throwInternalError(\"Prepared.getObjectId() was called before\");\n-        }\n-        persistedObjectId = -persistedObjectId - 1;  // while negative, it can be restored later\n-        return id;\n-    }\n-\n-    /**\n-     * Get the SQL statement with the execution plan.\n-     *\n-     * @return the execution plan\n-     */\n-    public String getPlanSQL() {\n-        return null;\n-    }\n-\n-    /**\n-     * Check if this statement was canceled.\n-     *\n-     * @throws DbException if it was canceled\n-     */\n-    public void checkCanceled() {\n-        session.checkCanceled();\n-        Command c = command != null ? command : session.getCurrentCommand();\n-        if (c != null) {\n-            c.checkCanceled();\n-        }\n-    }\n-\n-    /**\n-     * Set the persisted object id for this statement.\n-     *\n-     * @param i the object id\n-     */\n-    public void setPersistedObjectId(int i) {\n-        this.persistedObjectId = i;\n-        this.create = false;\n-    }\n-\n-    /**\n-     * Set the session for this statement.\n-     *\n-     * @param currentSession the new session\n-     */\n-    public void setSession(Session currentSession) {\n-        this.session = currentSession;\n-    }\n-\n-    /**\n-     * Print information about the statement executed if info trace level is\n-     * enabled.\n-     *\n-     * @param startTimeNanos when the statement was started\n-     * @param rowCount the query or update row count\n-     */\n-    void trace(long startTimeNanos, int rowCount) {\n-        if (session.getTrace().isInfoEnabled() && startTimeNanos > 0) {\n-            long deltaTimeNanos = System.nanoTime() - startTimeNanos;\n-            String params = Trace.formatParams(parameters);\n-            session.getTrace().infoSQL(sqlStatement, params, rowCount,\n-                    deltaTimeNanos / 1000 / 1000);\n-        }\n-        // startTime_nanos can be zero for the command that actually turns on\n-        // statistics\n-        if (session.getDatabase().getQueryStatistics() && startTimeNanos != 0) {\n-            long deltaTimeNanos = System.nanoTime() - startTimeNanos;\n-            session.getDatabase().getQueryStatisticsData().\n-                    update(toString(), deltaTimeNanos, rowCount);\n-        }\n-    }\n-\n-    /**\n-     * Set the prepare always flag.\n-     * If set, the statement is re-compiled whenever it is executed.\n-     *\n-     * @param prepareAlways the new value\n-     */\n-    public void setPrepareAlways(boolean prepareAlways) {\n-        this.prepareAlways = prepareAlways;\n-    }\n-\n-    /**\n-     * Set the current row number.\n-     *\n-     * @param rowNumber the row number\n-     */\n-    public void setCurrentRowNumber(int rowNumber) {\n-        if ((++rowScanCount & 127) == 0) {\n-            checkCanceled();\n-        }\n-        this.currentRowNumber = rowNumber;\n-        setProgress();\n-    }\n-\n-    /**\n-     * Get the current row number.\n-     *\n-     * @return the row number\n-     */\n-    public int getCurrentRowNumber() {\n-        return currentRowNumber;\n-    }\n-\n-    /**\n-     * Notifies query progress via the DatabaseEventListener\n-     */\n-    private void setProgress() {\n-        if ((currentRowNumber & 127) == 0) {\n-            session.getDatabase().setProgress(\n-                    DatabaseEventListener.STATE_STATEMENT_PROGRESS,\n-                    sqlStatement, currentRowNumber, 0);\n-        }\n-    }\n-\n-    /**\n-     * Convert the statement to a String.\n-     *\n-     * @return the SQL statement\n-     */\n-    @Override\n-    public String toString() {\n-        return sqlStatement;\n-    }\n-\n-    /**\n-     * Get the SQL snippet of the value list.\n-     *\n-     * @param values the value list\n-     * @return the SQL snippet\n-     */\n-    protected static String getSQL(Value[] values) {\n-        StatementBuilder buff = new StatementBuilder();\n-        for (Value v : values) {\n-            buff.appendExceptFirst(\", \");\n-            if (v != null) {\n-                buff.append(v.getSQL());\n-            }\n-        }\n-        return buff.toString();\n-    }\n-\n-    /**\n-     * Get the SQL snippet of the expression list.\n-     *\n-     * @param list the expression list\n-     * @return the SQL snippet\n-     */\n-    protected static String getSQL(Expression[] list) {\n-        StatementBuilder buff = new StatementBuilder();\n-        for (Expression e : list) {\n-            buff.appendExceptFirst(\", \");\n-            if (e != null) {\n-                buff.append(e.getSQL());\n-            }\n-        }\n-        return buff.toString();\n-    }\n-\n-    /**\n-     * Set the SQL statement of the exception to the given row.\n-     *\n-     * @param e the exception\n-     * @param rowId the row number\n-     * @param values the values of the row\n-     * @return the exception\n-     */\n-    protected DbException setRow(DbException e, int rowId, String values) {\n-        StringBuilder buff = new StringBuilder();\n-        if (sqlStatement != null) {\n-            buff.append(sqlStatement);\n-        }\n-        buff.append(\" -- \");\n-        if (rowId > 0) {\n-            buff.append(\"row #\").append(rowId + 1).append(' ');\n-        }\n-        buff.append('(').append(values).append(')');\n-        return e.addSQL(buff.toString());\n-    }\n-\n-    public boolean isCacheable() {\n-        return false;\n-    }\n-\n-    /**\n-     * @return the temporary views created for CTE's.\n-     */\n-    public List<TableView> getCteCleanups() {\n-        return cteCleanups;\n-    }\n-\n-    /**\n-     * Set the temporary views created for CTE's.\n-     *\n-     * @param cteCleanups the temporary views\n-     */\n-    public void setCteCleanups(List<TableView> cteCleanups) {\n-        this.cteCleanups = cteCleanups;\n-    }\n-\n-    public Session getSession() {\n-        return session;\n-    }\n+  /**\n+   * The session.\n+   */\n+  protected Session session;\n+\n+  /**\n+   * The SQL string.\n+   */\n+  protected String sqlStatement;\n+\n+  /**\n+   * Whether to create a new object (for indexes).\n+   */\n+  protected boolean create = true;\n+\n+  /**\n+   * The list of parameters.\n+   */\n+  protected ArrayList<Parameter> parameters;\n+\n+  /**\n+   * If the query should be prepared before each execution. This is set for\n+   * queries with LIKE ?, because the query plan depends on the parameter\n+   * value.\n+   */\n+  protected boolean prepareAlways;\n+\n+  private long modificationMetaId;\n+  private Command command;\n+  /**\n+   * Used to preserve object identities on database startup. {@code 0} if\n+   * object is not stored, {@code -1} if object is stored and its ID is\n+   * already read, {@code >0} if object is stored and its id is not yet read.\n+   */\n+  private int persistedObjectId;\n+  private int currentRowNumber;\n+  private int rowScanCount;\n+  /**\n+   * Common table expressions (CTE) in queries require us to create temporary views,\n+   * which need to be cleaned up once a command is done executing.\n+   */\n+  private List<TableView> cteCleanups;\n+\n+  /**\n+   * Create a new object.\n+   *\n+   * @param session the session\n+   */\n+  public Prepared(Session session) {\n+    this.session = session;\n+    modificationMetaId = session.getDatabase().getModificationMetaId();\n+  }\n+\n+  /**\n+   * Check if this command is transactional.\n+   * If it is not, then it forces the current transaction to commit.\n+   *\n+   * @return true if it is\n+   */\n+  public abstract boolean isTransactional();\n+\n+  /**\n+   * Get an empty result set containing the meta data.\n+   *\n+   * @return the result set\n+   */\n+  public abstract ResultInterface queryMeta();\n+\n+\n+  /**\n+   * Get the command type as defined in CommandInterface\n+   *\n+   * @return the statement type\n+   */\n+  public abstract int getType();\n+\n+  /**\n+   * Check if this command is read only.\n+   *\n+   * @return true if it is\n+   */\n+  public boolean isReadOnly() {\n+    return false;\n+  }\n+\n+  /**\n+   * Check if the statement needs to be re-compiled.\n+   *\n+   * @return true if it must\n+   */\n+  public boolean needRecompile() {\n+    Database db = session.getDatabase();\n+    if (db == null) {\n+      throw DbException.get(ErrorCode.CONNECTION_BROKEN_1, \"database closed\");\n+    }\n+    // parser: currently, compiling every create/drop/... twice\n+    // because needRecompile return true even for the first execution\n+    return prepareAlways ||\n+        modificationMetaId < db.getModificationMetaId() ||\n+        db.getSettings().recompileAlways;\n+  }\n+\n+  /**\n+   * Get the meta data modification id of the database when this statement was\n+   * compiled.\n+   *\n+   * @return the meta data modification id\n+   */\n+  long getModificationMetaId() {\n+    return modificationMetaId;\n+  }\n+\n+  /**\n+   * Set the meta data modification id of this statement.\n+   *\n+   * @param id the new id\n+   */\n+  void setModificationMetaId(long id) {\n+    this.modificationMetaId = id;\n+  }\n+\n+  /**\n+   * Set the parameter list of this statement.\n+   *\n+   * @param parameters the parameter list\n+   */\n+  public void setParameterList(ArrayList<Parameter> parameters) {\n+    this.parameters = parameters;\n+  }\n+\n+  /**\n+   * Get the parameter list.\n+   *\n+   * @return the parameter list\n+   */\n+  public ArrayList<Parameter> getParameters() {\n+    return parameters;\n+  }\n+\n+  /**\n+   * Check if all parameters have been set.\n+   *\n+   * @throws DbException if any parameter has not been set\n+   */\n+  protected void checkParameters() {\n+    if (persistedObjectId < 0) {\n+      // restore original persistedObjectId on Command re-run\n+      // i.e. due to concurrent update\n+      persistedObjectId = -persistedObjectId - 1;\n+    }\n+    if (parameters != null) {\n+      for (Parameter param : parameters) {\n+        param.checkSet();\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Set the command.\n+   *\n+   * @param command the new command\n+   */\n+  public void setCommand(Command command) {\n+    this.command = command;\n+  }\n+\n+  /**\n+   * Check if this object is a query.\n+   *\n+   * @return true if it is\n+   */\n+  public boolean isQuery() {\n+    return false;\n+  }\n+\n+  /**\n+   * Prepare this statement.\n+   */\n+  public void prepare() {\n+    // nothing to do\n+  }\n+\n+  /**\n+   * Execute the statement.\n+   *\n+   * @return the update count\n+   * @throws DbException if it is a query\n+   */\n+  public int update() {\n+    throw DbException.get(ErrorCode.METHOD_NOT_ALLOWED_FOR_QUERY);\n+  }\n+\n+  /**\n+   * Execute the query.\n+   *\n+   * @param maxrows the maximum number of rows to return\n+   * @return the result set\n+   * @throws DbException if it is not a query\n+   */\n+  @SuppressWarnings(\"unused\")\n+  public ResultInterface query(int maxrows) {\n+    throw DbException.get(ErrorCode.METHOD_ONLY_ALLOWED_FOR_QUERY);\n+  }\n+\n+  /**\n+   * Set the SQL statement.\n+   *\n+   * @param sql the SQL statement\n+   */\n+  public void setSQL(String sql) {\n+    this.sqlStatement = sql;\n+  }\n+\n+  /**\n+   * Get the SQL statement.\n+   *\n+   * @return the SQL statement\n+   */\n+  public String getSQL() {\n+    return sqlStatement;\n+  }\n+\n+  /**\n+   * Get the object id to use for the database object that is created in this\n+   * statement. This id is only set when the object is already persisted.\n+   * If not set, this method returns 0.\n+   *\n+   * @return the object id or 0 if not set\n+   */\n+  protected int getPersistedObjectId() {\n+    int id = persistedObjectId;\n+    return id >= 0 ? id : 0;\n+  }\n+\n+  /**\n+   * Get the current object id, or get a new id from the database. The object\n+   * id is used when creating new database object (CREATE statement). This\n+   * method may be called only once.\n+   *\n+   * @return the object id\n+   */\n+  protected int getObjectId() {\n+    int id = persistedObjectId;\n+    if (id == 0) {\n+      id = session.getDatabase().allocateObjectId();\n+    } else if (id < 0) {\n+      throw DbException.throwInternalError(\"Prepared.getObjectId() was called before\");\n+    }\n+    persistedObjectId = -persistedObjectId - 1;  // while negative, it can be restored later\n+    return id;\n+  }\n+\n+  /**\n+   * Get the SQL statement with the execution plan.\n+   *\n+   * @return the execution plan\n+   */\n+  public String getPlanSQL() {\n+    return null;\n+  }\n+\n+  /**\n+   * Check if this statement was canceled.\n+   *\n+   * @throws DbException if it was canceled\n+   */\n+  public void checkCanceled() {\n+    session.checkCanceled();\n+    Command c = command != null ? command : session.getCurrentCommand();\n+    if (c != null) {\n+      c.checkCanceled();\n+    }\n+  }\n+\n+  /**\n+   * Set the persisted object id for this statement.\n+   *\n+   * @param i the object id\n+   */\n+  public void setPersistedObjectId(int i) {\n+    this.persistedObjectId = i;\n+    this.create = false;\n+  }\n+\n+  /**\n+   * Set the session for this statement.\n+   *\n+   * @param currentSession the new session\n+   */\n+  public void setSession(Session currentSession) {\n+    this.session = currentSession;\n+  }\n+\n+  /**\n+   * Print information about the statement executed if info trace level is\n+   * enabled.\n+   *\n+   * @param startTimeNanos when the statement was started\n+   * @param rowCount       the query or update row count\n+   */\n+  void trace(long startTimeNanos, int rowCount) {\n+    if (session.getTrace().isInfoEnabled() && startTimeNanos > 0) {\n+      long deltaTimeNanos = System.nanoTime() - startTimeNanos;\n+      String params = Trace.formatParams(parameters);\n+      session.getTrace().infoSQL(sqlStatement, params, rowCount,\n+          deltaTimeNanos / 1000 / 1000);\n+    }\n+    // startTime_nanos can be zero for the command that actually turns on\n+    // statistics\n+    if (session.getDatabase().getQueryStatistics() && startTimeNanos != 0) {\n+      long deltaTimeNanos = System.nanoTime() - startTimeNanos;\n+      session.getDatabase().getQueryStatisticsData().\n+          update(toString(), deltaTimeNanos, rowCount);\n+    }\n+  }\n+\n+  /**\n+   * Set the prepare always flag.\n+   * If set, the statement is re-compiled whenever it is executed.\n+   *\n+   * @param prepareAlways the new value\n+   */\n+  public void setPrepareAlways(boolean prepareAlways) {\n+    this.prepareAlways = prepareAlways;\n+  }\n+\n+  /**\n+   * Set the current row number.\n+   *\n+   * @param rowNumber the row number\n+   */\n+  public void setCurrentRowNumber(int rowNumber) {\n+    if ((++rowScanCount & 127) == 0) {\n+      checkCanceled();\n+    }\n+    this.currentRowNumber = rowNumber;\n+    setProgress();\n+  }\n+\n+  /**\n+   * Get the current row number.\n+   *\n+   * @return the row number\n+   */\n+  public int getCurrentRowNumber() {\n+    return currentRowNumber;\n+  }\n+\n+  /**\n+   * Notifies query progress via the DatabaseEventListener\n+   */\n+  private void setProgress() {\n+    if ((currentRowNumber & 127) == 0) {\n+      session.getDatabase().setProgress(\n+          DatabaseEventListener.STATE_STATEMENT_PROGRESS,\n+          sqlStatement, currentRowNumber, 0);\n+    }\n+  }\n+\n+  /**\n+   * Convert the statement to a String.\n+   *\n+   * @return the SQL statement\n+   */\n+  @Override\n+  public String toString() {\n+    return sqlStatement;\n+  }\n+\n+  /**\n+   * Get the SQL snippet of the value list.\n+   *\n+   * @param values the value list\n+   * @return the SQL snippet\n+   */\n+  protected static String getSQL(Value[] values) {\n+    StatementBuilder buff = new StatementBuilder();\n+    for (Value v : values) {\n+      buff.appendExceptFirst(\", \");\n+      if (v != null) {\n+        buff.append(v.getSQL());\n+      }\n+    }\n+    return buff.toString();\n+  }\n+\n+  /**\n+   * Get the SQL snippet of the expression list.\n+   *\n+   * @param list the expression list\n+   * @return the SQL snippet\n+   */\n+  protected static String getSQL(Expression[] list) {\n+    StatementBuilder buff = new StatementBuilder();\n+    for (Expression e : list) {\n+      buff.appendExceptFirst(\", \");\n+      if (e != null) {\n+        buff.append(e.getSQL());\n+      }\n+    }\n+    return buff.toString();\n+  }\n+\n+  /**\n+   * Set the SQL statement of the exception to the given row.\n+   *\n+   * @param e      the exception\n+   * @param rowId  the row number\n+   * @param values the values of the row\n+   * @return the exception\n+   */\n+  protected DbException setRow(DbException e, int rowId, String values) {\n+    StringBuilder buff = new StringBuilder();\n+    if (sqlStatement != null) {\n+      buff.append(sqlStatement);\n+    }\n+    buff.append(\" -- \");\n+    if (rowId > 0) {\n+      buff.append(\"row #\").append(rowId + 1).append(' ');\n+    }\n+    buff.append('(').append(values).append(')');\n+    return e.addSQL(buff.toString());\n+  }\n+\n+  public boolean isCacheable() {\n+    return false;\n+  }\n+\n+  /**\n+   * @return the temporary views created for CTE's.\n+   */\n+  public List<TableView> getCteCleanups() {\n+    return cteCleanups;\n+  }\n+\n+  /**\n+   * Set the temporary views created for CTE's.\n+   *\n+   * @param cteCleanups the temporary views\n+   */\n+  public void setCteCleanups(List<TableView> cteCleanups) {\n+    this.cteCleanups = cteCleanups;\n+  }\n+\n+  public Session getSession() {\n+    return session;\n+  }\n }\n",
            "diff_size": 449
        },
        {
            "tool": "naturalize",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/143/Prepared.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/naturalize/143/Prepared.java\nindex a5ac78c8f32..bcb47be58c2 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/143/Prepared.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/naturalize/143/Prepared.java\n@@ -273,7 +273,9 @@ public abstract class Prepared {\n         } else if (id < 0) {\n             throw DbException.throwInternalError(\"Prepared.getObjectId() was called before\");\n         }\n-        persistedObjectId = -persistedObjectId - 1;  // while negative, it can be restored later\n+        persistedObjectId = -persistedObjectId - 1;\n+\n+// while negative, it can be restored later\n         return id;\n     }\n \n@@ -472,4 +474,4 @@ public abstract class Prepared {\n     public Session getSession() {\n         return session;\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 4
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "324",
                    "column": "54",
                    "severity": "warning",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/143/Prepared.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/codebuff/143/Prepared.java\nindex a5ac78c8f32..2be225f1ee2 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/143/Prepared.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/codebuff/143/Prepared.java\n@@ -23,26 +23,36 @@ import org.h2.value.Value;\n /**\n  * A prepared statement.\n  */\n+\n+\n public abstract class Prepared {\n \n     /**\n      * The session.\n      */\n+\n+\n     protected Session session;\n \n     /**\n      * The SQL string.\n      */\n+\n+\n     protected String sqlStatement;\n \n     /**\n      * Whether to create a new object (for indexes).\n      */\n+\n+\n     protected boolean create = true;\n \n     /**\n      * The list of parameters.\n      */\n+\n+\n     protected ArrayList<Parameter> parameters;\n \n     /**\n@@ -50,8 +60,9 @@ public abstract class Prepared {\n      * queries with LIKE ?, because the query plan depends on the parameter\n      * value.\n      */\n-    protected boolean prepareAlways;\n \n+\n+    protected boolean prepareAlways;\n     private long modificationMetaId;\n     private Command command;\n     /**\n@@ -73,6 +84,7 @@ public abstract class Prepared {\n      *\n      * @param session the session\n      */\n+\n     public Prepared(Session session) {\n         this.session = session;\n         modificationMetaId = session.getDatabase().getModificationMetaId();\n@@ -84,6 +96,8 @@ public abstract class Prepared {\n      *\n      * @return true if it is\n      */\n+\n+\n     public abstract boolean isTransactional();\n \n     /**\n@@ -91,6 +105,8 @@ public abstract class Prepared {\n      *\n      * @return the result set\n      */\n+\n+\n     public abstract ResultInterface queryMeta();\n \n \n@@ -99,6 +115,8 @@ public abstract class Prepared {\n      *\n      * @return the statement type\n      */\n+\n+\n     public abstract int getType();\n \n     /**\n@@ -106,6 +124,8 @@ public abstract class Prepared {\n      *\n      * @return true if it is\n      */\n+\n+\n     public boolean isReadOnly() {\n         return false;\n     }\n@@ -115,6 +135,8 @@ public abstract class Prepared {\n      *\n      * @return true if it must\n      */\n+\n+\n     public boolean needRecompile() {\n         Database db = session.getDatabase();\n         if (db == null) {\n@@ -122,9 +144,7 @@ public abstract class Prepared {\n         }\n         // parser: currently, compiling every create/drop/... twice\n         // because needRecompile return true even for the first execution\n-        return prepareAlways ||\n-                modificationMetaId < db.getModificationMetaId() ||\n-                db.getSettings().recompileAlways;\n+        return prepareAlways || modificationMetaId < db.getModificationMetaId() || db.getSettings().recompileAlways;\n     }\n \n     /**\n@@ -133,6 +153,8 @@ public abstract class Prepared {\n      *\n      * @return the meta data modification id\n      */\n+\n+\n     long getModificationMetaId() {\n         return modificationMetaId;\n     }\n@@ -142,6 +164,8 @@ public abstract class Prepared {\n      *\n      * @param id the new id\n      */\n+\n+\n     void setModificationMetaId(long id) {\n         this.modificationMetaId = id;\n     }\n@@ -151,6 +175,8 @@ public abstract class Prepared {\n      *\n      * @param parameters the parameter list\n      */\n+\n+\n     public void setParameterList(ArrayList<Parameter> parameters) {\n         this.parameters = parameters;\n     }\n@@ -160,6 +186,8 @@ public abstract class Prepared {\n      *\n      * @return the parameter list\n      */\n+\n+\n     public ArrayList<Parameter> getParameters() {\n         return parameters;\n     }\n@@ -169,6 +197,8 @@ public abstract class Prepared {\n      *\n      * @throws DbException if any parameter has not been set\n      */\n+\n+\n     protected void checkParameters() {\n         if (persistedObjectId < 0) {\n             // restore original persistedObjectId on Command re-run\n@@ -187,6 +217,8 @@ public abstract class Prepared {\n      *\n      * @param command the new command\n      */\n+\n+\n     public void setCommand(Command command) {\n         this.command = command;\n     }\n@@ -196,6 +228,8 @@ public abstract class Prepared {\n      *\n      * @return true if it is\n      */\n+\n+\n     public boolean isQuery() {\n         return false;\n     }\n@@ -203,8 +237,11 @@ public abstract class Prepared {\n     /**\n      * Prepare this statement.\n      */\n+\n+\n     public void prepare() {\n         // nothing to do\n+\n     }\n \n     /**\n@@ -213,6 +250,8 @@ public abstract class Prepared {\n      * @return the update count\n      * @throws DbException if it is a query\n      */\n+\n+\n     public int update() {\n         throw DbException.get(ErrorCode.METHOD_NOT_ALLOWED_FOR_QUERY);\n     }\n@@ -224,6 +263,7 @@ public abstract class Prepared {\n      * @return the result set\n      * @throws DbException if it is not a query\n      */\n+\n     @SuppressWarnings(\"unused\")\n     public ResultInterface query(int maxrows) {\n         throw DbException.get(ErrorCode.METHOD_ONLY_ALLOWED_FOR_QUERY);\n@@ -234,6 +274,8 @@ public abstract class Prepared {\n      *\n      * @param sql the SQL statement\n      */\n+\n+\n     public void setSQL(String sql) {\n         this.sqlStatement = sql;\n     }\n@@ -243,6 +285,8 @@ public abstract class Prepared {\n      *\n      * @return the SQL statement\n      */\n+\n+\n     public String getSQL() {\n         return sqlStatement;\n     }\n@@ -254,6 +298,8 @@ public abstract class Prepared {\n      *\n      * @return the object id or 0 if not set\n      */\n+\n+\n     protected int getPersistedObjectId() {\n         int id = persistedObjectId;\n         return id >= 0 ? id : 0;\n@@ -266,6 +312,8 @@ public abstract class Prepared {\n      *\n      * @return the object id\n      */\n+\n+\n     protected int getObjectId() {\n         int id = persistedObjectId;\n         if (id == 0) {\n@@ -282,6 +330,8 @@ public abstract class Prepared {\n      *\n      * @return the execution plan\n      */\n+\n+\n     public String getPlanSQL() {\n         return null;\n     }\n@@ -291,6 +341,8 @@ public abstract class Prepared {\n      *\n      * @throws DbException if it was canceled\n      */\n+\n+\n     public void checkCanceled() {\n         session.checkCanceled();\n         Command c = command != null ? command : session.getCurrentCommand();\n@@ -304,6 +356,8 @@ public abstract class Prepared {\n      *\n      * @param i the object id\n      */\n+\n+\n     public void setPersistedObjectId(int i) {\n         this.persistedObjectId = i;\n         this.create = false;\n@@ -314,6 +368,8 @@ public abstract class Prepared {\n      *\n      * @param currentSession the new session\n      */\n+\n+\n     public void setSession(Session currentSession) {\n         this.session = currentSession;\n     }\n@@ -325,19 +381,19 @@ public abstract class Prepared {\n      * @param startTimeNanos when the statement was started\n      * @param rowCount the query or update row count\n      */\n+\n+\n     void trace(long startTimeNanos, int rowCount) {\n         if (session.getTrace().isInfoEnabled() && startTimeNanos > 0) {\n             long deltaTimeNanos = System.nanoTime() - startTimeNanos;\n             String params = Trace.formatParams(parameters);\n-            session.getTrace().infoSQL(sqlStatement, params, rowCount,\n-                    deltaTimeNanos / 1000 / 1000);\n+            session.getTrace().infoSQL(sqlStatement, params, rowCount, deltaTimeNanos / 1000 / 1000);\n         }\n         // startTime_nanos can be zero for the command that actually turns on\n         // statistics\n         if (session.getDatabase().getQueryStatistics() && startTimeNanos != 0) {\n             long deltaTimeNanos = System.nanoTime() - startTimeNanos;\n-            session.getDatabase().getQueryStatisticsData().\n-                    update(toString(), deltaTimeNanos, rowCount);\n+            session.getDatabase().getQueryStatisticsData().update(toString(), deltaTimeNanos, rowCount);\n         }\n     }\n \n@@ -347,6 +403,8 @@ public abstract class Prepared {\n      *\n      * @param prepareAlways the new value\n      */\n+\n+\n     public void setPrepareAlways(boolean prepareAlways) {\n         this.prepareAlways = prepareAlways;\n     }\n@@ -356,6 +414,8 @@ public abstract class Prepared {\n      *\n      * @param rowNumber the row number\n      */\n+\n+\n     public void setCurrentRowNumber(int rowNumber) {\n         if ((++rowScanCount & 127) == 0) {\n             checkCanceled();\n@@ -369,6 +429,8 @@ public abstract class Prepared {\n      *\n      * @return the row number\n      */\n+\n+\n     public int getCurrentRowNumber() {\n         return currentRowNumber;\n     }\n@@ -376,11 +438,10 @@ public abstract class Prepared {\n     /**\n      * Notifies query progress via the DatabaseEventListener\n      */\n+\n     private void setProgress() {\n         if ((currentRowNumber & 127) == 0) {\n-            session.getDatabase().setProgress(\n-                    DatabaseEventListener.STATE_STATEMENT_PROGRESS,\n-                    sqlStatement, currentRowNumber, 0);\n+            session.getDatabase().setProgress(DatabaseEventListener.STATE_STATEMENT_PROGRESS, sqlStatement, currentRowNumber, 0);\n         }\n     }\n \n@@ -389,6 +450,7 @@ public abstract class Prepared {\n      *\n      * @return the SQL statement\n      */\n+\n     @Override\n     public String toString() {\n         return sqlStatement;\n@@ -400,6 +462,8 @@ public abstract class Prepared {\n      * @param values the value list\n      * @return the SQL snippet\n      */\n+\n+\n     protected static String getSQL(Value[] values) {\n         StatementBuilder buff = new StatementBuilder();\n         for (Value v : values) {\n@@ -417,6 +481,8 @@ public abstract class Prepared {\n      * @param list the expression list\n      * @return the SQL snippet\n      */\n+\n+\n     protected static String getSQL(Expression[] list) {\n         StatementBuilder buff = new StatementBuilder();\n         for (Expression e : list) {\n@@ -436,6 +502,8 @@ public abstract class Prepared {\n      * @param values the values of the row\n      * @return the exception\n      */\n+\n+\n     protected DbException setRow(DbException e, int rowId, String values) {\n         StringBuilder buff = new StringBuilder();\n         if (sqlStatement != null) {\n@@ -449,6 +517,7 @@ public abstract class Prepared {\n         return e.addSQL(buff.toString());\n     }\n \n+\n     public boolean isCacheable() {\n         return false;\n     }\n@@ -456,6 +525,8 @@ public abstract class Prepared {\n     /**\n      * @return the temporary views created for CTE's.\n      */\n+\n+\n     public List<TableView> getCteCleanups() {\n         return cteCleanups;\n     }\n@@ -465,11 +536,15 @@ public abstract class Prepared {\n      *\n      * @param cteCleanups the temporary views\n      */\n+\n+\n     public void setCteCleanups(List<TableView> cteCleanups) {\n         this.cteCleanups = cteCleanups;\n     }\n \n+\n     public Session getSession() {\n         return session;\n     }\n-}\n+\n+}\n\\ No newline at end of file\n",
            "diff_size": 94
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/143/Prepared.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_random/143/Prepared.java\nindex a5ac78c8f32..7a43210497a 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/143/Prepared.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_random/143/Prepared.java\n@@ -273,8 +273,9 @@ public abstract class Prepared {\n         } else if (id < 0) {\n             throw DbException.throwInternalError(\"Prepared.getObjectId() was called before\");\n         }\n-        persistedObjectId = -persistedObjectId - 1;  // while negative, it can be restored later\n-        return id;\n+        persistedObjectId = -persistedObjectId - 1;\n+        // while negative, it can be restored later\n+          return id;\n     }\n \n     /**\n",
            "diff_size": 3
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/143/Prepared.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/143/Prepared.java\nindex a5ac78c8f32..7a43210497a 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/143/Prepared.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/143/Prepared.java\n@@ -273,8 +273,9 @@ public abstract class Prepared {\n         } else if (id < 0) {\n             throw DbException.throwInternalError(\"Prepared.getObjectId() was called before\");\n         }\n-        persistedObjectId = -persistedObjectId - 1;  // while negative, it can be restored later\n-        return id;\n+        persistedObjectId = -persistedObjectId - 1;\n+        // while negative, it can be restored later\n+          return id;\n     }\n \n     /**\n",
            "diff_size": 3
        }
    ],
    "repaired_by": [
        "styler",
        "naturalize",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "intellij",
        "codebuff"
    ]
}