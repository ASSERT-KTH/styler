{
    "project_name": "NationalSecurityAgency-datawave",
    "error_id": "124",
    "information": {
        "errors": [
            {
                "line": "14",
                "severity": "error",
                "message": "Accumulo non-public classes imported",
                "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
            }
        ]
    },
    "source_code": "import datawave.webservice.query.runner.Trace;\nimport datawave.webservice.query.util.QueryUncaughtExceptionHandler;\nimport org.apache.accumulo.core.trace.thrift.TInfo;\nimport org.apache.deltaspike.core.api.exclude.Exclude;\nimport org.apache.log4j.Logger;\n",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "14",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "14",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/124/QueryExpirationBean.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/intellij/124/QueryExpirationBean.java\nindex 7396189a3a9..eb5381985c9 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/124/QueryExpirationBean.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/intellij/124/QueryExpirationBean.java\n@@ -39,176 +39,182 @@ import java.util.Date;\n // by default all methods are blocking\n @Exclude(ifProjectStage = DatawaveEmbeddedProjectStageHolder.DatawaveEmbedded.class)\n public class QueryExpirationBean {\n-    \n-    private static final Logger log = Logger.getLogger(QueryExpirationBean.class);\n-    \n-    @Inject\n-    private QueryCache cache;\n-    \n-    @Inject\n-    @SpringBean(refreshable = true)\n-    private QueryExpirationConfiguration conf;\n-    \n-    @Inject\n-    private AccumuloConnectionFactory connectionFactory;\n-    \n-    @Inject\n-    private CreatedQueryLogicCacheBean qlCache;\n-    \n-    @Inject\n-    private QueryMetricsBean metrics;\n-    \n-    private boolean clearAll = false;\n-    \n-    @PostConstruct\n-    public void init() {\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"@PostConstruct - init()\");\n-        }\n-        \n-        if (conf == null) {\n-            throw new IllegalArgumentException(\"QueryExpirationConfiguration is null\");\n-        }\n+\n+  private static final Logger log = Logger.getLogger(QueryExpirationBean.class);\n+\n+  @Inject\n+  private QueryCache cache;\n+\n+  @Inject\n+  @SpringBean(refreshable = true)\n+  private QueryExpirationConfiguration conf;\n+\n+  @Inject\n+  private AccumuloConnectionFactory connectionFactory;\n+\n+  @Inject\n+  private CreatedQueryLogicCacheBean qlCache;\n+\n+  @Inject\n+  private QueryMetricsBean metrics;\n+\n+  private boolean clearAll = false;\n+\n+  @PostConstruct\n+  public void init() {\n+    if (log.isDebugEnabled()) {\n+      log.debug(\"@PostConstruct - init()\");\n     }\n-    \n-    @PreDestroy\n-    public void close() {\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"@PreDestroy - Closing all active queries and query logics before shutdown.\");\n-            log.debug(\"Overriding idle and call time thresholds to zero so that all queries and logics resources are cleared before shutdown.\");\n-        }\n-        \n-        clearAll = true;\n-        clearQueries(System.currentTimeMillis());\n+\n+    if (conf == null) {\n+      throw new IllegalArgumentException(\"QueryExpirationConfiguration is null\");\n     }\n-    \n-    /**\n-     * The cache eviction notifications are not working. Using an interceptor is not working either. This method will be invoked every 30 seconds by the timer\n-     * service and will evict entries that are idle or expired.\n-     */\n-    @Schedule(hour = \"*\", minute = \"*\", second = \"*/30\", persistent = false)\n-    public void removeIdleOrExpired() {\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"@Schedule - removeIdleOrExpired\");\n-        }\n-        long now = System.currentTimeMillis();\n-        clearQueries(now);\n-        qlCache.clearQueryLogics(now, conf.getCallTimeInMS());\n+  }\n+\n+  @PreDestroy\n+  public void close() {\n+    if (log.isDebugEnabled()) {\n+      log.debug(\"@PreDestroy - Closing all active queries and query logics before shutdown.\");\n+      log.debug(\n+          \"Overriding idle and call time thresholds to zero so that all queries and logics resources are cleared before shutdown.\");\n     }\n-    \n-    private void clearQueries(long now) {\n-        int count = 0;\n-        \n-        for (RunningQuery query : cache) {\n-            boolean idleTooLong = !clearAll && !query.hasActiveCall() && isIdleTooLong(query, now);\n-            boolean nextTooLong = !clearAll && query.hasActiveCall() && isNextTooLong(query, now);\n-            if (clearAll || idleTooLong || nextTooLong) {\n-                if (query.getSettings().getUncaughtExceptionHandler() == null) {\n-                    query.getSettings().setUncaughtExceptionHandler(new QueryUncaughtExceptionHandler());\n-                }\n-                try {\n-                    if (clearAll) {\n-                        query.getMetric().setLifecycle(QueryMetric.Lifecycle.SHUTDOWN);\n-                        query.getSettings().getUncaughtExceptionHandler()\n-                                        .uncaughtException(Thread.currentThread(), new QueryException(DatawaveErrorCode.SERVER_SHUTDOWN));\n-                    } else {\n-                        if (!query.getMetric().isLifecycleFinal() && !query.isFinished() && idleTooLong) {\n-                            query.getMetric().setLifecycle(QueryMetric.Lifecycle.TIMEOUT);\n-                        }\n-                        if (!query.getMetric().isLifecycleFinal() && !query.isFinished() && nextTooLong) {\n-                            query.getMetric().setLifecycle(QueryMetric.Lifecycle.NEXTTIMEOUT);\n-                        }\n-                        \n-                        query.getSettings().getUncaughtExceptionHandler()\n-                                        .uncaughtException(Thread.currentThread(), new QueryException(DatawaveErrorCode.QUERY_TIMEOUT));\n-                    }\n-                } finally {\n-                    if (query.getLogic().getCollectQueryMetrics()) {\n-                        try {\n-                            metrics.updateMetric(query.getMetric());\n-                        } catch (Exception e) {\n-                            log.error(e.getMessage(), e);\n-                        }\n-                    }\n-                }\n-                \n-                if (query.hasActiveCall()) {\n-                    query.cancel();\n-                }\n-                try {\n-                    query.closeConnection(connectionFactory);\n-                } catch (Exception e) {\n-                    log.error(\"Error returning connection to factory\", e);\n-                }\n-                cache.remove(query.getSettings().getId().toString());\n-                count++;\n-                if (log.isDebugEnabled()) {\n-                    log.debug(\"Entry evicted, connection returned.\");\n-                }\n-                \n-                TInfo traceInfo = query.getTraceInfo();\n-                if (traceInfo != null) {\n-                    Span span = Trace.trace(traceInfo, \"query:expiration\");\n-                    span.data(\"expiredAt\", new Date().toString());\n-                    // Spans aren't recorded if they take no time, so sleep for a\n-                    // couple milliseconds just to ensure we get something saved.\n-                    try {\n-                        Thread.sleep(2);\n-                    } catch (InterruptedException e) {\n-                        // ignore\n-                    }\n-                    span.stop();\n-                }\n+\n+    clearAll = true;\n+    clearQueries(System.currentTimeMillis());\n+  }\n+\n+  /**\n+   * The cache eviction notifications are not working. Using an interceptor is not working either. This method will be invoked every 30 seconds by the timer\n+   * service and will evict entries that are idle or expired.\n+   */\n+  @Schedule(hour = \"*\", minute = \"*\", second = \"*/30\", persistent = false)\n+  public void removeIdleOrExpired() {\n+    if (log.isDebugEnabled()) {\n+      log.debug(\"@Schedule - removeIdleOrExpired\");\n+    }\n+    long now = System.currentTimeMillis();\n+    clearQueries(now);\n+    qlCache.clearQueryLogics(now, conf.getCallTimeInMS());\n+  }\n+\n+  private void clearQueries(long now) {\n+    int count = 0;\n+\n+    for (RunningQuery query : cache) {\n+      boolean idleTooLong = !clearAll && !query.hasActiveCall() && isIdleTooLong(query, now);\n+      boolean nextTooLong = !clearAll && query.hasActiveCall() && isNextTooLong(query, now);\n+      if (clearAll || idleTooLong || nextTooLong) {\n+        if (query.getSettings().getUncaughtExceptionHandler() == null) {\n+          query.getSettings().setUncaughtExceptionHandler(new QueryUncaughtExceptionHandler());\n+        }\n+        try {\n+          if (clearAll) {\n+            query.getMetric().setLifecycle(QueryMetric.Lifecycle.SHUTDOWN);\n+            query.getSettings().getUncaughtExceptionHandler()\n+                .uncaughtException(Thread.currentThread(), new QueryException(DatawaveErrorCode.SERVER_SHUTDOWN));\n+          } else {\n+            if (!query.getMetric().isLifecycleFinal() && !query.isFinished() && idleTooLong) {\n+              query.getMetric().setLifecycle(QueryMetric.Lifecycle.TIMEOUT);\n+            }\n+            if (!query.getMetric().isLifecycleFinal() && !query.isFinished() && nextTooLong) {\n+              query.getMetric().setLifecycle(QueryMetric.Lifecycle.NEXTTIMEOUT);\n             }\n+\n+            query.getSettings().getUncaughtExceptionHandler()\n+                .uncaughtException(Thread.currentThread(), new QueryException(DatawaveErrorCode.QUERY_TIMEOUT));\n+          }\n+        } finally {\n+          if (query.getLogic().getCollectQueryMetrics()) {\n+            try {\n+              metrics.updateMetric(query.getMetric());\n+            } catch (Exception e) {\n+              log.error(e.getMessage(), e);\n+            }\n+          }\n         }\n-        if (count > 0 && log.isDebugEnabled()) {\n-            log.debug(count + \" entries evicted from query cache.\");\n+\n+        if (query.hasActiveCall()) {\n+          query.cancel();\n         }\n-    }\n-    \n-    /**\n-     * Method to determine if a query has been idle too long based on configured values.\n-     *\n-     * @param query\n-     * @param currentTime\n-     * @return true if query has been idle too long, false otherwise\n-     */\n-    private boolean isIdleTooLong(RunningQuery query, long currentTime) {\n-        long difference = currentTime - query.getLastUsed();\n-        if (log.isDebugEnabled()) {\n-            long countDown = (conf.getIdleTimeInMS() / 1000) - (difference / 1000);\n-            log.debug(\"Query: \" + query.getSettings().getOwner() + \" - \" + query.getSettings().getId() + \" will be evicted in: \" + countDown + \" seconds.\");\n+        try {\n+          query.closeConnection(connectionFactory);\n+        } catch (Exception e) {\n+          log.error(\"Error returning connection to factory\", e);\n         }\n-        \n-        return difference > conf.getIdleTimeInMS();\n-    }\n-    \n-    /**\n-     * Method to determine if a query next call has been running too long based on configured values.\n-     *\n-     * @param query\n-     * @param currentTime\n-     * @return true if query next has been running too long, false otherwise\n-     */\n-    private boolean isNextTooLong(RunningQuery query, long currentTime) {\n-        if (query.getTimeOfCurrentCall() == 0) {\n-            log.warn(\"Query has active call set but a call time of 0ms.\");\n-            return false;\n+        cache.remove(query.getSettings().getId().toString());\n+        count++;\n+        if (log.isDebugEnabled()) {\n+          log.debug(\"Entry evicted, connection returned.\");\n         }\n-        \n-        query.touch(); // Since we know we're still in a call, go ahead and reset the idle time.\n-        long difference = currentTime - query.getTimeOfCurrentCall();\n-        \n-        if (difference > conf.getCallTimeInMS()) {\n-            log.warn(\"Query \" + query.getSettings().getOwner() + \" - \" + query.getSettings().getId() + \" has been in a call for \" + (difference / 1000)\n-                            + \"s.  We are evicting this query from the cache.\");\n-            return true;\n-        } else {\n-            if (log.isDebugEnabled()) {\n-                log.debug(\"Query \" + query.getSettings().getOwner() + \" - \" + query.getSettings().getId() + \" has been in a call for \" + (difference / 1000)\n-                                + \"s.\");\n-            }\n-            return false;\n+\n+        TInfo traceInfo = query.getTraceInfo();\n+        if (traceInfo != null) {\n+          Span span = Trace.trace(traceInfo, \"query:expiration\");\n+          span.data(\"expiredAt\", new Date().toString());\n+          // Spans aren't recorded if they take no time, so sleep for a\n+          // couple milliseconds just to ensure we get something saved.\n+          try {\n+            Thread.sleep(2);\n+          } catch (InterruptedException e) {\n+            // ignore\n+          }\n+          span.stop();\n         }\n+      }\n+    }\n+    if (count > 0 && log.isDebugEnabled()) {\n+      log.debug(count + \" entries evicted from query cache.\");\n+    }\n+  }\n+\n+  /**\n+   * Method to determine if a query has been idle too long based on configured values.\n+   *\n+   * @param query\n+   * @param currentTime\n+   * @return true if query has been idle too long, false otherwise\n+   */\n+  private boolean isIdleTooLong(RunningQuery query, long currentTime) {\n+    long difference = currentTime - query.getLastUsed();\n+    if (log.isDebugEnabled()) {\n+      long countDown = (conf.getIdleTimeInMS() / 1000) - (difference / 1000);\n+      log.debug(\n+          \"Query: \" + query.getSettings().getOwner() + \" - \" + query.getSettings().getId() + \" will be evicted in: \" +\n+              countDown + \" seconds.\");\n+    }\n+\n+    return difference > conf.getIdleTimeInMS();\n+  }\n+\n+  /**\n+   * Method to determine if a query next call has been running too long based on configured values.\n+   *\n+   * @param query\n+   * @param currentTime\n+   * @return true if query next has been running too long, false otherwise\n+   */\n+  private boolean isNextTooLong(RunningQuery query, long currentTime) {\n+    if (query.getTimeOfCurrentCall() == 0) {\n+      log.warn(\"Query has active call set but a call time of 0ms.\");\n+      return false;\n+    }\n+\n+    query.touch(); // Since we know we're still in a call, go ahead and reset the idle time.\n+    long difference = currentTime - query.getTimeOfCurrentCall();\n+\n+    if (difference > conf.getCallTimeInMS()) {\n+      log.warn(\n+          \"Query \" + query.getSettings().getOwner() + \" - \" + query.getSettings().getId() + \" has been in a call for \" +\n+              (difference / 1000)\n+              + \"s.  We are evicting this query from the cache.\");\n+      return true;\n+    } else {\n+      if (log.isDebugEnabled()) {\n+        log.debug(\"Query \" + query.getSettings().getOwner() + \" - \" + query.getSettings().getId() +\n+            \" has been in a call for \" + (difference / 1000)\n+            + \"s.\");\n+      }\n+      return false;\n     }\n+  }\n }\n",
            "diff_size": 231
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "14",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "14",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ],
    "repaired_by": [],
    "not_repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}