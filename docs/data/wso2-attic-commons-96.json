{
    "project_name": "wso2-attic-commons",
    "error_id": "96",
    "information": {
        "errors": [
            {
                "line": "2",
                "severity": "error",
                "message": "Line is longer than 120 characters (found 153).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": "/*\n * $HeadURL: http://svn.apache.org/repos/asf/httpcomponents/httpcore/trunk/contrib/src/main/java/org/apache/http/contrib/benchmark/BenchmarkWorker.java $\n * $Revision: 693049 $\n * $Date: 2008-09-08 03:50:31 -0700 (Mon, 08 Sep 2008) $\n *",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "2",
                    "severity": "error",
                    "message": "Line is longer than 120 characters (found 153).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "2",
                    "severity": "error",
                    "message": "Line is longer than 120 characters (found 153).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/96/BenchmarkWorker.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/intellij/96/BenchmarkWorker.java\nindex 05df2ce1910..abca567d1ab 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/96/BenchmarkWorker.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/intellij/96/BenchmarkWorker.java\n@@ -28,6 +28,7 @@\n  * <http://www.apache.org/>.\n  *\n  */\n+\n package org.apache.http.contrib.benchmark;\n \n import java.io.IOException;\n@@ -68,207 +69,206 @@ import org.apache.http.util.EntityUtils;\n  * Worker thread for the {@link HttpBenchmark HttpBenchmark}.\n  *\n  * @author <a href=\"mailto:oleg at ural.ru\">Oleg Kalnichevski</a>\n- *\n+ * <p>\n  * <!-- empty lines above to avoid 'svn diff' context problems -->\n  * @version $Revision: 693049 $\n- * \n  * @since 4.0\n  */\n public class BenchmarkWorker implements Runnable {\n \n-    private byte[] buffer = new byte[4096];\n-    private final int verbosity;\n-    private final HttpParams params;\n-    private final HttpContext context;\n-    private final BasicHttpProcessor httpProcessor;\n-    private final HttpRequestExecutor httpexecutor;\n-    private final ConnectionReuseStrategy connstrategy;\n-    private final HttpRequest request;\n-    private final HttpHost targetHost;\n-    private final int count;\n-    private final boolean keepalive;\n-    private final Stats stats = new Stats();\n-\n-    public BenchmarkWorker(\n-            final HttpParams params,\n-            int verbosity,\n-            final HttpRequest request,\n-            final HttpHost targetHost,\n-            int count,\n-            boolean keepalive) {\n-\n-        super();\n-        this.params = params;\n-        this.context = new BasicHttpContext(null);\n-        this.request = request;\n-        this.targetHost = targetHost;\n-        this.count = count;\n-        this.keepalive = keepalive;\n-\n-        this.httpProcessor = new BasicHttpProcessor();\n-        this.httpexecutor = new HttpRequestExecutor();\n-\n-        // Required request interceptors\n-        this.httpProcessor.addInterceptor(new RequestContent());\n-        this.httpProcessor.addInterceptor(new RequestTargetHost());\n-        // Recommended request interceptors\n-        this.httpProcessor.addInterceptor(new RequestConnControl());\n-        this.httpProcessor.addInterceptor(new RequestUserAgent());\n-        this.httpProcessor.addInterceptor(new RequestExpectContinue());\n-\n-        this.connstrategy = new DefaultConnectionReuseStrategy();\n-        this.verbosity = verbosity;\n-    }\n+  private byte[] buffer = new byte[4096];\n+  private final int verbosity;\n+  private final HttpParams params;\n+  private final HttpContext context;\n+  private final BasicHttpProcessor httpProcessor;\n+  private final HttpRequestExecutor httpexecutor;\n+  private final ConnectionReuseStrategy connstrategy;\n+  private final HttpRequest request;\n+  private final HttpHost targetHost;\n+  private final int count;\n+  private final boolean keepalive;\n+  private final Stats stats = new Stats();\n \n-    public void run() {\n+  public BenchmarkWorker(\n+    final HttpParams params,\n+    int verbosity,\n+    final HttpRequest request,\n+    final HttpHost targetHost,\n+    int count,\n+    boolean keepalive) {\n \n-        HttpResponse response = null;\n-        DefaultHttpClientConnection conn = new DefaultHttpClientConnection();\n+    super();\n+    this.params = params;\n+    this.context = new BasicHttpContext(null);\n+    this.request = request;\n+    this.targetHost = targetHost;\n+    this.count = count;\n+    this.keepalive = keepalive;\n \n-        String hostname = targetHost.getHostName();\n-        int port = targetHost.getPort();\n-        if (port == -1) {\n-            port = 80;\n-        }\n+    this.httpProcessor = new BasicHttpProcessor();\n+    this.httpexecutor = new HttpRequestExecutor();\n \n-        // Populate the execution context\n-        this.context.setAttribute(ExecutionContext.HTTP_CONNECTION, conn);\n-        this.context.setAttribute(ExecutionContext.HTTP_TARGET_HOST, this.targetHost);\n-        this.context.setAttribute(ExecutionContext.HTTP_REQUEST, this.request);\n+    // Required request interceptors\n+    this.httpProcessor.addInterceptor(new RequestContent());\n+    this.httpProcessor.addInterceptor(new RequestTargetHost());\n+    // Recommended request interceptors\n+    this.httpProcessor.addInterceptor(new RequestConnControl());\n+    this.httpProcessor.addInterceptor(new RequestUserAgent());\n+    this.httpProcessor.addInterceptor(new RequestExpectContinue());\n \n-        stats.start();\n-        request.setParams(new DefaultedHttpParams(new BasicHttpParams(), this.params));\n-        for (int i = 0; i < count; i++) {\n+    this.connstrategy = new DefaultConnectionReuseStrategy();\n+    this.verbosity = verbosity;\n+  }\n \n-            try {\n-                resetHeader(request);\n-                if (!conn.isOpen()) {\n-                    Socket socket = null;\n-                    if (\"https\".equals(targetHost.getSchemeName())) {\n-                        SocketFactory socketFactory = SSLSocketFactory.getDefault();\n-                        socket = socketFactory.createSocket(hostname, port);\n-                    } else {\n-                        socket = new Socket(hostname, port);\n-                    }\n-                    conn.bind(socket, params);\n-                }\n+  public void run() {\n \n-                try {\n-                    // Prepare request\n-                    this.httpexecutor.preProcess(this.request, this.httpProcessor, this.context);\n-                    // Execute request and get a response\n-                    response = this.httpexecutor.execute(this.request, conn, this.context);\n-                    // Finalize response\n-                    this.httpexecutor.postProcess(response, this.httpProcessor, this.context);\n+    HttpResponse response = null;\n+    DefaultHttpClientConnection conn = new DefaultHttpClientConnection();\n \n-                } catch (HttpException e) {\n-                    stats.incWriteErrors();\n-                    if (this.verbosity >= 2) {\n-                        System.err.println(\"Failed HTTP request : \" + e.getMessage());\n-                    }\n-                    continue;\n-                }\n+    String hostname = targetHost.getHostName();\n+    int port = targetHost.getPort();\n+    if (port == -1) {\n+      port = 80;\n+    }\n \n-                verboseOutput(response);\n+    // Populate the execution context\n+    this.context.setAttribute(ExecutionContext.HTTP_CONNECTION, conn);\n+    this.context.setAttribute(ExecutionContext.HTTP_TARGET_HOST, this.targetHost);\n+    this.context.setAttribute(ExecutionContext.HTTP_REQUEST, this.request);\n \n-                if (response.getStatusLine().getStatusCode() == HttpStatus.SC_OK) {\n-                    stats.incSuccessCount();\n-                } else {\n-                    stats.incFailureCount();\n-                    continue;\n-                }\n+    stats.start();\n+    request.setParams(new DefaultedHttpParams(new BasicHttpParams(), this.params));\n+    for (int i = 0; i < count; i++) {\n \n-                HttpEntity entity = response.getEntity();\n-                String charset = EntityUtils.getContentCharSet(entity);\n-                if (charset == null) {\n-                    charset = HTTP.DEFAULT_CONTENT_CHARSET;\n-                }\n-                long contentlen = 0;\n-                if (entity != null) {\n-                    InputStream instream = entity.getContent();\n-                    int l = 0;\n-                    while ((l = instream.read(this.buffer)) != -1) {\n-                        stats.incTotalBytesRecv(l);\n-                        contentlen += l;\n-                        if (this.verbosity >= 4) {\n-                            String s = new String(this.buffer, 0, l, charset);\n-                            System.out.print(s);\n-                        }\n-                    }\n-                    instream.close();\n-                }\n+      try {\n+        resetHeader(request);\n+        if (!conn.isOpen()) {\n+          Socket socket = null;\n+          if (\"https\".equals(targetHost.getSchemeName())) {\n+            SocketFactory socketFactory = SSLSocketFactory.getDefault();\n+            socket = socketFactory.createSocket(hostname, port);\n+          } else {\n+            socket = new Socket(hostname, port);\n+          }\n+          conn.bind(socket, params);\n+        }\n \n-                if (this.verbosity >= 4) {\n-                    System.out.println();\n-                    System.out.println();\n-                }\n+        try {\n+          // Prepare request\n+          this.httpexecutor.preProcess(this.request, this.httpProcessor, this.context);\n+          // Execute request and get a response\n+          response = this.httpexecutor.execute(this.request, conn, this.context);\n+          // Finalize response\n+          this.httpexecutor.postProcess(response, this.httpProcessor, this.context);\n \n-                if (!keepalive || !this.connstrategy.keepAlive(response, this.context)) {\n-                    conn.close();\n-                }\n-                stats.setContentLength(contentlen);\n+        } catch (HttpException e) {\n+          stats.incWriteErrors();\n+          if (this.verbosity >= 2) {\n+            System.err.println(\"Failed HTTP request : \" + e.getMessage());\n+          }\n+          continue;\n+        }\n \n-            } catch (IOException ex) {\n-                ex.printStackTrace();\n-                stats.incFailureCount();\n-                if (this.verbosity >= 2) {\n-                    System.err.println(\"I/O error: \" + ex.getMessage());\n-                }\n-            }\n+        verboseOutput(response);\n \n+        if (response.getStatusLine().getStatusCode() == HttpStatus.SC_OK) {\n+          stats.incSuccessCount();\n+        } else {\n+          stats.incFailureCount();\n+          continue;\n         }\n-        stats.finish();\n \n-        if (response != null) {\n-            Header header = response.getFirstHeader(\"Server\");\n-            if (header != null) {\n-                stats.setServerName(header.getValue());\n+        HttpEntity entity = response.getEntity();\n+        String charset = EntityUtils.getContentCharSet(entity);\n+        if (charset == null) {\n+          charset = HTTP.DEFAULT_CONTENT_CHARSET;\n+        }\n+        long contentlen = 0;\n+        if (entity != null) {\n+          InputStream instream = entity.getContent();\n+          int l = 0;\n+          while ((l = instream.read(this.buffer)) != -1) {\n+            stats.incTotalBytesRecv(l);\n+            contentlen += l;\n+            if (this.verbosity >= 4) {\n+              String s = new String(this.buffer, 0, l, charset);\n+              System.out.print(s);\n             }\n+          }\n+          instream.close();\n         }\n \n-        try {\n-            conn.close();\n-        } catch (IOException ex) {\n-            ex.printStackTrace();\n-            stats.incFailureCount();\n-            if (this.verbosity >= 2) {\n-                System.err.println(\"I/O error: \" + ex.getMessage());\n-            }\n+        if (this.verbosity >= 4) {\n+          System.out.println();\n+          System.out.println();\n         }\n-    }\n \n-    private void verboseOutput(HttpResponse response) {\n-        if (this.verbosity >= 3) {\n-            System.out.println(\">> \" + request.getRequestLine().toString());\n-            Header[] headers = request.getAllHeaders();\n-            for (int h = 0; h < headers.length; h++) {\n-                System.out.println(\">> \" + headers[h].toString());\n-            }\n-            System.out.println();\n+        if (!keepalive || !this.connstrategy.keepAlive(response, this.context)) {\n+          conn.close();\n         }\n+        stats.setContentLength(contentlen);\n+\n+      } catch (IOException ex) {\n+        ex.printStackTrace();\n+        stats.incFailureCount();\n         if (this.verbosity >= 2) {\n-            System.out.println(response.getStatusLine().getStatusCode());\n-        }\n-        if (this.verbosity >= 3) {\n-            System.out.println(\"<< \" + response.getStatusLine().toString());\n-            Header[] headers = response.getAllHeaders();\n-            for (int h = 0; h < headers.length; h++) {\n-                System.out.println(\"<< \" + headers[h].toString());\n-            }\n-            System.out.println();\n+          System.err.println(\"I/O error: \" + ex.getMessage());\n         }\n+      }\n+\n     }\n+    stats.finish();\n \n-    private static void resetHeader(final HttpRequest request) {\n-        for (HeaderIterator it = request.headerIterator(); it.hasNext();) {\n-            Header header = it.nextHeader();\n-            if (!(header instanceof DefaultHeader)) {\n-                it.remove();\n-            }\n-        }\n+    if (response != null) {\n+      Header header = response.getFirstHeader(\"Server\");\n+      if (header != null) {\n+        stats.setServerName(header.getValue());\n+      }\n+    }\n+\n+    try {\n+      conn.close();\n+    } catch (IOException ex) {\n+      ex.printStackTrace();\n+      stats.incFailureCount();\n+      if (this.verbosity >= 2) {\n+        System.err.println(\"I/O error: \" + ex.getMessage());\n+      }\n+    }\n+  }\n+\n+  private void verboseOutput(HttpResponse response) {\n+    if (this.verbosity >= 3) {\n+      System.out.println(\">> \" + request.getRequestLine().toString());\n+      Header[] headers = request.getAllHeaders();\n+      for (int h = 0; h < headers.length; h++) {\n+        System.out.println(\">> \" + headers[h].toString());\n+      }\n+      System.out.println();\n+    }\n+    if (this.verbosity >= 2) {\n+      System.out.println(response.getStatusLine().getStatusCode());\n     }\n+    if (this.verbosity >= 3) {\n+      System.out.println(\"<< \" + response.getStatusLine().toString());\n+      Header[] headers = response.getAllHeaders();\n+      for (int h = 0; h < headers.length; h++) {\n+        System.out.println(\"<< \" + headers[h].toString());\n+      }\n+      System.out.println();\n+    }\n+  }\n \n-    public Stats getStats() {\n-        return stats;\n+  private static void resetHeader(final HttpRequest request) {\n+    for (HeaderIterator it = request.headerIterator(); it.hasNext(); ) {\n+      Header header = it.nextHeader();\n+      if (!(header instanceof DefaultHeader)) {\n+        it.remove();\n+      }\n     }\n+  }\n+\n+  public Stats getStats() {\n+    return stats;\n+  }\n }\n",
            "diff_size": 257
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "2",
                    "severity": "error",
                    "message": "Line is longer than 120 characters (found 153).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/96/BenchmarkWorker.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/naturalize/96/BenchmarkWorker.java\nindex 05df2ce1910..e55884b538d 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/96/BenchmarkWorker.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/naturalize/96/BenchmarkWorker.java\n@@ -96,8 +96,7 @@ public class BenchmarkWorker implements Runnable {\n             final HttpHost targetHost,\n             int count,\n             boolean keepalive) {\n-\n-        super();\n+    super();\n         this.params = params;\n         this.context = new BasicHttpContext(null);\n         this.request = request;\n@@ -271,4 +270,4 @@ public class BenchmarkWorker implements Runnable {\n     public Stats getStats() {\n         return stats;\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 3
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "2",
                    "severity": "error",
                    "message": "Line is longer than 120 characters (found 153).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "2",
                    "severity": "error",
                    "message": "Line is longer than 120 characters (found 153).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ],
    "repaired_by": [],
    "not_repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}