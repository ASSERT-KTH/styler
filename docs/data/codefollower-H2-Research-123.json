{
    "project_name": "codefollower-H2-Research",
    "error_id": "123",
    "information": {
        "errors": [
            {
                "line": "364",
                "column": "36",
                "severity": "warning",
                "message": "Don't use trailing comments.",
                "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
            }
        ]
    },
    "source_code": "                int mapId = (Integer) op[0];\n                MVMap<Object, VersionedValue> map = openMap(mapId);\n                if (map != null) { // might be null if map was removed later\n                    Object key = op[1];\n                    VersionedValue value = map.get(key);\n                    if (value != null) {",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/123/TransactionStore.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler/123/TransactionStore.java\nindex b4d9dc28736..e3329d51eae 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/123/TransactionStore.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler/123/TransactionStore.java\n@@ -361,8 +361,9 @@ public class TransactionStore {\n                 }\n                 int mapId = (Integer) op[0];\n                 MVMap<Object, VersionedValue> map = openMap(mapId);\n-                if (map != null) { // might be null if map was removed later\n-                    Object key = op[1];\n+                if (map != null) {\n+                    // might be null if map was removed later\n+                Object key = op[1];\n                     VersionedValue value = map.get(key);\n                     if (value != null) {\n                         // only commit (remove/update) value if we've reached\n",
            "diff_size": 3
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "366",
                    "column": "28",
                    "severity": "warning",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/123/TransactionStore.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/123/TransactionStore.java\nindex b4d9dc28736..002bf8f592f 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/123/TransactionStore.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/123/TransactionStore.java\n@@ -3,6 +3,7 @@\n  * and the EPL 1.0 (http://h2database.com/html/license.html).\n  * Initial Developer: H2 Group\n  */\n+\n package org.h2.mvstore.db;\n \n import java.nio.ByteBuffer;\n@@ -13,6 +14,7 @@ import java.util.Iterator;\n import java.util.List;\n import java.util.Map.Entry;\n import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n import org.h2.mvstore.Cursor;\n import org.h2.mvstore.DataUtils;\n import org.h2.mvstore.MVMap;\n@@ -27,1796 +29,1795 @@ import org.h2.util.New;\n  */\n public class TransactionStore {\n \n+  /**\n+   * The store.\n+   */\n+  final MVStore store;\n+\n+  /**\n+   * The persisted map of prepared transactions.\n+   * Key: transactionId, value: [ status, name ].\n+   */\n+  final MVMap<Integer, Object[]> preparedTransactions;\n+\n+  /**\n+   * The undo log.\n+   * <p>\n+   * If the first entry for a transaction doesn't have a logId\n+   * of 0, then the transaction is partially committed (which means rollback\n+   * is not possible). Log entries are written before the data is changed\n+   * (write-ahead).\n+   * <p>\n+   * Key: opId, value: [ mapId, key, oldValue ].\n+   */\n+  final MVMap<Long, Object[]> undoLog;\n+\n+  /**\n+   * the reader/writer lock for the undo-log. Allows us to process multiple\n+   * selects in parallel.\n+   */\n+  final ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();\n+\n+  /**\n+   * The map of maps.\n+   */\n+  private HashMap<Integer, MVMap<Object, VersionedValue>> maps =\n+      New.hashMap();\n+\n+  private final DataType dataType;\n+\n+  private final BitSet openTransactions = new BitSet();\n+\n+  private boolean init;\n+\n+  private int maxTransactionId = 0xffff;\n+\n+  /**\n+   * The next id of a temporary map.\n+   */\n+  private int nextTempMapId;\n+\n+  /**\n+   * Create a new transaction store.\n+   *\n+   * @param store the store\n+   */\n+  public TransactionStore(MVStore store) {\n+    this(store, new ObjectDataType());\n+  }\n+\n+  /**\n+   * Create a new transaction store.\n+   *\n+   * @param store    the store\n+   * @param dataType the data type for map keys and values\n+   */\n+  public TransactionStore(MVStore store, DataType dataType) {\n+    this.store = store;\n+    this.dataType = dataType;\n+    preparedTransactions = store.openMap(\"openTransactions\",\n+        new MVMap.Builder<Integer, Object[]>());\n+    VersionedValueType oldValueType = new VersionedValueType(dataType);\n+    ArrayType undoLogValueType = new ArrayType(new DataType[] {\n+        new ObjectDataType(), dataType, oldValueType\n+    });\n+    MVMap.Builder<Long, Object[]> builder =\n+        new MVMap.Builder<Long, Object[]>().\n+            valueType(undoLogValueType);\n+    undoLog = store.openMap(\"undoLog\", builder);\n+    if (undoLog.getValueType() != undoLogValueType) {\n+      throw DataUtils.newIllegalStateException(\n+          DataUtils.ERROR_TRANSACTION_CORRUPT,\n+          \"Undo map open with a different value type\");\n+    }\n+  }\n+\n+  /**\n+   * Initialize the store. This is needed before a transaction can be opened.\n+   * If the transaction store is corrupt, this method can throw an exception,\n+   * in which case the store can only be used for reading.\n+   */\n+  public synchronized void init() {\n+    init = true;\n+    // remove all temporary maps\n+    for (String mapName : store.getMapNames()) {\n+      if (mapName.startsWith(\"temp.\")) {\n+        MVMap<Object, Integer> temp = openTempMap(mapName);\n+        store.removeMap(temp);\n+      }\n+    }\n+    rwLock.writeLock().lock();\n+    try {\n+      if (undoLog.size() > 0) {\n+        for (Long key : undoLog.keySet()) {\n+          int transactionId = getTransactionId(key);\n+          openTransactions.set(transactionId);\n+        }\n+      }\n+    } finally {\n+      rwLock.writeLock().unlock();\n+    }\n+  }\n+\n+  /**\n+   * Set the maximum transaction id, after which ids are re-used. If the old\n+   * transaction is still in use when re-using an old id, the new transaction\n+   * fails.\n+   *\n+   * @param max the maximum id\n+   */\n+  public void setMaxTransactionId(int max) {\n+    this.maxTransactionId = max;\n+  }\n+\n+  /**\n+   * Combine the transaction id and the log id to an operation id.\n+   *\n+   * @param transactionId the transaction id\n+   * @param logId         the log id\n+   * @return the operation id\n+   */\n+  static long getOperationId(int transactionId, long logId) {\n+    DataUtils.checkArgument(transactionId >= 0 && transactionId < (1 << 24),\n+        \"Transaction id out of range: {0}\", transactionId);\n+    DataUtils.checkArgument(logId >= 0 && logId < (1L << 40),\n+        \"Transaction log id out of range: {0}\", logId);\n+    return ((long) transactionId << 40) | logId;\n+  }\n+\n+  /**\n+   * Get the transaction id for the given operation id.\n+   *\n+   * @param operationId the operation id\n+   * @return the transaction id\n+   */\n+  static int getTransactionId(long operationId) {\n+    return (int) (operationId >>> 40);\n+  }\n+\n+  /**\n+   * Get the log id for the given operation id.\n+   *\n+   * @param operationId the operation id\n+   * @return the log id\n+   */\n+  static long getLogId(long operationId) {\n+    return operationId & ((1L << 40) - 1);\n+  }\n+\n+  /**\n+   * Get the list of unclosed transactions that have pending writes.\n+   *\n+   * @return the list of transactions (sorted by id)\n+   */\n+  public List<Transaction> getOpenTransactions() {\n+    rwLock.readLock().lock();\n+    try {\n+      ArrayList<Transaction> list = New.arrayList();\n+      Long key = undoLog.firstKey();\n+      while (key != null) {\n+        int transactionId = getTransactionId(key);\n+        key = undoLog.lowerKey(getOperationId(transactionId + 1, 0));\n+        long logId = getLogId(key) + 1;\n+        Object[] data = preparedTransactions.get(transactionId);\n+        int status;\n+        String name;\n+        if (data == null) {\n+          if (undoLog.containsKey(getOperationId(transactionId, 0))) {\n+            status = Transaction.STATUS_OPEN;\n+          } else {\n+            status = Transaction.STATUS_COMMITTING;\n+          }\n+          name = null;\n+        } else {\n+          status = (Integer) data[0];\n+          name = (String) data[1];\n+        }\n+        Transaction t = new Transaction(this, transactionId, status,\n+            name, logId);\n+        list.add(t);\n+        key = undoLog.ceilingKey(getOperationId(transactionId + 1, 0));\n+      }\n+      return list;\n+    } finally {\n+      rwLock.readLock().unlock();\n+    }\n+  }\n+\n+  /**\n+   * Close the transaction store.\n+   */\n+  public synchronized void close() {\n+    store.commit();\n+  }\n+\n+  /**\n+   * Begin a new transaction.\n+   *\n+   * @return the transaction\n+   */\n+  public synchronized Transaction begin() {\n+\n+    int transactionId;\n+    int status;\n+    if (!init) {\n+      throw DataUtils.newIllegalStateException(\n+          DataUtils.ERROR_TRANSACTION_ILLEGAL_STATE,\n+          \"Not initialized\");\n+    }\n+    transactionId = openTransactions.nextClearBit(1);\n+    if (transactionId > maxTransactionId) {\n+      throw DataUtils.newIllegalStateException(\n+          DataUtils.ERROR_TOO_MANY_OPEN_TRANSACTIONS,\n+          \"There are {0} open transactions\",\n+          transactionId - 1);\n+    }\n+    openTransactions.set(transactionId);\n+    status = Transaction.STATUS_OPEN;\n+    return new Transaction(this, transactionId, status, null, 0);\n+  }\n+\n+  /**\n+   * Store a transaction.\n+   *\n+   * @param t the transaction\n+   */\n+  synchronized void storeTransaction(Transaction t) {\n+    if (t.getStatus() == Transaction.STATUS_PREPARED ||\n+        t.getName() != null) {\n+      Object[] v = {t.getStatus(), t.getName()};\n+      preparedTransactions.put(t.getId(), v);\n+    }\n+  }\n+\n+  /**\n+   * Log an entry.\n+   *\n+   * @param t        the transaction\n+   * @param logId    the log id\n+   * @param mapId    the map id\n+   * @param key      the key\n+   * @param oldValue the old value\n+   */\n+  void log(Transaction t, long logId, int mapId,\n+           Object key, Object oldValue) {\n+    Long undoKey = getOperationId(t.getId(), logId);\n+    Object[] log = new Object[] {mapId, key, oldValue};\n+    rwLock.writeLock().lock();\n+    try {\n+      if (logId == 0) {\n+        if (undoLog.containsKey(undoKey)) {\n+          throw DataUtils.newIllegalStateException(\n+              DataUtils.ERROR_TOO_MANY_OPEN_TRANSACTIONS,\n+              \"An old transaction with the same id \" +\n+                  \"is still open: {0}\",\n+              t.getId());\n+        }\n+      }\n+      undoLog.put(undoKey, log);\n+    } finally {\n+      rwLock.writeLock().unlock();\n+    }\n+  }\n+\n+  /**\n+   * Remove a log entry.\n+   *\n+   * @param t     the transaction\n+   * @param logId the log id\n+   */\n+  public void logUndo(Transaction t, long logId) {\n+    Long undoKey = getOperationId(t.getId(), logId);\n+    rwLock.writeLock().lock();\n+    try {\n+      Object[] old = undoLog.remove(undoKey);\n+      if (old == null) {\n+        throw DataUtils.newIllegalStateException(\n+            DataUtils.ERROR_TRANSACTION_ILLEGAL_STATE,\n+            \"Transaction {0} was concurrently rolled back\",\n+            t.getId());\n+      }\n+    } finally {\n+      rwLock.writeLock().unlock();\n+    }\n+  }\n+\n+  /**\n+   * Remove the given map.\n+   *\n+   * @param <K> the key type\n+   * @param <V> the value type\n+   * @param map the map\n+   */\n+  synchronized <K, V> void removeMap(TransactionMap<K, V> map) {\n+    maps.remove(map.mapId);\n+    store.removeMap(map.map);\n+  }\n+\n+  /**\n+   * Commit a transaction.\n+   *\n+   * @param t        the transaction\n+   * @param maxLogId the last log id\n+   */\n+  void commit(Transaction t, long maxLogId) {\n+    if (store.isClosed()) {\n+      return;\n+    }\n+    // TODO could synchronize on blocks (100 at a time or so)\n+    rwLock.writeLock().lock();\n+    try {\n+      t.setStatus(Transaction.STATUS_COMMITTING);\n+      for (long logId = 0; logId < maxLogId; logId++) {\n+        Long undoKey = getOperationId(t.getId(), logId);\n+        Object[] op = undoLog.get(undoKey);\n+        if (op == null) {\n+          // partially committed: load next\n+          undoKey = undoLog.ceilingKey(undoKey);\n+          if (undoKey == null ||\n+              getTransactionId(undoKey) != t.getId()) {\n+            break;\n+          }\n+          logId = getLogId(undoKey) - 1;\n+          continue;\n+        }\n+        int mapId = (Integer) op[0];\n+        MVMap<Object, VersionedValue> map = openMap(mapId);\n+        if (map != null) { // might be null if map was removed later\n+          Object key = op[1];\n+          VersionedValue value = map.get(key);\n+          if (value != null) {\n+            // only commit (remove/update) value if we've reached\n+            // last undoLog entry for a given key\n+            if (value.operationId == undoKey) {\n+              if (value.value == null) {\n+                map.remove(key);\n+              } else {\n+                VersionedValue v2 = new VersionedValue();\n+                v2.value = value.value;\n+                map.put(key, v2);\n+              }\n+            }\n+          }\n+        }\n+        undoLog.remove(undoKey);\n+      }\n+    } finally {\n+      rwLock.writeLock().unlock();\n+    }\n+    endTransaction(t);\n+  }\n+\n+  /**\n+   * Open the map with the given name.\n+   *\n+   * @param <K>       the key type\n+   * @param name      the map name\n+   * @param keyType   the key type\n+   * @param valueType the value type\n+   * @return the map\n+   */\n+  synchronized <K> MVMap<K, VersionedValue> openMap(String name,\n+                                                    DataType keyType, DataType valueType) {\n+    if (keyType == null) {\n+      keyType = new ObjectDataType();\n+    }\n+    if (valueType == null) {\n+      valueType = new ObjectDataType();\n+    }\n+    VersionedValueType vt = new VersionedValueType(valueType);\n+    MVMap<K, VersionedValue> map;\n+    MVMap.Builder<K, VersionedValue> builder =\n+        new MVMap.Builder<K, VersionedValue>().\n+            keyType(keyType).valueType(vt);\n+    map = store.openMap(name, builder);\n+    @SuppressWarnings(\"unchecked\")\n+    MVMap<Object, VersionedValue> m = (MVMap<Object, VersionedValue>) map;\n+    maps.put(map.getId(), m);\n+    return map;\n+  }\n+\n+  /**\n+   * Open the map with the given id.\n+   *\n+   * @param mapId the id\n+   * @return the map\n+   */\n+  synchronized MVMap<Object, VersionedValue> openMap(int mapId) {\n+    MVMap<Object, VersionedValue> map = maps.get(mapId);\n+    if (map != null) {\n+      return map;\n+    }\n+    String mapName = store.getMapName(mapId);\n+    if (mapName == null) {\n+      // the map was removed later on\n+      return null;\n+    }\n+    VersionedValueType vt = new VersionedValueType(dataType);\n+    MVMap.Builder<Object, VersionedValue> mapBuilder =\n+        new MVMap.Builder<Object, VersionedValue>().\n+            keyType(dataType).valueType(vt);\n+    map = store.openMap(mapName, mapBuilder);\n+    maps.put(mapId, map);\n+    return map;\n+  }\n+\n+  /**\n+   * Create a temporary map. Such maps are removed when opening the store.\n+   *\n+   * @return the map\n+   */\n+  synchronized MVMap<Object, Integer> createTempMap() {\n+    String mapName = \"temp.\" + nextTempMapId++;\n+    return openTempMap(mapName);\n+  }\n+\n+  /**\n+   * Open a temporary map.\n+   *\n+   * @param mapName the map name\n+   * @return the map\n+   */\n+  MVMap<Object, Integer> openTempMap(String mapName) {\n+    MVMap.Builder<Object, Integer> mapBuilder =\n+        new MVMap.Builder<Object, Integer>().\n+            keyType(dataType);\n+    return store.openMap(mapName, mapBuilder);\n+  }\n+\n+  /**\n+   * End this transaction\n+   *\n+   * @param t the transaction\n+   */\n+  synchronized void endTransaction(Transaction t) {\n+    if (t.getStatus() == Transaction.STATUS_PREPARED) {\n+      preparedTransactions.remove(t.getId());\n+    }\n+    t.setStatus(Transaction.STATUS_CLOSED);\n+    openTransactions.clear(t.transactionId);\n+    if (store.getAutoCommitDelay() == 0) {\n+      store.commit();\n+      return;\n+    }\n+    // to avoid having to store the transaction log,\n+    // if there is no open transaction,\n+    // and if there have been many changes, store them now\n+    if (undoLog.isEmpty()) {\n+      int unsaved = store.getUnsavedMemory();\n+      int max = store.getAutoCommitMemory();\n+      // save at 3/4 capacity\n+      if (unsaved * 4 > max * 3) {\n+        store.commit();\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Rollback to an old savepoint.\n+   *\n+   * @param t        the transaction\n+   * @param maxLogId the last log id\n+   * @param toLogId  the log id to roll back to\n+   */\n+  void rollbackTo(Transaction t, long maxLogId, long toLogId) {\n+    // TODO could synchronize on blocks (100 at a time or so)\n+    rwLock.writeLock().lock();\n+    try {\n+      for (long logId = maxLogId - 1; logId >= toLogId; logId--) {\n+        Long undoKey = getOperationId(t.getId(), logId);\n+        Object[] op = undoLog.get(undoKey);\n+        if (op == null) {\n+          // partially rolled back: load previous\n+          undoKey = undoLog.floorKey(undoKey);\n+          if (undoKey == null ||\n+              getTransactionId(undoKey) != t.getId()) {\n+            break;\n+          }\n+          logId = getLogId(undoKey) + 1;\n+          continue;\n+        }\n+        int mapId = ((Integer) op[0]).intValue();\n+        MVMap<Object, VersionedValue> map = openMap(mapId);\n+        if (map != null) {\n+          Object key = op[1];\n+          VersionedValue oldValue = (VersionedValue) op[2];\n+          if (oldValue == null) {\n+            // this transaction added the value\n+            map.remove(key);\n+          } else {\n+            // this transaction updated the value\n+            map.put(key, oldValue);\n+          }\n+        }\n+        undoLog.remove(undoKey);\n+      }\n+    } finally {\n+      rwLock.writeLock().unlock();\n+    }\n+  }\n+\n+  /**\n+   * Get the changes of the given transaction, starting from the latest log id\n+   * back to the given log id.\n+   *\n+   * @param t        the transaction\n+   * @param maxLogId the maximum log id\n+   * @param toLogId  the minimum log id\n+   * @return the changes\n+   */\n+  Iterator<Change> getChanges(final Transaction t, final long maxLogId,\n+                              final long toLogId) {\n+    return new Iterator<Change>() {\n+\n+      private long logId = maxLogId - 1;\n+      private Change current;\n+\n+      {\n+        fetchNext();\n+      }\n+\n+      private void fetchNext() {\n+        rwLock.writeLock().lock();\n+        try {\n+          while (logId >= toLogId) {\n+            Long undoKey = getOperationId(t.getId(), logId);\n+            Object[] op = undoLog.get(undoKey);\n+            logId--;\n+            if (op == null) {\n+              // partially rolled back: load previous\n+              undoKey = undoLog.floorKey(undoKey);\n+              if (undoKey == null ||\n+                  getTransactionId(undoKey) != t.getId()) {\n+                break;\n+              }\n+              logId = getLogId(undoKey);\n+              continue;\n+            }\n+            int mapId = ((Integer) op[0]).intValue();\n+            MVMap<Object, VersionedValue> m = openMap(mapId);\n+            if (m == null) {\n+              // map was removed later on\n+            } else {\n+              current = new Change();\n+              current.mapName = m.getName();\n+              current.key = op[1];\n+              VersionedValue oldValue = (VersionedValue) op[2];\n+              current.value = oldValue == null ?\n+                  null : oldValue.value;\n+              return;\n+            }\n+          }\n+        } finally {\n+          rwLock.writeLock().unlock();\n+        }\n+        current = null;\n+      }\n+\n+      @Override\n+      public boolean hasNext() {\n+        return current != null;\n+      }\n+\n+      @Override\n+      public Change next() {\n+        if (current == null) {\n+          throw DataUtils.newUnsupportedOperationException(\"no data\");\n+        }\n+        Change result = current;\n+        fetchNext();\n+        return result;\n+      }\n+\n+      @Override\n+      public void remove() {\n+        throw DataUtils.newUnsupportedOperationException(\"remove\");\n+      }\n+\n+    };\n+  }\n+\n+  /**\n+   * A change in a map.\n+   */\n+  public static class Change {\n+\n     /**\n-     * The store.\n+     * The name of the map where the change occurred.\n      */\n-    final MVStore store;\n+    public String mapName;\n \n     /**\n-     * The persisted map of prepared transactions.\n-     * Key: transactionId, value: [ status, name ].\n+     * The key.\n      */\n-    final MVMap<Integer, Object[]> preparedTransactions;\n+    public Object key;\n \n     /**\n-     * The undo log.\n-     * <p>\n-     * If the first entry for a transaction doesn't have a logId\n-     * of 0, then the transaction is partially committed (which means rollback\n-     * is not possible). Log entries are written before the data is changed\n-     * (write-ahead).\n-     * <p>\n-     * Key: opId, value: [ mapId, key, oldValue ].\n+     * The value.\n      */\n-    final MVMap<Long, Object[]> undoLog;\n+    public Object value;\n+  }\n+\n+  /**\n+   * A transaction.\n+   */\n+  public static class Transaction {\n \n     /**\n-     * the reader/writer lock for the undo-log. Allows us to process multiple\n-     * selects in parallel.\n+     * The status of a closed transaction (committed or rolled back).\n      */\n-    final ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();\n+    public static final int STATUS_CLOSED = 0;\n \n     /**\n-     * The map of maps.\n+     * The status of an open transaction.\n      */\n-    private HashMap<Integer, MVMap<Object, VersionedValue>> maps =\n-            New.hashMap();\n+    public static final int STATUS_OPEN = 1;\n \n-    private final DataType dataType;\n+    /**\n+     * The status of a prepared transaction.\n+     */\n+    public static final int STATUS_PREPARED = 2;\n \n-    private final BitSet openTransactions = new BitSet();\n+    /**\n+     * The status of a transaction that is being committed, but possibly not\n+     * yet finished. A transactions can go into this state when the store is\n+     * closed while the transaction is committing. When opening a store,\n+     * such transactions should be committed.\n+     */\n+    public static final int STATUS_COMMITTING = 3;\n \n-    private boolean init;\n+    /**\n+     * The transaction store.\n+     */\n+    final TransactionStore store;\n \n-    private int maxTransactionId = 0xffff;\n+    /**\n+     * The transaction id.\n+     */\n+    final int transactionId;\n \n     /**\n-     * The next id of a temporary map.\n+     * The log id of the last entry in the undo log map.\n      */\n-    private int nextTempMapId;\n+    long logId;\n+\n+    private int status;\n+\n+    private String name;\n+\n+    Transaction(TransactionStore store, int transactionId, int status,\n+                String name, long logId) {\n+      this.store = store;\n+      this.transactionId = transactionId;\n+      this.status = status;\n+      this.name = name;\n+      this.logId = logId;\n+    }\n+\n+    public int getId() {\n+      return transactionId;\n+    }\n+\n+    public int getStatus() {\n+      return status;\n+    }\n+\n+    void setStatus(int status) {\n+      this.status = status;\n+    }\n+\n+    public void setName(String name) {\n+      checkNotClosed();\n+      this.name = name;\n+      store.storeTransaction(this);\n+    }\n+\n+    public String getName() {\n+      return name;\n+    }\n \n     /**\n-     * Create a new transaction store.\n+     * Create a new savepoint.\n      *\n-     * @param store the store\n+     * @return the savepoint id\n      */\n-    public TransactionStore(MVStore store) {\n-        this(store, new ObjectDataType());\n+    public long setSavepoint() {\n+      return logId;\n     }\n \n     /**\n-     * Create a new transaction store.\n+     * Add a log entry.\n      *\n-     * @param store the store\n-     * @param dataType the data type for map keys and values\n+     * @param mapId    the map id\n+     * @param key      the key\n+     * @param oldValue the old value\n      */\n-    public TransactionStore(MVStore store, DataType dataType) {\n-        this.store = store;\n-        this.dataType = dataType;\n-        preparedTransactions = store.openMap(\"openTransactions\",\n-                new MVMap.Builder<Integer, Object[]>());\n-        VersionedValueType oldValueType = new VersionedValueType(dataType);\n-        ArrayType undoLogValueType = new ArrayType(new DataType[]{\n-                new ObjectDataType(), dataType, oldValueType\n-        });\n-        MVMap.Builder<Long, Object[]> builder =\n-                new MVMap.Builder<Long, Object[]>().\n-                valueType(undoLogValueType);\n-        undoLog = store.openMap(\"undoLog\", builder);\n-        if (undoLog.getValueType() != undoLogValueType) {\n-            throw DataUtils.newIllegalStateException(\n-                    DataUtils.ERROR_TRANSACTION_CORRUPT,\n-                    \"Undo map open with a different value type\");\n-        }\n+    void log(int mapId, Object key, Object oldValue) {\n+      store.log(this, logId, mapId, key, oldValue);\n+      // only increment the log id if logging was successful\n+      logId++;\n     }\n \n     /**\n-     * Initialize the store. This is needed before a transaction can be opened.\n-     * If the transaction store is corrupt, this method can throw an exception,\n-     * in which case the store can only be used for reading.\n+     * Remove the last log entry.\n      */\n-    public synchronized void init() {\n-        init = true;\n-        // remove all temporary maps\n-        for (String mapName : store.getMapNames()) {\n-            if (mapName.startsWith(\"temp.\")) {\n-                MVMap<Object, Integer> temp = openTempMap(mapName);\n-                store.removeMap(temp);\n-            }\n-        }\n-        rwLock.writeLock().lock();\n-        try {\n-            if (undoLog.size() > 0) {\n-                for (Long key : undoLog.keySet()) {\n-                    int transactionId = getTransactionId(key);\n-                    openTransactions.set(transactionId);\n-                }\n-            }\n-        } finally {\n-            rwLock.writeLock().unlock();\n-        }\n+    void logUndo() {\n+      store.logUndo(this, --logId);\n     }\n \n     /**\n-     * Set the maximum transaction id, after which ids are re-used. If the old\n-     * transaction is still in use when re-using an old id, the new transaction\n-     * fails.\n+     * Open a data map.\n      *\n-     * @param max the maximum id\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n+     * @param name the name of the map\n+     * @return the transaction map\n      */\n-    public void setMaxTransactionId(int max) {\n-        this.maxTransactionId = max;\n+    public <K, V> TransactionMap<K, V> openMap(String name) {\n+      return openMap(name, null, null);\n     }\n \n     /**\n-     * Combine the transaction id and the log id to an operation id.\n+     * Open the map to store the data.\n      *\n-     * @param transactionId the transaction id\n-     * @param logId the log id\n-     * @return the operation id\n+     * @param <K>       the key type\n+     * @param <V>       the value type\n+     * @param name      the name of the map\n+     * @param keyType   the key data type\n+     * @param valueType the value data type\n+     * @return the transaction map\n      */\n-    static long getOperationId(int transactionId, long logId) {\n-        DataUtils.checkArgument(transactionId >= 0 && transactionId < (1 << 24),\n-                \"Transaction id out of range: {0}\", transactionId);\n-        DataUtils.checkArgument(logId >= 0 && logId < (1L << 40),\n-                \"Transaction log id out of range: {0}\", logId);\n-        return ((long) transactionId << 40) | logId;\n+    public <K, V> TransactionMap<K, V> openMap(String name,\n+                                               DataType keyType, DataType valueType) {\n+      checkNotClosed();\n+      MVMap<K, VersionedValue> map = store.openMap(name, keyType,\n+          valueType);\n+      int mapId = map.getId();\n+      return new TransactionMap<>(this, map, mapId);\n     }\n \n     /**\n-     * Get the transaction id for the given operation id.\n+     * Open the transactional version of the given map.\n      *\n-     * @param operationId the operation id\n-     * @return the transaction id\n+     * @param <K> the key type\n+     * @param <V> the value type\n+     * @param map the base map\n+     * @return the transactional map\n      */\n-    static int getTransactionId(long operationId) {\n-        return (int) (operationId >>> 40);\n+    public <K, V> TransactionMap<K, V> openMap(\n+        MVMap<K, VersionedValue> map) {\n+      checkNotClosed();\n+      int mapId = map.getId();\n+      return new TransactionMap<>(this, map, mapId);\n     }\n \n     /**\n-     * Get the log id for the given operation id.\n-     *\n-     * @param operationId the operation id\n-     * @return the log id\n+     * Prepare the transaction. Afterwards, the transaction can only be\n+     * committed or rolled back.\n      */\n-    static long getLogId(long operationId) {\n-        return operationId & ((1L << 40) - 1);\n+    public void prepare() {\n+      checkNotClosed();\n+      status = STATUS_PREPARED;\n+      store.storeTransaction(this);\n     }\n \n     /**\n-     * Get the list of unclosed transactions that have pending writes.\n+     * Commit the transaction. Afterwards, this transaction is closed.\n+     */\n+    public void commit() {\n+      checkNotClosed();\n+      store.commit(this, logId);\n+    }\n+\n+    /**\n+     * Roll back to the given savepoint. This is only allowed if the\n+     * transaction is open.\n      *\n-     * @return the list of transactions (sorted by id)\n+     * @param savepointId the savepoint id\n      */\n-    public List<Transaction> getOpenTransactions() {\n-        rwLock.readLock().lock();\n-        try {\n-            ArrayList<Transaction> list = New.arrayList();\n-            Long key = undoLog.firstKey();\n-            while (key != null) {\n-                int transactionId = getTransactionId(key);\n-                key = undoLog.lowerKey(getOperationId(transactionId + 1, 0));\n-                long logId = getLogId(key) + 1;\n-                Object[] data = preparedTransactions.get(transactionId);\n-                int status;\n-                String name;\n-                if (data == null) {\n-                    if (undoLog.containsKey(getOperationId(transactionId, 0))) {\n-                        status = Transaction.STATUS_OPEN;\n-                    } else {\n-                        status = Transaction.STATUS_COMMITTING;\n-                    }\n-                    name = null;\n-                } else {\n-                    status = (Integer) data[0];\n-                    name = (String) data[1];\n-                }\n-                Transaction t = new Transaction(this, transactionId, status,\n-                        name, logId);\n-                list.add(t);\n-                key = undoLog.ceilingKey(getOperationId(transactionId + 1, 0));\n-            }\n-            return list;\n-        } finally {\n-            rwLock.readLock().unlock();\n-        }\n+    public void rollbackToSavepoint(long savepointId) {\n+      checkNotClosed();\n+      store.rollbackTo(this, logId, savepointId);\n+      logId = savepointId;\n     }\n \n     /**\n-     * Close the transaction store.\n+     * Roll the transaction back. Afterwards, this transaction is closed.\n      */\n-    public synchronized void close() {\n-        store.commit();\n+    public void rollback() {\n+      checkNotClosed();\n+      store.rollbackTo(this, logId, 0);\n+      store.endTransaction(this);\n     }\n \n     /**\n-     * Begin a new transaction.\n+     * Get the list of changes, starting with the latest change, up to the\n+     * given savepoint (in reverse order than they occurred). The value of\n+     * the change is the value before the change was applied.\n      *\n-     * @return the transaction\n+     * @param savepointId the savepoint id, 0 meaning the beginning of the\n+     *                    transaction\n+     * @return the changes\n      */\n-    public synchronized Transaction begin() {\n+    public Iterator<Change> getChanges(long savepointId) {\n+      return store.getChanges(this, logId, savepointId);\n+    }\n \n-        int transactionId;\n-        int status;\n-        if (!init) {\n-            throw DataUtils.newIllegalStateException(\n-                    DataUtils.ERROR_TRANSACTION_ILLEGAL_STATE,\n-                    \"Not initialized\");\n-        }\n-        transactionId = openTransactions.nextClearBit(1);\n-        if (transactionId > maxTransactionId) {\n-            throw DataUtils.newIllegalStateException(\n-                    DataUtils.ERROR_TOO_MANY_OPEN_TRANSACTIONS,\n-                    \"There are {0} open transactions\",\n-                    transactionId - 1);\n-        }\n-        openTransactions.set(transactionId);\n-        status = Transaction.STATUS_OPEN;\n-        return new Transaction(this, transactionId, status, null, 0);\n+    /**\n+     * Check whether this transaction is open or prepared.\n+     */\n+    void checkNotClosed() {\n+      if (status == STATUS_CLOSED) {\n+        throw DataUtils.newIllegalStateException(\n+            DataUtils.ERROR_CLOSED, \"Transaction is closed\");\n+      }\n     }\n \n     /**\n-     * Store a transaction.\n+     * Remove the map.\n      *\n-     * @param t the transaction\n+     * @param map the map\n      */\n-    synchronized void storeTransaction(Transaction t) {\n-        if (t.getStatus() == Transaction.STATUS_PREPARED ||\n-                t.getName() != null) {\n-            Object[] v = { t.getStatus(), t.getName() };\n-            preparedTransactions.put(t.getId(), v);\n-        }\n+    public <K, V> void removeMap(TransactionMap<K, V> map) {\n+      store.removeMap(map);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"\" + transactionId;\n+    }\n+\n+  }\n+\n+  /**\n+   * A map that supports transactions.\n+   *\n+   * @param <K> the key type\n+   * @param <V> the value type\n+   */\n+  public static class TransactionMap<K, V> {\n+\n+    /**\n+     * The map id.\n+     */\n+    final int mapId;\n+\n+    /**\n+     * If a record was read that was updated by this transaction, and the\n+     * update occurred before this log id, the older version is read. This\n+     * is so that changes are not immediately visible, to support statement\n+     * processing (for example \"update test set id = id + 1\").\n+     */\n+    long readLogId = Long.MAX_VALUE;\n+\n+    /**\n+     * The map used for writing (the latest version).\n+     * <p>\n+     * Key: key the key of the data.\n+     * Value: { transactionId, oldVersion, value }\n+     */\n+    final MVMap<K, VersionedValue> map;\n+\n+    private Transaction transaction;\n+\n+    TransactionMap(Transaction transaction, MVMap<K, VersionedValue> map,\n+                   int mapId) {\n+      this.transaction = transaction;\n+      this.map = map;\n+      this.mapId = mapId;\n     }\n \n     /**\n-     * Log an entry.\n+     * Set the savepoint. Afterwards, reads are based on the specified\n+     * savepoint.\n      *\n-     * @param t the transaction\n-     * @param logId the log id\n-     * @param mapId the map id\n-     * @param key the key\n-     * @param oldValue the old value\n+     * @param savepoint the savepoint\n      */\n-    void log(Transaction t, long logId, int mapId,\n-            Object key, Object oldValue) {\n-        Long undoKey = getOperationId(t.getId(), logId);\n-        Object[] log = new Object[] { mapId, key, oldValue };\n-        rwLock.writeLock().lock();\n-        try {\n-            if (logId == 0) {\n-                if (undoLog.containsKey(undoKey)) {\n-                    throw DataUtils.newIllegalStateException(\n-                            DataUtils.ERROR_TOO_MANY_OPEN_TRANSACTIONS,\n-                            \"An old transaction with the same id \" +\n-                            \"is still open: {0}\",\n-                            t.getId());\n-                }\n-            }\n-            undoLog.put(undoKey, log);\n-        } finally {\n-            rwLock.writeLock().unlock();\n-        }\n+    public void setSavepoint(long savepoint) {\n+      this.readLogId = savepoint;\n     }\n \n     /**\n-     * Remove a log entry.\n+     * Get a clone of this map for the given transaction.\n      *\n-     * @param t the transaction\n-     * @param logId the log id\n+     * @param transaction the transaction\n+     * @param savepoint   the savepoint\n+     * @return the map\n      */\n-    public void logUndo(Transaction t, long logId) {\n-        Long undoKey = getOperationId(t.getId(), logId);\n-        rwLock.writeLock().lock();\n-        try {\n-            Object[] old = undoLog.remove(undoKey);\n-            if (old == null) {\n-                throw DataUtils.newIllegalStateException(\n-                        DataUtils.ERROR_TRANSACTION_ILLEGAL_STATE,\n-                        \"Transaction {0} was concurrently rolled back\",\n-                        t.getId());\n-            }\n-        } finally {\n-            rwLock.writeLock().unlock();\n-        }\n+    public TransactionMap<K, V> getInstance(Transaction transaction,\n+                                            long savepoint) {\n+      TransactionMap<K, V> m =\n+          new TransactionMap<>(transaction, map, mapId);\n+      m.setSavepoint(savepoint);\n+      return m;\n     }\n \n     /**\n-     * Remove the given map.\n+     * Get the size of the raw map. This includes uncommitted entries, and\n+     * transiently removed entries, so it is the maximum number of entries.\n      *\n-     * @param <K> the key type\n-     * @param <V> the value type\n-     * @param map the map\n+     * @return the maximum size\n      */\n-    synchronized <K, V> void removeMap(TransactionMap<K, V> map) {\n-        maps.remove(map.mapId);\n-        store.removeMap(map.map);\n+    public long sizeAsLongMax() {\n+      return map.sizeAsLong();\n     }\n \n     /**\n-     * Commit a transaction.\n+     * Get the size of the map as seen by this transaction.\n      *\n-     * @param t the transaction\n-     * @param maxLogId the last log id\n+     * @return the size\n      */\n-    void commit(Transaction t, long maxLogId) {\n-        if (store.isClosed()) {\n-            return;\n-        }\n-        // TODO could synchronize on blocks (100 at a time or so)\n-        rwLock.writeLock().lock();\n-        try {\n-            t.setStatus(Transaction.STATUS_COMMITTING);\n-            for (long logId = 0; logId < maxLogId; logId++) {\n-                Long undoKey = getOperationId(t.getId(), logId);\n-                Object[] op = undoLog.get(undoKey);\n-                if (op == null) {\n-                    // partially committed: load next\n-                    undoKey = undoLog.ceilingKey(undoKey);\n-                    if (undoKey == null ||\n-                            getTransactionId(undoKey) != t.getId()) {\n-                        break;\n-                    }\n-                    logId = getLogId(undoKey) - 1;\n-                    continue;\n-                }\n-                int mapId = (Integer) op[0];\n-                MVMap<Object, VersionedValue> map = openMap(mapId);\n-                if (map != null) { // might be null if map was removed later\n-                    Object key = op[1];\n-                    VersionedValue value = map.get(key);\n-                    if (value != null) {\n-                        // only commit (remove/update) value if we've reached\n-                        // last undoLog entry for a given key\n-                        if (value.operationId == undoKey) {\n-                            if (value.value == null) {\n-                                map.remove(key);\n-                            } else {\n-                                VersionedValue v2 = new VersionedValue();\n-                                v2.value = value.value;\n-                                map.put(key, v2);\n-                            }\n-                        }\n-                    }\n+    public long sizeAsLong() {\n+      transaction.store.rwLock.readLock().lock();\n+      try {\n+        long sizeRaw = map.sizeAsLong();\n+        MVMap<Long, Object[]> undo = transaction.store.undoLog;\n+        long undoLogSize;\n+        synchronized (undo) {\n+          undoLogSize = undo.sizeAsLong();\n+        }\n+        if (undoLogSize == 0) {\n+          return sizeRaw;\n+        }\n+        if (undoLogSize > sizeRaw) {\n+          // the undo log is larger than the map -\n+          // count the entries of the map\n+          long size = 0;\n+          Cursor<K, VersionedValue> cursor = map.cursor(null);\n+          while (cursor.hasNext()) {\n+            VersionedValue data;\n+            K key = cursor.next();\n+            data = getValue(key, readLogId, cursor.getValue());\n+            if (data != null && data.value != null) {\n+              size++;\n+            }\n+          }\n+          return size;\n+        }\n+        // the undo log is smaller than the map -\n+        // scan the undo log and subtract invisible entries\n+        synchronized (undo) {\n+          // re-fetch in case any transaction was committed now\n+          long size = map.sizeAsLong();\n+          MVMap<Object, Integer> temp = transaction.store\n+              .createTempMap();\n+          try {\n+            for (Entry<Long, Object[]> e : undo.entrySet()) {\n+              Object[] op = e.getValue();\n+              int m = (Integer) op[0];\n+              if (m != mapId) {\n+                // a different map - ignore\n+                continue;\n+              }\n+              @SuppressWarnings(\"unchecked\")\n+              K key = (K) op[1];\n+              if (get(key) == null) {\n+                Integer old = temp.put(key, 1);\n+                // count each key only once (there might be\n+                // multiple\n+                // changes for the same key)\n+                if (old == null) {\n+                  size--;\n                 }\n-                undoLog.remove(undoKey);\n+              }\n             }\n-        } finally {\n-            rwLock.writeLock().unlock();\n-        }\n-        endTransaction(t);\n+          } finally {\n+            transaction.store.store.removeMap(temp);\n+          }\n+          return size;\n+        }\n+      } finally {\n+        transaction.store.rwLock.readLock().unlock();\n+      }\n     }\n \n     /**\n-     * Open the map with the given name.\n+     * Remove an entry.\n+     * <p>\n+     * If the row is locked, this method will retry until the row could be\n+     * updated or until a lock timeout.\n      *\n-     * @param <K> the key type\n-     * @param name the map name\n-     * @param keyType the key type\n-     * @param valueType the value type\n-     * @return the map\n+     * @param key the key\n+     * @throws IllegalStateException if a lock timeout occurs\n      */\n-    synchronized <K> MVMap<K, VersionedValue> openMap(String name,\n-            DataType keyType, DataType valueType) {\n-        if (keyType == null) {\n-            keyType = new ObjectDataType();\n-        }\n-        if (valueType == null) {\n-            valueType = new ObjectDataType();\n-        }\n-        VersionedValueType vt = new VersionedValueType(valueType);\n-        MVMap<K, VersionedValue> map;\n-        MVMap.Builder<K, VersionedValue> builder =\n-                new MVMap.Builder<K, VersionedValue>().\n-                keyType(keyType).valueType(vt);\n-        map = store.openMap(name, builder);\n-        @SuppressWarnings(\"unchecked\")\n-        MVMap<Object, VersionedValue> m = (MVMap<Object, VersionedValue>) map;\n-        maps.put(map.getId(), m);\n-        return map;\n+    public V remove(K key) {\n+      return set(key, null);\n     }\n \n     /**\n-     * Open the map with the given id.\n+     * Update the value for the given key.\n+     * <p>\n+     * If the row is locked, this method will retry until the row could be\n+     * updated or until a lock timeout.\n      *\n-     * @param mapId the id\n-     * @return the map\n+     * @param key   the key\n+     * @param value the new value (not null)\n+     * @return the old value\n+     * @throws IllegalStateException if a lock timeout occurs\n      */\n-    synchronized MVMap<Object, VersionedValue> openMap(int mapId) {\n-        MVMap<Object, VersionedValue> map = maps.get(mapId);\n-        if (map != null) {\n-            return map;\n-        }\n-        String mapName = store.getMapName(mapId);\n-        if (mapName == null) {\n-            // the map was removed later on\n-            return null;\n-        }\n-        VersionedValueType vt = new VersionedValueType(dataType);\n-        MVMap.Builder<Object, VersionedValue> mapBuilder =\n-                new MVMap.Builder<Object, VersionedValue>().\n-                keyType(dataType).valueType(vt);\n-        map = store.openMap(mapName, mapBuilder);\n-        maps.put(mapId, map);\n-        return map;\n+    public V put(K key, V value) {\n+      DataUtils.checkArgument(value != null, \"The value may not be null\");\n+      return set(key, value);\n     }\n \n     /**\n-     * Create a temporary map. Such maps are removed when opening the store.\n+     * Update the value for the given key, without adding an undo log entry.\n      *\n-     * @return the map\n+     * @param key   the key\n+     * @param value the value\n+     * @return the old value\n      */\n-    synchronized MVMap<Object, Integer> createTempMap() {\n-        String mapName = \"temp.\" + nextTempMapId++;\n-        return openTempMap(mapName);\n+    @SuppressWarnings(\"unchecked\")\n+    public V putCommitted(K key, V value) {\n+      DataUtils.checkArgument(value != null, \"The value may not be null\");\n+      VersionedValue newValue = new VersionedValue();\n+      newValue.value = value;\n+      VersionedValue oldValue = map.put(key, newValue);\n+      return (V) (oldValue == null ? null : oldValue.value);\n+    }\n+\n+    private V set(K key, V value) {\n+      transaction.checkNotClosed();\n+      V old = get(key);\n+      boolean ok = trySet(key, value, false);\n+      if (ok) {\n+        return old;\n+      }\n+      throw DataUtils.newIllegalStateException(\n+          DataUtils.ERROR_TRANSACTION_LOCKED, \"Entry is locked\");\n     }\n \n     /**\n-     * Open a temporary map.\n+     * Try to remove the value for the given key.\n+     * <p>\n+     * This will fail if the row is locked by another transaction (that\n+     * means, if another open transaction changed the row).\n      *\n-     * @param mapName the map name\n-     * @return the map\n+     * @param key the key\n+     * @return whether the entry could be removed\n      */\n-    MVMap<Object, Integer> openTempMap(String mapName) {\n-        MVMap.Builder<Object, Integer> mapBuilder =\n-                new MVMap.Builder<Object, Integer>().\n-                keyType(dataType);\n-        return store.openMap(mapName, mapBuilder);\n+    public boolean tryRemove(K key) {\n+      return trySet(key, null, false);\n     }\n \n     /**\n-     * End this transaction\n+     * Try to update the value for the given key.\n+     * <p>\n+     * This will fail if the row is locked by another transaction (that\n+     * means, if another open transaction changed the row).\n      *\n-     * @param t the transaction\n+     * @param key   the key\n+     * @param value the new value\n+     * @return whether the entry could be updated\n      */\n-    synchronized void endTransaction(Transaction t) {\n-        if (t.getStatus() == Transaction.STATUS_PREPARED) {\n-            preparedTransactions.remove(t.getId());\n-        }\n-        t.setStatus(Transaction.STATUS_CLOSED);\n-        openTransactions.clear(t.transactionId);\n-        if (store.getAutoCommitDelay() == 0) {\n-            store.commit();\n-            return;\n-        }\n-        // to avoid having to store the transaction log,\n-        // if there is no open transaction,\n-        // and if there have been many changes, store them now\n-        if (undoLog.isEmpty()) {\n-            int unsaved = store.getUnsavedMemory();\n-            int max = store.getAutoCommitMemory();\n-            // save at 3/4 capacity\n-            if (unsaved * 4 > max * 3) {\n-                store.commit();\n-            }\n-        }\n+    public boolean tryPut(K key, V value) {\n+      DataUtils.checkArgument(value != null, \"The value may not be null\");\n+      return trySet(key, value, false);\n     }\n \n     /**\n-     * Rollback to an old savepoint.\n+     * Try to set or remove the value. When updating only unchanged entries,\n+     * then the value is only changed if it was not changed after opening\n+     * the map.\n      *\n-     * @param t the transaction\n-     * @param maxLogId the last log id\n-     * @param toLogId the log id to roll back to\n+     * @param key             the key\n+     * @param value           the new value (null to remove the value)\n+     * @param onlyIfUnchanged only set the value if it was not changed (by\n+     *                        this or another transaction) since the map was opened\n+     * @return true if the value was set, false if there was a concurrent\n+     * update\n      */\n-    void rollbackTo(Transaction t, long maxLogId, long toLogId) {\n-        // TODO could synchronize on blocks (100 at a time or so)\n-        rwLock.writeLock().lock();\n-        try {\n-            for (long logId = maxLogId - 1; logId >= toLogId; logId--) {\n-                Long undoKey = getOperationId(t.getId(), logId);\n-                Object[] op = undoLog.get(undoKey);\n-                if (op == null) {\n-                    // partially rolled back: load previous\n-                    undoKey = undoLog.floorKey(undoKey);\n-                    if (undoKey == null ||\n-                            getTransactionId(undoKey) != t.getId()) {\n-                        break;\n-                    }\n-                    logId = getLogId(undoKey) + 1;\n-                    continue;\n-                }\n-                int mapId = ((Integer) op[0]).intValue();\n-                MVMap<Object, VersionedValue> map = openMap(mapId);\n-                if (map != null) {\n-                    Object key = op[1];\n-                    VersionedValue oldValue = (VersionedValue) op[2];\n-                    if (oldValue == null) {\n-                        // this transaction added the value\n-                        map.remove(key);\n-                    } else {\n-                        // this transaction updated the value\n-                        map.put(key, oldValue);\n-                    }\n-                }\n-                undoLog.remove(undoKey);\n+    public boolean trySet(K key, V value, boolean onlyIfUnchanged) {\n+      VersionedValue current = map.get(key);\n+      if (onlyIfUnchanged) {\n+        VersionedValue old = getValue(key, readLogId);\n+        if (!map.areValuesEqual(old, current)) {\n+          long tx = getTransactionId(current.operationId);\n+          if (tx == transaction.transactionId) {\n+            if (value == null) {\n+              // ignore removing an entry\n+              // if it was added or changed\n+              // in the same statement\n+              return true;\n+            } else if (current.value == null) {\n+              // add an entry that was removed\n+              // in the same statement\n+            } else {\n+              return false;\n             }\n-        } finally {\n-            rwLock.writeLock().unlock();\n-        }\n+          } else {\n+            return false;\n+          }\n+        }\n+      }\n+      VersionedValue newValue = new VersionedValue();\n+      newValue.operationId = getOperationId(\n+          transaction.transactionId, transaction.logId);\n+      newValue.value = value;\n+      if (current == null) {\n+        // a new value\n+        transaction.log(mapId, key, current);\n+        VersionedValue old = map.putIfAbsent(key, newValue);\n+        if (old != null) {\n+          transaction.logUndo();\n+          return false;\n+        }\n+        return true;\n+      }\n+      long id = current.operationId;\n+      if (id == 0) {\n+        // committed\n+        transaction.log(mapId, key, current);\n+        // the transaction is committed:\n+        // overwrite the value\n+        if (!map.replace(key, current, newValue)) {\n+          // somebody else was faster\n+          transaction.logUndo();\n+          return false;\n+        }\n+        return true;\n+      }\n+      int tx = getTransactionId(current.operationId);\n+      if (tx == transaction.transactionId) {\n+        // added or updated by this transaction\n+        transaction.log(mapId, key, current);\n+        if (!map.replace(key, current, newValue)) {\n+          // strange, somebody overwrote the value\n+          // even though the change was not committed\n+          transaction.logUndo();\n+          return false;\n+        }\n+        return true;\n+      }\n+      // the transaction is not yet committed\n+      return false;\n     }\n \n     /**\n-     * Get the changes of the given transaction, starting from the latest log id\n-     * back to the given log id.\n+     * Get the value for the given key at the time when this map was opened.\n      *\n-     * @param t the transaction\n-     * @param maxLogId the maximum log id\n-     * @param toLogId the minimum log id\n-     * @return the changes\n+     * @param key the key\n+     * @return the value or null\n      */\n-    Iterator<Change> getChanges(final Transaction t, final long maxLogId,\n-            final long toLogId) {\n-        return new Iterator<Change>() {\n-\n-            private long logId = maxLogId - 1;\n-            private Change current;\n-\n-            {\n-                fetchNext();\n-            }\n-\n-            private void fetchNext() {\n-                rwLock.writeLock().lock();\n-                try {\n-                    while (logId >= toLogId) {\n-                        Long undoKey = getOperationId(t.getId(), logId);\n-                        Object[] op = undoLog.get(undoKey);\n-                        logId--;\n-                        if (op == null) {\n-                            // partially rolled back: load previous\n-                            undoKey = undoLog.floorKey(undoKey);\n-                            if (undoKey == null ||\n-                                    getTransactionId(undoKey) != t.getId()) {\n-                                break;\n-                            }\n-                            logId = getLogId(undoKey);\n-                            continue;\n-                        }\n-                        int mapId = ((Integer) op[0]).intValue();\n-                        MVMap<Object, VersionedValue> m = openMap(mapId);\n-                        if (m == null) {\n-                            // map was removed later on\n-                        } else {\n-                            current = new Change();\n-                            current.mapName = m.getName();\n-                            current.key = op[1];\n-                            VersionedValue oldValue = (VersionedValue) op[2];\n-                            current.value = oldValue == null ?\n-                                    null : oldValue.value;\n-                            return;\n-                        }\n-                    }\n-                } finally {\n-                    rwLock.writeLock().unlock();\n-                }\n-                current = null;\n-            }\n-\n-            @Override\n-            public boolean hasNext() {\n-                return current != null;\n-            }\n-\n-            @Override\n-            public Change next() {\n-                if (current == null) {\n-                    throw DataUtils.newUnsupportedOperationException(\"no data\");\n-                }\n-                Change result = current;\n-                fetchNext();\n-                return result;\n-            }\n-\n-            @Override\n-            public void remove() {\n-                throw DataUtils.newUnsupportedOperationException(\"remove\");\n-            }\n-\n-        };\n+    public V get(K key) {\n+      return get(key, readLogId);\n     }\n \n     /**\n-     * A change in a map.\n+     * Get the most recent value for the given key.\n+     *\n+     * @param key the key\n+     * @return the value or null\n      */\n-    public static class Change {\n-\n-        /**\n-         * The name of the map where the change occurred.\n-         */\n-        public String mapName;\n-\n-        /**\n-         * The key.\n-         */\n-        public Object key;\n-\n-        /**\n-         * The value.\n-         */\n-        public Object value;\n+    public V getLatest(K key) {\n+      return get(key, Long.MAX_VALUE);\n     }\n \n     /**\n-     * A transaction.\n+     * Whether the map contains the key.\n+     *\n+     * @param key the key\n+     * @return true if the map contains an entry for this key\n      */\n-    public static class Transaction {\n-\n-        /**\n-         * The status of a closed transaction (committed or rolled back).\n-         */\n-        public static final int STATUS_CLOSED = 0;\n-\n-        /**\n-         * The status of an open transaction.\n-         */\n-        public static final int STATUS_OPEN = 1;\n-\n-        /**\n-         * The status of a prepared transaction.\n-         */\n-        public static final int STATUS_PREPARED = 2;\n-\n-        /**\n-         * The status of a transaction that is being committed, but possibly not\n-         * yet finished. A transactions can go into this state when the store is\n-         * closed while the transaction is committing. When opening a store,\n-         * such transactions should be committed.\n-         */\n-        public static final int STATUS_COMMITTING = 3;\n-\n-        /**\n-         * The transaction store.\n-         */\n-        final TransactionStore store;\n-\n-        /**\n-         * The transaction id.\n-         */\n-        final int transactionId;\n-\n-        /**\n-         * The log id of the last entry in the undo log map.\n-         */\n-        long logId;\n-\n-        private int status;\n-\n-        private String name;\n-\n-        Transaction(TransactionStore store, int transactionId, int status,\n-                String name, long logId) {\n-            this.store = store;\n-            this.transactionId = transactionId;\n-            this.status = status;\n-            this.name = name;\n-            this.logId = logId;\n-        }\n-\n-        public int getId() {\n-            return transactionId;\n-        }\n-\n-        public int getStatus() {\n-            return status;\n-        }\n-\n-        void setStatus(int status) {\n-            this.status = status;\n-        }\n-\n-        public void setName(String name) {\n-            checkNotClosed();\n-            this.name = name;\n-            store.storeTransaction(this);\n-        }\n-\n-        public String getName() {\n-            return name;\n-        }\n-\n-        /**\n-         * Create a new savepoint.\n-         *\n-         * @return the savepoint id\n-         */\n-        public long setSavepoint() {\n-            return logId;\n-        }\n-\n-        /**\n-         * Add a log entry.\n-         *\n-         * @param mapId the map id\n-         * @param key the key\n-         * @param oldValue the old value\n-         */\n-        void log(int mapId, Object key, Object oldValue) {\n-            store.log(this, logId, mapId, key, oldValue);\n-            // only increment the log id if logging was successful\n-            logId++;\n-        }\n-\n-        /**\n-         * Remove the last log entry.\n-         */\n-        void logUndo() {\n-            store.logUndo(this, --logId);\n-        }\n-\n-        /**\n-         * Open a data map.\n-         *\n-         * @param <K> the key type\n-         * @param <V> the value type\n-         * @param name the name of the map\n-         * @return the transaction map\n-         */\n-        public <K, V> TransactionMap<K, V> openMap(String name) {\n-            return openMap(name, null, null);\n-        }\n+    public boolean containsKey(K key) {\n+      return get(key) != null;\n+    }\n \n-        /**\n-         * Open the map to store the data.\n-         *\n-         * @param <K> the key type\n-         * @param <V> the value type\n-         * @param name the name of the map\n-         * @param keyType the key data type\n-         * @param valueType the value data type\n-         * @return the transaction map\n-         */\n-        public <K, V> TransactionMap<K, V> openMap(String name,\n-                DataType keyType, DataType valueType) {\n-            checkNotClosed();\n-            MVMap<K, VersionedValue> map = store.openMap(name, keyType,\n-                    valueType);\n-            int mapId = map.getId();\n-            return new TransactionMap<>(this, map, mapId);\n-        }\n+    /**\n+     * Get the value for the given key.\n+     *\n+     * @param key      the key\n+     * @param maxLogId the maximum log id\n+     * @return the value or null\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public V get(K key, long maxLogId) {\n+      VersionedValue data = getValue(key, maxLogId);\n+      return data == null ? null : (V) data.value;\n+    }\n \n-        /**\n-         * Open the transactional version of the given map.\n-         *\n-         * @param <K> the key type\n-         * @param <V> the value type\n-         * @param map the base map\n-         * @return the transactional map\n-         */\n-        public <K, V> TransactionMap<K, V> openMap(\n-                MVMap<K, VersionedValue> map) {\n-            checkNotClosed();\n-            int mapId = map.getId();\n-            return new TransactionMap<>(this, map, mapId);\n-        }\n+    /**\n+     * Whether the entry for this key was added or removed from this\n+     * session.\n+     *\n+     * @param key the key\n+     * @return true if yes\n+     */\n+    public boolean isSameTransaction(K key) {\n+      VersionedValue data = map.get(key);\n+      if (data == null) {\n+        // doesn't exist or deleted by a committed transaction\n+        return false;\n+      }\n+      int tx = getTransactionId(data.operationId);\n+      return tx == transaction.transactionId;\n+    }\n \n-        /**\n-         * Prepare the transaction. Afterwards, the transaction can only be\n-         * committed or rolled back.\n-         */\n-        public void prepare() {\n-            checkNotClosed();\n-            status = STATUS_PREPARED;\n-            store.storeTransaction(this);\n-        }\n+    private VersionedValue getValue(K key, long maxLog) {\n+      transaction.store.rwLock.readLock().lock();\n+      try {\n+        VersionedValue data = map.get(key);\n+        return getValue(key, maxLog, data);\n+      } finally {\n+        transaction.store.rwLock.readLock().unlock();\n+      }\n+    }\n \n-        /**\n-         * Commit the transaction. Afterwards, this transaction is closed.\n-         */\n-        public void commit() {\n-            checkNotClosed();\n-            store.commit(this, logId);\n-        }\n+    /**\n+     * Get the versioned value for the given key.\n+     *\n+     * @param key    the key\n+     * @param maxLog the maximum log id of the entry\n+     * @param data   the value stored in the main map\n+     * @return the value\n+     */\n+    VersionedValue getValue(K key, long maxLog, VersionedValue data) {\n+      while (true) {\n+        if (data == null) {\n+          // doesn't exist or deleted by a committed transaction\n+          return null;\n+        }\n+        long id = data.operationId;\n+        if (id == 0) {\n+          // it is committed\n+          return data;\n+        }\n+        int tx = getTransactionId(id);\n+        if (tx == transaction.transactionId) {\n+          // added by this transaction\n+          if (getLogId(id) < maxLog) {\n+            return data;\n+          }\n+        }\n+        // get the value before the uncommitted transaction\n+        Object[] d;\n+        d = transaction.store.undoLog.get(id);\n+        if (d == null) {\n+          if (transaction.store.store.isReadOnly()) {\n+            // uncommitted transaction for a read-only store\n+            return null;\n+          }\n+          // this entry should be committed or rolled back\n+          // in the meantime (the transaction might still be open)\n+          // or it might be changed again in a different\n+          // transaction (possibly one with the same id)\n+          data = map.get(key);\n+        } else {\n+          data = (VersionedValue) d[2];\n+        }\n+      }\n+    }\n \n-        /**\n-         * Roll back to the given savepoint. This is only allowed if the\n-         * transaction is open.\n-         *\n-         * @param savepointId the savepoint id\n-         */\n-        public void rollbackToSavepoint(long savepointId) {\n-            checkNotClosed();\n-            store.rollbackTo(this, logId, savepointId);\n-            logId = savepointId;\n-        }\n+    /**\n+     * Check whether this map is closed.\n+     *\n+     * @return true if closed\n+     */\n+    public boolean isClosed() {\n+      return map.isClosed();\n+    }\n \n-        /**\n-         * Roll the transaction back. Afterwards, this transaction is closed.\n-         */\n-        public void rollback() {\n-            checkNotClosed();\n-            store.rollbackTo(this, logId, 0);\n-            store.endTransaction(this);\n-        }\n+    /**\n+     * Clear the map.\n+     */\n+    public void clear() {\n+      // TODO truncate transactionally?\n+      map.clear();\n+    }\n \n-        /**\n-         * Get the list of changes, starting with the latest change, up to the\n-         * given savepoint (in reverse order than they occurred). The value of\n-         * the change is the value before the change was applied.\n-         *\n-         * @param savepointId the savepoint id, 0 meaning the beginning of the\n-         *            transaction\n-         * @return the changes\n-         */\n-        public Iterator<Change> getChanges(long savepointId) {\n-            return store.getChanges(this, logId, savepointId);\n-        }\n+    /**\n+     * Get the first key.\n+     *\n+     * @return the first key, or null if empty\n+     */\n+    public K firstKey() {\n+      Iterator<K> it = keyIterator(null);\n+      return it.hasNext() ? it.next() : null;\n+    }\n \n-        /**\n-         * Check whether this transaction is open or prepared.\n-         */\n-        void checkNotClosed() {\n-            if (status == STATUS_CLOSED) {\n-                throw DataUtils.newIllegalStateException(\n-                        DataUtils.ERROR_CLOSED, \"Transaction is closed\");\n-            }\n+    /**\n+     * Get the last key.\n+     *\n+     * @return the last key, or null if empty\n+     */\n+    public K lastKey() {\n+      K k = map.lastKey();\n+      while (true) {\n+        if (k == null) {\n+          return null;\n         }\n-\n-        /**\n-         * Remove the map.\n-         *\n-         * @param map the map\n-         */\n-        public <K, V> void removeMap(TransactionMap<K, V> map) {\n-            store.removeMap(map);\n+        if (get(k) != null) {\n+          return k;\n         }\n+        k = map.lowerKey(k);\n+      }\n+    }\n \n-        @Override\n-        public String toString() {\n-            return \"\" + transactionId;\n-        }\n+    /**\n+     * Get the smallest key that is larger than the given key, or null if no\n+     * such key exists.\n+     *\n+     * @param key the key (may not be null)\n+     * @return the result\n+     */\n+    public K higherKey(K key) {\n+      while (true) {\n+        K k = map.higherKey(key);\n+        if (k == null || get(k) != null) {\n+          return k;\n+        }\n+        key = k;\n+      }\n+    }\n \n+    /**\n+     * Get one of the previous or next keys. There might be no value\n+     * available for the returned key.\n+     *\n+     * @param key    the key (may not be null)\n+     * @param offset how many keys to skip (-1 for previous, 1 for next)\n+     * @return the key\n+     */\n+    public K relativeKey(K key, long offset) {\n+      K k = offset > 0 ? map.ceilingKey(key) : map.floorKey(key);\n+      if (k == null) {\n+        return k;\n+      }\n+      long index = map.getKeyIndex(k);\n+      return map.getKey(index + offset);\n     }\n \n     /**\n-     * A map that supports transactions.\n+     * Get the largest key that is smaller than the given key, or null if no\n+     * such key exists.\n      *\n-     * @param <K> the key type\n-     * @param <V> the value type\n+     * @param key the key (may not be null)\n+     * @return the result\n      */\n-    public static class TransactionMap<K, V> {\n-\n-        /**\n-         * The map id.\n-         */\n-        final int mapId;\n-\n-        /**\n-         * If a record was read that was updated by this transaction, and the\n-         * update occurred before this log id, the older version is read. This\n-         * is so that changes are not immediately visible, to support statement\n-         * processing (for example \"update test set id = id + 1\").\n-         */\n-        long readLogId = Long.MAX_VALUE;\n-\n-        /**\n-         * The map used for writing (the latest version).\n-         * <p>\n-         * Key: key the key of the data.\n-         * Value: { transactionId, oldVersion, value }\n-         */\n-        final MVMap<K, VersionedValue> map;\n-\n-        private Transaction transaction;\n-\n-        TransactionMap(Transaction transaction, MVMap<K, VersionedValue> map,\n-                int mapId) {\n-            this.transaction = transaction;\n-            this.map = map;\n-            this.mapId = mapId;\n-        }\n+    public K lowerKey(K key) {\n+      while (true) {\n+        K k = map.lowerKey(key);\n+        if (k == null || get(k) != null) {\n+          return k;\n+        }\n+        key = k;\n+      }\n+    }\n \n-        /**\n-         * Set the savepoint. Afterwards, reads are based on the specified\n-         * savepoint.\n-         *\n-         * @param savepoint the savepoint\n-         */\n-        public void setSavepoint(long savepoint) {\n-            this.readLogId = savepoint;\n-        }\n+    /**\n+     * Iterate over keys.\n+     *\n+     * @param from the first key to return\n+     * @return the iterator\n+     */\n+    public Iterator<K> keyIterator(K from) {\n+      return keyIterator(from, false);\n+    }\n \n-        /**\n-         * Get a clone of this map for the given transaction.\n-         *\n-         * @param transaction the transaction\n-         * @param savepoint the savepoint\n-         * @return the map\n-         */\n-        public TransactionMap<K, V> getInstance(Transaction transaction,\n-                long savepoint) {\n-            TransactionMap<K, V> m =\n-                    new TransactionMap<>(transaction, map, mapId);\n-            m.setSavepoint(savepoint);\n-            return m;\n-        }\n+    /**\n+     * Iterate over keys.\n+     *\n+     * @param from               the first key to return\n+     * @param includeUncommitted whether uncommitted entries should be\n+     *                           included\n+     * @return the iterator\n+     */\n+    public Iterator<K> keyIterator(final K from, final boolean includeUncommitted) {\n+      return new Iterator<K>() {\n+        private K currentKey = from;\n+        private Cursor<K, VersionedValue> cursor = map.cursor(currentKey);\n \n-        /**\n-         * Get the size of the raw map. This includes uncommitted entries, and\n-         * transiently removed entries, so it is the maximum number of entries.\n-         *\n-         * @return the maximum size\n-         */\n-        public long sizeAsLongMax() {\n-            return map.sizeAsLong();\n+        {\n+          fetchNext();\n         }\n \n-        /**\n-         * Get the size of the map as seen by this transaction.\n-         *\n-         * @return the size\n-         */\n-        public long sizeAsLong() {\n-            transaction.store.rwLock.readLock().lock();\n+        private void fetchNext() {\n+          while (cursor.hasNext()) {\n+            K k;\n             try {\n-                long sizeRaw = map.sizeAsLong();\n-                MVMap<Long, Object[]> undo = transaction.store.undoLog;\n-                long undoLogSize;\n-                synchronized (undo) {\n-                    undoLogSize = undo.sizeAsLong();\n-                }\n-                if (undoLogSize == 0) {\n-                    return sizeRaw;\n-                }\n-                if (undoLogSize > sizeRaw) {\n-                    // the undo log is larger than the map -\n-                    // count the entries of the map\n-                    long size = 0;\n-                    Cursor<K, VersionedValue> cursor = map.cursor(null);\n-                    while (cursor.hasNext()) {\n-                        VersionedValue data;\n-                        K key = cursor.next();\n-                        data = getValue(key, readLogId, cursor.getValue());\n-                        if (data != null && data.value != null) {\n-                            size++;\n-                        }\n-                    }\n-                    return size;\n+              k = cursor.next();\n+            } catch (IllegalStateException e) {\n+              // TODO this is a bit ugly\n+              if (DataUtils.getErrorCode(e.getMessage()) ==\n+                  DataUtils.ERROR_CHUNK_NOT_FOUND) {\n+                cursor = map.cursor(currentKey);\n+                // we (should) get the current key again,\n+                // we need to ignore that one\n+                if (!cursor.hasNext()) {\n+                  break;\n                 }\n-                // the undo log is smaller than the map -\n-                // scan the undo log and subtract invisible entries\n-                synchronized (undo) {\n-                    // re-fetch in case any transaction was committed now\n-                    long size = map.sizeAsLong();\n-                    MVMap<Object, Integer> temp = transaction.store\n-                            .createTempMap();\n-                    try {\n-                        for (Entry<Long, Object[]> e : undo.entrySet()) {\n-                            Object[] op = e.getValue();\n-                            int m = (Integer) op[0];\n-                            if (m != mapId) {\n-                                // a different map - ignore\n-                                continue;\n-                            }\n-                            @SuppressWarnings(\"unchecked\")\n-                            K key = (K) op[1];\n-                            if (get(key) == null) {\n-                                Integer old = temp.put(key, 1);\n-                                // count each key only once (there might be\n-                                // multiple\n-                                // changes for the same key)\n-                                if (old == null) {\n-                                    size--;\n-                                }\n-                            }\n-                        }\n-                    } finally {\n-                        transaction.store.store.removeMap(temp);\n-                    }\n-                    return size;\n+                cursor.next();\n+                if (!cursor.hasNext()) {\n+                  break;\n                 }\n-            } finally {\n-                transaction.store.rwLock.readLock().unlock();\n+                k = cursor.next();\n+              } else {\n+                throw e;\n+              }\n             }\n-        }\n-\n-        /**\n-         * Remove an entry.\n-         * <p>\n-         * If the row is locked, this method will retry until the row could be\n-         * updated or until a lock timeout.\n-         *\n-         * @param key the key\n-         * @throws IllegalStateException if a lock timeout occurs\n-         */\n-        public V remove(K key) {\n-            return set(key, null);\n-        }\n-\n-        /**\n-         * Update the value for the given key.\n-         * <p>\n-         * If the row is locked, this method will retry until the row could be\n-         * updated or until a lock timeout.\n-         *\n-         * @param key the key\n-         * @param value the new value (not null)\n-         * @return the old value\n-         * @throws IllegalStateException if a lock timeout occurs\n-         */\n-        public V put(K key, V value) {\n-            DataUtils.checkArgument(value != null, \"The value may not be null\");\n-            return set(key, value);\n-        }\n-\n-        /**\n-         * Update the value for the given key, without adding an undo log entry.\n-         *\n-         * @param key the key\n-         * @param value the value\n-         * @return the old value\n-         */\n-        @SuppressWarnings(\"unchecked\")\n-        public V putCommitted(K key, V value) {\n-            DataUtils.checkArgument(value != null, \"The value may not be null\");\n-            VersionedValue newValue = new VersionedValue();\n-            newValue.value = value;\n-            VersionedValue oldValue = map.put(key, newValue);\n-            return (V) (oldValue == null ? null : oldValue.value);\n-        }\n-\n-        private V set(K key, V value) {\n-            transaction.checkNotClosed();\n-            V old = get(key);\n-            boolean ok = trySet(key, value, false);\n-            if (ok) {\n-                return old;\n+            currentKey = k;\n+            if (includeUncommitted) {\n+              return;\n             }\n-            throw DataUtils.newIllegalStateException(\n-                    DataUtils.ERROR_TRANSACTION_LOCKED, \"Entry is locked\");\n-        }\n-\n-        /**\n-         * Try to remove the value for the given key.\n-         * <p>\n-         * This will fail if the row is locked by another transaction (that\n-         * means, if another open transaction changed the row).\n-         *\n-         * @param key the key\n-         * @return whether the entry could be removed\n-         */\n-        public boolean tryRemove(K key) {\n-            return trySet(key, null, false);\n-        }\n-\n-        /**\n-         * Try to update the value for the given key.\n-         * <p>\n-         * This will fail if the row is locked by another transaction (that\n-         * means, if another open transaction changed the row).\n-         *\n-         * @param key the key\n-         * @param value the new value\n-         * @return whether the entry could be updated\n-         */\n-        public boolean tryPut(K key, V value) {\n-            DataUtils.checkArgument(value != null, \"The value may not be null\");\n-            return trySet(key, value, false);\n-        }\n-\n-        /**\n-         * Try to set or remove the value. When updating only unchanged entries,\n-         * then the value is only changed if it was not changed after opening\n-         * the map.\n-         *\n-         * @param key the key\n-         * @param value the new value (null to remove the value)\n-         * @param onlyIfUnchanged only set the value if it was not changed (by\n-         *            this or another transaction) since the map was opened\n-         * @return true if the value was set, false if there was a concurrent\n-         *         update\n-         */\n-        public boolean trySet(K key, V value, boolean onlyIfUnchanged) {\n-            VersionedValue current = map.get(key);\n-            if (onlyIfUnchanged) {\n-                VersionedValue old = getValue(key, readLogId);\n-                if (!map.areValuesEqual(old, current)) {\n-                    long tx = getTransactionId(current.operationId);\n-                    if (tx == transaction.transactionId) {\n-                        if (value == null) {\n-                            // ignore removing an entry\n-                            // if it was added or changed\n-                            // in the same statement\n-                            return true;\n-                        } else if (current.value == null) {\n-                            // add an entry that was removed\n-                            // in the same statement\n-                        } else {\n-                            return false;\n-                        }\n-                    } else {\n-                        return false;\n-                    }\n-                }\n-            }\n-            VersionedValue newValue = new VersionedValue();\n-            newValue.operationId = getOperationId(\n-                    transaction.transactionId, transaction.logId);\n-            newValue.value = value;\n-            if (current == null) {\n-                // a new value\n-                transaction.log(mapId, key, current);\n-                VersionedValue old = map.putIfAbsent(key, newValue);\n-                if (old != null) {\n-                    transaction.logUndo();\n-                    return false;\n-                }\n-                return true;\n-            }\n-            long id = current.operationId;\n-            if (id == 0) {\n-                // committed\n-                transaction.log(mapId, key, current);\n-                // the transaction is committed:\n-                // overwrite the value\n-                if (!map.replace(key, current, newValue)) {\n-                    // somebody else was faster\n-                    transaction.logUndo();\n-                    return false;\n-                }\n-                return true;\n-            }\n-            int tx = getTransactionId(current.operationId);\n-            if (tx == transaction.transactionId) {\n-                // added or updated by this transaction\n-                transaction.log(mapId, key, current);\n-                if (!map.replace(key, current, newValue)) {\n-                    // strange, somebody overwrote the value\n-                    // even though the change was not committed\n-                    transaction.logUndo();\n-                    return false;\n-                }\n-                return true;\n+            if (containsKey(k)) {\n+              return;\n             }\n-            // the transaction is not yet committed\n-            return false;\n+          }\n+          currentKey = null;\n         }\n \n-        /**\n-         * Get the value for the given key at the time when this map was opened.\n-         *\n-         * @param key the key\n-         * @return the value or null\n-         */\n-        public V get(K key) {\n-            return get(key, readLogId);\n+        @Override\n+        public boolean hasNext() {\n+          return currentKey != null;\n         }\n \n-        /**\n-         * Get the most recent value for the given key.\n-         *\n-         * @param key the key\n-         * @return the value or null\n-         */\n-        public V getLatest(K key) {\n-            return get(key, Long.MAX_VALUE);\n+        @Override\n+        public K next() {\n+          K result = currentKey;\n+          fetchNext();\n+          return result;\n         }\n \n-        /**\n-         * Whether the map contains the key.\n-         *\n-         * @param key the key\n-         * @return true if the map contains an entry for this key\n-         */\n-        public boolean containsKey(K key) {\n-            return get(key) != null;\n+        @Override\n+        public void remove() {\n+          throw DataUtils.newUnsupportedOperationException(\n+              \"Removing is not supported\");\n         }\n+      };\n+    }\n \n-        /**\n-         * Get the value for the given key.\n-         *\n-         * @param key the key\n-         * @param maxLogId the maximum log id\n-         * @return the value or null\n-         */\n-        @SuppressWarnings(\"unchecked\")\n-        public V get(K key, long maxLogId) {\n-            VersionedValue data = getValue(key, maxLogId);\n-            return data == null ? null : (V) data.value;\n-        }\n+    /**\n+     * Iterate over entries.\n+     *\n+     * @param from the first key to return\n+     * @return the iterator\n+     */\n+    public Iterator<Entry<K, V>> entryIterator(final K from) {\n+      return new Iterator<Entry<K, V>>() {\n+        private Entry<K, V> current;\n+        private K currentKey = from;\n+        private Cursor<K, VersionedValue> cursor = map.cursor(currentKey);\n \n-        /**\n-         * Whether the entry for this key was added or removed from this\n-         * session.\n-         *\n-         * @param key the key\n-         * @return true if yes\n-         */\n-        public boolean isSameTransaction(K key) {\n-            VersionedValue data = map.get(key);\n-            if (data == null) {\n-                // doesn't exist or deleted by a committed transaction\n-                return false;\n-            }\n-            int tx = getTransactionId(data.operationId);\n-            return tx == transaction.transactionId;\n+        {\n+          fetchNext();\n         }\n \n-        private VersionedValue getValue(K key, long maxLog) {\n+        private void fetchNext() {\n+          while (cursor.hasNext()) {\n             transaction.store.rwLock.readLock().lock();\n             try {\n-                VersionedValue data = map.get(key);\n-                return getValue(key, maxLog, data);\n-            } finally {\n-                transaction.store.rwLock.readLock().unlock();\n-            }\n-        }\n-\n-        /**\n-         * Get the versioned value for the given key.\n-         *\n-         * @param key the key\n-         * @param maxLog the maximum log id of the entry\n-         * @param data the value stored in the main map\n-         * @return the value\n-         */\n-        VersionedValue getValue(K key, long maxLog, VersionedValue data) {\n-            while (true) {\n-                if (data == null) {\n-                    // doesn't exist or deleted by a committed transaction\n-                    return null;\n-                }\n-                long id = data.operationId;\n-                if (id == 0) {\n-                    // it is committed\n-                    return data;\n-                }\n-                int tx = getTransactionId(id);\n-                if (tx == transaction.transactionId) {\n-                    // added by this transaction\n-                    if (getLogId(id) < maxLog) {\n-                        return data;\n-                    }\n-                }\n-                // get the value before the uncommitted transaction\n-                Object[] d;\n-                d = transaction.store.undoLog.get(id);\n-                if (d == null) {\n-                    if (transaction.store.store.isReadOnly()) {\n-                        // uncommitted transaction for a read-only store\n-                        return null;\n-                    }\n-                    // this entry should be committed or rolled back\n-                    // in the meantime (the transaction might still be open)\n-                    // or it might be changed again in a different\n-                    // transaction (possibly one with the same id)\n-                    data = map.get(key);\n+              K k;\n+              try {\n+                k = cursor.next();\n+              } catch (IllegalStateException e) {\n+                // TODO this is a bit ugly\n+                if (DataUtils.getErrorCode(e.getMessage()) ==\n+                    DataUtils.ERROR_CHUNK_NOT_FOUND) {\n+                  cursor = map.cursor(currentKey);\n+                  // we (should) get the current key again,\n+                  // we need to ignore that one\n+                  if (!cursor.hasNext()) {\n+                    break;\n+                  }\n+                  cursor.next();\n+                  if (!cursor.hasNext()) {\n+                    break;\n+                  }\n+                  k = cursor.next();\n                 } else {\n-                    data = (VersionedValue) d[2];\n+                  throw e;\n                 }\n+              }\n+              final K key = k;\n+              VersionedValue data = cursor.getValue();\n+              data = getValue(key, readLogId, data);\n+              if (data != null && data.value != null) {\n+                @SuppressWarnings(\"unchecked\") final V value = (V) data.value;\n+                current = new DataUtils.MapEntry<>(key, value);\n+                currentKey = key;\n+                return;\n+              }\n+            } finally {\n+              transaction.store.rwLock.readLock().unlock();\n             }\n+          }\n+          current = null;\n+          currentKey = null;\n         }\n \n-        /**\n-         * Check whether this map is closed.\n-         *\n-         * @return true if closed\n-         */\n-        public boolean isClosed() {\n-            return map.isClosed();\n+        @Override\n+        public boolean hasNext() {\n+          return current != null;\n         }\n \n-        /**\n-         * Clear the map.\n-         */\n-        public void clear() {\n-            // TODO truncate transactionally?\n-            map.clear();\n+        @Override\n+        public Entry<K, V> next() {\n+          Entry<K, V> result = current;\n+          fetchNext();\n+          return result;\n         }\n \n-        /**\n-         * Get the first key.\n-         *\n-         * @return the first key, or null if empty\n-         */\n-        public K firstKey() {\n-            Iterator<K> it = keyIterator(null);\n-            return it.hasNext() ? it.next() : null;\n+        @Override\n+        public void remove() {\n+          throw DataUtils.newUnsupportedOperationException(\n+              \"Removing is not supported\");\n         }\n+      };\n \n-        /**\n-         * Get the last key.\n-         *\n-         * @return the last key, or null if empty\n-         */\n-        public K lastKey() {\n-            K k = map.lastKey();\n-            while (true) {\n-                if (k == null) {\n-                    return null;\n-                }\n-                if (get(k) != null) {\n-                    return k;\n-                }\n-                k = map.lowerKey(k);\n-            }\n-        }\n+    }\n \n-        /**\n-         * Get the smallest key that is larger than the given key, or null if no\n-         * such key exists.\n-         *\n-         * @param key the key (may not be null)\n-         * @return the result\n-         */\n-        public K higherKey(K key) {\n-            while (true) {\n-                K k = map.higherKey(key);\n-                if (k == null || get(k) != null) {\n-                    return k;\n-                }\n-                key = k;\n-            }\n-        }\n+    /**\n+     * Iterate over keys.\n+     *\n+     * @param iterator           the iterator to wrap\n+     * @param includeUncommitted whether uncommitted entries should be\n+     *                           included\n+     * @return the iterator\n+     */\n+    public Iterator<K> wrapIterator(final Iterator<K> iterator,\n+                                    final boolean includeUncommitted) {\n+      // TODO duplicate code for wrapIterator and entryIterator\n+      return new Iterator<K>() {\n+        private K current;\n \n-        /**\n-         * Get one of the previous or next keys. There might be no value\n-         * available for the returned key.\n-         *\n-         * @param key the key (may not be null)\n-         * @param offset how many keys to skip (-1 for previous, 1 for next)\n-         * @return the key\n-         */\n-        public K relativeKey(K key, long offset) {\n-            K k = offset > 0 ? map.ceilingKey(key) : map.floorKey(key);\n-            if (k == null) {\n-                return k;\n-            }\n-            long index = map.getKeyIndex(k);\n-            return map.getKey(index + offset);\n+        {\n+          fetchNext();\n         }\n \n-        /**\n-         * Get the largest key that is smaller than the given key, or null if no\n-         * such key exists.\n-         *\n-         * @param key the key (may not be null)\n-         * @return the result\n-         */\n-        public K lowerKey(K key) {\n-            while (true) {\n-                K k = map.lowerKey(key);\n-                if (k == null || get(k) != null) {\n-                    return k;\n-                }\n-                key = k;\n+        private void fetchNext() {\n+          while (iterator.hasNext()) {\n+            current = iterator.next();\n+            if (includeUncommitted) {\n+              return;\n+            }\n+            if (containsKey(current)) {\n+              return;\n             }\n+          }\n+          current = null;\n         }\n \n-        /**\n-         * Iterate over keys.\n-         *\n-         * @param from the first key to return\n-         * @return the iterator\n-         */\n-        public Iterator<K> keyIterator(K from) {\n-            return keyIterator(from, false);\n+        @Override\n+        public boolean hasNext() {\n+          return current != null;\n         }\n \n-        /**\n-         * Iterate over keys.\n-         *\n-         * @param from the first key to return\n-         * @param includeUncommitted whether uncommitted entries should be\n-         *            included\n-         * @return the iterator\n-         */\n-        public Iterator<K> keyIterator(final K from, final boolean includeUncommitted) {\n-            return new Iterator<K>() {\n-                private K currentKey = from;\n-                private Cursor<K, VersionedValue> cursor = map.cursor(currentKey);\n-\n-                {\n-                    fetchNext();\n-                }\n-\n-                private void fetchNext() {\n-                    while (cursor.hasNext()) {\n-                        K k;\n-                        try {\n-                            k = cursor.next();\n-                        } catch (IllegalStateException e) {\n-                            // TODO this is a bit ugly\n-                            if (DataUtils.getErrorCode(e.getMessage()) ==\n-                                    DataUtils.ERROR_CHUNK_NOT_FOUND) {\n-                                cursor = map.cursor(currentKey);\n-                                // we (should) get the current key again,\n-                                // we need to ignore that one\n-                                if (!cursor.hasNext()) {\n-                                    break;\n-                                }\n-                                cursor.next();\n-                                if (!cursor.hasNext()) {\n-                                    break;\n-                                }\n-                                k = cursor.next();\n-                            } else {\n-                                throw e;\n-                            }\n-                        }\n-                        currentKey = k;\n-                        if (includeUncommitted) {\n-                            return;\n-                        }\n-                        if (containsKey(k)) {\n-                            return;\n-                        }\n-                    }\n-                    currentKey = null;\n-                }\n-\n-                @Override\n-                public boolean hasNext() {\n-                    return currentKey != null;\n-                }\n-\n-                @Override\n-                public K next() {\n-                    K result = currentKey;\n-                    fetchNext();\n-                    return result;\n-                }\n-\n-                @Override\n-                public void remove() {\n-                    throw DataUtils.newUnsupportedOperationException(\n-                            \"Removing is not supported\");\n-                }\n-            };\n+        @Override\n+        public K next() {\n+          K result = current;\n+          fetchNext();\n+          return result;\n         }\n \n-        /**\n-         * Iterate over entries.\n-         *\n-         * @param from the first key to return\n-         * @return the iterator\n-         */\n-        public Iterator<Entry<K, V>> entryIterator(final K from) {\n-            return new Iterator<Entry<K, V>>() {\n-                private Entry<K, V> current;\n-                private K currentKey = from;\n-                private Cursor<K, VersionedValue> cursor = map.cursor(currentKey);\n-\n-                {\n-                    fetchNext();\n-                }\n-\n-                private void fetchNext() {\n-                    while (cursor.hasNext()) {\n-                        transaction.store.rwLock.readLock().lock();\n-                        try {\n-                            K k;\n-                            try {\n-                                k = cursor.next();\n-                            } catch (IllegalStateException e) {\n-                                // TODO this is a bit ugly\n-                                if (DataUtils.getErrorCode(e.getMessage()) ==\n-                                        DataUtils.ERROR_CHUNK_NOT_FOUND) {\n-                                    cursor = map.cursor(currentKey);\n-                                    // we (should) get the current key again,\n-                                    // we need to ignore that one\n-                                    if (!cursor.hasNext()) {\n-                                        break;\n-                                    }\n-                                    cursor.next();\n-                                    if (!cursor.hasNext()) {\n-                                        break;\n-                                    }\n-                                    k = cursor.next();\n-                                } else {\n-                                    throw e;\n-                                }\n-                            }\n-                            final K key = k;\n-                            VersionedValue data = cursor.getValue();\n-                            data = getValue(key, readLogId, data);\n-                            if (data != null && data.value != null) {\n-                                @SuppressWarnings(\"unchecked\")\n-                                final V value = (V) data.value;\n-                                current = new DataUtils.MapEntry<>(key, value);\n-                                currentKey = key;\n-                                return;\n-                            }\n-                        } finally {\n-                            transaction.store.rwLock.readLock().unlock();\n-                        }\n-                    }\n-                    current = null;\n-                    currentKey = null;\n-                }\n-\n-                @Override\n-                public boolean hasNext() {\n-                    return current != null;\n-                }\n-\n-                @Override\n-                public Entry<K, V> next() {\n-                    Entry<K, V> result = current;\n-                    fetchNext();\n-                    return result;\n-                }\n-\n-                @Override\n-                public void remove() {\n-                    throw DataUtils.newUnsupportedOperationException(\n-                            \"Removing is not supported\");\n-                }\n-            };\n-\n+        @Override\n+        public void remove() {\n+          throw DataUtils.newUnsupportedOperationException(\n+              \"Removing is not supported\");\n         }\n+      };\n+    }\n \n-        /**\n-         * Iterate over keys.\n-         *\n-         * @param iterator the iterator to wrap\n-         * @param includeUncommitted whether uncommitted entries should be\n-         *            included\n-         * @return the iterator\n-         */\n-        public Iterator<K> wrapIterator(final Iterator<K> iterator,\n-                final boolean includeUncommitted) {\n-            // TODO duplicate code for wrapIterator and entryIterator\n-            return new Iterator<K>() {\n-                private K current;\n-\n-                {\n-                    fetchNext();\n-                }\n-\n-                private void fetchNext() {\n-                    while (iterator.hasNext()) {\n-                        current = iterator.next();\n-                        if (includeUncommitted) {\n-                            return;\n-                        }\n-                        if (containsKey(current)) {\n-                            return;\n-                        }\n-                    }\n-                    current = null;\n-                }\n-\n-                @Override\n-                public boolean hasNext() {\n-                    return current != null;\n-                }\n-\n-                @Override\n-                public K next() {\n-                    K result = current;\n-                    fetchNext();\n-                    return result;\n-                }\n+    public Transaction getTransaction() {\n+      return transaction;\n+    }\n \n-                @Override\n-                public void remove() {\n-                    throw DataUtils.newUnsupportedOperationException(\n-                            \"Removing is not supported\");\n-                }\n-            };\n-        }\n+    public DataType getKeyType() {\n+      return map.getKeyType();\n+    }\n \n-        public Transaction getTransaction() {\n-            return transaction;\n-        }\n+  }\n \n-        public DataType getKeyType() {\n-            return map.getKeyType();\n-        }\n+  /**\n+   * A versioned value (possibly null). It contains a pointer to the old\n+   * value, and the value itself.\n+   */\n+  static class VersionedValue {\n \n-    }\n+    /**\n+     * The operation id.\n+     */\n+    public long operationId;\n \n     /**\n-     * A versioned value (possibly null). It contains a pointer to the old\n-     * value, and the value itself.\n+     * The value.\n      */\n-    static class VersionedValue {\n+    public Object value;\n+\n+    @Override\n+    public String toString() {\n+      return value + (operationId == 0 ? \"\" : (\n+          \" \" +\n+              getTransactionId(operationId) + \"/\" +\n+              getLogId(operationId)));\n+    }\n \n-        /**\n-         * The operation id.\n-         */\n-        public long operationId;\n+  }\n \n-        /**\n-         * The value.\n-         */\n-        public Object value;\n+  /**\n+   * The value type for a versioned value.\n+   */\n+  public static class VersionedValueType implements DataType {\n \n-        @Override\n-        public String toString() {\n-            return value + (operationId == 0 ? \"\" : (\n-                    \" \" +\n-                    getTransactionId(operationId) + \"/\" +\n-                    getLogId(operationId)));\n-        }\n+    private final DataType valueType;\n \n+    VersionedValueType(DataType valueType) {\n+      this.valueType = valueType;\n     }\n \n-    /**\n-     * The value type for a versioned value.\n-     */\n-    public static class VersionedValueType implements DataType {\n+    @Override\n+    public int getMemory(Object obj) {\n+      VersionedValue v = (VersionedValue) obj;\n+      return valueType.getMemory(v.value) + 8;\n+    }\n \n-        private final DataType valueType;\n+    @Override\n+    public int compare(Object aObj, Object bObj) {\n+      if (aObj == bObj) {\n+        return 0;\n+      }\n+      VersionedValue a = (VersionedValue) aObj;\n+      VersionedValue b = (VersionedValue) bObj;\n+      long comp = a.operationId - b.operationId;\n+      if (comp == 0) {\n+        return valueType.compare(a.value, b.value);\n+      }\n+      return Long.signum(comp);\n+    }\n \n-        VersionedValueType(DataType valueType) {\n-            this.valueType = valueType;\n-        }\n+    @Override\n+    public void read(ByteBuffer buff, Object[] obj, int len, boolean key) {\n+      if (buff.get() == 0) {\n+        // fast path (no op ids or null entries)\n+        for (int i = 0; i < len; i++) {\n+          VersionedValue v = new VersionedValue();\n+          v.value = valueType.read(buff);\n+          obj[i] = v;\n+        }\n+      } else {\n+        // slow path (some entries may be null)\n+        for (int i = 0; i < len; i++) {\n+          obj[i] = read(buff);\n+        }\n+      }\n+    }\n \n-        @Override\n-        public int getMemory(Object obj) {\n-            VersionedValue v = (VersionedValue) obj;\n-            return valueType.getMemory(v.value) + 8;\n-        }\n+    @Override\n+    public Object read(ByteBuffer buff) {\n+      VersionedValue v = new VersionedValue();\n+      v.operationId = DataUtils.readVarLong(buff);\n+      if (buff.get() == 1) {\n+        v.value = valueType.read(buff);\n+      }\n+      return v;\n+    }\n \n-        @Override\n-        public int compare(Object aObj, Object bObj) {\n-            if (aObj == bObj) {\n-                return 0;\n-            }\n-            VersionedValue a = (VersionedValue) aObj;\n-            VersionedValue b = (VersionedValue) bObj;\n-            long comp = a.operationId - b.operationId;\n-            if (comp == 0) {\n-                return valueType.compare(a.value, b.value);\n-            }\n-            return Long.signum(comp);\n-        }\n+    @Override\n+    public void write(WriteBuffer buff, Object[] obj, int len, boolean key) {\n+      boolean fastPath = true;\n+      for (int i = 0; i < len; i++) {\n+        VersionedValue v = (VersionedValue) obj[i];\n+        if (v.operationId != 0 || v.value == null) {\n+          fastPath = false;\n+        }\n+      }\n+      if (fastPath) {\n+        buff.put((byte) 0);\n+        for (int i = 0; i < len; i++) {\n+          VersionedValue v = (VersionedValue) obj[i];\n+          valueType.write(buff, v.value);\n+        }\n+      } else {\n+        // slow path:\n+        // store op ids, and some entries may be null\n+        buff.put((byte) 1);\n+        for (int i = 0; i < len; i++) {\n+          write(buff, obj[i]);\n+        }\n+      }\n+    }\n \n-        @Override\n-        public void read(ByteBuffer buff, Object[] obj, int len, boolean key) {\n-            if (buff.get() == 0) {\n-                // fast path (no op ids or null entries)\n-                for (int i = 0; i < len; i++) {\n-                    VersionedValue v = new VersionedValue();\n-                    v.value = valueType.read(buff);\n-                    obj[i] = v;\n-                }\n-            } else {\n-                // slow path (some entries may be null)\n-                for (int i = 0; i < len; i++) {\n-                    obj[i] = read(buff);\n-                }\n-            }\n-        }\n+    @Override\n+    public void write(WriteBuffer buff, Object obj) {\n+      VersionedValue v = (VersionedValue) obj;\n+      buff.putVarLong(v.operationId);\n+      if (v.value == null) {\n+        buff.put((byte) 0);\n+      } else {\n+        buff.put((byte) 1);\n+        valueType.write(buff, v.value);\n+      }\n+    }\n \n-        @Override\n-        public Object read(ByteBuffer buff) {\n-            VersionedValue v = new VersionedValue();\n-            v.operationId = DataUtils.readVarLong(buff);\n-            if (buff.get() == 1) {\n-                v.value = valueType.read(buff);\n-            }\n-            return v;\n-        }\n+  }\n \n-        @Override\n-        public void write(WriteBuffer buff, Object[] obj, int len, boolean key) {\n-            boolean fastPath = true;\n-            for (int i = 0; i < len; i++) {\n-                VersionedValue v = (VersionedValue) obj[i];\n-                if (v.operationId != 0 || v.value == null) {\n-                    fastPath = false;\n-                }\n-            }\n-            if (fastPath) {\n-                buff.put((byte) 0);\n-                for (int i = 0; i < len; i++) {\n-                    VersionedValue v = (VersionedValue) obj[i];\n-                    valueType.write(buff, v.value);\n-                }\n-            } else {\n-                // slow path:\n-                // store op ids, and some entries may be null\n-                buff.put((byte) 1);\n-                for (int i = 0; i < len; i++) {\n-                    write(buff, obj[i]);\n-                }\n-            }\n-        }\n+  /**\n+   * A data type that contains an array of objects with the specified data\n+   * types.\n+   */\n+  public static class ArrayType implements DataType {\n \n-        @Override\n-        public void write(WriteBuffer buff, Object obj) {\n-            VersionedValue v = (VersionedValue) obj;\n-            buff.putVarLong(v.operationId);\n-            if (v.value == null) {\n-                buff.put((byte) 0);\n-            } else {\n-                buff.put((byte) 1);\n-                valueType.write(buff, v.value);\n-            }\n-        }\n+    private final int arrayLength;\n+    private final DataType[] elementTypes;\n \n+    ArrayType(DataType[] elementTypes) {\n+      this.arrayLength = elementTypes.length;\n+      this.elementTypes = elementTypes;\n     }\n \n-    /**\n-     * A data type that contains an array of objects with the specified data\n-     * types.\n-     */\n-    public static class ArrayType implements DataType {\n-\n-        private final int arrayLength;\n-        private final DataType[] elementTypes;\n-\n-        ArrayType(DataType[] elementTypes) {\n-            this.arrayLength = elementTypes.length;\n-            this.elementTypes = elementTypes;\n-        }\n-\n-        @Override\n-        public int getMemory(Object obj) {\n-            Object[] array = (Object[]) obj;\n-            int size = 0;\n-            for (int i = 0; i < arrayLength; i++) {\n-                DataType t = elementTypes[i];\n-                Object o = array[i];\n-                if (o != null) {\n-                    size += t.getMemory(o);\n-                }\n-            }\n-            return size;\n-        }\n+    @Override\n+    public int getMemory(Object obj) {\n+      Object[] array = (Object[]) obj;\n+      int size = 0;\n+      for (int i = 0; i < arrayLength; i++) {\n+        DataType t = elementTypes[i];\n+        Object o = array[i];\n+        if (o != null) {\n+          size += t.getMemory(o);\n+        }\n+      }\n+      return size;\n+    }\n \n-        @Override\n-        public int compare(Object aObj, Object bObj) {\n-            if (aObj == bObj) {\n-                return 0;\n-            }\n-            Object[] a = (Object[]) aObj;\n-            Object[] b = (Object[]) bObj;\n-            for (int i = 0; i < arrayLength; i++) {\n-                DataType t = elementTypes[i];\n-                int comp = t.compare(a[i], b[i]);\n-                if (comp != 0) {\n-                    return comp;\n-                }\n-            }\n-            return 0;\n-        }\n+    @Override\n+    public int compare(Object aObj, Object bObj) {\n+      if (aObj == bObj) {\n+        return 0;\n+      }\n+      Object[] a = (Object[]) aObj;\n+      Object[] b = (Object[]) bObj;\n+      for (int i = 0; i < arrayLength; i++) {\n+        DataType t = elementTypes[i];\n+        int comp = t.compare(a[i], b[i]);\n+        if (comp != 0) {\n+          return comp;\n+        }\n+      }\n+      return 0;\n+    }\n \n-        @Override\n-        public void read(ByteBuffer buff, Object[] obj,\n-                int len, boolean key) {\n-            for (int i = 0; i < len; i++) {\n-                obj[i] = read(buff);\n-            }\n-        }\n+    @Override\n+    public void read(ByteBuffer buff, Object[] obj,\n+                     int len, boolean key) {\n+      for (int i = 0; i < len; i++) {\n+        obj[i] = read(buff);\n+      }\n+    }\n \n-        @Override\n-        public void write(WriteBuffer buff, Object[] obj,\n-                int len, boolean key) {\n-            for (int i = 0; i < len; i++) {\n-                write(buff, obj[i]);\n-            }\n-        }\n+    @Override\n+    public void write(WriteBuffer buff, Object[] obj,\n+                      int len, boolean key) {\n+      for (int i = 0; i < len; i++) {\n+        write(buff, obj[i]);\n+      }\n+    }\n \n-        @Override\n-        public void write(WriteBuffer buff, Object obj) {\n-            Object[] array = (Object[]) obj;\n-            for (int i = 0; i < arrayLength; i++) {\n-                DataType t = elementTypes[i];\n-                Object o = array[i];\n-                if (o == null) {\n-                    buff.put((byte) 0);\n-                } else {\n-                    buff.put((byte) 1);\n-                    t.write(buff, o);\n-                }\n-            }\n-        }\n+    @Override\n+    public void write(WriteBuffer buff, Object obj) {\n+      Object[] array = (Object[]) obj;\n+      for (int i = 0; i < arrayLength; i++) {\n+        DataType t = elementTypes[i];\n+        Object o = array[i];\n+        if (o == null) {\n+          buff.put((byte) 0);\n+        } else {\n+          buff.put((byte) 1);\n+          t.write(buff, o);\n+        }\n+      }\n+    }\n \n-        @Override\n-        public Object read(ByteBuffer buff) {\n-            Object[] array = new Object[arrayLength];\n-            for (int i = 0; i < arrayLength; i++) {\n-                DataType t = elementTypes[i];\n-                if (buff.get() == 1) {\n-                    array[i] = t.read(buff);\n-                }\n-            }\n-            return array;\n+    @Override\n+    public Object read(ByteBuffer buff) {\n+      Object[] array = new Object[arrayLength];\n+      for (int i = 0; i < arrayLength; i++) {\n+        DataType t = elementTypes[i];\n+        if (buff.get() == 1) {\n+          array[i] = t.read(buff);\n         }\n-\n+      }\n+      return array;\n     }\n \n+  }\n+\n }\n",
            "diff_size": 2545
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "376",
                    "column": "36",
                    "severity": "warning",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/123/TransactionStore.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/codebuff/123/TransactionStore.java\nindex b4d9dc28736..4a8a3ad1953 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/123/TransactionStore.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/codebuff/123/TransactionStore.java\n@@ -25,17 +25,23 @@ import org.h2.util.New;\n /**\n  * A store that supports concurrent MVCC read-committed transactions.\n  */\n+\n+\n public class TransactionStore {\n \n     /**\n      * The store.\n      */\n+\n+\n     final MVStore store;\n \n     /**\n      * The persisted map of prepared transactions.\n      * Key: transactionId, value: [ status, name ].\n      */\n+\n+\n     final MVMap<Integer, Object[]> preparedTransactions;\n \n     /**\n@@ -48,26 +54,25 @@ public class TransactionStore {\n      * <p>\n      * Key: opId, value: [ mapId, key, oldValue ].\n      */\n+\n+\n     final MVMap<Long, Object[]> undoLog;\n \n     /**\n      * the reader/writer lock for the undo-log. Allows us to process multiple\n      * selects in parallel.\n      */\n+\n+\n     final ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();\n \n     /**\n      * The map of maps.\n      */\n-    private HashMap<Integer, MVMap<Object, VersionedValue>> maps =\n-            New.hashMap();\n-\n+    private HashMap<Integer, MVMap<Object, VersionedValue>> maps = New.hashMap();\n     private final DataType dataType;\n-\n     private final BitSet openTransactions = new BitSet();\n-\n     private boolean init;\n-\n     private int maxTransactionId = 0xffff;\n \n     /**\n@@ -80,6 +85,7 @@ public class TransactionStore {\n      *\n      * @param store the store\n      */\n+\n     public TransactionStore(MVStore store) {\n         this(store, new ObjectDataType());\n     }\n@@ -90,23 +96,18 @@ public class TransactionStore {\n      * @param store the store\n      * @param dataType the data type for map keys and values\n      */\n+\n     public TransactionStore(MVStore store, DataType dataType) {\n         this.store = store;\n         this.dataType = dataType;\n         preparedTransactions = store.openMap(\"openTransactions\",\n-                new MVMap.Builder<Integer, Object[]>());\n+            new MVMap.Builder<Integer, Object[]>());\n         VersionedValueType oldValueType = new VersionedValueType(dataType);\n-        ArrayType undoLogValueType = new ArrayType(new DataType[]{\n-                new ObjectDataType(), dataType, oldValueType\n-        });\n-        MVMap.Builder<Long, Object[]> builder =\n-                new MVMap.Builder<Long, Object[]>().\n-                valueType(undoLogValueType);\n+        ArrayType undoLogValueType = new ArrayType(new DataType[] { new ObjectDataType(), dataType, oldValueType });\n+        MVMap.Builder<Long, Object[]> builder = new MVMap.Builder<Long, Object[]>().valueType(undoLogValueType);\n         undoLog = store.openMap(\"undoLog\", builder);\n         if (undoLog.getValueType() != undoLogValueType) {\n-            throw DataUtils.newIllegalStateException(\n-                    DataUtils.ERROR_TRANSACTION_CORRUPT,\n-                    \"Undo map open with a different value type\");\n+            throw DataUtils.newIllegalStateException(DataUtils.ERROR_TRANSACTION_CORRUPT, \"Undo map open with a different value type\");\n         }\n     }\n \n@@ -115,6 +116,8 @@ public class TransactionStore {\n      * If the transaction store is corrupt, this method can throw an exception,\n      * in which case the store can only be used for reading.\n      */\n+\n+\n     public synchronized void init() {\n         init = true;\n         // remove all temporary maps\n@@ -144,6 +147,8 @@ public class TransactionStore {\n      *\n      * @param max the maximum id\n      */\n+\n+\n     public void setMaxTransactionId(int max) {\n         this.maxTransactionId = max;\n     }\n@@ -155,11 +160,12 @@ public class TransactionStore {\n      * @param logId the log id\n      * @return the operation id\n      */\n+\n+\n     static long getOperationId(int transactionId, long logId) {\n-        DataUtils.checkArgument(transactionId >= 0 && transactionId < (1 << 24),\n-                \"Transaction id out of range: {0}\", transactionId);\n+        DataUtils.checkArgument(transactionId >= 0 && transactionId < (1 << 24), \"Transaction id out of range: {0}\", transactionId);\n         DataUtils.checkArgument(logId >= 0 && logId < (1L << 40),\n-                \"Transaction log id out of range: {0}\", logId);\n+                                \"Transaction log id out of range: {0}\", logId);\n         return ((long) transactionId << 40) | logId;\n     }\n \n@@ -169,6 +175,8 @@ public class TransactionStore {\n      * @param operationId the operation id\n      * @return the transaction id\n      */\n+\n+\n     static int getTransactionId(long operationId) {\n         return (int) (operationId >>> 40);\n     }\n@@ -179,6 +187,8 @@ public class TransactionStore {\n      * @param operationId the operation id\n      * @return the log id\n      */\n+\n+\n     static long getLogId(long operationId) {\n         return operationId & ((1L << 40) - 1);\n     }\n@@ -188,6 +198,8 @@ public class TransactionStore {\n      *\n      * @return the list of transactions (sorted by id)\n      */\n+\n+\n     public List<Transaction> getOpenTransactions() {\n         rwLock.readLock().lock();\n         try {\n@@ -211,8 +223,7 @@ public class TransactionStore {\n                     status = (Integer) data[0];\n                     name = (String) data[1];\n                 }\n-                Transaction t = new Transaction(this, transactionId, status,\n-                        name, logId);\n+                Transaction t = new Transaction(this, transactionId, status, name, logId);\n                 list.add(t);\n                 key = undoLog.ceilingKey(getOperationId(transactionId + 1, 0));\n             }\n@@ -225,6 +236,8 @@ public class TransactionStore {\n     /**\n      * Close the transaction store.\n      */\n+\n+\n     public synchronized void close() {\n         store.commit();\n     }\n@@ -234,21 +247,18 @@ public class TransactionStore {\n      *\n      * @return the transaction\n      */\n-    public synchronized Transaction begin() {\n \n+\n+    public synchronized Transaction begin() {\n         int transactionId;\n         int status;\n         if (!init) {\n-            throw DataUtils.newIllegalStateException(\n-                    DataUtils.ERROR_TRANSACTION_ILLEGAL_STATE,\n-                    \"Not initialized\");\n+            throw DataUtils.newIllegalStateException(DataUtils.ERROR_TRANSACTION_ILLEGAL_STATE,\n+                                                     \"Not initialized\");\n         }\n         transactionId = openTransactions.nextClearBit(1);\n         if (transactionId > maxTransactionId) {\n-            throw DataUtils.newIllegalStateException(\n-                    DataUtils.ERROR_TOO_MANY_OPEN_TRANSACTIONS,\n-                    \"There are {0} open transactions\",\n-                    transactionId - 1);\n+            throw DataUtils.newIllegalStateException(DataUtils.ERROR_TOO_MANY_OPEN_TRANSACTIONS, \"There are {0} open transactions\", transactionId - 1);\n         }\n         openTransactions.set(transactionId);\n         status = Transaction.STATUS_OPEN;\n@@ -260,9 +270,10 @@ public class TransactionStore {\n      *\n      * @param t the transaction\n      */\n+\n+\n     synchronized void storeTransaction(Transaction t) {\n-        if (t.getStatus() == Transaction.STATUS_PREPARED ||\n-                t.getName() != null) {\n+        if (t.getStatus() == Transaction.STATUS_PREPARED || t.getName() != null) {\n             Object[] v = { t.getStatus(), t.getName() };\n             preparedTransactions.put(t.getId(), v);\n         }\n@@ -277,7 +288,10 @@ public class TransactionStore {\n      * @param key the key\n      * @param oldValue the old value\n      */\n-    void log(Transaction t, long logId, int mapId,\n+\n+\n+    void log(Transaction t,\n+        long logId, int mapId,\n             Object key, Object oldValue) {\n         Long undoKey = getOperationId(t.getId(), logId);\n         Object[] log = new Object[] { mapId, key, oldValue };\n@@ -285,11 +299,7 @@ public class TransactionStore {\n         try {\n             if (logId == 0) {\n                 if (undoLog.containsKey(undoKey)) {\n-                    throw DataUtils.newIllegalStateException(\n-                            DataUtils.ERROR_TOO_MANY_OPEN_TRANSACTIONS,\n-                            \"An old transaction with the same id \" +\n-                            \"is still open: {0}\",\n-                            t.getId());\n+                    throw DataUtils.newIllegalStateException(DataUtils.ERROR_TOO_MANY_OPEN_TRANSACTIONS, \"An old transaction with the same id \" + \"is still open: {0}\", t.getId());\n                 }\n             }\n             undoLog.put(undoKey, log);\n@@ -304,16 +314,15 @@ public class TransactionStore {\n      * @param t the transaction\n      * @param logId the log id\n      */\n+\n+\n     public void logUndo(Transaction t, long logId) {\n         Long undoKey = getOperationId(t.getId(), logId);\n         rwLock.writeLock().lock();\n         try {\n             Object[] old = undoLog.remove(undoKey);\n             if (old == null) {\n-                throw DataUtils.newIllegalStateException(\n-                        DataUtils.ERROR_TRANSACTION_ILLEGAL_STATE,\n-                        \"Transaction {0} was concurrently rolled back\",\n-                        t.getId());\n+                throw DataUtils.newIllegalStateException(DataUtils.ERROR_TRANSACTION_ILLEGAL_STATE, \"Transaction {0} was concurrently rolled back\", t.getId());\n             }\n         } finally {\n             rwLock.writeLock().unlock();\n@@ -327,6 +336,8 @@ public class TransactionStore {\n      * @param <V> the value type\n      * @param map the map\n      */\n+\n+\n     synchronized <K, V> void removeMap(TransactionMap<K, V> map) {\n         maps.remove(map.mapId);\n         store.removeMap(map.map);\n@@ -338,6 +349,8 @@ public class TransactionStore {\n      * @param t the transaction\n      * @param maxLogId the last log id\n      */\n+\n+\n     void commit(Transaction t, long maxLogId) {\n         if (store.isClosed()) {\n             return;\n@@ -352,8 +365,7 @@ public class TransactionStore {\n                 if (op == null) {\n                     // partially committed: load next\n                     undoKey = undoLog.ceilingKey(undoKey);\n-                    if (undoKey == null ||\n-                            getTransactionId(undoKey) != t.getId()) {\n+                    if (undoKey == null || getTransactionId(undoKey) != t.getId()) {\n                         break;\n                     }\n                     logId = getLogId(undoKey) - 1;\n@@ -395,8 +407,9 @@ public class TransactionStore {\n      * @param valueType the value type\n      * @return the map\n      */\n-    synchronized <K> MVMap<K, VersionedValue> openMap(String name,\n-            DataType keyType, DataType valueType) {\n+\n+\n+    synchronized <K> MVMap<K, VersionedValue> openMap(String name, DataType keyType, DataType valueType) {\n         if (keyType == null) {\n             keyType = new ObjectDataType();\n         }\n@@ -405,9 +418,7 @@ public class TransactionStore {\n         }\n         VersionedValueType vt = new VersionedValueType(valueType);\n         MVMap<K, VersionedValue> map;\n-        MVMap.Builder<K, VersionedValue> builder =\n-                new MVMap.Builder<K, VersionedValue>().\n-                keyType(keyType).valueType(vt);\n+        MVMap.Builder<K, VersionedValue> builder = new MVMap.Builder<K, VersionedValue>().keyType(keyType).valueType(vt);\n         map = store.openMap(name, builder);\n         @SuppressWarnings(\"unchecked\")\n         MVMap<Object, VersionedValue> m = (MVMap<Object, VersionedValue>) map;\n@@ -421,6 +432,8 @@ public class TransactionStore {\n      * @param mapId the id\n      * @return the map\n      */\n+\n+\n     synchronized MVMap<Object, VersionedValue> openMap(int mapId) {\n         MVMap<Object, VersionedValue> map = maps.get(mapId);\n         if (map != null) {\n@@ -432,9 +445,7 @@ public class TransactionStore {\n             return null;\n         }\n         VersionedValueType vt = new VersionedValueType(dataType);\n-        MVMap.Builder<Object, VersionedValue> mapBuilder =\n-                new MVMap.Builder<Object, VersionedValue>().\n-                keyType(dataType).valueType(vt);\n+        MVMap.Builder<Object, VersionedValue> mapBuilder = new MVMap.Builder<Object, VersionedValue>().keyType(dataType).valueType(vt);\n         map = store.openMap(mapName, mapBuilder);\n         maps.put(mapId, map);\n         return map;\n@@ -445,6 +456,8 @@ public class TransactionStore {\n      *\n      * @return the map\n      */\n+\n+\n     synchronized MVMap<Object, Integer> createTempMap() {\n         String mapName = \"temp.\" + nextTempMapId++;\n         return openTempMap(mapName);\n@@ -456,10 +469,10 @@ public class TransactionStore {\n      * @param mapName the map name\n      * @return the map\n      */\n+\n+\n     MVMap<Object, Integer> openTempMap(String mapName) {\n-        MVMap.Builder<Object, Integer> mapBuilder =\n-                new MVMap.Builder<Object, Integer>().\n-                keyType(dataType);\n+        MVMap.Builder<Object, Integer> mapBuilder = new MVMap.Builder<Object, Integer>().keyType(dataType);\n         return store.openMap(mapName, mapBuilder);\n     }\n \n@@ -468,6 +481,8 @@ public class TransactionStore {\n      *\n      * @param t the transaction\n      */\n+\n+\n     synchronized void endTransaction(Transaction t) {\n         if (t.getStatus() == Transaction.STATUS_PREPARED) {\n             preparedTransactions.remove(t.getId());\n@@ -498,6 +513,8 @@ public class TransactionStore {\n      * @param maxLogId the last log id\n      * @param toLogId the log id to roll back to\n      */\n+\n+\n     void rollbackTo(Transaction t, long maxLogId, long toLogId) {\n         // TODO could synchronize on blocks (100 at a time or so)\n         rwLock.writeLock().lock();\n@@ -508,8 +525,7 @@ public class TransactionStore {\n                 if (op == null) {\n                     // partially rolled back: load previous\n                     undoKey = undoLog.floorKey(undoKey);\n-                    if (undoKey == null ||\n-                            getTransactionId(undoKey) != t.getId()) {\n+                    if (undoKey == null || getTransactionId(undoKey) != t.getId()) {\n                         break;\n                     }\n                     logId = getLogId(undoKey) + 1;\n@@ -544,8 +560,9 @@ public class TransactionStore {\n      * @param toLogId the minimum log id\n      * @return the changes\n      */\n-    Iterator<Change> getChanges(final Transaction t, final long maxLogId,\n-            final long toLogId) {\n+\n+\n+    Iterator<Change> getChanges(final Transaction t, final long maxLogId, final long toLogId) {\n         return new Iterator<Change>() {\n \n             private long logId = maxLogId - 1;\n@@ -565,8 +582,7 @@ public class TransactionStore {\n                         if (op == null) {\n                             // partially rolled back: load previous\n                             undoKey = undoLog.floorKey(undoKey);\n-                            if (undoKey == null ||\n-                                    getTransactionId(undoKey) != t.getId()) {\n+                            if (undoKey == null || getTransactionId(undoKey) != t.getId()) {\n                                 break;\n                             }\n                             logId = getLogId(undoKey);\n@@ -576,13 +592,13 @@ public class TransactionStore {\n                         MVMap<Object, VersionedValue> m = openMap(mapId);\n                         if (m == null) {\n                             // map was removed later on\n+\n                         } else {\n                             current = new Change();\n                             current.mapName = m.getName();\n                             current.key = op[1];\n                             VersionedValue oldValue = (VersionedValue) op[2];\n-                            current.value = oldValue == null ?\n-                                    null : oldValue.value;\n+                            current.value = oldValue == null ? null : oldValue.value;\n                             return;\n                         }\n                     }\n@@ -611,49 +627,64 @@ public class TransactionStore {\n             public void remove() {\n                 throw DataUtils.newUnsupportedOperationException(\"remove\");\n             }\n-\n         };\n     }\n \n     /**\n      * A change in a map.\n      */\n+\n+\n     public static class Change {\n \n         /**\n          * The name of the map where the change occurred.\n          */\n+\n+\n         public String mapName;\n \n         /**\n          * The key.\n          */\n+\n+\n         public Object key;\n \n         /**\n          * The value.\n          */\n+\n+\n         public Object value;\n     }\n \n     /**\n      * A transaction.\n      */\n+\n+\n     public static class Transaction {\n \n         /**\n          * The status of a closed transaction (committed or rolled back).\n          */\n+\n+\n         public static final int STATUS_CLOSED = 0;\n \n         /**\n          * The status of an open transaction.\n          */\n+\n+\n         public static final int STATUS_OPEN = 1;\n \n         /**\n          * The status of a prepared transaction.\n          */\n+\n+\n         public static final int STATUS_PREPARED = 2;\n \n         /**\n@@ -662,29 +693,34 @@ public class TransactionStore {\n          * closed while the transaction is committing. When opening a store,\n          * such transactions should be committed.\n          */\n+\n+\n         public static final int STATUS_COMMITTING = 3;\n \n         /**\n          * The transaction store.\n          */\n+\n+\n         final TransactionStore store;\n \n         /**\n          * The transaction id.\n          */\n+\n+\n         final int transactionId;\n \n         /**\n          * The log id of the last entry in the undo log map.\n          */\n-        long logId;\n \n-        private int status;\n \n+        long logId;\n+        private int status;\n         private String name;\n \n-        Transaction(TransactionStore store, int transactionId, int status,\n-                String name, long logId) {\n+        Transaction(TransactionStore store, int transactionId, int status, String name, long logId) {\n             this.store = store;\n             this.transactionId = transactionId;\n             this.status = status;\n@@ -692,24 +728,29 @@ public class TransactionStore {\n             this.logId = logId;\n         }\n \n+\n         public int getId() {\n             return transactionId;\n         }\n \n+\n         public int getStatus() {\n             return status;\n         }\n \n+\n         void setStatus(int status) {\n             this.status = status;\n         }\n \n+\n         public void setName(String name) {\n             checkNotClosed();\n             this.name = name;\n             store.storeTransaction(this);\n         }\n \n+\n         public String getName() {\n             return name;\n         }\n@@ -719,6 +760,8 @@ public class TransactionStore {\n          *\n          * @return the savepoint id\n          */\n+\n+\n         public long setSavepoint() {\n             return logId;\n         }\n@@ -730,6 +773,8 @@ public class TransactionStore {\n          * @param key the key\n          * @param oldValue the old value\n          */\n+\n+\n         void log(int mapId, Object key, Object oldValue) {\n             store.log(this, logId, mapId, key, oldValue);\n             // only increment the log id if logging was successful\n@@ -739,6 +784,8 @@ public class TransactionStore {\n         /**\n          * Remove the last log entry.\n          */\n+\n+\n         void logUndo() {\n             store.logUndo(this, --logId);\n         }\n@@ -751,6 +798,8 @@ public class TransactionStore {\n          * @param name the name of the map\n          * @return the transaction map\n          */\n+\n+\n         public <K, V> TransactionMap<K, V> openMap(String name) {\n             return openMap(name, null, null);\n         }\n@@ -765,13 +814,13 @@ public class TransactionStore {\n          * @param valueType the value data type\n          * @return the transaction map\n          */\n-        public <K, V> TransactionMap<K, V> openMap(String name,\n-                DataType keyType, DataType valueType) {\n+\n+\n+        public <K, V> TransactionMap<K, V> openMap(String name, DataType keyType, DataType valueType) {\n             checkNotClosed();\n-            MVMap<K, VersionedValue> map = store.openMap(name, keyType,\n-                    valueType);\n+            MVMap<K, VersionedValue> map = store.openMap(name, keyType, valueType);\n             int mapId = map.getId();\n-            return new TransactionMap<>(this, map, mapId);\n+            return new TransactionMap< >(this, map, mapId);\n         }\n \n         /**\n@@ -782,17 +831,20 @@ public class TransactionStore {\n          * @param map the base map\n          * @return the transactional map\n          */\n-        public <K, V> TransactionMap<K, V> openMap(\n-                MVMap<K, VersionedValue> map) {\n+\n+\n+        public <K, V> TransactionMap<K, V> openMap(MVMap<K, VersionedValue> map) {\n             checkNotClosed();\n             int mapId = map.getId();\n-            return new TransactionMap<>(this, map, mapId);\n+            return new TransactionMap< >(this, map, mapId);\n         }\n \n         /**\n          * Prepare the transaction. Afterwards, the transaction can only be\n          * committed or rolled back.\n          */\n+\n+\n         public void prepare() {\n             checkNotClosed();\n             status = STATUS_PREPARED;\n@@ -802,6 +854,8 @@ public class TransactionStore {\n         /**\n          * Commit the transaction. Afterwards, this transaction is closed.\n          */\n+\n+\n         public void commit() {\n             checkNotClosed();\n             store.commit(this, logId);\n@@ -813,6 +867,8 @@ public class TransactionStore {\n          *\n          * @param savepointId the savepoint id\n          */\n+\n+\n         public void rollbackToSavepoint(long savepointId) {\n             checkNotClosed();\n             store.rollbackTo(this, logId, savepointId);\n@@ -822,6 +878,8 @@ public class TransactionStore {\n         /**\n          * Roll the transaction back. Afterwards, this transaction is closed.\n          */\n+\n+\n         public void rollback() {\n             checkNotClosed();\n             store.rollbackTo(this, logId, 0);\n@@ -837,6 +895,8 @@ public class TransactionStore {\n          *            transaction\n          * @return the changes\n          */\n+\n+\n         public Iterator<Change> getChanges(long savepointId) {\n             return store.getChanges(this, logId, savepointId);\n         }\n@@ -844,10 +904,11 @@ public class TransactionStore {\n         /**\n          * Check whether this transaction is open or prepared.\n          */\n+\n+\n         void checkNotClosed() {\n             if (status == STATUS_CLOSED) {\n-                throw DataUtils.newIllegalStateException(\n-                        DataUtils.ERROR_CLOSED, \"Transaction is closed\");\n+                throw DataUtils.newIllegalStateException(DataUtils.ERROR_CLOSED, \"Transaction is closed\");\n             }\n         }\n \n@@ -856,6 +917,8 @@ public class TransactionStore {\n          *\n          * @param map the map\n          */\n+\n+\n         public <K, V> void removeMap(TransactionMap<K, V> map) {\n             store.removeMap(map);\n         }\n@@ -873,11 +936,15 @@ public class TransactionStore {\n      * @param <K> the key type\n      * @param <V> the value type\n      */\n+\n+\n     public static class TransactionMap<K, V> {\n \n         /**\n          * The map id.\n          */\n+\n+\n         final int mapId;\n \n         /**\n@@ -886,6 +953,8 @@ public class TransactionStore {\n          * is so that changes are not immediately visible, to support statement\n          * processing (for example \"update test set id = id + 1\").\n          */\n+\n+\n         long readLogId = Long.MAX_VALUE;\n \n         /**\n@@ -894,12 +963,12 @@ public class TransactionStore {\n          * Key: key the key of the data.\n          * Value: { transactionId, oldVersion, value }\n          */\n-        final MVMap<K, VersionedValue> map;\n \n+\n+        final MVMap<K, VersionedValue> map;\n         private Transaction transaction;\n \n-        TransactionMap(Transaction transaction, MVMap<K, VersionedValue> map,\n-                int mapId) {\n+        TransactionMap(Transaction transaction, MVMap<K, VersionedValue> map, int mapId) {\n             this.transaction = transaction;\n             this.map = map;\n             this.mapId = mapId;\n@@ -911,6 +980,8 @@ public class TransactionStore {\n          *\n          * @param savepoint the savepoint\n          */\n+\n+\n         public void setSavepoint(long savepoint) {\n             this.readLogId = savepoint;\n         }\n@@ -922,10 +993,10 @@ public class TransactionStore {\n          * @param savepoint the savepoint\n          * @return the map\n          */\n-        public TransactionMap<K, V> getInstance(Transaction transaction,\n-                long savepoint) {\n-            TransactionMap<K, V> m =\n-                    new TransactionMap<>(transaction, map, mapId);\n+\n+\n+        public TransactionMap<K, V> getInstance(Transaction transaction, long savepoint) {\n+            TransactionMap<K, V> m = new TransactionMap< >(transaction, map, mapId);\n             m.setSavepoint(savepoint);\n             return m;\n         }\n@@ -936,6 +1007,8 @@ public class TransactionStore {\n          *\n          * @return the maximum size\n          */\n+\n+\n         public long sizeAsLongMax() {\n             return map.sizeAsLong();\n         }\n@@ -945,6 +1018,8 @@ public class TransactionStore {\n          *\n          * @return the size\n          */\n+\n+\n         public long sizeAsLong() {\n             transaction.store.rwLock.readLock().lock();\n             try {\n@@ -977,8 +1052,7 @@ public class TransactionStore {\n                 synchronized (undo) {\n                     // re-fetch in case any transaction was committed now\n                     long size = map.sizeAsLong();\n-                    MVMap<Object, Integer> temp = transaction.store\n-                            .createTempMap();\n+                    MVMap<Object, Integer> temp = transaction.store.createTempMap();\n                     try {\n                         for (Entry<Long, Object[]> e : undo.entrySet()) {\n                             Object[] op = e.getValue();\n@@ -1018,6 +1092,8 @@ public class TransactionStore {\n          * @param key the key\n          * @throws IllegalStateException if a lock timeout occurs\n          */\n+\n+\n         public V remove(K key) {\n             return set(key, null);\n         }\n@@ -1033,6 +1109,8 @@ public class TransactionStore {\n          * @return the old value\n          * @throws IllegalStateException if a lock timeout occurs\n          */\n+\n+\n         public V put(K key, V value) {\n             DataUtils.checkArgument(value != null, \"The value may not be null\");\n             return set(key, value);\n@@ -1045,6 +1123,7 @@ public class TransactionStore {\n          * @param value the value\n          * @return the old value\n          */\n+\n         @SuppressWarnings(\"unchecked\")\n         public V putCommitted(K key, V value) {\n             DataUtils.checkArgument(value != null, \"The value may not be null\");\n@@ -1061,8 +1140,7 @@ public class TransactionStore {\n             if (ok) {\n                 return old;\n             }\n-            throw DataUtils.newIllegalStateException(\n-                    DataUtils.ERROR_TRANSACTION_LOCKED, \"Entry is locked\");\n+            throw DataUtils.newIllegalStateException(DataUtils.ERROR_TRANSACTION_LOCKED, \"Entry is locked\");\n         }\n \n         /**\n@@ -1074,6 +1152,8 @@ public class TransactionStore {\n          * @param key the key\n          * @return whether the entry could be removed\n          */\n+\n+\n         public boolean tryRemove(K key) {\n             return trySet(key, null, false);\n         }\n@@ -1088,6 +1168,8 @@ public class TransactionStore {\n          * @param value the new value\n          * @return whether the entry could be updated\n          */\n+\n+\n         public boolean tryPut(K key, V value) {\n             DataUtils.checkArgument(value != null, \"The value may not be null\");\n             return trySet(key, value, false);\n@@ -1105,6 +1187,8 @@ public class TransactionStore {\n          * @return true if the value was set, false if there was a concurrent\n          *         update\n          */\n+\n+\n         public boolean trySet(K key, V value, boolean onlyIfUnchanged) {\n             VersionedValue current = map.get(key);\n             if (onlyIfUnchanged) {\n@@ -1120,6 +1204,7 @@ public class TransactionStore {\n                         } else if (current.value == null) {\n                             // add an entry that was removed\n                             // in the same statement\n+\n                         } else {\n                             return false;\n                         }\n@@ -1129,8 +1214,7 @@ public class TransactionStore {\n                 }\n             }\n             VersionedValue newValue = new VersionedValue();\n-            newValue.operationId = getOperationId(\n-                    transaction.transactionId, transaction.logId);\n+            newValue.operationId = getOperationId(transaction.transactionId, transaction.logId);\n             newValue.value = value;\n             if (current == null) {\n                 // a new value\n@@ -1177,6 +1261,8 @@ public class TransactionStore {\n          * @param key the key\n          * @return the value or null\n          */\n+\n+\n         public V get(K key) {\n             return get(key, readLogId);\n         }\n@@ -1187,6 +1273,8 @@ public class TransactionStore {\n          * @param key the key\n          * @return the value or null\n          */\n+\n+\n         public V getLatest(K key) {\n             return get(key, Long.MAX_VALUE);\n         }\n@@ -1197,6 +1285,8 @@ public class TransactionStore {\n          * @param key the key\n          * @return true if the map contains an entry for this key\n          */\n+\n+\n         public boolean containsKey(K key) {\n             return get(key) != null;\n         }\n@@ -1208,6 +1298,7 @@ public class TransactionStore {\n          * @param maxLogId the maximum log id\n          * @return the value or null\n          */\n+\n         @SuppressWarnings(\"unchecked\")\n         public V get(K key, long maxLogId) {\n             VersionedValue data = getValue(key, maxLogId);\n@@ -1221,6 +1312,8 @@ public class TransactionStore {\n          * @param key the key\n          * @return true if yes\n          */\n+\n+\n         public boolean isSameTransaction(K key) {\n             VersionedValue data = map.get(key);\n             if (data == null) {\n@@ -1249,6 +1342,8 @@ public class TransactionStore {\n          * @param data the value stored in the main map\n          * @return the value\n          */\n+\n+\n         VersionedValue getValue(K key, long maxLog, VersionedValue data) {\n             while (true) {\n                 if (data == null) {\n@@ -1291,6 +1386,8 @@ public class TransactionStore {\n          *\n          * @return true if closed\n          */\n+\n+\n         public boolean isClosed() {\n             return map.isClosed();\n         }\n@@ -1298,6 +1395,8 @@ public class TransactionStore {\n         /**\n          * Clear the map.\n          */\n+\n+\n         public void clear() {\n             // TODO truncate transactionally?\n             map.clear();\n@@ -1308,6 +1407,8 @@ public class TransactionStore {\n          *\n          * @return the first key, or null if empty\n          */\n+\n+\n         public K firstKey() {\n             Iterator<K> it = keyIterator(null);\n             return it.hasNext() ? it.next() : null;\n@@ -1318,6 +1419,8 @@ public class TransactionStore {\n          *\n          * @return the last key, or null if empty\n          */\n+\n+\n         public K lastKey() {\n             K k = map.lastKey();\n             while (true) {\n@@ -1338,6 +1441,8 @@ public class TransactionStore {\n          * @param key the key (may not be null)\n          * @return the result\n          */\n+\n+\n         public K higherKey(K key) {\n             while (true) {\n                 K k = map.higherKey(key);\n@@ -1356,6 +1461,8 @@ public class TransactionStore {\n          * @param offset how many keys to skip (-1 for previous, 1 for next)\n          * @return the key\n          */\n+\n+\n         public K relativeKey(K key, long offset) {\n             K k = offset > 0 ? map.ceilingKey(key) : map.floorKey(key);\n             if (k == null) {\n@@ -1372,6 +1479,8 @@ public class TransactionStore {\n          * @param key the key (may not be null)\n          * @return the result\n          */\n+\n+\n         public K lowerKey(K key) {\n             while (true) {\n                 K k = map.lowerKey(key);\n@@ -1388,6 +1497,8 @@ public class TransactionStore {\n          * @param from the first key to return\n          * @return the iterator\n          */\n+\n+\n         public Iterator<K> keyIterator(K from) {\n             return keyIterator(from, false);\n         }\n@@ -1400,8 +1511,11 @@ public class TransactionStore {\n          *            included\n          * @return the iterator\n          */\n+\n+\n         public Iterator<K> keyIterator(final K from, final boolean includeUncommitted) {\n             return new Iterator<K>() {\n+\n                 private K currentKey = from;\n                 private Cursor<K, VersionedValue> cursor = map.cursor(currentKey);\n \n@@ -1416,8 +1530,7 @@ public class TransactionStore {\n                             k = cursor.next();\n                         } catch (IllegalStateException e) {\n                             // TODO this is a bit ugly\n-                            if (DataUtils.getErrorCode(e.getMessage()) ==\n-                                    DataUtils.ERROR_CHUNK_NOT_FOUND) {\n+                            if (DataUtils.getErrorCode(e.getMessage()) == DataUtils.ERROR_CHUNK_NOT_FOUND) {\n                                 cursor = map.cursor(currentKey);\n                                 // we (should) get the current key again,\n                                 // we need to ignore that one\n@@ -1458,8 +1571,7 @@ public class TransactionStore {\n \n                 @Override\n                 public void remove() {\n-                    throw DataUtils.newUnsupportedOperationException(\n-                            \"Removing is not supported\");\n+                    throw DataUtils.newUnsupportedOperationException(\"Removing is not supported\");\n                 }\n             };\n         }\n@@ -1470,8 +1582,11 @@ public class TransactionStore {\n          * @param from the first key to return\n          * @return the iterator\n          */\n+\n+\n         public Iterator<Entry<K, V>> entryIterator(final K from) {\n             return new Iterator<Entry<K, V>>() {\n+\n                 private Entry<K, V> current;\n                 private K currentKey = from;\n                 private Cursor<K, VersionedValue> cursor = map.cursor(currentKey);\n@@ -1489,8 +1604,7 @@ public class TransactionStore {\n                                 k = cursor.next();\n                             } catch (IllegalStateException e) {\n                                 // TODO this is a bit ugly\n-                                if (DataUtils.getErrorCode(e.getMessage()) ==\n-                                        DataUtils.ERROR_CHUNK_NOT_FOUND) {\n+                                if (DataUtils.getErrorCode(e.getMessage()) == DataUtils.ERROR_CHUNK_NOT_FOUND) {\n                                     cursor = map.cursor(currentKey);\n                                     // we (should) get the current key again,\n                                     // we need to ignore that one\n@@ -1512,7 +1626,7 @@ public class TransactionStore {\n                             if (data != null && data.value != null) {\n                                 @SuppressWarnings(\"unchecked\")\n                                 final V value = (V) data.value;\n-                                current = new DataUtils.MapEntry<>(key, value);\n+                                current = new DataUtils.MapEntry< >(key, value);\n                                 currentKey = key;\n                                 return;\n                             }\n@@ -1538,11 +1652,9 @@ public class TransactionStore {\n \n                 @Override\n                 public void remove() {\n-                    throw DataUtils.newUnsupportedOperationException(\n-                            \"Removing is not supported\");\n+                    throw DataUtils.newUnsupportedOperationException(\"Removing is not supported\");\n                 }\n             };\n-\n         }\n \n         /**\n@@ -1553,10 +1665,12 @@ public class TransactionStore {\n          *            included\n          * @return the iterator\n          */\n-        public Iterator<K> wrapIterator(final Iterator<K> iterator,\n-                final boolean includeUncommitted) {\n+\n+\n+        public Iterator<K> wrapIterator(final Iterator<K> iterator, final boolean includeUncommitted) {\n             // TODO duplicate code for wrapIterator and entryIterator\n             return new Iterator<K>() {\n+\n                 private K current;\n \n                 {\n@@ -1590,16 +1704,17 @@ public class TransactionStore {\n \n                 @Override\n                 public void remove() {\n-                    throw DataUtils.newUnsupportedOperationException(\n-                            \"Removing is not supported\");\n+                    throw DataUtils.newUnsupportedOperationException(\"Removing is not supported\");\n                 }\n             };\n         }\n \n+\n         public Transaction getTransaction() {\n             return transaction;\n         }\n \n+\n         public DataType getKeyType() {\n             return map.getKeyType();\n         }\n@@ -1610,24 +1725,27 @@ public class TransactionStore {\n      * A versioned value (possibly null). It contains a pointer to the old\n      * value, and the value itself.\n      */\n+\n+\n     static class VersionedValue {\n \n         /**\n          * The operation id.\n          */\n+\n+\n         public long operationId;\n \n         /**\n          * The value.\n          */\n+\n+\n         public Object value;\n \n         @Override\n         public String toString() {\n-            return value + (operationId == 0 ? \"\" : (\n-                    \" \" +\n-                    getTransactionId(operationId) + \"/\" +\n-                    getLogId(operationId)));\n+            return value + (operationId == 0 ? \"\" : (\" \" + getTransactionId(operationId) + \"/\" + getLogId(operationId)));\n         }\n \n     }\n@@ -1635,6 +1753,8 @@ public class TransactionStore {\n     /**\n      * The value type for a versioned value.\n      */\n+\n+\n     public static class VersionedValueType implements DataType {\n \n         private final DataType valueType;\n@@ -1733,6 +1853,8 @@ public class TransactionStore {\n      * A data type that contains an array of objects with the specified data\n      * types.\n      */\n+\n+\n     public static class ArrayType implements DataType {\n \n         private final int arrayLength;\n@@ -1775,16 +1897,14 @@ public class TransactionStore {\n         }\n \n         @Override\n-        public void read(ByteBuffer buff, Object[] obj,\n-                int len, boolean key) {\n+        public void read(ByteBuffer buff, Object[] obj, int len, boolean key) {\n             for (int i = 0; i < len; i++) {\n                 obj[i] = read(buff);\n             }\n         }\n \n         @Override\n-        public void write(WriteBuffer buff, Object[] obj,\n-                int len, boolean key) {\n+        public void write(WriteBuffer buff, Object[] obj, int len, boolean key) {\n             for (int i = 0; i < len; i++) {\n                 write(buff, obj[i]);\n             }\n@@ -1819,4 +1939,4 @@ public class TransactionStore {\n \n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 291
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/123/TransactionStore.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_random/123/TransactionStore.java\nindex b4d9dc28736..e3329d51eae 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/123/TransactionStore.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_random/123/TransactionStore.java\n@@ -361,8 +361,9 @@ public class TransactionStore {\n                 }\n                 int mapId = (Integer) op[0];\n                 MVMap<Object, VersionedValue> map = openMap(mapId);\n-                if (map != null) { // might be null if map was removed later\n-                    Object key = op[1];\n+                if (map != null) {\n+                    // might be null if map was removed later\n+                Object key = op[1];\n                     VersionedValue value = map.get(key);\n                     if (value != null) {\n                         // only commit (remove/update) value if we've reached\n",
            "diff_size": 3
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/123/TransactionStore.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/123/TransactionStore.java\nindex b4d9dc28736..a595f22f1e8 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/123/TransactionStore.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/123/TransactionStore.java\n@@ -361,8 +361,9 @@ public class TransactionStore {\n                 }\n                 int mapId = (Integer) op[0];\n                 MVMap<Object, VersionedValue> map = openMap(mapId);\n-                if (map != null) { // might be null if map was removed later\n-                    Object key = op[1];\n+                if (map != null) {\n+            // might be null if map was removed later\n+                Object key = op[1];\n                     VersionedValue value = map.get(key);\n                     if (value != null) {\n                         // only commit (remove/update) value if we've reached\n",
            "diff_size": 3
        }
    ],
    "repaired_by": [
        "styler",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "intellij",
        "naturalize",
        "codebuff"
    ]
}