{
    "project_name": "IQSS-dataverse",
    "error_id": "95",
    "information": {
        "errors": [
            {
                "line": "152",
                "column": "1",
                "severity": "error",
                "message": "File contains tab characters (this is the first instance).",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
            }
        ]
    },
    "source_code": "            // name we used to have to do - since all the values in a current Dataverse \n            // database may already be santized enough. \n\t    // (Edit: Yes, we still need this - there are still datasets with multiple \n\t    // files with duplicate names; this method takes care of that)\n            if (inputStream != null && this.zipOutputStream != null) {\n                ",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/95/ZipDownloadService.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler/95/ZipDownloadService.java\nindex 4b66ee770d5..6483df1fa2a 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/95/ZipDownloadService.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler/95/ZipDownloadService.java\n@@ -149,8 +149,8 @@ public class ZipDownloadService {\n             // this may not be needed anymore - some extra sanitizing of the file \n             // name we used to have to do - since all the values in a current Dataverse \n             // database may already be santized enough. \n-\t    // (Edit: Yes, we still need this - there are still datasets with multiple \n-\t    // files with duplicate names; this method takes care of that)\n+            // (Edit: Yes, we still need this - there are still datasets with multiple \n+     // files with duplicate names; this method takes care of that)\n             if (inputStream != null && this.zipOutputStream != null) {\n                 \n                 ZipEntry entry = new ZipEntry(zipEntryName);\n",
            "diff_size": 2
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/95/ZipDownloadService.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/intellij/95/ZipDownloadService.java\nindex 4b66ee770d5..b54c4a65d62 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/95/ZipDownloadService.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/intellij/95/ZipDownloadService.java\n@@ -17,6 +17,7 @@\n    Developed at the Institute for Quantitative Social Science, Harvard University.\n    Version 3.0.\n */\n+\n package edu.harvard.iq.dataverse.custom.service.download;\n \n import edu.harvard.iq.dataverse.custom.service.util.DirectAccessUtil;\n@@ -31,235 +32,235 @@ import java.util.zip.ZipOutputStream;\n \n /**\n  * Custom (standalone) download service for Dataverse\n- * \n+ *\n  * @author Leonid Andreev\n  */\n-public class ZipDownloadService { \n-    \n-    private static String jobKey = null;\n-    private List<String[]> jobFiles = null;\n-    private boolean zipOnly = false; \n-    \n-    private DirectAccessUtil directAccessUtil = null; \n-    private ZipOutputStream zipOutputStream = null;\n-\n-    public static void main(String args[]) throws Exception {\n-        \n-        ZipDownloadService zipperService = new ZipDownloadService();\n-        \n-        if (!zipperService.parseArgs(args)) {\n-            zipperService.usage();\n-            return; \n-        }\n-        \n-        zipperService.parseCgiQueryParameters();\n-               \n-        zipperService.execute(jobKey);\n-    }\n+public class ZipDownloadService {\n \n-    private static void usage() {\n-        System.out.println(\"\\nUsage:\");\n-        System.out.println(\"  java -jar ZipDownloadService-1.0.0.jar [-ziponly]>\\n\");\n+  private static String jobKey = null;\n+  private List<String[]> jobFiles = null;\n+  private boolean zipOnly = false;\n \n-        System.out.println(\"  supported options:\");\n-        System.out.println(\"   -ziponly = output zip only, no http header/no chunking\");\n-        System.out.println(\"\");\n+  private DirectAccessUtil directAccessUtil = null;\n+  private ZipOutputStream zipOutputStream = null;\n \n-    }\n+  public static void main(String args[]) throws Exception {\n \n-    // The only option supported at the moment is \"zip only\" - output just the\n-    // compressed stream, skip the HTTP header and chunking.\n-    public boolean parseArgs(String[] args) {\n-\n-        if (args == null || args.length == 0) {\n-            return true; \n-        } else if (args.length == 1) {\n-            if (args[0].equals(\"-ziponly\")) {\n-                this.zipOnly = true;\n-                return true;\n-            }\n-        }\n-        \n-        return false; \n+    ZipDownloadService zipperService = new ZipDownloadService();\n+\n+    if (!zipperService.parseArgs(args)) {\n+      zipperService.usage();\n+      return;\n     }\n-    \n-    // Does not support any parameters, except the job-identifying token key, \n-    // supplied as the entire query string. \n-    public void parseCgiQueryParameters() {\n-        String queryString = System.getenv().get(\"QUERY_STRING\");\n-        if (queryString != null) {\n-            jobKey = queryString; \n-        }\n+\n+    zipperService.parseCgiQueryParameters();\n+\n+    zipperService.execute(jobKey);\n+  }\n+\n+  private static void usage() {\n+    System.out.println(\"\\nUsage:\");\n+    System.out.println(\"  java -jar ZipDownloadService-1.0.0.jar [-ziponly]>\\n\");\n+\n+    System.out.println(\"  supported options:\");\n+    System.out.println(\"   -ziponly = output zip only, no http header/no chunking\");\n+    System.out.println(\"\");\n+\n+  }\n+\n+  // The only option supported at the moment is \"zip only\" - output just the\n+  // compressed stream, skip the HTTP header and chunking.\n+  public boolean parseArgs(String[] args) {\n+\n+    if (args == null || args.length == 0) {\n+      return true;\n+    } else if (args.length == 1) {\n+      if (args[0].equals(\"-ziponly\")) {\n+        this.zipOnly = true;\n+        return true;\n+      }\n     }\n-    \n-    public void print404() {\n-        System.out.println(\"Status: 404 Not Found\\r\");\n-        System.out.println(\"Content-Type: text/html\\r\");\n-        System.out.println(\"\\r\");\n \n-        System.out.println(\"<h1>404 No such download job!</h1>\");\n+    return false;\n+  }\n+\n+  // Does not support any parameters, except the job-identifying token key,\n+  // supplied as the entire query string.\n+  public void parseCgiQueryParameters() {\n+    String queryString = System.getenv().get(\"QUERY_STRING\");\n+    if (queryString != null) {\n+      jobKey = queryString;\n     }\n-    \n-    public void printZipHeader() {\n-        System.out.println(\"Content-disposition: attachment; filename=\\\"dataverse_files.zip\\\"\\r\");\n-        System.out.println(\"Content-Type: application/zip; name=\\\"dataverse_files.zip\\\"\\r\");\n-        System.out.println(\"Transfer-Encoding: chunked\\r\");\n-        System.out.println(\"\\r\");\n-        System.out.flush();\n+  }\n+\n+  public void print404() {\n+    System.out.println(\"Status: 404 Not Found\\r\");\n+    System.out.println(\"Content-Type: text/html\\r\");\n+    System.out.println(\"\\r\");\n+\n+    System.out.println(\"<h1>404 No such download job!</h1>\");\n+  }\n+\n+  public void printZipHeader() {\n+    System.out.println(\"Content-disposition: attachment; filename=\\\"dataverse_files.zip\\\"\\r\");\n+    System.out.println(\"Content-Type: application/zip; name=\\\"dataverse_files.zip\\\"\\r\");\n+    System.out.println(\"Transfer-Encoding: chunked\\r\");\n+    System.out.println(\"\\r\");\n+    System.out.flush();\n+  }\n+\n+  public void execute(String key) {\n+\n+    jobFiles = lookupZipJob(key);\n+\n+    if (jobFiles == null || jobFiles.size() == 0) {\n+      this.print404();\n+      System.exit(0);\n     }\n-    \n-    public void execute(String key) {\n-        \n-        jobFiles = lookupZipJob(key); \n-        \n-        if (jobFiles == null || jobFiles.size() == 0) {\n-            this.print404();\n-            System.exit(0);\n-        }\n-        \n-        this.processFiles();\n+\n+    this.processFiles();\n+  }\n+\n+  public void processFiles() {\n+\n+    if (!this.zipOnly) {\n+      this.printZipHeader();\n     }\n-    \n-    public void processFiles() {\n-        \n-        if (!this.zipOnly) {\n-            this.printZipHeader();\n-        }\n-        \n-        Set<String> zippedFolders = new HashSet<>();\n-        Set<String> fileNamesList = new HashSet<>();\n-       \n-        for (String [] fileEntry : jobFiles) {\n-            String storageLocation = fileEntry[0];\n-            String fileName = fileEntry[1];\n-            \n-            //System.out.println(storageLocation + \":\" + fileName);\n-            \n-            if (this.zipOutputStream == null) {\n-                openZipStream();\n-            }\n-            \n-            if (this.directAccessUtil == null) {\n-                this.directAccessUtil = new DirectAccessUtil();\n-            }\n-            \n-            InputStream inputStream = this.directAccessUtil.openDirectAccess(storageLocation);\n-                \n-            String zipEntryName = checkZipEntryName(fileName, fileNamesList);\n-            // this may not be needed anymore - some extra sanitizing of the file \n-            // name we used to have to do - since all the values in a current Dataverse \n-            // database may already be santized enough. \n-\t    // (Edit: Yes, we still need this - there are still datasets with multiple \n-\t    // files with duplicate names; this method takes care of that)\n-            if (inputStream != null && this.zipOutputStream != null) {\n-                \n-                ZipEntry entry = new ZipEntry(zipEntryName);\n-\n-                byte[] bytes = new byte[2 * 8192];\n-                int read = 0;\n-                long readSize = 0L;\n-\n-                try {\n-                    // Does this file have a folder name? \n-                    if (hasFolder(zipEntryName)) {\n-                        addFolderToZipStream(getFolderName(zipEntryName), zippedFolders);\n-                    }\n-\n-                    this.zipOutputStream.putNextEntry(entry);\n-\n-                    while ((read = inputStream.read(bytes)) != -1) {\n-                        this.zipOutputStream.write(bytes, 0, read);\n-                        readSize += read;\n-                    }\n-                    this.zipOutputStream.closeEntry();\n+\n+    Set<String> zippedFolders = new HashSet<>();\n+    Set<String> fileNamesList = new HashSet<>();\n+\n+    for (String[] fileEntry : jobFiles) {\n+      String storageLocation = fileEntry[0];\n+      String fileName = fileEntry[1];\n+\n+      //System.out.println(storageLocation + \":\" + fileName);\n+\n+      if (this.zipOutputStream == null) {\n+        openZipStream();\n+      }\n+\n+      if (this.directAccessUtil == null) {\n+        this.directAccessUtil = new DirectAccessUtil();\n+      }\n+\n+      InputStream inputStream = this.directAccessUtil.openDirectAccess(storageLocation);\n+\n+      String zipEntryName = checkZipEntryName(fileName, fileNamesList);\n+      // this may not be needed anymore - some extra sanitizing of the file\n+      // name we used to have to do - since all the values in a current Dataverse\n+      // database may already be santized enough.\n+      // (Edit: Yes, we still need this - there are still datasets with multiple\n+      // files with duplicate names; this method takes care of that)\n+      if (inputStream != null && this.zipOutputStream != null) {\n+\n+        ZipEntry entry = new ZipEntry(zipEntryName);\n+\n+        byte[] bytes = new byte[2 * 8192];\n+        int read = 0;\n+        long readSize = 0L;\n+\n+        try {\n+          // Does this file have a folder name?\n+          if (hasFolder(zipEntryName)) {\n+            addFolderToZipStream(getFolderName(zipEntryName), zippedFolders);\n+          }\n+\n+          this.zipOutputStream.putNextEntry(entry);\n+\n+          while ((read = inputStream.read(bytes)) != -1) {\n+            this.zipOutputStream.write(bytes, 0, read);\n+            readSize += read;\n+          }\n+          this.zipOutputStream.closeEntry();\n \n                     /*if (fileSize == readSize) {\n                         //System.out.println(\"Read \"+readSize+\" bytes;\");\n                     } else {\n                         throw new IOException(\"Byte size mismatch: expected \" + fileSize + \", read: \" + readSize);\n                     }*/\n-                } catch (IOException ioex) {\n-                    System.err.println(\"Failed to compress \"+storageLocation);\n-                } finally {\n-                    try {\n-                        inputStream.close();\n-                    } catch (IOException ioexIgnore) {\n-                        System.err.println(\"Warning: IO exception trying to close input stream - \"+storageLocation);\n-                    }\n-                }\n-            } else {\n-                System.err.println(\"Failed to access \"+storageLocation);\n-            }\n-                \n+        } catch (IOException ioex) {\n+          System.err.println(\"Failed to compress \" + storageLocation);\n+        } finally {\n+          try {\n+            inputStream.close();\n+          } catch (IOException ioexIgnore) {\n+            System.err.println(\"Warning: IO exception trying to close input stream - \" + storageLocation);\n+          }\n         }\n-        try {\n-            this.zipOutputStream.flush();\n-            this.zipOutputStream.close();\n+      } else {\n+        System.err.println(\"Failed to access \" + storageLocation);\n+      }\n \n-            System.out.flush();\n-            System.out.close();\n-        } catch (Exception e) {\n-        }\n     }\n-    \n-    public void openZipStream() {\n-        if (this.zipOutputStream == null) {\n-            if (this.zipOnly) {\n-                this.zipOutputStream = new ZipOutputStream(System.out);\n-            } else {\n-                this.zipOutputStream = new ZipOutputStream(new ChunkingOutputStream(System.out));\n-            }\n-        }\n+    try {\n+      this.zipOutputStream.flush();\n+      this.zipOutputStream.close();\n+\n+      System.out.flush();\n+      System.out.close();\n+    } catch (Exception e) {\n     }\n-    \n-    private boolean hasFolder(String fileName) {\n-        if (fileName == null) {\n-            return false;\n-        }\n-        return fileName.indexOf('/') >= 0;\n+  }\n+\n+  public void openZipStream() {\n+    if (this.zipOutputStream == null) {\n+      if (this.zipOnly) {\n+        this.zipOutputStream = new ZipOutputStream(System.out);\n+      } else {\n+        this.zipOutputStream = new ZipOutputStream(new ChunkingOutputStream(System.out));\n+      }\n     }\n-    \n-    private String getFolderName(String fileName) {\n-        if (fileName == null) {\n-            return \"\";\n-        }\n-        String folderName = fileName.substring(0, fileName.lastIndexOf('/'));\n-        // If any of the saved folder names start with with slashes,            \n-        // we want to remove them:                                              \n-        // (i.e., ///foo/bar will become foo/bar)                               \n-        while (folderName.startsWith(\"/\")) {\n-            folderName = folderName.substring(1);\n-        }\n-        return folderName;\n+  }\n+\n+  private boolean hasFolder(String fileName) {\n+    if (fileName == null) {\n+      return false;\n     }\n-    \n-    private void addFolderToZipStream(String folderName, Set<String> zippedFolders) throws IOException {\n-        // We don't want to create folders in the output Zip file that have \n-        // already been added:\n-        if (!\"\".equals(folderName)) {\n-            if (!zippedFolders.contains(folderName)) {\n-                ZipEntry d = new ZipEntry(folderName + \"/\");\n-                zipOutputStream.putNextEntry(d);\n-                zipOutputStream.closeEntry();\n-                zippedFolders.add(folderName);\n-            }\n-        }\n+    return fileName.indexOf('/') >= 0;\n+  }\n+\n+  private String getFolderName(String fileName) {\n+    if (fileName == null) {\n+      return \"\";\n     }\n-    \n-    // check for and process duplicates:\n-    private String checkZipEntryName(String originalName, Set<String> fileNames) {\n-        String name = originalName;\n-        int fileSuffix = 1;\n-        int extensionIndex = originalName.lastIndexOf(\".\");\n-\n-        while (fileNames.contains(name)) {\n-            if (extensionIndex != -1) {\n-                name = originalName.substring(0, extensionIndex) + \"_\" + fileSuffix++ + originalName.substring(extensionIndex);\n-            } else {\n-                name = originalName + \"_\" + fileSuffix++;\n-            }\n-        }\n-        fileNames.add(name);\n-        return name;\n+    String folderName = fileName.substring(0, fileName.lastIndexOf('/'));\n+    // If any of the saved folder names start with with slashes,\n+    // we want to remove them:\n+    // (i.e., ///foo/bar will become foo/bar)\n+    while (folderName.startsWith(\"/\")) {\n+      folderName = folderName.substring(1);\n+    }\n+    return folderName;\n+  }\n+\n+  private void addFolderToZipStream(String folderName, Set<String> zippedFolders) throws IOException {\n+    // We don't want to create folders in the output Zip file that have\n+    // already been added:\n+    if (!\"\".equals(folderName)) {\n+      if (!zippedFolders.contains(folderName)) {\n+        ZipEntry d = new ZipEntry(folderName + \"/\");\n+        zipOutputStream.putNextEntry(d);\n+        zipOutputStream.closeEntry();\n+        zippedFolders.add(folderName);\n+      }\n+    }\n+  }\n+\n+  // check for and process duplicates:\n+  private String checkZipEntryName(String originalName, Set<String> fileNames) {\n+    String name = originalName;\n+    int fileSuffix = 1;\n+    int extensionIndex = originalName.lastIndexOf(\".\");\n+\n+    while (fileNames.contains(name)) {\n+      if (extensionIndex != -1) {\n+        name = originalName.substring(0, extensionIndex) + \"_\" + fileSuffix++ + originalName.substring(extensionIndex);\n+      } else {\n+        name = originalName + \"_\" + fileSuffix++;\n+      }\n     }\n+    fileNames.add(name);\n+    return name;\n+  }\n }\n",
            "diff_size": 276
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/95/ZipDownloadService.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/codebuff/95/ZipDownloadService.java\nindex 4b66ee770d5..a17d23cee9f 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/95/ZipDownloadService.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/codebuff/95/ZipDownloadService.java\n@@ -34,72 +34,66 @@ import java.util.zip.ZipOutputStream;\n  * \n  * @author Leonid Andreev\n  */\n-public class ZipDownloadService { \n-    \n+\n+\n+public class ZipDownloadService {\n+\n     private static String jobKey = null;\n     private List<String[]> jobFiles = null;\n-    private boolean zipOnly = false; \n-    \n-    private DirectAccessUtil directAccessUtil = null; \n+    private boolean zipOnly = false;\n+    private DirectAccessUtil directAccessUtil = null;\n     private ZipOutputStream zipOutputStream = null;\n \n     public static void main(String args[]) throws Exception {\n-        \n         ZipDownloadService zipperService = new ZipDownloadService();\n-        \n         if (!zipperService.parseArgs(args)) {\n             zipperService.usage();\n-            return; \n+            return;\n         }\n-        \n         zipperService.parseCgiQueryParameters();\n-               \n         zipperService.execute(jobKey);\n     }\n \n     private static void usage() {\n         System.out.println(\"\\nUsage:\");\n         System.out.println(\"  java -jar ZipDownloadService-1.0.0.jar [-ziponly]>\\n\");\n-\n         System.out.println(\"  supported options:\");\n         System.out.println(\"   -ziponly = output zip only, no http header/no chunking\");\n         System.out.println(\"\");\n-\n     }\n \n     // The only option supported at the moment is \"zip only\" - output just the\n     // compressed stream, skip the HTTP header and chunking.\n-    public boolean parseArgs(String[] args) {\n \n+    public boolean parseArgs(String[] args) {\n         if (args == null || args.length == 0) {\n-            return true; \n+            return true;\n         } else if (args.length == 1) {\n             if (args[0].equals(\"-ziponly\")) {\n                 this.zipOnly = true;\n                 return true;\n             }\n         }\n-        \n-        return false; \n+        return false;\n     }\n     \n     // Does not support any parameters, except the job-identifying token key, \n     // supplied as the entire query string. \n+\n     public void parseCgiQueryParameters() {\n         String queryString = System.getenv().get(\"QUERY_STRING\");\n         if (queryString != null) {\n-            jobKey = queryString; \n+            jobKey = queryString;\n         }\n     }\n-    \n+\n     public void print404() {\n         System.out.println(\"Status: 404 Not Found\\r\");\n         System.out.println(\"Content-Type: text/html\\r\");\n         System.out.println(\"\\r\");\n-\n         System.out.println(\"<h1>404 No such download job!</h1>\");\n     }\n-    \n+\n     public void printZipHeader() {\n         System.out.println(\"Content-disposition: attachment; filename=\\\"dataverse_files.zip\\\"\\r\");\n         System.out.println(\"Content-Type: application/zip; name=\\\"dataverse_files.zip\\\"\\r\");\n@@ -107,66 +101,54 @@ public class ZipDownloadService {\n         System.out.println(\"\\r\");\n         System.out.flush();\n     }\n-    \n+\n     public void execute(String key) {\n-        \n-        jobFiles = lookupZipJob(key); \n-        \n+        jobFiles = lookupZipJob(key);\n         if (jobFiles == null || jobFiles.size() == 0) {\n             this.print404();\n             System.exit(0);\n         }\n-        \n         this.processFiles();\n     }\n-    \n+\n     public void processFiles() {\n-        \n         if (!this.zipOnly) {\n             this.printZipHeader();\n         }\n-        \n+\n         Set<String> zippedFolders = new HashSet<>();\n         Set<String> fileNamesList = new HashSet<>();\n-       \n-        for (String [] fileEntry : jobFiles) {\n+        for (String[] fileEntry : jobFiles) {\n             String storageLocation = fileEntry[0];\n             String fileName = fileEntry[1];\n             \n             //System.out.println(storageLocation + \":\" + fileName);\n-            \n             if (this.zipOutputStream == null) {\n                 openZipStream();\n             }\n-            \n+\n             if (this.directAccessUtil == null) {\n                 this.directAccessUtil = new DirectAccessUtil();\n             }\n-            \n+\n             InputStream inputStream = this.directAccessUtil.openDirectAccess(storageLocation);\n-                \n             String zipEntryName = checkZipEntryName(fileName, fileNamesList);\n             // this may not be needed anymore - some extra sanitizing of the file \n             // name we used to have to do - since all the values in a current Dataverse \n             // database may already be santized enough. \n-\t    // (Edit: Yes, we still need this - there are still datasets with multiple \n-\t    // files with duplicate names; this method takes care of that)\n+        // (Edit: Yes, we still need this - there are still datasets with multiple \n+        // files with duplicate names; this method takes care of that)\n             if (inputStream != null && this.zipOutputStream != null) {\n-                \n                 ZipEntry entry = new ZipEntry(zipEntryName);\n-\n                 byte[] bytes = new byte[2 * 8192];\n                 int read = 0;\n                 long readSize = 0L;\n-\n                 try {\n                     // Does this file have a folder name? \n                     if (hasFolder(zipEntryName)) {\n                         addFolderToZipStream(getFolderName(zipEntryName), zippedFolders);\n                     }\n-\n                     this.zipOutputStream.putNextEntry(entry);\n-\n                     while ((read = inputStream.read(bytes)) != -1) {\n                         this.zipOutputStream.write(bytes, 0, read);\n                         readSize += read;\n@@ -179,29 +161,26 @@ public class ZipDownloadService {\n                         throw new IOException(\"Byte size mismatch: expected \" + fileSize + \", read: \" + readSize);\n                     }*/\n                 } catch (IOException ioex) {\n-                    System.err.println(\"Failed to compress \"+storageLocation);\n+                    System.err.println(\"Failed to compress \" + storageLocation);\n                 } finally {\n                     try {\n                         inputStream.close();\n                     } catch (IOException ioexIgnore) {\n-                        System.err.println(\"Warning: IO exception trying to close input stream - \"+storageLocation);\n+                        System.err.println(\"Warning: IO exception trying to close input stream - \" + storageLocation);\n                     }\n                 }\n             } else {\n-                System.err.println(\"Failed to access \"+storageLocation);\n+                System.err.println(\"Failed to access \" + storageLocation);\n             }\n-                \n         }\n         try {\n             this.zipOutputStream.flush();\n             this.zipOutputStream.close();\n-\n             System.out.flush();\n             System.out.close();\n-        } catch (Exception e) {\n-        }\n+        } catch (Exception e) {}\n     }\n-    \n+\n     public void openZipStream() {\n         if (this.zipOutputStream == null) {\n             if (this.zipOnly) {\n@@ -211,18 +190,19 @@ public class ZipDownloadService {\n             }\n         }\n     }\n-    \n+\n     private boolean hasFolder(String fileName) {\n         if (fileName == null) {\n             return false;\n         }\n-        return fileName.indexOf('/') >= 0;\n+        return fileName.indexOf('/') >=0;\n     }\n-    \n+\n     private String getFolderName(String fileName) {\n         if (fileName == null) {\n             return \"\";\n         }\n+\n         String folderName = fileName.substring(0, fileName.lastIndexOf('/'));\n         // If any of the saved folder names start with with slashes,            \n         // we want to remove them:                                              \n@@ -232,7 +212,7 @@ public class ZipDownloadService {\n         }\n         return folderName;\n     }\n-    \n+\n     private void addFolderToZipStream(String folderName, Set<String> zippedFolders) throws IOException {\n         // We don't want to create folders in the output Zip file that have \n         // already been added:\n@@ -247,11 +227,11 @@ public class ZipDownloadService {\n     }\n     \n     // check for and process duplicates:\n+\n     private String checkZipEntryName(String originalName, Set<String> fileNames) {\n         String name = originalName;\n         int fileSuffix = 1;\n         int extensionIndex = originalName.lastIndexOf(\".\");\n-\n         while (fileNames.contains(name)) {\n             if (extensionIndex != -1) {\n                 name = originalName.substring(0, extensionIndex) + \"_\" + fileSuffix++ + originalName.substring(extensionIndex);\n@@ -262,4 +242,4 @@ public class ZipDownloadService {\n         fileNames.add(name);\n         return name;\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 61
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/95/ZipDownloadService.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_random/95/ZipDownloadService.java\nindex 4b66ee770d5..6483df1fa2a 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/95/ZipDownloadService.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_random/95/ZipDownloadService.java\n@@ -149,8 +149,8 @@ public class ZipDownloadService {\n             // this may not be needed anymore - some extra sanitizing of the file \n             // name we used to have to do - since all the values in a current Dataverse \n             // database may already be santized enough. \n-\t    // (Edit: Yes, we still need this - there are still datasets with multiple \n-\t    // files with duplicate names; this method takes care of that)\n+            // (Edit: Yes, we still need this - there are still datasets with multiple \n+     // files with duplicate names; this method takes care of that)\n             if (inputStream != null && this.zipOutputStream != null) {\n                 \n                 ZipEntry entry = new ZipEntry(zipEntryName);\n",
            "diff_size": 2
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/95/ZipDownloadService.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_three_grams/95/ZipDownloadService.java\nindex 4b66ee770d5..6483df1fa2a 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/95/ZipDownloadService.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_three_grams/95/ZipDownloadService.java\n@@ -149,8 +149,8 @@ public class ZipDownloadService {\n             // this may not be needed anymore - some extra sanitizing of the file \n             // name we used to have to do - since all the values in a current Dataverse \n             // database may already be santized enough. \n-\t    // (Edit: Yes, we still need this - there are still datasets with multiple \n-\t    // files with duplicate names; this method takes care of that)\n+            // (Edit: Yes, we still need this - there are still datasets with multiple \n+     // files with duplicate names; this method takes care of that)\n             if (inputStream != null && this.zipOutputStream != null) {\n                 \n                 ZipEntry entry = new ZipEntry(zipEntryName);\n",
            "diff_size": 2
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "naturalize"
    ]
}