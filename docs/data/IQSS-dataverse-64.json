{
    "project_name": "IQSS-dataverse",
    "error_id": "64",
    "information": {
        "errors": [
            {
                "line": "227",
                "column": "5",
                "severity": "error",
                "message": "File contains tab characters (this is the first instance).",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
            }
        ]
    },
    "source_code": "    // in a file in the dataset directory / container based on its DOI:\n    private void cacheExport(DatasetVersion version, String format, JsonObject datasetAsJson, Exporter exporter) throws ExportException {\n    \tboolean tempFileUsed = false;\n    \tFile tempFile = null;\n    \tOutputStream outputStream = null;\n    \tDataset dataset = version.getDataset();",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "228",
                    "column": "5",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/64/ExportService.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler/64/ExportService.java\nindex 52de3cf1d78..3dc29e022a5 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/64/ExportService.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler/64/ExportService.java\n@@ -224,7 +224,7 @@ public class ExportService {\n     // This method runs the selected metadata exporter, caching the output \n     // in a file in the dataset directory / container based on its DOI:\n     private void cacheExport(DatasetVersion version, String format, JsonObject datasetAsJson, Exporter exporter) throws ExportException {\n-    \tboolean tempFileUsed = false;\n+    boolean tempFileUsed = false;\n     \tFile tempFile = null;\n     \tOutputStream outputStream = null;\n     \tDataset dataset = version.getDataset();\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/64/ExportService.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/intellij/64/ExportService.java\nindex 52de3cf1d78..fca644a4c11 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/64/ExportService.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/intellij/64/ExportService.java\n@@ -38,285 +38,286 @@ import javax.ws.rs.core.MediaType;\n import org.apache.commons.io.IOUtils;\n \n /**\n- *\n  * @author skraffmi\n  */\n public class ExportService {\n \n-    private static ExportService service;\n-    private ServiceLoader<Exporter> loader;\n+  private static ExportService service;\n+  private ServiceLoader<Exporter> loader;\n \n-    private ExportService() {\n-        loader = ServiceLoader.load(Exporter.class);\n-    }\n+  private ExportService() {\n+    loader = ServiceLoader.load(Exporter.class);\n+  }\n \n-    public static synchronized ExportService getInstance() {\n-        if (service == null) {\n-            service = new ExportService();\n-        }\n-        return service;\n+  public static synchronized ExportService getInstance() {\n+    if (service == null) {\n+      service = new ExportService();\n     }\n-\n-    public List< String[]> getExportersLabels() {\n-        List<String[]> retList = new ArrayList<>();\n-        Iterator<Exporter> exporters = ExportService.getInstance().loader.iterator();\n-        while (exporters.hasNext()) {\n-            Exporter e = exporters.next();\n-            String[] temp = new String[2];\n-            temp[0] = e.getDisplayName();\n-            temp[1] = e.getProviderName();\n-            retList.add(temp);\n-        }\n-        return retList;\n+    return service;\n+  }\n+\n+  public List<String[]> getExportersLabels() {\n+    List<String[]> retList = new ArrayList<>();\n+    Iterator<Exporter> exporters = ExportService.getInstance().loader.iterator();\n+    while (exporters.hasNext()) {\n+      Exporter e = exporters.next();\n+      String[] temp = new String[2];\n+      temp[0] = e.getDisplayName();\n+      temp[1] = e.getProviderName();\n+      retList.add(temp);\n     }\n+    return retList;\n+  }\n \n-    public InputStream getExport(Dataset dataset, String formatName) throws ExportException, IOException {\n-        // first we will try to locate an already existing, cached export \n-        // for this format: \n-        InputStream exportInputStream = getCachedExportFormat(dataset, formatName);\n+  public InputStream getExport(Dataset dataset, String formatName) throws ExportException, IOException {\n+    // first we will try to locate an already existing, cached export\n+    // for this format:\n+    InputStream exportInputStream = getCachedExportFormat(dataset, formatName);\n \n-        if (exportInputStream != null) {\n-            return exportInputStream;\n-        }\n-\n-        // if it doesn't exist, we'll try to run the export: \n-        exportFormat(dataset, formatName);\n+    if (exportInputStream != null) {\n+      return exportInputStream;\n+    }\n \n-        // and then try again: \n-        exportInputStream = getCachedExportFormat(dataset, formatName);\n+    // if it doesn't exist, we'll try to run the export:\n+    exportFormat(dataset, formatName);\n \n-        if (exportInputStream != null) {\n-            return exportInputStream;\n-        }\n-\n-        // if there is no cached export still - we have to give up and throw \n-        // an exception!\n-        throw new ExportException(\"Failed to export the dataset as \" + formatName);\n+    // and then try again:\n+    exportInputStream = getCachedExportFormat(dataset, formatName);\n \n+    if (exportInputStream != null) {\n+      return exportInputStream;\n     }\n \n-    public String getExportAsString(Dataset dataset, String formatName) {\n-        InputStream inputStream = null;\n-        InputStreamReader inp = null;\n-        try {\n-            inputStream = getExport(dataset, formatName);\n-            if (inputStream != null) {\n-                inp = new InputStreamReader(inputStream, \"UTF8\");\n-                BufferedReader br = new BufferedReader(inp);\n-                StringBuilder sb = new StringBuilder();\n-                String line;\n-                while ((line = br.readLine()) != null) {\n-                    sb.append(line);\n-                    sb.append('\\n');\n-                }\n-                br.close();\n-                inp.close();\n-                inputStream.close();\n-                return sb.toString();\n-            }\n-        } catch (ExportException | IOException ex) {\n-            //ex.printStackTrace();\n-            return null;\n-        } finally {\n-            IOUtils.closeQuietly(inp);\n-            IOUtils.closeQuietly(inputStream);\n+    // if there is no cached export still - we have to give up and throw\n+    // an exception!\n+    throw new ExportException(\"Failed to export the dataset as \" + formatName);\n+\n+  }\n+\n+  public String getExportAsString(Dataset dataset, String formatName) {\n+    InputStream inputStream = null;\n+    InputStreamReader inp = null;\n+    try {\n+      inputStream = getExport(dataset, formatName);\n+      if (inputStream != null) {\n+        inp = new InputStreamReader(inputStream, \"UTF8\");\n+        BufferedReader br = new BufferedReader(inp);\n+        StringBuilder sb = new StringBuilder();\n+        String line;\n+        while ((line = br.readLine()) != null) {\n+          sb.append(line);\n+          sb.append('\\n');\n         }\n-        return null;\n-\n+        br.close();\n+        inp.close();\n+        inputStream.close();\n+        return sb.toString();\n+      }\n+    } catch (ExportException | IOException ex) {\n+      //ex.printStackTrace();\n+      return null;\n+    } finally {\n+      IOUtils.closeQuietly(inp);\n+      IOUtils.closeQuietly(inputStream);\n+    }\n+    return null;\n+\n+  }\n+\n+  // This method goes through all the Exporters and calls\n+  // the \"chacheExport()\" method that will save the produced output\n+  // in a file in the dataset directory, on each Exporter available.\n+  public void exportAllFormats(Dataset dataset) throws ExportException {\n+    try {\n+      clearAllCachedFormats(dataset);\n+    } catch (IOException ex) {\n+      Logger.getLogger(ExportService.class.getName()).log(Level.SEVERE, null, ex);\n     }\n \n-    // This method goes through all the Exporters and calls \n-    // the \"chacheExport()\" method that will save the produced output  \n-    // in a file in the dataset directory, on each Exporter available. \n-    public void exportAllFormats(Dataset dataset) throws ExportException {\n-        try {\n-            clearAllCachedFormats(dataset);\n-        } catch (IOException ex) {\n-            Logger.getLogger(ExportService.class.getName()).log(Level.SEVERE, null, ex);\n-        }\n+    try {\n+      DatasetVersion releasedVersion = dataset.getReleasedVersion();\n+      if (releasedVersion == null) {\n+        throw new ExportException(\"No released version for dataset \" + dataset.getGlobalId().toString());\n+      }\n \n-        try {\n-            DatasetVersion releasedVersion = dataset.getReleasedVersion();\n-            if (releasedVersion == null) {\n-                throw new ExportException(\"No released version for dataset \" + dataset.getGlobalId().toString());\n-            }\n+      final JsonObjectBuilder datasetAsJsonBuilder = JsonPrinter.jsonAsDatasetDto(releasedVersion);\n+      JsonObject datasetAsJson = datasetAsJsonBuilder.build();\n \n-            final JsonObjectBuilder datasetAsJsonBuilder = JsonPrinter.jsonAsDatasetDto(releasedVersion);\n-            JsonObject datasetAsJson = datasetAsJsonBuilder.build();\n+      Iterator<Exporter> exporters = loader.iterator();\n+      while (exporters.hasNext()) {\n+        Exporter e = exporters.next();\n+        String formatName = e.getProviderName();\n \n-            Iterator<Exporter> exporters = loader.iterator();\n-            while (exporters.hasNext()) {\n-                Exporter e = exporters.next();\n-                String formatName = e.getProviderName();\n+        cacheExport(releasedVersion, formatName, datasetAsJson, e);\n \n-                cacheExport(releasedVersion, formatName, datasetAsJson, e);\n+      }\n+    } catch (ServiceConfigurationError serviceError) {\n+      throw new ExportException(\"Service configuration error during export. \" + serviceError.getMessage());\n+    }\n+    // Finally, if we have been able to successfully export in all available\n+    // formats, we'll increment the \"last exported\" time stamp:\n \n-            }\n-        } catch (ServiceConfigurationError serviceError) {\n-            throw new ExportException(\"Service configuration error during export. \" + serviceError.getMessage());\n-        }\n-        // Finally, if we have been able to successfully export in all available \n-        // formats, we'll increment the \"last exported\" time stamp: \n+    dataset.setLastExportTime(new Timestamp(new Date().getTime()));\n \n-        dataset.setLastExportTime(new Timestamp(new Date().getTime()));\n+  }\n \n-    }\n+  public void clearAllCachedFormats(Dataset dataset) throws IOException {\n+    try {\n+      Iterator<Exporter> exporters = loader.iterator();\n+      while (exporters.hasNext()) {\n+        Exporter e = exporters.next();\n+        String formatName = e.getProviderName();\n \n-    public void clearAllCachedFormats(Dataset dataset) throws IOException {\n-        try {\n-            Iterator<Exporter> exporters = loader.iterator();\n-            while (exporters.hasNext()) {\n-                Exporter e = exporters.next();\n-                String formatName = e.getProviderName();\n+        clearCachedExport(dataset, formatName);\n+      }\n \n-                clearCachedExport(dataset, formatName);\n-            }\n-\n-            dataset.setLastExportTime(null);\n-        } catch (IOException ex) {\n-            //not fatal\n+      dataset.setLastExportTime(null);\n+    } catch (IOException ex) {\n+      //not fatal\n+    }\n+  }\n+\n+  // This method finds the exporter for the format requested,\n+  // then produces the dataset metadata as a JsonObject, then calls\n+  // the \"cacheExport()\" method that will save the produced output\n+  // in a file in the dataset directory.\n+  public void exportFormat(Dataset dataset, String formatName) throws ExportException {\n+    try {\n+      Iterator<Exporter> exporters = loader.iterator();\n+      while (exporters.hasNext()) {\n+        Exporter e = exporters.next();\n+        if (e.getProviderName().equals(formatName)) {\n+          DatasetVersion releasedVersion = dataset.getReleasedVersion();\n+          if (releasedVersion == null) {\n+            throw new IllegalStateException(\"No Released Version\");\n+          }\n+          final JsonObjectBuilder datasetAsJsonBuilder = JsonPrinter.jsonAsDatasetDto(releasedVersion);\n+          cacheExport(releasedVersion, formatName, datasetAsJsonBuilder.build(), e);\n         }\n+      }\n+    } catch (ServiceConfigurationError serviceError) {\n+      throw new ExportException(\"Service configuration error during export. \" + serviceError.getMessage());\n+    } catch (IllegalStateException e) {\n+      throw new ExportException(\"No published version found during export. \" + dataset.getGlobalId().toString());\n     }\n+  }\n \n-    // This method finds the exporter for the format requested, \n-    // then produces the dataset metadata as a JsonObject, then calls\n-    // the \"cacheExport()\" method that will save the produced output  \n-    // in a file in the dataset directory. \n-    public void exportFormat(Dataset dataset, String formatName) throws ExportException {\n-        try {\n-            Iterator<Exporter> exporters = loader.iterator();\n-            while (exporters.hasNext()) {\n-                Exporter e = exporters.next();\n-                if (e.getProviderName().equals(formatName)) {\n-                    DatasetVersion releasedVersion = dataset.getReleasedVersion();\n-                    if (releasedVersion == null) {\n-                        throw new IllegalStateException(\"No Released Version\");\n-                    }\n-                    final JsonObjectBuilder datasetAsJsonBuilder = JsonPrinter.jsonAsDatasetDto(releasedVersion);\n-                    cacheExport(releasedVersion, formatName, datasetAsJsonBuilder.build(), e);\n-                }\n-            }\n-        } catch (ServiceConfigurationError serviceError) {\n-            throw new ExportException(\"Service configuration error during export. \" + serviceError.getMessage());\n-        } catch (IllegalStateException e) {\n-            throw new ExportException(\"No published version found during export. \" + dataset.getGlobalId().toString());\n+\n+  public Exporter getExporter(String formatName) throws ExportException {\n+    try {\n+      Iterator<Exporter> exporters = loader.iterator();\n+      while (exporters.hasNext()) {\n+        Exporter e = exporters.next();\n+        if (e.getProviderName().equals(formatName)) {\n+          return e;\n         }\n+      }\n+    } catch (ServiceConfigurationError serviceError) {\n+      throw new ExportException(\"Service configuration error during export. \" + serviceError.getMessage());\n+    } catch (Exception ex) {\n+      throw new ExportException(\"Could not find Exporter \\\"\" + formatName + \"\\\", unknown exception\");\n     }\n-    \n-\n-    public Exporter getExporter(String formatName) throws ExportException {\n-        try {\n-            Iterator<Exporter> exporters = loader.iterator();\n-            while (exporters.hasNext()) {\n-                Exporter e = exporters.next();\n-                if (e.getProviderName().equals(formatName)) {\n-                    return e;\n-                }\n-            }\n-        } catch (ServiceConfigurationError serviceError) {\n-            throw new ExportException(\"Service configuration error during export. \" + serviceError.getMessage());\n-        } catch (Exception ex) {\n-            throw new ExportException(\"Could not find Exporter \\\"\" + formatName + \"\\\", unknown exception\");\n+    throw new ExportException(\"No such Exporter: \" + formatName);\n+  }\n+\n+  // This method runs the selected metadata exporter, caching the output\n+  // in a file in the dataset directory / container based on its DOI:\n+  private void cacheExport(DatasetVersion version, String format, JsonObject datasetAsJson, Exporter exporter)\n+    throws ExportException {\n+    boolean tempFileUsed = false;\n+    File tempFile = null;\n+    OutputStream outputStream = null;\n+    Dataset dataset = version.getDataset();\n+    StorageIO<Dataset> storageIO = null;\n+    try {\n+      // With some storage drivers, we can open a WritableChannel, or OutputStream\n+      // to directly write the generated metadata export that we want to cache;\n+      // Some drivers (like Swift) do not support that, and will give us an\n+      // \"operation not supported\" exception. If that's the case, we'll have\n+      // to save the output into a temp file, and then copy it over to the\n+      // permanent storage using the IO \"save\" command:\n+      try {\n+        storageIO = DataAccess.getStorageIO(dataset);\n+        Channel outputChannel = storageIO.openAuxChannel(\"export_\" + format + \".cached\", DataAccessOption.WRITE_ACCESS);\n+        outputStream = Channels.newOutputStream((WritableByteChannel) outputChannel);\n+      } catch (IOException ioex) {\n+        // A common case = an IOException in openAuxChannel which is not supported by S3 stores for WRITE_ACCESS\n+        tempFileUsed = true;\n+        tempFile = File.createTempFile(\"tempFileToExport\", \".tmp\");\n+        outputStream = new FileOutputStream(tempFile);\n+      }\n+\n+      try {\n+        // Write the metadata export file to the outputStream, which may be the final location or a temp file\n+        exporter.exportDataset(version, datasetAsJson, outputStream);\n+        outputStream.flush();\n+        outputStream.close();\n+        if (tempFileUsed) {\n+          logger.fine(\n+            \"Saving export_\" + format + \".cached aux file from temp file: \" + Paths.get(tempFile.getAbsolutePath()));\n+          storageIO.savePathAsAux(Paths.get(tempFile.getAbsolutePath()), \"export_\" + format + \".cached\");\n+          boolean tempFileDeleted = tempFile.delete();\n+          logger.fine(\"tempFileDeleted: \" + tempFileDeleted);\n         }\n-        throw new ExportException(\"No such Exporter: \" + formatName);\n+      } catch (ExportException exex) {\n+        /*This exception is from the particular exporter and may not affect other exporters (versus other exceptions in this method which are from the basic mechanism to create a file)\n+         * So we'll catch it here and report so that loops over other exporters can continue.\n+         * Todo: Might be better to create a new exception subtype and send it upward, but the callers currently just log and ignore beyond terminating any loop over exporters.\n+         */\n+        logger.warning(\"Exception thrown while creating export_\" + format + \".cached : \" + exex.getMessage());\n+      } catch (IOException ioex) {\n+        throw new ExportException(\"IO Exception thrown exporting as \" + \"export_\" + format + \".cached\");\n+      }\n+\n+    } catch (IOException ioex) {\n+      //This catches any problem creating a local temp file in the catch clause above\n+      throw new ExportException(\"IO Exception thrown before exporting as \" + \"export_\" + format + \".cached\");\n+    } finally {\n+      IOUtils.closeQuietly(outputStream);\n     }\n \n-    // This method runs the selected metadata exporter, caching the output \n-    // in a file in the dataset directory / container based on its DOI:\n-    private void cacheExport(DatasetVersion version, String format, JsonObject datasetAsJson, Exporter exporter) throws ExportException {\n-    \tboolean tempFileUsed = false;\n-    \tFile tempFile = null;\n-    \tOutputStream outputStream = null;\n-    \tDataset dataset = version.getDataset();\n-    \tStorageIO<Dataset> storageIO = null;\n-    \ttry {\n-    \t\t// With some storage drivers, we can open a WritableChannel, or OutputStream \n-    \t\t// to directly write the generated metadata export that we want to cache; \n-    \t\t// Some drivers (like Swift) do not support that, and will give us an\n-    \t\t// \"operation not supported\" exception. If that's the case, we'll have \n-    \t\t// to save the output into a temp file, and then copy it over to the \n-    \t\t// permanent storage using the IO \"save\" command: \n-    \t\ttry {\n-    \t\t\tstorageIO = DataAccess.getStorageIO(dataset);\n-    \t\t\tChannel outputChannel = storageIO.openAuxChannel(\"export_\" + format + \".cached\", DataAccessOption.WRITE_ACCESS);\n-    \t\t\toutputStream = Channels.newOutputStream((WritableByteChannel) outputChannel);\n-    \t\t} catch (IOException ioex) {\n-    \t\t\t// A common case = an IOException in openAuxChannel which is not supported by S3 stores for WRITE_ACCESS\n-    \t\t\ttempFileUsed = true;\n-    \t\t\ttempFile = File.createTempFile(\"tempFileToExport\", \".tmp\");\n-    \t\t\toutputStream = new FileOutputStream(tempFile);\n-    \t\t}\n-\n-    \t\ttry {\n-    \t\t\t// Write the metadata export file to the outputStream, which may be the final location or a temp file\n-    \t\t\texporter.exportDataset(version, datasetAsJson, outputStream);\n-    \t\t\toutputStream.flush();\n-    \t\t\toutputStream.close();\n-    \t\t\tif(tempFileUsed) {                  \n-    \t\t\t\tlogger.fine(\"Saving export_\" + format + \".cached aux file from temp file: \" + Paths.get(tempFile.getAbsolutePath()));\n-    \t\t\t\tstorageIO.savePathAsAux(Paths.get(tempFile.getAbsolutePath()), \"export_\" + format + \".cached\");\n-    \t\t\t\tboolean tempFileDeleted = tempFile.delete();\n-    \t\t\t\tlogger.fine(\"tempFileDeleted: \" + tempFileDeleted);\n-    \t\t\t}\n-    \t\t} catch (ExportException exex) {\n-    \t\t\t/*This exception is from the particular exporter and may not affect other exporters (versus other exceptions in this method which are from the basic mechanism to create a file)\n-    \t\t\t * So we'll catch it here and report so that loops over other exporters can continue. \n-    \t\t\t * Todo: Might be better to create a new exception subtype and send it upward, but the callers currently just log and ignore beyond terminating any loop over exporters.\n-    \t\t\t */\n-    \t\t\tlogger.warning(\"Exception thrown while creating export_\" + format + \".cached : \" + exex.getMessage());\n-    \t\t} catch (IOException ioex) {\n-    \t\t\tthrow new ExportException(\"IO Exception thrown exporting as \" + \"export_\" + format + \".cached\");\n-    \t\t}\n-\n-    \t} catch (IOException ioex) {\n-    \t\t//This catches any problem creating a local temp file in the catch clause above\n-    \t\tthrow new ExportException(\"IO Exception thrown before exporting as \" + \"export_\" + format + \".cached\");\n-    \t} finally {\n-    \t\tIOUtils.closeQuietly(outputStream);\n-    \t}\n+  }\n \n-    }\n-\n-    private void clearCachedExport(Dataset dataset, String format) throws IOException {\n-        try {\n-            StorageIO<Dataset> storageIO = getStorageIO(dataset);\n-            storageIO.deleteAuxObject(\"export_\" + format + \".cached\");\n-\n-        } catch (IOException ex) {\n-            throw new IOException(\"IO Exception thrown exporting as \" + \"export_\" + format + \".cached\");\n-        }\n+  private void clearCachedExport(Dataset dataset, String format) throws IOException {\n+    try {\n+      StorageIO<Dataset> storageIO = getStorageIO(dataset);\n+      storageIO.deleteAuxObject(\"export_\" + format + \".cached\");\n \n+    } catch (IOException ex) {\n+      throw new IOException(\"IO Exception thrown exporting as \" + \"export_\" + format + \".cached\");\n     }\n \n-    // This method checks if the metadata has already been exported in this \n-    // format and cached on disk. If it has, it'll open the file and retun \n-    // the file input stream. If not, it'll return null. \n-    private InputStream getCachedExportFormat(Dataset dataset, String formatName) throws ExportException, IOException {\n+  }\n \n-        StorageIO<Dataset> dataAccess = null;\n+  // This method checks if the metadata has already been exported in this\n+  // format and cached on disk. If it has, it'll open the file and retun\n+  // the file input stream. If not, it'll return null.\n+  private InputStream getCachedExportFormat(Dataset dataset, String formatName) throws ExportException, IOException {\n \n-        try {\n-            dataAccess = DataAccess.getStorageIO(dataset);\n-        } catch (IOException ioex) {\n-            throw new IOException(\"IO Exception thrown exporting as \" + \"export_\" + formatName + \".cached\", ioex);\n-        }\n+    StorageIO<Dataset> dataAccess = null;\n \n-        InputStream cachedExportInputStream = null;\n+    try {\n+      dataAccess = DataAccess.getStorageIO(dataset);\n+    } catch (IOException ioex) {\n+      throw new IOException(\"IO Exception thrown exporting as \" + \"export_\" + formatName + \".cached\", ioex);\n+    }\n \n-        try {\n-            cachedExportInputStream = dataAccess.getAuxFileAsInputStream(\"export_\" + formatName + \".cached\");\n-            return cachedExportInputStream;\n-        } catch (IOException ioex) {\n-            throw new IOException(\"IO Exception thrown exporting as \" + \"export_\" + formatName + \".cached\", ioex);\n-        }\n+    InputStream cachedExportInputStream = null;\n \n+    try {\n+      cachedExportInputStream = dataAccess.getAuxFileAsInputStream(\"export_\" + formatName + \".cached\");\n+      return cachedExportInputStream;\n+    } catch (IOException ioex) {\n+      throw new IOException(\"IO Exception thrown exporting as \" + \"export_\" + formatName + \".cached\", ioex);\n     }\n \n-    /*The below method, getCachedExportSize(), is not currently used.\n-     *An exercise for the reader could be to refactor it if it's needed\n-     *to be compatible with storage drivers other than local filesystem.\n-     *Files.exists() would need to be discarded.\n-     * -- L.A. 4.8 */\n+  }\n+\n+  /*The below method, getCachedExportSize(), is not currently used.\n+   *An exercise for the reader could be to refactor it if it's needed\n+   *to be compatible with storage drivers other than local filesystem.\n+   *Files.exists() would need to be discarded.\n+   * -- L.A. 4.8 */\n //    public Long getCachedExportSize(Dataset dataset, String formatName) {\n //        try {\n //            if (dataset.getFileSystemDirectory() != null) {\n@@ -331,34 +332,34 @@ public class ExportService {\n //\n //        return null;\n //    }\n-    public Boolean isXMLFormat(String provider) {\n-        try {\n-            Iterator<Exporter> exporters = loader.iterator();\n-            while (exporters.hasNext()) {\n-                Exporter e = exporters.next();\n-                if (e.getProviderName().equals(provider)) {\n-                    return e.isXMLFormat();\n-                }\n-            }\n-        } catch (ServiceConfigurationError serviceError) {\n-            serviceError.printStackTrace();\n+  public Boolean isXMLFormat(String provider) {\n+    try {\n+      Iterator<Exporter> exporters = loader.iterator();\n+      while (exporters.hasNext()) {\n+        Exporter e = exporters.next();\n+        if (e.getProviderName().equals(provider)) {\n+          return e.isXMLFormat();\n         }\n-        return null;\n+      }\n+    } catch (ServiceConfigurationError serviceError) {\n+      serviceError.printStackTrace();\n     }\n-\n-\tpublic String getMediaType(String provider) {\n-\t\t try {\n-\t            Iterator<Exporter> exporters = loader.iterator();\n-\t            while (exporters.hasNext()) {\n-\t                Exporter e = exporters.next();\n-\t                if (e.getProviderName().equals(provider)) {\n-\t                    return e.getMediaType();\n-\t                }\n-\t            }\n-\t        } catch (ServiceConfigurationError serviceError) {\n-\t            serviceError.printStackTrace();\n-\t        }\n-\t        return MediaType.TEXT_PLAIN;\n-\t}\n+    return null;\n+  }\n+\n+  public String getMediaType(String provider) {\n+    try {\n+      Iterator<Exporter> exporters = loader.iterator();\n+      while (exporters.hasNext()) {\n+        Exporter e = exporters.next();\n+        if (e.getProviderName().equals(provider)) {\n+          return e.getMediaType();\n+        }\n+      }\n+    } catch (ServiceConfigurationError serviceError) {\n+      serviceError.printStackTrace();\n+    }\n+    return MediaType.TEXT_PLAIN;\n+  }\n \n }\n",
            "diff_size": 385
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "228",
                    "column": "5",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/64/ExportService.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_random/64/ExportService.java\nindex 52de3cf1d78..3dc29e022a5 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/64/ExportService.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_random/64/ExportService.java\n@@ -224,7 +224,7 @@ public class ExportService {\n     // This method runs the selected metadata exporter, caching the output \n     // in a file in the dataset directory / container based on its DOI:\n     private void cacheExport(DatasetVersion version, String format, JsonObject datasetAsJson, Exporter exporter) throws ExportException {\n-    \tboolean tempFileUsed = false;\n+    boolean tempFileUsed = false;\n     \tFile tempFile = null;\n     \tOutputStream outputStream = null;\n     \tDataset dataset = version.getDataset();\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "228",
                    "column": "5",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/64/ExportService.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_three_grams/64/ExportService.java\nindex 52de3cf1d78..387ffc0a520 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/64/ExportService.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_three_grams/64/ExportService.java\n@@ -224,7 +224,7 @@ public class ExportService {\n     // This method runs the selected metadata exporter, caching the output \n     // in a file in the dataset directory / container based on its DOI:\n     private void cacheExport(DatasetVersion version, String format, JsonObject datasetAsJson, Exporter exporter) throws ExportException {\n-    \tboolean tempFileUsed = false;\n+        boolean tempFileUsed = false;\n     \tFile tempFile = null;\n     \tOutputStream outputStream = null;\n     \tDataset dataset = version.getDataset();\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "intellij"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}