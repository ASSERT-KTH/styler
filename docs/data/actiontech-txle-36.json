{
    "project_name": "actiontech-txle",
    "error_id": "36",
    "information": {
        "errors": [
            {
                "line": "37",
                "column": "1",
                "severity": "error",
                "message": "File contains tab characters (this is the first instance).",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
            }
        ]
    },
    "source_code": " */\npublic class AutoCompensableRecovery implements AutoCompensableRecoveryPolicy {\n\tprivate static final Logger LOG = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n\n\t@Override\n\tpublic Object apply(ProceedingJoinPoint joinPoint, AutoCompensable compensable,",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "39",
                    "column": "1",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/errored/1/36/AutoCompensableRecovery.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/styler/36/AutoCompensableRecovery.java\nindex fdc90abf5a8..fbd9e9d9596 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/errored/1/36/AutoCompensableRecovery.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/styler/36/AutoCompensableRecovery.java\n@@ -34,7 +34,7 @@ import java.util.concurrent.Executors;\n  * 1.TxStartedEvent \\ | 3.TxEndedEvent \\ | ---------------------- alpha\n  */\n public class AutoCompensableRecovery implements AutoCompensableRecoveryPolicy {\n-\tprivate static final Logger LOG = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+private static final Logger LOG = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n \n \t@Override\n \tpublic Object apply(ProceedingJoinPoint joinPoint, AutoCompensable compensable,\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/errored/1/36/AutoCompensableRecovery.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/intellij/36/AutoCompensableRecovery.java\nindex fdc90abf5a8..a15b71b06be 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/errored/1/36/AutoCompensableRecovery.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/intellij/36/AutoCompensableRecovery.java\n@@ -29,89 +29,89 @@ import java.util.concurrent.Executors;\n  * events will report to alpha server before and after the execution of business\n  * logic. If there are errors while executing the business logic, a\n  * TxAbortedEvent will be reported to alpha.\n- *\n+ * <p>\n  * pre post request --------- 2.business logic --------- response \\ |\n  * 1.TxStartedEvent \\ | 3.TxEndedEvent \\ | ---------------------- alpha\n  */\n public class AutoCompensableRecovery implements AutoCompensableRecoveryPolicy {\n-\tprivate static final Logger LOG = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n-\n-\t@Override\n-\tpublic Object apply(ProceedingJoinPoint joinPoint, AutoCompensable compensable,\n-\t\t\tAutoCompensableInterceptor interceptor, OmegaContext context, String parentTxId, int retries, IAutoCompensateService autoCompensateService)\n-\t\t\tthrows Throwable {\n-\t\tMethod method = ((MethodSignature) joinPoint.getSignature()).getMethod();\n-\t\tLOG.debug(TxleConstants.logDebugPrefixWithTime() + \"Intercepting autoCompensable method {} with context {}\", method.toString(), context);\n-\n-\t\t// String retrySignature = (retries != 0 || compensationSignature.isEmpty()) ? method.toString() : \"\";\n-\t\tString retrySignature = \"\";\n-\t\tboolean isProceed = false;\n-\t\tboolean enabledTx = false;\n-\t\ttry {\n-\t\t\tString localTxId = context.localTxId();\n-\n-\t\t\t// Recording current thread identify, globalTxId and localTxId, the aim is to relate auto-compensation SQL by current thread identify. By Gannalyo\n-\t\t\tCurrentThreadOmegaContext.putThreadGlobalLocalTxId(new OmegaContextServiceConfig(context, true, false));\n-\n-\t\t\tAlphaResponse response = interceptor.preIntercept(parentTxId, TxleConstants.AUTO_COMPENSABLE_METHOD, compensable.timeout(),\n-\t\t\t\t\tretrySignature, retries, joinPoint.getArgs());\n-\t\t\tenabledTx = response.enabledTx();\n-\t\t\tCurrentThreadOmegaContext.getContextFromCurThread().setIsEnabledAutoCompensateTx(enabledTx);\n-\n-\t\t\tObject result = joinPoint.proceed();\n-\t\t\tisProceed = true;\n-\n-\t\t\tif (enabledTx) {\n-\t\t\t\tif (response.aborted()) {\n-\t\t\t\t\tcontext.setLocalTxId(parentTxId);\n-\t\t\t\t\tthrow new InvalidTransactionException(TxleConstants.LOG_ERROR_PREFIX + \"Abort sub transaction \" + localTxId\n-\t\t\t\t\t\t\t+ \" because global transaction \" + context.globalTxId() + \" has already aborted.\");\n-\t\t\t\t}\n-\n-\t\t\t\t// Remove cache after ending compensation preparation and business.\n-\t\t\t\tCurrentThreadOmegaContext.clearCache();\n-\n-\t\t\t\t// To submit the TxEndedEvent.\n-\t\t\t\tinterceptor.postIntercept(parentTxId, TxleConstants.AUTO_COMPENSABLE_METHOD);\n-\t\t\t}\n-\n-\t\t\treturn result;\n-\t\t} catch (InvalidTransactionException e) {\n-\t\t\tthrow e;\n-\t\t} catch (Throwable e) {\n-\t\t\tLOG.error(TxleConstants.LOG_ERROR_PREFIX + \"Fail to proceed business, context {}, method {}\", context, method.toString(), e);\n-\n-\t\t\tboolean isFaultTolerant = ApplicationContextUtil.getApplicationContext().getBean(MessageSender.class).readConfigFromServer(ConfigCenterType.CompensationFaultTolerant.toInteger(), context.category()).getStatus();\n-\t\t\tif (enabledTx && !isFaultTolerant) {\n-\t\t\t\tinterceptor.onError(parentTxId, TxleConstants.AUTO_COMPENSABLE_METHOD, e);\n-\t\t\t}\n-\n-\t\t\t// In case of exception, to execute business if it is not proceed yet when the fault-tolerant degradation is enabled fro global transaction.\n-\t\t\tif (!isProceed && isFaultTolerant) {\n-\t\t\t\treturn joinPoint.proceed();\n-\t\t\t}\n-\n-\t\t\t// So far, it cannot call auto-compensation method immediately due to every Omega has itself DB-link. By Gannalyo\n-\t\t\tthrow e;\n-\t\t} finally {\n-\t\t\tclearDataSourceMappingCache(interceptor);\n-\t\t}\n-\t}\n-\n-\tprivate void clearDataSourceMappingCache(AutoCompensableInterceptor interceptor) {\n-\t\ttry {\n-\t\t\t// To clear cache for datasource mapping when the cache size is more than fifty.\n-\t\t\tSet<String> localTxIdSet = DataSourceMappingCache.getCacheLocalTxIdSet();\n-\t\t\tif (localTxIdSet != null && localTxIdSet.size() > 0) {\n-\t\t\t\t// Open a new thread for saving time of the main thread.\n-\t\t\t\t// TODO batch to clear\n-\t\t\t\tExecutorService executorService = Executors.newSingleThreadExecutor();\n-\t\t\t\texecutorService.execute(() -> DataSourceMappingCache.clear(interceptor.fetchLocalTxIdOfEndedGlobalTx(localTxIdSet)));\n-\t\t\t\texecutorService.shutdown();\n-\t\t\t}\n-\t\t} catch (Exception e) {\n-\t\t\tLOG.error(TxleConstants.LOG_ERROR_PREFIX + \"Failed to clear cache for the datasource mapping. \" + e.getMessage());\n-\t\t}\n-\t}\n+    private static final Logger LOG = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    @Override\n+    public Object apply(ProceedingJoinPoint joinPoint, AutoCompensable compensable,\n+                        AutoCompensableInterceptor interceptor, OmegaContext context, String parentTxId, int retries, IAutoCompensateService autoCompensateService)\n+            throws Throwable {\n+        Method method = ((MethodSignature) joinPoint.getSignature()).getMethod();\n+        LOG.debug(TxleConstants.logDebugPrefixWithTime() + \"Intercepting autoCompensable method {} with context {}\", method.toString(), context);\n+\n+        // String retrySignature = (retries != 0 || compensationSignature.isEmpty()) ? method.toString() : \"\";\n+        String retrySignature = \"\";\n+        boolean isProceed = false;\n+        boolean enabledTx = false;\n+        try {\n+            String localTxId = context.localTxId();\n+\n+            // Recording current thread identify, globalTxId and localTxId, the aim is to relate auto-compensation SQL by current thread identify. By Gannalyo\n+            CurrentThreadOmegaContext.putThreadGlobalLocalTxId(new OmegaContextServiceConfig(context, true, false));\n+\n+            AlphaResponse response = interceptor.preIntercept(parentTxId, TxleConstants.AUTO_COMPENSABLE_METHOD, compensable.timeout(),\n+                    retrySignature, retries, joinPoint.getArgs());\n+            enabledTx = response.enabledTx();\n+            CurrentThreadOmegaContext.getContextFromCurThread().setIsEnabledAutoCompensateTx(enabledTx);\n+\n+            Object result = joinPoint.proceed();\n+            isProceed = true;\n+\n+            if (enabledTx) {\n+                if (response.aborted()) {\n+                    context.setLocalTxId(parentTxId);\n+                    throw new InvalidTransactionException(TxleConstants.LOG_ERROR_PREFIX + \"Abort sub transaction \" + localTxId\n+                            + \" because global transaction \" + context.globalTxId() + \" has already aborted.\");\n+                }\n+\n+                // Remove cache after ending compensation preparation and business.\n+                CurrentThreadOmegaContext.clearCache();\n+\n+                // To submit the TxEndedEvent.\n+                interceptor.postIntercept(parentTxId, TxleConstants.AUTO_COMPENSABLE_METHOD);\n+            }\n+\n+            return result;\n+        } catch (InvalidTransactionException e) {\n+            throw e;\n+        } catch (Throwable e) {\n+            LOG.error(TxleConstants.LOG_ERROR_PREFIX + \"Fail to proceed business, context {}, method {}\", context, method.toString(), e);\n+\n+            boolean isFaultTolerant = ApplicationContextUtil.getApplicationContext().getBean(MessageSender.class).readConfigFromServer(ConfigCenterType.CompensationFaultTolerant.toInteger(), context.category()).getStatus();\n+            if (enabledTx && !isFaultTolerant) {\n+                interceptor.onError(parentTxId, TxleConstants.AUTO_COMPENSABLE_METHOD, e);\n+            }\n+\n+            // In case of exception, to execute business if it is not proceed yet when the fault-tolerant degradation is enabled fro global transaction.\n+            if (!isProceed && isFaultTolerant) {\n+                return joinPoint.proceed();\n+            }\n+\n+            // So far, it cannot call auto-compensation method immediately due to every Omega has itself DB-link. By Gannalyo\n+            throw e;\n+        } finally {\n+            clearDataSourceMappingCache(interceptor);\n+        }\n+    }\n+\n+    private void clearDataSourceMappingCache(AutoCompensableInterceptor interceptor) {\n+        try {\n+            // To clear cache for datasource mapping when the cache size is more than fifty.\n+            Set<String> localTxIdSet = DataSourceMappingCache.getCacheLocalTxIdSet();\n+            if (localTxIdSet != null && localTxIdSet.size() > 0) {\n+                // Open a new thread for saving time of the main thread.\n+                // TODO batch to clear\n+                ExecutorService executorService = Executors.newSingleThreadExecutor();\n+                executorService.execute(() -> DataSourceMappingCache.clear(interceptor.fetchLocalTxIdOfEndedGlobalTx(localTxIdSet)));\n+                executorService.shutdown();\n+            }\n+        } catch (Exception e) {\n+            LOG.error(TxleConstants.LOG_ERROR_PREFIX + \"Failed to clear cache for the datasource mapping. \" + e.getMessage());\n+        }\n+    }\n \n }\n",
            "diff_size": 80
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "39",
                    "column": "1",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/errored/1/36/AutoCompensableRecovery.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/naturalize/36/AutoCompensableRecovery.java\nindex fdc90abf5a8..1b9a4d9803a 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/errored/1/36/AutoCompensableRecovery.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/naturalize/36/AutoCompensableRecovery.java\n@@ -34,13 +34,11 @@ import java.util.concurrent.Executors;\n  * 1.TxStartedEvent \\ | 3.TxEndedEvent \\ | ---------------------- alpha\n  */\n public class AutoCompensableRecovery implements AutoCompensableRecoveryPolicy {\n-\tprivate static final Logger LOG = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+    private static final Logger LOG = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n \n \t@Override\n-\tpublic Object apply(ProceedingJoinPoint joinPoint, AutoCompensable compensable,\n-\t\t\tAutoCompensableInterceptor interceptor, OmegaContext context, String parentTxId, int retries, IAutoCompensateService autoCompensateService)\n-\t\t\tthrows Throwable {\n-\t\tMethod method = ((MethodSignature) joinPoint.getSignature()).getMethod();\n+\tpublic Object apply(ProceedingJoinPoint joinPoint, AutoCompensable compensable, AutoCompensableInterceptor interceptor, OmegaContext context, String parentTxId, int retries, IAutoCompensateService autoCompensateService) throws Throwable {\n+    Method method = ((MethodSignature) joinPoint.getSignature()).getMethod();\n \t\tLOG.debug(TxleConstants.logDebugPrefixWithTime() + \"Intercepting autoCompensable method {} with context {}\", method.toString(), context);\n \n \t\t// String retrySignature = (retries != 0 || compensationSignature.isEmpty()) ? method.toString() : \"\";\n@@ -48,70 +46,67 @@ public class AutoCompensableRecovery implements AutoCompensableRecoveryPolicy {\n \t\tboolean isProceed = false;\n \t\tboolean enabledTx = false;\n \t\ttry {\n-\t\t\tString localTxId = context.localTxId();\n+    String localTxId = context.localTxId();\n \n \t\t\t// Recording current thread identify, globalTxId and localTxId, the aim is to relate auto-compensation SQL by current thread identify. By Gannalyo\n \t\t\tCurrentThreadOmegaContext.putThreadGlobalLocalTxId(new OmegaContextServiceConfig(context, true, false));\n \n-\t\t\tAlphaResponse response = interceptor.preIntercept(parentTxId, TxleConstants.AUTO_COMPENSABLE_METHOD, compensable.timeout(),\n-\t\t\t\t\tretrySignature, retries, joinPoint.getArgs());\n-\t\t\tenabledTx = response.enabledTx();\n+\t\t\tAlphaResponse response = interceptor.preIntercept(parentTxId, TxleConstants.AUTO_COMPENSABLE_METHOD, compensable.timeout(), retrySignature, retries, joinPoint.getArgs());\n+enabledTx = response.enabledTx();\n \t\t\tCurrentThreadOmegaContext.getContextFromCurThread().setIsEnabledAutoCompensateTx(enabledTx);\n \n \t\t\tObject result = joinPoint.proceed();\n \t\t\tisProceed = true;\n \n \t\t\tif (enabledTx) {\n-\t\t\t\tif (response.aborted()) {\n-\t\t\t\t\tcontext.setLocalTxId(parentTxId);\n-\t\t\t\t\tthrow new InvalidTransactionException(TxleConstants.LOG_ERROR_PREFIX + \"Abort sub transaction \" + localTxId\n-\t\t\t\t\t\t\t+ \" because global transaction \" + context.globalTxId() + \" has already aborted.\");\n-\t\t\t\t}\n+    if (response.aborted()) {\n+    context.setLocalTxId(parentTxId);\n+\t\t\t\t\tthrow new InvalidTransactionException(TxleConstants.LOG_ERROR_PREFIX + \"Abort sub transaction \" + localTxId + \" because global transaction \" + context.globalTxId() + \" has already aborted.\");\n+    }\n \n \t\t\t\t// Remove cache after ending compensation preparation and business.\n \t\t\t\tCurrentThreadOmegaContext.clearCache();\n \n \t\t\t\t// To submit the TxEndedEvent.\n \t\t\t\tinterceptor.postIntercept(parentTxId, TxleConstants.AUTO_COMPENSABLE_METHOD);\n-\t\t\t}\n+    }\n \n \t\t\treturn result;\n-\t\t} catch (InvalidTransactionException e) {\n-\t\t\tthrow e;\n-\t\t} catch (Throwable e) {\n-\t\t\tLOG.error(TxleConstants.LOG_ERROR_PREFIX + \"Fail to proceed business, context {}, method {}\", context, method.toString(), e);\n+    } catch (InvalidTransactionException e) {\n+  throw e;\n+    } catch (Throwable e) {\n+    LOG.error(TxleConstants.LOG_ERROR_PREFIX + \"Fail to proceed business, context {}, method {}\", context, method.toString(), e);\n \n \t\t\tboolean isFaultTolerant = ApplicationContextUtil.getApplicationContext().getBean(MessageSender.class).readConfigFromServer(ConfigCenterType.CompensationFaultTolerant.toInteger(), context.category()).getStatus();\n \t\t\tif (enabledTx && !isFaultTolerant) {\n-\t\t\t\tinterceptor.onError(parentTxId, TxleConstants.AUTO_COMPENSABLE_METHOD, e);\n-\t\t\t}\n+    interceptor.onError(parentTxId, TxleConstants.AUTO_COMPENSABLE_METHOD, e);\n+    }\n \n \t\t\t// In case of exception, to execute business if it is not proceed yet when the fault-tolerant degradation is enabled fro global transaction.\n \t\t\tif (!isProceed && isFaultTolerant) {\n-\t\t\t\treturn joinPoint.proceed();\n-\t\t\t}\n+    return joinPoint.proceed();\n+    }\n \n \t\t\t// So far, it cannot call auto-compensation method immediately due to every Omega has itself DB-link. By Gannalyo\n \t\t\tthrow e;\n-\t\t} finally {\n-\t\t\tclearDataSourceMappingCache(interceptor);\n-\t\t}\n-\t}\n+    } finally {\n+    clearDataSourceMappingCache(interceptor);\n+    }\n+    }\n \n \tprivate void clearDataSourceMappingCache(AutoCompensableInterceptor interceptor) {\n-\t\ttry {\n-\t\t\t// To clear cache for datasource mapping when the cache size is more than fifty.\n+    try {\n+    // To clear cache for datasource mapping when the cache size is more than fifty.\n \t\t\tSet<String> localTxIdSet = DataSourceMappingCache.getCacheLocalTxIdSet();\n \t\t\tif (localTxIdSet != null && localTxIdSet.size() > 0) {\n-\t\t\t\t// Open a new thread for saving time of the main thread.\n+    // Open a new thread for saving time of the main thread.\n \t\t\t\t// TODO batch to clear\n \t\t\t\tExecutorService executorService = Executors.newSingleThreadExecutor();\n \t\t\t\texecutorService.execute(() -> DataSourceMappingCache.clear(interceptor.fetchLocalTxIdOfEndedGlobalTx(localTxIdSet)));\n \t\t\t\texecutorService.shutdown();\n-\t\t\t}\n-\t\t} catch (Exception e) {\n-\t\t\tLOG.error(TxleConstants.LOG_ERROR_PREFIX + \"Failed to clear cache for the datasource mapping. \" + e.getMessage());\n-\t\t}\n-\t}\n-\n-}\n+    }\n+    } catch (Exception e) {\n+    LOG.error(TxleConstants.LOG_ERROR_PREFIX + \"Failed to clear cache for the datasource mapping. \" + e.getMessage());\n+    }\n+    }\n+    }\n\\ No newline at end of file\n",
            "diff_size": 37
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/errored/1/36/AutoCompensableRecovery.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/codebuff/36/AutoCompensableRecovery.java\nindex fdc90abf5a8..cf7e8edf31a 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/errored/1/36/AutoCompensableRecovery.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/codebuff/36/AutoCompensableRecovery.java\n@@ -16,7 +16,6 @@ import org.aspectj.lang.ProceedingJoinPoint;\n import org.aspectj.lang.reflect.MethodSignature;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-\n import javax.transaction.InvalidTransactionException;\n import java.lang.invoke.MethodHandles;\n import java.lang.reflect.Method;\n@@ -33,85 +32,82 @@ import java.util.concurrent.Executors;\n  * pre post request --------- 2.business logic --------- response \\ |\n  * 1.TxStartedEvent \\ | 3.TxEndedEvent \\ | ---------------------- alpha\n  */\n-public class AutoCompensableRecovery implements AutoCompensableRecoveryPolicy {\n-\tprivate static final Logger LOG = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n-\n-\t@Override\n-\tpublic Object apply(ProceedingJoinPoint joinPoint, AutoCompensable compensable,\n-\t\t\tAutoCompensableInterceptor interceptor, OmegaContext context, String parentTxId, int retries, IAutoCompensateService autoCompensateService)\n-\t\t\tthrows Throwable {\n-\t\tMethod method = ((MethodSignature) joinPoint.getSignature()).getMethod();\n-\t\tLOG.debug(TxleConstants.logDebugPrefixWithTime() + \"Intercepting autoCompensable method {} with context {}\", method.toString(), context);\n-\n-\t\t// String retrySignature = (retries != 0 || compensationSignature.isEmpty()) ? method.toString() : \"\";\n-\t\tString retrySignature = \"\";\n-\t\tboolean isProceed = false;\n-\t\tboolean enabledTx = false;\n-\t\ttry {\n-\t\t\tString localTxId = context.localTxId();\n-\n-\t\t\t// Recording current thread identify, globalTxId and localTxId, the aim is to relate auto-compensation SQL by current thread identify. By Gannalyo\n-\t\t\tCurrentThreadOmegaContext.putThreadGlobalLocalTxId(new OmegaContextServiceConfig(context, true, false));\n-\n-\t\t\tAlphaResponse response = interceptor.preIntercept(parentTxId, TxleConstants.AUTO_COMPENSABLE_METHOD, compensable.timeout(),\n-\t\t\t\t\tretrySignature, retries, joinPoint.getArgs());\n-\t\t\tenabledTx = response.enabledTx();\n-\t\t\tCurrentThreadOmegaContext.getContextFromCurThread().setIsEnabledAutoCompensateTx(enabledTx);\n-\n-\t\t\tObject result = joinPoint.proceed();\n-\t\t\tisProceed = true;\n-\n-\t\t\tif (enabledTx) {\n-\t\t\t\tif (response.aborted()) {\n-\t\t\t\t\tcontext.setLocalTxId(parentTxId);\n-\t\t\t\t\tthrow new InvalidTransactionException(TxleConstants.LOG_ERROR_PREFIX + \"Abort sub transaction \" + localTxId\n-\t\t\t\t\t\t\t+ \" because global transaction \" + context.globalTxId() + \" has already aborted.\");\n-\t\t\t\t}\n \n-\t\t\t\t// Remove cache after ending compensation preparation and business.\n-\t\t\t\tCurrentThreadOmegaContext.clearCache();\n-\n-\t\t\t\t// To submit the TxEndedEvent.\n-\t\t\t\tinterceptor.postIntercept(parentTxId, TxleConstants.AUTO_COMPENSABLE_METHOD);\n-\t\t\t}\n-\n-\t\t\treturn result;\n-\t\t} catch (InvalidTransactionException e) {\n-\t\t\tthrow e;\n-\t\t} catch (Throwable e) {\n-\t\t\tLOG.error(TxleConstants.LOG_ERROR_PREFIX + \"Fail to proceed business, context {}, method {}\", context, method.toString(), e);\n-\n-\t\t\tboolean isFaultTolerant = ApplicationContextUtil.getApplicationContext().getBean(MessageSender.class).readConfigFromServer(ConfigCenterType.CompensationFaultTolerant.toInteger(), context.category()).getStatus();\n-\t\t\tif (enabledTx && !isFaultTolerant) {\n-\t\t\t\tinterceptor.onError(parentTxId, TxleConstants.AUTO_COMPENSABLE_METHOD, e);\n-\t\t\t}\n-\n-\t\t\t// In case of exception, to execute business if it is not proceed yet when the fault-tolerant degradation is enabled fro global transaction.\n-\t\t\tif (!isProceed && isFaultTolerant) {\n-\t\t\t\treturn joinPoint.proceed();\n-\t\t\t}\n-\n-\t\t\t// So far, it cannot call auto-compensation method immediately due to every Omega has itself DB-link. By Gannalyo\n-\t\t\tthrow e;\n-\t\t} finally {\n-\t\t\tclearDataSourceMappingCache(interceptor);\n-\t\t}\n-\t}\n-\n-\tprivate void clearDataSourceMappingCache(AutoCompensableInterceptor interceptor) {\n-\t\ttry {\n-\t\t\t// To clear cache for datasource mapping when the cache size is more than fifty.\n-\t\t\tSet<String> localTxIdSet = DataSourceMappingCache.getCacheLocalTxIdSet();\n-\t\t\tif (localTxIdSet != null && localTxIdSet.size() > 0) {\n-\t\t\t\t// Open a new thread for saving time of the main thread.\n-\t\t\t\t// TODO batch to clear\n-\t\t\t\tExecutorService executorService = Executors.newSingleThreadExecutor();\n-\t\t\t\texecutorService.execute(() -> DataSourceMappingCache.clear(interceptor.fetchLocalTxIdOfEndedGlobalTx(localTxIdSet)));\n-\t\t\t\texecutorService.shutdown();\n-\t\t\t}\n-\t\t} catch (Exception e) {\n-\t\t\tLOG.error(TxleConstants.LOG_ERROR_PREFIX + \"Failed to clear cache for the datasource mapping. \" + e.getMessage());\n-\t\t}\n-\t}\n-\n-}\n+public class AutoCompensableRecovery implements AutoCompensableRecoveryPolicy {\n+    private static final Logger LOG = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    @Override\n+    public Object apply(\n+ProceedingJoinPoint joinPoint,\n+AutoCompensable compensable,\n+AutoCompensableInterceptor interceptor,\n+OmegaContext context,\n+String parentTxId,\n+int retries, IAutoCompensateService autoCompensateService) throws Throwable {\n+        Method method = ((MethodSignature) joinPoint.getSignature()).getMethod();\n+        LOG.debug(TxleConstants.logDebugPrefixWithTime() + \"Intercepting autoCompensable method {} with context {}\", method.toString(), context);\n+\n+        // String retrySignature = (retries != 0 || compensationSignature.isEmpty()) ? method.toString() : \"\";\n+        String retrySignature = \"\";\n+        boolean isProceed = false;\n+        boolean enabledTx = false;\n+        try {\n+            String localTxId = context.localTxId();\n+\n+            // Recording current thread identify, globalTxId and localTxId, the aim is to relate auto-compensation SQL by current thread identify. By Gannalyo\n+            CurrentThreadOmegaContext.putThreadGlobalLocalTxId(new OmegaContextServiceConfig(context, true, false));\n+            AlphaResponse response = interceptor.preIntercept(parentTxId, TxleConstants.AUTO_COMPENSABLE_METHOD, compensable.timeout(), retrySignature, retries, joinPoint.getArgs());\n+            enabledTx = response.enabledTx();\n+            CurrentThreadOmegaContext.getContextFromCurThread().setIsEnabledAutoCompensateTx(enabledTx);\n+            Object result = joinPoint.proceed();\n+            isProceed = true;\n+            if (enabledTx) {\n+                if (response.aborted()) {\n+                    context.setLocalTxId(parentTxId);\n+                    throw new InvalidTransactionException(TxleConstants.LOG_ERROR_PREFIX + \"Abort sub transaction \" + localTxId + \" because global transaction \" + context.globalTxId() + \" has already aborted.\");\n+                }\n+\n+                // Remove cache after ending compensation preparation and business.\n+                CurrentThreadOmegaContext.clearCache();\n+\n+                // To submit the TxEndedEvent.\n+                interceptor.postIntercept(parentTxId, TxleConstants.AUTO_COMPENSABLE_METHOD);\n+            }\n+            return result;\n+        } catch (InvalidTransactionException e) {\n+            throw e;\n+        } catch (Throwable e) {\n+            LOG.error(TxleConstants.LOG_ERROR_PREFIX + \"Fail to proceed business, context {}, method {}\", context, method.toString(), e);\n+            boolean isFaultTolerant = ApplicationContextUtil.getApplicationContext().getBean(MessageSender.class).readConfigFromServer(ConfigCenterType.CompensationFaultTolerant.toInteger(), context.category()).getStatus();\n+            if (enabledTx && !isFaultTolerant) {\n+                interceptor.onError(parentTxId, TxleConstants.AUTO_COMPENSABLE_METHOD, e);\n+            }\n+\n+            // In case of exception, to execute business if it is not proceed yet when the fault-tolerant degradation is enabled fro global transaction.\n+            if (!isProceed && isFaultTolerant) {\n+                return joinPoint.proceed();\n+            }\n+\n+            // So far, it cannot call auto-compensation method immediately due to every Omega has itself DB-link. By Gannalyo\n+            throw e;\n+        } finally {\n+            clearDataSourceMappingCache(interceptor);\n+        }\n+    }\n+\n+    private void clearDataSourceMappingCache(AutoCompensableInterceptor interceptor) {\n+        try {\n+            // To clear cache for datasource mapping when the cache size is more than fifty.\n+            Set<String> localTxIdSet = DataSourceMappingCache.getCacheLocalTxIdSet();\n+            if (localTxIdSet != null && localTxIdSet.size() > 0) {\n+                // Open a new thread for saving time of the main thread.\n+                // TODO batch to clear\n+                ExecutorService executorService = Executors.newSingleThreadExecutor();\n+                executorService.execute(() -> DataSourceMappingCache.clear(interceptor.fetchLocalTxIdOfEndedGlobalTx(localTxIdSet)));\n+                executorService.shutdown();\n+            }\n+        } catch (Exception e) {\n+            LOG.error(TxleConstants.LOG_ERROR_PREFIX + \"Failed to clear cache for the datasource mapping. \" + e.getMessage());\n+        }\n+    }\n+}\n\\ No newline at end of file\n",
            "diff_size": 113
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "39",
                    "column": "1",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/errored/1/36/AutoCompensableRecovery.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/styler_random/36/AutoCompensableRecovery.java\nindex fdc90abf5a8..fbd9e9d9596 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/errored/1/36/AutoCompensableRecovery.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/styler_random/36/AutoCompensableRecovery.java\n@@ -34,7 +34,7 @@ import java.util.concurrent.Executors;\n  * 1.TxStartedEvent \\ | 3.TxEndedEvent \\ | ---------------------- alpha\n  */\n public class AutoCompensableRecovery implements AutoCompensableRecoveryPolicy {\n-\tprivate static final Logger LOG = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+private static final Logger LOG = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n \n \t@Override\n \tpublic Object apply(ProceedingJoinPoint joinPoint, AutoCompensable compensable,\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "39",
                    "column": "1",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/errored/1/36/AutoCompensableRecovery.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/styler_three_grams/36/AutoCompensableRecovery.java\nindex fdc90abf5a8..3c9ddeb205a 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/errored/1/36/AutoCompensableRecovery.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/actiontech-txle/styler_three_grams/36/AutoCompensableRecovery.java\n@@ -34,7 +34,7 @@ import java.util.concurrent.Executors;\n  * 1.TxStartedEvent \\ | 3.TxEndedEvent \\ | ---------------------- alpha\n  */\n public class AutoCompensableRecovery implements AutoCompensableRecoveryPolicy {\n-\tprivate static final Logger LOG = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+    private static final Logger LOG = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n \n \t@Override\n \tpublic Object apply(ProceedingJoinPoint joinPoint, AutoCompensable compensable,\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "intellij",
        "codebuff"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "styler_random",
        "styler_three_grams"
    ]
}