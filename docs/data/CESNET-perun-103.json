{
    "project_name": "CESNET-perun",
    "error_id": "103",
    "information": {
        "errors": [
            {
                "line": "78",
                "severity": "error",
                "message": "Line matches the illegal pattern 'Wrong number of tabs before space on next line. Indent must use tab characters.'.",
                "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpCheck"
            }
        ]
    },
    "source_code": "\t}\n\n\tpublic SchedulingPoolImpl(Properties dispatcherPropertiesBean, TaskStore taskStore,\n\t\t\t\t\t\t\t  TasksManagerBl tasksManagerBl, EngineMessageProducerPool engineMessageProducerPool) {\n\t\tthis.dispatcherProperties = dispatcherPropertiesBean;\n\t\tthis.taskStore = taskStore;",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/103/SchedulingPoolImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/styler/103/SchedulingPoolImpl.java\nindex 0b8208d85c5..9730edbc6aa 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/103/SchedulingPoolImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/styler/103/SchedulingPoolImpl.java\n@@ -76,7 +76,7 @@ public class SchedulingPoolImpl implements SchedulingPool {\n \t}\n \n \tpublic SchedulingPoolImpl(Properties dispatcherPropertiesBean, TaskStore taskStore,\n-\t\t\t\t\t\t\t  TasksManagerBl tasksManagerBl, EngineMessageProducerPool engineMessageProducerPool) {\n+\t\t\tTasksManagerBl tasksManagerBl, EngineMessageProducerPool engineMessageProducerPool) {\n \t\tthis.dispatcherProperties = dispatcherPropertiesBean;\n \t\tthis.taskStore = taskStore;\n \t\tthis.tasksManagerBl = tasksManagerBl;\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/103/SchedulingPoolImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/intellij/103/SchedulingPoolImpl.java\nindex 0b8208d85c5..390be2aecd0 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/103/SchedulingPoolImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/intellij/103/SchedulingPoolImpl.java\n@@ -49,557 +49,562 @@ import javax.annotation.Resource;\n /**\n  * Implementation of SchedulingPool.\n  *\n- * @see cz.metacentrum.perun.dispatcher.scheduling.SchedulingPool\n- *\n  * @author Michal Voc\u016f\n  * @author Michal Babacek\n  * @author David \u0160arman\n  * @author Pavel Zl\u00e1mal <zlamal@cesnet.cz>\n+ * @see cz.metacentrum.perun.dispatcher.scheduling.SchedulingPool\n  */\n @org.springframework.stereotype.Service(\"schedulingPool\")\n public class SchedulingPoolImpl implements SchedulingPool {\n \n-\tprivate final static Logger log = LoggerFactory.getLogger(SchedulingPoolImpl.class);\n+    private final static Logger log = LoggerFactory.getLogger(SchedulingPoolImpl.class);\n \n-\tprivate final Map<Integer, EngineMessageProducer> enginesByTaskId = new HashMap<>();\n-\tprivate PerunSession sess;\n+    private final Map<Integer, EngineMessageProducer> enginesByTaskId = new HashMap<>();\n+    private PerunSession sess;\n \n-\tprivate DelayQueue<TaskSchedule> waitingTasksQueue;\n-\tprivate DelayQueue<TaskSchedule> waitingForcedTasksQueue;\n-\tprivate Properties dispatcherProperties;\n-\tprivate TaskStore taskStore;\n-\tprivate TasksManagerBl tasksManagerBl;\n-\tprivate EngineMessageProducerPool engineMessageProducerPool;\n-\tprivate Perun perun;\n+    private DelayQueue<TaskSchedule> waitingTasksQueue;\n+    private DelayQueue<TaskSchedule> waitingForcedTasksQueue;\n+    private Properties dispatcherProperties;\n+    private TaskStore taskStore;\n+    private TasksManagerBl tasksManagerBl;\n+    private EngineMessageProducerPool engineMessageProducerPool;\n+    private Perun perun;\n \n-\tpublic SchedulingPoolImpl() {\n-\t}\n+    public SchedulingPoolImpl() {\n+    }\n \n-\tpublic SchedulingPoolImpl(Properties dispatcherPropertiesBean, TaskStore taskStore,\n-\t\t\t\t\t\t\t  TasksManagerBl tasksManagerBl, EngineMessageProducerPool engineMessageProducerPool) {\n-\t\tthis.dispatcherProperties = dispatcherPropertiesBean;\n-\t\tthis.taskStore = taskStore;\n-\t\tthis.tasksManagerBl = tasksManagerBl;\n-\t\tthis.engineMessageProducerPool = engineMessageProducerPool;\n-\t}\n+    public SchedulingPoolImpl(Properties dispatcherPropertiesBean, TaskStore taskStore,\n+                              TasksManagerBl tasksManagerBl, EngineMessageProducerPool engineMessageProducerPool) {\n+        this.dispatcherProperties = dispatcherPropertiesBean;\n+        this.taskStore = taskStore;\n+        this.tasksManagerBl = tasksManagerBl;\n+        this.engineMessageProducerPool = engineMessageProducerPool;\n+    }\n \n \n-\t// ----- setters -------------------------------------\n+    // ----- setters -------------------------------------\n \n \n-\tpublic DelayQueue<TaskSchedule> getWaitingTasksQueue() {\n-\t\treturn waitingTasksQueue;\n-\t}\n+    public DelayQueue<TaskSchedule> getWaitingTasksQueue() {\n+        return waitingTasksQueue;\n+    }\n \n-\t@Autowired\n-\tpublic void setWaitingTasksQueue(DelayQueue<TaskSchedule> waitingTasksQueue) {\n-\t\tthis.waitingTasksQueue = waitingTasksQueue;\n-\t}\n+    @Autowired\n+    public void setWaitingTasksQueue(DelayQueue<TaskSchedule> waitingTasksQueue) {\n+        this.waitingTasksQueue = waitingTasksQueue;\n+    }\n \n-\tpublic DelayQueue<TaskSchedule> getWaitingForcedTasksQueue() {\n-\t\treturn waitingForcedTasksQueue;\n-\t}\n-\n-\t@Autowired\n-\tpublic void setWaitingForcedTasksQueue(DelayQueue<TaskSchedule> waitingForcedTasksQueue) {\n-\t\tthis.waitingForcedTasksQueue = waitingForcedTasksQueue;\n-\t}\n-\n-\tpublic Properties getDispatcherProperties() {\n-\t\treturn dispatcherProperties;\n-\t}\n-\n-\t@Resource(name=\"dispatcherPropertiesBean\")\n-\tpublic void setDispatcherProperties(Properties dispatcherProperties) {\n-\t\tthis.dispatcherProperties = dispatcherProperties;\n-\t}\n-\n-\tpublic TaskStore getTaskStore() {\n-\t\treturn taskStore;\n-\t}\n-\n-\t@Autowired\n-\tpublic void setTaskStore(TaskStore taskStore) {\n-\t\tthis.taskStore = taskStore;\n-\t}\n-\n-\tpublic TasksManagerBl getTasksManagerBl() {\n-\t\treturn tasksManagerBl;\n-\t}\n-\n-\t@Autowired\n-\tpublic void setTasksManagerBl(TasksManagerBl tasksManagerBl) {\n-\t\tthis.tasksManagerBl = tasksManagerBl;\n-\t}\n-\n-\tpublic EngineMessageProducerPool getEngineMessageProducerPool() {\n-\t\treturn engineMessageProducerPool;\n-\t}\n-\n-\t@Autowired\n-\tpublic void setEngineMessageProducerPool(EngineMessageProducerPool engineMessageProducerPool) {\n-\t\tthis.engineMessageProducerPool = engineMessageProducerPool;\n-\t}\n-\n-\tpublic Perun getPerun() {\n-\t\treturn perun;\n-\t}\n-\n-\t@Autowired\n-\tpublic void setPerun(Perun perun) {\n-\t\tthis.perun = perun;\n-\t}\n-\n-\n-\t// ----- methods -------------------------------------\n-\n-\n-\t@Override\n-\tpublic Task getTask(int id) {\n-\t\treturn taskStore.getTask(id);\n-\t}\n-\n-\t@Override\n-\tpublic Task getTask(Facility facility, Service service) {\n-\t\treturn taskStore.getTask(facility, service);\n-\t}\n-\n-\t@Override\n-\tpublic int getSize() {\n-\t\treturn taskStore.getSize();\n-\t}\n-\n-\t@Override\n-\tpublic Task addTask(Task task) throws TaskStoreException {\n-\t\treturn taskStore.addTask(task);\n-\t}\n-\n-\t@Override\n-\tpublic Collection<Task> getAllTasks() {\n-\t\treturn taskStore.getAllTasks();\n-\t}\n-\n-\t@Override\n-\tpublic List<Task> getTasksWithStatus(TaskStatus... status) {\n-\t\treturn taskStore.getTasksWithStatus(status);\n-\t}\n-\n-\t@Override\n-\tpublic Task removeTask(Task task) throws TaskStoreException {\n-\t\treturn taskStore.removeTask(task);\n-\t}\n-\n-\t@Override\n-\tpublic void scheduleTask(Task task, int delayCount) {\n-\n-\t\t// init session\n-\t\ttry {\n-\t\t\tif (sess == null) {\n-\t\t\t\tsess = perun.getPerunSession(new PerunPrincipal(\n-\t\t\t\t\t\t\t\tdispatcherProperties.getProperty(\"perun.principal.name\"),\n-\t\t\t\t\t\t\t\tdispatcherProperties.getProperty(\"perun.principal.extSourceName\"),\n-\t\t\t\t\t\t\t\tdispatcherProperties.getProperty(\"perun.principal.extSourceType\")),\n-\t\t\t\t\t\tnew PerunClient());\n-\t\t\t}\n-\t\t} catch (InternalErrorException e1) {\n-\t\t\tlog.error(\"Error establishing perun session to add task schedule: \", e1);\n-\t\t\treturn;\n-\t\t}\n-\n-\t\t// check if service/facility exists\n-\n-\t\tboolean removeTask = false;\n-\n-\t\ttry {\n-\t\t\tService service = perun.getServicesManager().getServiceById(sess, task.getServiceId());\n-\t\t\tFacility facility = perun.getFacilitiesManager().getFacilityById(sess, task.getFacilityId());\n-\t\t\ttask.setService(service);\n-\t\t\ttask.setFacility(facility);\n-\t\t} catch (ServiceNotExistsException e) {\n-\t\t\tlog.error(\"[{}] Task NOT added to waiting queue, service not exists: {}.\", task.getId(), task);\n-\t\t\tremoveTask = true;\n-\t\t} catch (FacilityNotExistsException e) {\n-\t\t\tlog.error(\"[{}] Task NOT added to waiting queue, facility not exists: {}.\", task.getId(), task);\n-\t\t\tremoveTask = true;\n-\t\t}  catch (InternalErrorException | PrivilegeException e) {\n-\t\t\tlog.error(\"[{}] {}\", task.getId(), e);\n-\t\t}\n-\n-\t\tif (!task.getService().isEnabled() || ((PerunBl) perun).getServicesManagerBl().isServiceBlockedOnFacility(task.getService(), task.getFacility())) {\n-\t\t\tlog.error(\"[{}] Task NOT added to waiting queue, service is blocked: {}.\", task.getId(), task);\n-\t\t\t// do not change Task status or any other data !\n-\t\t\tif (!removeTask) return;\n-\t\t}\n-\n-\t\ttry {\n-\t\t\tList<Destination> destinations = perun.getServicesManager().getDestinations(sess, task.getService(), task.getFacility());\n-\t\t\tif (destinations != null && !destinations.isEmpty()) {\n-\t\t\t\tIterator<Destination> iter = destinations.iterator();\n-\t\t\t\twhile (iter.hasNext()) {\n-\t\t\t\t\tDestination dest = iter.next();\n-\t\t\t\t\tif (((PerunBl) perun).getServicesManagerBl().isServiceBlockedOnDestination(task.getService(), dest.getId())) {\n-\t\t\t\t\t\titer.remove();\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tif (destinations.isEmpty()) {\n-\t\t\t\t\t// All service destinations were blocked -> Task is denied to be sent to engine just like\n-\t\t\t\t\t// when service is blocked globally in Perun or on facility as a whole.\n-\t\t\t\t\tlog.debug(\"[{}] Task NOT added to waiting queue, all its destinations are blocked.\", task.getId());\n-\t\t\t\t\tif (!removeTask) return;\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t} catch (ServiceNotExistsException e) {\n-\t\t\tlog.error(\"[{}] Task NOT added to waiting queue, service not exists: {}.\", task.getId(), task);\n-\t\t\tremoveTask = true;\n-\t\t} catch (FacilityNotExistsException e) {\n-\t\t\tlog.error(\"[{}] Task NOT added to waiting queue, facility not exists: {}.\", task.getId(), task);\n-\t\t\tremoveTask = true;\n-\t\t}  catch (InternalErrorException | PrivilegeException e) {\n-\t\t\tlog.error(\"[{}] {}\", task.getId(), e);\n-\t\t}\n-\n-\t\ttry {\n-\t\t\tList<Service> assignedServices = perun.getServicesManager().getAssignedServices(sess, task.getFacility());\n-\t\t\tif (!assignedServices.contains(task.getService())) {\n-\t\t\t\tlog.debug(\"[{}] Task NOT added to waiting queue, service is not assigned to facility any more: {}.\", task.getId(), task);\n-\t\t\t\tif (!removeTask) return;\n-\t\t\t}\n-\t\t} catch (FacilityNotExistsException e) {\n-\t\t\tremoveTask = true;\n-\t\t\tlog.error(\"[{}] Task removed from database, facility no longer exists: {}.\", task.getId(), task);\n-\t\t} catch (InternalErrorException | PrivilegeException e) {\n-\t\t\tlog.error(\"[{}] Unable to check Service assignment to Facility: {}\", task.getId(), e.getMessage());\n-\t\t}\n-\n-\t\tif (removeTask) {\n-\t\t\t// in memory task belongs to non existent facility/service - remove it and return\n-\t\t\ttry {\n-\t\t\t\tremoveTask(task);\n-\t\t\t\treturn;\n-\t\t\t} catch (TaskStoreException e) {\n-\t\t\t\tlog.error(\"[{}] Unable to remove Task from pool: {}.\", task.getId(), e);\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t}\n-\n-\t\t// Task is eligible for running - create new schedule\n-\n-\t\ttask.setSourceUpdated(false);\n-\n-\t\tlong newTaskDelay = 0;\n-\t\tif (!task.isPropagationForced()) {\n-\t\t\t// normal tasks are delayed\n-\t\t\ttry {\n-\t\t\t\tnewTaskDelay = Long.parseLong(dispatcherProperties.getProperty(\"dispatcher.task.delay.time\"));\n-\t\t\t} catch (NumberFormatException e) {\n-\t\t\t\tlog.warn(\"Could not parse value of dispatcher.task.delay.time property. Using default.\");\n-\t\t\t\tnewTaskDelay = 30000;\n-\t\t\t}\n-\t\t}\n-\t\tif (task.isPropagationForced()) {\n-\t\t\tdelayCount = 0;\n-\t\t}\n-\t\tif (delayCount < 0) {\n-\t\t\ttry {\n-\t\t\t\tdelayCount = Integer.parseInt(dispatcherProperties.getProperty(\"dispatcher.task.delay.count\"));\n-\t\t\t} catch (NumberFormatException e) {\n-\t\t\t\tlog.warn(\"Could not parse value of dispatcher.task.delay.count property. Using default.\");\n-\t\t\t\tdelayCount = 4;\n-\t\t\t}\n-\t\t}\n-\n-\t\tTaskSchedule schedule = new TaskSchedule(newTaskDelay, task);\n-\t\tschedule.setBase(System.currentTimeMillis());\n-\t\tschedule.setDelayCount(delayCount);\n-\n-\t\t// Task was newly planned for propagation, switch state.\n-\t\tif (!task.getStatus().equals(TaskStatus.WAITING)) {\n-\n-\t\t\ttask.setStatus(TaskStatus.WAITING);\n-\t\t\ttask.setSchedule(LocalDateTime.now());\n-\t\t\t// clear previous timestamps\n-\t\t\ttask.setSentToEngine((LocalDateTime) null);\n-\t\t\ttask.setStartTime((LocalDateTime) null);\n-\t\t\ttask.setGenStartTime((LocalDateTime) null);\n-\t\t\ttask.setSendStartTime((LocalDateTime) null);\n-\t\t\ttask.setEndTime((LocalDateTime) null);\n-\t\t\ttask.setGenEndTime((LocalDateTime) null);\n-\t\t\ttask.setSendEndTime((LocalDateTime) null);\n-\n-\t\t\ttasksManagerBl.updateTask(task);\n-\n-\t\t}\n-\n-\t\tboolean added = false;\n-\n-\t\tif (schedule.getTask().isPropagationForced()) {\n-\t\t\tadded = waitingForcedTasksQueue.add(schedule);\n-\t\t} else {\n-\t\t\tadded = waitingTasksQueue.add(schedule);\n-\t\t}\n-\n-\t\tif (!added) {\n-\t\t\tlog.error(\"[{}] Task could not be added to waiting queue. Shouldn't ever happen. Look to javadoc of DelayQueue. {}\", task.getId(), schedule);\n-\t\t} else {\n-\t\t\tlog.debug(\"[{}] Task was added to waiting queue: {}\", task.getId(), schedule);\n-\t\t}\n-\n-\t}\n-\n-\t/**\n-\t * Adds Task and associated dispatcherQueue into scheduling pools internal maps and also to the database.\n-\t *\n-\t * @param task            Task which will be added and persisted.\n-\t * @param engineMessageProducer dispatcherQueue associated with the Task which will be added and persisted.\n-\t * @return Number of Tasks in the pool.\n-\t * @throws TaskStoreException\n-\t */\n-\t@Override\n-\tpublic int addToPool(Task task, EngineMessageProducer engineMessageProducer) throws TaskStoreException {\n-\n-\t\tint engineId = (engineMessageProducer == null) ? -1 : engineMessageProducer.getClientID();\n-\t\tif (task.getId() == 0) {\n-\t\t\tif (getTask(task.getFacility(), task.getService()) == null) {\n-\t\t\t\tint id = tasksManagerBl.scheduleNewTask(task, engineId);\n-\t\t\t\ttask.setId(id);\n-\t\t\t\tlog.debug(\"[{}] New Task stored in DB: {}\", task.getId(), task);\n-\t\t\t} else {\n-\t\t\t\tTask existingTask = tasksManagerBl.getTaskById(task.getId());\n-\t\t\t\tif (existingTask == null) {\n-\t\t\t\t\tint id = tasksManagerBl.scheduleNewTask(task, engineId);\n-\t\t\t\t\ttask.setId(id);\n-\t\t\t\t\tlog.debug(\"[{}] New Task stored in DB: {}\", task.getId(), task);\n-\t\t\t\t} else {\n-\t\t\t\t\ttasksManagerBl.updateTask(task);\n-\t\t\t\t\tlog.debug(\"[{}] Task updated in the pool: {}\", task.getId(), task);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\taddTask(task);\n-\t\tenginesByTaskId.put(task.getId(), engineMessageProducer);\n-\t\tlog.debug(\"[{}] Task added to the pool: {}\", task.getId(), task);\n-\t\treturn getSize();\n-\t}\n-\n-\t@Override\n-\tpublic Task removeTask(int id) throws TaskStoreException {\n-\t\treturn taskStore.removeTask(id);\n-\t}\n-\n-\t@Override\n-\tpublic EngineMessageProducer getEngineMessageProducerForTask(Task task) throws InternalErrorException {\n-\t\tif (task == null) {\n-\t\t\tlog.error(\"Supplied Task is null.\");\n-\t\t\tthrow new IllegalArgumentException(\"Task cannot be null\");\n-\t\t}\n-\t\tEngineMessageProducer entry = enginesByTaskId.get(task.getId());\n-\t\tif (entry == null) {\n-\t\t\tthrow new InternalErrorException(\"No Task with ID \" + task.getId());\n-\t\t}\n-\t\treturn entry;\n-\t}\n-\n-\n-\t@Override\n-\tpublic List<Task> getTasksForEngine(int clientID) {\n-\t\tList<Task> result = new ArrayList<Task>();\n-\t\tfor (Map.Entry<Integer, EngineMessageProducer> entry : enginesByTaskId.entrySet()) {\n-\t\t\tif (entry.getValue() != null && clientID == entry.getValue().getClientID()) {\n-\t\t\t\tresult.add(getTask(entry.getKey()));\n-\t\t\t}\n-\t\t}\n-\t\treturn result;\n-\t}\n-\n-\t@Override\n-\tpublic String getReport() {\n-\t\tint waiting = getTasksWithStatus(TaskStatus.WAITING).size();\n-\t\tint planned = getTasksWithStatus(TaskStatus.PLANNED).size();\n-\t\tint generating = getTasksWithStatus(TaskStatus.GENERATING).size();\n-\t\tint generated = getTasksWithStatus(TaskStatus.GENERATED).size();\n-\t\tint generror = getTasksWithStatus(TaskStatus.GENERROR).size();\n-\t\tint sending = getTasksWithStatus(TaskStatus.SENDING).size();\n-\t\tint senderror = getTasksWithStatus(TaskStatus.SENDERROR).size();\n-\t\tint done = getTasksWithStatus(TaskStatus.DONE).size();\n-\t\tint error = getTasksWithStatus(TaskStatus.ERROR).size();\n-\n-\t\treturn \"Dispatcher SchedulingPool Task report:\\n\" +\n-\t\t\t\t\"  WAITING: \" + waiting +\n-\t\t\t\t\"  PLANNED: \" + planned +\n-\t\t\t\t\"  GENERATING: \" + generating +\n-\t\t\t\t\"  GENERATED: \" + generated +\n-\t\t\t\t\"  GENERROR: \" + generror +\n-\t\t\t\t\"  SENDING:  \" + sending +\n-\t\t\t\t\"  SENDEEROR:  \" + senderror +\n-\t\t\t\t\"  DONE: \" + done +\n-\t\t\t\t\"  ERROR: \" + error;\n-\t}\n-\n-\t@Override\n-\tpublic void clear() {\n-\t\ttaskStore.clear();\n-\t\tenginesByTaskId.clear();\n-\t\twaitingTasksQueue.clear();\n-\t\twaitingForcedTasksQueue.clear();\n-\t}\n-\n-\t@Override\n-\tpublic void reloadTasks() {\n-\n-\t\tlog.debug(\"Going to reload Tasks from database...\");\n-\n-\t\tthis.clear();\n-\n-\t\tfor (Pair<Task, Integer> pair : tasksManagerBl.listAllTasksAndClients()) {\n-\t\t\tTask task = pair.getLeft();\n-\t\t\tEngineMessageProducer queue = engineMessageProducerPool.getProducerByClient(pair.getRight());\n-\t\t\ttry {\n-\t\t\t\t// just add DB Task to in-memory structure\n-\t\t\t\taddToPool(task, queue);\n-\t\t\t} catch (TaskStoreException e) {\n-\t\t\t\tlog.error(\"Adding Task {} and Queue {} into SchedulingPool failed, so the Task will be lost.\", task, queue);\n-\t\t\t}\n-\n-\t\t\t// if service was not in DONE or any kind of ERROR - reschedule now\n-\t\t\t// error/done tasks will be rescheduled later by periodic jobs !!\n-\t\t\tif (!Arrays.asList(TaskStatus.DONE, TaskStatus.ERROR, TaskStatus.GENERROR, TaskStatus.SENDERROR).contains(task.getStatus())) {\n-\t\t\t\tif (task.getStatus().equals(TaskStatus.WAITING)) {\n-\t\t\t\t\t// if were in WAITING, reset timestamp to now\n-\t\t\t\t\ttask.setSchedule(LocalDateTime.now());\n-\t\t\t\t\ttasksManagerBl.updateTask(task);\n-\t\t\t\t}\n-\t\t\t\tscheduleTask(task, 0);\n-\t\t\t}\n-\n-\t\t}\n-\n-\t\tlog.debug(\"Reload of Tasks from database finished.\");\n-\n-\t}\n-\n-\t@Override\n-\tpublic void setEngineMessageProducerForTask(Task task, EngineMessageProducer messageProducer) throws InternalErrorException {\n-\t\tTask found = getTask(task.getId());\n-\t\tif (found == null) {\n-\t\t\tthrow new InternalErrorException(\"no task by id \" + task.getId());\n-\t\t} else {\n-\t\t\tenginesByTaskId.put(task.getId(), messageProducer);\n-\t\t}\n-\t\t// if queue is removed, set -1 to task as it's done on task creation if queue is null\n-\t\tint queueId = (messageProducer != null) ? messageProducer.getClientID() : -1;\n-\t\ttasksManagerBl.updateTaskEngine(task, queueId);\n-\t}\n-\n-\t@Override\n-\tpublic void closeTasksForEngine(int clientID) {\n-\n-\t\tList<Task> tasks = getTasksForEngine(clientID);\n-\t\tList<TaskStatus> engineStates = new ArrayList<>();\n-\t\tengineStates.add(TaskStatus.PLANNED);\n-\t\tengineStates.add(TaskStatus.GENERATING);\n-\t\tengineStates.add(TaskStatus.GENERATED);\n-\t\tengineStates.add(TaskStatus.SENDING);\n-\n-\t\t// switch all processing tasks to error, remove the engine queue association\n-\t\tlog.debug(\"Switching processing tasks on engine {} to ERROR, the engine went down...\", clientID);\n-\t\tfor (Task task : tasks) {\n-\t\t\tif (engineStates.contains(task.getStatus())) {\n-\t\t\t\tlog.info(\"[{}] Switching Task to ERROR, the engine it was running on went down.\", task.getId());\n-\t\t\t\ttask.setStatus(TaskStatus.ERROR);\n-\t\t\t}\n-\t\t\ttry {\n-\t\t\t\tsetEngineMessageProducerForTask(task, null);\n-\t\t\t} catch (InternalErrorException e) {\n-\t\t\t\tlog.error(\"[{}] Could not remove dispatcher queue for task: {}.\", task.getId(), e.getMessage());\n-\t\t\t}\n-\t\t}\n-\n-\t}\n-\n-\t@Override\n-\tpublic void onTaskStatusChange(int taskId, String status, String milliseconds) {\n-\n-\t\tTask task = getTask(taskId);\n-\t\tif (task == null) {\n-\t\t\tlog.error(\"[{}] Received status update about Task which is not in Dispatcher anymore, will ignore it.\", taskId);\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tTaskStatus oldStatus = task.getStatus();\n-\t\ttask.setStatus(TaskStatus.valueOf(status));\n-\t\tlong ms;\n-\t\ttry {\n-\t\t\tms = Long.valueOf(milliseconds);\n-\t\t} catch (NumberFormatException e) {\n-\t\t\tlog.warn(\"[{}] Timestamp of change '{}' could not be parsed, current time will be used instead.\", task.getId(), milliseconds);\n-\t\t\tms = System.currentTimeMillis();\n-\t\t}\n-\t\tLocalDateTime changeDate = LocalDateTime.ofInstant(Instant.ofEpochMilli(ms), ZoneId.systemDefault());\n-\n-\t\tswitch (task.getStatus()) {\n-\t\t\tcase WAITING:\n-\t\t\tcase PLANNED:\n-\t\t\t\tlog.error(\"[{}] Received status change to {} from Engine, this should not happen.\", task.getId(), task.getStatus());\n-\t\t\t\treturn;\n-\t\t\tcase GENERATING:\n-\t\t\t\ttask.setStartTime(changeDate);\n-\t\t\t\ttask.setGenStartTime(changeDate);\n-\t\t\t\tbreak;\n-\t\t\tcase GENERROR:\n-\t\t\t\ttask.setEndTime(changeDate);\n-\t\t\tcase GENERATED:\n-\t\t\t\ttask.setGenEndTime(changeDate);\n-\t\t\t\tbreak;\n-\t\t\tcase SENDING:\n-\t\t\t\ttask.setSendStartTime(changeDate);\n-\t\t\t\tbreak;\n-\t\t\tcase DONE:\n-\t\t\tcase SENDERROR:\n-\t\t\t\ttask.setSendEndTime(changeDate);\n-\t\t\t\ttask.setEndTime(changeDate);\n-\t\t\t\tbreak;\n-\t\t\tcase ERROR:\n-\t\t\t\ttask.setEndTime(changeDate);\n-\t\t\t\tbreak;\n-\t\t}\n-\n-\t\ttasksManagerBl.updateTask(task);\n-\n-\t\tlog.debug(\"[{}] Task status changed from {} to {} as reported by Engine: {}.\", task.getId(), oldStatus, task.getStatus(), task);\n-\n-\t}\n-\n-\t@Override\n-\tpublic void onTaskDestinationComplete(int clientID, String string) {\n-\n-\t\tif (string == null || string.isEmpty()) {\n-\t\t\tlog.error(\"Could not parse TaskResult message from Engine {}.\", clientID);\n-\t\t\treturn;\n-\t\t}\n-\n-\t\ttry {\n-\t\t\tList<PerunBean> listOfBeans = AuditParser.parseLog(string);\n-\t\t\tif (!listOfBeans.isEmpty()) {\n-\t\t\t\tTaskResult taskResult = (TaskResult) listOfBeans.get(0);\n-\t\t\t\tlog.debug(\"[{}] Received TaskResult for Task from Engine {}.\", taskResult.getTaskId(), clientID);\n-\t\t\t\tonTaskDestinationComplete(clientID, taskResult);\n-\t\t\t} else {\n-\t\t\t\tlog.error(\"No TaskResult found in message from Engine {}: {}.\", clientID, string);\n-\t\t\t}\n-\t\t} catch (Exception e) {\n-\t\t\tlog.error(\"Could not save TaskResult from Engine {}, {}, {}\", clientID, string, e.getMessage());\n-\t\t}\n-\n-\t}\n-\n-\t@Override\n-\tpublic void onTaskDestinationComplete(int clientID, TaskResult taskResult) {\n-\t\ttry {\n-\t\t\ttasksManagerBl.insertNewTaskResult(taskResult, clientID);\n-\t\t} catch (Exception e) {\n-\t\t\tlog.error(\"Could not save TaskResult from Engine {}, {}, {}\", clientID, taskResult, e.getMessage());\n-\t\t}\n-\t}\n+    public DelayQueue<TaskSchedule> getWaitingForcedTasksQueue() {\n+        return waitingForcedTasksQueue;\n+    }\n+\n+    @Autowired\n+    public void setWaitingForcedTasksQueue(DelayQueue<TaskSchedule> waitingForcedTasksQueue) {\n+        this.waitingForcedTasksQueue = waitingForcedTasksQueue;\n+    }\n+\n+    public Properties getDispatcherProperties() {\n+        return dispatcherProperties;\n+    }\n+\n+    @Resource(name = \"dispatcherPropertiesBean\")\n+    public void setDispatcherProperties(Properties dispatcherProperties) {\n+        this.dispatcherProperties = dispatcherProperties;\n+    }\n+\n+    public TaskStore getTaskStore() {\n+        return taskStore;\n+    }\n+\n+    @Autowired\n+    public void setTaskStore(TaskStore taskStore) {\n+        this.taskStore = taskStore;\n+    }\n+\n+    public TasksManagerBl getTasksManagerBl() {\n+        return tasksManagerBl;\n+    }\n+\n+    @Autowired\n+    public void setTasksManagerBl(TasksManagerBl tasksManagerBl) {\n+        this.tasksManagerBl = tasksManagerBl;\n+    }\n+\n+    public EngineMessageProducerPool getEngineMessageProducerPool() {\n+        return engineMessageProducerPool;\n+    }\n+\n+    @Autowired\n+    public void setEngineMessageProducerPool(EngineMessageProducerPool engineMessageProducerPool) {\n+        this.engineMessageProducerPool = engineMessageProducerPool;\n+    }\n+\n+    public Perun getPerun() {\n+        return perun;\n+    }\n+\n+    @Autowired\n+    public void setPerun(Perun perun) {\n+        this.perun = perun;\n+    }\n+\n+\n+    // ----- methods -------------------------------------\n+\n+\n+    @Override\n+    public Task getTask(int id) {\n+        return taskStore.getTask(id);\n+    }\n+\n+    @Override\n+    public Task getTask(Facility facility, Service service) {\n+        return taskStore.getTask(facility, service);\n+    }\n+\n+    @Override\n+    public int getSize() {\n+        return taskStore.getSize();\n+    }\n+\n+    @Override\n+    public Task addTask(Task task) throws TaskStoreException {\n+        return taskStore.addTask(task);\n+    }\n+\n+    @Override\n+    public Collection<Task> getAllTasks() {\n+        return taskStore.getAllTasks();\n+    }\n+\n+    @Override\n+    public List<Task> getTasksWithStatus(TaskStatus... status) {\n+        return taskStore.getTasksWithStatus(status);\n+    }\n+\n+    @Override\n+    public Task removeTask(Task task) throws TaskStoreException {\n+        return taskStore.removeTask(task);\n+    }\n+\n+    @Override\n+    public void scheduleTask(Task task, int delayCount) {\n+\n+        // init session\n+        try {\n+            if (sess == null) {\n+                sess = perun.getPerunSession(new PerunPrincipal(\n+                                dispatcherProperties.getProperty(\"perun.principal.name\"),\n+                                dispatcherProperties.getProperty(\"perun.principal.extSourceName\"),\n+                                dispatcherProperties.getProperty(\"perun.principal.extSourceType\")),\n+                        new PerunClient());\n+            }\n+        } catch (InternalErrorException e1) {\n+            log.error(\"Error establishing perun session to add task schedule: \", e1);\n+            return;\n+        }\n+\n+        // check if service/facility exists\n+\n+        boolean removeTask = false;\n+\n+        try {\n+            Service service = perun.getServicesManager().getServiceById(sess, task.getServiceId());\n+            Facility facility = perun.getFacilitiesManager().getFacilityById(sess, task.getFacilityId());\n+            task.setService(service);\n+            task.setFacility(facility);\n+        } catch (ServiceNotExistsException e) {\n+            log.error(\"[{}] Task NOT added to waiting queue, service not exists: {}.\", task.getId(), task);\n+            removeTask = true;\n+        } catch (FacilityNotExistsException e) {\n+            log.error(\"[{}] Task NOT added to waiting queue, facility not exists: {}.\", task.getId(), task);\n+            removeTask = true;\n+        } catch (InternalErrorException | PrivilegeException e) {\n+            log.error(\"[{}] {}\", task.getId(), e);\n+        }\n+\n+        if (!task.getService().isEnabled() || ((PerunBl) perun).getServicesManagerBl().isServiceBlockedOnFacility(task.getService(), task.getFacility())) {\n+            log.error(\"[{}] Task NOT added to waiting queue, service is blocked: {}.\", task.getId(), task);\n+            // do not change Task status or any other data !\n+            if (!removeTask) {\n+                return;\n+            }\n+        }\n+\n+        try {\n+            List<Destination> destinations = perun.getServicesManager().getDestinations(sess, task.getService(), task.getFacility());\n+            if (destinations != null && !destinations.isEmpty()) {\n+                Iterator<Destination> iter = destinations.iterator();\n+                while (iter.hasNext()) {\n+                    Destination dest = iter.next();\n+                    if (((PerunBl) perun).getServicesManagerBl().isServiceBlockedOnDestination(task.getService(), dest.getId())) {\n+                        iter.remove();\n+                    }\n+                }\n+                if (destinations.isEmpty()) {\n+                    // All service destinations were blocked -> Task is denied to be sent to engine just like\n+                    // when service is blocked globally in Perun or on facility as a whole.\n+                    log.debug(\"[{}] Task NOT added to waiting queue, all its destinations are blocked.\", task.getId());\n+                    if (!removeTask) {\n+                        return;\n+                    }\n+                }\n+            }\n+\n+        } catch (ServiceNotExistsException e) {\n+            log.error(\"[{}] Task NOT added to waiting queue, service not exists: {}.\", task.getId(), task);\n+            removeTask = true;\n+        } catch (FacilityNotExistsException e) {\n+            log.error(\"[{}] Task NOT added to waiting queue, facility not exists: {}.\", task.getId(), task);\n+            removeTask = true;\n+        } catch (InternalErrorException | PrivilegeException e) {\n+            log.error(\"[{}] {}\", task.getId(), e);\n+        }\n+\n+        try {\n+            List<Service> assignedServices = perun.getServicesManager().getAssignedServices(sess, task.getFacility());\n+            if (!assignedServices.contains(task.getService())) {\n+                log.debug(\"[{}] Task NOT added to waiting queue, service is not assigned to facility any more: {}.\", task.getId(), task);\n+                if (!removeTask) {\n+                    return;\n+                }\n+            }\n+        } catch (FacilityNotExistsException e) {\n+            removeTask = true;\n+            log.error(\"[{}] Task removed from database, facility no longer exists: {}.\", task.getId(), task);\n+        } catch (InternalErrorException | PrivilegeException e) {\n+            log.error(\"[{}] Unable to check Service assignment to Facility: {}\", task.getId(), e.getMessage());\n+        }\n+\n+        if (removeTask) {\n+            // in memory task belongs to non existent facility/service - remove it and return\n+            try {\n+                removeTask(task);\n+                return;\n+            } catch (TaskStoreException e) {\n+                log.error(\"[{}] Unable to remove Task from pool: {}.\", task.getId(), e);\n+                return;\n+            }\n+        }\n+\n+        // Task is eligible for running - create new schedule\n+\n+        task.setSourceUpdated(false);\n+\n+        long newTaskDelay = 0;\n+        if (!task.isPropagationForced()) {\n+            // normal tasks are delayed\n+            try {\n+                newTaskDelay = Long.parseLong(dispatcherProperties.getProperty(\"dispatcher.task.delay.time\"));\n+            } catch (NumberFormatException e) {\n+                log.warn(\"Could not parse value of dispatcher.task.delay.time property. Using default.\");\n+                newTaskDelay = 30000;\n+            }\n+        }\n+        if (task.isPropagationForced()) {\n+            delayCount = 0;\n+        }\n+        if (delayCount < 0) {\n+            try {\n+                delayCount = Integer.parseInt(dispatcherProperties.getProperty(\"dispatcher.task.delay.count\"));\n+            } catch (NumberFormatException e) {\n+                log.warn(\"Could not parse value of dispatcher.task.delay.count property. Using default.\");\n+                delayCount = 4;\n+            }\n+        }\n+\n+        TaskSchedule schedule = new TaskSchedule(newTaskDelay, task);\n+        schedule.setBase(System.currentTimeMillis());\n+        schedule.setDelayCount(delayCount);\n+\n+        // Task was newly planned for propagation, switch state.\n+        if (!task.getStatus().equals(TaskStatus.WAITING)) {\n+\n+            task.setStatus(TaskStatus.WAITING);\n+            task.setSchedule(LocalDateTime.now());\n+            // clear previous timestamps\n+            task.setSentToEngine((LocalDateTime) null);\n+            task.setStartTime((LocalDateTime) null);\n+            task.setGenStartTime((LocalDateTime) null);\n+            task.setSendStartTime((LocalDateTime) null);\n+            task.setEndTime((LocalDateTime) null);\n+            task.setGenEndTime((LocalDateTime) null);\n+            task.setSendEndTime((LocalDateTime) null);\n+\n+            tasksManagerBl.updateTask(task);\n+\n+        }\n+\n+        boolean added = false;\n+\n+        if (schedule.getTask().isPropagationForced()) {\n+            added = waitingForcedTasksQueue.add(schedule);\n+        } else {\n+            added = waitingTasksQueue.add(schedule);\n+        }\n+\n+        if (!added) {\n+            log.error(\"[{}] Task could not be added to waiting queue. Shouldn't ever happen. Look to javadoc of DelayQueue. {}\", task.getId(), schedule);\n+        } else {\n+            log.debug(\"[{}] Task was added to waiting queue: {}\", task.getId(), schedule);\n+        }\n+\n+    }\n+\n+    /**\n+     * Adds Task and associated dispatcherQueue into scheduling pools internal maps and also to the database.\n+     *\n+     * @param task                  Task which will be added and persisted.\n+     * @param engineMessageProducer dispatcherQueue associated with the Task which will be added and persisted.\n+     * @return Number of Tasks in the pool.\n+     * @throws TaskStoreException\n+     */\n+    @Override\n+    public int addToPool(Task task, EngineMessageProducer engineMessageProducer) throws TaskStoreException {\n+\n+        int engineId = (engineMessageProducer == null) ? -1 : engineMessageProducer.getClientID();\n+        if (task.getId() == 0) {\n+            if (getTask(task.getFacility(), task.getService()) == null) {\n+                int id = tasksManagerBl.scheduleNewTask(task, engineId);\n+                task.setId(id);\n+                log.debug(\"[{}] New Task stored in DB: {}\", task.getId(), task);\n+            } else {\n+                Task existingTask = tasksManagerBl.getTaskById(task.getId());\n+                if (existingTask == null) {\n+                    int id = tasksManagerBl.scheduleNewTask(task, engineId);\n+                    task.setId(id);\n+                    log.debug(\"[{}] New Task stored in DB: {}\", task.getId(), task);\n+                } else {\n+                    tasksManagerBl.updateTask(task);\n+                    log.debug(\"[{}] Task updated in the pool: {}\", task.getId(), task);\n+                }\n+            }\n+        }\n+        addTask(task);\n+        enginesByTaskId.put(task.getId(), engineMessageProducer);\n+        log.debug(\"[{}] Task added to the pool: {}\", task.getId(), task);\n+        return getSize();\n+    }\n+\n+    @Override\n+    public Task removeTask(int id) throws TaskStoreException {\n+        return taskStore.removeTask(id);\n+    }\n+\n+    @Override\n+    public EngineMessageProducer getEngineMessageProducerForTask(Task task) throws InternalErrorException {\n+        if (task == null) {\n+            log.error(\"Supplied Task is null.\");\n+            throw new IllegalArgumentException(\"Task cannot be null\");\n+        }\n+        EngineMessageProducer entry = enginesByTaskId.get(task.getId());\n+        if (entry == null) {\n+            throw new InternalErrorException(\"No Task with ID \" + task.getId());\n+        }\n+        return entry;\n+    }\n+\n+\n+    @Override\n+    public List<Task> getTasksForEngine(int clientID) {\n+        List<Task> result = new ArrayList<Task>();\n+        for (Map.Entry<Integer, EngineMessageProducer> entry : enginesByTaskId.entrySet()) {\n+            if (entry.getValue() != null && clientID == entry.getValue().getClientID()) {\n+                result.add(getTask(entry.getKey()));\n+            }\n+        }\n+        return result;\n+    }\n+\n+    @Override\n+    public String getReport() {\n+        int waiting = getTasksWithStatus(TaskStatus.WAITING).size();\n+        int planned = getTasksWithStatus(TaskStatus.PLANNED).size();\n+        int generating = getTasksWithStatus(TaskStatus.GENERATING).size();\n+        int generated = getTasksWithStatus(TaskStatus.GENERATED).size();\n+        int generror = getTasksWithStatus(TaskStatus.GENERROR).size();\n+        int sending = getTasksWithStatus(TaskStatus.SENDING).size();\n+        int senderror = getTasksWithStatus(TaskStatus.SENDERROR).size();\n+        int done = getTasksWithStatus(TaskStatus.DONE).size();\n+        int error = getTasksWithStatus(TaskStatus.ERROR).size();\n+\n+        return \"Dispatcher SchedulingPool Task report:\\n\" +\n+                \"  WAITING: \" + waiting +\n+                \"  PLANNED: \" + planned +\n+                \"  GENERATING: \" + generating +\n+                \"  GENERATED: \" + generated +\n+                \"  GENERROR: \" + generror +\n+                \"  SENDING:  \" + sending +\n+                \"  SENDEEROR:  \" + senderror +\n+                \"  DONE: \" + done +\n+                \"  ERROR: \" + error;\n+    }\n+\n+    @Override\n+    public void clear() {\n+        taskStore.clear();\n+        enginesByTaskId.clear();\n+        waitingTasksQueue.clear();\n+        waitingForcedTasksQueue.clear();\n+    }\n+\n+    @Override\n+    public void reloadTasks() {\n+\n+        log.debug(\"Going to reload Tasks from database...\");\n+\n+        this.clear();\n+\n+        for (Pair<Task, Integer> pair : tasksManagerBl.listAllTasksAndClients()) {\n+            Task task = pair.getLeft();\n+            EngineMessageProducer queue = engineMessageProducerPool.getProducerByClient(pair.getRight());\n+            try {\n+                // just add DB Task to in-memory structure\n+                addToPool(task, queue);\n+            } catch (TaskStoreException e) {\n+                log.error(\"Adding Task {} and Queue {} into SchedulingPool failed, so the Task will be lost.\", task, queue);\n+            }\n+\n+            // if service was not in DONE or any kind of ERROR - reschedule now\n+            // error/done tasks will be rescheduled later by periodic jobs !!\n+            if (!Arrays.asList(TaskStatus.DONE, TaskStatus.ERROR, TaskStatus.GENERROR, TaskStatus.SENDERROR).contains(task.getStatus())) {\n+                if (task.getStatus().equals(TaskStatus.WAITING)) {\n+                    // if were in WAITING, reset timestamp to now\n+                    task.setSchedule(LocalDateTime.now());\n+                    tasksManagerBl.updateTask(task);\n+                }\n+                scheduleTask(task, 0);\n+            }\n+\n+        }\n+\n+        log.debug(\"Reload of Tasks from database finished.\");\n+\n+    }\n+\n+    @Override\n+    public void setEngineMessageProducerForTask(Task task, EngineMessageProducer messageProducer) throws InternalErrorException {\n+        Task found = getTask(task.getId());\n+        if (found == null) {\n+            throw new InternalErrorException(\"no task by id \" + task.getId());\n+        } else {\n+            enginesByTaskId.put(task.getId(), messageProducer);\n+        }\n+        // if queue is removed, set -1 to task as it's done on task creation if queue is null\n+        int queueId = (messageProducer != null) ? messageProducer.getClientID() : -1;\n+        tasksManagerBl.updateTaskEngine(task, queueId);\n+    }\n+\n+    @Override\n+    public void closeTasksForEngine(int clientID) {\n+\n+        List<Task> tasks = getTasksForEngine(clientID);\n+        List<TaskStatus> engineStates = new ArrayList<>();\n+        engineStates.add(TaskStatus.PLANNED);\n+        engineStates.add(TaskStatus.GENERATING);\n+        engineStates.add(TaskStatus.GENERATED);\n+        engineStates.add(TaskStatus.SENDING);\n+\n+        // switch all processing tasks to error, remove the engine queue association\n+        log.debug(\"Switching processing tasks on engine {} to ERROR, the engine went down...\", clientID);\n+        for (Task task : tasks) {\n+            if (engineStates.contains(task.getStatus())) {\n+                log.info(\"[{}] Switching Task to ERROR, the engine it was running on went down.\", task.getId());\n+                task.setStatus(TaskStatus.ERROR);\n+            }\n+            try {\n+                setEngineMessageProducerForTask(task, null);\n+            } catch (InternalErrorException e) {\n+                log.error(\"[{}] Could not remove dispatcher queue for task: {}.\", task.getId(), e.getMessage());\n+            }\n+        }\n+\n+    }\n+\n+    @Override\n+    public void onTaskStatusChange(int taskId, String status, String milliseconds) {\n+\n+        Task task = getTask(taskId);\n+        if (task == null) {\n+            log.error(\"[{}] Received status update about Task which is not in Dispatcher anymore, will ignore it.\", taskId);\n+            return;\n+        }\n+\n+        TaskStatus oldStatus = task.getStatus();\n+        task.setStatus(TaskStatus.valueOf(status));\n+        long ms;\n+        try {\n+            ms = Long.valueOf(milliseconds);\n+        } catch (NumberFormatException e) {\n+            log.warn(\"[{}] Timestamp of change '{}' could not be parsed, current time will be used instead.\", task.getId(), milliseconds);\n+            ms = System.currentTimeMillis();\n+        }\n+        LocalDateTime changeDate = LocalDateTime.ofInstant(Instant.ofEpochMilli(ms), ZoneId.systemDefault());\n+\n+        switch (task.getStatus()) {\n+            case WAITING:\n+            case PLANNED:\n+                log.error(\"[{}] Received status change to {} from Engine, this should not happen.\", task.getId(), task.getStatus());\n+                return;\n+            case GENERATING:\n+                task.setStartTime(changeDate);\n+                task.setGenStartTime(changeDate);\n+                break;\n+            case GENERROR:\n+                task.setEndTime(changeDate);\n+            case GENERATED:\n+                task.setGenEndTime(changeDate);\n+                break;\n+            case SENDING:\n+                task.setSendStartTime(changeDate);\n+                break;\n+            case DONE:\n+            case SENDERROR:\n+                task.setSendEndTime(changeDate);\n+                task.setEndTime(changeDate);\n+                break;\n+            case ERROR:\n+                task.setEndTime(changeDate);\n+                break;\n+        }\n+\n+        tasksManagerBl.updateTask(task);\n+\n+        log.debug(\"[{}] Task status changed from {} to {} as reported by Engine: {}.\", task.getId(), oldStatus, task.getStatus(), task);\n+\n+    }\n+\n+    @Override\n+    public void onTaskDestinationComplete(int clientID, String string) {\n+\n+        if (string == null || string.isEmpty()) {\n+            log.error(\"Could not parse TaskResult message from Engine {}.\", clientID);\n+            return;\n+        }\n+\n+        try {\n+            List<PerunBean> listOfBeans = AuditParser.parseLog(string);\n+            if (!listOfBeans.isEmpty()) {\n+                TaskResult taskResult = (TaskResult) listOfBeans.get(0);\n+                log.debug(\"[{}] Received TaskResult for Task from Engine {}.\", taskResult.getTaskId(), clientID);\n+                onTaskDestinationComplete(clientID, taskResult);\n+            } else {\n+                log.error(\"No TaskResult found in message from Engine {}: {}.\", clientID, string);\n+            }\n+        } catch (Exception e) {\n+            log.error(\"Could not save TaskResult from Engine {}, {}, {}\", clientID, string, e.getMessage());\n+        }\n+\n+    }\n+\n+    @Override\n+    public void onTaskDestinationComplete(int clientID, TaskResult taskResult) {\n+        try {\n+            tasksManagerBl.insertNewTaskResult(taskResult, clientID);\n+        } catch (Exception e) {\n+            log.error(\"Could not save TaskResult from Engine {}, {}, {}\", clientID, taskResult, e.getMessage());\n+        }\n+    }\n \n }\n",
            "diff_size": 541
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/103/SchedulingPoolImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/codebuff/103/SchedulingPoolImpl.java\nindex 0b8208d85c5..6e9afb432e2 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/103/SchedulingPoolImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/codebuff/103/SchedulingPoolImpl.java\n@@ -26,11 +26,9 @@ import cz.metacentrum.perun.taskslib.model.Task.TaskStatus;\n import cz.metacentrum.perun.taskslib.model.TaskResult;\n import cz.metacentrum.perun.taskslib.model.TaskSchedule;\n import cz.metacentrum.perun.taskslib.service.TaskStore;\n-\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.springframework.beans.factory.annotation.Autowired;\n-\n import java.time.Instant;\n import java.time.LocalDateTime;\n import java.time.ZoneId;\n@@ -43,7 +41,6 @@ import java.util.List;\n import java.util.Map;\n import java.util.Properties;\n import java.util.concurrent.DelayQueue;\n-\n import javax.annotation.Resource;\n \n /**\n@@ -56,550 +53,523 @@ import javax.annotation.Resource;\n  * @author David \u0160arman\n  * @author Pavel Zl\u00e1mal <zlamal@cesnet.cz>\n  */\n+\n+\n @org.springframework.stereotype.Service(\"schedulingPool\")\n public class SchedulingPoolImpl implements SchedulingPool {\n \n-\tprivate final static Logger log = LoggerFactory.getLogger(SchedulingPoolImpl.class);\n-\n-\tprivate final Map<Integer, EngineMessageProducer> enginesByTaskId = new HashMap<>();\n-\tprivate PerunSession sess;\n \n-\tprivate DelayQueue<TaskSchedule> waitingTasksQueue;\n-\tprivate DelayQueue<TaskSchedule> waitingForcedTasksQueue;\n-\tprivate Properties dispatcherProperties;\n-\tprivate TaskStore taskStore;\n-\tprivate TasksManagerBl tasksManagerBl;\n-\tprivate EngineMessageProducerPool engineMessageProducerPool;\n-\tprivate Perun perun;\n+ private final static Logger log = LoggerFactory.getLogger(SchedulingPoolImpl.class);\n+ private final Map<Integer, EngineMessageProducer> enginesByTaskId = new HashMap<>();\n+ private PerunSession sess;\n+ private DelayQueue<TaskSchedule> waitingTasksQueue;\n+ private DelayQueue<TaskSchedule> waitingForcedTasksQueue;\n+ private Properties dispatcherProperties;\n+ private TaskStore taskStore;\n+ private TasksManagerBl tasksManagerBl;\n+ private EngineMessageProducerPool engineMessageProducerPool;\n+ private Perun perun;\n \n-\tpublic SchedulingPoolImpl() {\n-\t}\n \n-\tpublic SchedulingPoolImpl(Properties dispatcherPropertiesBean, TaskStore taskStore,\n-\t\t\t\t\t\t\t  TasksManagerBl tasksManagerBl, EngineMessageProducerPool engineMessageProducerPool) {\n-\t\tthis.dispatcherProperties = dispatcherPropertiesBean;\n-\t\tthis.taskStore = taskStore;\n-\t\tthis.tasksManagerBl = tasksManagerBl;\n-\t\tthis.engineMessageProducerPool = engineMessageProducerPool;\n-\t}\n+ public SchedulingPoolImpl() {}\n \n \n-\t// ----- setters -------------------------------------\n+ public SchedulingPoolImpl(Properties dispatcherPropertiesBean, TaskStore taskStore, TasksManagerBl tasksManagerBl, EngineMessageProducerPool engineMessageProducerPool) {\n+  this.dispatcherProperties = dispatcherPropertiesBean;\n+  this.taskStore = taskStore;\n+  this.tasksManagerBl = tasksManagerBl;\n+  this.engineMessageProducerPool = engineMessageProducerPool;\n+ }\n \n \n-\tpublic DelayQueue<TaskSchedule> getWaitingTasksQueue() {\n-\t\treturn waitingTasksQueue;\n-\t}\n+ // ----- setters -------------------------------------\n \n-\t@Autowired\n-\tpublic void setWaitingTasksQueue(DelayQueue<TaskSchedule> waitingTasksQueue) {\n-\t\tthis.waitingTasksQueue = waitingTasksQueue;\n-\t}\n+ public DelayQueue<TaskSchedule> getWaitingTasksQueue() {\n+  return waitingTasksQueue;\n+ }\n \n-\tpublic DelayQueue<TaskSchedule> getWaitingForcedTasksQueue() {\n-\t\treturn waitingForcedTasksQueue;\n-\t}\n-\n-\t@Autowired\n-\tpublic void setWaitingForcedTasksQueue(DelayQueue<TaskSchedule> waitingForcedTasksQueue) {\n-\t\tthis.waitingForcedTasksQueue = waitingForcedTasksQueue;\n-\t}\n-\n-\tpublic Properties getDispatcherProperties() {\n-\t\treturn dispatcherProperties;\n-\t}\n-\n-\t@Resource(name=\"dispatcherPropertiesBean\")\n-\tpublic void setDispatcherProperties(Properties dispatcherProperties) {\n-\t\tthis.dispatcherProperties = dispatcherProperties;\n-\t}\n-\n-\tpublic TaskStore getTaskStore() {\n-\t\treturn taskStore;\n-\t}\n-\n-\t@Autowired\n-\tpublic void setTaskStore(TaskStore taskStore) {\n-\t\tthis.taskStore = taskStore;\n-\t}\n-\n-\tpublic TasksManagerBl getTasksManagerBl() {\n-\t\treturn tasksManagerBl;\n-\t}\n-\n-\t@Autowired\n-\tpublic void setTasksManagerBl(TasksManagerBl tasksManagerBl) {\n-\t\tthis.tasksManagerBl = tasksManagerBl;\n-\t}\n-\n-\tpublic EngineMessageProducerPool getEngineMessageProducerPool() {\n-\t\treturn engineMessageProducerPool;\n-\t}\n-\n-\t@Autowired\n-\tpublic void setEngineMessageProducerPool(EngineMessageProducerPool engineMessageProducerPool) {\n-\t\tthis.engineMessageProducerPool = engineMessageProducerPool;\n-\t}\n-\n-\tpublic Perun getPerun() {\n-\t\treturn perun;\n-\t}\n-\n-\t@Autowired\n-\tpublic void setPerun(Perun perun) {\n-\t\tthis.perun = perun;\n-\t}\n-\n-\n-\t// ----- methods -------------------------------------\n-\n-\n-\t@Override\n-\tpublic Task getTask(int id) {\n-\t\treturn taskStore.getTask(id);\n-\t}\n-\n-\t@Override\n-\tpublic Task getTask(Facility facility, Service service) {\n-\t\treturn taskStore.getTask(facility, service);\n-\t}\n-\n-\t@Override\n-\tpublic int getSize() {\n-\t\treturn taskStore.getSize();\n-\t}\n-\n-\t@Override\n-\tpublic Task addTask(Task task) throws TaskStoreException {\n-\t\treturn taskStore.addTask(task);\n-\t}\n-\n-\t@Override\n-\tpublic Collection<Task> getAllTasks() {\n-\t\treturn taskStore.getAllTasks();\n-\t}\n-\n-\t@Override\n-\tpublic List<Task> getTasksWithStatus(TaskStatus... status) {\n-\t\treturn taskStore.getTasksWithStatus(status);\n-\t}\n-\n-\t@Override\n-\tpublic Task removeTask(Task task) throws TaskStoreException {\n-\t\treturn taskStore.removeTask(task);\n-\t}\n-\n-\t@Override\n-\tpublic void scheduleTask(Task task, int delayCount) {\n-\n-\t\t// init session\n-\t\ttry {\n-\t\t\tif (sess == null) {\n-\t\t\t\tsess = perun.getPerunSession(new PerunPrincipal(\n-\t\t\t\t\t\t\t\tdispatcherProperties.getProperty(\"perun.principal.name\"),\n-\t\t\t\t\t\t\t\tdispatcherProperties.getProperty(\"perun.principal.extSourceName\"),\n-\t\t\t\t\t\t\t\tdispatcherProperties.getProperty(\"perun.principal.extSourceType\")),\n-\t\t\t\t\t\tnew PerunClient());\n-\t\t\t}\n-\t\t} catch (InternalErrorException e1) {\n-\t\t\tlog.error(\"Error establishing perun session to add task schedule: \", e1);\n-\t\t\treturn;\n-\t\t}\n-\n-\t\t// check if service/facility exists\n-\n-\t\tboolean removeTask = false;\n-\n-\t\ttry {\n-\t\t\tService service = perun.getServicesManager().getServiceById(sess, task.getServiceId());\n-\t\t\tFacility facility = perun.getFacilitiesManager().getFacilityById(sess, task.getFacilityId());\n-\t\t\ttask.setService(service);\n-\t\t\ttask.setFacility(facility);\n-\t\t} catch (ServiceNotExistsException e) {\n-\t\t\tlog.error(\"[{}] Task NOT added to waiting queue, service not exists: {}.\", task.getId(), task);\n-\t\t\tremoveTask = true;\n-\t\t} catch (FacilityNotExistsException e) {\n-\t\t\tlog.error(\"[{}] Task NOT added to waiting queue, facility not exists: {}.\", task.getId(), task);\n-\t\t\tremoveTask = true;\n-\t\t}  catch (InternalErrorException | PrivilegeException e) {\n-\t\t\tlog.error(\"[{}] {}\", task.getId(), e);\n-\t\t}\n-\n-\t\tif (!task.getService().isEnabled() || ((PerunBl) perun).getServicesManagerBl().isServiceBlockedOnFacility(task.getService(), task.getFacility())) {\n-\t\t\tlog.error(\"[{}] Task NOT added to waiting queue, service is blocked: {}.\", task.getId(), task);\n-\t\t\t// do not change Task status or any other data !\n-\t\t\tif (!removeTask) return;\n-\t\t}\n-\n-\t\ttry {\n-\t\t\tList<Destination> destinations = perun.getServicesManager().getDestinations(sess, task.getService(), task.getFacility());\n-\t\t\tif (destinations != null && !destinations.isEmpty()) {\n-\t\t\t\tIterator<Destination> iter = destinations.iterator();\n-\t\t\t\twhile (iter.hasNext()) {\n-\t\t\t\t\tDestination dest = iter.next();\n-\t\t\t\t\tif (((PerunBl) perun).getServicesManagerBl().isServiceBlockedOnDestination(task.getService(), dest.getId())) {\n-\t\t\t\t\t\titer.remove();\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tif (destinations.isEmpty()) {\n-\t\t\t\t\t// All service destinations were blocked -> Task is denied to be sent to engine just like\n-\t\t\t\t\t// when service is blocked globally in Perun or on facility as a whole.\n-\t\t\t\t\tlog.debug(\"[{}] Task NOT added to waiting queue, all its destinations are blocked.\", task.getId());\n-\t\t\t\t\tif (!removeTask) return;\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t} catch (ServiceNotExistsException e) {\n-\t\t\tlog.error(\"[{}] Task NOT added to waiting queue, service not exists: {}.\", task.getId(), task);\n-\t\t\tremoveTask = true;\n-\t\t} catch (FacilityNotExistsException e) {\n-\t\t\tlog.error(\"[{}] Task NOT added to waiting queue, facility not exists: {}.\", task.getId(), task);\n-\t\t\tremoveTask = true;\n-\t\t}  catch (InternalErrorException | PrivilegeException e) {\n-\t\t\tlog.error(\"[{}] {}\", task.getId(), e);\n-\t\t}\n-\n-\t\ttry {\n-\t\t\tList<Service> assignedServices = perun.getServicesManager().getAssignedServices(sess, task.getFacility());\n-\t\t\tif (!assignedServices.contains(task.getService())) {\n-\t\t\t\tlog.debug(\"[{}] Task NOT added to waiting queue, service is not assigned to facility any more: {}.\", task.getId(), task);\n-\t\t\t\tif (!removeTask) return;\n-\t\t\t}\n-\t\t} catch (FacilityNotExistsException e) {\n-\t\t\tremoveTask = true;\n-\t\t\tlog.error(\"[{}] Task removed from database, facility no longer exists: {}.\", task.getId(), task);\n-\t\t} catch (InternalErrorException | PrivilegeException e) {\n-\t\t\tlog.error(\"[{}] Unable to check Service assignment to Facility: {}\", task.getId(), e.getMessage());\n-\t\t}\n-\n-\t\tif (removeTask) {\n-\t\t\t// in memory task belongs to non existent facility/service - remove it and return\n-\t\t\ttry {\n-\t\t\t\tremoveTask(task);\n-\t\t\t\treturn;\n-\t\t\t} catch (TaskStoreException e) {\n-\t\t\t\tlog.error(\"[{}] Unable to remove Task from pool: {}.\", task.getId(), e);\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t}\n-\n-\t\t// Task is eligible for running - create new schedule\n-\n-\t\ttask.setSourceUpdated(false);\n-\n-\t\tlong newTaskDelay = 0;\n-\t\tif (!task.isPropagationForced()) {\n-\t\t\t// normal tasks are delayed\n-\t\t\ttry {\n-\t\t\t\tnewTaskDelay = Long.parseLong(dispatcherProperties.getProperty(\"dispatcher.task.delay.time\"));\n-\t\t\t} catch (NumberFormatException e) {\n-\t\t\t\tlog.warn(\"Could not parse value of dispatcher.task.delay.time property. Using default.\");\n-\t\t\t\tnewTaskDelay = 30000;\n-\t\t\t}\n-\t\t}\n-\t\tif (task.isPropagationForced()) {\n-\t\t\tdelayCount = 0;\n-\t\t}\n-\t\tif (delayCount < 0) {\n-\t\t\ttry {\n-\t\t\t\tdelayCount = Integer.parseInt(dispatcherProperties.getProperty(\"dispatcher.task.delay.count\"));\n-\t\t\t} catch (NumberFormatException e) {\n-\t\t\t\tlog.warn(\"Could not parse value of dispatcher.task.delay.count property. Using default.\");\n-\t\t\t\tdelayCount = 4;\n-\t\t\t}\n-\t\t}\n-\n-\t\tTaskSchedule schedule = new TaskSchedule(newTaskDelay, task);\n-\t\tschedule.setBase(System.currentTimeMillis());\n-\t\tschedule.setDelayCount(delayCount);\n-\n-\t\t// Task was newly planned for propagation, switch state.\n-\t\tif (!task.getStatus().equals(TaskStatus.WAITING)) {\n-\n-\t\t\ttask.setStatus(TaskStatus.WAITING);\n-\t\t\ttask.setSchedule(LocalDateTime.now());\n-\t\t\t// clear previous timestamps\n-\t\t\ttask.setSentToEngine((LocalDateTime) null);\n-\t\t\ttask.setStartTime((LocalDateTime) null);\n-\t\t\ttask.setGenStartTime((LocalDateTime) null);\n-\t\t\ttask.setSendStartTime((LocalDateTime) null);\n-\t\t\ttask.setEndTime((LocalDateTime) null);\n-\t\t\ttask.setGenEndTime((LocalDateTime) null);\n-\t\t\ttask.setSendEndTime((LocalDateTime) null);\n-\n-\t\t\ttasksManagerBl.updateTask(task);\n-\n-\t\t}\n-\n-\t\tboolean added = false;\n-\n-\t\tif (schedule.getTask().isPropagationForced()) {\n-\t\t\tadded = waitingForcedTasksQueue.add(schedule);\n-\t\t} else {\n-\t\t\tadded = waitingTasksQueue.add(schedule);\n-\t\t}\n-\n-\t\tif (!added) {\n-\t\t\tlog.error(\"[{}] Task could not be added to waiting queue. Shouldn't ever happen. Look to javadoc of DelayQueue. {}\", task.getId(), schedule);\n-\t\t} else {\n-\t\t\tlog.debug(\"[{}] Task was added to waiting queue: {}\", task.getId(), schedule);\n-\t\t}\n-\n-\t}\n-\n-\t/**\n-\t * Adds Task and associated dispatcherQueue into scheduling pools internal maps and also to the database.\n-\t *\n-\t * @param task            Task which will be added and persisted.\n-\t * @param engineMessageProducer dispatcherQueue associated with the Task which will be added and persisted.\n-\t * @return Number of Tasks in the pool.\n-\t * @throws TaskStoreException\n-\t */\n-\t@Override\n-\tpublic int addToPool(Task task, EngineMessageProducer engineMessageProducer) throws TaskStoreException {\n-\n-\t\tint engineId = (engineMessageProducer == null) ? -1 : engineMessageProducer.getClientID();\n-\t\tif (task.getId() == 0) {\n-\t\t\tif (getTask(task.getFacility(), task.getService()) == null) {\n-\t\t\t\tint id = tasksManagerBl.scheduleNewTask(task, engineId);\n-\t\t\t\ttask.setId(id);\n-\t\t\t\tlog.debug(\"[{}] New Task stored in DB: {}\", task.getId(), task);\n-\t\t\t} else {\n-\t\t\t\tTask existingTask = tasksManagerBl.getTaskById(task.getId());\n-\t\t\t\tif (existingTask == null) {\n-\t\t\t\t\tint id = tasksManagerBl.scheduleNewTask(task, engineId);\n-\t\t\t\t\ttask.setId(id);\n-\t\t\t\t\tlog.debug(\"[{}] New Task stored in DB: {}\", task.getId(), task);\n-\t\t\t\t} else {\n-\t\t\t\t\ttasksManagerBl.updateTask(task);\n-\t\t\t\t\tlog.debug(\"[{}] Task updated in the pool: {}\", task.getId(), task);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\taddTask(task);\n-\t\tenginesByTaskId.put(task.getId(), engineMessageProducer);\n-\t\tlog.debug(\"[{}] Task added to the pool: {}\", task.getId(), task);\n-\t\treturn getSize();\n-\t}\n-\n-\t@Override\n-\tpublic Task removeTask(int id) throws TaskStoreException {\n-\t\treturn taskStore.removeTask(id);\n-\t}\n-\n-\t@Override\n-\tpublic EngineMessageProducer getEngineMessageProducerForTask(Task task) throws InternalErrorException {\n-\t\tif (task == null) {\n-\t\t\tlog.error(\"Supplied Task is null.\");\n-\t\t\tthrow new IllegalArgumentException(\"Task cannot be null\");\n-\t\t}\n-\t\tEngineMessageProducer entry = enginesByTaskId.get(task.getId());\n-\t\tif (entry == null) {\n-\t\t\tthrow new InternalErrorException(\"No Task with ID \" + task.getId());\n-\t\t}\n-\t\treturn entry;\n-\t}\n-\n-\n-\t@Override\n-\tpublic List<Task> getTasksForEngine(int clientID) {\n-\t\tList<Task> result = new ArrayList<Task>();\n-\t\tfor (Map.Entry<Integer, EngineMessageProducer> entry : enginesByTaskId.entrySet()) {\n-\t\t\tif (entry.getValue() != null && clientID == entry.getValue().getClientID()) {\n-\t\t\t\tresult.add(getTask(entry.getKey()));\n-\t\t\t}\n-\t\t}\n-\t\treturn result;\n-\t}\n-\n-\t@Override\n-\tpublic String getReport() {\n-\t\tint waiting = getTasksWithStatus(TaskStatus.WAITING).size();\n-\t\tint planned = getTasksWithStatus(TaskStatus.PLANNED).size();\n-\t\tint generating = getTasksWithStatus(TaskStatus.GENERATING).size();\n-\t\tint generated = getTasksWithStatus(TaskStatus.GENERATED).size();\n-\t\tint generror = getTasksWithStatus(TaskStatus.GENERROR).size();\n-\t\tint sending = getTasksWithStatus(TaskStatus.SENDING).size();\n-\t\tint senderror = getTasksWithStatus(TaskStatus.SENDERROR).size();\n-\t\tint done = getTasksWithStatus(TaskStatus.DONE).size();\n-\t\tint error = getTasksWithStatus(TaskStatus.ERROR).size();\n-\n-\t\treturn \"Dispatcher SchedulingPool Task report:\\n\" +\n-\t\t\t\t\"  WAITING: \" + waiting +\n-\t\t\t\t\"  PLANNED: \" + planned +\n-\t\t\t\t\"  GENERATING: \" + generating +\n-\t\t\t\t\"  GENERATED: \" + generated +\n-\t\t\t\t\"  GENERROR: \" + generror +\n-\t\t\t\t\"  SENDING:  \" + sending +\n-\t\t\t\t\"  SENDEEROR:  \" + senderror +\n-\t\t\t\t\"  DONE: \" + done +\n-\t\t\t\t\"  ERROR: \" + error;\n-\t}\n-\n-\t@Override\n-\tpublic void clear() {\n-\t\ttaskStore.clear();\n-\t\tenginesByTaskId.clear();\n-\t\twaitingTasksQueue.clear();\n-\t\twaitingForcedTasksQueue.clear();\n-\t}\n-\n-\t@Override\n-\tpublic void reloadTasks() {\n-\n-\t\tlog.debug(\"Going to reload Tasks from database...\");\n-\n-\t\tthis.clear();\n-\n-\t\tfor (Pair<Task, Integer> pair : tasksManagerBl.listAllTasksAndClients()) {\n-\t\t\tTask task = pair.getLeft();\n-\t\t\tEngineMessageProducer queue = engineMessageProducerPool.getProducerByClient(pair.getRight());\n-\t\t\ttry {\n-\t\t\t\t// just add DB Task to in-memory structure\n-\t\t\t\taddToPool(task, queue);\n-\t\t\t} catch (TaskStoreException e) {\n-\t\t\t\tlog.error(\"Adding Task {} and Queue {} into SchedulingPool failed, so the Task will be lost.\", task, queue);\n-\t\t\t}\n-\n-\t\t\t// if service was not in DONE or any kind of ERROR - reschedule now\n-\t\t\t// error/done tasks will be rescheduled later by periodic jobs !!\n-\t\t\tif (!Arrays.asList(TaskStatus.DONE, TaskStatus.ERROR, TaskStatus.GENERROR, TaskStatus.SENDERROR).contains(task.getStatus())) {\n-\t\t\t\tif (task.getStatus().equals(TaskStatus.WAITING)) {\n-\t\t\t\t\t// if were in WAITING, reset timestamp to now\n-\t\t\t\t\ttask.setSchedule(LocalDateTime.now());\n-\t\t\t\t\ttasksManagerBl.updateTask(task);\n-\t\t\t\t}\n-\t\t\t\tscheduleTask(task, 0);\n-\t\t\t}\n-\n-\t\t}\n-\n-\t\tlog.debug(\"Reload of Tasks from database finished.\");\n-\n-\t}\n-\n-\t@Override\n-\tpublic void setEngineMessageProducerForTask(Task task, EngineMessageProducer messageProducer) throws InternalErrorException {\n-\t\tTask found = getTask(task.getId());\n-\t\tif (found == null) {\n-\t\t\tthrow new InternalErrorException(\"no task by id \" + task.getId());\n-\t\t} else {\n-\t\t\tenginesByTaskId.put(task.getId(), messageProducer);\n-\t\t}\n-\t\t// if queue is removed, set -1 to task as it's done on task creation if queue is null\n-\t\tint queueId = (messageProducer != null) ? messageProducer.getClientID() : -1;\n-\t\ttasksManagerBl.updateTaskEngine(task, queueId);\n-\t}\n-\n-\t@Override\n-\tpublic void closeTasksForEngine(int clientID) {\n-\n-\t\tList<Task> tasks = getTasksForEngine(clientID);\n-\t\tList<TaskStatus> engineStates = new ArrayList<>();\n-\t\tengineStates.add(TaskStatus.PLANNED);\n-\t\tengineStates.add(TaskStatus.GENERATING);\n-\t\tengineStates.add(TaskStatus.GENERATED);\n-\t\tengineStates.add(TaskStatus.SENDING);\n-\n-\t\t// switch all processing tasks to error, remove the engine queue association\n-\t\tlog.debug(\"Switching processing tasks on engine {} to ERROR, the engine went down...\", clientID);\n-\t\tfor (Task task : tasks) {\n-\t\t\tif (engineStates.contains(task.getStatus())) {\n-\t\t\t\tlog.info(\"[{}] Switching Task to ERROR, the engine it was running on went down.\", task.getId());\n-\t\t\t\ttask.setStatus(TaskStatus.ERROR);\n-\t\t\t}\n-\t\t\ttry {\n-\t\t\t\tsetEngineMessageProducerForTask(task, null);\n-\t\t\t} catch (InternalErrorException e) {\n-\t\t\t\tlog.error(\"[{}] Could not remove dispatcher queue for task: {}.\", task.getId(), e.getMessage());\n-\t\t\t}\n-\t\t}\n-\n-\t}\n-\n-\t@Override\n-\tpublic void onTaskStatusChange(int taskId, String status, String milliseconds) {\n-\n-\t\tTask task = getTask(taskId);\n-\t\tif (task == null) {\n-\t\t\tlog.error(\"[{}] Received status update about Task which is not in Dispatcher anymore, will ignore it.\", taskId);\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tTaskStatus oldStatus = task.getStatus();\n-\t\ttask.setStatus(TaskStatus.valueOf(status));\n-\t\tlong ms;\n-\t\ttry {\n-\t\t\tms = Long.valueOf(milliseconds);\n-\t\t} catch (NumberFormatException e) {\n-\t\t\tlog.warn(\"[{}] Timestamp of change '{}' could not be parsed, current time will be used instead.\", task.getId(), milliseconds);\n-\t\t\tms = System.currentTimeMillis();\n-\t\t}\n-\t\tLocalDateTime changeDate = LocalDateTime.ofInstant(Instant.ofEpochMilli(ms), ZoneId.systemDefault());\n-\n-\t\tswitch (task.getStatus()) {\n-\t\t\tcase WAITING:\n-\t\t\tcase PLANNED:\n-\t\t\t\tlog.error(\"[{}] Received status change to {} from Engine, this should not happen.\", task.getId(), task.getStatus());\n-\t\t\t\treturn;\n-\t\t\tcase GENERATING:\n-\t\t\t\ttask.setStartTime(changeDate);\n-\t\t\t\ttask.setGenStartTime(changeDate);\n-\t\t\t\tbreak;\n-\t\t\tcase GENERROR:\n-\t\t\t\ttask.setEndTime(changeDate);\n-\t\t\tcase GENERATED:\n-\t\t\t\ttask.setGenEndTime(changeDate);\n-\t\t\t\tbreak;\n-\t\t\tcase SENDING:\n-\t\t\t\ttask.setSendStartTime(changeDate);\n-\t\t\t\tbreak;\n-\t\t\tcase DONE:\n-\t\t\tcase SENDERROR:\n-\t\t\t\ttask.setSendEndTime(changeDate);\n-\t\t\t\ttask.setEndTime(changeDate);\n-\t\t\t\tbreak;\n-\t\t\tcase ERROR:\n-\t\t\t\ttask.setEndTime(changeDate);\n-\t\t\t\tbreak;\n-\t\t}\n-\n-\t\ttasksManagerBl.updateTask(task);\n-\n-\t\tlog.debug(\"[{}] Task status changed from {} to {} as reported by Engine: {}.\", task.getId(), oldStatus, task.getStatus(), task);\n-\n-\t}\n-\n-\t@Override\n-\tpublic void onTaskDestinationComplete(int clientID, String string) {\n-\n-\t\tif (string == null || string.isEmpty()) {\n-\t\t\tlog.error(\"Could not parse TaskResult message from Engine {}.\", clientID);\n-\t\t\treturn;\n-\t\t}\n-\n-\t\ttry {\n-\t\t\tList<PerunBean> listOfBeans = AuditParser.parseLog(string);\n-\t\t\tif (!listOfBeans.isEmpty()) {\n-\t\t\t\tTaskResult taskResult = (TaskResult) listOfBeans.get(0);\n-\t\t\t\tlog.debug(\"[{}] Received TaskResult for Task from Engine {}.\", taskResult.getTaskId(), clientID);\n-\t\t\t\tonTaskDestinationComplete(clientID, taskResult);\n-\t\t\t} else {\n-\t\t\t\tlog.error(\"No TaskResult found in message from Engine {}: {}.\", clientID, string);\n-\t\t\t}\n-\t\t} catch (Exception e) {\n-\t\t\tlog.error(\"Could not save TaskResult from Engine {}, {}, {}\", clientID, string, e.getMessage());\n-\t\t}\n-\n-\t}\n-\n-\t@Override\n-\tpublic void onTaskDestinationComplete(int clientID, TaskResult taskResult) {\n-\t\ttry {\n-\t\t\ttasksManagerBl.insertNewTaskResult(taskResult, clientID);\n-\t\t} catch (Exception e) {\n-\t\t\tlog.error(\"Could not save TaskResult from Engine {}, {}, {}\", clientID, taskResult, e.getMessage());\n-\t\t}\n-\t}\n-\n-}\n+ @Autowired\n+ public void setWaitingTasksQueue(DelayQueue<TaskSchedule> waitingTasksQueue) {\n+  this.waitingTasksQueue = waitingTasksQueue;\n+ }\n+\n+ public DelayQueue<TaskSchedule> getWaitingForcedTasksQueue() {\n+  return waitingForcedTasksQueue;\n+ }\n+\n+ @Autowired\n+ public void setWaitingForcedTasksQueue(DelayQueue<TaskSchedule> waitingForcedTasksQueue) {\n+  this.waitingForcedTasksQueue = waitingForcedTasksQueue;\n+ }\n+\n+ public Properties getDispatcherProperties() {\n+  return dispatcherProperties;\n+ }\n+\n+ @Resource(name = \"dispatcherPropertiesBean\")\n+ public void setDispatcherProperties(Properties dispatcherProperties) {\n+  this.dispatcherProperties = dispatcherProperties;\n+ }\n+\n+ public TaskStore getTaskStore() {\n+  return taskStore;\n+ }\n+\n+ @Autowired\n+ public void setTaskStore(TaskStore taskStore) {\n+  this.taskStore = taskStore;\n+ }\n+\n+ public TasksManagerBl getTasksManagerBl() {\n+  return tasksManagerBl;\n+ }\n+\n+ @Autowired\n+ public void setTasksManagerBl(TasksManagerBl tasksManagerBl) {\n+  this.tasksManagerBl = tasksManagerBl;\n+ }\n+\n+ public EngineMessageProducerPool getEngineMessageProducerPool() {\n+  return engineMessageProducerPool;\n+ }\n+\n+ @Autowired\n+ public void setEngineMessageProducerPool(EngineMessageProducerPool engineMessageProducerPool) {\n+  this.engineMessageProducerPool = engineMessageProducerPool;\n+ }\n+\n+ public Perun getPerun() {\n+  return perun;\n+ }\n+\n+ @Autowired\n+ public void setPerun(Perun perun) {\n+  this.perun = perun;\n+ }\n+\n+\n+ // ----- methods -------------------------------------\n+\n+ @Override\n+ public Task getTask(int id) {\n+  return taskStore.getTask(id);\n+ }\n+\n+ @Override\n+ public Task getTask(Facility facility, Service service) {\n+  return taskStore.getTask(facility, service);\n+ }\n+\n+ @Override\n+ public int getSize() {\n+  return taskStore.getSize();\n+ }\n+\n+ @Override\n+ public Task addTask(Task task) throws TaskStoreException {\n+  return taskStore.addTask(task);\n+ }\n+\n+ @Override\n+ public Collection<Task> getAllTasks() {\n+  return taskStore.getAllTasks();\n+ }\n+\n+ @Override\n+ public List<Task> getTasksWithStatus(TaskStatus... status) {\n+  return taskStore.getTasksWithStatus(status);\n+ }\n+\n+ @Override\n+ public Task removeTask(Task task) throws TaskStoreException {\n+  return taskStore.removeTask(task);\n+ }\n+\n+ @Override\n+ public void scheduleTask(Task task, int delayCount) {\n+\n+  // init session\n+  try {\n+   if (sess == null) {\n+    sess = perun.getPerunSession(\n+     new PerunPrincipal(dispatcherProperties.getProperty(\"perun.principal.name\"), dispatcherProperties.getProperty(\"perun.principal.extSourceName\"), dispatcherProperties.getProperty(\"perun.principal.extSourceType\")), new PerunClient());\n+   }\n+  } catch (InternalErrorException e1) {\n+   log.error(\"Error establishing perun session to add task schedule: \", e1);\n+   return;\n+  }\n+\n+  // check if service/facility exists\n+\n+  boolean removeTask = false;\n+  try {\n+   Service service = perun.getServicesManager().getServiceById(sess, task.getServiceId());\n+   Facility facility = perun.getFacilitiesManager().getFacilityById(sess, task.getFacilityId());\n+   task.setService(service);\n+   task.setFacility(facility);\n+  } catch (ServiceNotExistsException e) {\n+   log.error(\"[{}] Task NOT added to waiting queue, service not exists: {}.\", task.getId(), task);\n+   removeTask = true;\n+  } catch (FacilityNotExistsException e) {\n+   log.error(\"[{}] Task NOT added to waiting queue, facility not exists: {}.\", task.getId(), task);\n+   removeTask = true;\n+  } catch (InternalErrorException | PrivilegeException e) {\n+   log.error(\"[{}] {}\", task.getId(), e);\n+  }\n+  if (!task.getService().isEnabled() || ((PerunBl) perun).getServicesManagerBl().isServiceBlockedOnFacility(task.getService(), task.getFacility())) {\n+   log.error(\"[{}] Task NOT added to waiting queue, service is blocked: {}.\", task.getId(), task);\n+   // do not change Task status or any other data !\n+   if (!removeTask)\n+    return;\n+  }\n+\n+  try {\n+   List<Destination> destinations = perun.getServicesManager().getDestinations(sess, task.getService(), task.getFacility());\n+   if (destinations != null && !destinations.isEmpty()) {\n+    Iterator<Destination> iter = destinations.iterator();\n+    while (iter.hasNext()) {\n+     Destination dest = iter.next();\n+     if (((PerunBl) perun).getServicesManagerBl().isServiceBlockedOnDestination(task.getService(), dest.getId())) {\n+      iter.remove();\n+     }\n+    }\n+    if (destinations.isEmpty()) {\n+     // All service destinations were blocked -> Task is denied to be sent to engine just like\n+     // when service is blocked globally in Perun or on facility as a whole.\n+     log.debug(\"[{}] Task NOT added to waiting queue, all its destinations are blocked.\", task.getId());\n+     if (!removeTask)\n+      return;\n+    }\n+   }\n+  } catch (ServiceNotExistsException e) {\n+   log.error(\"[{}] Task NOT added to waiting queue, service not exists: {}.\", task.getId(), task);\n+   removeTask = true;\n+  } catch (FacilityNotExistsException e) {\n+   log.error(\"[{}] Task NOT added to waiting queue, facility not exists: {}.\", task.getId(), task);\n+   removeTask = true;\n+  } catch (InternalErrorException | PrivilegeException e) {\n+   log.error(\"[{}] {}\", task.getId(), e);\n+  }\n+\n+  try {\n+   List<Service> assignedServices = perun.getServicesManager().getAssignedServices(sess, task.getFacility());\n+   if (!assignedServices.contains(task.getService())) {\n+    log.debug(\"[{}] Task NOT added to waiting queue, service is not assigned to facility any more: {}.\",\n+    task.getId(),\n+    task);\n+    if (!removeTask)\n+     return;\n+   }\n+  } catch (FacilityNotExistsException e) {\n+   removeTask = true;\n+   log.error(\"[{}] Task removed from database, facility no longer exists: {}.\", task.getId(), task);\n+  } catch (InternalErrorException | PrivilegeException e) {\n+   log.error(\"[{}] Unable to check Service assignment to Facility: {}\", task.getId(), e.getMessage());\n+  }\n+  if (removeTask) {\n+   // in memory task belongs to non existent facility/service - remove it and return\n+   try {\n+    removeTask(task);\n+    return;\n+   } catch (TaskStoreException e) {\n+    log.error(\"[{}] Unable to remove Task from pool: {}.\", task.getId(), e);\n+    return;\n+   }\n+  }\n+\n+  // Task is eligible for running - create new schedule\n+  task.setSourceUpdated(false);\n+  long newTaskDelay = 0;\n+  if (!task.isPropagationForced()) {\n+   // normal tasks are delayed\n+   try {\n+    newTaskDelay = Long.parseLong(dispatcherProperties.getProperty(\"dispatcher.task.delay.time\"));\n+   } catch (NumberFormatException e) {\n+    log.warn(\"Could not parse value of dispatcher.task.delay.time property. Using default.\");\n+    newTaskDelay = 30000;\n+   }\n+  }\n+  if (task.isPropagationForced()) {\n+   delayCount = 0;\n+  }\n+  if (delayCount< 0) {\n+   try {\n+    delayCount = Integer.parseInt(dispatcherProperties.getProperty(\"dispatcher.task.delay.count\"));\n+   } catch (NumberFormatException e) {\n+    log.warn(\"Could not parse value of dispatcher.task.delay.count property. Using default.\");\n+    delayCount = 4;\n+   }\n+  }\n+  TaskSchedule schedule = new TaskSchedule(newTaskDelay, task);\n+  schedule.setBase(System.currentTimeMillis());\n+  schedule.setDelayCount(delayCount);\n+\n+  // Task was newly planned for propagation, switch state.\n+  if (!task.getStatus().equals(TaskStatus.WAITING)) {\n+   task.setStatus(TaskStatus.WAITING);\n+   task.setSchedule(LocalDateTime.now());\n+   // clear previous timestamps\n+   task.setSentToEngine((LocalDateTime) null);\n+   task.setStartTime((LocalDateTime) null);\n+   task.setGenStartTime((LocalDateTime) null);\n+   task.setSendStartTime((LocalDateTime) null);\n+   task.setEndTime((LocalDateTime) null);\n+   task.setGenEndTime((LocalDateTime) null);\n+   task.setSendEndTime((LocalDateTime) null);\n+   tasksManagerBl.updateTask(task);\n+  }\n+\n+  boolean added = false;\n+  if (schedule.getTask().isPropagationForced()) {\n+   added = waitingForcedTasksQueue.add(schedule);\n+  } else {\n+   added = waitingTasksQueue.add(schedule);\n+  }\n+  if (!added) {\n+   log.error(\"[{}] Task could not be added to waiting queue. Shouldn't ever happen. Look to javadoc of DelayQueue. {}\", task.getId(), schedule);\n+  } else {\n+   log.debug(\"[{}] Task was added to waiting queue: {}\", task.getId(), schedule);\n+  }\n+ }\n+\n+ /**\n+  * Adds Task and associated dispatcherQueue into scheduling pools internal maps and also to the database.\n+  *\n+  * @param task            Task which will be added and persisted.\n+  * @param engineMessageProducer dispatcherQueue associated with the Task which will be added and persisted.\n+  * @return Number of Tasks in the pool.\n+  * @throws TaskStoreException\n+  */\n+\n+ @Override\n+ public int addToPool(Task task, EngineMessageProducer engineMessageProducer) throws TaskStoreException {\n+  int engineId = (engineMessageProducer == null) ? -1 : engineMessageProducer.getClientID();\n+  if (task.getId() == 0) {\n+   if (getTask(task.getFacility(), task.getService()) == null) {\n+    int id = tasksManagerBl.scheduleNewTask(task, engineId);\n+    task.setId(id);\n+    log.debug(\"[{}] New Task stored in DB: {}\", task.getId(), task);\n+   } else {\n+    Task existingTask = tasksManagerBl.getTaskById(task.getId());\n+    if (existingTask == null) {\n+     int id = tasksManagerBl.scheduleNewTask(task, engineId);\n+     task.setId(id);\n+     log.debug(\"[{}] New Task stored in DB: {}\", task.getId(), task);\n+    } else {\n+     tasksManagerBl.updateTask(task);\n+     log.debug(\"[{}] Task updated in the pool: {}\", task.getId(), task);\n+    }\n+   }\n+  }\n+  addTask(task);\n+  enginesByTaskId.put(task.getId(), engineMessageProducer);\n+  log.debug(\"[{}] Task added to the pool: {}\", task.getId(), task);\n+  return getSize();\n+ }\n+\n+ @Override\n+ public Task removeTask(int id) throws TaskStoreException {\n+  return taskStore.removeTask(id);\n+ }\n+\n+ @Override\n+ public EngineMessageProducer getEngineMessageProducerForTask(Task task) throws InternalErrorException {\n+  if (task == null) {\n+   log.error(\"Supplied Task is null.\");\n+   throw new IllegalArgumentException(\"Task cannot be null\");\n+  }\n+  EngineMessageProducer entry = enginesByTaskId.get(task.getId());\n+  if (entry == null) {\n+   throw new InternalErrorException(\"No Task with ID \" + task.getId());\n+  }\n+\n+  return entry;\n+ }\n+\n+ @Override\n+ public List<Task> getTasksForEngine(int clientID) {\n+  List<Task> result = new ArrayList<Task>();\n+  for (Map.Entry<Integer, EngineMessageProducer> entry : enginesByTaskId.entrySet()) {\n+   if (entry.getValue() != null && clientID == entry.getValue().getClientID()) {\n+    result.add(getTask(entry.getKey()));\n+   }\n+  }\n+\n+  return result;\n+ }\n+\n+ @Override\n+ public String getReport() {\n+  int waiting = getTasksWithStatus(TaskStatus.WAITING).size();\n+  int planned = getTasksWithStatus(TaskStatus.PLANNED).size();\n+  int generating = getTasksWithStatus(TaskStatus.GENERATING).size();\n+  int generated = getTasksWithStatus(TaskStatus.GENERATED).size();\n+  int generror = getTasksWithStatus(TaskStatus.GENERROR).size();\n+  int sending = getTasksWithStatus(TaskStatus.SENDING).size();\n+  int senderror = getTasksWithStatus(TaskStatus.SENDERROR).size();\n+  int done = getTasksWithStatus(TaskStatus.DONE).size();\n+  int error = getTasksWithStatus(TaskStatus.ERROR).size();\n+  return \"Dispatcher SchedulingPool Task report:\\n\" + \"  WAITING: \" + waiting + \"  PLANNED: \" + planned + \"  GENERATING: \" + generating + \"  GENERATED: \" + generated + \"  GENERROR: \" + generror + \"  SENDING:  \" + sending + \"  SENDEEROR:  \" + senderror + \"  DONE: \" + done + \"  ERROR: \" + error;\n+ }\n+\n+ @Override\n+ public void clear() {\n+  taskStore.clear();\n+  enginesByTaskId.clear();\n+  waitingTasksQueue.clear();\n+  waitingForcedTasksQueue.clear();\n+ }\n+\n+ @Override\n+ public void reloadTasks() {\n+  log.debug(\"Going to reload Tasks from database...\");\n+  this.clear();\n+  for (Pair<Task, Integer> pair : tasksManagerBl.listAllTasksAndClients()) {\n+   Task task = pair.getLeft();\n+   EngineMessageProducer queue = engineMessageProducerPool.getProducerByClient(pair.getRight());\n+   try {\n+    // just add DB Task to in-memory structure\n+    addToPool(task, queue);\n+   } catch (TaskStoreException e) {\n+    log.error(\"Adding Task {} and Queue {} into SchedulingPool failed, so the Task will be lost.\", task, queue);\n+   }\n+\n+   // if service was not in DONE or any kind of ERROR - reschedule now\n+   // error/done tasks will be rescheduled later by periodic jobs !!\n+   if (!Arrays.asList(TaskStatus.DONE, TaskStatus.ERROR, TaskStatus.GENERROR, TaskStatus.SENDERROR).contains(task.getStatus())) {\n+    if (task.getStatus().equals(TaskStatus.WAITING)) {\n+     // if were in WAITING, reset timestamp to now\n+     task.setSchedule(LocalDateTime.now());\n+     tasksManagerBl.updateTask(task);\n+    }\n+    scheduleTask(task, 0);\n+   }\n+  }\n+  log.debug(\"Reload of Tasks from database finished.\");\n+ }\n+\n+ @Override\n+ public void setEngineMessageProducerForTask(Task task, EngineMessageProducer messageProducer) throws InternalErrorException {\n+  Task found = getTask(task.getId());\n+  if (found == null) {\n+   throw new InternalErrorException(\"no task by id \" + task.getId());\n+  } else {\n+   enginesByTaskId.put(task.getId(), messageProducer);\n+  }\n+  // if queue is removed, set -1 to task as it's done on task creation if queue is null\n+\n+  int queueId = (messageProducer != null) ? messageProducer.getClientID() : -1;\n+  tasksManagerBl.updateTaskEngine(task, queueId);\n+ }\n+\n+ @Override\n+ public void closeTasksForEngine(int clientID) {\n+  List<Task> tasks = getTasksForEngine(clientID);\n+  List<TaskStatus> engineStates = new ArrayList<>();\n+  engineStates.add(TaskStatus.PLANNED);\n+  engineStates.add(TaskStatus.GENERATING);\n+  engineStates.add(TaskStatus.GENERATED);\n+  engineStates.add(TaskStatus.SENDING);\n+\n+  // switch all processing tasks to error, remove the engine queue association\n+  log.debug(\"Switching processing tasks on engine {} to ERROR, the engine went down...\", clientID);\n+  for (Task task : tasks) {\n+   if (engineStates.contains(task.getStatus())) {\n+    log.info(\"[{}] Switching Task to ERROR, the engine it was running on went down.\", task.getId());\n+    task.setStatus(TaskStatus.ERROR);\n+   }\n+\n+   try {\n+    setEngineMessageProducerForTask(task, null);\n+   } catch (InternalErrorException e) {\n+    log.error(\"[{}] Could not remove dispatcher queue for task: {}.\", task.getId(), e.getMessage());\n+   }\n+  }\n+ }\n+\n+ @Override\n+ public void onTaskStatusChange(int taskId, String status, String milliseconds) {\n+  Task task = getTask(taskId);\n+  if (task == null) {\n+   log.error(\"[{}] Received status update about Task which is not in Dispatcher anymore, will ignore it.\", taskId);\n+   return;\n+  }\n+  TaskStatus oldStatus = task.getStatus();\n+  task.setStatus(TaskStatus.valueOf(status));\n+  long ms;\n+  try {\n+   ms = Long.valueOf(milliseconds);\n+  } catch (NumberFormatException e) {\n+   log.warn(\"[{}] Timestamp of change '{}' could not be parsed, current time will be used instead.\",\n+   task.getId(),\n+   milliseconds);\n+   ms = System.currentTimeMillis();\n+  }\n+  LocalDateTime changeDate = LocalDateTime.ofInstant(Instant.ofEpochMilli(ms), ZoneId.systemDefault());\n+\n+  switch (task.getStatus()) {\n+   case WAITING:\n+   case PLANNED:\n+    log.error(\"[{}] Received status change to {} from Engine, this should not happen.\",\n+    task.getId(),\n+    task.getStatus());\n+    return;\n+   case GENERATING:\n+    task.setStartTime(changeDate);\n+    task.setGenStartTime(changeDate);\n+    break;\n+   case GENERROR:\n+    task.setEndTime(changeDate);\n+   case GENERATED:\n+    task.setGenEndTime(changeDate);\n+    break;\n+   case SENDING:\n+    task.setSendStartTime(changeDate);\n+    break;\n+   case DONE:\n+   case SENDERROR:\n+    task.setSendEndTime(changeDate);\n+    task.setEndTime(changeDate);\n+    break;\n+   case ERROR:\n+    task.setEndTime(changeDate);\n+    break;\n+  }\n+  tasksManagerBl.updateTask(task);\n+  log.debug(\"[{}] Task status changed from {} to {} as reported by Engine: {}.\",\n+  task.getId(),\n+  oldStatus,\n+  task.getStatus(),\n+  task);\n+ }\n+\n+ @Override\n+ public void onTaskDestinationComplete(int clientID, String string) {\n+  if (string == null || string.isEmpty()) {\n+   log.error(\"Could not parse TaskResult message from Engine {}.\", clientID);\n+   return;\n+  }\n+\n+  try {\n+   List<PerunBean> listOfBeans = AuditParser.parseLog(string);\n+   if (!listOfBeans.isEmpty()) {\n+    TaskResult taskResult = (TaskResult) listOfBeans.get(0);\n+    log.debug(\"[{}] Received TaskResult for Task from Engine {}.\", taskResult.getTaskId(), clientID);\n+    onTaskDestinationComplete(clientID, taskResult);\n+   } else {\n+    log.error(\"No TaskResult found in message from Engine {}: {}.\", clientID, string);\n+   }\n+  } catch (Exception e) {\n+   log.error(\"Could not save TaskResult from Engine {}, {}, {}\", clientID, string, e.getMessage());\n+  }\n+ }\n+\n+ @Override\n+ public void onTaskDestinationComplete(int clientID, TaskResult taskResult) {\n+  try {\n+   tasksManagerBl.insertNewTaskResult(taskResult, clientID);\n+  } catch (Exception e) {\n+   log.error(\"Could not save TaskResult from Engine {}, {}, {}\", clientID, taskResult, e.getMessage());\n+  }\n+ }\n+}\n\\ No newline at end of file\n",
            "diff_size": 548
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/103/SchedulingPoolImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/styler_random/103/SchedulingPoolImpl.java\nindex 0b8208d85c5..9730edbc6aa 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/103/SchedulingPoolImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/styler_random/103/SchedulingPoolImpl.java\n@@ -76,7 +76,7 @@ public class SchedulingPoolImpl implements SchedulingPool {\n \t}\n \n \tpublic SchedulingPoolImpl(Properties dispatcherPropertiesBean, TaskStore taskStore,\n-\t\t\t\t\t\t\t  TasksManagerBl tasksManagerBl, EngineMessageProducerPool engineMessageProducerPool) {\n+\t\t\tTasksManagerBl tasksManagerBl, EngineMessageProducerPool engineMessageProducerPool) {\n \t\tthis.dispatcherProperties = dispatcherPropertiesBean;\n \t\tthis.taskStore = taskStore;\n \t\tthis.tasksManagerBl = tasksManagerBl;\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/103/SchedulingPoolImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/styler_three_grams/103/SchedulingPoolImpl.java\nindex 0b8208d85c5..19a98e2eabf 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/103/SchedulingPoolImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/styler_three_grams/103/SchedulingPoolImpl.java\n@@ -76,7 +76,7 @@ public class SchedulingPoolImpl implements SchedulingPool {\n \t}\n \n \tpublic SchedulingPoolImpl(Properties dispatcherPropertiesBean, TaskStore taskStore,\n-\t\t\t\t\t\t\t  TasksManagerBl tasksManagerBl, EngineMessageProducerPool engineMessageProducerPool) {\n+\tTasksManagerBl tasksManagerBl, EngineMessageProducerPool engineMessageProducerPool) {\n \t\tthis.dispatcherProperties = dispatcherPropertiesBean;\n \t\tthis.taskStore = taskStore;\n \t\tthis.tasksManagerBl = tasksManagerBl;\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "naturalize"
    ]
}