{
    "project_name": "TIBCOSoftware-genxdm",
    "error_id": "209",
    "information": {
        "errors": [
            {
                "line": "43",
                "column": "1",
                "severity": "warning",
                "message": "File contains tab characters (this is the first instance).",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
            }
        ]
    },
    "source_code": "abstract class IdentityScope\n{\n\tprivate final IdentityConstraint m_constraint;\n\tprotected final SchemaExceptionHandler m_errorHandler;\n\n\t/**",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "44",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/209/IdentityScope.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler/209/IdentityScope.java\nindex f668db2f791..7787e3a7a68 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/209/IdentityScope.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler/209/IdentityScope.java\n@@ -40,7 +40,7 @@ import org.genxdm.xs.types.Type;\n  */\n abstract class IdentityScope\n {\n-\tprivate final IdentityConstraint m_constraint;\n+private final IdentityConstraint m_constraint;\n \tprotected final SchemaExceptionHandler m_errorHandler;\n \n \t/**\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "217",
                    "column": "3",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/209/IdentityScope.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/intellij/209/IdentityScope.java\nindex f668db2f791..a85731ac909 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/209/IdentityScope.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/intellij/209/IdentityScope.java\n@@ -1,18 +1,19 @@\n /**\n  * Copyright (c) 2009-2010 TIBCO Software Inc.\n- *\n+ * <p>\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+\n package org.genxdm.processor.w3c.xs.validation.impl;\n \n import java.util.ArrayList;\n@@ -38,195 +39,185 @@ import org.genxdm.xs.types.Type;\n  * Not surprisingly, this evaluation class mimicks the identity-constraint by having a selector and a list of fields\n  * that are of type {@link IdentitySelector}. The selector is established immediately (upon initialization)\n  */\n-abstract class IdentityScope\n-{\n-\tprivate final IdentityConstraint m_constraint;\n-\tprotected final SchemaExceptionHandler m_errorHandler;\n-\n-\t/**\n-\t * The element information that is the context element for the xs:selector.\n-\t */\n-\t@SuppressWarnings(\"unused\")\n-\tprivate final int m_elementIndex;\n-\n-\t/**\n-\t * There is one {selector} evaluator for this identity scope. However, the {selector} evaluator matches zero-or-more\n-\t * target nodes (element information items) and for each element information item we will have a set of {field}\n-\t * evaluators. So from a scope perspective the {field} evaluators are part of a map keyed by the element information\n-\t * item.\n-\t */\n-\tprivate final IdentitySelector m_selectorEval;\n-\tfinal HashMap<Integer, Integer> m_boundFields = new HashMap<Integer, Integer>();\n-\tfinal HashMap<Integer, ArrayList<IdentityField>> m_fieldEvals = new HashMap<Integer, ArrayList<IdentityField>>();\n-\n-\t/**\n-\t * A map from a key (tuple of values) to Boolean.TRUE | list of {@link IdentityDanglingReference}.\n-\t */\n-\t// protected HashMap<IdentityTuple<A>, IdentityVariant<A>>\n-\t// m_qualifiedTargets;\n-\tprotected final LocationInSchema m_location;\n-\n-\tprotected IdentityScope(final int elementIndex, final IdentityConstraint constraint, final SchemaExceptionHandler errorHandler, final LocationInSchema location)\n-\t{\n-\t\tm_elementIndex = elementIndex;\n-\t\tm_constraint = PreCondition.assertArgumentNotNull(constraint);\n-\t\tm_errorHandler = PreCondition.assertArgumentNotNull(errorHandler);\n-\n-\t\tm_location = location;\n-\n-\t\tm_selectorEval = new IdentitySelector(this, m_constraint.getSelector());\n-\t}\n-\n-\t/**\n-\t * Called when its full complement of keys have been completed.\n-\t * \n-\t * @param elementIndex\n-\t *            The index of the element that is the context for xs:field evaluation.\n-\t * @param keyValues\n-\t *            The key values.\n-\t */\n-\tprotected abstract void onKeysComplete(final ArrayList<IdentityKey> keyValues, final int elementIndex) throws AbortException;\n-\n-\t/**\n-\t * Called when the selector goes out of scope.\n-\t * \n-\t * @param elementIndex\n-\t *            The index of the element that is the context for xs:field evaluation.\n-\t */\n-\tprotected abstract void onScopeEnd(final int elementIndex, final Locatable location) throws AbortException;\n-\n-\tpublic void startElement(final QName elementName, final int elementIndex, final Type elementType, final Locatable locatable) throws AbortException\n-\t{\n-\t\tfor (final ArrayList<IdentityField> contextFields : m_fieldEvals.values())\n-\t\t{\n-\t\t\tfor (final IdentityField field : contextFields)\n-\t\t\t{\n-\t\t\t\tfield.startElement(elementName, elementIndex, elementType, locatable);\n-\t\t\t}\n-\t\t}\n-\n-\t\tm_selectorEval.startElement(elementName, elementIndex);\n-\t}\n-\n-\tpublic <A> void attribute(final QName attributeName, final List<? extends A> actualValue, final int attributeIndex, final SimpleType attributeType, final Locatable locatable, final AtomBridge<A> atomBridge) throws AbortException\n-\t{\n-\t\tfor (final ArrayList<IdentityField> contextFields : m_fieldEvals.values())\n-\t\t{\n-\t\t\tfor (final IdentityField field : contextFields)\n-\t\t\t{\n-\t\t\t\tfield.attribute(attributeName, actualValue, attributeIndex, attributeType, locatable, atomBridge);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic <A> void text(final List<? extends A> actualValue, final SimpleType actualType, final int textIndex, final Locatable locatable, final AtomBridge<A> atomBridge) throws AbortException\n-\t{\n-\t\tfor (final ArrayList<IdentityField> contextFields : m_fieldEvals.values())\n-\t\t{\n-\t\t\tfor (final IdentityField field : contextFields)\n-\t\t\t{\n-\t\t\t\tfield.text(actualValue, actualType, textIndex, locatable, atomBridge);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic void endElement(final QName elementName, final int elementIndex, final Locatable locatable) throws AbortException\n-\t{\n-\t\tm_selectorEval.endElement(elementName, elementIndex, locatable);\n-\n-\t\tfor (final ArrayList<IdentityField> contextFields : m_fieldEvals.values())\n-\t\t{\n-\t\t\tfor (final IdentityField field : contextFields)\n-\t\t\t{\n-\t\t\t\tfield.endElement(elementName, elementIndex, locatable);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic IdentityConstraint getConstraint()\n-\t{\n-\t\treturn m_constraint;\n-\t}\n-\n-\t/**\n-\t * We've found and element that matches the {selector}, so install handlers for the fields. This only needs to be\n-\t * done once for a given selected element, therby accounting for duplicates caused by the union(s) in the XPath\n-\t * {selector} expression.\n-\t * \n-\t * @param elementName\n-\t *            The name of the selected element.\n-\t * @param elementIndex\n-\t *            The index of the selected element.\n-\t */\n-\tpublic void startSelectorElement(final QName elementName, final int elementIndex)\n-\t{\n-\t\t// Avoid duplication caused by XPath unions.\n-\t\tif (!m_boundFields.containsKey(elementIndex))\n-\t\t{\n-\t\t\t// No fields have been bound yet for this element.\n-\t\t\tm_boundFields.put(elementIndex, 0);\n-\n-\t\t\tfinal ArrayList<IdentityField> fieldEvals = new ArrayList<IdentityField>();\n-\t\t\tfor (final RestrictedXPath path : getConstraint().getFields())\n-\t\t\t{\n-\t\t\t\tfieldEvals.add(new IdentityField(path, elementIndex, this, m_errorHandler));\n-\t\t\t}\n-\t\t\tm_fieldEvals.put(elementIndex, fieldEvals);\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\t// A redundant union in the XPath expression caused duplication.\n-\t\t\t// Ignore.\n-\t\t}\n-\t}\n-\n-\tpublic void endSelectorElement(final QName elementName, final int elementIndex, final Locatable location) throws AbortException\n-\t{\n-\t\tif (m_boundFields.containsKey(elementIndex))\n-\t\t{\n-\t\t\ttry\n-\t\t\t{\n-\t\t\t\tonScopeEnd(elementIndex, location);\n-\t\t\t}\n-\t\t\tfinally\n-\t\t\t{\n-\t\t\t\tm_fieldEvals.remove(elementIndex);\n-\t\t\t\tm_boundFields.remove(elementIndex);\n-\t\t\t}\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\t// We must have duplicates and removed it already.\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * When all fields have been gathered, report back up to the scope. This method is called by an IdentityField when\n-\t * its's value has been set.\n-\t * \n-\t * @param changedField\n-\t *            The {@link IdentityField} that had its value set.\n-\t */\n-\t<A> void onFieldValueSet(final IdentityField changedField, final int elementIndex, final AtomBridge<A> atomBridge) throws AbortException\n-\t{\n-\t\t// Note: We don't currently use the \"changedField\" parameter.\n-\t\tfinal ArrayList<IdentityField> elementHandlers = m_fieldEvals.get(elementIndex);\n-\n-\t\t// Increment the number of fields that have been bound.\n-\t\tfinal int boundFields = m_boundFields.get(elementIndex) + 1;\n-\t\tm_boundFields.put(elementIndex, boundFields);\n-\n-\t\t// When all the fields have been set, gather the values together and\n-\t\t// notify the scope.\n-\t\tif (boundFields == elementHandlers.size())\n-\t\t{\n-\t\t\tfinal ArrayList<IdentityKey> fieldValues = new ArrayList<IdentityKey>(boundFields);\n-\t\t\tfor (final IdentityField field : elementHandlers)\n-\t\t\t{\n+abstract class IdentityScope {\n+    private final IdentityConstraint m_constraint;\n+\n+    protected final SchemaExceptionHandler m_errorHandler;\n+\n+    /**\n+     * The element information that is the context element for the xs:selector.\n+     */\n+    @SuppressWarnings(\"unused\")\n+    private final int m_elementIndex;\n+\n+    /**\n+     * There is one {selector} evaluator for this identity scope. However, the {selector} evaluator matches zero-or-more\n+     * target nodes (element information items) and for each element information item we will have a set of {field}\n+     * evaluators. So from a scope perspective the {field} evaluators are part of a map keyed by the element information\n+     * item.\n+     */\n+    private final IdentitySelector m_selectorEval;\n+\n+    final HashMap<Integer, Integer> m_boundFields = new HashMap<Integer, Integer>();\n+\n+    final HashMap<Integer, ArrayList<IdentityField>> m_fieldEvals =\n+        new HashMap<Integer, ArrayList<IdentityField>>();\n+\n+    /**\n+     * A map from a key (tuple of values) to Boolean.TRUE | list of {@link IdentityDanglingReference}.\n+     */\n+    // protected HashMap<IdentityTuple<A>, IdentityVariant<A>>\n+    // m_qualifiedTargets;\n+    protected final LocationInSchema m_location;\n+\n+    protected IdentityScope(final int elementIndex, final IdentityConstraint constraint,\n+                            final SchemaExceptionHandler errorHandler,\n+                            final LocationInSchema location) {\n+        m_elementIndex = elementIndex;\n+        m_constraint = PreCondition.assertArgumentNotNull(constraint);\n+        m_errorHandler = PreCondition.assertArgumentNotNull(errorHandler);\n+\n+        m_location = location;\n+\n+        m_selectorEval = new IdentitySelector(this, m_constraint.getSelector());\n+    }\n+\n+    /**\n+     * Called when its full complement of keys have been completed.\n+     *\n+     * @param elementIndex\n+     *            The index of the element that is the context for xs:field evaluation.\n+     * @param keyValues\n+     *            The key values.\n+     */\n+    protected abstract void onKeysComplete(final ArrayList<IdentityKey> keyValues,\n+                                           final int elementIndex) throws AbortException;\n+\n+    /**\n+     * Called when the selector goes out of scope.\n+     *\n+     * @param elementIndex\n+     *            The index of the element that is the context for xs:field evaluation.\n+     */\n+    protected abstract void onScopeEnd(final int elementIndex, final Locatable location)\n+        throws AbortException;\n+\n+    public void startElement(final QName elementName, final int elementIndex,\n+                             final Type elementType, final Locatable locatable)\n+        throws AbortException {\n+        for (final ArrayList<IdentityField> contextFields : m_fieldEvals.values()) {\n+            for (final IdentityField field : contextFields) {\n+                field.startElement(elementName, elementIndex, elementType, locatable);\n+            }\n+        }\n+\n+        m_selectorEval.startElement(elementName, elementIndex);\n+    }\n+\n+    public <A> void attribute(final QName attributeName, final List<? extends A> actualValue,\n+                              final int attributeIndex, final SimpleType attributeType,\n+                              final Locatable locatable, final AtomBridge<A> atomBridge)\n+        throws AbortException {\n+        for (final ArrayList<IdentityField> contextFields : m_fieldEvals.values()) {\n+            for (final IdentityField field : contextFields) {\n+                field\n+                    .attribute(attributeName, actualValue, attributeIndex, attributeType, locatable,\n+                        atomBridge);\n+            }\n+        }\n+    }\n+\n+    public <A> void text(final List<? extends A> actualValue, final SimpleType actualType,\n+                         final int textIndex, final Locatable locatable,\n+                         final AtomBridge<A> atomBridge) throws AbortException {\n+        for (final ArrayList<IdentityField> contextFields : m_fieldEvals.values()) {\n+            for (final IdentityField field : contextFields) {\n+                field.text(actualValue, actualType, textIndex, locatable, atomBridge);\n+            }\n+        }\n+    }\n+\n+    public void endElement(final QName elementName, final int elementIndex,\n+                           final Locatable locatable) throws AbortException {\n+        m_selectorEval.endElement(elementName, elementIndex, locatable);\n+\n+        for (final ArrayList<IdentityField> contextFields : m_fieldEvals.values()) {\n+            for (final IdentityField field : contextFields) {\n+                field.endElement(elementName, elementIndex, locatable);\n+            }\n+        }\n+    }\n+\n+    public IdentityConstraint getConstraint() {\n+        return m_constraint;\n+    }\n+\n+    /**\n+     * We've found and element that matches the {selector}, so install handlers for the fields. This only needs to be\n+     * done once for a given selected element, therby accounting for duplicates caused by the union(s) in the XPath\n+     * {selector} expression.\n+     *\n+     * @param elementName\n+     *            The name of the selected element.\n+     * @param elementIndex\n+     *            The index of the selected element.\n+     */\n+    public void startSelectorElement(final QName elementName, final int elementIndex) {\n+        // Avoid duplication caused by XPath unions.\n+        if (!m_boundFields.containsKey(elementIndex)) {\n+            // No fields have been bound yet for this element.\n+            m_boundFields.put(elementIndex, 0);\n+\n+            final ArrayList<IdentityField> fieldEvals = new ArrayList<IdentityField>();\n+            for (final RestrictedXPath path : getConstraint().getFields()) {\n+                fieldEvals.add(new IdentityField(path, elementIndex, this, m_errorHandler));\n+            }\n+            m_fieldEvals.put(elementIndex, fieldEvals);\n+        } else {\n+            // A redundant union in the XPath expression caused duplication.\n+            // Ignore.\n+        }\n+    }\n+\n+    public void endSelectorElement(final QName elementName, final int elementIndex,\n+                                   final Locatable location) throws AbortException {\n+        if (m_boundFields.containsKey(elementIndex)) {\n+            try {\n+                onScopeEnd(elementIndex, location);\n+            } finally {\n+                m_fieldEvals.remove(elementIndex);\n+                m_boundFields.remove(elementIndex);\n+            }\n+        } else {\n+            // We must have duplicates and removed it already.\n+        }\n+    }\n+\n+    /**\n+     * When all fields have been gathered, report back up to the scope. This method is called by an IdentityField when\n+     * its's value has been set.\n+     *\n+     * @param changedField\n+     *            The {@link IdentityField} that had its value set.\n+     */\n+    <A> void onFieldValueSet(final IdentityField changedField, final int elementIndex,\n+                             final AtomBridge<A> atomBridge) throws AbortException {\n+        // Note: We don't currently use the \"changedField\" parameter.\n+        final ArrayList<IdentityField> elementHandlers = m_fieldEvals.get(elementIndex);\n+\n+        // Increment the number of fields that have been bound.\n+        final int boundFields = m_boundFields.get(elementIndex) + 1;\n+        m_boundFields.put(elementIndex, boundFields);\n+\n+        // When all the fields have been set, gather the values together and\n+        // notify the scope.\n+        if (boundFields == elementHandlers.size()) {\n+            final ArrayList<IdentityKey> fieldValues = new ArrayList<IdentityKey>(boundFields);\n+            for (final IdentityField field : elementHandlers) {\n //\t\t\t\tfieldValues.add(new IdentityKey(field.getTypedValue(atomBridge)));\n                 fieldValues.add(new IdentityKey(field.m_value));\n-\t\t\t}\n-\t\t\tonKeysComplete(fieldValues, elementIndex);\n-\t\t}\n-\t}\n+            }\n+            onKeysComplete(fieldValues, elementIndex);\n+        }\n+    }\n }\n",
            "diff_size": 194
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/209/IdentityScope.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/codebuff/209/IdentityScope.java\nindex f668db2f791..61cf7021313 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/209/IdentityScope.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/codebuff/209/IdentityScope.java\n@@ -18,9 +18,7 @@ package org.genxdm.processor.w3c.xs.validation.impl;\n import java.util.ArrayList;\n import java.util.HashMap;\n import java.util.List;\n-\n import javax.xml.namespace.QName;\n-\n import org.genxdm.exceptions.PreCondition;\n import org.genxdm.typed.types.AtomBridge;\n import org.genxdm.xs.constraints.IdentityConstraint;\n@@ -38,195 +36,204 @@ import org.genxdm.xs.types.Type;\n  * Not surprisingly, this evaluation class mimicks the identity-constraint by having a selector and a list of fields\n  * that are of type {@link IdentitySelector}. The selector is established immediately (upon initialization)\n  */\n+\n abstract class IdentityScope\n {\n-\tprivate final IdentityConstraint m_constraint;\n-\tprotected final SchemaExceptionHandler m_errorHandler;\n-\n-\t/**\n-\t * The element information that is the context element for the xs:selector.\n-\t */\n-\t@SuppressWarnings(\"unused\")\n-\tprivate final int m_elementIndex;\n-\n-\t/**\n-\t * There is one {selector} evaluator for this identity scope. However, the {selector} evaluator matches zero-or-more\n-\t * target nodes (element information items) and for each element information item we will have a set of {field}\n-\t * evaluators. So from a scope perspective the {field} evaluators are part of a map keyed by the element information\n-\t * item.\n-\t */\n-\tprivate final IdentitySelector m_selectorEval;\n-\tfinal HashMap<Integer, Integer> m_boundFields = new HashMap<Integer, Integer>();\n-\tfinal HashMap<Integer, ArrayList<IdentityField>> m_fieldEvals = new HashMap<Integer, ArrayList<IdentityField>>();\n-\n-\t/**\n-\t * A map from a key (tuple of values) to Boolean.TRUE | list of {@link IdentityDanglingReference}.\n-\t */\n-\t// protected HashMap<IdentityTuple<A>, IdentityVariant<A>>\n-\t// m_qualifiedTargets;\n-\tprotected final LocationInSchema m_location;\n-\n-\tprotected IdentityScope(final int elementIndex, final IdentityConstraint constraint, final SchemaExceptionHandler errorHandler, final LocationInSchema location)\n-\t{\n-\t\tm_elementIndex = elementIndex;\n-\t\tm_constraint = PreCondition.assertArgumentNotNull(constraint);\n-\t\tm_errorHandler = PreCondition.assertArgumentNotNull(errorHandler);\n-\n-\t\tm_location = location;\n-\n-\t\tm_selectorEval = new IdentitySelector(this, m_constraint.getSelector());\n-\t}\n-\n-\t/**\n-\t * Called when its full complement of keys have been completed.\n-\t * \n-\t * @param elementIndex\n-\t *            The index of the element that is the context for xs:field evaluation.\n-\t * @param keyValues\n-\t *            The key values.\n-\t */\n-\tprotected abstract void onKeysComplete(final ArrayList<IdentityKey> keyValues, final int elementIndex) throws AbortException;\n-\n-\t/**\n-\t * Called when the selector goes out of scope.\n-\t * \n-\t * @param elementIndex\n-\t *            The index of the element that is the context for xs:field evaluation.\n-\t */\n-\tprotected abstract void onScopeEnd(final int elementIndex, final Locatable location) throws AbortException;\n-\n-\tpublic void startElement(final QName elementName, final int elementIndex, final Type elementType, final Locatable locatable) throws AbortException\n-\t{\n-\t\tfor (final ArrayList<IdentityField> contextFields : m_fieldEvals.values())\n-\t\t{\n-\t\t\tfor (final IdentityField field : contextFields)\n-\t\t\t{\n-\t\t\t\tfield.startElement(elementName, elementIndex, elementType, locatable);\n-\t\t\t}\n-\t\t}\n-\n-\t\tm_selectorEval.startElement(elementName, elementIndex);\n-\t}\n-\n-\tpublic <A> void attribute(final QName attributeName, final List<? extends A> actualValue, final int attributeIndex, final SimpleType attributeType, final Locatable locatable, final AtomBridge<A> atomBridge) throws AbortException\n-\t{\n-\t\tfor (final ArrayList<IdentityField> contextFields : m_fieldEvals.values())\n-\t\t{\n-\t\t\tfor (final IdentityField field : contextFields)\n-\t\t\t{\n-\t\t\t\tfield.attribute(attributeName, actualValue, attributeIndex, attributeType, locatable, atomBridge);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic <A> void text(final List<? extends A> actualValue, final SimpleType actualType, final int textIndex, final Locatable locatable, final AtomBridge<A> atomBridge) throws AbortException\n-\t{\n-\t\tfor (final ArrayList<IdentityField> contextFields : m_fieldEvals.values())\n-\t\t{\n-\t\t\tfor (final IdentityField field : contextFields)\n-\t\t\t{\n-\t\t\t\tfield.text(actualValue, actualType, textIndex, locatable, atomBridge);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic void endElement(final QName elementName, final int elementIndex, final Locatable locatable) throws AbortException\n-\t{\n-\t\tm_selectorEval.endElement(elementName, elementIndex, locatable);\n-\n-\t\tfor (final ArrayList<IdentityField> contextFields : m_fieldEvals.values())\n-\t\t{\n-\t\t\tfor (final IdentityField field : contextFields)\n-\t\t\t{\n-\t\t\t\tfield.endElement(elementName, elementIndex, locatable);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic IdentityConstraint getConstraint()\n-\t{\n-\t\treturn m_constraint;\n-\t}\n-\n-\t/**\n-\t * We've found and element that matches the {selector}, so install handlers for the fields. This only needs to be\n-\t * done once for a given selected element, therby accounting for duplicates caused by the union(s) in the XPath\n-\t * {selector} expression.\n-\t * \n-\t * @param elementName\n-\t *            The name of the selected element.\n-\t * @param elementIndex\n-\t *            The index of the selected element.\n-\t */\n-\tpublic void startSelectorElement(final QName elementName, final int elementIndex)\n-\t{\n-\t\t// Avoid duplication caused by XPath unions.\n-\t\tif (!m_boundFields.containsKey(elementIndex))\n-\t\t{\n-\t\t\t// No fields have been bound yet for this element.\n-\t\t\tm_boundFields.put(elementIndex, 0);\n-\n-\t\t\tfinal ArrayList<IdentityField> fieldEvals = new ArrayList<IdentityField>();\n-\t\t\tfor (final RestrictedXPath path : getConstraint().getFields())\n-\t\t\t{\n-\t\t\t\tfieldEvals.add(new IdentityField(path, elementIndex, this, m_errorHandler));\n-\t\t\t}\n-\t\t\tm_fieldEvals.put(elementIndex, fieldEvals);\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\t// A redundant union in the XPath expression caused duplication.\n-\t\t\t// Ignore.\n-\t\t}\n-\t}\n-\n-\tpublic void endSelectorElement(final QName elementName, final int elementIndex, final Locatable location) throws AbortException\n-\t{\n-\t\tif (m_boundFields.containsKey(elementIndex))\n-\t\t{\n-\t\t\ttry\n-\t\t\t{\n-\t\t\t\tonScopeEnd(elementIndex, location);\n-\t\t\t}\n-\t\t\tfinally\n-\t\t\t{\n-\t\t\t\tm_fieldEvals.remove(elementIndex);\n-\t\t\t\tm_boundFields.remove(elementIndex);\n-\t\t\t}\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\t// We must have duplicates and removed it already.\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * When all fields have been gathered, report back up to the scope. This method is called by an IdentityField when\n-\t * its's value has been set.\n-\t * \n-\t * @param changedField\n-\t *            The {@link IdentityField} that had its value set.\n-\t */\n-\t<A> void onFieldValueSet(final IdentityField changedField, final int elementIndex, final AtomBridge<A> atomBridge) throws AbortException\n-\t{\n-\t\t// Note: We don't currently use the \"changedField\" parameter.\n-\t\tfinal ArrayList<IdentityField> elementHandlers = m_fieldEvals.get(elementIndex);\n-\n-\t\t// Increment the number of fields that have been bound.\n-\t\tfinal int boundFields = m_boundFields.get(elementIndex) + 1;\n-\t\tm_boundFields.put(elementIndex, boundFields);\n-\n-\t\t// When all the fields have been set, gather the values together and\n-\t\t// notify the scope.\n-\t\tif (boundFields == elementHandlers.size())\n-\t\t{\n-\t\t\tfinal ArrayList<IdentityKey> fieldValues = new ArrayList<IdentityKey>(boundFields);\n-\t\t\tfor (final IdentityField field : elementHandlers)\n-\t\t\t{\n-//\t\t\t\tfieldValues.add(new IdentityKey(field.getTypedValue(atomBridge)));\n+    private final IdentityConstraint m_constraint;\n+    protected final SchemaExceptionHandler m_errorHandler;\n+\n+    /**\n+     * The element information that is the context element for the xs:selector.\n+     */\n+\n+    @SuppressWarnings(\"unused\")\n+    private final int m_elementIndex;\n+\n+    /**\n+     * There is one {selector} evaluator for this identity scope. However, the {selector} evaluator matches zero-or-more\n+     * target nodes (element information items) and for each element information item we will have a set of {field}\n+     * evaluators. So from a scope perspective the {field} evaluators are part of a map keyed by the element information\n+     * item.\n+     */\n+    private final IdentitySelector m_selectorEval;\n+\n+    final HashMap<Integer, Integer> m_boundFields = new HashMap<Integer, Integer>();\n+\n+    final HashMap<Integer, ArrayList<IdentityField>> m_fieldEvals = new HashMap<Integer, ArrayList<IdentityField>>();\n+\n+    /**\n+     * A map from a key (tuple of values) to Boolean.TRUE | list of {@link IdentityDanglingReference}.\n+     */\n+    // protected HashMap<IdentityTuple<A>, IdentityVariant<A>>\n+    // m_qualifiedTargets;\n+    protected final LocationInSchema m_location;\n+\n+    protected IdentityScope(final int elementIndex, final IdentityConstraint constraint, final SchemaExceptionHandler errorHandler, final LocationInSchema location)\n+    {\n+        m_elementIndex = elementIndex;\n+        m_constraint = PreCondition.assertArgumentNotNull(constraint);\n+        m_errorHandler = PreCondition.assertArgumentNotNull(errorHandler);\n+        m_location = location;\n+        m_selectorEval = new IdentitySelector(this, m_constraint.getSelector());\n+    }\n+\n+    /**\n+     * Called when its full complement of keys have been completed.\n+     * \n+     * @param elementIndex\n+     *            The index of the element that is the context for xs:field evaluation.\n+     * @param keyValues\n+     *            The key values.\n+     */\n+\n+    protected abstract void onKeysComplete(final ArrayList<IdentityKey> keyValues, final int elementIndex)\n+        throws AbortException;\n+\n+    /**\n+     * Called when the selector goes out of scope.\n+     * \n+     * @param elementIndex\n+     *            The index of the element that is the context for xs:field evaluation.\n+     */\n+    protected abstract void onScopeEnd(final int elementIndex, final Locatable location)\n+        throws AbortException;\n+    public void startElement(final QName elementName, final int elementIndex, final Type elementType, final Locatable locatable)\n+        throws AbortException\n+    {\n+        for (final ArrayList<IdentityField> contextFields : m_fieldEvals.values())\n+        {\n+            for (final IdentityField field : contextFields)\n+            {\n+                field.startElement(elementName, elementIndex, elementType, locatable);\n+            }\n+        }\n+        m_selectorEval.startElement(elementName, elementIndex);\n+    }\n+\n+    public <A> void attribute(final QName attributeName, final List<? extends A> actualValue, final int attributeIndex, final SimpleType attributeType, final Locatable locatable, final AtomBridge<A> atomBridge) throws AbortException\n+    {\n+        for (final ArrayList<IdentityField> contextFields : m_fieldEvals.values())\n+        {\n+            for (final IdentityField field : contextFields)\n+            {\n+                field.attribute(attributeName, actualValue, attributeIndex, attributeType, locatable, atomBridge);\n+            }\n+        }\n+    }\n+\n+    public <A> void text(final List<? extends A> actualValue, final SimpleType actualType, final int textIndex, final Locatable locatable, final AtomBridge<A> atomBridge) throws AbortException\n+    {\n+        for (final ArrayList<IdentityField> contextFields : m_fieldEvals.values())\n+        {\n+            for (final IdentityField field : contextFields)\n+            {\n+                field.text(actualValue, actualType, textIndex, locatable, atomBridge);\n+            }\n+        }\n+    }\n+\n+    public void endElement(final QName elementName, final int elementIndex, final Locatable locatable)\n+        throws AbortException\n+    {\n+        m_selectorEval.endElement(elementName, elementIndex, locatable);\n+        for (final ArrayList<IdentityField> contextFields : m_fieldEvals.values())\n+        {\n+            for (final IdentityField field : contextFields)\n+            {\n+                field.endElement(elementName, elementIndex, locatable);\n+            }\n+        }\n+    }\n+\n+    public IdentityConstraint getConstraint()\n+    {\n+        return m_constraint;\n+    }\n+\n+    /**\n+     * We've found and element that matches the {selector}, so install handlers for the fields. This only needs to be\n+     * done once for a given selected element, therby accounting for duplicates caused by the union(s) in the XPath\n+     * {selector} expression.\n+     * \n+     * @param elementName\n+     *            The name of the selected element.\n+     * @param elementIndex\n+     *            The index of the selected element.\n+     */\n+\n+    public void startSelectorElement(final QName elementName, final int elementIndex)\n+    {\n+        // Avoid duplication caused by XPath unions.\n+        if (!m_boundFields.containsKey(elementIndex))\n+        {\n+            // No fields have been bound yet for this element.\n+            m_boundFields.put(elementIndex, 0);\n+\n+            final ArrayList<IdentityField> fieldEvals = new ArrayList<IdentityField>();\n+            for (final RestrictedXPath path : getConstraint().getFields())\n+            {\n+                fieldEvals.add(new IdentityField(path, elementIndex, this, m_errorHandler));\n+            }\n+            m_fieldEvals.put(elementIndex, fieldEvals);\n+        }\n+        else\n+        {\n+            // A redundant union in the XPath expression caused duplication.\n+            // Ignore.\n+\n+        }\n+    }\n+\n+    public void endSelectorElement(final QName elementName, final int elementIndex, final Locatable location)\n+        throws AbortException\n+    {\n+        if (m_boundFields.containsKey(elementIndex))\n+        {\n+            try\n+            {\n+                onScopeEnd(elementIndex, location);\n+            }\n+            finally\n+            {\n+                m_fieldEvals.remove(elementIndex);\n+                m_boundFields.remove(elementIndex);\n+            }\n+        }\n+        else\n+        {\n+            // We must have duplicates and removed it already.\n+\n+        }\n+    }\n+\n+    /**\n+     * When all fields have been gathered, report back up to the scope. This method is called by an IdentityField when\n+     * its's value has been set.\n+     * \n+     * @param changedField\n+     *            The {@link IdentityField} that had its value set.\n+     */\n+\n+    <A> void onFieldValueSet(final IdentityField changedField, final int elementIndex, final AtomBridge<A> atomBridge) throws AbortException\n+    {\n+        // Note: We don't currently use the \"changedField\" parameter.\n+        final ArrayList<IdentityField> elementHandlers = m_fieldEvals.get(elementIndex);\n+\n+        // Increment the number of fields that have been bound.\n+        final int boundFields = m_boundFields.get(elementIndex) + 1;\n+        m_boundFields.put(elementIndex, boundFields);\n+\n+        // When all the fields have been set, gather the values together and\n+        // notify the scope.\n+        if (boundFields == elementHandlers.size())\n+        {\n+            final ArrayList<IdentityKey> fieldValues = new ArrayList<IdentityKey>(boundFields);\n+            for (final IdentityField field : elementHandlers)\n+            {\n+//              fieldValues.add(new IdentityKey(field.getTypedValue(atomBridge)));\n                 fieldValues.add(new IdentityKey(field.m_value));\n-\t\t\t}\n-\t\t\tonKeysComplete(fieldValues, elementIndex);\n-\t\t}\n-\t}\n-}\n+            }\n+            onKeysComplete(fieldValues, elementIndex);\n+        }\n+    }\n+}\n\\ No newline at end of file\n",
            "diff_size": 200
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "44",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/209/IdentityScope.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_random/209/IdentityScope.java\nindex f668db2f791..7787e3a7a68 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/209/IdentityScope.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_random/209/IdentityScope.java\n@@ -40,7 +40,7 @@ import org.genxdm.xs.types.Type;\n  */\n abstract class IdentityScope\n {\n-\tprivate final IdentityConstraint m_constraint;\n+private final IdentityConstraint m_constraint;\n \tprotected final SchemaExceptionHandler m_errorHandler;\n \n \t/**\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "44",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/209/IdentityScope.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_three_grams/209/IdentityScope.java\nindex f668db2f791..bbd436ace88 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/209/IdentityScope.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_three_grams/209/IdentityScope.java\n@@ -40,7 +40,7 @@ import org.genxdm.xs.types.Type;\n  */\n abstract class IdentityScope\n {\n-\tprivate final IdentityConstraint m_constraint;\n+    private final IdentityConstraint m_constraint;\n \tprotected final SchemaExceptionHandler m_errorHandler;\n \n \t/**\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "codebuff"
    ],
    "not_repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "styler_random",
        "styler_three_grams"
    ]
}